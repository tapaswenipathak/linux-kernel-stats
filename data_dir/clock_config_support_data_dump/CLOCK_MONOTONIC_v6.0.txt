commit c4fd07cd5e7ecd18aacd295d4de7bb309c74f601
Author: James Morse <james.morse@arm.com>
Date:   Tue Jan 17 15:16:32 2023 +0000

    ia64: fix build error due to switch case label appearing next to declaration
    
    commit 6f28a2613497fc587e347afa99fa2c52230678a7 upstream.
    
    Since commit aa06a9bd8533 ("ia64: fix clock_getres(CLOCK_MONOTONIC) to
    report ITC frequency"), gcc 10.1.0 fails to build ia64 with the gnomic:
    | ../arch/ia64/kernel/sys_ia64.c: In function 'ia64_clock_getres':
    | ../arch/ia64/kernel/sys_ia64.c:189:3: error: a label can only be part of a statement and a declaration is not a statement
    |   189 |   s64 tick_ns = DIV_ROUND_UP(NSEC_PER_SEC, local_cpu_data->itc_freq);
    
    This line appears immediately after a case label in a switch.
    
    Move the declarations out of the case, to the top of the function.
    
    Link: https://lkml.kernel.org/r/20230117151632.393836-1-james.morse@arm.com
    Fixes: aa06a9bd8533 ("ia64: fix clock_getres(CLOCK_MONOTONIC) to report ITC frequency")
    Signed-off-by: James Morse <james.morse@arm.com>
    Reviewed-by: Sergei Trofimovich <slyich@gmail.com>
    Cc: Émeric Maschino <emeric.maschino@gmail.com>
    Cc: matoro <matoro_mailinglist_kernel@matoro.tk>
    Cc: John Paul Adrian Glaubitz <glaubitz@physik.fu-berlin.de>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 6f28a2613497fc587e347afa99fa2c52230678a7
Author: James Morse <james.morse@arm.com>
Date:   Tue Jan 17 15:16:32 2023 +0000

    ia64: fix build error due to switch case label appearing next to declaration
    
    Since commit aa06a9bd8533 ("ia64: fix clock_getres(CLOCK_MONOTONIC) to
    report ITC frequency"), gcc 10.1.0 fails to build ia64 with the gnomic:
    | ../arch/ia64/kernel/sys_ia64.c: In function 'ia64_clock_getres':
    | ../arch/ia64/kernel/sys_ia64.c:189:3: error: a label can only be part of a statement and a declaration is not a statement
    |   189 |   s64 tick_ns = DIV_ROUND_UP(NSEC_PER_SEC, local_cpu_data->itc_freq);
    
    This line appears immediately after a case label in a switch.
    
    Move the declarations out of the case, to the top of the function.
    
    Link: https://lkml.kernel.org/r/20230117151632.393836-1-james.morse@arm.com
    Fixes: aa06a9bd8533 ("ia64: fix clock_getres(CLOCK_MONOTONIC) to report ITC frequency")
    Signed-off-by: James Morse <james.morse@arm.com>
    Reviewed-by: Sergei Trofimovich <slyich@gmail.com>
    Cc: Émeric Maschino <emeric.maschino@gmail.com>
    Cc: matoro <matoro_mailinglist_kernel@matoro.tk>
    Cc: John Paul Adrian Glaubitz <glaubitz@physik.fu-berlin.de>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>

commit aa06a9bd853306c239f759018fb227d7e8f4e203
Author: Sergei Trofimovich <slyich@gmail.com>
Date:   Sat Aug 20 19:18:13 2022 +0100

    ia64: fix clock_getres(CLOCK_MONOTONIC) to report ITC frequency
    
    clock_gettime(CLOCK_MONOTONIC, &tp) is very precise on ia64 as it uses ITC
    (similar to rdtsc on x86).  It's not quite a hrtimer as it is a few times
    slower than 1ns.  Usually 2-3ns.
    
    clock_getres(CLOCK_MONOTONIC, &res) never reflected that fact and reported
    0.04s precision (1/HZ value).
    
    In https://bugs.gentoo.org/596382 gstreamer's test suite failed loudly
    when it noticed precision discrepancy.
    
    Before the change:
    
        clock_getres(CLOCK_MONOTONIC, &res) reported 250Hz precision.
    
    After the change:
    
        clock_getres(CLOCK_MONOTONIC, &res) reports ITC (400Mhz) precision.
    
    The patch is based on matoro's fix. I added a bit of explanation why we
    need to special-case arch-specific clock_getres().
    
    [akpm@linux-foundation.org: coding-style cleanups]
    Link: https://lkml.kernel.org/r/20220820181813.2275195-1-slyich@gmail.com
    Signed-off-by: Sergei Trofimovich <slyich@gmail.com>
    Cc: matoro <matoro_mailinglist_kernel@matoro.tk>
    Cc: Émeric Maschino <emeric.maschino@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>

commit 0f85e74756b5e85a0de6dce7d8c07f0b4e1f7726
Author: Daniil Lunev <dlunev@chromium.org>
Date:   Thu Aug 4 06:50:34 2022 +1000

    scsi: ufs: core: Use local_clock() for debugging timestamps
    
    CLOCK_MONOTONIC is not advanced when the system is in suspend. This becomes
    problematic when debugging issues related to suspend-resume: the timestamps
    printed by ufshcd_print_trs can not be correlated with dmesg entries, which
    are timestamped with local_clock().
    
    Change the used clock to local_clock() for the informational timestamp
    variables and adds mirroring *_local_clock instances for variables used in
    subsequent derevations (to not change the semantics of those derevations).
    
    Link: https://lore.kernel.org/r/20220804065019.v5.1.I699244ea7efbd326a34a6dfd9b5a31e78400cf68@changeid
    Acked-by: Stanley Chu <stanley.chu@mediatek.com>
    Acked-by: Avri Altman <avri.altman@wdc.com>
    Signed-off-by: Daniil Lunev <dlunev@chromium.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

commit c8996c98f703b09afe77a1d247dae691c9849dc1
Author: Jesper Dangaard Brouer <brouer@redhat.com>
Date:   Tue Aug 9 08:08:02 2022 +0200

    bpf: Add BPF-helper for accessing CLOCK_TAI
    
    Commit 3dc6ffae2da2 ("timekeeping: Introduce fast accessor to clock tai")
    introduced a fast and NMI-safe accessor for CLOCK_TAI. Especially in time
    sensitive networks (TSN), where all nodes are synchronized by Precision Time
    Protocol (PTP), it's helpful to have the possibility to generate timestamps
    based on CLOCK_TAI instead of CLOCK_MONOTONIC. With a BPF helper for TAI in
    place, it becomes very convenient to correlate activity across different
    machines in the network.
    
    Use cases for such a BPF helper include functionalities such as Tx launch
    time (e.g. ETF and TAPRIO Qdiscs) and timestamping.
    
    Note: CLOCK_TAI is nothing new per se, only the NMI-safe variant of it is.
    
    Signed-off-by: Jesper Dangaard Brouer <brouer@redhat.com>
    [Kurt: Wrote changelog and renamed helper]
    Signed-off-by: Kurt Kanzenbach <kurt@linutronix.de>
    Link: https://lore.kernel.org/r/20220809060803.5773-2-kurt@linutronix.de
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>

commit 4f0685f22c8b9e296f5ae37bef11c26d2b3ba109
Author: Kurt Kanzenbach <kurt@linutronix.de>
Date:   Thu Apr 28 08:24:32 2022 +0200

    timekeeping: Mark NMI safe time accessors as notrace
    
    commit 2c33d775ef4c25c0e1e1cc0fd5496d02f76bfa20 upstream.
    
    Mark the CLOCK_MONOTONIC fast time accessors as notrace. These functions are
    used in tracing to retrieve timestamps, so they should not recurse.
    
    Fixes: 4498e7467e9e ("time: Parametrize all tk_fast_mono users")
    Fixes: f09cb9a1808e ("time: Introduce tk_fast_raw")
    Reported-by: Steven Rostedt <rostedt@goodmis.org>
    Signed-off-by: Kurt Kanzenbach <kurt@linutronix.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/20220426175338.3807ca4f@gandalf.local.home/
    Link: https://lore.kernel.org/r/20220428062432.61063-1-kurt@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 07adb69545486b16540c02a538fed5e5f250cd86
Author: Kurt Kanzenbach <kurt@linutronix.de>
Date:   Thu Apr 28 08:24:32 2022 +0200

    timekeeping: Mark NMI safe time accessors as notrace
    
    commit 2c33d775ef4c25c0e1e1cc0fd5496d02f76bfa20 upstream.
    
    Mark the CLOCK_MONOTONIC fast time accessors as notrace. These functions are
    used in tracing to retrieve timestamps, so they should not recurse.
    
    Fixes: 4498e7467e9e ("time: Parametrize all tk_fast_mono users")
    Fixes: f09cb9a1808e ("time: Introduce tk_fast_raw")
    Reported-by: Steven Rostedt <rostedt@goodmis.org>
    Signed-off-by: Kurt Kanzenbach <kurt@linutronix.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/20220426175338.3807ca4f@gandalf.local.home/
    Link: https://lore.kernel.org/r/20220428062432.61063-1-kurt@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 2c33d775ef4c25c0e1e1cc0fd5496d02f76bfa20
Author: Kurt Kanzenbach <kurt@linutronix.de>
Date:   Thu Apr 28 08:24:32 2022 +0200

    timekeeping: Mark NMI safe time accessors as notrace
    
    Mark the CLOCK_MONOTONIC fast time accessors as notrace. These functions are
    used in tracing to retrieve timestamps, so they should not recurse.
    
    Fixes: 4498e7467e9e ("time: Parametrize all tk_fast_mono users")
    Fixes: f09cb9a1808e ("time: Introduce tk_fast_raw")
    Reported-by: Steven Rostedt <rostedt@goodmis.org>
    Signed-off-by: Kurt Kanzenbach <kurt@linutronix.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/20220426175338.3807ca4f@gandalf.local.home/
    Link: https://lore.kernel.org/r/20220428062432.61063-1-kurt@linutronix.de

commit 18e65ab351cf17b0af65e3d1e5d4cbbb7b8e3568
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Mar 8 16:44:25 2022 +0100

    power: ab8500_chargalg: Use CLOCK_MONOTONIC
    
    [ Upstream commit c22fca40522e2be8af168f3087d87d85e404ea72 ]
    
    The HRTimer in the AB8500 charging code is using CLOCK_REALTIME
    to set an alarm some hours forward in time +/- 5 min for a safety
    timer.
    
    I have observed that this will sometimes fire sporadically
    early when charging a battery with the result that
    charging stops.
    
    As CLOCK_REALTIME can be subject to adjustments of time from
    sources such as NTP, this cannot be trusted and will likely
    for example fire events if the clock is set forward some hours
    by say NTP.
    
    Use CLOCK_MONOTONIC as indicated in other instances and the
    problem goes away. Also initialize the timer to REL mode
    as this is what will be used later.
    
    Fixes: 257107ae6b9b ("ab8500-chargalg: Use hrtimer")
    Cc: Lee Jones <lee.jones@linaro.org>
    Suggested-by: Matti Vaittinen <mazziesaccount@gmail.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Reviewed-by: Matti Vaittinen <matti.vaittinen@fi.rohmeurope.com>
    Signed-off-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit e0bd5424aa8016c2a6a9001070cda184bff08b3e
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Mar 8 16:44:25 2022 +0100

    power: ab8500_chargalg: Use CLOCK_MONOTONIC
    
    [ Upstream commit c22fca40522e2be8af168f3087d87d85e404ea72 ]
    
    The HRTimer in the AB8500 charging code is using CLOCK_REALTIME
    to set an alarm some hours forward in time +/- 5 min for a safety
    timer.
    
    I have observed that this will sometimes fire sporadically
    early when charging a battery with the result that
    charging stops.
    
    As CLOCK_REALTIME can be subject to adjustments of time from
    sources such as NTP, this cannot be trusted and will likely
    for example fire events if the clock is set forward some hours
    by say NTP.
    
    Use CLOCK_MONOTONIC as indicated in other instances and the
    problem goes away. Also initialize the timer to REL mode
    as this is what will be used later.
    
    Fixes: 257107ae6b9b ("ab8500-chargalg: Use hrtimer")
    Cc: Lee Jones <lee.jones@linaro.org>
    Suggested-by: Matti Vaittinen <mazziesaccount@gmail.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Reviewed-by: Matti Vaittinen <matti.vaittinen@fi.rohmeurope.com>
    Signed-off-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 2334f49e937646bde20f3c064f1da007d073a1f4
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Mar 8 16:44:25 2022 +0100

    power: ab8500_chargalg: Use CLOCK_MONOTONIC
    
    [ Upstream commit c22fca40522e2be8af168f3087d87d85e404ea72 ]
    
    The HRTimer in the AB8500 charging code is using CLOCK_REALTIME
    to set an alarm some hours forward in time +/- 5 min for a safety
    timer.
    
    I have observed that this will sometimes fire sporadically
    early when charging a battery with the result that
    charging stops.
    
    As CLOCK_REALTIME can be subject to adjustments of time from
    sources such as NTP, this cannot be trusted and will likely
    for example fire events if the clock is set forward some hours
    by say NTP.
    
    Use CLOCK_MONOTONIC as indicated in other instances and the
    problem goes away. Also initialize the timer to REL mode
    as this is what will be used later.
    
    Fixes: 257107ae6b9b ("ab8500-chargalg: Use hrtimer")
    Cc: Lee Jones <lee.jones@linaro.org>
    Suggested-by: Matti Vaittinen <mazziesaccount@gmail.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Reviewed-by: Matti Vaittinen <matti.vaittinen@fi.rohmeurope.com>
    Signed-off-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 8eb48fc7c54ed627a693a205570f0eceea64274c
Merge: 148a65047695 c22fca40522e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Mar 25 13:31:02 2022 -0700

    Merge tag 'for-v5.18' of git://git.kernel.org/pub/scm/linux/kernel/git/sre/linux-power-supply
    
    Pull power supply and reset updates from Sebastian Reichel:
     "Power-supply core:
    
       - Introduce "Bypass" charging type used by USB PPS standard
    
       - Refactor power_supply_set_input_current_limit_from_supplier()
    
       - Add fwnode support to power_supply_get_battery_info()
    
      Drivers:
    
       - ab8500: continue migrating towards using standard core APIs
    
       - axp288 fuel-gauge: refactor driver to be fully resource managed
    
       - battery-samsung-sdi: new in-kernel provider for (constant) Samsung
         battery info
    
       - bq24190: disable boost regulator on shutdown
    
       - bq24190: add support for battery-info on ACPI based systems
    
       - bq25890: prepare driver for usage on ACPI based systems
    
       - bq25890: add boost regulator support
    
       - cpcap-battery: add NVMEM based battery detection support
    
       - injoinic ip5xxx: new driver for power bank IC
    
       - upi ug3105: new battery driver
    
       - misc small improvements and fixes"
    
    * tag 'for-v5.18' of git://git.kernel.org/pub/scm/linux/kernel/git/sre/linux-power-supply: (94 commits)
      power: ab8500_chargalg: Use CLOCK_MONOTONIC
      power: supply: Add a driver for Injoinic power bank ICs
      dt-bindings: trivial-devices: Add Injoinic power bank ICs
      dt-bindings: vendor-prefixes: Add Injoinic
      power: supply: ab8500: Remove unused variable
      power: supply: da9150-fg: Remove unnecessary print function dev_err()
      power: supply: ab8500: fix a handful of spelling mistakes
      power: supply: ab8500_fg: Account for line impedance
      dt-bindings: power: supply: ab8500_fg: Add line impedance
      power: supply: axp20x_usb_power: fix platform_get_irq.cocci warnings
      power: supply: axp20x_ac_power: fix platform_get_irq.cocci warning
      power: supply: wm8350-power: Add missing free in free_charger_irq
      power: supply: wm8350-power: Handle error for wm8350_register_irq
      power: supply: Static data for Samsung batteries
      power: supply: ab8500_fg: Use VBAT-to-Ri if possible
      power: supply: Support VBAT-to-Ri lookup tables
      power: supply: ab8500: Standardize BTI resistance
      power: supply: ab8500: Standardize alert mode charging
      power: supply: ab8500: Standardize maintenance charging
      power: supply: bq24190_charger: Delay applying charge_type changes when OTG 5V Vbus boost is on
      ...

commit c22fca40522e2be8af168f3087d87d85e404ea72
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Mar 8 16:44:25 2022 +0100

    power: ab8500_chargalg: Use CLOCK_MONOTONIC
    
    The HRTimer in the AB8500 charging code is using CLOCK_REALTIME
    to set an alarm some hours forward in time +/- 5 min for a safety
    timer.
    
    I have observed that this will sometimes fire sporadically
    early when charging a battery with the result that
    charging stops.
    
    As CLOCK_REALTIME can be subject to adjustments of time from
    sources such as NTP, this cannot be trusted and will likely
    for example fire events if the clock is set forward some hours
    by say NTP.
    
    Use CLOCK_MONOTONIC as indicated in other instances and the
    problem goes away. Also initialize the timer to REL mode
    as this is what will be used later.
    
    Fixes: 257107ae6b9b ("ab8500-chargalg: Use hrtimer")
    Cc: Lee Jones <lee.jones@linaro.org>
    Suggested-by: Matti Vaittinen <mazziesaccount@gmail.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Reviewed-by: Matti Vaittinen <matti.vaittinen@fi.rohmeurope.com>
    Signed-off-by: Sebastian Reichel <sebastian.reichel@collabora.com>

commit c5664d508674c77a52d311af8b1e11d08ac0cf4b
Author: Yu Liao <liaoyu15@huawei.com>
Date:   Mon Dec 13 21:57:27 2021 +0800

    timekeeping: Really make sure wall_to_monotonic isn't positive
    
    commit 4e8c11b6b3f0b6a283e898344f154641eda94266 upstream.
    
    Even after commit e1d7ba873555 ("time: Always make sure wall_to_monotonic
    isn't positive") it is still possible to make wall_to_monotonic positive
    by running the following code:
    
        int main(void)
        {
            struct timespec time;
    
            clock_gettime(CLOCK_MONOTONIC, &time);
            time.tv_nsec = 0;
            clock_settime(CLOCK_REALTIME, &time);
            return 0;
        }
    
    The reason is that the second parameter of timespec64_compare(), ts_delta,
    may be unnormalized because the delta is calculated with an open coded
    substraction which causes the comparison of tv_sec to yield the wrong
    result:
    
      wall_to_monotonic = { .tv_sec = -10, .tv_nsec =  900000000 }
      ts_delta          = { .tv_sec =  -9, .tv_nsec = -900000000 }
    
    That makes timespec64_compare() claim that wall_to_monotonic < ts_delta,
    but actually the result should be wall_to_monotonic > ts_delta.
    
    After normalization, the result of timespec64_compare() is correct because
    the tv_sec comparison is not longer misleading:
    
      wall_to_monotonic = { .tv_sec = -10, .tv_nsec =  900000000 }
      ts_delta          = { .tv_sec = -10, .tv_nsec =  100000000 }
    
    Use timespec64_sub() to ensure that ts_delta is normalized, which fixes the
    issue.
    
    Fixes: e1d7ba873555 ("time: Always make sure wall_to_monotonic isn't positive")
    Signed-off-by: Yu Liao <liaoyu15@huawei.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/20211213135727.1656662-1-liaoyu15@huawei.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit a9f2c6af5a601a2e2bf40e5561bedc87a44d9649
Author: Yu Liao <liaoyu15@huawei.com>
Date:   Mon Dec 13 21:57:27 2021 +0800

    timekeeping: Really make sure wall_to_monotonic isn't positive
    
    commit 4e8c11b6b3f0b6a283e898344f154641eda94266 upstream.
    
    Even after commit e1d7ba873555 ("time: Always make sure wall_to_monotonic
    isn't positive") it is still possible to make wall_to_monotonic positive
    by running the following code:
    
        int main(void)
        {
            struct timespec time;
    
            clock_gettime(CLOCK_MONOTONIC, &time);
            time.tv_nsec = 0;
            clock_settime(CLOCK_REALTIME, &time);
            return 0;
        }
    
    The reason is that the second parameter of timespec64_compare(), ts_delta,
    may be unnormalized because the delta is calculated with an open coded
    substraction which causes the comparison of tv_sec to yield the wrong
    result:
    
      wall_to_monotonic = { .tv_sec = -10, .tv_nsec =  900000000 }
      ts_delta          = { .tv_sec =  -9, .tv_nsec = -900000000 }
    
    That makes timespec64_compare() claim that wall_to_monotonic < ts_delta,
    but actually the result should be wall_to_monotonic > ts_delta.
    
    After normalization, the result of timespec64_compare() is correct because
    the tv_sec comparison is not longer misleading:
    
      wall_to_monotonic = { .tv_sec = -10, .tv_nsec =  900000000 }
      ts_delta          = { .tv_sec = -10, .tv_nsec =  100000000 }
    
    Use timespec64_sub() to ensure that ts_delta is normalized, which fixes the
    issue.
    
    Fixes: e1d7ba873555 ("time: Always make sure wall_to_monotonic isn't positive")
    Signed-off-by: Yu Liao <liaoyu15@huawei.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/20211213135727.1656662-1-liaoyu15@huawei.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 62889094939c5fc0c43b207396e51bde905be1ca
Author: Yu Liao <liaoyu15@huawei.com>
Date:   Mon Dec 13 21:57:27 2021 +0800

    timekeeping: Really make sure wall_to_monotonic isn't positive
    
    commit 4e8c11b6b3f0b6a283e898344f154641eda94266 upstream.
    
    Even after commit e1d7ba873555 ("time: Always make sure wall_to_monotonic
    isn't positive") it is still possible to make wall_to_monotonic positive
    by running the following code:
    
        int main(void)
        {
            struct timespec time;
    
            clock_gettime(CLOCK_MONOTONIC, &time);
            time.tv_nsec = 0;
            clock_settime(CLOCK_REALTIME, &time);
            return 0;
        }
    
    The reason is that the second parameter of timespec64_compare(), ts_delta,
    may be unnormalized because the delta is calculated with an open coded
    substraction which causes the comparison of tv_sec to yield the wrong
    result:
    
      wall_to_monotonic = { .tv_sec = -10, .tv_nsec =  900000000 }
      ts_delta          = { .tv_sec =  -9, .tv_nsec = -900000000 }
    
    That makes timespec64_compare() claim that wall_to_monotonic < ts_delta,
    but actually the result should be wall_to_monotonic > ts_delta.
    
    After normalization, the result of timespec64_compare() is correct because
    the tv_sec comparison is not longer misleading:
    
      wall_to_monotonic = { .tv_sec = -10, .tv_nsec =  900000000 }
      ts_delta          = { .tv_sec = -10, .tv_nsec =  100000000 }
    
    Use timespec64_sub() to ensure that ts_delta is normalized, which fixes the
    issue.
    
    Fixes: e1d7ba873555 ("time: Always make sure wall_to_monotonic isn't positive")
    Signed-off-by: Yu Liao <liaoyu15@huawei.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/20211213135727.1656662-1-liaoyu15@huawei.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 8938a4473e6244dff5c4ff3579e7b6d880d1f68c
Author: Yu Liao <liaoyu15@huawei.com>
Date:   Mon Dec 13 21:57:27 2021 +0800

    timekeeping: Really make sure wall_to_monotonic isn't positive
    
    commit 4e8c11b6b3f0b6a283e898344f154641eda94266 upstream.
    
    Even after commit e1d7ba873555 ("time: Always make sure wall_to_monotonic
    isn't positive") it is still possible to make wall_to_monotonic positive
    by running the following code:
    
        int main(void)
        {
            struct timespec time;
    
            clock_gettime(CLOCK_MONOTONIC, &time);
            time.tv_nsec = 0;
            clock_settime(CLOCK_REALTIME, &time);
            return 0;
        }
    
    The reason is that the second parameter of timespec64_compare(), ts_delta,
    may be unnormalized because the delta is calculated with an open coded
    substraction which causes the comparison of tv_sec to yield the wrong
    result:
    
      wall_to_monotonic = { .tv_sec = -10, .tv_nsec =  900000000 }
      ts_delta          = { .tv_sec =  -9, .tv_nsec = -900000000 }
    
    That makes timespec64_compare() claim that wall_to_monotonic < ts_delta,
    but actually the result should be wall_to_monotonic > ts_delta.
    
    After normalization, the result of timespec64_compare() is correct because
    the tv_sec comparison is not longer misleading:
    
      wall_to_monotonic = { .tv_sec = -10, .tv_nsec =  900000000 }
      ts_delta          = { .tv_sec = -10, .tv_nsec =  100000000 }
    
    Use timespec64_sub() to ensure that ts_delta is normalized, which fixes the
    issue.
    
    Fixes: e1d7ba873555 ("time: Always make sure wall_to_monotonic isn't positive")
    Signed-off-by: Yu Liao <liaoyu15@huawei.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/20211213135727.1656662-1-liaoyu15@huawei.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit c0b25c6d1b91da64069c3c364e68775ad6d5437c
Author: Yu Liao <liaoyu15@huawei.com>
Date:   Mon Dec 13 21:57:27 2021 +0800

    timekeeping: Really make sure wall_to_monotonic isn't positive
    
    commit 4e8c11b6b3f0b6a283e898344f154641eda94266 upstream.
    
    Even after commit e1d7ba873555 ("time: Always make sure wall_to_monotonic
    isn't positive") it is still possible to make wall_to_monotonic positive
    by running the following code:
    
        int main(void)
        {
            struct timespec time;
    
            clock_gettime(CLOCK_MONOTONIC, &time);
            time.tv_nsec = 0;
            clock_settime(CLOCK_REALTIME, &time);
            return 0;
        }
    
    The reason is that the second parameter of timespec64_compare(), ts_delta,
    may be unnormalized because the delta is calculated with an open coded
    substraction which causes the comparison of tv_sec to yield the wrong
    result:
    
      wall_to_monotonic = { .tv_sec = -10, .tv_nsec =  900000000 }
      ts_delta          = { .tv_sec =  -9, .tv_nsec = -900000000 }
    
    That makes timespec64_compare() claim that wall_to_monotonic < ts_delta,
    but actually the result should be wall_to_monotonic > ts_delta.
    
    After normalization, the result of timespec64_compare() is correct because
    the tv_sec comparison is not longer misleading:
    
      wall_to_monotonic = { .tv_sec = -10, .tv_nsec =  900000000 }
      ts_delta          = { .tv_sec = -10, .tv_nsec =  100000000 }
    
    Use timespec64_sub() to ensure that ts_delta is normalized, which fixes the
    issue.
    
    Fixes: e1d7ba873555 ("time: Always make sure wall_to_monotonic isn't positive")
    Signed-off-by: Yu Liao <liaoyu15@huawei.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/20211213135727.1656662-1-liaoyu15@huawei.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 848a0e10fde6575bc3fa5253e9afc45444902cc7
Author: Yu Liao <liaoyu15@huawei.com>
Date:   Mon Dec 13 21:57:27 2021 +0800

    timekeeping: Really make sure wall_to_monotonic isn't positive
    
    commit 4e8c11b6b3f0b6a283e898344f154641eda94266 upstream.
    
    Even after commit e1d7ba873555 ("time: Always make sure wall_to_monotonic
    isn't positive") it is still possible to make wall_to_monotonic positive
    by running the following code:
    
        int main(void)
        {
            struct timespec time;
    
            clock_gettime(CLOCK_MONOTONIC, &time);
            time.tv_nsec = 0;
            clock_settime(CLOCK_REALTIME, &time);
            return 0;
        }
    
    The reason is that the second parameter of timespec64_compare(), ts_delta,
    may be unnormalized because the delta is calculated with an open coded
    substraction which causes the comparison of tv_sec to yield the wrong
    result:
    
      wall_to_monotonic = { .tv_sec = -10, .tv_nsec =  900000000 }
      ts_delta          = { .tv_sec =  -9, .tv_nsec = -900000000 }
    
    That makes timespec64_compare() claim that wall_to_monotonic < ts_delta,
    but actually the result should be wall_to_monotonic > ts_delta.
    
    After normalization, the result of timespec64_compare() is correct because
    the tv_sec comparison is not longer misleading:
    
      wall_to_monotonic = { .tv_sec = -10, .tv_nsec =  900000000 }
      ts_delta          = { .tv_sec = -10, .tv_nsec =  100000000 }
    
    Use timespec64_sub() to ensure that ts_delta is normalized, which fixes the
    issue.
    
    Fixes: e1d7ba873555 ("time: Always make sure wall_to_monotonic isn't positive")
    Signed-off-by: Yu Liao <liaoyu15@huawei.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/20211213135727.1656662-1-liaoyu15@huawei.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit ed5dc41bb48e82478525c08c87a4c88847e8570c
Author: Yu Liao <liaoyu15@huawei.com>
Date:   Mon Dec 13 21:57:27 2021 +0800

    timekeeping: Really make sure wall_to_monotonic isn't positive
    
    commit 4e8c11b6b3f0b6a283e898344f154641eda94266 upstream.
    
    Even after commit e1d7ba873555 ("time: Always make sure wall_to_monotonic
    isn't positive") it is still possible to make wall_to_monotonic positive
    by running the following code:
    
        int main(void)
        {
            struct timespec time;
    
            clock_gettime(CLOCK_MONOTONIC, &time);
            time.tv_nsec = 0;
            clock_settime(CLOCK_REALTIME, &time);
            return 0;
        }
    
    The reason is that the second parameter of timespec64_compare(), ts_delta,
    may be unnormalized because the delta is calculated with an open coded
    substraction which causes the comparison of tv_sec to yield the wrong
    result:
    
      wall_to_monotonic = { .tv_sec = -10, .tv_nsec =  900000000 }
      ts_delta          = { .tv_sec =  -9, .tv_nsec = -900000000 }
    
    That makes timespec64_compare() claim that wall_to_monotonic < ts_delta,
    but actually the result should be wall_to_monotonic > ts_delta.
    
    After normalization, the result of timespec64_compare() is correct because
    the tv_sec comparison is not longer misleading:
    
      wall_to_monotonic = { .tv_sec = -10, .tv_nsec =  900000000 }
      ts_delta          = { .tv_sec = -10, .tv_nsec =  100000000 }
    
    Use timespec64_sub() to ensure that ts_delta is normalized, which fixes the
    issue.
    
    Fixes: e1d7ba873555 ("time: Always make sure wall_to_monotonic isn't positive")
    Signed-off-by: Yu Liao <liaoyu15@huawei.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/20211213135727.1656662-1-liaoyu15@huawei.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit e1fe1b10e6aae5fb2df1c065e4fbe655c39e5065
Merge: 909e1d166ca8 4e8c11b6b3f0
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Dec 19 12:23:18 2021 -0800

    Merge tag 'timers_urgent_for_v5.16_rc6' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer fix from Borislav Petkov:
    
     - Make sure the CLOCK_REALTIME to CLOCK_MONOTONIC offset is never
       positive
    
    * tag 'timers_urgent_for_v5.16_rc6' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      timekeeping: Really make sure wall_to_monotonic isn't positive

commit 4e8c11b6b3f0b6a283e898344f154641eda94266
Author: Yu Liao <liaoyu15@huawei.com>
Date:   Mon Dec 13 21:57:27 2021 +0800

    timekeeping: Really make sure wall_to_monotonic isn't positive
    
    Even after commit e1d7ba873555 ("time: Always make sure wall_to_monotonic
    isn't positive") it is still possible to make wall_to_monotonic positive
    by running the following code:
    
        int main(void)
        {
            struct timespec time;
    
            clock_gettime(CLOCK_MONOTONIC, &time);
            time.tv_nsec = 0;
            clock_settime(CLOCK_REALTIME, &time);
            return 0;
        }
    
    The reason is that the second parameter of timespec64_compare(), ts_delta,
    may be unnormalized because the delta is calculated with an open coded
    substraction which causes the comparison of tv_sec to yield the wrong
    result:
    
      wall_to_monotonic = { .tv_sec = -10, .tv_nsec =  900000000 }
      ts_delta          = { .tv_sec =  -9, .tv_nsec = -900000000 }
    
    That makes timespec64_compare() claim that wall_to_monotonic < ts_delta,
    but actually the result should be wall_to_monotonic > ts_delta.
    
    After normalization, the result of timespec64_compare() is correct because
    the tv_sec comparison is not longer misleading:
    
      wall_to_monotonic = { .tv_sec = -10, .tv_nsec =  900000000 }
      ts_delta          = { .tv_sec = -10, .tv_nsec =  100000000 }
    
    Use timespec64_sub() to ensure that ts_delta is normalized, which fixes the
    issue.
    
    Fixes: e1d7ba873555 ("time: Always make sure wall_to_monotonic isn't positive")
    Signed-off-by: Yu Liao <liaoyu15@huawei.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/20211213135727.1656662-1-liaoyu15@huawei.com

commit dffe11e280a42c2501e5b0cdebd85a77f539bb05
Author: Tong Tiangen <tongtiangen@huawei.com>
Date:   Wed Sep 1 03:20:25 2021 +0000

    riscv/vdso: Add support for time namespaces
    
    Implement generic vdso time namespace support which also enables time
    namespaces for riscv. This is quite similar to what arm64 does.
    
    selftest/timens test result:
      1..10
      ok 1 Passed for CLOCK_BOOTTIME (syscall)
      ok 2 Passed for CLOCK_BOOTTIME (vdso)
      ok 3 # SKIP CLOCK_BOOTTIME_ALARM isn't supported
      ok 4 # SKIP CLOCK_BOOTTIME_ALARM isn't supported
      ok 5 Passed for CLOCK_MONOTONIC (syscall)
      ok 6 Passed for CLOCK_MONOTONIC (vdso)
      ok 7 Passed for CLOCK_MONOTONIC_COARSE (syscall)
      ok 8 Passed for CLOCK_MONOTONIC_COARSE (vdso)
      ok 9 Passed for CLOCK_MONOTONIC_RAW (syscall)
      ok 10 Passed for CLOCK_MONOTONIC_RAW (vdso)
      # Totals: pass:8 fail:0 xfail:0 xpass:0 skip:2 error:0
    
    Signed-off-by: Tong Tiangen <tongtiangen@huawei.com>
    Signed-off-by: Palmer Dabbelt <palmerdabbelt@google.com>

commit 50c1df2b56e0f581b1dbf334dbf807d6fb8f77b2
Author: Jens Axboe <axboe@kernel.dk>
Date:   Fri Aug 27 17:11:06 2021 -0600

    io_uring: support CLOCK_BOOTTIME/REALTIME for timeouts
    
    Certain use cases want to use CLOCK_BOOTTIME or CLOCK_REALTIME rather than
    CLOCK_MONOTONIC, instead of the default CLOCK_MONOTONIC.
    
    Add an IORING_TIMEOUT_BOOTTIME and IORING_TIMEOUT_REALTIME flag that
    allows timeouts and linked timeouts to use the selected clock source.
    
    Only one clock source may be selected, and we -EINVAL the request if more
    than one is given. If neither BOOTIME nor REALTIME are selected, the
    previous default of MONOTONIC is used.
    
    Link: https://github.com/axboe/liburing/issues/369
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

commit 1b8a8fba7853905dff29dd7dfe59d1c4e8a33bde
Author: kaixi.fan <fankaixi.li@bytedance.com>
Date:   Wed Aug 18 10:22:15 2021 +0800

    ovs: clear skb->tstamp in forwarding path
    
    [ Upstream commit 01634047bf0d5c2d9b7d8095bb4de1663dbeedeb ]
    
    fq qdisc requires tstamp to be cleared in the forwarding path. Now ovs
    doesn't clear skb->tstamp. We encountered a problem with linux
    version 5.4.56 and ovs version 2.14.1, and packets failed to
    dequeue from qdisc when fq qdisc was attached to ovs port.
    
    Fixes: fb420d5d91c1 ("tcp/fq: move back to CLOCK_MONOTONIC")
    Signed-off-by: kaixi.fan <fankaixi.li@bytedance.com>
    Signed-off-by: xiexiaohui <xiexiaohui.xxh@bytedance.com>
    Reviewed-by: Cong Wang <cong.wang@bytedance.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit eee84eafc3bb78d575b482abe7aaa281cb6bf84f
Author: kaixi.fan <fankaixi.li@bytedance.com>
Date:   Wed Aug 18 10:22:15 2021 +0800

    ovs: clear skb->tstamp in forwarding path
    
    [ Upstream commit 01634047bf0d5c2d9b7d8095bb4de1663dbeedeb ]
    
    fq qdisc requires tstamp to be cleared in the forwarding path. Now ovs
    doesn't clear skb->tstamp. We encountered a problem with linux
    version 5.4.56 and ovs version 2.14.1, and packets failed to
    dequeue from qdisc when fq qdisc was attached to ovs port.
    
    Fixes: fb420d5d91c1 ("tcp/fq: move back to CLOCK_MONOTONIC")
    Signed-off-by: kaixi.fan <fankaixi.li@bytedance.com>
    Signed-off-by: xiexiaohui <xiexiaohui.xxh@bytedance.com>
    Reviewed-by: Cong Wang <cong.wang@bytedance.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit cf4c1661c40ecf0db2db121999f7adbcb0b65c7f
Author: kaixi.fan <fankaixi.li@bytedance.com>
Date:   Wed Aug 18 10:22:15 2021 +0800

    ovs: clear skb->tstamp in forwarding path
    
    [ Upstream commit 01634047bf0d5c2d9b7d8095bb4de1663dbeedeb ]
    
    fq qdisc requires tstamp to be cleared in the forwarding path. Now ovs
    doesn't clear skb->tstamp. We encountered a problem with linux
    version 5.4.56 and ovs version 2.14.1, and packets failed to
    dequeue from qdisc when fq qdisc was attached to ovs port.
    
    Fixes: fb420d5d91c1 ("tcp/fq: move back to CLOCK_MONOTONIC")
    Signed-off-by: kaixi.fan <fankaixi.li@bytedance.com>
    Signed-off-by: xiexiaohui <xiexiaohui.xxh@bytedance.com>
    Reviewed-by: Cong Wang <cong.wang@bytedance.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 01634047bf0d5c2d9b7d8095bb4de1663dbeedeb
Author: kaixi.fan <fankaixi.li@bytedance.com>
Date:   Wed Aug 18 10:22:15 2021 +0800

    ovs: clear skb->tstamp in forwarding path
    
    fq qdisc requires tstamp to be cleared in the forwarding path. Now ovs
    doesn't clear skb->tstamp. We encountered a problem with linux
    version 5.4.56 and ovs version 2.14.1, and packets failed to
    dequeue from qdisc when fq qdisc was attached to ovs port.
    
    Fixes: fb420d5d91c1 ("tcp/fq: move back to CLOCK_MONOTONIC")
    Signed-off-by: kaixi.fan <fankaixi.li@bytedance.com>
    Signed-off-by: xiexiaohui <xiexiaohui.xxh@bytedance.com>
    Reviewed-by: Cong Wang <cong.wang@bytedance.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit c41c926d9dfb3c81da370faf678eb06f7f48ba77
Author: Martin Fäcknitz <faecknitz@hotsplots.de>
Date:   Mon Jul 5 02:03:54 2021 +0200

    MIPS: vdso: Invalid GIC access through VDSO
    
    [ Upstream commit 47ce8527fbba145a7723685bc9a27d9855e06491 ]
    
    Accessing raw timers (currently only CLOCK_MONOTONIC_RAW) through VDSO
    doesn't return the correct time when using the GIC as clock source.
    The address of the GIC mapped page is in this case not calculated
    correctly. The GIC mapped page is calculated from the VDSO data by
    subtracting PAGE_SIZE:
    
      void *get_gic(const struct vdso_data *data) {
        return (void __iomem *)data - PAGE_SIZE;
      }
    
    However, the data pointer is not page aligned for raw clock sources.
    This is because the VDSO data for raw clock sources (CS_RAW = 1) is
    stored after the VDSO data for coarse clock sources (CS_HRES_COARSE = 0).
    Therefore, only the VDSO data for CS_HRES_COARSE is page aligned:
    
      +--------------------+
      |                    |
      | vd[CS_RAW]         | ---+
      | vd[CS_HRES_COARSE] |    |
      +--------------------+    | -PAGE_SIZE
      |                    |    |
      |  GIC mapped page   | <--+
      |                    |
      +--------------------+
    
    When __arch_get_hw_counter() is called with &vd[CS_RAW], get_gic returns
    the wrong address (somewhere inside the GIC mapped page). The GIC counter
    values are not returned which results in an invalid time.
    
    Fixes: a7f4df4e21dd ("MIPS: VDSO: Add implementations of gettimeofday() and clock_gettime()")
    Signed-off-by: Martin Fäcknitz <faecknitz@hotsplots.de>
    Signed-off-by: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 8be8d4ba1c4d4f5fb316957965f9f8d5f110f5b5
Author: Martin Fäcknitz <faecknitz@hotsplots.de>
Date:   Mon Jul 5 02:03:54 2021 +0200

    MIPS: vdso: Invalid GIC access through VDSO
    
    [ Upstream commit 47ce8527fbba145a7723685bc9a27d9855e06491 ]
    
    Accessing raw timers (currently only CLOCK_MONOTONIC_RAW) through VDSO
    doesn't return the correct time when using the GIC as clock source.
    The address of the GIC mapped page is in this case not calculated
    correctly. The GIC mapped page is calculated from the VDSO data by
    subtracting PAGE_SIZE:
    
      void *get_gic(const struct vdso_data *data) {
        return (void __iomem *)data - PAGE_SIZE;
      }
    
    However, the data pointer is not page aligned for raw clock sources.
    This is because the VDSO data for raw clock sources (CS_RAW = 1) is
    stored after the VDSO data for coarse clock sources (CS_HRES_COARSE = 0).
    Therefore, only the VDSO data for CS_HRES_COARSE is page aligned:
    
      +--------------------+
      |                    |
      | vd[CS_RAW]         | ---+
      | vd[CS_HRES_COARSE] |    |
      +--------------------+    | -PAGE_SIZE
      |                    |    |
      |  GIC mapped page   | <--+
      |                    |
      +--------------------+
    
    When __arch_get_hw_counter() is called with &vd[CS_RAW], get_gic returns
    the wrong address (somewhere inside the GIC mapped page). The GIC counter
    values are not returned which results in an invalid time.
    
    Fixes: a7f4df4e21dd ("MIPS: VDSO: Add implementations of gettimeofday() and clock_gettime()")
    Signed-off-by: Martin Fäcknitz <faecknitz@hotsplots.de>
    Signed-off-by: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit a69d0ba42ec05cb54f07a595d47741ede9ceb01d
Author: Martin Fäcknitz <faecknitz@hotsplots.de>
Date:   Mon Jul 5 02:03:54 2021 +0200

    MIPS: vdso: Invalid GIC access through VDSO
    
    [ Upstream commit 47ce8527fbba145a7723685bc9a27d9855e06491 ]
    
    Accessing raw timers (currently only CLOCK_MONOTONIC_RAW) through VDSO
    doesn't return the correct time when using the GIC as clock source.
    The address of the GIC mapped page is in this case not calculated
    correctly. The GIC mapped page is calculated from the VDSO data by
    subtracting PAGE_SIZE:
    
      void *get_gic(const struct vdso_data *data) {
        return (void __iomem *)data - PAGE_SIZE;
      }
    
    However, the data pointer is not page aligned for raw clock sources.
    This is because the VDSO data for raw clock sources (CS_RAW = 1) is
    stored after the VDSO data for coarse clock sources (CS_HRES_COARSE = 0).
    Therefore, only the VDSO data for CS_HRES_COARSE is page aligned:
    
      +--------------------+
      |                    |
      | vd[CS_RAW]         | ---+
      | vd[CS_HRES_COARSE] |    |
      +--------------------+    | -PAGE_SIZE
      |                    |    |
      |  GIC mapped page   | <--+
      |                    |
      +--------------------+
    
    When __arch_get_hw_counter() is called with &vd[CS_RAW], get_gic returns
    the wrong address (somewhere inside the GIC mapped page). The GIC counter
    values are not returned which results in an invalid time.
    
    Fixes: a7f4df4e21dd ("MIPS: VDSO: Add implementations of gettimeofday() and clock_gettime()")
    Signed-off-by: Martin Fäcknitz <faecknitz@hotsplots.de>
    Signed-off-by: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 8553099bdbe95a717e974552b6e6dbb8c4dac70b
Author: Martin Fäcknitz <faecknitz@hotsplots.de>
Date:   Mon Jul 5 02:03:54 2021 +0200

    MIPS: vdso: Invalid GIC access through VDSO
    
    [ Upstream commit 47ce8527fbba145a7723685bc9a27d9855e06491 ]
    
    Accessing raw timers (currently only CLOCK_MONOTONIC_RAW) through VDSO
    doesn't return the correct time when using the GIC as clock source.
    The address of the GIC mapped page is in this case not calculated
    correctly. The GIC mapped page is calculated from the VDSO data by
    subtracting PAGE_SIZE:
    
      void *get_gic(const struct vdso_data *data) {
        return (void __iomem *)data - PAGE_SIZE;
      }
    
    However, the data pointer is not page aligned for raw clock sources.
    This is because the VDSO data for raw clock sources (CS_RAW = 1) is
    stored after the VDSO data for coarse clock sources (CS_HRES_COARSE = 0).
    Therefore, only the VDSO data for CS_HRES_COARSE is page aligned:
    
      +--------------------+
      |                    |
      | vd[CS_RAW]         | ---+
      | vd[CS_HRES_COARSE] |    |
      +--------------------+    | -PAGE_SIZE
      |                    |    |
      |  GIC mapped page   | <--+
      |                    |
      +--------------------+
    
    When __arch_get_hw_counter() is called with &vd[CS_RAW], get_gic returns
    the wrong address (somewhere inside the GIC mapped page). The GIC counter
    values are not returned which results in an invalid time.
    
    Fixes: a7f4df4e21dd ("MIPS: VDSO: Add implementations of gettimeofday() and clock_gettime()")
    Signed-off-by: Martin Fäcknitz <faecknitz@hotsplots.de>
    Signed-off-by: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit e9602efecf1986b27dd965094b545f4aa4c8bb43
Author: Martin Fäcknitz <faecknitz@hotsplots.de>
Date:   Mon Jul 5 02:03:54 2021 +0200

    MIPS: vdso: Invalid GIC access through VDSO
    
    [ Upstream commit 47ce8527fbba145a7723685bc9a27d9855e06491 ]
    
    Accessing raw timers (currently only CLOCK_MONOTONIC_RAW) through VDSO
    doesn't return the correct time when using the GIC as clock source.
    The address of the GIC mapped page is in this case not calculated
    correctly. The GIC mapped page is calculated from the VDSO data by
    subtracting PAGE_SIZE:
    
      void *get_gic(const struct vdso_data *data) {
        return (void __iomem *)data - PAGE_SIZE;
      }
    
    However, the data pointer is not page aligned for raw clock sources.
    This is because the VDSO data for raw clock sources (CS_RAW = 1) is
    stored after the VDSO data for coarse clock sources (CS_HRES_COARSE = 0).
    Therefore, only the VDSO data for CS_HRES_COARSE is page aligned:
    
      +--------------------+
      |                    |
      | vd[CS_RAW]         | ---+
      | vd[CS_HRES_COARSE] |    |
      +--------------------+    | -PAGE_SIZE
      |                    |    |
      |  GIC mapped page   | <--+
      |                    |
      +--------------------+
    
    When __arch_get_hw_counter() is called with &vd[CS_RAW], get_gic returns
    the wrong address (somewhere inside the GIC mapped page). The GIC counter
    values are not returned which results in an invalid time.
    
    Fixes: a7f4df4e21dd ("MIPS: VDSO: Add implementations of gettimeofday() and clock_gettime()")
    Signed-off-by: Martin Fäcknitz <faecknitz@hotsplots.de>
    Signed-off-by: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit e09c9b558436405407563472f41b0aff437b9c7d
Author: Martin Fäcknitz <faecknitz@hotsplots.de>
Date:   Mon Jul 5 02:03:54 2021 +0200

    MIPS: vdso: Invalid GIC access through VDSO
    
    [ Upstream commit 47ce8527fbba145a7723685bc9a27d9855e06491 ]
    
    Accessing raw timers (currently only CLOCK_MONOTONIC_RAW) through VDSO
    doesn't return the correct time when using the GIC as clock source.
    The address of the GIC mapped page is in this case not calculated
    correctly. The GIC mapped page is calculated from the VDSO data by
    subtracting PAGE_SIZE:
    
      void *get_gic(const struct vdso_data *data) {
        return (void __iomem *)data - PAGE_SIZE;
      }
    
    However, the data pointer is not page aligned for raw clock sources.
    This is because the VDSO data for raw clock sources (CS_RAW = 1) is
    stored after the VDSO data for coarse clock sources (CS_HRES_COARSE = 0).
    Therefore, only the VDSO data for CS_HRES_COARSE is page aligned:
    
      +--------------------+
      |                    |
      | vd[CS_RAW]         | ---+
      | vd[CS_HRES_COARSE] |    |
      +--------------------+    | -PAGE_SIZE
      |                    |    |
      |  GIC mapped page   | <--+
      |                    |
      +--------------------+
    
    When __arch_get_hw_counter() is called with &vd[CS_RAW], get_gic returns
    the wrong address (somewhere inside the GIC mapped page). The GIC counter
    values are not returned which results in an invalid time.
    
    Fixes: a7f4df4e21dd ("MIPS: VDSO: Add implementations of gettimeofday() and clock_gettime()")
    Signed-off-by: Martin Fäcknitz <faecknitz@hotsplots.de>
    Signed-off-by: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 29cb4c6229201f22f6ce16d6a9fd15f76c001dc0
Author: Martin Fäcknitz <faecknitz@hotsplots.de>
Date:   Mon Jul 5 02:03:54 2021 +0200

    MIPS: vdso: Invalid GIC access through VDSO
    
    [ Upstream commit 47ce8527fbba145a7723685bc9a27d9855e06491 ]
    
    Accessing raw timers (currently only CLOCK_MONOTONIC_RAW) through VDSO
    doesn't return the correct time when using the GIC as clock source.
    The address of the GIC mapped page is in this case not calculated
    correctly. The GIC mapped page is calculated from the VDSO data by
    subtracting PAGE_SIZE:
    
      void *get_gic(const struct vdso_data *data) {
        return (void __iomem *)data - PAGE_SIZE;
      }
    
    However, the data pointer is not page aligned for raw clock sources.
    This is because the VDSO data for raw clock sources (CS_RAW = 1) is
    stored after the VDSO data for coarse clock sources (CS_HRES_COARSE = 0).
    Therefore, only the VDSO data for CS_HRES_COARSE is page aligned:
    
      +--------------------+
      |                    |
      | vd[CS_RAW]         | ---+
      | vd[CS_HRES_COARSE] |    |
      +--------------------+    | -PAGE_SIZE
      |                    |    |
      |  GIC mapped page   | <--+
      |                    |
      +--------------------+
    
    When __arch_get_hw_counter() is called with &vd[CS_RAW], get_gic returns
    the wrong address (somewhere inside the GIC mapped page). The GIC counter
    values are not returned which results in an invalid time.
    
    Fixes: a7f4df4e21dd ("MIPS: VDSO: Add implementations of gettimeofday() and clock_gettime()")
    Signed-off-by: Martin Fäcknitz <faecknitz@hotsplots.de>
    Signed-off-by: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 04ea267f5357ddcf39ff7098cdd03c855b9fa036
Author: Martin Fäcknitz <faecknitz@hotsplots.de>
Date:   Mon Jul 5 02:03:54 2021 +0200

    MIPS: vdso: Invalid GIC access through VDSO
    
    [ Upstream commit 47ce8527fbba145a7723685bc9a27d9855e06491 ]
    
    Accessing raw timers (currently only CLOCK_MONOTONIC_RAW) through VDSO
    doesn't return the correct time when using the GIC as clock source.
    The address of the GIC mapped page is in this case not calculated
    correctly. The GIC mapped page is calculated from the VDSO data by
    subtracting PAGE_SIZE:
    
      void *get_gic(const struct vdso_data *data) {
        return (void __iomem *)data - PAGE_SIZE;
      }
    
    However, the data pointer is not page aligned for raw clock sources.
    This is because the VDSO data for raw clock sources (CS_RAW = 1) is
    stored after the VDSO data for coarse clock sources (CS_HRES_COARSE = 0).
    Therefore, only the VDSO data for CS_HRES_COARSE is page aligned:
    
      +--------------------+
      |                    |
      | vd[CS_RAW]         | ---+
      | vd[CS_HRES_COARSE] |    |
      +--------------------+    | -PAGE_SIZE
      |                    |    |
      |  GIC mapped page   | <--+
      |                    |
      +--------------------+
    
    When __arch_get_hw_counter() is called with &vd[CS_RAW], get_gic returns
    the wrong address (somewhere inside the GIC mapped page). The GIC counter
    values are not returned which results in an invalid time.
    
    Fixes: a7f4df4e21dd ("MIPS: VDSO: Add implementations of gettimeofday() and clock_gettime()")
    Signed-off-by: Martin Fäcknitz <faecknitz@hotsplots.de>
    Signed-off-by: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit b00628b1c7d595ae5b544e059c27b1f5828314b4
Author: Alexei Starovoitov <ast@kernel.org>
Date:   Wed Jul 14 17:54:09 2021 -0700

    bpf: Introduce bpf timers.
    
    Introduce 'struct bpf_timer { __u64 :64; __u64 :64; };' that can be embedded
    in hash/array/lru maps as a regular field and helpers to operate on it:
    
    // Initialize the timer.
    // First 4 bits of 'flags' specify clockid.
    // Only CLOCK_MONOTONIC, CLOCK_REALTIME, CLOCK_BOOTTIME are allowed.
    long bpf_timer_init(struct bpf_timer *timer, struct bpf_map *map, int flags);
    
    // Configure the timer to call 'callback_fn' static function.
    long bpf_timer_set_callback(struct bpf_timer *timer, void *callback_fn);
    
    // Arm the timer to expire 'nsec' nanoseconds from the current time.
    long bpf_timer_start(struct bpf_timer *timer, u64 nsec, u64 flags);
    
    // Cancel the timer and wait for callback_fn to finish if it was running.
    long bpf_timer_cancel(struct bpf_timer *timer);
    
    Here is how BPF program might look like:
    struct map_elem {
        int counter;
        struct bpf_timer timer;
    };
    
    struct {
        __uint(type, BPF_MAP_TYPE_HASH);
        __uint(max_entries, 1000);
        __type(key, int);
        __type(value, struct map_elem);
    } hmap SEC(".maps");
    
    static int timer_cb(void *map, int *key, struct map_elem *val);
    /* val points to particular map element that contains bpf_timer. */
    
    SEC("fentry/bpf_fentry_test1")
    int BPF_PROG(test1, int a)
    {
        struct map_elem *val;
        int key = 0;
    
        val = bpf_map_lookup_elem(&hmap, &key);
        if (val) {
            bpf_timer_init(&val->timer, &hmap, CLOCK_REALTIME);
            bpf_timer_set_callback(&val->timer, timer_cb);
            bpf_timer_start(&val->timer, 1000 /* call timer_cb2 in 1 usec */, 0);
        }
    }
    
    This patch adds helper implementations that rely on hrtimers
    to call bpf functions as timers expire.
    The following patches add necessary safety checks.
    
    Only programs with CAP_BPF are allowed to use bpf_timer.
    
    The amount of timers used by the program is constrained by
    the memcg recorded at map creation time.
    
    The bpf_timer_init() helper needs explicit 'map' argument because inner maps
    are dynamic and not known at load time. While the bpf_timer_set_callback() is
    receiving hidden 'aux->prog' argument supplied by the verifier.
    
    The prog pointer is needed to do refcnting of bpf program to make sure that
    program doesn't get freed while the timer is armed. This approach relies on
    "user refcnt" scheme used in prog_array that stores bpf programs for
    bpf_tail_call. The bpf_timer_set_callback() will increment the prog refcnt which is
    paired with bpf_timer_cancel() that will drop the prog refcnt. The
    ops->map_release_uref is responsible for cancelling the timers and dropping
    prog refcnt when user space reference to a map reaches zero.
    This uref approach is done to make sure that Ctrl-C of user space process will
    not leave timers running forever unless the user space explicitly pinned a map
    that contained timers in bpffs.
    
    bpf_timer_init() and bpf_timer_set_callback() will return -EPERM if map doesn't
    have user references (is not held by open file descriptor from user space and
    not pinned in bpffs).
    
    The bpf_map_delete_elem() and bpf_map_update_elem() operations cancel
    and free the timer if given map element had it allocated.
    "bpftool map update" command can be used to cancel timers.
    
    The 'struct bpf_timer' is explicitly __attribute__((aligned(8))) because
    '__u64 :64' has 1 byte alignment of 8 byte padding.
    
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
    Acked-by: Martin KaFai Lau <kafai@fb.com>
    Acked-by: Andrii Nakryiko <andrii@kernel.org>
    Acked-by: Toke Høiland-Jørgensen <toke@redhat.com>
    Link: https://lore.kernel.org/bpf/20210715005417.78572-4-alexei.starovoitov@gmail.com

commit 47ce8527fbba145a7723685bc9a27d9855e06491
Author: Martin Fäcknitz <faecknitz@hotsplots.de>
Date:   Mon Jul 5 02:03:54 2021 +0200

    MIPS: vdso: Invalid GIC access through VDSO
    
    Accessing raw timers (currently only CLOCK_MONOTONIC_RAW) through VDSO
    doesn't return the correct time when using the GIC as clock source.
    The address of the GIC mapped page is in this case not calculated
    correctly. The GIC mapped page is calculated from the VDSO data by
    subtracting PAGE_SIZE:
    
      void *get_gic(const struct vdso_data *data) {
        return (void __iomem *)data - PAGE_SIZE;
      }
    
    However, the data pointer is not page aligned for raw clock sources.
    This is because the VDSO data for raw clock sources (CS_RAW = 1) is
    stored after the VDSO data for coarse clock sources (CS_HRES_COARSE = 0).
    Therefore, only the VDSO data for CS_HRES_COARSE is page aligned:
    
      +--------------------+
      |                    |
      | vd[CS_RAW]         | ---+
      | vd[CS_HRES_COARSE] |    |
      +--------------------+    | -PAGE_SIZE
      |                    |    |
      |  GIC mapped page   | <--+
      |                    |
      +--------------------+
    
    When __arch_get_hw_counter() is called with &vd[CS_RAW], get_gic returns
    the wrong address (somewhere inside the GIC mapped page). The GIC counter
    values are not returned which results in an invalid time.
    
    Fixes: a7f4df4e21dd ("MIPS: VDSO: Add implementations of gettimeofday() and clock_gettime()")
    Signed-off-by: Martin Fäcknitz <faecknitz@hotsplots.de>
    Signed-off-by: Thomas Bogendoerfer <tsbogend@alpha.franken.de>

commit a15286c63d113d4296c58867994cd266a28f5d6d
Merge: b89c07dea161 0e8a89d49d45
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jun 28 11:45:29 2021 -0700

    Merge tag 'locking-core-2021-06-28' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull locking updates from Ingo Molnar:
    
     - Core locking & atomics:
    
         - Convert all architectures to ARCH_ATOMIC: move every architecture
           to ARCH_ATOMIC, then get rid of ARCH_ATOMIC and all the
           transitory facilities and #ifdefs.
    
           Much reduction in complexity from that series:
    
               63 files changed, 756 insertions(+), 4094 deletions(-)
    
         - Self-test enhancements
    
     - Futexes:
    
         - Add the new FUTEX_LOCK_PI2 ABI, which is a variant that doesn't
           set FLAGS_CLOCKRT (.e. uses CLOCK_MONOTONIC).
    
           [ The temptation to repurpose FUTEX_LOCK_PI's implicit setting of
             FLAGS_CLOCKRT & invert the flag's meaning to avoid having to
             introduce a new variant was resisted successfully. ]
    
         - Enhance futex self-tests
    
     - Lockdep:
    
         - Fix dependency path printouts
    
         - Optimize trace saving
    
         - Broaden & fix wait-context checks
    
     - Misc cleanups and fixes.
    
    * tag 'locking-core-2021-06-28' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (52 commits)
      locking/lockdep: Correct the description error for check_redundant()
      futex: Provide FUTEX_LOCK_PI2 to support clock selection
      futex: Prepare futex_lock_pi() for runtime clock selection
      lockdep/selftest: Remove wait-type RCU_CALLBACK tests
      lockdep/selftests: Fix selftests vs PROVE_RAW_LOCK_NESTING
      lockdep: Fix wait-type for empty stack
      locking/selftests: Add a selftest for check_irq_usage()
      lockding/lockdep: Avoid to find wrong lock dep path in check_irq_usage()
      locking/lockdep: Remove the unnecessary trace saving
      locking/lockdep: Fix the dep path printing for backwards BFS
      selftests: futex: Add futex compare requeue test
      selftests: futex: Add futex wait test
      seqlock: Remove trailing semicolon in macros
      locking/lockdep: Reduce LOCKDEP dependency list
      locking/lockdep,doc: Improve readability of the block matrix
      locking/atomics: atomic-instrumented: simplify ifdeffery
      locking/atomic: delete !ARCH_ATOMIC remnants
      locking/atomic: xtensa: move to ARCH_ATOMIC
      locking/atomic: sparc: move to ARCH_ATOMIC
      locking/atomic: sh: move to ARCH_ATOMIC
      ...

commit bf22a6976897977b0a3f1aeba6823c959fc4fdae
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Apr 22 21:44:23 2021 +0200

    futex: Provide FUTEX_LOCK_PI2 to support clock selection
    
    The FUTEX_LOCK_PI futex operand uses a CLOCK_REALTIME based absolute
    timeout since it was implemented, but it does not require that the
    FUTEX_CLOCK_REALTIME flag is set, because that was introduced later.
    
    In theory as none of the user space implementations can set the
    FUTEX_CLOCK_REALTIME flag on this operand, it would be possible to
    creatively abuse it and make the meaning invers, i.e. select CLOCK_REALTIME
    when not set and CLOCK_MONOTONIC when set. But that's a nasty hackery.
    
    Another option would be to have a new FUTEX_CLOCK_MONOTONIC flag only for
    FUTEX_LOCK_PI, but that's also awkward because it does not allow libraries
    to handle the timeout clock selection consistently.
    
    So provide a new FUTEX_LOCK_PI2 operand which implements the timeout
    semantics which the other operands use and leave FUTEX_LOCK_PI alone.
    
    Reported-by: Kurt Kanzenbach <kurt@linutronix.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Link: https://lore.kernel.org/r/20210422194705.440773992@linutronix.de

commit e112c41341c03d9224a9fc522bdb3539bc849b56
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Apr 22 21:44:22 2021 +0200

    futex: Prepare futex_lock_pi() for runtime clock selection
    
    futex_lock_pi() is the only futex operation which cannot select the clock
    for timeouts (CLOCK_MONOTONIC/CLOCK_REALTIME). That's inconsistent and
    there is no particular reason why this cannot be supported.
    
    This was overlooked when CLOCK_REALTIME_FLAG was introduced and
    unfortunately not reported when the inconsistency was discovered in glibc.
    
    Prepare the function and enforce the CLOCK_REALTIME_FLAG on FUTEX_LOCK_PI
    so that a new FUTEX_LOCK_PI2 can implement it correctly.
    
    Reported-by: Kurt Kanzenbach <kurt@linutronix.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Link: https://lore.kernel.org/r/20210422194705.338657741@linutronix.de

commit f724a7453bbfb8bb917735e315d5d902c0b67c33
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Apr 22 21:44:18 2021 +0200

    Revert 337f13046ff0 ("futex: Allow FUTEX_CLOCK_REALTIME with FUTEX_WAIT op")
    
    commit 4fbf5d6837bf81fd7a27d771358f4ee6c4f243f8 upstream.
    
    The FUTEX_WAIT operand has historically a relative timeout which means that
    the clock id is irrelevant as relative timeouts on CLOCK_REALTIME are not
    subject to wall clock changes and therefore are mapped by the kernel to
    CLOCK_MONOTONIC for simplicity.
    
    If a caller would set FUTEX_CLOCK_REALTIME for FUTEX_WAIT the timeout is
    still treated relative vs. CLOCK_MONOTONIC and then the wait arms that
    timeout based on CLOCK_REALTIME which is broken and obviously has never
    been used or even tested.
    
    Reject any attempt to use FUTEX_CLOCK_REALTIME with FUTEX_WAIT again.
    
    The desired functionality can be achieved with FUTEX_WAIT_BITSET and a
    FUTEX_BITSET_MATCH_ANY argument.
    
    Fixes: 337f13046ff0 ("futex: Allow FUTEX_CLOCK_REALTIME with FUTEX_WAIT op")
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/20210422194704.834797921@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 2ae7a44069c4d36757d0ad508fad91538d68423b
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Apr 22 21:44:18 2021 +0200

    Revert 337f13046ff0 ("futex: Allow FUTEX_CLOCK_REALTIME with FUTEX_WAIT op")
    
    commit 4fbf5d6837bf81fd7a27d771358f4ee6c4f243f8 upstream.
    
    The FUTEX_WAIT operand has historically a relative timeout which means that
    the clock id is irrelevant as relative timeouts on CLOCK_REALTIME are not
    subject to wall clock changes and therefore are mapped by the kernel to
    CLOCK_MONOTONIC for simplicity.
    
    If a caller would set FUTEX_CLOCK_REALTIME for FUTEX_WAIT the timeout is
    still treated relative vs. CLOCK_MONOTONIC and then the wait arms that
    timeout based on CLOCK_REALTIME which is broken and obviously has never
    been used or even tested.
    
    Reject any attempt to use FUTEX_CLOCK_REALTIME with FUTEX_WAIT again.
    
    The desired functionality can be achieved with FUTEX_WAIT_BITSET and a
    FUTEX_BITSET_MATCH_ANY argument.
    
    Fixes: 337f13046ff0 ("futex: Allow FUTEX_CLOCK_REALTIME with FUTEX_WAIT op")
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/20210422194704.834797921@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit a1eb878265b8ad200037fabe467d12d712445e1d
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Apr 22 21:44:18 2021 +0200

    Revert 337f13046ff0 ("futex: Allow FUTEX_CLOCK_REALTIME with FUTEX_WAIT op")
    
    commit 4fbf5d6837bf81fd7a27d771358f4ee6c4f243f8 upstream.
    
    The FUTEX_WAIT operand has historically a relative timeout which means that
    the clock id is irrelevant as relative timeouts on CLOCK_REALTIME are not
    subject to wall clock changes and therefore are mapped by the kernel to
    CLOCK_MONOTONIC for simplicity.
    
    If a caller would set FUTEX_CLOCK_REALTIME for FUTEX_WAIT the timeout is
    still treated relative vs. CLOCK_MONOTONIC and then the wait arms that
    timeout based on CLOCK_REALTIME which is broken and obviously has never
    been used or even tested.
    
    Reject any attempt to use FUTEX_CLOCK_REALTIME with FUTEX_WAIT again.
    
    The desired functionality can be achieved with FUTEX_WAIT_BITSET and a
    FUTEX_BITSET_MATCH_ANY argument.
    
    Fixes: 337f13046ff0 ("futex: Allow FUTEX_CLOCK_REALTIME with FUTEX_WAIT op")
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/20210422194704.834797921@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 600de799010689ad8d16f7b1932ca718809f0719
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Apr 22 21:44:18 2021 +0200

    Revert 337f13046ff0 ("futex: Allow FUTEX_CLOCK_REALTIME with FUTEX_WAIT op")
    
    commit 4fbf5d6837bf81fd7a27d771358f4ee6c4f243f8 upstream.
    
    The FUTEX_WAIT operand has historically a relative timeout which means that
    the clock id is irrelevant as relative timeouts on CLOCK_REALTIME are not
    subject to wall clock changes and therefore are mapped by the kernel to
    CLOCK_MONOTONIC for simplicity.
    
    If a caller would set FUTEX_CLOCK_REALTIME for FUTEX_WAIT the timeout is
    still treated relative vs. CLOCK_MONOTONIC and then the wait arms that
    timeout based on CLOCK_REALTIME which is broken and obviously has never
    been used or even tested.
    
    Reject any attempt to use FUTEX_CLOCK_REALTIME with FUTEX_WAIT again.
    
    The desired functionality can be achieved with FUTEX_WAIT_BITSET and a
    FUTEX_BITSET_MATCH_ANY argument.
    
    Fixes: 337f13046ff0 ("futex: Allow FUTEX_CLOCK_REALTIME with FUTEX_WAIT op")
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/20210422194704.834797921@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 7b626640ab2223f239a5367024df72f9970951ab
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Apr 22 21:44:18 2021 +0200

    Revert 337f13046ff0 ("futex: Allow FUTEX_CLOCK_REALTIME with FUTEX_WAIT op")
    
    commit 4fbf5d6837bf81fd7a27d771358f4ee6c4f243f8 upstream.
    
    The FUTEX_WAIT operand has historically a relative timeout which means that
    the clock id is irrelevant as relative timeouts on CLOCK_REALTIME are not
    subject to wall clock changes and therefore are mapped by the kernel to
    CLOCK_MONOTONIC for simplicity.
    
    If a caller would set FUTEX_CLOCK_REALTIME for FUTEX_WAIT the timeout is
    still treated relative vs. CLOCK_MONOTONIC and then the wait arms that
    timeout based on CLOCK_REALTIME which is broken and obviously has never
    been used or even tested.
    
    Reject any attempt to use FUTEX_CLOCK_REALTIME with FUTEX_WAIT again.
    
    The desired functionality can be achieved with FUTEX_WAIT_BITSET and a
    FUTEX_BITSET_MATCH_ANY argument.
    
    Fixes: 337f13046ff0 ("futex: Allow FUTEX_CLOCK_REALTIME with FUTEX_WAIT op")
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/20210422194704.834797921@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 2543329485e2e0aec429535fa81065495b75dae9
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Apr 22 21:44:18 2021 +0200

    Revert 337f13046ff0 ("futex: Allow FUTEX_CLOCK_REALTIME with FUTEX_WAIT op")
    
    commit 4fbf5d6837bf81fd7a27d771358f4ee6c4f243f8 upstream.
    
    The FUTEX_WAIT operand has historically a relative timeout which means that
    the clock id is irrelevant as relative timeouts on CLOCK_REALTIME are not
    subject to wall clock changes and therefore are mapped by the kernel to
    CLOCK_MONOTONIC for simplicity.
    
    If a caller would set FUTEX_CLOCK_REALTIME for FUTEX_WAIT the timeout is
    still treated relative vs. CLOCK_MONOTONIC and then the wait arms that
    timeout based on CLOCK_REALTIME which is broken and obviously has never
    been used or even tested.
    
    Reject any attempt to use FUTEX_CLOCK_REALTIME with FUTEX_WAIT again.
    
    The desired functionality can be achieved with FUTEX_WAIT_BITSET and a
    FUTEX_BITSET_MATCH_ANY argument.
    
    Fixes: 337f13046ff0 ("futex: Allow FUTEX_CLOCK_REALTIME with FUTEX_WAIT op")
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/20210422194704.834797921@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 8d2be04dbb175eec4c107295d4d2deb529aff515
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Apr 22 21:44:18 2021 +0200

    Revert 337f13046ff0 ("futex: Allow FUTEX_CLOCK_REALTIME with FUTEX_WAIT op")
    
    commit 4fbf5d6837bf81fd7a27d771358f4ee6c4f243f8 upstream.
    
    The FUTEX_WAIT operand has historically a relative timeout which means that
    the clock id is irrelevant as relative timeouts on CLOCK_REALTIME are not
    subject to wall clock changes and therefore are mapped by the kernel to
    CLOCK_MONOTONIC for simplicity.
    
    If a caller would set FUTEX_CLOCK_REALTIME for FUTEX_WAIT the timeout is
    still treated relative vs. CLOCK_MONOTONIC and then the wait arms that
    timeout based on CLOCK_REALTIME which is broken and obviously has never
    been used or even tested.
    
    Reject any attempt to use FUTEX_CLOCK_REALTIME with FUTEX_WAIT again.
    
    The desired functionality can be achieved with FUTEX_WAIT_BITSET and a
    FUTEX_BITSET_MATCH_ANY argument.
    
    Fixes: 337f13046ff0 ("futex: Allow FUTEX_CLOCK_REALTIME with FUTEX_WAIT op")
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/20210422194704.834797921@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 4fbf5d6837bf81fd7a27d771358f4ee6c4f243f8
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Apr 22 21:44:18 2021 +0200

    Revert 337f13046ff0 ("futex: Allow FUTEX_CLOCK_REALTIME with FUTEX_WAIT op")
    
    The FUTEX_WAIT operand has historically a relative timeout which means that
    the clock id is irrelevant as relative timeouts on CLOCK_REALTIME are not
    subject to wall clock changes and therefore are mapped by the kernel to
    CLOCK_MONOTONIC for simplicity.
    
    If a caller would set FUTEX_CLOCK_REALTIME for FUTEX_WAIT the timeout is
    still treated relative vs. CLOCK_MONOTONIC and then the wait arms that
    timeout based on CLOCK_REALTIME which is broken and obviously has never
    been used or even tested.
    
    Reject any attempt to use FUTEX_CLOCK_REALTIME with FUTEX_WAIT again.
    
    The desired functionality can be achieved with FUTEX_WAIT_BITSET and a
    FUTEX_BITSET_MATCH_ANY argument.
    
    Fixes: 337f13046ff0 ("futex: Allow FUTEX_CLOCK_REALTIME with FUTEX_WAIT op")
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/20210422194704.834797921@linutronix.de

commit 6ac86aae89289121db784161fe318819778f7f2a
Merge: 17860ccabff5 84d572e634e2
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Mar 30 10:54:22 2021 -0700

    Merge tag 's390-5.12-5' of git://git.kernel.org/pub/scm/linux/kernel/git/s390/linux
    
    Pull s390 updates from Heiko Carstens:
    
     - fix incorrect initialization and update of vdso data pages, which
       results in incorrect tod clock steering, and that
       clock_gettime(CLOCK_MONOTONIC_RAW, ...) returns incorrect values.
    
     - update MAINTAINERS for s390 vfio drivers
    
    * tag 's390-5.12-5' of git://git.kernel.org/pub/scm/linux/kernel/git/s390/linux:
      MAINTAINERS: add backups for s390 vfio drivers
      s390/vdso: fix initializing and updating of vdso_data
      s390/vdso: fix tod_steering_delta type
      s390/vdso: copy tod_steering_delta value to vdso_data page

commit 5b43bd184530af6b868d8273b0a743a138d37ee8
Author: Heiko Carstens <hca@linux.ibm.com>
Date:   Wed Mar 24 20:23:55 2021 +0100

    s390/vdso: fix initializing and updating of vdso_data
    
    Li Wang reported that clock_gettime(CLOCK_MONOTONIC_RAW, ...) returns
    incorrect values when time is provided via vdso instead of system call:
    
    vdso_ts_nsec = 4484351380985507, vdso_ts.tv_sec = 4484351, vdso_ts.tv_nsec = 380985507
    sys_ts_nsec  = 1446923235377, sys_ts.tv_sec  = 1446, sys_ts.tv_nsec  = 923235377
    
    Within the s390 specific vdso function __arch_get_hw_counter() reads
    tod clock steering values from the arch_data member of the passed in
    vdso_data structure.
    
    Problem is that only for the CS_HRES_COARSE vdso_data arch_data is
    initialized and gets updated. The CS_RAW specific vdso_data does not
    contain any valid tod_clock_steering information, which explains the
    different values.
    
    Fix this by initializing and updating all vdso_datas.
    
    Reported-by: Li Wang <liwang@redhat.com>
    Tested-by: Li Wang <liwang@redhat.com>
    Fixes: 1ba2d6c0fd4e ("s390/vdso: simplify __arch_get_hw_counter()")
    Link: https://lore.kernel.org/linux-s390/YFnxr1ZlMIOIqjfq@osiris
    Signed-off-by: Heiko Carstens <hca@linux.ibm.com>

commit b603e810f740e76b6a67089c06d7f4442b187a9a
Author: Simon Ser <contact@emersion.fr>
Date:   Thu Mar 4 23:08:37 2021 +0100

    drm/uapi: document kernel capabilities
    
    Document all of the DRM_CAP_* defines.
    
    v2 (Pekka):
    - Describe what the bit depth is
    - Expand on preferred dumb buffer memory access patterns
    - Explain what a PRIME buffer is
    - Mention DRM_IOCTL_PRIME_FD_TO_HANDLE and DRM_IOCTL_PRIME_HANDLE_TO_FD
    - Explicitly reference CLOCK_REALTIME and CLOCK_MONOTONIC
    - Make it clear DRM_CAP_CRTC_IN_VBLANK_EVENT applies to both DRM_EVENT_VBLANK
      and DRM_EVENT_FLIP_COMPLETE
    
    v3 (Daniel):
    - Specify kernel versions for caps that don't depend on drivers
    - Make it clear dumb buffers caps are only about dumb buffers
    
    Signed-off-by: Simon Ser <contact@emersion.fr>
    Acked-by: Daniel Vetter <daniel@ffwll.ch>
    Reviewed-by: Pekka Paalanen <pekka.paalanen@collabora.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20210308123421.747836-1-contact@emersion.fr

commit f588f0c69e0e645225e4ebc1aff8f9677583a056
Author: Veera Sundaram Sankaran <veeras@codeaurora.org>
Date:   Fri Jan 15 16:31:46 2021 -0800

    dma-fence: allow signaling drivers to set fence timestamp
    
    Some drivers have hardware capability to get the precise HW timestamp
    of certain events based on which the fences are triggered. The delta
    between the event HW timestamp & current HW reference timestamp can
    be used to calculate the timestamp in kernel's CLOCK_MONOTONIC time
    domain. This allows it to set accurate timestamp factoring out any
    software and IRQ latencies. Add a timestamp variant of fence signal
    function, dma_fence_signal_timestamp to allow drivers to update the
    precise timestamp for fences.
    
    Changes in v2:
    - Add a new fence signal variant instead of modifying fence struct
    
    Changes in v3:
    - Add timestamp domain information to commit-text and
    dma_fence_signal_timestamp documentation
    
    Signed-off-by: Veera Sundaram Sankaran <veeras@codeaurora.org>
    Reviewed-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Sumit Semwal <sumit.semwal@linaro.org>
     [sumits: minor parenthesis alignment]
    Link: https://patchwork.freedesktop.org/patch/msgid/1610757107-11892-1-git-send-email-veeras@codeaurora.org
    (cherry picked from commit 5a164ac4dbd21b82bcdc03186d40e455ff467fdc)
    Signed-off-by: Sumit Semwal <sumit.semwal@linaro.org>

commit f405ac83fa252dd0e346f2715b66e7d2adba9027
Author: Tobias Klauser <tklauser@distanz.ch>
Date:   Thu Feb 4 15:50:42 2021 +0100

    selftests/vDSO: fix ABI selftest on riscv
    
    Only older versions of the RISC-V GCC toolchain define __riscv__. Check
    for __riscv as well, which is used by newer GCC toolchains. Also set
    VDSO_32BIT based on __riscv_xlen.
    
    Before (on riscv64):
    
    $ ./vdso_test_abi
    [vDSO kselftest] VDSO_VERSION: LINUX_4
    Could not find __vdso_gettimeofday
    Could not find __vdso_clock_gettime
    Could not find __vdso_clock_getres
    clock_id: CLOCK_REALTIME [PASS]
    Could not find __vdso_clock_gettime
    Could not find __vdso_clock_getres
    clock_id: CLOCK_BOOTTIME [PASS]
    Could not find __vdso_clock_gettime
    Could not find __vdso_clock_getres
    clock_id: CLOCK_TAI [PASS]
    Could not find __vdso_clock_gettime
    Could not find __vdso_clock_getres
    clock_id: CLOCK_REALTIME_COARSE [PASS]
    Could not find __vdso_clock_gettime
    Could not find __vdso_clock_getres
    clock_id: CLOCK_MONOTONIC [PASS]
    Could not find __vdso_clock_gettime
    Could not find __vdso_clock_getres
    clock_id: CLOCK_MONOTONIC_RAW [PASS]
    Could not find __vdso_clock_gettime
    Could not find __vdso_clock_getres
    clock_id: CLOCK_MONOTONIC_COARSE [PASS]
    Could not find __vdso_time
    
    After (on riscv32):
    
    $ ./vdso_test_abi
    [vDSO kselftest] VDSO_VERSION: LINUX_4.15
    The time is 1612449376.015086
    The time is 1612449376.18340784
    The resolution is 0 1
    clock_id: CLOCK_REALTIME [PASS]
    The time is 774.842586182
    The resolution is 0 1
    clock_id: CLOCK_BOOTTIME [PASS]
    The time is 1612449376.22536565
    The resolution is 0 1
    clock_id: CLOCK_TAI [PASS]
    The time is 1612449376.20885172
    The resolution is 0 4000000
    clock_id: CLOCK_REALTIME_COARSE [PASS]
    The time is 774.845491269
    The resolution is 0 1
    clock_id: CLOCK_MONOTONIC [PASS]
    The time is 774.849534200
    The resolution is 0 1
    clock_id: CLOCK_MONOTONIC_RAW [PASS]
    The time is 774.842139684
    The resolution is 0 4000000
    clock_id: CLOCK_MONOTONIC_COARSE [PASS]
    Could not find __vdso_time
    
    Signed-off-by: Tobias Klauser <tklauser@distanz.ch>
    Reviewed-by: Palmer Dabbelt <palmerdabbelt@google.com>
    Acked-by: Palmer Dabbelt <palmerdabbelt@google.com>
    Acked-by: Vincenzo Frascino <vincenzo.frascino@arm.com>
    Signed-off-by: Shuah Khan <skhan@linuxfoundation.org>

commit 5a164ac4dbd21b82bcdc03186d40e455ff467fdc
Author: Veera Sundaram Sankaran <veeras@codeaurora.org>
Date:   Fri Jan 15 16:31:46 2021 -0800

    dma-fence: allow signaling drivers to set fence timestamp
    
    Some drivers have hardware capability to get the precise HW timestamp
    of certain events based on which the fences are triggered. The delta
    between the event HW timestamp & current HW reference timestamp can
    be used to calculate the timestamp in kernel's CLOCK_MONOTONIC time
    domain. This allows it to set accurate timestamp factoring out any
    software and IRQ latencies. Add a timestamp variant of fence signal
    function, dma_fence_signal_timestamp to allow drivers to update the
    precise timestamp for fences.
    
    Changes in v2:
    - Add a new fence signal variant instead of modifying fence struct
    
    Changes in v3:
    - Add timestamp domain information to commit-text and
    dma_fence_signal_timestamp documentation
    
    Signed-off-by: Veera Sundaram Sankaran <veeras@codeaurora.org>
    Reviewed-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Sumit Semwal <sumit.semwal@linaro.org>
     [sumits: minor parenthesis alignment]
    Link: https://patchwork.freedesktop.org/patch/msgid/1610757107-11892-1-git-send-email-veeras@codeaurora.org

commit e4e428816192798c2fa473ff67d9032b94f93291
Author: Nikolay Borisov <nborisov@suse.com>
Date:   Thu Oct 8 15:24:28 2020 +0300

    btrfs: remove redundant time check in transaction kthread loop
    
    The value obtained from ktime_get_seconds() is guaranteed to be
    monotonically increasing since it's taken from CLOCK_MONOTONIC. As
    transaction_kthread obtains a reference to the currently running
    transaction under holding btrfs_fs_info::trans_lock it's guaranteed to:
    
    a) see an initialized 'cur', whose start_time is guaranteed to be smaller
       than 'now'
    
    or
    
    b) not obtain a 'cur' and simply go to sleep.
    
    Given this remove the unnecessary check, if it sees
    now < cur->start_time this would imply there are far greater problems on
    the machine.
    
    Signed-off-by: Nikolay Borisov <nborisov@suse.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

commit 26d060e47e25f2c715a1b2c48fea391f67907a30
Author: Kent Gibson <warthog618@gmail.com>
Date:   Thu Oct 15 07:11:56 2020 +0800

    gpiolib: cdev: allow edge event timestamps to be configured as REALTIME
    
    Using CLOCK_REALTIME as the source for event timestamps is crucial for
    some specific applications, particularly those requiring timetamps
    relative to a PTP clock, so provide an option to switch the event
    timestamp source from the default CLOCK_MONOTONIC to CLOCK_REALTIME.
    
    Note that CLOCK_REALTIME was the default source clock for GPIO until
    Linux 5.7 when it was changed to CLOCK_MONOTONIC due to issues with the
    shifting of the realtime clock.
    Providing this option maintains the CLOCK_MONOTONIC as the default,
    while also providing a path forward for those dependent on the pre-5.7
    behaviour.
    
    Suggested-by: Jack Winch <sunt.un.morcov@gmail.com>
    Signed-off-by: Kent Gibson <warthog618@gmail.com>
    Link: https://lore.kernel.org/r/20201014231158.34117-2-warthog618@gmail.com
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

commit d055126180564a57fe533728a4e93d0cb53d49b3
Author: Dmitrii Banshchikov <me@ubique.spb.ru>
Date:   Tue Nov 17 18:45:49 2020 +0000

    bpf: Add bpf_ktime_get_coarse_ns helper
    
    The helper uses CLOCK_MONOTONIC_COARSE source of time that is less
    accurate but more performant.
    
    We have a BPF CGROUP_SKB firewall that supports event logging through
    bpf_perf_event_output(). Each event has a timestamp and currently we use
    bpf_ktime_get_ns() for it. Use of bpf_ktime_get_coarse_ns() saves ~15-20
    ns in time required for event logging.
    
    bpf_ktime_get_ns():
    EgressLogByRemoteEndpoint                              113.82ns    8.79M
    
    bpf_ktime_get_coarse_ns():
    EgressLogByRemoteEndpoint                               95.40ns   10.48M
    
    Signed-off-by: Dmitrii Banshchikov <me@ubique.spb.ru>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
    Acked-by: Martin KaFai Lau <kafai@fb.com>
    Link: https://lore.kernel.org/bpf/20201117184549.257280-1-me@ubique.spb.ru

commit be6992b68bd05829b4fb35a2c4546d0273527a9c
Author: Pablo Neira Ayuso <pablo@netfilter.org>
Date:   Wed Oct 21 12:55:52 2020 +0200

    netfilter: nf_fwd_netdev: clear timestamp in forwarding path
    
    [ Upstream commit c77761c8a59405cb7aa44188b30fffe13fbdd02d ]
    
    Similar to 7980d2eabde8 ("ipvs: clear skb->tstamp in forwarding path").
    fq qdisc requires tstamp to be cleared in forwarding path.
    
    Fixes: 8203e2d844d3 ("net: clear skb->tstamp in forwarding paths")
    Fixes: fb420d5d91c1 ("tcp/fq: move back to CLOCK_MONOTONIC")
    Fixes: 80b14dee2bea ("net: Add a new socket option for a future transmit time.")
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 3bbd53ba677cce6b024d615f314d34381d156191
Author: Pablo Neira Ayuso <pablo@netfilter.org>
Date:   Wed Oct 21 12:55:52 2020 +0200

    netfilter: nf_fwd_netdev: clear timestamp in forwarding path
    
    [ Upstream commit c77761c8a59405cb7aa44188b30fffe13fbdd02d ]
    
    Similar to 7980d2eabde8 ("ipvs: clear skb->tstamp in forwarding path").
    fq qdisc requires tstamp to be cleared in forwarding path.
    
    Fixes: 8203e2d844d3 ("net: clear skb->tstamp in forwarding paths")
    Fixes: fb420d5d91c1 ("tcp/fq: move back to CLOCK_MONOTONIC")
    Fixes: 80b14dee2bea ("net: Add a new socket option for a future transmit time.")
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit a16f0f41591ecac3d57856b601a417957aee2851
Author: Julian Anastasov <ja@ssi.bg>
Date:   Fri Oct 9 21:24:25 2020 +0300

    ipvs: clear skb->tstamp in forwarding path
    
    [ Upstream commit 7980d2eabde82be86c5be18aa3d07e88ec13c6a1 ]
    
    fq qdisc requires tstamp to be cleared in forwarding path
    
    Reported-by: Evgeny B <abt-admin@mail.ru>
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=209427
    Suggested-by: Eric Dumazet <eric.dumazet@gmail.com>
    Fixes: 8203e2d844d3 ("net: clear skb->tstamp in forwarding paths")
    Fixes: fb420d5d91c1 ("tcp/fq: move back to CLOCK_MONOTONIC")
    Fixes: 80b14dee2bea ("net: Add a new socket option for a future transmit time.")
    Signed-off-by: Julian Anastasov <ja@ssi.bg>
    Reviewed-by: Simon Horman <horms@verge.net.au>
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 29e043f9016ccf29dd394f06a8e7cfb124606c9d
Author: Pablo Neira Ayuso <pablo@netfilter.org>
Date:   Wed Oct 21 12:55:52 2020 +0200

    netfilter: nf_fwd_netdev: clear timestamp in forwarding path
    
    [ Upstream commit c77761c8a59405cb7aa44188b30fffe13fbdd02d ]
    
    Similar to 7980d2eabde8 ("ipvs: clear skb->tstamp in forwarding path").
    fq qdisc requires tstamp to be cleared in forwarding path.
    
    Fixes: 8203e2d844d3 ("net: clear skb->tstamp in forwarding paths")
    Fixes: fb420d5d91c1 ("tcp/fq: move back to CLOCK_MONOTONIC")
    Fixes: 80b14dee2bea ("net: Add a new socket option for a future transmit time.")
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 4cdfe55c067b457c69316d9c7cba3fd0f88039e3
Author: Julian Anastasov <ja@ssi.bg>
Date:   Fri Oct 9 21:24:25 2020 +0300

    ipvs: clear skb->tstamp in forwarding path
    
    [ Upstream commit 7980d2eabde82be86c5be18aa3d07e88ec13c6a1 ]
    
    fq qdisc requires tstamp to be cleared in forwarding path
    
    Reported-by: Evgeny B <abt-admin@mail.ru>
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=209427
    Suggested-by: Eric Dumazet <eric.dumazet@gmail.com>
    Fixes: 8203e2d844d3 ("net: clear skb->tstamp in forwarding paths")
    Fixes: fb420d5d91c1 ("tcp/fq: move back to CLOCK_MONOTONIC")
    Fixes: 80b14dee2bea ("net: Add a new socket option for a future transmit time.")
    Signed-off-by: Julian Anastasov <ja@ssi.bg>
    Reviewed-by: Simon Horman <horms@verge.net.au>
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 6dbdc81b26252a3dd55d5b211c12450b9e0f0491
Author: Pablo Neira Ayuso <pablo@netfilter.org>
Date:   Wed Oct 21 12:55:52 2020 +0200

    netfilter: nf_fwd_netdev: clear timestamp in forwarding path
    
    [ Upstream commit c77761c8a59405cb7aa44188b30fffe13fbdd02d ]
    
    Similar to 7980d2eabde8 ("ipvs: clear skb->tstamp in forwarding path").
    fq qdisc requires tstamp to be cleared in forwarding path.
    
    Fixes: 8203e2d844d3 ("net: clear skb->tstamp in forwarding paths")
    Fixes: fb420d5d91c1 ("tcp/fq: move back to CLOCK_MONOTONIC")
    Fixes: 80b14dee2bea ("net: Add a new socket option for a future transmit time.")
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 76c0e4b2a50f8905b253552e20771ac8a9f978e1
Author: Julian Anastasov <ja@ssi.bg>
Date:   Fri Oct 9 21:24:25 2020 +0300

    ipvs: clear skb->tstamp in forwarding path
    
    [ Upstream commit 7980d2eabde82be86c5be18aa3d07e88ec13c6a1 ]
    
    fq qdisc requires tstamp to be cleared in forwarding path
    
    Reported-by: Evgeny B <abt-admin@mail.ru>
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=209427
    Suggested-by: Eric Dumazet <eric.dumazet@gmail.com>
    Fixes: 8203e2d844d3 ("net: clear skb->tstamp in forwarding paths")
    Fixes: fb420d5d91c1 ("tcp/fq: move back to CLOCK_MONOTONIC")
    Fixes: 80b14dee2bea ("net: Add a new socket option for a future transmit time.")
    Signed-off-by: Julian Anastasov <ja@ssi.bg>
    Reviewed-by: Simon Horman <horms@verge.net.au>
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 69a117d795ac1c79105c2284452095eed5becc6d
Author: Julian Anastasov <ja@ssi.bg>
Date:   Fri Oct 9 21:24:25 2020 +0300

    ipvs: clear skb->tstamp in forwarding path
    
    [ Upstream commit 7980d2eabde82be86c5be18aa3d07e88ec13c6a1 ]
    
    fq qdisc requires tstamp to be cleared in forwarding path
    
    Reported-by: Evgeny B <abt-admin@mail.ru>
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=209427
    Suggested-by: Eric Dumazet <eric.dumazet@gmail.com>
    Fixes: 8203e2d844d3 ("net: clear skb->tstamp in forwarding paths")
    Fixes: fb420d5d91c1 ("tcp/fq: move back to CLOCK_MONOTONIC")
    Fixes: 80b14dee2bea ("net: Add a new socket option for a future transmit time.")
    Signed-off-by: Julian Anastasov <ja@ssi.bg>
    Reviewed-by: Simon Horman <horms@verge.net.au>
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 672f8871261597894d46454b8fa1660d6c952af6
Merge: 87702a337f74 a4fd8414659b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Oct 25 11:28:49 2020 -0700

    Merge tag 'timers-urgent-2020-10-25' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer fixes from Thomas Gleixner:
     "A time namespace fix and a matching selftest. The futex absolute
      timeouts which are based on CLOCK_MONOTONIC require time namespace
      corrected. This was missed in the original time namesapce support"
    
    * tag 'timers-urgent-2020-10-25' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      selftests/timens: Add a test for futex()
      futex: Adjust absolute futex timeouts with per time namespace offset

commit c77761c8a59405cb7aa44188b30fffe13fbdd02d
Author: Pablo Neira Ayuso <pablo@netfilter.org>
Date:   Wed Oct 21 12:55:52 2020 +0200

    netfilter: nf_fwd_netdev: clear timestamp in forwarding path
    
    Similar to 7980d2eabde8 ("ipvs: clear skb->tstamp in forwarding path").
    fq qdisc requires tstamp to be cleared in forwarding path.
    
    Fixes: 8203e2d844d3 ("net: clear skb->tstamp in forwarding paths")
    Fixes: fb420d5d91c1 ("tcp/fq: move back to CLOCK_MONOTONIC")
    Fixes: 80b14dee2bea ("net: Add a new socket option for a future transmit time.")
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>

commit 7980d2eabde82be86c5be18aa3d07e88ec13c6a1
Author: Julian Anastasov <ja@ssi.bg>
Date:   Fri Oct 9 21:24:25 2020 +0300

    ipvs: clear skb->tstamp in forwarding path
    
    fq qdisc requires tstamp to be cleared in forwarding path
    
    Reported-by: Evgeny B <abt-admin@mail.ru>
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=209427
    Suggested-by: Eric Dumazet <eric.dumazet@gmail.com>
    Fixes: 8203e2d844d3 ("net: clear skb->tstamp in forwarding paths")
    Fixes: fb420d5d91c1 ("tcp/fq: move back to CLOCK_MONOTONIC")
    Fixes: 80b14dee2bea ("net: Add a new socket option for a future transmit time.")
    Signed-off-by: Julian Anastasov <ja@ssi.bg>
    Reviewed-by: Simon Horman <horms@verge.net.au>
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>

commit b03c49cde61f9e5a68cb0b1f3540fcb20b27b6fa
Author: Vinicius Costa Gomes <vinicius.gomes@intel.com>
Date:   Thu Aug 20 16:02:17 2020 -0700

    igc: Save PTP time before a reset
    
    Many TSN features depend on the internal PTP clock, so the internal
    PTP jumping when the adapter is reset can cause problems, usually in
    the form of "TX Hangs" warnings in the driver.
    
    The solution is to save the PTP time before a reset and restore it
    after the reset is done. The value of the PTP time is saved before a
    reset and we use the difference from CLOCK_MONOTONIC from reset time
    to now, to correct what's going to be the new PTP time.
    
    This is heavily inspired by commit bf4bf09bdd91 ("i40e: save PTP time
    before a device reset").
    
    Signed-off-by: Vinicius Costa Gomes <vinicius.gomes@intel.com>
    Tested-by: Aaron Brown <aaron.f.brown@intel.com>
    Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>

commit e534bfb16415f826e6aa146b27cb071c1363e49a
Author: Jiri Olsa <jolsa@kernel.org>
Date:   Wed Aug 5 11:34:44 2020 +0200

    perf script: Add 'tod' field to display time of day
    
    Add a 'tod' field to display time of day column with time of date
    (wallclock) time.
    
      # perf record -k CLOCK_MONOTONIC kill
      kill: not enough arguments
      [ perf record: Woken up 1 times to write data ]
      [ perf record: Captured and wrote 0.033 MB perf.data (8 samples) ]
    
      # perf script
                perf 261340 152919.481538:          1 cycles:  ffffffff8106d104 ...
                perf 261340 152919.481543:          1 cycles:  ffffffff8106d104 ...
                perf 261340 152919.481545:          7 cycles:  ffffffff8106d104 ...
      ...
    
      # perf script --ns
                perf 261340 152919.481538922:          1 cycles:  ffffffff8106d ...
                perf 261340 152919.481543286:          1 cycles:  ffffffff8106d ...
                perf 261340 152919.481545397:          7 cycles:  ffffffff8106d ...
      ...
    
      # perf script -F+tod
                perf 261340 2020-07-13 18:26:55.620971 152919.481538:           ...
                perf 261340 2020-07-13 18:26:55.620975 152919.481543:           ...
                perf 261340 2020-07-13 18:26:55.620978 152919.481545:           ...
      ...
    
      # perf script -F+tod --ns
                perf 261340 2020-07-13 18:26:55.620971621 152919.481538922:     ...
                perf 261340 2020-07-13 18:26:55.620975985 152919.481543286:     ...
                perf 261340 2020-07-13 18:26:55.620978096 152919.481545397:     ...
      ...
    
    It's available only for recording with clockid specified, because it's
    the only case where we can get reference time to wallclock time. It's
    can't do that with perf clock yet.
    
    Error is display if you want to use --tod on data without clockid
    specified:
    
      # perf script -F+tod
      Can't provide 'tod' time, missing clock data. Please record with -k/--clockid option.
    
    Original-patch-by: David Ahern <dsahern@gmail.com>
    Signed-off-by: Jiri Olsa <jolsa@kernel.org>
    Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Cc: Andi Kleen <ak@linux.intel.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Geneviève Bastien <gbastien@versatic.net>
    Cc: Ian Rogers <irogers@google.com>
    Cc: Jeremie Galarneau <jgalar@efficios.com>
    Cc: Michael Petlan <mpetlan@redhat.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Wang Nan <wangnan0@huawei.com>
    Link: http://lore.kernel.org/lkml/20200805093444.314999-8-jolsa@kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

commit 88371c5898fc9e7c9faeb7f53ab9082b4e84b7a8
Author: Jiri Olsa <jolsa@kernel.org>
Date:   Wed Aug 5 11:34:42 2020 +0200

    perf data: Add support to store time of day in CTF data conversion
    
    Adad support to convert and store time of day in CTF data conversion for
    'perf data convert' subcommand.
    
    The perf.data used for conversion needs to have clock data information -
    must be recorded with -k/--clockid option).
    
    New --tod option is added to 'perf data convert' subcommand to convert
    data with timestamps converted to wall clock time.
    
    Record data with clockid set:
    
      # perf record -k CLOCK_MONOTONIC kill
      kill: not enough arguments
      [ perf record: Woken up 1 times to write data ]
      [ perf record: Captured and wrote 0.033 MB perf.data (8 samples) ]
    
    Convert data with TOD timestamps:
    
      # perf data convert --tod --to-ctf ./ctf
      [ perf data convert: Converted 'perf.data' into CTF data './ctf' ]
      [ perf data convert: Converted and wrote 0.000 MB (8 samples) ]
    
    Display data in perf script:
    
      # perf script -F+tod --ns
                perf 262150 2020-07-13 18:38:50.097678523 153633.958246159:          1 cycles: ...
                perf 262150 2020-07-13 18:38:50.097682941 153633.958250577:          1 cycles: ...
                perf 262150 2020-07-13 18:38:50.097684997 153633.958252633:          7 cycles: ...
      ...
    
    Display data in babeltrace:
    
      # babeltrace --clock-date  ./ctf
      [2020-07-13 18:38:50.097678523] (+?.?????????) cycles: { cpu_id = 0 }, { perf_ip = 0xFFF ...
      [2020-07-13 18:38:50.097682941] (+0.000004418) cycles: { cpu_id = 0 }, { perf_ip = 0xFFF ...
      [2020-07-13 18:38:50.097684997] (+0.000002056) cycles: { cpu_id = 0 }, { perf_ip = 0xFFF ...
      ...
    
    It's available only for recording with clockid specified, because it's
    the only case where we can get reference time to wallclock time. It's
    can't do that with perf clock yet.
    
    Error is display if you want to use --tod on data without clockid
    specified:
    
      # perf data convert --tod --to-ctf ./ctf
      Can't provide --tod time, missing clock data. Please record with -k/--clockid option.
      Failed to setup CTF writer.
      Error during conversion setup.
    
    Signed-off-by: Jiri Olsa <jolsa@kernel.org>
    Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Cc: Andi Kleen <ak@linux.intel.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Geneviève Bastien <gbastien@versatic.net>
    Cc: Ian Rogers <irogers@google.com>
    Cc: Jeremie Galarneau <jgalar@efficios.com>
    Cc: Michael Petlan <mpetlan@redhat.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Wang Nan <wangnan0@huawei.com>
    Link: http://lore.kernel.org/lkml/20200805093444.314999-6-jolsa@kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

commit 71d19214776e61b33da48f7c1b46e522c7f78221
Author: Maciej Żenczykowski <maze@google.com>
Date:   Sun Apr 26 09:15:25 2020 -0700

    bpf: add bpf_ktime_get_boot_ns()
    
    On a device like a cellphone which is constantly suspending
    and resuming CLOCK_MONOTONIC is not particularly useful for
    keeping track of or reacting to external network events.
    Instead you want to use CLOCK_BOOTTIME.
    
    Hence add bpf_ktime_get_boot_ns() as a mirror of bpf_ktime_get_ns()
    based around CLOCK_BOOTTIME instead of CLOCK_MONOTONIC.
    
    Signed-off-by: Maciej Żenczykowski <maze@google.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>

commit 082b57e3eb09810d357083cca5ee2df02c16aec9
Author: Maciej Żenczykowski <maze@google.com>
Date:   Mon Apr 20 11:47:50 2020 -0700

    net: bpf: Make bpf_ktime_get_ns() available to non GPL programs
    
    The entire implementation is in kernel/bpf/helpers.c:
    
    BPF_CALL_0(bpf_ktime_get_ns) {
           /* NMI safe access to clock monotonic */
           return ktime_get_mono_fast_ns();
    }
    
    const struct bpf_func_proto bpf_ktime_get_ns_proto = {
           .func           = bpf_ktime_get_ns,
           .gpl_only       = false,
           .ret_type       = RET_INTEGER,
    };
    
    and this was presumably marked GPL due to kernel/time/timekeeping.c:
      EXPORT_SYMBOL_GPL(ktime_get_mono_fast_ns);
    
    and while that may make sense for kernel modules (although even that
    is doubtful), there is currently AFAICT no other source of time
    available to ebpf.
    
    Furthermore this is really just equivalent to clock_gettime(CLOCK_MONOTONIC)
    which is exposed to userspace (via vdso even to make it performant)...
    
    As such, I see no reason to keep the GPL restriction.
    (In the future I'd like to have access to time from Apache licensed ebpf code)
    
    Signed-off-by: Maciej Żenczykowski <maze@google.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>

commit 22b17db4ea05561c7c8e4d770f10751e22e339f9
Merge: a4fe2b4d87c9 c4e71212a245
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jan 29 14:55:47 2020 -0800

    Merge tag 'y2038-drivers-for-v5.6-signed' of git://git.kernel.org:/pub/scm/linux/kernel/git/arnd/playground
    
    Pull y2038 updates from Arnd Bergmann:
     "Core, driver and file system changes
    
      These are updates to device drivers and file systems that for some
      reason or another were not included in the kernel in the previous
      y2038 series.
    
      I've gone through all users of time_t again to make sure the kernel is
      in a long-term maintainable state, replacing all remaining references
      to time_t with safe alternatives.
    
      Some related parts of the series were picked up into the nfsd, xfs,
      alsa and v4l2 trees. A final set of patches in linux-mm removes the
      now unused time_t/timeval/timespec types and helper functions after
      all five branches are merged for linux-5.6, ensuring that no new users
      get merged.
    
      As a result, linux-5.6, or my backport of the patches to 5.4 [1],
      should be the first release that can serve as a base for a 32-bit
      system designed to run beyond year 2038, with a few remaining caveats:
    
       - All user space must be compiled with a 64-bit time_t, which will be
         supported in the coming musl-1.2 and glibc-2.32 releases, along
         with installed kernel headers from linux-5.6 or higher.
    
       - Applications that use the system call interfaces directly need to
         be ported to use the time64 syscalls added in linux-5.1 in place of
         the existing system calls. This impacts most users of futex() and
         seccomp() as well as programming languages that have their own
         runtime environment not based on libc.
    
       - Applications that use a private copy of kernel uapi header files or
         their contents may need to update to the linux-5.6 version, in
         particular for sound/asound.h, xfs/xfs_fs.h, linux/input.h,
         linux/elfcore.h, linux/sockios.h, linux/timex.h and
         linux/can/bcm.h.
    
       - A few remaining interfaces cannot be changed to pass a 64-bit
         time_t in a compatible way, so they must be configured to use
         CLOCK_MONOTONIC times or (with a y2106 problem) unsigned 32-bit
         timestamps. Most importantly this impacts all users of 'struct
         input_event'.
    
       - All y2038 problems that are present on 64-bit machines also apply
         to 32-bit machines. In particular this affects file systems with
         on-disk timestamps using signed 32-bit seconds: ext4 with
         ext3-style small inodes, ext2, xfs (to be fixed soon) and ufs"
    
    [1] https://git.kernel.org/pub/scm/linux/kernel/git/arnd/playground.git/log/?h=y2038-endgame
    
    * tag 'y2038-drivers-for-v5.6-signed' of git://git.kernel.org:/pub/scm/linux/kernel/git/arnd/playground: (21 commits)
      Revert "drm/etnaviv: reject timeouts with tv_nsec >= NSEC_PER_SEC"
      y2038: sh: remove timeval/timespec usage from headers
      y2038: sparc: remove use of struct timex
      y2038: rename itimerval to __kernel_old_itimerval
      y2038: remove obsolete jiffies conversion functions
      nfs: fscache: use timespec64 in inode auxdata
      nfs: fix timstamp debug prints
      nfs: use time64_t internally
      sunrpc: convert to time64_t for expiry
      drm/etnaviv: avoid deprecated timespec
      drm/etnaviv: reject timeouts with tv_nsec >= NSEC_PER_SEC
      drm/msm: avoid using 'timespec'
      hfs/hfsplus: use 64-bit inode timestamps
      hostfs: pass 64-bit timestamps to/from user space
      packet: clarify timestamp overflow
      tsacct: add 64-bit btime field
      acct: stop using get_seconds()
      um: ubd: use 64-bit time_t where possible
      xtensa: ISS: avoid struct timeval
      dlm: use SO_SNDTIMEO_NEW instead of SO_SNDTIMEO_OLD
      ...

commit 61c57676035df29a0a61991f4389e884ba0b68d7
Author: Dmitry Safonov <0x7f454c46@gmail.com>
Date:   Tue Nov 12 01:27:17 2019 +0000

    selftests/timens: Add Time Namespace test for supported clocks
    
    A test to check that all supported clocks work on host and inside
    a new time namespace. Use both ways to get time: through VDSO and
    by entering the kernel with implicit syscall.
    
    Introduce a new timens directory in selftests framework for
    the next timens tests.
    
    Output on success:
     1..10
     ok 1 Passed for CLOCK_BOOTTIME (syscall)
     ok 2 Passed for CLOCK_BOOTTIME (vdso)
     ok 3 Passed for CLOCK_BOOTTIME_ALARM (syscall)
     ok 4 Passed for CLOCK_BOOTTIME_ALARM (vdso)
     ok 5 Passed for CLOCK_MONOTONIC (syscall)
     ok 6 Passed for CLOCK_MONOTONIC (vdso)
     ok 7 Passed for CLOCK_MONOTONIC_COARSE (syscall)
     ok 8 Passed for CLOCK_MONOTONIC_COARSE (vdso)
     ok 9 Passed for CLOCK_MONOTONIC_RAW (syscall)
     ok 10 Passed for CLOCK_MONOTONIC_RAW (vdso)
     # Pass 10 Fail 0 Xfail 0 Xpass 0 Skip 0 Error 0
    
    Output with lack of permissions:
     1..10
     not ok 1 # SKIP need to run as root
    
    Output without support of time namespaces:
     1..10
     not ok 1 # SKIP Time namespaces are not supported
    
    Co-developed-by: Andrei Vagin <avagin@openvz.org>
    Signed-off-by: Andrei Vagin <avagin@gmail.com>
    Signed-off-by: Dmitry Safonov <dima@arista.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lore.kernel.org/r/20191112012724.250792-29-dima@arista.com

commit 769071ac9f20b6a447410c7eaa55d1a5233ef40c
Author: Andrei Vagin <avagin@openvz.org>
Date:   Tue Nov 12 01:26:52 2019 +0000

    ns: Introduce Time Namespace
    
    Time Namespace isolates clock values.
    
    The kernel provides access to several clocks CLOCK_REALTIME,
    CLOCK_MONOTONIC, CLOCK_BOOTTIME, etc.
    
    CLOCK_REALTIME
          System-wide clock that measures real (i.e., wall-clock) time.
    
    CLOCK_MONOTONIC
          Clock that cannot be set and represents monotonic time since
          some unspecified starting point.
    
    CLOCK_BOOTTIME
          Identical to CLOCK_MONOTONIC, except it also includes any time
          that the system is suspended.
    
    For many users, the time namespace means the ability to changes date and
    time in a container (CLOCK_REALTIME). Providing per namespace notions of
    CLOCK_REALTIME would be complex with a massive overhead, but has a dubious
    value.
    
    But in the context of checkpoint/restore functionality, monotonic and
    boottime clocks become interesting. Both clocks are monotonic with
    unspecified starting points. These clocks are widely used to measure time
    slices and set timers. After restoring or migrating processes, it has to be
    guaranteed that they never go backward. In an ideal case, the behavior of
    these clocks should be the same as for a case when a whole system is
    suspended. All this means that it is required to set CLOCK_MONOTONIC and
    CLOCK_BOOTTIME clocks, which can be achieved by adding per-namespace
    offsets for clocks.
    
    A time namespace is similar to a pid namespace in the way how it is
    created: unshare(CLONE_NEWTIME) system call creates a new time namespace,
    but doesn't set it to the current process. Then all children of the process
    will be born in the new time namespace, or a process can use the setns()
    system call to join a namespace.
    
    This scheme allows setting clock offsets for a namespace, before any
    processes appear in it.
    
    All available clone flags have been used, so CLONE_NEWTIME uses the highest
    bit of CSIGNAL. It means that it can be used only with the unshare() and
    the clone3() system calls.
    
    [ tglx: Adjusted paragraph about clone3() to reality and massaged the
            changelog a bit. ]
    
    Co-developed-by: Dmitry Safonov <dima@arista.com>
    Signed-off-by: Andrei Vagin <avagin@gmail.com>
    Signed-off-by: Dmitry Safonov <dima@arista.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://criu.org/Time_namespace
    Link: https://lists.openvz.org/pipermail/criu/2018-June/041504.html
    Link: https://lore.kernel.org/r/20191112012724.250792-4-dima@arista.com

commit 8d503ecf71548da5381151fa197cc091b141cc53
Author: Lorenz Bauer <lmb@cloudflare.com>
Date:   Fri Dec 13 18:08:17 2019 +0000

    bpf: Clear skb->tstamp in bpf_redirect when necessary
    
    [ Upstream commit 5133498f4ad1123a5ffd4c08df6431dab882cc32 ]
    
    Redirecting a packet from ingress to egress by using bpf_redirect
    breaks if the egress interface has an fq qdisc installed. This is the same
    problem as fixed in 'commit 8203e2d844d3 ("net: clear skb->tstamp in forwarding paths")
    
    Clear skb->tstamp when redirecting into the egress path.
    
    Fixes: 80b14dee2bea ("net: Add a new socket option for a future transmit time.")
    Fixes: fb420d5d91c1 ("tcp/fq: move back to CLOCK_MONOTONIC")
    Signed-off-by: Lorenz Bauer <lmb@cloudflare.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>
    Reviewed-by: Eric Dumazet <edumazet@google.com>
    Link: https://lore.kernel.org/bpf/20191213180817.2510-1-lmb@cloudflare.com
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit e3d5f12b312ab40d7522b1106bf85e1811c71eb5
Author: Lorenz Bauer <lmb@cloudflare.com>
Date:   Fri Dec 13 18:08:17 2019 +0000

    bpf: Clear skb->tstamp in bpf_redirect when necessary
    
    [ Upstream commit 5133498f4ad1123a5ffd4c08df6431dab882cc32 ]
    
    Redirecting a packet from ingress to egress by using bpf_redirect
    breaks if the egress interface has an fq qdisc installed. This is the same
    problem as fixed in 'commit 8203e2d844d3 ("net: clear skb->tstamp in forwarding paths")
    
    Clear skb->tstamp when redirecting into the egress path.
    
    Fixes: 80b14dee2bea ("net: Add a new socket option for a future transmit time.")
    Fixes: fb420d5d91c1 ("tcp/fq: move back to CLOCK_MONOTONIC")
    Signed-off-by: Lorenz Bauer <lmb@cloudflare.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>
    Reviewed-by: Eric Dumazet <edumazet@google.com>
    Link: https://lore.kernel.org/bpf/20191213180817.2510-1-lmb@cloudflare.com
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 1a6c0b36dd19c51cdd76895d009c5deba2286ebb
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Dec 16 15:15:03 2019 +0100

    media: v4l2-core: fix VIDIOC_DQEVENT for time64 ABI
    
    The v4l2_event structure contains a 'struct timespec' member that is
    defined by the user space C library, creating an ABI incompatibility
    when that gets updated to a 64-bit time_t.
    
    While passing a 32-bit time_t here would be sufficient for CLOCK_MONOTONIC
    timestamps, simply redefining the structure to use the kernel's
    __kernel_old_timespec would not work for any library that uses a copy
    of the linux/videodev2.h header file rather than including the copy from
    the latest kernel headers.
    
    This means the kernel has to be changed to handle both versions of the
    structure layout on a 32-bit architecture. The easiest way to do this
    is during the copy from/to user space.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Hans Verkuil <hverkuil-cisco@xs4all.nl>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+huawei@kernel.org>

commit 38c4a4cf02513a7904b9db0a668b7e50145ea696
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Nov 6 13:28:52 2017 +0100

    drm/etnaviv: avoid deprecated timespec
    
    struct timespec is being removed from the kernel because it often leads
    to code that is not y2038-safe.
    
    In the etnaviv driver, monotonic timestamps are used, which do not suffer
    from overflow, but the usage of timespec here gets in the way of removing
    the interface completely.
    
    Pass down the user-supplied 64-bit value here rather than converting
    it to an intermediate timespec to avoid the conversion.
    
    The conversion is transparent for all regular CLOCK_MONOTONIC values,
    but is a small change in behavior for excessively large values: the
    existing code would treat e.g. tv_sec=0x100000000 the same as tv_sec=0
    and not block, while the new code it would block for up to 2^31
    seconds. The new behavior is more logical here, but if it causes problems,
    the truncation can be put back.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

commit 5133498f4ad1123a5ffd4c08df6431dab882cc32
Author: Lorenz Bauer <lmb@cloudflare.com>
Date:   Fri Dec 13 18:08:17 2019 +0000

    bpf: Clear skb->tstamp in bpf_redirect when necessary
    
    Redirecting a packet from ingress to egress by using bpf_redirect
    breaks if the egress interface has an fq qdisc installed. This is the same
    problem as fixed in 'commit 8203e2d844d3 ("net: clear skb->tstamp in forwarding paths")
    
    Clear skb->tstamp when redirecting into the egress path.
    
    Fixes: 80b14dee2bea ("net: Add a new socket option for a future transmit time.")
    Fixes: fb420d5d91c1 ("tcp/fq: move back to CLOCK_MONOTONIC")
    Signed-off-by: Lorenz Bauer <lmb@cloudflare.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>
    Reviewed-by: Eric Dumazet <edumazet@google.com>
    Link: https://lore.kernel.org/bpf/20191213180817.2510-1-lmb@cloudflare.com

commit b98c7518c5345ac5f930fd40ce9d8d2b8dc2ba06
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Jun 18 16:19:24 2018 +0200

    firewire: ohci: stop using get_seconds() for BUS_TIME
    
    The ohci driver uses the get_seconds() function to implement the 32-bit
    CSR_BUS_TIME register. This was added in 2010 commit a48777e03ad5
    ("firewire: add CSR BUS_TIME support").
    
    As get_seconds() returns a 32-bit value (on 32-bit architectures), it
    seems like a good fit for that register, but it is also deprecated because
    of the y2038/y2106 overflow problem, and should be replaced throughout
    the kernel with either ktime_get_real_seconds() or ktime_get_seconds().
    
    I'm using the latter here, which uses monotonic time. This has the
    advantage of behaving better during concurrent settimeofday() updates
    or leap second adjustments and won't overflow a 32-bit integer, but
    the downside of using CLOCK_MONOTONIC instead of CLOCK_REALTIME is
    that the observed values are not related to external clocks.
    
    If we instead need UTC but can live with clock jumps or overflows,
    then we should use ktime_get_real_seconds() instead, retaining the
    existing behavior.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Link: https://lore.kernel.org/lkml/20180711124923.1205200-1-arnd@arndb.de/
    Reviewed-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

commit 95753984d8751580180ab0f06e6d3c2d0512da15
Author: Eric Dumazet <edumazet@google.com>
Date:   Wed Oct 16 18:00:56 2019 -0700

    net: ensure correct skb->tstamp in various fragmenters
    
    [ Upstream commit 9669fffc1415bb0c30e5d2ec98a8e1c3a418cb9c ]
    
    Thomas found that some forwarded packets would be stuck
    in FQ packet scheduler because their skb->tstamp contained
    timestamps far in the future.
    
    We thought we addressed this point in commit 8203e2d844d3
    ("net: clear skb->tstamp in forwarding paths") but there
    is still an issue when/if a packet needs to be fragmented.
    
    In order to meet EDT requirements, we have to make sure all
    fragments get the original skb->tstamp.
    
    Note that this original skb->tstamp should be zero in
    forwarding path, but might have a non zero value in
    output path if user decided so.
    
    Fixes: fb420d5d91c1 ("tcp/fq: move back to CLOCK_MONOTONIC")
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Reported-by: Thomas Bartschies <Thomas.Bartschies@cvk.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 53fafdbb8b21fa99dfd8376ca056bffde8cafc11
Author: Marcelo Tosatti <mtosatti@redhat.com>
Date:   Mon Oct 28 12:36:22 2019 -0200

    KVM: x86: switch KVMCLOCK base to monotonic raw clock
    
    Commit 0bc48bea36d1 ("KVM: x86: update master clock before computing
    kvmclock_offset")
    switches the order of operations to avoid the conversion
    
    TSC (without frequency correction) ->
    system_timestamp (with frequency correction),
    
    which might cause a time jump.
    
    However, it leaves any other masterclock update unsafe, which includes,
    at the moment:
    
            * HV_X64_MSR_REFERENCE_TSC MSR write.
            * TSC writes.
            * Host suspend/resume.
    
    Avoid the time jump issue by using frequency uncorrected
    CLOCK_MONOTONIC_RAW clock.
    
    Its the guests time keeping software responsability
    to track and correct a reference clock such as UTC.
    
    This fixes forward time jump (which can result in
    failure to bring up a vCPU) during vCPU hotplug:
    
    Oct 11 14:48:33 storage kernel: CPU2 has been hot-added
    Oct 11 14:48:34 storage kernel: CPU3 has been hot-added
    Oct 11 14:49:22 storage kernel: smpboot: Booting Node 0 Processor 2 APIC 0x2          <-- time jump of almost 1 minute
    Oct 11 14:49:22 storage kernel: smpboot: do_boot_cpu failed(-1) to wakeup CPU#2
    Oct 11 14:49:23 storage kernel: smpboot: Booting Node 0 Processor 3 APIC 0x3
    Oct 11 14:49:23 storage kernel: kvm-clock: cpu 3, msr 0:7ff640c1, secondary cpu clock
    
    Which happens because:
    
                    /*
                     * Wait 10s total for a response from AP
                     */
                    boot_error = -1;
                    timeout = jiffies + 10*HZ;
                    while (time_before(jiffies, timeout)) {
                             ...
                    }
    
    Analyzed-by: Igor Mammedov <imammedo@redhat.com>
    Signed-off-by: Marcelo Tosatti <mtosatti@redhat.com>
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>

commit 9669fffc1415bb0c30e5d2ec98a8e1c3a418cb9c
Author: Eric Dumazet <edumazet@google.com>
Date:   Wed Oct 16 18:00:56 2019 -0700

    net: ensure correct skb->tstamp in various fragmenters
    
    Thomas found that some forwarded packets would be stuck
    in FQ packet scheduler because their skb->tstamp contained
    timestamps far in the future.
    
    We thought we addressed this point in commit 8203e2d844d3
    ("net: clear skb->tstamp in forwarding paths") but there
    is still an issue when/if a packet needs to be fragmented.
    
    In order to meet EDT requirements, we have to make sure all
    fragments get the original skb->tstamp.
    
    Note that this original skb->tstamp should be zero in
    forwarding path, but might have a non zero value in
    output path if user decided so.
    
    Fixes: fb420d5d91c1 ("tcp/fq: move back to CLOCK_MONOTONIC")
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Reported-by: Thomas Bartschies <Thomas.Bartschies@cvk.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit ba94094818a811758570990648160a6ba2ca05cb
Author: Stanislav Fomichev <sdf@google.com>
Date:   Tue Oct 15 11:31:24 2019 -0700

    bpf: Allow __sk_buff tstamp in BPF_PROG_TEST_RUN
    
    It's useful for implementing EDT related tests (set tstamp, run the
    test, see how the tstamp is changed or observe some other parameter).
    
    Note that bpf_ktime_get_ns() helper is using monotonic clock, so for
    the BPF programs that compare tstamp against it, tstamp should be
    derived from clock_gettime(CLOCK_MONOTONIC, ...).
    
    Signed-off-by: Stanislav Fomichev <sdf@google.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>
    Acked-by: Martin KaFai Lau <kafai@fb.com>
    Link: https://lore.kernel.org/bpf/20191015183125.124413-1-sdf@google.com

commit fbcab84bd885b79125be32bddb88c5432dbd282b
Author: Christophe Leroy <christophe.leroy@c-s.fr>
Date:   Thu Apr 4 12:20:05 2019 +0000

    powerpc/vdso32: fix CLOCK_MONOTONIC on PPC64
    
    commit dd9a994fc68d196a052b73747e3366c57d14a09e upstream.
    
    Commit b5b4453e7912 ("powerpc/vdso64: Fix CLOCK_MONOTONIC
    inconsistencies across Y2038") changed the type of wtom_clock_sec
    to s64 on PPC64. Therefore, VDSO32 needs to read it with a 4 bytes
    shift in order to retrieve the lower part of it.
    
    Fixes: b5b4453e7912 ("powerpc/vdso64: Fix CLOCK_MONOTONIC inconsistencies across Y2038")
    Reported-by: Christian Zigotzky <chzigotzky@xenosoft.de>
    Signed-off-by: Christophe Leroy <christophe.leroy@c-s.fr>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit bb693bc07a915f22f93f4a67c09764bfbe356cd0
Author: Michael Ellerman <mpe@ellerman.id.au>
Date:   Thu Mar 14 00:14:38 2019 +1100

    powerpc/vdso64: Fix CLOCK_MONOTONIC inconsistencies across Y2038
    
    commit b5b4453e7912f056da1ca7572574cada32ecb60c upstream.
    
    Jakub Drnec reported:
      Setting the realtime clock can sometimes make the monotonic clock go
      back by over a hundred years. Decreasing the realtime clock across
      the y2k38 threshold is one reliable way to reproduce. Allegedly this
      can also happen just by running ntpd, I have not managed to
      reproduce that other than booting with rtc at >2038 and then running
      ntp. When this happens, anything with timers (e.g. openjdk) breaks
      rather badly.
    
    And included a test case (slightly edited for brevity):
      #define _POSIX_C_SOURCE 199309L
      #include <stdio.h>
      #include <time.h>
      #include <stdlib.h>
      #include <unistd.h>
    
      long get_time(void) {
        struct timespec tp;
        clock_gettime(CLOCK_MONOTONIC, &tp);
        return tp.tv_sec + tp.tv_nsec / 1000000000;
      }
    
      int main(void) {
        long last = get_time();
        while(1) {
          long now = get_time();
          if (now < last) {
            printf("clock went backwards by %ld seconds!\n", last - now);
          }
          last = now;
          sleep(1);
        }
        return 0;
      }
    
    Which when run concurrently with:
     # date -s 2040-1-1
     # date -s 2037-1-1
    
    Will detect the clock going backward.
    
    The root cause is that wtom_clock_sec in struct vdso_data is only a
    32-bit signed value, even though we set its value to be equal to
    tk->wall_to_monotonic.tv_sec which is 64-bits.
    
    Because the monotonic clock starts at zero when the system boots the
    wall_to_montonic.tv_sec offset is negative for current and future
    dates. Currently on a freshly booted system the offset will be in the
    vicinity of negative 1.5 billion seconds.
    
    However if the wall clock is set past the Y2038 boundary, the offset
    from wall to monotonic becomes less than negative 2^31, and no longer
    fits in 32-bits. When that value is assigned to wtom_clock_sec it is
    truncated and becomes positive, causing the VDSO assembly code to
    calculate CLOCK_MONOTONIC incorrectly.
    
    That causes CLOCK_MONOTONIC to jump ahead by ~4 billion seconds which
    it is not meant to do. Worse, if the time is then set back before the
    Y2038 boundary CLOCK_MONOTONIC will jump backward.
    
    We can fix it simply by storing the full 64-bit offset in the
    vdso_data, and using that in the VDSO assembly code. We also shuffle
    some of the fields in vdso_data to avoid creating a hole.
    
    The original commit that added the CLOCK_MONOTONIC support to the VDSO
    did actually use a 64-bit value for wtom_clock_sec, see commit
    a7f290dad32e ("[PATCH] powerpc: Merge vdso's and add vdso support to
    32 bits kernel") (Nov 2005). However just 3 days later it was
    converted to 32-bits in commit 0c37ec2aa88b ("[PATCH] powerpc: vdso
    fixes (take #2)"), and the bug has existed since then AFAICS.
    
    Fixes: 0c37ec2aa88b ("[PATCH] powerpc: vdso fixes (take #2)")
    Link: http://lkml.kernel.org/r/HaC.ZfES.62bwlnvAvMP.1STMMj@seznam.cz
    Reported-by: Jakub Drnec <jaydee@email.cz>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    [bwh: Backported to 3.16: CLOCK_MONOTONIC_COARSE is not handled by
     this vDSO]
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit 54002066100b6d2f731157156c41d853e0c9137e
Author: Vedang Patel <vedang.patel@intel.com>
Date:   Tue Jun 25 15:07:19 2019 -0700

    taprio: Adjust timestamps for TCP packets
    
    When the taprio qdisc is running in "txtime offload" mode, it will
    set the launchtime value (in skb->tstamp) for all the packets which do
    not have the SO_TXTIME socket option. But, the TCP packets already have
    this value set and it indicates the earliest departure time represented
    in CLOCK_MONOTONIC clock.
    
    We need to respect the timestamp set by the TCP subsystem. So, convert
    this time to the clock which taprio is using and ensure that the packet
    is not transmitted before the deadline set by TCP.
    
    Signed-off-by: Vedang Patel <vedang.patel@intel.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 7ede7b03484bbb035aa5be98c45a40cfabdc0738
Author: Vedang Patel <vedang.patel@intel.com>
Date:   Tue Jun 25 15:07:18 2019 -0700

    taprio: make clock reference conversions easier
    
    Later in this series we will need to transform from
    CLOCK_MONOTONIC (used in TCP) to the clock reference used in TAPRIO.
    
    Signed-off-by: Vinicius Costa Gomes <vinicius.gomes@intel.com>
    Signed-off-by: Vedang Patel <vedang.patel@intel.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit e0cef9ff6315d48a4dfd39da09ca770e242f9cb5
Author: Aurelien Thierry <aurelien.thierry@quoscient.io>
Date:   Fri Jun 7 10:07:02 2019 +0200

    Documentation: fix typo CLOCK_MONONOTNIC_COARSE
    
    Fix typo in documentation file timekeeping.rst: CLOCK_MONONOTNIC_COARSE
    should be CLOCK_MONOTONIC_COARSE.
    
    Signed-off-by: Aurelien Thierry <aurelien.thierry@quoscient.io>
    Signed-off-by: Jonathan Corbet <corbet@lwn.net>

commit dc0f37b780e97d45c580a7141f6ac06b1ea5ba07
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Mar 23 11:36:19 2019 +0100

    timekeeping: Force upper bound for setting CLOCK_REALTIME
    
    [ Upstream commit 7a8e61f8478639072d402a26789055a4a4de8f77 ]
    
    Several people reported testing failures after setting CLOCK_REALTIME close
    to the limits of the kernel internal representation in nanoseconds,
    i.e. year 2262.
    
    The failures are exposed in subsequent operations, i.e. when arming timers
    or when the advancing CLOCK_MONOTONIC makes the calculation of
    CLOCK_REALTIME overflow into negative space.
    
    Now people start to paper over the underlying problem by clamping
    calculations to the valid range, but that's just wrong because such
    workarounds will prevent detection of real issues as well.
    
    It is reasonable to force an upper bound for the various methods of setting
    CLOCK_REALTIME. Year 2262 is the absolute upper bound. Assume a maximum
    uptime of 30 years which is plenty enough even for esoteric embedded
    systems. That results in an upper bound of year 2232 for setting the time.
    
    Once that limit is reached in reality this limit is only a small part of
    the problem space. But until then this stops people from trying to paper
    over the problem at the wrong places.
    
    Reported-by: Xiongfeng Wang <wangxiongfeng2@huawei.com>
    Reported-by: Hongbo Yao <yaohongbo@huawei.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Stephen Boyd <sboyd@kernel.org>
    Cc: Miroslav Lichvar <mlichvar@redhat.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: https://lkml.kernel.org/r/alpine.DEB.2.21.1903231125480.2157@nanos.tec.linutronix.de
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit faa3f27911352ab2c23e5c8e0fb0801b8e4dd092
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Mar 23 11:36:19 2019 +0100

    timekeeping: Force upper bound for setting CLOCK_REALTIME
    
    [ Upstream commit 7a8e61f8478639072d402a26789055a4a4de8f77 ]
    
    Several people reported testing failures after setting CLOCK_REALTIME close
    to the limits of the kernel internal representation in nanoseconds,
    i.e. year 2262.
    
    The failures are exposed in subsequent operations, i.e. when arming timers
    or when the advancing CLOCK_MONOTONIC makes the calculation of
    CLOCK_REALTIME overflow into negative space.
    
    Now people start to paper over the underlying problem by clamping
    calculations to the valid range, but that's just wrong because such
    workarounds will prevent detection of real issues as well.
    
    It is reasonable to force an upper bound for the various methods of setting
    CLOCK_REALTIME. Year 2262 is the absolute upper bound. Assume a maximum
    uptime of 30 years which is plenty enough even for esoteric embedded
    systems. That results in an upper bound of year 2232 for setting the time.
    
    Once that limit is reached in reality this limit is only a small part of
    the problem space. But until then this stops people from trying to paper
    over the problem at the wrong places.
    
    Reported-by: Xiongfeng Wang <wangxiongfeng2@huawei.com>
    Reported-by: Hongbo Yao <yaohongbo@huawei.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Stephen Boyd <sboyd@kernel.org>
    Cc: Miroslav Lichvar <mlichvar@redhat.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: https://lkml.kernel.org/r/alpine.DEB.2.21.1903231125480.2157@nanos.tec.linutronix.de
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 5e04fcbab4b417ac1110ec917f653d7eb38fd056
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Mar 23 11:36:19 2019 +0100

    timekeeping: Force upper bound for setting CLOCK_REALTIME
    
    [ Upstream commit 7a8e61f8478639072d402a26789055a4a4de8f77 ]
    
    Several people reported testing failures after setting CLOCK_REALTIME close
    to the limits of the kernel internal representation in nanoseconds,
    i.e. year 2262.
    
    The failures are exposed in subsequent operations, i.e. when arming timers
    or when the advancing CLOCK_MONOTONIC makes the calculation of
    CLOCK_REALTIME overflow into negative space.
    
    Now people start to paper over the underlying problem by clamping
    calculations to the valid range, but that's just wrong because such
    workarounds will prevent detection of real issues as well.
    
    It is reasonable to force an upper bound for the various methods of setting
    CLOCK_REALTIME. Year 2262 is the absolute upper bound. Assume a maximum
    uptime of 30 years which is plenty enough even for esoteric embedded
    systems. That results in an upper bound of year 2232 for setting the time.
    
    Once that limit is reached in reality this limit is only a small part of
    the problem space. But until then this stops people from trying to paper
    over the problem at the wrong places.
    
    Reported-by: Xiongfeng Wang <wangxiongfeng2@huawei.com>
    Reported-by: Hongbo Yao <yaohongbo@huawei.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Stephen Boyd <sboyd@kernel.org>
    Cc: Miroslav Lichvar <mlichvar@redhat.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: https://lkml.kernel.org/r/alpine.DEB.2.21.1903231125480.2157@nanos.tec.linutronix.de
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit af5136f95045b6c4bb8a53d2f288a905c3bd6f25
Author: Willem de Bruijn <willemb@google.com>
Date:   Thu May 23 13:48:46 2019 -0400

    selftests/net: SO_TXTIME with ETF and FQ
    
    The SO_TXTIME API enables packet tranmission with delayed delivery.
    This is currently supported by the ETF and FQ packet schedulers.
    
    Evaluate the interface with both schedulers. Install the scheduler
    and send a variety of packets streams: without delay, with one
    delayed packet, with multiple ordered delays and with reordering.
    Verify that packets are released by the scheduler in expected order.
    
    The ETF qdisc requires a timestamp in the future on every packet. It
    needs a delay on the qdisc else the packet is dropped on dequeue for
    having a delivery time in the past. The test value is experimentally
    derived. ETF requires clock_id CLOCK_TAI. It checks this base and
    drops for non-conformance.
    
    The FQ qdisc expects clock_id CLOCK_MONOTONIC, the base used by TCP
    as of commit fb420d5d91c1 ("tcp/fq: move back to CLOCK_MONOTONIC").
    Within a flow there is an expecation of ordered delivery, as shown by
    delivery times of test 4. The FQ qdisc does not require all packets to
    have timestamps and does not drop for non-conformance.
    
    The large (msec) delays are chosen to avoid flakiness.
    
            Output:
    
            SO_TXTIME ipv6 clock monotonic
            payload:a delay:28 expected:0 (us)
    
            SO_TXTIME ipv4 clock monotonic
            payload:a delay:38 expected:0 (us)
    
            SO_TXTIME ipv6 clock monotonic
            payload:a delay:40 expected:0 (us)
    
            SO_TXTIME ipv4 clock monotonic
            payload:a delay:33 expected:0 (us)
    
            SO_TXTIME ipv6 clock monotonic
            payload:a delay:10120 expected:10000 (us)
    
            SO_TXTIME ipv4 clock monotonic
            payload:a delay:10102 expected:10000 (us)
    
            [.. etc ..]
    
            OK. All tests passed
    
    Changes v1->v2: update commit message output
    
    Signed-off-by: Willem de Bruijn <willemb@google.com>
    Acked-by: Eric Dumazet <edumazet@google.com>
    Acked-by: Vinicius Costa Gomes <vinicius.gomes@intel.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit ddb632889faeb7fb462b3e3e814f0a51186a8ad4
Author: Florian Westphal <fw@strlen.de>
Date:   Wed Apr 17 02:17:23 2019 +0200

    netfilter: never get/set skb->tstamp
    
    [ Upstream commit 916f6efae62305796e012e7c3a7884a267cbacbf ]
    
    setting net.netfilter.nf_conntrack_timestamp=1 breaks xmit with fq
    scheduler.  skb->tstamp might be "refreshed" using ktime_get_real(),
    but fq expects CLOCK_MONOTONIC.
    
    This patch removes all places in netfilter that check/set skb->tstamp:
    
    1. To fix the bogus "start" time seen with conntrack timestamping for
       outgoing packets, never use skb->tstamp and always use current time.
    2. In nfqueue and nflog, only use skb->tstamp for incoming packets,
       as determined by current hook (prerouting, input, forward).
    3. xt_time has to use system clock as well rather than skb->tstamp.
       We could still use skb->tstamp for prerouting/input/foward, but
       I see no advantage to make this conditional.
    
    Fixes: fb420d5d91c1 ("tcp/fq: move back to CLOCK_MONOTONIC")
    Cc: Eric Dumazet <edumazet@google.com>
    Reported-by: Michal Soltys <soltys@ziu.info>
    Signed-off-by: Florian Westphal <fw@strlen.de>
    Acked-by: Eric Dumazet <edumazet@google.com>
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit b6f3aa978866902ba23b3b38437cc41a8eced565
Author: Christophe Leroy <christophe.leroy@c-s.fr>
Date:   Thu Apr 4 12:20:05 2019 +0000

    powerpc/vdso32: fix CLOCK_MONOTONIC on PPC64
    
    [ Upstream commit dd9a994fc68d196a052b73747e3366c57d14a09e ]
    
    Commit b5b4453e7912 ("powerpc/vdso64: Fix CLOCK_MONOTONIC
    inconsistencies across Y2038") changed the type of wtom_clock_sec
    to s64 on PPC64. Therefore, VDSO32 needs to read it with a 4 bytes
    shift in order to retrieve the lower part of it.
    
    Fixes: b5b4453e7912 ("powerpc/vdso64: Fix CLOCK_MONOTONIC inconsistencies across Y2038")
    Reported-by: Christian Zigotzky <chzigotzky@xenosoft.de>
    Signed-off-by: Christophe Leroy <christophe.leroy@c-s.fr>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 1e0cab1bce57cf1618eeb57d399b6f9dfe49fa5b
Author: Christophe Leroy <christophe.leroy@c-s.fr>
Date:   Thu Apr 4 12:20:05 2019 +0000

    powerpc/vdso32: fix CLOCK_MONOTONIC on PPC64
    
    [ Upstream commit dd9a994fc68d196a052b73747e3366c57d14a09e ]
    
    Commit b5b4453e7912 ("powerpc/vdso64: Fix CLOCK_MONOTONIC
    inconsistencies across Y2038") changed the type of wtom_clock_sec
    to s64 on PPC64. Therefore, VDSO32 needs to read it with a 4 bytes
    shift in order to retrieve the lower part of it.
    
    Fixes: b5b4453e7912 ("powerpc/vdso64: Fix CLOCK_MONOTONIC inconsistencies across Y2038")
    Reported-by: Christian Zigotzky <chzigotzky@xenosoft.de>
    Signed-off-by: Christophe Leroy <christophe.leroy@c-s.fr>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit acced9d2b4dffaca5ce2228d70e6074965d54a27
Merge: 26d1b8586b4f d48668052b26
Author: David S. Miller <davem@davemloft.net>
Date:   Mon Apr 22 21:23:55 2019 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/pablo/nf
    
    Pablo Neira Ayuso says:
    
    ====================
    Netfilter/IPVS fixes for net
    
    The following patchset contains Netfilter/IPVS fixes for your net tree:
    
    1) Add a selftest for icmp packet too big errors with conntrack, from
       Florian Westphal.
    
    2) Validate inner header in ICMP error message does not lie to us
       in conntrack, also from Florian.
    
    3) Initialize ct->timeout to calm down KASAN, from Alexander Potapenko.
    
    4) Skip ICMP error messages from tunnels in IPVS, from Julian Anastasov.
    
    5) Use a hash to expose conntrack and expectation ID, from Florian Westphal.
    
    6) Prevent shift wrap in nft_chain_parse_hook(), from Dan Carpenter.
    
    7) Fix broken ICMP ID randomization with NAT, also from Florian.
    
    8) Remove WARN_ON in ebtables compat that is reached via syzkaller,
       from Florian Westphal.
    
    9) Fix broken timestamps since fb420d5d91c1 ("tcp/fq: move back to
       CLOCK_MONOTONIC"), from Florian.
    
    10) Fix logging of invalid packets in conntrack, from Andrei Vagin.
    ====================
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 916f6efae62305796e012e7c3a7884a267cbacbf
Author: Florian Westphal <fw@strlen.de>
Date:   Wed Apr 17 02:17:23 2019 +0200

    netfilter: never get/set skb->tstamp
    
    setting net.netfilter.nf_conntrack_timestamp=1 breaks xmit with fq
    scheduler.  skb->tstamp might be "refreshed" using ktime_get_real(),
    but fq expects CLOCK_MONOTONIC.
    
    This patch removes all places in netfilter that check/set skb->tstamp:
    
    1. To fix the bogus "start" time seen with conntrack timestamping for
       outgoing packets, never use skb->tstamp and always use current time.
    2. In nfqueue and nflog, only use skb->tstamp for incoming packets,
       as determined by current hook (prerouting, input, forward).
    3. xt_time has to use system clock as well rather than skb->tstamp.
       We could still use skb->tstamp for prerouting/input/foward, but
       I see no advantage to make this conditional.
    
    Fixes: fb420d5d91c1 ("tcp/fq: move back to CLOCK_MONOTONIC")
    Cc: Eric Dumazet <edumazet@google.com>
    Reported-by: Michal Soltys <soltys@ziu.info>
    Signed-off-by: Florian Westphal <fw@strlen.de>
    Acked-by: Eric Dumazet <edumazet@google.com>
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>

commit bf4bf09bdd91a75bb175c172b3f7251a4845f591
Author: Jacob Keller <jacob.e.keller@intel.com>
Date:   Tue Feb 12 13:56:24 2019 -0800

    i40e: save PTP time before a device reset
    
    In the case where PTP is running on the hardware clock, but the kernel
    system time is not being synced, a device reset can mess up the clock
    time.
    
    This occurs because we reset the clock time based on the kernel time
    every reset. This causes us to potentially completely reset the PTP
    time, and can cause unexpected behavior in programs like ptp4l.
    
    Avoid this by saving the PTP time prior to device reset, and then
    restoring using that time after the reset.
    
    Directly restoring the PTP time we saved isn't perfect, because time
    should have continued running, but the clock will essentially be stopped
    during the reset. This is still better than the current solution of
    assuming that the PTP HW clock is synced to the CLOCK_REALTIME.
    
    We can do even better, by saving the ktime and calculating
    a differential, using ktime_get(). This is based on CLOCK_MONOTONIC, and
    allows us to get a fairly precise measure of the time difference between
    saving and restoring the time.
    
    Using this, we can update the saved PTP time, and use that as the value
    to write to the hardware clock registers. This, of course is not perfect.
    However, it does help ensure that the PTP time is restored as close as
    feasible to the time it should have been if the reset had not occurred.
    
    During device initialization, continue using the system time as the
    source for the creation of the PTP clock, since this is the best known
    current time source at driver load.
    
    Signed-off-by: Jacob Keller <jacob.e.keller@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

commit cf60528f8ab805ba03e21ce4ce6ab11647cede9b
Merge: 5ded88718aef cf7cf6977f53
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Apr 13 09:03:09 2019 -0700

    Merge tag 'powerpc-5.1-5' of git://git.kernel.org/pub/scm/linux/kernel/git/powerpc/linux
    
    Pull powerpc fixes from Michael Ellerman:
     "A minor build fix for 64-bit FLATMEM configs.
    
      A fix for a boot failure on 32-bit powermacs.
    
      My commit to fix CLOCK_MONOTONIC across Y2038 broke the 32-bit VDSO on
      64-bit kernels, ie. compat mode, which is only used on big endian.
    
      The rewrite of the SLB code we merged in 4.20 missed the fact that the
      0x380 exception is also used with the Radix MMU to report out of range
      accesses. This could lead to an oops if userspace tried to read from
      addresses outside the user or kernel range.
    
      Thanks to: Aneesh Kumar K.V, Christophe Leroy, Larry Finger, Nicholas
      Piggin"
    
    * tag 'powerpc-5.1-5' of git://git.kernel.org/pub/scm/linux/kernel/git/powerpc/linux:
      powerpc/mm: Define MAX_PHYSMEM_BITS for all 64-bit configs
      powerpc/64s/radix: Fix radix segment exception handling
      powerpc/vdso32: fix CLOCK_MONOTONIC on PPC64
      powerpc/32: Fix early boot failure with RTAS built-in

commit dd9a994fc68d196a052b73747e3366c57d14a09e
Author: Christophe Leroy <christophe.leroy@c-s.fr>
Date:   Thu Apr 4 12:20:05 2019 +0000

    powerpc/vdso32: fix CLOCK_MONOTONIC on PPC64
    
    Commit b5b4453e7912 ("powerpc/vdso64: Fix CLOCK_MONOTONIC
    inconsistencies across Y2038") changed the type of wtom_clock_sec
    to s64 on PPC64. Therefore, VDSO32 needs to read it with a 4 bytes
    shift in order to retrieve the lower part of it.
    
    Fixes: b5b4453e7912 ("powerpc/vdso64: Fix CLOCK_MONOTONIC inconsistencies across Y2038")
    Reported-by: Christian Zigotzky <chzigotzky@xenosoft.de>
    Signed-off-by: Christophe Leroy <christophe.leroy@c-s.fr>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

commit 7a8e61f8478639072d402a26789055a4a4de8f77
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Mar 23 11:36:19 2019 +0100

    timekeeping: Force upper bound for setting CLOCK_REALTIME
    
    Several people reported testing failures after setting CLOCK_REALTIME close
    to the limits of the kernel internal representation in nanoseconds,
    i.e. year 2262.
    
    The failures are exposed in subsequent operations, i.e. when arming timers
    or when the advancing CLOCK_MONOTONIC makes the calculation of
    CLOCK_REALTIME overflow into negative space.
    
    Now people start to paper over the underlying problem by clamping
    calculations to the valid range, but that's just wrong because such
    workarounds will prevent detection of real issues as well.
    
    It is reasonable to force an upper bound for the various methods of setting
    CLOCK_REALTIME. Year 2262 is the absolute upper bound. Assume a maximum
    uptime of 30 years which is plenty enough even for esoteric embedded
    systems. That results in an upper bound of year 2232 for setting the time.
    
    Once that limit is reached in reality this limit is only a small part of
    the problem space. But until then this stops people from trying to paper
    over the problem at the wrong places.
    
    Reported-by: Xiongfeng Wang <wangxiongfeng2@huawei.com>
    Reported-by: Hongbo Yao <yaohongbo@huawei.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Stephen Boyd <sboyd@kernel.org>
    Cc: Miroslav Lichvar <mlichvar@redhat.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: https://lkml.kernel.org/r/alpine.DEB.2.21.1903231125480.2157@nanos.tec.linutronix.de

commit 7f5ffb4c7a710c1f441817cbeca7ca5aecc5f4ef
Author: Michael Ellerman <mpe@ellerman.id.au>
Date:   Thu Mar 14 00:14:38 2019 +1100

    powerpc/vdso64: Fix CLOCK_MONOTONIC inconsistencies across Y2038
    
    commit b5b4453e7912f056da1ca7572574cada32ecb60c upstream.
    
    Jakub Drnec reported:
      Setting the realtime clock can sometimes make the monotonic clock go
      back by over a hundred years. Decreasing the realtime clock across
      the y2k38 threshold is one reliable way to reproduce. Allegedly this
      can also happen just by running ntpd, I have not managed to
      reproduce that other than booting with rtc at >2038 and then running
      ntp. When this happens, anything with timers (e.g. openjdk) breaks
      rather badly.
    
    And included a test case (slightly edited for brevity):
      #define _POSIX_C_SOURCE 199309L
      #include <stdio.h>
      #include <time.h>
      #include <stdlib.h>
      #include <unistd.h>
    
      long get_time(void) {
        struct timespec tp;
        clock_gettime(CLOCK_MONOTONIC, &tp);
        return tp.tv_sec + tp.tv_nsec / 1000000000;
      }
    
      int main(void) {
        long last = get_time();
        while(1) {
          long now = get_time();
          if (now < last) {
            printf("clock went backwards by %ld seconds!\n", last - now);
          }
          last = now;
          sleep(1);
        }
        return 0;
      }
    
    Which when run concurrently with:
     # date -s 2040-1-1
     # date -s 2037-1-1
    
    Will detect the clock going backward.
    
    The root cause is that wtom_clock_sec in struct vdso_data is only a
    32-bit signed value, even though we set its value to be equal to
    tk->wall_to_monotonic.tv_sec which is 64-bits.
    
    Because the monotonic clock starts at zero when the system boots the
    wall_to_montonic.tv_sec offset is negative for current and future
    dates. Currently on a freshly booted system the offset will be in the
    vicinity of negative 1.5 billion seconds.
    
    However if the wall clock is set past the Y2038 boundary, the offset
    from wall to monotonic becomes less than negative 2^31, and no longer
    fits in 32-bits. When that value is assigned to wtom_clock_sec it is
    truncated and becomes positive, causing the VDSO assembly code to
    calculate CLOCK_MONOTONIC incorrectly.
    
    That causes CLOCK_MONOTONIC to jump ahead by ~4 billion seconds which
    it is not meant to do. Worse, if the time is then set back before the
    Y2038 boundary CLOCK_MONOTONIC will jump backward.
    
    We can fix it simply by storing the full 64-bit offset in the
    vdso_data, and using that in the VDSO assembly code. We also shuffle
    some of the fields in vdso_data to avoid creating a hole.
    
    The original commit that added the CLOCK_MONOTONIC support to the VDSO
    did actually use a 64-bit value for wtom_clock_sec, see commit
    a7f290dad32e ("[PATCH] powerpc: Merge vdso's and add vdso support to
    32 bits kernel") (Nov 2005). However just 3 days later it was
    converted to 32-bits in commit 0c37ec2aa88b ("[PATCH] powerpc: vdso
    fixes (take #2)"), and the bug has existed since then AFAICS.
    
    Fixes: 0c37ec2aa88b ("[PATCH] powerpc: vdso fixes (take #2)")
    Cc: stable@vger.kernel.org # v2.6.15+
    Link: http://lkml.kernel.org/r/HaC.ZfES.62bwlnvAvMP.1STMMj@seznam.cz
    Reported-by: Jakub Drnec <jaydee@email.cz>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit b8ea151a7ab5448782006b3723e6b25c33cbae64
Author: Michael Ellerman <mpe@ellerman.id.au>
Date:   Thu Mar 14 00:14:38 2019 +1100

    powerpc/vdso64: Fix CLOCK_MONOTONIC inconsistencies across Y2038
    
    commit b5b4453e7912f056da1ca7572574cada32ecb60c upstream.
    
    Jakub Drnec reported:
      Setting the realtime clock can sometimes make the monotonic clock go
      back by over a hundred years. Decreasing the realtime clock across
      the y2k38 threshold is one reliable way to reproduce. Allegedly this
      can also happen just by running ntpd, I have not managed to
      reproduce that other than booting with rtc at >2038 and then running
      ntp. When this happens, anything with timers (e.g. openjdk) breaks
      rather badly.
    
    And included a test case (slightly edited for brevity):
      #define _POSIX_C_SOURCE 199309L
      #include <stdio.h>
      #include <time.h>
      #include <stdlib.h>
      #include <unistd.h>
    
      long get_time(void) {
        struct timespec tp;
        clock_gettime(CLOCK_MONOTONIC, &tp);
        return tp.tv_sec + tp.tv_nsec / 1000000000;
      }
    
      int main(void) {
        long last = get_time();
        while(1) {
          long now = get_time();
          if (now < last) {
            printf("clock went backwards by %ld seconds!\n", last - now);
          }
          last = now;
          sleep(1);
        }
        return 0;
      }
    
    Which when run concurrently with:
     # date -s 2040-1-1
     # date -s 2037-1-1
    
    Will detect the clock going backward.
    
    The root cause is that wtom_clock_sec in struct vdso_data is only a
    32-bit signed value, even though we set its value to be equal to
    tk->wall_to_monotonic.tv_sec which is 64-bits.
    
    Because the monotonic clock starts at zero when the system boots the
    wall_to_montonic.tv_sec offset is negative for current and future
    dates. Currently on a freshly booted system the offset will be in the
    vicinity of negative 1.5 billion seconds.
    
    However if the wall clock is set past the Y2038 boundary, the offset
    from wall to monotonic becomes less than negative 2^31, and no longer
    fits in 32-bits. When that value is assigned to wtom_clock_sec it is
    truncated and becomes positive, causing the VDSO assembly code to
    calculate CLOCK_MONOTONIC incorrectly.
    
    That causes CLOCK_MONOTONIC to jump ahead by ~4 billion seconds which
    it is not meant to do. Worse, if the time is then set back before the
    Y2038 boundary CLOCK_MONOTONIC will jump backward.
    
    We can fix it simply by storing the full 64-bit offset in the
    vdso_data, and using that in the VDSO assembly code. We also shuffle
    some of the fields in vdso_data to avoid creating a hole.
    
    The original commit that added the CLOCK_MONOTONIC support to the VDSO
    did actually use a 64-bit value for wtom_clock_sec, see commit
    a7f290dad32e ("[PATCH] powerpc: Merge vdso's and add vdso support to
    32 bits kernel") (Nov 2005). However just 3 days later it was
    converted to 32-bits in commit 0c37ec2aa88b ("[PATCH] powerpc: vdso
    fixes (take #2)"), and the bug has existed since then AFAICS.
    
    Fixes: 0c37ec2aa88b ("[PATCH] powerpc: vdso fixes (take #2)")
    Cc: stable@vger.kernel.org # v2.6.15+
    Link: http://lkml.kernel.org/r/HaC.ZfES.62bwlnvAvMP.1STMMj@seznam.cz
    Reported-by: Jakub Drnec <jaydee@email.cz>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit a5ed1e96cafde5ba48638f486bfca0685dc6ddc9
Merge: 070c95d45726 92edf8df0ff2
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Mar 22 14:15:11 2019 -0700

    Merge tag 'powerpc-5.1-3' of git://git.kernel.org/pub/scm/linux/kernel/git/powerpc/linux
    
    Pull powerpc fixes from Michael Ellerman:
     "One fix for a boot failure on 32-bit, introduced during the merge
      window.
    
      A fix for our handling of CLOCK_MONOTONIC in the 64-bit VDSO. Changing
      the wall clock across the Y2038 boundary could cause CLOCK_MONOTONIC
      to jump forward and backward.
    
      Our spectre_v2 reporting was a bit confusing due to a bug I
      introduced. On some systems it was reporting that the count cache was
      disabled and also that we were flushing the count cache on context
      switch. Only the former is true, and given that the count cache is
      disabled it doesn't make any sense to flush it. No one reported it, so
      presumably the presence of any mitigation is all people check for.
    
      Finally a small build fix for zsmalloc on 32-bit.
    
      Thanks to: Ben Hutchings, Christophe Leroy, Diana Craciun, Guenter
      Roeck, Michael Neuling"
    
    * tag 'powerpc-5.1-3' of git://git.kernel.org/pub/scm/linux/kernel/git/powerpc/linux:
      powerpc/security: Fix spectre_v2 reporting
      powerpc/mm: Only define MAX_PHYSMEM_BITS in SPARSEMEM configurations
      powerpc/6xx: fix setup and use of SPRN_SPRG_PGDIR for hash32
      powerpc/vdso64: Fix CLOCK_MONOTONIC inconsistencies across Y2038

commit b5b4453e7912f056da1ca7572574cada32ecb60c
Author: Michael Ellerman <mpe@ellerman.id.au>
Date:   Thu Mar 14 00:14:38 2019 +1100

    powerpc/vdso64: Fix CLOCK_MONOTONIC inconsistencies across Y2038
    
    Jakub Drnec reported:
      Setting the realtime clock can sometimes make the monotonic clock go
      back by over a hundred years. Decreasing the realtime clock across
      the y2k38 threshold is one reliable way to reproduce. Allegedly this
      can also happen just by running ntpd, I have not managed to
      reproduce that other than booting with rtc at >2038 and then running
      ntp. When this happens, anything with timers (e.g. openjdk) breaks
      rather badly.
    
    And included a test case (slightly edited for brevity):
      #define _POSIX_C_SOURCE 199309L
      #include <stdio.h>
      #include <time.h>
      #include <stdlib.h>
      #include <unistd.h>
    
      long get_time(void) {
        struct timespec tp;
        clock_gettime(CLOCK_MONOTONIC, &tp);
        return tp.tv_sec + tp.tv_nsec / 1000000000;
      }
    
      int main(void) {
        long last = get_time();
        while(1) {
          long now = get_time();
          if (now < last) {
            printf("clock went backwards by %ld seconds!\n", last - now);
          }
          last = now;
          sleep(1);
        }
        return 0;
      }
    
    Which when run concurrently with:
     # date -s 2040-1-1
     # date -s 2037-1-1
    
    Will detect the clock going backward.
    
    The root cause is that wtom_clock_sec in struct vdso_data is only a
    32-bit signed value, even though we set its value to be equal to
    tk->wall_to_monotonic.tv_sec which is 64-bits.
    
    Because the monotonic clock starts at zero when the system boots the
    wall_to_montonic.tv_sec offset is negative for current and future
    dates. Currently on a freshly booted system the offset will be in the
    vicinity of negative 1.5 billion seconds.
    
    However if the wall clock is set past the Y2038 boundary, the offset
    from wall to monotonic becomes less than negative 2^31, and no longer
    fits in 32-bits. When that value is assigned to wtom_clock_sec it is
    truncated and becomes positive, causing the VDSO assembly code to
    calculate CLOCK_MONOTONIC incorrectly.
    
    That causes CLOCK_MONOTONIC to jump ahead by ~4 billion seconds which
    it is not meant to do. Worse, if the time is then set back before the
    Y2038 boundary CLOCK_MONOTONIC will jump backward.
    
    We can fix it simply by storing the full 64-bit offset in the
    vdso_data, and using that in the VDSO assembly code. We also shuffle
    some of the fields in vdso_data to avoid creating a hole.
    
    The original commit that added the CLOCK_MONOTONIC support to the VDSO
    did actually use a 64-bit value for wtom_clock_sec, see commit
    a7f290dad32e ("[PATCH] powerpc: Merge vdso's and add vdso support to
    32 bits kernel") (Nov 2005). However just 3 days later it was
    converted to 32-bits in commit 0c37ec2aa88b ("[PATCH] powerpc: vdso
    fixes (take #2)"), and the bug has existed since then AFAICS.
    
    Fixes: 0c37ec2aa88b ("[PATCH] powerpc: vdso fixes (take #2)")
    Cc: stable@vger.kernel.org # v2.6.15+
    Link: http://lkml.kernel.org/r/HaC.ZfES.62bwlnvAvMP.1STMMj@seznam.cz
    Reported-by: Jakub Drnec <jaydee@email.cz>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

commit 3f0824ad45ea350addc33e4a058002f868579f76
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Feb 25 10:27:37 2017 +0000

    mac80211_hwsim: Replace bogus hrtimer clockid
    
    commit 8fbcfeb8a9cc803464d6c166e7991913711c612c upstream.
    
    mac80211_hwsim initializes a hrtimer with clockid
    CLOCK_MONOTONIC_RAW. That's not supported.
    
    Use CLOCK_MONOTONIC instead.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit 183144815e34369b97b8efbee7f524388c71ae1f
Author: Paolo Abeni <pabeni@redhat.com>
Date:   Tue Jan 8 18:45:05 2019 +0100

    net: clear skb->tstamp in bridge forwarding path
    
    [ Upstream commit 41d1c8839e5f8cb781cc635f12791decee8271b7 ]
    
    Matteo reported forwarding issues inside the linux bridge,
    if the enslaved interfaces use the fq qdisc.
    
    Similar to commit 8203e2d844d3 ("net: clear skb->tstamp in
    forwarding paths"), we need to clear the tstamp field in
    the bridge forwarding path.
    
    Fixes: 80b14dee2bea ("net: Add a new socket option for a future transmit time.")
    Fixes: fb420d5d91c1 ("tcp/fq: move back to CLOCK_MONOTONIC")
    Reported-and-tested-by: Matteo Croce <mcroce@redhat.com>
    Signed-off-by: Paolo Abeni <pabeni@redhat.com>
    Acked-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Acked-by: Roopa Prabhu <roopa@cumulusnetworks.com>
    Reviewed-by: Eric Dumazet <edumazet@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit b6516d48403e04cf0e33784bed7934c609ad399a
Author: Paolo Abeni <pabeni@redhat.com>
Date:   Tue Jan 8 18:45:05 2019 +0100

    net: clear skb->tstamp in bridge forwarding path
    
    [ Upstream commit 41d1c8839e5f8cb781cc635f12791decee8271b7 ]
    
    Matteo reported forwarding issues inside the linux bridge,
    if the enslaved interfaces use the fq qdisc.
    
    Similar to commit 8203e2d844d3 ("net: clear skb->tstamp in
    forwarding paths"), we need to clear the tstamp field in
    the bridge forwarding path.
    
    Fixes: 80b14dee2bea ("net: Add a new socket option for a future transmit time.")
    Fixes: fb420d5d91c1 ("tcp/fq: move back to CLOCK_MONOTONIC")
    Reported-and-tested-by: Matteo Croce <mcroce@redhat.com>
    Signed-off-by: Paolo Abeni <pabeni@redhat.com>
    Acked-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Acked-by: Roopa Prabhu <roopa@cumulusnetworks.com>
    Reviewed-by: Eric Dumazet <edumazet@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 41d1c8839e5f8cb781cc635f12791decee8271b7
Author: Paolo Abeni <pabeni@redhat.com>
Date:   Tue Jan 8 18:45:05 2019 +0100

    net: clear skb->tstamp in bridge forwarding path
    
    Matteo reported forwarding issues inside the linux bridge,
    if the enslaved interfaces use the fq qdisc.
    
    Similar to commit 8203e2d844d3 ("net: clear skb->tstamp in
    forwarding paths"), we need to clear the tstamp field in
    the bridge forwarding path.
    
    Fixes: 80b14dee2bea ("net: Add a new socket option for a future transmit time.")
    Fixes: fb420d5d91c1 ("tcp/fq: move back to CLOCK_MONOTONIC")
    Reported-and-tested-by: Matteo Croce <mcroce@redhat.com>
    Signed-off-by: Paolo Abeni <pabeni@redhat.com>
    Acked-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Acked-by: Roopa Prabhu <roopa@cumulusnetworks.com>
    Reviewed-by: Eric Dumazet <edumazet@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 281731c8170accbec0f56e31b94bee62c0fcf2a4
Author: Eric Dumazet <edumazet@google.com>
Date:   Fri Dec 14 06:46:49 2018 -0800

    net: clear skb->tstamp in forwarding paths
    
    [ Upstream commit 8203e2d844d34af247a151d8ebd68553a6e91785 ]
    
    Sergey reported that forwarding was no longer working
    if fq packet scheduler was used.
    
    This is caused by the recent switch to EDT model, since incoming
    packets might have been timestamped by __net_timestamp()
    
    __net_timestamp() uses ktime_get_real(), while fq expects packets
    using CLOCK_MONOTONIC base.
    
    The fix is to clear skb->tstamp in forwarding paths.
    
    Fixes: 80b14dee2bea ("net: Add a new socket option for a future transmit time.")
    Fixes: fb420d5d91c1 ("tcp/fq: move back to CLOCK_MONOTONIC")
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Reported-by: Sergey Matyukevich <geomatsi@gmail.com>
    Tested-by: Sergey Matyukevich <geomatsi@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 4f9007359bcd28bc83c63cb9af38d8b2c8c1670d
Author: Andy Lutomirski <luto@kernel.org>
Date:   Mon Oct 1 12:52:15 2018 -0700

    x86/vdso: Fix asm constraints on vDSO syscall fallbacks
    
    commit 715bd9d12f84d8f5cc8ad21d888f9bc304a8eb0b upstream.
    
    The syscall fallbacks in the vDSO have incorrect asm constraints.
    They are not marked as writing to their outputs -- instead, they are
    marked as clobbering "memory", which is useless.  In particular, gcc
    is smart enough to know that the timespec parameter hasn't escaped,
    so a memory clobber doesn't clobber it.  And passing a pointer as an
    asm *input* does not tell gcc that the pointed-to value is changed.
    
    Add in the fact that the asm instructions weren't volatile, and gcc
    was free to omit them entirely unless their sole output (the return
    value) is used.  Which it is (phew!), but that stops happening with
    some upcoming patches.
    
    As a trivial example, the following code:
    
    void test_fallback(struct timespec *ts)
    {
            vdso_fallback_gettime(CLOCK_MONOTONIC, ts);
    }
    
    compiles to:
    
    00000000000000c0 <test_fallback>:
      c0:   c3                      retq
    
    To add insult to injury, the RCX and R11 clobbers on 64-bit
    builds were missing.
    
    The "memory" clobber is also unnecessary -- no ordering with respect to
    other memory operations is needed, but that's going to be fixed in a
    separate not-for-stable patch.
    
    Fixes: 2aae950b21e4 ("x86_64: Add vDSO for x86-64 with gettimeofday/clock_gettime/getcpu")
    Signed-off-by: Andy Lutomirski <luto@kernel.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lkml.kernel.org/r/2c0231690551989d2fafa60ed0e7b5cc8b403908.1538422295.git.luto@kernel.org
    [bwh: Backported to 3.16: adjust filename]
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit 8203e2d844d34af247a151d8ebd68553a6e91785
Author: Eric Dumazet <edumazet@google.com>
Date:   Fri Dec 14 06:46:49 2018 -0800

    net: clear skb->tstamp in forwarding paths
    
    Sergey reported that forwarding was no longer working
    if fq packet scheduler was used.
    
    This is caused by the recent switch to EDT model, since incoming
    packets might have been timestamped by __net_timestamp()
    
    __net_timestamp() uses ktime_get_real(), while fq expects packets
    using CLOCK_MONOTONIC base.
    
    The fix is to clear skb->tstamp in forwarding paths.
    
    Fixes: 80b14dee2bea ("net: Add a new socket option for a future transmit time.")
    Fixes: fb420d5d91c1 ("tcp/fq: move back to CLOCK_MONOTONIC")
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Reported-by: Sergey Matyukevich <geomatsi@gmail.com>
    Tested-by: Sergey Matyukevich <geomatsi@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 3fdf483bcf76ab19cf4412c6cac31135d7eda30e
Author: Eric Dumazet <edumazet@google.com>
Date:   Fri Oct 19 19:11:26 2018 -0700

    net: loopback: clear skb->tstamp before netif_rx()
    
    [ Upstream commit 4c16128b6271e70c8743178e90cccee147858503 ]
    
    At least UDP / TCP stacks can now cook skbs with a tstamp using
    MONOTONIC base (or arbitrary values with SCM_TXTIME)
    
    Since loopback driver does not call (directly or indirectly)
    skb_scrub_packet(), we need to clear skb->tstamp so that
    net_timestamp_check() can eventually resample the time,
    using ktime_get_real().
    
    Fixes: 80b14dee2bea ("net: Add a new socket option for a future transmit time.")
    Fixes: fb420d5d91c1 ("tcp/fq: move back to CLOCK_MONOTONIC")
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Cc: Willem de Bruijn <willemb@google.com>
    Cc: Soheil Hassas Yeganeh <soheil@google.com>
    Acked-by: Soheil Hassas Yeganeh <soheil@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sasha Levin <sashal@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 7236ead1b14923f3ba35cd29cce13246be83f451
Author: Eric Dumazet <edumazet@google.com>
Date:   Sat Nov 10 16:22:29 2018 -0800

    act_mirred: clear skb->tstamp on redirect
    
    If sch_fq is used at ingress, skbs that might have been
    timestamped by net_timestamp_set() if a packet capture
    is requesting timestamps could be delayed by arbitrary
    amount of time, since sch_fq time base is MONOTONIC.
    
    Fix this problem by moving code from sch_netem.c to act_mirred.c.
    
    Fixes: fb420d5d91c1 ("tcp/fq: move back to CLOCK_MONOTONIC")
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 4c16128b6271e70c8743178e90cccee147858503
Author: Eric Dumazet <edumazet@google.com>
Date:   Fri Oct 19 19:11:26 2018 -0700

    net: loopback: clear skb->tstamp before netif_rx()
    
    At least UDP / TCP stacks can now cook skbs with a tstamp using
    MONOTONIC base (or arbitrary values with SCM_TXTIME)
    
    Since loopback driver does not call (directly or indirectly)
    skb_scrub_packet(), we need to clear skb->tstamp so that
    net_timestamp_check() can eventually resample the time,
    using ktime_get_real().
    
    Fixes: 80b14dee2bea ("net: Add a new socket option for a future transmit time.")
    Fixes: fb420d5d91c1 ("tcp/fq: move back to CLOCK_MONOTONIC")
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Cc: Willem de Bruijn <willemb@google.com>
    Cc: Soheil Hassas Yeganeh <soheil@google.com>
    Acked-by: Soheil Hassas Yeganeh <soheil@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit e7e1889390a4a2b1e32edf26d7119ee92ad375cc
Author: Andy Lutomirski <luto@kernel.org>
Date:   Mon Oct 1 12:52:15 2018 -0700

    x86/vdso: Fix asm constraints on vDSO syscall fallbacks
    
    commit 715bd9d12f84d8f5cc8ad21d888f9bc304a8eb0b upstream.
    
    The syscall fallbacks in the vDSO have incorrect asm constraints.
    They are not marked as writing to their outputs -- instead, they are
    marked as clobbering "memory", which is useless.  In particular, gcc
    is smart enough to know that the timespec parameter hasn't escaped,
    so a memory clobber doesn't clobber it.  And passing a pointer as an
    asm *input* does not tell gcc that the pointed-to value is changed.
    
    Add in the fact that the asm instructions weren't volatile, and gcc
    was free to omit them entirely unless their sole output (the return
    value) is used.  Which it is (phew!), but that stops happening with
    some upcoming patches.
    
    As a trivial example, the following code:
    
    void test_fallback(struct timespec *ts)
    {
            vdso_fallback_gettime(CLOCK_MONOTONIC, ts);
    }
    
    compiles to:
    
    00000000000000c0 <test_fallback>:
      c0:   c3                      retq
    
    To add insult to injury, the RCX and R11 clobbers on 64-bit
    builds were missing.
    
    The "memory" clobber is also unnecessary -- no ordering with respect to
    other memory operations is needed, but that's going to be fixed in a
    separate not-for-stable patch.
    
    Fixes: 2aae950b21e4 ("x86_64: Add vDSO for x86-64 with gettimeofday/clock_gettime/getcpu")
    Signed-off-by: Andy Lutomirski <luto@kernel.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org
    Link: https://lkml.kernel.org/r/2c0231690551989d2fafa60ed0e7b5cc8b403908.1538422295.git.luto@kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 30500cc74a365c2fc90dc9b6d9611bbbc1304af9
Author: Andy Lutomirski <luto@kernel.org>
Date:   Mon Oct 1 12:52:15 2018 -0700

    x86/vdso: Fix asm constraints on vDSO syscall fallbacks
    
    commit 715bd9d12f84d8f5cc8ad21d888f9bc304a8eb0b upstream.
    
    The syscall fallbacks in the vDSO have incorrect asm constraints.
    They are not marked as writing to their outputs -- instead, they are
    marked as clobbering "memory", which is useless.  In particular, gcc
    is smart enough to know that the timespec parameter hasn't escaped,
    so a memory clobber doesn't clobber it.  And passing a pointer as an
    asm *input* does not tell gcc that the pointed-to value is changed.
    
    Add in the fact that the asm instructions weren't volatile, and gcc
    was free to omit them entirely unless their sole output (the return
    value) is used.  Which it is (phew!), but that stops happening with
    some upcoming patches.
    
    As a trivial example, the following code:
    
    void test_fallback(struct timespec *ts)
    {
            vdso_fallback_gettime(CLOCK_MONOTONIC, ts);
    }
    
    compiles to:
    
    00000000000000c0 <test_fallback>:
      c0:   c3                      retq
    
    To add insult to injury, the RCX and R11 clobbers on 64-bit
    builds were missing.
    
    The "memory" clobber is also unnecessary -- no ordering with respect to
    other memory operations is needed, but that's going to be fixed in a
    separate not-for-stable patch.
    
    Fixes: 2aae950b21e4 ("x86_64: Add vDSO for x86-64 with gettimeofday/clock_gettime/getcpu")
    Signed-off-by: Andy Lutomirski <luto@kernel.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org
    Link: https://lkml.kernel.org/r/2c0231690551989d2fafa60ed0e7b5cc8b403908.1538422295.git.luto@kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 9f14d89a13164552038977e7d1bc5b2e3c31f56a
Author: Andy Lutomirski <luto@kernel.org>
Date:   Mon Oct 1 12:52:15 2018 -0700

    x86/vdso: Fix asm constraints on vDSO syscall fallbacks
    
    commit 715bd9d12f84d8f5cc8ad21d888f9bc304a8eb0b upstream.
    
    The syscall fallbacks in the vDSO have incorrect asm constraints.
    They are not marked as writing to their outputs -- instead, they are
    marked as clobbering "memory", which is useless.  In particular, gcc
    is smart enough to know that the timespec parameter hasn't escaped,
    so a memory clobber doesn't clobber it.  And passing a pointer as an
    asm *input* does not tell gcc that the pointed-to value is changed.
    
    Add in the fact that the asm instructions weren't volatile, and gcc
    was free to omit them entirely unless their sole output (the return
    value) is used.  Which it is (phew!), but that stops happening with
    some upcoming patches.
    
    As a trivial example, the following code:
    
    void test_fallback(struct timespec *ts)
    {
            vdso_fallback_gettime(CLOCK_MONOTONIC, ts);
    }
    
    compiles to:
    
    00000000000000c0 <test_fallback>:
      c0:   c3                      retq
    
    To add insult to injury, the RCX and R11 clobbers on 64-bit
    builds were missing.
    
    The "memory" clobber is also unnecessary -- no ordering with respect to
    other memory operations is needed, but that's going to be fixed in a
    separate not-for-stable patch.
    
    Fixes: 2aae950b21e4 ("x86_64: Add vDSO for x86-64 with gettimeofday/clock_gettime/getcpu")
    Signed-off-by: Andy Lutomirski <luto@kernel.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org
    Link: https://lkml.kernel.org/r/2c0231690551989d2fafa60ed0e7b5cc8b403908.1538422295.git.luto@kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 5961c3d0064fdc4326d5390b30ceb50ae5d1459e
Author: Andy Lutomirski <luto@kernel.org>
Date:   Mon Oct 1 12:52:15 2018 -0700

    x86/vdso: Fix asm constraints on vDSO syscall fallbacks
    
    commit 715bd9d12f84d8f5cc8ad21d888f9bc304a8eb0b upstream.
    
    The syscall fallbacks in the vDSO have incorrect asm constraints.
    They are not marked as writing to their outputs -- instead, they are
    marked as clobbering "memory", which is useless.  In particular, gcc
    is smart enough to know that the timespec parameter hasn't escaped,
    so a memory clobber doesn't clobber it.  And passing a pointer as an
    asm *input* does not tell gcc that the pointed-to value is changed.
    
    Add in the fact that the asm instructions weren't volatile, and gcc
    was free to omit them entirely unless their sole output (the return
    value) is used.  Which it is (phew!), but that stops happening with
    some upcoming patches.
    
    As a trivial example, the following code:
    
    void test_fallback(struct timespec *ts)
    {
            vdso_fallback_gettime(CLOCK_MONOTONIC, ts);
    }
    
    compiles to:
    
    00000000000000c0 <test_fallback>:
      c0:   c3                      retq
    
    To add insult to injury, the RCX and R11 clobbers on 64-bit
    builds were missing.
    
    The "memory" clobber is also unnecessary -- no ordering with respect to
    other memory operations is needed, but that's going to be fixed in a
    separate not-for-stable patch.
    
    Fixes: 2aae950b21e4 ("x86_64: Add vDSO for x86-64 with gettimeofday/clock_gettime/getcpu")
    Signed-off-by: Andy Lutomirski <luto@kernel.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org
    Link: https://lkml.kernel.org/r/2c0231690551989d2fafa60ed0e7b5cc8b403908.1538422295.git.luto@kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 430d094da434246199406b48ea1d17e7cdc532f4
Author: Andy Lutomirski <luto@kernel.org>
Date:   Mon Oct 1 12:52:15 2018 -0700

    x86/vdso: Fix asm constraints on vDSO syscall fallbacks
    
    commit 715bd9d12f84d8f5cc8ad21d888f9bc304a8eb0b upstream.
    
    The syscall fallbacks in the vDSO have incorrect asm constraints.
    They are not marked as writing to their outputs -- instead, they are
    marked as clobbering "memory", which is useless.  In particular, gcc
    is smart enough to know that the timespec parameter hasn't escaped,
    so a memory clobber doesn't clobber it.  And passing a pointer as an
    asm *input* does not tell gcc that the pointed-to value is changed.
    
    Add in the fact that the asm instructions weren't volatile, and gcc
    was free to omit them entirely unless their sole output (the return
    value) is used.  Which it is (phew!), but that stops happening with
    some upcoming patches.
    
    As a trivial example, the following code:
    
    void test_fallback(struct timespec *ts)
    {
            vdso_fallback_gettime(CLOCK_MONOTONIC, ts);
    }
    
    compiles to:
    
    00000000000000c0 <test_fallback>:
      c0:   c3                      retq
    
    To add insult to injury, the RCX and R11 clobbers on 64-bit
    builds were missing.
    
    The "memory" clobber is also unnecessary -- no ordering with respect to
    other memory operations is needed, but that's going to be fixed in a
    separate not-for-stable patch.
    
    Fixes: 2aae950b21e4 ("x86_64: Add vDSO for x86-64 with gettimeofday/clock_gettime/getcpu")
    Signed-off-by: Andy Lutomirski <luto@kernel.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org
    Link: https://lkml.kernel.org/r/2c0231690551989d2fafa60ed0e7b5cc8b403908.1538422295.git.luto@kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 715bd9d12f84d8f5cc8ad21d888f9bc304a8eb0b
Author: Andy Lutomirski <luto@kernel.org>
Date:   Mon Oct 1 12:52:15 2018 -0700

    x86/vdso: Fix asm constraints on vDSO syscall fallbacks
    
    The syscall fallbacks in the vDSO have incorrect asm constraints.
    They are not marked as writing to their outputs -- instead, they are
    marked as clobbering "memory", which is useless.  In particular, gcc
    is smart enough to know that the timespec parameter hasn't escaped,
    so a memory clobber doesn't clobber it.  And passing a pointer as an
    asm *input* does not tell gcc that the pointed-to value is changed.
    
    Add in the fact that the asm instructions weren't volatile, and gcc
    was free to omit them entirely unless their sole output (the return
    value) is used.  Which it is (phew!), but that stops happening with
    some upcoming patches.
    
    As a trivial example, the following code:
    
    void test_fallback(struct timespec *ts)
    {
            vdso_fallback_gettime(CLOCK_MONOTONIC, ts);
    }
    
    compiles to:
    
    00000000000000c0 <test_fallback>:
      c0:   c3                      retq
    
    To add insult to injury, the RCX and R11 clobbers on 64-bit
    builds were missing.
    
    The "memory" clobber is also unnecessary -- no ordering with respect to
    other memory operations is needed, but that's going to be fixed in a
    separate not-for-stable patch.
    
    Fixes: 2aae950b21e4 ("x86_64: Add vDSO for x86-64 with gettimeofday/clock_gettime/getcpu")
    Signed-off-by: Andy Lutomirski <luto@kernel.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org
    Link: https://lkml.kernel.org/r/2c0231690551989d2fafa60ed0e7b5cc8b403908.1538422295.git.luto@kernel.org

commit fb420d5d91c1274d5966917725e71f27ed092a85
Author: Eric Dumazet <edumazet@google.com>
Date:   Fri Sep 28 10:28:44 2018 -0700

    tcp/fq: move back to CLOCK_MONOTONIC
    
    In the recent TCP/EDT patch series, I switched TCP and sch_fq
    clocks from MONOTONIC to TAI, in order to meet the choice done
    earlier for sch_etf packet scheduler.
    
    But sure enough, this broke some setups were the TAI clock
    jumps forward (by almost 50 year...), as reported
    by Leonard Crestez.
    
    If we want to converge later, we'll probably need to add
    an skb field to differentiate the clock bases, or a socket option.
    
    In the meantime, an UDP application will need to use CLOCK_MONOTONIC
    base for its SCM_TXTIME timestamps if using fq packet scheduler.
    
    Fixes: 72b0094f9182 ("tcp: switch tcp_clock_ns() to CLOCK_TAI base")
    Fixes: 142537e41923 ("net_sched: sch_fq: switch to CLOCK_TAI")
    Fixes: fd2bca2aa789 ("tcp: switch internal pacing timer to CLOCK_TAI")
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Reported-by: Leonard Crestez <leonard.crestez@nxp.com>
    Tested-by: Leonard Crestez <leonard.crestez@nxp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit bd65d7bf59d966cdc6c56f141bf059678cec89e6
Author: Paul Burton <paulburton@kernel.org>
Date:   Thu Aug 30 11:01:21 2018 -0700

    MIPS: VDSO: Match data page cache colouring when D$ aliases
    
    commit 0f02cfbc3d9e413d450d8d0fd660077c23f67eff upstream.
    
    When a system suffers from dcache aliasing a user program may observe
    stale VDSO data from an aliased cache line. Notably this can break the
    expectation that clock_gettime(CLOCK_MONOTONIC, ...) is, as its name
    suggests, monotonic.
    
    In order to ensure that users observe updates to the VDSO data page as
    intended, align the user mappings of the VDSO data page such that their
    cache colouring matches that of the virtual address range which the
    kernel will use to update the data page - typically its unmapped address
    within kseg0.
    
    This ensures that we don't introduce aliasing cache lines for the VDSO
    data page, and therefore that userland will observe updates without
    requiring cache invalidation.
    
    Signed-off-by: Paul Burton <paul.burton@mips.com>
    Reported-by: Hauke Mehrtens <hauke@hauke-m.de>
    Reported-by: Rene Nielsen <rene.nielsen@microsemi.com>
    Reported-by: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Fixes: ebb5e78cc634 ("MIPS: Initial implementation of a VDSO")
    Patchwork: https://patchwork.linux-mips.org/patch/20344/
    Tested-by: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Tested-by: Hauke Mehrtens <hauke@hauke-m.de>
    Cc: James Hogan <jhogan@kernel.org>
    Cc: linux-mips@linux-mips.org
    Cc: stable@vger.kernel.org # v4.4+
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 262ea6c0c422da1c5c8243cfde148fa9fdad7a26
Author: Paul Burton <paulburton@kernel.org>
Date:   Thu Aug 30 11:01:21 2018 -0700

    MIPS: VDSO: Match data page cache colouring when D$ aliases
    
    commit 0f02cfbc3d9e413d450d8d0fd660077c23f67eff upstream.
    
    When a system suffers from dcache aliasing a user program may observe
    stale VDSO data from an aliased cache line. Notably this can break the
    expectation that clock_gettime(CLOCK_MONOTONIC, ...) is, as its name
    suggests, monotonic.
    
    In order to ensure that users observe updates to the VDSO data page as
    intended, align the user mappings of the VDSO data page such that their
    cache colouring matches that of the virtual address range which the
    kernel will use to update the data page - typically its unmapped address
    within kseg0.
    
    This ensures that we don't introduce aliasing cache lines for the VDSO
    data page, and therefore that userland will observe updates without
    requiring cache invalidation.
    
    Signed-off-by: Paul Burton <paul.burton@mips.com>
    Reported-by: Hauke Mehrtens <hauke@hauke-m.de>
    Reported-by: Rene Nielsen <rene.nielsen@microsemi.com>
    Reported-by: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Fixes: ebb5e78cc634 ("MIPS: Initial implementation of a VDSO")
    Patchwork: https://patchwork.linux-mips.org/patch/20344/
    Tested-by: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Tested-by: Hauke Mehrtens <hauke@hauke-m.de>
    Cc: James Hogan <jhogan@kernel.org>
    Cc: linux-mips@linux-mips.org
    Cc: stable@vger.kernel.org # v4.4+
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 9efcaa7c4afba5628f2650a76f69c798f47eeb18
Author: Paul Burton <paulburton@kernel.org>
Date:   Thu Aug 30 11:01:21 2018 -0700

    MIPS: VDSO: Match data page cache colouring when D$ aliases
    
    commit 0f02cfbc3d9e413d450d8d0fd660077c23f67eff upstream.
    
    When a system suffers from dcache aliasing a user program may observe
    stale VDSO data from an aliased cache line. Notably this can break the
    expectation that clock_gettime(CLOCK_MONOTONIC, ...) is, as its name
    suggests, monotonic.
    
    In order to ensure that users observe updates to the VDSO data page as
    intended, align the user mappings of the VDSO data page such that their
    cache colouring matches that of the virtual address range which the
    kernel will use to update the data page - typically its unmapped address
    within kseg0.
    
    This ensures that we don't introduce aliasing cache lines for the VDSO
    data page, and therefore that userland will observe updates without
    requiring cache invalidation.
    
    Signed-off-by: Paul Burton <paul.burton@mips.com>
    Reported-by: Hauke Mehrtens <hauke@hauke-m.de>
    Reported-by: Rene Nielsen <rene.nielsen@microsemi.com>
    Reported-by: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Fixes: ebb5e78cc634 ("MIPS: Initial implementation of a VDSO")
    Patchwork: https://patchwork.linux-mips.org/patch/20344/
    Tested-by: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Tested-by: Hauke Mehrtens <hauke@hauke-m.de>
    Cc: James Hogan <jhogan@kernel.org>
    Cc: linux-mips@linux-mips.org
    Cc: stable@vger.kernel.org # v4.4+
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 521983976c38b8d3b911628ff7760af3d9af4502
Author: Paul Burton <paulburton@kernel.org>
Date:   Thu Aug 30 11:01:21 2018 -0700

    MIPS: VDSO: Match data page cache colouring when D$ aliases
    
    commit 0f02cfbc3d9e413d450d8d0fd660077c23f67eff upstream.
    
    When a system suffers from dcache aliasing a user program may observe
    stale VDSO data from an aliased cache line. Notably this can break the
    expectation that clock_gettime(CLOCK_MONOTONIC, ...) is, as its name
    suggests, monotonic.
    
    In order to ensure that users observe updates to the VDSO data page as
    intended, align the user mappings of the VDSO data page such that their
    cache colouring matches that of the virtual address range which the
    kernel will use to update the data page - typically its unmapped address
    within kseg0.
    
    This ensures that we don't introduce aliasing cache lines for the VDSO
    data page, and therefore that userland will observe updates without
    requiring cache invalidation.
    
    Signed-off-by: Paul Burton <paul.burton@mips.com>
    Reported-by: Hauke Mehrtens <hauke@hauke-m.de>
    Reported-by: Rene Nielsen <rene.nielsen@microsemi.com>
    Reported-by: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Fixes: ebb5e78cc634 ("MIPS: Initial implementation of a VDSO")
    Patchwork: https://patchwork.linux-mips.org/patch/20344/
    Tested-by: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Tested-by: Hauke Mehrtens <hauke@hauke-m.de>
    Cc: James Hogan <jhogan@kernel.org>
    Cc: linux-mips@linux-mips.org
    Cc: stable@vger.kernel.org # v4.4+
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit dd3535b937c192941daa9b966caa707fa31c2c4d
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Jun 18 16:27:09 2018 +0200

    ipmi: Change to ktime_get_ts64()
    
    getnstimeofday64() is deprecated because of the inconsistent naming,
    it is only a wrapper around ktime_get_real_ts64() now, which could be
    used as a direct replacement.
    
    However, it is generally better to use CLOCK_MONOTONIC timestamps
    where possible, to avoid glitches with a concurrent settimeofday()
    or leap second.
    
    The uses in ipmi are either for debugging prints or for comparing against
    a prior timestamp, so using a monotonic ktime_get_ts64() is probably
    best here.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Corey Minyard <cminyard@mvista.com>

commit 0f02cfbc3d9e413d450d8d0fd660077c23f67eff
Author: Paul Burton <paulburton@kernel.org>
Date:   Thu Aug 30 11:01:21 2018 -0700

    MIPS: VDSO: Match data page cache colouring when D$ aliases
    
    When a system suffers from dcache aliasing a user program may observe
    stale VDSO data from an aliased cache line. Notably this can break the
    expectation that clock_gettime(CLOCK_MONOTONIC, ...) is, as its name
    suggests, monotonic.
    
    In order to ensure that users observe updates to the VDSO data page as
    intended, align the user mappings of the VDSO data page such that their
    cache colouring matches that of the virtual address range which the
    kernel will use to update the data page - typically its unmapped address
    within kseg0.
    
    This ensures that we don't introduce aliasing cache lines for the VDSO
    data page, and therefore that userland will observe updates without
    requiring cache invalidation.
    
    Signed-off-by: Paul Burton <paul.burton@mips.com>
    Reported-by: Hauke Mehrtens <hauke@hauke-m.de>
    Reported-by: Rene Nielsen <rene.nielsen@microsemi.com>
    Reported-by: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Fixes: ebb5e78cc634 ("MIPS: Initial implementation of a VDSO")
    Patchwork: https://patchwork.linux-mips.org/patch/20344/
    Tested-by: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Tested-by: Hauke Mehrtens <hauke@hauke-m.de>
    Cc: James Hogan <jhogan@kernel.org>
    Cc: linux-mips@linux-mips.org
    Cc: stable@vger.kernel.org # v4.4+

commit 34d082604a7c8856051ff441fef0e22d93afd848
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Aug 21 21:59:26 2018 -0700

    reiserfs: use monotonic time for j_trans_start_time
    
    Using CLOCK_REALTIME time_t timestamps breaks on 32-bit systems in 2038,
    and gives surprising results with a concurrent settimeofday().
    
    This changes the reiserfs journal timestamps to use ktime_get_seconds()
    instead, which makes it use a 64-bit CLOCK_MONOTONIC stamp.
    
    In the procfs output, the monotonic timestamp needs to be converted back
    to CLOCK_REALTIME to keep the existing ABI.
    
    Link: http://lkml.kernel.org/r/20180620142522.27639-2-arnd@arndb.de
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Reviewed-by: Jan Kara <jack@suse.cz>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit afd48513f0019a2048afed0d98904d3fec7e05dd
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Thu Jun 21 18:04:05 2018 +0200

    btrfs: use monotonic time for transaction handling
    
    The transaction times were changed to ktime_get_real_seconds to avoid
    the y2038 overflow, but they still have a minor problem when they go
    backwards or jump due to settimeofday() or leap seconds.
    
    This changes the transaction handling to instead use ktime_get_seconds(),
    which returns a CLOCK_MONOTONIC timestamp that has neither of those
    problems.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Reviewed-by: Nikolay Borisov <nborisov@suse.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

commit c4d6204dc1742581c0450d2ff6a058f61ea4f4ce
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Jun 18 17:28:23 2018 +0200

    scsi: lpfc: use monotonic timestamps for statistics
    
    The get_seconds() function suffers from a possible overflow in 2038 or
    2106, as well as jitter due to settimeofday or leap second updates, and is
    deprecated.
    
    As we are interested in elapsed time only, using ktime_get_seconds() to
    read the CLOCK_MONOTONIC timebase is ideal here. This also lets us remove
    the hack that tries to deal with get_seconds() going slightly backwards,
    which cannot happen with montonic timestamps.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

commit fe7f4e5d11541402f54ebd777a4f49caee891401
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Jun 18 17:29:51 2018 +0200

    scsi: scsi_transport_fc: use 64-bit timestamps consistently
    
    The get_seconds() helper returns an 'unsigned long' value, which can
    overflow on 32-bit architectures. Since the interface we pass it into
    already uses a 64-bit type, we can just use ktime_get_real_seconds()
    instead.
    
    While we generally prefer local timestamps in CLOCK_MONOTONIC format
    (ktime_get_seconds), this keeps using the CLOCK_REALTIME version in order
    to maintain compatibility with existing code.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Reviewed-by: Tyrel Datwyler <tyreld@linux.vnet.ibm.com>
    Reviewed-by: James Smart <james.smart@broadcom.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

commit 6075e4ae6e729778ac687a9ffb0c0d5223a0a19e
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Jun 18 12:05:00 2018 +0200

    s390: hypfs: use ktime_get_seconds() instead of get_seconds()
    
    time_t and get_seconds() are deprecated because they will overflow on
    32-bit architectures in the future. This is not a problem on 64-bit s390,
    but we should use proper interfaces anyway.
    
    Besides moving to the time64_t based interface, the CLOCK_MONOTONIC
    based ktime_get_seconds() is preferred for kernel internal timekeeping
    because it does not behave in unexpected ways during leap second changes
    or settimeofday() calls.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

commit ac1cd8d483c9574f3b5edfe952897df3f1af24b8
Author: Anna-Maria Gleixner <anna-maria@linutronix.de>
Date:   Thu Dec 21 11:41:35 2017 +0100

    hrtimer: Ensure POSIX compliance (relative CLOCK_REALTIME hrtimers)
    
    commit 48d0c9becc7f3c66874c100c126459a9da0fdced upstream.
    
    The POSIX specification defines that relative CLOCK_REALTIME timers are not
    affected by clock modifications. Those timers have to use CLOCK_MONOTONIC
    to ensure POSIX compliance.
    
    The introduction of the additional HRTIMER_MODE_PINNED mode broke this
    requirement for pinned timers.
    
    There is no user space visible impact because user space timers are not
    using pinned mode, but for consistency reasons this needs to be fixed.
    
    Check whether the mode has the HRTIMER_MODE_REL bit set instead of
    comparing with HRTIMER_MODE_ABS.
    
    Signed-off-by: Anna-Maria Gleixner <anna-maria@linutronix.de>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: keescook@chromium.org
    Fixes: 597d0275736d ("timers: Framework for identifying pinned timers")
    Link: http://lkml.kernel.org/r/20171221104205.7269-7-anna-maria@linutronix.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    [bwh: Backported to 3.16: adjust filename]
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit dcc9bd87a2825e27df2dde6425b32d9da48421b2
Author: Anna-Maria Gleixner <anna-maria@linutronix.de>
Date:   Thu Dec 21 11:41:35 2017 +0100

    hrtimer: Ensure POSIX compliance (relative CLOCK_REALTIME hrtimers)
    
    commit 48d0c9becc7f3c66874c100c126459a9da0fdced upstream.
    
    The POSIX specification defines that relative CLOCK_REALTIME timers are not
    affected by clock modifications. Those timers have to use CLOCK_MONOTONIC
    to ensure POSIX compliance.
    
    The introduction of the additional HRTIMER_MODE_PINNED mode broke this
    requirement for pinned timers.
    
    There is no user space visible impact because user space timers are not
    using pinned mode, but for consistency reasons this needs to be fixed.
    
    Check whether the mode has the HRTIMER_MODE_REL bit set instead of
    comparing with HRTIMER_MODE_ABS.
    
    Signed-off-by: Anna-Maria Gleixner <anna-maria@linutronix.de>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: keescook@chromium.org
    Fixes: 597d0275736d ("timers: Framework for identifying pinned timers")
    Link: http://lkml.kernel.org/r/20171221104205.7269-7-anna-maria@linutronix.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    [bwh: Backported to 3.2: adjust filename]
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit 3f925cc2d3995f56be58b10870f4f424300b8ad8
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Jan 17 18:01:21 2018 +0100

    drm/exynos: g2d: use monotonic timestamps
    
    [ Upstream commit a588a8bb7b25a3fb4f7fed00feb7aec541fc2632 ]
    
    The exynos DRM driver uses real-time 'struct timeval' values
    for exporting its timestamps to user space. This has multiple
    problems:
    
    1. signed seconds overflow in y2038
    2. the 'struct timeval' definition is deprecated in the kernel
    3. time may jump or go backwards after a 'settimeofday()' syscall
    4. other DRM timestamps are in CLOCK_MONOTONIC domain, so they
       can't be compared
    5. exporting microseconds requires a division by 1000, which may
       be slow on some architectures.
    
    The code existed in two places before, but the IPP portion was
    removed in 8ded59413ccc ("drm/exynos: ipp: Remove Exynos DRM
    IPP subsystem"), so we no longer need to worry about it.
    
    Ideally timestamps should just use 64-bit nanoseconds instead, but
    of course we can't change that now. Instead, this tries to address
    the first four points above by using monotonic 'timespec' values.
    
    According to Tobias Jakobi, user space doesn't care about the
    timestamp at the moment, so we can change the format. Even if
    there is something looking at them, it will work just fine with
    monotonic times as long as the application only looks at the
    relative values between two events.
    
    Link: https://patchwork.kernel.org/patch/10038593/
    Cc: Tobias Jakobi <tjakobi@math.uni-bielefeld.de>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Reviewed-by: Tobias Jakobi <tjakobi@math.uni-bielefeld.de>
    Signed-off-by: Inki Dae <inki.dae@samsung.com>
    Signed-off-by: Sasha Levin <alexander.levin@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit e4529bc4ff8407de2ad373d9a1c19328a5a645d2
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Jan 17 18:01:21 2018 +0100

    drm/exynos: g2d: use monotonic timestamps
    
    [ Upstream commit a588a8bb7b25a3fb4f7fed00feb7aec541fc2632 ]
    
    The exynos DRM driver uses real-time 'struct timeval' values
    for exporting its timestamps to user space. This has multiple
    problems:
    
    1. signed seconds overflow in y2038
    2. the 'struct timeval' definition is deprecated in the kernel
    3. time may jump or go backwards after a 'settimeofday()' syscall
    4. other DRM timestamps are in CLOCK_MONOTONIC domain, so they
       can't be compared
    5. exporting microseconds requires a division by 1000, which may
       be slow on some architectures.
    
    The code existed in two places before, but the IPP portion was
    removed in 8ded59413ccc ("drm/exynos: ipp: Remove Exynos DRM
    IPP subsystem"), so we no longer need to worry about it.
    
    Ideally timestamps should just use 64-bit nanoseconds instead, but
    of course we can't change that now. Instead, this tries to address
    the first four points above by using monotonic 'timespec' values.
    
    According to Tobias Jakobi, user space doesn't care about the
    timestamp at the moment, so we can change the format. Even if
    there is something looking at them, it will work just fine with
    monotonic times as long as the application only looks at the
    relative values between two events.
    
    Link: https://patchwork.kernel.org/patch/10038593/
    Cc: Tobias Jakobi <tjakobi@math.uni-bielefeld.de>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Reviewed-by: Tobias Jakobi <tjakobi@math.uni-bielefeld.de>
    Signed-off-by: Inki Dae <inki.dae@samsung.com>
    Signed-off-by: Sasha Levin <alexander.levin@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit e3ae971af7896594df867abb2c07e8a7732a4915
Author: Anna-Maria Gleixner <anna-maria@linutronix.de>
Date:   Thu Dec 21 11:41:37 2017 +0100

    tracing/hrtimer: Fix tracing bugs by taking all clock bases and modes into account
    
    [ Upstream commit 91633eed73a3ac37aaece5c8c1f93a18bae616a9 ]
    
    So far only CLOCK_MONOTONIC and CLOCK_REALTIME were taken into account as
    well as HRTIMER_MODE_ABS/REL in the hrtimer_init tracepoint. The query for
    detecting the ABS or REL timer modes is not valid anymore, it got broken
    by the introduction of HRTIMER_MODE_PINNED.
    
    HRTIMER_MODE_PINNED is not evaluated in the hrtimer_init() call, but for the
    sake of completeness print all given modes.
    
    Signed-off-by: Anna-Maria Gleixner <anna-maria@linutronix.de>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: keescook@chromium.org
    Link: http://lkml.kernel.org/r/20171221104205.7269-9-anna-maria@linutronix.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Sasha Levin <alexander.levin@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 1c0467b9771fba4db5ea348b1788e7a553c93931
Author: Anna-Maria Gleixner <anna-maria@linutronix.de>
Date:   Thu Dec 21 11:41:37 2017 +0100

    tracing/hrtimer: Fix tracing bugs by taking all clock bases and modes into account
    
    [ Upstream commit 91633eed73a3ac37aaece5c8c1f93a18bae616a9 ]
    
    So far only CLOCK_MONOTONIC and CLOCK_REALTIME were taken into account as
    well as HRTIMER_MODE_ABS/REL in the hrtimer_init tracepoint. The query for
    detecting the ABS or REL timer modes is not valid anymore, it got broken
    by the introduction of HRTIMER_MODE_PINNED.
    
    HRTIMER_MODE_PINNED is not evaluated in the hrtimer_init() call, but for the
    sake of completeness print all given modes.
    
    Signed-off-by: Anna-Maria Gleixner <anna-maria@linutronix.de>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: keescook@chromium.org
    Link: http://lkml.kernel.org/r/20171221104205.7269-9-anna-maria@linutronix.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Sasha Levin <alexander.levin@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit ec8e8efa397d3373a75b7384937e06c2c379190c
Author: Anna-Maria Gleixner <anna-maria@linutronix.de>
Date:   Thu Dec 21 11:41:37 2017 +0100

    tracing/hrtimer: Fix tracing bugs by taking all clock bases and modes into account
    
    [ Upstream commit 91633eed73a3ac37aaece5c8c1f93a18bae616a9 ]
    
    So far only CLOCK_MONOTONIC and CLOCK_REALTIME were taken into account as
    well as HRTIMER_MODE_ABS/REL in the hrtimer_init tracepoint. The query for
    detecting the ABS or REL timer modes is not valid anymore, it got broken
    by the introduction of HRTIMER_MODE_PINNED.
    
    HRTIMER_MODE_PINNED is not evaluated in the hrtimer_init() call, but for the
    sake of completeness print all given modes.
    
    Signed-off-by: Anna-Maria Gleixner <anna-maria@linutronix.de>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: keescook@chromium.org
    Link: http://lkml.kernel.org/r/20171221104205.7269-9-anna-maria@linutronix.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Sasha Levin <alexander.levin@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 09f7ebaa436c9bdad4a21c24fed5057604e709c1
Author: John Stultz <john.stultz@linaro.org>
Date:   Thu Jun 8 16:44:21 2017 -0700

    time: Fix CLOCK_MONOTONIC_RAW sub-nanosecond accounting
    
    commit 3d88d56c5873f6eebe23e05c3da701960146b801 upstream.
    
    Due to how the MONOTONIC_RAW accumulation logic was handled,
    there is the potential for a 1ns discontinuity when we do
    accumulations. This small discontinuity has for the most part
    gone un-noticed, but since ARM64 enabled CLOCK_MONOTONIC_RAW
    in their vDSO clock_gettime implementation, we've seen failures
    with the inconsistency-check test in kselftest.
    
    This patch addresses the issue by using the same sub-ns
    accumulation handling that CLOCK_MONOTONIC uses, which avoids
    the issue for in-kernel users.
    
    Since the ARM64 vDSO implementation has its own clock_gettime
    calculation logic, this patch reduces the frequency of errors,
    but failures are still seen. The ARM64 vDSO will need to be
    updated to include the sub-nanosecond xtime_nsec values in its
    calculation for this issue to be completely fixed.
    
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Tested-by: Daniel Mentz <danielmentz@google.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Kevin Brodsky <kevin.brodsky@arm.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Stephen Boyd <stephen.boyd@linaro.org>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: "stable #4 . 8+" <stable@vger.kernel.org>
    Cc: Miroslav Lichvar <mlichvar@redhat.com>
    Link: http://lkml.kernel.org/r/1496965462-20003-3-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    [fabrizio: cherry-pick to 4.4. Kept cycle_t type for function
    logarithmic_accumulation local variable "interval". Dropped
    casting of "interval" variable]
    Signed-off-by: Fabrizio Castro <fabrizio.castro@bp.renesas.com>
    Signed-off-by: Biju Das <biju.das@bp.renesas.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit d066b246d482f69553e58d52f746377ce3966b66
Author: Russell King <rmk+kernel@armlinux.org.uk>
Date:   Tue Feb 20 10:22:22 2018 +0100

    drm/etnaviv: correct timeout calculation
    
    The old way did clamp the jiffy conversion and thus caused the timeouts
    to become negative after some time. Also it didn't work with userspace
    which actually fills the upper 32bits of the 64bit timestamp value.
    
    clock_gettime() is 32-bit on 32-bit architectures. Using 64-bit timespec
    math, like we do in this commit, means that when a wrap occurs, the
    specified timeout goes into the past and we can't request a timeout in
    the future. As the Linux implementation of CLOCK_MONOTONIC is reasonable
    and starts at 0, the first such timer wrap will occur after approx. 68
    years of system uptime.
    
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
    Signed-off-by: Lucas Stach <l.stach@pengutronix.de>

commit 810fb07a9b504ac22b95899cf8b39d25a5f3e5c5
Merge: 7d9e55feae55 a3ed0e4393d6
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Apr 29 09:03:25 2018 -0700

    Merge branch 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer fixes from Thomas Gleixner:
     "Two fixes from the timer departement:
    
       - Fix a long standing issue in the NOHZ tick code which causes RB
         tree corruption, delayed timers and other malfunctions. The cause
         for this is code which modifies the expiry time of an enqueued
         hrtimer.
    
       - Revert the CLOCK_MONOTONIC/CLOCK_BOOTTIME unification due to
         regression reports. Seems userspace _is_ relying on the documented
         behaviour despite our hope that it wont"
    
    * 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      Revert: Unify CLOCK_MONOTONIC and CLOCK_BOOTTIME
      tick/sched: Do not mess with an enqueued hrtimer

commit a3ed0e4393d6885b4af7ce84b437dc696490a530
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Apr 25 15:33:38 2018 +0200

    Revert: Unify CLOCK_MONOTONIC and CLOCK_BOOTTIME
    
    Revert commits
    
    92af4dcb4e1c ("tracing: Unify the "boot" and "mono" tracing clocks")
    127bfa5f4342 ("hrtimer: Unify MONOTONIC and BOOTTIME clock behavior")
    7250a4047aa6 ("posix-timers: Unify MONOTONIC and BOOTTIME clock behavior")
    d6c7270e913d ("timekeeping: Remove boot time specific code")
    f2d6fdbfd238 ("Input: Evdev - unify MONOTONIC and BOOTTIME clock behavior")
    d6ed449afdb3 ("timekeeping: Make the MONOTONIC clock behave like the BOOTTIME clock")
    72199320d49d ("timekeeping: Add the new CLOCK_MONOTONIC_ACTIVE clock")
    
    As stated in the pull request for the unification of CLOCK_MONOTONIC and
    CLOCK_BOOTTIME, it was clear that we might have to revert the change.
    
    As reported by several folks systemd and other applications rely on the
    documented behaviour of CLOCK_MONOTONIC on Linux and break with the above
    changes. After resume daemons time out and other timeout related issues are
    observed. Rafael compiled this list:
    
    * systemd kills daemons on resume, after >WatchdogSec seconds
      of suspending (Genki Sky).  [Verified that that's because systemd uses
      CLOCK_MONOTONIC and expects it to not include the suspend time.]
    
    * systemd-journald misbehaves after resume:
      systemd-journald[7266]: File /var/log/journal/016627c3c4784cd4812d4b7e96a34226/system.journal
    corrupted or uncleanly shut down, renaming and replacing.
      (Mike Galbraith).
    
    * NetworkManager reports "networking disabled" and networking is broken
      after resume 50% of the time (Pavel).  [May be because of systemd.]
    
    * MATE desktop dims the display and starts the screensaver right after
      system resume (Pavel).
    
    * Full system hang during resume (me).  [May be due to systemd or NM or both.]
    
    That happens on debian and open suse systems.
    
    It's sad, that these problems were neither catched in -next nor by those
    folks who expressed interest in this change.
    
    Reported-by: Rafael J. Wysocki <rjw@rjwysocki.net>
    Reported-by: Genki Sky <sky@genki.is>,
    Reported-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Jonathan Corbet <corbet@lwn.net>
    Cc: Kevin Easton <kevin@guarana.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mark Salyzyn <salyzyn@android.com>
    Cc: Michael Kerrisk <mtk.manpages@gmail.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Petr Mladek <pmladek@suse.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Cc: Steven Rostedt <rostedt@goodmis.org>

commit a5a8ca753c0c4659287416ce282ba357c30098a8
Author: Anna-Maria Gleixner <anna-maria@linutronix.de>
Date:   Thu Dec 21 11:41:37 2017 +0100

    tracing/hrtimer: Fix tracing bugs by taking all clock bases and modes into account
    
    
    [ Upstream commit 91633eed73a3ac37aaece5c8c1f93a18bae616a9 ]
    
    So far only CLOCK_MONOTONIC and CLOCK_REALTIME were taken into account as
    well as HRTIMER_MODE_ABS/REL in the hrtimer_init tracepoint. The query for
    detecting the ABS or REL timer modes is not valid anymore, it got broken
    by the introduction of HRTIMER_MODE_PINNED.
    
    HRTIMER_MODE_PINNED is not evaluated in the hrtimer_init() call, but for the
    sake of completeness print all given modes.
    
    Signed-off-by: Anna-Maria Gleixner <anna-maria@linutronix.de>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: keescook@chromium.org
    Link: http://lkml.kernel.org/r/20171221104205.7269-9-anna-maria@linutronix.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Sasha Levin <alexander.levin@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 680014d6d1da84e9c7860831221ec74230721907
Merge: 0c21fd6e6593 bd03143007eb
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Apr 4 14:50:29 2018 -0700

    Merge branch 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull time(r) updates from Thomas Gleixner:
     "A small set of updates for timers and timekeeping:
    
       - The most interesting change is the consolidation of clock MONOTONIC
         and clock BOOTTIME.
    
         Clock MONOTONIC behaves now exactly like clock BOOTTIME and does
         not longer ignore the time spent in suspend. A new clock
         MONOTONIC_ACTIVE is provived which behaves like clock MONOTONIC in
         kernels before this change. This allows applications to
         programmatically check for the clock MONOTONIC behaviour.
    
         As discussed in the review thread, this has the potential of
         breaking user space and we might have to revert this. Knock on wood
         that we can avoid that exercise.
    
       - Updates to the NTP mechanism to improve accuracy
    
       - A new kernel internal data structure to aid the ongoing Y2038 work.
    
       - Cleanups and simplifications of the clocksource code.
    
       - Make the alarmtimer code play nicely with debugobjects"
    
    * 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      alarmtimer: Init nanosleep alarm timer on stack
      y2038: Introduce struct __kernel_old_timeval
      tracing: Unify the "boot" and "mono" tracing clocks
      hrtimer: Unify MONOTONIC and BOOTTIME clock behavior
      posix-timers: Unify MONOTONIC and BOOTTIME clock behavior
      timekeeping: Remove boot time specific code
      Input: Evdev - unify MONOTONIC and BOOTTIME clock behavior
      timekeeping: Make the MONOTONIC clock behave like the BOOTTIME clock
      timekeeping: Add the new CLOCK_MONOTONIC_ACTIVE clock
      timekeeping/ntp: Determine the multiplier directly from NTP tick length
      timekeeping/ntp: Don't align NTP frequency adjustments to ticks
      clocksource: Use ATTRIBUTE_GROUPS
      clocksource: Use DEVICE_ATTR_RW/RO/WO to define device attributes
      clocksource: Don't walk the clocksource list for empty override

commit 291a16f3a8db60c0ba4a3a04ca193e90389e2396
Author: Anna-Maria Gleixner <anna-maria@linutronix.de>
Date:   Thu Dec 21 11:41:35 2017 +0100

    hrtimer: Ensure POSIX compliance (relative CLOCK_REALTIME hrtimers)
    
    [ Upstream commit 48d0c9becc7f3c66874c100c126459a9da0fdced ]
    
    The POSIX specification defines that relative CLOCK_REALTIME timers are not
    affected by clock modifications. Those timers have to use CLOCK_MONOTONIC
    to ensure POSIX compliance.
    
    The introduction of the additional HRTIMER_MODE_PINNED mode broke this
    requirement for pinned timers.
    
    There is no user space visible impact because user space timers are not
    using pinned mode, but for consistency reasons this needs to be fixed.
    
    Check whether the mode has the HRTIMER_MODE_REL bit set instead of
    comparing with HRTIMER_MODE_ABS.
    
    Signed-off-by: Anna-Maria Gleixner <anna-maria@linutronix.de>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: keescook@chromium.org
    Fixes: 597d0275736d ("timers: Framework for identifying pinned timers")
    Link: http://lkml.kernel.org/r/20171221104205.7269-7-anna-maria@linutronix.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Sasha Levin <alexander.levin@microsoft.com>

commit 72199320d49dbafa1a99f94f1cd60dc90035c154
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Mar 1 17:33:32 2018 +0100

    timekeeping: Add the new CLOCK_MONOTONIC_ACTIVE clock
    
    The planned change to unify the behaviour of the MONOTONIC and BOOTTIME
    clocks vs. suspend removes the ability to retrieve the active
    non-suspended time of a system.
    
    Provide a new CLOCK_MONOTONIC_ACTIVE clock which returns the active
    non-suspended time of the system via clock_gettime().
    
    This preserves the old behaviour of CLOCK_MONOTONIC before the
    BOOTTIME/MONOTONIC unification.
    
    This new clock also allows applications to detect programmatically that
    the MONOTONIC and BOOTTIME clocks are identical.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Jonathan Corbet <corbet@lwn.net>
    Cc: Kevin Easton <kevin@guarana.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mark Salyzyn <salyzyn@android.com>
    Cc: Michael Kerrisk <mtk.manpages@gmail.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Petr Mladek <pmladek@suse.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Link: http://lkml.kernel.org/r/20180301165149.965235774@linutronix.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit d3b7976e60c600843e78cdb87abced3aa71cf495
Author: Anna-Maria Gleixner <anna-maria@linutronix.de>
Date:   Thu Dec 21 11:41:35 2017 +0100

    hrtimer: Ensure POSIX compliance (relative CLOCK_REALTIME hrtimers)
    
    commit 48d0c9becc7f3c66874c100c126459a9da0fdced upstream.
    
    The POSIX specification defines that relative CLOCK_REALTIME timers are not
    affected by clock modifications. Those timers have to use CLOCK_MONOTONIC
    to ensure POSIX compliance.
    
    The introduction of the additional HRTIMER_MODE_PINNED mode broke this
    requirement for pinned timers.
    
    There is no user space visible impact because user space timers are not
    using pinned mode, but for consistency reasons this needs to be fixed.
    
    Check whether the mode has the HRTIMER_MODE_REL bit set instead of
    comparing with HRTIMER_MODE_ABS.
    
    Signed-off-by: Anna-Maria Gleixner <anna-maria@linutronix.de>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: keescook@chromium.org
    Fixes: 597d0275736d ("timers: Framework for identifying pinned timers")
    Link: http://lkml.kernel.org/r/20171221104205.7269-7-anna-maria@linutronix.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit f92679fee6ad1a13c8e82cf1f5769cef27343f78
Author: Anna-Maria Gleixner <anna-maria@linutronix.de>
Date:   Thu Dec 21 11:41:35 2017 +0100

    hrtimer: Ensure POSIX compliance (relative CLOCK_REALTIME hrtimers)
    
    commit 48d0c9becc7f3c66874c100c126459a9da0fdced upstream.
    
    The POSIX specification defines that relative CLOCK_REALTIME timers are not
    affected by clock modifications. Those timers have to use CLOCK_MONOTONIC
    to ensure POSIX compliance.
    
    The introduction of the additional HRTIMER_MODE_PINNED mode broke this
    requirement for pinned timers.
    
    There is no user space visible impact because user space timers are not
    using pinned mode, but for consistency reasons this needs to be fixed.
    
    Check whether the mode has the HRTIMER_MODE_REL bit set instead of
    comparing with HRTIMER_MODE_ABS.
    
    Signed-off-by: Anna-Maria Gleixner <anna-maria@linutronix.de>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: keescook@chromium.org
    Fixes: 597d0275736d ("timers: Framework for identifying pinned timers")
    Link: http://lkml.kernel.org/r/20171221104205.7269-7-anna-maria@linutronix.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 5a9f69b2c11bee48b1884165e4e1473f7672dc28
Author: Anna-Maria Gleixner <anna-maria@linutronix.de>
Date:   Thu Dec 21 11:41:35 2017 +0100

    hrtimer: Ensure POSIX compliance (relative CLOCK_REALTIME hrtimers)
    
    commit 48d0c9becc7f3c66874c100c126459a9da0fdced upstream.
    
    The POSIX specification defines that relative CLOCK_REALTIME timers are not
    affected by clock modifications. Those timers have to use CLOCK_MONOTONIC
    to ensure POSIX compliance.
    
    The introduction of the additional HRTIMER_MODE_PINNED mode broke this
    requirement for pinned timers.
    
    There is no user space visible impact because user space timers are not
    using pinned mode, but for consistency reasons this needs to be fixed.
    
    Check whether the mode has the HRTIMER_MODE_REL bit set instead of
    comparing with HRTIMER_MODE_ABS.
    
    Signed-off-by: Anna-Maria Gleixner <anna-maria@linutronix.de>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: keescook@chromium.org
    Fixes: 597d0275736d ("timers: Framework for identifying pinned timers")
    Link: http://lkml.kernel.org/r/20171221104205.7269-7-anna-maria@linutronix.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit b77d5ffcb7528dd9ae9510d899b08a5f325bfeeb
Author: Anna-Maria Gleixner <anna-maria@linutronix.de>
Date:   Thu Dec 21 11:41:35 2017 +0100

    hrtimer: Ensure POSIX compliance (relative CLOCK_REALTIME hrtimers)
    
    commit 48d0c9becc7f3c66874c100c126459a9da0fdced upstream.
    
    The POSIX specification defines that relative CLOCK_REALTIME timers are not
    affected by clock modifications. Those timers have to use CLOCK_MONOTONIC
    to ensure POSIX compliance.
    
    The introduction of the additional HRTIMER_MODE_PINNED mode broke this
    requirement for pinned timers.
    
    There is no user space visible impact because user space timers are not
    using pinned mode, but for consistency reasons this needs to be fixed.
    
    Check whether the mode has the HRTIMER_MODE_REL bit set instead of
    comparing with HRTIMER_MODE_ABS.
    
    Signed-off-by: Anna-Maria Gleixner <anna-maria@linutronix.de>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: keescook@chromium.org
    Fixes: 597d0275736d ("timers: Framework for identifying pinned timers")
    Link: http://lkml.kernel.org/r/20171221104205.7269-7-anna-maria@linutronix.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 5ae0e9de0ac6728f8a29612ff216240945a25dc8
Author: Anna-Maria Gleixner <anna-maria@linutronix.de>
Date:   Thu Dec 21 11:41:35 2017 +0100

    hrtimer: Ensure POSIX compliance (relative CLOCK_REALTIME hrtimers)
    
    commit 48d0c9becc7f3c66874c100c126459a9da0fdced upstream.
    
    The POSIX specification defines that relative CLOCK_REALTIME timers are not
    affected by clock modifications. Those timers have to use CLOCK_MONOTONIC
    to ensure POSIX compliance.
    
    The introduction of the additional HRTIMER_MODE_PINNED mode broke this
    requirement for pinned timers.
    
    There is no user space visible impact because user space timers are not
    using pinned mode, but for consistency reasons this needs to be fixed.
    
    Check whether the mode has the HRTIMER_MODE_REL bit set instead of
    comparing with HRTIMER_MODE_ABS.
    
    Signed-off-by: Anna-Maria Gleixner <anna-maria@linutronix.de>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: keescook@chromium.org
    Fixes: 597d0275736d ("timers: Framework for identifying pinned timers")
    Link: http://lkml.kernel.org/r/20171221104205.7269-7-anna-maria@linutronix.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit a588a8bb7b25a3fb4f7fed00feb7aec541fc2632
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Jan 17 18:01:21 2018 +0100

    drm/exynos: g2d: use monotonic timestamps
    
    The exynos DRM driver uses real-time 'struct timeval' values
    for exporting its timestamps to user space. This has multiple
    problems:
    
    1. signed seconds overflow in y2038
    2. the 'struct timeval' definition is deprecated in the kernel
    3. time may jump or go backwards after a 'settimeofday()' syscall
    4. other DRM timestamps are in CLOCK_MONOTONIC domain, so they
       can't be compared
    5. exporting microseconds requires a division by 1000, which may
       be slow on some architectures.
    
    The code existed in two places before, but the IPP portion was
    removed in 8ded59413ccc ("drm/exynos: ipp: Remove Exynos DRM
    IPP subsystem"), so we no longer need to worry about it.
    
    Ideally timestamps should just use 64-bit nanoseconds instead, but
    of course we can't change that now. Instead, this tries to address
    the first four points above by using monotonic 'timespec' values.
    
    According to Tobias Jakobi, user space doesn't care about the
    timestamp at the moment, so we can change the format. Even if
    there is something looking at them, it will work just fine with
    monotonic times as long as the application only looks at the
    relative values between two events.
    
    Link: https://patchwork.kernel.org/patch/10038593/
    Cc: Tobias Jakobi <tjakobi@math.uni-bielefeld.de>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Reviewed-by: Tobias Jakobi <tjakobi@math.uni-bielefeld.de>
    Signed-off-by: Inki Dae <inki.dae@samsung.com>

commit 28f3a488ed83ac4a01406490941a6486806d1333
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Feb 6 15:40:21 2018 -0800

    pps: parport: use timespec64 instead of timespec
    
    getnstimeofday() is deprecated, so I'm converting this to use
    ktime_get_real_ts64() as a safe replacement.  I considered using
    ktime_get_real() instead, but since the algorithm here depends on the
    exact timing, I decided to introduce fewer changes and leave the code
    that determines the nanoseconds since the last seconds wrap untouched.
    
    It's not entirely clear to me whether we should also change the time
    base to CLOCK_BOOTTIME or CLOCK_TAI.  With boottime, we would be
    independent of changes due to settimeofday() and only see the speed
    adjustment from the upstream clock source, with the downside of having
    the signal be at an arbirary offset from the start of the UTC second
    signal.  With CLOCK_TAI, we would use the same offset from the UTC
    second as before and still suffer from settimeofday() adjustments, but
    would be less confused during leap seconds.
    
    Both boottime and tai only offer usable (i.e.  avoiding ktime_t to
    timespec64 conversion) interfaces for ktime_t though, so either way,
    changing it wouldn't take significantly more work.  CLOCK_MONOTONIC
    could be used with ktime_get_ts64(), but would lose synchronization
    across a suspend/resume cycle, which seems worse.
    
    Link: http://lkml.kernel.org/r/20180116171451.3095620-1-arnd@arndb.de
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Rodolfo Giometti <giometti@enneenne.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit 3ec7a3ee9f15f6dcac1591902d85b94c2a4b520d
Author: Anna-Maria Gleixner <anna-maria@linutronix.de>
Date:   Thu Dec 21 11:41:51 2017 +0100

    hrtimer: Remove the 'base' parameter from hrtimer_reprogram()
    
    hrtimer_reprogram() must have access to the hrtimer_clock_base of the new
    first expiring timer to access hrtimer_clock_base.offset for adjusting the
    expiry time to CLOCK_MONOTONIC. This is required to evaluate whether the
    new left most timer in the hrtimer_clock_base is the first expiring timer
    of all clock bases in a hrtimer_cpu_base.
    
    The only user of hrtimer_reprogram() is hrtimer_start_range_ns(), which has
    a pointer to hrtimer_clock_base() already and hands it in as a parameter. But
    hrtimer_start_range_ns() will be split for the upcoming support for softirq
    based hrtimers to avoid code duplication and will lose the direct access to
    the clock base pointer.
    
    Instead of handing in timer and timer->base as a parameter remove the base
    parameter from hrtimer_reprogram() instead and retrieve the clock base internally.
    
    Signed-off-by: Anna-Maria Gleixner <anna-maria@linutronix.de>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: keescook@chromium.org
    Link: http://lkml.kernel.org/r/20171221104205.7269-23-anna-maria@linutronix.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 91633eed73a3ac37aaece5c8c1f93a18bae616a9
Author: Anna-Maria Gleixner <anna-maria@linutronix.de>
Date:   Thu Dec 21 11:41:37 2017 +0100

    tracing/hrtimer: Fix tracing bugs by taking all clock bases and modes into account
    
    So far only CLOCK_MONOTONIC and CLOCK_REALTIME were taken into account as
    well as HRTIMER_MODE_ABS/REL in the hrtimer_init tracepoint. The query for
    detecting the ABS or REL timer modes is not valid anymore, it got broken
    by the introduction of HRTIMER_MODE_PINNED.
    
    HRTIMER_MODE_PINNED is not evaluated in the hrtimer_init() call, but for the
    sake of completeness print all given modes.
    
    Signed-off-by: Anna-Maria Gleixner <anna-maria@linutronix.de>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: keescook@chromium.org
    Link: http://lkml.kernel.org/r/20171221104205.7269-9-anna-maria@linutronix.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 48d0c9becc7f3c66874c100c126459a9da0fdced
Author: Anna-Maria Gleixner <anna-maria@linutronix.de>
Date:   Thu Dec 21 11:41:35 2017 +0100

    hrtimer: Ensure POSIX compliance (relative CLOCK_REALTIME hrtimers)
    
    The POSIX specification defines that relative CLOCK_REALTIME timers are not
    affected by clock modifications. Those timers have to use CLOCK_MONOTONIC
    to ensure POSIX compliance.
    
    The introduction of the additional HRTIMER_MODE_PINNED mode broke this
    requirement for pinned timers.
    
    There is no user space visible impact because user space timers are not
    using pinned mode, but for consistency reasons this needs to be fixed.
    
    Check whether the mode has the HRTIMER_MODE_REL bit set instead of
    comparing with HRTIMER_MODE_ABS.
    
    Signed-off-by: Anna-Maria Gleixner <anna-maria@linutronix.de>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: keescook@chromium.org
    Fixes: 597d0275736d ("timers: Framework for identifying pinned timers")
    Link: http://lkml.kernel.org/r/20171221104205.7269-7-anna-maria@linutronix.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 5c929885f1bb4b77f85b1769c49405a0e0f154a1
Author: Santosh Sivaraj <santosh@fossix.org>
Date:   Mon Oct 16 11:19:14 2017 +0530

    powerpc/vdso64: Add support for CLOCK_{REALTIME/MONOTONIC}_COARSE
    
    Current vDSO64 implementation does not have support for coarse clocks
    (CLOCK_MONOTONIC_COARSE, CLOCK_REALTIME_COARSE), for which it falls back
    to system call, increasing the response time, vDSO implementation reduces
    the cycle time. Below is a benchmark of the difference in execution times.
    
    (Non-coarse clocks are also included just for completion)
    
    clock-gettime-realtime: syscall: 172 nsec/call
    clock-gettime-realtime:    libc: 28 nsec/call
    clock-gettime-realtime:    vdso: 22 nsec/call
    clock-gettime-monotonic: syscall: 171 nsec/call
    clock-gettime-monotonic:    libc: 30 nsec/call
    clock-gettime-monotonic:    vdso: 25 nsec/call
    clock-gettime-realtime-coarse: syscall: 153 nsec/call
    clock-gettime-realtime-coarse:    libc: 16 nsec/call
    clock-gettime-realtime-coarse:    vdso: 10 nsec/call
    clock-gettime-monotonic-coarse: syscall: 167 nsec/call
    clock-gettime-monotonic-coarse:    libc: 17 nsec/call
    clock-gettime-monotonic-coarse:    vdso: 11 nsec/call
    
    CC: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Reviewed-by: Naveen N. Rao <naveen.n.rao@linux.vnet.ibm.com>
    Signed-off-by: Santosh Sivaraj <santosh@fossix.org>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

commit 6c51441cd0710330ccdb8dd0288e5316256d1c8e
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Nov 7 11:39:57 2017 +0100

    usbip: use monotonic timestamps
    
    This gets rid of the deprecated do_gettimeofday() function in usbip.
    The comment above vgadget_get_frame() mentions that it suffers
    from issues with the time jumps due to suspend and settimeofday,
    so I'm changing it to use ktime_get_ts64() to use monotonic times
    that don't have this problem.
    
    I couldn't tell whether we should use CLOCK_MONOTONIC or
    CLOCK_MONOTONIC_RAW here, the difference being the exact rate
    when correcting for NTP. I picked monotonic time since it doesn't
    change the speed to the existing code and should be better
    synchronized with other machines we talk to.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Reviewed-by: Krzysztof Opasiak <k.opasiak@samsung.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 0c92e732937c8b159c73ba3c244d29eed5be9f57
Author: Marc Zyngier <maz@kernel.org>
Date:   Fri Jan 15 17:41:09 2016 +0000

    hrtimer: Catch invalid clockids again
    
    
    [ Upstream commit 336a9cde10d641e70bac67d90ae91b3190c3edca ]
    
    commit 82e88ff1ea94 ("hrtimer: Revert CLOCK_MONOTONIC_RAW support") removed
    unfortunately a sanity check in the hrtimer code which was part of that
    MONOTONIC_RAW patch series.
    
    It would have caught the bogus usage of CLOCK_MONOTONIC_RAW in the wireless
    code. So bring it back.
    
    It is way too easy to take any random clockid and feed it to the hrtimer
    subsystem. At best, it gets mapped to a monotonic base, but it would be
    better to just catch illegal values as early as possible.
    
    Detect invalid clockids, map them to CLOCK_MONOTONIC and emit a warning.
    
    [ tglx: Replaced the BUG by a WARN and gracefully map to CLOCK_MONOTONIC ]
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Tomasz Nowicki <tn@semihalf.com>
    Cc: Christoffer Dall <christoffer.dall@linaro.org>
    Link: http://lkml.kernel.org/r/1452879670-16133-3-git-send-email-marc.zyngier@arm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Sasha Levin <alexander.levin@verizon.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 27702bcfe8a125a1feeeb5f07526d63b20cac47f
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Thu Aug 31 11:50:04 2017 -0300

    perf trace: Support syscall name globbing
    
    So now we can use:
    
      # perf trace -e pkey_*
       532.784 ( 0.006 ms): pkey/16018 pkey_alloc(init_val: DISABLE_WRITE) = -1 EINVAL Invalid argument
       532.795 ( 0.004 ms): pkey/16018 pkey_mprotect(start: 0x7f380d0a6000, len: 4096, prot: READ|WRITE, pkey: -1) = 0
       532.801 ( 0.002 ms): pkey/16018 pkey_free(pkey: -1                ) = -1 EINVAL Invalid argument
      ^C[root@jouet ~]#
    
    Or '-e epoll*', '-e *msg*', etc.
    
    Combining syscall names with perf events, tracepoints, etc, continues to
    be valid, i.e. this is possible:
    
      # perf probe -L sys_nanosleep
      <SyS_nanosleep@/home/acme/git/linux/kernel/time/hrtimer.c:0>
          0  SYSCALL_DEFINE2(nanosleep, struct timespec __user *, rqtp,
                            struct timespec __user *, rmtp)
             {
                    struct timespec64 tu;
    
          5         if (get_timespec64(&tu, rqtp))
          6                 return -EFAULT;
    
                    if (!timespec64_valid(&tu))
          9                 return -EINVAL;
    
         11         current->restart_block.nanosleep.type = rmtp ? TT_NATIVE : TT_NONE;
         12         current->restart_block.nanosleep.rmtp = rmtp;
         13         return hrtimer_nanosleep(&tu, HRTIMER_MODE_REL, CLOCK_MONOTONIC);
             }
    
      # perf probe my_probe="sys_nanosleep:12 rmtp"
      Added new event:
        probe:my_probe       (on sys_nanosleep:12 with rmtp)
    
      You can now use it in all perf tools, such as:
    
            perf record -e probe:my_probe -aR sleep 1
    
      #
      # perf trace -e probe:my_probe/max-stack=5/,*sleep sleep 1
         0.427 ( 0.003 ms): sleep/16690 nanosleep(rqtp: 0x7ffefc245090) ...
         0.430 (         ): probe:my_probe:(ffffffffbd112923) rmtp=0)
                                           sys_nanosleep ([kernel.kallsyms])
                                           do_syscall_64 ([kernel.kallsyms])
                                           return_from_SYSCALL_64 ([kernel.kallsyms])
                                           __nanosleep_nocancel (/usr/lib64/libc-2.25.so)
         0.427 (1000.208 ms): sleep/16690  ... [continued]: nanosleep()) = 0
      #
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Wang Nan <wangnan0@huawei.com>
    Link: http://lkml.kernel.org/n/tip-elycoi8wy6y0w9dkj7ox1mzz@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

commit 0bcdc0987cce9880436b70836c6a92bb8e744fd1
Author: John Stultz <john.stultz@linaro.org>
Date:   Fri Aug 25 15:57:04 2017 -0700

    time: Fix ktime_get_raw() incorrect base accumulation
    
    In comqit fc6eead7c1e2 ("time: Clean up CLOCK_MONOTONIC_RAW time
    handling"), the following code got mistakenly added to the update of the
    raw timekeeper:
    
     /* Update the monotonic raw base */
     seconds = tk->raw_sec;
     nsec = (u32)(tk->tkr_raw.xtime_nsec >> tk->tkr_raw.shift);
     tk->tkr_raw.base = ns_to_ktime(seconds * NSEC_PER_SEC + nsec);
    
    Which adds the raw_sec value and the shifted down raw xtime_nsec to the
    base value.
    
    But the read function adds the shifted down tk->tkr_raw.xtime_nsec value
    another time, The result of this is that ktime_get_raw() users (which are
    all internal users) see the raw time move faster then it should (the rate
    at which can vary with the current size of tkr_raw.xtime_nsec), which has
    resulted in at least problems with graphics rendering performance.
    
    The change tried to match the monotonic base update logic:
    
     seconds = (u64)(tk->xtime_sec + tk->wall_to_monotonic.tv_sec);
     nsec = (u32) tk->wall_to_monotonic.tv_nsec;
     tk->tkr_mono.base = ns_to_ktime(seconds * NSEC_PER_SEC + nsec);
    
    Which adds the wall_to_monotonic.tv_nsec value, but not the
    tk->tkr_mono.xtime_nsec value to the base.
    
    To fix this, simplify the tkr_raw.base accumulation to only accumulate the
    raw_sec portion, and do not include the tkr_raw.xtime_nsec portion, which
    will be added at read time.
    
    Fixes: fc6eead7c1e2 ("time: Clean up CLOCK_MONOTONIC_RAW time handling")
    Reported-and-tested-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Kevin Brodsky <kevin.brodsky@arm.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Stephen Boyd <stephen.boyd@linaro.org>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: Miroslav Lichvar <mlichvar@redhat.com>
    Cc: Daniel Mentz <danielmentz@google.com>
    Link: http://lkml.kernel.org/r/1503701824-1645-1-git-send-email-john.stultz@linaro.org

commit 623fd81417ef4389ad8498fd29b586ea624e6d98
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Feb 25 10:27:37 2017 +0000

    mac80211_hwsim: Replace bogus hrtimer clockid
    
    [ Upstream commit 915f3e3f76c05b2da93c4cc278eebc2d9219d9f4 ]
    
    mac80211_hwsim initializes a hrtimer with clockid CLOCK_MONOTONIC_RAW.
    That's not supported.
    
    Use CLOCK_MONOTNIC instead.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Sasha Levin <alexander.levin@verizon.com>

commit 2e42225b85ee59e3fea83895256386c1544adfa6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Feb 25 10:27:37 2017 +0000

    mac80211_hwsim: Replace bogus hrtimer clockid
    
    commit 8fbcfeb8a9cc803464d6c166e7991913711c612c upstream.
    
    mac80211_hwsim initializes a hrtimer with clockid
    CLOCK_MONOTONIC_RAW. That's not supported.
    
    Use CLOCK_MONOTONIC instead.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 4e84b9c79003fb8d0eb7a82851f48d3ea7843f25
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Feb 25 10:27:37 2017 +0000

    mac80211_hwsim: Replace bogus hrtimer clockid
    
    commit 8fbcfeb8a9cc803464d6c166e7991913711c612c upstream.
    
    mac80211_hwsim initializes a hrtimer with clockid
    CLOCK_MONOTONIC_RAW. That's not supported.
    
    Use CLOCK_MONOTONIC instead.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 1b044f1cfc65a7d90b209dfabd57e16d98b58c5b
Merge: e0f3e8f14da8 2287d8664fe7
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jul 3 16:14:51 2017 -0700

    Merge branch 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer updates from Thomas Gleixner:
     "A rather large update for timers/timekeeping:
    
       - compat syscall consolidation (Al Viro)
    
       - Posix timer consolidation (Christoph Helwig / Thomas Gleixner)
    
       - Cleanup of the device tree based initialization for clockevents and
         clocksources (Daniel Lezcano)
    
       - Consolidation of the FTTMR010 clocksource/event driver (Linus
         Walleij)
    
       - The usual set of small fixes and updates all over the place"
    
    * 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (93 commits)
      timers: Make the cpu base lock raw
      clocksource/drivers/mips-gic-timer: Fix an error code in 'gic_clocksource_of_init()'
      clocksource/drivers/fsl_ftm_timer: Unmap region obtained by of_iomap
      clocksource/drivers/tcb_clksrc: Make IO endian agnostic
      clocksource/drivers/sun4i: Switch to the timer-of common init
      clocksource/drivers/timer-of: Fix invalid iomap check
      Revert "ktime: Simplify ktime_compare implementation"
      clocksource/drivers: Fix uninitialized variable use in timer_of_init
      kselftests: timers: Add test for frequency step
      kselftests: timers: Fix inconsistency-check to not ignore first timestamp
      time: Add warning about imminent deprecation of CONFIG_GENERIC_TIME_VSYSCALL_OLD
      time: Clean up CLOCK_MONOTONIC_RAW time handling
      posix-cpu-timers: Make timespec to nsec conversion safe
      itimer: Make timeval to nsec conversion range limited
      timers: Fix parameter description of try_to_del_timer_sync()
      ktime: Simplify ktime_compare implementation
      clocksource/drivers/fttmr010: Factor out clock read code
      clocksource/drivers/fttmr010: Implement delay timer
      clocksource/drivers: Add timer-of common init routine
      clocksource/drivers/tcb_clksrc: Save timer context on suspend/resume
      ...

commit 830146b6390a8f2cedbc7dc5e78331987c0418fa
Author: Will Deacon <will@kernel.org>
Date:   Thu Jun 8 16:44:22 2017 -0700

    arm64/vdso: Fix nsec handling for CLOCK_MONOTONIC_RAW
    
    commit dbb236c1ceb697a559e0694ac4c9e7b9131d0b16 upstream.
    
    Recently vDSO support for CLOCK_MONOTONIC_RAW was added in
    49eea433b326 ("arm64: Add support for CLOCK_MONOTONIC_RAW in
    clock_gettime() vDSO"). Noticing that the core timekeeping code
    never set tkr_raw.xtime_nsec, the vDSO implementation didn't
    bother exposing it via the data page and instead took the
    unshifted tk->raw_time.tv_nsec value which was then immediately
    shifted left in the vDSO code.
    
    Unfortunately, by accellerating the MONOTONIC_RAW clockid, it
    uncovered potential 1ns time inconsistencies caused by the
    timekeeping core not handing sub-ns resolution.
    
    Now that the core code has been fixed and is actually setting
    tkr_raw.xtime_nsec, we need to take that into account in the
    vDSO by adding it to the shifted raw_time value, in order to
    fix the user-visible inconsistency. Rather than do that at each
    use (and expand the data page in the process), instead perform
    the shift/addition operation when populating the data page and
    remove the shift from the vDSO code entirely.
    
    [jstultz: minor whitespace tweak, tried to improve commit
     message to make it more clear this fixes a regression]
    Reported-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Tested-by: Daniel Mentz <danielmentz@google.com>
    Acked-by: Kevin Brodsky <kevin.brodsky@arm.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Stephen Boyd <stephen.boyd@linaro.org>
    Cc: Miroslav Lichvar <mlichvar@redhat.com>
    Link: http://lkml.kernel.org/r/1496965462-20003-4-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 102d12f1567fa3d637bbb2885691fa4aca367f33
Author: John Stultz <john.stultz@linaro.org>
Date:   Thu Jun 8 16:44:21 2017 -0700

    time: Fix CLOCK_MONOTONIC_RAW sub-nanosecond accounting
    
    commit 3d88d56c5873f6eebe23e05c3da701960146b801 upstream.
    
    Due to how the MONOTONIC_RAW accumulation logic was handled,
    there is the potential for a 1ns discontinuity when we do
    accumulations. This small discontinuity has for the most part
    gone un-noticed, but since ARM64 enabled CLOCK_MONOTONIC_RAW
    in their vDSO clock_gettime implementation, we've seen failures
    with the inconsistency-check test in kselftest.
    
    This patch addresses the issue by using the same sub-ns
    accumulation handling that CLOCK_MONOTONIC uses, which avoids
    the issue for in-kernel users.
    
    Since the ARM64 vDSO implementation has its own clock_gettime
    calculation logic, this patch reduces the frequency of errors,
    but failures are still seen. The ARM64 vDSO will need to be
    updated to include the sub-nanosecond xtime_nsec values in its
    calculation for this issue to be completely fixed.
    
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Tested-by: Daniel Mentz <danielmentz@google.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Kevin Brodsky <kevin.brodsky@arm.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Stephen Boyd <stephen.boyd@linaro.org>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: Miroslav Lichvar <mlichvar@redhat.com>
    Link: http://lkml.kernel.org/r/1496965462-20003-3-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 99f66b5182a4f3d89563634f2fe156d4629b9c10
Author: Will Deacon <will@kernel.org>
Date:   Thu Jun 8 16:44:22 2017 -0700

    arm64/vdso: Fix nsec handling for CLOCK_MONOTONIC_RAW
    
    commit dbb236c1ceb697a559e0694ac4c9e7b9131d0b16 upstream.
    
    Recently vDSO support for CLOCK_MONOTONIC_RAW was added in
    49eea433b326 ("arm64: Add support for CLOCK_MONOTONIC_RAW in
    clock_gettime() vDSO"). Noticing that the core timekeeping code
    never set tkr_raw.xtime_nsec, the vDSO implementation didn't
    bother exposing it via the data page and instead took the
    unshifted tk->raw_time.tv_nsec value which was then immediately
    shifted left in the vDSO code.
    
    Unfortunately, by accellerating the MONOTONIC_RAW clockid, it
    uncovered potential 1ns time inconsistencies caused by the
    timekeeping core not handing sub-ns resolution.
    
    Now that the core code has been fixed and is actually setting
    tkr_raw.xtime_nsec, we need to take that into account in the
    vDSO by adding it to the shifted raw_time value, in order to
    fix the user-visible inconsistency. Rather than do that at each
    use (and expand the data page in the process), instead perform
    the shift/addition operation when populating the data page and
    remove the shift from the vDSO code entirely.
    
    [jstultz: minor whitespace tweak, tried to improve commit
     message to make it more clear this fixes a regression]
    Reported-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Tested-by: Daniel Mentz <danielmentz@google.com>
    Acked-by: Kevin Brodsky <kevin.brodsky@arm.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Stephen Boyd <stephen.boyd@linaro.org>
    Cc: Miroslav Lichvar <mlichvar@redhat.com>
    Link: http://lkml.kernel.org/r/1496965462-20003-4-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit a53bfdda06ac114c42796b4193aee10a8108bca1
Author: John Stultz <john.stultz@linaro.org>
Date:   Thu Jun 8 16:44:21 2017 -0700

    time: Fix CLOCK_MONOTONIC_RAW sub-nanosecond accounting
    
    commit 3d88d56c5873f6eebe23e05c3da701960146b801 upstream.
    
    Due to how the MONOTONIC_RAW accumulation logic was handled,
    there is the potential for a 1ns discontinuity when we do
    accumulations. This small discontinuity has for the most part
    gone un-noticed, but since ARM64 enabled CLOCK_MONOTONIC_RAW
    in their vDSO clock_gettime implementation, we've seen failures
    with the inconsistency-check test in kselftest.
    
    This patch addresses the issue by using the same sub-ns
    accumulation handling that CLOCK_MONOTONIC uses, which avoids
    the issue for in-kernel users.
    
    Since the ARM64 vDSO implementation has its own clock_gettime
    calculation logic, this patch reduces the frequency of errors,
    but failures are still seen. The ARM64 vDSO will need to be
    updated to include the sub-nanosecond xtime_nsec values in its
    calculation for this issue to be completely fixed.
    
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Tested-by: Daniel Mentz <danielmentz@google.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Kevin Brodsky <kevin.brodsky@arm.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Stephen Boyd <stephen.boyd@linaro.org>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: Miroslav Lichvar <mlichvar@redhat.com>
    Link: http://lkml.kernel.org/r/1496965462-20003-3-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 8ec7f15b8cca4f790df5cdf33f26e2926d4ee2fd
Author: Goran Ferenc <goran.ferenc@imgtec.com>
Date:   Wed Jun 28 17:55:28 2017 +0200

    MIPS: VDSO: Fix conversions in do_monotonic()/do_monotonic_coarse()
    
    Fix incorrect calculation in do_monotonic() and do_monotonic_coarse()
    function that in turn caused incorrect values returned by the vdso
    version of system call clock_gettime() on mips64 if its system clock
    ID parameter was CLOCK_MONOTONIC or CLOCK_MONOTONIC_COARSE.
    
    Consider these variables and their types on mips32 and mips64:
    
    tk->wall_to_monotonic.tv_sec  s64, s64   (kernel/vdso.c)
    vdso_data.wall_to_mono_sec    u32, u32   (kernel/vdso.c)
    to_mono_sec                   u32, u32   (vdso/gettimeofday.c)
    ts->tv_sec                    s32, s64   (vdso/gettimeofday.c)
    
    For mips64 case, u32 vdso_data.wall_to_mono_sec variable is updated
    from the 64-bit signed variable tk->wall_to_monotonic.tv_sec
    (kernel/vdso.c:76) which is a negative number holding the time passed
    from 1970-01-01 to the time boot started. This 64-bit signed value is
    currently around 47+ years, in seconds. For instance, let this value
    be:
    
    -1489757461
    
    or
    
    11111111111111111111111111111111 10100111001101000001101011101011
    
    By updating 32-bit vdso_data.wall_to_mono_sec variable, we lose upper
    32 bits (signed 1's).
    
    to_mono_sec variable is a parameter of do_monotonic() and
    do_monotonic_coarse() functions which holds vdso_data.wall_to_mono_sec
    value. Its value needs to be added (or subtracted considering it holds
    negative value from the tk->wall_to_monotonic.tv_sec) to the current
    time passed from 1970-01-01 (ts->tv_sec), which is again something like
    47+ years, but increased by the time passed from the boot to the
    current time. ts->tv_sec is 32-bit long in case of 32-bit architecture
    and 64-bit long in case of 64-bit architecture. Consider the update of
    ts->tv_sec (vdso/gettimeofday.c:55 & 167):
    
    ts->tv_sec += to_mono_sec;
    
    mips32 case: This update will be performed correctly, since both
    ts->tv_sec and to_mono_sec are 32-bit long and the sign in to_mono_sec
    is preserved. Implicit conversion from u32 to s32 will be done
    correctly.
    
    mips64 case: This update will be wrong, since the implicit conversion
    will not be done correctly. The reason is that the conversion will be
    from u32 to s64. This is because to_mono_sec is 32-bit long for both
    mips32 and mips64 cases and s64..33 bits of converted to_mono_sec
    variable will be zeros.
    
    So, in order to make MIPS64 implementation work properly for
    MONOTONIC and MONOTONIC_COARSE clock ids on mips64, the size of
    wall_to_mono_sec variable in mips_vdso_data union and respective
    parameters in do_monotonic() and do_monotonic_coarse() functions
    should be changed from u32 to u64. Because of consistency, this
    size change from u32 and u64 is also done for wall_to_mono_nsec
    variable and corresponding function parameters.
    
    As far as similar situations for other architectures are concerned,
    let's take a look at arm. Arm has two distinct vdso_data structures
    for 32-bit & 64-bit cases, and arm's wall_to_mono_sec and
    wall_to_mono_nsec are u32 for 32-bit and u64 for 64-bit cases.
    On the other hand, MIPS has only one structure (mips_vdso_data),
    hence the need for changing the size of above mentioned parameters.
    
    Signed-off-by: Goran Ferenc <goran.ferenc@imgtec.com>
    Signed-off-by: Miodrag Dinic <miodrag.dinic@imgtec.com>
    Signed-off-by: Aleksandar Markovic <aleksandar.markovic@imgtec.com>
    Cc: Douglas Leung <douglas.leung@imgtec.com>
    Cc: James Hogan <james.hogan@imgtec.com>
    Cc: Paul Burton <paul.burton@imgtec.com>
    Cc: Petar Jovanovic <petar.jovanovic@imgtec.com>
    Cc: Raghu Gandham <raghu.gandham@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Cc: linux-kernel@vger.kernel.org
    Patchwork: https://patchwork.linux-mips.org/patch/16638/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

commit 5f4b37d8784da4217ede8f8bcd301686853dcf8c
Merge: 35d8d5d47c0e 8e6cec1c7c5a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Jun 25 11:59:19 2017 -0700

    Merge branch 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer fixes from Thomas Gleixner:
     "A few fixes for timekeeping and timers:
    
       - Plug a subtle race due to a missing READ_ONCE() in the timekeeping
         code where reloading of a pointer results in an inconsistent
         callback argument being supplied to the clocksource->read function.
    
       - Correct the CLOCK_MONOTONIC_RAW sub-nanosecond accounting in the
         time keeping core code, to prevent a possible discontuity.
    
       - Apply a similar fix to the arm64 vdso clock_gettime()
         implementation
    
       - Add missing includes to clocksource drivers, which relied on
         indirect includes which fails in certain configs.
    
       - Use the proper iomem pointer for read/iounmap in a probe function"
    
    * 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      arm64/vdso: Fix nsec handling for CLOCK_MONOTONIC_RAW
      time: Fix CLOCK_MONOTONIC_RAW sub-nanosecond accounting
      time: Fix clock->read(clock) race around clocksource changes
      clocksource: Explicitly include linux/clocksource.h when needed
      clocksource/drivers/arm_arch_timer: Fix read and iounmap of incorrect variable

commit 767392565a3e618950fe1a5ff1ba11295f6332f4
Author: Miroslav Lichvar <mlichvar@redhat.com>
Date:   Fri Jun 9 13:43:17 2017 +0200

    kselftests: timers: Add test for frequency step
    
    This test checks the response of the system clock to frequency
    steps made with adjtimex(). The frequency error and stability of
    the CLOCK_MONOTONIC clock relative to the CLOCK_MONOTONIC_RAW clock
    is measured in two intervals following the step. The test fails if
    values from the second interval exceed specified limits.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Miroslav Lichvar <mlichvar@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Stephen Boyd <stephen.boyd@linaro.org>
    Cc: Shuah Khan <shuah@kernel.org>
    Signed-off-by: Miroslav Lichvar <mlichvar@redhat.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit fc6eead7c1e2e5376c25d2795d4539fdacbc0648
Author: John Stultz <john.stultz@linaro.org>
Date:   Mon May 22 17:20:20 2017 -0700

    time: Clean up CLOCK_MONOTONIC_RAW time handling
    
    Now that we fixed the sub-ns handling for CLOCK_MONOTONIC_RAW,
    remove the duplicitive tk->raw_time.tv_nsec, which can be
    stored in tk->tkr_raw.xtime_nsec (similarly to how its handled
    for monotonic time).
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Miroslav Lichvar <mlichvar@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Stephen Boyd <stephen.boyd@linaro.org>
    Cc: Kevin Brodsky <kevin.brodsky@arm.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: Daniel Mentz <danielmentz@google.com>
    Tested-by: Daniel Mentz <danielmentz@google.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit dbb236c1ceb697a559e0694ac4c9e7b9131d0b16
Author: Will Deacon <will@kernel.org>
Date:   Thu Jun 8 16:44:22 2017 -0700

    arm64/vdso: Fix nsec handling for CLOCK_MONOTONIC_RAW
    
    Recently vDSO support for CLOCK_MONOTONIC_RAW was added in
    49eea433b326 ("arm64: Add support for CLOCK_MONOTONIC_RAW in
    clock_gettime() vDSO"). Noticing that the core timekeeping code
    never set tkr_raw.xtime_nsec, the vDSO implementation didn't
    bother exposing it via the data page and instead took the
    unshifted tk->raw_time.tv_nsec value which was then immediately
    shifted left in the vDSO code.
    
    Unfortunately, by accellerating the MONOTONIC_RAW clockid, it
    uncovered potential 1ns time inconsistencies caused by the
    timekeeping core not handing sub-ns resolution.
    
    Now that the core code has been fixed and is actually setting
    tkr_raw.xtime_nsec, we need to take that into account in the
    vDSO by adding it to the shifted raw_time value, in order to
    fix the user-visible inconsistency. Rather than do that at each
    use (and expand the data page in the process), instead perform
    the shift/addition operation when populating the data page and
    remove the shift from the vDSO code entirely.
    
    [jstultz: minor whitespace tweak, tried to improve commit
     message to make it more clear this fixes a regression]
    Reported-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Tested-by: Daniel Mentz <danielmentz@google.com>
    Acked-by: Kevin Brodsky <kevin.brodsky@arm.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Stephen Boyd <stephen.boyd@linaro.org>
    Cc: "stable #4 . 8+" <stable@vger.kernel.org>
    Cc: Miroslav Lichvar <mlichvar@redhat.com>
    Link: http://lkml.kernel.org/r/1496965462-20003-4-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 3d88d56c5873f6eebe23e05c3da701960146b801
Author: John Stultz <john.stultz@linaro.org>
Date:   Thu Jun 8 16:44:21 2017 -0700

    time: Fix CLOCK_MONOTONIC_RAW sub-nanosecond accounting
    
    Due to how the MONOTONIC_RAW accumulation logic was handled,
    there is the potential for a 1ns discontinuity when we do
    accumulations. This small discontinuity has for the most part
    gone un-noticed, but since ARM64 enabled CLOCK_MONOTONIC_RAW
    in their vDSO clock_gettime implementation, we've seen failures
    with the inconsistency-check test in kselftest.
    
    This patch addresses the issue by using the same sub-ns
    accumulation handling that CLOCK_MONOTONIC uses, which avoids
    the issue for in-kernel users.
    
    Since the ARM64 vDSO implementation has its own clock_gettime
    calculation logic, this patch reduces the frequency of errors,
    but failures are still seen. The ARM64 vDSO will need to be
    updated to include the sub-nanosecond xtime_nsec values in its
    calculation for this issue to be completely fixed.
    
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Tested-by: Daniel Mentz <danielmentz@google.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Kevin Brodsky <kevin.brodsky@arm.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Stephen Boyd <stephen.boyd@linaro.org>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: "stable #4 . 8+" <stable@vger.kernel.org>
    Cc: Miroslav Lichvar <mlichvar@redhat.com>
    Link: http://lkml.kernel.org/r/1496965462-20003-3-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 67edab48caeb75d412706f4b9d3107afd1e07623
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Jun 12 19:39:49 2017 +0200

    posix-timers: Handle relative posix-timers correctly
    
    The recent rework of the posix timer internals broke the magic posix
    mechanism, which requires that relative timers are not affected by
    modifications of the underlying clock. That means relative CLOCK_REALTIME
    timers cannot use CLOCK_REALTIME, because that can be set and adjusted. The
    underlying hrtimer switches the clock for these timers to CLOCK_MONOTONIC.
    
    That still works, but reading the remaining time of such a timer has been
    broken in the rework. The old code used the hrtimer internals directly and
    avoided the posix clock callbacks. Now common_timer_get() uses the
    underlying kclock->timer_get() callback, which is still CLOCK_REALTIME
    based. So the remaining time of such a timer is calculated against the
    wrong time base.
    
    Handle it by switching the k_itimer->kclock pointer according to the
    resulting hrtimer mode. k_itimer->it_clock still contains CLOCK_REALTIME
    because the timer might be set with ABSTIME later and then it needs to
    switch back to the realtime posix clock implementation.
    
    Fixes: eae1c4ae275f ("posix-timers: Make use of cancel/arm callbacks")
    Reported-by: Andrei Vagin <avagin@virtuozzo.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Cyrill Gorcunov <gorcunov@openvz.org>
    Link: http://lkml.kernel.org/r/20170609201156.GB21491@outlook.office365.com

commit e891a32e7ae0c6ba57959799c0ac84681616eeef
Author: Marcelo Tosatti <mtosatti@redhat.com>
Date:   Mon Apr 17 12:51:37 2017 -0300

    KVM: x86: remove irq disablement around KVM_SET_CLOCK/KVM_GET_CLOCK
    
    The disablement of interrupts at KVM_SET_CLOCK/KVM_GET_CLOCK
    attempts to disable software suspend from causing "non atomic behaviour" of
    the operation:
    
        Add a helper function to compute the kernel time and convert nanoseconds
        back to CPU specific cycles.  Note that these must not be called in preemptible
        context, as that would mean the kernel could enter software suspend state,
        which would cause non-atomic operation.
    
    However, assume the kernel can enter software suspend at the following 2 points:
    
            ktime_get_ts(&ts);
    1.
                                                    hypothetical_ktime_get_ts(&ts)
            monotonic_to_bootbased(&ts);
    2.
    
    monotonic_to_bootbased() should be correct relative to a ktime_get_ts(&ts)
    performed after point 1 (that is after resuming from software suspend),
    hypothetical_ktime_get_ts()
    
    Therefore it is also correct for the ktime_get_ts(&ts) before point 1,
    which is
    
            ktime_get_ts(&ts) = hypothetical_ktime_get_ts(&ts) + time-to-execute-suspend-code
    
    Note CLOCK_MONOTONIC does not count during suspension.
    
    So remove the irq disablement, which causes the following warning on
    -RT kernels:
    
     With this reasoning, and the -RT bug that the irq disablement causes
     (because spin_lock is now a sleeping lock), remove the IRQ protection as it
     causes:
    
     [ 1064.668109] in_atomic(): 0, irqs_disabled(): 1, pid: 15296, name:m
     [ 1064.668110] INFO: lockdep is turned off.
     [ 1064.668110] irq event stamp: 0
     [ 1064.668112] hardirqs last  enabled at (0): [<          (null)>]  )
     [ 1064.668116] hardirqs last disabled at (0): [] c0
     [ 1064.668118] softirqs last  enabled at (0): [] c0
     [ 1064.668118] softirqs last disabled at (0): [<          (null)>]  )
     [ 1064.668121] CPU: 13 PID: 15296 Comm: qemu-kvm Not tainted 3.10.0-1
     [ 1064.668121] Hardware name: Dell Inc. PowerEdge R730/0H21J3, BIOS 5
     [ 1064.668123]  ffff8c1796b88000 00000000afe7344c ffff8c179abf3c68 f3
     [ 1064.668125]  ffff8c179abf3c90 ffffffff930ccb3d ffff8c1b992b3610 f0
     [ 1064.668126]  00007ffc1a26fbc0 ffff8c179abf3cb0 ffffffff9375f694 f0
     [ 1064.668126] Call Trace:
     [ 1064.668132]  [] dump_stack+0x19/0x1b
     [ 1064.668135]  [] __might_sleep+0x12d/0x1f0
     [ 1064.668138]  [] rt_spin_lock+0x24/0x60
     [ 1064.668155]  [] __get_kvmclock_ns+0x36/0x110 [k]
     [ 1064.668159]  [] ? futex_wait_queue_me+0x103/0x10
     [ 1064.668171]  [] kvm_arch_vm_ioctl+0xa2/0xd70 [k]
     [ 1064.668173]  [] ? futex_wait+0x1ac/0x2a0
    
    v2: notice get_kvmclock_ns with the same problem (Pankaj).
    v3: remove useless helper function (Pankaj).
    
    Signed-off-by: Marcelo Tosatti <mtosatti@redhat.com>
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>

commit 8fbcfeb8a9cc803464d6c166e7991913711c612c
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Feb 25 10:27:37 2017 +0000

    mac80211_hwsim: Replace bogus hrtimer clockid
    
    mac80211_hwsim initializes a hrtimer with clockid
    CLOCK_MONOTONIC_RAW. That's not supported.
    
    Use CLOCK_MONOTONIC instead.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

commit 915f3e3f76c05b2da93c4cc278eebc2d9219d9f4
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Feb 25 11:27:37 2017 +0100

    mac80211_hwsim: Replace bogus hrtimer clockid
    
    mac80211_hwsim initializes a hrtimer with clockid CLOCK_MONOTONIC_RAW.
    That's not supported.
    
    Use CLOCK_MONOTNIC instead.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit 336a9cde10d641e70bac67d90ae91b3190c3edca
Author: Marc Zyngier <maz@kernel.org>
Date:   Fri Jan 15 17:41:09 2016 +0000

    hrtimer: Catch invalid clockids again
    
    commit 82e88ff1ea94 ("hrtimer: Revert CLOCK_MONOTONIC_RAW support") removed
    unfortunately a sanity check in the hrtimer code which was part of that
    MONOTONIC_RAW patch series.
    
    It would have caught the bogus usage of CLOCK_MONOTONIC_RAW in the wireless
    code. So bring it back.
    
    It is way too easy to take any random clockid and feed it to the hrtimer
    subsystem. At best, it gets mapped to a monotonic base, but it would be
    better to just catch illegal values as early as possible.
    
    Detect invalid clockids, map them to CLOCK_MONOTONIC and emit a warning.
    
    [ tglx: Replaced the BUG by a WARN and gracefully map to CLOCK_MONOTONIC ]
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Tomasz Nowicki <tn@semihalf.com>
    Cc: Christoffer Dall <christoffer.dall@linaro.org>
    Link: http://lkml.kernel.org/r/1452879670-16133-3-git-send-email-marc.zyngier@arm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit baa73d9e478ff32d62f3f9422822b59dd9a95a21
Author: Nicolas Pitre <nico@fluxnic.net>
Date:   Fri Nov 11 00:10:10 2016 -0500

    posix-timers: Make them configurable
    
    Some embedded systems have no use for them.  This removes about
    25KB from the kernel binary size when configured out.
    
    Corresponding syscalls are routed to a stub logging the attempt to
    use those syscalls which should be enough of a clue if they were
    disabled without proper consideration. They are: timer_create,
    timer_gettime: timer_getoverrun, timer_settime, timer_delete,
    clock_adjtime, setitimer, getitimer, alarm.
    
    The clock_settime, clock_gettime, clock_getres and clock_nanosleep
    syscalls are replaced by simple wrappers compatible with CLOCK_REALTIME,
    CLOCK_MONOTONIC and CLOCK_BOOTTIME only which should cover the vast
    majority of use cases with very little code.
    
    Signed-off-by: Nicolas Pitre <nico@linaro.org>
    Acked-by: Richard Cochran <richardcochran@gmail.com>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: John Stultz <john.stultz@linaro.org>
    Reviewed-by: Josh Triplett <josh@joshtriplett.org>
    Cc: Paul Bolle <pebolle@tiscali.nl>
    Cc: linux-kbuild@vger.kernel.org
    Cc: netdev@vger.kernel.org
    Cc: Michal Marek <mmarek@suse.com>
    Cc: Edward Cree <ecree@solarflare.com>
    Link: http://lkml.kernel.org/r/1478841010-28605-7-git-send-email-nicolas.pitre@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 5587859fb1e8bea5e3b8a0ab7866526ad7d1d673
Author: Paolo Bonzini <pbonzini@redhat.com>
Date:   Tue Oct 25 15:23:49 2016 +0200

    KVM: x86: use ktime_get instead of seeking the hrtimer_clock_base
    
    The base clock for the LAPIC timer is always CLOCK_MONOTONIC.
    
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>

commit e831101a73fbc8339ef1d1909dad3ef64f089e70
Merge: f9abf53af4c7 fd6380b75065
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jul 27 11:16:05 2016 -0700

    Merge tag 'arm64-upstream' of git://git.kernel.org/pub/scm/linux/kernel/git/arm64/linux
    
    Pull arm64 updates from Catalin Marinas:
    
     - Kexec support for arm64
    
     - Kprobes support
    
     - Expose MIDR_EL1 and REVIDR_EL1 CPU identification registers to sysfs
    
     - Trapping of user space cache maintenance operations and emulation in
       the kernel (CPU errata workaround)
    
     - Clean-up of the early page tables creation (kernel linear mapping,
       EFI run-time maps) to avoid splitting larger blocks (e.g.  pmds) into
       smaller ones (e.g.  ptes)
    
     - VDSO support for CLOCK_MONOTONIC_RAW in clock_gettime()
    
     - ARCH_HAS_KCOV enabled for arm64
    
     - Optimise IP checksum helpers
    
     - SWIOTLB optimisation to only allocate/initialise the buffer if the
       available RAM is beyond the 32-bit mask
    
     - Properly handle the "nosmp" command line argument
    
     - Fix for the initialisation of the CPU debug state during early boot
    
     - vdso-offsets.h build dependency workaround
    
     - Build fix when RANDOMIZE_BASE is enabled with MODULES off
    
    * tag 'arm64-upstream' of git://git.kernel.org/pub/scm/linux/kernel/git/arm64/linux: (64 commits)
      arm64: arm: Fix-up the removal of the arm64 regs_query_register_name() prototype
      arm64: Only select ARM64_MODULE_PLTS if MODULES=y
      arm64: mm: run pgtable_page_ctor() on non-swapper translation table pages
      arm64: mm: make create_mapping_late() non-allocating
      arm64: Honor nosmp kernel command line option
      arm64: Fix incorrect per-cpu usage for boot CPU
      arm64: kprobes: Add KASAN instrumentation around stack accesses
      arm64: kprobes: Cleanup jprobe_return
      arm64: kprobes: Fix overflow when saving stack
      arm64: kprobes: WARN if attempting to step with PSTATE.D=1
      arm64: debug: remove unused local_dbg_{enable, disable} macros
      arm64: debug: remove redundant spsr manipulation
      arm64: debug: unmask PSTATE.D earlier
      arm64: localise Image objcopy flags
      arm64: ptrace: remove extra define for CPSR's E bit
      kprobes: Add arm64 case in kprobe example module
      arm64: Add kernel return probes support (kretprobes)
      arm64: Add trampoline code for kretprobes
      arm64: kprobes instruction simulation support
      arm64: Treat all entry code as non-kprobe-able
      ...

commit 49eea433b326a0ac5c7c941a011b2c65990bd19b
Author: Kevin Brodsky <kevin.brodsky@arm.com>
Date:   Tue Jul 12 11:24:00 2016 +0100

    arm64: Add support for CLOCK_MONOTONIC_RAW in clock_gettime() vDSO
    
    So far the arm64 clock_gettime() vDSO implementation only supported
    the following clocks, falling back to the syscall for the others:
    - CLOCK_REALTIME{,_COARSE}
    - CLOCK_MONOTONIC{,_COARSE}
    
    This patch adds support for the CLOCK_MONOTONIC_RAW clock, taking
    advantage of the recent refactoring of the vDSO time functions. Like
    the non-_COARSE clocks, this only works when the "arch_sys_counter"
    clocksource is in use (allowing us to read the current time from the
    virtual counter register), otherwise we also have to fall back to the
    syscall.
    
    Most of the data is shared with CLOCK_MONOTONIC, and the algorithm is
    similar. The reference implementation in kernel/time/timekeeping.c
    shows that:
    - CLOCK_MONOTONIC = tk->wall_to_monotonic + tk->xtime_sec +
      timekeeping_get_ns(&tk->tkr_mono)
    - CLOCK_MONOTONIC_RAW = tk->raw_time + timekeeping_get_ns(&tk->tkr_raw)
    - tkr_mono and tkr_raw are identical (in particular, same
      clocksource), except these members:
      * mult (only mono's multiplier is NTP-adjusted)
      * xtime_nsec (always 0 for raw)
    
    Therefore, tk->raw_time and tkr_raw->mult are now also stored in the
    vDSO data page.
    
    Cc: Ali Saidi <ali.saidi@arm.com>
    Signed-off-by: Kevin Brodsky <kevin.brodsky@arm.com>
    Reviewed-by: Dave Martin <dave.martin@arm.com>
    Acked-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>

commit b33f491f5a9aaf171b7de0f905362eb0314af478
Author: Kevin Brodsky <kevin.brodsky@arm.com>
Date:   Tue Jul 12 11:23:59 2016 +0100

    arm64: Refactor vDSO time functions
    
    Time functions are directly implemented in assembly in arm64, and it
    is desirable to keep it this way for performance reasons (everything
    fits in registers, so that the stack is not used at all). However, the
    current implementation is quite difficult to read and understand (even
    considering it's assembly).  Additionally, due to the structure of
    __kernel_clock_gettime, which heavily uses conditional branches to
    share code between the different clocks, it is difficult to support a
    new clock without making the branches even harder to follow.
    
    This commit completely refactors the structure of clock_gettime (and
    gettimeofday along the way) while keeping exactly the same algorithms.
    We no longer try to share code; instead, macros provide common
    operations. This new approach comes with a number of advantages:
    - In clock_gettime, clock implementations are no longer interspersed,
      making them much more readable. Additionally, macros only use
      registers passed as arguments or reserved with .req, this way it is
      easy to make sure that registers are properly allocated. To avoid a
      large number of branches in a given execution path, a jump table is
      used; a normal execution uses 3 unconditional branches.
    - __do_get_tspec has been replaced with 2 macros (get_ts_clock_mono,
      get_clock_shifted_nsec) and explicit loading of data from the vDSO
      page. Consequently, clock_gettime and gettimeofday are now leaf
      functions, and saving x30 (lr) is no longer necessary.
    - Variables protected by tb_seq_count are now loaded all at once,
      allowing to merge the seqcnt_read macro into seqcnt_check.
    - For CLOCK_REALTIME_COARSE, removed an unused load of the wall to
      monotonic timespec.
    - For CLOCK_MONOTONIC_COARSE, removed a few shift instructions.
    
    Obviously, the downside of sharing less code is an increase in code
    size. However since the vDSO has its own code page, this does not
    really matter, as long as the size of the DSO remains below 4 kB. For
    now this should be all right:
                        Before  After
      vdso.so size (B)  2776    3000
    
    Signed-off-by: Kevin Brodsky <kevin.brodsky@arm.com>
    Reviewed-by: Dave Martin <dave.martin@arm.com>
    Acked-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>

commit bc2b7dab629a51e8beb5fda4222c62a23b729f26
Author: Gregor Boirie <gregor.boirie@parrot.com>
Date:   Wed Mar 9 19:05:49 2016 +0100

    iio:core: timestamping clock selection support
    
    Adds a new per-device sysfs attribute "current_timestamp_clock" to allow
    userspace to select a particular POSIX clock for buffered samples and
    events timestamping.
    
    Following clocks, as listed in clock_gettime(2), are supported:
    CLOCK_REALTIME, CLOCK_MONOTONIC, CLOCK_MONOTONIC_RAW,
    CLOCK_REALTIME_COARSE, CLOCK_MONOTONIC_COARSE, CLOCK_BOOTTIME and
    CLOCK_TAI.
    
    Signed-off-by: Gregor Boirie <gregor.boirie@parrot.com>
    Acked-by: Sanchayan Maity <maitysanchayan@gmail.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

commit 0209b937569a133dedfe930cdfff3a0d1d68c9e9
Author: Thomas Graziadei <thomas.graziadei@omicronenergy.com>
Date:   Tue May 31 15:06:06 2016 +0200

    timekeeping: Fix 1ns/tick drift with GENERIC_TIME_VSYSCALL_OLD
    
    The user notices the problem in a raw and real time drift, calling
    clock_gettime with CLOCK_REALTIME / CLOCK_MONOTONIC_RAW on a system
    with no ntp correction taking place (no ntpd or ptp stuff running).
    
    The problem is, that old_vsyscall_fixup adds an extra 1ns even though
    xtime_nsec is already held in full nsecs and the remainder in this
    case is 0. Do the rounding up buisness only if needed.
    
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Thomas Graziadei <thomas.graziadei@omicronenergy.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 00fdbae1a9d2cecfcbab98fe69e4483f80fb80c4
Author: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
Date:   Sun Jun 5 14:03:29 2016 +0100

    greybus: timesync: Add gb_timesync_frame_time_to_timespec()
    
    This patch adds gb_timesync_to_timespec_by_svc() and
    gb_timesync_to_timespec_by_interface() respectively. These routines will
    convert from a given FrameTime to a ktime/timespec within an envelope of
    about 17 seconds. The purpose of this routine is to enable reporting of a
    FrameTime from a Module such as a Camera Module and to allow the AP to
    then convert this timestamp into a Linux-native timestamp such as ktime.
    This is useful and required in the v4l layer.
    
    At 19.2MHz the accuracy of this conversion is about .3 femtoseconds per
    count, which means at a 1 second offset from the reference the cumulative
    error is about 1.59 nanoseconds. 1.59 nanoseconds is still less than 1
    clock's worth of error @ 19.2MHz where each clock is 52.0833~ nanoseconds.
    
    We're aiming for a maximum error rate of 30 nanoseconds which means at the
    clock rate we are running at, the conversion from a FrameTime to a Linux
    ktime/timespec can be plus-or-minus about 17 seconds from the reference
    FrameTime/ktime pair before the routine will refuse to convert.
    
    A realistic use-case for this routine is envisaged to be
    
    - Greybus message received
    - Some processing takes place - taking milliseconds
    - Call into this routine is made
    - Actual time between event in Module and conversion in AP < 1 second
    - Error rate in conversion at 1.59 nanoseconds is less than 1 clock
      @ 19.2MHz
    
    This routine is not designed to allow for conversions for events with
    large gaps between the event time and the current reference time for
    conversion. Since FrameTime can be a very large integer we cannot convert
    an arbitrarily large FrameTime to ktime, the feeling and objective here is
    to make an over-provisioned envelope that in practical terms can never be
    exceeded by expected use-cases. To convert longer gaps more work would have
    to be done but ultimately some limit needs to be imposed and right now 0.3
    femotseconds per clock on MSM8994 is both accurate and generous.
    
    Adds:
    - timesync.c::gb_timesync_frame_time_to_timespec_by_svc(
                                                     struct gb_svc *,
                                                     u64 frame_time,
                                                     struct timespec *ts)
      - gb_svc is a pointer to a standard greybus SVC data structure
      - frame_time is a system FrameTime.
      - ts is an output parameter which represents the converted FrameTime
        as a CLOCK_MONOTONIC timespec value.
      - Returns 0 on success or a negative number indicating the type of
        error on failure.
    
    - timesync.c::gb_timesync_frame_time_to_timespec_by_interface(
                                                     struct gb_interface *,
                                                     u64 frame_time,
                                                     struct timespec *ts)
      - gb_svc is a pointer to a standard greybus Interface data structure
      - frame_time is a system FrameTime.
      - ts is an output parameter which represents the converted FrameTime
        as a CLOCK_MONOTONIC timespec value.
      - Returns 0 on success or a negative number indicating the type of
        error on failure.
    
    Signed-off-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Acked-by: Alex Elder <elder@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

commit 8a284c062ec923c924c79e3b1b5199b8d72904fc
Merge: 208de2147767 6436257b491c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Mar 15 12:13:56 2016 -0700

    Merge branch 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer updates from Thomas Gleixner:
     "The timer department delivers this time:
    
       - Support for cross clock domain timestamps in the core code plus a
         first user.  That allows more precise timestamping for PTP and
         later for audio and other peripherals.
    
         The ptp/e1000e patches have been acked by the relevant maintainers
         and are carried in the timer tree to avoid merge ordering issues.
    
       - Support for unregistering the current clocksource watchdog.  That
         lifts a limitation for switching clocksources which has been there
         from day 1
    
       - The usual pile of fixes and updates to the core and the drivers.
         Nothing outstanding and exciting"
    
    * 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (26 commits)
      time/timekeeping: Work around false positive GCC warning
      e1000e: Adds hardware supported cross timestamp on e1000e nic
      ptp: Add PTP_SYS_OFFSET_PRECISE for driver crosstimestamping
      x86/tsc: Always Running Timer (ART) correlated clocksource
      hrtimer: Revert CLOCK_MONOTONIC_RAW support
      time: Add history to cross timestamp interface supporting slower devices
      time: Add driver cross timestamp interface for higher precision time synchronization
      time: Remove duplicated code in ktime_get_raw_and_real()
      time: Add timekeeping snapshot code capturing system time and counter
      time: Add cycles to nanoseconds translation
      jiffies: Use CLOCKSOURCE_MASK instead of constant
      clocksource: Introduce clocksource_freq2mult()
      clockevents/drivers/exynos_mct: Implement ->set_state_oneshot_stopped()
      clockevents/drivers/arm_global_timer: Implement ->set_state_oneshot_stopped()
      clockevents/drivers/arm_arch_timer: Implement ->set_state_oneshot_stopped()
      clocksource/drivers/arm_global_timer: Register delay timer
      clocksource/drivers/lpc32xx: Support timer-based ARM delay
      clocksource/drivers/lpc32xx: Support periodic mode
      clocksource/drivers/lpc32xx: Don't use the prescaler counter for clockevents
      clocksource/drivers/rockchip: Add err handle for rk_timer_init
      ...

commit 82e88ff1ea948d83125a8aaa7c9809f03ccc500f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Mar 3 11:11:12 2016 +0100

    hrtimer: Revert CLOCK_MONOTONIC_RAW support
    
    Revert commits:
    a6e707ddbdf1: KVM: arm/arm64: timer: Switch to CLOCK_MONOTONIC_RAW
    9006a01829a5: hrtimer: Catch illegal clockids
    9c808765e88e: hrtimer: Add support for CLOCK_MONOTONIC_RAW
    
    Marc found out, that there are fundamental issues with that patch series
    because __hrtimer_get_next_event() and hrtimer_forward() need support for
    CLOCK_MONOTONIC_RAW. Nothing which is easily fixed, so revert the whole lot.
    
    Reported-by: Marc Zyngier <marc.zyngier@arm.com>
    Link: http://lkml.kernel.org/r/56D6CEF0.8060607@arm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 209045adc2bbdb2b315fa5539cec54d01cd3e7db
Author: Stephane Eranian <eranian@google.com>
Date:   Mon Nov 30 10:02:22 2015 +0100

    perf tools: add JVMTI agent library
    
    This is a standalone JVMTI library to help  profile Java jitted code with perf
    record/perf report. The library is not installed or compiled automatically by
    perf Makefile. It is not used directly by perf. It is arch agnostic and has
    been tested on X86 and ARM. It needs to be used with a Java runtime, such as
    OpenJDK, as follows:
    
      $ java -agentpath:libjvmti.so .......
    
    See the "Committer Notes" below on how to build it.
    
    When used this way, java will generate a jitdump binary file in
    $HOME/.debug/java/jit/java-jit-*
    
    This binary dump file contains information to help symbolize and
    annotate jitted code.
    
    The jitdump information must be injected into the perf.data file
    using:
    
      $ perf inject --jit -i perf.data -o perf.data.jitted
    
    This injects the MMAP records to cover the jitted code and also generates
    one ELF image for each jitted function. The ELF images are created in the
    same subdir as the jitdump file. The MMAP records point there too.
    
    Then, to visualize the function or asm profile, simply use the regular
    perf commands:
    
      $ perf report -i perf.data.jitted
    
    or
    
      $ perf annotate -i perf.data.jitted
    
    JVMTI agent code adapted from the OProfile's opagent code.
    
    This version of the JVMTI agent is using the CLOCK_MONOTONIC as the time
    source to timestamp jit samples. To correlate with perf_events samples,
    it needs to run on kernel 4.0.0-rc5+ or later with the following commit
    from Peter Zijlstra:
    
      34f439278cef ("perf: Add per event clockid support")
    
    With this patch recording jitted code is done as follows:
    
       $ perf record -k mono -- java -agentpath:libjvmti.so .......
    
     --------------------------------------------------------------------------
    
    Committer Notes:
    
    Extended testing instructions:
    
      $ cd tools/perf/jvmti/
      $ dnf install java-devel
      $ make
    
    Then, create some simple java stuff to record some samples:
    
      $ cat hello.java
      public class hello {
            public static void main(String[] args) {
                     System.out.println("Hello, World");
            }
      }
      $ javac hello.java
      $ java hello
      Hello, World
      $
    
    And then record it using this jvmti thing:
    
      $ perf record -k mono java -agentpath:/home/acme/git/linux/tools/perf/jvmti/libjvmti.so hello
      java: jvmti: jitdump in /home/acme/.debug/jit/java-jit-20160205.XXWIEDls/jit-1908.dump
      Hello, World
      [ perf record: Woken up 1 times to write data ]
      [ perf record: Captured and wrote 0.030 MB perf.data (268 samples) ]
      $
    
    Now lets insert the PERF_RECORD_MMAP2 records to point jitted mmaps to
    files created by the agent:
    
      $ perf inject --jit -i perf.data -o perf.data.jitted
    
    And finally see that it did its job:
    
      $ perf report -D -i perf.data.jitted | grep PERF_RECORD_MMAP2 | tail -5
      79197149129422 0xfe10 [0xa0]: PERF_RECORD_MMAP2 1908/1923: [0x7f172428bd60(0x80) @ 0x40 fd:02 1840554 1]: --xs /home/acme/.debug/jit/java-jit-20160205.XXWIEDls/jitted-1908-283.so
      79197149235701 0xfeb0 [0xa0]: PERF_RECORD_MMAP2 1908/1923: [0x7f172428ba60(0x180) @ 0x40 fd:02 1840555 1]: --xs /home/acme/.debug/jit/java-jit-20160205.XXWIEDls/jitted-1908-284.so
      79197149250558 0xff50 [0xa0]: PERF_RECORD_MMAP2 1908/1923: [0x7f172428b860(0x180) @ 0x40 fd:02 1840556 1]: --xs /home/acme/.debug/jit/java-jit-20160205.XXWIEDls/jitted-1908-285.so
      79197149714746 0xfff0 [0xa0]: PERF_RECORD_MMAP2 1908/1923: [0x7f172428b660(0x180) @ 0x40 fd:02 1840557 1]: --xs /home/acme/.debug/jit/java-jit-20160205.XXWIEDls/jitted-1908-286.so
      79197149806558 0x10090 [0xa0]: PERF_RECORD_MMAP2 1908/1923: [0x7f172428b460(0x180) @ 0x40 fd:02 1840558 1]: --xs /home/acme/.debug/jit/java-jit-20160205.XXWIEDls/jitted-1908-287.so
      $
    
    So:
    
      $ perf report -D -i perf.data | grep PERF_RECORD_MMAP2 | wc -l
      Failed to open /tmp/perf-1908.map, continuing without symbols
      21
      $ perf report -D -i perf.data.jitted | grep PERF_RECORD_MMAP2 | wc -l
      307
      $ echo $((307 - 21))
      286
      $
    
    286 extra PERF_RECORD_MMAP2 records.
    
    All for thise tiny, with just one function, ELF files:
    
      $ file /home/acme/.debug/jit/java-jit-20160205.XXWIEDls/jitted-1908-9.so
      /home/acme/.debug/jit/java-jit-20160205.XXWIEDls/jitted-1908-9.so: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), corrupted program header size, BuildID[sha1]=ae54a2ebc3ecf0ba547bfc8cabdea1519df5203f, not stripped
      $ readelf -sw /home/acme/.debug/jit/java-jit-20160205.XXWIEDls/jitted-1908-9.so
    
      Symbol table '.symtab' contains 2 entries:
       Num:    Value          Size Type    Bind   Vis      Ndx Name
         0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND
         1: 0000000000000040     9 FUNC    LOCAL  DEFAULT    1 atomic_cmpxchg_long
      $
    
    Inserted into the build-id cache:
    
      $ ls -la ~/.debug/.build-id/ae/54a2ebc3ecf0ba547bfc8cabdea1519df5203f
      lrwxrwxrwx. 1 acme acme 111 Feb  5 11:30 /home/acme/.debug/.build-id/ae/54a2ebc3ecf0ba547bfc8cabdea1519df5203f -> ../../home/acme/.debug/jit/java-jit-20160205.XXWIEDls/jitted-1908-9.so/ae54a2ebc3ecf0ba547bfc8cabdea1519df5203f
    
    Note: check why 'file' reports that 'corrupted program header size'.
    
    With a stupid java hog to do some profiling:
    
    $ cat hog.java
      public class hog {
            private static double do_something_else(int i) {
                    double total = 0;
                    while (i > 0) {
                            total += Math.log(i--);
                    }
                    return total;
            }
            private static double do_something(int i) {
                    double total = 0;
                    while (i > 0) {
                            total += Math.sqrt(i--) + do_something_else(i / 100);
                    }
                    return total;
            }
            public static void main(String[] args) {
                    System.out.println(String.format("%s=%f & %f", args[0],
                                       do_something(Integer.parseInt(args[0])),
                                       do_something_else(Integer.parseInt(args[1]))));
            }
      }
      $ javac hog.java
      $ perf record -F 10000 -g -k mono java -agentpath:/home/acme/git/linux/tools/perf/jvmti/libjvmti.so hog 100000 2345000
      java: jvmti: jitdump in /home/acme/.debug/jit/java-jit-20160205.XX4sqd14/jit-8670.dump
      100000=291561592.669602 & 32050989.778714
      [ perf record: Woken up 6 times to write data ]
      [ perf record: Captured and wrote 1.536 MB perf.data (12538 samples) ]
      $ perf inject --jit -i perf.data -o perf.data.jitted
    
    Looking at the 'perf report' TUI, at one expanded callchain leading
    to the jitted code:
    
      $ perf report --no-children -i perf.data.jitted
    
    Samples: 12K of event 'cycles:pp', Event count (approx.): 3829569932
      Overhead  Comm  Shared Object       Symbol
    -   93.38%  java  jitted-8670-291.so  [.] class hog.do_something_else(int)
         class hog.do_something_else(int)
       - Interpreter
          - 75.86% call_stub
               JavaCalls::call_helper
               jni_invoke_static
               jni_CallStaticVoidMethod
               JavaMain
               start_thread
          - 17.52% JavaCalls::call_helper
               jni_invoke_static
               jni_CallStaticVoidMethod
               JavaMain
               start_thread
    
    Signed-off-by: Stephane Eranian <eranian@google.com>
    Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Andi Kleen <ak@linux.intel.com>
    Cc: Carl Love <cel@us.ibm.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: John McCutchan <johnmccutchan@google.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Pawel Moll <pawel.moll@arm.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Sonny Rao <sonnyrao@chromium.org>
    Cc: Sukadev Bhattiprolu <sukadev@linux.vnet.ibm.com>
    Link: http://lkml.kernel.org/r/1448874143-7269-4-git-send-email-eranian@google.com
    [ Made it build on fedora23, added some build/usage instructions ]
    [ Check if filename != NULL in compiled_method_load_cb, fixing segfault ]
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

commit a6e707ddbdf150bd1c2a5c0eccc55abdc62a0039
Author: Marc Zyngier <maz@kernel.org>
Date:   Fri Jan 15 17:41:10 2016 +0000

    KVM: arm/arm64: timer: Switch to CLOCK_MONOTONIC_RAW
    
    In order to avoid NTP messing with the guest timer behind our back,
    use the new and improved monotonic raw version of the hrtimers.
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Tomasz Nowicki <tn@semihalf.com>
    Cc: Christoffer Dall <christoffer.dall@linaro.org>
    Link: http://lkml.kernel.org/r/1452879670-16133-4-git-send-email-marc.zyngier@arm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 9c808765e88efb6fa6af7e2206ef89512f1840a7
Author: Marc Zyngier <maz@kernel.org>
Date:   Fri Jan 15 17:41:08 2016 +0000

    hrtimer: Add support for CLOCK_MONOTONIC_RAW
    
    The KVM/ARM timer implementation arms a hrtimer when a vcpu is
    blocked (usually because it is waiting for an interrupt)
    while its timer is going to kick in the future.
    
    It is essential that this timer doesn't get adjusted, or the
    guest will end up being woken-up at the wrong time (NTP running
    on the host seems to confuse the hell out of some guests).
    
    In order to allow this, let's add CLOCK_MONOTONIC_RAW support
    to hrtimer (it is so far only supported for posix timers). It also
    has the (limited) benefit of fixing de0421d53bfb ("mac80211_hwsim:
    shuffle code to prepare for dynamic radios"), which already uses
    this functionnality without realizing wasn't implemented (just being
    lucky...).
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Tomasz Nowicki <tn@semihalf.com>
    Cc: Christoffer Dall <christoffer.dall@linaro.org>
    Link: http://lkml.kernel.org/r/1452879670-16133-2-git-send-email-marc.zyngier@arm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 9057bc2b35cfdb5b5fb7d93708f11de5dd9b6b2e
Author: Hans Verkuil <hans.verkuil@cisco.com>
Date:   Fri Nov 20 07:16:56 2015 -0200

    [media] solo6x10: use v4l2_get_timestamp to fill in buffer timestamp
    
    The timestamp of a v4l2_buffer was advertised as being CLOCK_MONOTONIC,
    but instead a timestamp from a header field was used. This is inconsistent
    and not what applications expect. Use v4l2_get_timestamp to properly
    set the timestamp.
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

commit 2eb5f31bc4ea24bb293e82934cfa1cce9573304b
Author: Anton Ivanov <aivanov@brocade.com>
Date:   Mon Nov 2 16:16:37 2015 +0000

    um: Switch clocksource to hrtimers
    
    UML is using an obsolete itimer call for
    all timers and "polls" for kernel space timer firing
    in its userspace portion resulting in a long list
    of bugs and incorrect behaviour(s). It also uses
    ITIMER_VIRTUAL for its timer which results in the
    timer being dependent on it running and the cpu
    load.
    
    This patch fixes this by moving to posix high resolution
    timers firing off CLOCK_MONOTONIC and relaying the timer
    correctly to the UML userspace.
    
    Fixes:
     - crashes when hosts suspends/resumes
     - broken userspace timers - effecive ~40Hz instead
       of what they should be. Note - this modifies skas behavior
       by no longer setting an itimer per clone(). Timer events
       are relayed instead.
     - kernel network packet scheduling disciplines
     - tcp behaviour especially under load
     - various timer related corner cases
    
    Finally, overall responsiveness of userspace is better.
    
    Signed-off-by: Thomas Meyer <thomas@m3y3r.de>
    Signed-off-by: Anton Ivanov <aivanov@brocade.com>
    [rw: massaged commit message]
    Signed-off-by: Richard Weinberger <richard@nod.at>

commit 38bf985b05625df3fbbc1dbf543bdd2da447c2af
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed May 27 16:44:48 2015 -0700

    timer_list: Add the base offset so remaining nsecs are accurate for non monotonic timers
    
    I noticed for non-monotonic timers in timer_list, some of the
    output looked a little confusing.
    
    For example:
     #1: <0000000000000000>, posix_timer_fn, S:01, hrtimer_start_range_ns, leap-a-day/2360
     # expires at 1434412800000000000-1434412800000000000 nsecs [in 1434410725062375469 to 1434410725062375469 nsecs]
    
    You'll note the relative time till the expiration "[in xxx to
    yyy nsecs]" is incorrect. This is because its printing the delta
    between CLOCK_MONOTONIC time to the CLOCK_REALTIME expiration.
    
    This patch fixes this issue by adding the clock offset to the
    "now" time which we use to calculate the delta.
    
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Daniel Bristot de Oliveira <bristot@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Jan Kara <jack@suse.cz>
    Cc: Jiri Bohac <jbohac@suse.cz>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Shuah Khan <shuahkh@osg.samsung.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 09edea4f8fdeb4e292b80d493296070f5ec64e6e
Author: Nathan Lynch <nathan_lynch@mentor.com>
Date:   Mon Aug 10 17:36:06 2015 +0100

    ARM: 8410/1: VDSO: fix coarse clock monotonicity regression
    
    Since 906c55579a63 ("timekeeping: Copy the shadow-timekeeper over the
    real timekeeper last") it has become possible on ARM to:
    
    - Obtain a CLOCK_MONOTONIC_COARSE or CLOCK_REALTIME_COARSE timestamp
      via syscall.
    - Subsequently obtain a timestamp for the same clock ID via VDSO which
      predates the first timestamp (by one jiffy).
    
    This is because ARM's update_vsyscall is deriving the coarse time
    using the __current_kernel_time interface, when it should really be
    using the timekeeper object provided to it by the timekeeping core.
    It happened to work before only because __current_kernel_time would
    access the same timekeeper object which had been passed to
    update_vsyscall.  This is no longer the case.
    
    Cc: stable@vger.kernel.org
    Fixes: 906c55579a63 ("timekeeping: Copy the shadow-timekeeper over the real timekeeper last")
    Signed-off-by: Nathan Lynch <nathan_lynch@mentor.com>
    Acked-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

commit 878854a374620a3f5e8c0a3c418e82a429bc2cff
Author: Nathan Lynch <nathan_lynch@mentor.com>
Date:   Fri Aug 7 21:03:23 2015 -0500

    arm64: VDSO: fix coarse clock monotonicity regression
    
    Since 906c55579a63 ("timekeeping: Copy the shadow-timekeeper over the
    real timekeeper last") it has become possible on arm64 to:
    
    - Obtain a CLOCK_MONOTONIC_COARSE or CLOCK_REALTIME_COARSE timestamp
      via syscall.
    - Subsequently obtain a timestamp for the same clock ID via VDSO which
      predates the first timestamp (by one jiffy).
    
    This is because arm64's update_vsyscall is deriving the coarse time
    using the __current_kernel_time interface, when it should really be
    using the timekeeper object provided to it by the timekeeping core.
    It happened to work before only because __current_kernel_time would
    access the same timekeeper object which had been passed to
    update_vsyscall.  This is no longer the case.
    
    Signed-off-by: Nathan Lynch <nathan_lynch@mentor.com>
    Acked-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>

commit 56c2da8338d5cdfc0695eeed96ebe03cf2ac0321
Author: Rob Clark <robdclark@gmail.com>
Date:   Mon May 11 11:50:03 2015 -0400

    drm/msm: fix timeout calculation
    
    The 'timeout' value comes from userspace (CLOCK_MONOTONIC), but
    converting this directly to jiffies doesn't take into account the
    initial jiffies count at boot, which may differ from the base time
    of CLOCK_MONOTONIC.
    
    TODO: add ktime_delta_jiffies() when rebasing on 4.1 and use that
    instead of ktime_sub/ktime_to_timespec/timespec_to_jiffies combo (as
    suggested by Arnd)
    
    v2: switch over from 'struct timespec' to ktime_t throughout, since
    'struct timespec' will be deprecated (as suggested by Arnd)
    v3: minor cosmetic tweaks
    
    Cc: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

commit 814c8c38e13c7050259c72f89bb01f3fc903f642
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Tue Mar 31 00:19:31 2015 +0200

    perf record: Add clockid parameter
    
    Teach perf-record about the new perf_event_attr::{use_clockid, clockid}
    fields. Add a simple parameter to set the clock (if any) to be used for
    the events to be recorded into the data file.
    
    Since we store the entire perf_event_attr in the EVENT_DESC section we
    also already store the used clockid in the data file.
    
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Acked-by: David Ahern <dsahern@gmail.com>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Stephane Eranian <eranian@google.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Yunlong Song <yunlong.song@huawei.com>
    Link: http://lkml.kernel.org/r/20150407154851.GR23123@twins.programming.kicks-ass.net
    [ Conditionally define CLOCK_BOOTTIME, at least rhel6 doesn't have it - dsahern
      Ditto for CLOCK_MONOTONIC_RAW, sles11sp2 doesn't have it - yunlong.song ]
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

commit f09cb9a1808e35ad7502ea39b6bfb443c7fa0f19
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Thu Mar 19 09:39:08 2015 +0100

    time: Introduce tk_fast_raw
    
    Add the NMI safe CLOCK_MONOTONIC_RAW accessor..
    
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Acked-by: John Stultz <john.stultz@linaro.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/20150319093400.562746929@infradead.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 876e78818def2983be55878b21f7152fbaebbd36
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Thu Mar 19 10:09:06 2015 +0100

    time: Rename timekeeper::tkr to timekeeper::tkr_mono
    
    In preparation of adding another tkr field, rename this one to
    tkr_mono. Also rename tk_read_base::base_mono to tk_read_base::base,
    since the structure is not specific to CLOCK_MONOTONIC and the mono
    name got added to the tk_read_base instance.
    
    Lots of trivial churn.
    
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Acked-by: John Stultz <john.stultz@linaro.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/20150319093400.344679419@infradead.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 1809bfa44e1019e397fabaa6f2349bb7237e57a4
Author: Daniel Thompson <daniel.thompson@linaro.org>
Date:   Thu Mar 26 12:23:26 2015 -0700

    timers, sched/clock: Avoid deadlock during read from NMI
    
    Currently it is possible for an NMI (or FIQ on ARM) to come in
    and read sched_clock() whilst update_sched_clock() has locked
    the seqcount for writing. This results in the NMI handler
    locking up when it calls raw_read_seqcount_begin().
    
    This patch fixes the NMI safety issues by providing banked clock
    data. This is a similar approach to the one used in Thomas
    Gleixner's 4396e058c52e("timekeeping: Provide fast and NMI safe
    access to CLOCK_MONOTONIC").
    
    Suggested-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Daniel Thompson <daniel.thompson@linaro.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Reviewed-by: Stephen Boyd <sboyd@codeaurora.org>
    Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Will Deacon <will.deacon@arm.com>
    Link: http://lkml.kernel.org/r/1427397806-20889-6-git-send-email-john.stultz@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 51f91cbdf5450b773eb221a2dfd141a92413370e
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Mar 11 17:40:02 2015 -0700

    selftests/timers: Add clock skew estimation test from timetest suite
    
    This adds my clock skew estimation test from the timetest suite.
    It measures the drift between CLOCK_MONOTONIC and CLOCK_MONOTONIC_RAW
    and compares it with the current frequency value from adjtimex.
    
    It sometimes can trigger false failures when ntpd isn't in a
    steady state, but its a useful too when doing adjtimex testing.
    
    Cc: Shuah Khan <shuahkh@osg.samsung.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Tested-by: Prarit Bhargava <prarit@redhat.com>
    Signed-off-by: Shuah Khan <shuahkh@osg.samsung.com>

commit 66c3bfca4b105382dbd84118a5aa0a9664d8549a
Author: David Hildenbrand <dahi@linux.vnet.ibm.com>
Date:   Thu Dec 11 10:18:01 2014 +0100

    KVM: s390: forward hrtimer if guest ckc not pending yet
    
    commit 2d00f759427bb3ed963b60f570830e9eca7e1c69 upstream.
    
    Patch 0759d0681cae ("KVM: s390: cleanup handle_wait by reusing
    kvm_vcpu_block") changed the way pending guest clock comparator
    interrupts are detected. It was assumed that as soon as the hrtimer
    wakes up, the condition for the guest ckc is satisfied.
    
    This is however only true as long as adjclock() doesn't speed
    up the monotonic clock. Reason is that the hrtimer is based on
    CLOCK_MONOTONIC, the guest clock comparator detection is based
    on the raw TOD clock. If CLOCK_MONOTONIC runs faster than the
    TOD clock, the hrtimer wakes the target VCPU up too early and
    the target VCPU will not detect any pending interrupts, therefore
    going back to sleep. It will never be woken up again because the
    hrtimer has finished. The VCPU is stuck.
    
    As a quick fix, we have to forward the hrtimer until the guest
    clock comparator is really due, to guarantee properly timed wake
    ups.
    
    As the hrtimer callback might be triggered on another cpu, we
    have to make sure that the timer is really stopped and not currently
    executing the callback on another cpu. This can happen if the vcpu
    thread is scheduled onto another physical cpu, but the timer base
    is not migrated. So lets use hrtimer_cancel instead of try_to_cancel.
    
    A proper fix might be to introduce a RAW based hrtimer.
    
    Reported-by: Christian Borntraeger <borntraeger@de.ibm.com>
    Signed-off-by: David Hildenbrand <dahi@linux.vnet.ibm.com>
    Acked-by: Cornelia Huck <cornelia.huck@de.ibm.com>
    Signed-off-by: Christian Borntraeger <borntraeger@de.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit ed9eb2855071faa632c8e04c6cbe3a11c086aa5b
Author: David Hildenbrand <dahi@linux.vnet.ibm.com>
Date:   Thu Dec 11 10:18:01 2014 +0100

    KVM: s390: forward hrtimer if guest ckc not pending yet
    
    commit 2d00f759427bb3ed963b60f570830e9eca7e1c69 upstream.
    
    Patch 0759d0681cae ("KVM: s390: cleanup handle_wait by reusing
    kvm_vcpu_block") changed the way pending guest clock comparator
    interrupts are detected. It was assumed that as soon as the hrtimer
    wakes up, the condition for the guest ckc is satisfied.
    
    This is however only true as long as adjclock() doesn't speed
    up the monotonic clock. Reason is that the hrtimer is based on
    CLOCK_MONOTONIC, the guest clock comparator detection is based
    on the raw TOD clock. If CLOCK_MONOTONIC runs faster than the
    TOD clock, the hrtimer wakes the target VCPU up too early and
    the target VCPU will not detect any pending interrupts, therefore
    going back to sleep. It will never be woken up again because the
    hrtimer has finished. The VCPU is stuck.
    
    As a quick fix, we have to forward the hrtimer until the guest
    clock comparator is really due, to guarantee properly timed wake
    ups.
    
    As the hrtimer callback might be triggered on another cpu, we
    have to make sure that the timer is really stopped and not currently
    executing the callback on another cpu. This can happen if the vcpu
    thread is scheduled onto another physical cpu, but the timer base
    is not migrated. So lets use hrtimer_cancel instead of try_to_cancel.
    
    A proper fix might be to introduce a RAW based hrtimer.
    
    Reported-by: Christian Borntraeger <borntraeger@de.ibm.com>
    Signed-off-by: David Hildenbrand <dahi@linux.vnet.ibm.com>
    Acked-by: Cornelia Huck <cornelia.huck@de.ibm.com>
    Signed-off-by: Christian Borntraeger <borntraeger@de.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit fef76eabdf6f5bd033de2353f27dccbeea60c066
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Feb 4 16:45:26 2015 -0800

    hrtimer: Fix incorrect tai offset calculation for non high-res timer systems
    
    commit 2d926c15d629a13914ce3e5f26354f6a0ac99e70 upstream.
    
    I noticed some CLOCK_TAI timer test failures on one of my
    less-frequently used configurations. And after digging in I
    found in 76f4108892d9 (Cleanup hrtimer accessors to the
    timekepeing state), the hrtimer_get_softirq_time tai offset
    calucation was incorrectly rewritten, as the tai offset we
    return shold be from CLOCK_MONOTONIC, and not CLOCK_REALTIME.
    
    This results in CLOCK_TAI timers expiring early on non-highres
    capable machines.
    
    This patch fixes the issue, calculating the tai time properly
    from the monotonic base.
    
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/1423097126-10236-1-git-send-email-john.stultz@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 2d926c15d629a13914ce3e5f26354f6a0ac99e70
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Feb 4 16:45:26 2015 -0800

    hrtimer: Fix incorrect tai offset calculation for non high-res timer systems
    
    I noticed some CLOCK_TAI timer test failures on one of my
    less-frequently used configurations. And after digging in I
    found in 76f4108892d9 (Cleanup hrtimer accessors to the
    timekepeing state), the hrtimer_get_softirq_time tai offset
    calucation was incorrectly rewritten, as the tai offset we
    return shold be from CLOCK_MONOTONIC, and not CLOCK_REALTIME.
    
    This results in CLOCK_TAI timers expiring early on non-highres
    capable machines.
    
    This patch fixes the issue, calculating the tai time properly
    from the monotonic base.
    
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable <stable@vger.kernel.org> # 3.17+
    Link: http://lkml.kernel.org/r/1423097126-10236-1-git-send-email-john.stultz@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 2d00f759427bb3ed963b60f570830e9eca7e1c69
Author: David Hildenbrand <dahi@linux.vnet.ibm.com>
Date:   Thu Dec 11 10:18:01 2014 +0100

    KVM: s390: forward hrtimer if guest ckc not pending yet
    
    Patch 0759d0681cae ("KVM: s390: cleanup handle_wait by reusing
    kvm_vcpu_block") changed the way pending guest clock comparator
    interrupts are detected. It was assumed that as soon as the hrtimer
    wakes up, the condition for the guest ckc is satisfied.
    
    This is however only true as long as adjclock() doesn't speed
    up the monotonic clock. Reason is that the hrtimer is based on
    CLOCK_MONOTONIC, the guest clock comparator detection is based
    on the raw TOD clock. If CLOCK_MONOTONIC runs faster than the
    TOD clock, the hrtimer wakes the target VCPU up too early and
    the target VCPU will not detect any pending interrupts, therefore
    going back to sleep. It will never be woken up again because the
    hrtimer has finished. The VCPU is stuck.
    
    As a quick fix, we have to forward the hrtimer until the guest
    clock comparator is really due, to guarantee properly timed wake
    ups.
    
    As the hrtimer callback might be triggered on another cpu, we
    have to make sure that the timer is really stopped and not currently
    executing the callback on another cpu. This can happen if the vcpu
    thread is scheduled onto another physical cpu, but the timer base
    is not migrated. So lets use hrtimer_cancel instead of try_to_cancel.
    
    A proper fix might be to introduce a RAW based hrtimer.
    
    Reported-by: Christian Borntraeger <borntraeger@de.ibm.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: David Hildenbrand <dahi@linux.vnet.ibm.com>
    Acked-by: Cornelia Huck <cornelia.huck@de.ibm.com>
    Signed-off-by: Christian Borntraeger <borntraeger@de.ibm.com>

commit 9bc7491906b4113b4c5ae442157c7dfc4e10cd14
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jan 20 21:24:10 2015 +0100

    hrtimer: Prevent stale expiry time in hrtimer_interrupt()
    
    hrtimer_interrupt() has the following subtle issue:
    
    hrtimer_interrupt()
      lock(cpu_base);
      expires_next = KTIME_MAX;
    
      expire_timers(CLOCK_MONOTONIC);
      expires = get_next_timer(CLOCK_MONOTONIC);
      if (expires < expires_next)
        expires_next = expires;
    
      expire_timers(CLOCK_REALTIME);
        unlock(cpu_base);
        wakeup()
        hrtimer_start(CLOCK_MONOTONIC, newtimer);
        lock(cpu_base();
      expires = get_next_timer(CLOCK_REALTIME);
      if (expires < expires_next)
        expires_next = expires;
    
    So because we already evaluated the next expiring timer of
    CLOCK_MONOTONIC we ignore that the expiry time of newtimer might be
    earlier than the overall next expiry time in hrtimer_interrupt().
    
    To solve this, remove the caching of the next expiry value from
    hrtimer_interrupt() and reevaluate all active clock bases for the next
    expiry value. To avoid another code duplication, create a shared
    evaluation function and use it for hrtimer_get_next_event(),
    hrtimer_force_reprogram() and hrtimer_interrupt().
    
    There is another subtlety in this mechanism:
    
    While hrtimer_interrupt() is running, we want to avoid to touch the
    hardware device because we will reprogram it anyway at the end of
    hrtimer_interrupt(). This works nicely for hrtimers which get rearmed
    via the HRTIMER_RESTART mechanism, because we drop out when the
    callback on that CPU is running. But that fails, if a new timer gets
    enqueued like in the example above.
    
    This has another implication: While hrtimer_interrupt() is running we
    refuse remote enqueueing of timers - see hrtimer_interrupt() and
    hrtimer_check_target().
    
    hrtimer_interrupt() tries to prevent this by setting cpu_base->expires
    to KTIME_MAX, but that fails if a new timer gets queued.
    
    Prevent both the hardware access and the remote enqueue
    explicitely. We can loosen the restriction on the remote enqueue now
    due to reevaluation of the next expiry value, but that needs a
    seperate patch.
    
    Folded in a fix from Vignesh Radhakrishnan.
    
    Reported-and-tested-by: Stanislav Fomichev <stfomichev@yandex-team.ru>
    Based-on-patch-by: Stanislav Fomichev <stfomichev@yandex-team.ru>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: vigneshr@codeaurora.org
    Cc: john.stultz@linaro.org
    Cc: viresh.kumar@linaro.org
    Cc: fweisbec@gmail.com
    Cc: cl@linux.com
    Cc: stuart.w.hayes@gmail.com
    Link: http://lkml.kernel.org/r/alpine.DEB.2.11.1501202049190.5526@nanos
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit d82012695ef29e4e1c8153ccf43098ec8e50369e
Merge: 3eb5b893ebec dbe7aa622db9
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Dec 10 10:13:28 2014 -0800

    Merge branch 'timers-2038-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull more 2038 timer work from Thomas Gleixner:
     "Two more patches for the ongoing 2038 work:
    
       - New accessors to clock MONOTONIC and REALTIME seconds
    
      This is a seperate branch as Arnd has follow up work depending on
      this"
    
    * 'timers-2038-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      timekeeping: Provide y2038 safe accessor to the seconds portion of CLOCK_REALTIME
      timekeeping: Provide fast accessor to the seconds part of CLOCK_MONOTONIC

commit 9e3680b1750b9a62680b0262c9f438de98b77655
Author: Heena Sirwani <heenasirwani@gmail.com>
Date:   Wed Oct 29 16:01:16 2014 +0530

    timekeeping: Provide fast accessor to the seconds part of CLOCK_MONOTONIC
    
    This is the counterpart to get_seconds() based on CLOCK_MONOTONIC. The
    use case for this interface are kernel internal coarse grained
    timestamps which do neither require the nanoseconds fraction of
    current time nor the CLOCK_REALTIME properties. Such timestamps can
    currently only retrieved by calling ktime_get_ts64() and using the
    tv_sec field of the returned timespec64. That's inefficient as it
    involves the read of the clocksource, math operations and must be
    protected by the timekeeper sequence counter.
    
    To avoid the sequence counter protection we restrict the return value
    to unsigned 32bit on 32bit machines. This covers ~136 years of uptime
    and therefor an overflow is not expected to hit anytime soon.
    
    To avoid math in the function we calculate the current seconds portion
    of CLOCK_MONOTONIC when the timekeeper gets updated in
    tk_update_ktime_data() similar to the CLOCK_REALTIME counterpart
    xtime_sec.
    
    [ tglx: Massaged changelog, simplified and commented the update
            function, added docbook comment ]
    
    Signed-off-by: Heena Sirwani <heenasirwani@gmail.com>
    Reviewed-by: Arnd Bergman <arnd@arndb.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: opw-kernel@googlegroups.com
    Link: http://lkml.kernel.org/r/da0b63f4bdf3478909f92becb35861197da3a905.1414578445.git.heenasirwani@gmail.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 78410af51146796f783925009c8676a30d6c6d90
Author: Chris Metcalf <cmetcalf@tilera.com>
Date:   Thu Oct 2 10:32:15 2014 -0400

    tile: add clock_gettime support to vDSO
    
    This change adds support for clock_gettime with CLOCK_REALTIME
    and CLOCK_MONOTONIC using vDSO.  It also updates the vdso
    struct nomenclature used for the clocks to match the x86 code
    to keep it easier to update going forward.
    
    We also support the *_COARSE clockid_t, for apps that want speed
    but aren't concerned about fine-grained timestamps; this saves
    about 20 cycles per call (see http://lwn.net/Articles/342018/).
    
    Signed-off-by: Chris Metcalf <cmetcalf@tilera.com>
    Acked-by: John Stultz <john.stultz@linaro.org>

commit b7eacb59cd7fb5e98852186e485c0c865f862645
Author: Martin Schwidefsky <schwidefsky@de.ibm.com>
Date:   Fri Aug 29 12:31:45 2014 +0200

    s390/vdso: add vdso support for coarse clocks
    
    Add CLOCK_REALTIME_COARSE and CLOCK_MONOTONIC_COARSE optimization to
    the 64-bit and 31-bit vdso.
    
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

commit e7fda6c4c3c1a7d6996dd75fd84670fa0b5d448f
Merge: 08d69a257144 953dec21aed4
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Aug 5 17:46:42 2014 -0700

    Merge branch 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer and time updates from Thomas Gleixner:
     "A rather large update of timers, timekeeping & co
    
       - Core timekeeping code is year-2038 safe now for 32bit machines.
         Now we just need to fix all in kernel users and the gazillion of
         user space interfaces which rely on timespec/timeval :)
    
       - Better cache layout for the timekeeping internal data structures.
    
       - Proper nanosecond based interfaces for in kernel users.
    
       - Tree wide cleanup of code which wants nanoseconds but does hoops
         and loops to convert back and forth from timespecs.  Some of it
         definitely belongs into the ugly code museum.
    
       - Consolidation of the timekeeping interface zoo.
    
       - A fast NMI safe accessor to clock monotonic for tracing.  This is a
         long standing request to support correlated user/kernel space
         traces.  With proper NTP frequency correction it's also suitable
         for correlation of traces accross separate machines.
    
       - Checkpoint/restart support for timerfd.
    
       - A few NOHZ[_FULL] improvements in the [hr]timer code.
    
       - Code move from kernel to kernel/time of all time* related code.
    
       - New clocksource/event drivers from the ARM universe.  I'm really
         impressed that despite an architected timer in the newer chips SoC
         manufacturers insist on inventing new and differently broken SoC
         specific timers.
    
    [ Ed. "Impressed"? I don't think that word means what you think it means ]
    
       - Another round of code move from arch to drivers.  Looks like most
         of the legacy mess in ARM regarding timers is sorted out except for
         a few obnoxious strongholds.
    
       - The usual updates and fixlets all over the place"
    
    * 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (114 commits)
      timekeeping: Fixup typo in update_vsyscall_old definition
      clocksource: document some basic timekeeping concepts
      timekeeping: Use cached ntp_tick_length when accumulating error
      timekeeping: Rework frequency adjustments to work better w/ nohz
      timekeeping: Minor fixup for timespec64->timespec assignment
      ftrace: Provide trace clocks monotonic
      timekeeping: Provide fast and NMI safe access to CLOCK_MONOTONIC
      seqcount: Add raw_write_seqcount_latch()
      seqcount: Provide raw_read_seqcount()
      timekeeping: Use tk_read_base as argument for timekeeping_get_ns()
      timekeeping: Create struct tk_read_base and use it in struct timekeeper
      timekeeping: Restructure the timekeeper some more
      clocksource: Get rid of cycle_last
      clocksource: Move cycle_last validation to core code
      clocksource: Make delta calculation a function
      wireless: ath9k: Get rid of timespec conversions
      drm: vmwgfx: Use nsec based interfaces
      drm: i915: Use nsec based interfaces
      timekeeping: Provide ktime_get_raw()
      hangcheck-timer: Use ktime_get_ns()
      ...

commit 4396e058c52e167729729cf64ea3dfa229637086
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Jul 16 21:05:23 2014 +0000

    timekeeping: Provide fast and NMI safe access to CLOCK_MONOTONIC
    
    Tracers want a correlated time between the kernel instrumentation and
    user space. We really do not want to export sched_clock() to user
    space, so we need to provide something sensible for this.
    
    Using separate data structures with an non blocking sequence count
    based update mechanism allows us to do that. The data structure
    required for the readout has a sequence counter and two copies of the
    timekeeping data.
    
    On the update side:
    
      smp_wmb();
      tkf->seq++;
      smp_wmb();
      update(tkf->base[0], tk);
      smp_wmb();
      tkf->seq++;
      smp_wmb();
      update(tkf->base[1], tk);
    
    On the reader side:
    
      do {
         seq = tkf->seq;
         smp_rmb();
         idx = seq & 0x01;
         now = now(tkf->base[idx]);
         smp_rmb();
      } while (seq != tkf->seq)
    
    So if a NMI hits the update of base[0] it will use base[1] which is
    still consistent, but this timestamp is not guaranteed to be monotonic
    across an update.
    
    The timestamp is calculated by:
    
            now = base_mono + clock_delta * slope
    
    So if the update lowers the slope, readers who are forced to the
    not yet updated second array are still using the old steeper slope.
    
     tmono
     ^
     |    o  n
     |   o n
     |  u
     | o
     |o
     |12345678---> reader order
    
     o = old slope
     u = update
     n = new slope
    
    So reader 6 will observe time going backwards versus reader 5.
    
    While other CPUs are likely to be able observe that, the only way
    for a CPU local observation is when an NMI hits in the middle of
    the update. Timestamps taken from that NMI context might be ahead
    of the following timestamps. Callers need to be aware of that and
    deal with it.
    
    V2: Got rid of clock monotonic raw and reorganized the data
        structures. Folded in the barrier fix from Mathieu.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 2044fdb03eb4e511d5028be0917899931f17461f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Jul 16 21:05:03 2014 +0000

    hangcheck-timer: Use ktime_get_ns()
    
    There is no point in having a S390 private implementation and there is
    no point in using the raw monotonic time. The NTP freqeuency
    adjustment of CLOCK_MONOTONIC is really not doing any harm for the
    hang check timer.
    
    Use ktime_get_ns() for everything and get rid of the timespec
    conversions.
    
    V2: Drop the raw monotonic and the S390 special case
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 0ac8a52d4541adc284a4f3e8a1f6847236de1d8a
Author: Mark Brown <broonie@linaro.org>
Date:   Tue Jul 8 16:51:49 2014 +0200

    ALSA: Provide a CLOCK_MONOTONIC_RAW timestamp type
    
    For applications which need to synchronise with external timebases such
    as broadcast TV applications the kernel monotonic time is not optimal as
    it includes adjustments from NTP and so may still include discontinuities
    due to that. A raw monotonic time which does not include any adjustments
    is available in the kernel from getrawmonotonic() so provide userspace with
    a new timestamp type SNDRV_PCM_TSTAMP_TYPE_MONOTONIC_RAW which provides
    timestamps based on this as an option.
    
    [dropped tstamp_type assignment code, as it's no longer needed -- tiwai]
    
    Reported-by: Daniel Thompson <daniel.thompson@linaro.org>
    Signed-off-by: Mark Brown <broonie@linaro.org>
    Acked-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

commit f01b3751f964df3266ed9e52b1676ff52a91b60f
Author: Martin Schwidefsky <schwidefsky@de.ibm.com>
Date:   Mon Dec 2 18:00:36 2013 +0100

    s390/time,vdso: fix clock_gettime for CLOCK_MONOTONIC
    
    commit ca5de58ba746b08c920b2024aaf01aa1500b110d upstream.
    
    With git commit 79c74ecbebf76732f91b82a62ce7fc8a88326962
    "s390/time,vdso: convert to the new update_vsyscall interface"
    the new update_vsyscall function already does the sum of xtime
    and wall_to_monotonic. The old update_vsyscall function only
    copied the wall_to_monotonic offset. The vdso code needs to be
    modified to take this into consideration.
    
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>

commit d8cec633b0488655ac324684d4cf53e312bcdf41
Author: Nathan Lynch <nathan_lynch@mentor.com>
Date:   Wed Feb 5 05:53:04 2014 +0000

    arm64: vdso: fix coarse clock handling
    
    commit 069b918623e1510e58dacf178905a72c3baa3ae4 upstream.
    
    When __kernel_clock_gettime is called with a CLOCK_MONOTONIC_COARSE or
    CLOCK_REALTIME_COARSE clock id, it returns incorrectly to whatever the
    caller has placed in x2 ("ret x2" to return from the fast path).  Fix
    this by saving x30/LR to x2 only in code that will call
    __do_get_tspec, restoring x30 afterward, and using a plain "ret" to
    return from the routine.
    
    Also: while the resulting tv_nsec value for CLOCK_REALTIME and
    CLOCK_MONOTONIC must be computed using intermediate values that are
    left-shifted by cs_shift (x12, set by __do_get_tspec), the results for
    coarse clocks should be calculated using unshifted values
    (xtime_coarse_nsec is in units of actual nanoseconds).  The current
    code shifts intermediate values by x12 unconditionally, but x12 is
    uninitialized when servicing a coarse clock.  Fix this by setting x12
    to 0 once we know we are dealing with a coarse clock id.
    
    Signed-off-by: Nathan Lynch <nathan_lynch@mentor.com>
    Acked-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 7401d60f4100e372bb401e4f1e977967b7ca560a
Author: Nathan Lynch <nathan_lynch@mentor.com>
Date:   Mon Feb 3 19:48:52 2014 +0000

    arm64: vdso: update wtm fields for CLOCK_MONOTONIC_COARSE
    
    commit d4022a335271a48cce49df35d825897914fbffe3 upstream.
    
    Update wall-to-monotonic fields in the VDSO data page
    unconditionally.  These are used to service CLOCK_MONOTONIC_COARSE,
    which is not guarded by use_syscall.
    
    Signed-off-by: Nathan Lynch <nathan_lynch@mentor.com>
    Acked-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 61cdf59100deb76fc299ee8ad1fb4c9cda4ce011
Author: Nathan Lynch <nathan_lynch@mentor.com>
Date:   Wed Feb 5 05:53:04 2014 +0000

    arm64: vdso: fix coarse clock handling
    
    commit 069b918623e1510e58dacf178905a72c3baa3ae4 upstream.
    
    When __kernel_clock_gettime is called with a CLOCK_MONOTONIC_COARSE or
    CLOCK_REALTIME_COARSE clock id, it returns incorrectly to whatever the
    caller has placed in x2 ("ret x2" to return from the fast path).  Fix
    this by saving x30/LR to x2 only in code that will call
    __do_get_tspec, restoring x30 afterward, and using a plain "ret" to
    return from the routine.
    
    Also: while the resulting tv_nsec value for CLOCK_REALTIME and
    CLOCK_MONOTONIC must be computed using intermediate values that are
    left-shifted by cs_shift (x12, set by __do_get_tspec), the results for
    coarse clocks should be calculated using unshifted values
    (xtime_coarse_nsec is in units of actual nanoseconds).  The current
    code shifts intermediate values by x12 unconditionally, but x12 is
    uninitialized when servicing a coarse clock.  Fix this by setting x12
    to 0 once we know we are dealing with a coarse clock id.
    
    Signed-off-by: Nathan Lynch <nathan_lynch@mentor.com>
    Acked-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 9594784323553039e7ffbbb16b936fe49f1c3499
Author: Nathan Lynch <nathan_lynch@mentor.com>
Date:   Mon Feb 3 19:48:52 2014 +0000

    arm64: vdso: update wtm fields for CLOCK_MONOTONIC_COARSE
    
    commit d4022a335271a48cce49df35d825897914fbffe3 upstream.
    
    Update wall-to-monotonic fields in the VDSO data page
    unconditionally.  These are used to service CLOCK_MONOTONIC_COARSE,
    which is not guarded by use_syscall.
    
    Signed-off-by: Nathan Lynch <nathan_lynch@mentor.com>
    Acked-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit fb569d15d867a06e89b1be8278404b6fbf6b5bde
Author: Nathan Lynch <nathan_lynch@mentor.com>
Date:   Wed Feb 5 05:53:04 2014 +0000

    arm64: vdso: fix coarse clock handling
    
    commit 069b918623e1510e58dacf178905a72c3baa3ae4 upstream.
    
    When __kernel_clock_gettime is called with a CLOCK_MONOTONIC_COARSE or
    CLOCK_REALTIME_COARSE clock id, it returns incorrectly to whatever the
    caller has placed in x2 ("ret x2" to return from the fast path).  Fix
    this by saving x30/LR to x2 only in code that will call
    __do_get_tspec, restoring x30 afterward, and using a plain "ret" to
    return from the routine.
    
    Also: while the resulting tv_nsec value for CLOCK_REALTIME and
    CLOCK_MONOTONIC must be computed using intermediate values that are
    left-shifted by cs_shift (x12, set by __do_get_tspec), the results for
    coarse clocks should be calculated using unshifted values
    (xtime_coarse_nsec is in units of actual nanoseconds).  The current
    code shifts intermediate values by x12 unconditionally, but x12 is
    uninitialized when servicing a coarse clock.  Fix this by setting x12
    to 0 once we know we are dealing with a coarse clock id.
    
    Signed-off-by: Nathan Lynch <nathan_lynch@mentor.com>
    Acked-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit b666f382900c74f23c78556777041c2ceb7c2b24
Author: Nathan Lynch <nathan_lynch@mentor.com>
Date:   Mon Feb 3 19:48:52 2014 +0000

    arm64: vdso: update wtm fields for CLOCK_MONOTONIC_COARSE
    
    commit d4022a335271a48cce49df35d825897914fbffe3 upstream.
    
    Update wall-to-monotonic fields in the VDSO data page
    unconditionally.  These are used to service CLOCK_MONOTONIC_COARSE,
    which is not guarded by use_syscall.
    
    Signed-off-by: Nathan Lynch <nathan_lynch@mentor.com>
    Acked-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 42be3f35a3ef0b64af80394afc5873aa5cf70871
Merge: d94d0e273eec 55834a773fe3
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Feb 7 12:19:50 2014 -0800

    Merge tag 'arm64-fixes' of git://git.kernel.org/pub/scm/linux/kernel/git/arm64/linux
    
    Pull arm64 fixes from Catalin Marinas:
     - Relax VDSO alignment requirements so that the kernel-picked one (4K)
       does not conflict with the dynamic linker's one (64K)
     - VDSO gettimeofday fix
     - Barrier fixes for atomic operations and cache flushing
     - TLB invalidation when overriding early page mappings during boot
     - Wired up new 32-bit arm (compat) syscalls
     - LSM_MMAP_MIN_ADDR when COMPAT is enabled
     - defconfig update
     - Clean-up (comments, pgd_alloc).
    
    * tag 'arm64-fixes' of git://git.kernel.org/pub/scm/linux/kernel/git/arm64/linux:
      arm64: defconfig: Expand default enabled features
      arm64: asm: remove redundant "cc" clobbers
      arm64: atomics: fix use of acquire + release for full barrier semantics
      arm64: barriers: allow dsb macro to take option parameter
      security: select correct default LSM_MMAP_MIN_ADDR on arm on arm64
      arm64: compat: Wire up new AArch32 syscalls
      arm64: vdso: update wtm fields for CLOCK_MONOTONIC_COARSE
      arm64: vdso: fix coarse clock handling
      arm64: simplify pgd_alloc
      arm64: fix typo: s/SERRROR/SERROR/
      arm64: Invalidate the TLB when replacing pmd entries during boot
      arm64: Align CMA sizes to PAGE_SIZE
      arm64: add DSB after icache flush in __flush_icache_all()
      arm64: vdso: prevent ld from aligning PT_LOAD segments to 64k

commit d4022a335271a48cce49df35d825897914fbffe3
Author: Nathan Lynch <nathan_lynch@mentor.com>
Date:   Mon Feb 3 19:48:52 2014 +0000

    arm64: vdso: update wtm fields for CLOCK_MONOTONIC_COARSE
    
    Update wall-to-monotonic fields in the VDSO data page
    unconditionally.  These are used to service CLOCK_MONOTONIC_COARSE,
    which is not guarded by use_syscall.
    
    Signed-off-by: Nathan Lynch <nathan_lynch@mentor.com>
    Acked-by: Will Deacon <will.deacon@arm.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>

commit 069b918623e1510e58dacf178905a72c3baa3ae4
Author: Nathan Lynch <nathan_lynch@mentor.com>
Date:   Wed Feb 5 05:53:04 2014 +0000

    arm64: vdso: fix coarse clock handling
    
    When __kernel_clock_gettime is called with a CLOCK_MONOTONIC_COARSE or
    CLOCK_REALTIME_COARSE clock id, it returns incorrectly to whatever the
    caller has placed in x2 ("ret x2" to return from the fast path).  Fix
    this by saving x30/LR to x2 only in code that will call
    __do_get_tspec, restoring x30 afterward, and using a plain "ret" to
    return from the routine.
    
    Also: while the resulting tv_nsec value for CLOCK_REALTIME and
    CLOCK_MONOTONIC must be computed using intermediate values that are
    left-shifted by cs_shift (x12, set by __do_get_tspec), the results for
    coarse clocks should be calculated using unshifted values
    (xtime_coarse_nsec is in units of actual nanoseconds).  The current
    code shifts intermediate values by x12 unconditionally, but x12 is
    uninitialized when servicing a coarse clock.  Fix this by setting x12
    to 0 once we know we are dealing with a coarse clock id.
    
    Signed-off-by: Nathan Lynch <nathan_lynch@mentor.com>
    Acked-by: Will Deacon <will.deacon@arm.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>

commit 22056614ee39ef43670814d2000f810901768277
Merge: 17b2112f332d ca5de58ba746
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Dec 10 11:02:33 2013 -0800

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/s390/linux
    
    Pull s390 fixes from Martin Schwidefsky:
     "One patch to increase the number of possible CPUs to 256, with the
      latest machine a single LPAR can have up to 101 CPUs.  Plus a number
      of bug fixes, the clock_gettime patch fixes a regression added in the
      3.13 merge window"
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/s390/linux:
      s390/time,vdso: fix clock_gettime for CLOCK_MONOTONIC
      s390/vdso: ectg gettime support for CLOCK_THREAD_CPUTIME_ID
      s390/vdso: fix access-list entry initialization
      s390: increase CONFIG_NR_CPUS limit
      s390/smp,sclp: fix size of sclp_cpu_info structure
      s390/sclp: replace uninitialized early_event_mask_sccb variable with sccb_early
      s390/dasd: fix memory leak caused by dangling references to request_queue

commit ca5de58ba746b08c920b2024aaf01aa1500b110d
Author: Martin Schwidefsky <schwidefsky@de.ibm.com>
Date:   Mon Dec 2 18:00:36 2013 +0100

    s390/time,vdso: fix clock_gettime for CLOCK_MONOTONIC
    
    With git commit 79c74ecbebf76732f91b82a62ce7fc8a88326962
    "s390/time,vdso: convert to the new update_vsyscall interface"
    the new update_vsyscall function already does the sum of xtime
    and wall_to_monotonic. The old update_vsyscall function only
    copied the wall_to_monotonic offset. The vdso code needs to be
    modified to take this into consideration.
    
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

commit 1d940aaab881b0ee62557ffbaad877ac5a1b51db
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Mon Nov 18 17:23:26 2013 +0100

    mac80211_hwsim: use CLOCK_MONOTONIC_RAW
    
    The beacon timers really shouldn't use any clock that is
    subject to adjustments from userspace, particularly not
    CLOCK_REALTIME. Use CLOCK_MONOTONIC_RAW instead.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

commit 4dfc47d29210411ed765ce966c580c5b41e32841
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Apr 6 10:10:27 2013 +0200

    sched_clock: Prevent 64bit inatomicity on 32bit systems
    
    commit a1cbcaa9ea87b87a96b9fc465951dcf36e459ca2 upstream.
    
    The sched_clock_remote() implementation has the following inatomicity
    problem on 32bit systems when accessing the remote scd->clock, which
    is a 64bit value.
    
    CPU0                    CPU1
    
    sched_clock_local()     sched_clock_remote(CPU0)
    ...
                            remote_clock = scd[CPU0]->clock
                                read_low32bit(scd[CPU0]->clock)
    cmpxchg64(scd->clock,...)
                                read_high32bit(scd[CPU0]->clock)
    
    While the update of scd->clock is using an atomic64 mechanism, the
    readout on the remote cpu is not, which can cause completely bogus
    readouts.
    
    It is a quite rare problem, because it requires the update to hit the
    narrow race window between the low/high readout and the update must go
    across the 32bit boundary.
    
    The resulting misbehaviour is, that CPU1 will see the sched_clock on
    CPU1 ~4 seconds ahead of it's own and update CPU1s sched_clock value
    to this bogus timestamp. This stays that way due to the clamping
    implementation for about 4 seconds until the synchronization with
    CLOCK_MONOTONIC undoes the problem.
    
    The issue is hard to observe, because it might only result in a less
    accurate SCHED_OTHER timeslicing behaviour. To create observable
    damage on realtime scheduling classes, it is necessary that the bogus
    update of CPU1 sched_clock happens in the context of an realtime
    thread, which then gets charged 4 seconds of RT runtime, which results
    in the RT throttler mechanism to trigger and prevent scheduling of RT
    tasks for a little less than 4 seconds. So this is quite unlikely as
    well.
    
    The issue was quite hard to decode as the reproduction time is between
    2 days and 3 weeks and intrusive tracing makes it less likely, but the
    following trace recorded with trace_clock=global, which uses
    sched_clock_local(), gave the final hint:
    
      <idle>-0   0d..30 400269.477150: hrtimer_cancel: hrtimer=0xf7061e80
      <idle>-0   0d..30 400269.477151: hrtimer_start:  hrtimer=0xf7061e80 ...
    irq/20-S-587 1d..32 400273.772118: sched_wakeup:   comm= ... target_cpu=0
      <idle>-0   0dN.30 400273.772118: hrtimer_cancel: hrtimer=0xf7061e80
    
    What happens is that CPU0 goes idle and invokes
    sched_clock_idle_sleep_event() which invokes sched_clock_local() and
    CPU1 runs a remote wakeup for CPU0 at the same time, which invokes
    sched_remote_clock(). The time jump gets propagated to CPU0 via
    sched_remote_clock() and stays stale on both cores for ~4 seconds.
    
    There are only two other possibilities, which could cause a stale
    sched clock:
    
    1) ktime_get() which reads out CLOCK_MONOTONIC returns a sporadic
       wrong value.
    
    2) sched_clock() which reads the TSC returns a sporadic wrong value.
    
    #1 can be excluded because sched_clock would continue to increase for
       one jiffy and then go stale.
    
    #2 can be excluded because it would not make the clock jump
       forward. It would just result in a stale sched_clock for one jiffy.
    
    After quite some brain twisting and finding the same pattern on other
    traces, sched_clock_remote() remained the only place which could cause
    such a problem and as explained above it's indeed racy on 32bit
    systems.
    
    So while on 64bit systems the readout is atomic, we need to verify the
    remote readout on 32bit machines. We need to protect the local->clock
    readout in sched_clock_remote() on 32bit as well because an NMI could
    hit between the low and the high readout, call sched_clock_local() and
    modify local->clock.
    
    Thanks to Siegfried Wulsch for bearing with my debug requests and
    going through the tedious tasks of running a bunch of reproducer
    systems to generate the debug information which let me decode the
    issue.
    
    Reported-by: Siegfried Wulsch <Siegfried.Wulsch@rovema.de>
    Acked-by: Peter Zijlstra <peterz@infradead.org>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Link: http://lkml.kernel.org/r/alpine.LFD.2.02.1304051544160.21884@ionos
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    [bwh: Backported to 3.2: adjust filename]
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit 092c48c05b0b25fdfca630441f34fd99b83deb1c
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Apr 6 10:10:27 2013 +0200

    sched_clock: Prevent 64bit inatomicity on 32bit systems
    
    commit a1cbcaa9ea87b87a96b9fc465951dcf36e459ca2 upstream.
    
    The sched_clock_remote() implementation has the following inatomicity
    problem on 32bit systems when accessing the remote scd->clock, which
    is a 64bit value.
    
    CPU0                    CPU1
    
    sched_clock_local()     sched_clock_remote(CPU0)
    ...
                            remote_clock = scd[CPU0]->clock
                                read_low32bit(scd[CPU0]->clock)
    cmpxchg64(scd->clock,...)
                                read_high32bit(scd[CPU0]->clock)
    
    While the update of scd->clock is using an atomic64 mechanism, the
    readout on the remote cpu is not, which can cause completely bogus
    readouts.
    
    It is a quite rare problem, because it requires the update to hit the
    narrow race window between the low/high readout and the update must go
    across the 32bit boundary.
    
    The resulting misbehaviour is, that CPU1 will see the sched_clock on
    CPU1 ~4 seconds ahead of it's own and update CPU1s sched_clock value
    to this bogus timestamp. This stays that way due to the clamping
    implementation for about 4 seconds until the synchronization with
    CLOCK_MONOTONIC undoes the problem.
    
    The issue is hard to observe, because it might only result in a less
    accurate SCHED_OTHER timeslicing behaviour. To create observable
    damage on realtime scheduling classes, it is necessary that the bogus
    update of CPU1 sched_clock happens in the context of an realtime
    thread, which then gets charged 4 seconds of RT runtime, which results
    in the RT throttler mechanism to trigger and prevent scheduling of RT
    tasks for a little less than 4 seconds. So this is quite unlikely as
    well.
    
    The issue was quite hard to decode as the reproduction time is between
    2 days and 3 weeks and intrusive tracing makes it less likely, but the
    following trace recorded with trace_clock=global, which uses
    sched_clock_local(), gave the final hint:
    
      <idle>-0   0d..30 400269.477150: hrtimer_cancel: hrtimer=0xf7061e80
      <idle>-0   0d..30 400269.477151: hrtimer_start:  hrtimer=0xf7061e80 ...
    irq/20-S-587 1d..32 400273.772118: sched_wakeup:   comm= ... target_cpu=0
      <idle>-0   0dN.30 400273.772118: hrtimer_cancel: hrtimer=0xf7061e80
    
    What happens is that CPU0 goes idle and invokes
    sched_clock_idle_sleep_event() which invokes sched_clock_local() and
    CPU1 runs a remote wakeup for CPU0 at the same time, which invokes
    sched_remote_clock(). The time jump gets propagated to CPU0 via
    sched_remote_clock() and stays stale on both cores for ~4 seconds.
    
    There are only two other possibilities, which could cause a stale
    sched clock:
    
    1) ktime_get() which reads out CLOCK_MONOTONIC returns a sporadic
       wrong value.
    
    2) sched_clock() which reads the TSC returns a sporadic wrong value.
    
    #1 can be excluded because sched_clock would continue to increase for
       one jiffy and then go stale.
    
    #2 can be excluded because it would not make the clock jump
       forward. It would just result in a stale sched_clock for one jiffy.
    
    After quite some brain twisting and finding the same pattern on other
    traces, sched_clock_remote() remained the only place which could cause
    such a problem and as explained above it's indeed racy on 32bit
    systems.
    
    So while on 64bit systems the readout is atomic, we need to verify the
    remote readout on 32bit machines. We need to protect the local->clock
    readout in sched_clock_remote() on 32bit as well because an NMI could
    hit between the low and the high readout, call sched_clock_local() and
    modify local->clock.
    
    Thanks to Siegfried Wulsch for bearing with my debug requests and
    going through the tedious tasks of running a bunch of reproducer
    systems to generate the debug information which let me decode the
    issue.
    
    Reported-by: Siegfried Wulsch <Siegfried.Wulsch@rovema.de>
    Acked-by: Peter Zijlstra <peterz@infradead.org>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Link: http://lkml.kernel.org/r/alpine.LFD.2.02.1304051544160.21884@ionos
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit fdd9ce008f3de39fa7fcd17717f1d7a0895269ea
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Apr 6 10:10:27 2013 +0200

    sched_clock: Prevent 64bit inatomicity on 32bit systems
    
    commit a1cbcaa9ea87b87a96b9fc465951dcf36e459ca2 upstream.
    
    The sched_clock_remote() implementation has the following inatomicity
    problem on 32bit systems when accessing the remote scd->clock, which
    is a 64bit value.
    
    CPU0                    CPU1
    
    sched_clock_local()     sched_clock_remote(CPU0)
    ...
                            remote_clock = scd[CPU0]->clock
                                read_low32bit(scd[CPU0]->clock)
    cmpxchg64(scd->clock,...)
                                read_high32bit(scd[CPU0]->clock)
    
    While the update of scd->clock is using an atomic64 mechanism, the
    readout on the remote cpu is not, which can cause completely bogus
    readouts.
    
    It is a quite rare problem, because it requires the update to hit the
    narrow race window between the low/high readout and the update must go
    across the 32bit boundary.
    
    The resulting misbehaviour is, that CPU1 will see the sched_clock on
    CPU1 ~4 seconds ahead of it's own and update CPU1s sched_clock value
    to this bogus timestamp. This stays that way due to the clamping
    implementation for about 4 seconds until the synchronization with
    CLOCK_MONOTONIC undoes the problem.
    
    The issue is hard to observe, because it might only result in a less
    accurate SCHED_OTHER timeslicing behaviour. To create observable
    damage on realtime scheduling classes, it is necessary that the bogus
    update of CPU1 sched_clock happens in the context of an realtime
    thread, which then gets charged 4 seconds of RT runtime, which results
    in the RT throttler mechanism to trigger and prevent scheduling of RT
    tasks for a little less than 4 seconds. So this is quite unlikely as
    well.
    
    The issue was quite hard to decode as the reproduction time is between
    2 days and 3 weeks and intrusive tracing makes it less likely, but the
    following trace recorded with trace_clock=global, which uses
    sched_clock_local(), gave the final hint:
    
      <idle>-0   0d..30 400269.477150: hrtimer_cancel: hrtimer=0xf7061e80
      <idle>-0   0d..30 400269.477151: hrtimer_start:  hrtimer=0xf7061e80 ...
    irq/20-S-587 1d..32 400273.772118: sched_wakeup:   comm= ... target_cpu=0
      <idle>-0   0dN.30 400273.772118: hrtimer_cancel: hrtimer=0xf7061e80
    
    What happens is that CPU0 goes idle and invokes
    sched_clock_idle_sleep_event() which invokes sched_clock_local() and
    CPU1 runs a remote wakeup for CPU0 at the same time, which invokes
    sched_remote_clock(). The time jump gets propagated to CPU0 via
    sched_remote_clock() and stays stale on both cores for ~4 seconds.
    
    There are only two other possibilities, which could cause a stale
    sched clock:
    
    1) ktime_get() which reads out CLOCK_MONOTONIC returns a sporadic
       wrong value.
    
    2) sched_clock() which reads the TSC returns a sporadic wrong value.
    
    #1 can be excluded because sched_clock would continue to increase for
       one jiffy and then go stale.
    
    #2 can be excluded because it would not make the clock jump
       forward. It would just result in a stale sched_clock for one jiffy.
    
    After quite some brain twisting and finding the same pattern on other
    traces, sched_clock_remote() remained the only place which could cause
    such a problem and as explained above it's indeed racy on 32bit
    systems.
    
    So while on 64bit systems the readout is atomic, we need to verify the
    remote readout on 32bit machines. We need to protect the local->clock
    readout in sched_clock_remote() on 32bit as well because an NMI could
    hit between the low and the high readout, call sched_clock_local() and
    modify local->clock.
    
    Thanks to Siegfried Wulsch for bearing with my debug requests and
    going through the tedious tasks of running a bunch of reproducer
    systems to generate the debug information which let me decode the
    issue.
    
    Reported-by: Siegfried Wulsch <Siegfried.Wulsch@rovema.de>
    Acked-by: Peter Zijlstra <peterz@infradead.org>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Link: http://lkml.kernel.org/r/alpine.LFD.2.02.1304051544160.21884@ionos
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 074ca07eff0e6f5ead1a1c688739c5bf960ca7c4
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Apr 6 10:10:27 2013 +0200

    sched_clock: Prevent 64bit inatomicity on 32bit systems
    
    commit a1cbcaa9ea87b87a96b9fc465951dcf36e459ca2 upstream.
    
    The sched_clock_remote() implementation has the following inatomicity
    problem on 32bit systems when accessing the remote scd->clock, which
    is a 64bit value.
    
    CPU0                    CPU1
    
    sched_clock_local()     sched_clock_remote(CPU0)
    ...
                            remote_clock = scd[CPU0]->clock
                                read_low32bit(scd[CPU0]->clock)
    cmpxchg64(scd->clock,...)
                                read_high32bit(scd[CPU0]->clock)
    
    While the update of scd->clock is using an atomic64 mechanism, the
    readout on the remote cpu is not, which can cause completely bogus
    readouts.
    
    It is a quite rare problem, because it requires the update to hit the
    narrow race window between the low/high readout and the update must go
    across the 32bit boundary.
    
    The resulting misbehaviour is, that CPU1 will see the sched_clock on
    CPU1 ~4 seconds ahead of it's own and update CPU1s sched_clock value
    to this bogus timestamp. This stays that way due to the clamping
    implementation for about 4 seconds until the synchronization with
    CLOCK_MONOTONIC undoes the problem.
    
    The issue is hard to observe, because it might only result in a less
    accurate SCHED_OTHER timeslicing behaviour. To create observable
    damage on realtime scheduling classes, it is necessary that the bogus
    update of CPU1 sched_clock happens in the context of an realtime
    thread, which then gets charged 4 seconds of RT runtime, which results
    in the RT throttler mechanism to trigger and prevent scheduling of RT
    tasks for a little less than 4 seconds. So this is quite unlikely as
    well.
    
    The issue was quite hard to decode as the reproduction time is between
    2 days and 3 weeks and intrusive tracing makes it less likely, but the
    following trace recorded with trace_clock=global, which uses
    sched_clock_local(), gave the final hint:
    
      <idle>-0   0d..30 400269.477150: hrtimer_cancel: hrtimer=0xf7061e80
      <idle>-0   0d..30 400269.477151: hrtimer_start:  hrtimer=0xf7061e80 ...
    irq/20-S-587 1d..32 400273.772118: sched_wakeup:   comm= ... target_cpu=0
      <idle>-0   0dN.30 400273.772118: hrtimer_cancel: hrtimer=0xf7061e80
    
    What happens is that CPU0 goes idle and invokes
    sched_clock_idle_sleep_event() which invokes sched_clock_local() and
    CPU1 runs a remote wakeup for CPU0 at the same time, which invokes
    sched_remote_clock(). The time jump gets propagated to CPU0 via
    sched_remote_clock() and stays stale on both cores for ~4 seconds.
    
    There are only two other possibilities, which could cause a stale
    sched clock:
    
    1) ktime_get() which reads out CLOCK_MONOTONIC returns a sporadic
       wrong value.
    
    2) sched_clock() which reads the TSC returns a sporadic wrong value.
    
    #1 can be excluded because sched_clock would continue to increase for
       one jiffy and then go stale.
    
    #2 can be excluded because it would not make the clock jump
       forward. It would just result in a stale sched_clock for one jiffy.
    
    After quite some brain twisting and finding the same pattern on other
    traces, sched_clock_remote() remained the only place which could cause
    such a problem and as explained above it's indeed racy on 32bit
    systems.
    
    So while on 64bit systems the readout is atomic, we need to verify the
    remote readout on 32bit machines. We need to protect the local->clock
    readout in sched_clock_remote() on 32bit as well because an NMI could
    hit between the low and the high readout, call sched_clock_local() and
    modify local->clock.
    
    Thanks to Siegfried Wulsch for bearing with my debug requests and
    going through the tedious tasks of running a bunch of reproducer
    systems to generate the debug information which let me decode the
    issue.
    
    Reported-by: Siegfried Wulsch <Siegfried.Wulsch@rovema.de>
    Acked-by: Peter Zijlstra <peterz@infradead.org>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Link: http://lkml.kernel.org/r/alpine.LFD.2.02.1304051544160.21884@ionos
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit a1cbcaa9ea87b87a96b9fc465951dcf36e459ca2
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Apr 6 10:10:27 2013 +0200

    sched_clock: Prevent 64bit inatomicity on 32bit systems
    
    The sched_clock_remote() implementation has the following inatomicity
    problem on 32bit systems when accessing the remote scd->clock, which
    is a 64bit value.
    
    CPU0                    CPU1
    
    sched_clock_local()     sched_clock_remote(CPU0)
    ...
                            remote_clock = scd[CPU0]->clock
                                read_low32bit(scd[CPU0]->clock)
    cmpxchg64(scd->clock,...)
                                read_high32bit(scd[CPU0]->clock)
    
    While the update of scd->clock is using an atomic64 mechanism, the
    readout on the remote cpu is not, which can cause completely bogus
    readouts.
    
    It is a quite rare problem, because it requires the update to hit the
    narrow race window between the low/high readout and the update must go
    across the 32bit boundary.
    
    The resulting misbehaviour is, that CPU1 will see the sched_clock on
    CPU1 ~4 seconds ahead of it's own and update CPU1s sched_clock value
    to this bogus timestamp. This stays that way due to the clamping
    implementation for about 4 seconds until the synchronization with
    CLOCK_MONOTONIC undoes the problem.
    
    The issue is hard to observe, because it might only result in a less
    accurate SCHED_OTHER timeslicing behaviour. To create observable
    damage on realtime scheduling classes, it is necessary that the bogus
    update of CPU1 sched_clock happens in the context of an realtime
    thread, which then gets charged 4 seconds of RT runtime, which results
    in the RT throttler mechanism to trigger and prevent scheduling of RT
    tasks for a little less than 4 seconds. So this is quite unlikely as
    well.
    
    The issue was quite hard to decode as the reproduction time is between
    2 days and 3 weeks and intrusive tracing makes it less likely, but the
    following trace recorded with trace_clock=global, which uses
    sched_clock_local(), gave the final hint:
    
      <idle>-0   0d..30 400269.477150: hrtimer_cancel: hrtimer=0xf7061e80
      <idle>-0   0d..30 400269.477151: hrtimer_start:  hrtimer=0xf7061e80 ...
    irq/20-S-587 1d..32 400273.772118: sched_wakeup:   comm= ... target_cpu=0
      <idle>-0   0dN.30 400273.772118: hrtimer_cancel: hrtimer=0xf7061e80
    
    What happens is that CPU0 goes idle and invokes
    sched_clock_idle_sleep_event() which invokes sched_clock_local() and
    CPU1 runs a remote wakeup for CPU0 at the same time, which invokes
    sched_remote_clock(). The time jump gets propagated to CPU0 via
    sched_remote_clock() and stays stale on both cores for ~4 seconds.
    
    There are only two other possibilities, which could cause a stale
    sched clock:
    
    1) ktime_get() which reads out CLOCK_MONOTONIC returns a sporadic
       wrong value.
    
    2) sched_clock() which reads the TSC returns a sporadic wrong value.
    
    #1 can be excluded because sched_clock would continue to increase for
       one jiffy and then go stale.
    
    #2 can be excluded because it would not make the clock jump
       forward. It would just result in a stale sched_clock for one jiffy.
    
    After quite some brain twisting and finding the same pattern on other
    traces, sched_clock_remote() remained the only place which could cause
    such a problem and as explained above it's indeed racy on 32bit
    systems.
    
    So while on 64bit systems the readout is atomic, we need to verify the
    remote readout on 32bit machines. We need to protect the local->clock
    readout in sched_clock_remote() on 32bit as well because an NMI could
    hit between the low and the high readout, call sched_clock_local() and
    modify local->clock.
    
    Thanks to Siegfried Wulsch for bearing with my debug requests and
    going through the tedious tasks of running a bunch of reproducer
    systems to generate the debug information which let me decode the
    issue.
    
    Reported-by: Siegfried Wulsch <Siegfried.Wulsch@rovema.de>
    Acked-by: Peter Zijlstra <peterz@infradead.org>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Link: http://lkml.kernel.org/r/alpine.LFD.2.02.1304051544160.21884@ionos
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org

commit 7806334afcaf4f0352a9c6f813264f5ef27d00f9
Author: Hector Palacios <hector.palacios@digi.com>
Date:   Mon Nov 14 11:15:25 2011 +0100

    timekeeping: add arch_offset hook to ktime_get functions
    
    commit d004e024058a0eaca097513ce62cbcf978913e0a upstream.
    
    ktime_get and ktime_get_ts were calling timekeeping_get_ns()
    but later they were not calling arch_gettimeoffset() so architectures
    using this mechanism returned 0 ns when calling these functions.
    
    This happened for example when running Busybox's ping which calls
    syscall(__NR_clock_gettime, CLOCK_MONOTONIC, ts) which eventually
    calls ktime_get. As a result the returned ping travel time was zero.
    
    Signed-off-by: Hector Palacios <hector.palacios@digi.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

commit b4e2564c9f5ba83af10076d029a7507b7a33b870
Author: John Stultz <john.stultz@linaro.org>
Date:   Mon Sep 17 21:38:46 2012 -0400

    time: Avoid making adjustments if we haven't accumulated anything
    
    commit bf2ac312195155511a0f79325515cbb61929898a upstream.
    
    If update_wall_time() is called and the current offset isn't large
    enough to accumulate, avoid re-calling timekeeping_adjust which may
    change the clock freq and can cause 1ns inconsistencies with
    CLOCK_REALTIME_COARSE/CLOCK_MONOTONIC_COARSE.
    
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Link: http://lkml.kernel.org/r/1345595449-34965-5-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Linux Kernel <linux-kernel@vger.kernel.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

commit 8e6057b510aad354e017c6dfca7f386a0eb91b63
Author: Sakari Ailus <sakari.ailus@linux.intel.com>
Date:   Sat Sep 15 15:14:42 2012 -0300

    [media] v4l: Convert drivers to use monotonic timestamps
    
    Convert drivers using wall clock time (CLOCK_REALTIME) to timestamp from the
    monotonic timer (CLOCK_MONOTONIC).
    
    Signed-off-by: Sakari Ailus <sakari.ailus@iki.fi>
    Acked-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

commit 61b76840ddee647c0c223365378c3f394355b7d7
Author: John Stultz <john.stultz@linaro.org>
Date:   Mon Sep 17 22:32:09 2012 -0400

    time: Avoid making adjustments if we haven't accumulated anything
    
    This is a -stable backport of bf2ac312195155511a0f79325515cbb61929898a
    
    If update_wall_time() is called and the current offset isn't large
    enough to accumulate, avoid re-calling timekeeping_adjust which may
    change the clock freq and can cause 1ns inconsistencies with
    CLOCK_REALTIME_COARSE/CLOCK_MONOTONIC_COARSE.
    
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: stable@vger.kernel.org
    Link: http://lkml.kernel.org/r/1345595449-34965-5-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Linux Kernel <linux-kernel@vger.kernel.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Willy Tarreau <w@1wt.eu>

commit 22539a28b0a97e84f74f716fe42d61dd07612d2d
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jul 17 18:05:33 2012 -0400

    timekeeping: Provide hrtimer update function
    
    This is a backport of f6c06abfb3972ad4914cef57d8348fcb2932bc3b
    
    To finally fix the infamous leap second issue and other race windows
    caused by functions which change the offsets between the various time
    bases (CLOCK_MONOTONIC, CLOCK_REALTIME and CLOCK_BOOTTIME) we need a
    function which atomically gets the current monotonic time and updates
    the offsets of CLOCK_REALTIME and CLOCK_BOOTTIME with minimalistic
    overhead. The previous patch which provides ktime_t offsets allows us
    to make this function almost as cheap as ktime_get() which is going to
    be replaced in hrtimer_interrupt().
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Ingo Molnar <mingo@kernel.org>
    Acked-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Acked-by: Prarit Bhargava <prarit@redhat.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Link: http://lkml.kernel.org/r/1341960205-56738-7-git-send-email-johnstul@us.ibm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Linux Kernel <linux-kernel@vger.kernel.org>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Willy Tarreau <w@1wt.eu>

commit af54f209dc49a5251f7b22646190d7193356bf02
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Jul 17 18:05:27 2012 -0400

    timekeeping: Fix CLOCK_MONOTONIC inconsistency during leapsecond
    
    This is a backport of fad0c66c4bb836d57a5f125ecd38bed653ca863a
    which resolves a bug the previous commit.
    
    Commit 6b43ae8a61 (ntp: Fix leap-second hrtimer livelock) broke the
    leapsecond update of CLOCK_MONOTONIC. The missing leapsecond update to
    wall_to_monotonic causes discontinuities in CLOCK_MONOTONIC.
    
    Adjust wall_to_monotonic when NTP inserted a leapsecond.
    
    Reported-by: Richard Cochran <richardcochran@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Tested-by: Richard Cochran <richardcochran@gmail.com>
    Link: http://lkml.kernel.org/r/1338400497-12420-1-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Linux Kernel <linux-kernel@vger.kernel.org>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Willy Tarreau <w@1wt.eu>

commit 4e64f897ce0d333d574143c0a23b1299d6137b4a
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Sep 11 14:56:20 2012 -0400

    time: Avoid making adjustments if we haven't accumulated anything
    
    commit bf2ac312195155511a0f79325515cbb61929898a upstream.
    
    If update_wall_time() is called and the current offset isn't large
    enough to accumulate, avoid re-calling timekeeping_adjust which may
    change the clock freq and can cause 1ns inconsistencies with
    CLOCK_REALTIME_COARSE/CLOCK_MONOTONIC_COARSE.
    
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: stable@vger.kernel.org
    Link: http://lkml.kernel.org/r/1345595449-34965-5-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 80257cbe62ea0919153c43421746269ab68473bf
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Sep 11 15:04:18 2012 -0400

    time: Avoid making adjustments if we haven't accumulated anything
    
    commit bf2ac312195155511a0f79325515cbb61929898a upstream.
    
    If update_wall_time() is called and the current offset isn't large
    enough to accumulate, avoid re-calling timekeeping_adjust which may
    change the clock freq and can cause 1ns inconsistencies with
    CLOCK_REALTIME_COARSE/CLOCK_MONOTONIC_COARSE.
    
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Link: http://lkml.kernel.org/r/1345595449-34965-5-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 4ffa9a8069801e36e2aceed5a77482b8b0841757
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Sep 11 20:49:52 2012 -0400

    time: Avoid making adjustments if we haven't accumulated anything
    
    commit bf2ac312195155511a0f79325515cbb61929898a upstream
    
    If update_wall_time() is called and the current offset isn't large
    enough to accumulate, avoid re-calling timekeeping_adjust which may
    change the clock freq and can cause 1ns inconsistencies with
    CLOCK_REALTIME_COARSE/CLOCK_MONOTONIC_COARSE.
    
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Link: http://lkml.kernel.org/r/1345595449-34965-5-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit cfb06dcbc0a63430195cfb70b56bd58311414878
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Aug 21 20:30:49 2012 -0400

    time: Avoid making adjustments if we haven't accumulated anything
    
    This is a -stable backport of bf2ac312195155511a0f79325515cbb61929898a
    
    If update_wall_time() is called and the current offset isn't large
    enough to accumulate, avoid re-calling timekeeping_adjust which may
    change the clock freq and can cause 1ns inconsistencies with
    CLOCK_REALTIME_COARSE/CLOCK_MONOTONIC_COARSE.
    
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Link: http://lkml.kernel.org/r/1345595449-34965-5-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Linux Kernel <linux-kernel@vger.kernel.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit bf2ac312195155511a0f79325515cbb61929898a
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Aug 21 20:30:49 2012 -0400

    time: Avoid making adjustments if we haven't accumulated anything
    
    If update_wall_time() is called and the current offset isn't large
    enough to accumulate, avoid re-calling timekeeping_adjust which may
    change the clock freq and can cause 1ns inconsistencies with
    CLOCK_REALTIME_COARSE/CLOCK_MONOTONIC_COARSE.
    
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: stable@vger.kernel.org
    Link: http://lkml.kernel.org/r/1345595449-34965-5-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit bd77b8e820140e552098f5262aa4e91513614110
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jul 17 17:49:29 2012 -0400

    timekeeping: Provide hrtimer update function
    
    commit f6c06abfb3972ad4914cef57d8348fcb2932bc3b upstream.
    
    To finally fix the infamous leap second issue and other race windows
    caused by functions which change the offsets between the various time
    bases (CLOCK_MONOTONIC, CLOCK_REALTIME and CLOCK_BOOTTIME) we need a
    function which atomically gets the current monotonic time and updates
    the offsets of CLOCK_REALTIME and CLOCK_BOOTTIME with minimalistic
    overhead. The previous patch which provides ktime_t offsets allows us
    to make this function almost as cheap as ktime_get() which is going to
    be replaced in hrtimer_interrupt().
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Ingo Molnar <mingo@kernel.org>
    Acked-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Acked-by: Prarit Bhargava <prarit@redhat.com>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Link: http://lkml.kernel.org/r/1341960205-56738-7-git-send-email-johnstul@us.ibm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Linux Kernel <linux-kernel@vger.kernel.org>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

commit 7df892974c2bf2487c3a08a959f0aab56d057822
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Jul 17 17:49:23 2012 -0400

    timekeeping: Fix CLOCK_MONOTONIC inconsistency during leapsecond
    
    commit fad0c66c4bb836d57a5f125ecd38bed653ca863a upstream.
    which resolves a bug the previous commit.
    
    Commit 6b43ae8a61 (ntp: Fix leap-second hrtimer livelock) broke the
    leapsecond update of CLOCK_MONOTONIC. The missing leapsecond update to
    wall_to_monotonic causes discontinuities in CLOCK_MONOTONIC.
    
    Adjust wall_to_monotonic when NTP inserted a leapsecond.
    
    Reported-by: Richard Cochran <richardcochran@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Tested-by: Richard Cochran <richardcochran@gmail.com>
    Link: http://lkml.kernel.org/r/1338400497-12420-1-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Linux Kernel <linux-kernel@vger.kernel.org>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

commit ec5806bcd08281a86e05b8e4eaf2f377bc8e5b24
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jul 10 18:43:24 2012 -0400

    timekeeping: Provide hrtimer update function
    
    This is a backport of f6c06abfb3972ad4914cef57d8348fcb2932bc3b
    
    To finally fix the infamous leap second issue and other race windows
    caused by functions which change the offsets between the various time
    bases (CLOCK_MONOTONIC, CLOCK_REALTIME and CLOCK_BOOTTIME) we need a
    function which atomically gets the current monotonic time and updates
    the offsets of CLOCK_REALTIME and CLOCK_BOOTTIME with minimalistic
    overhead. The previous patch which provides ktime_t offsets allows us
    to make this function almost as cheap as ktime_get() which is going to
    be replaced in hrtimer_interrupt().
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Ingo Molnar <mingo@kernel.org>
    Acked-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Acked-by: Prarit Bhargava <prarit@redhat.com>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Link: http://lkml.kernel.org/r/1341960205-56738-7-git-send-email-johnstul@us.ibm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    [John Stultz: Backported to 3.2]
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Linux Kernel <linux-kernel@vger.kernel.org>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit 09e66e8d71833a897a82ec18484b388e729b6548
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed May 30 10:54:57 2012 -0700

    timekeeping: Fix CLOCK_MONOTONIC inconsistency during leapsecond
    
    This is a backport of fad0c66c4bb836d57a5f125ecd38bed653ca863a
    which resolves a bug the previous commit.
    
    Commit 6b43ae8a61 (ntp: Fix leap-second hrtimer livelock) broke the
    leapsecond update of CLOCK_MONOTONIC. The missing leapsecond update to
    wall_to_monotonic causes discontinuities in CLOCK_MONOTONIC.
    
    Adjust wall_to_monotonic when NTP inserted a leapsecond.
    
    Reported-by: Richard Cochran <richardcochran@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Tested-by: Richard Cochran <richardcochran@gmail.com>
    Link: http://lkml.kernel.org/r/1338400497-12420-1-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Linux Kernel <linux-kernel@vger.kernel.org>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit 765bdc4d82fadcddfec19222a545e904633c7816
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jul 17 02:39:54 2012 -0400

    timekeeping: Provide hrtimer update function
    
    This is a backport of f6c06abfb3972ad4914cef57d8348fcb2932bc3b
    
    To finally fix the infamous leap second issue and other race windows
    caused by functions which change the offsets between the various time
    bases (CLOCK_MONOTONIC, CLOCK_REALTIME and CLOCK_BOOTTIME) we need a
    function which atomically gets the current monotonic time and updates
    the offsets of CLOCK_REALTIME and CLOCK_BOOTTIME with minimalistic
    overhead. The previous patch which provides ktime_t offsets allows us
    to make this function almost as cheap as ktime_get() which is going to
    be replaced in hrtimer_interrupt().
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Ingo Molnar <mingo@kernel.org>
    Acked-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Acked-by: Prarit Bhargava <prarit@redhat.com>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Link: http://lkml.kernel.org/r/1341960205-56738-7-git-send-email-johnstul@us.ibm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 22f4bbcfb131e2392c78ad67af35fdd436d4dd54
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jul 17 13:33:56 2012 -0400

    timekeeping: Provide hrtimer update function
    
    This is a backport of f6c06abfb3972ad4914cef57d8348fcb2932bc3b
    
    To finally fix the infamous leap second issue and other race windows
    caused by functions which change the offsets between the various time
    bases (CLOCK_MONOTONIC, CLOCK_REALTIME and CLOCK_BOOTTIME) we need a
    function which atomically gets the current monotonic time and updates
    the offsets of CLOCK_REALTIME and CLOCK_BOOTTIME with minimalistic
    overhead. The previous patch which provides ktime_t offsets allows us
    to make this function almost as cheap as ktime_get() which is going to
    be replaced in hrtimer_interrupt().
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Ingo Molnar <mingo@kernel.org>
    Acked-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Acked-by: Prarit Bhargava <prarit@redhat.com>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Link: http://lkml.kernel.org/r/1341960205-56738-7-git-send-email-johnstul@us.ibm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit c33f2424c3941986d402c81d380d4e805870a20f
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Jul 17 13:33:50 2012 -0400

    timekeeping: Fix CLOCK_MONOTONIC inconsistency during leapsecond
    
    This is a backport of fad0c66c4bb836d57a5f125ecd38bed653ca863a
    which resolves a bug the previous commit.
    
    Commit 6b43ae8a61 (ntp: Fix leap-second hrtimer livelock) broke the
    leapsecond update of CLOCK_MONOTONIC. The missing leapsecond update to
    wall_to_monotonic causes discontinuities in CLOCK_MONOTONIC.
    
    Adjust wall_to_monotonic when NTP inserted a leapsecond.
    
    Reported-by: Richard Cochran <richardcochran@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Tested-by: Richard Cochran <richardcochran@gmail.com>
    Link: http://lkml.kernel.org/r/1338400497-12420-1-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit f6c06abfb3972ad4914cef57d8348fcb2932bc3b
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jul 10 18:43:24 2012 -0400

    timekeeping: Provide hrtimer update function
    
    To finally fix the infamous leap second issue and other race windows
    caused by functions which change the offsets between the various time
    bases (CLOCK_MONOTONIC, CLOCK_REALTIME and CLOCK_BOOTTIME) we need a
    function which atomically gets the current monotonic time and updates
    the offsets of CLOCK_REALTIME and CLOCK_BOOTTIME with minimalistic
    overhead. The previous patch which provides ktime_t offsets allows us
    to make this function almost as cheap as ktime_get() which is going to
    be replaced in hrtimer_interrupt().
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Ingo Molnar <mingo@kernel.org>
    Acked-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Acked-by: Prarit Bhargava <prarit@redhat.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Link: http://lkml.kernel.org/r/1341960205-56738-7-git-send-email-johnstul@us.ibm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit d913c02b0a172d5dca6280da5b17a407d69bbce4
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed May 30 10:54:57 2012 -0700

    timekeeping: Fix CLOCK_MONOTONIC inconsistency during leapsecond
    
    commit fad0c66c4bb836d57a5f125ecd38bed653ca863a upstream.
    
    Commit 6b43ae8a61 (ntp: Fix leap-second hrtimer livelock) broke the
    leapsecond update of CLOCK_MONOTONIC. The missing leapsecond update to
    wall_to_monotonic causes discontinuities in CLOCK_MONOTONIC.
    
    Adjust wall_to_monotonic when NTP inserted a leapsecond.
    
    Reported-by: Richard Cochran <richardcochran@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Tested-by: Richard Cochran <richardcochran@gmail.com>
    Link: http://lkml.kernel.org/r/1338400497-12420-1-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit b1e25f41094dfe0b9653c926d3c02a35c2eb249c
Merge: 857505fae884 fad0c66c4bb8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jun 8 09:11:33 2012 -0700

    Merge branch 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull leap second timer fix from Thomas Gleixner.
    
    * 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      timekeeping: Fix CLOCK_MONOTONIC inconsistency during leapsecond

commit fad0c66c4bb836d57a5f125ecd38bed653ca863a
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed May 30 10:54:57 2012 -0700

    timekeeping: Fix CLOCK_MONOTONIC inconsistency during leapsecond
    
    Commit 6b43ae8a61 (ntp: Fix leap-second hrtimer livelock) broke the
    leapsecond update of CLOCK_MONOTONIC. The missing leapsecond update to
    wall_to_monotonic causes discontinuities in CLOCK_MONOTONIC.
    
    Adjust wall_to_monotonic when NTP inserted a leapsecond.
    
    Reported-by: Richard Cochran <richardcochran@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Tested-by: Richard Cochran <richardcochran@gmail.com>
    Cc: stable@kernel.org
    Link: http://lkml.kernel.org/r/1338400497-12420-1-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 91ec87d57fc38c529034e853687dfb7756de5406
Author: Andy Lutomirski <luto@mit.edu>
Date:   Thu Mar 22 21:15:51 2012 -0700

    x86-64: Simplify and optimize vdso clock_gettime monotonic variants
    
    We used to store the wall-to-monotonic offset and the realtime base.
    It's faster to precompute the monotonic base.
    
    This is about a 3% speedup on Sandy Bridge for CLOCK_MONOTONIC.
    It's much more impressive for CLOCK_MONOTONIC_COARSE.
    
    Signed-off-by: Andy Lutomirski <luto@amacapital.net>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit a80b83b7b8456e9b475346c2e01d7e210883208c
Author: John Stultz <john.stultz@linaro.org>
Date:   Fri Feb 3 00:19:07 2012 -0800

    Input: add infrastructure for selecting clockid for event time stamps
    
    As noted by Arve and others, since wall time can jump backwards, it is
    difficult to use for input because one cannot determine if one event
    occurred before another or for how long a key was pressed.
    
    However, the timestamp field is part of the kernel ABI, and cannot be
    changed without possibly breaking existing users.
    
    This patch adds a new IOCTL that allows a clockid to be set in the
    evdev_client struct that will specify which time base to use for event
    timestamps (ie: CLOCK_MONOTONIC instead of CLOCK_REALTIME).
    
    For now we only support CLOCK_MONOTONIC and CLOCK_REALTIME, but
    in the future we could support other clockids if appropriate.
    
    The default remains CLOCK_REALTIME, so we don't change the ABI.
    
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Reviewed-by: Daniel Kurtz <djkurtz@google.com>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

commit 5c3e9f55bbd366af73e51a12e1aa797a29532d67
Author: Hector Palacios <hector.palacios@digi.com>
Date:   Mon Nov 14 11:15:25 2011 +0100

    timekeeping: add arch_offset hook to ktime_get functions
    
    commit d004e024058a0eaca097513ce62cbcf978913e0a upstream.
    
    ktime_get and ktime_get_ts were calling timekeeping_get_ns()
    but later they were not calling arch_gettimeoffset() so architectures
    using this mechanism returned 0 ns when calling these functions.
    
    This happened for example when running Busybox's ping which calls
    syscall(__NR_clock_gettime, CLOCK_MONOTONIC, ts) which eventually
    calls ktime_get. As a result the returned ping travel time was zero.
    
    Signed-off-by: Hector Palacios <hector.palacios@digi.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 92ad5083db212ff3c5f6d1d085d85790f7a6c42c
Author: Hector Palacios <hector.palacios@digi.com>
Date:   Mon Nov 14 11:15:25 2011 +0100

    timekeeping: add arch_offset hook to ktime_get functions
    
    commit d004e024058a0eaca097513ce62cbcf978913e0a upstream.
    
    ktime_get and ktime_get_ts were calling timekeeping_get_ns()
    but later they were not calling arch_gettimeoffset() so architectures
    using this mechanism returned 0 ns when calling these functions.
    
    This happened for example when running Busybox's ping which calls
    syscall(__NR_clock_gettime, CLOCK_MONOTONIC, ts) which eventually
    calls ktime_get. As a result the returned ping travel time was zero.
    
    Signed-off-by: Hector Palacios <hector.palacios@digi.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit e1ef77bdad527601e9e47b377cbef5bee9df8248
Author: Hector Palacios <hector.palacios@digi.com>
Date:   Mon Nov 14 11:15:25 2011 +0100

    timekeeping: add arch_offset hook to ktime_get functions
    
    commit d004e024058a0eaca097513ce62cbcf978913e0a upstream.
    
    ktime_get and ktime_get_ts were calling timekeeping_get_ns()
    but later they were not calling arch_gettimeoffset() so architectures
    using this mechanism returned 0 ns when calling these functions.
    
    This happened for example when running Busybox's ping which calls
    syscall(__NR_clock_gettime, CLOCK_MONOTONIC, ts) which eventually
    calls ktime_get. As a result the returned ping travel time was zero.
    
    Signed-off-by: Hector Palacios <hector.palacios@digi.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit d004e024058a0eaca097513ce62cbcf978913e0a
Author: Hector Palacios <hector.palacios@digi.com>
Date:   Mon Nov 14 11:15:25 2011 +0100

    timekeeping: add arch_offset hook to ktime_get functions
    
    ktime_get and ktime_get_ts were calling timekeeping_get_ns()
    but later they were not calling arch_gettimeoffset() so architectures
    using this mechanism returned 0 ns when calling these functions.
    
    This happened for example when running Busybox's ping which calls
    syscall(__NR_clock_gettime, CLOCK_MONOTONIC, ts) which eventually
    calls ktime_get. As a result the returned ping travel time was zero.
    
    CC: stable@kernel.org
    Signed-off-by: Hector Palacios <hector.palacios@digi.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 14587a2a25447813996e6fb9e48d48627cb75a5d
Merge: fce637e392a7 e9d35946c84c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu May 26 12:19:31 2011 -0700

    Merge branch 'x86-vdso-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'x86-vdso-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip:
      x86: vdso: Remove unused variable
      x86-64: Optimize vDSO time()
      x86-64: Add time to vDSO
      x86-64: Turn off -pg and turn on -foptimize-sibling-calls for vDSO
      x86-64: Move vread_tsc into a new file with sensible options
      x86-64: Vclock_gettime(CLOCK_MONOTONIC) can't ever see nsec < 0
      x86-64: Don't generate cmov in vread_tsc
      x86-64: Remove unnecessary barrier in vread_tsc
      x86-64: Clean up vdso/kernel shared variables

commit 0f51f2852ccf0fe38a02d340d0ba625e8e32a863
Author: Andy Lutomirski <luto@MIT.EDU>
Date:   Mon May 23 09:31:27 2011 -0400

    x86-64: Vclock_gettime(CLOCK_MONOTONIC) can't ever see nsec < 0
    
    vclock_gettime's do_monotonic helper can't ever generate a negative
    nsec value, so it doesn't need to check whether it's negative.  In
    the CLOCK_MONOTONIC_COARSE case, ns can't ever exceed 2e9-1, so we
    can avoid the loop entirely.  This saves a single easily-predicted
    branch.
    
    Signed-off-by: Andy Lutomirski <luto@mit.edu>
    Cc: Andi Kleen <andi@firstfloor.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Eric Dumazet <eric.dumazet@gmail.com>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Borislav Petkov <bp@amd64.org>
    Link: http://lkml.kernel.org/r/%3Cd6d528d32c7a21618057cfc9005942a0fe5cb54a.1306156808.git.luto%40mit.edu%3E
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 057e6a8c660e95c3f4e7162e00e2fee1fc90c50d
Author: Andy Lutomirski <luto@MIT.EDU>
Date:   Mon May 23 09:31:25 2011 -0400

    x86-64: Remove unnecessary barrier in vread_tsc
    
    RDTSC is completely unordered on modern Intel and AMD CPUs.  The
    Intel manual says that lfence;rdtsc causes all previous instructions
    to complete before the tsc is read, and the AMD manual says to use
    mfence;rdtsc to do the same thing.
    
    From a decent amount of testing [1] this is enough to make rdtsc
    be ordered with respect to subsequent loads across a wide variety
    of CPUs.
    
    On Sandy Bridge (i7-2600), this improves a loop of
    clock_gettime(CLOCK_MONOTONIC) by more than 5 ns/iter.
    
    [1] https://lkml.org/lkml/2011/4/18/350
    
    Signed-off-by: Andy Lutomirski <luto@mit.edu>
    Cc: Andi Kleen <andi@firstfloor.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Eric Dumazet <eric.dumazet@gmail.com>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Borislav Petkov <bp@amd64.org>
    Link: http://lkml.kernel.org/r/%3C1c158b9d74338aa5361f96dd473d0e6a58235302.1306156808.git.luto%40mit.edu%3E
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 68fa61c026057a39d6ccb850aa8785043afbee02
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri May 20 23:14:04 2011 +0200

    hrtimers: Reorder clock bases
    
    The ordering of the clock bases is historical due to the
    CLOCK_REALTIME and CLOCK_MONOTONIC constants. Now the hrtimer bases
    have their own enumeration due to the gap between CLOCK_MONOTONIC and
    CLOCK_BOOTTIME. So we can be more clever as most timers end up on the
    CLOCK_MONOTONIC base due to the virtue of POSIX declaring that
    relative CLOCK_REALTIME timers are not affected by time changes. In
    desktop environments this is slowly changing as applications switch to
    absolute timers, but I've observed empty CLOCK_REALTIME bases often
    enough. There is no performance penalty or overhead when
    CLOCK_REALTIME timers are active, but in case they are not we don't
    skip over a full cache line.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Peter Zijlstra <peterz@infradead.org>

commit ce31332d3c77532d6ea97ddcb475a2b02dd358b4
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Apr 29 00:02:00 2011 +0200

    hrtimer: Initialize CLOCK_ID to HRTIMER_BASE table statically
    
    Sedat and Bruno reported RCU stalls which turned out to be caused by
    the following;
    
    sched_init() calls init_rt_bandwidth() which calls hrtimer_init()
    _BEFORE_ hrtimers_init() is called. While not entirely correct this
    worked because hrtimer_init() only accessed statically initialized
    data (hrtimer_bases.clock_base[CLOCK_MONOTONIC])
    
    Commit e06383db9 (hrtimers: extend hrtimer base code to handle more
    then 2 clockids) added an indirection to the hrtimer_bases.clock_base
    lookup to avoid gap handling in the hot path. The table which is used
    for the translataion from CLOCK_ID to HRTIMER_BASE index is
    initialized at runtime in hrtimers_init(). So the early call of the
    scheduler code translates CLOCK_MONOTONIC to HRTIMER_BASE_REALTIME.
    
    Thus the rt_bandwith timer ends up on CLOCK_REALTIME. If the timer is
    armed and the wall clock time is set (e.g. ntpdate in the early boot
    process - which also gives the problem deterministic behaviour
    i.e. magic recovery after N hours), then the timer ends up with an
    expiry time far into the future. That breaks the RT throttler
    mechanism as rt runtime is accumulated and never cleared, so the rt
    throttler detects a false cpu hog condition and blocks all RT tasks
    until the timer finally expires. That in turn stalls the RCU thread of
    TINYRCU which leads to an huge amount of RCU callbacks piling up.
    
    Make the translation table statically initialized, so we are back to
    the status of <= 2.6.39.
    
    Reported-and-tested-by: Sedat Dilek <sedat.dilek@gmail.com>
    Reported-by: Bruno Prémont <bonbons@linux-vserver.org>
    Cc: John stultz <johnstul@us.ibm.com>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/%3Calpine.LFD.2.02.1104282353140.3005%40ionos%3E
    Reviewed-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 9a7adcf5c6dea63d2e47e6f6d2f7a6c9f48b9337
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Jan 11 09:54:33 2011 -0800

    timers: Posix interface for alarm-timers
    
    This patch exposes alarm-timers to userland via the posix clock
    and timers interface, using two new clockids: CLOCK_REALTIME_ALARM
    and CLOCK_BOOTTIME_ALARM. Both clockids behave identically to
    CLOCK_REALTIME and CLOCK_BOOTTIME, respectively, but timers
    set against the _ALARM suffixed clockids will wake the system if
    it is suspended.
    
    Some background can be found here:
            https://lwn.net/Articles/429925/
    
    The concept for Alarm-timers was inspired by the Android Alarm
    driver (by Arve Hjønnevåg) found in the Android kernel tree.
    
    See: http://android.git.kernel.org/?p=kernel/common.git;a=blob;f=drivers/rtc/alarm.c;h=1250edfbdf3302f5e4ea6194847c6ef4bb7beb1c;hb=android-2.6.36
    
    While the in-kernel interface is pretty similar between
    alarm-timers and Android alarm driver, the user-space interface
    for the Android alarm driver is via ioctls to a new char device.
    As mentioned above, I've instead chosen to export this functionality
    via the posix interface, as it seemed a little simpler and avoids
    creating duplicate interfaces to things like CLOCK_REALTIME and
    CLOCK_MONOTONIC under alternate names (ie:ANDROID_ALARM_RTC and
    ANDROID_ALARM_SYSTEMTIME).
    
    The semantics of the Android alarm driver are different from what
    this posix interface provides. For instance, threads other then
    the thread waiting on the Android alarm driver are able to modify
    the alarm being waited on. Also this interface does not allow
    the same wakelock semantics that the Android driver provides
    (ie: kernel takes a wakelock on RTC alarm-interupt, and holds it
    through process wakeup, and while the process runs, until the
    process either closes the char device or calls back in to wait
    on a new alarm).
    
    One potential way to implement similar semantics may be via
    the timerfd infrastructure, but this needs more research.
    
    There may also need to be some sort of sysfs system level policy
    hooks that allow alarm timers to be disabled to keep them
    from firing at inappropriate times (ie: laptop in a well insulated
    bag, mid-flight).
    
    CC: Arve Hjønnevåg <arve@android.com>
    CC: Thomas Gleixner <tglx@linutronix.de>
    CC: Alessandro Zummo <a.zummo@towertech.it>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 6c6804fb2cef2d6aceb38b0eb0803210d77ff390
Author: Andrew Lutomirski <luto@mit.edu>
Date:   Thu Mar 24 00:36:56 2011 -0400

    perf symbols: Fix vsyscall symbol lookup
    
    Perf can't currently trace into the vsyscall page.  It looks like it was
    meant to work.
    
    Tested on 2.6.38 and today's -git.
    
    The bug is easy to reproduce.  Compile this:
    
    int main()
    {
            int i;
            struct timespec t;
            for(i = 0; i < 10000000; i++)
                    clock_gettime(CLOCK_MONOTONIC, &t);
            return 0;
    }
    
    and run it through perf record; perf report.  The top entry shows
    "[unknown]" and you can't zoom in.
    
    It looks like there are two issues.  The first is a that a test for user
    mode executing in kernel space is backwards.  (That's the first hunk
    below).  The second (I think) is that something's wrong with the code
    that generates lots of little struct dso objects for different sections
    -- when it runs on vmlinux it results in bogus long_name values which
    cause objdump to fail.
    
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    LPU-Reference: <AANLkTikxSw5+wJZUWNz++nL7mgivCh_Zf=2Kq6=f9Ce_@mail.gmail.com>
    Signed-off-by: Andy Lutomirski <luto@mit.edu>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

commit 70a08cca1227dc31c784ec930099a4417a06e7d0
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Feb 15 10:45:16 2011 -0800

    timers: Add CLOCK_BOOTTIME hrtimer base
    
    CLOCK_MONOTONIC stops while the system is in suspend. This is because
    to applications system suspend is invisible. However, there is a
    growing set of applications that are wanting to be suspend-aware,
    but do not want to deal with the complications of CLOCK_REALTIME
    (which might jump around if settimeofday is called).
    
    For these applications, I propose a new clockid: CLOCK_BOOTTIME.
    CLOCK_BOOTTIME is idential to CLOCK_MONOTONIC, except it also
    includes any time spent in suspend.
    
    This patch add hrtimer base for CLOCK_BOOTTIME, using
    get_monotonic_boottime/ktime_get_boottime, to allow
    in kernel users to set timers against.
    
    CC: Jamie Lokier <jamie@shareable.org>
    CC: Thomas Gleixner <tglx@linutronix.de>
    CC: Alexander Shishkin <virtuoso@slind.org>
    CC: Arve Hjønnevåg <arve@android.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit abb3a4ea2e0ea7114a4475745da2f32bd9ad5b73
Author: John Stultz <john.stultz@linaro.org>
Date:   Mon Feb 14 17:52:09 2011 -0800

    time: Introduce get_monotonic_boottime and ktime_get_boottime
    
    This adds new functions that return the monotonic time since boot
    (in other words, CLOCK_MONOTONIC + suspend time).
    
    CC: Jamie Lokier <jamie@shareable.org>
    CC: Thomas Gleixner <tglx@linutronix.de>
    CC: Alexander Shishkin <virtuoso@slind.org>
    CC: Arve Hjønnevåg <arve@android.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit e06383db9ec591696a06654257474b85bac1f8cb
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Dec 14 19:37:07 2010 -0800

    hrtimers: extend hrtimer base code to handle more then 2 clockids
    
    The hrtimer code is written mainly with CLOCK_REALTIME and CLOCK_MONOTONIC
    in mind. These are clockids 0 and 1 resepctively. However, if we are
    to introduce any new hrtimer bases, using new clockids, we have to skip
    the cputimers (clockids 2,3) as well as other clockids that may not impelement
    timers.
    
    This patch adds a little bit of indirection between the clockid and
    the base, so that we can extend the base by one when we add
    a new clockid at number 7 or so.
    
    CC: Jamie Lokier <jamie@shareable.org>
    CC: Thomas Gleixner <tglx@linutronix.de>
    CC: Alexander Shishkin <virtuoso@slind.org>
    CC: Arve Hjønnevåg <arve@android.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 6761c6702e2c647582e1829abe8cf90794f61d9d
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Feb 1 13:52:07 2011 +0000

    posix-timers: Convert timer_delete() to clockid_to_kclock()
    
    Set the common function for CLOCK_MONOTONIC and CLOCK_REALTIME kclocks
    and use the new decoding function.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: John Stultz <johnstul@us.ibm.com>
    Tested-by: Richard Cochran <richard.cochran@omicron.at>
    LKML-Reference: <20110201134419.198999420@linutronix.de>

commit a7319fa253a549c4c6528fb550ae6e72a9c83811
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Feb 1 13:52:04 2011 +0000

    posix-timers: Convert timer_gettime() to clockid_to_kclock()
    
    Set the common function for CLOCK_MONOTONIC and CLOCK_REALTIME kclocks
    and use the new decoding function.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: John Stultz <johnstul@us.ibm.com>
    Tested-by: Richard Cochran <richard.cochran@omicron.at>
    LKML-Reference: <20110201134419.101243181@linutronix.de>

commit 27722df16ef143017db55ac7baac1703a68017ff
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Feb 1 13:52:01 2011 +0000

    posix-timers: Convert timer_settime() to clockid_to_kclock()
    
    Set the common function for CLOCK_MONOTONIC and CLOCK_REALTIME kclocks
    and use the new decoding function.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: John Stultz <johnstul@us.ibm.com>
    Tested-by: Richard Cochran <richard.cochran@omicron.at>
    LKML-Reference: <20110201134419.001863714@linutronix.de>

commit 838394fbf989973ec7f5a0ad82cb6ff09e5c39aa
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Feb 1 13:51:58 2011 +0000

    posix-timers: Convert timer_create() to clockid_to_kclock()
    
    Setup timer_create for CLOCK_MONOTONIC and CLOCK_REALTIME kclocks and
    remove the no_timer_create() implementation.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: John Stultz <johnstul@us.ibm.com>
    Tested-by: Richard Cochran <richard.cochran@omicron.at>
    LKML-Reference: <20110201134418.903604289@linutronix.de>

commit b3423982bd2ecb7160856ffd6618dbb929c786cc
Author: Heiko Carstens <hca@linux.ibm.com>
Date:   Fri Oct 29 16:50:41 2010 +0200

    [S390] vdso: get rid of redefinition warnings
    
    The CLOCK_* defines in asm-offsets.c are only used for the vdso code
    however in the meantime they cause other trouble.
    Just rename them to get permanently rid of this:
    
    In file included from /home2/heicarst/linux-2.6/arch/s390/include/asm/asm-offsets.h:1:0,
                     from arch/s390/mm/fault.c:33:
    include/generated/asm-offsets.h:53:0: warning: "CLOCK_REALTIME" redefined
    include/linux/time.h:286:0: note: this is the location of the previous definition
    include/generated/asm-offsets.h:54:0: warning: "CLOCK_MONOTONIC" redefined
    include/linux/time.h:287:0: note: this is the location of the previous definition
    
    Signed-off-by: Heiko Carstens <heiko.carstens@de.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

commit abfe5a01ef1e463cbafdae461b693db34e308c02
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Sat Feb 20 12:13:49 2010 +0100

    firewire: cdev: add more flexible cycle timer ioctl
    
    The system time from CLOCK_REALTIME is not monotonic, hence problematic
    for the main user of the FW_CDEV_IOC_GET_CYCLE_TIMER ioctl.  This issue
    exists in its successor ABI, i.e. raw1394, too.
    http://subversion.ffado.org/ticket/242
    
    We now offer an alternative ioctl which lets the caller choose between
    CLOCK_REALTIME, CLOCK_MONOTONIC, and CLOCK_MONOTONIC_RAW as source of
    the local time, very similar to the clock_gettime libc function.  The
    format of the local time return value matches that of clock_gettime
    (seconds and nanoseconds, instead of a single microseconds value from
    the existing ioctl).
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

commit da15cfdae03351c689736f8d142618592e3cebc3
Author: John Stultz <johnstul@us.ibm.com>
Date:   Wed Aug 19 19:13:34 2009 -0700

    time: Introduce CLOCK_REALTIME_COARSE
    
    After talking with some application writers who want very fast, but not
    fine-grained timestamps, I decided to try to implement new clock_ids
    to clock_gettime(): CLOCK_REALTIME_COARSE and CLOCK_MONOTONIC_COARSE
    which returns the time at the last tick. This is very fast as we don't
    have to access any hardware (which can be very painful if you're using
    something like the acpi_pm clocksource), and we can even use the vdso
    clock_gettime() method to avoid the syscall. The only trade off is you
    only get low-res tick grained time resolution.
    
    This isn't a new idea, I know Ingo has a patch in the -rt tree that made
    the vsyscall gettimeofday() return coarse grained time when the
    vsyscall64 sysctrl was set to 2. However this affects all applications
    on a system.
    
    With this method, applications can choose the proper speed/granularity
    trade-off for themselves.
    
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Cc: Andi Kleen <andi@firstfloor.org>
    Cc: nikolag@ca.ibm.com
    Cc: Darren Hart <dvhltc@us.ibm.com>
    Cc: arjan@infradead.org
    Cc: jonathan@jonmasters.org
    LKML-Reference: <1250734414.6897.5.camel@localhost.localdomain>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit f175fe2d75ae60db85e8ca5c78da99789fcfe212
Author: Hiroshi Shimamoto <h-shimamoto@ct.jp.nec.com>
Date:   Mon Aug 3 11:48:19 2009 +0900

    posix-timers: Fix oops in clock_nanosleep() with CLOCK_MONOTONIC_RAW
    
    commit 70d715fd0597f18528f389b5ac59102263067744 upstream.
    
    Prevent calling do_nanosleep() with clockid
    CLOCK_MONOTONIC_RAW, it may cause oops, such as NULL pointer
    dereference.
    
    Signed-off-by: Hiroshi Shimamoto <h-shimamoto@ct.jp.nec.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: John Stultz <johnstul@us.ibm.com>
    LKML-Reference: <4A764FF3.50607@ct.jp.nec.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 7193675dc8ffa0325d013602d2bbccc0954db502
Merge: 9c66812b6bee 70d715fd0597
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Aug 4 15:32:08 2009 -0700

    Merge branch 'timers-fixes-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'timers-fixes-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip:
      posix-timers: Fix oops in clock_nanosleep() with CLOCK_MONOTONIC_RAW

commit 70d715fd0597f18528f389b5ac59102263067744
Author: Hiroshi Shimamoto <h-shimamoto@ct.jp.nec.com>
Date:   Mon Aug 3 11:48:19 2009 +0900

    posix-timers: Fix oops in clock_nanosleep() with CLOCK_MONOTONIC_RAW
    
    Prevent calling do_nanosleep() with clockid
    CLOCK_MONOTONIC_RAW, it may cause oops, such as NULL pointer
    dereference.
    
    Signed-off-by: Hiroshi Shimamoto <h-shimamoto@ct.jp.nec.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: John Stultz <johnstul@us.ibm.com>
    Cc: <stable@kernel.org>
    LKML-Reference: <4A764FF3.50607@ct.jp.nec.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

commit b020632e40c3ed5e8c0c066d022672907e8401cf
Author: Martin Schwidefsky <schwidefsky@de.ibm.com>
Date:   Thu Dec 25 13:38:36 2008 +0100

    [S390] introduce vdso on s390
    
    Add a vdso to speed up gettimeofday and clock_getres/clock_gettime for
    CLOCK_REALTIME/CLOCK_MONOTONIC.
    
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

commit 3d44cc3e01ee1b40317f79ed54324e25c4f848df
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Dec 20 21:27:34 2008 +0100

    Null pointer deref with hrtimer_try_to_cancel()
    
    Impact: Prevent kernel crash with posix timer clockid CLOCK_MONOTONIC_RAW
    
    commit 2d42244ae71d6c7b0884b5664cf2eda30fb2ae68 (clocksource:
    introduce CLOCK_MONOTONIC_RAW) introduced a new clockid, which is only
    available to read out the raw not NTP adjusted system time.
    
    The above commit did not prevent that a posix timer can be created
    with that clockid. The timer_create() syscall succeeds and initializes
    the timer to a non existing hrtimer base. When the timer is deleted
    either by timer_delete() or by the exit() cleanup the kernel crashes.
    
    Prevent the creation of timers for CLOCK_MONOTONIC_RAW by setting the
    posix clock function to no_timer_create which returns an error code.
    
    Reported-and-tested-by: Eric Sesterhenn <snakebyte@gmx.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Oleg Nesterov <oleg@redhat.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit 1acdac104668a0834cfa267de9946fac7764d486
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Nov 20 10:02:53 2008 -0800

    futex: make clock selectable for FUTEX_WAIT_BITSET
    
    FUTEX_WAIT_BITSET could be used instead of FUTEX_WAIT by setting the
    bit set to FUTEX_BITSET_MATCH_ANY, but FUTEX_WAIT uses CLOCK_REALTIME
    while FUTEX_WAIT_BITSET uses CLOCK_MONOTONIC.
    
    Add a flag to select CLOCK_REALTIME for FUTEX_WAIT_BITSET so glibc can
    replace the FUTEX_WAIT logic which needs to do gettimeofday() calls
    before and after the syscall to convert the absolute timeout to a
    relative timeout for FUTEX_WAIT.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ulrich Drepper <drepper@redhat.com>

commit 597bc5c00b666fe123abb0af64f6e86f7ab72a90
Author: Paul Mackerras <paulus@samba.org>
Date:   Mon Oct 27 23:56:03 2008 +0000

    powerpc: Improve resolution of VDSO clock_gettime
    
    Currently the clock_gettime implementation in the VDSO produces a
    result with microsecond resolution for the cases that are handled
    without a system call, i.e. CLOCK_REALTIME and CLOCK_MONOTONIC.  The
    nanoseconds field of the result is obtained by computing a
    microseconds value and multiplying by 1000.
    
    This changes the code in the VDSO to do the computation for
    clock_gettime with nanosecond resolution.  That means that the
    resolution of the result will ultimately depend on the timebase
    frequency.
    
    Because the timestamp in the VDSO datapage (stamp_xsec, the real time
    corresponding to the timebase count in tb_orig_stamp) is in units of
    2^-20 seconds, it doesn't have sufficient resolution for computing a
    result with nanosecond resolution.  Therefore this adds a copy of
    xtime to the VDSO datapage and updates it in update_gtod() along with
    the other time-related fields.
    
    Signed-off-by: Paul Mackerras <paulus@samba.org>

commit 2d42244ae71d6c7b0884b5664cf2eda30fb2ae68
Author: John Stultz <johnstul@us.ibm.com>
Date:   Wed Aug 20 16:37:30 2008 -0700

    clocksource: introduce CLOCK_MONOTONIC_RAW
    
    In talking with Josip Loncaric, and his work on clock synchronization (see
    btime.sf.net), he mentioned that for really close synchronization, it is
    useful to have access to "hardware time", that is a notion of time that is
    not in any way adjusted by the clock slewing done to keep close time sync.
    
    Part of the issue is if we are using the kernel's ntp adjusted
    representation of time in order to measure how we should correct time, we
    can run into what Paul McKenney aptly described as "Painting a road using
    the lines we're painting as the guide".
    
    I had been thinking of a similar problem, and was trying to come up with a
    way to give users access to a purely hardware based time representation
    that avoided users having to know the underlying frequency and mask values
    needed to deal with the wide variety of possible underlying hardware
    counters.
    
    My solution is to introduce CLOCK_MONOTONIC_RAW.  This exposes a
    nanosecond based time value, that increments starting at bootup and has no
    frequency adjustments made to it what so ever.
    
    The time is accessed from userspace via the posix_clock_gettime() syscall,
    passing CLOCK_MONOTONIC_RAW as the clock_id.
    
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

commit 4d672e7ac79b5ec5cdc90e450823441e20464691
Author: Davide Libenzi <davidel@xmailserver.org>
Date:   Mon Feb 4 22:27:26 2008 -0800

    timerfd: new timerfd API
    
    This is the new timerfd API as it is implemented by the following patch:
    
    int timerfd_create(int clockid, int flags);
    int timerfd_settime(int ufd, int flags,
                        const struct itimerspec *utmr,
                        struct itimerspec *otmr);
    int timerfd_gettime(int ufd, struct itimerspec *otmr);
    
    The timerfd_create() API creates an un-programmed timerfd fd.  The "clockid"
    parameter can be either CLOCK_MONOTONIC or CLOCK_REALTIME.
    
    The timerfd_settime() API give new settings by the timerfd fd, by optionally
    retrieving the previous expiration time (in case the "otmr" parameter is not
    NULL).
    
    The time value specified in "utmr" is absolute, if the TFD_TIMER_ABSTIME bit
    is set in the "flags" parameter.  Otherwise it's a relative time.
    
    The timerfd_gettime() API returns the next expiration time of the timer, or
    {0, 0} if the timerfd has not been set yet.
    
    Like the previous timerfd API implementation, read(2) and poll(2) are
    supported (with the same interface).  Here's a simple test program I used to
    exercise the new timerfd APIs:
    
    http://www.xmailserver.org/timerfd-test2.c
    
    [akpm@linux-foundation.org: coding-style cleanups]
    [akpm@linux-foundation.org: fix ia64 build]
    [akpm@linux-foundation.org: fix m68k build]
    [akpm@linux-foundation.org: fix mips build]
    [akpm@linux-foundation.org: fix alpha, arm, blackfin, cris, m68k, s390, sparc and sparc64 builds]
    [heiko.carstens@de.ibm.com: fix s390]
    [akpm@linux-foundation.org: fix powerpc build]
    [akpm@linux-foundation.org: fix sparc64 more]
    Signed-off-by: Davide Libenzi <davidel@xmailserver.org>
    Cc: Michael Kerrisk <mtk-manpages@gmx.net>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Davide Libenzi <davidel@xmailserver.org>
    Cc: Michael Kerrisk <mtk-manpages@gmx.net>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Signed-off-by: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Michael Kerrisk <mtk.manpages@gmail.com>
    Cc: Davide Libenzi <davidel@xmailserver.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit 2aae950b21e4bc789d1fc6668faf67e8748300b7
Author: Andi Kleen <ak@linux.intel.com>
Date:   Sat Jul 21 17:10:01 2007 +0200

    x86_64: Add vDSO for x86-64 with gettimeofday/clock_gettime/getcpu
    
    This implements new vDSO for x86-64.  The concept is similar
    to the existing vDSOs on i386 and PPC.  x86-64 has had static
    vsyscalls before,  but these are not flexible enough anymore.
    
    A vDSO is a ELF shared library supplied by the kernel that is mapped into
    user address space.  The vDSO mapping is randomized for each process
    for security reasons.
    
    Doing this was needed for clock_gettime, because clock_gettime
    always needs a syscall fallback and having one at a fixed
    address would have made buffer overflow exploits too easy to write.
    
    The vdso can be disabled with vdso=0
    
    It currently includes a new gettimeofday implemention and optimized
    clock_gettime(). The gettimeofday implementation is slightly faster
    than the one in the old vsyscall.  clock_gettime is significantly faster
    than the syscall for CLOCK_MONOTONIC and CLOCK_REALTIME.
    
    The new calls are generally faster than the old vsyscall.
    
    Advantages over the old x86-64 vsyscalls:
    - Extensible
    - Randomized
    - Cleaner
    - Easier to virtualize (the old static address range previously causes
    overhead e.g. for Xen because it has to create special page tables for it)
    
    Weak points:
    - glibc support still to be written
    
    The VM interface is partly based on Ingo Molnar's i386 version.
    
    Includes compile fix from Joachim Deguara
    
    Signed-off-by: Andi Kleen <ak@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit b215e283992899650c4271e7385c79e26fb9a88e
Author: Davide Libenzi <davidel@xmailserver.org>
Date:   Thu May 10 22:23:16 2007 -0700

    signal/timer/event: timerfd core
    
    This patch introduces a new system call for timers events delivered though
    file descriptors.  This allows timer event to be used with standard POSIX
    poll(2), select(2) and read(2).  As a consequence of supporting the Linux
    f_op->poll subsystem, they can be used with epoll(2) too.
    
    The system call is defined as:
    
    int timerfd(int ufd, int clockid, int flags, const struct itimerspec *utmr);
    
    The "ufd" parameter allows for re-use (re-programming) of an existing timerfd
    w/out going through the close/open cycle (same as signalfd).  If "ufd" is -1,
    s new file descriptor will be created, otherwise the existing "ufd" will be
    re-programmed.
    
    The "clockid" parameter is either CLOCK_MONOTONIC or CLOCK_REALTIME.  The time
    specified in the "utmr->it_value" parameter is the expiry time for the timer.
    
    If the TFD_TIMER_ABSTIME flag is set in "flags", this is an absolute time,
    otherwise it's a relative time.
    
    If the time specified in the "utmr->it_interval" is not zero (.tv_sec == 0,
    tv_nsec == 0), this is the period at which the following ticks should be
    generated.
    
    The "utmr->it_interval" should be set to zero if only one tick is requested.
    Setting the "utmr->it_value" to zero will disable the timer, or will create a
    timerfd without the timer enabled.
    
    The function returns the new (or same, in case "ufd" is a valid timerfd
    descriptor) file, or -1 in case of error.
    
    As stated before, the timerfd file descriptor supports poll(2), select(2) and
    epoll(2).  When a timer event happened on the timerfd, a POLLIN mask will be
    returned.
    
    The read(2) call can be used, and it will return a u32 variable holding the
    number of "ticks" that happened on the interface since the last call to
    read(2).  The read(2) call supportes the O_NONBLOCK flag too, and EAGAIN will
    be returned if no ticks happened.
    
    A quick test program, shows timerfd working correctly on my amd64 box:
    
    http://www.xmailserver.org/timerfd-test.c
    
    [akpm@linux-foundation.org: add sys_timerfd to sys_ni.c]
    Signed-off-by: Davide Libenzi <davidel@xmailserver.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit a7f290dad32ee34d931561b7943c858fe2aae503
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Fri Nov 11 21:15:21 2005 +1100

    [PATCH] powerpc: Merge vdso's and add vdso support to 32 bits kernel
    
    This patch moves the vdso's to arch/powerpc, adds support for the 32
    bits vdso to the 32 bits kernel, rename systemcfg (finally !), and adds
    some new (still untested) routines to both vdso's: clock_gettime() with
    support for CLOCK_REALTIME and CLOCK_MONOTONIC, clock_getres() (same
    clocks) and get_tbfreq() for glibc to retreive the timebase frequency.
    
    Tom,Steve: The implementation of get_tbfreq() I've done for 32 bits
    returns a long long (r3, r4) not a long. This is such that if we ever
    add support for >4Ghz timebases on ppc32, the userland interface won't
    have to change.
    
    I have tested gettimeofday() using some glibc patches in both ppc32 and
    ppc64 kernels using 32 bits userland (I haven't had a chance to test a
    64 bits userland yet, but the implementation didn't change and was
    tested earlier). I haven't tested yet the new functions.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

commit 78fa74a23b16bdb0d944272b696915c4e0bb3ee1
Author: George Anzinger <george@mvista.com>
Date:   Thu Jul 28 21:16:16 2005 -0700

    [PATCH] posix timers: fix normalization problem
    
    (We found this (after a customer complained) and it is in the kernel.org
    kernel.  Seems that for CLOCK_MONOTONIC absolute timers and clock_nanosleep
    calls both the request time and wall_to_monotonic are subtracted prior to
    the normalize resulting in an overflow in the existing normalize test.
    This causes the result to be shifted ~4 seconds ahead instead of ~2 seconds
    back in time.)
    
    The normalize code in posix-timers.c fails when the tv_nsec member is ~1.2
    seconds negative.  This can happen on absolute timers (and
    clock_nanosleeps) requested on CLOCK_MONOTONIC (both the request time and
    wall_to_monotonic are subtracted resulting in the possibility of a number
    close to -2 seconds.)
    
    This fix uses the set_normalized_timespec() (which does not have an
    overflow problem) to fix the problem and as a side effect makes the code
    cleaner.
    
    Signed-off-by: George Anzinger <george@mvista.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>
