commit 162d52dfee445c21d1fa5c4b1f55765946df4d3e
Author: Vladimir Oltean <vladimir.oltean@nxp.com>
Date:   Sat Sep 24 00:00:15 2022 +0300

    selftests: net: tsn_lib: run phc2sys in automatic mode
    
    We can make the phc2sys helper not only synchronize a PHC to
    CLOCK_REALTIME, which is what it currently does, but also CLOCK_REALTIME
    to a PHC, which is going to be needed in distributed TSN tests.
    
    Instead of making the complexity of the arguments passed to
    phc2sys_start() explode, we can let it figure out the sync direction
    automatically, based on ptp4l's port states.
    
    Towards that goal, pass just the path to the desired ptp4l instance's
    UNIX domain socket, and remove the $if_name argument (from which it
    derives the PHC). Also adapt the one caller from the ocelot psfp.sh
    test. In the case of psfp.sh, phc2sys_start is able to properly figure
    out that CLOCK_REALTIME is the source clock and swp1's PHC is the
    destination, because of the way in which ptp4l_start for the
    UDS_ADDRESS_SWP1 was called: with slave_only=false, so it will always
    win the BMCA and always become the sync master between itself and $h1.
    
    Signed-off-by: Vladimir Oltean <vladimir.oltean@nxp.com>
    Reviewed-by: Kurt Kanzenbach <kurt@linutronix.de>
    Signed-off-by: Jakub Kicinski <kuba@kernel.org>

commit 18e65ab351cf17b0af65e3d1e5d4cbbb7b8e3568
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Mar 8 16:44:25 2022 +0100

    power: ab8500_chargalg: Use CLOCK_MONOTONIC
    
    [ Upstream commit c22fca40522e2be8af168f3087d87d85e404ea72 ]
    
    The HRTimer in the AB8500 charging code is using CLOCK_REALTIME
    to set an alarm some hours forward in time +/- 5 min for a safety
    timer.
    
    I have observed that this will sometimes fire sporadically
    early when charging a battery with the result that
    charging stops.
    
    As CLOCK_REALTIME can be subject to adjustments of time from
    sources such as NTP, this cannot be trusted and will likely
    for example fire events if the clock is set forward some hours
    by say NTP.
    
    Use CLOCK_MONOTONIC as indicated in other instances and the
    problem goes away. Also initialize the timer to REL mode
    as this is what will be used later.
    
    Fixes: 257107ae6b9b ("ab8500-chargalg: Use hrtimer")
    Cc: Lee Jones <lee.jones@linaro.org>
    Suggested-by: Matti Vaittinen <mazziesaccount@gmail.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Reviewed-by: Matti Vaittinen <matti.vaittinen@fi.rohmeurope.com>
    Signed-off-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit e0bd5424aa8016c2a6a9001070cda184bff08b3e
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Mar 8 16:44:25 2022 +0100

    power: ab8500_chargalg: Use CLOCK_MONOTONIC
    
    [ Upstream commit c22fca40522e2be8af168f3087d87d85e404ea72 ]
    
    The HRTimer in the AB8500 charging code is using CLOCK_REALTIME
    to set an alarm some hours forward in time +/- 5 min for a safety
    timer.
    
    I have observed that this will sometimes fire sporadically
    early when charging a battery with the result that
    charging stops.
    
    As CLOCK_REALTIME can be subject to adjustments of time from
    sources such as NTP, this cannot be trusted and will likely
    for example fire events if the clock is set forward some hours
    by say NTP.
    
    Use CLOCK_MONOTONIC as indicated in other instances and the
    problem goes away. Also initialize the timer to REL mode
    as this is what will be used later.
    
    Fixes: 257107ae6b9b ("ab8500-chargalg: Use hrtimer")
    Cc: Lee Jones <lee.jones@linaro.org>
    Suggested-by: Matti Vaittinen <mazziesaccount@gmail.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Reviewed-by: Matti Vaittinen <matti.vaittinen@fi.rohmeurope.com>
    Signed-off-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 2334f49e937646bde20f3c064f1da007d073a1f4
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Mar 8 16:44:25 2022 +0100

    power: ab8500_chargalg: Use CLOCK_MONOTONIC
    
    [ Upstream commit c22fca40522e2be8af168f3087d87d85e404ea72 ]
    
    The HRTimer in the AB8500 charging code is using CLOCK_REALTIME
    to set an alarm some hours forward in time +/- 5 min for a safety
    timer.
    
    I have observed that this will sometimes fire sporadically
    early when charging a battery with the result that
    charging stops.
    
    As CLOCK_REALTIME can be subject to adjustments of time from
    sources such as NTP, this cannot be trusted and will likely
    for example fire events if the clock is set forward some hours
    by say NTP.
    
    Use CLOCK_MONOTONIC as indicated in other instances and the
    problem goes away. Also initialize the timer to REL mode
    as this is what will be used later.
    
    Fixes: 257107ae6b9b ("ab8500-chargalg: Use hrtimer")
    Cc: Lee Jones <lee.jones@linaro.org>
    Suggested-by: Matti Vaittinen <mazziesaccount@gmail.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Reviewed-by: Matti Vaittinen <matti.vaittinen@fi.rohmeurope.com>
    Signed-off-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit c22fca40522e2be8af168f3087d87d85e404ea72
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Mar 8 16:44:25 2022 +0100

    power: ab8500_chargalg: Use CLOCK_MONOTONIC
    
    The HRTimer in the AB8500 charging code is using CLOCK_REALTIME
    to set an alarm some hours forward in time +/- 5 min for a safety
    timer.
    
    I have observed that this will sometimes fire sporadically
    early when charging a battery with the result that
    charging stops.
    
    As CLOCK_REALTIME can be subject to adjustments of time from
    sources such as NTP, this cannot be trusted and will likely
    for example fire events if the clock is set forward some hours
    by say NTP.
    
    Use CLOCK_MONOTONIC as indicated in other instances and the
    problem goes away. Also initialize the timer to REL mode
    as this is what will be used later.
    
    Fixes: 257107ae6b9b ("ab8500-chargalg: Use hrtimer")
    Cc: Lee Jones <lee.jones@linaro.org>
    Suggested-by: Matti Vaittinen <mazziesaccount@gmail.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Reviewed-by: Matti Vaittinen <matti.vaittinen@fi.rohmeurope.com>
    Signed-off-by: Sebastian Reichel <sebastian.reichel@collabora.com>

commit c5664d508674c77a52d311af8b1e11d08ac0cf4b
Author: Yu Liao <liaoyu15@huawei.com>
Date:   Mon Dec 13 21:57:27 2021 +0800

    timekeeping: Really make sure wall_to_monotonic isn't positive
    
    commit 4e8c11b6b3f0b6a283e898344f154641eda94266 upstream.
    
    Even after commit e1d7ba873555 ("time: Always make sure wall_to_monotonic
    isn't positive") it is still possible to make wall_to_monotonic positive
    by running the following code:
    
        int main(void)
        {
            struct timespec time;
    
            clock_gettime(CLOCK_MONOTONIC, &time);
            time.tv_nsec = 0;
            clock_settime(CLOCK_REALTIME, &time);
            return 0;
        }
    
    The reason is that the second parameter of timespec64_compare(), ts_delta,
    may be unnormalized because the delta is calculated with an open coded
    substraction which causes the comparison of tv_sec to yield the wrong
    result:
    
      wall_to_monotonic = { .tv_sec = -10, .tv_nsec =  900000000 }
      ts_delta          = { .tv_sec =  -9, .tv_nsec = -900000000 }
    
    That makes timespec64_compare() claim that wall_to_monotonic < ts_delta,
    but actually the result should be wall_to_monotonic > ts_delta.
    
    After normalization, the result of timespec64_compare() is correct because
    the tv_sec comparison is not longer misleading:
    
      wall_to_monotonic = { .tv_sec = -10, .tv_nsec =  900000000 }
      ts_delta          = { .tv_sec = -10, .tv_nsec =  100000000 }
    
    Use timespec64_sub() to ensure that ts_delta is normalized, which fixes the
    issue.
    
    Fixes: e1d7ba873555 ("time: Always make sure wall_to_monotonic isn't positive")
    Signed-off-by: Yu Liao <liaoyu15@huawei.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/20211213135727.1656662-1-liaoyu15@huawei.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit a9f2c6af5a601a2e2bf40e5561bedc87a44d9649
Author: Yu Liao <liaoyu15@huawei.com>
Date:   Mon Dec 13 21:57:27 2021 +0800

    timekeeping: Really make sure wall_to_monotonic isn't positive
    
    commit 4e8c11b6b3f0b6a283e898344f154641eda94266 upstream.
    
    Even after commit e1d7ba873555 ("time: Always make sure wall_to_monotonic
    isn't positive") it is still possible to make wall_to_monotonic positive
    by running the following code:
    
        int main(void)
        {
            struct timespec time;
    
            clock_gettime(CLOCK_MONOTONIC, &time);
            time.tv_nsec = 0;
            clock_settime(CLOCK_REALTIME, &time);
            return 0;
        }
    
    The reason is that the second parameter of timespec64_compare(), ts_delta,
    may be unnormalized because the delta is calculated with an open coded
    substraction which causes the comparison of tv_sec to yield the wrong
    result:
    
      wall_to_monotonic = { .tv_sec = -10, .tv_nsec =  900000000 }
      ts_delta          = { .tv_sec =  -9, .tv_nsec = -900000000 }
    
    That makes timespec64_compare() claim that wall_to_monotonic < ts_delta,
    but actually the result should be wall_to_monotonic > ts_delta.
    
    After normalization, the result of timespec64_compare() is correct because
    the tv_sec comparison is not longer misleading:
    
      wall_to_monotonic = { .tv_sec = -10, .tv_nsec =  900000000 }
      ts_delta          = { .tv_sec = -10, .tv_nsec =  100000000 }
    
    Use timespec64_sub() to ensure that ts_delta is normalized, which fixes the
    issue.
    
    Fixes: e1d7ba873555 ("time: Always make sure wall_to_monotonic isn't positive")
    Signed-off-by: Yu Liao <liaoyu15@huawei.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/20211213135727.1656662-1-liaoyu15@huawei.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 62889094939c5fc0c43b207396e51bde905be1ca
Author: Yu Liao <liaoyu15@huawei.com>
Date:   Mon Dec 13 21:57:27 2021 +0800

    timekeeping: Really make sure wall_to_monotonic isn't positive
    
    commit 4e8c11b6b3f0b6a283e898344f154641eda94266 upstream.
    
    Even after commit e1d7ba873555 ("time: Always make sure wall_to_monotonic
    isn't positive") it is still possible to make wall_to_monotonic positive
    by running the following code:
    
        int main(void)
        {
            struct timespec time;
    
            clock_gettime(CLOCK_MONOTONIC, &time);
            time.tv_nsec = 0;
            clock_settime(CLOCK_REALTIME, &time);
            return 0;
        }
    
    The reason is that the second parameter of timespec64_compare(), ts_delta,
    may be unnormalized because the delta is calculated with an open coded
    substraction which causes the comparison of tv_sec to yield the wrong
    result:
    
      wall_to_monotonic = { .tv_sec = -10, .tv_nsec =  900000000 }
      ts_delta          = { .tv_sec =  -9, .tv_nsec = -900000000 }
    
    That makes timespec64_compare() claim that wall_to_monotonic < ts_delta,
    but actually the result should be wall_to_monotonic > ts_delta.
    
    After normalization, the result of timespec64_compare() is correct because
    the tv_sec comparison is not longer misleading:
    
      wall_to_monotonic = { .tv_sec = -10, .tv_nsec =  900000000 }
      ts_delta          = { .tv_sec = -10, .tv_nsec =  100000000 }
    
    Use timespec64_sub() to ensure that ts_delta is normalized, which fixes the
    issue.
    
    Fixes: e1d7ba873555 ("time: Always make sure wall_to_monotonic isn't positive")
    Signed-off-by: Yu Liao <liaoyu15@huawei.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/20211213135727.1656662-1-liaoyu15@huawei.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 8938a4473e6244dff5c4ff3579e7b6d880d1f68c
Author: Yu Liao <liaoyu15@huawei.com>
Date:   Mon Dec 13 21:57:27 2021 +0800

    timekeeping: Really make sure wall_to_monotonic isn't positive
    
    commit 4e8c11b6b3f0b6a283e898344f154641eda94266 upstream.
    
    Even after commit e1d7ba873555 ("time: Always make sure wall_to_monotonic
    isn't positive") it is still possible to make wall_to_monotonic positive
    by running the following code:
    
        int main(void)
        {
            struct timespec time;
    
            clock_gettime(CLOCK_MONOTONIC, &time);
            time.tv_nsec = 0;
            clock_settime(CLOCK_REALTIME, &time);
            return 0;
        }
    
    The reason is that the second parameter of timespec64_compare(), ts_delta,
    may be unnormalized because the delta is calculated with an open coded
    substraction which causes the comparison of tv_sec to yield the wrong
    result:
    
      wall_to_monotonic = { .tv_sec = -10, .tv_nsec =  900000000 }
      ts_delta          = { .tv_sec =  -9, .tv_nsec = -900000000 }
    
    That makes timespec64_compare() claim that wall_to_monotonic < ts_delta,
    but actually the result should be wall_to_monotonic > ts_delta.
    
    After normalization, the result of timespec64_compare() is correct because
    the tv_sec comparison is not longer misleading:
    
      wall_to_monotonic = { .tv_sec = -10, .tv_nsec =  900000000 }
      ts_delta          = { .tv_sec = -10, .tv_nsec =  100000000 }
    
    Use timespec64_sub() to ensure that ts_delta is normalized, which fixes the
    issue.
    
    Fixes: e1d7ba873555 ("time: Always make sure wall_to_monotonic isn't positive")
    Signed-off-by: Yu Liao <liaoyu15@huawei.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/20211213135727.1656662-1-liaoyu15@huawei.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit c0b25c6d1b91da64069c3c364e68775ad6d5437c
Author: Yu Liao <liaoyu15@huawei.com>
Date:   Mon Dec 13 21:57:27 2021 +0800

    timekeeping: Really make sure wall_to_monotonic isn't positive
    
    commit 4e8c11b6b3f0b6a283e898344f154641eda94266 upstream.
    
    Even after commit e1d7ba873555 ("time: Always make sure wall_to_monotonic
    isn't positive") it is still possible to make wall_to_monotonic positive
    by running the following code:
    
        int main(void)
        {
            struct timespec time;
    
            clock_gettime(CLOCK_MONOTONIC, &time);
            time.tv_nsec = 0;
            clock_settime(CLOCK_REALTIME, &time);
            return 0;
        }
    
    The reason is that the second parameter of timespec64_compare(), ts_delta,
    may be unnormalized because the delta is calculated with an open coded
    substraction which causes the comparison of tv_sec to yield the wrong
    result:
    
      wall_to_monotonic = { .tv_sec = -10, .tv_nsec =  900000000 }
      ts_delta          = { .tv_sec =  -9, .tv_nsec = -900000000 }
    
    That makes timespec64_compare() claim that wall_to_monotonic < ts_delta,
    but actually the result should be wall_to_monotonic > ts_delta.
    
    After normalization, the result of timespec64_compare() is correct because
    the tv_sec comparison is not longer misleading:
    
      wall_to_monotonic = { .tv_sec = -10, .tv_nsec =  900000000 }
      ts_delta          = { .tv_sec = -10, .tv_nsec =  100000000 }
    
    Use timespec64_sub() to ensure that ts_delta is normalized, which fixes the
    issue.
    
    Fixes: e1d7ba873555 ("time: Always make sure wall_to_monotonic isn't positive")
    Signed-off-by: Yu Liao <liaoyu15@huawei.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/20211213135727.1656662-1-liaoyu15@huawei.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 848a0e10fde6575bc3fa5253e9afc45444902cc7
Author: Yu Liao <liaoyu15@huawei.com>
Date:   Mon Dec 13 21:57:27 2021 +0800

    timekeeping: Really make sure wall_to_monotonic isn't positive
    
    commit 4e8c11b6b3f0b6a283e898344f154641eda94266 upstream.
    
    Even after commit e1d7ba873555 ("time: Always make sure wall_to_monotonic
    isn't positive") it is still possible to make wall_to_monotonic positive
    by running the following code:
    
        int main(void)
        {
            struct timespec time;
    
            clock_gettime(CLOCK_MONOTONIC, &time);
            time.tv_nsec = 0;
            clock_settime(CLOCK_REALTIME, &time);
            return 0;
        }
    
    The reason is that the second parameter of timespec64_compare(), ts_delta,
    may be unnormalized because the delta is calculated with an open coded
    substraction which causes the comparison of tv_sec to yield the wrong
    result:
    
      wall_to_monotonic = { .tv_sec = -10, .tv_nsec =  900000000 }
      ts_delta          = { .tv_sec =  -9, .tv_nsec = -900000000 }
    
    That makes timespec64_compare() claim that wall_to_monotonic < ts_delta,
    but actually the result should be wall_to_monotonic > ts_delta.
    
    After normalization, the result of timespec64_compare() is correct because
    the tv_sec comparison is not longer misleading:
    
      wall_to_monotonic = { .tv_sec = -10, .tv_nsec =  900000000 }
      ts_delta          = { .tv_sec = -10, .tv_nsec =  100000000 }
    
    Use timespec64_sub() to ensure that ts_delta is normalized, which fixes the
    issue.
    
    Fixes: e1d7ba873555 ("time: Always make sure wall_to_monotonic isn't positive")
    Signed-off-by: Yu Liao <liaoyu15@huawei.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/20211213135727.1656662-1-liaoyu15@huawei.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit ed5dc41bb48e82478525c08c87a4c88847e8570c
Author: Yu Liao <liaoyu15@huawei.com>
Date:   Mon Dec 13 21:57:27 2021 +0800

    timekeeping: Really make sure wall_to_monotonic isn't positive
    
    commit 4e8c11b6b3f0b6a283e898344f154641eda94266 upstream.
    
    Even after commit e1d7ba873555 ("time: Always make sure wall_to_monotonic
    isn't positive") it is still possible to make wall_to_monotonic positive
    by running the following code:
    
        int main(void)
        {
            struct timespec time;
    
            clock_gettime(CLOCK_MONOTONIC, &time);
            time.tv_nsec = 0;
            clock_settime(CLOCK_REALTIME, &time);
            return 0;
        }
    
    The reason is that the second parameter of timespec64_compare(), ts_delta,
    may be unnormalized because the delta is calculated with an open coded
    substraction which causes the comparison of tv_sec to yield the wrong
    result:
    
      wall_to_monotonic = { .tv_sec = -10, .tv_nsec =  900000000 }
      ts_delta          = { .tv_sec =  -9, .tv_nsec = -900000000 }
    
    That makes timespec64_compare() claim that wall_to_monotonic < ts_delta,
    but actually the result should be wall_to_monotonic > ts_delta.
    
    After normalization, the result of timespec64_compare() is correct because
    the tv_sec comparison is not longer misleading:
    
      wall_to_monotonic = { .tv_sec = -10, .tv_nsec =  900000000 }
      ts_delta          = { .tv_sec = -10, .tv_nsec =  100000000 }
    
    Use timespec64_sub() to ensure that ts_delta is normalized, which fixes the
    issue.
    
    Fixes: e1d7ba873555 ("time: Always make sure wall_to_monotonic isn't positive")
    Signed-off-by: Yu Liao <liaoyu15@huawei.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/20211213135727.1656662-1-liaoyu15@huawei.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit e1fe1b10e6aae5fb2df1c065e4fbe655c39e5065
Merge: 909e1d166ca8 4e8c11b6b3f0
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Dec 19 12:23:18 2021 -0800

    Merge tag 'timers_urgent_for_v5.16_rc6' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer fix from Borislav Petkov:
    
     - Make sure the CLOCK_REALTIME to CLOCK_MONOTONIC offset is never
       positive
    
    * tag 'timers_urgent_for_v5.16_rc6' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      timekeeping: Really make sure wall_to_monotonic isn't positive

commit 4e8c11b6b3f0b6a283e898344f154641eda94266
Author: Yu Liao <liaoyu15@huawei.com>
Date:   Mon Dec 13 21:57:27 2021 +0800

    timekeeping: Really make sure wall_to_monotonic isn't positive
    
    Even after commit e1d7ba873555 ("time: Always make sure wall_to_monotonic
    isn't positive") it is still possible to make wall_to_monotonic positive
    by running the following code:
    
        int main(void)
        {
            struct timespec time;
    
            clock_gettime(CLOCK_MONOTONIC, &time);
            time.tv_nsec = 0;
            clock_settime(CLOCK_REALTIME, &time);
            return 0;
        }
    
    The reason is that the second parameter of timespec64_compare(), ts_delta,
    may be unnormalized because the delta is calculated with an open coded
    substraction which causes the comparison of tv_sec to yield the wrong
    result:
    
      wall_to_monotonic = { .tv_sec = -10, .tv_nsec =  900000000 }
      ts_delta          = { .tv_sec =  -9, .tv_nsec = -900000000 }
    
    That makes timespec64_compare() claim that wall_to_monotonic < ts_delta,
    but actually the result should be wall_to_monotonic > ts_delta.
    
    After normalization, the result of timespec64_compare() is correct because
    the tv_sec comparison is not longer misleading:
    
      wall_to_monotonic = { .tv_sec = -10, .tv_nsec =  900000000 }
      ts_delta          = { .tv_sec = -10, .tv_nsec =  100000000 }
    
    Use timespec64_sub() to ensure that ts_delta is normalized, which fixes the
    issue.
    
    Fixes: e1d7ba873555 ("time: Always make sure wall_to_monotonic isn't positive")
    Signed-off-by: Yu Liao <liaoyu15@huawei.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/20211213135727.1656662-1-liaoyu15@huawei.com

commit dc2f7e9d8d20c0c407054596509e3d4316e2c9f3
Author: Holger Assmann <h.assmann@pengutronix.de>
Date:   Sun Nov 21 19:57:04 2021 +0200

    net: stmmac: retain PTP clock time during SIOCSHWTSTAMP ioctls
    
    [ Upstream commit a6da2bbb0005e6b4909472962c9d0af29e75dd06 ]
    
    Currently, when user space emits SIOCSHWTSTAMP ioctl calls such as
    enabling/disabling timestamping or changing filter settings, the driver
    reads the current CLOCK_REALTIME value and programming this into the
    NIC's hardware clock. This might be necessary during system
    initialization, but at runtime, when the PTP clock has already been
    synchronized to a grandmaster, a reset of the timestamp settings might
    result in a clock jump. Furthermore, if the clock is also controlled by
    phc2sys in automatic mode (where the UTC offset is queried from ptp4l),
    that UTC-to-TAI offset (currently 37 seconds in 2021) would be
    temporarily reset to 0, and it would take a long time for phc2sys to
    readjust so that CLOCK_REALTIME and the PHC are apart by 37 seconds
    again.
    
    To address the issue, we introduce a new function called
    stmmac_init_tstamp_counter(), which gets called during ndo_open().
    It contains the code snippet moved from stmmac_hwtstamp_set() that
    manages the time synchronization. Besides, the sub second increment
    configuration is also moved here since the related values are hardware
    dependent and runtime invariant.
    
    Furthermore, the hardware clock must be kept running even when no time
    stamping mode is selected in order to retain the synchronized time base.
    That way, timestamping can be enabled again at any time only with the
    need to compensate the clock's natural drifting.
    
    As a side effect, this patch fixes the issue that ptp_clock_info::enable
    can be called before SIOCSHWTSTAMP and the driver (which looks at
    priv->systime_flags) was not prepared to handle that ordering.
    
    Fixes: 92ba6888510c ("stmmac: add the support for PTP hw clock driver")
    Reported-by: Michael Olbrich <m.olbrich@pengutronix.de>
    Signed-off-by: Ahmad Fatoum <a.fatoum@pengutronix.de>
    Signed-off-by: Holger Assmann <h.assmann@pengutronix.de>
    Signed-off-by: Vladimir Oltean <vladimir.oltean@nxp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 8d196fa5a901239693bfcc119791cb8c3e18fa98
Author: Holger Assmann <h.assmann@pengutronix.de>
Date:   Sun Nov 21 19:57:04 2021 +0200

    net: stmmac: retain PTP clock time during SIOCSHWTSTAMP ioctls
    
    [ Upstream commit a6da2bbb0005e6b4909472962c9d0af29e75dd06 ]
    
    Currently, when user space emits SIOCSHWTSTAMP ioctl calls such as
    enabling/disabling timestamping or changing filter settings, the driver
    reads the current CLOCK_REALTIME value and programming this into the
    NIC's hardware clock. This might be necessary during system
    initialization, but at runtime, when the PTP clock has already been
    synchronized to a grandmaster, a reset of the timestamp settings might
    result in a clock jump. Furthermore, if the clock is also controlled by
    phc2sys in automatic mode (where the UTC offset is queried from ptp4l),
    that UTC-to-TAI offset (currently 37 seconds in 2021) would be
    temporarily reset to 0, and it would take a long time for phc2sys to
    readjust so that CLOCK_REALTIME and the PHC are apart by 37 seconds
    again.
    
    To address the issue, we introduce a new function called
    stmmac_init_tstamp_counter(), which gets called during ndo_open().
    It contains the code snippet moved from stmmac_hwtstamp_set() that
    manages the time synchronization. Besides, the sub second increment
    configuration is also moved here since the related values are hardware
    dependent and runtime invariant.
    
    Furthermore, the hardware clock must be kept running even when no time
    stamping mode is selected in order to retain the synchronized time base.
    That way, timestamping can be enabled again at any time only with the
    need to compensate the clock's natural drifting.
    
    As a side effect, this patch fixes the issue that ptp_clock_info::enable
    can be called before SIOCSHWTSTAMP and the driver (which looks at
    priv->systime_flags) was not prepared to handle that ordering.
    
    Fixes: 92ba6888510c ("stmmac: add the support for PTP hw clock driver")
    Reported-by: Michael Olbrich <m.olbrich@pengutronix.de>
    Signed-off-by: Ahmad Fatoum <a.fatoum@pengutronix.de>
    Signed-off-by: Holger Assmann <h.assmann@pengutronix.de>
    Signed-off-by: Vladimir Oltean <vladimir.oltean@nxp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit a6da2bbb0005e6b4909472962c9d0af29e75dd06
Author: Holger Assmann <h.assmann@pengutronix.de>
Date:   Sun Nov 21 19:57:04 2021 +0200

    net: stmmac: retain PTP clock time during SIOCSHWTSTAMP ioctls
    
    Currently, when user space emits SIOCSHWTSTAMP ioctl calls such as
    enabling/disabling timestamping or changing filter settings, the driver
    reads the current CLOCK_REALTIME value and programming this into the
    NIC's hardware clock. This might be necessary during system
    initialization, but at runtime, when the PTP clock has already been
    synchronized to a grandmaster, a reset of the timestamp settings might
    result in a clock jump. Furthermore, if the clock is also controlled by
    phc2sys in automatic mode (where the UTC offset is queried from ptp4l),
    that UTC-to-TAI offset (currently 37 seconds in 2021) would be
    temporarily reset to 0, and it would take a long time for phc2sys to
    readjust so that CLOCK_REALTIME and the PHC are apart by 37 seconds
    again.
    
    To address the issue, we introduce a new function called
    stmmac_init_tstamp_counter(), which gets called during ndo_open().
    It contains the code snippet moved from stmmac_hwtstamp_set() that
    manages the time synchronization. Besides, the sub second increment
    configuration is also moved here since the related values are hardware
    dependent and runtime invariant.
    
    Furthermore, the hardware clock must be kept running even when no time
    stamping mode is selected in order to retain the synchronized time base.
    That way, timestamping can be enabled again at any time only with the
    need to compensate the clock's natural drifting.
    
    As a side effect, this patch fixes the issue that ptp_clock_info::enable
    can be called before SIOCSHWTSTAMP and the driver (which looks at
    priv->systime_flags) was not prepared to handle that ordering.
    
    Fixes: 92ba6888510c ("stmmac: add the support for PTP hw clock driver")
    Reported-by: Michael Olbrich <m.olbrich@pengutronix.de>
    Signed-off-by: Ahmad Fatoum <a.fatoum@pengutronix.de>
    Signed-off-by: Holger Assmann <h.assmann@pengutronix.de>
    Signed-off-by: Vladimir Oltean <vladimir.oltean@nxp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 50c1df2b56e0f581b1dbf334dbf807d6fb8f77b2
Author: Jens Axboe <axboe@kernel.dk>
Date:   Fri Aug 27 17:11:06 2021 -0600

    io_uring: support CLOCK_BOOTTIME/REALTIME for timeouts
    
    Certain use cases want to use CLOCK_BOOTTIME or CLOCK_REALTIME rather than
    CLOCK_MONOTONIC, instead of the default CLOCK_MONOTONIC.
    
    Add an IORING_TIMEOUT_BOOTTIME and IORING_TIMEOUT_REALTIME flag that
    allows timeouts and linked timeouts to use the selected clock source.
    
    Only one clock source may be selected, and we -EINVAL the request if more
    than one is given. If neither BOOTIME nor REALTIME are selected, the
    previous default of MONOTONIC is used.
    
    Link: https://github.com/axboe/liburing/issues/369
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

commit 81d741d3460ca422843ce0ec8351083f259c6166
Author: Marcelo Tosatti <mtosatti@redhat.com>
Date:   Tue Jul 13 15:39:54 2021 +0200

    hrtimer: Avoid unnecessary SMP function calls in clock_was_set()
    
    Setting of clocks triggers an unconditional SMP function call on all online
    CPUs to reprogram the clock event device.
    
    However, only some clocks have their offsets updated and therefore
    potentially require a reprogram. That's CLOCK_REALTIME and CLOCK_TAI and in
    the case of resume (delayed sleep time injection) also CLOCK_BOOTTIME.
    
    Instead of sending an IPI unconditionally, check each per CPU hrtimer base
    whether it has active timers in the affected clock bases which are
    indicated by the caller in the @bases argument of clock_was_set().
    
    If that's not the case, skip the IPI and update the offsets remotely which
    ensures that any subsequently armed timers on the affected clocks are
    evaluated with the correct offsets.
    
    [ tglx: Adopted to the new bases argument, removed the softirq_active
            check, added comment, fixed up stale comment ]
    
    Signed-off-by: Marcelo Tosatti <mtosatti@redhat.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lore.kernel.org/r/20210713135158.787536542@linutronix.de

commit b00628b1c7d595ae5b544e059c27b1f5828314b4
Author: Alexei Starovoitov <ast@kernel.org>
Date:   Wed Jul 14 17:54:09 2021 -0700

    bpf: Introduce bpf timers.
    
    Introduce 'struct bpf_timer { __u64 :64; __u64 :64; };' that can be embedded
    in hash/array/lru maps as a regular field and helpers to operate on it:
    
    // Initialize the timer.
    // First 4 bits of 'flags' specify clockid.
    // Only CLOCK_MONOTONIC, CLOCK_REALTIME, CLOCK_BOOTTIME are allowed.
    long bpf_timer_init(struct bpf_timer *timer, struct bpf_map *map, int flags);
    
    // Configure the timer to call 'callback_fn' static function.
    long bpf_timer_set_callback(struct bpf_timer *timer, void *callback_fn);
    
    // Arm the timer to expire 'nsec' nanoseconds from the current time.
    long bpf_timer_start(struct bpf_timer *timer, u64 nsec, u64 flags);
    
    // Cancel the timer and wait for callback_fn to finish if it was running.
    long bpf_timer_cancel(struct bpf_timer *timer);
    
    Here is how BPF program might look like:
    struct map_elem {
        int counter;
        struct bpf_timer timer;
    };
    
    struct {
        __uint(type, BPF_MAP_TYPE_HASH);
        __uint(max_entries, 1000);
        __type(key, int);
        __type(value, struct map_elem);
    } hmap SEC(".maps");
    
    static int timer_cb(void *map, int *key, struct map_elem *val);
    /* val points to particular map element that contains bpf_timer. */
    
    SEC("fentry/bpf_fentry_test1")
    int BPF_PROG(test1, int a)
    {
        struct map_elem *val;
        int key = 0;
    
        val = bpf_map_lookup_elem(&hmap, &key);
        if (val) {
            bpf_timer_init(&val->timer, &hmap, CLOCK_REALTIME);
            bpf_timer_set_callback(&val->timer, timer_cb);
            bpf_timer_start(&val->timer, 1000 /* call timer_cb2 in 1 usec */, 0);
        }
    }
    
    This patch adds helper implementations that rely on hrtimers
    to call bpf functions as timers expire.
    The following patches add necessary safety checks.
    
    Only programs with CAP_BPF are allowed to use bpf_timer.
    
    The amount of timers used by the program is constrained by
    the memcg recorded at map creation time.
    
    The bpf_timer_init() helper needs explicit 'map' argument because inner maps
    are dynamic and not known at load time. While the bpf_timer_set_callback() is
    receiving hidden 'aux->prog' argument supplied by the verifier.
    
    The prog pointer is needed to do refcnting of bpf program to make sure that
    program doesn't get freed while the timer is armed. This approach relies on
    "user refcnt" scheme used in prog_array that stores bpf programs for
    bpf_tail_call. The bpf_timer_set_callback() will increment the prog refcnt which is
    paired with bpf_timer_cancel() that will drop the prog refcnt. The
    ops->map_release_uref is responsible for cancelling the timers and dropping
    prog refcnt when user space reference to a map reaches zero.
    This uref approach is done to make sure that Ctrl-C of user space process will
    not leave timers running forever unless the user space explicitly pinned a map
    that contained timers in bpffs.
    
    bpf_timer_init() and bpf_timer_set_callback() will return -EPERM if map doesn't
    have user references (is not held by open file descriptor from user space and
    not pinned in bpffs).
    
    The bpf_map_delete_elem() and bpf_map_update_elem() operations cancel
    and free the timer if given map element had it allocated.
    "bpftool map update" command can be used to cancel timers.
    
    The 'struct bpf_timer' is explicitly __attribute__((aligned(8))) because
    '__u64 :64' has 1 byte alignment of 8 byte padding.
    
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
    Acked-by: Martin KaFai Lau <kafai@fb.com>
    Acked-by: Andrii Nakryiko <andrii@kernel.org>
    Acked-by: Toke Høiland-Jørgensen <toke@redhat.com>
    Link: https://lore.kernel.org/bpf/20210715005417.78572-4-alexei.starovoitov@gmail.com

commit bf22a6976897977b0a3f1aeba6823c959fc4fdae
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Apr 22 21:44:23 2021 +0200

    futex: Provide FUTEX_LOCK_PI2 to support clock selection
    
    The FUTEX_LOCK_PI futex operand uses a CLOCK_REALTIME based absolute
    timeout since it was implemented, but it does not require that the
    FUTEX_CLOCK_REALTIME flag is set, because that was introduced later.
    
    In theory as none of the user space implementations can set the
    FUTEX_CLOCK_REALTIME flag on this operand, it would be possible to
    creatively abuse it and make the meaning invers, i.e. select CLOCK_REALTIME
    when not set and CLOCK_MONOTONIC when set. But that's a nasty hackery.
    
    Another option would be to have a new FUTEX_CLOCK_MONOTONIC flag only for
    FUTEX_LOCK_PI, but that's also awkward because it does not allow libraries
    to handle the timeout clock selection consistently.
    
    So provide a new FUTEX_LOCK_PI2 operand which implements the timeout
    semantics which the other operands use and leave FUTEX_LOCK_PI alone.
    
    Reported-by: Kurt Kanzenbach <kurt@linutronix.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Link: https://lore.kernel.org/r/20210422194705.440773992@linutronix.de

commit e112c41341c03d9224a9fc522bdb3539bc849b56
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Apr 22 21:44:22 2021 +0200

    futex: Prepare futex_lock_pi() for runtime clock selection
    
    futex_lock_pi() is the only futex operation which cannot select the clock
    for timeouts (CLOCK_MONOTONIC/CLOCK_REALTIME). That's inconsistent and
    there is no particular reason why this cannot be supported.
    
    This was overlooked when CLOCK_REALTIME_FLAG was introduced and
    unfortunately not reported when the inconsistency was discovered in glibc.
    
    Prepare the function and enforce the CLOCK_REALTIME_FLAG on FUTEX_LOCK_PI
    so that a new FUTEX_LOCK_PI2 can implement it correctly.
    
    Reported-by: Kurt Kanzenbach <kurt@linutronix.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Link: https://lore.kernel.org/r/20210422194705.338657741@linutronix.de

commit f724a7453bbfb8bb917735e315d5d902c0b67c33
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Apr 22 21:44:18 2021 +0200

    Revert 337f13046ff0 ("futex: Allow FUTEX_CLOCK_REALTIME with FUTEX_WAIT op")
    
    commit 4fbf5d6837bf81fd7a27d771358f4ee6c4f243f8 upstream.
    
    The FUTEX_WAIT operand has historically a relative timeout which means that
    the clock id is irrelevant as relative timeouts on CLOCK_REALTIME are not
    subject to wall clock changes and therefore are mapped by the kernel to
    CLOCK_MONOTONIC for simplicity.
    
    If a caller would set FUTEX_CLOCK_REALTIME for FUTEX_WAIT the timeout is
    still treated relative vs. CLOCK_MONOTONIC and then the wait arms that
    timeout based on CLOCK_REALTIME which is broken and obviously has never
    been used or even tested.
    
    Reject any attempt to use FUTEX_CLOCK_REALTIME with FUTEX_WAIT again.
    
    The desired functionality can be achieved with FUTEX_WAIT_BITSET and a
    FUTEX_BITSET_MATCH_ANY argument.
    
    Fixes: 337f13046ff0 ("futex: Allow FUTEX_CLOCK_REALTIME with FUTEX_WAIT op")
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/20210422194704.834797921@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 2ae7a44069c4d36757d0ad508fad91538d68423b
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Apr 22 21:44:18 2021 +0200

    Revert 337f13046ff0 ("futex: Allow FUTEX_CLOCK_REALTIME with FUTEX_WAIT op")
    
    commit 4fbf5d6837bf81fd7a27d771358f4ee6c4f243f8 upstream.
    
    The FUTEX_WAIT operand has historically a relative timeout which means that
    the clock id is irrelevant as relative timeouts on CLOCK_REALTIME are not
    subject to wall clock changes and therefore are mapped by the kernel to
    CLOCK_MONOTONIC for simplicity.
    
    If a caller would set FUTEX_CLOCK_REALTIME for FUTEX_WAIT the timeout is
    still treated relative vs. CLOCK_MONOTONIC and then the wait arms that
    timeout based on CLOCK_REALTIME which is broken and obviously has never
    been used or even tested.
    
    Reject any attempt to use FUTEX_CLOCK_REALTIME with FUTEX_WAIT again.
    
    The desired functionality can be achieved with FUTEX_WAIT_BITSET and a
    FUTEX_BITSET_MATCH_ANY argument.
    
    Fixes: 337f13046ff0 ("futex: Allow FUTEX_CLOCK_REALTIME with FUTEX_WAIT op")
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/20210422194704.834797921@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit a1eb878265b8ad200037fabe467d12d712445e1d
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Apr 22 21:44:18 2021 +0200

    Revert 337f13046ff0 ("futex: Allow FUTEX_CLOCK_REALTIME with FUTEX_WAIT op")
    
    commit 4fbf5d6837bf81fd7a27d771358f4ee6c4f243f8 upstream.
    
    The FUTEX_WAIT operand has historically a relative timeout which means that
    the clock id is irrelevant as relative timeouts on CLOCK_REALTIME are not
    subject to wall clock changes and therefore are mapped by the kernel to
    CLOCK_MONOTONIC for simplicity.
    
    If a caller would set FUTEX_CLOCK_REALTIME for FUTEX_WAIT the timeout is
    still treated relative vs. CLOCK_MONOTONIC and then the wait arms that
    timeout based on CLOCK_REALTIME which is broken and obviously has never
    been used or even tested.
    
    Reject any attempt to use FUTEX_CLOCK_REALTIME with FUTEX_WAIT again.
    
    The desired functionality can be achieved with FUTEX_WAIT_BITSET and a
    FUTEX_BITSET_MATCH_ANY argument.
    
    Fixes: 337f13046ff0 ("futex: Allow FUTEX_CLOCK_REALTIME with FUTEX_WAIT op")
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/20210422194704.834797921@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 13b5638e78d81e78c1cb1da72cdd00aaba88a2a8
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Apr 22 21:44:19 2021 +0200

    futex: Do not apply time namespace adjustment on FUTEX_LOCK_PI
    
    commit cdf78db4070967869e4d027c11f4dd825d8f815a upstream.
    
    FUTEX_LOCK_PI does not require to have the FUTEX_CLOCK_REALTIME bit set
    because it has been using CLOCK_REALTIME based absolute timeouts
    forever. Due to that, the time namespace adjustment which is applied when
    FUTEX_CLOCK_REALTIME is not set, will wrongly take place for FUTEX_LOCK_PI
    and wreckage the timeout.
    
    Exclude it from that procedure.
    
    Fixes: c2f7d08cccf4 ("futex: Adjust absolute futex timeouts with per time namespace offset")
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/20210422194704.984540159@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 600de799010689ad8d16f7b1932ca718809f0719
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Apr 22 21:44:18 2021 +0200

    Revert 337f13046ff0 ("futex: Allow FUTEX_CLOCK_REALTIME with FUTEX_WAIT op")
    
    commit 4fbf5d6837bf81fd7a27d771358f4ee6c4f243f8 upstream.
    
    The FUTEX_WAIT operand has historically a relative timeout which means that
    the clock id is irrelevant as relative timeouts on CLOCK_REALTIME are not
    subject to wall clock changes and therefore are mapped by the kernel to
    CLOCK_MONOTONIC for simplicity.
    
    If a caller would set FUTEX_CLOCK_REALTIME for FUTEX_WAIT the timeout is
    still treated relative vs. CLOCK_MONOTONIC and then the wait arms that
    timeout based on CLOCK_REALTIME which is broken and obviously has never
    been used or even tested.
    
    Reject any attempt to use FUTEX_CLOCK_REALTIME with FUTEX_WAIT again.
    
    The desired functionality can be achieved with FUTEX_WAIT_BITSET and a
    FUTEX_BITSET_MATCH_ANY argument.
    
    Fixes: 337f13046ff0 ("futex: Allow FUTEX_CLOCK_REALTIME with FUTEX_WAIT op")
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/20210422194704.834797921@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 0257bd28814c04d60f9a8c62aa2a697dd3afabe6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Apr 22 21:44:19 2021 +0200

    futex: Do not apply time namespace adjustment on FUTEX_LOCK_PI
    
    commit cdf78db4070967869e4d027c11f4dd825d8f815a upstream.
    
    FUTEX_LOCK_PI does not require to have the FUTEX_CLOCK_REALTIME bit set
    because it has been using CLOCK_REALTIME based absolute timeouts
    forever. Due to that, the time namespace adjustment which is applied when
    FUTEX_CLOCK_REALTIME is not set, will wrongly take place for FUTEX_LOCK_PI
    and wreckage the timeout.
    
    Exclude it from that procedure.
    
    Fixes: c2f7d08cccf4 ("futex: Adjust absolute futex timeouts with per time namespace offset")
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/20210422194704.984540159@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 7b626640ab2223f239a5367024df72f9970951ab
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Apr 22 21:44:18 2021 +0200

    Revert 337f13046ff0 ("futex: Allow FUTEX_CLOCK_REALTIME with FUTEX_WAIT op")
    
    commit 4fbf5d6837bf81fd7a27d771358f4ee6c4f243f8 upstream.
    
    The FUTEX_WAIT operand has historically a relative timeout which means that
    the clock id is irrelevant as relative timeouts on CLOCK_REALTIME are not
    subject to wall clock changes and therefore are mapped by the kernel to
    CLOCK_MONOTONIC for simplicity.
    
    If a caller would set FUTEX_CLOCK_REALTIME for FUTEX_WAIT the timeout is
    still treated relative vs. CLOCK_MONOTONIC and then the wait arms that
    timeout based on CLOCK_REALTIME which is broken and obviously has never
    been used or even tested.
    
    Reject any attempt to use FUTEX_CLOCK_REALTIME with FUTEX_WAIT again.
    
    The desired functionality can be achieved with FUTEX_WAIT_BITSET and a
    FUTEX_BITSET_MATCH_ANY argument.
    
    Fixes: 337f13046ff0 ("futex: Allow FUTEX_CLOCK_REALTIME with FUTEX_WAIT op")
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/20210422194704.834797921@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit d19a456acaec3de1ed64952fe21974ae0cff376f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Apr 22 21:44:19 2021 +0200

    futex: Do not apply time namespace adjustment on FUTEX_LOCK_PI
    
    commit cdf78db4070967869e4d027c11f4dd825d8f815a upstream.
    
    FUTEX_LOCK_PI does not require to have the FUTEX_CLOCK_REALTIME bit set
    because it has been using CLOCK_REALTIME based absolute timeouts
    forever. Due to that, the time namespace adjustment which is applied when
    FUTEX_CLOCK_REALTIME is not set, will wrongly take place for FUTEX_LOCK_PI
    and wreckage the timeout.
    
    Exclude it from that procedure.
    
    Fixes: c2f7d08cccf4 ("futex: Adjust absolute futex timeouts with per time namespace offset")
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/20210422194704.984540159@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 2543329485e2e0aec429535fa81065495b75dae9
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Apr 22 21:44:18 2021 +0200

    Revert 337f13046ff0 ("futex: Allow FUTEX_CLOCK_REALTIME with FUTEX_WAIT op")
    
    commit 4fbf5d6837bf81fd7a27d771358f4ee6c4f243f8 upstream.
    
    The FUTEX_WAIT operand has historically a relative timeout which means that
    the clock id is irrelevant as relative timeouts on CLOCK_REALTIME are not
    subject to wall clock changes and therefore are mapped by the kernel to
    CLOCK_MONOTONIC for simplicity.
    
    If a caller would set FUTEX_CLOCK_REALTIME for FUTEX_WAIT the timeout is
    still treated relative vs. CLOCK_MONOTONIC and then the wait arms that
    timeout based on CLOCK_REALTIME which is broken and obviously has never
    been used or even tested.
    
    Reject any attempt to use FUTEX_CLOCK_REALTIME with FUTEX_WAIT again.
    
    The desired functionality can be achieved with FUTEX_WAIT_BITSET and a
    FUTEX_BITSET_MATCH_ANY argument.
    
    Fixes: 337f13046ff0 ("futex: Allow FUTEX_CLOCK_REALTIME with FUTEX_WAIT op")
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/20210422194704.834797921@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 8d2be04dbb175eec4c107295d4d2deb529aff515
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Apr 22 21:44:18 2021 +0200

    Revert 337f13046ff0 ("futex: Allow FUTEX_CLOCK_REALTIME with FUTEX_WAIT op")
    
    commit 4fbf5d6837bf81fd7a27d771358f4ee6c4f243f8 upstream.
    
    The FUTEX_WAIT operand has historically a relative timeout which means that
    the clock id is irrelevant as relative timeouts on CLOCK_REALTIME are not
    subject to wall clock changes and therefore are mapped by the kernel to
    CLOCK_MONOTONIC for simplicity.
    
    If a caller would set FUTEX_CLOCK_REALTIME for FUTEX_WAIT the timeout is
    still treated relative vs. CLOCK_MONOTONIC and then the wait arms that
    timeout based on CLOCK_REALTIME which is broken and obviously has never
    been used or even tested.
    
    Reject any attempt to use FUTEX_CLOCK_REALTIME with FUTEX_WAIT again.
    
    The desired functionality can be achieved with FUTEX_WAIT_BITSET and a
    FUTEX_BITSET_MATCH_ANY argument.
    
    Fixes: 337f13046ff0 ("futex: Allow FUTEX_CLOCK_REALTIME with FUTEX_WAIT op")
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/20210422194704.834797921@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 732a27a0891cb5db1a0f9c33a018ea6eca9a4023
Merge: 85bbba1c0778 51cf94d16860
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun May 9 13:07:03 2021 -0700

    Merge tag 'locking-urgent-2021-05-09' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull locking fixes from Thomas Gleixner:
     "A set of locking related fixes and updates:
    
       - Two fixes for the futex syscall related to the timeout handling.
    
         FUTEX_LOCK_PI does not support the FUTEX_CLOCK_REALTIME bit and
         because it's not set the time namespace adjustment for clock
         MONOTONIC is applied wrongly.
    
         FUTEX_WAIT cannot support the FUTEX_CLOCK_REALTIME bit because its
         always a relative timeout.
    
       - Cleanups in the futex syscall entry points which became obvious
         when the two timeout handling bugs were fixed.
    
       - Cleanup of queued_write_lock_slowpath() as suggested by Linus
    
       - Fixup of the smp_call_function_single_async() prototype"
    
    * tag 'locking-urgent-2021-05-09' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      futex: Make syscall entry points less convoluted
      futex: Get rid of the val2 conditional dance
      futex: Do not apply time namespace adjustment on FUTEX_LOCK_PI
      Revert 337f13046ff0 ("futex: Allow FUTEX_CLOCK_REALTIME with FUTEX_WAIT op")
      locking/qrwlock: Cleanup queued_write_lock_slowpath()
      smp: Fix smp_call_function_single_async prototype

commit cdf78db4070967869e4d027c11f4dd825d8f815a
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Apr 22 21:44:19 2021 +0200

    futex: Do not apply time namespace adjustment on FUTEX_LOCK_PI
    
    FUTEX_LOCK_PI does not require to have the FUTEX_CLOCK_REALTIME bit set
    because it has been using CLOCK_REALTIME based absolute timeouts
    forever. Due to that, the time namespace adjustment which is applied when
    FUTEX_CLOCK_REALTIME is not set, will wrongly take place for FUTEX_LOCK_PI
    and wreckage the timeout.
    
    Exclude it from that procedure.
    
    Fixes: c2f7d08cccf4 ("futex: Adjust absolute futex timeouts with per time namespace offset")
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/20210422194704.984540159@linutronix.de

commit 4fbf5d6837bf81fd7a27d771358f4ee6c4f243f8
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Apr 22 21:44:18 2021 +0200

    Revert 337f13046ff0 ("futex: Allow FUTEX_CLOCK_REALTIME with FUTEX_WAIT op")
    
    The FUTEX_WAIT operand has historically a relative timeout which means that
    the clock id is irrelevant as relative timeouts on CLOCK_REALTIME are not
    subject to wall clock changes and therefore are mapped by the kernel to
    CLOCK_MONOTONIC for simplicity.
    
    If a caller would set FUTEX_CLOCK_REALTIME for FUTEX_WAIT the timeout is
    still treated relative vs. CLOCK_MONOTONIC and then the wait arms that
    timeout based on CLOCK_REALTIME which is broken and obviously has never
    been used or even tested.
    
    Reject any attempt to use FUTEX_CLOCK_REALTIME with FUTEX_WAIT again.
    
    The desired functionality can be achieved with FUTEX_WAIT_BITSET and a
    FUTEX_BITSET_MATCH_ANY argument.
    
    Fixes: 337f13046ff0 ("futex: Allow FUTEX_CLOCK_REALTIME with FUTEX_WAIT op")
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/20210422194704.834797921@linutronix.de

commit 5e38bd7c7a1f158cb753dd5eee20520ed2069a4f
Author: Anna-Maria Behnsen <anna-maria@linutronix.de>
Date:   Tue Feb 23 17:02:40 2021 +0100

    hrtimer: Update softirq_expires_next correctly after __hrtimer_get_next_event()
    
    [ Upstream commit 46eb1701c046cc18c032fa68f3c8ccbf24483ee4 ]
    
    hrtimer_force_reprogram() and hrtimer_interrupt() invokes
    __hrtimer_get_next_event() to find the earliest expiry time of hrtimer
    bases. __hrtimer_get_next_event() does not update
    cpu_base::[softirq_]_expires_next to preserve reprogramming logic. That
    needs to be done at the callsites.
    
    hrtimer_force_reprogram() updates cpu_base::softirq_expires_next only when
    the first expiring timer is a softirq timer and the soft interrupt is not
    activated. That's wrong because cpu_base::softirq_expires_next is left
    stale when the first expiring timer of all bases is a timer which expires
    in hard interrupt context. hrtimer_interrupt() does never update
    cpu_base::softirq_expires_next which is wrong too.
    
    That becomes a problem when clock_settime() sets CLOCK_REALTIME forward and
    the first soft expiring timer is in the CLOCK_REALTIME_SOFT base. Setting
    CLOCK_REALTIME forward moves the clock MONOTONIC based expiry time of that
    timer before the stale cpu_base::softirq_expires_next.
    
    cpu_base::softirq_expires_next is cached to make the check for raising the
    soft interrupt fast. In the above case the soft interrupt won't be raised
    until clock monotonic reaches the stale cpu_base::softirq_expires_next
    value. That's incorrect, but what's worse it that if the softirq timer
    becomes the first expiring timer of all clock bases after the hard expiry
    timer has been handled the reprogramming of the clockevent from
    hrtimer_interrupt() will result in an interrupt storm. That happens because
    the reprogramming does not use cpu_base::softirq_expires_next, it uses
    __hrtimer_get_next_event() which returns the actual expiry time. Once clock
    MONOTONIC reaches cpu_base::softirq_expires_next the soft interrupt is
    raised and the storm subsides.
    
    Change the logic in hrtimer_force_reprogram() to evaluate the soft and hard
    bases seperately, update softirq_expires_next and handle the case when a
    soft expiring timer is the first of all bases by comparing the expiry times
    and updating the required cpu base fields. Split this functionality into a
    separate function to be able to use it in hrtimer_interrupt() as well
    without copy paste.
    
    Fixes: 5da70160462e ("hrtimer: Implement support for softirq based hrtimers")
    Reported-by: Mikael Beckius <mikael.beckius@windriver.com>
    Suggested-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Mikael Beckius <mikael.beckius@windriver.com>
    Signed-off-by: Anna-Maria Behnsen <anna-maria@linutronix.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Link: https://lore.kernel.org/r/20210223160240.27518-1-anna-maria@linutronix.de
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit df7dbfc24c33ec719f0440c92c79a995b8505c52
Author: Anna-Maria Behnsen <anna-maria@linutronix.de>
Date:   Tue Feb 23 17:02:40 2021 +0100

    hrtimer: Update softirq_expires_next correctly after __hrtimer_get_next_event()
    
    [ Upstream commit 46eb1701c046cc18c032fa68f3c8ccbf24483ee4 ]
    
    hrtimer_force_reprogram() and hrtimer_interrupt() invokes
    __hrtimer_get_next_event() to find the earliest expiry time of hrtimer
    bases. __hrtimer_get_next_event() does not update
    cpu_base::[softirq_]_expires_next to preserve reprogramming logic. That
    needs to be done at the callsites.
    
    hrtimer_force_reprogram() updates cpu_base::softirq_expires_next only when
    the first expiring timer is a softirq timer and the soft interrupt is not
    activated. That's wrong because cpu_base::softirq_expires_next is left
    stale when the first expiring timer of all bases is a timer which expires
    in hard interrupt context. hrtimer_interrupt() does never update
    cpu_base::softirq_expires_next which is wrong too.
    
    That becomes a problem when clock_settime() sets CLOCK_REALTIME forward and
    the first soft expiring timer is in the CLOCK_REALTIME_SOFT base. Setting
    CLOCK_REALTIME forward moves the clock MONOTONIC based expiry time of that
    timer before the stale cpu_base::softirq_expires_next.
    
    cpu_base::softirq_expires_next is cached to make the check for raising the
    soft interrupt fast. In the above case the soft interrupt won't be raised
    until clock monotonic reaches the stale cpu_base::softirq_expires_next
    value. That's incorrect, but what's worse it that if the softirq timer
    becomes the first expiring timer of all clock bases after the hard expiry
    timer has been handled the reprogramming of the clockevent from
    hrtimer_interrupt() will result in an interrupt storm. That happens because
    the reprogramming does not use cpu_base::softirq_expires_next, it uses
    __hrtimer_get_next_event() which returns the actual expiry time. Once clock
    MONOTONIC reaches cpu_base::softirq_expires_next the soft interrupt is
    raised and the storm subsides.
    
    Change the logic in hrtimer_force_reprogram() to evaluate the soft and hard
    bases seperately, update softirq_expires_next and handle the case when a
    soft expiring timer is the first of all bases by comparing the expiry times
    and updating the required cpu base fields. Split this functionality into a
    separate function to be able to use it in hrtimer_interrupt() as well
    without copy paste.
    
    Fixes: 5da70160462e ("hrtimer: Implement support for softirq based hrtimers")
    Reported-by: Mikael Beckius <mikael.beckius@windriver.com>
    Suggested-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Mikael Beckius <mikael.beckius@windriver.com>
    Signed-off-by: Anna-Maria Behnsen <anna-maria@linutronix.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Link: https://lore.kernel.org/r/20210223160240.27518-1-anna-maria@linutronix.de
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit aaf92d0538d2f2d6cbb0a1ff6be704d5967d47f0
Author: Anna-Maria Behnsen <anna-maria@linutronix.de>
Date:   Tue Feb 23 17:02:40 2021 +0100

    hrtimer: Update softirq_expires_next correctly after __hrtimer_get_next_event()
    
    [ Upstream commit 46eb1701c046cc18c032fa68f3c8ccbf24483ee4 ]
    
    hrtimer_force_reprogram() and hrtimer_interrupt() invokes
    __hrtimer_get_next_event() to find the earliest expiry time of hrtimer
    bases. __hrtimer_get_next_event() does not update
    cpu_base::[softirq_]_expires_next to preserve reprogramming logic. That
    needs to be done at the callsites.
    
    hrtimer_force_reprogram() updates cpu_base::softirq_expires_next only when
    the first expiring timer is a softirq timer and the soft interrupt is not
    activated. That's wrong because cpu_base::softirq_expires_next is left
    stale when the first expiring timer of all bases is a timer which expires
    in hard interrupt context. hrtimer_interrupt() does never update
    cpu_base::softirq_expires_next which is wrong too.
    
    That becomes a problem when clock_settime() sets CLOCK_REALTIME forward and
    the first soft expiring timer is in the CLOCK_REALTIME_SOFT base. Setting
    CLOCK_REALTIME forward moves the clock MONOTONIC based expiry time of that
    timer before the stale cpu_base::softirq_expires_next.
    
    cpu_base::softirq_expires_next is cached to make the check for raising the
    soft interrupt fast. In the above case the soft interrupt won't be raised
    until clock monotonic reaches the stale cpu_base::softirq_expires_next
    value. That's incorrect, but what's worse it that if the softirq timer
    becomes the first expiring timer of all clock bases after the hard expiry
    timer has been handled the reprogramming of the clockevent from
    hrtimer_interrupt() will result in an interrupt storm. That happens because
    the reprogramming does not use cpu_base::softirq_expires_next, it uses
    __hrtimer_get_next_event() which returns the actual expiry time. Once clock
    MONOTONIC reaches cpu_base::softirq_expires_next the soft interrupt is
    raised and the storm subsides.
    
    Change the logic in hrtimer_force_reprogram() to evaluate the soft and hard
    bases seperately, update softirq_expires_next and handle the case when a
    soft expiring timer is the first of all bases by comparing the expiry times
    and updating the required cpu base fields. Split this functionality into a
    separate function to be able to use it in hrtimer_interrupt() as well
    without copy paste.
    
    Fixes: 5da70160462e ("hrtimer: Implement support for softirq based hrtimers")
    Reported-by: Mikael Beckius <mikael.beckius@windriver.com>
    Suggested-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Mikael Beckius <mikael.beckius@windriver.com>
    Signed-off-by: Anna-Maria Behnsen <anna-maria@linutronix.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Link: https://lore.kernel.org/r/20210223160240.27518-1-anna-maria@linutronix.de
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit eda5858d4867f1681b42e8b13e5eac3fba29e915
Author: Anna-Maria Behnsen <anna-maria@linutronix.de>
Date:   Tue Feb 23 17:02:40 2021 +0100

    hrtimer: Update softirq_expires_next correctly after __hrtimer_get_next_event()
    
    [ Upstream commit 46eb1701c046cc18c032fa68f3c8ccbf24483ee4 ]
    
    hrtimer_force_reprogram() and hrtimer_interrupt() invokes
    __hrtimer_get_next_event() to find the earliest expiry time of hrtimer
    bases. __hrtimer_get_next_event() does not update
    cpu_base::[softirq_]_expires_next to preserve reprogramming logic. That
    needs to be done at the callsites.
    
    hrtimer_force_reprogram() updates cpu_base::softirq_expires_next only when
    the first expiring timer is a softirq timer and the soft interrupt is not
    activated. That's wrong because cpu_base::softirq_expires_next is left
    stale when the first expiring timer of all bases is a timer which expires
    in hard interrupt context. hrtimer_interrupt() does never update
    cpu_base::softirq_expires_next which is wrong too.
    
    That becomes a problem when clock_settime() sets CLOCK_REALTIME forward and
    the first soft expiring timer is in the CLOCK_REALTIME_SOFT base. Setting
    CLOCK_REALTIME forward moves the clock MONOTONIC based expiry time of that
    timer before the stale cpu_base::softirq_expires_next.
    
    cpu_base::softirq_expires_next is cached to make the check for raising the
    soft interrupt fast. In the above case the soft interrupt won't be raised
    until clock monotonic reaches the stale cpu_base::softirq_expires_next
    value. That's incorrect, but what's worse it that if the softirq timer
    becomes the first expiring timer of all clock bases after the hard expiry
    timer has been handled the reprogramming of the clockevent from
    hrtimer_interrupt() will result in an interrupt storm. That happens because
    the reprogramming does not use cpu_base::softirq_expires_next, it uses
    __hrtimer_get_next_event() which returns the actual expiry time. Once clock
    MONOTONIC reaches cpu_base::softirq_expires_next the soft interrupt is
    raised and the storm subsides.
    
    Change the logic in hrtimer_force_reprogram() to evaluate the soft and hard
    bases seperately, update softirq_expires_next and handle the case when a
    soft expiring timer is the first of all bases by comparing the expiry times
    and updating the required cpu base fields. Split this functionality into a
    separate function to be able to use it in hrtimer_interrupt() as well
    without copy paste.
    
    Fixes: 5da70160462e ("hrtimer: Implement support for softirq based hrtimers")
    Reported-by: Mikael Beckius <mikael.beckius@windriver.com>
    Suggested-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Mikael Beckius <mikael.beckius@windriver.com>
    Signed-off-by: Anna-Maria Behnsen <anna-maria@linutronix.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Link: https://lore.kernel.org/r/20210223160240.27518-1-anna-maria@linutronix.de
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit b603e810f740e76b6a67089c06d7f4442b187a9a
Author: Simon Ser <contact@emersion.fr>
Date:   Thu Mar 4 23:08:37 2021 +0100

    drm/uapi: document kernel capabilities
    
    Document all of the DRM_CAP_* defines.
    
    v2 (Pekka):
    - Describe what the bit depth is
    - Expand on preferred dumb buffer memory access patterns
    - Explain what a PRIME buffer is
    - Mention DRM_IOCTL_PRIME_FD_TO_HANDLE and DRM_IOCTL_PRIME_HANDLE_TO_FD
    - Explicitly reference CLOCK_REALTIME and CLOCK_MONOTONIC
    - Make it clear DRM_CAP_CRTC_IN_VBLANK_EVENT applies to both DRM_EVENT_VBLANK
      and DRM_EVENT_FLIP_COMPLETE
    
    v3 (Daniel):
    - Specify kernel versions for caps that don't depend on drivers
    - Make it clear dumb buffers caps are only about dumb buffers
    
    Signed-off-by: Simon Ser <contact@emersion.fr>
    Acked-by: Daniel Vetter <daniel@ffwll.ch>
    Reviewed-by: Pekka Paalanen <pekka.paalanen@collabora.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20210308123421.747836-1-contact@emersion.fr

commit 46eb1701c046cc18c032fa68f3c8ccbf24483ee4
Author: Anna-Maria Behnsen <anna-maria@linutronix.de>
Date:   Tue Feb 23 17:02:40 2021 +0100

    hrtimer: Update softirq_expires_next correctly after __hrtimer_get_next_event()
    
    hrtimer_force_reprogram() and hrtimer_interrupt() invokes
    __hrtimer_get_next_event() to find the earliest expiry time of hrtimer
    bases. __hrtimer_get_next_event() does not update
    cpu_base::[softirq_]_expires_next to preserve reprogramming logic. That
    needs to be done at the callsites.
    
    hrtimer_force_reprogram() updates cpu_base::softirq_expires_next only when
    the first expiring timer is a softirq timer and the soft interrupt is not
    activated. That's wrong because cpu_base::softirq_expires_next is left
    stale when the first expiring timer of all bases is a timer which expires
    in hard interrupt context. hrtimer_interrupt() does never update
    cpu_base::softirq_expires_next which is wrong too.
    
    That becomes a problem when clock_settime() sets CLOCK_REALTIME forward and
    the first soft expiring timer is in the CLOCK_REALTIME_SOFT base. Setting
    CLOCK_REALTIME forward moves the clock MONOTONIC based expiry time of that
    timer before the stale cpu_base::softirq_expires_next.
    
    cpu_base::softirq_expires_next is cached to make the check for raising the
    soft interrupt fast. In the above case the soft interrupt won't be raised
    until clock monotonic reaches the stale cpu_base::softirq_expires_next
    value. That's incorrect, but what's worse it that if the softirq timer
    becomes the first expiring timer of all clock bases after the hard expiry
    timer has been handled the reprogramming of the clockevent from
    hrtimer_interrupt() will result in an interrupt storm. That happens because
    the reprogramming does not use cpu_base::softirq_expires_next, it uses
    __hrtimer_get_next_event() which returns the actual expiry time. Once clock
    MONOTONIC reaches cpu_base::softirq_expires_next the soft interrupt is
    raised and the storm subsides.
    
    Change the logic in hrtimer_force_reprogram() to evaluate the soft and hard
    bases seperately, update softirq_expires_next and handle the case when a
    soft expiring timer is the first of all bases by comparing the expiry times
    and updating the required cpu base fields. Split this functionality into a
    separate function to be able to use it in hrtimer_interrupt() as well
    without copy paste.
    
    Fixes: 5da70160462e ("hrtimer: Implement support for softirq based hrtimers")
    Reported-by: Mikael Beckius <mikael.beckius@windriver.com>
    Suggested-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Mikael Beckius <mikael.beckius@windriver.com>
    Signed-off-by: Anna-Maria Behnsen <anna-maria@linutronix.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Link: https://lore.kernel.org/r/20210223160240.27518-1-anna-maria@linutronix.de

commit f405ac83fa252dd0e346f2715b66e7d2adba9027
Author: Tobias Klauser <tklauser@distanz.ch>
Date:   Thu Feb 4 15:50:42 2021 +0100

    selftests/vDSO: fix ABI selftest on riscv
    
    Only older versions of the RISC-V GCC toolchain define __riscv__. Check
    for __riscv as well, which is used by newer GCC toolchains. Also set
    VDSO_32BIT based on __riscv_xlen.
    
    Before (on riscv64):
    
    $ ./vdso_test_abi
    [vDSO kselftest] VDSO_VERSION: LINUX_4
    Could not find __vdso_gettimeofday
    Could not find __vdso_clock_gettime
    Could not find __vdso_clock_getres
    clock_id: CLOCK_REALTIME [PASS]
    Could not find __vdso_clock_gettime
    Could not find __vdso_clock_getres
    clock_id: CLOCK_BOOTTIME [PASS]
    Could not find __vdso_clock_gettime
    Could not find __vdso_clock_getres
    clock_id: CLOCK_TAI [PASS]
    Could not find __vdso_clock_gettime
    Could not find __vdso_clock_getres
    clock_id: CLOCK_REALTIME_COARSE [PASS]
    Could not find __vdso_clock_gettime
    Could not find __vdso_clock_getres
    clock_id: CLOCK_MONOTONIC [PASS]
    Could not find __vdso_clock_gettime
    Could not find __vdso_clock_getres
    clock_id: CLOCK_MONOTONIC_RAW [PASS]
    Could not find __vdso_clock_gettime
    Could not find __vdso_clock_getres
    clock_id: CLOCK_MONOTONIC_COARSE [PASS]
    Could not find __vdso_time
    
    After (on riscv32):
    
    $ ./vdso_test_abi
    [vDSO kselftest] VDSO_VERSION: LINUX_4.15
    The time is 1612449376.015086
    The time is 1612449376.18340784
    The resolution is 0 1
    clock_id: CLOCK_REALTIME [PASS]
    The time is 774.842586182
    The resolution is 0 1
    clock_id: CLOCK_BOOTTIME [PASS]
    The time is 1612449376.22536565
    The resolution is 0 1
    clock_id: CLOCK_TAI [PASS]
    The time is 1612449376.20885172
    The resolution is 0 4000000
    clock_id: CLOCK_REALTIME_COARSE [PASS]
    The time is 774.845491269
    The resolution is 0 1
    clock_id: CLOCK_MONOTONIC [PASS]
    The time is 774.849534200
    The resolution is 0 1
    clock_id: CLOCK_MONOTONIC_RAW [PASS]
    The time is 774.842139684
    The resolution is 0 4000000
    clock_id: CLOCK_MONOTONIC_COARSE [PASS]
    Could not find __vdso_time
    
    Signed-off-by: Tobias Klauser <tklauser@distanz.ch>
    Reviewed-by: Palmer Dabbelt <palmerdabbelt@google.com>
    Acked-by: Palmer Dabbelt <palmerdabbelt@google.com>
    Acked-by: Vincenzo Frascino <vincenzo.frascino@arm.com>
    Signed-off-by: Shuah Khan <skhan@linuxfoundation.org>

commit 26d060e47e25f2c715a1b2c48fea391f67907a30
Author: Kent Gibson <warthog618@gmail.com>
Date:   Thu Oct 15 07:11:56 2020 +0800

    gpiolib: cdev: allow edge event timestamps to be configured as REALTIME
    
    Using CLOCK_REALTIME as the source for event timestamps is crucial for
    some specific applications, particularly those requiring timetamps
    relative to a PTP clock, so provide an option to switch the event
    timestamp source from the default CLOCK_MONOTONIC to CLOCK_REALTIME.
    
    Note that CLOCK_REALTIME was the default source clock for GPIO until
    Linux 5.7 when it was changed to CLOCK_MONOTONIC due to issues with the
    shifting of the realtime clock.
    Providing this option maintains the CLOCK_MONOTONIC as the default,
    while also providing a path forward for those dependent on the pre-5.7
    behaviour.
    
    Suggested-by: Jack Winch <sunt.un.morcov@gmail.com>
    Signed-off-by: Kent Gibson <warthog618@gmail.com>
    Link: https://lore.kernel.org/r/20201014231158.34117-2-warthog618@gmail.com
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

commit ea84c842900872f5b8d6d4754cf0fa37d6672011
Merge: 1248dc00fb62 461d6d058cff
Author: David S. Miller <davem@davemloft.net>
Date:   Mon May 4 12:02:03 2020 -0700

    Merge branch 'net-ethernet-ti-k3-introduce-common-platform-time-sync-driver-cpts'
    
    Grygorii Strashko says:
    
    ====================
    net: ethernet: ti: k3: introduce common platform time sync driver - cpts
    
    This series introduced support for significantly upgraded TI A65x/J721E Common
    platform time sync (CPTS) modules which are part of AM65xx Time Synchronization
    Architecture [1].
    The TI A65x/J721E now contain more than one CPTS instance:
    - MCU CPSW CPTS (IEEE 1588 compliant)
    - Main NAVSS CPTS (central)
    - PCIe CPTS(s) (PTM  compliant)
    - J721E: Main CPSW9g CPTS (IEEE 1588 compliant)
    which can work as separately as interact to each other through Time Sync Router
    (TSR) and Compare Event Router (CER). In addition there are also ICSS-G IEP
    blocks which can perform similar timsync functions, but require FW support.
    More info also available in TRM [2][3]. Not all above modules are available
    to the Linux by as of now as some of them are reserved for RTOS/FW purposes.
    
    The scope of this submission is TI A65x/J721E CPSW CPTS and Main NAVSS CPTS,
    and TSR was used for testing purposes.
                                                                           +---------------------------+
                                                                           | MCU CPSW                  |
    +-------------------+           +------------------------+             |                TS         |
    | Main Navss CPTS   |           | Time Sync Router (TSR) |             |          +-------------+  |
    |                   |           |                        |             |          |             |  |
    |            HW1_TS +<----------+                        |             | +--------v-----+    +--+--+
    |                   |           |                        |             | |        CPTS  |    |Port |
    |              ...  |           |                        |           X+-->HW1_TS        |    |     |
    |            HW8_TS <------------<---------+             |           X|-->HW2_TS        |    +--^--+
    |                   |           |          |             +--------------->HW3_TS        |       |  |
    |                   |           |          |             +--------------->HW4_TS        |       |  |
    |                   |           |          |             |             | |              |       |  |
    |                   |           |          |             |             | |              |       |  |
    |            Genf0  +----------->          (A)---------+ +<--------------+Genf0         |       |  |
    |                   |           |          |             |             | |              |       |  |
    |              ...  |           |          +-----------> <---------------+Genf1     ESTf+-------+  |
    |                   |           |                        |             | |              |          |
    |                   |           |                        |             | +--------------+          |
    |            Genf8  +---------->+                        |             |                           |
    |                   |           |    SYNC0 ...    SYNC3  |             |                           |
    +-------------------+           +------+------------+----+             +---------------------------+
                                           +            +
                                           X            X
    (A) shows possible routing path for MCU CPSW CPTS Genf0 signal as an example.
    
    Main features of the new TI A65x/J721E CPTS modules are:
    - 64-bit timestamp/counter mode support in ns by using add_val
    - implemented in HW PPM and nudge adjustment.
    - control of time sync events via interrupt or polling
    - selection of multiple external reference clock sources
    - hardware timestamp of ext. inputs events (HWx_TS_PUSH)
    - periodic generator function outputs (TS_GENFx)
    - (CPSW only) Ethernet Enhanced Scheduled Traffic Operations (CPTS_ESTFn),
      which drives TSN schedule
    - timestamping of all RX packets bypassing CPTS FIFO
    
    Patch 1 - DT bindings
    Patch 2 - the AM65x/J721E driver
    Patch 3 - enables packet timestamping support in TI AM65x/J721E MCU CPSW driver.
    Patches 4-7 - DT updates.
    
    === PTP Testing:
    
    phc2sys -s CLOCK_REALTIME -c eth0 -m -O 0 -u30
    phc2sys[627.331]: eth0 rms 409912446712787392 max 1587584079521858304 freq  -6665 +/- 35040 delay   832 +/-  27
    phc2sys[657.335]: eth0 rms   33 max   66 freq     -0 +/-  28 delay   820 +/-  30
    phc2sys[687.339]: eth0 rms   37 max   70 freq     -1 +/-  32 delay   830 +/-  29
    phc2sys[717.343]: eth0 rms   33 max   71 freq     -0 +/-  29 delay   828 +/-  23
    phc2sys[747.346]: eth0 rms   35 max   75 freq     -0 +/-  31 delay   829 +/-  26
    phc2sys[777.350]: eth0 rms   37 max   68 freq     -1 +/-  32 delay   825 +/-  25
    phc2sys[807.354]: eth0 rms   28 max   57 freq     -1 +/-  25 delay   824 +/-  21
    phc2sys[837.358]: eth0 rms   43 max   81 freq     -1 +/-  37 delay   836 +/-  23
    phc2sys[867.361]: eth0 rms   33 max   74 freq     +0 +/-  29 delay   828 +/-  24
    phc2sys[897.365]: eth0 rms   35 max   77 freq     -2 +/-  30 delay   824 +/-  25
    phc2sys[927.369]: eth0 rms   28 max   50 freq     +0 +/-  25 delay   825 +/-  25
    
    ptp4l -P -2 -H -i eth0 -l 6 -m -q -p /dev/ptp1 -f ptp.cfg -s
    ptp4l[22095.754]: port 1: MASTER to UNCALIBRATED on RS_SLAVE
    ptp4l[22097.754]: port 1: UNCALIBRATED to SLAVE on MASTER_CLOCK_SELECTED
    ptp4l[22159.757]: rms  317 max 1418 freq    +79 +/- 186 delay   410 +/-   1
    ptp4l[22223.760]: rms    9 max   24 freq    +42 +/-  12 delay   409 +/-   1
    ptp4l[22287.763]: rms   10 max   28 freq    +41 +/-  11 delay   410 +/-   1
    ptp4l[22351.767]: rms   10 max   26 freq    +34 +/-  12 delay   410 +/-   1
    ptp4l[22415.770]: rms   10 max   26 freq    +49 +/-  14 delay   410 +/-   1
    
    === Ext. HW_TS and Genf testing:
    
    For testing purposes Time Sync Router (TSR) can be modeled in DT as pin controller
    +       timesync_router: timesync_router@A40000 {
    +               compatible = "pinctrl-single";
    +               reg = <0x0 0xA40000 0x0 0x800>;
    +               #address-cells = <1>;
    +               #size-cells = <0>;
    +               #pinctrl-cells = <1>;
    +               pinctrl-single,register-width = <32>;
    +               pinctrl-single,function-mask = <0x800007ff>;
    +       };
    
    then signals routing can be done in board file, for example:
    +#define TS_OFFSET(pa, val)     (0x4+(pa)*4) (0x80000000 | val)
    +
    +&timesync_router {
    +       pinctrl-names = "default";
    +       pinctrl-0 = <&mcu_cpts>;
    +
    +       /* Example of the timesync routing */
    +       mcu_cpts: mcu_cpts {
    +               pinctrl-single,pins = <
    +                       /* [cpts genf1] in13 -> out25 [cpts hw4_push] */
    +                       TS_OFFSET(25, 13)
    +                       /* [cpts genf1] in13 -> out0 [main cpts hw1_push] */
    +                       TS_OFFSET(0, 13)
    +                       /* [main cpts genf0] in4 -> out1 [main cpts hw2_push] */
    +                       TS_OFFSET(1, 4)
    +                       /* [main cpts genf0] in4 -> out24 [cpts hw3_push] */
    +                       TS_OFFSET(24, 4)
    +               >;
    +       };
    +};
    
    will create link:
        cpsw cpts Genf1 -> main cpts hw1_push
                        -> cpsw cpts hw4_push
    
        main cpts Genf0 -> main cpts hw2_push
                        -> cpsw cpts hw3_push
    
     testptp -d /dev/ptp0 -i 0 -p 1000000000
     periodic output request okay
     testptp -d /dev/ptp0 -i 1 -e 5
     external time stamp request okay
     event index 1 at 22583.000000025
     event index 1 at 22584.000000025
     event index 1 at 22585.000000025
     event index 1 at 22586.000000025
     event index 1 at 22587.000000025
     testptp -d /dev/ptp1 -i 2 -e 5
     external time stamp request okay
     event index 2 at 1587606764.249304554
     event index 2 at 1587606765.249304467
     event index 2 at 1587606766.249304380
     event index 2 at 1587606767.249304293
     event index 2 at 1587606768.249304206
    
    [1] https://www.ti.com/lit/pdf/spracp7
    [2] https://www.ti.com/lit/pdf/sprz452
    [3] https://www.ti.com/lit/pdf/spruil1
    ====================
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit a0f808e5594127631d07e4059e59450afe99ea8b
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Nov 4 14:43:17 2019 +0100

    nfsd: fix jiffies/time_t mixup in LRU list
    
    commit 9594497f2c78993cb66b696122f7c65528ace985 upstream.
    
    The nfsd4_blocked_lock->nbl_time timestamp is recorded in jiffies,
    but then compared to a CLOCK_REALTIME timestamp later on, which makes
    no sense.
    
    For consistency with the other timestamps, change this to use a time_t.
    
    This is a change in behavior, which may cause regressions, but the
    current code is not sensible. On a system with CONFIG_HZ=1000,
    the 'time_after((unsigned long)nbl->nbl_time, (unsigned long)cutoff))'
    check is false for roughly the first 18 days of uptime and then true
    for the next 49 days.
    
    Fixes: 7919d0a27f1e ("nfsd: add a LRU list for blocked locks")
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 669210a066cf7f2196416660be2f0a4cfe1d61be
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Nov 4 14:43:17 2019 +0100

    nfsd: fix jiffies/time_t mixup in LRU list
    
    commit 9594497f2c78993cb66b696122f7c65528ace985 upstream.
    
    The nfsd4_blocked_lock->nbl_time timestamp is recorded in jiffies,
    but then compared to a CLOCK_REALTIME timestamp later on, which makes
    no sense.
    
    For consistency with the other timestamps, change this to use a time_t.
    
    This is a change in behavior, which may cause regressions, but the
    current code is not sensible. On a system with CONFIG_HZ=1000,
    the 'time_after((unsigned long)nbl->nbl_time, (unsigned long)cutoff))'
    check is false for roughly the first 18 days of uptime and then true
    for the next 49 days.
    
    Fixes: 7919d0a27f1e ("nfsd: add a LRU list for blocked locks")
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 9b3c5a65b7eaf8b6da97e4ddf74fa44be1064248
Author: Vincenzo Frascino <vincenzo.frascino@arm.com>
Date:   Mon Dec 2 07:57:29 2019 +0000

    powerpc: Fix vDSO clock_getres()
    
    commit 552263456215ada7ee8700ce022d12b0cffe4802 upstream.
    
    clock_getres in the vDSO library has to preserve the same behaviour
    of posix_get_hrtimer_res().
    
    In particular, posix_get_hrtimer_res() does:
        sec = 0;
        ns = hrtimer_resolution;
    and hrtimer_resolution depends on the enablement of the high
    resolution timers that can happen either at compile or at run time.
    
    Fix the powerpc vdso implementation of clock_getres keeping a copy of
    hrtimer_resolution in vdso data and using that directly.
    
    Fixes: a7f290dad32e ("[PATCH] powerpc: Merge vdso's and add vdso support to 32 bits kernel")
    Signed-off-by: Vincenzo Frascino <vincenzo.frascino@arm.com>
    Reviewed-by: Christophe Leroy <christophe.leroy@c-s.fr>
    Acked-by: Shuah Khan <skhan@linuxfoundation.org>
    [chleroy: changed CLOCK_REALTIME_RES to CLOCK_HRTIMER_RES]
    Signed-off-by: Christophe Leroy <christophe.leroy@c-s.fr>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Link: https://lore.kernel.org/r/a55eca3a5e85233838c2349783bcb5164dae1d09.1575273217.git.christophe.leroy@c-s.fr
    [bwh: Backported to 3.16:
     - In asm-offsets.c, use DEFINE() instead of OFFSET()
     - Adjust context]
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit 42fdf8c9099e3ad41bfd0bcf9edce9fff72e5ee1
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Nov 4 14:43:17 2019 +0100

    nfsd: fix jiffies/time_t mixup in LRU list
    
    commit 9594497f2c78993cb66b696122f7c65528ace985 upstream.
    
    The nfsd4_blocked_lock->nbl_time timestamp is recorded in jiffies,
    but then compared to a CLOCK_REALTIME timestamp later on, which makes
    no sense.
    
    For consistency with the other timestamps, change this to use a time_t.
    
    This is a change in behavior, which may cause regressions, but the
    current code is not sensible. On a system with CONFIG_HZ=1000,
    the 'time_after((unsigned long)nbl->nbl_time, (unsigned long)cutoff))'
    check is false for roughly the first 18 days of uptime and then true
    for the next 49 days.
    
    Fixes: 7919d0a27f1e ("nfsd: add a LRU list for blocked locks")
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit e94829641e6995d04cdd13765bfa0723abf9d906
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Nov 4 14:43:17 2019 +0100

    nfsd: fix jiffies/time_t mixup in LRU list
    
    commit 9594497f2c78993cb66b696122f7c65528ace985 upstream.
    
    The nfsd4_blocked_lock->nbl_time timestamp is recorded in jiffies,
    but then compared to a CLOCK_REALTIME timestamp later on, which makes
    no sense.
    
    For consistency with the other timestamps, change this to use a time_t.
    
    This is a change in behavior, which may cause regressions, but the
    current code is not sensible. On a system with CONFIG_HZ=1000,
    the 'time_after((unsigned long)nbl->nbl_time, (unsigned long)cutoff))'
    check is false for roughly the first 18 days of uptime and then true
    for the next 49 days.
    
    Fixes: 7919d0a27f1e ("nfsd: add a LRU list for blocked locks")
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit fdbc75c7cb7535890b948b16d349bb7de0d37664
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Nov 4 14:43:17 2019 +0100

    nfsd: fix jiffies/time_t mixup in LRU list
    
    commit 9594497f2c78993cb66b696122f7c65528ace985 upstream.
    
    The nfsd4_blocked_lock->nbl_time timestamp is recorded in jiffies,
    but then compared to a CLOCK_REALTIME timestamp later on, which makes
    no sense.
    
    For consistency with the other timestamps, change this to use a time_t.
    
    This is a change in behavior, which may cause regressions, but the
    current code is not sensible. On a system with CONFIG_HZ=1000,
    the 'time_after((unsigned long)nbl->nbl_time, (unsigned long)cutoff))'
    check is false for roughly the first 18 days of uptime and then true
    for the next 49 days.
    
    Fixes: 7919d0a27f1e ("nfsd: add a LRU list for blocked locks")
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 769071ac9f20b6a447410c7eaa55d1a5233ef40c
Author: Andrei Vagin <avagin@openvz.org>
Date:   Tue Nov 12 01:26:52 2019 +0000

    ns: Introduce Time Namespace
    
    Time Namespace isolates clock values.
    
    The kernel provides access to several clocks CLOCK_REALTIME,
    CLOCK_MONOTONIC, CLOCK_BOOTTIME, etc.
    
    CLOCK_REALTIME
          System-wide clock that measures real (i.e., wall-clock) time.
    
    CLOCK_MONOTONIC
          Clock that cannot be set and represents monotonic time since
          some unspecified starting point.
    
    CLOCK_BOOTTIME
          Identical to CLOCK_MONOTONIC, except it also includes any time
          that the system is suspended.
    
    For many users, the time namespace means the ability to changes date and
    time in a container (CLOCK_REALTIME). Providing per namespace notions of
    CLOCK_REALTIME would be complex with a massive overhead, but has a dubious
    value.
    
    But in the context of checkpoint/restore functionality, monotonic and
    boottime clocks become interesting. Both clocks are monotonic with
    unspecified starting points. These clocks are widely used to measure time
    slices and set timers. After restoring or migrating processes, it has to be
    guaranteed that they never go backward. In an ideal case, the behavior of
    these clocks should be the same as for a case when a whole system is
    suspended. All this means that it is required to set CLOCK_MONOTONIC and
    CLOCK_BOOTTIME clocks, which can be achieved by adding per-namespace
    offsets for clocks.
    
    A time namespace is similar to a pid namespace in the way how it is
    created: unshare(CLONE_NEWTIME) system call creates a new time namespace,
    but doesn't set it to the current process. Then all children of the process
    will be born in the new time namespace, or a process can use the setns()
    system call to join a namespace.
    
    This scheme allows setting clock offsets for a namespace, before any
    processes appear in it.
    
    All available clone flags have been used, so CLONE_NEWTIME uses the highest
    bit of CSIGNAL. It means that it can be used only with the unshare() and
    the clone3() system calls.
    
    [ tglx: Adjusted paragraph about clone3() to reality and massaged the
            changelog a bit. ]
    
    Co-developed-by: Dmitry Safonov <dima@arista.com>
    Signed-off-by: Andrei Vagin <avagin@gmail.com>
    Signed-off-by: Dmitry Safonov <dima@arista.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://criu.org/Time_namespace
    Link: https://lists.openvz.org/pipermail/criu/2018-June/041504.html
    Link: https://lore.kernel.org/r/20191112012724.250792-4-dima@arista.com

commit 444bdefc6424671f66ffdcf52f159a0431a23b27
Author: Vincenzo Frascino <vincenzo.frascino@arm.com>
Date:   Mon Dec 2 07:57:29 2019 +0000

    powerpc: Fix vDSO clock_getres()
    
    [ Upstream commit 552263456215ada7ee8700ce022d12b0cffe4802 ]
    
    clock_getres in the vDSO library has to preserve the same behaviour
    of posix_get_hrtimer_res().
    
    In particular, posix_get_hrtimer_res() does:
        sec = 0;
        ns = hrtimer_resolution;
    and hrtimer_resolution depends on the enablement of the high
    resolution timers that can happen either at compile or at run time.
    
    Fix the powerpc vdso implementation of clock_getres keeping a copy of
    hrtimer_resolution in vdso data and using that directly.
    
    Fixes: a7f290dad32e ("[PATCH] powerpc: Merge vdso's and add vdso support to 32 bits kernel")
    Cc: stable@vger.kernel.org
    Signed-off-by: Vincenzo Frascino <vincenzo.frascino@arm.com>
    Reviewed-by: Christophe Leroy <christophe.leroy@c-s.fr>
    Acked-by: Shuah Khan <skhan@linuxfoundation.org>
    [chleroy: changed CLOCK_REALTIME_RES to CLOCK_HRTIMER_RES]
    Signed-off-by: Christophe Leroy <christophe.leroy@c-s.fr>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Link: https://lore.kernel.org/r/a55eca3a5e85233838c2349783bcb5164dae1d09.1575273217.git.christophe.leroy@c-s.fr
    Signed-off-by: Sasha Levin <sashal@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit a9f80b879611037f7c0e1a04164c6e16d41b6b66
Author: Vincenzo Frascino <vincenzo.frascino@arm.com>
Date:   Mon Dec 2 07:57:29 2019 +0000

    powerpc: Fix vDSO clock_getres()
    
    [ Upstream commit 552263456215ada7ee8700ce022d12b0cffe4802 ]
    
    clock_getres in the vDSO library has to preserve the same behaviour
    of posix_get_hrtimer_res().
    
    In particular, posix_get_hrtimer_res() does:
        sec = 0;
        ns = hrtimer_resolution;
    and hrtimer_resolution depends on the enablement of the high
    resolution timers that can happen either at compile or at run time.
    
    Fix the powerpc vdso implementation of clock_getres keeping a copy of
    hrtimer_resolution in vdso data and using that directly.
    
    Fixes: a7f290dad32e ("[PATCH] powerpc: Merge vdso's and add vdso support to 32 bits kernel")
    Cc: stable@vger.kernel.org
    Signed-off-by: Vincenzo Frascino <vincenzo.frascino@arm.com>
    Reviewed-by: Christophe Leroy <christophe.leroy@c-s.fr>
    Acked-by: Shuah Khan <skhan@linuxfoundation.org>
    [chleroy: changed CLOCK_REALTIME_RES to CLOCK_HRTIMER_RES]
    Signed-off-by: Christophe Leroy <christophe.leroy@c-s.fr>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Link: https://lore.kernel.org/r/a55eca3a5e85233838c2349783bcb5164dae1d09.1575273217.git.christophe.leroy@c-s.fr
    Signed-off-by: Sasha Levin <sashal@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 9594497f2c78993cb66b696122f7c65528ace985
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Nov 4 14:43:17 2019 +0100

    nfsd: fix jiffies/time_t mixup in LRU list
    
    The nfsd4_blocked_lock->nbl_time timestamp is recorded in jiffies,
    but then compared to a CLOCK_REALTIME timestamp later on, which makes
    no sense.
    
    For consistency with the other timestamps, change this to use a time_t.
    
    This is a change in behavior, which may cause regressions, but the
    current code is not sensible. On a system with CONFIG_HZ=1000,
    the 'time_after((unsigned long)nbl->nbl_time, (unsigned long)cutoff))'
    check is false for roughly the first 18 days of uptime and then true
    for the next 49 days.
    
    Fixes: 7919d0a27f1e ("nfsd: add a LRU list for blocked locks")
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

commit cf9e11a310348a49ed481195ea6d686d3a3bfd1c
Author: Vincenzo Frascino <vincenzo.frascino@arm.com>
Date:   Mon Dec 2 07:57:29 2019 +0000

    powerpc: Fix vDSO clock_getres()
    
    [ Upstream commit 552263456215ada7ee8700ce022d12b0cffe4802 ]
    
    clock_getres in the vDSO library has to preserve the same behaviour
    of posix_get_hrtimer_res().
    
    In particular, posix_get_hrtimer_res() does:
        sec = 0;
        ns = hrtimer_resolution;
    and hrtimer_resolution depends on the enablement of the high
    resolution timers that can happen either at compile or at run time.
    
    Fix the powerpc vdso implementation of clock_getres keeping a copy of
    hrtimer_resolution in vdso data and using that directly.
    
    Fixes: a7f290dad32e ("[PATCH] powerpc: Merge vdso's and add vdso support to 32 bits kernel")
    Cc: stable@vger.kernel.org
    Signed-off-by: Vincenzo Frascino <vincenzo.frascino@arm.com>
    Reviewed-by: Christophe Leroy <christophe.leroy@c-s.fr>
    Acked-by: Shuah Khan <skhan@linuxfoundation.org>
    [chleroy: changed CLOCK_REALTIME_RES to CLOCK_HRTIMER_RES]
    Signed-off-by: Christophe Leroy <christophe.leroy@c-s.fr>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Link: https://lore.kernel.org/r/a55eca3a5e85233838c2349783bcb5164dae1d09.1575273217.git.christophe.leroy@c-s.fr
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 79bee5a380342b48d0ce177cb2fb75ef6eeeb1a2
Author: Vincenzo Frascino <vincenzo.frascino@arm.com>
Date:   Mon Dec 2 07:57:29 2019 +0000

    powerpc: Fix vDSO clock_getres()
    
    [ Upstream commit 552263456215ada7ee8700ce022d12b0cffe4802 ]
    
    clock_getres in the vDSO library has to preserve the same behaviour
    of posix_get_hrtimer_res().
    
    In particular, posix_get_hrtimer_res() does:
        sec = 0;
        ns = hrtimer_resolution;
    and hrtimer_resolution depends on the enablement of the high
    resolution timers that can happen either at compile or at run time.
    
    Fix the powerpc vdso implementation of clock_getres keeping a copy of
    hrtimer_resolution in vdso data and using that directly.
    
    Fixes: a7f290dad32e ("[PATCH] powerpc: Merge vdso's and add vdso support to 32 bits kernel")
    Cc: stable@vger.kernel.org
    Signed-off-by: Vincenzo Frascino <vincenzo.frascino@arm.com>
    Reviewed-by: Christophe Leroy <christophe.leroy@c-s.fr>
    Acked-by: Shuah Khan <skhan@linuxfoundation.org>
    [chleroy: changed CLOCK_REALTIME_RES to CLOCK_HRTIMER_RES]
    Signed-off-by: Christophe Leroy <christophe.leroy@c-s.fr>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Link: https://lore.kernel.org/r/a55eca3a5e85233838c2349783bcb5164dae1d09.1575273217.git.christophe.leroy@c-s.fr
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit e8672e0f87adbed588f077c03108b2de1bbf0124
Author: Vincenzo Frascino <vincenzo.frascino@arm.com>
Date:   Mon Dec 2 07:57:29 2019 +0000

    powerpc: Fix vDSO clock_getres()
    
    [ Upstream commit 552263456215ada7ee8700ce022d12b0cffe4802 ]
    
    clock_getres in the vDSO library has to preserve the same behaviour
    of posix_get_hrtimer_res().
    
    In particular, posix_get_hrtimer_res() does:
        sec = 0;
        ns = hrtimer_resolution;
    and hrtimer_resolution depends on the enablement of the high
    resolution timers that can happen either at compile or at run time.
    
    Fix the powerpc vdso implementation of clock_getres keeping a copy of
    hrtimer_resolution in vdso data and using that directly.
    
    Fixes: a7f290dad32e ("[PATCH] powerpc: Merge vdso's and add vdso support to 32 bits kernel")
    Cc: stable@vger.kernel.org
    Signed-off-by: Vincenzo Frascino <vincenzo.frascino@arm.com>
    Reviewed-by: Christophe Leroy <christophe.leroy@c-s.fr>
    Acked-by: Shuah Khan <skhan@linuxfoundation.org>
    [chleroy: changed CLOCK_REALTIME_RES to CLOCK_HRTIMER_RES]
    Signed-off-by: Christophe Leroy <christophe.leroy@c-s.fr>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Link: https://lore.kernel.org/r/a55eca3a5e85233838c2349783bcb5164dae1d09.1575273217.git.christophe.leroy@c-s.fr
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 78d375ace0f5c49ca1131fb033473de47b36312f
Author: Vincenzo Frascino <vincenzo.frascino@arm.com>
Date:   Mon Dec 2 07:57:29 2019 +0000

    powerpc: Fix vDSO clock_getres()
    
    [ Upstream commit 552263456215ada7ee8700ce022d12b0cffe4802 ]
    
    clock_getres in the vDSO library has to preserve the same behaviour
    of posix_get_hrtimer_res().
    
    In particular, posix_get_hrtimer_res() does:
        sec = 0;
        ns = hrtimer_resolution;
    and hrtimer_resolution depends on the enablement of the high
    resolution timers that can happen either at compile or at run time.
    
    Fix the powerpc vdso implementation of clock_getres keeping a copy of
    hrtimer_resolution in vdso data and using that directly.
    
    Fixes: a7f290dad32e ("[PATCH] powerpc: Merge vdso's and add vdso support to 32 bits kernel")
    Cc: stable@vger.kernel.org
    Signed-off-by: Vincenzo Frascino <vincenzo.frascino@arm.com>
    Reviewed-by: Christophe Leroy <christophe.leroy@c-s.fr>
    Acked-by: Shuah Khan <skhan@linuxfoundation.org>
    [chleroy: changed CLOCK_REALTIME_RES to CLOCK_HRTIMER_RES]
    Signed-off-by: Christophe Leroy <christophe.leroy@c-s.fr>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Link: https://lore.kernel.org/r/a55eca3a5e85233838c2349783bcb5164dae1d09.1575273217.git.christophe.leroy@c-s.fr
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 552263456215ada7ee8700ce022d12b0cffe4802
Author: Vincenzo Frascino <vincenzo.frascino@arm.com>
Date:   Mon Dec 2 07:57:29 2019 +0000

    powerpc: Fix vDSO clock_getres()
    
    clock_getres in the vDSO library has to preserve the same behaviour
    of posix_get_hrtimer_res().
    
    In particular, posix_get_hrtimer_res() does:
        sec = 0;
        ns = hrtimer_resolution;
    and hrtimer_resolution depends on the enablement of the high
    resolution timers that can happen either at compile or at run time.
    
    Fix the powerpc vdso implementation of clock_getres keeping a copy of
    hrtimer_resolution in vdso data and using that directly.
    
    Fixes: a7f290dad32e ("[PATCH] powerpc: Merge vdso's and add vdso support to 32 bits kernel")
    Cc: stable@vger.kernel.org
    Signed-off-by: Vincenzo Frascino <vincenzo.frascino@arm.com>
    Reviewed-by: Christophe Leroy <christophe.leroy@c-s.fr>
    Acked-by: Shuah Khan <skhan@linuxfoundation.org>
    [chleroy: changed CLOCK_REALTIME_RES to CLOCK_HRTIMER_RES]
    Signed-off-by: Christophe Leroy <christophe.leroy@c-s.fr>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Link: https://lore.kernel.org/r/a55eca3a5e85233838c2349783bcb5164dae1d09.1575273217.git.christophe.leroy@c-s.fr

commit f0ec4d8d691a802fe5ee590298018f01884824c2
Author: Thadeu Lima de Souza Cascardo <cascardo@canonical.com>
Date:   Tue Sep 3 14:18:02 2019 -0300

    alarmtimer: Use EOPNOTSUPP instead of ENOTSUPP
    
    commit f18ddc13af981ce3c7b7f26925f099e7c6929aba upstream.
    
    ENOTSUPP is not supposed to be returned to userspace. This was found on an
    OpenPower machine, where the RTC does not support set_alarm.
    
    On that system, a clock_nanosleep(CLOCK_REALTIME_ALARM, ...) results in
    "524 Unknown error 524"
    
    Replace it with EOPNOTSUPP which results in the expected "95 Operation not
    supported" error.
    
    Fixes: 1c6b39ad3f01 (alarmtimers: Return -ENOTSUPP if no RTC device is present)
    Signed-off-by: Thadeu Lima de Souza Cascardo <cascardo@canonical.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lkml.kernel.org/r/20190903171802.28314-1-cascardo@canonical.com
    [ pvorel: backport for v3.16, changes also in alarm_timer_{del,set}(), which
    were removed in f2c45807d3992fe0f173f34af9c347d907c31686 in v4.13-rc1 ]
    Signed-off-by: Petr Vorel <pvorel@suse.cz>
    Acked-by: Thadeu Lima de Souza Cascardo <cascardo@canonical.com>
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit b98c7518c5345ac5f930fd40ce9d8d2b8dc2ba06
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Jun 18 16:19:24 2018 +0200

    firewire: ohci: stop using get_seconds() for BUS_TIME
    
    The ohci driver uses the get_seconds() function to implement the 32-bit
    CSR_BUS_TIME register. This was added in 2010 commit a48777e03ad5
    ("firewire: add CSR BUS_TIME support").
    
    As get_seconds() returns a 32-bit value (on 32-bit architectures), it
    seems like a good fit for that register, but it is also deprecated because
    of the y2038/y2106 overflow problem, and should be replaced throughout
    the kernel with either ktime_get_real_seconds() or ktime_get_seconds().
    
    I'm using the latter here, which uses monotonic time. This has the
    advantage of behaving better during concurrent settimeofday() updates
    or leap second adjustments and won't overflow a 32-bit integer, but
    the downside of using CLOCK_MONOTONIC instead of CLOCK_REALTIME is
    that the observed values are not related to external clocks.
    
    If we instead need UTC but can live with clock jumps or overflows,
    then we should use ktime_get_real_seconds() instead, retaining the
    existing behavior.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Link: https://lore.kernel.org/lkml/20180711124923.1205200-1-arnd@arndb.de/
    Reviewed-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

commit cf25e24db61cc9df42c47485a2ec2bff4e9a3692
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Thu Nov 7 11:07:58 2019 +0100

    time: Rename tsk->real_start_time to ->start_boottime
    
    Since it stores CLOCK_BOOTTIME, not, as the name suggests,
    CLOCK_REALTIME, let's rename ->real_start_time to ->start_bootime.
    
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 26285f1359695e94751e01a4755d322af0e74145
Merge: 7941af9b38fa af580ae2dcb2
Author: David S. Miller <davem@davemloft.net>
Date:   Mon Nov 11 12:45:31 2019 -0800

    Merge branch 'Unlock-new-potential-in-SJA1105-with-PTP-system-timestamping'
    
    Vladimir Oltean says:
    
    ====================
    Unlock new potential in SJA1105 with PTP system timestamping
    
    The SJA1105 being an automotive switch means it is designed to live in a
    set-and-forget environment, far from the configure-at-runtime nature of
    Linux. Frequently resetting the switch to change its static config means
    it loses track of its PTP time, which is not good.
    
    This patch series implements PTP system timestamping for this switch
    (using the API introduced for SPI here:
    https://www.mail-archive.com/netdev@vger.kernel.org/msg316725.html),
    adding the following benefits to the driver:
    - When under control of a user space PTP servo loop (ptp4l, phc2sys),
      the loss of sync during a switch reset is much more manageable, and
      the switch still remains in the s2 (locked servo) state.
    - When synchronizing the switch using the software technique (based on
      reading clock A and writing the value to clock B, as opposed to
      relying on hardware timestamping), e.g. by using phc2sys, the sync
      accuracy is vastly improved due to the fact that the actual switch PTP
      time can now be more precisely correlated with something of better
      precision (CLOCK_REALTIME). The issue is that SPI transfers are
      inherently bad for measuring time with low jitter, but the newly
      introduced API aims to alleviate that issue somewhat.
    
    This series is also a requirement for a future patch set that adds full
    time-aware scheduling offload support for the switch.
    ====================
    
    Acked-by: Richard Cochran <richardcochran@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 34d76e9fa846a87e7924ab974e4cb70394a4fcac
Author: Vladimir Oltean <olteanv@gmail.com>
Date:   Sat Nov 9 13:32:22 2019 +0200

    net: dsa: sja1105: Implement the .gettimex64 system call for PTP
    
    Through the PTP_SYS_OFFSET_EXTENDED ioctl, it is possible for userspace
    applications (i.e. phc2sys) to compensate for the delays incurred while
    reading the PHC's time.
    
    The task itself of taking the software timestamp is delegated to the SPI
    subsystem, through the newly introduced API in struct spi_transfer. The
    goal is to cross-timestamp I/O operations on the switch's PTP clock with
    values in the local system clock (CLOCK_REALTIME). For that we need to
    understand a bit of the hardware internals.
    
    The 'read PTP time' message is a 12 byte structure, first 4 bytes of
    which represent the SPI header, and the last 8 bytes represent the
    64-bit PTP time. The switch itself starts processing the command
    immediately after receiving the last bit of the address, i.e. at the
    middle of byte 3 (last byte of header). The PTP time is shadowed to a
    buffer register in the switch, and retrieved atomically during the
    subsequent SPI frames.
    
    A similar thing goes on for the 'write PTP time' message, although in
    that case the switch waits until the 64-bit PTP time becomes fully
    available before taking any action. So the byte that needs to be
    software-timestamped is byte 11 (last) of the transfer.
    
    The patch creates a common (and local) sja1105_xfer implementation for
    the SPI I/O, and offers 3 front-ends:
    
    - sja1105_xfer_u32 and sja1105_xfer_u64: these are capable of optionally
      requesting a PTP timestamp
    
    - sja1105_xfer_buf: this is for large transfers (e.g. the static config
      buffer) and other misc data, and there is no point in giving
      timestamping capabilities to this.
    
    Signed-off-by: Vladimir Oltean <olteanv@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit b1a78a24172e3fb6ada01da392a08edb960e344d
Author: Thadeu Lima de Souza Cascardo <cascardo@canonical.com>
Date:   Tue Sep 3 14:18:02 2019 -0300

    alarmtimer: Use EOPNOTSUPP instead of ENOTSUPP
    
    commit f18ddc13af981ce3c7b7f26925f099e7c6929aba upstream.
    
    ENOTSUPP is not supposed to be returned to userspace. This was found on an
    OpenPower machine, where the RTC does not support set_alarm.
    
    On that system, a clock_nanosleep(CLOCK_REALTIME_ALARM, ...) results in
    "524 Unknown error 524"
    
    Replace it with EOPNOTSUPP which results in the expected "95 Operation not
    supported" error.
    
    Fixes: 1c6b39ad3f01 (alarmtimers: Return -ENOTSUPP if no RTC device is present)
    Signed-off-by: Thadeu Lima de Souza Cascardo <cascardo@canonical.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190903171802.28314-1-cascardo@canonical.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit f683465f0564e0a63bc138a6b74817fc890525e5
Author: Thadeu Lima de Souza Cascardo <cascardo@canonical.com>
Date:   Tue Sep 3 14:18:02 2019 -0300

    alarmtimer: Use EOPNOTSUPP instead of ENOTSUPP
    
    commit f18ddc13af981ce3c7b7f26925f099e7c6929aba upstream.
    
    ENOTSUPP is not supposed to be returned to userspace. This was found on an
    OpenPower machine, where the RTC does not support set_alarm.
    
    On that system, a clock_nanosleep(CLOCK_REALTIME_ALARM, ...) results in
    "524 Unknown error 524"
    
    Replace it with EOPNOTSUPP which results in the expected "95 Operation not
    supported" error.
    
    Fixes: 1c6b39ad3f01 (alarmtimers: Return -ENOTSUPP if no RTC device is present)
    Signed-off-by: Thadeu Lima de Souza Cascardo <cascardo@canonical.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190903171802.28314-1-cascardo@canonical.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 3784576fc63912e44268fbfdd3d676c1830e06a2
Author: Thadeu Lima de Souza Cascardo <cascardo@canonical.com>
Date:   Tue Sep 3 14:18:02 2019 -0300

    alarmtimer: Use EOPNOTSUPP instead of ENOTSUPP
    
    commit f18ddc13af981ce3c7b7f26925f099e7c6929aba upstream.
    
    ENOTSUPP is not supposed to be returned to userspace. This was found on an
    OpenPower machine, where the RTC does not support set_alarm.
    
    On that system, a clock_nanosleep(CLOCK_REALTIME_ALARM, ...) results in
    "524 Unknown error 524"
    
    Replace it with EOPNOTSUPP which results in the expected "95 Operation not
    supported" error.
    
    Fixes: 1c6b39ad3f01 (alarmtimers: Return -ENOTSUPP if no RTC device is present)
    Signed-off-by: Thadeu Lima de Souza Cascardo <cascardo@canonical.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190903171802.28314-1-cascardo@canonical.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 53f09cedf1060458de34958fb90d782d917fc24c
Author: Thadeu Lima de Souza Cascardo <cascardo@canonical.com>
Date:   Tue Sep 3 14:18:02 2019 -0300

    alarmtimer: Use EOPNOTSUPP instead of ENOTSUPP
    
    commit f18ddc13af981ce3c7b7f26925f099e7c6929aba upstream.
    
    ENOTSUPP is not supposed to be returned to userspace. This was found on an
    OpenPower machine, where the RTC does not support set_alarm.
    
    On that system, a clock_nanosleep(CLOCK_REALTIME_ALARM, ...) results in
    "524 Unknown error 524"
    
    Replace it with EOPNOTSUPP which results in the expected "95 Operation not
    supported" error.
    
    Fixes: 1c6b39ad3f01 (alarmtimers: Return -ENOTSUPP if no RTC device is present)
    Signed-off-by: Thadeu Lima de Souza Cascardo <cascardo@canonical.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190903171802.28314-1-cascardo@canonical.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 65b7a5a36afb11a6769a70308c1ef3a2afae6bf4
Author: Thadeu Lima de Souza Cascardo <cascardo@canonical.com>
Date:   Tue Sep 3 14:18:02 2019 -0300

    alarmtimer: Use EOPNOTSUPP instead of ENOTSUPP
    
    commit f18ddc13af981ce3c7b7f26925f099e7c6929aba upstream.
    
    ENOTSUPP is not supposed to be returned to userspace. This was found on an
    OpenPower machine, where the RTC does not support set_alarm.
    
    On that system, a clock_nanosleep(CLOCK_REALTIME_ALARM, ...) results in
    "524 Unknown error 524"
    
    Replace it with EOPNOTSUPP which results in the expected "95 Operation not
    supported" error.
    
    Fixes: 1c6b39ad3f01 (alarmtimers: Return -ENOTSUPP if no RTC device is present)
    Signed-off-by: Thadeu Lima de Souza Cascardo <cascardo@canonical.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190903171802.28314-1-cascardo@canonical.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit c22df8ea7c5831d6fdca2f6f136f0d32d7064ff9
Author: Thadeu Lima de Souza Cascardo <cascardo@canonical.com>
Date:   Tue Sep 3 14:18:02 2019 -0300

    alarmtimer: Use EOPNOTSUPP instead of ENOTSUPP
    
    commit f18ddc13af981ce3c7b7f26925f099e7c6929aba upstream.
    
    ENOTSUPP is not supposed to be returned to userspace. This was found on an
    OpenPower machine, where the RTC does not support set_alarm.
    
    On that system, a clock_nanosleep(CLOCK_REALTIME_ALARM, ...) results in
    "524 Unknown error 524"
    
    Replace it with EOPNOTSUPP which results in the expected "95 Operation not
    supported" error.
    
    Fixes: 1c6b39ad3f01 (alarmtimers: Return -ENOTSUPP if no RTC device is present)
    Signed-off-by: Thadeu Lima de Souza Cascardo <cascardo@canonical.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190903171802.28314-1-cascardo@canonical.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit f18ddc13af981ce3c7b7f26925f099e7c6929aba
Author: Thadeu Lima de Souza Cascardo <cascardo@canonical.com>
Date:   Tue Sep 3 14:18:02 2019 -0300

    alarmtimer: Use EOPNOTSUPP instead of ENOTSUPP
    
    ENOTSUPP is not supposed to be returned to userspace. This was found on an
    OpenPower machine, where the RTC does not support set_alarm.
    
    On that system, a clock_nanosleep(CLOCK_REALTIME_ALARM, ...) results in
    "524 Unknown error 524"
    
    Replace it with EOPNOTSUPP which results in the expected "95 Operation not
    supported" error.
    
    Fixes: 1c6b39ad3f01 (alarmtimers: Return -ENOTSUPP if no RTC device is present)
    Signed-off-by: Thadeu Lima de Souza Cascardo <cascardo@canonical.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190903171802.28314-1-cascardo@canonical.com

commit 41164dd56336bcccab95f0f0077bbbefa7891246
Author: Miroslav Lichvar <mlichvar@redhat.com>
Date:   Tue Jun 18 17:47:13 2019 +0200

    ntp: Limit TAI-UTC offset
    
    [ Upstream commit d897a4ab11dc8a9fda50d2eccc081a96a6385998 ]
    
    Don't allow the TAI-UTC offset of the system clock to be set by adjtimex()
    to a value larger than 100000 seconds.
    
    This prevents an overflow in the conversion to int, prevents the CLOCK_TAI
    clock from getting too far ahead of the CLOCK_REALTIME clock, and it is
    still large enough to allow leap seconds to be inserted at the maximum rate
    currently supported by the kernel (once per day) for the next ~270 years,
    however unlikely it is that someone can survive a catastrophic event which
    slowed down the rotation of the Earth so much.
    
    Reported-by: Weikang shi <swkhack@gmail.com>
    Signed-off-by: Miroslav Lichvar <mlichvar@redhat.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Stephen Boyd <sboyd@kernel.org>
    Link: https://lkml.kernel.org/r/20190618154713.20929-1-mlichvar@redhat.com
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 5992cebc8371cac5c1e44e64e0f2a8cbb71eb976
Author: Miroslav Lichvar <mlichvar@redhat.com>
Date:   Tue Jun 18 17:47:13 2019 +0200

    ntp: Limit TAI-UTC offset
    
    [ Upstream commit d897a4ab11dc8a9fda50d2eccc081a96a6385998 ]
    
    Don't allow the TAI-UTC offset of the system clock to be set by adjtimex()
    to a value larger than 100000 seconds.
    
    This prevents an overflow in the conversion to int, prevents the CLOCK_TAI
    clock from getting too far ahead of the CLOCK_REALTIME clock, and it is
    still large enough to allow leap seconds to be inserted at the maximum rate
    currently supported by the kernel (once per day) for the next ~270 years,
    however unlikely it is that someone can survive a catastrophic event which
    slowed down the rotation of the Earth so much.
    
    Reported-by: Weikang shi <swkhack@gmail.com>
    Signed-off-by: Miroslav Lichvar <mlichvar@redhat.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Stephen Boyd <sboyd@kernel.org>
    Link: https://lkml.kernel.org/r/20190618154713.20929-1-mlichvar@redhat.com
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit cf90753513b3e0c10096ed26175a27dc26fad4b7
Author: Miroslav Lichvar <mlichvar@redhat.com>
Date:   Tue Jun 18 17:47:13 2019 +0200

    ntp: Limit TAI-UTC offset
    
    [ Upstream commit d897a4ab11dc8a9fda50d2eccc081a96a6385998 ]
    
    Don't allow the TAI-UTC offset of the system clock to be set by adjtimex()
    to a value larger than 100000 seconds.
    
    This prevents an overflow in the conversion to int, prevents the CLOCK_TAI
    clock from getting too far ahead of the CLOCK_REALTIME clock, and it is
    still large enough to allow leap seconds to be inserted at the maximum rate
    currently supported by the kernel (once per day) for the next ~270 years,
    however unlikely it is that someone can survive a catastrophic event which
    slowed down the rotation of the Earth so much.
    
    Reported-by: Weikang shi <swkhack@gmail.com>
    Signed-off-by: Miroslav Lichvar <mlichvar@redhat.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Stephen Boyd <sboyd@kernel.org>
    Link: https://lkml.kernel.org/r/20190618154713.20929-1-mlichvar@redhat.com
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit d86c0b73f75b7732824905c7e59ed632c182bb3d
Author: Miroslav Lichvar <mlichvar@redhat.com>
Date:   Tue Jun 18 17:47:13 2019 +0200

    ntp: Limit TAI-UTC offset
    
    [ Upstream commit d897a4ab11dc8a9fda50d2eccc081a96a6385998 ]
    
    Don't allow the TAI-UTC offset of the system clock to be set by adjtimex()
    to a value larger than 100000 seconds.
    
    This prevents an overflow in the conversion to int, prevents the CLOCK_TAI
    clock from getting too far ahead of the CLOCK_REALTIME clock, and it is
    still large enough to allow leap seconds to be inserted at the maximum rate
    currently supported by the kernel (once per day) for the next ~270 years,
    however unlikely it is that someone can survive a catastrophic event which
    slowed down the rotation of the Earth so much.
    
    Reported-by: Weikang shi <swkhack@gmail.com>
    Signed-off-by: Miroslav Lichvar <mlichvar@redhat.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Stephen Boyd <sboyd@kernel.org>
    Link: https://lkml.kernel.org/r/20190618154713.20929-1-mlichvar@redhat.com
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit a0d5e56f6a05cb0ba3af8deb8df14af82a3072a9
Author: Miroslav Lichvar <mlichvar@redhat.com>
Date:   Tue Jun 18 17:47:13 2019 +0200

    ntp: Limit TAI-UTC offset
    
    [ Upstream commit d897a4ab11dc8a9fda50d2eccc081a96a6385998 ]
    
    Don't allow the TAI-UTC offset of the system clock to be set by adjtimex()
    to a value larger than 100000 seconds.
    
    This prevents an overflow in the conversion to int, prevents the CLOCK_TAI
    clock from getting too far ahead of the CLOCK_REALTIME clock, and it is
    still large enough to allow leap seconds to be inserted at the maximum rate
    currently supported by the kernel (once per day) for the next ~270 years,
    however unlikely it is that someone can survive a catastrophic event which
    slowed down the rotation of the Earth so much.
    
    Reported-by: Weikang shi <swkhack@gmail.com>
    Signed-off-by: Miroslav Lichvar <mlichvar@redhat.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Stephen Boyd <sboyd@kernel.org>
    Link: https://lkml.kernel.org/r/20190618154713.20929-1-mlichvar@redhat.com
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit b2e049098962d6fdc2d79b5bcaf816196c837e79
Author: Miroslav Lichvar <mlichvar@redhat.com>
Date:   Tue Jun 18 17:47:13 2019 +0200

    ntp: Limit TAI-UTC offset
    
    [ Upstream commit d897a4ab11dc8a9fda50d2eccc081a96a6385998 ]
    
    Don't allow the TAI-UTC offset of the system clock to be set by adjtimex()
    to a value larger than 100000 seconds.
    
    This prevents an overflow in the conversion to int, prevents the CLOCK_TAI
    clock from getting too far ahead of the CLOCK_REALTIME clock, and it is
    still large enough to allow leap seconds to be inserted at the maximum rate
    currently supported by the kernel (once per day) for the next ~270 years,
    however unlikely it is that someone can survive a catastrophic event which
    slowed down the rotation of the Earth so much.
    
    Reported-by: Weikang shi <swkhack@gmail.com>
    Signed-off-by: Miroslav Lichvar <mlichvar@redhat.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Stephen Boyd <sboyd@kernel.org>
    Link: https://lkml.kernel.org/r/20190618154713.20929-1-mlichvar@redhat.com
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit d897a4ab11dc8a9fda50d2eccc081a96a6385998
Author: Miroslav Lichvar <mlichvar@redhat.com>
Date:   Tue Jun 18 17:47:13 2019 +0200

    ntp: Limit TAI-UTC offset
    
    Don't allow the TAI-UTC offset of the system clock to be set by adjtimex()
    to a value larger than 100000 seconds.
    
    This prevents an overflow in the conversion to int, prevents the CLOCK_TAI
    clock from getting too far ahead of the CLOCK_REALTIME clock, and it is
    still large enough to allow leap seconds to be inserted at the maximum rate
    currently supported by the kernel (once per day) for the next ~270 years,
    however unlikely it is that someone can survive a catastrophic event which
    slowed down the rotation of the Earth so much.
    
    Reported-by: Weikang shi <swkhack@gmail.com>
    Signed-off-by: Miroslav Lichvar <mlichvar@redhat.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Stephen Boyd <sboyd@kernel.org>
    Link: https://lkml.kernel.org/r/20190618154713.20929-1-mlichvar@redhat.com

commit bb77f36ac21d226b8ae4311daceb983be764f746
Author: Vladimir Oltean <olteanv@gmail.com>
Date:   Sat Jun 8 15:04:34 2019 +0300

    net: dsa: sja1105: Add support for the PTP clock
    
    The design of this PHC driver is influenced by the switch's behavior
    w.r.t. timestamping.  It exposes two PTP counters, one free-running
    (PTPTSCLK) and the other offset- and frequency-corrected in hardware
    through PTPCLKVAL, PTPCLKADD and PTPCLKRATE.  The MACs can sample either
    of these for frame timestamps.
    
    However, the user manual warns that taking timestamps based on the
    corrected clock is less than useful, as the switch can deliver corrupted
    timestamps in a variety of circumstances.
    
    Therefore, this PHC uses the free-running PTPTSCLK together with a
    timecounter/cyclecounter structure that translates it into a software
    time domain.  Thus, the settime/adjtime and adjfine callbacks are
    hardware no-ops.
    
    The timestamps (introduced in a further patch) will also be translated
    to the correct time domain before being handed over to the userspace PTP
    stack.
    
    The introduction of a second set of PHC operations that operate on the
    hardware PTPCLKVAL/PTPCLKADD/PTPCLKRATE in the future is somewhat
    unavoidable, as the TTEthernet core uses the corrected PTP time domain.
    However, the free-running counter + timecounter structure combination
    will suffice for now, as the resulting timestamps yield a sub-50 ns
    synchronization offset in steady state using linuxptp.
    
    For this patch, in absence of frame timestamping, the operations of the
    switch PHC were tested by syncing it to the system time as a local slave
    clock with:
    
    phc2sys -s CLOCK_REALTIME -c swp2 -O 0 -m -S 0.01
    
    Signed-off-by: Vladimir Oltean <olteanv@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 9f641ee2b749d57b4672e4c28f4dba9523923ac4
Author: Vincenzo Frascino <vincenzo.frascino@arm.com>
Date:   Tue Apr 16 17:14:30 2019 +0100

    arm64: vdso: Fix clock_getres() for CLOCK_REALTIME
    
    [ Upstream commit 81fb8736dd81da3fe94f28968dac60f392ec6746 ]
    
    clock_getres() in the vDSO library has to preserve the same behaviour
    of posix_get_hrtimer_res().
    
    In particular, posix_get_hrtimer_res() does:
    
        sec = 0;
        ns = hrtimer_resolution;
    
    where 'hrtimer_resolution' depends on whether or not high resolution
    timers are enabled, which is a runtime decision.
    
    The vDSO incorrectly returns the constant CLOCK_REALTIME_RES. Fix this
    by exposing 'hrtimer_resolution' in the vDSO datapage and returning that
    instead.
    
    Reviewed-by: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Vincenzo Frascino <vincenzo.frascino@arm.com>
    [will: Use WRITE_ONCE(), move adr off COARSE path, renumber labels, use 'w' reg]
    Signed-off-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit fcc6b2459ee3879ab9b4afc6d6a68febac7c1f3f
Author: Vincenzo Frascino <vincenzo.frascino@arm.com>
Date:   Tue Apr 16 17:14:30 2019 +0100

    arm64: vdso: Fix clock_getres() for CLOCK_REALTIME
    
    [ Upstream commit 81fb8736dd81da3fe94f28968dac60f392ec6746 ]
    
    clock_getres() in the vDSO library has to preserve the same behaviour
    of posix_get_hrtimer_res().
    
    In particular, posix_get_hrtimer_res() does:
    
        sec = 0;
        ns = hrtimer_resolution;
    
    where 'hrtimer_resolution' depends on whether or not high resolution
    timers are enabled, which is a runtime decision.
    
    The vDSO incorrectly returns the constant CLOCK_REALTIME_RES. Fix this
    by exposing 'hrtimer_resolution' in the vDSO datapage and returning that
    instead.
    
    Reviewed-by: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Vincenzo Frascino <vincenzo.frascino@arm.com>
    [will: Use WRITE_ONCE(), move adr off COARSE path, renumber labels, use 'w' reg]
    Signed-off-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit dc0f37b780e97d45c580a7141f6ac06b1ea5ba07
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Mar 23 11:36:19 2019 +0100

    timekeeping: Force upper bound for setting CLOCK_REALTIME
    
    [ Upstream commit 7a8e61f8478639072d402a26789055a4a4de8f77 ]
    
    Several people reported testing failures after setting CLOCK_REALTIME close
    to the limits of the kernel internal representation in nanoseconds,
    i.e. year 2262.
    
    The failures are exposed in subsequent operations, i.e. when arming timers
    or when the advancing CLOCK_MONOTONIC makes the calculation of
    CLOCK_REALTIME overflow into negative space.
    
    Now people start to paper over the underlying problem by clamping
    calculations to the valid range, but that's just wrong because such
    workarounds will prevent detection of real issues as well.
    
    It is reasonable to force an upper bound for the various methods of setting
    CLOCK_REALTIME. Year 2262 is the absolute upper bound. Assume a maximum
    uptime of 30 years which is plenty enough even for esoteric embedded
    systems. That results in an upper bound of year 2232 for setting the time.
    
    Once that limit is reached in reality this limit is only a small part of
    the problem space. But until then this stops people from trying to paper
    over the problem at the wrong places.
    
    Reported-by: Xiongfeng Wang <wangxiongfeng2@huawei.com>
    Reported-by: Hongbo Yao <yaohongbo@huawei.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Stephen Boyd <sboyd@kernel.org>
    Cc: Miroslav Lichvar <mlichvar@redhat.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: https://lkml.kernel.org/r/alpine.DEB.2.21.1903231125480.2157@nanos.tec.linutronix.de
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit b0f6ac8c81e078a2a8277fc4a6e62322d12b39fa
Author: Vincenzo Frascino <vincenzo.frascino@arm.com>
Date:   Tue Apr 16 17:14:30 2019 +0100

    arm64: vdso: Fix clock_getres() for CLOCK_REALTIME
    
    [ Upstream commit 81fb8736dd81da3fe94f28968dac60f392ec6746 ]
    
    clock_getres() in the vDSO library has to preserve the same behaviour
    of posix_get_hrtimer_res().
    
    In particular, posix_get_hrtimer_res() does:
    
        sec = 0;
        ns = hrtimer_resolution;
    
    where 'hrtimer_resolution' depends on whether or not high resolution
    timers are enabled, which is a runtime decision.
    
    The vDSO incorrectly returns the constant CLOCK_REALTIME_RES. Fix this
    by exposing 'hrtimer_resolution' in the vDSO datapage and returning that
    instead.
    
    Reviewed-by: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Vincenzo Frascino <vincenzo.frascino@arm.com>
    [will: Use WRITE_ONCE(), move adr off COARSE path, renumber labels, use 'w' reg]
    Signed-off-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit faa3f27911352ab2c23e5c8e0fb0801b8e4dd092
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Mar 23 11:36:19 2019 +0100

    timekeeping: Force upper bound for setting CLOCK_REALTIME
    
    [ Upstream commit 7a8e61f8478639072d402a26789055a4a4de8f77 ]
    
    Several people reported testing failures after setting CLOCK_REALTIME close
    to the limits of the kernel internal representation in nanoseconds,
    i.e. year 2262.
    
    The failures are exposed in subsequent operations, i.e. when arming timers
    or when the advancing CLOCK_MONOTONIC makes the calculation of
    CLOCK_REALTIME overflow into negative space.
    
    Now people start to paper over the underlying problem by clamping
    calculations to the valid range, but that's just wrong because such
    workarounds will prevent detection of real issues as well.
    
    It is reasonable to force an upper bound for the various methods of setting
    CLOCK_REALTIME. Year 2262 is the absolute upper bound. Assume a maximum
    uptime of 30 years which is plenty enough even for esoteric embedded
    systems. That results in an upper bound of year 2232 for setting the time.
    
    Once that limit is reached in reality this limit is only a small part of
    the problem space. But until then this stops people from trying to paper
    over the problem at the wrong places.
    
    Reported-by: Xiongfeng Wang <wangxiongfeng2@huawei.com>
    Reported-by: Hongbo Yao <yaohongbo@huawei.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Stephen Boyd <sboyd@kernel.org>
    Cc: Miroslav Lichvar <mlichvar@redhat.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: https://lkml.kernel.org/r/alpine.DEB.2.21.1903231125480.2157@nanos.tec.linutronix.de
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit d306fa351148b04a158b208439d11f77df10145d
Author: Vincenzo Frascino <vincenzo.frascino@arm.com>
Date:   Tue Apr 16 17:14:30 2019 +0100

    arm64: vdso: Fix clock_getres() for CLOCK_REALTIME
    
    [ Upstream commit 81fb8736dd81da3fe94f28968dac60f392ec6746 ]
    
    clock_getres() in the vDSO library has to preserve the same behaviour
    of posix_get_hrtimer_res().
    
    In particular, posix_get_hrtimer_res() does:
    
        sec = 0;
        ns = hrtimer_resolution;
    
    where 'hrtimer_resolution' depends on whether or not high resolution
    timers are enabled, which is a runtime decision.
    
    The vDSO incorrectly returns the constant CLOCK_REALTIME_RES. Fix this
    by exposing 'hrtimer_resolution' in the vDSO datapage and returning that
    instead.
    
    Reviewed-by: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Vincenzo Frascino <vincenzo.frascino@arm.com>
    [will: Use WRITE_ONCE(), move adr off COARSE path, renumber labels, use 'w' reg]
    Signed-off-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 5e04fcbab4b417ac1110ec917f653d7eb38fd056
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Mar 23 11:36:19 2019 +0100

    timekeeping: Force upper bound for setting CLOCK_REALTIME
    
    [ Upstream commit 7a8e61f8478639072d402a26789055a4a4de8f77 ]
    
    Several people reported testing failures after setting CLOCK_REALTIME close
    to the limits of the kernel internal representation in nanoseconds,
    i.e. year 2262.
    
    The failures are exposed in subsequent operations, i.e. when arming timers
    or when the advancing CLOCK_MONOTONIC makes the calculation of
    CLOCK_REALTIME overflow into negative space.
    
    Now people start to paper over the underlying problem by clamping
    calculations to the valid range, but that's just wrong because such
    workarounds will prevent detection of real issues as well.
    
    It is reasonable to force an upper bound for the various methods of setting
    CLOCK_REALTIME. Year 2262 is the absolute upper bound. Assume a maximum
    uptime of 30 years which is plenty enough even for esoteric embedded
    systems. That results in an upper bound of year 2232 for setting the time.
    
    Once that limit is reached in reality this limit is only a small part of
    the problem space. But until then this stops people from trying to paper
    over the problem at the wrong places.
    
    Reported-by: Xiongfeng Wang <wangxiongfeng2@huawei.com>
    Reported-by: Hongbo Yao <yaohongbo@huawei.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Stephen Boyd <sboyd@kernel.org>
    Cc: Miroslav Lichvar <mlichvar@redhat.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: https://lkml.kernel.org/r/alpine.DEB.2.21.1903231125480.2157@nanos.tec.linutronix.de
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit cb9552b932fa036281c3ab2fd6456abd2a708fa2
Author: Vincenzo Frascino <vincenzo.frascino@arm.com>
Date:   Tue Apr 16 17:14:30 2019 +0100

    arm64: vdso: Fix clock_getres() for CLOCK_REALTIME
    
    [ Upstream commit 81fb8736dd81da3fe94f28968dac60f392ec6746 ]
    
    clock_getres() in the vDSO library has to preserve the same behaviour
    of posix_get_hrtimer_res().
    
    In particular, posix_get_hrtimer_res() does:
    
        sec = 0;
        ns = hrtimer_resolution;
    
    where 'hrtimer_resolution' depends on whether or not high resolution
    timers are enabled, which is a runtime decision.
    
    The vDSO incorrectly returns the constant CLOCK_REALTIME_RES. Fix this
    by exposing 'hrtimer_resolution' in the vDSO datapage and returning that
    instead.
    
    Reviewed-by: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Vincenzo Frascino <vincenzo.frascino@arm.com>
    [will: Use WRITE_ONCE(), move adr off COARSE path, renumber labels, use 'w' reg]
    Signed-off-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit a0e928ed7c603a47dca8643e58db224a799ff2c5
Merge: 5a2bf1abbf96 13e792a19d4e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon May 6 14:50:46 2019 -0700

    Merge branch 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer updates from Ingo Molnar:
     "This cycle had the following changes:
    
       - Timer tracing improvements (Anna-Maria Gleixner)
    
       - Continued tasklet reduction work: remove the hrtimer_tasklet
         (Thomas Gleixner)
    
       - Fix CPU hotplug remove race in the tick-broadcast mask handling
         code (Thomas Gleixner)
    
       - Force upper bound for setting CLOCK_REALTIME, to fix ABI
         inconsistencies with handling values that are close to the maximum
         supported and the vagueness of when uptime related wraparound might
         occur. Make the consistent maximum the year 2232 across all
         relevant ABIs and APIs. (Thomas Gleixner)
    
       - various cleanups and smaller fixes"
    
    * 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      tick: Fix typos in comments
      tick/broadcast: Fix warning about undefined tick_broadcast_oneshot_offline()
      timekeeping: Force upper bound for setting CLOCK_REALTIME
      timer/trace: Improve timer tracing
      timer/trace: Replace deprecated vsprintf pointer extension %pf by %ps
      timer: Move trace point to get proper index
      tick/sched: Update tick_sched struct documentation
      tick: Remove outgoing CPU from broadcast masks
      timekeeping: Consistently use unsigned int for seqcount snapshot
      softirq: Remove tasklet_hrtimer
      xfrm: Replace hrtimer tasklet with softirq hrtimer
      mac80211_hwsim: Replace hrtimer tasklet with softirq hrtimer

commit bf4bf09bdd91a75bb175c172b3f7251a4845f591
Author: Jacob Keller <jacob.e.keller@intel.com>
Date:   Tue Feb 12 13:56:24 2019 -0800

    i40e: save PTP time before a device reset
    
    In the case where PTP is running on the hardware clock, but the kernel
    system time is not being synced, a device reset can mess up the clock
    time.
    
    This occurs because we reset the clock time based on the kernel time
    every reset. This causes us to potentially completely reset the PTP
    time, and can cause unexpected behavior in programs like ptp4l.
    
    Avoid this by saving the PTP time prior to device reset, and then
    restoring using that time after the reset.
    
    Directly restoring the PTP time we saved isn't perfect, because time
    should have continued running, but the clock will essentially be stopped
    during the reset. This is still better than the current solution of
    assuming that the PTP HW clock is synced to the CLOCK_REALTIME.
    
    We can do even better, by saving the ktime and calculating
    a differential, using ktime_get(). This is based on CLOCK_MONOTONIC, and
    allows us to get a fairly precise measure of the time difference between
    saving and restoring the time.
    
    Using this, we can update the saved PTP time, and use that as the value
    to write to the hardware clock registers. This, of course is not perfect.
    However, it does help ensure that the PTP time is restored as close as
    feasible to the time it should have been if the reset had not occurred.
    
    During device initialization, continue using the system time as the
    source for the creation of the PTP clock, since this is the best known
    current time source at driver load.
    
    Signed-off-by: Jacob Keller <jacob.e.keller@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

commit 81fb8736dd81da3fe94f28968dac60f392ec6746
Author: Vincenzo Frascino <vincenzo.frascino@arm.com>
Date:   Tue Apr 16 17:14:30 2019 +0100

    arm64: vdso: Fix clock_getres() for CLOCK_REALTIME
    
    clock_getres() in the vDSO library has to preserve the same behaviour
    of posix_get_hrtimer_res().
    
    In particular, posix_get_hrtimer_res() does:
    
        sec = 0;
        ns = hrtimer_resolution;
    
    where 'hrtimer_resolution' depends on whether or not high resolution
    timers are enabled, which is a runtime decision.
    
    The vDSO incorrectly returns the constant CLOCK_REALTIME_RES. Fix this
    by exposing 'hrtimer_resolution' in the vDSO datapage and returning that
    instead.
    
    Reviewed-by: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Vincenzo Frascino <vincenzo.frascino@arm.com>
    [will: Use WRITE_ONCE(), move adr off COARSE path, renumber labels, use 'w' reg]
    Signed-off-by: Will Deacon <will.deacon@arm.com>

commit 7a8e61f8478639072d402a26789055a4a4de8f77
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Mar 23 11:36:19 2019 +0100

    timekeeping: Force upper bound for setting CLOCK_REALTIME
    
    Several people reported testing failures after setting CLOCK_REALTIME close
    to the limits of the kernel internal representation in nanoseconds,
    i.e. year 2262.
    
    The failures are exposed in subsequent operations, i.e. when arming timers
    or when the advancing CLOCK_MONOTONIC makes the calculation of
    CLOCK_REALTIME overflow into negative space.
    
    Now people start to paper over the underlying problem by clamping
    calculations to the valid range, but that's just wrong because such
    workarounds will prevent detection of real issues as well.
    
    It is reasonable to force an upper bound for the various methods of setting
    CLOCK_REALTIME. Year 2262 is the absolute upper bound. Assume a maximum
    uptime of 30 years which is plenty enough even for esoteric embedded
    systems. That results in an upper bound of year 2232 for setting the time.
    
    Once that limit is reached in reality this limit is only a small part of
    the problem space. But until then this stops people from trying to paper
    over the problem at the wrong places.
    
    Reported-by: Xiongfeng Wang <wangxiongfeng2@huawei.com>
    Reported-by: Hongbo Yao <yaohongbo@huawei.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Stephen Boyd <sboyd@kernel.org>
    Cc: Miroslav Lichvar <mlichvar@redhat.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: https://lkml.kernel.org/r/alpine.DEB.2.21.1903231125480.2157@nanos.tec.linutronix.de

commit 3876ced476c8ec17265d1739467e726ada88b660
Author: Deepa Dinamani <deepa.kernel@gmail.com>
Date:   Mon Jul 2 22:44:22 2018 -0700

    timex: change syscalls to use struct __kernel_timex
    
    struct timex is not y2038 safe.
    Switch all the syscall apis to use y2038 safe __kernel_timex.
    
    Note that sys_adjtimex() does not have a y2038 safe solution.  C libraries
    can implement it by calling clock_adjtime(CLOCK_REALTIME, ...).
    
    Signed-off-by: Deepa Dinamani <deepa.kernel@gmail.com>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

commit e6992eadc22ec2aef959099ae2cef59f83303069
Author: Anton Blanchard <anton@samba.org>
Date:   Sun Sep 25 17:16:53 2016 +1000

    powerpc/vdso64: Use double word compare on pointers
    
    [ Upstream commit 5045ea37377ce8cca6890d32b127ad6770e6dce5 ]
    
    __kernel_get_syscall_map() and __kernel_clock_getres() use cmpli to
    check if the passed in pointer is non zero. cmpli maps to a 32 bit
    compare on binutils, so we ignore the top 32 bits.
    
    A simple test case can be created by passing in a bogus pointer with
    the bottom 32 bits clear. Using a clk_id that is handled by the VDSO,
    then one that is handled by the kernel shows the problem:
    
      printf("%d\n", clock_getres(CLOCK_REALTIME, (void *)0x100000000));
      printf("%d\n", clock_getres(CLOCK_BOOTTIME, (void *)0x100000000));
    
    And we get:
    
      0
      -1
    
    The bigger issue is if we pass a valid pointer with the bottom 32 bits
    clear, in this case we will return success but won't write any data
    to the pointer.
    
    I stumbled across this issue because the LLVM integrated assembler
    doesn't accept cmpli with 3 arguments. Fix this by converting them to
    cmpldi.
    
    Fixes: a7f290dad32e ("[PATCH] powerpc: Merge vdso's and add vdso support to 32 bits kernel")
    Cc: stable@vger.kernel.org # v2.6.15+
    Signed-off-by: Anton Blanchard <anton@samba.org>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit f40d90dd556713bc2247b1b4d8362c04cdf4428a
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Jun 18 16:47:34 2018 +0200

    rcutorture: Use monotonic timestamp for stall detection
    
    [ Upstream commit 622be33fcbc93e9b672b99ed338369eb5e843ac3 ]
    
    The get_seconds() call is deprecated because it overflows on 32-bit
    architectures. The algorithm in rcu_torture_stall() can deal with
    the overflow, but another problem here is that using a CLOCK_REALTIME
    stamp can lead to a false-positive stall warning when a settimeofday()
    happens concurrently.
    
    Using ktime_get_seconds() instead avoids those issues and will never
    overflow. The added cast to 'unsigned long' however is necessary to
    make ULONG_CMP_LT() work correctly.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Signed-off-by: Sasha Levin <alexander.levin@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 34d082604a7c8856051ff441fef0e22d93afd848
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Aug 21 21:59:26 2018 -0700

    reiserfs: use monotonic time for j_trans_start_time
    
    Using CLOCK_REALTIME time_t timestamps breaks on 32-bit systems in 2038,
    and gives surprising results with a concurrent settimeofday().
    
    This changes the reiserfs journal timestamps to use ktime_get_seconds()
    instead, which makes it use a 64-bit CLOCK_MONOTONIC stamp.
    
    In the procfs output, the monotonic timestamp needs to be converted back
    to CLOCK_REALTIME to keep the existing ABI.
    
    Link: http://lkml.kernel.org/r/20180620142522.27639-2-arnd@arndb.de
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Reviewed-by: Jan Kara <jack@suse.cz>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit 2c1bb29aa6e7b0e52d84bd06bc199b0a5076a781
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Aug 17 15:43:44 2018 -0700

    firewire: use 64-bit time_t based interfaces
    
    32-bit CLOCK_REALTIME timestamps overflow in year 2038, so all such
    interfaces are deprecated now.  For the FW_CDEV_IOC_GET_CYCLE_TIMER2
    ioctl, we already support 64-bit timestamps, but the implementation
    still uses timespec.
    
    This changes the code to use timespec64 instead with the appropriate
    accessor functions.
    
    Link: http://lkml.kernel.org/r/20180711124456.1023039-1-arnd@arndb.de
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Cc: Stefan Richter <stefanr@s5r6.in-berlin.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit 622be33fcbc93e9b672b99ed338369eb5e843ac3
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Jun 18 16:47:34 2018 +0200

    rcutorture: Use monotonic timestamp for stall detection
    
    The get_seconds() call is deprecated because it overflows on 32-bit
    architectures. The algorithm in rcu_torture_stall() can deal with
    the overflow, but another problem here is that using a CLOCK_REALTIME
    stamp can lead to a false-positive stall warning when a settimeofday()
    happens concurrently.
    
    Using ktime_get_seconds() instead avoids those issues and will never
    overflow. The added cast to 'unsigned long' however is necessary to
    make ULONG_CMP_LT() work correctly.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>

commit cca9bab1b72cd2296097c75f59ef11ef80461279
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Jul 11 12:16:12 2018 +0200

    tcp: use monotonic timestamps for PAWS
    
    Using get_seconds() for timestamps is deprecated since it can lead
    to overflows on 32-bit systems. While the interface generally doesn't
    overflow until year 2106, the specific implementation of the TCP PAWS
    algorithm breaks in 2038 when the intermediate signed 32-bit timestamps
    overflow.
    
    A related problem is that the local timestamps in CLOCK_REALTIME form
    lead to unexpected behavior when settimeofday is called to set the system
    clock backwards or forwards by more than 24 days.
    
    While the first problem could be solved by using an overflow-safe method
    of comparing the timestamps, a nicer solution is to use a monotonic
    clocksource with ktime_get_seconds() that simply doesn't overflow (at
    least not until 136 years after boot) and that doesn't change during
    settimeofday().
    
    To make 32-bit and 64-bit architectures behave the same way here, and
    also save a few bytes in the tcp_options_received structure, I'm changing
    the type to a 32-bit integer, which is now safe on all architectures.
    
    Finally, the ts_recent_stamp field also (confusingly) gets used to store
    a jiffies value in tcp_synq_overflow()/tcp_synq_no_recent_overflow().
    This is currently safe, but changing the type to 32-bit requires
    some small changes there to keep it working.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 07f3355df7e6d043d36d4c172a18e74510fe7e7b
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Jul 9 10:34:43 2018 +0200

    infiniband: i40iw, nes: don't use wall time for TCP sequence numbers
    
    The nes infiniband driver uses current_kernel_time() to get a nanosecond
    granunarity timestamp to initialize its tcp sequence counters. This is
    one of only a few remaining users of that deprecated function, so we
    should try to get rid of it.
    
    Aside from using a deprecated API, there are several problems I see here:
    
    - Using a CLOCK_REALTIME based time source makes it predictable in
      case the time base is synchronized.
    - Using a coarse timestamp means it only gets updated once per jiffie,
      making it even more predictable in order to avoid having to access
      the hardware clock source
    - The upper 2 bits are always zero because the nanoseconds are at most
      999999999.
    
    For the Linux TCP implementation, we use secure_tcp_seq(), which appears
    to be appropriate here as well, and solves all the above problems.
    
    i40iw uses a variant of the same code, so I do that same thing there
    for ipv4. Unlike nes, i40e also supports ipv6, which needs to call
    secure_tcpv6_seq instead.
    
    Acked-by: Shiraz Saleem <shiraz.saleem@intel.com>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>

commit 88cab77162e86e0f6a2b7e4f859c1435c4e24feb
Author: Jesus Sanchez-Palencia <jesus.sanchez-palencia@intel.com>
Date:   Tue Jul 3 15:42:54 2018 -0700

    net/sched: Add HW offloading capability to ETF
    
    Add infra so etf qdisc supports HW offload of time-based transmission.
    
    For hw offload, the time sorted list is still used, so packets are
    dequeued always in order of txtime.
    
    Example:
    
    $ tc qdisc replace dev enp2s0 parent root handle 100 mqprio num_tc 3 \
               map 2 2 1 0 2 2 2 2 2 2 2 2 2 2 2 2 queues 1@0 1@1 2@2 hw 0
    
    $ tc qdisc add dev enp2s0 parent 100:1 etf offload delta 100000 \
               clockid CLOCK_REALTIME
    
    In this example, the Qdisc will use HW offload for the control of the
    transmission time through the network adapter. The hrtimer used for
    packets scheduling inside the qdisc will use the clockid CLOCK_REALTIME
    as reference and packets leave the Qdisc "delta" (100000) nanoseconds
    before their transmission time. Because this will be using HW offload and
    since dynamic clocks are not supported by the hrtimer, the system clock
    and the PHC clock must be synchronized for this mode to behave as
    expected.
    
    Signed-off-by: Jesus Sanchez-Palencia <jesus.sanchez-palencia@intel.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit fe7f4e5d11541402f54ebd777a4f49caee891401
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Jun 18 17:29:51 2018 +0200

    scsi: scsi_transport_fc: use 64-bit timestamps consistently
    
    The get_seconds() helper returns an 'unsigned long' value, which can
    overflow on 32-bit architectures. Since the interface we pass it into
    already uses a 64-bit type, we can just use ktime_get_real_seconds()
    instead.
    
    While we generally prefer local timestamps in CLOCK_MONOTONIC format
    (ktime_get_seconds), this keeps using the CLOCK_REALTIME version in order
    to maintain compatibility with existing code.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Reviewed-by: Tyrel Datwyler <tyreld@linux.vnet.ibm.com>
    Reviewed-by: James Smart <james.smart@broadcom.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

commit ac1cd8d483c9574f3b5edfe952897df3f1af24b8
Author: Anna-Maria Gleixner <anna-maria@linutronix.de>
Date:   Thu Dec 21 11:41:35 2017 +0100

    hrtimer: Ensure POSIX compliance (relative CLOCK_REALTIME hrtimers)
    
    commit 48d0c9becc7f3c66874c100c126459a9da0fdced upstream.
    
    The POSIX specification defines that relative CLOCK_REALTIME timers are not
    affected by clock modifications. Those timers have to use CLOCK_MONOTONIC
    to ensure POSIX compliance.
    
    The introduction of the additional HRTIMER_MODE_PINNED mode broke this
    requirement for pinned timers.
    
    There is no user space visible impact because user space timers are not
    using pinned mode, but for consistency reasons this needs to be fixed.
    
    Check whether the mode has the HRTIMER_MODE_REL bit set instead of
    comparing with HRTIMER_MODE_ABS.
    
    Signed-off-by: Anna-Maria Gleixner <anna-maria@linutronix.de>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: keescook@chromium.org
    Fixes: 597d0275736d ("timers: Framework for identifying pinned timers")
    Link: http://lkml.kernel.org/r/20171221104205.7269-7-anna-maria@linutronix.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    [bwh: Backported to 3.16: adjust filename]
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit dcc9bd87a2825e27df2dde6425b32d9da48421b2
Author: Anna-Maria Gleixner <anna-maria@linutronix.de>
Date:   Thu Dec 21 11:41:35 2017 +0100

    hrtimer: Ensure POSIX compliance (relative CLOCK_REALTIME hrtimers)
    
    commit 48d0c9becc7f3c66874c100c126459a9da0fdced upstream.
    
    The POSIX specification defines that relative CLOCK_REALTIME timers are not
    affected by clock modifications. Those timers have to use CLOCK_MONOTONIC
    to ensure POSIX compliance.
    
    The introduction of the additional HRTIMER_MODE_PINNED mode broke this
    requirement for pinned timers.
    
    There is no user space visible impact because user space timers are not
    using pinned mode, but for consistency reasons this needs to be fixed.
    
    Check whether the mode has the HRTIMER_MODE_REL bit set instead of
    comparing with HRTIMER_MODE_ABS.
    
    Signed-off-by: Anna-Maria Gleixner <anna-maria@linutronix.de>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: keescook@chromium.org
    Fixes: 597d0275736d ("timers: Framework for identifying pinned timers")
    Link: http://lkml.kernel.org/r/20171221104205.7269-7-anna-maria@linutronix.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    [bwh: Backported to 3.2: adjust filename]
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit e3ae971af7896594df867abb2c07e8a7732a4915
Author: Anna-Maria Gleixner <anna-maria@linutronix.de>
Date:   Thu Dec 21 11:41:37 2017 +0100

    tracing/hrtimer: Fix tracing bugs by taking all clock bases and modes into account
    
    [ Upstream commit 91633eed73a3ac37aaece5c8c1f93a18bae616a9 ]
    
    So far only CLOCK_MONOTONIC and CLOCK_REALTIME were taken into account as
    well as HRTIMER_MODE_ABS/REL in the hrtimer_init tracepoint. The query for
    detecting the ABS or REL timer modes is not valid anymore, it got broken
    by the introduction of HRTIMER_MODE_PINNED.
    
    HRTIMER_MODE_PINNED is not evaluated in the hrtimer_init() call, but for the
    sake of completeness print all given modes.
    
    Signed-off-by: Anna-Maria Gleixner <anna-maria@linutronix.de>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: keescook@chromium.org
    Link: http://lkml.kernel.org/r/20171221104205.7269-9-anna-maria@linutronix.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Sasha Levin <alexander.levin@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 1c0467b9771fba4db5ea348b1788e7a553c93931
Author: Anna-Maria Gleixner <anna-maria@linutronix.de>
Date:   Thu Dec 21 11:41:37 2017 +0100

    tracing/hrtimer: Fix tracing bugs by taking all clock bases and modes into account
    
    [ Upstream commit 91633eed73a3ac37aaece5c8c1f93a18bae616a9 ]
    
    So far only CLOCK_MONOTONIC and CLOCK_REALTIME were taken into account as
    well as HRTIMER_MODE_ABS/REL in the hrtimer_init tracepoint. The query for
    detecting the ABS or REL timer modes is not valid anymore, it got broken
    by the introduction of HRTIMER_MODE_PINNED.
    
    HRTIMER_MODE_PINNED is not evaluated in the hrtimer_init() call, but for the
    sake of completeness print all given modes.
    
    Signed-off-by: Anna-Maria Gleixner <anna-maria@linutronix.de>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: keescook@chromium.org
    Link: http://lkml.kernel.org/r/20171221104205.7269-9-anna-maria@linutronix.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Sasha Levin <alexander.levin@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit ec8e8efa397d3373a75b7384937e06c2c379190c
Author: Anna-Maria Gleixner <anna-maria@linutronix.de>
Date:   Thu Dec 21 11:41:37 2017 +0100

    tracing/hrtimer: Fix tracing bugs by taking all clock bases and modes into account
    
    [ Upstream commit 91633eed73a3ac37aaece5c8c1f93a18bae616a9 ]
    
    So far only CLOCK_MONOTONIC and CLOCK_REALTIME were taken into account as
    well as HRTIMER_MODE_ABS/REL in the hrtimer_init tracepoint. The query for
    detecting the ABS or REL timer modes is not valid anymore, it got broken
    by the introduction of HRTIMER_MODE_PINNED.
    
    HRTIMER_MODE_PINNED is not evaluated in the hrtimer_init() call, but for the
    sake of completeness print all given modes.
    
    Signed-off-by: Anna-Maria Gleixner <anna-maria@linutronix.de>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: keescook@chromium.org
    Link: http://lkml.kernel.org/r/20171221104205.7269-9-anna-maria@linutronix.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Sasha Levin <alexander.levin@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit a5a8ca753c0c4659287416ce282ba357c30098a8
Author: Anna-Maria Gleixner <anna-maria@linutronix.de>
Date:   Thu Dec 21 11:41:37 2017 +0100

    tracing/hrtimer: Fix tracing bugs by taking all clock bases and modes into account
    
    
    [ Upstream commit 91633eed73a3ac37aaece5c8c1f93a18bae616a9 ]
    
    So far only CLOCK_MONOTONIC and CLOCK_REALTIME were taken into account as
    well as HRTIMER_MODE_ABS/REL in the hrtimer_init tracepoint. The query for
    detecting the ABS or REL timer modes is not valid anymore, it got broken
    by the introduction of HRTIMER_MODE_PINNED.
    
    HRTIMER_MODE_PINNED is not evaluated in the hrtimer_init() call, but for the
    sake of completeness print all given modes.
    
    Signed-off-by: Anna-Maria Gleixner <anna-maria@linutronix.de>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: keescook@chromium.org
    Link: http://lkml.kernel.org/r/20171221104205.7269-9-anna-maria@linutronix.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Sasha Levin <alexander.levin@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 37efe80ce85f76b3b30d7b4ea40550e6a5a5b71a
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Jan 16 18:18:43 2018 +0100

    drm/vmwgfx: use monotonic event timestamps
    
    DRM_VMW_EVENT_FENCE_SIGNALED (struct drm_vmw_event_fence) and
    DRM_EVENT_VBLANK (struct drm_event_vblank) pass timestamps in 32-bit
    seconds/microseconds format.
    
    As of commit c61eef726a78 ("drm: add support for monotonic vblank
    timestamps"), other DRM drivers use monotonic times for drm_event_vblank,
    but vmwgfx still uses CLOCK_REALTIME for both events, which suffers from
    the y2038/y2106 overflow as well as time jumps.
    
    For consistency, this changes vmwgfx to use ktime_get_ts64 as well,
    which solves those problems and avoids the deprecated do_gettimeofday()
    function.
    
    This should be transparent to to user space, as long as it doesn't
    compare the time against the result of gettimeofday().
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>

commit 291a16f3a8db60c0ba4a3a04ca193e90389e2396
Author: Anna-Maria Gleixner <anna-maria@linutronix.de>
Date:   Thu Dec 21 11:41:35 2017 +0100

    hrtimer: Ensure POSIX compliance (relative CLOCK_REALTIME hrtimers)
    
    [ Upstream commit 48d0c9becc7f3c66874c100c126459a9da0fdced ]
    
    The POSIX specification defines that relative CLOCK_REALTIME timers are not
    affected by clock modifications. Those timers have to use CLOCK_MONOTONIC
    to ensure POSIX compliance.
    
    The introduction of the additional HRTIMER_MODE_PINNED mode broke this
    requirement for pinned timers.
    
    There is no user space visible impact because user space timers are not
    using pinned mode, but for consistency reasons this needs to be fixed.
    
    Check whether the mode has the HRTIMER_MODE_REL bit set instead of
    comparing with HRTIMER_MODE_ABS.
    
    Signed-off-by: Anna-Maria Gleixner <anna-maria@linutronix.de>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: keescook@chromium.org
    Fixes: 597d0275736d ("timers: Framework for identifying pinned timers")
    Link: http://lkml.kernel.org/r/20171221104205.7269-7-anna-maria@linutronix.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Sasha Levin <alexander.levin@microsoft.com>

commit d3b7976e60c600843e78cdb87abced3aa71cf495
Author: Anna-Maria Gleixner <anna-maria@linutronix.de>
Date:   Thu Dec 21 11:41:35 2017 +0100

    hrtimer: Ensure POSIX compliance (relative CLOCK_REALTIME hrtimers)
    
    commit 48d0c9becc7f3c66874c100c126459a9da0fdced upstream.
    
    The POSIX specification defines that relative CLOCK_REALTIME timers are not
    affected by clock modifications. Those timers have to use CLOCK_MONOTONIC
    to ensure POSIX compliance.
    
    The introduction of the additional HRTIMER_MODE_PINNED mode broke this
    requirement for pinned timers.
    
    There is no user space visible impact because user space timers are not
    using pinned mode, but for consistency reasons this needs to be fixed.
    
    Check whether the mode has the HRTIMER_MODE_REL bit set instead of
    comparing with HRTIMER_MODE_ABS.
    
    Signed-off-by: Anna-Maria Gleixner <anna-maria@linutronix.de>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: keescook@chromium.org
    Fixes: 597d0275736d ("timers: Framework for identifying pinned timers")
    Link: http://lkml.kernel.org/r/20171221104205.7269-7-anna-maria@linutronix.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 0edffe75fc811fa5181ea202a1ad26bf17fd58f5
Author: Anton Blanchard <anton@samba.org>
Date:   Fri Mar 2 15:45:49 2018 +1100

    powerpc/vdso64: Use double word compare on pointers
    
    commit 5045ea37377ce8cca6890d32b127ad6770e6dce5 upstream.
    
    __kernel_get_syscall_map() and __kernel_clock_getres() use cmpli to
    check if the passed in pointer is non zero. cmpli maps to a 32 bit
    compare on binutils, so we ignore the top 32 bits.
    
    A simple test case can be created by passing in a bogus pointer with
    the bottom 32 bits clear. Using a clk_id that is handled by the VDSO,
    then one that is handled by the kernel shows the problem:
    
      printf("%d\n", clock_getres(CLOCK_REALTIME, (void *)0x100000000));
      printf("%d\n", clock_getres(CLOCK_BOOTTIME, (void *)0x100000000));
    
    And we get:
    
      0
      -1
    
    The bigger issue is if we pass a valid pointer with the bottom 32 bits
    clear, in this case we will return success but won't write any data
    to the pointer.
    
    I stumbled across this issue because the LLVM integrated assembler
    doesn't accept cmpli with 3 arguments. Fix this by converting them to
    cmpldi.
    
    Fixes: a7f290dad32e ("[PATCH] powerpc: Merge vdso's and add vdso support to 32 bits kernel")
    Cc: stable@vger.kernel.org # v2.6.15+
    Signed-off-by: Anton Blanchard <anton@samba.org>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Signed-off-by: Sasha Levin <alexander.levin@microsoft.com>

commit f92679fee6ad1a13c8e82cf1f5769cef27343f78
Author: Anna-Maria Gleixner <anna-maria@linutronix.de>
Date:   Thu Dec 21 11:41:35 2017 +0100

    hrtimer: Ensure POSIX compliance (relative CLOCK_REALTIME hrtimers)
    
    commit 48d0c9becc7f3c66874c100c126459a9da0fdced upstream.
    
    The POSIX specification defines that relative CLOCK_REALTIME timers are not
    affected by clock modifications. Those timers have to use CLOCK_MONOTONIC
    to ensure POSIX compliance.
    
    The introduction of the additional HRTIMER_MODE_PINNED mode broke this
    requirement for pinned timers.
    
    There is no user space visible impact because user space timers are not
    using pinned mode, but for consistency reasons this needs to be fixed.
    
    Check whether the mode has the HRTIMER_MODE_REL bit set instead of
    comparing with HRTIMER_MODE_ABS.
    
    Signed-off-by: Anna-Maria Gleixner <anna-maria@linutronix.de>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: keescook@chromium.org
    Fixes: 597d0275736d ("timers: Framework for identifying pinned timers")
    Link: http://lkml.kernel.org/r/20171221104205.7269-7-anna-maria@linutronix.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 5a9f69b2c11bee48b1884165e4e1473f7672dc28
Author: Anna-Maria Gleixner <anna-maria@linutronix.de>
Date:   Thu Dec 21 11:41:35 2017 +0100

    hrtimer: Ensure POSIX compliance (relative CLOCK_REALTIME hrtimers)
    
    commit 48d0c9becc7f3c66874c100c126459a9da0fdced upstream.
    
    The POSIX specification defines that relative CLOCK_REALTIME timers are not
    affected by clock modifications. Those timers have to use CLOCK_MONOTONIC
    to ensure POSIX compliance.
    
    The introduction of the additional HRTIMER_MODE_PINNED mode broke this
    requirement for pinned timers.
    
    There is no user space visible impact because user space timers are not
    using pinned mode, but for consistency reasons this needs to be fixed.
    
    Check whether the mode has the HRTIMER_MODE_REL bit set instead of
    comparing with HRTIMER_MODE_ABS.
    
    Signed-off-by: Anna-Maria Gleixner <anna-maria@linutronix.de>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: keescook@chromium.org
    Fixes: 597d0275736d ("timers: Framework for identifying pinned timers")
    Link: http://lkml.kernel.org/r/20171221104205.7269-7-anna-maria@linutronix.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit b77d5ffcb7528dd9ae9510d899b08a5f325bfeeb
Author: Anna-Maria Gleixner <anna-maria@linutronix.de>
Date:   Thu Dec 21 11:41:35 2017 +0100

    hrtimer: Ensure POSIX compliance (relative CLOCK_REALTIME hrtimers)
    
    commit 48d0c9becc7f3c66874c100c126459a9da0fdced upstream.
    
    The POSIX specification defines that relative CLOCK_REALTIME timers are not
    affected by clock modifications. Those timers have to use CLOCK_MONOTONIC
    to ensure POSIX compliance.
    
    The introduction of the additional HRTIMER_MODE_PINNED mode broke this
    requirement for pinned timers.
    
    There is no user space visible impact because user space timers are not
    using pinned mode, but for consistency reasons this needs to be fixed.
    
    Check whether the mode has the HRTIMER_MODE_REL bit set instead of
    comparing with HRTIMER_MODE_ABS.
    
    Signed-off-by: Anna-Maria Gleixner <anna-maria@linutronix.de>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: keescook@chromium.org
    Fixes: 597d0275736d ("timers: Framework for identifying pinned timers")
    Link: http://lkml.kernel.org/r/20171221104205.7269-7-anna-maria@linutronix.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 5ae0e9de0ac6728f8a29612ff216240945a25dc8
Author: Anna-Maria Gleixner <anna-maria@linutronix.de>
Date:   Thu Dec 21 11:41:35 2017 +0100

    hrtimer: Ensure POSIX compliance (relative CLOCK_REALTIME hrtimers)
    
    commit 48d0c9becc7f3c66874c100c126459a9da0fdced upstream.
    
    The POSIX specification defines that relative CLOCK_REALTIME timers are not
    affected by clock modifications. Those timers have to use CLOCK_MONOTONIC
    to ensure POSIX compliance.
    
    The introduction of the additional HRTIMER_MODE_PINNED mode broke this
    requirement for pinned timers.
    
    There is no user space visible impact because user space timers are not
    using pinned mode, but for consistency reasons this needs to be fixed.
    
    Check whether the mode has the HRTIMER_MODE_REL bit set instead of
    comparing with HRTIMER_MODE_ABS.
    
    Signed-off-by: Anna-Maria Gleixner <anna-maria@linutronix.de>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: keescook@chromium.org
    Fixes: 597d0275736d ("timers: Framework for identifying pinned timers")
    Link: http://lkml.kernel.org/r/20171221104205.7269-7-anna-maria@linutronix.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 3258abe0991590a182be0a20ef6b79b65fe2c9cd
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Mon Jan 22 12:56:59 2018 -0300

    perf trace beauty futex: Beautify FUTEX_BITSET_MATCH_ANY
    
    E.g.:
    
      # strace -e futex -p 14437
      strace: Process 14437 attached
      futex(0x7f46f4808d70, FUTEX_WAKE_PRIVATE, 1) = 0
      futex(0x7f46f24e68b0, FUTEX_WAIT_BITSET_PRIVATE|FUTEX_CLOCK_REALTIME, 0, {tv_sec=1516636744, tv_nsec=221969000}, 0xffffffff) = -1 ETIMEDOUT (Connection timed out)
     <detached ...>
      #
    
    Should pretty print that 0xffffffff value, like:
    
      # trace -e futex --tid 14437
         0.028 (   0.005 ms): futex(uaddr: 0x7f46f4808d70, op: WAKE|PRIV, val: 1                    ) = 0
         0.037 (1000.092 ms): futex(uaddr: 0x7f46f24e68b0, op: WAIT_BITSET|PRIV|CLKRT, utime: 0x7f46f23fedf0, val3: MATCH_ANY) = -1 ETIMEDOUT Connection timed out
    ^C#
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Wang Nan <wangnan0@huawei.com>
    Link: https://lkml.kernel.org/n/tip-raef6e352la90600yksthao1@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

commit 91633eed73a3ac37aaece5c8c1f93a18bae616a9
Author: Anna-Maria Gleixner <anna-maria@linutronix.de>
Date:   Thu Dec 21 11:41:37 2017 +0100

    tracing/hrtimer: Fix tracing bugs by taking all clock bases and modes into account
    
    So far only CLOCK_MONOTONIC and CLOCK_REALTIME were taken into account as
    well as HRTIMER_MODE_ABS/REL in the hrtimer_init tracepoint. The query for
    detecting the ABS or REL timer modes is not valid anymore, it got broken
    by the introduction of HRTIMER_MODE_PINNED.
    
    HRTIMER_MODE_PINNED is not evaluated in the hrtimer_init() call, but for the
    sake of completeness print all given modes.
    
    Signed-off-by: Anna-Maria Gleixner <anna-maria@linutronix.de>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: keescook@chromium.org
    Link: http://lkml.kernel.org/r/20171221104205.7269-9-anna-maria@linutronix.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 48d0c9becc7f3c66874c100c126459a9da0fdced
Author: Anna-Maria Gleixner <anna-maria@linutronix.de>
Date:   Thu Dec 21 11:41:35 2017 +0100

    hrtimer: Ensure POSIX compliance (relative CLOCK_REALTIME hrtimers)
    
    The POSIX specification defines that relative CLOCK_REALTIME timers are not
    affected by clock modifications. Those timers have to use CLOCK_MONOTONIC
    to ensure POSIX compliance.
    
    The introduction of the additional HRTIMER_MODE_PINNED mode broke this
    requirement for pinned timers.
    
    There is no user space visible impact because user space timers are not
    using pinned mode, but for consistency reasons this needs to be fixed.
    
    Check whether the mode has the HRTIMER_MODE_REL bit set instead of
    comparing with HRTIMER_MODE_ABS.
    
    Signed-off-by: Anna-Maria Gleixner <anna-maria@linutronix.de>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: keescook@chromium.org
    Fixes: 597d0275736d ("timers: Framework for identifying pinned timers")
    Link: http://lkml.kernel.org/r/20171221104205.7269-7-anna-maria@linutronix.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 5c929885f1bb4b77f85b1769c49405a0e0f154a1
Author: Santosh Sivaraj <santosh@fossix.org>
Date:   Mon Oct 16 11:19:14 2017 +0530

    powerpc/vdso64: Add support for CLOCK_{REALTIME/MONOTONIC}_COARSE
    
    Current vDSO64 implementation does not have support for coarse clocks
    (CLOCK_MONOTONIC_COARSE, CLOCK_REALTIME_COARSE), for which it falls back
    to system call, increasing the response time, vDSO implementation reduces
    the cycle time. Below is a benchmark of the difference in execution times.
    
    (Non-coarse clocks are also included just for completion)
    
    clock-gettime-realtime: syscall: 172 nsec/call
    clock-gettime-realtime:    libc: 28 nsec/call
    clock-gettime-realtime:    vdso: 22 nsec/call
    clock-gettime-monotonic: syscall: 171 nsec/call
    clock-gettime-monotonic:    libc: 30 nsec/call
    clock-gettime-monotonic:    vdso: 25 nsec/call
    clock-gettime-realtime-coarse: syscall: 153 nsec/call
    clock-gettime-realtime-coarse:    libc: 16 nsec/call
    clock-gettime-realtime-coarse:    vdso: 10 nsec/call
    clock-gettime-monotonic-coarse: syscall: 167 nsec/call
    clock-gettime-monotonic-coarse:    libc: 17 nsec/call
    clock-gettime-monotonic-coarse:    vdso: 11 nsec/call
    
    CC: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Reviewed-by: Naveen N. Rao <naveen.n.rao@linux.vnet.ibm.com>
    Signed-off-by: Santosh Sivaraj <santosh@fossix.org>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

commit 7a615c8566d78a8a0d07de99ef5c6da7f61c77b7
Author: Wang YanQing <udknight@gmail.com>
Date:   Tue Jun 23 18:38:54 2015 +0800

    time: Always make sure wall_to_monotonic isn't positive
    
    commit e1d7ba8735551ed79c7a0463a042353574b96da3 upstream.
    
    Two issues were found on an IMX6 development board without an
    enabled RTC device(resulting in the boot time and monotonic
    time being initialized to 0).
    
    Issue 1:exportfs -a generate:
           "exportfs: /opt/nfs/arm does not support NFS export"
    Issue 2:cat /proc/stat:
           "btime 4294967236"
    
    The same issues can be reproduced on x86 after running the
    following code:
            int main(void)
            {
                struct timeval val;
                int ret;
    
                val.tv_sec = 0;
                val.tv_usec = 0;
                ret = settimeofday(&val, NULL);
                return 0;
            }
    
    Two issues are different symptoms of same problem:
    The reason is a positive wall_to_monotonic pushes boot time back
    to the time before Epoch, and getboottime will return negative
    value.
    
    In symptom 1:
              negative boot time cause get_expiry() to overflow time_t
              when input expire time is 2147483647, then cache_flush()
              always clears entries just added in ip_map_parse.
    In symptom 2:
              show_stat() uses "unsigned long" to print negative btime
              value returned by getboottime.
    
    This patch fix the problem by prohibiting time from being set to a value which
    would cause a negative boot time. As a result one can't set the CLOCK_REALTIME
    time prior to (1970 + system uptime).
    
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Wang YanQing <udknight@gmail.com>
    [jstultz: reworded commit message]
    [msfjarvis: Backport to 3.18 as we are missing the do_settimeofday64
    function the upstream commit patches, so we apply the changes to
    do_settimeofday]
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Harsh Shandilya <msfjarvis@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit eefd95e1f3d47b90dc768e9ebc77d390c4f34809
Author: Shuah Khan <shuah@kernel.org>
Date:   Thu Sep 21 13:05:18 2017 -0600

    selftests: timers: set-timer-lat: Fix hang when testing unsupported alarms
    
    When timer_create() fails on a bootime or realtime clock, setup_timer()
    returns 0 as if timer has been set. Callers wait forever for the timer
    to expire.
    
    This hang is seen on a system that doesn't have support for:
    
    CLOCK_REALTIME_ALARM   ABSTIME missing CAP_WAKE_ALARM? : [UNSUPPORTED]
    
    Test hangs waiting for a timer that hasn't been set to expire. Fix
    setup_timer() to return 1, add handling in callers to detect the
    unsupported case and return 0 without waiting to not fail the test.
    
    Signed-off-by: Shuah Khan <shuahkh@osg.samsung.com>

commit 67edab48caeb75d412706f4b9d3107afd1e07623
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Jun 12 19:39:49 2017 +0200

    posix-timers: Handle relative posix-timers correctly
    
    The recent rework of the posix timer internals broke the magic posix
    mechanism, which requires that relative timers are not affected by
    modifications of the underlying clock. That means relative CLOCK_REALTIME
    timers cannot use CLOCK_REALTIME, because that can be set and adjusted. The
    underlying hrtimer switches the clock for these timers to CLOCK_MONOTONIC.
    
    That still works, but reading the remaining time of such a timer has been
    broken in the rework. The old code used the hrtimer internals directly and
    avoided the posix clock callbacks. Now common_timer_get() uses the
    underlying kclock->timer_get() callback, which is still CLOCK_REALTIME
    based. So the remaining time of such a timer is calculated against the
    wrong time base.
    
    Handle it by switching the k_itimer->kclock pointer according to the
    resulting hrtimer mode. k_itimer->it_clock still contains CLOCK_REALTIME
    because the timer might be set with ABSTIME later and then it needs to
    switch back to the realtime posix clock implementation.
    
    Fixes: eae1c4ae275f ("posix-timers: Make use of cancel/arm callbacks")
    Reported-by: Andrei Vagin <avagin@virtuozzo.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Cyrill Gorcunov <gorcunov@openvz.org>
    Link: http://lkml.kernel.org/r/20170609201156.GB21491@outlook.office365.com

commit 25b68a8f0ab13a98de02650208ec927796659898
Author: Stephen Smalley <sds@tycho.nsa.gov>
Date:   Fri Feb 17 10:13:59 2017 -0500

    timerfd: Only check CAP_WAKE_ALARM when it is needed
    
    timerfd_create() and do_timerfd_settime() evaluate capable(CAP_WAKE_ALARM)
    unconditionally although CAP_WAKE_ALARM is only required for
    CLOCK_REALTIME_ALARM and CLOCK_BOOTTIME_ALARM.
    
    This can cause extraneous audit messages when using a LSM such as SELinux,
    incorrectly causes PF_SUPERPRIV to be set even when no privilege was
    exercised, and is inefficient.
    
    Flip the order of the tests in both functions so that we only call
    capable() if the capability is truly required for the operation.
    
    Signed-off-by: Stephen Smalley <sds@tycho.nsa.gov>
    Cc: linux-security-module@vger.kernel.org
    Cc: selinux@tycho.nsa.gov
    Link: http://lkml.kernel.org/r/1487344439-22293-1-git-send-email-sds@tycho.nsa.gov
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit a35222e8ca8ee8603281008692a4cc2d6eab1624
Author: Anton Blanchard <anton@samba.org>
Date:   Sun Sep 25 17:16:53 2016 +1000

    powerpc/vdso64: Use double word compare on pointers
    
    commit 5045ea37377ce8cca6890d32b127ad6770e6dce5 upstream.
    
    __kernel_get_syscall_map() and __kernel_clock_getres() use cmpli to
    check if the passed in pointer is non zero. cmpli maps to a 32 bit
    compare on binutils, so we ignore the top 32 bits.
    
    A simple test case can be created by passing in a bogus pointer with
    the bottom 32 bits clear. Using a clk_id that is handled by the VDSO,
    then one that is handled by the kernel shows the problem:
    
      printf("%d\n", clock_getres(CLOCK_REALTIME, (void *)0x100000000));
      printf("%d\n", clock_getres(CLOCK_BOOTTIME, (void *)0x100000000));
    
    And we get:
    
      0
      -1
    
    The bigger issue is if we pass a valid pointer with the bottom 32 bits
    clear, in this case we will return success but won't write any data
    to the pointer.
    
    I stumbled across this issue because the LLVM integrated assembler
    doesn't accept cmpli with 3 arguments. Fix this by converting them to
    cmpldi.
    
    Fixes: a7f290dad32e ("[PATCH] powerpc: Merge vdso's and add vdso support to 32 bits kernel")
    Signed-off-by: Anton Blanchard <anton@samba.org>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit f8351abb34bd02ed1334aabbb026918677e6ba1c
Author: Anton Blanchard <anton@samba.org>
Date:   Sun Sep 25 17:16:53 2016 +1000

    powerpc/vdso64: Use double word compare on pointers
    
    commit 5045ea37377ce8cca6890d32b127ad6770e6dce5 upstream.
    
    __kernel_get_syscall_map() and __kernel_clock_getres() use cmpli to
    check if the passed in pointer is non zero. cmpli maps to a 32 bit
    compare on binutils, so we ignore the top 32 bits.
    
    A simple test case can be created by passing in a bogus pointer with
    the bottom 32 bits clear. Using a clk_id that is handled by the VDSO,
    then one that is handled by the kernel shows the problem:
    
      printf("%d\n", clock_getres(CLOCK_REALTIME, (void *)0x100000000));
      printf("%d\n", clock_getres(CLOCK_BOOTTIME, (void *)0x100000000));
    
    And we get:
    
      0
      -1
    
    The bigger issue is if we pass a valid pointer with the bottom 32 bits
    clear, in this case we will return success but won't write any data
    to the pointer.
    
    I stumbled across this issue because the LLVM integrated assembler
    doesn't accept cmpli with 3 arguments. Fix this by converting them to
    cmpldi.
    
    Fixes: a7f290dad32e ("[PATCH] powerpc: Merge vdso's and add vdso support to 32 bits kernel")
    Signed-off-by: Anton Blanchard <anton@samba.org>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit 546731aaea6c5882bcb1adf4c109233bfbb22ae4
Author: Anton Blanchard <anton@samba.org>
Date:   Sun Sep 25 17:16:53 2016 +1000

    powerpc/vdso64: Use double word compare on pointers
    
    commit 5045ea37377ce8cca6890d32b127ad6770e6dce5 upstream.
    
    __kernel_get_syscall_map() and __kernel_clock_getres() use cmpli to
    check if the passed in pointer is non zero. cmpli maps to a 32 bit
    compare on binutils, so we ignore the top 32 bits.
    
    A simple test case can be created by passing in a bogus pointer with
    the bottom 32 bits clear. Using a clk_id that is handled by the VDSO,
    then one that is handled by the kernel shows the problem:
    
      printf("%d\n", clock_getres(CLOCK_REALTIME, (void *)0x100000000));
      printf("%d\n", clock_getres(CLOCK_BOOTTIME, (void *)0x100000000));
    
    And we get:
    
      0
      -1
    
    The bigger issue is if we pass a valid pointer with the bottom 32 bits
    clear, in this case we will return success but won't write any data
    to the pointer.
    
    I stumbled across this issue because the LLVM integrated assembler
    doesn't accept cmpli with 3 arguments. Fix this by converting them to
    cmpldi.
    
    Fixes: a7f290dad32e ("[PATCH] powerpc: Merge vdso's and add vdso support to 32 bits kernel")
    Signed-off-by: Anton Blanchard <anton@samba.org>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Signed-off-by: Willy Tarreau <w@1wt.eu>

commit baa73d9e478ff32d62f3f9422822b59dd9a95a21
Author: Nicolas Pitre <nicolas.pitre@linaro.org>
Date:   Fri Nov 11 00:10:10 2016 -0500

    posix-timers: Make them configurable
    
    Some embedded systems have no use for them.  This removes about
    25KB from the kernel binary size when configured out.
    
    Corresponding syscalls are routed to a stub logging the attempt to
    use those syscalls which should be enough of a clue if they were
    disabled without proper consideration. They are: timer_create,
    timer_gettime: timer_getoverrun, timer_settime, timer_delete,
    clock_adjtime, setitimer, getitimer, alarm.
    
    The clock_settime, clock_gettime, clock_getres and clock_nanosleep
    syscalls are replaced by simple wrappers compatible with CLOCK_REALTIME,
    CLOCK_MONOTONIC and CLOCK_BOOTTIME only which should cover the vast
    majority of use cases with very little code.
    
    Signed-off-by: Nicolas Pitre <nico@linaro.org>
    Acked-by: Richard Cochran <richardcochran@gmail.com>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: John Stultz <john.stultz@linaro.org>
    Reviewed-by: Josh Triplett <josh@joshtriplett.org>
    Cc: Paul Bolle <pebolle@tiscali.nl>
    Cc: linux-kbuild@vger.kernel.org
    Cc: netdev@vger.kernel.org
    Cc: Michal Marek <mmarek@suse.com>
    Cc: Edward Cree <ecree@solarflare.com>
    Link: http://lkml.kernel.org/r/1478841010-28605-7-git-send-email-nicolas.pitre@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 62c65d8792347c7f347594d464a9e6fc79a0ab1b
Author: Anton Blanchard <anton@samba.org>
Date:   Sun Sep 25 17:16:53 2016 +1000

    powerpc/vdso64: Use double word compare on pointers
    
    commit 5045ea37377ce8cca6890d32b127ad6770e6dce5 upstream.
    
    __kernel_get_syscall_map() and __kernel_clock_getres() use cmpli to
    check if the passed in pointer is non zero. cmpli maps to a 32 bit
    compare on binutils, so we ignore the top 32 bits.
    
    A simple test case can be created by passing in a bogus pointer with
    the bottom 32 bits clear. Using a clk_id that is handled by the VDSO,
    then one that is handled by the kernel shows the problem:
    
      printf("%d\n", clock_getres(CLOCK_REALTIME, (void *)0x100000000));
      printf("%d\n", clock_getres(CLOCK_BOOTTIME, (void *)0x100000000));
    
    And we get:
    
      0
      -1
    
    The bigger issue is if we pass a valid pointer with the bottom 32 bits
    clear, in this case we will return success but won't write any data
    to the pointer.
    
    I stumbled across this issue because the LLVM integrated assembler
    doesn't accept cmpli with 3 arguments. Fix this by converting them to
    cmpldi.
    
    Fixes: a7f290dad32e ("[PATCH] powerpc: Merge vdso's and add vdso support to 32 bits kernel")
    Signed-off-by: Anton Blanchard <anton@samba.org>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>

commit 33b094fa2450e777bc49b466a8d258e06d7991eb
Author: Anton Blanchard <anton@samba.org>
Date:   Sun Sep 25 17:16:53 2016 +1000

    powerpc/vdso64: Use double word compare on pointers
    
    commit 5045ea37377ce8cca6890d32b127ad6770e6dce5 upstream.
    
    __kernel_get_syscall_map() and __kernel_clock_getres() use cmpli to
    check if the passed in pointer is non zero. cmpli maps to a 32 bit
    compare on binutils, so we ignore the top 32 bits.
    
    A simple test case can be created by passing in a bogus pointer with
    the bottom 32 bits clear. Using a clk_id that is handled by the VDSO,
    then one that is handled by the kernel shows the problem:
    
      printf("%d\n", clock_getres(CLOCK_REALTIME, (void *)0x100000000));
      printf("%d\n", clock_getres(CLOCK_BOOTTIME, (void *)0x100000000));
    
    And we get:
    
      0
      -1
    
    The bigger issue is if we pass a valid pointer with the bottom 32 bits
    clear, in this case we will return success but won't write any data
    to the pointer.
    
    I stumbled across this issue because the LLVM integrated assembler
    doesn't accept cmpli with 3 arguments. Fix this by converting them to
    cmpldi.
    
    Fixes: a7f290dad32e ("[PATCH] powerpc: Merge vdso's and add vdso support to 32 bits kernel")
    Signed-off-by: Anton Blanchard <anton@samba.org>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 74c77018155818fbffd2120a4a8785da2688d09f
Author: Anton Blanchard <anton@samba.org>
Date:   Sun Sep 25 17:16:53 2016 +1000

    powerpc/vdso64: Use double word compare on pointers
    
    commit 5045ea37377ce8cca6890d32b127ad6770e6dce5 upstream.
    
    __kernel_get_syscall_map() and __kernel_clock_getres() use cmpli to
    check if the passed in pointer is non zero. cmpli maps to a 32 bit
    compare on binutils, so we ignore the top 32 bits.
    
    A simple test case can be created by passing in a bogus pointer with
    the bottom 32 bits clear. Using a clk_id that is handled by the VDSO,
    then one that is handled by the kernel shows the problem:
    
      printf("%d\n", clock_getres(CLOCK_REALTIME, (void *)0x100000000));
      printf("%d\n", clock_getres(CLOCK_BOOTTIME, (void *)0x100000000));
    
    And we get:
    
      0
      -1
    
    The bigger issue is if we pass a valid pointer with the bottom 32 bits
    clear, in this case we will return success but won't write any data
    to the pointer.
    
    I stumbled across this issue because the LLVM integrated assembler
    doesn't accept cmpli with 3 arguments. Fix this by converting them to
    cmpldi.
    
    Fixes: a7f290dad32e ("[PATCH] powerpc: Merge vdso's and add vdso support to 32 bits kernel")
    Signed-off-by: Anton Blanchard <anton@samba.org>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 8c095d35c42284d6d8cd792c01afd7cdeba475db
Author: John Stultz <john.stultz@linaro.org>
Date:   Thu Jun 11 15:54:55 2015 -0700

    time: Prevent early expiry of hrtimers[CLOCK_REALTIME] at the leap second edge
    
    commit 833f32d763028c1bb371c64f457788b933773b3e upstream.
    
    Currently, leapsecond adjustments are done at tick time. As a result,
    the leapsecond was applied at the first timer tick *after* the
    leapsecond (~1-10ms late depending on HZ), rather then exactly on the
    second edge.
    
    This was in part historical from back when we were always tick based,
    but correcting this since has been avoided since it adds extra
    conditional checks in the gettime fastpath, which has performance
    overhead.
    
    However, it was recently pointed out that ABS_TIME CLOCK_REALTIME
    timers set for right after the leapsecond could fire a second early,
    since some timers may be expired before we trigger the timekeeping
    timer, which then applies the leapsecond.
    
    This isn't quite as bad as it sounds, since behaviorally it is similar
    to what is possible w/ ntpd made leapsecond adjustments done w/o using
    the kernel discipline. Where due to latencies, timers may fire just
    prior to the settimeofday call. (Also, one should note that all
    applications using CLOCK_REALTIME timers should always be careful,
    since they are prone to quirks from settimeofday() disturbances.)
    
    However, the purpose of having the kernel do the leap adjustment is to
    avoid such latencies, so I think this is worth fixing.
    
    So in order to properly keep those timers from firing a second early,
    this patch modifies the ntp and timekeeping logic so that we keep
    enough state so that the update_base_offsets_now accessor, which
    provides the hrtimer core the current time, can check and apply the
    leapsecond adjustment on the second edge. This prevents the hrtimer
    core from expiring timers too early.
    
    This patch does not modify any other time read path, so no additional
    overhead is incurred. However, this also means that the leap-second
    continues to be applied at tick time for all other read-paths.
    
    Apologies to Richard Cochran, who pushed for similar changes years
    ago, which I resisted due to the concerns about the performance
    overhead.
    
    While I suspect this isn't extremely critical, folks who care about
    strict leap-second correctness will likely want to watch
    this. Potentially a -stable candidate eventually.
    
    Originally-suggested-by: Richard Cochran <richardcochran@gmail.com>
    Reported-by: Daniel Bristot de Oliveira <bristot@redhat.com>
    Reported-by: Prarit Bhargava <prarit@redhat.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Jan Kara <jack@suse.cz>
    Cc: Jiri Bohac <jbohac@suse.cz>
    Cc: Shuah Khan <shuahkh@osg.samsung.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Link: http://lkml.kernel.org/r/1434063297-28657-4-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    [Yadi: Move do_adjtimex to timekeeping.c and solve context issues]
    Signed-off-by: Hu <yadi.hu@windriver.com>
    Signed-off-by: Zefan Li <lizefan@huawei.com>

commit 5045ea37377ce8cca6890d32b127ad6770e6dce5
Author: Anton Blanchard <anton@samba.org>
Date:   Sun Sep 25 17:16:53 2016 +1000

    powerpc/vdso64: Use double word compare on pointers
    
    __kernel_get_syscall_map() and __kernel_clock_getres() use cmpli to
    check if the passed in pointer is non zero. cmpli maps to a 32 bit
    compare on binutils, so we ignore the top 32 bits.
    
    A simple test case can be created by passing in a bogus pointer with
    the bottom 32 bits clear. Using a clk_id that is handled by the VDSO,
    then one that is handled by the kernel shows the problem:
    
      printf("%d\n", clock_getres(CLOCK_REALTIME, (void *)0x100000000));
      printf("%d\n", clock_getres(CLOCK_BOOTTIME, (void *)0x100000000));
    
    And we get:
    
      0
      -1
    
    The bigger issue is if we pass a valid pointer with the bottom 32 bits
    clear, in this case we will return success but won't write any data
    to the pointer.
    
    I stumbled across this issue because the LLVM integrated assembler
    doesn't accept cmpli with 3 arguments. Fix this by converting them to
    cmpldi.
    
    Fixes: a7f290dad32e ("[PATCH] powerpc: Merge vdso's and add vdso support to 32 bits kernel")
    Cc: stable@vger.kernel.org # v2.6.15+
    Signed-off-by: Anton Blanchard <anton@samba.org>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

commit 49eea433b326a0ac5c7c941a011b2c65990bd19b
Author: Kevin Brodsky <kevin.brodsky@arm.com>
Date:   Tue Jul 12 11:24:00 2016 +0100

    arm64: Add support for CLOCK_MONOTONIC_RAW in clock_gettime() vDSO
    
    So far the arm64 clock_gettime() vDSO implementation only supported
    the following clocks, falling back to the syscall for the others:
    - CLOCK_REALTIME{,_COARSE}
    - CLOCK_MONOTONIC{,_COARSE}
    
    This patch adds support for the CLOCK_MONOTONIC_RAW clock, taking
    advantage of the recent refactoring of the vDSO time functions. Like
    the non-_COARSE clocks, this only works when the "arch_sys_counter"
    clocksource is in use (allowing us to read the current time from the
    virtual counter register), otherwise we also have to fall back to the
    syscall.
    
    Most of the data is shared with CLOCK_MONOTONIC, and the algorithm is
    similar. The reference implementation in kernel/time/timekeeping.c
    shows that:
    - CLOCK_MONOTONIC = tk->wall_to_monotonic + tk->xtime_sec +
      timekeeping_get_ns(&tk->tkr_mono)
    - CLOCK_MONOTONIC_RAW = tk->raw_time + timekeeping_get_ns(&tk->tkr_raw)
    - tkr_mono and tkr_raw are identical (in particular, same
      clocksource), except these members:
      * mult (only mono's multiplier is NTP-adjusted)
      * xtime_nsec (always 0 for raw)
    
    Therefore, tk->raw_time and tkr_raw->mult are now also stored in the
    vDSO data page.
    
    Cc: Ali Saidi <ali.saidi@arm.com>
    Signed-off-by: Kevin Brodsky <kevin.brodsky@arm.com>
    Reviewed-by: Dave Martin <dave.martin@arm.com>
    Acked-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>

commit b33f491f5a9aaf171b7de0f905362eb0314af478
Author: Kevin Brodsky <kevin.brodsky@arm.com>
Date:   Tue Jul 12 11:23:59 2016 +0100

    arm64: Refactor vDSO time functions
    
    Time functions are directly implemented in assembly in arm64, and it
    is desirable to keep it this way for performance reasons (everything
    fits in registers, so that the stack is not used at all). However, the
    current implementation is quite difficult to read and understand (even
    considering it's assembly).  Additionally, due to the structure of
    __kernel_clock_gettime, which heavily uses conditional branches to
    share code between the different clocks, it is difficult to support a
    new clock without making the branches even harder to follow.
    
    This commit completely refactors the structure of clock_gettime (and
    gettimeofday along the way) while keeping exactly the same algorithms.
    We no longer try to share code; instead, macros provide common
    operations. This new approach comes with a number of advantages:
    - In clock_gettime, clock implementations are no longer interspersed,
      making them much more readable. Additionally, macros only use
      registers passed as arguments or reserved with .req, this way it is
      easy to make sure that registers are properly allocated. To avoid a
      large number of branches in a given execution path, a jump table is
      used; a normal execution uses 3 unconditional branches.
    - __do_get_tspec has been replaced with 2 macros (get_ts_clock_mono,
      get_clock_shifted_nsec) and explicit loading of data from the vDSO
      page. Consequently, clock_gettime and gettimeofday are now leaf
      functions, and saving x30 (lr) is no longer necessary.
    - Variables protected by tb_seq_count are now loaded all at once,
      allowing to merge the seqcnt_read macro into seqcnt_check.
    - For CLOCK_REALTIME_COARSE, removed an unused load of the wall to
      monotonic timespec.
    - For CLOCK_MONOTONIC_COARSE, removed a few shift instructions.
    
    Obviously, the downside of sharing less code is an increase in code
    size. However since the vDSO has its own code page, this does not
    really matter, as long as the size of the DSO remains below 4 kB. For
    now this should be all right:
                        Before  After
      vdso.so size (B)  2776    3000
    
    Signed-off-by: Kevin Brodsky <kevin.brodsky@arm.com>
    Reviewed-by: Dave Martin <dave.martin@arm.com>
    Acked-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>

commit bc2b7dab629a51e8beb5fda4222c62a23b729f26
Author: Gregor Boirie <gregor.boirie@parrot.com>
Date:   Wed Mar 9 19:05:49 2016 +0100

    iio:core: timestamping clock selection support
    
    Adds a new per-device sysfs attribute "current_timestamp_clock" to allow
    userspace to select a particular POSIX clock for buffered samples and
    events timestamping.
    
    Following clocks, as listed in clock_gettime(2), are supported:
    CLOCK_REALTIME, CLOCK_MONOTONIC, CLOCK_MONOTONIC_RAW,
    CLOCK_REALTIME_COARSE, CLOCK_MONOTONIC_COARSE, CLOCK_BOOTTIME and
    CLOCK_TAI.
    
    Signed-off-by: Gregor Boirie <gregor.boirie@parrot.com>
    Acked-by: Sanchayan Maity <maitysanchayan@gmail.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

commit 0209b937569a133dedfe930cdfff3a0d1d68c9e9
Author: Thomas Graziadei <thomas.graziadei@omicronenergy.com>
Date:   Tue May 31 15:06:06 2016 +0200

    timekeeping: Fix 1ns/tick drift with GENERIC_TIME_VSYSCALL_OLD
    
    The user notices the problem in a raw and real time drift, calling
    clock_gettime with CLOCK_REALTIME / CLOCK_MONOTONIC_RAW on a system
    with no ntp correction taking place (no ntpd or ptp stuff running).
    
    The problem is, that old_vsyscall_fixup adds an extra 1ns even though
    xtime_nsec is already held in full nsecs and the remainder in this
    case is 0. Do the rounding up buisness only if needed.
    
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Thomas Graziadei <thomas.graziadei@omicronenergy.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 24af98c4cf5f5e69266e270c7f3fb34b82ff6656
Merge: 9061cbe62ade 337f13046ff0
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jan 11 14:18:38 2016 -0800

    Merge branch 'locking-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull locking updates from Ingo Molnar:
     "So we have a laundry list of locking subsystem changes:
    
       - continuing barrier API and code improvements
    
       - futex enhancements
    
       - atomics API improvements
    
       - pvqspinlock enhancements: in particular lock stealing and adaptive
         spinning
    
       - qspinlock micro-enhancements"
    
    * 'locking-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      futex: Allow FUTEX_CLOCK_REALTIME with FUTEX_WAIT op
      futex: Cleanup the goto confusion in requeue_pi()
      futex: Remove pointless put_pi_state calls in requeue()
      futex: Document pi_state refcounting in requeue code
      futex: Rename free_pi_state() to put_pi_state()
      futex: Drop refcount if requeue_pi() acquired the rtmutex
      locking/barriers, arch: Remove ambiguous statement in the smp_store_mb() documentation
      lcoking/barriers, arch: Use smp barriers in smp_store_release()
      locking/cmpxchg, arch: Remove tas() definitions
      locking/pvqspinlock: Queue node adaptive spinning
      locking/pvqspinlock: Allow limited lock stealing
      locking/pvqspinlock: Collect slowpath lock statistics
      sched/core, locking: Document Program-Order guarantees
      locking, sched: Introduce smp_cond_acquire() and use it
      locking/pvqspinlock, x86: Optimize the PV unlock code path
      locking/qspinlock: Avoid redundant read of next pointer
      locking/qspinlock: Prefetch the next node cacheline
      locking/qspinlock: Use _acquire/_release() versions of cmpxchg() & xchg()
      atomics: Add test for atomic operations with _relaxed variants

commit 337f13046ff03717a9e99675284a817527440a49
Author: Darren Hart <dvhart@linux.intel.com>
Date:   Fri Dec 18 13:36:37 2015 -0800

    futex: Allow FUTEX_CLOCK_REALTIME with FUTEX_WAIT op
    
    While reviewing Michael Kerrisk's recent futex manpage update, I noticed
    that we allow the FUTEX_CLOCK_REALTIME flag for FUTEX_WAIT_BITSET but
    not for FUTEX_WAIT.
    
    FUTEX_WAIT is treated as a simple version for FUTEX_WAIT_BITSET
    internally (with a bitmask of FUTEX_BITSET_MATCH_ANY). As such, I cannot
    come up with a reason for this exclusion for FUTEX_WAIT.
    
    This change does modify the behavior of the futex syscall, changing a
    call with FUTEX_WAIT | FUTEX_CLOCK_REALTIME from returning -ENOSYS, to be
    equivalent to FUTEX_WAIT_BITSET | FUTEX_CLOCK_REALTIME with a bitset of
    FUTEX_BITSET_MATCH_ANY.
    
    Reported-by: Michael Kerrisk <mtk.manpages@gmail.com>
    Signed-off-by: Darren Hart <dvhart@linux.intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Davidlohr Bueso <dave@stgolabs.net>
    Link: http://lkml.kernel.org/r/9f3bdc116d79d23f5ee72ceb9a2a857f5ff8fa29.1450474525.git.dvhart@linux.intel.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit a0e3213f836640065e2a23ad55fa6f72e812a4f1
Author: zhuo-hao <zhuo-hao.lee@intel.com>
Date:   Tue Nov 17 20:08:07 2015 +0800

    alarmtimer: Avoid unexpected rtc interrupt when system resume from S3
    
    Before the system go to suspend (S3), if user create a timer
    with clockid CLOCK_REALTIME_ALARM/CLOCK_BOOTTIME_ALARM and set a
    "large" timeout value to this timer. The function
    alarmtimer_suspend will be called to setup a timeout value to
    RTC timer to avoid the system sleep over time. However, if the
    system wakeup early than RTC timeout, the RTC timer will not be
    cleared. And this will cause the hpet_rtc_interrupt come
    unexpectedly until the RTC timeout. To fix this problem, just
    adding alarmtimer_resume to cancel the RTC timer.
    
    This was noticed because the HPET RTC emulation fires an
    interrupt every 16ms(=1/2^DEFAULT_RTC_SHIFT) up to the point
    where the alarm time is reached.
    
    This program always hits this situation
    (https://lkml.org/lkml/2015/11/8/326), if system wake up earlier
    than alarm time.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Zhuo-hao Lee <zhuo-hao.lee@intel.com>
    [jstultz: Tweak commit subject & formatting slightly]
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit e1d7ba8735551ed79c7a0463a042353574b96da3
Author: Wang YanQing <udknight@gmail.com>
Date:   Tue Jun 23 18:38:54 2015 +0800

    time: Always make sure wall_to_monotonic isn't positive
    
    Two issues were found on an IMX6 development board without an
    enabled RTC device(resulting in the boot time and monotonic
    time being initialized to 0).
    
    Issue 1:exportfs -a generate:
           "exportfs: /opt/nfs/arm does not support NFS export"
    Issue 2:cat /proc/stat:
           "btime 4294967236"
    
    The same issues can be reproduced on x86 after running the
    following code:
            int main(void)
            {
                struct timeval val;
                int ret;
    
                val.tv_sec = 0;
                val.tv_usec = 0;
                ret = settimeofday(&val, NULL);
                return 0;
            }
    
    Two issues are different symptoms of same problem:
    The reason is a positive wall_to_monotonic pushes boot time back
    to the time before Epoch, and getboottime will return negative
    value.
    
    In symptom 1:
              negative boot time cause get_expiry() to overflow time_t
              when input expire time is 2147483647, then cache_flush()
              always clears entries just added in ip_map_parse.
    In symptom 2:
              show_stat() uses "unsigned long" to print negative btime
              value returned by getboottime.
    
    This patch fix the problem by prohibiting time from being set to a value which
    would cause a negative boot time. As a result one can't set the CLOCK_REALTIME
    time prior to (1970 + system uptime).
    
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Wang YanQing <udknight@gmail.com>
    [jstultz: reworded commit message]
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 38bf985b05625df3fbbc1dbf543bdd2da447c2af
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed May 27 16:44:48 2015 -0700

    timer_list: Add the base offset so remaining nsecs are accurate for non monotonic timers
    
    I noticed for non-monotonic timers in timer_list, some of the
    output looked a little confusing.
    
    For example:
     #1: <0000000000000000>, posix_timer_fn, S:01, hrtimer_start_range_ns, leap-a-day/2360
     # expires at 1434412800000000000-1434412800000000000 nsecs [in 1434410725062375469 to 1434410725062375469 nsecs]
    
    You'll note the relative time till the expiration "[in xxx to
    yyy nsecs]" is incorrect. This is because its printing the delta
    between CLOCK_MONOTONIC time to the CLOCK_REALTIME expiration.
    
    This patch fixes this issue by adding the clock offset to the
    "now" time which we use to calculate the delta.
    
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Daniel Bristot de Oliveira <bristot@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Jan Kara <jack@suse.cz>
    Cc: Jiri Bohac <jbohac@suse.cz>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Shuah Khan <shuahkh@osg.samsung.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 28ebb87c73f9c17266d4f7570d65a1e695df7d9d
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Tue Aug 11 10:38:38 2015 -0300

    perf trace: Add missing clockid entries
    
    We were missing:
    
      CLOCK_BOOTTIME, CLOCK_REALTIME_ALARM, CLOCK_BOOTTIME_ALARM,
      CLOCK_SGI_CYCLE and CLOCK_TAI.
    
    Add them.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Borislav Petkov <bp@suse.de>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Milian Wolff <milian.wolff@kdab.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Stephane Eranian <eranian@google.com>
    Link: http://lkml.kernel.org/n/tip-d67rwqtwm9jyenwes98kr0cr@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

commit 09edea4f8fdeb4e292b80d493296070f5ec64e6e
Author: Nathan Lynch <nathan_lynch@mentor.com>
Date:   Mon Aug 10 17:36:06 2015 +0100

    ARM: 8410/1: VDSO: fix coarse clock monotonicity regression
    
    Since 906c55579a63 ("timekeeping: Copy the shadow-timekeeper over the
    real timekeeper last") it has become possible on ARM to:
    
    - Obtain a CLOCK_MONOTONIC_COARSE or CLOCK_REALTIME_COARSE timestamp
      via syscall.
    - Subsequently obtain a timestamp for the same clock ID via VDSO which
      predates the first timestamp (by one jiffy).
    
    This is because ARM's update_vsyscall is deriving the coarse time
    using the __current_kernel_time interface, when it should really be
    using the timekeeper object provided to it by the timekeeping core.
    It happened to work before only because __current_kernel_time would
    access the same timekeeper object which had been passed to
    update_vsyscall.  This is no longer the case.
    
    Cc: stable@vger.kernel.org
    Fixes: 906c55579a63 ("timekeeping: Copy the shadow-timekeeper over the real timekeeper last")
    Signed-off-by: Nathan Lynch <nathan_lynch@mentor.com>
    Acked-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

commit 878854a374620a3f5e8c0a3c418e82a429bc2cff
Author: Nathan Lynch <nathan_lynch@mentor.com>
Date:   Fri Aug 7 21:03:23 2015 -0500

    arm64: VDSO: fix coarse clock monotonicity regression
    
    Since 906c55579a63 ("timekeeping: Copy the shadow-timekeeper over the
    real timekeeper last") it has become possible on arm64 to:
    
    - Obtain a CLOCK_MONOTONIC_COARSE or CLOCK_REALTIME_COARSE timestamp
      via syscall.
    - Subsequently obtain a timestamp for the same clock ID via VDSO which
      predates the first timestamp (by one jiffy).
    
    This is because arm64's update_vsyscall is deriving the coarse time
    using the __current_kernel_time interface, when it should really be
    using the timekeeper object provided to it by the timekeeping core.
    It happened to work before only because __current_kernel_time would
    access the same timekeeper object which had been passed to
    update_vsyscall.  This is no longer the case.
    
    Signed-off-by: Nathan Lynch <nathan_lynch@mentor.com>
    Acked-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>

commit 43224b96af3154cedd7220f7b90094905f07ac78
Merge: d70b3ef54cea 1cb6c2151850
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jun 22 18:57:44 2015 -0700

    Merge branch 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer updates from Thomas Gleixner:
     "A rather largish update for everything time and timer related:
    
       - Cache footprint optimizations for both hrtimers and timer wheel
    
       - Lower the NOHZ impact on systems which have NOHZ or timer migration
         disabled at runtime.
    
       - Optimize run time overhead of hrtimer interrupt by making the clock
         offset updates smarter
    
       - hrtimer cleanups and removal of restrictions to tackle some
         problems in sched/perf
    
       - Some more leap second tweaks
    
       - Another round of changes addressing the 2038 problem
    
       - First step to change the internals of clock event devices by
         introducing the necessary infrastructure
    
       - Allow constant folding for usecs/msecs_to_jiffies()
    
       - The usual pile of clockevent/clocksource driver updates
    
      The hrtimer changes contain updates to sched, perf and x86 as they
      depend on them plus changes all over the tree to cleanup API changes
      and redundant code, which got copied all over the place.  The y2038
      changes touch s390 to remove the last non 2038 safe code related to
      boot/persistant clock"
    
    * 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (114 commits)
      clocksource: Increase dependencies of timer-stm32 to limit build wreckage
      timer: Minimize nohz off overhead
      timer: Reduce timer migration overhead if disabled
      timer: Stats: Simplify the flags handling
      timer: Replace timer base by a cpu index
      timer: Use hlist for the timer wheel hash buckets
      timer: Remove FIFO "guarantee"
      timers: Sanitize catchup_timer_jiffies() usage
      hrtimer: Allow hrtimer::function() to free the timer
      seqcount: Introduce raw_write_seqcount_barrier()
      seqcount: Rename write_seqcount_barrier()
      hrtimer: Fix hrtimer_is_queued() hole
      hrtimer: Remove HRTIMER_STATE_MIGRATE
      selftest: Timers: Avoid signal deadlock in leap-a-day
      timekeeping: Copy the shadow-timekeeper over the real timekeeper last
      clockevents: Check state instead of mode in suspend/resume path
      selftests: timers: Add leap-second timer edge testing to leap-a-day.c
      ntp: Do leapsecond adjustment in adjtimex read path
      time: Prevent early expiry of hrtimers[CLOCK_REALTIME] at the leap second edge
      ntp: Introduce and use SECS_PER_DAY macro instead of 86400
      ...

commit 96efdcf2d080687e041b0353c604b708546689fd
Author: John Stultz <john.stultz@linaro.org>
Date:   Thu Jun 11 15:54:56 2015 -0700

    ntp: Do leapsecond adjustment in adjtimex read path
    
    Since the leapsecond is applied at tick-time, this means there is a
    small window of time at the start of a leap-second where we cross into
    the next second before applying the leap.
    
    This patch modified adjtimex so that the leap-second is applied on the
    second edge. Providing more correct leapsecond behavior.
    
    This does make it so that adjtimex()'s returned time values can be
    inconsistent with time values read from gettimeofday() or
    clock_gettime(CLOCK_REALTIME,...)  for a brief period of one tick at
    the leapsecond.  However, those other interfaces do not provide the
    TIME_OOP time_state return that adjtimex() provides, which allows the
    leapsecond to be properly represented. They instead only see a time
    discontinuity, and cannot tell the first 23:59:59 from the repeated
    23:59:59 leap second.
    
    This seems like a reasonable tradeoff given clock_gettime() /
    gettimeofday() cannot properly represent a leapsecond, and users
    likely care more about performance, while folks who are using
    adjtimex() more likely care about leap-second correctness.
    
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Daniel Bristot de Oliveira <bristot@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Jan Kara <jack@suse.cz>
    Cc: Jiri Bohac <jbohac@suse.cz>
    Cc: Ingo Molnar <mingo@kernel.org>
    Link: http://lkml.kernel.org/r/1434063297-28657-5-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 833f32d763028c1bb371c64f457788b933773b3e
Author: John Stultz <john.stultz@linaro.org>
Date:   Thu Jun 11 15:54:55 2015 -0700

    time: Prevent early expiry of hrtimers[CLOCK_REALTIME] at the leap second edge
    
    Currently, leapsecond adjustments are done at tick time. As a result,
    the leapsecond was applied at the first timer tick *after* the
    leapsecond (~1-10ms late depending on HZ), rather then exactly on the
    second edge.
    
    This was in part historical from back when we were always tick based,
    but correcting this since has been avoided since it adds extra
    conditional checks in the gettime fastpath, which has performance
    overhead.
    
    However, it was recently pointed out that ABS_TIME CLOCK_REALTIME
    timers set for right after the leapsecond could fire a second early,
    since some timers may be expired before we trigger the timekeeping
    timer, which then applies the leapsecond.
    
    This isn't quite as bad as it sounds, since behaviorally it is similar
    to what is possible w/ ntpd made leapsecond adjustments done w/o using
    the kernel discipline. Where due to latencies, timers may fire just
    prior to the settimeofday call. (Also, one should note that all
    applications using CLOCK_REALTIME timers should always be careful,
    since they are prone to quirks from settimeofday() disturbances.)
    
    However, the purpose of having the kernel do the leap adjustment is to
    avoid such latencies, so I think this is worth fixing.
    
    So in order to properly keep those timers from firing a second early,
    this patch modifies the ntp and timekeeping logic so that we keep
    enough state so that the update_base_offsets_now accessor, which
    provides the hrtimer core the current time, can check and apply the
    leapsecond adjustment on the second edge. This prevents the hrtimer
    core from expiring timers too early.
    
    This patch does not modify any other time read path, so no additional
    overhead is incurred. However, this also means that the leap-second
    continues to be applied at tick time for all other read-paths.
    
    Apologies to Richard Cochran, who pushed for similar changes years
    ago, which I resisted due to the concerns about the performance
    overhead.
    
    While I suspect this isn't extremely critical, folks who care about
    strict leap-second correctness will likely want to watch
    this. Potentially a -stable candidate eventually.
    
    Originally-suggested-by: Richard Cochran <richardcochran@gmail.com>
    Reported-by: Daniel Bristot de Oliveira <bristot@redhat.com>
    Reported-by: Prarit Bhargava <prarit@redhat.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Jan Kara <jack@suse.cz>
    Cc: Jiri Bohac <jbohac@suse.cz>
    Cc: Shuah Khan <shuahkh@osg.samsung.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Link: http://lkml.kernel.org/r/1434063297-28657-4-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 48fd77d1444a387435c3bbc773fa4e7ab6b6aca3
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Apr 1 20:43:39 2015 -0700

    kselftests: timers: Make set-timer-lat fail more gracefully for !CAP_WAKE_ALARM
    
    The set-timer-lat test fails when testing CLOCK_BOOTTIME_ALARM
    or CLOCK_REALTIME_ALARM when the user isn't running as root or
    with CAP_WAKE_ALARM.
    
    So this patch improves the error checking so we report the
    issue more clearly and continue rather then reporting a failure.
    
    Cc: Shuah Khan <shuahkh@osg.samsung.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Shuah Khan <shuahkh@osg.samsung.com>

commit fef76eabdf6f5bd033de2353f27dccbeea60c066
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Feb 4 16:45:26 2015 -0800

    hrtimer: Fix incorrect tai offset calculation for non high-res timer systems
    
    commit 2d926c15d629a13914ce3e5f26354f6a0ac99e70 upstream.
    
    I noticed some CLOCK_TAI timer test failures on one of my
    less-frequently used configurations. And after digging in I
    found in 76f4108892d9 (Cleanup hrtimer accessors to the
    timekepeing state), the hrtimer_get_softirq_time tai offset
    calucation was incorrectly rewritten, as the tai offset we
    return shold be from CLOCK_MONOTONIC, and not CLOCK_REALTIME.
    
    This results in CLOCK_TAI timers expiring early on non-highres
    capable machines.
    
    This patch fixes the issue, calculating the tai time properly
    from the monotonic base.
    
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/1423097126-10236-1-git-send-email-john.stultz@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 2d926c15d629a13914ce3e5f26354f6a0ac99e70
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Feb 4 16:45:26 2015 -0800

    hrtimer: Fix incorrect tai offset calculation for non high-res timer systems
    
    I noticed some CLOCK_TAI timer test failures on one of my
    less-frequently used configurations. And after digging in I
    found in 76f4108892d9 (Cleanup hrtimer accessors to the
    timekepeing state), the hrtimer_get_softirq_time tai offset
    calucation was incorrectly rewritten, as the tai offset we
    return shold be from CLOCK_MONOTONIC, and not CLOCK_REALTIME.
    
    This results in CLOCK_TAI timers expiring early on non-highres
    capable machines.
    
    This patch fixes the issue, calculating the tai time properly
    from the monotonic base.
    
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable <stable@vger.kernel.org> # 3.17+
    Link: http://lkml.kernel.org/r/1423097126-10236-1-git-send-email-john.stultz@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 9bc7491906b4113b4c5ae442157c7dfc4e10cd14
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jan 20 21:24:10 2015 +0100

    hrtimer: Prevent stale expiry time in hrtimer_interrupt()
    
    hrtimer_interrupt() has the following subtle issue:
    
    hrtimer_interrupt()
      lock(cpu_base);
      expires_next = KTIME_MAX;
    
      expire_timers(CLOCK_MONOTONIC);
      expires = get_next_timer(CLOCK_MONOTONIC);
      if (expires < expires_next)
        expires_next = expires;
    
      expire_timers(CLOCK_REALTIME);
        unlock(cpu_base);
        wakeup()
        hrtimer_start(CLOCK_MONOTONIC, newtimer);
        lock(cpu_base();
      expires = get_next_timer(CLOCK_REALTIME);
      if (expires < expires_next)
        expires_next = expires;
    
    So because we already evaluated the next expiring timer of
    CLOCK_MONOTONIC we ignore that the expiry time of newtimer might be
    earlier than the overall next expiry time in hrtimer_interrupt().
    
    To solve this, remove the caching of the next expiry value from
    hrtimer_interrupt() and reevaluate all active clock bases for the next
    expiry value. To avoid another code duplication, create a shared
    evaluation function and use it for hrtimer_get_next_event(),
    hrtimer_force_reprogram() and hrtimer_interrupt().
    
    There is another subtlety in this mechanism:
    
    While hrtimer_interrupt() is running, we want to avoid to touch the
    hardware device because we will reprogram it anyway at the end of
    hrtimer_interrupt(). This works nicely for hrtimers which get rearmed
    via the HRTIMER_RESTART mechanism, because we drop out when the
    callback on that CPU is running. But that fails, if a new timer gets
    enqueued like in the example above.
    
    This has another implication: While hrtimer_interrupt() is running we
    refuse remote enqueueing of timers - see hrtimer_interrupt() and
    hrtimer_check_target().
    
    hrtimer_interrupt() tries to prevent this by setting cpu_base->expires
    to KTIME_MAX, but that fails if a new timer gets queued.
    
    Prevent both the hardware access and the remote enqueue
    explicitely. We can loosen the restriction on the remote enqueue now
    due to reevaluation of the next expiry value, but that needs a
    seperate patch.
    
    Folded in a fix from Vignesh Radhakrishnan.
    
    Reported-and-tested-by: Stanislav Fomichev <stfomichev@yandex-team.ru>
    Based-on-patch-by: Stanislav Fomichev <stfomichev@yandex-team.ru>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: vigneshr@codeaurora.org
    Cc: john.stultz@linaro.org
    Cc: viresh.kumar@linaro.org
    Cc: fweisbec@gmail.com
    Cc: cl@linux.com
    Cc: stuart.w.hayes@gmail.com
    Link: http://lkml.kernel.org/r/alpine.DEB.2.11.1501202049190.5526@nanos
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit d82012695ef29e4e1c8153ccf43098ec8e50369e
Merge: 3eb5b893ebec dbe7aa622db9
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Dec 10 10:13:28 2014 -0800

    Merge branch 'timers-2038-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull more 2038 timer work from Thomas Gleixner:
     "Two more patches for the ongoing 2038 work:
    
       - New accessors to clock MONOTONIC and REALTIME seconds
    
      This is a seperate branch as Arnd has follow up work depending on
      this"
    
    * 'timers-2038-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      timekeeping: Provide y2038 safe accessor to the seconds portion of CLOCK_REALTIME
      timekeeping: Provide fast accessor to the seconds part of CLOCK_MONOTONIC

commit dbe7aa622db96b5cd601f59d09c4f00b98b76079
Author: Heena Sirwani <heenasirwani@gmail.com>
Date:   Wed Oct 29 16:01:50 2014 +0530

    timekeeping: Provide y2038 safe accessor to the seconds portion of CLOCK_REALTIME
    
    ktime_get_real_seconds() is the replacement function for get_seconds()
    returning the seconds portion of CLOCK_REALTIME in a time64_t. For
    64bit the function is equivivalent to get_seconds(), but for 32bit it
    protects the readout with the timekeeper sequence count. This is
    required because 32-bit machines cannot access 64-bit tk->xtime_sec
    variable atomically.
    
    [tglx: Massaged changelog and added docbook comment ]
    
    Signed-off-by: Heena Sirwani <heenasirwani@gmail.com>
    Reviewed-by: Arnd Bergman <arnd@arndb.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: opw-kernel@googlegroups.com
    Link: http://lkml.kernel.org/r/7adcfaa8962b8ad58785d9a2456c3f77d93c0ffb.1414578445.git.heenasirwani@gmail.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 9e3680b1750b9a62680b0262c9f438de98b77655
Author: Heena Sirwani <heenasirwani@gmail.com>
Date:   Wed Oct 29 16:01:16 2014 +0530

    timekeeping: Provide fast accessor to the seconds part of CLOCK_MONOTONIC
    
    This is the counterpart to get_seconds() based on CLOCK_MONOTONIC. The
    use case for this interface are kernel internal coarse grained
    timestamps which do neither require the nanoseconds fraction of
    current time nor the CLOCK_REALTIME properties. Such timestamps can
    currently only retrieved by calling ktime_get_ts64() and using the
    tv_sec field of the returned timespec64. That's inefficient as it
    involves the read of the clocksource, math operations and must be
    protected by the timekeeper sequence counter.
    
    To avoid the sequence counter protection we restrict the return value
    to unsigned 32bit on 32bit machines. This covers ~136 years of uptime
    and therefor an overflow is not expected to hit anytime soon.
    
    To avoid math in the function we calculate the current seconds portion
    of CLOCK_MONOTONIC when the timekeeper gets updated in
    tk_update_ktime_data() similar to the CLOCK_REALTIME counterpart
    xtime_sec.
    
    [ tglx: Massaged changelog, simplified and commented the update
            function, added docbook comment ]
    
    Signed-off-by: Heena Sirwani <heenasirwani@gmail.com>
    Reviewed-by: Arnd Bergman <arnd@arndb.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: opw-kernel@googlegroups.com
    Link: http://lkml.kernel.org/r/da0b63f4bdf3478909f92becb35861197da3a905.1414578445.git.heenasirwani@gmail.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 78410af51146796f783925009c8676a30d6c6d90
Author: Chris Metcalf <cmetcalf@tilera.com>
Date:   Thu Oct 2 10:32:15 2014 -0400

    tile: add clock_gettime support to vDSO
    
    This change adds support for clock_gettime with CLOCK_REALTIME
    and CLOCK_MONOTONIC using vDSO.  It also updates the vdso
    struct nomenclature used for the clocks to match the x86 code
    to keep it easier to update going forward.
    
    We also support the *_COARSE clockid_t, for apps that want speed
    but aren't concerned about fine-grained timestamps; this saves
    about 20 cycles per call (see http://lwn.net/Articles/342018/).
    
    Signed-off-by: Chris Metcalf <cmetcalf@tilera.com>
    Acked-by: John Stultz <john.stultz@linaro.org>

commit b7eacb59cd7fb5e98852186e485c0c865f862645
Author: Martin Schwidefsky <schwidefsky@de.ibm.com>
Date:   Fri Aug 29 12:31:45 2014 +0200

    s390/vdso: add vdso support for coarse clocks
    
    Add CLOCK_REALTIME_COARSE and CLOCK_MONOTONIC_COARSE optimization to
    the 64-bit and 31-bit vdso.
    
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

commit febee6d26e3a89a656a9afdc13228eef679899bf
Author: John Stultz <john.stultz@linaro.org>
Date:   Mon Jul 7 14:06:11 2014 -0700

    alarmtimer: Fix bug where relative alarm timers were treated as absolute
    
    commit 16927776ae757d0d132bdbfabbfe2c498342bd59 upstream.
    
    Sharvil noticed with the posix timer_settime interface, using the
    CLOCK_REALTIME_ALARM or CLOCK_BOOTTIME_ALARM clockid, if the users
    tried to specify a relative time timer, it would incorrectly be
    treated as absolute regardless of the state of the flags argument.
    
    This patch corrects this, properly checking the absolute/relative flag,
    as well as adds further error checking that no invalid flag bits are set.
    
    Reported-by: Sharvil Nanavati <sharvil@google.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Sharvil Nanavati <sharvil@google.com>
    Link: http://lkml.kernel.org/r/1404767171-6902-1-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit bde32a05cc099e4ba4a117afb678134dd7082e82
Author: John Stultz <john.stultz@linaro.org>
Date:   Mon Jul 7 14:06:11 2014 -0700

    alarmtimer: Fix bug where relative alarm timers were treated as absolute
    
    commit 16927776ae757d0d132bdbfabbfe2c498342bd59 upstream.
    
    Sharvil noticed with the posix timer_settime interface, using the
    CLOCK_REALTIME_ALARM or CLOCK_BOOTTIME_ALARM clockid, if the users
    tried to specify a relative time timer, it would incorrectly be
    treated as absolute regardless of the state of the flags argument.
    
    This patch corrects this, properly checking the absolute/relative flag,
    as well as adds further error checking that no invalid flag bits are set.
    
    Reported-by: Sharvil Nanavati <sharvil@google.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Sharvil Nanavati <sharvil@google.com>
    Link: http://lkml.kernel.org/r/1404767171-6902-1-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>

commit 6ffb863bbe53b5f0622b1a3f4797d4713721f9cb
Author: John Stultz <john.stultz@linaro.org>
Date:   Mon Jul 7 14:06:11 2014 -0700

    alarmtimer: Fix bug where relative alarm timers were treated as absolute
    
    commit 16927776ae757d0d132bdbfabbfe2c498342bd59 upstream.
    
    Sharvil noticed with the posix timer_settime interface, using the
    CLOCK_REALTIME_ALARM or CLOCK_BOOTTIME_ALARM clockid, if the users
    tried to specify a relative time timer, it would incorrectly be
    treated as absolute regardless of the state of the flags argument.
    
    This patch corrects this, properly checking the absolute/relative flag,
    as well as adds further error checking that no invalid flag bits are set.
    
    Reported-by: Sharvil Nanavati <sharvil@google.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Sharvil Nanavati <sharvil@google.com>
    Link: http://lkml.kernel.org/r/1404767171-6902-1-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 025d494281c58dcee04fe3ee2b7fa300e150c95c
Author: John Stultz <john.stultz@linaro.org>
Date:   Mon Jul 7 14:06:11 2014 -0700

    alarmtimer: Fix bug where relative alarm timers were treated as absolute
    
    commit 16927776ae757d0d132bdbfabbfe2c498342bd59 upstream.
    
    Sharvil noticed with the posix timer_settime interface, using the
    CLOCK_REALTIME_ALARM or CLOCK_BOOTTIME_ALARM clockid, if the users
    tried to specify a relative time timer, it would incorrectly be
    treated as absolute regardless of the state of the flags argument.
    
    This patch corrects this, properly checking the absolute/relative flag,
    as well as adds further error checking that no invalid flag bits are set.
    
    Reported-by: Sharvil Nanavati <sharvil@google.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Sharvil Nanavati <sharvil@google.com>
    Link: http://lkml.kernel.org/r/1404767171-6902-1-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit c933192733ddf436c578183ca0687c7db5fff468
Author: John Stultz <john.stultz@linaro.org>
Date:   Mon Jul 7 14:06:11 2014 -0700

    alarmtimer: Fix bug where relative alarm timers were treated as absolute
    
    commit 16927776ae757d0d132bdbfabbfe2c498342bd59 upstream.
    
    Sharvil noticed with the posix timer_settime interface, using the
    CLOCK_REALTIME_ALARM or CLOCK_BOOTTIME_ALARM clockid, if the users
    tried to specify a relative time timer, it would incorrectly be
    treated as absolute regardless of the state of the flags argument.
    
    This patch corrects this, properly checking the absolute/relative flag,
    as well as adds further error checking that no invalid flag bits are set.
    
    Reported-by: Sharvil Nanavati <sharvil@google.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Sharvil Nanavati <sharvil@google.com>
    Link: http://lkml.kernel.org/r/1404767171-6902-1-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 299e667e26e9e3382fa471370121b117fa8ae987
Author: John Stultz <john.stultz@linaro.org>
Date:   Mon Jul 7 14:06:11 2014 -0700

    alarmtimer: Fix bug where relative alarm timers were treated as absolute
    
    commit 16927776ae757d0d132bdbfabbfe2c498342bd59 upstream.
    
    Sharvil noticed with the posix timer_settime interface, using the
    CLOCK_REALTIME_ALARM or CLOCK_BOOTTIME_ALARM clockid, if the users
    tried to specify a relative time timer, it would incorrectly be
    treated as absolute regardless of the state of the flags argument.
    
    This patch corrects this, properly checking the absolute/relative flag,
    as well as adds further error checking that no invalid flag bits are set.
    
    Reported-by: Sharvil Nanavati <sharvil@google.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Sharvil Nanavati <sharvil@google.com>
    Link: http://lkml.kernel.org/r/1404767171-6902-1-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit d2cb58c85ce4789caafa66fa8f1c641ab2504ead
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Jul 16 21:04:26 2014 +0000

    drm: Use ktime_mono_to_real()
    
    Convert the monotonic timestamp with ktime_mono_to_real() in
    drm_calc_vbltimestamp_from_scanoutpos().
    
    In get_drm_timestamp we can call either ktime_get() or
    ktime_get_real() depending on drm_timestamp_monotonic. No point in
    having two calls into the core for CLOCK_REALTIME.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 5cac2f4d1c5f3eb3d981fab85d926d19f7b6b889
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Jul 16 21:04:25 2014 +0000

    input: evdev: Use ktime_mono_to_real()
    
    Convert the monotonic timestamp with ktime_mono_to_real() in
    evdev_events().
    
    In evdev_queue_syn_dropped() we can call either ktime_get() or
    ktime_get_real() depending on the clkid. No point in having two calls
    for CLOCK_REALTIME.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 16927776ae757d0d132bdbfabbfe2c498342bd59
Author: John Stultz <john.stultz@linaro.org>
Date:   Mon Jul 7 14:06:11 2014 -0700

    alarmtimer: Fix bug where relative alarm timers were treated as absolute
    
    Sharvil noticed with the posix timer_settime interface, using the
    CLOCK_REALTIME_ALARM or CLOCK_BOOTTIME_ALARM clockid, if the users
    tried to specify a relative time timer, it would incorrectly be
    treated as absolute regardless of the state of the flags argument.
    
    This patch corrects this, properly checking the absolute/relative flag,
    as well as adds further error checking that no invalid flag bits are set.
    
    Reported-by: Sharvil Nanavati <sharvil@google.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Sharvil Nanavati <sharvil@google.com>
    Cc: stable <stable@vger.kernel.org> #3.0+
    Link: http://lkml.kernel.org/r/1404767171-6902-1-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit d8cec633b0488655ac324684d4cf53e312bcdf41
Author: Nathan Lynch <nathan_lynch@mentor.com>
Date:   Wed Feb 5 05:53:04 2014 +0000

    arm64: vdso: fix coarse clock handling
    
    commit 069b918623e1510e58dacf178905a72c3baa3ae4 upstream.
    
    When __kernel_clock_gettime is called with a CLOCK_MONOTONIC_COARSE or
    CLOCK_REALTIME_COARSE clock id, it returns incorrectly to whatever the
    caller has placed in x2 ("ret x2" to return from the fast path).  Fix
    this by saving x30/LR to x2 only in code that will call
    __do_get_tspec, restoring x30 afterward, and using a plain "ret" to
    return from the routine.
    
    Also: while the resulting tv_nsec value for CLOCK_REALTIME and
    CLOCK_MONOTONIC must be computed using intermediate values that are
    left-shifted by cs_shift (x12, set by __do_get_tspec), the results for
    coarse clocks should be calculated using unshifted values
    (xtime_coarse_nsec is in units of actual nanoseconds).  The current
    code shifts intermediate values by x12 unconditionally, but x12 is
    uninitialized when servicing a coarse clock.  Fix this by setting x12
    to 0 once we know we are dealing with a coarse clock id.
    
    Signed-off-by: Nathan Lynch <nathan_lynch@mentor.com>
    Acked-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 61cdf59100deb76fc299ee8ad1fb4c9cda4ce011
Author: Nathan Lynch <nathan_lynch@mentor.com>
Date:   Wed Feb 5 05:53:04 2014 +0000

    arm64: vdso: fix coarse clock handling
    
    commit 069b918623e1510e58dacf178905a72c3baa3ae4 upstream.
    
    When __kernel_clock_gettime is called with a CLOCK_MONOTONIC_COARSE or
    CLOCK_REALTIME_COARSE clock id, it returns incorrectly to whatever the
    caller has placed in x2 ("ret x2" to return from the fast path).  Fix
    this by saving x30/LR to x2 only in code that will call
    __do_get_tspec, restoring x30 afterward, and using a plain "ret" to
    return from the routine.
    
    Also: while the resulting tv_nsec value for CLOCK_REALTIME and
    CLOCK_MONOTONIC must be computed using intermediate values that are
    left-shifted by cs_shift (x12, set by __do_get_tspec), the results for
    coarse clocks should be calculated using unshifted values
    (xtime_coarse_nsec is in units of actual nanoseconds).  The current
    code shifts intermediate values by x12 unconditionally, but x12 is
    uninitialized when servicing a coarse clock.  Fix this by setting x12
    to 0 once we know we are dealing with a coarse clock id.
    
    Signed-off-by: Nathan Lynch <nathan_lynch@mentor.com>
    Acked-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit fb569d15d867a06e89b1be8278404b6fbf6b5bde
Author: Nathan Lynch <nathan_lynch@mentor.com>
Date:   Wed Feb 5 05:53:04 2014 +0000

    arm64: vdso: fix coarse clock handling
    
    commit 069b918623e1510e58dacf178905a72c3baa3ae4 upstream.
    
    When __kernel_clock_gettime is called with a CLOCK_MONOTONIC_COARSE or
    CLOCK_REALTIME_COARSE clock id, it returns incorrectly to whatever the
    caller has placed in x2 ("ret x2" to return from the fast path).  Fix
    this by saving x30/LR to x2 only in code that will call
    __do_get_tspec, restoring x30 afterward, and using a plain "ret" to
    return from the routine.
    
    Also: while the resulting tv_nsec value for CLOCK_REALTIME and
    CLOCK_MONOTONIC must be computed using intermediate values that are
    left-shifted by cs_shift (x12, set by __do_get_tspec), the results for
    coarse clocks should be calculated using unshifted values
    (xtime_coarse_nsec is in units of actual nanoseconds).  The current
    code shifts intermediate values by x12 unconditionally, but x12 is
    uninitialized when servicing a coarse clock.  Fix this by setting x12
    to 0 once we know we are dealing with a coarse clock id.
    
    Signed-off-by: Nathan Lynch <nathan_lynch@mentor.com>
    Acked-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 069b918623e1510e58dacf178905a72c3baa3ae4
Author: Nathan Lynch <nathan_lynch@mentor.com>
Date:   Wed Feb 5 05:53:04 2014 +0000

    arm64: vdso: fix coarse clock handling
    
    When __kernel_clock_gettime is called with a CLOCK_MONOTONIC_COARSE or
    CLOCK_REALTIME_COARSE clock id, it returns incorrectly to whatever the
    caller has placed in x2 ("ret x2" to return from the fast path).  Fix
    this by saving x30/LR to x2 only in code that will call
    __do_get_tspec, restoring x30 afterward, and using a plain "ret" to
    return from the routine.
    
    Also: while the resulting tv_nsec value for CLOCK_REALTIME and
    CLOCK_MONOTONIC must be computed using intermediate values that are
    left-shifted by cs_shift (x12, set by __do_get_tspec), the results for
    coarse clocks should be calculated using unshifted values
    (xtime_coarse_nsec is in units of actual nanoseconds).  The current
    code shifts intermediate values by x12 unconditionally, but x12 is
    uninitialized when servicing a coarse clock.  Fix this by setting x12
    to 0 once we know we are dealing with a coarse clock id.
    
    Signed-off-by: Nathan Lynch <nathan_lynch@mentor.com>
    Acked-by: Will Deacon <will.deacon@arm.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>

commit 1d940aaab881b0ee62557ffbaad877ac5a1b51db
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Mon Nov 18 17:23:26 2013 +0100

    mac80211_hwsim: use CLOCK_MONOTONIC_RAW
    
    The beacon timers really shouldn't use any clock that is
    subject to adjustments from userspace, particularly not
    CLOCK_REALTIME. Use CLOCK_MONOTONIC_RAW instead.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

commit 07783397c6e3757de805bda5e1139a9e47aa7d74
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Sep 17 11:20:21 2013 -0700

    rtc: rtc-pl031: Set wakeup flag prior to registering rtcdev
    
    In some recent testing, I noticed the CLOCK_REALTIME_ALARM clockid
    wasn't functioning on my vexpress qemu environment. Looking into it
    I noticed the pl031 rtc driver doesn't set the wakeup flag on the
    device until after registering the device with the RTC subsystem.
    
    This causes the alarmtimer subsystem to not see the pl031 driver
    as a valid backing device, and that resuls in alarm clockids
    getting ENOTSUPP errors.
    
    Thus be sure to set the wakeup flag on the device prior to
    registering the rtcdev so the pl031 rtc driver can be used as
    the backing alarmtimer device.
    
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Cc: Alessandro Zummo <a.zummo@towertech.it>
    Cc: "Jon Medhurst (Tixy)" <tixy@linaro.org>
    Cc: linux-arm-kernel@lists.infradead.org
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 11ffa9d6065f344a9bd769a2452f26f2f671e5f8
Author: Todd Poynor <toddpoynor@google.com>
Date:   Wed May 15 14:38:12 2013 -0700

    timerfd: Add alarm timers
    
    Add support for clocks CLOCK_REALTIME_ALARM and CLOCK_BOOTTIME_ALARM,
    thereby enabling wakeup alarm timers via file descriptors.
    
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 4622b3b7c0269bd2da531ea5949cadff98522da9
Author: Steffen Trumtrar <s.trumtrar@pengutronix.de>
Date:   Wed Jan 30 14:16:00 2013 +0100

    ARM: i.MX25: clk: parent per5_clk to AHB clock
    
    commit 4b526ca5f627188425184a22ed46c91baa602d43 upstream.
    
    The mxc-timer on the imx25 needs to be derived from the AHB clock.
    If a bootloader reparents this clock to the ipg_clk_highfreq, which according
    to the datasheet is a valid operation, the system can/will produce lockups/
    freezes after some time [1].
    
    This can be forced with code like
            while(1)
                    syscall(SYS_clock_gettime, CLOCK_REALTIME, &tp);
    
    This was already fixed with the commit
            "i.MX25 GPT clock fix: ensure correct the clock source" [2],
    for 3.1-rc2, but was lost, when i.MX was converted to the common clock framework
    ("ARM i.MX25: implement clocks using common clock framework") [3]
    
    [1]: http://lists.arm.linux.org.uk/lurker/message/20130129.161230.229bda17.en.html
    [2]: 2012d9ca2a1381ae3e733330a7f0d1d2f1988bba
    [3]: 6bbaec5676e4f475b0d78743cbd4c70a8804ce14
    
    Signed-off-by: Steffen Trumtrar <s.trumtrar@pengutronix.de>
    Signed-off-by: Sascha Hauer <s.hauer@pengutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 4b526ca5f627188425184a22ed46c91baa602d43
Author: Steffen Trumtrar <s.trumtrar@pengutronix.de>
Date:   Wed Jan 30 14:16:00 2013 +0100

    ARM: i.MX25: clk: parent per5_clk to AHB clock
    
    The mxc-timer on the imx25 needs to be derived from the AHB clock.
    If a bootloader reparents this clock to the ipg_clk_highfreq, which according
    to the datasheet is a valid operation, the system can/will produce lockups/
    freezes after some time [1].
    
    This can be forced with code like
            while(1)
                    syscall(SYS_clock_gettime, CLOCK_REALTIME, &tp);
    
    This was already fixed with the commit
            "i.MX25 GPT clock fix: ensure correct the clock source" [2],
    for 3.1-rc2, but was lost, when i.MX was converted to the common clock framework
    ("ARM i.MX25: implement clocks using common clock framework") [3]
    
    [1]: http://lists.arm.linux.org.uk/lurker/message/20130129.161230.229bda17.en.html
    [2]: 2012d9ca2a1381ae3e733330a7f0d1d2f1988bba
    [3]: 6bbaec5676e4f475b0d78743cbd4c70a8804ce14
    
    Signed-off-by: Steffen Trumtrar <s.trumtrar@pengutronix.de>
    Cc: stable@vger.kernel.org # v3.5+
    Signed-off-by: Sascha Hauer <s.hauer@pengutronix.de>

commit b4e2564c9f5ba83af10076d029a7507b7a33b870
Author: John Stultz <john.stultz@linaro.org>
Date:   Mon Sep 17 21:38:46 2012 -0400

    time: Avoid making adjustments if we haven't accumulated anything
    
    commit bf2ac312195155511a0f79325515cbb61929898a upstream.
    
    If update_wall_time() is called and the current offset isn't large
    enough to accumulate, avoid re-calling timekeeping_adjust which may
    change the clock freq and can cause 1ns inconsistencies with
    CLOCK_REALTIME_COARSE/CLOCK_MONOTONIC_COARSE.
    
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Link: http://lkml.kernel.org/r/1345595449-34965-5-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Linux Kernel <linux-kernel@vger.kernel.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

commit 8e6057b510aad354e017c6dfca7f386a0eb91b63
Author: Sakari Ailus <sakari.ailus@iki.fi>
Date:   Sat Sep 15 15:14:42 2012 -0300

    [media] v4l: Convert drivers to use monotonic timestamps
    
    Convert drivers using wall clock time (CLOCK_REALTIME) to timestamp from the
    monotonic timer (CLOCK_MONOTONIC).
    
    Signed-off-by: Sakari Ailus <sakari.ailus@iki.fi>
    Acked-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

commit 61b76840ddee647c0c223365378c3f394355b7d7
Author: John Stultz <john.stultz@linaro.org>
Date:   Mon Sep 17 22:32:09 2012 -0400

    time: Avoid making adjustments if we haven't accumulated anything
    
    This is a -stable backport of bf2ac312195155511a0f79325515cbb61929898a
    
    If update_wall_time() is called and the current offset isn't large
    enough to accumulate, avoid re-calling timekeeping_adjust which may
    change the clock freq and can cause 1ns inconsistencies with
    CLOCK_REALTIME_COARSE/CLOCK_MONOTONIC_COARSE.
    
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: stable@vger.kernel.org
    Link: http://lkml.kernel.org/r/1345595449-34965-5-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Linux Kernel <linux-kernel@vger.kernel.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Willy Tarreau <w@1wt.eu>

commit 22539a28b0a97e84f74f716fe42d61dd07612d2d
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jul 17 18:05:33 2012 -0400

    timekeeping: Provide hrtimer update function
    
    This is a backport of f6c06abfb3972ad4914cef57d8348fcb2932bc3b
    
    To finally fix the infamous leap second issue and other race windows
    caused by functions which change the offsets between the various time
    bases (CLOCK_MONOTONIC, CLOCK_REALTIME and CLOCK_BOOTTIME) we need a
    function which atomically gets the current monotonic time and updates
    the offsets of CLOCK_REALTIME and CLOCK_BOOTTIME with minimalistic
    overhead. The previous patch which provides ktime_t offsets allows us
    to make this function almost as cheap as ktime_get() which is going to
    be replaced in hrtimer_interrupt().
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Ingo Molnar <mingo@kernel.org>
    Acked-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Acked-by: Prarit Bhargava <prarit@redhat.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Link: http://lkml.kernel.org/r/1341960205-56738-7-git-send-email-johnstul@us.ibm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Linux Kernel <linux-kernel@vger.kernel.org>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Willy Tarreau <w@1wt.eu>

commit d155586fe34db9fc8d247a681c6524c7d75dd863
Author: John Stultz <johnstul@us.ibm.com>
Date:   Tue Jul 17 18:05:30 2012 -0400

    timekeeping: Fix leapsecond triggered load spike issue
    
    This is a backport of 4873fa070ae84a4115f0b3c9dfabc224f1bc7c51
    
    The timekeeping code misses an update of the hrtimer subsystem after a
    leap second happened. Due to that timers based on CLOCK_REALTIME are
    either expiring a second early or late depending on whether a leap
    second has been inserted or deleted until an operation is initiated
    which causes that update. Unless the update happens by some other
    means this discrepancy between the timekeeping and the hrtimer data
    stays forever and timers are expired either early or late.
    
    The reported immediate workaround - $ data -s "`date`" - is causing a
    call to clock_was_set() which updates the hrtimer data structures.
    See: http://www.sheeri.com/content/mysql-and-leap-second-high-cpu-and-fix
    
    Add the missing clock_was_set() call to update_wall_time() in case of
    a leap second event. The actual update is deferred to softirq context
    as the necessary smp function call cannot be invoked from hard
    interrupt context.
    
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Reported-by: Jan Engelhardt <jengelh@inai.de>
    Reviewed-by: Ingo Molnar <mingo@kernel.org>
    Acked-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Acked-by: Prarit Bhargava <prarit@redhat.com>
    Cc: stable@vger.kernel.org
    Link: http://lkml.kernel.org/r/1341960205-56738-3-git-send-email-johnstul@us.ibm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Linux Kernel <linux-kernel@vger.kernel.org>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Willy Tarreau <w@1wt.eu>

commit 4e64f897ce0d333d574143c0a23b1299d6137b4a
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Sep 11 14:56:20 2012 -0400

    time: Avoid making adjustments if we haven't accumulated anything
    
    commit bf2ac312195155511a0f79325515cbb61929898a upstream.
    
    If update_wall_time() is called and the current offset isn't large
    enough to accumulate, avoid re-calling timekeeping_adjust which may
    change the clock freq and can cause 1ns inconsistencies with
    CLOCK_REALTIME_COARSE/CLOCK_MONOTONIC_COARSE.
    
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: stable@vger.kernel.org
    Link: http://lkml.kernel.org/r/1345595449-34965-5-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 80257cbe62ea0919153c43421746269ab68473bf
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Sep 11 15:04:18 2012 -0400

    time: Avoid making adjustments if we haven't accumulated anything
    
    commit bf2ac312195155511a0f79325515cbb61929898a upstream.
    
    If update_wall_time() is called and the current offset isn't large
    enough to accumulate, avoid re-calling timekeeping_adjust which may
    change the clock freq and can cause 1ns inconsistencies with
    CLOCK_REALTIME_COARSE/CLOCK_MONOTONIC_COARSE.
    
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Link: http://lkml.kernel.org/r/1345595449-34965-5-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 4ffa9a8069801e36e2aceed5a77482b8b0841757
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Sep 11 20:49:52 2012 -0400

    time: Avoid making adjustments if we haven't accumulated anything
    
    commit bf2ac312195155511a0f79325515cbb61929898a upstream
    
    If update_wall_time() is called and the current offset isn't large
    enough to accumulate, avoid re-calling timekeeping_adjust which may
    change the clock freq and can cause 1ns inconsistencies with
    CLOCK_REALTIME_COARSE/CLOCK_MONOTONIC_COARSE.
    
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Link: http://lkml.kernel.org/r/1345595449-34965-5-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit cfb06dcbc0a63430195cfb70b56bd58311414878
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Aug 21 20:30:49 2012 -0400

    time: Avoid making adjustments if we haven't accumulated anything
    
    This is a -stable backport of bf2ac312195155511a0f79325515cbb61929898a
    
    If update_wall_time() is called and the current offset isn't large
    enough to accumulate, avoid re-calling timekeeping_adjust which may
    change the clock freq and can cause 1ns inconsistencies with
    CLOCK_REALTIME_COARSE/CLOCK_MONOTONIC_COARSE.
    
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Link: http://lkml.kernel.org/r/1345595449-34965-5-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Linux Kernel <linux-kernel@vger.kernel.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit bf2ac312195155511a0f79325515cbb61929898a
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Aug 21 20:30:49 2012 -0400

    time: Avoid making adjustments if we haven't accumulated anything
    
    If update_wall_time() is called and the current offset isn't large
    enough to accumulate, avoid re-calling timekeeping_adjust which may
    change the clock freq and can cause 1ns inconsistencies with
    CLOCK_REALTIME_COARSE/CLOCK_MONOTONIC_COARSE.
    
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: stable@vger.kernel.org
    Link: http://lkml.kernel.org/r/1345595449-34965-5-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit bd77b8e820140e552098f5262aa4e91513614110
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jul 17 17:49:29 2012 -0400

    timekeeping: Provide hrtimer update function
    
    commit f6c06abfb3972ad4914cef57d8348fcb2932bc3b upstream.
    
    To finally fix the infamous leap second issue and other race windows
    caused by functions which change the offsets between the various time
    bases (CLOCK_MONOTONIC, CLOCK_REALTIME and CLOCK_BOOTTIME) we need a
    function which atomically gets the current monotonic time and updates
    the offsets of CLOCK_REALTIME and CLOCK_BOOTTIME with minimalistic
    overhead. The previous patch which provides ktime_t offsets allows us
    to make this function almost as cheap as ktime_get() which is going to
    be replaced in hrtimer_interrupt().
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Ingo Molnar <mingo@kernel.org>
    Acked-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Acked-by: Prarit Bhargava <prarit@redhat.com>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Link: http://lkml.kernel.org/r/1341960205-56738-7-git-send-email-johnstul@us.ibm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Linux Kernel <linux-kernel@vger.kernel.org>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

commit 7e565a62054f05baecbc74ec28613b09bad57bcf
Author: John Stultz <johnstul@us.ibm.com>
Date:   Tue Jul 17 17:49:26 2012 -0400

    timekeeping: Fix leapsecond triggered load spike issue
    
    commit 4873fa070ae84a4115f0b3c9dfabc224f1bc7c51 upstream.
    
    The timekeeping code misses an update of the hrtimer subsystem after a
    leap second happened. Due to that timers based on CLOCK_REALTIME are
    either expiring a second early or late depending on whether a leap
    second has been inserted or deleted until an operation is initiated
    which causes that update. Unless the update happens by some other
    means this discrepancy between the timekeeping and the hrtimer data
    stays forever and timers are expired either early or late.
    
    The reported immediate workaround - $ data -s "`date`" - is causing a
    call to clock_was_set() which updates the hrtimer data structures.
    See: http://www.sheeri.com/content/mysql-and-leap-second-high-cpu-and-fix
    
    Add the missing clock_was_set() call to update_wall_time() in case of
    a leap second event. The actual update is deferred to softirq context
    as the necessary smp function call cannot be invoked from hard
    interrupt context.
    
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Reported-by: Jan Engelhardt <jengelh@inai.de>
    Reviewed-by: Ingo Molnar <mingo@kernel.org>
    Acked-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Acked-by: Prarit Bhargava <prarit@redhat.com>
    Link: http://lkml.kernel.org/r/1341960205-56738-3-git-send-email-johnstul@us.ibm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Linux Kernel <linux-kernel@vger.kernel.org>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

commit ec5806bcd08281a86e05b8e4eaf2f377bc8e5b24
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jul 10 18:43:24 2012 -0400

    timekeeping: Provide hrtimer update function
    
    This is a backport of f6c06abfb3972ad4914cef57d8348fcb2932bc3b
    
    To finally fix the infamous leap second issue and other race windows
    caused by functions which change the offsets between the various time
    bases (CLOCK_MONOTONIC, CLOCK_REALTIME and CLOCK_BOOTTIME) we need a
    function which atomically gets the current monotonic time and updates
    the offsets of CLOCK_REALTIME and CLOCK_BOOTTIME with minimalistic
    overhead. The previous patch which provides ktime_t offsets allows us
    to make this function almost as cheap as ktime_get() which is going to
    be replaced in hrtimer_interrupt().
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Ingo Molnar <mingo@kernel.org>
    Acked-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Acked-by: Prarit Bhargava <prarit@redhat.com>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Link: http://lkml.kernel.org/r/1341960205-56738-7-git-send-email-johnstul@us.ibm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    [John Stultz: Backported to 3.2]
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Linux Kernel <linux-kernel@vger.kernel.org>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit 8a1ba973a23bd94a4ce34ffa543bf0e0d4ec13ff
Author: John Stultz <johnstul@us.ibm.com>
Date:   Tue Jul 10 18:43:20 2012 -0400

    timekeeping: Fix leapsecond triggered load spike issue
    
    This is a backport of 4873fa070ae84a4115f0b3c9dfabc224f1bc7c51
    
    The timekeeping code misses an update of the hrtimer subsystem after a
    leap second happened. Due to that timers based on CLOCK_REALTIME are
    either expiring a second early or late depending on whether a leap
    second has been inserted or deleted until an operation is initiated
    which causes that update. Unless the update happens by some other
    means this discrepancy between the timekeeping and the hrtimer data
    stays forever and timers are expired either early or late.
    
    The reported immediate workaround - $ data -s "`date`" - is causing a
    call to clock_was_set() which updates the hrtimer data structures.
    See: http://www.sheeri.com/content/mysql-and-leap-second-high-cpu-and-fix
    
    Add the missing clock_was_set() call to update_wall_time() in case of
    a leap second event. The actual update is deferred to softirq context
    as the necessary smp function call cannot be invoked from hard
    interrupt context.
    
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Reported-by: Jan Engelhardt <jengelh@inai.de>
    Reviewed-by: Ingo Molnar <mingo@kernel.org>
    Acked-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Acked-by: Prarit Bhargava <prarit@redhat.com>
    Link: http://lkml.kernel.org/r/1341960205-56738-3-git-send-email-johnstul@us.ibm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Linux Kernel <linux-kernel@vger.kernel.org>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit 765bdc4d82fadcddfec19222a545e904633c7816
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jul 17 02:39:54 2012 -0400

    timekeeping: Provide hrtimer update function
    
    This is a backport of f6c06abfb3972ad4914cef57d8348fcb2932bc3b
    
    To finally fix the infamous leap second issue and other race windows
    caused by functions which change the offsets between the various time
    bases (CLOCK_MONOTONIC, CLOCK_REALTIME and CLOCK_BOOTTIME) we need a
    function which atomically gets the current monotonic time and updates
    the offsets of CLOCK_REALTIME and CLOCK_BOOTTIME with minimalistic
    overhead. The previous patch which provides ktime_t offsets allows us
    to make this function almost as cheap as ktime_get() which is going to
    be replaced in hrtimer_interrupt().
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Ingo Molnar <mingo@kernel.org>
    Acked-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Acked-by: Prarit Bhargava <prarit@redhat.com>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Link: http://lkml.kernel.org/r/1341960205-56738-7-git-send-email-johnstul@us.ibm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 2e947d469fba2c2036ff50a2e58a1875ab2ea6b6
Author: John Stultz <johnstul@us.ibm.com>
Date:   Tue Jul 17 02:39:51 2012 -0400

    timekeeping: Fix leapsecond triggered load spike issue
    
    This is a backport of 4873fa070ae84a4115f0b3c9dfabc224f1bc7c51
    
    The timekeeping code misses an update of the hrtimer subsystem after a
    leap second happened. Due to that timers based on CLOCK_REALTIME are
    either expiring a second early or late depending on whether a leap
    second has been inserted or deleted until an operation is initiated
    which causes that update. Unless the update happens by some other
    means this discrepancy between the timekeeping and the hrtimer data
    stays forever and timers are expired either early or late.
    
    The reported immediate workaround - $ data -s "`date`" - is causing a
    call to clock_was_set() which updates the hrtimer data structures.
    See: http://www.sheeri.com/content/mysql-and-leap-second-high-cpu-and-fix
    
    Add the missing clock_was_set() call to update_wall_time() in case of
    a leap second event. The actual update is deferred to softirq context
    as the necessary smp function call cannot be invoked from hard
    interrupt context.
    
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Reported-by: Jan Engelhardt <jengelh@inai.de>
    Reviewed-by: Ingo Molnar <mingo@kernel.org>
    Acked-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Acked-by: Prarit Bhargava <prarit@redhat.com>
    Link: http://lkml.kernel.org/r/1341960205-56738-3-git-send-email-johnstul@us.ibm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 22f4bbcfb131e2392c78ad67af35fdd436d4dd54
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jul 17 13:33:56 2012 -0400

    timekeeping: Provide hrtimer update function
    
    This is a backport of f6c06abfb3972ad4914cef57d8348fcb2932bc3b
    
    To finally fix the infamous leap second issue and other race windows
    caused by functions which change the offsets between the various time
    bases (CLOCK_MONOTONIC, CLOCK_REALTIME and CLOCK_BOOTTIME) we need a
    function which atomically gets the current monotonic time and updates
    the offsets of CLOCK_REALTIME and CLOCK_BOOTTIME with minimalistic
    overhead. The previous patch which provides ktime_t offsets allows us
    to make this function almost as cheap as ktime_get() which is going to
    be replaced in hrtimer_interrupt().
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Ingo Molnar <mingo@kernel.org>
    Acked-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Acked-by: Prarit Bhargava <prarit@redhat.com>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Link: http://lkml.kernel.org/r/1341960205-56738-7-git-send-email-johnstul@us.ibm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit d21e4baf4523fec26e3c70cb78b013ad3b245c83
Author: John Stultz <johnstul@us.ibm.com>
Date:   Tue Jul 17 13:33:53 2012 -0400

    timekeeping: Fix leapsecond triggered load spike issue
    
    This is a backport of 4873fa070ae84a4115f0b3c9dfabc224f1bc7c51
    
    The timekeeping code misses an update of the hrtimer subsystem after a
    leap second happened. Due to that timers based on CLOCK_REALTIME are
    either expiring a second early or late depending on whether a leap
    second has been inserted or deleted until an operation is initiated
    which causes that update. Unless the update happens by some other
    means this discrepancy between the timekeeping and the hrtimer data
    stays forever and timers are expired either early or late.
    
    The reported immediate workaround - $ data -s "`date`" - is causing a
    call to clock_was_set() which updates the hrtimer data structures.
    See: http://www.sheeri.com/content/mysql-and-leap-second-high-cpu-and-fix
    
    Add the missing clock_was_set() call to update_wall_time() in case of
    a leap second event. The actual update is deferred to softirq context
    as the necessary smp function call cannot be invoked from hard
    interrupt context.
    
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Reported-by: Jan Engelhardt <jengelh@inai.de>
    Reviewed-by: Ingo Molnar <mingo@kernel.org>
    Acked-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Acked-by: Prarit Bhargava <prarit@redhat.com>
    Link: http://lkml.kernel.org/r/1341960205-56738-3-git-send-email-johnstul@us.ibm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit f6c06abfb3972ad4914cef57d8348fcb2932bc3b
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jul 10 18:43:24 2012 -0400

    timekeeping: Provide hrtimer update function
    
    To finally fix the infamous leap second issue and other race windows
    caused by functions which change the offsets between the various time
    bases (CLOCK_MONOTONIC, CLOCK_REALTIME and CLOCK_BOOTTIME) we need a
    function which atomically gets the current monotonic time and updates
    the offsets of CLOCK_REALTIME and CLOCK_BOOTTIME with minimalistic
    overhead. The previous patch which provides ktime_t offsets allows us
    to make this function almost as cheap as ktime_get() which is going to
    be replaced in hrtimer_interrupt().
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Ingo Molnar <mingo@kernel.org>
    Acked-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Acked-by: Prarit Bhargava <prarit@redhat.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Link: http://lkml.kernel.org/r/1341960205-56738-7-git-send-email-johnstul@us.ibm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 4873fa070ae84a4115f0b3c9dfabc224f1bc7c51
Author: John Stultz <johnstul@us.ibm.com>
Date:   Tue Jul 10 18:43:20 2012 -0400

    timekeeping: Fix leapsecond triggered load spike issue
    
    The timekeeping code misses an update of the hrtimer subsystem after a
    leap second happened. Due to that timers based on CLOCK_REALTIME are
    either expiring a second early or late depending on whether a leap
    second has been inserted or deleted until an operation is initiated
    which causes that update. Unless the update happens by some other
    means this discrepancy between the timekeeping and the hrtimer data
    stays forever and timers are expired either early or late.
    
    The reported immediate workaround - $ data -s "`date`" - is causing a
    call to clock_was_set() which updates the hrtimer data structures.
    See: http://www.sheeri.com/content/mysql-and-leap-second-high-cpu-and-fix
    
    Add the missing clock_was_set() call to update_wall_time() in case of
    a leap second event. The actual update is deferred to softirq context
    as the necessary smp function call cannot be invoked from hard
    interrupt context.
    
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Reported-by: Jan Engelhardt <jengelh@inai.de>
    Reviewed-by: Ingo Molnar <mingo@kernel.org>
    Acked-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Acked-by: Prarit Bhargava <prarit@redhat.com>
    Cc: stable@vger.kernel.org
    Link: http://lkml.kernel.org/r/1341960205-56738-3-git-send-email-johnstul@us.ibm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 57c498fa5df05e4bd410c101795368439fec7b4e
Author: John Stultz <john.stultz@linaro.org>
Date:   Fri Apr 20 12:31:45 2012 -0700

    alarmtimer: Provide accessor to alarmtimer rtc device
    
    The Android alarm interface provides a settime call that sets both
    the alarmtimer RTC device and CLOCK_REALTIME to the same value.
    
    Since there may be multiple rtc devices, provide a hook to access the
    one the alarmtimer infrastructure is using.
    
    CC: Colin Cross <ccross@android.com>
    CC: Thomas Gleixner <tglx@linutronix.de>
    CC: Android Kernel Team <kernel-team@android.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit a80b83b7b8456e9b475346c2e01d7e210883208c
Author: John Stultz <john.stultz@linaro.org>
Date:   Fri Feb 3 00:19:07 2012 -0800

    Input: add infrastructure for selecting clockid for event time stamps
    
    As noted by Arve and others, since wall time can jump backwards, it is
    difficult to use for input because one cannot determine if one event
    occurred before another or for how long a key was pressed.
    
    However, the timestamp field is part of the kernel ABI, and cannot be
    changed without possibly breaking existing users.
    
    This patch adds a new IOCTL that allows a clockid to be set in the
    evdev_client struct that will specify which time base to use for event
    timestamps (ie: CLOCK_MONOTONIC instead of CLOCK_REALTIME).
    
    For now we only support CLOCK_MONOTONIC and CLOCK_REALTIME, but
    in the future we could support other clockids if appropriate.
    
    The default remains CLOCK_REALTIME, so we don't change the ABI.
    
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Reviewed-by: Daniel Kurtz <djkurtz@google.com>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

commit 3dcad5ff08f65ae30832220a0e0ee2eac3502a1a
Author: John Stultz <john.stultz@linaro.org>
Date:   Fri May 27 11:33:18 2011 -0700

    rtc: Avoid accumulating time drift in suspend/resume
    
    Because the RTC interface is only a second granular interface,
    each time we read from the RTC for suspend/resume, we introduce a
    half second (on average) of error.
    
    In order to avoid this error accumulating as the system is suspended
    over and over, this patch measures the time delta between the RTC
    and the system CLOCK_REALTIME.
    
    If the delta is less then 2 seconds from the last suspend, we compensate
    by using the previous time delta (keeping it close). If it is larger
    then 2 seconds, we assume the clock was set or has been changed, so we
    do no correction and update the delta.
    
    Note: If NTP is running, ths could seem to "fight" with the NTP corrected
    time, where as if the system time was off by 1 second, and NTP slewed the
    value in, a suspend/resume cycle could undo this correction, by trying to
    restore the previous offset from the RTC. However, without this patch,
    since each read could cause almost a full second worth of error, its
    possible to get almost 2 seconds of error just from the suspend/resume
    cycle alone, so this about equal to any offset added by the compensation.
    
    Further on systems that suspend/resume frequently, this should keep time
    closer then NTP could compensate for if the errors were allowed to
    accumulate.
    
    Credits to Arve Hjønnevåg for suggesting this solution.
    
    This patch also improves some of the variable names and adds more clear
    comments.
    
    CC: Arve Hjønnevåg <arve@android.com>
    CC: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit cb33217b1b2523895eb328a0b13fb3b1c4000969
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue May 31 22:53:23 2011 -0700

    time: Avoid accumulating time drift in suspend/resume
    
    Because the read_persistent_clock interface is usually backed by
    only a second granular interface, each time we read from the persistent
    clock for suspend/resume, we introduce a half second (on average) of error.
    
    In order to avoid this error accumulating as the system is suspended
    over and over, this patch measures the time delta between the persistent
    clock and the system CLOCK_REALTIME.
    
    If the delta is less then 2 seconds from the last suspend, we compensate
    by using the previous time delta (keeping it close). If it is larger
    then 2 seconds, we assume the clock was set or has been changed, so we
    do no correction and update the delta.
    
    Note: If NTP is running, ths could seem to "fight" with the NTP corrected
    time, where as if the system time was off by 1 second, and NTP slewed the
    value in, a suspend/resume cycle could undo this correction, by trying to
    restore the previous offset from the persistent clock.  However, without
    this patch, since each read could cause almost a full second worth of
    error, its possible to get almost 2 seconds of error just from the
    suspend/resume cycle alone, so this about equal to any offset added by
    the compensation.
    
    Further on systems that suspend/resume frequently, this should keep time
    closer then NTP could compensate for if the errors were allowed to
    accumulate.
    
    Credits to Arve Hjønnevåg for suggesting this solution.
    
    CC: Arve Hjønnevåg <arve@android.com>
    CC: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 90ff1f30c0f401e325d6b2747618b7e3a0addaf8
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 25 23:08:17 2011 +0200

    hrtimers: Fix typo causing erratic timers
    
    commit 9ec2690758a5 ("timerfd: Manage cancelable timers in timerfd")
    introduced a CONFIG_HIGHRES_TIMERS (should be CONFIG_HIGH_RES_TIMERS)
    typo, which caused applications depending on CLOCK_REALTIME timers to
    become sluggy due to the fact that the time base of the realtime
    timers was not updated when the wall clock time was set.
    
    This causes anything from 100% CPU use for some applications to odd
    delays and hickups.
    
    Reported-bisected-and-tested-by: Anca Emanuel <anca.emanuel@gmail.com>
    Tested-by: Linus Torvalds <torvalds@linux-foundation.org>
    Fatfingered-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit 68fa61c026057a39d6ccb850aa8785043afbee02
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri May 20 23:14:04 2011 +0200

    hrtimers: Reorder clock bases
    
    The ordering of the clock bases is historical due to the
    CLOCK_REALTIME and CLOCK_MONOTONIC constants. Now the hrtimer bases
    have their own enumeration due to the gap between CLOCK_MONOTONIC and
    CLOCK_BOOTTIME. So we can be more clever as most timers end up on the
    CLOCK_MONOTONIC base due to the virtue of POSIX declaring that
    relative CLOCK_REALTIME timers are not affected by time changes. In
    desktop environments this is slowly changing as applications switch to
    absolute timers, but I've observed empty CLOCK_REALTIME bases often
    enough. There is no performance penalty or overhead when
    CLOCK_REALTIME timers are active, but in case they are not we don't
    skip over a full cache line.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Peter Zijlstra <peterz@infradead.org>

commit 9ec2690758a5467f24beb301cca5098078073bba
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri May 20 16:18:50 2011 +0200

    timerfd: Manage cancelable timers in timerfd
    
    Peter is concerned about the extra scan of CLOCK_REALTIME_COS in the
    timer interrupt. Yes, I did not think about it, because the solution
    was so elegant. I didn't like the extra list in timerfd when it was
    proposed some time ago, but with a rcu based list the list walk it's
    less horrible than the original global lock, which was held over the
    list iteration.
    
    Requested-by: Peter Zijlstra <peterz@infradead.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Peter Zijlstra <peterz@infradead.org>

commit ce31332d3c77532d6ea97ddcb475a2b02dd358b4
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Apr 29 00:02:00 2011 +0200

    hrtimer: Initialize CLOCK_ID to HRTIMER_BASE table statically
    
    Sedat and Bruno reported RCU stalls which turned out to be caused by
    the following;
    
    sched_init() calls init_rt_bandwidth() which calls hrtimer_init()
    _BEFORE_ hrtimers_init() is called. While not entirely correct this
    worked because hrtimer_init() only accessed statically initialized
    data (hrtimer_bases.clock_base[CLOCK_MONOTONIC])
    
    Commit e06383db9 (hrtimers: extend hrtimer base code to handle more
    then 2 clockids) added an indirection to the hrtimer_bases.clock_base
    lookup to avoid gap handling in the hot path. The table which is used
    for the translataion from CLOCK_ID to HRTIMER_BASE index is
    initialized at runtime in hrtimers_init(). So the early call of the
    scheduler code translates CLOCK_MONOTONIC to HRTIMER_BASE_REALTIME.
    
    Thus the rt_bandwith timer ends up on CLOCK_REALTIME. If the timer is
    armed and the wall clock time is set (e.g. ntpdate in the early boot
    process - which also gives the problem deterministic behaviour
    i.e. magic recovery after N hours), then the timer ends up with an
    expiry time far into the future. That breaks the RT throttler
    mechanism as rt runtime is accumulated and never cleared, so the rt
    throttler detects a false cpu hog condition and blocks all RT tasks
    until the timer finally expires. That in turn stalls the RCU thread of
    TINYRCU which leads to an huge amount of RCU callbacks piling up.
    
    Make the translation table statically initialized, so we are back to
    the status of <= 2.6.39.
    
    Reported-and-tested-by: Sedat Dilek <sedat.dilek@gmail.com>
    Reported-by: Bruno Prémont <bonbons@linux-vserver.org>
    Cc: John stultz <johnstul@us.ibm.com>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/%3Calpine.LFD.2.02.1104282353140.3005%40ionos%3E
    Reviewed-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 9a7adcf5c6dea63d2e47e6f6d2f7a6c9f48b9337
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Jan 11 09:54:33 2011 -0800

    timers: Posix interface for alarm-timers
    
    This patch exposes alarm-timers to userland via the posix clock
    and timers interface, using two new clockids: CLOCK_REALTIME_ALARM
    and CLOCK_BOOTTIME_ALARM. Both clockids behave identically to
    CLOCK_REALTIME and CLOCK_BOOTTIME, respectively, but timers
    set against the _ALARM suffixed clockids will wake the system if
    it is suspended.
    
    Some background can be found here:
            https://lwn.net/Articles/429925/
    
    The concept for Alarm-timers was inspired by the Android Alarm
    driver (by Arve Hjønnevåg) found in the Android kernel tree.
    
    See: http://android.git.kernel.org/?p=kernel/common.git;a=blob;f=drivers/rtc/alarm.c;h=1250edfbdf3302f5e4ea6194847c6ef4bb7beb1c;hb=android-2.6.36
    
    While the in-kernel interface is pretty similar between
    alarm-timers and Android alarm driver, the user-space interface
    for the Android alarm driver is via ioctls to a new char device.
    As mentioned above, I've instead chosen to export this functionality
    via the posix interface, as it seemed a little simpler and avoids
    creating duplicate interfaces to things like CLOCK_REALTIME and
    CLOCK_MONOTONIC under alternate names (ie:ANDROID_ALARM_RTC and
    ANDROID_ALARM_SYSTEMTIME).
    
    The semantics of the Android alarm driver are different from what
    this posix interface provides. For instance, threads other then
    the thread waiting on the Android alarm driver are able to modify
    the alarm being waited on. Also this interface does not allow
    the same wakelock semantics that the Android driver provides
    (ie: kernel takes a wakelock on RTC alarm-interupt, and holds it
    through process wakeup, and while the process runs, until the
    process either closes the char device or calls back in to wait
    on a new alarm).
    
    One potential way to implement similar semantics may be via
    the timerfd infrastructure, but this needs more research.
    
    There may also need to be some sort of sysfs system level policy
    hooks that allow alarm timers to be disabled to keep them
    from firing at inappropriate times (ie: laptop in a well insulated
    bag, mid-flight).
    
    CC: Arve Hjønnevåg <arve@android.com>
    CC: Thomas Gleixner <tglx@linutronix.de>
    CC: Alessandro Zummo <a.zummo@towertech.it>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 304529b1b6f8612ccbb4582e997051b48b94f4a4
Author: John Stultz <john.stultz@linaro.org>
Date:   Fri Apr 1 14:32:09 2011 -0700

    time: Add timekeeping_inject_sleeptime
    
    Some platforms cannot implement read_persistent_clock, as
    their RTC devices are only accessible when interrupts are enabled.
    This keeps them from being used by the timekeeping code on resume
    to measure the time in suspend.
    
    The RTC layer tries to work around this, by calling do_settimeofday
    on resume after irqs are reenabled to set the time properly. However,
    this only corrects CLOCK_REALTIME, and does not properly adjust
    the sleep time value. This causes btime in /proc/stat to be incorrect
    as well as making the new CLOCK_BOTTTIME inaccurate.
    
    This patch resolves the issue by introducing a new timekeeping hook
    to allow the RTC layer to inject the sleep time on resume.
    
    The code also checks to make sure that read_persistent_clock is
    nonfunctional before setting the sleep time, so that should the RTC's
    HCTOSYS option be configured in on a system that does support
    read_persistent_clock we will not increase the total_sleep_time twice.
    
    CC: Arve Hjønnevåg <arve@android.com>
    CC: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 70a08cca1227dc31c784ec930099a4417a06e7d0
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Feb 15 10:45:16 2011 -0800

    timers: Add CLOCK_BOOTTIME hrtimer base
    
    CLOCK_MONOTONIC stops while the system is in suspend. This is because
    to applications system suspend is invisible. However, there is a
    growing set of applications that are wanting to be suspend-aware,
    but do not want to deal with the complications of CLOCK_REALTIME
    (which might jump around if settimeofday is called).
    
    For these applications, I propose a new clockid: CLOCK_BOOTTIME.
    CLOCK_BOOTTIME is idential to CLOCK_MONOTONIC, except it also
    includes any time spent in suspend.
    
    This patch add hrtimer base for CLOCK_BOOTTIME, using
    get_monotonic_boottime/ktime_get_boottime, to allow
    in kernel users to set timers against.
    
    CC: Jamie Lokier <jamie@shareable.org>
    CC: Thomas Gleixner <tglx@linutronix.de>
    CC: Alexander Shishkin <virtuoso@slind.org>
    CC: Arve Hjønnevåg <arve@android.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit e06383db9ec591696a06654257474b85bac1f8cb
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Dec 14 19:37:07 2010 -0800

    hrtimers: extend hrtimer base code to handle more then 2 clockids
    
    The hrtimer code is written mainly with CLOCK_REALTIME and CLOCK_MONOTONIC
    in mind. These are clockids 0 and 1 resepctively. However, if we are
    to introduce any new hrtimer bases, using new clockids, we have to skip
    the cputimers (clockids 2,3) as well as other clockids that may not impelement
    timers.
    
    This patch adds a little bit of indirection between the clockid and
    the base, so that we can extend the base by one when we add
    a new clockid at number 7 or so.
    
    CC: Jamie Lokier <jamie@shareable.org>
    CC: Thomas Gleixner <tglx@linutronix.de>
    CC: Alexander Shishkin <virtuoso@slind.org>
    CC: Arve Hjønnevåg <arve@android.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit c528f7c6c208f1fae6b4025957173dec045e5f21
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Feb 1 13:52:17 2011 +0000

    time: Introduce timekeeping_inject_offset
    
    This adds a kernel-internal timekeeping interface to add or subtract
    a fixed amount from CLOCK_REALTIME. This makes it so kernel users or
    interfaces trying to do so do not have to read the time, then add an
    offset and then call settimeofday(), which adds some extra error in
    comparision to just simply adding the offset in the kernel timekeeping
    core.
    
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Richard Cochran <richard.cochran@omicron.at>
    LKML-Reference: <20110201134419.584311693@linutronix.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 6761c6702e2c647582e1829abe8cf90794f61d9d
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Feb 1 13:52:07 2011 +0000

    posix-timers: Convert timer_delete() to clockid_to_kclock()
    
    Set the common function for CLOCK_MONOTONIC and CLOCK_REALTIME kclocks
    and use the new decoding function.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: John Stultz <johnstul@us.ibm.com>
    Tested-by: Richard Cochran <richard.cochran@omicron.at>
    LKML-Reference: <20110201134419.198999420@linutronix.de>

commit a7319fa253a549c4c6528fb550ae6e72a9c83811
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Feb 1 13:52:04 2011 +0000

    posix-timers: Convert timer_gettime() to clockid_to_kclock()
    
    Set the common function for CLOCK_MONOTONIC and CLOCK_REALTIME kclocks
    and use the new decoding function.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: John Stultz <johnstul@us.ibm.com>
    Tested-by: Richard Cochran <richard.cochran@omicron.at>
    LKML-Reference: <20110201134419.101243181@linutronix.de>

commit 27722df16ef143017db55ac7baac1703a68017ff
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Feb 1 13:52:01 2011 +0000

    posix-timers: Convert timer_settime() to clockid_to_kclock()
    
    Set the common function for CLOCK_MONOTONIC and CLOCK_REALTIME kclocks
    and use the new decoding function.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: John Stultz <johnstul@us.ibm.com>
    Tested-by: Richard Cochran <richard.cochran@omicron.at>
    LKML-Reference: <20110201134419.001863714@linutronix.de>

commit 838394fbf989973ec7f5a0ad82cb6ff09e5c39aa
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Feb 1 13:51:58 2011 +0000

    posix-timers: Convert timer_create() to clockid_to_kclock()
    
    Setup timer_create for CLOCK_MONOTONIC and CLOCK_REALTIME kclocks and
    remove the no_timer_create() implementation.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: John Stultz <johnstul@us.ibm.com>
    Tested-by: Richard Cochran <richard.cochran@omicron.at>
    LKML-Reference: <20110201134418.903604289@linutronix.de>

commit b3423982bd2ecb7160856ffd6618dbb929c786cc
Author: Heiko Carstens <heiko.carstens@de.ibm.com>
Date:   Fri Oct 29 16:50:41 2010 +0200

    [S390] vdso: get rid of redefinition warnings
    
    The CLOCK_* defines in asm-offsets.c are only used for the vdso code
    however in the meantime they cause other trouble.
    Just rename them to get permanently rid of this:
    
    In file included from /home2/heicarst/linux-2.6/arch/s390/include/asm/asm-offsets.h:1:0,
                     from arch/s390/mm/fault.c:33:
    include/generated/asm-offsets.h:53:0: warning: "CLOCK_REALTIME" redefined
    include/linux/time.h:286:0: note: this is the location of the previous definition
    include/generated/asm-offsets.h:54:0: warning: "CLOCK_MONOTONIC" redefined
    include/linux/time.h:287:0: note: this is the location of the previous definition
    
    Signed-off-by: Heiko Carstens <heiko.carstens@de.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

commit 164d44fd92e79d5bce54d0d62df9f856f7b23925
Merge: 5bfec46baa3a d7e81c269db8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed May 19 17:11:10 2010 -0700

    Merge branch 'timers-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'timers-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip:
      clocksource: Add clocksource_register_hz/khz interface
      posix-cpu-timers: Optimize run_posix_cpu_timers()
      time: Remove xtime_cache
      mqueue: Convert message queue timeout to use hrtimers
      hrtimers: Provide schedule_hrtimeout for CLOCK_REALTIME
      timers: Introduce the concept of timer slack for legacy timers
      ntp: Remove tickadj
      ntp: Make time_adjust static
      time: Add xtime, wall_to_monotonic to feature-removal-schedule
      timer: Try to survive timer callback preempt_count leak
      timer: Split out timer function call
      timer: Print function name for timer callbacks modifying preemption count
      time: Clean up warp_clock()
      cpu-timers: Avoid iterating over all threads in fastpath_timer_check()
      cpu-timers: Change SIGEV_NONE timer implementation
      cpu-timers: Return correct previous timer reload value
      cpu-timers: Cleanup arm_timer()
      cpu-timers: Simplify RLIMIT_CPU handling

commit 351b3f7a21e413a9b14d0393171497d2373bd702
Author: Carsten Emde <C.Emde@osadl.org>
Date:   Fri Apr 2 22:40:19 2010 +0200

    hrtimers: Provide schedule_hrtimeout for CLOCK_REALTIME
    
    The current version of schedule_hrtimeout() always uses the
    monotonic clock. Some system calls such as mq_timedsend()
    and mq_timedreceive(), however, require the use of the wall
    clock due to the definition of the system call.
    
    This patch provides the infrastructure to use schedule_hrtimeout()
    with a CLOCK_REALTIME timer.
    
    Signed-off-by: Carsten Emde <C.Emde@osadl.org>
    Tested-by: Pradyumna Sampath <pradysam@gmail.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Arjan van de Veen <arjan@infradead.org>
    LKML-Reference: <20100402204331.167439615@osadl.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit abfe5a01ef1e463cbafdae461b693db34e308c02
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Sat Feb 20 12:13:49 2010 +0100

    firewire: cdev: add more flexible cycle timer ioctl
    
    The system time from CLOCK_REALTIME is not monotonic, hence problematic
    for the main user of the FW_CDEV_IOC_GET_CYCLE_TIMER ioctl.  This issue
    exists in its successor ABI, i.e. raw1394, too.
    http://subversion.ffado.org/ticket/242
    
    We now offer an alternative ioctl which lets the caller choose between
    CLOCK_REALTIME, CLOCK_MONOTONIC, and CLOCK_MONOTONIC_RAW as source of
    the local time, very similar to the clock_gettime libc function.  The
    format of the local time return value matches that of clock_gettime
    (seconds and nanoseconds, instead of a single microseconds value from
    the existing ioctl).
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

commit 9e0d57fd6dad37d72a3ca6db00ca8c76f2215454
Author: Yury Polyanskiy <polyanskiy@gmail.com>
Date:   Sun Nov 8 20:58:41 2009 -0800

    xfrm: SAD entries do not expire correctly after suspend-resume
    
      This fixes the following bug in the current implementation of
    net/xfrm: SAD entries timeouts do not count the time spent by the machine
    in the suspended state. This leads to the connectivity problems because
    after resuming local machine thinks that the SAD entry is still valid, while
    it has already been expired on the remote server.
    
      The cause of this is very simple: the timeouts in the net/xfrm are bound to
    the old mod_timer() timers. This patch reassigns them to the
    CLOCK_REALTIME hrtimer.
    
      I have been using this version of the patch for a few months on my
    machines without any problems. Also run a few stress tests w/o any
    issues.
    
      This version of the patch uses tasklet_hrtimer by Peter Zijlstra
    (commit 9ba5f0).
    
      This patch is against 2.6.31.4. Please CC me.
    
    Signed-off-by: Yury Polyanskiy <polyanskiy@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit a03fdb7612874834d6847107198712d18b5242c7
Merge: 202c4675c55d 12e09337fe23
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Sep 18 09:15:24 2009 -0700

    Merge branch 'timers-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'timers-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip: (34 commits)
      time: Prevent 32 bit overflow with set_normalized_timespec()
      clocksource: Delay clocksource down rating to late boot
      clocksource: clocksource_select must be called with mutex locked
      clocksource: Resolve cpu hotplug dead lock with TSC unstable, fix crash
      timers: Drop a function prototype
      clocksource: Resolve cpu hotplug dead lock with TSC unstable
      timer.c: Fix S/390 comments
      timekeeping: Fix invalid getboottime() value
      timekeeping: Fix up read_persistent_clock() breakage on sh
      timekeeping: Increase granularity of read_persistent_clock(), build fix
      time: Introduce CLOCK_REALTIME_COARSE
      x86: Do not unregister PIT clocksource on PIT oneshot setup/shutdown
      clocksource: Avoid clocksource watchdog circular locking dependency
      clocksource: Protect the watchdog rating changes with clocksource_mutex
      clocksource: Call clocksource_change_rating() outside of watchdog_lock
      timekeeping: Introduce read_boot_clock
      timekeeping: Increase granularity of read_persistent_clock()
      timekeeping: Update clocksource with stop_machine
      timekeeping: Add timekeeper read_clock helper functions
      timekeeping: Move NTP adjusted clock multiplier to struct timekeeper
      ...
    
    Fix trivial conflict due to MIPS lemote -> loongson renaming.

commit da15cfdae03351c689736f8d142618592e3cebc3
Author: John Stultz <johnstul@us.ibm.com>
Date:   Wed Aug 19 19:13:34 2009 -0700

    time: Introduce CLOCK_REALTIME_COARSE
    
    After talking with some application writers who want very fast, but not
    fine-grained timestamps, I decided to try to implement new clock_ids
    to clock_gettime(): CLOCK_REALTIME_COARSE and CLOCK_MONOTONIC_COARSE
    which returns the time at the last tick. This is very fast as we don't
    have to access any hardware (which can be very painful if you're using
    something like the acpi_pm clocksource), and we can even use the vdso
    clock_gettime() method to avoid the syscall. The only trade off is you
    only get low-res tick grained time resolution.
    
    This isn't a new idea, I know Ingo has a patch in the -rt tree that made
    the vsyscall gettimeofday() return coarse grained time when the
    vsyscall64 sysctrl was set to 2. However this affects all applications
    on a system.
    
    With this method, applications can choose the proper speed/granularity
    trade-off for themselves.
    
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Cc: Andi Kleen <andi@firstfloor.org>
    Cc: nikolag@ca.ibm.com
    Cc: Darren Hart <dvhltc@us.ibm.com>
    Cc: arjan@infradead.org
    Cc: jonathan@jonmasters.org
    LKML-Reference: <1250734414.6897.5.camel@localhost.localdomain>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 6ff7041dbfeb3bd7dfe9aa67275c21199ef760d6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Jul 10 14:57:05 2009 +0200

    hrtimer: Fix migration expiry check
    
    The timer migration expiry check should prevent the migration of a
    timer to another CPU when the timer expires before the next event is
    scheduled on the other CPU. Migrating the timer might delay it because
    we can not reprogram the clock event device on the other CPU. But the
    code implementing that check has two flaws:
    
    - for !HIGHRES the check compares the expiry value with the clock
      events device expiry value which is wrong for CLOCK_REALTIME based
      timers.
    
    - the check is racy. It holds the hrtimer base lock of the target CPU,
      but the clock event device expiry value can be modified
      nevertheless, e.g. by an timer interrupt firing.
    
    The !HIGHRES case is easy to fix as we can enqueue the timer on the
    cpu which was selected by the load balancer. It runs the idle
    balancing code once per jiffy anyway. So the maximum delay for the
    timer is the same as when we keep the tick on the current cpu going.
    
    In the HIGHRES case we can get the next expiry value from the hrtimer
    cpu_base of the target CPU and serialize the update with the cpu_base
    lock. This moves the lock section in hrtimer_interrupt() so we can set
    next_event to KTIME_MAX while we are handling the expired timers and
    set it to the next expiry value after we handled the timers under the
    base lock. While the expired timers are processed timer migration is
    blocked because the expiry time of the timer is always <= KTIME_MAX.
    
    Also remove the now useless clockevents_get_next_event() function.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit b0a9b5111abf60ef07eade834f480e89004c7920
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun Jan 25 11:31:36 2009 +0100

    hrtimer: prevent negative expiry value after clock_was_set()
    
    Impact: prevent false positive WARN_ON() in clockevents_program_event()
    
    clock_was_set() changes the base->offset of CLOCK_REALTIME and
    enforces the reprogramming of the clockevent device to expire timers
    which are based on CLOCK_REALTIME. If the clock change is large enough
    then the subtraction of the timer expiry value and base->offset can
    become negative which triggers the warning in
    clockevents_program_event().
    
    Check the subtraction result and set a negative value to 0.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 6626bff24578753808c8b5bd4f1619e14e980f0f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun Jan 25 11:31:36 2009 +0100

    hrtimer: prevent negative expiry value after clock_was_set()
    
    Impact: prevent false positive WARN_ON() in clockevents_program_event()
    
    clock_was_set() changes the base->offset of CLOCK_REALTIME and
    enforces the reprogramming of the clockevent device to expire timers
    which are based on CLOCK_REALTIME. If the clock change is large enough
    then the subtraction of the timer expiry value and base->offset can
    become negative which triggers the warning in
    clockevents_program_event().
    
    Check the subtraction result and set a negative value to 0.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit b020632e40c3ed5e8c0c066d022672907e8401cf
Author: Martin Schwidefsky <schwidefsky@de.ibm.com>
Date:   Thu Dec 25 13:38:36 2008 +0100

    [S390] introduce vdso on s390
    
    Add a vdso to speed up gettimeofday and clock_getres/clock_gettime for
    CLOCK_REALTIME/CLOCK_MONOTONIC.
    
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

commit 1acdac104668a0834cfa267de9946fac7764d486
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Nov 20 10:02:53 2008 -0800

    futex: make clock selectable for FUTEX_WAIT_BITSET
    
    FUTEX_WAIT_BITSET could be used instead of FUTEX_WAIT by setting the
    bit set to FUTEX_BITSET_MATCH_ANY, but FUTEX_WAIT uses CLOCK_REALTIME
    while FUTEX_WAIT_BITSET uses CLOCK_MONOTONIC.
    
    Add a flag to select CLOCK_REALTIME for FUTEX_WAIT_BITSET so glibc can
    replace the FUTEX_WAIT logic which needs to do gettimeofday() calls
    before and after the syscall to convert the absolute timeout to a
    relative timeout for FUTEX_WAIT.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ulrich Drepper <drepper@redhat.com>

commit 597bc5c00b666fe123abb0af64f6e86f7ab72a90
Author: Paul Mackerras <paulus@samba.org>
Date:   Mon Oct 27 23:56:03 2008 +0000

    powerpc: Improve resolution of VDSO clock_gettime
    
    Currently the clock_gettime implementation in the VDSO produces a
    result with microsecond resolution for the cases that are handled
    without a system call, i.e. CLOCK_REALTIME and CLOCK_MONOTONIC.  The
    nanoseconds field of the result is obtained by computing a
    microseconds value and multiplying by 1000.
    
    This changes the code in the VDSO to do the computation for
    clock_gettime with nanosecond resolution.  That means that the
    resolution of the result will ultimately depend on the timebase
    frequency.
    
    Because the timestamp in the VDSO datapage (stamp_xsec, the real time
    corresponding to the timebase count in tb_orig_stamp) is in units of
    2^-20 seconds, it doesn't have sufficient resolution for computing a
    result with nanosecond resolution.  Therefore this adds a copy of
    xtime to the VDSO datapage and updates it in update_gtod() along with
    the other time-related fields.
    
    Signed-off-by: Paul Mackerras <paulus@samba.org>

commit 6b1ef0e60d42f2fdaec26baee8327eb156347b4f
Author: Ulrich Drepper <drepper@redhat.com>
Date:   Wed Jul 23 21:29:39 2008 -0700

    flag parameters: NONBLOCK in timerfd_create
    
    This patch adds support for the TFD_NONBLOCK flag to timerfd_create.  The
    additional changes needed are minimal.
    
    The following test must be adjusted for architectures other than x86 and
    x86-64 and in case the syscall numbers changed.
    
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    #include <fcntl.h>
    #include <stdio.h>
    #include <time.h>
    #include <unistd.h>
    #include <sys/syscall.h>
    
    #ifndef __NR_timerfd_create
    # ifdef __x86_64__
    #  define __NR_timerfd_create 283
    # elif defined __i386__
    #  define __NR_timerfd_create 322
    # else
    #  error "need __NR_timerfd_create"
    # endif
    #endif
    
    #define TFD_NONBLOCK O_NONBLOCK
    
    int
    main (void)
    {
      int fd = syscall (__NR_timerfd_create, CLOCK_REALTIME, 0);
      if (fd == -1)
        {
          puts ("timerfd_create(0) failed");
          return 1;
        }
      int fl = fcntl (fd, F_GETFL);
      if (fl == -1)
        {
          puts ("fcntl failed");
          return 1;
        }
      if (fl & O_NONBLOCK)
        {
          puts ("timerfd_create(0) set non-blocking mode");
          return 1;
        }
      close (fd);
    
      fd = syscall (__NR_timerfd_create, CLOCK_REALTIME, TFD_NONBLOCK);
      if (fd == -1)
        {
          puts ("timerfd_create(TFD_NONBLOCK) failed");
          return 1;
        }
      fl = fcntl (fd, F_GETFL);
      if (fl == -1)
        {
          puts ("fcntl failed");
          return 1;
        }
      if ((fl & O_NONBLOCK) == 0)
        {
          puts ("timerfd_create(TFD_NONBLOCK) set non-blocking mode");
          return 1;
        }
      close (fd);
    
      puts ("OK");
    
      return 0;
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    
    Signed-off-by: Ulrich Drepper <drepper@redhat.com>
    Acked-by: Davide Libenzi <davidel@xmailserver.org>
    Cc: Michael Kerrisk <mtk.manpages@googlemail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit 11fcb6c14676023d0bd437841f5dcd670e7990a0
Author: Ulrich Drepper <drepper@redhat.com>
Date:   Wed Jul 23 21:29:26 2008 -0700

    flag parameters: timerfd_create
    
    The timerfd_create syscall already has a flags parameter.  It just is
    unused so far.  This patch changes this by introducing the TFD_CLOEXEC
    flag to set the close-on-exec flag for the returned file descriptor.
    
    A new name TFD_CLOEXEC is introduced which in this implementation must
    have the same value as O_CLOEXEC.
    
    The following test must be adjusted for architectures other than x86 and
    x86-64 and in case the syscall numbers changed.
    
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    #include <fcntl.h>
    #include <stdio.h>
    #include <time.h>
    #include <unistd.h>
    #include <sys/syscall.h>
    
    #ifndef __NR_timerfd_create
    # ifdef __x86_64__
    #  define __NR_timerfd_create 283
    # elif defined __i386__
    #  define __NR_timerfd_create 322
    # else
    #  error "need __NR_timerfd_create"
    # endif
    #endif
    
    #define TFD_CLOEXEC O_CLOEXEC
    
    int
    main (void)
    {
      int fd = syscall (__NR_timerfd_create, CLOCK_REALTIME, 0);
      if (fd == -1)
        {
          puts ("timerfd_create(0) failed");
          return 1;
        }
      int coe = fcntl (fd, F_GETFD);
      if (coe == -1)
        {
          puts ("fcntl failed");
          return 1;
        }
      if (coe & FD_CLOEXEC)
        {
          puts ("timerfd_create(0) set close-on-exec flag");
          return 1;
        }
      close (fd);
    
      fd = syscall (__NR_timerfd_create, CLOCK_REALTIME, TFD_CLOEXEC);
      if (fd == -1)
        {
          puts ("timerfd_create(TFD_CLOEXEC) failed");
          return 1;
        }
      coe = fcntl (fd, F_GETFD);
      if (coe == -1)
        {
          puts ("fcntl failed");
          return 1;
        }
      if ((coe & FD_CLOEXEC) == 0)
        {
          puts ("timerfd_create(TFD_CLOEXEC) set close-on-exec flag");
          return 1;
        }
      close (fd);
    
      puts ("OK");
    
      return 0;
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    
    Signed-off-by: Ulrich Drepper <drepper@redhat.com>
    Acked-by: Davide Libenzi <davidel@xmailserver.org>
    Cc: Michael Kerrisk <mtk.manpages@googlemail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit 4813a83f2665f7276f1e4eee9cffe45116cf3824
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Feb 20 01:04:56 2008 +0100

    hrtimer: catch expired CLOCK_REALTIME timers early
    
    commit 63070a79ba482c274bad10ac8c4b587a3e011f2c
    
    A CLOCK_REALTIME timer, which has an absolute expiry time less than
    the clock realtime offset calls with a negative delta into the clock
    events code and triggers the WARN_ON() there.
    
    This is a false positive and needs to be prevented. Check the result
    of timer->expires - timer->base->offset right away and return -ETIME
    right away.
    
    Thanks to Frans Pop, who reported the problem and tested the fixes.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Frans Pop <elendil@planet.nl>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit c24ce1d88781b4d2b8232967630abaa1c90724cf
Merge: f527cf405017 63070a79ba48
Author: Linus Torvalds <torvalds@woody.linux-foundation.org>
Date:   Thu Feb 14 21:27:52 2008 -0800

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/tglx/linux-2.6-hrt
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/tglx/linux-2.6-hrt:
      hrtimer: catch expired CLOCK_REALTIME timers early
      hrtimer: check relative timeouts for overflow

commit 63070a79ba482c274bad10ac8c4b587a3e011f2c
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Feb 14 00:58:36 2008 +0100

    hrtimer: catch expired CLOCK_REALTIME timers early
    
    A CLOCK_REALTIME timer, which has an absolute expiry time less than
    the clock realtime offset calls with a negative delta into the clock
    events code and triggers the WARN_ON() there.
    
    This is a false positive and needs to be prevented. Check the result
    of timer->expires - timer->base->offset right away and return -ETIME
    right away.
    
    Thanks to Frans Pop, who reported the problem and tested the fixes.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Frans Pop <elendil@planet.nl>

commit 4d672e7ac79b5ec5cdc90e450823441e20464691
Author: Davide Libenzi <davidel@xmailserver.org>
Date:   Mon Feb 4 22:27:26 2008 -0800

    timerfd: new timerfd API
    
    This is the new timerfd API as it is implemented by the following patch:
    
    int timerfd_create(int clockid, int flags);
    int timerfd_settime(int ufd, int flags,
                        const struct itimerspec *utmr,
                        struct itimerspec *otmr);
    int timerfd_gettime(int ufd, struct itimerspec *otmr);
    
    The timerfd_create() API creates an un-programmed timerfd fd.  The "clockid"
    parameter can be either CLOCK_MONOTONIC or CLOCK_REALTIME.
    
    The timerfd_settime() API give new settings by the timerfd fd, by optionally
    retrieving the previous expiration time (in case the "otmr" parameter is not
    NULL).
    
    The time value specified in "utmr" is absolute, if the TFD_TIMER_ABSTIME bit
    is set in the "flags" parameter.  Otherwise it's a relative time.
    
    The timerfd_gettime() API returns the next expiration time of the timer, or
    {0, 0} if the timerfd has not been set yet.
    
    Like the previous timerfd API implementation, read(2) and poll(2) are
    supported (with the same interface).  Here's a simple test program I used to
    exercise the new timerfd APIs:
    
    http://www.xmailserver.org/timerfd-test2.c
    
    [akpm@linux-foundation.org: coding-style cleanups]
    [akpm@linux-foundation.org: fix ia64 build]
    [akpm@linux-foundation.org: fix m68k build]
    [akpm@linux-foundation.org: fix mips build]
    [akpm@linux-foundation.org: fix alpha, arm, blackfin, cris, m68k, s390, sparc and sparc64 builds]
    [heiko.carstens@de.ibm.com: fix s390]
    [akpm@linux-foundation.org: fix powerpc build]
    [akpm@linux-foundation.org: fix sparc64 more]
    Signed-off-by: Davide Libenzi <davidel@xmailserver.org>
    Cc: Michael Kerrisk <mtk-manpages@gmx.net>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Davide Libenzi <davidel@xmailserver.org>
    Cc: Michael Kerrisk <mtk-manpages@gmx.net>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Signed-off-by: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Michael Kerrisk <mtk.manpages@gmail.com>
    Cc: Davide Libenzi <davidel@xmailserver.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit 46164b51f5bcc2bba19d66b46297bb97195e35dd
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jul 3 20:05:20 2007 +0200

    NTP: remove clock_was_set() call to prevent deadlock
    
    The clock_was_set() call in seconds_overflow() which happens only when
    leap seconds are inserted / deleted is wrong in two aspects:
    
    1. it results in a call to on_each_cpu() with interrupts disabled
    2. it is potential deadlock source vs. call_lock in smp_call_function()
    
    The only possible side effect of the removal might be, that an absolute
    CLOCK_REALTIME timer fires 1 second too late, in the rare case of leap
    second deletion and an absolute CLOCK_REALTIME timer which expires in
    the affected time frame. It will never fire too early.
    
    This was probably observed by the reporter of a June 30th -> July 1st
    hang: http://lkml.org/lkml/2007/7/3/
    
    A similar problem was observed by Dave Jones, who provided a screen shot
    with a lockdep back trace, which allowed to analyse the problem.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: john stultz <johnstul@us.ibm.com>
    Cc: Dave Jones <davej@redhat.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Vincent Fortier <Vincent.Fortier1@EC.GC.CA>
    Signed-off-by: Chris Wright <chrisw@sous-sol.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 2aae950b21e4bc789d1fc6668faf67e8748300b7
Author: Andi Kleen <ak@suse.de>
Date:   Sat Jul 21 17:10:01 2007 +0200

    x86_64: Add vDSO for x86-64 with gettimeofday/clock_gettime/getcpu
    
    This implements new vDSO for x86-64.  The concept is similar
    to the existing vDSOs on i386 and PPC.  x86-64 has had static
    vsyscalls before,  but these are not flexible enough anymore.
    
    A vDSO is a ELF shared library supplied by the kernel that is mapped into
    user address space.  The vDSO mapping is randomized for each process
    for security reasons.
    
    Doing this was needed for clock_gettime, because clock_gettime
    always needs a syscall fallback and having one at a fixed
    address would have made buffer overflow exploits too easy to write.
    
    The vdso can be disabled with vdso=0
    
    It currently includes a new gettimeofday implemention and optimized
    clock_gettime(). The gettimeofday implementation is slightly faster
    than the one in the old vsyscall.  clock_gettime is significantly faster
    than the syscall for CLOCK_MONOTONIC and CLOCK_REALTIME.
    
    The new calls are generally faster than the old vsyscall.
    
    Advantages over the old x86-64 vsyscalls:
    - Extensible
    - Randomized
    - Cleaner
    - Easier to virtualize (the old static address range previously causes
    overhead e.g. for Xen because it has to create special page tables for it)
    
    Weak points:
    - glibc support still to be written
    
    The VM interface is partly based on Ingo Molnar's i386 version.
    
    Includes compile fix from Joachim Deguara
    
    Signed-off-by: Andi Kleen <ak@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit 746976a301ac9c9aa10d7d42454f8d6cdad8ff2b
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jul 3 20:05:20 2007 +0200

    NTP: remove clock_was_set() call to prevent deadlock
    
    The clock_was_set() call in seconds_overflow() which happens only when
    leap seconds are inserted / deleted is wrong in two aspects:
    
    1. it results in a call to on_each_cpu() with interrupts disabled
    2. it is potential deadlock source vs. call_lock in smp_call_function()
    
    The only possible side effect of the removal might be, that an absolute
    CLOCK_REALTIME timer fires 1 second too late, in the rare case of leap
    second deletion and an absolute CLOCK_REALTIME timer which expires in
    the affected time frame. It will never fire too early.
    
    This was probably observed by the reporter of a June 30th -> July 1st
    hang: http://lkml.org/lkml/2007/7/3/103
    
    A similar problem was observed by Dave Jones, who provided a screen shot
    with a lockdep back trace, which allowed to analyse the problem.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit b215e283992899650c4271e7385c79e26fb9a88e
Author: Davide Libenzi <davidel@xmailserver.org>
Date:   Thu May 10 22:23:16 2007 -0700

    signal/timer/event: timerfd core
    
    This patch introduces a new system call for timers events delivered though
    file descriptors.  This allows timer event to be used with standard POSIX
    poll(2), select(2) and read(2).  As a consequence of supporting the Linux
    f_op->poll subsystem, they can be used with epoll(2) too.
    
    The system call is defined as:
    
    int timerfd(int ufd, int clockid, int flags, const struct itimerspec *utmr);
    
    The "ufd" parameter allows for re-use (re-programming) of an existing timerfd
    w/out going through the close/open cycle (same as signalfd).  If "ufd" is -1,
    s new file descriptor will be created, otherwise the existing "ufd" will be
    re-programmed.
    
    The "clockid" parameter is either CLOCK_MONOTONIC or CLOCK_REALTIME.  The time
    specified in the "utmr->it_value" parameter is the expiry time for the timer.
    
    If the TFD_TIMER_ABSTIME flag is set in "flags", this is an absolute time,
    otherwise it's a relative time.
    
    If the time specified in the "utmr->it_interval" is not zero (.tv_sec == 0,
    tv_nsec == 0), this is the period at which the following ticks should be
    generated.
    
    The "utmr->it_interval" should be set to zero if only one tick is requested.
    Setting the "utmr->it_value" to zero will disable the timer, or will create a
    timerfd without the timer enabled.
    
    The function returns the new (or same, in case "ufd" is a valid timerfd
    descriptor) file, or -1 in case of error.
    
    As stated before, the timerfd file descriptor supports poll(2), select(2) and
    epoll(2).  When a timer event happened on the timerfd, a POLLIN mask will be
    returned.
    
    The read(2) call can be used, and it will return a u32 variable holding the
    number of "ticks" that happened on the interface since the last call to
    read(2).  The read(2) call supportes the O_NONBLOCK flag too, and EAGAIN will
    be returned if no ticks happened.
    
    A quick test program, shows timerfd working correctly on my amd64 box:
    
    http://www.xmailserver.org/timerfd-test.c
    
    [akpm@linux-foundation.org: add sys_timerfd to sys_ni.c]
    Signed-off-by: Davide Libenzi <davidel@xmailserver.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit a7f290dad32ee34d931561b7943c858fe2aae503
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Fri Nov 11 21:15:21 2005 +1100

    [PATCH] powerpc: Merge vdso's and add vdso support to 32 bits kernel
    
    This patch moves the vdso's to arch/powerpc, adds support for the 32
    bits vdso to the 32 bits kernel, rename systemcfg (finally !), and adds
    some new (still untested) routines to both vdso's: clock_gettime() with
    support for CLOCK_REALTIME and CLOCK_MONOTONIC, clock_getres() (same
    clocks) and get_tbfreq() for glibc to retreive the timebase frequency.
    
    Tom,Steve: The implementation of get_tbfreq() I've done for 32 bits
    returns a long long (r3, r4) not a long. This is such that if we ever
    add support for >4Ghz timebases on ppc32, the userland interface won't
    have to change.
    
    I have tested gettimeofday() using some glibc patches in both ppc32 and
    ppc64 kernels using 32 bits userland (I haven't had a chance to test a
    64 bits userland yet, but the implementation didn't change and was
    tested earlier). I haven't tested yet the new functions.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Paul Mackerras <paulus@samba.org>
