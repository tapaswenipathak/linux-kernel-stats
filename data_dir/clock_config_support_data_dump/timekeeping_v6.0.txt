commit f3cb80804b8295323919e031281768ba3bf5f8da
Author: Randy Dunlap <rdunlap@infradead.org>
Date:   Mon Jan 2 19:28:49 2023 -0800

    time: Fix various kernel-doc problems
    
    Clean up kernel-doc complaints about function names and non-kernel-doc
    comments in kernel/time/. Fixes these warnings:
    
      kernel/time/time.c:479: warning: expecting prototype for set_normalized_timespec(). Prototype was for set_normalized_timespec64() instead
      kernel/time/time.c:553: warning: expecting prototype for msecs_to_jiffies(). Prototype was for __msecs_to_jiffies() instead
    
      kernel/time/timekeeping.c:1595: warning: contents before sections
      kernel/time/timekeeping.c:1705: warning: This comment starts with '/**', but isn't a kernel-doc comment.
       * We have three kinds of time sources to use for sleep time
      kernel/time/timekeeping.c:1726: warning: This comment starts with '/**', but isn't a kernel-doc comment.
       * 1) can be determined whether to use or not only when doing
    
      kernel/time/tick-oneshot.c:21: warning: missing initial short description on line:
       * tick_program_event
      kernel/time/tick-oneshot.c:107: warning: expecting prototype for tick_check_oneshot_mode(). Prototype was for tick_oneshot_mode_active() instead
    
    Signed-off-by: Randy Dunlap <rdunlap@infradead.org>
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Link: https://lore.kernel.org/r/20230103032849.12723-1-rdunlap@infradead.org

commit 0a1d4434db5f86c50018fe0aab299ac97dc15b76
Merge: 79ad89123c25 18a207849218
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Dec 12 12:52:02 2022 -0800

    Merge tag 'timers-core-2022-12-10' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer updates from Thomas Gleixner:
     "Updates for timers, timekeeping and drivers:
    
      Core:
    
       - The timer_shutdown[_sync]() infrastructure:
    
         Tearing down timers can be tedious when there are circular
         dependencies to other things which need to be torn down. A prime
         example is timer and workqueue where the timer schedules work and
         the work arms the timer.
    
         What needs to prevented is that pending work which is drained via
         destroy_workqueue() does not rearm the previously shutdown timer.
         Nothing in that shutdown sequence relies on the timer being
         functional.
    
         The conclusion was that the semantics of timer_shutdown_sync()
         should be:
            - timer is not enqueued
            - timer callback is not running
            - timer cannot be rearmed
    
         Preventing the rearming of shutdown timers is done by discarding
         rearm attempts silently.
    
         A warning for the case that a rearm attempt of a shutdown timer is
         detected would not be really helpful because it's entirely unclear
         how it should be acted upon. The only way to address such a case is
         to add 'if (in_shutdown)' conditionals all over the place. This is
         error prone and in most cases of teardown not required all.
    
       - The real fix for the bluetooth HCI teardown based on
         timer_shutdown_sync().
    
         A larger scale conversion to timer_shutdown_sync() is work in
         progress.
    
       - Consolidation of VDSO time namespace helper functions
    
       - Small fixes for timer and timerqueue
    
      Drivers:
    
       - Prevent integer overflow on the XGene-1 TVAL register which causes
         an never ending interrupt storm.
    
       - The usual set of new device tree bindings
    
       - Small fixes and improvements all over the place"
    
    * tag 'timers-core-2022-12-10' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (34 commits)
      dt-bindings: timer: renesas,cmt: Add r8a779g0 CMT support
      dt-bindings: timer: renesas,tmu: Add r8a779g0 support
      clocksource/drivers/arm_arch_timer: Use kstrtobool() instead of strtobool()
      clocksource/drivers/timer-ti-dm: Fix missing clk_disable_unprepare in dmtimer_systimer_init_clock()
      clocksource/drivers/timer-ti-dm: Clear settings on probe and free
      clocksource/drivers/timer-ti-dm: Make timer_get_irq static
      clocksource/drivers/timer-ti-dm: Fix warning for omap_timer_match
      clocksource/drivers/arm_arch_timer: Fix XGene-1 TVAL register math error
      clocksource/drivers/timer-npcm7xx: Enable timer 1 clock before use
      dt-bindings: timer: nuvoton,npcm7xx-timer: Allow specifying all clocks
      dt-bindings: timer: rockchip: Add rockchip,rk3128-timer
      clockevents: Repair kernel-doc for clockevent_delta2ns()
      clocksource/drivers/ingenic-ost: Define pm functions properly in platform_driver struct
      clocksource/drivers/sh_cmt: Access registers according to spec
      vdso/timens: Refactor copy-pasted find_timens_vvar_page() helper into one copy
      Bluetooth: hci_qca: Fix the teardown problem for real
      timers: Update the documentation to reflect on the new timer_shutdown() API
      timers: Provide timer_shutdown[_sync]()
      timers: Add shutdown mechanism to the internal functions
      timers: Split [try_to_]del_timer[_sync]() to prepare for shutdown mode
      ...

commit e3e2d74678e9ac2af4158ad715dce7f445122f75
Author: Jonathan Corbet <corbet@lwn.net>
Date:   Mon Oct 31 08:21:39 2022 -0600

    Revert "docs/zh_CN: core-api: Add timekeeping Chinese translation"
    
    This reverts commit d24c911bd031a299de39863f67ae7290d450d56e.
    
    This translation added a bunch of duplicate function definitions, leading
    to a lot of warnings like:
    
      /Documentation/core-api/timekeeping.rst:16: WARNING: Duplicate C declaration, also defined at translations/zh_CN/core-api/timekeeping:26.
      Declaration is '.. c:function:: ktime_t ktime_get( void )'.
    
    We need to come up with a proper way to translate documents with
    :c:function declarations in them.
    
    Signed-off-by: Jonathan Corbet <corbet@lwn.net>

commit d24c911bd031a299de39863f67ae7290d450d56e
Author: Binbin Zhou <zhoubinbin@loongson.cn>
Date:   Fri Oct 21 09:58:08 2022 +0800

    docs/zh_CN: core-api: Add timekeeping Chinese translation
    
    Translate core-api/timekeeping.rst into Chinese.
    
    Last English version used:
    
    commit 3dc6ffae2da2 ("timekeeping: Introduce fast accessor to clock tai").
    
    Signed-off-by: Binbin Zhou <zhoubinbin@loongson.cn>
    Reviewed-by: Wu XiangCheng <bobwxc@email.cn>
    Link: https://lore.kernel.org/r/8d15ff60aaadd53065b3bc2da7d53a520cf01c53.1666171735.git.zhoubinbin@loongson.cn
    Signed-off-by: Jonathan Corbet <corbet@lwn.net>

commit 0a2abbfd8586d396a8581ebf9b96fd5746f08b14
Author: Rasmus Villemoes <linux@rasmusvillemoes.dk>
Date:   Wed Sep 21 13:46:22 2022 +0200

    rtc: isl12022: drop redundant write to HR register
    
    There's nothing in the data sheet that says writing to one of the time
    keeping registers is necessary to start the RTC. It does so at the
    stop condition of the i2c transfer setting the WRTC bit:
    
      Upon initialization or power-up, the WRTC must be set to "1" to
      enable the RTC. Upon the completion of a valid write (STOP), the RTC
      starts counting.
    
    Moreover, even if such a write to one of the timekeeping registers was
    necessary, that's exactly what we do anyway just below when we
    actually write the given struct rtc_time to the device.
    
    Signed-off-by: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Link: https://lore.kernel.org/r/20220921114624.3250848-8-linux@rasmusvillemoes.dk
    Signed-off-by: Alexandre Belloni <alexandre.belloni@bootlin.com>

commit 8adc0486f3c85e3c1e40c1ce6884317a17c380d3
Merge: 52abb27abfff a890d1c657ec
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Oct 10 10:41:21 2022 -0700

    Merge tag 'random-6.1-rc1-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/crng/random
    
    Pull random number generator updates from Jason Donenfeld:
    
     - Huawei reported that when they updated their kernel from 4.4 to
       something much newer, some userspace code they had broke, the culprit
       being the accidental removal of O_NONBLOCK from /dev/random way back
       in 5.6. It's been gone for over 2 years now and this is the first
       we've heard of it, but userspace breakage is userspace breakage, so
       O_NONBLOCK is now back.
    
     - Use randomness from hardware RNGs much more often during early boot,
       at the same interval that crng reseeds are done, from Dominik.
    
     - A semantic change in hardware RNG throttling, so that the hwrng
       framework can properly feed random.c with randomness from hardware
       RNGs that aren't specifically marked as creditable.
    
       A related patch coming to you via Herbert's hwrng tree depends on
       this one, not to compile, but just to function properly, so you may
       want to merge this PULL before that one.
    
     - A fix to clamp credited bits from the interrupts pool to the size of
       the pool sample. This is mainly just a theoretical fix, as it'd be
       pretty hard to exceed it in practice.
    
     - Oracle reported that InfiniBand TCP latency regressed by around
       10-15% after a change a few cycles ago made at the request of the RT
       folks, in which we hoisted a somewhat rare operation (1 in 1024
       times) out of the hard IRQ handler and into a workqueue, a pretty
       common and boring pattern.
    
       It turns out, though, that scheduling a worker from there has
       overhead of its own, whereas scheduling a timer on that same CPU for
       the next jiffy amortizes better and doesn't incur the same overhead.
    
       I also eliminated a cache miss by moving the work_struct (and
       subsequently, the timer_list) to below a critical cache line, so that
       the more critical members that are accessed on every hard IRQ aren't
       split between two cache lines.
    
     - The boot-time initialization of the RNG has been split into two
       approximate phases: what we can accomplish before timekeeping is
       possible and what we can accomplish after.
    
       This winds up being useful so that we can use RDRAND to seed the RNG
       before CONFIG_SLAB_FREELIST_RANDOM=y systems initialize slabs, in
       addition to other early uses of randomness. The effect is that
       systems with RDRAND (or a bootloader seed) will never see any
       warnings at all when setting CONFIG_WARN_ALL_UNSEEDED_RANDOM=y. And
       kfence benefits from getting a better seed of its own.
    
     - Small systems without much entropy sometimes wind up putting some
       truncated serial number read from flash into hostname, so contribute
       utsname changes to the RNG, without crediting.
    
     - Add smaller batches to serve requests for smaller integers, and make
       use of them when people ask for random numbers bounded by a given
       compile-time constant. This has positive effects all over the tree,
       most notably in networking and kfence.
    
     - The original jitter algorithm intended (I believe) to schedule the
       timer for the next jiffy, not the next-next jiffy, yet it used
       mod_timer(jiffies + 1), which will fire on the next-next jiffy,
       instead of what I believe was intended, mod_timer(jiffies), which
       will fire on the next jiffy. So fix that.
    
     - Fix a comment typo, from William.
    
    * tag 'random-6.1-rc1-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/crng/random:
      random: clear new batches when bringing new CPUs online
      random: fix typos in get_random_bytes() comment
      random: schedule jitter credit for next jiffy, not in two jiffies
      prandom: make use of smaller types in prandom_u32_max
      random: add 8-bit and 16-bit batches
      utsname: contribute changes to RNG
      random: use init_utsname() instead of utsname()
      kfence: use better stack hash seed
      random: split initialization into early step and later step
      random: use expired timer rather than wq for mixing fast pool
      random: avoid reading two cache lines on irq randomness
      random: clamp credited irq bits to maximum mixed
      random: throttle hwrng writes if no entropy is credited
      random: use hwgenerator randomness more frequently at early boot
      random: restore O_NONBLOCK support

commit 55be6084c8e0e0ada9278c2ab60b7a584378efda
Merge: 7f6dcffb44ad 6cb5ce13357d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Oct 10 10:16:00 2022 -0700

    Merge tag 'timers-core-2022-10-05' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer updates from Thomas Gleixner:
     "A boring time, timekeeping, timers update:
    
       - No core code changes
    
       - No new clocksource/event driver
    
       - Cleanup of the TI DM clocksource/event driver
    
       - The usual set of device tree binding updates
    
       - Small improvement, fixes and cleanups all over the place"
    
    * tag 'timers-core-2022-10-05' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (22 commits)
      clocksource/drivers/arm_arch_timer: Fix CNTPCT_LO and CNTVCT_LO value
      clocksource/drivers/imx-sysctr: handle nxp,no-divider property
      dt-bindings: timer: nxp,sysctr-timer: add nxp,no-divider property
      clocksource/drivers/timer-ti-dm: Get clock in probe with devm_clk_get()
      clocksource/drivers/timer-ti-dm: Add flag to detect omap1
      clocksource/drivers/timer-ti-dm: Move struct omap_dm_timer fields to driver
      clocksource/drivers/timer-ti-dm: Use runtime PM directly and check errors
      clocksource/drivers/timer-ti-dm: Move private defines to the driver
      clocksource/drivers/timer-ti-dm: Simplify register access further
      clocksource/drivers/timer-ti-dm: Simplify register writes with dmtimer_write()
      clocksource/drivers/timer-ti-dm: Simplify register reads with dmtimer_read()
      clocksource/drivers/timer-ti-dm: Drop unused functions
      clocksource/drivers/timer-gxp: Add missing error handling in gxp_timer_probe
      clocksource/drivers/arm_arch_timer: Fix handling of ARM erratum 858921
      clocksource/drivers/exynos_mct: Enable building on ARTPEC
      clocksource/drivers/exynos_mct: Support local-timers property
      clocksource/drivers/exynos_mct: Support frc-shared property
      dt-bindings: timer: exynos4210-mct: Add ARTPEC-8 MCT support
      clocksource/drivers/sun4i: Add definition of clear interrupt
      clocksource/drivers/renesas-ostm: Add support for RZ/V2L SoC
      ...

commit 3339914a5832cffdecd578931b3db20d3deba5f6
Merge: bf7676251b49 81a71f51b89e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Oct 4 09:06:35 2022 -0700

    Merge tag 'x86_platform_for_v6.1_rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull x86 platform update from Borislav Petkov:
     "A single x86/platform improvement when the kernel is running as an
      ACRN guest:
    
       - Get TSC and CPU frequency from CPUID leaf 0x40000010 when the
         kernel is running as a guest on the ACRN hypervisor"
    
    * tag 'x86_platform_for_v6.1_rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      x86/acrn: Set up timekeeping

commit f62384995e4cb7703e5295779c44135c5311770d
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Mon Sep 26 17:43:14 2022 +0200

    random: split initialization into early step and later step
    
    The full RNG initialization relies on some timestamps, made possible
    with initialization functions like time_init() and timekeeping_init().
    However, these are only available rather late in initialization.
    Meanwhile, other things, such as memory allocator functions, make use of
    the RNG much earlier.
    
    So split RNG initialization into two phases. We can provide arch
    randomness very early on, and then later, after timekeeping and such are
    available, initialize the rest.
    
    This ensures that, for example, slabs are properly randomized if RDRAND
    is available. Without this, CONFIG_SLAB_FREELIST_RANDOM=y loses a degree
    of its security, because its random seed is potentially deterministic,
    since it hasn't yet incorporated RDRAND. It also makes it possible to
    use a better seed in kfence, which currently relies on only the cycle
    counter.
    
    Another positive consequence is that on systems with RDRAND, running
    with CONFIG_WARN_ALL_UNSEEDED_RANDOM=y results in no warnings at all.
    
    One subtle side effect of this change is that on systems with no RDRAND,
    RDTSC is now only queried by random_init() once, committing the moment
    of the function call, instead of multiple times as before. This is
    intentional, as the multiple RDTSCs in a loop before weren't
    accomplishing very much, with jitter being better provided by
    try_to_generate_entropy(). Plus, filling blocks with RDTSC is still
    being done in extract_entropy(), which is necessarily called before
    random bytes are served anyway.
    
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Reviewed-by: Dominik Brodowski <linux@dominikbrodowski.net>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

commit 8b08d4f97233d8e58fff2fd9d5f86397a49733c5
Author: Michael Ellerman <mpe@ellerman.id.au>
Date:   Tue Aug 23 21:59:52 2022 +1000

    powerpc/rtas: Fix RTAS MSR[HV] handling for Cell
    
    commit 91926d8b7e71aaf5f84f0cf208fc5a8b7a761050 upstream.
    
    The semi-recent changes to MSR handling when entering RTAS (firmware)
    cause crashes on IBM Cell machines. An example trace:
    
      kernel tried to execute user page (2fff01a8) - exploit attempt? (uid: 0)
      BUG: Unable to handle kernel instruction fetch
      Faulting instruction address: 0x2fff01a8
      Oops: Kernel access of bad area, sig: 11 [#1]
      BE PAGE_SIZE=64K MMU=Hash SMP NR_CPUS=4 NUMA Cell
      Modules linked in:
      CPU: 0 PID: 0 Comm: swapper/0 Tainted: G        W          6.0.0-rc2-00433-gede0a8d3307a #207
      NIP:  000000002fff01a8 LR: 0000000000032608 CTR: 0000000000000000
      REGS: c0000000015236b0 TRAP: 0400   Tainted: G        W           (6.0.0-rc2-00433-gede0a8d3307a)
      MSR:  0000000008001002 <ME,RI>  CR: 00000000  XER: 20000000
      ...
      NIP 0x2fff01a8
      LR  0x32608
      Call Trace:
        0xc00000000143c5f8 (unreliable)
        .rtas_call+0x224/0x320
        .rtas_get_boot_time+0x70/0x150
        .read_persistent_clock64+0x114/0x140
        .read_persistent_wall_and_boot_offset+0x24/0x80
        .timekeeping_init+0x40/0x29c
        .start_kernel+0x674/0x8f0
        start_here_common+0x1c/0x50
    
    Unlike PAPR platforms where RTAS is only used in guests, on the IBM Cell
    machines Linux runs with MSR[HV] set but also uses RTAS, provided by
    SLOF.
    
    Fix it by copying the MSR[HV] bit from the MSR value we've just read
    using mfmsr into the value used for RTAS.
    
    It seems like we could also fix it using an #ifdef CELL to set MSR[HV],
    but that doesn't work because it's possible to build a single kernel
    image that runs on both Cell native and pseries.
    
    Fixes: b6b1c3ce06ca ("powerpc/rtas: Keep MSR[RI] set when calling RTAS")
    Cc: stable@vger.kernel.org # v5.19+
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Reviewed-by: Jordan Niethe <jniethe5@gmail.com>
    Link: https://lore.kernel.org/r/20220823115952.1203106-2-mpe@ellerman.id.au
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 91926d8b7e71aaf5f84f0cf208fc5a8b7a761050
Author: Michael Ellerman <mpe@ellerman.id.au>
Date:   Tue Aug 23 21:59:52 2022 +1000

    powerpc/rtas: Fix RTAS MSR[HV] handling for Cell
    
    The semi-recent changes to MSR handling when entering RTAS (firmware)
    cause crashes on IBM Cell machines. An example trace:
    
      kernel tried to execute user page (2fff01a8) - exploit attempt? (uid: 0)
      BUG: Unable to handle kernel instruction fetch
      Faulting instruction address: 0x2fff01a8
      Oops: Kernel access of bad area, sig: 11 [#1]
      BE PAGE_SIZE=64K MMU=Hash SMP NR_CPUS=4 NUMA Cell
      Modules linked in:
      CPU: 0 PID: 0 Comm: swapper/0 Tainted: G        W          6.0.0-rc2-00433-gede0a8d3307a #207
      NIP:  000000002fff01a8 LR: 0000000000032608 CTR: 0000000000000000
      REGS: c0000000015236b0 TRAP: 0400   Tainted: G        W           (6.0.0-rc2-00433-gede0a8d3307a)
      MSR:  0000000008001002 <ME,RI>  CR: 00000000  XER: 20000000
      ...
      NIP 0x2fff01a8
      LR  0x32608
      Call Trace:
        0xc00000000143c5f8 (unreliable)
        .rtas_call+0x224/0x320
        .rtas_get_boot_time+0x70/0x150
        .read_persistent_clock64+0x114/0x140
        .read_persistent_wall_and_boot_offset+0x24/0x80
        .timekeeping_init+0x40/0x29c
        .start_kernel+0x674/0x8f0
        start_here_common+0x1c/0x50
    
    Unlike PAPR platforms where RTAS is only used in guests, on the IBM Cell
    machines Linux runs with MSR[HV] set but also uses RTAS, provided by
    SLOF.
    
    Fix it by copying the MSR[HV] bit from the MSR value we've just read
    using mfmsr into the value used for RTAS.
    
    It seems like we could also fix it using an #ifdef CELL to set MSR[HV],
    but that doesn't work because it's possible to build a single kernel
    image that runs on both Cell native and pseries.
    
    Fixes: b6b1c3ce06ca ("powerpc/rtas: Keep MSR[RI] set when calling RTAS")
    Cc: stable@vger.kernel.org # v5.19+
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Reviewed-by: Jordan Niethe <jniethe5@gmail.com>
    Link: https://lore.kernel.org/r/20220823115952.1203106-2-mpe@ellerman.id.au

commit 7c77d1f9ba1137ece88223a0d49e3cb6157f89f1
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sun Jul 17 23:53:34 2022 +0200

    timekeeping: contribute wall clock to rng on time change
    
    commit b8ac29b40183a6038919768b5d189c9bd91ce9b4 upstream.
    
    The rng's random_init() function contributes the real time to the rng at
    boot time, so that events can at least start in relation to something
    particular in the real world. But this clock might not yet be set that
    point in boot, so nothing is contributed. In addition, the relation
    between minor clock changes from, say, NTP, and the cycle counter is
    potentially useful entropic data.
    
    This commit addresses this by mixing in a time stamp on calls to
    settimeofday and adjtimex. No entropy is credited in doing so, so it
    doesn't make initialization faster, but it is still useful input to
    have.
    
    Fixes: 1da177e4c3f4 ("Linux-2.6.12-rc2")
    Cc: stable@vger.kernel.org
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Eric Biggers <ebiggers@google.com>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit c6cf21d8d5209be883c835ebc883b5566483bfca
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sun Jul 17 23:53:34 2022 +0200

    timekeeping: contribute wall clock to rng on time change
    
    [ Upstream commit b8ac29b40183a6038919768b5d189c9bd91ce9b4 ]
    
    The rng's random_init() function contributes the real time to the rng at
    boot time, so that events can at least start in relation to something
    particular in the real world. But this clock might not yet be set that
    point in boot, so nothing is contributed. In addition, the relation
    between minor clock changes from, say, NTP, and the cycle counter is
    potentially useful entropic data.
    
    This commit addresses this by mixing in a time stamp on calls to
    settimeofday and adjtimex. No entropy is credited in doing so, so it
    doesn't make initialization faster, but it is still useful input to
    have.
    
    Fixes: 1da177e4c3f4 ("Linux-2.6.12-rc2")
    Cc: stable@vger.kernel.org
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Eric Biggers <ebiggers@google.com>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 141c2785d940c88998d5b704bbf2e2c72b4f9cf0
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sun Jul 17 23:53:34 2022 +0200

    timekeeping: contribute wall clock to rng on time change
    
    [ Upstream commit b8ac29b40183a6038919768b5d189c9bd91ce9b4 ]
    
    The rng's random_init() function contributes the real time to the rng at
    boot time, so that events can at least start in relation to something
    particular in the real world. But this clock might not yet be set that
    point in boot, so nothing is contributed. In addition, the relation
    between minor clock changes from, say, NTP, and the cycle counter is
    potentially useful entropic data.
    
    This commit addresses this by mixing in a time stamp on calls to
    settimeofday and adjtimex. No entropy is credited in doing so, so it
    doesn't make initialization faster, but it is still useful input to
    have.
    
    Fixes: 1da177e4c3f4 ("Linux-2.6.12-rc2")
    Cc: stable@vger.kernel.org
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Eric Biggers <ebiggers@google.com>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 2d74ca7d3663d185377535c6257f14bce7d041a3
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sun Jul 17 23:53:34 2022 +0200

    timekeeping: contribute wall clock to rng on time change
    
    [ Upstream commit b8ac29b40183a6038919768b5d189c9bd91ce9b4 ]
    
    The rng's random_init() function contributes the real time to the rng at
    boot time, so that events can at least start in relation to something
    particular in the real world. But this clock might not yet be set that
    point in boot, so nothing is contributed. In addition, the relation
    between minor clock changes from, say, NTP, and the cycle counter is
    potentially useful entropic data.
    
    This commit addresses this by mixing in a time stamp on calls to
    settimeofday and adjtimex. No entropy is credited in doing so, so it
    doesn't make initialization faster, but it is still useful input to
    have.
    
    Fixes: 1da177e4c3f4 ("Linux-2.6.12-rc2")
    Cc: stable@vger.kernel.org
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Eric Biggers <ebiggers@google.com>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 96ba981f09a9ebe683ab629a1205fec120e77ce9
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sun Jul 17 23:53:34 2022 +0200

    timekeeping: contribute wall clock to rng on time change
    
    [ Upstream commit b8ac29b40183a6038919768b5d189c9bd91ce9b4 ]
    
    The rng's random_init() function contributes the real time to the rng at
    boot time, so that events can at least start in relation to something
    particular in the real world. But this clock might not yet be set that
    point in boot, so nothing is contributed. In addition, the relation
    between minor clock changes from, say, NTP, and the cycle counter is
    potentially useful entropic data.
    
    This commit addresses this by mixing in a time stamp on calls to
    settimeofday and adjtimex. No entropy is credited in doing so, so it
    doesn't make initialization faster, but it is still useful input to
    have.
    
    Fixes: 1da177e4c3f4 ("Linux-2.6.12-rc2")
    Cc: stable@vger.kernel.org
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Eric Biggers <ebiggers@google.com>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit fc04b2ccf0edc49e53d2e1251d122e40285233e6
Author: Mateusz Jończyk <mat.jonczyk@o2.pl>
Date:   Sat Aug 13 15:10:33 2022 +0200

    x86/rtc: Rewrite & simplify mach_get_cmos_time() by deleting duplicated functionality
    
    There are functions in drivers/rtc/rtc-mc146818-lib.c that handle
    reading from / writing to the CMOS RTC clock. mach_get_cmos_time() in
    arch/x86/kernel/rtc.c did not use them and was mostly a duplicate of
    mc146818_get_time(). Modify mach_get_cmos_time() to use
    mc146818_get_time() and remove the duplicated functionality.
    
    mach_get_cmos_time() used a different algorithm than
    mc146818_get_time(), but these functions are equivalent. The major
    differences are:
    
    - mc146818_get_time() is better refined and handles various edge
      conditions,
    
    - when the UIP ("Update in progress") bit of the RTC is set,
      mach_get_cmos_time() was busy waiting with cpu_relax() while
      mc146818_get_time() is using mdelay(1) in every loop iteration.
      (However, there is my commit merged for Linux 5.20 / 6.0 to decrease
      this period to 100us:
        commit d2a632a8a117 ("rtc: mc146818-lib: reduce RTC_UIP polling period")
      ),
    
    - mach_get_cmos_time() assumed that the RTC year is >= 2000, which
      may not be true on some old boxes with a dead battery,
    
    - mach_get_cmos_time() was holding the rtc_lock for a long time
      and could hang if the RTC is broken or not present.
    
    The RTC writing counterpart, mach_set_rtc_mmss() is already using
    mc146818_get_time() from drivers/rtc. This was done in
            commit 3195ef59cb42 ("x86: Do full rtc synchronization with ntp")
    It appears that mach_get_cmos_time() was simply forgotten.
    
    mach_get_cmos_time() is really used only in read_persistent_clock64(),
    which is called only in a few places in kernel/time/timekeeping.c .
    
    [ mingo: These changes are not supposed to change behavior, but they are
             not identity transformations either, as mc146818_get_time() is a
             better but different implementation of the same logic - so
             regressions are possible in principle. ]
    
    Signed-off-by: Mateusz Jończyk <mat.jonczyk@o2.pl>
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Acked-by: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Link: https://lore.kernel.org/r/20220813131034.768527-1-mat.jonczyk@o2.pl

commit c8996c98f703b09afe77a1d247dae691c9849dc1
Author: Jesper Dangaard Brouer <brouer@redhat.com>
Date:   Tue Aug 9 08:08:02 2022 +0200

    bpf: Add BPF-helper for accessing CLOCK_TAI
    
    Commit 3dc6ffae2da2 ("timekeeping: Introduce fast accessor to clock tai")
    introduced a fast and NMI-safe accessor for CLOCK_TAI. Especially in time
    sensitive networks (TSN), where all nodes are synchronized by Precision Time
    Protocol (PTP), it's helpful to have the possibility to generate timestamps
    based on CLOCK_TAI instead of CLOCK_MONOTONIC. With a BPF helper for TAI in
    place, it becomes very convenient to correlate activity across different
    machines in the network.
    
    Use cases for such a BPF helper include functionalities such as Tx launch
    time (e.g. ETF and TAPRIO Qdiscs) and timestamping.
    
    Note: CLOCK_TAI is nothing new per se, only the NMI-safe variant of it is.
    
    Signed-off-by: Jesper Dangaard Brouer <brouer@redhat.com>
    [Kurt: Wrote changelog and renamed helper]
    Signed-off-by: Kurt Kanzenbach <kurt@linutronix.de>
    Link: https://lore.kernel.org/r/20220809060803.5773-2-kurt@linutronix.de
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>

commit 81a71f51b89e84f39df2a3b1daf4274ae6b7b194
Author: Fei Li <fei1.li@intel.com>
Date:   Thu Aug 4 13:59:03 2022 +0800

    x86/acrn: Set up timekeeping
    
    ACRN Hypervisor reports timing information via CPUID leaf 0x40000010.
    Get the TSC and CPU frequency via CPUID leaf 0x40000010 and set the
    kernel values accordingly.
    
    Signed-off-by: Fei Li <fei1.li@intel.com>
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Reviewed-by: Conghui <conghui.chen@intel.com>
    Link: https://lore.kernel.org/r/20220804055903.365211-1-fei1.li@intel.com

commit a0b09f2d6f30723e1008bd9ddb504e302e329f81
Merge: 569bede0cff5 7f637be4d460
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Aug 2 17:31:35 2022 -0700

    Merge tag 'random-6.0-rc1-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/crng/random
    
    Pull random number generator updates from Jason Donenfeld:
     "Though there's been a decent amount of RNG-related development during
      this last cycle, not all of it is coming through this tree, as this
      cycle saw a shift toward tackling early boot time seeding issues,
      which took place in other trees as well.
    
      Here's a summary of the various patches:
    
       - The CONFIG_ARCH_RANDOM .config option and the "nordrand" boot
         option have been removed, as they overlapped with the more widely
         supported and more sensible options, CONFIG_RANDOM_TRUST_CPU and
         "random.trust_cpu". This change allowed simplifying a bit of arch
         code.
    
       - x86's RDRAND boot time test has been made a bit more robust, with
         RDRAND disabled if it's clearly producing bogus results. This would
         be a tip.git commit, technically, but I took it through random.git
         to avoid a large merge conflict.
    
       - The RNG has long since mixed in a timestamp very early in boot, on
         the premise that a computer that does the same things, but does so
         starting at different points in wall time, could be made to still
         produce a different RNG state. Unfortunately, the clock isn't set
         early in boot on all systems, so now we mix in that timestamp when
         the time is actually set.
    
       - User Mode Linux now uses the host OS's getrandom() syscall to
         generate a bootloader RNG seed and later on treats getrandom() as
         the platform's RDRAND-like faculty.
    
       - The arch_get_random_{seed_,}_long() family of functions is now
         arch_get_random_{seed_,}_longs(), which enables certain platforms,
         such as s390, to exploit considerable performance advantages from
         requesting multiple CPU random numbers at once, while at the same
         time compiling down to the same code as before on platforms like
         x86.
    
       - A small cleanup changing a cmpxchg() into a try_cmpxchg(), from
         Uros.
    
       - A comment spelling fix"
    
    More info about other random number changes that come in through various
    architecture trees in the full commentary in the pull request:
    
      https://lore.kernel.org/all/20220731232428.2219258-1-Jason@zx2c4.com/
    
    * tag 'random-6.0-rc1-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/crng/random:
      random: correct spelling of "overwrites"
      random: handle archrandom with multiple longs
      um: seed rng using host OS rng
      random: use try_cmpxchg in _credit_init_bits
      timekeeping: contribute wall clock to rng on time change
      x86/rdrand: Remove "nordrand" flag in favor of "random.trust_cpu"
      random: remove CONFIG_ARCH_RANDOM

commit dfea84827f7eb49ca41d837d92ac1cbd5353a742
Merge: 63e6053add5a cceeeb6a6d02
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Aug 1 12:37:54 2022 -0700

    Merge tag 'timers-core-2022-08-01' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer updates from Thomas Gleixner:
     "Timers, timekeeping and related drivers update:
    
      Core:
    
       - Make wait_event_hrtimeout() aware of RT/DL tasks
    
      New drivers:
    
       - R-Car Gen4 timer
    
       - Tegra186 timer
    
       - Mediatek MT6795 CPUXGPT timer
    
      Updates:
    
       - Rework suspend/resume handling in timer drivers so it
         takes inactive clocks into account.
    
       - The usual device tree compatible add ons
    
       - Small fixed and cleanups all over the place"
    
    * tag 'timers-core-2022-08-01' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (24 commits)
      wait: Fix __wait_event_hrtimeout for RT/DL tasks
      clocksource/drivers/sun5i: Remove unnecessary (void*) conversions
      dt-bindings: timer: allwinner,sun4i-a10-timer: Add D1 compatible
      dt-bindings: timer: ingenic,tcu: use absolute path to other schema
      clocksource/drivers/sun4i: Remove unnecessary (void*) conversions
      dt-bindings: timer: renesas,cmt: Fix R-Car Gen4 fall-out
      clocksource/drivers/tegra186: Put Kconfig option 'tristate' to 'bool'
      clocksource/drivers/timer-ti-dm: Make driver selection bool for TI K3
      clocksource/drivers/timer-ti-dm: Add compatible for am6 SoCs
      clocksource/drivers/timer-ti-dm: Make timer selectable for ARCH_K3
      clocksource/drivers/timer-ti-dm: Move inline functions to driver for am6
      clocksource/drivers/sh_cmt: Add R-Car Gen4 support
      dt-bindings: timer: renesas,cmt: R-Car V3U is R-Car Gen4
      dt-bindings: timer: renesas,cmt: Add r8a779f0 and generic Gen4 CMT support
      clocksource/drivers/timer-microchip-pit64b: Fix compilation warnings
      clocksource/drivers/timer-microchip-pit64b: Use mchp_pit64b_{suspend, resume}
      clocksource/drivers/timer-microchip-pit64b: Remove suspend/resume ops for ce
      thermal/drivers/rcar_gen3_thermal: Add r8a779f0 support
      clocksource/drivers/timer-mediatek: Implement CPUXGPT timers
      dt-bindings: timer: mediatek: Add CPUX System Timer and MT6795 compatible
      ...

commit b8ac29b40183a6038919768b5d189c9bd91ce9b4
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sun Jul 17 23:53:34 2022 +0200

    timekeeping: contribute wall clock to rng on time change
    
    The rng's random_init() function contributes the real time to the rng at
    boot time, so that events can at least start in relation to something
    particular in the real world. But this clock might not yet be set that
    point in boot, so nothing is contributed. In addition, the relation
    between minor clock changes from, say, NTP, and the cycle counter is
    potentially useful entropic data.
    
    This commit addresses this by mixing in a time stamp on calls to
    settimeofday and adjtimex. No entropy is credited in doing so, so it
    doesn't make initialization faster, but it is still useful input to
    have.
    
    Fixes: 1da177e4c3f4 ("Linux-2.6.12-rc2")
    Cc: stable@vger.kernel.org
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Eric Biggers <ebiggers@google.com>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

commit 8cea35e3a001fb5f465f83df49314f5e8d2cc7e8
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sun Apr 10 16:49:50 2022 +0200

    timekeeping: Add raw clock fallback for random_get_entropy()
    
    commit 1366992e16bddd5e2d9a561687f367f9f802e2e4 upstream.
    
    The addition of random_get_entropy_fallback() provides access to
    whichever time source has the highest frequency, which is useful for
    gathering entropy on platforms without available cycle counters. It's
    not necessarily as good as being able to quickly access a cycle counter
    that the CPU has, but it's still something, even when it falls back to
    being jiffies-based.
    
    In the event that a given arch does not define get_cycles(), falling
    back to the get_cycles() default implementation that returns 0 is really
    not the best we can do. Instead, at least calling
    random_get_entropy_fallback() would be preferable, because that always
    needs to return _something_, even falling back to jiffies eventually.
    It's not as though random_get_entropy_fallback() is super high precision
    or guaranteed to be entropic, but basically anything that's not zero all
    the time is better than returning zero all the time.
    
    Finally, since random_get_entropy_fallback() is used during extremely
    early boot when randomizing freelists in mm_init(), it can be called
    before timekeeping has been initialized. In that case there really is
    nothing we can do; jiffies hasn't even started ticking yet. So just give
    up and return 0.
    
    Suggested-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Theodore Ts'o <tytso@mit.edu>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 89bbebd132a051a6787626c478b76f6077a51730
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sat Apr 23 21:11:41 2022 +0200

    powerpc: define get_cycles macro for arch-override
    
    commit 408835832158df0357e18e96da7f2d1ed6b80e7f upstream.
    
    PowerPC defines a get_cycles() function, but it does not do the usual
    `#define get_cycles get_cycles` dance, making it impossible for generic
    code to see if an arch-specific function was defined. While the
    get_cycles() ifdef is not currently used, the following timekeeping
    patch in this series will depend on the macro existing (or not existing)
    when defining random_get_entropy().
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Benjamin Herrenschmidt <benh@ozlabs.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Acked-by: Michael Ellerman <mpe@ellerman.id.au>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 14390ed75cdf7eb029bdc48acb11fe3dcc54eaee
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sat Apr 23 21:11:41 2022 +0200

    alpha: define get_cycles macro for arch-override
    
    commit 1097710bc9660e1e588cf2186a35db3d95c4d258 upstream.
    
    Alpha defines a get_cycles() function, but it does not do the usual
    `#define get_cycles get_cycles` dance, making it impossible for generic
    code to see if an arch-specific function was defined. While the
    get_cycles() ifdef is not currently used, the following timekeeping
    patch in this series will depend on the macro existing (or not existing)
    when defining random_get_entropy().
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Richard Henderson <rth@twiddle.net>
    Cc: Ivan Kokshaysky <ink@jurassic.park.msu.ru>
    Acked-by: Matt Turner <mattst88@gmail.com>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit d3b2c42dfba9eaf17866efe4dcaf4b7096e33fb0
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sat Apr 23 21:11:41 2022 +0200

    parisc: define get_cycles macro for arch-override
    
    commit 8865bbe6ba1120e67f72201b7003a16202cd42be upstream.
    
    PA-RISC defines a get_cycles() function, but it does not do the usual
    `#define get_cycles get_cycles` dance, making it impossible for generic
    code to see if an arch-specific function was defined. While the
    get_cycles() ifdef is not currently used, the following timekeeping
    patch in this series will depend on the macro existing (or not existing)
    when defining random_get_entropy().
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Helge Deller <deller@gmx.de>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 56fffd6d20faec91782a43cf1565900eefe0314c
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sat Apr 23 21:11:41 2022 +0200

    s390: define get_cycles macro for arch-override
    
    commit 2e3df523256cb9836de8441e9c791a796759bb3c upstream.
    
    S390x defines a get_cycles() function, but it does not do the usual
    `#define get_cycles get_cycles` dance, making it impossible for generic
    code to see if an arch-specific function was defined. While the
    get_cycles() ifdef is not currently used, the following timekeeping
    patch in this series will depend on the macro existing (or not existing)
    when defining random_get_entropy().
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Vasily Gorbik <gor@linux.ibm.com>
    Cc: Alexander Gordeev <agordeev@linux.ibm.com>
    Cc: Christian Borntraeger <borntraeger@linux.ibm.com>
    Cc: Sven Schnelle <svens@linux.ibm.com>
    Acked-by: Heiko Carstens <hca@linux.ibm.com>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 80dcc4effc0dfc03583670f779fe25cee2f5f1d0
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sat Apr 23 21:11:41 2022 +0200

    ia64: define get_cycles macro for arch-override
    
    commit 57c0900b91d8891ab43f0e6b464d059fda51d102 upstream.
    
    Itanium defines a get_cycles() function, but it does not do the usual
    `#define get_cycles get_cycles` dance, making it impossible for generic
    code to see if an arch-specific function was defined. While the
    get_cycles() ifdef is not currently used, the following timekeeping
    patch in this series will depend on the macro existing (or not existing)
    when defining random_get_entropy().
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit d7b3bc8b4fa530f965edd6ad9229240e55549a96
Author: Kees Cook <keescook@chromium.org>
Date:   Fri Apr 19 23:27:05 2019 -0400

    random: move rand_initialize() earlier
    
    commit d55535232c3dbde9a523a9d10d68670f5fe5dec3 upstream.
    
    Right now rand_initialize() is run as an early_initcall(), but it only
    depends on timekeeping_init() (for mixing ktime_get_real() into the
    pools). However, the call to boot_init_stack_canary() for stack canary
    initialization runs earlier, which triggers a warning at boot:
    
    random: get_random_bytes called from start_kernel+0x357/0x548 with crng_init=0
    
    Instead, this moves rand_initialize() to after timekeeping_init(), and moves
    canary initialization here as well.
    
    Note that this warning may still remain for machines that do not have
    UEFI RNG support (which initializes the RNG pools during setup_arch()),
    or for x86 machines without RDRAND (or booting without "random.trust=on"
    or CONFIG_RANDOM_TRUST_CPU=y).
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 2142a4d898519736aea596e4f1d9a1062edb20c7
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sun Apr 10 16:49:50 2022 +0200

    timekeeping: Add raw clock fallback for random_get_entropy()
    
    commit 1366992e16bddd5e2d9a561687f367f9f802e2e4 upstream.
    
    The addition of random_get_entropy_fallback() provides access to
    whichever time source has the highest frequency, which is useful for
    gathering entropy on platforms without available cycle counters. It's
    not necessarily as good as being able to quickly access a cycle counter
    that the CPU has, but it's still something, even when it falls back to
    being jiffies-based.
    
    In the event that a given arch does not define get_cycles(), falling
    back to the get_cycles() default implementation that returns 0 is really
    not the best we can do. Instead, at least calling
    random_get_entropy_fallback() would be preferable, because that always
    needs to return _something_, even falling back to jiffies eventually.
    It's not as though random_get_entropy_fallback() is super high precision
    or guaranteed to be entropic, but basically anything that's not zero all
    the time is better than returning zero all the time.
    
    Finally, since random_get_entropy_fallback() is used during extremely
    early boot when randomizing freelists in mm_init(), it can be called
    before timekeeping has been initialized. In that case there really is
    nothing we can do; jiffies hasn't even started ticking yet. So just give
    up and return 0.
    
    Suggested-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Theodore Ts'o <tytso@mit.edu>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 0a182df6e951b381f23ff2a0a9506de9dbf2e29b
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sat Apr 23 21:11:41 2022 +0200

    powerpc: define get_cycles macro for arch-override
    
    commit 408835832158df0357e18e96da7f2d1ed6b80e7f upstream.
    
    PowerPC defines a get_cycles() function, but it does not do the usual
    `#define get_cycles get_cycles` dance, making it impossible for generic
    code to see if an arch-specific function was defined. While the
    get_cycles() ifdef is not currently used, the following timekeeping
    patch in this series will depend on the macro existing (or not existing)
    when defining random_get_entropy().
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Benjamin Herrenschmidt <benh@ozlabs.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Acked-by: Michael Ellerman <mpe@ellerman.id.au>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit d969c9880bafd6e4986f125720da8b238a1aadd1
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sat Apr 23 21:11:41 2022 +0200

    alpha: define get_cycles macro for arch-override
    
    commit 1097710bc9660e1e588cf2186a35db3d95c4d258 upstream.
    
    Alpha defines a get_cycles() function, but it does not do the usual
    `#define get_cycles get_cycles` dance, making it impossible for generic
    code to see if an arch-specific function was defined. While the
    get_cycles() ifdef is not currently used, the following timekeeping
    patch in this series will depend on the macro existing (or not existing)
    when defining random_get_entropy().
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Richard Henderson <rth@twiddle.net>
    Cc: Ivan Kokshaysky <ink@jurassic.park.msu.ru>
    Acked-by: Matt Turner <mattst88@gmail.com>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit faf62b743975f623677ec0f59cb2f2f750cd35d1
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sat Apr 23 21:11:41 2022 +0200

    parisc: define get_cycles macro for arch-override
    
    commit 8865bbe6ba1120e67f72201b7003a16202cd42be upstream.
    
    PA-RISC defines a get_cycles() function, but it does not do the usual
    `#define get_cycles get_cycles` dance, making it impossible for generic
    code to see if an arch-specific function was defined. While the
    get_cycles() ifdef is not currently used, the following timekeeping
    patch in this series will depend on the macro existing (or not existing)
    when defining random_get_entropy().
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Helge Deller <deller@gmx.de>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 0da28452ba041054b4281f34db877d737f3fec13
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sat Apr 23 21:11:41 2022 +0200

    s390: define get_cycles macro for arch-override
    
    commit 2e3df523256cb9836de8441e9c791a796759bb3c upstream.
    
    S390x defines a get_cycles() function, but it does not do the usual
    `#define get_cycles get_cycles` dance, making it impossible for generic
    code to see if an arch-specific function was defined. While the
    get_cycles() ifdef is not currently used, the following timekeeping
    patch in this series will depend on the macro existing (or not existing)
    when defining random_get_entropy().
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Vasily Gorbik <gor@linux.ibm.com>
    Cc: Alexander Gordeev <agordeev@linux.ibm.com>
    Cc: Christian Borntraeger <borntraeger@linux.ibm.com>
    Cc: Sven Schnelle <svens@linux.ibm.com>
    Acked-by: Heiko Carstens <hca@linux.ibm.com>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit e154c03c323e29f56fb46751fb7abee924b47347
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sat Apr 23 21:11:41 2022 +0200

    ia64: define get_cycles macro for arch-override
    
    commit 57c0900b91d8891ab43f0e6b464d059fda51d102 upstream.
    
    Itanium defines a get_cycles() function, but it does not do the usual
    `#define get_cycles get_cycles` dance, making it impossible for generic
    code to see if an arch-specific function was defined. While the
    get_cycles() ifdef is not currently used, the following timekeeping
    patch in this series will depend on the macro existing (or not existing)
    when defining random_get_entropy().
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 50622066f5d13aae559ddb414d7444cde7f113b5
Author: Kees Cook <keescook@chromium.org>
Date:   Fri Apr 19 23:27:05 2019 -0400

    random: move rand_initialize() earlier
    
    commit d55535232c3dbde9a523a9d10d68670f5fe5dec3 upstream.
    
    Right now rand_initialize() is run as an early_initcall(), but it only
    depends on timekeeping_init() (for mixing ktime_get_real() into the
    pools). However, the call to boot_init_stack_canary() for stack canary
    initialization runs earlier, which triggers a warning at boot:
    
    random: get_random_bytes called from start_kernel+0x357/0x548 with crng_init=0
    
    Instead, this moves rand_initialize() to after timekeeping_init(), and moves
    canary initialization here as well.
    
    Note that this warning may still remain for machines that do not have
    UEFI RNG support (which initializes the RNG pools during setup_arch()),
    or for x86 machines without RDRAND (or booting without "random.trust=on"
    or CONFIG_RANDOM_TRUST_CPU=y).
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit bb61b00db2cde0ba4eae474c9b5a9b7258a093c7
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sun Apr 10 16:49:50 2022 +0200

    timekeeping: Add raw clock fallback for random_get_entropy()
    
    commit 1366992e16bddd5e2d9a561687f367f9f802e2e4 upstream.
    
    The addition of random_get_entropy_fallback() provides access to
    whichever time source has the highest frequency, which is useful for
    gathering entropy on platforms without available cycle counters. It's
    not necessarily as good as being able to quickly access a cycle counter
    that the CPU has, but it's still something, even when it falls back to
    being jiffies-based.
    
    In the event that a given arch does not define get_cycles(), falling
    back to the get_cycles() default implementation that returns 0 is really
    not the best we can do. Instead, at least calling
    random_get_entropy_fallback() would be preferable, because that always
    needs to return _something_, even falling back to jiffies eventually.
    It's not as though random_get_entropy_fallback() is super high precision
    or guaranteed to be entropic, but basically anything that's not zero all
    the time is better than returning zero all the time.
    
    Finally, since random_get_entropy_fallback() is used during extremely
    early boot when randomizing freelists in mm_init(), it can be called
    before timekeeping has been initialized. In that case there really is
    nothing we can do; jiffies hasn't even started ticking yet. So just give
    up and return 0.
    
    Suggested-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Theodore Ts'o <tytso@mit.edu>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 0cf45867fa6c6accb9c49803b65192c3a50d265f
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sat Apr 23 21:11:41 2022 +0200

    powerpc: define get_cycles macro for arch-override
    
    commit 408835832158df0357e18e96da7f2d1ed6b80e7f upstream.
    
    PowerPC defines a get_cycles() function, but it does not do the usual
    `#define get_cycles get_cycles` dance, making it impossible for generic
    code to see if an arch-specific function was defined. While the
    get_cycles() ifdef is not currently used, the following timekeeping
    patch in this series will depend on the macro existing (or not existing)
    when defining random_get_entropy().
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Benjamin Herrenschmidt <benh@ozlabs.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Acked-by: Michael Ellerman <mpe@ellerman.id.au>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 72b90d9cdfe9af96996eab1941a8d7af02c8d073
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sat Apr 23 21:11:41 2022 +0200

    alpha: define get_cycles macro for arch-override
    
    commit 1097710bc9660e1e588cf2186a35db3d95c4d258 upstream.
    
    Alpha defines a get_cycles() function, but it does not do the usual
    `#define get_cycles get_cycles` dance, making it impossible for generic
    code to see if an arch-specific function was defined. While the
    get_cycles() ifdef is not currently used, the following timekeeping
    patch in this series will depend on the macro existing (or not existing)
    when defining random_get_entropy().
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Richard Henderson <rth@twiddle.net>
    Cc: Ivan Kokshaysky <ink@jurassic.park.msu.ru>
    Acked-by: Matt Turner <mattst88@gmail.com>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit a99753e73cd1bc676d7a9bf10dd3568dfe7f1c32
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sat Apr 23 21:11:41 2022 +0200

    parisc: define get_cycles macro for arch-override
    
    commit 8865bbe6ba1120e67f72201b7003a16202cd42be upstream.
    
    PA-RISC defines a get_cycles() function, but it does not do the usual
    `#define get_cycles get_cycles` dance, making it impossible for generic
    code to see if an arch-specific function was defined. While the
    get_cycles() ifdef is not currently used, the following timekeeping
    patch in this series will depend on the macro existing (or not existing)
    when defining random_get_entropy().
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Helge Deller <deller@gmx.de>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 28528a7bebbd880e0813efeed64963fda38161ad
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sat Apr 23 21:11:41 2022 +0200

    s390: define get_cycles macro for arch-override
    
    commit 2e3df523256cb9836de8441e9c791a796759bb3c upstream.
    
    S390x defines a get_cycles() function, but it does not do the usual
    `#define get_cycles get_cycles` dance, making it impossible for generic
    code to see if an arch-specific function was defined. While the
    get_cycles() ifdef is not currently used, the following timekeeping
    patch in this series will depend on the macro existing (or not existing)
    when defining random_get_entropy().
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Vasily Gorbik <gor@linux.ibm.com>
    Cc: Alexander Gordeev <agordeev@linux.ibm.com>
    Cc: Christian Borntraeger <borntraeger@linux.ibm.com>
    Cc: Sven Schnelle <svens@linux.ibm.com>
    Acked-by: Heiko Carstens <hca@linux.ibm.com>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 115d4bd0dee2ee63cf595a874f46d09a1e8542ce
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sat Apr 23 21:11:41 2022 +0200

    ia64: define get_cycles macro for arch-override
    
    commit 57c0900b91d8891ab43f0e6b464d059fda51d102 upstream.
    
    Itanium defines a get_cycles() function, but it does not do the usual
    `#define get_cycles get_cycles` dance, making it impossible for generic
    code to see if an arch-specific function was defined. While the
    get_cycles() ifdef is not currently used, the following timekeeping
    patch in this series will depend on the macro existing (or not existing)
    when defining random_get_entropy().
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 166a592cad369dcbe942c26bdfdb313f09b1018d
Author: Kees Cook <keescook@chromium.org>
Date:   Fri Apr 19 23:27:05 2019 -0400

    random: move rand_initialize() earlier
    
    commit d55535232c3dbde9a523a9d10d68670f5fe5dec3 upstream.
    
    Right now rand_initialize() is run as an early_initcall(), but it only
    depends on timekeeping_init() (for mixing ktime_get_real() into the
    pools). However, the call to boot_init_stack_canary() for stack canary
    initialization runs earlier, which triggers a warning at boot:
    
    random: get_random_bytes called from start_kernel+0x357/0x548 with crng_init=0
    
    Instead, this moves rand_initialize() to after timekeeping_init(), and moves
    canary initialization here as well.
    
    Note that this warning may still remain for machines that do not have
    UEFI RNG support (which initializes the RNG pools during setup_arch()),
    or for x86 machines without RDRAND (or booting without "random.trust=on"
    or CONFIG_RANDOM_TRUST_CPU=y).
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit a7d04ca9da61e5760587c686a6af6390470bbf49
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sun Apr 10 16:49:50 2022 +0200

    timekeeping: Add raw clock fallback for random_get_entropy()
    
    commit 1366992e16bddd5e2d9a561687f367f9f802e2e4 upstream.
    
    The addition of random_get_entropy_fallback() provides access to
    whichever time source has the highest frequency, which is useful for
    gathering entropy on platforms without available cycle counters. It's
    not necessarily as good as being able to quickly access a cycle counter
    that the CPU has, but it's still something, even when it falls back to
    being jiffies-based.
    
    In the event that a given arch does not define get_cycles(), falling
    back to the get_cycles() default implementation that returns 0 is really
    not the best we can do. Instead, at least calling
    random_get_entropy_fallback() would be preferable, because that always
    needs to return _something_, even falling back to jiffies eventually.
    It's not as though random_get_entropy_fallback() is super high precision
    or guaranteed to be entropic, but basically anything that's not zero all
    the time is better than returning zero all the time.
    
    Finally, since random_get_entropy_fallback() is used during extremely
    early boot when randomizing freelists in mm_init(), it can be called
    before timekeeping has been initialized. In that case there really is
    nothing we can do; jiffies hasn't even started ticking yet. So just give
    up and return 0.
    
    Suggested-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Theodore Ts'o <tytso@mit.edu>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit eb2f9d72f32ac9357537b1c099e355dd9915206a
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sat Apr 23 21:11:41 2022 +0200

    powerpc: define get_cycles macro for arch-override
    
    commit 408835832158df0357e18e96da7f2d1ed6b80e7f upstream.
    
    PowerPC defines a get_cycles() function, but it does not do the usual
    `#define get_cycles get_cycles` dance, making it impossible for generic
    code to see if an arch-specific function was defined. While the
    get_cycles() ifdef is not currently used, the following timekeeping
    patch in this series will depend on the macro existing (or not existing)
    when defining random_get_entropy().
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Benjamin Herrenschmidt <benh@ozlabs.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Acked-by: Michael Ellerman <mpe@ellerman.id.au>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 10455a367c33cf015363d610926d579d73e15a48
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sat Apr 23 21:11:41 2022 +0200

    alpha: define get_cycles macro for arch-override
    
    commit 1097710bc9660e1e588cf2186a35db3d95c4d258 upstream.
    
    Alpha defines a get_cycles() function, but it does not do the usual
    `#define get_cycles get_cycles` dance, making it impossible for generic
    code to see if an arch-specific function was defined. While the
    get_cycles() ifdef is not currently used, the following timekeeping
    patch in this series will depend on the macro existing (or not existing)
    when defining random_get_entropy().
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Richard Henderson <rth@twiddle.net>
    Cc: Ivan Kokshaysky <ink@jurassic.park.msu.ru>
    Acked-by: Matt Turner <mattst88@gmail.com>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 5f0b77ca1978ce98d630a3e2b7274a3fec6c53c9
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sat Apr 23 21:11:41 2022 +0200

    parisc: define get_cycles macro for arch-override
    
    commit 8865bbe6ba1120e67f72201b7003a16202cd42be upstream.
    
    PA-RISC defines a get_cycles() function, but it does not do the usual
    `#define get_cycles get_cycles` dance, making it impossible for generic
    code to see if an arch-specific function was defined. While the
    get_cycles() ifdef is not currently used, the following timekeeping
    patch in this series will depend on the macro existing (or not existing)
    when defining random_get_entropy().
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Helge Deller <deller@gmx.de>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 80459abc9feeefc2640c1f071b318114ab1fd99b
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sat Apr 23 21:11:41 2022 +0200

    s390: define get_cycles macro for arch-override
    
    commit 2e3df523256cb9836de8441e9c791a796759bb3c upstream.
    
    S390x defines a get_cycles() function, but it does not do the usual
    `#define get_cycles get_cycles` dance, making it impossible for generic
    code to see if an arch-specific function was defined. While the
    get_cycles() ifdef is not currently used, the following timekeeping
    patch in this series will depend on the macro existing (or not existing)
    when defining random_get_entropy().
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Vasily Gorbik <gor@linux.ibm.com>
    Cc: Alexander Gordeev <agordeev@linux.ibm.com>
    Cc: Christian Borntraeger <borntraeger@linux.ibm.com>
    Cc: Sven Schnelle <svens@linux.ibm.com>
    Acked-by: Heiko Carstens <hca@linux.ibm.com>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 73385644490a8c9a8b316bf1c7038c80d61fb697
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sat Apr 23 21:11:41 2022 +0200

    ia64: define get_cycles macro for arch-override
    
    commit 57c0900b91d8891ab43f0e6b464d059fda51d102 upstream.
    
    Itanium defines a get_cycles() function, but it does not do the usual
    `#define get_cycles get_cycles` dance, making it impossible for generic
    code to see if an arch-specific function was defined. While the
    get_cycles() ifdef is not currently used, the following timekeeping
    patch in this series will depend on the macro existing (or not existing)
    when defining random_get_entropy().
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 7690be1adf8a5b8cc5dd5530009b5004209461b3
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sun Apr 10 16:49:50 2022 +0200

    timekeeping: Add raw clock fallback for random_get_entropy()
    
    commit 1366992e16bddd5e2d9a561687f367f9f802e2e4 upstream.
    
    The addition of random_get_entropy_fallback() provides access to
    whichever time source has the highest frequency, which is useful for
    gathering entropy on platforms without available cycle counters. It's
    not necessarily as good as being able to quickly access a cycle counter
    that the CPU has, but it's still something, even when it falls back to
    being jiffies-based.
    
    In the event that a given arch does not define get_cycles(), falling
    back to the get_cycles() default implementation that returns 0 is really
    not the best we can do. Instead, at least calling
    random_get_entropy_fallback() would be preferable, because that always
    needs to return _something_, even falling back to jiffies eventually.
    It's not as though random_get_entropy_fallback() is super high precision
    or guaranteed to be entropic, but basically anything that's not zero all
    the time is better than returning zero all the time.
    
    Finally, since random_get_entropy_fallback() is used during extremely
    early boot when randomizing freelists in mm_init(), it can be called
    before timekeeping has been initialized. In that case there really is
    nothing we can do; jiffies hasn't even started ticking yet. So just give
    up and return 0.
    
    Suggested-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Theodore Ts'o <tytso@mit.edu>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 07b5d0b3e2cc435d9ae44b52df4f0a846170962b
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sat Apr 23 21:11:41 2022 +0200

    powerpc: define get_cycles macro for arch-override
    
    commit 408835832158df0357e18e96da7f2d1ed6b80e7f upstream.
    
    PowerPC defines a get_cycles() function, but it does not do the usual
    `#define get_cycles get_cycles` dance, making it impossible for generic
    code to see if an arch-specific function was defined. While the
    get_cycles() ifdef is not currently used, the following timekeeping
    patch in this series will depend on the macro existing (or not existing)
    when defining random_get_entropy().
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Benjamin Herrenschmidt <benh@ozlabs.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Acked-by: Michael Ellerman <mpe@ellerman.id.au>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 30ee01bcdc2cd684d9aec469cbc1881384846dd1
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sat Apr 23 21:11:41 2022 +0200

    alpha: define get_cycles macro for arch-override
    
    commit 1097710bc9660e1e588cf2186a35db3d95c4d258 upstream.
    
    Alpha defines a get_cycles() function, but it does not do the usual
    `#define get_cycles get_cycles` dance, making it impossible for generic
    code to see if an arch-specific function was defined. While the
    get_cycles() ifdef is not currently used, the following timekeeping
    patch in this series will depend on the macro existing (or not existing)
    when defining random_get_entropy().
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Richard Henderson <rth@twiddle.net>
    Cc: Ivan Kokshaysky <ink@jurassic.park.msu.ru>
    Acked-by: Matt Turner <mattst88@gmail.com>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit c55a863c304e7301237c6c057350cf01d4ca9716
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sat Apr 23 21:11:41 2022 +0200

    parisc: define get_cycles macro for arch-override
    
    commit 8865bbe6ba1120e67f72201b7003a16202cd42be upstream.
    
    PA-RISC defines a get_cycles() function, but it does not do the usual
    `#define get_cycles get_cycles` dance, making it impossible for generic
    code to see if an arch-specific function was defined. While the
    get_cycles() ifdef is not currently used, the following timekeeping
    patch in this series will depend on the macro existing (or not existing)
    when defining random_get_entropy().
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Helge Deller <deller@gmx.de>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 641d1fbd96676cb3c7c987aea4792349117fdbe6
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sat Apr 23 21:11:41 2022 +0200

    s390: define get_cycles macro for arch-override
    
    commit 2e3df523256cb9836de8441e9c791a796759bb3c upstream.
    
    S390x defines a get_cycles() function, but it does not do the usual
    `#define get_cycles get_cycles` dance, making it impossible for generic
    code to see if an arch-specific function was defined. While the
    get_cycles() ifdef is not currently used, the following timekeeping
    patch in this series will depend on the macro existing (or not existing)
    when defining random_get_entropy().
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Vasily Gorbik <gor@linux.ibm.com>
    Cc: Alexander Gordeev <agordeev@linux.ibm.com>
    Cc: Christian Borntraeger <borntraeger@linux.ibm.com>
    Cc: Sven Schnelle <svens@linux.ibm.com>
    Acked-by: Heiko Carstens <hca@linux.ibm.com>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit c895438b172c7071b720b0ccefe25500526b7a0d
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sat Apr 23 21:11:41 2022 +0200

    ia64: define get_cycles macro for arch-override
    
    commit 57c0900b91d8891ab43f0e6b464d059fda51d102 upstream.
    
    Itanium defines a get_cycles() function, but it does not do the usual
    `#define get_cycles get_cycles` dance, making it impossible for generic
    code to see if an arch-specific function was defined. While the
    get_cycles() ifdef is not currently used, the following timekeeping
    patch in this series will depend on the macro existing (or not existing)
    when defining random_get_entropy().
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 82f182812f1772ee0d56e82f03f5c252b2bd2140
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sun Apr 10 16:49:50 2022 +0200

    timekeeping: Add raw clock fallback for random_get_entropy()
    
    commit 1366992e16bddd5e2d9a561687f367f9f802e2e4 upstream.
    
    The addition of random_get_entropy_fallback() provides access to
    whichever time source has the highest frequency, which is useful for
    gathering entropy on platforms without available cycle counters. It's
    not necessarily as good as being able to quickly access a cycle counter
    that the CPU has, but it's still something, even when it falls back to
    being jiffies-based.
    
    In the event that a given arch does not define get_cycles(), falling
    back to the get_cycles() default implementation that returns 0 is really
    not the best we can do. Instead, at least calling
    random_get_entropy_fallback() would be preferable, because that always
    needs to return _something_, even falling back to jiffies eventually.
    It's not as though random_get_entropy_fallback() is super high precision
    or guaranteed to be entropic, but basically anything that's not zero all
    the time is better than returning zero all the time.
    
    Finally, since random_get_entropy_fallback() is used during extremely
    early boot when randomizing freelists in mm_init(), it can be called
    before timekeeping has been initialized. In that case there really is
    nothing we can do; jiffies hasn't even started ticking yet. So just give
    up and return 0.
    
    Suggested-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Theodore Ts'o <tytso@mit.edu>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit bc94ccb2904eb2a0b8c86599790dbfebd34987b7
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sat Apr 23 21:11:41 2022 +0200

    powerpc: define get_cycles macro for arch-override
    
    commit 408835832158df0357e18e96da7f2d1ed6b80e7f upstream.
    
    PowerPC defines a get_cycles() function, but it does not do the usual
    `#define get_cycles get_cycles` dance, making it impossible for generic
    code to see if an arch-specific function was defined. While the
    get_cycles() ifdef is not currently used, the following timekeeping
    patch in this series will depend on the macro existing (or not existing)
    when defining random_get_entropy().
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Benjamin Herrenschmidt <benh@ozlabs.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Acked-by: Michael Ellerman <mpe@ellerman.id.au>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 8ca78fbdeba0160131a4699747fd32f4f480299b
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sat Apr 23 21:11:41 2022 +0200

    alpha: define get_cycles macro for arch-override
    
    commit 1097710bc9660e1e588cf2186a35db3d95c4d258 upstream.
    
    Alpha defines a get_cycles() function, but it does not do the usual
    `#define get_cycles get_cycles` dance, making it impossible for generic
    code to see if an arch-specific function was defined. While the
    get_cycles() ifdef is not currently used, the following timekeeping
    patch in this series will depend on the macro existing (or not existing)
    when defining random_get_entropy().
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Richard Henderson <rth@twiddle.net>
    Cc: Ivan Kokshaysky <ink@jurassic.park.msu.ru>
    Acked-by: Matt Turner <mattst88@gmail.com>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 9bf990cff673ca0747a01ceab0095a71af8033f6
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sat Apr 23 21:11:41 2022 +0200

    parisc: define get_cycles macro for arch-override
    
    commit 8865bbe6ba1120e67f72201b7003a16202cd42be upstream.
    
    PA-RISC defines a get_cycles() function, but it does not do the usual
    `#define get_cycles get_cycles` dance, making it impossible for generic
    code to see if an arch-specific function was defined. While the
    get_cycles() ifdef is not currently used, the following timekeeping
    patch in this series will depend on the macro existing (or not existing)
    when defining random_get_entropy().
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Helge Deller <deller@gmx.de>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit e05efd31b9db39ccd9c489c0f93df7a8e8cb48a8
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sat Apr 23 21:11:41 2022 +0200

    s390: define get_cycles macro for arch-override
    
    commit 2e3df523256cb9836de8441e9c791a796759bb3c upstream.
    
    S390x defines a get_cycles() function, but it does not do the usual
    `#define get_cycles get_cycles` dance, making it impossible for generic
    code to see if an arch-specific function was defined. While the
    get_cycles() ifdef is not currently used, the following timekeeping
    patch in this series will depend on the macro existing (or not existing)
    when defining random_get_entropy().
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Vasily Gorbik <gor@linux.ibm.com>
    Cc: Alexander Gordeev <agordeev@linux.ibm.com>
    Cc: Christian Borntraeger <borntraeger@linux.ibm.com>
    Cc: Sven Schnelle <svens@linux.ibm.com>
    Acked-by: Heiko Carstens <hca@linux.ibm.com>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 9f174326e35ceb355e6ac8dcb750797e9daf61f1
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sat Apr 23 21:11:41 2022 +0200

    ia64: define get_cycles macro for arch-override
    
    commit 57c0900b91d8891ab43f0e6b464d059fda51d102 upstream.
    
    Itanium defines a get_cycles() function, but it does not do the usual
    `#define get_cycles get_cycles` dance, making it impossible for generic
    code to see if an arch-specific function was defined. While the
    get_cycles() ifdef is not currently used, the following timekeeping
    patch in this series will depend on the macro existing (or not existing)
    when defining random_get_entropy().
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 9aaae713da1fd8234a767c48d481010b78126ecf
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sun Apr 10 16:49:50 2022 +0200

    timekeeping: Add raw clock fallback for random_get_entropy()
    
    commit 1366992e16bddd5e2d9a561687f367f9f802e2e4 upstream.
    
    The addition of random_get_entropy_fallback() provides access to
    whichever time source has the highest frequency, which is useful for
    gathering entropy on platforms without available cycle counters. It's
    not necessarily as good as being able to quickly access a cycle counter
    that the CPU has, but it's still something, even when it falls back to
    being jiffies-based.
    
    In the event that a given arch does not define get_cycles(), falling
    back to the get_cycles() default implementation that returns 0 is really
    not the best we can do. Instead, at least calling
    random_get_entropy_fallback() would be preferable, because that always
    needs to return _something_, even falling back to jiffies eventually.
    It's not as though random_get_entropy_fallback() is super high precision
    or guaranteed to be entropic, but basically anything that's not zero all
    the time is better than returning zero all the time.
    
    Finally, since random_get_entropy_fallback() is used during extremely
    early boot when randomizing freelists in mm_init(), it can be called
    before timekeeping has been initialized. In that case there really is
    nothing we can do; jiffies hasn't even started ticking yet. So just give
    up and return 0.
    
    Suggested-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Theodore Ts'o <tytso@mit.edu>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit d2e082dc5209834e6bb7826f921f90ca22f6fdf5
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sat Apr 23 21:11:41 2022 +0200

    powerpc: define get_cycles macro for arch-override
    
    commit 408835832158df0357e18e96da7f2d1ed6b80e7f upstream.
    
    PowerPC defines a get_cycles() function, but it does not do the usual
    `#define get_cycles get_cycles` dance, making it impossible for generic
    code to see if an arch-specific function was defined. While the
    get_cycles() ifdef is not currently used, the following timekeeping
    patch in this series will depend on the macro existing (or not existing)
    when defining random_get_entropy().
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Benjamin Herrenschmidt <benh@ozlabs.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Acked-by: Michael Ellerman <mpe@ellerman.id.au>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit af739f0719638fd272f429594f83bb65a09a55a5
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sat Apr 23 21:11:41 2022 +0200

    alpha: define get_cycles macro for arch-override
    
    commit 1097710bc9660e1e588cf2186a35db3d95c4d258 upstream.
    
    Alpha defines a get_cycles() function, but it does not do the usual
    `#define get_cycles get_cycles` dance, making it impossible for generic
    code to see if an arch-specific function was defined. While the
    get_cycles() ifdef is not currently used, the following timekeeping
    patch in this series will depend on the macro existing (or not existing)
    when defining random_get_entropy().
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Richard Henderson <rth@twiddle.net>
    Cc: Ivan Kokshaysky <ink@jurassic.park.msu.ru>
    Acked-by: Matt Turner <mattst88@gmail.com>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 4b40eda72a4bc5abb3c48d6267bb0c46f8a229da
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sat Apr 23 21:11:41 2022 +0200

    parisc: define get_cycles macro for arch-override
    
    commit 8865bbe6ba1120e67f72201b7003a16202cd42be upstream.
    
    PA-RISC defines a get_cycles() function, but it does not do the usual
    `#define get_cycles get_cycles` dance, making it impossible for generic
    code to see if an arch-specific function was defined. While the
    get_cycles() ifdef is not currently used, the following timekeeping
    patch in this series will depend on the macro existing (or not existing)
    when defining random_get_entropy().
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Helge Deller <deller@gmx.de>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 31290382687065595cd15fa882d3e260ab556001
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sat Apr 23 21:11:41 2022 +0200

    s390: define get_cycles macro for arch-override
    
    commit 2e3df523256cb9836de8441e9c791a796759bb3c upstream.
    
    S390x defines a get_cycles() function, but it does not do the usual
    `#define get_cycles get_cycles` dance, making it impossible for generic
    code to see if an arch-specific function was defined. While the
    get_cycles() ifdef is not currently used, the following timekeeping
    patch in this series will depend on the macro existing (or not existing)
    when defining random_get_entropy().
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Vasily Gorbik <gor@linux.ibm.com>
    Cc: Alexander Gordeev <agordeev@linux.ibm.com>
    Cc: Christian Borntraeger <borntraeger@linux.ibm.com>
    Cc: Sven Schnelle <svens@linux.ibm.com>
    Acked-by: Heiko Carstens <hca@linux.ibm.com>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 01f814b110ec1da211a950425381aea32dd4a004
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sat Apr 23 21:11:41 2022 +0200

    ia64: define get_cycles macro for arch-override
    
    commit 57c0900b91d8891ab43f0e6b464d059fda51d102 upstream.
    
    Itanium defines a get_cycles() function, but it does not do the usual
    `#define get_cycles get_cycles` dance, making it impossible for generic
    code to see if an arch-specific function was defined. While the
    get_cycles() ifdef is not currently used, the following timekeeping
    patch in this series will depend on the macro existing (or not existing)
    when defining random_get_entropy().
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 7a5a2e2ccfd9496dcc9290c2e8799da612270607
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sun Apr 10 16:49:50 2022 +0200

    timekeeping: Add raw clock fallback for random_get_entropy()
    
    commit 1366992e16bddd5e2d9a561687f367f9f802e2e4 upstream.
    
    The addition of random_get_entropy_fallback() provides access to
    whichever time source has the highest frequency, which is useful for
    gathering entropy on platforms without available cycle counters. It's
    not necessarily as good as being able to quickly access a cycle counter
    that the CPU has, but it's still something, even when it falls back to
    being jiffies-based.
    
    In the event that a given arch does not define get_cycles(), falling
    back to the get_cycles() default implementation that returns 0 is really
    not the best we can do. Instead, at least calling
    random_get_entropy_fallback() would be preferable, because that always
    needs to return _something_, even falling back to jiffies eventually.
    It's not as though random_get_entropy_fallback() is super high precision
    or guaranteed to be entropic, but basically anything that's not zero all
    the time is better than returning zero all the time.
    
    Finally, since random_get_entropy_fallback() is used during extremely
    early boot when randomizing freelists in mm_init(), it can be called
    before timekeeping has been initialized. In that case there really is
    nothing we can do; jiffies hasn't even started ticking yet. So just give
    up and return 0.
    
    Suggested-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Theodore Ts'o <tytso@mit.edu>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 62d1c104c7f6ee38d4f2717b1539a0dd54f71ff9
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sat Apr 23 21:11:41 2022 +0200

    powerpc: define get_cycles macro for arch-override
    
    commit 408835832158df0357e18e96da7f2d1ed6b80e7f upstream.
    
    PowerPC defines a get_cycles() function, but it does not do the usual
    `#define get_cycles get_cycles` dance, making it impossible for generic
    code to see if an arch-specific function was defined. While the
    get_cycles() ifdef is not currently used, the following timekeeping
    patch in this series will depend on the macro existing (or not existing)
    when defining random_get_entropy().
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Benjamin Herrenschmidt <benh@ozlabs.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Acked-by: Michael Ellerman <mpe@ellerman.id.au>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit d0d24c89d88505011b09eec0dec43bec1c617bef
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sat Apr 23 21:11:41 2022 +0200

    alpha: define get_cycles macro for arch-override
    
    commit 1097710bc9660e1e588cf2186a35db3d95c4d258 upstream.
    
    Alpha defines a get_cycles() function, but it does not do the usual
    `#define get_cycles get_cycles` dance, making it impossible for generic
    code to see if an arch-specific function was defined. While the
    get_cycles() ifdef is not currently used, the following timekeeping
    patch in this series will depend on the macro existing (or not existing)
    when defining random_get_entropy().
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Richard Henderson <rth@twiddle.net>
    Cc: Ivan Kokshaysky <ink@jurassic.park.msu.ru>
    Acked-by: Matt Turner <mattst88@gmail.com>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 9a51867dc50cdc4df16200d8897bced7f243aaab
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sat Apr 23 21:11:41 2022 +0200

    parisc: define get_cycles macro for arch-override
    
    commit 8865bbe6ba1120e67f72201b7003a16202cd42be upstream.
    
    PA-RISC defines a get_cycles() function, but it does not do the usual
    `#define get_cycles get_cycles` dance, making it impossible for generic
    code to see if an arch-specific function was defined. While the
    get_cycles() ifdef is not currently used, the following timekeeping
    patch in this series will depend on the macro existing (or not existing)
    when defining random_get_entropy().
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Helge Deller <deller@gmx.de>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit f11c51290d0f854f83632d79a03af9605ca2c32a
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sat Apr 23 21:11:41 2022 +0200

    s390: define get_cycles macro for arch-override
    
    commit 2e3df523256cb9836de8441e9c791a796759bb3c upstream.
    
    S390x defines a get_cycles() function, but it does not do the usual
    `#define get_cycles get_cycles` dance, making it impossible for generic
    code to see if an arch-specific function was defined. While the
    get_cycles() ifdef is not currently used, the following timekeeping
    patch in this series will depend on the macro existing (or not existing)
    when defining random_get_entropy().
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Vasily Gorbik <gor@linux.ibm.com>
    Cc: Alexander Gordeev <agordeev@linux.ibm.com>
    Cc: Christian Borntraeger <borntraeger@linux.ibm.com>
    Cc: Sven Schnelle <svens@linux.ibm.com>
    Acked-by: Heiko Carstens <hca@linux.ibm.com>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 9d923d15fc4b99d55a4cf0f8b1336ed7b8af218e
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sat Apr 23 21:11:41 2022 +0200

    ia64: define get_cycles macro for arch-override
    
    commit 57c0900b91d8891ab43f0e6b464d059fda51d102 upstream.
    
    Itanium defines a get_cycles() function, but it does not do the usual
    `#define get_cycles get_cycles` dance, making it impossible for generic
    code to see if an arch-specific function was defined. While the
    get_cycles() ifdef is not currently used, the following timekeeping
    patch in this series will depend on the macro existing (or not existing)
    when defining random_get_entropy().
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit ac2ab99072cce553c78f326ea22d72856f570d88
Merge: eadb2f47a3ce 1ce6c8d68f8a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue May 24 11:58:10 2022 -0700

    Merge tag 'random-5.19-rc1-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/crng/random
    
    Pull random number generator updates from Jason Donenfeld:
     "These updates continue to refine the work began in 5.17 and 5.18 of
      modernizing the RNG's crypto and streamlining and documenting its
      code.
    
      New for 5.19, the updates aim to improve entropy collection methods
      and make some initial decisions regarding the "premature next" problem
      and our threat model. The cloc utility now reports that random.c is
      931 lines of code and 466 lines of comments, not that basic metrics
      like that mean all that much, but at the very least it tells you that
      this is very much a manageable driver now.
    
      Here's a summary of the various updates:
    
       - The random_get_entropy() function now always returns something at
         least minimally useful. This is the primary entropy source in most
         collectors, which in the best case expands to something like RDTSC,
         but prior to this change, in the worst case it would just return 0,
         contributing nothing. For 5.19, additional architectures are wired
         up, and architectures that are entirely missing a cycle counter now
         have a generic fallback path, which uses the highest resolution
         clock available from the timekeeping subsystem.
    
         Some of those clocks can actually be quite good, despite the CPU
         not having a cycle counter of its own, and going off-core for a
         stamp is generally thought to increase jitter, something positive
         from the perspective of entropy gathering. Done very early on in
         the development cycle, this has been sitting in next getting some
         testing for a while now and has relevant acks from the archs, so it
         should be pretty well tested and fine, but is nonetheless the thing
         I'll be keeping my eye on most closely.
    
       - Of particular note with the random_get_entropy() improvements is
         MIPS, which, on CPUs that lack the c0 count register, will now
         combine the high-speed but short-cycle c0 random register with the
         lower-speed but long-cycle generic fallback path.
    
       - With random_get_entropy() now always returning something useful,
         the interrupt handler now collects entropy in a consistent
         construction.
    
       - Rather than comparing two samples of random_get_entropy() for the
         jitter dance, the algorithm now tests many samples, and uses the
         amount of differing ones to determine whether or not jitter entropy
         is usable and how laborious it must be. The problem with comparing
         only two samples was that if the cycle counter was extremely slow,
         but just so happened to be on the cusp of a change, the slowness
         wouldn't be detected. Taking many samples fixes that to some
         degree.
    
         This, combined with the other improvements to random_get_entropy(),
         should make future unification of /dev/random and /dev/urandom
         maybe more possible. At the very least, were we to attempt it again
         today (we're not), it wouldn't break any of Guenter's test rigs
         that broke when we tried it with 5.18. So, not today, but perhaps
         down the road, that's something we can revisit.
    
       - We attempt to reseed the RNG immediately upon waking up from system
         suspend or hibernation, making use of the various timestamps about
         suspend time and such available, as well as the usual inputs such
         as RDRAND when available.
    
       - Batched randomness now falls back to ordinary randomness before the
         RNG is initialized. This provides more consistent guarantees to the
         types of random numbers being returned by the various accessors.
    
       - The "pre-init injection" code is now gone for good. I suspect you
         in particular will be happy to read that, as I recall you
         expressing your distaste for it a few months ago. Instead, to avoid
         a "premature first" issue, while still allowing for maximal amount
         of entropy availability during system boot, the first 128 bits of
         estimated entropy are used immediately as it arrives, with the next
         128 bits being buffered. And, as before, after the RNG has been
         fully initialized, it winds up reseeding anyway a few seconds later
         in most cases. This resulted in a pretty big simplification of the
         initialization code and let us remove various ad-hoc mechanisms
         like the ugly crng_pre_init_inject().
    
       - The RNG no longer pretends to handle the "premature next" security
         model, something that various academics and other RNG designs have
         tried to care about in the past. After an interesting mailing list
         thread, these issues are thought to be a) mainly academic and not
         practical at all, and b) actively harming the real security of the
         RNG by delaying new entropy additions after a potential compromise,
         making a potentially bad situation even worse. As well, in the
         first place, our RNG never even properly handled the premature next
         issue, so removing an incomplete solution to a fake problem was
         particularly nice.
    
         This allowed for numerous other simplifications in the code, which
         is a lot cleaner as a consequence. If you didn't see it before,
         https://lore.kernel.org/lkml/YmlMGx6+uigkGiZ0@zx2c4.com/ may be a
         thread worth skimming through.
    
       - While the interrupt handler received a separate code path years ago
         that avoids locks by using per-cpu data structures and a faster
         mixing algorithm, in order to reduce interrupt latency, input and
         disk events that are triggered in hardirq handlers were still
         hitting locks and more expensive algorithms. Those are now
         redirected to use the faster per-cpu data structures.
    
       - Rather than having the fake-crypto almost-siphash-based random32
         implementation be used right and left, and in many places where
         cryptographically secure randomness is desirable, the batched
         entropy code is now fast enough to replace that.
    
       - As usual, numerous code quality and documentation cleanups. For
         example, the initialization state machine now uses enum symbolic
         constants instead of just hard coding numbers everywhere.
    
       - Since the RNG initializes once, and then is always initialized
         thereafter, a pretty heavy amount of code used during that
         initialization is never used again. It is now completely cordoned
         off using static branches and it winds up in the .text.unlikely
         section so that it doesn't reduce cache compactness after the RNG
         is ready.
    
       - A variety of functions meant for waiting on the RNG to be
         initialized were only used by vsprintf, and in not a particularly
         optimal way. Replacing that usage with a more ordinary setup made
         it possible to remove those functions.
    
       - A cleanup of how we warn userspace about the use of uninitialized
         /dev/urandom and uninitialized get_random_bytes() usage.
         Interestingly, with the change you merged for 5.18 that attempts to
         use jitter (but does not block if it can't), the majority of users
         should never see those warnings for /dev/urandom at all now, and
         the one for in-kernel usage is mainly a debug thing.
    
       - The file_operations struct for /dev/[u]random now implements
         .read_iter and .write_iter instead of .read and .write, allowing it
         to also implement .splice_read and .splice_write, which makes
         splice(2) work again after it was broken here (and in many other
         places in the tree) during the set_fs() removal. This was a bit of
         a last minute arrival from Jens that hasn't had as much time to
         bake, so I'll be keeping my eye on this as well, but it seems
         fairly ordinary. Unfortunately, read_iter() is around 3% slower
         than read() in my tests, which I'm not thrilled about. But Jens and
         Al, spurred by this observation, seem to be making progress in
         removing the bottlenecks on the iter paths in the VFS layer in
         general, which should remove the performance gap for all drivers.
    
       - Assorted other bug fixes, cleanups, and optimizations.
    
       - A small SipHash cleanup"
    
    * tag 'random-5.19-rc1-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/crng/random: (49 commits)
      random: check for signals after page of pool writes
      random: wire up fops->splice_{read,write}_iter()
      random: convert to using fops->write_iter()
      random: convert to using fops->read_iter()
      random: unify batched entropy implementations
      random: move randomize_page() into mm where it belongs
      random: remove mostly unused async readiness notifier
      random: remove get_random_bytes_arch() and add rng_has_arch_random()
      random: move initialization functions out of hot pages
      random: make consistent use of buf and len
      random: use proper return types on get_random_{int,long}_wait()
      random: remove extern from functions in header
      random: use static branch for crng_ready()
      random: credit architectural init the exact amount
      random: handle latent entropy and command line from random_init()
      random: use proper jiffies comparison macro
      random: remove ratelimiting for in-kernel unseeded randomness
      random: move initialization out of reseeding hot path
      random: avoid initializing twice in credit race
      random: use symbolic constants for crng_init states
      ...

commit 6e01f86fb2025111c77101254f1442ac137089cd
Merge: fcfde8a7cf6d 317f29c14d0c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon May 23 17:05:55 2022 -0700

    Merge tag 'timers-core-2022-05-23' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer and timekeeping updates from Thomas Gleixner:
    
     - Expose CLOCK_TAI to instrumentation to aid with TSN debugging.
    
     - Ensure that the clockevent is stopped when there is no timer armed to
       avoid pointless wakeups.
    
     - Make the sched clock frequency handling and rounding consistent.
    
     - Provide a better debugobject hint for delayed works. The timer
       callback is always the same, which makes it difficult to identify the
       underlying work. Use the work function as a hint instead.
    
     - Move the timer specific sysctl code into the timer subsystem.
    
     - The usual set of improvements and cleanups
    
    * tag 'timers-core-2022-05-23' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      timers: Provide a better debugobjects hint for delayed works
      time/sched_clock: Fix formatting of frequency reporting code
      time/sched_clock: Use Hz as the unit for clock rate reporting below 4kHz
      time/sched_clock: Round the frequency reported to nearest rather than down
      timekeeping: Consolidate fast timekeeper
      timekeeping: Annotate ktime_get_boot_fast_ns() with data_race()
      timers/nohz: Switch to ONESHOT_STOPPED in the low-res handler when the tick is stopped
      timekeeping: Introduce fast accessor to clock tai
      tracing/timer: Add missing argument documentation of trace points
      clocksource: Replace cpumask_weight() with cpumask_empty()
      timers: Move timer sysctl into the timer code
      clockevents: Use dedicated list iterator variable
      timers: Simplify calc_index()
      timers: Initialize base::next_expiry_recalc in timers_prepare_cpu()

commit 1366992e16bddd5e2d9a561687f367f9f802e2e4
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sun Apr 10 16:49:50 2022 +0200

    timekeeping: Add raw clock fallback for random_get_entropy()
    
    The addition of random_get_entropy_fallback() provides access to
    whichever time source has the highest frequency, which is useful for
    gathering entropy on platforms without available cycle counters. It's
    not necessarily as good as being able to quickly access a cycle counter
    that the CPU has, but it's still something, even when it falls back to
    being jiffies-based.
    
    In the event that a given arch does not define get_cycles(), falling
    back to the get_cycles() default implementation that returns 0 is really
    not the best we can do. Instead, at least calling
    random_get_entropy_fallback() would be preferable, because that always
    needs to return _something_, even falling back to jiffies eventually.
    It's not as though random_get_entropy_fallback() is super high precision
    or guaranteed to be entropic, but basically anything that's not zero all
    the time is better than returning zero all the time.
    
    Finally, since random_get_entropy_fallback() is used during extremely
    early boot when randomizing freelists in mm_init(), it can be called
    before timekeeping has been initialized. In that case there really is
    nothing we can do; jiffies hasn't even started ticking yet. So just give
    up and return 0.
    
    Suggested-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Theodore Ts'o <tytso@mit.edu>

commit 408835832158df0357e18e96da7f2d1ed6b80e7f
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sat Apr 23 21:11:41 2022 +0200

    powerpc: define get_cycles macro for arch-override
    
    PowerPC defines a get_cycles() function, but it does not do the usual
    `#define get_cycles get_cycles` dance, making it impossible for generic
    code to see if an arch-specific function was defined. While the
    get_cycles() ifdef is not currently used, the following timekeeping
    patch in this series will depend on the macro existing (or not existing)
    when defining random_get_entropy().
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Benjamin Herrenschmidt <benh@ozlabs.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Acked-by: Michael Ellerman <mpe@ellerman.id.au>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

commit 1097710bc9660e1e588cf2186a35db3d95c4d258
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sat Apr 23 21:11:41 2022 +0200

    alpha: define get_cycles macro for arch-override
    
    Alpha defines a get_cycles() function, but it does not do the usual
    `#define get_cycles get_cycles` dance, making it impossible for generic
    code to see if an arch-specific function was defined. While the
    get_cycles() ifdef is not currently used, the following timekeeping
    patch in this series will depend on the macro existing (or not existing)
    when defining random_get_entropy().
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Richard Henderson <rth@twiddle.net>
    Cc: Ivan Kokshaysky <ink@jurassic.park.msu.ru>
    Acked-by: Matt Turner <mattst88@gmail.com>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

commit 8865bbe6ba1120e67f72201b7003a16202cd42be
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sat Apr 23 21:11:41 2022 +0200

    parisc: define get_cycles macro for arch-override
    
    PA-RISC defines a get_cycles() function, but it does not do the usual
    `#define get_cycles get_cycles` dance, making it impossible for generic
    code to see if an arch-specific function was defined. While the
    get_cycles() ifdef is not currently used, the following timekeeping
    patch in this series will depend on the macro existing (or not existing)
    when defining random_get_entropy().
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Helge Deller <deller@gmx.de>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

commit 2e3df523256cb9836de8441e9c791a796759bb3c
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sat Apr 23 21:11:41 2022 +0200

    s390: define get_cycles macro for arch-override
    
    S390x defines a get_cycles() function, but it does not do the usual
    `#define get_cycles get_cycles` dance, making it impossible for generic
    code to see if an arch-specific function was defined. While the
    get_cycles() ifdef is not currently used, the following timekeeping
    patch in this series will depend on the macro existing (or not existing)
    when defining random_get_entropy().
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Vasily Gorbik <gor@linux.ibm.com>
    Cc: Alexander Gordeev <agordeev@linux.ibm.com>
    Cc: Christian Borntraeger <borntraeger@linux.ibm.com>
    Cc: Sven Schnelle <svens@linux.ibm.com>
    Acked-by: Heiko Carstens <hca@linux.ibm.com>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

commit 57c0900b91d8891ab43f0e6b464d059fda51d102
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sat Apr 23 21:11:41 2022 +0200

    ia64: define get_cycles macro for arch-override
    
    Itanium defines a get_cycles() function, but it does not do the usual
    `#define get_cycles get_cycles` dance, making it impossible for generic
    code to see if an arch-specific function was defined. While the
    get_cycles() ifdef is not currently used, the following timekeeping
    patch in this series will depend on the macro existing (or not existing)
    when defining random_get_entropy().
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

commit 4f0685f22c8b9e296f5ae37bef11c26d2b3ba109
Author: Kurt Kanzenbach <kurt@linutronix.de>
Date:   Thu Apr 28 08:24:32 2022 +0200

    timekeeping: Mark NMI safe time accessors as notrace
    
    commit 2c33d775ef4c25c0e1e1cc0fd5496d02f76bfa20 upstream.
    
    Mark the CLOCK_MONOTONIC fast time accessors as notrace. These functions are
    used in tracing to retrieve timestamps, so they should not recurse.
    
    Fixes: 4498e7467e9e ("time: Parametrize all tk_fast_mono users")
    Fixes: f09cb9a1808e ("time: Introduce tk_fast_raw")
    Reported-by: Steven Rostedt <rostedt@goodmis.org>
    Signed-off-by: Kurt Kanzenbach <kurt@linutronix.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/20220426175338.3807ca4f@gandalf.local.home/
    Link: https://lore.kernel.org/r/20220428062432.61063-1-kurt@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 07adb69545486b16540c02a538fed5e5f250cd86
Author: Kurt Kanzenbach <kurt@linutronix.de>
Date:   Thu Apr 28 08:24:32 2022 +0200

    timekeeping: Mark NMI safe time accessors as notrace
    
    commit 2c33d775ef4c25c0e1e1cc0fd5496d02f76bfa20 upstream.
    
    Mark the CLOCK_MONOTONIC fast time accessors as notrace. These functions are
    used in tracing to retrieve timestamps, so they should not recurse.
    
    Fixes: 4498e7467e9e ("time: Parametrize all tk_fast_mono users")
    Fixes: f09cb9a1808e ("time: Introduce tk_fast_raw")
    Reported-by: Steven Rostedt <rostedt@goodmis.org>
    Signed-off-by: Kurt Kanzenbach <kurt@linutronix.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/20220426175338.3807ca4f@gandalf.local.home/
    Link: https://lore.kernel.org/r/20220428062432.61063-1-kurt@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit ea82593bad9a77f6f14c9701c13ff7368b22f027
Merge: 9692df0581ea 2c33d775ef4c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun May 8 11:18:11 2022 -0700

    Merge tag 'timers-urgent-2022-05-08' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer fix from Thomas Gleixner:
     "A fix and an email address update:
    
       - Mark the NMI safe time accessors notrace to prevent tracer
         recursion when they are selected as trace clocks.
    
       - John Stultz has a new email address"
    
    * tag 'timers-urgent-2022-05-08' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      timekeeping: Mark NMI safe time accessors as notrace
      MAINTAINERS: Update email address for John Stultz

commit 90be8d6c1f91e1e5121c219726524c91b52bfc20
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Apr 15 11:19:38 2022 +0200

    timekeeping: Consolidate fast timekeeper
    
    Provide a inline function which replaces the copy & pasta.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Link: https://lore.kernel.org/r/20220415091921.072296632@linutronix.de

commit eff4849f928f2b90402907e06a6de1619cf16b1a
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Apr 15 11:19:35 2022 +0200

    timekeeping: Annotate ktime_get_boot_fast_ns() with data_race()
    
    Accessing timekeeper::offset_boot in ktime_get_boot_fast_ns() is an
    intended data race as the reader side cannot synchronize with a writer and
    there is no space in struct tk_read_base of the NMI safe timekeeper.
    
    Mark it so.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lore.kernel.org/r/20220415091920.956045162@linutronix.de

commit 2c33d775ef4c25c0e1e1cc0fd5496d02f76bfa20
Author: Kurt Kanzenbach <kurt@linutronix.de>
Date:   Thu Apr 28 08:24:32 2022 +0200

    timekeeping: Mark NMI safe time accessors as notrace
    
    Mark the CLOCK_MONOTONIC fast time accessors as notrace. These functions are
    used in tracing to retrieve timestamps, so they should not recurse.
    
    Fixes: 4498e7467e9e ("time: Parametrize all tk_fast_mono users")
    Fixes: f09cb9a1808e ("time: Introduce tk_fast_raw")
    Reported-by: Steven Rostedt <rostedt@goodmis.org>
    Signed-off-by: Kurt Kanzenbach <kurt@linutronix.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/20220426175338.3807ca4f@gandalf.local.home/
    Link: https://lore.kernel.org/r/20220428062432.61063-1-kurt@linutronix.de

commit b4f3d5f06e29b7020f19cc788b2c2de750e888a1
Author: Samuel Holland <samuel@sholland.org>
Date:   Mon Apr 11 00:00:59 2022 -0500

    clk: sunxi-ng: sun6i-rtc: Mark rtc-32k as critical
    
    Because some newer hardware variants have multiple possible parents for
    the RTC's timekeeping clock, this driver models it as a "rtc-32k" clock.
    However, it does not add any consumer for this clock. This causes the
    common clock framework to disable it, preventing RTC time access.
    
    Since the RTC's timekeeping clock should always be enabled, regardless
    of which drivers are loaded, let's mark this clock as critical instead
    of adding a consumer in the RTC driver.
    
    Fixes: d91612d7f01a ("clk: sunxi-ng: Add support for the sun6i RTC clocks")
    Signed-off-by: Samuel Holland <samuel@sholland.org>
    Acked-by: Jernej Skrabec <jernej.skrabec@gmail.com>
    Signed-off-by: Jernej Skrabec <jernej.skrabec@gmail.com>
    Link: https://lore.kernel.org/r/20220411050100.40964-1-samuel@sholland.org

commit c3a5acf91cb96ab5cde317fe37dd5e95a12734ed
Author: Richard Guy Briggs <rgb@redhat.com>
Date:   Tue Feb 22 11:44:51 2022 -0500

    audit: log AUDIT_TIME_* records only from rules
    
    [ Upstream commit 272ceeaea355214b301530e262a0df8600bfca95 ]
    
    AUDIT_TIME_* events are generated when there are syscall rules present
    that are not related to time keeping.  This will produce noisy log
    entries that could flood the logs and hide events we really care about.
    
    Rather than immediately produce the AUDIT_TIME_* records, store the data
    in the context and log it at syscall exit time respecting the filter
    rules.
    
    Note: This eats the audit_buffer, unlike any others in show_special().
    
    Please see https://bugzilla.redhat.com/show_bug.cgi?id=1991919
    
    Fixes: 7e8eda734d30 ("ntp: Audit NTP parameters adjustment")
    Fixes: 2d87a0674bd6 ("timekeeping: Audit clock adjustments")
    Signed-off-by: Richard Guy Briggs <rgb@redhat.com>
    [PM: fixed style/whitespace issues]
    Signed-off-by: Paul Moore <paul@paul-moore.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 3dc6ffae2da201284cb24af66af77ee0bbb2efaa
Author: Kurt Kanzenbach <kurt@linutronix.de>
Date:   Thu Apr 14 11:18:03 2022 +0200

    timekeeping: Introduce fast accessor to clock tai
    
    Introduce fast/NMI safe accessor to clock tai for tracing. The Linux kernel
    tracing infrastructure has support for using different clocks to generate
    timestamps for trace events. Especially in TSN networks it's useful to have TAI
    as trace clock, because the application scheduling is done in accordance to the
    network time, which is based on TAI. With a tai trace_clock in place, it becomes
    very convenient to correlate network activity with Linux kernel application
    traces.
    
    Use the same implementation as ktime_get_boot_fast_ns() does by reading the
    monotonic time and adding the TAI offset. The same limitations as for the fast
    boot implementation apply. The TAI offset may change at run time e.g., by
    setting the time or using adjtimex() with an offset. However, these kind of
    offset changes are rare events. Nevertheless, the user has to be aware and deal
    with it in post processing.
    
    An alternative approach would be to use the same implementation as
    ktime_get_real_fast_ns() does. However, this requires to add an additional u64
    member to the tk_read_base struct. This struct together with a seqcount is
    designed to fit into a single cache line on 64 bit architectures. Adding a new
    member would violate this constraint.
    
    Signed-off-by: Kurt Kanzenbach <kurt@linutronix.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Link: https://lore.kernel.org/r/20220414091805.89667-2-kurt@linutronix.de

commit a137f93ae581668d5ad384f9cbd6cc85ee5344ac
Author: Richard Guy Briggs <rgb@redhat.com>
Date:   Tue Feb 22 11:44:51 2022 -0500

    audit: log AUDIT_TIME_* records only from rules
    
    [ Upstream commit 272ceeaea355214b301530e262a0df8600bfca95 ]
    
    AUDIT_TIME_* events are generated when there are syscall rules present
    that are not related to time keeping.  This will produce noisy log
    entries that could flood the logs and hide events we really care about.
    
    Rather than immediately produce the AUDIT_TIME_* records, store the data
    in the context and log it at syscall exit time respecting the filter
    rules.
    
    Note: This eats the audit_buffer, unlike any others in show_special().
    
    Please see https://bugzilla.redhat.com/show_bug.cgi?id=1991919
    
    Fixes: 7e8eda734d30 ("ntp: Audit NTP parameters adjustment")
    Fixes: 2d87a0674bd6 ("timekeeping: Audit clock adjustments")
    Signed-off-by: Richard Guy Briggs <rgb@redhat.com>
    [PM: fixed style/whitespace issues]
    Signed-off-by: Paul Moore <paul@paul-moore.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 3a10df7315163d60bbe24356ef9049acdb162d61
Author: Richard Guy Briggs <rgb@redhat.com>
Date:   Tue Feb 22 11:44:51 2022 -0500

    audit: log AUDIT_TIME_* records only from rules
    
    [ Upstream commit 272ceeaea355214b301530e262a0df8600bfca95 ]
    
    AUDIT_TIME_* events are generated when there are syscall rules present
    that are not related to time keeping.  This will produce noisy log
    entries that could flood the logs and hide events we really care about.
    
    Rather than immediately produce the AUDIT_TIME_* records, store the data
    in the context and log it at syscall exit time respecting the filter
    rules.
    
    Note: This eats the audit_buffer, unlike any others in show_special().
    
    Please see https://bugzilla.redhat.com/show_bug.cgi?id=1991919
    
    Fixes: 7e8eda734d30 ("ntp: Audit NTP parameters adjustment")
    Fixes: 2d87a0674bd6 ("timekeeping: Audit clock adjustments")
    Signed-off-by: Richard Guy Briggs <rgb@redhat.com>
    [PM: fixed style/whitespace issues]
    Signed-off-by: Paul Moore <paul@paul-moore.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit c7828b5d1ebe531315db9825e8ffc02c4b5f1ac3
Author: Richard Guy Briggs <rgb@redhat.com>
Date:   Tue Feb 22 11:44:51 2022 -0500

    audit: log AUDIT_TIME_* records only from rules
    
    [ Upstream commit 272ceeaea355214b301530e262a0df8600bfca95 ]
    
    AUDIT_TIME_* events are generated when there are syscall rules present
    that are not related to time keeping.  This will produce noisy log
    entries that could flood the logs and hide events we really care about.
    
    Rather than immediately produce the AUDIT_TIME_* records, store the data
    in the context and log it at syscall exit time respecting the filter
    rules.
    
    Note: This eats the audit_buffer, unlike any others in show_special().
    
    Please see https://bugzilla.redhat.com/show_bug.cgi?id=1991919
    
    Fixes: 7e8eda734d30 ("ntp: Audit NTP parameters adjustment")
    Fixes: 2d87a0674bd6 ("timekeeping: Audit clock adjustments")
    Signed-off-by: Richard Guy Briggs <rgb@redhat.com>
    [PM: fixed style/whitespace issues]
    Signed-off-by: Paul Moore <paul@paul-moore.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit d5b38d27a992c2a2e81f37aa0c2dda6ffcbc95e3
Author: Richard Guy Briggs <rgb@redhat.com>
Date:   Tue Feb 22 11:44:51 2022 -0500

    audit: log AUDIT_TIME_* records only from rules
    
    [ Upstream commit 272ceeaea355214b301530e262a0df8600bfca95 ]
    
    AUDIT_TIME_* events are generated when there are syscall rules present
    that are not related to time keeping.  This will produce noisy log
    entries that could flood the logs and hide events we really care about.
    
    Rather than immediately produce the AUDIT_TIME_* records, store the data
    in the context and log it at syscall exit time respecting the filter
    rules.
    
    Note: This eats the audit_buffer, unlike any others in show_special().
    
    Please see https://bugzilla.redhat.com/show_bug.cgi?id=1991919
    
    Fixes: 7e8eda734d30 ("ntp: Audit NTP parameters adjustment")
    Fixes: 2d87a0674bd6 ("timekeeping: Audit clock adjustments")
    Signed-off-by: Richard Guy Briggs <rgb@redhat.com>
    [PM: fixed style/whitespace issues]
    Signed-off-by: Paul Moore <paul@paul-moore.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit d91612d7f01aca454469976d25db761c5085ae4d
Author: Samuel Holland <samuel@sholland.org>
Date:   Wed Feb 2 20:17:35 2022 -0600

    clk: sunxi-ng: Add support for the sun6i RTC clocks
    
    The RTC power domain in sun6i and newer SoCs manages the 16 MHz RC
    oscillator (called "IOSC" or "osc16M") and the optional 32 kHz crystal
    oscillator (called "LOSC" or "osc32k"). Starting with the H6, this power
    domain also handles the 24 MHz DCXO (called variously "HOSC", "dcxo24M",
    or "osc24M") as well. The H6 also adds a calibration circuit for IOSC.
    
    Later SoCs introduce further variations on the design:
     - H616 adds an additional mux for the 32 kHz fanout source.
     - R329 adds an additional mux for the RTC timekeeping clock, a clock
       for the SPI bus between power domains inside the RTC, and removes the
       IOSC calibration functionality.
    
    Take advantage of the CCU framework to handle this increased complexity.
    This driver is intended to be a drop-in replacement for the existing RTC
    clock provider. So some runtime adjustment of the clock parents is
    needed, both to handle hardware differences, and to support the old
    binding which omitted some of the input clocks.
    
    Signed-off-by: Samuel Holland <samuel@sholland.org>
    Acked-by: Stephen Boyd <sboyd@kernel.org>
    Signed-off-by: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Link: https://lore.kernel.org/r/20220203021736.13434-6-samuel@sholland.org

commit 84c2e17951feeea08a1f3a01e71f8fa82b66332a
Merge: bba90e096468 b166e52541f2
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Mar 21 12:53:14 2022 -0700

    Merge tag 'timers-core-2022-03-21' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer and timekeeping updates from Thomas Gleixner:
     "Core code:
    
       - Make the NOHZ handling of the timekeeping/tick core more robust to
         prevent a rare jiffies update stall.
    
       - Handle softirqs in the NOHZ/idle case correctly
    
      Drivers:
    
       - Add support for event stream scaling of the 1GHz counter on ARM(64)
    
       - Correct an error code check in the timer-of layer
    
       - The usual cleanups and improvements all over the place"
    
    * tag 'timers-core-2022-03-21' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (23 commits)
      lib/irq_poll: Declare IRQ_POLL softirq vector as ksoftirqd-parking safe
      tick/rcu: Stop allowing RCU_SOFTIRQ in idle
      tick/rcu: Remove obsolete rcu_needs_cpu() parameters
      tick: Detect and fix jiffies update stall
      clocksource/drivers/timer-of: Check return value of of_iomap in timer_of_base_init()
      clocksource/drivers/timer-microchip-pit64b: Use 5MHz for clockevent
      clocksource/drivers/timer-microchip-pit64b: Use notrace
      clocksource/drivers/timer-microchip-pit64b: Remove mmio selection
      dt-bindings: timer: Tegra: Convert text bindings to yaml
      clocksource/drivers/imx-tpm: Move tpm_read_sched_clock() under CONFIG_ARM
      clocksource/drivers/arm_arch_timer: Use event stream scaling when available
      clocksource/drivers/exynos_mct: Increase the size of name array
      clocksource/drivers/exynos_mct: Bump up mct max irq number
      clocksource/drivers/exynos_mct: Remove mct interrupt index enum
      clocksource/drivers/exynos_mct: Handle DTS with higher number of interrupts
      clocksource/drivers/timer-ti-dm: Fix regression from errata i940 fix
      clocksource/drivers/imx-tpm: Exclude sched clock for ARM64
      clocksource: Add a Kconfig option for WATCHDOG_MAX_SKEW
      clocksource/drivers/imx-tpm: Update name of clkevt
      clocksource/drivers/imx-tpm: Add CLOCK_EVT_FEAT_DYNIRQ
      ...

commit a1ff03cd6fb9c501fff63a4a2bface9adcfa81cd
Author: Frederic Weisbecker <frederic@kernel.org>
Date:   Wed Feb 2 01:01:07 2022 +0100

    tick: Detect and fix jiffies update stall
    
    On some rare cases, the timekeeper CPU may be delaying its jiffies
    update duty for a while. Known causes include:
    
    * The timekeeper is waiting on stop_machine in a MULTI_STOP_DISABLE_IRQ
      or MULTI_STOP_RUN state. Disabled interrupts prevent from timekeeping
      updates while waiting for the target CPU to complete its
      stop_machine() callback.
    
    * The timekeeper vcpu has VMEXIT'ed for a long while due to some overload
      on the host.
    
    Detect and fix these situations with emergency timekeeping catchups.
    
    Original-patch-by: Paul E. McKenney <paulmck@kernel.org>
    Signed-off-by: Frederic Weisbecker <frederic@kernel.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>

commit 0c430ff95116c4a635e651d9be9e4e8e1163bc5d
Author: Mario Limonciello <mario.limonciello@amd.com>
Date:   Fri Jan 28 14:35:03 2022 -0600

    ACPI: PM: Revert "Only mark EC GPE for wakeup on Intel systems"
    
    [ Upstream commit d6ebb17ccc7b37872a32bc25b4a21f1e5af8c7e3 ]
    
    Testing on various upcoming OEM systems shows commit 7b167c4cb48e ("ACPI:
    PM: Only mark EC GPE for wakeup on Intel systems") was short
    sighted and the symptoms were indicative of other problems. Some OEMs
    do have the dedicated GPIOs for the power button but also rely upon
    an interrupt to the EC SCI to let the lid work.
    
    The original commit showed spurious activity on Lenovo systems:
         * On both Lenovo T14 and P14s the keyboard wakeup doesn't work, and
           sometimes the power button event doesn't work.
    
    This was confirmed on my end at that time.
    
    However further development in the kernel showed that the issue was
    actually the IRQ for the GPIO controller was also shared with the EC SCI.
    This was actually fixed by commit 2d54067fcd23 ("pinctrl: amd: Fix
    wakeups when IRQ is shared with SCI").
    
    The original commit also showed problems with AC adapter:
         * On HP 635 G7 detaching or attaching AC during suspend will cause
           the system not to wakeup
         * On Asus vivobook to prevent detaching AC causing resume problems
         * On Lenovo 14ARE05 to prevent detaching AC causing resume problems
         * On HP ENVY x360  to prevent detaching AC causing resume problems
    
    Detaching AC adapter causing problems appears to have been a problem
    because the EC SCI went off to notify the OS of the power adapter change
    but the SCI was ignored and there was no other way to wake up this system
    since GPIO controller wasn't properly enabled.  The wakeups were fixed by
    enabling the GPIO controller in commit acd47b9f28e5 ("pinctrl: amd: Handle
    wake-up interrupt").
    
    I've confirmed on a variety of OEM notebooks with the following test
    
     1) echo 1 | sudo tee /sys/power/pm_debug_messages
     2) sudo systemctl suspend
     3) unplug AC adapter, make sure system is still asleep
     4) wake system from lid (which is provided by ACPI SCI on some of them)
     5) dmesg
        a) see the EC GPE dispatched, timekeeping for X seconds (matching ~time
           until AC adapter plug out)
        b) see timekeeping for Y seconds until woke (matching ~time from AC
           adapter until lid event)
     6) Look at /sys/kernel/debug/amd_pmc/s0ix_stats
        "Time (in us) in S0i3" = X + Y - firmware processing time
    
    Signed-off-by: Mario Limonciello <mario.limonciello@amd.com>
    Tested-by: Kai-Heng Feng <kai.heng.feng@canonical.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 0044583276952621822022b6ff8f5dc54c246f9a
Author: Mario Limonciello <mario.limonciello@amd.com>
Date:   Fri Jan 28 14:35:03 2022 -0600

    ACPI: PM: Revert "Only mark EC GPE for wakeup on Intel systems"
    
    [ Upstream commit d6ebb17ccc7b37872a32bc25b4a21f1e5af8c7e3 ]
    
    Testing on various upcoming OEM systems shows commit 7b167c4cb48e ("ACPI:
    PM: Only mark EC GPE for wakeup on Intel systems") was short
    sighted and the symptoms were indicative of other problems. Some OEMs
    do have the dedicated GPIOs for the power button but also rely upon
    an interrupt to the EC SCI to let the lid work.
    
    The original commit showed spurious activity on Lenovo systems:
         * On both Lenovo T14 and P14s the keyboard wakeup doesn't work, and
           sometimes the power button event doesn't work.
    
    This was confirmed on my end at that time.
    
    However further development in the kernel showed that the issue was
    actually the IRQ for the GPIO controller was also shared with the EC SCI.
    This was actually fixed by commit 2d54067fcd23 ("pinctrl: amd: Fix
    wakeups when IRQ is shared with SCI").
    
    The original commit also showed problems with AC adapter:
         * On HP 635 G7 detaching or attaching AC during suspend will cause
           the system not to wakeup
         * On Asus vivobook to prevent detaching AC causing resume problems
         * On Lenovo 14ARE05 to prevent detaching AC causing resume problems
         * On HP ENVY x360  to prevent detaching AC causing resume problems
    
    Detaching AC adapter causing problems appears to have been a problem
    because the EC SCI went off to notify the OS of the power adapter change
    but the SCI was ignored and there was no other way to wake up this system
    since GPIO controller wasn't properly enabled.  The wakeups were fixed by
    enabling the GPIO controller in commit acd47b9f28e5 ("pinctrl: amd: Handle
    wake-up interrupt").
    
    I've confirmed on a variety of OEM notebooks with the following test
    
     1) echo 1 | sudo tee /sys/power/pm_debug_messages
     2) sudo systemctl suspend
     3) unplug AC adapter, make sure system is still asleep
     4) wake system from lid (which is provided by ACPI SCI on some of them)
     5) dmesg
        a) see the EC GPE dispatched, timekeeping for X seconds (matching ~time
           until AC adapter plug out)
        b) see timekeeping for Y seconds until woke (matching ~time from AC
           adapter until lid event)
     6) Look at /sys/kernel/debug/amd_pmc/s0ix_stats
        "Time (in us) in S0i3" = X + Y - firmware processing time
    
    Signed-off-by: Mario Limonciello <mario.limonciello@amd.com>
    Tested-by: Kai-Heng Feng <kai.heng.feng@canonical.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 272ceeaea355214b301530e262a0df8600bfca95
Author: Richard Guy Briggs <rgb@redhat.com>
Date:   Tue Feb 22 11:44:51 2022 -0500

    audit: log AUDIT_TIME_* records only from rules
    
    AUDIT_TIME_* events are generated when there are syscall rules present
    that are not related to time keeping.  This will produce noisy log
    entries that could flood the logs and hide events we really care about.
    
    Rather than immediately produce the AUDIT_TIME_* records, store the data
    in the context and log it at syscall exit time respecting the filter
    rules.
    
    Note: This eats the audit_buffer, unlike any others in show_special().
    
    Please see https://bugzilla.redhat.com/show_bug.cgi?id=1991919
    
    Fixes: 7e8eda734d30 ("ntp: Audit NTP parameters adjustment")
    Fixes: 2d87a0674bd6 ("timekeeping: Audit clock adjustments")
    Signed-off-by: Richard Guy Briggs <rgb@redhat.com>
    [PM: fixed style/whitespace issues]
    Signed-off-by: Paul Moore <paul@paul-moore.com>

commit 80e4e1f472889f31a4dcaea3a4eb7a565296f1f3
Author: Barry Song <song.bao.hua@hisilicon.com>
Date:   Sun Feb 20 19:19:10 2022 +1300

    irqchip/gic-v3: Use dsb(ishst) to order writes with ICC_SGI1R_EL1 accesses
    
    A dsb(ishst) barrier should be enough to order previous writes with
    the system register generating the SGI, as we only need to guarantee
    the visibility of data to other CPUs in the inner shareable domain
    before we send the SGI.
    
    A micro-benchmark is written to verify the performance impact on
    kunpeng920 machine with 2 sockets, each socket has 2 dies, and
    each die has 24 CPUs, so totally the system has 2 * 2 * 24 = 96
    CPUs. ~2% performance improvement can be seen by this benchmark.
    
    The code of benchmark module:
    
     #include <linux/module.h>
     #include <linux/timekeeping.h>
    
     volatile int data0 ____cacheline_aligned;
     volatile int data1 ____cacheline_aligned;
     volatile int data2 ____cacheline_aligned;
     volatile int data3 ____cacheline_aligned;
     volatile int data4 ____cacheline_aligned;
     volatile int data5 ____cacheline_aligned;
     volatile int data6 ____cacheline_aligned;
    
     static void ipi_latency_func(void *val)
     {
     }
    
     static int __init ipi_latency_init(void)
     {
            ktime_t stime, etime, delta;
            int cpu, i;
            int start = smp_processor_id();
    
            stime = ktime_get();
            for ( i = 0; i < 1000; i++)
                    for (cpu = 0; cpu < 96; cpu++) {
                            data0 = data1 = data2 = data3 = data4 = data5 = data6 = cpu;
                            smp_call_function_single(cpu, ipi_latency_func, NULL, 1);
                    }
            etime = ktime_get();
    
            delta = ktime_sub(etime, stime);
    
            printk("%s ipi from cpu%d to cpu0-95 delta of 1000times:%lld\n",
                            __func__, start, delta);
    
            return 0;
     }
     module_init(ipi_latency_init);
    
     static void ipi_latency_exit(void)
     {
     }
     module_exit(ipi_latency_exit);
    
     MODULE_DESCRIPTION("IPI benchmark");
     MODULE_LICENSE("GPL");
    
    run the below commands 10 times on both Vanilla and the kernel with this
    patch:
     # taskset -c 0 insmod test.ko
     # rmmod test
    
    The result on vanilla:
     ipi_latency_init ipi from cpu0 to cpu0-95 delta of 1000times:126757449
     ipi_latency_init ipi from cpu0 to cpu0-95 delta of 1000times:126784249
     ipi_latency_init ipi from cpu0 to cpu0-95 delta of 1000times:126177703
     ipi_latency_init ipi from cpu0 to cpu0-95 delta of 1000times:127022281
     ipi_latency_init ipi from cpu0 to cpu0-95 delta of 1000times:126184883
     ipi_latency_init ipi from cpu0 to cpu0-95 delta of 1000times:127374585
     ipi_latency_init ipi from cpu0 to cpu0-95 delta of 1000times:125778089
     ipi_latency_init ipi from cpu0 to cpu0-95 delta of 1000times:126974441
     ipi_latency_init ipi from cpu0 to cpu0-95 delta of 1000times:127357625
     ipi_latency_init ipi from cpu0 to cpu0-95 delta of 1000times:126228184
    
    The result on the kernel with this patch:
     ipi_latency_init ipi from cpu0 to cpu0-95 delta of 1000times:124467401
     ipi_latency_init ipi from cpu0 to cpu0-95 delta of 1000times:123474209
     ipi_latency_init ipi from cpu0 to cpu0-95 delta of 1000times:123558497
     ipi_latency_init ipi from cpu0 to cpu0-95 delta of 1000times:122993951
     ipi_latency_init ipi from cpu0 to cpu0-95 delta of 1000times:122984223
     ipi_latency_init ipi from cpu0 to cpu0-95 delta of 1000times:123323609
     ipi_latency_init ipi from cpu0 to cpu0-95 delta of 1000times:124507583
     ipi_latency_init ipi from cpu0 to cpu0-95 delta of 1000times:123386963
     ipi_latency_init ipi from cpu0 to cpu0-95 delta of 1000times:123340664
     ipi_latency_init ipi from cpu0 to cpu0-95 delta of 1000times:123285324
    
    Signed-off-by: Barry Song <song.bao.hua@hisilicon.com>
    [maz: tidied up commit message]
    Signed-off-by: Marc Zyngier <maz@kernel.org>
    Link: https://lore.kernel.org/r/20220220061910.6155-1-21cnbao@gmail.com

commit 2fa9c57af062ded71e68462264d315a547c72da2
Author: Danilo Krummrich <danilokrummrich@dk-develop.de>
Date:   Tue Feb 15 14:39:12 2022 -0800

    Input: ps2-gpio - use ktime for IRQ timekeeping
    
    Using jiffies for the IRQ timekeeping is not sufficient for two reasons:
    
    (1) Usually jiffies have a resolution of 1ms to 10ms. The IRQ intervals
        based on the clock frequency of PS2 protocol specification (10kHz -
        16.7kHz) are between ~60us and 100us only. Therefore only those IRQ
        intervals can be detected which are either at the end of a transfer
        or are overly delayed. While this is sufficient in most cases, since
        we have quite a lot of ways to detect faulty transfers, it can
        produce false positives in rare cases: When the jiffies value
        changes right between two interrupt that are in time, we wrongly
        assume that we missed one or more clock cycles.
    
    (2) Some gpio controllers (e.g. the one in the bcm283x chips) may generate
        spurious IRQs when processing interrupts in the frequency given by PS2
        devices.
    
    Both issues can be fixed by using ktime resolution for IRQ timekeeping.
    
    However, it is still possible to miss clock cycles without detecting
    them. When the PS2 device generates the falling edge of the clock signal
    we have between ~30us and 50us to sample the data line, because after
    this time we reach the next rising edge at which the device changes the
    data signal already. But, the only thing we can detect is whether the
    IRQ interval is within the given period. Therefore it is possible to
    have an IRQ latency greater than ~30us to 50us, sample the wrong bit on
    the data line and still be on time with the next IRQ. However, this can
    only happen when within a given transfer the IRQ latency increases
    slowly.
    
    ___            ______            ______            ______            ___
       \          /      \          /      \          /      \          /
        \        /        \        /        \        /        \        /
         \______/          \______/          \______/          \______/
    
        |-----------------|                 |--------|
             60us/100us                      30us/50us
    
    Signed-off-by: Danilo Krummrich <danilokrummrich@dk-develop.de>
    Link: https://lore.kernel.org/r/20220215160208.34826-3-danilokrummrich@dk-develop.de
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

commit d6ebb17ccc7b37872a32bc25b4a21f1e5af8c7e3
Author: Mario Limonciello <mario.limonciello@amd.com>
Date:   Fri Jan 28 14:35:03 2022 -0600

    ACPI: PM: Revert "Only mark EC GPE for wakeup on Intel systems"
    
    Testing on various upcoming OEM systems shows commit 7b167c4cb48e ("ACPI:
    PM: Only mark EC GPE for wakeup on Intel systems") was short
    sighted and the symptoms were indicative of other problems. Some OEMs
    do have the dedicated GPIOs for the power button but also rely upon
    an interrupt to the EC SCI to let the lid work.
    
    The original commit showed spurious activity on Lenovo systems:
         * On both Lenovo T14 and P14s the keyboard wakeup doesn't work, and
           sometimes the power button event doesn't work.
    
    This was confirmed on my end at that time.
    
    However further development in the kernel showed that the issue was
    actually the IRQ for the GPIO controller was also shared with the EC SCI.
    This was actually fixed by commit 2d54067fcd23 ("pinctrl: amd: Fix
    wakeups when IRQ is shared with SCI").
    
    The original commit also showed problems with AC adapter:
         * On HP 635 G7 detaching or attaching AC during suspend will cause
           the system not to wakeup
         * On Asus vivobook to prevent detaching AC causing resume problems
         * On Lenovo 14ARE05 to prevent detaching AC causing resume problems
         * On HP ENVY x360  to prevent detaching AC causing resume problems
    
    Detaching AC adapter causing problems appears to have been a problem
    because the EC SCI went off to notify the OS of the power adapter change
    but the SCI was ignored and there was no other way to wake up this system
    since GPIO controller wasn't properly enabled.  The wakeups were fixed by
    enabling the GPIO controller in commit acd47b9f28e5 ("pinctrl: amd: Handle
    wake-up interrupt").
    
    I've confirmed on a variety of OEM notebooks with the following test
    
     1) echo 1 | sudo tee /sys/power/pm_debug_messages
     2) sudo systemctl suspend
     3) unplug AC adapter, make sure system is still asleep
     4) wake system from lid (which is provided by ACPI SCI on some of them)
     5) dmesg
        a) see the EC GPE dispatched, timekeeping for X seconds (matching ~time
           until AC adapter plug out)
        b) see timekeeping for Y seconds until woke (matching ~time from AC
           adapter until lid event)
     6) Look at /sys/kernel/debug/amd_pmc/s0ix_stats
        "Time (in us) in S0i3" = X + Y - firmware processing time
    
    Signed-off-by: Mario Limonciello <mario.limonciello@amd.com>
    Tested-by: Kai-Heng Feng <kai.heng.feng@canonical.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 3b7a7602b2e041f156cf7a1b4fb8cbe0eb506dc1
Author: Waiman Long <longman@redhat.com>
Date:   Thu Nov 18 14:14:36 2021 -0500

    clocksource: Avoid accidental unstable marking of clocksources
    
    [ Upstream commit c86ff8c55b8ae68837b2fa59dc0c203907e9a15f ]
    
    Since commit db3a34e17433 ("clocksource: Retry clock read if long delays
    detected") and commit 2e27e793e280 ("clocksource: Reduce clocksource-skew
    threshold"), it is found that tsc clocksource fallback to hpet can
    sometimes happen on both Intel and AMD systems especially when they are
    running stressful benchmarking workloads. Of the 23 systems tested with
    a v5.14 kernel, 10 of them have switched to hpet clock source during
    the test run.
    
    The result of falling back to hpet is a drastic reduction of performance
    when running benchmarks. For example, the fio performance tests can
    drop up to 70% whereas the iperf3 performance can drop up to 80%.
    
    4 hpet fallbacks happened during bootup. They were:
    
      [    8.749399] clocksource: timekeeping watchdog on CPU13: hpet read-back delay of 263750ns, attempt 4, marking unstable
      [   12.044610] clocksource: timekeeping watchdog on CPU19: hpet read-back delay of 186166ns, attempt 4, marking unstable
      [   17.336941] clocksource: timekeeping watchdog on CPU28: hpet read-back delay of 182291ns, attempt 4, marking unstable
      [   17.518565] clocksource: timekeeping watchdog on CPU34: hpet read-back delay of 252196ns, attempt 4, marking unstable
    
    Other fallbacks happen when the systems were running stressful
    benchmarks. For example:
    
      [ 2685.867873] clocksource: timekeeping watchdog on CPU117: hpet read-back delay of 57269ns, attempt 4, marking unstable
      [46215.471228] clocksource: timekeeping watchdog on CPU8: hpet read-back delay of 61460ns, attempt 4, marking unstable
    
    Commit 2e27e793e280 ("clocksource: Reduce clocksource-skew threshold"),
    changed the skew margin from 100us to 50us. I think this is too small
    and can easily be exceeded when running some stressful workloads on a
    thermally stressed system.  So it is switched back to 100us.
    
    Even a maximum skew margin of 100us may be too small in for some systems
    when booting up especially if those systems are under thermal stress. To
    eliminate the case that the large skew is due to the system being too
    busy slowing down the reading of both the watchdog and the clocksource,
    an extra consecutive read of watchdog clock is being done to check this.
    
    The consecutive watchdog read delay is compared against
    WATCHDOG_MAX_SKEW/2. If the delay exceeds the limit, we assume that
    the system is just too busy. A warning will be printed to the console
    and the clock skew check is skipped for this round.
    
    Fixes: db3a34e17433 ("clocksource: Retry clock read if long delays detected")
    Fixes: 2e27e793e280 ("clocksource: Reduce clocksource-skew threshold")
    Signed-off-by: Waiman Long <longman@redhat.com>
    Signed-off-by: Paul E. McKenney <paulmck@kernel.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit cf9b8de20168ddeb261a1e2d4f918d3c0d502fc5
Author: Waiman Long <longman@redhat.com>
Date:   Thu Nov 18 14:14:36 2021 -0500

    clocksource: Avoid accidental unstable marking of clocksources
    
    [ Upstream commit c86ff8c55b8ae68837b2fa59dc0c203907e9a15f ]
    
    Since commit db3a34e17433 ("clocksource: Retry clock read if long delays
    detected") and commit 2e27e793e280 ("clocksource: Reduce clocksource-skew
    threshold"), it is found that tsc clocksource fallback to hpet can
    sometimes happen on both Intel and AMD systems especially when they are
    running stressful benchmarking workloads. Of the 23 systems tested with
    a v5.14 kernel, 10 of them have switched to hpet clock source during
    the test run.
    
    The result of falling back to hpet is a drastic reduction of performance
    when running benchmarks. For example, the fio performance tests can
    drop up to 70% whereas the iperf3 performance can drop up to 80%.
    
    4 hpet fallbacks happened during bootup. They were:
    
      [    8.749399] clocksource: timekeeping watchdog on CPU13: hpet read-back delay of 263750ns, attempt 4, marking unstable
      [   12.044610] clocksource: timekeeping watchdog on CPU19: hpet read-back delay of 186166ns, attempt 4, marking unstable
      [   17.336941] clocksource: timekeeping watchdog on CPU28: hpet read-back delay of 182291ns, attempt 4, marking unstable
      [   17.518565] clocksource: timekeeping watchdog on CPU34: hpet read-back delay of 252196ns, attempt 4, marking unstable
    
    Other fallbacks happen when the systems were running stressful
    benchmarks. For example:
    
      [ 2685.867873] clocksource: timekeeping watchdog on CPU117: hpet read-back delay of 57269ns, attempt 4, marking unstable
      [46215.471228] clocksource: timekeeping watchdog on CPU8: hpet read-back delay of 61460ns, attempt 4, marking unstable
    
    Commit 2e27e793e280 ("clocksource: Reduce clocksource-skew threshold"),
    changed the skew margin from 100us to 50us. I think this is too small
    and can easily be exceeded when running some stressful workloads on a
    thermally stressed system.  So it is switched back to 100us.
    
    Even a maximum skew margin of 100us may be too small in for some systems
    when booting up especially if those systems are under thermal stress. To
    eliminate the case that the large skew is due to the system being too
    busy slowing down the reading of both the watchdog and the clocksource,
    an extra consecutive read of watchdog clock is being done to check this.
    
    The consecutive watchdog read delay is compared against
    WATCHDOG_MAX_SKEW/2. If the delay exceeds the limit, we assume that
    the system is just too busy. A warning will be printed to the console
    and the clock skew check is skipped for this round.
    
    Fixes: db3a34e17433 ("clocksource: Retry clock read if long delays detected")
    Fixes: 2e27e793e280 ("clocksource: Reduce clocksource-skew threshold")
    Signed-off-by: Waiman Long <longman@redhat.com>
    Signed-off-by: Paul E. McKenney <paulmck@kernel.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit fd99aeb978451eee9e623be496cd6f9bbbc95e37
Author: Waiman Long <longman@redhat.com>
Date:   Thu Nov 18 14:14:36 2021 -0500

    clocksource: Avoid accidental unstable marking of clocksources
    
    [ Upstream commit c86ff8c55b8ae68837b2fa59dc0c203907e9a15f ]
    
    Since commit db3a34e17433 ("clocksource: Retry clock read if long delays
    detected") and commit 2e27e793e280 ("clocksource: Reduce clocksource-skew
    threshold"), it is found that tsc clocksource fallback to hpet can
    sometimes happen on both Intel and AMD systems especially when they are
    running stressful benchmarking workloads. Of the 23 systems tested with
    a v5.14 kernel, 10 of them have switched to hpet clock source during
    the test run.
    
    The result of falling back to hpet is a drastic reduction of performance
    when running benchmarks. For example, the fio performance tests can
    drop up to 70% whereas the iperf3 performance can drop up to 80%.
    
    4 hpet fallbacks happened during bootup. They were:
    
      [    8.749399] clocksource: timekeeping watchdog on CPU13: hpet read-back delay of 263750ns, attempt 4, marking unstable
      [   12.044610] clocksource: timekeeping watchdog on CPU19: hpet read-back delay of 186166ns, attempt 4, marking unstable
      [   17.336941] clocksource: timekeeping watchdog on CPU28: hpet read-back delay of 182291ns, attempt 4, marking unstable
      [   17.518565] clocksource: timekeeping watchdog on CPU34: hpet read-back delay of 252196ns, attempt 4, marking unstable
    
    Other fallbacks happen when the systems were running stressful
    benchmarks. For example:
    
      [ 2685.867873] clocksource: timekeeping watchdog on CPU117: hpet read-back delay of 57269ns, attempt 4, marking unstable
      [46215.471228] clocksource: timekeeping watchdog on CPU8: hpet read-back delay of 61460ns, attempt 4, marking unstable
    
    Commit 2e27e793e280 ("clocksource: Reduce clocksource-skew threshold"),
    changed the skew margin from 100us to 50us. I think this is too small
    and can easily be exceeded when running some stressful workloads on a
    thermally stressed system.  So it is switched back to 100us.
    
    Even a maximum skew margin of 100us may be too small in for some systems
    when booting up especially if those systems are under thermal stress. To
    eliminate the case that the large skew is due to the system being too
    busy slowing down the reading of both the watchdog and the clocksource,
    an extra consecutive read of watchdog clock is being done to check this.
    
    The consecutive watchdog read delay is compared against
    WATCHDOG_MAX_SKEW/2. If the delay exceeds the limit, we assume that
    the system is just too busy. A warning will be printed to the console
    and the clock skew check is skipped for this round.
    
    Fixes: db3a34e17433 ("clocksource: Retry clock read if long delays detected")
    Fixes: 2e27e793e280 ("clocksource: Reduce clocksource-skew threshold")
    Signed-off-by: Waiman Long <longman@redhat.com>
    Signed-off-by: Paul E. McKenney <paulmck@kernel.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit c5664d508674c77a52d311af8b1e11d08ac0cf4b
Author: Yu Liao <liaoyu15@huawei.com>
Date:   Mon Dec 13 21:57:27 2021 +0800

    timekeeping: Really make sure wall_to_monotonic isn't positive
    
    commit 4e8c11b6b3f0b6a283e898344f154641eda94266 upstream.
    
    Even after commit e1d7ba873555 ("time: Always make sure wall_to_monotonic
    isn't positive") it is still possible to make wall_to_monotonic positive
    by running the following code:
    
        int main(void)
        {
            struct timespec time;
    
            clock_gettime(CLOCK_MONOTONIC, &time);
            time.tv_nsec = 0;
            clock_settime(CLOCK_REALTIME, &time);
            return 0;
        }
    
    The reason is that the second parameter of timespec64_compare(), ts_delta,
    may be unnormalized because the delta is calculated with an open coded
    substraction which causes the comparison of tv_sec to yield the wrong
    result:
    
      wall_to_monotonic = { .tv_sec = -10, .tv_nsec =  900000000 }
      ts_delta          = { .tv_sec =  -9, .tv_nsec = -900000000 }
    
    That makes timespec64_compare() claim that wall_to_monotonic < ts_delta,
    but actually the result should be wall_to_monotonic > ts_delta.
    
    After normalization, the result of timespec64_compare() is correct because
    the tv_sec comparison is not longer misleading:
    
      wall_to_monotonic = { .tv_sec = -10, .tv_nsec =  900000000 }
      ts_delta          = { .tv_sec = -10, .tv_nsec =  100000000 }
    
    Use timespec64_sub() to ensure that ts_delta is normalized, which fixes the
    issue.
    
    Fixes: e1d7ba873555 ("time: Always make sure wall_to_monotonic isn't positive")
    Signed-off-by: Yu Liao <liaoyu15@huawei.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/20211213135727.1656662-1-liaoyu15@huawei.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit a9f2c6af5a601a2e2bf40e5561bedc87a44d9649
Author: Yu Liao <liaoyu15@huawei.com>
Date:   Mon Dec 13 21:57:27 2021 +0800

    timekeeping: Really make sure wall_to_monotonic isn't positive
    
    commit 4e8c11b6b3f0b6a283e898344f154641eda94266 upstream.
    
    Even after commit e1d7ba873555 ("time: Always make sure wall_to_monotonic
    isn't positive") it is still possible to make wall_to_monotonic positive
    by running the following code:
    
        int main(void)
        {
            struct timespec time;
    
            clock_gettime(CLOCK_MONOTONIC, &time);
            time.tv_nsec = 0;
            clock_settime(CLOCK_REALTIME, &time);
            return 0;
        }
    
    The reason is that the second parameter of timespec64_compare(), ts_delta,
    may be unnormalized because the delta is calculated with an open coded
    substraction which causes the comparison of tv_sec to yield the wrong
    result:
    
      wall_to_monotonic = { .tv_sec = -10, .tv_nsec =  900000000 }
      ts_delta          = { .tv_sec =  -9, .tv_nsec = -900000000 }
    
    That makes timespec64_compare() claim that wall_to_monotonic < ts_delta,
    but actually the result should be wall_to_monotonic > ts_delta.
    
    After normalization, the result of timespec64_compare() is correct because
    the tv_sec comparison is not longer misleading:
    
      wall_to_monotonic = { .tv_sec = -10, .tv_nsec =  900000000 }
      ts_delta          = { .tv_sec = -10, .tv_nsec =  100000000 }
    
    Use timespec64_sub() to ensure that ts_delta is normalized, which fixes the
    issue.
    
    Fixes: e1d7ba873555 ("time: Always make sure wall_to_monotonic isn't positive")
    Signed-off-by: Yu Liao <liaoyu15@huawei.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/20211213135727.1656662-1-liaoyu15@huawei.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 62889094939c5fc0c43b207396e51bde905be1ca
Author: Yu Liao <liaoyu15@huawei.com>
Date:   Mon Dec 13 21:57:27 2021 +0800

    timekeeping: Really make sure wall_to_monotonic isn't positive
    
    commit 4e8c11b6b3f0b6a283e898344f154641eda94266 upstream.
    
    Even after commit e1d7ba873555 ("time: Always make sure wall_to_monotonic
    isn't positive") it is still possible to make wall_to_monotonic positive
    by running the following code:
    
        int main(void)
        {
            struct timespec time;
    
            clock_gettime(CLOCK_MONOTONIC, &time);
            time.tv_nsec = 0;
            clock_settime(CLOCK_REALTIME, &time);
            return 0;
        }
    
    The reason is that the second parameter of timespec64_compare(), ts_delta,
    may be unnormalized because the delta is calculated with an open coded
    substraction which causes the comparison of tv_sec to yield the wrong
    result:
    
      wall_to_monotonic = { .tv_sec = -10, .tv_nsec =  900000000 }
      ts_delta          = { .tv_sec =  -9, .tv_nsec = -900000000 }
    
    That makes timespec64_compare() claim that wall_to_monotonic < ts_delta,
    but actually the result should be wall_to_monotonic > ts_delta.
    
    After normalization, the result of timespec64_compare() is correct because
    the tv_sec comparison is not longer misleading:
    
      wall_to_monotonic = { .tv_sec = -10, .tv_nsec =  900000000 }
      ts_delta          = { .tv_sec = -10, .tv_nsec =  100000000 }
    
    Use timespec64_sub() to ensure that ts_delta is normalized, which fixes the
    issue.
    
    Fixes: e1d7ba873555 ("time: Always make sure wall_to_monotonic isn't positive")
    Signed-off-by: Yu Liao <liaoyu15@huawei.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/20211213135727.1656662-1-liaoyu15@huawei.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 8938a4473e6244dff5c4ff3579e7b6d880d1f68c
Author: Yu Liao <liaoyu15@huawei.com>
Date:   Mon Dec 13 21:57:27 2021 +0800

    timekeeping: Really make sure wall_to_monotonic isn't positive
    
    commit 4e8c11b6b3f0b6a283e898344f154641eda94266 upstream.
    
    Even after commit e1d7ba873555 ("time: Always make sure wall_to_monotonic
    isn't positive") it is still possible to make wall_to_monotonic positive
    by running the following code:
    
        int main(void)
        {
            struct timespec time;
    
            clock_gettime(CLOCK_MONOTONIC, &time);
            time.tv_nsec = 0;
            clock_settime(CLOCK_REALTIME, &time);
            return 0;
        }
    
    The reason is that the second parameter of timespec64_compare(), ts_delta,
    may be unnormalized because the delta is calculated with an open coded
    substraction which causes the comparison of tv_sec to yield the wrong
    result:
    
      wall_to_monotonic = { .tv_sec = -10, .tv_nsec =  900000000 }
      ts_delta          = { .tv_sec =  -9, .tv_nsec = -900000000 }
    
    That makes timespec64_compare() claim that wall_to_monotonic < ts_delta,
    but actually the result should be wall_to_monotonic > ts_delta.
    
    After normalization, the result of timespec64_compare() is correct because
    the tv_sec comparison is not longer misleading:
    
      wall_to_monotonic = { .tv_sec = -10, .tv_nsec =  900000000 }
      ts_delta          = { .tv_sec = -10, .tv_nsec =  100000000 }
    
    Use timespec64_sub() to ensure that ts_delta is normalized, which fixes the
    issue.
    
    Fixes: e1d7ba873555 ("time: Always make sure wall_to_monotonic isn't positive")
    Signed-off-by: Yu Liao <liaoyu15@huawei.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/20211213135727.1656662-1-liaoyu15@huawei.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit c0b25c6d1b91da64069c3c364e68775ad6d5437c
Author: Yu Liao <liaoyu15@huawei.com>
Date:   Mon Dec 13 21:57:27 2021 +0800

    timekeeping: Really make sure wall_to_monotonic isn't positive
    
    commit 4e8c11b6b3f0b6a283e898344f154641eda94266 upstream.
    
    Even after commit e1d7ba873555 ("time: Always make sure wall_to_monotonic
    isn't positive") it is still possible to make wall_to_monotonic positive
    by running the following code:
    
        int main(void)
        {
            struct timespec time;
    
            clock_gettime(CLOCK_MONOTONIC, &time);
            time.tv_nsec = 0;
            clock_settime(CLOCK_REALTIME, &time);
            return 0;
        }
    
    The reason is that the second parameter of timespec64_compare(), ts_delta,
    may be unnormalized because the delta is calculated with an open coded
    substraction which causes the comparison of tv_sec to yield the wrong
    result:
    
      wall_to_monotonic = { .tv_sec = -10, .tv_nsec =  900000000 }
      ts_delta          = { .tv_sec =  -9, .tv_nsec = -900000000 }
    
    That makes timespec64_compare() claim that wall_to_monotonic < ts_delta,
    but actually the result should be wall_to_monotonic > ts_delta.
    
    After normalization, the result of timespec64_compare() is correct because
    the tv_sec comparison is not longer misleading:
    
      wall_to_monotonic = { .tv_sec = -10, .tv_nsec =  900000000 }
      ts_delta          = { .tv_sec = -10, .tv_nsec =  100000000 }
    
    Use timespec64_sub() to ensure that ts_delta is normalized, which fixes the
    issue.
    
    Fixes: e1d7ba873555 ("time: Always make sure wall_to_monotonic isn't positive")
    Signed-off-by: Yu Liao <liaoyu15@huawei.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/20211213135727.1656662-1-liaoyu15@huawei.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 848a0e10fde6575bc3fa5253e9afc45444902cc7
Author: Yu Liao <liaoyu15@huawei.com>
Date:   Mon Dec 13 21:57:27 2021 +0800

    timekeeping: Really make sure wall_to_monotonic isn't positive
    
    commit 4e8c11b6b3f0b6a283e898344f154641eda94266 upstream.
    
    Even after commit e1d7ba873555 ("time: Always make sure wall_to_monotonic
    isn't positive") it is still possible to make wall_to_monotonic positive
    by running the following code:
    
        int main(void)
        {
            struct timespec time;
    
            clock_gettime(CLOCK_MONOTONIC, &time);
            time.tv_nsec = 0;
            clock_settime(CLOCK_REALTIME, &time);
            return 0;
        }
    
    The reason is that the second parameter of timespec64_compare(), ts_delta,
    may be unnormalized because the delta is calculated with an open coded
    substraction which causes the comparison of tv_sec to yield the wrong
    result:
    
      wall_to_monotonic = { .tv_sec = -10, .tv_nsec =  900000000 }
      ts_delta          = { .tv_sec =  -9, .tv_nsec = -900000000 }
    
    That makes timespec64_compare() claim that wall_to_monotonic < ts_delta,
    but actually the result should be wall_to_monotonic > ts_delta.
    
    After normalization, the result of timespec64_compare() is correct because
    the tv_sec comparison is not longer misleading:
    
      wall_to_monotonic = { .tv_sec = -10, .tv_nsec =  900000000 }
      ts_delta          = { .tv_sec = -10, .tv_nsec =  100000000 }
    
    Use timespec64_sub() to ensure that ts_delta is normalized, which fixes the
    issue.
    
    Fixes: e1d7ba873555 ("time: Always make sure wall_to_monotonic isn't positive")
    Signed-off-by: Yu Liao <liaoyu15@huawei.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/20211213135727.1656662-1-liaoyu15@huawei.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit ed5dc41bb48e82478525c08c87a4c88847e8570c
Author: Yu Liao <liaoyu15@huawei.com>
Date:   Mon Dec 13 21:57:27 2021 +0800

    timekeeping: Really make sure wall_to_monotonic isn't positive
    
    commit 4e8c11b6b3f0b6a283e898344f154641eda94266 upstream.
    
    Even after commit e1d7ba873555 ("time: Always make sure wall_to_monotonic
    isn't positive") it is still possible to make wall_to_monotonic positive
    by running the following code:
    
        int main(void)
        {
            struct timespec time;
    
            clock_gettime(CLOCK_MONOTONIC, &time);
            time.tv_nsec = 0;
            clock_settime(CLOCK_REALTIME, &time);
            return 0;
        }
    
    The reason is that the second parameter of timespec64_compare(), ts_delta,
    may be unnormalized because the delta is calculated with an open coded
    substraction which causes the comparison of tv_sec to yield the wrong
    result:
    
      wall_to_monotonic = { .tv_sec = -10, .tv_nsec =  900000000 }
      ts_delta          = { .tv_sec =  -9, .tv_nsec = -900000000 }
    
    That makes timespec64_compare() claim that wall_to_monotonic < ts_delta,
    but actually the result should be wall_to_monotonic > ts_delta.
    
    After normalization, the result of timespec64_compare() is correct because
    the tv_sec comparison is not longer misleading:
    
      wall_to_monotonic = { .tv_sec = -10, .tv_nsec =  900000000 }
      ts_delta          = { .tv_sec = -10, .tv_nsec =  100000000 }
    
    Use timespec64_sub() to ensure that ts_delta is normalized, which fixes the
    issue.
    
    Fixes: e1d7ba873555 ("time: Always make sure wall_to_monotonic isn't positive")
    Signed-off-by: Yu Liao <liaoyu15@huawei.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/20211213135727.1656662-1-liaoyu15@huawei.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit e1fe1b10e6aae5fb2df1c065e4fbe655c39e5065
Merge: 909e1d166ca8 4e8c11b6b3f0
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Dec 19 12:23:18 2021 -0800

    Merge tag 'timers_urgent_for_v5.16_rc6' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer fix from Borislav Petkov:
    
     - Make sure the CLOCK_REALTIME to CLOCK_MONOTONIC offset is never
       positive
    
    * tag 'timers_urgent_for_v5.16_rc6' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      timekeeping: Really make sure wall_to_monotonic isn't positive

commit 4e8c11b6b3f0b6a283e898344f154641eda94266
Author: Yu Liao <liaoyu15@huawei.com>
Date:   Mon Dec 13 21:57:27 2021 +0800

    timekeeping: Really make sure wall_to_monotonic isn't positive
    
    Even after commit e1d7ba873555 ("time: Always make sure wall_to_monotonic
    isn't positive") it is still possible to make wall_to_monotonic positive
    by running the following code:
    
        int main(void)
        {
            struct timespec time;
    
            clock_gettime(CLOCK_MONOTONIC, &time);
            time.tv_nsec = 0;
            clock_settime(CLOCK_REALTIME, &time);
            return 0;
        }
    
    The reason is that the second parameter of timespec64_compare(), ts_delta,
    may be unnormalized because the delta is calculated with an open coded
    substraction which causes the comparison of tv_sec to yield the wrong
    result:
    
      wall_to_monotonic = { .tv_sec = -10, .tv_nsec =  900000000 }
      ts_delta          = { .tv_sec =  -9, .tv_nsec = -900000000 }
    
    That makes timespec64_compare() claim that wall_to_monotonic < ts_delta,
    but actually the result should be wall_to_monotonic > ts_delta.
    
    After normalization, the result of timespec64_compare() is correct because
    the tv_sec comparison is not longer misleading:
    
      wall_to_monotonic = { .tv_sec = -10, .tv_nsec =  900000000 }
      ts_delta          = { .tv_sec = -10, .tv_nsec =  100000000 }
    
    Use timespec64_sub() to ensure that ts_delta is normalized, which fixes the
    issue.
    
    Fixes: e1d7ba873555 ("time: Always make sure wall_to_monotonic isn't positive")
    Signed-off-by: Yu Liao <liaoyu15@huawei.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/20211213135727.1656662-1-liaoyu15@huawei.com

commit 268ba095371cb28841bd9bd7f61c73290104a064
Merge: 944207047ca4 afdb4a5b1d34
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Dec 5 12:58:18 2021 -0800

    Merge tag 'for-5.16/parisc-6' of git://git.kernel.org/pub/scm/linux/kernel/git/deller/parisc-linux
    
    Pull parisc fixes from Helge Deller:
     "Some bug and warning fixes:
    
       - Fix "make install" to use debians "installkernel" script which is
         now in /usr/sbin
    
       - Fix the bindeb-pkg make target by giving the correct KBUILD_IMAGE
         file name
    
       - Fix compiler warnings by annotating parisc agp init functions with
         __init
    
       - Fix timekeeping on SMP machines with dual-core CPUs
    
       - Enable some more config options in the 64-bit defconfig"
    
    * tag 'for-5.16/parisc-6' of git://git.kernel.org/pub/scm/linux/kernel/git/deller/parisc-linux:
      parisc: Mark cr16 CPU clocksource unstable on all SMP machines
      parisc: Fix "make install" on newer debian releases
      parisc/agp: Annotate parisc agp init functions with __init
      parisc: Enable sata sil, audit and usb support on 64-bit defconfig
      parisc: Fix KBUILD_IMAGE for self-extracting kernel

commit 53e87e3cdc155f20c3417b689df8d2ac88d79576
Author: Frederic Weisbecker <frederic@kernel.org>
Date:   Tue Oct 26 16:10:54 2021 +0200

    timers/nohz: Last resort update jiffies on nohz_full IRQ entry
    
    When at least one CPU runs in nohz_full mode, a dedicated timekeeper CPU
    is guaranteed to stay online and to never stop its tick.
    
    Meanwhile on some rare case, the dedicated timekeeper may be running
    with interrupts disabled for a while, such as in stop_machine.
    
    If jiffies stop being updated, a nohz_full CPU may end up endlessly
    programming the next tick in the past, taking the last jiffies update
    monotonic timestamp as a stale base, resulting in an tick storm.
    
    Here is a scenario where it matters:
    
    0) CPU 0 is the timekeeper and CPU 1 a nohz_full CPU.
    
    1) A stop machine callback is queued to execute somewhere.
    
    2) CPU 0 reaches MULTI_STOP_DISABLE_IRQ while CPU 1 is still in
       MULTI_STOP_PREPARE. Hence CPU 0 can't do its timekeeping duty. CPU 1
       can still take IRQs.
    
    3) CPU 1 receives an IRQ which queues a timer callback one jiffy forward.
    
    4) On IRQ exit, CPU 1 schedules the tick one jiffy forward, taking
       last_jiffies_update as a base. But last_jiffies_update hasn't been
       updated for 2 jiffies since the timekeeper has interrupts disabled.
    
    5) clockevents_program_event(), which relies on ktime_get(), observes
       that the expiration is in the past and therefore programs the min
       delta event on the clock.
    
    6) The tick fires immediately, goto 3)
    
    7) Tick storm, the nohz_full CPU is drown and takes ages to reach
       MULTI_STOP_DISABLE_IRQ, which is the only way out of this situation.
    
    Solve this with unconditionally updating jiffies if the value is stale
    on nohz_full IRQ entry. IRQs and other disturbances are expected to be
    rare enough on nohz_full for the unconditional call to ktime_get() to
    actually matter.
    
    Reported-by: Paul E. McKenney <paulmck@kernel.org>
    Signed-off-by: Frederic Weisbecker <frederic@kernel.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Paul E. McKenney <paulmck@kernel.org>
    Link: https://lore.kernel.org/r/20211026141055.57358-2-frederic@kernel.org

commit c86ff8c55b8ae68837b2fa59dc0c203907e9a15f
Author: Waiman Long <longman@redhat.com>
Date:   Thu Nov 18 14:14:36 2021 -0500

    clocksource: Avoid accidental unstable marking of clocksources
    
    Since commit db3a34e17433 ("clocksource: Retry clock read if long delays
    detected") and commit 2e27e793e280 ("clocksource: Reduce clocksource-skew
    threshold"), it is found that tsc clocksource fallback to hpet can
    sometimes happen on both Intel and AMD systems especially when they are
    running stressful benchmarking workloads. Of the 23 systems tested with
    a v5.14 kernel, 10 of them have switched to hpet clock source during
    the test run.
    
    The result of falling back to hpet is a drastic reduction of performance
    when running benchmarks. For example, the fio performance tests can
    drop up to 70% whereas the iperf3 performance can drop up to 80%.
    
    4 hpet fallbacks happened during bootup. They were:
    
      [    8.749399] clocksource: timekeeping watchdog on CPU13: hpet read-back delay of 263750ns, attempt 4, marking unstable
      [   12.044610] clocksource: timekeeping watchdog on CPU19: hpet read-back delay of 186166ns, attempt 4, marking unstable
      [   17.336941] clocksource: timekeeping watchdog on CPU28: hpet read-back delay of 182291ns, attempt 4, marking unstable
      [   17.518565] clocksource: timekeeping watchdog on CPU34: hpet read-back delay of 252196ns, attempt 4, marking unstable
    
    Other fallbacks happen when the systems were running stressful
    benchmarks. For example:
    
      [ 2685.867873] clocksource: timekeeping watchdog on CPU117: hpet read-back delay of 57269ns, attempt 4, marking unstable
      [46215.471228] clocksource: timekeeping watchdog on CPU8: hpet read-back delay of 61460ns, attempt 4, marking unstable
    
    Commit 2e27e793e280 ("clocksource: Reduce clocksource-skew threshold"),
    changed the skew margin from 100us to 50us. I think this is too small
    and can easily be exceeded when running some stressful workloads on a
    thermally stressed system.  So it is switched back to 100us.
    
    Even a maximum skew margin of 100us may be too small in for some systems
    when booting up especially if those systems are under thermal stress. To
    eliminate the case that the large skew is due to the system being too
    busy slowing down the reading of both the watchdog and the clocksource,
    an extra consecutive read of watchdog clock is being done to check this.
    
    The consecutive watchdog read delay is compared against
    WATCHDOG_MAX_SKEW/2. If the delay exceeds the limit, we assume that
    the system is just too busy. A warning will be printed to the console
    and the clock skew check is skipped for this round.
    
    Fixes: db3a34e17433 ("clocksource: Retry clock read if long delays detected")
    Fixes: 2e27e793e280 ("clocksource: Reduce clocksource-skew threshold")
    Signed-off-by: Waiman Long <longman@redhat.com>
    Signed-off-by: Paul E. McKenney <paulmck@kernel.org>

commit 439b99314b635b40f2e0622eabe62d7055bb409b
Author: Dmitrii Banshchikov <me@ubique.spb.ru>
Date:   Sat Nov 13 18:22:26 2021 +0400

    bpf: Forbid bpf_ktime_get_coarse_ns and bpf_timer_* in tracing progs
    
    commit 5e0bc3082e2e403ac0753e099c2b01446bb35578 upstream.
    
    Use of bpf_ktime_get_coarse_ns() and bpf_timer_* helpers in tracing
    progs may result in locking issues.
    
    bpf_ktime_get_coarse_ns() uses ktime_get_coarse_ns() time accessor that
    isn't safe for any context:
    ======================================================
    WARNING: possible circular locking dependency detected
    5.15.0-syzkaller #0 Not tainted
    ------------------------------------------------------
    syz-executor.4/14877 is trying to acquire lock:
    ffffffff8cb30008 (tk_core.seq.seqcount){----}-{0:0}, at: ktime_get_coarse_ts64+0x25/0x110 kernel/time/timekeeping.c:2255
    
    but task is already holding lock:
    ffffffff90dbf200 (&obj_hash[i].lock){-.-.}-{2:2}, at: debug_object_deactivate+0x61/0x400 lib/debugobjects.c:735
    
    which lock already depends on the new lock.
    
    the existing dependency chain (in reverse order) is:
    
    -> #1 (&obj_hash[i].lock){-.-.}-{2:2}:
           lock_acquire+0x19f/0x4d0 kernel/locking/lockdep.c:5625
           __raw_spin_lock_irqsave include/linux/spinlock_api_smp.h:110 [inline]
           _raw_spin_lock_irqsave+0xd1/0x120 kernel/locking/spinlock.c:162
           __debug_object_init+0xd9/0x1860 lib/debugobjects.c:569
           debug_hrtimer_init kernel/time/hrtimer.c:414 [inline]
           debug_init kernel/time/hrtimer.c:468 [inline]
           hrtimer_init+0x20/0x40 kernel/time/hrtimer.c:1592
           ntp_init_cmos_sync kernel/time/ntp.c:676 [inline]
           ntp_init+0xa1/0xad kernel/time/ntp.c:1095
           timekeeping_init+0x512/0x6bf kernel/time/timekeeping.c:1639
           start_kernel+0x267/0x56e init/main.c:1030
           secondary_startup_64_no_verify+0xb1/0xbb
    
    -> #0 (tk_core.seq.seqcount){----}-{0:0}:
           check_prev_add kernel/locking/lockdep.c:3051 [inline]
           check_prevs_add kernel/locking/lockdep.c:3174 [inline]
           validate_chain+0x1dfb/0x8240 kernel/locking/lockdep.c:3789
           __lock_acquire+0x1382/0x2b00 kernel/locking/lockdep.c:5015
           lock_acquire+0x19f/0x4d0 kernel/locking/lockdep.c:5625
           seqcount_lockdep_reader_access+0xfe/0x230 include/linux/seqlock.h:103
           ktime_get_coarse_ts64+0x25/0x110 kernel/time/timekeeping.c:2255
           ktime_get_coarse include/linux/timekeeping.h:120 [inline]
           ktime_get_coarse_ns include/linux/timekeeping.h:126 [inline]
           ____bpf_ktime_get_coarse_ns kernel/bpf/helpers.c:173 [inline]
           bpf_ktime_get_coarse_ns+0x7e/0x130 kernel/bpf/helpers.c:171
           bpf_prog_a99735ebafdda2f1+0x10/0xb50
           bpf_dispatcher_nop_func include/linux/bpf.h:721 [inline]
           __bpf_prog_run include/linux/filter.h:626 [inline]
           bpf_prog_run include/linux/filter.h:633 [inline]
           BPF_PROG_RUN_ARRAY include/linux/bpf.h:1294 [inline]
           trace_call_bpf+0x2cf/0x5d0 kernel/trace/bpf_trace.c:127
           perf_trace_run_bpf_submit+0x7b/0x1d0 kernel/events/core.c:9708
           perf_trace_lock+0x37c/0x440 include/trace/events/lock.h:39
           trace_lock_release+0x128/0x150 include/trace/events/lock.h:58
           lock_release+0x82/0x810 kernel/locking/lockdep.c:5636
           __raw_spin_unlock_irqrestore include/linux/spinlock_api_smp.h:149 [inline]
           _raw_spin_unlock_irqrestore+0x75/0x130 kernel/locking/spinlock.c:194
           debug_hrtimer_deactivate kernel/time/hrtimer.c:425 [inline]
           debug_deactivate kernel/time/hrtimer.c:481 [inline]
           __run_hrtimer kernel/time/hrtimer.c:1653 [inline]
           __hrtimer_run_queues+0x2f9/0xa60 kernel/time/hrtimer.c:1749
           hrtimer_interrupt+0x3b3/0x1040 kernel/time/hrtimer.c:1811
           local_apic_timer_interrupt arch/x86/kernel/apic/apic.c:1086 [inline]
           __sysvec_apic_timer_interrupt+0xf9/0x270 arch/x86/kernel/apic/apic.c:1103
           sysvec_apic_timer_interrupt+0x8c/0xb0 arch/x86/kernel/apic/apic.c:1097
           asm_sysvec_apic_timer_interrupt+0x12/0x20
           __raw_spin_unlock_irqrestore include/linux/spinlock_api_smp.h:152 [inline]
           _raw_spin_unlock_irqrestore+0xd4/0x130 kernel/locking/spinlock.c:194
           try_to_wake_up+0x702/0xd20 kernel/sched/core.c:4118
           wake_up_process kernel/sched/core.c:4200 [inline]
           wake_up_q+0x9a/0xf0 kernel/sched/core.c:953
           futex_wake+0x50f/0x5b0 kernel/futex/waitwake.c:184
           do_futex+0x367/0x560 kernel/futex/syscalls.c:127
           __do_sys_futex kernel/futex/syscalls.c:199 [inline]
           __se_sys_futex+0x401/0x4b0 kernel/futex/syscalls.c:180
           do_syscall_x64 arch/x86/entry/common.c:50 [inline]
           do_syscall_64+0x44/0xd0 arch/x86/entry/common.c:80
           entry_SYSCALL_64_after_hwframe+0x44/0xae
    
    There is a possible deadlock with bpf_timer_* set of helpers:
    hrtimer_start()
      lock_base();
      trace_hrtimer...()
        perf_event()
          bpf_run()
            bpf_timer_start()
              hrtimer_start()
                lock_base()         <- DEADLOCK
    
    Forbid use of bpf_ktime_get_coarse_ns() and bpf_timer_* helpers in
    BPF_PROG_TYPE_KPROBE, BPF_PROG_TYPE_TRACEPOINT, BPF_PROG_TYPE_PERF_EVENT
    and BPF_PROG_TYPE_RAW_TRACEPOINT prog types.
    
    Fixes: d05512618056 ("bpf: Add bpf_ktime_get_coarse_ns helper")
    Fixes: b00628b1c7d5 ("bpf: Introduce bpf timers.")
    Reported-by: syzbot+43fd005b5a1b4d10781e@syzkaller.appspotmail.com
    Signed-off-by: Dmitrii Banshchikov <me@ubique.spb.ru>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>
    Link: https://lore.kernel.org/bpf/20211113142227.566439-2-me@ubique.spb.ru
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 3e13ce88a3c8cc4d5579409a650a3753cf4fac17
Author: Eric Dumazet <edumazet@google.com>
Date:   Mon Nov 8 10:08:15 2021 -0800

    net/sched: sch_taprio: fix undefined behavior in ktime_mono_to_any
    
    [ Upstream commit 6dc25401cba4d428328eade8ceae717633fdd702 ]
    
    1) if q->tk_offset == TK_OFFS_MAX, then get_tcp_tstamp() calls
       ktime_mono_to_any() with out-of-bound value.
    
    2) if q->tk_offset is changed in taprio_parse_clockid(),
       taprio_get_time() might also call ktime_mono_to_any()
       with out-of-bound value as sysbot found:
    
    UBSAN: array-index-out-of-bounds in kernel/time/timekeeping.c:908:27
    index 3 is out of range for type 'ktime_t *[3]'
    CPU: 1 PID: 25668 Comm: kworker/u4:0 Not tainted 5.15.0-syzkaller #0
    Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011
    Workqueue: bat_events batadv_iv_send_outstanding_bat_ogm_packet
    Call Trace:
     <TASK>
     __dump_stack lib/dump_stack.c:88 [inline]
     dump_stack_lvl+0xcd/0x134 lib/dump_stack.c:106
     ubsan_epilogue+0xb/0x5a lib/ubsan.c:151
     __ubsan_handle_out_of_bounds.cold+0x62/0x6c lib/ubsan.c:291
     ktime_mono_to_any+0x1d4/0x1e0 kernel/time/timekeeping.c:908
     get_tcp_tstamp net/sched/sch_taprio.c:322 [inline]
     get_packet_txtime net/sched/sch_taprio.c:353 [inline]
     taprio_enqueue_one+0x5b0/0x1460 net/sched/sch_taprio.c:420
     taprio_enqueue+0x3b1/0x730 net/sched/sch_taprio.c:485
     dev_qdisc_enqueue+0x40/0x300 net/core/dev.c:3785
     __dev_xmit_skb net/core/dev.c:3869 [inline]
     __dev_queue_xmit+0x1f6e/0x3630 net/core/dev.c:4194
     batadv_send_skb_packet+0x4a9/0x5f0 net/batman-adv/send.c:108
     batadv_iv_ogm_send_to_if net/batman-adv/bat_iv_ogm.c:393 [inline]
     batadv_iv_ogm_emit net/batman-adv/bat_iv_ogm.c:421 [inline]
     batadv_iv_send_outstanding_bat_ogm_packet+0x6d7/0x8e0 net/batman-adv/bat_iv_ogm.c:1701
     process_one_work+0x9b2/0x1690 kernel/workqueue.c:2298
     worker_thread+0x658/0x11f0 kernel/workqueue.c:2445
     kthread+0x405/0x4f0 kernel/kthread.c:327
     ret_from_fork+0x1f/0x30 arch/x86/entry/entry_64.S:295
    
    Fixes: 7ede7b03484b ("taprio: make clock reference conversions easier")
    Fixes: 54002066100b ("taprio: Adjust timestamps for TCP packets")
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Cc: Vedang Patel <vedang.patel@intel.com>
    Reported-by: syzbot <syzkaller@googlegroups.com>
    Reviewed-by: Vinicius Costa Gomes <vinicius.gomes@intel.com>
    Link: https://lore.kernel.org/r/20211108180815.1822479-1-eric.dumazet@gmail.com
    Signed-off-by: Jakub Kicinski <kuba@kernel.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit b327d92c10b27255d68989aa77ed71c2e38fae61
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue Sep 21 12:42:25 2021 +0300

    bus: ti-sysc: Fix timekeeping_suspended warning on resume
    
    [ Upstream commit b3e9431854e8f305385d5de225441c0477b936cb ]
    
    On resume we can get a warning at kernel/time/timekeeping.c:824 for
    timekeeping_suspended.
    
    Let's fix this by adding separate functions for sysc_poll_reset_sysstatus()
    and sysc_poll_reset_sysconfig() and have the new functions handle also
    timekeeping_suspended.
    
    If iopoll at some point supports timekeeping_suspended, we can just drop
    the custom handling from these functions.
    
    Fixes: d46f9fbec719 ("bus: ti-sysc: Use optional clocks on for enable and wait for softreset bit")
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 79aa8706b45c110de1188bcca0212dc362b5d353
Author: Eric Dumazet <edumazet@google.com>
Date:   Mon Nov 8 10:08:15 2021 -0800

    net/sched: sch_taprio: fix undefined behavior in ktime_mono_to_any
    
    [ Upstream commit 6dc25401cba4d428328eade8ceae717633fdd702 ]
    
    1) if q->tk_offset == TK_OFFS_MAX, then get_tcp_tstamp() calls
       ktime_mono_to_any() with out-of-bound value.
    
    2) if q->tk_offset is changed in taprio_parse_clockid(),
       taprio_get_time() might also call ktime_mono_to_any()
       with out-of-bound value as sysbot found:
    
    UBSAN: array-index-out-of-bounds in kernel/time/timekeeping.c:908:27
    index 3 is out of range for type 'ktime_t *[3]'
    CPU: 1 PID: 25668 Comm: kworker/u4:0 Not tainted 5.15.0-syzkaller #0
    Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011
    Workqueue: bat_events batadv_iv_send_outstanding_bat_ogm_packet
    Call Trace:
     <TASK>
     __dump_stack lib/dump_stack.c:88 [inline]
     dump_stack_lvl+0xcd/0x134 lib/dump_stack.c:106
     ubsan_epilogue+0xb/0x5a lib/ubsan.c:151
     __ubsan_handle_out_of_bounds.cold+0x62/0x6c lib/ubsan.c:291
     ktime_mono_to_any+0x1d4/0x1e0 kernel/time/timekeeping.c:908
     get_tcp_tstamp net/sched/sch_taprio.c:322 [inline]
     get_packet_txtime net/sched/sch_taprio.c:353 [inline]
     taprio_enqueue_one+0x5b0/0x1460 net/sched/sch_taprio.c:420
     taprio_enqueue+0x3b1/0x730 net/sched/sch_taprio.c:485
     dev_qdisc_enqueue+0x40/0x300 net/core/dev.c:3785
     __dev_xmit_skb net/core/dev.c:3869 [inline]
     __dev_queue_xmit+0x1f6e/0x3630 net/core/dev.c:4194
     batadv_send_skb_packet+0x4a9/0x5f0 net/batman-adv/send.c:108
     batadv_iv_ogm_send_to_if net/batman-adv/bat_iv_ogm.c:393 [inline]
     batadv_iv_ogm_emit net/batman-adv/bat_iv_ogm.c:421 [inline]
     batadv_iv_send_outstanding_bat_ogm_packet+0x6d7/0x8e0 net/batman-adv/bat_iv_ogm.c:1701
     process_one_work+0x9b2/0x1690 kernel/workqueue.c:2298
     worker_thread+0x658/0x11f0 kernel/workqueue.c:2445
     kthread+0x405/0x4f0 kernel/kthread.c:327
     ret_from_fork+0x1f/0x30 arch/x86/entry/entry_64.S:295
    
    Fixes: 7ede7b03484b ("taprio: make clock reference conversions easier")
    Fixes: 54002066100b ("taprio: Adjust timestamps for TCP packets")
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Cc: Vedang Patel <vedang.patel@intel.com>
    Reported-by: syzbot <syzkaller@googlegroups.com>
    Reviewed-by: Vinicius Costa Gomes <vinicius.gomes@intel.com>
    Link: https://lore.kernel.org/r/20211108180815.1822479-1-eric.dumazet@gmail.com
    Signed-off-by: Jakub Kicinski <kuba@kernel.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit b6493c2b7ddb7a019908fa80fc4ebc323fe36ffb
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue Sep 21 12:42:25 2021 +0300

    bus: ti-sysc: Fix timekeeping_suspended warning on resume
    
    [ Upstream commit b3e9431854e8f305385d5de225441c0477b936cb ]
    
    On resume we can get a warning at kernel/time/timekeeping.c:824 for
    timekeeping_suspended.
    
    Let's fix this by adding separate functions for sysc_poll_reset_sysstatus()
    and sysc_poll_reset_sysconfig() and have the new functions handle also
    timekeeping_suspended.
    
    If iopoll at some point supports timekeeping_suspended, we can just drop
    the custom handling from these functions.
    
    Fixes: d46f9fbec719 ("bus: ti-sysc: Use optional clocks on for enable and wait for softreset bit")
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 1959c36142270d6345aae972f4f0618a650092d7
Author: Eric Dumazet <edumazet@google.com>
Date:   Mon Nov 8 10:08:15 2021 -0800

    net/sched: sch_taprio: fix undefined behavior in ktime_mono_to_any
    
    [ Upstream commit 6dc25401cba4d428328eade8ceae717633fdd702 ]
    
    1) if q->tk_offset == TK_OFFS_MAX, then get_tcp_tstamp() calls
       ktime_mono_to_any() with out-of-bound value.
    
    2) if q->tk_offset is changed in taprio_parse_clockid(),
       taprio_get_time() might also call ktime_mono_to_any()
       with out-of-bound value as sysbot found:
    
    UBSAN: array-index-out-of-bounds in kernel/time/timekeeping.c:908:27
    index 3 is out of range for type 'ktime_t *[3]'
    CPU: 1 PID: 25668 Comm: kworker/u4:0 Not tainted 5.15.0-syzkaller #0
    Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011
    Workqueue: bat_events batadv_iv_send_outstanding_bat_ogm_packet
    Call Trace:
     <TASK>
     __dump_stack lib/dump_stack.c:88 [inline]
     dump_stack_lvl+0xcd/0x134 lib/dump_stack.c:106
     ubsan_epilogue+0xb/0x5a lib/ubsan.c:151
     __ubsan_handle_out_of_bounds.cold+0x62/0x6c lib/ubsan.c:291
     ktime_mono_to_any+0x1d4/0x1e0 kernel/time/timekeeping.c:908
     get_tcp_tstamp net/sched/sch_taprio.c:322 [inline]
     get_packet_txtime net/sched/sch_taprio.c:353 [inline]
     taprio_enqueue_one+0x5b0/0x1460 net/sched/sch_taprio.c:420
     taprio_enqueue+0x3b1/0x730 net/sched/sch_taprio.c:485
     dev_qdisc_enqueue+0x40/0x300 net/core/dev.c:3785
     __dev_xmit_skb net/core/dev.c:3869 [inline]
     __dev_queue_xmit+0x1f6e/0x3630 net/core/dev.c:4194
     batadv_send_skb_packet+0x4a9/0x5f0 net/batman-adv/send.c:108
     batadv_iv_ogm_send_to_if net/batman-adv/bat_iv_ogm.c:393 [inline]
     batadv_iv_ogm_emit net/batman-adv/bat_iv_ogm.c:421 [inline]
     batadv_iv_send_outstanding_bat_ogm_packet+0x6d7/0x8e0 net/batman-adv/bat_iv_ogm.c:1701
     process_one_work+0x9b2/0x1690 kernel/workqueue.c:2298
     worker_thread+0x658/0x11f0 kernel/workqueue.c:2445
     kthread+0x405/0x4f0 kernel/kthread.c:327
     ret_from_fork+0x1f/0x30 arch/x86/entry/entry_64.S:295
    
    Fixes: 7ede7b03484b ("taprio: make clock reference conversions easier")
    Fixes: 54002066100b ("taprio: Adjust timestamps for TCP packets")
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Cc: Vedang Patel <vedang.patel@intel.com>
    Reported-by: syzbot <syzkaller@googlegroups.com>
    Reviewed-by: Vinicius Costa Gomes <vinicius.gomes@intel.com>
    Link: https://lore.kernel.org/r/20211108180815.1822479-1-eric.dumazet@gmail.com
    Signed-off-by: Jakub Kicinski <kuba@kernel.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 87b20cedac641eb82e80852cada7d1e984b4266a
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue Sep 21 12:42:25 2021 +0300

    bus: ti-sysc: Fix timekeeping_suspended warning on resume
    
    [ Upstream commit b3e9431854e8f305385d5de225441c0477b936cb ]
    
    On resume we can get a warning at kernel/time/timekeeping.c:824 for
    timekeeping_suspended.
    
    Let's fix this by adding separate functions for sysc_poll_reset_sysstatus()
    and sysc_poll_reset_sysconfig() and have the new functions handle also
    timekeeping_suspended.
    
    If iopoll at some point supports timekeeping_suspended, we can just drop
    the custom handling from these functions.
    
    Fixes: d46f9fbec719 ("bus: ti-sysc: Use optional clocks on for enable and wait for softreset bit")
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 07b218db54a4eb84dbca49e191f486ba9ad991a6
Author: Eric Dumazet <edumazet@google.com>
Date:   Mon Nov 8 10:08:15 2021 -0800

    net/sched: sch_taprio: fix undefined behavior in ktime_mono_to_any
    
    [ Upstream commit 6dc25401cba4d428328eade8ceae717633fdd702 ]
    
    1) if q->tk_offset == TK_OFFS_MAX, then get_tcp_tstamp() calls
       ktime_mono_to_any() with out-of-bound value.
    
    2) if q->tk_offset is changed in taprio_parse_clockid(),
       taprio_get_time() might also call ktime_mono_to_any()
       with out-of-bound value as sysbot found:
    
    UBSAN: array-index-out-of-bounds in kernel/time/timekeeping.c:908:27
    index 3 is out of range for type 'ktime_t *[3]'
    CPU: 1 PID: 25668 Comm: kworker/u4:0 Not tainted 5.15.0-syzkaller #0
    Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011
    Workqueue: bat_events batadv_iv_send_outstanding_bat_ogm_packet
    Call Trace:
     <TASK>
     __dump_stack lib/dump_stack.c:88 [inline]
     dump_stack_lvl+0xcd/0x134 lib/dump_stack.c:106
     ubsan_epilogue+0xb/0x5a lib/ubsan.c:151
     __ubsan_handle_out_of_bounds.cold+0x62/0x6c lib/ubsan.c:291
     ktime_mono_to_any+0x1d4/0x1e0 kernel/time/timekeeping.c:908
     get_tcp_tstamp net/sched/sch_taprio.c:322 [inline]
     get_packet_txtime net/sched/sch_taprio.c:353 [inline]
     taprio_enqueue_one+0x5b0/0x1460 net/sched/sch_taprio.c:420
     taprio_enqueue+0x3b1/0x730 net/sched/sch_taprio.c:485
     dev_qdisc_enqueue+0x40/0x300 net/core/dev.c:3785
     __dev_xmit_skb net/core/dev.c:3869 [inline]
     __dev_queue_xmit+0x1f6e/0x3630 net/core/dev.c:4194
     batadv_send_skb_packet+0x4a9/0x5f0 net/batman-adv/send.c:108
     batadv_iv_ogm_send_to_if net/batman-adv/bat_iv_ogm.c:393 [inline]
     batadv_iv_ogm_emit net/batman-adv/bat_iv_ogm.c:421 [inline]
     batadv_iv_send_outstanding_bat_ogm_packet+0x6d7/0x8e0 net/batman-adv/bat_iv_ogm.c:1701
     process_one_work+0x9b2/0x1690 kernel/workqueue.c:2298
     worker_thread+0x658/0x11f0 kernel/workqueue.c:2445
     kthread+0x405/0x4f0 kernel/kthread.c:327
     ret_from_fork+0x1f/0x30 arch/x86/entry/entry_64.S:295
    
    Fixes: 7ede7b03484b ("taprio: make clock reference conversions easier")
    Fixes: 54002066100b ("taprio: Adjust timestamps for TCP packets")
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Cc: Vedang Patel <vedang.patel@intel.com>
    Reported-by: syzbot <syzkaller@googlegroups.com>
    Reviewed-by: Vinicius Costa Gomes <vinicius.gomes@intel.com>
    Link: https://lore.kernel.org/r/20211108180815.1822479-1-eric.dumazet@gmail.com
    Signed-off-by: Jakub Kicinski <kuba@kernel.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 5e0bc3082e2e403ac0753e099c2b01446bb35578
Author: Dmitrii Banshchikov <me@ubique.spb.ru>
Date:   Sat Nov 13 18:22:26 2021 +0400

    bpf: Forbid bpf_ktime_get_coarse_ns and bpf_timer_* in tracing progs
    
    Use of bpf_ktime_get_coarse_ns() and bpf_timer_* helpers in tracing
    progs may result in locking issues.
    
    bpf_ktime_get_coarse_ns() uses ktime_get_coarse_ns() time accessor that
    isn't safe for any context:
    ======================================================
    WARNING: possible circular locking dependency detected
    5.15.0-syzkaller #0 Not tainted
    ------------------------------------------------------
    syz-executor.4/14877 is trying to acquire lock:
    ffffffff8cb30008 (tk_core.seq.seqcount){----}-{0:0}, at: ktime_get_coarse_ts64+0x25/0x110 kernel/time/timekeeping.c:2255
    
    but task is already holding lock:
    ffffffff90dbf200 (&obj_hash[i].lock){-.-.}-{2:2}, at: debug_object_deactivate+0x61/0x400 lib/debugobjects.c:735
    
    which lock already depends on the new lock.
    
    the existing dependency chain (in reverse order) is:
    
    -> #1 (&obj_hash[i].lock){-.-.}-{2:2}:
           lock_acquire+0x19f/0x4d0 kernel/locking/lockdep.c:5625
           __raw_spin_lock_irqsave include/linux/spinlock_api_smp.h:110 [inline]
           _raw_spin_lock_irqsave+0xd1/0x120 kernel/locking/spinlock.c:162
           __debug_object_init+0xd9/0x1860 lib/debugobjects.c:569
           debug_hrtimer_init kernel/time/hrtimer.c:414 [inline]
           debug_init kernel/time/hrtimer.c:468 [inline]
           hrtimer_init+0x20/0x40 kernel/time/hrtimer.c:1592
           ntp_init_cmos_sync kernel/time/ntp.c:676 [inline]
           ntp_init+0xa1/0xad kernel/time/ntp.c:1095
           timekeeping_init+0x512/0x6bf kernel/time/timekeeping.c:1639
           start_kernel+0x267/0x56e init/main.c:1030
           secondary_startup_64_no_verify+0xb1/0xbb
    
    -> #0 (tk_core.seq.seqcount){----}-{0:0}:
           check_prev_add kernel/locking/lockdep.c:3051 [inline]
           check_prevs_add kernel/locking/lockdep.c:3174 [inline]
           validate_chain+0x1dfb/0x8240 kernel/locking/lockdep.c:3789
           __lock_acquire+0x1382/0x2b00 kernel/locking/lockdep.c:5015
           lock_acquire+0x19f/0x4d0 kernel/locking/lockdep.c:5625
           seqcount_lockdep_reader_access+0xfe/0x230 include/linux/seqlock.h:103
           ktime_get_coarse_ts64+0x25/0x110 kernel/time/timekeeping.c:2255
           ktime_get_coarse include/linux/timekeeping.h:120 [inline]
           ktime_get_coarse_ns include/linux/timekeeping.h:126 [inline]
           ____bpf_ktime_get_coarse_ns kernel/bpf/helpers.c:173 [inline]
           bpf_ktime_get_coarse_ns+0x7e/0x130 kernel/bpf/helpers.c:171
           bpf_prog_a99735ebafdda2f1+0x10/0xb50
           bpf_dispatcher_nop_func include/linux/bpf.h:721 [inline]
           __bpf_prog_run include/linux/filter.h:626 [inline]
           bpf_prog_run include/linux/filter.h:633 [inline]
           BPF_PROG_RUN_ARRAY include/linux/bpf.h:1294 [inline]
           trace_call_bpf+0x2cf/0x5d0 kernel/trace/bpf_trace.c:127
           perf_trace_run_bpf_submit+0x7b/0x1d0 kernel/events/core.c:9708
           perf_trace_lock+0x37c/0x440 include/trace/events/lock.h:39
           trace_lock_release+0x128/0x150 include/trace/events/lock.h:58
           lock_release+0x82/0x810 kernel/locking/lockdep.c:5636
           __raw_spin_unlock_irqrestore include/linux/spinlock_api_smp.h:149 [inline]
           _raw_spin_unlock_irqrestore+0x75/0x130 kernel/locking/spinlock.c:194
           debug_hrtimer_deactivate kernel/time/hrtimer.c:425 [inline]
           debug_deactivate kernel/time/hrtimer.c:481 [inline]
           __run_hrtimer kernel/time/hrtimer.c:1653 [inline]
           __hrtimer_run_queues+0x2f9/0xa60 kernel/time/hrtimer.c:1749
           hrtimer_interrupt+0x3b3/0x1040 kernel/time/hrtimer.c:1811
           local_apic_timer_interrupt arch/x86/kernel/apic/apic.c:1086 [inline]
           __sysvec_apic_timer_interrupt+0xf9/0x270 arch/x86/kernel/apic/apic.c:1103
           sysvec_apic_timer_interrupt+0x8c/0xb0 arch/x86/kernel/apic/apic.c:1097
           asm_sysvec_apic_timer_interrupt+0x12/0x20
           __raw_spin_unlock_irqrestore include/linux/spinlock_api_smp.h:152 [inline]
           _raw_spin_unlock_irqrestore+0xd4/0x130 kernel/locking/spinlock.c:194
           try_to_wake_up+0x702/0xd20 kernel/sched/core.c:4118
           wake_up_process kernel/sched/core.c:4200 [inline]
           wake_up_q+0x9a/0xf0 kernel/sched/core.c:953
           futex_wake+0x50f/0x5b0 kernel/futex/waitwake.c:184
           do_futex+0x367/0x560 kernel/futex/syscalls.c:127
           __do_sys_futex kernel/futex/syscalls.c:199 [inline]
           __se_sys_futex+0x401/0x4b0 kernel/futex/syscalls.c:180
           do_syscall_x64 arch/x86/entry/common.c:50 [inline]
           do_syscall_64+0x44/0xd0 arch/x86/entry/common.c:80
           entry_SYSCALL_64_after_hwframe+0x44/0xae
    
    There is a possible deadlock with bpf_timer_* set of helpers:
    hrtimer_start()
      lock_base();
      trace_hrtimer...()
        perf_event()
          bpf_run()
            bpf_timer_start()
              hrtimer_start()
                lock_base()         <- DEADLOCK
    
    Forbid use of bpf_ktime_get_coarse_ns() and bpf_timer_* helpers in
    BPF_PROG_TYPE_KPROBE, BPF_PROG_TYPE_TRACEPOINT, BPF_PROG_TYPE_PERF_EVENT
    and BPF_PROG_TYPE_RAW_TRACEPOINT prog types.
    
    Fixes: d05512618056 ("bpf: Add bpf_ktime_get_coarse_ns helper")
    Fixes: b00628b1c7d5 ("bpf: Introduce bpf timers.")
    Reported-by: syzbot+43fd005b5a1b4d10781e@syzkaller.appspotmail.com
    Signed-off-by: Dmitrii Banshchikov <me@ubique.spb.ru>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>
    Link: https://lore.kernel.org/bpf/20211113142227.566439-2-me@ubique.spb.ru

commit 6dc25401cba4d428328eade8ceae717633fdd702
Author: Eric Dumazet <edumazet@google.com>
Date:   Mon Nov 8 10:08:15 2021 -0800

    net/sched: sch_taprio: fix undefined behavior in ktime_mono_to_any
    
    1) if q->tk_offset == TK_OFFS_MAX, then get_tcp_tstamp() calls
       ktime_mono_to_any() with out-of-bound value.
    
    2) if q->tk_offset is changed in taprio_parse_clockid(),
       taprio_get_time() might also call ktime_mono_to_any()
       with out-of-bound value as sysbot found:
    
    UBSAN: array-index-out-of-bounds in kernel/time/timekeeping.c:908:27
    index 3 is out of range for type 'ktime_t *[3]'
    CPU: 1 PID: 25668 Comm: kworker/u4:0 Not tainted 5.15.0-syzkaller #0
    Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011
    Workqueue: bat_events batadv_iv_send_outstanding_bat_ogm_packet
    Call Trace:
     <TASK>
     __dump_stack lib/dump_stack.c:88 [inline]
     dump_stack_lvl+0xcd/0x134 lib/dump_stack.c:106
     ubsan_epilogue+0xb/0x5a lib/ubsan.c:151
     __ubsan_handle_out_of_bounds.cold+0x62/0x6c lib/ubsan.c:291
     ktime_mono_to_any+0x1d4/0x1e0 kernel/time/timekeeping.c:908
     get_tcp_tstamp net/sched/sch_taprio.c:322 [inline]
     get_packet_txtime net/sched/sch_taprio.c:353 [inline]
     taprio_enqueue_one+0x5b0/0x1460 net/sched/sch_taprio.c:420
     taprio_enqueue+0x3b1/0x730 net/sched/sch_taprio.c:485
     dev_qdisc_enqueue+0x40/0x300 net/core/dev.c:3785
     __dev_xmit_skb net/core/dev.c:3869 [inline]
     __dev_queue_xmit+0x1f6e/0x3630 net/core/dev.c:4194
     batadv_send_skb_packet+0x4a9/0x5f0 net/batman-adv/send.c:108
     batadv_iv_ogm_send_to_if net/batman-adv/bat_iv_ogm.c:393 [inline]
     batadv_iv_ogm_emit net/batman-adv/bat_iv_ogm.c:421 [inline]
     batadv_iv_send_outstanding_bat_ogm_packet+0x6d7/0x8e0 net/batman-adv/bat_iv_ogm.c:1701
     process_one_work+0x9b2/0x1690 kernel/workqueue.c:2298
     worker_thread+0x658/0x11f0 kernel/workqueue.c:2445
     kthread+0x405/0x4f0 kernel/kthread.c:327
     ret_from_fork+0x1f/0x30 arch/x86/entry/entry_64.S:295
    
    Fixes: 7ede7b03484b ("taprio: make clock reference conversions easier")
    Fixes: 54002066100b ("taprio: Adjust timestamps for TCP packets")
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Cc: Vedang Patel <vedang.patel@intel.com>
    Reported-by: syzbot <syzkaller@googlegroups.com>
    Reviewed-by: Vinicius Costa Gomes <vinicius.gomes@intel.com>
    Link: https://lore.kernel.org/r/20211108180815.1822479-1-eric.dumazet@gmail.com
    Signed-off-by: Jakub Kicinski <kuba@kernel.org>

commit 57a315cd7198907326e691cc909df2beebc2420d
Merge: 43aa0a195f06 a8da61cee95e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Nov 1 13:44:55 2021 -0700

    Merge tag 'timers-core-2021-10-31' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer updates from Thomas Gleixner:
     "Time, timers and timekeeping updates:
    
       - No core updates
    
       - No new clocksource/event driver
    
       - A large rework of the ARM architected timer driver to prepare for
         the support of the upcoming ARMv8.6 support
    
       - Fix Kconfig options for Exynos MCT, Samsung PWM and TI DM timers
    
       - Address a namespace collison in the ARC sp804 timer driver"
    
    * tag 'timers-core-2021-10-31' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      clocksource/drivers/timer-ti-dm: Select TIMER_OF
      clocksource/drivers/exynosy: Depend on sub-architecture for Exynos MCT and Samsung PWM
      clocksource/drivers/arch_arm_timer: Move workaround synchronisation around
      clocksource/drivers/arm_arch_timer: Fix masking for high freq counters
      clocksource/drivers/arm_arch_timer: Drop unnecessary ISB on CVAL programming
      clocksource/drivers/arm_arch_timer: Remove any trace of the TVAL programming interface
      clocksource/drivers/arm_arch_timer: Work around broken CVAL implementations
      clocksource/drivers/arm_arch_timer: Advertise 56bit timer to the core code
      clocksource/drivers/arm_arch_timer: Move MMIO timer programming over to CVAL
      clocksource/drivers/arm_arch_timer: Fix MMIO base address vs callback ordering issue
      clocksource/drivers/arm_arch_timer: Move drop _tval from erratum function names
      clocksource/drivers/arm_arch_timer: Move system register timer programming over to CVAL
      clocksource/drivers/arm_arch_timer: Extend write side of timer register accessors to u64
      clocksource/drivers/arm_arch_timer: Drop CNT*_TVAL read accessors
      clocksource/arm_arch_timer: Add build-time guards for unhandled register accesses
      clocksource/drivers/arc_timer: Eliminate redefined macro error

commit 030f4e72aa9cb92a097022f97792154f42901feb
Merge: 24e18b0f45c7 1b1da99b8453
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Oct 11 16:55:32 2021 +0200

    Merge tag 'omap-for-v5.16/ti-sysc-signed' of git://git.kernel.org/pub/scm/linux/kernel/git/tmlind/linux-omap into arm/drivers
    
    Driver changes for ti-sysc for v5.16
    
    Changes for ti-sysc driver for improved system suspend and resume
    support as some drivers need to be reinitialized on resume. Also
    a non-urgent resume warning fix, and dropping of legacy flags for
    gpio and sham:
    
    - Fix timekeeping suspended warning on resume. Probably no need to merge
      this into fixes as it's gone unnoticed for a while.
    
    - Check for context loss for reinit of a module
    
    - Add add quirk handling to reinit on context loss, and also fix a
      build warning it caused
    
    - Add quirk handling to reset on reinit
    
    - Use context loss quirk for gpmc and otg
    
    - Handle otg force-idle quirk even if no driver is loaded
    
    - Drop legacy flags for gpio and sham
    
    * tag 'omap-for-v5.16/ti-sysc-signed' of git://git.kernel.org/pub/scm/linux/kernel/git/tmlind/linux-omap:
      bus: ti-sysc: Fix variable set but not used warning for reinit_modules
      bus: ti-sysc: Drop legacy quirk flag for sham
      bus: ti-sysc: Drop legacy quirk flag for gpio
      bus: ti-sysc: Handle otg force idle quirk
      bus: ti-sysc: Use context lost quirk for otg
      bus: ti-sysc: Use context lost quirks for gpmc
      bus: ti-sysc: Add quirk handling for reset on re-init
      bus: ti-sysc: Add quirk handling for reinit on context lost
      bus: ti-sysc: Check for lost context in sysc_reinit_module()
      bus: ti-sysc: Fix timekeeping_suspended warning on resume
    
    Link: https://lore.kernel.org/r/pull-1633950030-501948@atomide.com-2
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

commit b3e9431854e8f305385d5de225441c0477b936cb
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue Sep 21 12:42:25 2021 +0300

    bus: ti-sysc: Fix timekeeping_suspended warning on resume
    
    On resume we can get a warning at kernel/time/timekeeping.c:824 for
    timekeeping_suspended.
    
    Let's fix this by adding separate functions for sysc_poll_reset_sysstatus()
    and sysc_poll_reset_sysconfig() and have the new functions handle also
    timekeeping_suspended.
    
    If iopoll at some point supports timekeeping_suspended, we can just drop
    the custom handling from these functions.
    
    Fixes: d46f9fbec719 ("bus: ti-sysc: Use optional clocks on for enable and wait for softreset bit")
    Signed-off-by: Tony Lindgren <tony@atomide.com>

commit eec6f991bf286e52e8c261f0998903761188c048
Author: Mark Rutland <mark.rutland@arm.com>
Date:   Wed Aug 18 17:15:35 2021 +0100

    arm64: initialize all of CNTHCTL_EL2
    
    [ Upstream commit bde8fff82e4a4b0f000dbf4d5eadab2079be0b56 ]
    
    In __init_el2_timers we initialize CNTHCTL_EL2.{EL1PCEN,EL1PCTEN} with a
    RMW sequence, leaving all other bits UNKNOWN.
    
    In general, we should initialize all bits in a register rather than
    using an RMW sequence, since most bits are UNKNOWN out of reset, and as
    new bits are added to the reigster their reset value might not result in
    expected behaviour.
    
    In the case of CNTHCTL_EL2, FEAT_ECV added a number of new control bits
    in previously RES0 bits, which reset to UNKNOWN values, and may cause
    issues for EL1 and EL0:
    
    * CNTHCTL_EL2.ECV enables the CNTPOFF_EL2 offset (which itself resets to
      an UNKNOWN value) at EL0 and EL1. Since the offset could reset to
      distinct values across CPUs, when the control bit resets to 1 this
      could break timekeeping generally.
    
    * CNTHCTL_EL2.{EL1TVT,EL1TVCT} trap EL0 and EL1 accesses to the EL1
      virtual timer/counter registers to EL2. When reset to 1, this could
      cause unexpected traps to EL2.
    
    Initializing these bits to zero avoids these problems, and all other
    bits in CNTHCTL_EL2 other than EL1PCEN and EL1PCTEN can safely be reset
    to zero.
    
    This patch ensures we initialize CNTHCTL_EL2 accordingly, only setting
    EL1PCEN and EL1PCTEN, and setting all other bits to zero.
    
    Signed-off-by: Mark Rutland <mark.rutland@arm.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Marc Zyngier <maz@kernel.org>
    Cc: Oliver Upton <oupton@google.com>
    Cc: Will Deacon <will@kernel.org>
    Reviewed-by: Oliver Upton <oupton@google.com>
    Acked-by: Marc Zyngier <maz@kernel.org>
    Link: https://lore.kernel.org/r/20210818161535.52786-1-mark.rutland@arm.com
    Signed-off-by: Will Deacon <will@kernel.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 8596e589b787732c8346f0482919e83cc9362db1
Merge: bed91667415b d25a025201ed
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Aug 30 15:31:33 2021 -0700

    Merge tag 'timers-core-2021-08-30' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer updates from Thomas Gleixner:
     "Updates for timekeeping, timers and related drivers:
    
      Core code:
    
       - Cure a couple of correctness issues in the posix CPU timer code to
         prevent that the tick dependency for NOHZ full is kept alive for no
         reason.
    
       - Avoid expensive double reprogramming of the clockevent device in
         hrtimer_start_range_ns().
    
       - Avoid pointless SMP function calls when the clock was set to avoid
         disturbing CPUs which do not have any affected timers queued.
    
       - Make the clocksource watchdog test work correctly when CONFIG_HZ is
         less than 100.
    
      Drivers:
    
       - Prefer the ARM architected timer over the Exynos timer which is way
         more expensive to access.
    
       - Add device tree bindings for new Ingenic SoCs
    
       - The usual improvements and cleanups all over the place"
    
    * tag 'timers-core-2021-08-30' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (29 commits)
      clocksource: Make clocksource watchdog test safe for slow-HZ systems
      dt-bindings: timer: Add ABIs for new Ingenic SoCs
      clocksource/drivers/fttmr010: Pass around less pointers
      clocksource/drivers/mediatek: Optimize systimer irq clear flow on shutdown
      clocksource/drivers/ingenic: Use bitfield macro helpers
      clocksource/drivers/sh_cmt: Fix wrong setting if don't request IRQ for clock source channel
      dt-bindings: timer: convert rockchip,rk-timer.txt to YAML
      clocksource/drivers/exynos_mct: Mark MCT device as CLOCK_EVT_FEAT_PERCPU
      clocksource/drivers/exynos_mct: Prioritise Arm arch timer on arm64
      hrtimer: Unbreak hrtimer_force_reprogram()
      hrtimer: Use raw_cpu_ptr() in clock_was_set()
      hrtimer: Avoid more SMP function calls in clock_was_set()
      hrtimer: Avoid unnecessary SMP function calls in clock_was_set()
      hrtimer: Add bases argument to clock_was_set()
      time/timekeeping: Avoid invoking clock_was_set() twice
      timekeeping: Distangle resume and clock-was-set events
      timerfd: Provide timerfd_resume()
      hrtimer: Force clock_was_set() handling for the HIGHRES=n, NOHZ=y case
      hrtimer: Ensure timerfd notification for HIGHRES=n
      hrtimer: Consolidate reprogramming code
      ...

commit bde8fff82e4a4b0f000dbf4d5eadab2079be0b56
Author: Mark Rutland <mark.rutland@arm.com>
Date:   Wed Aug 18 17:15:35 2021 +0100

    arm64: initialize all of CNTHCTL_EL2
    
    In __init_el2_timers we initialize CNTHCTL_EL2.{EL1PCEN,EL1PCTEN} with a
    RMW sequence, leaving all other bits UNKNOWN.
    
    In general, we should initialize all bits in a register rather than
    using an RMW sequence, since most bits are UNKNOWN out of reset, and as
    new bits are added to the reigster their reset value might not result in
    expected behaviour.
    
    In the case of CNTHCTL_EL2, FEAT_ECV added a number of new control bits
    in previously RES0 bits, which reset to UNKNOWN values, and may cause
    issues for EL1 and EL0:
    
    * CNTHCTL_EL2.ECV enables the CNTPOFF_EL2 offset (which itself resets to
      an UNKNOWN value) at EL0 and EL1. Since the offset could reset to
      distinct values across CPUs, when the control bit resets to 1 this
      could break timekeeping generally.
    
    * CNTHCTL_EL2.{EL1TVT,EL1TVCT} trap EL0 and EL1 accesses to the EL1
      virtual timer/counter registers to EL2. When reset to 1, this could
      cause unexpected traps to EL2.
    
    Initializing these bits to zero avoids these problems, and all other
    bits in CNTHCTL_EL2 other than EL1PCEN and EL1PCTEN can safely be reset
    to zero.
    
    This patch ensures we initialize CNTHCTL_EL2 accordingly, only setting
    EL1PCEN and EL1PCTEN, and setting all other bits to zero.
    
    Signed-off-by: Mark Rutland <mark.rutland@arm.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Marc Zyngier <maz@kernel.org>
    Cc: Oliver Upton <oupton@google.com>
    Cc: Will Deacon <will@kernel.org>
    Reviewed-by: Oliver Upton <oupton@google.com>
    Acked-by: Marc Zyngier <maz@kernel.org>
    Link: https://lore.kernel.org/r/20210818161535.52786-1-mark.rutland@arm.com
    Signed-off-by: Will Deacon <will@kernel.org>

commit 1b267793f4fd9a089ea8558f3b6698186b9a3214
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jul 13 15:39:52 2021 +0200

    time/timekeeping: Avoid invoking clock_was_set() twice
    
    do_adjtimex() might end up scheduling a delayed clock_was_set() via
    timekeeping_advance() and then invoke clock_was_set() directly which is
    pointless.
    
    Make timekeeping_advance() return whether an invocation of clock_was_set()
    is required and handle it at the call sites which allows do_adjtimex() to
    issue a single direct call if required.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lore.kernel.org/r/20210713135158.580966888@linutronix.de

commit a761a67f591a8c7476c30bb20ed0f09fdfb1a704
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jul 13 15:39:51 2021 +0200

    timekeeping: Distangle resume and clock-was-set events
    
    Resuming timekeeping is a clock-was-set event and uses the clock-was-set
    notification mechanism. This is in the way of making the clock-was-set
    update for hrtimers selective so unnecessary IPIs are avoided when a CPU
    base does not have timers queued which are affected by the clock setting.
    
    Distangle it by invoking hrtimer_resume() on each unfreezing CPU and invoke
    the new timerfd_resume() function from timekeeping_resume() which is the
    only place where this is needed.
    
    Rename hrtimer_resume() to hrtimer_resume_local() to reflect the change.
    
    With this the clock_was_set*() functions are not longer required to IPI all
    CPUs unconditionally and can get some smarts to avoid them.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lore.kernel.org/r/20210713135158.488853478@linutronix.de

commit 66f7b0c8aadd2785fc29f2c71477ebc16f4e38cc
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jul 13 15:39:50 2021 +0200

    timerfd: Provide timerfd_resume()
    
    Resuming timekeeping is a clock-was-set event and uses the clock-was-set
    notification mechanism. This is in the way of making the clock-was-set
    update for hrtimers selective so unnecessary IPIs are avoided when a CPU
    base does not have timers queued which are affected by the clock setting.
    
    Provide a seperate timerfd_resume() interface so the resume logic and the
    clock-was-set mechanism can be distangled in the core code.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lore.kernel.org/r/20210713135158.395287410@linutronix.de

commit d4c7c28806616809e3baa0b7cd8c665516b2726d
Author: Niklas Söderlund <niklas.soderlund+renesas@ragnatech.se>
Date:   Thu Feb 11 14:43:18 2021 +0100

    timekeeping: Allow runtime PM from change_clocksource()
    
    The struct clocksource callbacks enable() and disable() are described as a
    way to allow clock sources to enter a power save mode. See commit
    4614e6adafa2 ("clocksource: add enable() and disable() callbacks")
    
    But using runtime PM from these callbacks triggers a cyclic lockdep warning when
    switching clock source using change_clocksource().
    
      # echo e60f0000.timer > /sys/devices/system/clocksource/clocksource0/current_clocksource
       ======================================================
       WARNING: possible circular locking dependency detected
       ------------------------------------------------------
       migration/0/11 is trying to acquire lock:
       ffff0000403ed220 (&dev->power.lock){-...}-{2:2}, at: __pm_runtime_resume+0x40/0x74
    
       but task is already holding lock:
       ffff8000113c8f88 (tk_core.seq.seqcount){----}-{0:0}, at: multi_cpu_stop+0xa4/0x190
    
       which lock already depends on the new lock.
    
       the existing dependency chain (in reverse order) is:
    
       -> #2 (tk_core.seq.seqcount){----}-{0:0}:
              ktime_get+0x28/0xa0
              hrtimer_start_range_ns+0x210/0x2dc
              generic_sched_clock_init+0x70/0x88
              sched_clock_init+0x40/0x64
              start_kernel+0x494/0x524
    
       -> #1 (hrtimer_bases.lock){-.-.}-{2:2}:
              hrtimer_start_range_ns+0x68/0x2dc
              rpm_suspend+0x308/0x5dc
              rpm_idle+0xc4/0x2a4
              pm_runtime_work+0x98/0xc0
              process_one_work+0x294/0x6f0
              worker_thread+0x70/0x45c
              kthread+0x154/0x160
              ret_from_fork+0x10/0x20
    
       -> #0 (&dev->power.lock){-...}-{2:2}:
              _raw_spin_lock_irqsave+0x7c/0xc4
              __pm_runtime_resume+0x40/0x74
              sh_cmt_start+0x1c4/0x260
              sh_cmt_clocksource_enable+0x28/0x50
              change_clocksource+0x9c/0x160
              multi_cpu_stop+0xa4/0x190
              cpu_stopper_thread+0x90/0x154
              smpboot_thread_fn+0x244/0x270
              kthread+0x154/0x160
              ret_from_fork+0x10/0x20
    
       other info that might help us debug this:
    
       Chain exists of:
         &dev->power.lock --> hrtimer_bases.lock --> tk_core.seq.seqcount
    
        Possible unsafe locking scenario:
    
              CPU0                    CPU1
              ----                    ----
         lock(tk_core.seq.seqcount);
                                      lock(hrtimer_bases.lock);
                                      lock(tk_core.seq.seqcount);
         lock(&dev->power.lock);
    
        *** DEADLOCK ***
    
       2 locks held by migration/0/11:
        #0: ffff8000113c9278 (timekeeper_lock){-.-.}-{2:2}, at: change_clocksource+0x2c/0x160
        #1: ffff8000113c8f88 (tk_core.seq.seqcount){----}-{0:0}, at: multi_cpu_stop+0xa4/0x190
    
    Rework change_clocksource() so it enables the new clocksource and disables
    the old clocksource outside of the timekeeper_lock and seqcount write held
    region. There is no requirement that these callbacks are invoked from the
    lock held region.
    
    Signed-off-by: Niklas Söderlund <niklas.soderlund+renesas@ragnatech.se>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Link: https://lore.kernel.org/r/20210211134318.323910-1-niklas.soderlund+renesas@ragnatech.se

commit 4bf07f6562a01a488877e05267808da7147f44a5
Author: Ingo Molnar <mingo@kernel.org>
Date:   Mon Mar 22 22:39:03 2021 +0100

    timekeeping, clocksource: Fix various typos in comments
    
    Fix ~56 single-word typos in timekeeping & clocksource code comments.
    
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Stephen Boyd <sboyd@kernel.org>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: linux-kernel@vger.kernel.org

commit 7f3414226b58b0df0426104c8ab5e8d50ae71d11
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Fri Jan 15 12:49:45 2021 +0100

    um: time: fix initialization in time-travel mode
    
    In time-travel mode, since my previous patch, the start time was
    initialized too late, so that the system would read it before we
    set it, thus always starting system time at 0 (1970-01-01). This
    happens because timekeeping_init() reads the time and is called
    before time_init().
    
    Unfortunately, I didn't see this before because I was testing it
    only with the RTC patch applied (and enabled), and then the time
    is read again by the RTC a little - after time_init() this time.
    
    Fix this by just doing the initialization whenever necessary.
    
    Fixes: 2701c1bd91dd ("um: time: Fix read_persistent_clock64() in time-travel")
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: Richard Weinberger <richard@nod.at>

commit 025929f46813c572d4ef0b379c704bf664e8a7a3
Merge: 17b6c49da37f e3fab2f3de08
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Jan 24 09:58:38 2021 -0800

    Merge tag 'timers_urgent_for_v5.11_rc5' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer fixes from Borislav Petkov:
    
     - Fix an integer overflow in the NTP RTC synchronization which led to
       the latter happening every 2 seconds instead of the intended every 11
       minutes.
    
     - Get rid of now unused get_seconds().
    
    * tag 'timers_urgent_for_v5.11_rc5' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      ntp: Fix RTC synchronization on 32-bit platforms
      timekeeping: Remove unused get_seconds()

commit aba428a0c612bb259891307da12e22efd0fab14c
Author: Chunguang Xu <brookxu@tencent.com>
Date:   Tue Dec 1 17:52:31 2020 +0800

    timekeeping: Remove unused get_seconds()
    
    The get_seconds() cleanup seems to have been completed, now it is
    time to delete the legacy interface to avoid misuse later.
    
    Signed-off-by: Chunguang Xu <brookxu@tencent.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lore.kernel.org/r/1606816351-26900-1-git-send-email-brookxu@tencent.com

commit 2eeefc60ad70ffb7a5daf9f47aef5b1ebd1f39ad
Merge: 3b80dee70eaa f6f5cd840ae7
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Dec 27 09:03:41 2020 -0800

    Merge tag 'timers-urgent-2020-12-27' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer fixes from Ingo Molnar:
     "Update/fix two CPU sanity checks in the hotplug and the boot code, and
      fix a typo in the Kconfig help text.
    
      [ Context: the first two commits are the result of an ongoing
        annotation+review work of (intentional) tick_do_timer_cpu() data
        races reported by KCSAN, but the annotations aren't fully cooked
        yet ]"
    
    * tag 'timers-urgent-2020-12-27' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      timekeeping: Fix spelling mistake in Kconfig "fullfill" -> "fulfill"
      tick/sched: Remove bogus boot "safety" check
      tick: Remove pointless cpu valid check in hotplug code

commit f6f5cd840ae782680c5e94048c72420e4e6857f9
Author: Colin Ian King <colin.i.king@gmail.com>
Date:   Thu Dec 17 17:17:05 2020 +0000

    timekeeping: Fix spelling mistake in Kconfig "fullfill" -> "fulfill"
    
    There is a spelling mistake in the Kconfig help text. Fix it.
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Link: https://lore.kernel.org/r/20201217171705.57586-1-colin.king@canonical.com

commit 7a932e5702886e872a545d64605c06a51ee17973
Merge: 157807123c94 0774a6ed294b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Dec 16 00:07:17 2020 -0800

    Merge tag 'asm-generic-timers-5.11' of git://git.kernel.org/pub/scm/linux/kernel/git/arnd/asm-generic
    
    Pull asm-generic cross-architecture timer cleanup from Arnd Bergmann:
     "This cleans up two ancient timer features that were never completed in
      the past, CONFIG_GENERIC_CLOCKEVENTS and CONFIG_ARCH_USES_GETTIMEOFFSET.
    
      There was only one user left for the ARCH_USES_GETTIMEOFFSET variant
      of clocksource implementations, the ARM EBSA110 platform. Rather than
      changing to use modern timekeeping, we remove the platform entirely as
      Russell no longer uses his machine and nobody else seems to have one
      any more.
    
      The conditional code for using arch_gettimeoffset() is removed as a
      result.
    
      For CONFIG_GENERIC_CLOCKEVENTS, there are still a couple of platforms
      not using clockevent drivers: parisc, ia64, most of m68k, and one Arm
      platform. These all do timer ticks slighly differently, and this gets
      cleaned up to the point they at least all call the same helper
      function.
    
      Instead of most platforms using 'select GENERIC_CLOCKEVENTS' in
      Kconfig, the polarity is now reversed, with the few remaining ones
      selecting LEGACY_TIMER_TICK instead"
    
    * tag 'asm-generic-timers-5.11' of git://git.kernel.org/pub/scm/linux/kernel/git/arnd/asm-generic:
      timekeeping: default GENERIC_CLOCKEVENTS to enabled
      timekeeping: remove xtime_update
      m68k: remove timer_interrupt() function
      m68k: change remaining timers to legacy_timer_tick
      m68k: m68328: use legacy_timer_tick()
      m68k: sun3/sun3c: use legacy_timer_tick
      m68k: split heartbeat out of timer function
      m68k: coldfire: use legacy_timer_tick()
      parisc: use legacy_timer_tick
      ARM: rpc: use legacy_timer_tick
      ia64: convert to legacy_timer_tick
      timekeeping: add CONFIG_LEGACY_TIMER_TICK
      timekeeping: remove arch_gettimeoffset
      net: remove am79c961a driver
      ARM: remove ebsa110 platform

commit 533369b145d8d1bc44b8ed7f0dd0ecffb16384cc
Merge: 76d4acf22b48 3cabca87b329
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Dec 14 18:21:14 2020 -0800

    Merge tag 'timers-core-2020-12-14' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timers and timekeeping updates from Thomas Gleixner:
     "Core:
    
       - Robustness improvements for the NOHZ tick management
    
       - Fixes and consolidation of the NTP/RTC synchronization code
    
       - Small fixes and improvements in various places
    
       - A set of function documentation udpates and fixes
    
       Drivers:
    
       - Cleanups and improvements in various clocksoure/event drivers
    
       - Removal of the EZChip NPS clocksource driver as the platfrom
         support was removed from ARC
    
       - The usual set of new device tree binding and json conversions
    
       - The RTC driver which have been acked by the RTC maintainer:
    
           * fix a long standing bug in the MC146818 library code which can
             cause reading garbage during the RTC internal update.
    
           * changes related to the NTP/RTC consolidation work"
    
    * tag 'timers-core-2020-12-14' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (46 commits)
      ntp: Fix prototype in the !CONFIG_GENERIC_CMOS_UPDATE case
      tick/sched: Make jiffies update quick check more robust
      ntp: Consolidate the RTC update implementation
      ntp: Make the RTC sync offset less obscure
      ntp, rtc: Move rtc_set_ntp_time() to ntp code
      ntp: Make the RTC synchronization more reliable
      rtc: core: Make the sync offset default more realistic
      rtc: cmos: Make rtc_cmos sync offset correct
      rtc: mc146818: Reduce spinlock section in mc146818_set_time()
      rtc: mc146818: Prevent reading garbage
      clocksource/drivers/sh_cmt: Fix potential deadlock when calling runtime PM
      clocksource/drivers/arm_arch_timer: Correct fault programming of CNTKCTL_EL1.EVNTI
      clocksource/drivers/arm_arch_timer: Use stable count reader in erratum sne
      clocksource/drivers/dw_apb_timer_of: Add error handling if no clock available
      clocksource/drivers/riscv: Make RISCV_TIMER depends on RISCV_SBI
      clocksource/drivers/ingenic: Fix section mismatch
      clocksource/drivers/cadence_ttc: Fix memory leak in ttc_setup_clockevent()
      dt-bindings: timer: renesas: tmu: Convert to json-schema
      dt-bindings: timer: renesas: tmu: Document r8a774e1 bindings
      clocksource/drivers/orion: Add missing clk_disable_unprepare() on error path
      ...

commit 2701c1bd91dda815b8541aa8c23e1e548cdb6349
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Wed Dec 2 20:58:05 2020 +0100

    um: time: Fix read_persistent_clock64() in time-travel
    
    In time-travel mode, we've relied on read_persistent_clock64()
    being called only once at system startup, but this is both the
    right thing to call from the pseudo-RTC, and also gets called
    by the timekeeping core during suspend/resume.
    
    Thus, fix this to always fall make use of the time_travel_time
    in any time-travel mode, initializing time_travel_start at boot
    to the right value depending on the time-travel mode.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Acked-By: Anton Ivanov <anton.ivanov@cambridgegreys.com>
    Signed-off-by: Richard Weinberger <richard@nod.at>

commit 3cabca87b329cbcbdf295be0094adbd72c7b1f67
Author: Ingo Molnar <mingo@kernel.org>
Date:   Sat Dec 12 18:29:20 2020 +0100

    ntp: Fix prototype in the !CONFIG_GENERIC_CMOS_UPDATE case
    
    In the !CONFIG_GENERIC_CMOS_UPDATE case the update_persistent_clock64() function
    gets defined as a stub in ntp.c - make the prototype in <linux/timekeeping.h>
    conditional on CONFIG_GENERIC_CMOS_UPDATE as well.
    
    Fixes: 76e87d96b30b5 ("ntp: Consolidate the RTC update implementation")
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>

commit 5da5a1a1256c33570a51ad47b9616106d9083074
Author: Grygorii Strashko <grygorii.strashko@ti.com>
Date:   Wed Nov 18 16:19:00 2020 +0200

    bus: ti-sysc: suppress err msg for timers used as clockevent/source
    
    [ Upstream commit 65fb73676112f6fd107c5e542b2cbcfb206fe881 ]
    
    GP Timers used as clockevent/source are not available for ti-sysc bus and
    handled by Kernel timekeeping core. Now ti-sysc produces error message
    every time such timer is detected:
    
     "ti-sysc: probe of 48040000.target-module failed with error -16"
    
    Such messages are not necessary, so suppress them by returning -ENXIO
    instead of -EBUSY.
    
    Fixes: 6cfcd5563b4f ("clocksource/drivers/timer-ti-dm: Fix suspend and resume for am3 and am4")
    Signed-off-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 44a9e78f9242872c889f176782777fa2ed535650
Author: Sylwester Nawrocki <s.nawrocki@samsung.com>
Date:   Fri Nov 20 16:57:31 2020 +0100

    clk: samsung: Prevent potential endless loop in the PLL ops
    
    The PLL status polling loops in the set_rate callbacks of some PLLs
    have no timeout detection and may become endless loops when something
    goes wrong with the PLL.
    
    For some PLLs there is already the ktime API based timeout detection,
    but it will not work in all conditions when .set_rate gets called.
    In particular, before the clocksource is initialized or when the
    timekeeping is suspended.
    
    This patch adds a common helper with the PLL status bit polling and
    timeout detection. For conditions where the timekeeping API should not
    be used a simple readl_relaxed/cpu_relax() busy loop is added with the
    iterations limit derived from measurements of readl_relaxed() execution
    time for various PLL types and Exynos SoCs variants.
    
    Actual PLL lock time depends on the P divider value, the VCO frequency
    and a constant PLL type specific LOCK_FACTOR and can be calculated as
    
     lock_time = Pdiv * LOCK_FACTOR / VCO_freq
    
    For the ktime API use cases a common timeout value of 20 ms is applied
    for all the PLLs with an assumption that maximum possible value of Pdiv
    is 64, maximum possible LOCK_FACTOR value is 3000 and minimum VCO
    frequency is 24 MHz.
    
    Link: https://lore.kernel.org/r/20201120155731.26898-1-s.nawrocki@samsung.com
    Reviewed-by: Krzysztof Kozlowski <krzk@kernel.org>
    Signed-off-by: Sylwester Nawrocki <s.nawrocki@samsung.com>

commit 65fb73676112f6fd107c5e542b2cbcfb206fe881
Author: Grygorii Strashko <grygorii.strashko@ti.com>
Date:   Wed Nov 18 16:19:00 2020 +0200

    bus: ti-sysc: suppress err msg for timers used as clockevent/source
    
    GP Timers used as clockevent/source are not available for ti-sysc bus and
    handled by Kernel timekeeping core. Now ti-sysc produces error message
    every time such timer is detected:
    
     "ti-sysc: probe of 48040000.target-module failed with error -16"
    
    Such messages are not necessary, so suppress them by returning -ENXIO
    instead of -EBUSY.
    
    Fixes: 6cfcd5563b4f ("clocksource/drivers/timer-ti-dm: Fix suspend and resume for am3 and am4")
    Signed-off-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

commit 58953e87343dff07041c1cad1fd710805c4eec24
Author: Chunyan Zhang <zhang.lyra@gmail.com>
Date:   Fri Jan 10 16:39:02 2020 +0800

    tick/common: Touch watchdog in tick_unfreeze() on all CPUs
    
    commit 5167c506d62dd9ffab73eba23c79b0a8845c9fe1 upstream.
    
    Suspend to IDLE invokes tick_unfreeze() on resume. tick_unfreeze() on the
    first resuming CPU resumes timekeeping, which also has the side effect of
    resetting the softlockup watchdog on this CPU.
    
    But on the secondary CPUs the watchdog is not reset in the resume /
    unfreeze() path, which can result in false softlockup warnings on those
    CPUs depending on the time spent in suspend.
    
    Prevent this by clearing the softlock watchdog in the unfreeze path also
    on the secondary resuming CPUs.
    
    [ tglx: Massaged changelog ]
    
    Signed-off-by: Chunyan Zhang <chunyan.zhang@unisoc.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lore.kernel.org/r/20200110083902.27276-1-chunyan.zhang@unisoc.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 880d94c7811ebe89ab7edc7e8839ccdf0eedcd91
Author: Chunyan Zhang <zhang.lyra@gmail.com>
Date:   Fri Jan 10 16:39:02 2020 +0800

    tick/common: Touch watchdog in tick_unfreeze() on all CPUs
    
    commit 5167c506d62dd9ffab73eba23c79b0a8845c9fe1 upstream.
    
    Suspend to IDLE invokes tick_unfreeze() on resume. tick_unfreeze() on the
    first resuming CPU resumes timekeeping, which also has the side effect of
    resetting the softlockup watchdog on this CPU.
    
    But on the secondary CPUs the watchdog is not reset in the resume /
    unfreeze() path, which can result in false softlockup warnings on those
    CPUs depending on the time spent in suspend.
    
    Prevent this by clearing the softlock watchdog in the unfreeze path also
    on the secondary resuming CPUs.
    
    [ tglx: Massaged changelog ]
    
    Signed-off-by: Chunyan Zhang <chunyan.zhang@unisoc.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lore.kernel.org/r/20200110083902.27276-1-chunyan.zhang@unisoc.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 6e5a91901c2dff3a0f2eb9f10e427dce2b0488fc
Author: Alex Shi <alexs@kernel.org>
Date:   Fri Nov 13 15:24:34 2020 +0800

    timekeeping: Address parameter documentation issues for various functions
    
    The kernel-doc parser complains:
    
     kernel/time/timekeeping.c:1543: warning: Function parameter or member
     'ts' not described in 'read_persistent_clock64'
    
     kernel/time/timekeeping.c:764: warning: Function parameter or member
     'tk' not described in 'timekeeping_forward_now'
    
     kernel/time/timekeeping.c:1331: warning: Function parameter or member
     'ts' not described in 'timekeeping_inject_offset'
    
     kernel/time/timekeeping.c:1331: warning: Excess function parameter 'tv'
     description in 'timekeeping_inject_offset'
    
    Add the missing parameter documentations and rename the 'tv' parameter of
    timekeeping_inject_offset() to 'ts' so it matches the implemention.
    
    [ tglx: Reworded a few docs and massaged changelog ]
    
    Signed-off-by: Alex Shi <alex.shi@linux.alibaba.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lore.kernel.org/r/1605252275-63652-5-git-send-email-alex.shi@linux.alibaba.com

commit 29efc4612ac1b888e65da408b41dafa4dd00842f
Author: Alex Shi <alexs@kernel.org>
Date:   Fri Nov 13 15:24:35 2020 +0800

    timekeeping: Fix parameter docs of read_persistent_wall_and_boot_offset()
    
    Address the following kernel-doc markup warnings:
    
     kernel/time/timekeeping.c:1563: warning: Function parameter or member
     'wall_time' not described in 'read_persistent_wall_and_boot_offset'
     kernel/time/timekeeping.c:1563: warning: Function parameter or member
     'boot_offset' not described in 'read_persistent_wall_and_boot_offset'
    
    The parameters are described but miss the leading '@' and the colon after
    the parameter names.
    
    [ tglx: Massaged changelog ]
    
    Signed-off-by: Alex Shi <alex.shi@linux.alibaba.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lore.kernel.org/r/1605252275-63652-6-git-send-email-alex.shi@linux.alibaba.com

commit f27f7c3f100e74a7f451a63a15788f50c52f7cce
Author: Alex Shi <alexs@kernel.org>
Date:   Fri Nov 13 15:24:32 2020 +0800

    timekeeping: Add missing parameter docs for pvclock_gtod_[un]register_notifier()
    
    The kernel-doc parser complains about:
     kernel/time/timekeeping.c:651: warning: Function parameter or member
     'nb' not described in 'pvclock_gtod_register_notifier'
     kernel/time/timekeeping.c:670: warning: Function parameter or member
     'nb' not described in 'pvclock_gtod_unregister_notifier'
    
    Add the missing parameter explanations.
    
    [ tglx: Massaged changelog ]
    
    Signed-off-by: Alex Shi <alex.shi@linux.alibaba.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lore.kernel.org/r/1605252275-63652-3-git-send-email-alex.shi@linux.alibaba.com

commit c1ce406e80fb15fa52b2b48dfd48fad6f3d2a32f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun Nov 15 21:09:31 2020 +0100

    timekeeping: Fix up function documentation for the NMI safe accessors
    
    Alex reported the following warning:
    
     kernel/time/timekeeping.c:464: warning: Function parameter or member
     'tkf' not described in '__ktime_get_fast_ns'
    
    which is not entirely correct because the documented function is
    ktime_get_mono_fast_ns() which does not have a parameter, but the
    kernel-doc parser looks at the function declaration which follows the
    comment and complains about the missing parameter documentation.
    
    Aside of that the documentation for the rest of the NMI safe accessors is
    either incomplete or missing.
    
      - Move the function documentation to the right place
      - Fixup the references and inconsistencies
      - Add the missing documentation for ktime_get_raw_fast_ns()
    
    Reported-by: Alex Shi <alex.shi@linux.alibaba.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit e025b03113d27139ce2b28b82599018e4d8fa5f6
Author: Alex Shi <alexs@kernel.org>
Date:   Fri Nov 13 15:24:31 2020 +0800

    timekeeping: Add missing parameter documentation for update_fast_timekeeper()
    
    Address the following warning:
    
     kernel/time/timekeeping.c:415: warning: Function parameter or member
     'tkf' not described in 'update_fast_timekeeper'
    
    [ tglx: Remove the bogus ktime_get_mono_fast_ns() part ]
    
    Signed-off-by: Alex Shi <alex.shi@linux.alibaba.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lore.kernel.org/r/1605252275-63652-2-git-send-email-alex.shi@linux.alibaba.com

commit 199d280c884de44c3b0daeb77438db43f6db01a2
Author: Alex Shi <alexs@kernel.org>
Date:   Fri Nov 13 15:24:33 2020 +0800

    timekeeping: Remove static functions from kernel-doc markup
    
    Various static functions in the timekeeping code have function comments
    which pretend to be kernel-doc, but are incomplete and trigger parser
    warnings.
    
    As these functions are local to the timekeeping core code there is no need
    to expose them via kernel-doc.
    
    Remove the double star kernel-doc marker and remove excess newlines.
    
    [ tglx: Massaged changelog and removed excess newlines ]
    
    Signed-off-by: Alex Shi <alex.shi@linux.alibaba.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lore.kernel.org/r/1605252275-63652-4-git-send-email-alex.shi@linux.alibaba.com

commit b9795a3e4e1cbf521bbb5ef240eb47803c303b02
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Tue Nov 3 16:06:26 2020 +0100

    PM: domains: Enable dev_pm_genpd_suspend|resume() for suspend-to-idle
    
    The dev_pm_genpd_suspend|resume() have so far only been used during the
    syscore suspend/resume phases. However, during suspend-to-idle, where the
    syscore phases doesn't exist, similar operations are sometimes needed.
    
    An existing example are the timekeeping_suspend|resume() functions, which
    are being called both through a registered syscore ops during the syscore
    phases, but also as regular functions calls from cpuidle (via
    tick_freeze()) during suspend-to-idle.
    
    For similar reasons, let's enable the dev_pm_genpd_suspend|resume() APIs to
    be re-used for corresponding CPU devices that are attached to a genpd,
    during suspend-to-idle.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 1eafbd27edb5098ed6b6bc404c35d56c78beb0fd
Author: Ben Gardon <bgardon@google.com>
Date:   Tue Oct 27 16:37:31 2020 -0700

    KVM: selftests: Simplify demand_paging_test with timespec_diff_now
    
    Add a helper function to get the current time and return the time since
    a given start time. Use that function to simplify the timekeeping in the
    demand paging test.
    
    This series was tested by running the following invocations on an Intel
    Skylake machine:
    dirty_log_perf_test -b 20m -i 100 -v 64
    dirty_log_perf_test -b 20g -i 5 -v 4
    dirty_log_perf_test -b 4g -i 5 -v 32
    demand_paging_test -b 20m -v 64
    demand_paging_test -b 20g -v 4
    demand_paging_test -b 4g -v 32
    All behaved as expected.
    
    Signed-off-by: Ben Gardon <bgardon@google.com>
    Message-Id: <20201027233733.1484855-4-bgardon@google.com>
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>

commit 4312e0e8d3eab027d9506db091eb10e6a9ff25d3
Merge: 82423b46fc9e cb47755725da
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Nov 1 11:13:45 2020 -0800

    Merge tag 'timers-urgent-2020-11-01' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer fixes from Thomas Gleixner:
     "A few fixes for timers/timekeeping:
    
       - Prevent undefined behaviour in the timespec64_to_ns() conversion
         which is used for converting user supplied time input to
         nanoseconds. It lacked overflow protection.
    
       - Mark sched_clock_read_begin/retry() to prevent recursion in the
         tracer
    
       - Remove unused debug functions in the hrtimer and timerlist code"
    
    * tag 'timers-urgent-2020-11-01' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      time: Prevent undefined behaviour in timespec64_to_ns()
      timers: Remove unused inline funtion debug_timer_free()
      hrtimer: Remove unused inline function debug_hrtimer_free()
      time/sched_clock: Mark sched_clock_read_begin/retry() as notrace

commit 0774a6ed294b963dc76df2d8342ab86d030759ec
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Thu Sep 24 11:32:40 2020 +0200

    timekeeping: default GENERIC_CLOCKEVENTS to enabled
    
    Almost all machines use GENERIC_CLOCKEVENTS, so it feels wrong to
    require each one to select that symbol manually.
    
    Instead, enable it whenever CONFIG_LEGACY_TIMER_TICK is disabled as
    a simplification. It should be possible to select both
    GENERIC_CLOCKEVENTS and LEGACY_TIMER_TICK from an architecture now
    and decide at runtime between the two.
    
    For the clockevents arch-support.txt file, this means that additional
    architectures are marked as TODO when they have at least one machine
    that still uses LEGACY_TIMER_TICK, rather than being marked 'ok' when
    at least one machine has been converted. This means that both m68k and
    arm (for riscpc) revert to TODO.
    
    At this point, we could just always enable CONFIG_GENERIC_CLOCKEVENTS
    rather than leaving it off when not needed. I built an m68k
    defconfig kernel (using gcc-10.1.0) and found that this would add
    around 5.5KB in kernel image size:
    
       text    data     bss     dec     hex filename
    3861936 1092236  196656 5150828  4e986c obj-m68k/vmlinux-no-clockevent
    3866201 1093832  196184 5156217  4ead79 obj-m68k/vmlinux-clockevent
    
    On Arm (MACH_RPC), that difference appears to be twice as large,
    around 11KB on top of an 6MB vmlinux.
    
    Reviewed-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Acked-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Tested-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

commit 56cc7b8acfb7c763f71c0492fa8da01dca7c1760
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Thu Sep 24 17:39:11 2020 +0200

    timekeeping: remove xtime_update
    
    There are no more users of xtime_update aside from legacy_timer_tick(),
    so fold it into that function and remove the declaration.
    
    update_process_times() is now only called inside of the kernel/time/
    code, so the declaration can be moved there.
    
    Reviewed-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Tested-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

commit 686092e7daaa9f43396c57ea0044799e47f0d9da
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Thu Sep 24 15:30:34 2020 +0200

    parisc: use legacy_timer_tick
    
    parisc has selected CONFIG_GENERIC_CLOCKEVENTS since commit 43b1f6abd590
    ("parisc: Switch to generic sched_clock implementation"), but does not
    appear to actually be using it, and instead calls the low-level
    timekeeping functions directly.
    
    Remove the GENERIC_CLOCKEVENTS select again, and instead convert to
    the newly added legacy_timer_tick() helper.
    
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

commit b3550164a19d62e515af6cacb5a31f0b2b3f9501
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Thu Sep 24 15:21:43 2020 +0200

    timekeeping: add CONFIG_LEGACY_TIMER_TICK
    
    All platforms that currently do not use generic clockevents roughly call
    the same set of functions in their timer interrupts: xtime_update(),
    update_process_times() and profile_tick(), sometimes in a different
    sequence.
    
    Add a helper function that performs all three of them, to make the
    callers more uniform and simplify the interface.
    
    Reviewed-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

commit 77f6c0b87479c4578ac0798fc249637092ac45a3
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Thu Sep 24 12:30:50 2020 +0200

    timekeeping: remove arch_gettimeoffset
    
    With Arm EBSA110 gone, nothing uses it any more, so the corresponding
    code and the Kconfig option can be removed.
    
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

commit 1a2b85f1e2a93a3f84243e654d225e4088735336
Author: Davidlohr Bueso <dave@stgolabs.net>
Date:   Wed Oct 21 12:07:49 2020 -0700

    timekeeping: Convert jiffies_seq to seqcount_raw_spinlock_t
    
    Use the new api and associate the seqcounter to the jiffies_lock enabling
    lockdep support - although for this particular case the write-side locking
    and non-preemptibility are quite obvious.
    
    Signed-off-by: Davidlohr Bueso <dbueso@suse.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lore.kernel.org/r/20201021190749.19363-1-dave@stgolabs.net

commit ed016af52ee3035b4799ebd7d53f9ae59d5782c4
Merge: edaa5ddf3833 2116d708b058
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Oct 12 13:06:20 2020 -0700

    Merge tag 'locking-core-2020-10-12' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull locking updates from Ingo Molnar:
     "These are the locking updates for v5.10:
    
       - Add deadlock detection for recursive read-locks.
    
         The rationale is outlined in commit 224ec489d3cd ("lockdep/
         Documention: Recursive read lock detection reasoning")
    
         The main deadlock pattern we want to detect is:
    
               TASK A:                 TASK B:
    
               read_lock(X);
                                       write_lock(X);
               read_lock_2(X);
    
       - Add "latch sequence counters" (seqcount_latch_t):
    
         A sequence counter variant where the counter even/odd value is used
         to switch between two copies of protected data. This allows the
         read path, typically NMIs, to safely interrupt the write side
         critical section.
    
         We utilize this new variant for sched-clock, and to make x86 TSC
         handling safer.
    
       - Other seqlock cleanups, fixes and enhancements
    
       - KCSAN updates
    
       - LKMM updates
    
       - Misc updates, cleanups and fixes"
    
    * tag 'locking-core-2020-10-12' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (67 commits)
      lockdep: Revert "lockdep: Use raw_cpu_*() for per-cpu variables"
      lockdep: Fix lockdep recursion
      lockdep: Fix usage_traceoverflow
      locking/atomics: Check atomic-arch-fallback.h too
      locking/seqlock: Tweak DEFINE_SEQLOCK() kernel doc
      lockdep: Optimize the memory usage of circular queue
      seqlock: Unbreak lockdep
      seqlock: PREEMPT_RT: Do not starve seqlock_t writers
      seqlock: seqcount_LOCKNAME_t: Introduce PREEMPT_RT support
      seqlock: seqcount_t: Implement all read APIs as statement expressions
      seqlock: Use unique prefix for seqcount_t property accessors
      seqlock: seqcount_LOCKNAME_t: Standardize naming convention
      seqlock: seqcount latch APIs: Only allow seqcount_latch_t
      rbtree_latch: Use seqcount_latch_t
      x86/tsc: Use seqcount_latch_t
      timekeeping: Use seqcount_latch_t
      time/sched_clock: Use seqcount_latch_t
      seqlock: Introduce seqcount_latch_t
      mm/swap: Do not abuse the seqcount_t latching API
      time/sched_clock: Use raw_read_seqcount_latch() during suspend
      ...

commit f5f59336a9ae8f683772d6b8cb2d6732b5e567ea
Merge: 20d49bfcc3d2 1b80043ed218
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Oct 12 11:27:54 2020 -0700

    Merge tag 'timers-core-2020-10-12' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timekeeping updates from Thomas Gleixner:
     "Updates for timekeeping, timers and related drivers:
    
      Core:
    
       - Early boot support for the NMI safe timekeeper by utilizing
         local_clock() up to the point where timekeeping is initialized.
         This allows printk() to store multiple timestamps in the ringbuffer
         which is useful for coordinating dmesg information across a fleet
         of machines.
    
       - Provide a multi-timestamp accessor for printk()
    
       - Make timer init more robust by checking for invalid timer flags.
    
       - Comma vs semicolon fixes
    
      Drivers:
    
       - Support for new platforms in existing drivers (SP804 and Renesas
         CMT)
    
       - Comma vs semicolon fixes
    
    * tag 'timers-core-2020-10-12' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      clocksource/drivers/armada-370-xp: Use semicolons rather than commas to separate statements
      clocksource/drivers/mps2-timer: Use semicolons rather than commas to separate statements
      timers: Mask invalid flags in do_init_timer()
      clocksource/drivers/sp804: Enable Hisilicon sp804 timer 64bit mode
      clocksource/drivers/sp804: Add support for Hisilicon sp804 timer
      clocksource/drivers/sp804: Support non-standard register offset
      clocksource/drivers/sp804: Prepare for support non-standard register offset
      clocksource/drivers/sp804: Remove a mismatched comment
      clocksource/drivers/sp804: Delete the leading "__" of some functions
      clocksource/drivers/sp804: Remove unused sp804_timer_disable() and timer-sp804.h
      clocksource/drivers/sp804: Cleanup clk_get_sys()
      dt-bindings: timer: renesas,cmt: Document r8a774e1 CMT support
      dt-bindings: timer: renesas,cmt: Document r8a7742 CMT support
      alarmtimer: Convert comma to semicolon
      timekeeping: Provide multi-timestamp accessor to NMI safe timekeeper
      timekeeping: Utilize local_clock() for NMI safe timekeeper during early boot

commit 61f27ba2dd639ddbffd64ea2c975481bb386d7d2
Author: Wen Yang <wenyang@linux.alibaba.com>
Date:   Mon Jan 20 18:05:23 2020 +0800

    timekeeping: Prevent 32bit truncation in scale64_check_overflow()
    
    [ Upstream commit 4cbbc3a0eeed675449b1a4d080008927121f3da3 ]
    
    While unlikely the divisor in scale64_check_overflow() could be >= 32bit in
    scale64_check_overflow(). do_div() truncates the divisor to 32bit at least
    on 32bit platforms.
    
    Use div64_u64() instead to avoid the truncation to 32-bit.
    
    [ tglx: Massaged changelog ]
    
    Signed-off-by: Wen Yang <wenyang@linux.alibaba.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lkml.kernel.org/r/20200120100523.45656-1-wenyang@linux.alibaba.com
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit efc95f2ef743506638648a091887c0a8a8f1079b
Author: Wen Yang <wenyang@linux.alibaba.com>
Date:   Mon Jan 20 18:05:23 2020 +0800

    timekeeping: Prevent 32bit truncation in scale64_check_overflow()
    
    [ Upstream commit 4cbbc3a0eeed675449b1a4d080008927121f3da3 ]
    
    While unlikely the divisor in scale64_check_overflow() could be >= 32bit in
    scale64_check_overflow(). do_div() truncates the divisor to 32bit at least
    on 32bit platforms.
    
    Use div64_u64() instead to avoid the truncation to 32-bit.
    
    [ tglx: Massaged changelog ]
    
    Signed-off-by: Wen Yang <wenyang@linux.alibaba.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lkml.kernel.org/r/20200120100523.45656-1-wenyang@linux.alibaba.com
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 627b771be7d7a36b1a62049912003736bc79edb4
Author: Wen Yang <wenyang@linux.alibaba.com>
Date:   Mon Jan 20 18:05:23 2020 +0800

    timekeeping: Prevent 32bit truncation in scale64_check_overflow()
    
    [ Upstream commit 4cbbc3a0eeed675449b1a4d080008927121f3da3 ]
    
    While unlikely the divisor in scale64_check_overflow() could be >= 32bit in
    scale64_check_overflow(). do_div() truncates the divisor to 32bit at least
    on 32bit platforms.
    
    Use div64_u64() instead to avoid the truncation to 32-bit.
    
    [ tglx: Massaged changelog ]
    
    Signed-off-by: Wen Yang <wenyang@linux.alibaba.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lkml.kernel.org/r/20200120100523.45656-1-wenyang@linux.alibaba.com
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 62658ebe5c19c47419a82b21736770b1d99135e7
Author: Wen Yang <wenyang@linux.alibaba.com>
Date:   Mon Jan 20 18:05:23 2020 +0800

    timekeeping: Prevent 32bit truncation in scale64_check_overflow()
    
    [ Upstream commit 4cbbc3a0eeed675449b1a4d080008927121f3da3 ]
    
    While unlikely the divisor in scale64_check_overflow() could be >= 32bit in
    scale64_check_overflow(). do_div() truncates the divisor to 32bit at least
    on 32bit platforms.
    
    Use div64_u64() instead to avoid the truncation to 32-bit.
    
    [ tglx: Massaged changelog ]
    
    Signed-off-by: Wen Yang <wenyang@linux.alibaba.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lkml.kernel.org/r/20200120100523.45656-1-wenyang@linux.alibaba.com
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 249d053835320cb3e7c00066cf085a6ba9b1f126
Author: Ahmed S. Darwish <a.darwish@linutronix.de>
Date:   Thu Aug 27 13:40:41 2020 +0200

    timekeeping: Use seqcount_latch_t
    
    Latch sequence counters are a multiversion concurrency control mechanism
    where the seqcount_t counter even/odd value is used to switch between
    two data storage copies. This allows the seqcount_t read path to safely
    interrupt its write side critical section (e.g. from NMIs).
    
    Initially, latch sequence counters were implemented as a single write
    function, raw_write_seqcount_latch(), above plain seqcount_t. The read
    path was expected to use plain seqcount_t raw_read_seqcount().
    
    A specialized read function was later added, raw_read_seqcount_latch(),
    and became the standardized way for latch read paths. Having unique read
    and write APIs meant that latch sequence counters are basically a data
    type of their own -- just inappropriately overloading plain seqcount_t.
    The seqcount_latch_t data type was thus introduced at seqlock.h.
    
    Use that new data type instead of seqcount_raw_spinlock_t. This ensures
    that only latch-safe APIs are to be used with the sequence counter.
    
    Note that the use of seqcount_raw_spinlock_t was not very useful in the
    first place. Only the "raw_" subset of seqcount_t APIs were used at
    timekeeping.c. This subset was created for contexts where lockdep cannot
    be used. seqcount_LOCKTYPE_t's raison d'être -- verifying that the
    seqcount_t writer serialization lock is held -- cannot thus be done.
    
    References: 0c3351d451ae ("seqlock: Use raw_ prefix instead of _no_lockdep")
    References: 55f3560df975 ("seqlock: Extend seqcount API with associated locks")
    Signed-off-by: Ahmed S. Darwish <a.darwish@linutronix.de>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Link: https://lkml.kernel.org/r/20200827114044.11173-6-a.darwish@linutronix.de

commit e2d977c9f1abd1d199b412f8f83c1727808b794d
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Aug 14 12:19:35 2020 +0200

    timekeeping: Provide multi-timestamp accessor to NMI safe timekeeper
    
    printk wants to store various timestamps (MONOTONIC, REALTIME, BOOTTIME) to
    make correlation of dmesg from several systems easier.
    
    Provide an interface to retrieve all three timestamps in one go.
    
    There are some caveats:
    
    1) Boot time and late sleep time injection
    
      Boot time is a racy access on 32bit systems if the sleep time injection
      happens late during resume and not in timekeeping_resume(). That could be
      avoided by expanding struct tk_read_base with boot offset for 32bit and
      adding more overhead to the update. As this is a hard to observe once per
      resume event which can be filtered with reasonable effort using the
      accurate mono/real timestamps, it's probably not worth the trouble.
    
      Aside of that it might be possible on 32 and 64 bit to observe the
      following when the sleep time injection happens late:
    
      CPU 0                                  CPU 1
      timekeeping_resume()
      ktime_get_fast_timestamps()
        mono, real = __ktime_get_real_fast()
                                             inject_sleep_time()
                                               update boot offset
            boot = mono + bootoffset;
    
      That means that boot time already has the sleep time adjustment, but
      real time does not. On the next readout both are in sync again.
    
      Preventing this for 64bit is not really feasible without destroying the
      careful cache layout of the timekeeper because the sequence count and
      struct tk_read_base would then need two cache lines instead of one.
    
    2) Suspend/resume timestamps
    
       Access to the time keeper clock source is disabled accross the innermost
       steps of suspend/resume. The accessors still work, but the timestamps
       are frozen until time keeping is resumed which happens very early.
    
       For regular suspend/resume there is no observable difference vs. sched
       clock, but it might affect some of the nasty low level debug printks.
    
       OTOH, access to sched clock is not guaranteed accross suspend/resume on
       all systems either so it depends on the hardware in use.
    
       If that turns out to be a real problem then this could be mitigated by
       using sched clock in a similar way as during early boot. But it's not as
       trivial as on early boot because it needs some careful protection
       against the clock monotonic timestamp jumping backwards on resume.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Petr Mladek <pmladek@suse.com>
    Link: https://lore.kernel.org/r/20200814115512.159981360@linutronix.de

commit 71419b30cab099f7ca37e61bf41028d8b7d4984d
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Aug 14 12:19:34 2020 +0200

    timekeeping: Utilize local_clock() for NMI safe timekeeper during early boot
    
    During early boot the NMI safe timekeeper returns 0 until the first
    clocksource becomes available.
    
    This prevents it from being used for printk or other facilities which today
    use sched clock. sched clock can be available way before timekeeping is
    initialized.
    
    The obvious workaround for this is to utilize the early sched clock in the
    default dummy clock read function until a clocksource becomes available.
    
    After switching to the clocksource clock MONOTONIC and BOOTTIME will not
    jump because the timekeeping_init() bases clock MONOTONIC on sched clock
    and the offset between clock MONOTONIC and BOOTTIME is zero during boot.
    
    Clock REALTIME cannot provide useful timestamps during early boot up to
    the point where a persistent clock becomes available, which is either in
    timekeeping_init() or later when the RTC driver which might depend on I2C
    or other subsystems is initialized.
    
    There is a minor difference to sched_clock() vs. suspend/resume. As the
    timekeeper clock source might not be accessible during suspend, after
    timekeeping_suspend() timestamps freeze up to the point where
    timekeeping_resume() is invoked. OTOH this is true for some sched clock
    implementations as well.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Petr Mladek <pmladek@suse.com>
    Link: https://lore.kernel.org/r/20200814115512.041422402@linutronix.de

commit 06769a572492f56c6bcc824a17f8055ecc100136
Author: Douglas Anderson <dianders@chromium.org>
Date:   Thu May 28 07:48:34 2020 -0700

    soc: qcom: rpmh-rsc: Don't use ktime for timeout in write_tcs_reg_sync()
    
    [ Upstream commit be24c6a71ecfbd9436ea1f496eb518a53e06368c ]
    
    The write_tcs_reg_sync() may be called after timekeeping is suspended
    so it's not OK to use ktime.  The readl_poll_timeout_atomic() macro
    implicitly uses ktime.  This was causing a warning at suspend time.
    
    Change to just loop 1000000 times with a delay of 1 us between loops.
    This may give a timeout of more than 1 second but never less and is
    safe even if timekeeping is suspended.
    
    NOTE: I don't have any actual evidence that we need to loop here.
    It's possibly that all we really need to do is just read the value
    back to ensure that the pipes are cleaned and the looping/comparing is
    totally not needed.  I never saw the loop being needed in my tests.
    However, the loop shouldn't hurt.
    
    Reviewed-by: Stephen Boyd <sboyd@kernel.org>
    Reviewed-by: Maulik Shah <mkshah@codeaurora.org>
    Fixes: 91160150aba0 ("soc: qcom: rpmh-rsc: Timeout after 1 second in write_tcs_reg_sync()")
    Reported-by: Maulik Shah <mkshah@codeaurora.org>
    Signed-off-by: Douglas Anderson <dianders@chromium.org>
    Link: https://lore.kernel.org/r/20200528074530.1.Ib86e5b406fe7d16575ae1bb276d650faa144b63c@changeid
    Signed-off-by: Bjorn Andersson <bjorn.andersson@linaro.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit b923f1247b72fc100b87792fd2129d026bb10e66
Merge: b6b178e38f40 b0294f30256b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Aug 14 14:26:08 2020 -0700

    Merge tag 'timers-urgent-2020-08-14' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timekeeping updates from Thomas Gleixner:
     "A set of timekeeping/VDSO updates:
    
       - Preparatory work to allow S390 to switch over to the generic VDSO
         implementation.
    
         S390 requires that the VDSO data pointer is handed in to the
         counter read function when time namespace support is enabled.
         Adding the pointer is a NOOP for all other architectures because
         the compiler is supposed to optimize that out when it is unused in
         the architecture specific inline. The change also solved a similar
         problem for MIPS which fortunately has time namespaces not yet
         enabled.
    
         S390 needs to update clock related VDSO data independent of the
         timekeeping updates. This was solved so far with yet another
         sequence counter in the S390 implementation. A better solution is
         to utilize the already existing VDSO sequence count for this. The
         core code now exposes helper functions which allow to serialize
         against the timekeeper code and against concurrent readers.
    
         S390 needs extra data for their clock readout function. The initial
         common VDSO data structure did not provide a way to add that. It
         now has an embedded architecture specific struct embedded which
         defaults to an empty struct.
    
         Doing this now avoids tree dependencies and conflicts post rc1 and
         allows all other architectures which work on generic VDSO support
         to work from a common upstream base.
    
       - A trivial comment fix"
    
    * tag 'timers-urgent-2020-08-14' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      time: Delete repeated words in comments
      lib/vdso: Allow to add architecture-specific vdso data
      timekeeping/vsyscall: Provide vdso_update_begin/end()
      vdso/treewide: Add vdso_data pointer argument to __arch_get_hw_counter()

commit 97d052ea3fa853b9aabcc4baca1a605cb1188611
Merge: 086ba2ec163b 0cd39f4600ed
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Aug 10 19:07:44 2020 -0700

    Merge tag 'locking-urgent-2020-08-10' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull locking updates from Thomas Gleixner:
     "A set of locking fixes and updates:
    
       - Untangle the header spaghetti which causes build failures in
         various situations caused by the lockdep additions to seqcount to
         validate that the write side critical sections are non-preemptible.
    
       - The seqcount associated lock debug addons which were blocked by the
         above fallout.
    
         seqcount writers contrary to seqlock writers must be externally
         serialized, which usually happens via locking - except for strict
         per CPU seqcounts. As the lock is not part of the seqcount, lockdep
         cannot validate that the lock is held.
    
         This new debug mechanism adds the concept of associated locks.
         sequence count has now lock type variants and corresponding
         initializers which take a pointer to the associated lock used for
         writer serialization. If lockdep is enabled the pointer is stored
         and write_seqcount_begin() has a lockdep assertion to validate that
         the lock is held.
    
         Aside of the type and the initializer no other code changes are
         required at the seqcount usage sites. The rest of the seqcount API
         is unchanged and determines the type at compile time with the help
         of _Generic which is possible now that the minimal GCC version has
         been moved up.
    
         Adding this lockdep coverage unearthed a handful of seqcount bugs
         which have been addressed already independent of this.
    
         While generally useful this comes with a Trojan Horse twist: On RT
         kernels the write side critical section can become preemtible if
         the writers are serialized by an associated lock, which leads to
         the well known reader preempts writer livelock. RT prevents this by
         storing the associated lock pointer independent of lockdep in the
         seqcount and changing the reader side to block on the lock when a
         reader detects that a writer is in the write side critical section.
    
       - Conversion of seqcount usage sites to associated types and
         initializers"
    
    * tag 'locking-urgent-2020-08-10' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (25 commits)
      locking/seqlock, headers: Untangle the spaghetti monster
      locking, arch/ia64: Reduce <asm/smp.h> header dependencies by moving XTP bits into the new <asm/xtp.h> header
      x86/headers: Remove APIC headers from <asm/smp.h>
      seqcount: More consistent seqprop names
      seqcount: Compress SEQCNT_LOCKNAME_ZERO()
      seqlock: Fold seqcount_LOCKNAME_init() definition
      seqlock: Fold seqcount_LOCKNAME_t definition
      seqlock: s/__SEQ_LOCKDEP/__SEQ_LOCK/g
      hrtimer: Use sequence counter with associated raw spinlock
      kvm/eventfd: Use sequence counter with associated spinlock
      userfaultfd: Use sequence counter with associated spinlock
      NFSv4: Use sequence counter with associated spinlock
      iocost: Use sequence counter with associated spinlock
      raid5: Use sequence counter with associated spinlock
      vfs: Use sequence counter with associated spinlock
      timekeeping: Use sequence counter with associated raw spinlock
      xfrm: policy: Use sequence counters with associated lock
      netfilter: nft_set_rbtree: Use sequence counter with associated rwlock
      netfilter: conntrack: Use sequence counter with associated spinlock
      sched: tasks: Use sequence counter with associated spinlock
      ...

commit 19d0070a2792181f79df01277fe00b83b9f7eda7
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Aug 4 17:01:23 2020 +0200

    timekeeping/vsyscall: Provide vdso_update_begin/end()
    
    Architectures can have the requirement to add additional architecture
    specific data to the VDSO data page which needs to be updated independent
    of the timekeeper updates.
    
    To protect these updates vs. concurrent readers and a conflicting update
    through timekeeping, provide helper functions to make such updates safe.
    
    vdso_update_begin() takes the timekeeper_lock to protect against a
    potential update from timekeeper code and increments the VDSO sequence
    count to signal data inconsistency to concurrent readers. vdso_update_end()
    makes the sequence count even again to signal data consistency and drops
    the timekeeper lock.
    
    [ Sven: Add interrupt disable handling to the functions ]
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Sven Schnelle <svens@linux.ibm.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lkml.kernel.org/r/20200804150124.41692-3-svens@linux.ibm.com

commit 025e82bcbc34cd071390e72fd0b31593282f9425
Author: Ahmed S. Darwish <a.darwish@linutronix.de>
Date:   Mon Jul 20 17:55:23 2020 +0200

    timekeeping: Use sequence counter with associated raw spinlock
    
    A sequence counter write side critical section must be protected by some
    form of locking to serialize writers. A plain seqcount_t does not
    contain the information of which lock must be held when entering a write
    side critical section.
    
    Use the new seqcount_raw_spinlock_t data type, which allows to associate
    a raw spinlock with the sequence counter. This enables lockdep to verify
    that the raw spinlock used for writer serialization is held when the
    write side critical section is entered.
    
    If lockdep is disabled this lock association is compiled out and has
    neither storage size nor runtime overhead.
    
    Signed-off-by: Ahmed S. Darwish <a.darwish@linutronix.de>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Link: https://lkml.kernel.org/r/20200720155530.1173732-18-a.darwish@linutronix.de

commit 68f9b22842897087895230964776083e168415de
Author: Todd Brandt <todd.e.brandt@linux.intel.com>
Date:   Mon Jul 20 18:02:49 2020 -0700

    pm-graph v5.7 - important s2idle fixes
    
    Important fixes:
    
     - in s2idle, use timekeeping_freeze trace mark instead of
       machine_suspend to denote entry into s2idle mode.
    
     - in s2idle, use machine_suspend trace mark to create a new virtual
       device called "s2idle_enter_<n>x". It denotes an s2idle_enter call
       loop of <n> iterations where s2idle was never actually achieved.
       It isn't counted as "freeze time" in the header.
    
     - in s2idle, only show multiple freeze times if s2idle went in and
       out of resume_noirq. Otherwise multiple freezes are shown with
       "waking" time subtracted (waking time is time spent outside s2idle
       dealing with wakeups).
    
     - in s2idle summaries, include "FREEZEWAKE" as an issue when at
       least 1ms is spent waking from s2idle. A clean run should only
       wake for the rtc timer.
    
     - add support for device callbacks with matching names in the same
       phase. In rare cases some devices register multiple callbacks from
       separate drivers using the same name. Without this fix only one is
       shown.
    
     - add kparamsfmt string back to fix bootgraph
    
    General updates:
    
     - when suspend_machine is missing, error says "failed in
       suspend_machine"
    
     - extract target count/time and add to summary title if -multi
       used
    
     - include any instances of "timeout" in dmesg as issues to be
       logged.
    
     - fix ftrace parse to handle any number of flags (instead of
       just 4).
    
     - remove sync/async_device string from device detail, remains in
       hover.
    
     - when using callgraph (-f) add driver name to callgraph titles.
    
    Signed-off-by: Todd Brandt <todd.e.brandt@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit caffd39d4f15810c653fa8686aaf43c11c18d854
Author: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
Date:   Tue Mar 3 20:30:02 2020 +0900

    printk: queue wake_up_klogd irq_work only if per-CPU areas are ready
    
    commit ab6f762f0f53162d41497708b33c9a3236d3609e upstream.
    
    printk_deferred(), similarly to printk_safe/printk_nmi, does not
    immediately attempt to print a new message on the consoles, avoiding
    calls into non-reentrant kernel paths, e.g. scheduler or timekeeping,
    which potentially can deadlock the system.
    
    Those printk() flavors, instead, rely on per-CPU flush irq_work to print
    messages from safer contexts.  For same reasons (recursive scheduler or
    timekeeping calls) printk() uses per-CPU irq_work in order to wake up
    user space syslog/kmsg readers.
    
    However, only printk_safe/printk_nmi do make sure that per-CPU areas
    have been initialised and that it's safe to modify per-CPU irq_work.
    This means that, for instance, should printk_deferred() be invoked "too
    early", that is before per-CPU areas are initialised, printk_deferred()
    will perform illegal per-CPU access.
    
    Lech Perczak [0] reports that after commit 1b710b1b10ef ("char/random:
    silence a lockdep splat with printk()") user-space syslog/kmsg readers
    are not able to read new kernel messages.
    
    The reason is printk_deferred() being called too early (as was pointed
    out by Petr and John).
    
    Fix printk_deferred() and do not queue per-CPU irq_work before per-CPU
    areas are initialized.
    
    Link: https://lore.kernel.org/lkml/aa0732c6-5c4e-8a8b-a1c1-75ebe3dca05b@camlintechnologies.com/
    Reported-by: Lech Perczak <l.perczak@camlintechnologies.com>
    Signed-off-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Tested-by: Jann Horn <jannh@google.com>
    Reviewed-by: Petr Mladek <pmladek@suse.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Theodore Ts'o <tytso@mit.edu>
    Cc: John Ogness <john.ogness@linutronix.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit b81898e3d2133715e4475d25757595a3e18502ed
Author: Paul E. McKenney <paulmck@kernel.org>
Date:   Thu Apr 30 12:23:11 2020 -0700

    doc: Timer problems can cause RCU CPU stall warnings
    
    Over the past few years, there have been several cases where timekeeping
    bugs have caused RCU CPU stall warnings, particularly during hardware
    bringup.  This commit therefore adds such bugs to the list of things
    that can result in RCU CPU stall warnings.
    
    Signed-off-by: Paul E. McKenney <paulmck@kernel.org>

commit 668f532da4808688f5162cec6a38875390e1a91d
Merge: ae71d4bf0074 f097eb38f713
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Jun 28 11:59:08 2020 -0700

    Merge tag 'timers-urgent-2020-06-28' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer fix from Ingo Molnar:
     "A single DocBook fix"
    
    * tag 'timers-urgent-2020-06-28' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      timekeeping: Fix kerneldoc system_device_crosststamp & al

commit be24c6a71ecfbd9436ea1f496eb518a53e06368c
Author: Douglas Anderson <dianders@chromium.org>
Date:   Thu May 28 07:48:34 2020 -0700

    soc: qcom: rpmh-rsc: Don't use ktime for timeout in write_tcs_reg_sync()
    
    The write_tcs_reg_sync() may be called after timekeeping is suspended
    so it's not OK to use ktime.  The readl_poll_timeout_atomic() macro
    implicitly uses ktime.  This was causing a warning at suspend time.
    
    Change to just loop 1000000 times with a delay of 1 us between loops.
    This may give a timeout of more than 1 second but never less and is
    safe even if timekeeping is suspended.
    
    NOTE: I don't have any actual evidence that we need to loop here.
    It's possibly that all we really need to do is just read the value
    back to ensure that the pipes are cleaned and the looping/comparing is
    totally not needed.  I never saw the loop being needed in my tests.
    However, the loop shouldn't hurt.
    
    Reviewed-by: Stephen Boyd <sboyd@kernel.org>
    Reviewed-by: Maulik Shah <mkshah@codeaurora.org>
    Fixes: 91160150aba0 ("soc: qcom: rpmh-rsc: Timeout after 1 second in write_tcs_reg_sync()")
    Reported-by: Maulik Shah <mkshah@codeaurora.org>
    Signed-off-by: Douglas Anderson <dianders@chromium.org>
    Link: https://lore.kernel.org/r/20200528074530.1.Ib86e5b406fe7d16575ae1bb276d650faa144b63c@changeid
    Signed-off-by: Bjorn Andersson <bjorn.andersson@linaro.org>

commit 81e6737518a1e392ead4e568a4ee70bb7c371458
Author: Chen Yu <yu.c.chen@intel.com>
Date:   Tue Jun 23 14:31:31 2020 +0800

    PM: s2idle: Clear _TIF_POLLING_NRFLAG before suspend to idle
    
    Suspend to idle was found to not work on Goldmont CPU recently.
    
    The issue happens due to:
    
     1. On Goldmont the CPU in idle can only be woken up via IPIs,
        not POLLING mode, due to commit 08e237fa56a1 ("x86/cpu: Add
        workaround for MONITOR instruction erratum on Goldmont based
        CPUs")
    
     2. When the CPU is entering suspend to idle process, the
        _TIF_POLLING_NRFLAG remains on, because cpuidle_enter_s2idle()
        doesn't match call_cpuidle() exactly.
    
     3. Commit b2a02fc43a1f ("smp: Optimize send_call_function_single_ipi()")
        makes use of _TIF_POLLING_NRFLAG to avoid sending IPIs to idle
        CPUs.
    
     4. As a result, some IPIs related functions might not work
        well during suspend to idle on Goldmont. For example, one
        suspected victim:
    
        tick_unfreeze() -> timekeeping_resume() -> hrtimers_resume()
        -> clock_was_set() -> on_each_cpu() might wait forever,
        because the IPIs will not be sent to the CPUs which are
        sleeping with _TIF_POLLING_NRFLAG set, and Goldmont CPU
        could not be woken up by only setting _TIF_NEED_RESCHED
        on the monitor address.
    
    To avoid that, clear the _TIF_POLLING_NRFLAG flag before invoking
    enter_s2idle_proper() in cpuidle_enter_s2idle() in analogy with the
    call_cpuidle() code flow.
    
    Fixes: b2a02fc43a1f ("smp: Optimize send_call_function_single_ipi()")
    Suggested-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Suggested-by: Rafael J. Wysocki <rafael@kernel.org>
    Reported-by: kbuild test robot <lkp@intel.com>
    Signed-off-by: Chen Yu <yu.c.chen@intel.com>
    [ rjw: Subject / changelog ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit f097eb38f71391ff2cf078788bad5a00eb3bd96a
Author: Kurt Kanzenbach <kurt@linutronix.de>
Date:   Tue Jun 9 10:17:26 2020 +0200

    timekeeping: Fix kerneldoc system_device_crosststamp & al
    
    Make kernel doc comments actually work and fix the syncronized typo.
    
    [ tglx: Added the missing /** and fixed up formatting ]
    
    Signed-off-by: Kurt Kanzenbach <kurt@linutronix.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lkml.kernel.org/r/20200609081726.5657-1-kurt@linutronix.de

commit 6b8135e7d35add8c2497c0d2053261361b92d92d
Author: Konstantin Khlebnikov <koct9i@gmail.com>
Date:   Fri Jan 31 19:08:59 2020 +0300

    clocksource: Prevent double add_timer_on() for watchdog_timer
    
    commit febac332a819f0e764aa4da62757ba21d18c182b upstream.
    
    Kernel crashes inside QEMU/KVM are observed:
    
      kernel BUG at kernel/time/timer.c:1154!
      BUG_ON(timer_pending(timer) || !timer->function) in add_timer_on().
    
    At the same time another cpu got:
    
      general protection fault: 0000 [#1] SMP PTI of poinson pointer 0xdead000000000200 in:
    
      __hlist_del at include/linux/list.h:681
      (inlined by) detach_timer at kernel/time/timer.c:818
      (inlined by) expire_timers at kernel/time/timer.c:1355
      (inlined by) __run_timers at kernel/time/timer.c:1686
      (inlined by) run_timer_softirq at kernel/time/timer.c:1699
    
    Unfortunately kernel logs are badly scrambled, stacktraces are lost.
    
    Printing the timer->function before the BUG_ON() pointed to
    clocksource_watchdog().
    
    The execution of clocksource_watchdog() can race with a sequence of
    clocksource_stop_watchdog() .. clocksource_start_watchdog():
    
    expire_timers()
     detach_timer(timer, true);
      timer->entry.pprev = NULL;
     raw_spin_unlock_irq(&base->lock);
     call_timer_fn
      clocksource_watchdog()
    
                                            clocksource_watchdog_kthread() or
                                            clocksource_unbind()
    
                                            spin_lock_irqsave(&watchdog_lock, flags);
                                            clocksource_stop_watchdog();
                                             del_timer(&watchdog_timer);
                                             watchdog_running = 0;
                                            spin_unlock_irqrestore(&watchdog_lock, flags);
    
                                            spin_lock_irqsave(&watchdog_lock, flags);
                                            clocksource_start_watchdog();
                                             add_timer_on(&watchdog_timer, ...);
                                             watchdog_running = 1;
                                            spin_unlock_irqrestore(&watchdog_lock, flags);
    
      spin_lock(&watchdog_lock);
      add_timer_on(&watchdog_timer, ...);
       BUG_ON(timer_pending(timer) || !timer->function);
        timer_pending() -> true
        BUG()
    
    I.e. inside clocksource_watchdog() watchdog_timer could be already armed.
    
    Check timer_pending() before calling add_timer_on(). This is sufficient as
    all operations are synchronized by watchdog_lock.
    
    Fixes: 75c5158f70c0 ("timekeeping: Update clocksource with stop_machine")
    Signed-off-by: Konstantin Khlebnikov <khlebnikov@yandex-team.ru>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lore.kernel.org/r/158048693917.4378.13823603769948933793.stgit@buzz
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit 3e295cf681d34198632578bd62a2538817264714
Author: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
Date:   Tue Mar 3 20:30:02 2020 +0900

    printk: queue wake_up_klogd irq_work only if per-CPU areas are ready
    
    commit ab6f762f0f53162d41497708b33c9a3236d3609e upstream.
    
    printk_deferred(), similarly to printk_safe/printk_nmi, does not
    immediately attempt to print a new message on the consoles, avoiding
    calls into non-reentrant kernel paths, e.g. scheduler or timekeeping,
    which potentially can deadlock the system.
    
    Those printk() flavors, instead, rely on per-CPU flush irq_work to print
    messages from safer contexts.  For same reasons (recursive scheduler or
    timekeeping calls) printk() uses per-CPU irq_work in order to wake up
    user space syslog/kmsg readers.
    
    However, only printk_safe/printk_nmi do make sure that per-CPU areas
    have been initialised and that it's safe to modify per-CPU irq_work.
    This means that, for instance, should printk_deferred() be invoked "too
    early", that is before per-CPU areas are initialised, printk_deferred()
    will perform illegal per-CPU access.
    
    Lech Perczak [0] reports that after commit 1b710b1b10ef ("char/random:
    silence a lockdep splat with printk()") user-space syslog/kmsg readers
    are not able to read new kernel messages.
    
    The reason is printk_deferred() being called too early (as was pointed
    out by Petr and John).
    
    Fix printk_deferred() and do not queue per-CPU irq_work before per-CPU
    areas are initialized.
    
    Link: https://lore.kernel.org/lkml/aa0732c6-5c4e-8a8b-a1c1-75ebe3dca05b@camlintechnologies.com/
    Reported-by: Lech Perczak <l.perczak@camlintechnologies.com>
    Signed-off-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Tested-by: Jann Horn <jannh@google.com>
    Reviewed-by: Petr Mladek <pmladek@suse.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Theodore Ts'o <tytso@mit.edu>
    Cc: John Ogness <john.ogness@linutronix.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 4a5c9ae67b12f628fdc8f9ffac7e5677d510dd5e
Author: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
Date:   Tue Mar 3 20:30:02 2020 +0900

    printk: queue wake_up_klogd irq_work only if per-CPU areas are ready
    
    commit ab6f762f0f53162d41497708b33c9a3236d3609e upstream.
    
    printk_deferred(), similarly to printk_safe/printk_nmi, does not
    immediately attempt to print a new message on the consoles, avoiding
    calls into non-reentrant kernel paths, e.g. scheduler or timekeeping,
    which potentially can deadlock the system.
    
    Those printk() flavors, instead, rely on per-CPU flush irq_work to print
    messages from safer contexts.  For same reasons (recursive scheduler or
    timekeeping calls) printk() uses per-CPU irq_work in order to wake up
    user space syslog/kmsg readers.
    
    However, only printk_safe/printk_nmi do make sure that per-CPU areas
    have been initialised and that it's safe to modify per-CPU irq_work.
    This means that, for instance, should printk_deferred() be invoked "too
    early", that is before per-CPU areas are initialised, printk_deferred()
    will perform illegal per-CPU access.
    
    Lech Perczak [0] reports that after commit 1b710b1b10ef ("char/random:
    silence a lockdep splat with printk()") user-space syslog/kmsg readers
    are not able to read new kernel messages.
    
    The reason is printk_deferred() being called too early (as was pointed
    out by Petr and John).
    
    Fix printk_deferred() and do not queue per-CPU irq_work before per-CPU
    areas are initialized.
    
    Link: https://lore.kernel.org/lkml/aa0732c6-5c4e-8a8b-a1c1-75ebe3dca05b@camlintechnologies.com/
    Reported-by: Lech Perczak <l.perczak@camlintechnologies.com>
    Signed-off-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Tested-by: Jann Horn <jannh@google.com>
    Reviewed-by: Petr Mladek <pmladek@suse.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Theodore Ts'o <tytso@mit.edu>
    Cc: John Ogness <john.ogness@linutronix.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 082b57e3eb09810d357083cca5ee2df02c16aec9
Author: Maciej Żenczykowski <maze@google.com>
Date:   Mon Apr 20 11:47:50 2020 -0700

    net: bpf: Make bpf_ktime_get_ns() available to non GPL programs
    
    The entire implementation is in kernel/bpf/helpers.c:
    
    BPF_CALL_0(bpf_ktime_get_ns) {
           /* NMI safe access to clock monotonic */
           return ktime_get_mono_fast_ns();
    }
    
    const struct bpf_func_proto bpf_ktime_get_ns_proto = {
           .func           = bpf_ktime_get_ns,
           .gpl_only       = false,
           .ret_type       = RET_INTEGER,
    };
    
    and this was presumably marked GPL due to kernel/time/timekeeping.c:
      EXPORT_SYMBOL_GPL(ktime_get_mono_fast_ns);
    
    and while that may make sense for kernel modules (although even that
    is doubtful), there is currently AFAICT no other source of time
    available to ebpf.
    
    Furthermore this is really just equivalent to clock_gettime(CLOCK_MONOTONIC)
    which is exposed to userspace (via vdso even to make it performant)...
    
    As such, I see no reason to keep the GPL restriction.
    (In the future I'd like to have access to time from Apache licensed ebpf code)
    
    Signed-off-by: Maciej Żenczykowski <maze@google.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>

commit 90280eaa88ac1a9140dc759941123530d5545bb6
Merge: 5d286d5ebcf6 d98dbbe0d331
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Apr 17 13:10:50 2020 -0700

    Merge tag 'docs-fixes' of git://git.lwn.net/linux
    
    Pull documentation fixes from Jonathan Corbet:
     "A handful of fixes for reasonably obnoxious documentation issues"
    
    * tag 'docs-fixes' of git://git.lwn.net/linux:
      scripts: documentation-file-ref-check: Add line break before exit
      scripts/kernel-doc: Add missing close-paren in c:function directives
      docs: admin-guide: merge sections for the kernel.modprobe sysctl
      docs: timekeeping: Use correct prototype for deprecated functions

commit 404e603f1ec8520ca09b606496a55cfdcead4e15
Author: Chris Packham <chris.packham@alliedtelesis.co.nz>
Date:   Wed Apr 15 10:12:22 2020 +1200

    docs: timekeeping: Use correct prototype for deprecated functions
    
    Use the correct prototypes for do_gettimeofday(), getnstimeofday() and
    getnstimeofday64(). All of these returned void and passed the return
    value by reference. This should make the documentation of their
    deprecation and replacements easier to search for.
    
    Signed-off-by: Chris Packham <chris.packham@alliedtelesis.co.nz>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Link: https://lore.kernel.org/r/20200414221222.23996-1-chris.packham@alliedtelesis.co.nz
    Signed-off-by: Jonathan Corbet <corbet@lwn.net>

commit ab6f762f0f53162d41497708b33c9a3236d3609e
Author: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
Date:   Tue Mar 3 20:30:02 2020 +0900

    printk: queue wake_up_klogd irq_work only if per-CPU areas are ready
    
    printk_deferred(), similarly to printk_safe/printk_nmi, does not
    immediately attempt to print a new message on the consoles, avoiding
    calls into non-reentrant kernel paths, e.g. scheduler or timekeeping,
    which potentially can deadlock the system.
    
    Those printk() flavors, instead, rely on per-CPU flush irq_work to print
    messages from safer contexts.  For same reasons (recursive scheduler or
    timekeeping calls) printk() uses per-CPU irq_work in order to wake up
    user space syslog/kmsg readers.
    
    However, only printk_safe/printk_nmi do make sure that per-CPU areas
    have been initialised and that it's safe to modify per-CPU irq_work.
    This means that, for instance, should printk_deferred() be invoked "too
    early", that is before per-CPU areas are initialised, printk_deferred()
    will perform illegal per-CPU access.
    
    Lech Perczak [0] reports that after commit 1b710b1b10ef ("char/random:
    silence a lockdep splat with printk()") user-space syslog/kmsg readers
    are not able to read new kernel messages.
    
    The reason is printk_deferred() being called too early (as was pointed
    out by Petr and John).
    
    Fix printk_deferred() and do not queue per-CPU irq_work before per-CPU
    areas are initialized.
    
    Link: https://lore.kernel.org/lkml/aa0732c6-5c4e-8a8b-a1c1-75ebe3dca05b@camlintechnologies.com/
    Reported-by: Lech Perczak <l.perczak@camlintechnologies.com>
    Signed-off-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Tested-by: Jann Horn <jannh@google.com>
    Reviewed-by: Petr Mladek <pmladek@suse.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Theodore Ts'o <tytso@mit.edu>
    Cc: John Ogness <john.ogness@linutronix.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit dbb381b619aa5242c9cb1a8fd54d71c4d79c91eb
Merge: 336622e9fce7 4479730e9263
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Mar 30 18:51:47 2020 -0700

    Merge tag 'timers-core-2020-03-30' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timekeeping and timer updates from Thomas Gleixner:
     "Core:
    
       - Consolidation of the vDSO build infrastructure to address the
         difficulties of cross-builds for ARM64 compat vDSO libraries by
         restricting the exposure of header content to the vDSO build.
    
         This is achieved by splitting out header content into separate
         headers. which contain only the minimaly required information which
         is necessary to build the vDSO. These new headers are included from
         the kernel headers and the vDSO specific files.
    
       - Enhancements to the generic vDSO library allowing more fine grained
         control over the compiled in code, further reducing architecture
         specific storage and preparing for adopting the generic library by
         PPC.
    
       - Cleanup and consolidation of the exit related code in posix CPU
         timers.
    
       - Small cleanups and enhancements here and there
    
      Drivers:
    
       - The obligatory new drivers: Ingenic JZ47xx and X1000 TCU support
    
       - Correct the clock rate of PIT64b global clock
    
       - setup_irq() cleanup
    
       - Preparation for PWM and suspend support for the TI DM timer
    
       - Expand the fttmr010 driver to support ast2600 systems
    
       - The usual small fixes, enhancements and cleanups all over the
         place"
    
    * tag 'timers-core-2020-03-30' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (80 commits)
      Revert "clocksource/drivers/timer-probe: Avoid creating dead devices"
      vdso: Fix clocksource.h macro detection
      um: Fix header inclusion
      arm64: vdso32: Enable Clang Compilation
      lib/vdso: Enable common headers
      arm: vdso: Enable arm to use common headers
      x86/vdso: Enable x86 to use common headers
      mips: vdso: Enable mips to use common headers
      arm64: vdso32: Include common headers in the vdso library
      arm64: vdso: Include common headers in the vdso library
      arm64: Introduce asm/vdso/processor.h
      arm64: vdso32: Code clean up
      linux/elfnote.h: Replace elf.h with UAPI equivalent
      scripts: Fix the inclusion order in modpost
      common: Introduce processor.h
      linux/ktime.h: Extract common header for vDSO
      linux/jiffies.h: Extract common header for vDSO
      linux/time64.h: Extract common header for vDSO
      linux/time32.h: Extract common header for vDSO
      linux/time.h: Extract common header for vDSO
      ...

commit f185063bff914e589b50f1b711fc42218c4790c6
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Thu Feb 13 14:26:44 2020 +0100

    um: Move timer-internal.h to non-shared
    
    This file isn't really shared, it's only used on the kernel side,
    not on the user side. Remove the include from the user-side and
    move the file to a better place.
    
    While at it, rename it to time-internal.h, it's not really just
    timers but all kinds of things related to timekeeping.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: Richard Weinberger <richard@nod.at>

commit e5d4d1756b07d9490a0269a9e68c1e05ee1feb9b
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Mar 21 12:25:58 2020 +0100

    timekeeping: Split jiffies seqlock
    
    seqlock consists of a sequence counter and a spinlock_t which is used to
    serialize the writers. spinlock_t is substituted by a "sleeping" spinlock
    on PREEMPT_RT enabled kernels which breaks the usage in the timekeeping
    code as the writers are executed in hard interrupt and therefore
    non-preemptible context even on PREEMPT_RT.
    
    The spinlock in seqlock cannot be unconditionally replaced by a
    raw_spinlock_t as many seqlock users have nesting spinlock sections or
    other code which is not suitable to run in truly atomic context on RT.
    
    Instead of providing a raw_seqlock API for a single use case, open code the
    seqlock for the jiffies use case and implement it with a raw_spinlock_t and
    a sequence counter.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Link: https://lkml.kernel.org/r/20200321113242.120587764@linutronix.de

commit 05f4a6e5a615841f7cf87ae969cbc6ec499bb2b3
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jan 14 19:52:39 2020 +0100

    lib/vdso: Update coarse timekeeper unconditionally
    
    commit 9f24c540f7f8eb3a981528da9a9a636a5bdf5987 upstream.
    
    The low resolution parts of the VDSO, i.e.:
    
      clock_gettime(CLOCK_*_COARSE), clock_getres(), time()
    
    can be used even if there is no VDSO capable clocksource.
    
    But if an architecture opts out of the VDSO data update then this
    information becomes stale. This affects ARM when there is no architected
    timer available. The lack of update causes userspace to use stale data
    forever.
    
    Make the update of the low resolution parts unconditional and only skip
    the update of the high resolution parts if the architecture requests it.
    
    Fixes: 44f57d788e7d ("timekeeping: Provide a generic update_vsyscall() implementation")
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lore.kernel.org/r/20200114185946.765577901@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 993cc7831665fc732a6394d4ad84f093b16a2c6e
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jan 14 19:52:38 2020 +0100

    lib/vdso: Make __arch_update_vdso_data() logic understandable
    
    commit 9a6b55ac4a44060bcb782baf002859b2a2c63267 upstream.
    
    The function name suggests that this is a boolean checking whether the
    architecture asks for an update of the VDSO data, but it works the other
    way round. To spare further confusion invert the logic.
    
    Fixes: 44f57d788e7d ("timekeeping: Provide a generic update_vsyscall() implementation")
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lore.kernel.org/r/20200114185946.656652824@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 1fabae5c846f2c14f98f7e96228caa0e871cf922
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jan 14 19:52:39 2020 +0100

    lib/vdso: Update coarse timekeeper unconditionally
    
    commit 9f24c540f7f8eb3a981528da9a9a636a5bdf5987 upstream.
    
    The low resolution parts of the VDSO, i.e.:
    
      clock_gettime(CLOCK_*_COARSE), clock_getres(), time()
    
    can be used even if there is no VDSO capable clocksource.
    
    But if an architecture opts out of the VDSO data update then this
    information becomes stale. This affects ARM when there is no architected
    timer available. The lack of update causes userspace to use stale data
    forever.
    
    Make the update of the low resolution parts unconditional and only skip
    the update of the high resolution parts if the architecture requests it.
    
    Fixes: 44f57d788e7d ("timekeeping: Provide a generic update_vsyscall() implementation")
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lore.kernel.org/r/20200114185946.765577901@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 91ebef8618bf14eb335c58f4331c1c205e1ed424
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jan 14 19:52:38 2020 +0100

    lib/vdso: Make __arch_update_vdso_data() logic understandable
    
    commit 9a6b55ac4a44060bcb782baf002859b2a2c63267 upstream.
    
    The function name suggests that this is a boolean checking whether the
    architecture asks for an update of the VDSO data, but it works the other
    way round. To spare further confusion invert the logic.
    
    Fixes: 44f57d788e7d ("timekeeping: Provide a generic update_vsyscall() implementation")
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lore.kernel.org/r/20200114185946.656652824@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 4cbbc3a0eeed675449b1a4d080008927121f3da3
Author: Wen Yang <wenyang@linux.alibaba.com>
Date:   Mon Jan 20 18:05:23 2020 +0800

    timekeeping: Prevent 32bit truncation in scale64_check_overflow()
    
    While unlikely the divisor in scale64_check_overflow() could be >= 32bit in
    scale64_check_overflow(). do_div() truncates the divisor to 32bit at least
    on 32bit platforms.
    
    Use div64_u64() instead to avoid the truncation to 32-bit.
    
    [ tglx: Massaged changelog ]
    
    Signed-off-by: Wen Yang <wenyang@linux.alibaba.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lkml.kernel.org/r/20200120100523.45656-1-wenyang@linux.alibaba.com

commit 44024adb4aabefd275c6f9c00cac323473447dd5
Merge: b982df72ef84 120881b9e888
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Feb 16 13:01:42 2020 -0800

    Merge tag 'for-linus' of git://git.kernel.org/pub/scm/virt/kvm/kvm
    
    Pull KVM fixes from Paolo Bonzini:
     "Bugfixes and improvements to selftests.
    
      On top of this, Mauro converted the KVM documentation to rst format,
      which was very welcome"
    
    * tag 'for-linus' of git://git.kernel.org/pub/scm/virt/kvm/kvm: (44 commits)
      docs: virt: guest-halt-polling.txt convert to ReST
      docs: kvm: review-checklist.txt: rename to ReST
      docs: kvm: Convert timekeeping.txt to ReST format
      docs: kvm: Convert s390-diag.txt to ReST format
      docs: kvm: Convert ppc-pv.txt to ReST format
      docs: kvm: Convert nested-vmx.txt to ReST format
      docs: kvm: Convert mmu.txt to ReST format
      docs: kvm: Convert locking.txt to ReST format
      docs: kvm: Convert hypercalls.txt to ReST format
      docs: kvm: arm/psci.txt: convert to ReST
      docs: kvm: convert arm/hyp-abi.txt to ReST
      docs: kvm: Convert api.txt to ReST format
      docs: kvm: convert devices/xive.txt to ReST
      docs: kvm: convert devices/xics.txt to ReST
      docs: kvm: convert devices/vm.txt to ReST
      docs: kvm: convert devices/vfio.txt to ReST
      docs: kvm: convert devices/vcpu.txt to ReST
      docs: kvm: convert devices/s390_flic.txt to ReST
      docs: kvm: convert devices/mpic.txt to ReST
      docs: kvm: convert devices/arm-vgit.txt to ReST
      ...

commit 2106d26897f9341ddb7ad74bfc5867808cec927a
Author: Konstantin Khlebnikov <koct9i@gmail.com>
Date:   Fri Jan 31 19:08:59 2020 +0300

    clocksource: Prevent double add_timer_on() for watchdog_timer
    
    commit febac332a819f0e764aa4da62757ba21d18c182b upstream.
    
    Kernel crashes inside QEMU/KVM are observed:
    
      kernel BUG at kernel/time/timer.c:1154!
      BUG_ON(timer_pending(timer) || !timer->function) in add_timer_on().
    
    At the same time another cpu got:
    
      general protection fault: 0000 [#1] SMP PTI of poinson pointer 0xdead000000000200 in:
    
      __hlist_del at include/linux/list.h:681
      (inlined by) detach_timer at kernel/time/timer.c:818
      (inlined by) expire_timers at kernel/time/timer.c:1355
      (inlined by) __run_timers at kernel/time/timer.c:1686
      (inlined by) run_timer_softirq at kernel/time/timer.c:1699
    
    Unfortunately kernel logs are badly scrambled, stacktraces are lost.
    
    Printing the timer->function before the BUG_ON() pointed to
    clocksource_watchdog().
    
    The execution of clocksource_watchdog() can race with a sequence of
    clocksource_stop_watchdog() .. clocksource_start_watchdog():
    
    expire_timers()
     detach_timer(timer, true);
      timer->entry.pprev = NULL;
     raw_spin_unlock_irq(&base->lock);
     call_timer_fn
      clocksource_watchdog()
    
                                            clocksource_watchdog_kthread() or
                                            clocksource_unbind()
    
                                            spin_lock_irqsave(&watchdog_lock, flags);
                                            clocksource_stop_watchdog();
                                             del_timer(&watchdog_timer);
                                             watchdog_running = 0;
                                            spin_unlock_irqrestore(&watchdog_lock, flags);
    
                                            spin_lock_irqsave(&watchdog_lock, flags);
                                            clocksource_start_watchdog();
                                             add_timer_on(&watchdog_timer, ...);
                                             watchdog_running = 1;
                                            spin_unlock_irqrestore(&watchdog_lock, flags);
    
      spin_lock(&watchdog_lock);
      add_timer_on(&watchdog_timer, ...);
       BUG_ON(timer_pending(timer) || !timer->function);
        timer_pending() -> true
        BUG()
    
    I.e. inside clocksource_watchdog() watchdog_timer could be already armed.
    
    Check timer_pending() before calling add_timer_on(). This is sufficient as
    all operations are synchronized by watchdog_lock.
    
    Fixes: 75c5158f70c0 ("timekeeping: Update clocksource with stop_machine")
    Signed-off-by: Konstantin Khlebnikov <khlebnikov@yandex-team.ru>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/158048693917.4378.13823603769948933793.stgit@buzz
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 75fc4654a244504683f322ccbeff293f8578a3a3
Author: Konstantin Khlebnikov <koct9i@gmail.com>
Date:   Fri Jan 31 19:08:59 2020 +0300

    clocksource: Prevent double add_timer_on() for watchdog_timer
    
    commit febac332a819f0e764aa4da62757ba21d18c182b upstream.
    
    Kernel crashes inside QEMU/KVM are observed:
    
      kernel BUG at kernel/time/timer.c:1154!
      BUG_ON(timer_pending(timer) || !timer->function) in add_timer_on().
    
    At the same time another cpu got:
    
      general protection fault: 0000 [#1] SMP PTI of poinson pointer 0xdead000000000200 in:
    
      __hlist_del at include/linux/list.h:681
      (inlined by) detach_timer at kernel/time/timer.c:818
      (inlined by) expire_timers at kernel/time/timer.c:1355
      (inlined by) __run_timers at kernel/time/timer.c:1686
      (inlined by) run_timer_softirq at kernel/time/timer.c:1699
    
    Unfortunately kernel logs are badly scrambled, stacktraces are lost.
    
    Printing the timer->function before the BUG_ON() pointed to
    clocksource_watchdog().
    
    The execution of clocksource_watchdog() can race with a sequence of
    clocksource_stop_watchdog() .. clocksource_start_watchdog():
    
    expire_timers()
     detach_timer(timer, true);
      timer->entry.pprev = NULL;
     raw_spin_unlock_irq(&base->lock);
     call_timer_fn
      clocksource_watchdog()
    
                                            clocksource_watchdog_kthread() or
                                            clocksource_unbind()
    
                                            spin_lock_irqsave(&watchdog_lock, flags);
                                            clocksource_stop_watchdog();
                                             del_timer(&watchdog_timer);
                                             watchdog_running = 0;
                                            spin_unlock_irqrestore(&watchdog_lock, flags);
    
                                            spin_lock_irqsave(&watchdog_lock, flags);
                                            clocksource_start_watchdog();
                                             add_timer_on(&watchdog_timer, ...);
                                             watchdog_running = 1;
                                            spin_unlock_irqrestore(&watchdog_lock, flags);
    
      spin_lock(&watchdog_lock);
      add_timer_on(&watchdog_timer, ...);
       BUG_ON(timer_pending(timer) || !timer->function);
        timer_pending() -> true
        BUG()
    
    I.e. inside clocksource_watchdog() watchdog_timer could be already armed.
    
    Check timer_pending() before calling add_timer_on(). This is sufficient as
    all operations are synchronized by watchdog_lock.
    
    Fixes: 75c5158f70c0 ("timekeeping: Update clocksource with stop_machine")
    Signed-off-by: Konstantin Khlebnikov <khlebnikov@yandex-team.ru>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/158048693917.4378.13823603769948933793.stgit@buzz
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit d663366beefb8fa80e168af11820e1fd73532623
Author: Konstantin Khlebnikov <koct9i@gmail.com>
Date:   Fri Jan 31 19:08:59 2020 +0300

    clocksource: Prevent double add_timer_on() for watchdog_timer
    
    commit febac332a819f0e764aa4da62757ba21d18c182b upstream.
    
    Kernel crashes inside QEMU/KVM are observed:
    
      kernel BUG at kernel/time/timer.c:1154!
      BUG_ON(timer_pending(timer) || !timer->function) in add_timer_on().
    
    At the same time another cpu got:
    
      general protection fault: 0000 [#1] SMP PTI of poinson pointer 0xdead000000000200 in:
    
      __hlist_del at include/linux/list.h:681
      (inlined by) detach_timer at kernel/time/timer.c:818
      (inlined by) expire_timers at kernel/time/timer.c:1355
      (inlined by) __run_timers at kernel/time/timer.c:1686
      (inlined by) run_timer_softirq at kernel/time/timer.c:1699
    
    Unfortunately kernel logs are badly scrambled, stacktraces are lost.
    
    Printing the timer->function before the BUG_ON() pointed to
    clocksource_watchdog().
    
    The execution of clocksource_watchdog() can race with a sequence of
    clocksource_stop_watchdog() .. clocksource_start_watchdog():
    
    expire_timers()
     detach_timer(timer, true);
      timer->entry.pprev = NULL;
     raw_spin_unlock_irq(&base->lock);
     call_timer_fn
      clocksource_watchdog()
    
                                            clocksource_watchdog_kthread() or
                                            clocksource_unbind()
    
                                            spin_lock_irqsave(&watchdog_lock, flags);
                                            clocksource_stop_watchdog();
                                             del_timer(&watchdog_timer);
                                             watchdog_running = 0;
                                            spin_unlock_irqrestore(&watchdog_lock, flags);
    
                                            spin_lock_irqsave(&watchdog_lock, flags);
                                            clocksource_start_watchdog();
                                             add_timer_on(&watchdog_timer, ...);
                                             watchdog_running = 1;
                                            spin_unlock_irqrestore(&watchdog_lock, flags);
    
      spin_lock(&watchdog_lock);
      add_timer_on(&watchdog_timer, ...);
       BUG_ON(timer_pending(timer) || !timer->function);
        timer_pending() -> true
        BUG()
    
    I.e. inside clocksource_watchdog() watchdog_timer could be already armed.
    
    Check timer_pending() before calling add_timer_on(). This is sufficient as
    all operations are synchronized by watchdog_lock.
    
    Fixes: 75c5158f70c0 ("timekeeping: Update clocksource with stop_machine")
    Signed-off-by: Konstantin Khlebnikov <khlebnikov@yandex-team.ru>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/158048693917.4378.13823603769948933793.stgit@buzz
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 6012d9a9fa693e608f4de3c5a13741794dc4b2c7
Author: Mauro Carvalho Chehab <mchehab+huawei@kernel.org>
Date:   Mon Feb 10 07:03:04 2020 +0100

    docs: kvm: Convert timekeeping.txt to ReST format
    
    - Use document title and chapter markups;
    - Add markups for literal blocks;
    - Add markups for tables;
    - use :field: for field descriptions;
    - Add blank lines and adjust indentation.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab+huawei@kernel.org>
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>

commit 5afe1951d0391c71051d74e1030319dc87ce237d
Author: Konstantin Khlebnikov <koct9i@gmail.com>
Date:   Fri Jan 31 19:08:59 2020 +0300

    clocksource: Prevent double add_timer_on() for watchdog_timer
    
    commit febac332a819f0e764aa4da62757ba21d18c182b upstream.
    
    Kernel crashes inside QEMU/KVM are observed:
    
      kernel BUG at kernel/time/timer.c:1154!
      BUG_ON(timer_pending(timer) || !timer->function) in add_timer_on().
    
    At the same time another cpu got:
    
      general protection fault: 0000 [#1] SMP PTI of poinson pointer 0xdead000000000200 in:
    
      __hlist_del at include/linux/list.h:681
      (inlined by) detach_timer at kernel/time/timer.c:818
      (inlined by) expire_timers at kernel/time/timer.c:1355
      (inlined by) __run_timers at kernel/time/timer.c:1686
      (inlined by) run_timer_softirq at kernel/time/timer.c:1699
    
    Unfortunately kernel logs are badly scrambled, stacktraces are lost.
    
    Printing the timer->function before the BUG_ON() pointed to
    clocksource_watchdog().
    
    The execution of clocksource_watchdog() can race with a sequence of
    clocksource_stop_watchdog() .. clocksource_start_watchdog():
    
    expire_timers()
     detach_timer(timer, true);
      timer->entry.pprev = NULL;
     raw_spin_unlock_irq(&base->lock);
     call_timer_fn
      clocksource_watchdog()
    
                                            clocksource_watchdog_kthread() or
                                            clocksource_unbind()
    
                                            spin_lock_irqsave(&watchdog_lock, flags);
                                            clocksource_stop_watchdog();
                                             del_timer(&watchdog_timer);
                                             watchdog_running = 0;
                                            spin_unlock_irqrestore(&watchdog_lock, flags);
    
                                            spin_lock_irqsave(&watchdog_lock, flags);
                                            clocksource_start_watchdog();
                                             add_timer_on(&watchdog_timer, ...);
                                             watchdog_running = 1;
                                            spin_unlock_irqrestore(&watchdog_lock, flags);
    
      spin_lock(&watchdog_lock);
      add_timer_on(&watchdog_timer, ...);
       BUG_ON(timer_pending(timer) || !timer->function);
        timer_pending() -> true
        BUG()
    
    I.e. inside clocksource_watchdog() watchdog_timer could be already armed.
    
    Check timer_pending() before calling add_timer_on(). This is sufficient as
    all operations are synchronized by watchdog_lock.
    
    Fixes: 75c5158f70c0 ("timekeeping: Update clocksource with stop_machine")
    Signed-off-by: Konstantin Khlebnikov <khlebnikov@yandex-team.ru>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/158048693917.4378.13823603769948933793.stgit@buzz
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit d1318034e9e90180ed233b609b249c316205d056
Author: Konstantin Khlebnikov <koct9i@gmail.com>
Date:   Fri Jan 31 19:08:59 2020 +0300

    clocksource: Prevent double add_timer_on() for watchdog_timer
    
    commit febac332a819f0e764aa4da62757ba21d18c182b upstream.
    
    Kernel crashes inside QEMU/KVM are observed:
    
      kernel BUG at kernel/time/timer.c:1154!
      BUG_ON(timer_pending(timer) || !timer->function) in add_timer_on().
    
    At the same time another cpu got:
    
      general protection fault: 0000 [#1] SMP PTI of poinson pointer 0xdead000000000200 in:
    
      __hlist_del at include/linux/list.h:681
      (inlined by) detach_timer at kernel/time/timer.c:818
      (inlined by) expire_timers at kernel/time/timer.c:1355
      (inlined by) __run_timers at kernel/time/timer.c:1686
      (inlined by) run_timer_softirq at kernel/time/timer.c:1699
    
    Unfortunately kernel logs are badly scrambled, stacktraces are lost.
    
    Printing the timer->function before the BUG_ON() pointed to
    clocksource_watchdog().
    
    The execution of clocksource_watchdog() can race with a sequence of
    clocksource_stop_watchdog() .. clocksource_start_watchdog():
    
    expire_timers()
     detach_timer(timer, true);
      timer->entry.pprev = NULL;
     raw_spin_unlock_irq(&base->lock);
     call_timer_fn
      clocksource_watchdog()
    
                                            clocksource_watchdog_kthread() or
                                            clocksource_unbind()
    
                                            spin_lock_irqsave(&watchdog_lock, flags);
                                            clocksource_stop_watchdog();
                                             del_timer(&watchdog_timer);
                                             watchdog_running = 0;
                                            spin_unlock_irqrestore(&watchdog_lock, flags);
    
                                            spin_lock_irqsave(&watchdog_lock, flags);
                                            clocksource_start_watchdog();
                                             add_timer_on(&watchdog_timer, ...);
                                             watchdog_running = 1;
                                            spin_unlock_irqrestore(&watchdog_lock, flags);
    
      spin_lock(&watchdog_lock);
      add_timer_on(&watchdog_timer, ...);
       BUG_ON(timer_pending(timer) || !timer->function);
        timer_pending() -> true
        BUG()
    
    I.e. inside clocksource_watchdog() watchdog_timer could be already armed.
    
    Check timer_pending() before calling add_timer_on(). This is sufficient as
    all operations are synchronized by watchdog_lock.
    
    Fixes: 75c5158f70c0 ("timekeeping: Update clocksource with stop_machine")
    Signed-off-by: Konstantin Khlebnikov <khlebnikov@yandex-team.ru>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/158048693917.4378.13823603769948933793.stgit@buzz
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 6284d30e96ede11d9d434eebfacbe4b4625b6c87
Author: Konstantin Khlebnikov <koct9i@gmail.com>
Date:   Fri Jan 31 19:08:59 2020 +0300

    clocksource: Prevent double add_timer_on() for watchdog_timer
    
    commit febac332a819f0e764aa4da62757ba21d18c182b upstream.
    
    Kernel crashes inside QEMU/KVM are observed:
    
      kernel BUG at kernel/time/timer.c:1154!
      BUG_ON(timer_pending(timer) || !timer->function) in add_timer_on().
    
    At the same time another cpu got:
    
      general protection fault: 0000 [#1] SMP PTI of poinson pointer 0xdead000000000200 in:
    
      __hlist_del at include/linux/list.h:681
      (inlined by) detach_timer at kernel/time/timer.c:818
      (inlined by) expire_timers at kernel/time/timer.c:1355
      (inlined by) __run_timers at kernel/time/timer.c:1686
      (inlined by) run_timer_softirq at kernel/time/timer.c:1699
    
    Unfortunately kernel logs are badly scrambled, stacktraces are lost.
    
    Printing the timer->function before the BUG_ON() pointed to
    clocksource_watchdog().
    
    The execution of clocksource_watchdog() can race with a sequence of
    clocksource_stop_watchdog() .. clocksource_start_watchdog():
    
    expire_timers()
     detach_timer(timer, true);
      timer->entry.pprev = NULL;
     raw_spin_unlock_irq(&base->lock);
     call_timer_fn
      clocksource_watchdog()
    
                                            clocksource_watchdog_kthread() or
                                            clocksource_unbind()
    
                                            spin_lock_irqsave(&watchdog_lock, flags);
                                            clocksource_stop_watchdog();
                                             del_timer(&watchdog_timer);
                                             watchdog_running = 0;
                                            spin_unlock_irqrestore(&watchdog_lock, flags);
    
                                            spin_lock_irqsave(&watchdog_lock, flags);
                                            clocksource_start_watchdog();
                                             add_timer_on(&watchdog_timer, ...);
                                             watchdog_running = 1;
                                            spin_unlock_irqrestore(&watchdog_lock, flags);
    
      spin_lock(&watchdog_lock);
      add_timer_on(&watchdog_timer, ...);
       BUG_ON(timer_pending(timer) || !timer->function);
        timer_pending() -> true
        BUG()
    
    I.e. inside clocksource_watchdog() watchdog_timer could be already armed.
    
    Check timer_pending() before calling add_timer_on(). This is sufficient as
    all operations are synchronized by watchdog_lock.
    
    Fixes: 75c5158f70c0 ("timekeeping: Update clocksource with stop_machine")
    Signed-off-by: Konstantin Khlebnikov <khlebnikov@yandex-team.ru>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/158048693917.4378.13823603769948933793.stgit@buzz
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit febac332a819f0e764aa4da62757ba21d18c182b
Author: Konstantin Khlebnikov <koct9i@gmail.com>
Date:   Fri Jan 31 19:08:59 2020 +0300

    clocksource: Prevent double add_timer_on() for watchdog_timer
    
    Kernel crashes inside QEMU/KVM are observed:
    
      kernel BUG at kernel/time/timer.c:1154!
      BUG_ON(timer_pending(timer) || !timer->function) in add_timer_on().
    
    At the same time another cpu got:
    
      general protection fault: 0000 [#1] SMP PTI of poinson pointer 0xdead000000000200 in:
    
      __hlist_del at include/linux/list.h:681
      (inlined by) detach_timer at kernel/time/timer.c:818
      (inlined by) expire_timers at kernel/time/timer.c:1355
      (inlined by) __run_timers at kernel/time/timer.c:1686
      (inlined by) run_timer_softirq at kernel/time/timer.c:1699
    
    Unfortunately kernel logs are badly scrambled, stacktraces are lost.
    
    Printing the timer->function before the BUG_ON() pointed to
    clocksource_watchdog().
    
    The execution of clocksource_watchdog() can race with a sequence of
    clocksource_stop_watchdog() .. clocksource_start_watchdog():
    
    expire_timers()
     detach_timer(timer, true);
      timer->entry.pprev = NULL;
     raw_spin_unlock_irq(&base->lock);
     call_timer_fn
      clocksource_watchdog()
    
                                            clocksource_watchdog_kthread() or
                                            clocksource_unbind()
    
                                            spin_lock_irqsave(&watchdog_lock, flags);
                                            clocksource_stop_watchdog();
                                             del_timer(&watchdog_timer);
                                             watchdog_running = 0;
                                            spin_unlock_irqrestore(&watchdog_lock, flags);
    
                                            spin_lock_irqsave(&watchdog_lock, flags);
                                            clocksource_start_watchdog();
                                             add_timer_on(&watchdog_timer, ...);
                                             watchdog_running = 1;
                                            spin_unlock_irqrestore(&watchdog_lock, flags);
    
      spin_lock(&watchdog_lock);
      add_timer_on(&watchdog_timer, ...);
       BUG_ON(timer_pending(timer) || !timer->function);
        timer_pending() -> true
        BUG()
    
    I.e. inside clocksource_watchdog() watchdog_timer could be already armed.
    
    Check timer_pending() before calling add_timer_on(). This is sufficient as
    all operations are synchronized by watchdog_lock.
    
    Fixes: 75c5158f70c0 ("timekeeping: Update clocksource with stop_machine")
    Signed-off-by: Konstantin Khlebnikov <khlebnikov@yandex-team.ru>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/158048693917.4378.13823603769948933793.stgit@buzz

commit e279160f491392f1345f6eb4b0eeec5a6a2ecdd7
Merge: 534b0a8b6774 fd928f3e32ba
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jan 27 16:47:05 2020 -0800

    Merge tag 'timers-core-2020-01-27' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer updates from Thomas Gleixner:
     "The timekeeping and timers departement provides:
    
       - Time namespace support:
    
         If a container migrates from one host to another then it expects
         that clocks based on MONOTONIC and BOOTTIME are not subject to
         disruption. Due to different boot time and non-suspended runtime
         these clocks can differ significantly on two hosts, in the worst
         case time goes backwards which is a violation of the POSIX
         requirements.
    
         The time namespace addresses this problem. It allows to set offsets
         for clock MONOTONIC and BOOTTIME once after creation and before
         tasks are associated with the namespace. These offsets are taken
         into account by timers and timekeeping including the VDSO.
    
         Offsets for wall clock based clocks (REALTIME/TAI) are not provided
         by this mechanism. While in theory possible, the overhead and code
         complexity would be immense and not justified by the esoteric
         potential use cases which were discussed at Plumbers '18.
    
         The overhead for tasks in the root namespace (ie where host time
         offsets = 0) is in the noise and great effort was made to ensure
         that especially in the VDSO. If time namespace is disabled in the
         kernel configuration the code is compiled out.
    
         Kudos to Andrei Vagin and Dmitry Sofanov who implemented this
         feature and kept on for more than a year addressing review
         comments, finding better solutions. A pleasant experience.
    
       - Overhaul of the alarmtimer device dependency handling to ensure
         that the init/suspend/resume ordering is correct.
    
       - A new clocksource/event driver for Microchip PIT64
    
       - Suspend/resume support for the Hyper-V clocksource
    
       - The usual pile of fixes, updates and improvements mostly in the
         driver code"
    
    * tag 'timers-core-2020-01-27' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (71 commits)
      alarmtimer: Make alarmtimer_get_rtcdev() a stub when CONFIG_RTC_CLASS=n
      alarmtimer: Use wakeup source from alarmtimer platform device
      alarmtimer: Make alarmtimer platform device child of RTC device
      alarmtimer: Update alarmtimer_get_rtcdev() docs to reflect reality
      hrtimer: Add missing sparse annotation for __run_timer()
      lib/vdso: Only read hrtimer_res when needed in __cvdso_clock_getres()
      MIPS: vdso: Define BUILD_VDSO32 when building a 32bit kernel
      clocksource/drivers/hyper-v: Set TSC clocksource as default w/ InvariantTSC
      clocksource/drivers/hyper-v: Untangle stimers and timesync from clocksources
      clocksource/drivers/timer-microchip-pit64b: Fix sparse warning
      clocksource/drivers/exynos_mct: Rename Exynos to lowercase
      clocksource/drivers/timer-ti-dm: Fix uninitialized pointer access
      clocksource/drivers/timer-ti-dm: Switch to platform_get_irq
      clocksource/drivers/timer-ti-dm: Convert to devm_platform_ioremap_resource
      clocksource/drivers/em_sti: Fix variable declaration in em_sti_probe
      clocksource/drivers/em_sti: Convert to devm_platform_ioremap_resource
      clocksource/drivers/bcm2835_timer: Fix memory leak of timer
      clocksource/drivers/cadence-ttc: Use ttc driver as platform driver
      clocksource/drivers/timer-microchip-pit64b: Add Microchip PIT64B support
      clocksource/drivers/hyper-v: Reserve PAGE_SIZE space for tsc page
      ...

commit 9f24c540f7f8eb3a981528da9a9a636a5bdf5987
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jan 14 19:52:39 2020 +0100

    lib/vdso: Update coarse timekeeper unconditionally
    
    The low resolution parts of the VDSO, i.e.:
    
      clock_gettime(CLOCK_*_COARSE), clock_getres(), time()
    
    can be used even if there is no VDSO capable clocksource.
    
    But if an architecture opts out of the VDSO data update then this
    information becomes stale. This affects ARM when there is no architected
    timer available. The lack of update causes userspace to use stale data
    forever.
    
    Make the update of the low resolution parts unconditional and only skip
    the update of the high resolution parts if the architecture requests it.
    
    Fixes: 44f57d788e7d ("timekeeping: Provide a generic update_vsyscall() implementation")
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lore.kernel.org/r/20200114185946.765577901@linutronix.de

commit 9a6b55ac4a44060bcb782baf002859b2a2c63267
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jan 14 19:52:38 2020 +0100

    lib/vdso: Make __arch_update_vdso_data() logic understandable
    
    The function name suggests that this is a boolean checking whether the
    architecture asks for an update of the VDSO data, but it works the other
    way round. To spare further confusion invert the logic.
    
    Fixes: 44f57d788e7d ("timekeeping: Provide a generic update_vsyscall() implementation")
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lore.kernel.org/r/20200114185946.656652824@linutronix.de

commit 5167c506d62dd9ffab73eba23c79b0a8845c9fe1
Author: Chunyan Zhang <zhang.lyra@gmail.com>
Date:   Fri Jan 10 16:39:02 2020 +0800

    tick/common: Touch watchdog in tick_unfreeze() on all CPUs
    
    Suspend to IDLE invokes tick_unfreeze() on resume. tick_unfreeze() on the
    first resuming CPU resumes timekeeping, which also has the side effect of
    resetting the softlockup watchdog on this CPU.
    
    But on the secondary CPUs the watchdog is not reset in the resume /
    unfreeze() path, which can result in false softlockup warnings on those
    CPUs depending on the time spent in suspend.
    
    Prevent this by clearing the softlock watchdog in the unfreeze path also
    on the secondary resuming CPUs.
    
    [ tglx: Massaged changelog ]
    
    Signed-off-by: Chunyan Zhang <chunyan.zhang@unisoc.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lore.kernel.org/r/20200110083902.27276-1-chunyan.zhang@unisoc.com

commit 28f34294442b5525796d801f26ef3eda253f0096
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon Sep 30 08:40:01 2019 -0700

    clk: ti: clkctrl: Fix failed to enable error with double udelay timeout
    
    [ Upstream commit 81a41901ffd46bac6df4c95b8290ac259e0feda8 ]
    
    Commit 3d8598fb9c5a ("clk: ti: clkctrl: use fallback udelay approach if
    timekeeping is suspended") added handling for cases when timekeeping is
    suspended. But looks like we can still get occasional "failed to enable"
    errors on the PM runtime resume path with udelay() returning faster than
    expected.
    
    With ti-sysc interconnect target module driver this leads into device
    failure with PM runtime failing with "failed to enable" clkctrl error.
    
    Let's fix the issue with a delay of two times the desired delay as in
    often done for udelay() to account for the inaccuracy.
    
    Fixes: 3d8598fb9c5a ("clk: ti: clkctrl: use fallback udelay approach if timekeeping is suspended")
    Cc: Keerthy <j-keerthy@ti.com>
    Cc: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Link: https://lkml.kernel.org/r/20190930154001.46581-1-tony@atomide.com
    Tested-by: Keerthy <j-keerthy@ti.com>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit b5c92066656ef5d05667afc0d54356e335f9f540
Author: Michael Zhivich <mzhivich@akamai.com>
Date:   Thu Oct 24 13:59:45 2019 -0400

    x86/tsc: Respect tsc command line paraemeter for clocksource_tsc_early
    
    [ Upstream commit 63ec58b44fcc05efd1542045abd7faf056ac27d9 ]
    
    The introduction of clocksource_tsc_early broke the functionality of
    "tsc=reliable" and "tsc=nowatchdog" command line parameters, since
    clocksource_tsc_early is unconditionally registered with
    CLOCK_SOURCE_MUST_VERIFY and thus put on the watchdog list.
    
    This can cause the TSC to be declared unstable during boot:
    
      clocksource: timekeeping watchdog on CPU0: Marking clocksource
                   'tsc-early' as unstable because the skew is too large:
      clocksource: 'refined-jiffies' wd_now: fffb7018 wd_last: fffb6e9d
                   mask: ffffffff
      clocksource: 'tsc-early' cs_now: 68a6a7070f6a0 cs_last: 68a69ab6f74d6
                   mask: ffffffffffffffff
      tsc: Marking TSC unstable due to clocksource watchdog
    
    The corresponding elapsed times are cs_nsec=1224152026 and wd_nsec=378942392, so
    the watchdog differs from TSC by 0.84 seconds.
    
    This happens when HPET is not available and jiffies are used as the TSC
    watchdog instead and the jiffies update is not happening due to lost timer
    interrupts in periodic mode, which can happen e.g. with expensive debug
    mechanisms enabled or under massive overload conditions in virtualized
    environments.
    
    Before the introduction of the early TSC clocksource the command line
    parameters "tsc=reliable" and "tsc=nowatchdog" could be used to work around
    this issue.
    
    Restore the behaviour by disabling the watchdog if requested on the kernel
    command line.
    
    [ tglx: Clarify changelog ]
    
    Fixes: aa83c45762a24 ("x86/tsc: Introduce early tsc clocksource")
    Signed-off-by: Michael Zhivich <mzhivich@akamai.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lkml.kernel.org/r/20191024175945.14338-1-mzhivich@akamai.com
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 035b3f8cf1917dca287af368731add05144fe4b7
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon Sep 30 08:40:01 2019 -0700

    clk: ti: clkctrl: Fix failed to enable error with double udelay timeout
    
    [ Upstream commit 81a41901ffd46bac6df4c95b8290ac259e0feda8 ]
    
    Commit 3d8598fb9c5a ("clk: ti: clkctrl: use fallback udelay approach if
    timekeeping is suspended") added handling for cases when timekeeping is
    suspended. But looks like we can still get occasional "failed to enable"
    errors on the PM runtime resume path with udelay() returning faster than
    expected.
    
    With ti-sysc interconnect target module driver this leads into device
    failure with PM runtime failing with "failed to enable" clkctrl error.
    
    Let's fix the issue with a delay of two times the desired delay as in
    often done for udelay() to account for the inaccuracy.
    
    Fixes: 3d8598fb9c5a ("clk: ti: clkctrl: use fallback udelay approach if timekeeping is suspended")
    Cc: Keerthy <j-keerthy@ti.com>
    Cc: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Link: https://lkml.kernel.org/r/20190930154001.46581-1-tony@atomide.com
    Tested-by: Keerthy <j-keerthy@ti.com>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 32d3fe68d20e3da9737fe828c23008fec94d48fa
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Aug 14 15:18:20 2018 +0200

    y2038: make do_gettimeofday() and get_seconds() inline
    
    [ Upstream commit 33e26418193f58d1895f2f968e1953b1caf8deb7 ]
    
    get_seconds() and do_gettimeofday() are only used by a few modules now any
    more (waiting for the respective patches to get accepted), and they are
    among the last holdouts of code that is not y2038 safe in the core kernel.
    
    Move the implementation into the timekeeping32.h header to clean up
    the core kernel and isolate the old interfaces further.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit ab3664eabfa765e8fabcc106e23f7382ded518cb
Author: Huacai Chen <chenhuacai@kernel.org>
Date:   Thu Oct 24 11:28:29 2019 +0800

    timekeeping/vsyscall: Update VDSO data unconditionally
    
    [ Upstream commit 52338415cf4d4064ae6b8dd972dadbda841da4fa ]
    
    The update of the VDSO data is depending on __arch_use_vsyscall() returning
    True. This is a leftover from the attempt to map the features of various
    architectures 1:1 into generic code.
    
    The usage of __arch_use_vsyscall() in the actual vsyscall implementations
    got dropped and replaced by the requirement for the architecture code to
    return U64_MAX if the global clocksource is not usable in the VDSO.
    
    But the __arch_use_vsyscall() check in the update code stayed which causes
    the VDSO data to be stale or invalid when an architecture actually
    implements that function and returns False when the current clocksource is
    not usable in the VDSO.
    
    As a consequence the VDSO implementations of clock_getres(), time(),
    clock_gettime(CLOCK_.*_COARSE) operate on invalid data and return bogus
    information.
    
    Remove the __arch_use_vsyscall() check from the VDSO update function and
    update the VDSO data unconditionally.
    
    [ tglx: Massaged changelog and removed the now useless implementations in
            asm-generic/ARM64/MIPS ]
    
    Fixes: 44f57d788e7deecb50 ("timekeeping: Provide a generic update_vsyscall() implementation")
    Signed-off-by: Huacai Chen <chenhc@lemote.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Vincenzo Frascino <vincenzo.frascino@arm.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Paul Burton <paul.burton@mips.com>
    Cc: linux-mips@vger.kernel.org
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: stable@vger.kernel.org
    Link: https://lkml.kernel.org/r/1571887709-11447-1-git-send-email-chenhc@lemote.com
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 621084cd3d8cb31aa43a3e4cc37e27e3ddaab561
Merge: 81388c2b3fb1 52338415cf4d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Nov 10 12:03:58 2019 -0800

    Merge branch 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer fixes from Thomas Gleixner:
     "A small set of fixes for timekeepoing and clocksource drivers:
    
       - VDSO data was updated conditional on the availability of a VDSO
         capable clocksource. This causes the VDSO functions which do not
         depend on a VDSO capable clocksource to operate on stale data.
         Always update unconditionally.
    
       - Prevent a double free in the mediatek driver
    
       - Use the proper helper in the sh_mtu2 driver so it won't attempt to
         initialize non-existing interrupts"
    
    * 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      timekeeping/vsyscall: Update VDSO data unconditionally
      clocksource/drivers/sh_mtu2: Do not loop using platform_get_irq_by_name()
      clocksource/drivers/mediatek: Fix error handling

commit 63ec58b44fcc05efd1542045abd7faf056ac27d9
Author: Michael Zhivich <mzhivich@akamai.com>
Date:   Thu Oct 24 13:59:45 2019 -0400

    x86/tsc: Respect tsc command line paraemeter for clocksource_tsc_early
    
    The introduction of clocksource_tsc_early broke the functionality of
    "tsc=reliable" and "tsc=nowatchdog" command line parameters, since
    clocksource_tsc_early is unconditionally registered with
    CLOCK_SOURCE_MUST_VERIFY and thus put on the watchdog list.
    
    This can cause the TSC to be declared unstable during boot:
    
      clocksource: timekeeping watchdog on CPU0: Marking clocksource
                   'tsc-early' as unstable because the skew is too large:
      clocksource: 'refined-jiffies' wd_now: fffb7018 wd_last: fffb6e9d
                   mask: ffffffff
      clocksource: 'tsc-early' cs_now: 68a6a7070f6a0 cs_last: 68a69ab6f74d6
                   mask: ffffffffffffffff
      tsc: Marking TSC unstable due to clocksource watchdog
    
    The corresponding elapsed times are cs_nsec=1224152026 and wd_nsec=378942392, so
    the watchdog differs from TSC by 0.84 seconds.
    
    This happens when HPET is not available and jiffies are used as the TSC
    watchdog instead and the jiffies update is not happening due to lost timer
    interrupts in periodic mode, which can happen e.g. with expensive debug
    mechanisms enabled or under massive overload conditions in virtualized
    environments.
    
    Before the introduction of the early TSC clocksource the command line
    parameters "tsc=reliable" and "tsc=nowatchdog" could be used to work around
    this issue.
    
    Restore the behaviour by disabling the watchdog if requested on the kernel
    command line.
    
    [ tglx: Clarify changelog ]
    
    Fixes: aa83c45762a24 ("x86/tsc: Introduce early tsc clocksource")
    Signed-off-by: Michael Zhivich <mzhivich@akamai.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lkml.kernel.org/r/20191024175945.14338-1-mzhivich@akamai.com

commit 52338415cf4d4064ae6b8dd972dadbda841da4fa
Author: Huacai Chen <chenhuacai@kernel.org>
Date:   Thu Oct 24 11:28:29 2019 +0800

    timekeeping/vsyscall: Update VDSO data unconditionally
    
    The update of the VDSO data is depending on __arch_use_vsyscall() returning
    True. This is a leftover from the attempt to map the features of various
    architectures 1:1 into generic code.
    
    The usage of __arch_use_vsyscall() in the actual vsyscall implementations
    got dropped and replaced by the requirement for the architecture code to
    return U64_MAX if the global clocksource is not usable in the VDSO.
    
    But the __arch_use_vsyscall() check in the update code stayed which causes
    the VDSO data to be stale or invalid when an architecture actually
    implements that function and returns False when the current clocksource is
    not usable in the VDSO.
    
    As a consequence the VDSO implementations of clock_getres(), time(),
    clock_gettime(CLOCK_.*_COARSE) operate on invalid data and return bogus
    information.
    
    Remove the __arch_use_vsyscall() check from the VDSO update function and
    update the VDSO data unconditionally.
    
    [ tglx: Massaged changelog and removed the now useless implementations in
            asm-generic/ARM64/MIPS ]
    
    Fixes: 44f57d788e7deecb50 ("timekeeping: Provide a generic update_vsyscall() implementation")
    Signed-off-by: Huacai Chen <chenhc@lemote.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Vincenzo Frascino <vincenzo.frascino@arm.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Paul Burton <paul.burton@mips.com>
    Cc: linux-mips@vger.kernel.org
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: stable@vger.kernel.org
    Link: https://lkml.kernel.org/r/1571887709-11447-1-git-send-email-chenhc@lemote.com

commit 81a41901ffd46bac6df4c95b8290ac259e0feda8
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon Sep 30 08:40:01 2019 -0700

    clk: ti: clkctrl: Fix failed to enable error with double udelay timeout
    
    Commit 3d8598fb9c5a ("clk: ti: clkctrl: use fallback udelay approach if
    timekeeping is suspended") added handling for cases when timekeeping is
    suspended. But looks like we can still get occasional "failed to enable"
    errors on the PM runtime resume path with udelay() returning faster than
    expected.
    
    With ti-sysc interconnect target module driver this leads into device
    failure with PM runtime failing with "failed to enable" clkctrl error.
    
    Let's fix the issue with a delay of two times the desired delay as in
    often done for udelay() to account for the inaccuracy.
    
    Fixes: 3d8598fb9c5a ("clk: ti: clkctrl: use fallback udelay approach if timekeeping is suspended")
    Cc: Keerthy <j-keerthy@ti.com>
    Cc: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Link: https://lkml.kernel.org/r/20190930154001.46581-1-tony@atomide.com
    Tested-by: Keerthy <j-keerthy@ti.com>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

commit 2b776b54bca8c6f3b3a37f89bd80863b688bd8dd
Merge: a8a31fdccabb 7f2cbcbcafbc
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Oct 27 07:04:22 2019 -0400

    Merge branch 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer fixes from Thomas Gleixner:
     "A small set of fixes for time(keeping):
    
       - Add a missing include to prevent compiler warnings.
    
       - Make the VDSO implementation of clock_getres() POSIX compliant
         again. A recent change dropped the NULL pointer guard which is
         required as NULL is a valid pointer value for this function.
    
       - Fix two function documentation typos"
    
    * 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      posix-cpu-timers: Fix two trivial comments
      timers/sched_clock: Include local timekeeping.h for missing declarations
      lib/vdso: Make clock_getres() POSIX compliant again

commit 086ee46b08634a999bcd1707eabe3b0dc1806674
Author: Ben Dooks (Codethink) <ben.dooks@codethink.co.uk>
Date:   Tue Oct 22 14:12:26 2019 +0100

    timers/sched_clock: Include local timekeeping.h for missing declarations
    
    Include the timekeeping.h header to get the declaration of the
    sched_clock_{suspend,resume} functions. Fixes the following sparse
    warnings:
    
    kernel/time/sched_clock.c:275:5: warning: symbol 'sched_clock_suspend' was not declared. Should it be static?
    kernel/time/sched_clock.c:286:6: warning: symbol 'sched_clock_resume' was not declared. Should it be static?
    
    Signed-off-by: Ben Dooks (Codethink) <ben.dooks@codethink.co.uk>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lkml.kernel.org/r/20191022131226.11465-1-ben.dooks@codethink.co.uk

commit 7f2444d38f6bbfa12bc15e2533d8f9daa85ca02b
Merge: c5f12fdb8bd8 77b4b5420422
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Sep 17 12:35:15 2019 -0700

    Merge branch 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull core timer updates from Thomas Gleixner:
     "Timers and timekeeping updates:
    
       - A large overhaul of the posix CPU timer code which is a preparation
         for moving the CPU timer expiry out into task work so it can be
         properly accounted on the task/process.
    
         An update to the bogus permission checks will come later during the
         merge window as feedback was not complete before heading of for
         travel.
    
       - Switch the timerqueue code to use cached rbtrees and get rid of the
         homebrewn caching of the leftmost node.
    
       - Consolidate hrtimer_init() + hrtimer_init_sleeper() calls into a
         single function
    
       - Implement the separation of hrtimers to be forced to expire in hard
         interrupt context even when PREEMPT_RT is enabled and mark the
         affected timers accordingly.
    
       - Implement a mechanism for hrtimers and the timer wheel to protect
         RT against priority inversion and live lock issues when a (hr)timer
         which should be canceled is currently executing the callback.
         Instead of infinitely spinning, the task which tries to cancel the
         timer blocks on a per cpu base expiry lock which is held and
         released by the (hr)timer expiry code.
    
       - Enable the Hyper-V TSC page based sched_clock for Hyper-V guests
         resulting in faster access to timekeeping functions.
    
       - Updates to various clocksource/clockevent drivers and their device
         tree bindings.
    
       - The usual small improvements all over the place"
    
    * 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (101 commits)
      posix-cpu-timers: Fix permission check regression
      posix-cpu-timers: Always clear head pointer on dequeue
      hrtimer: Add a missing bracket and hide `migration_base' on !SMP
      posix-cpu-timers: Make expiry_active check actually work correctly
      posix-timers: Unbreak CONFIG_POSIX_TIMERS=n build
      tick: Mark sched_timer to expire in hard interrupt context
      hrtimer: Add kernel doc annotation for HRTIMER_MODE_HARD
      x86/hyperv: Hide pv_ops access for CONFIG_PARAVIRT=n
      posix-cpu-timers: Utilize timerqueue for storage
      posix-cpu-timers: Move state tracking to struct posix_cputimers
      posix-cpu-timers: Deduplicate rlimit handling
      posix-cpu-timers: Remove pointless comparisons
      posix-cpu-timers: Get rid of 64bit divisions
      posix-cpu-timers: Consolidate timer expiry further
      posix-cpu-timers: Get rid of zero checks
      rlimit: Rewrite non-sensical RLIMIT_CPU comment
      posix-cpu-timers: Respect INFINITY for hard RTTIME limit
      posix-cpu-timers: Switch thread group sampling to array
      posix-cpu-timers: Restructure expiry array
      posix-cpu-timers: Remove cputime_expires
      ...

commit 68829256e1f9ba375080e762f2c82b33a25f55e1
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Fri Jun 21 22:32:47 2019 +0200

    timekeeping: Use proper ktime_add when adding nsecs in coarse offset
    
    [ Upstream commit 0354c1a3cdf31f44b035cfad14d32282e815a572 ]
    
    While this doesn't actually amount to a real difference, since the macro
    evaluates to the same thing, every place else operates on ktime_t using
    these functions, so let's not break the pattern.
    
    Fixes: e3ff9c3678b4 ("timekeeping: Repair ktime_get_coarse*() granularity")
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>
    Link: https://lkml.kernel.org/r/20190621203249.3909-1-Jason@zx2c4.com
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 5a13fc3d8ba00b786056e6fd3612b5102590992f
Merge: 8a04c2ee62a4 b99328a60a48
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Aug 25 10:08:01 2019 -0700

    Merge branch 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timekeeping fix from Thomas Gleixner:
     "A single fix for a regression caused by the generic VDSO
      implementation where a math overflow causes CLOCK_BOOTTIME to become a
      random number generator"
    
    * 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      timekeeping/vsyscall: Prevent math overflow in BOOTTIME update

commit b99328a60a482108f5195b4d611f90992ca016ba
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Aug 22 13:00:15 2019 +0200

    timekeeping/vsyscall: Prevent math overflow in BOOTTIME update
    
    The VDSO update for CLOCK_BOOTTIME has a overflow issue as it shifts the
    nanoseconds based boot time offset left by the clocksource shift. That
    overflows once the boot time offset becomes large enough. As a consequence
    CLOCK_BOOTTIME in the VDSO becomes a random number causing applications to
    misbehave.
    
    Fix it by storing a timespec64 representation of the offset when boot time
    is adjusted and add that to the MONOTONIC base time value in the vdso data
    page. Using the timespec64 representation avoids a 64bit division in the
    update code.
    
    Fixes: 44f57d788e7d ("timekeeping: Provide a generic update_vsyscall() implementation")
    Reported-by: Chris Clayton <chris2553@googlemail.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Chris Clayton <chris2553@googlemail.com>
    Tested-by: Vincenzo Frascino <vincenzo.frascino@arm.com>
    Link: https://lkml.kernel.org/r/alpine.DEB.2.21.1908221257580.1983@nanos.tec.linutronix.de

commit 643d83f0a3518d6fbcf88f970de0340a5aa6b5a2
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Jul 25 08:28:45 2019 +0200

    x86/hpet: Undo the early counter is counting check
    
    Rui reported that on a Pentium D machine which has HPET forced enabled
    because it is not advertised by ACPI, the early counter is counting check
    leads to a silent boot hang.
    
    The reason is that the ordering of checking the counter first and then
    reconfiguring the HPET fails to work on that machine. As the HPET is not
    advertised and presumably not initialized by the BIOS the early enable and
    the following reconfiguration seems to bring it into a broken state. Adding
    clocksource=jiffies to the command line results in the following
    clocksource watchdog warning:
    
      clocksource: timekeeping watchdog on CPU1:
      Marking clocksource 'tsc-early' as unstable because the skew is too large:
      clocksource:  'hpet' wd_now: 33 wd_last: 33 mask: ffffffff
    
    That clearly shows that the HPET is not counting after it got reconfigured
    and reenabled. If the counter is not working then the HPET timer is not
    expiring either, which explains the boot hang.
    
    Move the counter is counting check after the full configuration again to
    unbreak these systems.
    
    Reported-by: Rui Salvaterra <rsalvaterra@gmail.com>
    Fixes: 3222daf970f3 ("x86/hpet: Separate counter check out of clocksource register code")
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Rui Salvaterra <rsalvaterra@gmail.com>
    Link: https://lkml.kernel.org/r/alpine.DEB.2.21.1907250810530.1791@nanos.tec.linutronix.de

commit d7fe42a64a19a4140fb94bcf996035319cd3e6b9
Merge: 02150fab6ae9 0df1c9868c3a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jul 11 13:52:23 2019 -0700

    Merge branch 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer fixes from Thomas Gleixner:
     "Two small fixes from the timer departement:
    
       - Prevent the compiler from converting the nanoseconds adjustment
         loop in the VDSO update function to a division (__udivdi3) by using
         the __iter_div_u64_rem() inline function which exists to prevent
         exactly that problem.
    
       - Fix the wrong argument order of the GENMASK macro in the NPCM timer
         driver"
    
    * 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      timekeeping/vsyscall: Use __iter_div_u64_rem()
      clocksource/drivers/npcm: Fix misuse of GENMASK macro

commit 0df1c9868c3a1916198ee09c323ca5932a0b8a11
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Jul 10 15:01:53 2019 +0200

    timekeeping/vsyscall: Use __iter_div_u64_rem()
    
    On 32-bit x86 when building with clang-9, the 'division' loop gets turned
    back into an inefficient division that causes a link error:
    
    kernel/time/vsyscall.o: In function `update_vsyscall':
    vsyscall.c:(.text+0xe3): undefined reference to `__udivdi3'
    
    Use the existing __iter_div_u64_rem() function which is used to address the
    same issue in other places.
    
    Fixes: 44f57d788e7d ("timekeeping: Provide a generic update_vsyscall() implementation")
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Nathan Chancellor <natechancellor@gmail.com>
    Tested-by: Nathan Chancellor <natechancellor@gmail.com>
    Link: https://lkml.kernel.org/r/20190710130206.1670830-1-arnd@arndb.de

commit 927ba67a63c72ee87d655e30183d1576c3717d3e
Merge: 2a1ccd31420a 9176ab1b8480
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jul 8 11:06:29 2019 -0700

    Merge branch 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer updates from Thomas Gleixner:
     "The timer and timekeeping departement delivers:
    
      Core:
    
       - The consolidation of the VDSO code into a generic library including
         the conversion of x86 and ARM64. Conversion of ARM and MIPS are en
         route through the relevant maintainer trees and should end up in
         5.4.
    
         This gets rid of the unnecessary different copies of the same code
         and brings all architectures on the same level of VDSO
         functionality.
    
       - Make the NTP user space interface more robust by restricting the
         TAI offset to prevent undefined behaviour. Includes a selftest.
    
       - Validate user input in the compat settimeofday() syscall to catch
         invalid values which would be turned into valid values by a
         multiplication overflow
    
       - Consolidate the time accessors
    
       - Small fixes, improvements and cleanups all over the place
    
      Drivers:
    
       - Support for the NXP system counter, TI davinci timer
    
       - Move the Microsoft HyperV clocksource/events code into the
         drivers/clocksource directory so it can be shared between x86 and
         ARM64.
    
       - Overhaul of the Tegra driver
    
       - Delay timer support for IXP4xx
    
       - Small fixes, improvements and cleanups as usual"
    
    * 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (71 commits)
      time: Validate user input in compat_settimeofday()
      timer: Document TIMER_PINNED
      clocksource/drivers: Continue making Hyper-V clocksource ISA agnostic
      clocksource/drivers: Make Hyper-V clocksource ISA agnostic
      MAINTAINERS: Fix Andy's surname and the directory entries of VDSO
      hrtimer: Use a bullet for the returns bullet list
      arm64: vdso: Fix compilation with clang older than 8
      arm64: compat: Fix __arch_get_hw_counter() implementation
      arm64: Fix __arch_get_hw_counter() implementation
      lib/vdso: Make delta calculation work correctly
      MAINTAINERS: Add entry for the generic VDSO library
      arm64: compat: No need for pre-ARMv7 barriers on an ARMv8 system
      arm64: vdso: Remove unnecessary asm-offsets.c definitions
      vdso: Remove superfluous #ifdef __KERNEL__ in vdso/datapage.h
      clocksource/drivers/davinci: Add support for clocksource
      clocksource/drivers/davinci: Add support for clockevents
      clocksource/drivers/tegra: Set up maximum-ticks limit properly
      clocksource/drivers/tegra: Cycles can't be 0
      clocksource/drivers/tegra: Restore base address before cleanup
      clocksource/drivers/tegra: Add verbose definition for 1MHz constant
      ...

commit fd329f276ecaad7a371d6f91b9bbea031d0c3440
Author: Ricardo Neri <ricardo.neri-calderon@linux.intel.com>
Date:   Thu Jun 27 19:35:37 2019 -0700

    x86/mtrr: Skip cache flushes on CPUs with cache self-snooping
    
    Programming MTRR registers in multi-processor systems is a rather lengthy
    process. Furthermore, all processors must program these registers in lock
    step and with interrupts disabled; the process also involves flushing
    caches and TLBs twice. As a result, the process may take a considerable
    amount of time.
    
    On some platforms, this can lead to a large skew of the refined-jiffies
    clock source. Early when booting, if no other clock is available (e.g.,
    booting with hpet=disabled), the refined-jiffies clock source is used to
    monitor the TSC clock source. If the skew of refined-jiffies is too large,
    Linux wrongly assumes that the TSC is unstable:
    
      clocksource: timekeeping watchdog on CPU1: Marking clocksource
                   'tsc-early' as unstable because the skew is too large:
      clocksource: 'refined-jiffies' wd_now: fffedc10 wd_last:
                   fffedb90 mask: ffffffff
      clocksource: 'tsc-early' cs_now: 5eccfddebc cs_last: 5e7e3303d4
                   mask: ffffffffffffffff
      tsc: Marking TSC unstable due to clocksource watchdog
    
    As per measurements, around 98% of the time needed by the procedure to
    program MTRRs in multi-processor systems is spent flushing caches with
    wbinvd(). As per the Section 11.11.8 of the Intel 64 and IA 32
    Architectures Software Developer's Manual, it is not necessary to flush
    caches if the CPU supports cache self-snooping. Thus, skipping the cache
    flushes can reduce by several tens of milliseconds the time needed to
    complete the programming of the MTRR registers:
    
    Platform                        Before     After
    104-core (208 Threads) Skylake  1437ms      28ms
      2-core (  4 Threads) Haswell   114ms       2ms
    
    Reported-by: Mohammad Etemadi <mohammad.etemadi@intel.com>
    Signed-off-by: Ricardo Neri <ricardo.neri-calderon@linux.intel.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Borislav Petkov <bp@suse.de>
    Cc: Alan Cox <alan.cox@intel.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Cc: Andi Kleen <andi.kleen@intel.com>
    Cc: Hans de Goede <hdegoede@redhat.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Jordan Borgner <mail@jordan-borgner.de>
    Cc: "Ravi V. Shankar" <ravi.v.shankar@intel.com>
    Cc: Ricardo Neri <ricardo.neri@intel.com>
    Cc: Andy Shevchenko <andriy.shevchenko@intel.com>
    Cc: Andi Kleen <ak@linux.intel.com>
    Cc: Peter Feiner <pfeiner@google.com>
    Cc: "Rafael J. Wysocki" <rafael.j.wysocki@intel.com>
    Link: https://lkml.kernel.org/r/1561689337-19390-3-git-send-email-ricardo.neri-calderon@linux.intel.com

commit 9d90b93bf325e015bbae31b83f16da5e4e17effa
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Jun 26 12:02:00 2019 +0200

    lib/vdso: Make delta calculation work correctly
    
    The x86 vdso implementation on which the generic vdso library is based on
    has subtle (unfortunately undocumented) twists:
    
     1) The code assumes that the clocksource mask is U64_MAX which means that
        no bits are masked. Which is true for any valid x86 VDSO clocksource.
        Stupidly it still did the mask operation for no reason and at the wrong
        place right after reading the clocksource.
    
     2) It contains a sanity check to catch the case where slightly
        unsynchronized TSC values can be observed which would cause the delta
        calculation to make a huge jump. It therefore checks whether the
        current TSC value is larger than the value on which the current
        conversion is based on. If it's not larger the base value is used to
        prevent time jumps.
    
    #1 Is not only stupid for the X86 case because it does the masking for no
    reason it is also completely wrong for clocksources with a smaller mask
    which can legitimately wrap around during a conversion period. The core
    timekeeping code does it correct by applying the mask after the delta
    calculation:
    
            (now - base) & mask
    
    #2 is equally broken for clocksources which have smaller masks and can wrap
    around during a conversion period because there the now > base check is
    just wrong and causes stale time stamps and time going backwards issues.
    
    Unbreak it by:
    
      1) Removing the mask operation from the clocksource read which makes the
         fallback detection work for all clocksources
    
      2) Replacing the conditional delta calculation with a overrideable inline
         function.
    
    #2 could reuse clocksource_delta() from the timekeeping code but that
    results in a significant performance hit for the x86 VSDO. The timekeeping
    core code must have the non optimized version as it has to operate
    correctly with clocksources which have smaller masks as well to handle the
    case where TSC is discarded as timekeeper clocksource and replaced by HPET
    or pmtimer. For the VDSO there is no replacement clocksource. If TSC is
    unusable the syscall is enforced which does the right thing.
    
    To accommodate to the needs of various architectures provide an
    override-able inline function which defaults to the regular delta
    calculation with masking:
    
            (now - base) & mask
    
    Override it for x86 with the non-masking and checking version.
    
    This unbreaks the ARM64 syscall fallback operation, allows to use
    clocksources with arbitrary width and preserves the performance
    optimization for x86.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Vincenzo Frascino <vincenzo.frascino@arm.com>
    Cc: linux-arch@vger.kernel.org
    Cc: LAK <linux-arm-kernel@lists.infradead.org>
    Cc: linux-mips@vger.kernel.org
    Cc: linux-kselftest@vger.kernel.org
    Cc: catalin.marinas@arm.com
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: linux@armlinux.org.uk
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: paul.burton@mips.com
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: salyzyn@android.com
    Cc: pcc@google.com
    Cc: shuah@kernel.org
    Cc: 0x7f454c46@gmail.com
    Cc: linux@rasmusvillemoes.dk
    Cc: huw@codeweavers.com
    Cc: sthotton@marvell.com
    Cc: andre.przywara@arm.com
    Cc: Andy Lutomirski <luto@kernel.org>
    Link: https://lkml.kernel.org/r/alpine.DEB.2.21.1906261159230.32342@nanos.tec.linutronix.de

commit d48e0cd8fcaf314175a15d3076d7a1e71bd4e628
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Mon Jun 24 11:15:39 2019 +0200

    timekeeping: Boot should be boottime for coarse ns accessor
    
    Somewhere in all the patchsets before, this cleanup got lost.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Link: https://lkml.kernel.org/r/20190624091539.13512-1-Jason@zx2c4.com

commit 44f57d788e7deecb504843534081d3449c2eede9
Author: Vincenzo Frascino <vincenzo.frascino@arm.com>
Date:   Fri Jun 21 10:52:30 2019 +0100

    timekeeping: Provide a generic update_vsyscall() implementation
    
    The new generic VDSO library allows to unify the update_vsyscall[_tz]()
    implementations.
    
    Provide a generic implementation based on the x86 code and the bindings
    which need to be implemented in architecture specific code.
    
    [ tglx: Moved it into kernel/time where it belongs. Removed the pointless
            line breaks in the stub functions. Massaged changelog ]
    
    Signed-off-by: Vincenzo Frascino <vincenzo.frascino@arm.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Shijith Thotton <sthotton@marvell.com>
    Tested-by: Andre Przywara <andre.przywara@arm.com>
    Cc: linux-arch@vger.kernel.org
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: linux-mips@vger.kernel.org
    Cc: linux-kselftest@vger.kernel.org
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Paul Burton <paul.burton@mips.com>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: Mark Salyzyn <salyzyn@android.com>
    Cc: Peter Collingbourne <pcc@google.com>
    Cc: Shuah Khan <shuah@kernel.org>
    Cc: Dmitry Safonov <0x7f454c46@gmail.com>
    Cc: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Cc: Huw Davies <huw@codeweavers.com>
    Link: https://lkml.kernel.org/r/20190621095252.32307-4-vincenzo.frascino@arm.com

commit 4c54294d01e605a9f992361b924c5d8b12822a6d
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Fri Jun 21 22:32:49 2019 +0200

    timekeeping: Add missing _ns functions for coarse accessors
    
    This further unifies the accessors for the fast and coarse functions, so
    that the same types of functions are available for each. There was also
    a bit of confusion with the documentation, which prior advertised a
    function that has never existed. Finally, the vanilla ktime_get_coarse()
    was omitted from the API originally, so this fills this oversight.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>
    Link: https://lkml.kernel.org/r/20190621203249.3909-3-Jason@zx2c4.com

commit 9285ec4c8b61d4930a575081abeba2cd4f449a74
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Fri Jun 21 22:32:48 2019 +0200

    timekeeping: Use proper clock specifier names in functions
    
    This makes boot uniformly boottime and tai uniformly clocktai, to
    address the remaining oversights.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>
    Link: https://lkml.kernel.org/r/20190621203249.3909-2-Jason@zx2c4.com

commit 0354c1a3cdf31f44b035cfad14d32282e815a572
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Fri Jun 21 22:32:47 2019 +0200

    timekeeping: Use proper ktime_add when adding nsecs in coarse offset
    
    While this doesn't actually amount to a real difference, since the macro
    evaluates to the same thing, every place else operates on ktime_t using
    these functions, so let's not break the pattern.
    
    Fixes: e3ff9c3678b4 ("timekeeping: Repair ktime_get_coarse*() granularity")
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>
    Link: https://lkml.kernel.org/r/20190621203249.3909-1-Jason@zx2c4.com

commit d21e43f2ef32ba3242687dbedb3c4b9a76b3eebc
Author: Miroslav Lichvar <mlichvar@redhat.com>
Date:   Tue Jun 18 18:06:12 2019 +0200

    kselftests: timers: freq-step: Update maximum acceptable precision and errors
    
    PTI has a significant impact on precision of the MONOTONIC_RAW clock,
    which prevents a lot of computers from running the freq-step test.
    Increase the maximum acceptable precision for the test to not be skipped
    to 500 nanoseconds.
    
    After commit 78b98e3c5a66 ("timekeeping/ntp: Determine the multiplier
    directly from NTP tick length") the frequency and time errors should be
    much smaller. Reduce the maximum acceptable values for the test to pass
    to 0.02 ppm and 50 nanoseconds respectively.
    
    Signed-off-by: Miroslav Lichvar <mlichvar@redhat.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Stephen Boyd <stephen.boyd@linaro.org>
    Link: https://lkml.kernel.org/r/20190618160612.21957-1-mlichvar@redhat.com

commit 882f261874c9aa3792e37d631342e84c84766dd0
Merge: 5c4c8b4a9990 9e0babf2c06c
Author: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
Date:   Fri Jun 21 16:09:25 2019 -0400

    Merge tag 'v5.2-rc5' into patchwork
    
    Linux 5.2-rc5
    
    There are some media fixes on -rc5, so merge from it at media
    devel tree.
    
    * tag 'v5.2-rc5': (210 commits)
      Linux 5.2-rc5
      x86/microcode, cpuhotplug: Add a microcode loader CPU hotplug callback
      Smack: Restore the smackfsdef mount option and add missing prefixes
      ftrace: Fix NULL pointer dereference in free_ftrace_func_mapper()
      module: Fix livepatch/ftrace module text permissions race
      tracing/uprobe: Fix obsolete comment on trace_uprobe_create()
      tracing/uprobe: Fix NULL pointer dereference in trace_uprobe_create()
      tracing: Make two symbols static
      tracing: avoid build warning with HAVE_NOP_MCOUNT
      tracing: Fix out-of-range read in trace_stack_print()
      gfs2: Fix rounding error in gfs2_iomap_page_prepare
      x86/kasan: Fix boot with 5-level paging and KASAN
      timekeeping: Repair ktime_get_coarse*() granularity
      Revert "ALSA: hda/realtek - Improve the headset mic for Acer Aspire laptops"
      mm/devm_memremap_pages: fix final page put race
      PCI/P2PDMA: track pgmap references per resource, not globally
      lib/genalloc: introduce chunk owners
      PCI/P2PDMA: fix the gen_pool_add_virt() failure path
      mm/devm_memremap_pages: introduce devm_memunmap_pages
      drivers/base/devres: introduce devm_release_action()
      ...

commit ca4c34037bb9b96263f3cf6043079e15e46a25b1
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Jun 13 21:40:45 2019 +0200

    timekeeping: Repair ktime_get_coarse*() granularity
    
    commit e3ff9c3678b4d80e22d2557b68726174578eaf52 upstream.
    
    Jason reported that the coarse ktime based time getters advance only once
    per second and not once per tick as advertised.
    
    The code reads only the monotonic base time, which advances once per
    second. The nanoseconds are accumulated on every tick in xtime_nsec up to
    a second and the regular time getters take this nanoseconds offset into
    account, but the ktime_get_coarse*() implementation fails to do so.
    
    Add the accumulated xtime_nsec value to the monotonic base time to get the
    proper per tick advancing coarse tinme.
    
    Fixes: b9ff604cff11 ("timekeeping: Add ktime_get_coarse_with_offset")
    Reported-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Clemens Ladisch <clemens@ladisch.de>
    Cc: Sultan Alsawaf <sultan@kerneltoast.com>
    Cc: Waiman Long <longman@redhat.com>
    Cc: stable@vger.kernel.org
    Link: https://lkml.kernel.org/r/alpine.DEB.2.21.1906132136280.1791@nanos.tec.linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 53903d9eadad80f669a2405dfb18d5afb06679f5
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Jun 13 21:40:45 2019 +0200

    timekeeping: Repair ktime_get_coarse*() granularity
    
    commit e3ff9c3678b4d80e22d2557b68726174578eaf52 upstream.
    
    Jason reported that the coarse ktime based time getters advance only once
    per second and not once per tick as advertised.
    
    The code reads only the monotonic base time, which advances once per
    second. The nanoseconds are accumulated on every tick in xtime_nsec up to
    a second and the regular time getters take this nanoseconds offset into
    account, but the ktime_get_coarse*() implementation fails to do so.
    
    Add the accumulated xtime_nsec value to the monotonic base time to get the
    proper per tick advancing coarse tinme.
    
    Fixes: b9ff604cff11 ("timekeeping: Add ktime_get_coarse_with_offset")
    Reported-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Clemens Ladisch <clemens@ladisch.de>
    Cc: Sultan Alsawaf <sultan@kerneltoast.com>
    Cc: Waiman Long <longman@redhat.com>
    Cc: stable@vger.kernel.org
    Link: https://lkml.kernel.org/r/alpine.DEB.2.21.1906132136280.1791@nanos.tec.linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit efba92d58fa37d714d665deddb5cc6458b39bb88
Merge: f763cf8e47d3 e3ff9c3678b4
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Jun 16 07:22:56 2019 -1000

    Merge branch 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer fixes from Thomas Gleixner:
     "A set of small fixes:
    
       - Repair the ktime_get_coarse() functions so they actually deliver
         what they are supposed to: tick granular time stamps. The current
         code missed to add the accumulated nanoseconds part of the
         timekeeper so the resulting granularity was 1 second.
    
       - Prevent the tracer from infinitely recursing into time getter
         functions in the arm architectured timer by marking these functions
         notrace
    
       - Fix a trivial compiler warning caused by wrong qualifier ordering"
    
    * 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      timekeeping: Repair ktime_get_coarse*() granularity
      clocksource/drivers/arm_arch_timer: Don't trace count reader functions
      clocksource/drivers/timer-ti-dm: Change to new style declaration

commit e3ff9c3678b4d80e22d2557b68726174578eaf52
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Jun 13 21:40:45 2019 +0200

    timekeeping: Repair ktime_get_coarse*() granularity
    
    Jason reported that the coarse ktime based time getters advance only once
    per second and not once per tick as advertised.
    
    The code reads only the monotonic base time, which advances once per
    second. The nanoseconds are accumulated on every tick in xtime_nsec up to
    a second and the regular time getters take this nanoseconds offset into
    account, but the ktime_get_coarse*() implementation fails to do so.
    
    Add the accumulated xtime_nsec value to the monotonic base time to get the
    proper per tick advancing coarse tinme.
    
    Fixes: b9ff604cff11 ("timekeeping: Add ktime_get_coarse_with_offset")
    Reported-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Clemens Ladisch <clemens@ladisch.de>
    Cc: Sultan Alsawaf <sultan@kerneltoast.com>
    Cc: Waiman Long <longman@redhat.com>
    Cc: stable@vger.kernel.org
    Link: https://lkml.kernel.org/r/alpine.DEB.2.21.1906132136280.1791@nanos.tec.linutronix.de

commit 869ee58b82680dae6e0b1d4b37e8c36561b2d2d6
Author: Mathieu Malaterre <malat@debian.org>
Date:   Wed May 29 10:04:34 2019 +0200

    kbuild: Remove -Waggregate-return from scripts/Makefile.extrawarn
    
    It makes little sense to pass -Waggregate-return these days since large
    part of the linux kernel rely on returning struct(s). For instance:
    
      ../include/linux/timekeeping.h: In function 'show_uptime':
      ../include/linux/ktime.h:91:34: error: function call has aggregate value [-Werror=aggregate-return]
       #define ktime_to_timespec64(kt)  ns_to_timespec64((kt))
                                        ^~~~~~~~~~~~~~~~~~~~~~
      ../include/linux/timekeeping.h:166:8: note: in expansion of macro 'ktime_to_timespec64'
        *ts = ktime_to_timespec64(ktime_get_coarse_boottime());
    
    Remove this warning from W=2 completely.
    
    Signed-off-by: Mathieu Malaterre <malat@debian.org>
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

commit e0cef9ff6315d48a4dfd39da09ca770e242f9cb5
Author: Aurelien Thierry <aurelien.thierry@quoscient.io>
Date:   Fri Jun 7 10:07:02 2019 +0200

    Documentation: fix typo CLOCK_MONONOTNIC_COARSE
    
    Fix typo in documentation file timekeeping.rst: CLOCK_MONONOTNIC_COARSE
    should be CLOCK_MONOTONIC_COARSE.
    
    Signed-off-by: Aurelien Thierry <aurelien.thierry@quoscient.io>
    Signed-off-by: Jonathan Corbet <corbet@lwn.net>

commit e867110a9a3241196613816d5bfd4688ebac15bb
Author: Hans Verkuil <hverkuil-cisco@xs4all.nl>
Date:   Thu May 30 02:45:48 2019 -0400

    media: dvb-usb/cxusb-analog.c: fix coccinelle warning, use ktime.h
    
    This patch fixes a coccinelle warning and includes ktime.h instead of
    timekeeping.h. The first includes the latter, but the latter doesn't
    exist before 3.17, causing problems for our compat build. It's easier
    to just use ktime.h instead.
    
    coccinelle warnings: (new ones prefixed by >>)
    
    >> drivers/media/usb/dvb-usb/cxusb-analog.c:1498:41-42: WARNING: Use ARRAY_SIZE
    
    Signed-off-by: Hans Verkuil <hverkuil-cisco@xs4all.nl>
    Reported-by: kbuild test robot <lkp@intel.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

commit dc0f37b780e97d45c580a7141f6ac06b1ea5ba07
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Mar 23 11:36:19 2019 +0100

    timekeeping: Force upper bound for setting CLOCK_REALTIME
    
    [ Upstream commit 7a8e61f8478639072d402a26789055a4a4de8f77 ]
    
    Several people reported testing failures after setting CLOCK_REALTIME close
    to the limits of the kernel internal representation in nanoseconds,
    i.e. year 2262.
    
    The failures are exposed in subsequent operations, i.e. when arming timers
    or when the advancing CLOCK_MONOTONIC makes the calculation of
    CLOCK_REALTIME overflow into negative space.
    
    Now people start to paper over the underlying problem by clamping
    calculations to the valid range, but that's just wrong because such
    workarounds will prevent detection of real issues as well.
    
    It is reasonable to force an upper bound for the various methods of setting
    CLOCK_REALTIME. Year 2262 is the absolute upper bound. Assume a maximum
    uptime of 30 years which is plenty enough even for esoteric embedded
    systems. That results in an upper bound of year 2232 for setting the time.
    
    Once that limit is reached in reality this limit is only a small part of
    the problem space. But until then this stops people from trying to paper
    over the problem at the wrong places.
    
    Reported-by: Xiongfeng Wang <wangxiongfeng2@huawei.com>
    Reported-by: Hongbo Yao <yaohongbo@huawei.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Stephen Boyd <sboyd@kernel.org>
    Cc: Miroslav Lichvar <mlichvar@redhat.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: https://lkml.kernel.org/r/alpine.DEB.2.21.1903231125480.2157@nanos.tec.linutronix.de
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit faa3f27911352ab2c23e5c8e0fb0801b8e4dd092
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Mar 23 11:36:19 2019 +0100

    timekeeping: Force upper bound for setting CLOCK_REALTIME
    
    [ Upstream commit 7a8e61f8478639072d402a26789055a4a4de8f77 ]
    
    Several people reported testing failures after setting CLOCK_REALTIME close
    to the limits of the kernel internal representation in nanoseconds,
    i.e. year 2262.
    
    The failures are exposed in subsequent operations, i.e. when arming timers
    or when the advancing CLOCK_MONOTONIC makes the calculation of
    CLOCK_REALTIME overflow into negative space.
    
    Now people start to paper over the underlying problem by clamping
    calculations to the valid range, but that's just wrong because such
    workarounds will prevent detection of real issues as well.
    
    It is reasonable to force an upper bound for the various methods of setting
    CLOCK_REALTIME. Year 2262 is the absolute upper bound. Assume a maximum
    uptime of 30 years which is plenty enough even for esoteric embedded
    systems. That results in an upper bound of year 2232 for setting the time.
    
    Once that limit is reached in reality this limit is only a small part of
    the problem space. But until then this stops people from trying to paper
    over the problem at the wrong places.
    
    Reported-by: Xiongfeng Wang <wangxiongfeng2@huawei.com>
    Reported-by: Hongbo Yao <yaohongbo@huawei.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Stephen Boyd <sboyd@kernel.org>
    Cc: Miroslav Lichvar <mlichvar@redhat.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: https://lkml.kernel.org/r/alpine.DEB.2.21.1903231125480.2157@nanos.tec.linutronix.de
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 5e04fcbab4b417ac1110ec917f653d7eb38fd056
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Mar 23 11:36:19 2019 +0100

    timekeeping: Force upper bound for setting CLOCK_REALTIME
    
    [ Upstream commit 7a8e61f8478639072d402a26789055a4a4de8f77 ]
    
    Several people reported testing failures after setting CLOCK_REALTIME close
    to the limits of the kernel internal representation in nanoseconds,
    i.e. year 2262.
    
    The failures are exposed in subsequent operations, i.e. when arming timers
    or when the advancing CLOCK_MONOTONIC makes the calculation of
    CLOCK_REALTIME overflow into negative space.
    
    Now people start to paper over the underlying problem by clamping
    calculations to the valid range, but that's just wrong because such
    workarounds will prevent detection of real issues as well.
    
    It is reasonable to force an upper bound for the various methods of setting
    CLOCK_REALTIME. Year 2262 is the absolute upper bound. Assume a maximum
    uptime of 30 years which is plenty enough even for esoteric embedded
    systems. That results in an upper bound of year 2232 for setting the time.
    
    Once that limit is reached in reality this limit is only a small part of
    the problem space. But until then this stops people from trying to paper
    over the problem at the wrong places.
    
    Reported-by: Xiongfeng Wang <wangxiongfeng2@huawei.com>
    Reported-by: Hongbo Yao <yaohongbo@huawei.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Stephen Boyd <sboyd@kernel.org>
    Cc: Miroslav Lichvar <mlichvar@redhat.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: https://lkml.kernel.org/r/alpine.DEB.2.21.1903231125480.2157@nanos.tec.linutronix.de
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 02aff8db6438ce29371fd9cd54c57213f4bb4536
Merge: f72dae20891d 70c4cf17e445
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue May 7 19:06:04 2019 -0700

    Merge tag 'audit-pr-20190507' of git://git.kernel.org/pub/scm/linux/kernel/git/pcmoore/audit
    
    Pull audit updates from Paul Moore:
     "We've got a reasonably broad set of audit patches for the v5.2 merge
      window, the highlights are below:
    
       - The biggest change, and the source of all the arch/* changes, is
         the patchset from Dmitry to help enable some of the work he is
         doing around PTRACE_GET_SYSCALL_INFO.
    
         To be honest, including this in the audit tree is a bit of a
         stretch, but it does help move audit a little further along towards
         proper syscall auditing for all arches, and everyone else seemed to
         agree that audit was a "good" spot for this to land (or maybe they
         just didn't want to merge it? dunno.).
    
       - We can now audit time/NTP adjustments.
    
       - We continue the work to connect associated audit records into a
         single event"
    
    * tag 'audit-pr-20190507' of git://git.kernel.org/pub/scm/linux/kernel/git/pcmoore/audit: (21 commits)
      audit: fix a memory leak bug
      ntp: Audit NTP parameters adjustment
      timekeeping: Audit clock adjustments
      audit: purge unnecessary list_empty calls
      audit: link integrity evm_write_xattrs record to syscall event
      syscall_get_arch: add "struct task_struct *" argument
      unicore32: define syscall_get_arch()
      Move EM_UNICORE to uapi/linux/elf-em.h
      nios2: define syscall_get_arch()
      nds32: define syscall_get_arch()
      Move EM_NDS32 to uapi/linux/elf-em.h
      m68k: define syscall_get_arch()
      hexagon: define syscall_get_arch()
      Move EM_HEXAGON to uapi/linux/elf-em.h
      h8300: define syscall_get_arch()
      c6x: define syscall_get_arch()
      arc: define syscall_get_arch()
      Move EM_ARCOMPACT and EM_ARCV2 to uapi/linux/elf-em.h
      audit: Make audit_log_cap and audit_copy_inode static
      audit: connect LOGIN record to its syscall record
      ...

commit ccbc2e5ed192ccd2663477107379f843d072e649
Merge: fdafe5d1ffe8 fdd20ec8786a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon May 6 16:39:31 2019 -0700

    Merge tag 'm68k-for-v5.2-tag1' of git://git.kernel.org/pub/scm/linux/kernel/git/geert/linux-m68k
    
    Pull m68k updates from Geert Uytterhoeven:
    
     - drop arch_gettimeoffset and adopt clocksource API
    
     - defconfig updates
    
    * tag 'm68k-for-v5.2-tag1' of git://git.kernel.org/pub/scm/linux/kernel/git/geert/linux-m68k:
      Documentation/features/time: Mark m68k having modern-timekeeping
      m68k: defconfig: Update defconfigs for v5.1-rc1
      m68k: mvme16x: Handle timer counter overflow
      m68k: mvme16x: Convert to clocksource API
      m68k: mvme147: Handle timer counter overflow
      m68k: mvme147: Convert to clocksource API
      m68k: mac: Convert to clocksource API
      m68k: hp300: Handle timer counter overflow
      m68k: hp300: Convert to clocksource API
      m68k: bvme6000: Convert to clocksource API
      m68k: atari: Convert to clocksource API
      m68k: amiga: Convert to clocksource API
      m68k: Drop ARCH_USES_GETTIMEOFFSET
      m68k: apollo, q40, sun3, sun3x: Remove arch_gettimeoffset implementations
      m68k: mac: Fix VIA timer counter accesses
      m68k: Call timer_interrupt() with interrupts disabled

commit a0e928ed7c603a47dca8643e58db224a799ff2c5
Merge: 5a2bf1abbf96 13e792a19d4e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon May 6 14:50:46 2019 -0700

    Merge branch 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer updates from Ingo Molnar:
     "This cycle had the following changes:
    
       - Timer tracing improvements (Anna-Maria Gleixner)
    
       - Continued tasklet reduction work: remove the hrtimer_tasklet
         (Thomas Gleixner)
    
       - Fix CPU hotplug remove race in the tick-broadcast mask handling
         code (Thomas Gleixner)
    
       - Force upper bound for setting CLOCK_REALTIME, to fix ABI
         inconsistencies with handling values that are close to the maximum
         supported and the vagueness of when uptime related wraparound might
         occur. Make the consistent maximum the year 2232 across all
         relevant ABIs and APIs. (Thomas Gleixner)
    
       - various cleanups and smaller fixes"
    
    * 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      tick: Fix typos in comments
      tick/broadcast: Fix warning about undefined tick_broadcast_oneshot_offline()
      timekeeping: Force upper bound for setting CLOCK_REALTIME
      timer/trace: Improve timer tracing
      timer/trace: Replace deprecated vsprintf pointer extension %pf by %ps
      timer: Move trace point to get proper index
      tick/sched: Update tick_sched struct documentation
      tick: Remove outgoing CPU from broadcast masks
      timekeeping: Consistently use unsigned int for seqcount snapshot
      softirq: Remove tasklet_hrtimer
      xfrm: Replace hrtimer tasklet with softirq hrtimer
      mac80211_hwsim: Replace hrtimer tasklet with softirq hrtimer

commit fdd20ec8786ab2950439c7e78871618f7e51f18b
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Mon May 6 10:46:41 2019 +0200

    Documentation/features/time: Mark m68k having modern-timekeeping
    
    M68k no longer uses arch_gettimeoffset.
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

commit 451fd88f62b9e1a684d6e6503425ee0610d755a0
Author: Chang-An Chen <chang-an.chen@mediatek.com>
Date:   Fri Mar 29 10:59:09 2019 +0800

    timers/sched_clock: Prevent generic sched_clock wrap caused by tick_freeze()
    
    commit 3f2552f7e9c5abef2775c53f7af66532f8bf65bc upstream.
    
    tick_freeze() introduced by suspend-to-idle in commit 124cf9117c5f ("PM /
    sleep: Make it possible to quiesce timers during suspend-to-idle") uses
    timekeeping_suspend() instead of syscore_suspend() during
    suspend-to-idle. As a consequence generic sched_clock will keep going
    because sched_clock_suspend() and sched_clock_resume() are not invoked
    during suspend-to-idle which can result in a generic sched_clock wrap.
    
    On a ARM system with suspend-to-idle enabled, sched_clock is registered
    as "56 bits at 13MHz, resolution 76ns, wraps every 4398046511101ns", which
    means the real wrapping duration is 8796093022202ns.
    
    [  134.551779] suspend-to-idle suspend (timekeeping_suspend())
    [ 1204.912239] suspend-to-idle resume (timekeeping_resume())
    ......
    [ 1206.912239] suspend-to-idle suspend (timekeeping_suspend())
    [ 5880.502807] suspend-to-idle resume (timekeeping_resume())
    ......
    [ 6000.403724] suspend-to-idle suspend (timekeeping_suspend())
    [ 8035.753167] suspend-to-idle resume  (timekeeping_resume())
    ......
    [ 8795.786684] (2)[321:charger_thread]......
    [ 8795.788387] (2)[321:charger_thread]......
    [    0.057226] (0)[0:swapper/0]......
    [    0.061447] (2)[0:swapper/2]......
    
    sched_clock was not stopped during suspend-to-idle, and sched_clock_poll
    hrtimer was not expired because timekeeping_suspend() was invoked during
    suspend-to-idle. It makes sched_clock wrap at kernel time 8796s.
    
    To prevent this, invoke sched_clock_suspend() and sched_clock_resume() in
    tick_freeze() together with timekeeping_suspend() and timekeeping_resume().
    
    Fixes: 124cf9117c5f (PM / sleep: Make it possible to quiesce timers during suspend-to-idle)
    Signed-off-by: Chang-An Chen <chang-an.chen@mediatek.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Matthias Brugger <matthias.bgg@gmail.com>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: Corey Minyard <cminyard@mvista.com>
    Cc: <linux-mediatek@lists.infradead.org>
    Cc: <linux-arm-kernel@lists.infradead.org>
    Cc: Stanley Chu <stanley.chu@mediatek.com>
    Cc: <kuohong.wang@mediatek.com>
    Cc: <freddy.hsin@mediatek.com>
    Cc: stable@vger.kernel.org
    Link: https://lkml.kernel.org/r/1553828349-8914-1-git-send-email-chang-an.chen@mediatek.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit cd37fd46b4857a787571c3153bfa64d0ae28a407
Author: Chang-An Chen <chang-an.chen@mediatek.com>
Date:   Fri Mar 29 10:59:09 2019 +0800

    timers/sched_clock: Prevent generic sched_clock wrap caused by tick_freeze()
    
    commit 3f2552f7e9c5abef2775c53f7af66532f8bf65bc upstream.
    
    tick_freeze() introduced by suspend-to-idle in commit 124cf9117c5f ("PM /
    sleep: Make it possible to quiesce timers during suspend-to-idle") uses
    timekeeping_suspend() instead of syscore_suspend() during
    suspend-to-idle. As a consequence generic sched_clock will keep going
    because sched_clock_suspend() and sched_clock_resume() are not invoked
    during suspend-to-idle which can result in a generic sched_clock wrap.
    
    On a ARM system with suspend-to-idle enabled, sched_clock is registered
    as "56 bits at 13MHz, resolution 76ns, wraps every 4398046511101ns", which
    means the real wrapping duration is 8796093022202ns.
    
    [  134.551779] suspend-to-idle suspend (timekeeping_suspend())
    [ 1204.912239] suspend-to-idle resume (timekeeping_resume())
    ......
    [ 1206.912239] suspend-to-idle suspend (timekeeping_suspend())
    [ 5880.502807] suspend-to-idle resume (timekeeping_resume())
    ......
    [ 6000.403724] suspend-to-idle suspend (timekeeping_suspend())
    [ 8035.753167] suspend-to-idle resume  (timekeeping_resume())
    ......
    [ 8795.786684] (2)[321:charger_thread]......
    [ 8795.788387] (2)[321:charger_thread]......
    [    0.057226] (0)[0:swapper/0]......
    [    0.061447] (2)[0:swapper/2]......
    
    sched_clock was not stopped during suspend-to-idle, and sched_clock_poll
    hrtimer was not expired because timekeeping_suspend() was invoked during
    suspend-to-idle. It makes sched_clock wrap at kernel time 8796s.
    
    To prevent this, invoke sched_clock_suspend() and sched_clock_resume() in
    tick_freeze() together with timekeeping_suspend() and timekeeping_resume().
    
    Fixes: 124cf9117c5f (PM / sleep: Make it possible to quiesce timers during suspend-to-idle)
    Signed-off-by: Chang-An Chen <chang-an.chen@mediatek.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Matthias Brugger <matthias.bgg@gmail.com>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: Corey Minyard <cminyard@mvista.com>
    Cc: <linux-mediatek@lists.infradead.org>
    Cc: <linux-arm-kernel@lists.infradead.org>
    Cc: Stanley Chu <stanley.chu@mediatek.com>
    Cc: <kuohong.wang@mediatek.com>
    Cc: <freddy.hsin@mediatek.com>
    Cc: stable@vger.kernel.org
    Link: https://lkml.kernel.org/r/1553828349-8914-1-git-send-email-chang-an.chen@mediatek.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit d55535232c3dbde9a523a9d10d68670f5fe5dec3
Author: Kees Cook <keescook@chromium.org>
Date:   Fri Apr 19 23:27:05 2019 -0400

    random: move rand_initialize() earlier
    
    Right now rand_initialize() is run as an early_initcall(), but it only
    depends on timekeeping_init() (for mixing ktime_get_real() into the
    pools). However, the call to boot_init_stack_canary() for stack canary
    initialization runs earlier, which triggers a warning at boot:
    
    random: get_random_bytes called from start_kernel+0x357/0x548 with crng_init=0
    
    Instead, this moves rand_initialize() to after timekeeping_init(), and moves
    canary initialization here as well.
    
    Note that this warning may still remain for machines that do not have
    UEFI RNG support (which initializes the RNG pools during setup_arch()),
    or for x86 machines without RDRAND (or booting without "random.trust=on"
    or CONFIG_RANDOM_TRUST_CPU=y).
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>

commit 3f2552f7e9c5abef2775c53f7af66532f8bf65bc
Author: Chang-An Chen <chang-an.chen@mediatek.com>
Date:   Fri Mar 29 10:59:09 2019 +0800

    timers/sched_clock: Prevent generic sched_clock wrap caused by tick_freeze()
    
    tick_freeze() introduced by suspend-to-idle in commit 124cf9117c5f ("PM /
    sleep: Make it possible to quiesce timers during suspend-to-idle") uses
    timekeeping_suspend() instead of syscore_suspend() during
    suspend-to-idle. As a consequence generic sched_clock will keep going
    because sched_clock_suspend() and sched_clock_resume() are not invoked
    during suspend-to-idle which can result in a generic sched_clock wrap.
    
    On a ARM system with suspend-to-idle enabled, sched_clock is registered
    as "56 bits at 13MHz, resolution 76ns, wraps every 4398046511101ns", which
    means the real wrapping duration is 8796093022202ns.
    
    [  134.551779] suspend-to-idle suspend (timekeeping_suspend())
    [ 1204.912239] suspend-to-idle resume (timekeeping_resume())
    ......
    [ 1206.912239] suspend-to-idle suspend (timekeeping_suspend())
    [ 5880.502807] suspend-to-idle resume (timekeeping_resume())
    ......
    [ 6000.403724] suspend-to-idle suspend (timekeeping_suspend())
    [ 8035.753167] suspend-to-idle resume  (timekeeping_resume())
    ......
    [ 8795.786684] (2)[321:charger_thread]......
    [ 8795.788387] (2)[321:charger_thread]......
    [    0.057226] (0)[0:swapper/0]......
    [    0.061447] (2)[0:swapper/2]......
    
    sched_clock was not stopped during suspend-to-idle, and sched_clock_poll
    hrtimer was not expired because timekeeping_suspend() was invoked during
    suspend-to-idle. It makes sched_clock wrap at kernel time 8796s.
    
    To prevent this, invoke sched_clock_suspend() and sched_clock_resume() in
    tick_freeze() together with timekeeping_suspend() and timekeeping_resume().
    
    Fixes: 124cf9117c5f (PM / sleep: Make it possible to quiesce timers during suspend-to-idle)
    Signed-off-by: Chang-An Chen <chang-an.chen@mediatek.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Matthias Brugger <matthias.bgg@gmail.com>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: Corey Minyard <cminyard@mvista.com>
    Cc: <linux-mediatek@lists.infradead.org>
    Cc: <linux-arm-kernel@lists.infradead.org>
    Cc: Stanley Chu <stanley.chu@mediatek.com>
    Cc: <kuohong.wang@mediatek.com>
    Cc: <freddy.hsin@mediatek.com>
    Cc: stable@vger.kernel.org
    Link: https://lkml.kernel.org/r/1553828349-8914-1-git-send-email-chang-an.chen@mediatek.com

commit 7e8eda734d30de81d06a949c9bf9853c445ede4e
Author: Ondrej Mosnacek <omosnace@redhat.com>
Date:   Wed Apr 10 11:14:20 2019 +0200

    ntp: Audit NTP parameters adjustment
    
    Emit an audit record every time selected NTP parameters are modified
    from userspace (via adjtimex(2) or clock_adjtime(2)). These parameters
    may be used to indirectly change system clock, and thus their
    modifications should be audited.
    
    Such events will now generate records of type AUDIT_TIME_ADJNTPVAL
    containing the following fields:
      - op -- which value was adjusted:
        - offset -- corresponding to the time_offset variable
        - freq   -- corresponding to the time_freq variable
        - status -- corresponding to the time_status variable
        - adjust -- corresponding to the time_adjust variable
        - tick   -- corresponding to the tick_usec variable
        - tai    -- corresponding to the timekeeping's TAI offset
      - old -- the old value
      - new -- the new value
    
    Example records:
    
    type=TIME_ADJNTPVAL msg=audit(1530616044.507:7): op=status old=64 new=8256
    type=TIME_ADJNTPVAL msg=audit(1530616044.511:11): op=freq old=0 new=49180377088000
    
    The records of this type will be associated with the corresponding
    syscall records.
    
    An overview of parameter changes that can be done via do_adjtimex()
    (based on information from Miroslav Lichvar) and whether they are
    audited:
      __timekeeping_set_tai_offset() -- sets the offset from the
                                        International Atomic Time
                                        (AUDITED)
      NTP variables:
        time_offset -- can adjust the clock by up to 0.5 seconds per call
                       and also speed it up or slow down by up to about
                       0.05% (43 seconds per day) (AUDITED)
        time_freq -- can speed up or slow down by up to about 0.05%
                     (AUDITED)
        time_status -- can insert/delete leap seconds and it also enables/
                       disables synchronization of the hardware real-time
                       clock (AUDITED)
        time_maxerror, time_esterror -- change error estimates used to
                                        inform userspace applications
                                        (NOT AUDITED)
        time_constant -- controls the speed of the clock adjustments that
                         are made when time_offset is set (NOT AUDITED)
        time_adjust -- can temporarily speed up or slow down the clock by up
                       to 0.05% (AUDITED)
        tick_usec -- a more extreme version of time_freq; can speed up or
                     slow down the clock by up to 10% (AUDITED)
    
    Signed-off-by: Ondrej Mosnacek <omosnace@redhat.com>
    Reviewed-by: Richard Guy Briggs <rgb@redhat.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Paul Moore <paul@paul-moore.com>

commit 2d87a0674bd60d855e4008e2d84f5b23d7cb9b7d
Author: Ondrej Mosnacek <omosnace@redhat.com>
Date:   Wed Apr 10 11:14:19 2019 +0200

    timekeeping: Audit clock adjustments
    
    Emit an audit record whenever the system clock is changed (i.e. shifted
    by a non-zero offset) by a syscall from userspace. The syscalls than can
    (at the time of writing) trigger such record are:
      - settimeofday(2), stime(2), clock_settime(2) -- via
        do_settimeofday64()
      - adjtimex(2), clock_adjtime(2) -- via do_adjtimex()
    
    The new records have type AUDIT_TIME_INJOFFSET and contain the following
    fields:
      - sec -- the 'seconds' part of the offset
      - nsec -- the 'nanoseconds' part of the offset
    
    Example record (time was shifted backwards by ~15.875 seconds):
    
    type=TIME_INJOFFSET msg=audit(1530616049.652:13): sec=-16 nsec=124887145
    
    The records of this type will be associated with the corresponding
    syscall records.
    
    Signed-off-by: Ondrej Mosnacek <omosnace@redhat.com>
    Reviewed-by: Richard Guy Briggs <rgb@redhat.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    [PM: fixed a line width problem in __audit_tk_injoffset()]
    Signed-off-by: Paul Moore <paul@paul-moore.com>

commit 7a8e61f8478639072d402a26789055a4a4de8f77
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Mar 23 11:36:19 2019 +0100

    timekeeping: Force upper bound for setting CLOCK_REALTIME
    
    Several people reported testing failures after setting CLOCK_REALTIME close
    to the limits of the kernel internal representation in nanoseconds,
    i.e. year 2262.
    
    The failures are exposed in subsequent operations, i.e. when arming timers
    or when the advancing CLOCK_MONOTONIC makes the calculation of
    CLOCK_REALTIME overflow into negative space.
    
    Now people start to paper over the underlying problem by clamping
    calculations to the valid range, but that's just wrong because such
    workarounds will prevent detection of real issues as well.
    
    It is reasonable to force an upper bound for the various methods of setting
    CLOCK_REALTIME. Year 2262 is the absolute upper bound. Assume a maximum
    uptime of 30 years which is plenty enough even for esoteric embedded
    systems. That results in an upper bound of year 2232 for setting the time.
    
    Once that limit is reached in reality this limit is only a small part of
    the problem space. But until then this stops people from trying to paper
    over the problem at the wrong places.
    
    Reported-by: Xiongfeng Wang <wangxiongfeng2@huawei.com>
    Reported-by: Hongbo Yao <yaohongbo@huawei.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Stephen Boyd <sboyd@kernel.org>
    Cc: Miroslav Lichvar <mlichvar@redhat.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: https://lkml.kernel.org/r/alpine.DEB.2.21.1903231125480.2157@nanos.tec.linutronix.de

commit e1e41b6ce5f9c1a80bf4f2404ec5ab11c6c5a2ad
Author: Rasmus Villemoes <linux@rasmusvillemoes.dk>
Date:   Mon Mar 18 20:55:56 2019 +0100

    timekeeping: Consistently use unsigned int for seqcount snapshot
    
    The timekeeping code uses a random mix of "unsigned long" and "unsigned
    int" for the seqcount snapshots (ratio 14:12). Since the seqlock.h API is
    entirely based on unsigned int, use that throughout.
    
    Signed-off-by: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Stephen Boyd <sboyd@kernel.org>
    Link: https://lkml.kernel.org/r/20190318195557.20773-1-linux@rasmusvillemoes.dk

commit 18483190e7a2a6761b67c6824a31adf5b2b7be51
Merge: d9862cfbe209 8dd2eee2f444
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Mar 5 12:14:43 2019 -0800

    Merge branch 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer and clockevent updates from Thomas Gleixner:
     "The time(r) core and clockevent updates are mostly boring this time:
    
       - A new driver for the Tegra210 timer
    
       - Small fixes and improvements alll over the place
    
       - Documentation updates and cleanups"
    
    * 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (22 commits)
      soc/tegra: default select TEGRA_TIMER for Tegra210
      clocksource/drivers/tegra: Add Tegra210 timer support
      dt-bindings: timer: add Tegra210 timer
      clocksource/drivers/timer-cs5535: Rename the file for consistency
      clocksource/drivers/timer-pxa: Rename the file for consistency
      clocksource/drivers/tango-xtal: Rename the file for consistency
      dt-bindings: timer: gpt: update binding doc
      clocksource/drivers/exynos_mct: Remove unused header includes
      dt-bindings: timer: mediatek: update bindings for MT7629 SoC
      clocksource/drivers/exynos_mct: Fix error path in timer resources initialization
      clocksource/drivers/exynos_mct: Remove dead code
      clocksource/drivers/riscv: Add required checks during clock source init
      dt-bindings: timer: renesas: tmu: Document r8a774c0 bindings
      dt-bindings: timer: renesas, cmt: Document r8a774c0 CMT support
      clocksource/drivers/exynos_mct: Clear timer interrupt when shutdown
      clocksource/drivers/exynos_mct: Move one-shot check from tick clear to ISR
      clocksource/drivers/arch_timer: Workaround for Allwinner A64 timer instability
      clocksource/drivers/sun5i: Fail gracefully when clock rate is unavailable
      timers: Mark expected switch fall-throughs
      timekeeping/debug: No need to check return value of debugfs_create functions
      ...

commit eb9c64e728f262a62969cb0fa2f8fe4798cfe97b
Author: Bart Van Assche <bvanassche@acm.org>
Date:   Wed Nov 28 15:43:09 2018 -0800

    timekeeping: Use proper seqcount initializer
    
    [ Upstream commit ce10a5b3954f2514af726beb78ed8d7350c5e41c ]
    
    tk_core.seq is initialized open coded, but that misses to initialize the
    lockdep map when lockdep is enabled. Lockdep splats involving tk_core seq
    consequently lack a name and are hard to read.
    
    Use the proper initializer which takes care of the lockdep map
    initialization.
    
    [ tglx: Massaged changelog ]
    
    Signed-off-by: Bart Van Assche <bvanassche@acm.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: peterz@infradead.org
    Cc: tj@kernel.org
    Cc: johannes.berg@intel.com
    Link: https://lkml.kernel.org/r/20181128234325.110011-12-bvanassche@acm.org
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 1f28d7f2b3488af27904b8b44003dc3f5402921e
Author: Bart Van Assche <bvanassche@acm.org>
Date:   Wed Nov 28 15:43:09 2018 -0800

    timekeeping: Use proper seqcount initializer
    
    [ Upstream commit ce10a5b3954f2514af726beb78ed8d7350c5e41c ]
    
    tk_core.seq is initialized open coded, but that misses to initialize the
    lockdep map when lockdep is enabled. Lockdep splats involving tk_core seq
    consequently lack a name and are hard to read.
    
    Use the proper initializer which takes care of the lockdep map
    initialization.
    
    [ tglx: Massaged changelog ]
    
    Signed-off-by: Bart Van Assche <bvanassche@acm.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: peterz@infradead.org
    Cc: tj@kernel.org
    Cc: johannes.berg@intel.com
    Link: https://lkml.kernel.org/r/20181128234325.110011-12-bvanassche@acm.org
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 63f46c261b9f982c66fff5eb64db70dd5b05d657
Author: Bart Van Assche <bvanassche@acm.org>
Date:   Wed Nov 28 15:43:09 2018 -0800

    timekeeping: Use proper seqcount initializer
    
    [ Upstream commit ce10a5b3954f2514af726beb78ed8d7350c5e41c ]
    
    tk_core.seq is initialized open coded, but that misses to initialize the
    lockdep map when lockdep is enabled. Lockdep splats involving tk_core seq
    consequently lack a name and are hard to read.
    
    Use the proper initializer which takes care of the lockdep map
    initialization.
    
    [ tglx: Massaged changelog ]
    
    Signed-off-by: Bart Van Assche <bvanassche@acm.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: peterz@infradead.org
    Cc: tj@kernel.org
    Cc: johannes.berg@intel.com
    Link: https://lkml.kernel.org/r/20181128234325.110011-12-bvanassche@acm.org
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 0105d80dd157963febf91668511b89641393f486
Author: Bart Van Assche <bvanassche@acm.org>
Date:   Wed Nov 28 15:43:09 2018 -0800

    timekeeping: Use proper seqcount initializer
    
    [ Upstream commit ce10a5b3954f2514af726beb78ed8d7350c5e41c ]
    
    tk_core.seq is initialized open coded, but that misses to initialize the
    lockdep map when lockdep is enabled. Lockdep splats involving tk_core seq
    consequently lack a name and are hard to read.
    
    Use the proper initializer which takes care of the lockdep map
    initialization.
    
    [ tglx: Massaged changelog ]
    
    Signed-off-by: Bart Van Assche <bvanassche@acm.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: peterz@infradead.org
    Cc: tj@kernel.org
    Cc: johannes.berg@intel.com
    Link: https://lkml.kernel.org/r/20181128234325.110011-12-bvanassche@acm.org
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 923841f0d9860abcb5fb17c65b63f379f24318d5
Author: Bart Van Assche <bvanassche@acm.org>
Date:   Wed Nov 28 15:43:09 2018 -0800

    timekeeping: Use proper seqcount initializer
    
    [ Upstream commit ce10a5b3954f2514af726beb78ed8d7350c5e41c ]
    
    tk_core.seq is initialized open coded, but that misses to initialize the
    lockdep map when lockdep is enabled. Lockdep splats involving tk_core seq
    consequently lack a name and are hard to read.
    
    Use the proper initializer which takes care of the lockdep map
    initialization.
    
    [ tglx: Massaged changelog ]
    
    Signed-off-by: Bart Van Assche <bvanassche@acm.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: peterz@infradead.org
    Cc: tj@kernel.org
    Cc: johannes.berg@intel.com
    Link: https://lkml.kernel.org/r/20181128234325.110011-12-bvanassche@acm.org
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit b6fc5a5108b410d7cb1a160b40845c943427b7d2
Author: Bart Van Assche <bvanassche@acm.org>
Date:   Wed Nov 28 15:43:09 2018 -0800

    timekeeping: Use proper seqcount initializer
    
    [ Upstream commit ce10a5b3954f2514af726beb78ed8d7350c5e41c ]
    
    tk_core.seq is initialized open coded, but that misses to initialize the
    lockdep map when lockdep is enabled. Lockdep splats involving tk_core seq
    consequently lack a name and are hard to read.
    
    Use the proper initializer which takes care of the lockdep map
    initialization.
    
    [ tglx: Massaged changelog ]
    
    Signed-off-by: Bart Van Assche <bvanassche@acm.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: peterz@infradead.org
    Cc: tj@kernel.org
    Cc: johannes.berg@intel.com
    Link: https://lkml.kernel.org/r/20181128234325.110011-12-bvanassche@acm.org
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 4d5f007eedb74d71a7bde2bff69b6a31ad8ab427
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Jan 2 13:28:47 2019 +0100

    time: make adjtime compat handling available for 32 bit
    
    We want to reuse the compat_timex handling on 32-bit architectures the
    same way we are using the compat handling for timespec when moving to
    64-bit time_t.
    
    Move all definitions related to compat_timex out of the compat code
    into the normal timekeeping code, along with a rename to old_timex32,
    corresponding to the timespec/timeval structures, and make it controlled
    by CONFIG_COMPAT_32BIT_TIME, which 32-bit architectures will then select.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

commit c155f6499f9797f200aa46eb3ccbf198f4206970
Author: Vincent Guittot <vincent.guittot@linaro.org>
Date:   Mon Feb 4 17:25:52 2019 +0100

    PM-runtime: Switch accounting over to ktime_get_mono_fast_ns()
    
    Similar to what happened whith autosuspend, a deadlock has been
    reported with PM-runtime accounting in the call path:
    
    change_clocksource
        ...
        write_seqcount_begin
        ...
        timekeeping_update
            ...
            sh_cmt_clocksource_enable
                ...
                rpm_resume
                    update_pm_runtime_accounting
                        ktime_get
                            do
                                read_seqcount_begin
                            while read_seqcount_retry
        ....
        write_seqcount_end
    
    Make PM-runtime accounting use ktime_get_mono_fast_ns() to avoid this
    problem.
    
    With ktime_get_mono_fast_ns(), the timestamp is not guaranteed to be
    monotonic across an update of timekeeping and as a result time can go
    backward. Add a test to skip accounting for such situation which should
    stay exceptional.
    
    Fixes: a08c2a5a3194 ("PM-runtime: Replace jiffies-based accounting with ktime-based accounting")
    Reported-by: Biju Das <biju.das@bp.renesas.com>
    Signed-off-by: Vincent Guittot <vincent.guittot@linaro.org>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    [ rjw: Subject, changelog, comment cleanup ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 58456488e0e3793f2f95a3d2e2a78b6eba0ad0aa
Author: Vincent Guittot <vincent.guittot@linaro.org>
Date:   Wed Jan 23 08:50:13 2019 +0100

    PM-runtime: update accounting_timestamp on enable
    
    Initializing accounting_timestamp to something different from 0 during
    pm_runtime_init() doesn't make sense and puts an artificial ordering
    constraint between timekeeping_init() and pm_runtime_init().
    
    PM-runtime should start time accounting only when it is enabled and
    discard the period when disabled.
    
    Set accounting_timestamp to now when enabling PM-runtime.
    
    Suggested-by: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Signed-off-by: Vincent Guittot <vincent.guittot@linaro.org>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    [ rjw: Subject & changelog ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 15efb47dc560849d0c07db96fdad5121f2cf736e
Author: Vincent Guittot <vincent.guittot@linaro.org>
Date:   Wed Jan 30 18:26:02 2019 +0100

    PM-runtime: Fix deadlock with ktime_get()
    
    A deadlock has been seen when swicthing clocksources which use
    PM-runtime.  The call path is:
    
    change_clocksource
        ...
        write_seqcount_begin
        ...
        timekeeping_update
            ...
            sh_cmt_clocksource_enable
                ...
                rpm_resume
                    pm_runtime_mark_last_busy
                        ktime_get
                            do
                                read_seqcount_begin
                            while read_seqcount_retry
        ....
        write_seqcount_end
    
    Although we should be safe because we haven't yet changed the
    clocksource at that time, we can't do that because of seqcount
    protection.
    
    Use ktime_get_mono_fast_ns() instead which is lock safe for such
    cases.
    
    With ktime_get_mono_fast_ns, the timestamp is not guaranteed to be
    monotonic across an update and as a result can goes backward.
    According to update_fast_timekeeper() description: "In the worst
    case, this can result is a slightly wrong timestamp (a few
    nanoseconds)". For PM-runtime autosuspend, this means only that
    the suspend decision may be slightly suboptimal.
    
    Fixes: 8234f6734c5d ("PM-runtime: Switch autosuspend over to using hrtimers")
    Reported-by: Biju Das <biju.das@bp.renesas.com>
    Signed-off-by: Vincent Guittot <vincent.guittot@linaro.org>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit ae503ab04913794b12e1939caa75aa091062a1b3
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Jan 22 16:21:42 2019 +0100

    timekeeping/debug: No need to check return value of debugfs_create functions
    
    When calling debugfs functions, there is no need to ever check the return
    value.  The function can work or not, but the code logic should never do
    something different based on this.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Stephen Boyd <sboyd@kernel.org>
    Link: https://lkml.kernel.org/r/20190122152151.16139-43-gregkh@linuxfoundation.org

commit 093ae8f9a86a974c920b613860f1f7fd5bbd70ab
Author: Borislav Petkov <bp@suse.de>
Date:   Thu Apr 12 13:11:36 2018 +0200

    x86/TSC: Use RDTSCP
    
    Currently, the kernel uses
    
      [LM]FENCE; RDTSC
    
    in the timekeeping code, to guarantee monotonicity of time where the
    *FENCE is selected based on vendor.
    
    Replace that sequence with RDTSCP which is faster or on-par and gives
    the same guarantees.
    
    A microbenchmark on Intel shows that the change is on-par.
    
    On AMD, the change is either on-par with the current LFENCE-prefixed
    RDTSC or slightly better with RDTSCP.
    
    The comparison is done with the LFENCE-prefixed RDTSC (and not with the
    MFENCE-prefixed one, as one would normally expect) because all modern
    AMD families make LFENCE serializing and thus avoid the heavy MFENCE by
    effectively enabling X86_FEATURE_LFENCE_RDTSC.
    
    Co-developed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Cc: Tom Lendacky <thomas.lendacky@amd.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: x86@kernel.org
    Link: https://lkml.kernel.org/r/20181119184556.11479-1-bp@alien8.de

commit 8a5aaf97cc4876a9b61cb3b7c07128d4569ac536
Author: Guo Ren <guoren@kernel.org>
Date:   Fri Jan 4 11:17:33 2019 +0800

    Documentation/features: Add csky kernel features
    
          core/ cBPF-JIT             : TODO |
          core/ eBPF-JIT             : TODO |
          core/ generic-idle-thread  :  ok  |
          core/ jump-labels          : TODO |
          core/ tracehook            :  ok  |
         debug/ KASAN                : TODO |
         debug/ gcov-profile-all     : TODO |
         debug/ kgdb                 : TODO |
         debug/ kprobes-on-ftrace    : TODO |
         debug/ kprobes              : TODO |
         debug/ kretprobes           : TODO |
         debug/ optprobes            : TODO |
         debug/ stackprotector       : TODO |
         debug/ uprobes              : TODO |
         debug/ user-ret-profiler    : TODO |
            io/ dma-contiguous       :  ok  |
       locking/ cmpxchg-local        : TODO |
       locking/ lockdep              : TODO |
       locking/ queued-rwlocks       :  ok  |
       locking/ queued-spinlocks     : TODO |
       locking/ rwsem-optimized      : TODO |
          perf/ kprobes-event        : TODO |
          perf/ perf-regs            : TODO |
          perf/ perf-stackdump       : TODO |
         sched/ membarrier-sync-core : TODO |
         sched/ numa-balancing       :  ..  |
       seccomp/ seccomp-filter       : TODO |
          time/ arch-tick-broadcast  : TODO |
          time/ clockevents          :  ok  |
          time/ context-tracking     : TODO |
          time/ irq-time-acct        : TODO |
          time/ modern-timekeeping   :  ok  |
          time/ virt-cpuacct         : TODO |
            vm/ ELF-ASLR             : TODO |
            vm/ PG_uncached          : TODO |
            vm/ THP                  :  ..  |
            vm/ batch-unmap-tlb-flush: TODO |
            vm/ huge-vmap            : TODO |
            vm/ ioremap_prot         : TODO |
            vm/ numa-memblock        :  ..  |
            vm/ pte_special          : TODO |
    
    Signed-off-by: Guo Ren <ren_guo@c-sky.com>
    Cc: Arnd Bergmann <arnd@arndb.de>

commit b12a9124eeb71d766a3e3eb594ebbb3fefc66902
Merge: 1a80dade010c e4b92b108c6c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Dec 28 12:45:04 2018 -0800

    Merge tag 'y2038-for-4.21' of ssh://gitolite.kernel.org:/pub/scm/linux/kernel/git/arnd/playground
    
    Pull y2038 updates from Arnd Bergmann:
     "More syscalls and cleanups
    
      This concludes the main part of the system call rework for 64-bit
      time_t, which has spread over most of year 2018, the last six system
      calls being
    
        - ppoll
        - pselect6
        - io_pgetevents
        - recvmmsg
        - futex
        - rt_sigtimedwait
    
      As before, nothing changes for 64-bit architectures, while 32-bit
      architectures gain another entry point that differs only in the layout
      of the timespec structure. Hopefully in the next release we can wire
      up all 22 of those system calls on all 32-bit architectures, which
      gives us a baseline version for glibc to start using them.
    
      This does not include the clock_adjtime, getrusage/waitid, and
      getitimer/setitimer system calls. I still plan to have new versions of
      those as well, but they are not required for correct operation of the
      C library since they can be emulated using the old 32-bit time_t based
      system calls.
    
      Aside from the system calls, there are also a few cleanups here,
      removing old kernel internal interfaces that have become unused after
      all references got removed. The arch/sh cleanups are part of this,
      there were posted several times over the past year without a reaction
      from the maintainers, while the corresponding changes made it into all
      other architectures"
    
    * tag 'y2038-for-4.21' of ssh://gitolite.kernel.org:/pub/scm/linux/kernel/git/arnd/playground:
      timekeeping: remove obsolete time accessors
      vfs: replace current_kernel_time64 with ktime equivalent
      timekeeping: remove timespec_add/timespec_del
      timekeeping: remove unused {read,update}_persistent_clock
      sh: remove board_time_init() callback
      sh: remove unused rtc_sh_get/set_time infrastructure
      sh: sh03: rtc: push down rtc class ops into driver
      sh: dreamcast: rtc: push down rtc class ops into driver
      y2038: signal: Add compat_sys_rt_sigtimedwait_time64
      y2038: signal: Add sys_rt_sigtimedwait_time32
      y2038: socket: Add compat_sys_recvmmsg_time64
      y2038: futex: Add support for __kernel_timespec
      y2038: futex: Move compat implementation into futex.c
      io_pgetevents: use __kernel_timespec
      pselect6: use __kernel_timespec
      ppoll: use __kernel_timespec
      signal: Add restore_user_sigmask()
      signal: Add set_user_sigmask()

commit 54e4f73cbe03dd0634548e40d12c442d377c36c4
Author: Stephen Rothwell <sfr@canb.auug.org.au>
Date:   Mon Dec 17 20:11:46 2018 +1100

    cifs: update for current_kernel_time64() removal
    
    Fixes cifs build failure after merge of the y2038 tree
    
    After merging the y2038 tree, today's linux-next build (x86_64
    allmodconfig) failed like this:
    
    fs/cifs/dfs_cache.c: In function 'cache_entry_expired':
    fs/cifs/dfs_cache.c:106:7: error: implicit declaration of function 'current_kernel_time64'; did you mean 'core_kernel_text'? [-Werror=implicit-function-declaration]
      ts = current_kernel_time64();
           ^~~~~~~~~~~~~~~~~~~~~
           core_kernel_text
    fs/cifs/dfs_cache.c:106:5: error: incompatible types when assigning to type 'struct timespec64' from type 'int'
      ts = current_kernel_time64();
         ^
    fs/cifs/dfs_cache.c: In function 'get_expire_time':
    fs/cifs/dfs_cache.c:342:24: error: incompatible type for argument 1 of 'timespec64_add'
      return timespec64_add(current_kernel_time64(), ts);
                            ^~~~~~~~~~~~~~~~~~~~~~~
    In file included from include/linux/restart_block.h:10,
                     from include/linux/thread_info.h:13,
                     from arch/x86/include/asm/preempt.h:7,
                     from include/linux/preempt.h:78,
                     from include/linux/rcupdate.h:40,
                     from fs/cifs/dfs_cache.c:8:
    include/linux/time64.h:66:66: note: expected 'struct timespec64' but argument is of type 'int'
     static inline struct timespec64 timespec64_add(struct timespec64 lhs,
                                                    ~~~~~~~~~~~~~~~~~~^~~
    fs/cifs/dfs_cache.c:343:1: warning: control reaches end of non-void function [-Wreturn-type]
     }
     ^
    
    Caused by:
    
      commit ccea641b6742 ("timekeeping: remove obsolete time accessors")
    
    interacting with:
      commit 34a44fb160f9 ("cifs: Add DFS cache routines")
    
    from the cifs tree.
    
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Reviewed-by: Paulo Alcantara <palcantara@suse.de>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Steve French <stfrench@microsoft.com>

commit bc0750e464d41e1234f56471b8f626b8d945b1a8
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Thu Nov 15 14:32:02 2018 +0100

    clocksource/drivers/dbx500: Demote dbx500 PRCMU clocksource
    
    Demote the DBx500 PRCMU clocksource to quality 100 and
    mark it as NONSTOP so it will still be used for
    timekeeping across suspend/resume.
    
    The Nomadik MTU timer which has higher precision will
    be used when the system is up and running, thanks to
    the recent changes properly utilizing the suspend
    clocksources.
    
    This was discussed back in 2011 when the driver was
    written, but the infrastructure was not available
    upstream to use this timer properly. Now the
    infrastructure is there, so let's finalize the work.
    
    Cc: Baolin Wang <baolin.wang@linaro.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Reviewed-by: Baolin Wang <baolin.wang@linaro.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit e4b92b108c6cd6b311e4b6e85d6a87a34599a6e3
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Dec 7 13:45:54 2018 +0100

    timekeeping: remove obsolete time accessors
    
    There are no more remaining users of these deprecated wrappers, so
    let's remove them before new users have a chance to make it in.
    
    See Documentation/core-api/timekeeping.rst for replacements when
    porting old drivers that contain calls to this function.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: John Stultz <john.stultz@linaro.org>

commit d651d1607f22fd0cd249cb045627569f8028092b
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Dec 5 11:14:27 2018 +1100

    vfs: replace current_kernel_time64 with ktime equivalent
    
    current_time is the last remaining caller of current_kernel_time64(),
    which is a wrapper around ktime_get_coarse_real_ts64().  This calls the
    latter directly for consistency with the rest of the kernel that is moving
    to the ktime_get_ family of time accessors, as now documented in
    Documentation/core-api/timekeeping.rst.
    
    An open questions is whether we may want to actually call the more
    accurate ktime_get_real_ts64() for file systems that save high-resolution
    timestamps in their on-disk format.  This would add a small overhead to
    each update of the inode stamps but lead to inode timestamps to actually
    have a usable resolution better than one jiffy (1 to 10 milliseconds
    normally).  Experiments on a variety of hardware platforms show a typical
    time of around 100 CPU cycles to read the cycle counter and calculate the
    accurate time from that.  On old platforms without a cycle counter, this
    can be signiciantly higher, up to several microseconds to access a
    hardware clock, but those have become very rare by now.
    
    I traced the original addition of the current_kernel_time() call to set
    the nanosecond fields back to linux-2.5.48, where Andi Kleen added a patch
    with subject "nanosecond stat timefields".  Andi explains that the
    motivation was to introduce as little overhead as possible back then.  At
    this time, reading the clock hardware was also more expensive when most
    architectures did not have a cycle counter.
    
    One side effect of having more accurate inode timestamp would be having to
    write out the inode every time that mtime/ctime/atime get touched on most
    systems, whereas many file systems today only write it when the timestamps
    have changed, i.e.  at most once per jiffy unless something else changes
    as well.  That change would certainly be noticed in some workloads, which
    is enough reason to not do it without a good reason, regardless of the
    cost of reading the time.
    
    One thing we could still consider however would be to round the timestamps
    from current_time() to multiples of NSEC_PER_JIFFY, e.g.  full
    milliseconds rather than having six or seven meaningless but confusing
    digits at the end of the timestamp.
    
    Link: http://lkml.kernel.org/r/20180726130820.4174359-1-arnd@arndb.de
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

commit 437e78d3fd6d35e6d56230962e6d03bb5dcda7f6
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Dec 7 13:41:02 2018 +0100

    timekeeping: remove timespec_add/timespec_del
    
    The last users were removed a while ago since everyone moved to ktime_t,
    so we can remove the two unused interfaces for old timespec structures.
    
    With those two gone, set_normalized_timespec() is also unused, so
    remove that as well.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: John Stultz <john.stultz@linaro.org>

commit 926617889dc8383a120c66a2ecf7959a69f96950
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Aug 14 14:15:23 2018 +0200

    timekeeping: remove unused {read,update}_persistent_clock
    
    After arch/sh has removed the last reference to these functions,
    we can remove them completely and just rely on the 64-bit time_t
    based versions. This cleans up a rather ugly use of __weak
    functions.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: John Stultz <john.stultz@linaro.org>

commit 5b20c6fd6a60e182243da31c47f2ebff5b0e3d57
Author: Yangtao Li <tiny.windzz@gmail.com>
Date:   Tue Dec 11 11:37:44 2018 -0500

    timekeeping: Convert to DEFINE_SHOW_ATTRIBUTE
    
    Use DEFINE_SHOW_ATTRIBUTE macro to simplify the code.
    
    Signed-off-by: Yangtao Li <tiny.windzz@gmail.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: john.stultz@linaro.org
    Cc: sboyd@kernel.org
    Link: https://lkml.kernel.org/r/20181211163744.22133-1-tiny.windzz@gmail.com

commit ce10a5b3954f2514af726beb78ed8d7350c5e41c
Author: Bart Van Assche <bvanassche@acm.org>
Date:   Wed Nov 28 15:43:09 2018 -0800

    timekeeping: Use proper seqcount initializer
    
    tk_core.seq is initialized open coded, but that misses to initialize the
    lockdep map when lockdep is enabled. Lockdep splats involving tk_core seq
    consequently lack a name and are hard to read.
    
    Use the proper initializer which takes care of the lockdep map
    initialization.
    
    [ tglx: Massaged changelog ]
    
    Signed-off-by: Bart Van Assche <bvanassche@acm.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: peterz@infradead.org
    Cc: tj@kernel.org
    Cc: johannes.berg@intel.com
    Link: https://lkml.kernel.org/r/20181128234325.110011-12-bvanassche@acm.org

commit 35728b8209ee7d25b6241a56304ee926469bd154
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Oct 31 19:21:09 2018 +0100

    time: Add SPDX license identifiers
    
    Update the time(r) core files files with the correct SPDX license
    identifier based on the license text in the file itself. The SPDX
    identifier is a legally binding shorthand, which can be used instead of the
    full boiler plate text.
    
    This work is based on a script and data from Philippe Ombredanne, Kate
    Stewart and myself. The data has been created with two independent license
    scanners and manual inspection.
    
    The following files do not contain any direct license information and have
    been omitted from the big initial SPDX changes:
    
      timeconst.bc: The .bc files were not touched
      time.c, timer.c, timekeeping.c: Licence was deduced from EXPORT_SYMBOL_GPL
    
    As those files do not contain direct license references they fall under the
    project license, i.e. GPL V2 only.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Kees Cook <keescook@chromium.org>
    Acked-by: Ingo Molnar <mingo@kernel.org>
    Acked-by: John Stultz <john.stultz@linaro.org>
    Acked-by: Corey Minyard <cminyard@mvista.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Cc: Russell King <rmk+kernel@armlinux.org.uk>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Nicolas Pitre <nicolas.pitre@linaro.org>
    Cc: David Riley <davidriley@chromium.org>
    Cc: Colin Cross <ccross@android.com>
    Cc: Mark Brown <broonie@kernel.org>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Link: https://lkml.kernel.org/r/20181031182252.879109557@linutronix.de

commit 165ec328038dcd71fdf19b93f02cfeb367efd1f5
Author: Bart Van Assche <bvanassche@acm.org>
Date:   Wed Oct 17 13:24:56 2018 -0700

    ACPI / OSL: Use 'jiffies' as the time bassis for acpi_os_get_timer()
    
    commit 83b2348e2755db48fa8f40fdb791f366fabc0ba0 upstream.
    
    Since acpi_os_get_timer() may be called after the timer subsystem has
    been suspended, use the jiffies counter instead of ktime_get(). This
    patch avoids that the following warning is reported during hibernation:
    
    WARNING: CPU: 0 PID: 612 at kernel/time/timekeeping.c:751 ktime_get+0x116/0x120
    RIP: 0010:ktime_get+0x116/0x120
    Call Trace:
     acpi_os_get_timer+0xe/0x30
     acpi_ds_exec_begin_control_op+0x175/0x1de
     acpi_ds_exec_begin_op+0x2c7/0x39a
     acpi_ps_create_op+0x573/0x5e4
     acpi_ps_parse_loop+0x349/0x1220
     acpi_ps_parse_aml+0x25b/0x6da
     acpi_ps_execute_method+0x327/0x41b
     acpi_ns_evaluate+0x4e9/0x6f5
     acpi_ut_evaluate_object+0xd9/0x2f2
     acpi_rs_get_method_data+0x8f/0x114
     acpi_walk_resources+0x122/0x1b6
     acpi_pci_link_get_current.isra.2+0x157/0x280
     acpi_pci_link_set+0x32f/0x4a0
     irqrouter_resume+0x58/0x80
     syscore_resume+0x84/0x380
     hibernation_snapshot+0x20c/0x4f0
     hibernate+0x22d/0x3a6
     state_store+0x99/0xa0
     kobj_attr_store+0x37/0x50
     sysfs_kf_write+0x87/0xa0
     kernfs_fop_write+0x1a5/0x240
     __vfs_write+0xd2/0x410
     vfs_write+0x101/0x250
     ksys_write+0xab/0x120
     __x64_sys_write+0x43/0x50
     do_syscall_64+0x71/0x220
     entry_SYSCALL_64_after_hwframe+0x49/0xbe
    
    Fixes: 164a08cee135 (ACPICA: Dispatcher: Introduce timeout mechanism for infinite loop detection)
    Reported-by: Fengguang Wu <fengguang.wu@intel.com>
    References: https://lists.01.org/pipermail/lkp/2018-April/008406.html
    Signed-off-by: Bart Van Assche <bvanassche@acm.org>
    Cc: 4.16+ <stable@vger.kernel.org> # 4.16+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit a3b026a380b7f6f5e83b0ed246d2b28593ae92bc
Author: Bart Van Assche <bvanassche@acm.org>
Date:   Wed Oct 17 13:24:56 2018 -0700

    ACPI / OSL: Use 'jiffies' as the time bassis for acpi_os_get_timer()
    
    commit 83b2348e2755db48fa8f40fdb791f366fabc0ba0 upstream.
    
    Since acpi_os_get_timer() may be called after the timer subsystem has
    been suspended, use the jiffies counter instead of ktime_get(). This
    patch avoids that the following warning is reported during hibernation:
    
    WARNING: CPU: 0 PID: 612 at kernel/time/timekeeping.c:751 ktime_get+0x116/0x120
    RIP: 0010:ktime_get+0x116/0x120
    Call Trace:
     acpi_os_get_timer+0xe/0x30
     acpi_ds_exec_begin_control_op+0x175/0x1de
     acpi_ds_exec_begin_op+0x2c7/0x39a
     acpi_ps_create_op+0x573/0x5e4
     acpi_ps_parse_loop+0x349/0x1220
     acpi_ps_parse_aml+0x25b/0x6da
     acpi_ps_execute_method+0x327/0x41b
     acpi_ns_evaluate+0x4e9/0x6f5
     acpi_ut_evaluate_object+0xd9/0x2f2
     acpi_rs_get_method_data+0x8f/0x114
     acpi_walk_resources+0x122/0x1b6
     acpi_pci_link_get_current.isra.2+0x157/0x280
     acpi_pci_link_set+0x32f/0x4a0
     irqrouter_resume+0x58/0x80
     syscore_resume+0x84/0x380
     hibernation_snapshot+0x20c/0x4f0
     hibernate+0x22d/0x3a6
     state_store+0x99/0xa0
     kobj_attr_store+0x37/0x50
     sysfs_kf_write+0x87/0xa0
     kernfs_fop_write+0x1a5/0x240
     __vfs_write+0xd2/0x410
     vfs_write+0x101/0x250
     ksys_write+0xab/0x120
     __x64_sys_write+0x43/0x50
     do_syscall_64+0x71/0x220
     entry_SYSCALL_64_after_hwframe+0x49/0xbe
    
    Fixes: 164a08cee135 (ACPICA: Dispatcher: Introduce timeout mechanism for infinite loop detection)
    Reported-by: Fengguang Wu <fengguang.wu@intel.com>
    References: https://lists.01.org/pipermail/lkp/2018-April/008406.html
    Signed-off-by: Bart Van Assche <bvanassche@acm.org>
    Cc: 4.16+ <stable@vger.kernel.org> # 4.16+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 4dcb9239dad6cee17c538482619a5b659774ee51
Merge: 3acbd2de6bc3 d59e0ba19481
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Oct 25 11:14:36 2018 -0700

    Merge branch 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timekeeping updates from Thomas Gleixner:
     "The timers and timekeeping departement provides:
    
       - Another large y2038 update with further preparations for providing
         the y2038 safe timespecs closer to the syscalls.
    
       - An overhaul of the SHCMT clocksource driver
    
       - SPDX license identifier updates
    
       - Small cleanups and fixes all over the place"
    
    * 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (31 commits)
      tick/sched : Remove redundant cpu_online() check
      clocksource/drivers/dw_apb: Add reset control
      clocksource: Remove obsolete CLOCKSOURCE_OF_DECLARE
      clocksource/drivers: Unify the names to timer-* format
      clocksource/drivers/sh_cmt: Add R-Car gen3 support
      dt-bindings: timer: renesas: cmt: document R-Car gen3 support
      clocksource/drivers/sh_cmt: Properly line-wrap sh_cmt_of_table[] initializer
      clocksource/drivers/sh_cmt: Fix clocksource width for 32-bit machines
      clocksource/drivers/sh_cmt: Fixup for 64-bit machines
      clocksource/drivers/sh_tmu: Convert to SPDX identifiers
      clocksource/drivers/sh_mtu2: Convert to SPDX identifiers
      clocksource/drivers/sh_cmt: Convert to SPDX identifiers
      clocksource/drivers/renesas-ostm: Convert to SPDX identifiers
      clocksource: Convert to using %pOFn instead of device_node.name
      tick/broadcast: Remove redundant check
      RISC-V: Request newstat syscalls
      y2038: signal: Change rt_sigtimedwait to use __kernel_timespec
      y2038: socket: Change recvmmsg to use __kernel_timespec
      y2038: sched: Change sched_rr_get_interval to use __kernel_timespec
      y2038: utimes: Rework #ifdef guards for compat syscalls
      ...

commit 58a0228707870c8330917f919804986855443a19
Merge: 12dd08fa954f 0a1875ad29ef
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Oct 23 10:33:16 2018 +0100

    Merge tag 'acpi-4.20-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull ACPI updates from Rafael Wysocki:
     "These fix ACPICA issues related to the handling of module-level AML,
      fix an ordering issue during ACPI initialization, update ACPICA to
      upstream revision 20181003 (including fixes mostly), fix issues with
      system-wide suspend/resume related to the ACPI driver for Intel SoCs
      (LPSS), fix device enumeration issues on boards with Dollar Cove or
      Whiskey Cove Intel PMICs, prevent ACPICA from calling ktime_get() in
      unsuitable conditions, update a few drivers and clean up some code in
      several places.
    
      Specifics:
    
       - Fix ACPICA issues related to the handling of module-level AML and
         make the ACPI initialization code parse ECDT before loading the
         definition block tables (Erik Schmauss).
    
       - Update ACPICA to upstream revision 20181003 including fixes related
         to the ill-defined "generic serial bus" and the handling of the
         _REG object (Bob Moore).
    
       - Fix some issues with system-wide suspend/resume on Intel BYT/CHT
         related to the handling of I2C controllers in the ACPI LPSS driver
         for Intel SoCs (Hans de Goede).
    
       - Modify the ACPI namespace scanning code to enumerate INT33FE HID
         devices as platform devices with I2C resources to avoid device
         enumeration problems on boards with Dollar Cove or Whiskey Cove
         Intel PMICs (Hans de Goede).
    
       - Prevent ACPICA from using ktime_get() during early resume from
         system-wide suspend before resuming the timekeeping which generally
         is unsafe and triggers a warning from the timekeeping code (Bart
         Van Assche).
    
       - Add low-level real time clock support to the ACPI Time and Aalarm
         Device (TAD) driver (Rafael Wysocki).
    
       - Fix the ACPI SBS driver to avoid GPE storms on MacBook Pro and
         Oopses when removing modules (Ronald Tschalär).
    
       - Fix the ACPI PPTT parsing code to handle architecturally unknown
         cache types properly (Jeffrey Hugo).
    
       - Fix initialization issue in the ACPI processor driver (Dou Liyang).
    
       - Clean up the code in several places (Andy Shevchenko, Bartlomiej
         Zolnierkiewicz, David Arcari, zhong jiang)"
    
    * tag 'acpi-4.20-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (33 commits)
      ACPI / scan: Create platform device for INT33FE ACPI nodes
      ACPI / OSL: Use 'jiffies' as the time bassis for acpi_os_get_timer()
      ACPI: probe ECDT before loading AML tables regardless of module-level code flag
      ACPICA: Remove acpi_gbl_group_module_level_code and only use acpi_gbl_execute_tables_as_methods instead
      ACPICA: AML Parser: fix parse loop to correctly skip erroneous extended opcodes
      ACPICA: AML interpreter: add region addresses in global list during initialization
      ACPI: TAD: Add low-level support for real time capability
      ACPI: remove redundant 'default n' from Kconfig
      ACPI / SBS: Fix rare oops when removing modules
      ACPI / SBS: Fix GPE storm on recent MacBookPro's
      ACPI/PPTT: Handle architecturally unknown cache types
      drivers: base: cacheinfo: Do not populate sysfs for unknown cache types
      ACPICA: Update version to 20181003
      ACPICA: Never run _REG on system_memory and system_IO
      ACPICA: Split large interpreter file
      ACPICA: Update for field unit access
      ACPICA: Rename some of the Field Attribute defines
      ACPICA: Update for generic_serial_bus and attrib_raw_process_bytes protocol
      ACPI / processor: Fix the return value of acpi_processor_ids_walk()
      ACPI / LPSS: Resume BYT/CHT I2C controllers from resume_noirq
      ...

commit 83b2348e2755db48fa8f40fdb791f366fabc0ba0
Author: Bart Van Assche <bvanassche@acm.org>
Date:   Wed Oct 17 13:24:56 2018 -0700

    ACPI / OSL: Use 'jiffies' as the time bassis for acpi_os_get_timer()
    
    Since acpi_os_get_timer() may be called after the timer subsystem has
    been suspended, use the jiffies counter instead of ktime_get(). This
    patch avoids that the following warning is reported during hibernation:
    
    WARNING: CPU: 0 PID: 612 at kernel/time/timekeeping.c:751 ktime_get+0x116/0x120
    RIP: 0010:ktime_get+0x116/0x120
    Call Trace:
     acpi_os_get_timer+0xe/0x30
     acpi_ds_exec_begin_control_op+0x175/0x1de
     acpi_ds_exec_begin_op+0x2c7/0x39a
     acpi_ps_create_op+0x573/0x5e4
     acpi_ps_parse_loop+0x349/0x1220
     acpi_ps_parse_aml+0x25b/0x6da
     acpi_ps_execute_method+0x327/0x41b
     acpi_ns_evaluate+0x4e9/0x6f5
     acpi_ut_evaluate_object+0xd9/0x2f2
     acpi_rs_get_method_data+0x8f/0x114
     acpi_walk_resources+0x122/0x1b6
     acpi_pci_link_get_current.isra.2+0x157/0x280
     acpi_pci_link_set+0x32f/0x4a0
     irqrouter_resume+0x58/0x80
     syscore_resume+0x84/0x380
     hibernation_snapshot+0x20c/0x4f0
     hibernate+0x22d/0x3a6
     state_store+0x99/0xa0
     kobj_attr_store+0x37/0x50
     sysfs_kf_write+0x87/0xa0
     kernfs_fop_write+0x1a5/0x240
     __vfs_write+0xd2/0x410
     vfs_write+0x101/0x250
     ksys_write+0xab/0x120
     __x64_sys_write+0x43/0x50
     do_syscall_64+0x71/0x220
     entry_SYSCALL_64_after_hwframe+0x49/0xbe
    
    Fixes: 164a08cee135 (ACPICA: Dispatcher: Introduce timeout mechanism for infinite loop detection)
    Reported-by: Fengguang Wu <fengguang.wu@intel.com>
    References: https://lists.01.org/pipermail/lkp/2018-April/008406.html
    Signed-off-by: Bart Van Assche <bvanassche@acm.org>
    Cc: 4.16+ <stable@vger.kernel.org> # 4.16+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 51d34e94c4701f125907c026272870790a37c4a1
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Wed Sep 5 10:41:58 2018 +0200

    clocksource: Revert "Remove kthread"
    
    commit e2c631ba75a7e727e8db0a9d30a06bfd434adb3a upstream.
    
    I turns out that the silly spawn kthread from worker was actually needed.
    
    clocksource_watchdog_kthread() cannot be called directly from
    clocksource_watchdog_work(), because clocksource_select() calls
    timekeeping_notify() which uses stop_machine(). One cannot use
    stop_machine() from a workqueue() due lock inversions wrt CPU hotplug.
    
    Revert the patch but add a comment that explain why we jump through such
    apparently silly hoops.
    
    Fixes: 7197e77abcb6 ("clocksource: Remove kthread")
    Reported-by: Siegfried Metz <frame@mailbox.org>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Niklas Cassel <niklas.cassel@linaro.org>
    Tested-by: Kevin Shanahan <kevin@shanahan.id.au>
    Tested-by: viktor_jaegerskuepper@freenet.de
    Tested-by: Siegfried Metz <frame@mailbox.org>
    Cc: rafael.j.wysocki@intel.com
    Cc: len.brown@intel.com
    Cc: diego.viola@gmail.com
    Cc: rui.zhang@intel.com
    Cc: bjorn.andersson@linaro.org
    Link: https://lkml.kernel.org/r/20180905084158.GR24124@hirez.programming.kicks-ass.net
    Cc: Siegfried Metz <frame@mailbox.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 3567994a05ba6490f6055650fbb892c926ae7fca
Merge: 225ad3cfec4c e2c631ba75a7
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Sep 9 06:55:27 2018 -0700

    Merge branch 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timekeeping fixes from Thomas Gleixner:
     "Two fixes for timekeeping:
    
       - Revert to the previous kthread based update, which is unfortunately
         required due to lock ordering issues. The removal caused boot
         failures on old Core2 machines. Add a proper comment why the thread
         needs to stay to prevent accidental removal in the future.
    
       - Fix a silly typo in a function declaration"
    
    * 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      clocksource: Revert "Remove kthread"
      timekeeping: Fix declaration of read_persistent_wall_and_boot_offset()

commit e2c631ba75a7e727e8db0a9d30a06bfd434adb3a
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Wed Sep 5 10:41:58 2018 +0200

    clocksource: Revert "Remove kthread"
    
    I turns out that the silly spawn kthread from worker was actually needed.
    
    clocksource_watchdog_kthread() cannot be called directly from
    clocksource_watchdog_work(), because clocksource_select() calls
    timekeeping_notify() which uses stop_machine(). One cannot use
    stop_machine() from a workqueue() due lock inversions wrt CPU hotplug.
    
    Revert the patch but add a comment that explain why we jump through such
    apparently silly hoops.
    
    Fixes: 7197e77abcb6 ("clocksource: Remove kthread")
    Reported-by: Siegfried Metz <frame@mailbox.org>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Niklas Cassel <niklas.cassel@linaro.org>
    Tested-by: Kevin Shanahan <kevin@shanahan.id.au>
    Tested-by: viktor_jaegerskuepper@freenet.de
    Tested-by: Siegfried Metz <frame@mailbox.org>
    Cc: rafael.j.wysocki@intel.com
    Cc: len.brown@intel.com
    Cc: diego.viola@gmail.com
    Cc: rui.zhang@intel.com
    Cc: bjorn.andersson@linaro.org
    Link: https://lkml.kernel.org/r/20180905084158.GR24124@hirez.programming.kicks-ass.net

commit c43c5e9f524ec914e7e202f9c5ab91779629ccc6
Author: Christian Borntraeger <borntraeger@linux.ibm.com>
Date:   Mon Sep 3 10:15:33 2018 +0200

    timekeeping: Fix declaration of read_persistent_wall_and_boot_offset()
    
    It is read_persistent_wall_and_boot_offset() and not
    read_persistent_clock_and_boot_offset()
    
    Fixes: 3eca993740b8eb40f51 ("timekeeping: Replace read_boot_clock64() with read_persistent_wall_and_boot_offset()")
    Signed-off-by: Christian Borntraeger <borntraeger@de.ibm.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Pavel Tatashin <pasha.tatashin@oracle.com>
    Link: https://lkml.kernel.org/r/20180903081533.34366-1-borntraeger@de.ibm.com

commit 33e26418193f58d1895f2f968e1953b1caf8deb7
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Aug 14 15:18:20 2018 +0200

    y2038: make do_gettimeofday() and get_seconds() inline
    
    get_seconds() and do_gettimeofday() are only used by a few modules now any
    more (waiting for the respective patches to get accepted), and they are
    among the last holdouts of code that is not y2038 safe in the core kernel.
    
    Move the implementation into the timekeeping32.h header to clean up
    the core kernel and isolate the old interfaces further.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

commit 976516404ff3fab2a8caa8bd6f5efc1437fed0b8
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Aug 14 14:02:57 2018 +0200

    y2038: remove unused time interfaces
    
    After many small patches, at least some of the deprecated interfaces
    have no remaining users any more and can be removed:
    
      current_kernel_time
      do_settimeofday
      get_monotonic_boottime
      get_monotonic_boottime64
      get_monotonic_coarse
      get_monotonic_coarse64
      getrawmonotonic64
      ktime_get_real_ts
      timekeeping_clocktai
      timespec_trunc
      timespec_valid_strict
      time_to_tm
    
    For many of the remaining time functions, we are missing one or
    two patches that failed to make it into 4.19, they will be removed
    in the following merge window.
    
    The replacement functions for the removed interfaces are documented in
    Documentation/core-api/timekeeping.rst.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

commit 0b3e776e2e809b808875b10e35d1047c5c548da4
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Aug 15 19:49:49 2018 +0200

    net: lan743x_ptp: convert to ktime_get_clocktai_ts64
    
    timekeeping_clocktai64() has been renamed to ktime_get_clocktai_ts64()
    for consistency with the other ktime_get_* access functions.
    
    Rename the new caller that has come up as well.
    
    Question: this is the only ptp driver that sets the hardware time
    to the current system time in TAI. Why does it do that?
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 13e091b6dd0e78a518a7d8756607d3acb8215768
Merge: eac341194426 1088c6eef261
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Aug 13 18:28:19 2018 -0700

    Merge branch 'x86-timers-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull x86 timer updates from Thomas Gleixner:
     "Early TSC based time stamping to allow better boot time analysis.
    
      This comes with a general cleanup of the TSC calibration code which
      grew warts and duct taping over the years and removes 250 lines of
      code. Initiated and mostly implemented by Pavel with help from various
      folks"
    
    * 'x86-timers-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (37 commits)
      x86/kvmclock: Mark kvm_get_preset_lpj() as __init
      x86/tsc: Consolidate init code
      sched/clock: Disable interrupts when calling generic_sched_clock_init()
      timekeeping: Prevent false warning when persistent clock is not available
      sched/clock: Close a hole in sched_clock_init()
      x86/tsc: Make use of tsc_calibrate_cpu_early()
      x86/tsc: Split native_calibrate_cpu() into early and late parts
      sched/clock: Use static key for sched_clock_running
      sched/clock: Enable sched clock early
      sched/clock: Move sched clock initialization and merge with generic clock
      x86/tsc: Use TSC as sched clock early
      x86/tsc: Initialize cyc2ns when tsc frequency is determined
      x86/tsc: Calibrate tsc only once
      ARM/time: Remove read_boot_clock64()
      s390/time: Remove read_boot_clock64()
      timekeeping: Default boot time offset to local_clock()
      timekeeping: Replace read_boot_clock64() with read_persistent_wall_and_boot_offset()
      s390/time: Add read_persistent_wall_and_boot_offset()
      x86/xen/time: Output xen sched_clock time from 0
      x86/xen/time: Initialize pv xen time in init_hypervisor_platform()
      ...

commit 1e45e9a95ec277272f73439629b6e3fe1f047e92
Merge: 8603596a327c fbfa9260085b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Aug 13 13:02:31 2018 -0700

    Merge branch 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer updates from Thomas Gleixner:
     "The timers departement more or less proudly presents:
    
       - More Y2038 timekeeping work mostly in the core code. The work is
         slowly, but steadily targeting the actuall syscalls.
    
       - Enhanced timekeeping suspend/resume support by utilizing
         clocksources which do not stop during suspend, but are otherwise
         not the main timekeeping clocksources.
    
       - Make NTP adjustmets more accurate and immediate when the frequency
         is set directly and not incrementally.
    
       - Sanitize the overrung handing of posix timers
    
       - A new timer driver for Mediatek SoCs
    
       - The usual pile of fixes and updates all over the place"
    
    * 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (32 commits)
      clockevents: Warn if cpu_all_mask is used as cpumask
      tick/broadcast-hrtimer: Use cpu_possible_mask for ce_broadcast_hrtimer
      clocksource/drivers/arm_arch_timer: Fix bogus cpu_all_mask usage
      clocksource: ti-32k: Remove CLOCK_SOURCE_SUSPEND_NONSTOP flag
      timers: Clear timer_base::must_forward_clk with timer_base::lock held
      clocksource/drivers/sprd: Register one always-on timer to compensate suspend time
      clocksource/drivers/timer-mediatek: Add support for system timer
      clocksource/drivers/timer-mediatek: Convert the driver to timer-of
      clocksource/drivers/timer-mediatek: Use specific prefix for GPT
      clocksource/drivers/timer-mediatek: Rename mtk_timer to timer-mediatek
      clocksource/drivers/timer-mediatek: Add system timer bindings
      clocksource/drivers: Set clockevent device cpumask to cpu_possible_mask
      time: Introduce one suspend clocksource to compensate the suspend time
      time: Fix extra sleeptime injection when suspend fails
      timekeeping/ntp: Constify some function arguments
      ntp: Use kstrtos64 for s64 variable
      ntp: Remove redundant arguments
      timer: Fix coding style
      ktime: Provide typesafe ktime_to_ns()
      hrtimer: Improve kernel message printing
      ...

commit 684ad537abff987886d63fb3c573eeca40d7f2db
Author: Pavel Tatashin <pasha.tatashin@oracle.com>
Date:   Wed Jul 25 16:00:18 2018 -0400

    timekeeping: Prevent false warning when persistent clock is not available
    
    On arches with no persistent clock a message like this is printed during
    boot:
    
    [    0.000000] Persistent clock returned invalid value
    
    The value is not invalid: Zero means that no persistent clock is available
    and the absence of persistent clock should be quietly accepted.
    
    Fixes: 3eca993740b8 ("timekeeping: Replace read_boot_clock64() with read_persistent_wall_and_boot_offset()")
    Signed-off-by: Pavel Tatashin <pasha.tatashin@oracle.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: steven.sistare@oracle.com
    Cc: daniel.m.jordan@oracle.com
    Cc: sboyd@kernel.org
    Cc: john.stultz@linaro.org
    Link: https://lkml.kernel.org/r/20180725200018.23722-1-pasha.tatashin@oracle.com

commit b2d94b3ff0638441460ce1fb23258cbd3374fd8e
Author: Baolin Wang <baolin.wang@linux.alibaba.com>
Date:   Mon Jul 23 14:10:20 2018 +0800

    arm64: dts: sprd: Add one suspend timer
    
    On Spreadtrum platform, the current clocksource for timekeeping will be
    stopped in suspend state, thus add one always-on timer to calculate the
    suspend time.
    
    Signed-off-by: Baolin Wang <baolin.wang@linaro.org>
    Signed-off-by: Olof Johansson <olof@lixom.net>

commit 9e7c758ec4768cf47779dea3cc8452f871f8d07e
Author: Siddaraju DH <siddarajudh@gmail.com>
Date:   Thu Jul 19 22:06:51 2018 +0530

    timekeeping.txt: Correct maxCount of n-bit binary counter
    
    A n-bit binary counter can count a maximum of 2^n events and the count
    value ranges from 0 to (2^n)-1
    
    Signed-off-by: Siddaraju DH <siddarajudh@gmail.com>
    Signed-off-by: Jonathan Corbet <corbet@lwn.net>

commit 0e3fd810c4f41dbd63fb7caddc11684959176727
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Jul 10 16:46:41 2018 +0200

    Documentation: document ktime_get_*() APIs
    
    As Dave Chinner points out, we don't have a proper documentation for the
    ktime_get() family of interfaces, making it rather unclear which of the
    over 30 (!) interfaces one should actually use in a driver or elsewhere
    in the kernel.
    
    I wrote up an explanation from how I personally see the interfaces,
    documenting what each of the functions do and hopefully making it a bit
    clearer which should be used where.
    
    This is the first time I tried writing .rst format documentation, so
    in addition to any mistakes in the content, I probably also introduce
    nonstandard formatting ;-)
    
    I first tried to add an extra section to
    Documentation/timers/timekeeping.txt, but this is currently not included
    in the generated API, and it seems useful to have the API docs as part
    of what gets generated in
    https://www.kernel.org/doc/html/latest/core-api/index.html#core-utilities
    instead, so I started a new file there.
    
    I also considered adding the documentation inline in the
    include/linux/timekeeping.h header, but couldn't figure out how to do
    that in a way that would result both in helpful inline comments as
    well as readable html output, so I settled for the latter, with
    a small note pointing to it from the header.
    
    Cc: Dave Chinner <david@fromorbit.com>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Stephen Boyd <sboyd@kernel.org>
    Tested-by: Randy Dunlap <rdunlap@infradead.org>
    Reviewed-by: Randy Dunlap <rdunlap@infradead.org>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Jonathan Corbet <corbet@lwn.net>

commit e5af5ff34cf037ac7bb70976161427dc40bf4a96
Merge: 30587589251a 39232ed5a179
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Jul 20 06:43:05 2018 +0200

    Merge tag 'fortglx/4.19/time-part2' of https://git.linaro.org/people/john.stultz/linux into timers/core
    
    Pull the second set of timekeeping things for 4.19 from John Stultz
    
      * NTP argument clenaups and constification from Ondrej Mosnacek
      * Fix to avoid RTC injecting sleeptime when suspend fails from
        Mukesh Ojha
      * Broading suspsend-timing to include non-stop clocksources that
        aren't currently used for timekeeping from Baolin Wang

commit 39232ed5a1793f67b11430c43ed8a9ed6e96c6eb
Author: Baolin Wang <baolin.wang@linux.alibaba.com>
Date:   Tue Jul 17 15:55:16 2018 +0800

    time: Introduce one suspend clocksource to compensate the suspend time
    
    On some hardware with multiple clocksources, we have coarse grained
    clocksources that support the CLOCK_SOURCE_SUSPEND_NONSTOP flag, but
    which are less than ideal for timekeeping whereas other clocksources
    can be better candidates but halt on suspend.
    
    Currently, the timekeeping core only supports timing suspend using
    CLOCK_SOURCE_SUSPEND_NONSTOP clocksources if that clocksource is the
    current clocksource for timekeeping.
    
    As a result, some architectures try to implement read_persistent_clock64()
    using those non-stop clocksources, but isn't really ideal, which will
    introduce more duplicate code. To fix this, provide logic to allow a
    registered SUSPEND_NONSTOP clocksource, which isn't the current
    clocksource, to be used to calculate the suspend time.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Miroslav Lichvar <mlichvar@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Stephen Boyd <sboyd@kernel.org>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Suggested-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Baolin Wang <baolin.wang@linaro.org>
    [jstultz: minor tweaks to merge with previous resume changes]
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit f473e5f467f6049370575390b08dc42131315d60
Author: Mukesh Ojha <mojha@codeaurora.org>
Date:   Tue Jul 17 12:01:29 2018 +0530

    time: Fix extra sleeptime injection when suspend fails
    
    Currently, there exists a corner case assuming when there is
    only one clocksource e.g RTC, and system failed to go to
    suspend mode. While resume rtc_resume() injects the sleeptime
    as timekeeping_rtc_skipresume() returned 'false' (default value
    of sleeptime_injected) due to which we can see mismatch in
    timestamps.
    
    This issue can also come in a system where more than one
    clocksource are present and very first suspend fails.
    
    Success case:
    ------------
                                            {sleeptime_injected=false}
    rtc_suspend() => timekeeping_suspend() => timekeeping_resume() =>
    
    (sleeptime injected)
     rtc_resume()
    
    Failure case:
    ------------
             {failure in sleep path} {sleeptime_injected=false}
    rtc_suspend()     =>          rtc_resume()
    
    {sleeptime injected again which was not required as the suspend failed}
    
    Fix this by handling the boolean logic properly.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Miroslav Lichvar <mlichvar@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Stephen Boyd <sboyd@kernel.org>
    Originally-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Mukesh Ojha <mojha@codeaurora.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 985e695074d35768cb04d65f58bca45f7bf1a99d
Author: Ondrej Mosnacek <omosnace@redhat.com>
Date:   Fri Jul 13 14:06:42 2018 +0200

    timekeeping/ntp: Constify some function arguments
    
    Add 'const' to some function arguments and variables to make it easier
    to read the code.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Miroslav Lichvar <mlichvar@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Stephen Boyd <sboyd@kernel.org>
    Signed-off-by: Ondrej Mosnacek <omosnace@redhat.com>
    [jstultz: Also fixup pre-existing checkpatch warnings for
     prototype arguments with no variable name]
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 5d2a4e91a541cb04d20d11602f0f9340291322ac
Author: Pavel Tatashin <pasha.tatashin@oracle.com>
Date:   Thu Jul 19 16:55:41 2018 -0400

    sched/clock: Move sched clock initialization and merge with generic clock
    
    sched_clock_postinit() initializes a generic clock on systems where no
    other clock is provided. This function may be called only after
    timekeeping_init().
    
    Rename sched_clock_postinit to generic_clock_inti() and call it from
    sched_clock_init(). Move the call for sched_clock_init() until after
    time_init().
    
    Suggested-by: Peter Zijlstra <peterz@infradead.org>
    Signed-off-by: Pavel Tatashin <pasha.tatashin@oracle.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: steven.sistare@oracle.com
    Cc: daniel.m.jordan@oracle.com
    Cc: linux@armlinux.org.uk
    Cc: schwidefsky@de.ibm.com
    Cc: heiko.carstens@de.ibm.com
    Cc: john.stultz@linaro.org
    Cc: sboyd@codeaurora.org
    Cc: hpa@zytor.com
    Cc: douly.fnst@cn.fujitsu.com
    Cc: prarit@redhat.com
    Cc: feng.tang@intel.com
    Cc: pmladek@suse.com
    Cc: gnomes@lxorguk.ukuu.org.uk
    Cc: linux-s390@vger.kernel.org
    Cc: boris.ostrovsky@oracle.com
    Cc: jgross@suse.com
    Cc: pbonzini@redhat.com
    Link: https://lkml.kernel.org/r/20180719205545.16512-23-pasha.tatashin@oracle.com

commit 4b1b7f8054896cee25669f6cea7cb6dd17f508f7
Author: Pavel Tatashin <pasha.tatashin@oracle.com>
Date:   Thu Jul 19 16:55:35 2018 -0400

    timekeeping: Default boot time offset to local_clock()
    
    read_persistent_wall_and_boot_offset() is called during boot to read
    both the persistent clock and also return the offset between the boot time
    and the value of persistent clock.
    
    Change the default boot_offset from zero to local_clock() so architectures,
    that do not have a dedicated boot_clock but have early sched_clock(), such
    as SPARCv9, x86, and possibly more will benefit from this change by getting
    a better and more consistent estimate of the boot time without need for an
    arch specific implementation.
    
    Signed-off-by: Pavel Tatashin <pasha.tatashin@oracle.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: steven.sistare@oracle.com
    Cc: daniel.m.jordan@oracle.com
    Cc: linux@armlinux.org.uk
    Cc: schwidefsky@de.ibm.com
    Cc: heiko.carstens@de.ibm.com
    Cc: john.stultz@linaro.org
    Cc: sboyd@codeaurora.org
    Cc: hpa@zytor.com
    Cc: douly.fnst@cn.fujitsu.com
    Cc: peterz@infradead.org
    Cc: prarit@redhat.com
    Cc: feng.tang@intel.com
    Cc: pmladek@suse.com
    Cc: gnomes@lxorguk.ukuu.org.uk
    Cc: linux-s390@vger.kernel.org
    Cc: boris.ostrovsky@oracle.com
    Cc: jgross@suse.com
    Cc: pbonzini@redhat.com
    Link: https://lkml.kernel.org/r/20180719205545.16512-17-pasha.tatashin@oracle.com

commit 3eca993740b8eb40f514b90b1877a4dbcf0a6710
Author: Pavel Tatashin <pasha.tatashin@oracle.com>
Date:   Thu Jul 19 16:55:34 2018 -0400

    timekeeping: Replace read_boot_clock64() with read_persistent_wall_and_boot_offset()
    
    If architecture does not support exact boot time, it is challenging to
    estimate boot time without having a reference to the current persistent
    clock value. Yet, it cannot read the persistent clock time again, because
    this may lead to math discrepancies with the caller of read_boot_clock64()
    who have read the persistent clock at a different time.
    
    This is why it is better to provide two values simultaneously: the
    persistent clock value, and the boot time.
    
    Replace read_boot_clock64() with:
    read_persistent_wall_and_boot_offset(wall_time, boot_offset)
    
    Where wall_time is returned by read_persistent_clock() And boot_offset is
    wall_time - boot time, which defaults to 0.
    
    Signed-off-by: Pavel Tatashin <pasha.tatashin@oracle.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: steven.sistare@oracle.com
    Cc: daniel.m.jordan@oracle.com
    Cc: linux@armlinux.org.uk
    Cc: schwidefsky@de.ibm.com
    Cc: heiko.carstens@de.ibm.com
    Cc: john.stultz@linaro.org
    Cc: sboyd@codeaurora.org
    Cc: hpa@zytor.com
    Cc: douly.fnst@cn.fujitsu.com
    Cc: peterz@infradead.org
    Cc: prarit@redhat.com
    Cc: feng.tang@intel.com
    Cc: pmladek@suse.com
    Cc: gnomes@lxorguk.ukuu.org.uk
    Cc: linux-s390@vger.kernel.org
    Cc: boris.ostrovsky@oracle.com
    Cc: jgross@suse.com
    Cc: pbonzini@redhat.com
    Link: https://lkml.kernel.org/r/20180719205545.16512-16-pasha.tatashin@oracle.com

commit fe9af81e524e8a86bdd59c0cc0d9e2b0ccaf840f
Author: Pavel Tatashin <pasha.tatashin@oracle.com>
Date:   Thu Jul 19 16:55:30 2018 -0400

    x86/tsc: Redefine notsc to behave as tsc=unstable
    
    Currently, the notsc kernel parameter disables the use of the TSC by
    sched_clock(). However, this parameter does not prevent the kernel from
    accessing tsc in other places.
    
    The only rationale to boot with notsc is to avoid timing discrepancies on
    multi-socket systems where TSC are not properly synchronized, and thus
    exclude TSC from being used for time keeping. But that prevents using TSC
    as sched_clock() as well, which is not necessary as the core sched_clock()
    implementation can handle non synchronized TSC based sched clocks just
    fine.
    
    However, there is another method to solve the above problem: booting with
    tsc=unstable parameter. This parameter allows sched_clock() to use TSC and
    just excludes it from timekeeping.
    
    So there is no real reason to keep notsc, but for compatibility reasons the
    parameter has to stay. Make it behave like 'tsc=unstable' instead.
    
    [ tglx: Massaged changelog ]
    
    Signed-off-by: Pavel Tatashin <pasha.tatashin@oracle.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Dou Liyang <douly.fnst@cn.fujitsu.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: steven.sistare@oracle.com
    Cc: daniel.m.jordan@oracle.com
    Cc: linux@armlinux.org.uk
    Cc: schwidefsky@de.ibm.com
    Cc: heiko.carstens@de.ibm.com
    Cc: john.stultz@linaro.org
    Cc: sboyd@codeaurora.org
    Cc: hpa@zytor.com
    Cc: peterz@infradead.org
    Cc: prarit@redhat.com
    Cc: feng.tang@intel.com
    Cc: pmladek@suse.com
    Cc: gnomes@lxorguk.ukuu.org.uk
    Cc: linux-s390@vger.kernel.org
    Cc: boris.ostrovsky@oracle.com
    Cc: jgross@suse.com
    Cc: pbonzini@redhat.com
    Link: https://lkml.kernel.org/r/20180719205545.16512-12-pasha.tatashin@oracle.com

commit c6bb11147eb09bd39f316c6062455b88c905ab6e
Merge: a8802d97e733 b061c7a513af
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Jul 12 22:19:58 2018 +0200

    Merge branch 'fortglx/4.19/time' of https://git.linaro.org/people/john.stultz/linux into timers/core
    
    Pull timekeeping updates from John Stultz:
    
      - Make the timekeeping update more precise when NTP frequency is set
        directly by updating the multiplier.
    
      - Adjust selftests

commit b061c7a513afe14a68af41cec7c3476befc40e95
Author: Miroslav Lichvar <mlichvar@redhat.com>
Date:   Mon Jun 4 15:34:21 2018 +0200

    timekeeping: Update multiplier when NTP frequency is set directly
    
    When the NTP frequency is set directly from userspace using the
    ADJ_FREQUENCY or ADJ_TICK timex mode, immediately update the
    timekeeper's multiplier instead of waiting for the next tick.
    
    This removes a hidden non-deterministic delay in setting of the
    frequency and allows an extremely tight control of the system clock
    with update rates close to or even exceeding the kernel HZ.
    
    The update is limited to archs using modern timekeeping
    (!ARCH_USES_GETTIMEOFFSET).
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Miroslav Lichvar <mlichvar@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Stephen Boyd <sboyd@kernel.org>
    Signed-off-by: Miroslav Lichvar <mlichvar@redhat.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 8365da2c0570f02615e7f1d2d729d854029202b0
Merge: a1be5a20f137 a42177505869
Author: David S. Miller <davem@davemloft.net>
Date:   Sat Jun 30 21:08:12 2018 +0900

    Merge tag 'mac80211-next-for-davem-2018-06-29' of git://git.kernel.org/pub/scm/linux/kernel/git/jberg/mac80211-next
    
    Small merge conflict in net/mac80211/scan.c, I preserved
    the kcalloc() conversion. -DaveM
    
    Johannes Berg says:
    
    ====================
    This round's updates:
     * finally some of the promised HE code, but it turns
       out to be small - but everything kept changing, so
       one part I did in the driver was >30 patches for
       what was ultimately <200 lines of code ... similar
       here for this code.
     * improved scan privacy support - can now specify scan
       flags for randomizing the sequence number as well as
       reducing the probe request element content
     * rfkill cleanups
     * a timekeeping cleanup from Arnd
     * various other cleanups
    ====================
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit c238d7b1e5fd6416458d7a7295a6d20ab56a3baa
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Jun 18 16:38:02 2018 +0200

    staging: rtsx: remove rtsx_trace() and related code
    
    The driver has rather excessive amount of tracing code, which would be
    better done using ftrace. This is obviously not a main feature of the
    driver, and it should work just as well without it.
    
    Removing it saves over 1300 lines of code and likely makes the driver
    a bit faster by avoiding lots of calls into the timekeeping code.
    
    I came across this while cleaning up the last users of the deprecated
    getnstimeofday64() function, of which there is one in the now-removed
    get_current_time() function of the rtsx driver that was only used for
    tracing.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 6075e4ae6e729778ac687a9ffb0c0d5223a0a19e
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Jun 18 12:05:00 2018 +0200

    s390: hypfs: use ktime_get_seconds() instead of get_seconds()
    
    time_t and get_seconds() are deprecated because they will overflow on
    32-bit architectures in the future. This is not a problem on 64-bit s390,
    but we should use proper interfaces anyway.
    
    Besides moving to the time64_t based interface, the CLOCK_MONOTONIC
    based ktime_get_seconds() is preferred for kernel internal timekeeping
    because it does not behave in unexpected ways during leap second changes
    or settimeofday() calls.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

commit d30faff900e666f9a6395a159fdd353c02f5bed0
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Jun 18 16:08:01 2018 +0200

    timekeeping: Use ktime_get_real_ts64() instead of getnstimeofday64()
    
    The two do the same, this moves all users to the newer name for consistency.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: y2038@lists.linaro.org
    Cc: Stephen Boyd <sboyd@kernel.org>
    Cc: Miroslav Lichvar <mlichvar@redhat.com>
    Link: https://lkml.kernel.org/r/20180618140811.2998503-3-arnd@arndb.de

commit a78945c357f58665d6a5da8a69e085898e831c70
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Thu Jun 14 15:28:52 2018 +0100

    nds32: Fix build error caused by configuration flag rename
    
    Fix build error on nds32 due to the merge of commit e3d5980568f ("lib:
    Rename compiler intrinsic selects to GENERIC_LIB_*") during the 4.18
    merge window which renames Kconfig symbols. This had raced with commit
    aeaa7af744fa ("nds32: lib: To use generic lib instead of libgcc to
    prevent the symbol undefined issue.") merged late in the 4.17 cycle,
    which added selects to nds32 using the original Kconfig symbol names.
    
    When they came together in merge commit 763f96944c95 ("Merge tag
    'mips_4.18' of
    git://git.kernel.org/pub/scm/linux/kernel/git/mips/linux") this resulted
    in the following build errors:
    
    nds32le-linux-ld: kernel/time/timekeeping.o: in function `timekeeping_init':
    timekeeping.c:(.init.text+0x140): undefined reference to `__ashldi3'
    nds32le-linux-ld: timekeeping.c:(.init.text+0x144): undefined reference to `__ashldi3'
    nds32le-linux-ld: timekeeping.c:(.init.text+0x17e): undefined reference to `__lshrdi3'
    nds32le-linux-ld: timekeeping.c:(.init.text+0x182): undefined reference to `__lshrdi3'
    nds32le-linux-ld: drivers/clocksource/mmio.o: in function `clocksource_mmio_init':
    mmio.c:(.init.text+0x54): undefined reference to `__lshrdi3'
    nds32le-linux-ld: mmio.c:(.init.text+0x58): undefined reference to `__lshrdi3'
    
    Rename all 6 selects in nds32 and adjust the ordering accordingly to be
    alphabetical.
    
    Fixes: 763f96944c95 ("Merge tag 'mips_4.18' of git://git.kernel.org/pub/scm/linux/kernel/git/mips/linux")
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    [jhogan@kernel.org: Rename all 6 symbols, sort, update commit message]
    Signed-off-by: James Hogan <jhogan@kernel.org>
    Cc: Greentime Hu <green.hu@gmail.com>
    Cc: Vincent Chen <deanbo422@gmail.com>
    Cc: Matt Redfearn <matt.redfearn@mips.com>
    Cc: Palmer Dabbelt <palmer@sifive.com>
    Acked-by: Greentime Hu <greentime@andestech.com>
    Signed-off-by: Greentime Hu <greentime@andestech.com>

commit ba252f16e4433e7599fec986e77722e6d0eed186
Merge: 0bbcce5d1ef3 e27c49291a7f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jun 4 21:02:18 2018 -0700

    Merge branch 'timers-2038-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull time/Y2038 updates from Thomas Gleixner:
    
     - Consolidate SySV IPC UAPI headers
    
     - Convert SySV IPC to the new COMPAT_32BIT_TIME mechanism
    
     - Cleanup the core interfaces and standardize on the ktime_get_* naming
       convention.
    
     - Convert the X86 platform ops to timespec64
    
     - Remove the ugly temporary timespec64 hack
    
    * 'timers-2038-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (22 commits)
      x86: Convert x86_platform_ops to timespec64
      timekeeping: Add more coarse clocktai/boottime interfaces
      timekeeping: Add ktime_get_coarse_with_offset
      timekeeping: Standardize on ktime_get_*() naming
      timekeeping: Clean up ktime_get_real_ts64
      timekeeping: Remove timespec64 hack
      y2038: ipc: Redirect ipc(SEMTIMEDOP, ...) to compat_ksys_semtimedop
      y2038: ipc: Enable COMPAT_32BIT_TIME
      y2038: ipc: Use __kernel_timespec
      y2038: ipc: Report long times to user space
      y2038: ipc: Use ktime_get_real_seconds consistently
      y2038: xtensa: Extend sysvipc data structures
      y2038: powerpc: Extend sysvipc data structures
      y2038: sparc: Extend sysvipc data structures
      y2038: parisc: Extend sysvipc data structures
      y2038: mips: Extend sysvipc data structures
      y2038: arm64: Extend sysvipc compat data structures
      y2038: s390: Remove unneeded ipc uapi header files
      y2038: ia64: Remove unneeded ipc uapi header files
      y2038: alpha: Remove unneeded ipc uapi header files
      ...

commit 0bbcce5d1ef3f771a349896f1c7574d20dc6f4bd
Merge: 0ef283d4c780 e45e778f078e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jun 4 20:27:54 2018 -0700

    Merge branch 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timers and timekeeping updates from Thomas Gleixner:
    
     - Core infrastucture work for Y2038 to address the COMPAT interfaces:
    
         + Add a new Y2038 safe __kernel_timespec and use it in the core
           code
    
         + Introduce config switches which allow to control the various
           compat mechanisms
    
         + Use the new config switch in the posix timer code to control the
           32bit compat syscall implementation.
    
     - Prevent bogus selection of CPU local clocksources which causes an
       endless reselection loop
    
     - Remove the extra kthread in the clocksource code which has no value
       and just adds another level of indirection
    
     - The usual bunch of trivial updates, cleanups and fixlets all over the
       place
    
     - More SPDX conversions
    
    * 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (24 commits)
      clocksource/drivers/mxs_timer: Switch to SPDX identifier
      clocksource/drivers/timer-imx-tpm: Switch to SPDX identifier
      clocksource/drivers/timer-imx-gpt: Switch to SPDX identifier
      clocksource/drivers/timer-imx-gpt: Remove outdated file path
      clocksource/drivers/arc_timer: Add comments about locking while read GFRC
      clocksource/drivers/mips-gic-timer: Add pr_fmt and reword pr_* messages
      clocksource/drivers/sprd: Fix Kconfig dependency
      clocksource: Move inline keyword to the beginning of function declarations
      timer_list: Remove unused function pointer typedef
      timers: Adjust a kernel-doc comment
      tick: Prefer a lower rating device only if it's CPU local device
      clocksource: Remove kthread
      time: Change nanosleep to safe __kernel_* types
      time: Change types to new y2038 safe __kernel_* types
      time: Fix get_timespec64() for y2038 safe compat interfaces
      time: Add new y2038 safe __kernel_timespec
      posix-timers: Make compat syscalls depend on CONFIG_COMPAT_32BIT_TIME
      time: Introduce CONFIG_COMPAT_32BIT_TIME
      time: Introduce CONFIG_64BIT_TIME in architectures
      compat: Enable compat_get/put_timespec64 always
      ...

commit 50de7f4347cf0dbe7b9c28e273a8cf498067790e
Author: Eugeniy Paltsev <Eugeniy.Paltsev@synopsys.com>
Date:   Fri Feb 23 19:41:52 2018 +0300

    ARC: mcip: halt GFRC counter when ARC cores halt
    
    [ Upstream commit 07423d00a2b2a71a97e4287d9262cb83c4c4c89f ]
    
    In SMP systems, GFRC is used for clocksource. However by default the
    counter keeps running even when core is halted (say when debugging via a
    JTAG debugger). This confuses Linux timekeeping and triggers flase RCU stall
    splat such as below:
    
    | [ARCLinux]# while true; do ./shm_open_23-1.run-test ; done
    | Running with 1000 processes for 1000 objects
    | hrtimer: interrupt took 485060 ns
    |
    | create_cnt: 1000
    | Running with 1000 processes for 1000 objects
    | [ARCLinux]# INFO: rcu_preempt self-detected stall on CPU
    |       2-...: (1 GPs behind) idle=a01/1/0 softirq=135770/135773 fqs=0
    | INFO: rcu_preempt detected stalls on CPUs/tasks:
    |       0-...: (1 GPs behind) idle=71e/0/0 softirq=135264/135264 fqs=0
    |       2-...: (1 GPs behind) idle=a01/1/0 softirq=135770/135773 fqs=0
    |       3-...: (1 GPs behind) idle=4e0/0/0 softirq=134304/134304 fqs=0
    |       (detected by 1, t=13648 jiffies, g=31493, c=31492, q=1)
    
    Starting from ARC HS v3.0 it's possible to tie GFRC to state of up-to 4
    ARC cores with help of GFRC's CORE register where we set a mask for
    cores which state we need to rely on.
    
    We update cpu mask every time new cpu came online instead of using
    hardcoded one or using mask generated from "possible_cpus" as we
    want it set correctly even if we run kernel on HW which has fewer cores
    than expected (or we launch kernel via debugger and kick fever cores
    than HW has)
    
    Note that GFRC halts when all cores have halted and thus relies on
    programming of Inter-Core-dEbug register to halt all cores when one
    halts.
    
    Signed-off-by: Alexey Brodkin <abrodkin@synopsys.com>
    Signed-off-by: Eugeniy Paltsev <Eugeniy.Paltsev@synopsys.com>
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>
    [vgupta: rewrote changelog]
    Signed-off-by: Sasha Levin <alexander.levin@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit c1a957d17086d20d52d7f9c8dffaeac2ee09d6f9
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri May 25 17:54:41 2018 +0200

    PM / suspend: Prevent might sleep splats
    
    timekeeping suspend/resume calls read_persistent_clock() which takes
    rtc_lock. That results in might sleep warnings because at that point
    we run with interrupts disabled.
    
    We cannot convert rtc_lock to a raw spinlock as that would trigger
    other might sleep warnings.
    
    As a workaround we disable the might sleep warnings by setting
    system_state to SYSTEM_SUSPEND before calling sysdev_suspend() and
    restoring it to SYSTEM_RUNNING afer sysdev_resume(). There is no lock
    contention because hibernate / suspend to RAM is single-CPU at this
    point.
    
    In s2idle's case the system_state is set to SYSTEM_SUSPEND before
    timekeeping_suspend() which is invoked by the last CPU. In the resume
    case it set back to SYSTEM_RUNNING after timekeeping_resume() which is
    invoked by the first CPU in the resume case. The other CPUs will block
    on tick_freeze_lock.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    [bigeasy: cover s2idle in tick_freeze() / tick_unfreeze()]
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 06aa376903b6e8c8741395a4702d78d47c7c27c6
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Apr 27 15:40:16 2018 +0200

    timekeeping: Add more coarse clocktai/boottime interfaces
    
    The set of APIs we provide has a few holes for coarse times, e.g. we
    provide ktime_get_coarse_boottime() and ktime_get_boottime_ts64(),
    but not the combination of the two.
    
    This adds four new functions:
    
    ktime_get_coarse_boottime_ts64()
    ktime_get_boottime_seconds()
    ktime_get_coarse_clocktai_ts64()
    ktime_get_clocktai_seconds()
    
    to fill in some of the missing pieces. I have missed only the
    ktime_get_boottime_seconds() accessor in a few occasions in
    the past, but it seems better to just provide all four together,
    as there is very little cost to having them.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Stephen Boyd <sboyd@kernel.org>
    Cc: y2038@lists.linaro.org
    Cc: John Stultz <john.stultz@linaro.org>
    Link: https://lkml.kernel.org/r/20180427134016.2525989-6-arnd@arndb.de

commit b9ff604cff1135cc576cf952d394ed9401aa234b
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Apr 27 15:40:15 2018 +0200

    timekeeping: Add ktime_get_coarse_with_offset
    
    I have run into a couple of drivers using current_kernel_time()
    suffering from the y2038 problem, and they could be converted
    to using ktime_t, but don't have interfaces that skip the nanosecond
    calculation at the moment.
    
    This introduces ktime_get_coarse_with_offset() as a simpler
    variant of ktime_get_with_offset(), and adds wrappers for the
    three time domains we support with the existing function.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Stephen Boyd <sboyd@kernel.org>
    Cc: y2038@lists.linaro.org
    Cc: John Stultz <john.stultz@linaro.org>
    Link: https://lkml.kernel.org/r/20180427134016.2525989-5-arnd@arndb.de

commit fb7fcc96a86cfaef0f6dcc0665516aa68611e736
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Apr 27 15:40:14 2018 +0200

    timekeeping: Standardize on ktime_get_*() naming
    
    The current_kernel_time64, get_monotonic_coarse64, getrawmonotonic64,
    get_monotonic_boottime64 and timekeeping_clocktai64 interfaces have
    rather inconsistent naming, and they differ in the calling conventions
    by passing the output either by reference or as a return value.
    
    Rename them to ktime_get_coarse_real_ts64, ktime_get_coarse_ts64,
    ktime_get_raw_ts64, ktime_get_boottime_ts64 and ktime_get_clocktai_ts64
    respectively, and provide the interfaces with macros or inline
    functions as needed.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Stephen Boyd <sboyd@kernel.org>
    Cc: y2038@lists.linaro.org
    Cc: John Stultz <john.stultz@linaro.org>
    Link: https://lkml.kernel.org/r/20180427134016.2525989-4-arnd@arndb.de

commit edca71fecb77e2697337d192cbfe96f513407761
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Apr 27 15:40:13 2018 +0200

    timekeeping: Clean up ktime_get_real_ts64
    
    In a move to make ktime_get_*() the preferred driver interface into the
    timekeeping code, sanitizes ktime_get_real_ts64() to be a proper exported
    symbol rather than an alias for getnstimeofday64().
    
    The internal __getnstimeofday64() is no longer used, so remove that
    and merge it into ktime_get_real_ts64().
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Stephen Boyd <sboyd@kernel.org>
    Cc: y2038@lists.linaro.org
    Cc: John Stultz <john.stultz@linaro.org>
    Link: https://lkml.kernel.org/r/20180427134016.2525989-3-arnd@arndb.de

commit 4f0fad9a603aee91a374e8411c23953894a77479
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Apr 27 15:40:12 2018 +0200

    timekeeping: Remove timespec64 hack
    
    At this point, we have converted most of the kernel to use timespec64
    consistently in place of timespec, so it seems it's time to make
    timespec64 the native structure and define timespec in terms of that
    one on 64-bit architectures.
    
    Starting with gcc-5, the compiler can completely optimize away the
    timespec_to_timespec64 and timespec64_to_timespec functions on 64-bit
    architectures. With older compilers, we introduce a couple of extra
    copies of local variables, but those are easily avoided by using
    the timespec64 based interfaces consistently, as we do in most of the
    important code paths already.
    
    The main upside of removing the hack is that printing the tv_sec
    field of a timespec64 structure can now use the %lld format
    string on all architectures without a cast to time64_t. Without
    this patch, the field is a 'long' type and would have to be printed
    using %ld on 64-bit architectures.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Stephen Boyd <sboyd@kernel.org>
    Cc: y2038@lists.linaro.org
    Cc: John Stultz <john.stultz@linaro.org>
    Link: https://lkml.kernel.org/r/20180427134016.2525989-2-arnd@arndb.de

commit 4fe581d7f114d56f31f392448477cff5a4394065
Merge: 1cfd904f1674 5dc0b1529d21
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 7 14:21:39 2018 +0200

    Merge tag 'y2038-ipc' of git://git.kernel.org/pub/scm/linux/kernel/git/arnd/playground into timers/2038
    
    Pull 'y2038: IPC system call conversion' from Arnd Bergmann:
    
    "This is a follow-up to Deepa's work on the timekeeping system calls,
     providing a y2038-safe syscall API for SYSVIPC. It uses a combination
     of two strategies:
    
     For sys_msgctl, sys_semctl and sys_shmctl, I do not introduce a completely
     new set of replacement system calls, but instead extend the existing
     ones to return data in the reserved fields of the normal data structure.
    
     This should be completely transparent to any existing user space, and
     only after the 32-bit time_t wraps, it will make a difference in the
     returned data.
    
     libc implementations will consequently have to provide their own data
     structures when they move to 64-bit time_t, and convert the structures
     in user space from the ones returned by the kernel.
    
     In contrast, mq_timedsend, mq_timedreceive and and semtimedop all do
     need to change because having a libc redefine the timespec type
     breaks the ABI, so with this series there will be two separate entry
     points for 32-bit architectures.
    
     There are three cases here:
    
     - little-endian architectures (except powerpc and mips) can use
       the normal layout and just cast the data structure to the user space
       type that contains 64-bit numbers.
    
     - parisc and sparc can do the same thing with big-endian user space
    
     - little-endian powerpc and most big-endian architectures have
       to flip the upper and lower 32-bit halves of the time_t value in memory,
       but can otherwise keep using the normal layout
    
     - mips and big-endian xtensa need to be more careful because
       they are not consistent in their definitions, and they have to provide
       custom libc implementations for the system calls to use 64-bit time_t."

commit a3ed0e4393d6885b4af7ce84b437dc696490a530
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Apr 25 15:33:38 2018 +0200

    Revert: Unify CLOCK_MONOTONIC and CLOCK_BOOTTIME
    
    Revert commits
    
    92af4dcb4e1c ("tracing: Unify the "boot" and "mono" tracing clocks")
    127bfa5f4342 ("hrtimer: Unify MONOTONIC and BOOTTIME clock behavior")
    7250a4047aa6 ("posix-timers: Unify MONOTONIC and BOOTTIME clock behavior")
    d6c7270e913d ("timekeeping: Remove boot time specific code")
    f2d6fdbfd238 ("Input: Evdev - unify MONOTONIC and BOOTTIME clock behavior")
    d6ed449afdb3 ("timekeeping: Make the MONOTONIC clock behave like the BOOTTIME clock")
    72199320d49d ("timekeeping: Add the new CLOCK_MONOTONIC_ACTIVE clock")
    
    As stated in the pull request for the unification of CLOCK_MONOTONIC and
    CLOCK_BOOTTIME, it was clear that we might have to revert the change.
    
    As reported by several folks systemd and other applications rely on the
    documented behaviour of CLOCK_MONOTONIC on Linux and break with the above
    changes. After resume daemons time out and other timeout related issues are
    observed. Rafael compiled this list:
    
    * systemd kills daemons on resume, after >WatchdogSec seconds
      of suspending (Genki Sky).  [Verified that that's because systemd uses
      CLOCK_MONOTONIC and expects it to not include the suspend time.]
    
    * systemd-journald misbehaves after resume:
      systemd-journald[7266]: File /var/log/journal/016627c3c4784cd4812d4b7e96a34226/system.journal
    corrupted or uncleanly shut down, renaming and replacing.
      (Mike Galbraith).
    
    * NetworkManager reports "networking disabled" and networking is broken
      after resume 50% of the time (Pavel).  [May be because of systemd.]
    
    * MATE desktop dims the display and starts the screensaver right after
      system resume (Pavel).
    
    * Full system hang during resume (me).  [May be due to systemd or NM or both.]
    
    That happens on debian and open suse systems.
    
    It's sad, that these problems were neither catched in -next nor by those
    folks who expressed interest in this change.
    
    Reported-by: Rafael J. Wysocki <rjw@rjwysocki.net>
    Reported-by: Genki Sky <sky@genki.is>,
    Reported-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Jonathan Corbet <corbet@lwn.net>
    Cc: Kevin Easton <kevin@guarana.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mark Salyzyn <salyzyn@android.com>
    Cc: Michael Kerrisk <mtk.manpages@gmail.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Petr Mladek <pmladek@suse.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Cc: Steven Rostedt <rostedt@goodmis.org>

commit c1e9dae0a9bf3394818abafaf376a34248c5f638
Merge: 38f0b33e6d5b 7407188489c6
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Apr 22 10:49:02 2018 -0700

    Merge branch 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer fixes from Thomas Gleixner:
     "A small set of timer fixes:
    
       - Evaluate the -ETIME condition correctly in the imx tpm driver
    
       - Fix the evaluation order of a condition in posix cpu timers
    
       - Use pr_cont() in the clockevents code to prevent ugly message
         splitting
    
       - Remove __current_kernel_time() which is now unused to prevent that
         new users show up.
    
       - Remove a stale forward declaration"
    
    * 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      clocksource/imx-tpm: Correct -ETIME return condition check
      posix-cpu-timers: Ensure set_process_cpu_timer is always evaluated
      timekeeping: Remove __current_kernel_time()
      timers: Remove stale struct tvec_base forward declaration
      clockevents: Fix kernel messages split across multiple lines

commit f990bee3f1871616d7b255b374ca33212999201e
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Apr 20 18:04:40 2018 +0200

    scsi: ips: fix firmware timestamps for 32-bit
    
    do_gettimeofday() is deprecated since it will stop working in 2038 on
    32-bit platforms, leading to incorrect times passed to the firmware.
    On 64-bit platforms the current code appears to be fine, as the
    calculation passes an 8-bit century number into the firmware that can
    represent times long in the future (possibly until 25599).
    
    Using ktime_get_real_seconds() to get a 64-bit seconds value and
    time64_to_tm() to convert it into the firmware format greatly simplifies
    the ips timekeeping code, makes 32-bit and 64-bit behave the same way
    here, and gets us closer to removing the deprecated interfaces.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

commit 1cfd904f16740df21b2df7b41c7a0dc00cbd434c
Merge: 87ef12027b9b 01909974b410
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Apr 19 16:27:44 2018 +0200

    Merge tag 'y2038-timekeeping' of git://git.kernel.org/pub/scm/linux/kernel/git/arnd/playground into timers/core
    
    Pull y2038 timekeeping syscall changes from Arnd Bergmann:
    
    This is the first set of system call entry point changes to enable 32-bit
    architectures to have variants on both 32-bit and 64-bit time_t. Typically
    these system calls take a 'struct timespec' argument, but that structure
    is defined in user space by the C library and its layout will change.
    
    The kernel already supports handling the 32-bit time_t on 64-bit
    architectures through the CONFIG_COMPAT mechanism. As there are a total
    of 51 system calls suffering from this problem, reusing that mechanism
    on 32-bit architectures.
    
    We already have patches for most of the remaining system calls, but this
    set contains most of the complexity and is best tested.  There was one
    last-minute regression that prevented it from going into 4.17, but that
    is fixed now.
    
    More details from Deepa's patch series description:
    
       Big picture is as per the lwn article:
       https://lwn.net/Articles/643234/ [2]
    
       The series is directed at converting posix clock syscalls:
       clock_gettime, clock_settime, clock_getres and clock_nanosleep
       to use a new data structure __kernel_timespec at syscall boundaries.
       __kernel_timespec maintains 64 bit time_t across all execution modes.
    
       vdso will be handled as part of each architecture when they enable
       support for 64 bit time_t.
    
       The compat syscalls are repurposed to provide backward compatibility
       by using them as native syscalls as well for 32 bit architectures.
       They will continue to use timespec at syscall boundaries.
    
       CONFIG_64_BIT_TIME controls whether the syscalls use __kernel_timespec
       or timespec at syscall boundaries.
    
       The series does the following:
       1. Enable compat syscalls on 32 bit architectures.
       2. Add a new __kernel_timespec type to be used as the data structure
          for all the new syscalls.
       3. Add new config CONFIG_64BIT_TIME(intead of the CONFIG_COMPAT_TIME in
          [1] and [2] to switch to new definition of __kernel_timespec. It is
          the same as struct timespec otherwise.
       4. Add new CONFIG_32BIT_TIME to conditionally compile compat syscalls.

commit e142aa09ed88be98395dde7acb96fb2263566b68
Author: Baolin Wang <baolin.wang@linux.alibaba.com>
Date:   Fri Apr 13 13:27:58 2018 +0800

    timekeeping: Remove __current_kernel_time()
    
    The __current_kernel_time() function based on 'struct timespec' is no
    longer recommended for new code, and the only user of this function has
    been replaced by commit 6909e29fdefb ("kdb: use __ktime_get_real_seconds
    instead of __current_kernel_time").
    
    Remove the obsolete interface.
    
    Signed-off-by: Baolin Wang <baolin.wang@linaro.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: arnd@arndb.de
    Cc: sboyd@kernel.org
    Cc: broonie@kernel.org
    Cc: john.stultz@linaro.org
    Link: https://lkml.kernel.org/r/1a9dbea7ee2cda7efe9ed330874075cf17fdbff6.1523596316.git.baolin.wang@linaro.org

commit ed98c34919985a9f87c3edacb9a8d8c283c9e243
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Mar 15 23:07:41 2018 +0100

    sched: idle: Do not stop the tick before cpuidle_idle_call()
    
    Make cpuidle_idle_call() decide whether or not to stop the tick.
    
    First, the cpuidle_enter_s2idle() path deals with the tick (and with
    the entire timekeeping for that matter) by itself and it doesn't need
    the tick to be stopped beforehand.
    
    Second, to address the issue with short idle duration predictions
    by the idle governor after the tick has been stopped, it will be
    necessary to change the ordering of cpuidle_select() with respect
    to tick_nohz_idle_stop_tick().  To prepare for that, put a
    tick_nohz_idle_stop_tick() call in the same branch in which
    cpuidle_select() is called.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Frederic Weisbecker <frederic@kernel.org>
    Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>

commit 680014d6d1da84e9c7860831221ec74230721907
Merge: 0c21fd6e6593 bd03143007eb
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Apr 4 14:50:29 2018 -0700

    Merge branch 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull time(r) updates from Thomas Gleixner:
     "A small set of updates for timers and timekeeping:
    
       - The most interesting change is the consolidation of clock MONOTONIC
         and clock BOOTTIME.
    
         Clock MONOTONIC behaves now exactly like clock BOOTTIME and does
         not longer ignore the time spent in suspend. A new clock
         MONOTONIC_ACTIVE is provived which behaves like clock MONOTONIC in
         kernels before this change. This allows applications to
         programmatically check for the clock MONOTONIC behaviour.
    
         As discussed in the review thread, this has the potential of
         breaking user space and we might have to revert this. Knock on wood
         that we can avoid that exercise.
    
       - Updates to the NTP mechanism to improve accuracy
    
       - A new kernel internal data structure to aid the ongoing Y2038 work.
    
       - Cleanups and simplifications of the clocksource code.
    
       - Make the alarmtimer code play nicely with debugobjects"
    
    * 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      alarmtimer: Init nanosleep alarm timer on stack
      y2038: Introduce struct __kernel_old_timeval
      tracing: Unify the "boot" and "mono" tracing clocks
      hrtimer: Unify MONOTONIC and BOOTTIME clock behavior
      posix-timers: Unify MONOTONIC and BOOTTIME clock behavior
      timekeeping: Remove boot time specific code
      Input: Evdev - unify MONOTONIC and BOOTTIME clock behavior
      timekeeping: Make the MONOTONIC clock behave like the BOOTTIME clock
      timekeeping: Add the new CLOCK_MONOTONIC_ACTIVE clock
      timekeeping/ntp: Determine the multiplier directly from NTP tick length
      timekeeping/ntp: Don't align NTP frequency adjustments to ticks
      clocksource: Use ATTRIBUTE_GROUPS
      clocksource: Use DEVICE_ATTR_RW/RO/WO to define device attributes
      clocksource: Don't walk the clocksource list for empty override

commit 1ea5afd42a16058f9301a46c8969787c7baa7eea
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Mar 9 12:02:36 2018 +0100

    Documentation: arch-support: remove obsolete architectures
    
    A number of architecture ports are obsolete and getting dropped,
    so we no longer want to track the respective features.
    
    We already removed the lines for metag and mn10300, this does
    the same edits for all the others.
    
    For the remaining 21 architectures, this shows how many are known
    to implement each given feature:
    
    19 time/modern-timekeeping/arch-support.txt
    19 time/clockevents/arch-support.txt
    15 core/tracehook/arch-support.txt
    14 core/generic-idle-thread/arch-support.txt
    13 locking/lockdep/arch-support.txt
    12 io/dma-api-debug/arch-support.txt
    11 debug/kgdb/arch-support.txt
    10 time/virt-cpuacct/arch-support.txt
     9 debug/kretprobes/arch-support.txt
     9 debug/kprobes/arch-support.txt
     8 vm/THP/arch-support.txt
     8 vm/pte_special/arch-support.txt
     8 vm/numa-memblock/arch-support.txt
     8 io/sg-chain/arch-support.txt
     7 perf/kprobes-event/arch-support.txt
     7 locking/rwsem-optimized/arch-support.txt
     7 debug/gcov-profile-all/arch-support.txt
     7 core/jump-labels/arch-support.txt
     7 core/BPF-JIT/arch-support.txt
     6 vm/ELF-ASLR/arch-support.txt
     6 time/context-tracking/arch-support.txt
     6 seccomp/seccomp-filter/arch-support.txt
     6 debug/stackprotector/arch-support.txt
     5 time/irq-time-acct/arch-support.txt
     5 io/dma-contiguous/arch-support.txt
     5 debug/uprobes/arch-support.txt
     4 vm/ioremap_prot/arch-support.txt
     4 time/arch-tick-broadcast/arch-support.txt
     4 perf/perf-stackdump/arch-support.txt
     4 perf/perf-regs/arch-support.txt
     3 debug/KASAN/arch-support.txt
     2 vm/PG_uncached/arch-support.txt
     2 vm/huge-vmap/arch-support.txt
     2 sched/numa-balancing/arch-support.txt
     2 sched/membarrier-sync-core/arch-support.txt
     2 locking/cmpxchg-local/arch-support.txt
     2 debug/optprobes/arch-support.txt
     2 debug/kprobes-on-ftrace/arch-support.txt
     1 vm/TLB/arch-support.txt
     1 locking/queued-spinlocks/arch-support.txt
     1 locking/queued-rwlocks/arch-support.txt
     1 debug/user-ret-profiler/arch-support.txt
     0 lib/strncasecmp/arch-support.txt
    
    Note that the list does not include riscv or nds32 yet, these still
    need to be added.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

commit d6c7270e913db75ca5fdc79915ba780e97ae2857
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Mar 1 17:33:35 2018 +0100

    timekeeping: Remove boot time specific code
    
    Now that the MONOTONIC and BOOTTIME clocks are the same, remove all the
    special handling from timekeeping. Keep wrappers for the existing users of
    the *boot* timekeeper interfaces.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Jonathan Corbet <corbet@lwn.net>
    Cc: Kevin Easton <kevin@guarana.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mark Salyzyn <salyzyn@android.com>
    Cc: Michael Kerrisk <mtk.manpages@gmail.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Petr Mladek <pmladek@suse.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Link: http://lkml.kernel.org/r/20180301165150.236279497@linutronix.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit d6ed449afdb38f89a7b38ec50e367559e1b8f71f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Mar 1 17:33:33 2018 +0100

    timekeeping: Make the MONOTONIC clock behave like the BOOTTIME clock
    
    The MONOTONIC clock is not fast forwarded by the time spent in suspend on
    resume. This is only done for the BOOTTIME clock. The reason why the
    MONOTONIC clock is not forwarded is historical: the original Linux
    implementation was using jiffies as a base for the MONOTONIC clock and
    jiffies have never been advanced after resume.
    
    At some point when timekeeping was unified in the core code, the
    MONONOTIC clock was advanced after resume which also advanced jiffies causing
    interesting side effects. As a consequence the the MONOTONIC clock forwarding
    was disabled again and the BOOTTIME clock was introduced, which allows to read
    time since boot.
    
    Back then it was not possible to completely distangle the MONOTONIC clock and
    jiffies because there were still interfaces which exposed the MONOTONIC clock
    behaviour based on the timer wheel and therefore jiffies.
    
    As of today none of the MONOTONIC clock facilities depends on jiffies
    anymore so the forwarding can be done seperately. This is achieved by
    forwarding the variables which are used for the jiffies update after resume
    before the tick is restarted,
    
    In timekeeping resume, the change is rather simple. Instead of updating the
    offset between the MONOTONIC clock and the REALTIME/BOOTTIME clocks, advance the
    time keeper base for the MONOTONIC and the MONOTONIC_RAW clocks by the time
    spent in suspend.
    
    The MONOTONIC clock is now the same as the BOOTTIME clock and the offset between
    the REALTIME and the MONOTONIC clocks is the same as before suspend.
    
    There might be side effects in applications, which rely on the
    (unfortunately) well documented behaviour of the MONOTONIC clock, but the
    downsides of the existing behaviour are probably worse.
    
    There is one obvious issue. Up to now it was possible to retrieve the time
    spent in suspend by observing the delta between the MONOTONIC clock and the
    BOOTTIME clock. This is not longer available, but the previously introduced
    mechanism to read the active non-suspended monotonic time can mitigate that
    in a detectable fashion.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Jonathan Corbet <corbet@lwn.net>
    Cc: Kevin Easton <kevin@guarana.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mark Salyzyn <salyzyn@android.com>
    Cc: Michael Kerrisk <mtk.manpages@gmail.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Petr Mladek <pmladek@suse.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Link: http://lkml.kernel.org/r/20180301165150.062975504@linutronix.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 72199320d49dbafa1a99f94f1cd60dc90035c154
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Mar 1 17:33:32 2018 +0100

    timekeeping: Add the new CLOCK_MONOTONIC_ACTIVE clock
    
    The planned change to unify the behaviour of the MONOTONIC and BOOTTIME
    clocks vs. suspend removes the ability to retrieve the active
    non-suspended time of a system.
    
    Provide a new CLOCK_MONOTONIC_ACTIVE clock which returns the active
    non-suspended time of the system via clock_gettime().
    
    This preserves the old behaviour of CLOCK_MONOTONIC before the
    BOOTTIME/MONOTONIC unification.
    
    This new clock also allows applications to detect programmatically that
    the MONOTONIC and BOOTTIME clocks are identical.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Jonathan Corbet <corbet@lwn.net>
    Cc: Kevin Easton <kevin@guarana.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mark Salyzyn <salyzyn@android.com>
    Cc: Michael Kerrisk <mtk.manpages@gmail.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Petr Mladek <pmladek@suse.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Link: http://lkml.kernel.org/r/20180301165149.965235774@linutronix.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 78b98e3c5a66d569a53b8f57b6a698f912794a43
Author: Miroslav Lichvar <mlichvar@redhat.com>
Date:   Fri Mar 9 10:42:48 2018 -0800

    timekeeping/ntp: Determine the multiplier directly from NTP tick length
    
    When the length of the NTP tick changes significantly, e.g. when an
    NTP/PTP application is correcting the initial offset of the clock, a
    large value may accumulate in the NTP error before the multiplier
    converges to the correct value. It may then take a very long time (hours
    or even days) before the error is corrected. This causes the clock to
    have an unstable frequency offset, which has a negative impact on the
    stability of synchronization with precise time sources (e.g. NTP/PTP
    using hardware timestamping or the PTP KVM clock).
    
    Use division to determine the correct multiplier directly from the NTP
    tick length and replace the iterative approach. This removes the last
    major source of the NTP error. The only remaining source is now limited
    resolution of the multiplier, which is corrected by adding 1 to the
    multiplier when the system clock is behind the NTP time.
    
    Signed-off-by: Miroslav Lichvar <mlichvar@redhat.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Stephen Boyd <stephen.boyd@linaro.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/1520620971-9567-3-git-send-email-john.stultz@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit c2cda2a5bda9f1369c9d1ab54a20571c13cf2743
Author: Miroslav Lichvar <mlichvar@redhat.com>
Date:   Fri Mar 9 10:42:47 2018 -0800

    timekeeping/ntp: Don't align NTP frequency adjustments to ticks
    
    When the timekeeping multiplier is changed, the NTP error is updated to
    correct the clock for the delay between the tick and the update of the
    clock. This error is corrected in later updates and the clock appears as
    if the frequency was changed exactly on the tick.
    
    Remove this correction to keep the point where the frequency is
    effectively changed at the time of the update. This removes a major
    source of the NTP error.
    
    Signed-off-by: Miroslav Lichvar <mlichvar@redhat.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Stephen Boyd <stephen.boyd@linaro.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/1520620971-9567-2-git-send-email-john.stultz@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 07423d00a2b2a71a97e4287d9262cb83c4c4c89f
Author: Eugeniy Paltsev <Eugeniy.Paltsev@synopsys.com>
Date:   Fri Feb 23 19:41:52 2018 +0300

    ARC: mcip: halt GFRC counter when ARC cores halt
    
    In SMP systems, GFRC is used for clocksource. However by default the
    counter keeps running even when core is halted (say when debugging via a
    JTAG debugger). This confuses Linux timekeeping and triggers flase RCU stall
    splat such as below:
    
    | [ARCLinux]# while true; do ./shm_open_23-1.run-test ; done
    | Running with 1000 processes for 1000 objects
    | hrtimer: interrupt took 485060 ns
    |
    | create_cnt: 1000
    | Running with 1000 processes for 1000 objects
    | [ARCLinux]# INFO: rcu_preempt self-detected stall on CPU
    |       2-...: (1 GPs behind) idle=a01/1/0 softirq=135770/135773 fqs=0
    | INFO: rcu_preempt detected stalls on CPUs/tasks:
    |       0-...: (1 GPs behind) idle=71e/0/0 softirq=135264/135264 fqs=0
    |       2-...: (1 GPs behind) idle=a01/1/0 softirq=135770/135773 fqs=0
    |       3-...: (1 GPs behind) idle=4e0/0/0 softirq=134304/134304 fqs=0
    |       (detected by 1, t=13648 jiffies, g=31493, c=31492, q=1)
    
    Starting from ARC HS v3.0 it's possible to tie GFRC to state of up-to 4
    ARC cores with help of GFRC's CORE register where we set a mask for
    cores which state we need to rely on.
    
    We update cpu mask every time new cpu came online instead of using
    hardcoded one or using mask generated from "possible_cpus" as we
    want it set correctly even if we run kernel on HW which has fewer cores
    than expected (or we launch kernel via debugger and kick fever cores
    than HW has)
    
    Note that GFRC halts when all cores have halted and thus relies on
    programming of Inter-Core-dEbug register to halt all cores when one
    halts.
    
    Signed-off-by: Alexey Brodkin <abrodkin@synopsys.com>
    Signed-off-by: Eugeniy Paltsev <Eugeniy.Paltsev@synopsys.com>
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>
    [vgupta: rewrote changelog]

commit 669c0f762ed19bd9ec128ebc97ae8641b6e1a4a3
Merge: f0b13428c95d 3b42349d56c9
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jan 29 18:17:39 2018 -0800

    Merge branch 'x86-platform-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull x86 platform updates from Thomas Gleixner:
     "The platform support for x86 contains the following updates:
    
       - A set of updates for the UV platform to support new CPUs and to fix
         some of the UV4A BAU MRRs
    
       - The initial platform support for the jailhouse hypervisor to allow
         native Linux guests (inmates) in non-root cells.
    
       - A fix for the PCI initialization on Intel MID platforms"
    
    * 'x86-platform-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (24 commits)
      x86/jailhouse: Respect pci=lastbus command line settings
      x86/jailhouse: Set X86_FEATURE_TSC_KNOWN_FREQ
      x86/platform/intel-mid: Move PCI initialization to arch_init()
      x86/platform/uv/BAU: Replace hard-coded values with MMR definitions
      x86/platform/UV: Fix UV4A BAU MMRs
      x86/platform/UV: Fix GAM MMR references in the UV x2apic code
      x86/platform/UV: Fix GAM MMR changes in UV4A
      x86/platform/UV: Add references to access fixed UV4A HUB MMRs
      x86/platform/UV: Fix UV4A support on new Intel Processors
      x86/platform/UV: Update uv_mmrs.h to prepare for UV4A fixes
      x86/jailhouse: Add PCI dependency
      x86/jailhouse: Hide x2apic code when CONFIG_X86_X2APIC=n
      x86/jailhouse: Initialize PCI support
      x86/jailhouse: Wire up IOAPIC for legacy UART ports
      x86/jailhouse: Halt instead of failing to restart
      x86/jailhouse: Silence ACPI warning
      x86/jailhouse: Avoid access of unsupported platform resources
      x86/jailhouse: Set up timekeeping
      x86/jailhouse: Enable PMTIMER
      x86/jailhouse: Enable APIC and SMP support
      ...

commit e85eb632f651e70252bb18b292efaf6961164e32
Author: Jan Kiszka <jan.kiszka@siemens.com>
Date:   Mon Nov 27 09:11:49 2017 +0100

    x86/jailhouse: Set up timekeeping
    
    Get the precalibrated frequencies for the TSC and the APIC timer from
    the Jailhouse platform info and set the kernel values accordingly.
    
    Signed-off-by: Jan Kiszka <jan.kiszka@siemens.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: jailhouse-dev@googlegroups.com
    Link: https://lkml.kernel.org/r/b2557426332fc337a74d3141cb920f7dce9ad601.1511770314.git.jan.kiszka@siemens.com

commit 3d8598fb9c5a77837d9c0951efc5c36fdf91d87c
Author: Tero Kristo <t-kristo@ti.com>
Date:   Tue Aug 15 11:42:17 2017 +0300

    clk: ti: clkctrl: use fallback udelay approach if timekeeping is suspended
    
    In certain cases it is possible that the timekeeping has been suspended
    already when attempting to disable/enable a clkctrl clock. This will
    happen at least on am43xx platform when attempting to enable / disable
    the clockevent source itself, burping out a warning from timekeeping core.
    
    The sequence of events leading to this:
    -> timekeeping_suspend()
     -> clockevents_suspend()
      -> omap_clkevt_idle()
       -> omap_hwmod_idle()
        -> _omap4_clkctrl_clk_disable()
         -> _omap4_is_timeout()
    
    Avoid the issue by checking if the timekeeping is suspended and using
    the fallback udelay approach for checking timeouts.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Acked-by: Stephen Boyd <sboyd@codeaurora.org>

commit d750dbdc071bf863112ea83c64cd7c44d4bad261
Author: Tina Ruchandani <ruchandani.tina@gmail.com>
Date:   Mon Nov 27 15:02:17 2017 +0100

    atm: mpoa: remove 32-bit timekeeping
    
    net/atm/mpoa_* files use 'struct timeval' to store event
    timestamps. struct timeval uses a 32-bit seconds field which will
    overflow in the year 2038 and beyond. Morever, the timestamps are being
    compared only to get seconds elapsed, so struct timeval which stores
    a seconds and microseconds field is an overkill. This patch replaces
    the use of struct timeval with time64_t to store a 64-bit seconds field.
    
    Signed-off-by: Tina Ruchandani <ruchandani.tina@gmail.com>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit aea3706cfc4d952ed6d32b6d5845b5ecd99ed7f5
Author: Miroslav Lichvar <mlichvar@redhat.com>
Date:   Mon Nov 13 14:51:31 2017 -0800

    timekeeping: Remove CONFIG_GENERIC_TIME_VSYSCALL_OLD
    
    As of d4d1fc61eb38f (ia64: Update fsyscall gettime to use modern
    vsyscall_update)the last user of CONFIG_GENERIC_TIME_VSYSCALL_OLD
    have been updated, the legacy support for old-style vsyscall
    implementations can be removed from the timekeeping code.
    
    (Thanks again to Tony Luck for helping remove the last user!)
    
    [jstultz: Commit message rework]
    
    Signed-off-by: Miroslav Lichvar <mlichvar@redhat.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Stephen Boyd <stephen.boyd@linaro.org>
    Link: https://lkml.kernel.org/r/1510613491-16695-1-git-send-email-john.stultz@linaro.org

commit 31486372a1e9a66ec2e9e2903b8792bba7e503e1
Merge: 8e9a2dba8686 fcdfafcb73be
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Nov 13 13:05:08 2017 -0800

    Merge branch 'perf-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull perf updates from Ingo Molnar:
     "The main changes in this cycle were:
    
      Kernel:
    
       - kprobes updates: use better W^X patterns for code modifications,
         improve optprobes, remove jprobes. (Masami Hiramatsu, Kees Cook)
    
       - core fixes: event timekeeping (enabled/running times statistics)
         fixes, perf_event_read() locking fixes and cleanups, etc. (Peter
         Zijlstra)
    
       - Extend x86 Intel free-running PEBS support and support x86
         user-register sampling in perf record and perf script. (Andi Kleen)
    
      Tooling:
    
       - Completely rework the way inline frames are handled. Instead of
         querying for the inline nodes on-demand in the individual tools, we
         now create proper callchain nodes for inlined frames. (Milian
         Wolff)
    
       - 'perf trace' updates (Arnaldo Carvalho de Melo)
    
       - Implement a way to print formatted output to per-event files in
         'perf script' to facilitate generate flamegraphs, elliminating the
         need to write scripts to do that separation (yuzhoujian, Arnaldo
         Carvalho de Melo)
    
       - Update vendor events JSON metrics for Intel's Broadwell, Broadwell
         Server, Haswell, Haswell Server, IvyBridge, IvyTown, JakeTown,
         Sandy Bridge, Skylake, SkyLake Server - and Goldmont Plus V1 (Andi
         Kleen, Kan Liang)
    
       - Multithread the synthesizing of PERF_RECORD_ events for
         pre-existing threads in 'perf top', speeding up that phase, greatly
         improving the user experience in systems such as Intel's Knights
         Mill (Kan Liang)
    
       - Introduce the concept of weak groups in 'perf stat': try to set up
         a group, but if it's not schedulable fallback to not using a group.
         That gives us the best of both worlds: groups if they work, but
         still a usable fallback if they don't. E.g: (Andi Kleen)
    
       - perf sched timehist enhancements (David Ahern)
    
       - ... various other enhancements, updates, cleanups and fixes"
    
    * 'perf-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (139 commits)
      kprobes: Don't spam the build log with deprecation warnings
      arm/kprobes: Remove jprobe test case
      arm/kprobes: Fix kretprobe test to check correct counter
      perf srcline: Show correct function name for srcline of callchains
      perf srcline: Fix memory leak in addr2inlines()
      perf trace beauty kcmp: Beautify arguments
      perf trace beauty: Implement pid_fd beautifier
      tools include uapi: Grab a copy of linux/kcmp.h
      perf callchain: Fix double mapping al->addr for children without self period
      perf stat: Make --per-thread update shadow stats to show metrics
      perf stat: Move the shadow stats scale computation in perf_stat__update_shadow_stats
      perf tools: Add perf_data_file__write function
      perf tools: Add struct perf_data_file
      perf tools: Rename struct perf_data_file to perf_data
      perf script: Print information about per-event-dump files
      perf trace beauty prctl: Generate 'option' string table from kernel headers
      tools include uapi: Grab a copy of linux/prctl.h
      perf script: Allow creating per-event dump files
      perf evsel: Restore evsel->priv as a tool private area
      perf script: Use event_format__fprintf()
      ...

commit 8a7a8e1eab929eb3a5b735a788a23b9731139046
Author: Dou Liyang <douly.fnst@cn.fujitsu.com>
Date:   Mon Nov 13 13:49:04 2017 +0800

    timekeeping: Eliminate the stale declaration of ktime_get_raw_and_real_ts64()
    
    Commit ba26621e63ce got rid of ktime_get_raw_and_real_ts64(), but left its
    declaration behind.
    
    Remove it.
    
    Fixes: ba26621e63ce ("time: Remove duplicated code in ktime_get_raw_and_real()")
    Signed-off-by: Dou Liyang <douly.fnst@cn.fujitsu.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Christopher S. Hall <christopher.s.hall@intel.com>
    Cc: joelaf@google.com
    Cc: arnd@arndb.de
    Cc: gregkh@linuxfoundation.org
    Cc: john.stultz@linaro.org
    Cc: deepa.kernel@gmail.com
    Cc: stable@vger.kernel.org
    Link: https://lkml.kernel.org/r/1510552144-20831-1-git-send-email-douly.fnst@cn.fujitsu.com

commit 9bfe7553fadb269e45a6e10f68b727957dff5676
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Tue Nov 7 01:49:54 2017 +0000

    arm64: Implement __lshrti3 library function
    
    Commit fb8722735f50 ("arm64: support __int128 on gcc 5+") added support
    for the __int128 data type, but this breaks the build in some configurations
    where GCC ends up emitting calls to the __lshrti3 helper in libgcc, which
    results in a link error:
    
      kernel/sched/fair.o: In function `__calc_delta':
      fair.c:(.text+0xca0): undefined reference to `__lshrti3'
      kernel/time/timekeeping.o: In function `timekeeping_resume':
      timekeeping.c:(.text+0x3f60): undefined reference to `__lshrti3'
      make: *** [vmlinux] Error 1
    
    Fix the build by providing an implementation of __lshrti3, like we do
    already for __ashlti3 and __ashrti3.
    
    Reported-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

commit df27067e6040b51188184876253d93da002433aa
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Nov 10 16:25:04 2017 +0100

    pstore: Use ktime_get_real_fast_ns() instead of __getnstimeofday()
    
    __getnstimeofday() is a rather odd interface, with a number of quirks:
    
    - The caller may come from NMI context, but the implementation is not NMI safe,
      one way to get there from NMI is
    
          NMI handler:
            something bad
              panic()
                kmsg_dump()
                  pstore_dump()
                     pstore_record_init()
                       __getnstimeofday()
    
    - The calling conventions are different from any other timekeeping functions,
      to deal with returning an error code during suspended timekeeping.
    
    Address the above issues by using a completely different method to get the
    time: ktime_get_real_fast_ns() is NMI safe and has a reasonable behavior
    when timekeeping is suspended: it returns the time at which it got
    suspended. As Thomas Gleixner explained, this is safe, as
    ktime_get_real_fast_ns() does not call into the clocksource driver that
    might be suspended.
    
    The result can easily be transformed into a timespec structure. Since
    ktime_get_real_fast_ns() was not exported to modules, add the export.
    
    The pstore behavior for the suspended case changes slightly, as it now
    stores the timestamp at which timekeeping was suspended instead of storing
    a zero timestamp.
    
    This change is not addressing y2038-safety, that's subject to a more
    complex follow up patch.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Kees Cook <keescook@chromium.org>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Anton Vorontsov <anton@enomsg.org>
    Cc: Stephen Boyd <sboyd@codeaurora.org>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Colin Cross <ccross@android.com>
    Link: https://lkml.kernel.org/r/20171110152530.1926955-1-arnd@arndb.de

commit e6d68b00e989f27116fd8575f1f9c217873e9b0e
Author: Christoffer Dall <cdall@linaro.org>
Date:   Wed Jul 5 11:04:28 2017 +0200

    arm64: Use physical counter for in-kernel reads when booted in EL2
    
    Using the physical counter allows KVM to retain the offset between the
    virtual and physical counter as long as it is actively running a VCPU.
    
    As soon as a VCPU is released, another thread is scheduled or we start
    running userspace applications, we reset the offset to 0, so that
    userspace accessing the virtual timer can still read the virtual counter
    and get the same view of time as the kernel.
    
    This opens up potential improvements for KVM performance, but we have to
    make a few adjustments to preserve system consistency.
    
    Currently get_cycles() is hardwired to arch_counter_get_cntvct() on
    arm64, but as we move to using the physical timer for the in-kernel
    time-keeping on systems that boot in EL2, we should use the same counter
    for get_cycles() as for other in-kernel timekeeping operations.
    
    Similarly, implementations of arch_timer_set_next_event_phys() is
    modified to use the counter specific to the timer being programmed.
    
    VHE kernels or kernels continuing to use the virtual timer are
    unaffected.
    
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Acked-by: Catalin Marinas <catalin.marinas@arm.com>
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Christoffer Dall <cdall@linaro.org>

commit fb56d689fb1c8f13d4d7168abf3838657b042885
Merge: 6c1e272f962d 6546911ed369
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Oct 31 23:17:28 2017 +0100

    Merge branch 'fortglx/4.15/time' of https://git.linaro.org/people/john.stultz/linux into timers/core
    
    Pull timekeeping updates from John Stultz:
    
     - More y2038 work from Arnd Bergmann
    
     - A new mechanism to allow RTC drivers to specify the resolution of the
       RTC so the suspend/resume code can make informed decisions whether to
       inject the suspended time or not in case of fast suspend/resume cycles.

commit 6546911ed369af8d747215ff8b6144618e91c6ab
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Thu Oct 19 13:14:49 2017 +0200

    time: Move old timekeeping interfaces to timekeeping32.h
    
    The interfaces based on 'struct timespec' and 'unsigned long' seconds
    are no longer recommended for new code, and we are trying to migrate to
    ktime_t based interfaces and other y2038-safe variants.
    
    This moves all the legacy interfaces from linux/timekeeping.h into a
    new timekeeping32.h to better document this.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Miroslav Lichvar <mlichvar@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Stephen Boyd <stephen.boyd@linaro.org>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 1572fa03784831b81ec26ec379374cf6bdec04fb
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Thu Oct 19 13:14:45 2017 +0200

    timekeeping: Use timespec64 in timekeeping_inject_offset
    
    As part of changing all the timekeeping code to use 64-bit
    time_t consistently, this removes the uses of timeval
    and timespec as much as possible from do_adjtimex() and
    timekeeping_inject_offset(). The timeval_inject_offset_valid()
    and timespec_inject_offset_valid() just complicate this,
    so I'm folding them into the respective callers.
    
    This leaves the actual 'struct timex' definition, which
    is part of the user-space ABI and should be dealt with
    separately when we have agreed on the ABI change.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Miroslav Lichvar <mlichvar@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Stephen Boyd <stephen.boyd@linaro.org>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit e0956dcc4ba74ec4b17e32fc9a156fcba1ef6610
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Thu Oct 19 13:14:44 2017 +0200

    timekeeping: Consolidate timekeeping_inject_offset code
    
    The code to check the adjtimex() or clock_adjtime() arguments is spread
    out across multiple files for presumably only historic reasons. As a
    preparatation for a rework to get rid of the use of 'struct timeval'
    and 'struct timespec' in there, this moves all the portions into
    kernel/time/timekeeping.c and marks them as 'static'.
    
    The warp_clock() function here is not as closely related as the others,
    but I feel it still makes sense to move it here in order to consolidate
    all callers of timekeeping_inject_offset().
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Miroslav Lichvar <mlichvar@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Stephen Boyd <stephen.boyd@linaro.org>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    [jstultz: Whitespace fixup]
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 0d3d73aac2ff05c78387aa9dcc2c8aa3804405e7
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Tue Sep 5 14:16:28 2017 +0200

    perf/core: Rewrite event timekeeping
    
    The current even timekeeping, which computes enabled and running
    times, uses 3 distinct timestamps to reflect the various event states:
    OFF (stopped), INACTIVE (enabled) and ACTIVE (running).
    
    Furthermore, the update rules are such that even INACTIVE events need
    their timestamps updated. This is undesirable because we'd like to not
    touch INACTIVE events if at all possible, this makes event scheduling
    (much) more expensive than needed.
    
    Rewrite the timekeeping to directly use event->state, this greatly
    simplifies the code and results in only having to update things when
    we change state, or an up-to-date value is requested (read).
    
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 0c1cbc18df9e38182a0604b15535699c84d7342a
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Tue Sep 5 16:26:44 2017 +0200

    perf/core: Fix perf_event_read()
    
    perf_event_read() has a number of issues regarding the timekeeping bits.
    
     - The IPI didn't update group times when it found INACTIVE
    
     - The direct call would not re-check ->state after taking ctx->lock
       which can result in ->count and timestamps getting out of sync.
    
    And we can make use of the ordering introduced for perf_event_stop()
    to make it more accurate for ACTIVE.
    
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 72ecd793865f91c3cdeb06884f230f38f434c67c
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Fri Oct 6 06:20:25 2017 +0200

    ARM: ux500: Fix regression while init PM domains
    
    The commit afece3ab9a36 ("PM / Domains: Add time accounting to various
    genpd states") causes a boot regression for ux500.
    
    The problem occurs when the ux500 machine code calls pm_genpd_init(), which
    since the above change triggers a call to ktime_get(). More precisely,
    because ux500 initializes PM domains in the init_IRQ() phase of the boot,
    timekeeping has not yet been initialized.
    
    Fix the problem by moving the initialization of the PM domains to after
    timekeeping has been initialized.
    
    Fixes: afece3ab9a36 ("PM / Domains: Add time accounting to various genpd..")
    Cc: Thara Gopinath <thara.gopinath@linaro.org>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

commit e7ad97938eaccb5a9ff4534167b1abafb507935c
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Thu Oct 12 11:48:31 2017 +0200

    liquidio: fix timespec64_to_ns typo
    
    While experimenting with changes to the timekeeping code, I
    ran into a build error in the liquidio driver:
    
    drivers/net/ethernet/cavium/liquidio/lio_main.c: In function 'liquidio_ptp_settime':
    drivers/net/ethernet/cavium/liquidio/lio_main.c:1850:22: error: passing argument 1 of 'timespec_to_ns' from incompatible pointer type [-Werror=incompatible-pointer-types]
    
    The driver had a type mismatch since it was first merged, but
    this never caused problems because it is only built on 64-bit
    architectures that define timespec and timespec64 to the same
    type.
    
    If we ever want to compile-test the driver on 32-bit or change
    the way that 64-bit timespec64 is defined, we need to fix it,
    so let's just do it now.
    
    Fixes: f21fb3ed364b ("Add support of Cavium Liquidio ethernet adapters")
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Felix Manlunas <felix.manlunas@cavium.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 584ce30c72954e5ec67aaf317d7cbffe6c2c97fa
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Tue Aug 29 21:52:56 2017 +0200

    rtc: ds1307: improve weekday handling
    
    The current code for checking and fixing the weekday in ds1307_probe
    faces some issues:
    - This check is applied to all chips even if its applicable (AFAIK)
      to mcp794xx only
    - The check uses MCP794XX constants for registers and bits even though
      it's executed also on other chips (ok, this could be fixed easily)
    - It relies on tm_wday being properly populated when core calls set_time
      and set_alarm. This is not guaranteed at all.
    
    First two issue we could solve by moving the check to the
    mcp794xx-specific initialization (where also VBATEN flag is set).
    
    The proposed alternative is in the set_alarm path for mcp794xx only and
    calculates the alarm weekday based on the current weekday in the RTC
    timekeeping regs and the difference between alarm date and current date.
    So we are fine with any weekday even if it doesn't match the date.
    
    Still there are cases where this could fail, e.g.:
    - rtc date/time + weekday have power-on-reset default values
    - alarm is set to actual date/time + x
    - set_time is called (may change diff between rtc weekday and actual
      weekday)
    
    But similar issues we have with the current code too:
    - rtc date/time + weekday have power-on-reset default values
    - alarm is set to rtc date/time + x
    - set_time is called before the alarm triggers
    
    Using random rtc date/time with relative alarms simply can interfere
    with set_time. I'm not totally convinced of either option yet.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>

commit 4c3711d7fb4763c63b2654f2d07cbe21ca5aadd4
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Aug 31 17:12:48 2017 +0200

    timekeeping: Provide NMI safe access to clock realtime
    
    The configurable printk timestamping wants access to clock realtime. Right
    now there is no ktime_get_real_fast_ns() accessor because reading the
    monotonic base and the realtime offset cannot be done atomically. Contrary
    to boot time this offset can change during runtime and cause half updated
    readouts.
    
    struct tk_read_base was fully packed when the fast timekeeper access was
    implemented. commit ceea5e3771ed ("time: Fix clock->read(clock) race around
    clocksource changes") removed the 'read' function pointer from the
    structure, but of course left the comment stale.
    
    So now the structure can fit a new 64bit member w/o violating the cache
    line constraints.
    
    Add real_base to tk_read_base and update it in the fast timekeeper update
    sequence.
    
    Implement an accessor which follows the same scheme as the accessor to
    clock monotonic, but uses the new real_base to access clock real time.
    
    The runtime overhead for updating real_base is minimal as it just adds two
    cache hot values and stores them into an already dirtied cache line along
    with the other fast timekeeper updates.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Peter Zijlstra <peterz@infradead,org>
    Link: https://lkml.kernel.org/r/1505757060-2004-3-git-send-email-prarit@redhat.com

commit 5df32107f609c1f621bcdac0a685c23677ef671e
Author: Prarit Bhargava <prarit@redhat.com>
Date:   Mon Aug 28 08:21:53 2017 -0400

    timekeeping: Make fast accessors return 0 before timekeeping is initialized
    
    printk timestamps will be extended to include mono and boot time by using
    the fast timekeeping accessors ktime_get_mono|boot_fast_ns().  The
    functions can return garbage before timekeeping is initialized resulting in
    garbage timestamps.
    
    Initialize the fast timekeepers with dummy clocks which guarantee a 0
    readout up to timekeeping_init().
    
    Suggested-by: Peter Zijlstra <peterz@infradead.org>
    Signed-off-by: Prarit Bhargava <prarit@redhat.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Stephen Boyd <sboyd@codeaurora.org>
    Cc: John Stultz <john.stultz@linaro.org>
    Link: http://lkml.kernel.org/r/1503922914-10660-2-git-send-email-prarit@redhat.com

commit dd90cccffc20a15d8e4c3ac8813f4b6a6cd4766f
Merge: b1b6f83ac938 51218298a25e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Sep 4 13:06:34 2017 -0700

    Merge branch 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer fixes from Thomas Gleixner:
     "A rather small update for the time(r) subsystem:
    
       - A new clocksource driver IMX-TPM
    
       - Minor fixes to the alarmtimer facility
    
       - Device tree cleanups for Renesas drivers
    
       - A new kselftest and fixes for the timer related tests
    
       - Conversion of the clocksource drivers to use %pOF
    
       - Use the proper helpers to access rlimits in the posix-cpu-timer
         code"
    
    * 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      alarmtimer: Ensure RTC module is not unloaded
      clocksource: Convert to using %pOF instead of full_name
      clocksource/drivers/bcm2835: Remove message for a memory allocation failure
      devicetree: bindings: Remove deprecated properties
      devicetree: bindings: Remove unused 32-bit CMT bindings
      devicetree: bindings: Deprecate property, update example
      devicetree: bindings: r8a73a4 and R-Car Gen2 CMT bindings
      devicetree: bindings: R-Car Gen2 CMT0 and CMT1 bindings
      devicetree: bindings: Remove sh7372 CMT binding
      clocksource/drivers/imx-tpm: Add imx tpm timer support
      dt-bindings: timer: Add nxp tpm timer binding doc
      posix-cpu-timers: Use dedicated helper to access rlimit values
      alarmtimer: Fix unavailable wake-up source in sysfs
      timekeeping: Use proper timekeeper for debug code
      kselftests: timers: set-timer-lat: Add one-shot timer test cases
      kselftests: timers: set-timer-lat: Tweak reporting when timer fires early
      kselftests: timers: freq-step: Fix build warning
      kselftests: timers: freq-step: Define ADJ_SETOFFSET if device has older kernel headers

commit 7b01463e51f6849d0787b24d06a62efcb243dd44
Merge: a1b5fd8fa29f 726fb6b4f2a8
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Sep 4 00:06:02 2017 +0200

    Merge branch 'pm-sleep'
    
    * pm-sleep:
      ACPI / PM: Check low power idle constraints for debug only
      PM / s2idle: Rename platform operations structure
      PM / s2idle: Rename ->enter_freeze to ->enter_s2idle
      PM / s2idle: Rename freeze_state enum and related items
      PM / s2idle: Rename PM_SUSPEND_FREEZE to PM_SUSPEND_TO_IDLE
      ACPI / PM: Prefer suspend-to-idle over S3 on some systems
      platform/x86: intel-hid: Wake up Dell Latitude 7275 from suspend-to-idle
      PM / suspend: Define pr_fmt() in suspend.c
      PM / suspend: Use mem_sleep_labels[] strings in messages
      PM / sleep: Put pm_test under CONFIG_PM_SLEEP_DEBUG
      PM / sleep: Check pm_wakeup_pending() in __device_suspend_noirq()
      PM / core: Add error argument to dpm_show_time()
      PM / core: Split dpm_suspend_noirq() and dpm_resume_noirq()
      PM / s2idle: Rearrange the main suspend-to-idle loop
      PM / timekeeping: Print debug messages when requested
      PM / sleep: Mark suspend/hibernation start and finish
      PM / sleep: Do not print debug messages by default
      PM / suspend: Export pm_suspend_target_state

commit a529bea8fa6b6dded6179c72d3385e0f7d0a4fde
Author: Stafford Horne <shorne@gmail.com>
Date:   Wed Jun 28 22:21:35 2017 +0900

    timekeeping: Use proper timekeeper for debug code
    
    When CONFIG_DEBUG_TIMEKEEPING is enabled the timekeeping_check_update()
    function will update status like last_warning and underflow_seen on the
    timekeeper.
    
    If there are issues found this state is used to rate limit the warnings
    that get printed.
    
    This rate limiting doesn't really really work if stored in real_tk as
    the shadow timekeeper is overwritten onto real_tk at the end of every
    update_wall_time() call, resetting last_warning and other statuses.
    
    Fix rate limiting by using the shadow_timekeeper for
    timekeeping_check_update().
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Miroslav Lichvar <mlichvar@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Stephen Boyd <stephen.boyd@linaro.org>
    Fixes: commit 57d05a93ada7 ("time: Rework debugging variables so they aren't global")
    Signed-off-by: Stafford Horne <shorne@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit faa04f63d82de2db5757469c6f07a1c4892d2bd4
Author: John Stultz <john.stultz@linaro.org>
Date:   Thu Jun 8 16:44:20 2017 -0700

    time: Fix clock->read(clock) race around clocksource changes
    
    [ Upstream commit ceea5e3771ed2378668455fa21861bead7504df5 ]
    
    In tests, which excercise switching of clocksources, a NULL
    pointer dereference can be observed on AMR64 platforms in the
    clocksource read() function:
    
    u64 clocksource_mmio_readl_down(struct clocksource *c)
    {
            return ~(u64)readl_relaxed(to_mmio_clksrc(c)->reg) & c->mask;
    }
    
    This is called from the core timekeeping code via:
    
            cycle_now = tkr->read(tkr->clock);
    
    tkr->read is the cached tkr->clock->read() function pointer.
    When the clocksource is changed then tkr->clock and tkr->read
    are updated sequentially. The code above results in a sequential
    load operation of tkr->read and tkr->clock as well.
    
    If the store to tkr->clock hits between the loads of tkr->read
    and tkr->clock, then the old read() function is called with the
    new clock pointer. As a consequence the read() function
    dereferences a different data structure and the resulting 'reg'
    pointer can point anywhere including NULL.
    
    This problem was introduced when the timekeeping code was
    switched over to use struct tk_read_base. Before that, it was
    theoretically possible as well when the compiler decided to
    reload clock in the code sequence:
    
         now = tk->clock->read(tk->clock);
    
    Add a helper function which avoids the issue by reading
    tk_read_base->clock once into a local variable clk and then issue
    the read function via clk->read(clk). This guarantees that the
    read() function always gets the proper clocksource pointer handed
    in.
    
    Since there is now no use for the tkr.read pointer, this patch
    also removes it, and to address stopping the fast timekeeper
    during suspend/resume, it introduces a dummy clocksource to use
    rather then just a dummy read function.
    
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Acked-by: Ingo Molnar <mingo@kernel.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Stephen Boyd <stephen.boyd@linaro.org>
    Cc: stable <stable@vger.kernel.org>
    Cc: Miroslav Lichvar <mlichvar@redhat.com>
    Cc: Daniel Mentz <danielmentz@google.com>
    Link: http://lkml.kernel.org/r/1496965462-20003-2-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Sasha Levin <alexander.levin@verizon.com>

commit 8e44a3517763a89e1135024eab12ef3b24819dc0
Author: Wanpeng Li <wanpeng.li@hotmail.com>
Date:   Thu Jun 29 19:15:11 2017 +0200

    sched/cputime: Accumulate vtime on top of nsec clocksource
    
    commit 2a42eb9594a1480b4ead9e036e06ee1290e5fa6d upstream.
    
    Currently the cputime source used by vtime is jiffies. When we cross
    a context boundary and jiffies have changed since the last snapshot, the
    pending cputime is accounted to the switching out context.
    
    This system works ok if the ticks are not aligned across CPUs. If they
    instead are aligned (ie: all fire at the same time) and the CPUs run in
    userspace, the jiffies change is only observed on tick exit and therefore
    the user cputime is accounted as system cputime. This is because the
    CPU that maintains timekeeping fires its tick at the same time as the
    others. It updates jiffies in the middle of the tick and the other CPUs
    see that update on IRQ exit:
    
        CPU 0 (timekeeper)                  CPU 1
        -------------------              -------------
                          jiffies = N
        ...                              run in userspace for a jiffy
        tick entry                       tick entry (sees jiffies = N)
        set jiffies = N + 1
        tick exit                        tick exit (sees jiffies = N + 1)
                                                    account 1 jiffy as stime
    
    Fix this with using a nanosec clock source instead of jiffies. The
    cputime is then accumulated and flushed everytime the pending delta
    reaches a jiffy in order to mitigate the accounting overhead.
    
    [ fweisbec: changelog, rebase on struct vtime, field renames, add delta
      on cputime readers, keep idle vtime as-is (low overhead accounting),
      harmonize clock sources. ]
    
    Suggested-by: Thomas Gleixner <tglx@linutronix.de>
    Reported-by: Luiz Capitulino <lcapitulino@redhat.com>
    Tested-by: Luiz Capitulino <lcapitulino@redhat.com>
    Signed-off-by: Wanpeng Li <wanpeng.li@hotmail.com>
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Rik van Riel <riel@redhat.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Wanpeng Li <kernellwp@gmail.com>
    Link: http://lkml.kernel.org/r/1498756511-11714-6-git-send-email-fweisbec@gmail.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Mel Gorman <mgorman@techsingularity.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit cb08e0353c249a27aed10c6f60a13871ae449d33
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Jul 23 00:03:43 2017 +0200

    PM / timekeeping: Print debug messages when requested
    
    The messages printed by tk_debug_account_sleep_time() are basically
    useful for system sleep debugging, so print them only when the other
    debug messages from the core suspend/hibernate code are enabled.
    
    While at it, make it clear that the messages from
    tk_debug_account_sleep_time() are about timekeeping suspend
    duration, because in general timekeeping may be suspeded and
    resumed for multiple times during one system suspend-resume cycle.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 5ab49e936a0a2d505bd1c93a9479e3d3ee67b7e7
Author: Michal Nazarewicz <mina86@mina86.com>
Date:   Mon Nov 9 14:58:10 2015 -0800

    kernel.h: make abs() work with 64-bit types
    
    commit c8299cb605b27dd5a49f7a69e48fd23e5a206298 upstream.
    
    For 64-bit arguments, the abs macro casts it to an int which leads to
    lost precision and may cause incorrect results.  To deal with 64-bit
    types abs64 macro has been introduced but still there are places where
    abs macro is used incorrectly.
    
    To deal with the problem, expand abs macro such that it operates on s64
    type when dealing with 64-bit types while still returning long when
    dealing with smaller types.
    
    This fixes one known bug (per John):
    
    The internal clocksteering done for fine-grained error correction uses a
    : logarithmic approximation, so any time adjtimex() adjusts the clock
    : steering, timekeeping_freqadjust() quickly approximates the correct clock
    : frequency over a series of ticks.
    :
    : Unfortunately, the logic in timekeeping_freqadjust(), introduced in commit
    : dc491596f639438 (Rework frequency adjustments to work better w/ nohz),
    : used the abs() function with a s64 error value to calculate the size of
    : the approximated adjustment to be made.
    :
    : Per include/linux/kernel.h: "abs() should not be used for 64-bit types
    : (s64, u64, long long) - use abs64()".
    :
    : Thus on 32-bit platforms, this resulted in the clocksteering to take a
    : quite dampended random walk trying to converge on the proper frequency,
    : which caused the adjustments to be made much slower then intended (most
    : easily observed when large adjustments are made).
    
    Signed-off-by: Michal Nazarewicz <mina86@mina86.com>
    Reported-by: John Stultz <john.stultz@linaro.org>
    Tested-by: John Stultz <john.stultz@linaro.org>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit 2a42eb9594a1480b4ead9e036e06ee1290e5fa6d
Author: Wanpeng Li <wanpeng.li@hotmail.com>
Date:   Thu Jun 29 19:15:11 2017 +0200

    sched/cputime: Accumulate vtime on top of nsec clocksource
    
    Currently the cputime source used by vtime is jiffies. When we cross
    a context boundary and jiffies have changed since the last snapshot, the
    pending cputime is accounted to the switching out context.
    
    This system works ok if the ticks are not aligned across CPUs. If they
    instead are aligned (ie: all fire at the same time) and the CPUs run in
    userspace, the jiffies change is only observed on tick exit and therefore
    the user cputime is accounted as system cputime. This is because the
    CPU that maintains timekeeping fires its tick at the same time as the
    others. It updates jiffies in the middle of the tick and the other CPUs
    see that update on IRQ exit:
    
        CPU 0 (timekeeper)                  CPU 1
        -------------------              -------------
                          jiffies = N
        ...                              run in userspace for a jiffy
        tick entry                       tick entry (sees jiffies = N)
        set jiffies = N + 1
        tick exit                        tick exit (sees jiffies = N + 1)
                                                    account 1 jiffy as stime
    
    Fix this with using a nanosec clock source instead of jiffies. The
    cputime is then accumulated and flushed everytime the pending delta
    reaches a jiffy in order to mitigate the accounting overhead.
    
    [ fweisbec: changelog, rebase on struct vtime, field renames, add delta
      on cputime readers, keep idle vtime as-is (low overhead accounting),
      harmonize clock sources. ]
    
    Suggested-by: Thomas Gleixner <tglx@linutronix.de>
    Reported-by: Luiz Capitulino <lcapitulino@redhat.com>
    Tested-by: Luiz Capitulino <lcapitulino@redhat.com>
    Signed-off-by: Wanpeng Li <wanpeng.li@hotmail.com>
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Rik van Riel <riel@redhat.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Wanpeng Li <kernellwp@gmail.com>
    Link: http://lkml.kernel.org/r/1498756511-11714-6-git-send-email-fweisbec@gmail.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 1b044f1cfc65a7d90b209dfabd57e16d98b58c5b
Merge: e0f3e8f14da8 2287d8664fe7
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jul 3 16:14:51 2017 -0700

    Merge branch 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer updates from Thomas Gleixner:
     "A rather large update for timers/timekeeping:
    
       - compat syscall consolidation (Al Viro)
    
       - Posix timer consolidation (Christoph Helwig / Thomas Gleixner)
    
       - Cleanup of the device tree based initialization for clockevents and
         clocksources (Daniel Lezcano)
    
       - Consolidation of the FTTMR010 clocksource/event driver (Linus
         Walleij)
    
       - The usual set of small fixes and updates all over the place"
    
    * 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (93 commits)
      timers: Make the cpu base lock raw
      clocksource/drivers/mips-gic-timer: Fix an error code in 'gic_clocksource_of_init()'
      clocksource/drivers/fsl_ftm_timer: Unmap region obtained by of_iomap
      clocksource/drivers/tcb_clksrc: Make IO endian agnostic
      clocksource/drivers/sun4i: Switch to the timer-of common init
      clocksource/drivers/timer-of: Fix invalid iomap check
      Revert "ktime: Simplify ktime_compare implementation"
      clocksource/drivers: Fix uninitialized variable use in timer_of_init
      kselftests: timers: Add test for frequency step
      kselftests: timers: Fix inconsistency-check to not ignore first timestamp
      time: Add warning about imminent deprecation of CONFIG_GENERIC_TIME_VSYSCALL_OLD
      time: Clean up CLOCK_MONOTONIC_RAW time handling
      posix-cpu-timers: Make timespec to nsec conversion safe
      itimer: Make timeval to nsec conversion range limited
      timers: Fix parameter description of try_to_del_timer_sync()
      ktime: Simplify ktime_compare implementation
      clocksource/drivers/fttmr010: Factor out clock read code
      clocksource/drivers/fttmr010: Implement delay timer
      clocksource/drivers: Add timer-of common init routine
      clocksource/drivers/tcb_clksrc: Save timer context on suspend/resume
      ...

commit 830146b6390a8f2cedbc7dc5e78331987c0418fa
Author: Will Deacon <will@kernel.org>
Date:   Thu Jun 8 16:44:22 2017 -0700

    arm64/vdso: Fix nsec handling for CLOCK_MONOTONIC_RAW
    
    commit dbb236c1ceb697a559e0694ac4c9e7b9131d0b16 upstream.
    
    Recently vDSO support for CLOCK_MONOTONIC_RAW was added in
    49eea433b326 ("arm64: Add support for CLOCK_MONOTONIC_RAW in
    clock_gettime() vDSO"). Noticing that the core timekeeping code
    never set tkr_raw.xtime_nsec, the vDSO implementation didn't
    bother exposing it via the data page and instead took the
    unshifted tk->raw_time.tv_nsec value which was then immediately
    shifted left in the vDSO code.
    
    Unfortunately, by accellerating the MONOTONIC_RAW clockid, it
    uncovered potential 1ns time inconsistencies caused by the
    timekeeping core not handing sub-ns resolution.
    
    Now that the core code has been fixed and is actually setting
    tkr_raw.xtime_nsec, we need to take that into account in the
    vDSO by adding it to the shifted raw_time value, in order to
    fix the user-visible inconsistency. Rather than do that at each
    use (and expand the data page in the process), instead perform
    the shift/addition operation when populating the data page and
    remove the shift from the vDSO code entirely.
    
    [jstultz: minor whitespace tweak, tried to improve commit
     message to make it more clear this fixes a regression]
    Reported-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Tested-by: Daniel Mentz <danielmentz@google.com>
    Acked-by: Kevin Brodsky <kevin.brodsky@arm.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Stephen Boyd <stephen.boyd@linaro.org>
    Cc: Miroslav Lichvar <mlichvar@redhat.com>
    Link: http://lkml.kernel.org/r/1496965462-20003-4-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit fa79bdd4c3e513d68bd13b40e7dc81b32376dc22
Author: John Stultz <john.stultz@linaro.org>
Date:   Thu Jun 8 16:44:20 2017 -0700

    time: Fix clock->read(clock) race around clocksource changes
    
    commit ceea5e3771ed2378668455fa21861bead7504df5 upstream.
    
    In tests, which excercise switching of clocksources, a NULL
    pointer dereference can be observed on AMR64 platforms in the
    clocksource read() function:
    
    u64 clocksource_mmio_readl_down(struct clocksource *c)
    {
            return ~(u64)readl_relaxed(to_mmio_clksrc(c)->reg) & c->mask;
    }
    
    This is called from the core timekeeping code via:
    
            cycle_now = tkr->read(tkr->clock);
    
    tkr->read is the cached tkr->clock->read() function pointer.
    When the clocksource is changed then tkr->clock and tkr->read
    are updated sequentially. The code above results in a sequential
    load operation of tkr->read and tkr->clock as well.
    
    If the store to tkr->clock hits between the loads of tkr->read
    and tkr->clock, then the old read() function is called with the
    new clock pointer. As a consequence the read() function
    dereferences a different data structure and the resulting 'reg'
    pointer can point anywhere including NULL.
    
    This problem was introduced when the timekeeping code was
    switched over to use struct tk_read_base. Before that, it was
    theoretically possible as well when the compiler decided to
    reload clock in the code sequence:
    
         now = tk->clock->read(tk->clock);
    
    Add a helper function which avoids the issue by reading
    tk_read_base->clock once into a local variable clk and then issue
    the read function via clk->read(clk). This guarantees that the
    read() function always gets the proper clocksource pointer handed
    in.
    
    Since there is now no use for the tkr.read pointer, this patch
    also removes it, and to address stopping the fast timekeeper
    during suspend/resume, it introduces a dummy clocksource to use
    rather then just a dummy read function.
    
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Acked-by: Ingo Molnar <mingo@kernel.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Stephen Boyd <stephen.boyd@linaro.org>
    Cc: Miroslav Lichvar <mlichvar@redhat.com>
    Cc: Daniel Mentz <danielmentz@google.com>
    Link: http://lkml.kernel.org/r/1496965462-20003-2-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit a7d29e276e1b9ec0d67f7788f356a9f81c4443ad
Author: Paul Mackerras <paulus@ozlabs.org>
Date:   Tue Jun 6 14:35:30 2017 +1000

    KVM: PPC: Book3S HV: Ignore timebase offset on POWER9 DD1
    
    commit 3d3efb68c19e539f0535c93a5258c1299270215f upstream.
    
    POWER9 DD1 has an erratum where writing to the TBU40 register, which
    is used to apply an offset to the timebase, can cause the timebase to
    lose counts.  This results in the timebase on some CPUs getting out of
    sync with other CPUs, which then results in misbehaviour of the
    timekeeping code.
    
    To work around the problem, we make KVM ignore the timebase offset for
    all guests on POWER9 DD1 machines.  This means that live migration
    cannot be supported on POWER9 DD1 machines.
    
    Signed-off-by: Paul Mackerras <paulus@ozlabs.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 99f66b5182a4f3d89563634f2fe156d4629b9c10
Author: Will Deacon <will@kernel.org>
Date:   Thu Jun 8 16:44:22 2017 -0700

    arm64/vdso: Fix nsec handling for CLOCK_MONOTONIC_RAW
    
    commit dbb236c1ceb697a559e0694ac4c9e7b9131d0b16 upstream.
    
    Recently vDSO support for CLOCK_MONOTONIC_RAW was added in
    49eea433b326 ("arm64: Add support for CLOCK_MONOTONIC_RAW in
    clock_gettime() vDSO"). Noticing that the core timekeeping code
    never set tkr_raw.xtime_nsec, the vDSO implementation didn't
    bother exposing it via the data page and instead took the
    unshifted tk->raw_time.tv_nsec value which was then immediately
    shifted left in the vDSO code.
    
    Unfortunately, by accellerating the MONOTONIC_RAW clockid, it
    uncovered potential 1ns time inconsistencies caused by the
    timekeeping core not handing sub-ns resolution.
    
    Now that the core code has been fixed and is actually setting
    tkr_raw.xtime_nsec, we need to take that into account in the
    vDSO by adding it to the shifted raw_time value, in order to
    fix the user-visible inconsistency. Rather than do that at each
    use (and expand the data page in the process), instead perform
    the shift/addition operation when populating the data page and
    remove the shift from the vDSO code entirely.
    
    [jstultz: minor whitespace tweak, tried to improve commit
     message to make it more clear this fixes a regression]
    Reported-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Tested-by: Daniel Mentz <danielmentz@google.com>
    Acked-by: Kevin Brodsky <kevin.brodsky@arm.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Stephen Boyd <stephen.boyd@linaro.org>
    Cc: Miroslav Lichvar <mlichvar@redhat.com>
    Link: http://lkml.kernel.org/r/1496965462-20003-4-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 02a37ccd6347897b9227c8ff7f11526321ec2048
Author: John Stultz <john.stultz@linaro.org>
Date:   Thu Jun 8 16:44:20 2017 -0700

    time: Fix clock->read(clock) race around clocksource changes
    
    commit ceea5e3771ed2378668455fa21861bead7504df5 upstream.
    
    In tests, which excercise switching of clocksources, a NULL
    pointer dereference can be observed on AMR64 platforms in the
    clocksource read() function:
    
    u64 clocksource_mmio_readl_down(struct clocksource *c)
    {
            return ~(u64)readl_relaxed(to_mmio_clksrc(c)->reg) & c->mask;
    }
    
    This is called from the core timekeeping code via:
    
            cycle_now = tkr->read(tkr->clock);
    
    tkr->read is the cached tkr->clock->read() function pointer.
    When the clocksource is changed then tkr->clock and tkr->read
    are updated sequentially. The code above results in a sequential
    load operation of tkr->read and tkr->clock as well.
    
    If the store to tkr->clock hits between the loads of tkr->read
    and tkr->clock, then the old read() function is called with the
    new clock pointer. As a consequence the read() function
    dereferences a different data structure and the resulting 'reg'
    pointer can point anywhere including NULL.
    
    This problem was introduced when the timekeeping code was
    switched over to use struct tk_read_base. Before that, it was
    theoretically possible as well when the compiler decided to
    reload clock in the code sequence:
    
         now = tk->clock->read(tk->clock);
    
    Add a helper function which avoids the issue by reading
    tk_read_base->clock once into a local variable clk and then issue
    the read function via clk->read(clk). This guarantees that the
    read() function always gets the proper clocksource pointer handed
    in.
    
    Since there is now no use for the tkr.read pointer, this patch
    also removes it, and to address stopping the fast timekeeper
    during suspend/resume, it introduces a dummy clocksource to use
    rather then just a dummy read function.
    
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Acked-by: Ingo Molnar <mingo@kernel.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Stephen Boyd <stephen.boyd@linaro.org>
    Cc: Miroslav Lichvar <mlichvar@redhat.com>
    Cc: Daniel Mentz <danielmentz@google.com>
    Link: http://lkml.kernel.org/r/1496965462-20003-2-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 1fecf3977defb3161ba194e5ddbdeca9be638377
Author: John Stultz <john.stultz@linaro.org>
Date:   Thu Jun 8 16:44:20 2017 -0700

    time: Fix clock->read(clock) race around clocksource changes
    
    commit ceea5e3771ed2378668455fa21861bead7504df5 upstream.
    
    In tests, which excercise switching of clocksources, a NULL
    pointer dereference can be observed on AMR64 platforms in the
    clocksource read() function:
    
    u64 clocksource_mmio_readl_down(struct clocksource *c)
    {
            return ~(u64)readl_relaxed(to_mmio_clksrc(c)->reg) & c->mask;
    }
    
    This is called from the core timekeeping code via:
    
            cycle_now = tkr->read(tkr->clock);
    
    tkr->read is the cached tkr->clock->read() function pointer.
    When the clocksource is changed then tkr->clock and tkr->read
    are updated sequentially. The code above results in a sequential
    load operation of tkr->read and tkr->clock as well.
    
    If the store to tkr->clock hits between the loads of tkr->read
    and tkr->clock, then the old read() function is called with the
    new clock pointer. As a consequence the read() function
    dereferences a different data structure and the resulting 'reg'
    pointer can point anywhere including NULL.
    
    This problem was introduced when the timekeeping code was
    switched over to use struct tk_read_base. Before that, it was
    theoretically possible as well when the compiler decided to
    reload clock in the code sequence:
    
         now = tk->clock->read(tk->clock);
    
    Add a helper function which avoids the issue by reading
    tk_read_base->clock once into a local variable clk and then issue
    the read function via clk->read(clk). This guarantees that the
    read() function always gets the proper clocksource pointer handed
    in.
    
    Since there is now no use for the tkr.read pointer, this patch
    also removes it, and to address stopping the fast timekeeper
    during suspend/resume, it introduces a dummy clocksource to use
    rather then just a dummy read function.
    
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Acked-by: Ingo Molnar <mingo@kernel.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Stephen Boyd <stephen.boyd@linaro.org>
    Cc: Miroslav Lichvar <mlichvar@redhat.com>
    Cc: Daniel Mentz <danielmentz@google.com>
    Link: http://lkml.kernel.org/r/1496965462-20003-2-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 5f4b37d8784da4217ede8f8bcd301686853dcf8c
Merge: 35d8d5d47c0e 8e6cec1c7c5a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Jun 25 11:59:19 2017 -0700

    Merge branch 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer fixes from Thomas Gleixner:
     "A few fixes for timekeeping and timers:
    
       - Plug a subtle race due to a missing READ_ONCE() in the timekeeping
         code where reloading of a pointer results in an inconsistent
         callback argument being supplied to the clocksource->read function.
    
       - Correct the CLOCK_MONOTONIC_RAW sub-nanosecond accounting in the
         time keeping core code, to prevent a possible discontuity.
    
       - Apply a similar fix to the arm64 vdso clock_gettime()
         implementation
    
       - Add missing includes to clocksource drivers, which relied on
         indirect includes which fails in certain configs.
    
       - Use the proper iomem pointer for read/iounmap in a probe function"
    
    * 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      arm64/vdso: Fix nsec handling for CLOCK_MONOTONIC_RAW
      time: Fix CLOCK_MONOTONIC_RAW sub-nanosecond accounting
      time: Fix clock->read(clock) race around clocksource changes
      clocksource: Explicitly include linux/clocksource.h when needed
      clocksource/drivers/arm_arch_timer: Fix read and iounmap of incorrect variable

commit d4cfb11387ee29ba4626546c676fd25c7abbbbb2
Author: Paul Mackerras <paulus@ozlabs.org>
Date:   Sat May 27 18:04:52 2017 +1000

    powerpc: Convert VDSO update function to use new update_vsyscall interface
    
    This converts the powerpc VDSO time update function to use the new
    interface introduced in commit 576094b7f0aa ("time: Introduce new
    GENERIC_TIME_VSYSCALL", 2012-09-11).  Where the old interface gave
    us the time as of the last update in seconds and whole nanoseconds,
    with the new interface we get the nanoseconds part effectively in
    a binary fixed-point format with tk->tkr_mono.shift bits to the
    right of the binary point.
    
    With the old interface, the fractional nanoseconds got truncated,
    meaning that the value returned by the VDSO clock_gettime function
    would have about 1ns of jitter in it compared to the value computed
    by the generic timekeeping code in the kernel.
    
    The powerpc VDSO time functions (clock_gettime and gettimeofday)
    already work in units of 2^-32 seconds, or 0.23283 ns, because that
    makes it simple to split the result into seconds and fractional
    seconds, and represent the fractional seconds in either microseconds
    or nanoseconds.  This is good enough accuracy for now, so this patch
    avoids changing how the VDSO works or the interface in the VDSO data
    page.
    
    This patch converts the powerpc update_vsyscall_old to be called
    update_vsyscall and use the new interface.  We convert the fractional
    second to units of 2^-32 seconds without truncating to whole nanoseconds.
    (There is still a conversion to whole nanoseconds for any legacy users
    of the vdso_data/systemcfg stamp_xtime field.)
    
    In addition, this improves the accuracy of the computation of tb_to_xs
    for those systems with high-frequency timebase clocks (>= 268.5 MHz)
    by doing the right shift in two parts, one before the multiplication and
    one after, rather than doing the right shift before the multiplication.
    (We can't do all of the right shift after the multiplication unless we
    use 128-bit arithmetic.)
    
    Signed-off-by: Paul Mackerras <paulus@ozlabs.org>
    Acked-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

commit 369adf04d80a7e179b9ea6d74cc01c233f142f47
Author: John Stultz <john.stultz@linaro.org>
Date:   Fri May 12 10:58:18 2017 -0700

    time: Add warning about imminent deprecation of CONFIG_GENERIC_TIME_VSYSCALL_OLD
    
    CONFIG_GENERIC_TIME_VSYSCALL_OLD was introduced five years ago
    to allow a transition from the old vsyscall implementations to
    the new method (which simplified internal accounting and made
    timekeeping more precise).
    
    However, PPC and IA64 have yet to make the transition, despite
    in some cases me sending test patches to try to help it along.
    
    http://patches.linaro.org/patch/30501/
    http://patches.linaro.org/patch/35412/
    
    If its helpful, my last pass at the patches can be found here:
    https://git.linaro.org/people/john.stultz/linux.git dev/oldvsyscall-cleanup
    
    So I think its time to set a deadline and make it clear this
    is going away. So this patch adds warnings about this
    functionality being dropped. Likely to be in v4.15.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Miroslav Lichvar <mlichvar@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Marcelo Tosatti <mtosatti@redhat.com>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Anton Blanchard <anton@samba.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Fenghua Yu <fenghua.yu@intel.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit dbb236c1ceb697a559e0694ac4c9e7b9131d0b16
Author: Will Deacon <will@kernel.org>
Date:   Thu Jun 8 16:44:22 2017 -0700

    arm64/vdso: Fix nsec handling for CLOCK_MONOTONIC_RAW
    
    Recently vDSO support for CLOCK_MONOTONIC_RAW was added in
    49eea433b326 ("arm64: Add support for CLOCK_MONOTONIC_RAW in
    clock_gettime() vDSO"). Noticing that the core timekeeping code
    never set tkr_raw.xtime_nsec, the vDSO implementation didn't
    bother exposing it via the data page and instead took the
    unshifted tk->raw_time.tv_nsec value which was then immediately
    shifted left in the vDSO code.
    
    Unfortunately, by accellerating the MONOTONIC_RAW clockid, it
    uncovered potential 1ns time inconsistencies caused by the
    timekeeping core not handing sub-ns resolution.
    
    Now that the core code has been fixed and is actually setting
    tkr_raw.xtime_nsec, we need to take that into account in the
    vDSO by adding it to the shifted raw_time value, in order to
    fix the user-visible inconsistency. Rather than do that at each
    use (and expand the data page in the process), instead perform
    the shift/addition operation when populating the data page and
    remove the shift from the vDSO code entirely.
    
    [jstultz: minor whitespace tweak, tried to improve commit
     message to make it more clear this fixes a regression]
    Reported-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Tested-by: Daniel Mentz <danielmentz@google.com>
    Acked-by: Kevin Brodsky <kevin.brodsky@arm.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Stephen Boyd <stephen.boyd@linaro.org>
    Cc: "stable #4 . 8+" <stable@vger.kernel.org>
    Cc: Miroslav Lichvar <mlichvar@redhat.com>
    Link: http://lkml.kernel.org/r/1496965462-20003-4-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit ceea5e3771ed2378668455fa21861bead7504df5
Author: John Stultz <john.stultz@linaro.org>
Date:   Thu Jun 8 16:44:20 2017 -0700

    time: Fix clock->read(clock) race around clocksource changes
    
    In tests, which excercise switching of clocksources, a NULL
    pointer dereference can be observed on AMR64 platforms in the
    clocksource read() function:
    
    u64 clocksource_mmio_readl_down(struct clocksource *c)
    {
            return ~(u64)readl_relaxed(to_mmio_clksrc(c)->reg) & c->mask;
    }
    
    This is called from the core timekeeping code via:
    
            cycle_now = tkr->read(tkr->clock);
    
    tkr->read is the cached tkr->clock->read() function pointer.
    When the clocksource is changed then tkr->clock and tkr->read
    are updated sequentially. The code above results in a sequential
    load operation of tkr->read and tkr->clock as well.
    
    If the store to tkr->clock hits between the loads of tkr->read
    and tkr->clock, then the old read() function is called with the
    new clock pointer. As a consequence the read() function
    dereferences a different data structure and the resulting 'reg'
    pointer can point anywhere including NULL.
    
    This problem was introduced when the timekeeping code was
    switched over to use struct tk_read_base. Before that, it was
    theoretically possible as well when the compiler decided to
    reload clock in the code sequence:
    
         now = tk->clock->read(tk->clock);
    
    Add a helper function which avoids the issue by reading
    tk_read_base->clock once into a local variable clk and then issue
    the read function via clk->read(clk). This guarantees that the
    read() function always gets the proper clocksource pointer handed
    in.
    
    Since there is now no use for the tkr.read pointer, this patch
    also removes it, and to address stopping the fast timekeeper
    during suspend/resume, it introduces a dummy clocksource to use
    rather then just a dummy read function.
    
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Acked-by: Ingo Molnar <mingo@kernel.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Stephen Boyd <stephen.boyd@linaro.org>
    Cc: stable <stable@vger.kernel.org>
    Cc: Miroslav Lichvar <mlichvar@redhat.com>
    Cc: Daniel Mentz <danielmentz@google.com>
    Link: http://lkml.kernel.org/r/1496965462-20003-2-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 3d3efb68c19e539f0535c93a5258c1299270215f
Author: Paul Mackerras <paulus@ozlabs.org>
Date:   Tue Jun 6 14:35:30 2017 +1000

    KVM: PPC: Book3S HV: Ignore timebase offset on POWER9 DD1
    
    POWER9 DD1 has an erratum where writing to the TBU40 register, which
    is used to apply an offset to the timebase, can cause the timebase to
    lose counts.  This results in the timebase on some CPUs getting out of
    sync with other CPUs, which then results in misbehaviour of the
    timekeeping code.
    
    To work around the problem, we make KVM ignore the timebase offset for
    all guests on POWER9 DD1 machines.  This means that live migration
    cannot be supported on POWER9 DD1 machines.
    
    Cc: stable@vger.kernel.org # v4.10+
    Signed-off-by: Paul Mackerras <paulus@ozlabs.org>

commit 12b28ba6d6164d3aa54b7e32032bcbd9b7c2a320
Author: Dave Gerlach <d-gerlach@ti.com>
Date:   Tue Mar 28 20:57:55 2017 -0500

    ARM: OMAP2+: timer: Add suspend-resume callbacks for clkevent device
    
    OMAP timer code registers two timers - one as clocksource
    and one as clockevent. Since AM33XX has only one usable timer
    in the WKUP domain one of the timers needs suspend-resume
    support to restore the configuration to pre-suspend state.
    
    commit adc78e6b9946 ("timekeeping: Add suspend and resume
    of clock event devices") introduced .suspend and .resume
    callbacks for clock event devices. Leverage these
    callbacks to have AM33XX clockevent timer behave properly
    across system suspend. Extend the use of the .suspend and
    .resume callbacks used by am335x clockevent to am437x as well.
    
    Signed-off-by: Dave Gerlach <d-gerlach@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

commit 26cbe162df3d0282e5108711663b8dcdafb1ad33
Author: Brian Norris <briannorris@chromium.org>
Date:   Tue Apr 4 19:32:05 2017 +0000

    clocksource/drivers/arm_arch_timer: Don't assume clock runs in suspend
    
    [ Upstream commit d8ec7595a013237f82d965dcf981571aeb41855b ]
    
    The ARM specifies that the system counter "must be implemented in an
    always-on power domain," and so we try to use the counter as a source of
    timekeeping across suspend/resume. Unfortunately, some SoCs (e.g.,
    Rockchip's RK3399) do not keep the counter ticking properly when
    switched from their high-power clock to the lower-power clock used in
    system suspend. Support this quirk by adding a new device tree property.
    
    Signed-off-by: Brian Norris <briannorris@chromium.org>
    Reviewed-by: Douglas Anderson <dianders@chromium.org>
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Signed-off-by: Sasha Levin <alexander.levin@verizon.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 5fc63f9577322d11019b6d357f73f5ce9031f263
Author: Nicholas Mc Guire <der.herr@hofr.at>
Date:   Fri Mar 24 20:03:35 2017 +0100

    timekeeping: Remove pointless conversion to bool
    
    interp_forward is type bool so assignment from a logical operation directly
    is sufficient.
    
    Signed-off-by: Nicholas Mc Guire <der.herr@hofr.at>
    Cc: "Christopher S. Hall" <christopher.s.hall@intel.com>
    Cc: John Stultz <john.stultz@linaro.org>
    Link: http://lkml.kernel.org/r/1490382215-30505-1-git-send-email-der.herr@hofr.at
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 9005615bafbe03075f4e4fe10874b7abe1918782
Merge: 016da20148a1 010704276865
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Mar 31 09:48:00 2017 +0200

    Merge branch 'fortglx/4.12/time' of https://git.linaro.org/people/john.stultz/linux into timers/core
    
    Pull timekeeping changes from John Stultz:
    
     Main changes are the initial steps of Nicoli's work to make the clockevent
     timers be corrected for NTP adjustments. Then a few smaller fixes that
     I've queued, and adding Stephen Boyd to the maintainers list for
     timekeeping.

commit e1c09219af364d17bcc432d86ad342bec1653dc5
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Feb 22 14:04:13 2017 -0800

    MAINTAINERS: Add Stephen Boyd as timekeeping reviewer
    
    After showing expertise and presenting on the timekeeping
    subsystem at ELC[1], Stephen clearly should be included in
    the maintainer list.
    
    [1] https://www.youtube.com/watch?v=Puv4mW55bF8
    
    Acked-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit b7eaf1aab9f8bd2e49fceed77ebc66c1b5800718
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Mar 22 00:08:50 2017 +0100

    cpufreq: schedutil: Avoid reducing frequency of busy CPUs prematurely
    
    The way the schedutil governor uses the PELT metric causes it to
    underestimate the CPU utilization in some cases.
    
    That can be easily demonstrated by running kernel compilation on
    a Sandy Bridge Intel processor, running turbostat in parallel with
    it and looking at the values written to the MSR_IA32_PERF_CTL
    register.  Namely, the expected result would be that when all CPUs
    were 100% busy, all of them would be requested to run in the maximum
    P-state, but observation shows that this clearly isn't the case.
    The CPUs run in the maximum P-state for a while and then are
    requested to run slower and go back to the maximum P-state after
    a while again.  That causes the actual frequency of the processor to
    visibly oscillate below the sustainable maximum in a jittery fashion
    which clearly is not desirable.
    
    That has been attributed to CPU utilization metric updates on task
    migration that cause the total utilization value for the CPU to be
    reduced by the utilization of the migrated task.  If that happens,
    the schedutil governor may see a CPU utilization reduction and will
    attempt to reduce the CPU frequency accordingly right away.  That
    may be premature, though, for example if the system is generally
    busy and there are other runnable tasks waiting to be run on that
    CPU already.
    
    This is unlikely to be an issue on systems where cpufreq policies are
    shared between multiple CPUs, because in those cases the policy
    utilization is computed as the maximum of the CPU utilization values
    over the whole policy and if that turns out to be low, reducing the
    frequency for the policy most likely is a good idea anyway.  On
    systems with one CPU per policy, however, it may affect performance
    adversely and even lead to increased energy consumption in some cases.
    
    On those systems it may be addressed by taking another utilization
    metric into consideration, like whether or not the CPU whose
    frequency is about to be reduced has been idle recently, because if
    that's not the case, the CPU is likely to be busy in the near future
    and its frequency should not be reduced.
    
    To that end, use the counter of idle calls in the timekeeping code.
    Namely, make the schedutil governor look at that counter for the
    current CPU every time before its frequency is about to be reduced.
    If the counter has not changed since the previous iteration of the
    governor computations for that CPU, the CPU has been busy for all
    that time and its frequency should not be decreased, so if the new
    frequency would be lower than the one set previously, the governor
    will skip the frequency update.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Joel Fernandes <joelaf@google.com>

commit 41d9830cd09f652936be95431cecfbac39ed09f7
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Sat Jan 21 12:59:05 2017 +0100

    ARM: gemini: DT for the Cortina Gemini SoC platforms
    
    This adds initial and compulsory device tree support to the
    Gemini ARMv4 platform.
    
    We are selecting a bunch of "absolute minimals" for getting a working
    system up with just device tree:
    
    - We select USE_OF for natural reasons or nothing works.
    
    - We select CLKSRC_OF and GEMINI_TIMER so we get timekeeping from
      the clocksource.
    
    - We select GPIO_GEMINI because these are used as irqchips, and
      for a generic driver it is not reasonable for those to have to
      select every possible irqchip in the world to work, the platform
      should simply provide the available irqchips.
    
    - We select a UART that can be exprected to work with
      SERIAL_OF_PLATFORM which is the name for an 8250 OF-probed
      serial port.
    
    - We select the syscon-based reset controller: it's not fun when
      "reboot" doesn't work because of Kconfig, so we just select
      POWER_RESET and POWER_RESET_SYSCON.
    
    - We perhaps a bit controversiallt select ARM_APPENDED_DTB, because
      this platform is using the ancient RedBoot, and can *NOT* be
      expected to upgrade its bootloaders. Appended device tree is
      simply how these devices have to work with device tree.
    
    Cc: Janos Laube <janos.dev@gmail.com>
    Cc: Paulius Zaleckas <paulius.zaleckas@gmail.com>
    Cc: Hans Ulli Kroll <ulli.kroll@googlemail.com>
    Cc: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

commit 93b5a9a7051e51ce50109046af0235268a261ba0
Author: Ingo Molnar <mingo@kernel.org>
Date:   Sun Feb 5 14:53:36 2017 +0100

    sched/headers, timekeeping: Move the timer tick function prototypes to <linux/timekeeping.h>
    
    Move the update_process_times() and xtime_update() prototypes to <linux/timekeeping.h>.
    
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 63cc9d6fca8c220c2406f1376100a9acb55197af
Author: Ingo Molnar <mingo@kernel.org>
Date:   Fri Feb 3 12:04:39 2017 +0100

    sched/headers, time/timekeeping: Move the xtime_update() prototype from <linux/sched.h> to <linux/time.h>
    
    This was in <linux/sched.h> only for hysterical raisins.
    
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 3f26b0c876bbfeed74325ada0329de53efbdf7a6
Merge: 74efe07bc38c 1572e45a924f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Feb 28 11:38:18 2017 -0800

    Merge branch 'perf-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull perf fixes from Ingo Molnar:
     "Misc fixes on the kernel and tooling side - nothing in particular
      stands out"
    
    * 'perf-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (21 commits)
      perf/core: Fix the perf_cpu_time_max_percent check
      perf/core: Fix perf_event_enable_on_exec() timekeeping (again)
      perf/core: Remove confusing comment and move put_ctx()
      perf record: Honor --quiet option properly
      perf annotate: Add -q/--quiet option
      perf diff: Add -q/--quiet option
      perf report: Add -q/--quiet option
      perf utils: Check verbose flag properly
      perf utils: Add perf_quiet_option()
      perf record: Add -a as default target
      perf stat: Add -a as default target
      perf tools: Fail on using multiple bits long terms without value
      perf tools: Move new_term arguments into struct parse_events_term template
      perf build: Add special fixdep cleaning rule
      perf tools: Replace _SC_NPROCESSORS_CONF with max_present_cpu in cpu_topology_map
      perf header: Make build_cpu_topology skip offline/absent CPUs
      perf cpumap: Add cpu__max_present_cpu()
      perf session: Fix DEBUG=1 build with clang
      tools lib traceevent: It's preempt not prempt
      perf python: Filter out -specs=/a/b/c from the python binding cc options
      ...

commit 7bbba0eb1af34694868d028b80475981f90e6bee
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Wed Feb 15 16:12:20 2017 +0100

    perf/core: Fix perf_event_enable_on_exec() timekeeping (again)
    
    Where commit:
    
      7fce250915ef ("perf: Fix scaling vs.  perf_event_enable_on_exec()")
    
    disabled the ctx-time a-priory, such that all events get enabled and
    scheduled at the time point in time, there is one hole in that patch,
    when no events do get enabled nothing re-enables the ctx-time.
    
    Reported-by: Ravi Bangoria <ravi.bangoria@linux.vnet.ibm.com>
    Reported-by: Anton Blanchard <anton@samba.org>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Cc: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Stephane Eranian <eranian@google.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Vince Weaver <vincent.weaver@maine.edu>
    Fixes: 7fce250915ef ("perf: Fix scaling vs.  perf_event_enable_on_exec()")
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 215d4d62ccfd585854b17f621342762784dde8c3
Author: Sergey Senozhatsky <sergey.senozhatsky.work@gmail.com>
Date:   Wed Feb 15 13:43:32 2017 +0900

    timekeeping: Use deferred printk() in debug code
    
    commit f222449c9dfad7c9bb8cb53e64c5c407b172ebbc upstream.
    
    We cannot do printk() from tk_debug_account_sleep_time(), because
    tk_debug_account_sleep_time() is called under tk_core seq lock.
    The reason why printk() is unsafe there is that console_sem may
    invoke scheduler (up()->wake_up_process()->activate_task()), which,
    in turn, can return back to timekeeping code, for instance, via
    get_time()->ktime_get(), deadlocking the system on tk_core seq lock.
    
    [   48.950592] ======================================================
    [   48.950622] [ INFO: possible circular locking dependency detected ]
    [   48.950622] 4.10.0-rc7-next-20170213+ #101 Not tainted
    [   48.950622] -------------------------------------------------------
    [   48.950622] kworker/0:0/3 is trying to acquire lock:
    [   48.950653]  (tk_core){----..}, at: [<c01cc624>] retrigger_next_event+0x4c/0x90
    [   48.950683]
                   but task is already holding lock:
    [   48.950683]  (hrtimer_bases.lock){-.-...}, at: [<c01cc610>] retrigger_next_event+0x38/0x90
    [   48.950714]
                   which lock already depends on the new lock.
    
    [   48.950714]
                   the existing dependency chain (in reverse order) is:
    [   48.950714]
                   -> #5 (hrtimer_bases.lock){-.-...}:
    [   48.950744]        _raw_spin_lock_irqsave+0x50/0x64
    [   48.950775]        lock_hrtimer_base+0x28/0x58
    [   48.950775]        hrtimer_start_range_ns+0x20/0x5c8
    [   48.950775]        __enqueue_rt_entity+0x320/0x360
    [   48.950805]        enqueue_rt_entity+0x2c/0x44
    [   48.950805]        enqueue_task_rt+0x24/0x94
    [   48.950836]        ttwu_do_activate+0x54/0xc0
    [   48.950836]        try_to_wake_up+0x248/0x5c8
    [   48.950836]        __setup_irq+0x420/0x5f0
    [   48.950836]        request_threaded_irq+0xdc/0x184
    [   48.950866]        devm_request_threaded_irq+0x58/0xa4
    [   48.950866]        omap_i2c_probe+0x530/0x6a0
    [   48.950897]        platform_drv_probe+0x50/0xb0
    [   48.950897]        driver_probe_device+0x1f8/0x2cc
    [   48.950897]        __driver_attach+0xc0/0xc4
    [   48.950927]        bus_for_each_dev+0x6c/0xa0
    [   48.950927]        bus_add_driver+0x100/0x210
    [   48.950927]        driver_register+0x78/0xf4
    [   48.950958]        do_one_initcall+0x3c/0x16c
    [   48.950958]        kernel_init_freeable+0x20c/0x2d8
    [   48.950958]        kernel_init+0x8/0x110
    [   48.950988]        ret_from_fork+0x14/0x24
    [   48.950988]
                   -> #4 (&rt_b->rt_runtime_lock){-.-...}:
    [   48.951019]        _raw_spin_lock+0x40/0x50
    [   48.951019]        rq_offline_rt+0x9c/0x2bc
    [   48.951019]        set_rq_offline.part.2+0x2c/0x58
    [   48.951049]        rq_attach_root+0x134/0x144
    [   48.951049]        cpu_attach_domain+0x18c/0x6f4
    [   48.951049]        build_sched_domains+0xba4/0xd80
    [   48.951080]        sched_init_smp+0x68/0x10c
    [   48.951080]        kernel_init_freeable+0x160/0x2d8
    [   48.951080]        kernel_init+0x8/0x110
    [   48.951080]        ret_from_fork+0x14/0x24
    [   48.951110]
                   -> #3 (&rq->lock){-.-.-.}:
    [   48.951110]        _raw_spin_lock+0x40/0x50
    [   48.951141]        task_fork_fair+0x30/0x124
    [   48.951141]        sched_fork+0x194/0x2e0
    [   48.951141]        copy_process.part.5+0x448/0x1a20
    [   48.951171]        _do_fork+0x98/0x7e8
    [   48.951171]        kernel_thread+0x2c/0x34
    [   48.951171]        rest_init+0x1c/0x18c
    [   48.951202]        start_kernel+0x35c/0x3d4
    [   48.951202]        0x8000807c
    [   48.951202]
                   -> #2 (&p->pi_lock){-.-.-.}:
    [   48.951232]        _raw_spin_lock_irqsave+0x50/0x64
    [   48.951232]        try_to_wake_up+0x30/0x5c8
    [   48.951232]        up+0x4c/0x60
    [   48.951263]        __up_console_sem+0x2c/0x58
    [   48.951263]        console_unlock+0x3b4/0x650
    [   48.951263]        vprintk_emit+0x270/0x474
    [   48.951293]        vprintk_default+0x20/0x28
    [   48.951293]        printk+0x20/0x30
    [   48.951324]        kauditd_hold_skb+0x94/0xb8
    [   48.951324]        kauditd_thread+0x1a4/0x56c
    [   48.951324]        kthread+0x104/0x148
    [   48.951354]        ret_from_fork+0x14/0x24
    [   48.951354]
                   -> #1 ((console_sem).lock){-.....}:
    [   48.951385]        _raw_spin_lock_irqsave+0x50/0x64
    [   48.951385]        down_trylock+0xc/0x2c
    [   48.951385]        __down_trylock_console_sem+0x24/0x80
    [   48.951385]        console_trylock+0x10/0x8c
    [   48.951416]        vprintk_emit+0x264/0x474
    [   48.951416]        vprintk_default+0x20/0x28
    [   48.951416]        printk+0x20/0x30
    [   48.951446]        tk_debug_account_sleep_time+0x5c/0x70
    [   48.951446]        __timekeeping_inject_sleeptime.constprop.3+0x170/0x1a0
    [   48.951446]        timekeeping_resume+0x218/0x23c
    [   48.951477]        syscore_resume+0x94/0x42c
    [   48.951477]        suspend_enter+0x554/0x9b4
    [   48.951477]        suspend_devices_and_enter+0xd8/0x4b4
    [   48.951507]        enter_state+0x934/0xbd4
    [   48.951507]        pm_suspend+0x14/0x70
    [   48.951507]        state_store+0x68/0xc8
    [   48.951538]        kernfs_fop_write+0xf4/0x1f8
    [   48.951538]        __vfs_write+0x1c/0x114
    [   48.951538]        vfs_write+0xa0/0x168
    [   48.951568]        SyS_write+0x3c/0x90
    [   48.951568]        __sys_trace_return+0x0/0x10
    [   48.951568]
                   -> #0 (tk_core){----..}:
    [   48.951599]        lock_acquire+0xe0/0x294
    [   48.951599]        ktime_get_update_offsets_now+0x5c/0x1d4
    [   48.951629]        retrigger_next_event+0x4c/0x90
    [   48.951629]        on_each_cpu+0x40/0x7c
    [   48.951629]        clock_was_set_work+0x14/0x20
    [   48.951660]        process_one_work+0x2b4/0x808
    [   48.951660]        worker_thread+0x3c/0x550
    [   48.951660]        kthread+0x104/0x148
    [   48.951690]        ret_from_fork+0x14/0x24
    [   48.951690]
                   other info that might help us debug this:
    
    [   48.951690] Chain exists of:
                     tk_core --> &rt_b->rt_runtime_lock --> hrtimer_bases.lock
    
    [   48.951721]  Possible unsafe locking scenario:
    
    [   48.951721]        CPU0                    CPU1
    [   48.951721]        ----                    ----
    [   48.951721]   lock(hrtimer_bases.lock);
    [   48.951751]                                lock(&rt_b->rt_runtime_lock);
    [   48.951751]                                lock(hrtimer_bases.lock);
    [   48.951751]   lock(tk_core);
    [   48.951782]
                    *** DEADLOCK ***
    
    [   48.951782] 3 locks held by kworker/0:0/3:
    [   48.951782]  #0:  ("events"){.+.+.+}, at: [<c0156590>] process_one_work+0x1f8/0x808
    [   48.951812]  #1:  (hrtimer_work){+.+...}, at: [<c0156590>] process_one_work+0x1f8/0x808
    [   48.951843]  #2:  (hrtimer_bases.lock){-.-...}, at: [<c01cc610>] retrigger_next_event+0x38/0x90
    [   48.951843]   stack backtrace:
    [   48.951873] CPU: 0 PID: 3 Comm: kworker/0:0 Not tainted 4.10.0-rc7-next-20170213+
    [   48.951904] Workqueue: events clock_was_set_work
    [   48.951904] [<c0110208>] (unwind_backtrace) from [<c010c224>] (show_stack+0x10/0x14)
    [   48.951934] [<c010c224>] (show_stack) from [<c04ca6c0>] (dump_stack+0xac/0xe0)
    [   48.951934] [<c04ca6c0>] (dump_stack) from [<c019b5cc>] (print_circular_bug+0x1d0/0x308)
    [   48.951965] [<c019b5cc>] (print_circular_bug) from [<c019d2a8>] (validate_chain+0xf50/0x1324)
    [   48.951965] [<c019d2a8>] (validate_chain) from [<c019ec18>] (__lock_acquire+0x468/0x7e8)
    [   48.951995] [<c019ec18>] (__lock_acquire) from [<c019f634>] (lock_acquire+0xe0/0x294)
    [   48.951995] [<c019f634>] (lock_acquire) from [<c01d0ea0>] (ktime_get_update_offsets_now+0x5c/0x1d4)
    [   48.952026] [<c01d0ea0>] (ktime_get_update_offsets_now) from [<c01cc624>] (retrigger_next_event+0x4c/0x90)
    [   48.952026] [<c01cc624>] (retrigger_next_event) from [<c01e4e24>] (on_each_cpu+0x40/0x7c)
    [   48.952056] [<c01e4e24>] (on_each_cpu) from [<c01cafc4>] (clock_was_set_work+0x14/0x20)
    [   48.952056] [<c01cafc4>] (clock_was_set_work) from [<c015664c>] (process_one_work+0x2b4/0x808)
    [   48.952087] [<c015664c>] (process_one_work) from [<c0157774>] (worker_thread+0x3c/0x550)
    [   48.952087] [<c0157774>] (worker_thread) from [<c015d644>] (kthread+0x104/0x148)
    [   48.952087] [<c015d644>] (kthread) from [<c0107830>] (ret_from_fork+0x14/0x24)
    
    Replace printk() with printk_deferred(), which does not call into
    the scheduler.
    
    Fixes: 0bf43f15db85 ("timekeeping: Prints the amounts of time spent during suspend")
    Reported-and-tested-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Cc: Petr Mladek <pmladek@suse.com>
    Cc: Sergey Senozhatsky <sergey.senozhatsky.work@gmail.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: "Rafael J . Wysocki" <rjw@rjwysocki.net>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: John Stultz <john.stultz@linaro.org>
    Link: http://lkml.kernel.org/r/20170215044332.30449-1-sergey.senozhatsky@gmail.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit b1517622f2524f531113b12c27b9a0ea69c38983
Author: Filipe Manana <fdmanana@suse.com>
Date:   Tue Feb 21 17:14:52 2017 +0000

    Btrfs: fix deadlock between dedup on same file and starting writeback
    
    If we are deduping two ranges of the same file we need to make sure that
    we lock all pages in ascending order, that is, lock first the pages from
    the range with lower offset and then the pages from the other range, as
    otherwise we can deadlock with a concurrent task that is starting delalloc
    (writeback). Example trace:
    
    [74073.052218] INFO: task kworker/u32:10:17997 blocked for more than 120 seconds.
    [74073.053889]       Tainted: G        W       4.9.0-rc7-btrfs-next-36+ #1
    [74073.055071] "echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
    [74073.056696] kworker/u32:10  D    0 17997      2 0x00000000
    [74073.058606] Workqueue: writeback wb_workfn (flush-btrfs-53176)
    [74073.061370]  ffff880031e79858 ffff8802159d2580 ffff880237004580 ffff880031e79240
    [74073.064784]  ffff88023f4978c0 ffffc9000817b638 ffffffff814c15e1 0000000000000000
    [74073.068386]  ffff88023f4978d8 ffff88023f4978c0 000000000017b620 ffff880031e79240
    [74073.071712] Call Trace:
    [74073.072884]  [<ffffffff814c15e1>] ? __schedule+0x48f/0x6f4
    [74073.075395]  [<ffffffff814c1c8b>] ? bit_wait+0x2f/0x2f
    [74073.077511]  [<ffffffff814c18d2>] schedule+0x8c/0xa0
    [74073.079440]  [<ffffffff814c4b36>] schedule_timeout+0x43/0xff
    [74073.081637]  [<ffffffff8110953e>] ? time_hardirqs_on+0x9/0x14
    [74073.083809]  [<ffffffff81095c67>] ? trace_hardirqs_on_caller+0x16/0x197
    [74073.086314]  [<ffffffff810bde98>] ? timekeeping_get_ns+0x1e/0x32
    [74073.100654]  [<ffffffff810be048>] ? ktime_get+0x41/0x52
    [74073.102619]  [<ffffffff814c10f0>] io_schedule_timeout+0xa0/0x102
    [74073.104771]  [<ffffffff814c10f0>] ? io_schedule_timeout+0xa0/0x102
    [74073.106969]  [<ffffffff814c1ca6>] bit_wait_io+0x1b/0x39
    [74073.108954]  [<ffffffff814c1fb8>] __wait_on_bit_lock+0x4f/0x99
    [74073.110981]  [<ffffffff8112b692>] __lock_page+0x6b/0x6d
    [74073.112833]  [<ffffffff8108ceb4>] ? autoremove_wake_function+0x3a/0x3a
    [74073.115010]  [<ffffffffa031178b>] lock_page+0x2f/0x32 [btrfs]
    [74073.116999]  [<ffffffffa0311d9f>] lock_delalloc_pages+0xc7/0x1a0 [btrfs]
    [74073.119243]  [<ffffffffa0313d15>] find_lock_delalloc_range+0xc3/0x1a4 [btrfs]
    [74073.121636]  [<ffffffffa0313e81>] writepage_delalloc.isra.31+0x8b/0x134 [btrfs]
    [74073.124229]  [<ffffffffa0315d69>] __extent_writepage+0x1c1/0x2bf [btrfs]
    [74073.126372]  [<ffffffffa03160f2>] extent_write_cache_pages.isra.30.constprop.49+0x28b/0x36c [btrfs]
    [74073.129371]  [<ffffffffa03165b9>] extent_writepages+0x4b/0x5c [btrfs]
    [74073.131440]  [<ffffffffa02fcb59>] ? insert_reserved_file_extent.constprop.42+0x261/0x261 [btrfs]
    [74073.134303]  [<ffffffff811b4ce4>] ? writeback_sb_inodes+0xe0/0x4a1
    [74073.136298]  [<ffffffffa02fab7f>] btrfs_writepages+0x28/0x2a [btrfs]
    [74073.138248]  [<ffffffff81138200>] do_writepages+0x23/0x2c
    [74073.139910]  [<ffffffff811b3cab>] __writeback_single_inode+0x105/0x6d2
    [74073.142003]  [<ffffffff811b4e96>] writeback_sb_inodes+0x292/0x4a1
    [74073.136298]  [<ffffffffa02fab7f>] btrfs_writepages+0x28/0x2a [btrfs]
    [74073.138248]  [<ffffffff81138200>] do_writepages+0x23/0x2c
    [74073.139910]  [<ffffffff811b3cab>] __writeback_single_inode+0x105/0x6d2
    [74073.142003]  [<ffffffff811b4e96>] writeback_sb_inodes+0x292/0x4a1
    [74073.143911]  [<ffffffff811b511b>] __writeback_inodes_wb+0x76/0xae
    [74073.145787]  [<ffffffff811b53ca>] wb_writeback+0x1cc/0x4d7
    [74073.147452]  [<ffffffff811b60cd>] wb_workfn+0x194/0x37d
    [74073.149084]  [<ffffffff811b60cd>] ? wb_workfn+0x194/0x37d
    [74073.150726]  [<ffffffff8106ce77>] ? process_one_work+0x154/0x4e4
    [74073.152694]  [<ffffffff8106cf96>] process_one_work+0x273/0x4e4
    [74073.154452]  [<ffffffff8106d6db>] worker_thread+0x1eb/0x2ca
    [74073.156138]  [<ffffffff8106d4f0>] ? rescuer_thread+0x2b6/0x2b6
    [74073.157837]  [<ffffffff81072a81>] kthread+0xd5/0xdd
    [74073.159339]  [<ffffffff810729ac>] ? __kthread_unpark+0x5a/0x5a
    [74073.161088]  [<ffffffff814c6257>] ret_from_fork+0x27/0x40
    [74073.162680] INFO: lockdep is turned off.
    [74073.163855] INFO: task do-dedup:30264 blocked for more than 120 seconds.
    [74073.181180]       Tainted: G        W       4.9.0-rc7-btrfs-next-36+ #1
    [74073.181180] "echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
    [74073.185296] fdm-stress      D    0 30264  29974 0x00000000
    [74073.186810]  ffff880089595118 ffff880211b8eac0 ffff880237030380 ffff880089594b00
    [74073.188998]  ffff88023f2978c0 ffffc900063abb68 ffffffff814c15e1 0000000000000000
    [74073.191070]  ffff88023f2978d8 ffff88023f2978c0 00000000003abb50 ffff880089594b00
    [74073.193286] Call Trace:
    [74073.193990]  [<ffffffff814c15e1>] ? __schedule+0x48f/0x6f4
    [74073.195418]  [<ffffffff814c1c8b>] ? bit_wait+0x2f/0x2f
    [74073.196796]  [<ffffffff814c18d2>] schedule+0x8c/0xa0
    [74073.198163]  [<ffffffff814c4b36>] schedule_timeout+0x43/0xff
    [74073.199621]  [<ffffffff81095df5>] ? trace_hardirqs_on+0xd/0xf
    [74073.201100]  [<ffffffff810bde98>] ? timekeeping_get_ns+0x1e/0x32
    [74073.202686]  [<ffffffff810be048>] ? ktime_get+0x41/0x52
    [74073.204051]  [<ffffffff814c10f0>] io_schedule_timeout+0xa0/0x102
    [74073.205585]  [<ffffffff814c10f0>] ? io_schedule_timeout+0xa0/0x102
    [74073.207123]  [<ffffffff814c1ca6>] bit_wait_io+0x1b/0x39
    [74073.208238]  [<ffffffff814c1fb8>] __wait_on_bit_lock+0x4f/0x99
    [74073.208871]  [<ffffffff8112b692>] __lock_page+0x6b/0x6d
    [74073.209430]  [<ffffffff8108ceb4>] ? autoremove_wake_function+0x3a/0x3a
    [74073.210101]  [<ffffffff8112b800>] lock_page+0x2f/0x32
    [74073.210636]  [<ffffffff8112c502>] pagecache_get_page+0x5e/0x153
    [74073.211270]  [<ffffffffa03257eb>] gather_extent_pages+0x4e/0x109 [btrfs]
    [74073.212166]  [<ffffffffa032a04c>] btrfs_dedupe_file_range+0x1e1/0x4dd [btrfs]
    [74073.213257]  [<ffffffff8118d9b5>] vfs_dedupe_file_range+0x1c1/0x221
    [74073.214086]  [<ffffffff8119e0c4>] do_vfs_ioctl+0x442/0x600
    [74073.214767]  [<ffffffff811a7874>] ? rcu_read_unlock+0x5b/0x5d
    [74073.215619]  [<ffffffff811a7953>] ? __fget+0x6b/0x77
    [74073.216338]  [<ffffffff8119e2d9>] SyS_ioctl+0x57/0x79
    [74073.217149]  [<ffffffff814c5fea>] entry_SYSCALL_64_fastpath+0x18/0xad
    [74073.218102]  [<ffffffff81109552>] ? time_hardirqs_off+0x9/0x14
    [74073.218968]  [<ffffffff810938ce>] ? trace_hardirqs_off_caller+0x1f/0xaa
    [74073.219938] INFO: lockdep is turned off.
    
    What happened was the following:
    
          CPU 1                                       CPU 2
    
                                                 btrfs_dedupe_file_range()
                                                   --> using same inode as source
                                                       and target
                                                   --> src range is [768K, 1Mb[
                                                   --> dst range is [0, 256K[
                                                  btrfs_cmp_data_prepare()
                                                   --> calls gather_extent_pages()
                                                       for range [768K, 1Mb[ and
                                                       locks all pages in that range
    
     do_writepages()
      btrfs_writepages()
       extent_writepages()
        extent_write_cache_pages()
         __extent_writepage()
          writepage_delalloc()
           find_lock_delalloc_range()
             --> finds range [0, 1Mb[
             lock_delalloc_pages()
              --> locks all pages in the
                  range [0, 768K[
              --> tries to lock page at
                  offset 768K
                    --> deadlock
    
                                                   --> calls gather_extent_pages()
                                                       to lock pages in the range
                                                       [0, 256K[
                                                        --> deadlock, task at CPU 1
                                                            already locked that
                                                            range and it's trying
                                                            to lock the range we
                                                            locked previously
    
    So fix this by making sure that during a dedup we always lock first the
    pages from the range with lower offset.
    
    Signed-off-by: Filipe Manana <fdmanana@suse.com>
    Signed-off-by: Chris Mason <clm@fb.com>

commit e602e700842104096e96a7deee453183e4ed278a
Merge: 3dd9c12726ff f222449c9dfa
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Feb 18 17:30:36 2017 -0800

    Merge branch 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer fixes from Thomas Gleixner:
     "Two small fixes::
    
       - Prevent deadlock on the tick broadcast lock. Found and fixed by
         Mike.
    
       - Stop using printk() in the timekeeping debug code to prevent a
         deadlock against the scheduler"
    
    * 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      timekeeping: Use deferred printk() in debug code
      tick/broadcast: Prevent deadlock on tick_broadcast_lock

commit f222449c9dfad7c9bb8cb53e64c5c407b172ebbc
Author: Sergey Senozhatsky <sergey.senozhatsky.work@gmail.com>
Date:   Wed Feb 15 13:43:32 2017 +0900

    timekeeping: Use deferred printk() in debug code
    
    We cannot do printk() from tk_debug_account_sleep_time(), because
    tk_debug_account_sleep_time() is called under tk_core seq lock.
    The reason why printk() is unsafe there is that console_sem may
    invoke scheduler (up()->wake_up_process()->activate_task()), which,
    in turn, can return back to timekeeping code, for instance, via
    get_time()->ktime_get(), deadlocking the system on tk_core seq lock.
    
    [   48.950592] ======================================================
    [   48.950622] [ INFO: possible circular locking dependency detected ]
    [   48.950622] 4.10.0-rc7-next-20170213+ #101 Not tainted
    [   48.950622] -------------------------------------------------------
    [   48.950622] kworker/0:0/3 is trying to acquire lock:
    [   48.950653]  (tk_core){----..}, at: [<c01cc624>] retrigger_next_event+0x4c/0x90
    [   48.950683]
                   but task is already holding lock:
    [   48.950683]  (hrtimer_bases.lock){-.-...}, at: [<c01cc610>] retrigger_next_event+0x38/0x90
    [   48.950714]
                   which lock already depends on the new lock.
    
    [   48.950714]
                   the existing dependency chain (in reverse order) is:
    [   48.950714]
                   -> #5 (hrtimer_bases.lock){-.-...}:
    [   48.950744]        _raw_spin_lock_irqsave+0x50/0x64
    [   48.950775]        lock_hrtimer_base+0x28/0x58
    [   48.950775]        hrtimer_start_range_ns+0x20/0x5c8
    [   48.950775]        __enqueue_rt_entity+0x320/0x360
    [   48.950805]        enqueue_rt_entity+0x2c/0x44
    [   48.950805]        enqueue_task_rt+0x24/0x94
    [   48.950836]        ttwu_do_activate+0x54/0xc0
    [   48.950836]        try_to_wake_up+0x248/0x5c8
    [   48.950836]        __setup_irq+0x420/0x5f0
    [   48.950836]        request_threaded_irq+0xdc/0x184
    [   48.950866]        devm_request_threaded_irq+0x58/0xa4
    [   48.950866]        omap_i2c_probe+0x530/0x6a0
    [   48.950897]        platform_drv_probe+0x50/0xb0
    [   48.950897]        driver_probe_device+0x1f8/0x2cc
    [   48.950897]        __driver_attach+0xc0/0xc4
    [   48.950927]        bus_for_each_dev+0x6c/0xa0
    [   48.950927]        bus_add_driver+0x100/0x210
    [   48.950927]        driver_register+0x78/0xf4
    [   48.950958]        do_one_initcall+0x3c/0x16c
    [   48.950958]        kernel_init_freeable+0x20c/0x2d8
    [   48.950958]        kernel_init+0x8/0x110
    [   48.950988]        ret_from_fork+0x14/0x24
    [   48.950988]
                   -> #4 (&rt_b->rt_runtime_lock){-.-...}:
    [   48.951019]        _raw_spin_lock+0x40/0x50
    [   48.951019]        rq_offline_rt+0x9c/0x2bc
    [   48.951019]        set_rq_offline.part.2+0x2c/0x58
    [   48.951049]        rq_attach_root+0x134/0x144
    [   48.951049]        cpu_attach_domain+0x18c/0x6f4
    [   48.951049]        build_sched_domains+0xba4/0xd80
    [   48.951080]        sched_init_smp+0x68/0x10c
    [   48.951080]        kernel_init_freeable+0x160/0x2d8
    [   48.951080]        kernel_init+0x8/0x110
    [   48.951080]        ret_from_fork+0x14/0x24
    [   48.951110]
                   -> #3 (&rq->lock){-.-.-.}:
    [   48.951110]        _raw_spin_lock+0x40/0x50
    [   48.951141]        task_fork_fair+0x30/0x124
    [   48.951141]        sched_fork+0x194/0x2e0
    [   48.951141]        copy_process.part.5+0x448/0x1a20
    [   48.951171]        _do_fork+0x98/0x7e8
    [   48.951171]        kernel_thread+0x2c/0x34
    [   48.951171]        rest_init+0x1c/0x18c
    [   48.951202]        start_kernel+0x35c/0x3d4
    [   48.951202]        0x8000807c
    [   48.951202]
                   -> #2 (&p->pi_lock){-.-.-.}:
    [   48.951232]        _raw_spin_lock_irqsave+0x50/0x64
    [   48.951232]        try_to_wake_up+0x30/0x5c8
    [   48.951232]        up+0x4c/0x60
    [   48.951263]        __up_console_sem+0x2c/0x58
    [   48.951263]        console_unlock+0x3b4/0x650
    [   48.951263]        vprintk_emit+0x270/0x474
    [   48.951293]        vprintk_default+0x20/0x28
    [   48.951293]        printk+0x20/0x30
    [   48.951324]        kauditd_hold_skb+0x94/0xb8
    [   48.951324]        kauditd_thread+0x1a4/0x56c
    [   48.951324]        kthread+0x104/0x148
    [   48.951354]        ret_from_fork+0x14/0x24
    [   48.951354]
                   -> #1 ((console_sem).lock){-.....}:
    [   48.951385]        _raw_spin_lock_irqsave+0x50/0x64
    [   48.951385]        down_trylock+0xc/0x2c
    [   48.951385]        __down_trylock_console_sem+0x24/0x80
    [   48.951385]        console_trylock+0x10/0x8c
    [   48.951416]        vprintk_emit+0x264/0x474
    [   48.951416]        vprintk_default+0x20/0x28
    [   48.951416]        printk+0x20/0x30
    [   48.951446]        tk_debug_account_sleep_time+0x5c/0x70
    [   48.951446]        __timekeeping_inject_sleeptime.constprop.3+0x170/0x1a0
    [   48.951446]        timekeeping_resume+0x218/0x23c
    [   48.951477]        syscore_resume+0x94/0x42c
    [   48.951477]        suspend_enter+0x554/0x9b4
    [   48.951477]        suspend_devices_and_enter+0xd8/0x4b4
    [   48.951507]        enter_state+0x934/0xbd4
    [   48.951507]        pm_suspend+0x14/0x70
    [   48.951507]        state_store+0x68/0xc8
    [   48.951538]        kernfs_fop_write+0xf4/0x1f8
    [   48.951538]        __vfs_write+0x1c/0x114
    [   48.951538]        vfs_write+0xa0/0x168
    [   48.951568]        SyS_write+0x3c/0x90
    [   48.951568]        __sys_trace_return+0x0/0x10
    [   48.951568]
                   -> #0 (tk_core){----..}:
    [   48.951599]        lock_acquire+0xe0/0x294
    [   48.951599]        ktime_get_update_offsets_now+0x5c/0x1d4
    [   48.951629]        retrigger_next_event+0x4c/0x90
    [   48.951629]        on_each_cpu+0x40/0x7c
    [   48.951629]        clock_was_set_work+0x14/0x20
    [   48.951660]        process_one_work+0x2b4/0x808
    [   48.951660]        worker_thread+0x3c/0x550
    [   48.951660]        kthread+0x104/0x148
    [   48.951690]        ret_from_fork+0x14/0x24
    [   48.951690]
                   other info that might help us debug this:
    
    [   48.951690] Chain exists of:
                     tk_core --> &rt_b->rt_runtime_lock --> hrtimer_bases.lock
    
    [   48.951721]  Possible unsafe locking scenario:
    
    [   48.951721]        CPU0                    CPU1
    [   48.951721]        ----                    ----
    [   48.951721]   lock(hrtimer_bases.lock);
    [   48.951751]                                lock(&rt_b->rt_runtime_lock);
    [   48.951751]                                lock(hrtimer_bases.lock);
    [   48.951751]   lock(tk_core);
    [   48.951782]
                    *** DEADLOCK ***
    
    [   48.951782] 3 locks held by kworker/0:0/3:
    [   48.951782]  #0:  ("events"){.+.+.+}, at: [<c0156590>] process_one_work+0x1f8/0x808
    [   48.951812]  #1:  (hrtimer_work){+.+...}, at: [<c0156590>] process_one_work+0x1f8/0x808
    [   48.951843]  #2:  (hrtimer_bases.lock){-.-...}, at: [<c01cc610>] retrigger_next_event+0x38/0x90
    [   48.951843]   stack backtrace:
    [   48.951873] CPU: 0 PID: 3 Comm: kworker/0:0 Not tainted 4.10.0-rc7-next-20170213+
    [   48.951904] Workqueue: events clock_was_set_work
    [   48.951904] [<c0110208>] (unwind_backtrace) from [<c010c224>] (show_stack+0x10/0x14)
    [   48.951934] [<c010c224>] (show_stack) from [<c04ca6c0>] (dump_stack+0xac/0xe0)
    [   48.951934] [<c04ca6c0>] (dump_stack) from [<c019b5cc>] (print_circular_bug+0x1d0/0x308)
    [   48.951965] [<c019b5cc>] (print_circular_bug) from [<c019d2a8>] (validate_chain+0xf50/0x1324)
    [   48.951965] [<c019d2a8>] (validate_chain) from [<c019ec18>] (__lock_acquire+0x468/0x7e8)
    [   48.951995] [<c019ec18>] (__lock_acquire) from [<c019f634>] (lock_acquire+0xe0/0x294)
    [   48.951995] [<c019f634>] (lock_acquire) from [<c01d0ea0>] (ktime_get_update_offsets_now+0x5c/0x1d4)
    [   48.952026] [<c01d0ea0>] (ktime_get_update_offsets_now) from [<c01cc624>] (retrigger_next_event+0x4c/0x90)
    [   48.952026] [<c01cc624>] (retrigger_next_event) from [<c01e4e24>] (on_each_cpu+0x40/0x7c)
    [   48.952056] [<c01e4e24>] (on_each_cpu) from [<c01cafc4>] (clock_was_set_work+0x14/0x20)
    [   48.952056] [<c01cafc4>] (clock_was_set_work) from [<c015664c>] (process_one_work+0x2b4/0x808)
    [   48.952087] [<c015664c>] (process_one_work) from [<c0157774>] (worker_thread+0x3c/0x550)
    [   48.952087] [<c0157774>] (worker_thread) from [<c015d644>] (kthread+0x104/0x148)
    [   48.952087] [<c015d644>] (kthread) from [<c0107830>] (ret_from_fork+0x14/0x24)
    
    Replace printk() with printk_deferred(), which does not call into
    the scheduler.
    
    Fixes: 0bf43f15db85 ("timekeeping: Prints the amounts of time spent during suspend")
    Reported-and-tested-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Cc: Petr Mladek <pmladek@suse.com>
    Cc: Sergey Senozhatsky <sergey.senozhatsky.work@gmail.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: "Rafael J . Wysocki" <rjw@rjwysocki.net>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: "[4.9+]" <stable@vger.kernel.org>
    Link: http://lkml.kernel.org/r/20170215044332.30449-1-sergey.senozhatsky@gmail.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 29955c9a00d52120ddbe249e658c2133c88d7645
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Dec 8 20:49:32 2016 +0000

    timekeeping_Force_unsigned_clocksource_to_nanoseconds_conversion
    
    [ Upstream commit 9c1645727b8fa90d07256fdfcc45bf831242a3ab ]
    
    The clocksource delta to nanoseconds conversion is using signed math, but
    the delta is unsigned. This makes the conversion space smaller than
    necessary and in case of a multiplication overflow the conversion can
    become negative. The conversion is done with scaled math:
    
        s64 nsec_delta = ((s64)clkdelta * clk->mult) >> clk->shift;
    
    Shifting a signed integer right obvioulsy preserves the sign, which has
    interesting consequences:
    
     - Time jumps backwards
    
     - __iter_div_u64_rem() which is used in one of the calling code pathes
       will take forever to piecewise calculate the seconds/nanoseconds part.
    
    This has been reported by several people with different scenarios:
    
    David observed that when stopping a VM with a debugger:
    
     "It was essentially the stopped by debugger case.  I forget exactly why,
      but the guest was being explicitly stopped from outside, it wasn't just
      scheduling lag.  I think it was something in the vicinity of 10 minutes
      stopped."
    
     When lifting the stop the machine went dead.
    
    The stopped by debugger case is not really interesting, but nevertheless it
    would be a good thing not to die completely.
    
    But this was also observed on a live system by Liav:
    
     "When the OS is too overloaded, delta will get a high enough value for the
      msb of the sum delta * tkr->mult + tkr->xtime_nsec to be set, and so
      after the shift the nsec variable will gain a value similar to
      0xffffffffff000000."
    
    Unfortunately this has been reintroduced recently with commit 6bd58f09e1d8
    ("time: Add cycles to nanoseconds translation"). It had been fixed a year
    ago already in commit 35a4933a8959 ("time: Avoid signed overflow in
    timekeeping_get_ns()").
    
    Though it's not surprising that the issue has been reintroduced because the
    function itself and the whole call chain uses s64 for the result and the
    propagation of it. The change in this recent commit is subtle:
    
       s64 nsec;
    
    -  nsec = (d * m + n) >> s:
    +  nsec = d * m + n;
    +  nsec >>= s;
    
    d being type of cycle_t adds another level of obfuscation.
    
    This wouldn't have happened if the previous change to unsigned computation
    would have made the 'nsec' variable u64 right away and a follow up patch
    had cleaned up the whole call chain.
    
    There have been patches submitted which basically did a revert of the above
    patch leaving everything else unchanged as signed. Back to square one. This
    spawned a admittedly pointless discussion about potential users which rely
    on the unsigned behaviour until someone pointed out that it had been fixed
    before. The changelogs of said patches added further confusion as they made
    finally false claims about the consequences for eventual users which expect
    signed results.
    
    Despite delta being cycle_t, aka. u64, it's very well possible to hand in
    a signed negative value and the signed computation will happily return the
    correct result. But nobody actually sat down and analyzed the code which
    was added as user after the propably unintended signed conversion.
    
    Though in sensitive code like this it's better to analyze it proper and
    make sure that nothing relies on this than hunting the subtle wreckage half
    a year later. After analyzing all call chains it stands that no caller can
    hand in a negative value (which actually would work due to the s64 cast)
    and rely on the signed math to do the right thing.
    
    Change the conversion function to unsigned math. The conversion of all call
    chains is done in a follow up patch.
    
    This solves the starvation issue, which was caused by the negative result,
    but it does not solve the underlying problem. It merily procrastinates
    it. When the timekeeper update is deferred long enough that the unsigned
    multiplication overflows, then time going backwards is observable again.
    
    It does neither solve the issue of clocksources with a small counter width
    which will wrap around possibly several times and cause random time stamps
    to be generated. But those are usually not found on systems used for
    virtualization, so this is likely a non issue.
    
    I took the liberty to claim authorship for this simply because
    analyzing all callsites and writing the changelog took substantially
    more time than just making the simple s/s64/u64/ change and ignore the
    rest.
    
    Fixes: 6bd58f09e1d8 ("time: Add cycles to nanoseconds translation")
    Reported-by: David Gibson <david@gibson.dropbear.id.au>
    Reported-by: Liav Rehana <liavr@mellanox.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: David Gibson <david@gibson.dropbear.id.au>
    Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: Parit Bhargava <prarit@redhat.com>
    Cc: Laurent Vivier <lvivier@redhat.com>
    Cc: "Christopher S. Hall" <christopher.s.hall@intel.com>
    Cc: Chris Metcalf <cmetcalf@mellanox.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: stable@vger.kernel.org
    Link: http://lkml.kernel.org/r/20161208204228.688545601@linutronix.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Sasha Levin <alexander.levin@verizon.com>

commit ca22975afa144d5bb648dcff22f598d623493e9f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Dec 8 20:49:32 2016 +0000

    timekeeping_Force_unsigned_clocksource_to_nanoseconds_conversion
    
    commit 9c1645727b8fa90d07256fdfcc45bf831242a3ab upstream.
    
    The clocksource delta to nanoseconds conversion is using signed math, but
    the delta is unsigned. This makes the conversion space smaller than
    necessary and in case of a multiplication overflow the conversion can
    become negative. The conversion is done with scaled math:
    
        s64 nsec_delta = ((s64)clkdelta * clk->mult) >> clk->shift;
    
    Shifting a signed integer right obvioulsy preserves the sign, which has
    interesting consequences:
    
     - Time jumps backwards
    
     - __iter_div_u64_rem() which is used in one of the calling code pathes
       will take forever to piecewise calculate the seconds/nanoseconds part.
    
    This has been reported by several people with different scenarios:
    
    David observed that when stopping a VM with a debugger:
    
     "It was essentially the stopped by debugger case.  I forget exactly why,
      but the guest was being explicitly stopped from outside, it wasn't just
      scheduling lag.  I think it was something in the vicinity of 10 minutes
      stopped."
    
     When lifting the stop the machine went dead.
    
    The stopped by debugger case is not really interesting, but nevertheless it
    would be a good thing not to die completely.
    
    But this was also observed on a live system by Liav:
    
     "When the OS is too overloaded, delta will get a high enough value for the
      msb of the sum delta * tkr->mult + tkr->xtime_nsec to be set, and so
      after the shift the nsec variable will gain a value similar to
      0xffffffffff000000."
    
    Unfortunately this has been reintroduced recently with commit 6bd58f09e1d8
    ("time: Add cycles to nanoseconds translation"). It had been fixed a year
    ago already in commit 35a4933a8959 ("time: Avoid signed overflow in
    timekeeping_get_ns()").
    
    Though it's not surprising that the issue has been reintroduced because the
    function itself and the whole call chain uses s64 for the result and the
    propagation of it. The change in this recent commit is subtle:
    
       s64 nsec;
    
    -  nsec = (d * m + n) >> s:
    +  nsec = d * m + n;
    +  nsec >>= s;
    
    d being type of cycle_t adds another level of obfuscation.
    
    This wouldn't have happened if the previous change to unsigned computation
    would have made the 'nsec' variable u64 right away and a follow up patch
    had cleaned up the whole call chain.
    
    There have been patches submitted which basically did a revert of the above
    patch leaving everything else unchanged as signed. Back to square one. This
    spawned a admittedly pointless discussion about potential users which rely
    on the unsigned behaviour until someone pointed out that it had been fixed
    before. The changelogs of said patches added further confusion as they made
    finally false claims about the consequences for eventual users which expect
    signed results.
    
    Despite delta being cycle_t, aka. u64, it's very well possible to hand in
    a signed negative value and the signed computation will happily return the
    correct result. But nobody actually sat down and analyzed the code which
    was added as user after the propably unintended signed conversion.
    
    Though in sensitive code like this it's better to analyze it proper and
    make sure that nothing relies on this than hunting the subtle wreckage half
    a year later. After analyzing all call chains it stands that no caller can
    hand in a negative value (which actually would work due to the s64 cast)
    and rely on the signed math to do the right thing.
    
    Change the conversion function to unsigned math. The conversion of all call
    chains is done in a follow up patch.
    
    This solves the starvation issue, which was caused by the negative result,
    but it does not solve the underlying problem. It merily procrastinates
    it. When the timekeeper update is deferred long enough that the unsigned
    multiplication overflows, then time going backwards is observable again.
    
    It does neither solve the issue of clocksources with a small counter width
    which will wrap around possibly several times and cause random time stamps
    to be generated. But those are usually not found on systems used for
    virtualization, so this is likely a non issue.
    
    I took the liberty to claim authorship for this simply because
    analyzing all callsites and writing the changelog took substantially
    more time than just making the simple s/s64/u64/ change and ignore the
    rest.
    
    Fixes: 6bd58f09e1d8 ("time: Add cycles to nanoseconds translation")
    Reported-by: David Gibson <david@gibson.dropbear.id.au>
    Reported-by: Liav Rehana <liavr@mellanox.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: David Gibson <david@gibson.dropbear.id.au>
    Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: Parit Bhargava <prarit@redhat.com>
    Cc: Laurent Vivier <lvivier@redhat.com>
    Cc: "Christopher S. Hall" <christopher.s.hall@intel.com>
    Cc: Chris Metcalf <cmetcalf@mellanox.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: John Stultz <john.stultz@linaro.org>
    Link: http://lkml.kernel.org/r/20161208204228.688545601@linutronix.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 61d0b7139cf97fedfd9176a3ae7d7ed560121c65
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Dec 8 20:49:32 2016 +0000

    timekeeping_Force_unsigned_clocksource_to_nanoseconds_conversion
    
    commit 9c1645727b8fa90d07256fdfcc45bf831242a3ab upstream.
    
    The clocksource delta to nanoseconds conversion is using signed math, but
    the delta is unsigned. This makes the conversion space smaller than
    necessary and in case of a multiplication overflow the conversion can
    become negative. The conversion is done with scaled math:
    
        s64 nsec_delta = ((s64)clkdelta * clk->mult) >> clk->shift;
    
    Shifting a signed integer right obvioulsy preserves the sign, which has
    interesting consequences:
    
     - Time jumps backwards
    
     - __iter_div_u64_rem() which is used in one of the calling code pathes
       will take forever to piecewise calculate the seconds/nanoseconds part.
    
    This has been reported by several people with different scenarios:
    
    David observed that when stopping a VM with a debugger:
    
     "It was essentially the stopped by debugger case.  I forget exactly why,
      but the guest was being explicitly stopped from outside, it wasn't just
      scheduling lag.  I think it was something in the vicinity of 10 minutes
      stopped."
    
     When lifting the stop the machine went dead.
    
    The stopped by debugger case is not really interesting, but nevertheless it
    would be a good thing not to die completely.
    
    But this was also observed on a live system by Liav:
    
     "When the OS is too overloaded, delta will get a high enough value for the
      msb of the sum delta * tkr->mult + tkr->xtime_nsec to be set, and so
      after the shift the nsec variable will gain a value similar to
      0xffffffffff000000."
    
    Unfortunately this has been reintroduced recently with commit 6bd58f09e1d8
    ("time: Add cycles to nanoseconds translation"). It had been fixed a year
    ago already in commit 35a4933a8959 ("time: Avoid signed overflow in
    timekeeping_get_ns()").
    
    Though it's not surprising that the issue has been reintroduced because the
    function itself and the whole call chain uses s64 for the result and the
    propagation of it. The change in this recent commit is subtle:
    
       s64 nsec;
    
    -  nsec = (d * m + n) >> s:
    +  nsec = d * m + n;
    +  nsec >>= s;
    
    d being type of cycle_t adds another level of obfuscation.
    
    This wouldn't have happened if the previous change to unsigned computation
    would have made the 'nsec' variable u64 right away and a follow up patch
    had cleaned up the whole call chain.
    
    There have been patches submitted which basically did a revert of the above
    patch leaving everything else unchanged as signed. Back to square one. This
    spawned a admittedly pointless discussion about potential users which rely
    on the unsigned behaviour until someone pointed out that it had been fixed
    before. The changelogs of said patches added further confusion as they made
    finally false claims about the consequences for eventual users which expect
    signed results.
    
    Despite delta being cycle_t, aka. u64, it's very well possible to hand in
    a signed negative value and the signed computation will happily return the
    correct result. But nobody actually sat down and analyzed the code which
    was added as user after the propably unintended signed conversion.
    
    Though in sensitive code like this it's better to analyze it proper and
    make sure that nothing relies on this than hunting the subtle wreckage half
    a year later. After analyzing all call chains it stands that no caller can
    hand in a negative value (which actually would work due to the s64 cast)
    and rely on the signed math to do the right thing.
    
    Change the conversion function to unsigned math. The conversion of all call
    chains is done in a follow up patch.
    
    This solves the starvation issue, which was caused by the negative result,
    but it does not solve the underlying problem. It merily procrastinates
    it. When the timekeeper update is deferred long enough that the unsigned
    multiplication overflows, then time going backwards is observable again.
    
    It does neither solve the issue of clocksources with a small counter width
    which will wrap around possibly several times and cause random time stamps
    to be generated. But those are usually not found on systems used for
    virtualization, so this is likely a non issue.
    
    I took the liberty to claim authorship for this simply because
    analyzing all callsites and writing the changelog took substantially
    more time than just making the simple s/s64/u64/ change and ignore the
    rest.
    
    Fixes: 6bd58f09e1d8 ("time: Add cycles to nanoseconds translation")
    Reported-by: David Gibson <david@gibson.dropbear.id.au>
    Reported-by: Liav Rehana <liavr@mellanox.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: David Gibson <david@gibson.dropbear.id.au>
    Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: Parit Bhargava <prarit@redhat.com>
    Cc: Laurent Vivier <lvivier@redhat.com>
    Cc: "Christopher S. Hall" <christopher.s.hall@intel.com>
    Cc: Chris Metcalf <cmetcalf@mellanox.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: John Stultz <john.stultz@linaro.org>
    Link: http://lkml.kernel.org/r/20161208204228.688545601@linutronix.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit e01b04be3eb00456d65278cfa56cfd8103872bfb
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Dec 8 20:49:32 2016 +0000

    timekeeping_Force_unsigned_clocksource_to_nanoseconds_conversion
    
    commit 9c1645727b8fa90d07256fdfcc45bf831242a3ab upstream.
    
    The clocksource delta to nanoseconds conversion is using signed math, but
    the delta is unsigned. This makes the conversion space smaller than
    necessary and in case of a multiplication overflow the conversion can
    become negative. The conversion is done with scaled math:
    
        s64 nsec_delta = ((s64)clkdelta * clk->mult) >> clk->shift;
    
    Shifting a signed integer right obvioulsy preserves the sign, which has
    interesting consequences:
    
     - Time jumps backwards
    
     - __iter_div_u64_rem() which is used in one of the calling code pathes
       will take forever to piecewise calculate the seconds/nanoseconds part.
    
    This has been reported by several people with different scenarios:
    
    David observed that when stopping a VM with a debugger:
    
     "It was essentially the stopped by debugger case.  I forget exactly why,
      but the guest was being explicitly stopped from outside, it wasn't just
      scheduling lag.  I think it was something in the vicinity of 10 minutes
      stopped."
    
     When lifting the stop the machine went dead.
    
    The stopped by debugger case is not really interesting, but nevertheless it
    would be a good thing not to die completely.
    
    But this was also observed on a live system by Liav:
    
     "When the OS is too overloaded, delta will get a high enough value for the
      msb of the sum delta * tkr->mult + tkr->xtime_nsec to be set, and so
      after the shift the nsec variable will gain a value similar to
      0xffffffffff000000."
    
    Unfortunately this has been reintroduced recently with commit 6bd58f09e1d8
    ("time: Add cycles to nanoseconds translation"). It had been fixed a year
    ago already in commit 35a4933a8959 ("time: Avoid signed overflow in
    timekeeping_get_ns()").
    
    Though it's not surprising that the issue has been reintroduced because the
    function itself and the whole call chain uses s64 for the result and the
    propagation of it. The change in this recent commit is subtle:
    
       s64 nsec;
    
    -  nsec = (d * m + n) >> s:
    +  nsec = d * m + n;
    +  nsec >>= s;
    
    d being type of cycle_t adds another level of obfuscation.
    
    This wouldn't have happened if the previous change to unsigned computation
    would have made the 'nsec' variable u64 right away and a follow up patch
    had cleaned up the whole call chain.
    
    There have been patches submitted which basically did a revert of the above
    patch leaving everything else unchanged as signed. Back to square one. This
    spawned a admittedly pointless discussion about potential users which rely
    on the unsigned behaviour until someone pointed out that it had been fixed
    before. The changelogs of said patches added further confusion as they made
    finally false claims about the consequences for eventual users which expect
    signed results.
    
    Despite delta being cycle_t, aka. u64, it's very well possible to hand in
    a signed negative value and the signed computation will happily return the
    correct result. But nobody actually sat down and analyzed the code which
    was added as user after the propably unintended signed conversion.
    
    Though in sensitive code like this it's better to analyze it proper and
    make sure that nothing relies on this than hunting the subtle wreckage half
    a year later. After analyzing all call chains it stands that no caller can
    hand in a negative value (which actually would work due to the s64 cast)
    and rely on the signed math to do the right thing.
    
    Change the conversion function to unsigned math. The conversion of all call
    chains is done in a follow up patch.
    
    This solves the starvation issue, which was caused by the negative result,
    but it does not solve the underlying problem. It merily procrastinates
    it. When the timekeeper update is deferred long enough that the unsigned
    multiplication overflows, then time going backwards is observable again.
    
    It does neither solve the issue of clocksources with a small counter width
    which will wrap around possibly several times and cause random time stamps
    to be generated. But those are usually not found on systems used for
    virtualization, so this is likely a non issue.
    
    I took the liberty to claim authorship for this simply because
    analyzing all callsites and writing the changelog took substantially
    more time than just making the simple s/s64/u64/ change and ignore the
    rest.
    
    Fixes: 6bd58f09e1d8 ("time: Add cycles to nanoseconds translation")
    Reported-by: David Gibson <david@gibson.dropbear.id.au>
    Reported-by: Liav Rehana <liavr@mellanox.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: David Gibson <david@gibson.dropbear.id.au>
    Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: Parit Bhargava <prarit@redhat.com>
    Cc: Laurent Vivier <lvivier@redhat.com>
    Cc: "Christopher S. Hall" <christopher.s.hall@intel.com>
    Cc: Chris Metcalf <cmetcalf@mellanox.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: John Stultz <john.stultz@linaro.org>
    Link: http://lkml.kernel.org/r/20161208204228.688545601@linutronix.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 40d9f82750044f846005d2ac4eec65e39c1c0f7c
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Wed Dec 7 14:33:23 2016 -0800

    timekeeping: Remove unused timekeeping_{get,set}_tai_offset()
    
    The last caller to timekeeping_set_tai_offset() was in commit
    0b5154fb9040 (timekeeping: Simplify tai updating from
    do_adjtimex, 2013-03-22) and the last caller to
    timekeeping_get_tai_offset() was in commit 76f4108892d9 (hrtimer:
    Cleanup hrtimer accessors to the timekepeing state, 2014-07-16).
    Remove these unused functions now that we handle TAI offsets
    differently.
    
    Cc: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 3ddc76dfc786cc6f87852693227fb0b1f124f807
Merge: b272f732f888 1f3a8e49d8f2
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Dec 25 14:30:04 2016 -0800

    Merge branch 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer type cleanups from Thomas Gleixner:
     "This series does a tree wide cleanup of types related to
      timers/timekeeping.
    
       - Get rid of cycles_t and use a plain u64. The type is not really
         helpful and caused more confusion than clarity
    
       - Get rid of the ktime union. The union has become useless as we use
         the scalar nanoseconds storage unconditionally now. The 32bit
         timespec alike storage got removed due to the Y2038 limitations
         some time ago.
    
         That leaves the odd union access around for no reason. Clean it up.
    
      Both changes have been done with coccinelle and a small amount of
      manual mopping up"
    
    * 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      ktime: Get rid of ktime_equal()
      ktime: Cleanup ktime_set() usage
      ktime: Get rid of the union
      clocksource: Use a plain u64 instead of cycle_t

commit 9465d9cc31fa732089cd8bec9f1bdfcdc174a5ce
Merge: e71c3978d6f9 c029a2bec66e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Dec 12 19:56:15 2016 -0800

    Merge branch 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer updates from Thomas Gleixner:
     "The time/timekeeping/timer folks deliver with this update:
    
       - Fix a reintroduced signed/unsigned issue and cleanup the whole
         signed/unsigned mess in the timekeeping core so this wont happen
         accidentaly again.
    
       - Add a new trace clock based on boot time
    
       - Prevent injection of random sleep times when PM tracing abuses the
         RTC for storage
    
       - Make posix timers configurable for real tiny systems
    
       - Add tracepoints for the alarm timer subsystem so timer based
         suspend wakeups can be instrumented
    
       - The usual pile of fixes and updates to core and drivers"
    
    * 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (23 commits)
      timekeeping: Use mul_u64_u32_shr() instead of open coding it
      timekeeping: Get rid of pointless typecasts
      timekeeping: Make the conversion call chain consistently unsigned
      timekeeping_Force_unsigned_clocksource_to_nanoseconds_conversion
      alarmtimer: Add tracepoints for alarm timers
      trace: Update documentation for mono, mono_raw and boot clock
      trace: Add an option for boot clock as trace clock
      timekeeping: Add a fast and NMI safe boot clock
      timekeeping/clocksource_cyc2ns: Document intended range limitation
      timekeeping: Ignore the bogus sleep time if pm_trace is enabled
      selftests/timers: Fix spelling mistake "Asyncrhonous" -> "Asynchronous"
      clocksource/drivers/bcm2835_timer: Unmap region obtained by of_iomap
      clocksource/drivers/arm_arch_timer: Map frame with of_io_request_and_map()
      arm64: dts: rockchip: Arch counter doesn't tick in system suspend
      clocksource/drivers/arm_arch_timer: Don't assume clock runs in suspend
      posix-timers: Make them configurable
      posix_cpu_timers: Move the add_device_randomness() call to a proper place
      timer: Move sys_alarm from timer.c to itimer.c
      ptp_clock: Allow for it to be optional
      Kconfig: Regenerate *.c_shipped files after previous changes
      ...

commit c029a2bec66e42e57538cb65e28618baf6a4b311
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Dec 8 20:49:38 2016 +0000

    timekeeping: Use mul_u64_u32_shr() instead of open coding it
    
    The resume code must deal with a clocksource delta which is potentially big
    enough to overflow the 64bit mult.
    
    Replace the open coded handling with the proper function.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: David Gibson <david@gibson.dropbear.id.au>
    Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: Parit Bhargava <prarit@redhat.com>
    Cc: Laurent Vivier <lvivier@redhat.com>
    Cc: "Christopher S. Hall" <christopher.s.hall@intel.com>
    Cc: Chris Metcalf <cmetcalf@mellanox.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Liav Rehana <liavr@mellanox.com>
    Cc: John Stultz <john.stultz@linaro.org>
    Link: http://lkml.kernel.org/r/20161208204228.921674404@linutronix.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit cbd99e3b289e43000c29aa4aa9b94b394cdc68bd
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Dec 8 20:49:36 2016 +0000

    timekeeping: Get rid of pointless typecasts
    
    cycle_t is defined as u64, so casting it to u64 is a pointless and
    confusing exercise. cycle_t should simply go away and be replaced with a
    plain u64 to avoid further confusion.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: David Gibson <david@gibson.dropbear.id.au>
    Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: Parit Bhargava <prarit@redhat.com>
    Cc: Laurent Vivier <lvivier@redhat.com>
    Cc: "Christopher S. Hall" <christopher.s.hall@intel.com>
    Cc: Chris Metcalf <cmetcalf@mellanox.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Liav Rehana <liavr@mellanox.com>
    Cc: John Stultz <john.stultz@linaro.org>
    Link: http://lkml.kernel.org/r/20161208204228.844699737@linutronix.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit acc89612a70e370a5640fd77a83f15b7b94d85e4
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Dec 8 20:49:34 2016 +0000

    timekeeping: Make the conversion call chain consistently unsigned
    
    Propagating a unsigned value through signed variables and functions makes
    absolutely no sense and is just prone to (re)introduce subtle signed
    vs. unsigned issues as happened recently.
    
    Clean it up.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: David Gibson <david@gibson.dropbear.id.au>
    Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: Parit Bhargava <prarit@redhat.com>
    Cc: Laurent Vivier <lvivier@redhat.com>
    Cc: "Christopher S. Hall" <christopher.s.hall@intel.com>
    Cc: Chris Metcalf <cmetcalf@mellanox.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Liav Rehana <liavr@mellanox.com>
    Cc: John Stultz <john.stultz@linaro.org>
    Link: http://lkml.kernel.org/r/20161208204228.765843099@linutronix.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 9c1645727b8fa90d07256fdfcc45bf831242a3ab
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Dec 8 20:49:32 2016 +0000

    timekeeping_Force_unsigned_clocksource_to_nanoseconds_conversion
    
    The clocksource delta to nanoseconds conversion is using signed math, but
    the delta is unsigned. This makes the conversion space smaller than
    necessary and in case of a multiplication overflow the conversion can
    become negative. The conversion is done with scaled math:
    
        s64 nsec_delta = ((s64)clkdelta * clk->mult) >> clk->shift;
    
    Shifting a signed integer right obvioulsy preserves the sign, which has
    interesting consequences:
    
     - Time jumps backwards
    
     - __iter_div_u64_rem() which is used in one of the calling code pathes
       will take forever to piecewise calculate the seconds/nanoseconds part.
    
    This has been reported by several people with different scenarios:
    
    David observed that when stopping a VM with a debugger:
    
     "It was essentially the stopped by debugger case.  I forget exactly why,
      but the guest was being explicitly stopped from outside, it wasn't just
      scheduling lag.  I think it was something in the vicinity of 10 minutes
      stopped."
    
     When lifting the stop the machine went dead.
    
    The stopped by debugger case is not really interesting, but nevertheless it
    would be a good thing not to die completely.
    
    But this was also observed on a live system by Liav:
    
     "When the OS is too overloaded, delta will get a high enough value for the
      msb of the sum delta * tkr->mult + tkr->xtime_nsec to be set, and so
      after the shift the nsec variable will gain a value similar to
      0xffffffffff000000."
    
    Unfortunately this has been reintroduced recently with commit 6bd58f09e1d8
    ("time: Add cycles to nanoseconds translation"). It had been fixed a year
    ago already in commit 35a4933a8959 ("time: Avoid signed overflow in
    timekeeping_get_ns()").
    
    Though it's not surprising that the issue has been reintroduced because the
    function itself and the whole call chain uses s64 for the result and the
    propagation of it. The change in this recent commit is subtle:
    
       s64 nsec;
    
    -  nsec = (d * m + n) >> s:
    +  nsec = d * m + n;
    +  nsec >>= s;
    
    d being type of cycle_t adds another level of obfuscation.
    
    This wouldn't have happened if the previous change to unsigned computation
    would have made the 'nsec' variable u64 right away and a follow up patch
    had cleaned up the whole call chain.
    
    There have been patches submitted which basically did a revert of the above
    patch leaving everything else unchanged as signed. Back to square one. This
    spawned a admittedly pointless discussion about potential users which rely
    on the unsigned behaviour until someone pointed out that it had been fixed
    before. The changelogs of said patches added further confusion as they made
    finally false claims about the consequences for eventual users which expect
    signed results.
    
    Despite delta being cycle_t, aka. u64, it's very well possible to hand in
    a signed negative value and the signed computation will happily return the
    correct result. But nobody actually sat down and analyzed the code which
    was added as user after the propably unintended signed conversion.
    
    Though in sensitive code like this it's better to analyze it proper and
    make sure that nothing relies on this than hunting the subtle wreckage half
    a year later. After analyzing all call chains it stands that no caller can
    hand in a negative value (which actually would work due to the s64 cast)
    and rely on the signed math to do the right thing.
    
    Change the conversion function to unsigned math. The conversion of all call
    chains is done in a follow up patch.
    
    This solves the starvation issue, which was caused by the negative result,
    but it does not solve the underlying problem. It merily procrastinates
    it. When the timekeeper update is deferred long enough that the unsigned
    multiplication overflows, then time going backwards is observable again.
    
    It does neither solve the issue of clocksources with a small counter width
    which will wrap around possibly several times and cause random time stamps
    to be generated. But those are usually not found on systems used for
    virtualization, so this is likely a non issue.
    
    I took the liberty to claim authorship for this simply because
    analyzing all callsites and writing the changelog took substantially
    more time than just making the simple s/s64/u64/ change and ignore the
    rest.
    
    Fixes: 6bd58f09e1d8 ("time: Add cycles to nanoseconds translation")
    Reported-by: David Gibson <david@gibson.dropbear.id.au>
    Reported-by: Liav Rehana <liavr@mellanox.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: David Gibson <david@gibson.dropbear.id.au>
    Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: Parit Bhargava <prarit@redhat.com>
    Cc: Laurent Vivier <lvivier@redhat.com>
    Cc: "Christopher S. Hall" <christopher.s.hall@intel.com>
    Cc: Chris Metcalf <cmetcalf@mellanox.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: stable@vger.kernel.org
    Link: http://lkml.kernel.org/r/20161208204228.688545601@linutronix.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 948a5312f41658f7b76a598a139ef1f4dea09ca9
Author: Joel Fernandes <joelaf@google.com>
Date:   Mon Nov 28 14:35:22 2016 -0800

    timekeeping: Add a fast and NMI safe boot clock
    
    This boot clock can be used as a tracing clock and will account for
    suspend time.
    
    To keep it NMI safe since we're accessing from tracing, we're not using a
    separate timekeeper with updates to monotonic clock and boot offset
    protected with seqlocks. This has the following minor side effects:
    
    (1) Its possible that a timestamp be taken after the boot offset is updated
    but before the timekeeper is updated. If this happens, the new boot offset
    is added to the old timekeeping making the clock appear to update slightly
    earlier:
       CPU 0                                        CPU 1
       timekeeping_inject_sleeptime64()
       __timekeeping_inject_sleeptime(tk, delta);
                                                    timestamp();
       timekeeping_update(tk, TK_CLEAR_NTP...);
    
    (2) On 32-bit systems, the 64-bit boot offset (tk->offs_boot) may be
    partially updated.  Since the tk->offs_boot update is a rare event, this
    should be a rare occurrence which postprocessing should be able to handle.
    
    Signed-off-by: Joel Fernandes <joelaf@google.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Link: http://lkml.kernel.org/r/1480372524-15181-6-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit ec4101e8903e318b9fd4e3bbf72b1eaba53c64e1
Author: Chris Metcalf <cmetcalf@mellanox.com>
Date:   Mon Nov 28 14:35:20 2016 -0800

    timekeeping/clocksource_cyc2ns: Document intended range limitation
    
    The "cycles" argument should not be an absolute clocksource cycle
    value, as the implementation's arithmetic will overflow relatively
    easily with wide (64 bit) clocksource counters.
    
    For performance, the implementation is simple and fast, since the
    function is intended for only relatively small delta values of
    clocksource cycles.
    
    [jstultz: Fixed up to merge against HEAD & commit message tweaks,
     also included rewording suggestion by Ingo]
    Signed-off-by: Chris Metcalf <cmetcalf@mellanox.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Link: http://lkml.kernel.org/r/1480372524-15181-4-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit ba58d1020a54933c6b087a3107661c8513556cb8
Author: Chen Yu <yu.c.chen@intel.com>
Date:   Mon Nov 28 14:35:19 2016 -0800

    timekeeping: Ignore the bogus sleep time if pm_trace is enabled
    
    Power management suspend/resume tracing (ab)uses the RTC to store
    suspend/resume information persistently. As a consequence the RTC value is
    clobbered when timekeeping is resumed and tries to inject the sleep time.
    
    Commit a4f8f6667f09 ("timekeeping: Cap array access in timekeeping_debug")
    plugged a out of bounds array access in the timekeeping debug code which
    was caused by the clobbered RTC value, but we still use the clobbered RTC
    value for sleep time injection into kernel timekeeping, which will result
    in random adjustments depending on the stored "hash" value.
    
    To prevent this keep track of the RTC clobbering and ignore the invalid RTC
    timestamp at resume. If the system resumed successfully clear the flag,
    which marks the RTC as unusable, warn the user about the RTC clobber and
    recommend to adjust the RTC with 'ntpdate' or 'rdate'.
    
    [jstultz: Fixed up pr_warn formating, and implemented suggestions from Ingo]
    [ tglx: Rewrote changelog ]
    
    Originally-from: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Chen Yu <yu.c.chen@intel.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Xunlei Pang <xlpang@redhat.com>
    Cc: Len Brown <lenb@kernel.org>
    Link: http://lkml.kernel.org/r/1480372524-15181-3-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit a94e502c22b61072f808f53392a8433bc948b03d
Author: Sudeep Holla <Sudeep.Holla@arm.com>
Date:   Thu Nov 10 14:24:33 2016 +0000

    cpuidle: dt: assign ->enter_freeze to same as ->enter callback function
    
    enter_freeze() callback is expected atleast to do the same as enter()
    but it has to guarantee that interrupts aren't enabled at any point
    in its execution, as the tick is frozen.
    
    CPUs execute ->enter_freeze with the local tick or entire timekeeping
    suspended, so it must not re-enable interrupts at any point (even
    temporarily) or attempt to change states of clock event devices.
    
    It will be called when the system goes to suspend-to-idle and will
    reduce power usage because CPUs won't be awaken for unnecessary IRQs
    (i.e. woken up only on IRQs from "wakeup sources")
    
    We can reuse the same code for both the enter() and enter_freeze()
    callbacks as along as they don't re-enable interrupts. Only "coupled"
    cpuidle mechanism enables interrupts and doing that with timekeeping
    suspended is generally not safe.
    
    Since this generic DT based idle driver doesn't support "coupled"
    states, it is safe to assume that the interrupts are not re-enabled.
    
    This patch assign enter_freeze to same as enter callback function which
    helps to save power without any intermittent spurious wakeups from
    suspend-to-idle.
    
    Signed-off-by: Sudeep Holla <sudeep.holla@arm.com>
    Tested-by: Andy Gross <andy.gross@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit d8ec7595a013237f82d965dcf981571aeb41855b
Author: Brian Norris <briannorris@chromium.org>
Date:   Tue Oct 4 11:12:09 2016 -0700

    clocksource/drivers/arm_arch_timer: Don't assume clock runs in suspend
    
    The ARM specifies that the system counter "must be implemented in an
    always-on power domain," and so we try to use the counter as a source of
    timekeeping across suspend/resume. Unfortunately, some SoCs (e.g.,
    Rockchip's RK3399) do not keep the counter ticking properly when
    switched from their high-power clock to the lower-power clock used in
    system suspend. Support this quirk by adding a new device tree property.
    
    Signed-off-by: Brian Norris <briannorris@chromium.org>
    Reviewed-by: Douglas Anderson <dianders@chromium.org>
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit e56b0b1a37b527e15ce928f5b9ed6ebc5222747d
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Aug 23 16:08:22 2016 -0700

    timekeeping: Cap array access in timekeeping_debug
    
    commit a4f8f6667f099036c88f231dcad4cf233652c824 upstream.
    
    It was reported that hibernation could fail on the 2nd attempt, where the
    system hangs at hibernate() -> syscore_resume() -> i8237A_resume() ->
    claim_dma_lock(), because the lock has already been taken.
    
    However there is actually no other process would like to grab this lock on
    that problematic platform.
    
    Further investigation showed that the problem is triggered by setting
    /sys/power/pm_trace to 1 before the 1st hibernation.
    
    Since once pm_trace is enabled, the rtc becomes unmeaningful after suspend,
    and meanwhile some BIOSes would like to adjust the 'invalid' RTC (e.g, smaller
    than 1970) to the release date of that motherboard during POST stage, thus
    after resumed, it may seem that the system had a significant long sleep time
    which is a completely meaningless value.
    
    Then in timekeeping_resume -> tk_debug_account_sleep_time, if the bit31 of the
    sleep time happened to be set to 1, fls() returns 32 and we add 1 to
    sleep_time_bin[32], which causes an out of bounds array access and therefor
    memory being overwritten.
    
    As depicted by System.map:
    0xffffffff81c9d080 b sleep_time_bin
    0xffffffff81c9d100 B dma_spin_lock
    the dma_spin_lock.val is set to 1, which caused this problem.
    
    This patch adds a sanity check in tk_debug_account_sleep_time()
    to ensure we don't index past the sleep_time_bin array.
    
    [jstultz: Problem diagnosed and original patch by Chen Yu, I've solved the
     issue slightly differently, but borrowed his excelent explanation of the
     issue here.]
    
    Fixes: 5c83545f24ab "power: Add option to log time spent in suspend"
    Reported-by: Janek Kozicki <cosurgi@gmail.com>
    Reported-by: Chen Yu <yu.c.chen@intel.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: linux-pm@vger.kernel.org
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Xunlei Pang <xpang@redhat.com>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: Zhang Rui <rui.zhang@intel.com>
    Link: http://lkml.kernel.org/r/1471993702-29148-3-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit e3fd9a93a12a1020067a676e826877623cee8e2b
Author: Paolo Bonzini <pbonzini@redhat.com>
Date:   Wed Nov 9 17:48:15 2016 +0100

    kvm: kvmclock: let KVM_GET_CLOCK return whether the master clock is in use
    
    Userspace can read the exact value of kvmclock by reading the TSC
    and fetching the timekeeping parameters out of guest memory.  This
    however is brittle and not necessary anymore with KVM 4.11.  Provide
    a mechanism that lets userspace know if the new KVM_GET_CLOCK
    semantics are in effect, and---since we are at it---if the clock
    is stable across all VCPUs.
    
    Cc: Radim Krčmář <rkrcmar@redhat.com>
    Cc: Marcelo Tosatti <mtosatti@redhat.com>
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
    Signed-off-by: Radim Krčmář <rkrcmar@redhat.com>

commit 8c095d35c42284d6d8cd792c01afd7cdeba475db
Author: John Stultz <john.stultz@linaro.org>
Date:   Thu Jun 11 15:54:55 2015 -0700

    time: Prevent early expiry of hrtimers[CLOCK_REALTIME] at the leap second edge
    
    commit 833f32d763028c1bb371c64f457788b933773b3e upstream.
    
    Currently, leapsecond adjustments are done at tick time. As a result,
    the leapsecond was applied at the first timer tick *after* the
    leapsecond (~1-10ms late depending on HZ), rather then exactly on the
    second edge.
    
    This was in part historical from back when we were always tick based,
    but correcting this since has been avoided since it adds extra
    conditional checks in the gettime fastpath, which has performance
    overhead.
    
    However, it was recently pointed out that ABS_TIME CLOCK_REALTIME
    timers set for right after the leapsecond could fire a second early,
    since some timers may be expired before we trigger the timekeeping
    timer, which then applies the leapsecond.
    
    This isn't quite as bad as it sounds, since behaviorally it is similar
    to what is possible w/ ntpd made leapsecond adjustments done w/o using
    the kernel discipline. Where due to latencies, timers may fire just
    prior to the settimeofday call. (Also, one should note that all
    applications using CLOCK_REALTIME timers should always be careful,
    since they are prone to quirks from settimeofday() disturbances.)
    
    However, the purpose of having the kernel do the leap adjustment is to
    avoid such latencies, so I think this is worth fixing.
    
    So in order to properly keep those timers from firing a second early,
    this patch modifies the ntp and timekeeping logic so that we keep
    enough state so that the update_base_offsets_now accessor, which
    provides the hrtimer core the current time, can check and apply the
    leapsecond adjustment on the second edge. This prevents the hrtimer
    core from expiring timers too early.
    
    This patch does not modify any other time read path, so no additional
    overhead is incurred. However, this also means that the leap-second
    continues to be applied at tick time for all other read-paths.
    
    Apologies to Richard Cochran, who pushed for similar changes years
    ago, which I resisted due to the concerns about the performance
    overhead.
    
    While I suspect this isn't extremely critical, folks who care about
    strict leap-second correctness will likely want to watch
    this. Potentially a -stable candidate eventually.
    
    Originally-suggested-by: Richard Cochran <richardcochran@gmail.com>
    Reported-by: Daniel Bristot de Oliveira <bristot@redhat.com>
    Reported-by: Prarit Bhargava <prarit@redhat.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Jan Kara <jack@suse.cz>
    Cc: Jiri Bohac <jbohac@suse.cz>
    Cc: Shuah Khan <shuahkh@osg.samsung.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Link: http://lkml.kernel.org/r/1434063297-28657-4-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    [Yadi: Move do_adjtimex to timekeeping.c and solve context issues]
    Signed-off-by: Hu <yadi.hu@windriver.com>
    Signed-off-by: Zefan Li <lizefan@huawei.com>

commit 4edf04a3a307195be345f8189e37501ac247f68b
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Oct 4 19:55:48 2016 -0700

    timekeeping: Fix __ktime_get_fast_ns() regression
    
    [ Upstream commit 58bfea9532552d422bde7afa207e1a0f08dffa7d ]
    
    In commit 27727df240c7 ("Avoid taking lock in NMI path with
    CONFIG_DEBUG_TIMEKEEPING"), I changed the logic to open-code
    the timekeeping_get_ns() function, but I forgot to include
    the unit conversion from cycles to nanoseconds, breaking the
    function's output, which impacts users like perf.
    
    This results in bogus perf timestamps like:
     swapper     0 [000]   253.427536:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]   254.426573:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]   254.426687:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]   254.426800:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]   254.426905:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]   254.427022:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]   254.427127:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]   254.427239:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]   254.427346:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]   254.427463:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]   255.426572:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
    
    Instead of more reasonable expected timestamps like:
     swapper     0 [000]    39.953768:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]    40.064839:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]    40.175956:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]    40.287103:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]    40.398217:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]    40.509324:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]    40.620437:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]    40.731546:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]    40.842654:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]    40.953772:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]    41.064881:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
    
    Add the proper use of timekeeping_delta_to_ns() to convert
    the cycle delta to nanoseconds as needed.
    
    Thanks to Brendan and Alexei for finding this quickly after
    the v4.8 release. Unfortunately the problematic commit has
    landed in some -stable trees so they'll need this fix as
    well.
    
    Many apologies for this mistake. I'll be looking to add a
    perf-clock sanity test to the kselftest timers tests soon.
    
    Fixes: 27727df240c7 "timekeeping: Avoid taking lock in NMI path with CONFIG_DEBUG_TIMEKEEPING"
    Reported-by: Brendan Gregg <bgregg@netflix.com>
    Reported-by: Alexei Starovoitov <alexei.starovoitov@gmail.com>
    Tested-and-reviewed-by: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: stable <stable@vger.kernel.org>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Link: http://lkml.kernel.org/r/1475636148-26539-1-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Sasha Levin <alexander.levin@verizon.com>

commit 486eeb6d6755a573829e6c5438eb7aae18891bb1
Author: Christopher S. Hall <christopher.s.hall@intel.com>
Date:   Mon Feb 22 03:15:19 2016 -0800

    time: Add cycles to nanoseconds translation
    
    [ Upstream commit 6bd58f09e1d8cc6c50a824c00bf0d617919986a1 ]
    
    The timekeeping code does not currently provide a way to translate
    externally provided clocksource cycles to system time. The cycle count
    is always provided by the result clocksource read() method internal to
    the timekeeping code. The added function timekeeping_cycles_to_ns()
    calculated a nanosecond value from a cycle count that can be added to
    tk_read_base.base value yielding the current system time. This allows
    clocksource cycle values external to the timekeeping code to provide a
    cycle count that can be transformed to system time.
    
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: kevin.b.stanton@intel.com
    Cc: kevin.j.clarke@intel.com
    Cc: hpa@zytor.com
    Cc: jeffrey.t.kirsher@intel.com
    Cc: netdev@vger.kernel.org
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Christopher S. Hall <christopher.s.hall@intel.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Sasha Levin <alexander.levin@verizon.com>

commit 4e584cfe7da58834d8213d30049daaeb30bf0204
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Oct 4 19:55:48 2016 -0700

    timekeeping: Fix __ktime_get_fast_ns() regression
    
    commit 58bfea9532552d422bde7afa207e1a0f08dffa7d upstream.
    
    In commit 27727df240c7 ("Avoid taking lock in NMI path with
    CONFIG_DEBUG_TIMEKEEPING"), I changed the logic to open-code
    the timekeeping_get_ns() function, but I forgot to include
    the unit conversion from cycles to nanoseconds, breaking the
    function's output, which impacts users like perf.
    
    This results in bogus perf timestamps like:
     swapper     0 [000]   253.427536:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]   254.426573:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]   254.426687:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]   254.426800:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]   254.426905:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]   254.427022:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]   254.427127:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]   254.427239:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]   254.427346:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]   254.427463:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]   255.426572:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
    
    Instead of more reasonable expected timestamps like:
     swapper     0 [000]    39.953768:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]    40.064839:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]    40.175956:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]    40.287103:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]    40.398217:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]    40.509324:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]    40.620437:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]    40.731546:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]    40.842654:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]    40.953772:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]    41.064881:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
    
    Add the proper use of timekeeping_delta_to_ns() to convert
    the cycle delta to nanoseconds as needed.
    
    Thanks to Brendan and Alexei for finding this quickly after
    the v4.8 release. Unfortunately the problematic commit has
    landed in some -stable trees so they'll need this fix as
    well.
    
    Many apologies for this mistake. I'll be looking to add a
    perf-clock sanity test to the kselftest timers tests soon.
    
    Fixes: 27727df240c7 "timekeeping: Avoid taking lock in NMI path with CONFIG_DEBUG_TIMEKEEPING"
    Reported-by: Brendan Gregg <bgregg@netflix.com>
    Reported-by: Alexei Starovoitov <alexei.starovoitov@gmail.com>
    Tested-and-reviewed-by: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Link: http://lkml.kernel.org/r/1475636148-26539-1-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 7ea90daac4f3c6a3dc5592e4faf8ba1905050c4c
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Oct 4 19:55:48 2016 -0700

    timekeeping: Fix __ktime_get_fast_ns() regression
    
    commit 58bfea9532552d422bde7afa207e1a0f08dffa7d upstream.
    
    In commit 27727df240c7 ("Avoid taking lock in NMI path with
    CONFIG_DEBUG_TIMEKEEPING"), I changed the logic to open-code
    the timekeeping_get_ns() function, but I forgot to include
    the unit conversion from cycles to nanoseconds, breaking the
    function's output, which impacts users like perf.
    
    This results in bogus perf timestamps like:
     swapper     0 [000]   253.427536:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]   254.426573:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]   254.426687:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]   254.426800:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]   254.426905:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]   254.427022:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]   254.427127:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]   254.427239:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]   254.427346:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]   254.427463:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]   255.426572:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
    
    Instead of more reasonable expected timestamps like:
     swapper     0 [000]    39.953768:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]    40.064839:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]    40.175956:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]    40.287103:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]    40.398217:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]    40.509324:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]    40.620437:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]    40.731546:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]    40.842654:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]    40.953772:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]    41.064881:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
    
    Add the proper use of timekeeping_delta_to_ns() to convert
    the cycle delta to nanoseconds as needed.
    
    Thanks to Brendan and Alexei for finding this quickly after
    the v4.8 release. Unfortunately the problematic commit has
    landed in some -stable trees so they'll need this fix as
    well.
    
    Many apologies for this mistake. I'll be looking to add a
    perf-clock sanity test to the kselftest timers tests soon.
    
    Fixes: 27727df240c7 "timekeeping: Avoid taking lock in NMI path with CONFIG_DEBUG_TIMEKEEPING"
    Reported-by: Brendan Gregg <bgregg@netflix.com>
    Reported-by: Alexei Starovoitov <alexei.starovoitov@gmail.com>
    Tested-and-reviewed-by: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Link: http://lkml.kernel.org/r/1475636148-26539-1-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 78c7b55b362e868e529ab6579134708fcf5539dd
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Oct 4 19:55:48 2016 -0700

    timekeeping: Fix __ktime_get_fast_ns() regression
    
    commit 58bfea9532552d422bde7afa207e1a0f08dffa7d upstream.
    
    In commit 27727df240c7 ("Avoid taking lock in NMI path with
    CONFIG_DEBUG_TIMEKEEPING"), I changed the logic to open-code
    the timekeeping_get_ns() function, but I forgot to include
    the unit conversion from cycles to nanoseconds, breaking the
    function's output, which impacts users like perf.
    
    This results in bogus perf timestamps like:
     swapper     0 [000]   253.427536:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]   254.426573:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]   254.426687:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]   254.426800:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]   254.426905:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]   254.427022:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]   254.427127:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]   254.427239:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]   254.427346:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]   254.427463:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]   255.426572:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
    
    Instead of more reasonable expected timestamps like:
     swapper     0 [000]    39.953768:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]    40.064839:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]    40.175956:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]    40.287103:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]    40.398217:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]    40.509324:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]    40.620437:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]    40.731546:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]    40.842654:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]    40.953772:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]    41.064881:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
    
    Add the proper use of timekeeping_delta_to_ns() to convert
    the cycle delta to nanoseconds as needed.
    
    Thanks to Brendan and Alexei for finding this quickly after
    the v4.8 release. Unfortunately the problematic commit has
    landed in some -stable trees so they'll need this fix as
    well.
    
    Many apologies for this mistake. I'll be looking to add a
    perf-clock sanity test to the kselftest timers tests soon.
    
    Fixes: 27727df240c7 "timekeeping: Avoid taking lock in NMI path with CONFIG_DEBUG_TIMEKEEPING"
    Reported-by: Brendan Gregg <bgregg@netflix.com>
    Reported-by: Alexei Starovoitov <alexei.starovoitov@gmail.com>
    Tested-and-reviewed-by: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Link: http://lkml.kernel.org/r/1475636148-26539-1-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 9b57d91c03054030f30be75c6e19c65b5f108ef3
Author: Christopher S. Hall <christopher.s.hall@intel.com>
Date:   Mon Feb 22 03:15:19 2016 -0800

    time: Add cycles to nanoseconds translation
    
    commit 6bd58f09e1d8cc6c50a824c00bf0d617919986a1 upstream.
    
    The timekeeping code does not currently provide a way to translate
    externally provided clocksource cycles to system time. The cycle count
    is always provided by the result clocksource read() method internal to
    the timekeeping code. The added function timekeeping_cycles_to_ns()
    calculated a nanosecond value from a cycle count that can be added to
    tk_read_base.base value yielding the current system time. This allows
    clocksource cycle values external to the timekeeping code to provide a
    cycle count that can be transformed to system time.
    
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: kevin.b.stanton@intel.com
    Cc: kevin.j.clarke@intel.com
    Cc: hpa@zytor.com
    Cc: jeffrey.t.kirsher@intel.com
    Cc: netdev@vger.kernel.org
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Christopher S. Hall <christopher.s.hall@intel.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 604a830d4fb5bf2334263bd597de22652e63b7e6
Merge: 563873318d32 58bfea953255
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Oct 10 10:23:18 2016 -0700

    Merge branch 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer fix from Thomas Gleixner:
     "A single fix for a regression introduced in 4.8 which causes the
      trace/perf clock to return random nonsense if CONFIG_DEBUG_TIMEKEEPING
      is set"
    
    * 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      timekeeping: Fix __ktime_get_fast_ns() regression

commit 58bfea9532552d422bde7afa207e1a0f08dffa7d
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Oct 4 19:55:48 2016 -0700

    timekeeping: Fix __ktime_get_fast_ns() regression
    
    In commit 27727df240c7 ("Avoid taking lock in NMI path with
    CONFIG_DEBUG_TIMEKEEPING"), I changed the logic to open-code
    the timekeeping_get_ns() function, but I forgot to include
    the unit conversion from cycles to nanoseconds, breaking the
    function's output, which impacts users like perf.
    
    This results in bogus perf timestamps like:
     swapper     0 [000]   253.427536:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]   254.426573:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]   254.426687:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]   254.426800:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]   254.426905:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]   254.427022:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]   254.427127:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]   254.427239:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]   254.427346:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]   254.427463:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]   255.426572:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
    
    Instead of more reasonable expected timestamps like:
     swapper     0 [000]    39.953768:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]    40.064839:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]    40.175956:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]    40.287103:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]    40.398217:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]    40.509324:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]    40.620437:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]    40.731546:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]    40.842654:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]    40.953772:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
     swapper     0 [000]    41.064881:  111111111 cpu-clock:  ffffffff810a0de6 native_safe_halt+0x6 ([kernel.kallsyms])
    
    Add the proper use of timekeeping_delta_to_ns() to convert
    the cycle delta to nanoseconds as needed.
    
    Thanks to Brendan and Alexei for finding this quickly after
    the v4.8 release. Unfortunately the problematic commit has
    landed in some -stable trees so they'll need this fix as
    well.
    
    Many apologies for this mistake. I'll be looking to add a
    perf-clock sanity test to the kselftest timers tests soon.
    
    Fixes: 27727df240c7 "timekeeping: Avoid taking lock in NMI path with CONFIG_DEBUG_TIMEKEEPING"
    Reported-by: Brendan Gregg <bgregg@netflix.com>
    Reported-by: Alexei Starovoitov <alexei.starovoitov@gmail.com>
    Tested-and-reviewed-by: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: stable <stable@vger.kernel.org>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Link: http://lkml.kernel.org/r/1475636148-26539-1-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 5e1b834b27fb2c27cde33a0752425f11d10c0b2d
Merge: 49deffe0b0e4 b536fd587044
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Oct 3 18:09:13 2016 -0700

    Merge branch 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer updates from Thomas Gleixner:
     "A rather smalish set of updates for timers and timekeeping:
    
       - Two core fixes to prevent potential undefinded behaviour about
         which gcc is complaining rightfully.
    
       - A fix to prevent stopping the tick on an (soon) offline CPU so it
         can complete the shutdown procedure.
    
       - Wait for clocks to stabilize before making decisions, so a not yet
         validated clock is not rejected.
    
       - The usual pile of fixes to the various clocksource drivers.
    
       - Core code typo and include fixlets"
    
    * 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      timekeeping: Include the correct header for errno definitions
      clocksource/drivers/ti-32k: Prevent ftrace recursion
      clocksource/mips-gic-timer: Stop checking cpu_has_counter
      clocksource/mips-gic-timer: Print an error if IRQ setup fails
      tick/nohz: Prevent stopping the tick on an offline CPU
      clocksource/drivers/oxnas: Add OX820 compatible
      clocksource/drivers/timer-atmel-pit: Simplify IRQ handler
      clocksource/drivers/timer-atmel-pit: Remove uselesss WARN_ON_ONCE
      clocksource/drivers/timer-atmel-pit: Drop at91sam926x_pit_common_init
      clocksource/drivers/moxart: Replace panic by pr_err
      clocksource/drivers/moxart: Replace setup_irq by request_irq
      clocksource/drivers/moxart: Add Aspeed support
      clocksource/drivers/moxart: Use struct to hold state
      clocksource/drivers/moxart: Refactor enable/disable
      time: Avoid undefined behaviour in ktime_add_safe()
      time: Avoid undefined behaviour in timespec64_add_safe()
      timekeeping: Prints the amounts of time spent during suspend
      clocksource: Defer override invalidation unless clock is unstable
      hrtimer: Spelling fixes

commit 4a47090ab9b6aef293efb11472112df2cf44323f
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Aug 23 16:08:22 2016 -0700

    timekeeping: Cap array access in timekeeping_debug
    
    commit a4f8f6667f099036c88f231dcad4cf233652c824 upstream.
    
    It was reported that hibernation could fail on the 2nd attempt, where the
    system hangs at hibernate() -> syscore_resume() -> i8237A_resume() ->
    claim_dma_lock(), because the lock has already been taken.
    
    However there is actually no other process would like to grab this lock on
    that problematic platform.
    
    Further investigation showed that the problem is triggered by setting
    /sys/power/pm_trace to 1 before the 1st hibernation.
    
    Since once pm_trace is enabled, the rtc becomes unmeaningful after suspend,
    and meanwhile some BIOSes would like to adjust the 'invalid' RTC (e.g, smaller
    than 1970) to the release date of that motherboard during POST stage, thus
    after resumed, it may seem that the system had a significant long sleep time
    which is a completely meaningless value.
    
    Then in timekeeping_resume -> tk_debug_account_sleep_time, if the bit31 of the
    sleep time happened to be set to 1, fls() returns 32 and we add 1 to
    sleep_time_bin[32], which causes an out of bounds array access and therefor
    memory being overwritten.
    
    As depicted by System.map:
    0xffffffff81c9d080 b sleep_time_bin
    0xffffffff81c9d100 B dma_spin_lock
    the dma_spin_lock.val is set to 1, which caused this problem.
    
    This patch adds a sanity check in tk_debug_account_sleep_time()
    to ensure we don't index past the sleep_time_bin array.
    
    [jstultz: Problem diagnosed and original patch by Chen Yu, I've solved the
     issue slightly differently, but borrowed his excelent explanation of the
     issue here.]
    
    Fixes: 5c83545f24ab "power: Add option to log time spent in suspend"
    Reported-by: Janek Kozicki <cosurgi@gmail.com>
    Reported-by: Chen Yu <yu.c.chen@intel.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: linux-pm@vger.kernel.org
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Xunlei Pang <xpang@redhat.com>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: Zhang Rui <rui.zhang@intel.com>
    Link: http://lkml.kernel.org/r/1471993702-29148-3-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>

commit adb560b3ee395ac9688a93582d805edec4c3d3e7
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Wed Sep 21 15:38:52 2016 +0200

    PM / Domains: Don't measure latency of ->power_on|off() during system PM
    
    Measure latency does by itself contribute to an increased latency, thus we
    should avoid it when it isn't needed.
    
    Currently genpd measures latencies in the system PM phase for the
    ->power_on|off() callbacks, except in the syscore case when it's not
    allowed to use ktime_get() as timekeeping may be suspended.
    
    Since there should be plenty of occasions during runtime PM to perform
    these measurements, let's rely on that and drop them from system PM. This
    will also make it consistent for how measurements are done of the runtime
    PM callbacks (as those may be invoked during system PM).
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit b536fd587044af02183b3c02690431b93154f0fa
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Sep 22 07:48:17 2016 -0700

    timekeeping: Include the correct header for errno definitions
    
    asm-generic headers are only defaults for architectures.  We need to get
    the proper defintion, which goes through <linux/errno.h> and <asm/errno.h>.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Cc: john.stultz@linaro.org
    Link: http://lkml.kernel.org/r/1474555697-8206-1-git-send-email-hch@lst.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 4eca11dbd272076f05c934dfd3005afc4b77c521
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Aug 23 16:08:21 2016 -0700

    timekeeping: Avoid taking lock in NMI path with CONFIG_DEBUG_TIMEKEEPING
    
    commit 27727df240c7cc84f2ba6047c6f18d5addfd25ef upstream.
    
    When I added some extra sanity checking in timekeeping_get_ns() under
    CONFIG_DEBUG_TIMEKEEPING, I missed that the NMI safe __ktime_get_fast_ns()
    method was using timekeeping_get_ns().
    
    Thus the locking added to the debug checks broke the NMI-safety of
    __ktime_get_fast_ns().
    
    This patch open-codes the timekeeping_get_ns() logic for
    __ktime_get_fast_ns(), so can avoid any deadlocks in NMI.
    
    Fixes: 4ca22c2648f9 "timekeeping: Add warnings when overflows or underflows are observed"
    Reported-by: Steven Rostedt <rostedt@goodmis.org>
    Reported-by: Peter Zijlstra <peterz@infradead.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Link: http://lkml.kernel.org/r/1471993702-29148-2-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 42ef9015e0adec4b5cf8142846a596a7adb8cadc
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Aug 23 16:08:22 2016 -0700

    timekeeping: Cap array access in timekeeping_debug
    
    commit a4f8f6667f099036c88f231dcad4cf233652c824 upstream.
    
    It was reported that hibernation could fail on the 2nd attempt, where the
    system hangs at hibernate() -> syscore_resume() -> i8237A_resume() ->
    claim_dma_lock(), because the lock has already been taken.
    
    However there is actually no other process would like to grab this lock on
    that problematic platform.
    
    Further investigation showed that the problem is triggered by setting
    /sys/power/pm_trace to 1 before the 1st hibernation.
    
    Since once pm_trace is enabled, the rtc becomes unmeaningful after suspend,
    and meanwhile some BIOSes would like to adjust the 'invalid' RTC (e.g, smaller
    than 1970) to the release date of that motherboard during POST stage, thus
    after resumed, it may seem that the system had a significant long sleep time
    which is a completely meaningless value.
    
    Then in timekeeping_resume -> tk_debug_account_sleep_time, if the bit31 of the
    sleep time happened to be set to 1, fls() returns 32 and we add 1 to
    sleep_time_bin[32], which causes an out of bounds array access and therefor
    memory being overwritten.
    
    As depicted by System.map:
    0xffffffff81c9d080 b sleep_time_bin
    0xffffffff81c9d100 B dma_spin_lock
    the dma_spin_lock.val is set to 1, which caused this problem.
    
    This patch adds a sanity check in tk_debug_account_sleep_time()
    to ensure we don't index past the sleep_time_bin array.
    
    [jstultz: Problem diagnosed and original patch by Chen Yu, I've solved the
     issue slightly differently, but borrowed his excelent explanation of the
     issue here.]
    
    Fixes: 5c83545f24ab "power: Add option to log time spent in suspend"
    Reported-by: Janek Kozicki <cosurgi@gmail.com>
    Reported-by: Chen Yu <yu.c.chen@intel.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: linux-pm@vger.kernel.org
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Xunlei Pang <xpang@redhat.com>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: Zhang Rui <rui.zhang@intel.com>
    Link: http://lkml.kernel.org/r/1471993702-29148-3-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 986b9db8f93e8f702a3c542f20f8c2e24e1dc1e2
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Aug 23 16:08:21 2016 -0700

    timekeeping: Avoid taking lock in NMI path with CONFIG_DEBUG_TIMEKEEPING
    
    commit 27727df240c7cc84f2ba6047c6f18d5addfd25ef upstream.
    
    When I added some extra sanity checking in timekeeping_get_ns() under
    CONFIG_DEBUG_TIMEKEEPING, I missed that the NMI safe __ktime_get_fast_ns()
    method was using timekeeping_get_ns().
    
    Thus the locking added to the debug checks broke the NMI-safety of
    __ktime_get_fast_ns().
    
    This patch open-codes the timekeeping_get_ns() logic for
    __ktime_get_fast_ns(), so can avoid any deadlocks in NMI.
    
    Fixes: 4ca22c2648f9 "timekeeping: Add warnings when overflows or underflows are observed"
    Reported-by: Steven Rostedt <rostedt@goodmis.org>
    Reported-by: Peter Zijlstra <peterz@infradead.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Link: http://lkml.kernel.org/r/1471993702-29148-2-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit b381a10cfe17d0e451f03eefd7c75346d08bcf02
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Aug 23 16:08:22 2016 -0700

    timekeeping: Cap array access in timekeeping_debug
    
    commit a4f8f6667f099036c88f231dcad4cf233652c824 upstream.
    
    It was reported that hibernation could fail on the 2nd attempt, where the
    system hangs at hibernate() -> syscore_resume() -> i8237A_resume() ->
    claim_dma_lock(), because the lock has already been taken.
    
    However there is actually no other process would like to grab this lock on
    that problematic platform.
    
    Further investigation showed that the problem is triggered by setting
    /sys/power/pm_trace to 1 before the 1st hibernation.
    
    Since once pm_trace is enabled, the rtc becomes unmeaningful after suspend,
    and meanwhile some BIOSes would like to adjust the 'invalid' RTC (e.g, smaller
    than 1970) to the release date of that motherboard during POST stage, thus
    after resumed, it may seem that the system had a significant long sleep time
    which is a completely meaningless value.
    
    Then in timekeeping_resume -> tk_debug_account_sleep_time, if the bit31 of the
    sleep time happened to be set to 1, fls() returns 32 and we add 1 to
    sleep_time_bin[32], which causes an out of bounds array access and therefor
    memory being overwritten.
    
    As depicted by System.map:
    0xffffffff81c9d080 b sleep_time_bin
    0xffffffff81c9d100 B dma_spin_lock
    the dma_spin_lock.val is set to 1, which caused this problem.
    
    This patch adds a sanity check in tk_debug_account_sleep_time()
    to ensure we don't index past the sleep_time_bin array.
    
    [jstultz: Problem diagnosed and original patch by Chen Yu, I've solved the
     issue slightly differently, but borrowed his excelent explanation of the
     issue here.]
    
    Fixes: 5c83545f24ab "power: Add option to log time spent in suspend"
    Reported-by: Janek Kozicki <cosurgi@gmail.com>
    Reported-by: Chen Yu <yu.c.chen@intel.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: linux-pm@vger.kernel.org
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Xunlei Pang <xpang@redhat.com>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: Zhang Rui <rui.zhang@intel.com>
    Link: http://lkml.kernel.org/r/1471993702-29148-3-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 2783e5d63a9a38b5246c75b29f0dce4cf995a1b3
Author: Alexandre Belloni <alexandre.belloni@bootlin.com>
Date:   Fri Sep 9 13:13:50 2016 +0200

    clocksource/drivers/timer-atmel-pit: Simplify IRQ handler
    
    Because the PIT is also a proper clocksource, the timekeeping code  is
    already able to handle lost ticks.
    
    Reported-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Nicolas Ferre <nicolas.ferre@atmel.com>
    Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit 189f6d32277fbc6901c5d09ec5b9df1fef3657b0
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Aug 23 16:08:22 2016 -0700

    timekeeping: Cap array access in timekeeping_debug
    
    [ Upstream commit a4f8f6667f099036c88f231dcad4cf233652c824 ]
    
    It was reported that hibernation could fail on the 2nd attempt, where the
    system hangs at hibernate() -> syscore_resume() -> i8237A_resume() ->
    claim_dma_lock(), because the lock has already been taken.
    
    However there is actually no other process would like to grab this lock on
    that problematic platform.
    
    Further investigation showed that the problem is triggered by setting
    /sys/power/pm_trace to 1 before the 1st hibernation.
    
    Since once pm_trace is enabled, the rtc becomes unmeaningful after suspend,
    and meanwhile some BIOSes would like to adjust the 'invalid' RTC (e.g, smaller
    than 1970) to the release date of that motherboard during POST stage, thus
    after resumed, it may seem that the system had a significant long sleep time
    which is a completely meaningless value.
    
    Then in timekeeping_resume -> tk_debug_account_sleep_time, if the bit31 of the
    sleep time happened to be set to 1, fls() returns 32 and we add 1 to
    sleep_time_bin[32], which causes an out of bounds array access and therefor
    memory being overwritten.
    
    As depicted by System.map:
    0xffffffff81c9d080 b sleep_time_bin
    0xffffffff81c9d100 B dma_spin_lock
    the dma_spin_lock.val is set to 1, which caused this problem.
    
    This patch adds a sanity check in tk_debug_account_sleep_time()
    to ensure we don't index past the sleep_time_bin array.
    
    [jstultz: Problem diagnosed and original patch by Chen Yu, I've solved the
     issue slightly differently, but borrowed his excelent explanation of the
     issue here.]
    
    Fixes: 5c83545f24ab "power: Add option to log time spent in suspend"
    Reported-by: Janek Kozicki <cosurgi@gmail.com>
    Reported-by: Chen Yu <yu.c.chen@intel.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: linux-pm@vger.kernel.org
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Xunlei Pang <xpang@redhat.com>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: stable <stable@vger.kernel.org>
    Cc: Zhang Rui <rui.zhang@intel.com>
    Link: http://lkml.kernel.org/r/1471993702-29148-3-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Sasha Levin <alexander.levin@verizon.com>

commit a3f914be622e423eb9f8d24128d3b965fa3d9b8a
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Aug 23 16:08:22 2016 -0700

    timekeeping: Cap array access in timekeeping_debug
    
    [ Upstream commit a4f8f6667f099036c88f231dcad4cf233652c824 ]
    
    It was reported that hibernation could fail on the 2nd attempt, where the
    system hangs at hibernate() -> syscore_resume() -> i8237A_resume() ->
    claim_dma_lock(), because the lock has already been taken.
    
    However there is actually no other process would like to grab this lock on
    that problematic platform.
    
    Further investigation showed that the problem is triggered by setting
    /sys/power/pm_trace to 1 before the 1st hibernation.
    
    Since once pm_trace is enabled, the rtc becomes unmeaningful after suspend,
    and meanwhile some BIOSes would like to adjust the 'invalid' RTC (e.g, smaller
    than 1970) to the release date of that motherboard during POST stage, thus
    after resumed, it may seem that the system had a significant long sleep time
    which is a completely meaningless value.
    
    Then in timekeeping_resume -> tk_debug_account_sleep_time, if the bit31 of the
    sleep time happened to be set to 1, fls() returns 32 and we add 1 to
    sleep_time_bin[32], which causes an out of bounds array access and therefor
    memory being overwritten.
    
    As depicted by System.map:
    0xffffffff81c9d080 b sleep_time_bin
    0xffffffff81c9d100 B dma_spin_lock
    the dma_spin_lock.val is set to 1, which caused this problem.
    
    This patch adds a sanity check in tk_debug_account_sleep_time()
    to ensure we don't index past the sleep_time_bin array.
    
    [jstultz: Problem diagnosed and original patch by Chen Yu, I've solved the
     issue slightly differently, but borrowed his excelent explanation of the
     issue here.]
    
    Fixes: 5c83545f24ab "power: Add option to log time spent in suspend"
    Reported-by: Janek Kozicki <cosurgi@gmail.com>
    Reported-by: Chen Yu <yu.c.chen@intel.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: linux-pm@vger.kernel.org
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Xunlei Pang <xpang@redhat.com>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: stable <stable@vger.kernel.org>
    Cc: Zhang Rui <rui.zhang@intel.com>
    Link: http://lkml.kernel.org/r/1471993702-29148-3-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Sasha Levin <alexander.levin@verizon.com>

commit 0c7b2c2aea55b4e940e3de8b41658855aebcbca4
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Aug 23 16:08:21 2016 -0700

    timekeeping: Avoid taking lock in NMI path with CONFIG_DEBUG_TIMEKEEPING
    
    [ Upstream commit 27727df240c7cc84f2ba6047c6f18d5addfd25ef ]
    
    When I added some extra sanity checking in timekeeping_get_ns() under
    CONFIG_DEBUG_TIMEKEEPING, I missed that the NMI safe __ktime_get_fast_ns()
    method was using timekeeping_get_ns().
    
    Thus the locking added to the debug checks broke the NMI-safety of
    __ktime_get_fast_ns().
    
    This patch open-codes the timekeeping_get_ns() logic for
    __ktime_get_fast_ns(), so can avoid any deadlocks in NMI.
    
    Fixes: 4ca22c2648f9 "timekeeping: Add warnings when overflows or underflows are observed"
    Reported-by: Steven Rostedt <rostedt@goodmis.org>
    Reported-by: Peter Zijlstra <peterz@infradead.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: stable <stable@vger.kernel.org>
    Link: http://lkml.kernel.org/r/1471993702-29148-2-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Sasha Levin <alexander.levin@verizon.com>

commit 0bf43f15db857e83daf4134aa062c8b157a80ee0
Author: Ruchi Kandoi <kandoiruchi@google.com>
Date:   Thu Aug 11 14:35:01 2016 -0700

    timekeeping: Prints the amounts of time spent during suspend
    
    In addition to keeping a histogram of suspend times, also
    print out the time spent in suspend to dmesg.
    
    This helps to keep track of suspend time while debugging using
    kernel logs.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Signed-off-by: Ruchi Kandoi <kandoiruchi@google.com>
    [jstultz: Tweaked commit message]
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 037d2405d0ca0d276c481e40b98fb40e5d0360b8
Merge: af56ff27eba5 b53e7d000d9e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Aug 28 09:03:05 2016 -0700

    Merge branch 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer fixes from Thomas Gleixner:
     "A few updates for timers & co:
    
       - prevent a livelock in the timekeeping code when debugging is
         enabled
    
       - prevent out of bounds access in the timekeeping debug code
    
       - various fixes in clocksource drivers
    
       - a new maintainers entry"
    
    * 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      clocksource/drivers/sun4i: Clear interrupts after stopping timer in probe function
      drivers/clocksource/pistachio: Fix memory corruption in init
      clocksource/drivers/timer-atmel-pit: Enable mck clock
      clocksource/drivers/pxa: Fix include files for compilation
      MAINTAINERS: Add ARM ARCHITECTED TIMER entry
      timekeeping: Cap array access in timekeeping_debug
      timekeeping: Avoid taking lock in NMI path with CONFIG_DEBUG_TIMEKEEPING

commit 4d0e701659aa869a445823149e172e23faa6edac
Author: Marcin Nowakowski <marcin.nowakowski@mips.com>
Date:   Wed Aug 17 12:22:33 2016 +0200

    drivers/clocksource/pistachio: Fix memory corruption in init
    
    Driver init code incorrectly uses the block base address and as a result
    clears clocksource structure's fields instead of the hardware registers.
    
    Commit 09a998201649 ("timekeeping: Lift clocksource cacheline
    restriction") has changed the offsets within pistachio_clocksource
    structure and what has previously gone unnoticed now leads to a kernel
    panic during boot.
    
    Signed-off-by: Marcin Nowakowski <marcin.nowakowski@imgtec.com>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit a4f8f6667f099036c88f231dcad4cf233652c824
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Aug 23 16:08:22 2016 -0700

    timekeeping: Cap array access in timekeeping_debug
    
    It was reported that hibernation could fail on the 2nd attempt, where the
    system hangs at hibernate() -> syscore_resume() -> i8237A_resume() ->
    claim_dma_lock(), because the lock has already been taken.
    
    However there is actually no other process would like to grab this lock on
    that problematic platform.
    
    Further investigation showed that the problem is triggered by setting
    /sys/power/pm_trace to 1 before the 1st hibernation.
    
    Since once pm_trace is enabled, the rtc becomes unmeaningful after suspend,
    and meanwhile some BIOSes would like to adjust the 'invalid' RTC (e.g, smaller
    than 1970) to the release date of that motherboard during POST stage, thus
    after resumed, it may seem that the system had a significant long sleep time
    which is a completely meaningless value.
    
    Then in timekeeping_resume -> tk_debug_account_sleep_time, if the bit31 of the
    sleep time happened to be set to 1, fls() returns 32 and we add 1 to
    sleep_time_bin[32], which causes an out of bounds array access and therefor
    memory being overwritten.
    
    As depicted by System.map:
    0xffffffff81c9d080 b sleep_time_bin
    0xffffffff81c9d100 B dma_spin_lock
    the dma_spin_lock.val is set to 1, which caused this problem.
    
    This patch adds a sanity check in tk_debug_account_sleep_time()
    to ensure we don't index past the sleep_time_bin array.
    
    [jstultz: Problem diagnosed and original patch by Chen Yu, I've solved the
     issue slightly differently, but borrowed his excelent explanation of the
     issue here.]
    
    Fixes: 5c83545f24ab "power: Add option to log time spent in suspend"
    Reported-by: Janek Kozicki <cosurgi@gmail.com>
    Reported-by: Chen Yu <yu.c.chen@intel.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: linux-pm@vger.kernel.org
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Xunlei Pang <xpang@redhat.com>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: stable <stable@vger.kernel.org>
    Cc: Zhang Rui <rui.zhang@intel.com>
    Link: http://lkml.kernel.org/r/1471993702-29148-3-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 27727df240c7cc84f2ba6047c6f18d5addfd25ef
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Aug 23 16:08:21 2016 -0700

    timekeeping: Avoid taking lock in NMI path with CONFIG_DEBUG_TIMEKEEPING
    
    When I added some extra sanity checking in timekeeping_get_ns() under
    CONFIG_DEBUG_TIMEKEEPING, I missed that the NMI safe __ktime_get_fast_ns()
    method was using timekeeping_get_ns().
    
    Thus the locking added to the debug checks broke the NMI-safety of
    __ktime_get_fast_ns().
    
    This patch open-codes the timekeeping_get_ns() logic for
    __ktime_get_fast_ns(), so can avoid any deadlocks in NMI.
    
    Fixes: 4ca22c2648f9 "timekeeping: Add warnings when overflows or underflows are observed"
    Reported-by: Steven Rostedt <rostedt@goodmis.org>
    Reported-by: Peter Zijlstra <peterz@infradead.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: stable <stable@vger.kernel.org>
    Link: http://lkml.kernel.org/r/1471993702-29148-2-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 75b5b632f4cb234c54ec6b8740390f8c9372ebc7
Author: James Hogan <jhogan@kernel.org>
Date:   Fri Apr 22 10:38:45 2016 +0100

    MIPS: KVM: Fix timer IRQ race when freezing timer
    
    commit 4355c44f063d3de4f072d796604c7f4ba4085cc3 upstream.
    
    There's a particularly narrow and subtle race condition when the
    software emulated guest timer is frozen which can allow a guest timer
    interrupt to be missed.
    
    This happens due to the hrtimer expiry being inexact, so very
    occasionally the freeze time will be after the moment when the emulated
    CP0_Count transitions to the same value as CP0_Compare (so an IRQ should
    be generated), but before the moment when the hrtimer is due to expire
    (so no IRQ is generated). The IRQ won't be generated when the timer is
    resumed either, since the resume CP0_Count will already match CP0_Compare.
    
    With VZ guests in particular this is far more likely to happen, since
    the soft timer may be frozen frequently in order to restore the timer
    state to the hardware guest timer. This happens after 5-10 hours of
    guest soak testing, resulting in an overflow in guest kernel timekeeping
    calculations, hanging the guest. A more focussed test case to
    intentionally hit the race (with the help of a new hypcall to cause the
    timer state to migrated between hardware & software) hits the condition
    fairly reliably within around 30 seconds.
    
    Instead of relying purely on the inexact hrtimer expiry to determine
    whether an IRQ should be generated, read the guest CP0_Compare and
    directly check whether the freeze time is before or after it. Only if
    CP0_Count is on or after CP0_Compare do we check the hrtimer expiry to
    determine whether the last IRQ has already been generated (which will
    have pushed back the expiry by one timer period).
    
    Fixes: e30492bbe95a ("MIPS: KVM: Rewrite count/compare timer emulation")
    Signed-off-by: James Hogan <james.hogan@imgtec.com>
    Cc: Paolo Bonzini <pbonzini@redhat.com>
    Cc: "Radim KrÄmÃ¡Å™" <rkrcmar@redhat.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: linux-mips@linux-mips.org
    Cc: kvm@vger.kernel.org
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
    [bwh: Backported to 3.16: adjust filename]
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit 49eea433b326a0ac5c7c941a011b2c65990bd19b
Author: Kevin Brodsky <kevin.brodsky@arm.com>
Date:   Tue Jul 12 11:24:00 2016 +0100

    arm64: Add support for CLOCK_MONOTONIC_RAW in clock_gettime() vDSO
    
    So far the arm64 clock_gettime() vDSO implementation only supported
    the following clocks, falling back to the syscall for the others:
    - CLOCK_REALTIME{,_COARSE}
    - CLOCK_MONOTONIC{,_COARSE}
    
    This patch adds support for the CLOCK_MONOTONIC_RAW clock, taking
    advantage of the recent refactoring of the vDSO time functions. Like
    the non-_COARSE clocks, this only works when the "arch_sys_counter"
    clocksource is in use (allowing us to read the current time from the
    virtual counter register), otherwise we also have to fall back to the
    syscall.
    
    Most of the data is shared with CLOCK_MONOTONIC, and the algorithm is
    similar. The reference implementation in kernel/time/timekeeping.c
    shows that:
    - CLOCK_MONOTONIC = tk->wall_to_monotonic + tk->xtime_sec +
      timekeeping_get_ns(&tk->tkr_mono)
    - CLOCK_MONOTONIC_RAW = tk->raw_time + timekeeping_get_ns(&tk->tkr_raw)
    - tkr_mono and tkr_raw are identical (in particular, same
      clocksource), except these members:
      * mult (only mono's multiplier is NTP-adjusted)
      * xtime_nsec (always 0 for raw)
    
    Therefore, tk->raw_time and tkr_raw->mult are now also stored in the
    vDSO data page.
    
    Cc: Ali Saidi <ali.saidi@arm.com>
    Signed-off-by: Kevin Brodsky <kevin.brodsky@arm.com>
    Reviewed-by: Dave Martin <dave.martin@arm.com>
    Acked-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>

commit eaaa7ec71bff4cb34d9025ed89068d4b3cac3df0
Author: Gregor Boirie <gregor.boirie@parrot.com>
Date:   Wed Mar 9 19:05:48 2016 +0100

    timekeeping: export get_monotonic_coarse64 symbol
    
    EXPORT_SYMBOL() get_monotonic_coarse64 for new IIO timestamping clock
    selection usage. This provides user apps the ability to request a
    particular IIO device to timestamp samples using a monotonic coarse clock
    granularity.
    
    Signed-off-by: Gregor Boirie <gregor.boirie@parrot.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

commit 0209b937569a133dedfe930cdfff3a0d1d68c9e9
Author: Thomas Graziadei <thomas.graziadei@omicronenergy.com>
Date:   Tue May 31 15:06:06 2016 +0200

    timekeeping: Fix 1ns/tick drift with GENERIC_TIME_VSYSCALL_OLD
    
    The user notices the problem in a raw and real time drift, calling
    clock_gettime with CLOCK_REALTIME / CLOCK_MONOTONIC_RAW on a system
    with no ntp correction taking place (no ntpd or ptp stuff running).
    
    The problem is, that old_vsyscall_fixup adds an extra 1ns even though
    xtime_nsec is already held in full nsecs and the remainder in this
    case is 0. Do the rounding up buisness only if needed.
    
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Thomas Graziadei <thomas.graziadei@omicronenergy.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 5933622cae3fcf3b5c008f99bcd2b0fdb1b3e2e6
Author: wang yanqing <udknight@gmail.com>
Date:   Sat May 7 00:33:53 2016 +0800

    rtlwifi: pci: use dev_kfree_skb_irq instead of kfree_skb in rtl_pci_reset_trx_ring
    
    commit cf968937d27751296920e6b82ffa89735e3a0023 upstream.
    
    We can't use kfree_skb in irq disable context, because spin_lock_irqsave
    make sure we are always in irq disable context, use dev_kfree_skb_irq
    instead of kfree_skb is better than dev_kfree_skb_any.
    
    This patch fix below kernel warning:
    [ 7612.095528] ------------[ cut here ]------------
    [ 7612.095546] WARNING: CPU: 3 PID: 4460 at kernel/softirq.c:150 __local_bh_enable_ip+0x58/0x80()
    [ 7612.095550] Modules linked in: rtl8723be x86_pkg_temp_thermal btcoexist rtl_pci rtlwifi rtl8723_common
    [ 7612.095567] CPU: 3 PID: 4460 Comm: ifconfig Tainted: G        W       4.4.0+ #4
    [ 7612.095570] Hardware name: LENOVO 20DFA04FCD/20DFA04FCD, BIOS J5ET48WW (1.19 ) 08/27/2015
    [ 7612.095574]  00000000 00000000 da37fc70 c12ce7c5 00000000 da37fca0 c104cc59 c19d4454
    [ 7612.095584]  00000003 0000116c c19d4784 00000096 c10508a8 c10508a8 00000200 c1b42400
    [ 7612.095594]  f29be780 da37fcb0 c104ccad 00000009 00000000 da37fcbc c10508a8 f21f08b8
    [ 7612.095604] Call Trace:
    [ 7612.095614]  [<c12ce7c5>] dump_stack+0x41/0x5c
    [ 7612.095620]  [<c104cc59>] warn_slowpath_common+0x89/0xc0
    [ 7612.095628]  [<c10508a8>] ? __local_bh_enable_ip+0x58/0x80
    [ 7612.095634]  [<c10508a8>] ? __local_bh_enable_ip+0x58/0x80
    [ 7612.095640]  [<c104ccad>] warn_slowpath_null+0x1d/0x20
    [ 7612.095646]  [<c10508a8>] __local_bh_enable_ip+0x58/0x80
    [ 7612.095653]  [<c16b7d34>] destroy_conntrack+0x64/0xa0
    [ 7612.095660]  [<c16b300f>] nf_conntrack_destroy+0xf/0x20
    [ 7612.095665]  [<c1677565>] skb_release_head_state+0x55/0xa0
    [ 7612.095670]  [<c16775bb>] skb_release_all+0xb/0x20
    [ 7612.095674]  [<c167760b>] __kfree_skb+0xb/0x60
    [ 7612.095679]  [<c16776f0>] kfree_skb+0x30/0x70
    [ 7612.095686]  [<f81b869d>] ? rtl_pci_reset_trx_ring+0x22d/0x370 [rtl_pci]
    [ 7612.095692]  [<f81b869d>] rtl_pci_reset_trx_ring+0x22d/0x370 [rtl_pci]
    [ 7612.095698]  [<f81b87f9>] rtl_pci_start+0x19/0x190 [rtl_pci]
    [ 7612.095705]  [<f81970e6>] rtl_op_start+0x56/0x90 [rtlwifi]
    [ 7612.095712]  [<c17e3f16>] drv_start+0x36/0xc0
    [ 7612.095717]  [<c17f5ab3>] ieee80211_do_open+0x2d3/0x890
    [ 7612.095725]  [<c16820fe>] ? call_netdevice_notifiers_info+0x2e/0x60
    [ 7612.095730]  [<c17f60bd>] ieee80211_open+0x4d/0x50
    [ 7612.095736]  [<c16891b3>] __dev_open+0xa3/0x130
    [ 7612.095742]  [<c183fa53>] ? _raw_spin_unlock_bh+0x13/0x20
    [ 7612.095748]  [<c1689499>] __dev_change_flags+0x89/0x140
    [ 7612.095753]  [<c127c70d>] ? selinux_capable+0xd/0x10
    [ 7612.095759]  [<c1689589>] dev_change_flags+0x29/0x60
    [ 7612.095765]  [<c1700b93>] devinet_ioctl+0x553/0x670
    [ 7612.095772]  [<c12db758>] ? _copy_to_user+0x28/0x40
    [ 7612.095777]  [<c17018b5>] inet_ioctl+0x85/0xb0
    [ 7612.095783]  [<c166e647>] sock_ioctl+0x67/0x260
    [ 7612.095788]  [<c166e5e0>] ? sock_fasync+0x80/0x80
    [ 7612.095795]  [<c115c99b>] do_vfs_ioctl+0x6b/0x550
    [ 7612.095800]  [<c127c812>] ? selinux_file_ioctl+0x102/0x1e0
    [ 7612.095807]  [<c10a8914>] ? timekeeping_suspend+0x294/0x320
    [ 7612.095813]  [<c10a256a>] ? __hrtimer_run_queues+0x14a/0x210
    [ 7612.095820]  [<c1276e24>] ? security_file_ioctl+0x34/0x50
    [ 7612.095827]  [<c115cef0>] SyS_ioctl+0x70/0x80
    [ 7612.095832]  [<c1001804>] do_fast_syscall_32+0x84/0x120
    [ 7612.095839]  [<c183ff91>] sysenter_past_esp+0x36/0x55
    [ 7612.095844] ---[ end trace 97e9c637a20e8348 ]---
    
    Signed-off-by: Wang YanQing <udknight@gmail.com>
    Acked-by: Larry Finger <Larry.Finger@lwfinger.net>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 85e29271c3a3942f6e7e453c8dae22c6210b8f03
Author: wang yanqing <udknight@gmail.com>
Date:   Sat May 7 00:33:53 2016 +0800

    rtlwifi: pci: use dev_kfree_skb_irq instead of kfree_skb in rtl_pci_reset_trx_ring
    
    commit cf968937d27751296920e6b82ffa89735e3a0023 upstream.
    
    We can't use kfree_skb in irq disable context, because spin_lock_irqsave
    make sure we are always in irq disable context, use dev_kfree_skb_irq
    instead of kfree_skb is better than dev_kfree_skb_any.
    
    This patch fix below kernel warning:
    [ 7612.095528] ------------[ cut here ]------------
    [ 7612.095546] WARNING: CPU: 3 PID: 4460 at kernel/softirq.c:150 __local_bh_enable_ip+0x58/0x80()
    [ 7612.095550] Modules linked in: rtl8723be x86_pkg_temp_thermal btcoexist rtl_pci rtlwifi rtl8723_common
    [ 7612.095567] CPU: 3 PID: 4460 Comm: ifconfig Tainted: G        W       4.4.0+ #4
    [ 7612.095570] Hardware name: LENOVO 20DFA04FCD/20DFA04FCD, BIOS J5ET48WW (1.19 ) 08/27/2015
    [ 7612.095574]  00000000 00000000 da37fc70 c12ce7c5 00000000 da37fca0 c104cc59 c19d4454
    [ 7612.095584]  00000003 0000116c c19d4784 00000096 c10508a8 c10508a8 00000200 c1b42400
    [ 7612.095594]  f29be780 da37fcb0 c104ccad 00000009 00000000 da37fcbc c10508a8 f21f08b8
    [ 7612.095604] Call Trace:
    [ 7612.095614]  [<c12ce7c5>] dump_stack+0x41/0x5c
    [ 7612.095620]  [<c104cc59>] warn_slowpath_common+0x89/0xc0
    [ 7612.095628]  [<c10508a8>] ? __local_bh_enable_ip+0x58/0x80
    [ 7612.095634]  [<c10508a8>] ? __local_bh_enable_ip+0x58/0x80
    [ 7612.095640]  [<c104ccad>] warn_slowpath_null+0x1d/0x20
    [ 7612.095646]  [<c10508a8>] __local_bh_enable_ip+0x58/0x80
    [ 7612.095653]  [<c16b7d34>] destroy_conntrack+0x64/0xa0
    [ 7612.095660]  [<c16b300f>] nf_conntrack_destroy+0xf/0x20
    [ 7612.095665]  [<c1677565>] skb_release_head_state+0x55/0xa0
    [ 7612.095670]  [<c16775bb>] skb_release_all+0xb/0x20
    [ 7612.095674]  [<c167760b>] __kfree_skb+0xb/0x60
    [ 7612.095679]  [<c16776f0>] kfree_skb+0x30/0x70
    [ 7612.095686]  [<f81b869d>] ? rtl_pci_reset_trx_ring+0x22d/0x370 [rtl_pci]
    [ 7612.095692]  [<f81b869d>] rtl_pci_reset_trx_ring+0x22d/0x370 [rtl_pci]
    [ 7612.095698]  [<f81b87f9>] rtl_pci_start+0x19/0x190 [rtl_pci]
    [ 7612.095705]  [<f81970e6>] rtl_op_start+0x56/0x90 [rtlwifi]
    [ 7612.095712]  [<c17e3f16>] drv_start+0x36/0xc0
    [ 7612.095717]  [<c17f5ab3>] ieee80211_do_open+0x2d3/0x890
    [ 7612.095725]  [<c16820fe>] ? call_netdevice_notifiers_info+0x2e/0x60
    [ 7612.095730]  [<c17f60bd>] ieee80211_open+0x4d/0x50
    [ 7612.095736]  [<c16891b3>] __dev_open+0xa3/0x130
    [ 7612.095742]  [<c183fa53>] ? _raw_spin_unlock_bh+0x13/0x20
    [ 7612.095748]  [<c1689499>] __dev_change_flags+0x89/0x140
    [ 7612.095753]  [<c127c70d>] ? selinux_capable+0xd/0x10
    [ 7612.095759]  [<c1689589>] dev_change_flags+0x29/0x60
    [ 7612.095765]  [<c1700b93>] devinet_ioctl+0x553/0x670
    [ 7612.095772]  [<c12db758>] ? _copy_to_user+0x28/0x40
    [ 7612.095777]  [<c17018b5>] inet_ioctl+0x85/0xb0
    [ 7612.095783]  [<c166e647>] sock_ioctl+0x67/0x260
    [ 7612.095788]  [<c166e5e0>] ? sock_fasync+0x80/0x80
    [ 7612.095795]  [<c115c99b>] do_vfs_ioctl+0x6b/0x550
    [ 7612.095800]  [<c127c812>] ? selinux_file_ioctl+0x102/0x1e0
    [ 7612.095807]  [<c10a8914>] ? timekeeping_suspend+0x294/0x320
    [ 7612.095813]  [<c10a256a>] ? __hrtimer_run_queues+0x14a/0x210
    [ 7612.095820]  [<c1276e24>] ? security_file_ioctl+0x34/0x50
    [ 7612.095827]  [<c115cef0>] SyS_ioctl+0x70/0x80
    [ 7612.095832]  [<c1001804>] do_fast_syscall_32+0x84/0x120
    [ 7612.095839]  [<c183ff91>] sysenter_past_esp+0x36/0x55
    [ 7612.095844] ---[ end trace 97e9c637a20e8348 ]---
    
    Signed-off-by: Wang YanQing <udknight@gmail.com>
    Acked-by: Larry Finger <Larry.Finger@lwfinger.net>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 04a6bcca2f76f7aa5b8749644e3a2947a3cf040d
Author: wang yanqing <udknight@gmail.com>
Date:   Sat May 7 00:33:53 2016 +0800

    rtlwifi: pci: use dev_kfree_skb_irq instead of kfree_skb in rtl_pci_reset_trx_ring
    
    commit cf968937d27751296920e6b82ffa89735e3a0023 upstream.
    
    We can't use kfree_skb in irq disable context, because spin_lock_irqsave
    make sure we are always in irq disable context, use dev_kfree_skb_irq
    instead of kfree_skb is better than dev_kfree_skb_any.
    
    This patch fix below kernel warning:
    [ 7612.095528] ------------[ cut here ]------------
    [ 7612.095546] WARNING: CPU: 3 PID: 4460 at kernel/softirq.c:150 __local_bh_enable_ip+0x58/0x80()
    [ 7612.095550] Modules linked in: rtl8723be x86_pkg_temp_thermal btcoexist rtl_pci rtlwifi rtl8723_common
    [ 7612.095567] CPU: 3 PID: 4460 Comm: ifconfig Tainted: G        W       4.4.0+ #4
    [ 7612.095570] Hardware name: LENOVO 20DFA04FCD/20DFA04FCD, BIOS J5ET48WW (1.19 ) 08/27/2015
    [ 7612.095574]  00000000 00000000 da37fc70 c12ce7c5 00000000 da37fca0 c104cc59 c19d4454
    [ 7612.095584]  00000003 0000116c c19d4784 00000096 c10508a8 c10508a8 00000200 c1b42400
    [ 7612.095594]  f29be780 da37fcb0 c104ccad 00000009 00000000 da37fcbc c10508a8 f21f08b8
    [ 7612.095604] Call Trace:
    [ 7612.095614]  [<c12ce7c5>] dump_stack+0x41/0x5c
    [ 7612.095620]  [<c104cc59>] warn_slowpath_common+0x89/0xc0
    [ 7612.095628]  [<c10508a8>] ? __local_bh_enable_ip+0x58/0x80
    [ 7612.095634]  [<c10508a8>] ? __local_bh_enable_ip+0x58/0x80
    [ 7612.095640]  [<c104ccad>] warn_slowpath_null+0x1d/0x20
    [ 7612.095646]  [<c10508a8>] __local_bh_enable_ip+0x58/0x80
    [ 7612.095653]  [<c16b7d34>] destroy_conntrack+0x64/0xa0
    [ 7612.095660]  [<c16b300f>] nf_conntrack_destroy+0xf/0x20
    [ 7612.095665]  [<c1677565>] skb_release_head_state+0x55/0xa0
    [ 7612.095670]  [<c16775bb>] skb_release_all+0xb/0x20
    [ 7612.095674]  [<c167760b>] __kfree_skb+0xb/0x60
    [ 7612.095679]  [<c16776f0>] kfree_skb+0x30/0x70
    [ 7612.095686]  [<f81b869d>] ? rtl_pci_reset_trx_ring+0x22d/0x370 [rtl_pci]
    [ 7612.095692]  [<f81b869d>] rtl_pci_reset_trx_ring+0x22d/0x370 [rtl_pci]
    [ 7612.095698]  [<f81b87f9>] rtl_pci_start+0x19/0x190 [rtl_pci]
    [ 7612.095705]  [<f81970e6>] rtl_op_start+0x56/0x90 [rtlwifi]
    [ 7612.095712]  [<c17e3f16>] drv_start+0x36/0xc0
    [ 7612.095717]  [<c17f5ab3>] ieee80211_do_open+0x2d3/0x890
    [ 7612.095725]  [<c16820fe>] ? call_netdevice_notifiers_info+0x2e/0x60
    [ 7612.095730]  [<c17f60bd>] ieee80211_open+0x4d/0x50
    [ 7612.095736]  [<c16891b3>] __dev_open+0xa3/0x130
    [ 7612.095742]  [<c183fa53>] ? _raw_spin_unlock_bh+0x13/0x20
    [ 7612.095748]  [<c1689499>] __dev_change_flags+0x89/0x140
    [ 7612.095753]  [<c127c70d>] ? selinux_capable+0xd/0x10
    [ 7612.095759]  [<c1689589>] dev_change_flags+0x29/0x60
    [ 7612.095765]  [<c1700b93>] devinet_ioctl+0x553/0x670
    [ 7612.095772]  [<c12db758>] ? _copy_to_user+0x28/0x40
    [ 7612.095777]  [<c17018b5>] inet_ioctl+0x85/0xb0
    [ 7612.095783]  [<c166e647>] sock_ioctl+0x67/0x260
    [ 7612.095788]  [<c166e5e0>] ? sock_fasync+0x80/0x80
    [ 7612.095795]  [<c115c99b>] do_vfs_ioctl+0x6b/0x550
    [ 7612.095800]  [<c127c812>] ? selinux_file_ioctl+0x102/0x1e0
    [ 7612.095807]  [<c10a8914>] ? timekeeping_suspend+0x294/0x320
    [ 7612.095813]  [<c10a256a>] ? __hrtimer_run_queues+0x14a/0x210
    [ 7612.095820]  [<c1276e24>] ? security_file_ioctl+0x34/0x50
    [ 7612.095827]  [<c115cef0>] SyS_ioctl+0x70/0x80
    [ 7612.095832]  [<c1001804>] do_fast_syscall_32+0x84/0x120
    [ 7612.095839]  [<c183ff91>] sysenter_past_esp+0x36/0x55
    [ 7612.095844] ---[ end trace 97e9c637a20e8348 ]---
    
    Signed-off-by: Wang YanQing <udknight@gmail.com>
    Acked-by: Larry Finger <Larry.Finger@lwfinger.net>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit fa5c124f7dbee615a8e1fe7c1cb8f65a29040202
Author: Sasha Levin <sasha.levin@oracle.com>
Date:   Tue May 31 21:07:16 2016 -0400

    rtlwifi: pci: use dev_kfree_skb_irq instead of kfree_skb in rtl_pci_reset_trx_ring
    
    [ Upstream commit cf968937d27751296920e6b82ffa89735e3a0023 ]
    
    We can't use kfree_skb in irq disable context, because spin_lock_irqsave
    make sure we are always in irq disable context, use dev_kfree_skb_irq
    instead of kfree_skb is better than dev_kfree_skb_any.
    
    This patch fix below kernel warning:
    [ 7612.095528] ------------[ cut here ]------------
    [ 7612.095546] WARNING: CPU: 3 PID: 4460 at kernel/softirq.c:150 __local_bh_enable_ip+0x58/0x80()
    [ 7612.095550] Modules linked in: rtl8723be x86_pkg_temp_thermal btcoexist rtl_pci rtlwifi rtl8723_common
    [ 7612.095567] CPU: 3 PID: 4460 Comm: ifconfig Tainted: G        W       4.4.0+ #4
    [ 7612.095570] Hardware name: LENOVO 20DFA04FCD/20DFA04FCD, BIOS J5ET48WW (1.19 ) 08/27/2015
    [ 7612.095574]  00000000 00000000 da37fc70 c12ce7c5 00000000 da37fca0 c104cc59 c19d4454
    [ 7612.095584]  00000003 0000116c c19d4784 00000096 c10508a8 c10508a8 00000200 c1b42400
    [ 7612.095594]  f29be780 da37fcb0 c104ccad 00000009 00000000 da37fcbc c10508a8 f21f08b8
    [ 7612.095604] Call Trace:
    [ 7612.095614]  [<c12ce7c5>] dump_stack+0x41/0x5c
    [ 7612.095620]  [<c104cc59>] warn_slowpath_common+0x89/0xc0
    [ 7612.095628]  [<c10508a8>] ? __local_bh_enable_ip+0x58/0x80
    [ 7612.095634]  [<c10508a8>] ? __local_bh_enable_ip+0x58/0x80
    [ 7612.095640]  [<c104ccad>] warn_slowpath_null+0x1d/0x20
    [ 7612.095646]  [<c10508a8>] __local_bh_enable_ip+0x58/0x80
    [ 7612.095653]  [<c16b7d34>] destroy_conntrack+0x64/0xa0
    [ 7612.095660]  [<c16b300f>] nf_conntrack_destroy+0xf/0x20
    [ 7612.095665]  [<c1677565>] skb_release_head_state+0x55/0xa0
    [ 7612.095670]  [<c16775bb>] skb_release_all+0xb/0x20
    [ 7612.095674]  [<c167760b>] __kfree_skb+0xb/0x60
    [ 7612.095679]  [<c16776f0>] kfree_skb+0x30/0x70
    [ 7612.095686]  [<f81b869d>] ? rtl_pci_reset_trx_ring+0x22d/0x370 [rtl_pci]
    [ 7612.095692]  [<f81b869d>] rtl_pci_reset_trx_ring+0x22d/0x370 [rtl_pci]
    [ 7612.095698]  [<f81b87f9>] rtl_pci_start+0x19/0x190 [rtl_pci]
    [ 7612.095705]  [<f81970e6>] rtl_op_start+0x56/0x90 [rtlwifi]
    [ 7612.095712]  [<c17e3f16>] drv_start+0x36/0xc0
    [ 7612.095717]  [<c17f5ab3>] ieee80211_do_open+0x2d3/0x890
    [ 7612.095725]  [<c16820fe>] ? call_netdevice_notifiers_info+0x2e/0x60
    [ 7612.095730]  [<c17f60bd>] ieee80211_open+0x4d/0x50
    [ 7612.095736]  [<c16891b3>] __dev_open+0xa3/0x130
    [ 7612.095742]  [<c183fa53>] ? _raw_spin_unlock_bh+0x13/0x20
    [ 7612.095748]  [<c1689499>] __dev_change_flags+0x89/0x140
    [ 7612.095753]  [<c127c70d>] ? selinux_capable+0xd/0x10
    [ 7612.095759]  [<c1689589>] dev_change_flags+0x29/0x60
    [ 7612.095765]  [<c1700b93>] devinet_ioctl+0x553/0x670
    [ 7612.095772]  [<c12db758>] ? _copy_to_user+0x28/0x40
    [ 7612.095777]  [<c17018b5>] inet_ioctl+0x85/0xb0
    [ 7612.095783]  [<c166e647>] sock_ioctl+0x67/0x260
    [ 7612.095788]  [<c166e5e0>] ? sock_fasync+0x80/0x80
    [ 7612.095795]  [<c115c99b>] do_vfs_ioctl+0x6b/0x550
    [ 7612.095800]  [<c127c812>] ? selinux_file_ioctl+0x102/0x1e0
    [ 7612.095807]  [<c10a8914>] ? timekeeping_suspend+0x294/0x320
    [ 7612.095813]  [<c10a256a>] ? __hrtimer_run_queues+0x14a/0x210
    [ 7612.095820]  [<c1276e24>] ? security_file_ioctl+0x34/0x50
    [ 7612.095827]  [<c115cef0>] SyS_ioctl+0x70/0x80
    [ 7612.095832]  [<c1001804>] do_fast_syscall_32+0x84/0x120
    [ 7612.095839]  [<c183ff91>] sysenter_past_esp+0x36/0x55
    [ 7612.095844] ---[ end trace 97e9c637a20e8348 ]---
    
    Signed-off-by: Wang YanQing <udknight@gmail.com>
    Cc: Stable <stable@vger.kernel.org>
    Acked-by: Larry Finger <Larry.Finger@lwfinger.net>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
    Signed-off-by: Sasha Levin <sasha.levin@oracle.com>

commit 8106278c3064f730d8257f74498b1c18dbb66e93
Author: James Hogan <jhogan@kernel.org>
Date:   Fri Apr 22 10:38:45 2016 +0100

    MIPS: KVM: Fix timer IRQ race when freezing timer
    
    [ Upstream commit 4355c44f063d3de4f072d796604c7f4ba4085cc3 ]
    
    There's a particularly narrow and subtle race condition when the
    software emulated guest timer is frozen which can allow a guest timer
    interrupt to be missed.
    
    This happens due to the hrtimer expiry being inexact, so very
    occasionally the freeze time will be after the moment when the emulated
    CP0_Count transitions to the same value as CP0_Compare (so an IRQ should
    be generated), but before the moment when the hrtimer is due to expire
    (so no IRQ is generated). The IRQ won't be generated when the timer is
    resumed either, since the resume CP0_Count will already match CP0_Compare.
    
    With VZ guests in particular this is far more likely to happen, since
    the soft timer may be frozen frequently in order to restore the timer
    state to the hardware guest timer. This happens after 5-10 hours of
    guest soak testing, resulting in an overflow in guest kernel timekeeping
    calculations, hanging the guest. A more focussed test case to
    intentionally hit the race (with the help of a new hypcall to cause the
    timer state to migrated between hardware & software) hits the condition
    fairly reliably within around 30 seconds.
    
    Instead of relying purely on the inexact hrtimer expiry to determine
    whether an IRQ should be generated, read the guest CP0_Compare and
    directly check whether the freeze time is before or after it. Only if
    CP0_Count is on or after CP0_Compare do we check the hrtimer expiry to
    determine whether the last IRQ has already been generated (which will
    have pushed back the expiry by one timer period).
    
    Fixes: e30492bbe95a ("MIPS: KVM: Rewrite count/compare timer emulation")
    Signed-off-by: James Hogan <james.hogan@imgtec.com>
    Cc: Paolo Bonzini <pbonzini@redhat.com>
    Cc: "Radim KrÄmÃ¡Å™" <rkrcmar@redhat.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: linux-mips@linux-mips.org
    Cc: kvm@vger.kernel.org
    Cc: <stable@vger.kernel.org> # 3.16.x-
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
    Signed-off-by: Sasha Levin <sasha.levin@oracle.com>

commit 23b229af85ee9dceef67760cd1724203015c16a6
Author: Sasha Levin <sasha.levin@oracle.com>
Date:   Tue May 31 21:07:16 2016 -0400

    rtlwifi: pci: use dev_kfree_skb_irq instead of kfree_skb in rtl_pci_reset_trx_ring
    
    [ Upstream commit cf968937d27751296920e6b82ffa89735e3a0023 ]
    
    We can't use kfree_skb in irq disable context, because spin_lock_irqsave
    make sure we are always in irq disable context, use dev_kfree_skb_irq
    instead of kfree_skb is better than dev_kfree_skb_any.
    
    This patch fix below kernel warning:
    [ 7612.095528] ------------[ cut here ]------------
    [ 7612.095546] WARNING: CPU: 3 PID: 4460 at kernel/softirq.c:150 __local_bh_enable_ip+0x58/0x80()
    [ 7612.095550] Modules linked in: rtl8723be x86_pkg_temp_thermal btcoexist rtl_pci rtlwifi rtl8723_common
    [ 7612.095567] CPU: 3 PID: 4460 Comm: ifconfig Tainted: G        W       4.4.0+ #4
    [ 7612.095570] Hardware name: LENOVO 20DFA04FCD/20DFA04FCD, BIOS J5ET48WW (1.19 ) 08/27/2015
    [ 7612.095574]  00000000 00000000 da37fc70 c12ce7c5 00000000 da37fca0 c104cc59 c19d4454
    [ 7612.095584]  00000003 0000116c c19d4784 00000096 c10508a8 c10508a8 00000200 c1b42400
    [ 7612.095594]  f29be780 da37fcb0 c104ccad 00000009 00000000 da37fcbc c10508a8 f21f08b8
    [ 7612.095604] Call Trace:
    [ 7612.095614]  [<c12ce7c5>] dump_stack+0x41/0x5c
    [ 7612.095620]  [<c104cc59>] warn_slowpath_common+0x89/0xc0
    [ 7612.095628]  [<c10508a8>] ? __local_bh_enable_ip+0x58/0x80
    [ 7612.095634]  [<c10508a8>] ? __local_bh_enable_ip+0x58/0x80
    [ 7612.095640]  [<c104ccad>] warn_slowpath_null+0x1d/0x20
    [ 7612.095646]  [<c10508a8>] __local_bh_enable_ip+0x58/0x80
    [ 7612.095653]  [<c16b7d34>] destroy_conntrack+0x64/0xa0
    [ 7612.095660]  [<c16b300f>] nf_conntrack_destroy+0xf/0x20
    [ 7612.095665]  [<c1677565>] skb_release_head_state+0x55/0xa0
    [ 7612.095670]  [<c16775bb>] skb_release_all+0xb/0x20
    [ 7612.095674]  [<c167760b>] __kfree_skb+0xb/0x60
    [ 7612.095679]  [<c16776f0>] kfree_skb+0x30/0x70
    [ 7612.095686]  [<f81b869d>] ? rtl_pci_reset_trx_ring+0x22d/0x370 [rtl_pci]
    [ 7612.095692]  [<f81b869d>] rtl_pci_reset_trx_ring+0x22d/0x370 [rtl_pci]
    [ 7612.095698]  [<f81b87f9>] rtl_pci_start+0x19/0x190 [rtl_pci]
    [ 7612.095705]  [<f81970e6>] rtl_op_start+0x56/0x90 [rtlwifi]
    [ 7612.095712]  [<c17e3f16>] drv_start+0x36/0xc0
    [ 7612.095717]  [<c17f5ab3>] ieee80211_do_open+0x2d3/0x890
    [ 7612.095725]  [<c16820fe>] ? call_netdevice_notifiers_info+0x2e/0x60
    [ 7612.095730]  [<c17f60bd>] ieee80211_open+0x4d/0x50
    [ 7612.095736]  [<c16891b3>] __dev_open+0xa3/0x130
    [ 7612.095742]  [<c183fa53>] ? _raw_spin_unlock_bh+0x13/0x20
    [ 7612.095748]  [<c1689499>] __dev_change_flags+0x89/0x140
    [ 7612.095753]  [<c127c70d>] ? selinux_capable+0xd/0x10
    [ 7612.095759]  [<c1689589>] dev_change_flags+0x29/0x60
    [ 7612.095765]  [<c1700b93>] devinet_ioctl+0x553/0x670
    [ 7612.095772]  [<c12db758>] ? _copy_to_user+0x28/0x40
    [ 7612.095777]  [<c17018b5>] inet_ioctl+0x85/0xb0
    [ 7612.095783]  [<c166e647>] sock_ioctl+0x67/0x260
    [ 7612.095788]  [<c166e5e0>] ? sock_fasync+0x80/0x80
    [ 7612.095795]  [<c115c99b>] do_vfs_ioctl+0x6b/0x550
    [ 7612.095800]  [<c127c812>] ? selinux_file_ioctl+0x102/0x1e0
    [ 7612.095807]  [<c10a8914>] ? timekeeping_suspend+0x294/0x320
    [ 7612.095813]  [<c10a256a>] ? __hrtimer_run_queues+0x14a/0x210
    [ 7612.095820]  [<c1276e24>] ? security_file_ioctl+0x34/0x50
    [ 7612.095827]  [<c115cef0>] SyS_ioctl+0x70/0x80
    [ 7612.095832]  [<c1001804>] do_fast_syscall_32+0x84/0x120
    [ 7612.095839]  [<c183ff91>] sysenter_past_esp+0x36/0x55
    [ 7612.095844] ---[ end trace 97e9c637a20e8348 ]---
    
    Signed-off-by: Wang YanQing <udknight@gmail.com>
    Cc: Stable <stable@vger.kernel.org>
    Acked-by: Larry Finger <Larry.Finger@lwfinger.net>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
    Signed-off-by: Sasha Levin <sasha.levin@oracle.com>

commit f255eae4b8c9fdac4cf3138bb80c5dc584a781ed
Author: James Hogan <jhogan@kernel.org>
Date:   Fri Apr 22 10:38:45 2016 +0100

    MIPS: KVM: Fix timer IRQ race when freezing timer
    
    [ Upstream commit 4355c44f063d3de4f072d796604c7f4ba4085cc3 ]
    
    There's a particularly narrow and subtle race condition when the
    software emulated guest timer is frozen which can allow a guest timer
    interrupt to be missed.
    
    This happens due to the hrtimer expiry being inexact, so very
    occasionally the freeze time will be after the moment when the emulated
    CP0_Count transitions to the same value as CP0_Compare (so an IRQ should
    be generated), but before the moment when the hrtimer is due to expire
    (so no IRQ is generated). The IRQ won't be generated when the timer is
    resumed either, since the resume CP0_Count will already match CP0_Compare.
    
    With VZ guests in particular this is far more likely to happen, since
    the soft timer may be frozen frequently in order to restore the timer
    state to the hardware guest timer. This happens after 5-10 hours of
    guest soak testing, resulting in an overflow in guest kernel timekeeping
    calculations, hanging the guest. A more focussed test case to
    intentionally hit the race (with the help of a new hypcall to cause the
    timer state to migrated between hardware & software) hits the condition
    fairly reliably within around 30 seconds.
    
    Instead of relying purely on the inexact hrtimer expiry to determine
    whether an IRQ should be generated, read the guest CP0_Compare and
    directly check whether the freeze time is before or after it. Only if
    CP0_Count is on or after CP0_Compare do we check the hrtimer expiry to
    determine whether the last IRQ has already been generated (which will
    have pushed back the expiry by one timer period).
    
    Fixes: e30492bbe95a ("MIPS: KVM: Rewrite count/compare timer emulation")
    Signed-off-by: James Hogan <james.hogan@imgtec.com>
    Cc: Paolo Bonzini <pbonzini@redhat.com>
    Cc: "Radim KrÄmÃ¡Å™" <rkrcmar@redhat.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: linux-mips@linux-mips.org
    Cc: kvm@vger.kernel.org
    Cc: <stable@vger.kernel.org> # 3.16.x-
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
    Signed-off-by: Sasha Levin <sasha.levin@oracle.com>

commit 5a1a83e4f24ed5b304c89d6f04f6b696a0f1b4d7
Author: James Hogan <jhogan@kernel.org>
Date:   Fri Apr 22 10:38:45 2016 +0100

    MIPS: KVM: Fix timer IRQ race when freezing timer
    
    commit 4355c44f063d3de4f072d796604c7f4ba4085cc3 upstream.
    
    There's a particularly narrow and subtle race condition when the
    software emulated guest timer is frozen which can allow a guest timer
    interrupt to be missed.
    
    This happens due to the hrtimer expiry being inexact, so very
    occasionally the freeze time will be after the moment when the emulated
    CP0_Count transitions to the same value as CP0_Compare (so an IRQ should
    be generated), but before the moment when the hrtimer is due to expire
    (so no IRQ is generated). The IRQ won't be generated when the timer is
    resumed either, since the resume CP0_Count will already match CP0_Compare.
    
    With VZ guests in particular this is far more likely to happen, since
    the soft timer may be frozen frequently in order to restore the timer
    state to the hardware guest timer. This happens after 5-10 hours of
    guest soak testing, resulting in an overflow in guest kernel timekeeping
    calculations, hanging the guest. A more focussed test case to
    intentionally hit the race (with the help of a new hypcall to cause the
    timer state to migrated between hardware & software) hits the condition
    fairly reliably within around 30 seconds.
    
    Instead of relying purely on the inexact hrtimer expiry to determine
    whether an IRQ should be generated, read the guest CP0_Compare and
    directly check whether the freeze time is before or after it. Only if
    CP0_Count is on or after CP0_Compare do we check the hrtimer expiry to
    determine whether the last IRQ has already been generated (which will
    have pushed back the expiry by one timer period).
    
    Fixes: e30492bbe95a ("MIPS: KVM: Rewrite count/compare timer emulation")
    Signed-off-by: James Hogan <james.hogan@imgtec.com>
    Cc: Paolo Bonzini <pbonzini@redhat.com>
    Cc: "Radim KrÄmÃ¡Å™" <rkrcmar@redhat.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: linux-mips@linux-mips.org
    Cc: kvm@vger.kernel.org
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit d2760fa98aac28d840d5041085a2ba39472d5a1f
Author: James Hogan <jhogan@kernel.org>
Date:   Fri Apr 22 10:38:45 2016 +0100

    MIPS: KVM: Fix timer IRQ race when freezing timer
    
    commit 4355c44f063d3de4f072d796604c7f4ba4085cc3 upstream.
    
    There's a particularly narrow and subtle race condition when the
    software emulated guest timer is frozen which can allow a guest timer
    interrupt to be missed.
    
    This happens due to the hrtimer expiry being inexact, so very
    occasionally the freeze time will be after the moment when the emulated
    CP0_Count transitions to the same value as CP0_Compare (so an IRQ should
    be generated), but before the moment when the hrtimer is due to expire
    (so no IRQ is generated). The IRQ won't be generated when the timer is
    resumed either, since the resume CP0_Count will already match CP0_Compare.
    
    With VZ guests in particular this is far more likely to happen, since
    the soft timer may be frozen frequently in order to restore the timer
    state to the hardware guest timer. This happens after 5-10 hours of
    guest soak testing, resulting in an overflow in guest kernel timekeeping
    calculations, hanging the guest. A more focussed test case to
    intentionally hit the race (with the help of a new hypcall to cause the
    timer state to migrated between hardware & software) hits the condition
    fairly reliably within around 30 seconds.
    
    Instead of relying purely on the inexact hrtimer expiry to determine
    whether an IRQ should be generated, read the guest CP0_Compare and
    directly check whether the freeze time is before or after it. Only if
    CP0_Count is on or after CP0_Compare do we check the hrtimer expiry to
    determine whether the last IRQ has already been generated (which will
    have pushed back the expiry by one timer period).
    
    Fixes: e30492bbe95a ("MIPS: KVM: Rewrite count/compare timer emulation")
    Signed-off-by: James Hogan <james.hogan@imgtec.com>
    Cc: Paolo Bonzini <pbonzini@redhat.com>
    Cc: "Radim KrÄmÃ¡Å™" <rkrcmar@redhat.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: linux-mips@linux-mips.org
    Cc: kvm@vger.kernel.org
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 9e01c02f98f98c03cba7e147577364b667d03808
Author: James Hogan <jhogan@kernel.org>
Date:   Fri Apr 22 10:38:45 2016 +0100

    MIPS: KVM: Fix timer IRQ race when freezing timer
    
    commit 4355c44f063d3de4f072d796604c7f4ba4085cc3 upstream.
    
    There's a particularly narrow and subtle race condition when the
    software emulated guest timer is frozen which can allow a guest timer
    interrupt to be missed.
    
    This happens due to the hrtimer expiry being inexact, so very
    occasionally the freeze time will be after the moment when the emulated
    CP0_Count transitions to the same value as CP0_Compare (so an IRQ should
    be generated), but before the moment when the hrtimer is due to expire
    (so no IRQ is generated). The IRQ won't be generated when the timer is
    resumed either, since the resume CP0_Count will already match CP0_Compare.
    
    With VZ guests in particular this is far more likely to happen, since
    the soft timer may be frozen frequently in order to restore the timer
    state to the hardware guest timer. This happens after 5-10 hours of
    guest soak testing, resulting in an overflow in guest kernel timekeeping
    calculations, hanging the guest. A more focussed test case to
    intentionally hit the race (with the help of a new hypcall to cause the
    timer state to migrated between hardware & software) hits the condition
    fairly reliably within around 30 seconds.
    
    Instead of relying purely on the inexact hrtimer expiry to determine
    whether an IRQ should be generated, read the guest CP0_Compare and
    directly check whether the freeze time is before or after it. Only if
    CP0_Count is on or after CP0_Compare do we check the hrtimer expiry to
    determine whether the last IRQ has already been generated (which will
    have pushed back the expiry by one timer period).
    
    Fixes: e30492bbe95a ("MIPS: KVM: Rewrite count/compare timer emulation")
    Signed-off-by: James Hogan <james.hogan@imgtec.com>
    Cc: Paolo Bonzini <pbonzini@redhat.com>
    Cc: "Radim KrÄmÃ¡Å™" <rkrcmar@redhat.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: linux-mips@linux-mips.org
    Cc: kvm@vger.kernel.org
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 8eb64c913af6f50933b6a332123d7bb8688b7244
Author: Filipe Manana <fdmanana@suse.com>
Date:   Thu Feb 18 14:28:55 2016 +0000

    Btrfs: fix deadlock between direct IO reads and buffered writes
    
    commit ade770294df29e08f913e5d733a756893128f45e upstream.
    
    While running a test with a mix of buffered IO and direct IO against
    the same files I hit a deadlock reported by the following trace:
    
    [11642.140352] INFO: task kworker/u32:3:15282 blocked for more than 120 seconds.
    [11642.142452]       Not tainted 4.4.0-rc6-btrfs-next-21+ #1
    [11642.143982] "echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
    [11642.146332] kworker/u32:3   D ffff880230ef7988 [11642.147737] systemd-journald[571]: Sent WATCHDOG=1 notification.
    [11642.149771]     0 15282      2 0x00000000
    [11642.151205] Workqueue: btrfs-flush_delalloc btrfs_flush_delalloc_helper [btrfs]
    [11642.154074]  ffff880230ef7988 0000000000000246 0000000000014ec0 ffff88023ec94ec0
    [11642.156722]  ffff880233fe8f80 ffff880230ef8000 ffff88023ec94ec0 7fffffffffffffff
    [11642.159205]  0000000000000002 ffffffff8147b7f9 ffff880230ef79a0 ffffffff8147b541
    [11642.161403] Call Trace:
    [11642.162129]  [<ffffffff8147b7f9>] ? bit_wait+0x2f/0x2f
    [11642.163396]  [<ffffffff8147b541>] schedule+0x82/0x9a
    [11642.164871]  [<ffffffff8147e7fe>] schedule_timeout+0x43/0x109
    [11642.167020]  [<ffffffff8147b7f9>] ? bit_wait+0x2f/0x2f
    [11642.167931]  [<ffffffff8108afd1>] ? trace_hardirqs_on_caller+0x17b/0x197
    [11642.182320]  [<ffffffff8108affa>] ? trace_hardirqs_on+0xd/0xf
    [11642.183762]  [<ffffffff810b079b>] ? timekeeping_get_ns+0xe/0x33
    [11642.185308]  [<ffffffff810b0f61>] ? ktime_get+0x41/0x52
    [11642.186782]  [<ffffffff8147ac08>] io_schedule_timeout+0xa0/0x102
    [11642.188217]  [<ffffffff8147ac08>] ? io_schedule_timeout+0xa0/0x102
    [11642.189626]  [<ffffffff8147b814>] bit_wait_io+0x1b/0x39
    [11642.190803]  [<ffffffff8147bb21>] __wait_on_bit_lock+0x4c/0x90
    [11642.192158]  [<ffffffff8111829f>] __lock_page+0x66/0x68
    [11642.193379]  [<ffffffff81082f29>] ? autoremove_wake_function+0x3a/0x3a
    [11642.194831]  [<ffffffffa0450ddd>] lock_page+0x31/0x34 [btrfs]
    [11642.197068]  [<ffffffffa0454e3b>] extent_write_cache_pages.isra.19.constprop.35+0x1af/0x2f4 [btrfs]
    [11642.199188]  [<ffffffffa0455373>] extent_writepages+0x4b/0x5c [btrfs]
    [11642.200723]  [<ffffffffa043c913>] ? btrfs_writepage_start_hook+0xce/0xce [btrfs]
    [11642.202465]  [<ffffffffa043aa82>] btrfs_writepages+0x28/0x2a [btrfs]
    [11642.203836]  [<ffffffff811236bc>] do_writepages+0x23/0x2c
    [11642.205624]  [<ffffffff811198c9>] __filemap_fdatawrite_range+0x5a/0x61
    [11642.207057]  [<ffffffff81119946>] filemap_fdatawrite_range+0x13/0x15
    [11642.208529]  [<ffffffffa044f87e>] btrfs_start_ordered_extent+0xd0/0x1a1 [btrfs]
    [11642.210375]  [<ffffffffa0462613>] ? btrfs_scrubparity_helper+0x140/0x33a [btrfs]
    [11642.212132]  [<ffffffffa044f974>] btrfs_run_ordered_extent_work+0x25/0x34 [btrfs]
    [11642.213837]  [<ffffffffa046262f>] btrfs_scrubparity_helper+0x15c/0x33a [btrfs]
    [11642.215457]  [<ffffffffa046293b>] btrfs_flush_delalloc_helper+0xe/0x10 [btrfs]
    [11642.217095]  [<ffffffff8106483e>] process_one_work+0x256/0x48b
    [11642.218324]  [<ffffffff81064f20>] worker_thread+0x1f5/0x2a7
    [11642.219466]  [<ffffffff81064d2b>] ? rescuer_thread+0x289/0x289
    [11642.220801]  [<ffffffff8106a500>] kthread+0xd4/0xdc
    [11642.222032]  [<ffffffff8106a42c>] ? kthread_parkme+0x24/0x24
    [11642.223190]  [<ffffffff8147fdef>] ret_from_fork+0x3f/0x70
    [11642.224394]  [<ffffffff8106a42c>] ? kthread_parkme+0x24/0x24
    [11642.226295] 2 locks held by kworker/u32:3/15282:
    [11642.227273]  #0:  ("%s-%s""btrfs", name){++++.+}, at: [<ffffffff8106474d>] process_one_work+0x165/0x48b
    [11642.229412]  #1:  ((&work->normal_work)){+.+.+.}, at: [<ffffffff8106474d>] process_one_work+0x165/0x48b
    [11642.231414] INFO: task kworker/u32:8:15289 blocked for more than 120 seconds.
    [11642.232872]       Not tainted 4.4.0-rc6-btrfs-next-21+ #1
    [11642.234109] "echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
    [11642.235776] kworker/u32:8   D ffff88020de5f848     0 15289      2 0x00000000
    [11642.237412] Workqueue: writeback wb_workfn (flush-btrfs-481)
    [11642.238670]  ffff88020de5f848 0000000000000246 0000000000014ec0 ffff88023ed54ec0
    [11642.240475]  ffff88021b1ece40 ffff88020de60000 ffff88023ed54ec0 7fffffffffffffff
    [11642.242154]  0000000000000002 ffffffff8147b7f9 ffff88020de5f860 ffffffff8147b541
    [11642.243715] Call Trace:
    [11642.244390]  [<ffffffff8147b7f9>] ? bit_wait+0x2f/0x2f
    [11642.245432]  [<ffffffff8147b541>] schedule+0x82/0x9a
    [11642.246392]  [<ffffffff8147e7fe>] schedule_timeout+0x43/0x109
    [11642.247479]  [<ffffffff8147b7f9>] ? bit_wait+0x2f/0x2f
    [11642.248551]  [<ffffffff8108afd1>] ? trace_hardirqs_on_caller+0x17b/0x197
    [11642.249968]  [<ffffffff8108affa>] ? trace_hardirqs_on+0xd/0xf
    [11642.251043]  [<ffffffff810b079b>] ? timekeeping_get_ns+0xe/0x33
    [11642.252202]  [<ffffffff810b0f61>] ? ktime_get+0x41/0x52
    [11642.253210]  [<ffffffff8147ac08>] io_schedule_timeout+0xa0/0x102
    [11642.254307]  [<ffffffff8147ac08>] ? io_schedule_timeout+0xa0/0x102
    [11642.256118]  [<ffffffff8147b814>] bit_wait_io+0x1b/0x39
    [11642.257131]  [<ffffffff8147bb21>] __wait_on_bit_lock+0x4c/0x90
    [11642.258200]  [<ffffffff8111829f>] __lock_page+0x66/0x68
    [11642.259168]  [<ffffffff81082f29>] ? autoremove_wake_function+0x3a/0x3a
    [11642.260516]  [<ffffffffa0450ddd>] lock_page+0x31/0x34 [btrfs]
    [11642.261841]  [<ffffffffa0454e3b>] extent_write_cache_pages.isra.19.constprop.35+0x1af/0x2f4 [btrfs]
    [11642.263531]  [<ffffffffa0455373>] extent_writepages+0x4b/0x5c [btrfs]
    [11642.264747]  [<ffffffffa043c913>] ? btrfs_writepage_start_hook+0xce/0xce [btrfs]
    [11642.266148]  [<ffffffffa043aa82>] btrfs_writepages+0x28/0x2a [btrfs]
    [11642.267264]  [<ffffffff811236bc>] do_writepages+0x23/0x2c
    [11642.268280]  [<ffffffff81192a2b>] __writeback_single_inode+0xda/0x5ba
    [11642.269407]  [<ffffffff811939f0>] writeback_sb_inodes+0x27b/0x43d
    [11642.270476]  [<ffffffff81193c28>] __writeback_inodes_wb+0x76/0xae
    [11642.271547]  [<ffffffff81193ea6>] wb_writeback+0x19e/0x41c
    [11642.272588]  [<ffffffff81194821>] wb_workfn+0x201/0x341
    [11642.273523]  [<ffffffff81194821>] ? wb_workfn+0x201/0x341
    [11642.274479]  [<ffffffff8106483e>] process_one_work+0x256/0x48b
    [11642.275497]  [<ffffffff81064f20>] worker_thread+0x1f5/0x2a7
    [11642.276518]  [<ffffffff81064d2b>] ? rescuer_thread+0x289/0x289
    [11642.277520]  [<ffffffff81064d2b>] ? rescuer_thread+0x289/0x289
    [11642.278517]  [<ffffffff8106a500>] kthread+0xd4/0xdc
    [11642.279371]  [<ffffffff8106a42c>] ? kthread_parkme+0x24/0x24
    [11642.280468]  [<ffffffff8147fdef>] ret_from_fork+0x3f/0x70
    [11642.281607]  [<ffffffff8106a42c>] ? kthread_parkme+0x24/0x24
    [11642.282604] 3 locks held by kworker/u32:8/15289:
    [11642.283423]  #0:  ("writeback"){++++.+}, at: [<ffffffff8106474d>] process_one_work+0x165/0x48b
    [11642.285629]  #1:  ((&(&wb->dwork)->work)){+.+.+.}, at: [<ffffffff8106474d>] process_one_work+0x165/0x48b
    [11642.287538]  #2:  (&type->s_umount_key#37){+++++.}, at: [<ffffffff81171217>] trylock_super+0x1b/0x4b
    [11642.289423] INFO: task fdm-stress:26848 blocked for more than 120 seconds.
    [11642.290547]       Not tainted 4.4.0-rc6-btrfs-next-21+ #1
    [11642.291453] "echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
    [11642.292864] fdm-stress      D ffff88022c107c20     0 26848  26591 0x00000000
    [11642.294118]  ffff88022c107c20 000000038108affa 0000000000014ec0 ffff88023ed54ec0
    [11642.295602]  ffff88013ab1ca40 ffff88022c108000 ffff8800b2fc19d0 00000000000e0fff
    [11642.297098]  ffff8800b2fc19b0 ffff88022c107c88 ffff88022c107c38 ffffffff8147b541
    [11642.298433] Call Trace:
    [11642.298896]  [<ffffffff8147b541>] schedule+0x82/0x9a
    [11642.299738]  [<ffffffffa045225d>] lock_extent_bits+0xfe/0x1a3 [btrfs]
    [11642.300833]  [<ffffffff81082eef>] ? add_wait_queue_exclusive+0x44/0x44
    [11642.301943]  [<ffffffffa0447516>] lock_and_cleanup_extent_if_need+0x68/0x18e [btrfs]
    [11642.303270]  [<ffffffffa04485ba>] __btrfs_buffered_write+0x238/0x4c1 [btrfs]
    [11642.304552]  [<ffffffffa044b50a>] ? btrfs_file_write_iter+0x17c/0x408 [btrfs]
    [11642.305782]  [<ffffffffa044b682>] btrfs_file_write_iter+0x2f4/0x408 [btrfs]
    [11642.306878]  [<ffffffff8116e298>] __vfs_write+0x7c/0xa5
    [11642.307729]  [<ffffffff8116e7d1>] vfs_write+0x9d/0xe8
    [11642.308602]  [<ffffffff8116efbb>] SyS_write+0x50/0x7e
    [11642.309410]  [<ffffffff8147fa97>] entry_SYSCALL_64_fastpath+0x12/0x6b
    [11642.310403] 3 locks held by fdm-stress/26848:
    [11642.311108]  #0:  (&f->f_pos_lock){+.+.+.}, at: [<ffffffff811877e8>] __fdget_pos+0x3a/0x40
    [11642.312578]  #1:  (sb_writers#11){.+.+.+}, at: [<ffffffff811706ee>] __sb_start_write+0x5f/0xb0
    [11642.314170]  #2:  (&sb->s_type->i_mutex_key#15){+.+.+.}, at: [<ffffffffa044b401>] btrfs_file_write_iter+0x73/0x408 [btrfs]
    [11642.316796] INFO: task fdm-stress:26849 blocked for more than 120 seconds.
    [11642.317842]       Not tainted 4.4.0-rc6-btrfs-next-21+ #1
    [11642.318691] "echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
    [11642.319959] fdm-stress      D ffff8801964ffa68     0 26849  26591 0x00000000
    [11642.321312]  ffff8801964ffa68 00ff8801e9975f80 0000000000014ec0 ffff88023ed94ec0
    [11642.322555]  ffff8800b00b4840 ffff880196500000 ffff8801e9975f20 0000000000000002
    [11642.323715]  ffff8801e9975f18 ffff8800b00b4840 ffff8801964ffa80 ffffffff8147b541
    [11642.325096] Call Trace:
    [11642.325532]  [<ffffffff8147b541>] schedule+0x82/0x9a
    [11642.326303]  [<ffffffff8147e7fe>] schedule_timeout+0x43/0x109
    [11642.327180]  [<ffffffff8108ae40>] ? mark_held_locks+0x5e/0x74
    [11642.328114]  [<ffffffff8147f30e>] ? _raw_spin_unlock_irq+0x2c/0x4a
    [11642.329051]  [<ffffffff8108afd1>] ? trace_hardirqs_on_caller+0x17b/0x197
    [11642.330053]  [<ffffffff8147bceb>] __wait_for_common+0x109/0x147
    [11642.330952]  [<ffffffff8147bceb>] ? __wait_for_common+0x109/0x147
    [11642.331869]  [<ffffffff8147e7bb>] ? usleep_range+0x4a/0x4a
    [11642.332925]  [<ffffffff81074075>] ? wake_up_q+0x47/0x47
    [11642.333736]  [<ffffffff8147bd4d>] wait_for_completion+0x24/0x26
    [11642.334672]  [<ffffffffa044f5ce>] btrfs_wait_ordered_extents+0x1c8/0x217 [btrfs]
    [11642.335858]  [<ffffffffa0465b5a>] btrfs_mksubvol+0x224/0x45d [btrfs]
    [11642.336854]  [<ffffffff81082eef>] ? add_wait_queue_exclusive+0x44/0x44
    [11642.337820]  [<ffffffffa0465edb>] btrfs_ioctl_snap_create_transid+0x148/0x17a [btrfs]
    [11642.339026]  [<ffffffffa046603b>] btrfs_ioctl_snap_create_v2+0xc7/0x110 [btrfs]
    [11642.340214]  [<ffffffffa0468582>] btrfs_ioctl+0x590/0x27bd [btrfs]
    [11642.341123]  [<ffffffff8147dc00>] ? mutex_unlock+0xe/0x10
    [11642.341934]  [<ffffffffa00fa6e9>] ? ext4_file_write_iter+0x2a3/0x36f [ext4]
    [11642.342936]  [<ffffffff8108895d>] ? __lock_is_held+0x3c/0x57
    [11642.343772]  [<ffffffff81186a1d>] ? rcu_read_unlock+0x3e/0x5d
    [11642.344673]  [<ffffffff8117dc95>] do_vfs_ioctl+0x458/0x4dc
    [11642.346024]  [<ffffffff81186bbe>] ? __fget_light+0x62/0x71
    [11642.346873]  [<ffffffff8117dd70>] SyS_ioctl+0x57/0x79
    [11642.347720]  [<ffffffff8147fa97>] entry_SYSCALL_64_fastpath+0x12/0x6b
    [11642.350222] 4 locks held by fdm-stress/26849:
    [11642.350898]  #0:  (sb_writers#11){.+.+.+}, at: [<ffffffff811706ee>] __sb_start_write+0x5f/0xb0
    [11642.352375]  #1:  (&type->i_mutex_dir_key#4/1){+.+.+.}, at: [<ffffffffa0465981>] btrfs_mksubvol+0x4b/0x45d [btrfs]
    [11642.354072]  #2:  (&fs_info->subvol_sem){++++..}, at: [<ffffffffa0465a2a>] btrfs_mksubvol+0xf4/0x45d [btrfs]
    [11642.355647]  #3:  (&root->ordered_extent_mutex){+.+...}, at: [<ffffffffa044f456>] btrfs_wait_ordered_extents+0x50/0x217 [btrfs]
    [11642.357516] INFO: task fdm-stress:26850 blocked for more than 120 seconds.
    [11642.358508]       Not tainted 4.4.0-rc6-btrfs-next-21+ #1
    [11642.359376] "echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
    [11642.368625] fdm-stress      D ffff88021f167688     0 26850  26591 0x00000000
    [11642.369716]  ffff88021f167688 0000000000000001 0000000000014ec0 ffff88023edd4ec0
    [11642.370950]  ffff880128a98680 ffff88021f168000 ffff88023edd4ec0 7fffffffffffffff
    [11642.372210]  0000000000000002 ffffffff8147b7f9 ffff88021f1676a0 ffffffff8147b541
    [11642.373430] Call Trace:
    [11642.373853]  [<ffffffff8147b7f9>] ? bit_wait+0x2f/0x2f
    [11642.374623]  [<ffffffff8147b541>] schedule+0x82/0x9a
    [11642.375948]  [<ffffffff8147e7fe>] schedule_timeout+0x43/0x109
    [11642.376862]  [<ffffffff8147b7f9>] ? bit_wait+0x2f/0x2f
    [11642.377637]  [<ffffffff8108afd1>] ? trace_hardirqs_on_caller+0x17b/0x197
    [11642.378610]  [<ffffffff8108affa>] ? trace_hardirqs_on+0xd/0xf
    [11642.379457]  [<ffffffff810b079b>] ? timekeeping_get_ns+0xe/0x33
    [11642.380366]  [<ffffffff810b0f61>] ? ktime_get+0x41/0x52
    [11642.381353]  [<ffffffff8147ac08>] io_schedule_timeout+0xa0/0x102
    [11642.382255]  [<ffffffff8147ac08>] ? io_schedule_timeout+0xa0/0x102
    [11642.383162]  [<ffffffff8147b814>] bit_wait_io+0x1b/0x39
    [11642.383945]  [<ffffffff8147bb21>] __wait_on_bit_lock+0x4c/0x90
    [11642.384875]  [<ffffffff8111829f>] __lock_page+0x66/0x68
    [11642.385749]  [<ffffffff81082f29>] ? autoremove_wake_function+0x3a/0x3a
    [11642.386721]  [<ffffffffa0450ddd>] lock_page+0x31/0x34 [btrfs]
    [11642.387596]  [<ffffffffa0454e3b>] extent_write_cache_pages.isra.19.constprop.35+0x1af/0x2f4 [btrfs]
    [11642.389030]  [<ffffffffa0455373>] extent_writepages+0x4b/0x5c [btrfs]
    [11642.389973]  [<ffffffff810a25ad>] ? rcu_read_lock_sched_held+0x61/0x69
    [11642.390939]  [<ffffffffa043c913>] ? btrfs_writepage_start_hook+0xce/0xce [btrfs]
    [11642.392271]  [<ffffffffa0451c32>] ? __clear_extent_bit+0x26e/0x2c0 [btrfs]
    [11642.393305]  [<ffffffffa043aa82>] btrfs_writepages+0x28/0x2a [btrfs]
    [11642.394239]  [<ffffffff811236bc>] do_writepages+0x23/0x2c
    [11642.395045]  [<ffffffff811198c9>] __filemap_fdatawrite_range+0x5a/0x61
    [11642.395991]  [<ffffffff81119946>] filemap_fdatawrite_range+0x13/0x15
    [11642.397144]  [<ffffffffa044f87e>] btrfs_start_ordered_extent+0xd0/0x1a1 [btrfs]
    [11642.398392]  [<ffffffffa0452094>] ? clear_extent_bit+0x17/0x19 [btrfs]
    [11642.399363]  [<ffffffffa0445945>] btrfs_get_blocks_direct+0x12b/0x61c [btrfs]
    [11642.400445]  [<ffffffff8119f7a1>] ? dio_bio_add_page+0x3d/0x54
    [11642.401309]  [<ffffffff8119fa93>] ? submit_page_section+0x7b/0x111
    [11642.402213]  [<ffffffff811a0258>] do_blockdev_direct_IO+0x685/0xc24
    [11642.403139]  [<ffffffffa044581a>] ? btrfs_page_exists_in_range+0x1a1/0x1a1 [btrfs]
    [11642.404360]  [<ffffffffa043d267>] ? btrfs_get_extent_fiemap+0x1c0/0x1c0 [btrfs]
    [11642.406187]  [<ffffffff811a0828>] __blockdev_direct_IO+0x31/0x33
    [11642.407070]  [<ffffffff811a0828>] ? __blockdev_direct_IO+0x31/0x33
    [11642.407990]  [<ffffffffa043d267>] ? btrfs_get_extent_fiemap+0x1c0/0x1c0 [btrfs]
    [11642.409192]  [<ffffffffa043b4ca>] btrfs_direct_IO+0x1c7/0x27e [btrfs]
    [11642.410146]  [<ffffffffa043d267>] ? btrfs_get_extent_fiemap+0x1c0/0x1c0 [btrfs]
    [11642.411291]  [<ffffffff81119a2c>] generic_file_read_iter+0x89/0x4e1
    [11642.412263]  [<ffffffff8108ac05>] ? mark_lock+0x24/0x201
    [11642.413057]  [<ffffffff8116e1f8>] __vfs_read+0x79/0x9d
    [11642.413897]  [<ffffffff8116e6f1>] vfs_read+0x8f/0xd2
    [11642.414708]  [<ffffffff8116ef3d>] SyS_read+0x50/0x7e
    [11642.415573]  [<ffffffff8147fa97>] entry_SYSCALL_64_fastpath+0x12/0x6b
    [11642.416572] 1 lock held by fdm-stress/26850:
    [11642.417345]  #0:  (&f->f_pos_lock){+.+.+.}, at: [<ffffffff811877e8>] __fdget_pos+0x3a/0x40
    [11642.418703] INFO: task fdm-stress:26851 blocked for more than 120 seconds.
    [11642.419698]       Not tainted 4.4.0-rc6-btrfs-next-21+ #1
    [11642.420612] "echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
    [11642.421807] fdm-stress      D ffff880196483d28     0 26851  26591 0x00000000
    [11642.422878]  ffff880196483d28 00ff8801c8f60740 0000000000014ec0 ffff88023ed94ec0
    [11642.424149]  ffff8801c8f60740 ffff880196484000 0000000000000246 ffff8801c8f60740
    [11642.425374]  ffff8801bb711840 ffff8801bb711878 ffff880196483d40 ffffffff8147b541
    [11642.426591] Call Trace:
    [11642.427013]  [<ffffffff8147b541>] schedule+0x82/0x9a
    [11642.427856]  [<ffffffff8147b6d5>] schedule_preempt_disabled+0x18/0x24
    [11642.428852]  [<ffffffff8147c23a>] mutex_lock_nested+0x1d7/0x3b4
    [11642.429743]  [<ffffffffa044f456>] ? btrfs_wait_ordered_extents+0x50/0x217 [btrfs]
    [11642.430911]  [<ffffffffa044f456>] btrfs_wait_ordered_extents+0x50/0x217 [btrfs]
    [11642.432102]  [<ffffffffa044f674>] ? btrfs_wait_ordered_roots+0x57/0x191 [btrfs]
    [11642.433259]  [<ffffffffa044f456>] ? btrfs_wait_ordered_extents+0x50/0x217 [btrfs]
    [11642.434431]  [<ffffffffa044f6ea>] btrfs_wait_ordered_roots+0xcd/0x191 [btrfs]
    [11642.436079]  [<ffffffffa0410cab>] btrfs_sync_fs+0xe0/0x1ad [btrfs]
    [11642.437009]  [<ffffffff81197900>] ? SyS_tee+0x23c/0x23c
    [11642.437860]  [<ffffffff81197920>] sync_fs_one_sb+0x20/0x22
    [11642.438723]  [<ffffffff81171435>] iterate_supers+0x75/0xc2
    [11642.439597]  [<ffffffff81197d00>] sys_sync+0x52/0x80
    [11642.440454]  [<ffffffff8147fa97>] entry_SYSCALL_64_fastpath+0x12/0x6b
    [11642.441533] 3 locks held by fdm-stress/26851:
    [11642.442370]  #0:  (&type->s_umount_key#37){+++++.}, at: [<ffffffff8117141f>] iterate_supers+0x5f/0xc2
    [11642.444043]  #1:  (&fs_info->ordered_operations_mutex){+.+...}, at: [<ffffffffa044f661>] btrfs_wait_ordered_roots+0x44/0x191 [btrfs]
    [11642.446010]  #2:  (&root->ordered_extent_mutex){+.+...}, at: [<ffffffffa044f456>] btrfs_wait_ordered_extents+0x50/0x217 [btrfs]
    
    This happened because under specific timings the path for direct IO reads
    can deadlock with concurrent buffered writes. The diagram below shows how
    this happens for an example file that has the following layout:
    
         [  extent A  ]  [  extent B  ]  [ ....
         0K              4K              8K
    
         CPU 1                                               CPU 2                             CPU 3
    
    DIO read against range
     [0K, 8K[ starts
    
    btrfs_direct_IO()
      --> calls btrfs_get_blocks_direct()
          which finds the extent map for the
          extent A and leaves the range
          [0K, 4K[ locked in the inode's
          io tree
    
                                                       buffered write against
                                                       range [4K, 8K[ starts
    
                                                       __btrfs_buffered_write()
                                                         --> dirties page at 4K
    
                                                                                         a user space
                                                                                         task calls sync
                                                                                         for e.g or
                                                                                         writepages() is
                                                                                         invoked by mm
    
                                                                                         writepages()
                                                                                           run_delalloc_range()
                                                                                             cow_file_range()
                                                                                               --> ordered extent X
                                                                                                   for the buffered
                                                                                                   write is created
                                                                                                   and
                                                                                                   writeback starts
    
      --> calls btrfs_get_blocks_direct()
          again, without submitting first
          a bio for reading extent A, and
          finds the extent map for extent B
    
      --> calls lock_extent_direct()
    
          --> locks range [4K, 8K[
          --> finds ordered extent X
              covering range [4K, 8K[
          --> unlocks range [4K, 8K[
    
                                                      buffered write against
                                                      range [0K, 8K[ starts
    
                                                      __btrfs_buffered_write()
                                                        prepare_pages()
                                                          --> locks pages with
                                                              offsets 0 and 4K
                                                        lock_and_cleanup_extent_if_need()
                                                          --> blocks attempting to
                                                              lock range [0K, 8K[ in
                                                              the inode's io tree,
                                                              because the range [0, 4K[
                                                              is already locked by the
                                                              direct IO task at CPU 1
    
          --> calls
              btrfs_start_ordered_extent(oe X)
    
              btrfs_start_ordered_extent(oe X)
    
                --> At this point writeback for ordered
                    extent X has not finished yet
    
                filemap_fdatawrite_range()
                  btrfs_writepages()
                    extent_writepages()
                      extent_write_cache_pages()
                        --> finds page with offset 0
                            with the writeback tag
                            (and not dirty)
                        --> tries to lock it
                             --> deadlock, task at CPU 2
                                 has the page locked and
                                 is blocked on the io range
                                 [0, 4K[ that was locked
                                 earlier by this task
    
    So fix this by falling back to a buffered read in the direct IO read path
    when an ordered extent for a buffered write is found.
    
    Signed-off-by: Filipe Manana <fdmanana@suse.com>
    Reviewed-by: Liu Bo <bo.li.liu@oracle.com>
    Signed-off-by: Chris Mason <clm@fb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 911cf4b94f7b068f92eab0b02f620a44ad6e405d
Author: Wanpeng Li <wanpeng.li@hotmail.com>
Date:   Wed May 11 17:55:18 2016 +0800

    workqueue: fix rebind bound workers warning
    
    commit f7c17d26f43d5cc1b7a6b896cd2fa24a079739b9 upstream.
    
    ------------[ cut here ]------------
    WARNING: CPU: 0 PID: 16 at kernel/workqueue.c:4559 rebind_workers+0x1c0/0x1d0
    Modules linked in:
    CPU: 0 PID: 16 Comm: cpuhp/0 Not tainted 4.6.0-rc4+ #31
    Hardware name: IBM IBM System x3550 M4 Server -[7914IUW]-/00Y8603, BIOS -[D7E128FUS-1.40]- 07/23/2013
     0000000000000000 ffff881037babb58 ffffffff8139d885 0000000000000010
     0000000000000000 0000000000000000 0000000000000000 ffff881037babba8
     ffffffff8108505d ffff881037ba0000 000011cf3e7d6e60 0000000000000046
    Call Trace:
     dump_stack+0x89/0xd4
     __warn+0xfd/0x120
     warn_slowpath_null+0x1d/0x20
     rebind_workers+0x1c0/0x1d0
     workqueue_cpu_up_callback+0xf5/0x1d0
     notifier_call_chain+0x64/0x90
     ? trace_hardirqs_on_caller+0xf2/0x220
     ? notify_prepare+0x80/0x80
     __raw_notifier_call_chain+0xe/0x10
     __cpu_notify+0x35/0x50
     notify_down_prepare+0x5e/0x80
     ? notify_prepare+0x80/0x80
     cpuhp_invoke_callback+0x73/0x330
     ? __schedule+0x33e/0x8a0
     cpuhp_down_callbacks+0x51/0xc0
     cpuhp_thread_fun+0xc1/0xf0
     smpboot_thread_fn+0x159/0x2a0
     ? smpboot_create_threads+0x80/0x80
     kthread+0xef/0x110
     ? wait_for_completion+0xf0/0x120
     ? schedule_tail+0x35/0xf0
     ret_from_fork+0x22/0x50
     ? __init_kthread_worker+0x70/0x70
    ---[ end trace eb12ae47d2382d8f ]---
    notify_down_prepare: attempt to take down CPU 0 failed
    
    This bug can be reproduced by below config w/ nohz_full= all cpus:
    
    CONFIG_BOOTPARAM_HOTPLUG_CPU0=y
    CONFIG_DEBUG_HOTPLUG_CPU0=y
    CONFIG_NO_HZ_FULL=y
    
    As Thomas pointed out:
    
    | If a down prepare callback fails, then DOWN_FAILED is invoked for all
    | callbacks which have successfully executed DOWN_PREPARE.
    |
    | But, workqueue has actually two notifiers. One which handles
    | UP/DOWN_FAILED/ONLINE and one which handles DOWN_PREPARE.
    |
    | Now look at the priorities of those callbacks:
    |
    | CPU_PRI_WORKQUEUE_UP        = 5
    | CPU_PRI_WORKQUEUE_DOWN      = -5
    |
    | So the call order on DOWN_PREPARE is:
    |
    | CB 1
    | CB ...
    | CB workqueue_up() -> Ignores DOWN_PREPARE
    | CB ...
    | CB X ---> Fails
    |
    | So we call up to CB X with DOWN_FAILED
    |
    | CB 1
    | CB ...
    | CB workqueue_up() -> Handles DOWN_FAILED
    | CB ...
    | CB X-1
    |
    | So the problem is that the workqueue stuff handles DOWN_FAILED in the up
    | callback, while it should do it in the down callback. Which is not a good idea
    | either because it wants to be called early on rollback...
    |
    | Brilliant stuff, isn't it? The hotplug rework will solve this problem because
    | the callbacks become symetric, but for the existing mess, we need some
    | workaround in the workqueue code.
    
    The boot CPU handles housekeeping duty(unbound timers, workqueues,
    timekeeping, ...) on behalf of full dynticks CPUs. It must remain
    online when nohz full is enabled. There is a priority set to every
    notifier_blocks:
    
    workqueue_cpu_up > tick_nohz_cpu_down > workqueue_cpu_down
    
    So tick_nohz_cpu_down callback failed when down prepare cpu 0, and
    notifier_blocks behind tick_nohz_cpu_down will not be called any
    more, which leads to workers are actually not unbound. Then hotplug
    state machine will fallback to undo and online cpu 0 again. Workers
    will be rebound unconditionally even if they are not unbound and
    trigger the warning in this progress.
    
    This patch fix it by catching !DISASSOCIATED to avoid rebind bound
    workers.
    
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Lai Jiangshan <jiangshanlai@gmail.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Frédéric Weisbecker <fweisbec@gmail.com>
    Suggested-by: Lai Jiangshan <jiangshanlai@gmail.com>
    Signed-off-by: Wanpeng Li <wanpeng.li@hotmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit cf73d8ad76e4555a45ee399887b7c0361354d10f
Author: Wanpeng Li <wanpeng.li@hotmail.com>
Date:   Wed May 11 17:55:18 2016 +0800

    workqueue: fix rebind bound workers warning
    
    commit f7c17d26f43d5cc1b7a6b896cd2fa24a079739b9 upstream.
    
    ------------[ cut here ]------------
    WARNING: CPU: 0 PID: 16 at kernel/workqueue.c:4559 rebind_workers+0x1c0/0x1d0
    Modules linked in:
    CPU: 0 PID: 16 Comm: cpuhp/0 Not tainted 4.6.0-rc4+ #31
    Hardware name: IBM IBM System x3550 M4 Server -[7914IUW]-/00Y8603, BIOS -[D7E128FUS-1.40]- 07/23/2013
     0000000000000000 ffff881037babb58 ffffffff8139d885 0000000000000010
     0000000000000000 0000000000000000 0000000000000000 ffff881037babba8
     ffffffff8108505d ffff881037ba0000 000011cf3e7d6e60 0000000000000046
    Call Trace:
     dump_stack+0x89/0xd4
     __warn+0xfd/0x120
     warn_slowpath_null+0x1d/0x20
     rebind_workers+0x1c0/0x1d0
     workqueue_cpu_up_callback+0xf5/0x1d0
     notifier_call_chain+0x64/0x90
     ? trace_hardirqs_on_caller+0xf2/0x220
     ? notify_prepare+0x80/0x80
     __raw_notifier_call_chain+0xe/0x10
     __cpu_notify+0x35/0x50
     notify_down_prepare+0x5e/0x80
     ? notify_prepare+0x80/0x80
     cpuhp_invoke_callback+0x73/0x330
     ? __schedule+0x33e/0x8a0
     cpuhp_down_callbacks+0x51/0xc0
     cpuhp_thread_fun+0xc1/0xf0
     smpboot_thread_fn+0x159/0x2a0
     ? smpboot_create_threads+0x80/0x80
     kthread+0xef/0x110
     ? wait_for_completion+0xf0/0x120
     ? schedule_tail+0x35/0xf0
     ret_from_fork+0x22/0x50
     ? __init_kthread_worker+0x70/0x70
    ---[ end trace eb12ae47d2382d8f ]---
    notify_down_prepare: attempt to take down CPU 0 failed
    
    This bug can be reproduced by below config w/ nohz_full= all cpus:
    
    CONFIG_BOOTPARAM_HOTPLUG_CPU0=y
    CONFIG_DEBUG_HOTPLUG_CPU0=y
    CONFIG_NO_HZ_FULL=y
    
    As Thomas pointed out:
    
    | If a down prepare callback fails, then DOWN_FAILED is invoked for all
    | callbacks which have successfully executed DOWN_PREPARE.
    |
    | But, workqueue has actually two notifiers. One which handles
    | UP/DOWN_FAILED/ONLINE and one which handles DOWN_PREPARE.
    |
    | Now look at the priorities of those callbacks:
    |
    | CPU_PRI_WORKQUEUE_UP        = 5
    | CPU_PRI_WORKQUEUE_DOWN      = -5
    |
    | So the call order on DOWN_PREPARE is:
    |
    | CB 1
    | CB ...
    | CB workqueue_up() -> Ignores DOWN_PREPARE
    | CB ...
    | CB X ---> Fails
    |
    | So we call up to CB X with DOWN_FAILED
    |
    | CB 1
    | CB ...
    | CB workqueue_up() -> Handles DOWN_FAILED
    | CB ...
    | CB X-1
    |
    | So the problem is that the workqueue stuff handles DOWN_FAILED in the up
    | callback, while it should do it in the down callback. Which is not a good idea
    | either because it wants to be called early on rollback...
    |
    | Brilliant stuff, isn't it? The hotplug rework will solve this problem because
    | the callbacks become symetric, but for the existing mess, we need some
    | workaround in the workqueue code.
    
    The boot CPU handles housekeeping duty(unbound timers, workqueues,
    timekeeping, ...) on behalf of full dynticks CPUs. It must remain
    online when nohz full is enabled. There is a priority set to every
    notifier_blocks:
    
    workqueue_cpu_up > tick_nohz_cpu_down > workqueue_cpu_down
    
    So tick_nohz_cpu_down callback failed when down prepare cpu 0, and
    notifier_blocks behind tick_nohz_cpu_down will not be called any
    more, which leads to workers are actually not unbound. Then hotplug
    state machine will fallback to undo and online cpu 0 again. Workers
    will be rebound unconditionally even if they are not unbound and
    trigger the warning in this progress.
    
    This patch fix it by catching !DISASSOCIATED to avoid rebind bound
    workers.
    
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Lai Jiangshan <jiangshanlai@gmail.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Frédéric Weisbecker <fweisbec@gmail.com>
    Suggested-by: Lai Jiangshan <jiangshanlai@gmail.com>
    Signed-off-by: Wanpeng Li <wanpeng.li@hotmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 3665ecd65aad209e7c8258c207094b5006eb3d0f
Author: Wanpeng Li <wanpeng.li@hotmail.com>
Date:   Wed May 11 17:55:18 2016 +0800

    workqueue: fix rebind bound workers warning
    
    [ Upstream commit f7c17d26f43d5cc1b7a6b896cd2fa24a079739b9 ]
    
    ------------[ cut here ]------------
    WARNING: CPU: 0 PID: 16 at kernel/workqueue.c:4559 rebind_workers+0x1c0/0x1d0
    Modules linked in:
    CPU: 0 PID: 16 Comm: cpuhp/0 Not tainted 4.6.0-rc4+ #31
    Hardware name: IBM IBM System x3550 M4 Server -[7914IUW]-/00Y8603, BIOS -[D7E128FUS-1.40]- 07/23/2013
     0000000000000000 ffff881037babb58 ffffffff8139d885 0000000000000010
     0000000000000000 0000000000000000 0000000000000000 ffff881037babba8
     ffffffff8108505d ffff881037ba0000 000011cf3e7d6e60 0000000000000046
    Call Trace:
     dump_stack+0x89/0xd4
     __warn+0xfd/0x120
     warn_slowpath_null+0x1d/0x20
     rebind_workers+0x1c0/0x1d0
     workqueue_cpu_up_callback+0xf5/0x1d0
     notifier_call_chain+0x64/0x90
     ? trace_hardirqs_on_caller+0xf2/0x220
     ? notify_prepare+0x80/0x80
     __raw_notifier_call_chain+0xe/0x10
     __cpu_notify+0x35/0x50
     notify_down_prepare+0x5e/0x80
     ? notify_prepare+0x80/0x80
     cpuhp_invoke_callback+0x73/0x330
     ? __schedule+0x33e/0x8a0
     cpuhp_down_callbacks+0x51/0xc0
     cpuhp_thread_fun+0xc1/0xf0
     smpboot_thread_fn+0x159/0x2a0
     ? smpboot_create_threads+0x80/0x80
     kthread+0xef/0x110
     ? wait_for_completion+0xf0/0x120
     ? schedule_tail+0x35/0xf0
     ret_from_fork+0x22/0x50
     ? __init_kthread_worker+0x70/0x70
    ---[ end trace eb12ae47d2382d8f ]---
    notify_down_prepare: attempt to take down CPU 0 failed
    
    This bug can be reproduced by below config w/ nohz_full= all cpus:
    
    CONFIG_BOOTPARAM_HOTPLUG_CPU0=y
    CONFIG_DEBUG_HOTPLUG_CPU0=y
    CONFIG_NO_HZ_FULL=y
    
    As Thomas pointed out:
    
    | If a down prepare callback fails, then DOWN_FAILED is invoked for all
    | callbacks which have successfully executed DOWN_PREPARE.
    |
    | But, workqueue has actually two notifiers. One which handles
    | UP/DOWN_FAILED/ONLINE and one which handles DOWN_PREPARE.
    |
    | Now look at the priorities of those callbacks:
    |
    | CPU_PRI_WORKQUEUE_UP        = 5
    | CPU_PRI_WORKQUEUE_DOWN      = -5
    |
    | So the call order on DOWN_PREPARE is:
    |
    | CB 1
    | CB ...
    | CB workqueue_up() -> Ignores DOWN_PREPARE
    | CB ...
    | CB X ---> Fails
    |
    | So we call up to CB X with DOWN_FAILED
    |
    | CB 1
    | CB ...
    | CB workqueue_up() -> Handles DOWN_FAILED
    | CB ...
    | CB X-1
    |
    | So the problem is that the workqueue stuff handles DOWN_FAILED in the up
    | callback, while it should do it in the down callback. Which is not a good idea
    | either because it wants to be called early on rollback...
    |
    | Brilliant stuff, isn't it? The hotplug rework will solve this problem because
    | the callbacks become symetric, but for the existing mess, we need some
    | workaround in the workqueue code.
    
    The boot CPU handles housekeeping duty(unbound timers, workqueues,
    timekeeping, ...) on behalf of full dynticks CPUs. It must remain
    online when nohz full is enabled. There is a priority set to every
    notifier_blocks:
    
    workqueue_cpu_up > tick_nohz_cpu_down > workqueue_cpu_down
    
    So tick_nohz_cpu_down callback failed when down prepare cpu 0, and
    notifier_blocks behind tick_nohz_cpu_down will not be called any
    more, which leads to workers are actually not unbound. Then hotplug
    state machine will fallback to undo and online cpu 0 again. Workers
    will be rebound unconditionally even if they are not unbound and
    trigger the warning in this progress.
    
    This patch fix it by catching !DISASSOCIATED to avoid rebind bound
    workers.
    
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Lai Jiangshan <jiangshanlai@gmail.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Frédéric Weisbecker <fweisbec@gmail.com>
    Cc: stable@vger.kernel.org
    Suggested-by: Lai Jiangshan <jiangshanlai@gmail.com>
    Signed-off-by: Wanpeng Li <wanpeng.li@hotmail.com>
    Signed-off-by: Sasha Levin <sasha.levin@oracle.com>

commit 3a1b9a74de5c10995d1fd842e3d2344d4e826ae1
Author: Wanpeng Li <wanpeng.li@hotmail.com>
Date:   Wed May 11 17:55:18 2016 +0800

    workqueue: fix rebind bound workers warning
    
    [ Upstream commit f7c17d26f43d5cc1b7a6b896cd2fa24a079739b9 ]
    
    ------------[ cut here ]------------
    WARNING: CPU: 0 PID: 16 at kernel/workqueue.c:4559 rebind_workers+0x1c0/0x1d0
    Modules linked in:
    CPU: 0 PID: 16 Comm: cpuhp/0 Not tainted 4.6.0-rc4+ #31
    Hardware name: IBM IBM System x3550 M4 Server -[7914IUW]-/00Y8603, BIOS -[D7E128FUS-1.40]- 07/23/2013
     0000000000000000 ffff881037babb58 ffffffff8139d885 0000000000000010
     0000000000000000 0000000000000000 0000000000000000 ffff881037babba8
     ffffffff8108505d ffff881037ba0000 000011cf3e7d6e60 0000000000000046
    Call Trace:
     dump_stack+0x89/0xd4
     __warn+0xfd/0x120
     warn_slowpath_null+0x1d/0x20
     rebind_workers+0x1c0/0x1d0
     workqueue_cpu_up_callback+0xf5/0x1d0
     notifier_call_chain+0x64/0x90
     ? trace_hardirqs_on_caller+0xf2/0x220
     ? notify_prepare+0x80/0x80
     __raw_notifier_call_chain+0xe/0x10
     __cpu_notify+0x35/0x50
     notify_down_prepare+0x5e/0x80
     ? notify_prepare+0x80/0x80
     cpuhp_invoke_callback+0x73/0x330
     ? __schedule+0x33e/0x8a0
     cpuhp_down_callbacks+0x51/0xc0
     cpuhp_thread_fun+0xc1/0xf0
     smpboot_thread_fn+0x159/0x2a0
     ? smpboot_create_threads+0x80/0x80
     kthread+0xef/0x110
     ? wait_for_completion+0xf0/0x120
     ? schedule_tail+0x35/0xf0
     ret_from_fork+0x22/0x50
     ? __init_kthread_worker+0x70/0x70
    ---[ end trace eb12ae47d2382d8f ]---
    notify_down_prepare: attempt to take down CPU 0 failed
    
    This bug can be reproduced by below config w/ nohz_full= all cpus:
    
    CONFIG_BOOTPARAM_HOTPLUG_CPU0=y
    CONFIG_DEBUG_HOTPLUG_CPU0=y
    CONFIG_NO_HZ_FULL=y
    
    As Thomas pointed out:
    
    | If a down prepare callback fails, then DOWN_FAILED is invoked for all
    | callbacks which have successfully executed DOWN_PREPARE.
    |
    | But, workqueue has actually two notifiers. One which handles
    | UP/DOWN_FAILED/ONLINE and one which handles DOWN_PREPARE.
    |
    | Now look at the priorities of those callbacks:
    |
    | CPU_PRI_WORKQUEUE_UP        = 5
    | CPU_PRI_WORKQUEUE_DOWN      = -5
    |
    | So the call order on DOWN_PREPARE is:
    |
    | CB 1
    | CB ...
    | CB workqueue_up() -> Ignores DOWN_PREPARE
    | CB ...
    | CB X ---> Fails
    |
    | So we call up to CB X with DOWN_FAILED
    |
    | CB 1
    | CB ...
    | CB workqueue_up() -> Handles DOWN_FAILED
    | CB ...
    | CB X-1
    |
    | So the problem is that the workqueue stuff handles DOWN_FAILED in the up
    | callback, while it should do it in the down callback. Which is not a good idea
    | either because it wants to be called early on rollback...
    |
    | Brilliant stuff, isn't it? The hotplug rework will solve this problem because
    | the callbacks become symetric, but for the existing mess, we need some
    | workaround in the workqueue code.
    
    The boot CPU handles housekeeping duty(unbound timers, workqueues,
    timekeeping, ...) on behalf of full dynticks CPUs. It must remain
    online when nohz full is enabled. There is a priority set to every
    notifier_blocks:
    
    workqueue_cpu_up > tick_nohz_cpu_down > workqueue_cpu_down
    
    So tick_nohz_cpu_down callback failed when down prepare cpu 0, and
    notifier_blocks behind tick_nohz_cpu_down will not be called any
    more, which leads to workers are actually not unbound. Then hotplug
    state machine will fallback to undo and online cpu 0 again. Workers
    will be rebound unconditionally even if they are not unbound and
    trigger the warning in this progress.
    
    This patch fix it by catching !DISASSOCIATED to avoid rebind bound
    workers.
    
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Lai Jiangshan <jiangshanlai@gmail.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Frédéric Weisbecker <fweisbec@gmail.com>
    Cc: stable@vger.kernel.org
    Suggested-by: Lai Jiangshan <jiangshanlai@gmail.com>
    Signed-off-by: Wanpeng Li <wanpeng.li@hotmail.com>
    Signed-off-by: Sasha Levin <sasha.levin@oracle.com>

commit f7c17d26f43d5cc1b7a6b896cd2fa24a079739b9
Author: Wanpeng Li <wanpeng.li@hotmail.com>
Date:   Wed May 11 17:55:18 2016 +0800

    workqueue: fix rebind bound workers warning
    
    ------------[ cut here ]------------
    WARNING: CPU: 0 PID: 16 at kernel/workqueue.c:4559 rebind_workers+0x1c0/0x1d0
    Modules linked in:
    CPU: 0 PID: 16 Comm: cpuhp/0 Not tainted 4.6.0-rc4+ #31
    Hardware name: IBM IBM System x3550 M4 Server -[7914IUW]-/00Y8603, BIOS -[D7E128FUS-1.40]- 07/23/2013
     0000000000000000 ffff881037babb58 ffffffff8139d885 0000000000000010
     0000000000000000 0000000000000000 0000000000000000 ffff881037babba8
     ffffffff8108505d ffff881037ba0000 000011cf3e7d6e60 0000000000000046
    Call Trace:
     dump_stack+0x89/0xd4
     __warn+0xfd/0x120
     warn_slowpath_null+0x1d/0x20
     rebind_workers+0x1c0/0x1d0
     workqueue_cpu_up_callback+0xf5/0x1d0
     notifier_call_chain+0x64/0x90
     ? trace_hardirqs_on_caller+0xf2/0x220
     ? notify_prepare+0x80/0x80
     __raw_notifier_call_chain+0xe/0x10
     __cpu_notify+0x35/0x50
     notify_down_prepare+0x5e/0x80
     ? notify_prepare+0x80/0x80
     cpuhp_invoke_callback+0x73/0x330
     ? __schedule+0x33e/0x8a0
     cpuhp_down_callbacks+0x51/0xc0
     cpuhp_thread_fun+0xc1/0xf0
     smpboot_thread_fn+0x159/0x2a0
     ? smpboot_create_threads+0x80/0x80
     kthread+0xef/0x110
     ? wait_for_completion+0xf0/0x120
     ? schedule_tail+0x35/0xf0
     ret_from_fork+0x22/0x50
     ? __init_kthread_worker+0x70/0x70
    ---[ end trace eb12ae47d2382d8f ]---
    notify_down_prepare: attempt to take down CPU 0 failed
    
    This bug can be reproduced by below config w/ nohz_full= all cpus:
    
    CONFIG_BOOTPARAM_HOTPLUG_CPU0=y
    CONFIG_DEBUG_HOTPLUG_CPU0=y
    CONFIG_NO_HZ_FULL=y
    
    As Thomas pointed out:
    
    | If a down prepare callback fails, then DOWN_FAILED is invoked for all
    | callbacks which have successfully executed DOWN_PREPARE.
    |
    | But, workqueue has actually two notifiers. One which handles
    | UP/DOWN_FAILED/ONLINE and one which handles DOWN_PREPARE.
    |
    | Now look at the priorities of those callbacks:
    |
    | CPU_PRI_WORKQUEUE_UP        = 5
    | CPU_PRI_WORKQUEUE_DOWN      = -5
    |
    | So the call order on DOWN_PREPARE is:
    |
    | CB 1
    | CB ...
    | CB workqueue_up() -> Ignores DOWN_PREPARE
    | CB ...
    | CB X ---> Fails
    |
    | So we call up to CB X with DOWN_FAILED
    |
    | CB 1
    | CB ...
    | CB workqueue_up() -> Handles DOWN_FAILED
    | CB ...
    | CB X-1
    |
    | So the problem is that the workqueue stuff handles DOWN_FAILED in the up
    | callback, while it should do it in the down callback. Which is not a good idea
    | either because it wants to be called early on rollback...
    |
    | Brilliant stuff, isn't it? The hotplug rework will solve this problem because
    | the callbacks become symetric, but for the existing mess, we need some
    | workaround in the workqueue code.
    
    The boot CPU handles housekeeping duty(unbound timers, workqueues,
    timekeeping, ...) on behalf of full dynticks CPUs. It must remain
    online when nohz full is enabled. There is a priority set to every
    notifier_blocks:
    
    workqueue_cpu_up > tick_nohz_cpu_down > workqueue_cpu_down
    
    So tick_nohz_cpu_down callback failed when down prepare cpu 0, and
    notifier_blocks behind tick_nohz_cpu_down will not be called any
    more, which leads to workers are actually not unbound. Then hotplug
    state machine will fallback to undo and online cpu 0 again. Workers
    will be rebound unconditionally even if they are not unbound and
    trigger the warning in this progress.
    
    This patch fix it by catching !DISASSOCIATED to avoid rebind bound
    workers.
    
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Lai Jiangshan <jiangshanlai@gmail.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Frédéric Weisbecker <fweisbec@gmail.com>
    Cc: stable@vger.kernel.org
    Suggested-by: Lai Jiangshan <jiangshanlai@gmail.com>
    Signed-off-by: Wanpeng Li <wanpeng.li@hotmail.com>

commit cf968937d27751296920e6b82ffa89735e3a0023
Author: wang yanqing <udknight@gmail.com>
Date:   Sat May 7 00:33:53 2016 +0800

    rtlwifi: pci: use dev_kfree_skb_irq instead of kfree_skb in rtl_pci_reset_trx_ring
    
    We can't use kfree_skb in irq disable context, because spin_lock_irqsave
    make sure we are always in irq disable context, use dev_kfree_skb_irq
    instead of kfree_skb is better than dev_kfree_skb_any.
    
    This patch fix below kernel warning:
    [ 7612.095528] ------------[ cut here ]------------
    [ 7612.095546] WARNING: CPU: 3 PID: 4460 at kernel/softirq.c:150 __local_bh_enable_ip+0x58/0x80()
    [ 7612.095550] Modules linked in: rtl8723be x86_pkg_temp_thermal btcoexist rtl_pci rtlwifi rtl8723_common
    [ 7612.095567] CPU: 3 PID: 4460 Comm: ifconfig Tainted: G        W       4.4.0+ #4
    [ 7612.095570] Hardware name: LENOVO 20DFA04FCD/20DFA04FCD, BIOS J5ET48WW (1.19 ) 08/27/2015
    [ 7612.095574]  00000000 00000000 da37fc70 c12ce7c5 00000000 da37fca0 c104cc59 c19d4454
    [ 7612.095584]  00000003 0000116c c19d4784 00000096 c10508a8 c10508a8 00000200 c1b42400
    [ 7612.095594]  f29be780 da37fcb0 c104ccad 00000009 00000000 da37fcbc c10508a8 f21f08b8
    [ 7612.095604] Call Trace:
    [ 7612.095614]  [<c12ce7c5>] dump_stack+0x41/0x5c
    [ 7612.095620]  [<c104cc59>] warn_slowpath_common+0x89/0xc0
    [ 7612.095628]  [<c10508a8>] ? __local_bh_enable_ip+0x58/0x80
    [ 7612.095634]  [<c10508a8>] ? __local_bh_enable_ip+0x58/0x80
    [ 7612.095640]  [<c104ccad>] warn_slowpath_null+0x1d/0x20
    [ 7612.095646]  [<c10508a8>] __local_bh_enable_ip+0x58/0x80
    [ 7612.095653]  [<c16b7d34>] destroy_conntrack+0x64/0xa0
    [ 7612.095660]  [<c16b300f>] nf_conntrack_destroy+0xf/0x20
    [ 7612.095665]  [<c1677565>] skb_release_head_state+0x55/0xa0
    [ 7612.095670]  [<c16775bb>] skb_release_all+0xb/0x20
    [ 7612.095674]  [<c167760b>] __kfree_skb+0xb/0x60
    [ 7612.095679]  [<c16776f0>] kfree_skb+0x30/0x70
    [ 7612.095686]  [<f81b869d>] ? rtl_pci_reset_trx_ring+0x22d/0x370 [rtl_pci]
    [ 7612.095692]  [<f81b869d>] rtl_pci_reset_trx_ring+0x22d/0x370 [rtl_pci]
    [ 7612.095698]  [<f81b87f9>] rtl_pci_start+0x19/0x190 [rtl_pci]
    [ 7612.095705]  [<f81970e6>] rtl_op_start+0x56/0x90 [rtlwifi]
    [ 7612.095712]  [<c17e3f16>] drv_start+0x36/0xc0
    [ 7612.095717]  [<c17f5ab3>] ieee80211_do_open+0x2d3/0x890
    [ 7612.095725]  [<c16820fe>] ? call_netdevice_notifiers_info+0x2e/0x60
    [ 7612.095730]  [<c17f60bd>] ieee80211_open+0x4d/0x50
    [ 7612.095736]  [<c16891b3>] __dev_open+0xa3/0x130
    [ 7612.095742]  [<c183fa53>] ? _raw_spin_unlock_bh+0x13/0x20
    [ 7612.095748]  [<c1689499>] __dev_change_flags+0x89/0x140
    [ 7612.095753]  [<c127c70d>] ? selinux_capable+0xd/0x10
    [ 7612.095759]  [<c1689589>] dev_change_flags+0x29/0x60
    [ 7612.095765]  [<c1700b93>] devinet_ioctl+0x553/0x670
    [ 7612.095772]  [<c12db758>] ? _copy_to_user+0x28/0x40
    [ 7612.095777]  [<c17018b5>] inet_ioctl+0x85/0xb0
    [ 7612.095783]  [<c166e647>] sock_ioctl+0x67/0x260
    [ 7612.095788]  [<c166e5e0>] ? sock_fasync+0x80/0x80
    [ 7612.095795]  [<c115c99b>] do_vfs_ioctl+0x6b/0x550
    [ 7612.095800]  [<c127c812>] ? selinux_file_ioctl+0x102/0x1e0
    [ 7612.095807]  [<c10a8914>] ? timekeeping_suspend+0x294/0x320
    [ 7612.095813]  [<c10a256a>] ? __hrtimer_run_queues+0x14a/0x210
    [ 7612.095820]  [<c1276e24>] ? security_file_ioctl+0x34/0x50
    [ 7612.095827]  [<c115cef0>] SyS_ioctl+0x70/0x80
    [ 7612.095832]  [<c1001804>] do_fast_syscall_32+0x84/0x120
    [ 7612.095839]  [<c183ff91>] sysenter_past_esp+0x36/0x55
    [ 7612.095844] ---[ end trace 97e9c637a20e8348 ]---
    
    Signed-off-by: Wang YanQing <udknight@gmail.com>
    Cc: Stable <stable@vger.kernel.org>
    Acked-by: Larry Finger <Larry.Finger@lwfinger.net>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>

commit 4355c44f063d3de4f072d796604c7f4ba4085cc3
Author: James Hogan <jhogan@kernel.org>
Date:   Fri Apr 22 10:38:45 2016 +0100

    MIPS: KVM: Fix timer IRQ race when freezing timer
    
    There's a particularly narrow and subtle race condition when the
    software emulated guest timer is frozen which can allow a guest timer
    interrupt to be missed.
    
    This happens due to the hrtimer expiry being inexact, so very
    occasionally the freeze time will be after the moment when the emulated
    CP0_Count transitions to the same value as CP0_Compare (so an IRQ should
    be generated), but before the moment when the hrtimer is due to expire
    (so no IRQ is generated). The IRQ won't be generated when the timer is
    resumed either, since the resume CP0_Count will already match CP0_Compare.
    
    With VZ guests in particular this is far more likely to happen, since
    the soft timer may be frozen frequently in order to restore the timer
    state to the hardware guest timer. This happens after 5-10 hours of
    guest soak testing, resulting in an overflow in guest kernel timekeeping
    calculations, hanging the guest. A more focussed test case to
    intentionally hit the race (with the help of a new hypcall to cause the
    timer state to migrated between hardware & software) hits the condition
    fairly reliably within around 30 seconds.
    
    Instead of relying purely on the inexact hrtimer expiry to determine
    whether an IRQ should be generated, read the guest CP0_Compare and
    directly check whether the freeze time is before or after it. Only if
    CP0_Count is on or after CP0_Compare do we check the hrtimer expiry to
    determine whether the last IRQ has already been generated (which will
    have pushed back the expiry by one timer period).
    
    Fixes: e30492bbe95a ("MIPS: KVM: Rewrite count/compare timer emulation")
    Signed-off-by: James Hogan <james.hogan@imgtec.com>
    Cc: Paolo Bonzini <pbonzini@redhat.com>
    Cc: "Radim KrÄmÃ¡Å™" <rkrcmar@redhat.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: linux-mips@linux-mips.org
    Cc: kvm@vger.kernel.org
    Cc: <stable@vger.kernel.org> # 3.16.x-
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>

commit 2bba66d6ae0f8b4c6fd7b7010437d29c0ecfff0a
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Wed Sep 16 14:10:03 2015 +0100

    x86/platform: Fix Geode LX timekeeping in the generic x86 build
    
    commit 03da3ff1cfcd7774c8780d2547ba0d995f7dc03d upstream.
    
    In 2007, commit 07190a08eef36 ("Mark TSC on GeodeLX reliable")
    bypassed verification of the TSC on Geode LX. However, this code
    (now in the check_system_tsc_reliable() function in
    arch/x86/kernel/tsc.c) was only present if CONFIG_MGEODE_LX was
    set.
    
    OpenWRT has recently started building its generic Geode target
    for Geode GX, not LX, to include support for additional
    platforms. This broke the timekeeping on LX-based devices,
    because the TSC wasn't marked as reliable:
    https://dev.openwrt.org/ticket/20531
    
    By adding a runtime check on is_geode_lx(), we can also include
    the fix if CONFIG_MGEODEGX1 or CONFIG_X86_GENERIC are set, thus
    fixing the problem.
    
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>
    Cc: Andres Salomon <dilinger@queued.net>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Marcelo Tosatti <marcelo@kvack.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/1442409003.131189.87.camel@infradead.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Zefan Li <lizefan@huawei.com>

commit 706a527ca32b3bf950754631fa42982c0f1c060b
Author: Tina Ruchandani <ruchandani.tina@gmail.com>
Date:   Tue Apr 12 23:09:16 2016 -0700

    prism54: isl_38xx: Replace 'struct timeval'
    
    'struct timeval' uses a 32-bit seconds field which will overflow in
    year 2038 and beyond. This patch is part of a larger effort to remove
    all instances of 'struct timeval' from the kernel and replace them
    with 64-bit timekeeping variables.
    The patch also fixes the debug printf specifier to avoid the
    seconds value being truncated.
    The patch was build-tested / debugged by removing the
    "if VERBOSE > SHOW_ERROR_MESSAGES" guards.
    
    Signed-off-by: Tina Ruchandani <ruchandani.tina@gmail.com>
    Suggested-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>

commit 9dbaab56ac09f07a73fe83bf69bec3e31060080a
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Mon Mar 14 09:01:57 2016 +0000

    drm/i915: Exit cherryview_irq_handler() after one pass
    
    This effectively reverts
    
    commit 8e5fd599eb219f1054e39b40d18b217af669eea9
    Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Date:   Wed Apr 9 13:28:50 2014 +0300
    
        drm/i915/chv: Make CHV irq handler loop until all interrupts are consumed
    
    as under continuous execlists load we can saturate the IRQ handler,
    destablising the tsc clock and triggering the NMI watchdog to declare a hung
    CPU.
    
    [  552.756051] clocksource: timekeeping watchdog on CPU0: Marking clocksource 'tsc' as unstable because the skew is too large:
    [  552.756080] clocksource:                       'refined-jiffies' wd_now: 10003b480 wd_last: 10003b28c mask: ffffffff
    [  552.756091] clocksource:                       'tsc' cs_now: d55d31aa50 cs_last: d17446166c mask: ffffffffffffffff
    [  552.756210] clocksource: Switched to clocksource refined-jiffies
    [  575.217870] NMI watchdog: Watchdog detected hard LOCKUP on cpu 1
    [  575.217893] CPU: 1 PID: 0 Comm: swapper/1 Not tainted 4.5.0-rc7+ #18
    [  575.217905] Hardware name:                  /NUC5CPYB, BIOS PYBSWCEL.86A.0027.2015.0507.1758 05/07/2015
    [  575.217915]  0000000000000000 ffff88027fd05bc0 ffffffff81288c6d 0000000000000000
    [  575.217935]  0000000000000001 ffff88027fd05be0 ffffffff810e72d1 0000000000000000
    [  575.217951]  ffff88027fd05c80 ffff88027fd05c20 ffffffff81114b60 0000000181015f1e
    [  575.217967] Call Trace:
    [  575.217973]  <NMI>  [<ffffffff81288c6d>] dump_stack+0x4f/0x72
    [  575.217994]  [<ffffffff810e72d1>] watchdog_overflow_callback+0x151/0x160
    [  575.218003]  [<ffffffff81114b60>] __perf_event_overflow+0xa0/0x1e0
    [  575.218016]  [<ffffffff811154c4>] perf_event_overflow+0x14/0x20
    [  575.218028]  [<ffffffff8101d2ca>] intel_pmu_handle_irq+0x1da/0x460
    [  575.218042]  [<ffffffff814a8aae>] ? poll_idle+0x3e/0x70
    [  575.218052]  [<ffffffff814a8aae>] ? poll_idle+0x3e/0x70
    [  575.218064]  [<ffffffff81014ae8>] perf_event_nmi_handler+0x28/0x50
    [  575.218075]  [<ffffffff81007540>] nmi_handle+0x60/0x130
    [  575.218086]  [<ffffffff814a8aae>] ? poll_idle+0x3e/0x70
    [  575.218096]  [<ffffffff810079c0>] do_nmi+0x140/0x470
    [  575.218108]  [<ffffffff81559ec7>] end_repeat_nmi+0x1a/0x1e
    [  575.218119]  [<ffffffff814a8aae>] ? poll_idle+0x3e/0x70
    [  575.218129]  [<ffffffff814a8aae>] ? poll_idle+0x3e/0x70
    [  575.218139]  [<ffffffff814a8aae>] ? poll_idle+0x3e/0x70
    [  575.218148]  <<EOE>>  [<ffffffff814a8353>] cpuidle_enter_state+0xf3/0x2f0
    [  575.218164]  [<ffffffff814a8587>] cpuidle_enter+0x17/0x20
    [  575.218175]  [<ffffffff810aaa3a>] call_cpuidle+0x2a/0x40
    [  575.218185]  [<ffffffff810aade3>] cpu_startup_entry+0x273/0x330
    [  575.218196]  [<ffffffff81033a1e>] start_secondary+0x10e/0x130
    
    However, not servicing all available IIR within the handler does hurt the
    throughput of pathological nop execbuf by about 20%, with a similar effect
    upon the dispatch latency of a series of execbuf.
    
    v2: use do {} while(0) for a smaller patch, and easier to revert again
    
    I have reasonable confidence that we do not miss GT interrupts (as
    execlists provides a stress case with a failure mechanism easily
    detected by igt), however I have less confidence about all the other
    sources of interrupts and worry that may lose a display hotplug
    interrupt, for example.
    
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=93467
    Testcase: igt/gem_exec_nop/basic # requires NMI watchdog
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: Antti Koskipää <antti.koskipaa@linux.intel.com>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Cc: stable@vger.kernel.org
    Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1457946117-6714-1-git-send-email-chris@chris-wilson.co.uk
    (cherry picked from commit 579de73b048a0a4c66c25a033ac76a2836e0cf73)
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>

commit 579de73b048a0a4c66c25a033ac76a2836e0cf73
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Mon Mar 14 09:01:57 2016 +0000

    drm/i915: Exit cherryview_irq_handler() after one pass
    
    This effectively reverts
    
    commit 8e5fd599eb219f1054e39b40d18b217af669eea9
    Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Date:   Wed Apr 9 13:28:50 2014 +0300
    
        drm/i915/chv: Make CHV irq handler loop until all interrupts are consumed
    
    as under continuous execlists load we can saturate the IRQ handler,
    destablising the tsc clock and triggering the NMI watchdog to declare a hung
    CPU.
    
    [  552.756051] clocksource: timekeeping watchdog on CPU0: Marking clocksource 'tsc' as unstable because the skew is too large:
    [  552.756080] clocksource:                       'refined-jiffies' wd_now: 10003b480 wd_last: 10003b28c mask: ffffffff
    [  552.756091] clocksource:                       'tsc' cs_now: d55d31aa50 cs_last: d17446166c mask: ffffffffffffffff
    [  552.756210] clocksource: Switched to clocksource refined-jiffies
    [  575.217870] NMI watchdog: Watchdog detected hard LOCKUP on cpu 1
    [  575.217893] CPU: 1 PID: 0 Comm: swapper/1 Not tainted 4.5.0-rc7+ #18
    [  575.217905] Hardware name:                  /NUC5CPYB, BIOS PYBSWCEL.86A.0027.2015.0507.1758 05/07/2015
    [  575.217915]  0000000000000000 ffff88027fd05bc0 ffffffff81288c6d 0000000000000000
    [  575.217935]  0000000000000001 ffff88027fd05be0 ffffffff810e72d1 0000000000000000
    [  575.217951]  ffff88027fd05c80 ffff88027fd05c20 ffffffff81114b60 0000000181015f1e
    [  575.217967] Call Trace:
    [  575.217973]  <NMI>  [<ffffffff81288c6d>] dump_stack+0x4f/0x72
    [  575.217994]  [<ffffffff810e72d1>] watchdog_overflow_callback+0x151/0x160
    [  575.218003]  [<ffffffff81114b60>] __perf_event_overflow+0xa0/0x1e0
    [  575.218016]  [<ffffffff811154c4>] perf_event_overflow+0x14/0x20
    [  575.218028]  [<ffffffff8101d2ca>] intel_pmu_handle_irq+0x1da/0x460
    [  575.218042]  [<ffffffff814a8aae>] ? poll_idle+0x3e/0x70
    [  575.218052]  [<ffffffff814a8aae>] ? poll_idle+0x3e/0x70
    [  575.218064]  [<ffffffff81014ae8>] perf_event_nmi_handler+0x28/0x50
    [  575.218075]  [<ffffffff81007540>] nmi_handle+0x60/0x130
    [  575.218086]  [<ffffffff814a8aae>] ? poll_idle+0x3e/0x70
    [  575.218096]  [<ffffffff810079c0>] do_nmi+0x140/0x470
    [  575.218108]  [<ffffffff81559ec7>] end_repeat_nmi+0x1a/0x1e
    [  575.218119]  [<ffffffff814a8aae>] ? poll_idle+0x3e/0x70
    [  575.218129]  [<ffffffff814a8aae>] ? poll_idle+0x3e/0x70
    [  575.218139]  [<ffffffff814a8aae>] ? poll_idle+0x3e/0x70
    [  575.218148]  <<EOE>>  [<ffffffff814a8353>] cpuidle_enter_state+0xf3/0x2f0
    [  575.218164]  [<ffffffff814a8587>] cpuidle_enter+0x17/0x20
    [  575.218175]  [<ffffffff810aaa3a>] call_cpuidle+0x2a/0x40
    [  575.218185]  [<ffffffff810aade3>] cpu_startup_entry+0x273/0x330
    [  575.218196]  [<ffffffff81033a1e>] start_secondary+0x10e/0x130
    
    However, not servicing all available IIR within the handler does hurt the
    throughput of pathological nop execbuf by about 20%, with a similar effect
    upon the dispatch latency of a series of execbuf.
    
    v2: use do {} while(0) for a smaller patch, and easier to revert again
    
    I have reasonable confidence that we do not miss GT interrupts (as
    execlists provides a stress case with a failure mechanism easily
    detected by igt), however I have less confidence about all the other
    sources of interrupts and worry that may lose a display hotplug
    interrupt, for example.
    
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=93467
    Testcase: igt/gem_exec_nop/basic # requires NMI watchdog
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: Antti Koskipää <antti.koskipaa@linux.intel.com>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Cc: stable@vger.kernel.org
    Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1457946117-6714-1-git-send-email-chris@chris-wilson.co.uk

commit 1c3d770043583d99118d52cad309f586ef8e7d4a
Merge: 3c2de27d793b e38e5ce81c3e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Mar 19 19:21:24 2016 -0700

    Merge tag 'firewire-updates' of git://git.kernel.org/pub/scm/linux/kernel/git/ieee1394/linux1394
    
    Pull firewire updates from Stefan Richter:
     "IEEE 1394 subsystem patches:
    
       - move away from outmoded timekeeping API
       - error reporting fix
       - documentation bits"
    
    * tag 'firewire-updates' of git://git.kernel.org/pub/scm/linux/kernel/git/ieee1394/linux1394:
      firewire: ABI documentation: libhinawa uses firewire-cdev
      firewire: ABI documentation: jujuutils were renamed to linux-firewire-utils
      firewire: ohci: propagate return code from soft_reset to probe and resume
      firewire: nosy: Replace timeval with timespec64

commit 8a284c062ec923c924c79e3b1b5199b8d72904fc
Merge: 208de2147767 6436257b491c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Mar 15 12:13:56 2016 -0700

    Merge branch 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer updates from Thomas Gleixner:
     "The timer department delivers this time:
    
       - Support for cross clock domain timestamps in the core code plus a
         first user.  That allows more precise timestamping for PTP and
         later for audio and other peripherals.
    
         The ptp/e1000e patches have been acked by the relevant maintainers
         and are carried in the timer tree to avoid merge ordering issues.
    
       - Support for unregistering the current clocksource watchdog.  That
         lifts a limitation for switching clocksources which has been there
         from day 1
    
       - The usual pile of fixes and updates to the core and the drivers.
         Nothing outstanding and exciting"
    
    * 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (26 commits)
      time/timekeeping: Work around false positive GCC warning
      e1000e: Adds hardware supported cross timestamp on e1000e nic
      ptp: Add PTP_SYS_OFFSET_PRECISE for driver crosstimestamping
      x86/tsc: Always Running Timer (ART) correlated clocksource
      hrtimer: Revert CLOCK_MONOTONIC_RAW support
      time: Add history to cross timestamp interface supporting slower devices
      time: Add driver cross timestamp interface for higher precision time synchronization
      time: Remove duplicated code in ktime_get_raw_and_real()
      time: Add timekeeping snapshot code capturing system time and counter
      time: Add cycles to nanoseconds translation
      jiffies: Use CLOCKSOURCE_MASK instead of constant
      clocksource: Introduce clocksource_freq2mult()
      clockevents/drivers/exynos_mct: Implement ->set_state_oneshot_stopped()
      clockevents/drivers/arm_global_timer: Implement ->set_state_oneshot_stopped()
      clockevents/drivers/arm_arch_timer: Implement ->set_state_oneshot_stopped()
      clocksource/drivers/arm_global_timer: Register delay timer
      clocksource/drivers/lpc32xx: Support timer-based ARM delay
      clocksource/drivers/lpc32xx: Support periodic mode
      clocksource/drivers/lpc32xx: Don't use the prescaler counter for clockevents
      clocksource/drivers/rockchip: Add err handle for rk_timer_init
      ...

commit 6436257b491cc0d456c39330dfc22126148d5ed7
Author: Ingo Molnar <mingo@kernel.org>
Date:   Tue Mar 8 11:09:53 2016 +0100

    time/timekeeping: Work around false positive GCC warning
    
    Newer GCC versions trigger the following warning:
    
      kernel/time/timekeeping.c: In function ‘get_device_system_crosststamp’:
      kernel/time/timekeeping.c:987:5: warning: ‘clock_was_set_seq’ may be used uninitialized in this function [-Wmaybe-uninitialized]
        if (discontinuity) {
         ^
      kernel/time/timekeeping.c:1045:15: note: ‘clock_was_set_seq’ was declared here
        unsigned int clock_was_set_seq;
                     ^
    
    GCC clearly is unable to recognize that the 'do_interp' boolean tracks
    the initialization status of 'clock_was_set_seq'.
    
    The GCC version used was:
    
      gcc version 5.3.1 20151207 (Red Hat 5.3.1-2) (GCC)
    
    Work it around by initializing clock_was_set_seq to 0. Compilers that
    are able to recognize the code flow will eliminate the unnecessary
    initialization.
    
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 972e9e3c7f447bb2becfdcde9931790e78dd43fa
Author: David Gibson <david@gibson.dropbear.id.au>
Date:   Mon Nov 30 12:30:30 2015 +1100

    time: Avoid signed overflow in timekeeping_get_ns()
    
    commit 35a4933a895927990772ae96fdcfd2f806929ee2 upstream.
    
    1e75fa8 "time: Condense timekeeper.xtime into xtime_sec" replaced a call to
    clocksource_cyc2ns() from timekeeping_get_ns() with an open-coded version
    of the same logic to avoid keeping a semi-redundant struct timespec
    in struct timekeeper.
    
    However, the commit also introduced a subtle semantic change - where
    clocksource_cyc2ns() uses purely unsigned math, the new version introduces
    a signed temporary, meaning that if (delta * tk->mult) has a 63-bit
    overflow the following shift will still give a negative result.  The
    choice of 'maxsec' in __clocksource_updatefreq_scale() means this will
    generally happen if there's a ~10 minute pause in examining the
    clocksource.
    
    This can be triggered on a powerpc KVM guest by stopping it from qemu for
    a bit over 10 minutes.  After resuming time has jumped backwards several
    minutes causing numerous problems (jiffies does not advance, msleep()s can
    be extended by minutes..).  It doesn't happen on x86 KVM guests, because
    the guest TSC is effectively frozen while the guest is stopped, which is
    not the case for the powerpc timebase.
    
    Obviously an unsigned (64 bit) overflow will only take twice as long as a
    signed, 63-bit overflow.  I don't know the time code well enough to know
    if that will still cause incorrect calculations, or if a 64-bit overflow
    is avoided elsewhere.
    
    Still, an incorrect forwards clock adjustment will cause less trouble than
    time going backwards.  So, this patch removes the potential for
    intermediate signed overflow.
    
    Suggested-by: Laurent Vivier <lvivier@redhat.com>
    Tested-by: Laurent Vivier <lvivier@redhat.com>
    Signed-off-by: David Gibson <david@gibson.dropbear.id.au>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 8006c24595cab106bcb9da12d35e32e14ff492df
Author: Christopher S. Hall <christopher.s.hall@intel.com>
Date:   Mon Feb 22 03:15:22 2016 -0800

    time: Add driver cross timestamp interface for higher precision time synchronization
    
    ACKNOWLEDGMENT: cross timestamp code was developed by Thomas Gleixner
    <tglx@linutronix.de>. It has changed considerably and any mistakes are
    mine.
    
    The precision with which events on multiple networked systems can be
    synchronized using, as an example, PTP (IEEE 1588, 802.1AS) is limited
    by the precision of the cross timestamps between the system clock and
    the device (timestamp) clock. Precision here is the degree of
    simultaneity when capturing the cross timestamp.
    
    Currently the PTP cross timestamp is captured in software using the
    PTP device driver ioctl PTP_SYS_OFFSET. Reads of the device clock are
    interleaved with reads of the realtime clock. At best, the precision
    of this cross timestamp is on the order of several microseconds due to
    software latencies. Sub-microsecond precision is required for
    industrial control and some media applications. To achieve this level
    of precision hardware supported cross timestamping is needed.
    
    The function get_device_system_crosstimestamp() allows device drivers
    to return a cross timestamp with system time properly scaled to
    nanoseconds.  The realtime value is needed to discipline that clock
    using PTP and the monotonic raw value is used for applications that
    don't require a "real" time, but need an unadjusted clock time.  The
    get_device_system_crosstimestamp() code calls back into the driver to
    ensure that the system counter is within the current timekeeping
    update interval.
    
    Modern Intel hardware provides an Always Running Timer (ART) which is
    exactly related to TSC through a known frequency ratio. The ART is
    routed to devices on the system and is used to precisely and
    simultaneously capture the device clock with the ART.
    
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: kevin.b.stanton@intel.com
    Cc: kevin.j.clarke@intel.com
    Cc: hpa@zytor.com
    Cc: jeffrey.t.kirsher@intel.com
    Cc: netdev@vger.kernel.org
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Christopher S. Hall <christopher.s.hall@intel.com>
    [jstultz: Reworked to remove extra structures and simplify calling]
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 9da0f49c8767cc0ef6101cb21156cf4380ed50dd
Author: Christopher S. Hall <christopher.s.hall@intel.com>
Date:   Mon Feb 22 03:15:20 2016 -0800

    time: Add timekeeping snapshot code capturing system time and counter
    
    In the current timekeeping code there isn't any interface to
    atomically capture the current relationship between the system counter
    and system time. ktime_get_snapshot() returns this triple (counter,
    monotonic raw, realtime) in the system_time_snapshot struct.
    
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: kevin.b.stanton@intel.com
    Cc: kevin.j.clarke@intel.com
    Cc: hpa@zytor.com
    Cc: jeffrey.t.kirsher@intel.com
    Cc: netdev@vger.kernel.org
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Christopher S. Hall <christopher.s.hall@intel.com>
    [jstultz: Moved structure definitions around to clean things up,
     fixed cycles_t/cycle_t confusion.]
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 6bd58f09e1d8cc6c50a824c00bf0d617919986a1
Author: Christopher S. Hall <christopher.s.hall@intel.com>
Date:   Mon Feb 22 03:15:19 2016 -0800

    time: Add cycles to nanoseconds translation
    
    The timekeeping code does not currently provide a way to translate
    externally provided clocksource cycles to system time. The cycle count
    is always provided by the result clocksource read() method internal to
    the timekeeping code. The added function timekeeping_cycles_to_ns()
    calculated a nanosecond value from a cycle count that can be added to
    tk_read_base.base value yielding the current system time. This allows
    clocksource cycle values external to the timekeeping code to provide a
    cycle count that can be transformed to system time.
    
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: kevin.b.stanton@intel.com
    Cc: kevin.j.clarke@intel.com
    Cc: hpa@zytor.com
    Cc: jeffrey.t.kirsher@intel.com
    Cc: netdev@vger.kernel.org
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Christopher S. Hall <christopher.s.hall@intel.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit ade770294df29e08f913e5d733a756893128f45e
Author: Filipe Manana <fdmanana@suse.com>
Date:   Thu Feb 18 14:28:55 2016 +0000

    Btrfs: fix deadlock between direct IO reads and buffered writes
    
    While running a test with a mix of buffered IO and direct IO against
    the same files I hit a deadlock reported by the following trace:
    
    [11642.140352] INFO: task kworker/u32:3:15282 blocked for more than 120 seconds.
    [11642.142452]       Not tainted 4.4.0-rc6-btrfs-next-21+ #1
    [11642.143982] "echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
    [11642.146332] kworker/u32:3   D ffff880230ef7988 [11642.147737] systemd-journald[571]: Sent WATCHDOG=1 notification.
    [11642.149771]     0 15282      2 0x00000000
    [11642.151205] Workqueue: btrfs-flush_delalloc btrfs_flush_delalloc_helper [btrfs]
    [11642.154074]  ffff880230ef7988 0000000000000246 0000000000014ec0 ffff88023ec94ec0
    [11642.156722]  ffff880233fe8f80 ffff880230ef8000 ffff88023ec94ec0 7fffffffffffffff
    [11642.159205]  0000000000000002 ffffffff8147b7f9 ffff880230ef79a0 ffffffff8147b541
    [11642.161403] Call Trace:
    [11642.162129]  [<ffffffff8147b7f9>] ? bit_wait+0x2f/0x2f
    [11642.163396]  [<ffffffff8147b541>] schedule+0x82/0x9a
    [11642.164871]  [<ffffffff8147e7fe>] schedule_timeout+0x43/0x109
    [11642.167020]  [<ffffffff8147b7f9>] ? bit_wait+0x2f/0x2f
    [11642.167931]  [<ffffffff8108afd1>] ? trace_hardirqs_on_caller+0x17b/0x197
    [11642.182320]  [<ffffffff8108affa>] ? trace_hardirqs_on+0xd/0xf
    [11642.183762]  [<ffffffff810b079b>] ? timekeeping_get_ns+0xe/0x33
    [11642.185308]  [<ffffffff810b0f61>] ? ktime_get+0x41/0x52
    [11642.186782]  [<ffffffff8147ac08>] io_schedule_timeout+0xa0/0x102
    [11642.188217]  [<ffffffff8147ac08>] ? io_schedule_timeout+0xa0/0x102
    [11642.189626]  [<ffffffff8147b814>] bit_wait_io+0x1b/0x39
    [11642.190803]  [<ffffffff8147bb21>] __wait_on_bit_lock+0x4c/0x90
    [11642.192158]  [<ffffffff8111829f>] __lock_page+0x66/0x68
    [11642.193379]  [<ffffffff81082f29>] ? autoremove_wake_function+0x3a/0x3a
    [11642.194831]  [<ffffffffa0450ddd>] lock_page+0x31/0x34 [btrfs]
    [11642.197068]  [<ffffffffa0454e3b>] extent_write_cache_pages.isra.19.constprop.35+0x1af/0x2f4 [btrfs]
    [11642.199188]  [<ffffffffa0455373>] extent_writepages+0x4b/0x5c [btrfs]
    [11642.200723]  [<ffffffffa043c913>] ? btrfs_writepage_start_hook+0xce/0xce [btrfs]
    [11642.202465]  [<ffffffffa043aa82>] btrfs_writepages+0x28/0x2a [btrfs]
    [11642.203836]  [<ffffffff811236bc>] do_writepages+0x23/0x2c
    [11642.205624]  [<ffffffff811198c9>] __filemap_fdatawrite_range+0x5a/0x61
    [11642.207057]  [<ffffffff81119946>] filemap_fdatawrite_range+0x13/0x15
    [11642.208529]  [<ffffffffa044f87e>] btrfs_start_ordered_extent+0xd0/0x1a1 [btrfs]
    [11642.210375]  [<ffffffffa0462613>] ? btrfs_scrubparity_helper+0x140/0x33a [btrfs]
    [11642.212132]  [<ffffffffa044f974>] btrfs_run_ordered_extent_work+0x25/0x34 [btrfs]
    [11642.213837]  [<ffffffffa046262f>] btrfs_scrubparity_helper+0x15c/0x33a [btrfs]
    [11642.215457]  [<ffffffffa046293b>] btrfs_flush_delalloc_helper+0xe/0x10 [btrfs]
    [11642.217095]  [<ffffffff8106483e>] process_one_work+0x256/0x48b
    [11642.218324]  [<ffffffff81064f20>] worker_thread+0x1f5/0x2a7
    [11642.219466]  [<ffffffff81064d2b>] ? rescuer_thread+0x289/0x289
    [11642.220801]  [<ffffffff8106a500>] kthread+0xd4/0xdc
    [11642.222032]  [<ffffffff8106a42c>] ? kthread_parkme+0x24/0x24
    [11642.223190]  [<ffffffff8147fdef>] ret_from_fork+0x3f/0x70
    [11642.224394]  [<ffffffff8106a42c>] ? kthread_parkme+0x24/0x24
    [11642.226295] 2 locks held by kworker/u32:3/15282:
    [11642.227273]  #0:  ("%s-%s""btrfs", name){++++.+}, at: [<ffffffff8106474d>] process_one_work+0x165/0x48b
    [11642.229412]  #1:  ((&work->normal_work)){+.+.+.}, at: [<ffffffff8106474d>] process_one_work+0x165/0x48b
    [11642.231414] INFO: task kworker/u32:8:15289 blocked for more than 120 seconds.
    [11642.232872]       Not tainted 4.4.0-rc6-btrfs-next-21+ #1
    [11642.234109] "echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
    [11642.235776] kworker/u32:8   D ffff88020de5f848     0 15289      2 0x00000000
    [11642.237412] Workqueue: writeback wb_workfn (flush-btrfs-481)
    [11642.238670]  ffff88020de5f848 0000000000000246 0000000000014ec0 ffff88023ed54ec0
    [11642.240475]  ffff88021b1ece40 ffff88020de60000 ffff88023ed54ec0 7fffffffffffffff
    [11642.242154]  0000000000000002 ffffffff8147b7f9 ffff88020de5f860 ffffffff8147b541
    [11642.243715] Call Trace:
    [11642.244390]  [<ffffffff8147b7f9>] ? bit_wait+0x2f/0x2f
    [11642.245432]  [<ffffffff8147b541>] schedule+0x82/0x9a
    [11642.246392]  [<ffffffff8147e7fe>] schedule_timeout+0x43/0x109
    [11642.247479]  [<ffffffff8147b7f9>] ? bit_wait+0x2f/0x2f
    [11642.248551]  [<ffffffff8108afd1>] ? trace_hardirqs_on_caller+0x17b/0x197
    [11642.249968]  [<ffffffff8108affa>] ? trace_hardirqs_on+0xd/0xf
    [11642.251043]  [<ffffffff810b079b>] ? timekeeping_get_ns+0xe/0x33
    [11642.252202]  [<ffffffff810b0f61>] ? ktime_get+0x41/0x52
    [11642.253210]  [<ffffffff8147ac08>] io_schedule_timeout+0xa0/0x102
    [11642.254307]  [<ffffffff8147ac08>] ? io_schedule_timeout+0xa0/0x102
    [11642.256118]  [<ffffffff8147b814>] bit_wait_io+0x1b/0x39
    [11642.257131]  [<ffffffff8147bb21>] __wait_on_bit_lock+0x4c/0x90
    [11642.258200]  [<ffffffff8111829f>] __lock_page+0x66/0x68
    [11642.259168]  [<ffffffff81082f29>] ? autoremove_wake_function+0x3a/0x3a
    [11642.260516]  [<ffffffffa0450ddd>] lock_page+0x31/0x34 [btrfs]
    [11642.261841]  [<ffffffffa0454e3b>] extent_write_cache_pages.isra.19.constprop.35+0x1af/0x2f4 [btrfs]
    [11642.263531]  [<ffffffffa0455373>] extent_writepages+0x4b/0x5c [btrfs]
    [11642.264747]  [<ffffffffa043c913>] ? btrfs_writepage_start_hook+0xce/0xce [btrfs]
    [11642.266148]  [<ffffffffa043aa82>] btrfs_writepages+0x28/0x2a [btrfs]
    [11642.267264]  [<ffffffff811236bc>] do_writepages+0x23/0x2c
    [11642.268280]  [<ffffffff81192a2b>] __writeback_single_inode+0xda/0x5ba
    [11642.269407]  [<ffffffff811939f0>] writeback_sb_inodes+0x27b/0x43d
    [11642.270476]  [<ffffffff81193c28>] __writeback_inodes_wb+0x76/0xae
    [11642.271547]  [<ffffffff81193ea6>] wb_writeback+0x19e/0x41c
    [11642.272588]  [<ffffffff81194821>] wb_workfn+0x201/0x341
    [11642.273523]  [<ffffffff81194821>] ? wb_workfn+0x201/0x341
    [11642.274479]  [<ffffffff8106483e>] process_one_work+0x256/0x48b
    [11642.275497]  [<ffffffff81064f20>] worker_thread+0x1f5/0x2a7
    [11642.276518]  [<ffffffff81064d2b>] ? rescuer_thread+0x289/0x289
    [11642.277520]  [<ffffffff81064d2b>] ? rescuer_thread+0x289/0x289
    [11642.278517]  [<ffffffff8106a500>] kthread+0xd4/0xdc
    [11642.279371]  [<ffffffff8106a42c>] ? kthread_parkme+0x24/0x24
    [11642.280468]  [<ffffffff8147fdef>] ret_from_fork+0x3f/0x70
    [11642.281607]  [<ffffffff8106a42c>] ? kthread_parkme+0x24/0x24
    [11642.282604] 3 locks held by kworker/u32:8/15289:
    [11642.283423]  #0:  ("writeback"){++++.+}, at: [<ffffffff8106474d>] process_one_work+0x165/0x48b
    [11642.285629]  #1:  ((&(&wb->dwork)->work)){+.+.+.}, at: [<ffffffff8106474d>] process_one_work+0x165/0x48b
    [11642.287538]  #2:  (&type->s_umount_key#37){+++++.}, at: [<ffffffff81171217>] trylock_super+0x1b/0x4b
    [11642.289423] INFO: task fdm-stress:26848 blocked for more than 120 seconds.
    [11642.290547]       Not tainted 4.4.0-rc6-btrfs-next-21+ #1
    [11642.291453] "echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
    [11642.292864] fdm-stress      D ffff88022c107c20     0 26848  26591 0x00000000
    [11642.294118]  ffff88022c107c20 000000038108affa 0000000000014ec0 ffff88023ed54ec0
    [11642.295602]  ffff88013ab1ca40 ffff88022c108000 ffff8800b2fc19d0 00000000000e0fff
    [11642.297098]  ffff8800b2fc19b0 ffff88022c107c88 ffff88022c107c38 ffffffff8147b541
    [11642.298433] Call Trace:
    [11642.298896]  [<ffffffff8147b541>] schedule+0x82/0x9a
    [11642.299738]  [<ffffffffa045225d>] lock_extent_bits+0xfe/0x1a3 [btrfs]
    [11642.300833]  [<ffffffff81082eef>] ? add_wait_queue_exclusive+0x44/0x44
    [11642.301943]  [<ffffffffa0447516>] lock_and_cleanup_extent_if_need+0x68/0x18e [btrfs]
    [11642.303270]  [<ffffffffa04485ba>] __btrfs_buffered_write+0x238/0x4c1 [btrfs]
    [11642.304552]  [<ffffffffa044b50a>] ? btrfs_file_write_iter+0x17c/0x408 [btrfs]
    [11642.305782]  [<ffffffffa044b682>] btrfs_file_write_iter+0x2f4/0x408 [btrfs]
    [11642.306878]  [<ffffffff8116e298>] __vfs_write+0x7c/0xa5
    [11642.307729]  [<ffffffff8116e7d1>] vfs_write+0x9d/0xe8
    [11642.308602]  [<ffffffff8116efbb>] SyS_write+0x50/0x7e
    [11642.309410]  [<ffffffff8147fa97>] entry_SYSCALL_64_fastpath+0x12/0x6b
    [11642.310403] 3 locks held by fdm-stress/26848:
    [11642.311108]  #0:  (&f->f_pos_lock){+.+.+.}, at: [<ffffffff811877e8>] __fdget_pos+0x3a/0x40
    [11642.312578]  #1:  (sb_writers#11){.+.+.+}, at: [<ffffffff811706ee>] __sb_start_write+0x5f/0xb0
    [11642.314170]  #2:  (&sb->s_type->i_mutex_key#15){+.+.+.}, at: [<ffffffffa044b401>] btrfs_file_write_iter+0x73/0x408 [btrfs]
    [11642.316796] INFO: task fdm-stress:26849 blocked for more than 120 seconds.
    [11642.317842]       Not tainted 4.4.0-rc6-btrfs-next-21+ #1
    [11642.318691] "echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
    [11642.319959] fdm-stress      D ffff8801964ffa68     0 26849  26591 0x00000000
    [11642.321312]  ffff8801964ffa68 00ff8801e9975f80 0000000000014ec0 ffff88023ed94ec0
    [11642.322555]  ffff8800b00b4840 ffff880196500000 ffff8801e9975f20 0000000000000002
    [11642.323715]  ffff8801e9975f18 ffff8800b00b4840 ffff8801964ffa80 ffffffff8147b541
    [11642.325096] Call Trace:
    [11642.325532]  [<ffffffff8147b541>] schedule+0x82/0x9a
    [11642.326303]  [<ffffffff8147e7fe>] schedule_timeout+0x43/0x109
    [11642.327180]  [<ffffffff8108ae40>] ? mark_held_locks+0x5e/0x74
    [11642.328114]  [<ffffffff8147f30e>] ? _raw_spin_unlock_irq+0x2c/0x4a
    [11642.329051]  [<ffffffff8108afd1>] ? trace_hardirqs_on_caller+0x17b/0x197
    [11642.330053]  [<ffffffff8147bceb>] __wait_for_common+0x109/0x147
    [11642.330952]  [<ffffffff8147bceb>] ? __wait_for_common+0x109/0x147
    [11642.331869]  [<ffffffff8147e7bb>] ? usleep_range+0x4a/0x4a
    [11642.332925]  [<ffffffff81074075>] ? wake_up_q+0x47/0x47
    [11642.333736]  [<ffffffff8147bd4d>] wait_for_completion+0x24/0x26
    [11642.334672]  [<ffffffffa044f5ce>] btrfs_wait_ordered_extents+0x1c8/0x217 [btrfs]
    [11642.335858]  [<ffffffffa0465b5a>] btrfs_mksubvol+0x224/0x45d [btrfs]
    [11642.336854]  [<ffffffff81082eef>] ? add_wait_queue_exclusive+0x44/0x44
    [11642.337820]  [<ffffffffa0465edb>] btrfs_ioctl_snap_create_transid+0x148/0x17a [btrfs]
    [11642.339026]  [<ffffffffa046603b>] btrfs_ioctl_snap_create_v2+0xc7/0x110 [btrfs]
    [11642.340214]  [<ffffffffa0468582>] btrfs_ioctl+0x590/0x27bd [btrfs]
    [11642.341123]  [<ffffffff8147dc00>] ? mutex_unlock+0xe/0x10
    [11642.341934]  [<ffffffffa00fa6e9>] ? ext4_file_write_iter+0x2a3/0x36f [ext4]
    [11642.342936]  [<ffffffff8108895d>] ? __lock_is_held+0x3c/0x57
    [11642.343772]  [<ffffffff81186a1d>] ? rcu_read_unlock+0x3e/0x5d
    [11642.344673]  [<ffffffff8117dc95>] do_vfs_ioctl+0x458/0x4dc
    [11642.346024]  [<ffffffff81186bbe>] ? __fget_light+0x62/0x71
    [11642.346873]  [<ffffffff8117dd70>] SyS_ioctl+0x57/0x79
    [11642.347720]  [<ffffffff8147fa97>] entry_SYSCALL_64_fastpath+0x12/0x6b
    [11642.350222] 4 locks held by fdm-stress/26849:
    [11642.350898]  #0:  (sb_writers#11){.+.+.+}, at: [<ffffffff811706ee>] __sb_start_write+0x5f/0xb0
    [11642.352375]  #1:  (&type->i_mutex_dir_key#4/1){+.+.+.}, at: [<ffffffffa0465981>] btrfs_mksubvol+0x4b/0x45d [btrfs]
    [11642.354072]  #2:  (&fs_info->subvol_sem){++++..}, at: [<ffffffffa0465a2a>] btrfs_mksubvol+0xf4/0x45d [btrfs]
    [11642.355647]  #3:  (&root->ordered_extent_mutex){+.+...}, at: [<ffffffffa044f456>] btrfs_wait_ordered_extents+0x50/0x217 [btrfs]
    [11642.357516] INFO: task fdm-stress:26850 blocked for more than 120 seconds.
    [11642.358508]       Not tainted 4.4.0-rc6-btrfs-next-21+ #1
    [11642.359376] "echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
    [11642.368625] fdm-stress      D ffff88021f167688     0 26850  26591 0x00000000
    [11642.369716]  ffff88021f167688 0000000000000001 0000000000014ec0 ffff88023edd4ec0
    [11642.370950]  ffff880128a98680 ffff88021f168000 ffff88023edd4ec0 7fffffffffffffff
    [11642.372210]  0000000000000002 ffffffff8147b7f9 ffff88021f1676a0 ffffffff8147b541
    [11642.373430] Call Trace:
    [11642.373853]  [<ffffffff8147b7f9>] ? bit_wait+0x2f/0x2f
    [11642.374623]  [<ffffffff8147b541>] schedule+0x82/0x9a
    [11642.375948]  [<ffffffff8147e7fe>] schedule_timeout+0x43/0x109
    [11642.376862]  [<ffffffff8147b7f9>] ? bit_wait+0x2f/0x2f
    [11642.377637]  [<ffffffff8108afd1>] ? trace_hardirqs_on_caller+0x17b/0x197
    [11642.378610]  [<ffffffff8108affa>] ? trace_hardirqs_on+0xd/0xf
    [11642.379457]  [<ffffffff810b079b>] ? timekeeping_get_ns+0xe/0x33
    [11642.380366]  [<ffffffff810b0f61>] ? ktime_get+0x41/0x52
    [11642.381353]  [<ffffffff8147ac08>] io_schedule_timeout+0xa0/0x102
    [11642.382255]  [<ffffffff8147ac08>] ? io_schedule_timeout+0xa0/0x102
    [11642.383162]  [<ffffffff8147b814>] bit_wait_io+0x1b/0x39
    [11642.383945]  [<ffffffff8147bb21>] __wait_on_bit_lock+0x4c/0x90
    [11642.384875]  [<ffffffff8111829f>] __lock_page+0x66/0x68
    [11642.385749]  [<ffffffff81082f29>] ? autoremove_wake_function+0x3a/0x3a
    [11642.386721]  [<ffffffffa0450ddd>] lock_page+0x31/0x34 [btrfs]
    [11642.387596]  [<ffffffffa0454e3b>] extent_write_cache_pages.isra.19.constprop.35+0x1af/0x2f4 [btrfs]
    [11642.389030]  [<ffffffffa0455373>] extent_writepages+0x4b/0x5c [btrfs]
    [11642.389973]  [<ffffffff810a25ad>] ? rcu_read_lock_sched_held+0x61/0x69
    [11642.390939]  [<ffffffffa043c913>] ? btrfs_writepage_start_hook+0xce/0xce [btrfs]
    [11642.392271]  [<ffffffffa0451c32>] ? __clear_extent_bit+0x26e/0x2c0 [btrfs]
    [11642.393305]  [<ffffffffa043aa82>] btrfs_writepages+0x28/0x2a [btrfs]
    [11642.394239]  [<ffffffff811236bc>] do_writepages+0x23/0x2c
    [11642.395045]  [<ffffffff811198c9>] __filemap_fdatawrite_range+0x5a/0x61
    [11642.395991]  [<ffffffff81119946>] filemap_fdatawrite_range+0x13/0x15
    [11642.397144]  [<ffffffffa044f87e>] btrfs_start_ordered_extent+0xd0/0x1a1 [btrfs]
    [11642.398392]  [<ffffffffa0452094>] ? clear_extent_bit+0x17/0x19 [btrfs]
    [11642.399363]  [<ffffffffa0445945>] btrfs_get_blocks_direct+0x12b/0x61c [btrfs]
    [11642.400445]  [<ffffffff8119f7a1>] ? dio_bio_add_page+0x3d/0x54
    [11642.401309]  [<ffffffff8119fa93>] ? submit_page_section+0x7b/0x111
    [11642.402213]  [<ffffffff811a0258>] do_blockdev_direct_IO+0x685/0xc24
    [11642.403139]  [<ffffffffa044581a>] ? btrfs_page_exists_in_range+0x1a1/0x1a1 [btrfs]
    [11642.404360]  [<ffffffffa043d267>] ? btrfs_get_extent_fiemap+0x1c0/0x1c0 [btrfs]
    [11642.406187]  [<ffffffff811a0828>] __blockdev_direct_IO+0x31/0x33
    [11642.407070]  [<ffffffff811a0828>] ? __blockdev_direct_IO+0x31/0x33
    [11642.407990]  [<ffffffffa043d267>] ? btrfs_get_extent_fiemap+0x1c0/0x1c0 [btrfs]
    [11642.409192]  [<ffffffffa043b4ca>] btrfs_direct_IO+0x1c7/0x27e [btrfs]
    [11642.410146]  [<ffffffffa043d267>] ? btrfs_get_extent_fiemap+0x1c0/0x1c0 [btrfs]
    [11642.411291]  [<ffffffff81119a2c>] generic_file_read_iter+0x89/0x4e1
    [11642.412263]  [<ffffffff8108ac05>] ? mark_lock+0x24/0x201
    [11642.413057]  [<ffffffff8116e1f8>] __vfs_read+0x79/0x9d
    [11642.413897]  [<ffffffff8116e6f1>] vfs_read+0x8f/0xd2
    [11642.414708]  [<ffffffff8116ef3d>] SyS_read+0x50/0x7e
    [11642.415573]  [<ffffffff8147fa97>] entry_SYSCALL_64_fastpath+0x12/0x6b
    [11642.416572] 1 lock held by fdm-stress/26850:
    [11642.417345]  #0:  (&f->f_pos_lock){+.+.+.}, at: [<ffffffff811877e8>] __fdget_pos+0x3a/0x40
    [11642.418703] INFO: task fdm-stress:26851 blocked for more than 120 seconds.
    [11642.419698]       Not tainted 4.4.0-rc6-btrfs-next-21+ #1
    [11642.420612] "echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
    [11642.421807] fdm-stress      D ffff880196483d28     0 26851  26591 0x00000000
    [11642.422878]  ffff880196483d28 00ff8801c8f60740 0000000000014ec0 ffff88023ed94ec0
    [11642.424149]  ffff8801c8f60740 ffff880196484000 0000000000000246 ffff8801c8f60740
    [11642.425374]  ffff8801bb711840 ffff8801bb711878 ffff880196483d40 ffffffff8147b541
    [11642.426591] Call Trace:
    [11642.427013]  [<ffffffff8147b541>] schedule+0x82/0x9a
    [11642.427856]  [<ffffffff8147b6d5>] schedule_preempt_disabled+0x18/0x24
    [11642.428852]  [<ffffffff8147c23a>] mutex_lock_nested+0x1d7/0x3b4
    [11642.429743]  [<ffffffffa044f456>] ? btrfs_wait_ordered_extents+0x50/0x217 [btrfs]
    [11642.430911]  [<ffffffffa044f456>] btrfs_wait_ordered_extents+0x50/0x217 [btrfs]
    [11642.432102]  [<ffffffffa044f674>] ? btrfs_wait_ordered_roots+0x57/0x191 [btrfs]
    [11642.433259]  [<ffffffffa044f456>] ? btrfs_wait_ordered_extents+0x50/0x217 [btrfs]
    [11642.434431]  [<ffffffffa044f6ea>] btrfs_wait_ordered_roots+0xcd/0x191 [btrfs]
    [11642.436079]  [<ffffffffa0410cab>] btrfs_sync_fs+0xe0/0x1ad [btrfs]
    [11642.437009]  [<ffffffff81197900>] ? SyS_tee+0x23c/0x23c
    [11642.437860]  [<ffffffff81197920>] sync_fs_one_sb+0x20/0x22
    [11642.438723]  [<ffffffff81171435>] iterate_supers+0x75/0xc2
    [11642.439597]  [<ffffffff81197d00>] sys_sync+0x52/0x80
    [11642.440454]  [<ffffffff8147fa97>] entry_SYSCALL_64_fastpath+0x12/0x6b
    [11642.441533] 3 locks held by fdm-stress/26851:
    [11642.442370]  #0:  (&type->s_umount_key#37){+++++.}, at: [<ffffffff8117141f>] iterate_supers+0x5f/0xc2
    [11642.444043]  #1:  (&fs_info->ordered_operations_mutex){+.+...}, at: [<ffffffffa044f661>] btrfs_wait_ordered_roots+0x44/0x191 [btrfs]
    [11642.446010]  #2:  (&root->ordered_extent_mutex){+.+...}, at: [<ffffffffa044f456>] btrfs_wait_ordered_extents+0x50/0x217 [btrfs]
    
    This happened because under specific timings the path for direct IO reads
    can deadlock with concurrent buffered writes. The diagram below shows how
    this happens for an example file that has the following layout:
    
         [  extent A  ]  [  extent B  ]  [ ....
         0K              4K              8K
    
         CPU 1                                               CPU 2                             CPU 3
    
    DIO read against range
     [0K, 8K[ starts
    
    btrfs_direct_IO()
      --> calls btrfs_get_blocks_direct()
          which finds the extent map for the
          extent A and leaves the range
          [0K, 4K[ locked in the inode's
          io tree
    
                                                       buffered write against
                                                       range [4K, 8K[ starts
    
                                                       __btrfs_buffered_write()
                                                         --> dirties page at 4K
    
                                                                                         a user space
                                                                                         task calls sync
                                                                                         for e.g or
                                                                                         writepages() is
                                                                                         invoked by mm
    
                                                                                         writepages()
                                                                                           run_delalloc_range()
                                                                                             cow_file_range()
                                                                                               --> ordered extent X
                                                                                                   for the buffered
                                                                                                   write is created
                                                                                                   and
                                                                                                   writeback starts
    
      --> calls btrfs_get_blocks_direct()
          again, without submitting first
          a bio for reading extent A, and
          finds the extent map for extent B
    
      --> calls lock_extent_direct()
    
          --> locks range [4K, 8K[
          --> finds ordered extent X
              covering range [4K, 8K[
          --> unlocks range [4K, 8K[
    
                                                      buffered write against
                                                      range [0K, 8K[ starts
    
                                                      __btrfs_buffered_write()
                                                        prepare_pages()
                                                          --> locks pages with
                                                              offsets 0 and 4K
                                                        lock_and_cleanup_extent_if_need()
                                                          --> blocks attempting to
                                                              lock range [0K, 8K[ in
                                                              the inode's io tree,
                                                              because the range [0, 4K[
                                                              is already locked by the
                                                              direct IO task at CPU 1
    
          --> calls
              btrfs_start_ordered_extent(oe X)
    
              btrfs_start_ordered_extent(oe X)
    
                --> At this point writeback for ordered
                    extent X has not finished yet
    
                filemap_fdatawrite_range()
                  btrfs_writepages()
                    extent_writepages()
                      extent_write_cache_pages()
                        --> finds page with offset 0
                            with the writeback tag
                            (and not dirty)
                        --> tries to lock it
                             --> deadlock, task at CPU 2
                                 has the page locked and
                                 is blocked on the io range
                                 [0, 4K[ that was locked
                                 earlier by this task
    
    So fix this by falling back to a buffered read in the direct IO read path
    when an ordered extent for a buffered write is found.
    
    Signed-off-by: Filipe Manana <fdmanana@suse.com>
    Reviewed-by: Liu Bo <bo.li.liu@oracle.com>
    Signed-off-by: Chris Mason <clm@fb.com>

commit dfd2961ab6eda6c39aa9d7ddc5e6fb754b16a750
Author: David Sterba <dsterba@suse.com>
Date:   Mon Jan 25 11:02:06 2016 +0100

    Revert "btrfs: clear PF_NOFREEZE in cleaner_kthread()"
    
    commit 80ad623edd2d0ccb47d85357ee31c97e6c684e82 upstream.
    
    This reverts commit 696249132158014d594896df3a81390616069c5c. The
    cleaner thread can block freezing when there's a snapshot cleaning in
    progress and the other threads get suspended first. From the logs
    provided by Martin we're waiting for reading extent pages:
    
    kernel: PM: Syncing filesystems ... done.
    kernel: Freezing user space processes ... (elapsed 0.015 seconds) done.
    kernel: Freezing remaining freezable tasks ...
    kernel: Freezing of tasks failed after 20.003 seconds (1 tasks refusing to freeze, wq_busy=0):
    kernel: btrfs-cleaner   D ffff88033dd13bc0     0   152      2 0x00000000
    kernel: ffff88032ebc2e00 ffff88032e750000 ffff88032e74fa50 7fffffffffffffff
    kernel: ffffffff814a58df 0000000000000002 ffffea000934d580 ffffffff814a5451
    kernel: 7fffffffffffffff ffffffff814a6e8f 0000000000000000 0000000000000020
    kernel: Call Trace:
    kernel: [<ffffffff814a58df>] ? bit_wait+0x2c/0x2c
    kernel: [<ffffffff814a5451>] ? schedule+0x6f/0x7c
    kernel: [<ffffffff814a6e8f>] ? schedule_timeout+0x2f/0xd8
    kernel: [<ffffffff81076f94>] ? timekeeping_get_ns+0xa/0x2e
    kernel: [<ffffffff81077603>] ? ktime_get+0x36/0x44
    kernel: [<ffffffff814a4f6c>] ? io_schedule_timeout+0x94/0xf2
    kernel: [<ffffffff814a4f6c>] ? io_schedule_timeout+0x94/0xf2
    kernel: [<ffffffff814a590b>] ? bit_wait_io+0x2c/0x30
    kernel: [<ffffffff814a5694>] ? __wait_on_bit+0x41/0x73
    kernel: [<ffffffff8109eba8>] ? wait_on_page_bit+0x6d/0x72
    kernel: [<ffffffff8105d718>] ? autoremove_wake_function+0x2a/0x2a
    kernel: [<ffffffff811a02d7>] ? read_extent_buffer_pages+0x1bd/0x203
    kernel: [<ffffffff8117d9e9>] ? free_root_pointers+0x4c/0x4c
    kernel: [<ffffffff8117e831>] ? btree_read_extent_buffer_pages.constprop.57+0x5a/0xe9
    kernel: [<ffffffff8117f4f3>] ? read_tree_block+0x2d/0x45
    kernel: [<ffffffff8116782a>] ? read_block_for_search.isra.34+0x22a/0x26b
    kernel: [<ffffffff811656c3>] ? btrfs_set_path_blocking+0x1e/0x4a
    kernel: [<ffffffff8116919b>] ? btrfs_search_slot+0x648/0x736
    kernel: [<ffffffff81170559>] ? btrfs_lookup_extent_info+0xb7/0x2c7
    kernel: [<ffffffff81170ee5>] ? walk_down_proc+0x9c/0x1ae
    kernel: [<ffffffff81171c9d>] ? walk_down_tree+0x40/0xa4
    kernel: [<ffffffff8117375f>] ? btrfs_drop_snapshot+0x2da/0x664
    kernel: [<ffffffff8104ff21>] ? finish_task_switch+0x126/0x167
    kernel: [<ffffffff811850f8>] ? btrfs_clean_one_deleted_snapshot+0xa6/0xb0
    kernel: [<ffffffff8117eaba>] ? cleaner_kthread+0x13e/0x17b
    kernel: [<ffffffff8117e97c>] ? btrfs_item_end+0x33/0x33
    kernel: [<ffffffff8104d256>] ? kthread+0x95/0x9d
    kernel: [<ffffffff8104d1c1>] ? kthread_parkme+0x16/0x16
    kernel: [<ffffffff814a7b5f>] ? ret_from_fork+0x3f/0x70
    kernel: [<ffffffff8104d1c1>] ? kthread_parkme+0x16/0x16
    
    As this affects a released kernel (4.4) we need a minimal fix for
    stable kernels.
    
    Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=108361
    Reported-by: Martin Ziegler <ziegler@uni-freiburg.de>
    CC: Jiri Kosina <jkosina@suse.cz>
    Signed-off-by: David Sterba <dsterba@suse.com>
    Signed-off-by: Chris Mason <clm@fb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 9282d8b196725d802a57a757e78a3c74cccb9708
Author: David Gibson <david@gibson.dropbear.id.au>
Date:   Mon Nov 30 12:30:30 2015 +1100

    time: Avoid signed overflow in timekeeping_get_ns()
    
    [ Upstream commit 35a4933a895927990772ae96fdcfd2f806929ee2 ]
    
    1e75fa8 "time: Condense timekeeper.xtime into xtime_sec" replaced a call to
    clocksource_cyc2ns() from timekeeping_get_ns() with an open-coded version
    of the same logic to avoid keeping a semi-redundant struct timespec
    in struct timekeeper.
    
    However, the commit also introduced a subtle semantic change - where
    clocksource_cyc2ns() uses purely unsigned math, the new version introduces
    a signed temporary, meaning that if (delta * tk->mult) has a 63-bit
    overflow the following shift will still give a negative result.  The
    choice of 'maxsec' in __clocksource_updatefreq_scale() means this will
    generally happen if there's a ~10 minute pause in examining the
    clocksource.
    
    This can be triggered on a powerpc KVM guest by stopping it from qemu for
    a bit over 10 minutes.  After resuming time has jumped backwards several
    minutes causing numerous problems (jiffies does not advance, msleep()s can
    be extended by minutes..).  It doesn't happen on x86 KVM guests, because
    the guest TSC is effectively frozen while the guest is stopped, which is
    not the case for the powerpc timebase.
    
    Obviously an unsigned (64 bit) overflow will only take twice as long as a
    signed, 63-bit overflow.  I don't know the time code well enough to know
    if that will still cause incorrect calculations, or if a 64-bit overflow
    is avoided elsewhere.
    
    Still, an incorrect forwards clock adjustment will cause less trouble than
    time going backwards.  So, this patch removes the potential for
    intermediate signed overflow.
    
    Cc: stable@vger.kernel.org  (3.7+)
    Suggested-by: Laurent Vivier <lvivier@redhat.com>
    Tested-by: Laurent Vivier <lvivier@redhat.com>
    Signed-off-by: David Gibson <david@gibson.dropbear.id.au>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Sasha Levin <sasha.levin@oracle.com>

commit 1b69e00de62060e7426702dd5799d88953b96757
Author: David Gibson <david@gibson.dropbear.id.au>
Date:   Mon Nov 30 12:30:30 2015 +1100

    time: Avoid signed overflow in timekeeping_get_ns()
    
    commit 35a4933a895927990772ae96fdcfd2f806929ee2 upstream.
    
    1e75fa8 "time: Condense timekeeper.xtime into xtime_sec" replaced a call to
    clocksource_cyc2ns() from timekeeping_get_ns() with an open-coded version
    of the same logic to avoid keeping a semi-redundant struct timespec
    in struct timekeeper.
    
    However, the commit also introduced a subtle semantic change - where
    clocksource_cyc2ns() uses purely unsigned math, the new version introduces
    a signed temporary, meaning that if (delta * tk->mult) has a 63-bit
    overflow the following shift will still give a negative result.  The
    choice of 'maxsec' in __clocksource_updatefreq_scale() means this will
    generally happen if there's a ~10 minute pause in examining the
    clocksource.
    
    This can be triggered on a powerpc KVM guest by stopping it from qemu for
    a bit over 10 minutes.  After resuming time has jumped backwards several
    minutes causing numerous problems (jiffies does not advance, msleep()s can
    be extended by minutes..).  It doesn't happen on x86 KVM guests, because
    the guest TSC is effectively frozen while the guest is stopped, which is
    not the case for the powerpc timebase.
    
    Obviously an unsigned (64 bit) overflow will only take twice as long as a
    signed, 63-bit overflow.  I don't know the time code well enough to know
    if that will still cause incorrect calculations, or if a 64-bit overflow
    is avoided elsewhere.
    
    Still, an incorrect forwards clock adjustment will cause less trouble than
    time going backwards.  So, this patch removes the potential for
    intermediate signed overflow.
    
    Suggested-by: Laurent Vivier <lvivier@redhat.com>
    Tested-by: Laurent Vivier <lvivier@redhat.com>
    Signed-off-by: David Gibson <david@gibson.dropbear.id.au>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    [ luis: backported to 3.16: adjusted context ]
    Signed-off-by: Luis Henriques <luis.henriques@canonical.com>

commit 51975a203210d3a94a7711651b1045ed0e3514ed
Author: David Gibson <david@gibson.dropbear.id.au>
Date:   Mon Nov 30 12:30:30 2015 +1100

    time: Avoid signed overflow in timekeeping_get_ns()
    
    [ Upstream commit 35a4933a895927990772ae96fdcfd2f806929ee2 ]
    
    1e75fa8 "time: Condense timekeeper.xtime into xtime_sec" replaced a call to
    clocksource_cyc2ns() from timekeeping_get_ns() with an open-coded version
    of the same logic to avoid keeping a semi-redundant struct timespec
    in struct timekeeper.
    
    However, the commit also introduced a subtle semantic change - where
    clocksource_cyc2ns() uses purely unsigned math, the new version introduces
    a signed temporary, meaning that if (delta * tk->mult) has a 63-bit
    overflow the following shift will still give a negative result.  The
    choice of 'maxsec' in __clocksource_updatefreq_scale() means this will
    generally happen if there's a ~10 minute pause in examining the
    clocksource.
    
    This can be triggered on a powerpc KVM guest by stopping it from qemu for
    a bit over 10 minutes.  After resuming time has jumped backwards several
    minutes causing numerous problems (jiffies does not advance, msleep()s can
    be extended by minutes..).  It doesn't happen on x86 KVM guests, because
    the guest TSC is effectively frozen while the guest is stopped, which is
    not the case for the powerpc timebase.
    
    Obviously an unsigned (64 bit) overflow will only take twice as long as a
    signed, 63-bit overflow.  I don't know the time code well enough to know
    if that will still cause incorrect calculations, or if a 64-bit overflow
    is avoided elsewhere.
    
    Still, an incorrect forwards clock adjustment will cause less trouble than
    time going backwards.  So, this patch removes the potential for
    intermediate signed overflow.
    
    Cc: stable@vger.kernel.org  (3.7+)
    Suggested-by: Laurent Vivier <lvivier@redhat.com>
    Tested-by: Laurent Vivier <lvivier@redhat.com>
    Signed-off-by: David Gibson <david@gibson.dropbear.id.au>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Sasha Levin <sasha.levin@oracle.com>

commit 80ad623edd2d0ccb47d85357ee31c97e6c684e82
Author: David Sterba <dsterba@suse.com>
Date:   Mon Jan 25 11:02:06 2016 +0100

    Revert "btrfs: clear PF_NOFREEZE in cleaner_kthread()"
    
    This reverts commit 696249132158014d594896df3a81390616069c5c. The
    cleaner thread can block freezing when there's a snapshot cleaning in
    progress and the other threads get suspended first. From the logs
    provided by Martin we're waiting for reading extent pages:
    
    kernel: PM: Syncing filesystems ... done.
    kernel: Freezing user space processes ... (elapsed 0.015 seconds) done.
    kernel: Freezing remaining freezable tasks ...
    kernel: Freezing of tasks failed after 20.003 seconds (1 tasks refusing to freeze, wq_busy=0):
    kernel: btrfs-cleaner   D ffff88033dd13bc0     0   152      2 0x00000000
    kernel: ffff88032ebc2e00 ffff88032e750000 ffff88032e74fa50 7fffffffffffffff
    kernel: ffffffff814a58df 0000000000000002 ffffea000934d580 ffffffff814a5451
    kernel: 7fffffffffffffff ffffffff814a6e8f 0000000000000000 0000000000000020
    kernel: Call Trace:
    kernel: [<ffffffff814a58df>] ? bit_wait+0x2c/0x2c
    kernel: [<ffffffff814a5451>] ? schedule+0x6f/0x7c
    kernel: [<ffffffff814a6e8f>] ? schedule_timeout+0x2f/0xd8
    kernel: [<ffffffff81076f94>] ? timekeeping_get_ns+0xa/0x2e
    kernel: [<ffffffff81077603>] ? ktime_get+0x36/0x44
    kernel: [<ffffffff814a4f6c>] ? io_schedule_timeout+0x94/0xf2
    kernel: [<ffffffff814a4f6c>] ? io_schedule_timeout+0x94/0xf2
    kernel: [<ffffffff814a590b>] ? bit_wait_io+0x2c/0x30
    kernel: [<ffffffff814a5694>] ? __wait_on_bit+0x41/0x73
    kernel: [<ffffffff8109eba8>] ? wait_on_page_bit+0x6d/0x72
    kernel: [<ffffffff8105d718>] ? autoremove_wake_function+0x2a/0x2a
    kernel: [<ffffffff811a02d7>] ? read_extent_buffer_pages+0x1bd/0x203
    kernel: [<ffffffff8117d9e9>] ? free_root_pointers+0x4c/0x4c
    kernel: [<ffffffff8117e831>] ? btree_read_extent_buffer_pages.constprop.57+0x5a/0xe9
    kernel: [<ffffffff8117f4f3>] ? read_tree_block+0x2d/0x45
    kernel: [<ffffffff8116782a>] ? read_block_for_search.isra.34+0x22a/0x26b
    kernel: [<ffffffff811656c3>] ? btrfs_set_path_blocking+0x1e/0x4a
    kernel: [<ffffffff8116919b>] ? btrfs_search_slot+0x648/0x736
    kernel: [<ffffffff81170559>] ? btrfs_lookup_extent_info+0xb7/0x2c7
    kernel: [<ffffffff81170ee5>] ? walk_down_proc+0x9c/0x1ae
    kernel: [<ffffffff81171c9d>] ? walk_down_tree+0x40/0xa4
    kernel: [<ffffffff8117375f>] ? btrfs_drop_snapshot+0x2da/0x664
    kernel: [<ffffffff8104ff21>] ? finish_task_switch+0x126/0x167
    kernel: [<ffffffff811850f8>] ? btrfs_clean_one_deleted_snapshot+0xa6/0xb0
    kernel: [<ffffffff8117eaba>] ? cleaner_kthread+0x13e/0x17b
    kernel: [<ffffffff8117e97c>] ? btrfs_item_end+0x33/0x33
    kernel: [<ffffffff8104d256>] ? kthread+0x95/0x9d
    kernel: [<ffffffff8104d1c1>] ? kthread_parkme+0x16/0x16
    kernel: [<ffffffff814a7b5f>] ? ret_from_fork+0x3f/0x70
    kernel: [<ffffffff8104d1c1>] ? kthread_parkme+0x16/0x16
    
    As this affects a released kernel (4.4) we need a minimal fix for
    stable kernels.
    
    Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=108361
    Reported-by: Martin Ziegler <ziegler@uni-freiburg.de>
    CC: stable@vger.kernel.org # 4.4
    CC: Jiri Kosina <jkosina@suse.cz>
    Signed-off-by: David Sterba <dsterba@suse.com>
    Signed-off-by: Chris Mason <clm@fb.com>

commit b4cee21ee057ff3e5c9014fb6a175bd932c5ce62
Merge: ae8a52185e5c 01414888eaf7 1b9f23727abb
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jan 11 18:06:43 2016 -0800

    Merge branches 'timers-core-for-linus' and 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer updates - and a leftover fix - from Thomas Gleixner:
     "A rather large (commit wise) update from the timer side:
    
       - A bulk update to make compile tests work in the clocksource drivers
    
       - An overhaul of the h8300 timers
    
       - Some more Y2038 work
    
       - A few overflow prevention checks in the timekeeping/ntp code
    
       - The usual pile of fixes and improvements to the various
         clocksource/clockevent drivers and core code"
    
    Also:
     "A single fix for the posix-clock poll code which did not make it into
      4.4"
    
    * 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (84 commits)
      clocksource/drivers/acpi_pm: Convert to pr_* macros
      clocksource: Make clocksource validation work for all clocksources
      timekeeping: Cap adjustments so they don't exceed the maxadj value
      ntp: Fix second_overflow's input parameter type to be 64bits
      ntp: Change time_reftime to time64_t and utilize 64bit __ktime_get_real_seconds
      timekeeping: Provide internal function __ktime_get_real_seconds
      clocksource/drivers/h8300: Use ioread / iowrite
      clocksource/drivers/h8300: Initializer cleanup.
      clocksource/drivers/h8300: Simplify delta handling
      clocksource/drivers/h8300: Fix timer not overflow case
      clocksource/drivers/h8300: Change to overflow interrupt
      clocksource/drivers/lpc32: Correct pr_err() output format
      clocksource/drivers/arm_global_timer: Fix suspend resume
      clocksource/drivers/pistachio: Fix wrong calculated clocksource read value
      clockevents/drivers/arm_global_timer: Use writel_relaxed in gt_compare_set
      clocksource/drivers/dw_apb_timer: Inline apbt_readl and apbt_writel
      clocksource/drivers/dw_apb_timer: Use {readl|writel}_relaxed in critical path
      clocksource/drivers/dw_apb_timer: Fix apbt_readl return types
      clocksource/drivers/tango-xtal: Replace code by clocksource_mmio_init
      clocksource/drivers/h8300: Increase the compilation test coverage
      ...
    
    * 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      posix-clock: Fix return code on the poll method's error path

commit b850ae14278dfc49c3a03b39357214fc79330db9
Author: Filipe Manana <fdmanana@suse.com>
Date:   Tue Dec 8 16:23:16 2015 +0000

    Btrfs: fix deadlock between direct IO write and defrag/readpages
    
    If readpages() (triggered by defrag or buffered reads) is called while a
    direct IO write is in progress, we have a small time window where we can
    deadlock, resulting in traces like the following being generated:
    
    [84723.212993] INFO: task fio:2849 blocked for more than 120 seconds.
    [84723.214310]       Tainted: G        W       4.3.0-rc5-btrfs-next-17+ #1
    [84723.215640] "echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
    [84723.217313] fio        D ffff88023ec75218     0  2849   2835 0x00000000
    [84723.218778]  ffff880122dfb6e8 0000000000000092 0000000000000000 ffff88023ec75200
    [84723.220458]  ffff88000e05d2c0 ffff880122dfc000 ffff88023ec75200 7fffffffffffffff
    [84723.230597]  0000000000000002 ffffffff8147891a ffff880122dfb700 ffffffff8147856a
    [84723.232085] Call Trace:
    [84723.232625]  [<ffffffff8147891a>] ? bit_wait+0x3c/0x3c
    [84723.233529]  [<ffffffff8147856a>] schedule+0x7d/0x95
    [84723.234398]  [<ffffffff8147baa3>] schedule_timeout+0x43/0x10b
    [84723.235384]  [<ffffffff810f82eb>] ? time_hardirqs_on+0x15/0x28
    [84723.236426]  [<ffffffff8108a23d>] ? trace_hardirqs_on+0xd/0xf
    [84723.237502]  [<ffffffff810af8a3>] ? read_seqcount_begin.constprop.20+0x57/0x6d
    [84723.238807]  [<ffffffff8108a09b>] ? trace_hardirqs_on_caller+0x16/0x1ab
    [84723.242012]  [<ffffffff8108a23d>] ? trace_hardirqs_on+0xd/0xf
    [84723.243064]  [<ffffffff810af2ad>] ? timekeeping_get_ns+0xe/0x33
    [84723.244116]  [<ffffffff810afa2e>] ? ktime_get+0x41/0x52
    [84723.245029]  [<ffffffff81477cff>] io_schedule_timeout+0xb7/0x12b
    [84723.245942]  [<ffffffff81477cff>] ? io_schedule_timeout+0xb7/0x12b
    [84723.246596]  [<ffffffff81478953>] bit_wait_io+0x39/0x45
    [84723.247503]  [<ffffffff81478b93>] __wait_on_bit_lock+0x49/0x8d
    [84723.248540]  [<ffffffff8111684f>] __lock_page+0x66/0x68
    [84723.249558]  [<ffffffff81081c9b>] ? autoremove_wake_function+0x3a/0x3a
    [84723.250844]  [<ffffffff81124a04>] lock_page+0x2c/0x2f
    [84723.251871]  [<ffffffff81124afc>] invalidate_inode_pages2_range+0xf5/0x2aa
    [84723.253274]  [<ffffffff81117c34>] ? filemap_fdatawait_range+0x12d/0x146
    [84723.254757]  [<ffffffff81118191>] ? filemap_fdatawrite_range+0x13/0x15
    [84723.256378]  [<ffffffffa05139a2>] btrfs_get_blocks_direct+0x1b0/0x664 [btrfs]
    [84723.258556]  [<ffffffff8119e3f9>] ? submit_page_section+0x7b/0x111
    [84723.260064]  [<ffffffff8119eb90>] do_blockdev_direct_IO+0x658/0xbdb
    [84723.261479]  [<ffffffffa05137f2>] ? btrfs_page_exists_in_range+0x1a9/0x1a9 [btrfs]
    [84723.262961]  [<ffffffffa050a8a6>] ? btrfs_writepage_start_hook+0xce/0xce [btrfs]
    [84723.264449]  [<ffffffff8119f144>] __blockdev_direct_IO+0x31/0x33
    [84723.265614]  [<ffffffff8119f144>] ? __blockdev_direct_IO+0x31/0x33
    [84723.266769]  [<ffffffffa050a8a6>] ? btrfs_writepage_start_hook+0xce/0xce [btrfs]
    [84723.268264]  [<ffffffffa050935d>] btrfs_direct_IO+0x1b9/0x259 [btrfs]
    [84723.270954]  [<ffffffffa050a8a6>] ? btrfs_writepage_start_hook+0xce/0xce [btrfs]
    [84723.272465]  [<ffffffff8111878c>] generic_file_direct_write+0xb3/0x128
    [84723.273734]  [<ffffffffa051955c>] btrfs_file_write_iter+0x228/0x404 [btrfs]
    [84723.275101]  [<ffffffff8116ca6f>] __vfs_write+0x7c/0xa5
    [84723.276200]  [<ffffffff8116cfab>] vfs_write+0xa0/0xe4
    [84723.277298]  [<ffffffff8116d79d>] SyS_write+0x50/0x7e
    [84723.278327]  [<ffffffff8147cd97>] entry_SYSCALL_64_fastpath+0x12/0x6f
    [84723.279595] INFO: lockdep is turned off.
    [84723.379035] INFO: task btrfs:2923 blocked for more than 120 seconds.
    [84723.380323]       Tainted: G        W       4.3.0-rc5-btrfs-next-17+ #1
    [84723.381608] "echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
    [84723.383003] btrfs           D ffff88023ed75218     0  2923   2859 0x00000000
    [84723.384277]  ffff88001311f860 0000000000000082 ffff88001311f840 ffff88023ed75200
    [84723.385748]  ffff88012c6751c0 ffff880013120000 ffff88012042fe68 ffff88012042fe30
    [84723.387152]  ffff880221571c88 0000000000000001 ffff88001311f878 ffffffff8147856a
    [84723.388620] Call Trace:
    [84723.389105]  [<ffffffff8147856a>] schedule+0x7d/0x95
    [84723.391882]  [<ffffffffa051da32>] btrfs_start_ordered_extent+0x161/0x1fa [btrfs]
    [84723.393718]  [<ffffffff81081c61>] ? signal_pending_state+0x31/0x31
    [84723.395659]  [<ffffffffa0522c5b>] __do_contiguous_readpages.constprop.21+0x81/0xdc [btrfs]
    [84723.397383]  [<ffffffffa050ac96>] ? btrfs_submit_direct+0x3f0/0x3f0 [btrfs]
    [84723.398852]  [<ffffffffa0522da3>] __extent_readpages.constprop.20+0xed/0x100 [btrfs]
    [84723.400561]  [<ffffffff81123f6c>] ? __lru_cache_add+0x5d/0x72
    [84723.401787]  [<ffffffffa0523896>] extent_readpages+0x111/0x1a7 [btrfs]
    [84723.403121]  [<ffffffffa050ac96>] ? btrfs_submit_direct+0x3f0/0x3f0 [btrfs]
    [84723.404583]  [<ffffffffa05088fa>] btrfs_readpages+0x1f/0x21 [btrfs]
    [84723.406007]  [<ffffffff811226df>] __do_page_cache_readahead+0x168/0x1f4
    [84723.407502]  [<ffffffff81122988>] ondemand_readahead+0x21d/0x22e
    [84723.408937]  [<ffffffff81122988>] ? ondemand_readahead+0x21d/0x22e
    [84723.410487]  [<ffffffff81122af1>] page_cache_sync_readahead+0x3d/0x3f
    [84723.411710]  [<ffffffffa0535388>] btrfs_defrag_file+0x419/0xaaf [btrfs]
    [84723.413007]  [<ffffffffa0531db0>] ? kzalloc+0xf/0x11 [btrfs]
    [84723.414085]  [<ffffffffa0535b43>] btrfs_ioctl_defrag+0x125/0x14e [btrfs]
    [84723.415307]  [<ffffffffa0536753>] btrfs_ioctl+0x746/0x24c6 [btrfs]
    [84723.416532]  [<ffffffff81087481>] ? arch_local_irq_save+0x9/0xc
    [84723.417731]  [<ffffffff8113ad61>] ? __might_fault+0x4c/0xa7
    [84723.418699]  [<ffffffff8113ad61>] ? __might_fault+0x4c/0xa7
    [84723.421532]  [<ffffffff8113adba>] ? __might_fault+0xa5/0xa7
    [84723.422629]  [<ffffffff81171139>] ? cp_new_stat+0x15d/0x174
    [84723.423712]  [<ffffffff8117c610>] do_vfs_ioctl+0x427/0x4e6
    [84723.424801]  [<ffffffff81171175>] ? SYSC_newfstat+0x25/0x2e
    [84723.425968]  [<ffffffff8118574d>] ? __fget_light+0x4d/0x71
    [84723.427063]  [<ffffffff8117c726>] SyS_ioctl+0x57/0x79
    [84723.428138]  [<ffffffff8147cd97>] entry_SYSCALL_64_fastpath+0x12/0x6f
    
    Consider the following logical and physical file layout:
    
    logical:    ... [ prealloc extent A ] [ prealloc extent B ] [ extent C ] ...
                    4K                    8K                    16K
    
    physical:   ... 12853248              12857344              1103101952   ...
                                          (= 12853248 + 4K)
    
    Extents A and B are physically adjacent. The following diagram shows a
    sequence of events that lead to the deadlock when we attempt to do a
    direct IO write against the file range [4K, 16K[ and a defrag is triggered
    simultaneously.
    
               CPU 1                                               CPU 2
    
     btrfs_direct_IO()
    
       btrfs_get_blocks_direct()
         creates ordered extent A, covering
         the 4k prealloc extent A (range [4K, 8K[)
    
                                                        btrfs_defrag_file()
                                                          page_cache_sync_readahead([0K, 1M[)
                                                            btrfs_readpages()
                                                              extent_readpages()
    
                                                                locks all pages in the file
                                                                range [0K, 128K[ through calls
                                                                to add_to_page_cache_lru()
    
                                                                __do_contiguous_readpages()
    
                                                                   finds ordered extent A
    
                                                                   waits for it to complete
    
       btrfs_get_blocks_direct() called again
    
         lock_extent_direct(range [8K, 16K[)
    
           finds a page in range [8K, 16K[ through
           btrfs_page_exists_in_range()
    
           invalidate_inode_pages2_range([8K, 16K[)
    
             --> tries to lock pages that are already
                 locked by the task at CPU 2
    
             --> our task, running __blockdev_direct_IO(),
                 hangs waiting to lock the pages and the
                 submit bio callback, btrfs_submit_direct(),
                 ends up never being called, resulting in the
                 ordered extent A never completing (because a
                 corresponding bio is never submitted) and
                 CPU 2 will wait for it forever while holding
                 the pages locked
                  ---> deadlock!
    
    Fix this by removing the page invalidation approach when attempting to
    lock the range for IO from the callback btrfs_get_blocks_direct() and
    falling back buffered IO. This was a rare case anyway and well behaved
    applications do not mix concurrent direct IO writes with buffered reads
    anyway, being a concurrent defrag the only normal case that could lead
    to the deadlock.
    
    Signed-off-by: Filipe Manana <fdmanana@suse.com>

commit ec02b076ceab63f99e5b3d80fd223d777266c236
Author: John Stultz <john.stultz@linaro.org>
Date:   Thu Dec 3 10:23:30 2015 -0800

    timekeeping: Cap adjustments so they don't exceed the maxadj value
    
    Thus its been occasionally noted that users have seen
    confusing warnings like:
    
        Adjusting tsc more than 11% (5941981 vs 7759439)
    
    We try to limit the maximum total adjustment to 11% (10% tick
    adjustment + 0.5% frequency adjustment). But this is done by
    bounding the requested adjustment values, and the internal
    steering that is done by tracking the error from what was
    requested and what was applied, does not have any such limits.
    
    This is usually not problematic, but in some cases has a risk
    that an adjustment could cause the clocksource mult value to
    overflow, so its an indication things are outside of what is
    expected.
    
    It ends up most of the reports of this 11% warning are on systems
    using chrony, which utilizes the adjtimex() ADJ_TICK interface
    (which allows a +-10% adjustment). The original rational for
    ADJ_TICK unclear to me but my assumption it was originally added
    to allow broken systems to get a big constant correction at boot
    (see adjtimex userspace package for an example) which would allow
    the system to work w/ ntpd's 0.5% adjustment limit.
    
    Chrony uses ADJ_TICK to make very aggressive short term corrections
    (usually right at startup). Which push us close enough to the max
    bound that a few late ticks can cause the internal steering to push
    past the max adjust value (tripping the warning).
    
    Thus this patch adds some extra logic to enforce the max adjustment
    cap in the internal steering.
    
    Note: This has the potential to slow corrections when the ADJ_TICK
    value is furthest away from the default value. So it would be good to
    get some testing from folks using chrony, to make sure we don't
    cause any troubles there.
    
    Cc: Miroslav Lichvar <mlichvar@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Tested-by: Miroslav Lichvar <mlichvar@redhat.com>
    Reported-by: Andy Lutomirski <luto@kernel.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit dee3665416a8553279d10b62b5e62685cbe5daa8
Author: DengChao <chao.deng@linaro.org>
Date:   Sun Dec 13 12:24:18 2015 +0800

    timekeeping: Provide internal function __ktime_get_real_seconds
    
    In order to fix Y2038 issues in the ntp code we will need replace
    get_seconds() with ktime_get_real_seconds() but as the ntp code uses
    the timekeeping lock which is also used by ktime_get_real_seconds(),
    we need a version without locking.
    Add a new function __ktime_get_real_seconds() in timekeeping to
    do this.
    
    Reviewed-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: DengChao <chao.deng@linaro.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 35a4933a895927990772ae96fdcfd2f806929ee2
Author: David Gibson <david@gibson.dropbear.id.au>
Date:   Mon Nov 30 12:30:30 2015 +1100

    time: Avoid signed overflow in timekeeping_get_ns()
    
    1e75fa8 "time: Condense timekeeper.xtime into xtime_sec" replaced a call to
    clocksource_cyc2ns() from timekeeping_get_ns() with an open-coded version
    of the same logic to avoid keeping a semi-redundant struct timespec
    in struct timekeeper.
    
    However, the commit also introduced a subtle semantic change - where
    clocksource_cyc2ns() uses purely unsigned math, the new version introduces
    a signed temporary, meaning that if (delta * tk->mult) has a 63-bit
    overflow the following shift will still give a negative result.  The
    choice of 'maxsec' in __clocksource_updatefreq_scale() means this will
    generally happen if there's a ~10 minute pause in examining the
    clocksource.
    
    This can be triggered on a powerpc KVM guest by stopping it from qemu for
    a bit over 10 minutes.  After resuming time has jumped backwards several
    minutes causing numerous problems (jiffies does not advance, msleep()s can
    be extended by minutes..).  It doesn't happen on x86 KVM guests, because
    the guest TSC is effectively frozen while the guest is stopped, which is
    not the case for the powerpc timebase.
    
    Obviously an unsigned (64 bit) overflow will only take twice as long as a
    signed, 63-bit overflow.  I don't know the time code well enough to know
    if that will still cause incorrect calculations, or if a 64-bit overflow
    is avoided elsewhere.
    
    Still, an incorrect forwards clock adjustment will cause less trouble than
    time going backwards.  So, this patch removes the potential for
    intermediate signed overflow.
    
    Cc: stable@vger.kernel.org  (3.7+)
    Suggested-by: Laurent Vivier <lvivier@redhat.com>
    Tested-by: Laurent Vivier <lvivier@redhat.com>
    Signed-off-by: David Gibson <david@gibson.dropbear.id.au>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit f3d885ccba8539f62e8be3ba29ecf91687120252
Author: Anton Blanchard <anton@samba.org>
Date:   Thu Oct 29 11:44:10 2015 +1100

    powerpc: Rearrange __switch_to()
    
    Most of __switch_to() is housekeeping, TLB batching, timekeeping etc.
    Move these away from the more complex and critical context switching
    code.
    
    Signed-off-by: Anton Blanchard <anton@samba.org>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

commit 8ab0f723af247af8dd92196c152c8f1da0254b2f
Author: Tina Ruchandani <ruchandani.tina@gmail.com>
Date:   Thu Oct 29 22:44:31 2015 -0700

    USB: usbmon: Use 64bit timestamp for mon_bin_hdr
    
    struct mon_bin_hdr allows for a 64-bit seconds timestamp. The code
    currently uses 'struct timeval' to populate the timestamp in mon_bin_hdr,
    which has a 32-bit seconds field and will overflow in year 2038 and beyond.
    This patch replaces 'struct timeval' with 'struct timespec64' which is
    y2038 safe. This patch is part of a larger attempt to remove instances
    of struct timeval and other 32-bit timekeeping (time_t, struct timespec)
    from the kernel.
    
    Signed-off-by: Tina Ruchandani <ruchandani.tina@gmail.com>
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit ec4dca8bdfb650fd698401e26f586683ec69a942
Author: Tina Ruchandani <ruchandani.tina@gmail.com>
Date:   Thu Oct 29 22:58:28 2015 -0700

    USB: usbmon: Remove timeval usage for timestamp
    
    struct timeval' uses 32-bits for its seconds field and will overflow in
    the year 2038 and beyond. This patch replaces the usage of 'struct timeval'
    in mon_get_timestamp() with timespec64 which uses a 64-bit seconds field
    and is y2038-safe. mon_get_timestamp() truncates the timestamp at 4096 seconds,
    so the correctness of the code is not affected. This patch is part of a larger
    attempt to remove instances of struct timeval and other 32-bit timekeeping
    (time_t, struct timespec) from the kernel.
    
    Signed-off-by: Tina Ruchandani <ruchandani.tina@gmail.com>
    Suggested-by: Arnd Bergmann <arnd@arndb.de>
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 09a9982016499daeb3fbee5ac8d87797310a565a
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Nov 19 11:43:09 2015 +0100

    timekeeping: Lift clocksource cacheline restriction
    
    We cache all hotpath members of a clocksource in the time keeper
    core. So there is no requirement in general to cache line align struct
    clocksource. Remove the enforces alignment.
    
    That allows users which need to wrap struct clocksource into their own
    struct to align the struct without getting extra padding.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Russell King - ARM Linux <linux@arm.linux.org.uk>
    Cc: Marc Gonzalez <marc_gonzalez@sigmadesigns.com>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: Mans Rullgard <mans@mansr.com>
    Cc: Viresh Kumar <viresh.kumar@linaro.org>
    Cc: Nicolas Pitre <nico@linaro.org>
    Cc: Tony Lindgren <tony@atomide.com>
    Cc: Sebastian Frias <sebastian_frias@sigmadesigns.com>
    Link: http://lkml.kernel.org/r/alpine.DEB.2.11.1511191209000.3898@nanos

commit 34db37c63a08b8f06f8ff15c5c301a26635ddf25
Author: John Stultz <john.stultz@linaro.org>
Date:   Fri Nov 13 13:07:31 2015 -0800

    MAINTAINERS: Add entry for kernel/time/alarmtimer.c
    
    I've been missing patches against alarmtimer.c due to
    a lack of a proper entry for it in the MAINTAINERS file.
    
    So update MAINTAINERS to fix this, adding it in with the
    timekeeping, ntp and core clocksource logic I share with
    Thomas.
    
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit c8299cb605b27dd5a49f7a69e48fd23e5a206298
Author: Michal Nazarewicz <mina86@mina86.com>
Date:   Mon Nov 9 14:58:10 2015 -0800

    kernel.h: make abs() work with 64-bit types
    
    For 64-bit arguments, the abs macro casts it to an int which leads to
    lost precision and may cause incorrect results.  To deal with 64-bit
    types abs64 macro has been introduced but still there are places where
    abs macro is used incorrectly.
    
    To deal with the problem, expand abs macro such that it operates on s64
    type when dealing with 64-bit types while still returning long when
    dealing with smaller types.
    
    This fixes one known bug (per John):
    
    The internal clocksteering done for fine-grained error correction uses a
    : logarithmic approximation, so any time adjtimex() adjusts the clock
    : steering, timekeeping_freqadjust() quickly approximates the correct clock
    : frequency over a series of ticks.
    :
    : Unfortunately, the logic in timekeeping_freqadjust(), introduced in commit
    : dc491596f639438 (Rework frequency adjustments to work better w/ nohz),
    : used the abs() function with a s64 error value to calculate the size of
    : the approximated adjustment to be made.
    :
    : Per include/linux/kernel.h: "abs() should not be used for 64-bit types
    : (s64, u64, long long) - use abs64()".
    :
    : Thus on 32-bit platforms, this resulted in the clocksteering to take a
    : quite dampended random walk trying to converge on the proper frequency,
    : which caused the adjustments to be made much slower then intended (most
    : easily observed when large adjustments are made).
    
    Signed-off-by: Michal Nazarewicz <mina86@mina86.com>
    Reported-by: John Stultz <john.stultz@linaro.org>
    Tested-by: John Stultz <john.stultz@linaro.org>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit 1032a6687168af9509615879d513f77e4049062e
Author: Tina Ruchandani <ruchandani.tina@gmail.com>
Date:   Fri Oct 30 01:24:56 2015 -0700

    Use 64-bit timekeeping
    
    This patch changes the use of struct timespec in
    dccp_probe to use struct timespec64 instead. timespec uses a 32-bit
    seconds field which will overflow in the year 2038 and beyond. timespec64
    uses a 64-bit seconds field. Note that the correctness of the code isn't
    changed, since the original code only uses the timestamps to compute a
    small elapsed interval. This patch is part of a larger attempt to remove
    instances of 32-bit timekeeping structures (timespec, timeval, time_t)
    from the kernel so it is easier to identify where the real 2038 issues
    are.
    
    Signed-off-by: Tina Ruchandani <ruchandani.tina@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 6ea48cdcf3c9054b03d2607ead2740d7a0376fa4
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Wed Sep 16 14:10:03 2015 +0100

    x86/platform: Fix Geode LX timekeeping in the generic x86 build
    
    [ Upstream commit 03da3ff1cfcd7774c8780d2547ba0d995f7dc03d ]
    
    In 2007, commit 07190a08eef36 ("Mark TSC on GeodeLX reliable")
    bypassed verification of the TSC on Geode LX. However, this code
    (now in the check_system_tsc_reliable() function in
    arch/x86/kernel/tsc.c) was only present if CONFIG_MGEODE_LX was
    set.
    
    OpenWRT has recently started building its generic Geode target
    for Geode GX, not LX, to include support for additional
    platforms. This broke the timekeeping on LX-based devices,
    because the TSC wasn't marked as reliable:
    https://dev.openwrt.org/ticket/20531
    
    By adding a runtime check on is_geode_lx(), we can also include
    the fix if CONFIG_MGEODEGX1 or CONFIG_X86_GENERIC are set, thus
    fixing the problem.
    
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>
    Cc: Andres Salomon <dilinger@queued.net>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Marcelo Tosatti <marcelo@kvack.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org
    Link: http://lkml.kernel.org/r/1442409003.131189.87.camel@infradead.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Sasha Levin <sasha.levin@oracle.com>

commit 1dbcfc2dcd84d2b2781fb8611fb4bcd3792c32ae
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Sep 9 16:07:30 2015 -0700

    time: Fix timekeeping_freqadjust()'s incorrect use of abs() instead of abs64()
    
    [ Upstream commit 2619d7e9c92d524cb155ec89fd72875321512e5b ]
    
    The internal clocksteering done for fine-grained error
    correction uses a logarithmic approximation, so any time
    adjtimex() adjusts the clock steering, timekeeping_freqadjust()
    quickly approximates the correct clock frequency over a series
    of ticks.
    
    Unfortunately, the logic in timekeeping_freqadjust(), introduced
    in commit:
    
      dc491596f639 ("timekeeping: Rework frequency adjustments to work better w/ nohz")
    
    used the abs() function with a s64 error value to calculate the
    size of the approximated adjustment to be made.
    
    Per include/linux/kernel.h:
    
      "abs() should not be used for 64-bit types (s64, u64, long long) - use abs64()".
    
    Thus on 32-bit platforms, this resulted in the clocksteering to
    take a quite dampended random walk trying to converge on the
    proper frequency, which caused the adjustments to be made much
    slower then intended (most easily observed when large
    adjustments are made).
    
    This patch fixes the issue by using abs64() instead.
    
    Reported-by: Nuno Gonçalves <nunojpg@gmail.com>
    Tested-by: Nuno Goncalves <nunojpg@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: <stable@vger.kernel.org> # v3.17+
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Miroslav Lichvar <mlichvar@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/1441840051-20244-1-git-send-email-john.stultz@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Sasha Levin <sasha.levin@oracle.com>

commit 007b921d513e330e0b1fe15099c6189ed6e44934
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Wed Sep 16 14:10:03 2015 +0100

    x86/platform: Fix Geode LX timekeeping in the generic x86 build
    
    commit 03da3ff1cfcd7774c8780d2547ba0d995f7dc03d upstream.
    
    In 2007, commit 07190a08eef36 ("Mark TSC on GeodeLX reliable")
    bypassed verification of the TSC on Geode LX. However, this code
    (now in the check_system_tsc_reliable() function in
    arch/x86/kernel/tsc.c) was only present if CONFIG_MGEODE_LX was
    set.
    
    OpenWRT has recently started building its generic Geode target
    for Geode GX, not LX, to include support for additional
    platforms. This broke the timekeeping on LX-based devices,
    because the TSC wasn't marked as reliable:
    https://dev.openwrt.org/ticket/20531
    
    By adding a runtime check on is_geode_lx(), we can also include
    the fix if CONFIG_MGEODEGX1 or CONFIG_X86_GENERIC are set, thus
    fixing the problem.
    
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>
    Cc: Andres Salomon <dilinger@queued.net>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Marcelo Tosatti <marcelo@kvack.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/1442409003.131189.87.camel@infradead.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>

commit 31a07f6dc6f16fafab8bebd673e653299bd03c93
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Oct 16 15:50:22 2015 +0200

    timekeeping: Increment clock_was_set_seq in timekeeping_init()
    
    commit 56fd16cabac9cd8f15e2902898a9d0cc96e2fa70 upstream.
    
    timekeeping_init() can set the wall time offset, so we need to
    increment the clock_was_set_seq counter. That way hrtimers will pick
    up the early offset immediately. Otherwise on a machine which does not
    set wall time later in the boot process the hrtimer offset is stale at
    0 and wall time timers are going to expire with a delay of 45 years.
    
    Fixes: 868a3e915f7f "hrtimer: Make offset update smarter"
    Reported-and-tested-by: Heiko Carstens <heiko.carstens@de.ibm.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Stefan Liebler <stli@linux.vnet.ibm.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit c8a7318666fca5573199d5e06ec1d779671caf07
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Wed Sep 16 14:10:03 2015 +0100

    x86/platform: Fix Geode LX timekeeping in the generic x86 build
    
    commit 03da3ff1cfcd7774c8780d2547ba0d995f7dc03d upstream.
    
    In 2007, commit 07190a08eef36 ("Mark TSC on GeodeLX reliable")
    bypassed verification of the TSC on Geode LX. However, this code
    (now in the check_system_tsc_reliable() function in
    arch/x86/kernel/tsc.c) was only present if CONFIG_MGEODE_LX was
    set.
    
    OpenWRT has recently started building its generic Geode target
    for Geode GX, not LX, to include support for additional
    platforms. This broke the timekeeping on LX-based devices,
    because the TSC wasn't marked as reliable:
    https://dev.openwrt.org/ticket/20531
    
    By adding a runtime check on is_geode_lx(), we can also include
    the fix if CONFIG_MGEODEGX1 or CONFIG_X86_GENERIC are set, thus
    fixing the problem.
    
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>
    Cc: Andres Salomon <dilinger@queued.net>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Marcelo Tosatti <marcelo@kvack.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/1442409003.131189.87.camel@infradead.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit d6402e4ecf0d9a3ec9ceee9d218dcc7605611df7
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Sep 9 16:07:30 2015 -0700

    time: Fix timekeeping_freqadjust()'s incorrect use of abs() instead of abs64()
    
    commit 2619d7e9c92d524cb155ec89fd72875321512e5b upstream.
    
    The internal clocksteering done for fine-grained error
    correction uses a logarithmic approximation, so any time
    adjtimex() adjusts the clock steering, timekeeping_freqadjust()
    quickly approximates the correct clock frequency over a series
    of ticks.
    
    Unfortunately, the logic in timekeeping_freqadjust(), introduced
    in commit:
    
      dc491596f639 ("timekeeping: Rework frequency adjustments to work better w/ nohz")
    
    used the abs() function with a s64 error value to calculate the
    size of the approximated adjustment to be made.
    
    Per include/linux/kernel.h:
    
      "abs() should not be used for 64-bit types (s64, u64, long long) - use abs64()".
    
    Thus on 32-bit platforms, this resulted in the clocksteering to
    take a quite dampended random walk trying to converge on the
    proper frequency, which caused the adjustments to be made much
    slower then intended (most easily observed when large
    adjustments are made).
    
    This patch fixes the issue by using abs64() instead.
    
    Reported-by: Nuno Gonçalves <nunojpg@gmail.com>
    Tested-by: Nuno Goncalves <nunojpg@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Miroslav Lichvar <mlichvar@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/1441840051-20244-1-git-send-email-john.stultz@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit e6491ecad829ef7e49a8a7cf3eb4b8189d926efa
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Wed Sep 16 14:10:03 2015 +0100

    x86/platform: Fix Geode LX timekeeping in the generic x86 build
    
    commit 03da3ff1cfcd7774c8780d2547ba0d995f7dc03d upstream.
    
    In 2007, commit 07190a08eef36 ("Mark TSC on GeodeLX reliable")
    bypassed verification of the TSC on Geode LX. However, this code
    (now in the check_system_tsc_reliable() function in
    arch/x86/kernel/tsc.c) was only present if CONFIG_MGEODE_LX was
    set.
    
    OpenWRT has recently started building its generic Geode target
    for Geode GX, not LX, to include support for additional
    platforms. This broke the timekeeping on LX-based devices,
    because the TSC wasn't marked as reliable:
    https://dev.openwrt.org/ticket/20531
    
    By adding a runtime check on is_geode_lx(), we can also include
    the fix if CONFIG_MGEODEGX1 or CONFIG_X86_GENERIC are set, thus
    fixing the problem.
    
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>
    Cc: Andres Salomon <dilinger@queued.net>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Marcelo Tosatti <marcelo@kvack.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/1442409003.131189.87.camel@infradead.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit a5428d82f04e051e9c0d1da2b353c21be01600c7
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Sep 9 16:07:30 2015 -0700

    time: Fix timekeeping_freqadjust()'s incorrect use of abs() instead of abs64()
    
    commit 2619d7e9c92d524cb155ec89fd72875321512e5b upstream.
    
    The internal clocksteering done for fine-grained error
    correction uses a logarithmic approximation, so any time
    adjtimex() adjusts the clock steering, timekeeping_freqadjust()
    quickly approximates the correct clock frequency over a series
    of ticks.
    
    Unfortunately, the logic in timekeeping_freqadjust(), introduced
    in commit:
    
      dc491596f639 ("timekeeping: Rework frequency adjustments to work better w/ nohz")
    
    used the abs() function with a s64 error value to calculate the
    size of the approximated adjustment to be made.
    
    Per include/linux/kernel.h:
    
      "abs() should not be used for 64-bit types (s64, u64, long long) - use abs64()".
    
    Thus on 32-bit platforms, this resulted in the clocksteering to
    take a quite dampended random walk trying to converge on the
    proper frequency, which caused the adjustments to be made much
    slower then intended (most easily observed when large
    adjustments are made).
    
    This patch fixes the issue by using abs64() instead.
    
    Reported-by: Nuno Gonçalves <nunojpg@gmail.com>
    Tested-by: Nuno Goncalves <nunojpg@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Miroslav Lichvar <mlichvar@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/1441840051-20244-1-git-send-email-john.stultz@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 34b561d0f90812f8869d2f958b247a6dd75b72f8
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Wed Sep 16 14:10:03 2015 +0100

    x86/platform: Fix Geode LX timekeeping in the generic x86 build
    
    commit 03da3ff1cfcd7774c8780d2547ba0d995f7dc03d upstream.
    
    In 2007, commit 07190a08eef36 ("Mark TSC on GeodeLX reliable")
    bypassed verification of the TSC on Geode LX. However, this code
    (now in the check_system_tsc_reliable() function in
    arch/x86/kernel/tsc.c) was only present if CONFIG_MGEODE_LX was
    set.
    
    OpenWRT has recently started building its generic Geode target
    for Geode GX, not LX, to include support for additional
    platforms. This broke the timekeeping on LX-based devices,
    because the TSC wasn't marked as reliable:
    https://dev.openwrt.org/ticket/20531
    
    By adding a runtime check on is_geode_lx(), we can also include
    the fix if CONFIG_MGEODEGX1 or CONFIG_X86_GENERIC are set, thus
    fixing the problem.
    
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>
    Cc: Andres Salomon <dilinger@queued.net>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Marcelo Tosatti <marcelo@kvack.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/1442409003.131189.87.camel@infradead.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 9870892fc277debf23fd5f6bef2fef5ae77b97fb
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Wed Sep 16 14:10:03 2015 +0100

    x86/platform: Fix Geode LX timekeeping in the generic x86 build
    
    commit 03da3ff1cfcd7774c8780d2547ba0d995f7dc03d upstream.
    
    In 2007, commit 07190a08eef36 ("Mark TSC on GeodeLX reliable")
    bypassed verification of the TSC on Geode LX. However, this code
    (now in the check_system_tsc_reliable() function in
    arch/x86/kernel/tsc.c) was only present if CONFIG_MGEODE_LX was
    set.
    
    OpenWRT has recently started building its generic Geode target
    for Geode GX, not LX, to include support for additional
    platforms. This broke the timekeeping on LX-based devices,
    because the TSC wasn't marked as reliable:
    https://dev.openwrt.org/ticket/20531
    
    By adding a runtime check on is_geode_lx(), we can also include
    the fix if CONFIG_MGEODEGX1 or CONFIG_X86_GENERIC are set, thus
    fixing the problem.
    
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>
    Cc: Andres Salomon <dilinger@queued.net>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Marcelo Tosatti <marcelo@kvack.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/1442409003.131189.87.camel@infradead.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 81429a6dbcbf3a01830de42dbdf0d9acbe68e1c1
Merge: 16c8b9cb2464 0701c53e460e 56fd16cabac9
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Oct 17 08:47:27 2015 -0700

    Merge branches 'irq-urgent-for-linus' and 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull irq/timer fixes from Thomas Gleixner:
     "irq: a fix for the new hierarchical MSI interrupt handling which
      unbreaks PCI=n configurations.
    
      timers: a fix for the new hrtimer clock offset update mechanism to
      ensure that the boot time offset is respected"
    
    * 'irq-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      genirq/msi: Do not use pci_msi_[un]mask_irq as default methods
    
    * 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      timekeeping: Increment clock_was_set_seq in timekeeping_init()

commit 56fd16cabac9cd8f15e2902898a9d0cc96e2fa70
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Oct 16 15:50:22 2015 +0200

    timekeeping: Increment clock_was_set_seq in timekeeping_init()
    
    timekeeping_init() can set the wall time offset, so we need to
    increment the clock_was_set_seq counter. That way hrtimers will pick
    up the early offset immediately. Otherwise on a machine which does not
    set wall time later in the boot process the hrtimer offset is stale at
    0 and wall time timers are going to expire with a delay of 45 years.
    
    Fixes: 868a3e915f7f "hrtimer: Make offset update smarter"
    Reported-and-tested-by: Heiko Carstens <heiko.carstens@de.ibm.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Stefan Liebler <stli@linux.vnet.ibm.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: John Stultz <john.stultz@linaro.org>

commit d8e332d409c06a68412c7d9a6f4c582249f2e9ff
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Wed Sep 16 14:10:03 2015 +0100

    x86/platform: Fix Geode LX timekeeping in the generic x86 build
    
    commit 03da3ff1cfcd7774c8780d2547ba0d995f7dc03d upstream.
    
    In 2007, commit 07190a08eef36 ("Mark TSC on GeodeLX reliable")
    bypassed verification of the TSC on Geode LX. However, this code
    (now in the check_system_tsc_reliable() function in
    arch/x86/kernel/tsc.c) was only present if CONFIG_MGEODE_LX was
    set.
    
    OpenWRT has recently started building its generic Geode target
    for Geode GX, not LX, to include support for additional
    platforms. This broke the timekeeping on LX-based devices,
    because the TSC wasn't marked as reliable:
    https://dev.openwrt.org/ticket/20531
    
    By adding a runtime check on is_geode_lx(), we can also include
    the fix if CONFIG_MGEODEGX1 or CONFIG_X86_GENERIC are set, thus
    fixing the problem.
    
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>
    Cc: Andres Salomon <dilinger@queued.net>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Marcelo Tosatti <marcelo@kvack.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/1442409003.131189.87.camel@infradead.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit 6035519fcf5aa17084b41790cdc584d881d82c03
Author: John Stultz <john.stultz@linaro.org>
Date:   Mon Oct 5 18:16:57 2015 -0700

    timers, kselftest: Add 'adjtick' test to validate adjtimex() tick adjustments
    
    Recently a kernel side NTP bug was fixed via the following commit:
    
      2619d7e9c92d ("time: Fix timekeeping_freqadjust()'s incorrect use of abs() instead of abs64()")
    
    When the bug was reported it was difficult to detect, except by
    tweaking the adjtimex tick value, and noticing how quickly the
    adjustment took:
    
            https://lkml.org/lkml/2015/9/1/488
    
    Thus this patch introduces a new test which manipulates the
    adjtimex tick value and validates that the results are what we
    expect.
    
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Miroslav Lichvar <mlichvar@redhat.com>
    Cc: Nuno Gonçalves <nunojpg@gmail.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Shuah Khan <shuahkh@osg.samsung.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/1444094217-20258-1-git-send-email-john.stultz@linaro.org
    [ Tidied up the code and the changelog a bit. ]
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 057c427cc27baaf17bed84838827fa6a5ed354f3
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Wed Sep 16 14:10:03 2015 +0100

    x86/platform: Fix Geode LX timekeeping in the generic x86 build
    
    commit 03da3ff1cfcd7774c8780d2547ba0d995f7dc03d upstream.
    
    In 2007, commit 07190a08eef36 ("Mark TSC on GeodeLX reliable")
    bypassed verification of the TSC on Geode LX. However, this code
    (now in the check_system_tsc_reliable() function in
    arch/x86/kernel/tsc.c) was only present if CONFIG_MGEODE_LX was
    set.
    
    OpenWRT has recently started building its generic Geode target
    for Geode GX, not LX, to include support for additional
    platforms. This broke the timekeeping on LX-based devices,
    because the TSC wasn't marked as reliable:
    https://dev.openwrt.org/ticket/20531
    
    By adding a runtime check on is_geode_lx(), we can also include
    the fix if CONFIG_MGEODEGX1 or CONFIG_X86_GENERIC are set, thus
    fixing the problem.
    
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>
    Cc: Andres Salomon <dilinger@queued.net>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Marcelo Tosatti <marcelo@kvack.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/1442409003.131189.87.camel@infradead.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Luis Henriques <luis.henriques@canonical.com>

commit ce2e572cfe7b2fc3f0e9da4aa7bc61a2c2c51fc7
Author: Daniel J Blueman <daniel@numascale.com>
Date:   Mon Sep 21 18:02:25 2015 +0800

    x86/numachip: Introduce Numachip2 timer mechanisms
    
    Add 1GHz 64-bit Numachip2 clocksource timer support for accurate
    system-wide timekeeping, as core TSCs are unsynchronised.
    
    Additionally, add a per-core clockevent mechanism that interrupts via the
    platform IPI vector after a programmed period.
    
    [ tglx: Taking it through x86 due to dependencies ]
    
    Signed-off-by: Daniel J Blueman <daniel@numascale.com>
    Acked-by: Steffen Persvold <sp@numascale.com>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Link: http://lkml.kernel.org/r/1442829745-29311-1-git-send-email-daniel@numascale.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 42dc2a3048247109b0a5ee6345226cbd3e4f6410
Merge: 1345df21ac54 03da3ff1cfcd
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Sep 17 11:01:34 2015 -0700

    Merge branch 'x86-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull x86 fixes from Ingo Molnar:
     - misc fixes all around the map
     - block non-root vm86(old) if mmap_min_addr != 0
     - two small debuggability improvements
     - removal of obsolete paravirt op
    
    * 'x86-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      x86/platform: Fix Geode LX timekeeping in the generic x86 build
      x86/apic: Serialize LVTT and TSC_DEADLINE writes
      x86/ioapic: Force affinity setting in setup_ioapic_dest()
      x86/paravirt: Remove the unused pv_time_ops::get_tsc_khz method
      x86/ldt: Fix small LDT allocation for Xen
      x86/vm86: Fix the misleading CONFIG_VM86 Kconfig help text
      x86/cpu: Print family/model/stepping in hex
      x86/vm86: Block non-root vm86(old) if mmap_min_addr != 0
      x86/alternatives: Make optimize_nops() interrupt safe and synced
      x86/mm/srat: Print non-volatile flag in SRAT
      x86/cpufeatures: Enable cpuid for Intel SHA extensions

commit 1345df21ac542daa9d8613f89a3f0b5f32d636f8
Merge: c2ea72fd8691 eef7635a22f6
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Sep 17 10:55:25 2015 -0700

    Merge branch 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer fixes from Ingo Molnar:
     "A fix for an abs()/abs64() bug that caused too slow NTP convergence on
      32-bit kernels, plus a removal of an obsolete clockevents driver
      facility after all users got converted during the merge window"
    
    * 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      clockevents: Remove unused set_mode() callback
      time: Fix timekeeping_freqadjust()'s incorrect use of abs() instead of abs64()

commit 03da3ff1cfcd7774c8780d2547ba0d995f7dc03d
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Wed Sep 16 14:10:03 2015 +0100

    x86/platform: Fix Geode LX timekeeping in the generic x86 build
    
    In 2007, commit 07190a08eef36 ("Mark TSC on GeodeLX reliable")
    bypassed verification of the TSC on Geode LX. However, this code
    (now in the check_system_tsc_reliable() function in
    arch/x86/kernel/tsc.c) was only present if CONFIG_MGEODE_LX was
    set.
    
    OpenWRT has recently started building its generic Geode target
    for Geode GX, not LX, to include support for additional
    platforms. This broke the timekeeping on LX-based devices,
    because the TSC wasn't marked as reliable:
    https://dev.openwrt.org/ticket/20531
    
    By adding a runtime check on is_geode_lx(), we can also include
    the fix if CONFIG_MGEODEGX1 or CONFIG_X86_GENERIC are set, thus
    fixing the problem.
    
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>
    Cc: Andres Salomon <dilinger@queued.net>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Marcelo Tosatti <marcelo@kvack.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org
    Link: http://lkml.kernel.org/r/1442409003.131189.87.camel@infradead.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 2619d7e9c92d524cb155ec89fd72875321512e5b
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Sep 9 16:07:30 2015 -0700

    time: Fix timekeeping_freqadjust()'s incorrect use of abs() instead of abs64()
    
    The internal clocksteering done for fine-grained error
    correction uses a logarithmic approximation, so any time
    adjtimex() adjusts the clock steering, timekeeping_freqadjust()
    quickly approximates the correct clock frequency over a series
    of ticks.
    
    Unfortunately, the logic in timekeeping_freqadjust(), introduced
    in commit:
    
      dc491596f639 ("timekeeping: Rework frequency adjustments to work better w/ nohz")
    
    used the abs() function with a s64 error value to calculate the
    size of the approximated adjustment to be made.
    
    Per include/linux/kernel.h:
    
      "abs() should not be used for 64-bit types (s64, u64, long long) - use abs64()".
    
    Thus on 32-bit platforms, this resulted in the clocksteering to
    take a quite dampended random walk trying to converge on the
    proper frequency, which caused the adjustments to be made much
    slower then intended (most easily observed when large
    adjustments are made).
    
    This patch fixes the issue by using abs64() instead.
    
    Reported-by: Nuno Gonçalves <nunojpg@gmail.com>
    Tested-by: Nuno Goncalves <nunojpg@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: <stable@vger.kernel.org> # v3.17+
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Miroslav Lichvar <mlichvar@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/1441840051-20244-1-git-send-email-john.stultz@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 44e98edcd11a48619b342d8f442d447b094ab2fc
Merge: 64291f7db5bd 4d283ec908e6
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Aug 31 08:27:44 2015 -0700

    Merge tag 'kvm-4.3-1' of git://git.kernel.org/pub/scm/virt/kvm/kvm
    
    Pull kvm updates from Paolo Bonzini:
     "A very small release for x86 and s390 KVM.
    
       - s390: timekeeping changes, cleanups and fixes
    
       - x86: support for Hyper-V MSRs to report crashes, and a bunch of
         cleanups.
    
      One interesting feature that was planned for 4.3 (emulating the local
      APIC in kernel while keeping the IOAPIC and 8254 in userspace) had to
      be delayed because Intel complained about my reading of the manual"
    
    * tag 'kvm-4.3-1' of git://git.kernel.org/pub/scm/virt/kvm/kvm: (42 commits)
      x86/kvm: Rename VMX's segment access rights defines
      KVM: x86/vPMU: Fix unnecessary signed extension for AMD PERFCTRn
      kvm: x86: Fix error handling in the function kvm_lapic_sync_from_vapic
      KVM: s390: Fix assumption that kvm_set_irq_routing is always run successfully
      KVM: VMX: drop ept misconfig check
      KVM: MMU: fully check zero bits for sptes
      KVM: MMU: introduce is_shadow_zero_bits_set()
      KVM: MMU: introduce the framework to check zero bits on sptes
      KVM: MMU: split reset_rsvds_bits_mask_ept
      KVM: MMU: split reset_rsvds_bits_mask
      KVM: MMU: introduce rsvd_bits_validate
      KVM: MMU: move FNAME(is_rsvd_bits_set) to mmu.c
      KVM: MMU: fix validation of mmio page fault
      KVM: MTRR: Use default type for non-MTRR-covered gfn before WARN_ON
      KVM: s390: host STP toleration for VMs
      KVM: x86: clean/fix memory barriers in irqchip_in_kernel
      KVM: document memory barriers for kvm->vcpus/kvm->online_vcpus
      KVM: x86: remove unnecessary memory barriers for shared MSRs
      KVM: move code related to KVM_SET_BOOT_CPU_ID to x86
      KVM: s390: log capability enablement and vm attribute changes
      ...

commit f9f58191011b986f4a92a792a8328f5c188ea1b3
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Jun 10 01:33:36 2015 +0200

    ACPI / init: Switch over platform to the ACPI mode later
    
    [ Upstream commit cdbbeb69d4b93455a73edff725639216d7fe0b38 ]
    
    commit b064a8fa77dfead647564c46ac8fc5b13bd1ab73 upstream.
    
    Commit 73f7d1ca3263 "ACPI / init: Run acpi_early_init() before
    timekeeping_init()" moved the ACPI subsystem initialization,
    including the ACPI mode enabling, to an earlier point in the
    initialization sequence, to allow the timekeeping subsystem
    use ACPI early.  Unfortunately, that resulted in boot regressions
    on some systems and the early ACPI initialization was moved toward
    its original position in the kernel initialization code by commit
    c4e1acbb35e4 "ACPI / init: Invoke early ACPI initialization later".
    
    However, that turns out to be insufficient, as boot is still broken
    on the Tyan S8812 mainboard.
    
    To fix that issue, split the ACPI early initialization code into
    two pieces so the majority of it still located in acpi_early_init()
    and the part switching over the platform into the ACPI mode goes into
    a new function, acpi_subsystem_init(), executed at the original early
    ACPI initialization spot.
    
    That fixes the Tyan S8812 boot problem, but still allows ACPI
    tables to be loaded earlier which is useful to the EFI code in
    efi_enter_virtual_mode().
    
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=97141
    Fixes: 73f7d1ca3263 "ACPI / init: Run acpi_early_init() before timekeeping_init()"
    Reported-and-tested-by: Marius Tolzmann <tolzmann@molgen.mpg.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Toshi Kani <toshi.kani@hp.com>
    Reviewed-by: Hanjun Guo <hanjun.guo@linaro.org>
    Reviewed-by: Lee, Chun-Yi <jlee@suse.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Sasha Levin <sasha.levin@oracle.com>

commit 09edea4f8fdeb4e292b80d493296070f5ec64e6e
Author: Nathan Lynch <nathan_lynch@mentor.com>
Date:   Mon Aug 10 17:36:06 2015 +0100

    ARM: 8410/1: VDSO: fix coarse clock monotonicity regression
    
    Since 906c55579a63 ("timekeeping: Copy the shadow-timekeeper over the
    real timekeeper last") it has become possible on ARM to:
    
    - Obtain a CLOCK_MONOTONIC_COARSE or CLOCK_REALTIME_COARSE timestamp
      via syscall.
    - Subsequently obtain a timestamp for the same clock ID via VDSO which
      predates the first timestamp (by one jiffy).
    
    This is because ARM's update_vsyscall is deriving the coarse time
    using the __current_kernel_time interface, when it should really be
    using the timekeeper object provided to it by the timekeeping core.
    It happened to work before only because __current_kernel_time would
    access the same timekeeper object which had been passed to
    update_vsyscall.  This is no longer the case.
    
    Cc: stable@vger.kernel.org
    Fixes: 906c55579a63 ("timekeeping: Copy the shadow-timekeeper over the real timekeeper last")
    Signed-off-by: Nathan Lynch <nathan_lynch@mentor.com>
    Acked-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

commit 878854a374620a3f5e8c0a3c418e82a429bc2cff
Author: Nathan Lynch <nathan_lynch@mentor.com>
Date:   Fri Aug 7 21:03:23 2015 -0500

    arm64: VDSO: fix coarse clock monotonicity regression
    
    Since 906c55579a63 ("timekeeping: Copy the shadow-timekeeper over the
    real timekeeper last") it has become possible on arm64 to:
    
    - Obtain a CLOCK_MONOTONIC_COARSE or CLOCK_REALTIME_COARSE timestamp
      via syscall.
    - Subsequently obtain a timestamp for the same clock ID via VDSO which
      predates the first timestamp (by one jiffy).
    
    This is because arm64's update_vsyscall is deriving the coarse time
    using the __current_kernel_time interface, when it should really be
    using the timekeeper object provided to it by the timekeeping core.
    It happened to work before only because __current_kernel_time would
    access the same timekeeper object which had been passed to
    update_vsyscall.  This is no longer the case.
    
    Signed-off-by: Nathan Lynch <nathan_lynch@mentor.com>
    Acked-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>

commit cdbbeb69d4b93455a73edff725639216d7fe0b38
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Jun 10 01:33:36 2015 +0200

    ACPI / init: Switch over platform to the ACPI mode later
    
    commit b064a8fa77dfead647564c46ac8fc5b13bd1ab73 upstream.
    
    Commit 73f7d1ca3263 "ACPI / init: Run acpi_early_init() before
    timekeeping_init()" moved the ACPI subsystem initialization,
    including the ACPI mode enabling, to an earlier point in the
    initialization sequence, to allow the timekeeping subsystem
    use ACPI early.  Unfortunately, that resulted in boot regressions
    on some systems and the early ACPI initialization was moved toward
    its original position in the kernel initialization code by commit
    c4e1acbb35e4 "ACPI / init: Invoke early ACPI initialization later".
    
    However, that turns out to be insufficient, as boot is still broken
    on the Tyan S8812 mainboard.
    
    To fix that issue, split the ACPI early initialization code into
    two pieces so the majority of it still located in acpi_early_init()
    and the part switching over the platform into the ACPI mode goes into
    a new function, acpi_subsystem_init(), executed at the original early
    ACPI initialization spot.
    
    That fixes the Tyan S8812 boot problem, but still allows ACPI
    tables to be loaded earlier which is useful to the EFI code in
    efi_enter_virtual_mode().
    
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=97141
    Fixes: 73f7d1ca3263 "ACPI / init: Run acpi_early_init() before timekeeping_init()"
    Reported-and-tested-by: Marius Tolzmann <tolzmann@molgen.mpg.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Toshi Kani <toshi.kani@hp.com>
    Reviewed-by: Hanjun Guo <hanjun.guo@linaro.org>
    Reviewed-by: Lee, Chun-Yi <jlee@suse.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 8ce84317f1bd73c9e5d10a1cc7f8ff5a6ae86106
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Jun 10 01:33:36 2015 +0200

    ACPI / init: Switch over platform to the ACPI mode later
    
    commit b064a8fa77dfead647564c46ac8fc5b13bd1ab73 upstream.
    
    Commit 73f7d1ca3263 "ACPI / init: Run acpi_early_init() before
    timekeeping_init()" moved the ACPI subsystem initialization,
    including the ACPI mode enabling, to an earlier point in the
    initialization sequence, to allow the timekeeping subsystem
    use ACPI early.  Unfortunately, that resulted in boot regressions
    on some systems and the early ACPI initialization was moved toward
    its original position in the kernel initialization code by commit
    c4e1acbb35e4 "ACPI / init: Invoke early ACPI initialization later".
    
    However, that turns out to be insufficient, as boot is still broken
    on the Tyan S8812 mainboard.
    
    To fix that issue, split the ACPI early initialization code into
    two pieces so the majority of it still located in acpi_early_init()
    and the part switching over the platform into the ACPI mode goes into
    a new function, acpi_subsystem_init(), executed at the original early
    ACPI initialization spot.
    
    That fixes the Tyan S8812 boot problem, but still allows ACPI
    tables to be loaded earlier which is useful to the EFI code in
    efi_enter_virtual_mode().
    
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=97141
    Fixes: 73f7d1ca3263 "ACPI / init: Run acpi_early_init() before timekeeping_init()"
    Reported-and-tested-by: Marius Tolzmann <tolzmann@molgen.mpg.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Toshi Kani <toshi.kani@hp.com>
    Reviewed-by: Hanjun Guo <hanjun.guo@linaro.org>
    Reviewed-by: Lee, Chun-Yi <jlee@suse.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 9e6004867b1a9e4ededb8d56edb827de67073291
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Jun 10 01:33:36 2015 +0200

    ACPI / init: Switch over platform to the ACPI mode later
    
    commit b064a8fa77dfead647564c46ac8fc5b13bd1ab73 upstream.
    
    Commit 73f7d1ca3263 "ACPI / init: Run acpi_early_init() before
    timekeeping_init()" moved the ACPI subsystem initialization,
    including the ACPI mode enabling, to an earlier point in the
    initialization sequence, to allow the timekeeping subsystem
    use ACPI early.  Unfortunately, that resulted in boot regressions
    on some systems and the early ACPI initialization was moved toward
    its original position in the kernel initialization code by commit
    c4e1acbb35e4 "ACPI / init: Invoke early ACPI initialization later".
    
    However, that turns out to be insufficient, as boot is still broken
    on the Tyan S8812 mainboard.
    
    To fix that issue, split the ACPI early initialization code into
    two pieces so the majority of it still located in acpi_early_init()
    and the part switching over the platform into the ACPI mode goes into
    a new function, acpi_subsystem_init(), executed at the original early
    ACPI initialization spot.
    
    That fixes the Tyan S8812 boot problem, but still allows ACPI
    tables to be loaded earlier which is useful to the EFI code in
    efi_enter_virtual_mode().
    
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=97141
    Fixes: 73f7d1ca3263 "ACPI / init: Run acpi_early_init() before timekeeping_init()"
    Reported-and-tested-by: Marius Tolzmann <tolzmann@molgen.mpg.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Toshi Kani <toshi.kani@hp.com>
    Reviewed-by: Hanjun Guo <hanjun.guo@linaro.org>
    Reviewed-by: Lee, Chun-Yi <jlee@suse.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit dfa4158724e364701f14ee0fc9fcc2ad8f3deee7
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Jun 10 01:33:36 2015 +0200

    ACPI / init: Switch over platform to the ACPI mode later
    
    commit b064a8fa77dfead647564c46ac8fc5b13bd1ab73 upstream.
    
    Commit 73f7d1ca3263 "ACPI / init: Run acpi_early_init() before
    timekeeping_init()" moved the ACPI subsystem initialization,
    including the ACPI mode enabling, to an earlier point in the
    initialization sequence, to allow the timekeeping subsystem
    use ACPI early.  Unfortunately, that resulted in boot regressions
    on some systems and the early ACPI initialization was moved toward
    its original position in the kernel initialization code by commit
    c4e1acbb35e4 "ACPI / init: Invoke early ACPI initialization later".
    
    However, that turns out to be insufficient, as boot is still broken
    on the Tyan S8812 mainboard.
    
    To fix that issue, split the ACPI early initialization code into
    two pieces so the majority of it still located in acpi_early_init()
    and the part switching over the platform into the ACPI mode goes into
    a new function, acpi_subsystem_init(), executed at the original early
    ACPI initialization spot.
    
    That fixes the Tyan S8812 boot problem, but still allows ACPI
    tables to be loaded earlier which is useful to the EFI code in
    efi_enter_virtual_mode().
    
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=97141
    Fixes: 73f7d1ca3263 "ACPI / init: Run acpi_early_init() before timekeeping_init()"
    Reported-and-tested-by: Marius Tolzmann <tolzmann@molgen.mpg.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Toshi Kani <toshi.kani@hp.com>
    Reviewed-by: Hanjun Guo <hanjun.guo@linaro.org>
    Reviewed-by: Lee, Chun-Yi <jlee@suse.com>
    Signed-off-by: Luis Henriques <luis.henriques@canonical.com>

commit 4be1f6bbd1e968ab02653c28eababd9480dfff77
Author: Heiko Stübner <heiko@sntech.de>
Date:   Sat Jun 13 12:34:04 2015 +0200

    rtc: hym8563: make the irq optional
    
    Sometimes the irq line is not connected to any soc-pin. This does
    not hinder basic timekeeping functionality of the rtc, so probe
    should not fail in this case.
    
    Signed-off-by: Heiko Stuebner <heiko@sntech.de>
    Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>

commit 43224b96af3154cedd7220f7b90094905f07ac78
Merge: d70b3ef54cea 1cb6c2151850
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jun 22 18:57:44 2015 -0700

    Merge branch 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer updates from Thomas Gleixner:
     "A rather largish update for everything time and timer related:
    
       - Cache footprint optimizations for both hrtimers and timer wheel
    
       - Lower the NOHZ impact on systems which have NOHZ or timer migration
         disabled at runtime.
    
       - Optimize run time overhead of hrtimer interrupt by making the clock
         offset updates smarter
    
       - hrtimer cleanups and removal of restrictions to tackle some
         problems in sched/perf
    
       - Some more leap second tweaks
    
       - Another round of changes addressing the 2038 problem
    
       - First step to change the internals of clock event devices by
         introducing the necessary infrastructure
    
       - Allow constant folding for usecs/msecs_to_jiffies()
    
       - The usual pile of clockevent/clocksource driver updates
    
      The hrtimer changes contain updates to sched, perf and x86 as they
      depend on them plus changes all over the tree to cleanup API changes
      and redundant code, which got copied all over the place.  The y2038
      changes touch s390 to remove the last non 2038 safe code related to
      boot/persistant clock"
    
    * 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (114 commits)
      clocksource: Increase dependencies of timer-stm32 to limit build wreckage
      timer: Minimize nohz off overhead
      timer: Reduce timer migration overhead if disabled
      timer: Stats: Simplify the flags handling
      timer: Replace timer base by a cpu index
      timer: Use hlist for the timer wheel hash buckets
      timer: Remove FIFO "guarantee"
      timers: Sanitize catchup_timer_jiffies() usage
      hrtimer: Allow hrtimer::function() to free the timer
      seqcount: Introduce raw_write_seqcount_barrier()
      seqcount: Rename write_seqcount_barrier()
      hrtimer: Fix hrtimer_is_queued() hole
      hrtimer: Remove HRTIMER_STATE_MIGRATE
      selftest: Timers: Avoid signal deadlock in leap-a-day
      timekeeping: Copy the shadow-timekeeper over the real timekeeper last
      clockevents: Check state instead of mode in suspend/resume path
      selftests: timers: Add leap-second timer edge testing to leap-a-day.c
      ntp: Do leapsecond adjustment in adjtimex read path
      time: Prevent early expiry of hrtimers[CLOCK_REALTIME] at the leap second edge
      ntp: Introduce and use SECS_PER_DAY macro instead of 86400
      ...

commit 906c55579a6360dd9ef5a3101bb2e3ae396dfb97
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Jun 17 10:05:53 2015 -0700

    timekeeping: Copy the shadow-timekeeper over the real timekeeper last
    
    The fix in d151832650ed9 (time: Move clock_was_set_seq update
    before updating shadow-timekeeper) was unfortunately incomplete.
    
    The main gist of that change was to do the shadow-copy update
    last, so that any state changes were properly duplicated, and
    we wouldn't accidentally have stale data in the shadow.
    
    Unfortunately in the main update_wall_time() logic, we update
    use the shadow-timekeeper to calculate the next update values,
    then while holding the lock, copy the shadow-timekeeper over,
    then call timekeeping_update() to do some additional
    bookkeeping, (skipping the shadow mirror). The bug with this is
    the additional bookkeeping isn't all read-only, and some
    changes timkeeper state. Thus we might then overwrite this state
    change on the next update.
    
    To avoid this problem, do the timekeeping_update() on the
    shadow-timekeeper prior to copying the full state over to
    the real-timekeeper.
    
    This avoids problems with both the clock_was_set_seq and
    next_leap_ktime being overwritten and possibly the
    fast-timekeepers as well.
    
    Many thanks to Prarit for his rigorous testing, which discovered
    this problem, along with Prarit and Daniel's work validating this
    fix.
    
    Reported-by: Prarit Bhargava <prarit@redhat.com>
    Tested-by: Prarit Bhargava <prarit@redhat.com>
    Tested-by: Daniel Bristot de Oliveira <bristot@redhat.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Jan Kara <jack@suse.cz>
    Cc: Jiri Bohac <jbohac@suse.cz>
    Cc: Ingo Molnar <mingo@kernel.org>
    Link: http://lkml.kernel.org/r/1434560753-7441-1-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit a4630c61274322eda7c4a4d17051f7c72a9e03b1
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Fri May 29 17:24:23 2015 +0200

    PM / Domains: Skip timings during syscore suspend/resume
    
    The PM Domain code uses ktime_get() to perform various latency
    measurements.  However, if ktime_get() is called while timekeeping is
    suspended, the following warning is printed:
    
        WARNING: CPU: 0 PID: 1340 at kernel/time/timekeeping.c:576 ktime_get+0x3
    
    This happens when resuming the PM Domain that contains the clock events
    source, which calls pm_genpd_syscore_poweron(). Chain of operations is:
    
        timekeeping_resume()
        {
            clockevents_resume()
                sh_cmt_clock_event_resume()
                    pm_genpd_syscore_poweron()
                        pm_genpd_sync_poweron()
                            genpd_syscore_switch()
                                genpd_power_on()
                                    ktime_get(), but timekeeping_suspended == 1
            ...
            timekeeping_suspended = 0;
        }
    
    Fix this by adding a "timed" parameter to genpd_power_{on,off}() and
    pm_genpd_sync_power{off,on}(), to indicate whether latency measurements
    are allowed.  This parameter is passed as false in
    genpd_syscore_switch() (i.e. during syscore suspend/resume), and true in
    all other cases.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 833f32d763028c1bb371c64f457788b933773b3e
Author: John Stultz <john.stultz@linaro.org>
Date:   Thu Jun 11 15:54:55 2015 -0700

    time: Prevent early expiry of hrtimers[CLOCK_REALTIME] at the leap second edge
    
    Currently, leapsecond adjustments are done at tick time. As a result,
    the leapsecond was applied at the first timer tick *after* the
    leapsecond (~1-10ms late depending on HZ), rather then exactly on the
    second edge.
    
    This was in part historical from back when we were always tick based,
    but correcting this since has been avoided since it adds extra
    conditional checks in the gettime fastpath, which has performance
    overhead.
    
    However, it was recently pointed out that ABS_TIME CLOCK_REALTIME
    timers set for right after the leapsecond could fire a second early,
    since some timers may be expired before we trigger the timekeeping
    timer, which then applies the leapsecond.
    
    This isn't quite as bad as it sounds, since behaviorally it is similar
    to what is possible w/ ntpd made leapsecond adjustments done w/o using
    the kernel discipline. Where due to latencies, timers may fire just
    prior to the settimeofday call. (Also, one should note that all
    applications using CLOCK_REALTIME timers should always be careful,
    since they are prone to quirks from settimeofday() disturbances.)
    
    However, the purpose of having the kernel do the leap adjustment is to
    avoid such latencies, so I think this is worth fixing.
    
    So in order to properly keep those timers from firing a second early,
    this patch modifies the ntp and timekeeping logic so that we keep
    enough state so that the update_base_offsets_now accessor, which
    provides the hrtimer core the current time, can check and apply the
    leapsecond adjustment on the second edge. This prevents the hrtimer
    core from expiring timers too early.
    
    This patch does not modify any other time read path, so no additional
    overhead is incurred. However, this also means that the leap-second
    continues to be applied at tick time for all other read-paths.
    
    Apologies to Richard Cochran, who pushed for similar changes years
    ago, which I resisted due to the concerns about the performance
    overhead.
    
    While I suspect this isn't extremely critical, folks who care about
    strict leap-second correctness will likely want to watch
    this. Potentially a -stable candidate eventually.
    
    Originally-suggested-by: Richard Cochran <richardcochran@gmail.com>
    Reported-by: Daniel Bristot de Oliveira <bristot@redhat.com>
    Reported-by: Prarit Bhargava <prarit@redhat.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Jan Kara <jack@suse.cz>
    Cc: Jiri Bohac <jbohac@suse.cz>
    Cc: Shuah Khan <shuahkh@osg.samsung.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Link: http://lkml.kernel.org/r/1434063297-28657-4-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit d151832650ed98961a5650e73e85c349ad7839cb
Author: John Stultz <john.stultz@linaro.org>
Date:   Thu Jun 11 15:54:53 2015 -0700

    time: Move clock_was_set_seq update before updating shadow-timekeeper
    
    It was reported that 868a3e915f7f5eba (hrtimer: Make offset
    update smarter) was causing timer problems after suspend/resume.
    
    The problem with that change is the modification to
    clock_was_set_seq in timekeeping_update is done prior to
    mirroring the time state to the shadow-timekeeper. Thus the
    next time we do update_wall_time() the updated sequence is
    overwritten by whats in the shadow copy.
    
    This patch moves the shadow-timekeeper mirroring to the end
    of the function, after all updates have been made, so all data
    is kept in sync.
    
    (This patch also affects the update_fast_timekeeper calls which
    were also problematically done prior to the mirroring).
    
    Reported-and-tested-by: Jeremiah Mahler <jmmahler@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Preeti U Murthy <preeti@linux.vnet.ibm.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Viresh Kumar <viresh.kumar@linaro.org>
    Cc: Marcelo Tosatti <mtosatti@redhat.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Link: http://lkml.kernel.org/r/1434063297-28657-2-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit b064a8fa77dfead647564c46ac8fc5b13bd1ab73
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Jun 10 01:33:36 2015 +0200

    ACPI / init: Switch over platform to the ACPI mode later
    
    Commit 73f7d1ca3263 "ACPI / init: Run acpi_early_init() before
    timekeeping_init()" moved the ACPI subsystem initialization,
    including the ACPI mode enabling, to an earlier point in the
    initialization sequence, to allow the timekeeping subsystem
    use ACPI early.  Unfortunately, that resulted in boot regressions
    on some systems and the early ACPI initialization was moved toward
    its original position in the kernel initialization code by commit
    c4e1acbb35e4 "ACPI / init: Invoke early ACPI initialization later".
    
    However, that turns out to be insufficient, as boot is still broken
    on the Tyan S8812 mainboard.
    
    To fix that issue, split the ACPI early initialization code into
    two pieces so the majority of it still located in acpi_early_init()
    and the part switching over the platform into the ACPI mode goes into
    a new function, acpi_subsystem_init(), executed at the original early
    ACPI initialization spot.
    
    That fixes the Tyan S8812 boot problem, but still allows ACPI
    tables to be loaded earlier which is useful to the EFI code in
    efi_enter_virtual_mode().
    
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=97141
    Fixes: 73f7d1ca3263 "ACPI / init: Run acpi_early_init() before timekeeping_init()"
    Reported-and-tested-by: Marius Tolzmann <tolzmann@molgen.mpg.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Toshi Kani <toshi.kani@hp.com>
    Reviewed-by: Hanjun Guo <hanjun.guo@linaro.org>
    Reviewed-by: Lee, Chun-Yi <jlee@suse.com>

commit 45bbfe64ea564a69e56ab6754006eee506224f46
Author: Joe Perches <joe@perches.com>
Date:   Mon May 25 11:49:55 2015 -0700

    clocksource: Use current logging style
    
    clocksource messages aren't prefixed in dmesg so it's a bit unclear
    what subsystem emits the messages.
    
    Use pr_fmt and pr_<level> to auto-prefix the messages appropriately.
    
    Miscellanea:
    
    o Remove "Warning" from KERN_WARNING level messages
    o Align "timekeeping watchdog: " messages
    o Coalesce formats
    o Align multiline arguments
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Cc: John Stultz <john.stultz@linaro.org>
    Link: http://lkml.kernel.org/r/1432579795.2846.75.camel@perches.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 9056a23ba19d911d4a079b8ca543fb8ebffa7c56
Author: Tina Ruchandani <ruchandani.tina@gmail.com>
Date:   Sun May 31 04:17:06 2015 -0300

    [media] dvb-frontend: Replace timeval with ktime_t
    
    struct timeval uses a 32-bit seconds representation which will
    overflow in the year 2038 and beyond. This patch replaces
    the usage of struct timeval with ktime_t which is a 64-bit
    timestamp and is year 2038 safe.
    This patch is part of a larger attempt to remove all instances
    of 32-bit timekeeping variables (timeval, timespec, time_t)
    which are not year 2038 safe, from the kernel.
    
    [mchehab@osg.samsung.com: add a missing parenthesis, breaking compilation]
    Suggested-by: Arnd Bergmann <arndb@arndb.de>
    Signed-off-by: Tina Ruchandani <ruchandani.tina@gmail.com>
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

commit e1d5bbcdc7ca08d8731f5d780f0de342a768d96a
Author: Tina Ruchandani <ruchandani.tina@gmail.com>
Date:   Tue May 19 11:38:09 2015 +0530

    xen/pcifront: Remove usage of struct timeval
    
    struct timeval uses a 32-bit field for representing seconds, which
    will overflow in the year 2038 and beyond. Replace struct timeval with
    64-bit ktime_t which is 2038 safe.  This is part of a larger effort to
    remove instances of 32-bit timekeeping variables (timeval, time_t and
    timespec) from the kernel.
    
    Signed-off-by: Tina Ruchandani <ruchandani.tina@gmail.com>
    Suggested-by: Arnd Bergmann <arnd@arndb.de>
    Reviewed-by: Boris Ostrovsky <boris.ostrovsky@oracle.com>
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: David Vrabel <david.vrabel@citrix.com>

commit 669f6f96c680a741257ada44a28b580df2e1fc25
Author: Ingo Molnar <mingo@kernel.org>
Date:   Wed Jun 3 12:39:26 2015 +0200

    Documentation/features: Explain kernel feature descriptions and add visualization script
    
    The previous patches added arch support matrices for more than 40 generic kernel features
    that need per architecture support.
    
    The structure of the feature descriptions is the following:
    
    Each feature has its own directory under Documentation/features/subsystem_name/feature_name/,
    and the arch-support.txt file shows its current arch porting status.
    
    For example, lockdep support is shown the following way:
    
        triton:~/tip> cat Documentation/features/locking/lockdep/arch-support.txt
        #
        # Feature name:          lockdep
        #         Kconfig:       LOCKDEP_SUPPORT
        #         description:   arch supports the runtime locking correctness debug facility
        #
            -----------------------
            |         arch |status|
            -----------------------
            |       alpha: | TODO |
            |         arc: |  ok  |
            |         arm: |  ok  |
            |       arm64: |  ok  |
            |       avr32: |  ok  |
            |    blackfin: |  ok  |
            |         c6x: | TODO |
            |        cris: | TODO |
            |         frv: | TODO |
            |       h8300: | TODO |
            |     hexagon: |  ok  |
            |        ia64: | TODO |
            |        m32r: | TODO |
            |        m68k: | TODO |
            |       metag: |  ok  |
            |  microblaze: |  ok  |
            |        mips: |  ok  |
            |     mn10300: | TODO |
            |       nios2: | TODO |
            |    openrisc: | TODO |
            |      parisc: | TODO |
            |     powerpc: |  ok  |
            |        s390: |  ok  |
            |       score: |  ok  |
            |          sh: |  ok  |
            |       sparc: |  ok  |
            |        tile: |  ok  |
            |          um: |  ok  |
            |   unicore32: |  ok  |
            |         x86: |  ok  |
            |      xtensa: |  ok  |
            -----------------------
    
    For generic kernel features that need architecture support, the
    arch-support.txt file in each feature directory shows the arch
    support matrix, for all upstream Linux architectures.
    
    The meaning of entries in the tables is:
    
        | ok |  # feature supported by the architecture
        |TODO|  # feature not yet supported by the architecture
        | .. |  # feature cannot be supported by the hardware
    
    This directory structure can be used in the future to add other
    files - such as porting guides, testing description, etc.
    
    The Documentation/features/ hierarchy may also include generic
    kernel features that works on every architecture, in that case
    the arch-support.txt file will list every architecture as
    supported.
    
    To list an architecture's unsupported features, just do something
    like:
    
      triton:~/tip>  git grep -lE 'x86.*TODO' Documentation/features/*/*/arch-support.txt
      Documentation/features/lib/strncasecmp/arch-support.txt
      Documentation/features/time/arch-tick-broadcast/arch-support.txt
    
    which will print the list of not yet supported features.
    
    The Documentation/features/list-arch.sh script will print the current
    support matrix of one architecture:
    
      triton:~/tip> Documentation/features/list-arch.sh
      #
      # Kernel feature support matrix of the 'x86' architecture:
      #
          core/ BPF-JIT              :  ok  |                        HAVE_BPF_JIT #  arch supports BPF JIT optimizations
          core/ generic-idle-thread  :  ok  |             GENERIC_SMP_IDLE_THREAD #  arch makes use of the generic SMP idle thread facility
          core/ jump-labels          :  ok  |                HAVE_ARCH_JUMP_LABEL #  arch supports live patched, high efficiency branches
          core/ tracehook            :  ok  |                 HAVE_ARCH_TRACEHOOK #  arch supports tracehook (ptrace) register handling APIs
         debug/ gcov-profile-all     :  ok  |           ARCH_HAS_GCOV_PROFILE_ALL #  arch supports whole-kernel GCOV code coverage profiling
         debug/ KASAN                :  ok  |                     HAVE_ARCH_KASAN #  arch supports the KASAN runtime memory checker
         debug/ kgdb                 :  ok  |                      HAVE_ARCH_KGDB #  arch supports the kGDB kernel debugger
         debug/ kprobes              :  ok  |                        HAVE_KPROBES #  arch supports live patched kernel probe
         debug/ kprobes-on-ftrace    :  ok  |              HAVE_KPROBES_ON_FTRACE #  arch supports combined kprobes and ftrace live patching
         debug/ kretprobes           :  ok  |                     HAVE_KRETPROBES #  arch supports kernel function-return probes
         debug/ optprobes            :  ok  |                      HAVE_OPTPROBES #  arch supports live patched optprobes
         debug/ stackprotector       :  ok  |              HAVE_CC_STACKPROTECTOR #  arch supports compiler driven stack overflow protection
         debug/ uprobes              :  ok  |               ARCH_SUPPORTS_UPROBES #  arch supports live patched user probes
         debug/ user-ret-profiler    :  ok  |           HAVE_USER_RETURN_NOTIFIER #  arch supports user-space return from system call profiler
            io/ dma-api-debug        :  ok  |                  HAVE_DMA_API_DEBUG #  arch supports DMA debug facilities
            io/ dma-contiguous       :  ok  |                 HAVE_DMA_CONTIGUOUS #  arch supports the DMA CMA (continuous memory allocator)
            io/ dma_map_attrs        :  ok  |                      HAVE_DMA_ATTRS #  arch provides dma_*map*_attrs() APIs
            io/ sg-chain             :  ok  |                   ARCH_HAS_SG_CHAIN #  arch supports chained scatter-gather lists
           lib/ strncasecmp          : TODO |             __HAVE_ARCH_STRNCASECMP #  arch provides an optimized strncasecmp() function
       locking/ cmpxchg-local        :  ok  |                  HAVE_CMPXCHG_LOCAL #  arch supports the this_cpu_cmpxchg() API
       locking/ lockdep              :  ok  |                     LOCKDEP_SUPPORT #  arch supports the runtime locking correctness debug facility
       locking/ queued-rwlocks       :  ok  |             ARCH_USE_QUEUED_RWLOCKS #  arch supports queued rwlocks
       locking/ queued-spinlocks     :  ok  |           ARCH_USE_QUEUED_SPINLOCKS #  arch supports queued spinlocks
       locking/ rwsem-optimized      :  ok  |               Optimized asm/rwsem.h #  arch provides optimized rwsem APIs
          perf/ kprobes-event        :  ok  |      HAVE_REGS_AND_STACK_ACCESS_API #  arch supports kprobes with perf events
          perf/ perf-regs            :  ok  |                      HAVE_PERF_REGS #  arch supports perf events register access
          perf/ perf-stackdump       :  ok  |           HAVE_PERF_USER_STACK_DUMP #  arch supports perf events stack dumps
         sched/ numa-balancing       :  ok  |        ARCH_SUPPORTS_NUMA_BALANCING #  arch supports NUMA balancing
       seccomp/ seccomp-filter       :  ok  |            HAVE_ARCH_SECCOMP_FILTER #  arch supports seccomp filters
          time/ arch-tick-broadcast  : TODO |             ARCH_HAS_TICK_BROADCAST #  arch provides tick_broadcast()
          time/ clockevents          :  ok  |                 GENERIC_CLOCKEVENTS #  arch support generic clock events
          time/ context-tracking     :  ok  |               HAVE_CONTEXT_TRACKING #  arch supports context tracking for NO_HZ_FULL
          time/ irq-time-acct        :  ok  |            HAVE_IRQ_TIME_ACCOUNTING #  arch supports precise IRQ time accounting
          time/ modern-timekeeping   :  ok  |            !ARCH_USES_GETTIMEOFFSET #  arch does not use arch_gettimeoffset() anymore
          time/ virt-cpuacct         :  ok  |            HAVE_VIRT_CPU_ACCOUNTING #  arch supports precise virtual CPU time accounting
            vm/ ELF-ASLR             :  ok  |              ARCH_HAS_ELF_RANDOMIZE #  arch randomizes the stack, heap and binary images of ELF binaries
            vm/ huge-vmap            :  ok  |                 HAVE_ARCH_HUGE_VMAP #  arch supports the ioremap_pud_enabled() and ioremap_pmd_enabled() VM APIs
            vm/ ioremap_prot         :  ok  |                   HAVE_IOREMAP_PROT #  arch has ioremap_prot()
            vm/ numa-memblock        :  ok  |              HAVE_MEMBLOCK_NODE_MAP #  arch supports NUMA aware memblocks
            vm/ PG_uncached          :  ok  |               ARCH_USES_PG_UNCACHED #  arch supports the PG_uncached page flag
            vm/ pmdp_splitting_flush :  ok  |    __HAVE_ARCH_PMDP_SPLITTING_FLUSH #  arch supports the pmdp_splitting_flush() VM API
            vm/ pte_special          :  ok  |             __HAVE_ARCH_PTE_SPECIAL #  arch supports the pte_special()/pte_mkspecial() VM APIs
            vm/ THP                  :  ok  |      HAVE_ARCH_TRANSPARENT_HUGEPAGE #  arch supports transparent hugepages
    
    Cc: <linux-api@vger.kernel.org>
    Cc: <linux-arch@vger.kernel.org>
    Cc: <linux-kernel@vger.kernel.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Jonathan Corbet <corbet@lwn.net>
    Cc: Josh Triplett <josh@joshtriplett.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 44121b9ed0384088a6899cfb2ca4ede1428d412f
Author: Ingo Molnar <mingo@kernel.org>
Date:   Wed Jun 3 12:37:04 2015 +0200

    Documentation/features/time: Add feature description and arch support status file for 'modern-timekeeping'
    
    Cc: <linux-api@vger.kernel.org>
    Cc: <linux-arch@vger.kernel.org>
    Cc: <linux-kernel@vger.kernel.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Jonathan Corbet <corbet@lwn.net>
    Cc: Josh Triplett <josh@joshtriplett.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit cf58fcb1bea9e0fcf3447bdb959ef5bcd22cfbcb
Author: Stephan Mueller <smueller@chronox.de>
Date:   Wed May 27 13:50:12 2015 +0200

    crypto: jitterentropy - remove timekeeping_valid_for_hres
    
    The patch removes the use of timekeeping_valid_for_hres which is now
    marked as internal for the time keeping subsystem. The jitterentropy
    does not really require this verification as a coarse timer (when
    random_get_entropy is absent) is discovered by the initialization test
    of jent_entropy_init, which would cause the jitter rng to not load in
    that case.
    
    Reported-by: kbuild test robot <fengguang.wu@intel.com>
    Signed-off-by: Stephan Mueller <smueller@chronox.de>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

commit 6695b92a60bc7160c92d6dc5b17cc79673017c2f
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Wed May 27 11:09:36 2015 +0930

    seqlock: Better document raw_write_seqcount_latch()
    
    Improve the documentation of the latch technique as used in the
    current timekeeping code, such that it can be readily employed
    elsewhere.
    
    Borrow from the comments in timekeeping and replace those with a
    reference to this more generic comment.
    
    Cc: Andrea Arcangeli <aarcange@redhat.com>
    Cc: David Woodhouse <David.Woodhouse@intel.com>
    Cc: Rik van Riel <riel@redhat.com>
    Cc: "Paul E. McKenney" <paulmck@linux.vnet.ibm.com>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Reviewed-by: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
    Acked-by: Michel Lespinasse <walken@google.com>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

commit 57d05a93ada77c4f8a6112cbc867a2948dce7991
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed May 13 16:04:47 2015 -0700

    time: Rework debugging variables so they aren't global
    
    Ingo suggested that the timekeeping debugging variables
    recently added should not be global, and should be tied
    to the timekeeper's read_base.
    
    Thus this patch implements that suggestion.
    
    This version is different from the earlier versions
    as it keeps the variables in the timekeeper structure
    rather then in the tkr.
    
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 6374f9124efea5fae9cba263108583c39e22f86b
Author: Harald Geyer <harald@ccbib.org>
Date:   Tue Apr 7 11:12:35 2015 +0000

    timekeeping: Provide new API to get the current time resolution
    
    This patch series introduces a new function
    u32 ktime_get_resolution_ns(void)
    which allows to clean up some driver code.
    
    In particular the IIO subsystem has a function to provide timestamps for
    events but no means to get their resolution. So currently the dht11 driver
    tries to guess the resolution in a rather messy and convoluted way. We
    can do much better with the new code.
    
    This API is not designed to be exposed to user space.
    
    This has been tested on i386, sunxi and mxs.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Harald Geyer <harald@ccbib.org>
    [jstultz: Tweaked to make it build after upstream changes]
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 75e0678e7095c486a1b39ea560f8eb51a2714d6d
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun May 10 01:23:35 2015 +0200

    PM / tick: Add tracepoints for suspend-to-idle diagnostics
    
    Add suspend/resume tracepoints to tick_freeze() and tick_unfreeze()
    to catch when timekeeping is suspended and resumed during suspend-to-idle
    so as to be able to check whether or not we enter the "frozen" state
    and to measure the time spent in it.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>

commit 51a03393bac061a4e13fd17214d3ef93a5b296e3
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Apr 22 11:44:15 2015 +0200

    timekeeping: Remove stale function prototype
    
    commit 61edec81d260 "timekeeping: Simplify timekeeping_clocktai()"
    implemented timekeeping_clocktai() as an inline function, but left the
    old extern prototype in the header file. Remove it.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 4796cf9b02b5bea141632e21d64556a7eb883a65
Author: Yingjoe Chen <yingjoe.chen@mediatek.com>
Date:   Fri Apr 10 21:55:50 2015 +0800

    time: Remove nonexistent function prototype
    
    The function clocksource_get_next() was removed in commit 75c5158f70
    (timekeeping: Update clocksource with stop_machine), but the
    prototype was not removed with it. Remove the prototype.
    
    Signed-off-by: Yingjoe Chen <yingjoe.chen@mediatek.com>
    Cc: <linux-arm-kernel@lists.infradead.org>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: <srv_heupstream@mediatek.com>
    Cc: John Stultz <john.stultz@linaro.org>
    Link: http://lkml.kernel.org/r/1428674150-1780-1-git-send-email-yingjoe.chen@mediatek.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 7fd56474db326f7a6df0e2a4e3a9600cc083ab9b
Merge: 49d2953c72c6 def747087e83
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Apr 13 11:08:28 2015 -0700

    Merge branch 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer updates from Ingo Molnar:
     "The main changes in this cycle were:
    
       - clockevents state machine cleanups and enhancements (Viresh Kumar)
    
       - clockevents broadcast notifier horror to state machine conversion
         and related cleanups (Thomas Gleixner, Rafael J Wysocki)
    
       - clocksource and timekeeping core updates (John Stultz)
    
       - clocksource driver updates and fixes (Ben Dooks, Dmitry Osipenko,
         Hans de Goede, Laurent Pinchart, Maxime Ripard, Xunlei Pang)
    
       - y2038 fixes (Xunlei Pang, John Stultz)
    
       - NMI-safe ktime_get_raw_fast() and general refactoring of the clock
         code, in preparation to perf's per event clock ID support (Peter
         Zijlstra)
    
       - generic sched/clock fixes, optimizations and cleanups (Daniel
         Thompson)
    
       - clockevents cpu_down() race fix (Preeti U Murthy)"
    
    * 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (94 commits)
      timers/PM: Drop unnecessary braces from tick_freeze()
      timers/PM: Fix up tick_unfreeze()
      timekeeping: Get rid of stale comment
      clockevents: Cleanup dead cpu explicitely
      clockevents: Make tick handover explicit
      clockevents: Remove broadcast oneshot control leftovers
      sched/idle: Use explicit broadcast oneshot control function
      ARM: Tegra: Use explicit broadcast oneshot control function
      ARM: OMAP: Use explicit broadcast oneshot control function
      intel_idle: Use explicit broadcast oneshot control function
      ACPI/idle: Use explicit broadcast control function
      ACPI/PAD: Use explicit broadcast oneshot control function
      x86/amd/idle, clockevents: Use explicit broadcast oneshot control functions
      clockevents: Provide explicit broadcast oneshot control functions
      clockevents: Remove the broadcast control leftovers
      ARM: OMAP: Use explicit broadcast control function
      intel_idle: Use explicit broadcast control function
      cpuidle: Use explicit broadcast control function
      ACPI/processor: Use explicit broadcast control function
      ACPI/PAD: Use explicit broadcast control function
      ...

commit f321c9cbf3bbf86f6e6153419eaf93ad085e3d74
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Apr 3 15:25:04 2015 +0200

    PM / watchdog: iTCO: stop watchdog during system suspend
    
    If the target sleep state of the system is not an ACPI sleep state
    (S1, S2 or S3), the TCO watchdog needs to be stopped during system
    suspend, because it may not be possible to ping it any more after
    timekeeping has been suspended (suspend-to-idle does that for
    one example).
    
    For this reason, provide ->suspend_noirq and ->resume_noirq
    callbacks for the iTCO watchdog driver and use them to stop
    and restart the watchdog during system suspend and resume,
    respectively, if the system is not going to enter an ACPI
    sleep state (in which case the watchdog will be stopped
    by the platform firmware before the state is entered).
    
    Reported-and-tested-by: Borun Fu <borun.fu@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Guenter Roeck <linux@roeck-us.net>

commit 347c6f6dda1098318088feb8e60188f0161e743d
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Apr 3 02:39:05 2015 +0200

    timekeeping: Get rid of stale comment
    
    Arch specific management of xtime/jiffies/wall_to_monotonic is
    gone for quite a while. Zap the stale comment.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: John Stultz <john.stultz@linaro.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: John Stultz <john.stultz@linaro.org>
    Link: http://lkml.kernel.org/r/2422730.dmO29q661S@vostro.rjw.lan
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 0fa88cb4b82b5cf7429bc1cef9db006ca035754e
Author: Xunlei Pang <pang.xunlei@linaro.org>
Date:   Wed Apr 1 20:34:38 2015 -0700

    time, drivers/rtc: Don't bother with rtc_resume() for the nonstop clocksource
    
    If a system does not provide a persistent_clock(), the time
    will be updated on resume by rtc_resume(). With the addition
    of the non-stop clocksources for suspend timing, those systems
    set the time on resume in timekeeping_resume(), but may not
    provide a valid persistent_clock().
    
    This results in the rtc_resume() logic thinking no one has set
    the time and it then will over-write the suspend time again,
    which is not necessary and only increases clock error.
    
    So, fix this for rtc_resume().
    
    This patch also improves the name of persistent_clock_exist to
    make it more grammatical.
    
    Signed-off-by: Xunlei Pang <pang.xunlei@linaro.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/1427945681-29972-19-git-send-email-john.stultz@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 264bb3f79f2a465477cdcd2f0554e21aedc443a3
Author: Xunlei Pang <pang.xunlei@linaro.org>
Date:   Wed Apr 1 20:34:37 2015 -0700

    time: Fix a bug in timekeeping_suspend() with no persistent clock
    
    When there's no persistent clock, normally
    timekeeping_suspend_time should always be zero, but this can
    break in timekeeping_suspend().
    
    At T1, there was a system suspend, so old_delta was assigned T1.
    After some time, one time adjustment happened, and xtime got the
    value of T1-dt(0s<dt<2s). Then, there comes another system
    suspend soon after this adjustment, obviously we will get a
    small negative delta_delta, resulting in a negative
    timekeeping_suspend_time.
    
    This is problematic, when doing timekeeping_resume() if there is
    no nonstop clocksource for example, it will hit the else leg and
    inject the improper sleeptime which is the wrong logic.
    
    So, we can solve this problem by only doing delta related code
    when the persistent clock is existent. Actually the code only
    makes sense for persistent clock cases.
    
    Signed-off-by: Xunlei Pang <pang.xunlei@linaro.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/1427945681-29972-18-git-send-email-john.stultz@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 7f2981393af31a854879f2496cab4c978e886902
Author: Xunlei Pang <pang.xunlei@linaro.org>
Date:   Wed Apr 1 20:34:35 2015 -0700

    time: Don't build timekeeping_inject_sleeptime64() if no one uses it
    
    timekeeping_inject_sleeptime64() is only used by RTC
    suspend/resume, so add build dependencies on the necessary RTC
    related macros.
    
    Signed-off-by: Xunlei Pang <pang.xunlei@linaro.org>
    [ Improve commit message clarity. ]
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/1427945681-29972-16-git-send-email-john.stultz@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit bfb83b27519aa7ed9510f601a8f825a2c1484bc2
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Mar 25 13:06:04 2015 +0100

    tick: Move clocksource related stuff to timekeeping.h
    
    Move clocksource related stuff to timekeeping.h and remove the
    pointless include from ntp.c
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    [ rjw: Subject ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/2714218.nM5AEfAHj0@vostro.rjw.lan
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 4a4ad80d32cea69ee93bd4589f24dc478804cd80
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Thu Mar 19 09:28:44 2015 +0100

    time: Add timerkeeper::tkr_raw
    
    Introduce tkr_raw and make use of it.
    
      base_raw -> tkr_raw.base
      clock->{mult,shift} -> tkr_raw.{mult.shift}
    
    Kill timekeeping_get_ns_raw() in favour of
    timekeeping_get_ns(&tkr_raw), this removes all mono_raw special
    casing.
    
    Duplicate the updates to tkr_mono.cycle_last into tkr_raw.cycle_last,
    both need the same value.
    
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Acked-by: John Stultz <john.stultz@linaro.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/20150319093400.422589590@infradead.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 1809bfa44e1019e397fabaa6f2349bb7237e57a4
Author: Daniel Thompson <daniel.thompson@linaro.org>
Date:   Thu Mar 26 12:23:26 2015 -0700

    timers, sched/clock: Avoid deadlock during read from NMI
    
    Currently it is possible for an NMI (or FIQ on ARM) to come in
    and read sched_clock() whilst update_sched_clock() has locked
    the seqcount for writing. This results in the NMI handler
    locking up when it calls raw_read_seqcount_begin().
    
    This patch fixes the NMI safety issues by providing banked clock
    data. This is a similar approach to the one used in Thomas
    Gleixner's 4396e058c52e("timekeeping: Provide fast and NMI safe
    access to CLOCK_MONOTONIC").
    
    Suggested-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Daniel Thompson <daniel.thompson@linaro.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Reviewed-by: Stephen Boyd <sboyd@codeaurora.org>
    Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Will Deacon <will.deacon@arm.com>
    Link: http://lkml.kernel.org/r/1427397806-20889-6-git-send-email-john.stultz@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 4ca22c2648f9c1cec0b242f58d7302136f5a4cbb
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Mar 11 21:16:35 2015 -0700

    timekeeping: Add warnings when overflows or underflows are observed
    
    It was suggested that the underflow/overflow protection
    should probably throw some sort of warning out, rather
    than just silently fixing the issue.
    
    So this patch adds some warnings here. The flag variables
    used are not protected by locks, but since we can't print
    from the reading functions, just being able to say we
    saw an issue in the update interval is useful enough,
    and can be slightly racy without real consequence.
    
    The big complication is that we're only under a read
    seqlock, so the data could shift under us during
    our calculation to see if there was a problem. This
    patch avoids this issue by nesting another seqlock
    which allows us to snapshot the just required values
    atomically. So we shouldn't see false positives.
    
    I also added some basic rate-limiting here, since
    on one build machine w/ skewed TSCs it was fairly
    noisy at bootup.
    
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Dave Jones <davej@codemonkey.org.uk>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Stephen Boyd <sboyd@codeaurora.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/1426133800-29329-8-git-send-email-john.stultz@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 057b87e3161d1194a095718f9918c01b2c389e74
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Mar 11 21:16:34 2015 -0700

    timekeeping: Try to catch clocksource delta underflows
    
    In the case where there is a broken clocksource
    where there are multiple actual clocks that
    aren't perfectly aligned, we may see small "negative"
    deltas when we subtract 'now' from 'cycle_last'.
    
    The values are actually negative with respect to the
    clocksource mask value, not necessarily negative
    if cast to a s64, but we can check by checking the
    delta to see if it is a small (relative to the mask)
    negative value (again negative relative to the mask).
    
    If so, we assume we jumped backwards somehow and
    instead use zero for our delta.
    
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Dave Jones <davej@codemonkey.org.uk>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Stephen Boyd <sboyd@codeaurora.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/1426133800-29329-7-git-send-email-john.stultz@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit a558cd021d83b65c47ee5b9bec1fcfe5298a769f
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Mar 11 21:16:33 2015 -0700

    timekeeping: Add checks to cap clocksource reads to the 'max_cycles' value
    
    When calculating the current delta since the last tick, we
    currently have no hard protections to prevent a multiplication
    overflow from occuring.
    
    This patch introduces infrastructure to allow a cap that
    limits the clocksource read delta value to the 'max_cycles' value,
    which is where an overflow would occur.
    
    Since this is in the hotpath, it adds the extra checking under
    CONFIG_DEBUG_TIMEKEEPING=y.
    
    There was some concern that capping time like this could cause
    problems as we may stop expiring timers, which could go circular
    if the timer that triggers time accumulation were mis-scheduled
    too far in the future, which would cause time to stop.
    
    However, since the mult overflow would result in a smaller time
    value, we would effectively have the same problem there.
    
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Dave Jones <davej@codemonkey.org.uk>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Stephen Boyd <sboyd@codeaurora.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/1426133800-29329-6-git-send-email-john.stultz@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 3c17ad19f0697ffe5ef7438cdafc2d2b7757d8a5
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Mar 11 21:16:32 2015 -0700

    timekeeping: Add debugging checks to warn if we see delays
    
    Recently there's been requests for better sanity
    checking in the time code, so that it's more clear
    when something is going wrong, since timekeeping issues
    could manifest in a large number of strange ways in
    various subsystems.
    
    Thus, this patch adds some extra infrastructure to
    add a check to update_wall_time() to print two new
    warnings:
    
     1) if we see the call delayed beyond the 'max_cycles'
        overflow point,
    
     2) or if we see the call delayed beyond the clocksource's
        'max_idle_ns' value, which is currently 50% of the
        overflow point.
    
    This extra infrastructure is conditional on
    a new CONFIG_DEBUG_TIMEKEEPING option, also
    added in this patch - default off.
    
    Tested this a bit by halting qemu for specified
    lengths of time to trigger the warnings.
    
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Dave Jones <davej@codemonkey.org.uk>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Stephen Boyd <sboyd@codeaurora.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/1426133800-29329-5-git-send-email-john.stultz@linaro.org
    [ Improved the changelog and the messages a bit. ]
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 7fe5f1c16c2c7904c7b8fcfb93e691893f21e8d3
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Mar 11 17:40:15 2015 -0700

    MAINTAINERS: Add selftests/timers to the timekeeping maintainance list
    
    Since I'm adding a bunch of tests to selftests/timers, put me
    on the hook in the maintainers file.
    
    Cc: Shuah Khan <shuahkh@osg.samsung.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Tested-by: Prarit Bhargava <prarit@redhat.com>
    Signed-off-by: Shuah Khan <shuahkh@osg.samsung.com>

commit 7290ce1423c38108027ae90116ece6618db32bc3
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Mar 11 17:40:10 2015 -0700

    selftests/timers: Add clocksource-switch test from timetest suite
    
    Adds the clocksource-switch tests which continually switches the
    current clocksource between all the available ones, watching for
    any timekeeping inconsistencies.
    
    Cc: Shuah Khan <shuahkh@osg.samsung.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Tested-by: Prarit Bhargava <prarit@redhat.com>
    Signed-off-by: Shuah Khan <shuahkh@osg.samsung.com>

commit 6e8b285bcdd1834a18fd264c88a15418091c4015
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Mar 11 17:40:09 2015 -0700

    selftests/timers: Add skew_consistency test from the timetests suite
    
    This change adds the skew_consistency test, which twists the
    ADJ_FREQUENCY knob back and forth and watches for timekeeping
    inconsistencies.
    
    Cc: Shuah Khan <shuahkh@osg.samsung.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Tested-by: Prarit Bhargava <prarit@redhat.com>
    Signed-off-by: Shuah Khan <shuahkh@osg.samsung.com>

commit 03438212d0b0ea2cf201e921c9056f683c624ffb
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Mar 11 17:39:57 2015 -0700

    selftests/timers: Cleanup Makefile to make it easier to add future tests
    
    Try to streamline the makefile so its easier to add timer/timekeeping
    tests.
    
    Also adds support for the CROSS_COMPILE variable.
    
    Cc: Shuah Khan <shuahkh@osg.samsung.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Tested-by: Prarit Bhargava <prarit@redhat.com>
    Signed-off-by: Shuah Khan <shuahkh@osg.samsung.com>

commit 99fa0ad92c4fd8b529c89b3640b42323984be761
Merge: 1d9e71404e2c 5f5081852038
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Feb 17 14:17:51 2015 -0800

    Merge tag 'suspend-to-idle-3.20-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull suspend-to-idle updates from Rafael Wysocki:
     "Suspend-to-idle timer quiescing support for v3.20-rc1
    
      Until now suspend-to-idle has not been able to save much more energy
      than runtime PM because of timer interrupts that periodically bring
      CPUs out of idle while they are waiting for a wakeup interrupt.  Of
      course, the timer interrupts are not wakeup ones, so the handling of
      them can be deferred until a real wakeup interrupt happens, but at the
      same time we don't want to mass-expire timers at that point.
    
      The solution is to suspend the entire timekeeping when the last CPU is
      entering an idle state and resume it when the first CPU goes out of
      idle.  That has to be done with care, though, so as to avoid accessing
      suspended clocksources etc.  end we need extra support from idle
      drivers for that.
    
      This series of commits adds support for quiescing timers during
      suspend-to-idle and adds the requisite callbacks to intel_idle and the
      ACPI cpuidle driver"
    
    * tag 'suspend-to-idle-3.20-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm:
      ACPI / idle: Implement ->enter_freeze callback routine
      intel_idle: Add ->enter_freeze callbacks
      PM / sleep: Make it possible to quiesce timers during suspend-to-idle
      timekeeping: Make it safe to use the fast timekeeper while suspended
      timekeeping: Pass readout base to update_fast_timekeeper()
      PM / sleep: Re-implement suspend-to-idle handling

commit 124cf9117c5f93cc5b324530b7e105b09c729d5d
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Feb 13 23:50:43 2015 +0100

    PM / sleep: Make it possible to quiesce timers during suspend-to-idle
    
    The efficiency of suspend-to-idle depends on being able to keep CPUs
    in the deepest available idle states for as much time as possible.
    Ideally, they should only be brought out of idle by system wakeup
    interrupts.
    
    However, timer interrupts occurring periodically prevent that from
    happening and it is not practical to chase all of the "misbehaving"
    timers in a whack-a-mole fashion.  A much more effective approach is
    to suspend the local ticks for all CPUs and the entire timekeeping
    along the lines of what is done during full suspend, which also
    helps to keep suspend-to-idle and full suspend reasonably similar.
    
    The idea is to suspend the local tick on each CPU executing
    cpuidle_enter_freeze() and to make the last of them suspend the
    entire timekeeping.  That should prevent timer interrupts from
    triggering until an IO interrupt wakes up one of the CPUs.  It
    needs to be done with interrupts disabled on all of the CPUs,
    though, because otherwise the suspended clocksource might be
    accessed by an interrupt handler which might lead to fatal
    consequences.
    
    Unfortunately, the existing ->enter callbacks provided by cpuidle
    drivers generally cannot be used for implementing that, because some
    of them re-enable interrupts temporarily and some idle entry methods
    cause interrupts to be re-enabled automatically on exit.  Also some
    of these callbacks manipulate local clock event devices of the CPUs
    which really shouldn't be done after suspending their ticks.
    
    To overcome that difficulty, introduce a new cpuidle state callback,
    ->enter_freeze, that will be guaranteed (1) to keep interrupts
    disabled all the time (and return with interrupts disabled) and (2)
    not to touch the CPU timer devices.  Modify cpuidle_enter_freeze() to
    look for the deepest available idle state with ->enter_freeze present
    and to make the CPU execute that callback with suspended tick (and the
    last of the online CPUs to execute it with suspended timekeeping).
    
    Suggested-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>

commit 060407aed56c00960c9b5f70f5d19b2823adffd7
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Feb 13 14:49:02 2015 +0100

    timekeeping: Make it safe to use the fast timekeeper while suspended
    
    Theoretically, ktime_get_mono_fast_ns() may be executed after
    timekeeping has been suspended (or before it is resumed) which
    in turn may lead to undefined behavior, for example, when the
    clocksource read from timekeeping_get_ns() called by it is
    not accessible at that time.
    
    Prevent that from happening by setting up a dummy readout base for
    the fast timekeeper during timekeeping_suspend() such that it will
    always return the same number of cycles.
    
    After the last timekeeping_update() in timekeeping_suspend() the
    clocksource is read and the result is stored as cycles_at_suspend.
    The readout base from the current timekeeper is copied onto the
    dummy and the ->read pointer of the dummy is set to a routine
    unconditionally returning cycles_at_suspend.  Next, the dummy is
    passed to update_fast_timekeeper().
    
    Then, ktime_get_mono_fast_ns() will work until the subsequent
    timekeeping_resume() and the proper readout base for the fast
    timekeeper will be restored by the timekeeping_update() called
    right after clearing timekeeping_suspended.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: John Stultz <john.stultz@linaro.org>
    Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>

commit affe3e85ae78507cc953f3f700e0644e50844cff
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Feb 11 05:01:52 2015 +0100

    timekeeping: Pass readout base to update_fast_timekeeper()
    
    Modify update_fast_timekeeper() to take a struct tk_read_base
    pointer as its argument (instead of a struct timekeeper pointer)
    and update its kerneldoc comment to reflect that.
    
    That will allow a struct tk_read_base that is not part of a
    struct timekeeper to be passed to it in the next patch.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Acked-by: John Stultz <john.stultz@linaro.org>

commit 41cbc01f6e49e48bc3d78158cec0a2d4ff6c906d
Merge: 12df4289ee8e 1e0d6714aceb
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Feb 12 08:37:41 2015 -0800

    Merge tag 'trace-v3.20' of git://git.kernel.org/pub/scm/linux/kernel/git/rostedt/linux-trace
    
    Pull tracing updates from Steven Rostedt:
     "The updates included in this pull request for ftrace are:
    
       o Several clean ups to the code
    
         One such clean up was to convert to 64 bit time keeping, in the
         ring buffer benchmark code.
    
       o Adding of __print_array() helper macro for TRACE_EVENT()
    
       o Updating the sample/trace_events/ to add samples of different ways
         to make trace events.  Lots of features have been added since the
         sample code was made, and these features are mostly unknown.
         Developers have been making their own hacks to do things that are
         already available.
    
       o Performance improvements.  Most notably, I found a performance bug
         where a waiter that is waiting for a full page from the ring buffer
         will see that a full page is not available, and go to sleep.  The
         sched event caused by it going to sleep would cause it to wake up
         again.  It would see that there was still not a full page, and go
         back to sleep again, and that would wake it up again, until finally
         it would see a full page.  This change has been marked for stable.
    
      Other improvements include removing global locks from fast paths"
    
    * tag 'trace-v3.20' of git://git.kernel.org/pub/scm/linux/kernel/git/rostedt/linux-trace:
      ring-buffer: Do not wake up a splice waiter when page is not full
      tracing: Fix unmapping loop in tracing_mark_write
      tracing: Add samples of DECLARE_EVENT_CLASS() and DEFINE_EVENT()
      tracing: Add TRACE_EVENT_FN example
      tracing: Add TRACE_EVENT_CONDITION sample
      tracing: Update the TRACE_EVENT fields available in the sample code
      tracing: Separate out initializing top level dir from instances
      tracing: Make tracing_init_dentry_tr() static
      trace: Use 64-bit timekeeping
      tracing: Add array printing helper
      tracing: Remove newline from trace_printk warning banner
      tracing: Use IS_ERR() check for return value of tracing_init_dentry()
      tracing: Remove unneeded includes of debugfs.h and fs.h
      tracing: Remove taking of trace_types_lock in pipe files
      tracing: Add ref count to tracer for when they are being read by pipe

commit 3e8c04eb117445d67ae2b83e08bec4005129356a
Merge: 44dbf058de9f b12aa1f25e1d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Feb 9 19:40:42 2015 -0800

    Merge branch 'for-3.20' of git://git.kernel.org/pub/scm/linux/kernel/git/tj/libata
    
    Pull libata changes from Tejun Heo:
     "Mostly driver-specific changes.  Nothing too noteworthy.
    
      This pull request contains three merges from for-3.19-fixes.  The
      first two are to pull ahci_xgene and sata_dwc_460ex fix commits which
      are depended upon by later changes.  The last one is to pull in a fix
      patch which missed the v3.19-rc window"
    
    * 'for-3.20' of git://git.kernel.org/pub/scm/linux/kernel/git/tj/libata: (24 commits)
      ahci_xgene: Fix the dma state machine lockup for the ATA_CMD_SMART PIO mode command.
      ata: libahci: Use of_platform_device_create only if supported
      sata_mv: Delete unnecessary checks before the function call "phy_power_off"
      ata: Delete unnecessary checks before the function call "pci_dev_put"
      ata: pata_platform: fix owner module reference mismatch for scsi host
      ata: ahci_platform: fix owner module reference mismatch for scsi host
      pata_pdc2027x: Use 64-bit timekeeping
      ata: libahci: Fix devres cleanup on failure
      ata: libahci: Allow using multiple regulators
      Documentation: bindings: Add the regulator property to the sub-nodes AHCI bindings
      ata: libahci: Clean-up the ahci_platform_en/disable_phys functions
      sata_rcar: extend PM methods
      sata_dwc_460ex: disable compilation on ARM and ARM64
      ata: libata-core: Remove unused function
      sata_dwc_460ex: convert to devm_kzalloc in ->probe()
      sata_dwc_460ex: remove extra message
      sata_dwc_460ex: use np local variable in ->probe()
      sata_dwc_460ex: fix most of the sparse warnings
      sata_dwc_460ex: enable COMPILE_TEST for the driver
      sata_dwc_460ex: remove redundant dev_set_drvdata
      ...

commit da194930ede6d87945786f72b1c36c7a4ed0f3a6
Author: Tina Ruchandani <ruchandani.tina@gmail.com>
Date:   Wed Jan 28 19:46:11 2015 +0530

    trace: Use 64-bit timekeeping
    
    The ring_buffer_producer uses 'struct timeval' to measure
    its start and end times. 'struct timeval' on 32-bit systems
    will have its tv_sec value overflow in year 2038 and beyond.
    This patch replaces struct timeval with 'ktime_t' which uses
    64-bit representation for nanoseconds.
    
    Link: http://lkml.kernel.org/r/20150128141611.GA2701@tinar
    
    Suggested-by: Arnd Bergmann <arnd@arndb.de>
    Suggested-by: Steven Rostedt <rostedt@goodmis.org>
    Signed-off-by: Tina Ruchandani <ruchandani.tina@gmail.com>
    Signed-off-by: Steven Rostedt <rostedt@goodmis.org>

commit cedda4c3b1ded2cc4951aeca38fdf862b9b79fb6
Author: Tina Ruchandani <ruchandani.tina@gmail.com>
Date:   Tue Jan 27 15:49:48 2015 +0530

    pata_pdc2027x: Use 64-bit timekeeping
    
    Function pdc_detect_pll_input_clock uses 'struct timeval'
    to measure start and end times, used to compute the pll_clock value.
    'struct timeval' on 32-bit systems will have its tv_sec field
    overflow in year 2038 and beyond. This patch uses 'ktime_t'
    (which uses 64 bits for seconds) for start and end times instead.
    
    Suggested-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Tina Ruchandani <ruchandani.tina@gmail.com>
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Tejun Heo <tj@kernel.org>

commit fe31fca35d6af9176eec0024fac2ceeaacbc8639
Merge: 9bc7491906b4 9a4a445e30f0
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jan 24 10:11:12 2015 +0100

    Merge tag 'fortglx-3.20-time' of https://git.linaro.org/people/john.stultz/linux into timers/core
    
    Pull time updates from John Stultz for 3.20:
    
     * ktime division optimization
     * Expose a few more y2038-safe timekeeping interfaces
     * RTC core changes to address y2038

commit 566b5cfb035fb496280be61f976b5281563bfa27
Author: Namhyung Kim <namhyung@kernel.org>
Date:   Thu Jan 8 09:45:48 2015 +0900

    perf diff: Fix -o/--order option behavior
    
    The prior change fixes default output ordering with each column but it
    breaks -o/--order option.  This patch prepends a new hpp fmt struct to
    sort list but not to output field list so that it can affect ordering
    without adding a new output column.
    
    The new hpp fmt uses its own compare functions which treats dummy
    entries (which have no baseline) little differently - the delta field
    can be computed without baseline but others (ratio and wdiff) are not.
    
    The new output will look like below:
    
      $ perf diff -o 2 perf.data.{old,cur,new}
      ...
      # Baseline/0  Delta/1  Delta/2  Shared Object      Symbol
      # ..........  .......  .......  .................  ..........................................
            22.98%   +0.51%   +0.52%  libc-2.20.so       [.] _int_malloc
             5.70%   +0.28%   +0.30%  libc-2.20.so       [.] free
             4.38%   -0.21%   +0.25%  a.out              [.] main
             1.32%   -0.15%   +0.05%  a.out              [.] free@plt
                              +0.01%  [kernel.kallsyms]  [k] intel_pstate_timer_func
                              +0.01%  [kernel.kallsyms]  [k] _raw_spin_lock_irqsave
                              +0.01%  [kernel.kallsyms]  [k] timekeeping_update.constprop.8
                     +0.01%   +0.01%  [kernel.kallsyms]  [k] apic_timer_interrupt
             0.01%            -0.00%  [kernel.kallsyms]  [k] native_read_msr_safe
             0.01%   -0.01%   -0.01%  [kernel.kallsyms]  [k] native_write_msr_safe
             1.31%   +0.03%   -0.06%  a.out              [.] malloc@plt
            31.50%   -0.74%   -0.23%  libc-2.20.so       [.] _int_free
            32.75%   +0.28%   -0.83%  libc-2.20.so       [.] malloc
             0.01%                    [kernel.kallsyms]  [k] scheduler_tick
                     +0.01%           [kernel.kallsyms]  [k] read_tsc
                     +0.01%           [kernel.kallsyms]  [k] perf_adjust_freq_unthr_context.part.82
    
    In above example, the output was sorted by 'Delta/2' column first, and
    then 'Baseline/0' and finally 'Delta/1'.
    
    Signed-off-by: Namhyung Kim <namhyung@kernel.org>
    Acked-by: Jiri Olsa <jolsa@kernel.org>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Kan Liang <kan.liang@intel.com>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Link: http://lkml.kernel.org/r/1420677949-6719-8-git-send-email-namhyung@kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

commit 56495a8affabe35aa0d94aae050d3e0e60d0455f
Author: Namhyung Kim <namhyung@kernel.org>
Date:   Thu Jan 8 09:45:47 2015 +0900

    perf diff: Fix output ordering to honor next column
    
    When perf diff prints output, it sorts the entries using baseline field
    by default, but entries which don't have baseline are not sorted
    properly.  This patch makes it sorted by values of next column.
    
    Before:
    
      # Baseline/0  Delta/1  Delta/2  Shared Object      Symbol
      # ..........  .......  .......  .................  ..........................................
      #
            32.75%   +0.28%   -0.83%  libc-2.20.so       [.] malloc
            31.50%   -0.74%   -0.23%  libc-2.20.so       [.] _int_free
            22.98%   +0.51%   +0.52%  libc-2.20.so       [.] _int_malloc
             5.70%   +0.28%   +0.30%  libc-2.20.so       [.] free
             4.38%   -0.21%   +0.25%  a.out              [.] main
             1.32%   -0.15%   +0.05%  a.out              [.] free@plt
             1.31%   +0.03%   -0.06%  a.out              [.] malloc@plt
             0.01%   -0.01%   -0.01%  [kernel.kallsyms]  [k] native_write_msr_safe
             0.01%                    [kernel.kallsyms]  [k] scheduler_tick
             0.01%            -0.00%  [kernel.kallsyms]  [k] native_read_msr_safe
                              +0.01%  [kernel.kallsyms]  [k] _raw_spin_lock_irqsave
                     +0.01%   +0.01%  [kernel.kallsyms]  [k] apic_timer_interrupt
                              +0.01%  [kernel.kallsyms]  [k] intel_pstate_timer_func
                     +0.01%           [kernel.kallsyms]  [k] perf_adjust_freq_unthr_context.part.82
                     +0.01%           [kernel.kallsyms]  [k] read_tsc
                              +0.01%  [kernel.kallsyms]  [k] timekeeping_update.constprop.8
    
    After:
    
      # Baseline/0  Delta/1  Delta/2  Shared Object      Symbol
      # ..........  .......  .......  .................  ..........................................
      #
            32.75%   +0.28%   -0.83%  libc-2.20.so       [.] malloc
            31.50%   -0.74%   -0.23%  libc-2.20.so       [.] _int_free
            22.98%   +0.51%   +0.52%  libc-2.20.so       [.] _int_malloc
             5.70%   +0.28%   +0.30%  libc-2.20.so       [.] free
             4.38%   -0.21%   +0.25%  a.out              [.] main
             1.32%   -0.15%   +0.05%  a.out              [.] free@plt
             1.31%   +0.03%   -0.06%  a.out              [.] malloc@plt
             0.01%   -0.01%   -0.01%  [kernel.kallsyms]  [k] native_write_msr_safe
             0.01%                    [kernel.kallsyms]  [k] scheduler_tick
             0.01%            -0.00%  [kernel.kallsyms]  [k] native_read_msr_safe
                     +0.01%   +0.01%  [kernel.kallsyms]  [k] apic_timer_interrupt
                     +0.01%           [kernel.kallsyms]  [k] read_tsc
                     +0.01%           [kernel.kallsyms]  [k] perf_adjust_freq_unthr_context.part.82
                              +0.01%  [kernel.kallsyms]  [k] intel_pstate_timer_func
                              +0.01%  [kernel.kallsyms]  [k] _raw_spin_lock_irqsave
                              +0.01%  [kernel.kallsyms]  [k] timekeeping_update.constprop.8
    
    Signed-off-by: Namhyung Kim <namhyung@kernel.org>
    Acked-by: Jiri Olsa <jolsa@kernel.org>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Kan Liang <kan.liang@intel.com>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Link: http://lkml.kernel.org/r/1420677949-6719-7-git-send-email-namhyung@kernel.org
    [ Fixed up hist_entry__cmp_ method signatures, fallout from making previous cset buildable ]
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

commit d82012695ef29e4e1c8153ccf43098ec8e50369e
Merge: 3eb5b893ebec dbe7aa622db9
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Dec 10 10:13:28 2014 -0800

    Merge branch 'timers-2038-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull more 2038 timer work from Thomas Gleixner:
     "Two more patches for the ongoing 2038 work:
    
       - New accessors to clock MONOTONIC and REALTIME seconds
    
      This is a seperate branch as Arnd has follow up work depending on
      this"
    
    * 'timers-2038-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      timekeeping: Provide y2038 safe accessor to the seconds portion of CLOCK_REALTIME
      timekeeping: Provide fast accessor to the seconds part of CLOCK_MONOTONIC

commit a157508c9790ccd1c8b5c6a828d6ba85bbe95aaa
Merge: 86c6a2fddf0b 89de77a8c557
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Dec 10 08:18:32 2014 -0800

    Merge branch 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer core updates from Thomas Gleixner:
     "The time(r) departement provides:
    
       - more infrastructure work on the year 2038 issue
    
       - a few fixes in the Armada SoC timers
    
       - the usual pile of fixlets and improvements"
    
    * 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      clocksource: armada-370-xp: Use the reference clock on A375 SoC
      watchdog: orion: Use the reference clock on Armada 375 SoC
      clocksource: armada-370-xp: Add missing clock enable
      time: Fix sign bug in NTP mult overflow warning
      time: Remove timekeeping_inject_sleeptime()
      rtc: Update suspend/resume timing to use 64bit time
      rtc/lib: Provide y2038 safe rtc_tm_to_time()/rtc_time_to_tm() replacement
      time: Fixup comments to reflect usage of timespec64
      time: Expose get_monotonic_coarse64() for in-kernel uses
      time: Expose getrawmonotonic64 for in-kernel uses
      time: Provide y2038 safe mktime() replacement
      time: Provide y2038 safe timekeeping_inject_sleeptime() replacement
      time: Provide y2038 safe do_settimeofday() replacement
      time: Complete NTP adjustment threshold judging conditions
      time: Avoid possible NTP adjustment mult overflow.
      time: Rename udelay_test.c to test_udelay.c
      clocksource: sirf: Remove hard-coded clock rate

commit e292ccde216e571faad475e4331c188f22a28182
Author: Huacai Chen <chenhuacai@kernel.org>
Date:   Tue Nov 4 14:15:31 2014 +0800

    MIPS: Loongson-3: Add RS780/SBX00 HPET support
    
    CPUFreq driver need external timer, so add hpet at first.
    
    In Loongson 3, only Core-0 can receive external interrupt. As a result,
    timekeeping cannot absolutely use HPET timer. We use a hybrid solution:
    Core-0 use HPET as its clock event device, but other cores still use
    MIPS; clock source is global and doesn't need interrupt, so use HPET.
    
    Signed-off-by: Huacai Chen <chenhc@lemote.com>
    Signed-off-by: Hongliang Tao <taohl@lemote.com>
    Cc: John Crispin <john@phrozen.org>
    Cc: Steven J. Hill <Steven.Hill@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Cc: Fuxin Zhang <zhangfx@lemote.com>
    Cc: Zhangjin Wu <wuzhangjin@gmail.com>
    Patchwork: https://patchwork.linux-mips.org/patch/8329/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

commit 21b6c0512e8aca75ce76365e1aef9fb16e007100
Author: John Stultz <john.stultz@linaro.org>
Date:   Thu Nov 20 21:19:15 2014 -0800

    time: Remove timekeeping_inject_sleeptime()
    
    Since all users have been converted to using the 64bit
    timekeeping_inject_sleeptime64(), remove the old y2038
    problematic timekeeping_inject_sleeptime().
    
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 04d9089086a8231ddc69a9f3f25e971a3c1d25e6
Author: pang.xunlei <pang.xunlei@linaro.org>
Date:   Tue Nov 18 19:15:17 2014 +0800

    time: Provide y2038 safe timekeeping_inject_sleeptime() replacement
    
    As part of addressing "y2038 problem" for in-kernel uses, this
    patch adds timekeeping_inject_sleeptime64() using timespec64.
    
    After this patch, timekeeping_inject_sleeptime() is deprecated
    and all its call sites will be fixed using the new interface,
    after that it can be removed.
    
    NOTE: timekeeping_inject_sleeptime() is safe actually, but we
    want to eliminate timespec eventually, so comes this patch.
    
    Signed-off-by: pang.xunlei <pang.xunlei@linaro.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 659bc17b80c692e0ccda757e207fc4666d9b3e71
Author: pang.xunlei <pang.xunlei@linaro.org>
Date:   Thu Oct 9 15:04:31 2014 +0800

    time: Complete NTP adjustment threshold judging conditions
    
    The clocksource mult-adjustment threshold is [mult-maxadj, mult+maxadj],
    timekeeping_adjust() only deals with the upper threshold, but misses the
    lower threshold.
    
    This patch adds the lower threshold judging condition.
    
    Signed-off-by: pang.xunlei <pang.xunlei@linaro.org>
    [jstultz: Minor fix for > 80 char line]
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 6067dc5a8c2b1b57e67eaf1125db1d63c1ed6361
Author: pang.xunlei <pang.xunlei@linaro.org>
Date:   Wed Oct 8 15:03:34 2014 +0800

    time: Avoid possible NTP adjustment mult overflow.
    
    Ideally, __clocksource_updatefreq_scale, selects the largest shift
    value possible for a clocksource. This results in the mult memember of
    struct clocksource being particularly large, although not so large
    that NTP would adjust the clock to cause it to overflow.
    
    That said, nothing actually prohibits an overflow from occuring, its
    just that it "shouldn't" occur.
    
    So while very unlikely, and so far never observed, the value of
    (cs->mult+cs->maxadj) may have a chance to reach very near 0xFFFFFFFF,
    so there is a possibility it may overflow when doing NTP positive
    adjustment
    
    See the following detail: When NTP slewes the clock, kernel goes
    through update_wall_time()->...->timekeeping_apply_adjustment():
            tk->tkr.mult += mult_adj;
    
    Since there is no guard against it, its possible tk->tkr.mult may
    overflow during this operation.
    
    This patch avoids any possible mult overflow by judging the overflow
    case before adding mult_adj to mult, also adds the WARNING message
    when capturing such case.
    
    Signed-off-by: pang.xunlei <pang.xunlei@linaro.org>
    [jstultz: Reworded commit message]
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit eafe8404c103b3051b6421fc17e0e8b91d369f0b
Author: Tina Ruchandani <ruchandani.tina@gmail.com>
Date:   Wed Oct 29 10:48:10 2014 -0700

    ALSA: es1968: Replace timeval with ktime_t
    
    es1968_measure_clock uses struct timeval, which on 32-bit systems will overflow
    in 2038, leading to incorrect interpretation of time.This patch changes the
    function to use ktime_t instead of struct timeval, which implies:
    - no y2038: ktime_t uses a 64-bit datatype explicitly.
    - efficent subtraction: The earlier version computes the difference in usecs
      while dealing with secs and nsecs. It requires checks to see if the nsecs of
      stop is less than start. This patch uses a direct subtract of ktime_t and
      converts to usecs.
    - use of monotonic clock (ktime_get) over real time (do_gettimeofday),
      which simplifies timekeeping, as it does not have to deal with cases
      where stop_time is less than start_time.
    
    Signed-off-by: Tina Ruchandani <ruchandani.tina@gmail.com>
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

commit dbe7aa622db96b5cd601f59d09c4f00b98b76079
Author: Heena Sirwani <heenasirwani@gmail.com>
Date:   Wed Oct 29 16:01:50 2014 +0530

    timekeeping: Provide y2038 safe accessor to the seconds portion of CLOCK_REALTIME
    
    ktime_get_real_seconds() is the replacement function for get_seconds()
    returning the seconds portion of CLOCK_REALTIME in a time64_t. For
    64bit the function is equivivalent to get_seconds(), but for 32bit it
    protects the readout with the timekeeper sequence count. This is
    required because 32-bit machines cannot access 64-bit tk->xtime_sec
    variable atomically.
    
    [tglx: Massaged changelog and added docbook comment ]
    
    Signed-off-by: Heena Sirwani <heenasirwani@gmail.com>
    Reviewed-by: Arnd Bergman <arnd@arndb.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: opw-kernel@googlegroups.com
    Link: http://lkml.kernel.org/r/7adcfaa8962b8ad58785d9a2456c3f77d93c0ffb.1414578445.git.heenasirwani@gmail.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 9e3680b1750b9a62680b0262c9f438de98b77655
Author: Heena Sirwani <heenasirwani@gmail.com>
Date:   Wed Oct 29 16:01:16 2014 +0530

    timekeeping: Provide fast accessor to the seconds part of CLOCK_MONOTONIC
    
    This is the counterpart to get_seconds() based on CLOCK_MONOTONIC. The
    use case for this interface are kernel internal coarse grained
    timestamps which do neither require the nanoseconds fraction of
    current time nor the CLOCK_REALTIME properties. Such timestamps can
    currently only retrieved by calling ktime_get_ts64() and using the
    tv_sec field of the returned timespec64. That's inefficient as it
    involves the read of the clocksource, math operations and must be
    protected by the timekeeper sequence counter.
    
    To avoid the sequence counter protection we restrict the return value
    to unsigned 32bit on 32bit machines. This covers ~136 years of uptime
    and therefor an overflow is not expected to hit anytime soon.
    
    To avoid math in the function we calculate the current seconds portion
    of CLOCK_MONOTONIC when the timekeeper gets updated in
    tk_update_ktime_data() similar to the CLOCK_REALTIME counterpart
    xtime_sec.
    
    [ tglx: Massaged changelog, simplified and commented the update
            function, added docbook comment ]
    
    Signed-off-by: Heena Sirwani <heenasirwani@gmail.com>
    Reviewed-by: Arnd Bergman <arnd@arndb.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: opw-kernel@googlegroups.com
    Link: http://lkml.kernel.org/r/da0b63f4bdf3478909f92becb35861197da3a905.1414578445.git.heenasirwani@gmail.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit ebc54f278f496798a3ea1df9ae29c1055e9de95e
Merge: 2b12164b55e7 9bf2419fa7bf
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Sep 7 10:37:48 2014 -0700

    Merge branch 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer fixes from Thomas Gleixner:
     "Three fixlets from the timer departement:
    
       - Update the timekeeper before updating vsyscall and pvclock.  This
         fixes the kvm-clock regression reported by Chris and Paolo.
    
       - Use the proper irq work interface from NMI.  This fixes the
         regression reported by Catalin and Dave.
    
       - Clarify the compat_nanosleep error handling mechanism to avoid
         future confusion"
    
    * 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      timekeeping: Update timekeeper before updating vsyscall and pvclock
      compat: nanosleep: Clarify error handling
      nohz: Restore NMI safe local irq work for local nohz kick

commit 9bf2419fa7bffa16ce58a4d5c20399eff8c970c9
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Sep 6 12:24:49 2014 +0200

    timekeeping: Update timekeeper before updating vsyscall and pvclock
    
    The update_walltime() code works on the shadow timekeeper to make the
    seqcount protected region as short as possible. But that update to the
    shadow timekeeper does not update all timekeeper fields because it's
    sufficient to do that once before it becomes life. One of these fields
    is tkr.base_mono. That stays stale in the shadow timekeeper unless an
    operation happens which copies the real timekeeper to the shadow.
    
    The update function is called after the update calls to vsyscall and
    pvclock. While not correct, it did not cause any problems because none
    of the invoked update functions used base_mono.
    
    commit cbcf2dd3b3d4 (x86: kvm: Make kvm_get_time_and_clockread()
    nanoseconds based) changed that in the kvm pvclock update function, so
    the stale mono_base value got used and caused kvm-clock to malfunction.
    
    Put the update where it belongs and fix the issue.
    
    Reported-by: Chris J Arges <chris.j.arges@canonical.com>
    Reported-by: Paolo Bonzini <pbonzini@redhat.com>
    Cc: Gleb Natapov <gleb@kernel.org>
    Cc: John Stultz <john.stultz@linaro.org>
    Link: http://lkml.kernel.org/r/alpine.DEB.2.10.1409050000570.3333@nanos
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit d6a1cfb5f64485010bb0429a7bcb899b96ee92e9
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Jun 4 16:11:40 2014 -0700

    printk: rename printk_sched to printk_deferred
    
    commit aac74dc495456412c4130a1167ce4beb6c1f0b38 upstream.
    
    After learning we'll need some sort of deferred printk functionality in
    the timekeeping core, Peter suggested we rename the printk_sched function
    so it can be reused by needed subsystems.
    
    This only changes the function name. No logic changes.
    
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Reviewed-by: Steven Rostedt <rostedt@goodmis.org>
    Cc: Jan Kara <jack@suse.cz>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Jiri Bohac <jbohac@suse.cz>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>

commit 0680eb1f485ba5aac2ee02c9f0622239c9a4b16c
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Aug 13 12:47:14 2014 -0700

    timekeeping: Another fix to the VSYSCALL_OLD update_vsyscall
    
    Benjamin Herrenschmidt pointed out that I further missed modifying
    update_vsyscall after the wall_to_mono value was changed to a
    timespec64.  This causes issues on powerpc32, which expects a 32bit
    timespec.
    
    This patch fixes the problem by properly converting from a timespec64 to
    a timespec before passing the value on to the arch-specific vsyscall
    logic.
    
    [ Thomas is currently on vacation, but reviewed it and wanted me to send
      this fix on to you directly. ]
    
    Cc: LKML <linux-kernel@vger.kernel.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Reported-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit 3a5e0137b5d7c58f6eb66a263fc66965b758b76f
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Jun 4 16:11:40 2014 -0700

    printk: rename printk_sched to printk_deferred
    
    commit aac74dc495456412c4130a1167ce4beb6c1f0b38 upstream.
    
    After learning we'll need some sort of deferred printk functionality in
    the timekeeping core, Peter suggested we rename the printk_sched function
    so it can be reused by needed subsystems.
    
    This only changes the function name. No logic changes.
    
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Reviewed-by: Steven Rostedt <rostedt@goodmis.org>
    Cc: Jan Kara <jack@suse.cz>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Jiri Bohac <jbohac@suse.cz>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit a8554e0d8b51719e1bb90855a242533fecb4dbdc
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Jun 4 16:11:40 2014 -0700

    printk: rename printk_sched to printk_deferred
    
    commit aac74dc495456412c4130a1167ce4beb6c1f0b38 upstream.
    
    After learning we'll need some sort of deferred printk functionality in
    the timekeeping core, Peter suggested we rename the printk_sched function
    so it can be reused by needed subsystems.
    
    This only changes the function name. No logic changes.
    
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Reviewed-by: Steven Rostedt <rostedt@goodmis.org>
    Cc: Jan Kara <jack@suse.cz>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Jiri Bohac <jbohac@suse.cz>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 3984bb13c8f5f2f192aed228a88696d4a697a435
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Jun 4 16:11:40 2014 -0700

    printk: rename printk_sched to printk_deferred
    
    commit aac74dc495456412c4130a1167ce4beb6c1f0b38 upstream.
    
    After learning we'll need some sort of deferred printk functionality in
    the timekeeping core, Peter suggested we rename the printk_sched function
    so it can be reused by needed subsystems.
    
    This only changes the function name. No logic changes.
    
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Reviewed-by: Steven Rostedt <rostedt@goodmis.org>
    Cc: Jan Kara <jack@suse.cz>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Jiri Bohac <jbohac@suse.cz>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit f73ff697833654ee578b606ea746d15dc1220aab
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Jun 4 16:11:40 2014 -0700

    printk: rename printk_sched to printk_deferred
    
    commit aac74dc495456412c4130a1167ce4beb6c1f0b38 upstream.
    
    After learning we'll need some sort of deferred printk functionality in
    the timekeeping core, Peter suggested we rename the printk_sched function
    so it can be reused by needed subsystems.
    
    This only changes the function name. No logic changes.
    
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Reviewed-by: Steven Rostedt <rostedt@goodmis.org>
    Cc: Jan Kara <jack@suse.cz>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Jiri Bohac <jbohac@suse.cz>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit e7fda6c4c3c1a7d6996dd75fd84670fa0b5d448f
Merge: 08d69a257144 953dec21aed4
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Aug 5 17:46:42 2014 -0700

    Merge branch 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer and time updates from Thomas Gleixner:
     "A rather large update of timers, timekeeping & co
    
       - Core timekeeping code is year-2038 safe now for 32bit machines.
         Now we just need to fix all in kernel users and the gazillion of
         user space interfaces which rely on timespec/timeval :)
    
       - Better cache layout for the timekeeping internal data structures.
    
       - Proper nanosecond based interfaces for in kernel users.
    
       - Tree wide cleanup of code which wants nanoseconds but does hoops
         and loops to convert back and forth from timespecs.  Some of it
         definitely belongs into the ugly code museum.
    
       - Consolidation of the timekeeping interface zoo.
    
       - A fast NMI safe accessor to clock monotonic for tracing.  This is a
         long standing request to support correlated user/kernel space
         traces.  With proper NTP frequency correction it's also suitable
         for correlation of traces accross separate machines.
    
       - Checkpoint/restart support for timerfd.
    
       - A few NOHZ[_FULL] improvements in the [hr]timer code.
    
       - Code move from kernel to kernel/time of all time* related code.
    
       - New clocksource/event drivers from the ARM universe.  I'm really
         impressed that despite an architected timer in the newer chips SoC
         manufacturers insist on inventing new and differently broken SoC
         specific timers.
    
    [ Ed. "Impressed"? I don't think that word means what you think it means ]
    
       - Another round of code move from arch to drivers.  Looks like most
         of the legacy mess in ARM regarding timers is sorted out except for
         a few obnoxious strongholds.
    
       - The usual updates and fixlets all over the place"
    
    * 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (114 commits)
      timekeeping: Fixup typo in update_vsyscall_old definition
      clocksource: document some basic timekeeping concepts
      timekeeping: Use cached ntp_tick_length when accumulating error
      timekeeping: Rework frequency adjustments to work better w/ nohz
      timekeeping: Minor fixup for timespec64->timespec assignment
      ftrace: Provide trace clocks monotonic
      timekeeping: Provide fast and NMI safe access to CLOCK_MONOTONIC
      seqcount: Add raw_write_seqcount_latch()
      seqcount: Provide raw_read_seqcount()
      timekeeping: Use tk_read_base as argument for timekeeping_get_ns()
      timekeeping: Create struct tk_read_base and use it in struct timekeeper
      timekeeping: Restructure the timekeeper some more
      clocksource: Get rid of cycle_last
      clocksource: Move cycle_last validation to core code
      clocksource: Make delta calculation a function
      wireless: ath9k: Get rid of timespec conversions
      drm: vmwgfx: Use nsec based interfaces
      drm: i915: Use nsec based interfaces
      timekeeping: Provide ktime_get_raw()
      hangcheck-timer: Use ktime_get_ns()
      ...

commit 953dec21aed4038464fec02f96a2f1b8701a5bce
Author: John Stultz <john.stultz@linaro.org>
Date:   Fri Jul 25 21:37:19 2014 -0700

    timekeeping: Fixup typo in update_vsyscall_old definition
    
    In commit 4a0e637738f0 ("clocksource: Get rid of cycle_last"),
    currently in the -tip tree, there was a small typo where cycles_t
    was used intstead of cycle_t. This broke ppc64 builds.
    
    Fix this by using the proper cycle_t type for this usage, in
    both the definition and the ia64 implementation.
    
    Now, having both cycle_t and cycles_t types seems like a very
    bad idea just asking for these sorts of issues. But that
    will be a cleanup for another day.
    
    Reported-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/1406349439-11785-1-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 7806f60e1d205db46eca6ad24429b3f86eda2588
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Thu Jul 10 09:52:27 2014 +0200

    clocksource: document some basic timekeeping concepts
    
    This adds some documentation about clock sources, clock events,
    the weak sched_clock() function and delay timers that answers
    questions that repeatedly arise on the mailing lists.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Nicolas Pitre <nico@fluxnic.net>
    Cc: Colin Cross <ccross@google.com>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 375f45b5b53a91dfa8f0c11328e0e044f82acbed
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Apr 23 20:53:29 2014 -0700

    timekeeping: Use cached ntp_tick_length when accumulating error
    
    By caching the ntp_tick_length() when we correct the frequency error,
    and then using that cached value to accumulate error, we avoid large
    initial errors when the tick length is changed.
    
    This makes convergence happen much faster in the simulator, since the
    initial error doesn't have to be slowly whittled away.
    
    This initially seems like an accounting error, but Miroslav pointed out
    that ntp_tick_length() can change mid-tick, so when we apply it in the
    error accumulation, we are applying any recent change to the entire tick.
    
    This approach chooses to apply changes in the ntp_tick_length() only to
    the next tick, which allows us to calculate the freq correction before
    using the new tick length, which avoids accummulating error.
    
    Credit to Miroslav for pointing this out and providing the original patch
    this functionality has been pulled out from, along with the rational.
    
    Cc: Miroslav Lichvar <mlichvar@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Reported-by: Miroslav Lichvar <mlichvar@redhat.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit dc491596f6394382fbc74ad331156207d619fa0a
Author: John Stultz <john.stultz@linaro.org>
Date:   Fri Dec 6 17:25:21 2013 -0800

    timekeeping: Rework frequency adjustments to work better w/ nohz
    
    The existing timekeeping_adjust logic has always been complicated
    to understand. Further, since it was developed prior to NOHZ becoming
    common, its not surprising it performs poorly when NOHZ is enabled.
    
    Since Miroslav pointed out the problematic nature of the existing code
    in the NOHZ case, I've tried to refactor the code to perform better.
    
    The problem with the previous approach was that it tried to adjust
    for the total cumulative error using a scaled dampening factor. This
    resulted in large errors to be corrected slowly, while small errors
    were corrected quickly. With NOHZ the timekeeping code doesn't know
    how far out the next tick will be, so this results in bad
    over-correction to small errors, and insufficient correction to large
    errors.
    
    Inspired by Miroslav's patch, I've refactored the code to try to
    address the correction in two steps.
    
    1) Check the future freq error for the next tick, and if the frequency
    error is large, try to make sure we correct it so it doesn't cause
    much accumulated error.
    
    2) Then make a small single unit adjustment to correct any cumulative
    error that has collected over time.
    
    This method performs fairly well in the simulator Miroslav created.
    
    Major credit to Miroslav for pointing out the issue, providing the
    original patch to resolve this, a simulator for testing, as well as
    helping debug and resolve issues in my implementation so that it
    performed closer to his original implementation.
    
    Cc: Miroslav Lichvar <mlichvar@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Reported-by: Miroslav Lichvar <mlichvar@redhat.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit e2dff1ec0cc81fcf3e0696604bacc3e1c816538c
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Jul 23 14:35:39 2014 -0700

    timekeeping: Minor fixup for timespec64->timespec assignment
    
    In the GENERIC_TIME_VSYSCALL_OLD update_vsyscall implementation,
    we take the tk_xtime() value, which returns a timespec64, and
    store it in a timespec.
    
    This luckily is ok, since the only architectures that use
    GENERIC_TIME_VSYSCALL_OLD are ia64 and ppc64, which are both
    64 bit systems where timespec64 is the same as a timespec.
    
    Even so, for cleanliness reasons, use the conversion function
    to assign the proper type.
    
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 4396e058c52e167729729cf64ea3dfa229637086
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Jul 16 21:05:23 2014 +0000

    timekeeping: Provide fast and NMI safe access to CLOCK_MONOTONIC
    
    Tracers want a correlated time between the kernel instrumentation and
    user space. We really do not want to export sched_clock() to user
    space, so we need to provide something sensible for this.
    
    Using separate data structures with an non blocking sequence count
    based update mechanism allows us to do that. The data structure
    required for the readout has a sequence counter and two copies of the
    timekeeping data.
    
    On the update side:
    
      smp_wmb();
      tkf->seq++;
      smp_wmb();
      update(tkf->base[0], tk);
      smp_wmb();
      tkf->seq++;
      smp_wmb();
      update(tkf->base[1], tk);
    
    On the reader side:
    
      do {
         seq = tkf->seq;
         smp_rmb();
         idx = seq & 0x01;
         now = now(tkf->base[idx]);
         smp_rmb();
      } while (seq != tkf->seq)
    
    So if a NMI hits the update of base[0] it will use base[1] which is
    still consistent, but this timestamp is not guaranteed to be monotonic
    across an update.
    
    The timestamp is calculated by:
    
            now = base_mono + clock_delta * slope
    
    So if the update lowers the slope, readers who are forced to the
    not yet updated second array are still using the old steeper slope.
    
     tmono
     ^
     |    o  n
     |   o n
     |  u
     | o
     |o
     |12345678---> reader order
    
     o = old slope
     u = update
     n = new slope
    
    So reader 6 will observe time going backwards versus reader 5.
    
    While other CPUs are likely to be able observe that, the only way
    for a CPU local observation is when an NMI hits in the middle of
    the update. Timestamps taken from that NMI context might be ahead
    of the following timestamps. Callers need to be aware of that and
    deal with it.
    
    V2: Got rid of clock monotonic raw and reorganized the data
        structures. Folded in the barrier fix from Mathieu.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 0e5ac3a8b100469ea154f87dd57b685fbdd356f6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Jul 16 21:05:18 2014 +0000

    timekeeping: Use tk_read_base as argument for timekeeping_get_ns()
    
    All the function needs is in the tk_read_base struct. No functional
    change for the current code, just a preparatory patch for the NMI safe
    accessor to clock monotonic which will use struct tk_read_base as well.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit d28ede83791defee9a81e558540699dc46dbbe13
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Jul 16 21:05:16 2014 +0000

    timekeeping: Create struct tk_read_base and use it in struct timekeeper
    
    The members of the new struct are the required ones for the new NMI
    safe accessor to clcok monotonic. In order to reuse the existing
    timekeeping code and to make the update of the fast NMI safe
    timekeepers a simple memcpy use the struct for the timekeeper as well
    and convert all users.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 6d3aadf3e180e09dbefab16478c6876b584ce16e
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Jul 16 21:05:15 2014 +0000

    timekeeping: Restructure the timekeeper some more
    
    Access to time requires to touch two cachelines at minimum
    
       1) The timekeeper data structure
    
       2) The clocksource data structure
    
    The access to the clocksource data structure can be avoided as almost
    all clocksource implementations ignore the argument to the read
    callback, which is a pointer to the clocksource.
    
    But the core needs to touch it to access the members @read and @mask.
    
    So we are better off by copying the @read function pointer and the
    @mask from the clocksource to the core data structure itself.
    
    For the most used ktime_get() access all required data including the
    @read and @mask copies fits together with the sequence counter into a
    single 64 byte cacheline.
    
    For the other time access functions we touch in the current code three
    cache lines in the worst case. But with the clocksource data copies we
    can reduce that to two adjacent cachelines, which is more efficient
    than disjunct cache lines.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit f519b1a2e08c913375324a927992bb328387f169
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Jul 16 21:05:04 2014 +0000

    timekeeping: Provide ktime_get_raw()
    
    Provide a ktime_t based interface for raw monotonic time.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 61edec81d260bc96a73c878bbdb4c614460346da
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Jul 16 21:05:01 2014 +0000

    timekeeping: Simplify timekeeping_clocktai()
    
    timekeeping_clocktai() is not used in fast pathes, so the extra
    timespec conversion is not problematic.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 47da70d32535000ec29cc206cfc1d318fbd8761f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Jul 16 21:05:00 2014 +0000

    timekeeping: Remove timekeeper.total_sleep_time
    
    No more users. Remove it
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 02cba1598a2a3b689e79ad6dad2532521f638271
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Jul 16 21:04:58 2014 +0000

    timekeeping: Simplify getboottime()
    
    Subtracting plain nsec values and converting to timespec is simpler
    than the whole timespec math. Not really fastpath code, so the
    division is not an issue.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 48f18fd6addc199f330d838d54fe7b0a0892adaa
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Jul 16 21:04:57 2014 +0000

    timekeeping: Use ktime_get_boottime() for get_monotonic_boottime()
    
    get_monotonic_boottime() is not used in fast pathes, so the extra
    timespec conversion is not problematic.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 250fade8af2ac5dda8d5106ea06738b6f9e768a7
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Jul 16 21:04:55 2014 +0000

    timekeeping: Remove monotonic_to_bootbased
    
    No more users.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 897994e32b2b0a41ce4222c3b38a05bd2d1ee9fa
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Jul 16 21:04:29 2014 +0000

    timekeeping: Provide ktime_get[*]_ns() helpers
    
    A lot of code converts either timespecs or ktime_t to
    nanoseconds. Provide helper functions.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit dcaab54e348c5b66cca4802815ceebd37059e70c
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Jul 16 21:04:28 2014 +0000

    timekeeping: Remove ktime_get_monotonic_offset()
    
    No more users.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 9a6b51976ea3a326b6de534beec3fd87275f4ef6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Jul 16 21:04:22 2014 +0000

    timekeeping: Provide ktime_mono_to_any()
    
    ktime based conversion function to map a monotonic time stamp to a
    different CLOCK.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 48064f5f67d58f95094305ac575d5372b58e265f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Jul 16 21:04:20 2014 +0000

    timekeeping; Use ktime based data for ktime_get_update_offsets_tick()
    
    No need to juggle with timespecs.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit a37c0aad6093575b52432b47b145304f1af18dff
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Jul 16 21:04:19 2014 +0000

    timekeeping: Use ktime_t data for ktime_get_update_offsets_now()
    
    No need to juggle with timespecs.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit afab07c0e91ecf098abf34573ccfcd86d6be26f9
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Jul 16 21:04:17 2014 +0000

    timekeeping: Use ktime_t based data for ktime_get_clocktai()
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit b82c817e2d16e818c472eb71019de521816000a3
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Jul 16 21:04:16 2014 +0000

    timekeeping; Use ktime_t based data for ktime_get_boottime()
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit f5264d5d5a0729306cc792d84432b97785d2662a
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Jul 16 21:04:14 2014 +0000

    timekeeping: Use ktime_t based data for ktime_get_real()
    
    Speed up the readout.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 0077dc60f274b9a7e9aa705a34784fefb87e0eee
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Jul 16 21:04:13 2014 +0000

    timekeeping: Provide ktime_get_with_offset()
    
    Provide a helper function which lets us implement ktime_t based
    interfaces for real, boot and tai clocks.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit a016a5bd62e29a738531d9d4d925037a1fdb52f5
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Jul 16 21:04:12 2014 +0000

    timekeeping: Use ktime_t based data for ktime_get()
    
    Speed up ktime_get() by using ktime_t based data. Text size shrinks by
    64 bytes on x8664.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 7c032df5570388044b4efda3d9f4d2ffb96a3116
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Jul 16 21:04:10 2014 +0000

    timekeeping: Provide internal ktime_t based data
    
    The ktime_t based interfaces are used a lot in performance critical
    code pathes. Add ktime_t based data so the interfaces don't have to
    convert from the xtime/timespec based data.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit f111adfdd7ff7d9fe54b6efa440b80824984749c
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Jul 16 21:04:09 2014 +0000

    timekeeping: Use timekeeping_update() instead of memcpy()
    
    We already have a function which does the right thing, that also makes
    sure that the coming ktime_t based cached values are getting updated.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 3fdb14fd1df70325e1e91e1203a699a4803ed741
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Jul 16 21:04:07 2014 +0000

    timekeeping: Cache optimize struct timekeeper
    
    struct timekeeper is quite badly sorted for the hot readout path. Most
    time access functions need to load two cache lines.
    
    Rearrange it so ktime_get() and getnstimeofday() are happy with a
    single cache line.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit d6d29896c665dfd50e6e0be7a9039901640433a3
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Jul 16 21:04:04 2014 +0000

    timekeeping: Provide timespec64 based interfaces
    
    To convert callers of the core code to timespec64 we need to provide
    the proper interfaces.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 8b094cd03b4a3793220d8d8d86a173bfea8c285b
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Jul 16 21:04:02 2014 +0000

    time: Consolidate the time accessor prototypes
    
    Right now we have time related prototypes in 3 different header
    files. Move it to a single timekeeping header file and move the core
    internal stuff into a core private header.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 7d489d15ce4be5310ca60e5896df833f9b3b4088
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Jul 16 21:04:01 2014 +0000

    timekeeping: Convert timekeeping core to use timespec64s
    
    Convert the core timekeeping logic to use timespec64s. This moves the
    2038 issues out of the core logic and into all of the accessor
    functions.
    
    Future changes will need to push the timespec64s out to all
    timekeeping users, but that can be done interface by interface.
    
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 76f4108892d9a9e3408bba839914f97a54086a6f
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Jul 16 21:03:52 2014 +0000

    hrtimer: Cleanup hrtimer accessors to the timekepeing state
    
    Rather then having two similar but totally different implementations
    that provide timekeeping state to the hrtimer code, try to unify the
    two implementations to be more simliar.
    
    Thus this clarifies ktime_get_update_offsets to
    ktime_get_update_offsets_now and changes get_xtime...  to
    ktime_get_update_offsets_tick.
    
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit e06fde37b860f5030e93475a2a95857af7ad13e1
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Jul 16 21:03:50 2014 +0000

    timekeeping: Simplify arch_gettimeoffset()
    
    Provide a default stub function instead of having the extra
    conditional. Cuts binary size on a m68k build by ~100 bytes.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit dc01c9fae1c5e40458c086a868d2028dfd6faebd
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Jul 16 21:03:49 2014 +0000

    tile: Convert VDSO timekeeping to the precise mechanism
    
    The code was only halfarsed converted to the new VSDO update mechanism
    and still uses the inaccurate base value which lacks the fractional
    part of xtime_nsec. Fix it up.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit c0f489d2c6fec8994c642c2ec925eb858727dc7b
Author: Paul E. McKenney <paulmck@kernel.org>
Date:   Wed Jun 4 13:46:03 2014 -0700

    rcu: Bind grace-period kthreads to non-NO_HZ_FULL CPUs
    
    Binding the grace-period kthreads to the timekeeping CPU resulted in
    significant performance decreases for some workloads.  For more detail,
    see:
    
    https://lkml.org/lkml/2014/6/3/395 for benchmark numbers
    
    https://lkml.org/lkml/2014/6/4/218 for CPU statistics
    
    It turns out that it is necessary to bind the grace-period kthreads
    to the timekeeping CPU only when all but CPU 0 is a nohz_full CPU
    on the one hand or if CONFIG_NO_HZ_FULL_SYSIDLE=y on the other.
    In other cases, it suffices to bind the grace-period kthreads to the
    set of non-nohz_full CPUs.
    
    This commit therefore creates a tick_nohz_not_full_mask that is the
    complement of tick_nohz_full_mask, and then binds the grace-period
    kthread to the set of CPUs indicated by this new mask, which covers
    the CONFIG_NO_HZ_FULL_SYSIDLE=n case.  The CONFIG_NO_HZ_FULL_SYSIDLE=y
    case still binds the grace-period kthreads to the timekeeping CPU.
    This commit also includes the tick_nohz_full_enabled() check suggested
    by Frederic Weisbecker.
    
    Reported-by: Jet Chen <jet.chen@intel.com>
    Signed-off-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    [ paulmck: Created housekeeping_affine() and housekeeping_mask per
      fweisbec feedback. ]

commit cd33b5a46edac04bdfe51f4cba28fc11dad94a56
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Feb 12 13:46:19 2013 -0800

    drivers/rtc/rtc-pl031.c: restore ST variant functionality
    
    commit 3399cfb5df9594495b876d1843a7165f77366b2b upstream.
    
    Commit e7e034e18a0a ("drivers/rtc/rtc-pl031.c: fix the missing operation
    on enable") accidentally broke the ST variants of PL031.
    
    The bit that is being poked as "clockwatch" enable bit for the ST
    variants does the work of bit 0 on this variant.  Bit 0 is used for a
    clock divider on the ST variants, and setting it to 1 will affect
    timekeeping in a very bad way.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Haojian Zhuang <haojian.zhuang@gmail.com>
    Cc: Mian Yousaf KAUKAB <mian.yousaf.kaukab@stericsson.com>
    Cc: Srinidhi Kasagar <srinidhi.kasagar@stericsson.com>
    Cc: Alessandro Zummo <a.zummo@towertech.it>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>
    Cc: Qiang Huang <h.huangqiang@huawei.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 6d9bcb621b0b0a20604cbdb298c4487e44dd0da2
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Jun 4 16:11:43 2014 -0700

    timekeeping: use printk_deferred when holding timekeeping seqlock
    
    Jiri Bohac pointed out that there are rare but potential deadlock
    possibilities when calling printk while holding the timekeeping
    seqlock.
    
    This is due to printk() triggering console sem wakeup, which can
    cause scheduling code to trigger hrtimers which may try to read
    the time.
    
    Specifically, as Jiri pointed out, that path is:
      printk
        vprintk_emit
          console_unlock
            up(&console_sem)
              __up
                wake_up_process
                  try_to_wake_up
                    ttwu_do_activate
                      ttwu_activate
                        activate_task
                          enqueue_task
                            enqueue_task_fair
                              hrtick_update
                                hrtick_start_fair
                                  hrtick_start_fair
                                    get_time
                                      ktime_get
                                        --> endless loop on
                                        read_seqcount_retry(&timekeeper_seq, ...)
    
    This patch tries to avoid this issue by using printk_deferred (previously
    named printk_sched) which should defer printing via a irq_work_queue.
    
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Reported-by: Jiri Bohac <jbohac@suse.cz>
    Reviewed-by: Steven Rostedt <rostedt@goodmis.org>
    Cc: Jan Kara <jack@suse.cz>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit aac74dc495456412c4130a1167ce4beb6c1f0b38
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Jun 4 16:11:40 2014 -0700

    printk: rename printk_sched to printk_deferred
    
    After learning we'll need some sort of deferred printk functionality in
    the timekeeping core, Peter suggested we rename the printk_sched function
    so it can be reused by needed subsystems.
    
    This only changes the function name. No logic changes.
    
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Reviewed-by: Steven Rostedt <rostedt@goodmis.org>
    Cc: Jan Kara <jack@suse.cz>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Jiri Bohac <jbohac@suse.cz>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit f13588b86969b02e3d74b55ac04956461f898a3d
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Apr 15 10:54:40 2014 +0530

    tick-sched: Don't call update_wall_time() when delta is lesser than tick_period
    
    commit 03e6bdc5c4d0fc166bfd5d3cf749a5a0c1b5b1bd upstream.
    
    In tick_do_update_jiffies64() we are processing ticks only if delta is
    greater than tick_period. This is what we are supposed to do here and
    it broke a bit with this patch:
    
    commit 47a1b796 (tick/timekeeping: Call update_wall_time outside the
    jiffies lock)
    
    With above patch, we might end up calling update_wall_time() even if
    delta is found to be smaller that tick_period. Fix this by returning
    when the delta is less than tick period.
    
    [ tglx: Made it a 3 liner and massaged changelog ]
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Cc: linaro-kernel@lists.linaro.org
    Cc: fweisbec@gmail.com
    Cc: Arvind.Chauhan@arm.com
    Cc: linaro-networking@linaro.org
    Cc: John Stultz <john.stultz@linaro.org>
    Link: http://lkml.kernel.org/r/80afb18a494b0bd9710975bcc4de134ae323c74f.1397537987.git.viresh.kumar@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit b33cdd283bd917d431469c29419c2cf2624bd683
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon May 26 17:25:22 2014 +0200

    ARM: vexpress: refine dependencies for new code
    
    The versatile express changes for 3.16 introduced a number of
    build regressions for randconfig kernels by not tracking dependencies
    between the components right.
    
    This patch tries to rectify that:
    
    * the mach-vexpress code cannot link without the syscfg driver,
      which in turn needs MFD_VEXPRESS_SYSREG
    * various drivers call devm_regmap_init_vexpress_config(), which
      has to be exported so it can be used by loadable modules
    * the configuration bus uses OF DT helper functions that are not
      available to platforms disable CONFIG_OF
    * The sysreg driver exports GPIOs through gpiolib, which can
      be disabled on some platforms.
    * The clocksource code cannot be built on platforms that don't
      use modern timekeeping but rely on gettimeoffset.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

commit 5057f55e543b7859cfd26bc281291795eac93f8a
Author: Paul E. McKenney <paulmck@kernel.org>
Date:   Tue Apr 1 11:20:36 2014 -0700

    rcu: Bind RCU grace-period kthreads if NO_HZ_FULL
    
    Currently, RCU binds the grace-period kthreads to the timekeeping
    CPU only if CONFIG_NO_HZ_FULL_SYSIDLE=y.  This means that these
    kthreads must be bound manually when CONFIG_NO_HZ_FULL_SYSIDLE=n and
    CONFIG_NO_HZ_FULL=y: Otherwise, these kthreads will induce OS jitter on
    random CPUs.  Given that we are trying to reduce the amount of manual
    tweaking required to make CONFIG_NO_HZ_FULL=y work nicely, this commit
    makes this binding happen when CONFIG_NO_HZ_FULL=y, even in cases where
    CONFIG_NO_HZ_FULL_SYSIDLE=n.
    
    Signed-off-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Reviewed-by: Josh Triplett <josh@joshtriplett.org>

commit 87a54cae0ba094de2ddb7e5f429fd32b965a2fbf
Merge: 81cef0fe19e0 27630532ef5e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Apr 17 16:19:10 2014 -0700

    Merge branch 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer fixes from Thomas Gleixner:
     "Viresh unearthed the following three hickups in the timer/timekeeping
      code:
    
       - Negated check for the result of a clock event selection
    
       - A missing early exit in the jiffies update path which causes
         update_wall_time to be called for nothing causing lock contention
         and wasted cycles in the timer interrupt
    
       - Checking a variable in the NOHZ code enable code for true which can
         only be set by that very code after the check succeeds.  That
         results in a rock solid runtime disablement of that feature"
    
    * 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      tick-sched: Check tick_nohz_enabled in tick_nohz_switch_to_nohz()
      tick-sched: Don't call update_wall_time() when delta is lesser than tick_period
      tick-common: Fix wrong check in tick_check_replacement()

commit 03e6bdc5c4d0fc166bfd5d3cf749a5a0c1b5b1bd
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Apr 15 10:54:40 2014 +0530

    tick-sched: Don't call update_wall_time() when delta is lesser than tick_period
    
    In tick_do_update_jiffies64() we are processing ticks only if delta is
    greater than tick_period. This is what we are supposed to do here and
    it broke a bit with this patch:
    
    commit 47a1b796 (tick/timekeeping: Call update_wall_time outside the
    jiffies lock)
    
    With above patch, we might end up calling update_wall_time() even if
    delta is found to be smaller that tick_period. Fix this by returning
    when the delta is less than tick period.
    
    [ tglx: Made it a 3 liner and massaged changelog ]
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Cc: linaro-kernel@lists.linaro.org
    Cc: fweisbec@gmail.com
    Cc: Arvind.Chauhan@arm.com
    Cc: linaro-networking@linaro.org
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: <stable@vger.kernel.org> # v3.14+
    Link: http://lkml.kernel.org/r/80afb18a494b0bd9710975bcc4de134ae323c74f.1397537987.git.viresh.kumar@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit c6f21243ce1e8d81ad8361da4d2eaa5947b667c4
Merge: 9447dc43941c 37c975545ec6
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Apr 2 12:26:43 2014 -0700

    Merge branch 'x86-vdso-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull x86 vdso changes from Peter Anvin:
     "This is the revamp of the 32-bit vdso and the associated cleanups.
    
      This adds timekeeping support to the 32-bit vdso that we already have
      in the 64-bit vdso.  Although 32-bit x86 is legacy, it is likely to
      remain in the embedded space for a very long time to come.
    
      This removes the traditional COMPAT_VDSO support; the configuration
      variable is reused for simply removing the 32-bit vdso, which will
      produce correct results but obviously suffer a performance penalty.
      Only one beta version of glibc was affected, but that version was
      unfortunately included in one OpenSUSE release.
    
      This is not the end of the vdso cleanups.  Stefani and Andy have
      agreed to continue work for the next kernel cycle; in fact Andy has
      already produced another set of cleanups that came too late for this
      cycle.
    
      An incidental, but arguably important, change is that this ensures
      that unused space in the VVAR page is properly zeroed.  It wasn't
      before, and would contain whatever garbage was left in memory by BIOS
      or the bootloader.  Since the VVAR page is accessible to user space
      this had the potential of information leaks"
    
    * 'x86-vdso-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (23 commits)
      x86, vdso: Fix the symbol versions on the 32-bit vDSO
      x86, vdso, build: Don't rebuild 32-bit vdsos on every make
      x86, vdso: Actually discard the .discard sections
      x86, vdso: Fix size of get_unmapped_area()
      x86, vdso: Finish removing VDSO32_PRELINK
      x86, vdso: Move more vdso definitions into vdso.h
      x86: Load the 32-bit vdso in place, just like the 64-bit vdsos
      x86, vdso32: handle 32 bit vDSO larger one page
      x86, vdso32: Disable stack protector, adjust optimizations
      x86, vdso: Zero-pad the VVAR page
      x86, vdso: Add 32 bit VDSO time support for 64 bit kernel
      x86, vdso: Add 32 bit VDSO time support for 32 bit kernel
      x86, vdso: Patch alternatives in the 32-bit VDSO
      x86, vdso: Introduce VVAR marco for vdso32
      x86, vdso: Cleanup __vdso_gettimeofday()
      x86, vdso: Replace VVAR(vsyscall_gtod_data) by gtod macro
      x86, vdso: __vdso_clock_gettime() cleanup
      x86, vdso: Revamp vclock_gettime.c
      mm: Add new func _install_special_mapping() to mmap.c
      x86, vdso: Make vsyscall_gtod_data handling x86 generic
      ...

commit 7f4d7e8fe42d3a34994055355694236f489c874f
Author: Colin Cross <ccross@android.com>
Date:   Mon Feb 10 13:16:29 2014 -0800

    timekeeping: fix 32-bit overflow in get_monotonic_boottime
    
    fixed upstream in v3.6 by ec145babe754f9ea1079034a108104b6001e001c
    
    get_monotonic_boottime adds three nanonsecond values stored
    in longs, followed by an s64.  If the long values are all
    close to 1e9 the first three additions can overflow and
    become negative when added to the s64.  Cast the first
    value to s64 so that all additions are 64 bit.
    
    Signed-off-by: Colin Cross <ccross@android.com>
    [jstultz: Fished this out of the AOSP commong.git tree. This was
    fixed upstream in v3.6 by ec145babe754f9ea1079034a108104b6001e001c]
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit c4a987db1b3cd89207cece4b8121c09cbfbc978a
Author: Huacai Chen <chenhuacai@kernel.org>
Date:   Fri Mar 21 18:44:09 2014 +0800

    MIPS: Loongson 3: Add CPU hotplug support
    
    Tips of Loongson's CPU hotplug:
    1, To fully shutdown a core in Loongson 3, the target core should go to
       CKSEG1 and flush all L1 cache entries at first. Then, another core
       (usually Core 0) can safely disable the clock of the target core. So
       play_dead() call loongson3_play_dead() via CKSEG1 (both uncached and
       unmmaped).
    2, The default clocksource of Loongson is MIPS. Since clock source is a
       global device, timekeeping need the CP0' Count registers of each core
       be synchronous. Thus, when a core is up, we use a SMP_ASK_C0COUNT IPI
       to ask Core-0's Count.
    
    Signed-off-by: Huacai Chen <chenhc@lemote.com>
    Signed-off-by: Hongliang Tao <taohl@lemote.com>
    Signed-off-by: Hua Yan <yanh@lemote.com>
    Tested-by: Alex Smith <alex.smith@imgtec.com>
    Reviewed-by: Alex Smith <alex.smith@imgtec.com>
    Cc: John Crispin <john@phrozen.org>
    Cc: Steven J. Hill <Steven.Hill@imgtec.com>
    Cc: Aurelien Jarno <aurelien@aurel32.net>
    Cc: linux-mips@linux-mips.org
    Cc: Fuxin Zhang <zhangfx@lemote.com>
    Cc: Zhangjin Wu <wuzhangjin@gmail.com>
    Patchwork: https://patchwork.linux-mips.org/patch/6639
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

commit cab5e127eef040399902caa8e1510795583fa03a
Author: John Stultz <john.stultz@linaro.org>
Date:   Thu Mar 27 16:30:49 2014 -0700

    time: Revert to calling clock_was_set_delayed() while in irq context
    
    In commit 47a1b796306356f35 ("tick/timekeeping: Call
    update_wall_time outside the jiffies lock"), we moved to calling
    clock_was_set() due to the fact that we were no longer holding
    the timekeeping or jiffies lock.
    
    However, there is still the problem that clock_was_set()
    triggers an IPI, which cannot be done from the timer's hard irq
    context, and will generate WARN_ON warnings.
    
    Apparently in my earlier testing, I'm guessing I didn't bump the
    dmesg log level, so I somehow missed the WARN_ONs.
    
    Thus we need to revert back to calling clock_was_set_delayed().
    
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Link: http://lkml.kernel.org/r/1395963049-11923-1-git-send-email-john.stultz@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit cee152ff8a3c8aedf7b97417889f9319a7002141
Merge: 0c01b4525716 d5af40d6b34d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Mar 14 18:02:02 2014 -0700

    Merge tag 'pm+acpi-3.14-rc7' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull ACPI and power management fixes from Rafael Wysocki:
     "Three of these are regression fixes, for two recent regressions and
      one introduced during the 3.13 cycle, and the fourth one is a working
      version of the fix that had to be reverted last time.
    
      Specifics:
    
       - A recent ACPI resources handling fix overlooked the fact that it
         had to update the ACPI PNP subsystem's resources parsing too and
         caused confusing warning messages to be printed during system
         intialization on some systems (with arguably buggy ACPI tables).
         Fix from Zhang Rui.
    
       - Moving the early ACPI initialization before timekeeping_init()
         earlier in this cycle broke fast TSC calibration on at least one
         system, so it needs to be done later, but still before
         efi_enter_virtual_mode() to allow the EFI initialization to refer
         to ACPI.
    
       - A change related to code duplication reduction in the cpufreq core
         inadvertently caused cpufreq intialization to fail for some CPUs
         handled by intel_pstate by adding checks that may fail for that
         driver, but aren't even necessary when it is used.  The issue is
         addressed by preventing those checks from run in the configurations
         in which they aren't needed.
    
       - If the Hardware Reduced ACPI flag is set in the ACPI tables, system
         suspend, hibernation and ACPI power off will only work when special
         sleep control and sleep status registeres are provided (their
         addresses in the ACPI tables are not zero).  If those registers are
         not available, the features in question have no chances to work, so
         they shouldn't even be regarded as supported.  That helps with
         power off in particular, because alternative power off methods may
         be used then and they may actually work"
    
    * tag 'pm+acpi-3.14-rc7' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm:
      ACPI / sleep: Add extra checks for HW Reduced ACPI mode sleep states
      ACPI / init: Invoke early ACPI initialization later
      cpufreq: Skip current frequency initialization for ->setpolicy drivers
      PNP / ACPI: proper handling of ACPI IO/Memory resource parsing failures

commit c4e1acbb35e4a3838cdfc0e7f8237e844aff00b6
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Mar 13 00:22:58 2014 +0100

    ACPI / init: Invoke early ACPI initialization later
    
    Commit 73f7d1ca3263 (ACPI / init: Run acpi_early_init() before
    timekeeping_init()) optimistically moved the early ACPI initialization
    before timekeeping_init(), but that didn't work, because it broke fast
    TSC calibration for Julian Wollrath on Thinkpad x121e (and most likely
    for others too).  The reason is that acpi_early_init() enables the SCI
    and that interferes with the fast TSC calibration mechanism.
    
    Thus follow the original idea to execute acpi_early_init() before
    efi_enter_virtual_mode() to help the EFI people for now and we can
    revisit the other problem that commit 73f7d1ca3263 attempted to
    address in the future (if really necessary).
    
    Fixes: 73f7d1ca3263 (ACPI / init: Run acpi_early_init() before timekeeping_init())
    Reported-by: Julian Wollrath <jwollrath@web.de>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 4b2f0b033a294e6c19d57c5d0a66c000f6299559
Author: tuukka.tikkanen@linaro.org <tuukka.tikkanen@linaro.org>
Date:   Mon Feb 24 08:29:37 2014 +0200

    cpuidle: poll state can measure residency
    
    For some platforms, a poll state is inserted in the cpuidle driver states.
    The flags for the state do not indicate that timekeeping is not affected.
    As the state does not do anything apart from calling cpu_relax(), the
    times returned by ktime_get should remain valid. Add the missing flag.
    
    Signed-off-by: Tuukka Tikkanen <tuukka.tikkanen@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 64e8d20bd39b81994d9cd60e7b42f8ec8652f5af
Author: Rashika Kheria <rashika.kheria@gmail.com>
Date:   Thu Feb 27 17:25:54 2014 +0530

    kernel: Include appropriate header file in time/timekeeping_debug.c
    
    Include appropriate header file kernel/time/timekeeping_internal.h in
    kernel/time/timekeeping_debug.c because it has prototype declaration of
    function defined in kernel/time/timekeeping_debug.c.
    
    This eliminates the following warning in
    kernel/time/timekeeping_debug.c:
    kernel/time/timekeeping_debug.c:68:6: warning: no previous prototype for ‘tk_debug_account_sleep_time’ [-Wmissing-prototypes]
    
    Signed-off-by: Rashika Kheria <rashika.kheria@gmail.com>
    Reviewed-by: Josh Triplett <josh@joshtriplett.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit d9bd24c3bc422acf43f744124d6537921719352f
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sun Dec 29 12:39:50 2013 +0000

    ARM: fix footbridge clockevent device
    
    commit 4ff859fe1dc0da0f87bbdfff78f527898878fa4a upstream.
    
    The clockevents code was being told that the footbridge clock event
    device ticks at 16x the rate which it actually does.  This leads to
    timekeeping problems since it allows the clocksource to wrap before
    the kernel notices.  Fix this by using the correct clock.
    
    Fixes: 4e8d76373c9fd ("ARM: footbridge: convert to clockevents/clocksource")
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    [bwh: Backported to 3.2: fold in the relevant parts of commit 838a2ae80a6a
     ('ARM: use clockevents_config_and_register() where possible')]
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit f96a34e27df19335155394a235ea3a096bc52a71
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Thu Feb 6 13:36:21 2014 -0500

    nohz: ensure users are aware boot CPU is not NO_HZ_FULL
    
    This bit of information is in the Kconfig help text:
    
      "Note the boot CPU will still be kept outside the range to
      handle the timekeeping duty."
    
    However neither the variable NO_HZ_FULL_ALL, or the prompt
    convey this important detail, so lets add it to the prompt
    to make it more explicitly obvious to the average user.
    
    Acked-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Paul Gortmaker <paul.gortmaker@windriver.com>
    Cc: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/1391711781-7466-1-git-send-email-paul.gortmaker@windriver.com
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>

commit 93aca8a79e4e9bb89816d00eb50d5f77fd63fcf2
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Dec 11 19:10:36 2013 -0800

    timekeeping: Fix missing timekeeping_update in suspend path
    
    commit 330a1617b0a6268d427aa5922c94d082b1d3e96d upstream.
    
    Since 48cdc135d4840 (Implement a shadow timekeeper), we have to
    call timekeeping_update() after any adjustment to the timekeeping
    structure in order to make sure that any adjustments to the structure
    persist.
    
    In the timekeeping suspend path, we udpate the timekeeper
    structure, so we should be sure to update the shadow-timekeeper
    before releasing the timekeeping locks. Currently this isn't done.
    
    In most cases, the next time related code to run would be
    timekeeping_resume, which does update the shadow-timekeeper, but
    in an abundence of caution, this patch adds the call to
    timekeeping_update() in the suspend path.
    
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 36050e26ea36f130d1c36fe51c4ffffdff49fe72
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Dec 10 17:13:35 2013 -0800

    timekeeping: Fix CLOCK_TAI timer/nanosleep delays
    
    commit 04005f6011e3b504cd4d791d9769f7cb9a3b2eae upstream.
    
    A think-o in the calculation of the monotonic -> tai time offset
    results in CLOCK_TAI timers and nanosleeps to expire late (the
    latency is ~2x the tai offset).
    
    Fix this by adding the tai offset from the realtime offset instead
    of subtracting.
    
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit de5cfcdd23d1001fc9348c17570ffc1f7bc0efee
Author: John Stultz <john.stultz@linaro.org>
Date:   Mon Feb 10 13:07:21 2014 -0800

    3.13.y: timekeeping: Fix clock_set/clock_was_set think-o
    
    In backporting 6fdda9a9c5db367130cf32df5d6618d08b89f46a
    (timekeeping: Avoid possible deadlock from clock_was_set_delayed),
    I ralized the patch had a think-o where instead of checking
    clock_set I accidentally typed clock_was_set (which is a function
    - so the conditional always is true).
    
    Upstream this was resolved in the immediately following patch
    47a1b796306356f358e515149d86baf0cc6bf007 (tick/timekeeping: Call
    update_wall_time outside the jiffies lock). But since that patch
    really isn't -stable material, so this patch only pulls
    the name change.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 970719a34d1e443eee0d52a52b0e8a755819d4cb
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Dec 10 17:18:18 2013 -0800

    timekeeping: Avoid possible deadlock from clock_was_set_delayed
    
    commit 6fdda9a9c5db367130cf32df5d6618d08b89f46a upstream.
    
    As part of normal operaions, the hrtimer subsystem frequently calls
    into the timekeeping code, creating a locking order of
      hrtimer locks -> timekeeping locks
    
    clock_was_set_delayed() was suppoed to allow us to avoid deadlocks
    between the timekeeping the hrtimer subsystem, so that we could
    notify the hrtimer subsytem the time had changed while holding
    the timekeeping locks. This was done by scheduling delayed work
    that would run later once we were out of the timekeeing code.
    
    But unfortunately the lock chains are complex enoguh that in
    scheduling delayed work, we end up eventually trying to grab
    an hrtimer lock.
    
    Sasha Levin noticed this in testing when the new seqlock lockdep
    enablement triggered the following (somewhat abrieviated) message:
    
    [  251.100221] ======================================================
    [  251.100221] [ INFO: possible circular locking dependency detected ]
    [  251.100221] 3.13.0-rc2-next-20131206-sasha-00005-g8be2375-dirty #4053 Not tainted
    [  251.101967] -------------------------------------------------------
    [  251.101967] kworker/10:1/4506 is trying to acquire lock:
    [  251.101967]  (timekeeper_seq){----..}, at: [<ffffffff81160e96>] retrigger_next_event+0x56/0x70
    [  251.101967]
    [  251.101967] but task is already holding lock:
    [  251.101967]  (hrtimer_bases.lock#11){-.-...}, at: [<ffffffff81160e7c>] retrigger_next_event+0x3c/0x70
    [  251.101967]
    [  251.101967] which lock already depends on the new lock.
    [  251.101967]
    [  251.101967]
    [  251.101967] the existing dependency chain (in reverse order) is:
    [  251.101967]
    -> #5 (hrtimer_bases.lock#11){-.-...}:
    [snipped]
    -> #4 (&rt_b->rt_runtime_lock){-.-...}:
    [snipped]
    -> #3 (&rq->lock){-.-.-.}:
    [snipped]
    -> #2 (&p->pi_lock){-.-.-.}:
    [snipped]
    -> #1 (&(&pool->lock)->rlock){-.-...}:
    [  251.101967]        [<ffffffff81194803>] validate_chain+0x6c3/0x7b0
    [  251.101967]        [<ffffffff81194d9d>] __lock_acquire+0x4ad/0x580
    [  251.101967]        [<ffffffff81194ff2>] lock_acquire+0x182/0x1d0
    [  251.101967]        [<ffffffff84398500>] _raw_spin_lock+0x40/0x80
    [  251.101967]        [<ffffffff81153e69>] __queue_work+0x1a9/0x3f0
    [  251.101967]        [<ffffffff81154168>] queue_work_on+0x98/0x120
    [  251.101967]        [<ffffffff81161351>] clock_was_set_delayed+0x21/0x30
    [  251.101967]        [<ffffffff811c4bd1>] do_adjtimex+0x111/0x160
    [  251.101967]        [<ffffffff811e2711>] compat_sys_adjtimex+0x41/0x70
    [  251.101967]        [<ffffffff843a4b49>] ia32_sysret+0x0/0x5
    [  251.101967]
    -> #0 (timekeeper_seq){----..}:
    [snipped]
    [  251.101967] other info that might help us debug this:
    [  251.101967]
    [  251.101967] Chain exists of:
      timekeeper_seq --> &rt_b->rt_runtime_lock --> hrtimer_bases.lock#11
    
    [  251.101967]  Possible unsafe locking scenario:
    [  251.101967]
    [  251.101967]        CPU0                    CPU1
    [  251.101967]        ----                    ----
    [  251.101967]   lock(hrtimer_bases.lock#11);
    [  251.101967]                                lock(&rt_b->rt_runtime_lock);
    [  251.101967]                                lock(hrtimer_bases.lock#11);
    [  251.101967]   lock(timekeeper_seq);
    [  251.101967]
    [  251.101967]  *** DEADLOCK ***
    [  251.101967]
    [  251.101967] 3 locks held by kworker/10:1/4506:
    [  251.101967]  #0:  (events){.+.+.+}, at: [<ffffffff81154960>] process_one_work+0x200/0x530
    [  251.101967]  #1:  (hrtimer_work){+.+...}, at: [<ffffffff81154960>] process_one_work+0x200/0x530
    [  251.101967]  #2:  (hrtimer_bases.lock#11){-.-...}, at: [<ffffffff81160e7c>] retrigger_next_event+0x3c/0x70
    [  251.101967]
    [  251.101967] stack backtrace:
    [  251.101967] CPU: 10 PID: 4506 Comm: kworker/10:1 Not tainted 3.13.0-rc2-next-20131206-sasha-00005-g8be2375-dirty #4053
    [  251.101967] Workqueue: events clock_was_set_work
    
    So the best solution is to avoid calling clock_was_set_delayed() while
    holding the timekeeping lock, and instead using a flag variable to
    decide if we should call clock_was_set() once we've released the locks.
    
    This works for the case here, where the do_adjtimex() was the deadlock
    trigger point. Unfortuantely, in update_wall_time() we still hold
    the jiffies lock, which would deadlock with the ipi triggered by
    clock_was_set(), preventing us from calling it even after we drop the
    timekeeping lock. So instead call clock_was_set_delayed() at that point.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Reported-by: Sasha Levin <sasha.levin@oracle.com>
    Tested-by: Sasha Levin <sasha.levin@oracle.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 224655fc3e805bcc5a2139eaae28f783fa206df9
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Dec 11 20:07:49 2013 -0800

    timekeeping: Fix potential lost pv notification of time change
    
    commit 5258d3f25c76f6ab86e9333abf97a55a877d3870 upstream.
    
    In 780427f0e11 (Indicate that clock was set in the pvclock
    gtod notifier), logic was added to pass a CLOCK_WAS_SET
    notification to the pvclock notifier chain.
    
    While that patch added a action flag returned from
    accumulate_nsecs_to_secs(), it only uses the returned value
    in one location, and not in the logarithmic accumulation.
    
    This means if a leap second triggered during the logarithmic
    accumulation (which is most likely where it would happen),
    the notification that the clock was set would not make it to
    the pv notifiers.
    
    This patch extends the logarithmic_accumulation pass down
    that action flag so proper notification will occur.
    
    This patch also changes the varialbe action -> clock_set
    per Ingo's suggestion.
    
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: David Vrabel <david.vrabel@citrix.com>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: <xen-devel@lists.xen.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 7ffbcb388ddf91af51cb24eaacb51f6f0ffd535b
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Dec 11 18:50:25 2013 -0800

    timekeeping: Fix lost updates to tai adjustment
    
    commit f55c07607a38f84b5c7e6066ee1cfe433fa5643c upstream.
    
    Since 48cdc135d4840 (Implement a shadow timekeeper), we have to
    call timekeeping_update() after any adjustment to the timekeeping
    structure in order to make sure that any adjustments to the structure
    persist.
    
    Unfortunately, the updates to the tai offset via adjtimex do not
    trigger this update, causing adjustments to the tai offset to be
    made and then over-written by the previous value at the next
    update_wall_time() call.
    
    This patch resovles the issue by calling timekeeping_update()
    right after setting the tai offset.
    
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit f7efe92de8f98563e1a711021f91d55f9a1de963
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Dec 11 19:10:36 2013 -0800

    timekeeping: Fix missing timekeeping_update in suspend path
    
    commit 330a1617b0a6268d427aa5922c94d082b1d3e96d upstream.
    
    Since 48cdc135d4840 (Implement a shadow timekeeper), we have to
    call timekeeping_update() after any adjustment to the timekeeping
    structure in order to make sure that any adjustments to the structure
    persist.
    
    In the timekeeping suspend path, we udpate the timekeeper
    structure, so we should be sure to update the shadow-timekeeper
    before releasing the timekeeping locks. Currently this isn't done.
    
    In most cases, the next time related code to run would be
    timekeeping_resume, which does update the shadow-timekeeper, but
    in an abundence of caution, this patch adds the call to
    timekeeping_update() in the suspend path.
    
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit aaa5ad29bc420c04cb0df5e4d6876aa32096b7d0
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Dec 10 17:13:35 2013 -0800

    timekeeping: Fix CLOCK_TAI timer/nanosleep delays
    
    commit 04005f6011e3b504cd4d791d9769f7cb9a3b2eae upstream.
    
    A think-o in the calculation of the monotonic -> tai time offset
    results in CLOCK_TAI timers and nanosleeps to expire late (the
    latency is ~2x the tai offset).
    
    Fix this by adding the tai offset from the realtime offset instead
    of subtracting.
    
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit e14bada985c4af6d192413ad72dc35758cffe286
Author: John Stultz <john.stultz@linaro.org>
Date:   Mon Feb 10 13:07:21 2014 -0800

    3.13.y: timekeeping: Fix clock_set/clock_was_set think-o
    
    In backporting 6fdda9a9c5db367130cf32df5d6618d08b89f46a
    (timekeeping: Avoid possible deadlock from clock_was_set_delayed),
    I ralized the patch had a think-o where instead of checking
    clock_set I accidentally typed clock_was_set (which is a function
    - so the conditional always is true).
    
    Upstream this was resolved in the immediately following patch
    47a1b796306356f358e515149d86baf0cc6bf007 (tick/timekeeping: Call
    update_wall_time outside the jiffies lock). But since that patch
    really isn't -stable material, so this patch only pulls
    the name change.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit b6f484eae189da008d6afa7b68414bdc5d460066
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Dec 10 17:18:18 2013 -0800

    timekeeping: Avoid possible deadlock from clock_was_set_delayed
    
    commit 6fdda9a9c5db367130cf32df5d6618d08b89f46a upstream.
    
    As part of normal operaions, the hrtimer subsystem frequently calls
    into the timekeeping code, creating a locking order of
      hrtimer locks -> timekeeping locks
    
    clock_was_set_delayed() was suppoed to allow us to avoid deadlocks
    between the timekeeping the hrtimer subsystem, so that we could
    notify the hrtimer subsytem the time had changed while holding
    the timekeeping locks. This was done by scheduling delayed work
    that would run later once we were out of the timekeeing code.
    
    But unfortunately the lock chains are complex enoguh that in
    scheduling delayed work, we end up eventually trying to grab
    an hrtimer lock.
    
    Sasha Levin noticed this in testing when the new seqlock lockdep
    enablement triggered the following (somewhat abrieviated) message:
    
    [  251.100221] ======================================================
    [  251.100221] [ INFO: possible circular locking dependency detected ]
    [  251.100221] 3.13.0-rc2-next-20131206-sasha-00005-g8be2375-dirty #4053 Not tainted
    [  251.101967] -------------------------------------------------------
    [  251.101967] kworker/10:1/4506 is trying to acquire lock:
    [  251.101967]  (timekeeper_seq){----..}, at: [<ffffffff81160e96>] retrigger_next_event+0x56/0x70
    [  251.101967]
    [  251.101967] but task is already holding lock:
    [  251.101967]  (hrtimer_bases.lock#11){-.-...}, at: [<ffffffff81160e7c>] retrigger_next_event+0x3c/0x70
    [  251.101967]
    [  251.101967] which lock already depends on the new lock.
    [  251.101967]
    [  251.101967]
    [  251.101967] the existing dependency chain (in reverse order) is:
    [  251.101967]
    -> #5 (hrtimer_bases.lock#11){-.-...}:
    [snipped]
    -> #4 (&rt_b->rt_runtime_lock){-.-...}:
    [snipped]
    -> #3 (&rq->lock){-.-.-.}:
    [snipped]
    -> #2 (&p->pi_lock){-.-.-.}:
    [snipped]
    -> #1 (&(&pool->lock)->rlock){-.-...}:
    [  251.101967]        [<ffffffff81194803>] validate_chain+0x6c3/0x7b0
    [  251.101967]        [<ffffffff81194d9d>] __lock_acquire+0x4ad/0x580
    [  251.101967]        [<ffffffff81194ff2>] lock_acquire+0x182/0x1d0
    [  251.101967]        [<ffffffff84398500>] _raw_spin_lock+0x40/0x80
    [  251.101967]        [<ffffffff81153e69>] __queue_work+0x1a9/0x3f0
    [  251.101967]        [<ffffffff81154168>] queue_work_on+0x98/0x120
    [  251.101967]        [<ffffffff81161351>] clock_was_set_delayed+0x21/0x30
    [  251.101967]        [<ffffffff811c4bd1>] do_adjtimex+0x111/0x160
    [  251.101967]        [<ffffffff811e2711>] compat_sys_adjtimex+0x41/0x70
    [  251.101967]        [<ffffffff843a4b49>] ia32_sysret+0x0/0x5
    [  251.101967]
    -> #0 (timekeeper_seq){----..}:
    [snipped]
    [  251.101967] other info that might help us debug this:
    [  251.101967]
    [  251.101967] Chain exists of:
      timekeeper_seq --> &rt_b->rt_runtime_lock --> hrtimer_bases.lock#11
    
    [  251.101967]  Possible unsafe locking scenario:
    [  251.101967]
    [  251.101967]        CPU0                    CPU1
    [  251.101967]        ----                    ----
    [  251.101967]   lock(hrtimer_bases.lock#11);
    [  251.101967]                                lock(&rt_b->rt_runtime_lock);
    [  251.101967]                                lock(hrtimer_bases.lock#11);
    [  251.101967]   lock(timekeeper_seq);
    [  251.101967]
    [  251.101967]  *** DEADLOCK ***
    [  251.101967]
    [  251.101967] 3 locks held by kworker/10:1/4506:
    [  251.101967]  #0:  (events){.+.+.+}, at: [<ffffffff81154960>] process_one_work+0x200/0x530
    [  251.101967]  #1:  (hrtimer_work){+.+...}, at: [<ffffffff81154960>] process_one_work+0x200/0x530
    [  251.101967]  #2:  (hrtimer_bases.lock#11){-.-...}, at: [<ffffffff81160e7c>] retrigger_next_event+0x3c/0x70
    [  251.101967]
    [  251.101967] stack backtrace:
    [  251.101967] CPU: 10 PID: 4506 Comm: kworker/10:1 Not tainted 3.13.0-rc2-next-20131206-sasha-00005-g8be2375-dirty #4053
    [  251.101967] Workqueue: events clock_was_set_work
    
    So the best solution is to avoid calling clock_was_set_delayed() while
    holding the timekeeping lock, and instead using a flag variable to
    decide if we should call clock_was_set() once we've released the locks.
    
    This works for the case here, where the do_adjtimex() was the deadlock
    trigger point. Unfortuantely, in update_wall_time() we still hold
    the jiffies lock, which would deadlock with the ipi triggered by
    clock_was_set(), preventing us from calling it even after we drop the
    timekeeping lock. So instead call clock_was_set_delayed() at that point.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Reported-by: Sasha Levin <sasha.levin@oracle.com>
    Tested-by: Sasha Levin <sasha.levin@oracle.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 638d188c2444f60c9bfa24efff3e1a6e3695873b
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Dec 11 20:07:49 2013 -0800

    timekeeping: Fix potential lost pv notification of time change
    
    commit 5258d3f25c76f6ab86e9333abf97a55a877d3870 upstream.
    
    In 780427f0e11 (Indicate that clock was set in the pvclock
    gtod notifier), logic was added to pass a CLOCK_WAS_SET
    notification to the pvclock notifier chain.
    
    While that patch added a action flag returned from
    accumulate_nsecs_to_secs(), it only uses the returned value
    in one location, and not in the logarithmic accumulation.
    
    This means if a leap second triggered during the logarithmic
    accumulation (which is most likely where it would happen),
    the notification that the clock was set would not make it to
    the pv notifiers.
    
    This patch extends the logarithmic_accumulation pass down
    that action flag so proper notification will occur.
    
    This patch also changes the varialbe action -> clock_set
    per Ingo's suggestion.
    
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: David Vrabel <david.vrabel@citrix.com>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: <xen-devel@lists.xen.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 89c23e583d4f29e026b6bb4e05b12e9e85b844cb
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Dec 11 18:50:25 2013 -0800

    timekeeping: Fix lost updates to tai adjustment
    
    commit f55c07607a38f84b5c7e6066ee1cfe433fa5643c upstream.
    
    Since 48cdc135d4840 (Implement a shadow timekeeper), we have to
    call timekeeping_update() after any adjustment to the timekeeping
    structure in order to make sure that any adjustments to the structure
    persist.
    
    Unfortunately, the updates to the tai offset via adjtimex do not
    trigger this update, causing adjustments to the tai offset to be
    made and then over-written by the previous value at the next
    update_wall_time() call.
    
    This patch resovles the issue by calling timekeeping_update()
    right after setting the tai offset.
    
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit d9e8fada0c0161f6fe2499a1b7dc9ce18e20fec2
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Dec 10 17:18:18 2013 -0800

    timekeeping: Avoid possible deadlock from clock_was_set_delayed
    
    commit 6fdda9a9c5db367130cf32df5d6618d08b89f46a upstream.
    
    As part of normal operaions, the hrtimer subsystem frequently calls
    into the timekeeping code, creating a locking order of
      hrtimer locks -> timekeeping locks
    
    clock_was_set_delayed() was suppoed to allow us to avoid deadlocks
    between the timekeeping the hrtimer subsystem, so that we could
    notify the hrtimer subsytem the time had changed while holding
    the timekeeping locks. This was done by scheduling delayed work
    that would run later once we were out of the timekeeing code.
    
    But unfortunately the lock chains are complex enoguh that in
    scheduling delayed work, we end up eventually trying to grab
    an hrtimer lock.
    
    Sasha Levin noticed this in testing when the new seqlock lockdep
    enablement triggered the following (somewhat abrieviated) message:
    
    [  251.100221] ======================================================
    [  251.100221] [ INFO: possible circular locking dependency detected ]
    [  251.100221] 3.13.0-rc2-next-20131206-sasha-00005-g8be2375-dirty #4053 Not tainted
    [  251.101967] -------------------------------------------------------
    [  251.101967] kworker/10:1/4506 is trying to acquire lock:
    [  251.101967]  (timekeeper_seq){----..}, at: [<ffffffff81160e96>] retrigger_next_event+0x56/0x70
    [  251.101967]
    [  251.101967] but task is already holding lock:
    [  251.101967]  (hrtimer_bases.lock#11){-.-...}, at: [<ffffffff81160e7c>] retrigger_next_event+0x3c/0x70
    [  251.101967]
    [  251.101967] which lock already depends on the new lock.
    [  251.101967]
    [  251.101967]
    [  251.101967] the existing dependency chain (in reverse order) is:
    [  251.101967]
    -> #5 (hrtimer_bases.lock#11){-.-...}:
    [snipped]
    -> #4 (&rt_b->rt_runtime_lock){-.-...}:
    [snipped]
    -> #3 (&rq->lock){-.-.-.}:
    [snipped]
    -> #2 (&p->pi_lock){-.-.-.}:
    [snipped]
    -> #1 (&(&pool->lock)->rlock){-.-...}:
    [  251.101967]        [<ffffffff81194803>] validate_chain+0x6c3/0x7b0
    [  251.101967]        [<ffffffff81194d9d>] __lock_acquire+0x4ad/0x580
    [  251.101967]        [<ffffffff81194ff2>] lock_acquire+0x182/0x1d0
    [  251.101967]        [<ffffffff84398500>] _raw_spin_lock+0x40/0x80
    [  251.101967]        [<ffffffff81153e69>] __queue_work+0x1a9/0x3f0
    [  251.101967]        [<ffffffff81154168>] queue_work_on+0x98/0x120
    [  251.101967]        [<ffffffff81161351>] clock_was_set_delayed+0x21/0x30
    [  251.101967]        [<ffffffff811c4bd1>] do_adjtimex+0x111/0x160
    [  251.101967]        [<ffffffff811e2711>] compat_sys_adjtimex+0x41/0x70
    [  251.101967]        [<ffffffff843a4b49>] ia32_sysret+0x0/0x5
    [  251.101967]
    -> #0 (timekeeper_seq){----..}:
    [snipped]
    [  251.101967] other info that might help us debug this:
    [  251.101967]
    [  251.101967] Chain exists of:
      timekeeper_seq --> &rt_b->rt_runtime_lock --> hrtimer_bases.lock#11
    
    [  251.101967]  Possible unsafe locking scenario:
    [  251.101967]
    [  251.101967]        CPU0                    CPU1
    [  251.101967]        ----                    ----
    [  251.101967]   lock(hrtimer_bases.lock#11);
    [  251.101967]                                lock(&rt_b->rt_runtime_lock);
    [  251.101967]                                lock(hrtimer_bases.lock#11);
    [  251.101967]   lock(timekeeper_seq);
    [  251.101967]
    [  251.101967]  *** DEADLOCK ***
    [  251.101967]
    [  251.101967] 3 locks held by kworker/10:1/4506:
    [  251.101967]  #0:  (events){.+.+.+}, at: [<ffffffff81154960>] process_one_work+0x200/0x530
    [  251.101967]  #1:  (hrtimer_work){+.+...}, at: [<ffffffff81154960>] process_one_work+0x200/0x530
    [  251.101967]  #2:  (hrtimer_bases.lock#11){-.-...}, at: [<ffffffff81160e7c>] retrigger_next_event+0x3c/0x70
    [  251.101967]
    [  251.101967] stack backtrace:
    [  251.101967] CPU: 10 PID: 4506 Comm: kworker/10:1 Not tainted 3.13.0-rc2-next-20131206-sasha-00005-g8be2375-dirty #4053
    [  251.101967] Workqueue: events clock_was_set_work
    
    So the best solution is to avoid calling clock_was_set_delayed() while
    holding the timekeeping lock, and instead using a flag variable to
    decide if we should call clock_was_set() once we've released the locks.
    
    This works for the case here, where the do_adjtimex() was the deadlock
    trigger point. Unfortuantely, in update_wall_time() we still hold
    the jiffies lock, which would deadlock with the ipi triggered by
    clock_was_set(), preventing us from calling it even after we drop the
    timekeeping lock. So instead call clock_was_set_delayed() at that point.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Reported-by: Sasha Levin <sasha.levin@oracle.com>
    Tested-by: Sasha Levin <sasha.levin@oracle.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 226e0f713f585c549f4200bb8a69b6753dff28d0
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Dec 11 19:10:36 2013 -0800

    timekeeping: Fix missing timekeeping_update in suspend path
    
    commit 330a1617b0a6268d427aa5922c94d082b1d3e96d upstream.
    
    Since 48cdc135d4840 (Implement a shadow timekeeper), we have to
    call timekeeping_update() after any adjustment to the timekeeping
    structure in order to make sure that any adjustments to the structure
    persist.
    
    In the timekeeping suspend path, we udpate the timekeeper
    structure, so we should be sure to update the shadow-timekeeper
    before releasing the timekeeping locks. Currently this isn't done.
    
    In most cases, the next time related code to run would be
    timekeeping_resume, which does update the shadow-timekeeper, but
    in an abundence of caution, this patch adds the call to
    timekeeping_update() in the suspend path.
    
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit a8ad6b67721e81c2e181ae3e0f3aea79da779cd7
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Dec 10 17:13:35 2013 -0800

    timekeeping: Fix CLOCK_TAI timer/nanosleep delays
    
    commit 04005f6011e3b504cd4d791d9769f7cb9a3b2eae upstream.
    
    A think-o in the calculation of the monotonic -> tai time offset
    results in CLOCK_TAI timers and nanosleeps to expire late (the
    latency is ~2x the tai offset).
    
    Fix this by adding the tai offset from the realtime offset instead
    of subtracting.
    
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 77535a0a168b2bf7c4aa35a20792a6e895844424
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Dec 11 18:50:25 2013 -0800

    timekeeping: Fix lost updates to tai adjustment
    
    commit f55c07607a38f84b5c7e6066ee1cfe433fa5643c upstream.
    
    Since 48cdc135d4840 (Implement a shadow timekeeper), we have to
    call timekeeping_update() after any adjustment to the timekeeping
    structure in order to make sure that any adjustments to the structure
    persist.
    
    Unfortunately, the updates to the tai offset via adjtimex do not
    trigger this update, causing adjustments to the tai offset to be
    made and then over-written by the previous value at the next
    update_wall_time() call.
    
    This patch resovles the issue by calling timekeeping_update()
    right after setting the tai offset.
    
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit cd34de10471a5ddad397739fae33555d47e53769
Author: Colin Cross <ccross@android.com>
Date:   Mon Feb 10 13:16:29 2014 -0800

    3.4.y: timekeeping: fix 32-bit overflow in get_monotonic_boottime
    
    fixed upstream in v3.6 by ec145babe754f9ea1079034a108104b6001e001c
    
    get_monotonic_boottime adds three nanonsecond values stored
    in longs, followed by an s64.  If the long values are all
    close to 1e9 the first three additions can overflow and
    become negative when added to the s64.  Cast the first
    value to s64 so that all additions are 64 bit.
    
    Signed-off-by: Colin Cross <ccross@android.com>
    [jstultz: Fished this out of the AOSP commong.git tree. This was
    fixed upstream in v3.6 by ec145babe754f9ea1079034a108104b6001e001c]
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit cf85cc93b24891b7e57b1d9939742b5774570b19
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Dec 10 17:18:18 2013 -0800

    timekeeping: Avoid possible deadlock from clock_was_set_delayed
    
    commit 6fdda9a9c5db367130cf32df5d6618d08b89f46a upstream.
    
    As part of normal operaions, the hrtimer subsystem frequently calls
    into the timekeeping code, creating a locking order of
      hrtimer locks -> timekeeping locks
    
    clock_was_set_delayed() was suppoed to allow us to avoid deadlocks
    between the timekeeping the hrtimer subsystem, so that we could
    notify the hrtimer subsytem the time had changed while holding
    the timekeeping locks. This was done by scheduling delayed work
    that would run later once we were out of the timekeeing code.
    
    But unfortunately the lock chains are complex enoguh that in
    scheduling delayed work, we end up eventually trying to grab
    an hrtimer lock.
    
    Sasha Levin noticed this in testing when the new seqlock lockdep
    enablement triggered the following (somewhat abrieviated) message:
    
    [  251.100221] ======================================================
    [  251.100221] [ INFO: possible circular locking dependency detected ]
    [  251.100221] 3.13.0-rc2-next-20131206-sasha-00005-g8be2375-dirty #4053 Not tainted
    [  251.101967] -------------------------------------------------------
    [  251.101967] kworker/10:1/4506 is trying to acquire lock:
    [  251.101967]  (timekeeper_seq){----..}, at: [<ffffffff81160e96>] retrigger_next_event+0x56/0x70
    [  251.101967]
    [  251.101967] but task is already holding lock:
    [  251.101967]  (hrtimer_bases.lock#11){-.-...}, at: [<ffffffff81160e7c>] retrigger_next_event+0x3c/0x70
    [  251.101967]
    [  251.101967] which lock already depends on the new lock.
    [  251.101967]
    [  251.101967]
    [  251.101967] the existing dependency chain (in reverse order) is:
    [  251.101967]
    -> #5 (hrtimer_bases.lock#11){-.-...}:
    [snipped]
    -> #4 (&rt_b->rt_runtime_lock){-.-...}:
    [snipped]
    -> #3 (&rq->lock){-.-.-.}:
    [snipped]
    -> #2 (&p->pi_lock){-.-.-.}:
    [snipped]
    -> #1 (&(&pool->lock)->rlock){-.-...}:
    [  251.101967]        [<ffffffff81194803>] validate_chain+0x6c3/0x7b0
    [  251.101967]        [<ffffffff81194d9d>] __lock_acquire+0x4ad/0x580
    [  251.101967]        [<ffffffff81194ff2>] lock_acquire+0x182/0x1d0
    [  251.101967]        [<ffffffff84398500>] _raw_spin_lock+0x40/0x80
    [  251.101967]        [<ffffffff81153e69>] __queue_work+0x1a9/0x3f0
    [  251.101967]        [<ffffffff81154168>] queue_work_on+0x98/0x120
    [  251.101967]        [<ffffffff81161351>] clock_was_set_delayed+0x21/0x30
    [  251.101967]        [<ffffffff811c4bd1>] do_adjtimex+0x111/0x160
    [  251.101967]        [<ffffffff811e2711>] compat_sys_adjtimex+0x41/0x70
    [  251.101967]        [<ffffffff843a4b49>] ia32_sysret+0x0/0x5
    [  251.101967]
    -> #0 (timekeeper_seq){----..}:
    [snipped]
    [  251.101967] other info that might help us debug this:
    [  251.101967]
    [  251.101967] Chain exists of:
      timekeeper_seq --> &rt_b->rt_runtime_lock --> hrtimer_bases.lock#11
    
    [  251.101967]  Possible unsafe locking scenario:
    [  251.101967]
    [  251.101967]        CPU0                    CPU1
    [  251.101967]        ----                    ----
    [  251.101967]   lock(hrtimer_bases.lock#11);
    [  251.101967]                                lock(&rt_b->rt_runtime_lock);
    [  251.101967]                                lock(hrtimer_bases.lock#11);
    [  251.101967]   lock(timekeeper_seq);
    [  251.101967]
    [  251.101967]  *** DEADLOCK ***
    [  251.101967]
    [  251.101967] 3 locks held by kworker/10:1/4506:
    [  251.101967]  #0:  (events){.+.+.+}, at: [<ffffffff81154960>] process_one_work+0x200/0x530
    [  251.101967]  #1:  (hrtimer_work){+.+...}, at: [<ffffffff81154960>] process_one_work+0x200/0x530
    [  251.101967]  #2:  (hrtimer_bases.lock#11){-.-...}, at: [<ffffffff81160e7c>] retrigger_next_event+0x3c/0x70
    [  251.101967]
    [  251.101967] stack backtrace:
    [  251.101967] CPU: 10 PID: 4506 Comm: kworker/10:1 Not tainted 3.13.0-rc2-next-20131206-sasha-00005-g8be2375-dirty #4053
    [  251.101967] Workqueue: events clock_was_set_work
    
    So the best solution is to avoid calling clock_was_set_delayed() while
    holding the timekeeping lock, and instead using a flag variable to
    decide if we should call clock_was_set() once we've released the locks.
    
    This works for the case here, where the do_adjtimex() was the deadlock
    trigger point. Unfortuantely, in update_wall_time() we still hold
    the jiffies lock, which would deadlock with the ipi triggered by
    clock_was_set(), preventing us from calling it even after we drop the
    timekeeping lock. So instead call clock_was_set_delayed() at that point.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Reported-by: Sasha Levin <sasha.levin@oracle.com>
    Tested-by: Sasha Levin <sasha.levin@oracle.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit e8b175946c16d7001b22620f52d78ab497efc9d0
Author: Shaibal Dutta <shaibal.dutta@linaro.org>
Date:   Fri Jan 31 11:18:24 2014 -0800

    timekeeping: Move clock sync work to power efficient workqueue
    
    For better use of CPU idle time, allow the scheduler to select the CPU
    on which the CMOS clock sync work would be scheduled. This improves
    idle residency time and conserver power.
    
    This functionality is enabled when CONFIG_WQ_POWER_EFFICIENT is selected.
    
    Signed-off-by: Shaibal Dutta <shaibal.dutta@broadcom.com>
    [zoran.markovic@linaro.org: Added commit message. Aligned code.]
    Signed-off-by: Zoran Markovic <zoran.markovic@linaro.org>
    Cc: John Stultz <john.stultz@linaro.org>
    Link: http://lkml.kernel.org/r/1391195904-12497-1-git-send-email-zoran.markovic@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit aafd9d6a46745926648cb5d0b68b108e79ceb8d4
Merge: 595bf999e3a8 a2b4c607c93a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jan 31 09:02:51 2014 -0800

    Merge branch 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer/dynticks updates from Ingo Molnar:
     "This tree contains misc dynticks updates: a fix and three cleanups"
    
    * 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      sched/nohz: Fix overflow error in scheduler_tick_max_deferment()
      nohz_full: fix code style issue of tick_nohz_full_stop_tick
      nohz: Get timekeeping max deferment outside jiffies_lock
      tick: Rename tick_check_idle() to tick_irq_enter()

commit 09da8dfa98682d871987145ed11e3232accac860
Merge: 3aacd625f201 7744064731a9
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jan 24 15:51:02 2014 -0800

    Merge tag 'pm+acpi-3.14-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull ACPI and power management updates from Rafael Wysocki:
     "As far as the number of commits goes, the top spot belongs to ACPI
      this time with cpufreq in the second position and a handful of PM
      core, PNP and cpuidle updates.  They are fixes and cleanups mostly, as
      usual, with a couple of new features in the mix.
    
      The most visible change is probably that we will create struct
      acpi_device objects (visible in sysfs) for all devices represented in
      the ACPI tables regardless of their status and there will be a new
      sysfs attribute under those objects allowing user space to check that
      status via _STA.
    
      Consequently, ACPI device eject or generally hot-removal will not
      delete those objects, unless the table containing the corresponding
      namespace nodes is unloaded, which is extremely rare.  Also ACPI
      container hotplug will be handled quite a bit differently and cpufreq
      will support CPU boost ("turbo") generically and not only in the
      acpi-cpufreq driver.
    
      Specifics:
    
       - ACPI core changes to make it create a struct acpi_device object for
         every device represented in the ACPI tables during all namespace
         scans regardless of the current status of that device.  In
         accordance with this, ACPI hotplug operations will not delete those
         objects, unless the underlying ACPI tables go away.
    
       - On top of the above, new sysfs attribute for ACPI device objects
         allowing user space to check device status by triggering the
         execution of _STA for its ACPI object.  From Srinivas Pandruvada.
    
       - ACPI core hotplug changes reducing code duplication, integrating
         the PCI root hotplug with the core and reworking container hotplug.
    
       - ACPI core simplifications making it use ACPI_COMPANION() in the
         code "glueing" ACPI device objects to "physical" devices.
    
       - ACPICA update to upstream version 20131218.  This adds support for
         the DBG2 and PCCT tables to ACPICA, fixes some bugs and improves
         debug facilities.  From Bob Moore, Lv Zheng and Betty Dall.
    
       - Init code change to carry out the early ACPI initialization
         earlier.  That should allow us to use ACPI during the timekeeping
         initialization and possibly to simplify the EFI initialization too.
         From Chun-Yi Lee.
    
       - Clenups of the inclusions of ACPI headers in many places all over
         from Lv Zheng and Rashika Kheria (work in progress).
    
       - New helper for ACPI _DSM execution and rework of the code in
         drivers that uses _DSM to execute it via the new helper.  From
         Jiang Liu.
    
       - New Win8 OSI blacklist entries from Takashi Iwai.
    
       - Assorted ACPI fixes and cleanups from Al Stone, Emil Goode, Hanjun
         Guo, Lan Tianyu, Masanari Iida, Oliver Neukum, Prarit Bhargava,
         Rashika Kheria, Tang Chen, Zhang Rui.
    
       - intel_pstate driver updates, including proper Baytrail support,
         from Dirk Brandewie and intel_pstate documentation from Ramkumar
         Ramachandra.
    
       - Generic CPU boost ("turbo") support for cpufreq from Lukasz
         Majewski.
    
       - powernow-k6 cpufreq driver fixes from Mikulas Patocka.
    
       - cpufreq core fixes and cleanups from Viresh Kumar, Jane Li, Mark
         Brown.
    
       - Assorted cpufreq drivers fixes and cleanups from Anson Huang, John
         Tobias, Paul Bolle, Paul Walmsley, Sachin Kamat, Shawn Guo, Viresh
         Kumar.
    
       - cpuidle cleanups from Bartlomiej Zolnierkiewicz.
    
       - Support for hibernation APM events from Bin Shi.
    
       - Hibernation fix to avoid bringing up nonboot CPUs with ACPI EC
         disabled during thaw transitions from Bjørn Mork.
    
       - PM core fixes and cleanups from Ben Dooks, Leonardo Potenza, Ulf
         Hansson.
    
       - PNP subsystem fixes and cleanups from Dmitry Torokhov, Levente
         Kurusa, Rashika Kheria.
    
       - New tool for profiling system suspend from Todd E Brandt and a
         cpupower tool cleanup from One Thousand Gnomes"
    
    * tag 'pm+acpi-3.14-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (153 commits)
      thermal: exynos: boost: Automatic enable/disable of BOOST feature (at Exynos4412)
      cpufreq: exynos4x12: Change L0 driver data to CPUFREQ_BOOST_FREQ
      Documentation: cpufreq / boost: Update BOOST documentation
      cpufreq: exynos: Extend Exynos cpufreq driver to support boost
      cpufreq / boost: Kconfig: Support for software-managed BOOST
      acpi-cpufreq: Adjust the code to use the common boost attribute
      cpufreq: Add boost frequency support in core
      intel_pstate: Add trace point to report internal state.
      cpufreq: introduce cpufreq_generic_get() routine
      ARM: SA1100: Create dummy clk_get_rate() to avoid build failures
      cpufreq: stats: create sysfs entries when cpufreq_stats is a module
      cpufreq: stats: free table and remove sysfs entry in a single routine
      cpufreq: stats: remove hotplug notifiers
      cpufreq: stats: handle cpufreq_unregister_driver() and suspend/resume properly
      cpufreq: speedstep: remove unused speedstep_get_state
      platform: introduce OF style 'modalias' support for platform bus
      PM / tools: new tool for suspend/resume performance optimization
      ACPI: fix module autoloading for ACPI enumerated devices
      ACPI: add module autoloading support for ACPI enumerated devices
      ACPI: fix create_modalias() return value handling
      ...

commit 6c6461435611e1d4843516f2d55e8316c009112e
Merge: a0fa1dd3cdbc 00e2bcd6d35f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jan 20 11:34:26 2014 -0800

    Merge branch 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer changes from Ingo Molnar:
      - ARM clocksource/clockevent improvements and fixes
      - generic timekeeping updates: TAI fixes/improvements, cleanups
      - Posix cpu timer cleanups and improvements
      - dynticks updates: full dynticks bugfixes, optimizations and cleanups
    
    * 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (46 commits)
      clocksource: Timer-sun5i: Switch to sched_clock_register()
      timekeeping: Remove comment that's mostly out of date
      rtc-cmos: Add an alarm disable quirk
      timekeeper: fix comment typo for tk_setup_internals()
      timekeeping: Fix missing timekeeping_update in suspend path
      timekeeping: Fix CLOCK_TAI timer/nanosleep delays
      tick/timekeeping: Call update_wall_time outside the jiffies lock
      timekeeping: Avoid possible deadlock from clock_was_set_delayed
      timekeeping: Fix potential lost pv notification of time change
      timekeeping: Fix lost updates to tai adjustment
      clocksource: sh_cmt: Add clk_prepare/unprepare support
      clocksource: bcm_kona_timer: Remove unused bcm_timer_ids
      clocksource: vt8500: Remove deprecated IRQF_DISABLED
      clocksource: tegra: Remove deprecated IRQF_DISABLED
      clocksource: misc drivers: Remove deprecated IRQF_DISABLED
      clocksource: sh_mtu2: Remove unnecessary platform_set_drvdata()
      clocksource: sh_tmu: Remove unnecessary platform_set_drvdata()
      clocksource: armada-370-xp: Enable timer divider only when needed
      clocksource: clksrc-of: Warn if no clock sources are found
      clocksource: orion: Switch to sched_clock_register()
      ...

commit 8341ecc9f4eb7513951bd1986d78185a11ac6d4e
Merge: 380062bd66dc 73f7d1ca3263 00159a201326
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Jan 17 01:57:26 2014 +0100

    Merge branches 'acpi-init' and 'acpi-hotplug'
    
    * acpi-init:
      ACPI / init: Run acpi_early_init() before timekeeping_init()
    
    * acpi-hotplug:
      ACPI / memhotplug: add parameter to disable memory hotplug

commit 73f7d1ca32638028e3271f54616773727e2f9f26
Author: Lee, Chun-Yi <joeyli.kernel@gmail.com>
Date:   Wed Jan 15 15:25:48 2014 +0800

    ACPI / init: Run acpi_early_init() before timekeeping_init()
    
    This is a variant patch from Rafael J. Wysocki's
    ACPI / init: Run acpi_early_init() before efi_enter_virtual_mode()
    
    According to Matt Fleming, if acpi_early_init() was executed before
    efi_enter_virtual_mode(), the EFI initialization could benefit from
    it, so Rafael's patch makes that happen.
    
    And, we want accessing ACPI TAD device to set system clock, so move
    acpi_early_init() before timekeeping_init(). This final position is
    also before efi_enter_virtual_mode().
    
    Tested-by: Toshi Kani <toshi.kani@hp.com>
    Signed-off-by: Lee, Chun-Yi <jlee@suse.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 32956a0646e1f63e03d2dbf35370772934d5654f
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sun Dec 29 12:39:50 2013 +0000

    ARM: fix footbridge clockevent device
    
    commit 4ff859fe1dc0da0f87bbdfff78f527898878fa4a upstream.
    
    The clockevents code was being told that the footbridge clock event
    device ticks at 16x the rate which it actually does.  This leads to
    timekeeping problems since it allows the clocksource to wrap before
    the kernel notices.  Fix this by using the correct clock.
    
    Fixes: 4e8d76373c9fd ("ARM: footbridge: convert to clockevents/clocksource")
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 4adf2b4bd303e73dfc13c3428383a8dba129fdb5
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sun Dec 29 12:39:50 2013 +0000

    ARM: fix footbridge clockevent device
    
    commit 4ff859fe1dc0da0f87bbdfff78f527898878fa4a upstream.
    
    The clockevents code was being told that the footbridge clock event
    device ticks at 16x the rate which it actually does.  This leads to
    timekeeping problems since it allows the clocksource to wrap before
    the kernel notices.  Fix this by using the correct clock.
    
    Fixes: 4e8d76373c9fd ("ARM: footbridge: convert to clockevents/clocksource")
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 855a0fc30b70d6ae681badd24d6625f9a9abb787
Author: Frederic Weisbecker <fweisbec@gmail.com>
Date:   Tue Dec 17 00:16:37 2013 +0100

    nohz: Get timekeeping max deferment outside jiffies_lock
    
    We don't need to fetch the timekeeping max deferment under the
    jiffies_lock seqlock.
    
    If the clocksource is updated concurrently while we stop the tick,
    stop machine is called and the tick will be reevaluated again along with
    uptodate jiffies and its related values.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Alex Shi <alex.shi@linaro.org>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Kevin Hilman <khilman@linaro.org>
    Link: http://lkml.kernel.org/r/1387320692-28460-9-git-send-email-fweisbec@gmail.com
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>

commit 5acac1be499d979e3aa463ea73a498888faefcbe
Author: Frederic Weisbecker <fweisbec@gmail.com>
Date:   Wed Dec 4 18:28:20 2013 +0100

    tick: Rename tick_check_idle() to tick_irq_enter()
    
    This makes the code more symetric against the existing tick functions
    called on irq exit: tick_irq_exit() and tick_nohz_irq_exit().
    
    These function are also symetric as they mirror each other's action:
    we start to account idle time on irq exit and we stop this accounting
    on irq entry. Also the tick is stopped on irq exit and timekeeping
    catches up with the tickless time elapsed until we reach irq entry.
    
    This rename was suggested by Peter Zijlstra a long while ago but it
    got forgotten in the mass.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Alex Shi <alex.shi@linaro.org>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Kevin Hilman <khilman@linaro.org>
    Link: http://lkml.kernel.org/r/1387320692-28460-2-git-send-email-fweisbec@gmail.com
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>

commit d05d24a984f8e14086771a158083dbe6facb769e
Merge: dba861461f88 38aef31ce777
Author: Ingo Molnar <mingo@kernel.org>
Date:   Sun Jan 12 14:13:31 2014 +0100

    Merge branch 'fortglx/3.14/time' of git://git.linaro.org/people/john.stultz/linux into timers/core
    
    Pull timekeeping updates from John Stultz.
    
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit c01f97387ea4fa2fd57a22d38f22bcfe364b1b6f
Merge: 55e0b071892c 6a79799d5654
Author: Olof Johansson <olof@lixom.net>
Date:   Thu Jan 2 11:58:30 2014 -0800

    Merge tag 'u300-for-arm-soc-1' of git://git.kernel.org/pub/scm/linux/kernel/git/linusw/linux-stericsson into next/fixes-non-critical
    
    From Linus Walleij:
    Misc U300 development for the v3.14 series:
    
    - Timekeeping patch from Uwe.
    - DT 0x0 cleanup from Lee.
    - Return value check from Wei.
    
    * tag 'u300-for-arm-soc-1' of git://git.kernel.org/pub/scm/linux/kernel/git/linusw/linux-stericsson:
      ARM: u300: fix timekeeping when periodic mode is used
      ARM: u300: Remove '0x's from U300 DTS file
      ARM: u300: fix return value check in __u300_init_boardpower()
    
    Signed-off-by: Olof Johansson <olof@lixom.net>

commit 4ff859fe1dc0da0f87bbdfff78f527898878fa4a
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sun Dec 29 12:39:50 2013 +0000

    ARM: fix footbridge clockevent device
    
    The clockevents code was being told that the footbridge clock event
    device ticks at 16x the rate which it actually does.  This leads to
    timekeeping problems since it allows the clocksource to wrap before
    the kernel notices.  Fix this by using the correct clock.
    
    Fixes: 4e8d76373c9fd ("ARM: footbridge: convert to clockevents/clocksource")
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Cc: <stable@vger.kernel.org>

commit 38aef31ce7773624c8f09ff58c4c27b3b955faaf
Author: John Stultz <john.stultz@linaro.org>
Date:   Mon Dec 23 12:53:22 2013 -0800

    timekeeping: Remove comment that's mostly out of date
    
    Prior to 92bb1fcf57a0c2e45f7e67fbf0a8ed475a749236 (Only
    do nanosecond rounding on GENERIC_TIME_VSYSCALL_OLD
    systems), the comment here was accuate, but now we can
    mostly avoid the extra rounding which causes the unlikey
    to be actually likely here.
    
    So remove the out of date comment.
    
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 330a1617b0a6268d427aa5922c94d082b1d3e96d
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Dec 11 19:10:36 2013 -0800

    timekeeping: Fix missing timekeeping_update in suspend path
    
    Since 48cdc135d4840 (Implement a shadow timekeeper), we have to
    call timekeeping_update() after any adjustment to the timekeeping
    structure in order to make sure that any adjustments to the structure
    persist.
    
    In the timekeeping suspend path, we udpate the timekeeper
    structure, so we should be sure to update the shadow-timekeeper
    before releasing the timekeeping locks. Currently this isn't done.
    
    In most cases, the next time related code to run would be
    timekeeping_resume, which does update the shadow-timekeeper, but
    in an abundence of caution, this patch adds the call to
    timekeeping_update() in the suspend path.
    
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: stable <stable@vger.kernel.org> #3.10+
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 04005f6011e3b504cd4d791d9769f7cb9a3b2eae
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Dec 10 17:13:35 2013 -0800

    timekeeping: Fix CLOCK_TAI timer/nanosleep delays
    
    A think-o in the calculation of the monotonic -> tai time offset
    results in CLOCK_TAI timers and nanosleeps to expire late (the
    latency is ~2x the tai offset).
    
    Fix this by adding the tai offset from the realtime offset instead
    of subtracting.
    
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: stable <stable@vger.kernel.org> #3.10+
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 47a1b796306356f358e515149d86baf0cc6bf007
Author: John Stultz <john.stultz@linaro.org>
Date:   Thu Dec 12 13:10:55 2013 -0800

    tick/timekeeping: Call update_wall_time outside the jiffies lock
    
    Since the xtime lock was split into the timekeeping lock and
    the jiffies lock, we no longer need to call update_wall_time()
    while holding the jiffies lock.
    
    Thus, this patch splits update_wall_time() out from do_timer().
    
    This allows us to get away from calling clock_was_set_delayed()
    in update_wall_time() and instead use the standard clock_was_set()
    call that previously would deadlock, as it causes the jiffies lock
    to be acquired.
    
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 6fdda9a9c5db367130cf32df5d6618d08b89f46a
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Dec 10 17:18:18 2013 -0800

    timekeeping: Avoid possible deadlock from clock_was_set_delayed
    
    As part of normal operaions, the hrtimer subsystem frequently calls
    into the timekeeping code, creating a locking order of
      hrtimer locks -> timekeeping locks
    
    clock_was_set_delayed() was suppoed to allow us to avoid deadlocks
    between the timekeeping the hrtimer subsystem, so that we could
    notify the hrtimer subsytem the time had changed while holding
    the timekeeping locks. This was done by scheduling delayed work
    that would run later once we were out of the timekeeing code.
    
    But unfortunately the lock chains are complex enoguh that in
    scheduling delayed work, we end up eventually trying to grab
    an hrtimer lock.
    
    Sasha Levin noticed this in testing when the new seqlock lockdep
    enablement triggered the following (somewhat abrieviated) message:
    
    [  251.100221] ======================================================
    [  251.100221] [ INFO: possible circular locking dependency detected ]
    [  251.100221] 3.13.0-rc2-next-20131206-sasha-00005-g8be2375-dirty #4053 Not tainted
    [  251.101967] -------------------------------------------------------
    [  251.101967] kworker/10:1/4506 is trying to acquire lock:
    [  251.101967]  (timekeeper_seq){----..}, at: [<ffffffff81160e96>] retrigger_next_event+0x56/0x70
    [  251.101967]
    [  251.101967] but task is already holding lock:
    [  251.101967]  (hrtimer_bases.lock#11){-.-...}, at: [<ffffffff81160e7c>] retrigger_next_event+0x3c/0x70
    [  251.101967]
    [  251.101967] which lock already depends on the new lock.
    [  251.101967]
    [  251.101967]
    [  251.101967] the existing dependency chain (in reverse order) is:
    [  251.101967]
    -> #5 (hrtimer_bases.lock#11){-.-...}:
    [snipped]
    -> #4 (&rt_b->rt_runtime_lock){-.-...}:
    [snipped]
    -> #3 (&rq->lock){-.-.-.}:
    [snipped]
    -> #2 (&p->pi_lock){-.-.-.}:
    [snipped]
    -> #1 (&(&pool->lock)->rlock){-.-...}:
    [  251.101967]        [<ffffffff81194803>] validate_chain+0x6c3/0x7b0
    [  251.101967]        [<ffffffff81194d9d>] __lock_acquire+0x4ad/0x580
    [  251.101967]        [<ffffffff81194ff2>] lock_acquire+0x182/0x1d0
    [  251.101967]        [<ffffffff84398500>] _raw_spin_lock+0x40/0x80
    [  251.101967]        [<ffffffff81153e69>] __queue_work+0x1a9/0x3f0
    [  251.101967]        [<ffffffff81154168>] queue_work_on+0x98/0x120
    [  251.101967]        [<ffffffff81161351>] clock_was_set_delayed+0x21/0x30
    [  251.101967]        [<ffffffff811c4bd1>] do_adjtimex+0x111/0x160
    [  251.101967]        [<ffffffff811e2711>] compat_sys_adjtimex+0x41/0x70
    [  251.101967]        [<ffffffff843a4b49>] ia32_sysret+0x0/0x5
    [  251.101967]
    -> #0 (timekeeper_seq){----..}:
    [snipped]
    [  251.101967] other info that might help us debug this:
    [  251.101967]
    [  251.101967] Chain exists of:
      timekeeper_seq --> &rt_b->rt_runtime_lock --> hrtimer_bases.lock#11
    
    [  251.101967]  Possible unsafe locking scenario:
    [  251.101967]
    [  251.101967]        CPU0                    CPU1
    [  251.101967]        ----                    ----
    [  251.101967]   lock(hrtimer_bases.lock#11);
    [  251.101967]                                lock(&rt_b->rt_runtime_lock);
    [  251.101967]                                lock(hrtimer_bases.lock#11);
    [  251.101967]   lock(timekeeper_seq);
    [  251.101967]
    [  251.101967]  *** DEADLOCK ***
    [  251.101967]
    [  251.101967] 3 locks held by kworker/10:1/4506:
    [  251.101967]  #0:  (events){.+.+.+}, at: [<ffffffff81154960>] process_one_work+0x200/0x530
    [  251.101967]  #1:  (hrtimer_work){+.+...}, at: [<ffffffff81154960>] process_one_work+0x200/0x530
    [  251.101967]  #2:  (hrtimer_bases.lock#11){-.-...}, at: [<ffffffff81160e7c>] retrigger_next_event+0x3c/0x70
    [  251.101967]
    [  251.101967] stack backtrace:
    [  251.101967] CPU: 10 PID: 4506 Comm: kworker/10:1 Not tainted 3.13.0-rc2-next-20131206-sasha-00005-g8be2375-dirty #4053
    [  251.101967] Workqueue: events clock_was_set_work
    
    So the best solution is to avoid calling clock_was_set_delayed() while
    holding the timekeeping lock, and instead using a flag variable to
    decide if we should call clock_was_set() once we've released the locks.
    
    This works for the case here, where the do_adjtimex() was the deadlock
    trigger point. Unfortuantely, in update_wall_time() we still hold
    the jiffies lock, which would deadlock with the ipi triggered by
    clock_was_set(), preventing us from calling it even after we drop the
    timekeeping lock. So instead call clock_was_set_delayed() at that point.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Cc: stable <stable@vger.kernel.org> #3.10+
    Reported-by: Sasha Levin <sasha.levin@oracle.com>
    Tested-by: Sasha Levin <sasha.levin@oracle.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 5258d3f25c76f6ab86e9333abf97a55a877d3870
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Dec 11 20:07:49 2013 -0800

    timekeeping: Fix potential lost pv notification of time change
    
    In 780427f0e11 (Indicate that clock was set in the pvclock
    gtod notifier), logic was added to pass a CLOCK_WAS_SET
    notification to the pvclock notifier chain.
    
    While that patch added a action flag returned from
    accumulate_nsecs_to_secs(), it only uses the returned value
    in one location, and not in the logarithmic accumulation.
    
    This means if a leap second triggered during the logarithmic
    accumulation (which is most likely where it would happen),
    the notification that the clock was set would not make it to
    the pv notifiers.
    
    This patch extends the logarithmic_accumulation pass down
    that action flag so proper notification will occur.
    
    This patch also changes the varialbe action -> clock_set
    per Ingo's suggestion.
    
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: David Vrabel <david.vrabel@citrix.com>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: <xen-devel@lists.xen.org>
    Cc: stable <stable@vger.kernel.org> #3.11+
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit f55c07607a38f84b5c7e6066ee1cfe433fa5643c
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Dec 11 18:50:25 2013 -0800

    timekeeping: Fix lost updates to tai adjustment
    
    Since 48cdc135d4840 (Implement a shadow timekeeper), we have to
    call timekeeping_update() after any adjustment to the timekeeping
    structure in order to make sure that any adjustments to the structure
    persist.
    
    Unfortunately, the updates to the tai offset via adjtimex do not
    trigger this update, causing adjustments to the tai offset to be
    made and then over-written by the previous value at the next
    update_wall_time() call.
    
    This patch resovles the issue by calling timekeeping_update()
    right after setting the tai offset.
    
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: stable <stable@vger.kernel.org> #3.10+
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 53985371458fc17405c7fc277e6f05fe36965eab
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Thu Dec 19 22:22:23 2013 +0100

    ARM: rpc: stop using <mach/timex.h>
    
    The rpc timekeeping code uses the symbol LATCH which depends on
    CLOCK_TICK_RATE which is defined in rpc's <mach/timex.h>. As this header
    will go away in a later patch introduce a local variable holding the
    same value as LATCH and use that instead.
    
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>

commit 90a01bfc77a797b9fb59d0f88224a9de02953700
Author: Martin Schwidefsky <schwidefsky@de.ibm.com>
Date:   Fri Nov 22 11:44:51 2013 -0800

    time: Fix 1ns/tick drift w/ GENERIC_TIME_VSYSCALL_OLD
    
    commit 4be77398ac9d948773116b6be4a3c91b3d6ea18c upstream.
    
    Since commit 1e75fa8be9f (time: Condense timekeeper.xtime
    into xtime_sec - merged in v3.6), there has been an problem
    with the error accounting in the timekeeping code, such that
    when truncating to nanoseconds, we round up to the next nsec,
    but the balancing adjustment to the ntp_error value was dropped.
    
    This causes 1ns per tick drift forward of the clock.
    
    In 3.7, this logic was isolated to only GENERIC_TIME_VSYSCALL_OLD
    architectures (s390, ia64, powerpc).
    
    The fix is simply to balance the accounting and to subtract the
    added nanosecond from ntp_error. This allows the internal long-term
    clock steering to keep the clock accurate.
    
    While this fix removes the regression added in 1e75fa8be9f, the
    ideal solution is to move away from GENERIC_TIME_VSYSCALL_OLD
    and use the new VSYSCALL method, which avoids entirely the
    nanosecond granular rounding, and the resulting short-term clock
    adjustment oscillation needed to keep long term accurate time.
    
    [ jstultz: Many thanks to Martin for his efforts identifying this
               subtle bug, and providing the fix. ]
    
    Originally-from: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Paul Turner <pjt@google.com>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Fenghua Yu <fenghua.yu@intel.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/1385149491-20307-1-git-send-email-john.stultz@linaro.org
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 78f8d9b5647283bdea224d9bb7fb99f8f37a7614
Author: Martin Schwidefsky <schwidefsky@de.ibm.com>
Date:   Fri Nov 22 11:44:51 2013 -0800

    time: Fix 1ns/tick drift w/ GENERIC_TIME_VSYSCALL_OLD
    
    commit 4be77398ac9d948773116b6be4a3c91b3d6ea18c upstream.
    
    Since commit 1e75fa8be9f (time: Condense timekeeper.xtime
    into xtime_sec - merged in v3.6), there has been an problem
    with the error accounting in the timekeeping code, such that
    when truncating to nanoseconds, we round up to the next nsec,
    but the balancing adjustment to the ntp_error value was dropped.
    
    This causes 1ns per tick drift forward of the clock.
    
    In 3.7, this logic was isolated to only GENERIC_TIME_VSYSCALL_OLD
    architectures (s390, ia64, powerpc).
    
    The fix is simply to balance the accounting and to subtract the
    added nanosecond from ntp_error. This allows the internal long-term
    clock steering to keep the clock accurate.
    
    While this fix removes the regression added in 1e75fa8be9f, the
    ideal solution is to move away from GENERIC_TIME_VSYSCALL_OLD
    and use the new VSYSCALL method, which avoids entirely the
    nanosecond granular rounding, and the resulting short-term clock
    adjustment oscillation needed to keep long term accurate time.
    
    [ jstultz: Many thanks to Martin for his efforts identifying this
               subtle bug, and providing the fix. ]
    
    Originally-from: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Paul Turner <pjt@google.com>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Fenghua Yu <fenghua.yu@intel.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/1385149491-20307-1-git-send-email-john.stultz@linaro.org
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 1ab231b274ba51a54acebec23c6aded0f3cdf54e
Merge: dea4f48a0a30 0e576acbc1d9
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Dec 4 08:52:09 2013 -0800

    Merge branch 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer fixes from Thomas Gleixner:
    
     - timekeeping: Cure a subtle drift issue on GENERIC_TIME_VSYSCALL_OLD
    
     - nohz: Make CONFIG_NO_HZ=n and nohz=off command line option behave the
       same way.  Fixes a long standing load accounting wreckage.
    
     - clocksource/ARM: Kconfig update to avoid ARM=n wreckage
    
     - clocksource/ARM: Fixlets for the AT91 and SH clocksource/clockevents
    
     - Trivial documentation update and kzalloc conversion from akpms pile
    
    * 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      nohz: Fix another inconsistency between CONFIG_NO_HZ=n and nohz=off
      time: Fix 1ns/tick drift w/ GENERIC_TIME_VSYSCALL_OLD
      clocksource: arm_arch_timer: Hide eventstream Kconfig on non-ARM
      clocksource: sh_tmu: Add clk_prepare/unprepare support
      clocksource: sh_tmu: Release clock when sh_tmu_register() fails
      clocksource: sh_mtu2: Add clk_prepare/unprepare support
      clocksource: sh_mtu2: Release clock when sh_mtu2_register() fails
      ARM: at91: rm9200: switch back to clockevents_config_and_register
      tick: Document tick_do_timer_cpu
      timer: Convert kmalloc_node(...GFP_ZERO...) to kzalloc_node(...)
      NOHZ: Check for nohz active instead of nohz enabled

commit 6a79799d5654bb7800614e8b7a009252be7ff90e
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Tue Nov 5 10:03:19 2013 +0100

    ARM: u300: fix timekeeping when periodic mode is used
    
    To determine the value to write to the hardware's timer counter register
    the symbol CLOCK_TICK_RATE is used. This value is a dummy value on u300
    though. So instead use the clock rate that is used for oneshot mode.
    
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

commit 4be77398ac9d948773116b6be4a3c91b3d6ea18c
Author: Martin Schwidefsky <schwidefsky@de.ibm.com>
Date:   Fri Nov 22 11:44:51 2013 -0800

    time: Fix 1ns/tick drift w/ GENERIC_TIME_VSYSCALL_OLD
    
    Since commit 1e75fa8be9f (time: Condense timekeeper.xtime
    into xtime_sec - merged in v3.6), there has been an problem
    with the error accounting in the timekeeping code, such that
    when truncating to nanoseconds, we round up to the next nsec,
    but the balancing adjustment to the ntp_error value was dropped.
    
    This causes 1ns per tick drift forward of the clock.
    
    In 3.7, this logic was isolated to only GENERIC_TIME_VSYSCALL_OLD
    architectures (s390, ia64, powerpc).
    
    The fix is simply to balance the accounting and to subtract the
    added nanosecond from ntp_error. This allows the internal long-term
    clock steering to keep the clock accurate.
    
    While this fix removes the regression added in 1e75fa8be9f, the
    ideal solution is to move away from GENERIC_TIME_VSYSCALL_OLD
    and use the new VSYSCALL method, which avoids entirely the
    nanosecond granular rounding, and the resulting short-term clock
    adjustment oscillation needed to keep long term accurate time.
    
    [ jstultz: Many thanks to Martin for his efforts identifying this
               subtle bug, and providing the fix. ]
    
    Originally-from: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Paul Turner <pjt@google.com>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Fenghua Yu <fenghua.yu@intel.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable <stable@vger.kernel.org>  #v3.6+
    Link: http://lkml.kernel.org/r/1385149491-20307-1-git-send-email-john.stultz@linaro.org
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 0891ad829d2a0501053703df66029e843e3b8365
Merge: f63c4824aa1b 392a546dc836
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Nov 16 10:19:15 2013 -0800

    Merge tag 'random_for_linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tytso/random
    
    Pull /dev/random changes from Ted Ts'o:
     "The /dev/random changes for 3.13 including a number of improvements in
      the following areas: performance, avoiding waste of entropy, better
      tracking of entropy estimates, support for non-x86 platforms that have
      a register which can't be used for fine-grained timekeeping, but which
      might be good enough for the random driver.
    
      Also add some printk's so that we can see how quickly /dev/urandom can
      get initialized, and when programs try to use /dev/urandom before it
      is fully initialized (since this could be a security issue).  This
      shouldn't be an issue on x86 desktop/laptops --- a test on my Lenovo
      T430s laptop shows that /dev/urandom is getting fully initialized
      approximately two seconds before the root file system is mounted
      read/write --- this may be an issue with ARM and MIPS embedded/mobile
      systems, though.  These printk's will be a useful canary before
      potentially adding a future change to start blocking processes which
      try to read from /dev/urandom before it is initialized, which is
      something FreeBSD does already for security reasons, and which
      security folks have been agitating for Linux to also adopt"
    
    * tag 'random_for_linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tytso/random:
      random: add debugging code to detect early use of get_random_bytes()
      random: initialize the last_time field in struct timer_rand_state
      random: don't zap entropy count in rand_initialize()
      random: printk notifications for urandom pool initialization
      random: make add_timer_randomness() fill the nonblocking pool first
      random: convert DEBUG_ENT to tracepoints
      random: push extra entropy to the output pools
      random: drop trickle mode
      random: adjust the generator polynomials in the mixing function slightly
      random: speed up the fast_mix function by a factor of four
      random: cap the rate which the /dev/urandom pool gets reseeded
      random: optimize the entropy_store structure
      random: optimize spinlock use in add_device_randomness()
      random: fix the tracepoint for get_random_bytes(_arch)
      random: account for entropy loss due to overwrites
      random: allow fractional bits to be tracked
      random: statically compute poolbitshift, poolbytes, poolbits
      random: mix in architectural randomness earlier in extract_buf()

commit 9073e1a804c3096eda84ee7cbf11d1f174236c75
Merge: 4937e2a6f939 2bb9936beac2
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Nov 15 16:47:22 2013 -0800

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/trivial
    
    Pull trivial tree updates from Jiri Kosina:
     "Usual earth-shaking, news-breaking, rocket science pile from
      trivial.git"
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/trivial: (23 commits)
      doc: usb: Fix typo in Documentation/usb/gadget_configs.txt
      doc: add missing files to timers/00-INDEX
      timekeeping: Fix some trivial typos in comments
      mm: Fix some trivial typos in comments
      irq: Fix some trivial typos in comments
      NUMA: fix typos in Kconfig help text
      mm: update 00-INDEX
      doc: Documentation/DMA-attributes.txt fix typo
      DRM: comment: `halve' -> `half'
      Docs: Kconfig: `devlopers' -> `developers'
      doc: typo on word accounting in kprobes.c in mutliple architectures
      treewide: fix "usefull" typo
      treewide: fix "distingush" typo
      mm/Kconfig: Grammar s/an/a/
      kexec: Typo s/the/then/
      Documentation/kvm: Update cpuid documentation for steal time and pv eoi
      treewide: Fix common typo in "identify"
      __page_to_pfn: Fix typo in comment
      Correct some typos for word frequency
      clk: fixed-factor: Fix a trivial typo
      ...

commit 87093826aa0172d9135ca1f301c4298a258ceee6
Merge: 39cf275a1a18 ee5872befc93
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Nov 12 10:36:00 2013 +0900

    Merge branch 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer changes from Ingo Molnar:
     "Main changes in this cycle were:
    
       - Updated full dynticks support.
    
       - Event stream support for architected (ARM) timers.
    
       - ARM clocksource driver updates.
    
       - Move arm64 to using the generic sched_clock framework & resulting
         cleanup in the generic sched_clock code.
    
       - Misc fixes and cleanups"
    
    * 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (50 commits)
      x86/time: Honor ACPI FADT flag indicating absence of a CMOS RTC
      clocksource: sun4i: remove IRQF_DISABLED
      clocksource: sun4i: Report the minimum tick that we can program
      clocksource: sun4i: Select CLKSRC_MMIO
      clocksource: Provide timekeeping for efm32 SoCs
      clocksource: em_sti: convert to clk_prepare/unprepare
      time: Fix signedness bug in sysfs_get_uname() and its callers
      timekeeping: Fix some trivial typos in comments
      alarmtimer: return EINVAL instead of ENOTSUPP if rtcdev doesn't exist
      clocksource: arch_timer: Do not register arch_sys_counter twice
      timer stats: Add a 'Collection: active/inactive' line to timer usage statistics
      sched_clock: Remove sched_clock_func() hook
      arch_timer: Move to generic sched_clock framework
      clocksource: tcb_clksrc: Remove IRQF_DISABLED
      clocksource: tcb_clksrc: Improve driver robustness
      clocksource: tcb_clksrc: Replace clk_enable/disable with clk_prepare_enable/disable_unprepare
      clocksource: arm_arch_timer: Use clocksource for suspend timekeeping
      clocksource: dw_apb_timer_of: Mark a few more functions as __init
      clocksource: Put nodes passed to CLOCKSOURCE_OF_DECLARE callbacks centrally
      arm: zynq: Enable arm_global_timer
      ...

commit 1ca7d67cf5d5a2aef26a8d9afd789006fa098347
Author: John Stultz <john.stultz@linaro.org>
Date:   Mon Oct 7 15:51:59 2013 -0700

    seqcount: Add lockdep functionality to seqcount/seqlock structures
    
    Currently seqlocks and seqcounts don't support lockdep.
    
    After running across a seqcount related deadlock in the timekeeping
    code, I used a less-refined and more focused variant of this patch
    to narrow down the cause of the issue.
    
    This is a first-pass attempt to properly enable lockdep functionality
    on seqlocks and seqcounts.
    
    Since seqcounts are used in the vdso gettimeofday code, I've provided
    non-lockdep accessors for those needs.
    
    I've also handled one case where there were nested seqlock writers
    and there may be more edge cases.
    
    Comments and feedback would be appreciated!
    
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Peter Zijlstra <peterz@infradead.org>
    Cc: Eric Dumazet <eric.dumazet@gmail.com>
    Cc: Li Zefan <lizefan@huawei.com>
    Cc: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: netdev@vger.kernel.org
    Link: http://lkml.kernel.org/r/1381186321-4906-3-git-send-email-john.stultz@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 9c9b781804e0a278e258f81dfc31c50f80867730
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Thu Oct 3 21:56:29 2013 +0200

    clocksource: Provide timekeeping for efm32 SoCs
    
    An efm32 features 4 16-bit timers with a 10-bit prescaler. This driver
    provides clocksource and clock event device using one timer instance
    each.
    
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit b7bc50e45111e59419474154736f419a555158d9
Author: Xie XiuQi <xiexiuqi@huawei.com>
Date:   Fri Oct 18 09:13:30 2013 +0800

    timekeeping: Fix some trivial typos in comments
    
    Fix some typos in timekeeping comments.
    
    Signed-off-by: Xie XiuQi <xiexiuqi@huawei.com>
    [jstultz: Commit message tweaks]
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 1e4cfed127986c32c910d5b3549c6eccf847fdf2
Author: Xie XiuQi <xiexiuqi@huawei.com>
Date:   Fri Oct 18 09:13:30 2013 +0800

    timekeeping: Fix some trivial typos in comments
    
    Signed-off-by: Xie XiuQi <xiexiuqi@huawei.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

commit 8a749de5e32d2b72def93f7bd7a2745580d75872
Merge: a44eb870f815 b4042ceaabbd
Author: Ingo Molnar <mingo@kernel.org>
Date:   Thu Oct 10 06:25:23 2013 +0200

    Merge branch 'fortglx/3.13/time' of git://git.linaro.org/people/jstultz/linux into timers/core
    
    Pull more timekeeping items for v3.13 from John Stultz:
    
      * Small cleanup in the clocksource code.
    
      * Fix for rtc-pl031 to let it work with alarmtimers.
    
      * Move arm64 to using the generic sched_clock framework & resulting
        cleanup in the generic sched_clock code.
    
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 4fbcdc813fb9c0324fcff4c75414e717569d965e
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Fri Sep 27 13:13:12 2013 -0700

    clocksource: arm_arch_timer: Use clocksource for suspend timekeeping
    
    The ARM architected timers keep counting during suspend so we can
    mark this clocksource with the CLOCK_SOURCE_SUSPEND_NONSTOP flag.
    This flag will indicate that this clocksource can be used for
    calculating suspend time and injecting sleep time into the
    timekeeping core. This should be more accurate than using an
    external RTC or architecture specific persistent clock.
    
    Cc: Mark Rutland <mark.rutland@arm.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit 7ee4ddd24bf7ceee9400de450f69e327f7970f7c
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Sep 11 16:50:56 2013 -0700

    timekeeping: Fix HRTICK related deadlock from ntp lock changes
    
    commit 7bd36014460f793c19e7d6c94dab67b0afcfcb7f upstream.
    
    Gerlando Falauto reported that when HRTICK is enabled, it is
    possible to trigger system deadlocks. These were hard to
    reproduce, as HRTICK has been broken in the past, but seemed
    to be connected to the timekeeping_seq lock.
    
    Since seqlock/seqcount's aren't supported w/ lockdep, I added
    some extra spinlock based locking and triggered the following
    lockdep output:
    
    [   15.849182] ntpd/4062 is trying to acquire lock:
    [   15.849765]  (&(&pool->lock)->rlock){..-...}, at: [<ffffffff810aa9b5>] __queue_work+0x145/0x480
    [   15.850051]
    [   15.850051] but task is already holding lock:
    [   15.850051]  (timekeeper_lock){-.-.-.}, at: [<ffffffff810df6df>] do_adjtimex+0x7f/0x100
    
    <snip>
    
    [   15.850051] Chain exists of: &(&pool->lock)->rlock --> &p->pi_lock --> timekeeper_lock
    [   15.850051]  Possible unsafe locking scenario:
    [   15.850051]
    [   15.850051]        CPU0                    CPU1
    [   15.850051]        ----                    ----
    [   15.850051]   lock(timekeeper_lock);
    [   15.850051]                                lock(&p->pi_lock);
    [   15.850051] lock(timekeeper_lock);
    [   15.850051] lock(&(&pool->lock)->rlock);
    [   15.850051]
    [   15.850051]  *** DEADLOCK ***
    
    The deadlock was introduced by 06c017fdd4dc48451a ("timekeeping:
    Hold timekeepering locks in do_adjtimex and hardpps") in 3.10
    
    This patch avoids this deadlock, by moving the call to
    schedule_delayed_work() outside of the timekeeper lock
    critical section.
    
    Reported-by: Gerlando Falauto <gerlando.falauto@keymile.com>
    Tested-by: Lin Ming <minggr@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
    Link: http://lkml.kernel.org/r/1378943457-27314-1-git-send-email-john.stultz@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 63946e8616205dafe39b4d88f9fc3dc7c4fd79aa
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Sep 11 16:50:56 2013 -0700

    timekeeping: Fix HRTICK related deadlock from ntp lock changes
    
    commit 7bd36014460f793c19e7d6c94dab67b0afcfcb7f upstream.
    
    Gerlando Falauto reported that when HRTICK is enabled, it is
    possible to trigger system deadlocks. These were hard to
    reproduce, as HRTICK has been broken in the past, but seemed
    to be connected to the timekeeping_seq lock.
    
    Since seqlock/seqcount's aren't supported w/ lockdep, I added
    some extra spinlock based locking and triggered the following
    lockdep output:
    
    [   15.849182] ntpd/4062 is trying to acquire lock:
    [   15.849765]  (&(&pool->lock)->rlock){..-...}, at: [<ffffffff810aa9b5>] __queue_work+0x145/0x480
    [   15.850051]
    [   15.850051] but task is already holding lock:
    [   15.850051]  (timekeeper_lock){-.-.-.}, at: [<ffffffff810df6df>] do_adjtimex+0x7f/0x100
    
    <snip>
    
    [   15.850051] Chain exists of: &(&pool->lock)->rlock --> &p->pi_lock --> timekeeper_lock
    [   15.850051]  Possible unsafe locking scenario:
    [   15.850051]
    [   15.850051]        CPU0                    CPU1
    [   15.850051]        ----                    ----
    [   15.850051]   lock(timekeeper_lock);
    [   15.850051]                                lock(&p->pi_lock);
    [   15.850051] lock(timekeeper_lock);
    [   15.850051] lock(&(&pool->lock)->rlock);
    [   15.850051]
    [   15.850051]  *** DEADLOCK ***
    
    The deadlock was introduced by 06c017fdd4dc48451a ("timekeeping:
    Hold timekeepering locks in do_adjtimex and hardpps") in 3.10
    
    This patch avoids this deadlock, by moving the call to
    schedule_delayed_work() outside of the timekeeper lock
    critical section.
    
    Reported-by: Gerlando Falauto <gerlando.falauto@keymile.com>
    Tested-by: Lin Ming <minggr@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
    Link: http://lkml.kernel.org/r/1378943457-27314-1-git-send-email-john.stultz@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit f118b54803039546620476f4766ec591919131b0
Author: Bjørn Mork <bjorn@mork.no>
Date:   Wed Aug 14 05:24:39 2013 -0300

    media: siano: fix divide error on 0 counters
    
    commit ec532503209053bbee0c7dac410031e50835e01a upstream.
    
    GIT_AUTHOR_DATE=1376465691
    I took a quick look at the code and wonder if the problem is caused by
    an initial zero statistics message?  This is all just a wild guess, but
    if it is correct, then the attached untested patch might fix it...
    Bjørn
    >From d78a0599d5b5d4da384eae08bf7da316389dfbe5 Mon Sep 17 00:00:00 2001
    ts_packets and ets_packets counters can be 0.  Don't fall over
    if they are. Fixes:
    [  846.851711] divide error: 0000 [#1] SMP
    [  846.851806] Modules linked in: smsdvb dvb_core ir_lirc_codec lirc_dev ir_sanyo_decoder ir_mce_kbd_decoder ir_sony_decoder ir_jvc_decoder ir_rc6_decoder ir_rc5_decoder ir_nec_decoder rc_hauppauge smsusb smsmdtv rc_core pci_stub vboxpci(O) vboxnetadp(O) vboxnetflt(O) vboxdrv(O) parport_pc ppdev lp parport cpufreq_userspace cpufreq_powersave cpufreq_stats cpufreq_conservative rfcomm bnep binfmt_misc uinput nfsd auth_rpcgss oid_registry nfs_acl nfs lockd dns_resolver fscache sunrpc ext4 jbd2 fuse tp_smapi(O) thinkpad_ec(O) loop firewire_sbp2 dm_crypt snd_hda_codec_conexant snd_hda_intel snd_hda_codec snd_hwdep snd_pcm_oss snd_mixer_oss snd_pcm thinkpad_acpi nvram snd_page_alloc hid_generic snd_seq_midi snd_seq_midi_event arc4 usbhid snd_rawmidi uvcvideo hid iwldvm coretemp kvm_intel mac8021
     1 cdc_wdm
    [  846.853477]  cdc_acm snd_seq videobuf2_vmalloc videobuf2_memops videobuf2_core videodev media kvm radeon r852 ttm joydev cdc_ether usbnet pcmcia mii sm_common nand btusb drm_kms_helper tpm_tis acpi_cpufreq bluetooth iwlwifi nand_ecc drm nand_ids i2c_i801 mtd snd_seq_device iTCO_wdt iTCO_vendor_support r592 memstick lpc_ich mperf tpm yenta_socket pcmcia_rsrc pcmcia_core cfg80211 snd_timer snd pcspkr i2c_algo_bit crc16 i2c_core tpm_bios processor mfd_core wmi psmouse mei_me rfkill mei serio_raw soundcore evdev battery button video ac microcode ext3 mbcache jbd md_mod dm_mirror dm_region_hash dm_log dm_mod sg sr_mod sd_mod cdrom crc_t10dif firewire_ohci sdhci_pci sdhci mmc_core firewire_core crc_itu_t thermal thermal_sys ahci libahci ehci_pci uhci_hcd ehci_hcd libata scsi_mod usbcore e1000
     e usb_common
    [  846.855310]  ptp pps_core
    [  846.855356] CPU: 0 PID: 0 Comm: swapper/0 Tainted: G           O 3.10-2-amd64 #1 Debian 3.10.5-1
    [  846.855490] Hardware name: LENOVO 4061WFA/4061WFA, BIOS 6FET92WW (3.22 ) 12/14/2011
    [  846.855609] task: ffffffff81613400 ti: ffffffff81600000 task.ti: ffffffff81600000
    [  846.855636] RIP: 0010:[<ffffffffa092be0c>]  [<ffffffffa092be0c>] smsdvb_onresponse+0x264/0xa86 [smsdvb]
    [  846.863906] RSP: 0018:ffff88013bc03cf0  EFLAGS: 00010046
    [  846.863906] RAX: 0000000000000000 RBX: ffff880133bf6000 RCX: 0000000000000000
    [  846.863906] RDX: 0000000000000000 RSI: ffff88005d3b58c0 RDI: ffff880133bf6000
    [  846.863906] RBP: ffff88005d1da000 R08: 0000000000000058 R09: 0000000000000015
    [  846.863906] R10: 0000000000001a0d R11: 000000000000021a R12: ffff88005d3b58c0
    [  846.863906] R13: ffff88005d1da008 R14: 00000000ffffff8d R15: ffff880036cf5060
    [  846.863906] FS:  0000000000000000(0000) GS:ffff88013bc00000(0000) knlGS:0000000000000000
    [  846.863906] CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b
    [  846.863906] CR2: 00007f3a4b69ae50 CR3: 0000000036dac000 CR4: 00000000000407f0
    [  846.863906] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
    [  846.863906] DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400
    [  846.863906] Stack:
    [  846.863906]  ffff88007a102000 ffff88005d1da000 ffff88005d3b58c0 0000000000085824
    [  846.863906]  ffffffffa08c5aa3 ffff88005d1da000 ffff8800a6907390 ffff8800a69073b0
    [  846.863906]  ffff8800a6907000 ffffffffa08b642c 000000000000021a ffff8800a69073b0
    [  846.863906] Call Trace:
    [  846.863906]  <IRQ>
    [  846.863906]
    [  846.863906]  [<ffffffffa08c5aa3>] ? smscore_onresponse+0x1d5/0x353 [smsmdtv]
    [  846.863906]  [<ffffffffa08b642c>] ? smsusb_onresponse+0x146/0x192 [smsusb]
    [  846.863906]  [<ffffffffa004cb1a>] ? usb_hcd_giveback_urb+0x6c/0xac [usbcore]
    [  846.863906]  [<ffffffffa0217be1>] ? ehci_urb_done+0x62/0x72 [ehci_hcd]
    [  846.863906]  [<ffffffffa0217c82>] ? qh_completions+0x91/0x364 [ehci_hcd]
    [  846.863906]  [<ffffffffa0219bba>] ? ehci_work+0x8a/0x68e [ehci_hcd]
    [  846.863906]  [<ffffffff8107336c>] ? timekeeping_get_ns.constprop.10+0xd/0x31
    [  846.863906]  [<ffffffff81064d41>] ? update_cfs_rq_blocked_load+0xde/0xec
    [  846.863906]  [<ffffffff81058ec2>] ? run_posix_cpu_timers+0x25/0x575
    [  846.863906]  [<ffffffffa021aa46>] ? ehci_irq+0x211/0x23d [ehci_hcd]
    [  846.863906]  [<ffffffffa004c0c1>] ? usb_hcd_irq+0x31/0x48 [usbcore]
    [  846.863906]  [<ffffffff810996fd>] ? handle_irq_event_percpu+0x49/0x1a4
    [  846.863906]  [<ffffffff8109988a>] ? handle_irq_event+0x32/0x4b
    [  846.863906]  [<ffffffff8109bd76>] ? handle_fasteoi_irq+0x80/0xb6
    [  846.863906]  [<ffffffff8100e93e>] ? handle_irq+0x18/0x20
    [  846.863906]  [<ffffffff8100e657>] ? do_IRQ+0x40/0x95
    [  846.863906]  [<ffffffff813883ed>] ? common_interrupt+0x6d/0x6d
    [  846.863906]  <EOI>
    [  846.863906]
    [  846.863906]  [<ffffffff812a011c>] ? arch_local_irq_enable+0x4/0x8
    [  846.863906]  [<ffffffff812a04f3>] ? cpuidle_enter_state+0x52/0xc1
    [  846.863906]  [<ffffffff812a0636>] ? cpuidle_idle_call+0xd4/0x143
    [  846.863906]  [<ffffffff8101398c>] ? arch_cpu_idle+0x5/0x17
    [  846.863906]  [<ffffffff81072571>] ? cpu_startup_entry+0x10d/0x187
    [  846.863906]  [<ffffffff816b3d3d>] ? start_kernel+0x3e8/0x3f3
    [  846.863906]  [<ffffffff816b3777>] ? repair_env_string+0x54/0x54
    [  846.863906]  [<ffffffff816b3598>] ? x86_64_start_kernel+0xf2/0xfd
    [  846.863906] Code: 25 09 00 00 c6 83 da 08 00 00 03 8b 45 54 48 01 83 b6 08 00 00 8b 45 50 48 01 83 db 08 00 00 8b 4d 18 69 c1 ff ff 00 00 03 4d 14 <48> f7 f1 89 83 a8 09 00 00 e9 68 fe ff ff 48 8b 7f 10 e8 79 92
    [  846.863906] RIP  [<ffffffffa092be0c>] smsdvb_onresponse+0x264/0xa86 [smsdvb]
    [  846.863906]  RSP <ffff88013bc03cf0>
    Reference: http://bugs.debian.org/719623
    
    Reported-by: Johannes Rohr <jorohr@gmail.com>
    Signed-off-by: Bjørn Mork <bjorn@mork.no>
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit d2310f7119ba394d3256c221886c048189dcfb91
Author: Bjørn Mork <bjorn@mork.no>
Date:   Wed Aug 14 05:24:39 2013 -0300

    media: siano: fix divide error on 0 counters
    
    commit ec532503209053bbee0c7dac410031e50835e01a upstream.
    
    GIT_AUTHOR_DATE=1376465691
    I took a quick look at the code and wonder if the problem is caused by
    an initial zero statistics message?  This is all just a wild guess, but
    if it is correct, then the attached untested patch might fix it...
    Bjørn
    >From d78a0599d5b5d4da384eae08bf7da316389dfbe5 Mon Sep 17 00:00:00 2001
    ts_packets and ets_packets counters can be 0.  Don't fall over
    if they are. Fixes:
    [  846.851711] divide error: 0000 [#1] SMP
    [  846.851806] Modules linked in: smsdvb dvb_core ir_lirc_codec lirc_dev ir_sanyo_decoder ir_mce_kbd_decoder ir_sony_decoder ir_jvc_decoder ir_rc6_decoder ir_rc5_decoder ir_nec_decoder rc_hauppauge smsusb smsmdtv rc_core pci_stub vboxpci(O) vboxnetadp(O) vboxnetflt(O) vboxdrv(O) parport_pc ppdev lp parport cpufreq_userspace cpufreq_powersave cpufreq_stats cpufreq_conservative rfcomm bnep binfmt_misc uinput nfsd auth_rpcgss oid_registry nfs_acl nfs lockd dns_resolver fscache sunrpc ext4 jbd2 fuse tp_smapi(O) thinkpad_ec(O) loop firewire_sbp2 dm_crypt snd_hda_codec_conexant snd_hda_intel snd_hda_codec snd_hwdep snd_pcm_oss snd_mixer_oss snd_pcm thinkpad_acpi nvram snd_page_alloc hid_generic snd_seq_midi snd_seq_midi_event arc4 usbhid snd_rawmidi uvcvideo hid iwldvm coretemp kvm_intel mac8021
     1 cdc_wdm
    [  846.853477]  cdc_acm snd_seq videobuf2_vmalloc videobuf2_memops videobuf2_core videodev media kvm radeon r852 ttm joydev cdc_ether usbnet pcmcia mii sm_common nand btusb drm_kms_helper tpm_tis acpi_cpufreq bluetooth iwlwifi nand_ecc drm nand_ids i2c_i801 mtd snd_seq_device iTCO_wdt iTCO_vendor_support r592 memstick lpc_ich mperf tpm yenta_socket pcmcia_rsrc pcmcia_core cfg80211 snd_timer snd pcspkr i2c_algo_bit crc16 i2c_core tpm_bios processor mfd_core wmi psmouse mei_me rfkill mei serio_raw soundcore evdev battery button video ac microcode ext3 mbcache jbd md_mod dm_mirror dm_region_hash dm_log dm_mod sg sr_mod sd_mod cdrom crc_t10dif firewire_ohci sdhci_pci sdhci mmc_core firewire_core crc_itu_t thermal thermal_sys ahci libahci ehci_pci uhci_hcd ehci_hcd libata scsi_mod usbcore e1000
     e usb_common
    [  846.855310]  ptp pps_core
    [  846.855356] CPU: 0 PID: 0 Comm: swapper/0 Tainted: G           O 3.10-2-amd64 #1 Debian 3.10.5-1
    [  846.855490] Hardware name: LENOVO 4061WFA/4061WFA, BIOS 6FET92WW (3.22 ) 12/14/2011
    [  846.855609] task: ffffffff81613400 ti: ffffffff81600000 task.ti: ffffffff81600000
    [  846.855636] RIP: 0010:[<ffffffffa092be0c>]  [<ffffffffa092be0c>] smsdvb_onresponse+0x264/0xa86 [smsdvb]
    [  846.863906] RSP: 0018:ffff88013bc03cf0  EFLAGS: 00010046
    [  846.863906] RAX: 0000000000000000 RBX: ffff880133bf6000 RCX: 0000000000000000
    [  846.863906] RDX: 0000000000000000 RSI: ffff88005d3b58c0 RDI: ffff880133bf6000
    [  846.863906] RBP: ffff88005d1da000 R08: 0000000000000058 R09: 0000000000000015
    [  846.863906] R10: 0000000000001a0d R11: 000000000000021a R12: ffff88005d3b58c0
    [  846.863906] R13: ffff88005d1da008 R14: 00000000ffffff8d R15: ffff880036cf5060
    [  846.863906] FS:  0000000000000000(0000) GS:ffff88013bc00000(0000) knlGS:0000000000000000
    [  846.863906] CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b
    [  846.863906] CR2: 00007f3a4b69ae50 CR3: 0000000036dac000 CR4: 00000000000407f0
    [  846.863906] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
    [  846.863906] DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400
    [  846.863906] Stack:
    [  846.863906]  ffff88007a102000 ffff88005d1da000 ffff88005d3b58c0 0000000000085824
    [  846.863906]  ffffffffa08c5aa3 ffff88005d1da000 ffff8800a6907390 ffff8800a69073b0
    [  846.863906]  ffff8800a6907000 ffffffffa08b642c 000000000000021a ffff8800a69073b0
    [  846.863906] Call Trace:
    [  846.863906]  <IRQ>
    [  846.863906]
    [  846.863906]  [<ffffffffa08c5aa3>] ? smscore_onresponse+0x1d5/0x353 [smsmdtv]
    [  846.863906]  [<ffffffffa08b642c>] ? smsusb_onresponse+0x146/0x192 [smsusb]
    [  846.863906]  [<ffffffffa004cb1a>] ? usb_hcd_giveback_urb+0x6c/0xac [usbcore]
    [  846.863906]  [<ffffffffa0217be1>] ? ehci_urb_done+0x62/0x72 [ehci_hcd]
    [  846.863906]  [<ffffffffa0217c82>] ? qh_completions+0x91/0x364 [ehci_hcd]
    [  846.863906]  [<ffffffffa0219bba>] ? ehci_work+0x8a/0x68e [ehci_hcd]
    [  846.863906]  [<ffffffff8107336c>] ? timekeeping_get_ns.constprop.10+0xd/0x31
    [  846.863906]  [<ffffffff81064d41>] ? update_cfs_rq_blocked_load+0xde/0xec
    [  846.863906]  [<ffffffff81058ec2>] ? run_posix_cpu_timers+0x25/0x575
    [  846.863906]  [<ffffffffa021aa46>] ? ehci_irq+0x211/0x23d [ehci_hcd]
    [  846.863906]  [<ffffffffa004c0c1>] ? usb_hcd_irq+0x31/0x48 [usbcore]
    [  846.863906]  [<ffffffff810996fd>] ? handle_irq_event_percpu+0x49/0x1a4
    [  846.863906]  [<ffffffff8109988a>] ? handle_irq_event+0x32/0x4b
    [  846.863906]  [<ffffffff8109bd76>] ? handle_fasteoi_irq+0x80/0xb6
    [  846.863906]  [<ffffffff8100e93e>] ? handle_irq+0x18/0x20
    [  846.863906]  [<ffffffff8100e657>] ? do_IRQ+0x40/0x95
    [  846.863906]  [<ffffffff813883ed>] ? common_interrupt+0x6d/0x6d
    [  846.863906]  <EOI>
    [  846.863906]
    [  846.863906]  [<ffffffff812a011c>] ? arch_local_irq_enable+0x4/0x8
    [  846.863906]  [<ffffffff812a04f3>] ? cpuidle_enter_state+0x52/0xc1
    [  846.863906]  [<ffffffff812a0636>] ? cpuidle_idle_call+0xd4/0x143
    [  846.863906]  [<ffffffff8101398c>] ? arch_cpu_idle+0x5/0x17
    [  846.863906]  [<ffffffff81072571>] ? cpu_startup_entry+0x10d/0x187
    [  846.863906]  [<ffffffff816b3d3d>] ? start_kernel+0x3e8/0x3f3
    [  846.863906]  [<ffffffff816b3777>] ? repair_env_string+0x54/0x54
    [  846.863906]  [<ffffffff816b3598>] ? x86_64_start_kernel+0xf2/0xfd
    [  846.863906] Code: 25 09 00 00 c6 83 da 08 00 00 03 8b 45 54 48 01 83 b6 08 00 00 8b 45 50 48 01 83 db 08 00 00 8b 4d 18 69 c1 ff ff 00 00 03 4d 14 <48> f7 f1 89 83 a8 09 00 00 e9 68 fe ff ff 48 8b 7f 10 e8 79 92
    [  846.863906] RIP  [<ffffffffa092be0c>] smsdvb_onresponse+0x264/0xa86 [smsdvb]
    [  846.863906]  RSP <ffff88013bc03cf0>
    Reference: http://bugs.debian.org/719623
    
    Reported-by: Johannes Rohr <jorohr@gmail.com>
    Signed-off-by: Bjørn Mork <bjorn@mork.no>
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 9d2cd7048b1ec21309e2d1a32bf50732eb5d5de8
Merge: 7e28b2712e5e 7bd36014460f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Sep 18 11:24:49 2013 -0500

    Merge branch 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer fix from Ingo Molnar:
     "An NTP related lockup fix"
    
    * 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      timekeeping: Fix HRTICK related deadlock from ntp lock changes

commit 389e067032fbb96e439abafae848dd447e4cafb4
Merge: 19c3205ceaff a97ad0c4b447
Author: John Stultz <john.stultz@linaro.org>
Date:   Mon Sep 16 18:54:07 2013 -0700

    Merge branch 'fortglx/3.12/time' into fortglx/3.13/time
    
    Merge in the timekeeping changes that missed 3.12
    
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 7bd36014460f793c19e7d6c94dab67b0afcfcb7f
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Sep 11 16:50:56 2013 -0700

    timekeeping: Fix HRTICK related deadlock from ntp lock changes
    
    Gerlando Falauto reported that when HRTICK is enabled, it is
    possible to trigger system deadlocks. These were hard to
    reproduce, as HRTICK has been broken in the past, but seemed
    to be connected to the timekeeping_seq lock.
    
    Since seqlock/seqcount's aren't supported w/ lockdep, I added
    some extra spinlock based locking and triggered the following
    lockdep output:
    
    [   15.849182] ntpd/4062 is trying to acquire lock:
    [   15.849765]  (&(&pool->lock)->rlock){..-...}, at: [<ffffffff810aa9b5>] __queue_work+0x145/0x480
    [   15.850051]
    [   15.850051] but task is already holding lock:
    [   15.850051]  (timekeeper_lock){-.-.-.}, at: [<ffffffff810df6df>] do_adjtimex+0x7f/0x100
    
    <snip>
    
    [   15.850051] Chain exists of: &(&pool->lock)->rlock --> &p->pi_lock --> timekeeper_lock
    [   15.850051]  Possible unsafe locking scenario:
    [   15.850051]
    [   15.850051]        CPU0                    CPU1
    [   15.850051]        ----                    ----
    [   15.850051]   lock(timekeeper_lock);
    [   15.850051]                                lock(&p->pi_lock);
    [   15.850051] lock(timekeeper_lock);
    [   15.850051] lock(&(&pool->lock)->rlock);
    [   15.850051]
    [   15.850051]  *** DEADLOCK ***
    
    The deadlock was introduced by 06c017fdd4dc48451a ("timekeeping:
    Hold timekeepering locks in do_adjtimex and hardpps") in 3.10
    
    This patch avoids this deadlock, by moving the call to
    schedule_delayed_work() outside of the timekeeper lock
    critical section.
    
    Reported-by: Gerlando Falauto <gerlando.falauto@keymile.com>
    Tested-by: Lin Ming <minggr@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
    Cc: stable <stable@vger.kernel.org> #3.11, 3.10
    Link: http://lkml.kernel.org/r/1378943457-27314-1-git-send-email-john.stultz@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit b854e4de0bf88d094476af82c0d5a80f6f2af916
Merge: 458c3f60ef12 7d992feb7694
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Sep 4 08:17:12 2013 -0700

    Merge branch 'core-rcu-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull RCU updates from Ingo Molnar:
     "Main RCU changes this cycle were:
    
       - Full-system idle detection.  This is for use by Frederic
         Weisbecker's adaptive-ticks mechanism.  Its purpose is to allow the
         timekeeping CPU to shut off its tick when all other CPUs are idle.
    
       - Miscellaneous fixes.
    
       - Improved rcutorture test coverage.
    
       - Updated RCU documentation"
    
    * 'core-rcu-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (30 commits)
      nohz_full: Force RCU's grace-period kthreads onto timekeeping CPU
      nohz_full: Add full-system-idle state machine
      jiffies: Avoid undefined behavior from signed overflow
      rcu: Simplify _rcu_barrier() processing
      rcu: Make rcutorture emit online failures if verbose
      rcu: Remove unused variable from rcu_torture_writer()
      rcu: Sort rcutorture module parameters
      rcu: Increase rcutorture test coverage
      rcu: Add duplicate-callback tests to rcutorture
      doc: Fix memory-barrier control-dependency example
      rcu: Update RTFP documentation
      nohz_full: Add full-system-idle arguments to API
      nohz_full: Add full-system idle states and variables
      nohz_full: Add per-CPU idle-state tracking
      nohz_full: Add rcu_dyntick data for scalable detection of all-idle state
      nohz_full: Add Kconfig parameter for scalable detection of all-idle state
      nohz_full: Add testing information to documentation
      rcu: Eliminate unused APIs intended for adaptive ticks
      rcu: Select IRQ_WORK from TREE_PREEMPT_RCU
      rculist: list_first_or_null_rcu() should use list_entry_rcu()
      ...

commit 7d992feb7694a21ee81f22894b455dadd5d1c110
Merge: 6e4664525b1d 25f27ce4a6a4
Author: Ingo Molnar <mingo@kernel.org>
Date:   Tue Sep 3 07:41:11 2013 +0200

    Merge branch 'rcu/next' of git://git.kernel.org/pub/scm/linux/kernel/git/paulmck/linux-rcu into core/rcu
    
    Pull RCU updates from Paul E. McKenney:
    
    "
     * Update RCU documentation.  These were posted to LKML at
       https://lkml.org/lkml/2013/8/19/611.
    
     * Miscellaneous fixes.  These were posted to LKML at
       https://lkml.org/lkml/2013/8/19/619.
    
     * Full-system idle detection.  This is for use by Frederic
       Weisbecker's adaptive-ticks mechanism.  Its purpose is
       to allow the timekeeping CPU to shut off its tick when
       all other CPUs are idle.  These were posted to LKML at
       https://lkml.org/lkml/2013/8/19/648.
    
     * Improve rcutorture test coverage.  These were posted to LKML at
       https://lkml.org/lkml/2013/8/19/675.
    "
    
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit eb75767be0e514f97bf1b5cec763696cfc7f7e2a
Author: Paul E. McKenney <paulmck@kernel.org>
Date:   Fri Jun 21 17:10:40 2013 -0700

    nohz_full: Force RCU's grace-period kthreads onto timekeeping CPU
    
    Because RCU's quiescent-state-forcing mechanism is used to drive the
    full-system-idle state machine, and because this mechanism is executed
    by RCU's grace-period kthreads, this commit forces these kthreads to
    run on the timekeeping CPU (tick_do_timer_cpu).  To do otherwise would
    mean that the RCU grace-period kthreads would force the system into
    non-idle state every time they drove the state machine, which would
    be just a bit on the futile side.
    
    Signed-off-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Lai Jiangshan <laijs@cn.fujitsu.com>
    Reviewed-by: Josh Triplett <josh@joshtriplett.org>

commit 0edd1b1784cbdad55aca2c1293be018f53c0ab1d
Author: Paul E. McKenney <paulmck@kernel.org>
Date:   Fri Jun 21 16:37:22 2013 -0700

    nohz_full: Add full-system-idle state machine
    
    This commit adds the state machine that takes the per-CPU idle data
    as input and produces a full-system-idle indication as output.  This
    state machine is driven out of RCU's quiescent-state-forcing
    mechanism, which invokes rcu_sysidle_check_cpu() to collect per-CPU
    idle state and then rcu_sysidle_report() to drive the state machine.
    
    The full-system-idle state is sampled using rcu_sys_is_idle(), which
    also drives the state machine if RCU is idle (and does so by forcing
    RCU to become non-idle).  This function returns true if all but the
    timekeeping CPU (tick_do_timer_cpu) are idle and have been idle long
    enough to avoid memory contention on the full_sysidle_state state
    variable.  The rcu_sysidle_force_exit() may be called externally
    to reset the state machine back into non-idle state.
    
    For large systems the state machine is driven out of RCU's
    force-quiescent-state logic, which provides good scalability at the price
    of millisecond-scale latencies on the transition to full-system-idle
    state.  This is not so good for battery-powered systems, which are usually
    small enough that they don't need to care about scalability, but which
    do care deeply about energy efficiency.  Small systems therefore drive
    the state machine directly out of the idle-entry code.  The number of
    CPUs in a "small" system is defined by a new NO_HZ_FULL_SYSIDLE_SMALL
    Kconfig parameter, which defaults to 8.  Note that this is a build-time
    definition.
    
    Signed-off-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Lai Jiangshan <laijs@cn.fujitsu.com>
    [ paulmck: Use true and false for boolean constants per Lai Jiangshan. ]
    Reviewed-by: Josh Triplett <josh@joshtriplett.org>
    [ paulmck: Simplify logic and provide better comments for memory barriers,
      based on review comments and questions by Lai Jiangshan. ]

commit ec532503209053bbee0c7dac410031e50835e01a
Author: Bjørn Mork <bjorn@mork.no>
Date:   Wed Aug 14 05:24:39 2013 -0300

    [media] siano: fix divide error on 0 counters
    
    GIT_AUTHOR_DATE=1376465691
    I took a quick look at the code and wonder if the problem is caused by
    an initial zero statistics message?  This is all just a wild guess, but
    if it is correct, then the attached untested patch might fix it...
    Bjørn
    >From d78a0599d5b5d4da384eae08bf7da316389dfbe5 Mon Sep 17 00:00:00 2001
    ts_packets and ets_packets counters can be 0.  Don't fall over
    if they are. Fixes:
    [  846.851711] divide error: 0000 [#1] SMP
    [  846.851806] Modules linked in: smsdvb dvb_core ir_lirc_codec lirc_dev ir_sanyo_decoder ir_mce_kbd_decoder ir_sony_decoder ir_jvc_decoder ir_rc6_decoder ir_rc5_decoder ir_nec_decoder rc_hauppauge smsusb smsmdtv rc_core pci_stub vboxpci(O) vboxnetadp(O) vboxnetflt(O) vboxdrv(O) parport_pc ppdev lp parport cpufreq_userspace cpufreq_powersave cpufreq_stats cpufreq_conservative rfcomm bnep binfmt_misc uinput nfsd auth_rpcgss oid_registry nfs_acl nfs lockd dns_resolver fscache sunrpc ext4 jbd2 fuse tp_smapi(O) thinkpad_ec(O) loop firewire_sbp2 dm_crypt snd_hda_codec_conexant snd_hda_intel snd_hda_codec snd_hwdep snd_pcm_oss snd_mixer_oss snd_pcm thinkpad_acpi nvram snd_page_alloc hid_generic snd_seq_midi snd_seq_midi_event arc4 usbhid snd_rawmidi uvcvideo hid iwldvm coretemp kvm_intel mac8021
     1 cdc_wdm
    [  846.853477]  cdc_acm snd_seq videobuf2_vmalloc videobuf2_memops videobuf2_core videodev media kvm radeon r852 ttm joydev cdc_ether usbnet pcmcia mii sm_common nand btusb drm_kms_helper tpm_tis acpi_cpufreq bluetooth iwlwifi nand_ecc drm nand_ids i2c_i801 mtd snd_seq_device iTCO_wdt iTCO_vendor_support r592 memstick lpc_ich mperf tpm yenta_socket pcmcia_rsrc pcmcia_core cfg80211 snd_timer snd pcspkr i2c_algo_bit crc16 i2c_core tpm_bios processor mfd_core wmi psmouse mei_me rfkill mei serio_raw soundcore evdev battery button video ac microcode ext3 mbcache jbd md_mod dm_mirror dm_region_hash dm_log dm_mod sg sr_mod sd_mod cdrom crc_t10dif firewire_ohci sdhci_pci sdhci mmc_core firewire_core crc_itu_t thermal thermal_sys ahci libahci ehci_pci uhci_hcd ehci_hcd libata scsi_mod usbcore e1000
     e usb_common
    [  846.855310]  ptp pps_core
    [  846.855356] CPU: 0 PID: 0 Comm: swapper/0 Tainted: G           O 3.10-2-amd64 #1 Debian 3.10.5-1
    [  846.855490] Hardware name: LENOVO 4061WFA/4061WFA, BIOS 6FET92WW (3.22 ) 12/14/2011
    [  846.855609] task: ffffffff81613400 ti: ffffffff81600000 task.ti: ffffffff81600000
    [  846.855636] RIP: 0010:[<ffffffffa092be0c>]  [<ffffffffa092be0c>] smsdvb_onresponse+0x264/0xa86 [smsdvb]
    [  846.863906] RSP: 0018:ffff88013bc03cf0  EFLAGS: 00010046
    [  846.863906] RAX: 0000000000000000 RBX: ffff880133bf6000 RCX: 0000000000000000
    [  846.863906] RDX: 0000000000000000 RSI: ffff88005d3b58c0 RDI: ffff880133bf6000
    [  846.863906] RBP: ffff88005d1da000 R08: 0000000000000058 R09: 0000000000000015
    [  846.863906] R10: 0000000000001a0d R11: 000000000000021a R12: ffff88005d3b58c0
    [  846.863906] R13: ffff88005d1da008 R14: 00000000ffffff8d R15: ffff880036cf5060
    [  846.863906] FS:  0000000000000000(0000) GS:ffff88013bc00000(0000) knlGS:0000000000000000
    [  846.863906] CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b
    [  846.863906] CR2: 00007f3a4b69ae50 CR3: 0000000036dac000 CR4: 00000000000407f0
    [  846.863906] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
    [  846.863906] DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400
    [  846.863906] Stack:
    [  846.863906]  ffff88007a102000 ffff88005d1da000 ffff88005d3b58c0 0000000000085824
    [  846.863906]  ffffffffa08c5aa3 ffff88005d1da000 ffff8800a6907390 ffff8800a69073b0
    [  846.863906]  ffff8800a6907000 ffffffffa08b642c 000000000000021a ffff8800a69073b0
    [  846.863906] Call Trace:
    [  846.863906]  <IRQ>
    [  846.863906]
    [  846.863906]  [<ffffffffa08c5aa3>] ? smscore_onresponse+0x1d5/0x353 [smsmdtv]
    [  846.863906]  [<ffffffffa08b642c>] ? smsusb_onresponse+0x146/0x192 [smsusb]
    [  846.863906]  [<ffffffffa004cb1a>] ? usb_hcd_giveback_urb+0x6c/0xac [usbcore]
    [  846.863906]  [<ffffffffa0217be1>] ? ehci_urb_done+0x62/0x72 [ehci_hcd]
    [  846.863906]  [<ffffffffa0217c82>] ? qh_completions+0x91/0x364 [ehci_hcd]
    [  846.863906]  [<ffffffffa0219bba>] ? ehci_work+0x8a/0x68e [ehci_hcd]
    [  846.863906]  [<ffffffff8107336c>] ? timekeeping_get_ns.constprop.10+0xd/0x31
    [  846.863906]  [<ffffffff81064d41>] ? update_cfs_rq_blocked_load+0xde/0xec
    [  846.863906]  [<ffffffff81058ec2>] ? run_posix_cpu_timers+0x25/0x575
    [  846.863906]  [<ffffffffa021aa46>] ? ehci_irq+0x211/0x23d [ehci_hcd]
    [  846.863906]  [<ffffffffa004c0c1>] ? usb_hcd_irq+0x31/0x48 [usbcore]
    [  846.863906]  [<ffffffff810996fd>] ? handle_irq_event_percpu+0x49/0x1a4
    [  846.863906]  [<ffffffff8109988a>] ? handle_irq_event+0x32/0x4b
    [  846.863906]  [<ffffffff8109bd76>] ? handle_fasteoi_irq+0x80/0xb6
    [  846.863906]  [<ffffffff8100e93e>] ? handle_irq+0x18/0x20
    [  846.863906]  [<ffffffff8100e657>] ? do_IRQ+0x40/0x95
    [  846.863906]  [<ffffffff813883ed>] ? common_interrupt+0x6d/0x6d
    [  846.863906]  <EOI>
    [  846.863906]
    [  846.863906]  [<ffffffff812a011c>] ? arch_local_irq_enable+0x4/0x8
    [  846.863906]  [<ffffffff812a04f3>] ? cpuidle_enter_state+0x52/0xc1
    [  846.863906]  [<ffffffff812a0636>] ? cpuidle_idle_call+0xd4/0x143
    [  846.863906]  [<ffffffff8101398c>] ? arch_cpu_idle+0x5/0x17
    [  846.863906]  [<ffffffff81072571>] ? cpu_startup_entry+0x10d/0x187
    [  846.863906]  [<ffffffff816b3d3d>] ? start_kernel+0x3e8/0x3f3
    [  846.863906]  [<ffffffff816b3777>] ? repair_env_string+0x54/0x54
    [  846.863906]  [<ffffffff816b3598>] ? x86_64_start_kernel+0xf2/0xfd
    [  846.863906] Code: 25 09 00 00 c6 83 da 08 00 00 03 8b 45 54 48 01 83 b6 08 00 00 8b 45 50 48 01 83 db 08 00 00 8b 4d 18 69 c1 ff ff 00 00 03 4d 14 <48> f7 f1 89 83 a8 09 00 00 e9 68 fe ff ff 48 8b 7f 10 e8 79 92
    [  846.863906] RIP  [<ffffffffa092be0c>] smsdvb_onresponse+0x264/0xa86 [smsdvb]
    [  846.863906]  RSP <ffff88013bc03cf0>
    Reference: http://bugs.debian.org/719623
    
    Reported-by: Johannes Rohr <jorohr@gmail.com>
    Signed-off-by: Bjørn Mork <bjorn@mork.no>
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>

commit d4bd54fbac2ea5c30eb976ca557e905f489d55f4
Author: Paul E. McKenney <paulmck@kernel.org>
Date:   Fri Jun 21 14:51:40 2013 -0700

    nohz_full: Add full-system idle states and variables
    
    This commit adds control variables and states for full-system idle.
    The system will progress through the states in numerical order when
    the system is fully idle (other than the timekeeping CPU), and reset
    down to the initial state if any non-timekeeping CPU goes non-idle.
    The current state is kept in full_sysidle_state.
    
    One flavor of RCU will be in charge of driving the state machine,
    defined by rcu_sysidle_state.  This should be the busiest flavor of RCU.
    
    Signed-off-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Reviewed-by: Josh Triplett <josh@joshtriplett.org>

commit 2333210b26cf7aaf48d71343029afb860103d9f9
Author: Paul E. McKenney <paulmck@kernel.org>
Date:   Fri Jun 21 12:34:33 2013 -0700

    nohz_full: Add rcu_dyntick data for scalable detection of all-idle state
    
    This commit adds fields to the rcu_dyntick structure that are used to
    detect idle CPUs.  These new fields differ from the existing ones in
    that the existing ones consider a CPU executing in user mode to be idle,
    where the new ones consider CPUs executing in user mode to be busy.
    The handling of these new fields is otherwise quite similar to that for
    the exiting fields.  This commit also adds the initialization required
    for these fields.
    
    So, why is usermode execution treated differently, with RCU considering
    it a quiescent state equivalent to idle, while in contrast the new
    full-system idle state detection considers usermode execution to be
    non-idle?
    
    It turns out that although one of RCU's quiescent states is usermode
    execution, it is not a full-system idle state.  This is because the
    purpose of the full-system idle state is not RCU, but rather determining
    when accurate timekeeping can safely be disabled.  Whenever accurate
    timekeeping is required in a CONFIG_NO_HZ_FULL kernel, at least one
    CPU must keep the scheduling-clock tick going.  If even one CPU is
    executing in user mode, accurate timekeeping is requires, particularly for
    architectures where gettimeofday() and friends do not enter the kernel.
    Only when all CPUs are really and truly idle can accurate timekeeping be
    disabled, allowing all CPUs to turn off the scheduling clock interrupt,
    thus greatly improving energy efficiency.
    
    This naturally raises the question "Why is this code in RCU rather than in
    timekeeping?", and the answer is that RCU has the data and infrastructure
    to efficiently make this determination.
    
    Signed-off-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Acked-by: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Reviewed-by: Josh Triplett <josh@joshtriplett.org>

commit b44379af1cf40050794832c38ea6a64e07eb5087
Author: Paul E. McKenney <paulmck@kernel.org>
Date:   Fri Jun 21 11:08:45 2013 -0700

    nohz_full: Add Kconfig parameter for scalable detection of all-idle state
    
    At least one CPU must keep the scheduling-clock tick running for
    timekeeping purposes whenever there is a non-idle CPU.  However, with
    the new nohz_full adaptive-idle machinery, it is difficult to distinguish
    between all CPUs really being idle as opposed to all non-idle CPUs being
    in adaptive-ticks mode.  This commit therefore adds a Kconfig parameter
    as a first step towards enabling a scalable detection of full-system
    idle state.
    
    Signed-off-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    [ paulmck: Update help text per Frederic Weisbecker. ]
    Reviewed-by: Josh Triplett <josh@joshtriplett.org>

commit 21884a83b2192a00885d7244a1dda32debd2fbc7
Merge: 8b70a90cabaf 73b0cd674ccc
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jul 6 14:09:38 2013 -0700

    Merge branch 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer core updates from Thomas Gleixner:
     "The timer changes contain:
    
       - posix timer code consolidation and fixes for odd corner cases
    
       - sched_clock implementation moved from ARM to core code to avoid
         duplication by other architectures
    
       - alarm timer updates
    
       - clocksource and clockevents unregistration facilities
    
       - clocksource/events support for new hardware
    
       - precise nanoseconds RTC readout (Xen feature)
    
       - generic support for Xen suspend/resume oddities
    
       - the usual lot of fixes and cleanups all over the place
    
      The parts which touch other areas (ARM/XEN) have been coordinated with
      the relevant maintainers.  Though this results in an handful of
      trivial to solve merge conflicts, which we preferred over nasty cross
      tree merge dependencies.
    
      The patches which have been committed in the last few days are bug
      fixes plus the posix timer lot.  The latter was in akpms queue and
      next for quite some time; they just got forgotten and Frederic
      collected them last minute."
    
    * 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (59 commits)
      hrtimer: Remove unused variable
      hrtimers: Move SMP function call to thread context
      clocksource: Reselect clocksource when watchdog validated high-res capability
      posix-cpu-timers: don't account cpu timer after stopped thread runtime accounting
      posix_timers: fix racy timer delta caching on task exit
      posix-timers: correctly get dying task time sample in posix_cpu_timer_schedule()
      selftests: add basic posix timers selftests
      posix_cpu_timers: consolidate expired timers check
      posix_cpu_timers: consolidate timer list cleanups
      posix_cpu_timer: consolidate expiry time type
      tick: Sanitize broadcast control logic
      tick: Prevent uncontrolled switch to oneshot mode
      tick: Make oneshot broadcast robust vs. CPU offlining
      x86: xen: Sync the CMOS RTC as well as the Xen wallclock
      x86: xen: Sync the wallclock when the system time is set
      timekeeping: Indicate that clock was set in the pvclock gtod notifier
      timekeeping: Pass flags instead of multiple bools to timekeeping_update()
      xen: Remove clock_was_set() call in the resume path
      hrtimers: Support resuming with two or more CPUs online (but stopped)
      timer: Fix jiffies wrap behavior of round_jiffies_common()
      ...

commit 47433b8c9d7480a3eebd99df38e857ce85a37cee
Author: David Vrabel <david.vrabel@citrix.com>
Date:   Thu Jun 27 11:35:48 2013 +0100

    x86: xen: Sync the CMOS RTC as well as the Xen wallclock
    
    Adjustments to Xen's persistent clock via update_persistent_clock()
    don't actually persist, as the Xen wallclock is a software only clock
    and modifications to it do not modify the underlying CMOS RTC.
    
    The x86_platform.set_wallclock hook is there to keep the hardware RTC
    synchronized. On a guest this is pointless.
    
    On Dom0 we can use the native implementaion which actually updates the
    hardware RTC, but we still need to keep the software emulation of RTC
    for the guests up to date. The subscription to the pvclock_notifier
    allows us to emulate this easily. The notifier is called at every tick
    and when the clock was set.
    
    Right now we only use that notifier when the clock was set, but due to
    the fact that it is called periodically from the timekeeping update
    code, we can utilize it to emulate the NTP driven drift compensation
    of update_persistant_clock() for the Xen wall (software) clock.
    
    Add a 11 minutes periodic update to the pvclock_gtod notifier callback
    to achieve that. The static variable 'next' which maintains that 11
    minutes update cycle is protected by the core code serialization so
    there is no need to add a Xen specific serialization mechanism.
    
    [ tglx: Massaged changelog and added a few comments ]
    
    Signed-off-by: David Vrabel <david.vrabel@citrix.com>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: <xen-devel@lists.xen.org>
    Link: http://lkml.kernel.org/r/1372329348-20841-6-git-send-email-david.vrabel@citrix.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 780427f0e113b4c77dfff4d258c05a902cdb0eb9
Author: David Vrabel <david.vrabel@citrix.com>
Date:   Thu Jun 27 11:35:46 2013 +0100

    timekeeping: Indicate that clock was set in the pvclock gtod notifier
    
    If the clock was set (stepped), set the action parameter to functions
    in the pvclock gtod notifier chain to non-zero.  This allows the
    callee to only do work if the clock was stepped.
    
    This will be used on Xen as the synchronization of the Xen wallclock
    to the control domain's (dom0) system time will be done with this
    notifier and updating on every timer tick is unnecessary and too
    expensive.
    
    Signed-off-by: David Vrabel <david.vrabel@citrix.com>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: <xen-devel@lists.xen.org>
    Link: http://lkml.kernel.org/r/1372329348-20841-4-git-send-email-david.vrabel@citrix.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 04397fe94ad65289884b9862b6a0c722ececaadf
Author: David Vrabel <david.vrabel@citrix.com>
Date:   Thu Jun 27 11:35:45 2013 +0100

    timekeeping: Pass flags instead of multiple bools to timekeeping_update()
    
    Instead of passing multiple bools to timekeeping_updated(), define
    flags and use a single 'action' parameter.  It is then more obvious
    what each timekeeping_update() call does.
    
    Signed-off-by: David Vrabel <david.vrabel@citrix.com>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: <xen-devel@lists.xen.org>
    Link: http://lkml.kernel.org/r/1372329348-20841-3-git-send-email-david.vrabel@citrix.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit a008dad702a55b27720760ab0f8a129dde49fb6e
Author: Daniel Lezcano <daniel.lezcano@linaro.org>
Date:   Fri Jun 21 14:36:59 2013 +0200

    ARM: at91: cpuidle: Fix target_residency
    
    The following commit:
    
    commit 7e348b9012522fa0efd854d20d210d5e57fcedd1
    Author: Robert Lee <rob.lee@linaro.org>
    Date:   Tue Mar 20 15:22:43 2012 -0500
    
        ARM: at91: Consolidate time keeping and irq enable
    
        Enable core cpuidle timekeeping and irq enabling and remove that
        handling from this code.
    
    introduced an additional zero to the state1 (suspend) target residency.
    
    With a periodic tick, the cpu never enters the state1 with both 10000 and
    100000.
    
    With a tickless system, it enters to state1 much more often with the
    initial value, roughly x7 more.
    
    Fix it by setting the value to 10ms again.
    
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    [nicola.ferre@atmel.com: add precisions given by Daniel to commit message]
    Signed-off-by: Nicolas Ferre <nicolas.ferre@atmel.com>

commit 4db88eb4c300333ed37585f75ab9a664ec537d68
Merge: 53d5defcfa8c f5d00c1f9adb
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jun 20 08:15:13 2013 -1000

    Merge branch 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer fixes from Thomas Gleixner:
     - Fix inconstinant clock usage in virtual time accounting
     - Fix a build error in KVM caused by the NOHZ work
     - Remove a pointless timekeeping duty assignment which breaks NOHZ
     - Use a proper notifier return value to avoid random behaviour
    
    * 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      tick: Remove useless timekeeping duty attribution to broadcast source
      nohz: Fix notifier return val that enforce timekeeping
      kvm: Move guest entry/exit APIs to context_tracking
      vtime: Use consistent clocks among nohz accounting

commit 054b50539d3dac99c5454e612e541c1f351a38b1
Author: Zoran Markovic <zoran.markovic@linaro.org>
Date:   Fri May 17 11:24:05 2013 -0700

    timekeeping: Correct run-time detection of persistent_clock.
    
    commit 0d6bd9953f739dad96d9a0de65383e479ab4e10d upstream.
    
    Since commit 31ade30692dc9680bfc95700d794818fa3f754ac, timekeeping_init()
    checks for presence of persistent clock by attempting to read a non-zero
    time value. This is an issue on platforms where persistent_clock (instead
    is implemented as a free-running counter (instead of an RTC) starting
    from zero on each boot and running during suspend. Examples are some ARM
    platforms (e.g. PandaBoard).
    
    An attempt to read such a clock during timekeeping_init() may return zero
    value and falsely declare persistent clock as missing. Additionally, in
    the above case suspend times may be accounted twice (once from
    timekeeping_resume() and once from rtc_resume()), resulting in a gradual
    drift of system time.
    
    This patch does a run-time correction of the issue by doing the same check
    during timekeeping_suspend().
    
    A better long-term solution would have to return error when trying to read
    non-existing clock and zero when trying to read an uninitialized clock, but
    that would require changing all persistent_clock implementations.
    
    This patch addresses the immediate breakage, for now.
    
    Signed-off-by: Zoran Markovic <zoran.markovic@linaro.org>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Feng Tang <feng.tang@intel.com>
    [jstultz: Tweaked commit message and subject]
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    [zoran.markovic@linaro.org: reworked patch to fit 3.9-stable.]
    Signed-off-by: Zoran Markovic <zoran.markovic@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit d556d3262945a9f7733c0c2cf70be5ac0c358254
Author: John Stultz <john.stultz@linaro.org>
Date:   Mon Jan 28 12:01:40 2013 -0800

    2.6.32.y: timekeeping: Fix nohz issue with commit 61b76840ddee647c0c223365378c3f394355b7d7
    
    Commit 61b76840ddee647c0c223365378c3f394355b7d7 ("time: Avoid
    making adjustments if we haven't accumulated anything")
    introduced a regression with nohz.
    
    Basically with kernels between 2.6.20-something to 2.6.32,
    we accumulate time in half second chunks, rather then every
    timer-tick. This was added because when NOHZ landed, if you
    were idle for a few seconds, you had to spin for every tick
    we skipped in the accumulation loop, which created some bad
    latencies.
    
    However, this required that we create the xtime_cache() which
    was still updated each tick, so that filesystem timestamps,
    etc continued to see time increment normally.
    
    Of course, the xtime_cache is updated at the bottom of
    update_wall_time(). So the early return on
    (offset < timekeeper.cycle_interval), added by the problematic
    commit causes the xtime_cache to not be updated.
    
    This can cause code using current_kernel_time() (like the mqueue
    code) or hrtimer_get_softirq_time(), which uses the non-updated
    xtime_cache, to see timers to fire with very coarse half-second
    granularity.
    
    Many thanks to Romain for describing the issue clearly,
    providing test case to reproduce it and helping with testing
    the solution.
    
    This change is for 2.6.32-stable ONLY!
    
    Cc: stable@vger.kernel.org
    Cc: Willy Tarreau <w@1wt.eu>
    Cc: Romain Francoise <romain@orebokech.com>
    Reported-by: Romain Francoise <romain@orebokech.com>
    Tested-by: Romain Francoise <romain@orebokech.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Willy Tarreau <w@1wt.eu>

commit 81db4dbf592b486ac2bc7cabfb328ee2a6c4725d
Merge: c3e58a7945c8 67dd331c5d81
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jun 8 15:51:21 2013 -0700

    Merge branch 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer fixes from Thomas Gleixner:
    
     - Trivial: unused variable removal
    
     - Posix-timers: Add the clock ID to the new proc interface to make it
       useful.  The interface is new and should be functional when we reach
       the final 3.10 release.
    
     - Cure a false positive warning in the tick code introduced by the
       overhaul in 3.10
    
     - Fix for a persistent clock detection regression introduced in this
       cycle
    
    * 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      timekeeping: Correct run-time detection of persistent_clock.
      ntp: Remove unused variable flags in __hardpps
      posix-timers: Show clock ID in proc file
      tick: Cure broadcast false positive pending bit warning

commit f5d00c1f9adb350c24c5301600f7bf2da99b66de
Author: Jiri Bohac <jbohac@suse.cz>
Date:   Tue May 28 15:29:03 2013 +0200

    tick: Remove useless timekeeping duty attribution to broadcast source
    
    Since 7300711e ("clockevents: broadcast fixup possible waiters"),
    the timekeeping duty is assigned to the CPU that handles the tick
    broadcast clock device by the time it is set in one shot mode.
    
    This is an issue in full dynticks mode where the timekeeping duty
    must stay handled by the boot CPU for now. Otherwise it prevents
    secondary CPUs from offlining and this breaks
    suspend/shutdown/reboot/...
    
    As it appears there is no reason for this timekeeping duty to be
    moved to the broadcast CPU, besides nothing prevent it from being
    later re-assigned to another target, let's simply remove it.
    
    Signed-off-by: Jiri Bohac <jbohac@suse.cz>
    Reported-by: Steven Rostedt <rostedt@goodmis.org>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 1a7f829f094dd7951e7d46c571a18080e455a436
Author: Li Zhong <zhong@linux.vnet.ibm.com>
Date:   Fri May 17 16:44:04 2013 +0800

    nohz: Fix notifier return val that enforce timekeeping
    
    In tick_nohz_cpu_down_callback() if the cpu is the one handling
    timekeeping, we must return something that stops the CPU_DOWN_PREPARE
    notifiers and then start notify CPU_DOWN_FAILED on the already called
    notifier call backs.
    
    However traditional errno values are not handled by the notifier unless
    these are encapsulated using errno_to_notifier().
    
    Hence the current -EINVAL is misinterpreted and converted to junk after
    notifier_to_errno(), leaving the notifier subsystem to random behaviour
    such as eventually allowing the cpu to go down.
    
    Fix this by using the standard NOTIFY_BAD instead.
    
    Signed-off-by: Li Zhong <zhong@linux.vnet.ibm.com>
    Reviewed-by: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
    Acked-by: Steven Rostedt <rostedt@goodmis.org>
    Cc: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 5c83545f24ab3dd67e0ae0e2b795fea750f08c34
Author: Colin Cross <ccross@android.com>
Date:   Tue May 21 22:32:14 2013 -0700

    power: Add option to log time spent in suspend
    
    Below is a patch from android kernel that maintains a histogram of
    suspend times. Please review and provide feedback.
    
    Statistices on the time spent in suspend are kept in
    /sys/kernel/debug/sleep_time.
    
    Cc: Android Kernel Team <kernel-team@android.com>
    Cc: Colin Cross <ccross@android.com>
    Cc: Todd Poynor <toddpoynor@google.com>
    Cc: San Mehat <san@google.com>
    Cc: Benoit Goby <benoit@android.com>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Colin Cross <ccross@android.com>
    Signed-off-by: Todd Poynor <toddpoynor@google.com>
    [zoran.markovic@linaro.org: Re-formatted suspend time table to better
    fit expected values. Moved accounting of suspend time into timekeeping
    core. Removed CONFIG_SUSPEND_TIME flag and made the feature conditional
    on CONFIG_DEBUG_FS. Changed the file name to sleep_time to better fit
    terminology in timekeeping core. Changed seq_printf to seq_puts. Tweaked
    commit message]
    Signed-off-by: Zoran Markovic <zoran.markovic@linaro.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 0d6bd9953f739dad96d9a0de65383e479ab4e10d
Author: Zoran Markovic <zoran.markovic@linaro.org>
Date:   Fri May 17 11:24:05 2013 -0700

    timekeeping: Correct run-time detection of persistent_clock.
    
    Since commit 31ade30692dc9680bfc95700d794818fa3f754ac, timekeeping_init()
    checks for presence of persistent clock by attempting to read a non-zero
    time value. This is an issue on platforms where persistent_clock (instead
    is implemented as a free-running counter (instead of an RTC) starting
    from zero on each boot and running during suspend. Examples are some ARM
    platforms (e.g. PandaBoard).
    
    An attempt to read such a clock during timekeeping_init() may return zero
    value and falsely declare persistent clock as missing. Additionally, in
    the above case suspend times may be accounted twice (once from
    timekeeping_resume() and once from rtc_resume()), resulting in a gradual
    drift of system time.
    
    This patch does a run-time correction of the issue by doing the same check
    during timekeeping_suspend().
    
    A better long-term solution would have to return error when trying to read
    non-existing clock and zero when trying to read an uninitialized clock, but
    that would require changing all persistent_clock implementations.
    
    This patch addresses the immediate breakage, for now.
    
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Feng Tang <feng.tang@intel.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Zoran Markovic <zoran.markovic@linaro.org>
    [jstultz: Tweaked commit message and subject]
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit aa848233f740abbabfa7669daca0ab94aaa37bcd
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Fri May 3 23:27:07 2013 +0200

    ntp: Remove unused variable flags in __hardpps
    
    kernel/time/ntp.c: In function ‘__hardpps’:
    kernel/time/ntp.c:877: warning: unused variable ‘flags’
    
    commit a076b2146fabb0894cae5e0189a8ba3f1502d737 ("ntp: Remove ntp_lock,
    using the timekeeping locks to protect ntp state") removed its users,
    but not the actual variable.
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit c7e99fc75de8882bc4104455ace366d9d3599a96
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue May 28 09:28:02 2013 +0200

    clockevents: Define CS_NAME_LEN unconditionally
    
    Unbreak architectures which do not use clockevents, but require to
    build some of the core timekeeping infrastructure
    
    Reported-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit ba919d1caa2e624eb8c6cae1f2ce0a253e697d45
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Apr 25 20:31:44 2013 +0000

    clocksource: Let timekeeping_notify return success/error
    
    timekeeping_notify() can fail due cs->enable() failure. Though the
    caller does not notice and happily keeps the wrong clocksource as the
    current one.
    
    Let the caller know about failure, so the current clocksource will be
    shown correctly in sysfs.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: John Stultz <john.stultz@linaro.org>
    Cc: Magnus Damm <magnus.damm@gmail.com>
    Link: http://lkml.kernel.org/r/20130425143435.696321912@linutronix.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 75ebfaade87e49f132a90d93020ddebc13a8289e
Author: David Engraf <david.engraf@sysgo.com>
Date:   Tue Mar 19 13:29:55 2013 +0100

    hrtimer: Fix ktime_add_ns() overflow on 32bit architectures
    
    commit 51fd36f3fad8447c487137ae26b9d0b3ce77bb25 upstream.
    
    One can trigger an overflow when using ktime_add_ns() on a 32bit
    architecture not supporting CONFIG_KTIME_SCALAR.
    
    When passing a very high value for u64 nsec, e.g. 7881299347898368000
    the do_div() function converts this value to seconds (7881299347) which
    is still to high to pass to the ktime_set() function as long. The result
    in is a negative value.
    
    The problem on my system occurs in the tick-sched.c,
    tick_nohz_stop_sched_tick() when time_delta is set to
    timekeeping_max_deferment(). The check for time_delta < KTIME_MAX is
    valid, thus ktime_add_ns() is called with a too large value resulting in
    a negative expire value. This leads to an endless loop in the ticker code:
    
    time_delta: 7881299347898368000
    expires = ktime_add_ns(last_update, time_delta)
    expires: negative value
    
    This fix caps the value to KTIME_MAX.
    
    This error doesn't occurs on 64bit or architectures supporting
    CONFIG_KTIME_SCALAR (e.g. ARM, x86-32).
    
    Signed-off-by: David Engraf <david.engraf@sysgo.com>
    [jstultz: Minor tweaks to commit message & header]
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit f931d5e4bf1902ae2a4829db0e6f3c789fd7d092
Author: David Engraf <david.engraf@sysgo.com>
Date:   Tue Mar 19 13:29:55 2013 +0100

    hrtimer: Fix ktime_add_ns() overflow on 32bit architectures
    
    commit 51fd36f3fad8447c487137ae26b9d0b3ce77bb25 upstream.
    
    One can trigger an overflow when using ktime_add_ns() on a 32bit
    architecture not supporting CONFIG_KTIME_SCALAR.
    
    When passing a very high value for u64 nsec, e.g. 7881299347898368000
    the do_div() function converts this value to seconds (7881299347) which
    is still to high to pass to the ktime_set() function as long. The result
    in is a negative value.
    
    The problem on my system occurs in the tick-sched.c,
    tick_nohz_stop_sched_tick() when time_delta is set to
    timekeeping_max_deferment(). The check for time_delta < KTIME_MAX is
    valid, thus ktime_add_ns() is called with a too large value resulting in
    a negative expire value. This leads to an endless loop in the ticker code:
    
    time_delta: 7881299347898368000
    expires = ktime_add_ns(last_update, time_delta)
    expires: negative value
    
    This fix caps the value to KTIME_MAX.
    
    This error doesn't occurs on 64bit or architectures supporting
    CONFIG_KTIME_SCALAR (e.g. ARM, x86-32).
    
    Signed-off-by: David Engraf <david.engraf@sysgo.com>
    [jstultz: Minor tweaks to commit message & header]
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit afb6f738ccaee780d65c1a787666812b0df5719d
Author: David Engraf <david.engraf@sysgo.com>
Date:   Tue Mar 19 13:29:55 2013 +0100

    hrtimer: Fix ktime_add_ns() overflow on 32bit architectures
    
    commit 51fd36f3fad8447c487137ae26b9d0b3ce77bb25 upstream.
    
    One can trigger an overflow when using ktime_add_ns() on a 32bit
    architecture not supporting CONFIG_KTIME_SCALAR.
    
    When passing a very high value for u64 nsec, e.g. 7881299347898368000
    the do_div() function converts this value to seconds (7881299347) which
    is still to high to pass to the ktime_set() function as long. The result
    in is a negative value.
    
    The problem on my system occurs in the tick-sched.c,
    tick_nohz_stop_sched_tick() when time_delta is set to
    timekeeping_max_deferment(). The check for time_delta < KTIME_MAX is
    valid, thus ktime_add_ns() is called with a too large value resulting in
    a negative expire value. This leads to an endless loop in the ticker code:
    
    time_delta: 7881299347898368000
    expires = ktime_add_ns(last_update, time_delta)
    expires: negative value
    
    This fix caps the value to KTIME_MAX.
    
    This error doesn't occurs on 64bit or architectures supporting
    CONFIG_KTIME_SCALAR (e.g. ARM, x86-32).
    
    Signed-off-by: David Engraf <david.engraf@sysgo.com>
    [jstultz: Minor tweaks to commit message & header]
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit b0f97a448749144ed26634ed47323ce2217a7a4c
Author: David Engraf <david.engraf@sysgo.com>
Date:   Tue Mar 19 13:29:55 2013 +0100

    hrtimer: Fix ktime_add_ns() overflow on 32bit architectures
    
    commit 51fd36f3fad8447c487137ae26b9d0b3ce77bb25 upstream.
    
    One can trigger an overflow when using ktime_add_ns() on a 32bit
    architecture not supporting CONFIG_KTIME_SCALAR.
    
    When passing a very high value for u64 nsec, e.g. 7881299347898368000
    the do_div() function converts this value to seconds (7881299347) which
    is still to high to pass to the ktime_set() function as long. The result
    in is a negative value.
    
    The problem on my system occurs in the tick-sched.c,
    tick_nohz_stop_sched_tick() when time_delta is set to
    timekeeping_max_deferment(). The check for time_delta < KTIME_MAX is
    valid, thus ktime_add_ns() is called with a too large value resulting in
    a negative expire value. This leads to an endless loop in the ticker code:
    
    time_delta: 7881299347898368000
    expires = ktime_add_ns(last_update, time_delta)
    expires: negative value
    
    This fix caps the value to KTIME_MAX.
    
    This error doesn't occurs on 64bit or architectures supporting
    CONFIG_KTIME_SCALAR (e.g. ARM, x86-32).
    
    Signed-off-by: David Engraf <david.engraf@sysgo.com>
    [jstultz: Minor tweaks to commit message & header]
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 86a640faa8585b60b2f2f78dd9769e2cc939208f
Author: David Engraf <david.engraf@sysgo.com>
Date:   Tue Mar 19 13:29:55 2013 +0100

    hrtimer: Fix ktime_add_ns() overflow on 32bit architectures
    
    commit 51fd36f3fad8447c487137ae26b9d0b3ce77bb25 upstream.
    
    One can trigger an overflow when using ktime_add_ns() on a 32bit
    architecture not supporting CONFIG_KTIME_SCALAR.
    
    When passing a very high value for u64 nsec, e.g. 7881299347898368000
    the do_div() function converts this value to seconds (7881299347) which
    is still to high to pass to the ktime_set() function as long. The result
    in is a negative value.
    
    The problem on my system occurs in the tick-sched.c,
    tick_nohz_stop_sched_tick() when time_delta is set to
    timekeeping_max_deferment(). The check for time_delta < KTIME_MAX is
    valid, thus ktime_add_ns() is called with a too large value resulting in
    a negative expire value. This leads to an endless loop in the ticker code:
    
    time_delta: 7881299347898368000
    expires = ktime_add_ns(last_update, time_delta)
    expires: negative value
    
    This fix caps the value to KTIME_MAX.
    
    This error doesn't occurs on 64bit or architectures supporting
    CONFIG_KTIME_SCALAR (e.g. ARM, x86-32).
    
    Signed-off-by: David Engraf <david.engraf@sysgo.com>
    [jstultz: Minor tweaks to commit message & header]
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit ab86e974f04b1cd827a9c7c35273834ebcd9ab38
Merge: 8700c95adb03 6f7a05d7018d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Apr 30 08:15:40 2013 -0700

    Merge branch 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull core timer updates from Ingo Molnar:
     "The main changes in this cycle's merge are:
    
       - Implement shadow timekeeper to shorten in kernel reader side
         blocking, by Thomas Gleixner.
    
       - Posix timers enhancements by Pavel Emelyanov:
    
       - allocate timer ID per process, so that exact timer ID allocations
         can be re-created be checkpoint/restore code.
    
       - debuggability and tooling (/proc/PID/timers, etc.) improvements.
    
       - suspend/resume enhancements by Feng Tang: on certain new Intel Atom
         processors (Penwell and Cloverview), there is a feature that the
         TSC won't stop in S3 state, so the TSC value won't be reset to 0
         after resume.  This can be taken advantage of by the generic via
         the CLOCK_SOURCE_SUSPEND_NONSTOP flag: instead of using the RTC to
         recover/approximate sleep time, the main (and precise) clocksource
         can be used.
    
       - Fix /proc/timer_list for 4096 CPUs by Nathan Zimmer: on so many
         CPUs the file goes beyond 4MB of size and thus the current
         simplistic seqfile approach fails.  Convert /proc/timer_list to a
         proper seq_file with its own iterator.
    
       - Cleanups and refactorings of the core timekeeping code by John
         Stultz.
    
       - International Atomic Clock time is managed by the NTP code
         internally currently but not exposed externally.  Separate the TAI
         code out and add CLOCK_TAI support and TAI support to the hrtimer
         and posix-timer code, by John Stultz.
    
       - Add deep idle support enhacement to the broadcast clockevents core
         timer code, by Daniel Lezcano: add an opt-in CLOCK_EVT_FEAT_DYNIRQ
         clockevents feature (which will be utilized by future clockevents
         driver updates), which allows the use of IRQ affinities to avoid
         spurious wakeups of idle CPUs - the right CPU with an expiring
         timer will be woken.
    
       - Add new ARM bcm281xx clocksource driver, by Christian Daudt
    
       - ... various other fixes and cleanups"
    
    * 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (52 commits)
      clockevents: Set dummy handler on CPU_DEAD shutdown
      timekeeping: Update tk->cycle_last in resume
      posix-timers: Remove unused variable
      clockevents: Switch into oneshot mode even if broadcast registered late
      timer_list: Convert timer list to be a proper seq_file
      timer_list: Split timer_list_show_tickdevices
      posix-timers: Show sigevent info in proc file
      posix-timers: Introduce /proc/PID/timers file
      posix timers: Allocate timer id per process (v2)
      timekeeping: Make sure to notify hrtimers when TAI offset changes
      hrtimer: Fix ktime_add_ns() overflow on 32bit architectures
      hrtimer: Add expiry time overflow check in hrtimer_interrupt
      timekeeping: Shorten seq_count region
      timekeeping: Implement a shadow timekeeper
      timekeeping: Delay update of clock->cycle_last
      timekeeping: Store cycle_last value in timekeeper struct as well
      ntp: Remove ntp_lock, using the timekeeping locks to protect ntp state
      timekeeping: Simplify tai updating from do_adjtimex
      timekeeping: Hold timekeepering locks in do_adjtimex and hardpps
      timekeeping: Move ADJ_SETOFFSET to top level do_adjtimex()
      ...

commit 77c675ba18836802f6b73d2d773481d06ebc0f04
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Apr 22 09:37:04 2013 +0200

    timekeeping: Update tk->cycle_last in resume
    
    commit 7ec98e15aa (timekeeping: Delay update of clock->cycle_last)
    forgot to update tk->cycle_last in the resume path. This results in a
    stale value versus clock->cycle_last and prevents resume in the worst
    case.
    
    Reported-by: Jiri Slaby <jslaby@suse.cz>
    Reported-and-tested-by: Borislav Petkov <bp@alien8.de>
    Acked-by: John Stultz <john.stultz@linaro.org>
    Cc: Linux-pm mailing list <linux-pm@lists.linux-foundation.org>
    Link: http://lkml.kernel.org/r/alpine.LFD.2.02.1304211648150.21884@ionos
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 2727872dfe5d273f313f8a0c0dd0fcc58e96cde7
Merge: 65d798f0f933 f98823ac758b
Author: Ingo Molnar <mingo@kernel.org>
Date:   Sun Apr 21 11:04:42 2013 +0200

    Merge branch 'timers/nohz-reviewed' of git://git.kernel.org/pub/scm/linux/kernel/git/frederic/linux-dynticks into timers/nohz
    
    Pull full dynticks timekeeping and RCU improvements from Frederic Weisbecker.
    
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit f98823ac758ba1aa77c6e3f8ad4ef3ad84ee0a7c
Author: Frederic Weisbecker <fweisbec@gmail.com>
Date:   Wed Mar 27 01:17:22 2013 +0100

    nohz: New option to default all CPUs in full dynticks range
    
    Provide a new kernel config that defaults all CPUs to be part
    of the full dynticks range, except the boot one for timekeeping.
    
    This default setting is overriden by the nohz_full= boot option
    if passed by the user.
    
    This is helpful for those who don't need a finegrained range
    of full dynticks CPU and also for automated testing.
    
    Suggested-by: Ingo Molnar <mingo@kernel.org>
    Reviewed-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Chris Metcalf <cmetcalf@tilera.com>
    Cc: Christoph Lameter <cl@linux.com>
    Cc: Geoff Levand <geoff@infradead.org>
    Cc: Gilad Ben Yossef <gilad@benyossef.com>
    Cc: Hakan Akkan <hakanakkan@gmail.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Kevin Hilman <khilman@linaro.org>
    Cc: Li Zhong <zhong@linux.vnet.ibm.com>
    Cc: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Cc: Paul Gortmaker <paul.gortmaker@windriver.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>

commit 0453b435df0d69dd0d8c42eb9b3015aaf0d8a032
Author: Frederic Weisbecker <fweisbec@gmail.com>
Date:   Wed Mar 27 02:18:34 2013 +0100

    nohz: Force boot CPU outside full dynticks range
    
    The timekeeping job must be able to run early on boot
    because there may be some pre-SMP (and thus pre-initcalls )
    components that rely on it. The IO-APIC is one such users
    as it tests the timer health by watching jiffies progression.
    
    Given that it happens before we know the initial online
    set, we can't rely on it to select a timekeeper. We need
    one before SMP time otherwise we simply crash on boot.
    
    To fix this and keep things simple for now, force the boot CPU
    outside of the full dynticks range in any case and do this early
    on kernel parameter parsing time.
    
    We might want a trickier solution later, expecially for aSMP
    architectures that need to assign housekeeping tasks to arbitrary
    low power CPUs.
    
    But it's still first pass KISS time for now.
    
    Reviewed-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Chris Metcalf <cmetcalf@tilera.com>
    Cc: Christoph Lameter <cl@linux.com>
    Cc: Geoff Levand <geoff@infradead.org>
    Cc: Gilad Ben Yossef <gilad@benyossef.com>
    Cc: Hakan Akkan <hakanakkan@gmail.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Kevin Hilman <khilman@linaro.org>
    Cc: Li Zhong <zhong@linux.vnet.ibm.com>
    Cc: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Cc: Paul Gortmaker <paul.gortmaker@windriver.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>

commit 4e8f8b34b92b6514cc070aeb94d317cadd5071d7
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Apr 10 12:41:49 2013 -0700

    timekeeping: Make sure to notify hrtimers when TAI offset changes
    
    Now that we have CLOCK_TAI timers, make sure we notify hrtimer
    code when TAI offset is changed.
    
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Link: http://lkml.kernel.org/r/1365622909-953-1-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 51fd36f3fad8447c487137ae26b9d0b3ce77bb25
Author: David Engraf <david.engraf@sysgo.com>
Date:   Tue Mar 19 13:29:55 2013 +0100

    hrtimer: Fix ktime_add_ns() overflow on 32bit architectures
    
    One can trigger an overflow when using ktime_add_ns() on a 32bit
    architecture not supporting CONFIG_KTIME_SCALAR.
    
    When passing a very high value for u64 nsec, e.g. 7881299347898368000
    the do_div() function converts this value to seconds (7881299347) which
    is still to high to pass to the ktime_set() function as long. The result
    in is a negative value.
    
    The problem on my system occurs in the tick-sched.c,
    tick_nohz_stop_sched_tick() when time_delta is set to
    timekeeping_max_deferment(). The check for time_delta < KTIME_MAX is
    valid, thus ktime_add_ns() is called with a too large value resulting in
    a negative expire value. This leads to an endless loop in the ticker code:
    
    time_delta: 7881299347898368000
    expires = ktime_add_ns(last_update, time_delta)
    expires: negative value
    
    This fix caps the value to KTIME_MAX.
    
    This error doesn't occurs on 64bit or architectures supporting
    CONFIG_KTIME_SCALAR (e.g. ARM, x86-32).
    
    Cc: stable@vger.kernel.org
    Signed-off-by: David Engraf <david.engraf@sysgo.com>
    [jstultz: Minor tweaks to commit message & header]
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit ca4523cda429712fc135c5db50920d90eb776a6c
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Feb 21 22:51:40 2013 +0000

    timekeeping: Shorten seq_count region
    
    Shorten the seqcount write hold region to the actual update of the
    timekeeper and the related data (e.g vsyscall).
    
    On a contemporary x86 system this reduces the maximum latencies on
    Preempt-RT from 8us to 4us on the non-timekeeping cores.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 48cdc135d4840aab8efd2fc3bacb5d7dfd94a9c8
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Feb 21 22:51:40 2013 +0000

    timekeeping: Implement a shadow timekeeper
    
    Use the shadow timekeeper to do the update_wall_time() adjustments and
    then copy it over to the real timekeeper.
    
    Keep the shadow timekeeper in sync when updating stuff outside of
    update_wall_time().
    
    This allows us to limit the timekeeper_seq hold time to the update of
    the real timekeeper and the vsyscall data in the next patch.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 7ec98e15aa049b7a2ca73485f31cf4f90c34e2dd
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Feb 21 22:51:39 2013 +0000

    timekeeping: Delay update of clock->cycle_last
    
    For calculating the new timekeeper values store the new cycle_last
    value in the timekeeper and update the clock->cycle_last just when we
    actually update the new values.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 14a3b6abe98c8f53a13522610c257accef7321df
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Feb 21 22:51:38 2013 +0000

    timekeeping: Store cycle_last value in timekeeper struct as well
    
    For implementing a shadow timekeeper and a split calculation/update
    region we need to store the cycle_last value in the timekeeper and
    update the value in the clocksource struct only in the update region.
    
    Add the extra storage to the timekeeper.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit a076b2146fabb0894cae5e0189a8ba3f1502d737
Author: John Stultz <john.stultz@linaro.org>
Date:   Fri Mar 22 11:52:03 2013 -0700

    ntp: Remove ntp_lock, using the timekeeping locks to protect ntp state
    
    In order to properly handle the NTP state in future changes to the
    timekeeping lock management, this patch moves the management of
    all of the ntp state under the timekeeping locks.
    
    This allows us to remove the ntp_lock.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 0b5154fb9040cca94e7d9893384c0e78bfe2d296
Author: John Stultz <john.stultz@linaro.org>
Date:   Fri Mar 22 14:20:03 2013 -0700

    timekeeping: Simplify tai updating from do_adjtimex
    
    Since we are taking the timekeeping locks, just go ahead
    and update any tai change directly, rather then dropping
    the lock and calling a function that will just take it again.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 06c017fdd4dc48451a29ac37fc1db4a3f86b7f40
Author: John Stultz <john.stultz@linaro.org>
Date:   Fri Mar 22 11:37:28 2013 -0700

    timekeeping: Hold timekeepering locks in do_adjtimex and hardpps
    
    In moving the NTP state to be protected by the timekeeping locks,
    be sure to acquire the timekeeping locks prior to calling
    ntp functions.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit cef90377fab488bd1f959efda178fb83250cf61d
Author: John Stultz <john.stultz@linaro.org>
Date:   Fri Mar 22 15:04:13 2013 -0700

    timekeeping: Move ADJ_SETOFFSET to top level do_adjtimex()
    
    Since ADJ_SETOFFSET adjusts the timekeeping state, process
    it as part of the top level do_adjtimex() function in
    timekeeping.c.
    
    This avoids deadlocks that could occur once we change the
    ntp locking rules.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit e4085693f629ded8ac8c35b5cdd324d20242990b
Author: John Stultz <john.stultz@linaro.org>
Date:   Fri Mar 22 12:08:52 2013 -0700

    ntp: Move timex validation to timekeeping do_adjtimex call.
    
    Move logic that does not need the ntp state to be done
    in the timekeeping do_adjtimex() call.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit aa6f9c595d857328e5d815e5b94c0e7cd31a6b59
Author: John Stultz <john.stultz@linaro.org>
Date:   Fri Mar 22 11:31:29 2013 -0700

    ntp: Move do_adjtimex() and hardpps() functions to timekeeping.c
    
    In preparation for changing the ntp locking rules, move
    do_adjtimex and hardpps accessor functions to timekeeping.c,
    but keep the code logic in ntp.c.
    
    This patch also introduces a ntp_internal.h file so timekeeping
    specific interfaces of ntp.c can be more limitedly shared with
    timekeeping.c.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 3ad735c406aa1b411dd55b354410f8751a9e16e5
Author: Ben Hutchings <bhutchings@solarflare.com>
Date:   Sat Dec 1 02:21:17 2012 +0000

    sfc: Fix timekeeping in efx_mcdi_poll()
    
    [ Upstream commit ebf98e797b4e26ad52ace1511a0b503ee60a6cd4 ]
    
    efx_mcdi_poll() uses get_seconds() to read the current time and to
    implement a polling timeout.  The use of this function was chosen
    partly because it could easily be replaced in a co-sim environment
    with a macro that read the simulated time.
    
    Unfortunately the real get_seconds() returns the system time (real
    time) which is subject to adjustment by e.g. ntpd.  If the system time
    is adjusted forward during a polled MCDI operation, the effective
    timeout can be shorter than the intended 10 seconds, resulting in a
    spurious failure.  It is also possible for a backward adjustment to
    delay detection of a areal failure.
    
    Use jiffies instead, and change MCDI_RPC_TIMEOUT to be denominated in
    jiffies.  Also correct rounding of the timeout: check time > finish
    (or rather time_after(time, finish)) and not time >= finish.
    
    Signed-off-by: Ben Hutchings <bhutchings@solarflare.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 16cec22e5099020edb0ba8b6ae8f1b011e2ec4d5
Author: Ben Hutchings <bhutchings@solarflare.com>
Date:   Sat Dec 1 02:21:17 2012 +0000

    sfc: Fix timekeeping in efx_mcdi_poll()
    
    [ Upstream commit ebf98e797b4e26ad52ace1511a0b503ee60a6cd4 ]
    
    efx_mcdi_poll() uses get_seconds() to read the current time and to
    implement a polling timeout.  The use of this function was chosen
    partly because it could easily be replaced in a co-sim environment
    with a macro that read the simulated time.
    
    Unfortunately the real get_seconds() returns the system time (real
    time) which is subject to adjustment by e.g. ntpd.  If the system time
    is adjusted forward during a polled MCDI operation, the effective
    timeout can be shorter than the intended 10 seconds, resulting in a
    spurious failure.  It is also possible for a backward adjustment to
    delay detection of a areal failure.
    
    Use jiffies instead, and change MCDI_RPC_TIMEOUT to be denominated in
    jiffies.  Also correct rounding of the timeout: check time > finish
    (or rather time_after(time, finish)) and not time >= finish.
    
    Signed-off-by: Ben Hutchings <bhutchings@solarflare.com>
    [bwh: Backported to 3.0: adjust context]
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 26af00506d193b3f2be779f46fe5fe7821b56a7a
Author: Ben Hutchings <bhutchings@solarflare.com>
Date:   Sat Dec 1 02:21:17 2012 +0000

    sfc: Fix timekeeping in efx_mcdi_poll()
    
    [ Upstream commit ebf98e797b4e26ad52ace1511a0b503ee60a6cd4 ]
    
    efx_mcdi_poll() uses get_seconds() to read the current time and to
    implement a polling timeout.  The use of this function was chosen
    partly because it could easily be replaced in a co-sim environment
    with a macro that read the simulated time.
    
    Unfortunately the real get_seconds() returns the system time (real
    time) which is subject to adjustment by e.g. ntpd.  If the system time
    is adjusted forward during a polled MCDI operation, the effective
    timeout can be shorter than the intended 10 seconds, resulting in a
    spurious failure.  It is also possible for a backward adjustment to
    delay detection of a areal failure.
    
    Use jiffies instead, and change MCDI_RPC_TIMEOUT to be denominated in
    jiffies.  Also correct rounding of the timeout: check time > finish
    (or rather time_after(time, finish)) and not time >= finish.
    
    Signed-off-by: Ben Hutchings <bhutchings@solarflare.com>
    [bwh: Backported to 3.2: adjust context]
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit dd5d70e869f960bde6376f4447fff59f16186cf5
Author: Fengguang Wu <fengguang.wu@intel.com>
Date:   Mon Mar 25 12:24:24 2013 -0700

    timekeeping: __timekeeping_set_tai_offset can be static
    
    Yet again, the kbuild test robot saves the day, noting
    I left out defining __timekeeping_set_tai_offset as
    static. It even sent me this patch.
    
    Reported-by: Fengguang Wu <fengguang.wu@intel.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 9a7a71b1d0968fc2bd602b7481cde1d4872e01ff
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Feb 21 22:51:38 2013 +0000

    timekeeping: Split timekeeper_lock into lock and seqcount
    
    We want to shorten the seqcount write hold time. So split the seqlock
    into a lock and a seqcount.
    
    Open code the seqwrite_lock in the places which matter and drop the
    sequence counter update where it's pointless.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    [jstultz: Merge fixups from CLOCK_TAI collisions]
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 7e40672d930b369c1984457233ec5557aa53bfb8
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Feb 21 22:51:37 2013 +0000

    timekeeping: Move lock out of timekeeper struct
    
    Make the lock a separate entity. Preparatory patch for shadow
    timekeeper structure.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    [Merged with CLOCK_TAI changes]
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit eb93e4d93093615c60cb7dd3dcb24e46bd7d62d4
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Feb 21 22:51:36 2013 +0000

    timekeeping: Make jiffies_lock internal
    
    Nothing outside of the timekeeping core needs that lock.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 23a9537a6999fce16f06ca61fc6cac52c8fbdc86
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Feb 21 22:51:36 2013 +0000

    timekeeping: Calc stuff once
    
    Calculate the cycle interval shifted value once. No functional change,
    just makes the code more readable.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 1ff3c9677bff7e468e0c487d0ffefe4e901d33f4
Author: John Stultz <john.stultz@linaro.org>
Date:   Thu May 3 12:43:40 2012 -0700

    timekeeping: Add CLOCK_TAI clockid
    
    This add a CLOCK_TAI clockid and the needed accessors.
    
    CC: Thomas Gleixner <tglx@linutronix.de>
    CC: Eric Dumazet <eric.dumazet@gmail.com>
    CC: Richard Cochran <richardcochran@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit cc244ddae6d4c6902ac9d7d64023534f8c44a7eb
Author: John Stultz <john.stultz@linaro.org>
Date:   Thu May 3 12:30:07 2012 -0700

    timekeeping: Move TAI managment into timekeeping core from ntp
    
    Currently NTP manages the TAI offset. Since there's plans for a
    CLOCK_TAI clockid, push the TAI management into the timekeeping
    core.
    
    CC: Thomas Gleixner <tglx@linutronix.de>
    CC: Eric Dumazet <eric.dumazet@gmail.com>
    CC: Richard Cochran <richardcochran@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit a382bf934449ddeb625167537ae81daa0211b477
Author: Frederic Weisbecker <fweisbec@gmail.com>
Date:   Tue Dec 18 18:24:35 2012 +0100

    nohz: Assign timekeeping duty to a CPU outside the full dynticks range
    
    This way the full nohz CPUs can safely run with the tick
    stopped with a guarantee that somebody else is taking
    care of the jiffies and GTOD progression.
    
    Once the duty is attributed to a CPU, it won't change. Also that
    CPU can't enter into dyntick idle mode or be hot unplugged.
    
    This may later be improved from a power consumption POV. At
    least we should be able to share the duty amongst all CPUs
    outside the full dynticks range. Then the duty could even be
    shared with full dynticks CPUs when those can't stop their
    tick for any reason.
    
    But let's start with that very simple approach first.
    
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Chris Metcalf <cmetcalf@tilera.com>
    Cc: Christoph Lameter <cl@linux.com>
    Cc: Geoff Levand <geoff@infradead.org>
    Cc: Gilad Ben Yossef <gilad@benyossef.com>
    Cc: Hakan Akkan <hakanakkan@gmail.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Kevin Hilman <khilman@linaro.org>
    Cc: Li Zhong <zhong@linux.vnet.ibm.com>
    Cc: Namhyung Kim <namhyung.kim@lge.com>
    Cc: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Cc: Paul Gortmaker <paul.gortmaker@windriver.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    [fix have_nohz_full_mask offcase]
    Signed-off-by: Steven Rostedt <rostedt@goodmis.org>

commit a831881be220358a1d28c5d95d69449fb6d623ca
Author: Frederic Weisbecker <fweisbec@gmail.com>
Date:   Tue Dec 18 17:32:19 2012 +0100

    nohz: Basic full dynticks interface
    
    For extreme usecases such as Real Time or HPC, having
    the ability to shutdown the tick when a single task runs
    on a CPU is a desired feature:
    
    * Reducing the amount of interrupts improves throughput
    for CPU-bound tasks. The CPU is less distracted from its
    real job, from an execution time and from the cache point
    of views.
    
    * This also improve latency response as we have less critical
    sections.
    
    Start with introducing a very simple interface to define
    full dynticks CPU: use a boot time option defined cpumask
    through the "nohz_extended=" kernel parameter. CPUs that
    are part of this range will have their tick shutdown
    whenever possible: provided they run a single task and
    they don't do kernel activity that require the periodic
    tick. These details will be later documented in
    Documentation/*
    
    An online CPU must be kept outside this range to handle the
    timekeeping.
    
    Suggested-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Chris Metcalf <cmetcalf@tilera.com>
    Cc: Christoph Lameter <cl@linux.com>
    Cc: Geoff Levand <geoff@infradead.org>
    Cc: Gilad Ben Yossef <gilad@benyossef.com>
    Cc: Hakan Akkan <hakanakkan@gmail.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Kevin Hilman <khilman@linaro.org>
    Cc: Li Zhong <zhong@linux.vnet.ibm.com>
    Cc: Namhyung Kim <namhyung.kim@lge.com>
    Cc: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Cc: Paul Gortmaker <paul.gortmaker@windriver.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>

commit e445cf1c4257cc0238d72e4129eb4739f46fd3de
Author: Feng Tang <feng.tang@intel.com>
Date:   Tue Mar 12 11:56:48 2013 +0800

    timekeeping: utilize the suspend-nonstop clocksource to count suspended time
    
    There are some new processors whose TSC clocksource won't stop during
    suspend. Currently, after system resumes, kernel will use persistent
    clock or RTC to compensate the sleep time, but with these nonstop
    clocksources, we could skip the special compensation from external
    sources, and just use current clocksource for time recounting.
    
    This can solve some time drift bugs caused by some not-so-accurate or
    error-prone RTC devices.
    
    The current way to count suspended time is first try to use the persistent
    clock, and then try the RTC if persistent clock can't be used. This
    patch will change the trying order to:
            suspend-nonstop clocksource -> persistent clock -> RTC
    
    When counting the sleep time with nonstop clocksource, use an accurate way
    suggested by Jason Gunthorpe to cover very large delta cycles.
    
    Signed-off-by: Feng Tang <feng.tang@intel.com>
    [jstultz: Small optimization, avoiding re-reading the clocksource]
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit c54fdbb2823d96b842d00c548e14dbc0dd37831d
Author: Feng Tang <feng.tang@intel.com>
Date:   Tue Mar 12 11:56:45 2013 +0800

    x86: Add cpu capability flag X86_FEATURE_NONSTOP_TSC_S3
    
    On some new Intel Atom processors (Penwell and Cloverview), there is
    a feature that the TSC won't stop in S3 state, say the TSC value
    won't be reset to 0 after resume. This feature makes TSC a more reliable
    clocksource and could benefit the timekeeping code during system
    suspend/resume cycle, so add a flag for it.
    
    Signed-off-by: Feng Tang <feng.tang@intel.com>
    [jstultz: Fix checkpatch warning]
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 7859e404ae73fe4f38b8cfc1af19ea82f153084e
Author: John Stultz <john.stultz@linaro.org>
Date:   Fri Feb 22 12:33:29 2013 -0800

    timekeeping: Use inject_offset in warp_clock
    
    When warping the clock (from a local time RTC), use
    timekeeping_inject_offset() to atomically add the offset.
    
    This avoids any minor time error caused by the delay between
    reading the time, and then setting the adjusted time.
    
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit c30bd09915ea243603d7803d53de890c4a6f1474
Author: Dong Zhu <bluezhudong@gmail.com>
Date:   Thu Dec 6 22:03:34 2012 +0800

    timekeeping: Avoid adjust kernel time once hwclock kept in UTC time
    
    If the Hardware Clock kept in local time,kernel will adjust the time
    to be UTC time.But if Hardware Clock kept in UTC time,system will make
    a dummy settimeofday call first (sys_tz.tz_minuteswest = 0) to make sure
    the time is not shifted,so at this point I think maybe it is not necessary
    to set the kernel time once the sys_tz.tz_minuteswest is zero.
    
    Signed-off-by: Dong Zhu <bluezhudong@gmail.com>
    [jstultz: Updated to merge with conflicting changes ]
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 7366b52c44b46c073a4bf1285ca09ca6ce5d9b39
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Feb 12 13:46:19 2013 -0800

    drivers/rtc/rtc-pl031.c: restore ST variant functionality
    
    commit 3399cfb5df9594495b876d1843a7165f77366b2b upstream.
    
    Commit e7e034e18a0a ("drivers/rtc/rtc-pl031.c: fix the missing operation
    on enable") accidentally broke the ST variants of PL031.
    
    The bit that is being poked as "clockwatch" enable bit for the ST
    variants does the work of bit 0 on this variant.  Bit 0 is used for a
    clock divider on the ST variants, and setting it to 1 will affect
    timekeeping in a very bad way.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Haojian Zhuang <haojian.zhuang@gmail.com>
    Cc: Mian Yousaf KAUKAB <mian.yousaf.kaukab@stericsson.com>
    Cc: Srinidhi Kasagar <srinidhi.kasagar@stericsson.com>
    Cc: Alessandro Zummo <a.zummo@towertech.it>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit 5e0b2704a1d5c246c8282303bbc952cba17f94fc
Author: Jonghwa Lee <jonghwa3.lee@samsung.com>
Date:   Thu Feb 21 16:45:07 2013 -0800

    rtc: max8997: add driver for max8997 rtc
    
    Add an rtc driver for Maxim 8997 multifunction chip.  Max8997 has rtc
    module in it.  and it can be used for timekeeping clock and system alarm.
    It provide various operational mode those are BCD/binary, 24/12hour,
    am/pm.  Driver sets binary/24/ for default.  Maxim 8997 also supports
    SMPL(Sudden Momentary Power Loss), WTSR (Watchdog Timeout and Software
    Reset).
    
    Signed-off-by: Jonghwa Lee <jonghwa3.lee@samsung.com>
    Cc: Devendra Naga <devendra.aaru@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit 266d7ad7f4fe2f44b91561f5b812115c1b3018ab
Merge: bcbd818c069b 36dfbbf136db
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Feb 19 19:05:45 2013 -0800

    Merge branch 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer changes from Ingo Molnar:
     "Main changes:
    
       - ntp: Add CONFIG_RTC_SYSTOHC: a generic RTC driver facility
         complementing the existing CONFIG_RTC_HCTOSYS, which uses NTP to
         keep the hardware clock updated.
    
       - posix-timers: Fix clock_adjtime to always return timex data on
         success.  This is changing the ABI, but no breakage was expected
         and found - caution is warranted nevertheless.
    
       - platform persistent clock improvements/cleanups.
    
       - clockevents: refactor timer broadcast handling to be more generic
         and less duplicated with matching architecture code (mostly ARM
         motivated.)
    
       - various fixes and cleanups"
    
    * 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      timers/x86/hpet: Use HPET_COUNTER to specify the hpet counter in vread_hpet()
      posix-cpu-timers: Fix nanosleep task_struct leak
      clockevents: Fix generic broadcast for FEAT_C3STOP
      time, Fix setting of hardware clock in NTP code
      hrtimer: Prevent hrtimer_enqueue_reprogram race
      clockevents: Add generic timer broadcast function
      clockevents: Add generic timer broadcast receiver
      timekeeping: Switch HAS_PERSISTENT_CLOCK to ALWAYS_USE_PERSISTENT_CLOCK
      x86/time/rtc: Don't print extended CMOS year when reading RTC
      x86: Select HAS_PERSISTENT_CLOCK on x86
      timekeeping: Add CONFIG_HAS_PERSISTENT_CLOCK option
      rtc: Skip the suspend/resume handling if persistent clock exist
      timekeeping: Add persistent_clock_exist flag
      posix-timers: Fix clock_adjtime to always return timex data on success
      Round the calculated scale factor in set_cyc2ns_scale()
      NTP: Add a CONFIG_RTC_SYSTOHC configuration
      MAINTAINERS: Update John Stultz's email
      time: create __getnstimeofday for WARNless calls

commit 047b1c0f49ea608e3ca0de2775957f061a0c2737
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Feb 12 13:46:19 2013 -0800

    drivers/rtc/rtc-pl031.c: restore ST variant functionality
    
    commit 3399cfb5df9594495b876d1843a7165f77366b2b upstream.
    
    Commit e7e034e18a0a ("drivers/rtc/rtc-pl031.c: fix the missing operation
    on enable") accidentally broke the ST variants of PL031.
    
    The bit that is being poked as "clockwatch" enable bit for the ST
    variants does the work of bit 0 on this variant.  Bit 0 is used for a
    clock divider on the ST variants, and setting it to 1 will affect
    timekeeping in a very bad way.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Haojian Zhuang <haojian.zhuang@gmail.com>
    Cc: Mian Yousaf KAUKAB <mian.yousaf.kaukab@stericsson.com>
    Cc: Srinidhi Kasagar <srinidhi.kasagar@stericsson.com>
    Cc: Alessandro Zummo <a.zummo@towertech.it>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 1e266629933bb3e40ac7db128f3b661f5bab56c1
Author: Vineet Gupta <vgupta@synopsys.com>
Date:   Wed Feb 6 15:09:13 2013 +0530

    ARC: 64bit RTSC timestamp hardware issue
    
    The 64bit RTSC is not reliable, causing spurious "jumps" in higher word,
    making Linux timekeeping go bonkers. So as of now just use the lower
    32bit timestamp.
    
    A cleaner approach would have been removing RTSC support altogether as the
    32bit RTSC is equivalent to old TIMER1 based solution, but some customers
    can use the 32bit RTSC in SMP syn fashion (vs. TIMER1 which being incore
    can't be done easily).
    
    A fallout of this is sched_clock()'s hardware assisted version needs to
    go away since it can't use 32bit wrapping counter - instead we use the
    generic "weak" jiffies based version.
    
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>

commit e9daff24a266307943457086533041bd971d0ef9
Author: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
Date:   Thu Feb 14 21:29:31 2013 -0500

    Revert "xen PVonHVM: use E820_Reserved area for shared_info"
    
    This reverts commit 9d02b43dee0d7fb18dfb13a00915550b1a3daa9f.
    
    We are doing this b/c on 32-bit PVonHVM with older hypervisors
    (Xen 4.1) it ends up bothing up the start_info. This is bad b/c
    we use it for the time keeping, and the timekeeping code loops
    forever - as the version field never changes. Olaf says to
    revert it, so lets do that.
    
    Acked-by: Olaf Hering <olaf@aepfle.de>
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>

commit 3399cfb5df9594495b876d1843a7165f77366b2b
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Feb 12 13:46:19 2013 -0800

    drivers/rtc/rtc-pl031.c: restore ST variant functionality
    
    Commit e7e034e18a0a ("drivers/rtc/rtc-pl031.c: fix the missing operation
    on enable") accidentally broke the ST variants of PL031.
    
    The bit that is being poked as "clockwatch" enable bit for the ST
    variants does the work of bit 0 on this variant.  Bit 0 is used for a
    clock divider on the ST variants, and setting it to 1 will affect
    timekeeping in a very bad way.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Haojian Zhuang <haojian.zhuang@gmail.com>
    Cc: Mian Yousaf KAUKAB <mian.yousaf.kaukab@stericsson.com>
    Cc: Srinidhi Kasagar <srinidhi.kasagar@stericsson.com>
    Cc: Alessandro Zummo <a.zummo@towertech.it>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit d8005e6b95268cbb50db3773d5f180c32a9434fe
Author: Vineet Gupta <vgupta@synopsys.com>
Date:   Fri Jan 18 15:12:18 2013 +0530

    ARC: Timers/counters/delay management
    
    ARC700 includes 2 in-core 32bit timers TIMER0 and TIMER1.
    Both have exactly same capabilies.
    
    * programmable to count from TIMER<n>_CNT to TIMER<n>_LIMIT
    * for count 0 and LIMIT ~1, provides a free-running counter by
        auto-wrapping when limit is reached.
    * optionally interrupt when LIMIT is reached (oneshot event semantics)
    * rearming the interrupt provides periodic semantics
    * run at CPU clk
    
    ARC Linux uses TIMER0 for clockevent (periodic/oneshot) and TIMER1 for
    clocksource (free-running clock).
    
    Newer cores provide RTSC insn which gives a 64bit cpu clk snapshot hence
    is more apt for clocksource when available.
    
    SMP poses a bit of challenge for global timekeeping clocksource /
    sched_clock() backend:
     -TIMER1 based local clocks are out-of-sync hence can't be used
      (thus we default to jiffies based cs as well as sched_clock() one/both
      of which platform can override with it's specific hardware assist)
     -RTSC is only allowed in SMP if it's cross-core-sync (Kconfig glue
      ensures that) and thus usable for both requirements.
    
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>

commit 8f0de0d62f29e47f5142737dad7561f108f69e92
Author: Santosh Shilimkar <santosh.shilimkar@ti.com>
Date:   Thu Jan 31 21:02:00 2013 +0530

    ARM: OMAP2+: Get rid of custom OMAP_32K_TIMER_HZ
    
    The timekeeping doesn't depend on HZ value in presence of fine grained
    clocksource and hence there should not be any time drift because of HZ
    value which was chosen to be divisor of 32768.
    
    OMAP has been using HZ = 128 value to avoid any time drift issues
    because of 32768 HZ clock. But with various measurements performed
    with HZ = 100, no time drift is observed and it also proves the
    point about HZ not having impact on time keeping on OMAP.
    
    Very informative thread on this topic is here:
            https://lkml.org/lkml/2013/1/29/435
    
    Special thanks to John Stulz, Arnd Bergmann and Russell King for their
    valuable suggestions.
    
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Tony Lindgren <tony@atomide.com>
    
    Signed-off-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Tested-by: Lokesh Vutla <lokeshvutla@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

commit 6f16eebe1ff82176339a0439c98ebec9768b0ee2
Author: John Stultz <john.stultz@linaro.org>
Date:   Fri Jan 25 17:08:12 2013 -0800

    timekeeping: Switch HAS_PERSISTENT_CLOCK to ALWAYS_USE_PERSISTENT_CLOCK
    
    Jason pointed out the HAS_PERSISTENT_CLOCK name isn't
    quite accurate for the config, as some systems may have
    the persistent_clock in some cases, but not always.
    
    So change the config name to the more clear
    ALWAYS_USE_PERSISTENT_CLOCK.
    
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 7806334afcaf4f0352a9c6f813264f5ef27d00f9
Author: Hector Palacios <hector.palacios@digi.com>
Date:   Mon Nov 14 11:15:25 2011 +0100

    timekeeping: add arch_offset hook to ktime_get functions
    
    commit d004e024058a0eaca097513ce62cbcf978913e0a upstream.
    
    ktime_get and ktime_get_ts were calling timekeeping_get_ns()
    but later they were not calling arch_gettimeoffset() so architectures
    using this mechanism returned 0 ns when calling these functions.
    
    This happened for example when running Busybox's ping which calls
    syscall(__NR_clock_gettime, CLOCK_MONOTONIC, ts) which eventually
    calls ktime_get. As a result the returned ping travel time was zero.
    
    Signed-off-by: Hector Palacios <hector.palacios@digi.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

commit 7d607e3f0b69385d5bad235de855aafd724a728f
Author: John Stultz <john.stultz@linaro.org>
Date:   Mon Sep 17 21:38:47 2012 -0400

    time: Move ktime_t overflow checking into timespec_valid_strict
    
    commit cee58483cf56e0ba355fdd97ff5e8925329aa936 upstream.
    
    Andreas Bombe reported that the added ktime_t overflow checking added to
    timespec_valid in commit 4e8b14526ca7 ("time: Improve sanity checking of
    timekeeping inputs") was causing problems with X.org because it caused
    timeouts larger then KTIME_T to be invalid.
    
    Previously, these large timeouts would be clamped to KTIME_MAX and would
    never expire, which is valid.
    
    This patch splits the ktime_t overflow checking into a new
    timespec_valid_strict function, and converts the timekeeping codes
    internal checking to use this more strict function.
    
    Reported-and-tested-by: Andreas Bombe <aeb@debian.org>
    Cc: Zhouping Liu <zliu@redhat.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Linux Kernel <linux-kernel@vger.kernel.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

commit b4e2564c9f5ba83af10076d029a7507b7a33b870
Author: John Stultz <john.stultz@linaro.org>
Date:   Mon Sep 17 21:38:46 2012 -0400

    time: Avoid making adjustments if we haven't accumulated anything
    
    commit bf2ac312195155511a0f79325515cbb61929898a upstream.
    
    If update_wall_time() is called and the current offset isn't large
    enough to accumulate, avoid re-calling timekeeping_adjust which may
    change the clock freq and can cause 1ns inconsistencies with
    CLOCK_REALTIME_COARSE/CLOCK_MONOTONIC_COARSE.
    
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Link: http://lkml.kernel.org/r/1345595449-34965-5-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Linux Kernel <linux-kernel@vger.kernel.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

commit 11ce0e7a9396b85a6f42cec5ec009d70d7b10652
Author: John Stultz <john.stultz@linaro.org>
Date:   Mon Sep 17 21:38:45 2012 -0400

    time: Improve sanity checking of timekeeping inputs
    
    commit 4e8b14526ca7fb046a81c94002c1c43b6fdf0e9b upstream.
    
    Unexpected behavior could occur if the time is set to a value large
    enough to overflow a 64bit ktime_t (which is something larger then the
    year 2262).
    
    Also unexpected behavior could occur if large negative offsets are
    injected via adjtimex.
    
    So this patch improves the sanity check timekeeping inputs by
    improving the timespec_valid() check, and then makes better use of
    timespec_valid() to make sure we don't set the time to an invalid
    negative value or one that overflows ktime_t.
    
    Note: This does not protect from setting the time close to overflowing
    ktime_t and then letting natural accumulation cause the overflow.
    
    Reported-by: CAI Qian <caiqian@redhat.com>
    Reported-by: Sasha Levin <levinsasha928@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Zhouping Liu <zliu@redhat.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Link: http://lkml.kernel.org/r/1344454580-17031-1-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Linux Kernel <linux-kernel@vger.kernel.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

commit 05ad717c77b1b8e98a1dd768c3700036d634629e
Author: Feng Tang <feng.tang@intel.com>
Date:   Wed Jan 16 00:09:49 2013 +0800

    timekeeping: Add CONFIG_HAS_PERSISTENT_CLOCK option
    
    Make the persistent clock check a kernel config option, so that some
    platform can explicitely select it, also make CONFIG_RTC_HCTOSYS and
    RTC_SYSTOHC depend on its non-existence, which could prevent the
    persistent clock and RTC code from doing similar thing twice during
    system's init/suspend/resume phases.
    
    If the CONFIG_HAS_PERSISTENT_CLOCK=n, then no change happens for kernel
    which still does the persistent clock check in timekeeping_init().
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Suggested-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Feng Tang <feng.tang@intel.com>
    [jstultz: Added dependency for RTC_SYSTOHC as well]
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 9ecf37eb7a81e3295a1b274eafb6f83d7d2cabf0
Author: Feng Tang <feng.tang@intel.com>
Date:   Wed Jan 16 00:09:48 2013 +0800

    rtc: Skip the suspend/resume handling if persistent clock exist
    
    All the RTC suspend and resume functions are to compensate the
    sleep time, but this is already done in timekeeping.c if persistent
    clock exist.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Alessandro Zummo <a.zummo@towertech.it>
    Cc: Arve Hjønnevåg <arve@android.com>
    Signed-off-by: Feng Tang <feng.tang@intel.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 31ade30692dc9680bfc95700d794818fa3f754ac
Author: Feng Tang <feng.tang@intel.com>
Date:   Wed Jan 16 00:09:47 2013 +0800

    timekeeping: Add persistent_clock_exist flag
    
    In current kernel, there are several places which need to check
    whether there is a persistent clock for the platform. Current check
    is done by calling the read_persistent_clock() and validating its
    return value.
    
    So one optimization is to do the check only once in timekeeping_init(),
    and use a flag persistent_clock_exist to record it.
    
    v2: Add a has_persistent_clock() helper function, as suggested by John.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Feng Tang <feng.tang@intel.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit b64c5fda3868cb29d5dae0909561aa7d93fb7330
Merge: f57d54bab696 9c3f9e281697
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Dec 11 18:22:46 2012 -0800

    Merge branch 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull core timer changes from Ingo Molnar:
     "It contains continued generic-NOHZ work by Frederic and smaller
      cleanups."
    
    * 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      time: Kill xtime_lock, replacing it with jiffies_lock
      clocksource: arm_generic: use this_cpu_ptr per-cpu helper
      clocksource: arm_generic: use integer math helpers
      time/jiffies: Make clocksource_jiffies static
      clocksource: clean up parse_pmtmr()
      tick: Correct the comments for tick_sched_timer()
      tick: Conditionally build nohz specific code in tick handler
      tick: Consolidate tick handling for high and low res handlers
      tick: Consolidate timekeeping handling code

commit 1103ef8e70a1725b7fd9e0cb18a8b1edb6e5c42d
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Tue Oct 9 10:18:23 2012 +0300

    timekeeping: Cast raw_interval to u64 to avoid shift overflow
    
    commit 5b3900cd409466c0070b234d941650685ad0c791 upstream.
    
    We fixed a bunch of integer overflows in timekeeping code during the 3.6
    cycle.  I did an audit based on that and found this potential overflow.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Acked-by: John Stultz <johnstul@us.ibm.com>
    Link: http://lkml.kernel.org/r/20121009071823.GA19159@elgon.mountain
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ben Hutchings <ben@decadent.org.uk>
    [ herton: adapt for 3.5, timekeeper instead of tk pointer ]
    Signed-off-by: Herton Ronaldo Krzesinski <herton.krzesinski@canonical.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit ebf98e797b4e26ad52ace1511a0b503ee60a6cd4
Author: Ben Hutchings <bhutchings@solarflare.com>
Date:   Sat Dec 1 02:21:17 2012 +0000

    sfc: Fix timekeeping in efx_mcdi_poll()
    
    efx_mcdi_poll() uses get_seconds() to read the current time and to
    implement a polling timeout.  The use of this function was chosen
    partly because it could easily be replaced in a co-sim environment
    with a macro that read the simulated time.
    
    Unfortunately the real get_seconds() returns the system time (real
    time) which is subject to adjustment by e.g. ntpd.  If the system time
    is adjusted forward during a polled MCDI operation, the effective
    timeout can be shorter than the intended 10 seconds, resulting in a
    spurious failure.  It is also possible for a backward adjustment to
    delay detection of a areal failure.
    
    Use jiffies instead, and change MCDI_RPC_TIMEOUT to be denominated in
    jiffies.  Also correct rounding of the timeout: check time > finish
    (or rather time_after(time, finish)) and not time >= finish.
    
    Signed-off-by: Ben Hutchings <bhutchings@solarflare.com>

commit d6ad418763888f617ac5b4849823e4cd670df1dd
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Feb 28 16:50:11 2012 -0800

    time: Kill xtime_lock, replacing it with jiffies_lock
    
    Now that timekeeping is protected by its own locks, rename
    the xtime_lock to jifffies_lock to better describe what it
    protects.
    
    CC: Thomas Gleixner <tglx@linutronix.de>
    CC: Eric Dumazet <eric.dumazet@gmail.com>
    CC: Richard Cochran <richardcochran@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 20e6199e93250b6a6506f65c07e18fb18ad382ab
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Tue Oct 9 10:18:23 2012 +0300

    timekeeping: Cast raw_interval to u64 to avoid shift overflow
    
    commit 5b3900cd409466c0070b234d941650685ad0c791 upstream.
    
    We fixed a bunch of integer overflows in timekeeping code during the 3.6
    cycle.  I did an audit based on that and found this potential overflow.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Acked-by: John Stultz <johnstul@us.ibm.com>
    Link: http://lkml.kernel.org/r/20121009071823.GA19159@elgon.mountain
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    [bwh: Backported to 3.2: adjust context; use timekeeper.raw_interval]
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit d6168c18c127871be6a54c63f9d54c87d74dcfbc
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Tue Oct 9 10:18:23 2012 +0300

    timekeeping: Cast raw_interval to u64 to avoid shift overflow
    
    commit 5b3900cd409466c0070b234d941650685ad0c791 upstream.
    
    We fixed a bunch of integer overflows in timekeeping code during the 3.6
    cycle.  I did an audit based on that and found this potential overflow.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Acked-by: John Stultz <johnstul@us.ibm.com>
    Link: http://lkml.kernel.org/r/20121009071823.GA19159@elgon.mountain
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 5bb962269c29cbb878414cddf0ebdff8c5cdef0a
Author: Frederic Weisbecker <fweisbec@gmail.com>
Date:   Mon Oct 15 02:03:27 2012 +0200

    tick: Consolidate timekeeping handling code
    
    Unify the duplicated timekeeping handling code of low and high res tick
    sched handlers.
    
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>

commit 03d3602a833715f83ea53b9feb078b9c4c5f6c1a
Merge: 0588f1f93479 5b3900cd4094
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Oct 12 22:17:48 2012 +0900

    Merge branch 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer core update from Thomas Gleixner:
     - Bug fixes (one for a longstanding dead loop issue)
     - Rework of time related vsyscalls
     - Alarm timer updates
     - Jiffies updates to remove compile time dependencies
    
    * 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      timekeeping: Cast raw_interval to u64 to avoid shift overflow
      timers: Fix endless looping between cascade() and internal_add_timer()
      time/jiffies: bring back unconditional LATCH definition
      time: Convert x86_64 to using new update_vsyscall
      time: Only do nanosecond rounding on GENERIC_TIME_VSYSCALL_OLD systems
      time: Introduce new GENERIC_TIME_VSYSCALL
      time: Convert CONFIG_GENERIC_TIME_VSYSCALL to CONFIG_GENERIC_TIME_VSYSCALL_OLD
      time: Move update_vsyscall definitions to timekeeper_internal.h
      time: Move timekeeper structure to timekeeper_internal.h for vsyscall changes
      jiffies: Remove compile time assumptions about CLOCK_TICK_RATE
      jiffies: Kill unused TICK_USEC_TO_NSEC
      alarmtimer: Rename alarmtimer_remove to alarmtimer_dequeue
      alarmtimer: Remove unused helpers & defines
      alarmtimer: Use hrtimer per-alarm instead of per-base
      alarmtimer: Implement minimum alarm interval for allowing suspend

commit 5b3900cd409466c0070b234d941650685ad0c791
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Tue Oct 9 10:18:23 2012 +0300

    timekeeping: Cast raw_interval to u64 to avoid shift overflow
    
    We fixed a bunch of integer overflows in timekeeping code during the 3.6
    cycle.  I did an audit based on that and found this potential overflow.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Acked-by: John Stultz <johnstul@us.ibm.com>
    Link: http://lkml.kernel.org/r/20121009071823.GA19159@elgon.mountain
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org

commit 0f467fcfbdfbad2a9b1f06dd15729fd22b461bf0
Author: John Stultz <john.stultz@linaro.org>
Date:   Mon Sep 17 22:32:10 2012 -0400

    time: Move ktime_t overflow checking into timespec_valid_strict
    
    This is a -stable backport of cee58483cf56e0ba355fdd97ff5e8925329aa936
    
    Andreas Bombe reported that the added ktime_t overflow checking added to
    timespec_valid in commit 4e8b14526ca7 ("time: Improve sanity checking of
    timekeeping inputs") was causing problems with X.org because it caused
    timeouts larger then KTIME_T to be invalid.
    
    Previously, these large timeouts would be clamped to KTIME_MAX and would
    never expire, which is valid.
    
    This patch splits the ktime_t overflow checking into a new
    timespec_valid_strict function, and converts the timekeeping codes
    internal checking to use this more strict function.
    
    Reported-and-tested-by: Andreas Bombe <aeb@debian.org>
    Cc: Zhouping Liu <zliu@redhat.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Linux Kernel <linux-kernel@vger.kernel.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Willy Tarreau <w@1wt.eu>

commit 61b76840ddee647c0c223365378c3f394355b7d7
Author: John Stultz <john.stultz@linaro.org>
Date:   Mon Sep 17 22:32:09 2012 -0400

    time: Avoid making adjustments if we haven't accumulated anything
    
    This is a -stable backport of bf2ac312195155511a0f79325515cbb61929898a
    
    If update_wall_time() is called and the current offset isn't large
    enough to accumulate, avoid re-calling timekeeping_adjust which may
    change the clock freq and can cause 1ns inconsistencies with
    CLOCK_REALTIME_COARSE/CLOCK_MONOTONIC_COARSE.
    
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: stable@vger.kernel.org
    Link: http://lkml.kernel.org/r/1345595449-34965-5-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Linux Kernel <linux-kernel@vger.kernel.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Willy Tarreau <w@1wt.eu>

commit 436b6be6cb5bbffb227b5a414e7a1c03fe941b43
Author: John Stultz <john.stultz@linaro.org>
Date:   Mon Sep 17 22:32:08 2012 -0400

    time: Improve sanity checking of timekeeping inputs
    
    This is a -stable backport of 4e8b14526ca7fb046a81c94002c1c43b6fdf0e9b
    
    Unexpected behavior could occur if the time is set to a value large
    enough to overflow a 64bit ktime_t (which is something larger then the
    year 2262).
    
    Also unexpected behavior could occur if large negative offsets are
    injected via adjtimex.
    
    So this patch improves the sanity check timekeeping inputs by
    improving the timespec_valid() check, and then makes better use of
    timespec_valid() to make sure we don't set the time to an invalid
    negative value or one that overflows ktime_t.
    
    Note: This does not protect from setting the time close to overflowing
    ktime_t and then letting natural accumulation cause the overflow.
    
    Reported-by: CAI Qian <caiqian@redhat.com>
    Reported-by: Sasha Levin <levinsasha928@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Zhouping Liu <zliu@redhat.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: stable@vger.kernel.org
    Link: http://lkml.kernel.org/r/1344454580-17031-1-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Linux Kernel <linux-kernel@vger.kernel.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Willy Tarreau <w@1wt.eu>

commit dfc4098e83abd567a4f4f17c2d20869cadcf9509
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jul 17 18:05:35 2012 -0400

    timekeeping: Add missing update call in timekeeping_resume()
    
    This is a backport of 3e997130bd2e8c6f5aaa49d6e3161d4d29b43ab0
    
    The leap second rework unearthed another issue of inconsistent data.
    
    On timekeeping_resume() the timekeeper data is updated, but nothing
    calls timekeeping_update(), so now the update code in the timer
    interrupt sees stale values.
    
    This has been the case before those changes, but then the timer
    interrupt was using stale data as well so this went unnoticed for quite
    some time.
    
    Add the missing update call, so all the data is consistent everywhere.
    
    Reported-by: Andreas Schwab <schwab@linux-m68k.org>
    Reported-and-tested-by: "Rafael J. Wysocki" <rjw@sisk.pl>
    Reported-and-tested-by: Martin Steigerwald <Martin@lichtvoll.de>
    Cc: LKML <linux-kernel@vger.kernel.org>
    Cc: Linux PM list <linux-pm@vger.kernel.org>
    Cc: John Stultz <johnstul@us.ibm.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>,
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Linux Kernel <linux-kernel@vger.kernel.org>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Willy Tarreau <w@1wt.eu>

commit 22539a28b0a97e84f74f716fe42d61dd07612d2d
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jul 17 18:05:33 2012 -0400

    timekeeping: Provide hrtimer update function
    
    This is a backport of f6c06abfb3972ad4914cef57d8348fcb2932bc3b
    
    To finally fix the infamous leap second issue and other race windows
    caused by functions which change the offsets between the various time
    bases (CLOCK_MONOTONIC, CLOCK_REALTIME and CLOCK_BOOTTIME) we need a
    function which atomically gets the current monotonic time and updates
    the offsets of CLOCK_REALTIME and CLOCK_BOOTTIME with minimalistic
    overhead. The previous patch which provides ktime_t offsets allows us
    to make this function almost as cheap as ktime_get() which is going to
    be replaced in hrtimer_interrupt().
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Ingo Molnar <mingo@kernel.org>
    Acked-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Acked-by: Prarit Bhargava <prarit@redhat.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Link: http://lkml.kernel.org/r/1341960205-56738-7-git-send-email-johnstul@us.ibm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Linux Kernel <linux-kernel@vger.kernel.org>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Willy Tarreau <w@1wt.eu>

commit c2358cf4165eeac6eacd6017c4419b33cacb0418
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jul 17 18:05:31 2012 -0400

    timekeeping: Maintain ktime_t based offsets for hrtimers
    
    This is a backport of 5b9fe759a678e05be4937ddf03d50e950207c1c0
    
    We need to update the hrtimer clock offsets from the hrtimer interrupt
    context. To avoid conversions from timespec to ktime_t maintain a
    ktime_t based representation of those offsets in the timekeeper. This
    puts the conversion overhead into the code which updates the
    underlying offsets and provides fast accessible values in the hrtimer
    interrupt.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Reviewed-by: Ingo Molnar <mingo@kernel.org>
    Acked-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Acked-by: Prarit Bhargava <prarit@redhat.com>
    Cc: stable@vger.kernel.org
    Link: http://lkml.kernel.org/r/1341960205-56738-4-git-send-email-johnstul@us.ibm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Linux Kernel <linux-kernel@vger.kernel.org>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Willy Tarreau <w@1wt.eu>

commit d155586fe34db9fc8d247a681c6524c7d75dd863
Author: John Stultz <johnstul@us.ibm.com>
Date:   Tue Jul 17 18:05:30 2012 -0400

    timekeeping: Fix leapsecond triggered load spike issue
    
    This is a backport of 4873fa070ae84a4115f0b3c9dfabc224f1bc7c51
    
    The timekeeping code misses an update of the hrtimer subsystem after a
    leap second happened. Due to that timers based on CLOCK_REALTIME are
    either expiring a second early or late depending on whether a leap
    second has been inserted or deleted until an operation is initiated
    which causes that update. Unless the update happens by some other
    means this discrepancy between the timekeeping and the hrtimer data
    stays forever and timers are expired either early or late.
    
    The reported immediate workaround - $ data -s "`date`" - is causing a
    call to clock_was_set() which updates the hrtimer data structures.
    See: http://www.sheeri.com/content/mysql-and-leap-second-high-cpu-and-fix
    
    Add the missing clock_was_set() call to update_wall_time() in case of
    a leap second event. The actual update is deferred to softirq context
    as the necessary smp function call cannot be invoked from hard
    interrupt context.
    
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Reported-by: Jan Engelhardt <jengelh@inai.de>
    Reviewed-by: Ingo Molnar <mingo@kernel.org>
    Acked-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Acked-by: Prarit Bhargava <prarit@redhat.com>
    Cc: stable@vger.kernel.org
    Link: http://lkml.kernel.org/r/1341960205-56738-3-git-send-email-johnstul@us.ibm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Linux Kernel <linux-kernel@vger.kernel.org>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Willy Tarreau <w@1wt.eu>

commit 40821c765eb339c04407c7382c9edbb8a7d340e3
Author: John Stultz <johnstul@us.ibm.com>
Date:   Tue Jul 17 18:05:29 2012 -0400

    hrtimer: Provide clock_was_set_delayed()
    
    This is a backport of f55a6faa384304c89cfef162768e88374d3312cb
    
    clock_was_set() cannot be called from hard interrupt context because
    it calls on_each_cpu().
    
    For fixing the widely reported leap seconds issue it is necessary to
    call it from hard interrupt context, i.e. the timer tick code, which
    does the timekeeping updates.
    
    Provide a new function which denotes it in the hrtimer cpu base
    structure of the cpu on which it is called and raise the hrtimer
    softirq. We then execute the clock_was_set() notificiation from
    softirq context in run_hrtimer_softirq(). The hrtimer softirq is
    rarely used, so polling the flag there is not a performance issue.
    
    [ tglx: Made it depend on CONFIG_HIGH_RES_TIMERS. We really should get
      rid of all this ifdeffery ASAP ]
    
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Reported-by: Jan Engelhardt <jengelh@inai.de>
    Reviewed-by: Ingo Molnar <mingo@kernel.org>
    Acked-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Acked-by: Prarit Bhargava <prarit@redhat.com>
    Cc: stable@vger.kernel.org
    Link: http://lkml.kernel.org/r/1341960205-56738-2-git-send-email-johnstul@us.ibm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Linux Kernel <linux-kernel@vger.kernel.org>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Willy Tarreau <w@1wt.eu>

commit af54f209dc49a5251f7b22646190d7193356bf02
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Jul 17 18:05:27 2012 -0400

    timekeeping: Fix CLOCK_MONOTONIC inconsistency during leapsecond
    
    This is a backport of fad0c66c4bb836d57a5f125ecd38bed653ca863a
    which resolves a bug the previous commit.
    
    Commit 6b43ae8a61 (ntp: Fix leap-second hrtimer livelock) broke the
    leapsecond update of CLOCK_MONOTONIC. The missing leapsecond update to
    wall_to_monotonic causes discontinuities in CLOCK_MONOTONIC.
    
    Adjust wall_to_monotonic when NTP inserted a leapsecond.
    
    Reported-by: Richard Cochran <richardcochran@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Tested-by: Richard Cochran <richardcochran@gmail.com>
    Link: http://lkml.kernel.org/r/1338400497-12420-1-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Linux Kernel <linux-kernel@vger.kernel.org>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Willy Tarreau <w@1wt.eu>

commit 4eb34389b35064542b62099a14a51a43cf49598c
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Sep 11 14:56:21 2012 -0400

    time: Move ktime_t overflow checking into timespec_valid_strict
    
    commit cee58483cf56e0ba355fdd97ff5e8925329aa936 upstream.
    
    Andreas Bombe reported that the added ktime_t overflow checking added to
    timespec_valid in commit 4e8b14526ca7 ("time: Improve sanity checking of
    timekeeping inputs") was causing problems with X.org because it caused
    timeouts larger then KTIME_T to be invalid.
    
    Previously, these large timeouts would be clamped to KTIME_MAX and would
    never expire, which is valid.
    
    This patch splits the ktime_t overflow checking into a new
    timespec_valid_strict function, and converts the timekeeping codes
    internal checking to use this more strict function.
    
    Reported-and-tested-by: Andreas Bombe <aeb@debian.org>
    Cc: Zhouping Liu <zliu@redhat.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 4e64f897ce0d333d574143c0a23b1299d6137b4a
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Sep 11 14:56:20 2012 -0400

    time: Avoid making adjustments if we haven't accumulated anything
    
    commit bf2ac312195155511a0f79325515cbb61929898a upstream.
    
    If update_wall_time() is called and the current offset isn't large
    enough to accumulate, avoid re-calling timekeeping_adjust which may
    change the clock freq and can cause 1ns inconsistencies with
    CLOCK_REALTIME_COARSE/CLOCK_MONOTONIC_COARSE.
    
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: stable@vger.kernel.org
    Link: http://lkml.kernel.org/r/1345595449-34965-5-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 7df3d033efb005c6018512933078566cd6f49463
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Sep 11 14:56:19 2012 -0400

    time: Improve sanity checking of timekeeping inputs
    
    commit 4e8b14526ca7fb046a81c94002c1c43b6fdf0e9b upstream.
    
    Unexpected behavior could occur if the time is set to a value large
    enough to overflow a 64bit ktime_t (which is something larger then the
    year 2262).
    
    Also unexpected behavior could occur if large negative offsets are
    injected via adjtimex.
    
    So this patch improves the sanity check timekeeping inputs by
    improving the timespec_valid() check, and then makes better use of
    timespec_valid() to make sure we don't set the time to an invalid
    negative value or one that overflows ktime_t.
    
    Note: This does not protect from setting the time close to overflowing
    ktime_t and then letting natural accumulation cause the overflow.
    
    Reported-by: CAI Qian <caiqian@redhat.com>
    Reported-by: Sasha Levin <levinsasha928@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Zhouping Liu <zliu@redhat.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Link: http://lkml.kernel.org/r/1344454580-17031-1-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 9a227fcb842a03fce5b8a6da0da40f5601ec6908
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Sep 11 15:04:19 2012 -0400

    time: Move ktime_t overflow checking into timespec_valid_strict
    
    commit cee58483cf56e0ba355fdd97ff5e8925329aa936 upstream
    
    Andreas Bombe reported that the added ktime_t overflow checking added to
    timespec_valid in commit 4e8b14526ca7 ("time: Improve sanity checking of
    timekeeping inputs") was causing problems with X.org because it caused
    timeouts larger then KTIME_T to be invalid.
    
    Previously, these large timeouts would be clamped to KTIME_MAX and would
    never expire, which is valid.
    
    This patch splits the ktime_t overflow checking into a new
    timespec_valid_strict function, and converts the timekeeping codes
    internal checking to use this more strict function.
    
    Reported-and-tested-by: Andreas Bombe <aeb@debian.org>
    Cc: Zhouping Liu <zliu@redhat.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 80257cbe62ea0919153c43421746269ab68473bf
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Sep 11 15:04:18 2012 -0400

    time: Avoid making adjustments if we haven't accumulated anything
    
    commit bf2ac312195155511a0f79325515cbb61929898a upstream.
    
    If update_wall_time() is called and the current offset isn't large
    enough to accumulate, avoid re-calling timekeeping_adjust which may
    change the clock freq and can cause 1ns inconsistencies with
    CLOCK_REALTIME_COARSE/CLOCK_MONOTONIC_COARSE.
    
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Link: http://lkml.kernel.org/r/1345595449-34965-5-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 8e878154f5658ba93cf9bb2b491a930ec195de3d
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Sep 11 15:04:17 2012 -0400

    time: Improve sanity checking of timekeeping inputs
    
    commit 4e8b14526ca7fb046a81c94002c1c43b6fdf0e9b upstream.
    
    Unexpected behavior could occur if the time is set to a value large
    enough to overflow a 64bit ktime_t (which is something larger then the
    year 2262).
    
    Also unexpected behavior could occur if large negative offsets are
    injected via adjtimex.
    
    So this patch improves the sanity check timekeeping inputs by
    improving the timespec_valid() check, and then makes better use of
    timespec_valid() to make sure we don't set the time to an invalid
    negative value or one that overflows ktime_t.
    
    Note: This does not protect from setting the time close to overflowing
    ktime_t and then letting natural accumulation cause the overflow.
    
    Reported-by: CAI Qian <caiqian@redhat.com>
    Reported-by: Sasha Levin <levinsasha928@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Zhouping Liu <zliu@redhat.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Link: http://lkml.kernel.org/r/1344454580-17031-1-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit fe979e2c0aa6e5b9157c3b381b43de2ca6965d7e
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Sep 11 20:49:53 2012 -0400

    time: Move ktime_t overflow checking into timespec_valid_strict
    
    commit cee58483cf56e0ba355fdd97ff5e8925329aa936 upstream
    
    Andreas Bombe reported that the added ktime_t overflow checking added to
    timespec_valid in commit 4e8b14526ca7 ("time: Improve sanity checking of
    timekeeping inputs") was causing problems with X.org because it caused
    timeouts larger then KTIME_T to be invalid.
    
    Previously, these large timeouts would be clamped to KTIME_MAX and would
    never expire, which is valid.
    
    This patch splits the ktime_t overflow checking into a new
    timespec_valid_strict function, and converts the timekeeping codes
    internal checking to use this more strict function.
    
    Reported-and-tested-by: Andreas Bombe <aeb@debian.org>
    Cc: Zhouping Liu <zliu@redhat.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 4ffa9a8069801e36e2aceed5a77482b8b0841757
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Sep 11 20:49:52 2012 -0400

    time: Avoid making adjustments if we haven't accumulated anything
    
    commit bf2ac312195155511a0f79325515cbb61929898a upstream
    
    If update_wall_time() is called and the current offset isn't large
    enough to accumulate, avoid re-calling timekeeping_adjust which may
    change the clock freq and can cause 1ns inconsistencies with
    CLOCK_REALTIME_COARSE/CLOCK_MONOTONIC_COARSE.
    
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Link: http://lkml.kernel.org/r/1345595449-34965-5-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 44fa9a0111168832510f8add6d589e73eac6793d
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Sep 11 20:49:51 2012 -0400

    time: Improve sanity checking of timekeeping inputs
    
    commit 4e8b14526ca7fb046a81c94002c1c43b6fdf0e9b upstream
    
    Unexpected behavior could occur if the time is set to a value large
    enough to overflow a 64bit ktime_t (which is something larger then the
    year 2262).
    
    Also unexpected behavior could occur if large negative offsets are
    injected via adjtimex.
    
    So this patch improves the sanity check timekeeping inputs by
    improving the timespec_valid() check, and then makes better use of
    timespec_valid() to make sure we don't set the time to an invalid
    negative value or one that overflows ktime_t.
    
    Note: This does not protect from setting the time close to overflowing
    ktime_t and then letting natural accumulation cause the overflow.
    
    Reported-by: CAI Qian <caiqian@redhat.com>
    Reported-by: Sasha Levin <levinsasha928@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Zhouping Liu <zliu@redhat.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Link: http://lkml.kernel.org/r/1344454580-17031-1-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit b3c869d35b9b014f63ac0beacd31c57372084d01
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Sep 4 12:42:27 2012 -0400

    jiffies: Remove compile time assumptions about CLOCK_TICK_RATE
    
    CLOCK_TICK_RATE is used to accurately caclulate exactly how
    a tick will be at a given HZ.
    
    This is useful, because while we'd expect NSEC_PER_SEC/HZ,
    the underlying hardware will have some granularity limit,
    so we won't be able to have exactly HZ ticks per second.
    
    This slight error can cause timekeeping quality problems
    when using the jiffies or other jiffies driven clocksources.
    Thus we currently use compile time CLOCK_TICK_RATE value to
    generate SHIFTED_HZ and NSEC_PER_JIFFIES, which we then use
    to adjust the jiffies clocksource to correct this error.
    
    Unfortunately though, since CLOCK_TICK_RATE is a compile
    time value, and the jiffies clocksource is registered very
    early during boot, there are a number of cases where there
    are different possible hardware timers that have different
    tick rates. This causes problems in cases like ARM where
    there are numerous different types of hardware, each having
    their own compile-time CLOCK_TICK_RATE, making it hard to
    accurately support different hardware with a single kernel.
    
    For the most part, this doesn't matter all that much, as not
    too many systems actually utilize the jiffies or jiffies driven
    clocksource. Usually there are other highres clocksources
    who's granularity error is negligable.
    
    Even so, we have some complicated calcualtions that we do
    everywhere to handle these edge cases.
    
    This patch removes the compile time SHIFTED_HZ value, and
    introduces a register_refined_jiffies() function. This results
    in the default jiffies clock as being assumed a perfect HZ
    freq, and allows archtectures that care about jiffies accuracy
    to call register_refined_jiffies() with the tick rate, specified
    dynamically at boot.
    
    This allows us, where necessary, to not have a compile time
    CLOCK_TICK_RATE constant, simplifies the jiffies code, and
    still provides a way to have an accurate jiffies clock.
    
    NOTE: Since this patch does not add register_refinied_jiffies()
    calls for every arch, it may cause time quality regressions
    in some cases. Its likely these will not be noticable, but
    if they are an issue, adding the following to the end of
    setup_arch() should resolve the regression:
            register_refinied_jiffies(CLOCK_TICK_RATE)
    
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 519b3b742d7d29c3386f0f35f3cee5dd362dd8e2
Merge: 18f5600ba262 ec145babe754
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Sep 21 14:25:46 2012 -0700

    Merge branch 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer fix from Ingo Molnar:
     "One more timekeeping fix for v3.6"
    
    * 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      time: Fix timeekeping_get_ns overflow on 32bit systems

commit 63180c8a56b254148c28762b200139dcaf92a73d
Author: John Stultz <john.stultz@linaro.org>
Date:   Fri Aug 31 13:30:06 2012 -0400

    time: Move ktime_t overflow checking into timespec_valid_strict
    
    This is a -stable backport of cee58483cf56e0ba355fdd97ff5e8925329aa936
    
    Andreas Bombe reported that the added ktime_t overflow checking added to
    timespec_valid in commit 4e8b14526ca7 ("time: Improve sanity checking of
    timekeeping inputs") was causing problems with X.org because it caused
    timeouts larger then KTIME_T to be invalid.
    
    Previously, these large timeouts would be clamped to KTIME_MAX and would
    never expire, which is valid.
    
    This patch splits the ktime_t overflow checking into a new
    timespec_valid_strict function, and converts the timekeeping codes
    internal checking to use this more strict function.
    
    Reported-and-tested-by: Andreas Bombe <aeb@debian.org>
    Cc: Zhouping Liu <zliu@redhat.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Linux Kernel <linux-kernel@vger.kernel.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit cfb06dcbc0a63430195cfb70b56bd58311414878
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Aug 21 20:30:49 2012 -0400

    time: Avoid making adjustments if we haven't accumulated anything
    
    This is a -stable backport of bf2ac312195155511a0f79325515cbb61929898a
    
    If update_wall_time() is called and the current offset isn't large
    enough to accumulate, avoid re-calling timekeeping_adjust which may
    change the clock freq and can cause 1ns inconsistencies with
    CLOCK_REALTIME_COARSE/CLOCK_MONOTONIC_COARSE.
    
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Link: http://lkml.kernel.org/r/1345595449-34965-5-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Linux Kernel <linux-kernel@vger.kernel.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 8dd006cdafa7c955f6f4c66d25564d90aa29af1d
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Aug 8 15:36:20 2012 -0400

    time: Improve sanity checking of timekeeping inputs
    
    This is a -stable backport of 4e8b14526ca7fb046a81c94002c1c43b6fdf0e9b
    
    Unexpected behavior could occur if the time is set to a value large
    enough to overflow a 64bit ktime_t (which is something larger then the
    year 2262).
    
    Also unexpected behavior could occur if large negative offsets are
    injected via adjtimex.
    
    So this patch improves the sanity check timekeeping inputs by
    improving the timespec_valid() check, and then makes better use of
    timespec_valid() to make sure we don't set the time to an invalid
    negative value or one that overflows ktime_t.
    
    Note: This does not protect from setting the time close to overflowing
    ktime_t and then letting natural accumulation cause the overflow.
    
    Reported-by: CAI Qian <caiqian@redhat.com>
    Reported-by: Sasha Levin <levinsasha928@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Zhouping Liu <zliu@redhat.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Link: http://lkml.kernel.org/r/1344454580-17031-1-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Linux Kernel <linux-kernel@vger.kernel.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 00e8b2613331042bbe0177e5b9bb5c8a654b14ae
Merge: 5698bd757d55 feb70af0e3ac
Author: Rafael J. Wysocki <rjw@rjwysocki.net>
Date:   Mon Sep 17 20:25:18 2012 +0200

    Merge branch 'pm-timers'
    
    * pm-timers:
      PM: Do not use the syscore flag for runtime PM
      sh: MTU2: Basic runtime PM support
      sh: CMT: Basic runtime PM support
      sh: TMU: Basic runtime PM support
      PM / Domains: Do not measure start time for "irq safe" devices
      PM / Domains: Move syscore flag from subsys data to struct device
      PM / Domains: Rename the always_on device flag to syscore
      PM / Runtime: Allow helpers to be called by early platform drivers
      PM: Reorganize device PM initialization
      sh: MTU2: Introduce clock events suspend/resume routines
      sh: CMT: Introduce clocksource/clock events suspend/resume routines
      sh: TMU: Introduce clocksource/clock events suspend/resume routines
      timekeeping: Add suspend and resume of clock event devices
      PM / Domains: Add power off/on function for system core suspend stage
      PM / Domains: Introduce simplified power on routine for system resume

commit ec145babe754f9ea1079034a108104b6001e001c
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Sep 11 19:26:03 2012 -0400

    time: Fix timeekeping_get_ns overflow on 32bit systems
    
    Daniel Lezcano reported seeing multi-second stalls from
    keyboard input on his T61 laptop when NOHZ and CPU_IDLE
    were enabled on a 32bit kernel.
    
    He bisected the problem down to commit
    1e75fa8be9fb6 ("time: Condense timekeeper.xtime into xtime_sec").
    
    After reproducing this issue, I narrowed the problem down
    to the fact that timekeeping_get_ns() returns a 64bit
    nsec value that hasn't been accumulated. In some cases
    this value was being then stored in timespec.tv_nsec
    (which is a long).
    
    On 32bit systems, with idle times larger then 4 seconds
    (or less, depending on the value of xtime_nsec), the
    returned nsec value would overflow 32bits. This limited
    kept time from increasing, causing timers to not expire.
    
    The fix is to make sure we don't directly store the
    result of timekeeping_get_ns() into a tv_nsec field,
    instead using a 64bit nsec value which can then be
    added into the timespec via timespec_add_ns().
    
    Reported-and-bisected-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Tested-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Acked-by: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Link: http://lkml.kernel.org/r/1347405963-35715-1-git-send-email-john.stultz@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit adc78e6b9946a4b22e22403d961f3b03c469e5d3
Author: Rafael J. Wysocki <rjw@rjwysocki.net>
Date:   Mon Aug 6 01:40:41 2012 +0200

    timekeeping: Add suspend and resume of clock event devices
    
    Some clock event devices, for example such that belong to PM domains,
    need to be handled in a spcial way during the timekeeping suspend
    and resume (which takes place in the system core, or "syscore",
    stages of system power transitions) in analogy with clock sources.
    
    Introduce .suspend() and .resume() callbacks for clock event devices
    that will be executed by timekeeping_suspend/_resume(), respectively,
    next the the clock sources' .suspend() and .resume() callbacks.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

commit cee58483cf56e0ba355fdd97ff5e8925329aa936
Author: John Stultz <john.stultz@linaro.org>
Date:   Fri Aug 31 13:30:06 2012 -0400

    time: Move ktime_t overflow checking into timespec_valid_strict
    
    Andreas Bombe reported that the added ktime_t overflow checking added to
    timespec_valid in commit 4e8b14526ca7 ("time: Improve sanity checking of
    timekeeping inputs") was causing problems with X.org because it caused
    timeouts larger then KTIME_T to be invalid.
    
    Previously, these large timeouts would be clamped to KTIME_MAX and would
    never expire, which is valid.
    
    This patch splits the ktime_t overflow checking into a new
    timespec_valid_strict function, and converts the timekeeping codes
    internal checking to use this more strict function.
    
    Reported-and-tested-by: Andreas Bombe <aeb@debian.org>
    Cc: Zhouping Liu <zliu@redhat.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit 0ad5ec517eab8686580de44007d3af1f0e4bf423
Author: Bruce Rogers <brogers@suse.com>
Date:   Wed Aug 15 11:49:02 2012 +0300

    KVM: x86: apply kvmclock offset to guest wall clock time
    
    (cherry picked from commit 4b6486659a7defef82ea51b276024b3aa357fefc)
    
    When a guest migrates to a new host, the system time difference from the
    previous host is used in the updates to the kvmclock system time visible
    to the guest, resulting in a continuation of correct kvmclock based guest
    timekeeping.
    
    The wall clock component of the kvmclock provided time is currently not
    updated with this same time offset. Since the Linux guest caches the
    wall clock based time, this discrepency is not noticed until the guest is
    rebooted. After reboot the guest's time calculations are off.
    
    This patch adjusts the wall clock by the kvmclock_offset, resulting in
    correct guest time after a reboot.
    
    Cc: Zachary Amsden <zamsden@gmail.com>
    Signed-off-by: Bruce Rogers <brogers@suse.com>
    Signed-off-by: Marcelo Tosatti <mtosatti@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit b5bc0c7054725e238d1be6965fec452b0f0e5213
Merge: d37e44969e60 bf2ac3121951
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Aug 23 21:46:57 2012 -0700

    Merge branch 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer fixes from Thomas Gleixner:
     "Mostly small fixes for the fallout of the timekeeping overhaul in 3.6
      along with stable fixes to address an accumulation problem and missing
      sanity checks for RTC readouts and user space provided values."
    
    * 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      time: Avoid making adjustments if we haven't accumulated anything
      time: Avoid potential shift overflow with large shift values
      time: Fix casting issue in timekeeping_forward_now
      time: Ensure we normalize the timekeeper in tk_xtime_add
      time: Improve sanity checking of timekeeping inputs

commit bf2ac312195155511a0f79325515cbb61929898a
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Aug 21 20:30:49 2012 -0400

    time: Avoid making adjustments if we haven't accumulated anything
    
    If update_wall_time() is called and the current offset isn't large
    enough to accumulate, avoid re-calling timekeeping_adjust which may
    change the clock freq and can cause 1ns inconsistencies with
    CLOCK_REALTIME_COARSE/CLOCK_MONOTONIC_COARSE.
    
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: stable@vger.kernel.org
    Link: http://lkml.kernel.org/r/1345595449-34965-5-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 85dc8f05c93c8105987de9d7e7cebf15a72ff4ec
Author: Andreas Schwab <schwab@linux-m68k.org>
Date:   Tue Aug 21 20:30:47 2012 -0400

    time: Fix casting issue in timekeeping_forward_now
    
    arch_gettimeoffset returns a u32 value which when shifted by tk->shift
    can overflow. This issue was introduced with 1e75fa8be (time: Condense
    timekeeper.xtime into xtime_sec)
    
    Cast it to u64 first.
    
    Signed-off-by: Andreas Schwab <schwab@linux-m68k.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Link: http://lkml.kernel.org/r/1345595449-34965-3-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit d3f610aeedcdfda9967c612b52be2b2815f76156
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jul 17 17:49:31 2012 -0400

    timekeeping: Add missing update call in timekeeping_resume()
    
    commit 3e997130bd2e8c6f5aaa49d6e3161d4d29b43ab0 upstream.
    
    The leap second rework unearthed another issue of inconsistent data.
    
    On timekeeping_resume() the timekeeper data is updated, but nothing
    calls timekeeping_update(), so now the update code in the timer
    interrupt sees stale values.
    
    This has been the case before those changes, but then the timer
    interrupt was using stale data as well so this went unnoticed for quite
    some time.
    
    Add the missing update call, so all the data is consistent everywhere.
    
    Reported-by: Andreas Schwab <schwab@linux-m68k.org>
    Reported-and-tested-by: "Rafael J. Wysocki" <rjw@sisk.pl>
    Reported-and-tested-by: Martin Steigerwald <Martin@lichtvoll.de>
    Cc: LKML <linux-kernel@vger.kernel.org>
    Cc: Linux PM list <linux-pm@vger.kernel.org>
    Cc: John Stultz <johnstul@us.ibm.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>,
    Cc: Prarit Bhargava <prarit@redhat.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Linux Kernel <linux-kernel@vger.kernel.org>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

commit bd77b8e820140e552098f5262aa4e91513614110
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jul 17 17:49:29 2012 -0400

    timekeeping: Provide hrtimer update function
    
    commit f6c06abfb3972ad4914cef57d8348fcb2932bc3b upstream.
    
    To finally fix the infamous leap second issue and other race windows
    caused by functions which change the offsets between the various time
    bases (CLOCK_MONOTONIC, CLOCK_REALTIME and CLOCK_BOOTTIME) we need a
    function which atomically gets the current monotonic time and updates
    the offsets of CLOCK_REALTIME and CLOCK_BOOTTIME with minimalistic
    overhead. The previous patch which provides ktime_t offsets allows us
    to make this function almost as cheap as ktime_get() which is going to
    be replaced in hrtimer_interrupt().
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Ingo Molnar <mingo@kernel.org>
    Acked-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Acked-by: Prarit Bhargava <prarit@redhat.com>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Link: http://lkml.kernel.org/r/1341960205-56738-7-git-send-email-johnstul@us.ibm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Linux Kernel <linux-kernel@vger.kernel.org>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

commit cf110b9408cdf2e539d194042da3853cb22c61b0
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jul 17 17:49:27 2012 -0400

    timekeeping: Maintain ktime_t based offsets for hrtimers
    
    commit 5b9fe759a678e05be4937ddf03d50e950207c1c0 upstream.
    
    We need to update the hrtimer clock offsets from the hrtimer interrupt
    context. To avoid conversions from timespec to ktime_t maintain a
    ktime_t based representation of those offsets in the timekeeper. This
    puts the conversion overhead into the code which updates the
    underlying offsets and provides fast accessible values in the hrtimer
    interrupt.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Reviewed-by: Ingo Molnar <mingo@kernel.org>
    Acked-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Acked-by: Prarit Bhargava <prarit@redhat.com>
    Link: http://lkml.kernel.org/r/1341960205-56738-4-git-send-email-johnstul@us.ibm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Linux Kernel <linux-kernel@vger.kernel.org>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

commit 7e565a62054f05baecbc74ec28613b09bad57bcf
Author: John Stultz <johnstul@us.ibm.com>
Date:   Tue Jul 17 17:49:26 2012 -0400

    timekeeping: Fix leapsecond triggered load spike issue
    
    commit 4873fa070ae84a4115f0b3c9dfabc224f1bc7c51 upstream.
    
    The timekeeping code misses an update of the hrtimer subsystem after a
    leap second happened. Due to that timers based on CLOCK_REALTIME are
    either expiring a second early or late depending on whether a leap
    second has been inserted or deleted until an operation is initiated
    which causes that update. Unless the update happens by some other
    means this discrepancy between the timekeeping and the hrtimer data
    stays forever and timers are expired either early or late.
    
    The reported immediate workaround - $ data -s "`date`" - is causing a
    call to clock_was_set() which updates the hrtimer data structures.
    See: http://www.sheeri.com/content/mysql-and-leap-second-high-cpu-and-fix
    
    Add the missing clock_was_set() call to update_wall_time() in case of
    a leap second event. The actual update is deferred to softirq context
    as the necessary smp function call cannot be invoked from hard
    interrupt context.
    
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Reported-by: Jan Engelhardt <jengelh@inai.de>
    Reviewed-by: Ingo Molnar <mingo@kernel.org>
    Acked-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Acked-by: Prarit Bhargava <prarit@redhat.com>
    Link: http://lkml.kernel.org/r/1341960205-56738-3-git-send-email-johnstul@us.ibm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Linux Kernel <linux-kernel@vger.kernel.org>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

commit 25b2871241b14b0b01b7aa1ffc958b565ad03e3e
Author: John Stultz <johnstul@us.ibm.com>
Date:   Tue Jul 17 17:49:25 2012 -0400

    hrtimer: Provide clock_was_set_delayed()
    
    commit f55a6faa384304c89cfef162768e88374d3312cb upstream.
    
    clock_was_set() cannot be called from hard interrupt context because
    it calls on_each_cpu().
    
    For fixing the widely reported leap seconds issue it is necessary to
    call it from hard interrupt context, i.e. the timer tick code, which
    does the timekeeping updates.
    
    Provide a new function which denotes it in the hrtimer cpu base
    structure of the cpu on which it is called and raise the hrtimer
    softirq. We then execute the clock_was_set() notificiation from
    softirq context in run_hrtimer_softirq(). The hrtimer softirq is
    rarely used, so polling the flag there is not a performance issue.
    
    [ tglx: Made it depend on CONFIG_HIGH_RES_TIMERS. We really should get
      rid of all this ifdeffery ASAP ]
    
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Reported-by: Jan Engelhardt <jengelh@inai.de>
    Reviewed-by: Ingo Molnar <mingo@kernel.org>
    Acked-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Acked-by: Prarit Bhargava <prarit@redhat.com>
    Link: http://lkml.kernel.org/r/1341960205-56738-2-git-send-email-johnstul@us.ibm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Linux Kernel <linux-kernel@vger.kernel.org>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

commit 7df892974c2bf2487c3a08a959f0aab56d057822
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Jul 17 17:49:23 2012 -0400

    timekeeping: Fix CLOCK_MONOTONIC inconsistency during leapsecond
    
    commit fad0c66c4bb836d57a5f125ecd38bed653ca863a upstream.
    which resolves a bug the previous commit.
    
    Commit 6b43ae8a61 (ntp: Fix leap-second hrtimer livelock) broke the
    leapsecond update of CLOCK_MONOTONIC. The missing leapsecond update to
    wall_to_monotonic causes discontinuities in CLOCK_MONOTONIC.
    
    Adjust wall_to_monotonic when NTP inserted a leapsecond.
    
    Reported-by: Richard Cochran <richardcochran@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Tested-by: Richard Cochran <richardcochran@gmail.com>
    Link: http://lkml.kernel.org/r/1338400497-12420-1-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Linux Kernel <linux-kernel@vger.kernel.org>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

commit 4e8b14526ca7fb046a81c94002c1c43b6fdf0e9b
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Aug 8 15:36:20 2012 -0400

    time: Improve sanity checking of timekeeping inputs
    
    Unexpected behavior could occur if the time is set to a value large
    enough to overflow a 64bit ktime_t (which is something larger then the
    year 2262).
    
    Also unexpected behavior could occur if large negative offsets are
    injected via adjtimex.
    
    So this patch improves the sanity check timekeeping inputs by
    improving the timespec_valid() check, and then makes better use of
    timespec_valid() to make sure we don't set the time to an invalid
    negative value or one that overflows ktime_t.
    
    Note: This does not protect from setting the time close to overflowing
    ktime_t and then letting natural accumulation cause the overflow.
    
    Reported-by: CAI Qian <caiqian@redhat.com>
    Reported-by: Sasha Levin <levinsasha928@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Zhouping Liu <zliu@redhat.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: stable@vger.kernel.org
    Link: http://lkml.kernel.org/r/1344454580-17031-1-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 42a579a0f960081cd16fc945036e4780c3ad3202
Merge: 1d17d17484d4 8a06bf14008f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Aug 5 22:28:49 2012 +0300

    Merge branches 'timers-urgent-for-linus' and 'perf-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timers and perf fixes from Ingo Molnar:
     "Timers:
     - Fix another timekeeping bug
    
     Pef:
       - Make clean brace expansion fix for some shells, from Palmer Cox
    
       - Warn user just once per guest kernel when not finding kernel info,
         from David Ahern
    
       - perf test fix from Jiri Olsa
    
       - Fix error handling on event creation in perf top, from David Ahern
    
       - Fix check on perf_target__strnerror, from Namhyung Kim
    
       - Save the whole cmdline, from David Ahern
    
      There's this infrastructure change:
    
       - Prep work for the DWARF CFI post unwinder, so that it doesn't use
         perf_session in lots of places, just evlist/evsel is enough.
    
      which is a late infrastructure change that prepare for future feature
      work - we wanted it upstream to simplify the fixes/development patch
      flows."
    
    * 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      time: Fix adjustment cleanup bug in timekeeping_adjust()
    
    * 'perf-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      perf tools: Remove brace expansion from clean target
      perf kvm top: Limit guest kernel info message to once
      perf tools: Introduce intlist
      perf tools: Change strlist to use the new rblist
      perf tools: Introducing rblist
      perf kvm: Use strtol for walking guestmount directory
      perf tool: Save cmdline from user in file header vs what is passed to record
      perf top: Error handling for counter creation should parallel perf-record
      perf session: Remove no longer used synthesize_sample method
      perf evsel: Adopt parse_sample method from perf_event
      perf evlist: Introduce perf_evlist__parse_sample
      perf session: Use perf_evlist__id_hdr_size more extensively
      perf session: Use perf_evlist__sample_id_all more extensively
      perf session: Use perf_evlist__sample_type more extensively
      perf evsel: Precalculate the sample size
      perf target: Fix check on buffer size
      perf symbols: Fix array sizes for binary types arrays
      perf test: Fix parse events automated tests

commit 1d17d17484d40f2d5b35c79518597a2b25296996
Author: Ingo Molnar <mingo@kernel.org>
Date:   Sat Aug 4 21:21:14 2012 +0200

    time: Fix adjustment cleanup bug in timekeeping_adjust()
    
    Tetsuo Handa reported that sporadically the system clock starts
    counting up too quickly which is enough to confuse the hangcheck
    timer to print a bogus stall warning.
    
    Commit 2a8c0883 "time: Move xtime_nsec adjustment underflow handling
    timekeeping_adjust" overlooked this exit path:
    
            } else
                    return;
    
    which should really be a proper exit sequence, fixing the bug as a
    side effect.
    
    Also make the flow more readable by properly balancing curly
    braces.
    
    Reported-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp> wrote:
    Tested-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp> wrote:
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Cc: john.stultz@linaro.org
    Cc: a.p.zijlstra@chello.nl
    Cc: richardcochran@gmail.com
    Cc: prarit@redhat.com
    Link: http://lkml.kernel.org/r/20120804192114.GA28347@gmail.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 4b6486659a7defef82ea51b276024b3aa357fefc
Author: Bruce Rogers <brogers@suse.com>
Date:   Fri Jul 20 10:44:24 2012 -0600

    KVM: x86: apply kvmclock offset to guest wall clock time
    
    When a guest migrates to a new host, the system time difference from the
    previous host is used in the updates to the kvmclock system time visible
    to the guest, resulting in a continuation of correct kvmclock based guest
    timekeeping.
    
    The wall clock component of the kvmclock provided time is currently not
    updated with this same time offset. Since the Linux guest caches the
    wall clock based time, this discrepency is not noticed until the guest is
    rebooted. After reboot the guest's time calculations are off.
    
    This patch adjusts the wall clock by the kvmclock_offset, resulting in
    correct guest time after a reboot.
    
    Cc: Zachary Amsden <zamsden@gmail.com>
    Signed-off-by: Bruce Rogers <brogers@suse.com>
    Signed-off-by: Marcelo Tosatti <mtosatti@redhat.com>

commit 4e250fdde9be50581c7dd5fed88c9b9960615314
Author: John Stultz <john.stultz@linaro.org>
Date:   Fri Jul 27 14:48:13 2012 -0400

    time: Remove all direct references to timekeeper
    
    Ingo noted that the numerous timekeeper.value references made
    the timekeeping code ugly and caused many long lines that
    had to be broken up. He recommended replacing timekeeper.value
    references with tk->value.
    
    This patch provides a local tk value for all top level time
    functions and sets it to &timekeeper. Then all timekeeper
    access is done via a tk pointer.
    
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Link: http://lkml.kernel.org/r/1343414893-45779-6-git-send-email-john.stultz@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 0ad70925ab61c308d669d93f02c7bf1974a5158f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Jul 16 12:50:42 2012 -0400

    timekeeping: Add missing update call in timekeeping_resume()
    
    This is a backport of 3e997130bd2e8c6f5aaa49d6e3161d4d29b43ab0
    
    The leap second rework unearthed another issue of inconsistent data.
    
    On timekeeping_resume() the timekeeper data is updated, but nothing
    calls timekeeping_update(), so now the update code in the timer
    interrupt sees stale values.
    
    This has been the case before those changes, but then the timer
    interrupt was using stale data as well so this went unnoticed for quite
    some time.
    
    Add the missing update call, so all the data is consistent everywhere.
    
    Reported-by: Andreas Schwab <schwab@linux-m68k.org>
    Reported-and-tested-by: "Rafael J. Wysocki" <rjw@sisk.pl>
    Reported-and-tested-by: Martin Steigerwald <Martin@lichtvoll.de>
    Cc: LKML <linux-kernel@vger.kernel.org>
    Cc: Linux PM list <linux-pm@vger.kernel.org>
    Cc: John Stultz <johnstul@us.ibm.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>,
    Cc: Prarit Bhargava <prarit@redhat.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    [John Stultz: Backported to 3.2]
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Linux Kernel <linux-kernel@vger.kernel.org>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit ec5806bcd08281a86e05b8e4eaf2f377bc8e5b24
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jul 10 18:43:24 2012 -0400

    timekeeping: Provide hrtimer update function
    
    This is a backport of f6c06abfb3972ad4914cef57d8348fcb2932bc3b
    
    To finally fix the infamous leap second issue and other race windows
    caused by functions which change the offsets between the various time
    bases (CLOCK_MONOTONIC, CLOCK_REALTIME and CLOCK_BOOTTIME) we need a
    function which atomically gets the current monotonic time and updates
    the offsets of CLOCK_REALTIME and CLOCK_BOOTTIME with minimalistic
    overhead. The previous patch which provides ktime_t offsets allows us
    to make this function almost as cheap as ktime_get() which is going to
    be replaced in hrtimer_interrupt().
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Ingo Molnar <mingo@kernel.org>
    Acked-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Acked-by: Prarit Bhargava <prarit@redhat.com>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Link: http://lkml.kernel.org/r/1341960205-56738-7-git-send-email-johnstul@us.ibm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    [John Stultz: Backported to 3.2]
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Linux Kernel <linux-kernel@vger.kernel.org>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit a105e023adf852c9847e1fe7f0bc151ce0339914
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jul 10 18:43:21 2012 -0400

    timekeeping: Maintain ktime_t based offsets for hrtimers
    
    This is a backport of 5b9fe759a678e05be4937ddf03d50e950207c1c0
    
    We need to update the hrtimer clock offsets from the hrtimer interrupt
    context. To avoid conversions from timespec to ktime_t maintain a
    ktime_t based representation of those offsets in the timekeeper. This
    puts the conversion overhead into the code which updates the
    underlying offsets and provides fast accessible values in the hrtimer
    interrupt.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Reviewed-by: Ingo Molnar <mingo@kernel.org>
    Acked-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Acked-by: Prarit Bhargava <prarit@redhat.com>
    Link: http://lkml.kernel.org/r/1341960205-56738-4-git-send-email-johnstul@us.ibm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    [John Stultz: Backported to 3.2]
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Linux Kernel <linux-kernel@vger.kernel.org>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit 8a1ba973a23bd94a4ce34ffa543bf0e0d4ec13ff
Author: John Stultz <johnstul@us.ibm.com>
Date:   Tue Jul 10 18:43:20 2012 -0400

    timekeeping: Fix leapsecond triggered load spike issue
    
    This is a backport of 4873fa070ae84a4115f0b3c9dfabc224f1bc7c51
    
    The timekeeping code misses an update of the hrtimer subsystem after a
    leap second happened. Due to that timers based on CLOCK_REALTIME are
    either expiring a second early or late depending on whether a leap
    second has been inserted or deleted until an operation is initiated
    which causes that update. Unless the update happens by some other
    means this discrepancy between the timekeeping and the hrtimer data
    stays forever and timers are expired either early or late.
    
    The reported immediate workaround - $ data -s "`date`" - is causing a
    call to clock_was_set() which updates the hrtimer data structures.
    See: http://www.sheeri.com/content/mysql-and-leap-second-high-cpu-and-fix
    
    Add the missing clock_was_set() call to update_wall_time() in case of
    a leap second event. The actual update is deferred to softirq context
    as the necessary smp function call cannot be invoked from hard
    interrupt context.
    
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Reported-by: Jan Engelhardt <jengelh@inai.de>
    Reviewed-by: Ingo Molnar <mingo@kernel.org>
    Acked-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Acked-by: Prarit Bhargava <prarit@redhat.com>
    Link: http://lkml.kernel.org/r/1341960205-56738-3-git-send-email-johnstul@us.ibm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Linux Kernel <linux-kernel@vger.kernel.org>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit 3c910e7e46810c73e21196867b7ec63d58a0a45c
Author: John Stultz <johnstul@us.ibm.com>
Date:   Tue Jul 10 18:43:19 2012 -0400

    hrtimer: Provide clock_was_set_delayed()
    
    commit f55a6faa384304c89cfef162768e88374d3312cb upstream.
    
    clock_was_set() cannot be called from hard interrupt context because
    it calls on_each_cpu().
    
    For fixing the widely reported leap seconds issue it is necessary to
    call it from hard interrupt context, i.e. the timer tick code, which
    does the timekeeping updates.
    
    Provide a new function which denotes it in the hrtimer cpu base
    structure of the cpu on which it is called and raise the hrtimer
    softirq. We then execute the clock_was_set() notificiation from
    softirq context in run_hrtimer_softirq(). The hrtimer softirq is
    rarely used, so polling the flag there is not a performance issue.
    
    [ tglx: Made it depend on CONFIG_HIGH_RES_TIMERS. We really should get
      rid of all this ifdeffery ASAP ]
    
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Reported-by: Jan Engelhardt <jengelh@inai.de>
    Reviewed-by: Ingo Molnar <mingo@kernel.org>
    Acked-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Acked-by: Prarit Bhargava <prarit@redhat.com>
    Link: http://lkml.kernel.org/r/1341960205-56738-2-git-send-email-johnstul@us.ibm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit 09e66e8d71833a897a82ec18484b388e729b6548
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed May 30 10:54:57 2012 -0700

    timekeeping: Fix CLOCK_MONOTONIC inconsistency during leapsecond
    
    This is a backport of fad0c66c4bb836d57a5f125ecd38bed653ca863a
    which resolves a bug the previous commit.
    
    Commit 6b43ae8a61 (ntp: Fix leap-second hrtimer livelock) broke the
    leapsecond update of CLOCK_MONOTONIC. The missing leapsecond update to
    wall_to_monotonic causes discontinuities in CLOCK_MONOTONIC.
    
    Adjust wall_to_monotonic when NTP inserted a leapsecond.
    
    Reported-by: Richard Cochran <richardcochran@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Tested-by: Richard Cochran <richardcochran@gmail.com>
    Link: http://lkml.kernel.org/r/1338400497-12420-1-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Linux Kernel <linux-kernel@vger.kernel.org>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit 3992c0321258bdff3666cbaf5225f538ad61a548
Merge: 55acdddbac17 eec19d1a0d04
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Jul 22 11:35:46 2012 -0700

    Merge branch 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer core changes from Ingo Molnar:
     "Continued cleanups of the core time and NTP code, plus more nohz work
      preparing for tick-less userspace execution."
    
    * 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      time: Rework timekeeping functions to take timekeeper ptr as argument
      time: Move xtime_nsec adjustment underflow handling timekeeping_adjust
      time: Move arch_gettimeoffset() usage into timekeeping_get_ns()
      time: Refactor accumulation of nsecs to secs
      time: Condense timekeeper.xtime into xtime_sec
      time: Explicitly use u32 instead of int for shift values
      time: Whitespace cleanups per Ingo%27s requests
      nohz: Move next idle expiry time record into idle logic area
      nohz: Move ts->idle_calls incrementation into strict idle logic
      nohz: Rename ts->idle_tick to ts->last_tick
      nohz: Make nohz API agnostic against idle ticks cputime accounting
      nohz: Separate idle sleeping time accounting from nohz logic
      timers: Improve get_next_timer_interrupt()
      timers: Add accounting of non deferrable timers
      timers: Consolidate base->next_timer update
      timers: Create detach_if_pending() and use it

commit 3cdeda1e763ccb2287c6ee76ece14145027653a9
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jul 17 02:39:56 2012 -0400

    timekeeping: Add missing update call in timekeeping_resume()
    
    This is a backport of 3e997130bd2e8c6f5aaa49d6e3161d4d29b43ab0
    
    The leap second rework unearthed another issue of inconsistent data.
    
    On timekeeping_resume() the timekeeper data is updated, but nothing
    calls timekeeping_update(), so now the update code in the timer
    interrupt sees stale values.
    
    This has been the case before those changes, but then the timer
    interrupt was using stale data as well so this went unnoticed for quite
    some time.
    
    Add the missing update call, so all the data is consistent everywhere.
    
    Reported-by: Andreas Schwab <schwab@linux-m68k.org>
    Reported-and-tested-by: "Rafael J. Wysocki" <rjw@sisk.pl>
    Reported-and-tested-by: Martin Steigerwald <Martin@lichtvoll.de>
    Cc: John Stultz <johnstul@us.ibm.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>,
    Cc: Prarit Bhargava <prarit@redhat.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 765bdc4d82fadcddfec19222a545e904633c7816
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jul 17 02:39:54 2012 -0400

    timekeeping: Provide hrtimer update function
    
    This is a backport of f6c06abfb3972ad4914cef57d8348fcb2932bc3b
    
    To finally fix the infamous leap second issue and other race windows
    caused by functions which change the offsets between the various time
    bases (CLOCK_MONOTONIC, CLOCK_REALTIME and CLOCK_BOOTTIME) we need a
    function which atomically gets the current monotonic time and updates
    the offsets of CLOCK_REALTIME and CLOCK_BOOTTIME with minimalistic
    overhead. The previous patch which provides ktime_t offsets allows us
    to make this function almost as cheap as ktime_get() which is going to
    be replaced in hrtimer_interrupt().
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Ingo Molnar <mingo@kernel.org>
    Acked-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Acked-by: Prarit Bhargava <prarit@redhat.com>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Link: http://lkml.kernel.org/r/1341960205-56738-7-git-send-email-johnstul@us.ibm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 7d1f07113b1b32da1eabce0dc74d9f96bbb7b90a
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jul 17 02:39:52 2012 -0400

    timekeeping: Maintain ktime_t based offsets for hrtimers
    
    This is a backport of 5b9fe759a678e05be4937ddf03d50e950207c1c0
    
    We need to update the hrtimer clock offsets from the hrtimer interrupt
    context. To avoid conversions from timespec to ktime_t maintain a
    ktime_t based representation of those offsets in the timekeeper. This
    puts the conversion overhead into the code which updates the
    underlying offsets and provides fast accessible values in the hrtimer
    interrupt.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Reviewed-by: Ingo Molnar <mingo@kernel.org>
    Acked-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Acked-by: Prarit Bhargava <prarit@redhat.com>
    Link: http://lkml.kernel.org/r/1341960205-56738-4-git-send-email-johnstul@us.ibm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 2e947d469fba2c2036ff50a2e58a1875ab2ea6b6
Author: John Stultz <johnstul@us.ibm.com>
Date:   Tue Jul 17 02:39:51 2012 -0400

    timekeeping: Fix leapsecond triggered load spike issue
    
    This is a backport of 4873fa070ae84a4115f0b3c9dfabc224f1bc7c51
    
    The timekeeping code misses an update of the hrtimer subsystem after a
    leap second happened. Due to that timers based on CLOCK_REALTIME are
    either expiring a second early or late depending on whether a leap
    second has been inserted or deleted until an operation is initiated
    which causes that update. Unless the update happens by some other
    means this discrepancy between the timekeeping and the hrtimer data
    stays forever and timers are expired either early or late.
    
    The reported immediate workaround - $ data -s "`date`" - is causing a
    call to clock_was_set() which updates the hrtimer data structures.
    See: http://www.sheeri.com/content/mysql-and-leap-second-high-cpu-and-fix
    
    Add the missing clock_was_set() call to update_wall_time() in case of
    a leap second event. The actual update is deferred to softirq context
    as the necessary smp function call cannot be invoked from hard
    interrupt context.
    
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Reported-by: Jan Engelhardt <jengelh@inai.de>
    Reviewed-by: Ingo Molnar <mingo@kernel.org>
    Acked-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Acked-by: Prarit Bhargava <prarit@redhat.com>
    Link: http://lkml.kernel.org/r/1341960205-56738-3-git-send-email-johnstul@us.ibm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 5e5006e64cae9603841405af9febb67064869d83
Author: John Stultz <johnstul@us.ibm.com>
Date:   Tue Jul 17 02:39:50 2012 -0400

    hrtimer: Provide clock_was_set_delayed()
    
    This is a backport of f55a6faa384304c89cfef162768e88374d3312cb
    
    clock_was_set() cannot be called from hard interrupt context because
    it calls on_each_cpu().
    
    For fixing the widely reported leap seconds issue it is necessary to
    call it from hard interrupt context, i.e. the timer tick code, which
    does the timekeeping updates.
    
    Provide a new function which denotes it in the hrtimer cpu base
    structure of the cpu on which it is called and raise the hrtimer
    softirq. We then execute the clock_was_set() notificiation from
    softirq context in run_hrtimer_softirq(). The hrtimer softirq is
    rarely used, so polling the flag there is not a performance issue.
    
    [ tglx: Made it depend on CONFIG_HIGH_RES_TIMERS. We really should get
      rid of all this ifdeffery ASAP ]
    
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Reported-by: Jan Engelhardt <jengelh@inai.de>
    Reviewed-by: Ingo Molnar <mingo@kernel.org>
    Acked-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Acked-by: Prarit Bhargava <prarit@redhat.com>
    Link: http://lkml.kernel.org/r/1341960205-56738-2-git-send-email-johnstul@us.ibm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 0851978b661f25192ff763289698f3175b1bab42
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jul 17 13:33:58 2012 -0400

    timekeeping: Add missing update call in timekeeping_resume()
    
    This is a backport of 3e997130bd2e8c6f5aaa49d6e3161d4d29b43ab0
    
    The leap second rework unearthed another issue of inconsistent data.
    
    On timekeeping_resume() the timekeeper data is updated, but nothing
    calls timekeeping_update(), so now the update code in the timer
    interrupt sees stale values.
    
    This has been the case before those changes, but then the timer
    interrupt was using stale data as well so this went unnoticed for quite
    some time.
    
    Add the missing update call, so all the data is consistent everywhere.
    
    Reported-by: Andreas Schwab <schwab@linux-m68k.org>
    Reported-and-tested-by: "Rafael J. Wysocki" <rjw@sisk.pl>
    Reported-and-tested-by: Martin Steigerwald <Martin@lichtvoll.de>
    Cc: John Stultz <johnstul@us.ibm.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>,
    Cc: Prarit Bhargava <prarit@redhat.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 22f4bbcfb131e2392c78ad67af35fdd436d4dd54
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jul 17 13:33:56 2012 -0400

    timekeeping: Provide hrtimer update function
    
    This is a backport of f6c06abfb3972ad4914cef57d8348fcb2932bc3b
    
    To finally fix the infamous leap second issue and other race windows
    caused by functions which change the offsets between the various time
    bases (CLOCK_MONOTONIC, CLOCK_REALTIME and CLOCK_BOOTTIME) we need a
    function which atomically gets the current monotonic time and updates
    the offsets of CLOCK_REALTIME and CLOCK_BOOTTIME with minimalistic
    overhead. The previous patch which provides ktime_t offsets allows us
    to make this function almost as cheap as ktime_get() which is going to
    be replaced in hrtimer_interrupt().
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Ingo Molnar <mingo@kernel.org>
    Acked-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Acked-by: Prarit Bhargava <prarit@redhat.com>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Link: http://lkml.kernel.org/r/1341960205-56738-7-git-send-email-johnstul@us.ibm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 03a90b9a6f7eec70edde4eb1f88fa8a5c058d85e
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jul 17 13:33:54 2012 -0400

    timekeeping: Maintain ktime_t based offsets for hrtimers
    
    This is a backport of 5b9fe759a678e05be4937ddf03d50e950207c1c0
    
    We need to update the hrtimer clock offsets from the hrtimer interrupt
    context. To avoid conversions from timespec to ktime_t maintain a
    ktime_t based representation of those offsets in the timekeeper. This
    puts the conversion overhead into the code which updates the
    underlying offsets and provides fast accessible values in the hrtimer
    interrupt.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Reviewed-by: Ingo Molnar <mingo@kernel.org>
    Acked-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Acked-by: Prarit Bhargava <prarit@redhat.com>
    Link: http://lkml.kernel.org/r/1341960205-56738-4-git-send-email-johnstul@us.ibm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit d21e4baf4523fec26e3c70cb78b013ad3b245c83
Author: John Stultz <johnstul@us.ibm.com>
Date:   Tue Jul 17 13:33:53 2012 -0400

    timekeeping: Fix leapsecond triggered load spike issue
    
    This is a backport of 4873fa070ae84a4115f0b3c9dfabc224f1bc7c51
    
    The timekeeping code misses an update of the hrtimer subsystem after a
    leap second happened. Due to that timers based on CLOCK_REALTIME are
    either expiring a second early or late depending on whether a leap
    second has been inserted or deleted until an operation is initiated
    which causes that update. Unless the update happens by some other
    means this discrepancy between the timekeeping and the hrtimer data
    stays forever and timers are expired either early or late.
    
    The reported immediate workaround - $ data -s "`date`" - is causing a
    call to clock_was_set() which updates the hrtimer data structures.
    See: http://www.sheeri.com/content/mysql-and-leap-second-high-cpu-and-fix
    
    Add the missing clock_was_set() call to update_wall_time() in case of
    a leap second event. The actual update is deferred to softirq context
    as the necessary smp function call cannot be invoked from hard
    interrupt context.
    
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Reported-by: Jan Engelhardt <jengelh@inai.de>
    Reviewed-by: Ingo Molnar <mingo@kernel.org>
    Acked-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Acked-by: Prarit Bhargava <prarit@redhat.com>
    Link: http://lkml.kernel.org/r/1341960205-56738-3-git-send-email-johnstul@us.ibm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 62b787f886e2d96cc7c5428aeee05dbe32a9531b
Author: John Stultz <johnstul@us.ibm.com>
Date:   Tue Jul 17 13:33:52 2012 -0400

    hrtimer: Provide clock_was_set_delayed()
    
    This is a backport of f55a6faa384304c89cfef162768e88374d3312cb
    
    clock_was_set() cannot be called from hard interrupt context because
    it calls on_each_cpu().
    
    For fixing the widely reported leap seconds issue it is necessary to
    call it from hard interrupt context, i.e. the timer tick code, which
    does the timekeeping updates.
    
    Provide a new function which denotes it in the hrtimer cpu base
    structure of the cpu on which it is called and raise the hrtimer
    softirq. We then execute the clock_was_set() notificiation from
    softirq context in run_hrtimer_softirq(). The hrtimer softirq is
    rarely used, so polling the flag there is not a performance issue.
    
    [ tglx: Made it depend on CONFIG_HIGH_RES_TIMERS. We really should get
      rid of all this ifdeffery ASAP ]
    
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Reported-by: Jan Engelhardt <jengelh@inai.de>
    Reviewed-by: Ingo Molnar <mingo@kernel.org>
    Acked-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Acked-by: Prarit Bhargava <prarit@redhat.com>
    Link: http://lkml.kernel.org/r/1341960205-56738-2-git-send-email-johnstul@us.ibm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit c33f2424c3941986d402c81d380d4e805870a20f
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Jul 17 13:33:50 2012 -0400

    timekeeping: Fix CLOCK_MONOTONIC inconsistency during leapsecond
    
    This is a backport of fad0c66c4bb836d57a5f125ecd38bed653ca863a
    which resolves a bug the previous commit.
    
    Commit 6b43ae8a61 (ntp: Fix leap-second hrtimer livelock) broke the
    leapsecond update of CLOCK_MONOTONIC. The missing leapsecond update to
    wall_to_monotonic causes discontinuities in CLOCK_MONOTONIC.
    
    Adjust wall_to_monotonic when NTP inserted a leapsecond.
    
    Reported-by: Richard Cochran <richardcochran@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Tested-by: Richard Cochran <richardcochran@gmail.com>
    Link: http://lkml.kernel.org/r/1338400497-12420-1-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit eec19d1a0d04c80e66eef634f7b8f460f2ca5643
Merge: f726a697d061 a018540141a9
Author: Ingo Molnar <mingo@kernel.org>
Date:   Wed Jul 18 11:24:41 2012 +0200

    Merge branch 'linus' into timers/core
    
    Resolve semantic conflict in kernel/time/timekeeping.c.
    
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 3e997130bd2e8c6f5aaa49d6e3161d4d29b43ab0
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Jul 16 12:50:42 2012 -0400

    timekeeping: Add missing update call in timekeeping_resume()
    
    The leap second rework unearthed another issue of inconsistent data.
    
    On timekeeping_resume() the timekeeper data is updated, but nothing
    calls timekeeping_update(), so now the update code in the timer
    interrupt sees stale values.
    
    This has been the case before those changes, but then the timer
    interrupt was using stale data as well so this went unnoticed for quite
    some time.
    
    Add the missing update call, so all the data is consistent everywhere.
    
    Reported-by: Andreas Schwab <schwab@linux-m68k.org>
    Reported-and-tested-by: "Rafael J. Wysocki" <rjw@sisk.pl>
    Reported-and-tested-by: Martin Steigerwald <Martin@lichtvoll.de>
    Cc: LKML <linux-kernel@vger.kernel.org>
    Cc: Linux PM list <linux-pm@vger.kernel.org>
    Cc: John Stultz <johnstul@us.ibm.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>,
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit f726a697d06102e7a1fc0a87308cb30a84580205
Author: John Stultz <john.stultz@linaro.org>
Date:   Fri Jul 13 01:21:57 2012 -0400

    time: Rework timekeeping functions to take timekeeper ptr as argument
    
    As part of cleaning up the timekeeping code, this patch converts
    a number of internal functions to takei a timekeeper ptr as an
    argument, so that the internal functions don't access the global
    timekeeper structure directly. This allows for further optimizations
    to reduce lock hold time later.
    
    This patch has been updated to include more consistent usage of the
    timekeeper value, by making sure it is always passed as a argument
    to non top-level functions.
    
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Reviewed-by: Ingo Molnar <mingo@kernel.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Link: http://lkml.kernel.org/r/1342156917-25092-9-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 2a8c0883c3cfffcc148ea606e2a4e7453cd75e73
Author: John Stultz <john.stultz@linaro.org>
Date:   Fri Jul 13 01:21:56 2012 -0400

    time: Move xtime_nsec adjustment underflow handling timekeeping_adjust
    
    When we make adjustments speeding up the clock, its possible
    for xtime_nsec to underflow. We already handle this properly,
    but we do so from update_wall_time() instead of the more logical
    timekeeping_adjust(), where the possible underflow actually
    occurs.
    
    Thus, move the correction logic to the timekeeping_adjust, which
    is the function that causes the issue. Making update_wall_time()
    more readable.
    
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Reviewed-by: Ingo Molnar <mingo@kernel.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Link: http://lkml.kernel.org/r/1342156917-25092-8-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit f2a5a0854efc62abe7f69e9947842cb135837f9a
Author: John Stultz <john.stultz@linaro.org>
Date:   Fri Jul 13 01:21:55 2012 -0400

    time: Move arch_gettimeoffset() usage into timekeeping_get_ns()
    
    Since we call arch_gettimeoffset() in all the accessor
    functions, move arch_gettimeoffset() calls into
    timekeeping_get_ns() and timekeeping_get_ns_raw() to simplify
    the code.
    
    This also makes the code easier to maintain as we don't have to
    worry about forgetting the arch_gettimeoffset() as has happened
    in the past.
    
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Reviewed-by: Ingo Molnar <mingo@kernel.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Link: http://lkml.kernel.org/r/1342156917-25092-7-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 1e75fa8be9fb61e1af46b5b3b176347a4c958ca1
Author: John Stultz <john.stultz@linaro.org>
Date:   Fri Jul 13 01:21:53 2012 -0400

    time: Condense timekeeper.xtime into xtime_sec
    
    The timekeeper struct has a xtime_nsec, which keeps the
    sub-nanosecond remainder.  This ends up being somewhat
    duplicative of the timekeeper.xtime.tv_nsec value, and we
    have to do extra work to keep them apart, copying the full
    nsec portion out and back in over and over.
    
    This patch simplifies some of the logic by taking the timekeeper
    xtime value and splitting it into timekeeper.xtime_sec and
    reuses the timekeeper.xtime_nsec for the sub-second portion
    (stored in higher res shifted nanoseconds).
    
    This simplifies some of the accumulation logic. And will
    allow for more accurate timekeeping once the vsyscall code
    is updated to use the shifted nanosecond remainder.
    
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Reviewed-by: Ingo Molnar <mingo@kernel.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Link: http://lkml.kernel.org/r/1342156917-25092-5-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit d55e5bd0201a2af0182687882a92c5f95dbccc12
Merge: 5651721edec2 5baefd6d8416
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jul 13 15:31:21 2012 -0700

    Merge branch 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull the leap second fixes from Thomas Gleixner:
     "It's a rather large series, but well discussed, refined and reviewed.
      It got a massive testing by John, Prarit and tip.
    
      In theory we could split it into two parts.  The first two patches
    
        f55a6faa3843: hrtimer: Provide clock_was_set_delayed()
        4873fa070ae8: timekeeping: Fix leapsecond triggered load spike issue
    
      are merely preventing the stuff loops forever issues, which people
      have observed.
    
      But there is no point in delaying the other 4 commits which achieve
      full correctness into 3.6 as they are tagged for stable anyway.  And I
      rather prefer to have the full fixes merged in bulk than a "prevent
      the observable wreckage and deal with the hidden fallout later"
      approach."
    
    * 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      hrtimer: Update hrtimer base offsets each hrtimer_interrupt
      timekeeping: Provide hrtimer update function
      hrtimers: Move lock held region in hrtimer_interrupt()
      timekeeping: Maintain ktime_t based offsets for hrtimers
      timekeeping: Fix leapsecond triggered load spike issue
      hrtimer: Provide clock_was_set_delayed()

commit f6c06abfb3972ad4914cef57d8348fcb2932bc3b
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jul 10 18:43:24 2012 -0400

    timekeeping: Provide hrtimer update function
    
    To finally fix the infamous leap second issue and other race windows
    caused by functions which change the offsets between the various time
    bases (CLOCK_MONOTONIC, CLOCK_REALTIME and CLOCK_BOOTTIME) we need a
    function which atomically gets the current monotonic time and updates
    the offsets of CLOCK_REALTIME and CLOCK_BOOTTIME with minimalistic
    overhead. The previous patch which provides ktime_t offsets allows us
    to make this function almost as cheap as ktime_get() which is going to
    be replaced in hrtimer_interrupt().
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Ingo Molnar <mingo@kernel.org>
    Acked-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Acked-by: Prarit Bhargava <prarit@redhat.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Link: http://lkml.kernel.org/r/1341960205-56738-7-git-send-email-johnstul@us.ibm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 5b9fe759a678e05be4937ddf03d50e950207c1c0
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jul 10 18:43:21 2012 -0400

    timekeeping: Maintain ktime_t based offsets for hrtimers
    
    We need to update the hrtimer clock offsets from the hrtimer interrupt
    context. To avoid conversions from timespec to ktime_t maintain a
    ktime_t based representation of those offsets in the timekeeper. This
    puts the conversion overhead into the code which updates the
    underlying offsets and provides fast accessible values in the hrtimer
    interrupt.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Reviewed-by: Ingo Molnar <mingo@kernel.org>
    Acked-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Acked-by: Prarit Bhargava <prarit@redhat.com>
    Cc: stable@vger.kernel.org
    Link: http://lkml.kernel.org/r/1341960205-56738-4-git-send-email-johnstul@us.ibm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 4873fa070ae84a4115f0b3c9dfabc224f1bc7c51
Author: John Stultz <johnstul@us.ibm.com>
Date:   Tue Jul 10 18:43:20 2012 -0400

    timekeeping: Fix leapsecond triggered load spike issue
    
    The timekeeping code misses an update of the hrtimer subsystem after a
    leap second happened. Due to that timers based on CLOCK_REALTIME are
    either expiring a second early or late depending on whether a leap
    second has been inserted or deleted until an operation is initiated
    which causes that update. Unless the update happens by some other
    means this discrepancy between the timekeeping and the hrtimer data
    stays forever and timers are expired either early or late.
    
    The reported immediate workaround - $ data -s "`date`" - is causing a
    call to clock_was_set() which updates the hrtimer data structures.
    See: http://www.sheeri.com/content/mysql-and-leap-second-high-cpu-and-fix
    
    Add the missing clock_was_set() call to update_wall_time() in case of
    a leap second event. The actual update is deferred to softirq context
    as the necessary smp function call cannot be invoked from hard
    interrupt context.
    
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Reported-by: Jan Engelhardt <jengelh@inai.de>
    Reviewed-by: Ingo Molnar <mingo@kernel.org>
    Acked-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Acked-by: Prarit Bhargava <prarit@redhat.com>
    Cc: stable@vger.kernel.org
    Link: http://lkml.kernel.org/r/1341960205-56738-3-git-send-email-johnstul@us.ibm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit f55a6faa384304c89cfef162768e88374d3312cb
Author: John Stultz <johnstul@us.ibm.com>
Date:   Tue Jul 10 18:43:19 2012 -0400

    hrtimer: Provide clock_was_set_delayed()
    
    clock_was_set() cannot be called from hard interrupt context because
    it calls on_each_cpu().
    
    For fixing the widely reported leap seconds issue it is necessary to
    call it from hard interrupt context, i.e. the timer tick code, which
    does the timekeeping updates.
    
    Provide a new function which denotes it in the hrtimer cpu base
    structure of the cpu on which it is called and raise the hrtimer
    softirq. We then execute the clock_was_set() notificiation from
    softirq context in run_hrtimer_softirq(). The hrtimer softirq is
    rarely used, so polling the flag there is not a performance issue.
    
    [ tglx: Made it depend on CONFIG_HIGH_RES_TIMERS. We really should get
      rid of all this ifdeffery ASAP ]
    
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Reported-by: Jan Engelhardt <jengelh@inai.de>
    Reviewed-by: Ingo Molnar <mingo@kernel.org>
    Acked-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Acked-by: Prarit Bhargava <prarit@redhat.com>
    Cc: stable@vger.kernel.org
    Link: http://lkml.kernel.org/r/1341960205-56738-2-git-send-email-johnstul@us.ibm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit d913c02b0a172d5dca6280da5b17a407d69bbce4
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed May 30 10:54:57 2012 -0700

    timekeeping: Fix CLOCK_MONOTONIC inconsistency during leapsecond
    
    commit fad0c66c4bb836d57a5f125ecd38bed653ca863a upstream.
    
    Commit 6b43ae8a61 (ntp: Fix leap-second hrtimer livelock) broke the
    leapsecond update of CLOCK_MONOTONIC. The missing leapsecond update to
    wall_to_monotonic causes discontinuities in CLOCK_MONOTONIC.
    
    Adjust wall_to_monotonic when NTP inserted a leapsecond.
    
    Reported-by: Richard Cochran <richardcochran@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Tested-by: Richard Cochran <richardcochran@gmail.com>
    Link: http://lkml.kernel.org/r/1338400497-12420-1-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit b1e25f41094dfe0b9653c926d3c02a35c2eb249c
Merge: 857505fae884 fad0c66c4bb8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jun 8 09:11:33 2012 -0700

    Merge branch 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull leap second timer fix from Thomas Gleixner.
    
    * 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      timekeeping: Fix CLOCK_MONOTONIC inconsistency during leapsecond

commit fad0c66c4bb836d57a5f125ecd38bed653ca863a
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed May 30 10:54:57 2012 -0700

    timekeeping: Fix CLOCK_MONOTONIC inconsistency during leapsecond
    
    Commit 6b43ae8a61 (ntp: Fix leap-second hrtimer livelock) broke the
    leapsecond update of CLOCK_MONOTONIC. The missing leapsecond update to
    wall_to_monotonic causes discontinuities in CLOCK_MONOTONIC.
    
    Adjust wall_to_monotonic when NTP inserted a leapsecond.
    
    Reported-by: Richard Cochran <richardcochran@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Tested-by: Richard Cochran <richardcochran@gmail.com>
    Cc: stable@kernel.org
    Link: http://lkml.kernel.org/r/1338400497-12420-1-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 6a445c7fa739d2cde881a22f1ed38455eeb56f51
Merge: f737c7705ff0 47e1993d32d4
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu May 31 10:41:39 2012 -0700

    Merge tag 'devel-late' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull late-merged development and first fixes for arm-soc from Olof Johansson:
     "This branch contains a few development patches for Samsung and
      Versatile Express that were submitted to arm-soc near the beginning of
      the merge window.  We picked them up with the agreement that they
      would need to sit in linux-next for a while, and now they have.
    
      There are also two fixes:
       - One long-standing build breakage on ixp4xx due to missing gpiolib
         dependencies.
       - The other is for some gpio device tree changes needed on lpc32xx."
    
    * tag 'devel-late' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc:
      ARM: LPC32xx: Adjust dts files to gpio dt binding
      ixp4xx: fix compilation by adding gpiolib support
      ARM: vexpress: Remove twice included header files
      ARM: vexpress: Device Tree updates
      ARM: EXYNOS: Support suspend and resume for EXYNOS5250
      ARM: EXYNOS: Add Clock register list for save and restore
      ARM: EXYNOS: Add PMU table for EXYNOS5250
      ARM: EXYNOS: Rename of function for pm.c
      ARM: EXYNOS: Remove GIC save & restore function
      ARM: dts: Add node for interrupt combiner controller on EXYNOS5250
      ARM: S3C24XX: add support for second irq set of S3C2416
      ARM: S3C64XX: use timekeeping wrapper on cpuidle
      ARM: S3C64XX: declare the states with the new api on cpuidle
      ARM: S3C64XX: Hook up carrier class modules on Cragganmore
      ARM: S3C64XX: Initial hookup for Bells module on Cragganmore

commit d64f41d8d2dabf4d10a11f7a5d1ef8706969655f
Merge: af56e0aa35f3 b19861a2a550
Author: Olof Johansson <olof@lixom.net>
Date:   Wed May 30 16:06:39 2012 -0700

    Merge branch 'late/cleanup' into devel-late
    
    * late/cleanup:
      ARM: S3C64XX: use timekeeping wrapper on cpuidle
      ARM: S3C64XX: declare the states with the new api on cpuidle

commit 492c24e5894c65e23b11e5043c7144c2f2310abf
Author: Stephen Rothwell <sfr@canb.auug.org.au>
Date:   Sun May 27 17:43:48 2012 +0000

    sparc: fix bad merge of sparc Kconfig
    
    Fixes this sparc32 defconfig build error:
    
    timekeeping.c:(.text+0x277c4): undefined reference to `arch_gettimeoffset'
    
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit c7523a7c88db637d66841018532cb4b3ab6ab0a8
Merge: 2f78d8e24997 b80fe1015be4
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu May 24 13:29:46 2012 -0700

    Merge branch 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer updates from Thomas Gleixner.
    
    Various trivial conflict fixups in arch Kconfig due to addition of
    unrelated entries nearby.  And one slightly more subtle one for sparc32
    (new user of GENERIC_CLOCKEVENTS), fixed up as per Thomas.
    
    * 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (31 commits)
      timekeeping: Fix a few minor newline issues.
      time: remove obsolete declaration
      ntp: Fix a stale comment and a few stray newlines.
      ntp: Correct TAI offset during leap second
      timers: Fixup the Kconfig consolidation fallout
      x86: Use generic time config
      unicore32: Use generic time config
      um: Use generic time config
      tile: Use generic time config
      sparc: Use: generic time config
      sh: Use generic time config
      score: Use generic time config
      s390: Use generic time config
      openrisc: Use generic time config
      powerpc: Use generic time config
      mn10300: Use generic time config
      mips: Use generic time config
      microblaze: Use generic time config
      m68k: Use generic time config
      m32r: Use generic time config
      ...

commit d239f49d77ad9ffa442e700db3cab06d8b414cd1
Author: Richard Cochran <richardcochran@gmail.com>
Date:   Fri Apr 27 10:12:42 2012 +0200

    timekeeping: Fix a few minor newline issues.
    
    Fix a few minor newline issues.
    
    Signed-off-by: Richard Cochran <richardcochran@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 190d3b6b4ab0e1ce991e8bc94ad95f00b0dc476b
Author: Richard Cochran <richardcochran@gmail.com>
Date:   Fri May 18 16:09:53 2012 +0200

    time: remove obsolete declaration
    
    The function, timekeeping_leap_insert, was removed in commit
    6b43ae8a619d17c4935c3320d2ef9e92bdeed05d
    
    Signed-off-by: Richard Cochran <richardcochran@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit b19861a2a550fac67c8bb92ba8045ede3b6c1286
Merge: 36be50515fe2 aba607d63c71
Author: Olof Johansson <olof@lixom.net>
Date:   Sat May 19 15:44:36 2012 -0700

    Merge branch 'next/cleanup-samsung-2' of git://git.kernel.org/pub/scm/linux/kernel/git/kgene/linux-samsung into late/cleanup
    
    * 'next/cleanup-samsung-2' of git://git.kernel.org/pub/scm/linux/kernel/git/kgene/linux-samsung:
      ARM: S3C64XX: use timekeeping wrapper on cpuidle
      ARM: S3C64XX: declare the states with the new api on cpuidle

commit aba607d63c71ef9b185fc7cb9637ab70a2d88491
Author: Daniel Lezcano <daniel.lezcano@linaro.org>
Date:   Fri May 18 07:19:49 2012 +0900

    ARM: S3C64XX: use timekeeping wrapper on cpuidle
    
    The timekeeping is computed from the cpuidle core if we set
    the .en_core_tk_irqen flag. Let's use it and remove the duplicated
    code.
    
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Tested-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Kukjin Kim <kgene.kim@samsung.com>

commit 06c77b3ce1b81163d74d9d5e904de731934e8510
Author: Amit Daniel Kachhap <amit.kachhap@linaro.org>
Date:   Sat May 12 16:29:21 2012 +0900

    ARM: EXYNOS: Adapt to cpuidle core time keeping and irq enable
    
    This patch enables core cpuidle timekeeping and irq enabling and
    remove those redundant parts from the exynos cpuidle drivers
    
    Signed-off-by: Amit Daniel <amit.kachhap@linaro.org>
    Acked-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Acked-by: Robert Lee <rob.lee@linaro.org>
    Signed-off-by: Kukjin Kim <kgene.kim@samsung.com>

commit 9c75fc8c5c8c50775fc8b89418219221335b758f
Author: Jesper Nilsson <jespern@axis.com>
Date:   Thu Apr 5 11:52:55 2012 +0200

    CRIS: Remove legacy RTC drivers
    
    These old drivers are not used anymore, we use the ones in drivers/rtc.
    This allows us to remove some cruft in the CRIS timekeeping code.
    
    Signed-off-by: Jesper Nilsson <jesper.nilsson@axis.com>

commit 2e7580b0e75d771d93e24e681031a165b1d31071
Merge: d25413efa953 cf9eeac46350
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Mar 28 14:35:31 2012 -0700

    Merge branch 'kvm-updates/3.4' of git://git.kernel.org/pub/scm/virt/kvm/kvm
    
    Pull kvm updates from Avi Kivity:
     "Changes include timekeeping improvements, support for assigning host
      PCI devices that share interrupt lines, s390 user-controlled guests, a
      large ppc update, and random fixes."
    
    This is with the sign-off's fixed, hopefully next merge window we won't
    have rebased commits.
    
    * 'kvm-updates/3.4' of git://git.kernel.org/pub/scm/virt/kvm/kvm: (130 commits)
      KVM: Convert intx_mask_lock to spin lock
      KVM: x86: fix kvm_write_tsc() TSC matching thinko
      x86: kvmclock: abstract save/restore sched_clock_state
      KVM: nVMX: Fix erroneous exception bitmap check
      KVM: Ignore the writes to MSR_K7_HWCR(3)
      KVM: MMU: make use of ->root_level in reset_rsvds_bits_mask
      KVM: PMU: add proper support for fixed counter 2
      KVM: PMU: Fix raw event check
      KVM: PMU: warn when pin control is set in eventsel msr
      KVM: VMX: Fix delayed load of shared MSRs
      KVM: use correct tlbs dirty type in cmpxchg
      KVM: Allow host IRQ sharing for assigned PCI 2.3 devices
      KVM: Ensure all vcpus are consistent with in-kernel irqchip settings
      KVM: x86 emulator: Allow PM/VM86 switch during task switch
      KVM: SVM: Fix CPL updates
      KVM: x86 emulator: VM86 segments must have DPL 3
      KVM: x86 emulator: Fix task switch privilege checks
      arch/powerpc/kvm/book3s_hv.c: included linux/sched.h twice
      KVM: x86 emulator: correctly mask pmc index bits in RDPMC instruction emulation
      KVM: mmu_notifier: Flush TLBs before releasing mmu_lock
      ...

commit a1be5d649699e0eecfe5fc65130954435543cda4
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Thu Mar 1 15:35:50 2012 +0000

    ARM: riscpc: move time-acorn.c to mach-rpc
    
    Nothing but RiscPC makes use of the Acorn timekeeping code, so move
    it into mach-rpc.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

commit 5c48c873baf1a67b93d26770c8fe4d41f26f48af
Author: Robert Lee <rob.lee@linaro.org>
Date:   Tue Mar 20 15:22:49 2012 -0500

    SH: shmobile: Consolidate time keeping and irq enable
    
    Enable core cpuidle timekeeping and irq enabling and remove that
    handling from this code.
    
    Signed-off-by: Robert Lee <rob.lee@linaro.org>
    Reviewed-by: Kevin Hilman <khilman@ti.com>
    Reviewed-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Acked-by: Jean Pihet <j-pihet@ti.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

commit ee807dd89c0003a5cc0ec961132cd83542e5c30c
Author: Robert Lee <rob.lee@linaro.org>
Date:   Tue Mar 20 15:22:48 2012 -0500

    ARM: shmobile: Consolidate time keeping and irq enable
    
    Enable core cpuidle timekeeping and irq enabling and remove that
    handling from this code.
    
    Signed-off-by: Robert Lee <rob.lee@linaro.org>
    Reviewed-by: Kevin Hilman <khilman@ti.com>
    Reviewed-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Acked-by: Jean Pihet <j-pihet@ti.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

commit d13e9261ac026f90cccac1e6de3978fb18d4af7b
Author: Robert Lee <rob.lee@linaro.org>
Date:   Tue Mar 20 15:22:47 2012 -0500

    ARM: omap: Consolidate OMAP4 time keeping and irq enable
    
    Enable core cpuidle timekeeping and irq enabling and remove that
    handling from this code.
    
    Signed-off-by: Robert Lee <rob.lee@linaro.org>
    Reviewed-by: Kevin Hilman <khilman@ti.com>
    Reviewed-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Acked-by: Jean Pihet <j-pihet@ti.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

commit 6da45dce3ce4a1f1f2548c9ad9954d57ab0625b3
Author: Robert Lee <rob.lee@linaro.org>
Date:   Tue Mar 20 15:22:46 2012 -0500

    ARM: omap: Consolidate OMAP3 time keeping and irq enable
    
    Use core cpuidle timekeeping and irqen wrapper and remove that
    handling from this code.
    
    Signed-off-by: Robert Lee <rob.lee@linaro.org>
    Reviewed-by: Kevin Hilman <khilman@ti.com>
    Reviewed-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Tested-by: Jean Pihet <j-pihet@ti.com>
    Acked-by: Jean Pihet <j-pihet@ti.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

commit 19976c2a88d125aec16b9255c7197c297bbdd637
Author: Robert Lee <rob.lee@linaro.org>
Date:   Tue Mar 20 15:22:45 2012 -0500

    ARM: davinci: Consolidate time keeping and irq enable
    
    Enable core cpuidle timekeeping and irq enabling and remove that
    handling from this code.
    
    Signed-off-by: Robert Lee <rob.lee@linaro.org>
    Reviewed-by: Kevin Hilman <khilman@ti.com>
    Reviewed-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Acked-by: Jean Pihet <j-pihet@ti.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

commit b334648db0ff2d07b00d81cf033c6eddff277680
Author: Robert Lee <rob.lee@linaro.org>
Date:   Tue Mar 20 15:22:44 2012 -0500

    ARM: kirkwood: Consolidate time keeping and irq enable
    
    Enable core cpuidle timekeeping and irq enabling and remove that
    handling from this code.
    
    Signed-off-by: Robert Lee <rob.lee@linaro.org>
    Reviewed-by: Kevin Hilman <khilman@ti.com>
    Reviewed-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Acked-by: Jean Pihet <j-pihet@ti.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

commit 7e348b9012522fa0efd854d20d210d5e57fcedd1
Author: Robert Lee <rob.lee@linaro.org>
Date:   Tue Mar 20 15:22:43 2012 -0500

    ARM: at91: Consolidate time keeping and irq enable
    
    Enable core cpuidle timekeeping and irq enabling and remove that
    handling from this code.
    
    Signed-off-by: Robert Lee <rob.lee@linaro.org>
    Reviewed-by: Kevin Hilman <khilman@ti.com>
    Reviewed-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Acked-by: Jean Pihet <j-pihet@ti.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

commit e1689795a784a7c41ac4cf9032794986b095a133
Author: Robert Lee <rob.lee@linaro.org>
Date:   Tue Mar 20 15:22:42 2012 -0500

    cpuidle: Add common time keeping and irq enabling
    
    Make necessary changes to implement time keeping and irq enabling
    in the core cpuidle code.  This will allow the removal of these
    functionalities from various platform cpuidle implementations whose
    timekeeping and irq enabling follows the form in this common code.
    
    Signed-off-by: Robert Lee <rob.lee@linaro.org>
    Tested-by: Jean Pihet <j-pihet@ti.com>
    Tested-by: Amit Daniel <amit.kachhap@linaro.org>
    Tested-by: Robert Lee <rob.lee@linaro.org>
    Reviewed-by: Kevin Hilman <khilman@ti.com>
    Reviewed-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Reviewed-by: Deepthi Dharwar <deepthi@linux.vnet.ibm.com>
    Acked-by: Jean Pihet <j-pihet@ti.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

commit 161f7a7161191ab9c2e97f787829ef8dd2b95771
Merge: 2ba68940c893 a078c6d0e628
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Mar 20 10:32:09 2012 -0700

    Merge branch 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer changes for v3.4 from Ingo Molnar
    
    * 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (32 commits)
      ntp: Fix integer overflow when setting time
      math: Introduce div64_long
      cs5535-clockevt: Allow the MFGPT IRQ to be shared
      cs5535-clockevt: Don't ignore MFGPT on SMP-capable kernels
      x86/time: Eliminate unused irq0_irqs counter
      clocksource: scx200_hrt: Fix the build
      x86/tsc: Reduce the TSC sync check time for core-siblings
      timer: Fix bad idle check on irq entry
      nohz: Remove ts->Einidle checks before restarting the tick
      nohz: Remove update_ts_time_stat from tick_nohz_start_idle
      clockevents: Leave the broadcast device in shutdown mode when not needed
      clocksource: Load the ACPI PM clocksource asynchronously
      clocksource: scx200_hrt: Convert scx200 to use clocksource_register_hz
      clocksource: Get rid of clocksource_calc_mult_shift()
      clocksource: dbx500: convert to clocksource_register_hz()
      clocksource: scx200_hrt:  use pr_<level> instead of printk
      time: Move common updates to a function
      time: Reorder so the hot data is together
      time: Remove most of xtime_lock usage in timekeeping.c
      ntp: Add ntp_lock to replace xtime_locking
      ...

commit f695cf94837de53864180400cbac42cfa370426f
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Mar 14 16:38:15 2012 -0700

    time: Fix change_clocksource locking
    
    change_clocksource() fails to grab locks or call timekeeping_update(),
    which leaves a race window for time inconsistencies.
    
    This adds proper locking and a call to timekeeping_update() to fix this.
    
    CC: Andy Lutomirski <luto@amacapital.net>
    CC: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 54d0eb4d980994c0743e9a9174ed2697da97f191
Author: John Stultz <johnstul@us.ibm.com>
Date:   Wed May 4 18:16:50 2011 -0700

    clocksource: Install completely before selecting
    
    commit e05b2efb82596905ebfe88e8612ee81dec9b6592 upstream.
    
    Christian Hoffmann reported that the command line clocksource override
    with acpi_pm timer fails:
    
     Kernel command line: <SNIP> clocksource=acpi_pm
     hpet clockevent registered
     Switching to clocksource hpet
     Override clocksource acpi_pm is not HRT compatible.
     Cannot switch while in HRT/NOHZ mode.
    
    The watchdog code is what enables CLOCK_SOURCE_VALID_FOR_HRES, but we
    actually end up selecting the clocksource before we enqueue it into
    the watchdog list, so that's why we see the warning and fail to switch
    to acpi_pm timer as requested. That's particularly bad when we want to
    debug timekeeping related problems in early boot.
    
    Put the selection call last.
    
    [PG: 34 doesn't have __clocksource_register_scale, so drop that 1/2]
    
    Reported-by: Christian Hoffmann <email@christianhoffmann.info>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Link: http://lkml.kernel.org/r/%3C1304558210.2943.24.camel%40work-vm%3E
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

commit 0dd6a6edb0124e6c71931ff575b18e15ed6e8603
Author: Zachary Amsden <zamsden@gmail.com>
Date:   Fri Feb 3 15:43:56 2012 -0200

    KVM: Dont mark TSC unstable due to S4 suspend
    
    During a host suspend, TSC may go backwards, which KVM interprets
    as an unstable TSC.  Technically, KVM should not be marking the
    TSC unstable, which causes the TSC clocksource to go bad, but we
    need to be adjusting the TSC offsets in such a case.
    
    Dealing with this issue is a little tricky as the only place we
    can reliably do it is before much of the timekeeping infrastructure
    is up and running.  On top of this, we are not in a KVM thread
    context, so we may not be able to safely access VCPU fields.
    Instead, we compute our best known hardware offset at power-up and
    stash it to be applied to all VCPUs when they actually start running.
    
    Signed-off-by: Zachary Amsden <zamsden@gmail.com>
    Signed-off-by: Marcelo Tosatti <mtosatti@redhat.com>
    Signed-off-by: Avi Kivity <avi@redhat.com>

commit 9fa73472ddbcd3da87d35a7f4566eaaf345f798e
Author: Shaohua Li <shaohua.li@intel.com>
Date:   Mon Feb 6 08:57:29 2012 +0100

    block: fix ioc locking warning
    
    Meelis reported a warning:
    
    WARNING: at kernel/timer.c:1122 run_timer_softirq+0x199/0x1ec()
    Hardware name: 939Dual-SATA2
    timer: cfq_idle_slice_timer+0x0/0xaa preempt leak: 00000102 -> 00000103
    Modules linked in: sr_mod cdrom videodev media drm_kms_helper ohci_hcd ehci_hcd v4l2_compat_ioctl32 usbcore i2c_ali15x3 snd_seq drm snd_timer snd_seq
    Pid: 0, comm: swapper Not tainted 3.3.0-rc2-00110-gd125666 #176
    Call Trace:
     <IRQ>  [<ffffffff81022aaa>] warn_slowpath_common+0x7e/0x96
     [<ffffffff8114c485>] ? cfq_slice_expired+0x1d/0x1d
     [<ffffffff81022b56>] warn_slowpath_fmt+0x41/0x43
     [<ffffffff8114c526>] ? cfq_idle_slice_timer+0xa1/0xaa
     [<ffffffff8114c485>] ? cfq_slice_expired+0x1d/0x1d
     [<ffffffff8102c124>] run_timer_softirq+0x199/0x1ec
     [<ffffffff81047a53>] ? timekeeping_get_ns+0x12/0x31
     [<ffffffff810145fd>] ? apic_write+0x11/0x13
     [<ffffffff81027475>] __do_softirq+0x74/0xfa
     [<ffffffff812f337a>] call_softirq+0x1a/0x30
     [<ffffffff81002ff9>] do_softirq+0x31/0x68
     [<ffffffff810276cf>] irq_exit+0x3d/0xa3
     [<ffffffff81014aca>] smp_apic_timer_interrupt+0x6b/0x77
     [<ffffffff812f2de9>] apic_timer_interrupt+0x69/0x70
     <EOI>  [<ffffffff81040136>] ? sched_clock_cpu+0x73/0x7d
     [<ffffffff81040136>] ? sched_clock_cpu+0x73/0x7d
     [<ffffffff8100801f>] ? default_idle+0x1e/0x32
     [<ffffffff81008019>] ? default_idle+0x18/0x32
     [<ffffffff810008b1>] cpu_idle+0x87/0xd1
     [<ffffffff812de861>] rest_init+0x85/0x89
     [<ffffffff81659a4d>] start_kernel+0x2eb/0x2f8
     [<ffffffff8165926e>] x86_64_start_reservations+0x7e/0x82
     [<ffffffff81659362>] x86_64_start_kernel+0xf0/0xf7
    
    this_q == locked_q is possible. There are two problems here:
    1. In UP case, there is preemption counter issue as spin_trylock always
    successes.
    2. In SMP case, the loop breaks too earlier.
    
    Signed-off-by: Shaohua Li <shaohua.li@intel.com>
    Reported-by: Meelis Roos <mroos@linux.ee>
    Reported-by: Knut Petersen <Knut_Petersen@t-online.de>
    Tested-by: Knut Petersen <Knut_Petersen@t-online.de>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

commit 92c1d3ed4dc0b8cfb10e85ed0c9934db41efc027
Author: John Stultz <john.stultz@linaro.org>
Date:   Mon Nov 14 14:05:44 2011 -0800

    time: Remove most of xtime_lock usage in timekeeping.c
    
    Now that ntp.c's locking is reworked, we can remove most
    of the xtime_lock usage in timekeeping.c
    
    The remaining xtime_lock presence is really for jiffies access
    and the global load calculation.
    
    CC: Thomas Gleixner <tglx@linutronix.de>
    CC: Eric Dumazet <eric.dumazet@gmail.com>
    CC: Richard Cochran <richardcochran@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 70471f2f061d59375e959b4e7d47ee62121babb1
Author: John Stultz <john.stultz@linaro.org>
Date:   Mon Nov 14 12:48:10 2011 -0800

    time: Add timekeeper lock
    
    Now that all the timekeeping variables are stored in
    the timekeeper structure, add a new lock to protect the
    structure.
    
    For now, this lock nests under the xtime_lock for writes.
    
    For readers, we don't need to take xtime_lock anymore.
    
    CC: Thomas Gleixner <tglx@linutronix.de>
    CC: Eric Dumazet <eric.dumazet@gmail.com>
    CC: Richard Cochran <richardcochran@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 8fcce546be16130865550136831f71097d7fc228
Author: John Stultz <john.stultz@linaro.org>
Date:   Mon Nov 14 11:46:39 2011 -0800

    time: Cleanup global variables and move them to the top
    
    Move global xtime_lock and timekeeping_suspended values up
    to the top of timekeeping.c
    
    CC: Thomas Gleixner <tglx@linutronix.de>
    CC: Eric Dumazet <eric.dumazet@gmail.com>
    CC: Richard Cochran <richardcochran@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 376613e81ddc68f545fd5c87ffc3ad222b7abe5f
Merge: 0db49b72bce2 0518469d0a32
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jan 6 13:57:44 2012 -0800

    Merge branch 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    * 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      x86, tsc: Skip TSC synchronization checks for tsc=reliable
      clocksource: Convert tcb_clksrc to use clocksource_register_hz/khz
      clocksource: cris: Convert to clocksource_register_khz
      clocksource: xtensa: Convert to clocksource_register_hz/khz
      clocksource: um: Convert to clocksource_register_hz/khz
      clocksource: parisc: Convert to clocksource_register_hz/khz
      clocksource: m86k: Convert to clocksource_register_hz/khz
      time: x86: Replace LATCH with PIT_LATCH in i8253 clocksource driver
      time: x86: Remove CLOCK_TICK_RATE from acpi_pm clocksource driver
      time: x86: Remove CLOCK_TICK_RATE from mach_timer.h
      time: x86: Remove CLOCK_TICK_RATE from tsc code
      time: Fix spelling mistakes in new comments
      time: fix bogus comment in timekeeping_get_ns_raw

commit 5c3e9f55bbd366af73e51a12e1aa797a29532d67
Author: Hector Palacios <hector.palacios@digi.com>
Date:   Mon Nov 14 11:15:25 2011 +0100

    timekeeping: add arch_offset hook to ktime_get functions
    
    commit d004e024058a0eaca097513ce62cbcf978913e0a upstream.
    
    ktime_get and ktime_get_ts were calling timekeeping_get_ns()
    but later they were not calling arch_gettimeoffset() so architectures
    using this mechanism returned 0 ns when calling these functions.
    
    This happened for example when running Busybox's ping which calls
    syscall(__NR_clock_gettime, CLOCK_MONOTONIC, ts) which eventually
    calls ktime_get. As a result the returned ping travel time was zero.
    
    Signed-off-by: Hector Palacios <hector.palacios@digi.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit be80893d309e256fe05a1e55d440bd6188ba2748
Author: John Stultz <john.stultz@linaro.org>
Date:   Mon Oct 31 17:06:35 2011 -0400

    clocksource: Avoid selecting mult values that might overflow when adjusted
    
    commit d65670a78cdbfae94f20a9e05ec705871d7cdf2b upstream.
    
    For some frequencies, the clocks_calc_mult_shift() function will
    unfortunately select mult values very close to 0xffffffff.  This
    has the potential to overflow when NTP adjusts the clock, adding
    to the mult value.
    
    This patch adds a clocksource.maxadj value, which provides
    an approximation of an 11% adjustment(NTP limits adjustments to
    500ppm and the tick adjustment is limited to 10%), which could
    be made to the clocksource.mult value. This is then used to both
    check that the current mult value won't overflow/underflow, as
    well as warning us if the timekeeping_adjust() code pushes over
    that 11% boundary.
    
    v2: Fix max_adjustment calculation, and improve WARN_ONCE
    messages.
    
    v3: Don't warn before maxadj has actually been set
    
    CC: Yong Zhang <yong.zhang0@gmail.com>
    CC: David Daney <ddaney.cavm@gmail.com>
    CC: Thomas Gleixner <tglx@linutronix.de>
    CC: Chen Jie <chenj@lemote.com>
    CC: zhangfx <zhangfx@lemote.com>
    Reported-by: Chen Jie <chenj@lemote.com>
    Reported-by: zhangfx <zhangfx@lemote.com>
    Tested-by: Yong Zhang <yong.zhang0@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 92ad5083db212ff3c5f6d1d085d85790f7a6c42c
Author: Hector Palacios <hector.palacios@digi.com>
Date:   Mon Nov 14 11:15:25 2011 +0100

    timekeeping: add arch_offset hook to ktime_get functions
    
    commit d004e024058a0eaca097513ce62cbcf978913e0a upstream.
    
    ktime_get and ktime_get_ts were calling timekeeping_get_ns()
    but later they were not calling arch_gettimeoffset() so architectures
    using this mechanism returned 0 ns when calling these functions.
    
    This happened for example when running Busybox's ping which calls
    syscall(__NR_clock_gettime, CLOCK_MONOTONIC, ts) which eventually
    calls ktime_get. As a result the returned ping travel time was zero.
    
    Signed-off-by: Hector Palacios <hector.palacios@digi.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit e1ef77bdad527601e9e47b377cbef5bee9df8248
Author: Hector Palacios <hector.palacios@digi.com>
Date:   Mon Nov 14 11:15:25 2011 +0100

    timekeeping: add arch_offset hook to ktime_get functions
    
    commit d004e024058a0eaca097513ce62cbcf978913e0a upstream.
    
    ktime_get and ktime_get_ts were calling timekeeping_get_ns()
    but later they were not calling arch_gettimeoffset() so architectures
    using this mechanism returned 0 ns when calling these functions.
    
    This happened for example when running Busybox's ping which calls
    syscall(__NR_clock_gettime, CLOCK_MONOTONIC, ts) which eventually
    calls ktime_get. As a result the returned ping travel time was zero.
    
    Signed-off-by: Hector Palacios <hector.palacios@digi.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit c2cb211116192690605eaa70d39deb04241003e2
Author: Janusz Krzysztofik <jkrzyszt@tis.icnet.pl>
Date:   Thu Dec 1 21:13:01 2011 +0100

    ARM: OMAP1: Fix ckctl value used for dpll1 defualt rate
    
    Use the exact value found in omap1_rate_table, otherwise I have been
    experiencing issues with correct timekeeping on my Amstrad Delta.
    
    Signed-off-by: Janusz Krzysztofik <jkrzyszt@tis.icnet.pl>
    [tony@atomide.com: removed comment referencing a development branch]
    Signed-off-by: Tony Lindgren <tony@atomide.com>

commit c28800a9c3caaf387d85ac665a25ebe99e480295
Merge: ce8f55c2a0ff 27c9cd7e6016
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Nov 28 08:43:52 2011 -0800

    Merge branch 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    * 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      hrtimer: Fix extra wakeups from __remove_hrtimer()
      timekeeping: add arch_offset hook to ktime_get functions
      clocksource: Avoid selecting mult values that might overflow when adjusted
      time: Improve documentation of timekeeeping_adjust()

commit c9fad429d438fdd736ac6816b75d16c4cd626acd
Author: Dan McGee <dpmcgee@gmail.com>
Date:   Mon Oct 17 13:58:43 2011 -0500

    time: fix bogus comment in timekeeping_get_ns_raw
    
    The whole point of this function is to return a value not touched by
    NTP; unfortunately the comment got copied wholesale without adjustment
    from the timekeeping_get_ns function above.
    
    Signed-off-by: Dan McGee <dpmcgee@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit d004e024058a0eaca097513ce62cbcf978913e0a
Author: Hector Palacios <hector.palacios@digi.com>
Date:   Mon Nov 14 11:15:25 2011 +0100

    timekeeping: add arch_offset hook to ktime_get functions
    
    ktime_get and ktime_get_ts were calling timekeeping_get_ns()
    but later they were not calling arch_gettimeoffset() so architectures
    using this mechanism returned 0 ns when calling these functions.
    
    This happened for example when running Busybox's ping which calls
    syscall(__NR_clock_gettime, CLOCK_MONOTONIC, ts) which eventually
    calls ktime_get. As a result the returned ping travel time was zero.
    
    CC: stable@kernel.org
    Signed-off-by: Hector Palacios <hector.palacios@digi.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 367177e50189ab0a983b52f3d3f7eb2a1927db71
Merge: c2bc11113c50 d65670a78cdb
Author: Ingo Molnar <mingo@elte.hu>
Date:   Fri Nov 11 08:10:42 2011 +0100

    Merge branch 'formingo/3.2/tip/timers/core' of git://git.linaro.org/people/jstultz/linux into timers/core
    
    Conflicts:
            kernel/time/timekeeping.c

commit d65670a78cdbfae94f20a9e05ec705871d7cdf2b
Author: John Stultz <john.stultz@linaro.org>
Date:   Mon Oct 31 17:06:35 2011 -0400

    clocksource: Avoid selecting mult values that might overflow when adjusted
    
    For some frequencies, the clocks_calc_mult_shift() function will
    unfortunately select mult values very close to 0xffffffff.  This
    has the potential to overflow when NTP adjusts the clock, adding
    to the mult value.
    
    This patch adds a clocksource.maxadj value, which provides
    an approximation of an 11% adjustment(NTP limits adjustments to
    500ppm and the tick adjustment is limited to 10%), which could
    be made to the clocksource.mult value. This is then used to both
    check that the current mult value won't overflow/underflow, as
    well as warning us if the timekeeping_adjust() code pushes over
    that 11% boundary.
    
    v2: Fix max_adjustment calculation, and improve WARN_ONCE
    messages.
    
    v3: Don't warn before maxadj has actually been set
    
    CC: Yong Zhang <yong.zhang0@gmail.com>
    CC: David Daney <ddaney.cavm@gmail.com>
    CC: Thomas Gleixner <tglx@linutronix.de>
    CC: Chen Jie <chenj@lemote.com>
    CC: zhangfx <zhangfx@lemote.com>
    CC: stable@kernel.org
    Reported-by: Chen Jie <chenj@lemote.com>
    Reported-by: zhangfx <zhangfx@lemote.com>
    Tested-by: Yong Zhang <yong.zhang0@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit c2bc11113c50449f23c40b724fe410fc2380a8e9
Author: John Stultz <john.stultz@linaro.org>
Date:   Thu Oct 27 18:12:42 2011 -0700

    time: Improve documentation of timekeeeping_adjust()
    
    After getting a number of questions in private emails about the
    math around admittedly very complex timekeeping_adjust() and
    timekeeping_big_adjust(), I figure the code needs some better
    comments.
    
    Hopefully the explanations are clear enough and don't muddy the
    water any worse.
    
    Still needs documentation for ntp_error, but I couldn't recall
    exactly the full explanation behind the code that's there
    (although I do recall once working it out when Roman first
    proposed it). Given a bit more time I can probably work it out,
    but I don't want to hold back this documentation until then.
    
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Chen Jie <chenj@lemote.com>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Link: http://lkml.kernel.org/r/1319764362-32367-1-git-send-email-john.stultz@linaro.org
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

commit 47997d756aa2a84ab577e1b0383cc12d582fc69c
Author: Matt Fleming <matt.fleming@intel.com>
Date:   Wed Sep 21 16:08:03 2011 +0200

    x86/rtc: Don't recursively acquire rtc_lock
    
    A deadlock was introduced on x86 in commit ef68c8f87ed1 ("x86:
    Serialize EFI time accesses on rtc_lock") because efi_get_time()
    and friends can be called with rtc_lock already held by
    read_persistent_time(), e.g.:
    
     timekeeping_init()
        read_persistent_clock()     <-- acquire rtc_lock
            efi_get_time()
                phys_efi_get_time() <-- acquire rtc_lock <DEADLOCK>
    
    To fix this let's push the locking down into the get_wallclock()
    and set_wallclock() implementations.  Only the clock
    implementations that access the x86 RTC directly need to acquire
    rtc_lock, so it makes sense to push the locking down into the
    rtc, vrtc and efi code.
    
    The virtualization implementations don't require rtc_lock to be
    held because they provide their own serialization.
    
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>
    Acked-by: Jan Beulich <jbeulich@novell.com>
    Acked-by: Avi Kivity <avi@redhat.com> [for the virtualization aspect]
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: Zhang Rui <rui.zhang@intel.com>
    Cc: Josh Boyer <jwboyer@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

commit 7ccc83b0fc69d5b18602aa250c10be0d3ae920c6
Author: Christian Lamparter <chunkeey@googlemail.com>
Date:   Mon Aug 15 18:45:54 2011 +0200

    carl9170: fix timekeeping for HW_COUNTER firmwares
    
    AR9170_PWR_REG_PLL_ADDAC is used to set the main clock
    divisor which affects the AHB/CPU speed. Because this
    would interfere with the firmware internal timekeeping,
    the function has to be moved into the firmware.
    
    Signed-off-by: Christian Lamparter <chunkeey@googlemail.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

commit e9d0b97eef235eccc3df9ddb9895b35c53a8aaa2
Author: Hemant Pedanekar <hemantp@ti.com>
Date:   Wed Aug 10 13:19:35 2011 +0000

    omap: timer: Set dmtimer used as clocksource in autoreload mode
    
    If CONFIG_OMAP_32K_TIMER is not selected and dmtimer is used as clocksource, the
    timer stops counting once overflow occurs as it was not set in autoreload mode.
    This results into timekeeping failure: for example, 'sleep 1' at the shell after
    the timer counter overflow would hang.
    
    This patch sets up autoreload when starting the clocksource timer which fixes
    the above issue.
    
    Signed-off-by: Hemant Pedanekar <hemantp@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

commit 5284561b0290f09e1c6c99a18b4bc6f39b5ca4d1
Author: John Stultz <johnstul@us.ibm.com>
Date:   Wed May 4 18:16:50 2011 -0700

    clocksource: Install completely before selecting
    
    commit e05b2efb82596905ebfe88e8612ee81dec9b6592 upstream.
    
    Christian Hoffmann reported that the command line clocksource override
    with acpi_pm timer fails:
    
     Kernel command line: <SNIP> clocksource=acpi_pm
     hpet clockevent registered
     Switching to clocksource hpet
     Override clocksource acpi_pm is not HRT compatible.
     Cannot switch while in HRT/NOHZ mode.
    
    The watchdog code is what enables CLOCK_SOURCE_VALID_FOR_HRES, but we
    actually end up selecting the clocksource before we enqueue it into
    the watchdog list, so that's why we see the warning and fail to switch
    to acpi_pm timer as requested. That's particularly bad when we want to
    debug timekeeping related problems in early boot.
    
    Put the selection call last.
    
    Reported-by: Christian Hoffmann <email@christianhoffmann.info>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Link: http://lkml.kernel.org/r/%3C1304558210.2943.24.camel%40work-vm%3E
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 112ec469663e09ffc815761254b52f3ca787ce83
Merge: a99a7d1436f9 cbaa51524b32
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jul 22 16:52:18 2011 -0700

    Merge branch 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip:
      time: Fix stupid KERN_WARN compile issue
      rtc: Avoid accumulating time drift in suspend/resume
      time: Avoid accumulating time drift in suspend/resume
      time: Catch invalid timespec sleep values in __timekeeping_inject_sleeptime

commit cbaa51524b3224813814607177a00c350ee35d12
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Jul 20 15:42:55 2011 -0700

    time: Fix stupid KERN_WARN compile issue
    
    Terribly embarassing. Don't know how I committed this, but its
    KERN_WARNING not KERN_WARN.
    
    This fixes the following compile error:
    kernel/time/timekeeping.c: In function ‘__timekeeping_inject_sleeptime’:
    kernel/time/timekeeping.c:608: error: ‘KERN_WARN’ undeclared (first use in this function)
    kernel/time/timekeeping.c:608: error: (Each undeclared identifier is reported only once
    kernel/time/timekeeping.c:608: error: for each function it appears in.)
    kernel/time/timekeeping.c:608: error: expected ‘)’ before string constant
    make[2]: *** [kernel/time/timekeeping.o] Error 1
    
    Reported-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit c5d753a55ac92e09816d410cd17093813f1a904b
Author: Peter Zijlstra <a.p.zijlstra@chello.nl>
Date:   Tue Jul 19 15:07:25 2011 -0700

    sched: Add irq_{enter,exit}() to scheduler_ipi()
    
    Ensure scheduler_ipi() calls irq_{enter,exit} when it does some actual
    work. Traditionally we never did any actual work from the resched IPI
    and all magic happened in the return from interrupt path.
    
    Now that we do do some work, we need to ensure irq_{enter,exit} are
    called so that we don't confuse things.
    
    This affects things like timekeeping, NO_HZ and RCU, basically
    everything with a hook in irq_enter/exit.
    
    Explicit examples of things going wrong are:
    
      sched_clock_cpu() -- has a callback when leaving NO_HZ state to take
                        a new reading from GTOD and TSC. Without this
                        callback, time is stuck in the past.
    
      RCU -- needs in_irq() to work in order to avoid some nasty deadlocks
    
    Signed-off-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Signed-off-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>

commit cb5de2f8d0306be38f9b377b8a5c56acca7dbc3d
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Jun 1 18:18:09 2011 -0700

    time: Catch invalid timespec sleep values in __timekeeping_inject_sleeptime
    
    Arve suggested making sure we catch possible negative sleep time
    intervals that could be passed into timekeeping_inject_sleeptime.
    
    CC: Arve Hjønnevåg <arve@android.com>
    CC: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 749230b06a753a22f6ed96e5dd60815d6ab12865
Author: Jiri Olsa <jolsa@redhat.com>
Date:   Fri Jun 3 16:58:51 2011 +0200

    tracing, function_graph: Add context-info support for function_graph tracer
    
    The function_graph tracer does not follow global context-info option.
    Adding TRACE_ITER_CONTEXT_INFO trace_flags check to enable it.
    
    With following commands:
            # echo function_graph > ./current_tracer
            # echo 0 > options/context-info
            # cat trace
    
    This is what it looked like before:
    # tracer: function_graph
    #
    #     TIME        CPU  DURATION                  FUNCTION CALLS
    #      |          |     |   |                     |   |   |   |
     1)   0.079 us    |          } /* __vma_link_rb */
     1)   0.056 us    |          copy_page_range();
     1)               |          security_vm_enough_memory() {
    ...
    
    This is what it looks like now:
    # tracer: function_graph
    #
      } /* update_ts_time_stats */
      timekeeping_max_deferment();
    ...
    
    Signed-off-by: Jiri Olsa <jolsa@redhat.com>
    Link: http://lkml.kernel.org/r/1307113131-10045-6-git-send-email-jolsa@redhat.com
    Signed-off-by: Steven Rostedt <rostedt@goodmis.org>

commit ddc5b086804c873d5316de9adcbb7e45feb3c2ee
Author: John Stultz <johnstul@us.ibm.com>
Date:   Wed May 4 18:16:50 2011 -0700

    clocksource: Install completely before selecting
    
    commit e05b2efb82596905ebfe88e8612ee81dec9b6592 upstream.
    
    Christian Hoffmann reported that the command line clocksource override
    with acpi_pm timer fails:
    
     Kernel command line: <SNIP> clocksource=acpi_pm
     hpet clockevent registered
     Switching to clocksource hpet
     Override clocksource acpi_pm is not HRT compatible.
     Cannot switch while in HRT/NOHZ mode.
    
    The watchdog code is what enables CLOCK_SOURCE_VALID_FOR_HRES, but we
    actually end up selecting the clocksource before we enqueue it into
    the watchdog list, so that's why we see the warning and fail to switch
    to acpi_pm timer as requested. That's particularly bad when we want to
    debug timekeeping related problems in early boot.
    
    Put the selection call last.
    
    Reported-by: Christian Hoffmann <email@christianhoffmann.info>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Link: http://lkml.kernel.org/r/%3C1304558210.2943.24.camel%40work-vm%3E
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit a83b90b7029a52ca073e4efee437ee74853d32aa
Author: John Stultz <johnstul@us.ibm.com>
Date:   Wed May 4 18:16:50 2011 -0700

    clocksource: Install completely before selecting
    
    commit e05b2efb82596905ebfe88e8612ee81dec9b6592 upstream.
    
    Christian Hoffmann reported that the command line clocksource override
    with acpi_pm timer fails:
    
     Kernel command line: <SNIP> clocksource=acpi_pm
     hpet clockevent registered
     Switching to clocksource hpet
     Override clocksource acpi_pm is not HRT compatible.
     Cannot switch while in HRT/NOHZ mode.
    
    The watchdog code is what enables CLOCK_SOURCE_VALID_FOR_HRES, but we
    actually end up selecting the clocksource before we enqueue it into
    the watchdog list, so that's why we see the warning and fail to switch
    to acpi_pm timer as requested. That's particularly bad when we want to
    debug timekeeping related problems in early boot.
    
    Put the selection call last.
    
    Reported-by: Christian Hoffmann <email@christianhoffmann.info>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Link: http://lkml.kernel.org/r/%3C1304558210.2943.24.camel%40work-vm%3E
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit f8c47371b566131cf60263ce8fe7a593da151387
Author: John Stultz <johnstul@us.ibm.com>
Date:   Wed May 4 18:16:50 2011 -0700

    clocksource: Install completely before selecting
    
    commit e05b2efb82596905ebfe88e8612ee81dec9b6592 upstream.
    
    Christian Hoffmann reported that the command line clocksource override
    with acpi_pm timer fails:
    
     Kernel command line: <SNIP> clocksource=acpi_pm
     hpet clockevent registered
     Switching to clocksource hpet
     Override clocksource acpi_pm is not HRT compatible.
     Cannot switch while in HRT/NOHZ mode.
    
    The watchdog code is what enables CLOCK_SOURCE_VALID_FOR_HRES, but we
    actually end up selecting the clocksource before we enqueue it into
    the watchdog list, so that's why we see the warning and fail to switch
    to acpi_pm timer as requested. That's particularly bad when we want to
    debug timekeeping related problems in early boot.
    
    Put the selection call last.
    
    Reported-by: Christian Hoffmann <email@christianhoffmann.info>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Link: http://lkml.kernel.org/r/%3C1304558210.2943.24.camel%40work-vm%3E
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 78c4def67e8eebe602655a3dec9aa08f0e2f7c4b
Merge: 7e6628e4bcb3 942c3c5c3292
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu May 19 17:45:08 2011 -0700

    Merge branch 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip:
      hrtimer: Make lookup table const
      RTC: Disable CONFIG_RTC_CLASS from being built as a module
      timers: Fix alarmtimer build issues when CONFIG_RTC_CLASS=n
      timers: Remove delayed irqwork from alarmtimers implementation
      timers: Improve alarmtimer comments and minor fixes
      timers: Posix interface for alarm-timers
      timers: Introduce in-kernel alarm-timer interface
      timers: Add rb_init_node() to allow for stack allocated rb nodes
      time: Add timekeeping_inject_sleeptime

commit e05b2efb82596905ebfe88e8612ee81dec9b6592
Author: John Stultz <johnstul@us.ibm.com>
Date:   Wed May 4 18:16:50 2011 -0700

    clocksource: Install completely before selecting
    
    Christian Hoffmann reported that the command line clocksource override
    with acpi_pm timer fails:
    
     Kernel command line: <SNIP> clocksource=acpi_pm
     hpet clockevent registered
     Switching to clocksource hpet
     Override clocksource acpi_pm is not HRT compatible.
     Cannot switch while in HRT/NOHZ mode.
    
    The watchdog code is what enables CLOCK_SOURCE_VALID_FOR_HRES, but we
    actually end up selecting the clocksource before we enqueue it into
    the watchdog list, so that's why we see the warning and fail to switch
    to acpi_pm timer as requested. That's particularly bad when we want to
    debug timekeeping related problems in early boot.
    
    Put the selection call last.
    
    Reported-by: Christian Hoffmann <email@christianhoffmann.info>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Cc: stable@kernel.org # 32...
    Link: http://lkml.kernel.org/r/%3C1304558210.2943.24.camel%40work-vm%3E
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 304529b1b6f8612ccbb4582e997051b48b94f4a4
Author: John Stultz <john.stultz@linaro.org>
Date:   Fri Apr 1 14:32:09 2011 -0700

    time: Add timekeeping_inject_sleeptime
    
    Some platforms cannot implement read_persistent_clock, as
    their RTC devices are only accessible when interrupts are enabled.
    This keeps them from being used by the timekeeping code on resume
    to measure the time in suspend.
    
    The RTC layer tries to work around this, by calling do_settimeofday
    on resume after irqs are reenabled to set the time properly. However,
    this only corrects CLOCK_REALTIME, and does not properly adjust
    the sleep time value. This causes btime in /proc/stat to be incorrect
    as well as making the new CLOCK_BOTTTIME inaccurate.
    
    This patch resolves the issue by introducing a new timekeeping hook
    to allow the RTC layer to inject the sleep time on resume.
    
    The code also checks to make sure that read_persistent_clock is
    nonfunctional before setting the sleep time, so that should the RTC's
    HCTOSYS option be configured in on a system that does support
    read_persistent_clock we will not increase the total_sleep_time twice.
    
    CC: Arve Hjønnevåg <arve@android.com>
    CC: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 4352d9d44b935e4d000be6ec89ddb55c2bf35f24
Author: Richard Cochran <richardcochran@gmail.com>
Date:   Mon Apr 4 08:31:23 2011 -0700

    ntp: fix non privileged system time shifting
    
    The ADJ_SETOFFSET bit added in commit 094aa188 ("ntp: Add ADJ_SETOFFSET
    mode bit") also introduced a way for any user to change the system time.
    Sneaky or buggy calls to adjtimex() could set
    
        ADJ_OFFSET_SS_READ | ADJ_SETOFFSET
    
    which would result in a successful call to timekeeping_inject_offset().
    This patch fixes the issue by adding the capability check.
    
    Signed-off-by: Richard Cochran <richard.cochran@omicron.at>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit 16c29dafcc86024048f1dbb8349d31cb22c7c55a
Merge: dc50eddb2f3a d47d81c0e9ab
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Mar 25 21:07:59 2011 -0700

    Merge branch 'syscore' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/suspend-2.6
    
    * 'syscore' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/suspend-2.6:
      Introduce ARCH_NO_SYSDEV_OPS config option (v2)
      cpufreq: Use syscore_ops for boot CPU suspend/resume (v2)
      KVM: Use syscore_ops instead of sysdev class and sysdev
      PCI / Intel IOMMU: Use syscore_ops instead of sysdev class and sysdev
      timekeeping: Use syscore_ops instead of sysdev class and sysdev
      x86: Use syscore_ops instead of sysdev classes and sysdevs

commit e1a85b2c519551d4792180cdab4074d7e99bf2c9
Author: Rafael J. Wysocki <rjw@rjwysocki.net>
Date:   Wed Mar 23 22:16:04 2011 +0100

    timekeeping: Use syscore_ops instead of sysdev class and sysdev
    
    The timekeeping subsystem uses a sysdev class and a sysdev for
    executing timekeeping_suspend() after interrupts have been turned off
    on the boot CPU (during system suspend) and for executing
    timekeeping_resume() before turning on interrupts on the boot CPU
    (during system resume).  However, since both of these functions
    ignore their arguments, the entire mechanism may be replaced with a
    struct syscore_ops object which is simpler.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>

commit 3a83ea6ecd31cbf4330b2c0a616e3d2539d5b616
Author: Joe Perches <joe@perches.com>
Date:   Tue Mar 22 16:34:34 2011 -0700

    MAINTAINERS: remove unused TIMEKEEPING timekeeping.h
    
    Commit 88606e80da0 ("MAINTAINERS: Update timer related entries") added a
    file pattern that didn't actually exist.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit 420c1c572d4ceaa2f37b6311b7017ac6cf049fe2
Merge: 9620639b7ea3 6e6823d17b15
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Mar 15 18:53:35 2011 -0700

    Merge branch 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip: (62 commits)
      posix-clocks: Check write permissions in posix syscalls
      hrtimer: Remove empty hrtimer_init_hres_timer()
      hrtimer: Update hrtimer->state documentation
      hrtimer: Update base[CLOCK_BOOTTIME].offset correctly
      timers: Export CLOCK_BOOTTIME via the posix timers interface
      timers: Add CLOCK_BOOTTIME hrtimer base
      time: Extend get_xtime_and_monotonic_offset() to also return sleep
      time: Introduce get_monotonic_boottime and ktime_get_boottime
      hrtimers: extend hrtimer base code to handle more then 2 clockids
      ntp: Remove redundant and incorrect parameter check
      mn10300: Switch do_timer() to xtimer_update()
      posix clocks: Introduce dynamic clocks
      posix-timers: Cleanup namespace
      posix-timers: Add support for fd based clocks
      x86: Add clock_adjtime for x86
      posix-timers: Introduce a syscall for clock tuning.
      time: Splitout compat timex accessors
      ntp: Add ADJ_SETOFFSET mode bit
      time: Introduce timekeeping_inject_offset
      posix-timer: Update comment
      ...
    
    Fix up new system-call-related conflicts in
            arch/x86/ia32/ia32entry.S
            arch/x86/include/asm/unistd_32.h
            arch/x86/include/asm/unistd_64.h
            arch/x86/kernel/syscall_table_32.S
    (name_to_handle_at()/open_by_handle_at() vs clock_adjtime()), and some
    due to movement of get_jiffies_64() in:
            kernel/time.c

commit db1c1cce4a653dcbe6949c72ae7b9f42cab1b929
Author: Richard Cochran <richardcochran@gmail.com>
Date:   Fri Feb 18 10:07:25 2011 +0100

    ntp: Remove redundant and incorrect parameter check
    
    The ADJ_SETOFFSET code redundantly checks the range of the nanoseconds
    field of the time value. This field is checked again in the subsequent
    call to timekeeping_inject_offset(). Also, as is, the check will not
    detect whether the number of microseconds is out of range.
    
    Let timekeeping_inject_offset() do the error checking.
    
    Signed-off-by: Richard Cochran <richard.cochran@omicron.at>
    Cc: johnstul@us.ibm.com
    LKML-Reference: <20110218090724.GA2924@riccoc20.at.omicron.at>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit c528f7c6c208f1fae6b4025957173dec045e5f21
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Feb 1 13:52:17 2011 +0000

    time: Introduce timekeeping_inject_offset
    
    This adds a kernel-internal timekeeping interface to add or subtract
    a fixed amount from CLOCK_REALTIME. This makes it so kernel users or
    interfaces trying to do so do not have to read the time, then add an
    offset and then call settimeofday(), which adds some extra error in
    comparision to just simply adding the offset in the kernel timekeeping
    core.
    
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Richard Cochran <richard.cochran@omicron.at>
    LKML-Reference: <20110201134419.584311693@linutronix.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 48cf76f7104f655bbd48a75c7759dce82c3e1ab6
Author: Torben Hohn <torbenh@gmx.de>
Date:   Thu Jan 27 15:59:05 2011 +0100

    time: Provide get_xtime_and_monotonic_offset()
    
    The hrtimer code accesses timekeeping variables under
    xtime_lock. Provide a sensible accessor function and use it.
    
    [ tglx: Removed the conditionals, unused variable, fixed codingstyle
            and massaged changelog ]
    
    Signed-off-by: Torben Hohn <torbenh@gmx.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: johnstul@us.ibm.com
    Cc: yong.zhang0@gmail.com
    Cc: hch@infradead.org
    LKML-Reference: <20110127145905.23248.30458.stgit@localhost>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 871cf1e5f2a17702f58539a3af8b18fc8666ad4c
Author: Torben Hohn <torbenh@gmx.de>
Date:   Thu Jan 27 15:58:55 2011 +0100

    time: Move do_timer() to kernel/time/timekeeping.c
    
    do_timer() is primary timekeeping related. calc_global_load() is
    called from do_timer() as well, but that's more for historical
    reasons.
    
    [ tglx: Fixed up the calc_global_load() reject andmassaged changelog ]
    
    Signed-off-by: Torben Hohn <torbenh@gmx.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: johnstul@us.ibm.com
    Cc: yong.zhang0@gmail.com
    Cc: hch@infradead.org
    LKML-Reference: <20110127145855.23248.56933.stgit@localhost>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit f9ee7f60d6f37ae0184812b4c59b3869f875768b
Merge: 16c102036208 1161ec944916 76d1f7bfcd58 afa14e7c553e 7c46d8da09df
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jan 15 12:45:00 2011 -0800

    Merge branches 'core-fixes-for-linus', 'x86-fixes-for-linus', 'timers-fixes-for-linus' and 'perf-fixes-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'core-fixes-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip:
      rcu: avoid pointless blocked-task warnings
      rcu: demote SRCU_SYNCHRONIZE_DELAY from kernel-parameter status
      rtmutex: Fix comment about why new_owner can be NULL in wake_futex_pi()
    
    * 'x86-fixes-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip:
      x86, olpc: Add missing Kconfig dependencies
      x86, mrst: Set correct APB timer IRQ affinity for secondary cpu
      x86: tsc: Fix calibration refinement conditionals to avoid divide by zero
      x86, ia64, acpi: Clean up x86-ism in drivers/acpi/numa.c
    
    * 'timers-fixes-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip:
      timekeeping: Make local variables static
      time: Rename misnamed minsec argument of clocks_calc_mult_shift()
    
    * 'perf-fixes-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip:
      tracing: Remove syscall_exit_fields
      tracing: Only process module tracepoints once
      perf record: Add "nodelay" mode, disabled by default
      perf sched: Fix list of events, dropping unsupported ':r' modifier
      Revert "perf tools: Emit clearer message for sys_perf_event_open ENOENT return"
      perf top: Fix annotate segv
      perf evsel: Fix order of event list deletion

commit e2c18e49a0d4f822ffc29fb4958943beb1ff08b7
Author: Alexander Gordeev <lasaine@lvk.cs.msu.su>
Date:   Wed Jan 12 17:00:57 2011 -0800

    pps: capture MONOTONIC_RAW timestamps as well
    
    MONOTONIC_RAW clock timestamps are ideally suited for frequency
    calculation and also fit well into the original NTP hardpps design.  Now
    phase and frequency can be adjusted separately: the former based on
    REALTIME clock and the latter based on MONOTONIC_RAW clock.
    
    A new function getnstime_raw_and_real is added to timekeeping subsystem to
    capture both timestamps at the same time and atomically.
    
    Signed-off-by: Alexander Gordeev <lasaine@lvk.cs.msu.su>
    Acked-by: John Stultz <johnstul@us.ibm.com>
    Cc: Rodolfo Giometti <giometti@enneenne.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit afa14e7c553ebe45844d76208f66017a43abd0e2
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jan 11 17:59:38 2011 -0600

    timekeeping: Make local variables static
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: John Stultz <johnstul@us.ibm.com>
    LKML-Reference: <0D753D10438DA54287A00B027084269764CE0E54B7@AUSP01VMBX24.collaborationhost.net>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 88606e80da0e8d862a42ee19e5bb60b01b940ea7
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Dec 14 21:37:13 2010 +0100

    MAINTAINERS: Update timer related entries
    
    Bring the existing file list up to date and add a new entry for
    timekeeping and ntp. Assign John Stultz to this new entry so he gets
    all the blame :)
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: John Stultz <johnstul@us.ibm.com>

commit f392eb2546170e539668a5ab8df6c1254d15a201
Author: Zachary Amsden <zamsden@redhat.com>
Date:   Thu Aug 19 22:07:33 2010 -1000

    KVM: x86: Add timekeeping documentation
    
    Basic informational document about x86 timekeeping and how KVM
    is affected.
    
    Signed-off-by: Zachary Amsden <zamsden@redhat.com>
    Signed-off-by: Marcelo Tosatti <mtosatti@redhat.com>

commit 0d3a7582aa527a5d0107039d24571faa57114bff
Author: Jason Wessel <jason.wessel@windriver.com>
Date:   Mon Aug 9 14:20:09 2010 -0700

    timekeeping: Fix overflow in rawtime tv_nsec on 32 bit archs
    
    commit deda2e81961e96be4f2c09328baca4710a2fd1a0 upstream.
    
    The tv_nsec is a long and when added to the shifted interval it can wrap
    and become negative which later causes looping problems in the
    getrawmonotonic().  The edge case occurs when the system has slept for
    a short period of time of ~2 seconds.
    
    A trace printk of the values in this patch illustrate the problem:
    
    ftrace time stamp: log
    43.716079: logarithmic_accumulation: raw: 3d0913 tv_nsec d687faa
    43.718513: logarithmic_accumulation: raw: 3d0913 tv_nsec da588bd
    43.722161: logarithmic_accumulation: raw: 3d0913 tv_nsec de291d0
    46.349925: logarithmic_accumulation: raw: 7a122600 tv_nsec e1f9ae3
    46.349930: logarithmic_accumulation: raw: 1e848980 tv_nsec 8831c0e3
    
    The kernel starts looping at 46.349925 in the getrawmonotonic() due to
    the negative value from adding the raw value to tv_nsec.
    
    A simple solution is to accumulate into a u64, and then normalize it
    to a timespec_t.
    
    Signed-off-by: Jason Wessel <jason.wessel@windriver.com>
     [ Reworked variable names and simplified some of the code. - John ]
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 8aa3149405e33cec4f866cfe7f92c2b40d259613
Author: Lin Ming <ming.m.lin@intel.com>
Date:   Tue Nov 17 13:49:50 2009 +0800

    timekeeping: Fix clock_gettime vsyscall time warp
    
    commit 0696b711e4be45fa104c12329f617beb29c03f78 upstream.
    
    Since commit 0a544198 "timekeeping: Move NTP adjusted clock multiplier
    to struct timekeeper" the clock multiplier of vsyscall is updated with
    the unmodified clock multiplier of the clock source and not with the
    NTP adjusted multiplier of the timekeeper.
    
    This causes user space observerable time warps:
    new CLOCK-warp maximum: 120 nsecs,  00000025c337c537 -> 00000025c337c4bf
    
    Add a new argument "mult" to update_vsyscall() and hand in the
    timekeeping internal NTP adjusted multiplier.
    
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Cc: "Zhang Yanmin" <yanmin_zhang@linux.intel.com>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Tony Luck <tony.luck@intel.com>
    LKML-Reference: <1258436990.17765.83.camel@minggr.sh.intel.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Kurt Garloff <garloff@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit deda2e81961e96be4f2c09328baca4710a2fd1a0
Author: Jason Wessel <jason.wessel@windriver.com>
Date:   Mon Aug 9 14:20:09 2010 -0700

    timekeeping: Fix overflow in rawtime tv_nsec on 32 bit archs
    
    The tv_nsec is a long and when added to the shifted interval it can wrap
    and become negative which later causes looping problems in the
    getrawmonotonic().  The edge case occurs when the system has slept for
    a short period of time of ~2 seconds.
    
    A trace printk of the values in this patch illustrate the problem:
    
    ftrace time stamp: log
    43.716079: logarithmic_accumulation: raw: 3d0913 tv_nsec d687faa
    43.718513: logarithmic_accumulation: raw: 3d0913 tv_nsec da588bd
    43.722161: logarithmic_accumulation: raw: 3d0913 tv_nsec de291d0
    46.349925: logarithmic_accumulation: raw: 7a122600 tv_nsec e1f9ae3
    46.349930: logarithmic_accumulation: raw: 1e848980 tv_nsec 8831c0e3
    
    The kernel starts looping at 46.349925 in the getrawmonotonic() due to
    the negative value from adding the raw value to tv_nsec.
    
    A simple solution is to accumulate into a u64, and then normalize it
    to a timespec_t.
    
    Signed-off-by: Jason Wessel <jason.wessel@windriver.com>
     [ Reworked variable names and simplified some of the code. - John ]
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit b62ad9ab181a67207a4c8c373461b587c4861a68
Merge: af390084359a b29230769e34
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Aug 6 13:18:29 2010 -0700

    Merge branch 'timers-timekeeping-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'timers-timekeeping-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip:
      um: Fix read_persistent_clock fallout
      kgdb: Do not access xtime directly
      powerpc: Clean up obsolete code relating to decrementer and timebase
      powerpc: Rework VDSO gettimeofday to prevent time going backwards
      clocksource: Add __clocksource_updatefreq_hz/khz methods
      x86: Convert common clocksources to use clocksource_register_hz/khz
      timekeeping: Make xtime and wall_to_monotonic static
      hrtimer: Cleanup direct access to wall_to_monotonic
      um: Convert to use read_persistent_clock
      timkeeping: Fix update_vsyscall to provide wall_to_monotonic offset
      powerpc: Cleanup xtime usage
      powerpc: Simplify update_vsyscall
      time: Kill off CONFIG_GENERIC_TIME
      time: Implement timespec_add
      x86: Fix vtime/file timestamp inconsistencies
    
    Trivial conflicts in Documentation/feature-removal-schedule.txt
    
    Much less trivial conflicts in arch/powerpc/kernel/time.c resolved as
    per Thomas' earlier merge commit 47916be4e28c ("Merge branch
    'powerpc.cherry-picks' into timers/clocksource")

commit 47916be4e28c3d6fdb97dd8fb887d1d9b3145b9d
Merge: 852db46d55e8 d75d68cfef49
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Jul 28 21:49:22 2010 +0200

    Merge branch 'powerpc.cherry-picks' into timers/clocksource
    
    Conflicts:
            arch/powerpc/kernel/time.c
    
    Reason: The powerpc next tree contains two commits which conflict with
    the timekeeping changes:
    
    8fd63a9e powerpc: Rework VDSO gettimeofday to prevent time going backwards
    c1aa687d powerpc: Clean up obsolete code relating to decrementer and timebase
    
    John Stultz identified them and provided the conflict resolution.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit d75d68cfef4936ddf38d2694ae2f7d1f7c45db05
Author: Paul Mackerras <paulus@samba.org>
Date:   Sun Jun 20 19:04:14 2010 +0000

    powerpc: Clean up obsolete code relating to decrementer and timebase
    
    Since the decrementer and timekeeping code was moved over to using
    the generic clockevents and timekeeping infrastructure, several
    variables and functions have been obsolete and effectively unused.
    This deletes them.
    
    In particular, wakeup_decrementer() is no longer needed since the
    generic code reprograms the decrementer as part of the process of
    resuming the timekeeping code, which happens during sysdev resume.
    Thus the wakeup_decrementer calls in the suspend_enter methods for
    52xx platforms have been removed.  The call in the powermac cpu
    frequency change code has been replaced by set_dec(1), which will
    cause a timer interrupt as soon as interrupts are enabled, and the
    generic code will then reprogram the decrementer with the correct
    value.
    
    This also simplifies the generic_suspend_en/disable_irqs functions
    and makes them static since they are not referenced outside time.c.
    The preempt_enable/disable calls are removed because the generic
    code has disabled all but the boot cpu at the point where these
    functions are called, so we can't be moved to another cpu.
    
    Signed-off-by: Paul Mackerras <paulus@samba.org>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

commit 0fb86b06298b6cd3205cac2e68a499f269282dac
Author: John Stultz <johnstul@us.ibm.com>
Date:   Tue Jul 13 17:56:26 2010 -0700

    timekeeping: Make xtime and wall_to_monotonic static
    
    This patch makes xtime and wall_to_monotonic static, as planned in
    Documentation/feature-removal-schedule.txt. This will allow for
    further cleanups to the timekeeping core.
    
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    LKML-Reference: <1279068988-21864-10-git-send-email-johnstul@us.ibm.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 7615856ebfee52b080c22d263ca4debbd0df0ac1
Author: John Stultz <johnstul@us.ibm.com>
Date:   Tue Jul 13 17:56:23 2010 -0700

    timkeeping: Fix update_vsyscall to provide wall_to_monotonic offset
    
    update_vsyscall() did not provide the wall_to_monotoinc offset,
    so arch specific implementations tend to reference wall_to_monotonic
    directly. This limits future cleanups in the timekeeping core, so
    this patch fixes the update_vsyscall interface to provide
    wall_to_monotonic, allowing wall_to_monotonic to be made static
    as planned in Documentation/feature-removal-schedule.txt
    
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Anton Blanchard <anton@samba.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Tony Luck <tony.luck@intel.com>
    LKML-Reference: <1279068988-21864-7-git-send-email-johnstul@us.ibm.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit c1aa687d499a8bce55cb8cf962f0b72c0f933f14
Author: Paul Mackerras <paulus@samba.org>
Date:   Sun Jun 20 19:04:14 2010 +0000

    powerpc: Clean up obsolete code relating to decrementer and timebase
    
    Since the decrementer and timekeeping code was moved over to using
    the generic clockevents and timekeeping infrastructure, several
    variables and functions have been obsolete and effectively unused.
    This deletes them.
    
    In particular, wakeup_decrementer() is no longer needed since the
    generic code reprograms the decrementer as part of the process of
    resuming the timekeeping code, which happens during sysdev resume.
    Thus the wakeup_decrementer calls in the suspend_enter methods for
    52xx platforms have been removed.  The call in the powermac cpu
    frequency change code has been replaced by set_dec(1), which will
    cause a timer interrupt as soon as interrupts are enabled, and the
    generic code will then reprogram the decrementer with the correct
    value.
    
    This also simplifies the generic_suspend_en/disable_irqs functions
    and makes them static since they are not referenced outside time.c.
    The preempt_enable/disable calls are removed because the generic
    code has disabled all but the boot cpu at the point where these
    functions are called, so we can't be moved to another cpu.
    
    Signed-off-by: Paul Mackerras <paulus@samba.org>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

commit 410f6abbf04138c8ac7cb1317ef1cf4fdb3a0f3a
Author: Ian Campbell <ian.campbell@citrix.com>
Date:   Wed May 19 16:19:25 2010 +0100

    xen: ensure timer tick is resumed even on CPU driving the resume
    
    commit cd52e17ea8278f8449b6174a8e5ed439a2e44ffb upstream.
    
    The core suspend/resume code is run from stop_machine on CPU0 but
    parts of the suspend/resume machinery (including xen_arch_resume) are
    run on whichever CPU happened to schedule the xenwatch kernel thread.
    
    As part of the non-core resume code xen_arch_resume is called in order
    to restart the timer tick on non-boot processors. The boot processor
    itself is taken care of by core timekeeping code.
    
    xen_arch_resume uses smp_call_function which does not call the given
    function on the current processor. This means that we can end up with
    one CPU not receiving timer ticks if the xenwatch thread happened to
    be scheduled on CPU > 0.
    
    Use on_each_cpu instead of smp_call_function to ensure the timer tick
    is resumed everywhere.
    
    Signed-off-by: Ian Campbell <ian.campbell@citrix.com>
    Acked-by: Jeremy Fitzhardinge <jeremy@goop.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 11c8bbaaa1a47d0362d1156db2d916c39d46780c
Author: Ian Campbell <ian.campbell@citrix.com>
Date:   Wed May 19 16:19:25 2010 +0100

    xen: ensure timer tick is resumed even on CPU driving the resume
    
    commit cd52e17ea8278f8449b6174a8e5ed439a2e44ffb upstream.
    
    The core suspend/resume code is run from stop_machine on CPU0 but
    parts of the suspend/resume machinery (including xen_arch_resume) are
    run on whichever CPU happened to schedule the xenwatch kernel thread.
    
    As part of the non-core resume code xen_arch_resume is called in order
    to restart the timer tick on non-boot processors. The boot processor
    itself is taken care of by core timekeeping code.
    
    xen_arch_resume uses smp_call_function which does not call the given
    function on the current processor. This means that we can end up with
    one CPU not receiving timer ticks if the xenwatch thread happened to
    be scheduled on CPU > 0.
    
    Use on_each_cpu instead of smp_call_function to ensure the timer tick
    is resumed everywhere.
    
    Signed-off-by: Ian Campbell <ian.campbell@citrix.com>
    Acked-by: Jeremy Fitzhardinge <jeremy@goop.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 0f58db21025d979e38db691861985ebc931551b1
Author: Ian Campbell <ian.campbell@citrix.com>
Date:   Wed May 19 16:19:25 2010 +0100

    xen: ensure timer tick is resumed even on CPU driving the resume
    
    commit cd52e17ea8278f8449b6174a8e5ed439a2e44ffb upstream.
    
    The core suspend/resume code is run from stop_machine on CPU0 but
    parts of the suspend/resume machinery (including xen_arch_resume) are
    run on whichever CPU happened to schedule the xenwatch kernel thread.
    
    As part of the non-core resume code xen_arch_resume is called in order
    to restart the timer tick on non-boot processors. The boot processor
    itself is taken care of by core timekeeping code.
    
    xen_arch_resume uses smp_call_function which does not call the given
    function on the current processor. This means that we can end up with
    one CPU not receiving timer ticks if the xenwatch thread happened to
    be scheduled on CPU > 0.
    
    Use on_each_cpu instead of smp_call_function to ensure the timer tick
    is resumed everywhere.
    
    Signed-off-by: Ian Campbell <ian.campbell@citrix.com>
    Acked-by: Jeremy Fitzhardinge <jeremy@goop.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 856f19145104dcab5b1415c1936c9aa81d83ba04
Author: Tero Kristo <tero.kristo@nokia.com>
Date:   Wed Jun 9 13:53:05 2010 +0300

    omap: DMTIMER: Ack pending interrupt always when stopping a timer
    
    The kernel timer queue is being run currently from a GP timer running in a one
    shot mode, which works in a way that when it expires, it will also stop.
    Usually during this situation, the interrupt handler will ack the interrupt,
    load a new value to the timer and start it again. During suspend, the
    situation is slightly different, as we disable interrupts just before
    timekeeping is suspended, which leaves a small window where the timer can
    expire before it is stopped, and will leave the interrupt flag pending.
    This pending interrupt will prevent ARM sleep entry, thus now we ack it always
    when we are attempting to stop a timer.
    
    Signed-off-by: Tero Kristo <tero.kristo@nokia.com>
    Acked-by: Kevin Hilman <khilman@deeprootsystems.com>
    [tony@atomide.com: removed the ifdef to make the patch cover omap1 also]
    Signed-off-by: Tony Lindgren <tony@atomide.com>

commit cd52e17ea8278f8449b6174a8e5ed439a2e44ffb
Author: Ian Campbell <ian.campbell@citrix.com>
Date:   Wed May 19 16:19:25 2010 +0100

    xen: ensure timer tick is resumed even on CPU driving the resume
    
    The core suspend/resume code is run from stop_machine on CPU0 but
    parts of the suspend/resume machinery (including xen_arch_resume) are
    run on whichever CPU happened to schedule the xenwatch kernel thread.
    
    As part of the non-core resume code xen_arch_resume is called in order
    to restart the timer tick on non-boot processors. The boot processor
    itself is taken care of by core timekeeping code.
    
    xen_arch_resume uses smp_call_function which does not call the given
    function on the current processor. This means that we can end up with
    one CPU not receiving timer ticks if the xenwatch thread happened to
    be scheduled on CPU > 0.
    
    Use on_each_cpu instead of smp_call_function to ensure the timer tick
    is resumed everywhere.
    
    Signed-off-by: Ian Campbell <ian.campbell@citrix.com>
    Acked-by: Jeremy Fitzhardinge <jeremy@goop.org>
    Cc: Stable Kernel <stable@kernel.org> # .32.x

commit c3ed9ea4ab460080dea9449c709be9316c670c72
Merge: 0fed2b5cb4c0 f00e047efdf9
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon May 24 07:59:17 2010 -0700

    Merge branch 'timers-for-linus-urgent' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'timers-for-linus-urgent' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip:
      timers: Fix slack calculation for expired timers
      timekeeping: Fix timezone update

commit bd45b7a385c5ffd82c11a1d51880be18559e5ad9
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun May 23 08:14:45 2010 +0200

    timekeeping: Fix timezone update
    
    commit 64ce4c2f (time: Clean up warp_clock()) breaks the timezone
    update in a very subtle way. To avoid the direct access to timekeeping
    internals it adds the timezone delta to the current time with
    timespec_add_safe(). This works nicely when the timezone delta is > 0.
    If timezone delta is < 0 then the wrap check in timespec_add_safe()
    triggers and timespec_add_safe() returns TIME_MAX and screws up
    timekeeping completely.
    
    The comment above timespec_add_safe() says:
        It's assumed that both values are valid (>= 0)
    
    Add the timezone seconds adjustment directly.
    
    Reported-by: Rafael J. Wysocki <rjw@sisk.pl>
    Tested-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 19cc36c0f0457e5c6629ec24036fbbe8255c88ec
Author: Frederic Weisbecker <fweisbec@gmail.com>
Date:   Thu May 13 02:30:49 2010 +0200

    lockup_detector: Fix forgotten config conversion
    
    Fix forgotten CONFIG_DETECT_SOFTLOCKUP -> CONFIG_LOCKUP_DETECTOR
    in sched.h
    
    Fixes:
            arch/x86/built-in.o: In function `touch_nmi_watchdog':
            (.text+0x1bd59): undefined reference to `touch_softlockup_watchdog'
            kernel/built-in.o: In function `show_state_filter':
            (.text+0x10d01): undefined reference to `touch_all_softlockup_watchdogs'
            kernel/built-in.o: In function `sched_clock_idle_wakeup_event':
            (.text+0x362f9): undefined reference to `touch_softlockup_watchdog'
            kernel/built-in.o: In function `timekeeping_resume':
            timekeeping.c:(.text+0x38757): undefined reference to `touch_softlockup_watchdog'
            kernel/built-in.o: In function `tick_nohz_handler':
            tick-sched.c:(.text+0x3e5b9): undefined reference to `touch_softlockup_watchdog'
            kernel/built-in.o: In function `tick_sched_timer':
            tick-sched.c:(.text+0x3e671): undefined reference to `touch_softlockup_watchdog'
            kernel/built-in.o: In function `tick_check_idle':
            (.text+0x3e90b): undefined reference to `touch_softlockup_watchdog'
    
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Don Zickus <dzickus@redhat.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Cyrill Gorcunov <gorcunov@gmail.com>
    Cc: Eric Paris <eparis@redhat.com>
    Cc: Randy Dunlap <randy.dunlap@oracle.com>

commit d7e81c269db899b800e0963dc4aceece1f82a680
Author: John Stultz <johnstul@us.ibm.com>
Date:   Fri May 7 18:07:38 2010 -0700

    clocksource: Add clocksource_register_hz/khz interface
    
    How to pick good mult/shift pairs has always been difficult to
    describe to folks writing clocksource drivers, since it requires
    careful tradeoffs in adjustment accuracy vs overflow limits.
    
    Now, with the clocks_calc_mult_shift function, its much
    easier. However, not many clocksources have converted to using that
    function, and there is still the issue of the max interval length
    assumption being made by each clocksource driver independently.
    
    So this patch simplifies the registration process by having
    clocksources be registered with a hz/khz value and the registration
    function taking care of setting mult/shift.
    
    This should take most of the confusion out of writing a clocksource
    driver.
    
    Additionally it also keeps the shift size tradeoff (more accuracy vs
    longer possible nohz times) centralized so the timekeeping core can
    keep track of the assumptions being made.
    
    [ tglx: Coding style and comments fixed ]
    
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    LKML-Reference: <1273280858-30143-1-git-send-email-johnstul@us.ibm.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 157a1a27d5921fc94db8c14e0d01363d13de99b5
Author: Hendrik Brueckner <brueckner@linux.vnet.ibm.com>
Date:   Thu Apr 22 17:17:06 2010 +0200

    [S390] vdso: use ntp adjusted clock multiplier
    
    Commit "timekeeping: Fix clock_gettime vsyscall time warp" (0696b711e)
    introduced the new parameter "mult" to update_vsyscall(). This parameter
    contains the internal NTP adjusted clock multiplier.
    
    The s390x vdso did not use this adjusted multiplier.  Instead, it used
    the constant clock multiplier for gettimeofday() and clock_gettime()
    variants.  This may result in observable time warps as explained in
    commit 0696b711e.
    
    Make the NTP adjusted clock multiplier available to the s390x vdso
    implementation and use it for time calculations.
    
    Cc: <stable@kernel.org>
    Signed-off-by: Hendrik Brueckner <brueckner@linux.vnet.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

commit 9e6776b6653afe1df9b362d4667a82070a1dd5f1
Author: John Stultz <johnstul@us.ibm.com>
Date:   Mon Mar 1 12:34:43 2010 -0800

    timekeeping: Prevent oops when GENERIC_TIME=n
    
    commit ad6759fbf35d104dbf573cd6f4c6784ad6823f7e upstream.
    
    Aaro Koskinen reported an issue in kernel.org bugzilla #15366, where
    on non-GENERIC_TIME systems, accessing
    /sys/devices/system/clocksource/clocksource0/current_clocksource
    results in an oops.
    
    It seems the timekeeper/clocksource rework missed initializing the
    curr_clocksource value in the !GENERIC_TIME case.
    
    Thanks to Aaro for reporting and diagnosing the issue as well as
    testing the fix!
    
    Reported-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    LKML-Reference: <1267475683.4216.61.camel@localhost.localdomain>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 74b176077272028d0a88eddd59e630abc37cd475
Author: John Stultz <johnstul@us.ibm.com>
Date:   Mon Mar 1 12:34:43 2010 -0800

    timekeeping: Prevent oops when GENERIC_TIME=n
    
    commit ad6759fbf35d104dbf573cd6f4c6784ad6823f7e upstream.
    
    Aaro Koskinen reported an issue in kernel.org bugzilla #15366, where
    on non-GENERIC_TIME systems, accessing
    /sys/devices/system/clocksource/clocksource0/current_clocksource
    results in an oops.
    
    It seems the timekeeper/clocksource rework missed initializing the
    curr_clocksource value in the !GENERIC_TIME case.
    
    Thanks to Aaro for reporting and diagnosing the issue as well as
    testing the fix!
    
    Reported-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    LKML-Reference: <1267475683.4216.61.camel@localhost.localdomain>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 830ec0458c390f29c6c99e1ff7feab9e36368d12
Author: John Stultz <johnstul@us.ibm.com>
Date:   Thu Mar 18 14:47:30 2010 -0700

    time: Fix accumulation bug triggered by long delay.
    
    The logarithmic accumulation done in the timekeeping has some overflow
    protection that limits the max shift value. That means it will take
    more then shift loops to accumulate all of the cycles. This causes
    the shift decrement to underflow, which causes the loop to never exit.
    
    The simplest fix would be simply to do a:
            if (shift)
                    shift--;
    
    However that is not optimal, as we know the cycle offset is larger
    then the interval << shift, the above would make shift drop to zero,
    then we would be spinning for quite awhile accumulating at interval
    chunks at a time.
    
    Instead, this patch only decreases shift if the offset is smaller
    then cycle_interval << shift.  This makes sure we accumulate using
    the largest chunks possible without overflowing tick_length, and limits
    the number of iterations through the loop.
    
    This issue was found and reported by Sonic Zhang, who also tested the fix.
    Many thanks your explanation and testing!
    
    Reported-by: Sonic Zhang <sonic.adi@gmail.com>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Tested-by: Sonic Zhang <sonic.adi@gmail.com>
    LKML-Reference: <1268948850-5225-1-git-send-email-johnstul@us.ibm.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 64d5aea30062ce9f3ce7c62be8ae65e776cbfee2
Merge: 3836a03d978e ad6759fbf35d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Mar 12 16:27:08 2010 -0800

    Merge branch 'timers-fixes-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'timers-fixes-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip:
      timekeeping: Prevent oops when GENERIC_TIME=n

commit 104f9c471ffb425fd081074ef31521b38d77592a
Author: John Stultz <johnstul@us.ibm.com>
Date:   Thu Mar 11 14:11:39 2010 -0800

    xtensa: Fix unnecessary setting of xtime
    
    xtensa supports read_persisitent_clock(), so there is no reason for
    the arch specific code to be setting xtime.  Setting xtime will be
    done by the generic timekeeping code.
    
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Cc: Chris Zankel <chris@zankel.net>
    Cc: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit c4507257764ae0387f0d8c2ca57808f37e4c9439
Author: John Stultz <johnstul@us.ibm.com>
Date:   Thu Mar 11 14:04:47 2010 -0800

    time: Clean up direct xtime usage in xen
    
    Cleanup xen's direct use of internal timekeeping values.
    
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Acked-by: Jeremy Fitzhardinge <jeremy@xensource.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 64ce4c2f5252f25798117fa80a027993163d6d84
Author: John Stultz <johnstul@us.ibm.com>
Date:   Thu Mar 11 14:04:47 2010 -0800

    time: Clean up warp_clock()
    
    warp_clock() currently accesses timekeeping internal state directly, which
    is unnecessary.  Convert it to use the proper timekeeping interfaces.
    
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit b1e2ba8da973535e62839915403b6f5450081d8c
Author: John Stultz <johnstul@us.ibm.com>
Date:   Mon Mar 8 12:25:19 2010 +0100

    [S390] Cleanup xtime usage
    
    This replaces direct xtime usage in the s390 arch with timekeeping accessors,
    so we can further clean up the timekeeping core.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

commit ad6759fbf35d104dbf573cd6f4c6784ad6823f7e
Author: John Stultz <johnstul@us.ibm.com>
Date:   Mon Mar 1 12:34:43 2010 -0800

    timekeeping: Prevent oops when GENERIC_TIME=n
    
    Aaro Koskinen reported an issue in kernel.org bugzilla #15366, where
    on non-GENERIC_TIME systems, accessing
    /sys/devices/system/clocksource/clocksource0/current_clocksource
    results in an oops.
    
    It seems the timekeeper/clocksource rework missed initializing the
    curr_clocksource value in the !GENERIC_TIME case.
    
    Thanks to Aaro for reporting and diagnosing the issue as well as
    testing the fix!
    
    Reported-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: stable@kernel.org
    LKML-Reference: <1267475683.4216.61.camel@localhost.localdomain>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 7e1b584774c6168ca5b27c340fbeff8f67651e4f
Author: John Stultz <johnstul@us.ibm.com>
Date:   Thu Jan 28 20:20:44 2010 -0800

    ntp: Cleanup xtime references in ntp.c
    
    ntp.c doesn't need to access timekeeping internals directly, so change
    xtime references to use the get_seconds() timekeeping interface.
    
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Cc: richard@rsk.demon.co.uk
    LKML-Reference: <1264738844-21935-1-git-send-email-johnstul@us.ibm.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 7b7422a566aa0dc1e582ce263d4c7ff4a772700a
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jan 26 12:51:10 2010 +0100

    clocksource: Prevent potential kgdb dead lock
    
    commit 0f8e8ef7 (clocksource: Simplify clocksource watchdog resume
    logic) introduced a potential kgdb dead lock. When the kernel is
    stopped by kgdb inside code which holds watchdog_lock then kgdb dead
    locks in clocksource_resume_watchdog().
    
    clocksource_resume_watchdog() is called from kbdg via
    clocksource_touch_watchdog() to avoid that the clock source watchdog
    marks TSC unstable after the kernel has been stopped.
    
    Solve this by replacing spin_lock with a spin_trylock and just return
    in case the lock is held. Not resetting the watchdog might result in
    TSC becoming marked unstable, but that's an acceptable penalty for
    using kgdb.
    
    The timekeeping is anyway easily screwed up by kgdb when the system
    uses either jiffies or a clock source which wraps in short intervals
    (e.g. pm_timer wraps about every 4.6s), so we really do not have to
    worry about that occasional TSC marked unstable side effect.
    
    The second caller of clocksource_resume_watchdog() is
    clocksource_resume(). The trylock is safe here as well because the
    system is UP at this point, interrupts are disabled and nothing else
    can hold watchdog_lock().
    
    Reported-by: Jason Wessel <jason.wessel@windriver.com>
    LKML-Reference: <1264480000-6997-4-git-send-email-jason.wessel@windriver.com>
    Cc: kgdb-bugreport@lists.sourceforge.net
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: John Stultz <johnstul@us.ibm.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 4f4e65d2484811210a2826fa9d59712c7fcf1b49
Merge: f6760aa02419 5c3db36bf68b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jan 25 18:56:12 2010 -0800

    Merge branch 'omap-fixes-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tmlind/linux-omap-2.6
    
    * 'omap-fixes-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tmlind/linux-omap-2.6: (25 commits)
      OMAP2/3: DMTIMER: Clear pending interrupts when stopping a timer
      PM debug: Fix warning when no CONFIG_DEBUG_FS
      OMAP3: PM: DSS PM_WKEN to refill DMA
      OMAP: timekeeping: time should not stop during suspend
      OMAP3: PM: Force write last pad config register into save area
      OMAP: omap3_pm_get_suspend_state() error ignored in pwrdm_suspend_get()
      OMAP3: PM: Enable wake-up from McBSP2, 3 and 4 modules
      OMAP3: PM debug: fix build error when !CONFIG_DEBUG_FS
      OMAP3: PM: Removing redundant and potentially dangerous PRCM configration
      OMAP3: Fixed ARM aux ctrl register save/restore
      OMAP3: CPUidle: Fixed timer resolution
      OMAP3: PM: Remove duplicate code blocks
      OMAP3: PM: Disable interrupt controller AUTOIDLE before WFI
      OMAP3: PM: Enable system control module autoidle
      OMAP3: PM: Ack pending interrupts before entering suspend
      omap: Enable GPMC clock in gpmc_init
      OMAP1 clock: fix for "BUG: spinlock lockup on CPU#0"
      OMAP4: clocks: Fix the clksel_rate struct DPLL divs
      OMAP4: PRCM: Fix the base address for CHIRONSS reg defines
      OMAP: dma_chan[lch_head].flag & OMAP_DMA_ACTIVE tested twice in omap_dma_unlink_lch()
      ...

commit a602f0f2f04f150fa1f7312b9e601e8e1a5afe10
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Thu Dec 17 12:43:29 2009 +0100

    arm/{pxa,sa1100,nomadik}: Don't disable irqs in set_next_event and set_mode
    
    These functions are called with irqs already off.  This commit removes
    the calls to raw_local_irq_save and raw_local_irq_restore on platforms
    that don't have to use a shared interrupt for their timekeeping.
    
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>

commit d92cfcbe39fdb2328a28b5505f31cb8be40fc339
Author: Kevin Hilman <khilman@deeprootsystems.com>
Date:   Thu Sep 24 16:35:48 2009 -0700

    OMAP: timekeeping: time should not stop during suspend
    
    During suspend, the kernel timekeeping subsystem is shut down.  Before
    suspend and upon resume, it uses a weak function
    read_persistent_clock() to determine the amount of time that elapsed
    during suspend.
    
    This function was not implemented on OMAP, so from the timekeeping
    subsystem perspective (and thus userspace as well) it appeared that no
    time elapsed during suspend.
    
    This patch uses the 32k sync timer as a the persistent clock.
    
    NOTE: This does *NOT* fully handle wrapping of the 32k sync timer, so
          more than one wrapping of the 32k sync timer during suspend may
          cause problems.  Also note there are not interrupts when the 32k
          sync timer wraps, so something else has to be done.
    
    Reported-by: Jon Hunter <jon-hunter@ti.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

commit 83f57a11d84460dfe2afdb5a8bc759953428e38b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Dec 22 14:10:37 2009 -0800

    Revert "time: Remove xtime_cache"
    
    This reverts commit 7bc7d637452383d56ba4368d4336b0dde1bb476d, as
    requested by John Stultz. Quoting John:
    
     "Petr Titěra reported an issue where he saw odd atime regressions with
      2.6.33 where there were a full second worth of nanoseconds in the
      nanoseconds field.
    
      He also reviewed the time code and narrowed down the problem: unhandled
      overflow of the nanosecond field caused by rounding up the
      sub-nanosecond accumulated time.
    
      Details:
    
       * At the end of update_wall_time(), we currently round up the
      sub-nanosecond portion of accumulated time when storing it into xtime.
      This was added to avoid time inconsistencies caused when the
      sub-nanosecond portion was truncated when storing into xtime.
      Unfortunately we don't handle the possible second overflow caused by
      that rounding.
    
       * Previously the xtime_cache code hid this overflow by normalizing the
      xtime value when storing into the xtime_cache.
    
       * We could try to handle the second overflow after the rounding up, but
      since this affects the timekeeping's internal state, this would further
      complicate the next accumulation cycle, causing small errors in ntp
      steering. As much as I'd like to get rid of it, the xtime_cache code is
      known to work.
    
       * The correct fix is really to include the sub-nanosecond portion in the
      timekeeping accessor function, so we don't need to round up at during
      accumulation. This would greatly simplify the accumulation code.
      Unfortunately, we can't do this safely until the last three
      non-GENERIC_TIME arches (sparc32, arm, cris) are converted  (those
      patches are in -mm) and we kill off the spots where arches set xtime
      directly. This is all 2.6.34 material, so I think reverting the
      xtime_cache change is the best approach for now.
    
      Many thanks to Petr for both reporting and finding the issue!"
    
    Reported-by: Petr Titěra <P.Titera@century.cz>
    Requested-by: john stultz <johnstul@us.ibm.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit d22926677f2244a6b68e7ea21d6c9338659c17aa
Author: Kevin Hilman <khilman@deeprootsystems.com>
Date:   Tue Dec 8 16:34:23 2009 -0700

    OMAP: omap_device: use read_persistent_clock() instead of getnstimeofday()
    
    During suspend and resume, when omap_device deactivation and
    activation is happening, the timekeeping subsystem has likely already
    been suspended.  Thus getnstimeofday() will fail and trigger a WARN().
    
    Use read_persistent_clock() instead of getnstimeofday() to avoid this.
    
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

commit fbf07eac7bf21c262143194181bd97c5d18b8ceb
Merge: 60d8ce2cd6c2 8629ea2eaba8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Dec 8 19:28:09 2009 -0800

    Merge branch 'timers-for-linus-urgent' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'timers-for-linus-urgent' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip:
      hrtimer: Fix /proc/timer_list regression
      itimers: Fix racy writes to cpu_itimer fields
      timekeeping: Fix clock_gettime vsyscall time warp

commit 0696b711e4be45fa104c12329f617beb29c03f78
Author: Lin Ming <ming.m.lin@intel.com>
Date:   Tue Nov 17 13:49:50 2009 +0800

    timekeeping: Fix clock_gettime vsyscall time warp
    
    Since commit 0a544198 "timekeeping: Move NTP adjusted clock multiplier
    to struct timekeeper" the clock multiplier of vsyscall is updated with
    the unmodified clock multiplier of the clock source and not with the
    NTP adjusted multiplier of the timekeeper.
    
    This causes user space observerable time warps:
    new CLOCK-warp maximum: 120 nsecs,  00000025c337c537 -> 00000025c337c4bf
    
    Add a new argument "mult" to update_vsyscall() and hand in the
    timekeeping internal NTP adjusted multiplier.
    
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Cc: "Zhang Yanmin" <yanmin_zhang@linux.intel.com>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Tony Luck <tony.luck@intel.com>
    LKML-Reference: <1258436990.17765.83.camel@minggr.sh.intel.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 978d7eb31d44de34a7f71e04ed4158f3f854688d
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Sun Nov 1 19:11:03 2009 +0000

    powerpc: Avoid giving out RTC dates below EPOCH
    
    Doing so causes xtime to be negative which crashes the timekeeping
    code in funny ways when doing suspend/resume
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

commit 89133f93508137231251543d1732da638e6022e1
Author: Martin Schwidefsky <schwidefsky@de.ibm.com>
Date:   Thu Sep 24 17:29:52 2009 +0200

    clocksource: Resume clocksource without taking the clocksource mutex
    
    git commit 75c5158f70c065b9 converted the clocksource spinlock to a
    mutex. This causes the following BUG:
    
    BUG: sleeping function called from invalid context at
    kernel/mutex.c:280 in_atomic(): 0, irqs_disabled(): 1, pid: 2473,
    name: pm-suspend 2 locks held by pm-suspend/2473:
     #0:  (&buffer->mutex){......}, at: [<ffffffff8115ab13>]
    sysfs_write_file+0x3c/0x137
     #1:  (pm_mutex){......}, at: [<ffffffff810865b5>]
    enter_state+0x39/0x130 Pid: 2473, comm: pm-suspend Not tainted 2.6.31
    #1 Call Trace:
     [<ffffffff810792f0>] ? __debug_show_held_locks+0x22/0x24
     [<ffffffff8104a2ef>] __might_sleep+0x107/0x10b
     [<ffffffff8141fca9>] mutex_lock_nested+0x25/0x43
     [<ffffffff81073537>] clocksource_resume+0x1c/0x60
     [<ffffffff81072902>] timekeeping_resume+0x1e/0x1c8
     [<ffffffff812aee62>] __sysdev_resume+0x25/0xcf
     [<ffffffff812aef79>] sysdev_resume+0x6d/0xae
     [<ffffffff810864f8>] suspend_devices_and_enter+0x12b/0x1af
     [<ffffffff8108665b>] enter_state+0xdf/0x130
     [<ffffffff81085dc3>] state_store+0xb6/0xd3
     [<ffffffff81204c73>] kobj_attr_store+0x17/0x19
     [<ffffffff8115abd2>] sysfs_write_file+0xfb/0x137
     [<ffffffff811057d2>] vfs_write+0xae/0x10b
     [<ffffffff81208392>] ? __up_read+0x1a/0x7f
     [<ffffffff811058ef>] sys_write+0x4a/0x6e
     [<ffffffff81011b82>] system_call_fastpath+0x16/0x1b
    
    clocksource_resume is called early in the resume process, there is
    only one cpu, no processes are running and the interrupts are
    disabled. It is therefore possible to resume the clocksources
    without taking the clocksource mutex.
    
    Reported-by: Xiaotian Feng <xtfeng@gmail.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Tested-by: Michal Schmidt <mschmidt@redhat.com>
    Cc: Xiaotian Feng <xtfeng@gmail.com>
    Cc: John Stultz <johnstul@us.ibm.com>
    LKML-Reference: <20090924172952.49697825@mschwide.boeblingen.de.ibm.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

commit 6399c087458859cddff2d6b46befb95b866df3e0
Author: Alok Kataria <akataria@vmware.com>
Date:   Fri Sep 4 13:13:39 2009 -0700

    x86: Print the hypervisor returned tsc_khz during boot
    
    On an AMD-64 system the processor frequency that is printed during
    system boot, may be different than the tsc frequency that was
    returned by the hypervisor, due to the value returned from
    calibrate_cpu.
    
    For debugging timekeeping or other related issues it might be
    better to get the tsc_khz value returned by the hypervisor.
    
    The patch below now prints the tsc frequency that the VMware
    hypervisor returned.
    
    Signed-off-by: Alok N Kataria <akataria@vmware.com>
    LKML-Reference: <1252095219.12518.13.camel@ank32.eng.vmware.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

commit 288f023e708efd89d77ce9acf977a33a623ae83d
Author: Arjan van de Ven <arjan@infradead.org>
Date:   Sat Sep 19 13:35:33 2009 +0200

    tracing, x86, cpuidle: Move the end point of a C state in the power tracer
    
    The "end of a C state" trace point currently happens before
    the code runs that corrects the TSC for having stopped during idle.
    
    The result of this is that the timestamp of the end-of-C-state event
    is garbage on cpus where the TSC stops during idle.
    
    This patch moves the end point of the C state to after the timekeeping
    engine of the kernel has been corrected.
    
    Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>
    Cc: Len Brown <len.brown@intel.com>
    Cc: fweisbec@gmail.com
    Cc: peterz@infradead.org
    Cc: Paul Mackerras <paulus@samba.org>
    LKML-Reference: <20090919133533.139c2a46@infradead.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

commit a03fdb7612874834d6847107198712d18b5242c7
Merge: 202c4675c55d 12e09337fe23
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Sep 18 09:15:24 2009 -0700

    Merge branch 'timers-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'timers-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip: (34 commits)
      time: Prevent 32 bit overflow with set_normalized_timespec()
      clocksource: Delay clocksource down rating to late boot
      clocksource: clocksource_select must be called with mutex locked
      clocksource: Resolve cpu hotplug dead lock with TSC unstable, fix crash
      timers: Drop a function prototype
      clocksource: Resolve cpu hotplug dead lock with TSC unstable
      timer.c: Fix S/390 comments
      timekeeping: Fix invalid getboottime() value
      timekeeping: Fix up read_persistent_clock() breakage on sh
      timekeeping: Increase granularity of read_persistent_clock(), build fix
      time: Introduce CLOCK_REALTIME_COARSE
      x86: Do not unregister PIT clocksource on PIT oneshot setup/shutdown
      clocksource: Avoid clocksource watchdog circular locking dependency
      clocksource: Protect the watchdog rating changes with clocksource_mutex
      clocksource: Call clocksource_change_rating() outside of watchdog_lock
      timekeeping: Introduce read_boot_clock
      timekeeping: Increase granularity of read_persistent_clock()
      timekeeping: Update clocksource with stop_machine
      timekeeping: Add timekeeper read_clock helper functions
      timekeeping: Move NTP adjusted clock multiplier to struct timekeeper
      ...
    
    Fix trivial conflict due to MIPS lemote -> loongson renaming.

commit 2882b0c63ac6085fd5c18959240b6f7d6ffb8d5b
Author: Manuel Lauss <manuel.lauss@googlemail.com>
Date:   Sat Aug 22 18:09:27 2009 +0200

    MIPS: Alchemy: get rid of allow_au1k_wait
    
    Eliminate the 'allow_au1k_wait' variable.  MIPS kernel installs the
    Alchemy-specific wait code before timer initialization;  if the C0
    timer must be used for timekeeping the wait function is set to NULL
    which means no wait implementation is available.
    
    As a sideeffect, the 'wait instruction available' output in
    /proc/cpuinfo now correctly indicates whether 'wait' is usable.
    
    Run-tested on DB1200.
    
    Signed-off-by: Manuel Lauss <manuel.lauss@gmail.com>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

commit 12e09337fe238981cb0c87543306e23775d1a143
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Sep 14 23:37:40 2009 +0200

    time: Prevent 32 bit overflow with set_normalized_timespec()
    
    set_normalized_timespec() nsec argument is of type long. The recent
    timekeeping changes of ktime_get_ts() feed
    
            ts->tv_nsec + tomono.tv_nsec + nsecs
    
    to set_normalized_timespec(). On 32 bit machines that sum can be
    larger than (1 << 31) and therefor result in a negative value which
    screws up the result completely.
    
    Make the nsec argument of set_normalized_timespec() s64 to fix the
    problem at hand. This also prevents similar problems for future users
    of set_normalized_timespec().
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Carsten Emde <carsten.emde@osadl.org>
    LKML-Reference: <new-submission>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: John Stultz <johnstul@us.ibm.com>

commit 331b93f41dff21c8f95709032cb184fb82bf2003
Author: Peter 'p2' De Schrijver <peter.de-schrijver@nokia.com>
Date:   Wed Oct 15 18:13:48 2008 +0300

    OMAP: PM: Add pm-debug counters
    
    This patch provides the debugfs entries and a function which will be
    called by the PM code to register the time spent per domain per
    state. Also some new fields are added to the powerdomain struct to
    keep the time information.
    
    NOTE: As of v2.6.29, using getnstimeofday() after drivers are
    suspended is no longer safe since the timekeeping subsystem is also
    suspended as part of the suspend process.  Instead use sched_clock()
    which on OMAP returns the 32k SYNC timer in nanoseconds.
    
    Also, do not print out status for meta powerdomains (dpll*)
    
    Signed-off-by: Peter 'p2' De Schrijver <peter.de-schrijver@nokia.com>
    Signed-off-by: Tero Kristo <tero.kristo@nokia.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

commit 7285dd7fd375763bfb8ab1ac9cf3f1206f503c16
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Aug 28 20:25:24 2009 +0200

    clocksource: Resolve cpu hotplug dead lock with TSC unstable
    
    Martin Schwidefsky analyzed it:
    To register a clocksource the clocksource_mutex is acquired and if
    necessary timekeeping_notify is called to install the clocksource as
    the timekeeper clock. timekeeping_notify uses stop_machine which needs
    to take cpu_add_remove_lock mutex.
    Starting a new cpu is done with the cpu_add_remove_lock mutex held.
    native_cpu_up checks the tsc of the new cpu and if the tsc is no good
    clocksource_change_rating is called. Which needs the clocksource_mutex
    and the deadlock is complete.
    
    The solution is to replace the TSC via the clocksource watchdog
    mechanism. Mark the TSC as unstable and schedule the watchdog work so
    it gets removed in the watchdog thread context.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    LKML-Reference: <new-submission>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: John Stultz <johnstul@us.ibm.com>

commit 36d47481b3824b661b464077db95d447984df799
Author: Hiroshi Shimamoto <h-shimamoto@ct.jp.nec.com>
Date:   Tue Aug 25 15:08:30 2009 +0900

    timekeeping: Fix invalid getboottime() value
    
    Don't use timespec_add_safe() with wall_to_monotonic, because
    wall_to_monotonic has negative values which will cause overflow
    in timespec_add_safe(). That makes btime in /proc/stat invalid.
    
    Signed-off-by: Hiroshi Shimamoto <h-shimamoto@ct.jp.nec.com>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: John Stultz <johnstul@us.ibm.com>
    Cc: Daniel Walker <dwalker@fifo99.com>
    LKML-Reference: <4A937FDE.4050506@ct.jp.nec.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

commit 0ceb4c3e3f1ccaf121851e33c3ea269b8ad0f219
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue Aug 25 07:32:39 2009 +0900

    timekeeping: Fix up read_persistent_clock() breakage on sh
    
    The recent commit "timekeeping: Increase granularity of
    read_persistent_clock()" introduced read_persistent_clock()
    rework which inadvertently broke the sh conversion:
    
            arch/sh/kernel/time.c:45: error: passing argument 1 of 'rtc_sh_get_time' from incompatible pointer type
            distcc[13470] ERROR: compile arch/sh/kernel/time.c on sprygo/32 failed
            make[2]: *** [arch/sh/kernel/time.o] Error 1
    
    This trivial fix gets it working again.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    LKML-Reference: <20090824223239.GB20832@linux-sh.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

commit d90246cd8e0141332a8ab09c3c1800cc2028a686
Author: Martin Schwidefsky <schwidefsky@de.ibm.com>
Date:   Sat Aug 22 22:23:13 2009 +0200

    timekeeping: Increase granularity of read_persistent_clock(), build fix
    
    Fix the following build problem on powerpc:
    
      arch/powerpc/kernel/time.c: In function 'read_persistent_clock':
      arch/powerpc/kernel/time.c:788: error: 'return' with a value, in function returning void
      arch/powerpc/kernel/time.c:791: error: 'return' with a value, in function returning void
    
    Reported-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: dwalker@fifo99.com
    Cc: johnstul@us.ibm.com
    LKML-Reference: <20090822222313.74b9619c@skybase>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

commit 8cab02dc3c58a12235c6d463ce684dded9696848
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Aug 20 18:19:45 2009 +0200

    x86: Do not unregister PIT clocksource on PIT oneshot setup/shutdown
    
    This basically reverts commit 1a0c009ac (x86: unregister PIT
    clocksource when PIT is disabled) because the problem which was tried
    to address with that patch has been solved by commit 3f68535ada
    (clocksource: sanity check sysfs clocksource changes).
    
    The problem addressed by the original patch is that PIT could be
    selected as clocksource after the system switched the PIT off or set
    the PIT into one shot mode which would result in complete timekeeping
    wreckage.
    
    Now with the sysfs sanity check in place PIT cannot be selected again
    when the system is in oneshot mode. The system will not switch to one
    shot mode as long as PIT is installed because PIT is not suitable for
    one shot.
    
    The shutdown case which happens when the lapic timer is installed is
    covered by the fact that init_pit_clocksource() is called after the
    lapic timer take over and then does not install the PIT clocksource
    at all.
    
    We should have done the sanity checks back then, but ...
    
    This also solves the locking problem which was reported vs. the
    clocksource rework.
    
    LKML-Reference: <new-submission>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: john stultz <johnstul@us.ibm.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 23970e389e9cee43c4b41023935e1417271708b2
Author: Martin Schwidefsky <schwidefsky@de.ibm.com>
Date:   Fri Aug 14 15:47:32 2009 +0200

    timekeeping: Introduce read_boot_clock
    
    Add the new function read_boot_clock to get the exact time the system
    has been started. For architectures without support for exact boot
    time a new weak function is added that returns 0.  Use the exact boot
    time to initialize wall_to_monotonic, or xtime if the read_boot_clock
    returned 0.
    
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Acked-by: John Stultz <johnstul@us.ibm.com>
    Cc: Daniel Walker <dwalker@fifo99.com>
    LKML-Reference: <20090814134811.296703241@de.ibm.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit d4f587c67fc39e0030ddd718675e252e208da4d7
Author: Martin Schwidefsky <schwidefsky@de.ibm.com>
Date:   Fri Aug 14 15:47:31 2009 +0200

    timekeeping: Increase granularity of read_persistent_clock()
    
    The persistent clock of some architectures (e.g. s390) have a
    better granularity than seconds. To reduce the delta between the
    host clock and the guest clock in a virtualized system change the
    read_persistent_clock function to return a struct timespec.
    
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Acked-by: John Stultz <johnstul@us.ibm.com>
    Cc: Daniel Walker <dwalker@fifo99.com>
    LKML-Reference: <20090814134811.013873340@de.ibm.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 75c5158f70c065b9704b924503d96e8297838f79
Author: Martin Schwidefsky <schwidefsky@de.ibm.com>
Date:   Fri Aug 14 15:47:30 2009 +0200

    timekeeping: Update clocksource with stop_machine
    
    update_wall_time calls change_clocksource HZ times per second to check
    if a new clock source is available. In close to 100% of all calls
    there is no new clock. Replace the tick based check by an update done
    with stop_machine.
    
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Acked-by: John Stultz <johnstul@us.ibm.com>
    Cc: Daniel Walker <dwalker@fifo99.com>
    LKML-Reference: <20090814134810.711836357@de.ibm.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 2ba2a3054fdffc8e6452f4ee120760322a6fbd43
Author: Martin Schwidefsky <schwidefsky@de.ibm.com>
Date:   Fri Aug 14 15:47:29 2009 +0200

    timekeeping: Add timekeeper read_clock helper functions
    
    Add timekeeper_read_clock_ntp and timekeeper_read_clock_raw and use
    them for getnstimeofday, ktime_get, ktime_get_ts and getrawmonotonic.
    
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Acked-by: John Stultz <johnstul@us.ibm.com>
    Cc: Daniel Walker <dwalker@fifo99.com>
    LKML-Reference: <20090814134810.435105711@de.ibm.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 0a54419836254a27baecd9037103171bcbabaf67
Author: Martin Schwidefsky <schwidefsky@de.ibm.com>
Date:   Fri Aug 14 15:47:28 2009 +0200

    timekeeping: Move NTP adjusted clock multiplier to struct timekeeper
    
    The clocksource structure has two multipliers, the unmodified multiplier
    clock->mult_orig and the NTP corrected multiplier clock->mult. The NTP
    multiplier is misplaced in the struct clocksource, this is private
    information of the timekeeping code. Add the mult field to the struct
    timekeeper to contain the NTP corrected value, keep the unmodifed
    multiplier in clock->mult and remove clock->mult_orig.
    
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Acked-by: John Stultz <johnstul@us.ibm.com>
    Cc: Daniel Walker <dwalker@fifo99.com>
    LKML-Reference: <20090814134810.149047645@de.ibm.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 23ce72117c714baab794e66c8daf343bf6a912bf
Author: Martin Schwidefsky <schwidefsky@de.ibm.com>
Date:   Fri Aug 14 15:47:27 2009 +0200

    timekeeping: Add xtime_shift and ntp_error_shift to struct timekeeper
    
    The xtime_nsec value in the timekeeper structure is shifted by a few
    bits to improve precision. This happens to be the same value as the
    clock->shift. To improve readability add xtime_shift to the timekeeper
    and use it instead of the clock->shift. Likewise add ntp_error_shift
    and replace all (NTP_SCALE_SHIFT - clock->shift) expressions.
    
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Acked-by: John Stultz <johnstul@us.ibm.com>
    Cc: Daniel Walker <dwalker@fifo99.com>
    LKML-Reference: <20090814134809.871899606@de.ibm.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 155ec60226ae0ae2aadaa57c951a58a359331030
Author: Martin Schwidefsky <schwidefsky@de.ibm.com>
Date:   Fri Aug 14 15:47:26 2009 +0200

    timekeeping: Introduce struct timekeeper
    
    Add struct timekeeper to keep the internal values timekeeping.c needs
    in regard to the currently selected clock source. This moves the
    timekeeping intervals, xtime_nsec and the ntp error value from struct
    clocksource to struct timekeeper. The raw_time is removed from the
    clocksource as well. It gets treated like xtime as a global variable.
    Eventually xtime raw_time should be moved to struct timekeeper.
    
    [ tglx: minor cleanup ]
    
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Acked-by: John Stultz <johnstul@us.ibm.com>
    Cc: Daniel Walker <dwalker@fifo99.com>
    LKML-Reference: <20090814134809.613209842@de.ibm.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 1be396794897f80bfc8774719ba60309a9e3d374
Author: Martin Schwidefsky <schwidefsky@de.ibm.com>
Date:   Fri Aug 14 15:47:20 2009 +0200

    timekeeping: Move reset of cycle_last for tsc clocksource to tsc
    
    change_clocksource resets the cycle_last value to zero then sets it to
    a value read from the clocksource. The reset to zero is required only
    for the TSC clocksource to make the read_tsc function work after a
    resume. The reason is that the TSC read function uses cycle_last to
    detect backwards going TSCs. In the resume case cycle_last contains
    the TSC value from the last update before the suspend. On resume the
    TSC starts counting from 0 again and would trip over the cycle_last
    comparison.
    
    This is subtle and surprising. Move the reset to a resume function in
    the tsc code.
    
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: John Stultz <johnstul@us.ibm.com>
    Cc: Daniel Walker <dwalker@fifo99.com>
    LKML-Reference: <20090814134808.142191175@de.ibm.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit a0f7d48bfb95a4c5172a2756dbc4b82afc8e9ae4
Author: Martin Schwidefsky <schwidefsky@de.ibm.com>
Date:   Fri Aug 14 15:47:19 2009 +0200

    timekeeping: Remove clocksource inline functions
    
    The three inline functions clocksource_read, clocksource_enable and
    clocksource_disable are simple wrappers of an indirect call plus the
    copy from and to the mult_orig value. The functions are exclusively
    used by the timekeeping code which has intimate knowledge of the
    clocksource anyway. Therefore remove the inline functions. No
    functional change.
    
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Acked-by: John Stultz <johnstul@us.ibm.com>
    Cc: Daniel Walker <dwalker@fifo99.com>
    LKML-Reference: <20090814134807.903108946@de.ibm.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 31089c13bcb18d2cd2a3ddfbe3a28666346f237e
Author: John Stultz <johnstul@us.ibm.com>
Date:   Fri Aug 14 15:47:18 2009 +0200

    timekeeping: Introduce timekeeping_leap_insert
    
    Move the adjustment of xtime, wall_to_monotonic and the update of the
    vsyscall variables to the timekeeping code.
    
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
    LKML-Reference: <20090814134807.609730216@de.ibm.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 4cd1993f0046fbc765dbf20af90966f5661e3789
Merge: 97fd9ed48ce2 64f1607ffbbc
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Aug 14 15:59:00 2009 +0200

    Merge branch 'linus' into timers/core
    
    Reason: Martin's timekeeping cleanup series depends on both
    timers/core and mainline changes.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit a40f262cc21fbfd781bbddcc40b16b83a75f5f34
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jul 7 13:00:31 2009 +0200

    timekeeping: Move ktime_get() functions to timekeeping.c
    
    The ktime_get() functions for GENERIC_TIME=n are still located in
    hrtimer.c. Move them to time/timekeeping.c where they belong.
    
    LKML-Reference: <new-submission>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 951ed4d36b77ba9fe1ea08fc3c59d8bb6c9bda32
Author: Martin Schwidefsky <schwidefsky@de.ibm.com>
Date:   Tue Jul 7 11:27:28 2009 +0200

    timekeeping: optimized ktime_get[_ts] for GENERIC_TIME=y
    
    The generic ktime_get function defined in kernel/hrtimer.c is suboptimial
    for GENERIC_TIME=y:
    
     0)               |  ktime_get() {
     0)               |    ktime_get_ts() {
     0)               |      getnstimeofday() {
     0)               |        read_tod_clock() {
     0)   0.601 us    |        }
     0)   1.938 us    |      }
     0)               |      set_normalized_timespec() {
     0)   0.602 us    |      }
     0)   4.375 us    |    }
     0)   5.523 us    |  }
    
    Overall there are two read_seqbegin/read_seqretry loops and a lot of
    unnecessary struct timespec calculations. ktime_get returns a nano second
    value which is the sum of xtime, wall_to_monotonic and the nano second
    delta from the clock source.
    
    ktime_get can be optimized for GENERIC_TIME=y. The new version only calls
    clocksource_read:
    
     0)               |  ktime_get() {
     0)               |    read_tod_clock() {
     0)   0.610 us    |    }
     0)   1.977 us    |  }
    
    It uses a single read_seqbegin/readseqretry loop and just adds everthing
    to a nano second value.
    
    ktime_get_ts is optimized in a similar fashion.
    
    [ tglx: added WARN_ON(timekeeping_suspended) as in getnstimeofday() ]
    
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Acked-by: john stultz <johnstul@us.ibm.com>
    LKML-Reference: <20090707112728.3005244d@skybase>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 6d134b9e8d3f32331ad2faca2db8186f54198931
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Fri May 8 16:36:13 2009 +0900

    sh: Wire up GENERIC_CMOS_UPDATE for the platforms that need it.
    
    Now that everything has converted over to generic timekeeping, we need an
    alternate method for keeping the RTC updated for those platforms that are
    still using the rtc_sh_get/set_time pairs, presently limited to SH-03 and
    the Dreamcast. This wires up the GENERIC_CMOS_UPDATE hooks for those to
    maintain the same behaviour.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

commit 7d27558c4138ac6b3684dea35c2f4379b940a7dd
Author: John Stultz <johnstul@us.ibm.com>
Date:   Fri May 1 13:10:26 2009 -0700

    timekeeping: create arch_gettimeoffset infrastructure
    
    Some arches don't supply their own clocksource. This is mainly the
    case in architectures that get their inter-tick times by reading the
    counter on their interval timer.  Since these timers wrap every tick,
    they're not really useful as clocksources.  Wrapping them to act like
    one is possible but not very efficient. So we provide a callout these
    arches can implement for use with the jiffies clocksource to provide
    finer then tick granular time.
    
    [ Impact: ease the migration to generic time keeping ]
    
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 4614e6adafa2c5e6c3a9c245af2807fa7bc5117a
Author: Magnus Damm <damm@igel.co.jp>
Date:   Tue Apr 21 12:24:02 2009 -0700

    clocksource: add enable() and disable() callbacks
    
    Add enable() and disable() callbacks for clocksources.
    
    This allows us to put unused clocksources in power save mode.  The
    functions clocksource_enable() and clocksource_disable() wrap the
    callbacks and are inserted in the timekeeping code to enable before use
    and disable after switching to a new clocksource.
    
    Signed-off-by: Magnus Damm <damm@igel.co.jp>
    Acked-by: John Stultz <johnstul@us.ibm.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit ab96e798cbd562a53edd802272e49a5100b29efb
Author: Martin Schwidefsky <schwidefsky@de.ibm.com>
Date:   Tue Apr 14 15:36:29 2009 +0200

    [S390] boot cputime accounting
    
    Start the cpu time accounting very early to catch the cpu time spent
    for the initial kernel setup. To make the output of /proc/uptime
    match the sum of all cpu accounting values of the boot cpu reset
    xtime and wall_to_monotonic to sane values based on the TOD clock.
    The values set by timekeeping_init are off by up to a second.
    
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

commit b6112ccbff5ec580d46b584ecc3c3a773b830da2
Author: Martin Schwidefsky <schwidefsky@de.ibm.com>
Date:   Tue Apr 14 15:36:28 2009 +0200

    [S390] add read_persistent_clock
    
    Add a read_persistent_clock function that does not just return 0.
    Since timekeeping_init calls the function before time_init has been
    called move reset_tod_clock to early.c to make sure that the TOD
    clock is running when read_persistent_clock is invoked.
    
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

commit a038a353c3de4040d8445ec568acebdac144436f
Author: Patrick Ohly <patrick.ohly@intel.com>
Date:   Thu Feb 12 05:03:34 2009 +0000

    clocksource: allow usage independent of timekeeping.c
    
    So far struct clocksource acted as the interface between time/timekeeping.c
    and hardware. This patch generalizes the concept so that a similar
    interface can also be used in other contexts. For that it introduces
    new structures and related functions *without* touching the existing
    struct clocksource.
    
    The reasons for adding these new structures to clocksource.[ch] are
    * the APIs are clearly related
    * struct clocksource could be cleaned up to use the new structs
    * avoids proliferation of files with similar names (timesource.h?
      timecounter.h?)
    
    As outlined in the discussion with John Stultz, this patch adds
    * struct cyclecounter: stateless API to hardware which counts clock cycles
    * struct timecounter: stateful utility code built on a cyclecounter which
      provides a nanosecond counter
    * only the function to read the nanosecond counter; deltas are used internally
      and not exposed to users of timecounter
    
    The code does no locking of the shared state. It must be called at least
    as often as the cycle counter wraps around to detect these wrap arounds.
    Both is the responsibility of the timecounter user.
    
    Acked-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Patrick Ohly <patrick.ohly@intel.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 474f010c78f1d28555971937c1e61688823cb4d1
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Wed Aug 20 16:37:28 2008 -0700

    clocksource: introduce clocksource_forward_now()
    
    commit 9a055117d3d9cb562f83f8d4cd88772761f4cab0 upstream.
    
    To keep the raw monotonic patch simple first introduce
    clocksource_forward_now(), which takes care of the offset since the last
    update_wall_time() call and adds it to the clock, so there is no need
    anymore to deal with it explicitly at various places, which need to make
    significant changes to the clock.
    
    This is also gets rid of the timekeeping_suspend_nsecs, instead of
    waiting until resume, the value is accumulated during suspend. In the end
    there is only a single user of __get_nsec_offset() left, so I integrated
    it back to getnstimeofday().
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 1d4a7f1c4faf53eb9e822743ec8a70b3019a26d2
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Sun Jan 18 16:39:29 2009 +0100

    hrtimers: fix inconsistent lock state on resume in hres_timers_resume
    
    Andrey Borzenkov reported this lockdep assert:
    
    > [17854.688347] =================================
    > [17854.688347] [ INFO: inconsistent lock state ]
    > [17854.688347] 2.6.29-rc2-1avb #1
    > [17854.688347] ---------------------------------
    > [17854.688347] inconsistent {in-hardirq-W} -> {hardirq-on-W} usage.
    > [17854.688347] pm-suspend/18240 [HC0[0]:SC0[0]:HE1:SE1] takes:
    > [17854.688347]  (&cpu_base->lock){++..}, at: [<c0136fcc>] retrigger_next_event+0x5c/0xa0
    > [17854.688347] {in-hardirq-W} state was registered at:
    > [17854.688347]   [<c01443cd>] __lock_acquire+0x79d/0x1930
    > [17854.688347]   [<c01455bc>] lock_acquire+0x5c/0x80
    > [17854.688347]   [<c03092e5>] _spin_lock+0x35/0x70
    > [17854.688347]   [<c0136e61>] hrtimer_run_queues+0x31/0x140
    > [17854.688347]   [<c0128d98>] run_local_timers+0x8/0x20
    > [17854.688347]   [<c0128dd3>] update_process_times+0x23/0x60
    > [17854.688347]   [<c013e274>] tick_periodic+0x24/0x80
    > [17854.688347]   [<c013e2e2>] tick_handle_periodic+0x12/0x70
    > [17854.688347]   [<c0104e24>] timer_interrupt+0x14/0x20
    > [17854.688347]   [<c01607b9>] handle_IRQ_event+0x29/0x60
    > [17854.688347]   [<c0161c59>] handle_level_irq+0x69/0xe0
    > [17854.688347]   [<ffffffff>] 0xffffffff
    > [17854.688347] irq event stamp: 55771
    > [17854.688347] hardirqs last  enabled at (55771): [<c0309125>] _spin_unlock_irqrestore+0x35/0x60
    > [17854.688347] hardirqs last disabled at (55770): [<c0309419>] _spin_lock_irqsave+0x19/0x80
    > [17854.688347] softirqs last  enabled at (54836): [<c0124f54>] __do_softirq+0xc4/0x110
    > [17854.688347] softirqs last disabled at (54831): [<c01049ae>] do_softirq+0x8e/0xe0
    > [17854.688347]
    > [17854.688347] other info that might help us debug this:
    > [17854.688347] 3 locks held by pm-suspend/18240:
    > [17854.688347]  #0:  (&buffer->mutex){--..}, at: [<c01dd4c5>] sysfs_write_file+0x25/0x100
    > [17854.688347]  #1:  (pm_mutex){--..}, at: [<c015056f>] enter_state+0x4f/0x140
    > [17854.688347]  #2:  (dpm_list_mtx){--..}, at: [<c027880f>] device_pm_lock+0xf/0x20
    > [17854.688347]
    > [17854.688347] stack backtrace:
    > [17854.688347] Pid: 18240, comm: pm-suspend Not tainted 2.6.29-rc2-1avb #1
    > [17854.688347] Call Trace:
    > [17854.688347]  [<c0306248>] ? printk+0x18/0x20
    > [17854.688347]  [<c0141fac>] print_usage_bug+0x16c/0x1d0
    > [17854.688347]  [<c0142bcf>] mark_lock+0x8bf/0xc90
    > [17854.688347]  [<c0106b8f>] ? pit_next_event+0x2f/0x40
    > [17854.688347]  [<c01441b0>] __lock_acquire+0x580/0x1930
    > [17854.688347]  [<c030916d>] ? _spin_unlock+0x1d/0x20
    > [17854.688347]  [<c0106b8f>] ? pit_next_event+0x2f/0x40
    > [17854.688347]  [<c013dd38>] ? clockevents_program_event+0x98/0x160
    > [17854.688347]  [<c0142fe8>] ? mark_held_locks+0x48/0x90
    > [17854.688347]  [<c0309125>] ? _spin_unlock_irqrestore+0x35/0x60
    > [17854.688347]  [<c0143229>] ? trace_hardirqs_on_caller+0x139/0x190
    > [17854.688347]  [<c014328b>] ? trace_hardirqs_on+0xb/0x10
    > [17854.688347]  [<c01455bc>] lock_acquire+0x5c/0x80
    > [17854.688347]  [<c0136fcc>] ? retrigger_next_event+0x5c/0xa0
    > [17854.688347]  [<c03092e5>] _spin_lock+0x35/0x70
    > [17854.688347]  [<c0136fcc>] ? retrigger_next_event+0x5c/0xa0
    > [17854.688347]  [<c0136fcc>] retrigger_next_event+0x5c/0xa0
    > [17854.688347]  [<c013711a>] hres_timers_resume+0xa/0x10
    > [17854.688347]  [<c013aa8e>] timekeeping_resume+0xee/0x150
    > [17854.688347]  [<c0273384>] __sysdev_resume+0x14/0x50
    > [17854.688347]  [<c0273407>] sysdev_resume+0x47/0x80
    > [17854.688347]  [<c02791ab>] device_power_up+0xb/0x20
    > [17854.688347]  [<c015043f>] suspend_devices_and_enter+0xcf/0x150
    > [17854.688347]  [<c0150c2f>] ? freeze_processes+0x3f/0x90
    > [17854.688347]  [<c0150614>] enter_state+0xf4/0x140
    > [17854.688347]  [<c01506dd>] state_store+0x7d/0xc0
    > [17854.688347]  [<c0150660>] ? state_store+0x0/0xc0
    > [17854.688347]  [<c0202da4>] kobj_attr_store+0x24/0x30
    > [17854.688347]  [<c01dd53c>] sysfs_write_file+0x9c/0x100
    > [17854.688347]  [<c019916c>] vfs_write+0x9c/0x160
    > [17854.688347]  [<c0103494>] ? restore_nocheck_notrace+0x0/0xe
    > [17854.688347]  [<c01dd4a0>] ? sysfs_write_file+0x0/0x100
    > [17854.688347]  [<c01992ed>] sys_write+0x3d/0x70
    > [17854.688347]  [<c0103371>] sysenter_do_call+0x12/0x31
    
    Andrey's analysis:
    
    > timekeeping_resume() is called via class ->resume
    > method; and according to comments in sysdev_resume() and
    > device_power_up(), they are called with interrupts disabled.
    >
    > Looking at suspend_enter, irqs *are* disabled at this point.
    >
    > So it actually looks like something (may be some driver)
    > unconditionally enabled irqs in resume path.
    
    Add a debug check to test this theory. If it triggers then it
    triggers because the resume code calls it with irqs enabled,
    which is a no-no not just for timekeeping_resume(), but also
    bad for a number of other resume handlers.
    
    Reported-by: Andrey Borzenkov <arvidjaar@mail.ru>
    Signed-off-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

commit e268dcdd404f4558cdd24c8ecede3e064df8fa33
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Dec 22 23:05:28 2008 +0100

    sched_clock: prevent scd->clock from moving backwards, take #2
    
    commit 1c5745aa380efb6417b5681104b007c8612fb496 upstream.
    
    Redo:
    
      5b7dba4: sched_clock: prevent scd->clock from moving backwards
    
    which had to be reverted due to s2ram hangs:
    
      ca7e716: Revert "sched_clock: prevent scd->clock from moving backwards"
    
    ... this time with resume restoring GTOD later in the sequence
    taken into account as well.
    
    The "timekeeping_suspended" flag is not very nice but we cannot call into
    GTOD before it has been properly resumed and the scheduler will run very
    early in the resume sequence.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 7d75e838bb5a3b2ec427b4121d4404f6b5689aae
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Dec 22 23:05:28 2008 +0100

    sched_clock: prevent scd->clock from moving backwards, take #2
    
    commit 1c5745aa380efb6417b5681104b007c8612fb496 upstream.
    
    Redo:
    
      5b7dba4: sched_clock: prevent scd->clock from moving backwards
    
    which had to be reverted due to s2ram hangs:
    
      ca7e716: Revert "sched_clock: prevent scd->clock from moving backwards"
    
    ... this time with resume restoring GTOD later in the sequence
    taken into account as well.
    
    The "timekeeping_suspended" flag is not very nice but we cannot call into
    GTOD before it has been properly resumed and the scheduler will run very
    early in the resume sequence.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 1c5745aa380efb6417b5681104b007c8612fb496
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Dec 22 23:05:28 2008 +0100

    sched_clock: prevent scd->clock from moving backwards, take #2
    
    Redo:
    
      5b7dba4: sched_clock: prevent scd->clock from moving backwards
    
    which had to be reverted due to s2ram hangs:
    
      ca7e716: Revert "sched_clock: prevent scd->clock from moving backwards"
    
    ... this time with resume restoring GTOD later in the sequence
    taken into account as well.
    
    The "timekeeping_suspended" flag is not very nice but we cannot call into
    GTOD before it has been properly resumed and the scheduler will run very
    early in the resume sequence.
    
    Cc: <stable@kernel.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

commit 64db4cfff99c04cd5f550357edcc8780f96b54a2
Author: Paul E. McKenney <paulmck@kernel.org>
Date:   Thu Dec 18 21:55:32 2008 +0100

    "Tree RCU": scalable classic RCU implementation
    
    This patch fixes a long-standing performance bug in classic RCU that
    results in massive internal-to-RCU lock contention on systems with
    more than a few hundred CPUs.  Although this patch creates a separate
    flavor of RCU for ease of review and patch maintenance, it is intended
    to replace classic RCU.
    
    This patch still handles stress better than does mainline, so I am still
    calling it ready for inclusion.  This patch is against the -tip tree.
    Nevertheless, experience on an actual 1000+ CPU machine would still be
    most welcome.
    
    Most of the changes noted below were found while creating an rcutiny
    (which should permit ejecting the current rcuclassic) and while doing
    detailed line-by-line documentation.
    
    Updates from v9 (http://lkml.org/lkml/2008/12/2/334):
    
    o       Fixes from remainder of line-by-line code walkthrough,
            including comment spelling, initialization, undesirable
            narrowing due to type conversion, removing redundant memory
            barriers, removing redundant local-variable initialization,
            and removing redundant local variables.
    
            I do not believe that any of these fixes address the CPU-hotplug
            issues that Andi Kleen was seeing, but please do give it a whirl
            in case the machine is smarter than I am.
    
            A writeup from the walkthrough may be found at the following
            URL, in case you are suffering from terminal insomnia or
            masochism:
    
            http://www.kernel.org/pub/linux/kernel/people/paulmck/tmp/rcutree-walkthrough.2008.12.16a.pdf
    
    o       Made rcutree tracing use seq_file, as suggested some time
            ago by Lai Jiangshan.
    
    o       Added a .csv variant of the rcudata debugfs trace file, to allow
            people having thousands of CPUs to drop the data into
            a spreadsheet.  Tested with oocalc and gnumeric.  Updated
            documentation to suit.
    
    Updates from v8 (http://lkml.org/lkml/2008/11/15/139):
    
    o       Fix a theoretical race between grace-period initialization and
            force_quiescent_state() that could occur if more than three
            jiffies were required to carry out the grace-period
            initialization.  Which it might, if you had enough CPUs.
    
    o       Apply Ingo's printk-standardization patch.
    
    o       Substitute local variables for repeated accesses to global
            variables.
    
    o       Fix comment misspellings and redundant (but harmless) increments
            of ->n_rcu_pending (this latter after having explicitly added it).
    
    o       Apply checkpatch fixes.
    
    Updates from v7 (http://lkml.org/lkml/2008/10/10/291):
    
    o       Fixed a number of problems noted by Gautham Shenoy, including
            the cpu-stall-detection bug that he was having difficulty
            convincing me was real.  ;-)
    
    o       Changed cpu-stall detection to wait for ten seconds rather than
            three in order to reduce false positive, as suggested by Ingo
            Molnar.
    
    o       Produced a design document (http://lwn.net/Articles/305782/).
            The act of writing this document uncovered a number of both
            theoretical and "here and now" bugs as noted below.
    
    o       Fix dynticks_nesting accounting confusion, simplify WARN_ON()
            condition, fix kerneldoc comments, and add memory barriers
            in dynticks interface functions.
    
    o       Add more data to tracing.
    
    o       Remove unused "rcu_barrier" field from rcu_data structure.
    
    o       Count calls to rcu_pending() from scheduling-clock interrupt
            to use as a surrogate timebase should jiffies stop counting.
    
    o       Fix a theoretical race between force_quiescent_state() and
            grace-period initialization.  Yes, initialization does have to
            go on for some jiffies for this race to occur, but given enough
            CPUs...
    
    Updates from v6 (http://lkml.org/lkml/2008/9/23/448):
    
    o       Fix a number of checkpatch.pl complaints.
    
    o       Apply review comments from Ingo Molnar and Lai Jiangshan
            on the stall-detection code.
    
    o       Fix several bugs in !CONFIG_SMP builds.
    
    o       Fix a misspelled config-parameter name so that RCU now announces
            at boot time if stall detection is configured.
    
    o       Run tests on numerous combinations of configurations parameters,
            which after the fixes above, now build and run correctly.
    
    Updates from v5 (http://lkml.org/lkml/2008/9/15/92, bad subject line):
    
    o       Fix a compiler error in the !CONFIG_FANOUT_EXACT case (blew a
            changeset some time ago, and finally got around to retesting
            this option).
    
    o       Fix some tracing bugs in rcupreempt that caused incorrect
            totals to be printed.
    
    o       I now test with a more brutal random-selection online/offline
            script (attached).  Probably more brutal than it needs to be
            on the people reading it as well, but so it goes.
    
    o       A number of optimizations and usability improvements:
    
            o       Make rcu_pending() ignore the grace-period timeout when
                    there is no grace period in progress.
    
            o       Make force_quiescent_state() avoid going for a global
                    lock in the case where there is no grace period in
                    progress.
    
            o       Rearrange struct fields to improve struct layout.
    
            o       Make call_rcu() initiate a grace period if RCU was
                    idle, rather than waiting for the next scheduling
                    clock interrupt.
    
            o       Invoke rcu_irq_enter() and rcu_irq_exit() only when
                    idle, as suggested by Andi Kleen.  I still don't
                    completely trust this change, and might back it out.
    
            o       Make CONFIG_RCU_TRACE be the single config variable
                    manipulated for all forms of RCU, instead of the prior
                    confusion.
    
            o       Document tracing files and formats for both rcupreempt
                    and rcutree.
    
    Updates from v4 for those missing v5 given its bad subject line:
    
    o       Separated dynticks interface so that NMIs and irqs call separate
            functions, greatly simplifying it.  In particular, this code
            no longer requires a proof of correctness.  ;-)
    
    o       Separated dynticks state out into its own per-CPU structure,
            avoiding the duplicated accounting.
    
    o       The case where a dynticks-idle CPU runs an irq handler that
            invokes call_rcu() is now correctly handled, forcing that CPU
            out of dynticks-idle mode.
    
    o       Review comments have been applied (thank you all!!!).
            For but one example, fixed the dynticks-ordering issue that
            Manfred pointed out, saving me much debugging.  ;-)
    
    o       Adjusted rcuclassic and rcupreempt to handle dynticks changes.
    
    Attached is an updated patch to Classic RCU that applies a hierarchy,
    greatly reducing the contention on the top-level lock for large machines.
    This passes 10-hour concurrent rcutorture and online-offline testing on
    128-CPU ppc64 without dynticks enabled, and exposes some timekeeping
    bugs in presence of dynticks (exciting working on a system where
    "sleep 1" hangs until interrupted...), which were fixed in the
    2.6.27 kernel.  It is getting more reliable than mainline by some
    measures, so the next version will be against -tip for inclusion.
    See also Manfred Spraul's recent patches (or his earlier work from
    2004 at http://marc.info/?l=linux-kernel&m=108546384711797&w=2).
    We will converge onto a common patch in the fullness of time, but are
    currently exploring different regions of the design space.  That said,
    I have already gratefully stolen quite a few of Manfred's ideas.
    
    This patch provides CONFIG_RCU_FANOUT, which controls the bushiness
    of the RCU hierarchy.  Defaults to 32 on 32-bit machines and 64 on
    64-bit machines.  If CONFIG_NR_CPUS is less than CONFIG_RCU_FANOUT,
    there is no hierarchy.  By default, the RCU initialization code will
    adjust CONFIG_RCU_FANOUT to balance the hierarchy, so strongly NUMA
    architectures may choose to set CONFIG_RCU_FANOUT_EXACT to disable
    this balancing, allowing the hierarchy to be exactly aligned to the
    underlying hardware.  Up to two levels of hierarchy are permitted
    (in addition to the root node), allowing up to 16,384 CPUs on 32-bit
    systems and up to 262,144 CPUs on 64-bit systems.  I just know that I
    am going to regret saying this, but this seems more than sufficient
    for the foreseeable future.  (Some architectures might wish to set
    CONFIG_RCU_FANOUT=4, which would limit such architectures to 64 CPUs.
    If this becomes a real problem, additional levels can be added, but I
    doubt that it will make a significant difference on real hardware.)
    
    In the common case, a given CPU will manipulate its private rcu_data
    structure and the rcu_node structure that it shares with its immediate
    neighbors.  This can reduce both lock and memory contention by multiple
    orders of magnitude, which should eliminate the need for the strange
    manipulations that are reported to be required when running Linux on
    very large systems.
    
    Some shortcomings:
    
    o       More bugs will probably surface as a result of an ongoing
            line-by-line code inspection.
    
            Patches will be provided as required.
    
    o       There are probably hangs, rcutorture failures, &c.  Seems
            quite stable on a 128-CPU machine, but that is kind of small
            compared to 4096 CPUs.  However, seems to do better than
            mainline.
    
            Patches will be provided as required.
    
    o       The memory footprint of this version is several KB larger
            than rcuclassic.
    
            A separate UP-only rcutiny patch will be provided, which will
            reduce the memory footprint significantly, even compared
            to the old rcuclassic.  One such patch passes light testing,
            and has a memory footprint smaller even than rcuclassic.
            Initial reaction from various embedded guys was "it is not
            worth it", so am putting it aside.
    
    Credits:
    
    o       Manfred Spraul for ideas, review comments, and bugs spotted,
            as well as some good friendly competition.  ;-)
    
    o       Josh Triplett, Ingo Molnar, Peter Zijlstra, Mathieu Desnoyers,
            Lai Jiangshan, Andi Kleen, Andy Whitcroft, and Andrew Morton
            for reviews and comments.
    
    o       Thomas Gleixner for much-needed help with some timer issues
            (see patches below).
    
    o       Jon M. Tollefson, Tim Pepper, Andrew Theurer, Jose R. Santos,
            Andy Whitcroft, Darrick Wong, Nishanth Aravamudan, Anton
            Blanchard, Dave Kleikamp, and Nathan Lynch for keeping machines
            alive despite my heavy abuse^Wtesting.
    
    Signed-off-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

commit 1f0d69a9fc815db82f15722bf05227190b1d714d
Author: Steven Rostedt <rostedt@goodmis.org>
Date:   Wed Nov 12 00:14:39 2008 -0500

    tracing: profile likely and unlikely annotations
    
    Impact: new unlikely/likely profiler
    
    Andrew Morton recently suggested having an in-kernel way to profile
    likely and unlikely macros. This patch achieves that goal.
    
    When configured, every(*) likely and unlikely macro gets a counter attached
    to it. When the condition is hit, the hit and misses of that condition
    are recorded. These numbers can later be retrieved by:
    
      /debugfs/tracing/profile_likely    - All likely markers
      /debugfs/tracing/profile_unlikely  - All unlikely markers.
    
    # cat /debug/tracing/profile_unlikely | head
     correct incorrect  %        Function                  File              Line
     ------- ---------  -        --------                  ----              ----
        2167        0   0 do_arch_prctl                  process_64.c         832
           0        0   0 do_arch_prctl                  process_64.c         804
        2670        0   0 IS_ERR                         err.h                34
       71230     5693   7 __switch_to                    process_64.c         673
       76919        0   0 __switch_to                    process_64.c         639
       43184    33743  43 __switch_to                    process_64.c         624
       12740    64181  83 __switch_to                    process_64.c         594
       12740    64174  83 __switch_to                    process_64.c         590
    
    # cat /debug/tracing/profile_unlikely | \
      awk '{ if ($3 > 25) print $0; }' |head -20
       44963    35259  43 __switch_to                    process_64.c         624
       12762    67454  84 __switch_to                    process_64.c         594
       12762    67447  84 __switch_to                    process_64.c         590
        1478      595  28 syscall_get_error              syscall.h            51
           0     2821 100 syscall_trace_leave            ptrace.c             1567
           0        1 100 native_smp_prepare_cpus        smpboot.c            1237
       86338   265881  75 calc_delta_fair                sched_fair.c         408
      210410   108540  34 calc_delta_mine                sched.c              1267
           0    54550 100 sched_info_queued              sched_stats.h        222
       51899    66435  56 pick_next_task_fair            sched_fair.c         1422
           6       10  62 yield_task_fair                sched_fair.c         982
        7325     2692  26 rt_policy                      sched.c              144
           0     1270 100 pre_schedule_rt                sched_rt.c           1261
        1268    48073  97 pick_next_task_rt              sched_rt.c           884
           0    45181 100 sched_info_dequeued            sched_stats.h        177
           0       15 100 sched_move_task                sched.c              8700
           0       15 100 sched_move_task                sched.c              8690
       53167    33217  38 schedule                       sched.c              4457
           0    80208 100 sched_info_switch              sched_stats.h        270
       30585    49631  61 context_switch                 sched.c              2619
    
    # cat /debug/tracing/profile_likely | awk '{ if ($3 > 25) print $0; }'
       39900    36577  47 pick_next_task                 sched.c              4397
       20824    15233  42 switch_mm                      mmu_context_64.h     18
           0        7 100 __cancel_work_timer            workqueue.c          560
         617    66484  99 clocksource_adjust             timekeeping.c        456
           0   346340 100 audit_syscall_exit             auditsc.c            1570
          38   347350  99 audit_get_context              auditsc.c            732
           0   345244 100 audit_syscall_entry            auditsc.c            1541
          38     1017  96 audit_free                     auditsc.c            1446
           0     1090 100 audit_alloc                    auditsc.c            862
        2618     1090  29 audit_alloc                    auditsc.c            858
           0        6 100 move_masked_irq                migration.c          9
           1      198  99 probe_sched_wakeup             trace_sched_switch.c 58
           2        2  50 probe_wakeup                   trace_sched_wakeup.c 227
           0        2 100 probe_wakeup_sched_switch      trace_sched_wakeup.c 144
        4514     2090  31 __grab_cache_page              filemap.c            2149
       12882   228786  94 mapping_unevictable            pagemap.h            50
           4       11  73 __flush_cpu_slab               slub.c               1466
      627757   330451  34 slab_free                      slub.c               1731
        2959    61245  95 dentry_lru_del_init            dcache.c             153
         946     1217  56 load_elf_binary                binfmt_elf.c         904
         102       82  44 disk_put_part                  genhd.h              206
           1        1  50 dst_gc_task                    dst.c                82
           0       19 100 tcp_mss_split_point            tcp_output.c         1126
    
    As you can see by the above, there's a bit of work to do in rethinking
    the use of some unlikelys and likelys. Note: the unlikely case had 71 hits
    that were more than 25%.
    
    Note:  After submitting my first version of this patch, Andrew Morton
      showed me a version written by Daniel Walker, where I picked up
      the following ideas from:
    
      1)  Using __builtin_constant_p to avoid profiling fixed values.
      2)  Using __FILE__ instead of instruction pointers.
      3)  Using the preprocessor to stop all profiling of likely
           annotations from vsyscall_64.c.
    
    Thanks to Andrew Morton, Arjan van de Ven, Theodore Tso and Ingo Molnar
    for their feed back on this patch.
    
    (*) Not ever unlikely is recorded, those that are used by vsyscalls
     (a few of them) had to have profiling disabled.
    
    Signed-off-by: Steven Rostedt <srostedt@redhat.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Theodore Tso <tytso@mit.edu>
    Cc: Arjan van de Ven <arjan@infradead.org>
    Cc: Steven Rostedt <srostedt@redhat.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

commit 3cc698789a3f44dabc5eed389b6c123caf787c0f
Author: Paul Mackerras <paulus@samba.org>
Date:   Tue Oct 28 00:18:11 2008 +0000

    powerpc: Eliminate unused do_gtod variable
    
    Since we started using the generic timekeeping code, we haven't had a
    powerpc-specific version of do_gettimeofday, and hence there is now
    nothing that reads the do_gtod variable in arch/powerpc/kernel/time.c.
    This therefore removes it and the code that sets it.
    
    Signed-off-by: Paul Mackerras <paulus@samba.org>

commit 395628ef4ea12ff0748099f145363b5e33c69acb
Author: Alok Kataria <akataria@vmware.com>
Date:   Fri Oct 24 17:22:01 2008 -0700

    x86: Skip verification by the watchdog for TSC clocksource.
    
    Impact: Changes timekeeping on Vmware (or with tsc=reliable).
    
    This is achieved by resetting the CLOCKSOURCE_MUST_VERIFY flag.
    
    We add a tsc=reliable commandline option to enable this.
    This enables legacy hardware without HPET, LAPIC, or ACPI timers
    to enter high-resolution timer mode.
    
    Along with that have extended this to be used in virtualization environement
    too. Now we also set this flag if the X86_FEATURE_TSC_RELIABLE bit is set.
    
    This is important since there is a wrap-around problem with the acpi_pm timer.
    The acpi_pm counter is just 24bits and this can overflow in ~4 seconds. With
    the NO_HZ kernels in virtualized environment, there can be situations when
    the guest is descheduled for longer duration, as a result we may miss the wrap
    of the acpi counter. When TSC is used as a clocksource and acpi_pm timer is
    being used as the watchdog clocksource this error in acpi_pm results in TSC
    being marked as unstable, and essentially results in time dropping in chunks
    of 4 seconds whenever this wrap is missed. Since the virtualized TSC is
    reliable on VMware, we should always use the TSCs clocksource on VMware, so
    we skip the verfication at runtime, by checking for the feature bit.
    
    Since we reset the flag for mgeode systems too, i have combined
    the mgeode case with the feature bit check.
    
    Signed-off-by: Jeff Hansen <jhansen@cardaccess-inc.com>
    Signed-off-by: Alok N Kataria <akataria@vmware.com>
    Signed-off-by: Dan Hecht <dhecht@vmware.com>
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>

commit eca0cd028bdf0f6aaceb0d023e9c7501079a7dda
Author: Alok Kataria <akataria@vmware.com>
Date:   Fri Oct 31 12:01:58 2008 -0700

    x86: Add a synthetic TSC_RELIABLE feature bit.
    
    Impact: Changes timebase calibration on Vmware.
    
    Use the synthetic TSC_RELIABLE bit to workaround virtualization anomalies.
    
    Virtual TSCs can be kept nearly in sync, but because the virtual TSC
    offset is set by software, it's not perfect.  So, the TSC
    synchronization test can fail. Even then the TSC can be used as a
    clocksource since the VMware platform exports a reliable TSC to the
    guest for timekeeping purposes. Use this bit to check if we need to
    skip the TSC sync checks.
    
    Along with this also set the CONSTANT_TSC bit when on VMware, since we
    still want to use TSC as clocksource on VM running over hardware which
    has unsynchronized TSC's (opteron's), since the hypervisor will take
    care of providing consistent TSC to the guest.
    
    Signed-off-by: Alok N Kataria <akataria@vmware.com>
    Signed-off-by: Dan Hecht <dhecht@vmware.com>
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>

commit 99ebcf8285df28f32fd2d1c19a7166e70f00309c
Merge: 72558dde738b c465a76af658
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Oct 20 13:19:56 2008 -0700

    Merge branch 'v28-timers-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'v28-timers-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip: (36 commits)
      fix documentation of sysrq-q really
      Fix documentation of sysrq-q
      timer_list: add base address to clock base
      timer_list: print cpu number of clockevents device
      timer_list: print real timer address
      NOHZ: restart tick device from irq_enter()
      NOHZ: split tick_nohz_restart_sched_tick()
      NOHZ: unify the nohz function calls in irq_enter()
      timers: fix itimer/many thread hang, fix
      timers: fix itimer/many thread hang, v3
      ntp: improve adjtimex frequency rounding
      timekeeping: fix rounding problem during clock update
      ntp: let update_persistent_clock() sleep
      hrtimer: reorder struct hrtimer to save 8 bytes on 64bit builds
      posix-timers: lock_timer: make it readable
      posix-timers: lock_timer: kill the bogus ->it_id check
      posix-timers: kill ->it_sigev_signo and ->it_sigev_value
      posix-timers: sys_timer_create: cleanup the error handling
      posix-timers: move the initialization of timer->sigq from send to create path
      posix-timers: sys_timer_create: simplify and s/tasklist/rcu/
      ...
    
    Fix trivial conflicts due to sysrq-q description clahes in
    Documentation/sysrq.txt and drivers/char/sysrq.c

commit 5cd1c9c5cf30d4b33df3d3f74d8142f278d536b7
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Mon Sep 22 14:42:43 2008 -0700

    timekeeping: fix rounding problem during clock update
    
    Due to a rounding problem during a clock update it's possible for readers
    to observe the clock jumping back by 1nsec.  The following simplified
    example demonstrates the problem:
    
    cycle   xtime
    0       0
    1000    999999.6
    2000    1999999.2
    3000    2999998.8
    ...
    
    1500 =  1499999.4
    =       0.0 + 1499999.4
    =       999999.6 + 499999.8
    
    When reading the clock only the full nanosecond part is used, while
    timekeeping internally keeps nanosecond fractions.  If the clock is now
    updated at cycle 1500 here, a nanosecond is missing due to the truncation.
    
    The simple fix is to round up the xtime value during the update, this also
    changes the distance to the reference time, but the adjustment will
    automatically take care that it stays under control.
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 9a055117d3d9cb562f83f8d4cd88772761f4cab0
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Wed Aug 20 16:37:28 2008 -0700

    clocksource: introduce clocksource_forward_now()
    
    To keep the raw monotonic patch simple first introduce
    clocksource_forward_now(), which takes care of the offset since the last
    update_wall_time() call and adds it to the clock, so there is no need
    anymore to deal with it explicitly at various places, which need to make
    significant changes to the clock.
    
    This is also gets rid of the timekeeping_suspend_nsecs, instead of
    waiting until resume, the value is accumulated during suspend. In the end
    there is only a single user of __get_nsec_offset() left, so I integrated
    it back to getnstimeofday().
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

commit e3ac3cda49d4ee77dee42270d02d3996bace3744
Author: Jeff Dike <jdike@addtoit.com>
Date:   Tue Aug 5 16:14:05 2008 -0400

    uml: track and make up lost ticks
    
    commit fe2cc53ee013a4d4d0317d418e7019fe6533a5a8 upstream
    
    Alarm delivery could be noticably late in the !CONFIG_NOHZ case because lost
    ticks weren't being taken into account.  This is now treated more carefully,
    with the time between ticks being calculated and the appropriate number of
    ticks delivered to the timekeeping system.
    
    Cc: Nix <nix@esperi.org.uk>
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 359cdd3f866b6219a6729e313faf2221397f3278
Author: Jeremy Fitzhardinge <jeremy@goop.org>
Date:   Mon May 26 23:31:28 2008 +0100

    xen: maintain clock offset over save/restore
    
    Hook into the device model to make sure that timekeeping's resume handler
    is called.  This deals with our clocksource's non-monotonicity over the
    save/restore.  Explicitly call clock_has_changed() to make sure that
    all the timers get retriggered properly.
    
    Signed-off-by: Jeremy Fitzhardinge <jeremy.fitzhardinge@citrix.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit f70c5253b41444fd2779e1f76bfe25811d9b8c23
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Sun Apr 20 12:22:36 2008 +0100

    [RTC] remove references to asm/mach/time.h
    
    asm/mach/time.h is the ARM header file for setting up kernel ticker
    timekeeping (be that the old jiffy interrupt or the new clocksource.)
    RTC drivers have no business using this header file, and in fact do
    not require it.
    
    Build tested on at91sam9rl, omap and s3c2410 configurations.
    
    Acked-by: Alessandro Zummo <a.zummo@towertech.it>
    Acked-by: Andrew Victor <linux@maxim.org.za>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

commit fe2cc53ee013a4d4d0317d418e7019fe6533a5a8
Author: Jeff Dike <jdike@addtoit.com>
Date:   Mon May 12 14:02:00 2008 -0700

    uml: track and make up lost ticks
    
    Alarm delivery could be noticably late in the !CONFIG_NOHZ case because lost
    ticks weren't being taken into account.  This is now treated more carefully,
    with the time between ticks being calculated and the appropriate number of
    ticks delivered to the timekeeping system.
    
    Cc: Nix <nix@esperi.org.uk>
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit e723ff666a5da8f7fda4e36ebfeafac2175a5c6e
Author: David Brownell <david-b@pacbell.net>
Date:   Thu Feb 14 11:24:02 2008 -0800

    avr32: Generic clockevents support
    
    This combines three patches from David Brownell:
      * avr32: tclib support
      * avr32: simplify clocksources
      * avr32: Turn count/compare into a oneshot clockevent device
    
    Register both TC blocks (instead of just the first one) so that
    the AT32/AT91 tclib code will pick them up (instead of just the
    avr32-only PIT-style clocksource).
    
    Rename the first one and its resources appropriately.
    
    More cleanups to the cycle counter clocksource code
    
     - Disable all the weak symbol magic; remove the AVR32-only TCB-based
       clocksource code (source and header).
    
     - Mark the __init code properly.
    
     - Don't forget to report IRQF_TIMER.
    
     - Make the system work properly with this clocksource, by preventing
       use of the CPU "idle" sleep state in the idle loop when it's used.
    
    Package the avr32 count/compare timekeeping support as a oneshot
    clockevent device, so it supports NO_HZ and high res timers.
    This means it also supports plugging in other clockevent devices
    and clocksources.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Haavard Skinnemoen <hskinnemoen@atmel.com>

commit ad48ce74f70a201c4c1cf3b4e8f6b6203a2e4a8d
Author: Andrew Victor <linux@maxim.org.za>
Date:   Wed Apr 16 20:43:49 2008 +0100

    [ARM] 4989/1: [AT91] SAM9 ClockSource / ClockEvents
    
    Update AT91SAM9/CAP9 PIT driver to use generic time and clockevent
    infrastructure:
    
     - Clocksource gives sub-microsecond timestamp precision, assuming
     memory is clocked at over 16 MHz.  It's less than a 32 bit counter,
     unless it's is also generating IRQs.
    
     - Clockevent device supports periodic mode only; no oneshot
     support from this hardware.  No IRQs generated unless it's the
     active clocksource.
    
    Later, another timer (probably from a TC module) can provide a oneshot
    clockevent device to get NO_HZ and High-Res-Timer behavior.
    
    This also updates the timekeeping to use the actual master clock rate
    on the system, instead of compile-time <asm/arch/timex.h> constants
    matching what Atmel's EK boards use.  (Product boards may well differ!)
    
    Plus cleanup:  rename "*_timer*" symbols to "*_pit*" (there are other
    timers, but only one PIT); shorter lines; remove needless CPP stuff;
    make several symbols static; etc.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Andrew Victor <linux@maxim.org.za>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

commit cf4fc6cb76e50b01666e28a9f4b2e6fbcbb96d5f
Author: Li Zefan <lizf@cn.fujitsu.com>
Date:   Fri Feb 8 04:19:24 2008 -0800

    timekeeping: rename timekeeping_is_continuous to timekeeping_valid_for_hres
    
    Function timekeeping_is_continuous() no longer checks flag
    CLOCK_IS_CONTINUOUS, and it checks CLOCK_SOURCE_VALID_FOR_HRES now.  So rename
    the function accordingly.
    
    Signed-off-by: Li Zefan <lizf@cn.fujitsu.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: john stultz <johnstul@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit 45f37e86f1ef95f002386d8a0ab508407cec9bf3
Merge: e30ec4525d47 aa7d93506cc2
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Feb 2 08:27:00 2008 +1100

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/mingo/linux-2.6-sched
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/mingo/linux-2.6-sched:
      latencytop: Change Kconfig dependency.
      futex: Add bitset conditional wait/wakeup functionality
      futex: Remove warn on in return fixup path
      x86: replace LOCK_PREFIX in futex.h
      tick-sched: add more debug information
      timekeeping: update xtime_cache when time(zone) changes
      hrtimer: fix hrtimer_init_sleeper() users

commit 1001d0a9ee74a468077dfd4da0565174e88de26b
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Feb 1 17:45:13 2008 +0100

    timekeeping: update xtime_cache when time(zone) changes
    
    xtime_cache needs to be updated whenever xtime and or wall_to_monotic
    are changed. Otherwise users of xtime_cache might see a stale (and in
    the case of timezone changes utterly wrong) value until the next
    update happens.
    
    Fixup the obvious places, which miss this update.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: John Stultz <johnstul@us.ibm.com>
    Tested-by: Dhaval Giani <dhaval@linux.vnet.ibm.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

commit ba2a631b14fe8a9c122801c648c49a543d020d8d
Author: Adrian Bunk <bunk@kernel.org>
Date:   Tue Oct 16 23:27:16 2007 -0700

    kernel/time/timekeeping.c: cleanups
    
    - remove the no longer required __attribute__((weak)) of xtime_lock
    - remove the following no longer used EXPORT_SYMBOL's:
      - xtime
      - xtime_lock
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: john stultz <johnstul@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit aa3be5f32db137bc4404f32a24b36fb47d48d260
Author: Tony Breeds <tony@bakeyournoodle.com>
Date:   Fri Sep 21 13:26:02 2007 +1000

    [POWERPC] Implement {read,update}_persistent_clock
    
    With these functions implemented we cooperate better with the generic
    timekeeping code.  This obsoletes the need for the timer sysdev as a bonus.
    
    Signed-off-by: Tony Breeds <tony@bakeyournoodle.com>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

commit f15f41383d466860f8b22f669da8c841f8d73c3b
Merge: dbe3ed1c078c c27da3396981
Author: Linus Torvalds <torvalds@woody.linux-foundation.org>
Date:   Wed Sep 19 11:38:25 2007 -0700

    Merge branch 'merge' of git://git.kernel.org/pub/scm/linux/kernel/git/paulus/powerpc
    
    * 'merge' of git://git.kernel.org/pub/scm/linux/kernel/git/paulus/powerpc:
      [POWERPC] Fix timekeeping on PowerPC 601
      [POWERPC] Don't expose clock vDSO functions when CPU has no timebase
      [POWERPC] spusched: Fix null pointer dereference in find_victim

commit c27da339698145a9383e052c1070a950d30da478
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Wed Sep 19 14:21:56 2007 +1000

    [POWERPC] Fix timekeeping on PowerPC 601
    
    Recent changes to the timekeeping code broke support for the PowerPC 601
    processor which doesn't have the usual timebase facility but a slightly
    different thing called (yuck) the RTC.
    
    This fixes it, boot tested on an old 601 based PowerMac 7200.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

commit 6a669ee8a790487b7ec1edda762d39615a78264b
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun Sep 16 15:36:43 2007 +0200

    timekeeping: Prevent time going backwards on resume
    
    Timekeeping resume adjusts xtime by adding the slept time in seconds and
    resets the reference value of the clock source (clock->cycle_last).
    clock->cycle last is used to calculate the delta between the last xtime
    update and the readout of the clock source in __get_nsec_offset(). xtime
    plus the offset is the current time. The resume code ignores the delta
    which had already elapsed between the last xtime update and the actual
    time of suspend. If the suspend time is short, then we can see time
    going backwards on resume.
    
    Suspend:
    offs_s = clock->read() - clock->cycle_last;
    now = xtime + offs_s;
    timekeeping_suspend_time = read_rtc();
    
    Resume:
    sleep_time = read_rtc() - timekeeping_suspend_time;
    xtime.tv_sec += sleep_time;
    clock->cycle_last = clock->read();
    offs_r = clock->read() - clock->cycle_last;
    now = xtime + offs_r;
    
    if sleep_time_seconds == 0 and offs_r < offs_s, then time goes
    backwards.
    
    Fix this by storing the offset from the last xtime update and add it to
    xtime during resume, when we reset clock->cycle_last:
    
    sleep_time = read_rtc() - timekeeping_suspend_time;
    xtime.tv_sec += sleep_time;
    xtime += offs_s;        /* Fixup xtime offset at suspend time */
    clock->cycle_last = clock->read();
    offs_r = clock->read() - clock->cycle_last;
    now = xtime + offs_r;
    
    Thanks to Marcelo for tracking this down on the OLPC and providing the
    necessary details to analyze the root cause.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: John Stultz <johnstul@us.ibm.com>
    Cc: Tosatti <marcelo@kvack.org>

commit 3be9095063885d482b87d3875ea7f28e635882d0
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun Sep 16 15:36:43 2007 +0200

    timekeeping: access rtc outside of xtime lock
    
    Lockdep complains about the access of rtc in timekeeping_suspend
    inside the interrupt disabled region of the write locked xtime lock.
    Move the access outside.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: John Stultz <johnstul@us.ibm.com>

commit ef81ab2c72e6979367612502fefbb18669e37879
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jul 21 17:10:12 2007 +0200

    x86_64: Use generic xtime init
    
    xtime can be initialized including the cmos update from the generic
    timekeeping code. Remove the arch specific implementation.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Chris Wright <chrisw@sous-sol.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andi Kleen <ak@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit 029641151bfede0930a79ecabb2572dc27a3c86f
Author: Thomas Hommel <thomas.hommel@gefanuc.com>
Date:   Sat Jul 21 04:37:58 2007 -0700

    rtc: add support for STK17TA8 chip
    
    This patch adds support for the Simtek STK17TA8 timekeeping chip.
    
    The STK17TA8 is quite similar to the DS1553, but differs in register layout
    and in various control bits in the registers.  I chose to make this a new
    driver to avoid confusion in the code and to not get lost in #ifdefs.
    
    Signed-off-by: Thomas Hommel <thomas.hommel@gefanuc.com>
    Cc: Alessandro Zummo <a.zummo@towertech.it>
    Cc: David Brownell <david-b@pacbell.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit efa7e8673c78cc6de2d6c367eb6f50449c57ed90
Merge: 02d6112cd7d7 bd807f9c5b90
Author: Linus Torvalds <torvalds@woody.linux-foundation.org>
Date:   Fri Jul 20 12:02:20 2007 -0700

    Merge branch 'release' of git://git.kernel.org/pub/scm/linux/kernel/git/aegl/linux-2.6
    
    * 'release' of git://git.kernel.org/pub/scm/linux/kernel/git/aegl/linux-2.6:
      [IA64] Prevent people from directly including <asm/rwsem.h>.
      [IA64] remove time interpolator
      [IA64] Convert to generic timekeeping/clocksource
      [IA64] refresh some config files for 64K pagesize
      [IA64] Delete iosapic_free_rte()
      [IA64] fallocate system call
      [IA64] Enable percpu vector domain for IA64_DIG
      [IA64] Enable percpu vector domain for IA64_GENERIC
      [IA64] Support irq migration across domain
      [IA64] Add support for vector domain
      [IA64] Add mapping table between irq and vector
      [IA64] Check if irq is sharable
      [IA64] Fix invalid irq vector assumption for iosapic
      [IA64] Use dynamic irq for iosapic interrupts
      [IA64] Use per iosapic lock for indirect iosapic register access
      [IA64] Cleanup lock order in iosapic_register_intr
      [IA64] Remove duplicated members in iosapic_rte_info
      [IA64] Remove block structure for locking in iosapic.c

commit 0aa366f351d044703e25c8425e508170e80d83b1
Author: Tony Luck <tony.luck@intel.com>
Date:   Fri Jul 20 11:22:30 2007 -0700

    [IA64] Convert to generic timekeeping/clocksource
    
    This is a merge of Peter Keilty's initial patch (which was
    revived by Bob Picco) for this with Hidetoshi Seto's fixes
    and scaling improvements.
    
    Acked-by: Bob Picco <bob.picco@hp.com>
    Signed-off-by: Tony Luck <tony.luck@intel.com>

commit 71120f183bff04ba4f7ba3cc554202061912d548
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Jul 19 01:49:16 2007 -0700

    timekeeping: fixup shadow variable argument
    
    clocksource_adjust() has a clock argument, which shadows the file global clock
    variable.  Fix this up.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: john stultz <johnstul@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit f34ddce1302d548244c499b2905ab2fe999610c6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 9 02:35:15 2007 -0700

    [PATCH] clocksource: fix resume logic
    
    We need to make sure that the clocksources are resumed, when timekeeping is
    resumed.  The current resume logic does not guarantee this.
    
    Add a resume function pointer to the clocksource struct, so clocksource
    drivers which need to reinitialize the clocksource can provide a resume
    function.
    
    Add a resume function, which calls the maybe available clocksource resume
    functions and resets the watchdog function, so a stable TSC can be used
    accross suspend/resume.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: john stultz <johnstul@us.ibm.com>
    Cc: Andi Kleen <ak@suse.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Chris Wright <chrisw@sous-sol.org>

commit d10ff3fb62bd38415c0f7be3d75d107e1f67e59a
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 14 11:10:02 2007 +0200

    timekeeping fix patch got mis-applied
    
    The time keeping code move to kernel/time/timekeeping.c broke the
    clocksource resume logic patch, which got applied to the old file by a
    fuzzy application.  Fix it up and move the clocksource_resume() call to
    the appropriate place.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    [ tssk, tssk, everybody should use --fuzz=0 ]
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit b52f52a093bb1e841e014c2087b5bee7162da413
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 9 02:35:15 2007 -0700

    clocksource: fix resume logic
    
    We need to make sure that the clocksources are resumed, when timekeeping is
    resumed.  The current resume logic does not guarantee this.
    
    Add a resume function pointer to the clocksource struct, so clocksource
    drivers which need to reinitialize the clocksource can provide a resume
    function.
    
    Add a resume function, which calls the maybe available clocksource resume
    functions and resets the watchdog function, so a stable TSC can be used
    accross suspend/resume.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: john stultz <johnstul@us.ibm.com>
    Cc: Andi Kleen <ak@suse.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: <stable@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit 8524070b7982d76258942275908b7434cfcab4b4
Author: John Stultz <johnstul@us.ibm.com>
Date:   Tue May 8 00:27:59 2007 -0700

    Move timekeeping code to timekeeping.c
    
    Move the timekeeping code out of kernel/timer.c and into
    kernel/time/timekeeping.c.  I made no cleanups or other changes in transit.
    
    [akpm@linux-foundation.org: build fix]
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit ee17b36fd0dc2af37ea92548595e30964674ded8
Author: John Stultz <johnstul@us.ibm.com>
Date:   Sun May 6 14:51:53 2007 -0700

    v850: generic timekeeping conversion
    
    Convert an arch that does not currently implement sub-jiffy timekeeping to
    use the generic timekeeping code.
    
    v850 looks like it has some intent to implement sub-jiffy timekeeping, so
    it may not yet be appropriate to try to convert, but I figured I'd get the
    maintainer's input and submit the patch for comment.
    
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Cc: Miles Bader <uclinux-v850@lsi.nec.co.jp>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit b7ec15bd004f4524bf091f851348da2ccb519e4f
Author: Jeff Dike <jdike@addtoit.com>
Date:   Sun May 6 14:51:51 2007 -0700

    uml: virtualized time fix
    
    With the current timekeeping, !CONFIG_UML_REAL_TIME_CLOCK has
    inconsistent behavior.  Previously, gettimeofday could be (and was)
    isolated from the clock ticking.  Now, it's not, so when
    CONFIG_UML_REAL_TIME_CLOCK is disabled, gettimeofday must progress in
    lockstep with the clock, making it fully virtual.
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Cc: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit aeecf3142d82414d511135cc85f86caddfb58338
Author: John Stultz <johnstul@us.ibm.com>
Date:   Sun May 6 14:50:34 2007 -0700

    Convert h8/300 to generic timekeeping
    
    Currently h8/300 does not implement sub-jiffy timekeeping, so there is no
    benefit to having arch specific timekeeping code.
    
    This patch simply removes those functions and enables the generic
    timekeeping code.
    
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Acked-by: Yoshinori Sato <ysato@users.sourceforge.jp>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit df3624aa293dfa2d46089747d919711089a702eb
Author: Daniel Walker <dwalker@mvista.com>
Date:   Wed May 2 19:27:18 2007 +0200

    [PATCH] i386: remove xtime_lock'ing around cpufreq notifier
    
    The locking of the xtime_lock around the cpu notifier is unessesary now.
    At one time the tsc was used after a frequency change for timekeeping, but
    the re-write of timekeeping no longer uses the TSC unless the frequency is
    constant.
    
    The variables that are changed in this section of code had also once been
    used for timekeeping, but not any longer ..
    
    Signed-off-by: Daniel Walker <dwalker@mvista.com>
    Signed-off-by: Andi Kleen <ak@suse.de>
    Cc: Andi Kleen <ak@suse.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: john stultz <johnstul@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>

commit b49c87c2a5059af14b68ee5f596ac0e9c93678bb
Author: Kevin Hilman <khilman@mvista.com>
Date:   Thu Mar 8 20:25:13 2007 +0100

    [ARM] 4260/1: clocksource support for Versatile platform
    
    Update Versatile to use new clocksource infrastructure for basic timekeeping.
    
    Signed-off-by: Kevin Hilman <khilman@mvista.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

commit 995f054f2a342f8505fed4f8395d12c0f5966414
Author: Ingo Molnar <mingo@elte.hu>
Date:   Sat Apr 7 12:05:00 2007 +0200

    [PATCH] high-res timers: resume fix
    
    Soeren Sonnenburg reported that upon resume he is getting
    this backtrace:
    
     [<c0119637>] smp_apic_timer_interrupt+0x57/0x90
     [<c0142d30>] retrigger_next_event+0x0/0xb0
     [<c0104d30>] apic_timer_interrupt+0x28/0x30
     [<c0142d30>] retrigger_next_event+0x0/0xb0
     [<c0140068>] __kfifo_put+0x8/0x90
     [<c0130fe5>] on_each_cpu+0x35/0x60
     [<c0143538>] clock_was_set+0x18/0x20
     [<c0135cdc>] timekeeping_resume+0x7c/0xa0
     [<c02aabe1>] __sysdev_resume+0x11/0x80
     [<c02ab0c7>] sysdev_resume+0x47/0x80
     [<c02b0b05>] device_power_up+0x5/0x10
    
    it turns out that on resume we mistakenly re-enable interrupts too
    early.  Do the timer retrigger only on the current CPU.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Soeren Sonnenburg <kernel@nn7.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit 6bb74df481223731af6c7e0ff3adb31f6442cfcd
Author: John Stultz <johnstul@us.ibm.com>
Date:   Mon Mar 5 00:30:50 2007 -0800

    [PATCH] clocksource init adjustments (fix bug #7426)
    
    This patch resolves the issue found here:
    http://bugme.osdl.org/show_bug.cgi?id=7426
    
    The basic summary is:
    Currently we register most of i386/x86_64 clocksources at module_init
    time. Then we enable clocksource selection at late_initcall time. This
    causes some problems for drivers that use gettimeofday for init
    calibration routines (specifically the es1968 driver in this case),
    where durring module_init, the only clocksource available is the low-res
    jiffies clocksource. This may cause slight calibration errors, due to
    the small sampling time used.
    
    It should be noted that drivers that require fine grained time may not
    function on architectures that do not have better then jiffies
    resolution timekeeping (there are a few). However, this does not
    discount the reasonable need for such fine-grained timekeeping at init
    time.
    
    Thus the solution here is to register clocksources earlier (ideally when
    the hardware is being initialized), and then we enable clocksource
    selection at fs_initcall (before device_initcall).
    
    This patch should probably get some testing time in -mm, since
    clocksource selection is one of the most important issues for correct
    timekeeping, and I've only been able to test this on a few of my own
    boxes.
    
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: "David S. Miller" <davem@davemloft.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit 9d6346311418d12e90cca9384e5fbbe2ffa18efb
Author: Daniel Walker <dwalker@mvista.com>
Date:   Wed Feb 28 20:12:07 2007 -0800

    [PATCH] update timekeeping_is_continuous comment
    
    Signed-off-by: Daniel Walker <dwalker@mvista.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit 2d0c87c3bc49c60ab5bbac401fb1ef37ff10bbe2
Author: John Stultz <johnstul@us.ibm.com>
Date:   Fri Feb 16 01:28:18 2007 -0800

    [PATCH] time: x86_64: hpet_address cleanup
    
    In preparation for supporting generic timekeeping, this patch cleans up
    x86-64's use of vxtime.hpet_address, changing it to just hpet_address as is
    also used in i386.  This is necessary since the vxtime structure will be going
    away.
    
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Andi Kleen <ak@muc.de>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit c1d370e167d66b10bca3b602d3740405469383de
Author: John Stultz <johnstul@us.ibm.com>
Date:   Fri Feb 16 01:27:31 2007 -0800

    [PATCH] i386: use GTOD persistent clock support
    
    Persistent clock support: do proper timekeeping across suspend/resume, i386
    arch support.
    
    [bunk@stusta.de: cleanup]
    Build-fixes-from: Andrew Morton <akpm@osdl.org>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Cc: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit 411187fb05cd11676b0979d9fbf3291db69dbce2
Author: John Stultz <johnstul@us.ibm.com>
Date:   Fri Feb 16 01:27:30 2007 -0800

    [PATCH] GTOD: persistent clock support
    
    Persistent clock support: do proper timekeeping across suspend/resume.
    
    [bunk@stusta.de: cleanup]
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Cc: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit 7be2c7c96aff2871240d61fef508c41176c688b5
Author: David Brownell <david-b@pacbell.net>
Date:   Sat Feb 10 01:46:02 2007 -0800

    [PATCH] RTC framework driver for CMOS RTCs
    
    This is an "RTC framework" driver for the "CMOS" RTCs which are standard on
    PCs and some other platforms.  That's MC146818 compatible silicon.
    Advantages of this vs.  drivers/char/rtc.c (use one _or_ the other, only
    one will be able to claim the RTC irq) include:
    
     - This leverages both the new RTC framework and the driver model; both
       PNPACPI and platform device modes are supported.  (A separate patch
       creates a platform device on PCs where PNPACPI isn't configured.)
    
     - It supports common extensions like longer alarms.  (A separate patch
       exports that information from ACPI through platform_data.)
    
     - Likewise, system wakeup events use "real driver model support", with
       policy control via sysfs "wakeup" attributes and and using normal rtc
       ioctls to manage wakeup.  (Patch in the works.  The ACPI hooks are
       known; /proc/acpi/alarm can vanish.  Making it work with EFI will
       be a minor challenge to someone with e.g. a MiniMac.)
    
    It's not yet been tested on non-x86 systems, without ACPI, or with HPET.
    And the RTC framework will surely have teething pains on "mainstream"
    PC-based systems (though must embedded Linux systems use it heavily), not
    limited to sorting out the "/dev/rtc0" issue (udev easily tweaked).  Also,
    the ALSA rtctimer code doesn't use the new RTC API.
    
    Otherwise, this should be a no-known-regressions replacement for the old
    drivers/char/rtc.c driver, and should help the non-embedded distros (and
    the new timekeeping code) start to switch to the framework.
    
    Note also that any systems using "rtc-m48t86" are candidates to switch over
    to this more functional driver; the platform data is different, and the way
    bytes are read is different, but otherwise those chips should be compatible.
    
    [akpm@osdl.org: sparc32 fix]
    [akpm@osdl.org: sparc64 fix]
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Cc: Woody Suwalski <woodys@xandros.com>
    Cc: Alessandro Zummo <alessandro.zummo@towertech.it>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit a670fad0adb1cc6202a607d250f10bd380593905
Author: Vojtech Pavlik <vojtech@suse.cz>
Date:   Tue Sep 26 10:52:28 2006 +0200

    [PATCH] Add initalization of the RDTSCP auxilliary values
    
    This patch adds initalization of the RDTSCP auxilliary values to CPU numbers
    to time.c. If RDTSCP is available, the MSRs are written with the respective
    values. It can be later used to initalize per-cpu timekeeping variables.
    
    AK: Some cleanups. Move externs into headers and fix CPU hotplug.
    
    Signed-off-by: Vojtech Pavlik <vojtech@suse.cz>
    Signed-off-by: Andi Kleen <ak@suse.de>

commit 38ce73ebd74a9a1738b73619557f2397c59ba628
Author: Lennert Buytenhek <buytenh@wantstofly.org>
Date:   Mon Sep 18 23:21:38 2006 +0100

    [ARM] 3825/1: iop3xx: use cp6 enable/disable macros
    
    Add CP6 enable/disable sequences to the timekeeping code and the IRQ
    code.  As a result, we can't depend on CP6 access being enabled when
    we enter get_irqnr_and_base anymore, so switch the latter over to
    using memory-mapped accesses for now.
    
    Signed-off-by: Lennert Buytenhek <buytenh@wantstofly.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

commit 3e143475c22036847f898d7e76ba337c1d7dbf6f
Author: John Stultz <johnstul@us.ibm.com>
Date:   Fri Jul 14 00:24:17 2006 -0700

    [PATCH] improve timekeeping resume robustness
    
    Resolve problems seen w/ APM suspend.
    
    Due to resume initialization ordering, its possible we could get a timer
    interrupt before the timekeeping resume() function is called.  This patch
    ensures we don't do any timekeeping accounting before we're fully resumed.
    
    (akpm: fixes the machine-freezes-on-APM-resume bug)
    
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

commit 88fecaa27f398d95db6c405a1908292c6f0bc3ef
Author: John Stultz <johnstul@us.ibm.com>
Date:   Mon Jul 3 00:24:04 2006 -0700

    [PATCH] time initialisation fix
    
    We're not reay to take a timer interrupt until timekeeping_init() has run.
    But time_init() will start the time interrupt and if it is called with
    local interrupts enabled we'll immediately take an interrupt and die.
    
    Fix that by running timekeeping_init() prior to time_init().
    
    We don't know _why_ local interrupts got enabled on Jesse Brandeburg's
    machine.  That's a separate as-yet-unsolved problem.  THe patch adds a little
    bit of debugging to detect that.
    
    This whole requirement that local interrupts be held off during early boot
    keeps on biting us.
    
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Cc: Jesse Brandeburg <jesse.brandeburg@gmail.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

commit 05ebb76109f302b949e745724bbf0f0634dba43f
Author: Vojtech Pavlik <vojtech@suse.cz>
Date:   Mon Jun 26 13:58:20 2006 +0200

    [PATCH] x86_64: Add useful constants to time.h
    
    In timekeeping code, one often does need to use conversion constants. Naming
    these leads to code that's easier to understand, showing the reader between
    which units the conversion is made.
    
    Signed-off-by: Vojtech Pavlik <vojtech@suse.cz>
    Signed-off-by: Andi Kleen <ak@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

commit 5d0cf410e94b1f1ff852c3f210d22cc6c5a27ffa
Author: John Stultz <johnstul@us.ibm.com>
Date:   Mon Jun 26 00:25:12 2006 -0700

    [PATCH] Time: i386 Clocksource Drivers
    
    Implement the time sources for i386 (acpi_pm, cyclone, hpet, pit, and tsc).
    With this patch, the conversion of the i386 arch to the generic timekeeping
    code should be complete.
    
    The patch should be fairly straight forward, only adding the new clocksources.
    
    [hirofumi@mail.parknet.co.jp: acpi_pm cleanup]
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: OGAWA Hirofumi <hirofumi@mail.parknet.co.jp>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

commit 6f84fa2f3edc8902cfed02cd510c7c58334bb9bd
Author: John Stultz <johnstul@us.ibm.com>
Date:   Mon Jun 26 00:25:11 2006 -0700

    [PATCH] Time: i386 Conversion - part 3: Enable Generic Timekeeping
    
    This converts the i386 arch to use the generic timeofday subsystem.  It
    enabled the GENERIC_TIME option, disables the timer_opts code and other arch
    specific timekeeping code and reworks the delay code.
    
    While this patch enables the generic timekeeping, please note that this patch
    does not provide any i386 clocksource.  Thus only the jiffies clocksource will
    be available.  To get full replacements for the code being disabled here, the
    timeofday-clocks-i386 patch will needed.
    
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

commit 539eb11e6e904f2cd4f62908cc5e44d724879721
Author: John Stultz <johnstul@us.ibm.com>
Date:   Mon Jun 26 00:25:10 2006 -0700

    [PATCH] Time: i386 Conversion - part 2: Rework TSC Support
    
    As part of the i386 conversion to the generic timekeeping infrastructure, this
    introduces a new tsc.c file.  The code in this file replaces the TSC
    initialization, management and access code currently in timer_tsc.c (which
    will be removed) that we want to preserve.
    
    The code also introduces the following functionality:
    
    o tsc_khz: like cpu_khz but stores the TSC frequency on systems that do not
      change TSC frequency w/ CPU frequency
    
    o check/mark_tsc_unstable: accessor/modifier flag for TSC timekeeping
      usability
    
    o minor cleanups to calibration math.
    
    This patch also includes a one line __cpuinitdata fix from Zwane Mwaikambo.
    
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

commit ad596171ed635c51a9eef829187af100cbf8dcf7
Author: John Stultz <johnstul@us.ibm.com>
Date:   Mon Jun 26 00:25:06 2006 -0700

    [PATCH] Time: Use clocksource infrastructure for update_wall_time
    
    Modify the update_wall_time function so it increments time using the
    clocksource abstraction instead of jiffies.  Since the only clocksource driver
    currently provided is the jiffies clocksource, this should result in no
    functional change.  Additionally, a timekeeping_init and timekeeping_resume
    function has been added to initialize and maintain some of the new timekeping
    state.
    
    [hirofumi@mail.parknet.co.jp: fixlet]
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: OGAWA Hirofumi <hirofumi@mail.parknet.co.jp>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

commit 092b8f3488a3e50a4ab5f2f3f7c8bbf56b3144e1
Author: Paul Mackerras <paulus@samba.org>
Date:   Mon Feb 20 10:38:56 2006 +1100

    powerpc: Keep xtime and gettimeofday in sync
    
    This fixes a regression which was introduced by moving ppc32 to use
    the same sort of lockless gettimeofday as ppc64 has been using for
    some time.  This involves getting the timebase and performing some
    simple arithmetic to convert it to seconds and microseconds.  However,
    the factor and offset used there weren't being updated when NTP
    varied the tick length using adjtimex.  64-bit didn't notice the
    problem because it had a hook in the 32-bit adjtimex compat routine
    that attempted to work out what the generic timekeeping code would
    do and alter the factor and offset to match.  However, that code
    was very complex and it wasn't clear that it still matched what the
    generic code would do.
    
    Now we use the generic current_tick_length() routine that was recently
    added to check that the current tick will be as long as we expect; if
    not we recompute the factor and offset.  This keeps gettimeofday and
    xtime in sync.  In addition we check that gettimeofday hasn't got ahead
    of xtime on each timer interrupt; if it has, we resync.
    
    Signed-off-by: Paul Mackerras <paulus@samba.org>

commit 726c14bf499e91e7ede4f1728830aba05c675061
Author: Paul Mackerras <paulus@samba.org>
Date:   Fri Feb 17 10:30:23 2006 +1100

    [PATCH] Provide an interface for getting the current tick length
    
    This provides an interface for arch code to find out how many
    nanoseconds are going to be added on to xtime by the next call to
    do_timer.  The value returned is a fixed-point number in 52.12 format
    in nanoseconds.  The reason for this format is that it gives the
    full precision that the timekeeping code is using internally.
    
    The motivation for this is to fix a problem that has arisen on 32-bit
    powerpc in that the value returned by do_gettimeofday drifts apart
    from xtime if NTP is being used.  PowerPC is now using a lockless
    do_gettimeofday based on reading the timebase register and performing
    some simple arithmetic.  (This method of getting the time is also
    exported to userspace via the VDSO.)  However, the factor and offset
    it uses were calculated based on the nominal tick length and weren't
    being adjusted when NTP varied the tick length.
    
    Note that 64-bit powerpc has had the lockless do_gettimeofday for a
    long time now.  It also had an extremely hairy routine that got called
    from the 32-bit compat routine for adjtimex, which adjusted the
    factor and offset according to what it thought the timekeeping code
    was going to do.  Not only was this only called if a 32-bit task did
    adjtimex (i.e. not if a 64-bit task did adjtimex), it was also
    duplicating computations from kernel/timer.c and it wasn't clear that
    it was (still) correct.
    
    The simple solution is to ask the timekeeping code how long the
    current jiffy will be on each timer interrupt, after calling
    do_timer.  If this jiffy will be a different length from the last one,
    we then need to compute new values for the factor and offset used in
    the lockless do_gettimeofday.  In this way we can keep xtime and
    do_gettimeofday in sync, even when NTP is varying the tick length.
    
    Note that when adjtimex varies the tick length, it almost always
    introduces the variation from the next tick on.  The only case I could
    see where adjtimex would vary the length of the current tick is when
    an old-style adjtime adjustment is being cancelled.  (It's not clear
    to me why the adjustment has to be cancelled immediately rather than
    from the next tick on.)  Thus I don't see any real need for a hook in
    adjtimex; the rare case of an old-style adjustment being cancelled can
    be fixed up at the next tick.
    
    Signed-off-by: Paul Mackerras <paulus@samba.org>
    Acked-by: john stultz <johnstul@us.ibm.com>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

commit bfaa1deeb982c985d8e0435e835baeaae63b57fd
Author: John Stultz <johnstul@us.ibm.com>
Date:   Wed Feb 1 03:05:19 2006 -0800

    [PATCH] disable lost tick compensation before TSCs are synced
    
    Avoid lost tick compensation early in boot before the TSCs are
    synchronized.  Currently timekeeping is enabled before the TSCs are
    synchronized, thus when the TSCs are synched (reset to zero), it appears
    that a number of lost ticks have occurred.  This can cause premature expiry
    of timers and in extreme cases can cause the soft lockup detection to fire.
    
    This resolves issues reported by Andy Whitcroft as well as bug #5366
    reported by Tim Mann.
    
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Acked-by: Andy Whitcroft <apw@shadowen.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

commit d93f4eb4134d693be834627d31cd7c4aac427911
Author: Richard Mortimer <richm@oldelvet.org.uk>
Date:   Tue Jan 17 15:23:00 2006 -0800

    [PATCH] Fix timekeeping on sparc64 ultra-IIe machines
    
    [SPARC64]: Eliminate race condition reading Hummingbird STICK register
    
    Ensure a consistent value is read from the STICK register by ensuring
    that both high and low are read without high changing due to a roll
    over of the low register.
    
    Various Debian/SPARC users (myself include) have noticed problems with
    Hummingbird based systems. The symptoms are that the system time is
    seen to jump forward 3 days, 6 hours, 11 minutes give or take a few
    seconds. In many cases the system then hangs some time afterwards.
    
    I've spotted a race condition in the code to read the STICK register.
    I could not work out why 3d, 6h, 11m is important but guess that it is
    due to the 2^32 jump of STICK (forwards on one read and then the next
    read will seem to be backwards) during a timer interrupt. I'm guessing
    that a change of -2^32 will get converted to a large unsigned
    increment after the arithmetic manipulation between STICK,
    nanoseconds, jiffies etc.
    
    I did a test where I modified __hbird_read_stick to artificially
    inject rollover faults forcefully every few seconds. With this I saw
    the clock jump over 6 times in 12 hours compared to once every month
    or so.
    
    Signed-off-by: Richard Mortimer <richm@oldelvet.org.uk>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Chris Wright <chrisw@sous-sol.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit fd4954714e8e7db9f6eb5878fa6111c46445ca81
Author: John Stultz <johnstul@us.ibm.com>
Date:   Mon Dec 12 22:17:13 2005 -0800

    [PATCH] x86_64: Fix collision between pmtimer and pit/hpet
    
    On systems that do not support the HPET legacy functions (basically the IBM
    x460, but there could be others), in time_init() we accidentally fall into a
    PM timer conditional and set the vxtime_hz value to the PM timer's frequency.
    We then use this value with the HPET for timekeeping.
    
    This patch (which mimics the behavior in time_init_gtod) corrects the
    collision.
    
    Signed-off-by: Andi Kleen <ak@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

commit a1c7e111934b6375baf07a970d6c890d18d7e34f
Author: Paul Mackerras <paulus@samba.org>
Date:   Fri Oct 21 22:39:36 2005 +1000

    [PATCH] ppc64: Fix typo in time calculations
    
    This fixes a typo in the div128_by_32 function used in the timekeeping
    calculations on ppc64.  If you look at the code it's quite obvious
    that we need (rb + c) rather than (rb + b).  The "b" is clearly just a
    typo.
    
    Signed-off-by: Paul Mackerras <paulus@samba.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

commit cbd27b8ced4b1888c93f69b4dd108a69ac4d733f
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Wed Oct 12 11:39:33 2005 +1000

    [PATCH] ppc32: Fix timekeeping
    
    Interestingly enough, ppc32 had broken timekeeping for ages...  It
    worked, but probably drifted a bit more than could be explained by the
    actual bad precision of the timebase calibration.  We discovered that
    recently when somebody figured out that the common code was using
    CLOCK_TICK_RATE to correct the timekeeing, and ppc32 had a completely
    bogus value for it.
    
    This patch turns it into something saner.  Probably not as good as doing
    something based on the actual timebase frequency precision but I'll
    leave that sort of math to others.  This at least makes it better for
    the common HZ values.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

commit 23cb8c297eb939b25e5a628dc9e8a71b17f1c44e
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Wed Oct 5 17:43:40 2005 +1000

    [PATCH] ppc: Fix timekeeping with HZ=250 on some Mac models
    
    Older Macs which uses the VIA chip timers to calibrate the timebase used
    some code that wouldn't work if HZ wasn't divisible by 100...
    
    This fixes it at least for 250.  Not totally perfect but should be
    enough for now (so it at least works with the default value which is now
    250).
    
    There is still a potential issue with the core using CLOCK_TICK_RATE to
    maintain xtime and CLOCK_TICK_RATE value on ppc32 is pure crap, but that
    is a different problem, this patch at least brings us back to our
    previous situation.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

commit e1474e2d9dfb782e6c6517a180b5a8913c69dfad
Author: Dave Hansen <haveblue@us.ibm.com>
Date:   Thu Jul 28 21:16:18 2005 -0700

    [PATCH] re-disable TSC on NUMAQ
    
    Somewhere recently, the TSC got re-enabled for timekeeping on NUMAQ
    machines.  However, the hardware makes these get unsynchronized quite
    badly.  So badly, in fact, that the code to fix up the skew can just hang
    on boot.
    
    This patch re-disables them.  It's nicely confined to the numaq.c file.  It
    would be great if this could make it into 2.6.13, I think it counts as a
    bugfix.
    
    Tested on a 16-proc 4-node NUMAQ.
    
    Signed-off-by: Dave Hansen <haveblue@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

commit f2be64b3b15f52ceb83ff26abc10705a31ae5352
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue Jun 28 21:01:16 2005 +0100

    [PATCH] ARM: 2760/1: Add a warning on dynamic tick timekeeping on some platforms
    
    Patch from Tony Lindgren
    
    This patch was suggested by RMK, and adds a warning on the accuracy
    of timekeeping when using dynamic tick on some platforms. Depending
    on the timer implementation, dynamic tick may affect the accuracy of
    timekeeping.
    Currently at least OMAP is known to have accurate timekeeping with
    dynamic tick.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

commit e4fe19819ef32950541503042f32e71b67edffc7
Author: Lennert Buytenhek <buytenh@org.rmk.(none)>
Date:   Mon Jun 20 18:51:07 2005 +0100

    [PATCH] ARM: 2701/1: free up ixp2000 timer 4 for the watchdog
    
    Patch from Lennert Buytenhek
    
    The IXP2000 has four timers, but if we're on an A-step IXP2800, timer
    2 and 3 don't work.  We need two timers for timekeeping (one for the
    timer interrupt and one for tracking missed jiffies), so on early
    IXP2800s we have no other choice but to use timer 1 and 4 for that,
    but on all other IXP2000s we'd rather leave timer 4 free since that's
    the only timer we can use for the watchdog.
    So, on buggy IXP2000s (i.e. the A-step IXP2800) we use timer 4 for
    tracking missed jiffies, and on all all non-buggy IXP2000s (i.e.
    everything but the A-step IXP2800) we use timer 2.
    On a pre-production IXP2800, this patch should print these messages
    on boot:
            Enabling IXP2800 erratum #25 workaround
            Unable to use IXP2000 watchdog due to IXP2800 erratum #25
    On any non-buggy IXP2800 (as well as on IXP2400s) you shouldn't see
    anything at all, and the watchdog should be usable again.
    
    Signed-off-by: Lennert Buytenhek
    Signed-off-by: Deepak Saxena
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
