commit 7ae6aa649394e1e7f6dafb55ce0d578c0572a280
Author: Luo Meng <luomeng12@huawei.com>
Date:   Tue Nov 29 10:48:47 2022 +0800

    dm thin: Fix UAF in run_timer_softirq()
    
    commit 88430ebcbc0ec637b710b947738839848c20feff upstream.
    
    When dm_resume() and dm_destroy() are concurrent, it will
    lead to UAF, as follows:
    
     BUG: KASAN: use-after-free in __run_timers+0x173/0x710
     Write of size 8 at addr ffff88816d9490f0 by task swapper/0/0
    <snip>
     Call Trace:
      <IRQ>
      dump_stack_lvl+0x73/0x9f
      print_report.cold+0x132/0xaa2
      _raw_spin_lock_irqsave+0xcd/0x160
      __run_timers+0x173/0x710
      kasan_report+0xad/0x110
      __run_timers+0x173/0x710
      __asan_store8+0x9c/0x140
      __run_timers+0x173/0x710
      call_timer_fn+0x310/0x310
      pvclock_clocksource_read+0xfa/0x250
      kvm_clock_read+0x2c/0x70
      kvm_clock_get_cycles+0xd/0x20
      ktime_get+0x5c/0x110
      lapic_next_event+0x38/0x50
      clockevents_program_event+0xf1/0x1e0
      run_timer_softirq+0x49/0x90
      __do_softirq+0x16e/0x62c
      __irq_exit_rcu+0x1fa/0x270
      irq_exit_rcu+0x12/0x20
      sysvec_apic_timer_interrupt+0x8e/0xc0
    
    One of the concurrency UAF can be shown as below:
    
            use                                  free
    do_resume                           |
      __find_device_hash_cell           |
        dm_get                          |
          atomic_inc(&md->holders)      |
                                        | dm_destroy
                                        |   __dm_destroy
                                        |     if (!dm_suspended_md(md))
                                        |     atomic_read(&md->holders)
                                        |     msleep(1)
      dm_resume                         |
        __dm_resume                     |
          dm_table_resume_targets       |
            pool_resume                 |
              do_waker  #add delay work |
      dm_put                            |
        atomic_dec(&md->holders)        |
                                        |     dm_table_destroy
                                        |       pool_dtr
                                        |         __pool_dec
                                        |           __pool_destroy
                                        |             destroy_workqueue
                                        |             kfree(pool) # free pool
            time out
    __do_softirq
      run_timer_softirq # pool has already been freed
    
    This can be easily reproduced using:
      1. create thin-pool
      2. dmsetup suspend pool
      3. dmsetup resume pool
      4. dmsetup remove_all # Concurrent with 3
    
    The root cause of this UAF bug is that dm_resume() adds timer after
    dm_destroy() skips cancelling the timer because of suspend status.
    After timeout, it will call run_timer_softirq(), however pool has
    already been freed. The concurrency UAF bug will happen.
    
    Therefore, cancelling timer again in __pool_destroy().
    
    Cc: stable@vger.kernel.org
    Fixes: 991d9fa02da0d ("dm: add thin provisioning target")
    Signed-off-by: Luo Meng <luomeng12@huawei.com>
    Signed-off-by: Mike Snitzer <snitzer@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit e8b8e0d2bbf7d1172c4f435621418e29ee408d46
Author: Luo Meng <luomeng12@huawei.com>
Date:   Tue Nov 29 10:48:47 2022 +0800

    dm thin: Fix UAF in run_timer_softirq()
    
    commit 88430ebcbc0ec637b710b947738839848c20feff upstream.
    
    When dm_resume() and dm_destroy() are concurrent, it will
    lead to UAF, as follows:
    
     BUG: KASAN: use-after-free in __run_timers+0x173/0x710
     Write of size 8 at addr ffff88816d9490f0 by task swapper/0/0
    <snip>
     Call Trace:
      <IRQ>
      dump_stack_lvl+0x73/0x9f
      print_report.cold+0x132/0xaa2
      _raw_spin_lock_irqsave+0xcd/0x160
      __run_timers+0x173/0x710
      kasan_report+0xad/0x110
      __run_timers+0x173/0x710
      __asan_store8+0x9c/0x140
      __run_timers+0x173/0x710
      call_timer_fn+0x310/0x310
      pvclock_clocksource_read+0xfa/0x250
      kvm_clock_read+0x2c/0x70
      kvm_clock_get_cycles+0xd/0x20
      ktime_get+0x5c/0x110
      lapic_next_event+0x38/0x50
      clockevents_program_event+0xf1/0x1e0
      run_timer_softirq+0x49/0x90
      __do_softirq+0x16e/0x62c
      __irq_exit_rcu+0x1fa/0x270
      irq_exit_rcu+0x12/0x20
      sysvec_apic_timer_interrupt+0x8e/0xc0
    
    One of the concurrency UAF can be shown as below:
    
            use                                  free
    do_resume                           |
      __find_device_hash_cell           |
        dm_get                          |
          atomic_inc(&md->holders)      |
                                        | dm_destroy
                                        |   __dm_destroy
                                        |     if (!dm_suspended_md(md))
                                        |     atomic_read(&md->holders)
                                        |     msleep(1)
      dm_resume                         |
        __dm_resume                     |
          dm_table_resume_targets       |
            pool_resume                 |
              do_waker  #add delay work |
      dm_put                            |
        atomic_dec(&md->holders)        |
                                        |     dm_table_destroy
                                        |       pool_dtr
                                        |         __pool_dec
                                        |           __pool_destroy
                                        |             destroy_workqueue
                                        |             kfree(pool) # free pool
            time out
    __do_softirq
      run_timer_softirq # pool has already been freed
    
    This can be easily reproduced using:
      1. create thin-pool
      2. dmsetup suspend pool
      3. dmsetup resume pool
      4. dmsetup remove_all # Concurrent with 3
    
    The root cause of this UAF bug is that dm_resume() adds timer after
    dm_destroy() skips cancelling the timer because of suspend status.
    After timeout, it will call run_timer_softirq(), however pool has
    already been freed. The concurrency UAF bug will happen.
    
    Therefore, cancelling timer again in __pool_destroy().
    
    Cc: stable@vger.kernel.org
    Fixes: 991d9fa02da0d ("dm: add thin provisioning target")
    Signed-off-by: Luo Meng <luomeng12@huawei.com>
    Signed-off-by: Mike Snitzer <snitzer@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 550a4fac7ecfee5bac6a0dd772456ca62fb72f46
Author: Luo Meng <luomeng12@huawei.com>
Date:   Tue Nov 29 10:48:47 2022 +0800

    dm thin: Fix UAF in run_timer_softirq()
    
    commit 88430ebcbc0ec637b710b947738839848c20feff upstream.
    
    When dm_resume() and dm_destroy() are concurrent, it will
    lead to UAF, as follows:
    
     BUG: KASAN: use-after-free in __run_timers+0x173/0x710
     Write of size 8 at addr ffff88816d9490f0 by task swapper/0/0
    <snip>
     Call Trace:
      <IRQ>
      dump_stack_lvl+0x73/0x9f
      print_report.cold+0x132/0xaa2
      _raw_spin_lock_irqsave+0xcd/0x160
      __run_timers+0x173/0x710
      kasan_report+0xad/0x110
      __run_timers+0x173/0x710
      __asan_store8+0x9c/0x140
      __run_timers+0x173/0x710
      call_timer_fn+0x310/0x310
      pvclock_clocksource_read+0xfa/0x250
      kvm_clock_read+0x2c/0x70
      kvm_clock_get_cycles+0xd/0x20
      ktime_get+0x5c/0x110
      lapic_next_event+0x38/0x50
      clockevents_program_event+0xf1/0x1e0
      run_timer_softirq+0x49/0x90
      __do_softirq+0x16e/0x62c
      __irq_exit_rcu+0x1fa/0x270
      irq_exit_rcu+0x12/0x20
      sysvec_apic_timer_interrupt+0x8e/0xc0
    
    One of the concurrency UAF can be shown as below:
    
            use                                  free
    do_resume                           |
      __find_device_hash_cell           |
        dm_get                          |
          atomic_inc(&md->holders)      |
                                        | dm_destroy
                                        |   __dm_destroy
                                        |     if (!dm_suspended_md(md))
                                        |     atomic_read(&md->holders)
                                        |     msleep(1)
      dm_resume                         |
        __dm_resume                     |
          dm_table_resume_targets       |
            pool_resume                 |
              do_waker  #add delay work |
      dm_put                            |
        atomic_dec(&md->holders)        |
                                        |     dm_table_destroy
                                        |       pool_dtr
                                        |         __pool_dec
                                        |           __pool_destroy
                                        |             destroy_workqueue
                                        |             kfree(pool) # free pool
            time out
    __do_softirq
      run_timer_softirq # pool has already been freed
    
    This can be easily reproduced using:
      1. create thin-pool
      2. dmsetup suspend pool
      3. dmsetup resume pool
      4. dmsetup remove_all # Concurrent with 3
    
    The root cause of this UAF bug is that dm_resume() adds timer after
    dm_destroy() skips cancelling the timer because of suspend status.
    After timeout, it will call run_timer_softirq(), however pool has
    already been freed. The concurrency UAF bug will happen.
    
    Therefore, cancelling timer again in __pool_destroy().
    
    Cc: stable@vger.kernel.org
    Fixes: 991d9fa02da0d ("dm: add thin provisioning target")
    Signed-off-by: Luo Meng <luomeng12@huawei.com>
    Signed-off-by: Mike Snitzer <snitzer@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 34fe9c2251f19786a6689149a6212c6c0de1d63b
Author: Luo Meng <luomeng12@huawei.com>
Date:   Tue Nov 29 10:48:47 2022 +0800

    dm thin: Fix UAF in run_timer_softirq()
    
    commit 88430ebcbc0ec637b710b947738839848c20feff upstream.
    
    When dm_resume() and dm_destroy() are concurrent, it will
    lead to UAF, as follows:
    
     BUG: KASAN: use-after-free in __run_timers+0x173/0x710
     Write of size 8 at addr ffff88816d9490f0 by task swapper/0/0
    <snip>
     Call Trace:
      <IRQ>
      dump_stack_lvl+0x73/0x9f
      print_report.cold+0x132/0xaa2
      _raw_spin_lock_irqsave+0xcd/0x160
      __run_timers+0x173/0x710
      kasan_report+0xad/0x110
      __run_timers+0x173/0x710
      __asan_store8+0x9c/0x140
      __run_timers+0x173/0x710
      call_timer_fn+0x310/0x310
      pvclock_clocksource_read+0xfa/0x250
      kvm_clock_read+0x2c/0x70
      kvm_clock_get_cycles+0xd/0x20
      ktime_get+0x5c/0x110
      lapic_next_event+0x38/0x50
      clockevents_program_event+0xf1/0x1e0
      run_timer_softirq+0x49/0x90
      __do_softirq+0x16e/0x62c
      __irq_exit_rcu+0x1fa/0x270
      irq_exit_rcu+0x12/0x20
      sysvec_apic_timer_interrupt+0x8e/0xc0
    
    One of the concurrency UAF can be shown as below:
    
            use                                  free
    do_resume                           |
      __find_device_hash_cell           |
        dm_get                          |
          atomic_inc(&md->holders)      |
                                        | dm_destroy
                                        |   __dm_destroy
                                        |     if (!dm_suspended_md(md))
                                        |     atomic_read(&md->holders)
                                        |     msleep(1)
      dm_resume                         |
        __dm_resume                     |
          dm_table_resume_targets       |
            pool_resume                 |
              do_waker  #add delay work |
      dm_put                            |
        atomic_dec(&md->holders)        |
                                        |     dm_table_destroy
                                        |       pool_dtr
                                        |         __pool_dec
                                        |           __pool_destroy
                                        |             destroy_workqueue
                                        |             kfree(pool) # free pool
            time out
    __do_softirq
      run_timer_softirq # pool has already been freed
    
    This can be easily reproduced using:
      1. create thin-pool
      2. dmsetup suspend pool
      3. dmsetup resume pool
      4. dmsetup remove_all # Concurrent with 3
    
    The root cause of this UAF bug is that dm_resume() adds timer after
    dm_destroy() skips cancelling the timer because of suspend status.
    After timeout, it will call run_timer_softirq(), however pool has
    already been freed. The concurrency UAF bug will happen.
    
    Therefore, cancelling timer again in __pool_destroy().
    
    Cc: stable@vger.kernel.org
    Fixes: 991d9fa02da0d ("dm: add thin provisioning target")
    Signed-off-by: Luo Meng <luomeng12@huawei.com>
    Signed-off-by: Mike Snitzer <snitzer@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 34cd15d83b7206188d440b29b68084fcafde9395
Author: Luo Meng <luomeng12@huawei.com>
Date:   Tue Nov 29 10:48:47 2022 +0800

    dm thin: Fix UAF in run_timer_softirq()
    
    commit 88430ebcbc0ec637b710b947738839848c20feff upstream.
    
    When dm_resume() and dm_destroy() are concurrent, it will
    lead to UAF, as follows:
    
     BUG: KASAN: use-after-free in __run_timers+0x173/0x710
     Write of size 8 at addr ffff88816d9490f0 by task swapper/0/0
    <snip>
     Call Trace:
      <IRQ>
      dump_stack_lvl+0x73/0x9f
      print_report.cold+0x132/0xaa2
      _raw_spin_lock_irqsave+0xcd/0x160
      __run_timers+0x173/0x710
      kasan_report+0xad/0x110
      __run_timers+0x173/0x710
      __asan_store8+0x9c/0x140
      __run_timers+0x173/0x710
      call_timer_fn+0x310/0x310
      pvclock_clocksource_read+0xfa/0x250
      kvm_clock_read+0x2c/0x70
      kvm_clock_get_cycles+0xd/0x20
      ktime_get+0x5c/0x110
      lapic_next_event+0x38/0x50
      clockevents_program_event+0xf1/0x1e0
      run_timer_softirq+0x49/0x90
      __do_softirq+0x16e/0x62c
      __irq_exit_rcu+0x1fa/0x270
      irq_exit_rcu+0x12/0x20
      sysvec_apic_timer_interrupt+0x8e/0xc0
    
    One of the concurrency UAF can be shown as below:
    
            use                                  free
    do_resume                           |
      __find_device_hash_cell           |
        dm_get                          |
          atomic_inc(&md->holders)      |
                                        | dm_destroy
                                        |   __dm_destroy
                                        |     if (!dm_suspended_md(md))
                                        |     atomic_read(&md->holders)
                                        |     msleep(1)
      dm_resume                         |
        __dm_resume                     |
          dm_table_resume_targets       |
            pool_resume                 |
              do_waker  #add delay work |
      dm_put                            |
        atomic_dec(&md->holders)        |
                                        |     dm_table_destroy
                                        |       pool_dtr
                                        |         __pool_dec
                                        |           __pool_destroy
                                        |             destroy_workqueue
                                        |             kfree(pool) # free pool
            time out
    __do_softirq
      run_timer_softirq # pool has already been freed
    
    This can be easily reproduced using:
      1. create thin-pool
      2. dmsetup suspend pool
      3. dmsetup resume pool
      4. dmsetup remove_all # Concurrent with 3
    
    The root cause of this UAF bug is that dm_resume() adds timer after
    dm_destroy() skips cancelling the timer because of suspend status.
    After timeout, it will call run_timer_softirq(), however pool has
    already been freed. The concurrency UAF bug will happen.
    
    Therefore, cancelling timer again in __pool_destroy().
    
    Cc: stable@vger.kernel.org
    Fixes: 991d9fa02da0d ("dm: add thin provisioning target")
    Signed-off-by: Luo Meng <luomeng12@huawei.com>
    Signed-off-by: Mike Snitzer <snitzer@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 7ee059d06a5d3c15465959e0472993e80fbe4e81
Author: Luo Meng <luomeng12@huawei.com>
Date:   Tue Nov 29 10:48:47 2022 +0800

    dm thin: Fix UAF in run_timer_softirq()
    
    commit 88430ebcbc0ec637b710b947738839848c20feff upstream.
    
    When dm_resume() and dm_destroy() are concurrent, it will
    lead to UAF, as follows:
    
     BUG: KASAN: use-after-free in __run_timers+0x173/0x710
     Write of size 8 at addr ffff88816d9490f0 by task swapper/0/0
    <snip>
     Call Trace:
      <IRQ>
      dump_stack_lvl+0x73/0x9f
      print_report.cold+0x132/0xaa2
      _raw_spin_lock_irqsave+0xcd/0x160
      __run_timers+0x173/0x710
      kasan_report+0xad/0x110
      __run_timers+0x173/0x710
      __asan_store8+0x9c/0x140
      __run_timers+0x173/0x710
      call_timer_fn+0x310/0x310
      pvclock_clocksource_read+0xfa/0x250
      kvm_clock_read+0x2c/0x70
      kvm_clock_get_cycles+0xd/0x20
      ktime_get+0x5c/0x110
      lapic_next_event+0x38/0x50
      clockevents_program_event+0xf1/0x1e0
      run_timer_softirq+0x49/0x90
      __do_softirq+0x16e/0x62c
      __irq_exit_rcu+0x1fa/0x270
      irq_exit_rcu+0x12/0x20
      sysvec_apic_timer_interrupt+0x8e/0xc0
    
    One of the concurrency UAF can be shown as below:
    
            use                                  free
    do_resume                           |
      __find_device_hash_cell           |
        dm_get                          |
          atomic_inc(&md->holders)      |
                                        | dm_destroy
                                        |   __dm_destroy
                                        |     if (!dm_suspended_md(md))
                                        |     atomic_read(&md->holders)
                                        |     msleep(1)
      dm_resume                         |
        __dm_resume                     |
          dm_table_resume_targets       |
            pool_resume                 |
              do_waker  #add delay work |
      dm_put                            |
        atomic_dec(&md->holders)        |
                                        |     dm_table_destroy
                                        |       pool_dtr
                                        |         __pool_dec
                                        |           __pool_destroy
                                        |             destroy_workqueue
                                        |             kfree(pool) # free pool
            time out
    __do_softirq
      run_timer_softirq # pool has already been freed
    
    This can be easily reproduced using:
      1. create thin-pool
      2. dmsetup suspend pool
      3. dmsetup resume pool
      4. dmsetup remove_all # Concurrent with 3
    
    The root cause of this UAF bug is that dm_resume() adds timer after
    dm_destroy() skips cancelling the timer because of suspend status.
    After timeout, it will call run_timer_softirq(), however pool has
    already been freed. The concurrency UAF bug will happen.
    
    Therefore, cancelling timer again in __pool_destroy().
    
    Cc: stable@vger.kernel.org
    Fixes: 991d9fa02da0d ("dm: add thin provisioning target")
    Signed-off-by: Luo Meng <luomeng12@huawei.com>
    Signed-off-by: Mike Snitzer <snitzer@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 94e231c9d6f2648d2f1f68e7f476e050ee0a6159
Author: Luo Meng <luomeng12@huawei.com>
Date:   Tue Nov 29 10:48:47 2022 +0800

    dm thin: Fix UAF in run_timer_softirq()
    
    commit 88430ebcbc0ec637b710b947738839848c20feff upstream.
    
    When dm_resume() and dm_destroy() are concurrent, it will
    lead to UAF, as follows:
    
     BUG: KASAN: use-after-free in __run_timers+0x173/0x710
     Write of size 8 at addr ffff88816d9490f0 by task swapper/0/0
    <snip>
     Call Trace:
      <IRQ>
      dump_stack_lvl+0x73/0x9f
      print_report.cold+0x132/0xaa2
      _raw_spin_lock_irqsave+0xcd/0x160
      __run_timers+0x173/0x710
      kasan_report+0xad/0x110
      __run_timers+0x173/0x710
      __asan_store8+0x9c/0x140
      __run_timers+0x173/0x710
      call_timer_fn+0x310/0x310
      pvclock_clocksource_read+0xfa/0x250
      kvm_clock_read+0x2c/0x70
      kvm_clock_get_cycles+0xd/0x20
      ktime_get+0x5c/0x110
      lapic_next_event+0x38/0x50
      clockevents_program_event+0xf1/0x1e0
      run_timer_softirq+0x49/0x90
      __do_softirq+0x16e/0x62c
      __irq_exit_rcu+0x1fa/0x270
      irq_exit_rcu+0x12/0x20
      sysvec_apic_timer_interrupt+0x8e/0xc0
    
    One of the concurrency UAF can be shown as below:
    
            use                                  free
    do_resume                           |
      __find_device_hash_cell           |
        dm_get                          |
          atomic_inc(&md->holders)      |
                                        | dm_destroy
                                        |   __dm_destroy
                                        |     if (!dm_suspended_md(md))
                                        |     atomic_read(&md->holders)
                                        |     msleep(1)
      dm_resume                         |
        __dm_resume                     |
          dm_table_resume_targets       |
            pool_resume                 |
              do_waker  #add delay work |
      dm_put                            |
        atomic_dec(&md->holders)        |
                                        |     dm_table_destroy
                                        |       pool_dtr
                                        |         __pool_dec
                                        |           __pool_destroy
                                        |             destroy_workqueue
                                        |             kfree(pool) # free pool
            time out
    __do_softirq
      run_timer_softirq # pool has already been freed
    
    This can be easily reproduced using:
      1. create thin-pool
      2. dmsetup suspend pool
      3. dmsetup resume pool
      4. dmsetup remove_all # Concurrent with 3
    
    The root cause of this UAF bug is that dm_resume() adds timer after
    dm_destroy() skips cancelling the timer because of suspend status.
    After timeout, it will call run_timer_softirq(), however pool has
    already been freed. The concurrency UAF bug will happen.
    
    Therefore, cancelling timer again in __pool_destroy().
    
    Cc: stable@vger.kernel.org
    Fixes: 991d9fa02da0d ("dm: add thin provisioning target")
    Signed-off-by: Luo Meng <luomeng12@huawei.com>
    Signed-off-by: Mike Snitzer <snitzer@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit d9971fa4d8bde63d49c743c1b32d12fbbd3a30bd
Author: Luo Meng <luomeng12@huawei.com>
Date:   Tue Nov 29 10:48:47 2022 +0800

    dm thin: Fix UAF in run_timer_softirq()
    
    commit 88430ebcbc0ec637b710b947738839848c20feff upstream.
    
    When dm_resume() and dm_destroy() are concurrent, it will
    lead to UAF, as follows:
    
     BUG: KASAN: use-after-free in __run_timers+0x173/0x710
     Write of size 8 at addr ffff88816d9490f0 by task swapper/0/0
    <snip>
     Call Trace:
      <IRQ>
      dump_stack_lvl+0x73/0x9f
      print_report.cold+0x132/0xaa2
      _raw_spin_lock_irqsave+0xcd/0x160
      __run_timers+0x173/0x710
      kasan_report+0xad/0x110
      __run_timers+0x173/0x710
      __asan_store8+0x9c/0x140
      __run_timers+0x173/0x710
      call_timer_fn+0x310/0x310
      pvclock_clocksource_read+0xfa/0x250
      kvm_clock_read+0x2c/0x70
      kvm_clock_get_cycles+0xd/0x20
      ktime_get+0x5c/0x110
      lapic_next_event+0x38/0x50
      clockevents_program_event+0xf1/0x1e0
      run_timer_softirq+0x49/0x90
      __do_softirq+0x16e/0x62c
      __irq_exit_rcu+0x1fa/0x270
      irq_exit_rcu+0x12/0x20
      sysvec_apic_timer_interrupt+0x8e/0xc0
    
    One of the concurrency UAF can be shown as below:
    
            use                                  free
    do_resume                           |
      __find_device_hash_cell           |
        dm_get                          |
          atomic_inc(&md->holders)      |
                                        | dm_destroy
                                        |   __dm_destroy
                                        |     if (!dm_suspended_md(md))
                                        |     atomic_read(&md->holders)
                                        |     msleep(1)
      dm_resume                         |
        __dm_resume                     |
          dm_table_resume_targets       |
            pool_resume                 |
              do_waker  #add delay work |
      dm_put                            |
        atomic_dec(&md->holders)        |
                                        |     dm_table_destroy
                                        |       pool_dtr
                                        |         __pool_dec
                                        |           __pool_destroy
                                        |             destroy_workqueue
                                        |             kfree(pool) # free pool
            time out
    __do_softirq
      run_timer_softirq # pool has already been freed
    
    This can be easily reproduced using:
      1. create thin-pool
      2. dmsetup suspend pool
      3. dmsetup resume pool
      4. dmsetup remove_all # Concurrent with 3
    
    The root cause of this UAF bug is that dm_resume() adds timer after
    dm_destroy() skips cancelling the timer because of suspend status.
    After timeout, it will call run_timer_softirq(), however pool has
    already been freed. The concurrency UAF bug will happen.
    
    Therefore, cancelling timer again in __pool_destroy().
    
    Cc: stable@vger.kernel.org
    Fixes: 991d9fa02da0d ("dm: add thin provisioning target")
    Signed-off-by: Luo Meng <luomeng12@huawei.com>
    Signed-off-by: Mike Snitzer <snitzer@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 0a1d4434db5f86c50018fe0aab299ac97dc15b76
Merge: 79ad89123c25 18a207849218
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Dec 12 12:52:02 2022 -0800

    Merge tag 'timers-core-2022-12-10' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer updates from Thomas Gleixner:
     "Updates for timers, timekeeping and drivers:
    
      Core:
    
       - The timer_shutdown[_sync]() infrastructure:
    
         Tearing down timers can be tedious when there are circular
         dependencies to other things which need to be torn down. A prime
         example is timer and workqueue where the timer schedules work and
         the work arms the timer.
    
         What needs to prevented is that pending work which is drained via
         destroy_workqueue() does not rearm the previously shutdown timer.
         Nothing in that shutdown sequence relies on the timer being
         functional.
    
         The conclusion was that the semantics of timer_shutdown_sync()
         should be:
            - timer is not enqueued
            - timer callback is not running
            - timer cannot be rearmed
    
         Preventing the rearming of shutdown timers is done by discarding
         rearm attempts silently.
    
         A warning for the case that a rearm attempt of a shutdown timer is
         detected would not be really helpful because it's entirely unclear
         how it should be acted upon. The only way to address such a case is
         to add 'if (in_shutdown)' conditionals all over the place. This is
         error prone and in most cases of teardown not required all.
    
       - The real fix for the bluetooth HCI teardown based on
         timer_shutdown_sync().
    
         A larger scale conversion to timer_shutdown_sync() is work in
         progress.
    
       - Consolidation of VDSO time namespace helper functions
    
       - Small fixes for timer and timerqueue
    
      Drivers:
    
       - Prevent integer overflow on the XGene-1 TVAL register which causes
         an never ending interrupt storm.
    
       - The usual set of new device tree bindings
    
       - Small fixes and improvements all over the place"
    
    * tag 'timers-core-2022-12-10' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (34 commits)
      dt-bindings: timer: renesas,cmt: Add r8a779g0 CMT support
      dt-bindings: timer: renesas,tmu: Add r8a779g0 support
      clocksource/drivers/arm_arch_timer: Use kstrtobool() instead of strtobool()
      clocksource/drivers/timer-ti-dm: Fix missing clk_disable_unprepare in dmtimer_systimer_init_clock()
      clocksource/drivers/timer-ti-dm: Clear settings on probe and free
      clocksource/drivers/timer-ti-dm: Make timer_get_irq static
      clocksource/drivers/timer-ti-dm: Fix warning for omap_timer_match
      clocksource/drivers/arm_arch_timer: Fix XGene-1 TVAL register math error
      clocksource/drivers/timer-npcm7xx: Enable timer 1 clock before use
      dt-bindings: timer: nuvoton,npcm7xx-timer: Allow specifying all clocks
      dt-bindings: timer: rockchip: Add rockchip,rk3128-timer
      clockevents: Repair kernel-doc for clockevent_delta2ns()
      clocksource/drivers/ingenic-ost: Define pm functions properly in platform_driver struct
      clocksource/drivers/sh_cmt: Access registers according to spec
      vdso/timens: Refactor copy-pasted find_timens_vvar_page() helper into one copy
      Bluetooth: hci_qca: Fix the teardown problem for real
      timers: Update the documentation to reflect on the new timer_shutdown() API
      timers: Provide timer_shutdown[_sync]()
      timers: Add shutdown mechanism to the internal functions
      timers: Split [try_to_]del_timer[_sync]() to prepare for shutdown mode
      ...

commit ebe11732838f39bd10bddafd4dfe2f97010fde62
Author: Lukas Bulwahn <lukas.bulwahn@gmail.com>
Date:   Wed Nov 2 10:10:48 2022 +0100

    clockevents: Repair kernel-doc for clockevent_delta2ns()
    
    Since the introduction of clockevents, i.e., commit d316c57ff6bf
    ("clockevents: add core functionality"), there has been a mismatch between
    the function and the kernel-doc comment for clockevent_delta2ns().
    
    Hence, ./scripts/kernel-doc -none kernel/time/clockevents.c warns about it.
    
    Adjust the kernel-doc comment for clockevent_delta2ns() for make W=1
    happiness.
    
    Signed-off-by: Lukas Bulwahn <lukas.bulwahn@gmail.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lore.kernel.org/r/20221102091048.15068-1-lukas.bulwahn@gmail.com

commit 88430ebcbc0ec637b710b947738839848c20feff
Author: Luo Meng <luomeng12@huawei.com>
Date:   Tue Nov 29 10:48:47 2022 +0800

    dm thin: Fix UAF in run_timer_softirq()
    
    When dm_resume() and dm_destroy() are concurrent, it will
    lead to UAF, as follows:
    
     BUG: KASAN: use-after-free in __run_timers+0x173/0x710
     Write of size 8 at addr ffff88816d9490f0 by task swapper/0/0
    <snip>
     Call Trace:
      <IRQ>
      dump_stack_lvl+0x73/0x9f
      print_report.cold+0x132/0xaa2
      _raw_spin_lock_irqsave+0xcd/0x160
      __run_timers+0x173/0x710
      kasan_report+0xad/0x110
      __run_timers+0x173/0x710
      __asan_store8+0x9c/0x140
      __run_timers+0x173/0x710
      call_timer_fn+0x310/0x310
      pvclock_clocksource_read+0xfa/0x250
      kvm_clock_read+0x2c/0x70
      kvm_clock_get_cycles+0xd/0x20
      ktime_get+0x5c/0x110
      lapic_next_event+0x38/0x50
      clockevents_program_event+0xf1/0x1e0
      run_timer_softirq+0x49/0x90
      __do_softirq+0x16e/0x62c
      __irq_exit_rcu+0x1fa/0x270
      irq_exit_rcu+0x12/0x20
      sysvec_apic_timer_interrupt+0x8e/0xc0
    
    One of the concurrency UAF can be shown as below:
    
            use                                  free
    do_resume                           |
      __find_device_hash_cell           |
        dm_get                          |
          atomic_inc(&md->holders)      |
                                        | dm_destroy
                                        |   __dm_destroy
                                        |     if (!dm_suspended_md(md))
                                        |     atomic_read(&md->holders)
                                        |     msleep(1)
      dm_resume                         |
        __dm_resume                     |
          dm_table_resume_targets       |
            pool_resume                 |
              do_waker  #add delay work |
      dm_put                            |
        atomic_dec(&md->holders)        |
                                        |     dm_table_destroy
                                        |       pool_dtr
                                        |         __pool_dec
                                        |           __pool_destroy
                                        |             destroy_workqueue
                                        |             kfree(pool) # free pool
            time out
    __do_softirq
      run_timer_softirq # pool has already been freed
    
    This can be easily reproduced using:
      1. create thin-pool
      2. dmsetup suspend pool
      3. dmsetup resume pool
      4. dmsetup remove_all # Concurrent with 3
    
    The root cause of this UAF bug is that dm_resume() adds timer after
    dm_destroy() skips cancelling the timer because of suspend status.
    After timeout, it will call run_timer_softirq(), however pool has
    already been freed. The concurrency UAF bug will happen.
    
    Therefore, cancelling timer again in __pool_destroy().
    
    Cc: stable@vger.kernel.org
    Fixes: 991d9fa02da0d ("dm: add thin provisioning target")
    Signed-off-by: Luo Meng <luomeng12@huawei.com>
    Signed-off-by: Mike Snitzer <snitzer@kernel.org>

commit c0bb97a90b133416b50b3ffbdb7efca9253cc687
Author: Wen Gong <quic_wgong@quicinc.com>
Date:   Tue Sep 20 18:23:41 2022 +0300

    wifi: ath11k: fix failed to find the peer with peer_id 0 when disconnected
    
    [ Upstream commit a20ed60bb357776301c2dad7b4a4f0db97e143e9 ]
    
    It has a fail log which is ath11k_dbg in ath11k_dp_rx_process_mon_status(),
    as below, it will not print when debug_mask is not set ATH11K_DBG_DATA.
            ath11k_dbg(ab, ATH11K_DBG_DATA,
                      "failed to find the peer with peer_id %d\n",
                       ppdu_info.peer_id);
    
    When run scan with station disconnected, the peer_id is 0 for case
    HAL_RX_MPDU_START in ath11k_hal_rx_parse_mon_status_tlv() which called
    from ath11k_dp_rx_process_mon_status(), and the peer_id of ppdu_info is
    reset to 0 in the while loop, so it does not match condition of the
    check "if (ppdu_info->peer_id == HAL_INVALID_PEERID" in the loop, and
    then the log "failed to find the peer with peer_id 0" print after the
    check in the loop, it is below call stack when debug_mask is set
    ATH11K_DBG_DATA.
    
    The reason is this commit 01d2f285e3e5 ("ath11k: decode HE status tlv")
    add "memset(ppdu_info, 0, sizeof(struct hal_rx_mon_ppdu_info))" in
    ath11k_dp_rx_process_mon_status(), but the commit does not initialize
    the peer_id to HAL_INVALID_PEERID, then lead the check mis-match.
    
    Callstack of the failed log:
    [12335.689072] RIP: 0010:ath11k_dp_rx_process_mon_status+0x9ea/0x1020 [ath11k]
    [12335.689157] Code: 89 ff e8 f9 10 00 00 be 01 00 00 00 4c 89 f7 e8 dc 4b 4e de 48 8b 85 38 ff ff ff c7 80 e4 07 00 00 01 00 00 00 e9 20 f8 ff ff <0f> 0b 41 0f b7 96 be 06 00 00 48 c7 c6 b8 50 44 c1 4c 89 ff e8 fd
    [12335.689180] RSP: 0018:ffffb874001a4ca0 EFLAGS: 00010246
    [12335.689210] RAX: 0000000000000000 RBX: ffff995642cbd100 RCX: 0000000000000000
    [12335.689229] RDX: 0000000000000000 RSI: 0000000000000000 RDI: ffff99564212cd18
    [12335.689248] RBP: ffffb874001a4dc0 R08: 0000000000000001 R09: 0000000000000000
    [12335.689268] R10: 0000000000000220 R11: ffffb874001a48e8 R12: ffff995642473d40
    [12335.689286] R13: ffff99564212c5b8 R14: ffff9956424736a0 R15: ffff995642120000
    [12335.689303] FS:  0000000000000000(0000) GS:ffff995739000000(0000) knlGS:0000000000000000
    [12335.689323] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [12335.689341] CR2: 00007f43c5d5e039 CR3: 000000011c012005 CR4: 00000000000606e0
    [12335.689360] Call Trace:
    [12335.689377]  <IRQ>
    [12335.689418]  ? rcu_read_lock_held_common+0x12/0x50
    [12335.689447]  ? rcu_read_lock_sched_held+0x25/0x80
    [12335.689471]  ? rcu_read_lock_held_common+0x12/0x50
    [12335.689504]  ath11k_dp_rx_process_mon_rings+0x8d/0x4f0 [ath11k]
    [12335.689578]  ? ath11k_dp_rx_process_mon_rings+0x8d/0x4f0 [ath11k]
    [12335.689653]  ? lock_acquire+0xef/0x360
    [12335.689681]  ? rcu_read_lock_sched_held+0x25/0x80
    [12335.689713]  ath11k_dp_service_mon_ring+0x38/0x60 [ath11k]
    [12335.689784]  ? ath11k_dp_rx_process_mon_rings+0x4f0/0x4f0 [ath11k]
    [12335.689860]  call_timer_fn+0xb2/0x2f0
    [12335.689897]  ? ath11k_dp_rx_process_mon_rings+0x4f0/0x4f0 [ath11k]
    [12335.689970]  run_timer_softirq+0x21f/0x540
    [12335.689999]  ? ktime_get+0xad/0x160
    [12335.690025]  ? lapic_next_deadline+0x2c/0x40
    [12335.690053]  ? clockevents_program_event+0x82/0x100
    [12335.690093]  __do_softirq+0x151/0x4a8
    [12335.690135]  irq_exit_rcu+0xc9/0x100
    [12335.690165]  sysvec_apic_timer_interrupt+0xa8/0xd0
    [12335.690189]  </IRQ>
    [12335.690204]  <TASK>
    [12335.690225]  asm_sysvec_apic_timer_interrupt+0x12/0x20
    
    Reset the default value to HAL_INVALID_PEERID each time after memset
    of ppdu_info as well as others memset which existed in function
    ath11k_dp_rx_process_mon_status(), then the failed log disappeared.
    
    Tested-on: WCN6855 hw2.0 PCI WLAN.HSP.1.1-03125-QCAHSPSWPL_V1_V2_SILICONZ_LITE-3
    
    Fixes: 01d2f285e3e5 ("ath11k: decode HE status tlv")
    Signed-off-by: Wen Gong <quic_wgong@quicinc.com>
    Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
    Link: https://lore.kernel.org/r/20220518033556.31940-1-quic_wgong@quicinc.com
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit a5b03df19041e5ce35c7f048fa84bf1b0ceb1311
Author: Wen Gong <quic_wgong@quicinc.com>
Date:   Tue Sep 20 18:23:41 2022 +0300

    wifi: ath11k: fix failed to find the peer with peer_id 0 when disconnected
    
    [ Upstream commit a20ed60bb357776301c2dad7b4a4f0db97e143e9 ]
    
    It has a fail log which is ath11k_dbg in ath11k_dp_rx_process_mon_status(),
    as below, it will not print when debug_mask is not set ATH11K_DBG_DATA.
            ath11k_dbg(ab, ATH11K_DBG_DATA,
                      "failed to find the peer with peer_id %d\n",
                       ppdu_info.peer_id);
    
    When run scan with station disconnected, the peer_id is 0 for case
    HAL_RX_MPDU_START in ath11k_hal_rx_parse_mon_status_tlv() which called
    from ath11k_dp_rx_process_mon_status(), and the peer_id of ppdu_info is
    reset to 0 in the while loop, so it does not match condition of the
    check "if (ppdu_info->peer_id == HAL_INVALID_PEERID" in the loop, and
    then the log "failed to find the peer with peer_id 0" print after the
    check in the loop, it is below call stack when debug_mask is set
    ATH11K_DBG_DATA.
    
    The reason is this commit 01d2f285e3e5 ("ath11k: decode HE status tlv")
    add "memset(ppdu_info, 0, sizeof(struct hal_rx_mon_ppdu_info))" in
    ath11k_dp_rx_process_mon_status(), but the commit does not initialize
    the peer_id to HAL_INVALID_PEERID, then lead the check mis-match.
    
    Callstack of the failed log:
    [12335.689072] RIP: 0010:ath11k_dp_rx_process_mon_status+0x9ea/0x1020 [ath11k]
    [12335.689157] Code: 89 ff e8 f9 10 00 00 be 01 00 00 00 4c 89 f7 e8 dc 4b 4e de 48 8b 85 38 ff ff ff c7 80 e4 07 00 00 01 00 00 00 e9 20 f8 ff ff <0f> 0b 41 0f b7 96 be 06 00 00 48 c7 c6 b8 50 44 c1 4c 89 ff e8 fd
    [12335.689180] RSP: 0018:ffffb874001a4ca0 EFLAGS: 00010246
    [12335.689210] RAX: 0000000000000000 RBX: ffff995642cbd100 RCX: 0000000000000000
    [12335.689229] RDX: 0000000000000000 RSI: 0000000000000000 RDI: ffff99564212cd18
    [12335.689248] RBP: ffffb874001a4dc0 R08: 0000000000000001 R09: 0000000000000000
    [12335.689268] R10: 0000000000000220 R11: ffffb874001a48e8 R12: ffff995642473d40
    [12335.689286] R13: ffff99564212c5b8 R14: ffff9956424736a0 R15: ffff995642120000
    [12335.689303] FS:  0000000000000000(0000) GS:ffff995739000000(0000) knlGS:0000000000000000
    [12335.689323] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [12335.689341] CR2: 00007f43c5d5e039 CR3: 000000011c012005 CR4: 00000000000606e0
    [12335.689360] Call Trace:
    [12335.689377]  <IRQ>
    [12335.689418]  ? rcu_read_lock_held_common+0x12/0x50
    [12335.689447]  ? rcu_read_lock_sched_held+0x25/0x80
    [12335.689471]  ? rcu_read_lock_held_common+0x12/0x50
    [12335.689504]  ath11k_dp_rx_process_mon_rings+0x8d/0x4f0 [ath11k]
    [12335.689578]  ? ath11k_dp_rx_process_mon_rings+0x8d/0x4f0 [ath11k]
    [12335.689653]  ? lock_acquire+0xef/0x360
    [12335.689681]  ? rcu_read_lock_sched_held+0x25/0x80
    [12335.689713]  ath11k_dp_service_mon_ring+0x38/0x60 [ath11k]
    [12335.689784]  ? ath11k_dp_rx_process_mon_rings+0x4f0/0x4f0 [ath11k]
    [12335.689860]  call_timer_fn+0xb2/0x2f0
    [12335.689897]  ? ath11k_dp_rx_process_mon_rings+0x4f0/0x4f0 [ath11k]
    [12335.689970]  run_timer_softirq+0x21f/0x540
    [12335.689999]  ? ktime_get+0xad/0x160
    [12335.690025]  ? lapic_next_deadline+0x2c/0x40
    [12335.690053]  ? clockevents_program_event+0x82/0x100
    [12335.690093]  __do_softirq+0x151/0x4a8
    [12335.690135]  irq_exit_rcu+0xc9/0x100
    [12335.690165]  sysvec_apic_timer_interrupt+0xa8/0xd0
    [12335.690189]  </IRQ>
    [12335.690204]  <TASK>
    [12335.690225]  asm_sysvec_apic_timer_interrupt+0x12/0x20
    
    Reset the default value to HAL_INVALID_PEERID each time after memset
    of ppdu_info as well as others memset which existed in function
    ath11k_dp_rx_process_mon_status(), then the failed log disappeared.
    
    Tested-on: WCN6855 hw2.0 PCI WLAN.HSP.1.1-03125-QCAHSPSWPL_V1_V2_SILICONZ_LITE-3
    
    Fixes: 01d2f285e3e5 ("ath11k: decode HE status tlv")
    Signed-off-by: Wen Gong <quic_wgong@quicinc.com>
    Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
    Link: https://lore.kernel.org/r/20220518033556.31940-1-quic_wgong@quicinc.com
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit a20ed60bb357776301c2dad7b4a4f0db97e143e9
Author: Wen Gong <quic_wgong@quicinc.com>
Date:   Tue Sep 20 18:23:41 2022 +0300

    wifi: ath11k: fix failed to find the peer with peer_id 0 when disconnected
    
    It has a fail log which is ath11k_dbg in ath11k_dp_rx_process_mon_status(),
    as below, it will not print when debug_mask is not set ATH11K_DBG_DATA.
            ath11k_dbg(ab, ATH11K_DBG_DATA,
                      "failed to find the peer with peer_id %d\n",
                       ppdu_info.peer_id);
    
    When run scan with station disconnected, the peer_id is 0 for case
    HAL_RX_MPDU_START in ath11k_hal_rx_parse_mon_status_tlv() which called
    from ath11k_dp_rx_process_mon_status(), and the peer_id of ppdu_info is
    reset to 0 in the while loop, so it does not match condition of the
    check "if (ppdu_info->peer_id == HAL_INVALID_PEERID" in the loop, and
    then the log "failed to find the peer with peer_id 0" print after the
    check in the loop, it is below call stack when debug_mask is set
    ATH11K_DBG_DATA.
    
    The reason is this commit 01d2f285e3e5 ("ath11k: decode HE status tlv")
    add "memset(ppdu_info, 0, sizeof(struct hal_rx_mon_ppdu_info))" in
    ath11k_dp_rx_process_mon_status(), but the commit does not initialize
    the peer_id to HAL_INVALID_PEERID, then lead the check mis-match.
    
    Callstack of the failed log:
    [12335.689072] RIP: 0010:ath11k_dp_rx_process_mon_status+0x9ea/0x1020 [ath11k]
    [12335.689157] Code: 89 ff e8 f9 10 00 00 be 01 00 00 00 4c 89 f7 e8 dc 4b 4e de 48 8b 85 38 ff ff ff c7 80 e4 07 00 00 01 00 00 00 e9 20 f8 ff ff <0f> 0b 41 0f b7 96 be 06 00 00 48 c7 c6 b8 50 44 c1 4c 89 ff e8 fd
    [12335.689180] RSP: 0018:ffffb874001a4ca0 EFLAGS: 00010246
    [12335.689210] RAX: 0000000000000000 RBX: ffff995642cbd100 RCX: 0000000000000000
    [12335.689229] RDX: 0000000000000000 RSI: 0000000000000000 RDI: ffff99564212cd18
    [12335.689248] RBP: ffffb874001a4dc0 R08: 0000000000000001 R09: 0000000000000000
    [12335.689268] R10: 0000000000000220 R11: ffffb874001a48e8 R12: ffff995642473d40
    [12335.689286] R13: ffff99564212c5b8 R14: ffff9956424736a0 R15: ffff995642120000
    [12335.689303] FS:  0000000000000000(0000) GS:ffff995739000000(0000) knlGS:0000000000000000
    [12335.689323] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [12335.689341] CR2: 00007f43c5d5e039 CR3: 000000011c012005 CR4: 00000000000606e0
    [12335.689360] Call Trace:
    [12335.689377]  <IRQ>
    [12335.689418]  ? rcu_read_lock_held_common+0x12/0x50
    [12335.689447]  ? rcu_read_lock_sched_held+0x25/0x80
    [12335.689471]  ? rcu_read_lock_held_common+0x12/0x50
    [12335.689504]  ath11k_dp_rx_process_mon_rings+0x8d/0x4f0 [ath11k]
    [12335.689578]  ? ath11k_dp_rx_process_mon_rings+0x8d/0x4f0 [ath11k]
    [12335.689653]  ? lock_acquire+0xef/0x360
    [12335.689681]  ? rcu_read_lock_sched_held+0x25/0x80
    [12335.689713]  ath11k_dp_service_mon_ring+0x38/0x60 [ath11k]
    [12335.689784]  ? ath11k_dp_rx_process_mon_rings+0x4f0/0x4f0 [ath11k]
    [12335.689860]  call_timer_fn+0xb2/0x2f0
    [12335.689897]  ? ath11k_dp_rx_process_mon_rings+0x4f0/0x4f0 [ath11k]
    [12335.689970]  run_timer_softirq+0x21f/0x540
    [12335.689999]  ? ktime_get+0xad/0x160
    [12335.690025]  ? lapic_next_deadline+0x2c/0x40
    [12335.690053]  ? clockevents_program_event+0x82/0x100
    [12335.690093]  __do_softirq+0x151/0x4a8
    [12335.690135]  irq_exit_rcu+0xc9/0x100
    [12335.690165]  sysvec_apic_timer_interrupt+0xa8/0xd0
    [12335.690189]  </IRQ>
    [12335.690204]  <TASK>
    [12335.690225]  asm_sysvec_apic_timer_interrupt+0x12/0x20
    
    Reset the default value to HAL_INVALID_PEERID each time after memset
    of ppdu_info as well as others memset which existed in function
    ath11k_dp_rx_process_mon_status(), then the failed log disappeared.
    
    Tested-on: WCN6855 hw2.0 PCI WLAN.HSP.1.1-03125-QCAHSPSWPL_V1_V2_SILICONZ_LITE-3
    
    Fixes: 01d2f285e3e5 ("ath11k: decode HE status tlv")
    Signed-off-by: Wen Gong <quic_wgong@quicinc.com>
    Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
    Link: https://lore.kernel.org/r/20220518033556.31940-1-quic_wgong@quicinc.com

commit 110a25357584a2d2d9f50accb1e89455c54290b6
Author: Daniel Lezcano <daniel.lezcano@linaro.org>
Date:   Mon Jul 18 23:36:57 2022 +0200

    clocksource/drivers/tegra186: Put Kconfig option 'tristate' to 'bool'
    
    The clocksources are built-in, they are not modules. We don't know if
    the core time framework is ready for clockevents / clocksources as
    modules.
    
    Revert back this option to 'bool'.
    
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Link: https://lore.kernel.org/r/20220718213657.1303538-1-daniel.lezcano@linaro.org

commit 579a8a2c173492a1d2aa4cae8ddbad5287c615c5
Author: Samuel Holland <samuel@sholland.org>
Date:   Sun May 8 20:21:21 2022 -0500

    clocksource/drivers/riscv: Events are stopped during CPU suspend
    
    [ Upstream commit 232ccac1bd9b5bfe73895f527c08623e7fa0752d ]
    
    Some implementations of the SBI time extension depend on hart-local
    state (for example, CSRs) that are lost or hardware that is powered
    down when a CPU is suspended. To be safe, the clockevents driver
    cannot assume that timer IRQs will be received during CPU suspend.
    
    Fixes: 62b019436814 ("clocksource: new RISC-V SBI timer driver")
    Signed-off-by: Samuel Holland <samuel@sholland.org>
    Reviewed-by: Anup Patel <anup@brainfault.org>
    Link: https://lore.kernel.org/r/20220509012121.40031-1-samuel@sholland.org
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 9a54fb777ff3bf47889afca8a35d9fde05414ecc
Author: Samuel Holland <samuel@sholland.org>
Date:   Sun May 8 20:21:21 2022 -0500

    clocksource/drivers/riscv: Events are stopped during CPU suspend
    
    [ Upstream commit 232ccac1bd9b5bfe73895f527c08623e7fa0752d ]
    
    Some implementations of the SBI time extension depend on hart-local
    state (for example, CSRs) that are lost or hardware that is powered
    down when a CPU is suspended. To be safe, the clockevents driver
    cannot assume that timer IRQs will be received during CPU suspend.
    
    Fixes: 62b019436814 ("clocksource: new RISC-V SBI timer driver")
    Signed-off-by: Samuel Holland <samuel@sholland.org>
    Reviewed-by: Anup Patel <anup@brainfault.org>
    Link: https://lore.kernel.org/r/20220509012121.40031-1-samuel@sholland.org
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 604e35f704756842f7c3c392bf3771e9970a9a88
Author: Samuel Holland <samuel@sholland.org>
Date:   Sun May 8 20:21:21 2022 -0500

    clocksource/drivers/riscv: Events are stopped during CPU suspend
    
    [ Upstream commit 232ccac1bd9b5bfe73895f527c08623e7fa0752d ]
    
    Some implementations of the SBI time extension depend on hart-local
    state (for example, CSRs) that are lost or hardware that is powered
    down when a CPU is suspended. To be safe, the clockevents driver
    cannot assume that timer IRQs will be received during CPU suspend.
    
    Fixes: 62b019436814 ("clocksource: new RISC-V SBI timer driver")
    Signed-off-by: Samuel Holland <samuel@sholland.org>
    Reviewed-by: Anup Patel <anup@brainfault.org>
    Link: https://lore.kernel.org/r/20220509012121.40031-1-samuel@sholland.org
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit d54a51b51851ead86292a0db4a7184d77623bfe2
Author: Samuel Holland <samuel@sholland.org>
Date:   Sun May 8 20:21:21 2022 -0500

    clocksource/drivers/riscv: Events are stopped during CPU suspend
    
    [ Upstream commit 232ccac1bd9b5bfe73895f527c08623e7fa0752d ]
    
    Some implementations of the SBI time extension depend on hart-local
    state (for example, CSRs) that are lost or hardware that is powered
    down when a CPU is suspended. To be safe, the clockevents driver
    cannot assume that timer IRQs will be received during CPU suspend.
    
    Fixes: 62b019436814 ("clocksource: new RISC-V SBI timer driver")
    Signed-off-by: Samuel Holland <samuel@sholland.org>
    Reviewed-by: Anup Patel <anup@brainfault.org>
    Link: https://lore.kernel.org/r/20220509012121.40031-1-samuel@sholland.org
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit d041e885749f1506d41bc0dd945f27fc0cfc73f7
Author: Samuel Holland <samuel@sholland.org>
Date:   Sun May 8 20:21:21 2022 -0500

    clocksource/drivers/riscv: Events are stopped during CPU suspend
    
    [ Upstream commit 232ccac1bd9b5bfe73895f527c08623e7fa0752d ]
    
    Some implementations of the SBI time extension depend on hart-local
    state (for example, CSRs) that are lost or hardware that is powered
    down when a CPU is suspended. To be safe, the clockevents driver
    cannot assume that timer IRQs will be received during CPU suspend.
    
    Fixes: 62b019436814 ("clocksource: new RISC-V SBI timer driver")
    Signed-off-by: Samuel Holland <samuel@sholland.org>
    Reviewed-by: Anup Patel <anup@brainfault.org>
    Link: https://lore.kernel.org/r/20220509012121.40031-1-samuel@sholland.org
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 3448aa3b941999f5fed7570ad6bad79972cbd18c
Author: Samuel Holland <samuel@sholland.org>
Date:   Sun May 8 20:21:21 2022 -0500

    clocksource/drivers/riscv: Events are stopped during CPU suspend
    
    [ Upstream commit 232ccac1bd9b5bfe73895f527c08623e7fa0752d ]
    
    Some implementations of the SBI time extension depend on hart-local
    state (for example, CSRs) that are lost or hardware that is powered
    down when a CPU is suspended. To be safe, the clockevents driver
    cannot assume that timer IRQs will be received during CPU suspend.
    
    Fixes: 62b019436814 ("clocksource: new RISC-V SBI timer driver")
    Signed-off-by: Samuel Holland <samuel@sholland.org>
    Reviewed-by: Anup Patel <anup@brainfault.org>
    Link: https://lore.kernel.org/r/20220509012121.40031-1-samuel@sholland.org
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 6e01f86fb2025111c77101254f1442ac137089cd
Merge: fcfde8a7cf6d 317f29c14d0c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon May 23 17:05:55 2022 -0700

    Merge tag 'timers-core-2022-05-23' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer and timekeeping updates from Thomas Gleixner:
    
     - Expose CLOCK_TAI to instrumentation to aid with TSN debugging.
    
     - Ensure that the clockevent is stopped when there is no timer armed to
       avoid pointless wakeups.
    
     - Make the sched clock frequency handling and rounding consistent.
    
     - Provide a better debugobject hint for delayed works. The timer
       callback is always the same, which makes it difficult to identify the
       underlying work. Use the work function as a hint instead.
    
     - Move the timer specific sysctl code into the timer subsystem.
    
     - The usual set of improvements and cleanups
    
    * tag 'timers-core-2022-05-23' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      timers: Provide a better debugobjects hint for delayed works
      time/sched_clock: Fix formatting of frequency reporting code
      time/sched_clock: Use Hz as the unit for clock rate reporting below 4kHz
      time/sched_clock: Round the frequency reported to nearest rather than down
      timekeeping: Consolidate fast timekeeper
      timekeeping: Annotate ktime_get_boot_fast_ns() with data_race()
      timers/nohz: Switch to ONESHOT_STOPPED in the low-res handler when the tick is stopped
      timekeeping: Introduce fast accessor to clock tai
      tracing/timer: Add missing argument documentation of trace points
      clocksource: Replace cpumask_weight() with cpumask_empty()
      timers: Move timer sysctl into the timer code
      clockevents: Use dedicated list iterator variable
      timers: Simplify calc_index()
      timers: Initialize base::next_expiry_recalc in timers_prepare_cpu()

commit 232ccac1bd9b5bfe73895f527c08623e7fa0752d
Author: Samuel Holland <samuel@sholland.org>
Date:   Sun May 8 20:21:21 2022 -0500

    clocksource/drivers/riscv: Events are stopped during CPU suspend
    
    Some implementations of the SBI time extension depend on hart-local
    state (for example, CSRs) that are lost or hardware that is powered
    down when a CPU is suspended. To be safe, the clockevents driver
    cannot assume that timer IRQs will be received during CPU suspend.
    
    Fixes: 62b019436814 ("clocksource: new RISC-V SBI timer driver")
    Signed-off-by: Samuel Holland <samuel@sholland.org>
    Reviewed-by: Anup Patel <anup@brainfault.org>
    Link: https://lore.kernel.org/r/20220509012121.40031-1-samuel@sholland.org
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit d0f75b88f1d1b98d54af7aa0fe532628a1653e59
Author: Michael Ellerman <mpe@ellerman.id.au>
Date:   Thu Apr 21 00:16:57 2022 +1000

    powerpc/time: Always set decrementer in timer_interrupt()
    
    [ Upstream commit d2b9be1f4af5cabed1ee5bb341f887f64b1c1669 ]
    
    This is a partial revert of commit 0faf20a1ad16 ("powerpc/64s/interrupt:
    Don't enable MSR[EE] in irq handlers unless perf is in use").
    
    Prior to that commit, we always set the decrementer in
    timer_interrupt(), to clear the timer interrupt. Otherwise we could end
    up continuously taking timer interrupts.
    
    When high res timers are enabled there is no problem seen with leaving
    the decrementer untouched in timer_interrupt(), because it will be
    programmed via hrtimer_interrupt() -> tick_program_event() ->
    clockevents_program_event() -> decrementer_set_next_event().
    
    However with CONFIG_HIGH_RES_TIMERS=n or booting with highres=off, we
    see a stall/lockup, because tick_nohz_handler() does not cause a
    reprogram of the decrementer, leading to endless timer interrupts.
    Example trace:
    
      [    1.898617][    T7] Freeing initrd memory: 2624K^M
      [   22.680919][    C1] rcu: INFO: rcu_sched detected stalls on CPUs/tasks:^M
      [   22.682281][    C1] rcu:     0-....: (25 ticks this GP) idle=073/0/0x1 softirq=10/16 fqs=1050 ^M
      [   22.682851][    C1]  (detected by 1, t=2102 jiffies, g=-1179, q=476)^M
      [   22.683649][    C1] Sending NMI from CPU 1 to CPUs 0:^M
      [   22.685252][    C0] NMI backtrace for cpu 0^M
      [   22.685649][    C0] CPU: 0 PID: 0 Comm: swapper/0 Not tainted 5.16.0-rc2-00185-g0faf20a1ad16 #145^M
      [   22.686393][    C0] NIP:  c000000000016d64 LR: c000000000f6cca4 CTR: c00000000019c6e0^M
      [   22.686774][    C0] REGS: c000000002833590 TRAP: 0500   Not tainted  (5.16.0-rc2-00185-g0faf20a1ad16)^M
      [   22.687222][    C0] MSR:  8000000000009033 <SF,EE,ME,IR,DR,RI,LE>  CR: 24000222  XER: 00000000^M
      [   22.688297][    C0] CFAR: c00000000000c854 IRQMASK: 0 ^M
      ...
      [   22.692637][    C0] NIP [c000000000016d64] arch_local_irq_restore+0x174/0x250^M
      [   22.694443][    C0] LR [c000000000f6cca4] __do_softirq+0xe4/0x3dc^M
      [   22.695762][    C0] Call Trace:^M
      [   22.696050][    C0] [c000000002833830] [c000000000f6cc80] __do_softirq+0xc0/0x3dc (unreliable)^M
      [   22.697377][    C0] [c000000002833920] [c000000000151508] __irq_exit_rcu+0xd8/0x130^M
      [   22.698739][    C0] [c000000002833950] [c000000000151730] irq_exit+0x20/0x40^M
      [   22.699938][    C0] [c000000002833970] [c000000000027f40] timer_interrupt+0x270/0x460^M
      [   22.701119][    C0] [c0000000028339d0] [c0000000000099a8] decrementer_common_virt+0x208/0x210^M
    
    Possibly this should be fixed in the lowres timing code, but that would
    be a generic change and could take some time and may not backport
    easily, so for now make the programming of the decrementer unconditional
    again in timer_interrupt() to avoid the stall/lockup.
    
    Fixes: 0faf20a1ad16 ("powerpc/64s/interrupt: Don't enable MSR[EE] in irq handlers unless perf is in use")
    Reported-by: Miguel Ojeda <miguel.ojeda.sandonis@gmail.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Reviewed-by: Nicholas Piggin <npiggin@gmail.com>
    Link: https://lore.kernel.org/r/20220420141657.771442-1-mpe@ellerman.id.au
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit d2b9be1f4af5cabed1ee5bb341f887f64b1c1669
Author: Michael Ellerman <mpe@ellerman.id.au>
Date:   Thu Apr 21 00:16:57 2022 +1000

    powerpc/time: Always set decrementer in timer_interrupt()
    
    This is a partial revert of commit 0faf20a1ad16 ("powerpc/64s/interrupt:
    Don't enable MSR[EE] in irq handlers unless perf is in use").
    
    Prior to that commit, we always set the decrementer in
    timer_interrupt(), to clear the timer interrupt. Otherwise we could end
    up continuously taking timer interrupts.
    
    When high res timers are enabled there is no problem seen with leaving
    the decrementer untouched in timer_interrupt(), because it will be
    programmed via hrtimer_interrupt() -> tick_program_event() ->
    clockevents_program_event() -> decrementer_set_next_event().
    
    However with CONFIG_HIGH_RES_TIMERS=n or booting with highres=off, we
    see a stall/lockup, because tick_nohz_handler() does not cause a
    reprogram of the decrementer, leading to endless timer interrupts.
    Example trace:
    
      [    1.898617][    T7] Freeing initrd memory: 2624K^M
      [   22.680919][    C1] rcu: INFO: rcu_sched detected stalls on CPUs/tasks:^M
      [   22.682281][    C1] rcu:     0-....: (25 ticks this GP) idle=073/0/0x1 softirq=10/16 fqs=1050 ^M
      [   22.682851][    C1]  (detected by 1, t=2102 jiffies, g=-1179, q=476)^M
      [   22.683649][    C1] Sending NMI from CPU 1 to CPUs 0:^M
      [   22.685252][    C0] NMI backtrace for cpu 0^M
      [   22.685649][    C0] CPU: 0 PID: 0 Comm: swapper/0 Not tainted 5.16.0-rc2-00185-g0faf20a1ad16 #145^M
      [   22.686393][    C0] NIP:  c000000000016d64 LR: c000000000f6cca4 CTR: c00000000019c6e0^M
      [   22.686774][    C0] REGS: c000000002833590 TRAP: 0500   Not tainted  (5.16.0-rc2-00185-g0faf20a1ad16)^M
      [   22.687222][    C0] MSR:  8000000000009033 <SF,EE,ME,IR,DR,RI,LE>  CR: 24000222  XER: 00000000^M
      [   22.688297][    C0] CFAR: c00000000000c854 IRQMASK: 0 ^M
      ...
      [   22.692637][    C0] NIP [c000000000016d64] arch_local_irq_restore+0x174/0x250^M
      [   22.694443][    C0] LR [c000000000f6cca4] __do_softirq+0xe4/0x3dc^M
      [   22.695762][    C0] Call Trace:^M
      [   22.696050][    C0] [c000000002833830] [c000000000f6cc80] __do_softirq+0xc0/0x3dc (unreliable)^M
      [   22.697377][    C0] [c000000002833920] [c000000000151508] __irq_exit_rcu+0xd8/0x130^M
      [   22.698739][    C0] [c000000002833950] [c000000000151730] irq_exit+0x20/0x40^M
      [   22.699938][    C0] [c000000002833970] [c000000000027f40] timer_interrupt+0x270/0x460^M
      [   22.701119][    C0] [c0000000028339d0] [c0000000000099a8] decrementer_common_virt+0x208/0x210^M
    
    Possibly this should be fixed in the lowres timing code, but that would
    be a generic change and could take some time and may not backport
    easily, so for now make the programming of the decrementer unconditional
    again in timer_interrupt() to avoid the stall/lockup.
    
    Fixes: 0faf20a1ad16 ("powerpc/64s/interrupt: Don't enable MSR[EE] in irq handlers unless perf is in use")
    Reported-by: Miguel Ojeda <miguel.ojeda.sandonis@gmail.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Reviewed-by: Nicholas Piggin <npiggin@gmail.com>
    Link: https://lore.kernel.org/r/20220420141657.771442-1-mpe@ellerman.id.au

commit 2966a9918dfab183a1cb6be6794981ebe2abff83
Author: Jakob Koschel <jakobkoschel@gmail.com>
Date:   Thu Mar 31 23:57:07 2022 +0200

    clockevents: Use dedicated list iterator variable
    
    To move the list iterator variable into the list_for_each_entry_*()
    macro in the future it should be avoided to use the list iterator
    variable after the loop body.
    
    To *never* use the list iterator variable after the loop it was
    concluded to use a separate iterator variable.
    
    Signed-off-by: Jakob Koschel <jakobkoschel@gmail.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lore.kernel.org/all/CAHk-=wgRr_D8CB-D9Kg-c=EHreAsk5SqXPwr9Y7k9sA6cWXJ6w@mail.gmail.com/
    Link: https://lore.kernel.org/r/20220331215707.883957-1-jakobkoschel@gmail.com

commit 400705c50bbf184794c885d1efad7fe9ccf1471a
Author: Wen Gong <quic_wgong@quicinc.com>
Date:   Tue Jan 11 16:42:52 2022 +0200

    ath11k: free peer for station when disconnect from AP for QCA6390/WCN6855
    
    [ Upstream commit 212ad7cb7d7592669c067125949e0a8e31ce6a0b ]
    
    Commit b4a0f54156ac ("ath11k: move peer delete after vdev stop of station
    for QCA6390 and WCN6855") is to fix firmware crash by changing the WMI
    command sequence, but actually skip all the peer delete operation, then
    it lead commit 58595c9874c6 ("ath11k: Fixing dangling pointer issue upon
    peer delete failure") not take effect, and then happened a use-after-free
    warning from KASAN. because the peer->sta is not set to NULL and then used
    later.
    
    Change to only skip the WMI_PEER_DELETE_CMDID for QCA6390/WCN6855.
    
    log of user-after-free:
    
    [  534.888665] BUG: KASAN: use-after-free in ath11k_dp_rx_update_peer_stats+0x912/0xc10 [ath11k]
    [  534.888696] Read of size 8 at addr ffff8881396bb1b8 by task rtcwake/2860
    
    [  534.888705] CPU: 4 PID: 2860 Comm: rtcwake Kdump: loaded Tainted: G        W         5.15.0-wt-ath+ #523
    [  534.888712] Hardware name: Intel(R) Client Systems NUC8i7HVK/NUC8i7HVB, BIOS HNKBLi70.86A.0067.2021.0528.1339 05/28/2021
    [  534.888716] Call Trace:
    [  534.888720]  <IRQ>
    [  534.888726]  dump_stack_lvl+0x57/0x7d
    [  534.888736]  print_address_description.constprop.0+0x1f/0x170
    [  534.888745]  ? ath11k_dp_rx_update_peer_stats+0x912/0xc10 [ath11k]
    [  534.888771]  kasan_report.cold+0x83/0xdf
    [  534.888783]  ? ath11k_dp_rx_update_peer_stats+0x912/0xc10 [ath11k]
    [  534.888810]  ath11k_dp_rx_update_peer_stats+0x912/0xc10 [ath11k]
    [  534.888840]  ath11k_dp_rx_process_mon_status+0x529/0xa70 [ath11k]
    [  534.888874]  ? ath11k_dp_rx_mon_status_bufs_replenish+0x3f0/0x3f0 [ath11k]
    [  534.888897]  ? check_prev_add+0x20f0/0x20f0
    [  534.888922]  ? __lock_acquire+0xb72/0x1870
    [  534.888937]  ? find_held_lock+0x33/0x110
    [  534.888954]  ath11k_dp_rx_process_mon_rings+0x297/0x520 [ath11k]
    [  534.888981]  ? rcu_read_unlock+0x40/0x40
    [  534.888990]  ? ath11k_dp_rx_pdev_alloc+0xd90/0xd90 [ath11k]
    [  534.889026]  ath11k_dp_service_mon_ring+0x67/0xe0 [ath11k]
    [  534.889053]  ? ath11k_dp_rx_process_mon_rings+0x520/0x520 [ath11k]
    [  534.889075]  call_timer_fn+0x167/0x4a0
    [  534.889084]  ? add_timer_on+0x3b0/0x3b0
    [  534.889103]  ? lockdep_hardirqs_on_prepare.part.0+0x18c/0x370
    [  534.889117]  __run_timers.part.0+0x539/0x8b0
    [  534.889123]  ? ath11k_dp_rx_process_mon_rings+0x520/0x520 [ath11k]
    [  534.889157]  ? call_timer_fn+0x4a0/0x4a0
    [  534.889164]  ? mark_lock_irq+0x1c30/0x1c30
    [  534.889173]  ? clockevents_program_event+0xdd/0x280
    [  534.889189]  ? mark_held_locks+0xa5/0xe0
    [  534.889203]  run_timer_softirq+0x97/0x180
    [  534.889213]  __do_softirq+0x276/0x86a
    [  534.889230]  __irq_exit_rcu+0x11c/0x180
    [  534.889238]  irq_exit_rcu+0x5/0x20
    [  534.889244]  sysvec_apic_timer_interrupt+0x8e/0xc0
    [  534.889251]  </IRQ>
    [  534.889254]  <TASK>
    [  534.889259]  asm_sysvec_apic_timer_interrupt+0x12/0x20
    [  534.889265] RIP: 0010:_raw_spin_unlock_irqrestore+0x38/0x70
    [  534.889271] Code: 74 24 10 e8 ea c2 bf fd 48 89 ef e8 12 53 c0 fd 81 e3 00 02 00 00 75 25 9c 58 f6 c4 02 75 2d 48 85 db 74 01 fb bf 01 00 00 00 <e8> 13 a7 b5 fd 65 8b 05 cc d9 9c 5e 85 c0 74 0a 5b 5d c3 e8 a0 ee
    [  534.889276] RSP: 0018:ffffc90002e5f880 EFLAGS: 00000206
    [  534.889284] RAX: 0000000000000006 RBX: 0000000000000200 RCX: ffffffff9f256f10
    [  534.889289] RDX: 0000000000000000 RSI: ffffffffa1c6e420 RDI: 0000000000000001
    [  534.889293] RBP: ffff8881095e6200 R08: 0000000000000001 R09: ffffffffa40d2b8f
    [  534.889298] R10: fffffbfff481a571 R11: 0000000000000001 R12: ffff8881095e6e68
    [  534.889302] R13: ffffc90002e5f908 R14: 0000000000000246 R15: 0000000000000000
    [  534.889316]  ? mark_lock+0xd0/0x14a0
    [  534.889332]  klist_next+0x1d4/0x450
    [  534.889340]  ? dpm_wait_for_subordinate+0x2d0/0x2d0
    [  534.889350]  device_for_each_child+0xa8/0x140
    [  534.889360]  ? device_remove_class_symlinks+0x1b0/0x1b0
    [  534.889370]  ? __lock_release+0x4bd/0x9f0
    [  534.889378]  ? dpm_suspend+0x26b/0x3f0
    [  534.889390]  dpm_wait_for_subordinate+0x82/0x2d0
    [  534.889400]  ? dpm_for_each_dev+0xa0/0xa0
    [  534.889410]  ? dpm_suspend+0x233/0x3f0
    [  534.889427]  __device_suspend+0xd4/0x10c0
    [  534.889440]  ? wait_for_completion_io+0x270/0x270
    [  534.889456]  ? async_suspend_late+0xe0/0xe0
    [  534.889463]  ? async_schedule_node_domain+0x468/0x640
    [  534.889482]  dpm_suspend+0x25a/0x3f0
    [  534.889491]  ? dpm_suspend_end+0x1a0/0x1a0
    [  534.889497]  ? ktime_get+0x214/0x2f0
    [  534.889502]  ? lockdep_hardirqs_on+0x79/0x100
    [  534.889509]  ? recalibrate_cpu_khz+0x10/0x10
    [  534.889516]  ? ktime_get+0x119/0x2f0
    [  534.889528]  dpm_suspend_start+0xab/0xc0
    [  534.889538]  suspend_devices_and_enter+0x1ca/0x350
    [  534.889546]  ? suspend_enter+0x850/0x850
    [  534.889566]  enter_state+0x27c/0x3d7
    [  534.889575]  pm_suspend.cold+0x42/0x189
    [  534.889583]  state_store+0xab/0x160
    [  534.889595]  ? sysfs_file_ops+0x160/0x160
    [  534.889601]  kernfs_fop_write_iter+0x2b5/0x450
    [  534.889615]  new_sync_write+0x36a/0x600
    [  534.889625]  ? new_sync_read+0x600/0x600
    [  534.889639]  ? rcu_read_unlock+0x40/0x40
    [  534.889668]  vfs_write+0x619/0x910
    [  534.889681]  ksys_write+0xf4/0x1d0
    [  534.889689]  ? __ia32_sys_read+0xa0/0xa0
    [  534.889699]  ? lockdep_hardirqs_on_prepare.part.0+0x18c/0x370
    [  534.889707]  ? syscall_enter_from_user_mode+0x1d/0x50
    [  534.889719]  do_syscall_64+0x3b/0x90
    [  534.889725]  entry_SYSCALL_64_after_hwframe+0x44/0xae
    [  534.889731] RIP: 0033:0x7f0b9bc931e7
    [  534.889736] Code: 64 89 02 48 c7 c0 ff ff ff ff eb bb 0f 1f 80 00 00 00 00 f3 0f 1e fa 64 8b 04 25 18 00 00 00 85 c0 75 10 b8 01 00 00 00 0f 05 <48> 3d 00 f0 ff ff 77 51 c3 48 83 ec 28 48 89 54 24 18 48 89 74 24
    [  534.889741] RSP: 002b:00007ffd9d34cc88 EFLAGS: 00000246 ORIG_RAX: 0000000000000001
    [  534.889749] RAX: ffffffffffffffda RBX: 0000000000000004 RCX: 00007f0b9bc931e7
    [  534.889753] RDX: 0000000000000004 RSI: 0000561cd023c5f0 RDI: 0000000000000004
    [  534.889757] RBP: 0000561cd023c5f0 R08: 0000000000000000 R09: 0000000000000004
    [  534.889761] R10: 0000561ccef842a6 R11: 0000000000000246 R12: 0000000000000004
    [  534.889765] R13: 0000561cd0239590 R14: 00007f0b9bd6f4a0 R15: 00007f0b9bd6e8a0
    [  534.889789]  </TASK>
    
    [  534.889796] Allocated by task 2711:
    [  534.889800]  kasan_save_stack+0x1b/0x40
    [  534.889805]  __kasan_kmalloc+0x7c/0x90
    [  534.889810]  sta_info_alloc+0x98/0x1ef0 [mac80211]
    [  534.889874]  ieee80211_prep_connection+0x30b/0x11e0 [mac80211]
    [  534.889950]  ieee80211_mgd_auth+0x529/0xe00 [mac80211]
    [  534.890024]  cfg80211_mlme_auth+0x332/0x6f0 [cfg80211]
    [  534.890090]  nl80211_authenticate+0x839/0xcf0 [cfg80211]
    [  534.890147]  genl_family_rcv_msg_doit+0x1f4/0x2f0
    [  534.890154]  genl_rcv_msg+0x280/0x500
    [  534.890160]  netlink_rcv_skb+0x11c/0x340
    [  534.890165]  genl_rcv+0x1f/0x30
    [  534.890170]  netlink_unicast+0x42b/0x700
    [  534.890176]  netlink_sendmsg+0x71b/0xc60
    [  534.890181]  sock_sendmsg+0xdf/0x110
    [  534.890187]  ____sys_sendmsg+0x5c0/0x850
    [  534.890192]  ___sys_sendmsg+0xe4/0x160
    [  534.890197]  __sys_sendmsg+0xb2/0x140
    [  534.890202]  do_syscall_64+0x3b/0x90
    [  534.890207]  entry_SYSCALL_64_after_hwframe+0x44/0xae
    
    [  534.890215] Freed by task 2825:
    [  534.890218]  kasan_save_stack+0x1b/0x40
    [  534.890223]  kasan_set_track+0x1c/0x30
    [  534.890227]  kasan_set_free_info+0x20/0x30
    [  534.890232]  __kasan_slab_free+0xce/0x100
    [  534.890237]  slab_free_freelist_hook+0xf0/0x1a0
    [  534.890242]  kfree+0xe5/0x370
    [  534.890248]  __sta_info_flush+0x333/0x4b0 [mac80211]
    [  534.890308]  ieee80211_set_disassoc+0x324/0xd20 [mac80211]
    [  534.890382]  ieee80211_mgd_deauth+0x537/0xee0 [mac80211]
    [  534.890472]  cfg80211_mlme_deauth+0x349/0x810 [cfg80211]
    [  534.890526]  cfg80211_mlme_down+0x1ce/0x270 [cfg80211]
    [  534.890578]  cfg80211_disconnect+0x4f5/0x7b0 [cfg80211]
    [  534.890631]  cfg80211_leave+0x24/0x40 [cfg80211]
    [  534.890677]  wiphy_suspend+0x23d/0x2f0 [cfg80211]
    [  534.890723]  dpm_run_callback+0xf4/0x1b0
    [  534.890728]  __device_suspend+0x648/0x10c0
    [  534.890733]  async_suspend+0x16/0xe0
    [  534.890737]  async_run_entry_fn+0x90/0x4f0
    [  534.890741]  process_one_work+0x866/0x1490
    [  534.890747]  worker_thread+0x596/0x1010
    [  534.890751]  kthread+0x35d/0x420
    [  534.890756]  ret_from_fork+0x22/0x30
    
    [  534.890763] The buggy address belongs to the object at ffff8881396ba000
                    which belongs to the cache kmalloc-8k of size 8192
    [  534.890767] The buggy address is located 4536 bytes inside of
                    8192-byte region [ffff8881396ba000, ffff8881396bc000)
    [  534.890772] The buggy address belongs to the page:
    [  534.890775] page:ffffea0004e5ae00 refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x1396b8
    [  534.890780] head:ffffea0004e5ae00 order:3 compound_mapcount:0 compound_pincount:0
    [  534.890784] flags: 0x200000000010200(slab|head|node=0|zone=2)
    [  534.890791] raw: 0200000000010200 ffffea000562be08 ffffea0004b04c08 ffff88810004e340
    [  534.890795] raw: 0000000000000000 0000000000010001 00000001ffffffff 0000000000000000
    [  534.890798] page dumped because: kasan: bad access detected
    
    [  534.890804] Memory state around the buggy address:
    [  534.890807]  ffff8881396bb080: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [  534.890811]  ffff8881396bb100: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [  534.890814] >ffff8881396bb180: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [  534.890817]                                         ^
    [  534.890821]  ffff8881396bb200: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [  534.890824]  ffff8881396bb280: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [  534.890827] ==================================================================
    [  534.890830] Disabling lock debugging due to kernel taint
    
    Tested-on: WCN6855 hw2.0 PCI WLAN.HSP.1.1-01720.1-QCAHSPSWPL_V1_V2_SILICONZ_LITE-1
    
    Fixes: b4a0f54156ac ("ath11k: move peer delete after vdev stop of station for QCA6390 and WCN6855")
    Signed-off-by: Wen Gong <quic_wgong@quicinc.com>
    Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
    Link: https://lore.kernel.org/r/20211222070431.29595-1-quic_wgong@quicinc.com
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 35de589cb8793573ed56a915af9cb4b5f15ad7d7
Author: Nicholas Piggin <npiggin@gmail.com>
Date:   Tue Jan 25 00:39:30 2022 +1000

    powerpc/time: improve decrementer clockevent processing
    
    The stop/shutdown op should not use decrementer_set_next_event because
    that sets decrementers_next_tb to now + decrementer_max, which means a
    decrementer interrupt that occurs after that time will call the
    clockevent event handler unexpectedly. Set next_tb to ~0 here to prevent
    any clock event call. Init all clockevents to stopped.
    
    Then the decrementer clockevent device always has event_handler set and
    applicable because we know the clock event device was not stopped. So
    make this call unconditional to show that it is always called. next_tb
    need not be set to ~0 before the event handler is called because it will
    stop the clockevent device if there is no other timer.
    
    Finally, the timer broadcast interrupt should not modify next_tb because
    it is not involved with the local decrementer clockevent on this CPU.
    
    This doesn't fix a known bug, just tidies the code.
    
    Signed-off-by: Nicholas Piggin <npiggin@gmail.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Link: https://lore.kernel.org/r/20220124143930.3923442-3-npiggin@gmail.com

commit 212ad7cb7d7592669c067125949e0a8e31ce6a0b
Author: Wen Gong <quic_wgong@quicinc.com>
Date:   Tue Jan 11 16:42:52 2022 +0200

    ath11k: free peer for station when disconnect from AP for QCA6390/WCN6855
    
    Commit b4a0f54156ac ("ath11k: move peer delete after vdev stop of station
    for QCA6390 and WCN6855") is to fix firmware crash by changing the WMI
    command sequence, but actually skip all the peer delete operation, then
    it lead commit 58595c9874c6 ("ath11k: Fixing dangling pointer issue upon
    peer delete failure") not take effect, and then happened a use-after-free
    warning from KASAN. because the peer->sta is not set to NULL and then used
    later.
    
    Change to only skip the WMI_PEER_DELETE_CMDID for QCA6390/WCN6855.
    
    log of user-after-free:
    
    [  534.888665] BUG: KASAN: use-after-free in ath11k_dp_rx_update_peer_stats+0x912/0xc10 [ath11k]
    [  534.888696] Read of size 8 at addr ffff8881396bb1b8 by task rtcwake/2860
    
    [  534.888705] CPU: 4 PID: 2860 Comm: rtcwake Kdump: loaded Tainted: G        W         5.15.0-wt-ath+ #523
    [  534.888712] Hardware name: Intel(R) Client Systems NUC8i7HVK/NUC8i7HVB, BIOS HNKBLi70.86A.0067.2021.0528.1339 05/28/2021
    [  534.888716] Call Trace:
    [  534.888720]  <IRQ>
    [  534.888726]  dump_stack_lvl+0x57/0x7d
    [  534.888736]  print_address_description.constprop.0+0x1f/0x170
    [  534.888745]  ? ath11k_dp_rx_update_peer_stats+0x912/0xc10 [ath11k]
    [  534.888771]  kasan_report.cold+0x83/0xdf
    [  534.888783]  ? ath11k_dp_rx_update_peer_stats+0x912/0xc10 [ath11k]
    [  534.888810]  ath11k_dp_rx_update_peer_stats+0x912/0xc10 [ath11k]
    [  534.888840]  ath11k_dp_rx_process_mon_status+0x529/0xa70 [ath11k]
    [  534.888874]  ? ath11k_dp_rx_mon_status_bufs_replenish+0x3f0/0x3f0 [ath11k]
    [  534.888897]  ? check_prev_add+0x20f0/0x20f0
    [  534.888922]  ? __lock_acquire+0xb72/0x1870
    [  534.888937]  ? find_held_lock+0x33/0x110
    [  534.888954]  ath11k_dp_rx_process_mon_rings+0x297/0x520 [ath11k]
    [  534.888981]  ? rcu_read_unlock+0x40/0x40
    [  534.888990]  ? ath11k_dp_rx_pdev_alloc+0xd90/0xd90 [ath11k]
    [  534.889026]  ath11k_dp_service_mon_ring+0x67/0xe0 [ath11k]
    [  534.889053]  ? ath11k_dp_rx_process_mon_rings+0x520/0x520 [ath11k]
    [  534.889075]  call_timer_fn+0x167/0x4a0
    [  534.889084]  ? add_timer_on+0x3b0/0x3b0
    [  534.889103]  ? lockdep_hardirqs_on_prepare.part.0+0x18c/0x370
    [  534.889117]  __run_timers.part.0+0x539/0x8b0
    [  534.889123]  ? ath11k_dp_rx_process_mon_rings+0x520/0x520 [ath11k]
    [  534.889157]  ? call_timer_fn+0x4a0/0x4a0
    [  534.889164]  ? mark_lock_irq+0x1c30/0x1c30
    [  534.889173]  ? clockevents_program_event+0xdd/0x280
    [  534.889189]  ? mark_held_locks+0xa5/0xe0
    [  534.889203]  run_timer_softirq+0x97/0x180
    [  534.889213]  __do_softirq+0x276/0x86a
    [  534.889230]  __irq_exit_rcu+0x11c/0x180
    [  534.889238]  irq_exit_rcu+0x5/0x20
    [  534.889244]  sysvec_apic_timer_interrupt+0x8e/0xc0
    [  534.889251]  </IRQ>
    [  534.889254]  <TASK>
    [  534.889259]  asm_sysvec_apic_timer_interrupt+0x12/0x20
    [  534.889265] RIP: 0010:_raw_spin_unlock_irqrestore+0x38/0x70
    [  534.889271] Code: 74 24 10 e8 ea c2 bf fd 48 89 ef e8 12 53 c0 fd 81 e3 00 02 00 00 75 25 9c 58 f6 c4 02 75 2d 48 85 db 74 01 fb bf 01 00 00 00 <e8> 13 a7 b5 fd 65 8b 05 cc d9 9c 5e 85 c0 74 0a 5b 5d c3 e8 a0 ee
    [  534.889276] RSP: 0018:ffffc90002e5f880 EFLAGS: 00000206
    [  534.889284] RAX: 0000000000000006 RBX: 0000000000000200 RCX: ffffffff9f256f10
    [  534.889289] RDX: 0000000000000000 RSI: ffffffffa1c6e420 RDI: 0000000000000001
    [  534.889293] RBP: ffff8881095e6200 R08: 0000000000000001 R09: ffffffffa40d2b8f
    [  534.889298] R10: fffffbfff481a571 R11: 0000000000000001 R12: ffff8881095e6e68
    [  534.889302] R13: ffffc90002e5f908 R14: 0000000000000246 R15: 0000000000000000
    [  534.889316]  ? mark_lock+0xd0/0x14a0
    [  534.889332]  klist_next+0x1d4/0x450
    [  534.889340]  ? dpm_wait_for_subordinate+0x2d0/0x2d0
    [  534.889350]  device_for_each_child+0xa8/0x140
    [  534.889360]  ? device_remove_class_symlinks+0x1b0/0x1b0
    [  534.889370]  ? __lock_release+0x4bd/0x9f0
    [  534.889378]  ? dpm_suspend+0x26b/0x3f0
    [  534.889390]  dpm_wait_for_subordinate+0x82/0x2d0
    [  534.889400]  ? dpm_for_each_dev+0xa0/0xa0
    [  534.889410]  ? dpm_suspend+0x233/0x3f0
    [  534.889427]  __device_suspend+0xd4/0x10c0
    [  534.889440]  ? wait_for_completion_io+0x270/0x270
    [  534.889456]  ? async_suspend_late+0xe0/0xe0
    [  534.889463]  ? async_schedule_node_domain+0x468/0x640
    [  534.889482]  dpm_suspend+0x25a/0x3f0
    [  534.889491]  ? dpm_suspend_end+0x1a0/0x1a0
    [  534.889497]  ? ktime_get+0x214/0x2f0
    [  534.889502]  ? lockdep_hardirqs_on+0x79/0x100
    [  534.889509]  ? recalibrate_cpu_khz+0x10/0x10
    [  534.889516]  ? ktime_get+0x119/0x2f0
    [  534.889528]  dpm_suspend_start+0xab/0xc0
    [  534.889538]  suspend_devices_and_enter+0x1ca/0x350
    [  534.889546]  ? suspend_enter+0x850/0x850
    [  534.889566]  enter_state+0x27c/0x3d7
    [  534.889575]  pm_suspend.cold+0x42/0x189
    [  534.889583]  state_store+0xab/0x160
    [  534.889595]  ? sysfs_file_ops+0x160/0x160
    [  534.889601]  kernfs_fop_write_iter+0x2b5/0x450
    [  534.889615]  new_sync_write+0x36a/0x600
    [  534.889625]  ? new_sync_read+0x600/0x600
    [  534.889639]  ? rcu_read_unlock+0x40/0x40
    [  534.889668]  vfs_write+0x619/0x910
    [  534.889681]  ksys_write+0xf4/0x1d0
    [  534.889689]  ? __ia32_sys_read+0xa0/0xa0
    [  534.889699]  ? lockdep_hardirqs_on_prepare.part.0+0x18c/0x370
    [  534.889707]  ? syscall_enter_from_user_mode+0x1d/0x50
    [  534.889719]  do_syscall_64+0x3b/0x90
    [  534.889725]  entry_SYSCALL_64_after_hwframe+0x44/0xae
    [  534.889731] RIP: 0033:0x7f0b9bc931e7
    [  534.889736] Code: 64 89 02 48 c7 c0 ff ff ff ff eb bb 0f 1f 80 00 00 00 00 f3 0f 1e fa 64 8b 04 25 18 00 00 00 85 c0 75 10 b8 01 00 00 00 0f 05 <48> 3d 00 f0 ff ff 77 51 c3 48 83 ec 28 48 89 54 24 18 48 89 74 24
    [  534.889741] RSP: 002b:00007ffd9d34cc88 EFLAGS: 00000246 ORIG_RAX: 0000000000000001
    [  534.889749] RAX: ffffffffffffffda RBX: 0000000000000004 RCX: 00007f0b9bc931e7
    [  534.889753] RDX: 0000000000000004 RSI: 0000561cd023c5f0 RDI: 0000000000000004
    [  534.889757] RBP: 0000561cd023c5f0 R08: 0000000000000000 R09: 0000000000000004
    [  534.889761] R10: 0000561ccef842a6 R11: 0000000000000246 R12: 0000000000000004
    [  534.889765] R13: 0000561cd0239590 R14: 00007f0b9bd6f4a0 R15: 00007f0b9bd6e8a0
    [  534.889789]  </TASK>
    
    [  534.889796] Allocated by task 2711:
    [  534.889800]  kasan_save_stack+0x1b/0x40
    [  534.889805]  __kasan_kmalloc+0x7c/0x90
    [  534.889810]  sta_info_alloc+0x98/0x1ef0 [mac80211]
    [  534.889874]  ieee80211_prep_connection+0x30b/0x11e0 [mac80211]
    [  534.889950]  ieee80211_mgd_auth+0x529/0xe00 [mac80211]
    [  534.890024]  cfg80211_mlme_auth+0x332/0x6f0 [cfg80211]
    [  534.890090]  nl80211_authenticate+0x839/0xcf0 [cfg80211]
    [  534.890147]  genl_family_rcv_msg_doit+0x1f4/0x2f0
    [  534.890154]  genl_rcv_msg+0x280/0x500
    [  534.890160]  netlink_rcv_skb+0x11c/0x340
    [  534.890165]  genl_rcv+0x1f/0x30
    [  534.890170]  netlink_unicast+0x42b/0x700
    [  534.890176]  netlink_sendmsg+0x71b/0xc60
    [  534.890181]  sock_sendmsg+0xdf/0x110
    [  534.890187]  ____sys_sendmsg+0x5c0/0x850
    [  534.890192]  ___sys_sendmsg+0xe4/0x160
    [  534.890197]  __sys_sendmsg+0xb2/0x140
    [  534.890202]  do_syscall_64+0x3b/0x90
    [  534.890207]  entry_SYSCALL_64_after_hwframe+0x44/0xae
    
    [  534.890215] Freed by task 2825:
    [  534.890218]  kasan_save_stack+0x1b/0x40
    [  534.890223]  kasan_set_track+0x1c/0x30
    [  534.890227]  kasan_set_free_info+0x20/0x30
    [  534.890232]  __kasan_slab_free+0xce/0x100
    [  534.890237]  slab_free_freelist_hook+0xf0/0x1a0
    [  534.890242]  kfree+0xe5/0x370
    [  534.890248]  __sta_info_flush+0x333/0x4b0 [mac80211]
    [  534.890308]  ieee80211_set_disassoc+0x324/0xd20 [mac80211]
    [  534.890382]  ieee80211_mgd_deauth+0x537/0xee0 [mac80211]
    [  534.890472]  cfg80211_mlme_deauth+0x349/0x810 [cfg80211]
    [  534.890526]  cfg80211_mlme_down+0x1ce/0x270 [cfg80211]
    [  534.890578]  cfg80211_disconnect+0x4f5/0x7b0 [cfg80211]
    [  534.890631]  cfg80211_leave+0x24/0x40 [cfg80211]
    [  534.890677]  wiphy_suspend+0x23d/0x2f0 [cfg80211]
    [  534.890723]  dpm_run_callback+0xf4/0x1b0
    [  534.890728]  __device_suspend+0x648/0x10c0
    [  534.890733]  async_suspend+0x16/0xe0
    [  534.890737]  async_run_entry_fn+0x90/0x4f0
    [  534.890741]  process_one_work+0x866/0x1490
    [  534.890747]  worker_thread+0x596/0x1010
    [  534.890751]  kthread+0x35d/0x420
    [  534.890756]  ret_from_fork+0x22/0x30
    
    [  534.890763] The buggy address belongs to the object at ffff8881396ba000
                    which belongs to the cache kmalloc-8k of size 8192
    [  534.890767] The buggy address is located 4536 bytes inside of
                    8192-byte region [ffff8881396ba000, ffff8881396bc000)
    [  534.890772] The buggy address belongs to the page:
    [  534.890775] page:ffffea0004e5ae00 refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x1396b8
    [  534.890780] head:ffffea0004e5ae00 order:3 compound_mapcount:0 compound_pincount:0
    [  534.890784] flags: 0x200000000010200(slab|head|node=0|zone=2)
    [  534.890791] raw: 0200000000010200 ffffea000562be08 ffffea0004b04c08 ffff88810004e340
    [  534.890795] raw: 0000000000000000 0000000000010001 00000001ffffffff 0000000000000000
    [  534.890798] page dumped because: kasan: bad access detected
    
    [  534.890804] Memory state around the buggy address:
    [  534.890807]  ffff8881396bb080: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [  534.890811]  ffff8881396bb100: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [  534.890814] >ffff8881396bb180: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [  534.890817]                                         ^
    [  534.890821]  ffff8881396bb200: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [  534.890824]  ffff8881396bb280: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [  534.890827] ==================================================================
    [  534.890830] Disabling lock debugging due to kernel taint
    
    Tested-on: WCN6855 hw2.0 PCI WLAN.HSP.1.1-01720.1-QCAHSPSWPL_V1_V2_SILICONZ_LITE-1
    
    Fixes: b4a0f54156ac ("ath11k: move peer delete after vdev stop of station for QCA6390 and WCN6855")
    Signed-off-by: Wen Gong <quic_wgong@quicinc.com>
    Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
    Link: https://lore.kernel.org/r/20211222070431.29595-1-quic_wgong@quicinc.com

commit e64da64f410cf4f9697e25ab76cdfc679f4fb6db
Author: Romain Perier <romain.perier@gmail.com>
Date:   Fri Dec 17 20:57:23 2021 +0100

    clocksource/drivers/msc313e: Add support for ssd20xd-based platforms
    
    On SSD20X family SoCs the timers are connected to a 432MHz clock instead
    of 12MHz that all the previous chips used. There is no way to reduce or
    divide these clocks in the clktree yet as we do not know exactly where
    the 432MHz clock comes from but it is enabled at boot.
    
    The SSD20X timers have an input clock divider within the timer itself
    to configure the frequency. timer0 is preconfigured at power up to run
    at 12MHz so it is backwards compatible and doesn't need special handling
    right now. timer1 and timer2 run at 432Mhz at power up so are not
    backward compatible.
    
    This commit adds support for the input clock divider register and sets
    timer1 and timer2 to run at 48Mhz for clockevents.
    
    Signed-off-by: Romain Perier <romain.perier@gmail.com>
    Link: https://lore.kernel.org/r/20211217195727.8955-3-romain.perier@gmail.com
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit 5fc1f93f69989e72be7a84ded6ee867d6415f690
Author: Romain Perier <romain.perier@gmail.com>
Date:   Fri Dec 17 20:57:22 2021 +0100

    clocksource/drivers: Add MStar MSC313e timer support
    
    The MSC313e-compatible SoCs have 3 timer hardware blocks. All of these
    are free running 32-bit increasing counters and can generate interrupts.
    Based onto a maximum value register, each timer can either count from 0
    to max, one time then stop (which generates interrupts) or can count
    from 0 to max and then roll. This commit adds basic support for these
    timers, the first timer block being used as clocksource/sched_clock
    and delay, while the others will be used as clockevents.
    
    Signed-off-by: Romain Perier <romain.perier@gmail.com>
    Co-developed-by: Daniel Palmer <daniel@0x0f.com>
    Signed-off-by: Daniel Palmer <daniel@0x0f.com>
    Link: https://lore.kernel.org/r/20211217195727.8955-2-romain.perier@gmail.com
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit 410fbda49cc9b2165e80b87880f164d9644b460d
Author: Will Deacon <will@kernel.org>
Date:   Wed Nov 3 16:48:04 2021 +0000

    clocksource/drivers/exynos_mct: Fix silly typo resulting in checkpatch warning
    
    Commit ae460fd9164b ("clocksource/drivers/exynos_mct: Prioritise Arm
    arch timer on arm64") changed the rating of the MCT clockevents device
    to be lower than the Arm architected timer and, in the process, replaced
    a semicolon with a comma thanks to a silly copy-paste error.
    
    Put the semicolon back so that the code looks more idiomatic and resolve
    the SUSPECT_COMMA_SEMICOLON warning from checkpatch at the same time.
    
    Cc: Krzysztof Kozlowski <krzk@kernel.org>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Signed-off-by: Will Deacon <will@kernel.org>
    Reviewed-by: Krzysztof Kozlowski <krzysztof.kozlowski@canonical.com>
    Link: https://lore.kernel.org/r/20211103164804.30182-1-will@kernel.org
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit 53e87e3cdc155f20c3417b689df8d2ac88d79576
Author: Frederic Weisbecker <frederic@kernel.org>
Date:   Tue Oct 26 16:10:54 2021 +0200

    timers/nohz: Last resort update jiffies on nohz_full IRQ entry
    
    When at least one CPU runs in nohz_full mode, a dedicated timekeeper CPU
    is guaranteed to stay online and to never stop its tick.
    
    Meanwhile on some rare case, the dedicated timekeeper may be running
    with interrupts disabled for a while, such as in stop_machine.
    
    If jiffies stop being updated, a nohz_full CPU may end up endlessly
    programming the next tick in the past, taking the last jiffies update
    monotonic timestamp as a stale base, resulting in an tick storm.
    
    Here is a scenario where it matters:
    
    0) CPU 0 is the timekeeper and CPU 1 a nohz_full CPU.
    
    1) A stop machine callback is queued to execute somewhere.
    
    2) CPU 0 reaches MULTI_STOP_DISABLE_IRQ while CPU 1 is still in
       MULTI_STOP_PREPARE. Hence CPU 0 can't do its timekeeping duty. CPU 1
       can still take IRQs.
    
    3) CPU 1 receives an IRQ which queues a timer callback one jiffy forward.
    
    4) On IRQ exit, CPU 1 schedules the tick one jiffy forward, taking
       last_jiffies_update as a base. But last_jiffies_update hasn't been
       updated for 2 jiffies since the timekeeper has interrupts disabled.
    
    5) clockevents_program_event(), which relies on ktime_get(), observes
       that the expiration is in the past and therefore programs the min
       delta event on the clock.
    
    6) The tick fires immediately, goto 3)
    
    7) Tick storm, the nohz_full CPU is drown and takes ages to reach
       MULTI_STOP_DISABLE_IRQ, which is the only way out of this situation.
    
    Solve this with unconditionally updating jiffies if the value is stale
    on nohz_full IRQ entry. IRQs and other disturbances are expected to be
    rare enough on nohz_full for the unconditional call to ktime_get() to
    actually matter.
    
    Reported-by: Paul E. McKenney <paulmck@kernel.org>
    Signed-off-by: Frederic Weisbecker <frederic@kernel.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Paul E. McKenney <paulmck@kernel.org>
    Link: https://lore.kernel.org/r/20211026141055.57358-2-frederic@kernel.org

commit 3e6e11f8537c088ec40e81bd3ce175d89c5ea27d
Author: Andrea Righi <andrea.righi@canonical.com>
Date:   Tue Oct 19 11:20:26 2021 +0200

    blk-wbt: prevent NULL pointer dereference in wb_timer_fn
    
    [ Upstream commit 480d42dc001bbfe953825a92073012fcd5a99161 ]
    
    The timer callback used to evaluate if the latency is exceeded can be
    executed after the corresponding disk has been released, causing the
    following NULL pointer dereference:
    
    [ 119.987108] BUG: kernel NULL pointer dereference, address: 0000000000000098
    [ 119.987617] #PF: supervisor read access in kernel mode
    [ 119.987971] #PF: error_code(0x0000) - not-present page
    [ 119.988325] PGD 7c4a4067 P4D 7c4a4067 PUD 7bf63067 PMD 0
    [ 119.988697] Oops: 0000 [#1] SMP NOPTI
    [ 119.988959] CPU: 1 PID: 9353 Comm: cloud-init Not tainted 5.15-rc5+arighi #rc5+arighi
    [ 119.989520] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.14.0-2 04/01/2014
    [ 119.990055] RIP: 0010:wb_timer_fn+0x44/0x3c0
    [ 119.990376] Code: 41 8b 9c 24 98 00 00 00 41 8b 94 24 b8 00 00 00 41 8b 84 24 d8 00 00 00 4d 8b 74 24 28 01 d3 01 c3 49 8b 44 24 60 48 8b 40 78 <4c> 8b b8 98 00 00 00 4d 85 f6 0f 84 c4 00 00 00 49 83 7c 24 30 00
    [ 119.991578] RSP: 0000:ffffb5f580957da8 EFLAGS: 00010246
    [ 119.991937] RAX: 0000000000000000 RBX: 0000000000000000 RCX: 0000000000000004
    [ 119.992412] RDX: 0000000000000000 RSI: 0000000000000000 RDI: ffff88f476d7f780
    [ 119.992895] RBP: ffffb5f580957dd0 R08: 0000000000000000 R09: 0000000000000000
    [ 119.993371] R10: 0000000000000004 R11: 0000000000000002 R12: ffff88f476c84500
    [ 119.993847] R13: ffff88f4434390c0 R14: 0000000000000000 R15: ffff88f4bdc98c00
    [ 119.994323] FS: 00007fb90bcd9c00(0000) GS:ffff88f4bdc80000(0000) knlGS:0000000000000000
    [ 119.994952] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [ 119.995380] CR2: 0000000000000098 CR3: 000000007c0d6000 CR4: 00000000000006e0
    [ 119.995906] Call Trace:
    [ 119.996130] ? blk_stat_free_callback_rcu+0x30/0x30
    [ 119.996505] blk_stat_timer_fn+0x138/0x140
    [ 119.996830] call_timer_fn+0x2b/0x100
    [ 119.997136] __run_timers.part.0+0x1d1/0x240
    [ 119.997470] ? kvm_clock_get_cycles+0x11/0x20
    [ 119.997826] ? ktime_get+0x3e/0xa0
    [ 119.998110] ? native_apic_msr_write+0x2c/0x30
    [ 119.998456] ? lapic_next_event+0x20/0x30
    [ 119.998779] ? clockevents_program_event+0x94/0xf0
    [ 119.999150] run_timer_softirq+0x2a/0x50
    [ 119.999465] __do_softirq+0xcb/0x26f
    [ 119.999764] irq_exit_rcu+0x8c/0xb0
    [ 120.000057] sysvec_apic_timer_interrupt+0x43/0x90
    [ 120.000429] ? asm_sysvec_apic_timer_interrupt+0xa/0x20
    [ 120.000836] asm_sysvec_apic_timer_interrupt+0x12/0x20
    
    In this case simply return from the timer callback (no action
    required) to prevent the NULL pointer dereference.
    
    BugLink: https://bugs.launchpad.net/bugs/1947557
    Link: https://lore.kernel.org/linux-mm/YWRNVTk9N8K0RMst@arighi-desktop/
    Fixes: 34dbad5d26e2 ("blk-stat: convert to callback-based statistics reporting")
    Signed-off-by: Andrea Righi <andrea.righi@canonical.com>
    Link: https://lore.kernel.org/r/YW6N2qXpBU3oc50q@arighi-desktop
    Signed-off-by: Jens Axboe <axboe@kernel.dk>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 595cb5e0b832a3e100cbbdefef797b0c27bf725a
Author: Kim Phillips <kim.phillips@amd.com>
Date:   Thu Oct 21 10:30:06 2021 -0500

    Revert "drm/ast: Add detect function support"
    
    This reverts commit aae74ff9caa8de9a45ae2e46068c417817392a26,
    since it prevents my AMD Milan system from booting, with:
    
    [   27.189558] BUG: kernel NULL pointer dereference, address: 0000000000000000
    [   27.197506] #PF: supervisor write access in kernel mode
    [   27.203333] #PF: error_code(0x0002) - not-present page
    [   27.209064] PGD 0 P4D 0
    [   27.211885] Oops: 0002 [#1] PREEMPT SMP NOPTI
    [   27.216744] CPU: 0 PID: 0 Comm: swapper/0 Not tainted 5.15.0-rc6+ #15
    [   27.223928] Hardware name: AMD Corporation ETHANOL_X/ETHANOL_X, BIOS RXM1006B 08/20/2021
    [   27.232955] RIP: 0010:run_timer_softirq+0x38b/0x4a0
    [   27.238397] Code: 4c 89 f7 e8 37 27 ac 00 49 c7 46 08 00 00 00 00 49 8b 04 24 48 85 c0 74 71 4d 8b 3c 24 4d 89 7e 08 66 90 49 8b 07 49 8b 57 08 <48> 89 02 48 85 c0 74 04 48 89 50 08 49 8b 77 18 41 f6 47 22 20 4c
    [   27.259350] RSP: 0018:ffffc42d00003ee8 EFLAGS: 00010086
    [   27.265176] RAX: dead000000000122 RBX: 0000000000000000 RCX: 0000000000000101
    [   27.273134] RDX: 0000000000000000 RSI: 0000000000000087 RDI: 0000000000000001
    [   27.281084] RBP: ffffc42d00003f70 R08: 0000000000000000 R09: 00000000000003eb
    [   27.289043] R10: ffffa0860cb300d0 R11: ffffa0c44de290b0 R12: ffffc42d00003ef8
    [   27.297002] R13: 00000000fffef200 R14: ffffa0c44de18dc0 R15: ffffa0867a882350
    [   27.304961] FS:  0000000000000000(0000) GS:ffffa0c44de00000(0000) knlGS:0000000000000000
    [   27.313988] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [   27.320396] CR2: 0000000000000000 CR3: 000000014569c001 CR4: 0000000000770ef0
    [   27.328346] PKRU: 55555554
    [   27.331359] Call Trace:
    [   27.334073]  <IRQ>
    [   27.336314]  ? __queue_work+0x420/0x420
    [   27.340589]  ? lapic_next_event+0x21/0x30
    [   27.345060]  ? clockevents_program_event+0x8f/0xe0
    [   27.350402]  __do_softirq+0xfb/0x2db
    [   27.354388]  irq_exit_rcu+0x98/0xd0
    [   27.358275]  sysvec_apic_timer_interrupt+0xac/0xd0
    [   27.363620]  </IRQ>
    [   27.365955]  asm_sysvec_apic_timer_interrupt+0x12/0x20
    [   27.371685] RIP: 0010:cpuidle_enter_state+0xcc/0x390
    [   27.377292] Code: 3d 01 79 0a 50 e8 44 ed 77 ff 49 89 c6 0f 1f 44 00 00 31 ff e8 f5 f8 77 ff 80 7d d7 00 0f 85 e6 01 00 00 fb 66 0f 1f 44 00 00 <45> 85 ff 0f 88 17 01 00 00 49 63 c7 4c 2b 75 c8 48 8d 14 40 48 8d
    [   27.398243] RSP: 0018:ffffffffb0e03dc8 EFLAGS: 00000246
    [   27.404069] RAX: ffffa0c44de00000 RBX: 0000000000000001 RCX: 000000000000001f
    [   27.412028] RDX: 0000000000000000 RSI: ffffffffb0bafc1f RDI: ffffffffb0bbdb81
    [   27.419986] RBP: ffffffffb0e03e00 R08: 00000006549f8f3f R09: ffffffffb1065200
    [   27.427935] R10: ffffa0c44de27ae4 R11: ffffa0c44de27ac4 R12: ffffa0c5634cb000
    [   27.435894] R13: ffffffffb1065200 R14: 00000006549f8f3f R15: 0000000000000001
    [   27.443854]  ? cpuidle_enter_state+0xbb/0x390
    [   27.448712]  cpuidle_enter+0x2e/0x40
    [   27.452695]  call_cpuidle+0x23/0x40
    [   27.456584]  do_idle+0x1f0/0x270
    [   27.460181]  cpu_startup_entry+0x20/0x30
    [   27.464553]  rest_init+0xd4/0xe0
    [   27.468149]  arch_call_rest_init+0xe/0x1b
    [   27.472619]  start_kernel+0x6bc/0x6e2
    [   27.476764]  x86_64_start_reservations+0x24/0x26
    [   27.481912]  x86_64_start_kernel+0x75/0x79
    [   27.486477]  secondary_startup_64_no_verify+0xb0/0xbb
    [   27.492111] Modules linked in: kvm_amd(+) kvm ipmi_si(+) ipmi_devintf rapl wmi_bmof ipmi_msghandler input_leds ccp k10temp mac_hid sch_fq_codel msr ip_tables x_tables autofs4 btrfs blake2b_generic zstd_compress raid10 raid456 async_raid6_recov async_memcpy async_pq async_xor async_tx xor raid6_pq libcrc32c raid1 raid0 multipath linear ast i2c_algo_bit drm_vram_helper drm_ttm_helper ttm drm_kms_helper crct10dif_pclmul crc32_pclmul ghash_clmulni_intel syscopyarea aesni_intel sysfillrect crypto_simd sysimgblt fb_sys_fops cryptd hid_generic cec nvme ahci usbhid drm e1000e nvme_core hid libahci i2c_piix4 wmi
    [   27.551789] CR2: 0000000000000000
    [   27.555482] ---[ end trace 897987dfe93dccc6 ]---
    [   27.560630] RIP: 0010:run_timer_softirq+0x38b/0x4a0
    [   27.566069] Code: 4c 89 f7 e8 37 27 ac 00 49 c7 46 08 00 00 00 00 49 8b 04 24 48 85 c0 74 71 4d 8b 3c 24 4d 89 7e 08 66 90 49 8b 07 49 8b 57 08 <48> 89 02 48 85 c0 74 04 48 89 50 08 49 8b 77 18 41 f6 47 22 20 4c
    [   27.587021] RSP: 0018:ffffc42d00003ee8 EFLAGS: 00010086
    [   27.592848] RAX: dead000000000122 RBX: 0000000000000000 RCX: 0000000000000101
    [   27.600808] RDX: 0000000000000000 RSI: 0000000000000087 RDI: 0000000000000001
    [   27.608765] RBP: ffffc42d00003f70 R08: 0000000000000000 R09: 00000000000003eb
    [   27.616716] R10: ffffa0860cb300d0 R11: ffffa0c44de290b0 R12: ffffc42d00003ef8
    [   27.624673] R13: 00000000fffef200 R14: ffffa0c44de18dc0 R15: ffffa0867a882350
    [   27.632624] FS:  0000000000000000(0000) GS:ffffa0c44de00000(0000) knlGS:0000000000000000
    [   27.641650] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [   27.648159] CR2: 0000000000000000 CR3: 000000014569c001 CR4: 0000000000770ef0
    [   27.656119] PKRU: 55555554
    [   27.659133] Kernel panic - not syncing: Fatal exception in interrupt
    [   29.030411] Shutting down cpus with NMI
    [   29.034699] Kernel Offset: 0x2e600000 from 0xffffffff81000000 (relocation range: 0xffffffff80000000-0xffffffffbfffffff)
    [   29.046790] ---[ end Kernel panic - not syncing: Fatal exception in interrupt ]---
    
    Since unreliable, found by bisecting for KASAN's use-after-free in
    enqueue_timer+0x4f/0x1e0, where the timer callback is called.
    
    Reported-by: Kim Phillips <kim.phillips@amd.com>
    Signed-off-by: Kim Phillips <kim.phillips@amd.com>
    Fixes: aae74ff9caa8 ("drm/ast: Add detect function support")
    Link: https://lore.kernel.org/lkml/0f7871be-9ca6-5ae4-3a40-5db9a8fb2365@amd.com/
    Cc: Ainux <ainux.wang@gmail.com>
    Cc: Thomas Zimmermann <tzimmermann@suse.de>
    Cc: David Airlie <airlied@redhat.com>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Cc: sterlingteng@gmail.com
    Cc: chenhuacai@kernel.org
    Cc: Chuck Lever III <chuck.lever@oracle.com>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Borislav Petkov <bp@suse.de>
    Cc: Jon Grimm <jon.grimm@amd.com>
    Cc: dri-devel <dri-devel@lists.freedesktop.org>
    Cc: linux-kernel <linux-kernel@vger.kernel.org>
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20211021153006.92983-1-kim.phillips@amd.com

commit 480d42dc001bbfe953825a92073012fcd5a99161
Author: Andrea Righi <andrea.righi@canonical.com>
Date:   Tue Oct 19 11:20:26 2021 +0200

    blk-wbt: prevent NULL pointer dereference in wb_timer_fn
    
    The timer callback used to evaluate if the latency is exceeded can be
    executed after the corresponding disk has been released, causing the
    following NULL pointer dereference:
    
    [ 119.987108] BUG: kernel NULL pointer dereference, address: 0000000000000098
    [ 119.987617] #PF: supervisor read access in kernel mode
    [ 119.987971] #PF: error_code(0x0000) - not-present page
    [ 119.988325] PGD 7c4a4067 P4D 7c4a4067 PUD 7bf63067 PMD 0
    [ 119.988697] Oops: 0000 [#1] SMP NOPTI
    [ 119.988959] CPU: 1 PID: 9353 Comm: cloud-init Not tainted 5.15-rc5+arighi #rc5+arighi
    [ 119.989520] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.14.0-2 04/01/2014
    [ 119.990055] RIP: 0010:wb_timer_fn+0x44/0x3c0
    [ 119.990376] Code: 41 8b 9c 24 98 00 00 00 41 8b 94 24 b8 00 00 00 41 8b 84 24 d8 00 00 00 4d 8b 74 24 28 01 d3 01 c3 49 8b 44 24 60 48 8b 40 78 <4c> 8b b8 98 00 00 00 4d 85 f6 0f 84 c4 00 00 00 49 83 7c 24 30 00
    [ 119.991578] RSP: 0000:ffffb5f580957da8 EFLAGS: 00010246
    [ 119.991937] RAX: 0000000000000000 RBX: 0000000000000000 RCX: 0000000000000004
    [ 119.992412] RDX: 0000000000000000 RSI: 0000000000000000 RDI: ffff88f476d7f780
    [ 119.992895] RBP: ffffb5f580957dd0 R08: 0000000000000000 R09: 0000000000000000
    [ 119.993371] R10: 0000000000000004 R11: 0000000000000002 R12: ffff88f476c84500
    [ 119.993847] R13: ffff88f4434390c0 R14: 0000000000000000 R15: ffff88f4bdc98c00
    [ 119.994323] FS: 00007fb90bcd9c00(0000) GS:ffff88f4bdc80000(0000) knlGS:0000000000000000
    [ 119.994952] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [ 119.995380] CR2: 0000000000000098 CR3: 000000007c0d6000 CR4: 00000000000006e0
    [ 119.995906] Call Trace:
    [ 119.996130] ? blk_stat_free_callback_rcu+0x30/0x30
    [ 119.996505] blk_stat_timer_fn+0x138/0x140
    [ 119.996830] call_timer_fn+0x2b/0x100
    [ 119.997136] __run_timers.part.0+0x1d1/0x240
    [ 119.997470] ? kvm_clock_get_cycles+0x11/0x20
    [ 119.997826] ? ktime_get+0x3e/0xa0
    [ 119.998110] ? native_apic_msr_write+0x2c/0x30
    [ 119.998456] ? lapic_next_event+0x20/0x30
    [ 119.998779] ? clockevents_program_event+0x94/0xf0
    [ 119.999150] run_timer_softirq+0x2a/0x50
    [ 119.999465] __do_softirq+0xcb/0x26f
    [ 119.999764] irq_exit_rcu+0x8c/0xb0
    [ 120.000057] sysvec_apic_timer_interrupt+0x43/0x90
    [ 120.000429] ? asm_sysvec_apic_timer_interrupt+0xa/0x20
    [ 120.000836] asm_sysvec_apic_timer_interrupt+0x12/0x20
    
    In this case simply return from the timer callback (no action
    required) to prevent the NULL pointer dereference.
    
    BugLink: https://bugs.launchpad.net/bugs/1947557
    Link: https://lore.kernel.org/linux-mm/YWRNVTk9N8K0RMst@arighi-desktop/
    Fixes: 34dbad5d26e2 ("blk-stat: convert to callback-based statistics reporting")
    Signed-off-by: Andrea Righi <andrea.righi@canonical.com>
    Link: https://lore.kernel.org/r/YW6N2qXpBU3oc50q@arighi-desktop
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

commit 88183788eacb782eb6e1295f1934fb9531b503d6
Author: Will Deacon <will@kernel.org>
Date:   Tue Jun 8 16:43:41 2021 +0100

    clocksource/drivers/exynos_mct: Mark MCT device as CLOCK_EVT_FEAT_PERCPU
    
    The "mct_tick" is a per-cpu clockevents device. Set the
    CLOCK_EVT_FEAT_PERCPU feature to prevent e.g. mct_tick0 being unsafely
    designated as the global broadcast timer and instead treat the device as
    a per-cpu wakeup timer.
    
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Krzysztof Kozlowski <krzysztof.kozlowski@canonical.com>
    Signed-off-by: Will Deacon <will@kernel.org>
    Acked-by: Krzysztof Kozlowski <krzysztof.kozlowski@canonical.com>
    Reviewed-by: Chanwoo Choi <cw00.choi@samsung.com>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Link: https://lore.kernel.org/r/20210608154341.10794-3-will@kernel.org

commit a941a0349cf11ed250a04864fef268c2e05a1d32
Merge: 21edf5094872 2d0a9eb23ccf
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jun 29 12:31:16 2021 -0700

    Merge tag 'timers-core-2021-06-29' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer updates from Thomas Gleixner:
     "Time and clocksource/clockevent related updates:
    
      Core changes:
    
       - Infrastructure to support per CPU "broadcast" devices for per CPU
         clockevent devices which stop in deep idle states. This allows us
         to utilize the more efficient architected timer on certain ARM SoCs
         for normal operation instead of permanentely using the slow to
         access SoC specific clockevent device.
    
       - Print the name of the broadcast/wakeup device in /proc/timer_list
    
       - Make the clocksource watchdog more robust against delays between
         reading the current active clocksource and the watchdog
         clocksource. Such delays can be caused by NMIs, SMIs and vCPU
         preemption.
    
         Handle this by reading the watchdog clocksource twice, i.e. before
         and after reading the current active clocksource. In case that the
         two watchdog reads shows an excessive time delta, the read sequence
         is repeated up to 3 times.
    
       - Improve the debug output and add a test module for the watchdog
         mechanism.
    
       - Reimplementation of the venerable time64_to_tm() function with a
         faster and significantly smaller version. Straight from the source,
         i.e. the author of the related research paper contributed this!
    
      Driver changes:
    
       - No new drivers, not even new device tree bindings!
    
       - Fixes, improvements and cleanups and all over the place"
    
    * tag 'timers-core-2021-06-29' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (30 commits)
      time/kunit: Add missing MODULE_LICENSE()
      time: Improve performance of time64_to_tm()
      clockevents: Use list_move() instead of list_del()/list_add()
      clocksource: Print deviation in nanoseconds when a clocksource becomes unstable
      clocksource: Provide kernel module to test clocksource watchdog
      clocksource: Reduce clocksource-skew threshold
      clocksource: Limit number of CPUs checked for clock synchronization
      clocksource: Check per-CPU clock synchronization when marked unstable
      clocksource: Retry clock read if long delays detected
      clockevents: Add missing parameter documentation
      clocksource/drivers/timer-ti-dm: Drop unnecessary restore
      clocksource/arm_arch_timer: Improve Allwinner A64 timer workaround
      clocksource/drivers/arm_global_timer: Remove duplicated argument in arm_global_timer
      clocksource/drivers/arm_global_timer: Make symbol 'gt_clk_rate_change_nb' static
      arm: zynq: don't disable CONFIG_ARM_GLOBAL_TIMER due to CONFIG_CPU_FREQ anymore
      clocksource/drivers/arm_global_timer: Implement rate compensation whenever source clock changes
      clocksource/drivers/ingenic: Rename unreasonable array names
      clocksource/drivers/timer-ti-dm: Save and restore timer TIOCP_CFG
      clocksource/drivers/mediatek: Ack and disable interrupts on suspend
      clocksource/drivers/samsung_pwm: Constify source IO memory
      ...

commit 4e82d2e20f3b11f253bc5c6e92f05ed3694a1ae3
Author: Baokun Li <libaokun1@huawei.com>
Date:   Wed Jun 9 15:02:42 2021 +0800

    clockevents: Use list_move() instead of list_del()/list_add()
    
    Simplify the code.
    
    Reported-by: Hulk Robot <hulkci@huawei.com>
    Signed-off-by: Baokun Li <libaokun1@huawei.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lore.kernel.org/r/20210609070242.1322450-1-libaokun1@huawei.com

commit 64ab7071254c178e81a6d0203354aad6521258ea
Author: Baokun Li <libaokun1@huawei.com>
Date:   Tue Jun 8 10:43:05 2021 +0800

    clockevents: Add missing parameter documentation
    
    Add the missing documentation for the @cpu parameter of
    tick_cleanup_dead_cpu().
    
    Signed-off-by: Baokun Li <libaokun1@huawei.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lore.kernel.org/r/20210608024305.2750999-1-libaokun1@huawei.com

commit 171b45a4a70eef2fd36bb794ce4f5a48c440361e
Author: Andrea Merello <andrea.merello@gmail.com>
Date:   Tue Apr 6 15:00:44 2021 +0200

    clocksource/drivers/arm_global_timer: Implement rate compensation whenever source clock changes
    
    This patch adds rate change notification support for the parent clock;
    should that clock change, then we try to adjust the our prescaler in order
    to compensate (i.e. we adjust to still get the same timer frequency).
    
    This is loosely based on what it's done in timer-cadence-ttc. timer-sun51,
    mips-gic-timer and smp_twd.c also seem to look at their parent clock rate
    and to perform some kind of adjustment whenever needed.
    
    In this particular case we have only one single counter and prescaler for
    all clocksource, clockevent and timer_delay, and we just update it for all
    (i.e. we don't let it go and call clockevents_update_freq() to notify to
    the kernel that our rate has changed).
    
    Note that, there is apparently no other way to fixup things, because once
    we call register_current_timer_delay(), specifying the timer rate, it seems
    that that rate is not supposed to change ever.
    
    In order for this mechanism to work, we have to make assumptions about how
    much the initial clock is supposed to eventually decrease from the initial
    one, and set our initial prescaler to a value that we can eventually
    decrease enough to compensate. We provide an option in KConfig for this.
    
    In case we end up in a situation in which we are not able to compensate the
    parent clock change, we fail returning NOTIFY_BAD.
    
    This fixes a real-world problem with Zynq arch not being able to use this
    driver and CPU_FREQ at the same time (because ARM global timer is fed by
    the CPU clock, which may keep changing when CPU_FREQ is enabled).
    
    Signed-off-by: Andrea Merello <andrea.merello@gmail.com>
    Cc: Patrice Chotard <patrice.chotard@st.com>
    Cc: linux-kernel@vger.kernel.org
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: Michal Simek <michal.simek@xilinx.com>
    Cc: Sren Brinkmann <soren.brinkmann@xilinx.com>
    Reviewed-by: Patrice Chotard <patrice.chotard@foss.st.com>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Link: https://lore.kernel.org/r/20210406130045.15491-2-andrea.merello@gmail.com

commit 1fa98d96ea0ff6c8770eeba90417aab4b4e07f52
Author: YueHaibing <yuehaibing@huawei.com>
Date:   Sun May 23 14:58:25 2021 +0800

    clockevents: Use DEVICE_ATTR_[RO|WO] macros
    
    Use the DEVICE_ATTR_[RO|WO] helpers instead of plain DEVICE_ATTR, which
    makes the code a bit shorter and easier to read.
    
    Signed-off-by: YueHaibing <yuehaibing@huawei.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lore.kernel.org/r/20210523065825.19684-1-yuehaibing@huawei.com

commit bf2333393f33b9405727d5c3a0a151b0c558d01e
Author: Tony Lindgren <tony@atomide.com>
Date:   Thu Mar 4 09:21:35 2021 +0200

    clocksource/drivers/timer-ti-dm: Add missing set_state_oneshot_stopped
    
    [ Upstream commit ac4daf737674b4d29e19b7c300caff3bcf7160d8 ]
    
    To avoid spurious timer interrupts when KTIME_MAX is used, we need to
    configure set_state_oneshot_stopped(). Although implementing this is
    optional, it still affects things like power management for the extra
    timer interrupt.
    
    For more information, please see commit 8fff52fd5093 ("clockevents:
    Introduce CLOCK_EVT_STATE_ONESHOT_STOPPED state") and commit cf8c5009ee37
    ("clockevents/drivers/arm_arch_timer: Implement
    ->set_state_oneshot_stopped()").
    
    Fixes: 52762fbd1c47 ("clocksource/drivers/timer-ti-dm: Add clockevent and clocksource support")
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Link: https://lore.kernel.org/r/20210304072135.52712-4-tony@atomide.com
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 824b9aec96dc28a3df1a0f322c7010717abf214a
Author: Tony Lindgren <tony@atomide.com>
Date:   Thu Mar 4 09:21:35 2021 +0200

    clocksource/drivers/timer-ti-dm: Add missing set_state_oneshot_stopped
    
    [ Upstream commit ac4daf737674b4d29e19b7c300caff3bcf7160d8 ]
    
    To avoid spurious timer interrupts when KTIME_MAX is used, we need to
    configure set_state_oneshot_stopped(). Although implementing this is
    optional, it still affects things like power management for the extra
    timer interrupt.
    
    For more information, please see commit 8fff52fd5093 ("clockevents:
    Introduce CLOCK_EVT_STATE_ONESHOT_STOPPED state") and commit cf8c5009ee37
    ("clockevents/drivers/arm_arch_timer: Implement
    ->set_state_oneshot_stopped()").
    
    Fixes: 52762fbd1c47 ("clocksource/drivers/timer-ti-dm: Add clockevent and clocksource support")
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Link: https://lore.kernel.org/r/20210304072135.52712-4-tony@atomide.com
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit edfcc1835958392c0eaad85e6c0cb0b302fe3695
Author: Tony Lindgren <tony@atomide.com>
Date:   Thu Mar 4 09:21:35 2021 +0200

    clocksource/drivers/timer-ti-dm: Add missing set_state_oneshot_stopped
    
    [ Upstream commit ac4daf737674b4d29e19b7c300caff3bcf7160d8 ]
    
    To avoid spurious timer interrupts when KTIME_MAX is used, we need to
    configure set_state_oneshot_stopped(). Although implementing this is
    optional, it still affects things like power management for the extra
    timer interrupt.
    
    For more information, please see commit 8fff52fd5093 ("clockevents:
    Introduce CLOCK_EVT_STATE_ONESHOT_STOPPED state") and commit cf8c5009ee37
    ("clockevents/drivers/arm_arch_timer: Implement
    ->set_state_oneshot_stopped()").
    
    Fixes: 52762fbd1c47 ("clocksource/drivers/timer-ti-dm: Add clockevent and clocksource support")
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Link: https://lore.kernel.org/r/20210304072135.52712-4-tony@atomide.com
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit ac4daf737674b4d29e19b7c300caff3bcf7160d8
Author: Tony Lindgren <tony@atomide.com>
Date:   Thu Mar 4 09:21:35 2021 +0200

    clocksource/drivers/timer-ti-dm: Add missing set_state_oneshot_stopped
    
    To avoid spurious timer interrupts when KTIME_MAX is used, we need to
    configure set_state_oneshot_stopped(). Although implementing this is
    optional, it still affects things like power management for the extra
    timer interrupt.
    
    For more information, please see commit 8fff52fd5093 ("clockevents:
    Introduce CLOCK_EVT_STATE_ONESHOT_STOPPED state") and commit cf8c5009ee37
    ("clockevents/drivers/arm_arch_timer: Implement
    ->set_state_oneshot_stopped()").
    
    Fixes: 52762fbd1c47 ("clocksource/drivers/timer-ti-dm: Add clockevent and clocksource support")
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Link: https://lore.kernel.org/r/20210304072135.52712-4-tony@atomide.com

commit 62ecd2b17d7078ceec69c6b3c55d14ecc4c95621
Author: Tom Rix <trix@redhat.com>
Date:   Mon Jan 18 13:19:55 2021 -0800

    clocksource/drivers/mxs_timer: Add missing semicolon when DEBUG is defined
    
    [ Upstream commit 7da390694afbaed8e0f05717a541dfaf1077ba51 ]
    
    When DEBUG is defined this error occurs
    
    drivers/clocksource/mxs_timer.c:138:1: error:
      expected ; before } token
    
    The preceding statement needs a semicolon.
    Replace pr_info() with pr_debug() and remove the unneeded ifdef.
    
    Fixes: eb8703e2ef7c ("clockevents/drivers/mxs: Migrate to new 'set-state' interface")
    Signed-off-by: Tom Rix <trix@redhat.com>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Link: https://lore.kernel.org/r/20210118211955.763609-1-trix@redhat.com
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit f8b64afe9166c8ceec5d7e3893381283b5a07e99
Author: Tom Rix <trix@redhat.com>
Date:   Mon Jan 18 13:19:55 2021 -0800

    clocksource/drivers/mxs_timer: Add missing semicolon when DEBUG is defined
    
    [ Upstream commit 7da390694afbaed8e0f05717a541dfaf1077ba51 ]
    
    When DEBUG is defined this error occurs
    
    drivers/clocksource/mxs_timer.c:138:1: error:
      expected ; before } token
    
    The preceding statement needs a semicolon.
    Replace pr_info() with pr_debug() and remove the unneeded ifdef.
    
    Fixes: eb8703e2ef7c ("clockevents/drivers/mxs: Migrate to new 'set-state' interface")
    Signed-off-by: Tom Rix <trix@redhat.com>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Link: https://lore.kernel.org/r/20210118211955.763609-1-trix@redhat.com
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 6a52a17fd0a3b3da5414ca3f81d21f5b7dd6053c
Author: Tom Rix <trix@redhat.com>
Date:   Mon Jan 18 13:19:55 2021 -0800

    clocksource/drivers/mxs_timer: Add missing semicolon when DEBUG is defined
    
    [ Upstream commit 7da390694afbaed8e0f05717a541dfaf1077ba51 ]
    
    When DEBUG is defined this error occurs
    
    drivers/clocksource/mxs_timer.c:138:1: error:
      expected ; before } token
    
    The preceding statement needs a semicolon.
    Replace pr_info() with pr_debug() and remove the unneeded ifdef.
    
    Fixes: eb8703e2ef7c ("clockevents/drivers/mxs: Migrate to new 'set-state' interface")
    Signed-off-by: Tom Rix <trix@redhat.com>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Link: https://lore.kernel.org/r/20210118211955.763609-1-trix@redhat.com
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 2ac171abc715e45c09232391bac1f1cca443c6a5
Author: Tom Rix <trix@redhat.com>
Date:   Mon Jan 18 13:19:55 2021 -0800

    clocksource/drivers/mxs_timer: Add missing semicolon when DEBUG is defined
    
    [ Upstream commit 7da390694afbaed8e0f05717a541dfaf1077ba51 ]
    
    When DEBUG is defined this error occurs
    
    drivers/clocksource/mxs_timer.c:138:1: error:
      expected ; before } token
    
    The preceding statement needs a semicolon.
    Replace pr_info() with pr_debug() and remove the unneeded ifdef.
    
    Fixes: eb8703e2ef7c ("clockevents/drivers/mxs: Migrate to new 'set-state' interface")
    Signed-off-by: Tom Rix <trix@redhat.com>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Link: https://lore.kernel.org/r/20210118211955.763609-1-trix@redhat.com
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit fe25fe09421eee24b22bd3da94e9a54720fb6ceb
Author: Tom Rix <trix@redhat.com>
Date:   Mon Jan 18 13:19:55 2021 -0800

    clocksource/drivers/mxs_timer: Add missing semicolon when DEBUG is defined
    
    [ Upstream commit 7da390694afbaed8e0f05717a541dfaf1077ba51 ]
    
    When DEBUG is defined this error occurs
    
    drivers/clocksource/mxs_timer.c:138:1: error:
      expected ; before } token
    
    The preceding statement needs a semicolon.
    Replace pr_info() with pr_debug() and remove the unneeded ifdef.
    
    Fixes: eb8703e2ef7c ("clockevents/drivers/mxs: Migrate to new 'set-state' interface")
    Signed-off-by: Tom Rix <trix@redhat.com>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Link: https://lore.kernel.org/r/20210118211955.763609-1-trix@redhat.com
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 2b1cbe30b1da2a46d8032868d391362cdec90088
Author: Tom Rix <trix@redhat.com>
Date:   Mon Jan 18 13:19:55 2021 -0800

    clocksource/drivers/mxs_timer: Add missing semicolon when DEBUG is defined
    
    [ Upstream commit 7da390694afbaed8e0f05717a541dfaf1077ba51 ]
    
    When DEBUG is defined this error occurs
    
    drivers/clocksource/mxs_timer.c:138:1: error:
      expected ; before } token
    
    The preceding statement needs a semicolon.
    Replace pr_info() with pr_debug() and remove the unneeded ifdef.
    
    Fixes: eb8703e2ef7c ("clockevents/drivers/mxs: Migrate to new 'set-state' interface")
    Signed-off-by: Tom Rix <trix@redhat.com>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Link: https://lore.kernel.org/r/20210118211955.763609-1-trix@redhat.com
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit da3f0e7b38984eaaef8650d6c82738f986b007a4
Author: Tom Rix <trix@redhat.com>
Date:   Mon Jan 18 13:19:55 2021 -0800

    clocksource/drivers/mxs_timer: Add missing semicolon when DEBUG is defined
    
    [ Upstream commit 7da390694afbaed8e0f05717a541dfaf1077ba51 ]
    
    When DEBUG is defined this error occurs
    
    drivers/clocksource/mxs_timer.c:138:1: error:
      expected ; before } token
    
    The preceding statement needs a semicolon.
    Replace pr_info() with pr_debug() and remove the unneeded ifdef.
    
    Fixes: eb8703e2ef7c ("clockevents/drivers/mxs: Migrate to new 'set-state' interface")
    Signed-off-by: Tom Rix <trix@redhat.com>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Link: https://lore.kernel.org/r/20210118211955.763609-1-trix@redhat.com
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 4473923b6674aeddb57c586939dd705cb499131b
Author: Dexuan Cui <decui@microsoft.com>
Date:   Sat Jan 16 14:31:36 2021 -0800

    x86/hyperv: Initialize clockevents after LAPIC is initialized
    
    [ Upstream commit fff7b5e6ee63c5d20406a131b260c619cdd24fd1 ]
    
    With commit 4df4cb9e99f8, the Hyper-V direct-mode STIMER is actually
    initialized before LAPIC is initialized: see
    
      apic_intr_mode_init()
    
        x86_platform.apic_post_init()
          hyperv_init()
            hv_stimer_alloc()
    
        apic_bsp_setup()
          setup_local_APIC()
    
    setup_local_APIC() temporarily disables LAPIC, initializes it and
    re-eanble it.  The direct-mode STIMER depends on LAPIC, and when it's
    registered, it can be programmed immediately and the timer can fire
    very soon:
    
      hv_stimer_init
        clockevents_config_and_register
          clockevents_register_device
            tick_check_new_device
              tick_setup_device
                tick_setup_periodic(), tick_setup_oneshot()
                  clockevents_program_event
    
    When the timer fires in the hypervisor, if the LAPIC is in the
    disabled state, new versions of Hyper-V ignore the event and don't inject
    the timer interrupt into the VM, and hence the VM hangs when it boots.
    
    Note: when the VM starts/reboots, the LAPIC is pre-enabled by the
    firmware, so the window of LAPIC being temporarily disabled is pretty
    small, and the issue can only happen once out of 100~200 reboots for
    a 40-vCPU VM on one dev host, and on another host the issue doesn't
    reproduce after 2000 reboots.
    
    The issue is more noticeable for kdump/kexec, because the LAPIC is
    disabled by the first kernel, and stays disabled until the kdump/kexec
    kernel enables it. This is especially an issue to a Generation-2 VM
    (for which Hyper-V doesn't emulate the PIT timer) when CONFIG_HZ=1000
    (rather than CONFIG_HZ=250) is used.
    
    Fix the issue by moving hv_stimer_alloc() to a later place where the
    LAPIC timer is initialized.
    
    Fixes: 4df4cb9e99f8 ("x86/hyperv: Initialize clockevents earlier in CPU onlining")
    Signed-off-by: Dexuan Cui <decui@microsoft.com>
    Reviewed-by:  Michael Kelley <mikelley@microsoft.com>
    Link: https://lore.kernel.org/r/20210116223136.13892-1-decui@microsoft.com
    Signed-off-by: Wei Liu <wei.liu@kernel.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 28df858033484b830c2ea146c03da67d2d659405
Merge: 1e2a199f6ccd fff7b5e6ee63
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jan 19 12:58:55 2021 -0800

    Merge tag 'hyperv-fixes-signed-20210119' of git://git.kernel.org/pub/scm/linux/kernel/git/hyperv/linux
    
    Pull hyperv fix from Wei Liu:
     "One patch from Dexuan to fix clockevent initialization"
    
    * tag 'hyperv-fixes-signed-20210119' of git://git.kernel.org/pub/scm/linux/kernel/git/hyperv/linux:
      x86/hyperv: Initialize clockevents after LAPIC is initialized

commit 7da390694afbaed8e0f05717a541dfaf1077ba51
Author: Tom Rix <trix@redhat.com>
Date:   Mon Jan 18 13:19:55 2021 -0800

    clocksource/drivers/mxs_timer: Add missing semicolon when DEBUG is defined
    
    When DEBUG is defined this error occurs
    
    drivers/clocksource/mxs_timer.c:138:1: error:
      expected ; before } token
    
    The preceding statement needs a semicolon.
    Replace pr_info() with pr_debug() and remove the unneeded ifdef.
    
    Fixes: eb8703e2ef7c ("clockevents/drivers/mxs: Migrate to new 'set-state' interface")
    Signed-off-by: Tom Rix <trix@redhat.com>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Link: https://lore.kernel.org/r/20210118211955.763609-1-trix@redhat.com

commit fff7b5e6ee63c5d20406a131b260c619cdd24fd1
Author: Dexuan Cui <decui@microsoft.com>
Date:   Sat Jan 16 14:31:36 2021 -0800

    x86/hyperv: Initialize clockevents after LAPIC is initialized
    
    With commit 4df4cb9e99f8, the Hyper-V direct-mode STIMER is actually
    initialized before LAPIC is initialized: see
    
      apic_intr_mode_init()
    
        x86_platform.apic_post_init()
          hyperv_init()
            hv_stimer_alloc()
    
        apic_bsp_setup()
          setup_local_APIC()
    
    setup_local_APIC() temporarily disables LAPIC, initializes it and
    re-eanble it.  The direct-mode STIMER depends on LAPIC, and when it's
    registered, it can be programmed immediately and the timer can fire
    very soon:
    
      hv_stimer_init
        clockevents_config_and_register
          clockevents_register_device
            tick_check_new_device
              tick_setup_device
                tick_setup_periodic(), tick_setup_oneshot()
                  clockevents_program_event
    
    When the timer fires in the hypervisor, if the LAPIC is in the
    disabled state, new versions of Hyper-V ignore the event and don't inject
    the timer interrupt into the VM, and hence the VM hangs when it boots.
    
    Note: when the VM starts/reboots, the LAPIC is pre-enabled by the
    firmware, so the window of LAPIC being temporarily disabled is pretty
    small, and the issue can only happen once out of 100~200 reboots for
    a 40-vCPU VM on one dev host, and on another host the issue doesn't
    reproduce after 2000 reboots.
    
    The issue is more noticeable for kdump/kexec, because the LAPIC is
    disabled by the first kernel, and stays disabled until the kdump/kexec
    kernel enables it. This is especially an issue to a Generation-2 VM
    (for which Hyper-V doesn't emulate the PIT timer) when CONFIG_HZ=1000
    (rather than CONFIG_HZ=250) is used.
    
    Fix the issue by moving hv_stimer_alloc() to a later place where the
    LAPIC timer is initialized.
    
    Fixes: 4df4cb9e99f8 ("x86/hyperv: Initialize clockevents earlier in CPU onlining")
    Signed-off-by: Dexuan Cui <decui@microsoft.com>
    Reviewed-by:  Michael Kelley <mikelley@microsoft.com>
    Link: https://lore.kernel.org/r/20210116223136.13892-1-decui@microsoft.com
    Signed-off-by: Wei Liu <wei.liu@kernel.org>

commit 3c07bf0fc3558f680374f8ac6d148b0082aa08c6
Author: Kefeng Wang <wangkefeng.wang@huawei.com>
Date:   Thu Oct 29 20:33:14 2020 +0800

    clocksource/drivers/sp804: Make some symbol static
    
    drivers/clocksource/timer-sp804.c:38:31: warning: symbol 'arm_sp804_timer' was not declared. Should it be static?
    drivers/clocksource/timer-sp804.c:47:31: warning: symbol 'hisi_sp804_timer' was not declared. Should it be static?
    drivers/clocksource/timer-sp804.c:120:12: warning: symbol 'sp804_clocksource_and_sched_clock_init' was not declared. Should it be static?
    drivers/clocksource/timer-sp804.c:219:12: warning: symbol 'sp804_clockevents_init' was not declared. Should it be static?
    
    And move __initdata after the variables.
    
    Signed-off-by: Kefeng Wang <wangkefeng.wang@huawei.com>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Link: https://lore.kernel.org/r/20201029123317.90286-2-wangkefeng.wang@huawei.com

commit 3c0a4b185f6c82c06025720b00a490c719a6f0ff
Author: Zhen Lei <thunder.leizhen@huawei.com>
Date:   Wed Oct 21 09:22:59 2020 +0800

    clocksource/drivers/sp804: Add static for functions such as sp804_clockevents_init()
    
    Add static for sp804_clocksource_and_sched_clock_init() and
    sp804_clockevents_init(), they are only used in timer-sp804.c now.
    Otherwise, the following warning will be reported:
    
    drivers/clocksource/timer-sp804.c:68:12: warning: no previous prototype \
    for 'sp804_clocksource_and_sched_clock_init' [-Wmissing-prototypes]
    drivers/clocksource/timer-sp804.c:162:12: warning: no previous prototype \
    for 'sp804_clockevents_init' [-Wmissing-prototypes]
    
    Fixes: 975434f8b24a ("clocksource/drivers/sp804: Delete the leading "__" of some functions")
    Fixes: 65f4d7ddc7b6 ("clocksource/drivers/sp804: Remove unused sp804_timer_disable() and timer-sp804.h")
    Reported-by: kernel test robot <lkp@intel.com>
    Signed-off-by: Zhen Lei <thunder.leizhen@huawei.com>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Link: https://lore.kernel.org/r/20201021012259.2067-2-thunder.leizhen@huawei.com

commit a048ffdf85506fa3489d38ed47a88f80d63e2194
Author: Qian Cai <cai@redhat.com>
Date:   Wed Oct 28 14:23:34 2020 -0400

    powerpc/smp: Call rcu_cpu_starting() earlier
    
    commit 99f070b62322a4b8c1252952735806d09eb44b68 upstream.
    
    The call to rcu_cpu_starting() in start_secondary() is not early
    enough in the CPU-hotplug onlining process, which results in lockdep
    splats as follows (with CONFIG_PROVE_RCU_LIST=y):
    
      WARNING: suspicious RCU usage
      -----------------------------
      kernel/locking/lockdep.c:3497 RCU-list traversed in non-reader section!!
    
      other info that might help us debug this:
    
      RCU used illegally from offline CPU!
      rcu_scheduler_active = 1, debug_locks = 1
      no locks held by swapper/1/0.
    
      Call Trace:
      dump_stack+0xec/0x144 (unreliable)
      lockdep_rcu_suspicious+0x128/0x14c
      __lock_acquire+0x1060/0x1c60
      lock_acquire+0x140/0x5f0
      _raw_spin_lock_irqsave+0x64/0xb0
      clockevents_register_device+0x74/0x270
      register_decrementer_clockevent+0x94/0x110
      start_secondary+0x134/0x800
      start_secondary_prolog+0x10/0x14
    
    This is avoided by adding a call to rcu_cpu_starting() near the
    beginning of the start_secondary() function. Note that the
    raw_smp_processor_id() is required in order to avoid calling into
    lockdep before RCU has declared the CPU to be watched for readers.
    
    It's safe to call rcu_cpu_starting() in the arch code as well as later
    in generic code, as explained by Paul:
    
      It uses a per-CPU variable so that RCU pays attention only to the
      first call to rcu_cpu_starting() if there is more than one of them.
      This is even intentional, due to there being a generic
      arch-independent call to rcu_cpu_starting() in
      notify_cpu_starting().
    
      So multiple calls to rcu_cpu_starting() are fine by design.
    
    Fixes: 4d004099a668 ("lockdep: Fix lockdep recursion")
    Signed-off-by: Qian Cai <cai@redhat.com>
    Acked-by: Paul E. McKenney <paulmck@kernel.org>
    [mpe: Add Fixes tag, reword slightly & expand change log]
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Link: https://lore.kernel.org/r/20201028182334.13466-1-cai@redhat.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit e68d3689dcfa003b4808e124855ec872f5564fc4
Author: Qian Cai <cai@redhat.com>
Date:   Wed Oct 28 14:27:42 2020 -0400

    s390/smp: move rcu_cpu_starting() earlier
    
    [ Upstream commit de5d9dae150ca1c1b5c7676711a9ca139d1a8dec ]
    
    The call to rcu_cpu_starting() in smp_init_secondary() is not early
    enough in the CPU-hotplug onlining process, which results in lockdep
    splats as follows:
    
     WARNING: suspicious RCU usage
     -----------------------------
     kernel/locking/lockdep.c:3497 RCU-list traversed in non-reader section!!
    
     other info that might help us debug this:
    
     RCU used illegally from offline CPU!
     rcu_scheduler_active = 1, debug_locks = 1
     no locks held by swapper/1/0.
    
     Call Trace:
     show_stack+0x158/0x1f0
     dump_stack+0x1f2/0x238
     __lock_acquire+0x2640/0x4dd0
     lock_acquire+0x3a8/0xd08
     _raw_spin_lock_irqsave+0xc0/0xf0
     clockevents_register_device+0xa8/0x528
     init_cpu_timer+0x33e/0x468
     smp_init_secondary+0x11a/0x328
     smp_start_secondary+0x82/0x88
    
    This is avoided by moving the call to rcu_cpu_starting up near the
    beginning of the smp_init_secondary() function. Note that the
    raw_smp_processor_id() is required in order to avoid calling into
    lockdep before RCU has declared the CPU to be watched for readers.
    
    Link: https://lore.kernel.org/lkml/160223032121.7002.1269740091547117869.tip-bot2@tip-bot2/
    Signed-off-by: Qian Cai <cai@redhat.com>
    Acked-by: Paul E. McKenney <paulmck@kernel.org>
    Signed-off-by: Heiko Carstens <hca@linux.ibm.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 4d6f536e34d669bd150f7a1883eb203dd4ae2679
Author: Qian Cai <cai@redhat.com>
Date:   Wed Oct 28 14:27:42 2020 -0400

    s390/smp: move rcu_cpu_starting() earlier
    
    [ Upstream commit de5d9dae150ca1c1b5c7676711a9ca139d1a8dec ]
    
    The call to rcu_cpu_starting() in smp_init_secondary() is not early
    enough in the CPU-hotplug onlining process, which results in lockdep
    splats as follows:
    
     WARNING: suspicious RCU usage
     -----------------------------
     kernel/locking/lockdep.c:3497 RCU-list traversed in non-reader section!!
    
     other info that might help us debug this:
    
     RCU used illegally from offline CPU!
     rcu_scheduler_active = 1, debug_locks = 1
     no locks held by swapper/1/0.
    
     Call Trace:
     show_stack+0x158/0x1f0
     dump_stack+0x1f2/0x238
     __lock_acquire+0x2640/0x4dd0
     lock_acquire+0x3a8/0xd08
     _raw_spin_lock_irqsave+0xc0/0xf0
     clockevents_register_device+0xa8/0x528
     init_cpu_timer+0x33e/0x468
     smp_init_secondary+0x11a/0x328
     smp_start_secondary+0x82/0x88
    
    This is avoided by moving the call to rcu_cpu_starting up near the
    beginning of the smp_init_secondary() function. Note that the
    raw_smp_processor_id() is required in order to avoid calling into
    lockdep before RCU has declared the CPU to be watched for readers.
    
    Link: https://lore.kernel.org/lkml/160223032121.7002.1269740091547117869.tip-bot2@tip-bot2/
    Signed-off-by: Qian Cai <cai@redhat.com>
    Acked-by: Paul E. McKenney <paulmck@kernel.org>
    Signed-off-by: Heiko Carstens <hca@linux.ibm.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 2343665ea3627826e316674f4b80ee102b9010a7
Author: Qian Cai <cai@redhat.com>
Date:   Wed Oct 28 14:27:42 2020 -0400

    s390/smp: move rcu_cpu_starting() earlier
    
    [ Upstream commit de5d9dae150ca1c1b5c7676711a9ca139d1a8dec ]
    
    The call to rcu_cpu_starting() in smp_init_secondary() is not early
    enough in the CPU-hotplug onlining process, which results in lockdep
    splats as follows:
    
     WARNING: suspicious RCU usage
     -----------------------------
     kernel/locking/lockdep.c:3497 RCU-list traversed in non-reader section!!
    
     other info that might help us debug this:
    
     RCU used illegally from offline CPU!
     rcu_scheduler_active = 1, debug_locks = 1
     no locks held by swapper/1/0.
    
     Call Trace:
     show_stack+0x158/0x1f0
     dump_stack+0x1f2/0x238
     __lock_acquire+0x2640/0x4dd0
     lock_acquire+0x3a8/0xd08
     _raw_spin_lock_irqsave+0xc0/0xf0
     clockevents_register_device+0xa8/0x528
     init_cpu_timer+0x33e/0x468
     smp_init_secondary+0x11a/0x328
     smp_start_secondary+0x82/0x88
    
    This is avoided by moving the call to rcu_cpu_starting up near the
    beginning of the smp_init_secondary() function. Note that the
    raw_smp_processor_id() is required in order to avoid calling into
    lockdep before RCU has declared the CPU to be watched for readers.
    
    Link: https://lore.kernel.org/lkml/160223032121.7002.1269740091547117869.tip-bot2@tip-bot2/
    Signed-off-by: Qian Cai <cai@redhat.com>
    Acked-by: Paul E. McKenney <paulmck@kernel.org>
    Signed-off-by: Heiko Carstens <hca@linux.ibm.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit ee06fcb98dcdc2713c83c29e9101b007a825cd7f
Author: Ben Greear <greearb@candelatech.com>
Date:   Tue Sep 22 12:19:57 2020 -0700

    ath10k: Don't iterate over not-sdata-in-driver interfaces.
    
    This fixes possible crash scenario where interfaces that were not
    set up in the driver yet might still be iterated over.  When originally
    debugged on the ath10k-ct driver, the crash looked like this:
    
    kernel BUG at /home/greearb/git/linux-4.7.dev.y/drivers/net/wireless/ath/ath10k/wmi.c:1781!
    invalid opcode: 0000 [#1] PREEMPT SMP KASAN
    Modules linked in: nf_conntrack_netlink nf_conntrack nfnetlink nf_defrag_ipv4 bridge carl9170 mac80211_hwsim ath10k_pci ath10k_core ath5k ath9k ath9k_common ath9k_hw ath mac80211 cfg80211 8021q garp mrp stp llc bnep bluetooth fuse macvlan pktgen rpcsec_gss_krb5 nfsv4 nfs fscache snd_hda_codec_hdmi coretemp hwmon intel_rapl x86_pkg_temp_thermal intel_powerclamp snd_hda_codec_realtek snd_hda_codec_generic kvm iTCO_wdt irqbypass iTCO_vendor_support joydev snd_hda_intel snd_hda_codec snd_hda_core snd_hwdep snd_seq snd_seq_device pcspkr snd_pcm snd_timer shpchp snd i2c_i801 lpc_ich soundcore tpm_tis tpm nfsd auth_rpcgss nfs_acl lockd grace sunrpc i915 serio_raw i2c_algo_bit drm_kms_helper ata_generic e1000e pata_acpi drm ptp pps_core i2c_core fjes video ipv6 [last unloaded: nf_conntrack]
    CPU: 1 PID: 0 Comm: swapper/1 Not tainted 4.7.10+ #15
    Hardware name: To be filled by O.E.M. To be filled by O.E.M./ChiefRiver, BIOS 4.6.5 06/07/2013
    task: ffff8801d4f20000 ti: ffff8801d4f28000 task.ti: ffff8801d4f28000
    RIP: 0010:[<ffffffffa0efbcfb>]  [<ffffffffa0efbcfb>] ath10k_wmi_tx_beacons_iter+0x28b/0x290 [ath10k_core]
    RSP: 0018:ffff8801d6447a98  EFLAGS: 00010293
    RAX: 0000000000000018 RBX: ffff8801ce97e1d8 RCX: 0000000000000000
    RDX: 0000000000000018 RSI: 0000000000000003 RDI: ffffed003ac88f49
    RBP: ffff8801d6447af0 R08: 0000000000000003 R09: 0000000000000000
    R10: 0000000000000001 R11: 0000000000000001 R12: 0000000000000000
    R13: ffff8801ce97e320 R14: ffff8801ce97e378 R15: ffff8801ce97ca40
    FS:  0000000000000000(0000) GS:ffff8801d6440000(0000) knlGS:0000000000000000
    CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    CR2: 00007eff191ef1ab CR3: 000000000260a000 CR4: 00000000001406e0
    Stack:
     1ffff1003ac88f59 0000000041b58ab3 ffffffffa0f4d52a ffff8801d4f20000
     0000000000000246 0000000000000002 ffff8801ce97e1d8 ffff8801bd5d39b8
     0000000000000002 0000000000000001 ffff8801ce97ca40 ffff8801d6447b48
    Call Trace:
     <IRQ>
     [<ffffffffa0d03e5c>] __iterate_interfaces+0xfc/0x1d0 [mac80211]
     [<ffffffffa0efba70>] ? ath10k_wmi_cmd_send_nowait+0x260/0x260 [ath10k_core]
     [<ffffffffa0efba70>] ? ath10k_wmi_cmd_send_nowait+0x260/0x260 [ath10k_core]
     [<ffffffffa0d04477>] ieee80211_iterate_active_interfaces_atomic+0x67/0x100 [mac80211]
     [<ffffffffa0d04410>] ? ieee80211_handle_reconfig_failure+0x140/0x140 [mac80211]
     [<ffffffffa0ef4060>] ? ath10k_tpc_config_disp_tables+0x620/0x620 [ath10k_core]
     [<ffffffffa0ef408b>] ath10k_wmi_op_ep_tx_credits+0x2b/0x50 [ath10k_core]
     [<ffffffffa0ee2fd2>] ath10k_htc_rx_completion_handler+0x422/0x5c0 [ath10k_core]
     [<ffffffffa0b4301e>] ath10k_pci_process_rx_cb+0x37e/0x430 [ath10k_pci]
     [<ffffffffa0ee2bb0>] ? ath10k_htc_build_tx_ctrl_skb+0xc0/0xc0 [ath10k_core]
     [<ffffffffa0b42ca0>] ? ath10k_pci_rx_post_pipe+0x550/0x550 [ath10k_pci]
     [<ffffffff8120cbe5>] ? debug_lockdep_rcu_enabled+0x35/0x40
     [<ffffffff811e1893>] ? mark_held_locks+0x23/0xc0
     [<ffffffff8116019a>] ? __local_bh_enable_ip+0x6a/0xd0
     [<ffffffff811e1abb>] ? trace_hardirqs_on_caller+0x18b/0x290
     [<ffffffff811e1bcd>] ? trace_hardirqs_on+0xd/0x10
     [<ffffffff8116019a>] ? __local_bh_enable_ip+0x6a/0xd0
     [<ffffffff81df11d0>] ? _raw_spin_unlock_bh+0x30/0x40
     [<ffffffffa0b4902e>] ? ath10k_ce_per_engine_service+0xee/0x100 [ath10k_pci]
     [<ffffffffa0b43139>] ath10k_pci_htt_htc_rx_cb+0x29/0x30 [ath10k_pci]
     [<ffffffffa0b48fe6>] ath10k_ce_per_engine_service+0xa6/0x100 [ath10k_pci]
     [<ffffffffa0b49116>] ath10k_ce_per_engine_service_any+0xd6/0xf0 [ath10k_pci]
     [<ffffffffa0b45800>] ? ath10k_pci_enable_legacy_irq+0xe0/0xe0 [ath10k_pci]
     [<ffffffffa0b4585f>] ath10k_pci_tasklet+0x5f/0xb0 [ath10k_pci]
     [<ffffffff81160445>] tasklet_action+0x245/0x2b0
     [<ffffffff81df4831>] __do_softirq+0x181/0x595
     [<ffffffff8116137c>] irq_exit+0xbc/0xc0
     [<ffffffff81df423c>] do_IRQ+0x7c/0x150
     [<ffffffff81df23cc>] common_interrupt+0x8c/0x8c
     <EOI>
     [<ffffffff811e1abb>] ? trace_hardirqs_on_caller+0x18b/0x290
     [<ffffffff81b722ae>] ? cpuidle_enter_state+0x1ae/0x4b0
     [<ffffffff81b722a7>] ? cpuidle_enter_state+0x1a7/0x4b0
     [<ffffffff81b72602>] cpuidle_enter+0x12/0x20
     [<ffffffff811d0b6e>] call_cpuidle+0x4e/0x90
     [<ffffffff811d10e7>] cpu_startup_entry+0x3f7/0x540
     [<ffffffff811d0cf0>] ? default_idle_call+0x50/0x50
     [<ffffffff81234bdf>] ? clockevents_config_and_register+0x5f/0x70
     [<ffffffff81085a9a>] ? setup_APIC_timer+0xfa/0x110
     [<ffffffff81083b63>] start_secondary+0x253/0x2b0
     [<ffffffff81083910>] ? set_cpu_sibling_map+0x920/0x920
    Code: 4d 49 e0 8b b3 48 01 00 00 48 c7 c7 a0 ee f3 a0 e8 d9 c2 3f e0 49 81 fd 3f 1f 00 00 76 0f 49 81 fc 3f 1f 00 00 0f 87 c0 fd ff ff <0f> 0b 0f 0b 90 55 48 89 e5 41 57 41 56 48 8d 85 58 ff ff ff 41
    RIP  [<ffffffffa0efbcfb>] ath10k_wmi_tx_beacons_iter+0x28b/0x290 [ath10k_core]
     RSP <ffff8801d6447a98>
    ---[ end trace 6588464714e5163a ]---
    
    Similar logic was tested for years in ath10k-ct driver and various firmware.
    
    Also tested with stock kernel plus this patch, with firmware
    10.2.4-1.0-00037
    
    This test case was to bring up 5 vap on a radio and fake a firmware
    crash.  Make sure ap interfaces continue to function properly.
    
    Signed-off-by: Ben Greear <greearb@candelatech.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
    Link: https://lore.kernel.org/r/20200922191957.25257-2-greearb@candelatech.com

commit de5d9dae150ca1c1b5c7676711a9ca139d1a8dec
Author: Qian Cai <cai@redhat.com>
Date:   Wed Oct 28 14:27:42 2020 -0400

    s390/smp: move rcu_cpu_starting() earlier
    
    The call to rcu_cpu_starting() in smp_init_secondary() is not early
    enough in the CPU-hotplug onlining process, which results in lockdep
    splats as follows:
    
     WARNING: suspicious RCU usage
     -----------------------------
     kernel/locking/lockdep.c:3497 RCU-list traversed in non-reader section!!
    
     other info that might help us debug this:
    
     RCU used illegally from offline CPU!
     rcu_scheduler_active = 1, debug_locks = 1
     no locks held by swapper/1/0.
    
     Call Trace:
     show_stack+0x158/0x1f0
     dump_stack+0x1f2/0x238
     __lock_acquire+0x2640/0x4dd0
     lock_acquire+0x3a8/0xd08
     _raw_spin_lock_irqsave+0xc0/0xf0
     clockevents_register_device+0xa8/0x528
     init_cpu_timer+0x33e/0x468
     smp_init_secondary+0x11a/0x328
     smp_start_secondary+0x82/0x88
    
    This is avoided by moving the call to rcu_cpu_starting up near the
    beginning of the smp_init_secondary() function. Note that the
    raw_smp_processor_id() is required in order to avoid calling into
    lockdep before RCU has declared the CPU to be watched for readers.
    
    Link: https://lore.kernel.org/lkml/160223032121.7002.1269740091547117869.tip-bot2@tip-bot2/
    Signed-off-by: Qian Cai <cai@redhat.com>
    Acked-by: Paul E. McKenney <paulmck@kernel.org>
    Signed-off-by: Heiko Carstens <hca@linux.ibm.com>

commit 99f070b62322a4b8c1252952735806d09eb44b68
Author: Qian Cai <cai@redhat.com>
Date:   Wed Oct 28 14:23:34 2020 -0400

    powerpc/smp: Call rcu_cpu_starting() earlier
    
    The call to rcu_cpu_starting() in start_secondary() is not early
    enough in the CPU-hotplug onlining process, which results in lockdep
    splats as follows (with CONFIG_PROVE_RCU_LIST=y):
    
      WARNING: suspicious RCU usage
      -----------------------------
      kernel/locking/lockdep.c:3497 RCU-list traversed in non-reader section!!
    
      other info that might help us debug this:
    
      RCU used illegally from offline CPU!
      rcu_scheduler_active = 1, debug_locks = 1
      no locks held by swapper/1/0.
    
      Call Trace:
      dump_stack+0xec/0x144 (unreliable)
      lockdep_rcu_suspicious+0x128/0x14c
      __lock_acquire+0x1060/0x1c60
      lock_acquire+0x140/0x5f0
      _raw_spin_lock_irqsave+0x64/0xb0
      clockevents_register_device+0x74/0x270
      register_decrementer_clockevent+0x94/0x110
      start_secondary+0x134/0x800
      start_secondary_prolog+0x10/0x14
    
    This is avoided by adding a call to rcu_cpu_starting() near the
    beginning of the start_secondary() function. Note that the
    raw_smp_processor_id() is required in order to avoid calling into
    lockdep before RCU has declared the CPU to be watched for readers.
    
    It's safe to call rcu_cpu_starting() in the arch code as well as later
    in generic code, as explained by Paul:
    
      It uses a per-CPU variable so that RCU pays attention only to the
      first call to rcu_cpu_starting() if there is more than one of them.
      This is even intentional, due to there being a generic
      arch-independent call to rcu_cpu_starting() in
      notify_cpu_starting().
    
      So multiple calls to rcu_cpu_starting() are fine by design.
    
    Fixes: 4d004099a668 ("lockdep: Fix lockdep recursion")
    Signed-off-by: Qian Cai <cai@redhat.com>
    Acked-by: Paul E. McKenney <paulmck@kernel.org>
    [mpe: Add Fixes tag, reword slightly & expand change log]
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Link: https://lore.kernel.org/r/20201028182334.13466-1-cai@redhat.com

commit 0774a6ed294b963dc76df2d8342ab86d030759ec
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Thu Sep 24 11:32:40 2020 +0200

    timekeeping: default GENERIC_CLOCKEVENTS to enabled
    
    Almost all machines use GENERIC_CLOCKEVENTS, so it feels wrong to
    require each one to select that symbol manually.
    
    Instead, enable it whenever CONFIG_LEGACY_TIMER_TICK is disabled as
    a simplification. It should be possible to select both
    GENERIC_CLOCKEVENTS and LEGACY_TIMER_TICK from an architecture now
    and decide at runtime between the two.
    
    For the clockevents arch-support.txt file, this means that additional
    architectures are marked as TODO when they have at least one machine
    that still uses LEGACY_TIMER_TICK, rather than being marked 'ok' when
    at least one machine has been converted. This means that both m68k and
    arm (for riscpc) revert to TODO.
    
    At this point, we could just always enable CONFIG_GENERIC_CLOCKEVENTS
    rather than leaving it off when not needed. I built an m68k
    defconfig kernel (using gcc-10.1.0) and found that this would add
    around 5.5KB in kernel image size:
    
       text    data     bss     dec     hex filename
    3861936 1092236  196656 5150828  4e986c obj-m68k/vmlinux-no-clockevent
    3866201 1093832  196184 5156217  4ead79 obj-m68k/vmlinux-clockevent
    
    On Arm (MACH_RPC), that difference appears to be twice as large,
    around 11KB on top of an 6MB vmlinux.
    
    Reviewed-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Acked-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Tested-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

commit 275e70e4b9dd4d59639e43fb859d0c953a374752
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Thu Sep 24 16:28:53 2020 +0200

    m68k: coldfire: use legacy_timer_tick()
    
    Replace the indirect function calls in the timer code
    with direct calls to the newly added legacy_timer_tick()
    helper for those that have not yet been converted to
    generic clockevents.
    
    This makes the timer code a little more self-contained.
    
    Tested-by: Greg Ungerer <gerg@linux-m68k.org>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

commit b3550164a19d62e515af6cacb5a31f0b2b3f9501
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Thu Sep 24 15:21:43 2020 +0200

    timekeeping: add CONFIG_LEGACY_TIMER_TICK
    
    All platforms that currently do not use generic clockevents roughly call
    the same set of functions in their timer interrupts: xtime_update(),
    update_process_times() and profile_tick(), sometimes in a different
    sequence.
    
    Add a helper function that performs all three of them, to make the
    callers more uniform and simplify the interface.
    
    Reviewed-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

commit c83ed7bb74698493f7d873af08d9a2d4bcf2f410
Author: Eric Dumazet <edumazet@google.com>
Date:   Fri Sep 25 06:38:07 2020 -0700

    bonding: set dev->needed_headroom in bond_setup_by_slave()
    
    [ Upstream commit f32f19339596b214c208c0dba716f4b6cc4f6958 ]
    
    syzbot managed to crash a host by creating a bond
    with a GRE device.
    
    For non Ethernet device, bonding calls bond_setup_by_slave()
    instead of ether_setup(), and unfortunately dev->needed_headroom
    was not copied from the new added member.
    
    [  171.243095] skbuff: skb_under_panic: text:ffffffffa184b9ea len:116 put:20 head:ffff883f84012dc0 data:ffff883f84012dbc tail:0x70 end:0xd00 dev:bond0
    [  171.243111] ------------[ cut here ]------------
    [  171.243112] kernel BUG at net/core/skbuff.c:112!
    [  171.243117] invalid opcode: 0000 [#1] SMP KASAN PTI
    [  171.243469] gsmi: Log Shutdown Reason 0x03
    [  171.243505] Call Trace:
    [  171.243506]  <IRQ>
    [  171.243512]  [<ffffffffa171be59>] skb_push+0x49/0x50
    [  171.243516]  [<ffffffffa184b9ea>] ipgre_header+0x2a/0xf0
    [  171.243520]  [<ffffffffa17452d7>] neigh_connected_output+0xb7/0x100
    [  171.243524]  [<ffffffffa186f1d3>] ip6_finish_output2+0x383/0x490
    [  171.243528]  [<ffffffffa186ede2>] __ip6_finish_output+0xa2/0x110
    [  171.243531]  [<ffffffffa186acbc>] ip6_finish_output+0x2c/0xa0
    [  171.243534]  [<ffffffffa186abe9>] ip6_output+0x69/0x110
    [  171.243537]  [<ffffffffa186ac90>] ? ip6_output+0x110/0x110
    [  171.243541]  [<ffffffffa189d952>] mld_sendpack+0x1b2/0x2d0
    [  171.243544]  [<ffffffffa189d290>] ? mld_send_report+0xf0/0xf0
    [  171.243548]  [<ffffffffa189c797>] mld_ifc_timer_expire+0x2d7/0x3b0
    [  171.243551]  [<ffffffffa189c4c0>] ? mld_gq_timer_expire+0x50/0x50
    [  171.243556]  [<ffffffffa0fea270>] call_timer_fn+0x30/0x130
    [  171.243559]  [<ffffffffa0fea17c>] expire_timers+0x4c/0x110
    [  171.243563]  [<ffffffffa0fea0e3>] __run_timers+0x213/0x260
    [  171.243566]  [<ffffffffa0fecb7d>] ? ktime_get+0x3d/0xa0
    [  171.243570]  [<ffffffffa0ff9c4e>] ? clockevents_program_event+0x7e/0xe0
    [  171.243574]  [<ffffffffa0f7e5d5>] ? sched_clock_cpu+0x15/0x190
    [  171.243577]  [<ffffffffa0fe973d>] run_timer_softirq+0x1d/0x40
    [  171.243581]  [<ffffffffa1c00152>] __do_softirq+0x152/0x2f0
    [  171.243585]  [<ffffffffa0f44e1f>] irq_exit+0x9f/0xb0
    [  171.243588]  [<ffffffffa1a02e1d>] smp_apic_timer_interrupt+0xfd/0x1a0
    [  171.243591]  [<ffffffffa1a01ea6>] apic_timer_interrupt+0x86/0x90
    
    Fixes: f5184d267c1a ("net: Allow netdevices to specify needed head/tailroom")
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Reported-by: syzbot <syzkaller@googlegroups.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 8d103b1f9ce52d06e4db3c829e1d49756936ec43
Author: Eric Dumazet <edumazet@google.com>
Date:   Fri Sep 25 06:38:07 2020 -0700

    bonding: set dev->needed_headroom in bond_setup_by_slave()
    
    [ Upstream commit f32f19339596b214c208c0dba716f4b6cc4f6958 ]
    
    syzbot managed to crash a host by creating a bond
    with a GRE device.
    
    For non Ethernet device, bonding calls bond_setup_by_slave()
    instead of ether_setup(), and unfortunately dev->needed_headroom
    was not copied from the new added member.
    
    [  171.243095] skbuff: skb_under_panic: text:ffffffffa184b9ea len:116 put:20 head:ffff883f84012dc0 data:ffff883f84012dbc tail:0x70 end:0xd00 dev:bond0
    [  171.243111] ------------[ cut here ]------------
    [  171.243112] kernel BUG at net/core/skbuff.c:112!
    [  171.243117] invalid opcode: 0000 [#1] SMP KASAN PTI
    [  171.243469] gsmi: Log Shutdown Reason 0x03
    [  171.243505] Call Trace:
    [  171.243506]  <IRQ>
    [  171.243512]  [<ffffffffa171be59>] skb_push+0x49/0x50
    [  171.243516]  [<ffffffffa184b9ea>] ipgre_header+0x2a/0xf0
    [  171.243520]  [<ffffffffa17452d7>] neigh_connected_output+0xb7/0x100
    [  171.243524]  [<ffffffffa186f1d3>] ip6_finish_output2+0x383/0x490
    [  171.243528]  [<ffffffffa186ede2>] __ip6_finish_output+0xa2/0x110
    [  171.243531]  [<ffffffffa186acbc>] ip6_finish_output+0x2c/0xa0
    [  171.243534]  [<ffffffffa186abe9>] ip6_output+0x69/0x110
    [  171.243537]  [<ffffffffa186ac90>] ? ip6_output+0x110/0x110
    [  171.243541]  [<ffffffffa189d952>] mld_sendpack+0x1b2/0x2d0
    [  171.243544]  [<ffffffffa189d290>] ? mld_send_report+0xf0/0xf0
    [  171.243548]  [<ffffffffa189c797>] mld_ifc_timer_expire+0x2d7/0x3b0
    [  171.243551]  [<ffffffffa189c4c0>] ? mld_gq_timer_expire+0x50/0x50
    [  171.243556]  [<ffffffffa0fea270>] call_timer_fn+0x30/0x130
    [  171.243559]  [<ffffffffa0fea17c>] expire_timers+0x4c/0x110
    [  171.243563]  [<ffffffffa0fea0e3>] __run_timers+0x213/0x260
    [  171.243566]  [<ffffffffa0fecb7d>] ? ktime_get+0x3d/0xa0
    [  171.243570]  [<ffffffffa0ff9c4e>] ? clockevents_program_event+0x7e/0xe0
    [  171.243574]  [<ffffffffa0f7e5d5>] ? sched_clock_cpu+0x15/0x190
    [  171.243577]  [<ffffffffa0fe973d>] run_timer_softirq+0x1d/0x40
    [  171.243581]  [<ffffffffa1c00152>] __do_softirq+0x152/0x2f0
    [  171.243585]  [<ffffffffa0f44e1f>] irq_exit+0x9f/0xb0
    [  171.243588]  [<ffffffffa1a02e1d>] smp_apic_timer_interrupt+0xfd/0x1a0
    [  171.243591]  [<ffffffffa1a01ea6>] apic_timer_interrupt+0x86/0x90
    
    Fixes: f5184d267c1a ("net: Allow netdevices to specify needed head/tailroom")
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Reported-by: syzbot <syzkaller@googlegroups.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 3f396a6be34ab71d1d6bd935ad1b787800781849
Author: Eric Dumazet <edumazet@google.com>
Date:   Fri Sep 25 06:38:07 2020 -0700

    bonding: set dev->needed_headroom in bond_setup_by_slave()
    
    [ Upstream commit f32f19339596b214c208c0dba716f4b6cc4f6958 ]
    
    syzbot managed to crash a host by creating a bond
    with a GRE device.
    
    For non Ethernet device, bonding calls bond_setup_by_slave()
    instead of ether_setup(), and unfortunately dev->needed_headroom
    was not copied from the new added member.
    
    [  171.243095] skbuff: skb_under_panic: text:ffffffffa184b9ea len:116 put:20 head:ffff883f84012dc0 data:ffff883f84012dbc tail:0x70 end:0xd00 dev:bond0
    [  171.243111] ------------[ cut here ]------------
    [  171.243112] kernel BUG at net/core/skbuff.c:112!
    [  171.243117] invalid opcode: 0000 [#1] SMP KASAN PTI
    [  171.243469] gsmi: Log Shutdown Reason 0x03
    [  171.243505] Call Trace:
    [  171.243506]  <IRQ>
    [  171.243512]  [<ffffffffa171be59>] skb_push+0x49/0x50
    [  171.243516]  [<ffffffffa184b9ea>] ipgre_header+0x2a/0xf0
    [  171.243520]  [<ffffffffa17452d7>] neigh_connected_output+0xb7/0x100
    [  171.243524]  [<ffffffffa186f1d3>] ip6_finish_output2+0x383/0x490
    [  171.243528]  [<ffffffffa186ede2>] __ip6_finish_output+0xa2/0x110
    [  171.243531]  [<ffffffffa186acbc>] ip6_finish_output+0x2c/0xa0
    [  171.243534]  [<ffffffffa186abe9>] ip6_output+0x69/0x110
    [  171.243537]  [<ffffffffa186ac90>] ? ip6_output+0x110/0x110
    [  171.243541]  [<ffffffffa189d952>] mld_sendpack+0x1b2/0x2d0
    [  171.243544]  [<ffffffffa189d290>] ? mld_send_report+0xf0/0xf0
    [  171.243548]  [<ffffffffa189c797>] mld_ifc_timer_expire+0x2d7/0x3b0
    [  171.243551]  [<ffffffffa189c4c0>] ? mld_gq_timer_expire+0x50/0x50
    [  171.243556]  [<ffffffffa0fea270>] call_timer_fn+0x30/0x130
    [  171.243559]  [<ffffffffa0fea17c>] expire_timers+0x4c/0x110
    [  171.243563]  [<ffffffffa0fea0e3>] __run_timers+0x213/0x260
    [  171.243566]  [<ffffffffa0fecb7d>] ? ktime_get+0x3d/0xa0
    [  171.243570]  [<ffffffffa0ff9c4e>] ? clockevents_program_event+0x7e/0xe0
    [  171.243574]  [<ffffffffa0f7e5d5>] ? sched_clock_cpu+0x15/0x190
    [  171.243577]  [<ffffffffa0fe973d>] run_timer_softirq+0x1d/0x40
    [  171.243581]  [<ffffffffa1c00152>] __do_softirq+0x152/0x2f0
    [  171.243585]  [<ffffffffa0f44e1f>] irq_exit+0x9f/0xb0
    [  171.243588]  [<ffffffffa1a02e1d>] smp_apic_timer_interrupt+0xfd/0x1a0
    [  171.243591]  [<ffffffffa1a01ea6>] apic_timer_interrupt+0x86/0x90
    
    Fixes: f5184d267c1a ("net: Allow netdevices to specify needed head/tailroom")
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Reported-by: syzbot <syzkaller@googlegroups.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 1ee2fd6238c50ba8705d450d5ff99dc0dfafd1b7
Author: Eric Dumazet <edumazet@google.com>
Date:   Fri Sep 25 06:38:07 2020 -0700

    bonding: set dev->needed_headroom in bond_setup_by_slave()
    
    [ Upstream commit f32f19339596b214c208c0dba716f4b6cc4f6958 ]
    
    syzbot managed to crash a host by creating a bond
    with a GRE device.
    
    For non Ethernet device, bonding calls bond_setup_by_slave()
    instead of ether_setup(), and unfortunately dev->needed_headroom
    was not copied from the new added member.
    
    [  171.243095] skbuff: skb_under_panic: text:ffffffffa184b9ea len:116 put:20 head:ffff883f84012dc0 data:ffff883f84012dbc tail:0x70 end:0xd00 dev:bond0
    [  171.243111] ------------[ cut here ]------------
    [  171.243112] kernel BUG at net/core/skbuff.c:112!
    [  171.243117] invalid opcode: 0000 [#1] SMP KASAN PTI
    [  171.243469] gsmi: Log Shutdown Reason 0x03
    [  171.243505] Call Trace:
    [  171.243506]  <IRQ>
    [  171.243512]  [<ffffffffa171be59>] skb_push+0x49/0x50
    [  171.243516]  [<ffffffffa184b9ea>] ipgre_header+0x2a/0xf0
    [  171.243520]  [<ffffffffa17452d7>] neigh_connected_output+0xb7/0x100
    [  171.243524]  [<ffffffffa186f1d3>] ip6_finish_output2+0x383/0x490
    [  171.243528]  [<ffffffffa186ede2>] __ip6_finish_output+0xa2/0x110
    [  171.243531]  [<ffffffffa186acbc>] ip6_finish_output+0x2c/0xa0
    [  171.243534]  [<ffffffffa186abe9>] ip6_output+0x69/0x110
    [  171.243537]  [<ffffffffa186ac90>] ? ip6_output+0x110/0x110
    [  171.243541]  [<ffffffffa189d952>] mld_sendpack+0x1b2/0x2d0
    [  171.243544]  [<ffffffffa189d290>] ? mld_send_report+0xf0/0xf0
    [  171.243548]  [<ffffffffa189c797>] mld_ifc_timer_expire+0x2d7/0x3b0
    [  171.243551]  [<ffffffffa189c4c0>] ? mld_gq_timer_expire+0x50/0x50
    [  171.243556]  [<ffffffffa0fea270>] call_timer_fn+0x30/0x130
    [  171.243559]  [<ffffffffa0fea17c>] expire_timers+0x4c/0x110
    [  171.243563]  [<ffffffffa0fea0e3>] __run_timers+0x213/0x260
    [  171.243566]  [<ffffffffa0fecb7d>] ? ktime_get+0x3d/0xa0
    [  171.243570]  [<ffffffffa0ff9c4e>] ? clockevents_program_event+0x7e/0xe0
    [  171.243574]  [<ffffffffa0f7e5d5>] ? sched_clock_cpu+0x15/0x190
    [  171.243577]  [<ffffffffa0fe973d>] run_timer_softirq+0x1d/0x40
    [  171.243581]  [<ffffffffa1c00152>] __do_softirq+0x152/0x2f0
    [  171.243585]  [<ffffffffa0f44e1f>] irq_exit+0x9f/0xb0
    [  171.243588]  [<ffffffffa1a02e1d>] smp_apic_timer_interrupt+0xfd/0x1a0
    [  171.243591]  [<ffffffffa1a01ea6>] apic_timer_interrupt+0x86/0x90
    
    Fixes: f5184d267c1a ("net: Allow netdevices to specify needed head/tailroom")
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Reported-by: syzbot <syzkaller@googlegroups.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit dbda849d1af6a0b1fa212df8d3db202ef157500c
Author: Eric Dumazet <edumazet@google.com>
Date:   Fri Sep 25 06:38:07 2020 -0700

    bonding: set dev->needed_headroom in bond_setup_by_slave()
    
    [ Upstream commit f32f19339596b214c208c0dba716f4b6cc4f6958 ]
    
    syzbot managed to crash a host by creating a bond
    with a GRE device.
    
    For non Ethernet device, bonding calls bond_setup_by_slave()
    instead of ether_setup(), and unfortunately dev->needed_headroom
    was not copied from the new added member.
    
    [  171.243095] skbuff: skb_under_panic: text:ffffffffa184b9ea len:116 put:20 head:ffff883f84012dc0 data:ffff883f84012dbc tail:0x70 end:0xd00 dev:bond0
    [  171.243111] ------------[ cut here ]------------
    [  171.243112] kernel BUG at net/core/skbuff.c:112!
    [  171.243117] invalid opcode: 0000 [#1] SMP KASAN PTI
    [  171.243469] gsmi: Log Shutdown Reason 0x03
    [  171.243505] Call Trace:
    [  171.243506]  <IRQ>
    [  171.243512]  [<ffffffffa171be59>] skb_push+0x49/0x50
    [  171.243516]  [<ffffffffa184b9ea>] ipgre_header+0x2a/0xf0
    [  171.243520]  [<ffffffffa17452d7>] neigh_connected_output+0xb7/0x100
    [  171.243524]  [<ffffffffa186f1d3>] ip6_finish_output2+0x383/0x490
    [  171.243528]  [<ffffffffa186ede2>] __ip6_finish_output+0xa2/0x110
    [  171.243531]  [<ffffffffa186acbc>] ip6_finish_output+0x2c/0xa0
    [  171.243534]  [<ffffffffa186abe9>] ip6_output+0x69/0x110
    [  171.243537]  [<ffffffffa186ac90>] ? ip6_output+0x110/0x110
    [  171.243541]  [<ffffffffa189d952>] mld_sendpack+0x1b2/0x2d0
    [  171.243544]  [<ffffffffa189d290>] ? mld_send_report+0xf0/0xf0
    [  171.243548]  [<ffffffffa189c797>] mld_ifc_timer_expire+0x2d7/0x3b0
    [  171.243551]  [<ffffffffa189c4c0>] ? mld_gq_timer_expire+0x50/0x50
    [  171.243556]  [<ffffffffa0fea270>] call_timer_fn+0x30/0x130
    [  171.243559]  [<ffffffffa0fea17c>] expire_timers+0x4c/0x110
    [  171.243563]  [<ffffffffa0fea0e3>] __run_timers+0x213/0x260
    [  171.243566]  [<ffffffffa0fecb7d>] ? ktime_get+0x3d/0xa0
    [  171.243570]  [<ffffffffa0ff9c4e>] ? clockevents_program_event+0x7e/0xe0
    [  171.243574]  [<ffffffffa0f7e5d5>] ? sched_clock_cpu+0x15/0x190
    [  171.243577]  [<ffffffffa0fe973d>] run_timer_softirq+0x1d/0x40
    [  171.243581]  [<ffffffffa1c00152>] __do_softirq+0x152/0x2f0
    [  171.243585]  [<ffffffffa0f44e1f>] irq_exit+0x9f/0xb0
    [  171.243588]  [<ffffffffa1a02e1d>] smp_apic_timer_interrupt+0xfd/0x1a0
    [  171.243591]  [<ffffffffa1a01ea6>] apic_timer_interrupt+0x86/0x90
    
    Fixes: f5184d267c1a ("net: Allow netdevices to specify needed head/tailroom")
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Reported-by: syzbot <syzkaller@googlegroups.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit aaf8fe791e1618a171bd36c39225e3ec8e478abb
Author: Eric Dumazet <edumazet@google.com>
Date:   Fri Sep 25 06:38:07 2020 -0700

    bonding: set dev->needed_headroom in bond_setup_by_slave()
    
    [ Upstream commit f32f19339596b214c208c0dba716f4b6cc4f6958 ]
    
    syzbot managed to crash a host by creating a bond
    with a GRE device.
    
    For non Ethernet device, bonding calls bond_setup_by_slave()
    instead of ether_setup(), and unfortunately dev->needed_headroom
    was not copied from the new added member.
    
    [  171.243095] skbuff: skb_under_panic: text:ffffffffa184b9ea len:116 put:20 head:ffff883f84012dc0 data:ffff883f84012dbc tail:0x70 end:0xd00 dev:bond0
    [  171.243111] ------------[ cut here ]------------
    [  171.243112] kernel BUG at net/core/skbuff.c:112!
    [  171.243117] invalid opcode: 0000 [#1] SMP KASAN PTI
    [  171.243469] gsmi: Log Shutdown Reason 0x03
    [  171.243505] Call Trace:
    [  171.243506]  <IRQ>
    [  171.243512]  [<ffffffffa171be59>] skb_push+0x49/0x50
    [  171.243516]  [<ffffffffa184b9ea>] ipgre_header+0x2a/0xf0
    [  171.243520]  [<ffffffffa17452d7>] neigh_connected_output+0xb7/0x100
    [  171.243524]  [<ffffffffa186f1d3>] ip6_finish_output2+0x383/0x490
    [  171.243528]  [<ffffffffa186ede2>] __ip6_finish_output+0xa2/0x110
    [  171.243531]  [<ffffffffa186acbc>] ip6_finish_output+0x2c/0xa0
    [  171.243534]  [<ffffffffa186abe9>] ip6_output+0x69/0x110
    [  171.243537]  [<ffffffffa186ac90>] ? ip6_output+0x110/0x110
    [  171.243541]  [<ffffffffa189d952>] mld_sendpack+0x1b2/0x2d0
    [  171.243544]  [<ffffffffa189d290>] ? mld_send_report+0xf0/0xf0
    [  171.243548]  [<ffffffffa189c797>] mld_ifc_timer_expire+0x2d7/0x3b0
    [  171.243551]  [<ffffffffa189c4c0>] ? mld_gq_timer_expire+0x50/0x50
    [  171.243556]  [<ffffffffa0fea270>] call_timer_fn+0x30/0x130
    [  171.243559]  [<ffffffffa0fea17c>] expire_timers+0x4c/0x110
    [  171.243563]  [<ffffffffa0fea0e3>] __run_timers+0x213/0x260
    [  171.243566]  [<ffffffffa0fecb7d>] ? ktime_get+0x3d/0xa0
    [  171.243570]  [<ffffffffa0ff9c4e>] ? clockevents_program_event+0x7e/0xe0
    [  171.243574]  [<ffffffffa0f7e5d5>] ? sched_clock_cpu+0x15/0x190
    [  171.243577]  [<ffffffffa0fe973d>] run_timer_softirq+0x1d/0x40
    [  171.243581]  [<ffffffffa1c00152>] __do_softirq+0x152/0x2f0
    [  171.243585]  [<ffffffffa0f44e1f>] irq_exit+0x9f/0xb0
    [  171.243588]  [<ffffffffa1a02e1d>] smp_apic_timer_interrupt+0xfd/0x1a0
    [  171.243591]  [<ffffffffa1a01ea6>] apic_timer_interrupt+0x86/0x90
    
    Fixes: f5184d267c1a ("net: Allow netdevices to specify needed head/tailroom")
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Reported-by: syzbot <syzkaller@googlegroups.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit ba25f0570b53267e8b9dc1f2e185caa3d3bc7633
Merge: d042035eaf5f a7b6c0feda15
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Sep 27 12:11:35 2020 -0700

    Merge tag 'timers-urgent-2020-09-27' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer updates from Thomas Gleixner:
     "A set of clocksource/clockevents updates:
    
       - Reset the TI/DM timer before enabling it instead of doing it the
         other way round.
    
       - Initialize the reload value for the GX6605s timer correctly so the
         hardware counter starts at 0 again after overrun.
    
       - Make error return value negative in the h8300 timer init function"
    
    * tag 'timers-urgent-2020-09-27' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      clocksource/drivers/timer-gx6605s: Fixup counter reload
      clocksource/drivers/timer-ti-dm: Do reset before enable
      clocksource/drivers/h8300_timer8: Fix wrong return value in h8300_8timer_init()

commit f32f19339596b214c208c0dba716f4b6cc4f6958
Author: Eric Dumazet <edumazet@google.com>
Date:   Fri Sep 25 06:38:07 2020 -0700

    bonding: set dev->needed_headroom in bond_setup_by_slave()
    
    syzbot managed to crash a host by creating a bond
    with a GRE device.
    
    For non Ethernet device, bonding calls bond_setup_by_slave()
    instead of ether_setup(), and unfortunately dev->needed_headroom
    was not copied from the new added member.
    
    [  171.243095] skbuff: skb_under_panic: text:ffffffffa184b9ea len:116 put:20 head:ffff883f84012dc0 data:ffff883f84012dbc tail:0x70 end:0xd00 dev:bond0
    [  171.243111] ------------[ cut here ]------------
    [  171.243112] kernel BUG at net/core/skbuff.c:112!
    [  171.243117] invalid opcode: 0000 [#1] SMP KASAN PTI
    [  171.243469] gsmi: Log Shutdown Reason 0x03
    [  171.243505] Call Trace:
    [  171.243506]  <IRQ>
    [  171.243512]  [<ffffffffa171be59>] skb_push+0x49/0x50
    [  171.243516]  [<ffffffffa184b9ea>] ipgre_header+0x2a/0xf0
    [  171.243520]  [<ffffffffa17452d7>] neigh_connected_output+0xb7/0x100
    [  171.243524]  [<ffffffffa186f1d3>] ip6_finish_output2+0x383/0x490
    [  171.243528]  [<ffffffffa186ede2>] __ip6_finish_output+0xa2/0x110
    [  171.243531]  [<ffffffffa186acbc>] ip6_finish_output+0x2c/0xa0
    [  171.243534]  [<ffffffffa186abe9>] ip6_output+0x69/0x110
    [  171.243537]  [<ffffffffa186ac90>] ? ip6_output+0x110/0x110
    [  171.243541]  [<ffffffffa189d952>] mld_sendpack+0x1b2/0x2d0
    [  171.243544]  [<ffffffffa189d290>] ? mld_send_report+0xf0/0xf0
    [  171.243548]  [<ffffffffa189c797>] mld_ifc_timer_expire+0x2d7/0x3b0
    [  171.243551]  [<ffffffffa189c4c0>] ? mld_gq_timer_expire+0x50/0x50
    [  171.243556]  [<ffffffffa0fea270>] call_timer_fn+0x30/0x130
    [  171.243559]  [<ffffffffa0fea17c>] expire_timers+0x4c/0x110
    [  171.243563]  [<ffffffffa0fea0e3>] __run_timers+0x213/0x260
    [  171.243566]  [<ffffffffa0fecb7d>] ? ktime_get+0x3d/0xa0
    [  171.243570]  [<ffffffffa0ff9c4e>] ? clockevents_program_event+0x7e/0xe0
    [  171.243574]  [<ffffffffa0f7e5d5>] ? sched_clock_cpu+0x15/0x190
    [  171.243577]  [<ffffffffa0fe973d>] run_timer_softirq+0x1d/0x40
    [  171.243581]  [<ffffffffa1c00152>] __do_softirq+0x152/0x2f0
    [  171.243585]  [<ffffffffa0f44e1f>] irq_exit+0x9f/0xb0
    [  171.243588]  [<ffffffffa1a02e1d>] smp_apic_timer_interrupt+0xfd/0x1a0
    [  171.243591]  [<ffffffffa1a01ea6>] apic_timer_interrupt+0x86/0x90
    
    Fixes: f5184d267c1a ("net: Allow netdevices to specify needed head/tailroom")
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Reported-by: syzbot <syzkaller@googlegroups.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 975434f8b24a55af31daa4634972890c061a0a0c
Author: Zhen Lei <thunder.leizhen@huawei.com>
Date:   Fri Sep 18 21:22:31 2020 +0800

    clocksource/drivers/sp804: Delete the leading "__" of some functions
    
    Delete the leading "__" of __sp804_clocksource_and_sched_clock_init() and
    __sp804_clockevents_init(), make it looks a little more comfortable.
    
    Signed-off-by: Zhen Lei <thunder.leizhen@huawei.com>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Link: https://lore.kernel.org/r/20200918132237.3552-4-thunder.leizhen@huawei.com

commit ef1d6a20e06397f4a28f23524cdb4611fd629063
Author: Alexandre Belloni <alexandre.belloni@bootlin.com>
Date:   Sat Jul 11 01:08:11 2020 +0200

    clocksource/drivers/timer-atmel-tcb: Stop using the 32kHz for clockevents
    
    Stop using the slow clock as the clock source for 32 bit counters because
    even at 10MHz, they are able to handle delays up to two minutes. This
    provides a way better resolution.
    
    Signed-off-by: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Link: https://lore.kernel.org/r/20200710230813.1005150-8-alexandre.belloni@bootlin.com

commit 4f7e94547c0e82af77c94133723daa64b54b68c1
Author: Serge Semin <Sergey.Semin@baikalelectronics.ru>
Date:   Thu May 21 23:48:15 2020 +0300

    clocksource: dw_apb_timer_of: Fix missing clockevent timers
    
    [ Upstream commit 6d2e16a3181bafb77b535095c39ad1c8b9558c8c ]
    
    Commit 100214889973 ("clocksource: dw_apb_timer_of: use
    clocksource_of_init") replaced a publicly available driver
    initialization method with one called by the timer_probe() method
    available after CLKSRC_OF. In current implementation it traverses
    all the timers available in the system and calls their initialization
    methods if corresponding devices were either in dtb or in acpi. But
    if before the commit any number of available timers would be installed
    as clockevent and clocksource devices, after that there would be at most
    two. The rest are just ignored since default case branch doesn't do
    anything. I don't see a reason of such behaviour, neither the commit
    message explains it. Moreover this might be wrong if on some platforms
    these timers might be used for different purpose, as virtually CPU-local
    clockevent timers and as an independent broadcast timer. So in order
    to keep the compatibility with the platforms where the order of the
    timers detection has some meaning, lets add the secondly discovered
    timer to be of clocksource/sched_clock type, while the very first and
    the others would provide the clockevents service.
    
    Fixes: 100214889973 ("clocksource: dw_apb_timer_of: use clocksource_of_init")
    Signed-off-by: Serge Semin <Sergey.Semin@baikalelectronics.ru>
    Cc: Alexey Malahov <Alexey.Malahov@baikalelectronics.ru>
    Cc: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
    Cc: Paul Burton <paulburton@kernel.org>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Alessandro Zummo <a.zummo@towertech.it>
    Cc: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Rob Herring <robh+dt@kernel.org>
    Cc: linux-mips@vger.kernel.org
    Cc: linux-rtc@vger.kernel.org
    Cc: devicetree@vger.kernel.org
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Link: https://lore.kernel.org/r/20200521204818.25436-7-Sergey.Semin@baikalelectronics.ru
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit bffe2c8e2303dfa1aa409745963c626ecb78ec89
Author: Serge Semin <Sergey.Semin@baikalelectronics.ru>
Date:   Thu May 21 23:48:15 2020 +0300

    clocksource: dw_apb_timer_of: Fix missing clockevent timers
    
    [ Upstream commit 6d2e16a3181bafb77b535095c39ad1c8b9558c8c ]
    
    Commit 100214889973 ("clocksource: dw_apb_timer_of: use
    clocksource_of_init") replaced a publicly available driver
    initialization method with one called by the timer_probe() method
    available after CLKSRC_OF. In current implementation it traverses
    all the timers available in the system and calls their initialization
    methods if corresponding devices were either in dtb or in acpi. But
    if before the commit any number of available timers would be installed
    as clockevent and clocksource devices, after that there would be at most
    two. The rest are just ignored since default case branch doesn't do
    anything. I don't see a reason of such behaviour, neither the commit
    message explains it. Moreover this might be wrong if on some platforms
    these timers might be used for different purpose, as virtually CPU-local
    clockevent timers and as an independent broadcast timer. So in order
    to keep the compatibility with the platforms where the order of the
    timers detection has some meaning, lets add the secondly discovered
    timer to be of clocksource/sched_clock type, while the very first and
    the others would provide the clockevents service.
    
    Fixes: 100214889973 ("clocksource: dw_apb_timer_of: use clocksource_of_init")
    Signed-off-by: Serge Semin <Sergey.Semin@baikalelectronics.ru>
    Cc: Alexey Malahov <Alexey.Malahov@baikalelectronics.ru>
    Cc: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
    Cc: Paul Burton <paulburton@kernel.org>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Alessandro Zummo <a.zummo@towertech.it>
    Cc: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Rob Herring <robh+dt@kernel.org>
    Cc: linux-mips@vger.kernel.org
    Cc: linux-rtc@vger.kernel.org
    Cc: devicetree@vger.kernel.org
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Link: https://lore.kernel.org/r/20200521204818.25436-7-Sergey.Semin@baikalelectronics.ru
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit ffa7a58fb048e577b358e521369bdc2cd354f8b6
Author: Serge Semin <Sergey.Semin@baikalelectronics.ru>
Date:   Thu May 21 23:48:15 2020 +0300

    clocksource: dw_apb_timer_of: Fix missing clockevent timers
    
    [ Upstream commit 6d2e16a3181bafb77b535095c39ad1c8b9558c8c ]
    
    Commit 100214889973 ("clocksource: dw_apb_timer_of: use
    clocksource_of_init") replaced a publicly available driver
    initialization method with one called by the timer_probe() method
    available after CLKSRC_OF. In current implementation it traverses
    all the timers available in the system and calls their initialization
    methods if corresponding devices were either in dtb or in acpi. But
    if before the commit any number of available timers would be installed
    as clockevent and clocksource devices, after that there would be at most
    two. The rest are just ignored since default case branch doesn't do
    anything. I don't see a reason of such behaviour, neither the commit
    message explains it. Moreover this might be wrong if on some platforms
    these timers might be used for different purpose, as virtually CPU-local
    clockevent timers and as an independent broadcast timer. So in order
    to keep the compatibility with the platforms where the order of the
    timers detection has some meaning, lets add the secondly discovered
    timer to be of clocksource/sched_clock type, while the very first and
    the others would provide the clockevents service.
    
    Fixes: 100214889973 ("clocksource: dw_apb_timer_of: use clocksource_of_init")
    Signed-off-by: Serge Semin <Sergey.Semin@baikalelectronics.ru>
    Cc: Alexey Malahov <Alexey.Malahov@baikalelectronics.ru>
    Cc: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
    Cc: Paul Burton <paulburton@kernel.org>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Alessandro Zummo <a.zummo@towertech.it>
    Cc: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Rob Herring <robh+dt@kernel.org>
    Cc: linux-mips@vger.kernel.org
    Cc: linux-rtc@vger.kernel.org
    Cc: devicetree@vger.kernel.org
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Link: https://lore.kernel.org/r/20200521204818.25436-7-Sergey.Semin@baikalelectronics.ru
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit a49fdcefa920293883877ed7c2029e242823ace7
Author: Serge Semin <Sergey.Semin@baikalelectronics.ru>
Date:   Thu May 21 23:48:15 2020 +0300

    clocksource: dw_apb_timer_of: Fix missing clockevent timers
    
    [ Upstream commit 6d2e16a3181bafb77b535095c39ad1c8b9558c8c ]
    
    Commit 100214889973 ("clocksource: dw_apb_timer_of: use
    clocksource_of_init") replaced a publicly available driver
    initialization method with one called by the timer_probe() method
    available after CLKSRC_OF. In current implementation it traverses
    all the timers available in the system and calls their initialization
    methods if corresponding devices were either in dtb or in acpi. But
    if before the commit any number of available timers would be installed
    as clockevent and clocksource devices, after that there would be at most
    two. The rest are just ignored since default case branch doesn't do
    anything. I don't see a reason of such behaviour, neither the commit
    message explains it. Moreover this might be wrong if on some platforms
    these timers might be used for different purpose, as virtually CPU-local
    clockevent timers and as an independent broadcast timer. So in order
    to keep the compatibility with the platforms where the order of the
    timers detection has some meaning, lets add the secondly discovered
    timer to be of clocksource/sched_clock type, while the very first and
    the others would provide the clockevents service.
    
    Fixes: 100214889973 ("clocksource: dw_apb_timer_of: use clocksource_of_init")
    Signed-off-by: Serge Semin <Sergey.Semin@baikalelectronics.ru>
    Cc: Alexey Malahov <Alexey.Malahov@baikalelectronics.ru>
    Cc: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
    Cc: Paul Burton <paulburton@kernel.org>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Alessandro Zummo <a.zummo@towertech.it>
    Cc: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Rob Herring <robh+dt@kernel.org>
    Cc: linux-mips@vger.kernel.org
    Cc: linux-rtc@vger.kernel.org
    Cc: devicetree@vger.kernel.org
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Link: https://lore.kernel.org/r/20200521204818.25436-7-Sergey.Semin@baikalelectronics.ru
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit ec718fc8acdbba62351c2988dfb4355e73df8b3e
Author: Serge Semin <Sergey.Semin@baikalelectronics.ru>
Date:   Thu May 21 23:48:15 2020 +0300

    clocksource: dw_apb_timer_of: Fix missing clockevent timers
    
    [ Upstream commit 6d2e16a3181bafb77b535095c39ad1c8b9558c8c ]
    
    Commit 100214889973 ("clocksource: dw_apb_timer_of: use
    clocksource_of_init") replaced a publicly available driver
    initialization method with one called by the timer_probe() method
    available after CLKSRC_OF. In current implementation it traverses
    all the timers available in the system and calls their initialization
    methods if corresponding devices were either in dtb or in acpi. But
    if before the commit any number of available timers would be installed
    as clockevent and clocksource devices, after that there would be at most
    two. The rest are just ignored since default case branch doesn't do
    anything. I don't see a reason of such behaviour, neither the commit
    message explains it. Moreover this might be wrong if on some platforms
    these timers might be used for different purpose, as virtually CPU-local
    clockevent timers and as an independent broadcast timer. So in order
    to keep the compatibility with the platforms where the order of the
    timers detection has some meaning, lets add the secondly discovered
    timer to be of clocksource/sched_clock type, while the very first and
    the others would provide the clockevents service.
    
    Fixes: 100214889973 ("clocksource: dw_apb_timer_of: use clocksource_of_init")
    Signed-off-by: Serge Semin <Sergey.Semin@baikalelectronics.ru>
    Cc: Alexey Malahov <Alexey.Malahov@baikalelectronics.ru>
    Cc: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
    Cc: Paul Burton <paulburton@kernel.org>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Alessandro Zummo <a.zummo@towertech.it>
    Cc: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Rob Herring <robh+dt@kernel.org>
    Cc: linux-mips@vger.kernel.org
    Cc: linux-rtc@vger.kernel.org
    Cc: devicetree@vger.kernel.org
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Link: https://lore.kernel.org/r/20200521204818.25436-7-Sergey.Semin@baikalelectronics.ru
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit ea4f019105a00186f1770eeb5d0bd280cc6c7498
Author: Serge Semin <Sergey.Semin@baikalelectronics.ru>
Date:   Thu May 21 23:48:15 2020 +0300

    clocksource: dw_apb_timer_of: Fix missing clockevent timers
    
    [ Upstream commit 6d2e16a3181bafb77b535095c39ad1c8b9558c8c ]
    
    Commit 100214889973 ("clocksource: dw_apb_timer_of: use
    clocksource_of_init") replaced a publicly available driver
    initialization method with one called by the timer_probe() method
    available after CLKSRC_OF. In current implementation it traverses
    all the timers available in the system and calls their initialization
    methods if corresponding devices were either in dtb or in acpi. But
    if before the commit any number of available timers would be installed
    as clockevent and clocksource devices, after that there would be at most
    two. The rest are just ignored since default case branch doesn't do
    anything. I don't see a reason of such behaviour, neither the commit
    message explains it. Moreover this might be wrong if on some platforms
    these timers might be used for different purpose, as virtually CPU-local
    clockevent timers and as an independent broadcast timer. So in order
    to keep the compatibility with the platforms where the order of the
    timers detection has some meaning, lets add the secondly discovered
    timer to be of clocksource/sched_clock type, while the very first and
    the others would provide the clockevents service.
    
    Fixes: 100214889973 ("clocksource: dw_apb_timer_of: use clocksource_of_init")
    Signed-off-by: Serge Semin <Sergey.Semin@baikalelectronics.ru>
    Cc: Alexey Malahov <Alexey.Malahov@baikalelectronics.ru>
    Cc: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
    Cc: Paul Burton <paulburton@kernel.org>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Alessandro Zummo <a.zummo@towertech.it>
    Cc: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Rob Herring <robh+dt@kernel.org>
    Cc: linux-mips@vger.kernel.org
    Cc: linux-rtc@vger.kernel.org
    Cc: devicetree@vger.kernel.org
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Link: https://lore.kernel.org/r/20200521204818.25436-7-Sergey.Semin@baikalelectronics.ru
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 6d2e16a3181bafb77b535095c39ad1c8b9558c8c
Author: Serge Semin <Sergey.Semin@baikalelectronics.ru>
Date:   Thu May 21 23:48:15 2020 +0300

    clocksource: dw_apb_timer_of: Fix missing clockevent timers
    
    Commit 100214889973 ("clocksource: dw_apb_timer_of: use
    clocksource_of_init") replaced a publicly available driver
    initialization method with one called by the timer_probe() method
    available after CLKSRC_OF. In current implementation it traverses
    all the timers available in the system and calls their initialization
    methods if corresponding devices were either in dtb or in acpi. But
    if before the commit any number of available timers would be installed
    as clockevent and clocksource devices, after that there would be at most
    two. The rest are just ignored since default case branch doesn't do
    anything. I don't see a reason of such behaviour, neither the commit
    message explains it. Moreover this might be wrong if on some platforms
    these timers might be used for different purpose, as virtually CPU-local
    clockevent timers and as an independent broadcast timer. So in order
    to keep the compatibility with the platforms where the order of the
    timers detection has some meaning, lets add the secondly discovered
    timer to be of clocksource/sched_clock type, while the very first and
    the others would provide the clockevents service.
    
    Fixes: 100214889973 ("clocksource: dw_apb_timer_of: use clocksource_of_init")
    Signed-off-by: Serge Semin <Sergey.Semin@baikalelectronics.ru>
    Cc: Alexey Malahov <Alexey.Malahov@baikalelectronics.ru>
    Cc: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
    Cc: Paul Burton <paulburton@kernel.org>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Alessandro Zummo <a.zummo@towertech.it>
    Cc: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Rob Herring <robh+dt@kernel.org>
    Cc: linux-mips@vger.kernel.org
    Cc: linux-rtc@vger.kernel.org
    Cc: devicetree@vger.kernel.org
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Link: https://lore.kernel.org/r/20200521204818.25436-7-Sergey.Semin@baikalelectronics.ru

commit 65e0f876405ef4f0ff25eb1c5ff3e9b536d68805
Author: Serge Semin <Sergey.Semin@baikalelectronics.ru>
Date:   Thu May 21 23:48:14 2020 +0300

    clocksource: dw_apb_timer: Affiliate of-based timer with any CPU
    
    Currently any DW APB Timer device detected in OF is bound to CPU #0.
    Doing so is redundant since DW APB Timer isn't CPU-local timer, but as
    having APB interface is normally accessible from any CPU in the system. By
    artificially affiliating the DW timer to the very first CPU we may and in
    our case will make the clockevent subsystem to decline the more performant
    real CPU-local timers selection in favor of in fact non-local and
    accessible over a slow bus - DW APB Timers.
    
    Let's not affiliate the of-detected DW APB Timers to any CPU. By doing so
    the clockevent framework would prefer to select the real CPU-local timer
    instead of DW APB one. Otherwise if there is no other than DW APB device
    for clockevents tracking then it will be selected.
    
    Signed-off-by: Serge Semin <Sergey.Semin@baikalelectronics.ru>
    Cc: Alexey Malahov <Alexey.Malahov@baikalelectronics.ru>
    Cc: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
    Cc: Paul Burton <paulburton@kernel.org>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Alessandro Zummo <a.zummo@towertech.it>
    Cc: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Rob Herring <robh+dt@kernel.org>
    Cc: linux-mips@vger.kernel.org
    Cc: linux-rtc@vger.kernel.org
    Cc: devicetree@vger.kernel.org
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Link: https://lore.kernel.org/r/20200521204818.25436-6-Sergey.Semin@baikalelectronics.ru

commit 21e1a03e1dbed20e03d88aa077163cd6ceaa128f
Author: Serge Semin <Sergey.Semin@baikalelectronics.ru>
Date:   Thu May 21 17:07:24 2020 +0300

    mips: cevt-r4k: Update the r4k-clockevent frequency in sync with CPU
    
    Due to being embedded into the CPU cores MIPS count/compare timer
    frequency is changed together with the CPU clocks alteration.
    In case if frequency really changes the kernel clockevent framework
    must be notified, otherwise the kernel timers won't work correctly.
    Fix this by calling clockevents_update_freq() for each r4k clockevent
    handlers registered per available CPUs.
    
    Traditionally MIPS r4k-clock are clocked with CPU frequency divided by 2.
    But this isn't true for some of the platforms. Due to this we have to save
    the basic CPU frequency, so then use it to scale the initial timer
    frequency (mips_hpt_frequency) and pass the updated value further to the
    clockevent framework.
    
    Signed-off-by: Serge Semin <Sergey.Semin@baikalelectronics.ru>
    Cc: Alexey Malahov <Alexey.Malahov@baikalelectronics.ru>
    Cc: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
    Cc: Paul Burton <paulburton@kernel.org>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Rob Herring <robh+dt@kernel.org>
    Cc: devicetree@vger.kernel.org
    Signed-off-by: Thomas Bogendoerfer <tsbogend@alpha.franken.de>

commit e6d05acd57013114977ec77a131fe79d2f542774
Author: Nathan Chancellor <natechancellor@gmail.com>
Date:   Thu Apr 2 18:31:35 2020 -0700

    remoteproc/omap: Fix set_load call in omap_rproc_request_timer
    
    When building arm allyesconfig:
    
    drivers/remoteproc/omap_remoteproc.c:174:44: error: too many arguments
    to function call, expected 2, have 3
            timer->timer_ops->set_load(timer->odt, 0, 0);
            ~~~~~~~~~~~~~~~~~~~~~~~~~~                ^
    1 error generated.
    
    This is due to commit 02e6d546e3bd ("clocksource/drivers/timer-ti-dm:
    Enable autoreload in set_pwm") in the clockevents tree interacting with
    commit e28edc571925 ("remoteproc/omap: Request a timer(s) for remoteproc
    usage") from the rpmsg tree.
    
    This should have been fixed during the merge of the remoteproc tree
    since it happened after the clockevents tree merge; however, it does not
    look like my email was noticed by either maintainer and I did not pay
    attention when the pull was sent since I was on CC.
    
    Fixes: c6570114316f ("Merge tag 'rproc-v5.7' of git://git.kernel.org/pub/scm/linux/kernel/git/andersson/remoteproc")
    Link: https://lore.kernel.org/lkml/20200327185055.GA22438@ubuntu-m2-xlarge-x86/
    Signed-off-by: Nathan Chancellor <natechancellor@gmail.com>
    Acked-by: Suman Anna <s-anna@ti.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit 6adf50d0371ac22ecc424ee879fa3aed3b3de32e
Author: Bartosz Golaszewski <bgolaszewski@baylibre.com>
Date:   Fri Jan 10 18:16:41 2020 +0100

    clocksource: davinci: only enable clockevents once tim34 is initialized
    
    [ Upstream commit cea931c25104e6bddc42eb067f58193f355dbdd7 ]
    
    The DM365 platform has a strange quirk (only present when using ancient
    u-boot - mainline u-boot v2013.01 and later works fine) where if we
    enable the second half of the timer in periodic mode before we do its
    initialization - the time won't start flowing and we can't boot.
    
    When using more recent u-boot, we can enable the timer, then reinitialize
    it and all works fine.
    
    To work around this issue only enable clockevents once tim34 is
    initialized i.e. move clockevents_config_and_register() below tim34
    initialization.
    
    Signed-off-by: Bartosz Golaszewski <bgolaszewski@baylibre.com>
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 989a495ed9a34bc60a33d8ec9ce00dcade40b36c
Author: Bartosz Golaszewski <bgolaszewski@baylibre.com>
Date:   Fri Jan 10 18:16:41 2020 +0100

    clocksource: davinci: only enable clockevents once tim34 is initialized
    
    [ Upstream commit cea931c25104e6bddc42eb067f58193f355dbdd7 ]
    
    The DM365 platform has a strange quirk (only present when using ancient
    u-boot - mainline u-boot v2013.01 and later works fine) where if we
    enable the second half of the timer in periodic mode before we do its
    initialization - the time won't start flowing and we can't boot.
    
    When using more recent u-boot, we can enable the timer, then reinitialize
    it and all works fine.
    
    To work around this issue only enable clockevents once tim34 is
    initialized i.e. move clockevents_config_and_register() below tim34
    initialization.
    
    Signed-off-by: Bartosz Golaszewski <bgolaszewski@baylibre.com>
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit a832eb203ecd34e486bdde0042cf166e687eb227
Merge: 19d52e94e083 5e06d19694a4
Author: Olof Johansson <olof@lixom.net>
Date:   Mon Jan 27 07:36:40 2020 -0800

    Merge tag 'davinci-for-v5.6/soc' of git://git.kernel.org/pub/scm/linux/kernel/git/nsekhar/linux-davinci into arm/late
    
    DaVinci SoC updates for v5.6 include migrating DM365 SoC to use
    drivers/clocksource based driver for timer. This leads to removal
    of machine specific timer driver.
    
    There are two patches adding missing fixed regulators for audio codecs
    on DM365 and DM644x EVMs.
    
    * tag 'davinci-for-v5.6/soc' of git://git.kernel.org/pub/scm/linux/kernel/git/nsekhar/linux-davinci:
      ARM: davinci: dm644x-evm: Add Fixed regulators needed for tlv320aic33
      ARM: davinci: dm365-evm: Add Fixed regulators needed for tlv320aic3101
      ARM: davinci: remove legacy timer support
      ARM: davinci: dm365: switch to using the clocksource driver
      clocksource: davinci: only enable clockevents once tim34 is initialized
    
    Link: https://lore.kernel.org/r/043eb5b2-a302-4de6-a3e8-8238e49483b1@ti.com/
    Signed-off-by: Olof Johansson <olof@lixom.net>

commit cea931c25104e6bddc42eb067f58193f355dbdd7
Author: Bartosz Golaszewski <bgolaszewski@baylibre.com>
Date:   Fri Jan 10 18:16:41 2020 +0100

    clocksource: davinci: only enable clockevents once tim34 is initialized
    
    The DM365 platform has a strange quirk (only present when using ancient
    u-boot - mainline u-boot v2013.01 and later works fine) where if we
    enable the second half of the timer in periodic mode before we do its
    initialization - the time won't start flowing and we can't boot.
    
    When using more recent u-boot, we can enable the timer, then reinitialize
    it and all works fine.
    
    To work around this issue only enable clockevents once tim34 is
    initialized i.e. move clockevents_config_and_register() below tim34
    initialization.
    
    Signed-off-by: Bartosz Golaszewski <bgolaszewski@baylibre.com>
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

commit cb6a7efdd78d5ad3c3b0e4b567b9d6402a109fda
Author: Balasubramani Vivekanandan <balasubramani_vivekanandan@mentor.com>
Date:   Thu Sep 26 15:51:01 2019 +0200

    tick: broadcast-hrtimer: Fix a race in bc_set_next
    
    commit b9023b91dd020ad7e093baa5122b6968c48cc9e0 upstream.
    
    When a cpu requests broadcasting, before starting the tick broadcast
    hrtimer, bc_set_next() checks if the timer callback (bc_handler) is active
    using hrtimer_try_to_cancel(). But hrtimer_try_to_cancel() does not provide
    the required synchronization when the callback is active on other core.
    
    The callback could have already executed tick_handle_oneshot_broadcast()
    and could have also returned. But still there is a small time window where
    the hrtimer_try_to_cancel() returns -1. In that case bc_set_next() returns
    without doing anything, but the next_event of the tick broadcast clock
    device is already set to a timeout value.
    
    In the race condition diagram below, CPU #1 is running the timer callback
    and CPU #2 is entering idle state and so calls bc_set_next().
    
    In the worst case, the next_event will contain an expiry time, but the
    hrtimer will not be started which happens when the racing callback returns
    HRTIMER_NORESTART. The hrtimer might never recover if all further requests
    from the CPUs to subscribe to tick broadcast have timeout greater than the
    next_event of tick broadcast clock device. This leads to cascading of
    failures and finally noticed as rcu stall warnings
    
    Here is a depiction of the race condition
    
    CPU #1 (Running timer callback)                   CPU #2 (Enter idle
                                                      and subscribe to
                                                      tick broadcast)
    ---------------------                             ---------------------
    
    __run_hrtimer()                                   tick_broadcast_enter()
    
      bc_handler()                                      __tick_broadcast_oneshot_control()
    
        tick_handle_oneshot_broadcast()
    
          raw_spin_lock(&tick_broadcast_lock);
    
          dev->next_event = KTIME_MAX;                  //wait for tick_broadcast_lock
          //next_event for tick broadcast clock
          set to KTIME_MAX since no other cores
          subscribed to tick broadcasting
    
          raw_spin_unlock(&tick_broadcast_lock);
    
        if (dev->next_event == KTIME_MAX)
          return HRTIMER_NORESTART
        // callback function exits without
           restarting the hrtimer                      //tick_broadcast_lock acquired
                                                       raw_spin_lock(&tick_broadcast_lock);
    
                                                       tick_broadcast_set_event()
    
                                                         clockevents_program_event()
    
                                                           dev->next_event = expires;
    
                                                           bc_set_next()
    
                                                             hrtimer_try_to_cancel()
                                                             //returns -1 since the timer
                                                             callback is active. Exits without
                                                             restarting the timer
      cpu_base->running = NULL;
    
    The comment that hrtimer cannot be armed from within the callback is
    wrong. It is fine to start the hrtimer from within the callback. Also it is
    safe to start the hrtimer from the enter/exit idle code while the broadcast
    handler is active. The enter/exit idle code and the broadcast handler are
    synchronized using tick_broadcast_lock. So there is no need for the
    existing try to cancel logic. All this can be removed which will eliminate
    the race condition as well.
    
    Fixes: 5d1638acb9f6 ("tick: Introduce hrtimer based broadcast")
    Originally-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Balasubramani Vivekanandan <balasubramani_vivekanandan@mentor.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lkml.kernel.org/r/20190926135101.12102-2-balasubramani_vivekanandan@mentor.com
    [bwh: Backported to 3.16: adjust context]
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit 64d6a12094f35d644540c15440874723b1887f9d
Merge: cd4771f77092 4df4cb9e99f8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Nov 26 09:43:34 2019 -0800

    Merge branch 'x86-hyperv-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull x86 hyperv updates from Ingo Molnar:
     "Misc updates to the hyperv guest code:
    
       - Rework clockevents initialization to better support hibernation
    
       - Allow guests to enable InvariantTSC
    
       - Micro-optimize send_ipi_one"
    
    * 'x86-hyperv-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      x86/hyperv: Initialize clockevents earlier in CPU onlining
      x86/hyperv: Allow guests to enable InvariantTSC
      x86/hyperv: Micro-optimize send_ipi_one()

commit cd3cac5198777cabf5ab6a8226148431e42a0ddf
Author: Michael Ellerman <mpe@ellerman.id.au>
Date:   Wed Oct 17 23:39:41 2018 +1100

    powerpc/time: Fix clockevent_decrementer initalisation for PR KVM
    
    [ Upstream commit b4d16ab58c41ff0125822464bdff074cebd0fe47 ]
    
    In the recent commit 8b78fdb045de ("powerpc/time: Use
    clockevents_register_device(), fixing an issue with large
    decrementer") we changed the way we initialise the decrementer
    clockevent(s).
    
    We no longer initialise the mult & shift values of
    decrementer_clockevent itself.
    
    This has the effect of breaking PR KVM, because it uses those values
    in kvmppc_emulate_dec(). The symptom is guest kernels spin forever
    mid-way through boot.
    
    For now fix it by assigning back to decrementer_clockevent the mult
    and shift values.
    
    Fixes: 8b78fdb045de ("powerpc/time: Use clockevents_register_device(), fixing an issue with large decrementer")
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 991d57ecd8bc0db05186a4ecb2341748b1b7e97e
Author: Anton Blanchard <anton@ozlabs.org>
Date:   Tue Oct 2 09:01:04 2018 +1000

    powerpc/time: Use clockevents_register_device(), fixing an issue with large decrementer
    
    [ Upstream commit 8b78fdb045de60a4eb35460092bbd3cffa925353 ]
    
    We currently cap the decrementer clockevent at 4 seconds, even on systems
    with large decrementer support. Fix this by converting the code to use
    clockevents_register_device() which calculates the upper bound based on
    the max_delta passed in.
    
    Signed-off-by: Anton Blanchard <anton@ozlabs.org>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit a2667a032c6207c9d058678d4f5f8422e20603aa
Author: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
Date:   Sat Sep 8 23:54:05 2018 +0300

    clocksource/drivers/sh_cmt: Fixup for 64-bit machines
    
    [ Upstream commit 22627c6f3ed3d9d0df13eec3c831b08f8186c38e ]
    
    When trying to use CMT for clockevents on R-Car gen3 SoCs, I noticed
    that 'max_delta_ns' for the broadcast timer (CMT) was shown as 1000 in
    /proc/timer_list. It turned out that when calculating it, the driver did
    1 << 32 (causing what I think was undefined behavior) resulting in a zero
    delta, later clamped to 1000 by cev_delta2ns(). The root cause turned out
    to be that the driver abused *unsigned long* for the CMT register values
    (which are 16/32-bit), so that the calculation of 'ch->max_match_value'
    in sh_cmt_setup_channel() used the wrong branch. Using more proper 'u32'
    instead fixed 'max_delta_ns' and even fixed the switching an active
    clocksource to CMT (which caused the system to turn non-interactive
    before).
    
    Signed-off-by: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
    Reviewed-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit e2a37708cfca2e9815fc9a2456263b4fbbcfc367
Author: Michael Ellerman <mpe@ellerman.id.au>
Date:   Wed Oct 17 23:39:41 2018 +1100

    powerpc/time: Fix clockevent_decrementer initalisation for PR KVM
    
    [ Upstream commit b4d16ab58c41ff0125822464bdff074cebd0fe47 ]
    
    In the recent commit 8b78fdb045de ("powerpc/time: Use
    clockevents_register_device(), fixing an issue with large
    decrementer") we changed the way we initialise the decrementer
    clockevent(s).
    
    We no longer initialise the mult & shift values of
    decrementer_clockevent itself.
    
    This has the effect of breaking PR KVM, because it uses those values
    in kvmppc_emulate_dec(). The symptom is guest kernels spin forever
    mid-way through boot.
    
    For now fix it by assigning back to decrementer_clockevent the mult
    and shift values.
    
    Fixes: 8b78fdb045de ("powerpc/time: Use clockevents_register_device(), fixing an issue with large decrementer")
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 9e4649e443e24fecfc5521f6452a0a4184488d30
Author: Anton Blanchard <anton@ozlabs.org>
Date:   Tue Oct 2 09:01:04 2018 +1000

    powerpc/time: Use clockevents_register_device(), fixing an issue with large decrementer
    
    [ Upstream commit 8b78fdb045de60a4eb35460092bbd3cffa925353 ]
    
    We currently cap the decrementer clockevent at 4 seconds, even on systems
    with large decrementer support. Fix this by converting the code to use
    clockevents_register_device() which calculates the upper bound based on
    the max_delta passed in.
    
    Signed-off-by: Anton Blanchard <anton@ozlabs.org>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 31fb5ea6ed1b1f5dfcc88ec454fb9a6d313125d6
Author: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
Date:   Sat Sep 8 23:54:05 2018 +0300

    clocksource/drivers/sh_cmt: Fixup for 64-bit machines
    
    [ Upstream commit 22627c6f3ed3d9d0df13eec3c831b08f8186c38e ]
    
    When trying to use CMT for clockevents on R-Car gen3 SoCs, I noticed
    that 'max_delta_ns' for the broadcast timer (CMT) was shown as 1000 in
    /proc/timer_list. It turned out that when calculating it, the driver did
    1 << 32 (causing what I think was undefined behavior) resulting in a zero
    delta, later clamped to 1000 by cev_delta2ns(). The root cause turned out
    to be that the driver abused *unsigned long* for the CMT register values
    (which are 16/32-bit), so that the calculation of 'ch->max_match_value'
    in sh_cmt_setup_channel() used the wrong branch. Using more proper 'u32'
    instead fixed 'max_delta_ns' and even fixed the switching an active
    clocksource to CMT (which caused the system to turn non-interactive
    before).
    
    Signed-off-by: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
    Reviewed-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 3dcb2a3fa5a0c903fd754bfba2b8defb9f191974
Author: Andrea Arcangeli <aarcange@redhat.com>
Date:   Mon Nov 4 18:00:00 2019 -0500

    KVM: retpolines: x86: eliminate retpoline from svm.c exit handlers
    
    It's enough to check the exit value and issue a direct call to avoid
    the retpoline for all the common vmexit reasons.
    
    After this commit is applied, here the most common retpolines executed
    under a high resolution timer workload in the guest on a SVM host:
    
    [..]
    @[
        trace_retpoline+1
        __trace_retpoline+30
        __x86_indirect_thunk_rax+33
        ktime_get_update_offsets_now+70
        hrtimer_interrupt+131
        smp_apic_timer_interrupt+106
        apic_timer_interrupt+15
        start_sw_timer+359
        restart_apic_timer+85
        kvm_set_msr_common+1497
        msr_interception+142
        vcpu_enter_guest+684
        kvm_arch_vcpu_ioctl_run+261
        kvm_vcpu_ioctl+559
        do_vfs_ioctl+164
        ksys_ioctl+96
        __x64_sys_ioctl+22
        do_syscall_64+89
        entry_SYSCALL_64_after_hwframe+68
    ]: 1940
    @[
        trace_retpoline+1
        __trace_retpoline+30
        __x86_indirect_thunk_r12+33
        force_qs_rnp+217
        rcu_gp_kthread+1270
        kthread+268
        ret_from_fork+34
    ]: 4644
    @[]: 25095
    @[
        trace_retpoline+1
        __trace_retpoline+30
        __x86_indirect_thunk_rax+33
        lapic_next_event+28
        clockevents_program_event+148
        hrtimer_start_range_ns+528
        start_sw_timer+356
        restart_apic_timer+85
        kvm_set_msr_common+1497
        msr_interception+142
        vcpu_enter_guest+684
        kvm_arch_vcpu_ioctl_run+261
        kvm_vcpu_ioctl+559
        do_vfs_ioctl+164
        ksys_ioctl+96
        __x64_sys_ioctl+22
        do_syscall_64+89
        entry_SYSCALL_64_after_hwframe+68
    ]: 41474
    @[
        trace_retpoline+1
        __trace_retpoline+30
        __x86_indirect_thunk_rax+33
        clockevents_program_event+148
        hrtimer_start_range_ns+528
        start_sw_timer+356
        restart_apic_timer+85
        kvm_set_msr_common+1497
        msr_interception+142
        vcpu_enter_guest+684
        kvm_arch_vcpu_ioctl_run+261
        kvm_vcpu_ioctl+559
        do_vfs_ioctl+164
        ksys_ioctl+96
        __x64_sys_ioctl+22
        do_syscall_64+89
        entry_SYSCALL_64_after_hwframe+68
    ]: 41474
    @[
        trace_retpoline+1
        __trace_retpoline+30
        __x86_indirect_thunk_rax+33
        ktime_get+58
        clockevents_program_event+84
        hrtimer_start_range_ns+528
        start_sw_timer+356
        restart_apic_timer+85
        kvm_set_msr_common+1497
        msr_interception+142
        vcpu_enter_guest+684
        kvm_arch_vcpu_ioctl_run+261
        kvm_vcpu_ioctl+559
        do_vfs_ioctl+164
        ksys_ioctl+96
        __x64_sys_ioctl+22
        do_syscall_64+89
        entry_SYSCALL_64_after_hwframe+68
    ]: 41887
    @[
        trace_retpoline+1
        __trace_retpoline+30
        __x86_indirect_thunk_rax+33
        lapic_next_event+28
        clockevents_program_event+148
        hrtimer_try_to_cancel+168
        hrtimer_cancel+21
        kvm_set_lapic_tscdeadline_msr+43
        kvm_set_msr_common+1497
        msr_interception+142
        vcpu_enter_guest+684
        kvm_arch_vcpu_ioctl_run+261
        kvm_vcpu_ioctl+559
        do_vfs_ioctl+164
        ksys_ioctl+96
        __x64_sys_ioctl+22
        do_syscall_64+89
        entry_SYSCALL_64_after_hwframe+68
    ]: 42723
    @[
        trace_retpoline+1
        __trace_retpoline+30
        __x86_indirect_thunk_rax+33
        clockevents_program_event+148
        hrtimer_try_to_cancel+168
        hrtimer_cancel+21
        kvm_set_lapic_tscdeadline_msr+43
        kvm_set_msr_common+1497
        msr_interception+142
        vcpu_enter_guest+684
        kvm_arch_vcpu_ioctl_run+261
        kvm_vcpu_ioctl+559
        do_vfs_ioctl+164
        ksys_ioctl+96
        __x64_sys_ioctl+22
        do_syscall_64+89
        entry_SYSCALL_64_after_hwframe+68
    ]: 42766
    @[
        trace_retpoline+1
        __trace_retpoline+30
        __x86_indirect_thunk_rax+33
        ktime_get+58
        clockevents_program_event+84
        hrtimer_try_to_cancel+168
        hrtimer_cancel+21
        kvm_set_lapic_tscdeadline_msr+43
        kvm_set_msr_common+1497
        msr_interception+142
        vcpu_enter_guest+684
        kvm_arch_vcpu_ioctl_run+261
        kvm_vcpu_ioctl+559
        do_vfs_ioctl+164
        ksys_ioctl+96
        __x64_sys_ioctl+22
        do_syscall_64+89
        entry_SYSCALL_64_after_hwframe+68
    ]: 42848
    @[
        trace_retpoline+1
        __trace_retpoline+30
        __x86_indirect_thunk_rax+33
        ktime_get+58
        start_sw_timer+279
        restart_apic_timer+85
        kvm_set_msr_common+1497
        msr_interception+142
        vcpu_enter_guest+684
        kvm_arch_vcpu_ioctl_run+261
        kvm_vcpu_ioctl+559
        do_vfs_ioctl+164
        ksys_ioctl+96
        __x64_sys_ioctl+22
        do_syscall_64+89
        entry_SYSCALL_64_after_hwframe+68
    ]: 499845
    
    @total: 1780243
    
    SVM has no TSC based programmable preemption timer so it is invoking
    ktime_get() frequently.
    
    Signed-off-by: Andrea Arcangeli <aarcange@redhat.com>
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>

commit 4df4cb9e99f83b70d54bc0e25081ac23cceafcbc
Author: Michael Kelley <mikelley@microsoft.com>
Date:   Wed Nov 13 01:11:49 2019 +0000

    x86/hyperv: Initialize clockevents earlier in CPU onlining
    
    Hyper-V has historically initialized stimer-based clockevents late in the
    process of onlining a CPU because clockevents depend on stimer
    interrupts. In the original Hyper-V design, stimer interrupts generate a
    VMbus message, so the VMbus machinery must be running first, and VMbus
    can't be initialized until relatively late. On x86/64, LAPIC timer based
    clockevents are used during early initialization before VMbus and
    stimer-based clockevents are ready, and again during CPU offlining after
    the stimer clockevents have been shut down.
    
    Unfortunately, this design creates problems when offlining CPUs for
    hibernation or other purposes. stimer-based clockevents are shut down
    relatively early in the offlining process, so clockevents_unbind_device()
    must be used to fallback to the LAPIC-based clockevents for the remainder
    of the offlining process.  Furthermore, the late initialization and early
    shutdown of stimer-based clockevents doesn't work well on ARM64 since there
    is no other timer like the LAPIC to fallback to. So CPU onlining and
    offlining doesn't work properly.
    
    Fix this by recognizing that stimer Direct Mode is the normal path for
    newer versions of Hyper-V on x86/64, and the only path on other
    architectures. With stimer Direct Mode, stimer interrupts don't require any
    VMbus machinery. stimer clockevents can be initialized and shut down
    consistent with how it is done for other clockevent devices. While the old
    VMbus-based stimer interrupts must still be supported for backward
    compatibility on x86, that mode of operation can be treated as legacy.
    
    So add a new Hyper-V stimer entry in the CPU hotplug state list, and use
    that new state when in Direct Mode. Update the Hyper-V clocksource driver
    to allocate and initialize stimer clockevents earlier during boot. Update
    Hyper-V initialization and the VMbus driver to use this new design. As a
    result, the LAPIC timer is no longer used during boot or CPU
    onlining/offlining and clockevents_unbind_device() is not called.  But
    retain the old design as a legacy implementation for older versions of
    Hyper-V that don't support Direct Mode.
    
    Signed-off-by: Michael Kelley <mikelley@microsoft.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Dexuan Cui <decui@microsoft.com>
    Reviewed-by: Dexuan Cui <decui@microsoft.com>
    Link: https://lkml.kernel.org/r/1573607467-9456-1-git-send-email-mikelley@microsoft.com

commit 39b656ee9f2ce41eb969c86525f9a2a63fefac5b
Merge: 4f5cafb5cb84 cebf7d51a6c3
Author: Ingo Molnar <mingo@kernel.org>
Date:   Tue Oct 15 07:19:55 2019 +0200

    Merge tag 'perf-core-for-mingo-5.5-20191011' of git://git.kernel.org/pub/scm/linux/kernel/git/acme/linux into perf/core
    
    Pull perf/core improvements and fixes from Arnaldo Carvalho de Melo:
    
    perf trace:
    
      Arnaldo Carvalho de Melo:
    
      - Reuse the strace-like syscall_arg_fmt->scnprintf() beautification routines
        (convert integer arguments into strings, like open flags, etc) in tracepoint
        arguments.
    
        For now the type based scnprintf routines (pid_t, umode_t, etc) and the
        ones based in well known arg name based ("fd", etc) gets associated with
        tracepoint args of that type.
    
        A tracepoint only arg, "msr", for the msr:{write,read}_msr gets added as
        an initial step.
    
      - Introduce syscall_arg_fmt->strtoul() methods to be the reverse operation
        of ->scnprintf(), i.e. to go from a string to an integer.
    
      - Implement --filter, just like in 'perf record', that affects the tracepoint
        events specied thus far in the command line, use the ->strtoul() methods
        to allow strings in tables associated with beautifiers to the integers
        the in-kernel tracepoint (eBPF later) filters expect, e.g.:
    
         # perf trace --max-events 1 -e sched:*ipi --filter="cpu==1 || cpu==2"
          0.000 as/24630 sched:sched_wake_idle_without_ipi(cpu: 1)
         #
    
         # perf trace --max-events 1 --max-stack=32 -e msr:* --filter="msr==IA32_TSC_DEADLINE"
          207.000 cc1/19963 msr:write_msr(msr: IA32_TSC_DEADLINE, val: 5442316760822)
                                            do_trace_write_msr ([kernel.kallsyms])
                                            do_trace_write_msr ([kernel.kallsyms])
                                            lapic_next_deadline ([kernel.kallsyms])
                                            clockevents_program_event ([kernel.kallsyms])
                                            hrtimer_interrupt ([kernel.kallsyms])
                                            smp_apic_timer_interrupt ([kernel.kallsyms])
                                            apic_timer_interrupt ([kernel.kallsyms])
                                            [0x6ff66c] (/usr/lib/gcc-cross/alpha-linux-gnu/8/cc1)
                                            [0x7047c3] (/usr/lib/gcc-cross/alpha-linux-gnu/8/cc1)
                                            [0x707708] (/usr/lib/gcc-cross/alpha-linux-gnu/8/cc1)
                                            execute_one_pass (/usr/lib/gcc-cross/alpha-linux-gnu/8/cc1)
                                            [0x4f3d37] (/usr/lib/gcc-cross/alpha-linux-gnu/8/cc1)
                                            [0x4f3d49] (/usr/lib/gcc-cross/alpha-linux-gnu/8/cc1)
                                            execute_pass_list (/usr/lib/gcc-cross/alpha-linux-gnu/8/cc1)
                                            cgraph_node::expand (/usr/lib/gcc-cross/alpha-linux-gnu/8/cc1)
                                            [0x2625b4] (/usr/lib/gcc-cross/alpha-linux-gnu/8/cc1)
                                            symbol_table::finalize_compilation_unit (/usr/lib/gcc-cross/alpha-linux-gnu/8/cc1)
                                            [0x5ae8b9] (/usr/lib/gcc-cross/alpha-linux-gnu/8/cc1)
                                            toplev::main (/usr/lib/gcc-cross/alpha-linux-gnu/8/cc1)
                                            main (/usr/lib/gcc-cross/alpha-linux-gnu/8/cc1)
                                            [0x26b6a] (/usr/lib/x86_64-linux-gnu/libc-2.29.so)
         #
         # perf trace --max-events 8 -e msr:* --filter="msr==IA32_SPEC_CTRL"
             0.000 :13281/13281 msr:write_msr(msr: IA32_SPEC_CTRL, val: 6)
             0.063 migration/3/25 msr:write_msr(msr: IA32_SPEC_CTRL)
             0.217 kworker/u16:1-/4826 msr:write_msr(msr: IA32_SPEC_CTRL)
             0.687 rcu_sched/11 msr:write_msr(msr: IA32_SPEC_CTRL)
             0.696 :13280/13280 msr:write_msr(msr: IA32_SPEC_CTRL, val: 6)
             0.305 :13281/13281 msr:write_msr(msr: IA32_SPEC_CTRL, val: 6)
             0.355 :13274/13274 msr:write_msr(msr: IA32_SPEC_CTRL, val: 6)
             2.743 kworker/u16:0-/6711 msr:write_msr(msr: IA32_SPEC_CTRL)
         #
         # perf trace --max-events 8 --cpu 1 -e msr:* --filter="msr!=IA32_SPEC_CTRL && msr!=IA32_TSC_DEADLINE && msr != FS_BASE"
               0.000 mtr-packet/30819 msr:write_msr(msr: 0x830, val: 68719479037)
               0.096 :0/0 msr:read_msr(msr: IA32_TSC_ADJUST)
             238.925 mtr-packet/30819 msr:write_msr(msr: 0x830, val: 8589936893)
             511.010 :0/0 msr:write_msr(msr: 0x830, val: 68719479037)
            1005.052 :0/0 msr:read_msr(msr: IA32_TSC_ADJUST)
            1235.131 CPU 0/KVM/3750 msr:write_msr(msr: 0x830, val: 4294969595)
            1235.195 CPU 0/KVM/3750 msr:read_msr(msr: IA32_SYSENTER_ESP, val: -2199023037952)
            1235.201 CPU 0/KVM/3750 msr:read_msr(msr: IA32_APICBASE, val: 4276096000)
         #
    
      - Default to not using libtraceevent and its plugins for beautifying
        tracepoint arguments, since now we're reusing the strace-like beatufiers.
        Use --libtraceevent_print (using just --libtrace is unambiguous and can
        be used as a short hand) to go back to those beautifiers.
    
        This will help in the transition, as can be seen in some of the sched tracepoints
        that still need some work in the libbeauty based mode:
    
        # trace --no-inherit -e msr:*,*sleep,sched:* sleep 1
             0.000 (         ): sched:sched_waking(comm: "trace", pid: 3319 (trace), prio: 120, success: 1)
             0.006 (         ): sched:sched_wakeup(comm: "trace", pid: 3319 (trace), prio: 120, success: 1)
             0.348 (         ): sched:sched_process_exec(filename: 140212596720100, pid: 3319 (sleep), old_pid: 3319 (sleep))
             0.490 (         ): msr:write_msr(msr: FS_BASE, val: 139631189321088)
             0.670 (         ): nanosleep(rqtp: 0x7ffc52c23bc0)                                    ...
             0.674 (         ): sched:sched_stat_runtime(comm: "sleep", pid: 3319 (sleep), runtime: 659259, vruntime: 78942418342)
             0.675 (         ): sched:sched_switch(prev_comm: "sleep", prev_pid: 3319 (sleep), prev_prio: 120, prev_state: 1, next_comm: "swapper/0", next_prio: 120)
          1001.059 (         ): sched:sched_waking(comm: "sleep", pid: 3319 (sleep), prio: 120, success: 1)
          1001.098 (         ): sched:sched_wakeup(comm: "sleep", pid: 3319 (sleep), prio: 120, success: 1)
             0.670 (1000.504 ms):  ... [continued]: nanosleep())                                        = 0
          1001.456 (         ): sched:sched_process_exit(comm: "sleep", pid: 3319 (sleep), prio: 120)
        # trace --libtrace --no-inherit -e msr:*,*sleep,sched:* sleep 1
        # trace --libtrace --no-inherit -e msr:*,*sleep,sched:* sleep 1
             0.000 (         ): sched:sched_waking(comm=trace pid=3323 prio=120 target_cpu=000)
             0.007 (         ): sched:sched_wakeup(comm=trace pid=3323 prio=120 target_cpu=000)
             0.382 (         ): sched:sched_process_exec(filename=/usr/bin/sleep pid=3323 old_pid=3323)
             0.525 (         ): msr:write_msr(c0000100, value 7f5d508a0580)
             0.713 (         ): nanosleep(rqtp: 0x7fff487fb4a0)                                    ...
             0.717 (         ): sched:sched_stat_runtime(comm=sleep pid=3323 runtime=617722 [ns] vruntime=78957731636 [ns])
             0.719 (         ): sched:sched_switch(prev_comm=sleep prev_pid=3323 prev_prio=120 prev_state=S ==> next_comm=swapper/0 next_pid=0 next_prio=120)
          1001.117 (         ): sched:sched_waking(comm=sleep pid=3323 prio=120 target_cpu=000)
          1001.157 (         ): sched:sched_wakeup(comm=sleep pid=3323 prio=120 target_cpu=000)
             0.713 (1000.522 ms):  ... [continued]: nanosleep())                                        = 0
          1001.538 (         ): sched:sched_process_exit(comm=sleep pid=3323 prio=120)
        #
    
      - Make -v (verbose) mode be honoured for .perfconfig based trace.add_events,
        to help in diagnosing problems with building eBPF events (-e source.c).
    
      - When using eBPF syscall payload augmentation do not show strace-like
        syscalls when all the user specified was some tracepoint event, bringing
        the behaviour in line with that of when not using eBPF augmentation.
    
    Intel PT:
    
      exported-sql-viewer GUI:
    
      Adrian Hunter:
    
      - Add LookupModel, HBoxLayout, VBoxLayout, global time range calculations
        so as to add a time chart by CPU.
    
    perf script:
    
      Andi Kleen:
    
      - Allow --time (to specify a time span of interest) with --reltime
    
    perf diff:
    
      Jin Yao:
    
      - Report noise for cycles diff, i.e. a histogram + stddev.
        (timestamps relative to start).
    
    perf annotate:
    
      Arnaldo Carvalho de Melo:
    
      - Initialize env->cpuid when running in live mode (perf top), as it
        is used in some of the per arch annotation init routines.
    
    samples bpf:
    
      Bjrn Tpel:
    
      - Fixup fallout of using tools/perf/perf-sys. from outside tools/perf.
    
    Core:
    
      Ian Rogers:
    
      - Avoid 'sample_reg_masks' being const + weak, as this breaks with some
        compilers that constant-propagate from the weak symbol.
    
    libperf:
    
      - First part of moving the perf_mmap class from tools/perf to libperf.
    
      - Propagate CFLAGS to libperf from the tools/perf Makefile.
    
    Vendor events:
    
      John Garry:
    
      - Add entry in MAINTAINERS with reviewers for the for perf tool arm64
        pmu-events files.
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 91dbd8778f7fce438a16e1ae2b22c55e885bdff8
Author: Balasubramani Vivekanandan <balasubramani_vivekanandan@mentor.com>
Date:   Thu Sep 26 15:51:01 2019 +0200

    tick: broadcast-hrtimer: Fix a race in bc_set_next
    
    [ Upstream commit b9023b91dd020ad7e093baa5122b6968c48cc9e0 ]
    
    When a cpu requests broadcasting, before starting the tick broadcast
    hrtimer, bc_set_next() checks if the timer callback (bc_handler) is active
    using hrtimer_try_to_cancel(). But hrtimer_try_to_cancel() does not provide
    the required synchronization when the callback is active on other core.
    
    The callback could have already executed tick_handle_oneshot_broadcast()
    and could have also returned. But still there is a small time window where
    the hrtimer_try_to_cancel() returns -1. In that case bc_set_next() returns
    without doing anything, but the next_event of the tick broadcast clock
    device is already set to a timeout value.
    
    In the race condition diagram below, CPU #1 is running the timer callback
    and CPU #2 is entering idle state and so calls bc_set_next().
    
    In the worst case, the next_event will contain an expiry time, but the
    hrtimer will not be started which happens when the racing callback returns
    HRTIMER_NORESTART. The hrtimer might never recover if all further requests
    from the CPUs to subscribe to tick broadcast have timeout greater than the
    next_event of tick broadcast clock device. This leads to cascading of
    failures and finally noticed as rcu stall warnings
    
    Here is a depiction of the race condition
    
    CPU #1 (Running timer callback)                   CPU #2 (Enter idle
                                                      and subscribe to
                                                      tick broadcast)
    ---------------------                             ---------------------
    
    __run_hrtimer()                                   tick_broadcast_enter()
    
      bc_handler()                                      __tick_broadcast_oneshot_control()
    
        tick_handle_oneshot_broadcast()
    
          raw_spin_lock(&tick_broadcast_lock);
    
          dev->next_event = KTIME_MAX;                  //wait for tick_broadcast_lock
          //next_event for tick broadcast clock
          set to KTIME_MAX since no other cores
          subscribed to tick broadcasting
    
          raw_spin_unlock(&tick_broadcast_lock);
    
        if (dev->next_event == KTIME_MAX)
          return HRTIMER_NORESTART
        // callback function exits without
           restarting the hrtimer                      //tick_broadcast_lock acquired
                                                       raw_spin_lock(&tick_broadcast_lock);
    
                                                       tick_broadcast_set_event()
    
                                                         clockevents_program_event()
    
                                                           dev->next_event = expires;
    
                                                           bc_set_next()
    
                                                             hrtimer_try_to_cancel()
                                                             //returns -1 since the timer
                                                             callback is active. Exits without
                                                             restarting the timer
      cpu_base->running = NULL;
    
    The comment that hrtimer cannot be armed from within the callback is
    wrong. It is fine to start the hrtimer from within the callback. Also it is
    safe to start the hrtimer from the enter/exit idle code while the broadcast
    handler is active. The enter/exit idle code and the broadcast handler are
    synchronized using tick_broadcast_lock. So there is no need for the
    existing try to cancel logic. All this can be removed which will eliminate
    the race condition as well.
    
    Fixes: 5d1638acb9f6 ("tick: Introduce hrtimer based broadcast")
    Originally-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Balasubramani Vivekanandan <balasubramani_vivekanandan@mentor.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190926135101.12102-2-balasubramani_vivekanandan@mentor.com
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit e5331c37c08baa21e6a1caa7c3ae30156596573c
Author: Balasubramani Vivekanandan <balasubramani_vivekanandan@mentor.com>
Date:   Thu Sep 26 15:51:01 2019 +0200

    tick: broadcast-hrtimer: Fix a race in bc_set_next
    
    [ Upstream commit b9023b91dd020ad7e093baa5122b6968c48cc9e0 ]
    
    When a cpu requests broadcasting, before starting the tick broadcast
    hrtimer, bc_set_next() checks if the timer callback (bc_handler) is active
    using hrtimer_try_to_cancel(). But hrtimer_try_to_cancel() does not provide
    the required synchronization when the callback is active on other core.
    
    The callback could have already executed tick_handle_oneshot_broadcast()
    and could have also returned. But still there is a small time window where
    the hrtimer_try_to_cancel() returns -1. In that case bc_set_next() returns
    without doing anything, but the next_event of the tick broadcast clock
    device is already set to a timeout value.
    
    In the race condition diagram below, CPU #1 is running the timer callback
    and CPU #2 is entering idle state and so calls bc_set_next().
    
    In the worst case, the next_event will contain an expiry time, but the
    hrtimer will not be started which happens when the racing callback returns
    HRTIMER_NORESTART. The hrtimer might never recover if all further requests
    from the CPUs to subscribe to tick broadcast have timeout greater than the
    next_event of tick broadcast clock device. This leads to cascading of
    failures and finally noticed as rcu stall warnings
    
    Here is a depiction of the race condition
    
    CPU #1 (Running timer callback)                   CPU #2 (Enter idle
                                                      and subscribe to
                                                      tick broadcast)
    ---------------------                             ---------------------
    
    __run_hrtimer()                                   tick_broadcast_enter()
    
      bc_handler()                                      __tick_broadcast_oneshot_control()
    
        tick_handle_oneshot_broadcast()
    
          raw_spin_lock(&tick_broadcast_lock);
    
          dev->next_event = KTIME_MAX;                  //wait for tick_broadcast_lock
          //next_event for tick broadcast clock
          set to KTIME_MAX since no other cores
          subscribed to tick broadcasting
    
          raw_spin_unlock(&tick_broadcast_lock);
    
        if (dev->next_event == KTIME_MAX)
          return HRTIMER_NORESTART
        // callback function exits without
           restarting the hrtimer                      //tick_broadcast_lock acquired
                                                       raw_spin_lock(&tick_broadcast_lock);
    
                                                       tick_broadcast_set_event()
    
                                                         clockevents_program_event()
    
                                                           dev->next_event = expires;
    
                                                           bc_set_next()
    
                                                             hrtimer_try_to_cancel()
                                                             //returns -1 since the timer
                                                             callback is active. Exits without
                                                             restarting the timer
      cpu_base->running = NULL;
    
    The comment that hrtimer cannot be armed from within the callback is
    wrong. It is fine to start the hrtimer from within the callback. Also it is
    safe to start the hrtimer from the enter/exit idle code while the broadcast
    handler is active. The enter/exit idle code and the broadcast handler are
    synchronized using tick_broadcast_lock. So there is no need for the
    existing try to cancel logic. All this can be removed which will eliminate
    the race condition as well.
    
    Fixes: 5d1638acb9f6 ("tick: Introduce hrtimer based broadcast")
    Originally-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Balasubramani Vivekanandan <balasubramani_vivekanandan@mentor.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190926135101.12102-2-balasubramani_vivekanandan@mentor.com
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit a990caf9f6e68e04f142734bacccb5ffb51da623
Author: Balasubramani Vivekanandan <balasubramani_vivekanandan@mentor.com>
Date:   Thu Sep 26 15:51:01 2019 +0200

    tick: broadcast-hrtimer: Fix a race in bc_set_next
    
    [ Upstream commit b9023b91dd020ad7e093baa5122b6968c48cc9e0 ]
    
    When a cpu requests broadcasting, before starting the tick broadcast
    hrtimer, bc_set_next() checks if the timer callback (bc_handler) is active
    using hrtimer_try_to_cancel(). But hrtimer_try_to_cancel() does not provide
    the required synchronization when the callback is active on other core.
    
    The callback could have already executed tick_handle_oneshot_broadcast()
    and could have also returned. But still there is a small time window where
    the hrtimer_try_to_cancel() returns -1. In that case bc_set_next() returns
    without doing anything, but the next_event of the tick broadcast clock
    device is already set to a timeout value.
    
    In the race condition diagram below, CPU #1 is running the timer callback
    and CPU #2 is entering idle state and so calls bc_set_next().
    
    In the worst case, the next_event will contain an expiry time, but the
    hrtimer will not be started which happens when the racing callback returns
    HRTIMER_NORESTART. The hrtimer might never recover if all further requests
    from the CPUs to subscribe to tick broadcast have timeout greater than the
    next_event of tick broadcast clock device. This leads to cascading of
    failures and finally noticed as rcu stall warnings
    
    Here is a depiction of the race condition
    
    CPU #1 (Running timer callback)                   CPU #2 (Enter idle
                                                      and subscribe to
                                                      tick broadcast)
    ---------------------                             ---------------------
    
    __run_hrtimer()                                   tick_broadcast_enter()
    
      bc_handler()                                      __tick_broadcast_oneshot_control()
    
        tick_handle_oneshot_broadcast()
    
          raw_spin_lock(&tick_broadcast_lock);
    
          dev->next_event = KTIME_MAX;                  //wait for tick_broadcast_lock
          //next_event for tick broadcast clock
          set to KTIME_MAX since no other cores
          subscribed to tick broadcasting
    
          raw_spin_unlock(&tick_broadcast_lock);
    
        if (dev->next_event == KTIME_MAX)
          return HRTIMER_NORESTART
        // callback function exits without
           restarting the hrtimer                      //tick_broadcast_lock acquired
                                                       raw_spin_lock(&tick_broadcast_lock);
    
                                                       tick_broadcast_set_event()
    
                                                         clockevents_program_event()
    
                                                           dev->next_event = expires;
    
                                                           bc_set_next()
    
                                                             hrtimer_try_to_cancel()
                                                             //returns -1 since the timer
                                                             callback is active. Exits without
                                                             restarting the timer
      cpu_base->running = NULL;
    
    The comment that hrtimer cannot be armed from within the callback is
    wrong. It is fine to start the hrtimer from within the callback. Also it is
    safe to start the hrtimer from the enter/exit idle code while the broadcast
    handler is active. The enter/exit idle code and the broadcast handler are
    synchronized using tick_broadcast_lock. So there is no need for the
    existing try to cancel logic. All this can be removed which will eliminate
    the race condition as well.
    
    Fixes: 5d1638acb9f6 ("tick: Introduce hrtimer based broadcast")
    Originally-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Balasubramani Vivekanandan <balasubramani_vivekanandan@mentor.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190926135101.12102-2-balasubramani_vivekanandan@mentor.com
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 728db198868c7b46db5e65717d4518aeb6523ccc
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Wed Oct 9 16:25:02 2019 -0300

    perf beauty: Introduce strtoul() for x86 MSRs
    
    Continuing from the previous cset comment, now that filter expression
    works:
    
      # perf trace -e msr:* --filter="msr!=FS_BASE && msr != IA32_TSC_DEADLINE && msr != 0x830 && msr != 0x83f && msr !=IA32_SPEC_CTRL" --filter-pids 3750
         0.000 Timer/5033 msr:write_msr(msr: SYSCALL_MASK, val: 292608)
         0.009 Timer/5033 msr:write_msr(msr: LSTAR, val: -1398800368)
         0.010 Timer/5033 msr:write_msr(msr: TSC_AUX, val: 4)
         0.050 :0/0 msr:read_msr(msr: IA32_TSC_ADJUST)
        45.661 gnome-terminal/12595 msr:write_msr(msr: SYSCALL_MASK, val: 292608)
        45.672 gnome-terminal/12595 msr:write_msr(msr: LSTAR, val: -1398800368)
        45.675 gnome-terminal/12595 msr:write_msr(msr: TSC_AUX, val: 3)
        54.852 :0/0 msr:read_msr(msr: IA32_TSC_ADJUST)
       130.508 Timer/4050 msr:write_msr(msr: SYSCALL_MASK, val: 292608)
       130.527 Timer/4050 msr:write_msr(msr: LSTAR, val: -1398800368)
       130.531 Timer/4050 msr:write_msr(msr: TSC_AUX, val: 3)
       140.924 :0/0 msr:read_msr(msr: IA32_TSC_ADJUST)
       164.738 :0/0 msr:read_msr(msr: IA32_TSC_ADJUST)
       603.578 :0/0 msr:read_msr(msr: IA32_TSC_ADJUST)
       620.809 :0/0 msr:read_msr(msr: IA32_TSC_ADJUST)
       690.115 JS Watchdog/4259 msr:write_msr(msr: SYSCALL_MASK, val: 292608)
       690.136 JS Watchdog/4259 msr:write_msr(msr: LSTAR, val: -1398800368)
       690.141 JS Watchdog/4259 msr:write_msr(msr: TSC_AUX, val: 3)
       690.186 :0/0 msr:read_msr(msr: IA32_TSC_ADJUST)
       759.016 :0/0 msr:read_msr(msr: IA32_TSC_ADJUST)
    ^C[root@quaco ~]#
    
    Or look at the first 3 write_msr events for that IA32_TSC_DEADLINE to learn why
    it happens so often:
    
      # perf trace --max-events=3 --max-stack=8 -e msr:* --filter="msr==IA32_TSC_DEADLINE" --filter-pids 3750
         0.000 :0/0 msr:write_msr(msr: IA32_TSC_DEADLINE, val: 19296732550862)
                                           do_trace_write_msr ([kernel.kallsyms])
                                           do_trace_write_msr ([kernel.kallsyms])
                                           lapic_next_deadline ([kernel.kallsyms])
                                           clockevents_program_event ([kernel.kallsyms])
                                           hrtimer_interrupt ([kernel.kallsyms])
                                           smp_apic_timer_interrupt ([kernel.kallsyms])
                                           apic_timer_interrupt ([kernel.kallsyms])
                                           cpuidle_enter_state ([kernel.kallsyms])
        32.646 :0/0 msr:write_msr(msr: IA32_TSC_DEADLINE, val: 19296800134158)
                                           do_trace_write_msr ([kernel.kallsyms])
                                           do_trace_write_msr ([kernel.kallsyms])
                                           lapic_next_deadline ([kernel.kallsyms])
                                           clockevents_program_event ([kernel.kallsyms])
                                           hrtimer_start_range_ns ([kernel.kallsyms])
                                           tick_nohz_restart_sched_tick ([kernel.kallsyms])
                                           tick_nohz_idle_exit ([kernel.kallsyms])
                                           do_idle ([kernel.kallsyms])
        32.802 :0/0 msr:write_msr(msr: IA32_TSC_DEADLINE, val: 19297507436922)
                                           do_trace_write_msr ([kernel.kallsyms])
                                           do_trace_write_msr ([kernel.kallsyms])
                                           lapic_next_deadline ([kernel.kallsyms])
                                           clockevents_program_event ([kernel.kallsyms])
                                           hrtimer_try_to_cancel ([kernel.kallsyms])
                                           hrtimer_cancel ([kernel.kallsyms])
                                           tick_nohz_restart_sched_tick ([kernel.kallsyms])
                                           tick_nohz_idle_exit ([kernel.kallsyms])
      #
    
    And if some of the strings can't be found:
    
      # trace -e msr:* --filter="msr!=SPECULATIVE_EXECUTION_PROBLEMS_SOLUTION && msr != IA32_TSC_DEADLINE && msr != 0x830 && msr != 0x83f && msr !=IA32_SPEC_CTRL" --filter-pids 3750
      "SPECULATIVE_EXECUTION_PROBLEMS_SOLUTION" not found for "msr" in "msr:read_msr", can't set filter "(msr!=SPECULATIVE_EXECUTION_PROBLEMS_SOLUTION && msr != IA32_TSC_DEADLINE && msr != 0x830 && msr != 0x83f && msr !=IA32_SPEC_CTRL) && (common_pid != 28131 && common_pid != 3750)"
      #
    
    Next step is to automatically wire up the pre-existing strarrays, which there
    are quite a few.
    
    The strtoul() methods will be further enhanced to allow for looking at other
    arguments in a syscall/tracepoint, just like going from integer to string
    (scnprintf methods), so that those "val" lines for the msr tracepoints can be
    properly formatted or even resolved into some string.
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Brendan Gregg <brendan.d.gregg@gmail.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Luis Cludio Gonalves <lclaudio@redhat.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Link: https://lkml.kernel.org/n/tip-4qaai5iqjgefd11k4ddm7qg8@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

commit b9023b91dd020ad7e093baa5122b6968c48cc9e0
Author: Balasubramani Vivekanandan <balasubramani_vivekanandan@mentor.com>
Date:   Thu Sep 26 15:51:01 2019 +0200

    tick: broadcast-hrtimer: Fix a race in bc_set_next
    
    When a cpu requests broadcasting, before starting the tick broadcast
    hrtimer, bc_set_next() checks if the timer callback (bc_handler) is active
    using hrtimer_try_to_cancel(). But hrtimer_try_to_cancel() does not provide
    the required synchronization when the callback is active on other core.
    
    The callback could have already executed tick_handle_oneshot_broadcast()
    and could have also returned. But still there is a small time window where
    the hrtimer_try_to_cancel() returns -1. In that case bc_set_next() returns
    without doing anything, but the next_event of the tick broadcast clock
    device is already set to a timeout value.
    
    In the race condition diagram below, CPU #1 is running the timer callback
    and CPU #2 is entering idle state and so calls bc_set_next().
    
    In the worst case, the next_event will contain an expiry time, but the
    hrtimer will not be started which happens when the racing callback returns
    HRTIMER_NORESTART. The hrtimer might never recover if all further requests
    from the CPUs to subscribe to tick broadcast have timeout greater than the
    next_event of tick broadcast clock device. This leads to cascading of
    failures and finally noticed as rcu stall warnings
    
    Here is a depiction of the race condition
    
    CPU #1 (Running timer callback)                   CPU #2 (Enter idle
                                                      and subscribe to
                                                      tick broadcast)
    ---------------------                             ---------------------
    
    __run_hrtimer()                                   tick_broadcast_enter()
    
      bc_handler()                                      __tick_broadcast_oneshot_control()
    
        tick_handle_oneshot_broadcast()
    
          raw_spin_lock(&tick_broadcast_lock);
    
          dev->next_event = KTIME_MAX;                  //wait for tick_broadcast_lock
          //next_event for tick broadcast clock
          set to KTIME_MAX since no other cores
          subscribed to tick broadcasting
    
          raw_spin_unlock(&tick_broadcast_lock);
    
        if (dev->next_event == KTIME_MAX)
          return HRTIMER_NORESTART
        // callback function exits without
           restarting the hrtimer                      //tick_broadcast_lock acquired
                                                       raw_spin_lock(&tick_broadcast_lock);
    
                                                       tick_broadcast_set_event()
    
                                                         clockevents_program_event()
    
                                                           dev->next_event = expires;
    
                                                           bc_set_next()
    
                                                             hrtimer_try_to_cancel()
                                                             //returns -1 since the timer
                                                             callback is active. Exits without
                                                             restarting the timer
      cpu_base->running = NULL;
    
    The comment that hrtimer cannot be armed from within the callback is
    wrong. It is fine to start the hrtimer from within the callback. Also it is
    safe to start the hrtimer from the enter/exit idle code while the broadcast
    handler is active. The enter/exit idle code and the broadcast handler are
    synchronized using tick_broadcast_lock. So there is no need for the
    existing try to cancel logic. All this can be removed which will eliminate
    the race condition as well.
    
    Fixes: 5d1638acb9f6 ("tick: Introduce hrtimer based broadcast")
    Originally-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Balasubramani Vivekanandan <balasubramani_vivekanandan@mentor.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190926135101.12102-2-balasubramani_vivekanandan@mentor.com

commit ba2ddb43f270e6492ccce4fc42fc32c611de8f68
Author: Christoph Paasch <cpaasch@apple.com>
Date:   Fri Sep 13 13:08:19 2019 -0700

    tcp: Don't dequeue SYN/FIN-segments from write-queue
    
    If a SYN/FIN-segment is on the write-queue, skb->len is 0, but the
    segment actually has been transmitted. end_seq and seq of the tcp_skb_cb
    in that case will indicate this difference.
    
    We should not remove such segments from the write-queue as we might be
    in SYN_SENT-state and a retransmission-timer is running. When that one
    fires, packets_out will be 1, but the write-queue would be empty,
    resulting in:
    
    [   61.280214] ------------[ cut here ]------------
    [   61.281307] WARNING: CPU: 0 PID: 0 at net/ipv4/tcp_timer.c:429 tcp_retransmit_timer+0x18f9/0x2660
    [   61.283498] Modules linked in:
    [   61.284084] CPU: 0 PID: 0 Comm: swapper/0 Not tainted 4.14.142 #58
    [   61.285214] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 0.5.1 01/01/2011
    [   61.286644] task: ffffffff8401e1c0 task.stack: ffffffff84000000
    [   61.287758] RIP: 0010:tcp_retransmit_timer+0x18f9/0x2660
    [   61.288715] RSP: 0018:ffff88806ce07cb8 EFLAGS: 00010206
    [   61.289669] RAX: ffffffff8401e1c0 RBX: ffff88805c998b00 RCX: 0000000000000006
    [   61.290968] RDX: 0000000000000100 RSI: 0000000000000000 RDI: ffff88805c9994d8
    [   61.292314] RBP: ffff88805c99919a R08: ffff88807fff901c R09: ffff88807fff9008
    [   61.293547] R10: ffff88807fff9017 R11: ffff88807fff9010 R12: ffff88805c998b30
    [   61.294834] R13: ffffffff844b9380 R14: 0000000000000000 R15: ffff88805c99930c
    [   61.296086] FS:  0000000000000000(0000) GS:ffff88806ce00000(0000) knlGS:0000000000000000
    [   61.297523] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [   61.298646] CR2: 00007f721da50ff8 CR3: 0000000004014002 CR4: 00000000001606f0
    [   61.299944] Call Trace:
    [   61.300403]  <IRQ>
    [   61.300806]  ? kvm_sched_clock_read+0x21/0x30
    [   61.301689]  ? sched_clock+0x5/0x10
    [   61.302433]  ? sched_clock_cpu+0x18/0x170
    [   61.303173]  tcp_write_timer_handler+0x2c1/0x7a0
    [   61.304038]  tcp_write_timer+0x13e/0x160
    [   61.304794]  call_timer_fn+0x14a/0x5f0
    [   61.305480]  ? tcp_write_timer_handler+0x7a0/0x7a0
    [   61.306364]  ? __next_timer_interrupt+0x140/0x140
    [   61.307229]  ? _raw_spin_unlock_irq+0x24/0x40
    [   61.308033]  ? tcp_write_timer_handler+0x7a0/0x7a0
    [   61.308887]  ? tcp_write_timer_handler+0x7a0/0x7a0
    [   61.309760]  run_timer_softirq+0xc41/0x1080
    [   61.310539]  ? trigger_dyntick_cpu.isra.33+0x180/0x180
    [   61.311506]  ? ktime_get+0x13f/0x1c0
    [   61.312232]  ? clockevents_program_event+0x10d/0x2f0
    [   61.313158]  __do_softirq+0x20b/0x96b
    [   61.313889]  irq_exit+0x1a7/0x1e0
    [   61.314513]  smp_apic_timer_interrupt+0xfc/0x4d0
    [   61.315386]  apic_timer_interrupt+0x8f/0xa0
    [   61.316129]  </IRQ>
    
    Followed by a panic.
    
    So, before removing an skb with skb->len == 0, let's make sure that the
    skb is really empty by checking the end_seq and seq.
    
    This patch needs to be backported only to 4.14 and older (among those
    that applied the backport of fdfc5c8594c2).
    
    Fixes: fdfc5c8594c2 ("tcp: remove empty skb from write queue in error cases")
    Cc: Eric Dumazet <edumazet@google.com>
    Cc: Jason Baron <jbaron@akamai.com>
    Cc: Vladimir Rutsky <rutsky@google.com>
    Cc: Soheil Hassas Yeganeh <soheil@google.com>
    Cc: Neal Cardwell <ncardwell@google.com>
    Signed-off-by: Christoph Paasch <cpaasch@apple.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit b55bd585551ed2220eefdab96b31e6f935310eec
Author: Paul E. McKenney <paulmck@linux.ibm.com>
Date:   Thu May 30 05:39:25 2019 -0700

    time/tick-broadcast: Fix tick_broadcast_offline() lockdep complaint
    
    The TASKS03 and TREE04 rcutorture scenarios produce the following
    lockdep complaint:
    
    ------------------------------------------------------------------------
    
    ================================
    WARNING: inconsistent lock state
    5.2.0-rc1+ #513 Not tainted
    --------------------------------
    inconsistent {IN-HARDIRQ-W} -> {HARDIRQ-ON-W} usage.
    migration/1/14 [HC0[0]:SC0[0]:HE1:SE1] takes:
    (____ptrval____) (tick_broadcast_lock){?...}, at: tick_broadcast_offline+0xf/0x70
    {IN-HARDIRQ-W} state was registered at:
      lock_acquire+0xb0/0x1c0
      _raw_spin_lock_irqsave+0x3c/0x50
      tick_broadcast_switch_to_oneshot+0xd/0x40
      tick_switch_to_oneshot+0x4f/0xd0
      hrtimer_run_queues+0xf3/0x130
      run_local_timers+0x1c/0x50
      update_process_times+0x1c/0x50
      tick_periodic+0x26/0xc0
      tick_handle_periodic+0x1a/0x60
      smp_apic_timer_interrupt+0x80/0x2a0
      apic_timer_interrupt+0xf/0x20
      _raw_spin_unlock_irqrestore+0x4e/0x60
      rcu_nocb_gp_kthread+0x15d/0x590
      kthread+0xf3/0x130
      ret_from_fork+0x3a/0x50
    irq event stamp: 171
    hardirqs last  enabled at (171): [<ffffffff8a201a37>] trace_hardirqs_on_thunk+0x1a/0x1c
    hardirqs last disabled at (170): [<ffffffff8a201a53>] trace_hardirqs_off_thunk+0x1a/0x1c
    softirqs last  enabled at (0): [<ffffffff8a264ee0>] copy_process.part.56+0x650/0x1cb0
    softirqs last disabled at (0): [<0000000000000000>] 0x0
    
    other info that might help us debug this:
     Possible unsafe locking scenario:
    
           CPU0
           ----
      lock(tick_broadcast_lock);
      <Interrupt>
        lock(tick_broadcast_lock);
    
     *** DEADLOCK ***
    
    1 lock held by migration/1/14:
     #0: (____ptrval____) (clockevents_lock){+.+.}, at: tick_offline_cpu+0xf/0x30
    
    stack backtrace:
    CPU: 1 PID: 14 Comm: migration/1 Not tainted 5.2.0-rc1+ #513
    Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS Bochs 01/01/2011
    Call Trace:
     dump_stack+0x5e/0x8b
     print_usage_bug+0x1fc/0x216
     ? print_shortest_lock_dependencies+0x1b0/0x1b0
     mark_lock+0x1f2/0x280
     __lock_acquire+0x1e0/0x18f0
     ? __lock_acquire+0x21b/0x18f0
     ? _raw_spin_unlock_irqrestore+0x4e/0x60
     lock_acquire+0xb0/0x1c0
     ? tick_broadcast_offline+0xf/0x70
     _raw_spin_lock+0x33/0x40
     ? tick_broadcast_offline+0xf/0x70
     tick_broadcast_offline+0xf/0x70
     tick_offline_cpu+0x16/0x30
     take_cpu_down+0x7d/0xa0
     multi_cpu_stop+0xa2/0xe0
     ? cpu_stop_queue_work+0xc0/0xc0
     cpu_stopper_thread+0x6d/0x100
     smpboot_thread_fn+0x169/0x240
     kthread+0xf3/0x130
     ? sort_range+0x20/0x20
     ? kthread_cancel_delayed_work_sync+0x10/0x10
     ret_from_fork+0x3a/0x50
    
    ------------------------------------------------------------------------
    
    To reproduce, run the following rcutorture test:
    
            tools/testing/selftests/rcutorture/bin/kvm.sh --duration 5 --kconfig "CONFIG_DEBUG_LOCK_ALLOC=y CONFIG_PROVE_LOCKING=y" --configs "TASKS03 TREE04"
    
    It turns out that tick_broadcast_offline() was an innocent bystander.
    After all, interrupts are supposed to be disabled throughout
    take_cpu_down(), and therefore should have been disabled upon entry to
    tick_offline_cpu() and thus to tick_broadcast_offline().  This suggests
    that one of the CPU-hotplug notifiers was incorrectly enabling interrupts,
    and leaving them enabled on return.
    
    Some debugging code showed that the culprit was sched_cpu_dying().
    It had irqs enabled after return from sched_tick_stop().  Which in turn
    had irqs enabled after return from cancel_delayed_work_sync().  Which is a
    wrapper around __cancel_work_timer().  Which can sleep in the case where
    something else is concurrently trying to cancel the same delayed work,
    and as Thomas Gleixner pointed out on IRC, sleeping is a decidedly bad
    idea when you are invoked from take_cpu_down(), regardless of the state
    you leave interrupts in upon return.
    
    Code inspection located no reason why the delayed work absolutely
    needed to be canceled from sched_tick_stop():  The work is not
    bound to the outgoing CPU by design, given that the whole point is
    to collect statistics without disturbing the outgoing CPU.
    
    This commit therefore simply drops the cancel_delayed_work_sync() from
    sched_tick_stop().  Instead, a new ->state field is added to the tick_work
    structure so that the delayed-work handler function sched_tick_remote()
    can avoid reposting itself.  A cpu_is_offline() check is also added to
    sched_tick_remote() to avoid mucking with the state of an offlined CPU
    (though it does appear safe to do so).  The sched_tick_start() and
    sched_tick_stop() functions also update ->state, and sched_tick_start()
    also schedules the delayed work if ->state indicates that it is not
    already in flight.
    
    Signed-off-by: Paul E. McKenney <paulmck@linux.ibm.com>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Reviewed-by: Frederic Weisbecker <frederic@kernel.org>
    [ paulmck: Apply Peter Zijlstra and Frederic Weisbecker atomics feedback. ]
    Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>

commit 2f0f6503e37551eb8d8d5e4d27c78d28a30fed5a
Merge: 13324c42c140 e44252f4fe79
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jul 8 12:16:40 2019 -0700

    Merge branch 'x86-timers-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull x86 timer updates from Thomas Gleixner:
     "A rather large series consolidating the HPET code, which was triggered
      by the attempt to bolt HPET NMI watchdog support on to the existing
      maze with the usual duct tape and super glue approach.
    
      This mainly removes two separate partially redundant storage layers
      and consolidates them into a single one which provides a consistent
      view of the different HPET channels and their usage and allows to
      integrate HPET NMI watchdog support (if it turns out to be feasible)
      in a non intrusive way"
    
    * 'x86-timers-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (29 commits)
      x86/hpet: Use channel for legacy clockevent storage
      x86/hpet: Use common init for legacy clockevent
      x86/hpet: Carve out shareable parts of init_one_hpet_msi_clockevent()
      x86/hpet: Consolidate clockevent functions
      x86/hpet: Wrap legacy clockevent in hpet_channel
      x86/hpet: Use cached info instead of extra flags
      x86/hpet: Move clockevents into channels
      x86/hpet: Rename variables to prepare for switching to channels
      x86/hpet: Add function to select a /dev/hpet channel
      x86/hpet: Add mode information to struct hpet_channel
      x86/hpet: Use cached channel data
      x86/hpet: Introduce struct hpet_base and struct hpet_channel
      x86/hpet: Coding style cleanup
      x86/hpet: Clean up comments
      x86/hpet: Make naming consistent
      x86/hpet: Remove not required includes
      x86/hpet: Decapitalize and rename EVT_TO_HPET_DEV
      x86/hpet: Simplify counter validation
      x86/hpet: Separate counter check out of clocksource register code
      x86/hpet: Shuffle code around for readability sake
      ...

commit 927ba67a63c72ee87d655e30183d1576c3717d3e
Merge: 2a1ccd31420a 9176ab1b8480
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jul 8 11:06:29 2019 -0700

    Merge branch 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer updates from Thomas Gleixner:
     "The timer and timekeeping departement delivers:
    
      Core:
    
       - The consolidation of the VDSO code into a generic library including
         the conversion of x86 and ARM64. Conversion of ARM and MIPS are en
         route through the relevant maintainer trees and should end up in
         5.4.
    
         This gets rid of the unnecessary different copies of the same code
         and brings all architectures on the same level of VDSO
         functionality.
    
       - Make the NTP user space interface more robust by restricting the
         TAI offset to prevent undefined behaviour. Includes a selftest.
    
       - Validate user input in the compat settimeofday() syscall to catch
         invalid values which would be turned into valid values by a
         multiplication overflow
    
       - Consolidate the time accessors
    
       - Small fixes, improvements and cleanups all over the place
    
      Drivers:
    
       - Support for the NXP system counter, TI davinci timer
    
       - Move the Microsoft HyperV clocksource/events code into the
         drivers/clocksource directory so it can be shared between x86 and
         ARM64.
    
       - Overhaul of the Tegra driver
    
       - Delay timer support for IXP4xx
    
       - Small fixes, improvements and cleanups as usual"
    
    * 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (71 commits)
      time: Validate user input in compat_settimeofday()
      timer: Document TIMER_PINNED
      clocksource/drivers: Continue making Hyper-V clocksource ISA agnostic
      clocksource/drivers: Make Hyper-V clocksource ISA agnostic
      MAINTAINERS: Fix Andy's surname and the directory entries of VDSO
      hrtimer: Use a bullet for the returns bullet list
      arm64: vdso: Fix compilation with clang older than 8
      arm64: compat: Fix __arch_get_hw_counter() implementation
      arm64: Fix __arch_get_hw_counter() implementation
      lib/vdso: Make delta calculation work correctly
      MAINTAINERS: Add entry for the generic VDSO library
      arm64: compat: No need for pre-ARMv7 barriers on an ARMv8 system
      arm64: vdso: Remove unnecessary asm-offsets.c definitions
      vdso: Remove superfluous #ifdef __KERNEL__ in vdso/datapage.h
      clocksource/drivers/davinci: Add support for clocksource
      clocksource/drivers/davinci: Add support for clockevents
      clocksource/drivers/tegra: Set up maximum-ticks limit properly
      clocksource/drivers/tegra: Cycles can't be 0
      clocksource/drivers/tegra: Restore base address before cleanup
      clocksource/drivers/tegra: Add verbose definition for 1MHz constant
      ...

commit fd1fea6834d0f9f93062ae6685862908a9baed39
Author: Michael Kelley <mikelley@microsoft.com>
Date:   Mon Jul 1 04:25:56 2019 +0000

    clocksource/drivers: Make Hyper-V clocksource ISA agnostic
    
    Hyper-V clock/timer code and data structures are currently mixed
    in with other code in the ISA independent drivers/hv directory as
    well as the ISA dependent Hyper-V code under arch/x86.
    
    Consolidate this code and data structures into a Hyper-V clocksource driver
    to better follow the Linux model. In doing so, separate out the ISA
    dependent portions so the new clocksource driver works for x86 and for the
    in-process Hyper-V on ARM64 code.
    
    To start, move the existing clockevents code to create the new clocksource
    driver. Update the VMbus driver to call initialization and cleanup routines
    since the Hyper-V synthetic timers are not independently enumerated in
    ACPI.
    
    No behavior is changed and no new functionality is added.
    
    Suggested-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Michael Kelley <mikelley@microsoft.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Vitaly Kuznetsov <vkuznets@redhat.com>
    Cc: "bp@alien8.de" <bp@alien8.de>
    Cc: "will.deacon@arm.com" <will.deacon@arm.com>
    Cc: "catalin.marinas@arm.com" <catalin.marinas@arm.com>
    Cc: "mark.rutland@arm.com" <mark.rutland@arm.com>
    Cc: "linux-arm-kernel@lists.infradead.org" <linux-arm-kernel@lists.infradead.org>
    Cc: "gregkh@linuxfoundation.org" <gregkh@linuxfoundation.org>
    Cc: "linux-hyperv@vger.kernel.org" <linux-hyperv@vger.kernel.org>
    Cc: "olaf@aepfle.de" <olaf@aepfle.de>
    Cc: "apw@canonical.com" <apw@canonical.com>
    Cc: "jasowang@redhat.com" <jasowang@redhat.com>
    Cc: "marcelo.cerri@canonical.com" <marcelo.cerri@canonical.com>
    Cc: Sunil Muthuswamy <sunilmut@microsoft.com>
    Cc: KY Srinivasan <kys@microsoft.com>
    Cc: "sashal@kernel.org" <sashal@kernel.org>
    Cc: "vincenzo.frascino@arm.com" <vincenzo.frascino@arm.com>
    Cc: "linux-arch@vger.kernel.org" <linux-arch@vger.kernel.org>
    Cc: "linux-mips@vger.kernel.org" <linux-mips@vger.kernel.org>
    Cc: "linux-kselftest@vger.kernel.org" <linux-kselftest@vger.kernel.org>
    Cc: "arnd@arndb.de" <arnd@arndb.de>
    Cc: "linux@armlinux.org.uk" <linux@armlinux.org.uk>
    Cc: "ralf@linux-mips.org" <ralf@linux-mips.org>
    Cc: "paul.burton@mips.com" <paul.burton@mips.com>
    Cc: "daniel.lezcano@linaro.org" <daniel.lezcano@linaro.org>
    Cc: "salyzyn@android.com" <salyzyn@android.com>
    Cc: "pcc@google.com" <pcc@google.com>
    Cc: "shuah@kernel.org" <shuah@kernel.org>
    Cc: "0x7f454c46@gmail.com" <0x7f454c46@gmail.com>
    Cc: "linux@rasmusvillemoes.dk" <linux@rasmusvillemoes.dk>
    Cc: "huw@codeweavers.com" <huw@codeweavers.com>
    Cc: "sfr@canb.auug.org.au" <sfr@canb.auug.org.au>
    Cc: "pbonzini@redhat.com" <pbonzini@redhat.com>
    Cc: "rkrcmar@redhat.com" <rkrcmar@redhat.com>
    Cc: "kvm@vger.kernel.org" <kvm@vger.kernel.org>
    Link: https://lkml.kernel.org/r/1561955054-1838-2-git-send-email-mikelley@microsoft.com

commit 49adaa60fa75a04457d30f38321378cdc3547212
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun Jun 23 15:24:08 2019 +0200

    x86/hpet: Use common init for legacy clockevent
    
    Replace the static initialization of the legacy clockevent with runtime
    initialization utilizing the common init function as the last preparatory
    step to switch the legacy clockevent over to the channel 0 storage in
    hpet_base.
    
    This comes with a twist. The static clockevent initializer has selected
    support for periodic and oneshot mode unconditionally whether the HPET
    config advertised periodic mode or not. Even the pre clockevents code did
    this. But....
    
    Using the conditional in hpet_init_clockevent() makes at least Qemu and one
    hardware machine fail to boot.  There are two issues which cause the boot
    failure:
    
     #1 After the timer delivery test in IOAPIC and the IOAPIC setup the next
        interrupt is not delivered despite the HPET channel being programmed
        correctly. Reprogramming the HPET after switching to IOAPIC makes it
        work again. After fixing this, the next issue surfaces:
    
     #2 Due to the unconditional periodic mode 'availability' the Local APIC
        timer calibration can hijack the global clockevents event handler
        without causing damage. Using oneshot at this stage makes if hang
        because the HPET does not get reprogrammed due to the handler
        hijacking. Duh, stupid me!
    
    Both issues require major surgery and especially the kick HPET again after
    enabling IOAPIC results in really nasty hackery.  This 'assume periodic
    works' magic has survived since HPET support got added, so it's
    questionable whether this should be fixed. Both Qemu and the failing
    hardware machine support periodic mode despite the fact that both don't
    advertise it in the configuration register and both need that extra kick
    after switching to IOAPIC. Seems to be a feature...
    
    Keep the 'assume periodic works' magic around and add a big fat comment.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Ingo Molnar <mingo@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Ricardo Neri <ricardo.neri-calderon@linux.intel.com>
    Cc: Ashok Raj <ashok.raj@intel.com>
    Cc: Andi Kleen <andi.kleen@intel.com>
    Cc: Suravee Suthikulpanit <Suravee.Suthikulpanit@amd.com>
    Cc: Stephane Eranian <eranian@google.com>
    Cc: Ravi Shankar <ravi.v.shankar@intel.com>
    Link: https://lkml.kernel.org/r/20190623132436.646565913@linutronix.de

commit ea99110dd024d2f31bde19dda049f3fbf3816a70
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun Jun 23 15:24:07 2019 +0200

    x86/hpet: Carve out shareable parts of init_one_hpet_msi_clockevent()
    
    To finally remove the static channel0/clockevent storage and to utilize the
    channel 0 storage in hpet_base, it's required to run time initialize the
    clockevent. The MSI clockevents already have a run time init function.
    
    Carve out the parts which can be shared between the legacy and the MSI
    implementation.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Ingo Molnar <mingo@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Ricardo Neri <ricardo.neri-calderon@linux.intel.com>
    Cc: Ashok Raj <ashok.raj@intel.com>
    Cc: Andi Kleen <andi.kleen@intel.com>
    Cc: Suravee Suthikulpanit <Suravee.Suthikulpanit@amd.com>
    Cc: Stephane Eranian <eranian@google.com>
    Cc: Ravi Shankar <ravi.v.shankar@intel.com>
    Link: https://lkml.kernel.org/r/20190623132436.552451082@linutronix.de

commit 310b5b3eb6ba5d3a92d783b9fa1c5a3ffb5932e9
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun Jun 23 15:24:06 2019 +0200

    x86/hpet: Consolidate clockevent functions
    
    Now that the legacy clockevent is wrapped in a hpet_channel struct most
    clockevent functions can be shared between the legacy and the MSI based
    clockevents.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Ingo Molnar <mingo@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Ricardo Neri <ricardo.neri-calderon@linux.intel.com>
    Cc: Ashok Raj <ashok.raj@intel.com>
    Cc: Andi Kleen <andi.kleen@intel.com>
    Cc: Suravee Suthikulpanit <Suravee.Suthikulpanit@amd.com>
    Cc: Stephane Eranian <eranian@google.com>
    Cc: Ravi Shankar <ravi.v.shankar@intel.com>
    Link: https://lkml.kernel.org/r/20190623132436.461437795@linutronix.de

commit 4d5e68330df4e79633bcde2bebcbfed1ba0421d5
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun Jun 23 15:24:03 2019 +0200

    x86/hpet: Move clockevents into channels
    
    Instead of allocating yet another data structure, move the clock event data
    into the channel structure. This allows further consolidation of the
    reservation code and the reuse of the cached boot config to replace the
    extra flags in the clockevent data.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Ingo Molnar <mingo@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Ricardo Neri <ricardo.neri-calderon@linux.intel.com>
    Cc: Ashok Raj <ashok.raj@intel.com>
    Cc: Andi Kleen <andi.kleen@intel.com>
    Cc: Suravee Suthikulpanit <Suravee.Suthikulpanit@amd.com>
    Cc: Stephane Eranian <eranian@google.com>
    Cc: Ravi Shankar <ravi.v.shankar@intel.com>
    Link: https://lkml.kernel.org/r/20190623132436.185851116@linutronix.de

commit af5a1dadf3fcf673906af1a1129b2b7528494ee5
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun Jun 23 15:24:01 2019 +0200

    x86/hpet: Add function to select a /dev/hpet channel
    
    If CONFIG_HPET=y is enabled the x86 specific HPET code should reserve at
    least one channel for the /dev/hpet character device, so that not all
    channels are absorbed for per CPU clockevent devices.
    
    Create a function to assign HPET_MODE_DEVICE so the rework of the
    clockevents allocation code can utilize the mode information instead of
    reducing the number of evaluated channels by #ifdef hackery.
    
    The function is not yet used, but provided as a separate patch for ease of
    review. It will be used when the rework of the clockevent selection takes
    place.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Ingo Molnar <mingo@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Ricardo Neri <ricardo.neri-calderon@linux.intel.com>
    Cc: Ashok Raj <ashok.raj@intel.com>
    Cc: Andi Kleen <andi.kleen@intel.com>
    Cc: Suravee Suthikulpanit <Suravee.Suthikulpanit@amd.com>
    Cc: Stephane Eranian <eranian@google.com>
    Cc: Ravi Shankar <ravi.v.shankar@intel.com>
    Link: https://lkml.kernel.org/r/20190623132436.002758910@linutronix.de

commit 3fe50c34dc1fa8ae2c24ec202b9decbbef72921d
Author: Ingo Molnar <mingo@kernel.org>
Date:   Sun Jun 23 15:23:55 2019 +0200

    x86/hpet: Make naming consistent
    
    Use 'evt' for clockevents pointers and capitalize HPET in comments.
    
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Ingo Molnar <mingo@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Ricardo Neri <ricardo.neri-calderon@linux.intel.com>
    Cc: Ashok Raj <ashok.raj@intel.com>
    Cc: Andi Kleen <andi.kleen@intel.com>
    Cc: Suravee Suthikulpanit <Suravee.Suthikulpanit@amd.com>
    Cc: Stephane Eranian <eranian@google.com>
    Cc: Ravi Shankar <ravi.v.shankar@intel.com>
    Link: https://lkml.kernel.org/r/20190623132435.454138339@linutronix.de

commit 721154f972aa68772f410401ebfae795b7b4c5f8
Author: Bartosz Golaszewski <bgolaszewski@baylibre.com>
Date:   Mon Jun 24 11:50:55 2019 +0200

    clocksource/drivers/davinci: Add support for clockevents
    
    Currently the clocksource and clockevent support for davinci platforms
    lives in mach-davinci. It hard-codes many things, uses global variables,
    implements functionalities unused by any platform and has code fragments
    scattered across many (often unrelated) files.
    
    Implement a new, modern and simplified timer driver and put it into
    drivers/clocksource. We still need to support legacy board files so
    export a config structure and a function that allows machine code to
    register the timer.
    
    The timer we're using is 64-bit but can be programmed in dual 32-bit
    mode (both chained and unchained).
    
    On all davinci SoCs except for da830 we're using both halves. Lower half
    for clockevents and upper half for clocksource. On da830 we're using the
    lower half for both with the help of a compare register.
    
    This patch contains the core code and support for clockevent. The
    clocksource code will be included in a subsequent patch.
    
    Signed-off-by: Bartosz Golaszewski <bgolaszewski@baylibre.com>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit 0ef6b01d024c24fad307b277cfa4a2be7d25dc29
Author: Dmitry Osipenko <digetx@gmail.com>
Date:   Tue Jun 18 17:03:57 2019 +0300

    clocksource/drivers/tegra: Cycles can't be 0
    
    Tegra's timer uses n+1 scheme for the counter, i.e. timer will fire after
    one tick if 0 is loaded. The minimum and maximum numbers of oneshot ticks
    are defined by clockevents_config_and_register(min, max) invocation and
    the min value is set to 1 tick. Hence "cycles" value can't ever be 0,
    unless it's a bug in clocksource core.
    
    Signed-off-by: Dmitry Osipenko <digetx@gmail.com>
    Acked-by: Jon Hunter <jonathanh@nvidia.com>
    Acked-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit 4aa215d0230222375c385559d98be8f119626a05
Author: Maciej enczykowski <maze@google.com>
Date:   Wed Apr 10 11:11:23 2019 -0700

    uml: fix a boot splat wrt use of cpu_all_mask
    
    [ Upstream commit 689a58605b63173acb0a8cf954af6a8f60440c93 ]
    
    Memory: 509108K/542612K available (3835K kernel code, 919K rwdata, 1028K rodata, 129K init, 211K bss, 33504K reserved, 0K cma-reserved)
    NR_IRQS: 15
    clocksource: timer: mask: 0xffffffffffffffff max_cycles: 0x1cd42e205, max_idle_ns: 881590404426 ns
    ------------[ cut here ]------------
    WARNING: CPU: 0 PID: 0 at kernel/time/clockevents.c:458 clockevents_register_device+0x72/0x140
    posix-timer cpumask == cpu_all_mask, using cpu_possible_mask instead
    Modules linked in:
    CPU: 0 PID: 0 Comm: swapper Not tainted 5.1.0-rc4-00048-ged79cc87302b #4
    Stack:
     604ebda0 603c5370 604ebe20 6046fd17
     00000000 6006fcbb 604ebdb0 603c53b5
     604ebe10 6003bfc4 604ebdd0 9000001ca
    Call Trace:
     [<6006fcbb>] ? printk+0x0/0x94
     [<60083160>] ? clockevents_register_device+0x72/0x140
     [<6001f16e>] show_stack+0x13b/0x155
     [<603c5370>] ? dump_stack_print_info+0xe2/0xeb
     [<6006fcbb>] ? printk+0x0/0x94
     [<603c53b5>] dump_stack+0x2a/0x2c
     [<6003bfc4>] __warn+0x10e/0x13e
     [<60070320>] ? vprintk_func+0xc8/0xcf
     [<60030fd6>] ? block_signals+0x0/0x16
     [<6006fcbb>] ? printk+0x0/0x94
     [<6003c08b>] warn_slowpath_fmt+0x97/0x99
     [<600311a1>] ? set_signals+0x0/0x3f
     [<6003bff4>] ? warn_slowpath_fmt+0x0/0x99
     [<600842cb>] ? tick_oneshot_mode_active+0x44/0x4f
     [<60030fd6>] ? block_signals+0x0/0x16
     [<6006fcbb>] ? printk+0x0/0x94
     [<6007d2d5>] ? __clocksource_select+0x20/0x1b1
     [<60030fd6>] ? block_signals+0x0/0x16
     [<6006fcbb>] ? printk+0x0/0x94
     [<60083160>] clockevents_register_device+0x72/0x140
     [<60031192>] ? get_signals+0x0/0xf
     [<60030fd6>] ? block_signals+0x0/0x16
     [<6006fcbb>] ? printk+0x0/0x94
     [<60002eec>] um_timer_setup+0xc8/0xca
     [<60001b59>] start_kernel+0x47f/0x57e
     [<600035bc>] start_kernel_proc+0x49/0x4d
     [<6006c483>] ? kmsg_dump_register+0x82/0x8a
     [<6001de62>] new_thread_handler+0x81/0xb2
     [<60003571>] ? kmsg_dumper_stdout_init+0x1a/0x1c
     [<60020c75>] uml_finishsetup+0x54/0x59
    
    random: get_random_bytes called from init_oops_id+0x27/0x34 with crng_init=0
    ---[ end trace 00173d0117a88acb ]---
    Calibrating delay loop... 6941.90 BogoMIPS (lpj=34709504)
    
    Signed-off-by: Maciej enczykowski <maze@google.com>
    Cc: Jeff Dike <jdike@addtoit.com>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Anton Ivanov <anton.ivanov@cambridgegreys.com>
    Cc: linux-um@lists.infradead.org
    Cc: linux-kernel@vger.kernel.org
    
    Signed-off-by: Richard Weinberger <richard@nod.at>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit c752badd81de32961b9b7b41190a920deb0337b5
Author: Maciej enczykowski <maze@google.com>
Date:   Wed Apr 10 11:11:23 2019 -0700

    uml: fix a boot splat wrt use of cpu_all_mask
    
    [ Upstream commit 689a58605b63173acb0a8cf954af6a8f60440c93 ]
    
    Memory: 509108K/542612K available (3835K kernel code, 919K rwdata, 1028K rodata, 129K init, 211K bss, 33504K reserved, 0K cma-reserved)
    NR_IRQS: 15
    clocksource: timer: mask: 0xffffffffffffffff max_cycles: 0x1cd42e205, max_idle_ns: 881590404426 ns
    ------------[ cut here ]------------
    WARNING: CPU: 0 PID: 0 at kernel/time/clockevents.c:458 clockevents_register_device+0x72/0x140
    posix-timer cpumask == cpu_all_mask, using cpu_possible_mask instead
    Modules linked in:
    CPU: 0 PID: 0 Comm: swapper Not tainted 5.1.0-rc4-00048-ged79cc87302b #4
    Stack:
     604ebda0 603c5370 604ebe20 6046fd17
     00000000 6006fcbb 604ebdb0 603c53b5
     604ebe10 6003bfc4 604ebdd0 9000001ca
    Call Trace:
     [<6006fcbb>] ? printk+0x0/0x94
     [<60083160>] ? clockevents_register_device+0x72/0x140
     [<6001f16e>] show_stack+0x13b/0x155
     [<603c5370>] ? dump_stack_print_info+0xe2/0xeb
     [<6006fcbb>] ? printk+0x0/0x94
     [<603c53b5>] dump_stack+0x2a/0x2c
     [<6003bfc4>] __warn+0x10e/0x13e
     [<60070320>] ? vprintk_func+0xc8/0xcf
     [<60030fd6>] ? block_signals+0x0/0x16
     [<6006fcbb>] ? printk+0x0/0x94
     [<6003c08b>] warn_slowpath_fmt+0x97/0x99
     [<600311a1>] ? set_signals+0x0/0x3f
     [<6003bff4>] ? warn_slowpath_fmt+0x0/0x99
     [<600842cb>] ? tick_oneshot_mode_active+0x44/0x4f
     [<60030fd6>] ? block_signals+0x0/0x16
     [<6006fcbb>] ? printk+0x0/0x94
     [<6007d2d5>] ? __clocksource_select+0x20/0x1b1
     [<60030fd6>] ? block_signals+0x0/0x16
     [<6006fcbb>] ? printk+0x0/0x94
     [<60083160>] clockevents_register_device+0x72/0x140
     [<60031192>] ? get_signals+0x0/0xf
     [<60030fd6>] ? block_signals+0x0/0x16
     [<6006fcbb>] ? printk+0x0/0x94
     [<60002eec>] um_timer_setup+0xc8/0xca
     [<60001b59>] start_kernel+0x47f/0x57e
     [<600035bc>] start_kernel_proc+0x49/0x4d
     [<6006c483>] ? kmsg_dump_register+0x82/0x8a
     [<6001de62>] new_thread_handler+0x81/0xb2
     [<60003571>] ? kmsg_dumper_stdout_init+0x1a/0x1c
     [<60020c75>] uml_finishsetup+0x54/0x59
    
    random: get_random_bytes called from init_oops_id+0x27/0x34 with crng_init=0
    ---[ end trace 00173d0117a88acb ]---
    Calibrating delay loop... 6941.90 BogoMIPS (lpj=34709504)
    
    Signed-off-by: Maciej enczykowski <maze@google.com>
    Cc: Jeff Dike <jdike@addtoit.com>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Anton Ivanov <anton.ivanov@cambridgegreys.com>
    Cc: linux-um@lists.infradead.org
    Cc: linux-kernel@vger.kernel.org
    
    Signed-off-by: Richard Weinberger <richard@nod.at>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit a4aa028267019df11696077507994510a0d84726
Author: Maciej enczykowski <maze@google.com>
Date:   Wed Apr 10 11:11:23 2019 -0700

    uml: fix a boot splat wrt use of cpu_all_mask
    
    [ Upstream commit 689a58605b63173acb0a8cf954af6a8f60440c93 ]
    
    Memory: 509108K/542612K available (3835K kernel code, 919K rwdata, 1028K rodata, 129K init, 211K bss, 33504K reserved, 0K cma-reserved)
    NR_IRQS: 15
    clocksource: timer: mask: 0xffffffffffffffff max_cycles: 0x1cd42e205, max_idle_ns: 881590404426 ns
    ------------[ cut here ]------------
    WARNING: CPU: 0 PID: 0 at kernel/time/clockevents.c:458 clockevents_register_device+0x72/0x140
    posix-timer cpumask == cpu_all_mask, using cpu_possible_mask instead
    Modules linked in:
    CPU: 0 PID: 0 Comm: swapper Not tainted 5.1.0-rc4-00048-ged79cc87302b #4
    Stack:
     604ebda0 603c5370 604ebe20 6046fd17
     00000000 6006fcbb 604ebdb0 603c53b5
     604ebe10 6003bfc4 604ebdd0 9000001ca
    Call Trace:
     [<6006fcbb>] ? printk+0x0/0x94
     [<60083160>] ? clockevents_register_device+0x72/0x140
     [<6001f16e>] show_stack+0x13b/0x155
     [<603c5370>] ? dump_stack_print_info+0xe2/0xeb
     [<6006fcbb>] ? printk+0x0/0x94
     [<603c53b5>] dump_stack+0x2a/0x2c
     [<6003bfc4>] __warn+0x10e/0x13e
     [<60070320>] ? vprintk_func+0xc8/0xcf
     [<60030fd6>] ? block_signals+0x0/0x16
     [<6006fcbb>] ? printk+0x0/0x94
     [<6003c08b>] warn_slowpath_fmt+0x97/0x99
     [<600311a1>] ? set_signals+0x0/0x3f
     [<6003bff4>] ? warn_slowpath_fmt+0x0/0x99
     [<600842cb>] ? tick_oneshot_mode_active+0x44/0x4f
     [<60030fd6>] ? block_signals+0x0/0x16
     [<6006fcbb>] ? printk+0x0/0x94
     [<6007d2d5>] ? __clocksource_select+0x20/0x1b1
     [<60030fd6>] ? block_signals+0x0/0x16
     [<6006fcbb>] ? printk+0x0/0x94
     [<60083160>] clockevents_register_device+0x72/0x140
     [<60031192>] ? get_signals+0x0/0xf
     [<60030fd6>] ? block_signals+0x0/0x16
     [<6006fcbb>] ? printk+0x0/0x94
     [<60002eec>] um_timer_setup+0xc8/0xca
     [<60001b59>] start_kernel+0x47f/0x57e
     [<600035bc>] start_kernel_proc+0x49/0x4d
     [<6006c483>] ? kmsg_dump_register+0x82/0x8a
     [<6001de62>] new_thread_handler+0x81/0xb2
     [<60003571>] ? kmsg_dumper_stdout_init+0x1a/0x1c
     [<60020c75>] uml_finishsetup+0x54/0x59
    
    random: get_random_bytes called from init_oops_id+0x27/0x34 with crng_init=0
    ---[ end trace 00173d0117a88acb ]---
    Calibrating delay loop... 6941.90 BogoMIPS (lpj=34709504)
    
    Signed-off-by: Maciej enczykowski <maze@google.com>
    Cc: Jeff Dike <jdike@addtoit.com>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Anton Ivanov <anton.ivanov@cambridgegreys.com>
    Cc: linux-um@lists.infradead.org
    Cc: linux-kernel@vger.kernel.org
    
    Signed-off-by: Richard Weinberger <richard@nod.at>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 84e5ca83b1ed5f2041c7644d1e508e44ccec77bb
Author: Maciej enczykowski <maze@google.com>
Date:   Wed Apr 10 11:11:23 2019 -0700

    uml: fix a boot splat wrt use of cpu_all_mask
    
    [ Upstream commit 689a58605b63173acb0a8cf954af6a8f60440c93 ]
    
    Memory: 509108K/542612K available (3835K kernel code, 919K rwdata, 1028K rodata, 129K init, 211K bss, 33504K reserved, 0K cma-reserved)
    NR_IRQS: 15
    clocksource: timer: mask: 0xffffffffffffffff max_cycles: 0x1cd42e205, max_idle_ns: 881590404426 ns
    ------------[ cut here ]------------
    WARNING: CPU: 0 PID: 0 at kernel/time/clockevents.c:458 clockevents_register_device+0x72/0x140
    posix-timer cpumask == cpu_all_mask, using cpu_possible_mask instead
    Modules linked in:
    CPU: 0 PID: 0 Comm: swapper Not tainted 5.1.0-rc4-00048-ged79cc87302b #4
    Stack:
     604ebda0 603c5370 604ebe20 6046fd17
     00000000 6006fcbb 604ebdb0 603c53b5
     604ebe10 6003bfc4 604ebdd0 9000001ca
    Call Trace:
     [<6006fcbb>] ? printk+0x0/0x94
     [<60083160>] ? clockevents_register_device+0x72/0x140
     [<6001f16e>] show_stack+0x13b/0x155
     [<603c5370>] ? dump_stack_print_info+0xe2/0xeb
     [<6006fcbb>] ? printk+0x0/0x94
     [<603c53b5>] dump_stack+0x2a/0x2c
     [<6003bfc4>] __warn+0x10e/0x13e
     [<60070320>] ? vprintk_func+0xc8/0xcf
     [<60030fd6>] ? block_signals+0x0/0x16
     [<6006fcbb>] ? printk+0x0/0x94
     [<6003c08b>] warn_slowpath_fmt+0x97/0x99
     [<600311a1>] ? set_signals+0x0/0x3f
     [<6003bff4>] ? warn_slowpath_fmt+0x0/0x99
     [<600842cb>] ? tick_oneshot_mode_active+0x44/0x4f
     [<60030fd6>] ? block_signals+0x0/0x16
     [<6006fcbb>] ? printk+0x0/0x94
     [<6007d2d5>] ? __clocksource_select+0x20/0x1b1
     [<60030fd6>] ? block_signals+0x0/0x16
     [<6006fcbb>] ? printk+0x0/0x94
     [<60083160>] clockevents_register_device+0x72/0x140
     [<60031192>] ? get_signals+0x0/0xf
     [<60030fd6>] ? block_signals+0x0/0x16
     [<6006fcbb>] ? printk+0x0/0x94
     [<60002eec>] um_timer_setup+0xc8/0xca
     [<60001b59>] start_kernel+0x47f/0x57e
     [<600035bc>] start_kernel_proc+0x49/0x4d
     [<6006c483>] ? kmsg_dump_register+0x82/0x8a
     [<6001de62>] new_thread_handler+0x81/0xb2
     [<60003571>] ? kmsg_dumper_stdout_init+0x1a/0x1c
     [<60020c75>] uml_finishsetup+0x54/0x59
    
    random: get_random_bytes called from init_oops_id+0x27/0x34 with crng_init=0
    ---[ end trace 00173d0117a88acb ]---
    Calibrating delay loop... 6941.90 BogoMIPS (lpj=34709504)
    
    Signed-off-by: Maciej enczykowski <maze@google.com>
    Cc: Jeff Dike <jdike@addtoit.com>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Anton Ivanov <anton.ivanov@cambridgegreys.com>
    Cc: linux-um@lists.infradead.org
    Cc: linux-kernel@vger.kernel.org
    
    Signed-off-by: Richard Weinberger <richard@nod.at>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 689a58605b63173acb0a8cf954af6a8f60440c93
Author: Maciej enczykowski <maze@google.com>
Date:   Wed Apr 10 11:11:23 2019 -0700

    uml: fix a boot splat wrt use of cpu_all_mask
    
    Memory: 509108K/542612K available (3835K kernel code, 919K rwdata, 1028K rodata, 129K init, 211K bss, 33504K reserved, 0K cma-reserved)
    NR_IRQS: 15
    clocksource: timer: mask: 0xffffffffffffffff max_cycles: 0x1cd42e205, max_idle_ns: 881590404426 ns
    ------------[ cut here ]------------
    WARNING: CPU: 0 PID: 0 at kernel/time/clockevents.c:458 clockevents_register_device+0x72/0x140
    posix-timer cpumask == cpu_all_mask, using cpu_possible_mask instead
    Modules linked in:
    CPU: 0 PID: 0 Comm: swapper Not tainted 5.1.0-rc4-00048-ged79cc87302b #4
    Stack:
     604ebda0 603c5370 604ebe20 6046fd17
     00000000 6006fcbb 604ebdb0 603c53b5
     604ebe10 6003bfc4 604ebdd0 9000001ca
    Call Trace:
     [<6006fcbb>] ? printk+0x0/0x94
     [<60083160>] ? clockevents_register_device+0x72/0x140
     [<6001f16e>] show_stack+0x13b/0x155
     [<603c5370>] ? dump_stack_print_info+0xe2/0xeb
     [<6006fcbb>] ? printk+0x0/0x94
     [<603c53b5>] dump_stack+0x2a/0x2c
     [<6003bfc4>] __warn+0x10e/0x13e
     [<60070320>] ? vprintk_func+0xc8/0xcf
     [<60030fd6>] ? block_signals+0x0/0x16
     [<6006fcbb>] ? printk+0x0/0x94
     [<6003c08b>] warn_slowpath_fmt+0x97/0x99
     [<600311a1>] ? set_signals+0x0/0x3f
     [<6003bff4>] ? warn_slowpath_fmt+0x0/0x99
     [<600842cb>] ? tick_oneshot_mode_active+0x44/0x4f
     [<60030fd6>] ? block_signals+0x0/0x16
     [<6006fcbb>] ? printk+0x0/0x94
     [<6007d2d5>] ? __clocksource_select+0x20/0x1b1
     [<60030fd6>] ? block_signals+0x0/0x16
     [<6006fcbb>] ? printk+0x0/0x94
     [<60083160>] clockevents_register_device+0x72/0x140
     [<60031192>] ? get_signals+0x0/0xf
     [<60030fd6>] ? block_signals+0x0/0x16
     [<6006fcbb>] ? printk+0x0/0x94
     [<60002eec>] um_timer_setup+0xc8/0xca
     [<60001b59>] start_kernel+0x47f/0x57e
     [<600035bc>] start_kernel_proc+0x49/0x4d
     [<6006c483>] ? kmsg_dump_register+0x82/0x8a
     [<6001de62>] new_thread_handler+0x81/0xb2
     [<60003571>] ? kmsg_dumper_stdout_init+0x1a/0x1c
     [<60020c75>] uml_finishsetup+0x54/0x59
    
    random: get_random_bytes called from init_oops_id+0x27/0x34 with crng_init=0
    ---[ end trace 00173d0117a88acb ]---
    Calibrating delay loop... 6941.90 BogoMIPS (lpj=34709504)
    
    Signed-off-by: Maciej enczykowski <maze@google.com>
    Cc: Jeff Dike <jdike@addtoit.com>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Anton Ivanov <anton.ivanov@cambridgegreys.com>
    Cc: linux-um@lists.infradead.org
    Cc: linux-kernel@vger.kernel.org
    
    Signed-off-by: Richard Weinberger <richard@nod.at>

commit f6efc18bbfc3136a829f081388368d75f0b55923
Author: Max Filippov <jcmvbkbc@gmail.com>
Date:   Mon Jan 29 09:09:41 2018 -0800

    xtensa: SMP: fix ccount_timer_shutdown
    
    [ Upstream commit 4fe8713b873fc881284722ce4ac47995de7cf62c ]
    
    ccount_timer_shutdown is called from the atomic context in the
    secondary_start_kernel, resulting in the following BUG:
    
    BUG: sleeping function called from invalid context
    in_atomic(): 1, irqs_disabled(): 1, pid: 0, name: swapper/1
    Preemption disabled at:
      secondary_start_kernel+0xa1/0x130
    Call Trace:
      ___might_sleep+0xe7/0xfc
      __might_sleep+0x41/0x44
      synchronize_irq+0x24/0x64
      disable_irq+0x11/0x14
      ccount_timer_shutdown+0x12/0x20
      clockevents_switch_state+0x82/0xb4
      clockevents_exchange_device+0x54/0x60
      tick_check_new_device+0x46/0x70
      clockevents_register_device+0x8c/0xc8
      clockevents_config_and_register+0x1d/0x2c
      local_timer_setup+0x75/0x7c
      secondary_start_kernel+0xb4/0x130
      should_never_return+0x32/0x35
    
    Use disable_irq_nosync instead of disable_irq to avoid it.
    This is safe because the ccount timer IRQ is per-CPU, and once IRQ is
    masked the ISR will not be called.
    
    Signed-off-by: Max Filippov <jcmvbkbc@gmail.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit aa9b819beeca166b31ca52288a8aae94cdf99a50
Author: Max Filippov <jcmvbkbc@gmail.com>
Date:   Mon Jan 29 09:09:41 2018 -0800

    xtensa: SMP: fix ccount_timer_shutdown
    
    [ Upstream commit 4fe8713b873fc881284722ce4ac47995de7cf62c ]
    
    ccount_timer_shutdown is called from the atomic context in the
    secondary_start_kernel, resulting in the following BUG:
    
    BUG: sleeping function called from invalid context
    in_atomic(): 1, irqs_disabled(): 1, pid: 0, name: swapper/1
    Preemption disabled at:
      secondary_start_kernel+0xa1/0x130
    Call Trace:
      ___might_sleep+0xe7/0xfc
      __might_sleep+0x41/0x44
      synchronize_irq+0x24/0x64
      disable_irq+0x11/0x14
      ccount_timer_shutdown+0x12/0x20
      clockevents_switch_state+0x82/0xb4
      clockevents_exchange_device+0x54/0x60
      tick_check_new_device+0x46/0x70
      clockevents_register_device+0x8c/0xc8
      clockevents_config_and_register+0x1d/0x2c
      local_timer_setup+0x75/0x7c
      secondary_start_kernel+0xb4/0x130
      should_never_return+0x32/0x35
    
    Use disable_irq_nosync instead of disable_irq to avoid it.
    This is safe because the ccount timer IRQ is per-CPU, and once IRQ is
    masked the ISR will not be called.
    
    Signed-off-by: Max Filippov <jcmvbkbc@gmail.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 2c4f5f56327c919c8d5bccb1a1f002ede41b2876
Author: Max Filippov <jcmvbkbc@gmail.com>
Date:   Mon Jan 29 09:09:41 2018 -0800

    xtensa: SMP: fix ccount_timer_shutdown
    
    [ Upstream commit 4fe8713b873fc881284722ce4ac47995de7cf62c ]
    
    ccount_timer_shutdown is called from the atomic context in the
    secondary_start_kernel, resulting in the following BUG:
    
    BUG: sleeping function called from invalid context
    in_atomic(): 1, irqs_disabled(): 1, pid: 0, name: swapper/1
    Preemption disabled at:
      secondary_start_kernel+0xa1/0x130
    Call Trace:
      ___might_sleep+0xe7/0xfc
      __might_sleep+0x41/0x44
      synchronize_irq+0x24/0x64
      disable_irq+0x11/0x14
      ccount_timer_shutdown+0x12/0x20
      clockevents_switch_state+0x82/0xb4
      clockevents_exchange_device+0x54/0x60
      tick_check_new_device+0x46/0x70
      clockevents_register_device+0x8c/0xc8
      clockevents_config_and_register+0x1d/0x2c
      local_timer_setup+0x75/0x7c
      secondary_start_kernel+0xb4/0x130
      should_never_return+0x32/0x35
    
    Use disable_irq_nosync instead of disable_irq to avoid it.
    This is safe because the ccount timer IRQ is per-CPU, and once IRQ is
    masked the ISR will not be called.
    
    Signed-off-by: Max Filippov <jcmvbkbc@gmail.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 51cbb781d215eed7ee9146eef96fdce7cbe98132
Author: Max Filippov <jcmvbkbc@gmail.com>
Date:   Mon Jan 29 09:09:41 2018 -0800

    xtensa: SMP: fix ccount_timer_shutdown
    
    [ Upstream commit 4fe8713b873fc881284722ce4ac47995de7cf62c ]
    
    ccount_timer_shutdown is called from the atomic context in the
    secondary_start_kernel, resulting in the following BUG:
    
    BUG: sleeping function called from invalid context
    in_atomic(): 1, irqs_disabled(): 1, pid: 0, name: swapper/1
    Preemption disabled at:
      secondary_start_kernel+0xa1/0x130
    Call Trace:
      ___might_sleep+0xe7/0xfc
      __might_sleep+0x41/0x44
      synchronize_irq+0x24/0x64
      disable_irq+0x11/0x14
      ccount_timer_shutdown+0x12/0x20
      clockevents_switch_state+0x82/0xb4
      clockevents_exchange_device+0x54/0x60
      tick_check_new_device+0x46/0x70
      clockevents_register_device+0x8c/0xc8
      clockevents_config_and_register+0x1d/0x2c
      local_timer_setup+0x75/0x7c
      secondary_start_kernel+0xb4/0x130
      should_never_return+0x32/0x35
    
    Use disable_irq_nosync instead of disable_irq to avoid it.
    This is safe because the ccount timer IRQ is per-CPU, and once IRQ is
    masked the ISR will not be called.
    
    Signed-off-by: Max Filippov <jcmvbkbc@gmail.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit f43e42f46aa87bc0507bde9a0cd6ead663ba6a30
Author: Max Filippov <jcmvbkbc@gmail.com>
Date:   Mon Jan 29 09:09:41 2018 -0800

    xtensa: SMP: fix ccount_timer_shutdown
    
    [ Upstream commit 4fe8713b873fc881284722ce4ac47995de7cf62c ]
    
    ccount_timer_shutdown is called from the atomic context in the
    secondary_start_kernel, resulting in the following BUG:
    
    BUG: sleeping function called from invalid context
    in_atomic(): 1, irqs_disabled(): 1, pid: 0, name: swapper/1
    Preemption disabled at:
      secondary_start_kernel+0xa1/0x130
    Call Trace:
      ___might_sleep+0xe7/0xfc
      __might_sleep+0x41/0x44
      synchronize_irq+0x24/0x64
      disable_irq+0x11/0x14
      ccount_timer_shutdown+0x12/0x20
      clockevents_switch_state+0x82/0xb4
      clockevents_exchange_device+0x54/0x60
      tick_check_new_device+0x46/0x70
      clockevents_register_device+0x8c/0xc8
      clockevents_config_and_register+0x1d/0x2c
      local_timer_setup+0x75/0x7c
      secondary_start_kernel+0xb4/0x130
      should_never_return+0x32/0x35
    
    Use disable_irq_nosync instead of disable_irq to avoid it.
    This is safe because the ccount timer IRQ is per-CPU, and once IRQ is
    masked the ISR will not be called.
    
    Signed-off-by: Max Filippov <jcmvbkbc@gmail.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 8dd2eee2f444a7a570599bffc9da330157cca5b5
Merge: 75b710af7139 f40f4fc9506d
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Feb 23 17:21:53 2019 +0100

    Merge branch 'clockevents/5.1' of https://git.linaro.org/people/daniel.lezcano/linux into timers/core
    
    Pull clockevents updates from Daniel Lezcano:
    
     - Update the binding documentation for the gpt timer (Anson Huang)
    
     - Improve checking and error handling at init time on risc timer (Atish
       Patra)
    
     - Update the binding documentation for r8a774c0 cmt and tmu (Biju Das)
    
     - Fail gracefully when clock rate is unavailable on sun5i (Chen-Yu Tsai)
    
     - Rename the tango-xtal, pxa and cs5535 to timer-*.c for consistency
       (Daniel Lezcano)
    
     - Add the support for the tegra210 timer and add the platform's Kconfig
       selection (Joseph Lo)
    
     - Do a cleanup in the header inclusions and remove the unused ones for the
       exynos_mct timer driver (Krzysztof Kozlowski)
    
     - Remove some non-of dead code and fix the error path when initializing
       the resources in the exynos_mct timer driver (Marek Szyprowski)
    
     - Update the DT bindings for the MT7629 (Ryder Lee)
    
     - Provide a workaround for the arm arch timer for Allwinner A64 timers
       (Samuel Holland)
    
     - Clear the timer interrupt at shutdown time on the exynos_mct timer
       driver (Stuart Menefy)

commit 6dc5ad52fe628c39ceb3fe0c1d252bb082418c48
Author: Michael Kelley <mikelley@microsoft.com>
Date:   Sun Nov 4 03:48:54 2018 +0000

    clockevents/drivers/i8253: Add support for PIT shutdown quirk
    
    commit 35b69a420bfb56b7b74cb635ea903db05e357bec upstream.
    
    Add support for platforms where pit_shutdown() doesn't work because of a
    quirk in the PIT emulation. On these platforms setting the counter register
    to zero causes the PIT to start running again, negating the shutdown.
    
    Provide a global variable that controls whether the counter register is
    zero'ed, which platform specific code can override.
    
    Signed-off-by: Michael Kelley <mikelley@microsoft.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: "gregkh@linuxfoundation.org" <gregkh@linuxfoundation.org>
    Cc: "devel@linuxdriverproject.org" <devel@linuxdriverproject.org>
    Cc: "daniel.lezcano@linaro.org" <daniel.lezcano@linaro.org>
    Cc: "virtualization@lists.linux-foundation.org" <virtualization@lists.linux-foundation.org>
    Cc: "jgross@suse.com" <jgross@suse.com>
    Cc: "akataria@vmware.com" <akataria@vmware.com>
    Cc: "olaf@aepfle.de" <olaf@aepfle.de>
    Cc: "apw@canonical.com" <apw@canonical.com>
    Cc: vkuznets <vkuznets@redhat.com>
    Cc: "jasowang@redhat.com" <jasowang@redhat.com>
    Cc: "marcelo.cerri@canonical.com" <marcelo.cerri@canonical.com>
    Cc: KY Srinivasan <kys@microsoft.com>
    Link: https://lkml.kernel.org/r/1541303219-11142-2-git-send-email-mikelley@microsoft.com
    [bwh: Backported to 3.16:
     - Don't use __ro_after_init
     - Adjust context, indentation]
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit 4fe8713b873fc881284722ce4ac47995de7cf62c
Author: Max Filippov <jcmvbkbc@gmail.com>
Date:   Mon Jan 29 09:09:41 2018 -0800

    xtensa: SMP: fix ccount_timer_shutdown
    
    ccount_timer_shutdown is called from the atomic context in the
    secondary_start_kernel, resulting in the following BUG:
    
    BUG: sleeping function called from invalid context
    in_atomic(): 1, irqs_disabled(): 1, pid: 0, name: swapper/1
    Preemption disabled at:
      secondary_start_kernel+0xa1/0x130
    Call Trace:
      ___might_sleep+0xe7/0xfc
      __might_sleep+0x41/0x44
      synchronize_irq+0x24/0x64
      disable_irq+0x11/0x14
      ccount_timer_shutdown+0x12/0x20
      clockevents_switch_state+0x82/0xb4
      clockevents_exchange_device+0x54/0x60
      tick_check_new_device+0x46/0x70
      clockevents_register_device+0x8c/0xc8
      clockevents_config_and_register+0x1d/0x2c
      local_timer_setup+0x75/0x7c
      secondary_start_kernel+0xb4/0x130
      should_never_return+0x32/0x35
    
    Use disable_irq_nosync instead of disable_irq to avoid it.
    This is safe because the ccount timer IRQ is per-CPU, and once IRQ is
    masked the ISR will not be called.
    
    Signed-off-by: Max Filippov <jcmvbkbc@gmail.com>

commit 8a5aaf97cc4876a9b61cb3b7c07128d4569ac536
Author: Guo Ren <ren_guo@c-sky.com>
Date:   Fri Jan 4 11:17:33 2019 +0800

    Documentation/features: Add csky kernel features
    
          core/ cBPF-JIT             : TODO |
          core/ eBPF-JIT             : TODO |
          core/ generic-idle-thread  :  ok  |
          core/ jump-labels          : TODO |
          core/ tracehook            :  ok  |
         debug/ KASAN                : TODO |
         debug/ gcov-profile-all     : TODO |
         debug/ kgdb                 : TODO |
         debug/ kprobes-on-ftrace    : TODO |
         debug/ kprobes              : TODO |
         debug/ kretprobes           : TODO |
         debug/ optprobes            : TODO |
         debug/ stackprotector       : TODO |
         debug/ uprobes              : TODO |
         debug/ user-ret-profiler    : TODO |
            io/ dma-contiguous       :  ok  |
       locking/ cmpxchg-local        : TODO |
       locking/ lockdep              : TODO |
       locking/ queued-rwlocks       :  ok  |
       locking/ queued-spinlocks     : TODO |
       locking/ rwsem-optimized      : TODO |
          perf/ kprobes-event        : TODO |
          perf/ perf-regs            : TODO |
          perf/ perf-stackdump       : TODO |
         sched/ membarrier-sync-core : TODO |
         sched/ numa-balancing       :  ..  |
       seccomp/ seccomp-filter       : TODO |
          time/ arch-tick-broadcast  : TODO |
          time/ clockevents          :  ok  |
          time/ context-tracking     : TODO |
          time/ irq-time-acct        : TODO |
          time/ modern-timekeeping   :  ok  |
          time/ virt-cpuacct         : TODO |
            vm/ ELF-ASLR             : TODO |
            vm/ PG_uncached          : TODO |
            vm/ THP                  :  ..  |
            vm/ batch-unmap-tlb-flush: TODO |
            vm/ huge-vmap            : TODO |
            vm/ ioremap_prot         : TODO |
            vm/ numa-memblock        :  ..  |
            vm/ pte_special          : TODO |
    
    Signed-off-by: Guo Ren <ren_guo@c-sky.com>
    Cc: Arnd Bergmann <arnd@arndb.de>

commit bbb8a75208937beee3bba746da7addb194588619
Author: Manuel Lauss <manuel.lauss@gmail.com>
Date:   Wed Dec 19 08:07:59 2018 +0100

    MIPS: alchemy: cpu_all_mask is forbidden for clock event devices
    
    change alchemy clock event device cpu_all_mask to cpu_possible_mask.
    Gets rid of a warning, which then does the same substitution:
    WARNING: CPU: 0 PID: 0 at kernel/time/clockevents.c:468 clockevents_register_device+0x130/0x140
    rtcmatch2 cpumask == cpu_all_mask, using cpu_possible_mask instead
    
    Signed-off-by: Manuel Lauss <manuel.lauss@gmail.com>
    Signed-off-by: Paul Burton <paul.burton@mips.com>
    Cc: Linux-MIPS <linux-mips@vger.kernel.org>

commit bd2bcaa565a2c07dd0492f6172f3ab6ad27c1acc
Merge: 615740fd6b0c 2e64d317e197
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Dec 19 11:34:49 2018 +0100

    Merge branch 'clockevents/4.21' of http://git.linaro.org/people/daniel.lezcano/linux into timers/core
    
    Pull clockevents/source update from Daniel Lezcano:
    
     - Add dt-bindings for RDA8810PL SoC (Manivannan Sadhasivam)

commit 615740fd6b0c44e6ba1beaa87ddbdf7ead57ecf4
Merge: 07daef8b41e0 7f83a1327962
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Dec 18 22:57:38 2018 +0100

    Merge branch 'clockevents/4.21' of http://git.linaro.org/people/daniel.lezcano/linux into timers/core
    
    Pull clocksource/event changes from Daniel Lezcano:
    
     - Add the sched_clock for the arc timer (Alexey Brodkin)
    
     - Change the file timer names for riscv, rockchip, tegra20, sun4i and
       meson6 (Daniel Lezcano)
    
     - Add the DT bindings for r8a7796, r8a77470 and r8a774a1 (Biju Das)
    
     - Remove the early platform driver registration for timer-ti-dm (Bartosz
       Golaszewski)
    
     - Provide the sched_clock for the riscv timer (Anup Patel)
    
     - Add support for ARM64 for the imx-gpt and convert the imx-tpm to the
       timer-of API (Anson Huang)
    
     - Remove useless irq protection for the imx-gpt (Clment Pron)
    
     - Remove a duplicate function name for the vt8500 (Dan Carpenter)
    
     - Remove obsolete inclusion of <asm/smp_twd.h> for the tegra20 (Geert
       Uytterhoeven)
    
     - Demote the prcmu and the custom sched_clock for the dbx500 and the ux500
       (Linus Walleij)
    
     - Add a new timer clock for the RDA8810PL (Manivannan Sadhasivam)
    
     - Rename the macro to stick to the register name and add the delay timer
       (Martin Blumenstingl)
    
     - Switch the bcm2835 to the SPDX identifier (Stefan Wahren)
    
     - Fix the interrupt register access on the fttmr010 (Tao Ren)
    
     - Add missing of_node_put in the initialization path on the
       integrator-ap (Yangtao Li)

commit 7f83a1327962b9b3712866db8cbafbdee239cce4
Author: Manivannan Sadhasivam <manivannan.sadhasivam@linaro.org>
Date:   Mon Dec 10 23:05:46 2018 +0530

    clocksource/drivers/rda: Add clock driver for RDA8810PL SoC
    
    Add clock driver for RDA Micro RDA8810PL SoC supporting OSTIMER
    and HWTIMER.
    
    RDA8810PL has two independent timers: OSTIMER (56 bit) and HWTIMER
    (64 bit). Each timer provides optional interrupt support. In this
    driver, OSTIMER is used for clockevents and HWTIMER is used for
    clocksource.
    
    Signed-off-by: Andreas Frber <afaerber@suse.de>
    Signed-off-by: Manivannan Sadhasivam <manivannan.sadhasivam@linaro.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit 7b59263801077e480be79e5f9a3a3bcdefeb05b8
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Thu Nov 15 11:00:37 2018 +0100

    clockevents/drivers/tegra20: Remove obsolete inclusion of <asm/smp_twd.h>
    
    As of commit da4a686a2cfb077a ("ARM: smp_twd: convert to use CLKSRC_OF
    init"), this header file is no longer used.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Acked-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit d999c0ec2498e54b9328db6b2c1037710025add1
Author: Roland Dreier <roland@purestorage.com>
Date:   Fri Nov 30 13:14:50 2018 -0800

    x86/hpet: Remove unused FSEC_PER_NSEC define
    
    The FSEC_PER_NSEC macro has had zero users since commit
    
      ab0e08f15d23 ("x86: hpet: Cleanup the clockevents init and register code").
    
    Remove it.
    
    Signed-off-by: Roland Dreier <roland@purestorage.com>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: x86-ml <x86@kernel.org>
    Link: https://lkml.kernel.org/r/20181130211450.5200-1-roland@purestorage.com

commit f49c174b5f431db9fa17315269e288d4548b651c
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Oct 31 19:21:10 2018 +0100

    hrtimers/tick/clockevents: Remove sloppy license references
    
    "For licencing details see kernel-base/COPYING" and similar license
    references have no value over the SPDX identifier. Remove them.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Kees Cook <keescook@chromium.org>
    Acked-by: Ingo Molnar <mingo@kernel.org>
    Acked-by: John Stultz <john.stultz@linaro.org>
    Acked-by: Corey Minyard <cminyard@mvista.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Cc: Peter Anvin <hpa@zytor.com>
    Cc: Russell King <rmk+kernel@armlinux.org.uk>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: "Paul E. McKenney" <paulmck@linux.vnet.ibm.com>
    Cc: Nicolas Pitre <nicolas.pitre@linaro.org>
    Cc: David Riley <davidriley@chromium.org>
    Cc: Colin Cross <ccross@android.com>
    Cc: Mark Brown <broonie@kernel.org>
    Link: https://lkml.kernel.org/r/20181031182252.963632760@linutronix.de

commit 989e44d6d2688a9bb162589a719410d6e7898502
Author: Michael Kelley <mikelley@microsoft.com>
Date:   Sun Nov 4 03:48:54 2018 +0000

    clockevents/drivers/i8253: Add support for PIT shutdown quirk
    
    commit 35b69a420bfb56b7b74cb635ea903db05e357bec upstream.
    
    Add support for platforms where pit_shutdown() doesn't work because of a
    quirk in the PIT emulation. On these platforms setting the counter register
    to zero causes the PIT to start running again, negating the shutdown.
    
    Provide a global variable that controls whether the counter register is
    zero'ed, which platform specific code can override.
    
    Signed-off-by: Michael Kelley <mikelley@microsoft.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: "gregkh@linuxfoundation.org" <gregkh@linuxfoundation.org>
    Cc: "devel@linuxdriverproject.org" <devel@linuxdriverproject.org>
    Cc: "daniel.lezcano@linaro.org" <daniel.lezcano@linaro.org>
    Cc: "virtualization@lists.linux-foundation.org" <virtualization@lists.linux-foundation.org>
    Cc: "jgross@suse.com" <jgross@suse.com>
    Cc: "akataria@vmware.com" <akataria@vmware.com>
    Cc: "olaf@aepfle.de" <olaf@aepfle.de>
    Cc: "apw@canonical.com" <apw@canonical.com>
    Cc: vkuznets <vkuznets@redhat.com>
    Cc: "jasowang@redhat.com" <jasowang@redhat.com>
    Cc: "marcelo.cerri@canonical.com" <marcelo.cerri@canonical.com>
    Cc: KY Srinivasan <kys@microsoft.com>
    Cc: stable@vger.kernel.org
    Link: https://lkml.kernel.org/r/1541303219-11142-2-git-send-email-mikelley@microsoft.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit f6939dbd8071a95d536c4c92a5a0d1426a9e8fd3
Author: Michael Kelley <mikelley@microsoft.com>
Date:   Sun Nov 4 03:48:54 2018 +0000

    clockevents/drivers/i8253: Add support for PIT shutdown quirk
    
    commit 35b69a420bfb56b7b74cb635ea903db05e357bec upstream.
    
    Add support for platforms where pit_shutdown() doesn't work because of a
    quirk in the PIT emulation. On these platforms setting the counter register
    to zero causes the PIT to start running again, negating the shutdown.
    
    Provide a global variable that controls whether the counter register is
    zero'ed, which platform specific code can override.
    
    Signed-off-by: Michael Kelley <mikelley@microsoft.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: "gregkh@linuxfoundation.org" <gregkh@linuxfoundation.org>
    Cc: "devel@linuxdriverproject.org" <devel@linuxdriverproject.org>
    Cc: "daniel.lezcano@linaro.org" <daniel.lezcano@linaro.org>
    Cc: "virtualization@lists.linux-foundation.org" <virtualization@lists.linux-foundation.org>
    Cc: "jgross@suse.com" <jgross@suse.com>
    Cc: "akataria@vmware.com" <akataria@vmware.com>
    Cc: "olaf@aepfle.de" <olaf@aepfle.de>
    Cc: "apw@canonical.com" <apw@canonical.com>
    Cc: vkuznets <vkuznets@redhat.com>
    Cc: "jasowang@redhat.com" <jasowang@redhat.com>
    Cc: "marcelo.cerri@canonical.com" <marcelo.cerri@canonical.com>
    Cc: KY Srinivasan <kys@microsoft.com>
    Cc: stable@vger.kernel.org
    Link: https://lkml.kernel.org/r/1541303219-11142-2-git-send-email-mikelley@microsoft.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 79d80b876396693e5b6d7d345963b83a2f917816
Author: Michael Kelley <mikelley@microsoft.com>
Date:   Sun Nov 4 03:48:54 2018 +0000

    clockevents/drivers/i8253: Add support for PIT shutdown quirk
    
    commit 35b69a420bfb56b7b74cb635ea903db05e357bec upstream.
    
    Add support for platforms where pit_shutdown() doesn't work because of a
    quirk in the PIT emulation. On these platforms setting the counter register
    to zero causes the PIT to start running again, negating the shutdown.
    
    Provide a global variable that controls whether the counter register is
    zero'ed, which platform specific code can override.
    
    Signed-off-by: Michael Kelley <mikelley@microsoft.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: "gregkh@linuxfoundation.org" <gregkh@linuxfoundation.org>
    Cc: "devel@linuxdriverproject.org" <devel@linuxdriverproject.org>
    Cc: "daniel.lezcano@linaro.org" <daniel.lezcano@linaro.org>
    Cc: "virtualization@lists.linux-foundation.org" <virtualization@lists.linux-foundation.org>
    Cc: "jgross@suse.com" <jgross@suse.com>
    Cc: "akataria@vmware.com" <akataria@vmware.com>
    Cc: "olaf@aepfle.de" <olaf@aepfle.de>
    Cc: "apw@canonical.com" <apw@canonical.com>
    Cc: vkuznets <vkuznets@redhat.com>
    Cc: "jasowang@redhat.com" <jasowang@redhat.com>
    Cc: "marcelo.cerri@canonical.com" <marcelo.cerri@canonical.com>
    Cc: KY Srinivasan <kys@microsoft.com>
    Cc: stable@vger.kernel.org
    Link: https://lkml.kernel.org/r/1541303219-11142-2-git-send-email-mikelley@microsoft.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit d4b97e20c7ea4057bf1d006cecf2270f6e0ec7b1
Author: Michael Kelley <mikelley@microsoft.com>
Date:   Sun Nov 4 03:48:54 2018 +0000

    clockevents/drivers/i8253: Add support for PIT shutdown quirk
    
    commit 35b69a420bfb56b7b74cb635ea903db05e357bec upstream.
    
    Add support for platforms where pit_shutdown() doesn't work because of a
    quirk in the PIT emulation. On these platforms setting the counter register
    to zero causes the PIT to start running again, negating the shutdown.
    
    Provide a global variable that controls whether the counter register is
    zero'ed, which platform specific code can override.
    
    Signed-off-by: Michael Kelley <mikelley@microsoft.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: "gregkh@linuxfoundation.org" <gregkh@linuxfoundation.org>
    Cc: "devel@linuxdriverproject.org" <devel@linuxdriverproject.org>
    Cc: "daniel.lezcano@linaro.org" <daniel.lezcano@linaro.org>
    Cc: "virtualization@lists.linux-foundation.org" <virtualization@lists.linux-foundation.org>
    Cc: "jgross@suse.com" <jgross@suse.com>
    Cc: "akataria@vmware.com" <akataria@vmware.com>
    Cc: "olaf@aepfle.de" <olaf@aepfle.de>
    Cc: "apw@canonical.com" <apw@canonical.com>
    Cc: vkuznets <vkuznets@redhat.com>
    Cc: "jasowang@redhat.com" <jasowang@redhat.com>
    Cc: "marcelo.cerri@canonical.com" <marcelo.cerri@canonical.com>
    Cc: KY Srinivasan <kys@microsoft.com>
    Cc: stable@vger.kernel.org
    Link: https://lkml.kernel.org/r/1541303219-11142-2-git-send-email-mikelley@microsoft.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit ebbc6fce6d2cb84e43245ba77b385323ace747b2
Author: Michael Kelley <mikelley@microsoft.com>
Date:   Sun Nov 4 03:48:54 2018 +0000

    clockevents/drivers/i8253: Add support for PIT shutdown quirk
    
    commit 35b69a420bfb56b7b74cb635ea903db05e357bec upstream.
    
    Add support for platforms where pit_shutdown() doesn't work because of a
    quirk in the PIT emulation. On these platforms setting the counter register
    to zero causes the PIT to start running again, negating the shutdown.
    
    Provide a global variable that controls whether the counter register is
    zero'ed, which platform specific code can override.
    
    Signed-off-by: Michael Kelley <mikelley@microsoft.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: "gregkh@linuxfoundation.org" <gregkh@linuxfoundation.org>
    Cc: "devel@linuxdriverproject.org" <devel@linuxdriverproject.org>
    Cc: "daniel.lezcano@linaro.org" <daniel.lezcano@linaro.org>
    Cc: "virtualization@lists.linux-foundation.org" <virtualization@lists.linux-foundation.org>
    Cc: "jgross@suse.com" <jgross@suse.com>
    Cc: "akataria@vmware.com" <akataria@vmware.com>
    Cc: "olaf@aepfle.de" <olaf@aepfle.de>
    Cc: "apw@canonical.com" <apw@canonical.com>
    Cc: vkuznets <vkuznets@redhat.com>
    Cc: "jasowang@redhat.com" <jasowang@redhat.com>
    Cc: "marcelo.cerri@canonical.com" <marcelo.cerri@canonical.com>
    Cc: KY Srinivasan <kys@microsoft.com>
    Cc: stable@vger.kernel.org
    Link: https://lkml.kernel.org/r/1541303219-11142-2-git-send-email-mikelley@microsoft.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit b6df7b6db1c1837fc9eada74ed561cbfe7746755
Merge: 655c6b977755 15035388439f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Nov 11 16:41:50 2018 -0600

    Merge branch 'x86-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull x86 fixes from Thomas Gleixner:
     "A set of x86 fixes:
    
       - Cure the LDT remapping to user space on 5 level paging which ended
         up in the KASLR space
    
       - Remove LDT mapping before freeing the LDT pages
    
       - Make NFIT MCE handling more robust
    
       - Unbreak the VSMP build by removing the dependency on paravirt ops
    
       - Support broken PIT emulation on Microsoft hyperV
    
       - Don't trace vmware_sched_clock() to avoid tracer recursion
    
       - Remove -pipe from KBUILD CFLAGS which breaks clang and is also
         slower on GCC
    
       - Trivial coding style and typo fixes"
    
    * 'x86-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      x86/cpu/vmware: Do not trace vmware_sched_clock()
      x86/vsmp: Remove dependency on pv_irq_ops
      x86/ldt: Remove unused variable in map_ldt_struct()
      x86/ldt: Unmap PTEs for the slot before freeing LDT pages
      x86/mm: Move LDT remap out of KASLR region on 5-level paging
      acpi/nfit, x86/mce: Validate a MCE's address before using it
      acpi/nfit, x86/mce: Handle only uncorrectable machine checks
      x86/build: Remove -pipe from KBUILD_CFLAGS
      x86/hyper-v: Fix indentation in hv_do_fast_hypercall16()
      Documentation/x86: Fix typo in zero-page.txt
      x86/hyper-v: Enable PIT shutdown quirk
      clockevents/drivers/i8253: Add support for PIT shutdown quirk

commit 7d9df98be66fec64349f9f1c9d3e896293fe7b45
Author: Yangtao Li <tiny.windzz@gmail.com>
Date:   Sat Nov 3 22:31:04 2018 -0400

    clockevents: Remove unnecessary unlikely()
    
    WARN_ON() and WARN_ON_ONCE() already contains an unlikely(), so it's not
    necessary to use unlikely.
    
    Signed-off-by: Yangtao Li <tiny.windzz@gmail.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lkml.kernel.org/r/20181104023104.2572-1-tiny.windzz@gmail.com

commit 35b69a420bfb56b7b74cb635ea903db05e357bec
Author: Michael Kelley <mikelley@microsoft.com>
Date:   Sun Nov 4 03:48:54 2018 +0000

    clockevents/drivers/i8253: Add support for PIT shutdown quirk
    
    Add support for platforms where pit_shutdown() doesn't work because of a
    quirk in the PIT emulation. On these platforms setting the counter register
    to zero causes the PIT to start running again, negating the shutdown.
    
    Provide a global variable that controls whether the counter register is
    zero'ed, which platform specific code can override.
    
    Signed-off-by: Michael Kelley <mikelley@microsoft.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: "gregkh@linuxfoundation.org" <gregkh@linuxfoundation.org>
    Cc: "devel@linuxdriverproject.org" <devel@linuxdriverproject.org>
    Cc: "daniel.lezcano@linaro.org" <daniel.lezcano@linaro.org>
    Cc: "virtualization@lists.linux-foundation.org" <virtualization@lists.linux-foundation.org>
    Cc: "jgross@suse.com" <jgross@suse.com>
    Cc: "akataria@vmware.com" <akataria@vmware.com>
    Cc: "olaf@aepfle.de" <olaf@aepfle.de>
    Cc: "apw@canonical.com" <apw@canonical.com>
    Cc: vkuznets <vkuznets@redhat.com>
    Cc: "jasowang@redhat.com" <jasowang@redhat.com>
    Cc: "marcelo.cerri@canonical.com" <marcelo.cerri@canonical.com>
    Cc: KY Srinivasan <kys@microsoft.com>
    Cc: stable@vger.kernel.org
    Link: https://lkml.kernel.org/r/1541303219-11142-2-git-send-email-mikelley@microsoft.com

commit bff9a1076adfb787036ced707fc28cfa578aee99
Merge: 291d0e5d81e1 ab1e77c3f590
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Nov 2 21:58:39 2018 +0100

    Merge branch 'clockevents/4.20-rc1' of https://git.linaro.org/people/daniel.lezcano/linux into timers/urgent
    
    Pull clockevent update from Daniel Lezcano:
    
     - Add the per cpu timer for the c-sky architecture (Guo Ren)
    
     - Add the global timer for the c-sky architecture (Guo Ren)

commit b4d16ab58c41ff0125822464bdff074cebd0fe47
Author: Michael Ellerman <mpe@ellerman.id.au>
Date:   Wed Oct 17 23:39:41 2018 +1100

    powerpc/time: Fix clockevent_decrementer initalisation for PR KVM
    
    In the recent commit 8b78fdb045de ("powerpc/time: Use
    clockevents_register_device(), fixing an issue with large
    decrementer") we changed the way we initialise the decrementer
    clockevent(s).
    
    We no longer initialise the mult & shift values of
    decrementer_clockevent itself.
    
    This has the effect of breaking PR KVM, because it uses those values
    in kvmppc_emulate_dec(). The symptom is guest kernels spin forever
    mid-way through boot.
    
    For now fix it by assigning back to decrementer_clockevent the mult
    and shift values.
    
    Fixes: 8b78fdb045de ("powerpc/time: Use clockevents_register_device(), fixing an issue with large decrementer")
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

commit 2f6affe35c1d79e3524a6475ea2267535a252258
Merge: 9414229c9c53 1f174a1a2cde
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun Oct 7 21:56:29 2018 +0200

    Merge branch 'clockevents/4.20' of https://git.linaro.org/people/daniel.lezcano/linux into timers/core
    
    Pull clockevent updates from Daniel Lezcano:
    
     - Prefix file names with timer-* (Daniel Lezcano)
    
     - Remove old CLOCKSOURCE_OF_DECLARE which was replaced by TIMER_OF_DECLARE
       (Daniel Lezcano)
    
     - Add reset control for dw_apb (Dinh Nguyen)
    
     - Add the SPDX identifiers for the renesas and sh timers (Kuninori
       Morimoto)
    
     - Use %pOFn instead of device_node.name (Rob Herring)
    
     - Fixup 64bits and clocksource width to 32b for sh_cmt (Sergei Shtylyov)
    
     - Add the R-Car gen3 support (Sergei Shtylyov)

commit 8b78fdb045de60a4eb35460092bbd3cffa925353
Author: Anton Blanchard <anton@ozlabs.org>
Date:   Tue Oct 2 09:01:04 2018 +1000

    powerpc/time: Use clockevents_register_device(), fixing an issue with large decrementer
    
    We currently cap the decrementer clockevent at 4 seconds, even on systems
    with large decrementer support. Fix this by converting the code to use
    clockevents_register_device() which calculates the upper bound based on
    the max_delta passed in.
    
    Signed-off-by: Anton Blanchard <anton@ozlabs.org>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

commit 22627c6f3ed3d9d0df13eec3c831b08f8186c38e
Author: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
Date:   Sat Sep 8 23:54:05 2018 +0300

    clocksource/drivers/sh_cmt: Fixup for 64-bit machines
    
    When trying to use CMT for clockevents on R-Car gen3 SoCs, I noticed
    that 'max_delta_ns' for the broadcast timer (CMT) was shown as 1000 in
    /proc/timer_list. It turned out that when calculating it, the driver did
    1 << 32 (causing what I think was undefined behavior) resulting in a zero
    delta, later clamped to 1000 by cev_delta2ns(). The root cause turned out
    to be that the driver abused *unsigned long* for the CMT register values
    (which are 16/32-bit), so that the calculation of 'ch->max_match_value'
    in sh_cmt_setup_channel() used the wrong branch. Using more proper 'u32'
    instead fixed 'max_delta_ns' and even fixed the switching an active
    clocksource to CMT (which caused the system to turn non-interactive
    before).
    
    Signed-off-by: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
    Reviewed-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit 090bcfd5d1b631ef0f6f46de19ae5a8d0cbfd6a0
Merge: 864f893f31ee 52bf4a900d9c
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Sep 27 16:50:22 2018 +0200

    Merge branch 'clockevents/4.19-fixes' of https://git.linaro.org/people/daniel.lezcano/linux into timers/urgent
    
    Pull another fix from Daniel Lezcano, which felt through the cracks:
    
     - Fix a potential memory leak reported by smatch in the atmel timer driver

commit 864f893f31eecf4d944539ad5ec1d004aefc3f41
Merge: 6bf4ca7fbc85 4451d3f59f2a
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Sep 24 10:55:38 2018 +0200

    Merge branch 'clockevents/4.19-fixes' of https://git.linaro.org/people/daniel.lezcano/linux into timers/urgent
    
    Pull clockevent fixed from Daniel Lezcano:
    
     - Add the CLOCK_SOURCE_SUSPEND_NONSTOP for non-am43 SoCs (Keerthy)
    
     - Fix set_next_event handler for the fttmr010 (Tao Ren)

commit 1e45e9a95ec277272f73439629b6e3fe1f047e92
Merge: 8603596a327c fbfa9260085b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Aug 13 13:02:31 2018 -0700

    Merge branch 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer updates from Thomas Gleixner:
     "The timers departement more or less proudly presents:
    
       - More Y2038 timekeeping work mostly in the core code. The work is
         slowly, but steadily targeting the actuall syscalls.
    
       - Enhanced timekeeping suspend/resume support by utilizing
         clocksources which do not stop during suspend, but are otherwise
         not the main timekeeping clocksources.
    
       - Make NTP adjustmets more accurate and immediate when the frequency
         is set directly and not incrementally.
    
       - Sanitize the overrung handing of posix timers
    
       - A new timer driver for Mediatek SoCs
    
       - The usual pile of fixes and updates all over the place"
    
    * 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (32 commits)
      clockevents: Warn if cpu_all_mask is used as cpumask
      tick/broadcast-hrtimer: Use cpu_possible_mask for ce_broadcast_hrtimer
      clocksource/drivers/arm_arch_timer: Fix bogus cpu_all_mask usage
      clocksource: ti-32k: Remove CLOCK_SOURCE_SUSPEND_NONSTOP flag
      timers: Clear timer_base::must_forward_clk with timer_base::lock held
      clocksource/drivers/sprd: Register one always-on timer to compensate suspend time
      clocksource/drivers/timer-mediatek: Add support for system timer
      clocksource/drivers/timer-mediatek: Convert the driver to timer-of
      clocksource/drivers/timer-mediatek: Use specific prefix for GPT
      clocksource/drivers/timer-mediatek: Rename mtk_timer to timer-mediatek
      clocksource/drivers/timer-mediatek: Add system timer bindings
      clocksource/drivers: Set clockevent device cpumask to cpu_possible_mask
      time: Introduce one suspend clocksource to compensate the suspend time
      time: Fix extra sleeptime injection when suspend fails
      timekeeping/ntp: Constify some function arguments
      ntp: Use kstrtos64 for s64 variable
      ntp: Remove redundant arguments
      timer: Fix coding style
      ktime: Provide typesafe ktime_to_ns()
      hrtimer: Improve kernel message printing
      ...

commit fbfa9260085b5b578a049a90135e5c51928c5f7f
Author: Sudeep Holla <sudeep.holla@arm.com>
Date:   Wed Jul 11 12:24:24 2018 +0100

    clockevents: Warn if cpu_all_mask is used as cpumask
    
    Using cpu_all_mask in clockevents cpumask may result in issues while
    comparing multiple clockevent devices to choose the preferred one.
    
    On one of the platforms with 2 system (i.e. non per-CPU) timers with
    different ratings, having cpu_all_mask for one of the device resulted in a
    boot hang due to a endless loop in clockevents_notify_released() as both
    were clocksources were selected as preferred.
    
    In order to prevent such issues in the future, warn if any clockevent
    driver sets cpu_all_mask as it's cpumask and just override it to use
    cpu_possible_mask. All the existing occurrences of cpu_all_mask are already
    replaced with cpu_possible_mask.
    
    Signed-off-by: Sudeep Holla <sudeep.holla@arm.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-arm-kernel@lists.infradead.org
    Link: https://lkml.kernel.org/r/1531308264-24220-3-git-send-email-sudeep.holla@arm.com

commit 234b3840d73430564a03f53973a311b7a83a95a9
Author: Sudeep Holla <sudeep.holla@arm.com>
Date:   Wed Jul 11 12:24:23 2018 +0100

    tick/broadcast-hrtimer: Use cpu_possible_mask for ce_broadcast_hrtimer
    
    This is the last instance of cpu_all_mask usage in the core framework.
    
    Replace it with cpu_possible_mask like all other instances in the
    clockevent drivers. This makes it possible to add a warning in the core
    clockevents_register_device on usage of cpu_all_mask from any clockevent
    drivers in the future.
    
    Signed-off-by: Sudeep Holla <sudeep.holla@arm.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-arm-kernel@lists.infradead.org
    Link: https://lkml.kernel.org/r/1531308264-24220-2-git-send-email-sudeep.holla@arm.com

commit 6777996d27dd4f0a569ed9593e78db68c6b659cd
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Aug 2 14:53:10 2018 +0200

    clocksource/drivers/arm_arch_timer: Fix bogus cpu_all_mask usage
    
    Using cpu_all_mask as target mask for clockevents is wrong as it never can
    actually target not possible CPUs. Use cpu_possible_mask instead
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Sudeep Holla <sudeep.holla@arm.com>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>

commit b2ab472dc159b7f89e2bc2d305fbc52fc2241dd6
Merge: e5af5ff34cf0 156955754969
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Jul 30 13:08:54 2018 +0200

    Merge branch 'clockevents/4.19' of git://git.linaro.org/people/daniel.lezcano/linux into timers/core
    
    Pull clockevent/source changes from Daniel Lezcano:
    
     - Add a less accurate but always-on clocksource for the sprd platform
       (Baoling Wang)
     - Add the system timer for the new mediatek platforms (Stanley Chu)
     - Change the cpumask to cpu_possible_mask (Sudeep Holla)

commit f8f5fe86f7e10ecc784b53537edbe3fcf0c00884
Author: Sudeep Holla <sudeep.holla@arm.com>
Date:   Wed Jul 11 12:24:22 2018 +0100

    clocksource/drivers: Set clockevent device cpumask to cpu_possible_mask
    
    Currently, quite a few clockevent devices have cpumask set to
    cpu_all_mask which should be fine. However, cpu_possible_mask is more
    accurate and if there are any other clockevent devices in the system
    which have cpumask set to cpu_possible_mask, then having cpu_all_mask
    may result in issues (mostly boot hang with forever loops in
    clockevents_notify_released).
    
    So, lets replace all the clockevent device cpu_all_mask to
    cpu_possible_mask in order to prevent above mentioned possible issue.
    
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Thierry Reding <thierry.reding@gmail.com>
    Cc: Jonathan Hunter <jonathanh@nvidia.com>
    Cc: Santosh Shilimkar <ssantosh@kernel.org>
    Signed-off-by: Sudeep Holla <sudeep.holla@arm.com>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit 3f984620f9a4fe089c0a3c951b75a460211394bb
Author: Nicholas Piggin <npiggin@gmail.com>
Date:   Sat May 5 03:19:31 2018 +1000

    powerpc: generic clockevents broadcast receiver call tick_receive_broadcast
    
    The broadcast tick recipient can call tick_receive_broadcast rather
    than re-running the full timer interrupt.
    
    It does not have to check for the next event time, because the sender
    already determined the timer has expired. It does not have to test
    irq_work_pending, because that's a direct decrementer interrupt and
    does not go through the clock events subsystem. And it does not have
    to read PURR because that was removed with the previous patch.
    
    This results in no code size change, but both the decrementer and
    broadcast path lengths are reduced.
    
    Cc: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
    Cc: Preeti U Murthy <preeti@linux.vnet.ibm.com>
    Signed-off-by: Nicholas Piggin <npiggin@gmail.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

commit 003ad57484d9154db1ba93370a20c92d8356a61d
Author: Petr Machata <petrm@mellanox.com>
Date:   Thu May 17 16:36:15 2018 +0200

    net: ip6_gre: Fix headroom request in ip6erspan_tunnel_xmit()
    
    [ Upstream commit 5691484df961aff897d824bcc26cd1a2aa036b5b ]
    
    dev->needed_headroom is not primed until ip6_tnl_xmit(), so it starts
    out zero. Thus the call to skb_cow_head() fails to actually make sure
    there's enough headroom to push the ERSPAN headers to. That can lead to
    the panic cited below. (Reproducer below that).
    
    Fix by requesting either needed_headroom if already primed, or just the
    bare minimum needed for the header otherwise.
    
    [  190.703567] kernel BUG at net/core/skbuff.c:104!
    [  190.708384] invalid opcode: 0000 [#1] PREEMPT SMP KASAN PTI
    [  190.714007] Modules linked in: act_mirred cls_matchall ip6_gre ip6_tunnel tunnel6 gre sch_ingress vrf veth x86_pkg_temp_thermal mlx_platform nfsd e1000e leds_mlxcpld
    [  190.728975] CPU: 1 PID: 959 Comm: kworker/1:2 Not tainted 4.17.0-rc4-net_master-custom-139 #10
    [  190.737647] Hardware name: Mellanox Technologies Ltd. "MSN2410-CB2F"/"SA000874", BIOS 4.6.5 03/08/2016
    [  190.747006] Workqueue: ipv6_addrconf addrconf_dad_work
    [  190.752222] RIP: 0010:skb_panic+0xc3/0x100
    [  190.756358] RSP: 0018:ffff8801d54072f0 EFLAGS: 00010282
    [  190.761629] RAX: 0000000000000085 RBX: ffff8801c1a8ecc0 RCX: 0000000000000000
    [  190.768830] RDX: 0000000000000085 RSI: dffffc0000000000 RDI: ffffed003aa80e54
    [  190.776025] RBP: ffff8801bd1ec5a0 R08: ffffed003aabce19 R09: ffffed003aabce19
    [  190.783226] R10: 0000000000000001 R11: ffffed003aabce18 R12: ffff8801bf695dbe
    [  190.790418] R13: 0000000000000084 R14: 00000000000006c0 R15: ffff8801bf695dc8
    [  190.797621] FS:  0000000000000000(0000) GS:ffff8801d5400000(0000) knlGS:0000000000000000
    [  190.805786] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [  190.811582] CR2: 000055fa929aced0 CR3: 0000000003228004 CR4: 00000000001606e0
    [  190.818790] Call Trace:
    [  190.821264]  <IRQ>
    [  190.823314]  ? ip6erspan_tunnel_xmit+0x5e4/0x1982 [ip6_gre]
    [  190.828940]  ? ip6erspan_tunnel_xmit+0x5e4/0x1982 [ip6_gre]
    [  190.834562]  skb_push+0x78/0x90
    [  190.837749]  ip6erspan_tunnel_xmit+0x5e4/0x1982 [ip6_gre]
    [  190.843219]  ? ip6gre_tunnel_ioctl+0xd90/0xd90 [ip6_gre]
    [  190.848577]  ? debug_check_no_locks_freed+0x210/0x210
    [  190.853679]  ? debug_check_no_locks_freed+0x210/0x210
    [  190.858783]  ? print_irqtrace_events+0x120/0x120
    [  190.863451]  ? sched_clock_cpu+0x18/0x210
    [  190.867496]  ? cyc2ns_read_end+0x10/0x10
    [  190.871474]  ? skb_network_protocol+0x76/0x200
    [  190.875977]  dev_hard_start_xmit+0x137/0x770
    [  190.880317]  ? do_raw_spin_trylock+0x6d/0xa0
    [  190.884624]  sch_direct_xmit+0x2ef/0x5d0
    [  190.888589]  ? pfifo_fast_dequeue+0x3fa/0x670
    [  190.892994]  ? pfifo_fast_change_tx_queue_len+0x810/0x810
    [  190.898455]  ? __lock_is_held+0xa0/0x160
    [  190.902422]  __qdisc_run+0x39e/0xfc0
    [  190.906041]  ? _raw_spin_unlock+0x29/0x40
    [  190.910090]  ? pfifo_fast_enqueue+0x24b/0x3e0
    [  190.914501]  ? sch_direct_xmit+0x5d0/0x5d0
    [  190.918658]  ? pfifo_fast_dequeue+0x670/0x670
    [  190.923047]  ? __dev_queue_xmit+0x172/0x1770
    [  190.927365]  ? preempt_count_sub+0xf/0xd0
    [  190.931421]  __dev_queue_xmit+0x410/0x1770
    [  190.935553]  ? ___slab_alloc+0x605/0x930
    [  190.939524]  ? print_irqtrace_events+0x120/0x120
    [  190.944186]  ? memcpy+0x34/0x50
    [  190.947364]  ? netdev_pick_tx+0x1c0/0x1c0
    [  190.951428]  ? __skb_clone+0x2fd/0x3d0
    [  190.955218]  ? __copy_skb_header+0x270/0x270
    [  190.959537]  ? rcu_read_lock_sched_held+0x93/0xa0
    [  190.964282]  ? kmem_cache_alloc+0x344/0x4d0
    [  190.968520]  ? cyc2ns_read_end+0x10/0x10
    [  190.972495]  ? skb_clone+0x123/0x230
    [  190.976112]  ? skb_split+0x820/0x820
    [  190.979747]  ? tcf_mirred+0x554/0x930 [act_mirred]
    [  190.984582]  tcf_mirred+0x554/0x930 [act_mirred]
    [  190.989252]  ? tcf_mirred_act_wants_ingress.part.2+0x10/0x10 [act_mirred]
    [  190.996109]  ? __lock_acquire+0x706/0x26e0
    [  191.000239]  ? sched_clock_cpu+0x18/0x210
    [  191.004294]  tcf_action_exec+0xcf/0x2a0
    [  191.008179]  tcf_classify+0xfa/0x340
    [  191.011794]  __netif_receive_skb_core+0x8e1/0x1c60
    [  191.016630]  ? debug_check_no_locks_freed+0x210/0x210
    [  191.021732]  ? nf_ingress+0x500/0x500
    [  191.025458]  ? process_backlog+0x347/0x4b0
    [  191.029619]  ? print_irqtrace_events+0x120/0x120
    [  191.034302]  ? lock_acquire+0xd8/0x320
    [  191.038089]  ? process_backlog+0x1b6/0x4b0
    [  191.042246]  ? process_backlog+0xc2/0x4b0
    [  191.046303]  process_backlog+0xc2/0x4b0
    [  191.050189]  net_rx_action+0x5cc/0x980
    [  191.053991]  ? napi_complete_done+0x2c0/0x2c0
    [  191.058386]  ? mark_lock+0x13d/0xb40
    [  191.062001]  ? clockevents_program_event+0x6b/0x1d0
    [  191.066922]  ? print_irqtrace_events+0x120/0x120
    [  191.071593]  ? __lock_is_held+0xa0/0x160
    [  191.075566]  __do_softirq+0x1d4/0x9d2
    [  191.079282]  ? ip6_finish_output2+0x524/0x1460
    [  191.083771]  do_softirq_own_stack+0x2a/0x40
    [  191.087994]  </IRQ>
    [  191.090130]  do_softirq.part.13+0x38/0x40
    [  191.094178]  __local_bh_enable_ip+0x135/0x190
    [  191.098591]  ip6_finish_output2+0x54d/0x1460
    [  191.102916]  ? ip6_forward_finish+0x2f0/0x2f0
    [  191.107314]  ? ip6_mtu+0x3c/0x2c0
    [  191.110674]  ? ip6_finish_output+0x2f8/0x650
    [  191.114992]  ? ip6_output+0x12a/0x500
    [  191.118696]  ip6_output+0x12a/0x500
    [  191.122223]  ? ip6_route_dev_notify+0x5b0/0x5b0
    [  191.126807]  ? ip6_finish_output+0x650/0x650
    [  191.131120]  ? ip6_fragment+0x1a60/0x1a60
    [  191.135182]  ? icmp6_dst_alloc+0x26e/0x470
    [  191.139317]  mld_sendpack+0x672/0x830
    [  191.143021]  ? igmp6_mcf_seq_next+0x2f0/0x2f0
    [  191.147429]  ? __local_bh_enable_ip+0x77/0x190
    [  191.151913]  ipv6_mc_dad_complete+0x47/0x90
    [  191.156144]  addrconf_dad_completed+0x561/0x720
    [  191.160731]  ? addrconf_rs_timer+0x3a0/0x3a0
    [  191.165036]  ? mark_held_locks+0xc9/0x140
    [  191.169095]  ? __local_bh_enable_ip+0x77/0x190
    [  191.173570]  ? addrconf_dad_work+0x50d/0xa20
    [  191.177886]  ? addrconf_dad_work+0x529/0xa20
    [  191.182194]  addrconf_dad_work+0x529/0xa20
    [  191.186342]  ? addrconf_dad_completed+0x720/0x720
    [  191.191088]  ? __lock_is_held+0xa0/0x160
    [  191.195059]  ? process_one_work+0x45d/0xe20
    [  191.199302]  ? process_one_work+0x51e/0xe20
    [  191.203531]  ? rcu_read_lock_sched_held+0x93/0xa0
    [  191.208279]  process_one_work+0x51e/0xe20
    [  191.212340]  ? pwq_dec_nr_in_flight+0x200/0x200
    [  191.216912]  ? get_lock_stats+0x4b/0xf0
    [  191.220788]  ? preempt_count_sub+0xf/0xd0
    [  191.224844]  ? worker_thread+0x219/0x860
    [  191.228823]  ? do_raw_spin_trylock+0x6d/0xa0
    [  191.233142]  worker_thread+0xeb/0x860
    [  191.236848]  ? process_one_work+0xe20/0xe20
    [  191.241095]  kthread+0x206/0x300
    [  191.244352]  ? process_one_work+0xe20/0xe20
    [  191.248587]  ? kthread_stop+0x570/0x570
    [  191.252459]  ret_from_fork+0x3a/0x50
    [  191.256082] Code: 14 3e ff 8b 4b 78 55 4d 89 f9 41 56 41 55 48 c7 c7 a0 cf db 82 41 54 44 8b 44 24 2c 48 8b 54 24 30 48 8b 74 24 20 e8 16 94 13 ff <0f> 0b 48 c7 c7 60 8e 1f 85 48 83 c4 20 e8 55 ef a6 ff 89 74 24
    [  191.275327] RIP: skb_panic+0xc3/0x100 RSP: ffff8801d54072f0
    [  191.281024] ---[ end trace 7ea51094e099e006 ]---
    [  191.285724] Kernel panic - not syncing: Fatal exception in interrupt
    [  191.292168] Kernel Offset: disabled
    [  191.295697] ---[ end Kernel panic - not syncing: Fatal exception in interrupt ]---
    
    Reproducer:
    
            ip link add h1 type veth peer name swp1
            ip link add h3 type veth peer name swp3
    
            ip link set dev h1 up
            ip address add 192.0.2.1/28 dev h1
    
            ip link add dev vh3 type vrf table 20
            ip link set dev h3 master vh3
            ip link set dev vh3 up
            ip link set dev h3 up
    
            ip link set dev swp3 up
            ip address add dev swp3 2001:db8:2::1/64
    
            ip link set dev swp1 up
            tc qdisc add dev swp1 clsact
    
            ip link add name gt6 type ip6erspan \
                    local 2001:db8:2::1 remote 2001:db8:2::2 oseq okey 123
            ip link set dev gt6 up
    
            sleep 1
    
            tc filter add dev swp1 ingress pref 1000 matchall skip_hw \
                    action mirred egress mirror dev gt6
            ping -I h1 192.0.2.2
    
    Fixes: e41c7c68ea77 ("ip6erspan: make sure enough headroom at xmit.")
    Signed-off-by: Petr Machata <petrm@mellanox.com>
    Acked-by: William Tu <u9012063@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 5691484df961aff897d824bcc26cd1a2aa036b5b
Author: Petr Machata <petrm@mellanox.com>
Date:   Thu May 17 16:36:15 2018 +0200

    net: ip6_gre: Fix headroom request in ip6erspan_tunnel_xmit()
    
    dev->needed_headroom is not primed until ip6_tnl_xmit(), so it starts
    out zero. Thus the call to skb_cow_head() fails to actually make sure
    there's enough headroom to push the ERSPAN headers to. That can lead to
    the panic cited below. (Reproducer below that).
    
    Fix by requesting either needed_headroom if already primed, or just the
    bare minimum needed for the header otherwise.
    
    [  190.703567] kernel BUG at net/core/skbuff.c:104!
    [  190.708384] invalid opcode: 0000 [#1] PREEMPT SMP KASAN PTI
    [  190.714007] Modules linked in: act_mirred cls_matchall ip6_gre ip6_tunnel tunnel6 gre sch_ingress vrf veth x86_pkg_temp_thermal mlx_platform nfsd e1000e leds_mlxcpld
    [  190.728975] CPU: 1 PID: 959 Comm: kworker/1:2 Not tainted 4.17.0-rc4-net_master-custom-139 #10
    [  190.737647] Hardware name: Mellanox Technologies Ltd. "MSN2410-CB2F"/"SA000874", BIOS 4.6.5 03/08/2016
    [  190.747006] Workqueue: ipv6_addrconf addrconf_dad_work
    [  190.752222] RIP: 0010:skb_panic+0xc3/0x100
    [  190.756358] RSP: 0018:ffff8801d54072f0 EFLAGS: 00010282
    [  190.761629] RAX: 0000000000000085 RBX: ffff8801c1a8ecc0 RCX: 0000000000000000
    [  190.768830] RDX: 0000000000000085 RSI: dffffc0000000000 RDI: ffffed003aa80e54
    [  190.776025] RBP: ffff8801bd1ec5a0 R08: ffffed003aabce19 R09: ffffed003aabce19
    [  190.783226] R10: 0000000000000001 R11: ffffed003aabce18 R12: ffff8801bf695dbe
    [  190.790418] R13: 0000000000000084 R14: 00000000000006c0 R15: ffff8801bf695dc8
    [  190.797621] FS:  0000000000000000(0000) GS:ffff8801d5400000(0000) knlGS:0000000000000000
    [  190.805786] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [  190.811582] CR2: 000055fa929aced0 CR3: 0000000003228004 CR4: 00000000001606e0
    [  190.818790] Call Trace:
    [  190.821264]  <IRQ>
    [  190.823314]  ? ip6erspan_tunnel_xmit+0x5e4/0x1982 [ip6_gre]
    [  190.828940]  ? ip6erspan_tunnel_xmit+0x5e4/0x1982 [ip6_gre]
    [  190.834562]  skb_push+0x78/0x90
    [  190.837749]  ip6erspan_tunnel_xmit+0x5e4/0x1982 [ip6_gre]
    [  190.843219]  ? ip6gre_tunnel_ioctl+0xd90/0xd90 [ip6_gre]
    [  190.848577]  ? debug_check_no_locks_freed+0x210/0x210
    [  190.853679]  ? debug_check_no_locks_freed+0x210/0x210
    [  190.858783]  ? print_irqtrace_events+0x120/0x120
    [  190.863451]  ? sched_clock_cpu+0x18/0x210
    [  190.867496]  ? cyc2ns_read_end+0x10/0x10
    [  190.871474]  ? skb_network_protocol+0x76/0x200
    [  190.875977]  dev_hard_start_xmit+0x137/0x770
    [  190.880317]  ? do_raw_spin_trylock+0x6d/0xa0
    [  190.884624]  sch_direct_xmit+0x2ef/0x5d0
    [  190.888589]  ? pfifo_fast_dequeue+0x3fa/0x670
    [  190.892994]  ? pfifo_fast_change_tx_queue_len+0x810/0x810
    [  190.898455]  ? __lock_is_held+0xa0/0x160
    [  190.902422]  __qdisc_run+0x39e/0xfc0
    [  190.906041]  ? _raw_spin_unlock+0x29/0x40
    [  190.910090]  ? pfifo_fast_enqueue+0x24b/0x3e0
    [  190.914501]  ? sch_direct_xmit+0x5d0/0x5d0
    [  190.918658]  ? pfifo_fast_dequeue+0x670/0x670
    [  190.923047]  ? __dev_queue_xmit+0x172/0x1770
    [  190.927365]  ? preempt_count_sub+0xf/0xd0
    [  190.931421]  __dev_queue_xmit+0x410/0x1770
    [  190.935553]  ? ___slab_alloc+0x605/0x930
    [  190.939524]  ? print_irqtrace_events+0x120/0x120
    [  190.944186]  ? memcpy+0x34/0x50
    [  190.947364]  ? netdev_pick_tx+0x1c0/0x1c0
    [  190.951428]  ? __skb_clone+0x2fd/0x3d0
    [  190.955218]  ? __copy_skb_header+0x270/0x270
    [  190.959537]  ? rcu_read_lock_sched_held+0x93/0xa0
    [  190.964282]  ? kmem_cache_alloc+0x344/0x4d0
    [  190.968520]  ? cyc2ns_read_end+0x10/0x10
    [  190.972495]  ? skb_clone+0x123/0x230
    [  190.976112]  ? skb_split+0x820/0x820
    [  190.979747]  ? tcf_mirred+0x554/0x930 [act_mirred]
    [  190.984582]  tcf_mirred+0x554/0x930 [act_mirred]
    [  190.989252]  ? tcf_mirred_act_wants_ingress.part.2+0x10/0x10 [act_mirred]
    [  190.996109]  ? __lock_acquire+0x706/0x26e0
    [  191.000239]  ? sched_clock_cpu+0x18/0x210
    [  191.004294]  tcf_action_exec+0xcf/0x2a0
    [  191.008179]  tcf_classify+0xfa/0x340
    [  191.011794]  __netif_receive_skb_core+0x8e1/0x1c60
    [  191.016630]  ? debug_check_no_locks_freed+0x210/0x210
    [  191.021732]  ? nf_ingress+0x500/0x500
    [  191.025458]  ? process_backlog+0x347/0x4b0
    [  191.029619]  ? print_irqtrace_events+0x120/0x120
    [  191.034302]  ? lock_acquire+0xd8/0x320
    [  191.038089]  ? process_backlog+0x1b6/0x4b0
    [  191.042246]  ? process_backlog+0xc2/0x4b0
    [  191.046303]  process_backlog+0xc2/0x4b0
    [  191.050189]  net_rx_action+0x5cc/0x980
    [  191.053991]  ? napi_complete_done+0x2c0/0x2c0
    [  191.058386]  ? mark_lock+0x13d/0xb40
    [  191.062001]  ? clockevents_program_event+0x6b/0x1d0
    [  191.066922]  ? print_irqtrace_events+0x120/0x120
    [  191.071593]  ? __lock_is_held+0xa0/0x160
    [  191.075566]  __do_softirq+0x1d4/0x9d2
    [  191.079282]  ? ip6_finish_output2+0x524/0x1460
    [  191.083771]  do_softirq_own_stack+0x2a/0x40
    [  191.087994]  </IRQ>
    [  191.090130]  do_softirq.part.13+0x38/0x40
    [  191.094178]  __local_bh_enable_ip+0x135/0x190
    [  191.098591]  ip6_finish_output2+0x54d/0x1460
    [  191.102916]  ? ip6_forward_finish+0x2f0/0x2f0
    [  191.107314]  ? ip6_mtu+0x3c/0x2c0
    [  191.110674]  ? ip6_finish_output+0x2f8/0x650
    [  191.114992]  ? ip6_output+0x12a/0x500
    [  191.118696]  ip6_output+0x12a/0x500
    [  191.122223]  ? ip6_route_dev_notify+0x5b0/0x5b0
    [  191.126807]  ? ip6_finish_output+0x650/0x650
    [  191.131120]  ? ip6_fragment+0x1a60/0x1a60
    [  191.135182]  ? icmp6_dst_alloc+0x26e/0x470
    [  191.139317]  mld_sendpack+0x672/0x830
    [  191.143021]  ? igmp6_mcf_seq_next+0x2f0/0x2f0
    [  191.147429]  ? __local_bh_enable_ip+0x77/0x190
    [  191.151913]  ipv6_mc_dad_complete+0x47/0x90
    [  191.156144]  addrconf_dad_completed+0x561/0x720
    [  191.160731]  ? addrconf_rs_timer+0x3a0/0x3a0
    [  191.165036]  ? mark_held_locks+0xc9/0x140
    [  191.169095]  ? __local_bh_enable_ip+0x77/0x190
    [  191.173570]  ? addrconf_dad_work+0x50d/0xa20
    [  191.177886]  ? addrconf_dad_work+0x529/0xa20
    [  191.182194]  addrconf_dad_work+0x529/0xa20
    [  191.186342]  ? addrconf_dad_completed+0x720/0x720
    [  191.191088]  ? __lock_is_held+0xa0/0x160
    [  191.195059]  ? process_one_work+0x45d/0xe20
    [  191.199302]  ? process_one_work+0x51e/0xe20
    [  191.203531]  ? rcu_read_lock_sched_held+0x93/0xa0
    [  191.208279]  process_one_work+0x51e/0xe20
    [  191.212340]  ? pwq_dec_nr_in_flight+0x200/0x200
    [  191.216912]  ? get_lock_stats+0x4b/0xf0
    [  191.220788]  ? preempt_count_sub+0xf/0xd0
    [  191.224844]  ? worker_thread+0x219/0x860
    [  191.228823]  ? do_raw_spin_trylock+0x6d/0xa0
    [  191.233142]  worker_thread+0xeb/0x860
    [  191.236848]  ? process_one_work+0xe20/0xe20
    [  191.241095]  kthread+0x206/0x300
    [  191.244352]  ? process_one_work+0xe20/0xe20
    [  191.248587]  ? kthread_stop+0x570/0x570
    [  191.252459]  ret_from_fork+0x3a/0x50
    [  191.256082] Code: 14 3e ff 8b 4b 78 55 4d 89 f9 41 56 41 55 48 c7 c7 a0 cf db 82 41 54 44 8b 44 24 2c 48 8b 54 24 30 48 8b 74 24 20 e8 16 94 13 ff <0f> 0b 48 c7 c7 60 8e 1f 85 48 83 c4 20 e8 55 ef a6 ff 89 74 24
    [  191.275327] RIP: skb_panic+0xc3/0x100 RSP: ffff8801d54072f0
    [  191.281024] ---[ end trace 7ea51094e099e006 ]---
    [  191.285724] Kernel panic - not syncing: Fatal exception in interrupt
    [  191.292168] Kernel Offset: disabled
    [  191.295697] ---[ end Kernel panic - not syncing: Fatal exception in interrupt ]---
    
    Reproducer:
    
            ip link add h1 type veth peer name swp1
            ip link add h3 type veth peer name swp3
    
            ip link set dev h1 up
            ip address add 192.0.2.1/28 dev h1
    
            ip link add dev vh3 type vrf table 20
            ip link set dev h3 master vh3
            ip link set dev vh3 up
            ip link set dev h3 up
    
            ip link set dev swp3 up
            ip address add dev swp3 2001:db8:2::1/64
    
            ip link set dev swp1 up
            tc qdisc add dev swp1 clsact
    
            ip link add name gt6 type ip6erspan \
                    local 2001:db8:2::1 remote 2001:db8:2::2 oseq okey 123
            ip link set dev gt6 up
    
            sleep 1
    
            tc filter add dev swp1 ingress pref 1000 matchall skip_hw \
                    action mirred egress mirror dev gt6
            ping -I h1 192.0.2.2
    
    Fixes: e41c7c68ea77 ("ip6erspan: make sure enough headroom at xmit.")
    Signed-off-by: Petr Machata <petrm@mellanox.com>
    Acked-by: William Tu <u9012063@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 1332a90558013ae4242e3dd7934bdcdeafb06c0d
Author: Sudeep Holla <sudeep.holla@arm.com>
Date:   Wed May 9 17:02:08 2018 +0100

    tick: Prefer a lower rating device only if it's CPU local device
    
    Checking the equality of cpumask for both new and old tick device doesn't
    ensure that it's CPU local device. This will cause issue if a low rating
    clockevent tick device is registered first followed by the registration
    of higher rating clockevent tick device.
    
    In such case, clockevents_released list will never get emptied as both
    the devices get selected as preferred one and we will loop forever in
    clockevents_notify_released.
    
    Signed-off-by: Sudeep Holla <sudeep.holla@arm.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Link: https://lkml.kernel.org/r/1525881728-4858-1-git-send-email-sudeep.holla@arm.com

commit c1e9dae0a9bf3394818abafaf376a34248c5f638
Merge: 38f0b33e6d5b 7407188489c6
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Apr 22 10:49:02 2018 -0700

    Merge branch 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer fixes from Thomas Gleixner:
     "A small set of timer fixes:
    
       - Evaluate the -ETIME condition correctly in the imx tpm driver
    
       - Fix the evaluation order of a condition in posix cpu timers
    
       - Use pr_cont() in the clockevents code to prevent ugly message
         splitting
    
       - Remove __current_kernel_time() which is now unused to prevent that
         new users show up.
    
       - Remove a stale forward declaration"
    
    * 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      clocksource/imx-tpm: Correct -ETIME return condition check
      posix-cpu-timers: Ensure set_process_cpu_timer is always evaluated
      timekeeping: Remove __current_kernel_time()
      timers: Remove stale struct tvec_base forward declaration
      clockevents: Fix kernel messages split across multiple lines

commit 4450dc0ae2c18a0ac6dce560215c7a1fa12122b5
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Thu Apr 5 17:26:58 2018 +0200

    clockevents: Fix kernel messages split across multiple lines
    
    Convert the clockevents driver from old-style printk() to pr_info() and
    pr_cont(), to fix split kernel messages like below:
    
        Clockevents: could not switch to one-shot mode:
         dummy_timer is not functional.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Link: https://lkml.kernel.org/r/1522942018-14471-1-git-send-email-geert%2Brenesas@glider.be

commit 90c7c0c24e2232bbc74c6752c67bf1dfc6b4ced1
Merge: bd03143007eb 0136c741ff40
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Apr 4 12:25:19 2018 +0200

    Merge branch 'clockevents/4.17' of https://git.linaro.org/people/daniel.lezcano/linux into timers/core
    
    Pull clockevent updates from Daniel Lezcano:
    
     - Fix timer name and register flow for imx's timer tmp and handle
       different counter width (Anson Huang)
    
     - Add the NPCM7xx timer support (Tomer Maimon)

commit 1ea5afd42a16058f9301a46c8969787c7baa7eea
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Mar 9 12:02:36 2018 +0100

    Documentation: arch-support: remove obsolete architectures
    
    A number of architecture ports are obsolete and getting dropped,
    so we no longer want to track the respective features.
    
    We already removed the lines for metag and mn10300, this does
    the same edits for all the others.
    
    For the remaining 21 architectures, this shows how many are known
    to implement each given feature:
    
    19 time/modern-timekeeping/arch-support.txt
    19 time/clockevents/arch-support.txt
    15 core/tracehook/arch-support.txt
    14 core/generic-idle-thread/arch-support.txt
    13 locking/lockdep/arch-support.txt
    12 io/dma-api-debug/arch-support.txt
    11 debug/kgdb/arch-support.txt
    10 time/virt-cpuacct/arch-support.txt
     9 debug/kretprobes/arch-support.txt
     9 debug/kprobes/arch-support.txt
     8 vm/THP/arch-support.txt
     8 vm/pte_special/arch-support.txt
     8 vm/numa-memblock/arch-support.txt
     8 io/sg-chain/arch-support.txt
     7 perf/kprobes-event/arch-support.txt
     7 locking/rwsem-optimized/arch-support.txt
     7 debug/gcov-profile-all/arch-support.txt
     7 core/jump-labels/arch-support.txt
     7 core/BPF-JIT/arch-support.txt
     6 vm/ELF-ASLR/arch-support.txt
     6 time/context-tracking/arch-support.txt
     6 seccomp/seccomp-filter/arch-support.txt
     6 debug/stackprotector/arch-support.txt
     5 time/irq-time-acct/arch-support.txt
     5 io/dma-contiguous/arch-support.txt
     5 debug/uprobes/arch-support.txt
     4 vm/ioremap_prot/arch-support.txt
     4 time/arch-tick-broadcast/arch-support.txt
     4 perf/perf-stackdump/arch-support.txt
     4 perf/perf-regs/arch-support.txt
     3 debug/KASAN/arch-support.txt
     2 vm/PG_uncached/arch-support.txt
     2 vm/huge-vmap/arch-support.txt
     2 sched/numa-balancing/arch-support.txt
     2 sched/membarrier-sync-core/arch-support.txt
     2 locking/cmpxchg-local/arch-support.txt
     2 debug/optprobes/arch-support.txt
     2 debug/kprobes-on-ftrace/arch-support.txt
     1 vm/TLB/arch-support.txt
     1 locking/queued-spinlocks/arch-support.txt
     1 locking/queued-rwlocks/arch-support.txt
     1 debug/user-ret-profiler/arch-support.txt
     0 lib/strncasecmp/arch-support.txt
    
    Note that the list does not include riscv or nds32 yet, these still
    need to be added.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

commit a46d3f9b1c9888a244ed1ce8da0eca98c3f378e2
Merge: 7bcd34259466 303c146df1c4
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jan 29 16:50:58 2018 -0800

    Merge branch 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer updates from Thomas Gleixner:
     "The timer departement presents:
    
       - A rather large rework of the hrtimer infrastructure which
         introduces softirq based hrtimers to replace the spread of
         hrtimer/tasklet combos which force the actual callback execution
         into softirq context. The approach is completely different from the
         initial implementation which you cursed at 10 years ago rightfully.
    
         The softirq based timers have their own queues and there is no
         nasty indirection and list reshuffling in the hard interrupt
         anymore. This comes with conversion of some of the hrtimer/tasklet
         users, the rest and the final removal of that horrible interface
         will come towards the end of the merge window or go through the
         relevant maintainer trees.
    
         Note: The top commit merged the last minute bugfix for the 10 years
         old CPU hotplug bug as I wanted to make sure that I fatfinger the
         merge conflict resolution myself.
    
       - The overhaul of the STM32 clocksource/clockevents driver
    
       - A new driver for the Spreadtrum SC9860 timer
    
       - A new driver dor the Actions Semi S700 timer
    
       - The usual set of fixes and updates all over the place"
    
    * 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (53 commits)
      usb/gadget/NCM: Replace tasklet with softirq hrtimer
      ALSA/dummy: Replace tasklet with softirq hrtimer
      hrtimer: Implement SOFT/HARD clock base selection
      hrtimer: Implement support for softirq based hrtimers
      hrtimer: Prepare handling of hard and softirq based hrtimers
      hrtimer: Add clock bases and hrtimer mode for softirq context
      hrtimer: Use irqsave/irqrestore around __run_hrtimer()
      hrtimer: Factor out __hrtimer_next_event_base()
      hrtimer: Factor out __hrtimer_start_range_ns()
      hrtimer: Remove the 'base' parameter from hrtimer_reprogram()
      hrtimer: Make remote enqueue decision less restrictive
      hrtimer: Unify remote enqueue handling
      hrtimer: Unify hrtimer removal handling
      hrtimer: Make hrtimer_force_reprogramm() unconditionally available
      hrtimer: Make hrtimer_reprogramm() unconditional
      hrtimer: Make hrtimer_cpu_base.next_timer handling unconditional
      hrtimer: Make the remote enqueue check unconditional
      hrtimer: Use accesor functions instead of direct access
      hrtimer: Make the hrtimer_cpu_base::hres_active field unconditional, to simplify the code
      hrtimer: Make room in 'struct hrtimer_cpu_base'
      ...

commit 3d8598fb9c5a77837d9c0951efc5c36fdf91d87c
Author: Tero Kristo <t-kristo@ti.com>
Date:   Tue Aug 15 11:42:17 2017 +0300

    clk: ti: clkctrl: use fallback udelay approach if timekeeping is suspended
    
    In certain cases it is possible that the timekeeping has been suspended
    already when attempting to disable/enable a clkctrl clock. This will
    happen at least on am43xx platform when attempting to enable / disable
    the clockevent source itself, burping out a warning from timekeeping core.
    
    The sequence of events leading to this:
    -> timekeeping_suspend()
     -> clockevents_suspend()
      -> omap_clkevt_idle()
       -> omap_hwmod_idle()
        -> _omap4_clkctrl_clk_disable()
         -> _omap4_is_timeout()
    
    Avoid the issue by checking if the timekeeping is suspended and using
    the fallback udelay approach for checking timeouts.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Acked-by: Stephen Boyd <sboyd@codeaurora.org>

commit 777a45b458660b18d7d7c3e0d874d08650c99cd2
Author: Chris Metcalf <cmetcalf@mellanox.com>
Date:   Fri Nov 3 13:20:54 2017 -0400

    arch/tile: Implement ->set_state_oneshot_stopped()
    
    set_state_oneshot_stopped() is called by the clkevt core, when the
    next event is required at an expiry time of 'KTIME_MAX'. This normally
    happens with NO_HZ_{IDLE|FULL} in both LOWRES/HIGHRES modes.
    
    This patch makes the clockevent device to stop on such an event, to
    avoid spurious interrupts, as explained by: commit 8fff52fd5093
    ("clockevents: Introduce CLOCK_EVT_STATE_ONESHOT_STOPPED state").
    
    Signed-off-by: Chris Metcalf <cmetcalf@mellanox.com>

commit 39c82caff8610d57ffe32157cb3130dfabe12fbe
Author: Prasad Sodagudi <psodagud@codeaurora.org>
Date:   Thu Oct 26 11:37:22 2017 -0700

    clockevents: Update clockevents device next_event on stop
    
    clockevent_device::next_event holds the next timer event of a clock event
    device. The value is updated in clockevents_program_event(), i.e. when the
    hardware timer is armed for the next expiry.
    
    When there are no software timers armed on a CPU, the corresponding per CPU
    clockevent device is brought into ONESHOT_STOPPED state, but
    clockevent_device::next_event is not updated, because
    clockevents_program_event() is not called.
    
    So the content of clockevent_device::next_event is stale, which is not an
    issue when real hardware is used. But the hrtimer broadcast device relies
    on that information and the stale value causes spurious wakeups.
    
    Update clockevent_device::next_event to KTIME_MAX when it has been brought
    into ONESHOT_STOPPED state to avoid spurious wakeups. This reflects the
    proper expiry time of the stopped timer: infinity.
    
    [ tglx: Massaged changelog ]
    
    Signed-off-by: Prasad Sodagudi <psodagud@codeaurora.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: viresh.kumar@linaro.org
    Link: https://lkml.kernel.org/r/1509043042-32486-1-git-send-email-psodagud@codeaurora.org

commit eccbf5fbb4dbeece1c611a4897a1b3679510b8bf
Merge: fb56d689fb1c f48729a999ee
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Nov 1 00:11:16 2017 +0100

    Merge branch 'clockevents/4.15' of https://git.linaro.org/people/daniel.lezcano/linux into timers/core
    
    Pull clockevent updates from Daniel Lezcano:
    
     - Improve the generic clockevents dependency by factoring out the option
       in the Kconfig menu option (Arnd Bergmann)
    
     - Add missing "\n" in pr_err messages for fttmr010, owl and rockchip
       (Arvind Yadav)
    
     - Add missing timer_of_exit function to rollback timer_of_init (Benjamin
       Gaignard)
    
     - Fix path and add bindings to timers (Daniel Lezcano)
    
     - Cleanup and remove support for renesas,cmt-32* (Geert Uytterhoeven)
    
     - Add support for separate R-Car Gen2 (Magnus Damm)
    
     - Fix DEFINE_PER_CPU length definition to prevent warning at expansion
       time for the arm_arch_timer (Mark Rutland)
    
     - Remove pointless irq_save,restore in an already irq-disabled callback
       and add a shortcut optimization for the local cpu on mips-gic-timer
       (Matt Redfearn)

commit 74c66c0bbfed46dd1c6df6171909de2cf7e52065
Author: David Kozub <zub@linux.fjfi.cvut.cz>
Date:   Thu Oct 19 22:57:02 2017 +0200

    clockevents/drivers/cs5535: Improve resilience to spurious interrupts
    
    commit eb39a7c0355393c5a8d930f342ad7a6231b552c4 upstream.
    
    The interrupt handler mfgpt_tick() is not robust versus spurious interrupts
    which happen before the clock event device is registered and fully
    initialized.
    
    The reason is that the safe guard against spurious interrupts solely checks
    for the clockevents shutdown state, but lacks a check for detached
    state. If the interrupt hits while the device is in detached state it
    passes the safe guard and dereferences the event handler call back which is
    NULL.
    
    Add the missing state check.
    
    Fixes: 8f9327cbb6e8 ("clockevents/drivers/cs5535: Migrate to new 'set-state' interface")
    Suggested-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: David Kozub <zub@linux.fjfi.cvut.cz>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Link: https://lkml.kernel.org/r/20171020093103.3317F6004D@linux.fjfi.cvut.cz
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit f1ae556a31dd59ebce9b8282bf271f307777646e
Author: David Kozub <zub@linux.fjfi.cvut.cz>
Date:   Thu Oct 19 22:57:02 2017 +0200

    clockevents/drivers/cs5535: Improve resilience to spurious interrupts
    
    commit eb39a7c0355393c5a8d930f342ad7a6231b552c4 upstream.
    
    The interrupt handler mfgpt_tick() is not robust versus spurious interrupts
    which happen before the clock event device is registered and fully
    initialized.
    
    The reason is that the safe guard against spurious interrupts solely checks
    for the clockevents shutdown state, but lacks a check for detached
    state. If the interrupt hits while the device is in detached state it
    passes the safe guard and dereferences the event handler call back which is
    NULL.
    
    Add the missing state check.
    
    Fixes: 8f9327cbb6e8 ("clockevents/drivers/cs5535: Migrate to new 'set-state' interface")
    Suggested-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: David Kozub <zub@linux.fjfi.cvut.cz>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Link: https://lkml.kernel.org/r/20171020093103.3317F6004D@linux.fjfi.cvut.cz
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit cffdaa65e72f76efc821d551b78ceec1f76196be
Author: David Kozub <zub@linux.fjfi.cvut.cz>
Date:   Thu Oct 19 22:57:02 2017 +0200

    clockevents/drivers/cs5535: Improve resilience to spurious interrupts
    
    commit eb39a7c0355393c5a8d930f342ad7a6231b552c4 upstream.
    
    The interrupt handler mfgpt_tick() is not robust versus spurious interrupts
    which happen before the clock event device is registered and fully
    initialized.
    
    The reason is that the safe guard against spurious interrupts solely checks
    for the clockevents shutdown state, but lacks a check for detached
    state. If the interrupt hits while the device is in detached state it
    passes the safe guard and dereferences the event handler call back which is
    NULL.
    
    Add the missing state check.
    
    Fixes: 8f9327cbb6e8 ("clockevents/drivers/cs5535: Migrate to new 'set-state' interface")
    Suggested-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: David Kozub <zub@linux.fjfi.cvut.cz>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Link: https://lkml.kernel.org/r/20171020093103.3317F6004D@linux.fjfi.cvut.cz
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 9e415a8edce53fb0fed28e15bc06522d122e872e
Merge: 5670a8471e27 eb39a7c03553
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Oct 22 06:56:25 2017 -0400

    Merge branch 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer fix from Thomas Gleixner:
     "A single fix to make the cs5535 clock event driver robust agaist
      spurious interrupts"
    
    * 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      clockevents/drivers/cs5535: Improve resilience to spurious interrupts

commit eb39a7c0355393c5a8d930f342ad7a6231b552c4
Author: David Kozub <zub@linux.fjfi.cvut.cz>
Date:   Thu Oct 19 22:57:02 2017 +0200

    clockevents/drivers/cs5535: Improve resilience to spurious interrupts
    
    The interrupt handler mfgpt_tick() is not robust versus spurious interrupts
    which happen before the clock event device is registered and fully
    initialized.
    
    The reason is that the safe guard against spurious interrupts solely checks
    for the clockevents shutdown state, but lacks a check for detached
    state. If the interrupt hits while the device is in detached state it
    passes the safe guard and dereferences the event handler call back which is
    NULL.
    
    Add the missing state check.
    
    Fixes: 8f9327cbb6e8 ("clockevents/drivers/cs5535: Migrate to new 'set-state' interface")
    Suggested-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: David Kozub <zub@linux.fjfi.cvut.cz>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: stable@vger.kernel.org
    Link: https://lkml.kernel.org/r/20171020093103.3317F6004D@linux.fjfi.cvut.cz

commit 3a29ddb1c5986a6d3f941bfb1f434105203ce7f6
Author: James Hogan <jhogan@kernel.org>
Date:   Thu Oct 19 15:17:23 2017 +0100

    clockevents: Retry programming min delta up to 10 times
    
    When CONFIG_GENERIC_CLOCKEVENTS_MIN_ADJUST=n, the call path
    hrtimer_reprogram -> clockevents_program_event ->
    clockevents_program_min_delta will not retry if the clock event driver
    returns -ETIME.
    
    If the driver could not satisfy the program_min_delta for any reason, the
    lack of a retry means the CPU may not receive a tick interrupt, potentially
    until the counter does a full period. This leads to rcu_sched timeout
    messages as the stalled CPU is detected by other CPUs, and other issues if
    the CPU is holding locks or other resources at the point at which it
    stalls.
    
    There have been a couple of observed mechanisms through which a clock event
    driver could not satisfy the requested min_delta and return -ETIME.
    
    With the MIPS GIC driver, the shared execution resource within MT cores
    means inconventient latency due to execution of instructions from other
    hardware threads in the core, within gic_next_event, can result in an event
    being set in the past.
    
    Additionally under virtualisation it is possible to get unexpected latency
    during a clockevent device's set_next_event() callback which can make it
    return -ETIME even for a delta based on min_delta_ns.
    
    It isn't appropriate to use MIN_ADJUST in the virtualisation case as
    occasional hypervisor induced high latency will cause min_delta_ns to
    quickly increase to the maximum.
    
    Instead, borrow the retry pattern from the MIN_ADJUST case, but without
    making adjustments. Retry up to 10 times, each time increasing the
    attempted delta by min_delta, before giving up.
    
    [ Matt: Reworked the loop and made retry increase the delta. ]
    
    Signed-off-by: James Hogan <jhogan@kernel.org>
    Signed-off-by: Matt Redfearn <matt.redfearn@mips.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-mips@linux-mips.org
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: "Martin Schwidefsky" <schwidefsky@de.ibm.com>
    Cc: James Hogan <james.hogan@mips.com>
    Link: https://lkml.kernel.org/r/1508422643-6075-1-git-send-email-matt.redfearn@mips.com

commit bc30658eff39c5bb562174fcf93618ab6a7afe88
Merge: 4e2a809703e2 469869d18a88
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Aug 31 16:03:47 2017 +0200

    Merge branch 'clockevents/4.14' of http://git.linaro.org/people/daniel.lezcano/linux into timers/core
    
    Pull clockevent updates from Daniel Lezcano:
    
     - Add the new imx-tpm driver (Dong Aisheng)
     - Remove DT deprecated binding for Renesas (Magnus Damm)
     - Remove error message on memory allocation (Markus Elfring)
     - Convert clocksource drivers to use %pOF

commit b60bf53abc0323f91ac59b08a7642216281e662e
Merge: 216e4a1def29 adb4f11e0a8f
Author: Ingo Molnar <mingo@kernel.org>
Date:   Sun Aug 13 11:39:45 2017 +0200

    Merge branch 'clockevents/4.13-fixes' of http://git.linaro.org/people/daniel.lezcano/linux into timers/urgent
    
    Pull clockevents fixes from Daniel Lezcano:
    
    " - Fix error check against IS_ERR() instead of NULL for the timer-of code (Dan Carpenter)
      - Fix infinite recusion with ftrace for the ARM architected timer (Ding Tianhong)
      - Fix the error code return in the em_sti's probe function (Gustavo A. R.  Silva)
      - Fix Kconfig dependency for the pistachio driver (Matt Redfearn)
      - Fix mem frame loop initialization for the ARM architected timer (Matthias Kaehlcke)"
    
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 1b044f1cfc65a7d90b209dfabd57e16d98b58c5b
Merge: e0f3e8f14da8 2287d8664fe7
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jul 3 16:14:51 2017 -0700

    Merge branch 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer updates from Thomas Gleixner:
     "A rather large update for timers/timekeeping:
    
       - compat syscall consolidation (Al Viro)
    
       - Posix timer consolidation (Christoph Helwig / Thomas Gleixner)
    
       - Cleanup of the device tree based initialization for clockevents and
         clocksources (Daniel Lezcano)
    
       - Consolidation of the FTTMR010 clocksource/event driver (Linus
         Walleij)
    
       - The usual set of small fixes and updates all over the place"
    
    * 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (93 commits)
      timers: Make the cpu base lock raw
      clocksource/drivers/mips-gic-timer: Fix an error code in 'gic_clocksource_of_init()'
      clocksource/drivers/fsl_ftm_timer: Unmap region obtained by of_iomap
      clocksource/drivers/tcb_clksrc: Make IO endian agnostic
      clocksource/drivers/sun4i: Switch to the timer-of common init
      clocksource/drivers/timer-of: Fix invalid iomap check
      Revert "ktime: Simplify ktime_compare implementation"
      clocksource/drivers: Fix uninitialized variable use in timer_of_init
      kselftests: timers: Add test for frequency step
      kselftests: timers: Fix inconsistency-check to not ignore first timestamp
      time: Add warning about imminent deprecation of CONFIG_GENERIC_TIME_VSYSCALL_OLD
      time: Clean up CLOCK_MONOTONIC_RAW time handling
      posix-cpu-timers: Make timespec to nsec conversion safe
      itimer: Make timeval to nsec conversion range limited
      timers: Fix parameter description of try_to_del_timer_sync()
      ktime: Simplify ktime_compare implementation
      clocksource/drivers/fttmr010: Factor out clock read code
      clocksource/drivers/fttmr010: Implement delay timer
      clocksource/drivers: Add timer-of common init routine
      clocksource/drivers/tcb_clksrc: Save timer context on suspend/resume
      ...

commit f5b816786f7687a2ec0f485a1138b009d2020352
Merge: 9902747ec57d 8c3ecd60e2ee
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 27 12:29:32 2017 +0200

    Merge branch 'clockevents/4.13' of https://git.linaro.org/people/daniel.lezcano/linux into timers/core
    
    Pull clockevents updates from Daniel Lezcano:
    
     - Made the tcb_clksrc endianess agnostic as the AVR32 support is gone
       (Alexandre Belloni)
    
     - Unmap io region on failure at init time in the fsl_ftm_timer (Arvind Yadav)
    
     - Fix a bad return value for the mips-gic-timer at init time (Christophe
       Jaillet)
    
     - Fix invalid iomap check and switch the sun4i timer to use the common timer
       init routine (Daniel Lezcano)

commit 8e6cec1c7c5afa489687c90be15d6ed82c742975
Merge: dbb236c1ceb6 459fa246d8fa
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 20 12:50:32 2017 +0200

    Merge branch 'clockevents/4.12-fixes' of https://git.linaro.org/people/daniel.lezcano/linux into timers/urgent
    
    Pull clockevents fixes from Daniel Lezcano:
    
     - Fixed wrong iomem area unmapped in the arch_arm_timer (Frank Rowand)
    
     - Added missing includes for sun5i and cadence-ttc (Stephen Rothwell)

commit e707eb762cf38b63402c1a124192f648a0629168
Merge: 938e7cf2d569 c477990295a7
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 20 12:35:36 2017 +0200

    Merge branch 'clockevents/4.13' of https://git.linaro.org/people/daniel.lezcano/linux into timers/core
    
    Pull clockevent changes from Daniel Lezcano:
    
     - Factored out moxart, aspeed, cortina drivers into a generic timer fttrm010.
       Take the opportunity to add the delay timer (Linus Walleij)
    
     - Saved / restored tcb atmel context at suspend/resume (Alexandre Belloni)
    
     - Added ast2500 compatible string and fixed aspeed2500 initialization (Daniel
       Lezcano)
    
     - Added clock names property for aspeed (Andrew Jeffery)
    
     - Renamed clocksource_of to timer_of (Daniel Lezcano)
    
     - Added a common timer init routine (Daniel Lezcano)

commit 4be78a86c5063a50782dd2f16bd76df6a1771d77
Author: Andreas Frber <afaerber@suse.de>
Date:   Thu Feb 23 19:27:12 2017 +0100

    clocksource: Add Owl timer
    
    The Actions Semi S500 SoC provides four timers, 2Hz0/1 and 32-bit TIMER0/1.
    
    Use TIMER0 as clocksource and TIMER1 as clockevents.
    
    Based on LeMaker linux-actions tree.
    
    An S500 datasheet can be found on the LeMaker Guitar pages:
    http://www.lemaker.org/product-guitar-download-29.html
    
    Acked-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Signed-off-by: Andreas Frber <afaerber@suse.de>

commit 8e0931022e12e45bab9afe01e830d697d9c8e73d
Author: Daniel Lezcano <daniel.lezcano@linaro.org>
Date:   Fri May 26 15:30:34 2017 +0200

    Revert "clockevents: Add a clkevt-of mechanism like clksrc-of"
    
    After discussing it, this feature is dropped as it is not considered
    adequate:
    
            https://patchwork.kernel.org/patch/9639317/
    
    There is no user of this macro yet, so there is no impact on the drivers.
    
    This reverts commit 376bc27150f180d9f5eddec6a14117780177589d.
    
    Cc: Mark Rutland <mark.rutland@arm.com>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit f99973e18b65ca1fff8c81532e3132b8f622aea8
Author: Frederic Weisbecker <fweisbec@gmail.com>
Date:   Thu Jun 1 16:47:09 2017 +0200

    nohz: Fix buggy tick delay on IRQ storms
    
    When the tick is stopped and we reach the dynticks evaluation code on
    IRQ exit, we perform a soft tick restart if we observe an expired timer
    from there. It means we program the nearest possible tick but we stay in
    dynticks mode (ts->tick_stopped = 1) because we may need to stop the tick
    again after that expired timer is handled.
    
    Now this solution works most of the time but if we suffer an IRQ storm
    and those interrupts trigger faster than the hardware clockevents min
    delay, our tick won't fire until that IRQ storm is finished.
    
    Here is the problem: on IRQ exit we reprog the timer to at least
    NOW() + min_clockevents_delay. Another IRQ fires before the tick so we
    reschedule again to NOW() + min_clockevents_delay, etc... The tick
    is eternally rescheduled min_clockevents_delay ahead.
    
    A solution is to simply remove this soft tick restart. After all
    the normal dynticks evaluation path can handle 0 delay just fine. And
    by doing that we benefit from the optimization branch which avoids
    clock reprogramming if the clockevents deadline hasn't changed since
    the last reprog. This fixes our issue because we don't do repetitive
    clock reprog that always add hardware min delay.
    
    As a side effect it should even optimize the 0 delay path in general.
    
    Reported-and-tested-by: Octavian Purdila <octavian.purdila@nxp.com>
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Rik van Riel <riel@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/1496328429-13317-1-git-send-email-fweisbec@gmail.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit bb26081a98d3db2fde37ff57f8276266b6158471
Author: Nicolai Stange <nicstange@gmail.com>
Date:   Thu Mar 30 21:45:28 2017 +0200

    microblaze: Set ->min_delta_ticks and ->max_delta_ticks for timer
    
    In preparation for making the clockevents core NTP correction aware,
    all clockevent device drivers must set ->min_delta_ticks and
    ->max_delta_ticks rather than ->min_delta_ns and ->max_delta_ns: a
    clockevent device's rate is going to change dynamically and thus, the
    ratio of ns to ticks ceases to stay invariant.
    
    Make the microblaze arch's clockevent driver initialize these fields
    properly.
    
    This patch alone doesn't introduce any change in functionality as the
    clockevents core still looks exclusively at the (untouched) ->min_delta_ns
    and ->max_delta_ns. As soon as this has changed, a followup patch will
    purge the initialization of ->min_delta_ns and ->max_delta_ns from this
    driver.
    
    Signed-off-by: Nicolai Stange <nicstange@gmail.com>
    Acked-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Signed-off-by: Michal Simek <michal.simek@xilinx.com>

commit 821596a50aba6873ff4ea8fdf2b1515638c3c8a3
Merge: 2886a734081e 6f9c89000c3f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Apr 17 10:55:14 2017 +0200

    Merge branch 'clockevents/4.12' of https://git.linaro.org/people/daniel.lezcano/linux into timers/core
    
    Pull clockevents updates from Daniel Lezcano
    
    - Provide a framework to handle errata gracefuly for arm_arch_timer (Mark
       Zyngier)
    
     - Clarify the DT properties for the rockchip timer and add the clocksource as
       an alternative to the bogus architected timer (Alexander Kochetkov)
    
     - Rename the Gemini timer to Faraday timer fttmr010 and provide a specific
       initialization for Gemini (Linus Walleij)
    
     - Add missing newlines in the error message in the timers (Rafa Miecki)
    
     - Read the clock once and implement the delay timer on Orion (Russell King)

commit 6fc46497a9fb283c4f8e8d04ae4f0bf3c0041f7e
Author: Nicolai Stange <nicstange@gmail.com>
Date:   Thu Mar 30 22:04:58 2017 +0200

    x86/uv/time: Set ->min_delta_ticks and ->max_delta_ticks
    
    In preparation for making the clockevents core NTP correction aware,
    all clockevent device drivers must set ->min_delta_ticks and
    ->max_delta_ticks rather than ->min_delta_ns and ->max_delta_ns: a
    clockevent device's rate is going to change dynamically and thus, the
    ratio of ns to ticks ceases to stay invariant.
    
    Currently, the x86's uv rtc clockevent device is initialized as follows:
    
      clock_event_device_uv.min_delta_ns = NSEC_PER_SEC /
                                     sn_rtc_cycles_per_second;
      clock_event_device_uv.max_delta_ns = clocksource_uv.mask *
                                     (NSEC_PER_SEC / sn_rtc_cycles_per_second);
    
    This translates to a ->min_delta_ticks value of 1 and a ->max_delta_ticks
    value of clocksource_uv.mask.
    
    Initialize ->min_delta_ticks and ->max_delta_ticks with these values
    respectively.
    
    This patch alone doesn't introduce any change in functionality as the
    clockevents core still looks exclusively at the (untouched) ->min_delta_ns
    and ->max_delta_ns. As soon as this has changed, a followup patch will
    purge the initialization of ->min_delta_ns and ->max_delta_ns from this
    driver.
    
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Stephen Boyd <sboyd@codeaurora.org>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: x86@kernel.org
    Cc: Mike Travis <travis@sgi.com>
    Cc: Dimitri Sivanich <sivanich@sgi.com>
    Signed-off-by: Nicolai Stange <nicstange@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 16c125b6c2c58a77756f099605724a2b11aea2d1
Author: Nicolai Stange <nicstange@gmail.com>
Date:   Thu Mar 30 22:01:13 2017 +0200

    unicore32/time: Set ->min_delta_ticks and ->max_delta_ticks
    
    In preparation for making the clockevents core NTP correction aware,
    all clockevent device drivers must set ->min_delta_ticks and
    ->max_delta_ticks rather than ->min_delta_ns and ->max_delta_ns: a
    clockevent device's rate is going to change dynamically and thus, the
    ratio of ns to ticks ceases to stay invariant.
    
    Make the unicore32 arch's clockevent driver initialize these fields
    properly.
    
    This patch alone doesn't introduce any change in functionality as the
    clockevents core still looks exclusively at the (untouched) ->min_delta_ns
    and ->max_delta_ns. As soon as this has changed, a followup patch will
    purge the initialization of ->min_delta_ns and ->max_delta_ns from this
    driver.
    
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Stephen Boyd <sboyd@codeaurora.org>
    Cc: Guan Xuetao <gxt@mprc.pku.edu.cn>
    Signed-off-by: Nicolai Stange <nicstange@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 8ab3a284a6348f4160a93051d1ed69692589a5c8
Author: Nicolai Stange <nicstange@gmail.com>
Date:   Thu Mar 30 21:59:42 2017 +0200

    um/time: Set ->min_delta_ticks and ->max_delta_ticks
    
    In preparation for making the clockevents core NTP correction aware,
    all clockevent device drivers must set ->min_delta_ticks and
    ->max_delta_ticks rather than ->min_delta_ns and ->max_delta_ns: a
    clockevent device's rate is going to change dynamically and thus, the
    ratio of ns to ticks ceases to stay invariant.
    
    Make the uml arch's clockevent driver initialize these fields properly.
    
    This patch alone doesn't introduce any change in functionality as the
    clockevents core still looks exclusively at the (untouched) ->min_delta_ns
    and ->max_delta_ns. As soon as this has changed, a followup patch will
    purge the initialization of ->min_delta_ns and ->max_delta_ns from this
    driver.
    
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Stephen Boyd <sboyd@codeaurora.org>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Jeff Dike <jdike@addtoit.com>
    Cc: user-mode-linux-devel@lists.sourceforge.net
    Signed-off-by: Nicolai Stange <nicstange@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 45b586ef231abf29bff2b91efb74c10d01a0d79c
Author: Nicolai Stange <nicstange@gmail.com>
Date:   Thu Mar 30 21:57:43 2017 +0200

    tile/time: Set ->min_delta_ticks and ->max_delta_ticks
    
    In preparation for making the clockevents core NTP correction aware,
    all clockevent device drivers must set ->min_delta_ticks and
    ->max_delta_ticks rather than ->min_delta_ns and ->max_delta_ns: a
    clockevent device's rate is going to change dynamically and thus, the
    ratio of ns to ticks ceases to stay invariant.
    
    Currently, the tile's timer clockevent device is initialized as follows:
    
      evt->max_delta_ns = clockevent_delta2ns(MAX_TICK, evt);
    
    and
    
      .min_delta_ns = 1000,
    
    The first one translates to a ->max_delta_ticks value of MAX_TICK.
    For the latter, note that the clockevent core will superimpose a
    minimum of 1us by itself -- setting ->min_delta_ticks to 1 is safe here.
    
    Initialize ->min_delta_ticks and ->max_delta_ticks with these values.
    
    This patch alone doesn't introduce any change in functionality as the
    clockevents core still looks exclusively at the (untouched) ->min_delta_ns
    and ->max_delta_ns. As soon as this has changed, a followup patch will
    purge the initialization of ->min_delta_ns and ->max_delta_ns from this
    driver.
    
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Stephen Boyd <sboyd@codeaurora.org>
    Cc: Chris Metcalf <cmetcalf@mellanox.com>
    Signed-off-by: Nicolai Stange <nicstange@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit c5d710654c0eb9a33d32aadea4863442461cf847
Author: Nicolai Stange <nicstange@gmail.com>
Date:   Thu Mar 30 21:55:55 2017 +0200

    score/time: Set ->min_delta_ticks and ->max_delta_ticks
    
    In preparation for making the clockevents core NTP correction aware,
    all clockevent device drivers must set ->min_delta_ticks and
    ->max_delta_ticks rather than ->min_delta_ns and ->max_delta_ns: a
    clockevent device's rate is going to change dynamically and thus, the
    ratio of ns to ticks ceases to stay invariant.
    
    Make the score arch's clockevent driver initialize these fields properly.
    
    This patch alone doesn't introduce any change in functionality as the
    clockevents core still looks exclusively at the (untouched) ->min_delta_ns
    and ->max_delta_ns. As soon as this has changed, a followup patch will
    purge the initialization of ->min_delta_ns and ->max_delta_ns from this
    driver.
    
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Stephen Boyd <sboyd@codeaurora.org>
    Cc: Chen Liqin <liqin.linux@gmail.com>
    Cc: Lennox Wu <lennox.wu@gmail.com>
    Signed-off-by: Nicolai Stange <nicstange@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 06c546110b0dafbc96c6eaf00aaa5835a18408c1
Author: Nicolai Stange <nicstange@gmail.com>
Date:   Thu Mar 30 21:54:55 2017 +0200

    s390/time: Set ->min_delta_ticks and ->max_delta_ticks
    
    In preparation for making the clockevents core NTP correction aware,
    all clockevent device drivers must set ->min_delta_ticks and
    ->max_delta_ticks rather than ->min_delta_ns and ->max_delta_ns: a
    clockevent device's rate is going to change dynamically and thus, the
    ratio of ns to ticks ceases to stay invariant.
    
    Currently, the s390's CPU timer clockevent device is initialized as
    follows:
    
      cd->min_delta_ns    = 1;
      cd->max_delta_ns    = LONG_MAX;
    
    Note that the device's time to cycle conversion factor, i.e.
    cd->mult / (2^cd->shift), is approx. equal to 4.
    
    Hence, this would translate to
    
      cd->min_delta_ticks = 4;
      cd->max_delta_ticks = 4 * LONG_MAX;
    
    However, a minimum value of 1ns is in the range of noise anyway and the
    clockevent core will take care of this by increasing it to 1us or so.
    Furthermore, 4*LONG_MAX would overflow the unsigned long argument the
    clockevent devices gets programmed with.
    
    Thus, initialize ->min_delta_ticks with 1 and ->max_delta_ticks with
    ULONG_MAX.
    
    This patch alone doesn't introduce any change in functionality as the
    clockevents core still looks exclusively at the (untouched) ->min_delta_ns
    and ->max_delta_ns. As soon as this has changed, a followup patch will
    purge the initialization of ->min_delta_ns and ->max_delta_ns from this
    driver.
    
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Stephen Boyd <sboyd@codeaurora.org>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: David Hildenbrand <dahi@linux.vnet.ibm.com>
    Cc: linux-s390@vger.kernel.org
    Signed-off-by: Nicolai Stange <nicstange@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 5f664e2b1bb1325c350192ead3f305742fcc79c7
Author: Nicolai Stange <nicstange@gmail.com>
Date:   Thu Mar 30 21:48:28 2017 +0200

    mn10300/cevt-mn10300: Set ->min_delta_ticks and ->max_delta_ticks
    
    In preparation for making the clockevents core NTP correction aware,
    all clockevent device drivers must set ->min_delta_ticks and
    ->max_delta_ticks rather than ->min_delta_ns and ->max_delta_ns: a
    clockevent device's rate is going to change dynamically and thus, the
    ratio of ns to ticks ceases to stay invariant.
    
    Make the mn10300 arch's clockevent driver initialize these fields properly.
    
    This patch alone doesn't introduce any change in functionality as the
    clockevents core still looks exclusively at the (untouched) ->min_delta_ns
    and ->max_delta_ns. As soon as this has changed, a followup patch will
    purge the initialization of ->min_delta_ns and ->max_delta_ns from this
    driver.
    
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Stephen Boyd <sboyd@codeaurora.org>
    Cc: David Howells <dhowells@redhat.com>
    Cc: linux-am33-list@redhat.com
    Signed-off-by: Nicolai Stange <nicstange@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit e1e5fc150da4233f2bf9c143068e1a673071a68f
Author: Nicolai Stange <nicstange@gmail.com>
Date:   Thu Mar 30 21:42:20 2017 +0200

    c6x/timer64: Set ->min_delta_ticks and ->max_delta_ticks
    
    In preparation for making the clockevents core NTP correction aware,
    all clockevent device drivers must set ->min_delta_ticks and
    ->max_delta_ticks rather than ->min_delta_ns and ->max_delta_ns: a
    clockevent device's rate is going to change dynamically and thus, the
    ratio of ns to ticks ceases to stay invariant.
    
    Make the c6x arch's clockevent driver initialize these fields properly.
    
    This patch alone doesn't introduce any change in functionality as the
    clockevents core still looks exclusively at the (untouched) ->min_delta_ns
    and ->max_delta_ns. As soon as this has changed, a followup patch will
    purge the initialization of ->min_delta_ns and ->max_delta_ns from this
    driver.
    
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Stephen Boyd <sboyd@codeaurora.org>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Aurelien Jacquiot <a-jacquiot@ti.com>
    Cc: linux-c6x-dev@linux-c6x.org
    Signed-off-by: Nicolai Stange <nicstange@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 18154c5c978bbd3a77f05a66421c362374edca57
Author: Nicolai Stange <nicstange@gmail.com>
Date:   Thu Mar 30 21:41:09 2017 +0200

    blackfin: time-ts: Set ->min_delta_ticks and ->max_delta_ticks
    
    In preparation for making the clockevents core NTP correction aware,
    all clockevent device drivers must set ->min_delta_ticks and
    ->max_delta_ticks rather than ->min_delta_ns and ->max_delta_ns: a
    clockevent device's rate is going to change dynamically and thus, the
    ratio of ns to ticks ceases to stay invariant.
    
    Make the blackfin arch's clockevent driver initialize these fields
    properly.
    
    This patch alone doesn't introduce any change in functionality as the
    clockevents core still looks exclusively at the (untouched) ->min_delta_ns
    and ->max_delta_ns. As soon as this has changed, a followup patch will
    purge the initialization of ->min_delta_ns and ->max_delta_ns from this
    driver.
    
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Stephen Boyd <sboyd@codeaurora.org>
    Cc: Steven Miao <realmz6@gmail.com>
    Signed-off-by: Nicolai Stange <nicstange@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 747d04b30e5285d8fc81db6a20b745bde3830798
Author: Nicolai Stange <nicstange@gmail.com>
Date:   Sun Mar 26 15:44:03 2017 +0200

    x86/apic/timer: Set ->min_delta_ticks and ->max_delta_ticks
    
    In preparation for making the clockevents core NTP correction aware,
    all clockevent device drivers must set ->min_delta_ticks and
    ->max_delta_ticks rather than ->min_delta_ns and ->max_delta_ns: a
    clockevent device's rate is going to change dynamically and thus, the
    ratio of ns to ticks ceases to stay invariant.
    
    Make the x86 arch's apic clockevent driver initialize these fields
    properly.
    
    This patch alone doesn't introduce any change in functionality as the
    clockevents core still looks exclusively at the (untouched) ->min_delta_ns
    and ->max_delta_ns. As soon as this has changed, a followup patch will
    purge the initialization of ->min_delta_ns and ->max_delta_ns from this
    driver.
    
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Stephen Boyd <sboyd@codeaurora.org>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: x86@kernel.org
    CC: Dou Liyang <douly.fnst@cn.fujitsu.com>
    Cc: Gu Zheng <guz.fnst@cn.fujitsu.com>
    Signed-off-by: Nicolai Stange <nicstange@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit e4db9253d6b4c1d927254f1c4bef875573229502
Author: Nicolai Stange <nicstange@gmail.com>
Date:   Thu Mar 30 21:47:32 2017 +0200

    MIPS: clockevent drivers: Set ->min_delta_ticks and ->max_delta_ticks
    
    In preparation for making the clockevents core NTP correction aware,
    all clockevent device drivers must set ->min_delta_ticks and
    ->max_delta_ticks rather than ->min_delta_ns and ->max_delta_ns: a
    clockevent device's rate is going to change dynamically and thus, the
    ratio of ns to ticks ceases to stay invariant.
    
    Make the MIPS arch's clockevent drivers initialize these fields properly.
    
    This patch alone doesn't introduce any change in functionality as the
    clockevents core still looks exclusively at the (untouched) ->min_delta_ns
    and ->max_delta_ns. As soon as this has changed, a followup patch will
    purge the initialization of ->min_delta_ns and ->max_delta_ns from these
    drivers.
    
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Stephen Boyd <sboyd@codeaurora.org>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Keguang Zhang <keguang.zhang@gmail.com>
    Cc: John Crispin <john@phrozen.org>
    Acked-by: Ralf Baechle <ralf@linux-mips.org>
    Signed-off-by: Nicolai Stange <nicstange@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 547733c58dc3d2a50af762d4fdaf1d552e6b31cd
Author: Nicolai Stange <nicstange@gmail.com>
Date:   Thu Mar 30 22:10:21 2017 +0200

    clockevents/drivers/atlas7: Set ->min_delta_ticks and ->max_delta_ticks
    
    In preparation for making the clockevents core NTP correction aware,
    all clockevent device drivers must set ->min_delta_ticks and
    ->max_delta_ticks rather than ->min_delta_ns and ->max_delta_ns: a
    clockevent device's rate is going to change dynamically and thus, the
    ratio of ns to ticks ceases to stay invariant.
    
    Make the timer-atlas7 clockevent driver initialize these fields properly.
    
    This patch alone doesn't introduce any change in functionality as the
    clockevents core still looks exclusively at the (untouched) ->min_delta_ns
    and ->max_delta_ns. As soon as this has changed, a followup patch will
    purge the initialization of ->min_delta_ns and ->max_delta_ns from this
    driver.
    
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Stephen Boyd <sboyd@codeaurora.org>
    Cc: Barry Song <baohua@kernel.org>
    Cc: linux-arm-kernel@lists.infradead.org
    Acked-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Signed-off-by: Nicolai Stange <nicstange@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit bb2e94ac0cf4628f5e5f778c8de4a376dac43558
Author: Nicolai Stange <nicstange@gmail.com>
Date:   Thu Mar 30 22:09:12 2017 +0200

    clockevents/drivers/sh_cmt: Set ->min_delta_ticks and ->max_delta_ticks
    
    In preparation for making the clockevents core NTP correction aware,
    all clockevent device drivers must set ->min_delta_ticks and
    ->max_delta_ticks rather than ->min_delta_ns and ->max_delta_ns: a
    clockevent device's rate is going to change dynamically and thus, the
    ratio of ns to ticks ceases to stay invariant.
    
    Make the sh_cmt clockevent driver initialize these fields properly.
    
    This patch alone doesn't introduce any change in functionality as the
    clockevents core still looks exclusively at the (untouched) ->min_delta_ns
    and ->max_delta_ns. As soon as this has changed, a followup patch will
    purge the initialization of ->min_delta_ns and ->max_delta_ns from this
    driver.
    
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Stephen Boyd <sboyd@codeaurora.org>
    Acked-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Signed-off-by: Nicolai Stange <nicstange@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 6cf57ae8cd9916efa889dc030b1010571b4567ab
Author: Nicolai Stange <nicstange@gmail.com>
Date:   Thu Mar 30 22:08:49 2017 +0200

    x86/numachip timer: Set ->min_delta_ticks and ->max_delta_ticks
    
    In preparation for making the clockevents core NTP correction aware,
    all clockevent device drivers must set ->min_delta_ticks and
    ->max_delta_ticks rather than ->min_delta_ns and ->max_delta_ns: a
    clockevent device's rate is going to change dynamically and thus, the
    ratio of ns to ticks ceases to stay invariant.
    
    Make the numachip clockevent driver initialize these fields properly.
    
    This patch alone doesn't introduce any change in functionality as the
    clockevents core still looks exclusively at the (untouched) ->min_delta_ns
    and ->max_delta_ns. As soon as this has changed, a followup patch will
    purge the initialization of ->min_delta_ns and ->max_delta_ns from this
    driver.
    
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Stephen Boyd <sboyd@codeaurora.org>
    Acked-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Signed-off-by: Nicolai Stange <nicstange@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit c7438ba1133f9cccf230d63e7f978b5a71d468ff
Author: Nicolai Stange <nicstange@gmail.com>
Date:   Thu Mar 30 22:08:20 2017 +0200

    clockevents/drivers/metag: Set ->min_delta_ticks and ->max_delta_ticks
    
    In preparation for making the clockevents core NTP correction aware,
    all clockevent device drivers must set ->min_delta_ticks and
    ->max_delta_ticks rather than ->min_delta_ns and ->max_delta_ns: a
    clockevent device's rate is going to change dynamically and thus, the
    ratio of ns to ticks ceases to stay invariant.
    
    Make the metag_generic clockevent driver initialize these fields properly.
    
    This patch alone doesn't introduce any change in functionality as the
    clockevents core still looks exclusively at the (untouched) ->min_delta_ns
    and ->max_delta_ns. As soon as this has changed, a followup patch will
    purge the initialization of ->min_delta_ns and ->max_delta_ns from this
    driver.
    
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Stephen Boyd <sboyd@codeaurora.org>
    Cc: James Hogan <james.hogan@imgtec.com>
    Acked-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Signed-off-by: Nicolai Stange <nicstange@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 8317b53fbe32439c56ba83ad4435b641799b2ce8
Author: Nicolai Stange <nicstange@gmail.com>
Date:   Thu Mar 30 22:07:49 2017 +0200

    clockevents/drivers/dw_apb: Set ->min_delta_ticks and ->max_delta_ticks
    
    In preparation for making the clockevents core NTP correction aware,
    all clockevent device drivers must set ->min_delta_ticks and
    ->max_delta_ticks rather than ->min_delta_ns and ->max_delta_ns: a
    clockevent device's rate is going to change dynamically and thus, the
    ratio of ns to ticks ceases to stay invariant.
    
    Make the dw_apb clockevent driver initialize these fields properly.
    
    This patch alone doesn't introduce any change in functionality as the
    clockevents core still looks exclusively at the (untouched) ->min_delta_ns
    and ->max_delta_ns. As soon as this has changed, a followup patch will
    purge the initialization of ->min_delta_ns and ->max_delta_ns from this
    driver.
    
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Stephen Boyd <sboyd@codeaurora.org>
    Acked-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Signed-off-by: Nicolai Stange <nicstange@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit a60a9fb8fb52768bd19cd8c0893f4c0432acb10e
Author: Nicolai Stange <nicstange@gmail.com>
Date:   Thu Mar 30 21:43:32 2017 +0200

    hexagon/time: Set ->min_delta_ticks and ->max_delta_ticks
    
    In preparation for making the clockevents core NTP correction aware,
    all clockevent device drivers must set ->min_delta_ticks and
    ->max_delta_ticks rather than ->min_delta_ns and ->max_delta_ns: a
    clockevent device's rate is going to change dynamically and thus, the
    ratio of ns to ticks ceases to stay invariant.
    
    Make the hexagon arch's clockevent driver initialize these fields
    properly.
    
    This patch alone doesn't introduce any change in functionality as the
    clockevents core still looks exclusively at the (untouched) ->min_delta_ns
    and ->max_delta_ns. As soon as this has changed, a followup patch will
    purge the initialization of ->min_delta_ns and ->max_delta_ns from this
    driver.
    
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Stephen Boyd <sboyd@codeaurora.org>
    Cc: Richard Kuo <rkuo@codeaurora.org>
    Cc: linux-hexagon@vger.kernel.org
    Acked-by: Richard Kuo <rkuo@codeaurora.org>
    Signed-off-by: Nicolai Stange <nicstange@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit b77f41618c2647e80ee45d6609d95b3d4a10e372
Author: Nicolai Stange <nicstange@gmail.com>
Date:   Thu Mar 30 22:03:41 2017 +0200

    x86/lguest/timer: Set ->min_delta_ticks and ->max_delta_ticks
    
    In preparation for making the clockevents core NTP correction aware,
    all clockevent device drivers must set ->min_delta_ticks and
    ->max_delta_ticks rather than ->min_delta_ns and ->max_delta_ns: a
    clockevent device's rate is going to change dynamically and thus, the
    ratio of ns to ticks ceases to stay invariant.
    
    Make the x86 arch's lguest clockevent driver initialize these fields
    properly.
    
    This patch alone doesn't introduce any change in functionality as the
    clockevents core still looks exclusively at the (untouched) ->min_delta_ns
    and ->max_delta_ns. As soon as this has changed, a followup patch will
    purge the initialization of ->min_delta_ns and ->max_delta_ns from this
    driver.
    
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Stephen Boyd <sboyd@codeaurora.org>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: x86@kernel.org
    Cc: Paul Bolle <pebolle@tiscali.nl>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Juergen Gross <jgross@suse.com>
    Cc: "Luis R. Rodriguez" <mcgrof@kernel.org>
    Cc: lguest@lists.ozlabs.org
    Acked-by: Rusty Russell <rusty@rustcorp.com.au>
    Signed-off-by: Nicolai Stange <nicstange@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 7fd534247d1b6fcd399ab70f04db39047724898a
Author: Nicolai Stange <nicstange@gmail.com>
Date:   Thu Mar 30 21:56:47 2017 +0200

    sparc/time: Set ->min_delta_ticks and ->max_delta_ticks
    
    In preparation for making the clockevents core NTP correction aware,
    all clockevent device drivers must set ->min_delta_ticks and
    ->max_delta_ticks rather than ->min_delta_ns and ->max_delta_ns: a
    clockevent device's rate is going to change dynamically and thus, the
    ratio of ns to ticks ceases to stay invariant.
    
    Make the sparc arch's clockevent drivers initialize these fields properly.
    
    This patch alone doesn't introduce any change in functionality as the
    clockevents core still looks exclusively at the (untouched) ->min_delta_ns
    and ->max_delta_ns. As soon as this has changed, a followup patch will
    purge the initialization of ->min_delta_ns and ->max_delta_ns from these
    drivers.
    
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Stephen Boyd <sboyd@codeaurora.org>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: sparclinux@vger.kernel.org
    Acked-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Nicolai Stange <nicstange@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 115631c350bfd3b9cbc0aff75b3975e17c83d3d9
Author: Nicolai Stange <nicstange@gmail.com>
Date:   Thu Mar 30 21:53:17 2017 +0200

    powerpc/time: Set ->min_delta_ticks and ->max_delta_ticks
    
    In preparation for making the clockevents core NTP correction aware,
    all clockevent device drivers must set ->min_delta_ticks and
    ->max_delta_ticks rather than ->min_delta_ns and ->max_delta_ns: a
    clockevent device's rate is going to change dynamically and thus, the
    ratio of ns to ticks ceases to stay invariant.
    
    Make the powerpc arch's clockevent driver initialize these fields properly.
    
    This patch alone doesn't introduce any change in functionality as the
    clockevents core still looks exclusively at the (untouched) ->min_delta_ns
    and ->max_delta_ns. As soon as this has changed, a followup patch will
    purge the initialization of ->min_delta_ns and ->max_delta_ns from this
    driver.
    
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Stephen Boyd <sboyd@codeaurora.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Oliver O'Halloran <oohall@gmail.com>
    Cc: linuxppc-dev@lists.ozlabs.org
    Acked-by: Michael Ellerman <mpe@ellerman.id.au> (powerpc)
    Signed-off-by: Nicolai Stange <nicstange@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 33ae7a9b6c23cdffe7449ddf1a992117262b939b
Author: Nicolai Stange <nicstange@gmail.com>
Date:   Thu Mar 30 21:44:31 2017 +0200

    m68k/coldfire/pit: Set ->min_delta_ticks and ->max_delta_ticks
    
    In preparation for making the clockevents core NTP correction aware,
    all clockevent device drivers must set ->min_delta_ticks and
    ->max_delta_ticks rather than ->min_delta_ns and ->max_delta_ns: a
    clockevent device's rate is going to change dynamically and thus, the
    ratio of ns to ticks ceases to stay invariant.
    
    Make the m68k arch's coldfire clockevent driver initialize these fields
    properly.
    
    This patch alone doesn't introduce any change in functionality as the
    clockevents core still looks exclusively at the (untouched) ->min_delta_ns
    and ->max_delta_ns. As soon as this has changed, a followup patch will
    purge the initialization of ->min_delta_ns and ->max_delta_ns from this
    driver.
    
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Stephen Boyd <sboyd@codeaurora.org>
    Cc: Greg Ungerer <gerg@linux-m68k.org>
    CC: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: linux-m68k@lists.linux-m68k.org
    Acked-by: Greg Ungerer <gerg@linux-m68k.org>
    Signed-off-by: Nicolai Stange <nicstange@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 3d18d661aaad5a22f4d37a0592acc9d784f2a11b
Author: Nicolai Stange <nicstange@gmail.com>
Date:   Thu Mar 30 22:06:42 2017 +0200

    x86/xen/time: Set ->min_delta_ticks and ->max_delta_ticks
    
    In preparation for making the clockevents core NTP correction aware,
    all clockevent device drivers must set ->min_delta_ticks and
    ->max_delta_ticks rather than ->min_delta_ns and ->max_delta_ns: a
    clockevent device's rate is going to change dynamically and thus, the
    ratio of ns to ticks ceases to stay invariant.
    
    Make the x86 arch's xen clockevent driver initialize these fields properly.
    
    This patch alone doesn't introduce any change in functionality as the
    clockevents core still looks exclusively at the (untouched) ->min_delta_ns
    and ->max_delta_ns. As soon as this has changed, a followup patch will
    purge the initialization of ->min_delta_ns and ->max_delta_ns from this
    driver.
    
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Stephen Boyd <sboyd@codeaurora.org>
    Cc: Boris Ostrovsky <boris.ostrovsky@oracle.com>
    Cc: Juergen Gross <jgross@suse.com>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: x86@kernel.org
    Cc: xen-devel@lists.xenproject.org
    Reviewed-by: Boris Ostrovsky <boris.ostrovsky@oracle.com>
    Signed-off-by: Nicolai Stange <nicstange@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 6f9c89000c3f771c47adacaca2df775a25f27205
Merge: 28e71e2fe8fe d003d029cea8
Author: Daniel Lezcano <daniel.lezcano@linaro.org>
Date:   Fri Apr 7 16:23:29 2017 +0200

    Merge tag 'arch-timer-errata' of git://git.kernel.org/pub/scm/linux/kernel/git/maz/arm-platforms into clockevents/4.12
    
    arm64 arch timer workaround series, including the base patches
    that will also go via the arm64 tree.
    
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit 4a6808f347a3f969e56e8e4274e70849ecdc33de
Merge: 907977b2a22c 8d09617b076f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Apr 2 09:22:03 2017 -0700

    Merge branch 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer fixes from Thomas Gleixner:
     "Two small fixes for the new CLKEVT_OF infrastructure"
    
    * 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      vmlinux.lds: Add __clkevt_of_table to kernel
      clockevents: Fix syntax error in clkevt-of macro

commit 8d09617b076fd03ee9ae124abce94dda17bf3723
Author: Alexander Kochetkov <al.kochet@gmail.com>
Date:   Wed Mar 22 17:29:06 2017 +0300

    vmlinux.lds: Add __clkevt_of_table to kernel
    
    The code introduced by commit 0c8893c9095d ("clockevents: Add a
    clkevt-of mechanism like clksrc-of") refer to __clkevt_of_table
    what doesn't exist in the vmlinux. As a result kernel build
    failed with error: "clkevt-probe.c:63: undefined reference to
    `__clkevt_of_table"
    
    Fixes: 0c8893c9095d ("clockevents: Add a clkevt-of mechanism like clksrc-of")
    Signed-off-by: Alexander Kochetkov <al.kochet@gmail.com>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit 07de36b378a58f1d1426829acf0ab7cf86f651f3
Author: Alexander Kochetkov <al.kochet@gmail.com>
Date:   Wed Mar 22 17:32:49 2017 +0300

    clockevents: Fix syntax error in clkevt-of macro
    
    The patch fix syntax errors introduced by commit 0c8893c9095d
    ("clockevents: Add a clkevt-of mechanism like clksrc-of").
    
    Fixes: 0c8893c9095d ("clockevents: Add a clkevt-of mechanism like clksrc-of")
    Signed-off-by: Alexander Kochetkov <al.kochet@gmail.com>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit 0695bd99c0d22bef4d9d4c72cf537b722ba98531
Author: Nicolai Stange <nicstange@gmail.com>
Date:   Mon Feb 6 22:12:04 2017 +0100

    clockevents: Make clockevents_config() static
    
    A clockevent device's rate should be configured before or at registration
    and changed afterwards through clockevents_update_freq() only.
    
    For the configuration at registration, we already have
    clockevents_config_and_register().
    
    Right now, there are no clockevents_config() users outside of the
    clockevents core.
    
    To mitigiate the risk of drivers errorneously reconfiguring their rates
    through clockevents_config() *after* device registration, make
    clockevents_config() static.
    
    Signed-off-by: Nicolai Stange <nicstange@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit a17e0178fa2898bd8c4ccaaefa83c729759a361c
Author: Nicolai Stange <nicstange@gmail.com>
Date:   Mon Feb 6 22:12:03 2017 +0100

    clocksource: h8300_timer8: Don't reset rate in ->set_state_oneshot()
    
    With the upcoming NTP correction related rate adjustments to be implemented
    in the clockevents core, the latter needs to get informed about every rate
    change of a clockevent device made after its registration.
    
    Currently, h8300_timer8 violates this requirement in that it registers its
    clockevent device with the correct rate, but resets its ->mult and ->rate
    values in timer8_clock_event_start(), called from its ->set_state_oneshot()
    function.
    
    It seems like
      commit 4633f4cac85a ("clocksource/drivers/h8300: Cleanup startup and
                            remove module code."),
    which introduced the rate initialization at registration, missed to remove
    the manual setting of ->mult and ->shift from timer8_clock_event_start().
    
    Purge the setting of ->mult, ->shift, ->min_delta_ns and ->max_delta_ns
    from timer8_clock_event_start().
    
    Signed-off-by: Nicolai Stange <nicstange@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 4e53aa2fde4124878fc6b2183d6e8ec46e12ceb0
Author: Nicolai Stange <nicstange@gmail.com>
Date:   Mon Feb 6 22:12:02 2017 +0100

    clocksource: em_sti: Compute rate before registration
    
    With the upcoming NTP correction related rate adjustments to be implemented
    in the clockevents core, the latter needs to get informed about every rate
    change of a clockevent device made after its registration.
    
    Currently, em_sti violates this requirement in that it registers its
    clockevent device with a dummy rate and sets its final rate through
    clockevents_config() called from its ->set_state_oneshot().
    
    This patch moves the setting of the clockevent device's rate to its
    registration.
    
    I checked all current em_sti users in arch/arm/mach-shmobile and right now,
    none of them changes any rate in any clock tree relevant to em_sti after
    their respective time_init(). Since all em_sti instances are created after
    time_init(), none of them should ever observe any clock rate changes.
    
    - Determine the ->rate value in em_sti_probe() at device probing rather
      than at first usage.
    - Set the clockevent device's rate at its registration.
    - Although not strictly necessary for the upcoming clockevent core changes,
      set the clocksource's rate at its registration for consistency.
    
    Signed-off-by: Nicolai Stange <nicstange@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit c3c0a20df9fc55e2243a31f91a943b3e8ba61289
Author: Nicolai Stange <nicstange@gmail.com>
Date:   Mon Feb 6 22:12:00 2017 +0100

    clocksource: sh_tmu: Compute rate before registration again
    
    With the upcoming NTP correction related rate adjustments to be implemented
    in the clockevents core, the latter needs to get informed about every rate
    change of a clockevent device made after its registration.
    
    Currently, sh_tmu violates this requirement in that it registers its
    clockevent device with a dummy rate and sets its final rate through
    clockevents_config() called from its ->set_state_oneshot() and
    ->set_state_periodic() functions respectively.
    
    This patch moves the setting of the clockevent device's rate to its
    registration.
    
    Note that there has been some back and forth regarding this question with
    respect to the clocksource also provided by this driver:
      commit 66f49121ffa4 ("clocksource: sh_tmu: compute mult and shift before
                            registration")
    moves the rate determination from the clocksource's ->enable() function to
    before its registration. OTOH, the later
      commit 0aeac458d9eb ("clocksource: sh_tmu: __clocksource_updatefreq_hz()
                            update")
    basically reverts this, saying
      "Without this patch the old code uses clocksource_register() together
       with a hack that assumes a never changing clock rate."
    
    However, I checked all current sh_tmu users in arch/sh as well as in
    arch/arm/mach-shmobile carefully and right now, none of them changes any
    rate in any clock tree relevant to sh_tmu after their respective
    time_init(). Since all sh_tmu instances are created after time_init(), none
    of them should ever observe any clock rate changes.
    
    What's more, both, a clocksource as well as a clockevent device, can
    immediately get selected for use at their registration and thus, enabled
    at this point already. So it's probably safer to assume a "never changing
    clock rate" here.
    
    - Move the struct sh_tmu_channel's ->rate member to struct sh_tmu_device:
      it's a property of the underlying clock which is in turn specific to
      the sh_tmu_device.
    - Determine the ->rate value in sh_tmu_setup() at device probing rather
      than at first usage.
    - Set the clockevent device's rate at its registration.
    - Although not strictly necessary for the upcoming clockevent core changes,
      set the clocksource's rate at its registration for consistency.
    
    Signed-off-by: Nicolai Stange <nicstange@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 890f423b266623e1cfb3a97b864f3e5039bdfbb9
Author: Nicolai Stange <nicstange@gmail.com>
Date:   Mon Feb 6 22:11:59 2017 +0100

    clocksource: sh_cmt: Compute rate before registration again
    
    With the upcoming NTP correction related rate adjustments to be implemented
    in the clockevents core, the latter needs to get informed about every rate
    change of a clockevent device made after its registration.
    
    Currently, sh_cmt violates this requirement in that it registers its
    clockevent device with a dummy rate and sets its final ->mult and ->shift
    values from its ->set_state_oneshot() and ->set_state_periodic() functions
    respectively.
    
    This patch moves the setting of the clockevent device's ->mult and ->shift
    values to before its registration.
    
    Note that there has been some back and forth regarding this question with
    respect to the clocksource also provided by this driver:
      commit f4d7c3565c16 ("clocksource: sh_cmt: compute mult and shift before
                            registration")
    moves the rate determination from the clocksource's ->enable() function to
    before its registration. OTOH, the later
      commit 3593f5fe40a1 ("clocksource: sh_cmt: __clocksource_updatefreq_hz()
                            update")
    basically reverts this, saying
      "Without this patch the old code uses clocksource_register() together
       with a hack that assumes a never changing clock rate."
    
    However, I checked all current sh_cmt users in arch/sh as well as in
    arch/arm/mach-shmobile carefully and right now, none of them changes any
    rate in any clock tree relevant to sh_cmt after their respective
    time_init(). Since all sh_cmt instances are created after time_init(), none
    of them should ever observe any clock rate changes.
    
    What's more, both, a clocksource as well as a clockevent device, can
    immediately get selected for use at their registration and thus, enabled
    at this point already. So it's probably safer to assume a "never changing
    clock rate" here.
    
    - Move the struct sh_cmt_channel's ->rate member to struct sh_cmt_device:
      it's a property of the underlying clock which is in turn specific to
      the sh_cmt_device.
    - Determine the ->rate value in sh_cmt_setup() at device probing rather
      than at first usage.
    - Set the clockevent device's ->mult and ->shift values right before its
      registration.
    - Although not strictly necessary for the upcoming clockevent core changes,
      set the clocksource's rate at its registration for consistency.
    
    Signed-off-by: Nicolai Stange <nicstange@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 20dcfe1b7df4072a3c13bdb7506f7138125d0099
Merge: c9b9f207b904 336a9cde10d6
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Feb 20 10:06:32 2017 -0800

    Merge branch 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer updates from Thomas Gleixner:
     "Nothing exciting, just the usual pile of fixes, updates and cleanups:
    
       - A bunch of clocksource driver updates
    
       - Removal of CONFIG_TIMER_STATS and the related /proc file
    
       - More posix timer slim down work
    
       - A scalability enhancement in the tick broadcast code
    
       - Math cleanups"
    
    * 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (23 commits)
      hrtimer: Catch invalid clockids again
      math64, tile: Fix build failure
      clocksource/drivers/arm_arch_timer:: Mark cyclecounter __ro_after_init
      timerfd: Protect the might cancel mechanism proper
      timer_list: Remove useless cast when printing
      time: Remove CONFIG_TIMER_STATS
      clocksource/drivers/arm_arch_timer: Work around Hisilicon erratum 161010101
      clocksource/drivers/arm_arch_timer: Introduce generic errata handling infrastructure
      clocksource/drivers/arm_arch_timer: Remove fsl-a008585 parameter
      clocksource/drivers/arm_arch_timer: Add dt binding for hisilicon-161010101 erratum
      clocksource/drivers/ostm: Add renesas-ostm timer driver
      clocksource/drivers/ostm: Document renesas-ostm timer DT bindings
      clocksource/drivers/tcb_clksrc: Use 32 bit tcb as sched_clock
      clocksource/drivers/gemini: Add driver for the Cortina Gemini
      clocksource: add DT bindings for Cortina Gemini
      clockevents: Add a clkevt-of mechanism like clksrc-of
      tick/broadcast: Reduce lock cacheline contention
      timers: Omit POSIX timer stuff from task_struct when disabled
      x86/timer: Make delay() work during early bootup
      delay: Add explanation of udelay() inaccuracy
      ...

commit 376bc27150f180d9f5eddec6a14117780177589d
Author: Daniel Lezcano <daniel.lezcano@linaro.org>
Date:   Tue Apr 19 08:56:27 2016 +0200

    clockevents: Add a clkevt-of mechanism like clksrc-of
    
    The current code uses the CLOCKSOURCE_OF_DECLARE macro to fill the clksrc
    table with a t-uple (name, init_function).
    
    Unfortunately it ends up to the clockevent and the clocksource being
    both initialized with this macro. It is not a problem by itself but there
    is not a clear distinction between a clockevent and a clocksource in the
    code initialization path. Somebody can argue there are the same IP block
    and the same DT node. But conceptually from the software side, there are
    two distincts entities and as is they should be initialized separetely.
    Some drivers which do not have a clocksource end up by using the
    CLOCKSOURCE_OF_DECLARE macro to declare a clockevent.
    
    Another result is the fuzzy organization in the clocksource directory,
    where the clockevents are implemented in the same file than the
    clocksources or file labelled timer-something implementing a clocksource.
    
    This patch provides another macro to specifically declare a clockevent in
    the same way than the clocksource and gives the opportunity to write two
    separate drivers, one for the clocksource and another for the clockevents.
    
    Hopefully, that can help to do some housework in the directory, perhaps
    split the drivers in to entities, for example:
            - clksrc-rockchip.c
            - clkevt-rockchip.c
    
    Also, it gives the possibility to declare clocksources separately in the
    DT and then use a clocksource from IP block while while clockevents are
    used from another IP block.
    
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit 21162d6c411fad063291abba4905d86d67444746
Author: Alexey Klimov <klimov.linux@gmail.com>
Date:   Sun Jun 21 23:41:39 2015 +0300

    clockevents/drivers/exynos_mct: Remove unneeded container_of()
    
    commit 479a932982944786269296a31682e5642f87b89a upstream.
    
    Patch removes unneeded container_of() macro in exynos4_local_timer_setup().
    Instead let's pass mevt pointer to setup and stop functions from
    exynos4_mct_cpu_notify() and let them get evt pointer.
    
    Tested on odroid-xu3.
    
    Signed-off-by: Alexey Klimov <klimov.linux@gmail.com>
    Acked-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Reviewed-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>

commit d5116b4091ecca271c249ede43a49c1245920558
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Thu Jan 19 11:51:51 2017 -0700

    Drivers: hv: vmbus: Restructure the clockevents code
    
    Move the relevant code that programs the hypervisor to an architecture
    specific file.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit b78b499a67c3f77aeb6cd0b54724bc38b141255d
Merge: 098c30557a9a 190cc65e912d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Dec 13 12:11:01 2016 -0800

    Merge tag 'char-misc-4.10-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/char-misc
    
    Pull char/misc driver updates from Greg KH:
     "Here's the big char/misc driver patches for 4.10-rc1. Lots of tiny
      changes over lots of "minor" driver subsystems, the largest being some
      new FPGA drivers. Other than that, a few other new drivers, but no new
      driver subsystems added for this kernel cycle, a nice change.
    
      All of these have been in linux-next with no reported issues"
    
    * tag 'char-misc-4.10-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/char-misc: (107 commits)
      uio-hv-generic: store physical addresses instead of virtual
      Tools: hv: kvp: configurable external scripts path
      uio-hv-generic: new userspace i/o driver for VMBus
      vmbus: add support for dynamic device id's
      hv: change clockevents unbind tactics
      hv: acquire vmbus_connection.channel_mutex in vmbus_free_channels()
      hyperv: Fix spelling of HV_UNKOWN
      mei: bus: enable non-blocking RX
      mei: fix the back to back interrupt handling
      mei: synchronize irq before initiating a reset.
      VME: Remove shutdown entry from vme_driver
      auxdisplay: ht16k33: select framebuffer helper modules
      MAINTAINERS: add git url for fpga
      fpga: Clarify how write_init works streaming modes
      fpga zynq: Fix incorrect ISR state on bootup
      fpga zynq: Remove priv->dev
      fpga zynq: Add missing \n to messages
      fpga: Add COMPILE_TEST to all drivers
      uio: pruss: add clk_disable()
      char/pcmcia: add some error checking in scr24x_read()
      ...

commit 6ffc4b85358f6b7d252420cfa5862312cf5f83d8
Author: Vitaly Kuznetsov <vkuznets@redhat.com>
Date:   Sat Dec 3 12:34:35 2016 -0800

    hv: change clockevents unbind tactics
    
    To get prepared to CPU offlining support we need co change the way how we
    unbind clockevent devices. As one CPU may go online/offline multiple times
    we need to bind it in hv_synic_init() and unbind it in hv_synic_cleanup().
    There is an additional corner case: when we unload the module completely we
    need to switch to some other clockevent mechanism before stopping VMBus or
    we will hang. We can't call hv_synic_cleanup() before unloading VMBus as
    we won't be able to send UNLOAD request and get a response so
    hv_synic_clockevents_cleanup() has to live. Luckily, we can always call
    clockevents_unbind_device(), even if it wasn't bound before and there is
    no issue if we call it twice.
    
    Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 0465fb495f9c9698de08ff103905008e5f38e8f1
Author: Noam Camus <noamca@mellanox.com>
Date:   Wed Nov 16 08:31:12 2016 +0200

    clocksource: update "fn" at CLOCKSOURCE_OF_DECLARE() of nps400 timer
    
    nps_setup_clocksource() should take node as only argument as defined by
    typedef int (*of_init_fn_1_ret)(struct device_node *)
    
    Therefore need to replace:
    int __init nps_setup_clocksource(struct device_node *node, struct clk *clk)
    with
    int __init nps_setup_clocksource(struct device_node *node)
    
    This patch also serve as preparation for next patch which add support
    for clockevents to nps400.
    Specifically we add new function nps_get_timer_clk() to serve clocksource
    and later clockevent registration.
    
    Signed-off-by: Noam Camus <noamca@mellanox.com>
    Acked-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit 0d6a2bb674f96c9463ce7daefb9b5837adfb7194
Author: Vitaly Kuznetsov <vkuznets@redhat.com>
Date:   Fri Feb 27 11:25:56 2015 -0800

    clockevents: export clockevents_unbind_device instead of clockevents_unbind
    
    commit 32a158325acf12842764b1681f53903673f2f22e upstream.
    
    It looks like clockevents_unbind is being exported by mistake as:
    - it is static;
    - it is not listed in include/linux/clockchips.h;
    - EXPORT_SYMBOL_GPL(clockevents_unbind) follows clockevents_unbind_device()
      implementation.
    
    I think clockevents_unbind_device should be exported instead. This is going to
    be used to teardown Hyper-V clockevent devices on module unload.
    
    Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>

commit 7b0e604267af578f60ad4bccbc22af3cf9a0b365
Author: Huacai Chen <chenhc@lemote.com>
Date:   Thu Jul 21 14:27:49 2016 +0800

    MIPS: Fix r4k clockevents registration
    
    commit 6dabf2b7a597a9613f0b8a2fcbe01e2a0a05c896 upstream.
    
    CPUFreq need min_delta_ticks/max_delta_ticks to be initialized, and
    this can be done by clockevents_config_and_register().
    
    Signed-off-by: Heiher <r@hev.cc>
    Signed-off-by: Huacai Chen <chenhc@lemote.com>
    Cc: John Crispin <john@phrozen.org>
    Cc: Steven J . Hill <Steven.Hill@imgtec.com>
    Cc: Fuxin Zhang <zhangfx@lemote.com>
    Cc: Zhangjin Wu <wuzhangjin@gmail.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/13817/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 3bc6d8c155fbbbe789b6caa44b9e658a5b2995d3
Merge: e6e7214fbbda 22cc1ca3c546
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Aug 12 13:55:06 2016 -0700

    Merge branch 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer fixes from Ingo Molnar:
     "Misc fixes: a /dev/rtc regression fix, two APIC timer period
      calibration fixes, an ARM clocksource driver fix and a NOHZ
      power use regression fix"
    
    * 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      x86/hpet: Fix /dev/rtc breakage caused by RTC cleanup
      x86/timers/apic: Inform TSC deadline clockevent device about recalibration
      x86/timers/apic: Fix imprecise timer interrupts by eliminating TSC clockevents frequency roundoff error
      timers: Fix get_next_timer_interrupt() computation
      clocksource/arm_arch_timer: Force per-CPU interrupt to be level-triggered

commit 1a9e4c564ab174e53ed86def922804a5ddc63e7d
Author: Nicolai Stange <nicstange@gmail.com>
Date:   Thu Jul 14 17:22:54 2016 +0200

    x86/timers/apic: Fix imprecise timer interrupts by eliminating TSC clockevents frequency roundoff error
    
    I noticed the following bug/misbehavior on certain Intel systems: with a
    single task running on a NOHZ CPU on an Intel Haswell, I recognized
    that I did not only get the one expected local_timer APIC interrupt, but
    two per second at minimum. (!)
    
    Further tracing showed that the first one precedes the programmed deadline
    by up to ~50us and hence, it did nothing except for reprogramming the TSC
    deadline clockevent device to trigger shortly thereafter again.
    
    The reason for this is imprecise calibration, the timeout we program into
    the APIC results in 'too short' timer interrupts. The core (hr)timer code
    notices this (because it has a precise ktime source and sees the short
    interrupt) and fixes it up by programming an additional very short
    interrupt period.
    
    This is obviously suboptimal.
    
    The reason for the imprecise calibration is twofold, and this patch
    fixes the first reason:
    
    In setup_APIC_timer(), the registered clockevent device's frequency
    is calculated by first dividing tsc_khz by TSC_DIVISOR and multiplying
    it with 1000 afterwards:
    
      (tsc_khz / TSC_DIVISOR) * 1000
    
    The multiplication with 1000 is done for converting from kHz to Hz and the
    division by TSC_DIVISOR is carried out in order to make sure that the final
    result fits into an u32.
    
    However, with the order given in this calculation, the roundoff error
    introduced by the division gets magnified by a factor of 1000 by the
    following multiplication.
    
    To fix it, reversing the order of the division and the multiplication a la:
    
      (tsc_khz * 1000) / TSC_DIVISOR
    
    ... reduces the roundoff error already.
    
    Furthermore, if TSC_DIVISOR divides 1000, associativity holds:
    
      (tsc_khz * 1000) / TSC_DIVISOR = tsc_khz * (1000 / TSC_DIVISOR)
    
    and thus, the roundoff error even vanishes and the whole operation can be
    carried out within 32 bits.
    
    The powers of two that divide 1000 are 2, 4 and 8. A value of 8 for
    TSC_DIVISOR still allows for TSC frequencies up to
    2^32 / 10^9ns * 8 = 34.4GHz which is way larger than anything to expect
    in the next years.
    
    Thus we also replace the current TSC_DIVISOR value of 32 by 8. Reverse
    the order of the divison and the multiplication in the calculation of
    the registered clockevent device's frequency.
    
    Signed-off-by: Nicolai Stange <nicstange@gmail.com>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Reviewed-by: Paolo Bonzini <pbonzini@redhat.com>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Borislav Petkov <bp@suse.de>
    Cc: Christopher S. Hall <christopher.s.hall@intel.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Hidehiro Kawai <hidehiro.kawai.ez@hitachi.com>
    Cc: Len Brown <len.brown@intel.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Viresh Kumar <viresh.kumar@linaro.org>
    Link: http://lkml.kernel.org/r/20160714152255.18295-2-nicstange@gmail.com
    [ Improved changelog. ]
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 77a87824ed676ca8ff8482e4157d3adb284fd381
Author: Stephen Rothwell <sfr@canb.auug.org.au>
Date:   Thu Jul 7 13:59:06 2016 +1000

    clocksource/drivers/clps_711x: fixup for "ARM: clps711x:
    
     Switch to MULTIPLATFORM"
    
    Missed conflict between commit c86f51737f8d ("ARM: clps711x: Switch to
    MULTIPLATFORM") from the arm-soc tree and commit 250e46aa3bb3
    ("clocksource/drivers/clps_711x: Add the COMPILE_TEST option") from the
    clockevents tree.
    
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit 55392c4c06204c8149dc333309cf474691f1cc3c
Merge: c410614c9025 1f3b0f8243cb
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jul 25 20:43:12 2016 -0700

    Merge branch 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer updates from Thomas Gleixner:
     "This update provides the following changes:
    
       - The rework of the timer wheel which addresses the shortcomings of
         the current wheel (cascading, slow search for next expiring timer,
         etc).  That's the first major change of the wheel in almost 20
         years since Finn implemted it.
    
       - A large overhaul of the clocksource drivers init functions to
         consolidate the Device Tree initialization
    
       - Some more Y2038 updates
    
       - A capability fix for timerfd
    
       - Yet another clock chip driver
    
       - The usual pile of updates, comment improvements all over the place"
    
    * 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (130 commits)
      tick/nohz: Optimize nohz idle enter
      clockevents: Make clockevents_subsys static
      clocksource/drivers/time-armada-370-xp: Fix return value check
      timers: Implement optimization for same expiry time in mod_timer()
      timers: Split out index calculation
      timers: Only wake softirq if necessary
      timers: Forward the wheel clock whenever possible
      timers/nohz: Remove pointless tick_nohz_kick_tick() function
      timers: Optimize collect_expired_timers() for NOHZ
      timers: Move __run_timers() function
      timers: Remove set_timer_slack() leftovers
      timers: Switch to a non-cascading wheel
      timers: Reduce the CPU index space to 256k
      timers: Give a few structs and members proper names
      hlist: Add hlist_is_singular_node() helper
      signals: Use hrtimer for sigtimedwait()
      timers: Remove the deprecated mod_timer_pinned() API
      timers, net/ipv4/inet: Initialize connection request timers as pinned
      timers, drivers/tty/mips_ejtag: Initialize the poll timer as pinned
      timers, drivers/tty/metag_da: Initialize the poll timer as pinned
      ...

commit 6dabf2b7a597a9613f0b8a2fcbe01e2a0a05c896
Author: Huacai Chen <chenhc@lemote.com>
Date:   Thu Jul 21 14:27:49 2016 +0800

    MIPS: Fix r4k clockevents registration
    
    CPUFreq need min_delta_ticks/max_delta_ticks to be initialized, and
    this can be done by clockevents_config_and_register().
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Heiher <r@hev.cc>
    Signed-off-by: Huacai Chen <chenhc@lemote.com>
    Cc: John Crispin <john@phrozen.org>
    Cc: Steven J . Hill <Steven.Hill@imgtec.com>
    Cc: Fuxin Zhang <zhangfx@lemote.com>
    Cc: Zhangjin Wu <wuzhangjin@gmail.com>
    Cc: stable@vger.kernel.org
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/13817/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

commit 775be506266a860f141f6b848c92c316c602a94f
Author: Ben Dooks <ben.dooks@codethink.co.uk>
Date:   Fri Jun 17 16:56:14 2016 +0100

    clockevents: Make clockevents_subsys static
    
    The clockevents_subsys struct is used for sysfs support and
    is not declared or used outside the file it is defined in.
    Fix the following warning by making it static:
    
    kernel/time/clockevents.c:648:17: warning: symbol 'clockevents_subsys' was not declared. Should it be static?
    
    Signed-off-by: Ben Dooks <ben.dooks@codethink.co.uk>
    Cc: linux-kernel@lists.codethink.co.uk
    Link: http://lkml.kernel.org/r/1466178974-7105-1-git-send-email-ben.dooks@codethink.co.uk
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 27590dc17b34aedc4f3e14bd107ee59b9db9b0a6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Jul 15 10:41:04 2016 +0200

    hrtimer: Convert to hotplug state machine
    
    Split out the clockevents callbacks instead of piggybacking them on
    hrtimers.
    
    This gets rid of a POST_DEAD user. See commit:
    
      54e88fad223c ("sched: Make sure timers have migrated before killing the migration_thread")
    
    We just move the callback state to the proper place in the state machine.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Anna-Maria Gleixner <anna-maria@linutronix.de>
    Reviewed-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Cc: rt@linutronix.de
    Link: http://lkml.kernel.org/r/20160713153337.485419196@linutronix.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 3d93f42d449ace8e2dd8e2ec9790fdce31a14c9c
Merge: 4b4b20852d10 34c720a91585
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Jul 7 15:41:13 2016 +0200

    Merge branch 'clockevents/4.8' of http://git.linaro.org/people/daniel.lezcano/linux into timers/core
    
    Pull the clockevents/clocksource tree from Daniel Lezcano:
    
      - Convert the clocksource-probe init functions to return a value in order to
        prepare the consolidation of the drivers using the DT. It is a big patchset
        but went through 01.org (kbuild bot), linux next and kernel-ci (continuous
        integration) (Daniel Lezcano)
    
      - Fix a bad error handling by returning the right value for cadence_ttc
        (Christophe Jaillet)
    
      - Fix typo in the Kconfig for the Samsung pwm (Alexandre Belloni)
    
      - Change functions to static for armada-370-xp and digicolor (Ben Dooks)
    
      - Add support for the rk3399 SoC timer by adding bindings and a slight
        change in the base address. Take the opportunity to add the DYNIRQ flag
        (Huang Tao)
    
      - Fix endian accessors for the Samsung pwm timer (Matthew Leach)
    
      - Add Oxford Semiconductor RPS Dual Timer driver (Neil Armstrong)
    
      - Add a kernel parameter to swich on/off the event stream feature of the arch
        arm timer (Will Deacon)

commit 5130213721d01b6632c255d4295a8102cbb58379
Author: Jisheng Zhang <jszhang@marvell.com>
Date:   Tue Jul 5 16:57:51 2016 +0800

    tick/broadcast-hrtimer: Set name of the ce_broadcast_hrtimer
    
    This is to avoid the "null" name when we either
    
    ~ # cat /sys/devices/system/clockevents/broadcast/current_device
    (null)
    
    or
    
    ~ # cat /proc/timer_list
    ...
    Tick Device: mode:     1
    Broadcast device
    Clock Event Device: (null)
    ...
    
    Signed-off-by: Jisheng Zhang <jszhang@marvell.com>
    Cc: linux-arm-kernel@lists.infradead.org
    Link: http://lkml.kernel.org/r/1467709071-3667-1-git-send-email-jszhang@marvell.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 66d95b6705a6347f7b2645e042874ec0bb03b726
Author: Ying Xue <ying.xue@windriver.com>
Date:   Wed Jun 15 14:10:57 2016 +0800

    tipc: fix suspicious RCU usage
    
    When run tipcTS&tipcTC test suite, the following complaint appears:
    
    [   56.926168] ===============================
    [   56.926169] [ INFO: suspicious RCU usage. ]
    [   56.926171] 4.7.0-rc1+ #160 Not tainted
    [   56.926173] -------------------------------
    [   56.926174] net/tipc/bearer.c:408 suspicious rcu_dereference_protected() usage!
    [   56.926175]
    [   56.926175] other info that might help us debug this:
    [   56.926175]
    [   56.926177]
    [   56.926177] rcu_scheduler_active = 1, debug_locks = 1
    [   56.926179] 3 locks held by swapper/4/0:
    [   56.926180]  #0:  (((&req->timer))){+.-...}, at: [<ffffffff810e79b5>] call_timer_fn+0x5/0x340
    [   56.926203]  #1:  (&(&req->lock)->rlock){+.-...}, at: [<ffffffffa000c29b>] disc_timeout+0x1b/0xd0 [tipc]
    [   56.926212]  #2:  (rcu_read_lock){......}, at: [<ffffffffa00055e0>] tipc_bearer_xmit_skb+0xb0/0x2e0 [tipc]
    [   56.926218]
    [   56.926218] stack backtrace:
    [   56.926221] CPU: 4 PID: 0 Comm: swapper/4 Not tainted 4.7.0-rc1+ #160
    [   56.926222] Hardware name: Bochs Bochs, BIOS Bochs 01/01/2007
    [   56.926224]  0000000000000000 ffff880016803d28 ffffffff813c4423 ffff8800154252c0
    [   56.926227]  0000000000000001 ffff880016803d58 ffffffff810b7512 ffff8800124d8120
    [   56.926230]  ffff880013f8a160 ffff8800132b5ccc ffff8800124d8120 ffff880016803d88
    [   56.926234] Call Trace:
    [   56.926235]  <IRQ>  [<ffffffff813c4423>] dump_stack+0x67/0x94
    [   56.926250]  [<ffffffff810b7512>] lockdep_rcu_suspicious+0xe2/0x120
    [   56.926256]  [<ffffffffa00051f1>] tipc_l2_send_msg+0x131/0x1c0 [tipc]
    [   56.926261]  [<ffffffffa000567c>] tipc_bearer_xmit_skb+0x14c/0x2e0 [tipc]
    [   56.926266]  [<ffffffffa00055e0>] ? tipc_bearer_xmit_skb+0xb0/0x2e0 [tipc]
    [   56.926273]  [<ffffffffa000c280>] ? tipc_disc_init_msg+0x1f0/0x1f0 [tipc]
    [   56.926278]  [<ffffffffa000c280>] ? tipc_disc_init_msg+0x1f0/0x1f0 [tipc]
    [   56.926283]  [<ffffffffa000c2d6>] disc_timeout+0x56/0xd0 [tipc]
    [   56.926288]  [<ffffffff810e7a68>] call_timer_fn+0xb8/0x340
    [   56.926291]  [<ffffffff810e79b5>] ? call_timer_fn+0x5/0x340
    [   56.926296]  [<ffffffffa000c280>] ? tipc_disc_init_msg+0x1f0/0x1f0 [tipc]
    [   56.926300]  [<ffffffff810e8f4a>] run_timer_softirq+0x23a/0x390
    [   56.926306]  [<ffffffff810f89ff>] ? clockevents_program_event+0x7f/0x130
    [   56.926316]  [<ffffffff819727c3>] __do_softirq+0xc3/0x4a2
    [   56.926323]  [<ffffffff8106ba5a>] irq_exit+0x8a/0xb0
    [   56.926327]  [<ffffffff81972456>] smp_apic_timer_interrupt+0x46/0x60
    [   56.926331]  [<ffffffff81970a49>] apic_timer_interrupt+0x89/0x90
    [   56.926333]  <EOI>  [<ffffffff81027fda>] ? default_idle+0x2a/0x1a0
    [   56.926340]  [<ffffffff81027fd8>] ? default_idle+0x28/0x1a0
    [   56.926342]  [<ffffffff810289cf>] arch_cpu_idle+0xf/0x20
    [   56.926345]  [<ffffffff810adf0f>] default_idle_call+0x2f/0x50
    [   56.926347]  [<ffffffff810ae145>] cpu_startup_entry+0x215/0x3e0
    [   56.926353]  [<ffffffff81040ad9>] start_secondary+0xf9/0x100
    
    The warning appears as rtnl_dereference() is wrongly used in
    tipc_l2_send_msg() under RCU read lock protection. Instead the proper
    usage should be that rcu_dereference_rtnl() is called here.
    
    Fixes: 5b7066c3dd24 ("tipc: stricter filtering of packets in bearer layer")
    Acked-by: Jon Maloy <jon.maloy@ericsson.com>
    Signed-off-by: Ying Xue <ying.xue@windriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 91e8d0cbc94f81f110e508c3105dd93fb146d6b5
Merge: 2fe2edf85ffe 9999c5fc014a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue May 17 09:49:28 2016 -0700

    Merge branch 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer updates from Thomas Gleixner:
     "A rather small set of patches from the timer departement:
    
       - Some more y2038 work
       - Yet another new clocksource driver
       - The usual set of small fixes, cleanups and enhancements"
    
    * 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      clocksource/drivers/tegra: Remove unused suspend/resume code
      clockevents/driversi/mps2: add MPS2 Timer driver
      dt-bindings: document the MPS2 timer bindings
      clocksource/drivers/mtk_timer: Add __init attribute
      clockevents/drivers/dw_apb_timer: Implement ->set_state_oneshot_stopped()
      time: Introduce do_sys_settimeofday64()
      security: Introduce security_settime64()
      clocksource: Add missing include of of.h.

commit 0302637f1860400cfe0895e4355a5fecb89e0347
Author: Vladimir Murzin <vladimir.murzin@arm.com>
Date:   Mon Apr 25 09:45:44 2016 +0100

    clockevents/driversi/mps2: add MPS2 Timer driver
    
    MPS2 platform has simple 32 bits general purpose countdown timers.
    
    The driver uses the first detected timer as a clocksource and the rest
    of the timers as a clockevent
    
    Acked-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Signed-off-by: Vladimir Murzin <vladimir.murzin@arm.com>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit 457353260d9ff4b89bcf21c9142b2f54ed75699e
Author: Jisheng Zhang <jszhang@marvell.com>
Date:   Fri Feb 26 17:45:57 2016 +0800

    clockevents/drivers/dw_apb_timer: Implement ->set_state_oneshot_stopped()
    
    The dw_apb_timer only "supports PERIODIC mode and their drivers emulate
    ONESHOT over that" as described in commit 8fff52fd5093 ("clockevents:
    Introduce CLOCK_EVT_STATE_ONESHOT_STOPPED state").
    
    Inspired by Viresh, I think the dw_apb_timer also needs to implement
    the set_state_oneshot_stopped() which is called by the clkevt core,
    when the next event is required at an expiry time of 'KTIME_MAX'. This
    normally happens with NO_HZ_{IDLE|FULL} in both LOWRES/HIGHRES modes.
    
    This patch makes the clockevent device to stop on such an event, to
    avoid spurious interrupts, as explained by the above commit.
    
    Signed-off-by: Jisheng Zhang <jszhang@marvell.com>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Reviewed-by: Viresh Kumar <viresh.kumar@linaro.org>

commit 8a284c062ec923c924c79e3b1b5199b8d72904fc
Merge: 208de2147767 6436257b491c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Mar 15 12:13:56 2016 -0700

    Merge branch 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer updates from Thomas Gleixner:
     "The timer department delivers this time:
    
       - Support for cross clock domain timestamps in the core code plus a
         first user.  That allows more precise timestamping for PTP and
         later for audio and other peripherals.
    
         The ptp/e1000e patches have been acked by the relevant maintainers
         and are carried in the timer tree to avoid merge ordering issues.
    
       - Support for unregistering the current clocksource watchdog.  That
         lifts a limitation for switching clocksources which has been there
         from day 1
    
       - The usual pile of fixes and updates to the core and the drivers.
         Nothing outstanding and exciting"
    
    * 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (26 commits)
      time/timekeeping: Work around false positive GCC warning
      e1000e: Adds hardware supported cross timestamp on e1000e nic
      ptp: Add PTP_SYS_OFFSET_PRECISE for driver crosstimestamping
      x86/tsc: Always Running Timer (ART) correlated clocksource
      hrtimer: Revert CLOCK_MONOTONIC_RAW support
      time: Add history to cross timestamp interface supporting slower devices
      time: Add driver cross timestamp interface for higher precision time synchronization
      time: Remove duplicated code in ktime_get_raw_and_real()
      time: Add timekeeping snapshot code capturing system time and counter
      time: Add cycles to nanoseconds translation
      jiffies: Use CLOCKSOURCE_MASK instead of constant
      clocksource: Introduce clocksource_freq2mult()
      clockevents/drivers/exynos_mct: Implement ->set_state_oneshot_stopped()
      clockevents/drivers/arm_global_timer: Implement ->set_state_oneshot_stopped()
      clockevents/drivers/arm_arch_timer: Implement ->set_state_oneshot_stopped()
      clocksource/drivers/arm_global_timer: Register delay timer
      clocksource/drivers/lpc32xx: Support timer-based ARM delay
      clocksource/drivers/lpc32xx: Support periodic mode
      clocksource/drivers/lpc32xx: Don't use the prescaler counter for clockevents
      clocksource/drivers/rockchip: Add err handle for rk_timer_init
      ...

commit c0cbcf2cb59c076f4ff6422153534dd2762c3d44
Author: Alexandre Belloni <alexandre.belloni@free-electrons.com>
Date:   Fri Jan 15 11:34:21 2016 +0100

    clockevents/tcb_clksrc: Prevent disabling an already disabled clock
    
    commit f02b4b72d12cbae7020a959e2ed0410a464b4cc4 upstream.
    
    clockevents_exchange_device is calling clockevents_shutdown() on the new
    clockenvents device but it may have never been enabled in the first place.
    This results in the tcb clock being disabled without being enabled first:
    
    ------------[ cut here ]------------
    WARNING: CPU: 0 PID: 1 at drivers/clk/clk.c:680 clk_disable+0x28/0x34()
    Modules linked in:
    CPU: 0 PID: 1 Comm: swapper Not tainted 4.4.0+ #6
    Hardware name: Atmel AT91SAM9
    [<c000f2b8>] (unwind_backtrace) from [<c000d01c>] (show_stack+0x10/0x14)
    [<c000d01c>] (show_stack) from [<c00172f0>] (warn_slowpath_common+0x78/0xa0)
    [<c00172f0>] (warn_slowpath_common) from [<c00173a8>] (warn_slowpath_null+0x18/0x20)
    [<c00173a8>] (warn_slowpath_null) from [<c0361528>] (clk_disable+0x28/0x34)
    [<c0361528>] (clk_disable) from [<c034d560>] (tc_shutdown+0x38/0x4c)
    [<c034d560>] (tc_shutdown) from [<c0059ad4>] (clockevents_switch_state+0x38/0x6c)
    [<c0059ad4>] (clockevents_switch_state) from [<c0059b18>] (clockevents_shutdown+0x10/0x24)
    [<c0059b18>] (clockevents_shutdown) from [<c005a458>] (tick_check_new_device+0x84/0xac)
    [<c005a458>] (tick_check_new_device) from [<c0059660>] (clockevents_register_device+0x7c/0x108)
    [<c0059660>] (clockevents_register_device) from [<c06b5a68>] (tcb_clksrc_init+0x390/0x3e8)
    [<c06b5a68>] (tcb_clksrc_init) from [<c00097cc>] (do_one_initcall+0x114/0x1d4)
    [<c00097cc>] (do_one_initcall) from [<c069bd54>] (kernel_init_freeable+0xfc/0x1b8)
    [<c069bd54>] (kernel_init_freeable) from [<c04c3818>] (kernel_init+0x8/0xe0)
    [<c04c3818>] (kernel_init) from [<c000a410>] (ret_from_fork+0x14/0x24)
    ---[ end trace 0000000000000001 ]---
    
    Check what state we were in before trying to disable the clock.
    
    Fixes: cf4541c101ea ("clockevents/drivers/tcb_clksrc: Migrate to new 'set-state' interface")
    Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Cc: Nicolas Ferre <nicolas.ferre@atmel.com>
    Cc: Boris Brezillon <boris.brezillon@free-electrons.com>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Link: http://lkml.kernel.org/r/1452854061-30370-1-git-send-email-alexandre.belloni@free-electrons.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 142ad71dd6de7368cc8cc5c52288b628062f391d
Author: Roman Volkov <rvolkov@v1ros.org>
Date:   Fri Jan 1 16:24:41 2016 +0300

    clocksource/drivers/vt8500: Increase the minimum delta
    
    commit f9eccf24615672896dc13251410c3f2f33a14f95 upstream.
    
    The vt8500 clocksource driver declares itself as capable to handle the
    minimum delay of 4 cycles by passing the value into
    clockevents_config_and_register(). The vt8500_timer_set_next_event()
    requires the passed cycles value to be at least 16. The impact is that
    userspace hangs in nanosleep() calls with small delay intervals.
    
    This problem is reproducible in Linux 4.2 starting from:
    c6eb3f70d448 ('hrtimer: Get rid of hrtimer softirq')
    
    From Russell King, more detailed explanation:
    
    "It's a speciality of the StrongARM/PXA hardware. It takes a certain
    number of OSCR cycles for the value written to hit the compare registers.
    So, if a very small delta is written (eg, the compare register is written
    with a value of OSCR + 1), the OSCR will have incremented past this value
    before it hits the underlying hardware. The result is, that you end up
    waiting a very long time for the OSCR to wrap before the event fires.
    
    So, we introduce a check in set_next_event() to detect this and return
    -ETIME if the calculated delta is too small, which causes the generic
    clockevents code to retry after adding the min_delta specified in
    clockevents_config_and_register() to the current time value.
    
    min_delta must be sufficient that we don't re-trip the -ETIME check - if
    we do, we will return -ETIME, forward the next event time, try to set it,
    return -ETIME again, and basically lock the system up. So, min_delta
    must be larger than the check inside set_next_event(). A factor of two
    was chosen to ensure that this situation would never occur.
    
    The PXA code worked on PXA systems for years, and I'd suggest no one
    changes this mechanism without access to a wide range of PXA systems,
    otherwise they're risking breakage."
    
    Cc: Russell King <linux@arm.linux.org.uk>
    Acked-by: Alexey Charkov <alchark@gmail.com>
    Signed-off-by: Roman Volkov <rvolkov@v1ros.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 194770bb72f1c59c7f0872635a30dde361c9dfc7
Author: Roman Volkov <rvolkov@v1ros.org>
Date:   Fri Jan 1 16:24:41 2016 +0300

    clocksource/drivers/vt8500: Increase the minimum delta
    
    commit f9eccf24615672896dc13251410c3f2f33a14f95 upstream.
    
    The vt8500 clocksource driver declares itself as capable to handle the
    minimum delay of 4 cycles by passing the value into
    clockevents_config_and_register(). The vt8500_timer_set_next_event()
    requires the passed cycles value to be at least 16. The impact is that
    userspace hangs in nanosleep() calls with small delay intervals.
    
    This problem is reproducible in Linux 4.2 starting from:
    c6eb3f70d448 ('hrtimer: Get rid of hrtimer softirq')
    
    From Russell King, more detailed explanation:
    
    "It's a speciality of the StrongARM/PXA hardware. It takes a certain
    number of OSCR cycles for the value written to hit the compare registers.
    So, if a very small delta is written (eg, the compare register is written
    with a value of OSCR + 1), the OSCR will have incremented past this value
    before it hits the underlying hardware. The result is, that you end up
    waiting a very long time for the OSCR to wrap before the event fires.
    
    So, we introduce a check in set_next_event() to detect this and return
    -ETIME if the calculated delta is too small, which causes the generic
    clockevents code to retry after adding the min_delta specified in
    clockevents_config_and_register() to the current time value.
    
    min_delta must be sufficient that we don't re-trip the -ETIME check - if
    we do, we will return -ETIME, forward the next event time, try to set it,
    return -ETIME again, and basically lock the system up. So, min_delta
    must be larger than the check inside set_next_event(). A factor of two
    was chosen to ensure that this situation would never occur.
    
    The PXA code worked on PXA systems for years, and I'd suggest no one
    changes this mechanism without access to a wide range of PXA systems,
    otherwise they're risking breakage."
    
    Cc: Russell King <linux@arm.linux.org.uk>
    Acked-by: Alexey Charkov <alchark@gmail.com>
    Signed-off-by: Roman Volkov <rvolkov@v1ros.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 1644fe6cc1567ecde034ea8acd5f4d6146e395b5
Author: Roman Volkov <rvolkov@v1ros.org>
Date:   Fri Jan 1 16:24:41 2016 +0300

    clocksource/drivers/vt8500: Increase the minimum delta
    
    commit f9eccf24615672896dc13251410c3f2f33a14f95 upstream.
    
    The vt8500 clocksource driver declares itself as capable to handle the
    minimum delay of 4 cycles by passing the value into
    clockevents_config_and_register(). The vt8500_timer_set_next_event()
    requires the passed cycles value to be at least 16. The impact is that
    userspace hangs in nanosleep() calls with small delay intervals.
    
    This problem is reproducible in Linux 4.2 starting from:
    c6eb3f70d448 ('hrtimer: Get rid of hrtimer softirq')
    
    From Russell King, more detailed explanation:
    
    "It's a speciality of the StrongARM/PXA hardware. It takes a certain
    number of OSCR cycles for the value written to hit the compare registers.
    So, if a very small delta is written (eg, the compare register is written
    with a value of OSCR + 1), the OSCR will have incremented past this value
    before it hits the underlying hardware. The result is, that you end up
    waiting a very long time for the OSCR to wrap before the event fires.
    
    So, we introduce a check in set_next_event() to detect this and return
    -ETIME if the calculated delta is too small, which causes the generic
    clockevents code to retry after adding the min_delta specified in
    clockevents_config_and_register() to the current time value.
    
    min_delta must be sufficient that we don't re-trip the -ETIME check - if
    we do, we will return -ETIME, forward the next event time, try to set it,
    return -ETIME again, and basically lock the system up. So, min_delta
    must be larger than the check inside set_next_event(). A factor of two
    was chosen to ensure that this situation would never occur.
    
    The PXA code worked on PXA systems for years, and I'd suggest no one
    changes this mechanism without access to a wide range of PXA systems,
    otherwise they're risking breakage."
    
    Cc: Russell King <linux@arm.linux.org.uk>
    Acked-by: Alexey Charkov <alchark@gmail.com>
    Signed-off-by: Roman Volkov <rvolkov@v1ros.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 0ea3c0a5ae0b286ccb86212350258caae8a7f0eb
Author: Roman Volkov <rvolkov@v1ros.org>
Date:   Fri Jan 1 16:24:41 2016 +0300

    clocksource/drivers/vt8500: Increase the minimum delta
    
    commit f9eccf24615672896dc13251410c3f2f33a14f95 upstream.
    
    The vt8500 clocksource driver declares itself as capable to handle the
    minimum delay of 4 cycles by passing the value into
    clockevents_config_and_register(). The vt8500_timer_set_next_event()
    requires the passed cycles value to be at least 16. The impact is that
    userspace hangs in nanosleep() calls with small delay intervals.
    
    This problem is reproducible in Linux 4.2 starting from:
    c6eb3f70d448 ('hrtimer: Get rid of hrtimer softirq')
    
    From Russell King, more detailed explanation:
    
    "It's a speciality of the StrongARM/PXA hardware. It takes a certain
    number of OSCR cycles for the value written to hit the compare registers.
    So, if a very small delta is written (eg, the compare register is written
    with a value of OSCR + 1), the OSCR will have incremented past this value
    before it hits the underlying hardware. The result is, that you end up
    waiting a very long time for the OSCR to wrap before the event fires.
    
    So, we introduce a check in set_next_event() to detect this and return
    -ETIME if the calculated delta is too small, which causes the generic
    clockevents code to retry after adding the min_delta specified in
    clockevents_config_and_register() to the current time value.
    
    min_delta must be sufficient that we don't re-trip the -ETIME check - if
    we do, we will return -ETIME, forward the next event time, try to set it,
    return -ETIME again, and basically lock the system up. So, min_delta
    must be larger than the check inside set_next_event(). A factor of two
    was chosen to ensure that this situation would never occur.
    
    The PXA code worked on PXA systems for years, and I'd suggest no one
    changes this mechanism without access to a wide range of PXA systems,
    otherwise they're risking breakage."
    
    Cc: Russell King <linux@arm.linux.org.uk>
    Acked-by: Alexey Charkov <alchark@gmail.com>
    Signed-off-by: Roman Volkov <rvolkov@v1ros.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>

commit 07f101d33def572c7018626735475f88dabecebf
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Wed Dec 23 16:59:14 2015 +0530

    clockevents/drivers/exynos_mct: Implement ->set_state_oneshot_stopped()
    
    set_state_oneshot_stopped() is called by the clkevt core, when the next
    event is required at an expiry time of 'KTIME_MAX'. This normally
    happens with NO_HZ_{IDLE|FULL} in both LOWRES/HIGHRES modes.
    
    This patch makes the clockevent device to stop on such an event, to
    avoid spurious interrupts, as explained by: commit 8fff52fd5093
    ("clockevents: Introduce CLOCK_EVT_STATE_ONESHOT_STOPPED state").
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit 3effa3ceea2da9f67f042a694e24ba0d8143cff8
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Wed Dec 23 16:59:13 2015 +0530

    clockevents/drivers/arm_global_timer: Implement ->set_state_oneshot_stopped()
    
    set_state_oneshot_stopped() is called by the clkevt core, when the next
    event is required at an expiry time of 'KTIME_MAX'. This normally
    happens with NO_HZ_{IDLE|FULL} in both LOWRES/HIGHRES modes.
    
    This patch makes the clockevent device to stop on such an event, to
    avoid spurious interrupts, as explained by: commit 8fff52fd5093
    ("clockevents: Introduce CLOCK_EVT_STATE_ONESHOT_STOPPED state").
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit cf8c5009ee37d25cf4da0a250f3044ec6d1144a0
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Wed Dec 23 16:59:12 2015 +0530

    clockevents/drivers/arm_arch_timer: Implement ->set_state_oneshot_stopped()
    
    set_state_oneshot_stopped() is called by the clkevt core, when the next
    event is required at an expiry time of 'KTIME_MAX'. This normally
    happens with NO_HZ_{IDLE|FULL} in both LOWRES/HIGHRES modes.
    
    This patch makes the clockevent device to stop on such an event, to
    avoid spurious interrupts, as explained by: commit 8fff52fd5093
    ("clockevents: Introduce CLOCK_EVT_STATE_ONESHOT_STOPPED state").
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit 751db1a6eaec3d266ccfe3f0d11323b7c82486bf
Author: Ezequiel Garcia <ezequiel@vanguardiasur.com.ar>
Date:   Tue Feb 9 22:54:25 2016 -0300

    clocksource/drivers/lpc32xx: Don't use the prescaler counter for clockevents
    
    This commit switches the clockevents one-shot current implementation
    to avoid using the prescaler counter. The clockevents timer currently
    uses MR0=1, PR=ticks; and after this commit is uses MR0=ticks, PR=0.
    
    While using the prescaler with PR=1 works fine in one-shot mode,
    it seems it doesn't work as expected in periodic mode.
    
    By using the only match channel register (MR0) for the timer we make
    the periodic mode introduction easier, and consistent with one-shot mode.
    
    Signed-off-by: Ezequiel Garcia <ezequiel@vanguardiasur.com.ar>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Reviewed-by: Joachim Eastwood <manabian@gmail.com>
    Tested-by: Joachim Eastwood <manabian@gmail.com>

commit 27853751e20c1d4c3d060210d38cc0b63ac0c991
Author: Roman Volkov <rvolkov@v1ros.org>
Date:   Fri Jan 1 16:24:41 2016 +0300

    clocksource/drivers/vt8500: Increase the minimum delta
    
    [ Upstream commit f9eccf24615672896dc13251410c3f2f33a14f95 ]
    
    The vt8500 clocksource driver declares itself as capable to handle the
    minimum delay of 4 cycles by passing the value into
    clockevents_config_and_register(). The vt8500_timer_set_next_event()
    requires the passed cycles value to be at least 16. The impact is that
    userspace hangs in nanosleep() calls with small delay intervals.
    
    This problem is reproducible in Linux 4.2 starting from:
    c6eb3f70d448 ('hrtimer: Get rid of hrtimer softirq')
    
    From Russell King, more detailed explanation:
    
    "It's a speciality of the StrongARM/PXA hardware. It takes a certain
    number of OSCR cycles for the value written to hit the compare registers.
    So, if a very small delta is written (eg, the compare register is written
    with a value of OSCR + 1), the OSCR will have incremented past this value
    before it hits the underlying hardware. The result is, that you end up
    waiting a very long time for the OSCR to wrap before the event fires.
    
    So, we introduce a check in set_next_event() to detect this and return
    -ETIME if the calculated delta is too small, which causes the generic
    clockevents code to retry after adding the min_delta specified in
    clockevents_config_and_register() to the current time value.
    
    min_delta must be sufficient that we don't re-trip the -ETIME check - if
    we do, we will return -ETIME, forward the next event time, try to set it,
    return -ETIME again, and basically lock the system up. So, min_delta
    must be larger than the check inside set_next_event(). A factor of two
    was chosen to ensure that this situation would never occur.
    
    The PXA code worked on PXA systems for years, and I'd suggest no one
    changes this mechanism without access to a wide range of PXA systems,
    otherwise they're risking breakage."
    
    Cc: stable@vger.kernel.org
    Cc: Russell King <linux@arm.linux.org.uk>
    Acked-by: Alexey Charkov <alchark@gmail.com>
    Signed-off-by: Roman Volkov <rvolkov@v1ros.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Signed-off-by: Sasha Levin <sasha.levin@oracle.com>

commit bb0395416bd0cd4f230923ca7e0108b4ca246ab5
Author: Roman Volkov <rvolkov@v1ros.org>
Date:   Fri Jan 1 16:24:41 2016 +0300

    clocksource/drivers/vt8500: Increase the minimum delta
    
    commit f9eccf24615672896dc13251410c3f2f33a14f95 upstream.
    
    The vt8500 clocksource driver declares itself as capable to handle the
    minimum delay of 4 cycles by passing the value into
    clockevents_config_and_register(). The vt8500_timer_set_next_event()
    requires the passed cycles value to be at least 16. The impact is that
    userspace hangs in nanosleep() calls with small delay intervals.
    
    This problem is reproducible in Linux 4.2 starting from:
    c6eb3f70d448 ('hrtimer: Get rid of hrtimer softirq')
    
    From Russell King, more detailed explanation:
    
    "It's a speciality of the StrongARM/PXA hardware. It takes a certain
    number of OSCR cycles for the value written to hit the compare registers.
    So, if a very small delta is written (eg, the compare register is written
    with a value of OSCR + 1), the OSCR will have incremented past this value
    before it hits the underlying hardware. The result is, that you end up
    waiting a very long time for the OSCR to wrap before the event fires.
    
    So, we introduce a check in set_next_event() to detect this and return
    -ETIME if the calculated delta is too small, which causes the generic
    clockevents code to retry after adding the min_delta specified in
    clockevents_config_and_register() to the current time value.
    
    min_delta must be sufficient that we don't re-trip the -ETIME check - if
    we do, we will return -ETIME, forward the next event time, try to set it,
    return -ETIME again, and basically lock the system up. So, min_delta
    must be larger than the check inside set_next_event(). A factor of two
    was chosen to ensure that this situation would never occur.
    
    The PXA code worked on PXA systems for years, and I'd suggest no one
    changes this mechanism without access to a wide range of PXA systems,
    otherwise they're risking breakage."
    
    Cc: Russell King <linux@arm.linux.org.uk>
    Acked-by: Alexey Charkov <alchark@gmail.com>
    Signed-off-by: Roman Volkov <rvolkov@v1ros.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Signed-off-by: Luis Henriques <luis.henriques@canonical.com>

commit dc799d0179baa7f62d2e73a8217a273ca82adbdf
Merge: 7ab85d4a8516 1ca8ec532fc2
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Jan 31 15:49:06 2016 -0800

    Merge branch 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer fixes from Thomas Gleixner:
     "The timer departement delivers:
    
       - a regression fix for the NTP code along with a proper selftest
       - prevent a spurious timer interrupt in the NOHZ lowres code
       - a fix for user space interfaces returning the remaining time on
         architectures with CONFIG_TIME_LOW_RES=y
       - a few patches to fix COMPILE_TEST fallout"
    
    * 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      tick/nohz: Set the correct expiry when switching to nohz/lowres mode
      clocksource: Fix dependencies for archs w/o HAS_IOMEM
      clocksource: Select CLKSRC_MMIO where needed
      tick/sched: Hide unused oneshot timer code
      kselftests: timers: Add adjtimex SETOFFSET validity tests
      ntp: Fix ADJ_SETOFFSET being used w/ ADJ_NANO
      itimers: Handle relative timers with CONFIG_TIME_LOW_RES proper
      posix-timers: Handle relative timers with CONFIG_TIME_LOW_RES proper
      timerfd: Handle relative timers with CONFIG_TIME_LOW_RES proper
      hrtimer: Handle remaining time proper for TIME_LOW_RES
      clockevents/tcb_clksrc: Prevent disabling an already disabled clock

commit dd42ac8f02aea32661756554aace2095f7181d34
Author: Alexander Kuleshov <kuleshovmail@gmail.com>
Date:   Fri Oct 16 15:20:53 2015 +0600

    clockevents: Rename last parameter of clocks_calc_mult_shift() to maxsec
    
    Last parameter of the clocks_calc_mult_shift() was renamed from minsec to
    maxsec in the 5fdade95 (time: Rename misnamed minsec argument of
    clocks_calc_mult_shift()).
    
    Signed-off-by: Alexander Kuleshov <kuleshovmail@gmail.com>
    Link: http://lkml.kernel.org/r/1444987253-11018-1-git-send-email-kuleshovmail@gmail.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit c6d308534aef6c99904bf5862066360ae067abc4
Author: Andrey Ryabinin <aryabinin@virtuozzo.com>
Date:   Wed Jan 20 15:00:55 2016 -0800

    UBSAN: run-time undefined behavior sanity checker
    
    UBSAN uses compile-time instrumentation to catch undefined behavior
    (UB).  Compiler inserts code that perform certain kinds of checks before
    operations that could cause UB.  If check fails (i.e.  UB detected)
    __ubsan_handle_* function called to print error message.
    
    So the most of the work is done by compiler.  This patch just implements
    ubsan handlers printing errors.
    
    GCC has this capability since 4.9.x [1] (see -fsanitize=undefined
    option and its suboptions).
    However GCC 5.x has more checkers implemented [2].
    Article [3] has a bit more details about UBSAN in the GCC.
    
    [1] - https://gcc.gnu.org/onlinedocs/gcc-4.9.0/gcc/Debugging-Options.html
    [2] - https://gcc.gnu.org/onlinedocs/gcc/Debugging-Options.html
    [3] - http://developerblog.redhat.com/2014/10/16/gcc-undefined-behavior-sanitizer-ubsan/
    
    Issues which UBSAN has found thus far are:
    
    Found bugs:
    
     * out-of-bounds access - 97840cb67ff5 ("netfilter: nfnetlink: fix
       insufficient validation in nfnetlink_bind")
    
    undefined shifts:
    
     * d48458d4a768 ("jbd2: use a better hash function for the revoke
       table")
    
     * 10632008b9e1 ("clockevents: Prevent shift out of bounds")
    
     * 'x << -1' shift in ext4 -
       http://lkml.kernel.org/r/<5444EF21.8020501@samsung.com>
    
     * undefined rol32(0) -
       http://lkml.kernel.org/r/<1449198241-20654-1-git-send-email-sasha.levin@oracle.com>
    
     * undefined dirty_ratelimit calculation -
       http://lkml.kernel.org/r/<566594E2.3050306@odin.com>
    
     * undefined roundown_pow_of_two(0) -
       http://lkml.kernel.org/r/<1449156616-11474-1-git-send-email-sasha.levin@oracle.com>
    
     * [WONTFIX] undefined shift in __bpf_prog_run -
       http://lkml.kernel.org/r/<CACT4Y+ZxoR3UjLgcNdUm4fECLMx2VdtfrENMtRRCdgHB2n0bJA@mail.gmail.com>
    
       WONTFIX here because it should be fixed in bpf program, not in kernel.
    
    signed overflows:
    
     * 32a8df4e0b33f ("sched: Fix odd values in effective_load()
       calculations")
    
     * mul overflow in ntp -
       http://lkml.kernel.org/r/<1449175608-1146-1-git-send-email-sasha.levin@oracle.com>
    
     * incorrect conversion into rtc_time in rtc_time64_to_tm() -
       http://lkml.kernel.org/r/<1449187944-11730-1-git-send-email-sasha.levin@oracle.com>
    
     * unvalidated timespec in io_getevents() -
       http://lkml.kernel.org/r/<CACT4Y+bBxVYLQ6LtOKrKtnLthqLHcw-BMp3aqP3mjdAvr9FULQ@mail.gmail.com>
    
     * [NOTABUG] signed overflow in ktime_add_safe() -
       http://lkml.kernel.org/r/<CACT4Y+aJ4muRnWxsUe1CMnA6P8nooO33kwG-c8YZg=0Xc8rJqw@mail.gmail.com>
    
    [akpm@linux-foundation.org: fix unused local warning]
    [akpm@linux-foundation.org: fix __int128 build woes]
    Signed-off-by: Andrey Ryabinin <aryabinin@virtuozzo.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Cc: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Cc: Jonathan Corbet <corbet@lwn.net>
    Cc: Michal Marek <mmarek@suse.cz>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: Yury Gribov <y.gribov@samsung.com>
    Cc: Dmitry Vyukov <dvyukov@google.com>
    Cc: Konstantin Khlebnikov <koct9i@gmail.com>
    Cc: Kostya Serebryany <kcc@google.com>
    Cc: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit f02b4b72d12cbae7020a959e2ed0410a464b4cc4
Author: Alexandre Belloni <alexandre.belloni@free-electrons.com>
Date:   Fri Jan 15 11:34:21 2016 +0100

    clockevents/tcb_clksrc: Prevent disabling an already disabled clock
    
    clockevents_exchange_device is calling clockevents_shutdown() on the new
    clockenvents device but it may have never been enabled in the first place.
    This results in the tcb clock being disabled without being enabled first:
    
    ------------[ cut here ]------------
    WARNING: CPU: 0 PID: 1 at drivers/clk/clk.c:680 clk_disable+0x28/0x34()
    Modules linked in:
    CPU: 0 PID: 1 Comm: swapper Not tainted 4.4.0+ #6
    Hardware name: Atmel AT91SAM9
    [<c000f2b8>] (unwind_backtrace) from [<c000d01c>] (show_stack+0x10/0x14)
    [<c000d01c>] (show_stack) from [<c00172f0>] (warn_slowpath_common+0x78/0xa0)
    [<c00172f0>] (warn_slowpath_common) from [<c00173a8>] (warn_slowpath_null+0x18/0x20)
    [<c00173a8>] (warn_slowpath_null) from [<c0361528>] (clk_disable+0x28/0x34)
    [<c0361528>] (clk_disable) from [<c034d560>] (tc_shutdown+0x38/0x4c)
    [<c034d560>] (tc_shutdown) from [<c0059ad4>] (clockevents_switch_state+0x38/0x6c)
    [<c0059ad4>] (clockevents_switch_state) from [<c0059b18>] (clockevents_shutdown+0x10/0x24)
    [<c0059b18>] (clockevents_shutdown) from [<c005a458>] (tick_check_new_device+0x84/0xac)
    [<c005a458>] (tick_check_new_device) from [<c0059660>] (clockevents_register_device+0x7c/0x108)
    [<c0059660>] (clockevents_register_device) from [<c06b5a68>] (tcb_clksrc_init+0x390/0x3e8)
    [<c06b5a68>] (tcb_clksrc_init) from [<c00097cc>] (do_one_initcall+0x114/0x1d4)
    [<c00097cc>] (do_one_initcall) from [<c069bd54>] (kernel_init_freeable+0xfc/0x1b8)
    [<c069bd54>] (kernel_init_freeable) from [<c04c3818>] (kernel_init+0x8/0xe0)
    [<c04c3818>] (kernel_init) from [<c000a410>] (ret_from_fork+0x14/0x24)
    ---[ end trace 0000000000000001 ]---
    
    Check what state we were in before trying to disable the clock.
    
    Fixes: cf4541c101ea ("clockevents/drivers/tcb_clksrc: Migrate to new 'set-state' interface")
    Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Cc: Nicolas Ferre <nicolas.ferre@atmel.com>
    Cc: Boris Brezillon <boris.brezillon@free-electrons.com>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: stable@vger.kernel.org
    Link: http://lkml.kernel.org/r/1452854061-30370-1-git-send-email-alexandre.belloni@free-electrons.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 1f16f116b01c110db20ab808562c8b8bc3ee3d6e
Merge: 03724ac3d48f f9eccf246156
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jan 12 11:01:12 2016 +0100

    Merge branches 'clockevents/4.4-fixes' and 'clockevents/4.5-fixes' of http://git.linaro.org/people/daniel.lezcano/linux into timers/urgent
    
    Pull in fixes from Daniel Lezcano:
    
     - Fix the vt8500 timer leading to a system lock up when dealing with too
       small delta (Roman Volkov)
    
     - Select the CLKSRC_MMIO when the fsl_ftm_timer is enabled with COMPILE_TEST
       (Daniel Lezcano)
    
     - Prevent to compile timers using the 'iomem' API when the architecture has
       not HAS_IOMEM set (Richard Weinberger)

commit b4cee21ee057ff3e5c9014fb6a175bd932c5ce62
Merge: ae8a52185e5c 01414888eaf7 1b9f23727abb
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jan 11 18:06:43 2016 -0800

    Merge branches 'timers-core-for-linus' and 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer updates - and a leftover fix - from Thomas Gleixner:
     "A rather large (commit wise) update from the timer side:
    
       - A bulk update to make compile tests work in the clocksource drivers
    
       - An overhaul of the h8300 timers
    
       - Some more Y2038 work
    
       - A few overflow prevention checks in the timekeeping/ntp code
    
       - The usual pile of fixes and improvements to the various
         clocksource/clockevent drivers and core code"
    
    Also:
     "A single fix for the posix-clock poll code which did not make it into
      4.4"
    
    * 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (84 commits)
      clocksource/drivers/acpi_pm: Convert to pr_* macros
      clocksource: Make clocksource validation work for all clocksources
      timekeeping: Cap adjustments so they don't exceed the maxadj value
      ntp: Fix second_overflow's input parameter type to be 64bits
      ntp: Change time_reftime to time64_t and utilize 64bit __ktime_get_real_seconds
      timekeeping: Provide internal function __ktime_get_real_seconds
      clocksource/drivers/h8300: Use ioread / iowrite
      clocksource/drivers/h8300: Initializer cleanup.
      clocksource/drivers/h8300: Simplify delta handling
      clocksource/drivers/h8300: Fix timer not overflow case
      clocksource/drivers/h8300: Change to overflow interrupt
      clocksource/drivers/lpc32: Correct pr_err() output format
      clocksource/drivers/arm_global_timer: Fix suspend resume
      clocksource/drivers/pistachio: Fix wrong calculated clocksource read value
      clockevents/drivers/arm_global_timer: Use writel_relaxed in gt_compare_set
      clocksource/drivers/dw_apb_timer: Inline apbt_readl and apbt_writel
      clocksource/drivers/dw_apb_timer: Use {readl|writel}_relaxed in critical path
      clocksource/drivers/dw_apb_timer: Fix apbt_readl return types
      clocksource/drivers/tango-xtal: Replace code by clocksource_mmio_init
      clocksource/drivers/h8300: Increase the compilation test coverage
      ...
    
    * 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      posix-clock: Fix return code on the poll method's error path

commit f9eccf24615672896dc13251410c3f2f33a14f95
Author: Roman Volkov <rvolkov@v1ros.org>
Date:   Fri Jan 1 16:24:41 2016 +0300

    clocksource/drivers/vt8500: Increase the minimum delta
    
    The vt8500 clocksource driver declares itself as capable to handle the
    minimum delay of 4 cycles by passing the value into
    clockevents_config_and_register(). The vt8500_timer_set_next_event()
    requires the passed cycles value to be at least 16. The impact is that
    userspace hangs in nanosleep() calls with small delay intervals.
    
    This problem is reproducible in Linux 4.2 starting from:
    c6eb3f70d448 ('hrtimer: Get rid of hrtimer softirq')
    
    From Russell King, more detailed explanation:
    
    "It's a speciality of the StrongARM/PXA hardware. It takes a certain
    number of OSCR cycles for the value written to hit the compare registers.
    So, if a very small delta is written (eg, the compare register is written
    with a value of OSCR + 1), the OSCR will have incremented past this value
    before it hits the underlying hardware. The result is, that you end up
    waiting a very long time for the OSCR to wrap before the event fires.
    
    So, we introduce a check in set_next_event() to detect this and return
    -ETIME if the calculated delta is too small, which causes the generic
    clockevents code to retry after adding the min_delta specified in
    clockevents_config_and_register() to the current time value.
    
    min_delta must be sufficient that we don't re-trip the -ETIME check - if
    we do, we will return -ETIME, forward the next event time, try to set it,
    return -ETIME again, and basically lock the system up. So, min_delta
    must be larger than the check inside set_next_event(). A factor of two
    was chosen to ensure that this situation would never occur.
    
    The PXA code worked on PXA systems for years, and I'd suggest no one
    changes this mechanism without access to a wide range of PXA systems,
    otherwise they're risking breakage."
    
    Cc: stable@vger.kernel.org
    Cc: Russell King <linux@arm.linux.org.uk>
    Acked-by: Alexey Charkov <alchark@gmail.com>
    Signed-off-by: Roman Volkov <rvolkov@v1ros.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit 08e4b44852626f3549c8bd45308431d9c9e0ee6d
Author: Jisheng Zhang <jszhang@marvell.com>
Date:   Thu Nov 26 20:20:38 2015 +0800

    clockevents/drivers/arm_global_timer: Use writel_relaxed in gt_compare_set
    
    Use the relaxed version to improve performance. we measured time of
    4096 rounds of gt_compare_set() spent on Marvell BG2Q:
    
    before the patch: 3690648ns on average
    after the patch: 1083023ns on average
    
    improved by 70%!
    
    Signed-off-by: Jisheng Zhang <jszhang@marvell.com>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit 7b2a4306f9e7d64bb408a6df3bb419500578068a
Merge: 316dde2fe95b 03f136a2074b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Nov 3 14:13:41 2015 -0800

    Merge branch 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer updates from Thomas Gleixner:
     "The timer departement provides:
    
       - More y2038 work in the area of ntp and pps.
    
       - Optimization of posix cpu timers
    
       - New time related selftests
    
       - Some new clocksource drivers
    
       - The usual pile of fixes, cleanups and improvements"
    
    * 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (25 commits)
      timeconst: Update path in comment
      timers/x86/hpet: Type adjustments
      clocksource/drivers/armada-370-xp: Implement ARM delay timer
      clocksource/drivers/tango_xtal: Add new timer for Tango SoCs
      clocksource/drivers/imx: Allow timer irq affinity change
      clocksource/drivers/exynos_mct: Use container_of() instead of this_cpu_ptr()
      clocksource/drivers/h8300_*: Remove unneeded memset()s
      clocksource/drivers/sh_cmt: Remove unneeded memset() in sh_cmt_setup()
      clocksource/drivers/em_sti: Remove unneeded memset()s
      clocksource/drivers/mediatek: Use GPT as sched clock source
      clockevents/drivers/mtk: Fix spurious interrupt leading to crash
      posix_cpu_timer: Reduce unnecessary sighand lock contention
      posix_cpu_timer: Convert cputimer->running to bool
      posix_cpu_timer: Check thread timers only when there are active thread timers
      posix_cpu_timer: Optimize fastpath_timer_check()
      timers, kselftest: Add 'adjtick' test to validate adjtimex() tick adjustments
      timers: Use __fls in apply_slack()
      clocksource: Remove return statement from void functions
      net: sfc: avoid using timespec
      ntp/pps: use y2038 safe types in pps_event_time
      ...

commit fe326c5cc07cd265abad29c35c142cfae09889e4
Author: Magnus Damm <damm+renesas@opensource.se>
Date:   Wed Oct 28 10:43:23 2015 +0900

    clocksource/drivers/sh_mtu2: Fix multiple shutdown call issue
    
    On the r7s72100 Genmai board the MTU2 driver currently triggers a common
    clock framework WARN_ON(enable_count) when disabling the clock due to
    the MTU2 driver after recent callback rework may call ->set_state_shutdown()
    multiple times. A similar issue was spotted for the TMU driver and fixed in:
    452b132 clocksource/drivers/sh_tmu: Fix traceback spotted in -next
    
    On r7s72100 Genmai v4.3-rc7 built with shmobile_defconfig spits out the
    following during boot:
    
    sh_mtu2 fcff0000.timer: ch0: used for clock events
    ------------[ cut here ]------------
    WARNING: CPU: 0 PID: 1 at drivers/clk/clk.c:675 clk_core_disable+0x2c/0x6c()
    CPU: 0 PID: 1 Comm: swapper/0 Not tainted 4.3.0-rc7 #1
    Hardware name: Generic R7S72100 (Flattened Device Tree)
    Backtrace:
    [<c00133d4>] (dump_backtrace) from [<c0013570>] (show_stack+0x18/0x1c)
    [<c0013558>] (show_stack) from [<c01c7aac>] (dump_stack+0x74/0x90)
    [<c01c7a38>] (dump_stack) from [<c00272fc>] (warn_slowpath_common+0x88/0xb4)
    [<c0027274>] (warn_slowpath_common) from [<c0027400>] (warn_slowpath_null+0x24/0x2c)
    [<c00273dc>] (warn_slowpath_null) from [<c03a9320>] (clk_core_disable+0x2c/0x6c)
    [<c03a92f4>] (clk_core_disable) from [<c03aa0a0>] (clk_disable+0x40/0x4c)
    [<c03aa060>] (clk_disable) from [<c0395d2c>] (sh_mtu2_disable+0x24/0x50)
    [<c0395d08>] (sh_mtu2_disable) from [<c0395d6c>] (sh_mtu2_clock_event_shutdown+0x14/0x1c)
    [<c0395d58>] (sh_mtu2_clock_event_shutdown) from [<c007d7d0>] (clockevents_switch_state+0xc8/0x114)
    [<c007d708>] (clockevents_switch_state) from [<c007d834>] (clockevents_shutdown+0x18/0x28)
    [<c007d81c>] (clockevents_shutdown) from [<c007dd58>] (clockevents_exchange_device+0x70/0x78)
    [<c007dce8>] (clockevents_exchange_device) from [<c007e578>] (tick_check_new_device+0x88/0xe0)
    [<c007e4f0>] (tick_check_new_device) from [<c007daf0>] (clockevents_register_device+0xac/0x120)
    [<c007da44>] (clockevents_register_device) from [<c0395be8>] (sh_mtu2_probe+0x230/0x350)
    [<c03959b8>] (sh_mtu2_probe) from [<c028b6f0>] (platform_drv_probe+0x50/0x98)
    
    Reported-by: Chris Brandt <chris.brandt@renesas.com>
    Fixes: 19a9ffb ("clockevents/drivers/sh_mtu2: Migrate to new 'set-state' interface")
    Cc: Viresh Kumar <viresh.kumar@linaro.org>
    Cc: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Signed-off-by: Magnus Damm <damm+renesas@opensource.se>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Reviewed-by: Viresh Kumar <viresh.kumar@linaro.org>

commit 3bc2159faf897bab51e4f1144b525d21823832a6
Merge: b2c280bdd6ea cb0f2538039c
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Oct 20 12:37:45 2015 +0200

    Merge branch 'clockevents/4.4' of http://git.linaro.org/people/daniel.lezcano/linux into timers/core
    
    clockevent updates from Daniel Lezcano:
    
     - Remove unneeded memset in em_sti, sh_cmt and h8300 because there are already
       zeroed by a kzalloc (Alexey Klimov)
    
     - Optimize code by replacing this_cpu_ptr by container_of on the exynos_mct (Alexey
       Klimov)
    
     - Get immune from a spurious interrupt when enabling the mtk_timer (Daniel Lezcano)
    
     - Use the dynamic irq affinity to optimize wakeup and useless IPI timer on the imx
       timer (Lucas Stach)
    
     - Add new timer for Tango SoCs (Marc Gonzalez)
    
     - Implement the timer delay for armada-370-xp (Russell King)
    
     - Use GPT as clock source (Yingjoe Chen)

commit fc686d0037d782c994e338ecb01bfef8bbafff9f
Author: Daniel Lezcano <daniel.lezcano@linaro.org>
Date:   Mon Aug 24 15:14:30 2015 +0200

    clockevents/drivers/mtk: Fix spurious interrupt leading to crash
    
    After analysis done by Yingjoe Chen, the timer appears to have a pending
    interrupt when it is enabled.
    
    Fix this by acknowledging the pending interrupt when enabling the timer
    interrupt.
    
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Tested-by: Yingjoe Chen <yingjoe.chen@mediatek.com>

commit 1345df21ac542daa9d8613f89a3f0b5f32d636f8
Merge: c2ea72fd8691 eef7635a22f6
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Sep 17 10:55:25 2015 -0700

    Merge branch 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer fixes from Ingo Molnar:
     "A fix for an abs()/abs64() bug that caused too slow NTP convergence on
      32-bit kernels, plus a removal of an obsolete clockevents driver
      facility after all users got converted during the merge window"
    
    * 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      clockevents: Remove unused set_mode() callback
      time: Fix timekeeping_freqadjust()'s incorrect use of abs() instead of abs64()

commit eef7635a22f6b144206b5ca2f1398f637acffc4d
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Sep 11 09:34:26 2015 +0530

    clockevents: Remove unused set_mode() callback
    
    All users are migrated to the per-state callbacks, get rid of the
    unused interface and the core support code.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: linaro-kernel@lists.linaro.org
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/fd60de14cf6d125489c031207567bb255ad946f6.1441943991.git.viresh.kumar@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit d70e22d5bcf700a53881acad71a6c669be6eec93
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jul 16 16:56:19 2015 +0530

    hexagon/time: Migrate to new 'set-state' interface
    
    Migrate hexagon driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    We weren't doing anything in the ->set_mode() callback. So, this patch
    doesn't provide any set-state callbacks.
    
    Cc: linux-hexagon@vger.kernel.org
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Richard Kuo <rkuo@codeaurora.org>

commit 549a14c14b2f1868b81e5417a33b6d79e6da1d00
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Aug 18 13:59:28 2015 +0800

    nios2/time: Migrate to new 'set-state' interface
    
    Migrate nios2 driver to the new 'set-state' interface provided by clockevents core, the earlier 'set-mode' interface is marked obsolete now.
    
    This also enables us to implement callbacks for new states of clockevent devices, for example: ONESHOT_STOPPED.
    
    Cc: Ley Foon Tan <lftan@altera.com>
    Cc: Tobias Klauser <tklauser@distanz.ch>
    Cc: Herbert Xu <herbert@gondor.apana.org.au>
    Cc: Dmitry Torokhov <dtor@chromium.org>
    Cc: nios2-dev@lists.rocketboards.org
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Ley Foon Tan <lftan@altera.com>

commit fc6a6772f888ee8ab4c5428854f7f1d3abda13df
Author: Ezequiel Garcia <ezequiel.garcia@imgtec.com>
Date:   Mon Jul 27 15:00:15 2015 +0100

    CLOCKSOURCE: mips-gic: Update clockevent frequency on clock rate changes
    
    This commit introduces the clockevent frequency update, using
    a clock notifier. It will be used to support CPUFreq on platforms
    using MIPS GIC based clockevents.
    
    Signed-off-by: Ezequiel Garcia <ezequiel.garcia@imgtec.com>
    Acked-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: linux-kernel@vger.kernel.org
    Cc: linux-mips@linux-mips.org
    Cc: devicetree@vger.kernel.org
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Andrew Bresticker <abrestic@chromium.org>
    Cc: James Hartley <James.Hartley@imgtec.com>
    Cc: Govindraj Raja <Govindraj.Raja@imgtec.com>
    Cc: Damien Horsley <Damien.Horsley@imgtec.com>
    Cc: James Hogan <James.Hogan@imgtec.com>
    Cc: Ezequiel Garcia <ezequiel@vanguardiasur.com.ar>
    Patchwork: https://patchwork.linux-mips.org/patch/10782/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

commit 397d08b006fc8bbb087615214400b86b64f8fe50
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon Jul 6 16:42:05 2015 +0530

    MIPS: sni: Migrate to new 'set-state' interface
    
    Migrate sni driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: linux-mips@linux-mips.org
    Cc: linaro-kernel@lists.linaro.org
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Patchwork: https://patchwork.linux-mips.org/patch/10612/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

commit 0c16240ab07ff8a0e611f676f86a92a4b513d15d
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon Jul 6 16:42:04 2015 +0530

    MIPS: IP27: Migrate to new 'set-state' interface
    
    Migrate sgidriver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    We weren't doing anything in the ->set_mode() callback. So, this patch
    doesn't provide any set-state callbacks.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Cc: Deng-Cheng Zhu <dengcheng.zhu@imgtec.com>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: linux-mips@linux-mips.org
    Cc: linaro-kernel@lists.linaro.org
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Patchwork: https://patchwork.linux-mips.org/patch/10611/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

commit 59113d93c2b483485cf62f0b057f896e420048c2
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon Jul 6 16:42:03 2015 +0530

    MIPS: rt3352: Migrate to new 'set-state' interface
    
    Migrate ralink driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: linux-mips@linux-mips.org
    Cc: linaro-kernel@lists.linaro.org
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Patchwork: https://patchwork.linux-mips.org/patch/10610/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

commit 1fed884d5f3d615d56d3b3c07d5ef95f7b49b5f5
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon Jul 6 16:42:02 2015 +0530

    MIPS: loongsoon32: Migrate to new 'set-state' interface
    
    Migrate loongsoon32 driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Cc: Kelvin Cheung <keguang.zhang@gmail.com>
    Cc: Huacai Chen <chenhc@lemote.com>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: linux-mips@linux-mips.org
    Cc: linaro-kernel@lists.linaro.org
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Patchwork: https://patchwork.linux-mips.org/patch/10609/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

commit e3280b2a54b38406563d6422685a20172382d365
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon Jul 6 16:42:01 2015 +0530

    MIPS: loongson64/timer: Migrate to new 'set-state' interface
    
    Migrate loongson driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    [ralf@linux-mips.org: Folded in Viresh's followon fix.]
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Cc: Huacai Chen <chenhc@lemote.com>
    Cc: Michael Opdenacker <michael.opdenacker@free-electrons.com>
    Cc: Hongliang Tao <taohl@lemote.com>
    Cc: Valentin Rothberg <valentinrothberg@gmail.com>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: linux-mips@linux-mips.org
    Cc: linaro-kernel@lists.linaro.org
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Viresh Kumar <viresh.kumar@linaro.org>
    Patchwork: https://patchwork.linux-mips.org/patch/10608/
    Patchwork: https://patchwork.linux-mips.org/patch/10883/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

commit d199da550da30e0946a7554f8a93ef75f66f8005
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon Jul 6 16:42:00 2015 +0530

    MIPS: cevt-txx9: Migrate to new 'set-state' interface
    
    Migrate cevt-txx9 driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Cc: Deng-Cheng Zhu <dengcheng.zhu@imgtec.com>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: linux-mips@linux-mips.org
    Cc: linaro-kernel@lists.linaro.org
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Viresh Kumar <viresh.kumar@linaro.org>
    Patchwork: https://patchwork.linux-mips.org/patch/10607/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

commit 57e148cabbb2f1e6770d6a506088486142b26b97
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon Jul 6 16:41:59 2015 +0530

    MIPS: cevt-sb1250: Migrate to new 'set-state' interface
    
    Migrate cevt-rsb1250 driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: linux-mips@linux-mips.org
    Cc: linaro-kernel@lists.linaro.org
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Patchwork: https://patchwork.linux-mips.org/patch/10606/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

commit 877c61dc63c2eaa98515abfd89596f293b543342
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon Jul 6 16:41:58 2015 +0530

    MIPS: cevt-r4k: Migrate to new 'set-state' interface
    
    Migrate cevt-4k driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    We weren't doing anything in the ->set_mode() callback. So, this patch
    doesn't provide any set-state callbacks.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Cc: James Hogan <james.hogan@imgtec.com>
    Cc: Andrew Bresticker <abrestic@chromium.org>
    Cc: Qais Yousef <qais.yousef@imgtec.com>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Leonid Yegoshin <Leonid.Yegoshin@imgtec.com>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: linux-mips@linux-mips.org
    Cc: linaro-kernel@lists.linaro.org
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Patchwork: https://patchwork.linux-mips.org/patch/10605/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

commit c88f2fb4d81df3dbafd79d51b2cacefb356d466c
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon Jul 6 16:41:57 2015 +0530

    MIPS: cevt-gt641xx: Migrate to new 'set-state' interface
    
    Migrate cevt-gt641xx driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: linux-mips@linux-mips.org
    Cc: linaro-kernel@lists.linaro.org
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Patchwork: https://patchwork.linux-mips.org/patch/10604/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

commit 9f95618f9fe5fc902a3d8fecd10c98e482fab6c5
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon Jul 6 16:41:56 2015 +0530

    MIPS: cevt-ds1287: Migrate to new 'set-state' interface
    
    Migrate cevt-ds1287 driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: linux-mips@linux-mips.org
    Cc: linaro-kernel@lists.linaro.org
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Patchwork: https://patchwork.linux-mips.org/patch/10603/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

commit 1edf907a09e1cad9032411d84679b637ab696593
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon Jul 6 16:41:55 2015 +0530

    MIPS: cevt-bcm1480: Migrate to new 'set-state' interface
    
    Migrate cevt-bcm1480 driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    Read operation on R_SCD_TIMER_CFG and R_SCD_TIMER_INIT registers isn't
    performed now for many modes as there returned values aren't used.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: linux-mips@linux-mips.org
    Cc: linaro-kernel@lists.linaro.org
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Patchwork: https://patchwork.linux-mips.org/patch/10602/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

commit c87cbe06916868e1b14a0681e874b96cfab61083
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon Jul 6 16:41:54 2015 +0530

    MIPS: jz4740: Migrate to new 'set-state' interface
    
    Migrate jz4740 driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Cc: Paul Burton <paul.burton@imgtec.com>
    Cc: Deng-Cheng Zhu <dengcheng.zhu@imgtec.com>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: linux-mips@linux-mips.org
    Cc: linaro-kernel@lists.linaro.org
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Patchwork: https://patchwork.linux-mips.org/patch/10601/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

commit 20a7835f8f3666eaaec599f8f9f1628c4e7e88dd
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon Jul 6 16:41:53 2015 +0530

    MIPS: Jazz: Migrate to new 'set-state' interface
    
    Migrate jazz driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    We weren't doing anything in the ->set_mode() callback. So, this patch
    doesn't provide any set-state callbacks.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: linux-mips@linux-mips.org
    Cc: linaro-kernel@lists.linaro.org
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Patchwork: https://patchwork.linux-mips.org/patch/10600/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

commit 3dcd7779ac4dada4a2c97e19a9ac3593891d89a0
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon Jul 6 16:41:52 2015 +0530

    MIPS: Alchemy: Migrate to new 'set-state' interface
    
    Migrate alchemy driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    We weren't doing anything in the ->set_mode() callback. So, this patch
    doesn't provide any set-state callbacks.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Cc: Manuel Lauss <manuel.lauss@gmail.com>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: linux-mips@linux-mips.org
    Cc: linaro-kernel@lists.linaro.org
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Patchwork: https://patchwork.linux-mips.org/patch/10599/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

commit e713c80a4e49d4bed5324d24755e42bf01c87556
Merge: 43af9872f52a c8b5db7de66b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Sep 1 15:42:28 2015 -0700

    Merge branch 'x86-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull x86 clockevent update from Thomas Gleixner:
     "A single commit, which converts HPET clockevents driver to the new
      callbacks"
    
    * 'x86-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      x86/hpet: Migrate to new set_state interface

commit 361f7d175734a8e21bcd0585eca9be195c12c5c5
Merge: 25525bea46e7 e971aa2cbac0
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Sep 1 10:33:31 2015 -0700

    Merge branch 'x86-platform-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull x86 core platform updates from Ingo Molnar:
     "The main changes are:
    
       - Intel Atom platform updates.  (Andy Shevchenko)
    
       - modularity fixlets.  (Paul Gortmaker)
    
       - x86 platform clockevents driver updates for lguest, uv and Xen.
         (Viresh Kumar)
    
       - Microsoft Hyper-V TSC fixlet.  (Vitaly Kuznetsov)"
    
    * 'x86-platform-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      x86/platform: Make atom/pmc_atom.c explicitly non-modular
      x86/hyperv: Mark the Hyper-V TSC as unstable
      x86/xen/time: Migrate to new set-state interface
      x86/uv/time: Migrate to new set-state interface
      x86/lguest/timer: Migrate to new set-state interface
      x86/pci/intel_mid_pci: Use proper constants for irq polarity
      x86/pci/intel_mid_pci: Make intel_mid_pci_ops static
      x86/pci/intel_mid_pci: Propagate actual return code
      x86/pci/intel_mid_pci: Work around for IRQ0 assignment
      x86/platform/iosf_mbi: Add Intel Tangier PCI id
      x86/platform/iosf_mbi: Source cleanup
      x86/platform/iosf_mbi: Remove NULL pointer checks for pci_dev_put()
      x86/platform/iosf_mbi: Check return value of debugfs_create properly
      x86/platform/iosf_mbi: Move to dedicated folder
      x86/platform/intel/pmc_atom: Move the PMC-Atom code to arch/x86/platform/atom
      x86/platform/intel/pmc_atom: Add Cherrytrail PMC interface
      x86/platform/intel/pmc_atom: Supply register mappings via PMC object
      x86/platform/intel/pmc_atom: Print index of device in loop
      x86/platform/intel/pmc_atom: Export accessors to PMC registers

commit 5bbc08fb0f1457ceef388739b48c72675246639c
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jul 16 16:56:20 2015 +0530

    m68k/coldfire/pit: Migrate to new 'set-state' interface
    
    Migrate m68k driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    We weren't doing anything in ->set_mode(RESUME) and so tick_resume()
    isn't implemented.
    
    Cc: Greg Ungerer <gerg@uclinux.org>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: linux-m68k@lists.linux-m68k.org
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Ungerer <gerg@uclinux.org>

commit 3670901f73e889538a1b8283e8d6eb9962aab410
Merge: b25c6cee55c7 54d46b7fbcbd
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Aug 14 11:06:43 2015 -0700

    Merge branch 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer fix from Ingo Molnar:
     "A single clocksource driver suspend/resume fix"
    
    * 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      clockevents/drivers/sh_cmt: Only perform clocksource suspend/resume if enabled

commit a54868b460b65bd93a5324a7fc35dfd556fe576c
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Aug 6 14:41:13 2015 +0530

    ARM: ep93xx/timer: Migrate to new 'set-state' interface
    
    Migrate EP93xx driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Olof Johansson <olof@lixom.net>

commit 2b5cf544934fe15f7b2f8bd26696284606f9e7d3
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jul 16 16:56:18 2015 +0530

    cris/time: Migrate to new 'set-state' interface
    
    Migrate cris driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    Cc: Mikael Starvik <starvik@axis.com>
    Cc: Jesper Nilsson <jesper.nilsson@axis.com>
    Cc: Rabin Vincent <rabin@rab.in>
    Cc: Guenter Roeck <linux@roeck-us.net>
    Cc: linux-cris-kernel@axis.com
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit ecbebcb868bed598354d3b6d94cfeb10e440e4ca
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jul 16 16:56:35 2015 +0530

    kernel: broadcast-hrtimer: Migrate to new 'set-state' interface
    
    Migrate broadcast-hrtimer driver to the new 'set-state' interface
    provided by clockevents core, the earlier 'set-mode' interface is marked
    obsolete now.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit 8e40fc4b782dc582fbf77ee3ff1d735a1d788a76
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jul 16 16:56:33 2015 +0530

    xtensa/time: Migrate to new 'set-state' interface
    
    Migrate xtensa driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    Cc: Chris Zankel <chris@zankel.net>
    Cc: Max Filippov <jcmvbkbc@gmail.com>
    Cc: linux-xtensa@linux-xtensa.org
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit 3078c8df2c03ebad334e1efe7e0867d8b0cd2764
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jul 16 16:56:32 2015 +0530

    unicore/time: Migrate to new 'set-state' interface
    
    Migrate unicore driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    We weren't doing anything for PERIODIC or RESUME modes and so their
    callbacks aren't implemented.
    
    Cc: Guan Xuetao <gxt@mprc.pku.edu.cn>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit 71b5280b79359ca3c6c21d46b6b14a3ae93d8330
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jul 16 16:56:31 2015 +0530

    um/time: Migrate to new 'set-state' interface
    
    Migrate um driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    Cc: Jeff Dike <jdike@addtoit.com>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: user-mode-linux-devel@lists.sourceforge.net
    Cc: user-mode-linux-user@lists.sourceforge.net
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit ff4aea45c7f9c73889f08976ad65b31dbc35047e
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jul 16 16:56:29 2015 +0530

    sparc/time: Migrate to new 'set-state' interface
    
    Migrate sparc drivers to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    We weren't doing anything which switching to few clockevent modes and so
    their callbacks aren't implemented.
    
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: sparclinux@vger.kernel.org
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit d5ed65d83c27aee1c07bf4879cce539055d0c27f
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jul 16 16:56:28 2015 +0530

    sh/localtimer: Migrate to new 'set-state' interface
    
    Migrate sh driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    We weren't doing anything in the ->set_mode() callback. So, this patch
    doesn't provide any set-state callbacks.
    
    Cc: linux-sh@vger.kernel.org
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit 07d93ebdbffac61201d2f7fb81d08872df402f91
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jul 16 16:56:27 2015 +0530

    score/time: Migrate to new 'set-state' interface
    
    Migrate score driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    We weren't doing anything in ONESHOT/SHUTDOWN/RESUME modes and so
    callbacks for them aren't implemented.
    
    Cc: Chen Liqin <liqin.linux@gmail.com>
    Cc: Lennox Wu <lennox.wu@gmail.com>
    Cc: Michael Opdenacker <michael.opdenacker@free-electrons.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit 07aeed3f9ba2a846d07fa870c26c3634e849d4e4
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jul 16 16:56:26 2015 +0530

    s390/time: Migrate to new 'set-state' interface
    
    Migrate s390 driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    We weren't doing anything in the ->set_mode() callback. So, this patch
    doesn't provide any set-state callbacks.
    
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: linux390@de.ibm.com
    Cc: linux-s390@vger.kernel.org
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit 37a13e78e017c31fbb98a148b54c2552dc08d788
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jul 16 16:56:25 2015 +0530

    powerpc/time: Migrate to new 'set-state' interface
    
    Migrate powerpc driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    We weren't doing anything in ->set_mode(ONSHOT) and so
    set_state_oneshot() isn't implemented.
    
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: linuxppc-dev@lists.ozlabs.org
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit 00c5a0acd11ec157585d290469b6c82ddd816663
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jul 16 16:56:24 2015 +0530

    openrisc/time: Migrate to new 'set-state' interface
    
    Migrate openrisc driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    We weren't doing anything in the ->set_mode() callback. So, this patch
    doesn't provide any set-state callbacks.
    
    Cc: Jonas Bonn <jonas@southpole.se>
    Cc: linux@lists.openrisc.net
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit 032facef42a1a15be4a038e5e45819b941c2a6a8
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jul 16 16:56:22 2015 +0530

    mn10300/cevt-mn10300: Migrate to new 'set-state' interface
    
    Migrate mn10300 driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    We weren't doing anything in the ->set_mode() callback. So, this patch
    doesn't provide any set-state callbacks.
    
    Cc: David Howells <dhowells@redhat.com>
    Cc: Koichi Yasutake <yasutake.koichi@jp.panasonic.com>
    Cc: linux-am33-list@redhat.com
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit 9797529d8981b2d2dce116ba7cf0641e13a5774b
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jul 16 16:56:21 2015 +0530

    microblaze/timer: Migrate to new 'set-state' interface
    
    Migrate microblaze driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    We weren't doing anything in ->set_mode(RESUME or ONESHOT) and so
    tick_resume() set_state_oneshot() aren't implemented.
    
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit 677e6fe06378829a4263f65ee32c4b7242410636
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jul 16 16:56:17 2015 +0530

    c6x/timer64: Migrate to new 'set-state' interface
    
    Migrate c6x driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    We weren't doing anything in ->set_mode(RESUME) and so tick_resume()
    isn't implemented.
    
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Aurelien Jacquiot <a-jacquiot@ti.com>
    Cc: linux-c6x-dev@linux-c6x.org
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit 067f96218c60266d606258e246df269dfd34d1e6
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jul 16 16:56:16 2015 +0530

    blackfin/time-ts: Migrate to new 'set-state' interface
    
    Migrate blackfin driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    We weren't doing anything in ->set_mode(RESUME) and so tick_resume()
    isn't implemented.
    
    Cc: Steven Miao <realmz6@gmail.com>
    Cc: adi-buildroot-devel@lists.sourceforge.net
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit 6ec81932988b231e3038f7b73d58b2f9ce1e7ab0
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jul 16 16:56:13 2015 +0530

    alpha/time: Migrate to new 'set-state' interface
    
    Migrate alpha driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    rtc clockevent device wasn't doing anything in set-mode and so its
    set-state callbacks aren't implemented.
    
    Cc: Richard Henderson <rth@twiddle.net>
    Cc: Ivan Kokshaysky <ink@jurassic.park.msu.ru>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Christoph Lameter <cl@linux.com>
    Cc: linux-alpha@vger.kernel.org
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit fc2b2f5df6d8dbf78c958a34628a3880150d6c9e
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon Jul 27 15:02:00 2015 +0530

    clockevents/drivers/h8300_timer8: Migrate to new 'set-state' interface
    
    Migrate h8300_timer8 driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit 452b13248fe8499b2d9a487999d3610095aecca5
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Jul 21 08:01:14 2015 +0530

    clocksource/drivers/sh_tmu: Fix traceback spotted in -next
    
    Traceback in -next due to commit 'clockevents/drivers/sh_tmu: Migrate to new
    'set-state' interface'.
    
    Commit ("clockevents/drivers/sh_tmu: Migrate to new 'set-state' interface")
    in -next causes the following traceback. This is seen with qemu runs for the sh
    target.
    
    ------------[ cut here ]------------
    WARNING: at drivers/clocksource/sh_tmu.c:202
    Modules linked in:
    
    CPU: 0 PID: 0 Comm: swapper Not tainted 4.2.0-rc3-next-20150720 #1
    task: 8c411ed8 ti: 8c40e000 task.ti: 8c40e000
    PC is at sh_tmu_disable+0x40/0x60
    PR is at sh_tmu_clock_event_shutdown+0x8/0x20
    PC  : 8c271220 SP  : 8c40ff10 SR  : 400081f1 TEA : 00000000
    R0  : 8c271240 R1  : 8fc08cfc R2  : 00000000 R3  : 3fffffff
    R4  : 8fc08c00 R5  : 00000001 R6  : 00000002 R7  : ffffffff
    R8  : 00000001 R9  : 8fc08c20 R10 : 00000000 R11 : 00000000
    R12 : 8c012820 R13 : 00000000 R14 : 00000000
    MACH: 3b9ac9ff MACL: 80000000 GBR : 00000000 PR  : 8c271248
    
    Call trace:
     [<8c065836>] clockevents_switch_state+0x16/0x60
     [<8c06588c>] clockevents_shutdown+0xc/0x40
     [<8c066330>] tick_check_new_device+0x90/0xc0
     [<8c065556>] clockevents_register_device+0x56/0x120
     [<8c0662a0>] tick_check_new_device+0x0/0xc0
     [<8c27167a>] sh_tmu_probe+0x29a/0x4e0
     [<8c18a994>] kasprintf+0x14/0x20
     [<8c442782>] early_platform_driver_probe+0x20e/0x2bc
     [<8c1fade0>] platform_match+0x0/0x100
     [<8c33babc>] printk+0x0/0x24
     [<8c434892>] start_kernel+0x32e/0x574
     [<8c33babc>] printk+0x0/0x24
     [<8c17d320>] strlen+0x0/0x58
     [<8c43430c>] unknown_bootoption+0x0/0x1e0
     [<8c011024>] _stext+0x24/0x30
    
    ---[ end trace cb88537fdc8fa200 ]---
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Tested-by: Geert Uytterhoeven <geert+renesas@glider.be>

commit 005e56272b28193540dcd1dab3dadb3da8375eaf
Author: Daniel Lezcano <daniel.lezcano@linaro.org>
Date:   Tue Aug 4 11:59:42 2015 +0200

    clockevents/drivers/timer-atmel-pit: Fix typo in structure initialization
    
    Reported-by: Peter Mamonov <pmamonov@gmail.com>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit daea72831d3a18c561f028258ca5fb65ac3c8947
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon Jul 6 15:39:19 2015 +0530

    clockevents/drivers/timer-sp804: Migrate to new 'set-state' interface
    
    Migrate timer-sp driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    There are few more changes worth noticing:
    
    - The clockevent device was disabled by writing: 'TIMER_CTRL_32BIT |
      TIMER_CTRL_IE' to ctrl register earlier. i.e. by un-setting the
      TIMER_CTRL_ENABLE bit. Its done by writing zero now and should have
      the same effect.
    
    - For shutdown and resume we were writing the same value twice to the
      register (to disable the timer), which is fixed now.
    
    - Switching to oneshot mode was divided into two parts earlier:
      - Firstly set_mode() was writing:
        'TIMER_CTRL_32BIT | TIMER_CTRL_IE | TIMER_CTRL_ONESHOT'
        to ctrl register (device not enabled yet)
      - Then sp804_set_next_event() was enabling the device by writing
        'readl(ctrl) | TIMER_CTRL_ENABLE' to the ctrl register. This was
        unnecessarily complicated.
      - Change this to: Stop device on set_state_oneshot and configure it in
        sp804_set_next_event().
    
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: Russell King <rmk+kernel@arm.linux.org.uk>
    Cc: Sudeep Holla <sudeep.holla@arm.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Olof Johansson <olof@lixom.net>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit 26b91f043abda63dd240374f0eac05e7283a509c
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon Jul 6 15:39:18 2015 +0530

    clockevents/drivers/timer-imx-gpt: Migrate to new 'set-state' interface
    
    Migrate timer-imx-gpt driver to the new 'set-state' interface provided
    by clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    Also drop:
    - 'imx_timer.cem': It was caching the last state of the clockevent
      device. The same behavior can be achieved by using clockevents state
      helpers. These helpers are only required for oneshot mode as
      shutdown/resume wouldn't be done twice by the core.
    
    - 'clock_event_mode_label': CLOCK_EVT_MODE_* shouldn't be used anymore
      by drivers. The prints are modified to print the set-state functions
      name now to debug the driver.
    
    Cc: Shawn Guo <shawn.guo@linaro.org>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit 8c436f84800c570ecde517dcd8709258bb34e498
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Tue Jul 14 14:00:47 2015 +0200

    clockevents/drivers/sh_cmt: Remove obsolete sh-cmt-48 platform_device_id entry
    
    Since the removal of the r8a7740 legacy SoC code in commit
    44d88c754e57a6d9 ("ARM: shmobile: Remove legacy SoC code for R-Mobile
    A1"), all former users of the "sh-cmt-48-gen2" platform device name are
    only supported in generic DT-only ARM multi-platform builds.  The driver
    doesn't need to match platform devices by name anymore, hence remove the
    corresponding platform_device_id entry.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Acked-by: Simon Horman <horms+renesas@verge.net.au>

commit 8b5f0010fe0d666bb8dfc74b881f2401324a0e89
Author: Jisheng Zhang <jszhang@marvell.com>
Date:   Sat Jul 4 13:06:43 2015 +0800

    clockevents/drivers/dw_apb_timer: Add dynamic irq flag to the timer
    
    Commit d2348fb6fdc6 ("tick: Dynamically set broadcast irq affinity")
    adds one excellent feature CLOCK_EVT_FEAT_DYNIRQ to let the core set the
    interrupt affinity of the broadcast interrupt to the cpu which has the
    earliest expiry time. This patch adds CLOCK_EVT_FEAT_DYNIRQ flag to
    avoid unnecessary wakeups and IPIs when the dw_apb_timer is used as
    broadcast timer.
    
    A simple test:
    ~ # rm /tmp/test.sh
    ~ # cat > /tmp/test.sh
    cat /proc/interrupts
    for i in `seq 10` ; do sleep $i; done
    cat /proc/interrupts
    ~ # chmod +x /tmp/test.sh
    ~ # taskset 0x2 /tmp/test.sh
    
    without the patch:
    
               CPU0       CPU1
     27:        115         36       GIC  27  arch_timer
     45:         62          0       GIC  45  mmc0
    160:         88          0  interrupt-controller   8  timer
    227:          0          0  interrupt-controller   4  f7e81400.i2c
    228:          0          0  interrupt-controller   5  f7e81800.i2c
    229:          0          0  interrupt-controller   7  dw_spi65535
    230:          0          0  interrupt-controller  21  f7e84000.i2c
    231:          0          0  interrupt-controller  20  f7e84800.i2c
    265:        445          0  interrupt-controller   8  serial
    IPI0:          0          0  CPU wakeup interrupts
    IPI1:          0         11  Timer broadcast interrupts
    IPI2:         56        104  Rescheduling interrupts
    IPI3:          0          0  Function call interrupts
    IPI4:          0          4  Single function call interrupts
    IPI5:          0          0  CPU stop interrupts
    IPI6:         25         27  IRQ work interrupts
    IPI7:          0          0  completion interrupts
    IPI8:          0          0  CPU backtrace
    Err:          0
               CPU0       CPU1
     27:        115         38       GIC  27  arch_timer
     45:         62          0       GIC  45  mmc0
    160:        160          0  interrupt-controller   8  timer
    227:          0          0  interrupt-controller   4  f7e81400.i2c
    228:          0          0  interrupt-controller   5  f7e81800.i2c
    229:          0          0  interrupt-controller   7  dw_spi65535
    230:          0          0  interrupt-controller  21  f7e84000.i2c
    231:          0          0  interrupt-controller  20  f7e84800.i2c
    265:        514          0  interrupt-controller   8  serial
    IPI0:          0          0  CPU wakeup interrupts
    IPI1:          0         83  Timer broadcast interrupts
    IPI2:         56        104  Rescheduling interrupts
    IPI3:          0          0  Function call interrupts
    IPI4:          0          4  Single function call interrupts
    IPI5:          0          0  CPU stop interrupts
    IPI6:         25         46  IRQ work interrupts
    IPI7:          0          0  completion interrupts
    IPI8:          0          0  CPU backtrace
    Err:          0
    
    cpu0 get 160-88=72 timer interrupts, CPU1 got 83-11=72 broadcast timer
    IPIs
    So, overall system got 72+72=144 wake ups and 72 broadcast timer IPIs
    
    With the patch:
               CPU0       CPU1
     27:        107         37       GIC  27  arch_timer
     45:         62          0       GIC  45  mmc0
    160:         66          7  interrupt-controller   8  timer
    227:          0          0  interrupt-controller   4  f7e81400.i2c
    228:          0          0  interrupt-controller   5  f7e81800.i2c
    229:          0          0  interrupt-controller   7  dw_spi65535
    230:          0          0  interrupt-controller  21  f7e84000.i2c
    231:          0          0  interrupt-controller  20  f7e84800.i2c
    265:        311          0  interrupt-controller   8  serial
    IPI0:          0          0  CPU wakeup interrupts
    IPI1:          2          4  Timer broadcast interrupts
    IPI2:         58        100  Rescheduling interrupts
    IPI3:          0          0  Function call interrupts
    IPI4:          0          4  Single function call interrupts
    IPI5:          0          0  CPU stop interrupts
    IPI6:         21         24  IRQ work interrupts
    IPI7:          0          0  completion interrupts
    IPI8:          0          0  CPU backtrace
    Err:          0
               CPU0       CPU1
     27:        107         39       GIC  27  arch_timer
     45:         62          0       GIC  45  mmc0
    160:         69         75  interrupt-controller   8  timer
    227:          0          0  interrupt-controller   4  f7e81400.i2c
    228:          0          0  interrupt-controller   5  f7e81800.i2c
    229:          0          0  interrupt-controller   7  dw_spi65535
    230:          0          0  interrupt-controller  21  f7e84000.i2c
    231:          0          0  interrupt-controller  20  f7e84800.i2c
    265:        380          0  interrupt-controller   8  serial
    IPI0:          0          0  CPU wakeup interrupts
    IPI1:          3          6  Timer broadcast interrupts
    IPI2:         60        100  Rescheduling interrupts
    IPI3:          0          0  Function call interrupts
    IPI4:          0          4  Single function call interrupts
    IPI5:          0          0  CPU stop interrupts
    IPI6:         21         45  IRQ work interrupts
    IPI7:          0          0  completion interrupts
    IPI8:          0          0  CPU backtrace
    Err:          0
    
    cpu0 got 69-66=3, cpu1 got 75-7=68 timer interrupts. cpu0 got 3-2=1
    broadcast timer IPIs, cpu1 got 6-4=2 broadcast timer IPIs.
    So, overall system got 3+68+1+2=74 wakeups and 1+2=3 broadcast timer
    IPIs
    
    This patch removes 50% wakeups and almost 100% broadcast timer IPIs!
    
    Signed-off-by: Jisheng Zhang <jszhang@marvell.com>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit 79e436d3a7d0510dfe6be3973efd78f6ccfe1492
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jun 18 16:24:20 2015 +0530

    clockevents/drivers/exynos_mct: Migrate to new 'set-state' interface
    
    Migrate exynos_mct driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    Cc: Kukjin Kim <kgene.kim@samsung.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit cf4541c101ea497f68639cc94a2639a05cc3710f
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jun 18 16:24:38 2015 +0530

    clockevents/drivers/tcb_clksrc: Migrate to new 'set-state' interface
    
    Migrate tcb_clksrc driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    Cc: Nicolas Ferre <nicolas.ferre@atmel.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit f0753793d33931bffbc7eee3289bf4d289728ef6
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jun 18 16:24:55 2015 +0530

    clockevents/drivers/zevio: Migrate to new 'set-state' interface
    
    Migrate zevio driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    Cc: Daniel Tang <dt.tangr@gmail.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit 214bc755b67029821106acc0b73abdc9b4ca6968
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jun 18 16:24:54 2015 +0530

    clockevents/drivers/vt8500: Migrate to new 'set-state' interface
    
    Migrate vt8500 driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    Cc: Tony Prisk <linux@prisktech.co.nz>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit 9552a6af8c807ab547c053399b40bd05781fa0a8
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jun 18 16:24:53 2015 +0530

    clockevents/drivers/vf_pit: Migrate to new 'set-state' interface
    
    Migrate vf_pit driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    Cc: Jingchang Lu <b35083@freescale.com>
    Cc: Stefan Agner <stefan@agner.ch>
    Cc: Shawn Guo <shawn.guo@linaro.org>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Acked-by: Stefan Agner <stefan@agner.ch>

commit 8ff8fc13bdd4f1474720669042fccfbf304638f1
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jun 18 16:24:52 2015 +0530

    clockevents/drivers/u300: Migrate to new 'set-state' interface
    
    Migrate u300 driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>

commit 7486f5ad27f6833397d55972878e7d73e84bede2
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jun 18 16:24:51 2015 +0530

    clockevents/drivers/sun5i: Migrate to new 'set-state' interface
    
    Migrate sun5i driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    Cc: Maxime Ripard <maxime.ripard@free-electrons.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Acked-by: Maxime Ripard <maxime.ripard@free-electrons.com>

commit 8e8af4cd3b4227d1bc64db0f0a4081095eb519b2
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jun 18 16:24:50 2015 +0530

    clockevents/drivers/stm32: Migrate to new 'set-state' interface
    
    Migrate stm32 driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    Cc: Maxime Coquelin <mcoquelin.stm32@gmail.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Tested-by: Maxime Coquelin <mcoquelin.stm32@gmail.com>
    Acked-by: Maxime Coquelin <mcoquelin.stm32@gmail.com>

commit 53cba064443c1f36a55aa9dbc38f1d0d2aac96a4
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jun 18 16:24:49 2015 +0530

    clockevents/drivers/prima2: Migrate to new 'set-state' interface
    
    Migrate prima2 driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    Cc: Barry Song <baohua@kernel.org>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit 634eb0ec8c210ca3ea81b5b9493b4a39999bbf4a
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jun 18 16:24:48 2015 +0530

    clockevents/drivers/keystone: Migrate to new 'set-state' interface
    
    Migrate keystone driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    Also pass the mode-mask to keystone_timer_config() instead of the mode
    as mode macro's aren't valid anymore.
    
    Cc: Santosh Shilimkar <ssantosh@kernel.org>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit f710bdeecffe9ce3ad8bdc358c6109d3848f6352
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jun 18 16:24:47 2015 +0530

    clockevents/drivers/integrator: Migrate to new 'set-state' interface
    
    Migrate integrator driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    For oneshot mode the clkevt device was first getting disabled by
    clearing TIMER_CTRL_ENABLE bits in TIMER_CTRL register, followed by
    clearing TIMER_CTRL_PERIODIC bit. Both these are done with a single
    write operation now.
    
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>

commit e0d1ca332c1e91febd0de0ef69a45957cdc39fd8
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jun 18 16:24:46 2015 +0530

    clockevents/drivers/digicolor: Migrate to new 'set-state' interface
    
    Migrate digicolor driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    Cc: Baruch Siach <baruch@tkos.co.il>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Acked-by: Baruch Siach <baruch@tkos.co.il>
    Tested-by: Baruch Siach <baruch@tkos.co.il>

commit 8ab282305f88c693275925330a0f93b16cab9c37
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jun 18 16:24:45 2015 +0530

    clockevents/drivers/atmel-st: Migrate to new 'set-state' interface
    
    Migrate atmel-st driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    Cc: Nicolas Ferre <nicolas.ferre@atmel.com>
    Cc: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Cc: Jean-Christophe Plagniol-Villard <plagnioj@jcrosoft.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Acked-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Tested-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>

commit 85250fb89be3792c8a6793a594e30307c4e39214
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jun 18 16:24:44 2015 +0530

    clockevents/drivers/atmel: Migrate to new 'set-state' interface
    
    Migrate atmel driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    Cc: Nicolas Ferre <nicolas.ferre@atmel.com>
    Cc: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Cc: Jean-Christophe Plagniol-Villard <plagnioj@jcrosoft.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Acked-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>

commit 1e729d378e75063bf3fa91c62ea372fb73012b24
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jun 18 16:24:43 2015 +0530

    clockevents/drivers/atlas7: Migrate to new 'set-state' interface
    
    Migrate atlas7 driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    Cc: Barry Song <baohua@kernel.org>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit 5dd2482c8e7d8108e8d5d59a25f7b7a16d1ea64e
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jun 18 16:24:42 2015 +0530

    clockevents/drivers/orion: Migrate to new 'set-state' interface
    
    Migrate orion driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Andrew Lunn <andrew@lunn.ch>
    Cc: Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
    Cc: Gregory Clement <gregory.clement@free-electrons.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit 20bf54f1172931df634d8f8cf05ba2c2d371dc10
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jun 18 16:24:41 2015 +0530

    clockevents/drivers/efm32: Migrate to new 'set-state' interface
    
    Migrate efm32 driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    There is nothing to be done for resume state and so isn't implemented.
    
    Cc: Uwe Kleine-Knig <kernel@pengutronix.de>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit d96f4412bcbd6698b6241146f01021dabdf052f3
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jun 18 16:24:40 2015 +0530

    clockevents/drivers/time-armada-370-xp: Migrate to new 'set-state' interface
    
    Migrate time-armada-370-xp driver to the new 'set-state' interface
    provided by clockevents core, the earlier 'set-mode' interface is marked
    obsolete now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Andrew Lunn <andrew@lunn.ch>
    Cc: Gregory Clement <gregory.clement@free-electrons.com>
    Cc: Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit 4134d29bfc4703d4000fc3a49ea4aeeae494d85a
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Jul 3 14:24:35 2015 +0530

    clockevents/drivers/tegra20: Migrate to new 'set-state' interface
    
    Migrate tegra20 driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    Cc: Thierry Reding <treding@nvidia.com>
    Cc: Stephen Warren <swarren@wwwdotorg.org>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit 6de6c977bdf61b1ca6f321aba468275c32952d79
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jun 18 16:24:37 2015 +0530

    clockevents/drivers/sun4i: Migrate to new 'set-state' interface
    
    Migrate sun4i driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    Cc: Maxime Ripard <maxime.ripard@free-electrons.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Acked-by: Maxime Ripard <maxime.ripard@free-electrons.com>

commit 2bcc4da3d45c5c69e529f7f454191a749277ab1d
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jun 18 16:24:36 2015 +0530

    clockevents/drivers/sh_tmu: Migrate to new 'set-state' interface
    
    Migrate sh_tmu driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    Cc: Magnus Damm <damm+renesas@opensource.se>
    Cc: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Cc: Paul Mundt <lethal@linux-sh.org>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Acked-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>

commit 19a9ffb3d6e9ed1d3a46aee18d0b7f8eff41c82b
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jun 18 16:24:35 2015 +0530

    clockevents/drivers/sh_mtu2: Migrate to new 'set-state' interface
    
    Migrate sh_mtu2 driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    Cc: Magnus Damm <damm+renesas@opensource.se>
    Cc: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Cc: Paul Mundt <lethal@linux-sh.org>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Acked-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>

commit 051b782e2406af7f831602c70f887ca9b510b511
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jun 18 16:24:34 2015 +0530

    clockevents/drivers/sh_cmt: Migrate to new 'set-state' interface
    
    Migrate sh_cmt driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    Cc: Magnus Damm <damm+renesas@opensource.se>
    Cc: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Cc: Paul Mundt <lethal@linux-sh.org>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Acked-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>

commit b49b570474490bad8ee5289b103563d978f20a7e
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jun 18 16:24:33 2015 +0530

    clockevents/drivers/samsung_pwm: Migrate to new 'set-state' interface
    
    Migrate samsung_pwm driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    Cc: Tomasz Figa <tfiga@chromium.org>
    Cc: Kukjin Kim <kgene@kernel.org>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit 99b3fa72efc545a7e21955c17f6a2f6f87dfacde
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jun 18 16:24:32 2015 +0530

    clockevents/drivers/rockchip: Migrate to new 'set-state' interface
    
    Migrate rockchip driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    We weren't doing anything for oneshot or resume modes, and so the
    callbacks aren't provided.
    
    Cc: Heiko Stuebner <heiko@sntech.de>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit 736b2df2abc1f128ce381e9f2e578502cabc2973
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jun 18 16:24:31 2015 +0530

    clockevents/drivers/qcom: Migrate to new 'set-state' interface
    
    Migrate qcom driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    Periodic mode isn't supported by the driver and so the callback isn't
    provided anymore.
    
    Cc: Stephen Boyd <sboyd@codeaurora.org>
    Cc: Kumar Gala <galak@codeaurora.org>
    Cc: Andy Gross <agross@codeaurora.org>
    Cc: David Brown <davidb@codeaurora.org>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Acked-by: Stephen Boyd <sboyd@codeaurora.org>

commit 47d490ea1529633f02209fcb4e89438995375a6f
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jun 18 16:24:30 2015 +0530

    clockevents/drivers/pxa: Migrate to new 'set-state' interface
    
    Migrate pxa driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    Both oneshot and shutdown modes had exactly same code and so only a
    single callback is sufficient now, which will be called for both the
    modes.
    
    Cc: Robert Jarzmik <robert.jarzmik@free.fr>
    Cc: Russell King <linux@arm.linux.org.uk>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Acked-by: Robert Jarzmik <robert.jarzmik@free.fr>

commit 9b0af69947562858059b379794b6e94309f367ed
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jun 18 16:24:29 2015 +0530

    clockevents/drivers/nomadik-mtu: Migrate to new 'set-state' interface
    
    Migrate nomadik-mtu driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>

commit eb8703e2ef7c311900174818e884bd49f64d4511
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jun 18 16:24:28 2015 +0530

    clockevents/drivers/mxs: Migrate to new 'set-state' interface
    
    Migrate mxs driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    Also drop:
    - 'mxs_clockevent_mode': as we have helpers available from core for the
      same.
      same state twice and so perhaps the check wasn't required.
    - 'clock_event_mode_label': CLOCK_EVT_MODE_* shouldn't be used anymore
      by drivers and it was used just to print old-state:new-state. The
      debug prints are called from mxs_irq_clear() now based on the
      state-name passed to it. The printed name will be same for shutdown
      and resume states as they use the same callback pointer.
    
    Cc: Shawn Guo <shawn.guo@linaro.org>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit a2b7e10d29051a084b490c2911c3e1388b5f9677
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jun 18 16:24:27 2015 +0530

    clockevents/drivers/mtk: Migrate to new 'set-state' interface
    
    Migrate mtk driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    Cc: Matthias Brugger <matthias.bgg@gmail.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit 37ae24716a584da33253cf6630a91c01b6656cc0
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jun 18 16:24:26 2015 +0530

    clockevents/drivers/moxart: Migrate to new 'set-state' interface
    
    Migrate moxart driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    Cc: Jonas Jensen <jonas.jensen@gmail.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit d47409347e76ca5e7cdbbb515a9000878b5222cc
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jun 18 16:24:25 2015 +0530

    clockevents/drivers/mips-gic: Migrate to new 'set-state' interface
    
    Migrate mips-gic driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    We weren't doing anything in the ->set_mode() callback. So, this patch
    doesn't provide any set-state callbacks.
    
    Cc: Andrew Bresticker <abrestic@chromium.org>
    Cc: Steven J. Hill <Steven.Hill@imgtec.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit 3f583d01d796f7b9fda0203b134585ca06a242ad
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jun 18 16:24:24 2015 +0530

    clockevents/drivers/metag_generic: Migrate to new 'set-state' interface
    
    Migrate metag_generic driver to the new 'set-state' interface provided
    by clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    We weren't doing anything in the ->set_mode() callback. Even the WARN()
    for periodic or unused modes isn't required anymore as the core is
    taking care of that now. So, this patch doesn't provide any set-state
    callbacks.
    
    Cc: James Hogan <james.hogan@imgtec.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit 40117bd559d3119eb06206f5323680d712db7775
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jun 18 16:24:23 2015 +0530

    clockevents/drivers/meson6: Migrate to new 'set-state' interface
    
    Migrate meson6 driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    Cc: Carlo Caione <carlo@caione.org>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Acked-by: Carlo Caione <carlo@caione.org>

commit 8eda41b0863ca82010010e951b7aa13b66a06e78
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jun 18 16:24:22 2015 +0530

    clockevents/drivers/i8253: Migrate to new 'set-state' interface
    
    Migrate i8253 driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    Cc: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit 737663401897f84610d00552eeb83ffa4d730142
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jun 18 16:24:21 2015 +0530

    clockevents/drivers/fsl_ftm: Migrate to new 'set-state' interface
    
    Migrate fsl_ftm driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    Cc: Xiubo Li <Li.Xiubo@freescale.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit 226be92b3e6ec2412cd29520fa09fb41a2606cb6
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jun 18 16:24:19 2015 +0530

    clockevents/drivers/dw_apb: Migrate to new 'set-state' interface
    
    Migrate dw_apb driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    Cc: Jacob Pan <jacob.jun.pan@linux.intel.com>
    Cc: Jamie Iles <jamie@jamieiles.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit 5c78b265454e6199754b61fa33ea3c1337e6aeab
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jun 18 16:24:18 2015 +0530

    clockevents/drivers/dummy_timer: Migrate to new 'set-state' interface
    
    Migrate dummy_timer driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    We weren't doing anything in the ->set_mode() callback. So, this patch
    doesn't provide any set-state callbacks.
    
    Cc: Mark Rutland <mark.rutland@arm.com>
    Signed-off-by: Viresh Kumae <viresh.kumar@linaro.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit bd88420c589afc0c58542a5d1953637ef2fa64e4
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jun 18 16:24:17 2015 +0530

    clockevents/drivers/clps711x: Migrate to new 'set-state' interface
    
    Migrate clps711x driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    We weren't doing anything in the ->set_mode() callback. So, this patch
    doesn't provide any set-state callbacks.
    
    Cc: Alexander Shiyan <shc_work@mail.ru>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit 5c0a4bbefc0571ba3addb39da0eb53368c018b64
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jun 18 16:24:16 2015 +0530

    clockevents/drivers/cadence_ttc: Migrate to new 'set-state' interface
    
    Migrate cadence_ttc driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    Cc: Michal Simek <michal.simek@xilinx.com>
    Cc: Sren Brinkmann <soren.brinkmann@xilinx.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Tested-by: Sren Brinkmann <soren.brinkmann@xilinx.com>

commit 3465f60917f2dbbc227e2a2e7913ad75bb604c12
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Jun 30 14:30:48 2015 +0530

    clockevents/drivers/asm9260: Migrate to new 'set-state' interface
    
    Migrate asm9260 driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    As a default the timer was stopped when entering in the set_mode(RESUME)
    function, now this is done explicitly with the new API.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    Cc: Oleksij Rempel <linux@rempel-privat.de>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit 0fae62eafec3c033d49160344228a4fa7d6303bc
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Tue Jun 23 14:56:29 2015 +0200

    clockevents/drivers/sh_cmt: Remove obsolete sh-cmt-48-gen2 platform_device_id entry
    
    Since commit 914d7d148411997c ("ARM: shmobile: r8a73a4: Remove legacy
    code"), all former users of the "sh-cmt-48-gen2" platform device name
    are only supported in generic DT-only ARM multi-platform builds.  The
    driver doesn't need to match platform devices by name anymore, hence
    remove the corresponding platform_device_id entry.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Acked-by: Simon Horman <horms+renesas@verge.net.au>

commit 59252d187763ef3675fba1623be6996761fc2400
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Tue Jun 23 14:56:28 2015 +0200

    clockevents/drivers/sh_cmt: Remove obsolete sh-cmt-32-fast platform_device_id entry
    
    Since commit 59b89af1d5551c12 ("ARM: shmobile: sh7372: Remove Legacy C
    SoC code"), there are no more users left of the "sh-cmt-32-fast"
    platform device name. Hence remove the corresponding platform_device_id
    entry from the driver.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Acked-by: Simon Horman <horms+renesas@verge.net.au>

commit 479a932982944786269296a31682e5642f87b89a
Author: Alexey Klimov <klimov.linux@gmail.com>
Date:   Sun Jun 21 23:41:39 2015 +0300

    clockevents/drivers/exynos_mct: Remove unneeded container_of()
    
    Patch removes unneeded container_of() macro in exynos4_local_timer_setup().
    Instead let's pass mevt pointer to setup and stop functions from
    exynos4_mct_cpu_notify() and let them get evt pointer.
    
    Tested on odroid-xu3.
    
    Signed-off-by: Alexey Klimov <klimov.linux@gmail.com>
    Acked-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Reviewed-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>

commit 02760b116c56376ad564e959f81835008848861d
Author: Antonio Borneo <borneo.antonio@gmail.com>
Date:   Wed Jun 17 19:42:30 2015 +0800

    clockevents/drivers/Kconfig: Replace USE_OF with OF
    
    USE_OF is used as intermediate Kconfig option by few arch's (ARM, MIPS,
    Xtensa); in all these cases it implies setting option OF too. Replace the
    only instance of USE_OF in clocksource with OF.
    
    Signed-off-by: Antonio Borneo <borneo.antonio@gmail.com>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit 54d46b7fbcbd00fe4b20a27208e5909facc714e3
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Thu Aug 6 17:32:06 2015 +0200

    clockevents/drivers/sh_cmt: Only perform clocksource suspend/resume if enabled
    
    Currently the sh_cmt clocksource timer is disabled or enabled
    unconditionally on clocksource suspend resp. resume, even if a
    better clocksource is present (e.g. arch_sys_counter) and the
    sh_cmt clocksource is not enabled.
    
    As sh_cmt is a syscore device when its timer is enabled, this
    may lead to a genpd.prepared_count imbalance in the presence of
    PM Domains, which may cause a lock-up during reboot after s2ram.
    
    During suspend:
      - pm_genpd_prepare() is called for all non-syscore devices (incl.
        sh_cmt), increasing genpd.prepared_count for each device,
      - clocksource.suspend() is called for all clocksource devices,
      - sh_cmt_clocksource_suspend() calls sh_cmt_stop(), which is a no-op
        as the clocksource was not enabled.
    
    During resume:
      - clocksource.resume() is called for all clocksource devices,
      - sh_cmt_clocksource_resume() calls sh_cmt_start(), which enables the
        clocksource timer, and turns sh_cmt into a syscore device,
      - pm_genpd_complete() is called for all non-syscore devices (excl.
        sh_cmt now!), decreasing genpd.prepared_count for each device but
        sh_cmt.
    
    Now genpd.prepared_count of the PM Domain containing sh_cmt is
    still 1 instead of zero.  On subsequent suspend/resume cycles,
    sh_cmt is still a syscore device, hence it's skipped for
    pm_genpd_{prepare,complete}(), keeping the imbalance of
    genpd.prepared_count at 1.
    
    During reboot:
    
      - platform_drv_shutdown() is called for any platform device that has
        a driver with a .shutdown() method (only rcar-dmac on R-Car Gen2),
    
      - platform_drv_shutdown() calls dev_pm_domain_detach(), which
        calls genpd_dev_pm_detach(),
    
      - genpd_dev_pm_detach() keeps calling pm_genpd_remove_device() until
        it doesn't return -EAGAIN[*],
    
      - If the device is part of the same PM Domain as sh_cmt,
        pm_genpd_remove_device() always fails with -EAGAIN due to
        genpd.prepared_count > 0.
    
      - Infinite loop in genpd_dev_pm_detach()[*].
    
    [*] Commit 93af5e9354432828 ("PM / Domains: Avoid infinite loops in
        attach/detach code") already limited the number of loop iterations,
        avoiding the lock-up.
    
    To fix this, only disable or enable the clocksource timer on
    clocksource suspend resp. resume if the clocksource was enabled.
    
    This was tested on r8a7791/koelsch with the CPG Clock Domain:
    
      - using arch_sys_counter as the clocksource, which is the default, and
        which showed the problem,
    
      - using sh_cmt as a clocksource ("echo ffca0000.timer > \
        /sys/devices/system/clocksource/clocksource0/current_clocksource"),
        which behaves the same as before.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/1438875126-12596-2-git-send-email-daniel.lezcano@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 117b8a10fe0c434d9043267efd51f3ba3f3d359a
Author: Alexander Sverdlin <alexander.sverdlin@nokia.com>
Date:   Mon Jun 29 10:41:03 2015 +0200

    sctp: Fix race between OOTB responce and route removal
    
    [ Upstream commit 29c4afc4e98f4dc0ea9df22c631841f9c220b944 ]
    
    There is NULL pointer dereference possible during statistics update if the route
    used for OOTB responce is removed at unfortunate time. If the route exists when
    we receive OOTB packet and we finally jump into sctp_packet_transmit() to send
    ABORT, but in the meantime route is removed under our feet, we take "no_route"
    path and try to update stats with IP_INC_STATS(sock_net(asoc->base.sk), ...).
    
    But sctp_ootb_pkt_new() used to prepare responce packet doesn't call
    sctp_transport_set_owner() and therefore there is no asoc associated with this
    packet. Probably temporary asoc just for OOTB responces is overkill, so just
    introduce a check like in all other places in sctp_packet_transmit(), where
    "asoc" is dereferenced.
    
    To reproduce this, one needs to
    0. ensure that sctp module is loaded (otherwise ABORT is not generated)
    1. remove default route on the machine
    2. while true; do
         ip route del [interface-specific route]
         ip route add [interface-specific route]
       done
    3. send enough OOTB packets (i.e. HB REQs) from another host to trigger ABORT
       responce
    
    On x86_64 the crash looks like this:
    
    BUG: unable to handle kernel NULL pointer dereference at 0000000000000020
    IP: [<ffffffffa05ec9ac>] sctp_packet_transmit+0x63c/0x730 [sctp]
    PGD 0
    Oops: 0000 [#1] PREEMPT SMP
    Modules linked in: ...
    CPU: 0 PID: 0 Comm: swapper/0 Tainted: G           O    4.0.5-1-ARCH #1
    Hardware name: ...
    task: ffffffff818124c0 ti: ffffffff81800000 task.ti: ffffffff81800000
    RIP: 0010:[<ffffffffa05ec9ac>]  [<ffffffffa05ec9ac>] sctp_packet_transmit+0x63c/0x730 [sctp]
    RSP: 0018:ffff880127c037b8  EFLAGS: 00010296
    RAX: 0000000000000000 RBX: 0000000000000000 RCX: 00000015ff66b480
    RDX: 00000015ff66b400 RSI: ffff880127c17200 RDI: ffff880123403700
    RBP: ffff880127c03888 R08: 0000000000017200 R09: ffffffff814625af
    R10: ffffea00047e4680 R11: 00000000ffffff80 R12: ffff8800b0d38a28
    R13: ffff8800b0d38a28 R14: ffff8800b3e88000 R15: ffffffffa05f24e0
    FS:  0000000000000000(0000) GS:ffff880127c00000(0000) knlGS:0000000000000000
    CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b
    CR2: 0000000000000020 CR3: 00000000c855b000 CR4: 00000000000007f0
    Stack:
     ffff880127c03910 ffff8800b0d38a28 ffffffff8189d240 ffff88011f91b400
     ffff880127c03828 ffffffffa05c94c5 0000000000000000 ffff8800baa1c520
     0000000000000000 0000000000000001 0000000000000000 0000000000000000
    Call Trace:
     <IRQ>
     [<ffffffffa05c94c5>] ? sctp_sf_tabort_8_4_8.isra.20+0x85/0x140 [sctp]
     [<ffffffffa05d6b42>] ? sctp_transport_put+0x52/0x80 [sctp]
     [<ffffffffa05d0bfc>] sctp_do_sm+0xb8c/0x19a0 [sctp]
     [<ffffffff810b0e00>] ? trigger_load_balance+0x90/0x210
     [<ffffffff810e0329>] ? update_process_times+0x59/0x60
     [<ffffffff812c7a40>] ? timerqueue_add+0x60/0xb0
     [<ffffffff810e0549>] ? enqueue_hrtimer+0x29/0xa0
     [<ffffffff8101f599>] ? read_tsc+0x9/0x10
     [<ffffffff8116d4b5>] ? put_page+0x55/0x60
     [<ffffffff810ee1ad>] ? clockevents_program_event+0x6d/0x100
     [<ffffffff81462b68>] ? skb_free_head+0x58/0x80
     [<ffffffffa029a10b>] ? chksum_update+0x1b/0x27 [crc32c_generic]
     [<ffffffff81283f3e>] ? crypto_shash_update+0xce/0xf0
     [<ffffffffa05d3993>] sctp_endpoint_bh_rcv+0x113/0x280 [sctp]
     [<ffffffffa05dd4e6>] sctp_inq_push+0x46/0x60 [sctp]
     [<ffffffffa05ed7a0>] sctp_rcv+0x880/0x910 [sctp]
     [<ffffffffa05ecb50>] ? sctp_packet_transmit_chunk+0xb0/0xb0 [sctp]
     [<ffffffffa05ecb70>] ? sctp_csum_update+0x20/0x20 [sctp]
     [<ffffffff814b05a5>] ? ip_route_input_noref+0x235/0xd30
     [<ffffffff81051d6b>] ? ack_ioapic_level+0x7b/0x150
     [<ffffffff814b27be>] ip_local_deliver_finish+0xae/0x210
     [<ffffffff814b2e15>] ip_local_deliver+0x35/0x90
     [<ffffffff814b2a15>] ip_rcv_finish+0xf5/0x370
     [<ffffffff814b3128>] ip_rcv+0x2b8/0x3a0
     [<ffffffff81474193>] __netif_receive_skb_core+0x763/0xa50
     [<ffffffff81476c28>] __netif_receive_skb+0x18/0x60
     [<ffffffff81476cb0>] netif_receive_skb_internal+0x40/0xd0
     [<ffffffff814776c8>] napi_gro_receive+0xe8/0x120
     [<ffffffffa03946aa>] rtl8169_poll+0x2da/0x660 [r8169]
     [<ffffffff8147896a>] net_rx_action+0x21a/0x360
     [<ffffffff81078dc1>] __do_softirq+0xe1/0x2d0
     [<ffffffff8107912d>] irq_exit+0xad/0xb0
     [<ffffffff8157d158>] do_IRQ+0x58/0xf0
     [<ffffffff8157b06d>] common_interrupt+0x6d/0x6d
     <EOI>
     [<ffffffff810e1218>] ? hrtimer_start+0x18/0x20
     [<ffffffffa05d65f9>] ? sctp_transport_destroy_rcu+0x29/0x30 [sctp]
     [<ffffffff81020c50>] ? mwait_idle+0x60/0xa0
     [<ffffffff810216ef>] arch_cpu_idle+0xf/0x20
     [<ffffffff810b731c>] cpu_startup_entry+0x3ec/0x480
     [<ffffffff8156b365>] rest_init+0x85/0x90
     [<ffffffff818eb035>] start_kernel+0x48b/0x4ac
     [<ffffffff818ea120>] ? early_idt_handlers+0x120/0x120
     [<ffffffff818ea339>] x86_64_start_reservations+0x2a/0x2c
     [<ffffffff818ea49c>] x86_64_start_kernel+0x161/0x184
    Code: 90 48 8b 80 b8 00 00 00 48 89 85 70 ff ff ff 48 83 bd 70 ff ff ff 00 0f 85 cd fa ff ff 48 89 df 31 db e8 18 63 e7 e0 48 8b 45 80 <48> 8b 40 20 48 8b 40 30 48 8b 80 68 01 00 00 65 48 ff 40 78 e9
    RIP  [<ffffffffa05ec9ac>] sctp_packet_transmit+0x63c/0x730 [sctp]
     RSP <ffff880127c037b8>
    CR2: 0000000000000020
    ---[ end trace 5aec7fd2dc983574 ]---
    Kernel panic - not syncing: Fatal exception in interrupt
    Kernel Offset: 0x0 from 0xffffffff81000000 (relocation range: 0xffffffff80000000-0xffffffff9fffffff)
    drm_kms_helper: panic occurred, switching back to text console
    ---[ end Kernel panic - not syncing: Fatal exception in interrupt
    
    Signed-off-by: Alexander Sverdlin <alexander.sverdlin@nokia.com>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Acked-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Acked-by: Vlad Yasevich <vyasevich@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    [bwh: Backported to 3.2: sctp alway uses init_net]
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit 75f940615aa93cb681b36e355b3f9509d955f547
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Jun 12 13:30:17 2015 +0530

    clockevents/drivers/em_sti: Migrate to new 'set-state' interface
    
    Migrate em_sti driver to the new 'set-state' interface provided by
    the clockevents core, the earlier 'set-mode' interface is marked
    obsolete now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    NOTE: This also drops a special check:
    
            if (old_mode == CLOCK_EVT_MODE_ONESHOT)
                    em_sti_stop(p, USER_CLOCKEVENT);
    
    as it doesn't look like that important. This driver only supports
    ONESHOT and we can only move only to SHUTDOWN from ONESHOT and.
    Also on second call (on shutdown), em_sti_stop() would return without
    disabling the device again.
    
    Acked-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: Magnus Damm <magnus.damm@gmail.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit 8f9327cbb6e87ce1bed3e5dfbac70d8a96c6d1cc
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Jun 12 13:30:16 2015 +0530

    clockevents/drivers/cs5535: Migrate to new 'set-state' interface
    
    Migrate cs5535 driver to the new 'set-state' interface provided by
    the clockevents core, the earlier 'set-mode' interface is marked
    obsolete now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    Acked-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: Andres Salomon <dilinger@queued.net>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit b4cf5d710fdf297692d5c0f36cddbbeaa690e323
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Jun 12 13:30:15 2015 +0530

    clockevents/drivers/bcm_kona: Migrate to new 'set-state' interface
    
    Migrate bcm_kona driver to the new 'set-state' interface provided by
    the clockevents core, the earlier 'set-mode' interface is marked
    obsolete now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    Oneshot callback isn't required as it was empty.
    
    Acked-by: Ray Jui <rjui@broadcom.com>
    Cc: Florian Fainelli <f.fainelli@gmail.com>
    Cc: Ray Jui <rjui@broadcom.com>
    Cc: Scott Branden <sbranden@broadcom.com>
    Cc: bcm-kernel-feedback-list@broadcom.com
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit 4996978490f7e48f29408e499c7e542ac1e2c5b8
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Jun 12 13:30:14 2015 +0530

    clockevents/drivers/bcm2835: Migrate to new 'set-state' interface
    
    Migrate bcm2835 driver to the new 'set-state' interface provided by
    the clockevents core, the earlier 'set-mode' interface is marked
    obsolete now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    We weren't doing anything in the ->set_mode() callback. So, this patch
    doesn't provide any set-state callbacks.
    
    Acked-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Tested-by: Stephen Warren <swarren@wwwdotorg.org>
    Cc: Stephen Warren <swarren@wwwdotorg.org>
    Cc: Lee Jones <lee@kernel.org>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit e511e6c3cd9baa3177f29aeb30c4ac7150c5f93b
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Jun 12 13:30:13 2015 +0530

    clockevents/drivers/arm_global_timer: Migrate to new 'set-state' interface
    
    Migrate arm_global_timer driver to the new 'set-state' interface
    provided by the clockevents core, the earlier 'set-mode' interface is
    marked obsolete now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    Acked-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Acked-by: Maxime Coquelin <maxime.coquelin@st.com>
    Acked-by: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
    Cc: Srinivas Kandagatla <srinivas.kandagatla@gmail.com>
    Cc: Maxime Coquelin <maxime.coquelin@st.com>
    Cc: Patrice Chotard <patrice.chotard@st.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit 46c5bfdda3de91ba4324d73403af7dfb60f5ee38
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Jun 12 13:30:12 2015 +0530

    clockevents/drivers/arm_arch_timer: Migrate to new 'set-state' interface
    
    Migrate arm_arch_timer driver to the new 'set-state' interface provided
    by the clockevents core, the earlier 'set-mode' interface is marked
    obsolete now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit bc609cb47fb2e74654e23cef0a1d4db38b6570a3
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Wed Aug 5 00:52:41 2015 -0700

    drivers/hv: Migrate to new 'set-state' interface
    
    Migrate hv driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    Cc: "K. Y. Srinivasan" <kys@microsoft.com>
    Cc: Haiyang Zhang <haiyangz@microsoft.com>
    Cc: devel@linuxdriverproject.org
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 2517281d63a2b09d94aedfb522943617048f337e
Author: Vitaly Kuznetsov <vkuznets@redhat.com>
Date:   Sat Aug 1 16:08:07 2015 -0700

    Drivers: hv: vmbus: add special kexec handler
    
    When general-purpose kexec (not kdump) is being performed in Hyper-V guest
    the newly booted kernel fails with an MCE error coming from the host. It
    is the same error which was fixed in the "Drivers: hv: vmbus: Implement
    the protocol for tearing down vmbus state" commit - monitor pages remain
    special and when they're being written to (as the new kernel doesn't know
    these pages are special) bad things happen. We need to perform some
    minimalistic cleanup before booting a new kernel on kexec. To do so we
    need to register a special machine_ops.shutdown handler to be executed
    before the native_machine_shutdown(). Registering a shutdown notification
    handler via the register_reboot_notifier() call is not sufficient as it
    happens to early for our purposes. machine_ops is not being exported to
    modules (and I don't think we want to export it) so let's do this in
    mshyperv.c
    
    The minimalistic cleanup consists of cleaning up clockevents, synic MSRs,
    guest os id MSR, and hypercall MSR.
    
    Kdump doesn't require all this stuff as it lives in a separate memory
    space.
    
    Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit d74892c5b291c0010295d26d6b1e11cd70451722
Author: Luiz Capitulino <lcapitulino@redhat.com>
Date:   Wed Jul 29 15:14:17 2015 -0400

    clockevents: Drop redundant cpumask check in tick_check_new_device()
    
    The same check is performed by tick_check_percpu().
    
    Signed-off-by: Luiz Capitulino <lcapitulino@redhat.com>
    Link: http://lkml.kernel.org/r/20150729151417.069d1bb0@redhat.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit c8b5db7de66b75330a96f9f1ad7376b89646c953
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jul 16 16:28:45 2015 +0530

    x86/hpet: Migrate to new set_state interface
    
    Migrate hpet driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    Forward definition of 'hpet_clockevent' wasn't required and so it is
    placed after all the callback are defined, to avoid forward declaring
    all the callbacks.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Cc: linaro-kernel@lists.linaro.org
    Cc: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Link: http://lkml.kernel.org/r/8cc9864b6d6342dfac28f270cf69f4cba46fffae.1437042675.git.viresh.kumar@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 955381dd65654bd6f066408823691db8fa7d05bb
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jul 16 16:28:48 2015 +0530

    x86/xen/time: Migrate to new set-state interface
    
    Migrate xen driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    Callbacks aren't implemented for modes where we weren't doing anything.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Cc: linaro-kernel@lists.linaro.org
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: Boris Ostrovsky <boris.ostrovsky@oracle.com>
    Cc: David Vrabel <david.vrabel@citrix.com>
    Cc: xen-devel@lists.xenproject.org (moderated list:XEN HYPERVISOR INTERFACE)
    Link: http://lkml.kernel.org/r/881eea6e1a3d483cd33e044cd34827cce26a57fd.1437042675.git.viresh.kumar@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit ca53d434f7e63352c9edd1ad8cde4dfe11da44aa
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jul 16 16:28:47 2015 +0530

    x86/uv/time: Migrate to new set-state interface
    
    Migrate uv driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    We weren't doing anything while switching modes other than in shutdown
    mode and so those are not implemented.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Cc: linaro-kernel@lists.linaro.org
    Cc: Christoph Lameter <cl@linux.com>
    Cc: Tejun Heo <tj@kernel.org>
    Link: http://lkml.kernel.org/r/52e04139746222a2e82a96d13953cbc306cfb59b.1437042675.git.viresh.kumar@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit c2e13cc2cea64385043fa9afaaf91a74ec438467
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jul 16 16:28:46 2015 +0530

    x86/lguest/timer: Migrate to new set-state interface
    
    Migrate lguest driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    We weren't doing anything while switching modes other than in shutdown
    mode and so those are not implemented.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-and-tested-by: Rusty Russell <rusty@rustcorp.com.au>
    Cc: linaro-kernel@lists.linaro.org
    Cc: Alexander Kuleshov <kuleshovmail@gmail.com>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: Jan Beulich <JBeulich@suse.com>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: lguest@lists.ozlabs.org (open list:LGUEST)
    Link: http://lkml.kernel.org/r/b96f1c308f4523255c5394a4e6e13f2b67685402.1437042675.git.viresh.kumar@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 38715df206d52817ac8ac032f35ee76955bdc15d
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jul 16 16:56:30 2015 +0530

    tile/time: Migrate to new 'set-state' interface
    
    Migrate tile driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    Cc: Chris Metcalf <cmetcalf@ezchip.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Chris Metcalf <cmetcalf@ezchip.com>

commit a41f0610323e094c35d00dc420f77d8f789e8578
Author: Alexander Sverdlin <alexander.sverdlin@nokia.com>
Date:   Mon Jun 29 10:41:03 2015 +0200

    sctp: Fix race between OOTB responce and route removal
    
    [ Upstream commit 29c4afc4e98f4dc0ea9df22c631841f9c220b944 ]
    
    There is NULL pointer dereference possible during statistics update if the route
    used for OOTB responce is removed at unfortunate time. If the route exists when
    we receive OOTB packet and we finally jump into sctp_packet_transmit() to send
    ABORT, but in the meantime route is removed under our feet, we take "no_route"
    path and try to update stats with IP_INC_STATS(sock_net(asoc->base.sk), ...).
    
    But sctp_ootb_pkt_new() used to prepare responce packet doesn't call
    sctp_transport_set_owner() and therefore there is no asoc associated with this
    packet. Probably temporary asoc just for OOTB responces is overkill, so just
    introduce a check like in all other places in sctp_packet_transmit(), where
    "asoc" is dereferenced.
    
    To reproduce this, one needs to
    0. ensure that sctp module is loaded (otherwise ABORT is not generated)
    1. remove default route on the machine
    2. while true; do
         ip route del [interface-specific route]
         ip route add [interface-specific route]
       done
    3. send enough OOTB packets (i.e. HB REQs) from another host to trigger ABORT
       responce
    
    On x86_64 the crash looks like this:
    
    BUG: unable to handle kernel NULL pointer dereference at 0000000000000020
    IP: [<ffffffffa05ec9ac>] sctp_packet_transmit+0x63c/0x730 [sctp]
    PGD 0
    Oops: 0000 [#1] PREEMPT SMP
    Modules linked in: ...
    CPU: 0 PID: 0 Comm: swapper/0 Tainted: G           O    4.0.5-1-ARCH #1
    Hardware name: ...
    task: ffffffff818124c0 ti: ffffffff81800000 task.ti: ffffffff81800000
    RIP: 0010:[<ffffffffa05ec9ac>]  [<ffffffffa05ec9ac>] sctp_packet_transmit+0x63c/0x730 [sctp]
    RSP: 0018:ffff880127c037b8  EFLAGS: 00010296
    RAX: 0000000000000000 RBX: 0000000000000000 RCX: 00000015ff66b480
    RDX: 00000015ff66b400 RSI: ffff880127c17200 RDI: ffff880123403700
    RBP: ffff880127c03888 R08: 0000000000017200 R09: ffffffff814625af
    R10: ffffea00047e4680 R11: 00000000ffffff80 R12: ffff8800b0d38a28
    R13: ffff8800b0d38a28 R14: ffff8800b3e88000 R15: ffffffffa05f24e0
    FS:  0000000000000000(0000) GS:ffff880127c00000(0000) knlGS:0000000000000000
    CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b
    CR2: 0000000000000020 CR3: 00000000c855b000 CR4: 00000000000007f0
    Stack:
     ffff880127c03910 ffff8800b0d38a28 ffffffff8189d240 ffff88011f91b400
     ffff880127c03828 ffffffffa05c94c5 0000000000000000 ffff8800baa1c520
     0000000000000000 0000000000000001 0000000000000000 0000000000000000
    Call Trace:
     <IRQ>
     [<ffffffffa05c94c5>] ? sctp_sf_tabort_8_4_8.isra.20+0x85/0x140 [sctp]
     [<ffffffffa05d6b42>] ? sctp_transport_put+0x52/0x80 [sctp]
     [<ffffffffa05d0bfc>] sctp_do_sm+0xb8c/0x19a0 [sctp]
     [<ffffffff810b0e00>] ? trigger_load_balance+0x90/0x210
     [<ffffffff810e0329>] ? update_process_times+0x59/0x60
     [<ffffffff812c7a40>] ? timerqueue_add+0x60/0xb0
     [<ffffffff810e0549>] ? enqueue_hrtimer+0x29/0xa0
     [<ffffffff8101f599>] ? read_tsc+0x9/0x10
     [<ffffffff8116d4b5>] ? put_page+0x55/0x60
     [<ffffffff810ee1ad>] ? clockevents_program_event+0x6d/0x100
     [<ffffffff81462b68>] ? skb_free_head+0x58/0x80
     [<ffffffffa029a10b>] ? chksum_update+0x1b/0x27 [crc32c_generic]
     [<ffffffff81283f3e>] ? crypto_shash_update+0xce/0xf0
     [<ffffffffa05d3993>] sctp_endpoint_bh_rcv+0x113/0x280 [sctp]
     [<ffffffffa05dd4e6>] sctp_inq_push+0x46/0x60 [sctp]
     [<ffffffffa05ed7a0>] sctp_rcv+0x880/0x910 [sctp]
     [<ffffffffa05ecb50>] ? sctp_packet_transmit_chunk+0xb0/0xb0 [sctp]
     [<ffffffffa05ecb70>] ? sctp_csum_update+0x20/0x20 [sctp]
     [<ffffffff814b05a5>] ? ip_route_input_noref+0x235/0xd30
     [<ffffffff81051d6b>] ? ack_ioapic_level+0x7b/0x150
     [<ffffffff814b27be>] ip_local_deliver_finish+0xae/0x210
     [<ffffffff814b2e15>] ip_local_deliver+0x35/0x90
     [<ffffffff814b2a15>] ip_rcv_finish+0xf5/0x370
     [<ffffffff814b3128>] ip_rcv+0x2b8/0x3a0
     [<ffffffff81474193>] __netif_receive_skb_core+0x763/0xa50
     [<ffffffff81476c28>] __netif_receive_skb+0x18/0x60
     [<ffffffff81476cb0>] netif_receive_skb_internal+0x40/0xd0
     [<ffffffff814776c8>] napi_gro_receive+0xe8/0x120
     [<ffffffffa03946aa>] rtl8169_poll+0x2da/0x660 [r8169]
     [<ffffffff8147896a>] net_rx_action+0x21a/0x360
     [<ffffffff81078dc1>] __do_softirq+0xe1/0x2d0
     [<ffffffff8107912d>] irq_exit+0xad/0xb0
     [<ffffffff8157d158>] do_IRQ+0x58/0xf0
     [<ffffffff8157b06d>] common_interrupt+0x6d/0x6d
     <EOI>
     [<ffffffff810e1218>] ? hrtimer_start+0x18/0x20
     [<ffffffffa05d65f9>] ? sctp_transport_destroy_rcu+0x29/0x30 [sctp]
     [<ffffffff81020c50>] ? mwait_idle+0x60/0xa0
     [<ffffffff810216ef>] arch_cpu_idle+0xf/0x20
     [<ffffffff810b731c>] cpu_startup_entry+0x3ec/0x480
     [<ffffffff8156b365>] rest_init+0x85/0x90
     [<ffffffff818eb035>] start_kernel+0x48b/0x4ac
     [<ffffffff818ea120>] ? early_idt_handlers+0x120/0x120
     [<ffffffff818ea339>] x86_64_start_reservations+0x2a/0x2c
     [<ffffffff818ea49c>] x86_64_start_kernel+0x161/0x184
    Code: 90 48 8b 80 b8 00 00 00 48 89 85 70 ff ff ff 48 83 bd 70 ff ff ff 00 0f 85 cd fa ff ff 48 89 df 31 db e8 18 63 e7 e0 48 8b 45 80 <48> 8b 40 20 48 8b 40 30 48 8b 80 68 01 00 00 65 48 ff 40 78 e9
    RIP  [<ffffffffa05ec9ac>] sctp_packet_transmit+0x63c/0x730 [sctp]
     RSP <ffff880127c037b8>
    CR2: 0000000000000020
    ---[ end trace 5aec7fd2dc983574 ]---
    Kernel panic - not syncing: Fatal exception in interrupt
    Kernel Offset: 0x0 from 0xffffffff81000000 (relocation range: 0xffffffff80000000-0xffffffff9fffffff)
    drm_kms_helper: panic occurred, switching back to text console
    ---[ end Kernel panic - not syncing: Fatal exception in interrupt
    
    Signed-off-by: Alexander Sverdlin <alexander.sverdlin@nokia.com>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Acked-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Acked-by: Vlad Yasevich <vyasevich@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>

commit b23d8e527815954768861bb20d2b224009fff7cd
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jul 16 16:28:44 2015 +0530

    x86/apic: Migrate apic timer to new set_state interface
    
    Migrate apic driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    We weren't doing anything while switching to resume mode and so that
    callback isn't implemented.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Cc: linaro-kernel@lists.linaro.org
    Cc: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: David Rientjes <rientjes@google.com>
    Cc: Bandan Das <bsd@redhat.com>
    Link: http://lkml.kernel.org/r/1896ac5989d27f2ac37f4786af9bd537e1921b83.1437042675.git.viresh.kumar@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit aeec6cdad6cda5fdf26f937c0d15f101539d8185
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jul 16 16:56:14 2015 +0530

    ARC/time: Migrate to new 'set-state' interface
    
    Migrate arc driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>

commit 09adcdf212d777ace8bb31bed8ca5c1dbd56bd0f
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jul 16 16:56:15 2015 +0530

    AVR32/time: Migrate to new 'set-state' interface
    
    Migrate avr32 driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    We want to call cpu_idle_poll_ctrl() in shutdown only if we were in
    oneshot or resume state earlier. Create another variable to save this
    information and check that in shutdown callback.
    
    Cc: Haavard Skinnemoen <hskinnemoen@gmail.com>
    Cc: Hans-Christian Egtvedt <egtvedt@samfundet.no>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Hans-Christian Egtvedt <egtvedt@samfundet.no>

commit 87dc11220df266d7d4b6dc594b55d0729b92809d
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Wed Jul 15 11:21:40 2015 -0700

    clockevents: Remove clockevents_notify() prototype
    
    This function no longer exists after commit a49b116dcb12
    (clockevents: Cleanup dead cpu explicitely, 2015-04-03). Remove
    the prototype and the stub function.
    
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Cc: trivial@kernel.org
    Cc: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Link: http://lkml.kernel.org/r/1436984500-5425-1-git-send-email-sboyd@codeaurora.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 52e43a11aed3f8166ba311744637d636a8a79096
Merge: b3f81739ab2a 10dca88a4be6
Author: Olof Johansson <olof@lixom.net>
Date:   Fri Jul 17 09:58:32 2015 -0700

    Merge branch 'ARM/clkevt/set-state-4.3' of git://git.kernel.org/pub/scm/linux/kernel/git/vireshk/linux into next/cleanup
    
    Merge "ARM: clockevents: Migrate to 'set-state' callbacks" from Viresh Kumar:
    
    This series migrates ARM clockevent drivers (present in arch/arm/
    directory), to the new set-state interface. This would enable these
    drivers to use new states (like: ONESHOT_STOPPED, etc.) of a clockevent
    device (if required), as the set-mode interface is marked obsolete now
    and wouldn't be expanded to handle new states.
    
    * 'ARM/clkevt/set-state-4.3' of git://git.kernel.org/pub/scm/linux/kernel/git/vireshk/linux:
      ARM/orion/time: Migrate to new 'set-state' interface
      ARM/iop/time: Migrate to new 'set-state' interface
      ARM/w90x900/time: Migrate to new 'set-state' interface
      ARM/SPEAr/time: Migrate to new 'set-state' interface
      ARM/omap2/timer: Migrate to new 'set-state' interface
      ARM/omap1/timer32: Migrate to new 'set-state' interface
      ARM/omap1/time: Migrate to new 'set-state' interface
      ARM/netx/time: Migrate to new 'set-state' interface
      ARM/mmp/time: Migrate to new 'set-state' interface
      ARM/lpc32xx/timer: Migrate to new 'set-state' interface
      ARM/ks8695/time: Migrate to new 'set-state' interface
      ARM/ixp4xx/timer: Migrate to new 'set-state' interface
      ARM/imx/epit: Migrate to new 'set-state' interface
      ARM/gemini/time: Migrate to new 'set-state' interface
      ARM/dc21285-timer: Migrate to new 'set-state' interface
      ARM/davinci/time: Migrate to new 'set-state' interface
      ARM/cns3xxx/timer: Migrate to new 'set-state' interface
      ARM/smp_twd: Migrate to new 'set-state' interface
    
    Signed-off-by: Olof Johansson <olof@lixom.net>

commit 10dca88a4be632678088f5cbc20b54c2113ecb91
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Feb 27 13:39:52 2015 +0530

    ARM/orion/time: Migrate to new 'set-state' interface
    
    Migrate orion driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Andrew Lunn <andrew@lunn.ch>
    Cc: Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
    Cc: Gregory Clement <gregory.clement@free-electrons.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>

commit 8d778377e598bd78d4ce788b20b1c74777c5d137
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Feb 27 13:39:52 2015 +0530

    ARM/iop/time: Migrate to new 'set-state' interface
    
    Migrate iop driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    Cc: Russell King <linux@arm.linux.org.uk>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>

commit 6c724d4388997588f38587213ce1ab7d3925b87c
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Feb 27 13:39:52 2015 +0530

    ARM/w90x900/time: Migrate to new 'set-state' interface
    
    Migrate w90x900 driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    Cc: Wan ZongShun <mcuos.com@gmail.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>

commit 7639c0b8b3d5e061253936ed5279ff674be238cb
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Feb 27 13:39:52 2015 +0530

    ARM/SPEAr/time: Migrate to new 'set-state' interface
    
    Migrate SPEAr driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    Also kill the unnecessary forward declaration of set-mode routine by
    moving 'struct clock_event_device clkevt' towards the bottom of the file.
    
    Cc: Shiraz Hashim <shiraz.linux.kernel@gmail.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>

commit 74364615a643f65b6de9faa4112365e4880c7047
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Feb 27 13:39:52 2015 +0530

    ARM/omap2/timer: Migrate to new 'set-state' interface
    
    Migrate omap2 driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    Acked-by: Santosh Shilimkar <ssantosh@kernel.org>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>

commit 69ec063f6018b5931974e7c4ac7a24b1a075ca25
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Feb 27 13:39:52 2015 +0530

    ARM/omap1/timer32: Migrate to new 'set-state' interface
    
    Migrate omap timer32 driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    Acked-by: Santosh Shilimkar <ssantosh@kernel.org>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>

commit 29105e102085a9c1a1eea4f634db2890aca884b8
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Feb 27 13:39:52 2015 +0530

    ARM/omap1/time: Migrate to new 'set-state' interface
    
    Migrate omap driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    Acked-by: Santosh Shilimkar <ssantosh@kernel.org>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>

commit c22437b78e77ae05768d77d44bb5651ac7ef5da9
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Feb 27 13:39:52 2015 +0530

    ARM/netx/time: Migrate to new 'set-state' interface
    
    Migrate netx driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    We aren't writing zero twice on the control register for shutdown or
    resume state now.
    
    Cc: Russell King <linux@arm.linux.org.uk>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>

commit a785fb39e1b7070da5d53a7d09b140c80c31974e
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Feb 27 13:39:52 2015 +0530

    ARM/mmp/time: Migrate to new 'set-state' interface
    
    Migrate mmp driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    We weren't doing anything in set_mode(RESUME) except of
    local_irq_{save|restore}(), which isn't required and so ->tick_resume
    isn't implemented.
    
    Cc: Eric Miao <eric.y.miao@gmail.com>
    Cc: Haojian Zhuang <haojian.zhuang@gmail.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>

commit 9325a3a896b611454f6ab3dcedf69c5799dd5617
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Feb 27 13:39:52 2015 +0530

    ARM/lpc32xx/timer: Migrate to new 'set-state' interface
    
    Migrate lpc32xx driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    Cc: Roland Stigge <stigge@antcom.de>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>

commit 7cfa3c69ca97acfd7cac19652d82aa610015bab8
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Feb 27 13:39:52 2015 +0530

    ARM/ks8695/time: Migrate to new 'set-state' interface
    
    Migrate ks8695 driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    There is nothing to be done for oneshot or shutdown states and so are
    not implemented.
    
    Acked-by: Greg Ungerer <gerg@uclinux.org>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>

commit cea50eeef15c8498181c4a1ff804a7cdef29aebb
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Feb 27 13:39:52 2015 +0530

    ARM/ixp4xx/timer: Migrate to new 'set-state' interface
    
    Migrate ixp4xx driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    NOTE: ixp4xx_set_{oneshot|periodic} don't perform read operation on
    'IXP4XX_OSRT1' register anymore.
    
    Cc: Imre Kaloz <kaloz@openwrt.org>
    Acked-by: Krzysztof Haasa <khalasa@piap.pl>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>

commit 3200579fafb0400cd098e939ec664638d38e2bc9
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Feb 27 13:39:52 2015 +0530

    ARM/imx/epit: Migrate to new 'set-state' interface
    
    Migrate imx driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    Also drop 'clockevent_mode': It was caching the last state of the
    clockevent device. The same behavior can be achieved by using
    clockevents state helpers. These helpers are only required for oneshot
    mode as shutdown/resume wouldn't be done twice by the core.
    
    Cc: Shawn Guo <shawnguo@kernel.org>
    Cc: Sascha Hauer <kernel@pengutronix.de>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>

commit e2efda24804234c83e17172a2525641dd6b690bc
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Feb 27 13:39:52 2015 +0530

    ARM/gemini/time: Migrate to new 'set-state' interface
    
    Migrate gemini driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    Acked-by: Hans Ulli Kroll <ulli.kroll@googlemail.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>

commit 947d9cf53f5c9c4dfbbffe68f07dd4d02da2093d
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Feb 27 13:39:52 2015 +0530

    ARM/dc21285-timer: Migrate to new 'set-state' interface
    
    Migrate footbridge driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    Cc: Russell King <linux@arm.linux.org.uk>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>

commit bc660a454f7899f21f2106be1a16e8d006dd2dba
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Feb 27 13:39:52 2015 +0530

    ARM/davinci/time: Migrate to new 'set-state' interface
    
    Migrate davinci driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    We weren't doing anything in set_mode(RESUME) and so .tick_resume()
    isn't implemented.
    
    Cc: Sekhar Nori <nsekhar@ti.com>
    Cc: Kevin Hilman <khilman@deeprootsystems.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>

commit 9bdc2e0c9a45b2b5f4de9927562305475ecb9b55
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Feb 27 13:39:52 2015 +0530

    ARM/cns3xxx/timer: Migrate to new 'set-state' interface
    
    Migrate cns3xxx driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    NOTE: We don't read TIMER1_2_CONTROL_OFFSET register on shutdown
    anymore.
    
    Acked-by: Krzysztof Haasa <khalasa@piap.pl>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>

commit 5e2535710ee3fa2807406ea75eb4381f85b29b0b
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Feb 27 13:39:52 2015 +0530

    ARM/smp_twd: Migrate to new 'set-state' interface
    
    Migrate smp_twd driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    Cc: Russell King <linux@arm.linux.org.uk>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>

commit 7b732169e9d1f0f6614a8e85a9e65a9d755b3d86
Merge: c4bc680cf7bc c4d029f2d43b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Jul 12 09:36:59 2015 -0700

    Merge branch 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer fixes from Thomas Gleixner:
     "This update from the timer departement contains:
    
       - A series of patches which address a shortcoming in the tick
         broadcast code.
    
         If the broadcast device is not available or an hrtimer emulated
         broadcast device, some of the original assumptions lead to boot
         failures.  I rather plugged all of the corner cases instead of only
         addressing the issue reported, so the change got a little larger.
    
         Has been extensivly tested on x86 and arm.
    
       - Get rid of the last holdouts using do_posix_clock_monotonic_gettime()
    
       - A regression fix for the imx clocksource driver
    
       - An update to the new state callbacks mechanism for clockevents.
         This is required to simplify the conversion, which will take place
         in 4.3"
    
    * 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      tick/broadcast: Prevent NULL pointer dereference
      time: Get rid of do_posix_clock_monotonic_gettime
      cris: Replace do_posix_clock_monotonic_gettime()
      tick/broadcast: Unbreak CONFIG_GENERIC_CLOCKEVENTS=n build
      tick/broadcast: Handle spurious interrupts gracefully
      tick/broadcast: Check for hrtimer broadcast active early
      tick/broadcast: Return busy when IPI is pending
      tick/broadcast: Return busy if periodic mode and hrtimer broadcast
      tick/broadcast: Move the check for periodic mode inside state handling
      tick/broadcast: Prevent deep idle if no broadcast device available
      tick/broadcast: Make idle check independent from mode and config
      tick/broadcast: Sanity check the shutdown of the local clock_event
      tick/broadcast: Prevent hrtimer recursion
      clockevents: Allow set-state callbacks to be optional
      clocksource/imx: Define clocksource for mx27

commit 59a460c394a771501ffcd81e68c83fa2ed91e384
Author: Alexander Sverdlin <alexander.sverdlin@nokia.com>
Date:   Mon Jun 29 10:41:03 2015 +0200

    sctp: Fix race between OOTB responce and route removal
    
    [ Upstream commit 29c4afc4e98f4dc0ea9df22c631841f9c220b944 ]
    
    There is NULL pointer dereference possible during statistics update if the route
    used for OOTB responce is removed at unfortunate time. If the route exists when
    we receive OOTB packet and we finally jump into sctp_packet_transmit() to send
    ABORT, but in the meantime route is removed under our feet, we take "no_route"
    path and try to update stats with IP_INC_STATS(sock_net(asoc->base.sk), ...).
    
    But sctp_ootb_pkt_new() used to prepare responce packet doesn't call
    sctp_transport_set_owner() and therefore there is no asoc associated with this
    packet. Probably temporary asoc just for OOTB responces is overkill, so just
    introduce a check like in all other places in sctp_packet_transmit(), where
    "asoc" is dereferenced.
    
    To reproduce this, one needs to
    0. ensure that sctp module is loaded (otherwise ABORT is not generated)
    1. remove default route on the machine
    2. while true; do
         ip route del [interface-specific route]
         ip route add [interface-specific route]
       done
    3. send enough OOTB packets (i.e. HB REQs) from another host to trigger ABORT
       responce
    
    On x86_64 the crash looks like this:
    
    BUG: unable to handle kernel NULL pointer dereference at 0000000000000020
    IP: [<ffffffffa05ec9ac>] sctp_packet_transmit+0x63c/0x730 [sctp]
    PGD 0
    Oops: 0000 [#1] PREEMPT SMP
    Modules linked in: ...
    CPU: 0 PID: 0 Comm: swapper/0 Tainted: G           O    4.0.5-1-ARCH #1
    Hardware name: ...
    task: ffffffff818124c0 ti: ffffffff81800000 task.ti: ffffffff81800000
    RIP: 0010:[<ffffffffa05ec9ac>]  [<ffffffffa05ec9ac>] sctp_packet_transmit+0x63c/0x730 [sctp]
    RSP: 0018:ffff880127c037b8  EFLAGS: 00010296
    RAX: 0000000000000000 RBX: 0000000000000000 RCX: 00000015ff66b480
    RDX: 00000015ff66b400 RSI: ffff880127c17200 RDI: ffff880123403700
    RBP: ffff880127c03888 R08: 0000000000017200 R09: ffffffff814625af
    R10: ffffea00047e4680 R11: 00000000ffffff80 R12: ffff8800b0d38a28
    R13: ffff8800b0d38a28 R14: ffff8800b3e88000 R15: ffffffffa05f24e0
    FS:  0000000000000000(0000) GS:ffff880127c00000(0000) knlGS:0000000000000000
    CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b
    CR2: 0000000000000020 CR3: 00000000c855b000 CR4: 00000000000007f0
    Stack:
     ffff880127c03910 ffff8800b0d38a28 ffffffff8189d240 ffff88011f91b400
     ffff880127c03828 ffffffffa05c94c5 0000000000000000 ffff8800baa1c520
     0000000000000000 0000000000000001 0000000000000000 0000000000000000
    Call Trace:
     <IRQ>
     [<ffffffffa05c94c5>] ? sctp_sf_tabort_8_4_8.isra.20+0x85/0x140 [sctp]
     [<ffffffffa05d6b42>] ? sctp_transport_put+0x52/0x80 [sctp]
     [<ffffffffa05d0bfc>] sctp_do_sm+0xb8c/0x19a0 [sctp]
     [<ffffffff810b0e00>] ? trigger_load_balance+0x90/0x210
     [<ffffffff810e0329>] ? update_process_times+0x59/0x60
     [<ffffffff812c7a40>] ? timerqueue_add+0x60/0xb0
     [<ffffffff810e0549>] ? enqueue_hrtimer+0x29/0xa0
     [<ffffffff8101f599>] ? read_tsc+0x9/0x10
     [<ffffffff8116d4b5>] ? put_page+0x55/0x60
     [<ffffffff810ee1ad>] ? clockevents_program_event+0x6d/0x100
     [<ffffffff81462b68>] ? skb_free_head+0x58/0x80
     [<ffffffffa029a10b>] ? chksum_update+0x1b/0x27 [crc32c_generic]
     [<ffffffff81283f3e>] ? crypto_shash_update+0xce/0xf0
     [<ffffffffa05d3993>] sctp_endpoint_bh_rcv+0x113/0x280 [sctp]
     [<ffffffffa05dd4e6>] sctp_inq_push+0x46/0x60 [sctp]
     [<ffffffffa05ed7a0>] sctp_rcv+0x880/0x910 [sctp]
     [<ffffffffa05ecb50>] ? sctp_packet_transmit_chunk+0xb0/0xb0 [sctp]
     [<ffffffffa05ecb70>] ? sctp_csum_update+0x20/0x20 [sctp]
     [<ffffffff814b05a5>] ? ip_route_input_noref+0x235/0xd30
     [<ffffffff81051d6b>] ? ack_ioapic_level+0x7b/0x150
     [<ffffffff814b27be>] ip_local_deliver_finish+0xae/0x210
     [<ffffffff814b2e15>] ip_local_deliver+0x35/0x90
     [<ffffffff814b2a15>] ip_rcv_finish+0xf5/0x370
     [<ffffffff814b3128>] ip_rcv+0x2b8/0x3a0
     [<ffffffff81474193>] __netif_receive_skb_core+0x763/0xa50
     [<ffffffff81476c28>] __netif_receive_skb+0x18/0x60
     [<ffffffff81476cb0>] netif_receive_skb_internal+0x40/0xd0
     [<ffffffff814776c8>] napi_gro_receive+0xe8/0x120
     [<ffffffffa03946aa>] rtl8169_poll+0x2da/0x660 [r8169]
     [<ffffffff8147896a>] net_rx_action+0x21a/0x360
     [<ffffffff81078dc1>] __do_softirq+0xe1/0x2d0
     [<ffffffff8107912d>] irq_exit+0xad/0xb0
     [<ffffffff8157d158>] do_IRQ+0x58/0xf0
     [<ffffffff8157b06d>] common_interrupt+0x6d/0x6d
     <EOI>
     [<ffffffff810e1218>] ? hrtimer_start+0x18/0x20
     [<ffffffffa05d65f9>] ? sctp_transport_destroy_rcu+0x29/0x30 [sctp]
     [<ffffffff81020c50>] ? mwait_idle+0x60/0xa0
     [<ffffffff810216ef>] arch_cpu_idle+0xf/0x20
     [<ffffffff810b731c>] cpu_startup_entry+0x3ec/0x480
     [<ffffffff8156b365>] rest_init+0x85/0x90
     [<ffffffff818eb035>] start_kernel+0x48b/0x4ac
     [<ffffffff818ea120>] ? early_idt_handlers+0x120/0x120
     [<ffffffff818ea339>] x86_64_start_reservations+0x2a/0x2c
     [<ffffffff818ea49c>] x86_64_start_kernel+0x161/0x184
    Code: 90 48 8b 80 b8 00 00 00 48 89 85 70 ff ff ff 48 83 bd 70 ff ff ff 00 0f 85 cd fa ff ff 48 89 df 31 db e8 18 63 e7 e0 48 8b 45 80 <48> 8b 40 20 48 8b 40 30 48 8b 80 68 01 00 00 65 48 ff 40 78 e9
    RIP  [<ffffffffa05ec9ac>] sctp_packet_transmit+0x63c/0x730 [sctp]
     RSP <ffff880127c037b8>
    CR2: 0000000000000020
    ---[ end trace 5aec7fd2dc983574 ]---
    Kernel panic - not syncing: Fatal exception in interrupt
    Kernel Offset: 0x0 from 0xffffffff81000000 (relocation range: 0xffffffff80000000-0xffffffff9fffffff)
    drm_kms_helper: panic occurred, switching back to text console
    ---[ end Kernel panic - not syncing: Fatal exception in interrupt
    
    Signed-off-by: Alexander Sverdlin <alexander.sverdlin@nokia.com>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Acked-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Acked-by: Vlad Yasevich <vyasevich@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit ab65d27cc4af1b2e72da2d9d098edcec99e491c6
Author: Alexander Sverdlin <alexander.sverdlin@nokia.com>
Date:   Mon Jun 29 10:41:03 2015 +0200

    sctp: Fix race between OOTB responce and route removal
    
    [ Upstream commit 29c4afc4e98f4dc0ea9df22c631841f9c220b944 ]
    
    There is NULL pointer dereference possible during statistics update if the route
    used for OOTB responce is removed at unfortunate time. If the route exists when
    we receive OOTB packet and we finally jump into sctp_packet_transmit() to send
    ABORT, but in the meantime route is removed under our feet, we take "no_route"
    path and try to update stats with IP_INC_STATS(sock_net(asoc->base.sk), ...).
    
    But sctp_ootb_pkt_new() used to prepare responce packet doesn't call
    sctp_transport_set_owner() and therefore there is no asoc associated with this
    packet. Probably temporary asoc just for OOTB responces is overkill, so just
    introduce a check like in all other places in sctp_packet_transmit(), where
    "asoc" is dereferenced.
    
    To reproduce this, one needs to
    0. ensure that sctp module is loaded (otherwise ABORT is not generated)
    1. remove default route on the machine
    2. while true; do
         ip route del [interface-specific route]
         ip route add [interface-specific route]
       done
    3. send enough OOTB packets (i.e. HB REQs) from another host to trigger ABORT
       responce
    
    On x86_64 the crash looks like this:
    
    BUG: unable to handle kernel NULL pointer dereference at 0000000000000020
    IP: [<ffffffffa05ec9ac>] sctp_packet_transmit+0x63c/0x730 [sctp]
    PGD 0
    Oops: 0000 [#1] PREEMPT SMP
    Modules linked in: ...
    CPU: 0 PID: 0 Comm: swapper/0 Tainted: G           O    4.0.5-1-ARCH #1
    Hardware name: ...
    task: ffffffff818124c0 ti: ffffffff81800000 task.ti: ffffffff81800000
    RIP: 0010:[<ffffffffa05ec9ac>]  [<ffffffffa05ec9ac>] sctp_packet_transmit+0x63c/0x730 [sctp]
    RSP: 0018:ffff880127c037b8  EFLAGS: 00010296
    RAX: 0000000000000000 RBX: 0000000000000000 RCX: 00000015ff66b480
    RDX: 00000015ff66b400 RSI: ffff880127c17200 RDI: ffff880123403700
    RBP: ffff880127c03888 R08: 0000000000017200 R09: ffffffff814625af
    R10: ffffea00047e4680 R11: 00000000ffffff80 R12: ffff8800b0d38a28
    R13: ffff8800b0d38a28 R14: ffff8800b3e88000 R15: ffffffffa05f24e0
    FS:  0000000000000000(0000) GS:ffff880127c00000(0000) knlGS:0000000000000000
    CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b
    CR2: 0000000000000020 CR3: 00000000c855b000 CR4: 00000000000007f0
    Stack:
     ffff880127c03910 ffff8800b0d38a28 ffffffff8189d240 ffff88011f91b400
     ffff880127c03828 ffffffffa05c94c5 0000000000000000 ffff8800baa1c520
     0000000000000000 0000000000000001 0000000000000000 0000000000000000
    Call Trace:
     <IRQ>
     [<ffffffffa05c94c5>] ? sctp_sf_tabort_8_4_8.isra.20+0x85/0x140 [sctp]
     [<ffffffffa05d6b42>] ? sctp_transport_put+0x52/0x80 [sctp]
     [<ffffffffa05d0bfc>] sctp_do_sm+0xb8c/0x19a0 [sctp]
     [<ffffffff810b0e00>] ? trigger_load_balance+0x90/0x210
     [<ffffffff810e0329>] ? update_process_times+0x59/0x60
     [<ffffffff812c7a40>] ? timerqueue_add+0x60/0xb0
     [<ffffffff810e0549>] ? enqueue_hrtimer+0x29/0xa0
     [<ffffffff8101f599>] ? read_tsc+0x9/0x10
     [<ffffffff8116d4b5>] ? put_page+0x55/0x60
     [<ffffffff810ee1ad>] ? clockevents_program_event+0x6d/0x100
     [<ffffffff81462b68>] ? skb_free_head+0x58/0x80
     [<ffffffffa029a10b>] ? chksum_update+0x1b/0x27 [crc32c_generic]
     [<ffffffff81283f3e>] ? crypto_shash_update+0xce/0xf0
     [<ffffffffa05d3993>] sctp_endpoint_bh_rcv+0x113/0x280 [sctp]
     [<ffffffffa05dd4e6>] sctp_inq_push+0x46/0x60 [sctp]
     [<ffffffffa05ed7a0>] sctp_rcv+0x880/0x910 [sctp]
     [<ffffffffa05ecb50>] ? sctp_packet_transmit_chunk+0xb0/0xb0 [sctp]
     [<ffffffffa05ecb70>] ? sctp_csum_update+0x20/0x20 [sctp]
     [<ffffffff814b05a5>] ? ip_route_input_noref+0x235/0xd30
     [<ffffffff81051d6b>] ? ack_ioapic_level+0x7b/0x150
     [<ffffffff814b27be>] ip_local_deliver_finish+0xae/0x210
     [<ffffffff814b2e15>] ip_local_deliver+0x35/0x90
     [<ffffffff814b2a15>] ip_rcv_finish+0xf5/0x370
     [<ffffffff814b3128>] ip_rcv+0x2b8/0x3a0
     [<ffffffff81474193>] __netif_receive_skb_core+0x763/0xa50
     [<ffffffff81476c28>] __netif_receive_skb+0x18/0x60
     [<ffffffff81476cb0>] netif_receive_skb_internal+0x40/0xd0
     [<ffffffff814776c8>] napi_gro_receive+0xe8/0x120
     [<ffffffffa03946aa>] rtl8169_poll+0x2da/0x660 [r8169]
     [<ffffffff8147896a>] net_rx_action+0x21a/0x360
     [<ffffffff81078dc1>] __do_softirq+0xe1/0x2d0
     [<ffffffff8107912d>] irq_exit+0xad/0xb0
     [<ffffffff8157d158>] do_IRQ+0x58/0xf0
     [<ffffffff8157b06d>] common_interrupt+0x6d/0x6d
     <EOI>
     [<ffffffff810e1218>] ? hrtimer_start+0x18/0x20
     [<ffffffffa05d65f9>] ? sctp_transport_destroy_rcu+0x29/0x30 [sctp]
     [<ffffffff81020c50>] ? mwait_idle+0x60/0xa0
     [<ffffffff810216ef>] arch_cpu_idle+0xf/0x20
     [<ffffffff810b731c>] cpu_startup_entry+0x3ec/0x480
     [<ffffffff8156b365>] rest_init+0x85/0x90
     [<ffffffff818eb035>] start_kernel+0x48b/0x4ac
     [<ffffffff818ea120>] ? early_idt_handlers+0x120/0x120
     [<ffffffff818ea339>] x86_64_start_reservations+0x2a/0x2c
     [<ffffffff818ea49c>] x86_64_start_kernel+0x161/0x184
    Code: 90 48 8b 80 b8 00 00 00 48 89 85 70 ff ff ff 48 83 bd 70 ff ff ff 00 0f 85 cd fa ff ff 48 89 df 31 db e8 18 63 e7 e0 48 8b 45 80 <48> 8b 40 20 48 8b 40 30 48 8b 80 68 01 00 00 65 48 ff 40 78 e9
    RIP  [<ffffffffa05ec9ac>] sctp_packet_transmit+0x63c/0x730 [sctp]
     RSP <ffff880127c037b8>
    CR2: 0000000000000020
    ---[ end trace 5aec7fd2dc983574 ]---
    Kernel panic - not syncing: Fatal exception in interrupt
    Kernel Offset: 0x0 from 0xffffffff81000000 (relocation range: 0xffffffff80000000-0xffffffff9fffffff)
    drm_kms_helper: panic occurred, switching back to text console
    ---[ end Kernel panic - not syncing: Fatal exception in interrupt
    
    Signed-off-by: Alexander Sverdlin <alexander.sverdlin@nokia.com>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Acked-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Acked-by: Vlad Yasevich <vyasevich@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 67866a8c30f4707cef895635d5d08cb8105d2f5e
Author: Alexander Sverdlin <alexander.sverdlin@nokia.com>
Date:   Mon Jun 29 10:41:03 2015 +0200

    sctp: Fix race between OOTB responce and route removal
    
    [ Upstream commit 29c4afc4e98f4dc0ea9df22c631841f9c220b944 ]
    
    There is NULL pointer dereference possible during statistics update if the route
    used for OOTB responce is removed at unfortunate time. If the route exists when
    we receive OOTB packet and we finally jump into sctp_packet_transmit() to send
    ABORT, but in the meantime route is removed under our feet, we take "no_route"
    path and try to update stats with IP_INC_STATS(sock_net(asoc->base.sk), ...).
    
    But sctp_ootb_pkt_new() used to prepare responce packet doesn't call
    sctp_transport_set_owner() and therefore there is no asoc associated with this
    packet. Probably temporary asoc just for OOTB responces is overkill, so just
    introduce a check like in all other places in sctp_packet_transmit(), where
    "asoc" is dereferenced.
    
    To reproduce this, one needs to
    0. ensure that sctp module is loaded (otherwise ABORT is not generated)
    1. remove default route on the machine
    2. while true; do
         ip route del [interface-specific route]
         ip route add [interface-specific route]
       done
    3. send enough OOTB packets (i.e. HB REQs) from another host to trigger ABORT
       responce
    
    On x86_64 the crash looks like this:
    
    BUG: unable to handle kernel NULL pointer dereference at 0000000000000020
    IP: [<ffffffffa05ec9ac>] sctp_packet_transmit+0x63c/0x730 [sctp]
    PGD 0
    Oops: 0000 [#1] PREEMPT SMP
    Modules linked in: ...
    CPU: 0 PID: 0 Comm: swapper/0 Tainted: G           O    4.0.5-1-ARCH #1
    Hardware name: ...
    task: ffffffff818124c0 ti: ffffffff81800000 task.ti: ffffffff81800000
    RIP: 0010:[<ffffffffa05ec9ac>]  [<ffffffffa05ec9ac>] sctp_packet_transmit+0x63c/0x730 [sctp]
    RSP: 0018:ffff880127c037b8  EFLAGS: 00010296
    RAX: 0000000000000000 RBX: 0000000000000000 RCX: 00000015ff66b480
    RDX: 00000015ff66b400 RSI: ffff880127c17200 RDI: ffff880123403700
    RBP: ffff880127c03888 R08: 0000000000017200 R09: ffffffff814625af
    R10: ffffea00047e4680 R11: 00000000ffffff80 R12: ffff8800b0d38a28
    R13: ffff8800b0d38a28 R14: ffff8800b3e88000 R15: ffffffffa05f24e0
    FS:  0000000000000000(0000) GS:ffff880127c00000(0000) knlGS:0000000000000000
    CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b
    CR2: 0000000000000020 CR3: 00000000c855b000 CR4: 00000000000007f0
    Stack:
     ffff880127c03910 ffff8800b0d38a28 ffffffff8189d240 ffff88011f91b400
     ffff880127c03828 ffffffffa05c94c5 0000000000000000 ffff8800baa1c520
     0000000000000000 0000000000000001 0000000000000000 0000000000000000
    Call Trace:
     <IRQ>
     [<ffffffffa05c94c5>] ? sctp_sf_tabort_8_4_8.isra.20+0x85/0x140 [sctp]
     [<ffffffffa05d6b42>] ? sctp_transport_put+0x52/0x80 [sctp]
     [<ffffffffa05d0bfc>] sctp_do_sm+0xb8c/0x19a0 [sctp]
     [<ffffffff810b0e00>] ? trigger_load_balance+0x90/0x210
     [<ffffffff810e0329>] ? update_process_times+0x59/0x60
     [<ffffffff812c7a40>] ? timerqueue_add+0x60/0xb0
     [<ffffffff810e0549>] ? enqueue_hrtimer+0x29/0xa0
     [<ffffffff8101f599>] ? read_tsc+0x9/0x10
     [<ffffffff8116d4b5>] ? put_page+0x55/0x60
     [<ffffffff810ee1ad>] ? clockevents_program_event+0x6d/0x100
     [<ffffffff81462b68>] ? skb_free_head+0x58/0x80
     [<ffffffffa029a10b>] ? chksum_update+0x1b/0x27 [crc32c_generic]
     [<ffffffff81283f3e>] ? crypto_shash_update+0xce/0xf0
     [<ffffffffa05d3993>] sctp_endpoint_bh_rcv+0x113/0x280 [sctp]
     [<ffffffffa05dd4e6>] sctp_inq_push+0x46/0x60 [sctp]
     [<ffffffffa05ed7a0>] sctp_rcv+0x880/0x910 [sctp]
     [<ffffffffa05ecb50>] ? sctp_packet_transmit_chunk+0xb0/0xb0 [sctp]
     [<ffffffffa05ecb70>] ? sctp_csum_update+0x20/0x20 [sctp]
     [<ffffffff814b05a5>] ? ip_route_input_noref+0x235/0xd30
     [<ffffffff81051d6b>] ? ack_ioapic_level+0x7b/0x150
     [<ffffffff814b27be>] ip_local_deliver_finish+0xae/0x210
     [<ffffffff814b2e15>] ip_local_deliver+0x35/0x90
     [<ffffffff814b2a15>] ip_rcv_finish+0xf5/0x370
     [<ffffffff814b3128>] ip_rcv+0x2b8/0x3a0
     [<ffffffff81474193>] __netif_receive_skb_core+0x763/0xa50
     [<ffffffff81476c28>] __netif_receive_skb+0x18/0x60
     [<ffffffff81476cb0>] netif_receive_skb_internal+0x40/0xd0
     [<ffffffff814776c8>] napi_gro_receive+0xe8/0x120
     [<ffffffffa03946aa>] rtl8169_poll+0x2da/0x660 [r8169]
     [<ffffffff8147896a>] net_rx_action+0x21a/0x360
     [<ffffffff81078dc1>] __do_softirq+0xe1/0x2d0
     [<ffffffff8107912d>] irq_exit+0xad/0xb0
     [<ffffffff8157d158>] do_IRQ+0x58/0xf0
     [<ffffffff8157b06d>] common_interrupt+0x6d/0x6d
     <EOI>
     [<ffffffff810e1218>] ? hrtimer_start+0x18/0x20
     [<ffffffffa05d65f9>] ? sctp_transport_destroy_rcu+0x29/0x30 [sctp]
     [<ffffffff81020c50>] ? mwait_idle+0x60/0xa0
     [<ffffffff810216ef>] arch_cpu_idle+0xf/0x20
     [<ffffffff810b731c>] cpu_startup_entry+0x3ec/0x480
     [<ffffffff8156b365>] rest_init+0x85/0x90
     [<ffffffff818eb035>] start_kernel+0x48b/0x4ac
     [<ffffffff818ea120>] ? early_idt_handlers+0x120/0x120
     [<ffffffff818ea339>] x86_64_start_reservations+0x2a/0x2c
     [<ffffffff818ea49c>] x86_64_start_kernel+0x161/0x184
    Code: 90 48 8b 80 b8 00 00 00 48 89 85 70 ff ff ff 48 83 bd 70 ff ff ff 00 0f 85 cd fa ff ff 48 89 df 31 db e8 18 63 e7 e0 48 8b 45 80 <48> 8b 40 20 48 8b 40 30 48 8b 80 68 01 00 00 65 48 ff 40 78 e9
    RIP  [<ffffffffa05ec9ac>] sctp_packet_transmit+0x63c/0x730 [sctp]
     RSP <ffff880127c037b8>
    CR2: 0000000000000020
    ---[ end trace 5aec7fd2dc983574 ]---
    Kernel panic - not syncing: Fatal exception in interrupt
    Kernel Offset: 0x0 from 0xffffffff81000000 (relocation range: 0xffffffff80000000-0xffffffff9fffffff)
    drm_kms_helper: panic occurred, switching back to text console
    ---[ end Kernel panic - not syncing: Fatal exception in interrupt
    
    Signed-off-by: Alexander Sverdlin <alexander.sverdlin@nokia.com>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Acked-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Acked-by: Vlad Yasevich <vyasevich@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit be9b655ce54b1d4fc9ea70790c426750e12a260e
Author: Alexander Sverdlin <alexander.sverdlin@nokia.com>
Date:   Mon Jun 29 10:41:03 2015 +0200

    sctp: Fix race between OOTB responce and route removal
    
    [ Upstream commit 29c4afc4e98f4dc0ea9df22c631841f9c220b944 ]
    
    There is NULL pointer dereference possible during statistics update if the route
    used for OOTB responce is removed at unfortunate time. If the route exists when
    we receive OOTB packet and we finally jump into sctp_packet_transmit() to send
    ABORT, but in the meantime route is removed under our feet, we take "no_route"
    path and try to update stats with IP_INC_STATS(sock_net(asoc->base.sk), ...).
    
    But sctp_ootb_pkt_new() used to prepare responce packet doesn't call
    sctp_transport_set_owner() and therefore there is no asoc associated with this
    packet. Probably temporary asoc just for OOTB responces is overkill, so just
    introduce a check like in all other places in sctp_packet_transmit(), where
    "asoc" is dereferenced.
    
    To reproduce this, one needs to
    0. ensure that sctp module is loaded (otherwise ABORT is not generated)
    1. remove default route on the machine
    2. while true; do
         ip route del [interface-specific route]
         ip route add [interface-specific route]
       done
    3. send enough OOTB packets (i.e. HB REQs) from another host to trigger ABORT
       responce
    
    On x86_64 the crash looks like this:
    
    BUG: unable to handle kernel NULL pointer dereference at 0000000000000020
    IP: [<ffffffffa05ec9ac>] sctp_packet_transmit+0x63c/0x730 [sctp]
    PGD 0
    Oops: 0000 [#1] PREEMPT SMP
    Modules linked in: ...
    CPU: 0 PID: 0 Comm: swapper/0 Tainted: G           O    4.0.5-1-ARCH #1
    Hardware name: ...
    task: ffffffff818124c0 ti: ffffffff81800000 task.ti: ffffffff81800000
    RIP: 0010:[<ffffffffa05ec9ac>]  [<ffffffffa05ec9ac>] sctp_packet_transmit+0x63c/0x730 [sctp]
    RSP: 0018:ffff880127c037b8  EFLAGS: 00010296
    RAX: 0000000000000000 RBX: 0000000000000000 RCX: 00000015ff66b480
    RDX: 00000015ff66b400 RSI: ffff880127c17200 RDI: ffff880123403700
    RBP: ffff880127c03888 R08: 0000000000017200 R09: ffffffff814625af
    R10: ffffea00047e4680 R11: 00000000ffffff80 R12: ffff8800b0d38a28
    R13: ffff8800b0d38a28 R14: ffff8800b3e88000 R15: ffffffffa05f24e0
    FS:  0000000000000000(0000) GS:ffff880127c00000(0000) knlGS:0000000000000000
    CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b
    CR2: 0000000000000020 CR3: 00000000c855b000 CR4: 00000000000007f0
    Stack:
     ffff880127c03910 ffff8800b0d38a28 ffffffff8189d240 ffff88011f91b400
     ffff880127c03828 ffffffffa05c94c5 0000000000000000 ffff8800baa1c520
     0000000000000000 0000000000000001 0000000000000000 0000000000000000
    Call Trace:
     <IRQ>
     [<ffffffffa05c94c5>] ? sctp_sf_tabort_8_4_8.isra.20+0x85/0x140 [sctp]
     [<ffffffffa05d6b42>] ? sctp_transport_put+0x52/0x80 [sctp]
     [<ffffffffa05d0bfc>] sctp_do_sm+0xb8c/0x19a0 [sctp]
     [<ffffffff810b0e00>] ? trigger_load_balance+0x90/0x210
     [<ffffffff810e0329>] ? update_process_times+0x59/0x60
     [<ffffffff812c7a40>] ? timerqueue_add+0x60/0xb0
     [<ffffffff810e0549>] ? enqueue_hrtimer+0x29/0xa0
     [<ffffffff8101f599>] ? read_tsc+0x9/0x10
     [<ffffffff8116d4b5>] ? put_page+0x55/0x60
     [<ffffffff810ee1ad>] ? clockevents_program_event+0x6d/0x100
     [<ffffffff81462b68>] ? skb_free_head+0x58/0x80
     [<ffffffffa029a10b>] ? chksum_update+0x1b/0x27 [crc32c_generic]
     [<ffffffff81283f3e>] ? crypto_shash_update+0xce/0xf0
     [<ffffffffa05d3993>] sctp_endpoint_bh_rcv+0x113/0x280 [sctp]
     [<ffffffffa05dd4e6>] sctp_inq_push+0x46/0x60 [sctp]
     [<ffffffffa05ed7a0>] sctp_rcv+0x880/0x910 [sctp]
     [<ffffffffa05ecb50>] ? sctp_packet_transmit_chunk+0xb0/0xb0 [sctp]
     [<ffffffffa05ecb70>] ? sctp_csum_update+0x20/0x20 [sctp]
     [<ffffffff814b05a5>] ? ip_route_input_noref+0x235/0xd30
     [<ffffffff81051d6b>] ? ack_ioapic_level+0x7b/0x150
     [<ffffffff814b27be>] ip_local_deliver_finish+0xae/0x210
     [<ffffffff814b2e15>] ip_local_deliver+0x35/0x90
     [<ffffffff814b2a15>] ip_rcv_finish+0xf5/0x370
     [<ffffffff814b3128>] ip_rcv+0x2b8/0x3a0
     [<ffffffff81474193>] __netif_receive_skb_core+0x763/0xa50
     [<ffffffff81476c28>] __netif_receive_skb+0x18/0x60
     [<ffffffff81476cb0>] netif_receive_skb_internal+0x40/0xd0
     [<ffffffff814776c8>] napi_gro_receive+0xe8/0x120
     [<ffffffffa03946aa>] rtl8169_poll+0x2da/0x660 [r8169]
     [<ffffffff8147896a>] net_rx_action+0x21a/0x360
     [<ffffffff81078dc1>] __do_softirq+0xe1/0x2d0
     [<ffffffff8107912d>] irq_exit+0xad/0xb0
     [<ffffffff8157d158>] do_IRQ+0x58/0xf0
     [<ffffffff8157b06d>] common_interrupt+0x6d/0x6d
     <EOI>
     [<ffffffff810e1218>] ? hrtimer_start+0x18/0x20
     [<ffffffffa05d65f9>] ? sctp_transport_destroy_rcu+0x29/0x30 [sctp]
     [<ffffffff81020c50>] ? mwait_idle+0x60/0xa0
     [<ffffffff810216ef>] arch_cpu_idle+0xf/0x20
     [<ffffffff810b731c>] cpu_startup_entry+0x3ec/0x480
     [<ffffffff8156b365>] rest_init+0x85/0x90
     [<ffffffff818eb035>] start_kernel+0x48b/0x4ac
     [<ffffffff818ea120>] ? early_idt_handlers+0x120/0x120
     [<ffffffff818ea339>] x86_64_start_reservations+0x2a/0x2c
     [<ffffffff818ea49c>] x86_64_start_kernel+0x161/0x184
    Code: 90 48 8b 80 b8 00 00 00 48 89 85 70 ff ff ff 48 83 bd 70 ff ff ff 00 0f 85 cd fa ff ff 48 89 df 31 db e8 18 63 e7 e0 48 8b 45 80 <48> 8b 40 20 48 8b 40 30 48 8b 80 68 01 00 00 65 48 ff 40 78 e9
    RIP  [<ffffffffa05ec9ac>] sctp_packet_transmit+0x63c/0x730 [sctp]
     RSP <ffff880127c037b8>
    CR2: 0000000000000020
    ---[ end trace 5aec7fd2dc983574 ]---
    Kernel panic - not syncing: Fatal exception in interrupt
    Kernel Offset: 0x0 from 0xffffffff81000000 (relocation range: 0xffffffff80000000-0xffffffff9fffffff)
    drm_kms_helper: panic occurred, switching back to text console
    ---[ end Kernel panic - not syncing: Fatal exception in interrupt
    
    Signed-off-by: Alexander Sverdlin <alexander.sverdlin@nokia.com>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Acked-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Acked-by: Vlad Yasevich <vyasevich@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit c4288334818c81c946acb23d2319881f58c3d497
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun Jul 5 20:53:17 2015 +0000

    tick/broadcast: Handle spurious interrupts gracefully
    
    Andriy reported that on a virtual machine the warning about negative
    expiry time in the clock events programming code triggered:
    
    hpet: hpet0 irq 40 for MSI
    hpet: hpet1 irq 41 for MSI
    Switching to clocksource hpet
    WARNING: at kernel/time/clockevents.c:239
    
    [<ffffffff810ce6eb>] clockevents_program_event+0xdb/0xf0
    [<ffffffff810cf211>] tick_handle_periodic_broadcast+0x41/0x50
    [<ffffffff81016525>] timer_interrupt+0x15/0x20
    
    When the second hpet is installed as a per cpu timer the broadcast
    event is not longer required and stopped, which sets the next_evt of
    the broadcast device to KTIME_MAX.
    
    If after that a spurious interrupt happens on the broadcast device,
    then the current code blindly handles it and tries to reprogram the
    broadcast device afterwards, which adds the period to
    next_evt. KTIME_MAX + period results in a negative expiry value
    causing the WARN_ON in the clockevents code to trigger.
    
    Add a proper check for the state of the broadcast device into the
    interrupt handler and return if the interrupt is spurious.
    
    [ Folded in pointer fix from Sudeep ]
    
    Reported-by: Andriy Gapon <avg@FreeBSD.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Sudeep Holla <sudeep.holla@arm.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Preeti U Murthy <preeti@linux.vnet.ibm.com>
    Link: http://lkml.kernel.org/r/20150705205221.802094647@linutronix.de

commit 7c4a976cd55972b68c75a978f171b6db5df4ce66
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Jul 7 10:14:35 2015 +0200

    clockevents: Allow set-state callbacks to be optional
    
    Its mandatory for the drivers to provide set_state_{oneshot|periodic}()
    (only if related modes are supported) and set_state_shutdown() callbacks
    today, if they are implementing the new set-state interface.
    
    But this leads to unnecessary noop callbacks for drivers which don't
    want to implement them. Over that, it will lead to a full function call
    for nothing really useful.
    
    Lets make all set-state callbacks optional.
    
    Suggested-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Link: http://lkml.kernel.org/r/1436256875-15562-1-git-send-email-daniel.lezcano@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 59a2d77bb38d0c3c0491b6b60ff9165b510aa647
Author: Alexander Sverdlin <alexander.sverdlin@nokia.com>
Date:   Mon Jun 29 10:41:03 2015 +0200

    sctp: Fix race between OOTB responce and route removal
    
    commit 29c4afc4e98f4dc0ea9df22c631841f9c220b944 upstream.
    
    There is NULL pointer dereference possible during statistics update if the route
    used for OOTB responce is removed at unfortunate time. If the route exists when
    we receive OOTB packet and we finally jump into sctp_packet_transmit() to send
    ABORT, but in the meantime route is removed under our feet, we take "no_route"
    path and try to update stats with IP_INC_STATS(sock_net(asoc->base.sk), ...).
    
    But sctp_ootb_pkt_new() used to prepare responce packet doesn't call
    sctp_transport_set_owner() and therefore there is no asoc associated with this
    packet. Probably temporary asoc just for OOTB responces is overkill, so just
    introduce a check like in all other places in sctp_packet_transmit(), where
    "asoc" is dereferenced.
    
    To reproduce this, one needs to
    0. ensure that sctp module is loaded (otherwise ABORT is not generated)
    1. remove default route on the machine
    2. while true; do
         ip route del [interface-specific route]
         ip route add [interface-specific route]
       done
    3. send enough OOTB packets (i.e. HB REQs) from another host to trigger ABORT
       responce
    
    On x86_64 the crash looks like this:
    
    BUG: unable to handle kernel NULL pointer dereference at 0000000000000020
    IP: [<ffffffffa05ec9ac>] sctp_packet_transmit+0x63c/0x730 [sctp]
    PGD 0
    Oops: 0000 [#1] PREEMPT SMP
    Modules linked in: ...
    CPU: 0 PID: 0 Comm: swapper/0 Tainted: G           O    4.0.5-1-ARCH #1
    Hardware name: ...
    task: ffffffff818124c0 ti: ffffffff81800000 task.ti: ffffffff81800000
    RIP: 0010:[<ffffffffa05ec9ac>]  [<ffffffffa05ec9ac>] sctp_packet_transmit+0x63c/0x730 [sctp]
    RSP: 0018:ffff880127c037b8  EFLAGS: 00010296
    RAX: 0000000000000000 RBX: 0000000000000000 RCX: 00000015ff66b480
    RDX: 00000015ff66b400 RSI: ffff880127c17200 RDI: ffff880123403700
    RBP: ffff880127c03888 R08: 0000000000017200 R09: ffffffff814625af
    R10: ffffea00047e4680 R11: 00000000ffffff80 R12: ffff8800b0d38a28
    R13: ffff8800b0d38a28 R14: ffff8800b3e88000 R15: ffffffffa05f24e0
    FS:  0000000000000000(0000) GS:ffff880127c00000(0000) knlGS:0000000000000000
    CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b
    CR2: 0000000000000020 CR3: 00000000c855b000 CR4: 00000000000007f0
    Stack:
     ffff880127c03910 ffff8800b0d38a28 ffffffff8189d240 ffff88011f91b400
     ffff880127c03828 ffffffffa05c94c5 0000000000000000 ffff8800baa1c520
     0000000000000000 0000000000000001 0000000000000000 0000000000000000
    Call Trace:
     <IRQ>
     [<ffffffffa05c94c5>] ? sctp_sf_tabort_8_4_8.isra.20+0x85/0x140 [sctp]
     [<ffffffffa05d6b42>] ? sctp_transport_put+0x52/0x80 [sctp]
     [<ffffffffa05d0bfc>] sctp_do_sm+0xb8c/0x19a0 [sctp]
     [<ffffffff810b0e00>] ? trigger_load_balance+0x90/0x210
     [<ffffffff810e0329>] ? update_process_times+0x59/0x60
     [<ffffffff812c7a40>] ? timerqueue_add+0x60/0xb0
     [<ffffffff810e0549>] ? enqueue_hrtimer+0x29/0xa0
     [<ffffffff8101f599>] ? read_tsc+0x9/0x10
     [<ffffffff8116d4b5>] ? put_page+0x55/0x60
     [<ffffffff810ee1ad>] ? clockevents_program_event+0x6d/0x100
     [<ffffffff81462b68>] ? skb_free_head+0x58/0x80
     [<ffffffffa029a10b>] ? chksum_update+0x1b/0x27 [crc32c_generic]
     [<ffffffff81283f3e>] ? crypto_shash_update+0xce/0xf0
     [<ffffffffa05d3993>] sctp_endpoint_bh_rcv+0x113/0x280 [sctp]
     [<ffffffffa05dd4e6>] sctp_inq_push+0x46/0x60 [sctp]
     [<ffffffffa05ed7a0>] sctp_rcv+0x880/0x910 [sctp]
     [<ffffffffa05ecb50>] ? sctp_packet_transmit_chunk+0xb0/0xb0 [sctp]
     [<ffffffffa05ecb70>] ? sctp_csum_update+0x20/0x20 [sctp]
     [<ffffffff814b05a5>] ? ip_route_input_noref+0x235/0xd30
     [<ffffffff81051d6b>] ? ack_ioapic_level+0x7b/0x150
     [<ffffffff814b27be>] ip_local_deliver_finish+0xae/0x210
     [<ffffffff814b2e15>] ip_local_deliver+0x35/0x90
     [<ffffffff814b2a15>] ip_rcv_finish+0xf5/0x370
     [<ffffffff814b3128>] ip_rcv+0x2b8/0x3a0
     [<ffffffff81474193>] __netif_receive_skb_core+0x763/0xa50
     [<ffffffff81476c28>] __netif_receive_skb+0x18/0x60
     [<ffffffff81476cb0>] netif_receive_skb_internal+0x40/0xd0
     [<ffffffff814776c8>] napi_gro_receive+0xe8/0x120
     [<ffffffffa03946aa>] rtl8169_poll+0x2da/0x660 [r8169]
     [<ffffffff8147896a>] net_rx_action+0x21a/0x360
     [<ffffffff81078dc1>] __do_softirq+0xe1/0x2d0
     [<ffffffff8107912d>] irq_exit+0xad/0xb0
     [<ffffffff8157d158>] do_IRQ+0x58/0xf0
     [<ffffffff8157b06d>] common_interrupt+0x6d/0x6d
     <EOI>
     [<ffffffff810e1218>] ? hrtimer_start+0x18/0x20
     [<ffffffffa05d65f9>] ? sctp_transport_destroy_rcu+0x29/0x30 [sctp]
     [<ffffffff81020c50>] ? mwait_idle+0x60/0xa0
     [<ffffffff810216ef>] arch_cpu_idle+0xf/0x20
     [<ffffffff810b731c>] cpu_startup_entry+0x3ec/0x480
     [<ffffffff8156b365>] rest_init+0x85/0x90
     [<ffffffff818eb035>] start_kernel+0x48b/0x4ac
     [<ffffffff818ea120>] ? early_idt_handlers+0x120/0x120
     [<ffffffff818ea339>] x86_64_start_reservations+0x2a/0x2c
     [<ffffffff818ea49c>] x86_64_start_kernel+0x161/0x184
    Code: 90 48 8b 80 b8 00 00 00 48 89 85 70 ff ff ff 48 83 bd 70 ff ff ff 00 0f 85 cd fa ff ff 48 89 df 31 db e8 18 63 e7 e0 48 8b 45 80 <48> 8b 40 20 48 8b 40 30 48 8b 80 68 01 00 00 65 48 ff 40 78 e9
    RIP  [<ffffffffa05ec9ac>] sctp_packet_transmit+0x63c/0x730 [sctp]
     RSP <ffff880127c037b8>
    CR2: 0000000000000020
    ---[ end trace 5aec7fd2dc983574 ]---
    Kernel panic - not syncing: Fatal exception in interrupt
    Kernel Offset: 0x0 from 0xffffffff81000000 (relocation range: 0xffffffff80000000-0xffffffff9fffffff)
    drm_kms_helper: panic occurred, switching back to text console
    ---[ end Kernel panic - not syncing: Fatal exception in interrupt
    
    Signed-off-by: Alexander Sverdlin <alexander.sverdlin@nokia.com>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Acked-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Acked-by: Vlad Yasevich <vyasevich@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Luis Henriques <luis.henriques@canonical.com>

commit 294440ca8608451a4a0cecbef125917932d620b4
Author: Alexander Sverdlin <alexander.sverdlin@nokia.com>
Date:   Mon Jun 29 10:41:03 2015 +0200

    sctp: Fix race between OOTB responce and route removal
    
    [ Upstream commit 29c4afc4e98f4dc0ea9df22c631841f9c220b944 ]
    
    There is NULL pointer dereference possible during statistics update if the route
    used for OOTB responce is removed at unfortunate time. If the route exists when
    we receive OOTB packet and we finally jump into sctp_packet_transmit() to send
    ABORT, but in the meantime route is removed under our feet, we take "no_route"
    path and try to update stats with IP_INC_STATS(sock_net(asoc->base.sk), ...).
    
    But sctp_ootb_pkt_new() used to prepare responce packet doesn't call
    sctp_transport_set_owner() and therefore there is no asoc associated with this
    packet. Probably temporary asoc just for OOTB responces is overkill, so just
    introduce a check like in all other places in sctp_packet_transmit(), where
    "asoc" is dereferenced.
    
    To reproduce this, one needs to
    0. ensure that sctp module is loaded (otherwise ABORT is not generated)
    1. remove default route on the machine
    2. while true; do
         ip route del [interface-specific route]
         ip route add [interface-specific route]
       done
    3. send enough OOTB packets (i.e. HB REQs) from another host to trigger ABORT
       responce
    
    On x86_64 the crash looks like this:
    
    BUG: unable to handle kernel NULL pointer dereference at 0000000000000020
    IP: [<ffffffffa05ec9ac>] sctp_packet_transmit+0x63c/0x730 [sctp]
    PGD 0
    Oops: 0000 [#1] PREEMPT SMP
    Modules linked in: ...
    CPU: 0 PID: 0 Comm: swapper/0 Tainted: G           O    4.0.5-1-ARCH #1
    Hardware name: ...
    task: ffffffff818124c0 ti: ffffffff81800000 task.ti: ffffffff81800000
    RIP: 0010:[<ffffffffa05ec9ac>]  [<ffffffffa05ec9ac>] sctp_packet_transmit+0x63c/0x730 [sctp]
    RSP: 0018:ffff880127c037b8  EFLAGS: 00010296
    RAX: 0000000000000000 RBX: 0000000000000000 RCX: 00000015ff66b480
    RDX: 00000015ff66b400 RSI: ffff880127c17200 RDI: ffff880123403700
    RBP: ffff880127c03888 R08: 0000000000017200 R09: ffffffff814625af
    R10: ffffea00047e4680 R11: 00000000ffffff80 R12: ffff8800b0d38a28
    R13: ffff8800b0d38a28 R14: ffff8800b3e88000 R15: ffffffffa05f24e0
    FS:  0000000000000000(0000) GS:ffff880127c00000(0000) knlGS:0000000000000000
    CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b
    CR2: 0000000000000020 CR3: 00000000c855b000 CR4: 00000000000007f0
    Stack:
     ffff880127c03910 ffff8800b0d38a28 ffffffff8189d240 ffff88011f91b400
     ffff880127c03828 ffffffffa05c94c5 0000000000000000 ffff8800baa1c520
     0000000000000000 0000000000000001 0000000000000000 0000000000000000
    Call Trace:
     <IRQ>
     [<ffffffffa05c94c5>] ? sctp_sf_tabort_8_4_8.isra.20+0x85/0x140 [sctp]
     [<ffffffffa05d6b42>] ? sctp_transport_put+0x52/0x80 [sctp]
     [<ffffffffa05d0bfc>] sctp_do_sm+0xb8c/0x19a0 [sctp]
     [<ffffffff810b0e00>] ? trigger_load_balance+0x90/0x210
     [<ffffffff810e0329>] ? update_process_times+0x59/0x60
     [<ffffffff812c7a40>] ? timerqueue_add+0x60/0xb0
     [<ffffffff810e0549>] ? enqueue_hrtimer+0x29/0xa0
     [<ffffffff8101f599>] ? read_tsc+0x9/0x10
     [<ffffffff8116d4b5>] ? put_page+0x55/0x60
     [<ffffffff810ee1ad>] ? clockevents_program_event+0x6d/0x100
     [<ffffffff81462b68>] ? skb_free_head+0x58/0x80
     [<ffffffffa029a10b>] ? chksum_update+0x1b/0x27 [crc32c_generic]
     [<ffffffff81283f3e>] ? crypto_shash_update+0xce/0xf0
     [<ffffffffa05d3993>] sctp_endpoint_bh_rcv+0x113/0x280 [sctp]
     [<ffffffffa05dd4e6>] sctp_inq_push+0x46/0x60 [sctp]
     [<ffffffffa05ed7a0>] sctp_rcv+0x880/0x910 [sctp]
     [<ffffffffa05ecb50>] ? sctp_packet_transmit_chunk+0xb0/0xb0 [sctp]
     [<ffffffffa05ecb70>] ? sctp_csum_update+0x20/0x20 [sctp]
     [<ffffffff814b05a5>] ? ip_route_input_noref+0x235/0xd30
     [<ffffffff81051d6b>] ? ack_ioapic_level+0x7b/0x150
     [<ffffffff814b27be>] ip_local_deliver_finish+0xae/0x210
     [<ffffffff814b2e15>] ip_local_deliver+0x35/0x90
     [<ffffffff814b2a15>] ip_rcv_finish+0xf5/0x370
     [<ffffffff814b3128>] ip_rcv+0x2b8/0x3a0
     [<ffffffff81474193>] __netif_receive_skb_core+0x763/0xa50
     [<ffffffff81476c28>] __netif_receive_skb+0x18/0x60
     [<ffffffff81476cb0>] netif_receive_skb_internal+0x40/0xd0
     [<ffffffff814776c8>] napi_gro_receive+0xe8/0x120
     [<ffffffffa03946aa>] rtl8169_poll+0x2da/0x660 [r8169]
     [<ffffffff8147896a>] net_rx_action+0x21a/0x360
     [<ffffffff81078dc1>] __do_softirq+0xe1/0x2d0
     [<ffffffff8107912d>] irq_exit+0xad/0xb0
     [<ffffffff8157d158>] do_IRQ+0x58/0xf0
     [<ffffffff8157b06d>] common_interrupt+0x6d/0x6d
     <EOI>
     [<ffffffff810e1218>] ? hrtimer_start+0x18/0x20
     [<ffffffffa05d65f9>] ? sctp_transport_destroy_rcu+0x29/0x30 [sctp]
     [<ffffffff81020c50>] ? mwait_idle+0x60/0xa0
     [<ffffffff810216ef>] arch_cpu_idle+0xf/0x20
     [<ffffffff810b731c>] cpu_startup_entry+0x3ec/0x480
     [<ffffffff8156b365>] rest_init+0x85/0x90
     [<ffffffff818eb035>] start_kernel+0x48b/0x4ac
     [<ffffffff818ea120>] ? early_idt_handlers+0x120/0x120
     [<ffffffff818ea339>] x86_64_start_reservations+0x2a/0x2c
     [<ffffffff818ea49c>] x86_64_start_kernel+0x161/0x184
    Code: 90 48 8b 80 b8 00 00 00 48 89 85 70 ff ff ff 48 83 bd 70 ff ff ff 00 0f 85 cd fa ff ff 48 89 df 31 db e8 18 63 e7 e0 48 8b 45 80 <48> 8b 40 20 48 8b 40 30 48 8b 80 68 01 00 00 65 48 ff 40 78 e9
    RIP  [<ffffffffa05ec9ac>] sctp_packet_transmit+0x63c/0x730 [sctp]
     RSP <ffff880127c037b8>
    CR2: 0000000000000020
    ---[ end trace 5aec7fd2dc983574 ]---
    Kernel panic - not syncing: Fatal exception in interrupt
    Kernel Offset: 0x0 from 0xffffffff81000000 (relocation range: 0xffffffff80000000-0xffffffff9fffffff)
    drm_kms_helper: panic occurred, switching back to text console
    ---[ end Kernel panic - not syncing: Fatal exception in interrupt
    
    Signed-off-by: Alexander Sverdlin <alexander.sverdlin@nokia.com>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Acked-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Acked-by: Vlad Yasevich <vyasevich@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sasha Levin <sasha.levin@oracle.com>

commit 29c4afc4e98f4dc0ea9df22c631841f9c220b944
Author: Alexander Sverdlin <alexander.sverdlin@nokia.com>
Date:   Mon Jun 29 10:41:03 2015 +0200

    sctp: Fix race between OOTB responce and route removal
    
    There is NULL pointer dereference possible during statistics update if the route
    used for OOTB responce is removed at unfortunate time. If the route exists when
    we receive OOTB packet and we finally jump into sctp_packet_transmit() to send
    ABORT, but in the meantime route is removed under our feet, we take "no_route"
    path and try to update stats with IP_INC_STATS(sock_net(asoc->base.sk), ...).
    
    But sctp_ootb_pkt_new() used to prepare responce packet doesn't call
    sctp_transport_set_owner() and therefore there is no asoc associated with this
    packet. Probably temporary asoc just for OOTB responces is overkill, so just
    introduce a check like in all other places in sctp_packet_transmit(), where
    "asoc" is dereferenced.
    
    To reproduce this, one needs to
    0. ensure that sctp module is loaded (otherwise ABORT is not generated)
    1. remove default route on the machine
    2. while true; do
         ip route del [interface-specific route]
         ip route add [interface-specific route]
       done
    3. send enough OOTB packets (i.e. HB REQs) from another host to trigger ABORT
       responce
    
    On x86_64 the crash looks like this:
    
    BUG: unable to handle kernel NULL pointer dereference at 0000000000000020
    IP: [<ffffffffa05ec9ac>] sctp_packet_transmit+0x63c/0x730 [sctp]
    PGD 0
    Oops: 0000 [#1] PREEMPT SMP
    Modules linked in: ...
    CPU: 0 PID: 0 Comm: swapper/0 Tainted: G           O    4.0.5-1-ARCH #1
    Hardware name: ...
    task: ffffffff818124c0 ti: ffffffff81800000 task.ti: ffffffff81800000
    RIP: 0010:[<ffffffffa05ec9ac>]  [<ffffffffa05ec9ac>] sctp_packet_transmit+0x63c/0x730 [sctp]
    RSP: 0018:ffff880127c037b8  EFLAGS: 00010296
    RAX: 0000000000000000 RBX: 0000000000000000 RCX: 00000015ff66b480
    RDX: 00000015ff66b400 RSI: ffff880127c17200 RDI: ffff880123403700
    RBP: ffff880127c03888 R08: 0000000000017200 R09: ffffffff814625af
    R10: ffffea00047e4680 R11: 00000000ffffff80 R12: ffff8800b0d38a28
    R13: ffff8800b0d38a28 R14: ffff8800b3e88000 R15: ffffffffa05f24e0
    FS:  0000000000000000(0000) GS:ffff880127c00000(0000) knlGS:0000000000000000
    CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b
    CR2: 0000000000000020 CR3: 00000000c855b000 CR4: 00000000000007f0
    Stack:
     ffff880127c03910 ffff8800b0d38a28 ffffffff8189d240 ffff88011f91b400
     ffff880127c03828 ffffffffa05c94c5 0000000000000000 ffff8800baa1c520
     0000000000000000 0000000000000001 0000000000000000 0000000000000000
    Call Trace:
     <IRQ>
     [<ffffffffa05c94c5>] ? sctp_sf_tabort_8_4_8.isra.20+0x85/0x140 [sctp]
     [<ffffffffa05d6b42>] ? sctp_transport_put+0x52/0x80 [sctp]
     [<ffffffffa05d0bfc>] sctp_do_sm+0xb8c/0x19a0 [sctp]
     [<ffffffff810b0e00>] ? trigger_load_balance+0x90/0x210
     [<ffffffff810e0329>] ? update_process_times+0x59/0x60
     [<ffffffff812c7a40>] ? timerqueue_add+0x60/0xb0
     [<ffffffff810e0549>] ? enqueue_hrtimer+0x29/0xa0
     [<ffffffff8101f599>] ? read_tsc+0x9/0x10
     [<ffffffff8116d4b5>] ? put_page+0x55/0x60
     [<ffffffff810ee1ad>] ? clockevents_program_event+0x6d/0x100
     [<ffffffff81462b68>] ? skb_free_head+0x58/0x80
     [<ffffffffa029a10b>] ? chksum_update+0x1b/0x27 [crc32c_generic]
     [<ffffffff81283f3e>] ? crypto_shash_update+0xce/0xf0
     [<ffffffffa05d3993>] sctp_endpoint_bh_rcv+0x113/0x280 [sctp]
     [<ffffffffa05dd4e6>] sctp_inq_push+0x46/0x60 [sctp]
     [<ffffffffa05ed7a0>] sctp_rcv+0x880/0x910 [sctp]
     [<ffffffffa05ecb50>] ? sctp_packet_transmit_chunk+0xb0/0xb0 [sctp]
     [<ffffffffa05ecb70>] ? sctp_csum_update+0x20/0x20 [sctp]
     [<ffffffff814b05a5>] ? ip_route_input_noref+0x235/0xd30
     [<ffffffff81051d6b>] ? ack_ioapic_level+0x7b/0x150
     [<ffffffff814b27be>] ip_local_deliver_finish+0xae/0x210
     [<ffffffff814b2e15>] ip_local_deliver+0x35/0x90
     [<ffffffff814b2a15>] ip_rcv_finish+0xf5/0x370
     [<ffffffff814b3128>] ip_rcv+0x2b8/0x3a0
     [<ffffffff81474193>] __netif_receive_skb_core+0x763/0xa50
     [<ffffffff81476c28>] __netif_receive_skb+0x18/0x60
     [<ffffffff81476cb0>] netif_receive_skb_internal+0x40/0xd0
     [<ffffffff814776c8>] napi_gro_receive+0xe8/0x120
     [<ffffffffa03946aa>] rtl8169_poll+0x2da/0x660 [r8169]
     [<ffffffff8147896a>] net_rx_action+0x21a/0x360
     [<ffffffff81078dc1>] __do_softirq+0xe1/0x2d0
     [<ffffffff8107912d>] irq_exit+0xad/0xb0
     [<ffffffff8157d158>] do_IRQ+0x58/0xf0
     [<ffffffff8157b06d>] common_interrupt+0x6d/0x6d
     <EOI>
     [<ffffffff810e1218>] ? hrtimer_start+0x18/0x20
     [<ffffffffa05d65f9>] ? sctp_transport_destroy_rcu+0x29/0x30 [sctp]
     [<ffffffff81020c50>] ? mwait_idle+0x60/0xa0
     [<ffffffff810216ef>] arch_cpu_idle+0xf/0x20
     [<ffffffff810b731c>] cpu_startup_entry+0x3ec/0x480
     [<ffffffff8156b365>] rest_init+0x85/0x90
     [<ffffffff818eb035>] start_kernel+0x48b/0x4ac
     [<ffffffff818ea120>] ? early_idt_handlers+0x120/0x120
     [<ffffffff818ea339>] x86_64_start_reservations+0x2a/0x2c
     [<ffffffff818ea49c>] x86_64_start_kernel+0x161/0x184
    Code: 90 48 8b 80 b8 00 00 00 48 89 85 70 ff ff ff 48 83 bd 70 ff ff ff 00 0f 85 cd fa ff ff 48 89 df 31 db e8 18 63 e7 e0 48 8b 45 80 <48> 8b 40 20 48 8b 40 30 48 8b 80 68 01 00 00 65 48 ff 40 78 e9
    RIP  [<ffffffffa05ec9ac>] sctp_packet_transmit+0x63c/0x730 [sctp]
     RSP <ffff880127c037b8>
    CR2: 0000000000000020
    ---[ end trace 5aec7fd2dc983574 ]---
    Kernel panic - not syncing: Fatal exception in interrupt
    Kernel Offset: 0x0 from 0xffffffff81000000 (relocation range: 0xffffffff80000000-0xffffffff9fffffff)
    drm_kms_helper: panic occurred, switching back to text console
    ---[ end Kernel panic - not syncing: Fatal exception in interrupt
    
    Signed-off-by: Alexander Sverdlin <alexander.sverdlin@nokia.com>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Acked-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Acked-by: Vlad Yasevich <vyasevich@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 43224b96af3154cedd7220f7b90094905f07ac78
Merge: d70b3ef54cea 1cb6c2151850
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jun 22 18:57:44 2015 -0700

    Merge branch 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer updates from Thomas Gleixner:
     "A rather largish update for everything time and timer related:
    
       - Cache footprint optimizations for both hrtimers and timer wheel
    
       - Lower the NOHZ impact on systems which have NOHZ or timer migration
         disabled at runtime.
    
       - Optimize run time overhead of hrtimer interrupt by making the clock
         offset updates smarter
    
       - hrtimer cleanups and removal of restrictions to tackle some
         problems in sched/perf
    
       - Some more leap second tweaks
    
       - Another round of changes addressing the 2038 problem
    
       - First step to change the internals of clock event devices by
         introducing the necessary infrastructure
    
       - Allow constant folding for usecs/msecs_to_jiffies()
    
       - The usual pile of clockevent/clocksource driver updates
    
      The hrtimer changes contain updates to sched, perf and x86 as they
      depend on them plus changes all over the tree to cleanup API changes
      and redundant code, which got copied all over the place.  The y2038
      changes touch s390 to remove the last non 2038 safe code related to
      boot/persistant clock"
    
    * 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (114 commits)
      clocksource: Increase dependencies of timer-stm32 to limit build wreckage
      timer: Minimize nohz off overhead
      timer: Reduce timer migration overhead if disabled
      timer: Stats: Simplify the flags handling
      timer: Replace timer base by a cpu index
      timer: Use hlist for the timer wheel hash buckets
      timer: Remove FIFO "guarantee"
      timers: Sanitize catchup_timer_jiffies() usage
      hrtimer: Allow hrtimer::function() to free the timer
      seqcount: Introduce raw_write_seqcount_barrier()
      seqcount: Rename write_seqcount_barrier()
      hrtimer: Fix hrtimer_is_queued() hole
      hrtimer: Remove HRTIMER_STATE_MIGRATE
      selftest: Timers: Avoid signal deadlock in leap-a-day
      timekeeping: Copy the shadow-timekeeper over the real timekeeper last
      clockevents: Check state instead of mode in suspend/resume path
      selftests: timers: Add leap-second timer edge testing to leap-a-day.c
      ntp: Do leapsecond adjustment in adjtimex read path
      time: Prevent early expiry of hrtimers[CLOCK_REALTIME] at the leap second edge
      ntp: Introduce and use SECS_PER_DAY macro instead of 86400
      ...

commit a9d20988ac7db47fec4510cefc966e876a4ce674
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Wed Jun 17 16:04:46 2015 +0530

    clockevents: Check state instead of mode in suspend/resume path
    
    CLOCK_EVT_MODE_* macros are present for backward compatibility (as most
    of the drivers are still using old ->set_mode() interface).
    
    These macro's shouldn't be used anymore in code, that is common to both
    driver interfaces, i.e. ->set_mode() and ->set_state_*().
    
    Drivers implementing ->set_state_*() interface, which have their
    clkevt->mode set to 0 (clkevt device structures are normally globally
    defined), will not participate in suspend/resume as they will always be
    marked as UNUSED.
    
    Fix this by checking state of the clockevent device instead of mode,
    which is updated for both the interfaces.
    
    Fixes: ac34ad27fc16 ("clockevents: Do not suspend/resume if unused")
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Cc: linaro-kernel@lists.linaro.org
    Cc: alexandre.belloni@free-electrons.com
    Cc: sylvain.rochet@finsecur.com
    Link: http://lkml.kernel.org/r/a1964eef6e8a47d02b1ff9083c6c91f73f0ff643.1434537215.git.viresh.kumar@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit a4630c61274322eda7c4a4d17051f7c72a9e03b1
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Fri May 29 17:24:23 2015 +0200

    PM / Domains: Skip timings during syscore suspend/resume
    
    The PM Domain code uses ktime_get() to perform various latency
    measurements.  However, if ktime_get() is called while timekeeping is
    suspended, the following warning is printed:
    
        WARNING: CPU: 0 PID: 1340 at kernel/time/timekeeping.c:576 ktime_get+0x3
    
    This happens when resuming the PM Domain that contains the clock events
    source, which calls pm_genpd_syscore_poweron(). Chain of operations is:
    
        timekeeping_resume()
        {
            clockevents_resume()
                sh_cmt_clock_event_resume()
                    pm_genpd_syscore_poweron()
                        pm_genpd_sync_poweron()
                            genpd_syscore_switch()
                                genpd_power_on()
                                    ktime_get(), but timekeeping_suspended == 1
            ...
            timekeeping_suspended = 0;
        }
    
    Fix this by adding a "timed" parameter to genpd_power_{on,off}() and
    pm_genpd_sync_power{off,on}(), to indicate whether latency measurements
    are allowed.  This parameter is passed as false in
    genpd_syscore_switch() (i.e. during syscore suspend/resume), and true in
    all other cases.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 6286e8285078ab02b215bba1d42a05ecfd864515
Author: Govindarajulu Varadarajan <_govind@gmx.com>
Date:   Thu Jun 11 11:52:54 2015 +0530

    enic: unlock napi busy poll before unmasking intr
    
    There is a small window between vnic_intr_unmask() and enic_poll_unlock_napi().
    In this window if an irq occurs and napi is scheduled on different cpu, it tries
    to acquire enic_poll_lock_napi() and hits the following WARN_ON message.
    
    Fix is to unlock napi_poll before unmasking the interrupt.
    
    [  781.121746] ------------[ cut here ]------------
    [  781.121789] WARNING: CPU: 1 PID: 0 at drivers/net/ethernet/cisco/enic/vnic_rq.h:228 enic_poll_msix_rq+0x36a/0x3c0 [enic]()
    [  781.121834] Modules linked in: nfsv3 nfs_acl rpcsec_gss_krb5 auth_rpcgss oid_registry nfsv4 dns_resolver coretemp intel_rapl iosf_mbi x86_pkg_temp_thermal intel_powerclamp kvm_intel kvm crct10dif_pclmul crc32_pclmul ghash_clmulni_intel aesni_intel mgag200 ttm drm_kms_helper joydev aes_x86_64 lrw drm gf128mul mousedev glue_helper sb_edac ablk_helper iTCO_wdt iTCO_vendor_support evdev ipmi_si syscopyarea sysfillrect sysimgblt i2c_algo_bit i2c_core edac_core lpc_ich mac_hid cryptd pcspkr ipmi_msghandler shpchp tpm_tis acpi_power_meter tpm wmi processor hwmon button ac sch_fq_codel nfs lockd grace sunrpc fscache hid_generic usbhid hid ehci_pci ehci_hcd sd_mod megaraid_sas usbcore scsi_mod usb_common enic crc32c_generic crc32c_intel btrfs xor raid6_pq ext4 crc16 mbcache jbd2
    [  781.122176] CPU: 1 PID: 0 Comm: swapper/1 Not tainted 4.1.0-rc6-ARCH-00040-gc46a024-dirty #106
    [  781.122210] Hardware name: Cisco Systems Inc UCSB-B200-M4/UCSB-B200-M4, BIOS B200M4.2.2.2.23.061220140128 06/12/2014
    [  781.122252]  0000000000000000 bddbbc9d655ec96e ffff880277e43da8 ffffffff81583fe8
    [  781.122286]  0000000000000000 0000000000000000 ffff880277e43de8 ffffffff8107acfa
    [  781.122319]  ffff880272c01000 ffff880273f18000 ffff880273f1a100 0000000000000000
    [  781.122352] Call Trace:
    [  781.122364]  <IRQ>  [<ffffffff81583fe8>] dump_stack+0x4f/0x7b
    [  781.122399]  [<ffffffff8107acfa>] warn_slowpath_common+0x8a/0xc0
    [  781.122425]  [<ffffffff8107ae2a>] warn_slowpath_null+0x1a/0x20
    [  781.122455]  [<ffffffffa01fa9ca>] enic_poll_msix_rq+0x36a/0x3c0 [enic]
    [  781.122487]  [<ffffffff8148525a>] net_rx_action+0x22a/0x370
    [  781.122512]  [<ffffffff8107ed3d>] __do_softirq+0xed/0x2d0
    [  781.122537]  [<ffffffff8107f06e>] irq_exit+0x7e/0xa0
    [  781.122560]  [<ffffffff8158c424>] do_IRQ+0x64/0x100
    [  781.122582]  [<ffffffff8158a42e>] common_interrupt+0x6e/0x6e
    [  781.122605]  <EOI>  [<ffffffff810bd331>] ? cpu_startup_entry+0x121/0x480
    [  781.122638]  [<ffffffff810bd2fc>] ? cpu_startup_entry+0xec/0x480
    [  781.122667]  [<ffffffff810f2ed3>] ? clockevents_register_device+0x113/0x1f0
    [  781.122698]  [<ffffffff81050ab6>] start_secondary+0x196/0x1e0
    [  781.122723] ---[ end trace cec2e9dd3af7b9db ]---
    
    Signed-off-by: Govindarajulu Varadarajan <_govind@gmx.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 669f6f96c680a741257ada44a28b580df2e1fc25
Author: Ingo Molnar <mingo@kernel.org>
Date:   Wed Jun 3 12:39:26 2015 +0200

    Documentation/features: Explain kernel feature descriptions and add visualization script
    
    The previous patches added arch support matrices for more than 40 generic kernel features
    that need per architecture support.
    
    The structure of the feature descriptions is the following:
    
    Each feature has its own directory under Documentation/features/subsystem_name/feature_name/,
    and the arch-support.txt file shows its current arch porting status.
    
    For example, lockdep support is shown the following way:
    
        triton:~/tip> cat Documentation/features/locking/lockdep/arch-support.txt
        #
        # Feature name:          lockdep
        #         Kconfig:       LOCKDEP_SUPPORT
        #         description:   arch supports the runtime locking correctness debug facility
        #
            -----------------------
            |         arch |status|
            -----------------------
            |       alpha: | TODO |
            |         arc: |  ok  |
            |         arm: |  ok  |
            |       arm64: |  ok  |
            |       avr32: |  ok  |
            |    blackfin: |  ok  |
            |         c6x: | TODO |
            |        cris: | TODO |
            |         frv: | TODO |
            |       h8300: | TODO |
            |     hexagon: |  ok  |
            |        ia64: | TODO |
            |        m32r: | TODO |
            |        m68k: | TODO |
            |       metag: |  ok  |
            |  microblaze: |  ok  |
            |        mips: |  ok  |
            |     mn10300: | TODO |
            |       nios2: | TODO |
            |    openrisc: | TODO |
            |      parisc: | TODO |
            |     powerpc: |  ok  |
            |        s390: |  ok  |
            |       score: |  ok  |
            |          sh: |  ok  |
            |       sparc: |  ok  |
            |        tile: |  ok  |
            |          um: |  ok  |
            |   unicore32: |  ok  |
            |         x86: |  ok  |
            |      xtensa: |  ok  |
            -----------------------
    
    For generic kernel features that need architecture support, the
    arch-support.txt file in each feature directory shows the arch
    support matrix, for all upstream Linux architectures.
    
    The meaning of entries in the tables is:
    
        | ok |  # feature supported by the architecture
        |TODO|  # feature not yet supported by the architecture
        | .. |  # feature cannot be supported by the hardware
    
    This directory structure can be used in the future to add other
    files - such as porting guides, testing description, etc.
    
    The Documentation/features/ hierarchy may also include generic
    kernel features that works on every architecture, in that case
    the arch-support.txt file will list every architecture as
    supported.
    
    To list an architecture's unsupported features, just do something
    like:
    
      triton:~/tip>  git grep -lE 'x86.*TODO' Documentation/features/*/*/arch-support.txt
      Documentation/features/lib/strncasecmp/arch-support.txt
      Documentation/features/time/arch-tick-broadcast/arch-support.txt
    
    which will print the list of not yet supported features.
    
    The Documentation/features/list-arch.sh script will print the current
    support matrix of one architecture:
    
      triton:~/tip> Documentation/features/list-arch.sh
      #
      # Kernel feature support matrix of the 'x86' architecture:
      #
          core/ BPF-JIT              :  ok  |                        HAVE_BPF_JIT #  arch supports BPF JIT optimizations
          core/ generic-idle-thread  :  ok  |             GENERIC_SMP_IDLE_THREAD #  arch makes use of the generic SMP idle thread facility
          core/ jump-labels          :  ok  |                HAVE_ARCH_JUMP_LABEL #  arch supports live patched, high efficiency branches
          core/ tracehook            :  ok  |                 HAVE_ARCH_TRACEHOOK #  arch supports tracehook (ptrace) register handling APIs
         debug/ gcov-profile-all     :  ok  |           ARCH_HAS_GCOV_PROFILE_ALL #  arch supports whole-kernel GCOV code coverage profiling
         debug/ KASAN                :  ok  |                     HAVE_ARCH_KASAN #  arch supports the KASAN runtime memory checker
         debug/ kgdb                 :  ok  |                      HAVE_ARCH_KGDB #  arch supports the kGDB kernel debugger
         debug/ kprobes              :  ok  |                        HAVE_KPROBES #  arch supports live patched kernel probe
         debug/ kprobes-on-ftrace    :  ok  |              HAVE_KPROBES_ON_FTRACE #  arch supports combined kprobes and ftrace live patching
         debug/ kretprobes           :  ok  |                     HAVE_KRETPROBES #  arch supports kernel function-return probes
         debug/ optprobes            :  ok  |                      HAVE_OPTPROBES #  arch supports live patched optprobes
         debug/ stackprotector       :  ok  |              HAVE_CC_STACKPROTECTOR #  arch supports compiler driven stack overflow protection
         debug/ uprobes              :  ok  |               ARCH_SUPPORTS_UPROBES #  arch supports live patched user probes
         debug/ user-ret-profiler    :  ok  |           HAVE_USER_RETURN_NOTIFIER #  arch supports user-space return from system call profiler
            io/ dma-api-debug        :  ok  |                  HAVE_DMA_API_DEBUG #  arch supports DMA debug facilities
            io/ dma-contiguous       :  ok  |                 HAVE_DMA_CONTIGUOUS #  arch supports the DMA CMA (continuous memory allocator)
            io/ dma_map_attrs        :  ok  |                      HAVE_DMA_ATTRS #  arch provides dma_*map*_attrs() APIs
            io/ sg-chain             :  ok  |                   ARCH_HAS_SG_CHAIN #  arch supports chained scatter-gather lists
           lib/ strncasecmp          : TODO |             __HAVE_ARCH_STRNCASECMP #  arch provides an optimized strncasecmp() function
       locking/ cmpxchg-local        :  ok  |                  HAVE_CMPXCHG_LOCAL #  arch supports the this_cpu_cmpxchg() API
       locking/ lockdep              :  ok  |                     LOCKDEP_SUPPORT #  arch supports the runtime locking correctness debug facility
       locking/ queued-rwlocks       :  ok  |             ARCH_USE_QUEUED_RWLOCKS #  arch supports queued rwlocks
       locking/ queued-spinlocks     :  ok  |           ARCH_USE_QUEUED_SPINLOCKS #  arch supports queued spinlocks
       locking/ rwsem-optimized      :  ok  |               Optimized asm/rwsem.h #  arch provides optimized rwsem APIs
          perf/ kprobes-event        :  ok  |      HAVE_REGS_AND_STACK_ACCESS_API #  arch supports kprobes with perf events
          perf/ perf-regs            :  ok  |                      HAVE_PERF_REGS #  arch supports perf events register access
          perf/ perf-stackdump       :  ok  |           HAVE_PERF_USER_STACK_DUMP #  arch supports perf events stack dumps
         sched/ numa-balancing       :  ok  |        ARCH_SUPPORTS_NUMA_BALANCING #  arch supports NUMA balancing
       seccomp/ seccomp-filter       :  ok  |            HAVE_ARCH_SECCOMP_FILTER #  arch supports seccomp filters
          time/ arch-tick-broadcast  : TODO |             ARCH_HAS_TICK_BROADCAST #  arch provides tick_broadcast()
          time/ clockevents          :  ok  |                 GENERIC_CLOCKEVENTS #  arch support generic clock events
          time/ context-tracking     :  ok  |               HAVE_CONTEXT_TRACKING #  arch supports context tracking for NO_HZ_FULL
          time/ irq-time-acct        :  ok  |            HAVE_IRQ_TIME_ACCOUNTING #  arch supports precise IRQ time accounting
          time/ modern-timekeeping   :  ok  |            !ARCH_USES_GETTIMEOFFSET #  arch does not use arch_gettimeoffset() anymore
          time/ virt-cpuacct         :  ok  |            HAVE_VIRT_CPU_ACCOUNTING #  arch supports precise virtual CPU time accounting
            vm/ ELF-ASLR             :  ok  |              ARCH_HAS_ELF_RANDOMIZE #  arch randomizes the stack, heap and binary images of ELF binaries
            vm/ huge-vmap            :  ok  |                 HAVE_ARCH_HUGE_VMAP #  arch supports the ioremap_pud_enabled() and ioremap_pmd_enabled() VM APIs
            vm/ ioremap_prot         :  ok  |                   HAVE_IOREMAP_PROT #  arch has ioremap_prot()
            vm/ numa-memblock        :  ok  |              HAVE_MEMBLOCK_NODE_MAP #  arch supports NUMA aware memblocks
            vm/ PG_uncached          :  ok  |               ARCH_USES_PG_UNCACHED #  arch supports the PG_uncached page flag
            vm/ pmdp_splitting_flush :  ok  |    __HAVE_ARCH_PMDP_SPLITTING_FLUSH #  arch supports the pmdp_splitting_flush() VM API
            vm/ pte_special          :  ok  |             __HAVE_ARCH_PTE_SPECIAL #  arch supports the pte_special()/pte_mkspecial() VM APIs
            vm/ THP                  :  ok  |      HAVE_ARCH_TRANSPARENT_HUGEPAGE #  arch supports transparent hugepages
    
    Cc: <linux-api@vger.kernel.org>
    Cc: <linux-arch@vger.kernel.org>
    Cc: <linux-kernel@vger.kernel.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Jonathan Corbet <corbet@lwn.net>
    Cc: Josh Triplett <josh@joshtriplett.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 28dfffd6d14f9cb2277e9bead011e8d510e2c4fa
Author: Ingo Molnar <mingo@kernel.org>
Date:   Wed Jun 3 12:37:24 2015 +0200

    Documentation/features/time: Add feature description and arch support status file for 'clockevents'
    
    Cc: <linux-api@vger.kernel.org>
    Cc: <linux-arch@vger.kernel.org>
    Cc: <linux-kernel@vger.kernel.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Jonathan Corbet <corbet@lwn.net>
    Cc: Josh Triplett <josh@joshtriplett.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 09cbbf0c169dd81487682622500c81a9012cbeef
Merge: be3ef76e9d9b d4688bdc6335
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 2 16:57:47 2015 +0200

    Merge branch 'clockevents/4.2' of http://git.linaro.org/people/daniel.lezcano/linux into timers/core
    
    Pull clockevents/clocksource changes from Daniel Lezcano:
    
      - Removed dead code in the files related to mach-msm for qcom (Stephen Boyd)
      - Cleaned up code for exynos_mct (Krzysztof Kozlowski)
      - Added the new timer lpc3220 (Joachim Eastwood)
      - Added the new timer STM32 and ARM system timer (Maxime Coquelin)

commit be3ef76e9d9b97962c70bd6351787d29071ae481
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 2 14:30:11 2015 +0200

    clockevents: Rename state to state_use_accessors
    
    The only sensible way to make abuse of core internal fields obvious
    and easy to grep for.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Viresh Kumar <viresh.kumar@linaro.org>
    Cc: Peter Zijlstra <peterz@infradead.org>

commit 051ebd101b05c09d9b5b673e19fb0586e9bfec56
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 2 14:13:46 2015 +0200

    clockevents: Use set/get state helper functions
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Viresh Kumar <viresh.kumar@linaro.org>
    Cc: Peter Zijlstra <peterz@infradead.org>

commit d7eb231c71420bc34ac3d35403115600f920cfc2
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 2 14:08:46 2015 +0200

    clockevents: Provide functions to set and get the state
    
    We want to rename dev->state, so provide proper get and set
    functions. Rename clockevents_set_state() to
    clockevents_switch_state() to avoid confusion.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Viresh Kumar <viresh.kumar@linaro.org>
    Cc: Peter Zijlstra <peterz@infradead.org>

commit 472c4a9437d3c6a0b1e59df7c5aa14075946aa70
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu May 21 13:33:46 2015 +0530

    clockevents: Use helpers to check the state of a clockevent device
    
    Use accessor functions to check the state of clockevent devices in
    core code.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Cc: linaro-kernel@lists.linaro.org
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/fa2b9869fd17f210eaa156ec2b594efd0230b6c7.1432192527.git.viresh.kumar@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 3434d23b694e5cb6e44e966914563406c31c4053
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu May 21 13:33:45 2015 +0530

    clockevents: Add helpers to check the state of a clockevent device
    
    Some clockevent drivers, once migrated to use per-state callbacks,
    need to check the state of the clockevent device in their callbacks or
    interrupt handler.
    
    Add accessor functions clockevent_state_*() to get this information.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Cc: linaro-kernel@lists.linaro.org
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/04a717d490335c688dd7af899fbcede97e1bb8ee.1432192527.git.viresh.kumar@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit d4688bdc6335e9faaf3f0173f96932cd520cee1a
Author: Maxime Coquelin <mcoquelin.stm32@gmail.com>
Date:   Thu May 28 07:05:53 2015 +0200

    clockevents/drivers/timer-stm32: Fix build warning spotted by kbuild test robot
    
    This patch fixes below warning spotted by kbuild test robot when building
    with ARCH=powerpc:
    
       drivers/clocksource/timer-stm32.c: In function 'stm32_clockevent_init':
    >> drivers/clocksource/timer-stm32.c:140:9: warning: large integer implicitly
            truncated to unsigned type [-Woverflow]
    
         writel_relaxed(~0UL, data->base + TIM_ARR);
    
    The fix consists in using 0U instead of 0UL.
    
    Reported-by: kbuild test robot <fengguang.wu@intel.com>
    Signed-off-by: Maxime Coquelin <mcoquelin.stm32@gmail.com>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit e37e45934afed32f00e16db745c410d5c675456d
Author: Maxime Coquelin <mcoquelin.stm32@gmail.com>
Date:   Fri May 22 23:03:33 2015 +0200

    clockevents/drivers: Add STM32 Timer driver
    
    STM32 MCUs feature 16 and 32 bits general purpose timers with prescalers.
    The drivers detects whether the time is 16 or 32 bits, and applies a
    1024 prescaler value if it is 16 bits.
    
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Tested-by: Chanwoo Choi <cw00.choi@samsung.com>
    Signed-off-by: Maxime Coquelin <mcoquelin.stm32@gmail.com>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit ac34ad27fc160b5bd31c731cdaaf6e1d1890ccb2
Author: Alexandre Belloni <alexandre.belloni@free-electrons.com>
Date:   Fri Jan 16 10:05:51 2015 +0100

    clockevents: Do not suspend/resume if unused
    
    There is no point in calling suspend/resume for unused clockevents as
    they are already stopped and disabled.
    
    This is really important for AT91 as the hardware is a trainwreck and
    takes ages to synchronize.
    
    Reported-by: Sylvain Rochet <sylvain.rochet@finsecur.com>
    Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: Nicolas Ferre <nicolas.ferre@atmel.com>
    Cc: Boris Brezillon <boris.brezillon@free-electrons.com>
    Cc: Maxime Ripard <maxime.ripard@free-electrons.com>
    Cc: linux-arm-kernel@lists.infradead.org
    Link: http://lkml.kernel.org/r/1421399151-26800-1-git-send-email-alexandre.belloni@free-electrons.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit d25408756accbd2171abaa0678f986adae139e6f
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Apr 3 09:04:05 2015 +0530

    clockevents: Stop unused clockevent devices
    
    To avoid getting spurious interrupts on a tickless CPU, clockevent
    device can now be stopped by switching to ONESHOT_STOPPED state.
    
    The natural place for handling this transition is tick_program_event().
    
    On 'expires == KTIME_MAX', we skip programming the event and so we need
    to fix such call sites as well, to always call tick_program_event()
    irrespective of the expires value.
    
    Once the clockevent device is required again, check if it was earlier
    put into ONESHOT_STOPPED state. If yes, switch its state to ONESHOT
    before programming its event.
    
    To make sure we haven't missed any corner case, add a WARN() for the
    case where we try to reprogram clockevent device while we aren't
    configured in ONESHOT_STOPPED state.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Cc: linaro-kernel@lists.linaro.org
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Kevin Hilman <khilman@linaro.org>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: Preeti U Murthy <preeti@linux.vnet.ibm.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/5146b07be7f0bc497e0ebae036590ec2fa73e540.1428031396.git.viresh.kumar@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 8fff52fd50934580c5108afed12043a774edf728
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Apr 3 09:04:04 2015 +0530

    clockevents: Introduce CLOCK_EVT_STATE_ONESHOT_STOPPED state
    
    When no timers/hrtimers are pending, the expiry time is set to a
    special value: 'KTIME_MAX'. This normally happens with
    NO_HZ_{IDLE|FULL} in both LOWRES/HIGHRES modes.
    
    When 'expiry == KTIME_MAX', we either cancel the 'tick-sched' hrtimer
    (NOHZ_MODE_HIGHRES) or skip reprogramming clockevent device
    (NOHZ_MODE_LOWRES).  But, the clockevent device is already
    reprogrammed from the tick-handler for next tick.
    
    As the clock event device is programmed in ONESHOT mode it will at
    least fire one more time (unnecessarily). Timers on few
    implementations (like arm_arch_timer, etc.) only support PERIODIC mode
    and their drivers emulate ONESHOT over that. Which means that on these
    platforms we will get spurious interrupts periodically (at last
    programmed interval rate, normally tick rate).
    
    In order to avoid spurious interrupts, the clockevent device should be
    stopped or its interrupts should be masked.
    
    A simple (yet hacky) solution to get this fixed could be: update
    hrtimer_force_reprogram() to always reprogram clockevent device and
    update clockevent drivers to STOP generating events (or delay it to
    max time) when 'expires' is set to KTIME_MAX. But the drawback here is
    that every clockevent driver has to be hacked for this particular case
    and its very easy for new ones to miss this.
    
    However, Thomas suggested to add an optional state ONESHOT_STOPPED to
    solve this problem: lkml.org/lkml/2014/5/9/508.
    
    This patch adds support for ONESHOT_STOPPED state in clockevents
    core. It will only be available to drivers that implement the
    state-specific callbacks instead of the legacy ->set_mode() callback.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Preeti U. Murthy <preeti@linux.vnet.ibm.com>
    Cc: linaro-kernel@lists.linaro.org
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Kevin Hilman <khilman@linaro.org>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/b8b383a03ac07b13312c16850b5106b82e4245b5.1428031396.git.viresh.kumar@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 95f3b1f4b1df4716ce2db8aa2243b7e288eeb9a7
Merge: 1a9f064f516c 149aabcc44e3
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat May 9 14:57:49 2015 -0700

    Merge branch 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer fix from Thomas Gleixner:
     "A simple fix to actually shut down a detached device instead of
      keeping it active"
    
    * 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      clockevents: Shutdown detached clockevent device

commit 4a152c3913fb46fc2e29081d0251862106c3d55f
Merge: 5a2e73b281b7 50904a7ddd1c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Apr 30 14:23:31 2015 -0700

    Merge tag 'pm+acpi-4.1-rc2' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull power management and ACPI fixes from Rafael Wysocki:
     "Three regression fixes this time, one for a recent regression in the
      cpuidle core affecting multiple systems, one for an inadvertently
      added duplicate typedef in ACPICA that breaks compilation with GCC 4.5
      and one for an ACPI Smart Battery Subsystem driver regression
      introduced during the 3.18 cycle (stable-candidate).
    
      Specifics:
    
       - Fix for a regression in the cpuidle core introduced by one of the
         recent commits in the clockevents_notify() removal series that put
         a call to a function which had to be executed with disabled
         interrupts into a code path running with enabled interrupts (Rafael
         J Wysocki)
    
       - Fix for a build problem in ACPICA (with GCC 4.5) introduced by one
         of the recent ACPICA tools commits that added a duplicate typedef
         to one of the ACPICA's header files by mistake (Olaf Hering)
    
       - Fix for a regression in the ACPI SBS (Smart Battery Subsystem)
         driver introduced during the 3.18 development cycle causing the
         smart battery manager to be marked as not present when it should be
         marked as present (Chris Bainbridge)"
    
    * tag 'pm+acpi-4.1-rc2' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm:
      cpuidle: Run tick_broadcast_exit() with disabled interrupts
      ACPI / SBS: Enable battery manager when present
      ACPICA: remove duplicate u8 typedef

commit 2b953a5e994ce279904ec70220f7d4f31d380a0a
Author: Boris Ostrovsky <boris.ostrovsky@oracle.com>
Date:   Tue Apr 28 18:46:20 2015 -0400

    xen: Suspend ticks on all CPUs during suspend
    
    Commit 77e32c89a711 ("clockevents: Manage device's state separately for
    the core") decouples clockevent device's modes from states. With this
    change when a Xen guest tries to resume, it won't be calling its
    set_mode op which needs to be done on each VCPU in order to make the
    hypervisor aware that we are in oneshot mode.
    
    This happens because clockevents_tick_resume() (which is an intermediate
    step of resuming ticks on a processor) doesn't call clockevents_set_state()
    anymore and because during suspend clockevent devices on all VCPUs (except
    for the one doing the suspend) are left in ONESHOT state. As result, during
    resume the clockevents state machine will assume that device is already
    where it should be and doesn't need to be updated.
    
    To avoid this problem we should suspend ticks on all VCPUs during
    suspend.
    
    Signed-off-by: Boris Ostrovsky <boris.ostrovsky@oracle.com>
    Signed-off-by: David Vrabel <david.vrabel@citrix.com>

commit df8d9eeadd0f7a216f2476351d5aee43c6550bf0
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Apr 29 15:19:21 2015 +0200

    cpuidle: Run tick_broadcast_exit() with disabled interrupts
    
    Commit 335f49196fd6 (sched/idle: Use explicit broadcast oneshot
    control function) replaced clockevents_notify() invocations in
    cpuidle_idle_call() with direct calls to tick_broadcast_enter()
    and tick_broadcast_exit(), but it overlooked the fact that
    interrupts were already enabled before calling the latter which
    led to functional breakage on systems using idle states with the
    CPUIDLE_FLAG_TIMER_STOP flag set.
    
    Fix that by moving the invocations of tick_broadcast_enter()
    and tick_broadcast_exit() down into cpuidle_enter_state() where
    interrupts are still disabled when tick_broadcast_exit() is
    called.  Also ensure that interrupts will be disabled before
    running tick_broadcast_exit() even if they have been enabled by
    the idle state's ->enter callback.  Trigger a WARN_ON_ONCE() in
    that case, as we generally don't want that to happen for states
    with CPUIDLE_FLAG_TIMER_STOP set.
    
    Fixes: 335f49196fd6 (sched/idle: Use explicit broadcast oneshot control function)
    Reported-and-tested-by: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Acked-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Reported-and-tested-by: Sudeep Holla <sudeep.holla@arm.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 7f9f44308c8993c9ab8078d174dad34bea3e82d7
Merge: 63905bba5b01 d939b52abe0c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Apr 26 13:31:05 2015 -0700

    Merge tag 'cris-for-4.1' of git://git.kernel.org/pub/scm/linux/kernel/git/jesper/cris
    
    Pull arch/cris updates from Jesper Nilsson:
     "Some much needed love for the CRIS-port.
    
      There's a bunch of changes this time, giving the CRISv32 port a bit of
      modern makeover with device-tree, irq domain and gpiolib support, and
      more switchover to generic frameworks.
    
      Some small fixes and removal of the theoretical SMP support brings up
      the rear"
    
    * tag 'cris-for-4.1' of git://git.kernel.org/pub/scm/linux/kernel/git/jesper/cris:
      cris: fix integer overflow in ELF_ET_DYN_BASE
      CRISv32: use GENERIC_SCHED_CLOCK
      CRISv32: use MMIO clocksource
      CRISv32: use generic clockevents
      CRIS: use generic headers via Kbuild
      CRIS: use generic cmpxchg.h
      CRIS: use generic atomic.h
      CRIS: use generic atomic bitops
      CRISv10: remove redundant macros from system.h
      CRIS: remove SMP code
      CRISv32: don't enable irqs in INIT_THREAD
      CRISv32: handle multiple signals
      CRISv32: prevent bogus restarts on sigreturn
      CRISv32: don't attempt syscall restart on irq exit
      Add binding documentation for CRIS
      CRIS: add Axis 88 board device tree
      CRISv32: add device tree support
      CRISv32: add irq domains support
      CRIS: enable GPIOLIB

commit b27b4b79d535672a19e9d0fe1256ad1016cc9e7f
Author: Preeti U Murthy <preeti@linux.vnet.ibm.com>
Date:   Wed Mar 18 16:19:27 2015 +0530

    timers/tick/broadcast-hrtimer: Fix suspicious RCU usage in idle loop
    
    [ Upstream commit a127d2bcf1fbc8c8e0b5cf0dab54f7d3ff50ce47 ]
    
    The hrtimer mode of broadcast queues hrtimers in the idle entry
    path so as to wakeup cpus in deep idle states. The associated
    call graph is :
    
            cpuidle_idle_call()
            |____ clockevents_notify(CLOCK_EVT_NOTIFY_BROADCAST_ENTER, ....))
                 |_____tick_broadcast_set_event()
                       |____clockevents_program_event()
                            |____bc_set_next()
    
    The hrtimer_{start/cancel} functions call into tracing which uses RCU.
    But it is not legal to call into RCU in cpuidle because it is one of the
    quiescent states. Hence protect this region with RCU_NONIDLE which informs
    RCU that the cpu is momentarily non-idle.
    
    As an aside it is helpful to point out that the clock event device that is
    programmed here is not a per-cpu clock device; it is a
    pseudo clock device, used by the broadcast framework alone.
    The per-cpu clock device programming never goes through bc_set_next().
    
    Signed-off-by: Preeti U Murthy <preeti@linux.vnet.ibm.com>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Reviewed-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Cc: linuxppc-dev@ozlabs.org
    Cc: mpe@ellerman.id.au
    Cc: tglx@linutronix.de
    Link: http://lkml.kernel.org/r/20150318104705.17763.56668.stgit@preeti.in.ibm.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Sasha Levin <sasha.levin@oracle.com>

commit 149aabcc44e3e2c1f8fe4f0832be53d2db55b598
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Apr 10 12:56:41 2015 +0530

    clockevents: Shutdown detached clockevent device
    
    A clockevent device is marked DETACHED when it is replaced by another
    clockevent device.
    
    The device is shutdown properly for drivers that implement legacy
    ->set_mode() callback, as we call ->set_mode() for CLOCK_EVT_MODE_UNUSED
    as well.
    
    But for the new per-state callback interface, we skip shutting down the
    device, as we thought its an internal state change. That wasn't correct.
    
    The effect is that the device is left programmed in oneshot or periodic
    mode.
    
    Fall-back to 'case CLOCK_EVT_STATE_SHUTDOWN', to shutdown the device.
    
    Fixes: bd624d75db21 "clockevents: Introduce mode specific callbacks"
    Reported-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Cc: linaro-kernel@lists.linaro.org
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/eef0a91c51b74d4e52c8e5a95eca27b5a0563f07.1428650683.git.viresh.kumar@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 73a317377303b5ec14d4703d73ba87efffbb779d
Author: Erik Hugne <erik.hugne@ericsson.com>
Date:   Thu Apr 23 09:37:40 2015 -0400

    tipc: fix node refcount issue
    
    When link statistics is dumped over netlink, we iterate over
    the list of peer nodes and append each links statistics to
    the netlink msg. In the case where the dump is resumed after
    filling up a nlmsg, the node refcnt is decremented without
    having been incremented previously which may cause the node
    reference to be freed. When this happens, the following
    info/stacktrace will be generated, followed by a crash or
    undefined behavior.
    We fix this by removing the erroneous call to tipc_node_put
    inside the loop that iterates over nodes.
    
    [  384.312303] INFO: trying to register non-static key.
    [  384.313110] the code is fine but needs lockdep annotation.
    [  384.313290] turning off the locking correctness validator.
    [  384.313290] CPU: 1 PID: 0 Comm: swapper/1 Not tainted 4.0.0+ #13
    [  384.313290] Hardware name: Bochs Bochs, BIOS Bochs 01/01/2011
    [  384.313290]  ffff88003c6d0290 ffff88003cc03ca8 ffffffff8170adf1 0000000000000007
    [  384.313290]  ffffffff82728730 ffff88003cc03d38 ffffffff810a6a6d 00000000001d7200
    [  384.313290]  ffff88003c6d0ab0 ffff88003cc03ce8 0000000000000285 0000000000000001
    [  384.313290] Call Trace:
    [  384.313290]  <IRQ>  [<ffffffff8170adf1>] dump_stack+0x4c/0x65
    [  384.313290]  [<ffffffff810a6a6d>] __lock_acquire+0xf3d/0xf50
    [  384.313290]  [<ffffffff810a7375>] lock_acquire+0xd5/0x290
    [  384.313290]  [<ffffffffa0043e8c>] ? link_timeout+0x1c/0x170 [tipc]
    [  384.313290]  [<ffffffffa0043e70>] ? link_state_event+0x4e0/0x4e0 [tipc]
    [  384.313290]  [<ffffffff81712890>] _raw_spin_lock_bh+0x40/0x80
    [  384.313290]  [<ffffffffa0043e8c>] ? link_timeout+0x1c/0x170 [tipc]
    [  384.313290]  [<ffffffffa0043e8c>] link_timeout+0x1c/0x170 [tipc]
    [  384.313290]  [<ffffffff810c4698>] call_timer_fn+0xb8/0x490
    [  384.313290]  [<ffffffff810c45e0>] ? process_timeout+0x10/0x10
    [  384.313290]  [<ffffffff810c5a2c>] run_timer_softirq+0x21c/0x420
    [  384.313290]  [<ffffffffa0043e70>] ? link_state_event+0x4e0/0x4e0 [tipc]
    [  384.313290]  [<ffffffff8105a954>] __do_softirq+0xf4/0x630
    [  384.313290]  [<ffffffff8105afdd>] irq_exit+0x5d/0x60
    [  384.313290]  [<ffffffff8103ade1>] smp_apic_timer_interrupt+0x41/0x50
    [  384.313290]  [<ffffffff817144a0>] apic_timer_interrupt+0x70/0x80
    [  384.313290]  <EOI>  [<ffffffff8100db10>] ? default_idle+0x20/0x210
    [  384.313290]  [<ffffffff8100db0e>] ? default_idle+0x1e/0x210
    [  384.313290]  [<ffffffff8100e61a>] arch_cpu_idle+0xa/0x10
    [  384.313290]  [<ffffffff81099803>] cpu_startup_entry+0x2c3/0x530
    [  384.313290]  [<ffffffff810d2893>] ? clockevents_register_device+0x113/0x200
    [  384.313290]  [<ffffffff81038b0f>] start_secondary+0x13f/0x170
    
    Fixes: 8a0f6ebe8494 ("tipc: involve reference counter for node structure")
    Signed-off-by: Erik Hugne <erik.hugne@ericsson.com>
    Signed-off-by: Jon Maloy <jon.maloy@ericsson.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 1a6fe5b612b4f9a18f87b6c2c9e4ee51731caf25
Author: Preeti U Murthy <preeti@linux.vnet.ibm.com>
Date:   Wed Mar 18 16:19:27 2015 +0530

    timers/tick/broadcast-hrtimer: Fix suspicious RCU usage in idle loop
    
    commit a127d2bcf1fbc8c8e0b5cf0dab54f7d3ff50ce47 upstream.
    
    The hrtimer mode of broadcast queues hrtimers in the idle entry
    path so as to wakeup cpus in deep idle states. The associated
    call graph is :
    
            cpuidle_idle_call()
            |____ clockevents_notify(CLOCK_EVT_NOTIFY_BROADCAST_ENTER, ....))
                 |_____tick_broadcast_set_event()
                       |____clockevents_program_event()
                            |____bc_set_next()
    
    The hrtimer_{start/cancel} functions call into tracing which uses RCU.
    But it is not legal to call into RCU in cpuidle because it is one of the
    quiescent states. Hence protect this region with RCU_NONIDLE which informs
    RCU that the cpu is momentarily non-idle.
    
    As an aside it is helpful to point out that the clock event device that is
    programmed here is not a per-cpu clock device; it is a
    pseudo clock device, used by the broadcast framework alone.
    The per-cpu clock device programming never goes through bc_set_next().
    
    Signed-off-by: Preeti U Murthy <preeti@linux.vnet.ibm.com>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Reviewed-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Cc: linuxppc-dev@ozlabs.org
    Cc: mpe@ellerman.id.au
    Cc: tglx@linutronix.de
    Link: http://lkml.kernel.org/r/20150318104705.17763.56668.stgit@preeti.in.ibm.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 5820c59b7d2b67f3ffadfb88d85dd2ce81b1241f
Author: Yongbae Park <yongbae2@gmail.com>
Date:   Tue Mar 3 13:05:48 2015 +0900

    clockevents: sun5i: Fix setup_irq init sequence
    
    [ Upstream commit 1096be084ac59927158ce80ff1d31c33eed0e565 ]
    
    The interrupt is enabled before the handler is set. Even this bug
    did not appear, it is potentially dangerous as it can lead to a
    NULL pointer dereference.
    
    Fix the error by enabling the interrupt after
    clockevents_config_and_register() is called.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Yongbae Park <yongbae2@gmail.com>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Signed-off-by: Sasha Levin <sasha.levin@oracle.com>

commit 2a9fe3ca84afff6259820c4f62e579f41476becc
Author: Heiko Stuebner <heiko@sntech.de>
Date:   Tue Jan 20 23:47:30 2015 +0100

    rockchip: make sure timer7 is enabled on rk3288 platforms
    
    timer7 supplies the architected timer and thus as has to run when
    the system clocksource and clockevents drivers are registered.
    
    While it should be the responsibility of the bootloader to do this,
    and there exists a fix in a community u-boot, all u-boot based systems
    that actually shipped have the mentioned issue.
    
    Therefore to not require every developer to update their u-boot, add a
    snippet for this, enabling the timer early in the kernel.
    
    Signed-off-by: Heiko Stuebner <heiko@sntech.de>

commit 7fd56474db326f7a6df0e2a4e3a9600cc083ab9b
Merge: 49d2953c72c6 def747087e83
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Apr 13 11:08:28 2015 -0700

    Merge branch 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer updates from Ingo Molnar:
     "The main changes in this cycle were:
    
       - clockevents state machine cleanups and enhancements (Viresh Kumar)
    
       - clockevents broadcast notifier horror to state machine conversion
         and related cleanups (Thomas Gleixner, Rafael J Wysocki)
    
       - clocksource and timekeeping core updates (John Stultz)
    
       - clocksource driver updates and fixes (Ben Dooks, Dmitry Osipenko,
         Hans de Goede, Laurent Pinchart, Maxime Ripard, Xunlei Pang)
    
       - y2038 fixes (Xunlei Pang, John Stultz)
    
       - NMI-safe ktime_get_raw_fast() and general refactoring of the clock
         code, in preparation to perf's per event clock ID support (Peter
         Zijlstra)
    
       - generic sched/clock fixes, optimizations and cleanups (Daniel
         Thompson)
    
       - clockevents cpu_down() race fix (Preeti U Murthy)"
    
    * 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (94 commits)
      timers/PM: Drop unnecessary braces from tick_freeze()
      timers/PM: Fix up tick_unfreeze()
      timekeeping: Get rid of stale comment
      clockevents: Cleanup dead cpu explicitely
      clockevents: Make tick handover explicit
      clockevents: Remove broadcast oneshot control leftovers
      sched/idle: Use explicit broadcast oneshot control function
      ARM: Tegra: Use explicit broadcast oneshot control function
      ARM: OMAP: Use explicit broadcast oneshot control function
      intel_idle: Use explicit broadcast oneshot control function
      ACPI/idle: Use explicit broadcast control function
      ACPI/PAD: Use explicit broadcast oneshot control function
      x86/amd/idle, clockevents: Use explicit broadcast oneshot control functions
      clockevents: Provide explicit broadcast oneshot control functions
      clockevents: Remove the broadcast control leftovers
      ARM: OMAP: Use explicit broadcast control function
      intel_idle: Use explicit broadcast control function
      cpuidle: Use explicit broadcast control function
      ACPI/processor: Use explicit broadcast control function
      ACPI/PAD: Use explicit broadcast control function
      ...

commit 0e1e3b03a3edcc2fd5a56fbbbc03d6eec07146c9
Author: Yongbae Park <yongbae2@gmail.com>
Date:   Tue Mar 3 13:05:48 2015 +0900

    clockevents: sun5i: Fix setup_irq init sequence
    
    commit 1096be084ac59927158ce80ff1d31c33eed0e565 upstream.
    
    The interrupt is enabled before the handler is set. Even this bug
    did not appear, it is potentially dangerous as it can lead to a
    NULL pointer dereference.
    
    Fix the error by enabling the interrupt after
    clockevents_config_and_register() is called.
    
    Signed-off-by: Yongbae Park <yongbae2@gmail.com>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 1e529ecd360d27e5fb15782df14d9c5a43ecda13
Author: Yongbae Park <yongbae2@gmail.com>
Date:   Tue Mar 3 13:05:48 2015 +0900

    clockevents: sun5i: Fix setup_irq init sequence
    
    commit 1096be084ac59927158ce80ff1d31c33eed0e565 upstream.
    
    The interrupt is enabled before the handler is set. Even this bug
    did not appear, it is potentially dangerous as it can lead to a
    NULL pointer dereference.
    
    Fix the error by enabling the interrupt after
    clockevents_config_and_register() is called.
    
    Signed-off-by: Yongbae Park <yongbae2@gmail.com>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit a49b116dcb1265f238f3169507424257b0519069
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Apr 3 02:38:05 2015 +0200

    clockevents: Cleanup dead cpu explicitely
    
    clockevents_notify() is a leftover from the early design of the
    clockevents facility. It's really not a notification mechanism,
    it's a multiplex call. We are way better off to have explicit
    calls instead of this monstrosity.
    
    Split out the cleanup function for a dead cpu and invoke it
    directly from the cpu down code. Make it conditional on
    CPU_HOTPLUG as well.
    
    Temporary change, will be refined in the future.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    [ Rebased, added clockevents_notify() removal ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/1735025.raBZdQHM3m@vostro.rjw.lan
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 52c063d1adbc16c76e70fffa20727fcd4e9343b3
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Apr 3 02:37:24 2015 +0200

    clockevents: Make tick handover explicit
    
    clockevents_notify() is a leftover from the early design of the
    clockevents facility. It's really not a notification mechanism,
    it's a multiplex call. We are way better off to have explicit
    calls instead of this monstrosity.
    
    Split out the tick_handover call and invoke it explicitely from
    the hotplug code. Temporary solution will be cleaned up in later
    patches.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    [ Rebase ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Link: http://lkml.kernel.org/r/1658173.RkEEILFiQZ@vostro.rjw.lan
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit ffa48c0d76803057ee89bf220305466d74256d7b
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Apr 3 02:36:10 2015 +0200

    clockevents: Remove broadcast oneshot control leftovers
    
    Now that all users are converted over to explicit calls into the
    clockevents state machine, remove the notification chain leftovers.
    
    Original-from: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: John Stultz <john.stultz@linaro.org>
    Link: http://lkml.kernel.org/r/14018863.NQUzkFuafr@vostro.rjw.lan
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 335f49196fd6011521f078cb44f445847e5aa183
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Apr 3 02:34:49 2015 +0200

    sched/idle: Use explicit broadcast oneshot control function
    
    Replace the clockevents_notify() call with an explicit function call.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/6422336.RMm7oUHcXh@vostro.rjw.lan
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit a0b4122447a3c1a467ce4e4f1bb863e1170394d5
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Apr 3 02:32:14 2015 +0200

    ARM: Tegra: Use explicit broadcast oneshot control function
    
    Replace the clockevents_notify() call with an explicit function call.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: Alexandre Courbot <gnurou@gmail.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Stephen Warren <swarren@wwwdotorg.org>
    Cc: Thierry Reding <thierry.reding@gmail.com>
    Link: http://lkml.kernel.org/r/2131111.rjxRLX1eZB@vostro.rjw.lan
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit fb7f0398a98020def9429ddd7b4a8fc2d948b092
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Apr 3 02:31:29 2015 +0200

    ARM: OMAP: Use explicit broadcast oneshot control function
    
    Replace the clockevents_notify() call with an explicit function call.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Tony Lindgren <tony@atomide.com>
    Link: http://lkml.kernel.org/r/3123047.uVjevtxDV7@vostro.rjw.lan
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit f6cee191fc6b286f9056a13456c4c8ade0aeb890
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Apr 3 02:14:23 2015 +0200

    intel_idle: Use explicit broadcast oneshot control function
    
    Replace the clockevents_notify() call with an explicit function call.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: Len Brown <lenb@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/20714596.QMfNNPbuyU@vostro.rjw.lan
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 7815701c5cd7276b712d898b3cf49c55e587dbb1
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Apr 3 02:12:03 2015 +0200

    ACPI/idle: Use explicit broadcast control function
    
    Replace the clockevents_notify() call with an explicit function call.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/2653377.MSAlfA939I@vostro.rjw.lan
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit c79521354e71a1fbcee040ee3147cadc0f8e3c97
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Apr 3 02:06:37 2015 +0200

    ACPI/PAD: Use explicit broadcast oneshot control function
    
    Replace the clockevents_notify() call with an explicit function call.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: Len Brown <lenb@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/1552509.UntNmyqF5v@vostro.rjw.lan
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 435c350e8197488f12c97e7df28a9c2199bd1673
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Apr 3 02:05:53 2015 +0200

    x86/amd/idle, clockevents: Use explicit broadcast oneshot control functions
    
    Replace the clockevents_notify() call with an explicit function call.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/8569669.lgxIty9PKW@vostro.rjw.lan
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 1fe5d5c3c9ba0c4ade18e3325cba0ffe35127941
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Apr 3 02:05:15 2015 +0200

    clockevents: Provide explicit broadcast oneshot control functions
    
    clockevents_notify() is a leftover from the early design of the
    clockevents facility. It's really not a notification mechanism,
    it's a multiplex call. We are way better off to have explicit
    calls instead of this monstrosity.
    
    Split out the broadcast oneshot control into a separate function
    and provide inline helpers. Switch clockevents_notify() over.
    This will go away once all callers are converted.
    
    This also gets rid of the nested locking of clockevents_lock and
    broadcast_lock. The broadcast oneshot control functions do not
    require clockevents_lock. Only the managing functions
    (setup/shutdown/suspend/resume of the broadcast device require
    clockevents_lock.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: Alexandre Courbot <gnurou@gmail.com>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: Len Brown <lenb@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Stephen Warren <swarren@wwwdotorg.org>
    Cc: Thierry Reding <thierry.reding@gmail.com>
    Cc: Tony Lindgren <tony@atomide.com>
    Link: http://lkml.kernel.org/r/13000649.8qZuEDV0OA@vostro.rjw.lan
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 89feddbfe7023ccfb4a6d7f5e3f5161d91b28b18
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Apr 3 02:03:42 2015 +0200

    clockevents: Remove the broadcast control leftovers
    
    All users converted. Remove the notify leftovers.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/2076318.76XJZ8QYP3@vostro.rjw.lan
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit fa8589fe3bfafadd80677c8eabae97dc5dab22c0
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Apr 3 02:02:47 2015 +0200

    ARM: OMAP: Use explicit broadcast control function
    
    Replace the clockevents_notify() call with an explicit function call.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Tony Lindgren <tony@atomide.com>
    Link: http://lkml.kernel.org/r/2124877.3nbWGILHCV@vostro.rjw.lan
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 76962caa4b691ad09556903602143fc8b16802ae
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Apr 3 02:02:34 2015 +0200

    intel_idle: Use explicit broadcast control function
    
    Replace the clockevents_notify() call with an explicit function call.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: Len Brown <lenb@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/3878165.rXNXrtVNuy@vostro.rjw.lan
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit ee7a1438b548fb5e206058d6bd0e2a5adf081dbf
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Apr 3 02:02:18 2015 +0200

    cpuidle: Use explicit broadcast control function
    
    Replace the clockevents_notify() call with an explicit function call.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/2106401.cYdJzzA6Ic@vostro.rjw.lan
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit ee41eebf9cef624b2e766a4b8688eeeedb65114c
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Apr 3 02:02:00 2015 +0200

    ACPI/processor: Use explicit broadcast control function
    
    Replace the clockevents_notify() call with an explicit function call.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/25071624.dkenaL3SGT@vostro.rjw.lan
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 979081e7440056da28b19e57acf20098caf49103
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Apr 3 02:01:49 2015 +0200

    ACPI/PAD: Use explicit broadcast control function
    
    Replace the clockevents_notify() call with an explicit function call.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: Len Brown <lenb@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/1521832.mm0ZfkTzTA@vostro.rjw.lan
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 162a688e84df49c5bcc855a5e5bf812d0ec89ad5
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Apr 3 02:01:28 2015 +0200

    x86/amd/idle, clockevents: Use explicit broadcast control function
    
    Replace the clockevents_notify() call with an explicit function call.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/1528188.S1pjqkSL1P@vostro.rjw.lan
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 592a438ff3fea61d303c5784c209b3f1fd3e16df
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Apr 3 02:01:10 2015 +0200

    clockevents: Provide explicit broadcast control functions
    
    clockevents_notify() is a leftover from the early design of the
    clockevents facility. It's really not a notification mechanism,
    it's a multiplex call. We are way better off to have explicit
    calls instead of this monstrosity.
    
    Split out the broadcast control into a separate function and
    provide inline helpers. Switch clockevents_notify() over. This
    will go away once all callers are converted.
    
    This also gets rid of the nested locking of clockevents_lock and
    broadcast_lock. The broadcast control functions do not require
    clockevents_lock. Only the managing functions
    (setup/shutdown/suspend/resume of the broadcast device require
    clockevents_lock.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: Len Brown <lenb@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Tony Lindgren <tony@atomide.com>
    Link: http://lkml.kernel.org/r/8086559.ttsuS0n1Xr@vostro.rjw.lan
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 3ff70551a942b4c1d3c2e96e31a5c6e369a6d0be
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Apr 3 01:46:34 2015 +0200

    ACPI/PAD: Remove the local APIC nonsense
    
    While looking through the (ab)use of the clockevents_notify()
    function I stumbled over the following gem in the acpi_pad code:
    
      if (lapic_detected_unstable && !lapic_marked_unstable) {
         /* LAPIC could halt in idle, so notify users */
         for_each_online_cpu(i)
           clockevents_notify(CLOCK_EVT_NOTIFY_BROADCAST_ON, &i);
         lapic_marked_unstable = 1;
      }
    
    This code calls on the cpu which detects the lapic unstable
    condition first clockevents_notify() to tell the core code that
    the broadcast should be enabled on all online cpus. Brilliant
    stuff that as it notifies the core code a num_online_cpus()
    times that the broadcast should be enabled on the current cpu.
    
    This probably has never been noticed because that code got never
    tested with NOHZ=n and HIGHRES_TIMER=n or it just worked by
    chance because one of the other mechanisms told the core in the
    right way that the local apic timer is wreckaged.
    
    Sigh, this is:
    
     - The 4th incarnation of idle drivers which has their own mechanism
       to detect and deal with X86_FEATURE_ARAT.
    
     - The 2nd incarnation of fake idle mechanisms with a different set of
       brainmelting bugs.
    
     - Has been merged against an explicit NAK of the scheduler
       maintainer with the promise to improve it over time.
    
     - Another example of featuritis driven trainwreck engineering.
    
     - Another pointless waste of my time.
    
    Fix this nonsense by removing that lapic detection and
    notification logic and simply call into the clockevents code
    unconditonally. The ARAT feature is marked in the lapic
    clockevent already so the core code will just ignore the
    requests and return.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/1887788.RObRuI4tSv@vostro.rjw.lan
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 345527b1edce8df719e0884500c76832a18211c3
Author: Preeti U Murthy <preeti@linux.vnet.ibm.com>
Date:   Mon Mar 30 14:59:19 2015 +0530

    clockevents: Fix cpu_down() race for hrtimer based broadcasting
    
    It was found when doing a hotplug stress test on POWER, that the
    machine either hit softlockups or rcu_sched stall warnings.  The
    issue was traced to commit:
    
      7cba160ad789 ("powernv/cpuidle: Redesign idle states management")
    
    which exposed the cpu_down() race with hrtimer based broadcast mode:
    
      5d1638acb9f6 ("tick: Introduce hrtimer based broadcast")
    
    The race is the following:
    
    Assume CPU1 is the CPU which holds the hrtimer broadcasting duty
    before it is taken down.
    
            CPU0                                    CPU1
    
            cpu_down()                              take_cpu_down()
                                                    disable_interrupts()
    
            cpu_die()
    
            while (CPU1 != CPU_DEAD) {
                    msleep(100);
                    switch_to_idle();
                    stop_cpu_timer();
                    schedule_broadcast();
            }
    
            tick_cleanup_cpu_dead()
                    take_over_broadcast()
    
    So after CPU1 disabled interrupts it cannot handle the broadcast
    hrtimer anymore, so CPU0 will be stuck forever.
    
    Fix this by explicitly taking over broadcast duty before cpu_die().
    
    This is a temporary workaround. What we really want is a callback
    in the clockevent device which allows us to do that from the dying
    CPU by pushing the hrtimer onto a different cpu. That might involve
    an IPI and is definitely more complex than this immediate fix.
    
    Changelog was picked up from:
    
        https://lkml.org/lkml/2015/2/16/213
    
    Suggested-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Nicolas Pitre <nico@linaro.org>
    Signed-off-by: Preeti U. Murthy <preeti@linux.vnet.ibm.com>
    Cc: linuxppc-dev@lists.ozlabs.org
    Cc: mpe@ellerman.id.au
    Cc: nicolas.pitre@linaro.org
    Cc: peterz@infradead.org
    Cc: rjw@rjwysocki.net
    Fixes: http://linuxppc.10917.n7.nabble.com/offlining-cpus-breakage-td88619.html
    Link: http://lkml.kernel.org/r/20150330092410.24979.59887.stgit@preeti.in.ibm.com
    [ Merged it to the latest timer tree, renamed the callback, tidied up the changelog. ]
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 9eed56e889d8a0bb7870e1216d8d4326dd63ec50
Author: Ingo Molnar <mingo@kernel.org>
Date:   Thu Apr 2 11:26:23 2015 +0200

    clockevents: Clean up clockchips.h
    
    Do various cleanups on the clockchips.h file:
    
     - indent preprocessor blocks to make it more clear which block we are in,
       this also makes merge resolution easier
    
     - comment larger preprocessor blocks consistently, using the:
    
         #if FOO
         ...
         #else /* !FOO: */
         ...
         #endif /* !FOO */
    
       notation.
    
     - unbreak lines
    
     - etc.
    
    No change in functionality.
    
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 3ae7a939165c6159afb3c09e1d7405b6d1807f2b
Author: Ingo Molnar <mingo@kernel.org>
Date:   Thu Apr 2 11:26:06 2015 +0200

    tick: Further simplify tick-internal.h
    
    Move the broadcasting related section to the GENERIC_CLOCKEVENTS=y
    section - this also solves build failures on architectures that
    don't use generic clockevents yet.
    
    Also standardize include file style to make it easier to read, and
    use nesting depth aware preprocessor directives to make future merges
    easier.
    
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 4ffee521f36390c7720d493591b764ca35c8030b
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Mar 25 13:09:16 2015 +0100

    clockevents: Make suspend/resume calls explicit
    
    clockevents_notify() is a leftover from the early design of the
    clockevents facility. It's really not a notification mechanism,
    it's a multiplex call.
    
    We are way better off to have explicit calls instead of this
    monstrosity. Split out the suspend/resume() calls and invoke
    them directly from the call sites.
    
    No locking required at this point because these calls happen
    with interrupts disabled and a single cpu online.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    [ Rebased on top of 4.0-rc5. ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/713674030.jVm1qaHuPf@vostro.rjw.lan
    [ Rebased on top of latest timers/core. ]
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit db6f672ef11d7a3c5aa128a3c3e57c92580a25f7
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Mar 25 13:08:27 2015 +0100

    clockevents: Remove extra local_irq_save() in clockevents_exchange_device()
    
    Called with 'clockevents_lock' held and interrupts disabled
    already.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/51005827.yXt5tjZMBs@vostro.rjw.lan
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 9f083b74df3a7eaa100b456f2dc195512daf728e
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Mar 25 13:05:19 2015 +0100

    clockevents: Remove CONFIG_GENERIC_CLOCKEVENTS_BUILD
    
    This option was for simpler migration to the clock events code.
    Most architectures have been converted and the option has been
    disfunctional as a standalone option for quite some time. Remove
    it.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/5021859.jl9OC1medj@vostro.rjw.lan
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 6cbc6fd5f987aea28ede4c2774830f0c48b885e6
Author: Preeti U Murthy <preeti@linux.vnet.ibm.com>
Date:   Wed Mar 18 16:19:27 2015 +0530

    timers/tick/broadcast-hrtimer: Fix suspicious RCU usage in idle loop
    
    commit a127d2bcf1fbc8c8e0b5cf0dab54f7d3ff50ce47 upstream.
    
    The hrtimer mode of broadcast queues hrtimers in the idle entry
    path so as to wakeup cpus in deep idle states. The associated
    call graph is :
    
            cpuidle_idle_call()
            |____ clockevents_notify(CLOCK_EVT_NOTIFY_BROADCAST_ENTER, ....))
                 |_____tick_broadcast_set_event()
                       |____clockevents_program_event()
                            |____bc_set_next()
    
    The hrtimer_{start/cancel} functions call into tracing which uses RCU.
    But it is not legal to call into RCU in cpuidle because it is one of the
    quiescent states. Hence protect this region with RCU_NONIDLE which informs
    RCU that the cpu is momentarily non-idle.
    
    As an aside it is helpful to point out that the clock event device that is
    programmed here is not a per-cpu clock device; it is a
    pseudo clock device, used by the broadcast framework alone.
    The per-cpu clock device programming never goes through bc_set_next().
    
    Signed-off-by: Preeti U Murthy <preeti@linux.vnet.ibm.com>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Reviewed-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Cc: linuxppc-dev@ozlabs.org
    Cc: mpe@ellerman.id.au
    Cc: tglx@linutronix.de
    Link: http://lkml.kernel.org/r/20150318104705.17763.56668.stgit@preeti.in.ibm.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Luis Henriques <luis.henriques@canonical.com>

commit 724cfb0b6b5f4dc18a2567b7a5b5ef66bc750405
Author: Yongbae Park <yongbae2@gmail.com>
Date:   Tue Mar 3 13:05:48 2015 +0900

    clockevents: sun5i: Fix setup_irq init sequence
    
    commit 1096be084ac59927158ce80ff1d31c33eed0e565 upstream.
    
    The interrupt is enabled before the handler is set. Even this bug
    did not appear, it is potentially dangerous as it can lead to a
    NULL pointer dereference.
    
    Fix the error by enabling the interrupt after
    clockevents_config_and_register() is called.
    
    Signed-off-by: Yongbae Park <yongbae2@gmail.com>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Signed-off-by: Luis Henriques <luis.henriques@canonical.com>

commit de81e64b250d3865a75d221a80b4311e3273670a
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Feb 27 17:21:34 2015 +0530

    clockevents: Don't validate dev->mode against CLOCK_EVT_MODE_UNUSED for new interface
    
    It was a requirement in the legacy interface that drivers must
    initialize ->mode field to 'CLOCK_EVT_MODE_UNUSED'. This field
    isn't used anymore by the new interface and so should be only
    checked for the legacy interface.
    
    Probably it can be dropped as well as core doesn't rely on it
    anymore, but lets keep it to support legacy interface.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Kevin Hilman <khilman@linaro.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Preeti U Murthy <preeti@linux.vnet.ibm.com>
    Cc: linaro-kernel@lists.linaro.org
    Cc: linaro-networking@linaro.org
    Cc: linux-arm-kernel@lists.infradead.org
    Link: http://lkml.kernel.org/r/c6604fa1a77fe1fc8dcab87769857228fb1dadd5.1425037853.git.viresh.kumar@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 77e32c89a7117614ab3d66d20c1088de721abfaa
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Feb 27 17:21:33 2015 +0530

    clockevents: Manage device's state separately for the core
    
    'enum clock_event_mode' is used for two purposes today:
    
     - to pass mode to the driver of clockevent device::set_mode().
    
     - for managing state of the device for clockevents core.
    
    For supporting new modes/states we have moved away from the
    legacy set_mode() callback to new per-mode/state callbacks. New
    modes/states shouldn't be exposed to the legacy (now OBSOLOTE)
    callbacks and so we shouldn't add new states to 'enum
    clock_event_mode'.
    
    Lets have separate enums for the two use cases mentioned above.
    Keep using the earlier enum for legacy set_mode() callback and
    mark it OBSOLETE. And add another enum to clearly specify the
    possible states of a clockevent device.
    
    This also renames the newly added per-mode callbacks to reflect
    state changes.
    
    We haven't got rid of 'mode' member of 'struct
    clock_event_device' as it is used by some of the clockevent
    drivers and it would automatically die down once we migrate
    those drivers to the new interface. It ('mode') is only updated
    now for the drivers using the legacy interface.
    
    Suggested-by: Peter Zijlstra <peterz@infradead.org>
    Suggested-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Kevin Hilman <khilman@linaro.org>
    Cc: Preeti U Murthy <preeti@linux.vnet.ibm.com>
    Cc: linaro-kernel@lists.linaro.org
    Cc: linaro-networking@linaro.org
    Cc: linux-arm-kernel@lists.infradead.org
    Link: http://lkml.kernel.org/r/b6b0143a8a57bd58352ad35e08c25424c879c0cb.1425037853.git.viresh.kumar@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 554ef3876c6acdff1331feab10275e9e9e0adb84
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Feb 27 17:21:32 2015 +0530

    clockevents: Handle tick device's resume separately
    
    Upcoming patch will redefine possible states of a clockevent
    device. The RESUME mode is a special case only for tick's
    clockevent devices. In future it can be replaced by ->resume()
    callback already available for clockevent devices.
    
    Lets handle it separately so that clockevents_set_mode() only
    handles states valid across all devices. This also renames
    set_mode_resume() to tick_resume() to make it more explicit.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Kevin Hilman <khilman@linaro.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Preeti U Murthy <preeti@linux.vnet.ibm.com>
    Cc: linaro-kernel@lists.linaro.org
    Cc: linaro-networking@linaro.org
    Cc: linux-arm-kernel@lists.infradead.org
    Link: http://lkml.kernel.org/r/c1b0112410870f49e7bf06958e1483eac6c15e20.1425037853.git.viresh.kumar@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit ed9fd3ff0251783cb3943e71aac398b9064efae6
Author: Rabin Vincent <rabin@rab.in>
Date:   Sun Mar 8 16:29:12 2015 +0100

    CRISv32: use generic clockevents
    
    Implement a oneshot-capable clockevents device so we get support for
    things like hrtimers and NOHZ.
    
    Signed-off-by: Rabin Vincent <rabin@rab.in>
    Signed-off-by: Jesper Nilsson <jespern@axis.com>

commit a127d2bcf1fbc8c8e0b5cf0dab54f7d3ff50ce47
Author: Preeti U Murthy <preeti@linux.vnet.ibm.com>
Date:   Wed Mar 18 16:19:27 2015 +0530

    timers/tick/broadcast-hrtimer: Fix suspicious RCU usage in idle loop
    
    The hrtimer mode of broadcast queues hrtimers in the idle entry
    path so as to wakeup cpus in deep idle states. The associated
    call graph is :
    
            cpuidle_idle_call()
            |____ clockevents_notify(CLOCK_EVT_NOTIFY_BROADCAST_ENTER, ....))
                 |_____tick_broadcast_set_event()
                       |____clockevents_program_event()
                            |____bc_set_next()
    
    The hrtimer_{start/cancel} functions call into tracing which uses RCU.
    But it is not legal to call into RCU in cpuidle because it is one of the
    quiescent states. Hence protect this region with RCU_NONIDLE which informs
    RCU that the cpu is momentarily non-idle.
    
    As an aside it is helpful to point out that the clock event device that is
    programmed here is not a per-cpu clock device; it is a
    pseudo clock device, used by the broadcast framework alone.
    The per-cpu clock device programming never goes through bc_set_next().
    
    Signed-off-by: Preeti U Murthy <preeti@linux.vnet.ibm.com>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Reviewed-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Cc: linuxppc-dev@ozlabs.org
    Cc: mpe@ellerman.id.au
    Cc: tglx@linutronix.de
    Link: http://lkml.kernel.org/r/20150318104705.17763.56668.stgit@preeti.in.ibm.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 13326e5a620df5063df2e87b38d923785066ee63
Merge: 8e6e44fbd230 d415a7f1c1a8 9ab2b7f3acfa
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Mar 17 13:22:29 2015 -0700

    Merge branches 'perf-urgent-for-linus' and 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull perf and timer fixes from Ingo Molnar:
     "Two small perf fixes:
       - kernel side context leak fix
       - tooling crash fix
    
      And two clocksource driver fixes"
    
    * 'perf-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      perf: Fix context leak in put_event()
      perf annotate: Fix fallback to unparsed disassembler line
    
    * 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      clockevents: sun5i: Fix setup_irq init sequence
      clocksource: efm32: Fix a NULL pointer dereference

commit 9ab2b7f3acfa5490f36c9e5774a2bfecd01943db
Merge: 13a7a6ac0a11 1096be084ac5
Author: Ingo Molnar <mingo@kernel.org>
Date:   Thu Mar 5 17:46:31 2015 +0100

    Merge branch 'clockevents/4.0-rc2' of http://git.linaro.org/people/daniel.lezcano/linux into timers/urgent
    
    Pull clockevents fixes from Daniel Lezcano:
    
     " These two patches fix a potential crash at boot time.
    
       - Fix setup_irq / clockevents_config_and_register init ordering in order to
         prevent to have an interrupt to be fired before the handler is set for sun5i
         and efm32. (Yongbae Park)"
    
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 1096be084ac59927158ce80ff1d31c33eed0e565
Author: Yongbae Park <yongbae2@gmail.com>
Date:   Tue Mar 3 13:05:48 2015 +0900

    clockevents: sun5i: Fix setup_irq init sequence
    
    The interrupt is enabled before the handler is set. Even this bug
    did not appear, it is potentially dangerous as it can lead to a
    NULL pointer dereference.
    
    Fix the error by enabling the interrupt after
    clockevents_config_and_register() is called.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Yongbae Park <yongbae2@gmail.com>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit e086748c655ab99bac91b87d1bb59d9cc45867b9
Author: Vitaly Kuznetsov <vkuznets@redhat.com>
Date:   Fri Feb 27 11:25:57 2015 -0800

    Drivers: hv: vmbus: Teardown clockevent devices on module unload
    
    Newly introduced clockevent devices made it impossible to unload hv_vmbus
    module as clockevents_config_and_register() takes additional reverence to
    the module. To make it possible again we do the following:
    - avoid setting dev->owner for clockevent devices;
    - implement hv_synic_clockevents_cleanup() doing clockevents_unbind_device();
    - call it from vmbus_exit().
    
    In theory hv_synic_clockevents_cleanup() can be merged with hv_synic_cleanup(),
    however, we call hv_synic_cleanup() from smp_call_function_single() and this
    doesn't work for clockevents_unbind_device() as it does such call on its own. I
    opted for a separate function.
    
    Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 32a158325acf12842764b1681f53903673f2f22e
Author: Vitaly Kuznetsov <vkuznets@redhat.com>
Date:   Fri Feb 27 11:25:56 2015 -0800

    clockevents: export clockevents_unbind_device instead of clockevents_unbind
    
    It looks like clockevents_unbind is being exported by mistake as:
    - it is static;
    - it is not listed in include/linux/clockchips.h;
    - EXPORT_SYMBOL_GPL(clockevents_unbind) follows clockevents_unbind_device()
      implementation.
    
    I think clockevents_unbind_device should be exported instead. This is going to
    be used to teardown Hyper-V clockevent devices on module unload.
    
    Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 640c0f5c57864cbc1f495509bdc879fab94d4d9d
Merge: d7b48fec3520 e3eff6fe7d8a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Mar 1 12:00:25 2015 -0800

    Merge branch 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer fixes from Ingo Molnar:
     "Three clockevents/clocksource driver fixes"
    
    * 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      clocksource: pxa: Fix section mismatch
      clocksource: mtk: Fix race conditions in probe code
      clockevents: asm9260: Fix compilation error with sparc/sparc64 allyesconfig

commit e3eff6fe7d8a877d94f5dbb8fea46b4f8ca4ce5a
Merge: b24e2bdde4af 6f2116ebe24f
Author: Ingo Molnar <mingo@kernel.org>
Date:   Wed Feb 25 14:44:45 2015 +0100

    Merge branch 'clockevents/4.0-rc1' of git://git.linaro.org/people/daniel.lezcano/linux into timers/urgent
    
    Pull clockevents driver fixes from Daniel Lezcano:
    
      - Fix the Kconfig to prevent the asm9260 timer to be compiled with
        allyesconfig with sparc/sparc64 (Daniel Lezcano)
    
      - Reorder the mtk driver init sequence in order to prevent a potential race
        when the clock is registered before the irq handler is set (Matthias Brugger)
    
      - Fix a section mismatch for the pxa driver (Robert Jarzmik)
    
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit a8b1b9fc927400045fb7631d5b12093aaf5d939d
Author: Daniel Lezcano <daniel.lezcano@linaro.org>
Date:   Mon Feb 23 19:54:16 2015 +0100

    clockevents: asm9260: Fix compilation error with sparc/sparc64 allyesconfig
    
    The Kconfig options for the asm9260 timer is wrong as it can be selected by
    another platform with allyes config and thus leading to a compilation failure
    as some non arch related code is pulled by the compilation.
    
    Fix this by having the platform Kconfig to select the timer as it is done for
    the others drivers.
    
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Acked-by: Guenter Roeck <linux@roeck-us.net>
    Acked-by: Oleksij Rempel <linux@rempel-privat.de>
    
    Conflicts:
            drivers/clocksource/Kconfig

commit bd624d75db21ea5402f9ecf4450b311794d80352
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Feb 13 08:54:56 2015 +0800

    clockevents: Introduce mode specific callbacks
    
    It is not possible for the clockevents core to know which modes (other than
    those with a corresponding feature flag) are supported by a particular
    implementation. And drivers are expected to handle transition to all modes
    elegantly, as ->set_mode() would be issued for them unconditionally.
    
    Now, adding support for a new mode complicates things a bit if we want to use
    the legacy ->set_mode() callback. We need to closely review all clockevents
    drivers to see if they would break on addition of a new mode. And after such
    reviews, it is found that we have to do non-trivial changes to most of the
    drivers [1].
    
    Introduce mode-specific set_mode_*() callbacks, some of which the drivers may or
    may not implement. A missing callback would clearly convey the message that the
    corresponding mode isn't supported.
    
    A driver may still choose to keep supporting the legacy ->set_mode() callback,
    but ->set_mode() wouldn't be supporting any new modes beyond RESUME. If a driver
    wants to benefit from using a new mode, it would be required to migrate to
    the mode specific callbacks.
    
    The legacy ->set_mode() callback and the newly introduced mode-specific
    callbacks are mutually exclusive. Only one of them should be supported by the
    driver.
    
    Sanity check is done at the time of registration to distinguish between optional
    and required callbacks and to make error recovery and handling simpler. If the
    legacy ->set_mode() callback is provided, all mode specific ones would be
    ignored by the core but a warning is thrown if they are present.
    
    Call sites calling ->set_mode() directly are also updated to use
    __clockevents_set_mode() instead, as ->set_mode() may not be available anymore
    for few drivers.
    
     [1] https://lkml.org/lkml/2014/12/9/605
     [2] https://lkml.org/lkml/2015/1/23/255
    
    Suggested-by: Thomas Gleixner <tglx@linutronix.de> [2]
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Kevin Hilman <khilman@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Preeti U Murthy <preeti@linux.vnet.ibm.com>
    Cc: linaro-kernel@lists.linaro.org
    Cc: linaro-networking@linaro.org
    Link: http://lkml.kernel.org/r/792d59a40423f0acffc9bb0bec9de1341a06fa02.1423788565.git.viresh.kumar@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 8c334ce8f0fec7122fc3059c52a697b669a01b41
Merge: 3c6847eaa3da f40d149b58f5
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Feb 16 15:26:10 2015 -0800

    Merge branch 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull clocksource updates from Ingo Molnar:
     "The main change in this tree is the addition of various new SoC
      clocksource/clockevents drivers: Conexant Digicolor SoCs, rockchip
      rk3288 board, asm9260 for MIPS and versatile AB/PB boards"
    
    * 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      dts: versatile: Add sysregs node
      clocksource: versatile: Adapt for Versatile AB and PB boards
      dt/bindings: Add binding for Versatile system registers
      clocksource: Driver for Conexant Digicolor SoC timer
      clocksource: devicetree: Document Conexant Digicolor timer binding
      clockevents: rockchip: Add rockchip timer for rk3288
      ARM: clocksource: Add asm9260_timer driver
      clocksource: marco: Rename marco to atlas7
      clocksource: sirf: Remove unused variable

commit f40d149b58f5dea148ceaee5f9249da133e5004c
Merge: 4ebbda525137 35a8578e8b83
Author: Ingo Molnar <mingo@kernel.org>
Date:   Mon Feb 9 11:20:36 2015 +0100

    Merge branch 'clockevents/3.20' of http://git.linaro.org/people/daniel.lezcano/linux into timers/core
    
    Pull clockevents updates from Daniel Lezcano:
    
       - Add new driver for the Conexant Digicolor SoCs (Baruch Siach)
    
       - Add new driver for the rockchip rk3288 board (Daniel Lezcano)
    
       - Add new asm9260 driver for MIPS (Oleksij Rempel)
    
       - Add DT definitions for the versatile AB/PB boards (Rob Herring)
    
       - Rename the 'marco' timer to 'atlas7' (Barry Song)
    
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 468b8c4cf3962d4d24eca58da18bb63368ff4fcd
Author: Daniel Lezcano <daniel.lezcano@linaro.org>
Date:   Sun Jan 25 22:06:02 2015 +0100

    clockevents: rockchip: Add rockchip timer for rk3288
    
    The rk3288 board uses the architected timers and these ones are shutdown when
    the cpu is powered down. There is a need of a broadcast timer in this case to
    ensure proper wakeup when the cpus are in sleep mode and a timer expires.
    
    This driver provides the basic timer functionnality as a backup for the local
    timers at sleep time.
    
    The timer belongs to the alive subsystem. It includes two programmables 64 bits
    timer channels but the driver only uses 32bits. It works with two operations
    mode: free running and user defined count.
    
    Programing sequence:
    
    1. Timer initialization:
     * Disable the timer by writing '0' to the CONTROLREG register
     * Program the timer mode by writing the mode to the CONTROLREG register
     * Set the interrupt mask
    
    2. Setting the count value:
     * Load the count value to the registers COUNT0 and COUNT1 (not used).
    
    3. Enable the timer
     * Write '1' to the CONTROLREG register with the mode (free running or user)
    
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Reviewed-by: Heiko Stuebner <heiko@sntech.de>

commit 17d1b500792b382169883c1e2415f1e930236128
Author: Martin Schwidefsky <schwidefsky@de.ibm.com>
Date:   Fri Nov 22 12:04:18 2013 +0100

    s390,time: revert direct ktime path for s390 clockevent device
    
    commit 8adbf78ec4839c1dc4ff20c9a1f332a7bc99e6e6 upstream.
    
    Git commit 4f37a68cdaf6dea833cfdded2a3e0c47c0f006da
    "s390: Use direct ktime path for s390 clockevent device" makes use
    of the CLOCK_EVT_FEAT_KTIME clockevent option to avoid the delta
    calculation with ktime_get() in clockevents_program_event and the
    get_tod_clock() in s390_next_event. This is based on the assumption
    that the difference between the internal ktime and the hardware
    clock is reflected in the wall_to_monotonic delta. But this is not
    true, the ntp corrections are applied via changes to the tk->mult
    multiplier and this is not reflected in wall_to_monotonic.
    
    In theory this could be solved by using the raw monotonic clock
    but it is simpler to switch back to the standard clock delta
    calculation.
    
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
    [bwh: Backported to 3.2: s/get_tod_clock()/get_clock()/]
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit 89de77a8c557f14d2713a1f43fbc33980e639b98
Merge: cb2aa63469f8 4a22d9c93af1
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Nov 27 11:47:10 2014 +0100

    Merge branch 'clockevents/3.19' of http://git.linaro.org/people/daniel.lezcano/linux into timers/core
    
    Daniel Lezcano muttered:
    
     * Marvell timer updates from Ezequiel Garcia
       - Add missing clock enable calls for armada
       - Change source clock for clocksource and watchdog
     * SIRF timer updates from Yanchang Li
       - Make clock rate configurable

commit b695d8e6ad6fba3d72b309b0d62128b04cf57160
Author: Andrew Bresticker <abrestic@chromium.org>
Date:   Mon Oct 20 12:04:05 2014 -0700

    clocksource: mips-gic: Use clockevents_config_and_register
    
    Use clockevents_config_and_register to setup the clock_event_device
    based on frequency and min/max ticks instead of doing it ourselves.
    
    Signed-off-by: Andrew Bresticker <abrestic@chromium.org>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Paul Burton <paul.burton@imgtec.com>
    Cc: Qais Yousef <qais.yousef@imgtec.com>
    Cc: John Crispin <blogic@openwrt.org>
    Cc: linux-mips@linux-mips.org
    Cc: linux-kernel@vger.kernel.org
    Patchwork: https://patchwork.linux-mips.org/patch/8140/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

commit cb95413971d605b0d152d3ceecc47ba8991d66fb
Merge: ecde00642c79 6bab4a8a1888
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Nov 22 14:33:11 2014 -0800

    Merge branch 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer fix from Thomas Gleixner:
     "A single bugfix for an init order problem in the sun4i subarch
      clockevents code"
    
    * 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      clockevent: sun4i: Fix race condition in the probe code

commit 0f4b06766bb6dc16c62c45607e3ccced23b7fead
Merge: bcdfdaee5a0d 59aa896db804
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Oct 31 12:33:05 2014 -0700

    Merge branch 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer fixes from Thomas Gleixner:
     "As you requested in the rc2 release mail the timer department serves
      you a few real bug fixes:
    
       - Fix the probe logic of the architected arm/arm64 timer
       - Plug a stack info leak in posix-timers
       - Prevent a shift out of bounds issue in the clockevents core"
    
    * 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      ARM/ARM64: arch-timer: fix arch_timer_probed logic
      clockevents: Prevent shift out of bounds
      posix-timers: Fix stack info leak in timer_create()

commit 10632008b9e18b76cbff0ffc69c15e948aa548e0
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Oct 20 15:07:50 2014 +0400

    clockevents: Prevent shift out of bounds
    
    Andrey reported that on a kernel with UBSan enabled he found:
    
         UBSan: Undefined behaviour in ../kernel/time/clockevents.c:75:34
    
         I guess it should be 1ULL here instead of 1U:
                (!ismax || evt->mult <= (1U << evt->shift)))
    
    That's indeed the correct solution because shift might be 32.
    
    Reported-by: Andrey Ryabinin <a.ryabinin@samsung.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 1e203c1a2c104c8f8030245d2afaa337a79b4375
Author: John Fastabend <john.fastabend@gmail.com>
Date:   Thu Oct 2 22:43:09 2014 -0700

    net: sched: suspicious RCU usage in qdisc_watchdog
    
    Suspicious RCU usage in qdisc_watchdog call needs to be done inside
    rcu_read_lock/rcu_read_unlock. And then Qdisc destroy operations
    need to ensure timer is cancelled before removing qdisc structure.
    
    [ 3992.191339] ===============================
    [ 3992.191340] [ INFO: suspicious RCU usage. ]
    [ 3992.191343] 3.17.0-rc6net-next+ #72 Not tainted
    [ 3992.191345] -------------------------------
    [ 3992.191347] include/net/sch_generic.h:272 suspicious rcu_dereference_check() usage!
    [ 3992.191348]
    [ 3992.191348] other info that might help us debug this:
    [ 3992.191348]
    [ 3992.191351]
    [ 3992.191351] rcu_scheduler_active = 1, debug_locks = 1
    [ 3992.191353] no locks held by swapper/1/0.
    [ 3992.191355]
    [ 3992.191355] stack backtrace:
    [ 3992.191358] CPU: 1 PID: 0 Comm: swapper/1 Not tainted 3.17.0-rc6net-next+ #72
    [ 3992.191360] Hardware name:                  /DZ77RE-75K, BIOS GAZ7711H.86A.0060.2012.1115.1750 11/15/2012
    [ 3992.191362]  0000000000000001 ffff880235803e48 ffffffff8178f92c 0000000000000000
    [ 3992.191366]  ffff8802322224a0 ffff880235803e78 ffffffff810c9966 ffff8800a5fe3000
    [ 3992.191370]  ffff880235803f30 ffff8802359cd768 ffff8802359cd6e0 ffff880235803e98
    [ 3992.191374] Call Trace:
    [ 3992.191376]  <IRQ>  [<ffffffff8178f92c>] dump_stack+0x4e/0x68
    [ 3992.191387]  [<ffffffff810c9966>] lockdep_rcu_suspicious+0xe6/0x130
    [ 3992.191392]  [<ffffffff8167213a>] qdisc_watchdog+0x8a/0xb0
    [ 3992.191396]  [<ffffffff810f93f2>] __run_hrtimer+0x72/0x420
    [ 3992.191399]  [<ffffffff810f9bcd>] ? hrtimer_interrupt+0x7d/0x240
    [ 3992.191403]  [<ffffffff816720b0>] ? tc_classify+0xc0/0xc0
    [ 3992.191406]  [<ffffffff810f9c4f>] hrtimer_interrupt+0xff/0x240
    [ 3992.191410]  [<ffffffff8109e4a5>] ? __atomic_notifier_call_chain+0x5/0x140
    [ 3992.191415]  [<ffffffff8103577b>] local_apic_timer_interrupt+0x3b/0x60
    [ 3992.191419]  [<ffffffff8179c2b5>] smp_apic_timer_interrupt+0x45/0x60
    [ 3992.191422]  [<ffffffff8179a6bf>] apic_timer_interrupt+0x6f/0x80
    [ 3992.191424]  <EOI>  [<ffffffff815ed233>] ? cpuidle_enter_state+0x73/0x2e0
    [ 3992.191432]  [<ffffffff815ed22e>] ? cpuidle_enter_state+0x6e/0x2e0
    [ 3992.191437]  [<ffffffff815ed567>] cpuidle_enter+0x17/0x20
    [ 3992.191441]  [<ffffffff810c0741>] cpu_startup_entry+0x3d1/0x4a0
    [ 3992.191445]  [<ffffffff81106fc6>] ? clockevents_config_and_register+0x26/0x30
    [ 3992.191448]  [<ffffffff81033c16>] start_secondary+0x1b6/0x260
    
    Fixes: b26b0d1e8b1 ("net: qdisc: use rcu prefix and silence sparse warnings")
    Signed-off-by: John Fastabend <john.r.fastabend@intel.com>
    Acked-by: Cong Wang <cwang@twopensource.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 867f667fb9c6734e06cc24e96fc7f06a7e772084
Merge: e1ce5c7adc73 fb0eee2f1419
Author: Daniel Lezcano <daniel.lezcano@linaro.org>
Date:   Mon Sep 29 01:59:51 2014 +0200

    Merge tag 'renesas-clocksource-for-v3.18' of git://git.kernel.org/pub/scm/linux/kernel/git/horms/renesas into clockevents/3.18
    
    Renesas Clocksource Updates for v3.18
    
    * Document per-SoC bindings
    
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit 2a16fc93d2c9568e16d45db77c7b5f15e1921cf1
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jun 12 16:24:41 2014 +0530

    nohz: Avoid tick's double reprogramming in highres mode
    
    In highres mode, the tick reschedules itself unconditionally to the
    next jiffies.
    
    However while this clock reprogramming is relevant when the tick is
    in periodic mode, it's not that interesting when we run in dynticks mode
    because irq exit is likely going to overwrite the next tick to some
    randomly deferred future.
    
    So lets just get rid of this tick self rescheduling in dynticks mode.
    This way we can avoid some clockevents double write in favourable
    scenarios like when we stop the tick completely in idle while no other
    hrtimer is pending.
    
    Suggested-by: Frederic Weisbecker <fweisbec@gmail.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>

commit 9ac1f1f2b7b385891a5a63d09337a2d66fd76673
Author: Dmitry Kravkov <Dmitry.Kravkov@qlogic.com>
Date:   Thu Jul 24 18:54:47 2014 +0300

    bnx2x: fix crash during TSO tunneling
    
    [ Upstream commit fe26566d8a05151ba1dce75081f6270f73ec4ae1 ]
    
    When TSO packet is transmitted additional BD w/o mapping is used
    to describe the packed. The BD needs special handling in tx
    completion.
    
    kernel: Call Trace:
    kernel: <IRQ>  [<ffffffff815e19ba>] dump_stack+0x19/0x1b
    kernel: [<ffffffff8105dee1>] warn_slowpath_common+0x61/0x80
    kernel: [<ffffffff8105df5c>] warn_slowpath_fmt+0x5c/0x80
    kernel: [<ffffffff814a8c0d>] ? find_iova+0x4d/0x90
    kernel: [<ffffffff814ab0e2>] intel_unmap_page.part.36+0x142/0x160
    kernel: [<ffffffff814ad0e6>] intel_unmap_page+0x26/0x30
    kernel: [<ffffffffa01f55d7>] bnx2x_free_tx_pkt+0x157/0x2b0 [bnx2x]
    kernel: [<ffffffffa01f8dac>] bnx2x_tx_int+0xac/0x220 [bnx2x]
    kernel: [<ffffffff8101a0d9>] ? read_tsc+0x9/0x20
    kernel: [<ffffffffa01f8fdb>] bnx2x_poll+0xbb/0x3c0 [bnx2x]
    kernel: [<ffffffff814d041a>] net_rx_action+0x15a/0x250
    kernel: [<ffffffff81067047>] __do_softirq+0xf7/0x290
    kernel: [<ffffffff815f3a5c>] call_softirq+0x1c/0x30
    kernel: [<ffffffff81014d25>] do_softirq+0x55/0x90
    kernel: [<ffffffff810673e5>] irq_exit+0x115/0x120
    kernel: [<ffffffff815f4358>] do_IRQ+0x58/0xf0
    kernel: [<ffffffff815e94ad>] common_interrupt+0x6d/0x6d
    kernel: <EOI>  [<ffffffff810bbff7>] ? clockevents_notify+0x127/0x140
    kernel: [<ffffffff814834df>] ? cpuidle_enter_state+0x4f/0xc0
    kernel: [<ffffffff81483615>] cpuidle_idle_call+0xc5/0x200
    kernel: [<ffffffff8101bc7e>] arch_cpu_idle+0xe/0x30
    kernel: [<ffffffff810b4725>] cpu_startup_entry+0xf5/0x290
    kernel: [<ffffffff815cfee1>] start_secondary+0x265/0x27b
    kernel: ---[ end trace 11aa7726f18d7e80 ]---
    
    Fixes: a848ade408b ("bnx2x: add CSUM and TSO support for encapsulation protocols")
    Reported-by: Yulong Pei <ypei@redhat.com>
    Cc: Michal Schmidt <mschmidt@redhat.com>
    Signed-off-by: Dmitry Kravkov <Dmitry.Kravkov@qlogic.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>

commit 62c54cb10f458a548305bc4c2fb55fc0ad9d79ea
Author: Jan Kara <jack@suse.cz>
Date:   Fri Aug 1 12:20:02 2014 +0200

    timer: Fix lock inversion between hrtimer_bases.lock and scheduler locks
    
    commit 504d58745c9ca28d33572e2d8a9990b43e06075d upstream.
    
    clockevents_increase_min_delta() calls printk() from under
    hrtimer_bases.lock. That causes lock inversion on scheduler locks because
    printk() can call into the scheduler. Lockdep puts it as:
    
    ======================================================
    [ INFO: possible circular locking dependency detected ]
    3.15.0-rc8-06195-g939f04b #2 Not tainted
    -------------------------------------------------------
    trinity-main/74 is trying to acquire lock:
     (&port_lock_key){-.....}, at: [<811c60be>] serial8250_console_write+0x8c/0x10c
    
    but task is already holding lock:
     (hrtimer_bases.lock){-.-...}, at: [<8103caeb>] hrtimer_try_to_cancel+0x13/0x66
    
    which lock already depends on the new lock.
    
    the existing dependency chain (in reverse order) is:
    
    -> #5 (hrtimer_bases.lock){-.-...}:
           [<8104a942>] lock_acquire+0x92/0x101
           [<8142f11d>] _raw_spin_lock_irqsave+0x2e/0x3e
           [<8103c918>] __hrtimer_start_range_ns+0x1c/0x197
           [<8107ec20>] perf_swevent_start_hrtimer.part.41+0x7a/0x85
           [<81080792>] task_clock_event_start+0x3a/0x3f
           [<810807a4>] task_clock_event_add+0xd/0x14
           [<8108259a>] event_sched_in+0xb6/0x17a
           [<810826a2>] group_sched_in+0x44/0x122
           [<81082885>] ctx_sched_in.isra.67+0x105/0x11f
           [<810828e6>] perf_event_sched_in.isra.70+0x47/0x4b
           [<81082bf6>] __perf_install_in_context+0x8b/0xa3
           [<8107eb8e>] remote_function+0x12/0x2a
           [<8105f5af>] smp_call_function_single+0x2d/0x53
           [<8107e17d>] task_function_call+0x30/0x36
           [<8107fb82>] perf_install_in_context+0x87/0xbb
           [<810852c9>] SYSC_perf_event_open+0x5c6/0x701
           [<810856f9>] SyS_perf_event_open+0x17/0x19
           [<8142f8ee>] syscall_call+0x7/0xb
    
    -> #4 (&ctx->lock){......}:
           [<8104a942>] lock_acquire+0x92/0x101
           [<8142f04c>] _raw_spin_lock+0x21/0x30
           [<81081df3>] __perf_event_task_sched_out+0x1dc/0x34f
           [<8142cacc>] __schedule+0x4c6/0x4cb
           [<8142cae0>] schedule+0xf/0x11
           [<8142f9a6>] work_resched+0x5/0x30
    
    -> #3 (&rq->lock){-.-.-.}:
           [<8104a942>] lock_acquire+0x92/0x101
           [<8142f04c>] _raw_spin_lock+0x21/0x30
           [<81040873>] __task_rq_lock+0x33/0x3a
           [<8104184c>] wake_up_new_task+0x25/0xc2
           [<8102474b>] do_fork+0x15c/0x2a0
           [<810248a9>] kernel_thread+0x1a/0x1f
           [<814232a2>] rest_init+0x1a/0x10e
           [<817af949>] start_kernel+0x303/0x308
           [<817af2ab>] i386_start_kernel+0x79/0x7d
    
    -> #2 (&p->pi_lock){-.-...}:
           [<8104a942>] lock_acquire+0x92/0x101
           [<8142f11d>] _raw_spin_lock_irqsave+0x2e/0x3e
           [<810413dd>] try_to_wake_up+0x1d/0xd6
           [<810414cd>] default_wake_function+0xb/0xd
           [<810461f3>] __wake_up_common+0x39/0x59
           [<81046346>] __wake_up+0x29/0x3b
           [<811b8733>] tty_wakeup+0x49/0x51
           [<811c3568>] uart_write_wakeup+0x17/0x19
           [<811c5dc1>] serial8250_tx_chars+0xbc/0xfb
           [<811c5f28>] serial8250_handle_irq+0x54/0x6a
           [<811c5f57>] serial8250_default_handle_irq+0x19/0x1c
           [<811c56d8>] serial8250_interrupt+0x38/0x9e
           [<810510e7>] handle_irq_event_percpu+0x5f/0x1e2
           [<81051296>] handle_irq_event+0x2c/0x43
           [<81052cee>] handle_level_irq+0x57/0x80
           [<81002a72>] handle_irq+0x46/0x5c
           [<810027df>] do_IRQ+0x32/0x89
           [<8143036e>] common_interrupt+0x2e/0x33
           [<8142f23c>] _raw_spin_unlock_irqrestore+0x3f/0x49
           [<811c25a4>] uart_start+0x2d/0x32
           [<811c2c04>] uart_write+0xc7/0xd6
           [<811bc6f6>] n_tty_write+0xb8/0x35e
           [<811b9beb>] tty_write+0x163/0x1e4
           [<811b9cd9>] redirected_tty_write+0x6d/0x75
           [<810b6ed6>] vfs_write+0x75/0xb0
           [<810b7265>] SyS_write+0x44/0x77
           [<8142f8ee>] syscall_call+0x7/0xb
    
    -> #1 (&tty->write_wait){-.....}:
           [<8104a942>] lock_acquire+0x92/0x101
           [<8142f11d>] _raw_spin_lock_irqsave+0x2e/0x3e
           [<81046332>] __wake_up+0x15/0x3b
           [<811b8733>] tty_wakeup+0x49/0x51
           [<811c3568>] uart_write_wakeup+0x17/0x19
           [<811c5dc1>] serial8250_tx_chars+0xbc/0xfb
           [<811c5f28>] serial8250_handle_irq+0x54/0x6a
           [<811c5f57>] serial8250_default_handle_irq+0x19/0x1c
           [<811c56d8>] serial8250_interrupt+0x38/0x9e
           [<810510e7>] handle_irq_event_percpu+0x5f/0x1e2
           [<81051296>] handle_irq_event+0x2c/0x43
           [<81052cee>] handle_level_irq+0x57/0x80
           [<81002a72>] handle_irq+0x46/0x5c
           [<810027df>] do_IRQ+0x32/0x89
           [<8143036e>] common_interrupt+0x2e/0x33
           [<8142f23c>] _raw_spin_unlock_irqrestore+0x3f/0x49
           [<811c25a4>] uart_start+0x2d/0x32
           [<811c2c04>] uart_write+0xc7/0xd6
           [<811bc6f6>] n_tty_write+0xb8/0x35e
           [<811b9beb>] tty_write+0x163/0x1e4
           [<811b9cd9>] redirected_tty_write+0x6d/0x75
           [<810b6ed6>] vfs_write+0x75/0xb0
           [<810b7265>] SyS_write+0x44/0x77
           [<8142f8ee>] syscall_call+0x7/0xb
    
    -> #0 (&port_lock_key){-.....}:
           [<8104a62d>] __lock_acquire+0x9ea/0xc6d
           [<8104a942>] lock_acquire+0x92/0x101
           [<8142f11d>] _raw_spin_lock_irqsave+0x2e/0x3e
           [<811c60be>] serial8250_console_write+0x8c/0x10c
           [<8104e402>] call_console_drivers.constprop.31+0x87/0x118
           [<8104f5d5>] console_unlock+0x1d7/0x398
           [<8104fb70>] vprintk_emit+0x3da/0x3e4
           [<81425f76>] printk+0x17/0x19
           [<8105bfa0>] clockevents_program_min_delta+0x104/0x116
           [<8105c548>] clockevents_program_event+0xe7/0xf3
           [<8105cc1c>] tick_program_event+0x1e/0x23
           [<8103c43c>] hrtimer_force_reprogram+0x88/0x8f
           [<8103c49e>] __remove_hrtimer+0x5b/0x79
           [<8103cb21>] hrtimer_try_to_cancel+0x49/0x66
           [<8103cb4b>] hrtimer_cancel+0xd/0x18
           [<8107f102>] perf_swevent_cancel_hrtimer.part.60+0x2b/0x30
           [<81080705>] task_clock_event_stop+0x20/0x64
           [<81080756>] task_clock_event_del+0xd/0xf
           [<81081350>] event_sched_out+0xab/0x11e
           [<810813e0>] group_sched_out+0x1d/0x66
           [<81081682>] ctx_sched_out+0xaf/0xbf
           [<81081e04>] __perf_event_task_sched_out+0x1ed/0x34f
           [<8142cacc>] __schedule+0x4c6/0x4cb
           [<8142cae0>] schedule+0xf/0x11
           [<8142f9a6>] work_resched+0x5/0x30
    
    other info that might help us debug this:
    
    Chain exists of:
      &port_lock_key --> &ctx->lock --> hrtimer_bases.lock
    
     Possible unsafe locking scenario:
    
           CPU0                    CPU1
           ----                    ----
      lock(hrtimer_bases.lock);
                                   lock(&ctx->lock);
                                   lock(hrtimer_bases.lock);
      lock(&port_lock_key);
    
     *** DEADLOCK ***
    
    4 locks held by trinity-main/74:
     #0:  (&rq->lock){-.-.-.}, at: [<8142c6f3>] __schedule+0xed/0x4cb
     #1:  (&ctx->lock){......}, at: [<81081df3>] __perf_event_task_sched_out+0x1dc/0x34f
     #2:  (hrtimer_bases.lock){-.-...}, at: [<8103caeb>] hrtimer_try_to_cancel+0x13/0x66
     #3:  (console_lock){+.+...}, at: [<8104fb5d>] vprintk_emit+0x3c7/0x3e4
    
    stack backtrace:
    CPU: 0 PID: 74 Comm: trinity-main Not tainted 3.15.0-rc8-06195-g939f04b #2
     00000000 81c3a310 8b995c14 81426f69 8b995c44 81425a99 8161f671 8161f570
     8161f538 8161f559 8161f538 8b995c78 8b142bb0 00000004 8b142fdc 8b142bb0
     8b995ca8 8104a62d 8b142fac 000016f2 81c3a310 00000001 00000001 00000003
    Call Trace:
     [<81426f69>] dump_stack+0x16/0x18
     [<81425a99>] print_circular_bug+0x18f/0x19c
     [<8104a62d>] __lock_acquire+0x9ea/0xc6d
     [<8104a942>] lock_acquire+0x92/0x101
     [<811c60be>] ? serial8250_console_write+0x8c/0x10c
     [<811c6032>] ? wait_for_xmitr+0x76/0x76
     [<8142f11d>] _raw_spin_lock_irqsave+0x2e/0x3e
     [<811c60be>] ? serial8250_console_write+0x8c/0x10c
     [<811c60be>] serial8250_console_write+0x8c/0x10c
     [<8104af87>] ? lock_release+0x191/0x223
     [<811c6032>] ? wait_for_xmitr+0x76/0x76
     [<8104e402>] call_console_drivers.constprop.31+0x87/0x118
     [<8104f5d5>] console_unlock+0x1d7/0x398
     [<8104fb70>] vprintk_emit+0x3da/0x3e4
     [<81425f76>] printk+0x17/0x19
     [<8105bfa0>] clockevents_program_min_delta+0x104/0x116
     [<8105cc1c>] tick_program_event+0x1e/0x23
     [<8103c43c>] hrtimer_force_reprogram+0x88/0x8f
     [<8103c49e>] __remove_hrtimer+0x5b/0x79
     [<8103cb21>] hrtimer_try_to_cancel+0x49/0x66
     [<8103cb4b>] hrtimer_cancel+0xd/0x18
     [<8107f102>] perf_swevent_cancel_hrtimer.part.60+0x2b/0x30
     [<81080705>] task_clock_event_stop+0x20/0x64
     [<81080756>] task_clock_event_del+0xd/0xf
     [<81081350>] event_sched_out+0xab/0x11e
     [<810813e0>] group_sched_out+0x1d/0x66
     [<81081682>] ctx_sched_out+0xaf/0xbf
     [<81081e04>] __perf_event_task_sched_out+0x1ed/0x34f
     [<8104416d>] ? __dequeue_entity+0x23/0x27
     [<81044505>] ? pick_next_task_fair+0xb1/0x120
     [<8142cacc>] __schedule+0x4c6/0x4cb
     [<81047574>] ? trace_hardirqs_off_caller+0xd7/0x108
     [<810475b0>] ? trace_hardirqs_off+0xb/0xd
     [<81056346>] ? rcu_irq_exit+0x64/0x77
    
    Fix the problem by using printk_deferred() which does not call into the
    scheduler.
    
    Reported-by: Fengguang Wu <fengguang.wu@intel.com>
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>

commit e0d1b89416a6a32461fb110ebc6e0f4cf01fb411
Author: Dmitry Kravkov <Dmitry.Kravkov@qlogic.com>
Date:   Thu Jul 24 18:54:47 2014 +0300

    bnx2x: fix crash during TSO tunneling
    
    [ Upstream commit fe26566d8a05151ba1dce75081f6270f73ec4ae1 ]
    
    When TSO packet is transmitted additional BD w/o mapping is used
    to describe the packed. The BD needs special handling in tx
    completion.
    
    kernel: Call Trace:
    kernel: <IRQ>  [<ffffffff815e19ba>] dump_stack+0x19/0x1b
    kernel: [<ffffffff8105dee1>] warn_slowpath_common+0x61/0x80
    kernel: [<ffffffff8105df5c>] warn_slowpath_fmt+0x5c/0x80
    kernel: [<ffffffff814a8c0d>] ? find_iova+0x4d/0x90
    kernel: [<ffffffff814ab0e2>] intel_unmap_page.part.36+0x142/0x160
    kernel: [<ffffffff814ad0e6>] intel_unmap_page+0x26/0x30
    kernel: [<ffffffffa01f55d7>] bnx2x_free_tx_pkt+0x157/0x2b0 [bnx2x]
    kernel: [<ffffffffa01f8dac>] bnx2x_tx_int+0xac/0x220 [bnx2x]
    kernel: [<ffffffff8101a0d9>] ? read_tsc+0x9/0x20
    kernel: [<ffffffffa01f8fdb>] bnx2x_poll+0xbb/0x3c0 [bnx2x]
    kernel: [<ffffffff814d041a>] net_rx_action+0x15a/0x250
    kernel: [<ffffffff81067047>] __do_softirq+0xf7/0x290
    kernel: [<ffffffff815f3a5c>] call_softirq+0x1c/0x30
    kernel: [<ffffffff81014d25>] do_softirq+0x55/0x90
    kernel: [<ffffffff810673e5>] irq_exit+0x115/0x120
    kernel: [<ffffffff815f4358>] do_IRQ+0x58/0xf0
    kernel: [<ffffffff815e94ad>] common_interrupt+0x6d/0x6d
    kernel: <EOI>  [<ffffffff810bbff7>] ? clockevents_notify+0x127/0x140
    kernel: [<ffffffff814834df>] ? cpuidle_enter_state+0x4f/0xc0
    kernel: [<ffffffff81483615>] cpuidle_idle_call+0xc5/0x200
    kernel: [<ffffffff8101bc7e>] arch_cpu_idle+0xe/0x30
    kernel: [<ffffffff810b4725>] cpu_startup_entry+0xf5/0x290
    kernel: [<ffffffff815cfee1>] start_secondary+0x265/0x27b
    kernel: ---[ end trace 11aa7726f18d7e80 ]---
    
    Fixes: a848ade408b ("bnx2x: add CSUM and TSO support for encapsulation protocols")
    Reported-by: Yulong Pei <ypei@redhat.com>
    Cc: Michal Schmidt <mschmidt@redhat.com>
    Signed-off-by: Dmitry Kravkov <Dmitry.Kravkov@qlogic.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 910c396e1c58e0f6f6c817edf9292f245779ec65
Author: Dmitry Kravkov <Dmitry.Kravkov@qlogic.com>
Date:   Thu Jul 24 18:54:47 2014 +0300

    bnx2x: fix crash during TSO tunneling
    
    [ Upstream commit fe26566d8a05151ba1dce75081f6270f73ec4ae1 ]
    
    When TSO packet is transmitted additional BD w/o mapping is used
    to describe the packed. The BD needs special handling in tx
    completion.
    
    kernel: Call Trace:
    kernel: <IRQ>  [<ffffffff815e19ba>] dump_stack+0x19/0x1b
    kernel: [<ffffffff8105dee1>] warn_slowpath_common+0x61/0x80
    kernel: [<ffffffff8105df5c>] warn_slowpath_fmt+0x5c/0x80
    kernel: [<ffffffff814a8c0d>] ? find_iova+0x4d/0x90
    kernel: [<ffffffff814ab0e2>] intel_unmap_page.part.36+0x142/0x160
    kernel: [<ffffffff814ad0e6>] intel_unmap_page+0x26/0x30
    kernel: [<ffffffffa01f55d7>] bnx2x_free_tx_pkt+0x157/0x2b0 [bnx2x]
    kernel: [<ffffffffa01f8dac>] bnx2x_tx_int+0xac/0x220 [bnx2x]
    kernel: [<ffffffff8101a0d9>] ? read_tsc+0x9/0x20
    kernel: [<ffffffffa01f8fdb>] bnx2x_poll+0xbb/0x3c0 [bnx2x]
    kernel: [<ffffffff814d041a>] net_rx_action+0x15a/0x250
    kernel: [<ffffffff81067047>] __do_softirq+0xf7/0x290
    kernel: [<ffffffff815f3a5c>] call_softirq+0x1c/0x30
    kernel: [<ffffffff81014d25>] do_softirq+0x55/0x90
    kernel: [<ffffffff810673e5>] irq_exit+0x115/0x120
    kernel: [<ffffffff815f4358>] do_IRQ+0x58/0xf0
    kernel: [<ffffffff815e94ad>] common_interrupt+0x6d/0x6d
    kernel: <EOI>  [<ffffffff810bbff7>] ? clockevents_notify+0x127/0x140
    kernel: [<ffffffff814834df>] ? cpuidle_enter_state+0x4f/0xc0
    kernel: [<ffffffff81483615>] cpuidle_idle_call+0xc5/0x200
    kernel: [<ffffffff8101bc7e>] arch_cpu_idle+0xe/0x30
    kernel: [<ffffffff810b4725>] cpu_startup_entry+0xf5/0x290
    kernel: [<ffffffff815cfee1>] start_secondary+0x265/0x27b
    kernel: ---[ end trace 11aa7726f18d7e80 ]---
    
    Fixes: a848ade408b ("bnx2x: add CSUM and TSO support for encapsulation protocols")
    Reported-by: Yulong Pei <ypei@redhat.com>
    Cc: Michal Schmidt <mschmidt@redhat.com>
    Signed-off-by: Dmitry Kravkov <Dmitry.Kravkov@qlogic.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit f5980d099295d4113635ded88425834a38d17125
Author: Dmitry Kravkov <Dmitry.Kravkov@qlogic.com>
Date:   Thu Jul 24 18:54:47 2014 +0300

    bnx2x: fix crash during TSO tunneling
    
    [ Upstream commit fe26566d8a05151ba1dce75081f6270f73ec4ae1 ]
    
    When TSO packet is transmitted additional BD w/o mapping is used
    to describe the packed. The BD needs special handling in tx
    completion.
    
    kernel: Call Trace:
    kernel: <IRQ>  [<ffffffff815e19ba>] dump_stack+0x19/0x1b
    kernel: [<ffffffff8105dee1>] warn_slowpath_common+0x61/0x80
    kernel: [<ffffffff8105df5c>] warn_slowpath_fmt+0x5c/0x80
    kernel: [<ffffffff814a8c0d>] ? find_iova+0x4d/0x90
    kernel: [<ffffffff814ab0e2>] intel_unmap_page.part.36+0x142/0x160
    kernel: [<ffffffff814ad0e6>] intel_unmap_page+0x26/0x30
    kernel: [<ffffffffa01f55d7>] bnx2x_free_tx_pkt+0x157/0x2b0 [bnx2x]
    kernel: [<ffffffffa01f8dac>] bnx2x_tx_int+0xac/0x220 [bnx2x]
    kernel: [<ffffffff8101a0d9>] ? read_tsc+0x9/0x20
    kernel: [<ffffffffa01f8fdb>] bnx2x_poll+0xbb/0x3c0 [bnx2x]
    kernel: [<ffffffff814d041a>] net_rx_action+0x15a/0x250
    kernel: [<ffffffff81067047>] __do_softirq+0xf7/0x290
    kernel: [<ffffffff815f3a5c>] call_softirq+0x1c/0x30
    kernel: [<ffffffff81014d25>] do_softirq+0x55/0x90
    kernel: [<ffffffff810673e5>] irq_exit+0x115/0x120
    kernel: [<ffffffff815f4358>] do_IRQ+0x58/0xf0
    kernel: [<ffffffff815e94ad>] common_interrupt+0x6d/0x6d
    kernel: <EOI>  [<ffffffff810bbff7>] ? clockevents_notify+0x127/0x140
    kernel: [<ffffffff814834df>] ? cpuidle_enter_state+0x4f/0xc0
    kernel: [<ffffffff81483615>] cpuidle_idle_call+0xc5/0x200
    kernel: [<ffffffff8101bc7e>] arch_cpu_idle+0xe/0x30
    kernel: [<ffffffff810b4725>] cpu_startup_entry+0xf5/0x290
    kernel: [<ffffffff815cfee1>] start_secondary+0x265/0x27b
    kernel: ---[ end trace 11aa7726f18d7e80 ]---
    
    Fixes: a848ade408b ("bnx2x: add CSUM and TSO support for encapsulation protocols")
    Reported-by: Yulong Pei <ypei@redhat.com>
    Cc: Michal Schmidt <mschmidt@redhat.com>
    Signed-off-by: Dmitry Kravkov <Dmitry.Kravkov@qlogic.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit d7bbbf4552fc9d1c6483b305839f89d3943ee189
Author: Jan Kara <jack@suse.cz>
Date:   Fri Aug 1 12:20:02 2014 +0200

    timer: Fix lock inversion between hrtimer_bases.lock and scheduler locks
    
    commit 504d58745c9ca28d33572e2d8a9990b43e06075d upstream.
    
    clockevents_increase_min_delta() calls printk() from under
    hrtimer_bases.lock. That causes lock inversion on scheduler locks because
    printk() can call into the scheduler. Lockdep puts it as:
    
    ======================================================
    [ INFO: possible circular locking dependency detected ]
    3.15.0-rc8-06195-g939f04b #2 Not tainted
    -------------------------------------------------------
    trinity-main/74 is trying to acquire lock:
     (&port_lock_key){-.....}, at: [<811c60be>] serial8250_console_write+0x8c/0x10c
    
    but task is already holding lock:
     (hrtimer_bases.lock){-.-...}, at: [<8103caeb>] hrtimer_try_to_cancel+0x13/0x66
    
    which lock already depends on the new lock.
    
    the existing dependency chain (in reverse order) is:
    
    -> #5 (hrtimer_bases.lock){-.-...}:
           [<8104a942>] lock_acquire+0x92/0x101
           [<8142f11d>] _raw_spin_lock_irqsave+0x2e/0x3e
           [<8103c918>] __hrtimer_start_range_ns+0x1c/0x197
           [<8107ec20>] perf_swevent_start_hrtimer.part.41+0x7a/0x85
           [<81080792>] task_clock_event_start+0x3a/0x3f
           [<810807a4>] task_clock_event_add+0xd/0x14
           [<8108259a>] event_sched_in+0xb6/0x17a
           [<810826a2>] group_sched_in+0x44/0x122
           [<81082885>] ctx_sched_in.isra.67+0x105/0x11f
           [<810828e6>] perf_event_sched_in.isra.70+0x47/0x4b
           [<81082bf6>] __perf_install_in_context+0x8b/0xa3
           [<8107eb8e>] remote_function+0x12/0x2a
           [<8105f5af>] smp_call_function_single+0x2d/0x53
           [<8107e17d>] task_function_call+0x30/0x36
           [<8107fb82>] perf_install_in_context+0x87/0xbb
           [<810852c9>] SYSC_perf_event_open+0x5c6/0x701
           [<810856f9>] SyS_perf_event_open+0x17/0x19
           [<8142f8ee>] syscall_call+0x7/0xb
    
    -> #4 (&ctx->lock){......}:
           [<8104a942>] lock_acquire+0x92/0x101
           [<8142f04c>] _raw_spin_lock+0x21/0x30
           [<81081df3>] __perf_event_task_sched_out+0x1dc/0x34f
           [<8142cacc>] __schedule+0x4c6/0x4cb
           [<8142cae0>] schedule+0xf/0x11
           [<8142f9a6>] work_resched+0x5/0x30
    
    -> #3 (&rq->lock){-.-.-.}:
           [<8104a942>] lock_acquire+0x92/0x101
           [<8142f04c>] _raw_spin_lock+0x21/0x30
           [<81040873>] __task_rq_lock+0x33/0x3a
           [<8104184c>] wake_up_new_task+0x25/0xc2
           [<8102474b>] do_fork+0x15c/0x2a0
           [<810248a9>] kernel_thread+0x1a/0x1f
           [<814232a2>] rest_init+0x1a/0x10e
           [<817af949>] start_kernel+0x303/0x308
           [<817af2ab>] i386_start_kernel+0x79/0x7d
    
    -> #2 (&p->pi_lock){-.-...}:
           [<8104a942>] lock_acquire+0x92/0x101
           [<8142f11d>] _raw_spin_lock_irqsave+0x2e/0x3e
           [<810413dd>] try_to_wake_up+0x1d/0xd6
           [<810414cd>] default_wake_function+0xb/0xd
           [<810461f3>] __wake_up_common+0x39/0x59
           [<81046346>] __wake_up+0x29/0x3b
           [<811b8733>] tty_wakeup+0x49/0x51
           [<811c3568>] uart_write_wakeup+0x17/0x19
           [<811c5dc1>] serial8250_tx_chars+0xbc/0xfb
           [<811c5f28>] serial8250_handle_irq+0x54/0x6a
           [<811c5f57>] serial8250_default_handle_irq+0x19/0x1c
           [<811c56d8>] serial8250_interrupt+0x38/0x9e
           [<810510e7>] handle_irq_event_percpu+0x5f/0x1e2
           [<81051296>] handle_irq_event+0x2c/0x43
           [<81052cee>] handle_level_irq+0x57/0x80
           [<81002a72>] handle_irq+0x46/0x5c
           [<810027df>] do_IRQ+0x32/0x89
           [<8143036e>] common_interrupt+0x2e/0x33
           [<8142f23c>] _raw_spin_unlock_irqrestore+0x3f/0x49
           [<811c25a4>] uart_start+0x2d/0x32
           [<811c2c04>] uart_write+0xc7/0xd6
           [<811bc6f6>] n_tty_write+0xb8/0x35e
           [<811b9beb>] tty_write+0x163/0x1e4
           [<811b9cd9>] redirected_tty_write+0x6d/0x75
           [<810b6ed6>] vfs_write+0x75/0xb0
           [<810b7265>] SyS_write+0x44/0x77
           [<8142f8ee>] syscall_call+0x7/0xb
    
    -> #1 (&tty->write_wait){-.....}:
           [<8104a942>] lock_acquire+0x92/0x101
           [<8142f11d>] _raw_spin_lock_irqsave+0x2e/0x3e
           [<81046332>] __wake_up+0x15/0x3b
           [<811b8733>] tty_wakeup+0x49/0x51
           [<811c3568>] uart_write_wakeup+0x17/0x19
           [<811c5dc1>] serial8250_tx_chars+0xbc/0xfb
           [<811c5f28>] serial8250_handle_irq+0x54/0x6a
           [<811c5f57>] serial8250_default_handle_irq+0x19/0x1c
           [<811c56d8>] serial8250_interrupt+0x38/0x9e
           [<810510e7>] handle_irq_event_percpu+0x5f/0x1e2
           [<81051296>] handle_irq_event+0x2c/0x43
           [<81052cee>] handle_level_irq+0x57/0x80
           [<81002a72>] handle_irq+0x46/0x5c
           [<810027df>] do_IRQ+0x32/0x89
           [<8143036e>] common_interrupt+0x2e/0x33
           [<8142f23c>] _raw_spin_unlock_irqrestore+0x3f/0x49
           [<811c25a4>] uart_start+0x2d/0x32
           [<811c2c04>] uart_write+0xc7/0xd6
           [<811bc6f6>] n_tty_write+0xb8/0x35e
           [<811b9beb>] tty_write+0x163/0x1e4
           [<811b9cd9>] redirected_tty_write+0x6d/0x75
           [<810b6ed6>] vfs_write+0x75/0xb0
           [<810b7265>] SyS_write+0x44/0x77
           [<8142f8ee>] syscall_call+0x7/0xb
    
    -> #0 (&port_lock_key){-.....}:
           [<8104a62d>] __lock_acquire+0x9ea/0xc6d
           [<8104a942>] lock_acquire+0x92/0x101
           [<8142f11d>] _raw_spin_lock_irqsave+0x2e/0x3e
           [<811c60be>] serial8250_console_write+0x8c/0x10c
           [<8104e402>] call_console_drivers.constprop.31+0x87/0x118
           [<8104f5d5>] console_unlock+0x1d7/0x398
           [<8104fb70>] vprintk_emit+0x3da/0x3e4
           [<81425f76>] printk+0x17/0x19
           [<8105bfa0>] clockevents_program_min_delta+0x104/0x116
           [<8105c548>] clockevents_program_event+0xe7/0xf3
           [<8105cc1c>] tick_program_event+0x1e/0x23
           [<8103c43c>] hrtimer_force_reprogram+0x88/0x8f
           [<8103c49e>] __remove_hrtimer+0x5b/0x79
           [<8103cb21>] hrtimer_try_to_cancel+0x49/0x66
           [<8103cb4b>] hrtimer_cancel+0xd/0x18
           [<8107f102>] perf_swevent_cancel_hrtimer.part.60+0x2b/0x30
           [<81080705>] task_clock_event_stop+0x20/0x64
           [<81080756>] task_clock_event_del+0xd/0xf
           [<81081350>] event_sched_out+0xab/0x11e
           [<810813e0>] group_sched_out+0x1d/0x66
           [<81081682>] ctx_sched_out+0xaf/0xbf
           [<81081e04>] __perf_event_task_sched_out+0x1ed/0x34f
           [<8142cacc>] __schedule+0x4c6/0x4cb
           [<8142cae0>] schedule+0xf/0x11
           [<8142f9a6>] work_resched+0x5/0x30
    
    other info that might help us debug this:
    
    Chain exists of:
      &port_lock_key --> &ctx->lock --> hrtimer_bases.lock
    
     Possible unsafe locking scenario:
    
           CPU0                    CPU1
           ----                    ----
      lock(hrtimer_bases.lock);
                                   lock(&ctx->lock);
                                   lock(hrtimer_bases.lock);
      lock(&port_lock_key);
    
     *** DEADLOCK ***
    
    4 locks held by trinity-main/74:
     #0:  (&rq->lock){-.-.-.}, at: [<8142c6f3>] __schedule+0xed/0x4cb
     #1:  (&ctx->lock){......}, at: [<81081df3>] __perf_event_task_sched_out+0x1dc/0x34f
     #2:  (hrtimer_bases.lock){-.-...}, at: [<8103caeb>] hrtimer_try_to_cancel+0x13/0x66
     #3:  (console_lock){+.+...}, at: [<8104fb5d>] vprintk_emit+0x3c7/0x3e4
    
    stack backtrace:
    CPU: 0 PID: 74 Comm: trinity-main Not tainted 3.15.0-rc8-06195-g939f04b #2
     00000000 81c3a310 8b995c14 81426f69 8b995c44 81425a99 8161f671 8161f570
     8161f538 8161f559 8161f538 8b995c78 8b142bb0 00000004 8b142fdc 8b142bb0
     8b995ca8 8104a62d 8b142fac 000016f2 81c3a310 00000001 00000001 00000003
    Call Trace:
     [<81426f69>] dump_stack+0x16/0x18
     [<81425a99>] print_circular_bug+0x18f/0x19c
     [<8104a62d>] __lock_acquire+0x9ea/0xc6d
     [<8104a942>] lock_acquire+0x92/0x101
     [<811c60be>] ? serial8250_console_write+0x8c/0x10c
     [<811c6032>] ? wait_for_xmitr+0x76/0x76
     [<8142f11d>] _raw_spin_lock_irqsave+0x2e/0x3e
     [<811c60be>] ? serial8250_console_write+0x8c/0x10c
     [<811c60be>] serial8250_console_write+0x8c/0x10c
     [<8104af87>] ? lock_release+0x191/0x223
     [<811c6032>] ? wait_for_xmitr+0x76/0x76
     [<8104e402>] call_console_drivers.constprop.31+0x87/0x118
     [<8104f5d5>] console_unlock+0x1d7/0x398
     [<8104fb70>] vprintk_emit+0x3da/0x3e4
     [<81425f76>] printk+0x17/0x19
     [<8105bfa0>] clockevents_program_min_delta+0x104/0x116
     [<8105cc1c>] tick_program_event+0x1e/0x23
     [<8103c43c>] hrtimer_force_reprogram+0x88/0x8f
     [<8103c49e>] __remove_hrtimer+0x5b/0x79
     [<8103cb21>] hrtimer_try_to_cancel+0x49/0x66
     [<8103cb4b>] hrtimer_cancel+0xd/0x18
     [<8107f102>] perf_swevent_cancel_hrtimer.part.60+0x2b/0x30
     [<81080705>] task_clock_event_stop+0x20/0x64
     [<81080756>] task_clock_event_del+0xd/0xf
     [<81081350>] event_sched_out+0xab/0x11e
     [<810813e0>] group_sched_out+0x1d/0x66
     [<81081682>] ctx_sched_out+0xaf/0xbf
     [<81081e04>] __perf_event_task_sched_out+0x1ed/0x34f
     [<8104416d>] ? __dequeue_entity+0x23/0x27
     [<81044505>] ? pick_next_task_fair+0xb1/0x120
     [<8142cacc>] __schedule+0x4c6/0x4cb
     [<81047574>] ? trace_hardirqs_off_caller+0xd7/0x108
     [<810475b0>] ? trace_hardirqs_off+0xb/0xd
     [<81056346>] ? rcu_irq_exit+0x64/0x77
    
    Fix the problem by using printk_deferred() which does not call into the
    scheduler.
    
    Reported-by: Fengguang Wu <fengguang.wu@intel.com>
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 65337015afb47e285c46499557d75f6d0b872047
Author: Jan Kara <jack@suse.cz>
Date:   Fri Aug 1 12:20:02 2014 +0200

    timer: Fix lock inversion between hrtimer_bases.lock and scheduler locks
    
    commit 504d58745c9ca28d33572e2d8a9990b43e06075d upstream.
    
    clockevents_increase_min_delta() calls printk() from under
    hrtimer_bases.lock. That causes lock inversion on scheduler locks because
    printk() can call into the scheduler. Lockdep puts it as:
    
    ======================================================
    [ INFO: possible circular locking dependency detected ]
    3.15.0-rc8-06195-g939f04b #2 Not tainted
    -------------------------------------------------------
    trinity-main/74 is trying to acquire lock:
     (&port_lock_key){-.....}, at: [<811c60be>] serial8250_console_write+0x8c/0x10c
    
    but task is already holding lock:
     (hrtimer_bases.lock){-.-...}, at: [<8103caeb>] hrtimer_try_to_cancel+0x13/0x66
    
    which lock already depends on the new lock.
    
    the existing dependency chain (in reverse order) is:
    
    -> #5 (hrtimer_bases.lock){-.-...}:
           [<8104a942>] lock_acquire+0x92/0x101
           [<8142f11d>] _raw_spin_lock_irqsave+0x2e/0x3e
           [<8103c918>] __hrtimer_start_range_ns+0x1c/0x197
           [<8107ec20>] perf_swevent_start_hrtimer.part.41+0x7a/0x85
           [<81080792>] task_clock_event_start+0x3a/0x3f
           [<810807a4>] task_clock_event_add+0xd/0x14
           [<8108259a>] event_sched_in+0xb6/0x17a
           [<810826a2>] group_sched_in+0x44/0x122
           [<81082885>] ctx_sched_in.isra.67+0x105/0x11f
           [<810828e6>] perf_event_sched_in.isra.70+0x47/0x4b
           [<81082bf6>] __perf_install_in_context+0x8b/0xa3
           [<8107eb8e>] remote_function+0x12/0x2a
           [<8105f5af>] smp_call_function_single+0x2d/0x53
           [<8107e17d>] task_function_call+0x30/0x36
           [<8107fb82>] perf_install_in_context+0x87/0xbb
           [<810852c9>] SYSC_perf_event_open+0x5c6/0x701
           [<810856f9>] SyS_perf_event_open+0x17/0x19
           [<8142f8ee>] syscall_call+0x7/0xb
    
    -> #4 (&ctx->lock){......}:
           [<8104a942>] lock_acquire+0x92/0x101
           [<8142f04c>] _raw_spin_lock+0x21/0x30
           [<81081df3>] __perf_event_task_sched_out+0x1dc/0x34f
           [<8142cacc>] __schedule+0x4c6/0x4cb
           [<8142cae0>] schedule+0xf/0x11
           [<8142f9a6>] work_resched+0x5/0x30
    
    -> #3 (&rq->lock){-.-.-.}:
           [<8104a942>] lock_acquire+0x92/0x101
           [<8142f04c>] _raw_spin_lock+0x21/0x30
           [<81040873>] __task_rq_lock+0x33/0x3a
           [<8104184c>] wake_up_new_task+0x25/0xc2
           [<8102474b>] do_fork+0x15c/0x2a0
           [<810248a9>] kernel_thread+0x1a/0x1f
           [<814232a2>] rest_init+0x1a/0x10e
           [<817af949>] start_kernel+0x303/0x308
           [<817af2ab>] i386_start_kernel+0x79/0x7d
    
    -> #2 (&p->pi_lock){-.-...}:
           [<8104a942>] lock_acquire+0x92/0x101
           [<8142f11d>] _raw_spin_lock_irqsave+0x2e/0x3e
           [<810413dd>] try_to_wake_up+0x1d/0xd6
           [<810414cd>] default_wake_function+0xb/0xd
           [<810461f3>] __wake_up_common+0x39/0x59
           [<81046346>] __wake_up+0x29/0x3b
           [<811b8733>] tty_wakeup+0x49/0x51
           [<811c3568>] uart_write_wakeup+0x17/0x19
           [<811c5dc1>] serial8250_tx_chars+0xbc/0xfb
           [<811c5f28>] serial8250_handle_irq+0x54/0x6a
           [<811c5f57>] serial8250_default_handle_irq+0x19/0x1c
           [<811c56d8>] serial8250_interrupt+0x38/0x9e
           [<810510e7>] handle_irq_event_percpu+0x5f/0x1e2
           [<81051296>] handle_irq_event+0x2c/0x43
           [<81052cee>] handle_level_irq+0x57/0x80
           [<81002a72>] handle_irq+0x46/0x5c
           [<810027df>] do_IRQ+0x32/0x89
           [<8143036e>] common_interrupt+0x2e/0x33
           [<8142f23c>] _raw_spin_unlock_irqrestore+0x3f/0x49
           [<811c25a4>] uart_start+0x2d/0x32
           [<811c2c04>] uart_write+0xc7/0xd6
           [<811bc6f6>] n_tty_write+0xb8/0x35e
           [<811b9beb>] tty_write+0x163/0x1e4
           [<811b9cd9>] redirected_tty_write+0x6d/0x75
           [<810b6ed6>] vfs_write+0x75/0xb0
           [<810b7265>] SyS_write+0x44/0x77
           [<8142f8ee>] syscall_call+0x7/0xb
    
    -> #1 (&tty->write_wait){-.....}:
           [<8104a942>] lock_acquire+0x92/0x101
           [<8142f11d>] _raw_spin_lock_irqsave+0x2e/0x3e
           [<81046332>] __wake_up+0x15/0x3b
           [<811b8733>] tty_wakeup+0x49/0x51
           [<811c3568>] uart_write_wakeup+0x17/0x19
           [<811c5dc1>] serial8250_tx_chars+0xbc/0xfb
           [<811c5f28>] serial8250_handle_irq+0x54/0x6a
           [<811c5f57>] serial8250_default_handle_irq+0x19/0x1c
           [<811c56d8>] serial8250_interrupt+0x38/0x9e
           [<810510e7>] handle_irq_event_percpu+0x5f/0x1e2
           [<81051296>] handle_irq_event+0x2c/0x43
           [<81052cee>] handle_level_irq+0x57/0x80
           [<81002a72>] handle_irq+0x46/0x5c
           [<810027df>] do_IRQ+0x32/0x89
           [<8143036e>] common_interrupt+0x2e/0x33
           [<8142f23c>] _raw_spin_unlock_irqrestore+0x3f/0x49
           [<811c25a4>] uart_start+0x2d/0x32
           [<811c2c04>] uart_write+0xc7/0xd6
           [<811bc6f6>] n_tty_write+0xb8/0x35e
           [<811b9beb>] tty_write+0x163/0x1e4
           [<811b9cd9>] redirected_tty_write+0x6d/0x75
           [<810b6ed6>] vfs_write+0x75/0xb0
           [<810b7265>] SyS_write+0x44/0x77
           [<8142f8ee>] syscall_call+0x7/0xb
    
    -> #0 (&port_lock_key){-.....}:
           [<8104a62d>] __lock_acquire+0x9ea/0xc6d
           [<8104a942>] lock_acquire+0x92/0x101
           [<8142f11d>] _raw_spin_lock_irqsave+0x2e/0x3e
           [<811c60be>] serial8250_console_write+0x8c/0x10c
           [<8104e402>] call_console_drivers.constprop.31+0x87/0x118
           [<8104f5d5>] console_unlock+0x1d7/0x398
           [<8104fb70>] vprintk_emit+0x3da/0x3e4
           [<81425f76>] printk+0x17/0x19
           [<8105bfa0>] clockevents_program_min_delta+0x104/0x116
           [<8105c548>] clockevents_program_event+0xe7/0xf3
           [<8105cc1c>] tick_program_event+0x1e/0x23
           [<8103c43c>] hrtimer_force_reprogram+0x88/0x8f
           [<8103c49e>] __remove_hrtimer+0x5b/0x79
           [<8103cb21>] hrtimer_try_to_cancel+0x49/0x66
           [<8103cb4b>] hrtimer_cancel+0xd/0x18
           [<8107f102>] perf_swevent_cancel_hrtimer.part.60+0x2b/0x30
           [<81080705>] task_clock_event_stop+0x20/0x64
           [<81080756>] task_clock_event_del+0xd/0xf
           [<81081350>] event_sched_out+0xab/0x11e
           [<810813e0>] group_sched_out+0x1d/0x66
           [<81081682>] ctx_sched_out+0xaf/0xbf
           [<81081e04>] __perf_event_task_sched_out+0x1ed/0x34f
           [<8142cacc>] __schedule+0x4c6/0x4cb
           [<8142cae0>] schedule+0xf/0x11
           [<8142f9a6>] work_resched+0x5/0x30
    
    other info that might help us debug this:
    
    Chain exists of:
      &port_lock_key --> &ctx->lock --> hrtimer_bases.lock
    
     Possible unsafe locking scenario:
    
           CPU0                    CPU1
           ----                    ----
      lock(hrtimer_bases.lock);
                                   lock(&ctx->lock);
                                   lock(hrtimer_bases.lock);
      lock(&port_lock_key);
    
     *** DEADLOCK ***
    
    4 locks held by trinity-main/74:
     #0:  (&rq->lock){-.-.-.}, at: [<8142c6f3>] __schedule+0xed/0x4cb
     #1:  (&ctx->lock){......}, at: [<81081df3>] __perf_event_task_sched_out+0x1dc/0x34f
     #2:  (hrtimer_bases.lock){-.-...}, at: [<8103caeb>] hrtimer_try_to_cancel+0x13/0x66
     #3:  (console_lock){+.+...}, at: [<8104fb5d>] vprintk_emit+0x3c7/0x3e4
    
    stack backtrace:
    CPU: 0 PID: 74 Comm: trinity-main Not tainted 3.15.0-rc8-06195-g939f04b #2
     00000000 81c3a310 8b995c14 81426f69 8b995c44 81425a99 8161f671 8161f570
     8161f538 8161f559 8161f538 8b995c78 8b142bb0 00000004 8b142fdc 8b142bb0
     8b995ca8 8104a62d 8b142fac 000016f2 81c3a310 00000001 00000001 00000003
    Call Trace:
     [<81426f69>] dump_stack+0x16/0x18
     [<81425a99>] print_circular_bug+0x18f/0x19c
     [<8104a62d>] __lock_acquire+0x9ea/0xc6d
     [<8104a942>] lock_acquire+0x92/0x101
     [<811c60be>] ? serial8250_console_write+0x8c/0x10c
     [<811c6032>] ? wait_for_xmitr+0x76/0x76
     [<8142f11d>] _raw_spin_lock_irqsave+0x2e/0x3e
     [<811c60be>] ? serial8250_console_write+0x8c/0x10c
     [<811c60be>] serial8250_console_write+0x8c/0x10c
     [<8104af87>] ? lock_release+0x191/0x223
     [<811c6032>] ? wait_for_xmitr+0x76/0x76
     [<8104e402>] call_console_drivers.constprop.31+0x87/0x118
     [<8104f5d5>] console_unlock+0x1d7/0x398
     [<8104fb70>] vprintk_emit+0x3da/0x3e4
     [<81425f76>] printk+0x17/0x19
     [<8105bfa0>] clockevents_program_min_delta+0x104/0x116
     [<8105cc1c>] tick_program_event+0x1e/0x23
     [<8103c43c>] hrtimer_force_reprogram+0x88/0x8f
     [<8103c49e>] __remove_hrtimer+0x5b/0x79
     [<8103cb21>] hrtimer_try_to_cancel+0x49/0x66
     [<8103cb4b>] hrtimer_cancel+0xd/0x18
     [<8107f102>] perf_swevent_cancel_hrtimer.part.60+0x2b/0x30
     [<81080705>] task_clock_event_stop+0x20/0x64
     [<81080756>] task_clock_event_del+0xd/0xf
     [<81081350>] event_sched_out+0xab/0x11e
     [<810813e0>] group_sched_out+0x1d/0x66
     [<81081682>] ctx_sched_out+0xaf/0xbf
     [<81081e04>] __perf_event_task_sched_out+0x1ed/0x34f
     [<8104416d>] ? __dequeue_entity+0x23/0x27
     [<81044505>] ? pick_next_task_fair+0xb1/0x120
     [<8142cacc>] __schedule+0x4c6/0x4cb
     [<81047574>] ? trace_hardirqs_off_caller+0xd7/0x108
     [<810475b0>] ? trace_hardirqs_off+0xb/0xd
     [<81056346>] ? rcu_irq_exit+0x64/0x77
    
    Fix the problem by using printk_deferred() which does not call into the
    scheduler.
    
    Reported-by: Fengguang Wu <fengguang.wu@intel.com>
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 562eebeb9c07101e49f6803fd018ac45a01e3f43
Author: Jan Kara <jack@suse.cz>
Date:   Fri Aug 1 12:20:02 2014 +0200

    timer: Fix lock inversion between hrtimer_bases.lock and scheduler locks
    
    commit 504d58745c9ca28d33572e2d8a9990b43e06075d upstream.
    
    clockevents_increase_min_delta() calls printk() from under
    hrtimer_bases.lock. That causes lock inversion on scheduler locks because
    printk() can call into the scheduler. Lockdep puts it as:
    
    ======================================================
    [ INFO: possible circular locking dependency detected ]
    3.15.0-rc8-06195-g939f04b #2 Not tainted
    -------------------------------------------------------
    trinity-main/74 is trying to acquire lock:
     (&port_lock_key){-.....}, at: [<811c60be>] serial8250_console_write+0x8c/0x10c
    
    but task is already holding lock:
     (hrtimer_bases.lock){-.-...}, at: [<8103caeb>] hrtimer_try_to_cancel+0x13/0x66
    
    which lock already depends on the new lock.
    
    the existing dependency chain (in reverse order) is:
    
    -> #5 (hrtimer_bases.lock){-.-...}:
           [<8104a942>] lock_acquire+0x92/0x101
           [<8142f11d>] _raw_spin_lock_irqsave+0x2e/0x3e
           [<8103c918>] __hrtimer_start_range_ns+0x1c/0x197
           [<8107ec20>] perf_swevent_start_hrtimer.part.41+0x7a/0x85
           [<81080792>] task_clock_event_start+0x3a/0x3f
           [<810807a4>] task_clock_event_add+0xd/0x14
           [<8108259a>] event_sched_in+0xb6/0x17a
           [<810826a2>] group_sched_in+0x44/0x122
           [<81082885>] ctx_sched_in.isra.67+0x105/0x11f
           [<810828e6>] perf_event_sched_in.isra.70+0x47/0x4b
           [<81082bf6>] __perf_install_in_context+0x8b/0xa3
           [<8107eb8e>] remote_function+0x12/0x2a
           [<8105f5af>] smp_call_function_single+0x2d/0x53
           [<8107e17d>] task_function_call+0x30/0x36
           [<8107fb82>] perf_install_in_context+0x87/0xbb
           [<810852c9>] SYSC_perf_event_open+0x5c6/0x701
           [<810856f9>] SyS_perf_event_open+0x17/0x19
           [<8142f8ee>] syscall_call+0x7/0xb
    
    -> #4 (&ctx->lock){......}:
           [<8104a942>] lock_acquire+0x92/0x101
           [<8142f04c>] _raw_spin_lock+0x21/0x30
           [<81081df3>] __perf_event_task_sched_out+0x1dc/0x34f
           [<8142cacc>] __schedule+0x4c6/0x4cb
           [<8142cae0>] schedule+0xf/0x11
           [<8142f9a6>] work_resched+0x5/0x30
    
    -> #3 (&rq->lock){-.-.-.}:
           [<8104a942>] lock_acquire+0x92/0x101
           [<8142f04c>] _raw_spin_lock+0x21/0x30
           [<81040873>] __task_rq_lock+0x33/0x3a
           [<8104184c>] wake_up_new_task+0x25/0xc2
           [<8102474b>] do_fork+0x15c/0x2a0
           [<810248a9>] kernel_thread+0x1a/0x1f
           [<814232a2>] rest_init+0x1a/0x10e
           [<817af949>] start_kernel+0x303/0x308
           [<817af2ab>] i386_start_kernel+0x79/0x7d
    
    -> #2 (&p->pi_lock){-.-...}:
           [<8104a942>] lock_acquire+0x92/0x101
           [<8142f11d>] _raw_spin_lock_irqsave+0x2e/0x3e
           [<810413dd>] try_to_wake_up+0x1d/0xd6
           [<810414cd>] default_wake_function+0xb/0xd
           [<810461f3>] __wake_up_common+0x39/0x59
           [<81046346>] __wake_up+0x29/0x3b
           [<811b8733>] tty_wakeup+0x49/0x51
           [<811c3568>] uart_write_wakeup+0x17/0x19
           [<811c5dc1>] serial8250_tx_chars+0xbc/0xfb
           [<811c5f28>] serial8250_handle_irq+0x54/0x6a
           [<811c5f57>] serial8250_default_handle_irq+0x19/0x1c
           [<811c56d8>] serial8250_interrupt+0x38/0x9e
           [<810510e7>] handle_irq_event_percpu+0x5f/0x1e2
           [<81051296>] handle_irq_event+0x2c/0x43
           [<81052cee>] handle_level_irq+0x57/0x80
           [<81002a72>] handle_irq+0x46/0x5c
           [<810027df>] do_IRQ+0x32/0x89
           [<8143036e>] common_interrupt+0x2e/0x33
           [<8142f23c>] _raw_spin_unlock_irqrestore+0x3f/0x49
           [<811c25a4>] uart_start+0x2d/0x32
           [<811c2c04>] uart_write+0xc7/0xd6
           [<811bc6f6>] n_tty_write+0xb8/0x35e
           [<811b9beb>] tty_write+0x163/0x1e4
           [<811b9cd9>] redirected_tty_write+0x6d/0x75
           [<810b6ed6>] vfs_write+0x75/0xb0
           [<810b7265>] SyS_write+0x44/0x77
           [<8142f8ee>] syscall_call+0x7/0xb
    
    -> #1 (&tty->write_wait){-.....}:
           [<8104a942>] lock_acquire+0x92/0x101
           [<8142f11d>] _raw_spin_lock_irqsave+0x2e/0x3e
           [<81046332>] __wake_up+0x15/0x3b
           [<811b8733>] tty_wakeup+0x49/0x51
           [<811c3568>] uart_write_wakeup+0x17/0x19
           [<811c5dc1>] serial8250_tx_chars+0xbc/0xfb
           [<811c5f28>] serial8250_handle_irq+0x54/0x6a
           [<811c5f57>] serial8250_default_handle_irq+0x19/0x1c
           [<811c56d8>] serial8250_interrupt+0x38/0x9e
           [<810510e7>] handle_irq_event_percpu+0x5f/0x1e2
           [<81051296>] handle_irq_event+0x2c/0x43
           [<81052cee>] handle_level_irq+0x57/0x80
           [<81002a72>] handle_irq+0x46/0x5c
           [<810027df>] do_IRQ+0x32/0x89
           [<8143036e>] common_interrupt+0x2e/0x33
           [<8142f23c>] _raw_spin_unlock_irqrestore+0x3f/0x49
           [<811c25a4>] uart_start+0x2d/0x32
           [<811c2c04>] uart_write+0xc7/0xd6
           [<811bc6f6>] n_tty_write+0xb8/0x35e
           [<811b9beb>] tty_write+0x163/0x1e4
           [<811b9cd9>] redirected_tty_write+0x6d/0x75
           [<810b6ed6>] vfs_write+0x75/0xb0
           [<810b7265>] SyS_write+0x44/0x77
           [<8142f8ee>] syscall_call+0x7/0xb
    
    -> #0 (&port_lock_key){-.....}:
           [<8104a62d>] __lock_acquire+0x9ea/0xc6d
           [<8104a942>] lock_acquire+0x92/0x101
           [<8142f11d>] _raw_spin_lock_irqsave+0x2e/0x3e
           [<811c60be>] serial8250_console_write+0x8c/0x10c
           [<8104e402>] call_console_drivers.constprop.31+0x87/0x118
           [<8104f5d5>] console_unlock+0x1d7/0x398
           [<8104fb70>] vprintk_emit+0x3da/0x3e4
           [<81425f76>] printk+0x17/0x19
           [<8105bfa0>] clockevents_program_min_delta+0x104/0x116
           [<8105c548>] clockevents_program_event+0xe7/0xf3
           [<8105cc1c>] tick_program_event+0x1e/0x23
           [<8103c43c>] hrtimer_force_reprogram+0x88/0x8f
           [<8103c49e>] __remove_hrtimer+0x5b/0x79
           [<8103cb21>] hrtimer_try_to_cancel+0x49/0x66
           [<8103cb4b>] hrtimer_cancel+0xd/0x18
           [<8107f102>] perf_swevent_cancel_hrtimer.part.60+0x2b/0x30
           [<81080705>] task_clock_event_stop+0x20/0x64
           [<81080756>] task_clock_event_del+0xd/0xf
           [<81081350>] event_sched_out+0xab/0x11e
           [<810813e0>] group_sched_out+0x1d/0x66
           [<81081682>] ctx_sched_out+0xaf/0xbf
           [<81081e04>] __perf_event_task_sched_out+0x1ed/0x34f
           [<8142cacc>] __schedule+0x4c6/0x4cb
           [<8142cae0>] schedule+0xf/0x11
           [<8142f9a6>] work_resched+0x5/0x30
    
    other info that might help us debug this:
    
    Chain exists of:
      &port_lock_key --> &ctx->lock --> hrtimer_bases.lock
    
     Possible unsafe locking scenario:
    
           CPU0                    CPU1
           ----                    ----
      lock(hrtimer_bases.lock);
                                   lock(&ctx->lock);
                                   lock(hrtimer_bases.lock);
      lock(&port_lock_key);
    
     *** DEADLOCK ***
    
    4 locks held by trinity-main/74:
     #0:  (&rq->lock){-.-.-.}, at: [<8142c6f3>] __schedule+0xed/0x4cb
     #1:  (&ctx->lock){......}, at: [<81081df3>] __perf_event_task_sched_out+0x1dc/0x34f
     #2:  (hrtimer_bases.lock){-.-...}, at: [<8103caeb>] hrtimer_try_to_cancel+0x13/0x66
     #3:  (console_lock){+.+...}, at: [<8104fb5d>] vprintk_emit+0x3c7/0x3e4
    
    stack backtrace:
    CPU: 0 PID: 74 Comm: trinity-main Not tainted 3.15.0-rc8-06195-g939f04b #2
     00000000 81c3a310 8b995c14 81426f69 8b995c44 81425a99 8161f671 8161f570
     8161f538 8161f559 8161f538 8b995c78 8b142bb0 00000004 8b142fdc 8b142bb0
     8b995ca8 8104a62d 8b142fac 000016f2 81c3a310 00000001 00000001 00000003
    Call Trace:
     [<81426f69>] dump_stack+0x16/0x18
     [<81425a99>] print_circular_bug+0x18f/0x19c
     [<8104a62d>] __lock_acquire+0x9ea/0xc6d
     [<8104a942>] lock_acquire+0x92/0x101
     [<811c60be>] ? serial8250_console_write+0x8c/0x10c
     [<811c6032>] ? wait_for_xmitr+0x76/0x76
     [<8142f11d>] _raw_spin_lock_irqsave+0x2e/0x3e
     [<811c60be>] ? serial8250_console_write+0x8c/0x10c
     [<811c60be>] serial8250_console_write+0x8c/0x10c
     [<8104af87>] ? lock_release+0x191/0x223
     [<811c6032>] ? wait_for_xmitr+0x76/0x76
     [<8104e402>] call_console_drivers.constprop.31+0x87/0x118
     [<8104f5d5>] console_unlock+0x1d7/0x398
     [<8104fb70>] vprintk_emit+0x3da/0x3e4
     [<81425f76>] printk+0x17/0x19
     [<8105bfa0>] clockevents_program_min_delta+0x104/0x116
     [<8105cc1c>] tick_program_event+0x1e/0x23
     [<8103c43c>] hrtimer_force_reprogram+0x88/0x8f
     [<8103c49e>] __remove_hrtimer+0x5b/0x79
     [<8103cb21>] hrtimer_try_to_cancel+0x49/0x66
     [<8103cb4b>] hrtimer_cancel+0xd/0x18
     [<8107f102>] perf_swevent_cancel_hrtimer.part.60+0x2b/0x30
     [<81080705>] task_clock_event_stop+0x20/0x64
     [<81080756>] task_clock_event_del+0xd/0xf
     [<81081350>] event_sched_out+0xab/0x11e
     [<810813e0>] group_sched_out+0x1d/0x66
     [<81081682>] ctx_sched_out+0xaf/0xbf
     [<81081e04>] __perf_event_task_sched_out+0x1ed/0x34f
     [<8104416d>] ? __dequeue_entity+0x23/0x27
     [<81044505>] ? pick_next_task_fair+0xb1/0x120
     [<8142cacc>] __schedule+0x4c6/0x4cb
     [<81047574>] ? trace_hardirqs_off_caller+0xd7/0x108
     [<810475b0>] ? trace_hardirqs_off+0xb/0xd
     [<81056346>] ? rcu_irq_exit+0x64/0x77
    
    Fix the problem by using printk_deferred() which does not call into the
    scheduler.
    
    Reported-by: Fengguang Wu <fengguang.wu@intel.com>
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit fbbb7208969e8bfbd07782bbec069878a29d3267
Author: Jan Kara <jack@suse.cz>
Date:   Fri Aug 1 12:20:02 2014 +0200

    timer: Fix lock inversion between hrtimer_bases.lock and scheduler locks
    
    commit 504d58745c9ca28d33572e2d8a9990b43e06075d upstream.
    
    clockevents_increase_min_delta() calls printk() from under
    hrtimer_bases.lock. That causes lock inversion on scheduler locks because
    printk() can call into the scheduler. Lockdep puts it as:
    
    ======================================================
    [ INFO: possible circular locking dependency detected ]
    3.15.0-rc8-06195-g939f04b #2 Not tainted
    -------------------------------------------------------
    trinity-main/74 is trying to acquire lock:
     (&port_lock_key){-.....}, at: [<811c60be>] serial8250_console_write+0x8c/0x10c
    
    but task is already holding lock:
     (hrtimer_bases.lock){-.-...}, at: [<8103caeb>] hrtimer_try_to_cancel+0x13/0x66
    
    which lock already depends on the new lock.
    
    the existing dependency chain (in reverse order) is:
    
    -> #5 (hrtimer_bases.lock){-.-...}:
           [<8104a942>] lock_acquire+0x92/0x101
           [<8142f11d>] _raw_spin_lock_irqsave+0x2e/0x3e
           [<8103c918>] __hrtimer_start_range_ns+0x1c/0x197
           [<8107ec20>] perf_swevent_start_hrtimer.part.41+0x7a/0x85
           [<81080792>] task_clock_event_start+0x3a/0x3f
           [<810807a4>] task_clock_event_add+0xd/0x14
           [<8108259a>] event_sched_in+0xb6/0x17a
           [<810826a2>] group_sched_in+0x44/0x122
           [<81082885>] ctx_sched_in.isra.67+0x105/0x11f
           [<810828e6>] perf_event_sched_in.isra.70+0x47/0x4b
           [<81082bf6>] __perf_install_in_context+0x8b/0xa3
           [<8107eb8e>] remote_function+0x12/0x2a
           [<8105f5af>] smp_call_function_single+0x2d/0x53
           [<8107e17d>] task_function_call+0x30/0x36
           [<8107fb82>] perf_install_in_context+0x87/0xbb
           [<810852c9>] SYSC_perf_event_open+0x5c6/0x701
           [<810856f9>] SyS_perf_event_open+0x17/0x19
           [<8142f8ee>] syscall_call+0x7/0xb
    
    -> #4 (&ctx->lock){......}:
           [<8104a942>] lock_acquire+0x92/0x101
           [<8142f04c>] _raw_spin_lock+0x21/0x30
           [<81081df3>] __perf_event_task_sched_out+0x1dc/0x34f
           [<8142cacc>] __schedule+0x4c6/0x4cb
           [<8142cae0>] schedule+0xf/0x11
           [<8142f9a6>] work_resched+0x5/0x30
    
    -> #3 (&rq->lock){-.-.-.}:
           [<8104a942>] lock_acquire+0x92/0x101
           [<8142f04c>] _raw_spin_lock+0x21/0x30
           [<81040873>] __task_rq_lock+0x33/0x3a
           [<8104184c>] wake_up_new_task+0x25/0xc2
           [<8102474b>] do_fork+0x15c/0x2a0
           [<810248a9>] kernel_thread+0x1a/0x1f
           [<814232a2>] rest_init+0x1a/0x10e
           [<817af949>] start_kernel+0x303/0x308
           [<817af2ab>] i386_start_kernel+0x79/0x7d
    
    -> #2 (&p->pi_lock){-.-...}:
           [<8104a942>] lock_acquire+0x92/0x101
           [<8142f11d>] _raw_spin_lock_irqsave+0x2e/0x3e
           [<810413dd>] try_to_wake_up+0x1d/0xd6
           [<810414cd>] default_wake_function+0xb/0xd
           [<810461f3>] __wake_up_common+0x39/0x59
           [<81046346>] __wake_up+0x29/0x3b
           [<811b8733>] tty_wakeup+0x49/0x51
           [<811c3568>] uart_write_wakeup+0x17/0x19
           [<811c5dc1>] serial8250_tx_chars+0xbc/0xfb
           [<811c5f28>] serial8250_handle_irq+0x54/0x6a
           [<811c5f57>] serial8250_default_handle_irq+0x19/0x1c
           [<811c56d8>] serial8250_interrupt+0x38/0x9e
           [<810510e7>] handle_irq_event_percpu+0x5f/0x1e2
           [<81051296>] handle_irq_event+0x2c/0x43
           [<81052cee>] handle_level_irq+0x57/0x80
           [<81002a72>] handle_irq+0x46/0x5c
           [<810027df>] do_IRQ+0x32/0x89
           [<8143036e>] common_interrupt+0x2e/0x33
           [<8142f23c>] _raw_spin_unlock_irqrestore+0x3f/0x49
           [<811c25a4>] uart_start+0x2d/0x32
           [<811c2c04>] uart_write+0xc7/0xd6
           [<811bc6f6>] n_tty_write+0xb8/0x35e
           [<811b9beb>] tty_write+0x163/0x1e4
           [<811b9cd9>] redirected_tty_write+0x6d/0x75
           [<810b6ed6>] vfs_write+0x75/0xb0
           [<810b7265>] SyS_write+0x44/0x77
           [<8142f8ee>] syscall_call+0x7/0xb
    
    -> #1 (&tty->write_wait){-.....}:
           [<8104a942>] lock_acquire+0x92/0x101
           [<8142f11d>] _raw_spin_lock_irqsave+0x2e/0x3e
           [<81046332>] __wake_up+0x15/0x3b
           [<811b8733>] tty_wakeup+0x49/0x51
           [<811c3568>] uart_write_wakeup+0x17/0x19
           [<811c5dc1>] serial8250_tx_chars+0xbc/0xfb
           [<811c5f28>] serial8250_handle_irq+0x54/0x6a
           [<811c5f57>] serial8250_default_handle_irq+0x19/0x1c
           [<811c56d8>] serial8250_interrupt+0x38/0x9e
           [<810510e7>] handle_irq_event_percpu+0x5f/0x1e2
           [<81051296>] handle_irq_event+0x2c/0x43
           [<81052cee>] handle_level_irq+0x57/0x80
           [<81002a72>] handle_irq+0x46/0x5c
           [<810027df>] do_IRQ+0x32/0x89
           [<8143036e>] common_interrupt+0x2e/0x33
           [<8142f23c>] _raw_spin_unlock_irqrestore+0x3f/0x49
           [<811c25a4>] uart_start+0x2d/0x32
           [<811c2c04>] uart_write+0xc7/0xd6
           [<811bc6f6>] n_tty_write+0xb8/0x35e
           [<811b9beb>] tty_write+0x163/0x1e4
           [<811b9cd9>] redirected_tty_write+0x6d/0x75
           [<810b6ed6>] vfs_write+0x75/0xb0
           [<810b7265>] SyS_write+0x44/0x77
           [<8142f8ee>] syscall_call+0x7/0xb
    
    -> #0 (&port_lock_key){-.....}:
           [<8104a62d>] __lock_acquire+0x9ea/0xc6d
           [<8104a942>] lock_acquire+0x92/0x101
           [<8142f11d>] _raw_spin_lock_irqsave+0x2e/0x3e
           [<811c60be>] serial8250_console_write+0x8c/0x10c
           [<8104e402>] call_console_drivers.constprop.31+0x87/0x118
           [<8104f5d5>] console_unlock+0x1d7/0x398
           [<8104fb70>] vprintk_emit+0x3da/0x3e4
           [<81425f76>] printk+0x17/0x19
           [<8105bfa0>] clockevents_program_min_delta+0x104/0x116
           [<8105c548>] clockevents_program_event+0xe7/0xf3
           [<8105cc1c>] tick_program_event+0x1e/0x23
           [<8103c43c>] hrtimer_force_reprogram+0x88/0x8f
           [<8103c49e>] __remove_hrtimer+0x5b/0x79
           [<8103cb21>] hrtimer_try_to_cancel+0x49/0x66
           [<8103cb4b>] hrtimer_cancel+0xd/0x18
           [<8107f102>] perf_swevent_cancel_hrtimer.part.60+0x2b/0x30
           [<81080705>] task_clock_event_stop+0x20/0x64
           [<81080756>] task_clock_event_del+0xd/0xf
           [<81081350>] event_sched_out+0xab/0x11e
           [<810813e0>] group_sched_out+0x1d/0x66
           [<81081682>] ctx_sched_out+0xaf/0xbf
           [<81081e04>] __perf_event_task_sched_out+0x1ed/0x34f
           [<8142cacc>] __schedule+0x4c6/0x4cb
           [<8142cae0>] schedule+0xf/0x11
           [<8142f9a6>] work_resched+0x5/0x30
    
    other info that might help us debug this:
    
    Chain exists of:
      &port_lock_key --> &ctx->lock --> hrtimer_bases.lock
    
     Possible unsafe locking scenario:
    
           CPU0                    CPU1
           ----                    ----
      lock(hrtimer_bases.lock);
                                   lock(&ctx->lock);
                                   lock(hrtimer_bases.lock);
      lock(&port_lock_key);
    
     *** DEADLOCK ***
    
    4 locks held by trinity-main/74:
     #0:  (&rq->lock){-.-.-.}, at: [<8142c6f3>] __schedule+0xed/0x4cb
     #1:  (&ctx->lock){......}, at: [<81081df3>] __perf_event_task_sched_out+0x1dc/0x34f
     #2:  (hrtimer_bases.lock){-.-...}, at: [<8103caeb>] hrtimer_try_to_cancel+0x13/0x66
     #3:  (console_lock){+.+...}, at: [<8104fb5d>] vprintk_emit+0x3c7/0x3e4
    
    stack backtrace:
    CPU: 0 PID: 74 Comm: trinity-main Not tainted 3.15.0-rc8-06195-g939f04b #2
     00000000 81c3a310 8b995c14 81426f69 8b995c44 81425a99 8161f671 8161f570
     8161f538 8161f559 8161f538 8b995c78 8b142bb0 00000004 8b142fdc 8b142bb0
     8b995ca8 8104a62d 8b142fac 000016f2 81c3a310 00000001 00000001 00000003
    Call Trace:
     [<81426f69>] dump_stack+0x16/0x18
     [<81425a99>] print_circular_bug+0x18f/0x19c
     [<8104a62d>] __lock_acquire+0x9ea/0xc6d
     [<8104a942>] lock_acquire+0x92/0x101
     [<811c60be>] ? serial8250_console_write+0x8c/0x10c
     [<811c6032>] ? wait_for_xmitr+0x76/0x76
     [<8142f11d>] _raw_spin_lock_irqsave+0x2e/0x3e
     [<811c60be>] ? serial8250_console_write+0x8c/0x10c
     [<811c60be>] serial8250_console_write+0x8c/0x10c
     [<8104af87>] ? lock_release+0x191/0x223
     [<811c6032>] ? wait_for_xmitr+0x76/0x76
     [<8104e402>] call_console_drivers.constprop.31+0x87/0x118
     [<8104f5d5>] console_unlock+0x1d7/0x398
     [<8104fb70>] vprintk_emit+0x3da/0x3e4
     [<81425f76>] printk+0x17/0x19
     [<8105bfa0>] clockevents_program_min_delta+0x104/0x116
     [<8105cc1c>] tick_program_event+0x1e/0x23
     [<8103c43c>] hrtimer_force_reprogram+0x88/0x8f
     [<8103c49e>] __remove_hrtimer+0x5b/0x79
     [<8103cb21>] hrtimer_try_to_cancel+0x49/0x66
     [<8103cb4b>] hrtimer_cancel+0xd/0x18
     [<8107f102>] perf_swevent_cancel_hrtimer.part.60+0x2b/0x30
     [<81080705>] task_clock_event_stop+0x20/0x64
     [<81080756>] task_clock_event_del+0xd/0xf
     [<81081350>] event_sched_out+0xab/0x11e
     [<810813e0>] group_sched_out+0x1d/0x66
     [<81081682>] ctx_sched_out+0xaf/0xbf
     [<81081e04>] __perf_event_task_sched_out+0x1ed/0x34f
     [<8104416d>] ? __dequeue_entity+0x23/0x27
     [<81044505>] ? pick_next_task_fair+0xb1/0x120
     [<8142cacc>] __schedule+0x4c6/0x4cb
     [<81047574>] ? trace_hardirqs_off_caller+0xd7/0x108
     [<810475b0>] ? trace_hardirqs_off+0xb/0xd
     [<81056346>] ? rcu_irq_exit+0x64/0x77
    
    Fix the problem by using printk_deferred() which does not call into the
    scheduler.
    
    Reported-by: Fengguang Wu <fengguang.wu@intel.com>
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 504d58745c9ca28d33572e2d8a9990b43e06075d
Author: Jan Kara <jack@suse.cz>
Date:   Fri Aug 1 12:20:02 2014 +0200

    timer: Fix lock inversion between hrtimer_bases.lock and scheduler locks
    
    clockevents_increase_min_delta() calls printk() from under
    hrtimer_bases.lock. That causes lock inversion on scheduler locks because
    printk() can call into the scheduler. Lockdep puts it as:
    
    ======================================================
    [ INFO: possible circular locking dependency detected ]
    3.15.0-rc8-06195-g939f04b #2 Not tainted
    -------------------------------------------------------
    trinity-main/74 is trying to acquire lock:
     (&port_lock_key){-.....}, at: [<811c60be>] serial8250_console_write+0x8c/0x10c
    
    but task is already holding lock:
     (hrtimer_bases.lock){-.-...}, at: [<8103caeb>] hrtimer_try_to_cancel+0x13/0x66
    
    which lock already depends on the new lock.
    
    the existing dependency chain (in reverse order) is:
    
    -> #5 (hrtimer_bases.lock){-.-...}:
           [<8104a942>] lock_acquire+0x92/0x101
           [<8142f11d>] _raw_spin_lock_irqsave+0x2e/0x3e
           [<8103c918>] __hrtimer_start_range_ns+0x1c/0x197
           [<8107ec20>] perf_swevent_start_hrtimer.part.41+0x7a/0x85
           [<81080792>] task_clock_event_start+0x3a/0x3f
           [<810807a4>] task_clock_event_add+0xd/0x14
           [<8108259a>] event_sched_in+0xb6/0x17a
           [<810826a2>] group_sched_in+0x44/0x122
           [<81082885>] ctx_sched_in.isra.67+0x105/0x11f
           [<810828e6>] perf_event_sched_in.isra.70+0x47/0x4b
           [<81082bf6>] __perf_install_in_context+0x8b/0xa3
           [<8107eb8e>] remote_function+0x12/0x2a
           [<8105f5af>] smp_call_function_single+0x2d/0x53
           [<8107e17d>] task_function_call+0x30/0x36
           [<8107fb82>] perf_install_in_context+0x87/0xbb
           [<810852c9>] SYSC_perf_event_open+0x5c6/0x701
           [<810856f9>] SyS_perf_event_open+0x17/0x19
           [<8142f8ee>] syscall_call+0x7/0xb
    
    -> #4 (&ctx->lock){......}:
           [<8104a942>] lock_acquire+0x92/0x101
           [<8142f04c>] _raw_spin_lock+0x21/0x30
           [<81081df3>] __perf_event_task_sched_out+0x1dc/0x34f
           [<8142cacc>] __schedule+0x4c6/0x4cb
           [<8142cae0>] schedule+0xf/0x11
           [<8142f9a6>] work_resched+0x5/0x30
    
    -> #3 (&rq->lock){-.-.-.}:
           [<8104a942>] lock_acquire+0x92/0x101
           [<8142f04c>] _raw_spin_lock+0x21/0x30
           [<81040873>] __task_rq_lock+0x33/0x3a
           [<8104184c>] wake_up_new_task+0x25/0xc2
           [<8102474b>] do_fork+0x15c/0x2a0
           [<810248a9>] kernel_thread+0x1a/0x1f
           [<814232a2>] rest_init+0x1a/0x10e
           [<817af949>] start_kernel+0x303/0x308
           [<817af2ab>] i386_start_kernel+0x79/0x7d
    
    -> #2 (&p->pi_lock){-.-...}:
           [<8104a942>] lock_acquire+0x92/0x101
           [<8142f11d>] _raw_spin_lock_irqsave+0x2e/0x3e
           [<810413dd>] try_to_wake_up+0x1d/0xd6
           [<810414cd>] default_wake_function+0xb/0xd
           [<810461f3>] __wake_up_common+0x39/0x59
           [<81046346>] __wake_up+0x29/0x3b
           [<811b8733>] tty_wakeup+0x49/0x51
           [<811c3568>] uart_write_wakeup+0x17/0x19
           [<811c5dc1>] serial8250_tx_chars+0xbc/0xfb
           [<811c5f28>] serial8250_handle_irq+0x54/0x6a
           [<811c5f57>] serial8250_default_handle_irq+0x19/0x1c
           [<811c56d8>] serial8250_interrupt+0x38/0x9e
           [<810510e7>] handle_irq_event_percpu+0x5f/0x1e2
           [<81051296>] handle_irq_event+0x2c/0x43
           [<81052cee>] handle_level_irq+0x57/0x80
           [<81002a72>] handle_irq+0x46/0x5c
           [<810027df>] do_IRQ+0x32/0x89
           [<8143036e>] common_interrupt+0x2e/0x33
           [<8142f23c>] _raw_spin_unlock_irqrestore+0x3f/0x49
           [<811c25a4>] uart_start+0x2d/0x32
           [<811c2c04>] uart_write+0xc7/0xd6
           [<811bc6f6>] n_tty_write+0xb8/0x35e
           [<811b9beb>] tty_write+0x163/0x1e4
           [<811b9cd9>] redirected_tty_write+0x6d/0x75
           [<810b6ed6>] vfs_write+0x75/0xb0
           [<810b7265>] SyS_write+0x44/0x77
           [<8142f8ee>] syscall_call+0x7/0xb
    
    -> #1 (&tty->write_wait){-.....}:
           [<8104a942>] lock_acquire+0x92/0x101
           [<8142f11d>] _raw_spin_lock_irqsave+0x2e/0x3e
           [<81046332>] __wake_up+0x15/0x3b
           [<811b8733>] tty_wakeup+0x49/0x51
           [<811c3568>] uart_write_wakeup+0x17/0x19
           [<811c5dc1>] serial8250_tx_chars+0xbc/0xfb
           [<811c5f28>] serial8250_handle_irq+0x54/0x6a
           [<811c5f57>] serial8250_default_handle_irq+0x19/0x1c
           [<811c56d8>] serial8250_interrupt+0x38/0x9e
           [<810510e7>] handle_irq_event_percpu+0x5f/0x1e2
           [<81051296>] handle_irq_event+0x2c/0x43
           [<81052cee>] handle_level_irq+0x57/0x80
           [<81002a72>] handle_irq+0x46/0x5c
           [<810027df>] do_IRQ+0x32/0x89
           [<8143036e>] common_interrupt+0x2e/0x33
           [<8142f23c>] _raw_spin_unlock_irqrestore+0x3f/0x49
           [<811c25a4>] uart_start+0x2d/0x32
           [<811c2c04>] uart_write+0xc7/0xd6
           [<811bc6f6>] n_tty_write+0xb8/0x35e
           [<811b9beb>] tty_write+0x163/0x1e4
           [<811b9cd9>] redirected_tty_write+0x6d/0x75
           [<810b6ed6>] vfs_write+0x75/0xb0
           [<810b7265>] SyS_write+0x44/0x77
           [<8142f8ee>] syscall_call+0x7/0xb
    
    -> #0 (&port_lock_key){-.....}:
           [<8104a62d>] __lock_acquire+0x9ea/0xc6d
           [<8104a942>] lock_acquire+0x92/0x101
           [<8142f11d>] _raw_spin_lock_irqsave+0x2e/0x3e
           [<811c60be>] serial8250_console_write+0x8c/0x10c
           [<8104e402>] call_console_drivers.constprop.31+0x87/0x118
           [<8104f5d5>] console_unlock+0x1d7/0x398
           [<8104fb70>] vprintk_emit+0x3da/0x3e4
           [<81425f76>] printk+0x17/0x19
           [<8105bfa0>] clockevents_program_min_delta+0x104/0x116
           [<8105c548>] clockevents_program_event+0xe7/0xf3
           [<8105cc1c>] tick_program_event+0x1e/0x23
           [<8103c43c>] hrtimer_force_reprogram+0x88/0x8f
           [<8103c49e>] __remove_hrtimer+0x5b/0x79
           [<8103cb21>] hrtimer_try_to_cancel+0x49/0x66
           [<8103cb4b>] hrtimer_cancel+0xd/0x18
           [<8107f102>] perf_swevent_cancel_hrtimer.part.60+0x2b/0x30
           [<81080705>] task_clock_event_stop+0x20/0x64
           [<81080756>] task_clock_event_del+0xd/0xf
           [<81081350>] event_sched_out+0xab/0x11e
           [<810813e0>] group_sched_out+0x1d/0x66
           [<81081682>] ctx_sched_out+0xaf/0xbf
           [<81081e04>] __perf_event_task_sched_out+0x1ed/0x34f
           [<8142cacc>] __schedule+0x4c6/0x4cb
           [<8142cae0>] schedule+0xf/0x11
           [<8142f9a6>] work_resched+0x5/0x30
    
    other info that might help us debug this:
    
    Chain exists of:
      &port_lock_key --> &ctx->lock --> hrtimer_bases.lock
    
     Possible unsafe locking scenario:
    
           CPU0                    CPU1
           ----                    ----
      lock(hrtimer_bases.lock);
                                   lock(&ctx->lock);
                                   lock(hrtimer_bases.lock);
      lock(&port_lock_key);
    
     *** DEADLOCK ***
    
    4 locks held by trinity-main/74:
     #0:  (&rq->lock){-.-.-.}, at: [<8142c6f3>] __schedule+0xed/0x4cb
     #1:  (&ctx->lock){......}, at: [<81081df3>] __perf_event_task_sched_out+0x1dc/0x34f
     #2:  (hrtimer_bases.lock){-.-...}, at: [<8103caeb>] hrtimer_try_to_cancel+0x13/0x66
     #3:  (console_lock){+.+...}, at: [<8104fb5d>] vprintk_emit+0x3c7/0x3e4
    
    stack backtrace:
    CPU: 0 PID: 74 Comm: trinity-main Not tainted 3.15.0-rc8-06195-g939f04b #2
     00000000 81c3a310 8b995c14 81426f69 8b995c44 81425a99 8161f671 8161f570
     8161f538 8161f559 8161f538 8b995c78 8b142bb0 00000004 8b142fdc 8b142bb0
     8b995ca8 8104a62d 8b142fac 000016f2 81c3a310 00000001 00000001 00000003
    Call Trace:
     [<81426f69>] dump_stack+0x16/0x18
     [<81425a99>] print_circular_bug+0x18f/0x19c
     [<8104a62d>] __lock_acquire+0x9ea/0xc6d
     [<8104a942>] lock_acquire+0x92/0x101
     [<811c60be>] ? serial8250_console_write+0x8c/0x10c
     [<811c6032>] ? wait_for_xmitr+0x76/0x76
     [<8142f11d>] _raw_spin_lock_irqsave+0x2e/0x3e
     [<811c60be>] ? serial8250_console_write+0x8c/0x10c
     [<811c60be>] serial8250_console_write+0x8c/0x10c
     [<8104af87>] ? lock_release+0x191/0x223
     [<811c6032>] ? wait_for_xmitr+0x76/0x76
     [<8104e402>] call_console_drivers.constprop.31+0x87/0x118
     [<8104f5d5>] console_unlock+0x1d7/0x398
     [<8104fb70>] vprintk_emit+0x3da/0x3e4
     [<81425f76>] printk+0x17/0x19
     [<8105bfa0>] clockevents_program_min_delta+0x104/0x116
     [<8105cc1c>] tick_program_event+0x1e/0x23
     [<8103c43c>] hrtimer_force_reprogram+0x88/0x8f
     [<8103c49e>] __remove_hrtimer+0x5b/0x79
     [<8103cb21>] hrtimer_try_to_cancel+0x49/0x66
     [<8103cb4b>] hrtimer_cancel+0xd/0x18
     [<8107f102>] perf_swevent_cancel_hrtimer.part.60+0x2b/0x30
     [<81080705>] task_clock_event_stop+0x20/0x64
     [<81080756>] task_clock_event_del+0xd/0xf
     [<81081350>] event_sched_out+0xab/0x11e
     [<810813e0>] group_sched_out+0x1d/0x66
     [<81081682>] ctx_sched_out+0xaf/0xbf
     [<81081e04>] __perf_event_task_sched_out+0x1ed/0x34f
     [<8104416d>] ? __dequeue_entity+0x23/0x27
     [<81044505>] ? pick_next_task_fair+0xb1/0x120
     [<8142cacc>] __schedule+0x4c6/0x4cb
     [<81047574>] ? trace_hardirqs_off_caller+0xd7/0x108
     [<810475b0>] ? trace_hardirqs_off+0xb/0xd
     [<81056346>] ? rcu_irq_exit+0x64/0x77
    
    Fix the problem by using printk_deferred() which does not call into the
    scheduler.
    
    Reported-by: Fengguang Wu <fengguang.wu@intel.com>
    Signed-off-by: Jan Kara <jack@suse.cz>
    Cc: stable@vger.kernel.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit fe26566d8a05151ba1dce75081f6270f73ec4ae1
Author: Dmitry Kravkov <Dmitry.Kravkov@qlogic.com>
Date:   Thu Jul 24 18:54:47 2014 +0300

    bnx2x: fix crash during TSO tunneling
    
    When TSO packet is transmitted additional BD w/o mapping is used
    to describe the packed. The BD needs special handling in tx
    completion.
    
    kernel: Call Trace:
    kernel: <IRQ>  [<ffffffff815e19ba>] dump_stack+0x19/0x1b
    kernel: [<ffffffff8105dee1>] warn_slowpath_common+0x61/0x80
    kernel: [<ffffffff8105df5c>] warn_slowpath_fmt+0x5c/0x80
    kernel: [<ffffffff814a8c0d>] ? find_iova+0x4d/0x90
    kernel: [<ffffffff814ab0e2>] intel_unmap_page.part.36+0x142/0x160
    kernel: [<ffffffff814ad0e6>] intel_unmap_page+0x26/0x30
    kernel: [<ffffffffa01f55d7>] bnx2x_free_tx_pkt+0x157/0x2b0 [bnx2x]
    kernel: [<ffffffffa01f8dac>] bnx2x_tx_int+0xac/0x220 [bnx2x]
    kernel: [<ffffffff8101a0d9>] ? read_tsc+0x9/0x20
    kernel: [<ffffffffa01f8fdb>] bnx2x_poll+0xbb/0x3c0 [bnx2x]
    kernel: [<ffffffff814d041a>] net_rx_action+0x15a/0x250
    kernel: [<ffffffff81067047>] __do_softirq+0xf7/0x290
    kernel: [<ffffffff815f3a5c>] call_softirq+0x1c/0x30
    kernel: [<ffffffff81014d25>] do_softirq+0x55/0x90
    kernel: [<ffffffff810673e5>] irq_exit+0x115/0x120
    kernel: [<ffffffff815f4358>] do_IRQ+0x58/0xf0
    kernel: [<ffffffff815e94ad>] common_interrupt+0x6d/0x6d
    kernel: <EOI>  [<ffffffff810bbff7>] ? clockevents_notify+0x127/0x140
    kernel: [<ffffffff814834df>] ? cpuidle_enter_state+0x4f/0xc0
    kernel: [<ffffffff81483615>] cpuidle_idle_call+0xc5/0x200
    kernel: [<ffffffff8101bc7e>] arch_cpu_idle+0xe/0x30
    kernel: [<ffffffff810b4725>] cpu_startup_entry+0xf5/0x290
    kernel: [<ffffffff815cfee1>] start_secondary+0x265/0x27b
    kernel: ---[ end trace 11aa7726f18d7e80 ]---
    
    Fixes: a848ade408b ("bnx2x: add CSUM and TSO support for encapsulation protocols")
    Reported-by: Yulong Pei <ypei@redhat.com>
    Cc: Michal Schmidt <mschmidt@redhat.com>
    Signed-off-by: Dmitry Kravkov <Dmitry.Kravkov@qlogic.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 1af447bd8cbfb808a320885d214555fb2d32e6e6
Merge: 5442e9fbd7c2 3252a646aa2c
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Jul 23 13:22:59 2014 +0200

    Merge branch 'clockevents/3.17' of git://git.linaro.org/people/daniel.lezcano/linux into timers/core
    
    Pull clockevents from Danel Lezcano:
     * New timer driver for the Cirrus Logic CLPS711X SoC
     * New driver for the Mediatek SoC which includes:
     * A new function for of, acked by Rob Herring
     * Move the PXA driver to drivers/clocksource, add DT support
     * Optimization of the exynos_mct driver
     * DT support for the renesas timers family.
     * Some Kconfig and driver fixlets

commit de2ea58155413f8914169b7183107f4ea5c6521f
Merge: afdb09438088 cca8d0596c4c
Author: Daniel Lezcano <daniel.lezcano@linaro.org>
Date:   Wed Jul 23 12:00:00 2014 +0200

    Merge branch 'clockevents/renesas-timers-dt' into clockevents/3.17

commit 0605993990f785c882924305f5383d9cb765e736
Author: Anton Blanchard <anton@samba.org>
Date:   Fri May 9 17:47:12 2014 +1000

    powerpc: irq work racing with timer interrupt can result in timer interrupt hang
    
    commit 8050936caf125fbe54111ba5e696b68a360556ba upstream.
    
    I am seeing an issue where a CPU running perf eventually hangs.
    Traces show timer interrupts happening every 4 seconds even
    when a userspace task is running on the CPU. /proc/timer_list
    also shows pending hrtimers have not run in over an hour,
    including the scheduler.
    
    Looking closer, decrementers_next_tb is getting set to
    0xffffffffffffffff, and at that point we will never take
    a timer interrupt again.
    
    In __timer_interrupt() we set decrementers_next_tb to
    0xffffffffffffffff and rely on ->event_handler to update it:
    
            *next_tb = ~(u64)0;
            if (evt->event_handler)
                    evt->event_handler(evt);
    
    In this case ->event_handler is hrtimer_interrupt. This will eventually
    call back through the clockevents code with the next event to be
    programmed:
    
    static int decrementer_set_next_event(unsigned long evt,
                                          struct clock_event_device *dev)
    {
            /* Don't adjust the decrementer if some irq work is pending */
            if (test_irq_work_pending())
                    return 0;
            __get_cpu_var(decrementers_next_tb) = get_tb_or_rtc() + evt;
    
    If irq work came in between these two points, we will return
    before updating decrementers_next_tb and we never process a timer
    interrupt again.
    
    This looks to have been introduced by 0215f7d8c53f (powerpc: Fix races
    with irq_work). Fix it by removing the early exit and relying on
    code later on in the function to force an early decrementer:
    
           /* We may have raced with new irq work */
           if (test_irq_work_pending())
                   set_dec(1);
    
    Signed-off-by: Anton Blanchard <anton@samba.org>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 331b483f42fb4d04d52ce920ae10a71411c859a4
Merge: 309179fabddd 2529c3a33079
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue May 27 10:03:39 2014 +0200

    Merge branch 'clockevents/3.16' of git://git.linaro.org/people/daniel.lezcano/linux into timers/core
    
    This pull request contains the following changes:
    
    * Laurent Pinchart did a lot of modifications to prepare the DT
      support.  These modifications include a lot of cleanup (structure
      renaming, preparation to support multiple channel, kzalloc usage,
      ...) and then finishes to drop the old code to the new one.
    
    * Jingoo Han removed the dev_err when an allocation fails because this
      error is already given by the mm subsystems.
    
    * Matthew Leach added the ARM global timer with vexpress, enabled the
      ARM global timer with the A5 and added the definition in the DT. He
      also fixed a invalid check when looking for an usable ARM global
      timer for A9
    
    * Maxime Ripard added the support for AllWinner A31 for sun4i and made
      the timer reset optional through the DT
    
    * Stephen Boyd used the msm timer for the udelay
    
    * Uwe Kleine-Knig fixed the non-standard 'compatible' binding for efm32
    
    * Xiubo Li clarified the types for the clocksource_mmio_read* and
      added a new Flextimer Module (FTM) with its bindings
    
    * Yang Wei added the 'notrace' attribute to 'read_sched_clock' for the
      dw_apb_timer

commit 28d4768869a297210bfd19d4a4b186acda0cdb1b
Merge: 814876b0b00a c54697ae180e
Author: Daniel Lezcano <daniel.lezcano@linaro.org>
Date:   Fri May 23 09:23:21 2014 +0200

    Merge branch 'clockevents/cmt-mtu2-tmu-cleanups' into clockevents/3.16

commit 91f0f06ccbd2a0648160aad6783b7da92e2880d7
Merge: 4a70e968893e 346f5e76b382
Author: Olof Johansson <olof@lixom.net>
Date:   Wed May 21 14:05:27 2014 -0700

    Merge branch 'depends/clockevents-cleanups' into next/boards
    
    Bringing in as an external dependency that the renesas/clock-cleanup2 branch
    relies on.
    
    * depends/clockevents-cleanups: (52 commits)
      clocksource: sh_mtu2: Sort headers alphabetically
      clocksource: sh_mtu2: Remove FSF mail address from GPL notice
      clocksource: sh_mtu2: Rename clock to "fck" in the non-legacy case
      clocksource: sh_mtu2: Add support for multiple channels per device
      clocksource: sh_mtu2: Hardcode MTU2 clock event rating to 200
      clocksource: sh_mtu2: Set cpumask to cpu_possible_mask
      clocksource: sh_mtu2: Replace hardcoded register values with macros
      clocksource: sh_mtu2: Allocate channels dynamically
      clocksource: sh_mtu2: Replace kmalloc + memset with kzalloc
      clocksource: sh_mtu2: Add index to struct sh_mtu2_channel
      clocksource: sh_mtu2: Add memory base to sh_mtu2_channel structure
      clocksource: sh_mtu2: Constify name argument to sh_mtu2_register()
      clocksource: sh_mtu2: Split channel setup to separate function
      clocksource: sh_mtu2: Rename struct sh_mtu2_priv to sh_mtu2_device
      clocksource: sh_mtu2: Split channel fields from sh_mtu2_priv
      clocksource: sh_mtu2: Turn sh_mtu2_priv fields into local variables
      clocksource: sh_mtu2: Use request_irq() instead of setup_irq()
      clocksource: sh_tmu: Sort headers alphabetically
      clocksource: sh_tmu: Remove FSF mail address from GPL notice
      clocksource: sh_tmu: Rename clock to "fck" in the non-legacy case
      ...
    
    Signed-off-by: Olof Johansson <olof@lixom.net>

commit 3f04e3d3eb77ac9df70619b9c87da71b0eeddc36
Merge: 8cffcb0ca333 2779ac167b1a
Author: Daniel Lezcano <daniel.lezcano@linaro.org>
Date:   Fri May 16 16:08:32 2014 +0200

    Merge remote-tracking branch 'tip/timers/core/timers/core' into clockevents/3.16

commit 8050936caf125fbe54111ba5e696b68a360556ba
Author: Anton Blanchard <anton@samba.org>
Date:   Fri May 9 17:47:12 2014 +1000

    powerpc: irq work racing with timer interrupt can result in timer interrupt hang
    
    I am seeing an issue where a CPU running perf eventually hangs.
    Traces show timer interrupts happening every 4 seconds even
    when a userspace task is running on the CPU. /proc/timer_list
    also shows pending hrtimers have not run in over an hour,
    including the scheduler.
    
    Looking closer, decrementers_next_tb is getting set to
    0xffffffffffffffff, and at that point we will never take
    a timer interrupt again.
    
    In __timer_interrupt() we set decrementers_next_tb to
    0xffffffffffffffff and rely on ->event_handler to update it:
    
            *next_tb = ~(u64)0;
            if (evt->event_handler)
                    evt->event_handler(evt);
    
    In this case ->event_handler is hrtimer_interrupt. This will eventually
    call back through the clockevents code with the next event to be
    programmed:
    
    static int decrementer_set_next_event(unsigned long evt,
                                          struct clock_event_device *dev)
    {
            /* Don't adjust the decrementer if some irq work is pending */
            if (test_irq_work_pending())
                    return 0;
            __get_cpu_var(decrementers_next_tb) = get_tb_or_rtc() + evt;
    
    If irq work came in between these two points, we will return
    before updating decrementers_next_tb and we never process a timer
    interrupt again.
    
    This looks to have been introduced by 0215f7d8c53f (powerpc: Fix races
    with irq_work). Fix it by removing the early exit and relying on
    code later on in the function to force an early decrementer:
    
           /* We may have raced with new irq work */
           if (test_irq_work_pending())
                   set_dec(1);
    
    Signed-off-by: Anton Blanchard <anton@samba.org>
    Cc: stable@vger.kernel.org # 3.14+
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

commit cc7964af8f997a20240d3ec5bf90c4fd20d3c48a
Author: Paul Burton <paul.burton@mips.com>
Date:   Fri Feb 14 09:24:58 2014 +0000

    MIPS: support for generic clockevents broadcast
    
    This patch adds support for generic clockevents broadcast using the a
    dummy clockevent device and the tick_broadcast function introduced by
    commit 12ad10004645 "clockevents: Add generic timer broadcast function".
    
    Signed-off-by: Paul Burton <paul.burton@imgtec.com>

commit fb0095da19a2e905dfa3141a7704d9614f64992c
Merge: d1db0eea8524 9afa27ce9414
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Apr 29 19:26:58 2014 +0200

    Merge branch 'clockevents/3.15-fixes' of git://git.linaro.org/people/daniel.lezcano/linux into timers/urgent
    
    clockevent fixes for 3.15 from Daniel Lezcano:
     * Lorenzo Pieralizi fixed an issue with the arch_arm_timer where the
       C3STOP flag for all the arch can cause some trouble by setting the
       flag only if the power domain is not always on
     * Alexander Shiyan fixed a compilation by changing the init function
       to the right prototype

commit 1c41ecb60b3de08d341be13de1dfc3d907b82694
Merge: d3a088d459ae 346f5e76b382
Author: Simon Horman <horms+renesas@verge.net.au>
Date:   Wed Apr 23 10:01:02 2014 +0900

    Merge branch 'clockevents/cmt-mtu2-tmu-cleanups' of git://git.linaro.org/people/daniel.lezcano/linux into cmt-mtu2-tmu-cleanups-for-v3.16

commit a5e11117856147bd35e740b36939f3a8a958e1e6
Merge: 63cc122381bd 346f5e76b382
Author: Daniel Lezcano <daniel.lezcano@linaro.org>
Date:   Tue Apr 22 11:53:18 2014 +0200

    Merge branch 'clockevents/cmt-mtu2-tmu-cleanups' into clockevents/3.16
    
    This patch set cleans up the Renesas CMT and TMU drivers in preparation for DT
    support.
    
    The first 35 patches are a bunch of necessary cleanups that reorganize the CMT
    and TMU drivers, their platform data, and the memory, interrupt and clock
    resources they expect. As a result the drivers accept a new platform data
    model close to the hardware with supports for all the timer channels using a
    single device.
    
    The next 13 patches (36/52 to 48/52) move all CMT and TMU platforms from the
    old to the new platform data model. Patches 49/52 to 52/52 then drop support
    for the old model and perform one more cleanup.
    
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit 1ead65812486cda65093683a99b8907a7242fa93
Merge: b6d739e95812 b97f0291a250
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Apr 1 11:00:07 2014 -0700

    Merge branch 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer changes from Thomas Gleixner:
     "This assorted collection provides:
    
       - A new timer based timer broadcast feature for systems which do not
         provide a global accessible timer device.  That allows those
         systems to put CPUs into deep idle states where the per cpu timer
         device stops.
    
       - A few NOHZ_FULL related improvements to the timer wheel
    
       - The usual updates to timer devices found in ARM SoCs
    
       - Small improvements and updates all over the place"
    
    * 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (44 commits)
      tick: Remove code duplication in tick_handle_periodic()
      tick: Fix spelling mistake in tick_handle_periodic()
      x86: hpet: Use proper destructor for delayed work
      workqueue: Provide destroy_delayed_work_on_stack()
      clocksource: CMT, MTU2, TMU and STI should depend on GENERIC_CLOCKEVENTS
      timer: Remove code redundancy while calling get_nohz_timer_target()
      hrtimer: Rearrange comments in the order struct members are declared
      timer: Use variable head instead of &work_list in __run_timers()
      clocksource: exynos_mct: silence a static checker warning
      arm: zynq: Add support for cpufreq
      arm: zynq: Don't use arm_global_timer with cpufreq
      clocksource/cadence_ttc: Overhaul clocksource frequency adjustment
      clocksource/cadence_ttc: Call clockevents_update_freq() with IRQs enabled
      clocksource: Add Kconfig entries for CMT, MTU2, TMU and STI
      sh: Remove Kconfig entries for TMU, CMT and MTU2
      ARM: shmobile: Remove CMT, TMU and STI Kconfig entries
      clocksource: armada-370-xp: Use atomic access for shared registers
      clocksource: orion: Use atomic access for shared registers
      clocksource: timer-keystone: Delete unnecessary variable
      clocksource: timer-keystone: introduce clocksource driver for Keystone
      ...

commit ccb738e88b60ec21a96f8f5e11a1857236deb518
Author: Martin Schwidefsky <schwidefsky@de.ibm.com>
Date:   Fri Nov 22 12:04:18 2013 +0100

    s390,time: revert direct ktime path for s390 clockevent device
    
    commit 8adbf78ec4839c1dc4ff20c9a1f332a7bc99e6e6 upstream.
    
    Git commit 4f37a68cdaf6dea833cfdded2a3e0c47c0f006da
    "s390: Use direct ktime path for s390 clockevent device" makes use
    of the CLOCK_EVT_FEAT_KTIME clockevent option to avoid the delta
    calculation with ktime_get() in clockevents_program_event and the
    get_tod_clock() in s390_next_event. This is based on the assumption
    that the difference between the internal ktime and the hardware
    clock is reflected in the wall_to_monotonic delta. But this is not
    true, the ntp corrections are applied via changes to the tk->mult
    multiplier and this is not reflected in wall_to_monotonic.
    
    In theory this could be solved by using the raw monotonic clock
    but it is simpler to switch back to the standard clock delta
    calculation.
    
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>

commit 32ed904ec15d37d35afae9ce784951ec955d20a5
Author: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
Date:   Tue Apr 16 13:49:26 2013 -0400

    xen/smp: Fix leakage of timer interrupt line for every CPU online/offline.
    
    commit 888b65b4bc5e7fcbbb967023300cd5d44dba1950 upstream.
    
    In the PVHVM path when we do CPU online/offline path we would
    leak the timer%d IRQ line everytime we do a offline event. The
    online path (xen_hvm_setup_cpu_clockevents via
    x86_cpuinit.setup_percpu_clockev) would allocate a new interrupt
    line for the timer%d.
    
    But we would still use the old interrupt line leading to:
    
    kernel BUG at /home/konrad/ssd/konrad/linux/kernel/hrtimer.c:1261!
    invalid opcode: 0000 [#1] SMP
    RIP: 0010:[<ffffffff810b9e21>]  [<ffffffff810b9e21>] hrtimer_interrupt+0x261/0x270
    .. snip..
     <IRQ>
     [<ffffffff810445ef>] xen_timer_interrupt+0x2f/0x1b0
     [<ffffffff81104825>] ? stop_machine_cpu_stop+0xb5/0xf0
     [<ffffffff8111434c>] handle_irq_event_percpu+0x7c/0x240
     [<ffffffff811175b9>] handle_percpu_irq+0x49/0x70
     [<ffffffff813a74a3>] __xen_evtchn_do_upcall+0x1c3/0x2f0
     [<ffffffff813a760a>] xen_evtchn_do_upcall+0x2a/0x40
     [<ffffffff8167c26d>] xen_hvm_callback_vector+0x6d/0x80
     <EOI>
     [<ffffffff81666d01>] ? start_secondary+0x193/0x1a8
     [<ffffffff81666cfd>] ? start_secondary+0x18f/0x1a8
    
    There is also the oddity (timer1) in the /proc/interrupts after
    offlining CPU1:
    
      64:       1121          0  xen-percpu-virq      timer0
      78:          0          0  xen-percpu-virq      timer1
      84:          0       2483  xen-percpu-virq      timer2
    
    This patch fixes it.
    
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    [bwh: Backported to 3.2: adjust context]
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>
    Cc: Yijing Wang <wangyijing@huawei.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 5f0ba3b462b2d36b3c28748863747fb1050f40d0
Author: Soren Brinkmann <soren.brinkmann@xilinx.com>
Date:   Wed Feb 19 15:14:41 2014 -0800

    clocksource/cadence_ttc: Call clockevents_update_freq() with IRQs enabled
    
    The timer core takes care of serialization and IRQs. Hence the driver is
    no longer required to disable interrupts when calling
    clockevents_update_freq().
    
    Signed-off-by: Soren Brinkmann <soren.brinkmann@xilinx.com>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Acked-by: Michal Simek <michal.simek@xilinx.com>

commit a5d90c923bcfb9632d998ed06e9569216ad695f3
Author: Borislav Petkov <bp@suse.de>
Date:   Tue Mar 4 17:02:17 2014 +0100

    x86/efi: Quirk out SGI UV
    
    Alex reported hitting the following BUG after the EFI 1:1 virtual
    mapping work was merged,
    
     kernel BUG at arch/x86/mm/init_64.c:351!
     invalid opcode: 0000 [#1] SMP
     Call Trace:
      [<ffffffff818aa71d>] init_extra_mapping_uc+0x13/0x15
      [<ffffffff818a5e20>] uv_system_init+0x22b/0x124b
      [<ffffffff8108b886>] ? clockevents_register_device+0x138/0x13d
      [<ffffffff81028dbb>] ? setup_APIC_timer+0xc5/0xc7
      [<ffffffff8108b620>] ? clockevent_delta2ns+0xb/0xd
      [<ffffffff818a3a92>] ? setup_boot_APIC_clock+0x4a8/0x4b7
      [<ffffffff8153d955>] ? printk+0x72/0x74
      [<ffffffff818a1757>] native_smp_prepare_cpus+0x389/0x3d6
      [<ffffffff818957bc>] kernel_init_freeable+0xb7/0x1fb
      [<ffffffff81535530>] ? rest_init+0x74/0x74
      [<ffffffff81535539>] kernel_init+0x9/0xff
      [<ffffffff81541dfc>] ret_from_fork+0x7c/0xb0
      [<ffffffff81535530>] ? rest_init+0x74/0x74
    
    Getting this thing to work with the new mapping scheme would need more
    work, so automatically switch to the old memmap layout for SGI UV.
    
    Acked-by: Russ Anderson <rja@sgi.com>
    Cc: Alex Thorlton <athorlton@sgi.com
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

commit 5f0e030930d715920be4de638084aaf8653867e8
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Feb 19 13:52:29 2014 +0200

    x86, tsc: Fallback to normal calibration if fast MSR calibration fails
    
    If we cannot calibrate TSC via MSR based calibration
    try_msr_calibrate_tsc() stores zero to fast_calibrate and returns that
    to the caller. This value gets then propagated further to clockevents
    code resulting division by zero oops like the one below:
    
     divide error: 0000 [#1] PREEMPT SMP
     Modules linked in:
     CPU: 0 PID: 1 Comm: swapper/0 Tainted: G        W    3.13.0+ #47
     task: ffff880075508000 ti: ffff880075506000 task.ti: ffff880075506000
     RIP: 0010:[<ffffffff810aec14>]  [<ffffffff810aec14>] clockevents_config.part.3+0x24/0xa0
     RSP: 0000:ffff880075507e58  EFLAGS: 00010246
     RAX: ffffffffffffffff RBX: ffff880079c0cd80 RCX: 0000000000000000
     RDX: 0000000000000000 RSI: 0000000000000000 RDI: ffffffffffffffff
     RBP: ffff880075507e70 R08: 0000000000000001 R09: 00000000000000be
     R10: 00000000000000bd R11: 0000000000000003 R12: 000000000000b008
     R13: 0000000000000008 R14: 000000000000b010 R15: 0000000000000000
     FS:  0000000000000000(0000) GS:ffff880079c00000(0000) knlGS:0000000000000000
     CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b
     CR2: ffff880079fff000 CR3: 0000000001c0b000 CR4: 00000000001006f0
     Stack:
      ffff880079c0cd80 000000000000b008 0000000000000008 ffff880075507e88
      ffffffff810aecb0 ffff880079c0cd80 ffff880075507e98 ffffffff81030168
      ffff880075507ed8 ffffffff81d1104f 00000000000000c3 0000000000000000
     Call Trace:
      [<ffffffff810aecb0>] clockevents_config_and_register+0x20/0x30
      [<ffffffff81030168>] setup_APIC_timer+0xc8/0xd0
      [<ffffffff81d1104f>] setup_boot_APIC_clock+0x4cc/0x4d8
      [<ffffffff81d0f5de>] native_smp_prepare_cpus+0x3dd/0x3f0
      [<ffffffff81d02ee9>] kernel_init_freeable+0xc3/0x205
      [<ffffffff8177c910>] ? rest_init+0x90/0x90
      [<ffffffff8177c91e>] kernel_init+0xe/0x120
      [<ffffffff8178deec>] ret_from_fork+0x7c/0xb0
      [<ffffffff8177c910>] ? rest_init+0x90/0x90
    
    Prevent this from happening by:
     1) Modifying try_msr_calibrate_tsc() to return calibration value or zero
        if it fails.
     2) Check this return value in native_calibrate_tsc() and in case of zero
        fallback to use normal non-MSR based calibration.
    
    [mw: Added subject and changelog]
    
    Reported-and-tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Bin Gao <bin.gao@linux.intel.com>
    Cc: One Thousand Gnomes <gnomes@lxorguk.ukuu.org.uk>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Link: http://lkml.kernel.org/r/1392810750-18660-1-git-send-email-mika.westerberg@linux.intel.com
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit d9bd24c3bc422acf43f744124d6537921719352f
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sun Dec 29 12:39:50 2013 +0000

    ARM: fix footbridge clockevent device
    
    commit 4ff859fe1dc0da0f87bbdfff78f527898878fa4a upstream.
    
    The clockevents code was being told that the footbridge clock event
    device ticks at 16x the rate which it actually does.  This leads to
    timekeeping problems since it allows the clocksource to wrap before
    the kernel notices.  Fix this by using the correct clock.
    
    Fixes: 4e8d76373c9fd ("ARM: footbridge: convert to clockevents/clocksource")
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    [bwh: Backported to 3.2: fold in the relevant parts of commit 838a2ae80a6a
     ('ARM: use clockevents_config_and_register() where possible')]
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit 003cad75f07b923d1cc75d032a931f461930d28c
Author: Mark Rutland <mark.rutland@arm.com>
Date:   Thu Mar 7 15:09:24 2013 +0000

    clockevents: Don't allow dummy broadcast timers
    
    commit a7dc19b8652c862d5b7c4d2339bd3c428bd29c4a upstream.
    
    Currently tick_check_broadcast_device doesn't reject clock_event_devices
    with CLOCK_EVT_FEAT_DUMMY, and may select them in preference to real
    hardware if they have a higher rating value. In this situation, the
    dummy timer is responsible for broadcasting to itself, and the core
    clockevents code may attempt to call non-existent callbacks for
    programming the dummy, eventually leading to a panic.
    
    This patch makes tick_check_broadcast_device always reject dummy timers,
    preventing this problem.
    
    Signed-off-by: Mark Rutland <mark.rutland@arm.com>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: Jon Medhurst (Tixy) <tixy@linaro.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

commit f1689bb7abec8e2e670d8ad11eaa86d54bad8cfd
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Feb 7 16:00:46 2014 +0100

    time: Fixup fallout from recent clockevent/tick changes
    
    Make the stub function static inline instead of static and move the
    clockevents related function into the proper ifdeffed section.
    
    Reported-by: Fengguang Wu <fengguang.wu@intel.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Soren Brinkmann <soren.brinkmann@xilinx.com>
    Cc: Preeti U Murthy <preeti@linux.vnet.ibm.com>

commit ba8f20c2eb4158a443e9d6a909aee5010efa0c69
Author: Preeti U Murthy <preeti@linux.vnet.ibm.com>
Date:   Fri Feb 7 13:36:52 2014 +0530

    cpuidle: Handle clockevents_notify(BROADCAST_ENTER) failure
    
    Some archs set the CPUIDLE_FLAG_TIMER_STOP flag for idle states in which the
    local timers stop. The cpuidle_idle_call() currently handles such idle states
    by calling into the broadcast framework so as to wakeup CPUs at their next
    wakeup event. With the hrtimer mode of broadcast, the BROADCAST_ENTER call
    into the broadcast frameowork can fail for archs that do not have an external
    clock device to handle wakeups and the CPU in question has thus to be made
    the stand by CPU. This patch handles such cases by failing the call into
    cpuidle so that the arch can take some default action. The arch will certainly
    not enter a similar idle state because a failed cpuidle call will also implicitly
    indicate that the broadcast framework has not registered this CPU to be woken up.
    Hence we are safe if we fail the cpuidle call.
    
    In the process move the functions that trace idle statistics just before and
    after the entry and exit into idle states respectively. In other
    scenarios where the call to cpuidle fails, we end up not tracing idle
    entry and exit since a decision on an idle state could not be taken. Similarly
    when the call to broadcast framework fails, we skip tracing idle statistics
    because we are in no further position to take a decision on an alternative
    idle state to enter into.
    
    Signed-off-by: Preeti U Murthy <preeti@linux.vnet.ibm.com>
    Cc: deepthi@linux.vnet.ibm.com
    Cc: paulmck@linux.vnet.ibm.com
    Cc: fweisbec@gmail.com
    Cc: paulus@samba.org
    Cc: srivatsa.bhat@linux.vnet.ibm.com
    Cc: svaidy@linux.vnet.ibm.com
    Cc: peterz@infradead.org
    Cc: benh@kernel.crashing.org
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: linuxppc-dev@lists.ozlabs.org
    Link: http://lkml.kernel.org/r/20140207080652.17187.66344.stgit@preeti.in.ibm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit da7e6f45c34d39186b72328bacc4dd86bff60e0a
Author: Preeti U Murthy <preeti@linux.vnet.ibm.com>
Date:   Fri Feb 7 13:36:06 2014 +0530

    time: Change the return type of clockevents_notify() to integer
    
    The broadcast framework can potentially be made use of by archs which do not have an
    external clock device as well. Then, it is required that one of the CPUs need
    to handle the broadcasting of wakeup IPIs to the CPUs in deep idle. As a
    result its local timers should remain functional all the time. For such
    a CPU, the BROADCAST_ENTER notification has to fail indicating that its clock
    device cannot be shutdown. To make way for this support, change the return
    type of tick_broadcast_oneshot_control() and hence clockevents_notify() to
    indicate such scenarios.
    
    Signed-off-by: Preeti U Murthy <preeti@linux.vnet.ibm.com>
    Cc: deepthi@linux.vnet.ibm.com
    Cc: paulmck@linux.vnet.ibm.com
    Cc: fweisbec@gmail.com
    Cc: paulus@samba.org
    Cc: srivatsa.bhat@linux.vnet.ibm.com
    Cc: svaidy@linux.vnet.ibm.com
    Cc: peterz@infradead.org
    Cc: benh@kernel.crashing.org
    Cc: rafael.j.wysocki@intel.com
    Cc: linuxppc-dev@lists.ozlabs.org
    Link: http://lkml.kernel.org/r/20140207080606.17187.78306.stgit@preeti.in.ibm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit fe79a9ba11962a603fb6af68fcb476e64031e46c
Author: Soren Brinkmann <soren.brinkmann@xilinx.com>
Date:   Mon Feb 3 14:34:32 2014 -0800

    clockevents: Adjust timer interval when frequency changes
    
    clockevent devices in periodic mode are not updated when the frequency
    of the device changes. Issue a dev->set_mode() callback which forces
    the device to reevaluate the timer settings.
    
    Signed-off-by: Soren Brinkmann <soren.brinkmann@xilinx.com>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: Michal Simek <michal.simek@xilinx.com>
    Link: http://lkml.kernel.org/r/1391466877-28908-3-git-send-email-soren.brinkmann@xilinx.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 627ee7947e2e83ba565c31c5c9373d6e364b1ecd
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Feb 3 14:34:31 2014 -0800

    clockevents: Serialize calls to clockevents_update_freq() in the core
    
    We can identify the broadcast device in the core and serialize all
    callers including interrupts on a different CPU against the update.
    Also, disabling interrupts is moved into the core allowing callers to
    leave interrutps enabled when calling clockevents_update_freq().
    
    Signed-off-by: Soren Brinkmann <soren.brinkmann@xilinx.com>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: Soeren Brinkmann <soren.brinkmann@xilinx.com>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: Michal Simek <michal.simek@xilinx.com>
    Link: http://lkml.kernel.org/r/1391466877-28908-2-git-send-email-soren.brinkmann@xilinx.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 829d9315c46a2be57a8fb40c89aeb7db61513d96
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Mon Feb 3 13:07:24 2014 +0100

    netfilter: nf_nat_h323: fix crash in nf_ct_unlink_expect_report()
    
    Similar bug fixed in SIP module in 3f509c6 ("netfilter: nf_nat_sip: fix
    incorrect handling of EBUSY for RTCP expectation").
    
    BUG: unable to handle kernel paging request at 00100104
    IP: [<f8214f07>] nf_ct_unlink_expect_report+0x57/0xf0 [nf_conntrack]
    ...
    Call Trace:
      [<c0244bd8>] ? del_timer+0x48/0x70
      [<f8215687>] nf_ct_remove_expectations+0x47/0x60 [nf_conntrack]
      [<f8211c99>] nf_ct_delete_from_lists+0x59/0x90 [nf_conntrack]
      [<f8212e5e>] death_by_timeout+0x14e/0x1c0 [nf_conntrack]
      [<f8212d10>] ? nf_conntrack_set_hashsize+0x190/0x190 [nf_conntrack]
      [<c024442d>] call_timer_fn+0x1d/0x80
      [<c024461e>] run_timer_softirq+0x18e/0x1a0
      [<f8212d10>] ? nf_conntrack_set_hashsize+0x190/0x190 [nf_conntrack]
      [<c023e6f3>] __do_softirq+0xa3/0x170
      [<c023e650>] ? __local_bh_enable+0x70/0x70
      <IRQ>
      [<c023e587>] ? irq_exit+0x67/0xa0
      [<c0202af6>] ? do_IRQ+0x46/0xb0
      [<c027ad05>] ? clockevents_notify+0x35/0x110
      [<c066ac6c>] ? common_interrupt+0x2c/0x40
      [<c056e3c1>] ? cpuidle_enter_state+0x41/0xf0
      [<c056e6fb>] ? cpuidle_idle_call+0x8b/0x100
      [<c02085f8>] ? arch_cpu_idle+0x8/0x30
      [<c027314b>] ? cpu_idle_loop+0x4b/0x140
      [<c0273258>] ? cpu_startup_entry+0x18/0x20
      [<c066056d>] ? rest_init+0x5d/0x70
      [<c0813ac8>] ? start_kernel+0x2ec/0x2f2
      [<c081364f>] ? repair_env_string+0x5b/0x5b
      [<c0813269>] ? i386_start_kernel+0x33/0x35
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>

commit 32956a0646e1f63e03d2dbf35370772934d5654f
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sun Dec 29 12:39:50 2013 +0000

    ARM: fix footbridge clockevent device
    
    commit 4ff859fe1dc0da0f87bbdfff78f527898878fa4a upstream.
    
    The clockevents code was being told that the footbridge clock event
    device ticks at 16x the rate which it actually does.  This leads to
    timekeeping problems since it allows the clocksource to wrap before
    the kernel notices.  Fix this by using the correct clock.
    
    Fixes: 4e8d76373c9fd ("ARM: footbridge: convert to clockevents/clocksource")
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 4adf2b4bd303e73dfc13c3428383a8dba129fdb5
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sun Dec 29 12:39:50 2013 +0000

    ARM: fix footbridge clockevent device
    
    commit 4ff859fe1dc0da0f87bbdfff78f527898878fa4a upstream.
    
    The clockevents code was being told that the footbridge clock event
    device ticks at 16x the rate which it actually does.  This leads to
    timekeeping problems since it allows the clocksource to wrap before
    the kernel notices.  Fix this by using the correct clock.
    
    Fixes: 4e8d76373c9fd ("ARM: footbridge: convert to clockevents/clocksource")
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit e59da0aedb573a347fa501fa63d3ff5055aa1bc7
Merge: a6da83f98267 c1dcc927dae0
Author: Ingo Molnar <mingo@kernel.org>
Date:   Wed Jan 15 07:39:30 2014 +0100

    Merge branch 'clockevents/3.13-fixes' of git://git.linaro.org/people/daniel.lezcano/linux into timers/urgent
    
    Pull clock driver fix from Daniel Lezcano:
    
     " * Soren Brinkmann fixed the cadence_ttc driver where a call to
         clk_get_rate happens in an interrupt context. More precisely in an IPI
         when the broadcast timer is initialized for each cpu in the cpuidle
         driver. "
    
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 1b3f82876006bd4172ca7696aa367baf96ec7c15
Merge: d05d24a984f8 98aefbe72ec6
Author: Ingo Molnar <mingo@kernel.org>
Date:   Sun Jan 12 17:28:52 2014 +0100

    Merge branch 'clockevents/3.14' of git://git.linaro.org/people/daniel.lezcano/linux into timers/core
    
    Pull clocksource/clockevent updates from Daniel Lezcano:
    
      * Axel Lin removed an unused structure defining the ids for the
        bcm kona driver.
    
      * Ezequiel Garcia enabled the timer divider only when the 25MHz
        timer is not used for the armada 370 XP.
    
      * Jingoo Han removed a pointless platform data initialization for
        the sh_mtu and sh_mtu2.
    
      * Laurent Pinchart added the clk_prepare/clk_unprepare for sh_cmt.
    
      * Linus Walleij added a useful warning in clk_of when no clocks
        are found while the old behavior was to silently hang at boot time.
    
      * Maxime Ripard added the high speed timer drivers for the
        Allwinner SoCs (A10, A13, A20). He increased the rating, shared the
        irq across all available cpus and fixed the clockevent's irq
        initialization for the sun4i.
    
      * Michael Opdenacker removed the usage of the IRQF_DISABLED for the
        all the timers driver located in drivers/clocksource.
    
      * Stephen Boyd switched to sched_clock_register for the
        arm_global_timer, cadence_ttc, sun4i and orion timers.
    
    Conflicts:
            drivers/clocksource/clksrc-of.c
    
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 7bda701e012373ca53c9d837b7b25131852e0238
Author: fan.du <fan.du@windriver.com>
Date:   Fri Jan 3 10:18:58 2014 +0800

    {vxlan, inet6} Mark vxlan_dev flags with VXLAN_F_IPV6 properly
    
    Even if user doesn't supply the physical netdev to attach vxlan dev
    to, and at the same time user want to vxlan sit top of IPv6, mark
    vxlan_dev flags with VXLAN_F_IPV6 to create IPv6 based socket.
    Otherwise kernel crashes safely every time spitting below messages,
    
    Steps to reproduce:
    ip link add vxlan0 type vxlan id 42 group ff0e::110
    ip link set vxlan0 up
    
    [   62.656266] BUG: unable to handle kernel NULL pointer dereference[   62.656320] ip (3008) used greatest stack depth: 3912 bytes left
     at 0000000000000046
    [   62.656423] IP: [<ffffffff816d822d>] ip6_route_output+0xbd/0xe0
    [   62.656525] PGD 2c966067 PUD 2c9a2067 PMD 0
    [   62.656674] Oops: 0000 [#1] SMP
    [   62.656781] Modules linked in: vxlan netconsole deflate zlib_deflate af_key
    [   62.657083] CPU: 1 PID: 2128 Comm: whoopsie Not tainted 3.12.0+ #182
    [   62.657083] Hardware name: innotek GmbH VirtualBox, BIOS VirtualBox 12/01/2006
    [   62.657083] task: ffff88002e2335d0 ti: ffff88002c94c000 task.ti: ffff88002c94c000
    [   62.657083] RIP: 0010:[<ffffffff816d822d>]  [<ffffffff816d822d>] ip6_route_output+0xbd/0xe0
    [   62.657083] RSP: 0000:ffff88002fd038f8  EFLAGS: 00210296
    [   62.657083] RAX: 0000000000000000 RBX: ffff88002fd039e0 RCX: 0000000000000000
    [   62.657083] RDX: ffff88002fd0eb68 RSI: ffff88002fd0d278 RDI: ffff88002fd0d278
    [   62.657083] RBP: ffff88002fd03918 R08: 0000000002000000 R09: 0000000000000000
    [   62.657083] R10: 00000000000001ff R11: 0000000000000000 R12: 0000000000000001
    [   62.657083] R13: ffff88002d96b480 R14: ffffffff81c8e2c0 R15: 0000000000000001
    [   62.657083] FS:  0000000000000000(0000) GS:ffff88002fd00000(0063) knlGS:00000000f693b740
    [   62.657083] CS:  0010 DS: 002b ES: 002b CR0: 0000000080050033
    [   62.657083] CR2: 0000000000000046 CR3: 000000002c9d2000 CR4: 00000000000006e0
    [   62.657083] Stack:
    [   62.657083]  ffff88002fd03a40 ffffffff81c8e2c0 ffff88002fd039e0 ffff88002d96b480
    [   62.657083]  ffff88002fd03958 ffffffff816cac8b ffff880019277cc0 ffff8800192b5d00
    [   62.657083]  ffff88002d5bc000 ffff880019277cc0 0000000000001821 0000000000000001
    [   62.657083] Call Trace:
    [   62.657083]  <IRQ>
    [   62.657083]  [<ffffffff816cac8b>] ip6_dst_lookup_tail+0xdb/0xf0
    [   62.657083]  [<ffffffff816caea0>] ip6_dst_lookup+0x10/0x20
    [   62.657083]  [<ffffffffa0020c13>] vxlan_xmit_one+0x193/0x9c0 [vxlan]
    [   62.657083]  [<ffffffff8137b3b7>] ? account+0xc7/0x1f0
    [   62.657083]  [<ffffffffa0021513>] vxlan_xmit+0xd3/0x400 [vxlan]
    [   62.657083]  [<ffffffff8161390d>] dev_hard_start_xmit+0x49d/0x5e0
    [   62.657083]  [<ffffffff81613d29>] dev_queue_xmit+0x2d9/0x480
    [   62.657083]  [<ffffffff817cb854>] ? _raw_write_unlock_bh+0x14/0x20
    [   62.657083]  [<ffffffff81630565>] ? eth_header+0x35/0xe0
    [   62.657083]  [<ffffffff8161bc5e>] neigh_resolve_output+0x11e/0x1e0
    [   62.657083]  [<ffffffff816ce0e0>] ? ip6_fragment+0xad0/0xad0
    [   62.657083]  [<ffffffff816cb465>] ip6_finish_output2+0x2f5/0x470
    [   62.657083]  [<ffffffff816ce166>] ip6_finish_output+0x86/0xc0
    [   62.657083]  [<ffffffff816ce218>] ip6_output+0x78/0xb0
    [   62.657083]  [<ffffffff816eadd6>] mld_sendpack+0x256/0x2a0
    [   62.657083]  [<ffffffff816ebd8c>] mld_ifc_timer_expire+0x17c/0x290
    [   62.657083]  [<ffffffff816ebc10>] ? igmp6_timer_handler+0x80/0x80
    [   62.657083]  [<ffffffff816ebc10>] ? igmp6_timer_handler+0x80/0x80
    [   62.657083]  [<ffffffff81051065>] call_timer_fn+0x45/0x150
    [   62.657083]  [<ffffffff816ebc10>] ? igmp6_timer_handler+0x80/0x80
    [   62.657083]  [<ffffffff81052353>] run_timer_softirq+0x1f3/0x2a0
    [   62.657083]  [<ffffffff8102dfd8>] ? lapic_next_event+0x18/0x20
    [   62.657083]  [<ffffffff8109e36f>] ? clockevents_program_event+0x6f/0x110
    [   62.657083]  [<ffffffff8104a2f6>] __do_softirq+0xd6/0x2b0
    [   62.657083]  [<ffffffff8104a75e>] irq_exit+0x7e/0xa0
    [   62.657083]  [<ffffffff8102ea15>] smp_apic_timer_interrupt+0x45/0x60
    [   62.657083]  [<ffffffff817d3eca>] apic_timer_interrupt+0x6a/0x70
    [   62.657083]  <EOI>
    [   62.657083]  [<ffffffff817d4a35>] ? sysenter_dispatch+0x7/0x1a
    [   62.657083] Code: 4d 8b 85 a8 02 00 00 4c 89 e9 ba 03 04 00 00 48 c7 c6 c0 be 8d 81 48 c7 c7 48 35 a3 81 31 c0 e8 db 68 0e 00 49 8b 85 a8 02 00 00 <0f> b6 40 46 c0 e8 05 0f b6 c0 c1 e0 03 41 09 c4 e9 77 ff ff ff
    [   62.657083] RIP  [<ffffffff816d822d>] ip6_route_output+0xbd/0xe0
    [   62.657083]  RSP <ffff88002fd038f8>
    [   62.657083] CR2: 0000000000000046
    [   62.657083] ---[ end trace ba8a9583d7cd1934 ]---
    [   62.657083] Kernel panic - not syncing: Fatal exception in interrupt
    
    Signed-off-by: Fan Du <fan.du@windriver.com>
    Reported-by: Ryan Whelan <rcwhelan@gmail.com>
    Acked-by: Cong Wang <xiyou.wangcong@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit c1dcc927dae01dfd4904ee82ce2c00b50eab6dc3
Author: Soren Brinkmann <soren.brinkmann@xilinx.com>
Date:   Tue Nov 26 17:04:50 2013 -0800

    clocksource: cadence_ttc: Fix mutex taken inside interrupt context
    
    When the kernel is compiled with:
    CONFIG_HIGH_RES_TIMERS=no
    CONFIG_HZ_PERIODIC=yes
    CONFIG_DEBUG_ATOMIC_SLEEP=yes
    
    The following WARN appears:
    
    WARNING: CPU: 1 PID: 0 at linux/kernel/mutex.c:856 mutex_trylock+0x70/0x1fc()
    DEBUG_LOCKS_WARN_ON(in_interrupt())
    Modules linked in:
    CPU: 1 PID: 0 Comm: swapper/1 Not tainted 3.12.0-xilinx-dirty #93
    [<c0014a78>] (unwind_backtrace+0x0/0x11c) from [<c0011b6c>] (show_stack+0x10/0x14)
    [<c0011b6c>] (show_stack+0x10/0x14) from [<c039120c>] (dump_stack+0x7c/0xc0)
    [<c039120c>] (dump_stack+0x7c/0xc0) from [<c001fda4>] (warn_slowpath_common+0x60/0x84)
    [<c001fda4>] (warn_slowpath_common+0x60/0x84) from [<c001fe48>] (warn_slowpath_fmt+0x2c/0x3c)
    [<c001fe48>] (warn_slowpath_fmt+0x2c/0x3c) from [<c0392658>] (mutex_trylock+0x70/0x1fc)
    [<c0392658>] (mutex_trylock+0x70/0x1fc) from [<c02dfc08>] (clk_prepare_lock+0xc/0xe4)
    [<c02dfc08>] (clk_prepare_lock+0xc/0xe4) from [<c02e099c>] (clk_get_rate+0xc/0x44)
    [<c02e099c>] (clk_get_rate+0xc/0x44) from [<c02d0394>] (ttc_set_mode+0x34/0x78)
    [<c02d0394>] (ttc_set_mode+0x34/0x78) from [<c005f794>] (clockevents_set_mode+0x28/0x5c)
    [<c005f794>] (clockevents_set_mode+0x28/0x5c) from [<c00607fc>] (tick_broadcast_on_off+0x190/0x1c0)
    [<c00607fc>] (tick_broadcast_on_off+0x190/0x1c0) from [<c005f168>] (clockevents_notify+0x58/0x1ac)
    [<c005f168>] (clockevents_notify+0x58/0x1ac) from [<c02b99dc>] (cpuidle_setup_broadcast_timer+0x20/0x24)
    [<c02b99dc>] (cpuidle_setup_broadcast_timer+0x20/0x24) from [<c006cd04>] (generic_smp_call_function_single_interrupt+0)
    [<c006cd04>] (generic_smp_call_function_single_interrupt+0xe0/0x130) from [<c00138c8>] (handle_IPI+0x88/0x118)
    [<c00138c8>] (handle_IPI+0x88/0x118) from [<c0008504>] (gic_handle_irq+0x58/0x60)
    [<c0008504>] (gic_handle_irq+0x58/0x60) from [<c0012644>] (__irq_svc+0x44/0x78)
    Exception stack(0xef099fa0 to 0xef099fe8)
    9fa0: 00000001 ef092100 00000000 ef092100 ef098000 00000015 c0399f2c c0579d74
    9fc0: 0000406a 413fc090 00000000 00000000 00000000 ef099fe8 c00666ec c000f46c
    9fe0: 20000113 ffffffff
    [<c0012644>] (__irq_svc+0x44/0x78) from [<c000f46c>] (arch_cpu_idle+0x34/0x3c)
    [<c000f46c>] (arch_cpu_idle+0x34/0x3c) from [<c0053980>] (cpu_startup_entry+0xa8/0x10c)
    [<c0053980>] (cpu_startup_entry+0xa8/0x10c) from [<000085a4>] (0x85a4)
    
    We are in an interrupt context (IPI) and we are calling clk_get_rate in the
    set_mode function which in turn ends up by getting a mutex... Even if that
    does not hang, it is a potential kernel deadlock.
    
    It is not allowed to call clk_get_rate() from interrupt context. To
    avoid such calls the timer input frequency is stored in the driver's
    data struct which makes it accessible to the driver in any context.
    
    [dlezcano] completed the changelog with the WARN trace and added a more
    detailed description. Tested on zync zc702.
    
    Acked-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Tested-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Signed-off-by: Soren Brinkmann <soren.brinkmann@xilinx.com>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit 4ff859fe1dc0da0f87bbdfff78f527898878fa4a
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sun Dec 29 12:39:50 2013 +0000

    ARM: fix footbridge clockevent device
    
    The clockevents code was being told that the footbridge clock event
    device ticks at 16x the rate which it actually does.  This leads to
    timekeeping problems since it allows the clocksource to wrap before
    the kernel notices.  Fix this by using the correct clock.
    
    Fixes: 4e8d76373c9fd ("ARM: footbridge: convert to clockevents/clocksource")
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Cc: <stable@vger.kernel.org>

commit 97aee1b8e444d0aa4904fb5d4850c9490e5b9935
Merge: 72521014037b 57dee992df24
Author: Simon Horman <horms+renesas@verge.net.au>
Date:   Thu Dec 19 17:14:16 2013 +0900

    Merge remote-tracking branch 'daniel-lezcano/clockevents/for-Simon-3.13-rc2' into dt3-base

commit 98aefbe72ec6015f90fe045ed16c5cf755da283d
Merge: 6d19944bd260 57dee992df24
Author: Daniel Lezcano <daniel.lezcano@linaro.org>
Date:   Wed Dec 18 15:14:11 2013 +0100

    Merge branch 'clockevents/for-Simon-3.13-rc2' into clockevents/3.14
    
     * clocksource: sh_cmt: Add clk_prepare/unprepare support
    
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit 1f85008e74768a88e1ddb96cc1fe45bb2378166c
Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Date:   Wed Sep 4 10:55:17 2013 +0100

    arm64: enable generic clockevent broadcast
    
    On platforms with power management capabilities, timers that are shut
    down when a CPU enters deep C-states must be emulated using an always-on
    timer and a timer IPI to relay the timer IRQ to target CPUs on an SMP
    system.
    
    This patch enables the generic clockevents broadcast infrastructure for
    arm64, by providing the required Kconfig entries and adding the timer
    IPI infrastructure.
    
    Acked-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>

commit 5d5119a476f77b57381ddd66d4f7034a5447480b
Merge: 17b2112f332d 9ab4727c1d41
Author: Ingo Molnar <mingo@kernel.org>
Date:   Tue Dec 10 20:47:22 2013 +0100

    Merge branch 'clockevents/fixes' of git://git.linaro.org/people/daniel.lezcano/linux into timers/urgent
    
    Pull clockevents/clocksource fixes from Daniel Lezcano:
    
      * Axel Lin added a missing dependency on CLKSRC_MMIO in the Kconfig
        for the time-efm32
    
      * Dinh Nguyen fixed read_sched_clock to return the right value and
        added the clksrc-of missing definition for the dw_apb_timer
    
      * Ezequiel Garcia registered the sched clock after the counter,
        thus preventing time jump in the traces for the armada-370-xp
    
      * Marc Zyngier stopped the timer before enabling the irq in order
        to prevent it to be fired before the clockevent is registered for
        the sunxi
    
      * Thierry Reding removed a of_node_put in clksrc-of because the
        reference is not held
    
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 7281bb5614bcdbf6789e9559420b814689b122e3
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Thu Jun 13 11:39:50 2013 -0700

    clockevents: Prefer CPU local devices over global devices
    
    commit 70e5975d3a04be5479a28eec4a2fb10f98ad2785 upstream.
    
    On an SMP system with only one global clockevent and a dummy
    clockevent per CPU we run into problems. We want the dummy
    clockevents to be registered as the per CPU tick devices, but
    we can only achieve that if we register the dummy clockevents
    before the global clockevent or if we artificially inflate the
    rating of the dummy clockevents to be higher than the rating
    of the global clockevent. Failure to do so leads to boot
    hangs when the dummy timers are registered on all other CPUs
    besides the CPU that accepted the global clockevent as its tick
    device and there is no broadcast timer to poke the dummy
    devices.
    
    If we're registering multiple clockevents and one clockevent is
    global and the other is local to a particular CPU we should
    choose to use the local clockevent regardless of the rating of
    the device. This way, if the clockevent is a dummy it will take
    the tick device duty as long as there isn't a higher rated tick
    device and any global clockevent will be bumped out into
    broadcast mode, fixing the problem described above.
    
    Reported-and-tested-by: Mark Rutland <mark.rutland@arm.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Tested-by: soren.brinkmann@xilinx.com
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: John Stultz <john.stultz@linaro.org>
    Link: http://lkml.kernel.org/r/20130613183950.GA32061@codeaurora.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kim Phillips <kim.phillips@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 9bae8ea0544becdd8e6716b318c1844aeea41a69
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Apr 25 20:31:50 2013 +0000

    clockevents: Split out selection logic
    
    commit 45cb8e01b2ecef1c2afb18333e95793fa1a90281 upstream.
    
    Split out the clockevent device selection logic. Preparatory patch to
    allow unbinding active clockevent devices.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Magnus Damm <magnus.damm@gmail.com>
    Link: http://lkml.kernel.org/r/20130425143436.431796247@linutronix.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kim Phillips <kim.phillips@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 409d4ffaf0c8b29693243918217cec0044979395
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Apr 25 20:31:49 2013 +0000

    clockevents: Add module refcount
    
    commit ccf33d6880f39a35158fff66db13000ae4943fac upstream.
    
    We want to be able to remove clockevent modules as well. Add a
    refcount so we don't remove a module with an active clock event
    device.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Magnus Damm <magnus.damm@gmail.com>
    Link: http://lkml.kernel.org/r/20130425143436.307435149@linutronix.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kim Phillips <kim.phillips@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit e8d630331dfe32c63438a4558eeda6f79c712485
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Apr 25 20:31:47 2013 +0000

    clockevents: Get rid of the notifier chain
    
    commit 7172a286ced0c1f4f239a0fa09db54ed37d3ead2 upstream.
    
    7+ years and still a single user. Kill it.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Magnus Damm <magnus.damm@gmail.com>
    Link: http://lkml.kernel.org/r/20130425143436.098520211@linutronix.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kim Phillips <kim.phillips@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 1ab231b274ba51a54acebec23c6aded0f3cdf54e
Merge: dea4f48a0a30 0e576acbc1d9
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Dec 4 08:52:09 2013 -0800

    Merge branch 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer fixes from Thomas Gleixner:
    
     - timekeeping: Cure a subtle drift issue on GENERIC_TIME_VSYSCALL_OLD
    
     - nohz: Make CONFIG_NO_HZ=n and nohz=off command line option behave the
       same way.  Fixes a long standing load accounting wreckage.
    
     - clocksource/ARM: Kconfig update to avoid ARM=n wreckage
    
     - clocksource/ARM: Fixlets for the AT91 and SH clocksource/clockevents
    
     - Trivial documentation update and kzalloc conversion from akpms pile
    
    * 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      nohz: Fix another inconsistency between CONFIG_NO_HZ=n and nohz=off
      time: Fix 1ns/tick drift w/ GENERIC_TIME_VSYSCALL_OLD
      clocksource: arm_arch_timer: Hide eventstream Kconfig on non-ARM
      clocksource: sh_tmu: Add clk_prepare/unprepare support
      clocksource: sh_tmu: Release clock when sh_tmu_register() fails
      clocksource: sh_mtu2: Add clk_prepare/unprepare support
      clocksource: sh_mtu2: Release clock when sh_mtu2_register() fails
      ARM: at91: rm9200: switch back to clockevents_config_and_register
      tick: Document tick_do_timer_cpu
      timer: Convert kmalloc_node(...GFP_ZERO...) to kzalloc_node(...)
      NOHZ: Check for nohz active instead of nohz enabled

commit 70fe8217e17ddd058f9f043ae1cc0d86b1658a5c
Merge: 4be77398ac9d 77f7ce9a9f63
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Nov 26 19:00:32 2013 +0100

    Merge branch 'clockevents/fixes' of git://git.linaro.org/people/dlezcano/linux into timers/urgent
    
     * Hide event stream Kconfig option for the arch_arm_timer for ARM=n
     * Fix a missing a clk_put in case the registering of the sh_mtu[2] drivers fails.
     * Reuse clockevents_config_and_register for the at91rm9200_time timer

commit 8adbf78ec4839c1dc4ff20c9a1f332a7bc99e6e6
Author: Martin Schwidefsky <schwidefsky@de.ibm.com>
Date:   Fri Nov 22 12:04:18 2013 +0100

    s390,time: revert direct ktime path for s390 clockevent device
    
    Git commit 4f37a68cdaf6dea833cfdded2a3e0c47c0f006da
    "s390: Use direct ktime path for s390 clockevent device" makes use
    of the CLOCK_EVT_FEAT_KTIME clockevent option to avoid the delta
    calculation with ktime_get() in clockevents_program_event and the
    get_tod_clock() in s390_next_event. This is based on the assumption
    that the difference between the internal ktime and the hardware
    clock is reflected in the wall_to_monotonic delta. But this is not
    true, the ntp corrections are applied via changes to the tk->mult
    multiplier and this is not reflected in wall_to_monotonic.
    
    In theory this could be solved by using the raw monotonic clock
    but it is simpler to switch back to the standard clock delta
    calculation.
    
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

commit 1c283531115bda77a9b559271311c1983fbcffaa
Author: Uwe Kleine-Knig <u.kleine-koenig@pengutronix.de>
Date:   Tue Oct 8 16:38:53 2013 +0200

    ARM: at91: rm9200: switch back to clockevents_config_and_register
    
    The timer code for at91rm9200 was already converted some time ago by
    Shawn Guo in commit 838a2ae (ARM: use clockevents_config_and_register()
    where possible) but because of a rounding issue in the timer core this
    resulted in an easily reproducible oops. So it was reverted (commit
    b7a8ca5 (ARM: at91: rm9200 fix time support)) which stopped the oops
    from happening because min_delta_ns is increased by one in arch code
    which stopped from problem from happening.
    
    Now that the timer core problem is fixed (commit a4578ea (clockevents:
    Sanitize ticks to nsec conversion)), we can switch back to the
    clockevents_config_and_register helper.
    
    Tested-by: Nicolas Ferre <nicolas.ferre@atmel.com>
    Signed-off-by: Uwe Kleine-Knig <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit 728ccd1f9a6e8ec19e001d8b4d1e2930c9034068
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Sep 24 21:50:23 2013 +0200

    clockevents: Sanitize ticks to nsec conversion
    
    commit 97b9410643475d6557d2517c2aff9fd2221141a9 upstream.
    
    Marc Kleine-Budde pointed out, that commit 77cc982 "clocksource: use
    clockevents_config_and_register() where possible" caused a regression
    for some of the converted subarchs.
    
    The reason is, that the clockevents core code converts the minimal
    hardware tick delta to a nanosecond value for core internal
    usage. This conversion is affected by integer math rounding loss, so
    the backwards conversion to hardware ticks will likely result in a
    value which is less than the configured hardware limitation. The
    affected subarchs used their own workaround (SIGH!) which got lost in
    the conversion.
    
    The solution for the issue at hand is simple: adding evt->mult - 1 to
    the shifted value before the integer divison in the core conversion
    function takes care of it. But this only works for the case where for
    the scaled math mult/shift pair "mult <= 1 << shift" is true. For the
    case where "mult > 1 << shift" we can apply the rounding add only for
    the minimum delta value to make sure that the backward conversion is
    not less than the given hardware limit. For the upper bound we need to
    omit the rounding add, because the backwards conversion is always
    larger than the original latch value. That would violate the upper
    bound of the hardware device.
    
    Though looking closer at the details of that function reveals another
    bogosity: The upper bounds check is broken as well. Checking for a
    resulting "clc" value greater than KTIME_MAX after the conversion is
    pointless. The conversion does:
    
          u64 clc = (latch << evt->shift) / evt->mult;
    
    So there is no sanity check for (latch << evt->shift) exceeding the
    64bit boundary. The latch argument is "unsigned long", so on a 64bit
    arch the handed in argument could easily lead to an unnoticed shift
    overflow. With the above rounding fix applied the calculation before
    the divison is:
    
           u64 clc = (latch << evt->shift) + evt->mult - 1;
    
    So we need to make sure, that neither the shift nor the rounding add
    is overflowing the u64 boundary.
    
    [ukl: move assignment to rnd after eventually changing mult, fix build
     issue and correct comment with the right math]
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Russell King - ARM Linux <linux@arm.linux.org.uk>
    Cc: Marc Kleine-Budde <mkl@pengutronix.de>
    Cc: nicolas.ferre@atmel.com
    Cc: Marc Pignat <marc.pignat@hevs.ch>
    Cc: john.stultz@linaro.org
    Cc: kernel@pengutronix.de
    Cc: Ronald Wahl <ronald.wahl@raritan.com>
    Cc: LAK <linux-arm-kernel@lists.infradead.org>
    Cc: Ludovic Desroches <ludovic.desroches@atmel.com>
    Link: http://lkml.kernel.org/r/1380052223-24139-1-git-send-email-u.kleine-koenig@pengutronix.de
    Signed-off-by: Uwe Kleine-Knig <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit b5b02b140665d016236918cb88b88f6249050605
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Sep 24 21:50:23 2013 +0200

    clockevents: Sanitize ticks to nsec conversion
    
    commit 97b9410643475d6557d2517c2aff9fd2221141a9 upstream.
    
    Marc Kleine-Budde pointed out, that commit 77cc982 "clocksource: use
    clockevents_config_and_register() where possible" caused a regression
    for some of the converted subarchs.
    
    The reason is, that the clockevents core code converts the minimal
    hardware tick delta to a nanosecond value for core internal
    usage. This conversion is affected by integer math rounding loss, so
    the backwards conversion to hardware ticks will likely result in a
    value which is less than the configured hardware limitation. The
    affected subarchs used their own workaround (SIGH!) which got lost in
    the conversion.
    
    The solution for the issue at hand is simple: adding evt->mult - 1 to
    the shifted value before the integer divison in the core conversion
    function takes care of it. But this only works for the case where for
    the scaled math mult/shift pair "mult <= 1 << shift" is true. For the
    case where "mult > 1 << shift" we can apply the rounding add only for
    the minimum delta value to make sure that the backward conversion is
    not less than the given hardware limit. For the upper bound we need to
    omit the rounding add, because the backwards conversion is always
    larger than the original latch value. That would violate the upper
    bound of the hardware device.
    
    Though looking closer at the details of that function reveals another
    bogosity: The upper bounds check is broken as well. Checking for a
    resulting "clc" value greater than KTIME_MAX after the conversion is
    pointless. The conversion does:
    
          u64 clc = (latch << evt->shift) / evt->mult;
    
    So there is no sanity check for (latch << evt->shift) exceeding the
    64bit boundary. The latch argument is "unsigned long", so on a 64bit
    arch the handed in argument could easily lead to an unnoticed shift
    overflow. With the above rounding fix applied the calculation before
    the divison is:
    
           u64 clc = (latch << evt->shift) + evt->mult - 1;
    
    So we need to make sure, that neither the shift nor the rounding add
    is overflowing the u64 boundary.
    
    [ukl: move assignment to rnd after eventually changing mult, fix build
     issue and correct comment with the right math]
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Russell King - ARM Linux <linux@arm.linux.org.uk>
    Cc: Marc Kleine-Budde <mkl@pengutronix.de>
    Cc: nicolas.ferre@atmel.com
    Cc: Marc Pignat <marc.pignat@hevs.ch>
    Cc: john.stultz@linaro.org
    Cc: kernel@pengutronix.de
    Cc: Ronald Wahl <ronald.wahl@raritan.com>
    Cc: LAK <linux-arm-kernel@lists.infradead.org>
    Cc: Ludovic Desroches <ludovic.desroches@atmel.com>
    Link: http://lkml.kernel.org/r/1380052223-24139-1-git-send-email-u.kleine-koenig@pengutronix.de
    Signed-off-by: Uwe Kleine-Knig <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit f81d0a99446a0c4548d5783807529d075b06c64e
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Sep 24 21:50:23 2013 +0200

    clockevents: Sanitize ticks to nsec conversion
    
    commit 97b9410643475d6557d2517c2aff9fd2221141a9 upstream.
    
    Marc Kleine-Budde pointed out, that commit 77cc982 "clocksource: use
    clockevents_config_and_register() where possible" caused a regression
    for some of the converted subarchs.
    
    The reason is, that the clockevents core code converts the minimal
    hardware tick delta to a nanosecond value for core internal
    usage. This conversion is affected by integer math rounding loss, so
    the backwards conversion to hardware ticks will likely result in a
    value which is less than the configured hardware limitation. The
    affected subarchs used their own workaround (SIGH!) which got lost in
    the conversion.
    
    The solution for the issue at hand is simple: adding evt->mult - 1 to
    the shifted value before the integer divison in the core conversion
    function takes care of it. But this only works for the case where for
    the scaled math mult/shift pair "mult <= 1 << shift" is true. For the
    case where "mult > 1 << shift" we can apply the rounding add only for
    the minimum delta value to make sure that the backward conversion is
    not less than the given hardware limit. For the upper bound we need to
    omit the rounding add, because the backwards conversion is always
    larger than the original latch value. That would violate the upper
    bound of the hardware device.
    
    Though looking closer at the details of that function reveals another
    bogosity: The upper bounds check is broken as well. Checking for a
    resulting "clc" value greater than KTIME_MAX after the conversion is
    pointless. The conversion does:
    
          u64 clc = (latch << evt->shift) / evt->mult;
    
    So there is no sanity check for (latch << evt->shift) exceeding the
    64bit boundary. The latch argument is "unsigned long", so on a 64bit
    arch the handed in argument could easily lead to an unnoticed shift
    overflow. With the above rounding fix applied the calculation before
    the divison is:
    
           u64 clc = (latch << evt->shift) + evt->mult - 1;
    
    So we need to make sure, that neither the shift nor the rounding add
    is overflowing the u64 boundary.
    
    [ukl: move assignment to rnd after eventually changing mult, fix build
     issue and correct comment with the right math]
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Russell King - ARM Linux <linux@arm.linux.org.uk>
    Cc: Marc Kleine-Budde <mkl@pengutronix.de>
    Cc: nicolas.ferre@atmel.com
    Cc: Marc Pignat <marc.pignat@hevs.ch>
    Cc: john.stultz@linaro.org
    Cc: kernel@pengutronix.de
    Cc: Ronald Wahl <ronald.wahl@raritan.com>
    Cc: LAK <linux-arm-kernel@lists.infradead.org>
    Cc: Ludovic Desroches <ludovic.desroches@atmel.com>
    Link: http://lkml.kernel.org/r/1380052223-24139-1-git-send-email-u.kleine-koenig@pengutronix.de
    Signed-off-by: Uwe Kleine-Knig <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit f3372c01816ec9e974e449cf7233408a31647dd3
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Oct 1 12:57:20 2013 +0200

    ARM: gemini: convert to GENERIC_CLOCKEVENTS
    
    This converts the gemini machine to use generic clockevents
    by rewriting the timer driver.
    
    Cc: arm@kernel.org
    Cc: Hans Ulli Kroll <ulli.kroll@googlemail.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Olof Johansson <olof@lixom.net>

commit aff22d3f1a8abef4d28817e0d762b3054e39cf7a
Merge: e2756f5e0fab 97b941064347
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Oct 27 10:29:25 2013 -0700

    Merge branch 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer fix from Ingo Molnar:
     "This tree contains a clockevents regression fix for certain ARM
      subarchitectures"
    
    * 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      clockevents: Sanitize ticks to nsec conversion

commit 97b9410643475d6557d2517c2aff9fd2221141a9
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Sep 24 21:50:23 2013 +0200

    clockevents: Sanitize ticks to nsec conversion
    
    Marc Kleine-Budde pointed out, that commit 77cc982 "clocksource: use
    clockevents_config_and_register() where possible" caused a regression
    for some of the converted subarchs.
    
    The reason is, that the clockevents core code converts the minimal
    hardware tick delta to a nanosecond value for core internal
    usage. This conversion is affected by integer math rounding loss, so
    the backwards conversion to hardware ticks will likely result in a
    value which is less than the configured hardware limitation. The
    affected subarchs used their own workaround (SIGH!) which got lost in
    the conversion.
    
    The solution for the issue at hand is simple: adding evt->mult - 1 to
    the shifted value before the integer divison in the core conversion
    function takes care of it. But this only works for the case where for
    the scaled math mult/shift pair "mult <= 1 << shift" is true. For the
    case where "mult > 1 << shift" we can apply the rounding add only for
    the minimum delta value to make sure that the backward conversion is
    not less than the given hardware limit. For the upper bound we need to
    omit the rounding add, because the backwards conversion is always
    larger than the original latch value. That would violate the upper
    bound of the hardware device.
    
    Though looking closer at the details of that function reveals another
    bogosity: The upper bounds check is broken as well. Checking for a
    resulting "clc" value greater than KTIME_MAX after the conversion is
    pointless. The conversion does:
    
          u64 clc = (latch << evt->shift) / evt->mult;
    
    So there is no sanity check for (latch << evt->shift) exceeding the
    64bit boundary. The latch argument is "unsigned long", so on a 64bit
    arch the handed in argument could easily lead to an unnoticed shift
    overflow. With the above rounding fix applied the calculation before
    the divison is:
    
           u64 clc = (latch << evt->shift) + evt->mult - 1;
    
    So we need to make sure, that neither the shift nor the rounding add
    is overflowing the u64 boundary.
    
    [ukl: move assignment to rnd after eventually changing mult, fix build
     issue and correct comment with the right math]
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Russell King - ARM Linux <linux@arm.linux.org.uk>
    Cc: Marc Kleine-Budde <mkl@pengutronix.de>
    Cc: nicolas.ferre@atmel.com
    Cc: Marc Pignat <marc.pignat@hevs.ch>
    Cc: john.stultz@linaro.org
    Cc: kernel@pengutronix.de
    Cc: Ronald Wahl <ronald.wahl@raritan.com>
    Cc: LAK <linux-arm-kernel@lists.infradead.org>
    Cc: Ludovic Desroches <ludovic.desroches@atmel.com>
    Cc: stable@vger.kernel.org
    Link: http://lkml.kernel.org/r/1380052223-24139-1-git-send-email-u.kleine-koenig@pengutronix.de
    Signed-off-by: Uwe Kleine-Knig <u.kleine-koenig@pengutronix.de>

commit 1723f2a18d304ca09a4e7aec28dc5b5797114c5d
Merge: 94f53f1f0845 bf94d09ddacd
Author: Kevin Hilman <khilman@linaro.org>
Date:   Thu Oct 17 14:36:34 2013 -0700

    Merge branch 'davinci/soc' into next/soc
    
    From Sekhar Nori:
    * davinci/soc:
      ARM: davinci: convert to clockevents_config_and_register
    
    Signed-off-by: Kevin Hilman <khilman@linaro.org>

commit bf94d09ddacd3e2e3ebb602fd1826982b0ce825f
Author: Uwe Kleine-Knig <u.kleine-koenig@pengutronix.de>
Date:   Sun Oct 13 10:36:30 2013 +0200

    ARM: davinci: convert to clockevents_config_and_register
    
    clockevents_config_and_register is superior compared to setting
    shift/mult and {min,max}_delta_ns by hand.
    
    Tested-by: Prabhakar Lad <prabhakar.csengg@gmail.com>
    Signed-off-by: Uwe Kleine-Knig <u.kleine-koenig@pengutronix.de>
    [nsekhar@ti.com: fix an alignment related checkpatch warning]
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

commit d9b834c61f22b8fc38a32cfde86017381f370336
Author: Gabor Juhos <juhosg@openwrt.org>
Date:   Wed Sep 25 15:32:35 2013 +0200

    avr32: fix clockevents kernel warning
    
    commit 1b0135b5e20c56b2edae29e92b91c0b12c983432 upstream.
    
    Since commit 01426478df3a8791ff5c8b6b82d409e699cfaf38
    (avr32: Use generic idle loop) the kernel throws the
    following warning on avr32:
    
      WARNING: at 900322e4 [verbose debug info unavailable]
      Modules linked in:
      CPU: 0 PID: 0 Comm: swapper Not tainted 3.12.0-rc2 #117
      task: 901c3ecc ti: 901c0000 task.ti: 901c0000
      PC is at cpu_idle_poll_ctrl+0x1c/0x38
      LR is at comparator_mode+0x3e/0x40
      pc : [<900322e4>]    lr : [<90014882>]    Not tainted
      sp : 901c1f74  r12: 00000000  r11: 901c74a0
      r10: 901d2510  r9 : 00000001  r8 : 901db4de
      r7 : 901c74a0  r6 : 00000001  r5 : 00410020  r4 : 901db574
      r3 : 00410024  r2 : 90206fe0  r1 : 00000000  r0 : 007f0000
      Flags: qvnzc
      Mode bits: hjmde....G
      CPU Mode: Supervisor
      Call trace:
       [<90039ede>] clockevents_set_mode+0x16/0x2e
       [<90039f00>] clockevents_shutdown+0xa/0x1e
       [<9003a078>] clockevents_exchange_device+0x58/0x70
       [<9003a78c>] tick_check_new_device+0x38/0x54
       [<9003a1a2>] clockevents_register_device+0x32/0x90
       [<900035c4>] time_init+0xa8/0x108
       [<90000520>] start_kernel+0x128/0x23c
    
    When the 'avr32_comparator' clockevent device is registered,
    the clockevent core sets the mode of that clockevent device
    to CLOCK_EVT_MODE_SHUTDOWN. Due to this, the 'comparator_mode'
    function calls the 'cpu_idle_poll_ctrl' to disables idle poll.
    This results in the aforementioned warning because the polling
    is not enabled yet.
    
    Change the code to only disable idle poll if it is enabled by
    the same function to avoid the warning.
    
    Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
    Acked-by: Hans-Christian Egtvedt <egtvedt@samfundet.no>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit fd728b3e6bd0153c78425052da773c95f3fcf332
Author: Gabor Juhos <juhosg@openwrt.org>
Date:   Wed Sep 25 15:32:35 2013 +0200

    avr32: fix clockevents kernel warning
    
    commit 1b0135b5e20c56b2edae29e92b91c0b12c983432 upstream.
    
    Since commit 01426478df3a8791ff5c8b6b82d409e699cfaf38
    (avr32: Use generic idle loop) the kernel throws the
    following warning on avr32:
    
      WARNING: at 900322e4 [verbose debug info unavailable]
      Modules linked in:
      CPU: 0 PID: 0 Comm: swapper Not tainted 3.12.0-rc2 #117
      task: 901c3ecc ti: 901c0000 task.ti: 901c0000
      PC is at cpu_idle_poll_ctrl+0x1c/0x38
      LR is at comparator_mode+0x3e/0x40
      pc : [<900322e4>]    lr : [<90014882>]    Not tainted
      sp : 901c1f74  r12: 00000000  r11: 901c74a0
      r10: 901d2510  r9 : 00000001  r8 : 901db4de
      r7 : 901c74a0  r6 : 00000001  r5 : 00410020  r4 : 901db574
      r3 : 00410024  r2 : 90206fe0  r1 : 00000000  r0 : 007f0000
      Flags: qvnzc
      Mode bits: hjmde....G
      CPU Mode: Supervisor
      Call trace:
       [<90039ede>] clockevents_set_mode+0x16/0x2e
       [<90039f00>] clockevents_shutdown+0xa/0x1e
       [<9003a078>] clockevents_exchange_device+0x58/0x70
       [<9003a78c>] tick_check_new_device+0x38/0x54
       [<9003a1a2>] clockevents_register_device+0x32/0x90
       [<900035c4>] time_init+0xa8/0x108
       [<90000520>] start_kernel+0x128/0x23c
    
    When the 'avr32_comparator' clockevent device is registered,
    the clockevent core sets the mode of that clockevent device
    to CLOCK_EVT_MODE_SHUTDOWN. Due to this, the 'comparator_mode'
    function calls the 'cpu_idle_poll_ctrl' to disables idle poll.
    This results in the aforementioned warning because the polling
    is not enabled yet.
    
    Change the code to only disable idle poll if it is enabled by
    the same function to avoid the warning.
    
    Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
    Acked-by: Hans-Christian Egtvedt <egtvedt@samfundet.no>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 4d594dd3028ba8cdfcbd854bde3811a1ee4e36d7
Author: Yuvaraj Kumar C D <yuvaraj.cd@gmail.com>
Date:   Wed Sep 18 15:41:53 2013 +0530

    ARM: exynos: dts: Update 5250 arch timer node with clock frequency
    
    Without the "clock-frequency" property in arch timer node, could able
    to see the below crash dump.
    
    [<c0014e28>] (unwind_backtrace+0x0/0xf4) from [<c0011808>] (show_stack+0x10/0x14)
    [<c0011808>] (show_stack+0x10/0x14) from [<c036ac1c>] (dump_stack+0x7c/0xb0)
    [<c036ac1c>] (dump_stack+0x7c/0xb0) from [<c01ab760>] (Ldiv0_64+0x8/0x18)
    [<c01ab760>] (Ldiv0_64+0x8/0x18) from [<c0062f60>] (clockevents_config.part.2+0x1c/0x74)
    [<c0062f60>] (clockevents_config.part.2+0x1c/0x74) from [<c0062fd8>] (clockevents_config_and_register+0x20/0x2c)
    [<c0062fd8>] (clockevents_config_and_register+0x20/0x2c) from [<c02b8e8c>] (arch_timer_setup+0xa8/0x134)
    [<c02b8e8c>] (arch_timer_setup+0xa8/0x134) from [<c04b47b4>] (arch_timer_init+0x1f4/0x24c)
    [<c04b47b4>] (arch_timer_init+0x1f4/0x24c) from [<c04b40d8>] (clocksource_of_init+0x34/0x58)
    [<c04b40d8>] (clocksource_of_init+0x34/0x58) from [<c049ed8c>] (time_init+0x20/0x2c)
    [<c049ed8c>] (time_init+0x20/0x2c) from [<c049b95c>] (start_kernel+0x1e0/0x39c)
    
    THis is because the Exynos u-boot, for example on the Chromebooks, doesn't set
    up the CNTFRQ register as expected by arch_timer. Instead, we have to specify
    the frequency in the device tree like this.
    
    Signed-off-by: Yuvaraj Kumar C D <yuvaraj.cd@samsung.com>
    [olof: Changed subject, added comment, elaborated on commit message]
    Signed-off-by: Olof Johansson <olof@lixom.net>

commit a44eb870f815356dac56adf3a380ee9b94787424
Merge: 68e90740284c f51380a75652
Author: Ingo Molnar <mingo@kernel.org>
Date:   Wed Oct 9 08:27:18 2013 +0200

    Merge branch 'clockevents/3.13' of git://git.linaro.org/people/dlezcano/linux into timers/core
    
    Pull ARM clocksource/clockevents updates from Daniel Lezcano:
    
      * Will Deacon and Sudeep KarkadaNagesha implemented the event stream
        for architected timer. The event streams can be used to impose a
        timeout on a wfe, to safeguard against any programming error in case
        an expected event is not generated or even to implement wfe-based
        timeouts for userspace locking implementations. Some files fall
        under the arm maintainers' umbrella but those changes have been
        reviewed and acked by the relevant people (Catalin Marinas and Olof
        Johansson).
    
      * Boris Brezillon improved the tcb_clksrc driver by removing a
        deprecated flag, checking return code values and using functions
        from the common clock framework.
    
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 191124efb4d6e5e47fe073b4b97350873523e88c
Merge: 68e90740284c 346e7480f1d4
Author: Daniel Lezcano <daniel.lezcano@linaro.org>
Date:   Thu Oct 3 16:13:51 2013 +0200

    Merge branch 'timer_evtstrm' of git://linux-arm.org/linux-skn into clockevents/3.13
    
    Adds support to configure the rate and enable the event stream for architected
    timer. The event streams can be used to impose a timeout on a wfe, to safeguard
    against any programming error in case an expected event is not generated or
    even to implement wfe-based timeouts for userspace locking implementations.
    This feature can be disabled(enabled by default).
    
    Since the timer control register is reset to zero on warm boot, CPU PM notifier
    is added to save and restore the value.
    
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit 68e90740284c69292881cd38c7ece6f09a18a58f
Merge: 19f29887a73e 4fbcdc813fb9
Author: Ingo Molnar <mingo@kernel.org>
Date:   Thu Oct 3 07:55:07 2013 +0200

    Merge branch 'clockevents/3.13' of git://git.linaro.org/people/dlezcano/linux into timers/core
    
    Pull (mostly) ARM clocksource driver updates from Daniel Lezcano:
    
    " - Soren Brinkmann added FEAT_PERCPU to a clock device when it is local
        per cpu. This feature prevents the clock framework to choose a per cpu
        timer as a broadcast timer. This problem arised when the ARM global
        timer is used when switching to the broadcast timer which is the case
        now on Xillinx with its cpuidle driver.
    
      - Stephen Boyd extended the generic sched_clock code to support 64bit
        counters and removes the setup_sched_clock deprecation, as that causes
        lots of warnings since there's still users in the arch/arm tree. He
        added also the CLOCK_SOURCE_SUSPEND_NONSTOP flag on the architected
        timer as they continue counting during suspend.
    
      - Uwe Kleine-Knig added some missing __init sections and consolidated the
        code by moving the of_node_put call from the drivers to the function
        clocksource_of_init. "
    
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 245a34962661cd2ce7b4dd6c4aa65d870a589c50
Author: Soren Brinkmann <soren.brinkmann@xilinx.com>
Date:   Wed Sep 18 11:48:37 2013 -0700

    tick: broadcast: Deny per-cpu clockevents from being broadcast sources
    
    On most ARM systems the per-cpu clockevents are truly per-cpu in
    the sense that they can't be controlled on any other CPU besides
    the CPU that they interrupt. If one of these clockevents were to
    become a broadcast source we will run into a lot of trouble
    because the broadcast source is enabled on the first CPU to go
    into deep idle (if that CPU suffers from FEAT_C3_STOP) and that
    could be a different CPU than what the clockevent is interrupting
    (or even worse the CPU that the clockevent interrupts could be
    offline).
    
    Theoretically it's possible to support per-cpu clockevents as the
    broadcast source but so far we haven't needed this and supporting
    it is rather complicated. Let's just deny the possibility for now
    until this becomes a reality (let's hope it never does!).
    
    Signed-off-by: Soren Brinkmann <soren.brinkmann@xilinx.com>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Acked-by: Michal Simek <michal.simek@xilinx.com>

commit 5c282e858f87651e97b31b99e7446aeb449f987e
Merge: 8945546d90a7 395e73a278cf
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Sep 30 10:40:20 2013 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/egtvedt/linux-avr32
    
    Pull AVR32 fixes from Hans-Christian Egtvedt.
    
    Fix build warnings and use the Kbuild infrastructure for generic headers
    rather than doing it by hand.
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/egtvedt/linux-avr32:
      avr32: cast syscall_return to silence compiler warning
      avr32: fix clockevents kernel warning
      avr32: use Kbuild infrastructure to handle the asm-generic headers

commit 815a4bb18ba834a58a60da14536ace4dcaa8b465
Merge: 15c03dd4859a 55c2e2620427
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Sep 30 10:37:05 2013 -0700

    Merge tag 'arc-fixes-for-3.12' of git://git.kernel.org/pub/scm/linux/kernel/git/vgupta/arc
    
    Pull ARC Fixes from Vineet Gupta:
     - Handle unaligned access in zero delay loops
     - spinlock livelock fix for SMP systemC model
     - fix 32bit overflow in access_ok
     - better setup of clockevents
    
    * tag 'arc-fixes-for-3.12' of git://git.kernel.org/pub/scm/linux/kernel/git/vgupta/arc:
      ARC: Use clockevents_config_and_register over clockevents_register_device
      ARC: Workaround spinlock livelock in SMP SystemC simulation
      ARC: Fix 32-bit wrap around in access_ok()
      ARC: Handle zero-overhead-loop in unaligned access handler

commit 1b0135b5e20c56b2edae29e92b91c0b12c983432
Author: Gabor Juhos <juhosg@openwrt.org>
Date:   Wed Sep 25 15:32:35 2013 +0200

    avr32: fix clockevents kernel warning
    
    Since commit 01426478df3a8791ff5c8b6b82d409e699cfaf38
    (avr32: Use generic idle loop) the kernel throws the
    following warning on avr32:
    
      WARNING: at 900322e4 [verbose debug info unavailable]
      Modules linked in:
      CPU: 0 PID: 0 Comm: swapper Not tainted 3.12.0-rc2 #117
      task: 901c3ecc ti: 901c0000 task.ti: 901c0000
      PC is at cpu_idle_poll_ctrl+0x1c/0x38
      LR is at comparator_mode+0x3e/0x40
      pc : [<900322e4>]    lr : [<90014882>]    Not tainted
      sp : 901c1f74  r12: 00000000  r11: 901c74a0
      r10: 901d2510  r9 : 00000001  r8 : 901db4de
      r7 : 901c74a0  r6 : 00000001  r5 : 00410020  r4 : 901db574
      r3 : 00410024  r2 : 90206fe0  r1 : 00000000  r0 : 007f0000
      Flags: qvnzc
      Mode bits: hjmde....G
      CPU Mode: Supervisor
      Call trace:
       [<90039ede>] clockevents_set_mode+0x16/0x2e
       [<90039f00>] clockevents_shutdown+0xa/0x1e
       [<9003a078>] clockevents_exchange_device+0x58/0x70
       [<9003a78c>] tick_check_new_device+0x38/0x54
       [<9003a1a2>] clockevents_register_device+0x32/0x90
       [<900035c4>] time_init+0xa8/0x108
       [<90000520>] start_kernel+0x128/0x23c
    
    When the 'avr32_comparator' clockevent device is registered,
    the clockevent core sets the mode of that clockevent device
    to CLOCK_EVT_MODE_SHUTDOWN. Due to this, the 'comparator_mode'
    function calls the 'cpu_idle_poll_ctrl' to disables idle poll.
    This results in the aforementioned warning because the polling
    is not enabled yet.
    
    Change the code to only disable idle poll if it is enabled by
    the same function to avoid the warning.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
    Acked-by: Hans-Christian Egtvedt <egtvedt@samfundet.no>

commit 55c2e26204276b27f2b7a63123b701c950e45d89
Author: Uwe Kleine-Knig <u.kleine-koenig@pengutronix.de>
Date:   Tue Sep 24 23:05:37 2013 +0200

    ARC: Use clockevents_config_and_register over clockevents_register_device
    
    clockevents_config_and_register is more clever and correct than doing it
    by hand; so use it.
    
    [vgupta: fixed build failure due to missing ; in patch]
    
    Signed-off-by: Uwe Kleine-Knig <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>

commit cfb6d656d569510ac9239583ce09e4c92ad54719
Merge: fac778a2b8d6 220069945b29
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Aug 21 14:59:23 2013 +0200

    Merge branch 'timers/clockevents-next' of git://git.linaro.org/people/dlezcano/clockevents into timers/core
    
    * Support for memory mapped arch_timers
    * Trivial fixes to the moxart timer code
    * Documentation updates
    
    Trivial conflicts in drivers/clocksource/arm_arch_timer.c. Fixed up
    the newly added __cpuinit annotations as well.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 07862c1cd6675cde2dd4bd64e64d704ea2185b79
Author: Jonas Jensen <jonas.jensen@gmail.com>
Date:   Wed Jul 17 10:04:57 2013 +0200

    ARM: clocksource: Add support for MOXA ART SoCs
    
    This patch adds an clocksource driver for the main timer(s)
    found on MOXA ART SoCs.
    
    The MOXA ART SoC provides three separate timers with individual
    count/load/match registers, two are used here:
    
    TIMER1: clockevents, used to support oneshot and periodic events
    TIMER2: set up as a free running counter, used as clocksource
    
    Timers are preconfigured by bootloader to count down and interrupt
    on match or zero. Count increments every APB clock cycle and is
    automatically reloaded when it reaches zero.
    
    Signed-off-by: Jonas Jensen <jonas.jensen@gmail.com>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit b0ec636c93ddd77235bf0f023a8a95d78cb6cafe
Merge: a272dcca1802 c1b40e447af8
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Jul 12 17:10:30 2013 +0200

    Merge branch 'timers/clockevents' of git://git.linaro.org/people/dlezcano/clockevents into timers/urgent
    
    * New clocksource drivers for ARM SoCs to share

commit 21884a83b2192a00885d7244a1dda32debd2fbc7
Merge: 8b70a90cabaf 73b0cd674ccc
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jul 6 14:09:38 2013 -0700

    Merge branch 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer core updates from Thomas Gleixner:
     "The timer changes contain:
    
       - posix timer code consolidation and fixes for odd corner cases
    
       - sched_clock implementation moved from ARM to core code to avoid
         duplication by other architectures
    
       - alarm timer updates
    
       - clocksource and clockevents unregistration facilities
    
       - clocksource/events support for new hardware
    
       - precise nanoseconds RTC readout (Xen feature)
    
       - generic support for Xen suspend/resume oddities
    
       - the usual lot of fixes and cleanups all over the place
    
      The parts which touch other areas (ARM/XEN) have been coordinated with
      the relevant maintainers.  Though this results in an handful of
      trivial to solve merge conflicts, which we preferred over nasty cross
      tree merge dependencies.
    
      The patches which have been committed in the last few days are bug
      fixes plus the posix timer lot.  The latter was in akpms queue and
      next for quite some time; they just got forgotten and Frederic
      collected them last minute."
    
    * 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (59 commits)
      hrtimer: Remove unused variable
      hrtimers: Move SMP function call to thread context
      clocksource: Reselect clocksource when watchdog validated high-res capability
      posix-cpu-timers: don't account cpu timer after stopped thread runtime accounting
      posix_timers: fix racy timer delta caching on task exit
      posix-timers: correctly get dying task time sample in posix_cpu_timer_schedule()
      selftests: add basic posix timers selftests
      posix_cpu_timers: consolidate expired timers check
      posix_cpu_timers: consolidate timer list cleanups
      posix_cpu_timer: consolidate expiry time type
      tick: Sanitize broadcast control logic
      tick: Prevent uncontrolled switch to oneshot mode
      tick: Make oneshot broadcast robust vs. CPU offlining
      x86: xen: Sync the CMOS RTC as well as the Xen wallclock
      x86: xen: Sync the wallclock when the system time is set
      timekeeping: Indicate that clock was set in the pvclock gtod notifier
      timekeeping: Pass flags instead of multiple bools to timekeeping_update()
      xen: Remove clock_was_set() call in the resume path
      hrtimers: Support resuming with two or more CPUs online (but stopped)
      timer: Fix jiffies wrap behavior of round_jiffies_common()
      ...

commit 064706514ec3fea740c2656e03c4f01f6a551ac4
Author: Mark Rutland <mark.rutland@arm.com>
Date:   Mon Jun 3 13:33:53 2013 -0700

    clocksource: Add generic dummy timer driver
    
    Several architectures have a dummy timer driver tightly coupled with
    their broadcast code to support machines without cpu-local timers (or
    where there is a lack of driver support).
    
    Since 12ad100046: "clockevents: Add generic timer broadcast function"
    it's been possible to write broadcast-capable timer drivers decoupled
    from the broadcast mechanism. We can use this functionality to implement
    a generic dummy timer driver that can be shared by all architectures
    with generic tick broadcast (ARCH_HAS_TICK_BROADCAST).
    
    This patch implements a generic dummy timer using this facility.
    
    [sboyd: Make percpu data static, use __this_cpu_ptr(), move to
            early_initcall to properly register on each CPU, only
            register if more than one CPU possible]
    
    Signed-off-by: Mark Rutland <mark.rutland@arm.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>,
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: linux-arm-kernel@lists.infradead.org
    Link: http://lkml.kernel.org/r/1370291642-13259-3-git-send-email-sboyd@codeaurora.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 70e5975d3a04be5479a28eec4a2fb10f98ad2785
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Thu Jun 13 11:39:50 2013 -0700

    clockevents: Prefer CPU local devices over global devices
    
    On an SMP system with only one global clockevent and a dummy
    clockevent per CPU we run into problems. We want the dummy
    clockevents to be registered as the per CPU tick devices, but
    we can only achieve that if we register the dummy clockevents
    before the global clockevent or if we artificially inflate the
    rating of the dummy clockevents to be higher than the rating
    of the global clockevent. Failure to do so leads to boot
    hangs when the dummy timers are registered on all other CPUs
    besides the CPU that accepted the global clockevent as its tick
    device and there is no broadcast timer to poke the dummy
    devices.
    
    If we're registering multiple clockevents and one clockevent is
    global and the other is local to a particular CPU we should
    choose to use the local clockevent regardless of the rating of
    the device. This way, if the clockevent is a dummy it will take
    the tick device duty as long as there isn't a higher rated tick
    device and any global clockevent will be bumped out into
    broadcast mode, fixing the problem described above.
    
    Reported-and-tested-by: Mark Rutland <mark.rutland@arm.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Tested-by: soren.brinkmann@xilinx.com
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: John Stultz <john.stultz@linaro.org>
    Link: http://lkml.kernel.org/r/20130613183950.GA32061@codeaurora.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit ea8deb8dfa6b0e8d1b3d1051585706739b46656c
Author: Daniel Lezcano <daniel.lezcano@linaro.org>
Date:   Mon Jun 17 18:15:35 2013 +0200

    tick: Fix tick_broadcast_pending_mask not cleared
    
    The recent modification in the cpuidle framework consolidated the
    timer broadcast code across the different drivers by setting a new
    flag in the idle state. It tells the cpuidle core code to enter/exit
    the broadcast mode for the cpu when entering a deep idle state. The
    broadcast timer enter/exit is no longer handled by the back-end
    driver.
    
    This change made the local interrupt to be enabled *before* calling
    CLOCK_EVENT_NOTIFY_EXIT.
    
    On a tegra114, a four cores system, when the flag has been introduced
    in the driver, the following warning appeared:
    
    WARNING: at kernel/time/tick-broadcast.c:578 tick_broadcast_oneshot_control
    CPU: 2 PID: 0 Comm: swapper/2 Not tainted 3.10.0-rc3-next-20130529+ #15
    [<c00667f8>] (tick_broadcast_oneshot_control+0x1a4/0x1d0) from [<c0065cd0>] (tick_notify+0x240/0x40c)
    [<c0065cd0>] (tick_notify+0x240/0x40c) from [<c0044724>] (notifier_call_chain+0x44/0x84)
    [<c0044724>] (notifier_call_chain+0x44/0x84) from [<c0044828>] (raw_notifier_call_chain+0x18/0x20)
    [<c0044828>] (raw_notifier_call_chain+0x18/0x20) from [<c00650cc>] (clockevents_notify+0x28/0x170)
    [<c00650cc>] (clockevents_notify+0x28/0x170) from [<c033f1f0>] (cpuidle_idle_call+0x11c/0x168)
    [<c033f1f0>] (cpuidle_idle_call+0x11c/0x168) from [<c000ea94>] (arch_cpu_idle+0x8/0x38)
    [<c000ea94>] (arch_cpu_idle+0x8/0x38) from [<c005ea80>] (cpu_startup_entry+0x60/0x134)
    [<c005ea80>] (cpu_startup_entry+0x60/0x134) from [<804fe9a4>] (0x804fe9a4)
    
    I don't have the hardware, so I wasn't able to reproduce the warning
    but after looking a while at the code, I deduced the following:
    
     1. the CPU2 enters a deep idle state and sets the broadcast timer
    
     2. the timer expires, the tick_handle_oneshot_broadcast function is
        called, setting the tick_broadcast_pending_mask and waking up the
        idle cpu CPU2
    
     3. the CPU2 exits idle handles the interrupt and then invokes
        tick_broadcast_oneshot_control with CLOCK_EVENT_NOTIFY_EXIT which
        runs the following code:
    
        [...]
        if (dev->next_event.tv64 == KTIME_MAX)
                goto out;
    
        if (cpumask_test_and_clear_cpu(cpu,
                                     tick_broadcast_pending_mask))
                goto out;
        [...]
    
        So if there is no next event scheduled for CPU2, we fulfil the
        first condition and jump out without clearing the
        tick_broadcast_pending_mask.
    
     4. CPU2 goes to deep idle again and calls
        tick_broadcast_oneshot_control with CLOCK_NOTIFY_EVENT_ENTER but
        with the tick_broadcast_pending_mask set for CPU2, triggering the
        warning.
    
    The issue only surfaced due to the modifications of the cpuidle
    framework, which resulted in interrupts being enabled before the call
    to the clockevents code. If the call happens before interrupts have
    been enabled, the warning cannot trigger, because there is still the
    event pending which caused the broadcast timer expiry.
    
    Move the check for the next event below the check for the pending bit,
    so the pending bit gets cleared whether an event is scheduled on the
    cpu or not.
    
    [ tglx: Massaged changelog ]
    
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Reported-and-tested-by: Joseph Lo <josephl@nvidia.com>
    Cc: Stephen Warren <swarren@nvidia.com>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: linaro-kernel@lists.linaro.org
    Link: http://lkml.kernel.org/r/1371485735-31249-1-git-send-email-daniel.lezcano@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 30145daa32a9f20f6de2cdcff698365f72d2d4b6
Author: Mark Rutland <mark.rutland@arm.com>
Date:   Thu Mar 7 15:09:24 2013 +0000

    clockevents: Don't allow dummy broadcast timers
    
    commit a7dc19b8652c862d5b7c4d2339bd3c428bd29c4a upstream.
    
    Currently tick_check_broadcast_device doesn't reject clock_event_devices
    with CLOCK_EVT_FEAT_DUMMY, and may select them in preference to real
    hardware if they have a higher rating value. In this situation, the
    dummy timer is responsible for broadcasting to itself, and the core
    clockevents code may attempt to call non-existent callbacks for
    programming the dummy, eventually leading to a panic.
    
    This patch makes tick_check_broadcast_device always reject dummy timers,
    preventing this problem.
    
    Signed-off-by: Mark Rutland <mark.rutland@arm.com>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: Jon Medhurst (Tixy) <tixy@linaro.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Willy Tarreau <w@1wt.eu>

commit 762cf9695d714d312ef7369bed1b9f9467c9e64e
Merge: ce0b09898154 77ba83bb1bb1
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jun 8 22:58:27 2013 +0200

    Merge branch 'timers/clockevents' of git://git.linaro.org/people/dlezcano/clockevents into timers/core

commit 2261ddd846aee14180a14b98ca4586dccd28f758
Author: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
Date:   Wed May 15 12:12:33 2013 +0200

    ARM: at91: rm9200 fix time support
    
    commit b7a8ca5173ef9aa55fa039d7c216426ff0b25a12 upstream.
    
    since commit 838a2ae80a6ab52139fb1bf0a93ea8c5eff94488
    Author: Shawn Guo <shawn.guo@linaro.org>
    Date:   Sat Jan 12 11:50:05 2013 +0000
    
    ARM: use clockevents_config_and_register() where possible
    
    The timer is wrongly configured and result in a nice crash
    so revert it on rm9200 timer.
    
    Signed-off-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
    Cc: Shawn Guo <shawn.guo@linaro.org>
    Signed-off-by: Nicolas Ferre <nicolas.ferre@atmel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 77ba83bb1bb1cdabd522d32536f8eee65a870145
Author: Daniel Tang <dt.tangr@gmail.com>
Date:   Sat Jun 1 16:02:37 2013 +1000

    clocksource: Add TI-Nspire timer support
    
    This patch adds a clocksource/clockevent driver for the timer found on some
    models in the TI-Nspire calculator series. The timer has two 16bit subtimers
    within its memory mapped I/O interface but only the first can generate
    interrupts. The first subtimer is used to generate clockevents but only if an
    interrupt number and register is given.
    
    The interrupt acknowledgement mechanism is a little strange because the
    interrupt mask and acknowledge registers are located in another memory mapped
    I/O peripheral. The address of this register is passed to the driver through
    device tree bindings.
    
    The second subtimer is used as a clocksource because it isn't capable of
    generating an interrupt. This subtimer is always added.
    
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Daniel Tang <dt.tangr@gmail.com>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

commit f5d00c1f9adb350c24c5301600f7bf2da99b66de
Author: Jiri Bohac <jbohac@suse.cz>
Date:   Tue May 28 15:29:03 2013 +0200

    tick: Remove useless timekeeping duty attribution to broadcast source
    
    Since 7300711e ("clockevents: broadcast fixup possible waiters"),
    the timekeeping duty is assigned to the CPU that handles the tick
    broadcast clock device by the time it is set in one shot mode.
    
    This is an issue in full dynticks mode where the timekeeping duty
    must stay handled by the boot CPU for now. Otherwise it prevents
    secondary CPUs from offlining and this breaks
    suspend/shutdown/reboot/...
    
    As it appears there is no reason for this timekeeping duty to be
    moved to the broadcast CPU, besides nothing prevent it from being
    later re-assigned to another target, let's simply remove it.
    
    Signed-off-by: Jiri Bohac <jbohac@suse.cz>
    Reported-by: Steven Rostedt <rostedt@goodmis.org>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 2938d2757fc99c26aa678ce4eba910c4a77c3a55
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue May 28 09:33:01 2013 +0200

    tick: Cure broadcast false positive pending bit warning
    
    commit 26517f3e (tick: Avoid programming the local cpu timer if
    broadcast pending) added a warning if the cpu enters broadcast mode
    again while the pending bit is still set. Meelis reported that the
    warning triggers. There are two corner cases which have been not
    considered:
    
    1) cpuidle calls clockevents_notify(CLOCK_EVT_NOTIFY_BROADCAST_ENTER)
       twice. That can result in the following scenario
    
       CPU0                    CPU1
                               cpuidle_idle_call()
                                 clockevents_notify(CLOCK_EVT_NOTIFY_BROADCAST_ENTER)
                                   set cpu in tick_broadcast_oneshot_mask
    
       broadcast interrupt
         event expired for cpu1
         set pending bit
    
                                 acpi_idle_enter_simple()
                                   clockevents_notify(CLOCK_EVT_NOTIFY_BROADCAST_ENTER)
                                     WARN_ON(pending bit)
    
      Move the WARN_ON into the section where we enter broadcast mode so
      it wont provide false positives on the second call.
    
    2) safe_halt() enables interrupts, so a broadcast interrupt can be
       delivered befor the broadcast mode is disabled. That sets the
       pending bit for the CPU which receives the broadcast
       interrupt. Though the interrupt is delivered right away from the
       broadcast handler and leaves the pending bit stale.
    
       Clear the pending bit for the current cpu in the broadcast handler.
    
    Reported-and-tested-by: Meelis Roos <mroos@linux.ee>
    Cc: Len Brown <lenb@kernel.org>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Link: http://lkml.kernel.org/r/alpine.LFD.2.02.1305271841130.4220@ionos
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit c7e99fc75de8882bc4104455ace366d9d3599a96
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue May 28 09:28:02 2013 +0200

    clockevents: Define CS_NAME_LEN unconditionally
    
    Unbreak architectures which do not use clockevents, but require to
    build some of the core timekeeping infrastructure
    
    Reported-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 03e13cf5ee60584fe0c831682c67212effb7fca4
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Apr 25 20:31:50 2013 +0000

    clockevents: Implement unbind functionality
    
    Provide a sysfs interface to allow unbinding of clockevent
    devices. The device is unbound if it is unused or if there is a
    replacement device available. Unbinding of broadcast devices is not
    supported as we don't want to foster that nonsense. If no replacement
    device is available the unbind returns -EBUSY. Unbind is available
    from the kernel and through sysfs, which is necessary to drop the
    module refcount.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Magnus Damm <magnus.damm@gmail.com>
    Link: http://lkml.kernel.org/r/20130425143436.499216659@linutronix.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 45cb8e01b2ecef1c2afb18333e95793fa1a90281
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Apr 25 20:31:50 2013 +0000

    clockevents: Split out selection logic
    
    Split out the clockevent device selection logic. Preparatory patch to
    allow unbinding active clockevent devices.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Magnus Damm <magnus.damm@gmail.com>
    Link: http://lkml.kernel.org/r/20130425143436.431796247@linutronix.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 501f867064e95f9a6f540e60705be0937280e7ec
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Apr 25 20:31:49 2013 +0000

    clockevents: Provide sysfs interface
    
    Provide a simple sysfs interface for the clockevent devices. Show the
    current active clockevent device.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Magnus Damm <magnus.damm@gmail.com>
    Link: http://lkml.kernel.org/r/20130425143436.371634778@linutronix.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit ccf33d6880f39a35158fff66db13000ae4943fac
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Apr 25 20:31:49 2013 +0000

    clockevents: Add module refcount
    
    We want to be able to remove clockevent modules as well. Add a
    refcount so we don't remove a module with an active clock event
    device.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Magnus Damm <magnus.damm@gmail.com>
    Link: http://lkml.kernel.org/r/20130425143436.307435149@linutronix.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 8c53daf63f56791ed47fc585206ef3049489612f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Apr 25 20:31:48 2013 +0000

    clockevents: Move the tick_notify() switch case to clockevents_notify()
    
    No need to call another function and have duplicated cases.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Magnus Damm <magnus.damm@gmail.com>
    Link: http://lkml.kernel.org/r/20130425143436.235746557@linutronix.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 7126cac426137633e470167524e7bcb590fd49b3
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Apr 25 20:31:48 2013 +0000

    clockevents: Simplify locking
    
    Now that the notifier chain is gone there are no other users and it's
    pointless to nest tick_device_lock inside of clockevents_lock because
    there is no other use case.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Magnus Damm <magnus.damm@gmail.com>
    Link: http://lkml.kernel.org/r/20130425143436.162888472@linutronix.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 7172a286ced0c1f4f239a0fa09db54ed37d3ead2
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Apr 25 20:31:47 2013 +0000

    clockevents: Get rid of the notifier chain
    
    7+ years and still a single user. Kill it.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Magnus Damm <magnus.damm@gmail.com>
    Link: http://lkml.kernel.org/r/20130425143436.098520211@linutronix.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit b7a8ca5173ef9aa55fa039d7c216426ff0b25a12
Author: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
Date:   Wed May 15 12:12:33 2013 +0200

    ARM: at91: rm9200 fix time support
    
    since commit 838a2ae80a6ab52139fb1bf0a93ea8c5eff94488
    Author: Shawn Guo <shawn.guo@linaro.org>
    Date:   Sat Jan 12 11:50:05 2013 +0000
    
    ARM: use clockevents_config_and_register() where possible
    
    The timer is wrongly configured and result in a nice crash
    so revert it on rm9200 timer.
    
    Signed-off-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
    Cc: stable <stable@vger.kernel.org> # 3.8+
    Cc: Shawn Guo <shawn.guo@linaro.org>
    Signed-off-by: Nicolas Ferre <nicolas.ferre@atmel.com>

commit 7210dd24ee9e4dbb8f16cfe11d1d4319909bfe34
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Apr 25 11:45:53 2013 +0200

    clockevents: Set dummy handler on CPU_DEAD shutdown
    
    commit 6f7a05d7018de222e40ca003721037a530979974 upstream.
    
    Vitaliy reported that a per cpu HPET timer interrupt crashes the
    system during hibernation. What happens is that the per cpu HPET timer
    gets shut down when the nonboot cpus are stopped. When the nonboot
    cpus are onlined again the HPET code sets up the MSI interrupt which
    fires before the clock event device is registered. The event handler
    is still set to hrtimer_interrupt, which then crashes the machine due
    to highres mode not being active.
    
    See http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=700333
    
    There is no real good way to avoid that in the HPET code. The HPET
    code alrady has a mechanism to detect spurious interrupts when event
    handler == NULL for a similar reason.
    
    We can handle that in the clockevent/tick layer and replace the
    previous functional handler with a dummy handler like we do in
    tick_setup_new_device().
    
    The original clockevents code did this in clockevents_exchange_device(),
    but that got removed by commit 7c1e76897 (clockevents: prevent
    clockevent event_handler ending up handler_noop) which forgot to fix
    it up in tick_shutdown(). Same issue with the broadcast device.
    
    Reported-by: Vitaliy Fillipov <vitalif@yourcmc.ru>
    Cc: Ben Hutchings <ben@decadent.org.uk>
    Cc: 700333@bugs.debian.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit 0bd5ff02f874986f30455d41222d53bd1846aa0e
Author: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
Date:   Tue Apr 16 15:18:00 2013 -0400

    xen/time: Fix kasprintf splat when allocating timer%d IRQ line.
    
    commit 7918c92ae9638eb8a6ec18e2b4a0de84557cccc8 upstream.
    
    When we online the CPU, we get this splat:
    
    smpboot: Booting Node 0 Processor 1 APIC 0x2
    installing Xen timer for CPU 1
    BUG: sleeping function called from invalid context at /home/konrad/ssd/konrad/linux/mm/slab.c:3179
    in_atomic(): 1, irqs_disabled(): 0, pid: 0, name: swapper/1
    Pid: 0, comm: swapper/1 Not tainted 3.9.0-rc6upstream-00001-g3884fad #1
    Call Trace:
     [<ffffffff810c1fea>] __might_sleep+0xda/0x100
     [<ffffffff81194617>] __kmalloc_track_caller+0x1e7/0x2c0
     [<ffffffff81303758>] ? kasprintf+0x38/0x40
     [<ffffffff813036eb>] kvasprintf+0x5b/0x90
     [<ffffffff81303758>] kasprintf+0x38/0x40
     [<ffffffff81044510>] xen_setup_timer+0x30/0xb0
     [<ffffffff810445af>] xen_hvm_setup_cpu_clockevents+0x1f/0x30
     [<ffffffff81666d0a>] start_secondary+0x19c/0x1a8
    
    The solution to that is use kasprintf in the CPU hotplug path
    that 'online's the CPU. That is, do it in in xen_hvm_cpu_notify,
    and remove the call to in xen_hvm_setup_cpu_clockevents.
    
    Unfortunatly the later is not a good idea as the bootup path
    does not use xen_hvm_cpu_notify so we would end up never allocating
    timer%d interrupt lines when booting. As such add the check for
    atomic() to continue.
    
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit 20c4ec0f41d9be235c376c4cd5f5517ca31d7874
Author: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
Date:   Tue Apr 16 13:49:26 2013 -0400

    xen/smp: Fix leakage of timer interrupt line for every CPU online/offline.
    
    commit 888b65b4bc5e7fcbbb967023300cd5d44dba1950 upstream.
    
    In the PVHVM path when we do CPU online/offline path we would
    leak the timer%d IRQ line everytime we do a offline event. The
    online path (xen_hvm_setup_cpu_clockevents via
    x86_cpuinit.setup_percpu_clockev) would allocate a new interrupt
    line for the timer%d.
    
    But we would still use the old interrupt line leading to:
    
    kernel BUG at /home/konrad/ssd/konrad/linux/kernel/hrtimer.c:1261!
    invalid opcode: 0000 [#1] SMP
    RIP: 0010:[<ffffffff810b9e21>]  [<ffffffff810b9e21>] hrtimer_interrupt+0x261/0x270
    .. snip..
     <IRQ>
     [<ffffffff810445ef>] xen_timer_interrupt+0x2f/0x1b0
     [<ffffffff81104825>] ? stop_machine_cpu_stop+0xb5/0xf0
     [<ffffffff8111434c>] handle_irq_event_percpu+0x7c/0x240
     [<ffffffff811175b9>] handle_percpu_irq+0x49/0x70
     [<ffffffff813a74a3>] __xen_evtchn_do_upcall+0x1c3/0x2f0
     [<ffffffff813a760a>] xen_evtchn_do_upcall+0x2a/0x40
     [<ffffffff8167c26d>] xen_hvm_callback_vector+0x6d/0x80
     <EOI>
     [<ffffffff81666d01>] ? start_secondary+0x193/0x1a8
     [<ffffffff81666cfd>] ? start_secondary+0x18f/0x1a8
    
    There is also the oddity (timer1) in the /proc/interrupts after
    offlining CPU1:
    
      64:       1121          0  xen-percpu-virq      timer0
      78:          0          0  xen-percpu-virq      timer1
      84:          0       2483  xen-percpu-virq      timer2
    
    This patch fixes it.
    
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    [bwh: Backported to 3.2: adjust context]
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit 79d8ce897f2d73978e742334992da618a9fd839f
Author: Prarit Bhargava <prarit@redhat.com>
Date:   Mon Apr 8 08:47:15 2013 -0400

    hrtimer: Add expiry time overflow check in hrtimer_interrupt
    
    commit 8f294b5a139ee4b75e890ad5b443c93d1e558a8b upstream.
    
    The settimeofday01 test in the LTP testsuite effectively does
    
            gettimeofday(current time);
            settimeofday(Jan 1, 1970 + 100 seconds);
            settimeofday(current time);
    
    This test causes a stack trace to be displayed on the console during the
    setting of timeofday to Jan 1, 1970 + 100 seconds:
    
    [  131.066751] ------------[ cut here ]------------
    [  131.096448] WARNING: at kernel/time/clockevents.c:209 clockevents_program_event+0x135/0x140()
    [  131.104935] Hardware name: Dinar
    [  131.108150] Modules linked in: sg nfsv3 nfs_acl nfsv4 auth_rpcgss nfs dns_resolver fscache lockd sunrpc nf_conntrack_netbios_ns nf_conntrack_broadcast ipt_MASQUERADE ip6table_mangle ip6t_REJECT nf_conntrack_ipv6 nf_defrag_ipv6 iptable_nat nf_nat_ipv4 nf_nat iptable_mangle ipt_REJECT nf_conntrack_ipv4 nf_defrag_ipv4 xt_conntrack nf_conntrack ebtable_filter ebtables ip6table_filter ip6_tables iptable_filter ip_tables kvm_amd kvm sp5100_tco bnx2 i2c_piix4 crc32c_intel k10temp fam15h_power ghash_clmulni_intel amd64_edac_mod pcspkr serio_raw edac_mce_amd edac_core microcode xfs libcrc32c sr_mod sd_mod cdrom ata_generic crc_t10dif pata_acpi radeon i2c_algo_bit drm_kms_helper ttm drm ahci pata_atiixp libahci libata usb_storage i2c_core dm_mirror dm_region_hash dm_log dm_mod
    [  131.176784] Pid: 0, comm: swapper/28 Not tainted 3.8.0+ #6
    [  131.182248] Call Trace:
    [  131.184684]  <IRQ>  [<ffffffff810612af>] warn_slowpath_common+0x7f/0xc0
    [  131.191312]  [<ffffffff8106130a>] warn_slowpath_null+0x1a/0x20
    [  131.197131]  [<ffffffff810b9fd5>] clockevents_program_event+0x135/0x140
    [  131.203721]  [<ffffffff810bb584>] tick_program_event+0x24/0x30
    [  131.209534]  [<ffffffff81089ab1>] hrtimer_interrupt+0x131/0x230
    [  131.215437]  [<ffffffff814b9600>] ? cpufreq_p4_target+0x130/0x130
    [  131.221509]  [<ffffffff81619119>] smp_apic_timer_interrupt+0x69/0x99
    [  131.227839]  [<ffffffff8161805d>] apic_timer_interrupt+0x6d/0x80
    [  131.233816]  <EOI>  [<ffffffff81099745>] ? sched_clock_cpu+0xc5/0x120
    [  131.240267]  [<ffffffff814b9ff0>] ? cpuidle_wrap_enter+0x50/0xa0
    [  131.246252]  [<ffffffff814b9fe9>] ? cpuidle_wrap_enter+0x49/0xa0
    [  131.252238]  [<ffffffff814ba050>] cpuidle_enter_tk+0x10/0x20
    [  131.257877]  [<ffffffff814b9c89>] cpuidle_idle_call+0xa9/0x260
    [  131.263692]  [<ffffffff8101c42f>] cpu_idle+0xaf/0x120
    [  131.268727]  [<ffffffff815f8971>] start_secondary+0x255/0x257
    [  131.274449] ---[ end trace 1151a50552231615 ]---
    
    When we change the system time to a low value like this, the value of
    timekeeper->offs_real will be a negative value.
    
    It seems that the WARN occurs because an hrtimer has been started in the time
    between the releasing of the timekeeper lock and the IPI call (via a call to
    on_each_cpu) in clock_was_set() in the do_settimeofday() code.  The end result
    is that a REALTIME_CLOCK timer has been added with softexpires = expires =
    KTIME_MAX.  The hrtimer_interrupt() fires/is called and the loop at
    kernel/hrtimer.c:1289 is executed.  In this loop the code subtracts the
    clock base's offset (which was set to timekeeper->offs_real in
    do_settimeofday()) from the current hrtimer_cpu_base->expiry value (which
    was KTIME_MAX):
    
            KTIME_MAX - (a negative value) = overflow
    
    A simple check for an overflow can resolve this problem.  Using KTIME_MAX
    instead of the overflow value will result in the hrtimer function being run,
    and the reprogramming of the timer after that.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Rik van Riel <riel@redhat.com>
    Signed-off-by: Prarit Bhargava <prarit@redhat.com>
    [jstultz: Tweaked commit subject]
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit ee50f837b567e691ba1347042dab3e2c5ff44112
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Apr 25 11:45:53 2013 +0200

    clockevents: Set dummy handler on CPU_DEAD shutdown
    
    commit 6f7a05d7018de222e40ca003721037a530979974 upstream.
    
    Vitaliy reported that a per cpu HPET timer interrupt crashes the
    system during hibernation. What happens is that the per cpu HPET timer
    gets shut down when the nonboot cpus are stopped. When the nonboot
    cpus are onlined again the HPET code sets up the MSI interrupt which
    fires before the clock event device is registered. The event handler
    is still set to hrtimer_interrupt, which then crashes the machine due
    to highres mode not being active.
    
    See http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=700333
    
    There is no real good way to avoid that in the HPET code. The HPET
    code alrady has a mechanism to detect spurious interrupts when event
    handler == NULL for a similar reason.
    
    We can handle that in the clockevent/tick layer and replace the
    previous functional handler with a dummy handler like we do in
    tick_setup_new_device().
    
    The original clockevents code did this in clockevents_exchange_device(),
    but that got removed by commit 7c1e76897 (clockevents: prevent
    clockevent event_handler ending up handler_noop) which forgot to fix
    it up in tick_shutdown(). Same issue with the broadcast device.
    
    Reported-by: Vitaliy Fillipov <vitalif@yourcmc.ru>
    Cc: Ben Hutchings <ben@decadent.org.uk>
    Cc: 700333@bugs.debian.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 66e79283801c000513f7a6026620b7b5278bf156
Author: Prarit Bhargava <prarit@redhat.com>
Date:   Mon Apr 8 08:47:15 2013 -0400

    hrtimer: Add expiry time overflow check in hrtimer_interrupt
    
    commit 8f294b5a139ee4b75e890ad5b443c93d1e558a8b upstream.
    
    The settimeofday01 test in the LTP testsuite effectively does
    
            gettimeofday(current time);
            settimeofday(Jan 1, 1970 + 100 seconds);
            settimeofday(current time);
    
    This test causes a stack trace to be displayed on the console during the
    setting of timeofday to Jan 1, 1970 + 100 seconds:
    
    [  131.066751] ------------[ cut here ]------------
    [  131.096448] WARNING: at kernel/time/clockevents.c:209 clockevents_program_event+0x135/0x140()
    [  131.104935] Hardware name: Dinar
    [  131.108150] Modules linked in: sg nfsv3 nfs_acl nfsv4 auth_rpcgss nfs dns_resolver fscache lockd sunrpc nf_conntrack_netbios_ns nf_conntrack_broadcast ipt_MASQUERADE ip6table_mangle ip6t_REJECT nf_conntrack_ipv6 nf_defrag_ipv6 iptable_nat nf_nat_ipv4 nf_nat iptable_mangle ipt_REJECT nf_conntrack_ipv4 nf_defrag_ipv4 xt_conntrack nf_conntrack ebtable_filter ebtables ip6table_filter ip6_tables iptable_filter ip_tables kvm_amd kvm sp5100_tco bnx2 i2c_piix4 crc32c_intel k10temp fam15h_power ghash_clmulni_intel amd64_edac_mod pcspkr serio_raw edac_mce_amd edac_core microcode xfs libcrc32c sr_mod sd_mod cdrom ata_generic crc_t10dif pata_acpi radeon i2c_algo_bit drm_kms_helper ttm drm ahci pata_atiixp libahci libata usb_storage i2c_core dm_mirror dm_region_hash dm_log dm_mod
    [  131.176784] Pid: 0, comm: swapper/28 Not tainted 3.8.0+ #6
    [  131.182248] Call Trace:
    [  131.184684]  <IRQ>  [<ffffffff810612af>] warn_slowpath_common+0x7f/0xc0
    [  131.191312]  [<ffffffff8106130a>] warn_slowpath_null+0x1a/0x20
    [  131.197131]  [<ffffffff810b9fd5>] clockevents_program_event+0x135/0x140
    [  131.203721]  [<ffffffff810bb584>] tick_program_event+0x24/0x30
    [  131.209534]  [<ffffffff81089ab1>] hrtimer_interrupt+0x131/0x230
    [  131.215437]  [<ffffffff814b9600>] ? cpufreq_p4_target+0x130/0x130
    [  131.221509]  [<ffffffff81619119>] smp_apic_timer_interrupt+0x69/0x99
    [  131.227839]  [<ffffffff8161805d>] apic_timer_interrupt+0x6d/0x80
    [  131.233816]  <EOI>  [<ffffffff81099745>] ? sched_clock_cpu+0xc5/0x120
    [  131.240267]  [<ffffffff814b9ff0>] ? cpuidle_wrap_enter+0x50/0xa0
    [  131.246252]  [<ffffffff814b9fe9>] ? cpuidle_wrap_enter+0x49/0xa0
    [  131.252238]  [<ffffffff814ba050>] cpuidle_enter_tk+0x10/0x20
    [  131.257877]  [<ffffffff814b9c89>] cpuidle_idle_call+0xa9/0x260
    [  131.263692]  [<ffffffff8101c42f>] cpu_idle+0xaf/0x120
    [  131.268727]  [<ffffffff815f8971>] start_secondary+0x255/0x257
    [  131.274449] ---[ end trace 1151a50552231615 ]---
    
    When we change the system time to a low value like this, the value of
    timekeeper->offs_real will be a negative value.
    
    It seems that the WARN occurs because an hrtimer has been started in the time
    between the releasing of the timekeeper lock and the IPI call (via a call to
    on_each_cpu) in clock_was_set() in the do_settimeofday() code.  The end result
    is that a REALTIME_CLOCK timer has been added with softexpires = expires =
    KTIME_MAX.  The hrtimer_interrupt() fires/is called and the loop at
    kernel/hrtimer.c:1289 is executed.  In this loop the code subtracts the
    clock base's offset (which was set to timekeeper->offs_real in
    do_settimeofday()) from the current hrtimer_cpu_base->expiry value (which
    was KTIME_MAX):
    
            KTIME_MAX - (a negative value) = overflow
    
    A simple check for an overflow can resolve this problem.  Using KTIME_MAX
    instead of the overflow value will result in the hrtimer function being run,
    and the reprogramming of the timer after that.
    
    Reviewed-by: Rik van Riel <riel@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Prarit Bhargava <prarit@redhat.com>
    [jstultz: Tweaked commit subject]
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 4a605ff63b16199d20be2209ac6f48f7125bc8f5
Author: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
Date:   Tue Apr 16 13:49:26 2013 -0400

    xen/smp: Fix leakage of timer interrupt line for every CPU online/offline.
    
    commit 888b65b4bc5e7fcbbb967023300cd5d44dba1950 upstream.
    
    In the PVHVM path when we do CPU online/offline path we would
    leak the timer%d IRQ line everytime we do a offline event. The
    online path (xen_hvm_setup_cpu_clockevents via
    x86_cpuinit.setup_percpu_clockev) would allocate a new interrupt
    line for the timer%d.
    
    But we would still use the old interrupt line leading to:
    
    kernel BUG at /home/konrad/ssd/konrad/linux/kernel/hrtimer.c:1261!
    invalid opcode: 0000 [#1] SMP
    RIP: 0010:[<ffffffff810b9e21>]  [<ffffffff810b9e21>] hrtimer_interrupt+0x261/0x270
    .. snip..
     <IRQ>
     [<ffffffff810445ef>] xen_timer_interrupt+0x2f/0x1b0
     [<ffffffff81104825>] ? stop_machine_cpu_stop+0xb5/0xf0
     [<ffffffff8111434c>] handle_irq_event_percpu+0x7c/0x240
     [<ffffffff811175b9>] handle_percpu_irq+0x49/0x70
     [<ffffffff813a74a3>] __xen_evtchn_do_upcall+0x1c3/0x2f0
     [<ffffffff813a760a>] xen_evtchn_do_upcall+0x2a/0x40
     [<ffffffff8167c26d>] xen_hvm_callback_vector+0x6d/0x80
     <EOI>
     [<ffffffff81666d01>] ? start_secondary+0x193/0x1a8
     [<ffffffff81666cfd>] ? start_secondary+0x18f/0x1a8
    
    There is also the oddity (timer1) in the /proc/interrupts after
    offlining CPU1:
    
      64:       1121          0  xen-percpu-virq      timer0
      78:          0          0  xen-percpu-virq      timer1
      84:          0       2483  xen-percpu-virq      timer2
    
    This patch fixes it.
    
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 3672f12220a0994d9e37d6e2bb93ac7ec1669d60
Author: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
Date:   Tue Apr 16 15:18:00 2013 -0400

    xen/time: Fix kasprintf splat when allocating timer%d IRQ line.
    
    commit 7918c92ae9638eb8a6ec18e2b4a0de84557cccc8 upstream.
    
    When we online the CPU, we get this splat:
    
    smpboot: Booting Node 0 Processor 1 APIC 0x2
    installing Xen timer for CPU 1
    BUG: sleeping function called from invalid context at /home/konrad/ssd/konrad/linux/mm/slab.c:3179
    in_atomic(): 1, irqs_disabled(): 0, pid: 0, name: swapper/1
    Pid: 0, comm: swapper/1 Not tainted 3.9.0-rc6upstream-00001-g3884fad #1
    Call Trace:
     [<ffffffff810c1fea>] __might_sleep+0xda/0x100
     [<ffffffff81194617>] __kmalloc_track_caller+0x1e7/0x2c0
     [<ffffffff81303758>] ? kasprintf+0x38/0x40
     [<ffffffff813036eb>] kvasprintf+0x5b/0x90
     [<ffffffff81303758>] kasprintf+0x38/0x40
     [<ffffffff81044510>] xen_setup_timer+0x30/0xb0
     [<ffffffff810445af>] xen_hvm_setup_cpu_clockevents+0x1f/0x30
     [<ffffffff81666d0a>] start_secondary+0x19c/0x1a8
    
    The solution to that is use kasprintf in the CPU hotplug path
    that 'online's the CPU. That is, do it in in xen_hvm_cpu_notify,
    and remove the call to in xen_hvm_setup_cpu_clockevents.
    
    Unfortunatly the later is not a good idea as the bootup path
    does not use xen_hvm_cpu_notify so we would end up never allocating
    timer%d interrupt lines when booting. As such add the check for
    atomic() to continue.
    
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit fc8bc6906f47766f9bdcb296f4b176984889249e
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Apr 25 11:45:53 2013 +0200

    clockevents: Set dummy handler on CPU_DEAD shutdown
    
    commit 6f7a05d7018de222e40ca003721037a530979974 upstream.
    
    Vitaliy reported that a per cpu HPET timer interrupt crashes the
    system during hibernation. What happens is that the per cpu HPET timer
    gets shut down when the nonboot cpus are stopped. When the nonboot
    cpus are onlined again the HPET code sets up the MSI interrupt which
    fires before the clock event device is registered. The event handler
    is still set to hrtimer_interrupt, which then crashes the machine due
    to highres mode not being active.
    
    See http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=700333
    
    There is no real good way to avoid that in the HPET code. The HPET
    code alrady has a mechanism to detect spurious interrupts when event
    handler == NULL for a similar reason.
    
    We can handle that in the clockevent/tick layer and replace the
    previous functional handler with a dummy handler like we do in
    tick_setup_new_device().
    
    The original clockevents code did this in clockevents_exchange_device(),
    but that got removed by commit 7c1e76897 (clockevents: prevent
    clockevent event_handler ending up handler_noop) which forgot to fix
    it up in tick_shutdown(). Same issue with the broadcast device.
    
    Reported-by: Vitaliy Fillipov <vitalif@yourcmc.ru>
    Cc: Ben Hutchings <ben@decadent.org.uk>
    Cc: 700333@bugs.debian.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 551c15a593c8c8636d609508f6a3d957bdec10ea
Author: Prarit Bhargava <prarit@redhat.com>
Date:   Mon Apr 8 08:47:15 2013 -0400

    hrtimer: Add expiry time overflow check in hrtimer_interrupt
    
    commit 8f294b5a139ee4b75e890ad5b443c93d1e558a8b upstream.
    
    The settimeofday01 test in the LTP testsuite effectively does
    
            gettimeofday(current time);
            settimeofday(Jan 1, 1970 + 100 seconds);
            settimeofday(current time);
    
    This test causes a stack trace to be displayed on the console during the
    setting of timeofday to Jan 1, 1970 + 100 seconds:
    
    [  131.066751] ------------[ cut here ]------------
    [  131.096448] WARNING: at kernel/time/clockevents.c:209 clockevents_program_event+0x135/0x140()
    [  131.104935] Hardware name: Dinar
    [  131.108150] Modules linked in: sg nfsv3 nfs_acl nfsv4 auth_rpcgss nfs dns_resolver fscache lockd sunrpc nf_conntrack_netbios_ns nf_conntrack_broadcast ipt_MASQUERADE ip6table_mangle ip6t_REJECT nf_conntrack_ipv6 nf_defrag_ipv6 iptable_nat nf_nat_ipv4 nf_nat iptable_mangle ipt_REJECT nf_conntrack_ipv4 nf_defrag_ipv4 xt_conntrack nf_conntrack ebtable_filter ebtables ip6table_filter ip6_tables iptable_filter ip_tables kvm_amd kvm sp5100_tco bnx2 i2c_piix4 crc32c_intel k10temp fam15h_power ghash_clmulni_intel amd64_edac_mod pcspkr serio_raw edac_mce_amd edac_core microcode xfs libcrc32c sr_mod sd_mod cdrom ata_generic crc_t10dif pata_acpi radeon i2c_algo_bit drm_kms_helper ttm drm ahci pata_atiixp libahci libata usb_storage i2c_core dm_mirror dm_region_hash dm_log dm_mod
    [  131.176784] Pid: 0, comm: swapper/28 Not tainted 3.8.0+ #6
    [  131.182248] Call Trace:
    [  131.184684]  <IRQ>  [<ffffffff810612af>] warn_slowpath_common+0x7f/0xc0
    [  131.191312]  [<ffffffff8106130a>] warn_slowpath_null+0x1a/0x20
    [  131.197131]  [<ffffffff810b9fd5>] clockevents_program_event+0x135/0x140
    [  131.203721]  [<ffffffff810bb584>] tick_program_event+0x24/0x30
    [  131.209534]  [<ffffffff81089ab1>] hrtimer_interrupt+0x131/0x230
    [  131.215437]  [<ffffffff814b9600>] ? cpufreq_p4_target+0x130/0x130
    [  131.221509]  [<ffffffff81619119>] smp_apic_timer_interrupt+0x69/0x99
    [  131.227839]  [<ffffffff8161805d>] apic_timer_interrupt+0x6d/0x80
    [  131.233816]  <EOI>  [<ffffffff81099745>] ? sched_clock_cpu+0xc5/0x120
    [  131.240267]  [<ffffffff814b9ff0>] ? cpuidle_wrap_enter+0x50/0xa0
    [  131.246252]  [<ffffffff814b9fe9>] ? cpuidle_wrap_enter+0x49/0xa0
    [  131.252238]  [<ffffffff814ba050>] cpuidle_enter_tk+0x10/0x20
    [  131.257877]  [<ffffffff814b9c89>] cpuidle_idle_call+0xa9/0x260
    [  131.263692]  [<ffffffff8101c42f>] cpu_idle+0xaf/0x120
    [  131.268727]  [<ffffffff815f8971>] start_secondary+0x255/0x257
    [  131.274449] ---[ end trace 1151a50552231615 ]---
    
    When we change the system time to a low value like this, the value of
    timekeeper->offs_real will be a negative value.
    
    It seems that the WARN occurs because an hrtimer has been started in the time
    between the releasing of the timekeeper lock and the IPI call (via a call to
    on_each_cpu) in clock_was_set() in the do_settimeofday() code.  The end result
    is that a REALTIME_CLOCK timer has been added with softexpires = expires =
    KTIME_MAX.  The hrtimer_interrupt() fires/is called and the loop at
    kernel/hrtimer.c:1289 is executed.  In this loop the code subtracts the
    clock base's offset (which was set to timekeeper->offs_real in
    do_settimeofday()) from the current hrtimer_cpu_base->expiry value (which
    was KTIME_MAX):
    
            KTIME_MAX - (a negative value) = overflow
    
    A simple check for an overflow can resolve this problem.  Using KTIME_MAX
    instead of the overflow value will result in the hrtimer function being run,
    and the reprogramming of the timer after that.
    
    Reviewed-by: Rik van Riel <riel@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Prarit Bhargava <prarit@redhat.com>
    [jstultz: Tweaked commit subject]
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit d9cdb8cadde392413f01d8182863d1727a43a60b
Author: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
Date:   Tue Apr 16 13:49:26 2013 -0400

    xen/smp: Fix leakage of timer interrupt line for every CPU online/offline.
    
    commit 888b65b4bc5e7fcbbb967023300cd5d44dba1950 upstream.
    
    In the PVHVM path when we do CPU online/offline path we would
    leak the timer%d IRQ line everytime we do a offline event. The
    online path (xen_hvm_setup_cpu_clockevents via
    x86_cpuinit.setup_percpu_clockev) would allocate a new interrupt
    line for the timer%d.
    
    But we would still use the old interrupt line leading to:
    
    kernel BUG at /home/konrad/ssd/konrad/linux/kernel/hrtimer.c:1261!
    invalid opcode: 0000 [#1] SMP
    RIP: 0010:[<ffffffff810b9e21>]  [<ffffffff810b9e21>] hrtimer_interrupt+0x261/0x270
    .. snip..
     <IRQ>
     [<ffffffff810445ef>] xen_timer_interrupt+0x2f/0x1b0
     [<ffffffff81104825>] ? stop_machine_cpu_stop+0xb5/0xf0
     [<ffffffff8111434c>] handle_irq_event_percpu+0x7c/0x240
     [<ffffffff811175b9>] handle_percpu_irq+0x49/0x70
     [<ffffffff813a74a3>] __xen_evtchn_do_upcall+0x1c3/0x2f0
     [<ffffffff813a760a>] xen_evtchn_do_upcall+0x2a/0x40
     [<ffffffff8167c26d>] xen_hvm_callback_vector+0x6d/0x80
     <EOI>
     [<ffffffff81666d01>] ? start_secondary+0x193/0x1a8
     [<ffffffff81666cfd>] ? start_secondary+0x18f/0x1a8
    
    There is also the oddity (timer1) in the /proc/interrupts after
    offlining CPU1:
    
      64:       1121          0  xen-percpu-virq      timer0
      78:          0          0  xen-percpu-virq      timer1
      84:          0       2483  xen-percpu-virq      timer2
    
    This patch fixes it.
    
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 037f6cd3f80e2777b758839055faaba00aab6e3d
Author: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
Date:   Tue Apr 16 15:18:00 2013 -0400

    xen/time: Fix kasprintf splat when allocating timer%d IRQ line.
    
    commit 7918c92ae9638eb8a6ec18e2b4a0de84557cccc8 upstream.
    
    When we online the CPU, we get this splat:
    
    smpboot: Booting Node 0 Processor 1 APIC 0x2
    installing Xen timer for CPU 1
    BUG: sleeping function called from invalid context at /home/konrad/ssd/konrad/linux/mm/slab.c:3179
    in_atomic(): 1, irqs_disabled(): 0, pid: 0, name: swapper/1
    Pid: 0, comm: swapper/1 Not tainted 3.9.0-rc6upstream-00001-g3884fad #1
    Call Trace:
     [<ffffffff810c1fea>] __might_sleep+0xda/0x100
     [<ffffffff81194617>] __kmalloc_track_caller+0x1e7/0x2c0
     [<ffffffff81303758>] ? kasprintf+0x38/0x40
     [<ffffffff813036eb>] kvasprintf+0x5b/0x90
     [<ffffffff81303758>] kasprintf+0x38/0x40
     [<ffffffff81044510>] xen_setup_timer+0x30/0xb0
     [<ffffffff810445af>] xen_hvm_setup_cpu_clockevents+0x1f/0x30
     [<ffffffff81666d0a>] start_secondary+0x19c/0x1a8
    
    The solution to that is use kasprintf in the CPU hotplug path
    that 'online's the CPU. That is, do it in in xen_hvm_cpu_notify,
    and remove the call to in xen_hvm_setup_cpu_clockevents.
    
    Unfortunatly the later is not a good idea as the bootup path
    does not use xen_hvm_cpu_notify so we would end up never allocating
    timer%d interrupt lines when booting. As such add the check for
    atomic() to continue.
    
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit a35089a9cc44f621e58af899b3483d206bb89284
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Apr 25 11:45:53 2013 +0200

    clockevents: Set dummy handler on CPU_DEAD shutdown
    
    commit 6f7a05d7018de222e40ca003721037a530979974 upstream.
    
    Vitaliy reported that a per cpu HPET timer interrupt crashes the
    system during hibernation. What happens is that the per cpu HPET timer
    gets shut down when the nonboot cpus are stopped. When the nonboot
    cpus are onlined again the HPET code sets up the MSI interrupt which
    fires before the clock event device is registered. The event handler
    is still set to hrtimer_interrupt, which then crashes the machine due
    to highres mode not being active.
    
    See http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=700333
    
    There is no real good way to avoid that in the HPET code. The HPET
    code alrady has a mechanism to detect spurious interrupts when event
    handler == NULL for a similar reason.
    
    We can handle that in the clockevent/tick layer and replace the
    previous functional handler with a dummy handler like we do in
    tick_setup_new_device().
    
    The original clockevents code did this in clockevents_exchange_device(),
    but that got removed by commit 7c1e76897 (clockevents: prevent
    clockevent event_handler ending up handler_noop) which forgot to fix
    it up in tick_shutdown(). Same issue with the broadcast device.
    
    Reported-by: Vitaliy Fillipov <vitalif@yourcmc.ru>
    Cc: Ben Hutchings <ben@decadent.org.uk>
    Cc: 700333@bugs.debian.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit a0f25ff9b9e74174def19cdad1f1d2e7f4894683
Author: Prarit Bhargava <prarit@redhat.com>
Date:   Mon Apr 8 08:47:15 2013 -0400

    hrtimer: Add expiry time overflow check in hrtimer_interrupt
    
    commit 8f294b5a139ee4b75e890ad5b443c93d1e558a8b upstream.
    
    The settimeofday01 test in the LTP testsuite effectively does
    
            gettimeofday(current time);
            settimeofday(Jan 1, 1970 + 100 seconds);
            settimeofday(current time);
    
    This test causes a stack trace to be displayed on the console during the
    setting of timeofday to Jan 1, 1970 + 100 seconds:
    
    [  131.066751] ------------[ cut here ]------------
    [  131.096448] WARNING: at kernel/time/clockevents.c:209 clockevents_program_event+0x135/0x140()
    [  131.104935] Hardware name: Dinar
    [  131.108150] Modules linked in: sg nfsv3 nfs_acl nfsv4 auth_rpcgss nfs dns_resolver fscache lockd sunrpc nf_conntrack_netbios_ns nf_conntrack_broadcast ipt_MASQUERADE ip6table_mangle ip6t_REJECT nf_conntrack_ipv6 nf_defrag_ipv6 iptable_nat nf_nat_ipv4 nf_nat iptable_mangle ipt_REJECT nf_conntrack_ipv4 nf_defrag_ipv4 xt_conntrack nf_conntrack ebtable_filter ebtables ip6table_filter ip6_tables iptable_filter ip_tables kvm_amd kvm sp5100_tco bnx2 i2c_piix4 crc32c_intel k10temp fam15h_power ghash_clmulni_intel amd64_edac_mod pcspkr serio_raw edac_mce_amd edac_core microcode xfs libcrc32c sr_mod sd_mod cdrom ata_generic crc_t10dif pata_acpi radeon i2c_algo_bit drm_kms_helper ttm drm ahci pata_atiixp libahci libata usb_storage i2c_core dm_mirror dm_region_hash dm_log dm_mod
    [  131.176784] Pid: 0, comm: swapper/28 Not tainted 3.8.0+ #6
    [  131.182248] Call Trace:
    [  131.184684]  <IRQ>  [<ffffffff810612af>] warn_slowpath_common+0x7f/0xc0
    [  131.191312]  [<ffffffff8106130a>] warn_slowpath_null+0x1a/0x20
    [  131.197131]  [<ffffffff810b9fd5>] clockevents_program_event+0x135/0x140
    [  131.203721]  [<ffffffff810bb584>] tick_program_event+0x24/0x30
    [  131.209534]  [<ffffffff81089ab1>] hrtimer_interrupt+0x131/0x230
    [  131.215437]  [<ffffffff814b9600>] ? cpufreq_p4_target+0x130/0x130
    [  131.221509]  [<ffffffff81619119>] smp_apic_timer_interrupt+0x69/0x99
    [  131.227839]  [<ffffffff8161805d>] apic_timer_interrupt+0x6d/0x80
    [  131.233816]  <EOI>  [<ffffffff81099745>] ? sched_clock_cpu+0xc5/0x120
    [  131.240267]  [<ffffffff814b9ff0>] ? cpuidle_wrap_enter+0x50/0xa0
    [  131.246252]  [<ffffffff814b9fe9>] ? cpuidle_wrap_enter+0x49/0xa0
    [  131.252238]  [<ffffffff814ba050>] cpuidle_enter_tk+0x10/0x20
    [  131.257877]  [<ffffffff814b9c89>] cpuidle_idle_call+0xa9/0x260
    [  131.263692]  [<ffffffff8101c42f>] cpu_idle+0xaf/0x120
    [  131.268727]  [<ffffffff815f8971>] start_secondary+0x255/0x257
    [  131.274449] ---[ end trace 1151a50552231615 ]---
    
    When we change the system time to a low value like this, the value of
    timekeeper->offs_real will be a negative value.
    
    It seems that the WARN occurs because an hrtimer has been started in the time
    between the releasing of the timekeeper lock and the IPI call (via a call to
    on_each_cpu) in clock_was_set() in the do_settimeofday() code.  The end result
    is that a REALTIME_CLOCK timer has been added with softexpires = expires =
    KTIME_MAX.  The hrtimer_interrupt() fires/is called and the loop at
    kernel/hrtimer.c:1289 is executed.  In this loop the code subtracts the
    clock base's offset (which was set to timekeeper->offs_real in
    do_settimeofday()) from the current hrtimer_cpu_base->expiry value (which
    was KTIME_MAX):
    
            KTIME_MAX - (a negative value) = overflow
    
    A simple check for an overflow can resolve this problem.  Using KTIME_MAX
    instead of the overflow value will result in the hrtimer function being run,
    and the reprogramming of the timer after that.
    
    Reviewed-by: Rik van Riel <riel@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Prarit Bhargava <prarit@redhat.com>
    [jstultz: Tweaked commit subject]
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit f7cfcd277732f50bbdaf56880546faddbb2a73ba
Author: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
Date:   Tue Apr 16 15:18:00 2013 -0400

    xen/time: Fix kasprintf splat when allocating timer%d IRQ line.
    
    commit 7918c92ae9638eb8a6ec18e2b4a0de84557cccc8 upstream.
    
    When we online the CPU, we get this splat:
    
    smpboot: Booting Node 0 Processor 1 APIC 0x2
    installing Xen timer for CPU 1
    BUG: sleeping function called from invalid context at /home/konrad/ssd/konrad/linux/mm/slab.c:3179
    in_atomic(): 1, irqs_disabled(): 0, pid: 0, name: swapper/1
    Pid: 0, comm: swapper/1 Not tainted 3.9.0-rc6upstream-00001-g3884fad #1
    Call Trace:
     [<ffffffff810c1fea>] __might_sleep+0xda/0x100
     [<ffffffff81194617>] __kmalloc_track_caller+0x1e7/0x2c0
     [<ffffffff81303758>] ? kasprintf+0x38/0x40
     [<ffffffff813036eb>] kvasprintf+0x5b/0x90
     [<ffffffff81303758>] kasprintf+0x38/0x40
     [<ffffffff81044510>] xen_setup_timer+0x30/0xb0
     [<ffffffff810445af>] xen_hvm_setup_cpu_clockevents+0x1f/0x30
     [<ffffffff81666d0a>] start_secondary+0x19c/0x1a8
    
    The solution to that is use kasprintf in the CPU hotplug path
    that 'online's the CPU. That is, do it in in xen_hvm_cpu_notify,
    and remove the call to in xen_hvm_setup_cpu_clockevents.
    
    Unfortunatly the later is not a good idea as the bootup path
    does not use xen_hvm_cpu_notify so we would end up never allocating
    timer%d interrupt lines when booting. As such add the check for
    atomic() to continue.
    
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 357093a8b82c10e6fff37d3c772ccc0e3b0549c4
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Apr 25 11:45:53 2013 +0200

    clockevents: Set dummy handler on CPU_DEAD shutdown
    
    commit 6f7a05d7018de222e40ca003721037a530979974 upstream.
    
    Vitaliy reported that a per cpu HPET timer interrupt crashes the
    system during hibernation. What happens is that the per cpu HPET timer
    gets shut down when the nonboot cpus are stopped. When the nonboot
    cpus are onlined again the HPET code sets up the MSI interrupt which
    fires before the clock event device is registered. The event handler
    is still set to hrtimer_interrupt, which then crashes the machine due
    to highres mode not being active.
    
    See http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=700333
    
    There is no real good way to avoid that in the HPET code. The HPET
    code alrady has a mechanism to detect spurious interrupts when event
    handler == NULL for a similar reason.
    
    We can handle that in the clockevent/tick layer and replace the
    previous functional handler with a dummy handler like we do in
    tick_setup_new_device().
    
    The original clockevents code did this in clockevents_exchange_device(),
    but that got removed by commit 7c1e76897 (clockevents: prevent
    clockevent event_handler ending up handler_noop) which forgot to fix
    it up in tick_shutdown(). Same issue with the broadcast device.
    
    Reported-by: Vitaliy Fillipov <vitalif@yourcmc.ru>
    Cc: Ben Hutchings <ben@decadent.org.uk>
    Cc: 700333@bugs.debian.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 194d30b3996940a012ed8265f3969f1f75ff7ec5
Author: Prarit Bhargava <prarit@redhat.com>
Date:   Mon Apr 8 08:47:15 2013 -0400

    hrtimer: Add expiry time overflow check in hrtimer_interrupt
    
    commit 8f294b5a139ee4b75e890ad5b443c93d1e558a8b upstream.
    
    The settimeofday01 test in the LTP testsuite effectively does
    
            gettimeofday(current time);
            settimeofday(Jan 1, 1970 + 100 seconds);
            settimeofday(current time);
    
    This test causes a stack trace to be displayed on the console during the
    setting of timeofday to Jan 1, 1970 + 100 seconds:
    
    [  131.066751] ------------[ cut here ]------------
    [  131.096448] WARNING: at kernel/time/clockevents.c:209 clockevents_program_event+0x135/0x140()
    [  131.104935] Hardware name: Dinar
    [  131.108150] Modules linked in: sg nfsv3 nfs_acl nfsv4 auth_rpcgss nfs dns_resolver fscache lockd sunrpc nf_conntrack_netbios_ns nf_conntrack_broadcast ipt_MASQUERADE ip6table_mangle ip6t_REJECT nf_conntrack_ipv6 nf_defrag_ipv6 iptable_nat nf_nat_ipv4 nf_nat iptable_mangle ipt_REJECT nf_conntrack_ipv4 nf_defrag_ipv4 xt_conntrack nf_conntrack ebtable_filter ebtables ip6table_filter ip6_tables iptable_filter ip_tables kvm_amd kvm sp5100_tco bnx2 i2c_piix4 crc32c_intel k10temp fam15h_power ghash_clmulni_intel amd64_edac_mod pcspkr serio_raw edac_mce_amd edac_core microcode xfs libcrc32c sr_mod sd_mod cdrom ata_generic crc_t10dif pata_acpi radeon i2c_algo_bit drm_kms_helper ttm drm ahci pata_atiixp libahci libata usb_storage i2c_core dm_mirror dm_region_hash dm_log dm_mod
    [  131.176784] Pid: 0, comm: swapper/28 Not tainted 3.8.0+ #6
    [  131.182248] Call Trace:
    [  131.184684]  <IRQ>  [<ffffffff810612af>] warn_slowpath_common+0x7f/0xc0
    [  131.191312]  [<ffffffff8106130a>] warn_slowpath_null+0x1a/0x20
    [  131.197131]  [<ffffffff810b9fd5>] clockevents_program_event+0x135/0x140
    [  131.203721]  [<ffffffff810bb584>] tick_program_event+0x24/0x30
    [  131.209534]  [<ffffffff81089ab1>] hrtimer_interrupt+0x131/0x230
    [  131.215437]  [<ffffffff814b9600>] ? cpufreq_p4_target+0x130/0x130
    [  131.221509]  [<ffffffff81619119>] smp_apic_timer_interrupt+0x69/0x99
    [  131.227839]  [<ffffffff8161805d>] apic_timer_interrupt+0x6d/0x80
    [  131.233816]  <EOI>  [<ffffffff81099745>] ? sched_clock_cpu+0xc5/0x120
    [  131.240267]  [<ffffffff814b9ff0>] ? cpuidle_wrap_enter+0x50/0xa0
    [  131.246252]  [<ffffffff814b9fe9>] ? cpuidle_wrap_enter+0x49/0xa0
    [  131.252238]  [<ffffffff814ba050>] cpuidle_enter_tk+0x10/0x20
    [  131.257877]  [<ffffffff814b9c89>] cpuidle_idle_call+0xa9/0x260
    [  131.263692]  [<ffffffff8101c42f>] cpu_idle+0xaf/0x120
    [  131.268727]  [<ffffffff815f8971>] start_secondary+0x255/0x257
    [  131.274449] ---[ end trace 1151a50552231615 ]---
    
    When we change the system time to a low value like this, the value of
    timekeeper->offs_real will be a negative value.
    
    It seems that the WARN occurs because an hrtimer has been started in the time
    between the releasing of the timekeeper lock and the IPI call (via a call to
    on_each_cpu) in clock_was_set() in the do_settimeofday() code.  The end result
    is that a REALTIME_CLOCK timer has been added with softexpires = expires =
    KTIME_MAX.  The hrtimer_interrupt() fires/is called and the loop at
    kernel/hrtimer.c:1289 is executed.  In this loop the code subtracts the
    clock base's offset (which was set to timekeeper->offs_real in
    do_settimeofday()) from the current hrtimer_cpu_base->expiry value (which
    was KTIME_MAX):
    
            KTIME_MAX - (a negative value) = overflow
    
    A simple check for an overflow can resolve this problem.  Using KTIME_MAX
    instead of the overflow value will result in the hrtimer function being run,
    and the reprogramming of the timer after that.
    
    Reviewed-by: Rik van Riel <riel@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Prarit Bhargava <prarit@redhat.com>
    [jstultz: Tweaked commit subject]
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 0c6ad85215e151e96a0af63f7012d6642c23e3bd
Author: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
Date:   Tue Apr 16 15:18:00 2013 -0400

    xen/time: Fix kasprintf splat when allocating timer%d IRQ line.
    
    commit 7918c92ae9638eb8a6ec18e2b4a0de84557cccc8 upstream.
    
    When we online the CPU, we get this splat:
    
    smpboot: Booting Node 0 Processor 1 APIC 0x2
    installing Xen timer for CPU 1
    BUG: sleeping function called from invalid context at /home/konrad/ssd/konrad/linux/mm/slab.c:3179
    in_atomic(): 1, irqs_disabled(): 0, pid: 0, name: swapper/1
    Pid: 0, comm: swapper/1 Not tainted 3.9.0-rc6upstream-00001-g3884fad #1
    Call Trace:
     [<ffffffff810c1fea>] __might_sleep+0xda/0x100
     [<ffffffff81194617>] __kmalloc_track_caller+0x1e7/0x2c0
     [<ffffffff81303758>] ? kasprintf+0x38/0x40
     [<ffffffff813036eb>] kvasprintf+0x5b/0x90
     [<ffffffff81303758>] kasprintf+0x38/0x40
     [<ffffffff81044510>] xen_setup_timer+0x30/0xb0
     [<ffffffff810445af>] xen_hvm_setup_cpu_clockevents+0x1f/0x30
     [<ffffffff81666d0a>] start_secondary+0x19c/0x1a8
    
    The solution to that is use kasprintf in the CPU hotplug path
    that 'online's the CPU. That is, do it in in xen_hvm_cpu_notify,
    and remove the call to in xen_hvm_setup_cpu_clockevents.
    
    Unfortunatly the later is not a good idea as the bootup path
    does not use xen_hvm_cpu_notify so we would end up never allocating
    timer%d interrupt lines when booting. As such add the check for
    atomic() to continue.
    
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit bb9055b2744ada735a2fe555c4196ad39a83ef2a
Merge: 1bf25e78af31 241a9871263f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue May 7 11:28:42 2013 -0700

    Merge tag 'multiplatform-for-linus-2' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull late ARM Exynos multiplatform changes from Arnd Bergmann:
     "These continue the multiplatform support for exynos, adding support
      for building most of the essential drivers (clocksource, clk, irqchip)
      when combined with other platforms.  As a result, it should become
      really easy to add full multiplatform exynos support in 3.11, although
      we don't yet enable it for 3.10.
    
      The changes were not included in the earlier multiplatform series in
      order to avoid clashes with the other Exynos updates.
    
      This also includes work from Tomasz Figa to fix the pwm clocksource
      code on Exynos, which is not strictly required for multiplatform, but
      related to the other patches in this set and needed as a bug fix for
      at least one board."
    
    * tag 'multiplatform-for-linus-2' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (22 commits)
      ARM: dts: exynops4210: really add universal_c210 dts
      ARM: dts: exynos4210: Add basic dts file for universal_c210 board
      ARM: dts: exynos4: Add node for PWM device
      ARM: SAMSUNG: Do not register legacy timer interrupts on Exynos
      clocksource: samsung_pwm_timer: Work around rounding errors in clockevents core
      clocksource: samsung_pwm_timer: Correct programming of clock events
      clocksource: samsung_pwm_timer: Use proper clockevents max_delta
      clocksource: samsung_pwm_timer: Add support for non-DT platforms
      clocksource: samsung_pwm_timer: Drop unused samsung_pwm struct
      clocksource: samsung_pwm_timer: Keep all driver data in a structure
      clocksource: samsung_pwm_timer: Make PWM spinlock global
      clocksource: samsung_pwm_timer: Let platforms select the driver
      Documentation: Add device tree bindings for Samsung PWM timers
      clocksource: add samsung pwm timer driver
      irqchip: exynos: look up irq using irq_find_mapping
      irqchip: exynos: pass irq_base from platform
      irqchip: exynos: localize irq lookup for ATAGS
      irqchip: exynos: allocate combiner_data dynamically
      irqchip: exynos: pass max combiner number to combiner_init
      ARM: exynos: add missing properties for combiner IRQs
      ...

commit 241a9871263f3114717c0ed416a1bd1d2415d1fb
Merge: 2254c36ddeb8 0682edaaa32c
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon May 6 23:49:09 2013 +0200

    Merge branch 'exynos/pwm-clocksource' into late/multiplatform
    
    This series from Tomasz Figa restores support for the pwm clocksource
    in Exynos, which was broken during the conversion of the platform
    to the common clk framework. The clocksource is only used in one
    board in the mainline kernel (universal_c210), and this makes it
    work for DT based probing as well as restoring the non-DT based
    case.
    
    * exynos/pwm-clocksource:
      ARM: dts: exynops4210: really add universal_c210 dts
      ARM: dts: exynos4210: Add basic dts file for universal_c210 board
      ARM: dts: exynos4: Add node for PWM device
      ARM: SAMSUNG: Do not register legacy timer interrupts on Exynos
      clocksource: samsung_pwm_timer: Work around rounding errors in clockevents core
      clocksource: samsung_pwm_timer: Correct programming of clock events
      clocksource: samsung_pwm_timer: Use proper clockevents max_delta
      clocksource: samsung_pwm_timer: Add support for non-DT platforms
      clocksource: samsung_pwm_timer: Drop unused samsung_pwm struct
      clocksource: samsung_pwm_timer: Keep all driver data in a structure
      clocksource: samsung_pwm_timer: Make PWM spinlock global
      clocksource: samsung_pwm_timer: Let platforms select the driver
      Documentation: Add device tree bindings for Samsung PWM timers
      clocksource: add samsung pwm timer driver
    
    Conflicts:
            arch/arm/boot/dts/Makefile
            arch/arm/mach-exynos/common.c
            drivers/clocksource/Kconfig
            drivers/clocksource/Makefile
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

commit ab86e974f04b1cd827a9c7c35273834ebcd9ab38
Merge: 8700c95adb03 6f7a05d7018d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Apr 30 08:15:40 2013 -0700

    Merge branch 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull core timer updates from Ingo Molnar:
     "The main changes in this cycle's merge are:
    
       - Implement shadow timekeeper to shorten in kernel reader side
         blocking, by Thomas Gleixner.
    
       - Posix timers enhancements by Pavel Emelyanov:
    
       - allocate timer ID per process, so that exact timer ID allocations
         can be re-created be checkpoint/restore code.
    
       - debuggability and tooling (/proc/PID/timers, etc.) improvements.
    
       - suspend/resume enhancements by Feng Tang: on certain new Intel Atom
         processors (Penwell and Cloverview), there is a feature that the
         TSC won't stop in S3 state, so the TSC value won't be reset to 0
         after resume.  This can be taken advantage of by the generic via
         the CLOCK_SOURCE_SUSPEND_NONSTOP flag: instead of using the RTC to
         recover/approximate sleep time, the main (and precise) clocksource
         can be used.
    
       - Fix /proc/timer_list for 4096 CPUs by Nathan Zimmer: on so many
         CPUs the file goes beyond 4MB of size and thus the current
         simplistic seqfile approach fails.  Convert /proc/timer_list to a
         proper seq_file with its own iterator.
    
       - Cleanups and refactorings of the core timekeeping code by John
         Stultz.
    
       - International Atomic Clock time is managed by the NTP code
         internally currently but not exposed externally.  Separate the TAI
         code out and add CLOCK_TAI support and TAI support to the hrtimer
         and posix-timer code, by John Stultz.
    
       - Add deep idle support enhacement to the broadcast clockevents core
         timer code, by Daniel Lezcano: add an opt-in CLOCK_EVT_FEAT_DYNIRQ
         clockevents feature (which will be utilized by future clockevents
         driver updates), which allows the use of IRQ affinities to avoid
         spurious wakeups of idle CPUs - the right CPU with an expiring
         timer will be woken.
    
       - Add new ARM bcm281xx clocksource driver, by Christian Daudt
    
       - ... various other fixes and cleanups"
    
    * 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (52 commits)
      clockevents: Set dummy handler on CPU_DEAD shutdown
      timekeeping: Update tk->cycle_last in resume
      posix-timers: Remove unused variable
      clockevents: Switch into oneshot mode even if broadcast registered late
      timer_list: Convert timer list to be a proper seq_file
      timer_list: Split timer_list_show_tickdevices
      posix-timers: Show sigevent info in proc file
      posix-timers: Introduce /proc/PID/timers file
      posix timers: Allocate timer id per process (v2)
      timekeeping: Make sure to notify hrtimers when TAI offset changes
      hrtimer: Fix ktime_add_ns() overflow on 32bit architectures
      hrtimer: Add expiry time overflow check in hrtimer_interrupt
      timekeeping: Shorten seq_count region
      timekeeping: Implement a shadow timekeeper
      timekeeping: Delay update of clock->cycle_last
      timekeeping: Store cycle_last value in timekeeper struct as well
      ntp: Remove ntp_lock, using the timekeeping locks to protect ntp state
      timekeeping: Simplify tai updating from do_adjtimex
      timekeeping: Hold timekeepering locks in do_adjtimex and hardpps
      timekeeping: Move ADJ_SETOFFSET to top level do_adjtimex()
      ...

commit 81d4f7bfdc9417e7d8fc1133c762daa4458eec5e
Author: Tomasz Figa <t.figa@samsung.com>
Date:   Tue Apr 23 17:46:30 2013 +0200

    clocksource: samsung_pwm_timer: Work around rounding errors in clockevents core
    
    Due to rounding errors in clockevents core (in conversions between ticks
    and nsecs), it might happen that the set_next_event callback gets called
    with cycles = 0, causing the code to incorrectly program the PWM timer.
    
    This patch modifies the callback to program the timer for 1 tick, if
    received tick count value is 0.
    
    Signed-off-by: Tomasz Figa <t.figa@samsung.com>
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Kukjin Kim <kgene.kim@samsung.com>
    Signed-off-by: Olof Johansson <olof@lixom.net>

commit e9b852b8a7bc0217a03afff07fad34093e087542
Author: Tomasz Figa <t.figa@samsung.com>
Date:   Tue Apr 23 17:46:28 2013 +0200

    clocksource: samsung_pwm_timer: Use proper clockevents max_delta
    
    This patch replaces hardcoded -1 argument passed to
    clockevents_config_and_register() with tcnt_max calculated based on
    variant data.
    
    This fixes invalid max delta configuration for 16-bit timers of s3c24xx.
    
    Signed-off-by: Tomasz Figa <t.figa@samsung.com>
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Kukjin Kim <kgene.kim@samsung.com>
    Signed-off-by: Olof Johansson <olof@lixom.net>

commit 6f7a05d7018de222e40ca003721037a530979974
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Apr 25 11:45:53 2013 +0200

    clockevents: Set dummy handler on CPU_DEAD shutdown
    
    Vitaliy reported that a per cpu HPET timer interrupt crashes the
    system during hibernation. What happens is that the per cpu HPET timer
    gets shut down when the nonboot cpus are stopped. When the nonboot
    cpus are onlined again the HPET code sets up the MSI interrupt which
    fires before the clock event device is registered. The event handler
    is still set to hrtimer_interrupt, which then crashes the machine due
    to highres mode not being active.
    
    See http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=700333
    
    There is no real good way to avoid that in the HPET code. The HPET
    code alrady has a mechanism to detect spurious interrupts when event
    handler == NULL for a similar reason.
    
    We can handle that in the clockevent/tick layer and replace the
    previous functional handler with a dummy handler like we do in
    tick_setup_new_device().
    
    The original clockevents code did this in clockevents_exchange_device(),
    but that got removed by commit 7c1e76897 (clockevents: prevent
    clockevent event_handler ending up handler_noop) which forgot to fix
    it up in tick_shutdown(). Same issue with the broadcast device.
    
    Reported-by: Vitaliy Fillipov <vitalif@yourcmc.ru>
    Cc: Ben Hutchings <ben@decadent.org.uk>
    Cc: stable@vger.kernel.org
    Cc: 700333@bugs.debian.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit c038c1c44179c80da6201f91ef354e48d5689617
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Wed Apr 17 10:26:06 2013 -0700

    clockevents: Switch into oneshot mode even if broadcast registered late
    
    tick_oneshot_notify() is used to notify a particular CPU to try
    to switch into oneshot mode after a oneshot capable tick device
    is registered and tick_clock_notify() is used to notify all CPUs
    to try to switch into oneshot mode after a high res clocksource
    is registered. There is one caveat; if the tick devices suffer
    from FEAT_C3_STOP we don't try to switch into oneshot mode unless
    we have a oneshot capable broadcast device already registered.
    
    If the broadcast device is registered after the tick devices that
    have FEAT_C3_STOP we'll never try to switch into oneshot mode
    again, causing us to be stuck in periodic mode forever. Avoid
    this scenario by calling tick_clock_notify() after we register
    the broadcast device so that we try to switch into oneshot mode
    on all CPUs one more time.
    
    [ tglx: Adopted to timers/core and added a comment ]
    
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Link: http://lkml.kernel.org/r/1366219566-29783-1-git-send-email-sboyd@codeaurora.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 7918c92ae9638eb8a6ec18e2b4a0de84557cccc8
Author: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
Date:   Tue Apr 16 15:18:00 2013 -0400

    xen/time: Fix kasprintf splat when allocating timer%d IRQ line.
    
    When we online the CPU, we get this splat:
    
    smpboot: Booting Node 0 Processor 1 APIC 0x2
    installing Xen timer for CPU 1
    BUG: sleeping function called from invalid context at /home/konrad/ssd/konrad/linux/mm/slab.c:3179
    in_atomic(): 1, irqs_disabled(): 0, pid: 0, name: swapper/1
    Pid: 0, comm: swapper/1 Not tainted 3.9.0-rc6upstream-00001-g3884fad #1
    Call Trace:
     [<ffffffff810c1fea>] __might_sleep+0xda/0x100
     [<ffffffff81194617>] __kmalloc_track_caller+0x1e7/0x2c0
     [<ffffffff81303758>] ? kasprintf+0x38/0x40
     [<ffffffff813036eb>] kvasprintf+0x5b/0x90
     [<ffffffff81303758>] kasprintf+0x38/0x40
     [<ffffffff81044510>] xen_setup_timer+0x30/0xb0
     [<ffffffff810445af>] xen_hvm_setup_cpu_clockevents+0x1f/0x30
     [<ffffffff81666d0a>] start_secondary+0x19c/0x1a8
    
    The solution to that is use kasprintf in the CPU hotplug path
    that 'online's the CPU. That is, do it in in xen_hvm_cpu_notify,
    and remove the call to in xen_hvm_setup_cpu_clockevents.
    
    Unfortunatly the later is not a good idea as the bootup path
    does not use xen_hvm_cpu_notify so we would end up never allocating
    timer%d interrupt lines when booting. As such add the check for
    atomic() to continue.
    
    CC: stable@vger.kernel.org
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>

commit 888b65b4bc5e7fcbbb967023300cd5d44dba1950
Author: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
Date:   Tue Apr 16 13:49:26 2013 -0400

    xen/smp: Fix leakage of timer interrupt line for every CPU online/offline.
    
    In the PVHVM path when we do CPU online/offline path we would
    leak the timer%d IRQ line everytime we do a offline event. The
    online path (xen_hvm_setup_cpu_clockevents via
    x86_cpuinit.setup_percpu_clockev) would allocate a new interrupt
    line for the timer%d.
    
    But we would still use the old interrupt line leading to:
    
    kernel BUG at /home/konrad/ssd/konrad/linux/kernel/hrtimer.c:1261!
    invalid opcode: 0000 [#1] SMP
    RIP: 0010:[<ffffffff810b9e21>]  [<ffffffff810b9e21>] hrtimer_interrupt+0x261/0x270
    .. snip..
     <IRQ>
     [<ffffffff810445ef>] xen_timer_interrupt+0x2f/0x1b0
     [<ffffffff81104825>] ? stop_machine_cpu_stop+0xb5/0xf0
     [<ffffffff8111434c>] handle_irq_event_percpu+0x7c/0x240
     [<ffffffff811175b9>] handle_percpu_irq+0x49/0x70
     [<ffffffff813a74a3>] __xen_evtchn_do_upcall+0x1c3/0x2f0
     [<ffffffff813a760a>] xen_evtchn_do_upcall+0x2a/0x40
     [<ffffffff8167c26d>] xen_hvm_callback_vector+0x6d/0x80
     <EOI>
     [<ffffffff81666d01>] ? start_secondary+0x193/0x1a8
     [<ffffffff81666cfd>] ? start_secondary+0x18f/0x1a8
    
    There is also the oddity (timer1) in the /proc/interrupts after
    offlining CPU1:
    
      64:       1121          0  xen-percpu-virq      timer0
      78:          0          0  xen-percpu-virq      timer1
      84:          0       2483  xen-percpu-virq      timer2
    
    This patch fixes it.
    
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    CC: stable@vger.kernel.org

commit 7161ab99e363e18e7a6e5abd6f01496f32fa033f
Author: Mark Rutland <mark.rutland@arm.com>
Date:   Thu Mar 7 15:09:24 2013 +0000

    clockevents: Don't allow dummy broadcast timers
    
    commit a7dc19b8652c862d5b7c4d2339bd3c428bd29c4a upstream.
    
    Currently tick_check_broadcast_device doesn't reject clock_event_devices
    with CLOCK_EVT_FEAT_DUMMY, and may select them in preference to real
    hardware if they have a higher rating value. In this situation, the
    dummy timer is responsible for broadcasting to itself, and the core
    clockevents code may attempt to call non-existent callbacks for
    programming the dummy, eventually leading to a panic.
    
    This patch makes tick_check_broadcast_device always reject dummy timers,
    preventing this problem.
    
    Signed-off-by: Mark Rutland <mark.rutland@arm.com>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: Jon Medhurst (Tixy) <tixy@linaro.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit 8f294b5a139ee4b75e890ad5b443c93d1e558a8b
Author: Prarit Bhargava <prarit@redhat.com>
Date:   Mon Apr 8 08:47:15 2013 -0400

    hrtimer: Add expiry time overflow check in hrtimer_interrupt
    
    The settimeofday01 test in the LTP testsuite effectively does
    
            gettimeofday(current time);
            settimeofday(Jan 1, 1970 + 100 seconds);
            settimeofday(current time);
    
    This test causes a stack trace to be displayed on the console during the
    setting of timeofday to Jan 1, 1970 + 100 seconds:
    
    [  131.066751] ------------[ cut here ]------------
    [  131.096448] WARNING: at kernel/time/clockevents.c:209 clockevents_program_event+0x135/0x140()
    [  131.104935] Hardware name: Dinar
    [  131.108150] Modules linked in: sg nfsv3 nfs_acl nfsv4 auth_rpcgss nfs dns_resolver fscache lockd sunrpc nf_conntrack_netbios_ns nf_conntrack_broadcast ipt_MASQUERADE ip6table_mangle ip6t_REJECT nf_conntrack_ipv6 nf_defrag_ipv6 iptable_nat nf_nat_ipv4 nf_nat iptable_mangle ipt_REJECT nf_conntrack_ipv4 nf_defrag_ipv4 xt_conntrack nf_conntrack ebtable_filter ebtables ip6table_filter ip6_tables iptable_filter ip_tables kvm_amd kvm sp5100_tco bnx2 i2c_piix4 crc32c_intel k10temp fam15h_power ghash_clmulni_intel amd64_edac_mod pcspkr serio_raw edac_mce_amd edac_core microcode xfs libcrc32c sr_mod sd_mod cdrom ata_generic crc_t10dif pata_acpi radeon i2c_algo_bit drm_kms_helper ttm drm ahci pata_atiixp libahci libata usb_storage i2c_core dm_mirror dm_region_hash dm_log dm_mod
    [  131.176784] Pid: 0, comm: swapper/28 Not tainted 3.8.0+ #6
    [  131.182248] Call Trace:
    [  131.184684]  <IRQ>  [<ffffffff810612af>] warn_slowpath_common+0x7f/0xc0
    [  131.191312]  [<ffffffff8106130a>] warn_slowpath_null+0x1a/0x20
    [  131.197131]  [<ffffffff810b9fd5>] clockevents_program_event+0x135/0x140
    [  131.203721]  [<ffffffff810bb584>] tick_program_event+0x24/0x30
    [  131.209534]  [<ffffffff81089ab1>] hrtimer_interrupt+0x131/0x230
    [  131.215437]  [<ffffffff814b9600>] ? cpufreq_p4_target+0x130/0x130
    [  131.221509]  [<ffffffff81619119>] smp_apic_timer_interrupt+0x69/0x99
    [  131.227839]  [<ffffffff8161805d>] apic_timer_interrupt+0x6d/0x80
    [  131.233816]  <EOI>  [<ffffffff81099745>] ? sched_clock_cpu+0xc5/0x120
    [  131.240267]  [<ffffffff814b9ff0>] ? cpuidle_wrap_enter+0x50/0xa0
    [  131.246252]  [<ffffffff814b9fe9>] ? cpuidle_wrap_enter+0x49/0xa0
    [  131.252238]  [<ffffffff814ba050>] cpuidle_enter_tk+0x10/0x20
    [  131.257877]  [<ffffffff814b9c89>] cpuidle_idle_call+0xa9/0x260
    [  131.263692]  [<ffffffff8101c42f>] cpu_idle+0xaf/0x120
    [  131.268727]  [<ffffffff815f8971>] start_secondary+0x255/0x257
    [  131.274449] ---[ end trace 1151a50552231615 ]---
    
    When we change the system time to a low value like this, the value of
    timekeeper->offs_real will be a negative value.
    
    It seems that the WARN occurs because an hrtimer has been started in the time
    between the releasing of the timekeeper lock and the IPI call (via a call to
    on_each_cpu) in clock_was_set() in the do_settimeofday() code.  The end result
    is that a REALTIME_CLOCK timer has been added with softexpires = expires =
    KTIME_MAX.  The hrtimer_interrupt() fires/is called and the loop at
    kernel/hrtimer.c:1289 is executed.  In this loop the code subtracts the
    clock base's offset (which was set to timekeeper->offs_real in
    do_settimeofday()) from the current hrtimer_cpu_base->expiry value (which
    was KTIME_MAX):
    
            KTIME_MAX - (a negative value) = overflow
    
    A simple check for an overflow can resolve this problem.  Using KTIME_MAX
    instead of the overflow value will result in the hrtimer function being run,
    and the reprogramming of the timer after that.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org
    Reviewed-by: Rik van Riel <riel@redhat.com>
    Signed-off-by: Prarit Bhargava <prarit@redhat.com>
    [jstultz: Tweaked commit subject]
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit dc2d3db8137fba0f62d7517e1bea8a47f69fcbc4
Merge: 8355ae69afca 7f585bbfc54f
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Apr 8 19:30:48 2013 +0200

    Merge tag 'omap-for-v3.10/timer-signed' of git://git.kernel.org/pub/scm/linux/kernel/git/tmlind/linux-omap into next/drivers
    
    From Tony Lindgren <tony@atomide.com>:
    
    Clean-up for omap2+ timers from Jon Hunter <jon-hunter@ti.com>:
    
    This series consists mainly of clean-ups for clockevents and
    clocksource timers on OMAP2+ devices. The most significant change
    in functionality comes from the 5th patch which is changing the
    selection of the clocksource timer for OMAP3 and AM335x devices
    when gptimers are used for clocksource.
    
    Note that this series depends on 7185684 (ARM: OMAP: use
    consistent error checking) in RMK's tree and 960cba6 (ARM:
    OMAP5: timer: Update the clocksource name as per clock data)
    in omap-for-v3.10/fixes-non-critical. So this branch is based
    on a merge of 7185684 and omap-for-v3.10/fixes-non-critical
    to avoid non-trivial merge conflicts.
    
    * tag 'omap-for-v3.10/timer-signed' of git://git.kernel.org/pub/scm/linux/kernel/git/tmlind/linux-omap:
      ARM: OMAP4+: Fix sparse warning in system timers
      ARM: OMAP2+: Store ID of system timers in timer structure
      ARM: OMAP3: Update clocksource timer selection
      ARM: OMAP2+: Simplify system timers definitions
      ARM: OMAP2+: Simplify system timer clock definitions
      ARM: OMAP2+: Remove hard-coded test on timer ID
      ARM: OMAP2+: Display correct system timer name
      ARM: OMAP2+: fix typo "CONFIG_BRIDGE_DVFS"
      ARM: OMAP1: remove "config MACH_OMAP_HTCWIZARD"
      ARM: OMAP: dpll: enable bypass clock only when attempting dpll bypass
      ARM: OMAP2+: powerdomain: avoid testing whether an unsigned char is less than 0
      ARM: OMAP2+: hwmod: Remove unused _HWMOD_WAKEUP_ENABLED flag
      ARM: OMAP2+: am335x: Change the wdt1 func clk src to per_32k clk
      ARM: OMAP2+: AM33xx: hwmod: Add missing sysc definition to wdt1 entry
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

commit 5f03dc2002f5dc85ce87e69caff7f28f17f5c9b2
Author: Christian Daudt <csd@broadcom.com>
Date:   Wed Mar 13 14:27:28 2013 -0700

    ARM: bcm281xx: Add timer driver (DT portion)
    
    This adds support for the Broadcom timer, used in the following SoCs:
    BCM11130, BCM11140, BCM11351, BCM28145, BCM28155
    
    Updates from V6:
    - Split DT portion into a separate patch
    
    Updates from V5:
    - Rebase to latest arm-soc/for-next
    
    Updates from V4:
    - Switch code to use CLOCKSOURCE_OF_DECLARE
    
    Updates from V3:
    - Migrate to 3.9 timer framework updates
    
    Updates from V2:
    - prepend static fns + fields with kona_
    
    Updates from V1:
    - Rename bcm_timer.c to bcm_kona_timer.c
    - Pull .h into bcm_kona_timer.c
    - Make timers static
    - Clean up comment block
    - Switched to using clockevents_config_and_register
    - Added an error to the get_timer loop if it repeats too much
    - Added to Documentation/devicetree/bindings/arm/bcm/bcm,kona-timer.txt
    - Added missing readl to timer_disable_and_clear
    
    Note: bcm,kona-timer was kept as the 'compatible' field to make it
    specific enough for when there are multiple bcm timers (bcm,timer is
    too generic).
    
    Signed-off-by: Christian Daudt <csd@broadcom.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: John Stultz <john.stultz@linaro.org>
    Reviewed-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Olof Johansson <olof@lixom.net>

commit 2eb03937df3ebc822dab413bd69533dcd66afd48
Author: Jon Hunter <jon-hunter@ti.com>
Date:   Mon Jan 28 17:53:57 2013 -0600

    ARM: OMAP3: Update clocksource timer selection
    
    When booting with device-tree for OMAP3 and AM335x devices and a gptimer
    is used as the clocksource (which is always the case for AM335x), a
    gptimer located in a power domain that is not always-on is selected.
    Ideally we should use a gptimer for clocksource that is located in a
    power domain that is always on (such as the wake-up domain) so that time
    can be maintained during a kernel suspend without keeping on additional
    power domains unnecessarily.
    
    In order to fix this so that we can select a gptimer located in a power
    domain that is always-on, the following changes were made ...
    1. Currently, only when selecting a gptimer to use for a clockevent
       timer, do we pass a timer property that can be used to select a
       specific gptimer. Change this so that we can pass a property when
       selecting a gptimer to use for a clocksource timer too.
    2. Currently, when selecting either a gptimer to use for a clockevent
       timer or a clocksource timer and no timer property is passed, then
       the first available timer is selected regardless of the properties
       it has. Change this so that if no properties are passed, then a timer
       that does not have additional features (such as always-on, dsp-irq,
       pwm, and secure) is selected.
    
    For OMAP3 and AM335x devices that use a gptimer for clocksource, change
    the selection of the gptimer so that by default the gptimer located in
    the always-on power domain is used for clocksource instead of
    clockevents.
    
    Please note that using a gptimer for both clocksource and clockevents
    can have a system power impact during idle. The reason being is that
    OMAP and AMxxx devices typically only have one gptimer in a power domain
    that is always-on. Therefore when the kernel is idle both the clocksource
    and clockevent timers will be active and this will keep additional power
    domains on. During kernel suspend, only the clocksource timer is active
    and therefore, it is better to use a gptimer in a power domain that is
    always-on for clocksource.
    
    Signed-off-by: Jon Hunter <jon-hunter@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Acked-by: Igor Grinberg <grinberg@compulab.co.il>

commit e95ea43a90c32ccb47a601c70203ff60c0c1f345
Author: Jon Hunter <jon-hunter@ti.com>
Date:   Tue Jan 29 13:55:25 2013 -0600

    ARM: OMAP2+: Display correct system timer name
    
    Currently on boot, when displaying the name of the gptimer used for
    clockevents and clocksource timers, the timer ID is shown. However,
    when booting with device-tree, the timer ID is not used to select a
    gptimer but a timer property. Hence, it is possible that the timer
    selected when booting with device-tree does not match the ID shown.
    Therefore, instead display the HWMOD name of the gptimer and use
    the HWMOD name as the name of clockevent and clocksource timer (if a
    gptimer is used).
    
    Signed-off-by: Jon Hunter <jon-hunter@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>

commit 4dbad816febb6cb7340e36af4f5c0dc86e55a2ca
Author: Daniel Lezcano <daniel.lezcano@linaro.org>
Date:   Wed Mar 27 10:22:09 2013 +0000

    timer: move enum definition out of ifdef section
    
    The next patch will setup automatically the broadcast timer for
    the different cpuidle driver when one idle state stops its timer.
    This will be part of the generic code.
    
    But some ARM boards, like s3c64xx, uses cpuidle but without the
    CONFIG_GENERIC_CLOCKEVENTS_BUILD set. Hence the cpuidle framework
    will be compiled with the code supposed to be generic, that is
    with clockevents_notify and the different enum.
    
    Also the function clockevents_notify is a noop macro, this is fine
    except the usual code is:
    
            int cpu = smp_processor_id();
            clockevents_notify(CLOCK_EVT_NOTIFY_BROADCAST_ON, &cpu);
    
    and that raises a warning for the variable cpu which is not used.
    
    Move the clock_event_nofitiers enum definition out of the
    CONFIG_GENERIC_CLOCKEVENTS_BUILD section to prevent a compilation
    error when these are used in the code.
    
    Change the clockevents_notify macro to a static inline noop function
    to prevent a compilation warning.
    
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit b60e6a0eb0273132cbb60a9806abf5f47a4aee1c
Author: Daniel Lezcano <daniel.lezcano@linaro.org>
Date:   Thu Mar 21 12:21:31 2013 +0000

    cpuidle : handle clockevent notify from the cpuidle framework
    
    When a cpu enters a deep idle state, the local timers are stopped and
    the time framework falls back to the timer device used as a broadcast
    timer.
    
    The different cpuidle drivers are calling clockevents_notify ENTER/EXIT
    when the idle state stops the local timer.
    
    Add a new flag CPUIDLE_FLAG_TIMER_STOP which can be set by the cpuidle
    drivers. If the flag is set, the cpuidle core code takes care of the
    notification on behalf of the driver to avoid pointless code duplication.
    
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 66fe4de752ccbab09d3e30d2b551b92f475e8782
Author: Mark Rutland <mark.rutland@arm.com>
Date:   Thu Mar 7 15:09:24 2013 +0000

    clockevents: Don't allow dummy broadcast timers
    
    commit a7dc19b8652c862d5b7c4d2339bd3c428bd29c4a upstream.
    
    Currently tick_check_broadcast_device doesn't reject clock_event_devices
    with CLOCK_EVT_FEAT_DUMMY, and may select them in preference to real
    hardware if they have a higher rating value. In this situation, the
    dummy timer is responsible for broadcasting to itself, and the core
    clockevents code may attempt to call non-existent callbacks for
    programming the dummy, eventually leading to a panic.
    
    This patch makes tick_check_broadcast_device always reject dummy timers,
    preventing this problem.
    
    Signed-off-by: Mark Rutland <mark.rutland@arm.com>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: Jon Medhurst (Tixy) <tixy@linaro.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 8d96fcec68c30196fca01a75a911835c7b89a50d
Author: Mark Rutland <mark.rutland@arm.com>
Date:   Thu Mar 7 15:09:24 2013 +0000

    clockevents: Don't allow dummy broadcast timers
    
    commit a7dc19b8652c862d5b7c4d2339bd3c428bd29c4a upstream.
    
    Currently tick_check_broadcast_device doesn't reject clock_event_devices
    with CLOCK_EVT_FEAT_DUMMY, and may select them in preference to real
    hardware if they have a higher rating value. In this situation, the
    dummy timer is responsible for broadcasting to itself, and the core
    clockevents code may attempt to call non-existent callbacks for
    programming the dummy, eventually leading to a panic.
    
    This patch makes tick_check_broadcast_device always reject dummy timers,
    preventing this problem.
    
    Signed-off-by: Mark Rutland <mark.rutland@arm.com>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: Jon Medhurst (Tixy) <tixy@linaro.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 611f2aaf1f4de0ab50d0a3dabfb1759d13f65cf9
Author: Mark Rutland <mark.rutland@arm.com>
Date:   Thu Mar 7 15:09:24 2013 +0000

    clockevents: Don't allow dummy broadcast timers
    
    commit a7dc19b8652c862d5b7c4d2339bd3c428bd29c4a upstream.
    
    Currently tick_check_broadcast_device doesn't reject clock_event_devices
    with CLOCK_EVT_FEAT_DUMMY, and may select them in preference to real
    hardware if they have a higher rating value. In this situation, the
    dummy timer is responsible for broadcasting to itself, and the core
    clockevents code may attempt to call non-existent callbacks for
    programming the dummy, eventually leading to a panic.
    
    This patch makes tick_check_broadcast_device always reject dummy timers,
    preventing this problem.
    
    Signed-off-by: Mark Rutland <mark.rutland@arm.com>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: Jon Medhurst (Tixy) <tixy@linaro.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 8011657b9e63cb2e914b9a0f75233b910c1854cb
Author: Christian Daudt <csd@broadcom.com>
Date:   Wed Mar 13 14:27:27 2013 -0700

    ARM: bcm281xx: Add timer driver (driver portion)
    
    This adds support for the Broadcom timer, used in the following SoCs:
    BCM11130, BCM11140, BCM11351, BCM28145, BCM28155
    
    Updates from V6:
    - Split DT portion into a separate patch
    
    Updates from V5:
    - Rebase to latest arm-soc/for-next
    
    Updates from V4:
    - Switch code to use CLOCKSOURCE_OF_DECLARE
    
    Updates from V3:
    - Migrate to 3.9 timer framework updates
    
    Updates from V2:
    - prepend static fns + fields with kona_
    
    Updates from V1:
    - Rename bcm_timer.c to bcm_kona_timer.c
    - Pull .h into bcm_kona_timer.c
    - Make timers static
    - Clean up comment block
    - Switched to using clockevents_config_and_register
    - Added an error to the get_timer loop if it repeats too much
    - Added to Documentation/devicetree/bindings/arm/bcm/bcm,kona-timer.txt
    - Added missing readl to timer_disable_and_clear
    
    Note: bcm,kona-timer was kept as the 'compatible' field to make it
    specific enough for when there are multiple bcm timers (bcm,timer is
    too generic).
    
    Signed-off-by: Christian Daudt <csd@broadcom.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: John Stultz <john.stultz@linaro.org>
    Reviewed-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit a12183c62717ac4579319189a00f5883a18dff08
Merge: 53b680924800 a7dc19b8652c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Mar 25 18:03:34 2013 -0700

    Merge branch 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer fix from Thomas Gleixner:
     "A single bugfix which prevents that a non functional timer device is
      selected to provide the fallback device, which is supposed to serve
      timer interrupts on behalf of non functional devices ..."
    
    * 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      clockevents: Don't allow dummy broadcast timers

commit 19919226c3f20e6bf5de3df96432ce80ffd63ff2
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Mar 22 10:48:33 2013 +0100

    clockevents: Add missing tick_check_broadcast_expired() for CLOCKEVENTS=n
    
    Fengs build robot reports:
    
    arch/arm/kernel/process.c: In function 'cpu_idle':
    arch/arm/kernel/process.c:211:4: error: implicit declaration of function
    'tick_check_broadcast_expired' [-Werror=implicit-function-declaration]
    
    Add the missing inline function for non clockevent builds
    
    Reported-by: Wu Fengguang <fengguang.wu@intel.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 6210d421c20f12ef4e8c9826973478beb104114d
Merge: a937536b868b 2c36af0e559c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Mar 18 08:11:53 2013 -0700

    Merge branch 'fixes' of git://git.linaro.org/people/rmk/linux-arm
    
    Pull ARM fixes from Russell King:
     "Just three fixes this time - a fix for a fix for our memset function,
      fixing the dummy clockevent so that it doesn't interfere with real
      hardware clockevents, and fixing a build error for Tegra."
    
    * 'fixes' of git://git.linaro.org/people/rmk/linux-arm:
      ARM: 7675/1: amba: tegra-ahb: Fix build error w/ PM_SLEEP w/o PM_RUNTIME
      ARM: 7674/1: smp: Avoid dummy clockevent being preferred over real hardware clock-event
      ARM: 7670/1: fix the memset fix

commit a7dc19b8652c862d5b7c4d2339bd3c428bd29c4a
Author: Mark Rutland <mark.rutland@arm.com>
Date:   Thu Mar 7 15:09:24 2013 +0000

    clockevents: Don't allow dummy broadcast timers
    
    Currently tick_check_broadcast_device doesn't reject clock_event_devices
    with CLOCK_EVT_FEAT_DUMMY, and may select them in preference to real
    hardware if they have a higher rating value. In this situation, the
    dummy timer is responsible for broadcasting to itself, and the core
    clockevents code may attempt to call non-existent callbacks for
    programming the dummy, eventually leading to a panic.
    
    This patch makes tick_check_broadcast_device always reject dummy timers,
    preventing this problem.
    
    Signed-off-by: Mark Rutland <mark.rutland@arm.com>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: Jon Medhurst (Tixy) <tixy@linaro.org>
    Cc: stable@vger.kernel.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit ad2b13536ace08dfcca4cf86b75a5d06efe06373
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Mar 5 15:14:05 2013 +0100

    tick: Call tick_init late
    
    To convert the clockevents code to cpumask_var_t we need to move the
    init call after the allocator setup.
    
    Clockevents are earliest registered from time_init() as they need
    interrupts being set up, so this is safe.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/20130306111537.304379448@linutronix.de
    Cc: Rusty Russell <rusty@rustcorp.com.au>

commit 266d7ad7f4fe2f44b91561f5b812115c1b3018ab
Merge: bcbd818c069b 36dfbbf136db
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Feb 19 19:05:45 2013 -0800

    Merge branch 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer changes from Ingo Molnar:
     "Main changes:
    
       - ntp: Add CONFIG_RTC_SYSTOHC: a generic RTC driver facility
         complementing the existing CONFIG_RTC_HCTOSYS, which uses NTP to
         keep the hardware clock updated.
    
       - posix-timers: Fix clock_adjtime to always return timex data on
         success.  This is changing the ABI, but no breakage was expected
         and found - caution is warranted nevertheless.
    
       - platform persistent clock improvements/cleanups.
    
       - clockevents: refactor timer broadcast handling to be more generic
         and less duplicated with matching architecture code (mostly ARM
         motivated.)
    
       - various fixes and cleanups"
    
    * 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      timers/x86/hpet: Use HPET_COUNTER to specify the hpet counter in vread_hpet()
      posix-cpu-timers: Fix nanosleep task_struct leak
      clockevents: Fix generic broadcast for FEAT_C3STOP
      time, Fix setting of hardware clock in NTP code
      hrtimer: Prevent hrtimer_enqueue_reprogram race
      clockevents: Add generic timer broadcast function
      clockevents: Add generic timer broadcast receiver
      timekeeping: Switch HAS_PERSISTENT_CLOCK to ALWAYS_USE_PERSISTENT_CLOCK
      x86/time/rtc: Don't print extended CMOS year when reading RTC
      x86: Select HAS_PERSISTENT_CLOCK on x86
      timekeeping: Add CONFIG_HAS_PERSISTENT_CLOCK option
      rtc: Skip the suspend/resume handling if persistent clock exist
      timekeeping: Add persistent_clock_exist flag
      posix-timers: Fix clock_adjtime to always return timex data on success
      Round the calculated scale factor in set_cyc2ns_scale()
      NTP: Add a CONFIG_RTC_SYSTOHC configuration
      MAINTAINERS: Update John Stultz's email
      time: create __getnstimeofday for WARNless calls

commit 9664ffe6a16676fa4d6a238ad3d9bb6cc24825a1
Author: Mark Rutland <mark.rutland@arm.com>
Date:   Tue Feb 12 18:22:14 2013 +0100

    ARM: 7651/1: remove unused smp_timer_broadcast #define
    
    The assignment of clock_event_device::broadcast can be done by timer
    core as of 12ad100046: "clockevents: Add generic timer broadcast
    function", and the arm code moved over to this as of 3d06770eef: "arm:
    Add generic timer broadcast support", but left a dangling #define when
    !CONFIG_GENERIC_TIMER_BROADCAST.
    
    This patch removes the now unused #define.
    
    Signed-off-by: Mark Rutland <mark.rutland@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

commit 5d1d9a29bc0772abee765f09513779a2ef0ebbfd
Author: Mark Rutland <mark.rutland@arm.com>
Date:   Fri Feb 8 15:24:07 2013 +0000

    clockevents: Fix generic broadcast for FEAT_C3STOP
    
    Commit 12ad100046: "clockevents: Add generic timer broadcast function"
    made tick_device_uses_broadcast set up the generic broadcast function
    for dummy devices (where !tick_device_is_functional(dev)), but neglected
    to set up the broadcast function for devices that stop in low power
    states (with the CLOCK_EVT_FEAT_C3STOP flag).
    
    When these devices enter low power states they will not have the generic
    broadcast function assigned, and will bring down the system when an
    attempt is made to broadcast to them.
    
    This patch ensures that the broadcast function is also assigned for
    devices which require broadcast in low power states.
    
    Reported-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Mark Rutland <mark.rutland@arm.com>
    Tested-by: Stephen Warren <swarren@nvidia.com>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: nico@linaro.org
    Cc: Marc.Zyngier@arm.com
    Cc: Will.Deacon@arm.com
    Cc: santosh.shilimkar@ti.com
    Cc: john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 3ddc0e1a7fd2fc222a6c87654af1cf059acdd1ec
Merge: 655e194cfee8 5b91ab0abc95
Author: Olof Johansson <olof@lixom.net>
Date:   Mon Feb 11 09:03:05 2013 -0800

    Merge branch 'for-rmk/broadcast' of git://git.kernel.org/pub/scm/linux/kernel/git/will/linux into next/virt
    
    * 'for-rmk/broadcast' of git://git.kernel.org/pub/scm/linux/kernel/git/will/linux:
      arm: Add generic timer broadcast support
      arm: Use generic timer broadcast receiver
      clockevents: Add generic timer broadcast function
      clockevents: Add generic timer broadcast receiver

commit 93beec7f7bba67a025f4038ebfadaa8d14c9042e
Author: Mukund Jampala <jbmukund@gmail.com>
Date:   Sun Dec 16 19:25:58 2012 +0100

    netfilter: ip[6]t_REJECT: fix wrong transport header pointer in TCP reset
    
    commit c6f408996c625cb950cad024f90e50519f94713c upstream.
    
    The problem occurs when iptables constructs the tcp reset packet.
    It doesn't initialize the pointer to the tcp header within the skb.
    When the skb is passed to the ixgbe driver for transmit, the ixgbe
    driver attempts to access the tcp header and crashes.
    Currently, other drivers (such as our 1G e1000e or igb drivers) don't
    access the tcp header on transmit unless the TSO option is turned on.
    
    <1>BUG: unable to handle kernel NULL pointer dereference at 0000000d
    <1>IP: [<d081621c>] ixgbe_xmit_frame_ring+0x8cc/0x2260 [ixgbe]
    <4>*pdpt = 0000000085e5d001 *pde = 0000000000000000
    <0>Oops: 0000 [#1] SMP
    [...]
    <4>Pid: 0, comm: swapper Tainted: P            2.6.35.12 #1 Greencity/Thurley
    <4>EIP: 0060:[<d081621c>] EFLAGS: 00010246 CPU: 16
    <4>EIP is at ixgbe_xmit_frame_ring+0x8cc/0x2260 [ixgbe]
    <4>EAX: c7628820 EBX: 00000007 ECX: 00000000 EDX: 00000000
    <4>ESI: 00000008 EDI: c6882180 EBP: dfc6b000 ESP: ced95c48
    <4> DS: 007b ES: 007b FS: 00d8 GS: 0000 SS: 0068
    <0>Process swapper (pid: 0, ti=ced94000 task=ced73bd0 task.ti=ced94000)
    <0>Stack:
    <4> cbec7418 c779e0d8 c77cc888 c77cc8a8 0903010a 00000000 c77c0008 00000002
    <4><0> cd4997c0 00000010 dfc6b000 00000000 d0d176c9 c77cc8d8 c6882180 cbec7318
    <4><0> 00000004 00000004 cbec7230 cbec7110 00000000 cbec70c0 c779e000 00000002
    <0>Call Trace:
    <4> [<d0d176c9>] ? 0xd0d176c9
    <4> [<d0d18a4d>] ? 0xd0d18a4d
    <4> [<411e243e>] ? dev_hard_start_xmit+0x218/0x2d7
    <4> [<411f03d7>] ? sch_direct_xmit+0x4b/0x114
    <4> [<411f056a>] ? __qdisc_run+0xca/0xe0
    <4> [<411e28b0>] ? dev_queue_xmit+0x2d1/0x3d0
    <4> [<411e8120>] ? neigh_resolve_output+0x1c5/0x20f
    <4> [<411e94a1>] ? neigh_update+0x29c/0x330
    <4> [<4121cf29>] ? arp_process+0x49c/0x4cd
    <4> [<411f80c9>] ? nf_hook_slow+0x3f/0xac
    <4> [<4121ca8d>] ? arp_process+0x0/0x4cd
    <4> [<4121ca8d>] ? arp_process+0x0/0x4cd
    <4> [<4121c6d5>] ? T.901+0x38/0x3b
    <4> [<4121c918>] ? arp_rcv+0xa3/0xb4
    <4> [<4121ca8d>] ? arp_process+0x0/0x4cd
    <4> [<411e1173>] ? __netif_receive_skb+0x32b/0x346
    <4> [<411e19e1>] ? netif_receive_skb+0x5a/0x5f
    <4> [<411e1ea9>] ? napi_skb_finish+0x1b/0x30
    <4> [<d0816eb4>] ? ixgbe_xmit_frame_ring+0x1564/0x2260 [ixgbe]
    <4> [<41013468>] ? lapic_next_event+0x13/0x16
    <4> [<410429b2>] ? clockevents_program_event+0xd2/0xe4
    <4> [<411e1b03>] ? net_rx_action+0x55/0x127
    <4> [<4102da1a>] ? __do_softirq+0x77/0xeb
    <4> [<4102dab1>] ? do_softirq+0x23/0x27
    <4> [<41003a67>] ? do_IRQ+0x7d/0x8e
    <4> [<41002a69>] ? common_interrupt+0x29/0x30
    <4> [<41007bcf>] ? mwait_idle+0x48/0x4d
    <4> [<4100193b>] ? cpu_idle+0x37/0x4c
    <0>Code: df 09 d7 0f 94 c2 0f b6 d2 e9 e7 fb ff ff 31 db 31 c0 e9 38
    ff ff ff 80 78 06 06 0f 85 3e fb ff ff 8b 7c 24 38 8b 8f b8 00 00 00
    <0f> b6 51 0d f6 c2 01 0f 85 27 fb ff ff 80 e2 02 75 0d 8b 6c 24
    <0>EIP: [<d081621c>] ixgbe_xmit_frame_ring+0x8cc/0x2260 [ixgbe] SS:ESP
    
    Signed-off-by: Mukund Jampala <jbmukund@gmail.com>
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit e2c501190c7d4bf9d7febb9e1f1094cbde59ed89
Author: Mark Rutland <mark.rutland@arm.com>
Date:   Tue Oct 30 11:17:01 2012 +0000

    arm: Use generic timer broadcast receiver
    
    Currently, the ARM backend must maintain a redundant list of timers for
    the purpose of centralising timer broadcast functionality. This prevents
    sharing timer drivers across architectures.
    
    This patch moves the pain of dealing with timer broadcasts to the core
    clockevents tick broadcast code, which already maintains its own list
    of timers.
    
    Signed-off-by: Mark Rutland <mark.rutland@arm.com>
    Reviewed-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Tested-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Reviewed-by: Stephen Boyd <sboyd@codeaurora.org>

commit 12ad10004645d38356b14d1fbba379c523a61916
Author: Mark Rutland <mark.rutland@arm.com>
Date:   Mon Jan 14 17:05:22 2013 +0000

    clockevents: Add generic timer broadcast function
    
    Currently, the timer broadcast mechanism is defined by a function
    pointer on struct clock_event_device. As the fundamental mechanism for
    broadcast is architecture-specific, this means that clock_event_device
    drivers cannot be shared across multiple architectures.
    
    This patch adds an (optional) architecture-specific function for timer
    tick broadcast, allowing drivers which may require broadcast
    functionality to be shared across multiple architectures.
    
    Signed-off-by: Mark Rutland <mark.rutland@arm.com>
    Reviewed-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: nico@linaro.org
    Cc: Will.Deacon@arm.com
    Cc: Marc.Zyngier@arm.com
    Cc: john.stultz@linaro.org
    Link: http://lkml.kernel.org/r/1358183124-28461-3-git-send-email-mark.rutland@arm.com
    Tested-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Reviewed-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 12572dbb53638c6e454ef831c8fee7de3df24389
Author: Mark Rutland <mark.rutland@arm.com>
Date:   Mon Jan 14 17:05:21 2013 +0000

    clockevents: Add generic timer broadcast receiver
    
    Currently the broadcast mechanism used for timers is abstracted by a
    function pointer on struct clock_event_device. As the fundamental
    mechanism for broadcast is architecture-specific, this ties each
    clock_event_device driver to a single architecture, even where the
    driver is otherwise generic.
    
    This patch adds a standard path for the receipt of timer broadcasts, so
    drivers and/or architecture backends need not manage redundant lists of
    timers for the purpose of routing broadcast timer ticks.
    
    [tglx: Made the implementation depend on the config switch as well ]
    
    Signed-off-by: Mark Rutland <mark.rutland@arm.com>
    Reviewed-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: nico@linaro.org
    Cc: Will.Deacon@arm.com
    Cc: Marc.Zyngier@arm.com
    Cc: john.stultz@linaro.org
    Link: http://lkml.kernel.org/r/1358183124-28461-2-git-send-email-mark.rutland@arm.com
    Tested-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Reviewed-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 7bcdd8d5e31db4f49ae52580e86723c376ee0999
Merge: 96e61b8e34ea f8060f5446b1
Author: Olof Johansson <olof@lixom.net>
Date:   Mon Jan 28 13:36:23 2013 -0800

    Merge branch 'depends/cleanup' into next/drivers
    
    * depends/cleanup: (375 commits)
      ARM: at91: fix board-rm9200-dt after sys_timer conversion
      clocksource: use clockevents_config_and_register() where possible
      ARM: use clockevents_config_and_register() where possible
      clockevents: export clockevents_config_and_register for module use
      timer: vt8500: Move timer code to drivers/clocksource
      irqchip: Move ARM vic.h to include/linux/irqchip/arm-vic.h
      ARM: picoxcell: use common irqchip_init function
      ARM: spear: use common irqchip_init function
      irqchip: Move ARM VIC to drivers/irqchip
      ARM: samsung: remove unused tick.h
      ARM: remove unneeded vic.h includes
      ARM: remove mach .handle_irq for VIC users
      ARM: VIC: set handle_arch_irq in VIC initialization
      ARM: VIC: shrink down vic.h
      irqchip: Move ARM gic.h to include/linux/irqchip/arm-gic.h
      ARM: use common irqchip_init for GIC init
      irqchip: Move ARM GIC to drivers/irqchip
      ARM: remove mach .handle_irq for GIC users
      ARM: GIC: set handle_arch_irq in GIC initialization
      ARM: GIC: remove direct use of gic_raise_softirq
      ...

commit a32f7d1ad3744914273c6907204c2ab3b5d496a0
Merge: 6b9e50c463ef 68d6f84ba0c4
Author: Mauro Carvalho Chehab <mchehab@kernel.org>
Date:   Thu Jan 24 18:49:18 2013 -0200

    Merge branch 'v4l_for_linus' into staging/for_v3.9
    
    * v4l_for_linus: (464 commits)
      [media] uvcvideo: Set error_idx properly for S_EXT_CTRLS failures
      [media] uvcvideo: Cleanup leftovers of partial revert
      [media] uvcvideo: Return -EACCES when trying to set a read-only control
      Linux 3.8-rc3
      mm: reinstante dropped pmd_trans_splitting() check
      cred: Remove tgcred pointer from struct cred
      drm/ttm: fix fence locking in ttm_buffer_object_transfer
      ARM: clps711x: Fix bad merge of clockevents setup
      ARM: highbank: save and restore L2 cache and GIC on suspend
      ARM: highbank: add a power request clear
      ARM: highbank: fix secondary boot and hotplug
      ARM: highbank: fix typos with hignbank in power request functions
      ARM: dts: fix highbank cpu mpidr values
      ARM: dts: add device_type prop to cpu nodes on Calxeda platforms
      drm/prime: drop reference on imported dma-buf come from gem
      xen/netfront: improve truesize tracking
      ARM: mx5: Fix MX53 flexcan2 clock
      ARM: OMAP2+: am33xx-hwmod: Fix wrongly terminated am33xx_usbss_mpu_irqs array
      sctp: fix Kconfig bug in default cookie hmac selection
      EDAC: Cleanup device deregistering path
      ...
    
    Conflicts:
            drivers/media/pci/dm1105/dm1105.c
            drivers/media/platform/soc_camera/mx2_camera.c

commit 8d84981e395850aab31c3f2ca7e2738e03f671d7
Merge: 00c82d644056 77cc982f6a3b
Author: Olof Johansson <olof@lixom.net>
Date:   Mon Jan 14 10:20:02 2013 -0800

    Merge branch 'clocksource/cleanup' into next/cleanup
    
    Clockevent cleanup series from Shawn Guo.
    
    Resolved move/change conflict in mach-pxa/time.c due to the sys_timer
    cleanup.
    
    * clocksource/cleanup:
      clocksource: use clockevents_config_and_register() where possible
      ARM: use clockevents_config_and_register() where possible
      clockevents: export clockevents_config_and_register for module use
      + sync to Linux 3.8-rc3
    
    Signed-off-by: Olof Johansson <olof@lixom.net>
    
    Conflicts:
            arch/arm/mach-pxa/time.c

commit 77cc982f6a3b33a5aa058ad3b20cda8866db2948
Author: Shawn Guo <shawn.guo@linaro.org>
Date:   Sat Jan 12 11:50:06 2013 +0000

    clocksource: use clockevents_config_and_register() where possible
    
    The clockevent core is able to figure out the best mult and shift,
    calculate min_delta_ns and max_delta_ns, with the necessary info passed
    into clockevents_config_and_register().  Use this combined configure
    and register function where possible to make the codes less error prone
    and gain some positive diff stat.
    
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>
    Cc: Andres Salomon <dilinger@queued.net>
    Cc: Nicolas Ferre <nicolas.ferre@atmel.com>
    Acked-by: Maxime Ripard <maxime.ripard@free-electrons.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Olof Johansson <olof@lixom.net>

commit 838a2ae80a6ab52139fb1bf0a93ea8c5eff94488
Author: Shawn Guo <shawn.guo@linaro.org>
Date:   Sat Jan 12 11:50:05 2013 +0000

    ARM: use clockevents_config_and_register() where possible
    
    The clockevent core is able to figure out the best mult and shift,
    calculate min_delta_ns and max_delta_ns, with the necessary info passed
    into clockevents_config_and_register().  Use this combined configure
    and register function where possible to make the codes less error prone
    and gain some positive diff stat.
    
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>
    Cc: Nicolas Ferre <nicolas.ferre@atmel.com>
    Reviewed-by: Anton Vorontsov <cbouatmailru@gmail.com>
    Acked-by: Kukjin Kim <kgene.kim@samsung.com>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Sascha Hauer <s.hauer@pengutronix.de>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Tested-by: Roland Stigge <stigge@antcom.de>
    Acked-by: Eric Miao <eric.y.miao@gmail.com>
    Cc: Haojian Zhuang <haojian.zhuang@gmail.com>
    Cc: David Brown <davidb@codeaurora.org>
    Tested-by: Tony Lindgren <tony@atomide.com>
    Acked-by: Barry Song <baohua.song@csr.com>
    Tested-by: Stephen Warren <swarren@nvidia.com>
    Acked-by: Tony Prisk <linux@prisktech.co.nz>
    Cc: Lennert Buytenhek <buytenh@wantstofly.org>
    Cc: Wan ZongShun <mcuos.com@gmail.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Jason Cooper <jason@lakedaemon.net>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Olof Johansson <olof@lixom.net>

commit c35ef95c273c06471818f9245a05ac5a6e3ffa34
Author: Shawn Guo <shawn.guo@linaro.org>
Date:   Sat Jan 12 11:50:04 2013 +0000

    clockevents: export clockevents_config_and_register for module use
    
    clockevents_config_and_register is a handy helper for clockevent
    drivers, some of which might support module build, so export the symbol.
    
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Olof Johansson <olof@lixom.net>

commit 734d1ece37fbf3d2ddfc71bc6c69e0fe35f02542
Merge: 216c82c6aba6 9931faca02c6
Author: Mauro Carvalho Chehab <mchehab@kernel.org>
Date:   Fri Jan 11 13:28:19 2013 -0200

    Merge tag 'v3.8-rc3' into v4l_for_linus
    
    Linux 3.8-rc3
    
    * tag 'v3.8-rc3': (11110 commits)
      Linux 3.8-rc3
      mm: reinstante dropped pmd_trans_splitting() check
      cred: Remove tgcred pointer from struct cred
      drm/ttm: fix fence locking in ttm_buffer_object_transfer
      ARM: clps711x: Fix bad merge of clockevents setup
      ARM: highbank: save and restore L2 cache and GIC on suspend
      ARM: highbank: add a power request clear
      ARM: highbank: fix secondary boot and hotplug
      ARM: highbank: fix typos with hignbank in power request functions
      ARM: dts: fix highbank cpu mpidr values
      ARM: dts: add device_type prop to cpu nodes on Calxeda platforms
      drm/prime: drop reference on imported dma-buf come from gem
      xen/netfront: improve truesize tracking
      ARM: mx5: Fix MX53 flexcan2 clock
      ARM: OMAP2+: am33xx-hwmod: Fix wrongly terminated am33xx_usbss_mpu_irqs array
      sctp: fix Kconfig bug in default cookie hmac selection
      EDAC: Cleanup device deregistering path
      EDAC: Fix EDAC Kconfig menu
      EDAC: Fix kernel panic on module unloading
      ALSA: hda - add mute LED for HP Pavilion 17 (Realtek codec)
      ...

commit 974b33586b4bbbdab33c666417f9ba9ef50b62c3
Merge: ca5c8a4c2aba 434fec16948c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jan 8 18:53:56 2013 -0800

    Merge tag 'fixes' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC fixes from Olof Johansson:
     "People are back from the holiday breaks, and it shows.  Here are a
      bunch of fixes for a number of platforms:
       - A couple of small fixes for Nomadik
       - A larger set of changes for kirkwood/mvebu
         - uart driver selection, dt clocks, gpio-poweroff fixups, a few
           __init annotation fixes and some error handling improvement in
           their xor dma driver.
       - i.MX had a couple of minor fixes (and a critical one for flexcan2
         clock setup)
       - MXS has a small board fix and a framebuffer bugfix
       - A set of fixes for Samsung Exynos, fixing default bootargs and some
         Exynos5440 clock issues
       - A set of OMAP changes including PM fixes and a few sparse warning
         fixups
    
      All in all a bit more positive code delta than we'd ideally want to
      see here, mostly from the OMAP PM changes, but nothing overly crazy."
    
    * tag 'fixes' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (44 commits)
      ARM: clps711x: Fix bad merge of clockevents setup
      ARM: highbank: save and restore L2 cache and GIC on suspend
      ARM: highbank: add a power request clear
      ARM: highbank: fix secondary boot and hotplug
      ARM: highbank: fix typos with hignbank in power request functions
      ARM: dts: fix highbank cpu mpidr values
      ARM: dts: add device_type prop to cpu nodes on Calxeda platforms
      ARM: mx5: Fix MX53 flexcan2 clock
      ARM: OMAP2+: am33xx-hwmod: Fix wrongly terminated am33xx_usbss_mpu_irqs array
      pinctrl: mvebu: make pdma clock on dove mandatory
      ARM: Dove: Add pinctrl clock to DT
      dma: mv_xor: fix error handling for clocks
      dma: mv_xor: fix error handling of mv_xor_channel_add()
      arm: mvebu: Add missing ; for cpu node.
      arm: mvebu: Armada XP MV78230 has only three Ethernet interfaces
      arm: mvebu: Armada XP MV78230 has two cores, not one
      clk: mvebu: Remove inappropriate __init tagging
      ARM: Kirkwood: Use fixed-regulator instead of board gpio call
      ARM: Kirkwood: Fix missing sdio clock
      ARM: Kirkwood: Switch TWSI1 of 88f6282 to DT clock providers
      ...

commit 0e3a4a2eb67acdd710a833b767c20e9189cc3458
Author: Olof Johansson <olof@lixom.net>
Date:   Sat Jan 5 08:33:30 2013 -0800

    ARM: clps711x: Fix bad merge of clockevents setup
    
    I mismerged a previous branch from Alexander, and accidentally left
    in ARCH_USES_GETTIMEOFFSET. Remove it.
    
    Signed-off-by: Olof Johansson <olof@lixom.net>
    Cc: Alexander Shiyan <shc_work@mail.ru>

commit c6f408996c625cb950cad024f90e50519f94713c
Author: Mukund Jampala <jbmukund@gmail.com>
Date:   Sun Dec 16 19:25:58 2012 +0100

    netfilter: ip[6]t_REJECT: fix wrong transport header pointer in TCP reset
    
    The problem occurs when iptables constructs the tcp reset packet.
    It doesn't initialize the pointer to the tcp header within the skb.
    When the skb is passed to the ixgbe driver for transmit, the ixgbe
    driver attempts to access the tcp header and crashes.
    Currently, other drivers (such as our 1G e1000e or igb drivers) don't
    access the tcp header on transmit unless the TSO option is turned on.
    
    <1>BUG: unable to handle kernel NULL pointer dereference at 0000000d
    <1>IP: [<d081621c>] ixgbe_xmit_frame_ring+0x8cc/0x2260 [ixgbe]
    <4>*pdpt = 0000000085e5d001 *pde = 0000000000000000
    <0>Oops: 0000 [#1] SMP
    [...]
    <4>Pid: 0, comm: swapper Tainted: P            2.6.35.12 #1 Greencity/Thurley
    <4>EIP: 0060:[<d081621c>] EFLAGS: 00010246 CPU: 16
    <4>EIP is at ixgbe_xmit_frame_ring+0x8cc/0x2260 [ixgbe]
    <4>EAX: c7628820 EBX: 00000007 ECX: 00000000 EDX: 00000000
    <4>ESI: 00000008 EDI: c6882180 EBP: dfc6b000 ESP: ced95c48
    <4> DS: 007b ES: 007b FS: 00d8 GS: 0000 SS: 0068
    <0>Process swapper (pid: 0, ti=ced94000 task=ced73bd0 task.ti=ced94000)
    <0>Stack:
    <4> cbec7418 c779e0d8 c77cc888 c77cc8a8 0903010a 00000000 c77c0008 00000002
    <4><0> cd4997c0 00000010 dfc6b000 00000000 d0d176c9 c77cc8d8 c6882180 cbec7318
    <4><0> 00000004 00000004 cbec7230 cbec7110 00000000 cbec70c0 c779e000 00000002
    <0>Call Trace:
    <4> [<d0d176c9>] ? 0xd0d176c9
    <4> [<d0d18a4d>] ? 0xd0d18a4d
    <4> [<411e243e>] ? dev_hard_start_xmit+0x218/0x2d7
    <4> [<411f03d7>] ? sch_direct_xmit+0x4b/0x114
    <4> [<411f056a>] ? __qdisc_run+0xca/0xe0
    <4> [<411e28b0>] ? dev_queue_xmit+0x2d1/0x3d0
    <4> [<411e8120>] ? neigh_resolve_output+0x1c5/0x20f
    <4> [<411e94a1>] ? neigh_update+0x29c/0x330
    <4> [<4121cf29>] ? arp_process+0x49c/0x4cd
    <4> [<411f80c9>] ? nf_hook_slow+0x3f/0xac
    <4> [<4121ca8d>] ? arp_process+0x0/0x4cd
    <4> [<4121ca8d>] ? arp_process+0x0/0x4cd
    <4> [<4121c6d5>] ? T.901+0x38/0x3b
    <4> [<4121c918>] ? arp_rcv+0xa3/0xb4
    <4> [<4121ca8d>] ? arp_process+0x0/0x4cd
    <4> [<411e1173>] ? __netif_receive_skb+0x32b/0x346
    <4> [<411e19e1>] ? netif_receive_skb+0x5a/0x5f
    <4> [<411e1ea9>] ? napi_skb_finish+0x1b/0x30
    <4> [<d0816eb4>] ? ixgbe_xmit_frame_ring+0x1564/0x2260 [ixgbe]
    <4> [<41013468>] ? lapic_next_event+0x13/0x16
    <4> [<410429b2>] ? clockevents_program_event+0xd2/0xe4
    <4> [<411e1b03>] ? net_rx_action+0x55/0x127
    <4> [<4102da1a>] ? __do_softirq+0x77/0xeb
    <4> [<4102dab1>] ? do_softirq+0x23/0x27
    <4> [<41003a67>] ? do_IRQ+0x7d/0x8e
    <4> [<41002a69>] ? common_interrupt+0x29/0x30
    <4> [<41007bcf>] ? mwait_idle+0x48/0x4d
    <4> [<4100193b>] ? cpu_idle+0x37/0x4c
    <0>Code: df 09 d7 0f 94 c2 0f b6 d2 e9 e7 fb ff ff 31 db 31 c0 e9 38
    ff ff ff 80 78 06 06 0f 85 3e fb ff ff 8b 7c 24 38 8b 8f b8 00 00 00
    <0f> b6 51 0d f6 c2 01 0f 85 27 fb ff ff 80 e2 02 75 0d 8b 6c 24
    <0>EIP: [<d081621c>] ixgbe_xmit_frame_ring+0x8cc/0x2260 [ixgbe] SS:ESP
    
    Signed-off-by: Mukund Jampala <jbmukund@gmail.com>
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>

commit 4bddddf24b644fd884f20639a91871bcbf567974
Merge: a0f2a5a18441 2a5528912d15
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Thu Oct 25 17:23:50 2012 +0200

    Merge branch 'clps711x/soc' into next/soc
    
    * clps711x/soc:
      ARM: clps711x: merge files related to EDB7211-board into one
      ARM: clps711x: merge all CLPS711X-defconfigs into one
      ARM: clps711x: make all virtual addresses definition via one macro
      ARM: clps711x: added missing definitions
      ARM: clps711x: rework IRQ sybsustem initialization
      ARM: clps711x: p720t: remove missing #include
      ARM: clps711x: convert to clockevents

commit 4a8355c4c34f55aecd204604f02e179eaee15502
Author: Alexander Shiyan <shc_work@mail.ru>
Date:   Wed Oct 10 19:45:27 2012 +0400

    ARM: clps711x: convert to clockevents
    
    This patch converts CLPS711X-platform to use modern clockevent API.
    
    Signed-off-by: Alexander Shiyan <shc_work@mail.ru>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

commit 6a29b109b9fb4c76bf55851223ae59e3322d9616
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Jul 17 18:05:25 2012 -0400

    ntp: Fix leap-second hrtimer livelock
    
    This is a backport of 6b43ae8a619d17c4935c3320d2ef9e92bdeed05d
    
    This should have been backported when it was commited, but I
    mistook the problem as requiring the ntp_lock changes
    that landed in 3.4 in order for it to occur.
    
    Unfortunately the same issue can happen (with only one cpu)
    as follows:
    do_adjtimex()
     write_seqlock_irq(&xtime_lock);
      process_adjtimex_modes()
       process_adj_status()
        ntp_start_leap_timer()
         hrtimer_start()
          hrtimer_reprogram()
           tick_program_event()
            clockevents_program_event()
             ktime_get()
              seq = req_seqbegin(xtime_lock); [DEADLOCK]
    
    This deadlock will no always occur, as it requires the
    leap_timer to force a hrtimer_reprogram which only happens
    if its set and there's no sooner timer to expire.
    
    NOTE: This patch, being faithful to the original commit,
    introduces a bug (we don't update wall_to_monotonic),
    which will be resovled by backporting a following fix.
    
    Original commit message below:
    
    Since commit 7dffa3c673fbcf835cd7be80bb4aec8ad3f51168 the ntp
    subsystem has used an hrtimer for triggering the leapsecond
    adjustment. However, this can cause a potential livelock.
    
    Thomas diagnosed this as the following pattern:
    CPU 0                                                    CPU 1
    do_adjtimex()
      spin_lock_irq(&ntp_lock);
        process_adjtimex_modes();                            timer_interrupt()
          process_adj_status();                                do_timer()
            ntp_start_leap_timer();                             write_lock(&xtime_lock);
              hrtimer_start();                                  update_wall_time();
                 hrtimer_reprogram();                            ntp_tick_length()
                   tick_program_event()                            spin_lock(&ntp_lock);
                     clockevents_program_event()
                       ktime_get()
                         seq = req_seqbegin(xtime_lock);
    
    This patch tries to avoid the problem by reverting back to not using
    an hrtimer to inject leapseconds, and instead we handle the leapsecond
    processing in the second_overflow() function.
    
    The downside to this change is that on systems that support highres
    timers, the leap second processing will occur on a HZ tick boundary,
    (ie: ~1-10ms, depending on HZ)  after the leap second instead of
    possibly sooner (~34us in my tests w/ x86_64 lapic).
    
    This patch applies on top of tip/timers/core.
    
    CC: Sasha Levin <levinsasha928@gmail.com>
    CC: Thomas Gleixner <tglx@linutronix.de>
    Reported-by: Sasha Levin <levinsasha928@gmail.com>
    Diagnoised-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Sasha Levin <levinsasha928@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Linux Kernel <linux-kernel@vger.kernel.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Willy Tarreau <w@1wt.eu>

commit 838955464ce6579492c1b863264ad6cfe79a9a14
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Jul 17 17:49:21 2012 -0400

    ntp: Fix leap-second hrtimer livelock
    
    commit 6b43ae8a619d17c4935c3320d2ef9e92bdeed05d upstream.
    
    This should have been backported when it was commited, but I
    mistook the problem as requiring the ntp_lock changes
    that landed in 3.4 in order for it to occur.
    
    Unfortunately the same issue can happen (with only one cpu)
    as follows:
    do_adjtimex()
     write_seqlock_irq(&xtime_lock);
      process_adjtimex_modes()
       process_adj_status()
        ntp_start_leap_timer()
         hrtimer_start()
          hrtimer_reprogram()
           tick_program_event()
            clockevents_program_event()
             ktime_get()
              seq = req_seqbegin(xtime_lock); [DEADLOCK]
    
    This deadlock will no always occur, as it requires the
    leap_timer to force a hrtimer_reprogram which only happens
    if its set and there's no sooner timer to expire.
    
    NOTE: This patch, being faithful to the original commit,
    introduces a bug (we don't update wall_to_monotonic),
    which will be resovled by backporting a following fix.
    
    Original commit message below:
    
    Since commit 7dffa3c673fbcf835cd7be80bb4aec8ad3f51168 the ntp
    subsystem has used an hrtimer for triggering the leapsecond
    adjustment. However, this can cause a potential livelock.
    
    Thomas diagnosed this as the following pattern:
    CPU 0                                                    CPU 1
    do_adjtimex()
      spin_lock_irq(&ntp_lock);
        process_adjtimex_modes();                            timer_interrupt()
          process_adj_status();                                do_timer()
            ntp_start_leap_timer();                             write_lock(&xtime_lock);
              hrtimer_start();                                  update_wall_time();
                 hrtimer_reprogram();                            ntp_tick_length()
                   tick_program_event()                            spin_lock(&ntp_lock);
                     clockevents_program_event()
                       ktime_get()
                         seq = req_seqbegin(xtime_lock);
    
    This patch tries to avoid the problem by reverting back to not using
    an hrtimer to inject leapseconds, and instead we handle the leapsecond
    processing in the second_overflow() function.
    
    The downside to this change is that on systems that support highres
    timers, the leap second processing will occur on a HZ tick boundary,
    (ie: ~1-10ms, depending on HZ)  after the leap second instead of
    possibly sooner (~34us in my tests w/ x86_64 lapic).
    
    This patch applies on top of tip/timers/core.
    
    CC: Sasha Levin <levinsasha928@gmail.com>
    CC: Thomas Gleixner <tglx@linutronix.de>
    Reported-by: Sasha Levin <levinsasha928@gmail.com>
    Diagnoised-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Sasha Levin <levinsasha928@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Linux Kernel <linux-kernel@vger.kernel.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

commit a57ccabee60519dd90051266c00d038055b93878
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Jul 17 03:05:14 2012 -0400

    ntp: Fix leap-second hrtimer livelock
    
    This is a backport of 6b43ae8a619d17c4935c3320d2ef9e92bdeed05d
    
    This should have been backported when it was commited, but I
    mistook the problem as requiring the ntp_lock changes
    that landed in 3.4 in order for it to occur.
    
    Unfortunately the same issue can happen (with only one cpu)
    as follows:
    do_adjtimex()
     write_seqlock_irq(&xtime_lock);
      process_adjtimex_modes()
       process_adj_status()
        ntp_start_leap_timer()
         hrtimer_start()
          hrtimer_reprogram()
           tick_program_event()
            clockevents_program_event()
             ktime_get()
              seq = req_seqbegin(xtime_lock); [DEADLOCK]
    
    This deadlock will no always occur, as it requires the
    leap_timer to force a hrtimer_reprogram which only happens
    if its set and there's no sooner timer to expire.
    
    NOTE: This patch, being faithful to the original commit,
    introduces a bug (we don't update wall_to_monotonic),
    which will be resovled by backporting a following fix.
    
    Original commit message below:
    
    Since commit 7dffa3c673fbcf835cd7be80bb4aec8ad3f51168 the ntp
    subsystem has used an hrtimer for triggering the leapsecond
    adjustment. However, this can cause a potential livelock.
    
    Thomas diagnosed this as the following pattern:
    CPU 0                                                    CPU 1
    do_adjtimex()
      spin_lock_irq(&ntp_lock);
        process_adjtimex_modes();                            timer_interrupt()
          process_adj_status();                                do_timer()
            ntp_start_leap_timer();                             write_lock(&xtime_lock);
              hrtimer_start();                                  update_wall_time();
                 hrtimer_reprogram();                            ntp_tick_length()
                   tick_program_event()                            spin_lock(&ntp_lock);
                     clockevents_program_event()
                       ktime_get()
                         seq = req_seqbegin(xtime_lock);
    
    This patch tries to avoid the problem by reverting back to not using
    an hrtimer to inject leapseconds, and instead we handle the leapsecond
    processing in the second_overflow() function.
    
    The downside to this change is that on systems that support highres
    timers, the leap second processing will occur on a HZ tick boundary,
    (ie: ~1-10ms, depending on HZ)  after the leap second instead of
    possibly sooner (~34us in my tests w/ x86_64 lapic).
    
    This patch applies on top of tip/timers/core.
    
    CC: Sasha Levin <levinsasha928@gmail.com>
    CC: Thomas Gleixner <tglx@linutronix.de>
    Reported-by: Sasha Levin <levinsasha928@gmail.com>
    Diagnoised-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Sasha Levin <levinsasha928@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Linux Kernel <linux-kernel@vger.kernel.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit 9c24771f844b6f0708a72cd116953e0a128e5d2a
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Jul 17 13:33:48 2012 -0400

    ntp: Fix leap-second hrtimer livelock
    
    This is a backport of 6b43ae8a619d17c4935c3320d2ef9e92bdeed05d
    
    This should have been backported when it was commited, but I
    mistook the problem as requiring the ntp_lock changes
    that landed in 3.4 in order for it to occur.
    
    Unfortunately the same issue can happen (with only one cpu)
    as follows:
    do_adjtimex()
     write_seqlock_irq(&xtime_lock);
      process_adjtimex_modes()
       process_adj_status()
        ntp_start_leap_timer()
         hrtimer_start()
          hrtimer_reprogram()
           tick_program_event()
            clockevents_program_event()
             ktime_get()
              seq = req_seqbegin(xtime_lock); [DEADLOCK]
    
    This deadlock will no always occur, as it requires the
    leap_timer to force a hrtimer_reprogram which only happens
    if its set and there's no sooner timer to expire.
    
    NOTE: This patch, being faithful to the original commit,
    introduces a bug (we don't update wall_to_monotonic),
    which will be resovled by backporting a following fix.
    
    Original commit message below:
    
    Since commit 7dffa3c673fbcf835cd7be80bb4aec8ad3f51168 the ntp
    subsystem has used an hrtimer for triggering the leapsecond
    adjustment. However, this can cause a potential livelock.
    
    Thomas diagnosed this as the following pattern:
    CPU 0                                                    CPU 1
    do_adjtimex()
      spin_lock_irq(&ntp_lock);
        process_adjtimex_modes();                            timer_interrupt()
          process_adj_status();                                do_timer()
            ntp_start_leap_timer();                             write_lock(&xtime_lock);
              hrtimer_start();                                  update_wall_time();
                 hrtimer_reprogram();                            ntp_tick_length()
                   tick_program_event()                            spin_lock(&ntp_lock);
                     clockevents_program_event()
                       ktime_get()
                         seq = req_seqbegin(xtime_lock);
    
    This patch tries to avoid the problem by reverting back to not using
    an hrtimer to inject leapseconds, and instead we handle the leapsecond
    processing in the second_overflow() function.
    
    The downside to this change is that on systems that support highres
    timers, the leap second processing will occur on a HZ tick boundary,
    (ie: ~1-10ms, depending on HZ)  after the leap second instead of
    possibly sooner (~34us in my tests w/ x86_64 lapic).
    
    This patch applies on top of tip/timers/core.
    
    CC: Sasha Levin <levinsasha928@gmail.com>
    CC: Thomas Gleixner <tglx@linutronix.de>
    Reported-by: Sasha Levin <levinsasha928@gmail.com>
    Diagnoised-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Sasha Levin <levinsasha928@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 27a5569dc66ecce06cb532542ddcd0b6da8783f6
Author: Lorenzo Pieralisi <Lorenzo.Pieralisi@arm.com>
Date:   Fri Jul 6 11:06:49 2012 +0100

    ARM: 7444/1: kernel: add arch-timer C3STOP feature
    
    When a CPU is shutdown its architected timer comparators registers are
    lost. Within CPU idle, before processors enter shutdown they enter
    clock events broadcast mode through the
    
    clockevents_notify(CLOCK_EVT_NOTIFY_BROADCAST_ENTER, cpuid);
    
    function where the local timers are emulated by a global always-on timer.
    On CPU resume, the per-CPU tick device normal mode is restored by exiting
    broadcast mode through
    
    clockevents_notify(CLOCK_EVT_NOTIFY_BROADCAST_EXIT, cpuid);
    
    In order for this mechanism to function, architected timers should add to
    their feature C3STOP, which means that they are not able to function when the
    CPU is in off-mode.
    
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

commit b7b4ff764f7bf903e47eebdab661b1c38e791c6d
Author: Jon Hunter <jon-hunter@ti.com>
Date:   Tue Jun 5 12:34:51 2012 -0500

    ARM: OMAP2+: Add dmtimer platform function to reserve systimers
    
    During early boot, one or two dmtimers are reserved by the kernel as system
    timers (for clocksource and clockevents). These timers are marked as reserved
    and the dmtimer driver is notified which timers have been reserved via the
    platform data information.
    
    For OMAP2+ devices the timers reserved may vary depending on device and compile
    flags. Therefore, it is not easy to assume which timers we be reserved for the
    system timers. In order to migrate the dmtimer driver to support device-tree we
    need a way to pass the timers reserved for system timers to the dmtimer driver.
    Using the platform data structure will not work in the same way as it is
    currently used because the platform data structure will be stored statically in
    the dmtimer itself and the platform data will be selected via the device-tree
    match device function (of_match_device).
    
    There are a couple ways to workaround this. One option is to store the system
    timers reserved for the kernel in the device-tree and query them on boot.
    The downside of this approach is that it adds some delay to parse the DT blob
    to search for the system timers. Secondly, for OMAP3 devices we have a
    dependency on compile time flags and the device-tree would not be aware of that
    kernel compile flags and so we would need to address that.
    
    The second option is to add a function to the dmtimer code to reserved the
    system timers during boot and so the dmtimer knows exactly which timers are
    being used for system timers. This also allows us to remove the "reserved"
    member from the timer platform data. This seemed like the simpler approach and
    so was implemented here.
    
    Signed-off-by: Jon Hunter <jon-hunter@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

commit 790b9d4bb7614252e133d4a99ef18c1734d69163
Merge: c02feeea3dad 380622e9ff56
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jun 13 23:19:34 2012 +0300

    Merge tag 'sh-for-linus' of git://github.com/pmundt/linux-sh
    
    Pull SuperH fixes from Paul Mundt.
    
    * tag 'sh-for-linus' of git://github.com/pmundt/linux-sh:
      sh: Kill off additional asm-generic wrappers.
      sh: Setup CROSS_COMPILE at the top
      sh: Fix up link time defsym warnings.
      sh: use the new generic strnlen_user() function
      sh: switch to generic strncpy_from_user().
      sh: Kill off last dead UBC header
      serial: sh-sci: Make probe fail for ports that exceed the maximum count
      serial: sh-sci: Fix probe error paths
      clocksource: sh_tmu: Use clockevents_config_and_register().
      clocksource: sh_tmu: Convert timer lock to raw spinlock.
      clocksource: sh_mtu2: Convert timer lock to raw spinlock.
      clocksource: sh_cmt: Convert timer lock to raw spinlock.
      bug.h: need linux/kernel.h for TAINT_WARN.
      sh: convert to kbuild asm-generic support.
      sh64: Fix up fallout from generic init_task conversion.
      sh: arch/sh/kernel/process.c needs asm/fpu.h for unlazy_fpu().

commit 380622e9ff56201f9c3c1f153d1ca0a24324a1d4
Merge: 74ca4313bdd0 cba8df4be3bd 3977407e8312 1318002aebad d14a5fdc2698
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed Jun 13 12:01:33 2012 +0900

    Merge branches 'sh/urgent', 'sh/core', 'sh/clockevents', 'sh/asm-generic' and 'sh/trivial' into sh-fixes-for-linus

commit 3977407e83129f53e43d3ac44be8702f59fa3f77
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon Jun 11 17:10:16 2012 +0900

    clocksource: sh_tmu: Use clockevents_config_and_register().
    
    This switches over to the now exported clockevents_config() and
    clockevents_config_and_register() helpers. This knocks off a
    long-standing TMU TODO item.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

commit c22072bdf053b115a1126658100967dda00b5ecf
Merge: 0640113be25d 62cf20b32aee
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jun 4 11:25:31 2012 -0700

    Merge branch 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer updates from Thomas Gleixner:
     "The clocksource driver is pure hardware enablement and the skew option
      is default off, well tested and non dangerous."
    
    * 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      tick: Move skew_tick option into the HIGH_RES_TIMER section
      clocksource: em_sti: Add DT support
      clocksource: em_sti: Emma Mobile STI driver
      clockevents: Make clockevents_config() a global symbol
      tick: Add tick skew boot option

commit f737c7705ff0df2f1d66e14ec30a1a5f285ddb39
Merge: 13199a084572 e49e6ff553ff
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu May 31 10:39:06 2012 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/sparc
    
    Pull Sparc updates from David S. Miller:
    
     1) Remove the idiotic situation wherein Leon was a special case in all
        of the TLB/cache handling code.
    
        The worst side effect of this bogosity is that you couldn't build a
        kernel with Leon support enabled (to get better build coverage), and
        test boot it on a non-LEON cpu.
    
        Leon is, in all core respects, programatically identical to the
        32-bit SRMMU.  Except that they put the TLB registers in a different
        alternate address space location.
    
        Through code patching (for fast paths) and run time checks, this
        issue is now a thing of the past.
    
        From Sam Ravnborg.
    
     2) There was a mis-merge of arch/sparc/Kconfig for one of the
        clockevents changes that went in, causing 32-bit sparc to start
        failing to build.
    
        I merged in your tree to get those clockevents changes (and added a
        note to the merge commit) then added Stephen Rothwell's fix for the
        merge error.
    
     3) Software quad floating point emulation was not working properly on
        more recent Niagara chips, because the way the situation is reported
        by the cpu has changed.
    
        Nobody noticed because gcc emits calls to software emulation
        routines in glibc.
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/davem/sparc: (25 commits)
      sparc: fix sparc64 build due to leon.h inclusion
      sparc32: remove unused variable in head_32.S
      sparc32,leon: fix leon bootup
      sparc32: Export leon_dma_ops to modules.
      sparc32: support leon + sun in dma_make_coherent()
      sparc32,leon: always support leon in ioport
      sparc32,leon: always include leon_pmc in build
      sparc32: refactor cpu_idle()
      sparc32: srmmu_probe now knows about leon too
      sparc32: drop LEON hack for ASI_M_MMUREGS
      sparc32: introduce run-time patching of srmmu access functions
      sparc32: introduce support for run-time patching for all shared assembler code
      sparc32,leon: fix section mismatch warning
      sparc32,leon: always include leon_smp + leon_mm in build
      sparc32,leon: always include leon_kernel in build
      sparc32,leon: clean up leon.h
      sparc32: handle leon in cpu.c
      sparc32: handle leon in irq_32.c
      sparc32: add support for run-time patching of leon/sun single instructions
      sparc32: introduce sparc32_start_kernel called from head_32.S
      ...

commit fa2af6e4fe0c4d2f8875d42625b25675e8584010
Merge: 109b9b0408e5 1fcb78e9da71
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri May 25 15:59:38 2012 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/cmetcalf/linux-tile
    
    Pull tile updates from Chris Metcalf:
     "These changes cover a range of new arch/tile features and
      optimizations.  They've been through LKML review and on linux-next for
      a month or so.  There's also one bug-fix that just missed 3.4, which
      I've marked for stable."
    
    Fixed up trivial conflict in arch/tile/Kconfig (new added tile Kconfig
    entries clashing with the generic timer/clockevents changes).
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/cmetcalf/linux-tile:
      tile: default to tilegx_defconfig for ARCH=tile
      tile: fix bug where fls(0) was not returning 0
      arch/tile: mark TILEGX as not EXPERIMENTAL
      tile/mm/fault.c: Port OOM changes to handle_page_fault
      arch/tile: add descriptive text if the kernel reports a bad trap
      arch/tile: allow querying cpu module information from the hypervisor
      arch/tile: fix hardwall for tilegx and generalize for idn and ipi
      arch/tile: support multiple huge page sizes dynamically
      mm: add new arch_make_huge_pte() method for tile support
      arch/tile: support kexec() for tilegx
      arch/tile: support <asm/cachectl.h> header for cacheflush() syscall
      arch/tile: Allow tilegx to build with either 16K or 64K page size
      arch/tile: optimize get_user/put_user and friends
      arch/tile: support building big-endian kernel
      arch/tile: allow building Linux with transparent huge pages enabled
      arch/tile: use interrupt critical sections less

commit e5400321a6f15ce0fe77c8455954f213ef7dcc54
Author: Magnus Damm <magnus.damm@gmail.com>
Date:   Wed May 9 23:39:34 2012 +0900

    clockevents: Make clockevents_config() a global symbol
    
    Make clockevents_config() into a global symbol to allow it to be used
    by compiled-in clockevent drivers. This is needed by drivers that want
    to update the timer frequency after registration time.
    
    Signed-off-by: Magnus Damm <damm@opensource.se>
    Tested-by: Simon Horman <horms@verge.net.au>
    Cc: arnd@arndb.de
    Cc: johnstul@us.ibm.com
    Cc: rjw@sisk.pl
    Cc: lethal@linux-sh.org
    Cc: gregkh@linuxfoundation.org
    Cc: olof@lixom.net
    Cc: Magnus Damm <magnus.damm@gmail.com>
    Link: http://lkml.kernel.org/r/20120509143934.27521.46553.sendpatchset@w520
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 9daeaa370526df1c19eba4780247bb7155541e38
Merge: cb62ab71fe2b 1edc17832d8f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon May 21 10:32:01 2012 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/sparc-next
    
    Pull sparc updates from David Miller:
    
    1) Kill off support for sun4c and Cypress sun4m chips.
    
       And as a result we were able to also kill off that ugly btfixup thing
       that required multi-stage links of the final vmlinux image in the
       Kbuild system.  This should make the kbuild maintainers really happy.
    
       Thanks a lot to Sam Ravnborg for his tireless efforts to get this
       going.
    
    2) Convert sparc64 to nobootmem.  I suspect now with sparc32 being a lot
       cleaner, it should be able to fall in line and modernize in this area
       too.
    
    3) Make sparc32 use generic clockevents, from Tkhai Kirill.
    
    [ I fixed up the BPF rules, and tried to clean up the build rules too.
      But I don't have - or want - a sparc cross-build environment, so the
      BPF rule bug and the related build cleanup was all done with just a
      bare "make -n" pseudo-test.      - Linus ]
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/davem/sparc-next: (110 commits)
      sparc32: use flushi when run-time patching in per_cpu_patch
      sparc32: fix cpuid_patch run-time patching
      sparc32: drop unused inline functions in srmmu.c
      sparc32: drop unused functions in pgtsrmmu.h
      sparc32,leon: move leon mmu functions to leon_mm.c
      sparc32,leon: remove duplicate definitions in leon.h
      sparc32,leon: remove duplicate UART register definitions
      sparc32,leon: move leon ASI definitions to asi.h
      sparc32: move trap table to a separate file
      sparc64: renamed ttable.S to ttable_64.S
      sparc32: Remove asm/sysen.h header.
      sparc32: Delete asm/smpprim.h
      sparc32: Remove unused empty_bad_page{,_table} declarations.
      sparc32: Kill boot_cpu_id4
      sparc32: Move GET_PROCESSOR*_ID() out of asm/asmmacro.h
      sparc32: Remove completely unused code from asm/cache.h
      sparc32: Add ucmpdi2.o to obj-y instead of lib-y.
      sparc32: add ucmpdi2
      sparc: introduce arch/sparc/Kbuild
      sparc: remove obsolete documentation
      ...

commit dfbaec06bd80117f8ed944236efab8fb32cd4f68
Author: Anna-Maria Gleixner <anna-maria@glx-um.de>
Date:   Fri May 18 16:45:45 2012 +0000

    blackfin: Use generic time config
    
    Use seperate selector for clockevents.
    
    Signed-off-by: Anna-Maria Gleixner <anna-maria@glx-um.de>
    Cc: Mike Frysinger <vapier@gentoo.org>
    Link: http://lkml.kernel.org/r/20120518163105.026597932@glx-um.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 8a775c185c43cdea7c67a2fa84d29e693fac618e
Author: Milton Miller <miltonm@bga.com>
Date:   Thu May 12 04:13:54 2011 -0500

    seqlock: Don't smp_rmb in seqlock reader spin loop
    
    commit 5db1256a5131d3b133946fa02ac9770a784e6eb2 upstream.
    
    Move the smp_rmb after cpu_relax loop in read_seqlock and add
    ACCESS_ONCE to make sure the test and return are consistent.
    
    A multi-threaded core in the lab didn't like the update
    from 2.6.35 to 2.6.36, to the point it would hang during
    boot when multiple threads were active.  Bisection showed
    af5ab277ded04bd9bc6b048c5a2f0e7d70ef0867 (clockevents:
    Remove the per cpu tick skew) as the culprit and it is
    supported with stack traces showing xtime_lock waits including
    tick_do_update_jiffies64 and/or update_vsyscall.
    
    Experimentation showed the combination of cpu_relax and smp_rmb
    was significantly slowing the progress of other threads sharing
    the core, and this patch is effective in avoiding the hang.
    
    A theory is the rmb is affecting the whole core while the
    cpu_relax is causing a resource rebalance flush, together they
    cause an interfernce cadance that is unbroken when the seqlock
    reader has interrupts disabled.
    
    At first I was confused why the refactor in
    3c22cd5709e8143444a6d08682a87f4c57902df3 (kernel: optimise
    seqlock) didn't affect this patch application, but after some
    study that affected seqcount not seqlock. The new seqcount was
    not factored back into the seqlock.  I defer that the future.
    
    While the removal of the timer interrupt offset created
    contention for the xtime lock while a cpu does the
    additonal work to update the system clock, the seqlock
    implementation with the tight rmb spin loop goes back much
    further, and is just waiting for the right trigger.
    
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Milton Miller <miltonm@bga.com>
    Cc: <linuxppc-dev@lists.ozlabs.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Andi Kleen <andi@firstfloor.org>
    Cc: Nick Piggin <npiggin@kernel.dk>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Anton Blanchard <anton@samba.org>
    Cc: Paul McKenney <paulmck@linux.vnet.ibm.com>
    Acked-by: Eric Dumazet <eric.dumazet@gmail.com>
    Link: http://lkml.kernel.org/r/%3Cseqlock-rmb%40mdm.bga.com%3E
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

commit b9a6a23566960d0dd3f51e2e68b472cd61911078
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Apr 18 17:31:58 2012 +0200

    tick: Ensure that the broadcast device is initialized
    
    Santosh found another trap when we avoid to initialize the broadcast
    device in the switch_to_oneshot code. The broadcast device might be
    still in SHUTDOWN state when we actually need to use it. That
    obviously breaks, as set_next_event() is called on a shutdown
    device. This did not break on x86, but Suresh analyzed it:
    
    From the review, most likely on Sven's system we are force enabling
    the hpet using the pci quirk's method very late. And in this case,
    hpet_clockevent (which will be global_clock_event) handler can be
    null, specifically as this platform might not be using deeper c-states
    and using the reliable APIC timer.
    
    Prior to commit 'fa4da365bc7772c', that handler will be set to
    'tick_handle_oneshot_broadcast' when we switch the broadcast timer to
    oneshot mode, even though we don't use it. Post commit
    'fa4da365bc7772c', we stopped switching the broadcast mode to oneshot
    as this is not really needed and his platform's global_clock_event's
    handler will remain null. While on my SNB laptop, same is set to
    'clockevents_handle_noop' because hpet gets enabled very early. (noop
    handler on my platform set when the early enabled hpet timer gets
    replaced by the lapic timer).
    
    But the commit 'fa4da365bc7772c' tracked the broadcast timer mode in
    the SW as oneshot, even though it didn't touch the HW timer. During
    resume however, tick_resume_broadcast() saw the SW broadcast mode as
    oneshot and actually programmed the broadcast device also into oneshot
    mode. So this triggered the null pointer de-reference after the hpet
    wraps around and depending on what the hpet counter is set to. On the
    normal platforms where hpet gets enabled early we should be seeing a
    spurious interrupt (in my SNB laptop I see one spurious interrupt
    after around 5 minutes ;) which is 32-bit hpet counter wraparound
    time), but that's a separate issue.
    
    Enforce the mode setting when trying to set an event.
    
    Reported-and-tested-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Suresh Siddha <suresh.b.siddha@intel.com>
    Cc: torvalds@linux-foundation.org
    Cc: svenjoac@gmx.de
    Cc: rjw@sisk.pl
    Link: http://lkml.kernel.org/r/alpine.LFD.2.02.1204181723350.2542@ionos

commit b435092f70ec5ebbfb6d075d5bf3c631b49a51de
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Apr 18 12:08:23 2012 +0200

    tick: Fix oneshot broadcast setup really
    
    Sven Joachim reported, that suspend/resume on rc3 trips over a NULL
    pointer dereference. Linus spotted the clockevent handler being NULL.
    
    commit fa4da365b(clockevents: tTack broadcast device mode change in
    tick_broadcast_switch_to_oneshot()) tried to fix a problem with the
    broadcast device setup, which was introduced in commit 77b0d60c5(
    clockevents: Leave the broadcast device in shutdown mode when not
    needed).
    
    The initial commit avoided to set up the broadcast device when no
    broadcast request bits were set, but that left the broadcast device
    disfunctional. In consequence deep idle states which need the
    broadcast device were not woken up.
    
    commit fa4da365b tried to fix that by initializing the state of the
    broadcast facility, but that missed the fact, that nothing initializes
    the event handler and some other state of the underlying clock event
    device.
    
    The fix is to revert both commits and make only the mode setting of
    the clock event device conditional on the state of active broadcast
    users.
    
    That initializes everything except the low level device mode, but this
    happens when the broadcast functionality is invoked by deep idle.
    
    Reported-and-tested-by: Sven Joachim <svenjoac@gmx.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Suresh Siddha <suresh.b.siddha@intel.com>
    Link: http://lkml.kernel.org/r/alpine.LFD.2.02.1204181205540.2542@ionos

commit 62f082830d63cf753ed0dab16f8d3b2d0ffc7f43
Author: Tkhai Kirill <tkhai@yandex.ru>
Date:   Wed Apr 4 21:49:26 2012 +0200

    sparc32: generic clockevent support
    
    The kernel uses l14 timers as clockevents. l10 timer is used
    as clocksource if platform master_l10_counter isn't constantly
    zero. The clocksource is continuous, so it's possible to use
    high resolution timers. l10 timer is also used as clockevent
    on UP configurations.
    
    This realization is for sun4m, sun4d, sun4c, microsparc-IIep
    and LEON platforms. The appropriate LEON changes was made by
    Konrad Eisele.
    
    In case of sun4m's oneshot mode, profile irq is zeroed in
    smp4m_percpu_timer_interrupt(). It is maybe
    needless (double, triple etc overflow does nothing).
    
    sun4d is able to have oneshot mode too, but I haven't
    any way to test it. So code of its percpu timer handler
    is made as much equal to the current code as possible.
    
    The patch is tested on sun4m box in SMP mode by me,
    and tested by Konrad on leon in up mode (leon smp
    is broken atm - due to other reasons).
    
    Signed-off-by: Tkhai Kirill <tkhai@yandex.ru>
    Tested-by: Konrad Eisele <konrad@gaisler.com> [leon up]
    [sam: revised patch to provide generic support for leon]
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit ccb1ec95e924a24906ef01ce6d028a8dc13dc87d
Merge: 4a1d7544fee5 d48fc63f6f3f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Apr 12 15:16:26 2012 -0700

    Merge branch 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer fixes from Thomas Gleixner:
     "The itimer removal one is not strictly a fix, but I really wanted to
      avoid a rebase of the urgent ones."
    
    * 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      Revert "clocksource: Load the ACPI PM clocksource asynchronously"
      clockevents: tTack broadcast device mode change in tick_broadcast_switch_to_oneshot()
      itimer: Use printk_once instead of WARN_ONCE
      nohz: Fix stale jiffies update in tick_nohz_restart()
      tick: Document TICK_ONESHOT config option
      proc: stats: Use arch_idle_time for idle and iowait times if available
      itimer: Schedule silent NULL pointer fixup in setitimer() for removal

commit fa4da365bc7772c2cd6d5405bdf151612455f957
Author: Suresh Siddha <suresh.b.siddha@intel.com>
Date:   Mon Apr 9 15:41:44 2012 -0700

    clockevents: tTack broadcast device mode change in tick_broadcast_switch_to_oneshot()
    
    In the commit 77b0d60c5adf39c74039e2142a1d3cd1e4d53799,
    "clockevents: Leave the broadcast device in shutdown mode when not needed",
    we were bailing out too quickly in tick_broadcast_switch_to_oneshot(),
    with out tracking the broadcast device mode change to 'TICKDEV_MODE_ONESHOT'.
    
    This breaks the platforms which need broadcast device oneshot services during
    deep idle states. tick_broadcast_oneshot_control() thinks that it is
    in periodic mode and fails to take proper decisions based on the
    CLOCK_EVT_NOTIFY_BROADCAST_[ENTER, EXIT] notifications during deep
    idle entry/exit.
    
    Fix this by tracking the broadcast device mode as 'TICKDEV_MODE_ONESHOT',
    before leaving the broadcast HW device in shutdown mode if there are no active
    requests for the moment.
    
    Reported-and-tested-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Signed-off-by: Suresh Siddha <suresh.b.siddha@intel.com>
    Cc: johnstul@us.ibm.com
    Link: http://lkml.kernel.org/r/1334011304.12400.81.camel@sbsiddha-desk.sc.intel.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 6b43ae8a619d17c4935c3320d2ef9e92bdeed05d
Author: John Stultz <john.stultz@linaro.org>
Date:   Thu Mar 15 13:04:03 2012 -0700

    ntp: Fix leap-second hrtimer livelock
    
    Since commit 7dffa3c673fbcf835cd7be80bb4aec8ad3f51168 the ntp
    subsystem has used an hrtimer for triggering the leapsecond
    adjustment. However, this can cause a potential livelock.
    
    Thomas diagnosed this as the following pattern:
    CPU 0                                                    CPU 1
    do_adjtimex()
      spin_lock_irq(&ntp_lock);
        process_adjtimex_modes();                            timer_interrupt()
          process_adj_status();                                do_timer()
            ntp_start_leap_timer();                             write_lock(&xtime_lock);
              hrtimer_start();                                  update_wall_time();
                 hrtimer_reprogram();                            ntp_tick_length()
                   tick_program_event()                            spin_lock(&ntp_lock);
                     clockevents_program_event()
                       ktime_get()
                         seq = req_seqbegin(xtime_lock);
    
    This patch tries to avoid the problem by reverting back to not using
    an hrtimer to inject leapseconds, and instead we handle the leapsecond
    processing in the second_overflow() function.
    
    The downside to this change is that on systems that support highres
    timers, the leap second processing will occur on a HZ tick boundary,
    (ie: ~1-10ms, depending on HZ)  after the leap second instead of
    possibly sooner (~34us in my tests w/ x86_64 lapic).
    
    This patch applies on top of tip/timers/core.
    
    CC: Sasha Levin <levinsasha928@gmail.com>
    CC: Thomas Gleixner <tglx@linutronix.de>
    Reported-by: Sasha Levin <levinsasha928@gmail.com>
    Diagnoised-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Sasha Levin <levinsasha928@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 161f7a7161191ab9c2e97f787829ef8dd2b95771
Merge: 2ba68940c893 a078c6d0e628
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Mar 20 10:32:09 2012 -0700

    Merge branch 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer changes for v3.4 from Ingo Molnar
    
    * 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (32 commits)
      ntp: Fix integer overflow when setting time
      math: Introduce div64_long
      cs5535-clockevt: Allow the MFGPT IRQ to be shared
      cs5535-clockevt: Don't ignore MFGPT on SMP-capable kernels
      x86/time: Eliminate unused irq0_irqs counter
      clocksource: scx200_hrt: Fix the build
      x86/tsc: Reduce the TSC sync check time for core-siblings
      timer: Fix bad idle check on irq entry
      nohz: Remove ts->Einidle checks before restarting the tick
      nohz: Remove update_ts_time_stat from tick_nohz_start_idle
      clockevents: Leave the broadcast device in shutdown mode when not needed
      clocksource: Load the ACPI PM clocksource asynchronously
      clocksource: scx200_hrt: Convert scx200 to use clocksource_register_hz
      clocksource: Get rid of clocksource_calc_mult_shift()
      clocksource: dbx500: convert to clocksource_register_hz()
      clocksource: scx200_hrt:  use pr_<level> instead of printk
      time: Move common updates to a function
      time: Reorder so the hot data is together
      time: Remove most of xtime_lock usage in timekeeping.c
      ntp: Add ntp_lock to replace xtime_locking
      ...

commit fc579da75f0151eec4c465b0f79b4ef8e3dfb8c2
Author: Jens Rottmann <JRottmann@LiPPERTEmbedded.de>
Date:   Mon Mar 5 15:07:54 2012 -0800

    cs5535-clockevt: Don't ignore MFGPT on SMP-capable kernels
    
    On SMP-capable kernels (e.g.  generic distro kernel) the cs5535-clockevt
    driver loads but is not actually used.
    
    Setting cpumask to cpu_all_mask works for UP-only kernels, but if compiled
    for SMP - though still running on the same UP hardware -
    kernel/time/tick-common.c:tick_check_new_device() reads this as
    "non-cpu-local" and silently ignores the device.
    
    If we leave cpumask unset clockevents_register_device() will initialize it
    and the cs5535-clockevt driver will be used no matter how the kernel was
    compiled.  Should anyone ever manage to stick a CS553x in an SMP system
    (is this even possible?) then a warning will be printed.  This is fine as
    the cs5535-clockevt driver was never written/tested for SMP.
    
    If bisecting led you here this patch may have exposed a pre-existing MFGPT
    problem.  Configure for UP-only and re-check.
    
    Signed-off-by: Jens Rottmann <JRottmann@LiPPERTEmbedded.de>
    Acked-by: Andres Salomon <dilinger@queued.net>
    Cc: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 77b0d60c5adf39c74039e2142a1d3cd1e4d53799
Author: Suresh Siddha <suresh.b.siddha@intel.com>
Date:   Fri Nov 4 17:18:21 2011 -0700

    clockevents: Leave the broadcast device in shutdown mode when not needed
    
    Platforms with Always Running APIC Timer doesn't use the broadcast timer
    but the kernel is leaving the broadcast timer (HPET in this case)
    in oneshot mode.
    
    On these platforms, before the switch to oneshot mode, broadcast device is
    actually in shutdown mode. Code checks for empty tick_broadcast_mask and
    avoids going into the periodic mode.
    
    During switch to oneshot mode, add the same tick_broadcast_mask checks in the
    tick_broadcast_switch_to_oneshot() and avoid the broadcast device going into
    the oneshot mode.
    
    Signed-off-by: Suresh Siddha <suresh.b.siddha@intel.com>
    Cc: john stultz <johnstul@us.ibm.com>
    Cc: venki@google.com
    Link: http://lkml.kernel.org/r/1320452301.15071.16.camel@sbsiddha-desk.sc.intel.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 496b8ba4f8581311718b19466f57f423a6b69bb5
Author: Milton Miller <miltonm@bga.com>
Date:   Thu May 12 04:13:54 2011 -0500

    seqlock: Don't smp_rmb in seqlock reader spin loop
    
    commit 5db1256a5131d3b133946fa02ac9770a784e6eb2 upstream.
    
    Move the smp_rmb after cpu_relax loop in read_seqlock and add
    ACCESS_ONCE to make sure the test and return are consistent.
    
    A multi-threaded core in the lab didn't like the update
    from 2.6.35 to 2.6.36, to the point it would hang during
    boot when multiple threads were active.  Bisection showed
    af5ab277ded04bd9bc6b048c5a2f0e7d70ef0867 (clockevents:
    Remove the per cpu tick skew) as the culprit and it is
    supported with stack traces showing xtime_lock waits including
    tick_do_update_jiffies64 and/or update_vsyscall.
    
    Experimentation showed the combination of cpu_relax and smp_rmb
    was significantly slowing the progress of other threads sharing
    the core, and this patch is effective in avoiding the hang.
    
    A theory is the rmb is affecting the whole core while the
    cpu_relax is causing a resource rebalance flush, together they
    cause an interfernce cadance that is unbroken when the seqlock
    reader has interrupts disabled.
    
    At first I was confused why the refactor in
    3c22cd5709e8143444a6d08682a87f4c57902df3 (kernel: optimise
    seqlock) didn't affect this patch application, but after some
    study that affected seqcount not seqlock. The new seqcount was
    not factored back into the seqlock.  I defer that the future.
    
    While the removal of the timer interrupt offset created
    contention for the xtime lock while a cpu does the
    additonal work to update the system clock, the seqlock
    implementation with the tight rmb spin loop goes back much
    further, and is just waiting for the right trigger.
    
    Signed-off-by: Milton Miller <miltonm@bga.com>
    Cc: <linuxppc-dev@lists.ozlabs.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Andi Kleen <andi@firstfloor.org>
    Cc: Nick Piggin <npiggin@kernel.dk>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Anton Blanchard <anton@samba.org>
    Cc: Paul McKenney <paulmck@linux.vnet.ibm.com>
    Acked-by: Eric Dumazet <eric.dumazet@gmail.com>
    Link: http://lkml.kernel.org/r/%3Cseqlock-rmb%40mdm.bga.com%3E
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Willy Tarreau <w@1wt.eu>

commit a3b86a6d6f5a7592192eb3fca22ae38de18f2171
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Wed Jan 11 09:57:56 2012 +0100

    ARM: plat-nomadik: modernize MTU timer
    
    Modernize the MTU timer to rely on the clockevents core to
    calculate mult and shift and setup the clock event.
    
    Acked-by: Alessandro Rubini <rubini@unipv.it>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

commit 05c30b9551f1904d9950ad0d28e65fc4ff3c8a8e
Author: Shaohua Li <shaohua.li@intel.com>
Date:   Thu Jan 19 09:20:10 2012 +0100

    block: fix NULL icq_cache reference
    
    Vivek reported a kernel crash:
    [   94.217015] BUG: unable to handle kernel NULL pointer dereference at 000000000000001c
    [   94.218004] IP: [<ffffffff81142fae>] kmem_cache_free+0x5e/0x200
    [   94.218004] PGD 13abda067 PUD 137d52067 PMD 0
    [   94.218004] Oops: 0000 [#1] SMP DEBUG_PAGEALLOC
    [   94.218004] CPU 0
    [   94.218004] Modules linked in: [last unloaded: scsi_wait_scan]
    [   94.218004]
    [   94.218004] Pid: 0, comm: swapper/0 Not tainted 3.2.0+ #16 Hewlett-Packard HP xw6600 Workstation/0A9Ch
    [   94.218004] RIP: 0010:[<ffffffff81142fae>]  [<ffffffff81142fae>] kmem_cache_free+0x5e/0x200
    [   94.218004] RSP: 0018:ffff88013fc03de0  EFLAGS: 00010006
    [   94.218004] RAX: ffffffff81e0d020 RBX: ffff880138b3c680 RCX: 00000001801c001b
    [   94.218004] RDX: 00000000003aac1d RSI: ffff880138b3c680 RDI: ffffffff81142fae
    [   94.218004] RBP: ffff88013fc03e10 R08: ffff880137830238 R09: 0000000000000001
    [   94.218004] R10: 0000000000000000 R11: 0000000000000000 R12: 0000000000000000
    [   94.218004] R13: ffffea0004e2cf00 R14: ffffffff812f6eb6 R15: 0000000000000246
    [   94.218004] FS:  0000000000000000(0000) GS:ffff88013fc00000(0000) knlGS:0000000000000000
    [   94.218004] CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b
    [   94.218004] CR2: 000000000000001c CR3: 00000001395ab000 CR4: 00000000000006f0
    [   94.218004] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
    [   94.218004] DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400
    [   94.218004] Process swapper/0 (pid: 0, threadinfo ffffffff81e00000, task ffffffff81e0d020)
    [   94.218004] Stack:
    [   94.218004]  0000000000000102 ffff88013fc0db20 ffffffff81e22700 ffff880139500f00
    [   94.218004]  0000000000000001 000000000000000a ffff88013fc03e20 ffffffff812f6eb6
    [   94.218004]  ffff88013fc03e90 ffffffff810c8da2 ffffffff81e01fd8 ffff880137830240
    [   94.218004] Call Trace:
    [   94.218004]  <IRQ>
    [   94.218004]  [<ffffffff812f6eb6>] icq_free_icq_rcu+0x16/0x20
    [   94.218004]  [<ffffffff810c8da2>] __rcu_process_callbacks+0x1c2/0x420
    [   94.218004]  [<ffffffff810c9038>] rcu_process_callbacks+0x38/0x250
    [   94.218004]  [<ffffffff810405ee>] __do_softirq+0xce/0x3e0
    [   94.218004]  [<ffffffff8108ed04>] ? clockevents_program_event+0x74/0x100
    [   94.218004]  [<ffffffff81090104>] ? tick_program_event+0x24/0x30
    [   94.218004]  [<ffffffff8183ed1c>] call_softirq+0x1c/0x30
    [   94.218004]  [<ffffffff8100422d>] do_softirq+0x8d/0xc0
    [   94.218004]  [<ffffffff81040c3e>] irq_exit+0xae/0xe0
    [   94.218004]  [<ffffffff8183f4be>] smp_apic_timer_interrupt+0x6e/0x99
    [   94.218004]  [<ffffffff8183e330>] apic_timer_interrupt+0x70/0x80
    
    Once a queue is quiesced, it's not supposed to have any elvpriv data or
    icq's, and elevator switching depends on that.  Request alloc path
    followed the rule for elvpriv data but forgot apply it to icq's
    leading to the following crash during elevator switch. Fix it by not
    allocating icq's if ELVPRIV is not set for the request.
    
    Reported-by: Vivek Goyal <vgoyal@redhat.com>
    Tested-by: Vivek Goyal <vgoyal@redhat.com>
    Signed-off-by: Shaohua Li <shaohua.li@intel.com>
    Acked-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

commit e8cbce976050a9f874a8b07012ddeb9b9eb59603
Merge: b3c37522928b 27fdb577435e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jan 9 14:40:48 2012 -0800

    Merge tag 'timer' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    timer changes for msm
    
    A very simple series. We used to have more churn in the timer
    area, so this is kept separate. Will probably put this into the
    drivers series next time.
    
    * tag 'timer' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc:
      msm: timer: Use clockevents_config_and_register()
      msm: timer: Setup interrupt after registering clockevent
      msm: timer: Remove SoC specific #ifdefs
      msm: timer: Remove msm_clocks[] and simplify code
      msm: timer: Fix ONESHOT mode interrupts
      msm: timer: Use GPT for clockevents and DGT for clocksource
      msm: timer: Cleanup #includes and #defines
      msm: timer: Tighten #ifdef for local timer support

commit 98793265b429a3f0b3f1750e74d67cd4d740d162
Merge: b4a133da2eac bd1b2a555952
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Jan 8 13:21:22 2012 -0800

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/trivial
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/trivial: (53 commits)
      Kconfig: acpi: Fix typo in comment.
      misc latin1 to utf8 conversions
      devres: Fix a typo in devm_kfree comment
      btrfs: free-space-cache.c: remove extra semicolon.
      fat: Spelling s/obsolate/obsolete/g
      SCSI, pmcraid: Fix spelling error in a pmcraid_err() call
      tools/power turbostat: update fields in manpage
      mac80211: drop spelling fix
      types.h: fix comment spelling for 'architectures'
      typo fixes: aera -> area, exntension -> extension
      devices.txt: Fix typo of 'VMware'.
      sis900: Fix enum typo 'sis900_rx_bufer_status'
      decompress_bunzip2: remove invalid vi modeline
      treewide: Fix comment and string typo 'bufer'
      hyper-v: Update MAINTAINERS
      treewide: Fix typos in various parts of the kernel, and fix some comments.
      clockevents: drop unknown Kconfig symbol GENERIC_CLOCKEVENTS_MIGR
      gpio: Kconfig: drop unknown symbol 'CS5535_GPIO'
      leds: Kconfig: Fix typo 'D2NET_V2'
      sound: Kconfig: drop unknown symbol ARCH_CLPS7500
      ...
    
    Fix up trivial conflicts in arch/powerpc/platforms/40x/Kconfig (some new
    kconfig additions, close to removed commented-out old ones)

commit 7affca3537d74365128e477b40c529d6f2fe86c8
Merge: 356b95424cfb ff4b8a57f0aa
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jan 7 12:03:30 2012 -0800

    Merge branch 'driver-core-next' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core
    
    * 'driver-core-next' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core: (73 commits)
      arm: fix up some samsung merge sysdev conversion problems
      firmware: Fix an oops on reading fw_priv->fw in sysfs loading file
      Drivers:hv: Fix a bug in vmbus_driver_unregister()
      driver core: remove __must_check from device_create_file
      debugfs: add missing #ifdef HAS_IOMEM
      arm: time.h: remove device.h #include
      driver-core: remove sysdev.h usage.
      clockevents: remove sysdev.h
      arm: convert sysdev_class to a regular subsystem
      arm: leds: convert sysdev_class to a regular subsystem
      kobject: remove kset_find_obj_hinted()
      m86k: gpio - convert sysdev_class to a regular subsystem
      mips: txx9_sram - convert sysdev_class to a regular subsystem
      mips: 7segled - convert sysdev_class to a regular subsystem
      sh: dma - convert sysdev_class to a regular subsystem
      sh: intc - convert sysdev_class to a regular subsystem
      power: suspend - convert sysdev_class to a regular subsystem
      power: qe_ic - convert sysdev_class to a regular subsystem
      power: cmm - convert sysdev_class to a regular subsystem
      s390: time - convert sysdev_class to a regular subsystem
      ...
    
    Fix up conflicts with 'struct sysdev' removal from various platform
    drivers that got changed:
     - arch/arm/mach-exynos/cpu.c
     - arch/arm/mach-exynos/irq-eint.c
     - arch/arm/mach-s3c64xx/common.c
     - arch/arm/mach-s3c64xx/cpu.c
     - arch/arm/mach-s5p64x0/cpu.c
     - arch/arm/mach-s5pv210/common.c
     - arch/arm/plat-samsung/include/plat/cpu.h
     - arch/powerpc/kernel/sysfs.c
    and fix up cpu_is_hotpluggable() as per Greg in include/linux/cpu.h

commit ef7386b5de11f6269eaf072c5ef522d2a43172c2
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Dec 30 13:24:40 2011 -0800

    Revert "clockevents: Set noop handler in clockevents_exchange_device()"
    
    commit 3b87487ac5008072f138953b07505a7e3493327f upstream.
    
    This reverts commit de28f25e8244c7353abed8de0c7792f5f883588c.
    
    It results in resume problems for various people. See for example
    
      http://thread.gmane.org/gmane.linux.kernel/1233033
      http://thread.gmane.org/gmane.linux.kernel/1233389
      http://thread.gmane.org/gmane.linux.kernel/1233159
      http://thread.gmane.org/gmane.linux.kernel/1227868/focus=1230877
    
    and the fedora and ubuntu bug reports
    
      https://bugzilla.redhat.com/show_bug.cgi?id=767248
      https://bugs.launchpad.net/ubuntu/+source/linux/+bug/904569
    
    which got bisected down to the stable version of this commit.
    
    Reported-by: Jonathan Nieder <jrnieder@gmail.com>
    Reported-by: Phil Miller <mille121@illinois.edu>
    Reported-by: Philip Langdale <philipl@overt.org>
    Reported-by: Tim Gardner <tim.gardner@canonical.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 664ba1f0d41f8e593f4189b5cdeebc860be25b8f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Dec 30 13:24:40 2011 -0800

    Revert "clockevents: Set noop handler in clockevents_exchange_device()"
    
    commit 3b87487ac5008072f138953b07505a7e3493327f upstream.
    
    This reverts commit de28f25e8244c7353abed8de0c7792f5f883588c.
    
    It results in resume problems for various people. See for example
    
      http://thread.gmane.org/gmane.linux.kernel/1233033
      http://thread.gmane.org/gmane.linux.kernel/1233389
      http://thread.gmane.org/gmane.linux.kernel/1233159
      http://thread.gmane.org/gmane.linux.kernel/1227868/focus=1230877
    
    and the fedora and ubuntu bug reports
    
      https://bugzilla.redhat.com/show_bug.cgi?id=767248
      https://bugs.launchpad.net/ubuntu/+source/linux/+bug/904569
    
    which got bisected down to the stable version of this commit.
    
    Reported-by: Jonathan Nieder <jrnieder@gmail.com>
    Reported-by: Phil Miller <mille121@illinois.edu>
    Reported-by: Philip Langdale <philipl@overt.org>
    Reported-by: Tim Gardner <tim.gardner@canonical.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit fcb80fd20a6f677b7df46742557a6c79b094f63f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Dec 30 13:24:40 2011 -0800

    Revert "clockevents: Set noop handler in clockevents_exchange_device()"
    
    commit 3b87487ac5008072f138953b07505a7e3493327f upstream.
    
    This reverts commit de28f25e8244c7353abed8de0c7792f5f883588c.
    
    It results in resume problems for various people. See for example
    
      http://thread.gmane.org/gmane.linux.kernel/1233033
      http://thread.gmane.org/gmane.linux.kernel/1233389
      http://thread.gmane.org/gmane.linux.kernel/1233159
      http://thread.gmane.org/gmane.linux.kernel/1227868/focus=1230877
    
    and the fedora and ubuntu bug reports
    
      https://bugzilla.redhat.com/show_bug.cgi?id=767248
      https://bugs.launchpad.net/ubuntu/+source/linux/+bug/904569
    
    which got bisected down to the stable version of this commit.
    
    Reported-by: Jonathan Nieder <jrnieder@gmail.com>
    Reported-by: Phil Miller <mille121@illinois.edu>
    Reported-by: Philip Langdale <philipl@overt.org>
    Reported-by: Tim Gardner <tim.gardner@canonical.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 3b87487ac5008072f138953b07505a7e3493327f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Dec 30 13:24:40 2011 -0800

    Revert "clockevents: Set noop handler in clockevents_exchange_device()"
    
    This reverts commit de28f25e8244c7353abed8de0c7792f5f883588c.
    
    It results in resume problems for various people. See for example
    
      http://thread.gmane.org/gmane.linux.kernel/1233033
      http://thread.gmane.org/gmane.linux.kernel/1233389
      http://thread.gmane.org/gmane.linux.kernel/1233159
      http://thread.gmane.org/gmane.linux.kernel/1227868/focus=1230877
    
    and the fedora and ubuntu bug reports
    
      https://bugzilla.redhat.com/show_bug.cgi?id=767248
      https://bugs.launchpad.net/ubuntu/+source/linux/+bug/904569
    
    which got bisected down to the stable version of this commit.
    
    Reported-by: Jonathan Nieder <jrnieder@gmail.com>
    Reported-by: Phil Miller <mille121@illinois.edu>
    Reported-by: Philip Langdale <philipl@overt.org>
    Reported-by: Tim Gardner <tim.gardner@canonical.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Greg KH <gregkh@suse.de>
    Cc: stable@kernel.org    # for stable kernels that applied the original
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit 4fd7f9b128107034fa925b6877fae3c275f0da86
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Dec 13 12:48:18 2011 +0100

    ARM: 7212/1: smp_twd: reconfigure clockevents after cpufreq change
    
    This break-out from Colin Cross' cpufreq-aware TWD patch
    will handle the case when our localtimer's clock changes with
    the cpu clock. A cpufreq transtion notifier will be registered
    only if the platform has supplied a specified clock to the TWD.
    
    After a cpufreq transition, update the clockevent's frequency
    by fetching the new clock rate from the clock framework and
    reprogram the next clock event.
    
    The necessary changes in the clockevents framework was done by
    Thomas Gleixner in kernel v3.0.
    
    ChangeLog v1->v2:
    - Replace IS_ERR_OR_NULL() with IS_ERR() in twd_clk check.
    - Update code to use the already existing per-cpu array of TWD
      clockevents instead of adding cruft.
    
    [Broke out, ifdef:ed CPUfreq stuff for non-cpufreq configs]
    [Rebased to newer TWD base with per-CPU clock array]
    
    Signed-off-by: Colin Cross <ccross@android.com>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Rob Herring <rob.herring@calxeda.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

commit 54d15b1d7ac550ecd8ab6b04309c2def614f8c80
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Dec 13 12:46:43 2011 +0100

    ARM: 7210/1: smp_twd: modernize clock event registration
    
    This break-out from Colin Cross' cpufreq-aware TWD patch will
    just modernize the clock event registration code to use
    clockevents_config_and_register().
    
    [Broke out of larger SMP TWD patch]
    
    Signed-off-by: Colin Cross <ccross@android.com>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Rob Herring <rob.herring@calxeda.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

commit 7239f65cf364180cdb100a4ed211b2a9f9a72119
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Wed Dec 21 16:12:37 2011 -0800

    clockevents: remove sysdev.h
    
    This isn't needed in the clockevents.c file, and the header file is
    going away soon, so just remove the #include
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 30c95692f62a40170833e87f3cd50fcbfe87c1a2
Author: Santosh Shilimkar <santosh.shilimkar@ti.com>
Date:   Fri Dec 16 16:09:12 2011 -0800

    ARM: OMAP4: clock: Add CPU local timer clock node
    
    Local timer clock is sourced from the CPU clock and hence changes
    along with CPU clock. These per CPU local timers are used as
    clock-events, so they need to be reconfigured on CPU frequency
    change as part of CPUfreq governor.
    
    Newly introduced clockevents_reconfigure() needs to know the
    twd clock-rate. Provide a clock-node to make clk_get_rate() work
    for TWD.
    
    Signed-off-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Cc: Paul Walmsley <paul@pwsan.com>
    Cc: Kevin Hilman <khilman@ti.com>
    [paul@pwsan.com: renamed clock node to 'mpu_periphclk' to indicate that this
     is the Cortex-A9 MPCore subsystem clock PERIPHCLK (DDI 0407G); moved
     clock and clkdev entries to match the autogenerated script output]
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

commit d88048a3d7b795e08def7519626496e1f2d3931b
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Dec 2 16:02:45 2011 +0100

    clockevents: Set noop handler in clockevents_exchange_device()
    
    commit de28f25e8244c7353abed8de0c7792f5f883588c upstream.
    
    If a device is shutdown, then there might be a pending interrupt,
    which will be processed after we reenable interrupts, which causes the
    original handler to be run. If the old handler is the (broadcast)
    periodic handler the shutdown state might hang the kernel completely.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit aeed6baa702a285cf03b7dc4182ffc1a7f4e4ed6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Dec 2 16:02:45 2011 +0100

    clockevents: Set noop handler in clockevents_exchange_device()
    
    commit de28f25e8244c7353abed8de0c7792f5f883588c upstream.
    
    If a device is shutdown, then there might be a pending interrupt,
    which will be processed after we reenable interrupts, which causes the
    original handler to be run. If the old handler is the (broadcast)
    periodic handler the shutdown state might hang the kernel completely.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit b01b383bbd04e9dcf7d9fe6ca3751b77ccdc533c
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Dec 2 16:02:45 2011 +0100

    clockevents: Set noop handler in clockevents_exchange_device()
    
    commit de28f25e8244c7353abed8de0c7792f5f883588c upstream.
    
    If a device is shutdown, then there might be a pending interrupt,
    which will be processed after we reenable interrupts, which causes the
    original handler to be run. If the old handler is the (broadcast)
    periodic handler the shutdown state might hang the kernel completely.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 40c043b077c6e377c8440d71563c055d0c4f0f0a
Merge: f14aa871c7e1 de28f25e8244
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Dec 5 16:53:43 2011 -0800

    Merge branch 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    * 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      clockevents: Set noop handler in clockevents_exchange_device()
      tick-broadcast: Stop active broadcast device when replacing it
      clocksource: Fix bug with max_deferment margin calculation
      rtc: Fix some bugs that allowed accumulating time drift in suspend/resume
      rtc: Disable the alarm in the hardware

commit de28f25e8244c7353abed8de0c7792f5f883588c
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Dec 2 16:02:45 2011 +0100

    clockevents: Set noop handler in clockevents_exchange_device()
    
    If a device is shutdown, then there might be a pending interrupt,
    which will be processed after we reenable interrupts, which causes the
    original handler to be run. If the old handler is the (broadcast)
    periodic handler the shutdown state might hang the kernel completely.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org

commit a13b032776379fa6e2bfccf798969ca51e5fb052
Author: Paul Bolle <pebolle@tiscali.nl>
Date:   Thu Nov 24 12:27:26 2011 +0100

    clockevents: drop unknown Kconfig symbol GENERIC_CLOCKEVENTS_MIGR
    
    There's no Kconfig symbol GENERIC_CLOCKEVENTS_MIGR, so the check for it
    will always fail.
    
    Signed-off-by: Paul Bolle <pebolle@tiscali.nl>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

commit 614b35af53468f13a41192ffb4ea34f264035b91
Author: Don Zickus <dzickus@redhat.com>
Date:   Thu Oct 20 23:52:14 2011 -0400

    usb, xhci: fix lockdep warning on endpoint timeout
    
    commit f43d623164022dcbf6750ef220b7a1133a1183eb upstream.
    
    While debugging a usb3 problem, I stumbled upon this lockdep warning.
    
    Oct 18 21:41:17 dhcp47-74 kernel: =================================
    Oct 18 21:41:17 dhcp47-74 kernel: [ INFO: inconsistent lock state ]
    Oct 18 21:41:17 dhcp47-74 kernel: 3.1.0-rc4nmi+ #456
    Oct 18 21:41:17 dhcp47-74 kernel: ---------------------------------
    Oct 18 21:41:17 dhcp47-74 kernel: inconsistent {IN-HARDIRQ-W} -> {HARDIRQ-ON-W} usage.
    Oct 18 21:41:17 dhcp47-74 kernel: swapper/0 [HC0[0]:SC1[1]:HE1:SE0] takes:
    Oct 18 21:41:17 dhcp47-74 kernel: (&(&xhci->lock)->rlock){?.-...}, at: [<ffffffffa0228990>] xhci_stop_endpoint_command_watchdog+0x30/0x340 [xhci_hcd]
    Oct 18 21:41:17 dhcp47-74 kernel: {IN-HARDIRQ-W} state was registered at:
    Oct 18 21:41:17 dhcp47-74 kernel:  [<ffffffff8109a941>] __lock_acquire+0x781/0x1660
    Oct 18 21:41:17 dhcp47-74 kernel:  [<ffffffff8109bed7>] lock_acquire+0x97/0x170
    Oct 18 21:41:17 dhcp47-74 kernel:  [<ffffffff81501b46>] _raw_spin_lock+0x46/0x80
    Oct 18 21:41:17 dhcp47-74 kernel:  [<ffffffffa02299fa>] xhci_irq+0x3a/0x1960 [xhci_hcd]
    Oct 18 21:41:17 dhcp47-74 kernel:  [<ffffffffa022b351>] xhci_msi_irq+0x31/0x40 [xhci_hcd]
    Oct 18 21:41:17 dhcp47-74 kernel:  [<ffffffff810d2305>] handle_irq_event_percpu+0x85/0x320
    Oct 18 21:41:17 dhcp47-74 kernel:  [<ffffffff810d25e8>] handle_irq_event+0x48/0x70
    Oct 18 21:41:17 dhcp47-74 kernel:  [<ffffffff810d537d>] handle_edge_irq+0x6d/0x130
    Oct 18 21:41:17 dhcp47-74 kernel:  [<ffffffff810048c9>] handle_irq+0x49/0xa0
    Oct 18 21:41:17 dhcp47-74 kernel:  [<ffffffff8150d56d>] do_IRQ+0x5d/0xe0
    Oct 18 21:41:17 dhcp47-74 kernel:  [<ffffffff815029b0>] ret_from_intr+0x0/0x13
    Oct 18 21:41:17 dhcp47-74 kernel:  [<ffffffff81388aca>] usb_set_device_state+0x8a/0x180
    Oct 18 21:41:17 dhcp47-74 kernel:  [<ffffffff8138f038>] usb_add_hcd+0x2b8/0x730
    Oct 18 21:41:17 dhcp47-74 kernel:  [<ffffffffa022ed7e>] xhci_pci_probe+0x9e/0xd4 [xhci_hcd]
    Oct 18 21:41:17 dhcp47-74 kernel:  [<ffffffff8127915f>] local_pci_probe+0x5f/0xd0
    Oct 18 21:41:17 dhcp47-74 kernel:  [<ffffffff8127a569>] pci_device_probe+0x119/0x120
    Oct 18 21:41:17 dhcp47-74 kernel:  [<ffffffff81334473>] driver_probe_device+0xa3/0x2c0
    Oct 18 21:41:17 dhcp47-74 kernel:  [<ffffffff8133473b>] __driver_attach+0xab/0xb0
    Oct 18 21:41:17 dhcp47-74 kernel:  [<ffffffff8133373c>] bus_for_each_dev+0x6c/0xa0
    Oct 18 21:41:17 dhcp47-74 kernel:  [<ffffffff813341fe>] driver_attach+0x1e/0x20
    Oct 18 21:41:17 dhcp47-74 kernel:  [<ffffffff81333b88>] bus_add_driver+0x1f8/0x2b0
    Oct 18 21:41:17 dhcp47-74 kernel:  [<ffffffff81334df6>] driver_register+0x76/0x140
    Oct 18 21:41:17 dhcp47-74 kernel:  [<ffffffff8127a7c6>] __pci_register_driver+0x66/0xe0
    Oct 18 21:41:17 dhcp47-74 kernel:  [<ffffffffa013c04a>] snd_timer_find+0x4a/0x70 [snd_timer]
    Oct 18 21:41:17 dhcp47-74 kernel:  [<ffffffffa013c00e>] snd_timer_find+0xe/0x70 [snd_timer]
    Oct 18 21:41:17 dhcp47-74 kernel:  [<ffffffff810001d3>] do_one_initcall+0x43/0x180
    Oct 18 21:41:17 dhcp47-74 kernel:  [<ffffffff810a9ed2>] sys_init_module+0x92/0x1f0
    Oct 18 21:41:17 dhcp47-74 kernel:  [<ffffffff8150ab6b>] system_call_fastpath+0x16/0x1b
    Oct 18 21:41:17 dhcp47-74 kernel: irq event stamp: 631984
    Oct 18 21:41:17 dhcp47-74 kernel: hardirqs last  enabled at (631984): [<ffffffff81502720>] _raw_spin_unlock_irq+0x30/0x50
    Oct 18 21:41:17 dhcp47-74 kernel: hardirqs last disabled at (631983): [<ffffffff81501c49>] _raw_spin_lock_irq+0x19/0x90
    Oct 18 21:41:17 dhcp47-74 kernel: softirqs last  enabled at (631980): [<ffffffff8105ff63>] _local_bh_enable+0x13/0x20
    Oct 18 21:41:17 dhcp47-74 kernel: softirqs last disabled at (631981): [<ffffffff8150ce6c>] call_softirq+0x1c/0x30
    Oct 18 21:41:17 dhcp47-74 kernel:
    Oct 18 21:41:17 dhcp47-74 kernel: other info that might help us debug this:
    Oct 18 21:41:17 dhcp47-74 kernel: Possible unsafe locking scenario:
    Oct 18 21:41:17 dhcp47-74 kernel:
    Oct 18 21:41:17 dhcp47-74 kernel:       CPU0
    Oct 18 21:41:17 dhcp47-74 kernel:       ----
    Oct 18 21:41:17 dhcp47-74 kernel:  lock(&(&xhci->lock)->rlock);
    Oct 18 21:41:17 dhcp47-74 kernel:  <Interrupt>
    Oct 18 21:41:17 dhcp47-74 kernel:    lock(&(&xhci->lock)->rlock);
    Oct 18 21:41:17 dhcp47-74 kernel:
    Oct 18 21:41:17 dhcp47-74 kernel: *** DEADLOCK ***
    Oct 18 21:41:17 dhcp47-74 kernel:
    Oct 18 21:41:17 dhcp47-74 kernel: 1 lock held by swapper/0:
    Oct 18 21:41:17 dhcp47-74 kernel: #0:  (&ep->stop_cmd_timer){+.-...}, at: [<ffffffff8106abf2>] run_timer_softirq+0x162/0x570
    Oct 18 21:41:17 dhcp47-74 kernel:
    Oct 18 21:41:17 dhcp47-74 kernel: stack backtrace:
    Oct 18 21:41:17 dhcp47-74 kernel: Pid: 0, comm: swapper Tainted: G        W   3.1.0-rc4nmi+ #456
    Oct 18 21:41:17 dhcp47-74 kernel: Call Trace:
    Oct 18 21:41:17 dhcp47-74 kernel: <IRQ>  [<ffffffff81098ed7>] print_usage_bug+0x227/0x270
    Oct 18 21:41:17 dhcp47-74 kernel: [<ffffffff810999c6>] mark_lock+0x346/0x410
    Oct 18 21:41:17 dhcp47-74 kernel: [<ffffffff8109a7de>] __lock_acquire+0x61e/0x1660
    Oct 18 21:41:17 dhcp47-74 kernel: [<ffffffff81099893>] ? mark_lock+0x213/0x410
    Oct 18 21:41:17 dhcp47-74 kernel: [<ffffffff8109bed7>] lock_acquire+0x97/0x170
    Oct 18 21:41:17 dhcp47-74 kernel: [<ffffffffa0228990>] ? xhci_stop_endpoint_command_watchdog+0x30/0x340 [xhci_hcd]
    Oct 18 21:41:17 dhcp47-74 kernel: [<ffffffff81501b46>] _raw_spin_lock+0x46/0x80
    Oct 18 21:41:17 dhcp47-74 kernel: [<ffffffffa0228990>] ? xhci_stop_endpoint_command_watchdog+0x30/0x340 [xhci_hcd]
    Oct 18 21:41:17 dhcp47-74 kernel: [<ffffffffa0228990>] xhci_stop_endpoint_command_watchdog+0x30/0x340 [xhci_hcd]
    Oct 18 21:41:17 dhcp47-74 kernel: [<ffffffff8106abf2>] ? run_timer_softirq+0x162/0x570
    Oct 18 21:41:17 dhcp47-74 kernel: [<ffffffff8106ac9d>] run_timer_softirq+0x20d/0x570
    Oct 18 21:41:17 dhcp47-74 kernel: [<ffffffff8106abf2>] ? run_timer_softirq+0x162/0x570
    Oct 18 21:41:17 dhcp47-74 kernel: [<ffffffffa0228960>] ? xhci_queue_isoc_tx_prepare+0x8e0/0x8e0 [xhci_hcd]
    Oct 18 21:41:17 dhcp47-74 kernel: [<ffffffff810604d2>] __do_softirq+0xf2/0x3f0
    Oct 18 21:41:17 dhcp47-74 kernel: [<ffffffff81020edd>] ? lapic_next_event+0x1d/0x30
    Oct 18 21:41:17 dhcp47-74 kernel: [<ffffffff81090d4e>] ? clockevents_program_event+0x5e/0x90
    Oct 18 21:41:17 dhcp47-74 kernel: [<ffffffff8150ce6c>] call_softirq+0x1c/0x30
    Oct 18 21:41:17 dhcp47-74 kernel: [<ffffffff8100484d>] do_softirq+0x8d/0xc0
    Oct 18 21:41:17 dhcp47-74 kernel: [<ffffffff8105ff35>] irq_exit+0xe5/0x100
    Oct 18 21:41:17 dhcp47-74 kernel: [<ffffffff8150d65e>] smp_apic_timer_interrupt+0x6e/0x99
    Oct 18 21:41:17 dhcp47-74 kernel: [<ffffffff8150b6f0>] apic_timer_interrupt+0x70/0x80
    Oct 18 21:41:17 dhcp47-74 kernel: <EOI>  [<ffffffff81095d8d>] ? trace_hardirqs_off+0xd/0x10
    Oct 18 21:41:17 dhcp47-74 kernel: [<ffffffff812ddb76>] ? acpi_idle_enter_bm+0x227/0x25b
    Oct 18 21:41:17 dhcp47-74 kernel: [<ffffffff812ddb71>] ? acpi_idle_enter_bm+0x222/0x25b
    Oct 18 21:41:17 dhcp47-74 kernel: [<ffffffff813eda63>] cpuidle_idle_call+0x103/0x290
    Oct 18 21:41:17 dhcp47-74 kernel: [<ffffffff81002155>] cpu_idle+0xe5/0x160
    Oct 18 21:41:17 dhcp47-74 kernel: [<ffffffff814e7f50>] rest_init+0xe0/0xf0
    Oct 18 21:41:17 dhcp47-74 kernel: [<ffffffff814e7e70>] ? csum_partial_copy_generic+0x170/0x170
    Oct 18 21:41:17 dhcp47-74 kernel: [<ffffffff81df8e23>] start_kernel+0x3fc/0x407
    Oct 18 21:41:17 dhcp47-74 kernel: [<ffffffff81df8321>] x86_64_start_reservations+0x131/0x135
    Oct 18 21:41:17 dhcp47-74 kernel: [<ffffffff81df8412>] x86_64_start_kernel+0xed/0xf4
    Oct 18 21:41:17 dhcp47-74 kernel: xhci_hcd 0000:00:14.0: xHCI host not responding to stop endpoint command.
    Oct 18 21:41:17 dhcp47-74 kernel: xhci_hcd 0000:00:14.0: Assuming host is dying, halting host.
    Oct 18 21:41:17 dhcp47-74 kernel: xhci_hcd 0000:00:14.0: HC died; cleaning up
    Oct 18 21:41:17 dhcp47-74 kernel: usb 3-4: device descriptor read/8, error -110
    Oct 18 21:41:17 dhcp47-74 kernel: usb 3-4: device descriptor read/8, error -22
    Oct 18 21:41:17 dhcp47-74 kernel: hub 3-0:1.0: cannot disable port 4 (err = -19)
    
    Basically what is happening is in xhci_stop_endpoint_command_watchdog()
    the xhci->lock is grabbed with just spin_lock.  What lockdep deduces is
    that if an interrupt occurred while in this function it would deadlock
    with xhci_irq because that function also grabs the xhci->lock.
    
    Fixing it is trivial by using spin_lock_irqsave instead.
    
    This should be queued to stable kernels as far back as 2.6.33.
    
    Signed-off-by: Don Zickus <dzickus@redhat.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 6b17329bbf8b902dcd1f5a0f94d43f902b72f682
Author: Don Zickus <dzickus@redhat.com>
Date:   Thu Oct 20 23:52:14 2011 -0400

    usb, xhci: fix lockdep warning on endpoint timeout
    
    commit f43d623164022dcbf6750ef220b7a1133a1183eb upstream.
    
    While debugging a usb3 problem, I stumbled upon this lockdep warning.
    
    Oct 18 21:41:17 dhcp47-74 kernel: =================================
    Oct 18 21:41:17 dhcp47-74 kernel: [ INFO: inconsistent lock state ]
    Oct 18 21:41:17 dhcp47-74 kernel: 3.1.0-rc4nmi+ #456
    Oct 18 21:41:17 dhcp47-74 kernel: ---------------------------------
    Oct 18 21:41:17 dhcp47-74 kernel: inconsistent {IN-HARDIRQ-W} -> {HARDIRQ-ON-W} usage.
    Oct 18 21:41:17 dhcp47-74 kernel: swapper/0 [HC0[0]:SC1[1]:HE1:SE0] takes:
    Oct 18 21:41:17 dhcp47-74 kernel: (&(&xhci->lock)->rlock){?.-...}, at: [<ffffffffa0228990>] xhci_stop_endpoint_command_watchdog+0x30/0x340 [xhci_hcd]
    Oct 18 21:41:17 dhcp47-74 kernel: {IN-HARDIRQ-W} state was registered at:
    Oct 18 21:41:17 dhcp47-74 kernel:  [<ffffffff8109a941>] __lock_acquire+0x781/0x1660
    Oct 18 21:41:17 dhcp47-74 kernel:  [<ffffffff8109bed7>] lock_acquire+0x97/0x170
    Oct 18 21:41:17 dhcp47-74 kernel:  [<ffffffff81501b46>] _raw_spin_lock+0x46/0x80
    Oct 18 21:41:17 dhcp47-74 kernel:  [<ffffffffa02299fa>] xhci_irq+0x3a/0x1960 [xhci_hcd]
    Oct 18 21:41:17 dhcp47-74 kernel:  [<ffffffffa022b351>] xhci_msi_irq+0x31/0x40 [xhci_hcd]
    Oct 18 21:41:17 dhcp47-74 kernel:  [<ffffffff810d2305>] handle_irq_event_percpu+0x85/0x320
    Oct 18 21:41:17 dhcp47-74 kernel:  [<ffffffff810d25e8>] handle_irq_event+0x48/0x70
    Oct 18 21:41:17 dhcp47-74 kernel:  [<ffffffff810d537d>] handle_edge_irq+0x6d/0x130
    Oct 18 21:41:17 dhcp47-74 kernel:  [<ffffffff810048c9>] handle_irq+0x49/0xa0
    Oct 18 21:41:17 dhcp47-74 kernel:  [<ffffffff8150d56d>] do_IRQ+0x5d/0xe0
    Oct 18 21:41:17 dhcp47-74 kernel:  [<ffffffff815029b0>] ret_from_intr+0x0/0x13
    Oct 18 21:41:17 dhcp47-74 kernel:  [<ffffffff81388aca>] usb_set_device_state+0x8a/0x180
    Oct 18 21:41:17 dhcp47-74 kernel:  [<ffffffff8138f038>] usb_add_hcd+0x2b8/0x730
    Oct 18 21:41:17 dhcp47-74 kernel:  [<ffffffffa022ed7e>] xhci_pci_probe+0x9e/0xd4 [xhci_hcd]
    Oct 18 21:41:17 dhcp47-74 kernel:  [<ffffffff8127915f>] local_pci_probe+0x5f/0xd0
    Oct 18 21:41:17 dhcp47-74 kernel:  [<ffffffff8127a569>] pci_device_probe+0x119/0x120
    Oct 18 21:41:17 dhcp47-74 kernel:  [<ffffffff81334473>] driver_probe_device+0xa3/0x2c0
    Oct 18 21:41:17 dhcp47-74 kernel:  [<ffffffff8133473b>] __driver_attach+0xab/0xb0
    Oct 18 21:41:17 dhcp47-74 kernel:  [<ffffffff8133373c>] bus_for_each_dev+0x6c/0xa0
    Oct 18 21:41:17 dhcp47-74 kernel:  [<ffffffff813341fe>] driver_attach+0x1e/0x20
    Oct 18 21:41:17 dhcp47-74 kernel:  [<ffffffff81333b88>] bus_add_driver+0x1f8/0x2b0
    Oct 18 21:41:17 dhcp47-74 kernel:  [<ffffffff81334df6>] driver_register+0x76/0x140
    Oct 18 21:41:17 dhcp47-74 kernel:  [<ffffffff8127a7c6>] __pci_register_driver+0x66/0xe0
    Oct 18 21:41:17 dhcp47-74 kernel:  [<ffffffffa013c04a>] snd_timer_find+0x4a/0x70 [snd_timer]
    Oct 18 21:41:17 dhcp47-74 kernel:  [<ffffffffa013c00e>] snd_timer_find+0xe/0x70 [snd_timer]
    Oct 18 21:41:17 dhcp47-74 kernel:  [<ffffffff810001d3>] do_one_initcall+0x43/0x180
    Oct 18 21:41:17 dhcp47-74 kernel:  [<ffffffff810a9ed2>] sys_init_module+0x92/0x1f0
    Oct 18 21:41:17 dhcp47-74 kernel:  [<ffffffff8150ab6b>] system_call_fastpath+0x16/0x1b
    Oct 18 21:41:17 dhcp47-74 kernel: irq event stamp: 631984
    Oct 18 21:41:17 dhcp47-74 kernel: hardirqs last  enabled at (631984): [<ffffffff81502720>] _raw_spin_unlock_irq+0x30/0x50
    Oct 18 21:41:17 dhcp47-74 kernel: hardirqs last disabled at (631983): [<ffffffff81501c49>] _raw_spin_lock_irq+0x19/0x90
    Oct 18 21:41:17 dhcp47-74 kernel: softirqs last  enabled at (631980): [<ffffffff8105ff63>] _local_bh_enable+0x13/0x20
    Oct 18 21:41:17 dhcp47-74 kernel: softirqs last disabled at (631981): [<ffffffff8150ce6c>] call_softirq+0x1c/0x30
    Oct 18 21:41:17 dhcp47-74 kernel:
    Oct 18 21:41:17 dhcp47-74 kernel: other info that might help us debug this:
    Oct 18 21:41:17 dhcp47-74 kernel: Possible unsafe locking scenario:
    Oct 18 21:41:17 dhcp47-74 kernel:
    Oct 18 21:41:17 dhcp47-74 kernel:       CPU0
    Oct 18 21:41:17 dhcp47-74 kernel:       ----
    Oct 18 21:41:17 dhcp47-74 kernel:  lock(&(&xhci->lock)->rlock);
    Oct 18 21:41:17 dhcp47-74 kernel:  <Interrupt>
    Oct 18 21:41:17 dhcp47-74 kernel:    lock(&(&xhci->lock)->rlock);
    Oct 18 21:41:17 dhcp47-74 kernel:
    Oct 18 21:41:17 dhcp47-74 kernel: *** DEADLOCK ***
    Oct 18 21:41:17 dhcp47-74 kernel:
    Oct 18 21:41:17 dhcp47-74 kernel: 1 lock held by swapper/0:
    Oct 18 21:41:17 dhcp47-74 kernel: #0:  (&ep->stop_cmd_timer){+.-...}, at: [<ffffffff8106abf2>] run_timer_softirq+0x162/0x570
    Oct 18 21:41:17 dhcp47-74 kernel:
    Oct 18 21:41:17 dhcp47-74 kernel: stack backtrace:
    Oct 18 21:41:17 dhcp47-74 kernel: Pid: 0, comm: swapper Tainted: G        W   3.1.0-rc4nmi+ #456
    Oct 18 21:41:17 dhcp47-74 kernel: Call Trace:
    Oct 18 21:41:17 dhcp47-74 kernel: <IRQ>  [<ffffffff81098ed7>] print_usage_bug+0x227/0x270
    Oct 18 21:41:17 dhcp47-74 kernel: [<ffffffff810999c6>] mark_lock+0x346/0x410
    Oct 18 21:41:17 dhcp47-74 kernel: [<ffffffff8109a7de>] __lock_acquire+0x61e/0x1660
    Oct 18 21:41:17 dhcp47-74 kernel: [<ffffffff81099893>] ? mark_lock+0x213/0x410
    Oct 18 21:41:17 dhcp47-74 kernel: [<ffffffff8109bed7>] lock_acquire+0x97/0x170
    Oct 18 21:41:17 dhcp47-74 kernel: [<ffffffffa0228990>] ? xhci_stop_endpoint_command_watchdog+0x30/0x340 [xhci_hcd]
    Oct 18 21:41:17 dhcp47-74 kernel: [<ffffffff81501b46>] _raw_spin_lock+0x46/0x80
    Oct 18 21:41:17 dhcp47-74 kernel: [<ffffffffa0228990>] ? xhci_stop_endpoint_command_watchdog+0x30/0x340 [xhci_hcd]
    Oct 18 21:41:17 dhcp47-74 kernel: [<ffffffffa0228990>] xhci_stop_endpoint_command_watchdog+0x30/0x340 [xhci_hcd]
    Oct 18 21:41:17 dhcp47-74 kernel: [<ffffffff8106abf2>] ? run_timer_softirq+0x162/0x570
    Oct 18 21:41:17 dhcp47-74 kernel: [<ffffffff8106ac9d>] run_timer_softirq+0x20d/0x570
    Oct 18 21:41:17 dhcp47-74 kernel: [<ffffffff8106abf2>] ? run_timer_softirq+0x162/0x570
    Oct 18 21:41:17 dhcp47-74 kernel: [<ffffffffa0228960>] ? xhci_queue_isoc_tx_prepare+0x8e0/0x8e0 [xhci_hcd]
    Oct 18 21:41:17 dhcp47-74 kernel: [<ffffffff810604d2>] __do_softirq+0xf2/0x3f0
    Oct 18 21:41:17 dhcp47-74 kernel: [<ffffffff81020edd>] ? lapic_next_event+0x1d/0x30
    Oct 18 21:41:17 dhcp47-74 kernel: [<ffffffff81090d4e>] ? clockevents_program_event+0x5e/0x90
    Oct 18 21:41:17 dhcp47-74 kernel: [<ffffffff8150ce6c>] call_softirq+0x1c/0x30
    Oct 18 21:41:17 dhcp47-74 kernel: [<ffffffff8100484d>] do_softirq+0x8d/0xc0
    Oct 18 21:41:17 dhcp47-74 kernel: [<ffffffff8105ff35>] irq_exit+0xe5/0x100
    Oct 18 21:41:17 dhcp47-74 kernel: [<ffffffff8150d65e>] smp_apic_timer_interrupt+0x6e/0x99
    Oct 18 21:41:17 dhcp47-74 kernel: [<ffffffff8150b6f0>] apic_timer_interrupt+0x70/0x80
    Oct 18 21:41:17 dhcp47-74 kernel: <EOI>  [<ffffffff81095d8d>] ? trace_hardirqs_off+0xd/0x10
    Oct 18 21:41:17 dhcp47-74 kernel: [<ffffffff812ddb76>] ? acpi_idle_enter_bm+0x227/0x25b
    Oct 18 21:41:17 dhcp47-74 kernel: [<ffffffff812ddb71>] ? acpi_idle_enter_bm+0x222/0x25b
    Oct 18 21:41:17 dhcp47-74 kernel: [<ffffffff813eda63>] cpuidle_idle_call+0x103/0x290
    Oct 18 21:41:17 dhcp47-74 kernel: [<ffffffff81002155>] cpu_idle+0xe5/0x160
    Oct 18 21:41:17 dhcp47-74 kernel: [<ffffffff814e7f50>] rest_init+0xe0/0xf0
    Oct 18 21:41:17 dhcp47-74 kernel: [<ffffffff814e7e70>] ? csum_partial_copy_generic+0x170/0x170
    Oct 18 21:41:17 dhcp47-74 kernel: [<ffffffff81df8e23>] start_kernel+0x3fc/0x407
    Oct 18 21:41:17 dhcp47-74 kernel: [<ffffffff81df8321>] x86_64_start_reservations+0x131/0x135
    Oct 18 21:41:17 dhcp47-74 kernel: [<ffffffff81df8412>] x86_64_start_kernel+0xed/0xf4
    Oct 18 21:41:17 dhcp47-74 kernel: xhci_hcd 0000:00:14.0: xHCI host not responding to stop endpoint command.
    Oct 18 21:41:17 dhcp47-74 kernel: xhci_hcd 0000:00:14.0: Assuming host is dying, halting host.
    Oct 18 21:41:17 dhcp47-74 kernel: xhci_hcd 0000:00:14.0: HC died; cleaning up
    Oct 18 21:41:17 dhcp47-74 kernel: usb 3-4: device descriptor read/8, error -110
    Oct 18 21:41:17 dhcp47-74 kernel: usb 3-4: device descriptor read/8, error -22
    Oct 18 21:41:17 dhcp47-74 kernel: hub 3-0:1.0: cannot disable port 4 (err = -19)
    
    Basically what is happening is in xhci_stop_endpoint_command_watchdog()
    the xhci->lock is grabbed with just spin_lock.  What lockdep deduces is
    that if an interrupt occurred while in this function it would deadlock
    with xhci_irq because that function also grabs the xhci->lock.
    
    Fixing it is trivial by using spin_lock_irqsave instead.
    
    This should be queued to stable kernels as far back as 2.6.33.
    
    Signed-off-by: Don Zickus <dzickus@redhat.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 68568add2ca70153cca3dd1858eaa0776821cf75
Author: Anton Blanchard <anton@samba.org>
Date:   Wed Nov 23 20:07:20 2011 +0000

    powerpc/time: Remove unnecessary sanity check of decrementer expiration
    
    The clockevents code uses max_delta_ns to avoid calling a
    clockevent with too large a value.
    
    Remove the redundant version of this in the timer_interrupt
    code.
    
    Signed-off-by: Anton Blanchard <anton@samba.org>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

commit d8afc6fd95496204174f19af0cb39eefee0c3e8a
Author: Anton Blanchard <anton@samba.org>
Date:   Wed Nov 23 20:07:18 2011 +0000

    powerpc/time: Use clockevents_calc_mult_shift
    
    We can use clockevents_calc_mult_shift instead of doing all
    the work ourselves.
    
    Signed-off-by: Anton Blanchard <anton@samba.org>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

commit 27fdb577435e336e4b00b9e51626f9002b88a86c
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Tue Nov 8 10:34:10 2011 -0800

    msm: timer: Use clockevents_config_and_register()
    
    Don't open code the min/max delta logic. Use the generic
    version instead. Also expand the number of bits we can handle
    because there isn't anything that says we can't handle all 32
    bits.
    
    Before:
     max_delta_ns:   122880426391799
     min_delta_ns:   122070
     mult:           140737
     shift:          32
    
    After:
     max_delta_ns:   131071523464981
     min_delta_ns:   122069
     mult:           70369
     shift:          31
    
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: David Brown <davidb@codeaurora.org>

commit dd15ab814149df65187943c32ca09e4eeaac0047
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Tue Nov 8 10:34:05 2011 -0800

    msm: timer: Use GPT for clockevents and DGT for clocksource
    
    The clocksource shouldn't stop ticking when the clockevent stops.
    This is exactly what happens today with MSM timers. The same
    hardware is used for both the clockevent and the clocksource
    because the ratings of the two are the same.
    
    Fix this by registering a clockevent based on the GPT and a
    clocksource based on the DGT. This removes any other possible
    configuration (e.g. a GPT clocksource and a DGT clockevent) but
    that shouldn't be a big issue since we want higher precision
    timing than high precision scheduling interrupts.
    
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: David Brown <davidb@codeaurora.org>

commit 8658ca730fa66fd6b8c559315915c774330f35bb
Author: Maxin B. John <maxin.john@gmail.com>
Date:   Wed Nov 9 11:12:58 2011 +0100

    ARM: 7153/1: mach-bcmring: fix build error in core.c
    
    Fixes this build error:
    
    CC      arch/arm/mach-bcmring/core.o
    arch/arm/mach-bcmring/core.c: In function 'bcmring_init_timer':
    arch/arm/mach-bcmring/core.c:238: error: implicit declaration of function 'sp804_clockevents_register'
    make[1]: *** [arch/arm/mach-bcmring/core.o] Error 1
    make: *** [arch/arm/mach-bcmring] Error 2
    
    Signed-off-by: Maxin B. John <maxin.john@gmail.com>
    Reviewed-by: Jiandong Zheng <jdzheng@broadcom.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

commit f43d623164022dcbf6750ef220b7a1133a1183eb
Author: Don Zickus <dzickus@redhat.com>
Date:   Thu Oct 20 23:52:14 2011 -0400

    usb, xhci: fix lockdep warning on endpoint timeout
    
    While debugging a usb3 problem, I stumbled upon this lockdep warning.
    
    Oct 18 21:41:17 dhcp47-74 kernel: =================================
    Oct 18 21:41:17 dhcp47-74 kernel: [ INFO: inconsistent lock state ]
    Oct 18 21:41:17 dhcp47-74 kernel: 3.1.0-rc4nmi+ #456
    Oct 18 21:41:17 dhcp47-74 kernel: ---------------------------------
    Oct 18 21:41:17 dhcp47-74 kernel: inconsistent {IN-HARDIRQ-W} -> {HARDIRQ-ON-W} usage.
    Oct 18 21:41:17 dhcp47-74 kernel: swapper/0 [HC0[0]:SC1[1]:HE1:SE0] takes:
    Oct 18 21:41:17 dhcp47-74 kernel: (&(&xhci->lock)->rlock){?.-...}, at: [<ffffffffa0228990>] xhci_stop_endpoint_command_watchdog+0x30/0x340 [xhci_hcd]
    Oct 18 21:41:17 dhcp47-74 kernel: {IN-HARDIRQ-W} state was registered at:
    Oct 18 21:41:17 dhcp47-74 kernel:  [<ffffffff8109a941>] __lock_acquire+0x781/0x1660
    Oct 18 21:41:17 dhcp47-74 kernel:  [<ffffffff8109bed7>] lock_acquire+0x97/0x170
    Oct 18 21:41:17 dhcp47-74 kernel:  [<ffffffff81501b46>] _raw_spin_lock+0x46/0x80
    Oct 18 21:41:17 dhcp47-74 kernel:  [<ffffffffa02299fa>] xhci_irq+0x3a/0x1960 [xhci_hcd]
    Oct 18 21:41:17 dhcp47-74 kernel:  [<ffffffffa022b351>] xhci_msi_irq+0x31/0x40 [xhci_hcd]
    Oct 18 21:41:17 dhcp47-74 kernel:  [<ffffffff810d2305>] handle_irq_event_percpu+0x85/0x320
    Oct 18 21:41:17 dhcp47-74 kernel:  [<ffffffff810d25e8>] handle_irq_event+0x48/0x70
    Oct 18 21:41:17 dhcp47-74 kernel:  [<ffffffff810d537d>] handle_edge_irq+0x6d/0x130
    Oct 18 21:41:17 dhcp47-74 kernel:  [<ffffffff810048c9>] handle_irq+0x49/0xa0
    Oct 18 21:41:17 dhcp47-74 kernel:  [<ffffffff8150d56d>] do_IRQ+0x5d/0xe0
    Oct 18 21:41:17 dhcp47-74 kernel:  [<ffffffff815029b0>] ret_from_intr+0x0/0x13
    Oct 18 21:41:17 dhcp47-74 kernel:  [<ffffffff81388aca>] usb_set_device_state+0x8a/0x180
    Oct 18 21:41:17 dhcp47-74 kernel:  [<ffffffff8138f038>] usb_add_hcd+0x2b8/0x730
    Oct 18 21:41:17 dhcp47-74 kernel:  [<ffffffffa022ed7e>] xhci_pci_probe+0x9e/0xd4 [xhci_hcd]
    Oct 18 21:41:17 dhcp47-74 kernel:  [<ffffffff8127915f>] local_pci_probe+0x5f/0xd0
    Oct 18 21:41:17 dhcp47-74 kernel:  [<ffffffff8127a569>] pci_device_probe+0x119/0x120
    Oct 18 21:41:17 dhcp47-74 kernel:  [<ffffffff81334473>] driver_probe_device+0xa3/0x2c0
    Oct 18 21:41:17 dhcp47-74 kernel:  [<ffffffff8133473b>] __driver_attach+0xab/0xb0
    Oct 18 21:41:17 dhcp47-74 kernel:  [<ffffffff8133373c>] bus_for_each_dev+0x6c/0xa0
    Oct 18 21:41:17 dhcp47-74 kernel:  [<ffffffff813341fe>] driver_attach+0x1e/0x20
    Oct 18 21:41:17 dhcp47-74 kernel:  [<ffffffff81333b88>] bus_add_driver+0x1f8/0x2b0
    Oct 18 21:41:17 dhcp47-74 kernel:  [<ffffffff81334df6>] driver_register+0x76/0x140
    Oct 18 21:41:17 dhcp47-74 kernel:  [<ffffffff8127a7c6>] __pci_register_driver+0x66/0xe0
    Oct 18 21:41:17 dhcp47-74 kernel:  [<ffffffffa013c04a>] snd_timer_find+0x4a/0x70 [snd_timer]
    Oct 18 21:41:17 dhcp47-74 kernel:  [<ffffffffa013c00e>] snd_timer_find+0xe/0x70 [snd_timer]
    Oct 18 21:41:17 dhcp47-74 kernel:  [<ffffffff810001d3>] do_one_initcall+0x43/0x180
    Oct 18 21:41:17 dhcp47-74 kernel:  [<ffffffff810a9ed2>] sys_init_module+0x92/0x1f0
    Oct 18 21:41:17 dhcp47-74 kernel:  [<ffffffff8150ab6b>] system_call_fastpath+0x16/0x1b
    Oct 18 21:41:17 dhcp47-74 kernel: irq event stamp: 631984
    Oct 18 21:41:17 dhcp47-74 kernel: hardirqs last  enabled at (631984): [<ffffffff81502720>] _raw_spin_unlock_irq+0x30/0x50
    Oct 18 21:41:17 dhcp47-74 kernel: hardirqs last disabled at (631983): [<ffffffff81501c49>] _raw_spin_lock_irq+0x19/0x90
    Oct 18 21:41:17 dhcp47-74 kernel: softirqs last  enabled at (631980): [<ffffffff8105ff63>] _local_bh_enable+0x13/0x20
    Oct 18 21:41:17 dhcp47-74 kernel: softirqs last disabled at (631981): [<ffffffff8150ce6c>] call_softirq+0x1c/0x30
    Oct 18 21:41:17 dhcp47-74 kernel:
    Oct 18 21:41:17 dhcp47-74 kernel: other info that might help us debug this:
    Oct 18 21:41:17 dhcp47-74 kernel: Possible unsafe locking scenario:
    Oct 18 21:41:17 dhcp47-74 kernel:
    Oct 18 21:41:17 dhcp47-74 kernel:       CPU0
    Oct 18 21:41:17 dhcp47-74 kernel:       ----
    Oct 18 21:41:17 dhcp47-74 kernel:  lock(&(&xhci->lock)->rlock);
    Oct 18 21:41:17 dhcp47-74 kernel:  <Interrupt>
    Oct 18 21:41:17 dhcp47-74 kernel:    lock(&(&xhci->lock)->rlock);
    Oct 18 21:41:17 dhcp47-74 kernel:
    Oct 18 21:41:17 dhcp47-74 kernel: *** DEADLOCK ***
    Oct 18 21:41:17 dhcp47-74 kernel:
    Oct 18 21:41:17 dhcp47-74 kernel: 1 lock held by swapper/0:
    Oct 18 21:41:17 dhcp47-74 kernel: #0:  (&ep->stop_cmd_timer){+.-...}, at: [<ffffffff8106abf2>] run_timer_softirq+0x162/0x570
    Oct 18 21:41:17 dhcp47-74 kernel:
    Oct 18 21:41:17 dhcp47-74 kernel: stack backtrace:
    Oct 18 21:41:17 dhcp47-74 kernel: Pid: 0, comm: swapper Tainted: G        W   3.1.0-rc4nmi+ #456
    Oct 18 21:41:17 dhcp47-74 kernel: Call Trace:
    Oct 18 21:41:17 dhcp47-74 kernel: <IRQ>  [<ffffffff81098ed7>] print_usage_bug+0x227/0x270
    Oct 18 21:41:17 dhcp47-74 kernel: [<ffffffff810999c6>] mark_lock+0x346/0x410
    Oct 18 21:41:17 dhcp47-74 kernel: [<ffffffff8109a7de>] __lock_acquire+0x61e/0x1660
    Oct 18 21:41:17 dhcp47-74 kernel: [<ffffffff81099893>] ? mark_lock+0x213/0x410
    Oct 18 21:41:17 dhcp47-74 kernel: [<ffffffff8109bed7>] lock_acquire+0x97/0x170
    Oct 18 21:41:17 dhcp47-74 kernel: [<ffffffffa0228990>] ? xhci_stop_endpoint_command_watchdog+0x30/0x340 [xhci_hcd]
    Oct 18 21:41:17 dhcp47-74 kernel: [<ffffffff81501b46>] _raw_spin_lock+0x46/0x80
    Oct 18 21:41:17 dhcp47-74 kernel: [<ffffffffa0228990>] ? xhci_stop_endpoint_command_watchdog+0x30/0x340 [xhci_hcd]
    Oct 18 21:41:17 dhcp47-74 kernel: [<ffffffffa0228990>] xhci_stop_endpoint_command_watchdog+0x30/0x340 [xhci_hcd]
    Oct 18 21:41:17 dhcp47-74 kernel: [<ffffffff8106abf2>] ? run_timer_softirq+0x162/0x570
    Oct 18 21:41:17 dhcp47-74 kernel: [<ffffffff8106ac9d>] run_timer_softirq+0x20d/0x570
    Oct 18 21:41:17 dhcp47-74 kernel: [<ffffffff8106abf2>] ? run_timer_softirq+0x162/0x570
    Oct 18 21:41:17 dhcp47-74 kernel: [<ffffffffa0228960>] ? xhci_queue_isoc_tx_prepare+0x8e0/0x8e0 [xhci_hcd]
    Oct 18 21:41:17 dhcp47-74 kernel: [<ffffffff810604d2>] __do_softirq+0xf2/0x3f0
    Oct 18 21:41:17 dhcp47-74 kernel: [<ffffffff81020edd>] ? lapic_next_event+0x1d/0x30
    Oct 18 21:41:17 dhcp47-74 kernel: [<ffffffff81090d4e>] ? clockevents_program_event+0x5e/0x90
    Oct 18 21:41:17 dhcp47-74 kernel: [<ffffffff8150ce6c>] call_softirq+0x1c/0x30
    Oct 18 21:41:17 dhcp47-74 kernel: [<ffffffff8100484d>] do_softirq+0x8d/0xc0
    Oct 18 21:41:17 dhcp47-74 kernel: [<ffffffff8105ff35>] irq_exit+0xe5/0x100
    Oct 18 21:41:17 dhcp47-74 kernel: [<ffffffff8150d65e>] smp_apic_timer_interrupt+0x6e/0x99
    Oct 18 21:41:17 dhcp47-74 kernel: [<ffffffff8150b6f0>] apic_timer_interrupt+0x70/0x80
    Oct 18 21:41:17 dhcp47-74 kernel: <EOI>  [<ffffffff81095d8d>] ? trace_hardirqs_off+0xd/0x10
    Oct 18 21:41:17 dhcp47-74 kernel: [<ffffffff812ddb76>] ? acpi_idle_enter_bm+0x227/0x25b
    Oct 18 21:41:17 dhcp47-74 kernel: [<ffffffff812ddb71>] ? acpi_idle_enter_bm+0x222/0x25b
    Oct 18 21:41:17 dhcp47-74 kernel: [<ffffffff813eda63>] cpuidle_idle_call+0x103/0x290
    Oct 18 21:41:17 dhcp47-74 kernel: [<ffffffff81002155>] cpu_idle+0xe5/0x160
    Oct 18 21:41:17 dhcp47-74 kernel: [<ffffffff814e7f50>] rest_init+0xe0/0xf0
    Oct 18 21:41:17 dhcp47-74 kernel: [<ffffffff814e7e70>] ? csum_partial_copy_generic+0x170/0x170
    Oct 18 21:41:17 dhcp47-74 kernel: [<ffffffff81df8e23>] start_kernel+0x3fc/0x407
    Oct 18 21:41:17 dhcp47-74 kernel: [<ffffffff81df8321>] x86_64_start_reservations+0x131/0x135
    Oct 18 21:41:17 dhcp47-74 kernel: [<ffffffff81df8412>] x86_64_start_kernel+0xed/0xf4
    Oct 18 21:41:17 dhcp47-74 kernel: xhci_hcd 0000:00:14.0: xHCI host not responding to stop endpoint command.
    Oct 18 21:41:17 dhcp47-74 kernel: xhci_hcd 0000:00:14.0: Assuming host is dying, halting host.
    Oct 18 21:41:17 dhcp47-74 kernel: xhci_hcd 0000:00:14.0: HC died; cleaning up
    Oct 18 21:41:17 dhcp47-74 kernel: usb 3-4: device descriptor read/8, error -110
    Oct 18 21:41:17 dhcp47-74 kernel: usb 3-4: device descriptor read/8, error -22
    Oct 18 21:41:17 dhcp47-74 kernel: hub 3-0:1.0: cannot disable port 4 (err = -19)
    
    Basically what is happening is in xhci_stop_endpoint_command_watchdog()
    the xhci->lock is grabbed with just spin_lock.  What lockdep deduces is
    that if an interrupt occurred while in this function it would deadlock
    with xhci_irq because that function also grabs the xhci->lock.
    
    Fixing it is trivial by using spin_lock_irqsave instead.
    
    This should be queued to stable kernels as far back as 2.6.33.
    
    Signed-off-by: Don Zickus <dzickus@redhat.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Cc: stable@kernel.org

commit 8efd072b32d67436413e98e25e9a316216e88900
Author: Vincent Guittot <vincent.guittot@linaro.org>
Date:   Thu Aug 25 08:31:20 2011 +0200

    [CPUFREQ] ARM: ux500: send cpufreq notification for all cpus
    
    The same clock is used for all cpus so we must notify the frequency change
    for each one in order to update the configuration of all twd clockevents.
    
    change since V1:
    * use policy->cpus instead of cpu_online_mask
    
    Signed-off-by: Vincent Guittot <vincent.guittot@linaro.org>
    Signed-off-by: Dave Jones <davej@redhat.com>

commit 39adff5f69d6849ca22353a88058c9f8630528c0
Merge: 8a4a8918ed6e e35f95b36e43
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Oct 26 17:15:03 2011 +0200

    Merge branch 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    * 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (23 commits)
      time, s390: Get rid of compile warning
      dw_apb_timer: constify clocksource name
      time: Cleanup old CONFIG_GENERIC_TIME references that snuck in
      time: Change jiffies_to_clock_t() argument type to unsigned long
      alarmtimers: Fix error handling
      clocksource: Make watchdog reset lockless
      posix-cpu-timers: Cure SMP accounting oddities
      s390: Use direct ktime path for s390 clockevent device
      clockevents: Add direct ktime programming function
      clockevents: Make minimum delay adjustments configurable
      nohz: Remove "Switched to NOHz mode" debugging messages
      proc: Consider NO_HZ when printing idle and iowait times
      nohz: Make idle/iowait counter update conditional
      nohz: Fix update_ts_time_stat idle accounting
      cputime: Clean up cputime_to_usecs and usecs_to_cputime macros
      alarmtimers: Rework RTC device selection using class interface
      alarmtimers: Add try_to_cancel functionality
      alarmtimers: Add more refined alarm state tracking
      alarmtimers: Remove period from alarm structure
      alarmtimers: Remove interval cap limit hack
      ...

commit 65516f8a7c2028381f0dae4c16ddb621c96158cc
Author: Martin Schwidefsky <schwidefsky@de.ibm.com>
Date:   Tue Aug 23 15:29:43 2011 +0200

    clockevents: Add direct ktime programming function
    
    There is at least one architecture (s390) with a sane clockevent device
    that can be programmed with the equivalent of a ktime. No need to create
    a delta against the current time, the ktime can be used directly.
    
    A new clock device function 'set_next_ktime' is introduced that is called
    with the unmodified ktime for the timer if the clock event device has the
    CLOCK_EVT_FEAT_KTIME bit set.
    
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: john stultz <johnstul@us.ibm.com>
    Link: http://lkml.kernel.org/r/20110823133142.815350967@de.ibm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit d1748302f70be7469809809283fe164156a34231
Author: Martin Schwidefsky <schwidefsky@de.ibm.com>
Date:   Tue Aug 23 15:29:42 2011 +0200

    clockevents: Make minimum delay adjustments configurable
    
    The automatic increase of the min_delta_ns of a clockevents device
    should be done in the clockevents code as the minimum delay is an
    attribute of the clockevents device.
    
    In addition not all architectures want the automatic adjustment, on a
    massively virtualized system it can happen that the programming of a
    clock event fails several times in a row because the virtual cpu has
    been rescheduled quickly enough. In that case the minimum delay will
    erroneously be increased with no way back. The new config symbol
    GENERIC_CLOCKEVENTS_MIN_ADJUST is used to enable the automatic
    adjustment. The config option is selected only for x86.
    
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: john stultz <johnstul@us.ibm.com>
    Link: http://lkml.kernel.org/r/20110823133142.494157493@de.ibm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 90e93648c41bd29a72f6ec55ce27a23c209eab8c
Merge: 3ae627b5a6c8 25904157168d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Aug 29 16:34:07 2011 -0700

    Merge branch 'fixes' of master.kernel.org:/home/rmk/linux-2.6-arm
    
    * 'fixes' of master.kernel.org:/home/rmk/linux-2.6-arm:
      ARM: pm: avoid writing the auxillary control register for ARMv7
      ARM: pm: some ARMv7 requires a dsb in resume to ensure correctness
      ARM: pm: arm920/926: fix number of registers saved
      ARM: pm: CPU specific code should not overwrite r1 (v:p offset)
      ARM: 7066/1: proc-v7: disable SCTLR.TE when disabling MMU
      ARM: 7065/1: kexec: ensure new kernel is entered in ARM state
      ARM: 7003/1: vexpress: Add clock definition for the SP805.
      ARM: 7051/1: cpuimx* boards: fix mach-types errors
      ARM: 7019/1: Footbridge: select CLKEVT_I8253 for ARCH_NETWINDER
      ARM: 7015/1: ARM errata: Possible cache data corruption with hit-under-miss enabled
      ARM: 7014/1: cache-l2x0: Fix L2 Cache size calculation.
      ARM: 6967/1: ep93xx: ts72xx: fix board model detection
      ARM: 6965/1: ep93xx: add model detection for ts-7300 and ts-7400 boards
      ARM: cache: detect VIPT aliasing I-cache on ARMv6
      ARM: twd: register clockevents device before enabling PPI
      ARM: realview: ensure visibility of writes during reset
      ARM: perf: make name of arm_pmu_type consistent
      ARM: perf: fix prototype of release_pmu
      ARM: fix perf build with uclibc toolchains

commit dfc40b24c0a37593724f3317cd485c73ee878c18
Author: Will Deacon <will.deacon@arm.com>
Date:   Wed Jul 20 14:18:46 2011 +0100

    ARM: twd: register clockevents device before enabling PPI
    
    The smp_twd clockevents driver currently enables the local timer PPI
    before the clockevents device is registered. This can lead to a kernel
    panic if a spurious timer interrupt is generated before registration
    has completed since the kernel will treat it as an IPI timer.
    
    This patch moves the clockevents device registration before the IRQ
    unmasking so that we can always handle timer interrupts once they can
    occur.
    
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

commit 081104261c084dee58518bcbbd23e95910e3fbe3
Author: Milton Miller <miltonm@bga.com>
Date:   Thu May 12 04:13:54 2011 -0500

    seqlock: Don't smp_rmb in seqlock reader spin loop
    
    commit 5db1256a5131d3b133946fa02ac9770a784e6eb2 upstream.
    
    Move the smp_rmb after cpu_relax loop in read_seqlock and add
    ACCESS_ONCE to make sure the test and return are consistent.
    
    A multi-threaded core in the lab didn't like the update
    from 2.6.35 to 2.6.36, to the point it would hang during
    boot when multiple threads were active.  Bisection showed
    af5ab277ded04bd9bc6b048c5a2f0e7d70ef0867 (clockevents:
    Remove the per cpu tick skew) as the culprit and it is
    supported with stack traces showing xtime_lock waits including
    tick_do_update_jiffies64 and/or update_vsyscall.
    
    Experimentation showed the combination of cpu_relax and smp_rmb
    was significantly slowing the progress of other threads sharing
    the core, and this patch is effective in avoiding the hang.
    
    A theory is the rmb is affecting the whole core while the
    cpu_relax is causing a resource rebalance flush, together they
    cause an interfernce cadance that is unbroken when the seqlock
    reader has interrupts disabled.
    
    At first I was confused why the refactor in
    3c22cd5709e8143444a6d08682a87f4c57902df3 (kernel: optimise
    seqlock) didn't affect this patch application, but after some
    study that affected seqcount not seqlock. The new seqcount was
    not factored back into the seqlock.  I defer that the future.
    
    While the removal of the timer interrupt offset created
    contention for the xtime lock while a cpu does the
    additonal work to update the system clock, the seqlock
    implementation with the tight rmb spin loop goes back much
    further, and is just waiting for the right trigger.
    
    Signed-off-by: Milton Miller <miltonm@bga.com>
    Cc: <linuxppc-dev@lists.ozlabs.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Andi Kleen <andi@firstfloor.org>
    Cc: Nick Piggin <npiggin@kernel.dk>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Anton Blanchard <anton@samba.org>
    Cc: Paul McKenney <paulmck@linux.vnet.ibm.com>
    Acked-by: Eric Dumazet <eric.dumazet@gmail.com>
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Link: http://lkml.kernel.org/r/%3Cseqlock-rmb%40mdm.bga.com%3E
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 05ed8490812a2f2b93da5d8e29fd2a1a9a87deb0
Author: Joe Perches <joe@perches.com>
Date:   Mon Jul 25 17:13:14 2011 -0700

    MAINTAINERS: update HIGH RESOLUTION TIMERS patterns
    
    clockchips.h was typoed as clockevents.h
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit e6220bdc9485c5ea972f9e0e6d062a05934bb74b
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Jun 9 13:08:25 2011 +0000

    i8253: Create common clockevent implementation
    
    arm, mips and x86 implement i8253 based clockevents. All the same code
    copied. Create a common implementation in drivers/clocksource/i8253.c.
    
    About time to rename drivers/clocksource/ to something else.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: John Stultz <john.stultz@linaro.org>
    Link: http://lkml.kernel.org/r/20110609130621.921710458@linutronix.de

commit 64323cd54f3a6450bd64aac242df7bd1ade457f3
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Feb 25 22:34:23 2011 +0100

    clockevents: Prevent oneshot mode when broadcast device is periodic
    
    commit 3a142a0672b48a853f00af61f184c7341ac9c99d upstream.
    
    When the per cpu timer is marked CLOCK_EVT_FEAT_C3STOP, then we only
    can switch into oneshot mode, when the backup broadcast device
    supports oneshot mode as well. Otherwise we would try to switch the
    broadcast device into an unsupported mode unconditionally. This went
    unnoticed so far as the current available broadcast devices support
    oneshot mode. Seth unearthed this problem while debugging and working
    around an hpet related BIOS wreckage.
    
    Add the necessary check to tick_is_oneshot_available().
    
    Reported-and-tested-by: Seth Forshee <seth.forshee@canonical.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    LKML-Reference: <alpine.LFD.2.00.1102252231200.2701@localhost6.localdomain6>
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

commit f9d42dd4fc06dac8ccbcdc0f4777c311355b9429
Author: Milton Miller <miltonm@bga.com>
Date:   Thu May 12 04:13:54 2011 -0500

    seqlock: Don't smp_rmb in seqlock reader spin loop
    
    commit 5db1256a5131d3b133946fa02ac9770a784e6eb2 upstream.
    
    Move the smp_rmb after cpu_relax loop in read_seqlock and add
    ACCESS_ONCE to make sure the test and return are consistent.
    
    A multi-threaded core in the lab didn't like the update
    from 2.6.35 to 2.6.36, to the point it would hang during
    boot when multiple threads were active.  Bisection showed
    af5ab277ded04bd9bc6b048c5a2f0e7d70ef0867 (clockevents:
    Remove the per cpu tick skew) as the culprit and it is
    supported with stack traces showing xtime_lock waits including
    tick_do_update_jiffies64 and/or update_vsyscall.
    
    Experimentation showed the combination of cpu_relax and smp_rmb
    was significantly slowing the progress of other threads sharing
    the core, and this patch is effective in avoiding the hang.
    
    A theory is the rmb is affecting the whole core while the
    cpu_relax is causing a resource rebalance flush, together they
    cause an interfernce cadance that is unbroken when the seqlock
    reader has interrupts disabled.
    
    At first I was confused why the refactor in
    3c22cd5709e8143444a6d08682a87f4c57902df3 (kernel: optimise
    seqlock) didn't affect this patch application, but after some
    study that affected seqcount not seqlock. The new seqcount was
    not factored back into the seqlock.  I defer that the future.
    
    While the removal of the timer interrupt offset created
    contention for the xtime lock while a cpu does the
    additonal work to update the system clock, the seqlock
    implementation with the tight rmb spin loop goes back much
    further, and is just waiting for the right trigger.
    
    Signed-off-by: Milton Miller <miltonm@bga.com>
    Cc: <linuxppc-dev@lists.ozlabs.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Andi Kleen <andi@firstfloor.org>
    Cc: Nick Piggin <npiggin@kernel.dk>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Anton Blanchard <anton@samba.org>
    Cc: Paul McKenney <paulmck@linux.vnet.ibm.com>
    Acked-by: Eric Dumazet <eric.dumazet@gmail.com>
    Link: http://lkml.kernel.org/r/%3Cseqlock-rmb%40mdm.bga.com%3E
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit ff3af58772a733945a9a9af5f5b5aaf157609a53
Author: Milton Miller <miltonm@bga.com>
Date:   Thu May 12 04:13:54 2011 -0500

    seqlock: Don't smp_rmb in seqlock reader spin loop
    
    commit 5db1256a5131d3b133946fa02ac9770a784e6eb2 upstream.
    
    Move the smp_rmb after cpu_relax loop in read_seqlock and add
    ACCESS_ONCE to make sure the test and return are consistent.
    
    A multi-threaded core in the lab didn't like the update
    from 2.6.35 to 2.6.36, to the point it would hang during
    boot when multiple threads were active.  Bisection showed
    af5ab277ded04bd9bc6b048c5a2f0e7d70ef0867 (clockevents:
    Remove the per cpu tick skew) as the culprit and it is
    supported with stack traces showing xtime_lock waits including
    tick_do_update_jiffies64 and/or update_vsyscall.
    
    Experimentation showed the combination of cpu_relax and smp_rmb
    was significantly slowing the progress of other threads sharing
    the core, and this patch is effective in avoiding the hang.
    
    A theory is the rmb is affecting the whole core while the
    cpu_relax is causing a resource rebalance flush, together they
    cause an interfernce cadance that is unbroken when the seqlock
    reader has interrupts disabled.
    
    At first I was confused why the refactor in
    3c22cd5709e8143444a6d08682a87f4c57902df3 (kernel: optimise
    seqlock) didn't affect this patch application, but after some
    study that affected seqcount not seqlock. The new seqcount was
    not factored back into the seqlock.  I defer that the future.
    
    While the removal of the timer interrupt offset created
    contention for the xtime lock while a cpu does the
    additonal work to update the system clock, the seqlock
    implementation with the tight rmb spin loop goes back much
    further, and is just waiting for the right trigger.
    
    Signed-off-by: Milton Miller <miltonm@bga.com>
    Cc: <linuxppc-dev@lists.ozlabs.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Andi Kleen <andi@firstfloor.org>
    Cc: Nick Piggin <npiggin@kernel.dk>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Anton Blanchard <anton@samba.org>
    Cc: Paul McKenney <paulmck@linux.vnet.ibm.com>
    Acked-by: Eric Dumazet <eric.dumazet@gmail.com>
    Link: http://lkml.kernel.org/r/%3Cseqlock-rmb%40mdm.bga.com%3E
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit cde21de148a5bf474bbde59ebf046992fab3c77b
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Mon May 30 15:51:47 2011 +0200

    mach-u300: cleanup clockevent code
    
    Use the new clockevents_config_and_register() function to register
    the U300 clockevent, since that code requires ->cpumask to be set
    we set this even on this UP system to please the framework.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

commit 7d7975a0e1da7d6e558211b6296a96f1d6bf60ce
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sat Jun 11 00:46:17 2011 +0100

    ARM: footbridge: fix clock event support
    
    4e8d7637 (ARM: footbridge: convert to clockevents/clocksource) did
    not set the cpumask for the clock event device.  This causes boot
    to fail.  Add the necessary initialization.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

commit ecff4fcc7bbaf060646d2160123f8dc02605a047
Merge: 58a9a36b5444 1c3cc1160211
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jun 7 19:07:22 2011 -0700

    Merge branch 'timers-fixes-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'timers-fixes-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip:
      timers: Consider slack value in mod_timer()
      clockevents: Handle empty cpumask gracefully

commit 1b054b67d3bfc6dca9f634c104780f3f24ff3eec
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Jun 3 11:13:33 2011 +0200

    clockevents: Handle empty cpumask gracefully
    
    For UP it's stupid to request an initialized cpumask for the clock
    event devices. Though we need the mask set even on UP to avoid a
    horrible ifdeffery especially in the broadcast code.
    
    For SMP we can at least try to survive with a warning and set the
    cpumask of the cpu we're running on. That gives a decent chance to
    bring the machine up and retrieve the debug info.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Linus Walleij <linus.walleij@linaro.org
    Cc: Lee Jones <lee.jones@linaro.org>
    Cc: Russell King - ARM Linux <linux@arm.linux.org.uk>
    Cc: Stephen Boyd <sboyd@codeaurora.org>

commit 8a5167a5fc4e06cc1b4281eff1b3f884003bb7e2
Author: Milton Miller <miltonm@bga.com>
Date:   Thu May 12 04:13:54 2011 -0500

    seqlock: Don't smp_rmb in seqlock reader spin loop
    
    commit 5db1256a5131d3b133946fa02ac9770a784e6eb2 upstream.
    
    Move the smp_rmb after cpu_relax loop in read_seqlock and add
    ACCESS_ONCE to make sure the test and return are consistent.
    
    A multi-threaded core in the lab didn't like the update
    from 2.6.35 to 2.6.36, to the point it would hang during
    boot when multiple threads were active.  Bisection showed
    af5ab277ded04bd9bc6b048c5a2f0e7d70ef0867 (clockevents:
    Remove the per cpu tick skew) as the culprit and it is
    supported with stack traces showing xtime_lock waits including
    tick_do_update_jiffies64 and/or update_vsyscall.
    
    Experimentation showed the combination of cpu_relax and smp_rmb
    was significantly slowing the progress of other threads sharing
    the core, and this patch is effective in avoiding the hang.
    
    A theory is the rmb is affecting the whole core while the
    cpu_relax is causing a resource rebalance flush, together they
    cause an interfernce cadance that is unbroken when the seqlock
    reader has interrupts disabled.
    
    At first I was confused why the refactor in
    3c22cd5709e8143444a6d08682a87f4c57902df3 (kernel: optimise
    seqlock) didn't affect this patch application, but after some
    study that affected seqcount not seqlock. The new seqcount was
    not factored back into the seqlock.  I defer that the future.
    
    While the removal of the timer interrupt offset created
    contention for the xtime lock while a cpu does the
    additonal work to update the system clock, the seqlock
    implementation with the tight rmb spin loop goes back much
    further, and is just waiting for the right trigger.
    
    Signed-off-by: Milton Miller <miltonm@bga.com>
    Cc: <linuxppc-dev@lists.ozlabs.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Andi Kleen <andi@firstfloor.org>
    Cc: Nick Piggin <npiggin@kernel.dk>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Anton Blanchard <anton@samba.org>
    Cc: Paul McKenney <paulmck@linux.vnet.ibm.com>
    Acked-by: Eric Dumazet <eric.dumazet@gmail.com>
    Link: http://lkml.kernel.org/r/%3Cseqlock-rmb%40mdm.bga.com%3E
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 395b93001142c32243d471c391c319f9bbe91dae
Author: Milton Miller <miltonm@bga.com>
Date:   Thu May 12 04:13:54 2011 -0500

    seqlock: Don't smp_rmb in seqlock reader spin loop
    
    commit 5db1256a5131d3b133946fa02ac9770a784e6eb2 upstream.
    
    Move the smp_rmb after cpu_relax loop in read_seqlock and add
    ACCESS_ONCE to make sure the test and return are consistent.
    
    A multi-threaded core in the lab didn't like the update
    from 2.6.35 to 2.6.36, to the point it would hang during
    boot when multiple threads were active.  Bisection showed
    af5ab277ded04bd9bc6b048c5a2f0e7d70ef0867 (clockevents:
    Remove the per cpu tick skew) as the culprit and it is
    supported with stack traces showing xtime_lock waits including
    tick_do_update_jiffies64 and/or update_vsyscall.
    
    Experimentation showed the combination of cpu_relax and smp_rmb
    was significantly slowing the progress of other threads sharing
    the core, and this patch is effective in avoiding the hang.
    
    A theory is the rmb is affecting the whole core while the
    cpu_relax is causing a resource rebalance flush, together they
    cause an interfernce cadance that is unbroken when the seqlock
    reader has interrupts disabled.
    
    At first I was confused why the refactor in
    3c22cd5709e8143444a6d08682a87f4c57902df3 (kernel: optimise
    seqlock) didn't affect this patch application, but after some
    study that affected seqcount not seqlock. The new seqcount was
    not factored back into the seqlock.  I defer that the future.
    
    While the removal of the timer interrupt offset created
    contention for the xtime lock while a cpu does the
    additonal work to update the system clock, the seqlock
    implementation with the tight rmb spin loop goes back much
    further, and is just waiting for the right trigger.
    
    Signed-off-by: Milton Miller <miltonm@bga.com>
    Cc: <linuxppc-dev@lists.ozlabs.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Andi Kleen <andi@firstfloor.org>
    Cc: Nick Piggin <npiggin@kernel.dk>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Anton Blanchard <anton@samba.org>
    Cc: Paul McKenney <paulmck@linux.vnet.ibm.com>
    Acked-by: Eric Dumazet <eric.dumazet@gmail.com>
    Link: http://lkml.kernel.org/r/%3Cseqlock-rmb%40mdm.bga.com%3E
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 42cd71bf1e3a081b3150018bbf448cb6c8a844a5
Merge: f5039935ac68 9a55d9752d8a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon May 23 15:15:27 2011 -0700

    Merge branch 'for-linus' of master.kernel.org:/home/rmk/linux-2.6-arm
    
    * 'for-linus' of master.kernel.org:/home/rmk/linux-2.6-arm: (137 commits)
      ARM: bcmring: convert to use sp804 clockevents
      ARM: bcmring: convert to sp804 clocksource
      ARM: 6912/1: bcmring: Add clkdev table in init_early
      clockevents: ARM sp804: obtain sp804 timer rate via clks
      clockevents: ARM sp804: allow clockevent name to be specified
      clocksource: ARM sp804: obtain sp804 timer rate via clks
      clocksource: ARM sp804: allow clocksource name to be specified
      clocksource: convert OMAP1 to 32-bit down counting clocksource
      clocksource: convert MXS timrotv2 to 32-bit down counting clocksource
      clocksource: convert SPEAr platforms 16-bit up counting clocksource
      clocksource: convert Integrator/AP 16-bit down counting clocksource
      clocksource: convert W90x900 24-bit down counting clocksource
      clocksource: convert ARM 32-bit down counting clocksources
      clocksource: convert ARM 32-bit up counting clocksources
      clocksource: add common mmio clocksource
      ARM: update sa1100 to reflect PXA updates
      ARM: omap1: convert to using readl/writel instead of volatile struct
      ARM: omap1: delete useless interrupt handler
      ARM: s5p: consolidate selection of timer register
      ARM: 6939/1: fix missing 'cpu_relax()' declaration
      ...

commit 30cb6d5f2eb24d15d20139d5ceefaccc68734bd7
Merge: 4867faab1e3e 68fa61c02605
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon May 23 11:30:28 2011 -0700

    Merge branch 'timers-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'timers-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip:
      hrtimers: Reorder clock bases
      hrtimers: Avoid touching inactive timer bases
      hrtimers: Make struct hrtimer_cpu_base layout less stupid
      timerfd: Manage cancelable timers in timerfd
      clockevents: Move C3 stop test outside lock
      alarmtimer: Drop device refcount after rtc_open()
      alarmtimer: Check return value of class_find_device()
      timerfd: Allow timers to be cancelled when clock was set
      hrtimers: Prepare for cancel on clock was set timers

commit e8765afe54b72b85ffe2b60683710ff450a92912
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Thu May 12 15:51:29 2011 +0100

    ARM: bcmring: convert to use sp804 clockevents
    
    bcmring has a set of four sp804 timers incorporated, yet it has its
    own copy of the sp804 code.  Convert its clockevent implementation
    to the standard sp804 support code.
    
    Cc: Jiandong Zheng <jdzheng@broadcom.com>
    Cc: Scott Branden <sbranden@broadcom.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

commit ede2e23456c1a4b9ce038bb4ed095ed442b1b07e
Author: Jiandong Zheng <jdzheng@broadcom.com>
Date:   Thu May 19 00:36:57 2011 +0100

    ARM: 6912/1: bcmring: Add clkdev table in init_early
    
    Move adding clkdev table to init_early to make sure the common sp804 clockevents can be initialized properly.
    
    Signed-off-by: Jiandong Zheng <jdzheng@broadcom.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

commit 23828a7a976eb8dbe3b5f4e83584c3fe814b295b
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Thu May 12 15:45:16 2011 +0100

    clockevents: ARM sp804: obtain sp804 timer rate via clks
    
    This allows platforms to specify the rate of the SP804 clockevent via
    the clk subsystem.  While ARM boards clock these at 1MHz, BCMRing also
    has SP804 timers but are clocked at different rates.
    
    Acked-by: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

commit 57cc4f7de2b896ca79185e337eaf7ff9906c4656
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Thu May 12 15:31:13 2011 +0100

    clockevents: ARM sp804: allow clockevent name to be specified
    
    This allows platforms to specify the clcokevent name upon registration.
    
    Acked-by: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

commit 1ba4c3cb171d9899a3eaa2e45fa171e0704c1377
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sun May 8 16:14:40 2011 +0100

    ARM: update sa1100 to reflect PXA updates
    
    Update sa1100 clockevents code to reflect what its later derivative
    does with clockevents_calc_mult_shift().  Use OSSR_M* constants too.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

commit 102dc1bae12a20214c9ee2d33a7402dc5175e30d
Merge: 91444f47b2a0 bbe7b8bef48c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri May 20 13:38:28 2011 -0700

    Merge branch 'timers-fixes-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'timers-fixes-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip:
      MAINTAINERS: Add drivers/clocksource to TIMEKEEPING
      clockevents/source: Use u64 to make 32bit happy

commit c0e299b1a91cbdb21ae08e382a4176200398bc36
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri May 20 10:50:52 2011 +0200

    clockevents/source: Use u64 to make 32bit happy
    
    unsigned long is not 64bit on 32bit machine.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 7e6628e4bcb3b3546c625ec63ca724f28ab14f0c
Merge: 0f1bdc1815c4 ab0e08f15d23
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu May 19 17:44:40 2011 -0700

    Merge branch 'timers-clockevents-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'timers-clockevents-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip:
      x86: hpet: Cleanup the clockevents init and register code
      x86: Convert PIT to clockevents_config_and_register()
      clockevents: Provide interface to reconfigure an active clock event device
      clockevents: Provide combined configure and register function
      clockevents: Restructure clock_event_device members
      clocksource: Get rid of the hardcoded 5 seconds sleep time limit
      clocksource: Restructure clocksource struct members

commit ab0e08f15d23628dd8d50bf6ce1a935a8840c7dc
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 18 21:33:43 2011 +0000

    x86: hpet: Cleanup the clockevents init and register code
    
    No need to recalculate the frequency and the conversion factors over
    and over. Calculate the frequency once and use the new config/register
    interface and let the core code do the math.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Reviewed-by: Ingo Molnar <mingo@elte.hu>
    Link: http://lkml.kernel.org/r/%3C20110518210136.646482357%40linutronix.de%3E

commit 61ee9a4ba05f0a4163d43a33dee7a0651e080b98
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 18 21:33:42 2011 +0000

    x86: Convert PIT to clockevents_config_and_register()
    
    Let the core do the work.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Reviewed-by: Ingo Molnar <mingo@elte.hu>
    Link: http://lkml.kernel.org/r/%3C20110518210136.545615675%40linutronix.de%3E

commit 80b816b736cfa5b9582279127099b20a479ab7d9
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 18 21:33:42 2011 +0000

    clockevents: Provide interface to reconfigure an active clock event device
    
    Some ARM SoCs have clock event devices which have their frequency
    modified due to frequency scaling. Provide an interface which allows
    to reconfigure an active device. After reconfiguration reprogram the
    current pending event.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: LAK <linux-arm-kernel@lists.infradead.org>
    Cc: John Stultz <john.stultz@linaro.org>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Reviewed-by: Ingo Molnar <mingo@elte.hu>
    Link: http://lkml.kernel.org/r/%3C20110518210136.437459958%40linutronix.de%3E

commit 57f0fcbe1dea8a36c9d1673086326059991c5f81
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 18 21:33:41 2011 +0000

    clockevents: Provide combined configure and register function
    
    All clockevent devices have the same open coded initialization
    functions. Provide an interface which does all necessary
    initialization in the core code.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Reviewed-by: Ingo Molnar <mingo@elte.hu>
    Link: http://lkml.kernel.org/r/%3C20110518210136.331975870%40linutronix.de%3E

commit 847b2f42be203f3cff7f243fdd3ee50c1e06c882
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 18 21:33:41 2011 +0000

    clockevents: Restructure clock_event_device members
    
    Group the hot path members of struct clock_event_device together so we
    have a better cache line footprint. Make it cacheline aligned.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Reviewed-by: Ingo Molnar <mingo@elte.hu>
    Link: http://lkml.kernel.org/r/%3C20110518210136.223607682%40linutronix.de%3E

commit 5db1256a5131d3b133946fa02ac9770a784e6eb2
Author: Milton Miller <miltonm@bga.com>
Date:   Thu May 12 04:13:54 2011 -0500

    seqlock: Don't smp_rmb in seqlock reader spin loop
    
    Move the smp_rmb after cpu_relax loop in read_seqlock and add
    ACCESS_ONCE to make sure the test and return are consistent.
    
    A multi-threaded core in the lab didn't like the update
    from 2.6.35 to 2.6.36, to the point it would hang during
    boot when multiple threads were active.  Bisection showed
    af5ab277ded04bd9bc6b048c5a2f0e7d70ef0867 (clockevents:
    Remove the per cpu tick skew) as the culprit and it is
    supported with stack traces showing xtime_lock waits including
    tick_do_update_jiffies64 and/or update_vsyscall.
    
    Experimentation showed the combination of cpu_relax and smp_rmb
    was significantly slowing the progress of other threads sharing
    the core, and this patch is effective in avoiding the hang.
    
    A theory is the rmb is affecting the whole core while the
    cpu_relax is causing a resource rebalance flush, together they
    cause an interfernce cadance that is unbroken when the seqlock
    reader has interrupts disabled.
    
    At first I was confused why the refactor in
    3c22cd5709e8143444a6d08682a87f4c57902df3 (kernel: optimise
    seqlock) didn't affect this patch application, but after some
    study that affected seqcount not seqlock. The new seqcount was
    not factored back into the seqlock.  I defer that the future.
    
    While the removal of the timer interrupt offset created
    contention for the xtime lock while a cpu does the
    additonal work to update the system clock, the seqlock
    implementation with the tight rmb spin loop goes back much
    further, and is just waiting for the right trigger.
    
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Milton Miller <miltonm@bga.com>
    Cc: <linuxppc-dev@lists.ozlabs.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Andi Kleen <andi@firstfloor.org>
    Cc: Nick Piggin <npiggin@kernel.dk>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Anton Blanchard <anton@samba.org>
    Cc: Paul McKenney <paulmck@linux.vnet.ibm.com>
    Acked-by: Eric Dumazet <eric.dumazet@gmail.com>
    Link: http://lkml.kernel.org/r/%3Cseqlock-rmb%40mdm.bga.com%3E
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 7372b0b122af0f6675f3ab65bfd91c8a438e0480
Author: Andi Kleen <ak@linux.intel.com>
Date:   Wed May 4 15:09:27 2011 -0700

    clockevents: Move C3 stop test outside lock
    
    Avoid taking broadcast_lock in the idle path for systems where the
    timer doesn't stop in C3.
    
    [ tglx: Removed the stale label and added comment ]
    
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Cc: Dave Kleikamp <dkleikamp@gmail.com>
    Cc: Chris Mason <chris.mason@oracle.com>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Tim Chen <tim.c.chen@linux.intel.com>
    Cc: lenb@kernel.org
    Cc: paulmck@us.ibm.com
    Link: http://lkml.kernel.org/r/%3C20110504234806.GF2925%40one.firstfloor.org%3E
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit c3b01b0df34002e981ed6d0b04fe8cecd25d3625
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Feb 25 22:34:23 2011 +0100

    clockevents: Prevent oneshot mode when broadcast device is periodic
    
    commit 3a142a0672b48a853f00af61f184c7341ac9c99d upstream.
    
    When the per cpu timer is marked CLOCK_EVT_FEAT_C3STOP, then we only
    can switch into oneshot mode, when the backup broadcast device
    supports oneshot mode as well. Otherwise we would try to switch the
    broadcast device into an unsupported mode unconditionally. This went
    unnoticed so far as the current available broadcast devices support
    oneshot mode. Seth unearthed this problem while debugging and working
    around an hpet related BIOS wreckage.
    
    Add the necessary check to tick_is_oneshot_available().
    
    Reported-and-tested-by: Seth Forshee <seth.forshee@canonical.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    LKML-Reference: <alpine.LFD.2.00.1102252231200.2701@localhost6.localdomain6>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 19b9675069cb06ae17d1595ac517d475d75e6bb9
Author: Senthil Balasubramanian <senthilkumar@atheros.com>
Date:   Wed Mar 23 23:07:21 2011 +0530

    ath9k: Fix kernel panic caused by invalid rate index access.
    
    With the recent tx status optimization in mac80211, we bail out as
    and and when invalid rate index is found. So the behavior of resetting
    rate idx to -1 and count to 0 has changed for the rate indexes that
    were not part of the driver's retry series.
    
    This has resulted in ath9k using incorrect rate table index which
    caused the system to panic. Ideally ath9k need to loop only for the
    indexes that were part of the retry series and so simply use hw->max_rates
    as the loop counter.
    
    Pasted the stack trace of the panic issue for reference.
    
    [  754.093192] BUG: unable to handle kernel paging request at ffff88046a9025b0
    [  754.093256] IP: [<ffffffffa02eac49>] ath_tx_status+0x209/0x2f0 [ath9k]
    [  754.094888] Call Trace:
    [  754.094903]  <IRQ>
    [  754.094928]  [<ffffffffa051f883>] ieee80211_tx_status+0x203/0x9e0 [mac80211]
    [  754.094975]  [<ffffffffa053e305>] ? __ieee80211_wake_queue+0x125/0x140 [mac80211]
    [  754.095017]  [<ffffffffa02e66c9>] ath_tx_complete_buf+0x1b9/0x370 [ath9k]
    [  754.095054]  [<ffffffffa02e6fcf>] ath_tx_complete_aggr+0x51f/0xb50 [ath9k]
    [  754.095098]  [<ffffffffa05382a3>] ? ieee80211_prepare_and_rx_handle+0x173/0xab0 [mac80211]
    [  754.095148]  [<ffffffff81350e62>] ? _raw_spin_unlock_irqrestore+0x32/0x40
    [  754.095186]  [<ffffffffa02e9735>] ath_tx_tasklet+0x365/0x4b0 [ath9k]
    [  754.095224]  [<ffffffff8107a2a2>] ? clockevents_program_event+0x62/0xa0
    [  754.095261]  [<ffffffffa02e2628>] ath9k_tasklet+0x168/0x1c0 [ath9k]
    [  754.095298]  [<ffffffff8105599b>] tasklet_action+0x6b/0xe0
    [  754.095331]  [<ffffffff81056278>] __do_softirq+0x98/0x120
    [  754.095361]  [<ffffffff8100cd5c>] call_softirq+0x1c/0x30
    [  754.095393]  [<ffffffff8100efb5>] do_softirq+0x65/0xa0
    [  754.095423]  [<ffffffff810563fd>] irq_exit+0x8d/0x90
    [  754.095453]  [<ffffffff8100ebc1>] do_IRQ+0x61/0xe0
    [  754.095482]  [<ffffffff81351413>] ret_from_intr+0x0/0x15
    [  754.095513]  <EOI>
    [  754.095531]  [<ffffffff81014375>] ? native_sched_clock+0x15/0x70
    [  754.096475]  [<ffffffffa02bcfa6>] ? acpi_idle_enter_bm+0x24d/0x285 [processor]
    [  754.096475]  [<ffffffffa02bcf9f>] ? acpi_idle_enter_bm+0x246/0x285 [processor]
    [  754.096475]  [<ffffffff8127fab2>] cpuidle_idle_call+0x82/0x100
    [  754.096475]  [<ffffffff8100a236>] cpu_idle+0xa6/0xf0
    [  754.096475]  [<ffffffff81339bc1>] rest_init+0x91/0xa0
    [  754.096475]  [<ffffffff814efccd>] start_kernel+0x3fd/0x408
    [  754.096475]  [<ffffffff814ef347>] x86_64_start_reservations+0x132/0x136
    [  754.096475]  [<ffffffff814ef451>] x86_64_start_kernel+0x106/0x115
    [  754.096475] RIP  [<ffffffffa02eac49>] ath_tx_status+0x209/0x2f0 [ath9k]
    
    Signed-off-by: Senthil Balasubramanian <senthilkumar@atheros.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

commit 002b43bfac57403ff58fe9cda16d71bdfac99dcc
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Feb 25 22:34:23 2011 +0100

    clockevents: Prevent oneshot mode when broadcast device is periodic
    
    commit 3a142a0672b48a853f00af61f184c7341ac9c99d upstream.
    
    When the per cpu timer is marked CLOCK_EVT_FEAT_C3STOP, then we only
    can switch into oneshot mode, when the backup broadcast device
    supports oneshot mode as well. Otherwise we would try to switch the
    broadcast device into an unsupported mode unconditionally. This went
    unnoticed so far as the current available broadcast devices support
    oneshot mode. Seth unearthed this problem while debugging and working
    around an hpet related BIOS wreckage.
    
    Add the necessary check to tick_is_oneshot_available().
    
    Reported-and-tested-by: Seth Forshee <seth.forshee@canonical.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    LKML-Reference: <alpine.LFD.2.00.1102252231200.2701@localhost6.localdomain6>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 2c1d2470c0c0992fae2cc0e04921f9e02a670a00
Merge: 664322a44752 ddb7d1e975d2
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Mar 18 22:31:05 2011 -0700

    Merge branch 'fixes' of git://git.kernel.org/pub/scm/linux/kernel/git/dhowells/linux-2.6-mn10300
    
    * 'fixes' of git://git.kernel.org/pub/scm/linux/kernel/git/dhowells/linux-2.6-mn10300:
      MN10300: Clear ASB2364 peripheral interrupt masks before enabling interrupts
      MN10300: Fix the ASB2364 gdbport UART register defs
      MN10300: Fix ASB2364 FPGA register defs
      MN10300: Select GENERIC_HARDIRQS_NO_DEPRECATED
      MN10300: Select HAVE_GENERIC_HARDIRQS rather than GENERIC_HARDIRQS
      MN10300: Convert ASB2364 FPGA irq_chip to new functions
      MN10300: Convert ipi irq_chip to new functions
      MN10300: Convert serial irq_chip to new functions
      MN10300: Convert cpu irq_chips to new functions
      MN10300: Remove unused mn10300_intc_* functions
      MN10300: Remove stale irq_chip.end - V2
      MN10300: Use clockevents_calc_mult_shift()
      MN10300: Use clocksource_register_hz()
      MN10300: Remove stale code

commit dc7daf33626d1f4afc97505516f824caf440d52c
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Mar 18 16:52:50 2011 +0000

    MN10300: Use clockevents_calc_mult_shift()
    
    Use clockevents_calc_mult_shift() instead of the homebrewn function in
    mn10300/kernel/time.c.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: John Stultz <johnstul@us.ibm.com>
    Cc: Koichi Yasutake <yasutake.koichi@jp.panasonic.com>
    Cc: Mark Salter <msalter@redhat.com>
    Signed-off-by: David Howells <dhowells@redhat.com>

commit 73a173a4117419892bd436e85a00a53aa22ad118
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Mar 18 16:42:06 2011 +0000

    MN10300: Remove stale code
    
    mn10300 implements clocksource and clockevents and selects them
    unconditionally in Kconfig. Remove the stale code which seems to be a
    leftover of the conversion. Cleanup the configuration switches as well.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: John Stultz <johnstul@us.ibm.com>
    Cc: Koichi Yasutake <yasutake.koichi@jp.panasonic.com>
    Cc: Mark Salter <msalter@redhat.com>
    Signed-off-by: David Howells <dhowells@redhat.com>

commit a913a8234bb812d21bb0f75c2458f9eb941ddf91
Author: GuanXuetao <gxt@mprc.pku.edu.cn>
Date:   Thu Feb 17 17:50:43 2011 +0800

    unicore32 time.c: change calculate method for clock_event_device
    
    apply clockevents_calc_mult_shift() to get rid of
    shift assignment and mult calculation for osmr0
      -- by advice with Thomas Gleixner
    
    Signed-off-by: Guan Xuetao <gxt@mprc.pku.edu.cn>

commit ccc46e29a63c88aa9ac72aac86ff0cfd5c627a11
Author: Haojian Zhuang <haojian.zhuang@marvell.com>
Date:   Wed Nov 24 11:54:23 2010 +0800

    ARM: pxa: auto compute shift and mult of timer
    
    Use auto-computed shift and mult of timer with new API
    clocksource_calc_mult_shift()/clockevents_calc_mult_shift().
    
    Signed-off-by: Haojian Zhuang <haojian.zhuang@marvell.com>
    Cc: Nicolas Pitre <nico@fluxnic.net>
    Signed-off-by: Eric Miao <eric.y.miao@gmail.com>

commit f3d155634f6fc7ee665731768ed6f85d04ef442c
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Feb 25 22:34:23 2011 +0100

    clockevents: Prevent oneshot mode when broadcast device is periodic
    
    commit 3a142a0672b48a853f00af61f184c7341ac9c99d upstream.
    
    When the per cpu timer is marked CLOCK_EVT_FEAT_C3STOP, then we only
    can switch into oneshot mode, when the backup broadcast device
    supports oneshot mode as well. Otherwise we would try to switch the
    broadcast device into an unsupported mode unconditionally. This went
    unnoticed so far as the current available broadcast devices support
    oneshot mode. Seth unearthed this problem while debugging and working
    around an hpet related BIOS wreckage.
    
    Add the necessary check to tick_is_oneshot_available().
    
    Reported-and-tested-by: Seth Forshee <seth.forshee@canonical.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    LKML-Reference: <alpine.LFD.2.00.1102252231200.2701@localhost6.localdomain6>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 69d2dd738ce984fd0b7ab25c8f179ba07c56d2e0
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Feb 25 22:34:23 2011 +0100

    clockevents: Prevent oneshot mode when broadcast device is periodic
    
    commit 3a142a0672b48a853f00af61f184c7341ac9c99d upstream.
    
    When the per cpu timer is marked CLOCK_EVT_FEAT_C3STOP, then we only
    can switch into oneshot mode, when the backup broadcast device
    supports oneshot mode as well. Otherwise we would try to switch the
    broadcast device into an unsupported mode unconditionally. This went
    unnoticed so far as the current available broadcast devices support
    oneshot mode. Seth unearthed this problem while debugging and working
    around an hpet related BIOS wreckage.
    
    Add the necessary check to tick_is_oneshot_available().
    
    Reported-and-tested-by: Seth Forshee <seth.forshee@canonical.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    LKML-Reference: <alpine.LFD.2.00.1102252231200.2701@localhost6.localdomain6>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 7f233dee2149245bc7ee1194c31a04ea43cd127e
Merge: 58da94f0139d 54b08f5f90fe 299c56966a72 3a142a0672b4
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Feb 28 17:55:08 2011 -0800

    Merge branches 'perf-fixes-for-linus', 'x86-fixes-for-linus' and 'timers-fixes-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'perf-fixes-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip:
      perf timechart: Fix max number of cpus
      perf timechart: Fix black idle boxes in the title
      perf hists: Print number of samples, not the period sum
    
    * 'x86-fixes-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip:
      x86: Use u32 instead of long to set reset vector back to 0
    
    * 'timers-fixes-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip:
      clockevents: Prevent oneshot mode when broadcast device is periodic

commit a2debdbd1ad896a410019c9cf30785cad15930fc
Author: Paul Walmsley <paul@pwsan.com>
Date:   Wed Feb 23 00:14:07 2011 -0700

    OMAP2+: hwmod: add ability to setup individual hwmods
    
    Add omap_hwmod_setup_one(), which is intended for use early in boot to
    selectively setup the hwmods needed for system clocksources and
    clockevents, and any other hwmod that is needed in early boot.
    omap_hwmod_setup_all() can then be called later in the boot process.
    The point is to minimize the amount of code that needs to be run
    early.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Benot Cousson <b-cousson@ti.com>
    Cc: Kevin Hilman <khilman@ti.com>
    Cc: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Cc: Tony Lindgren <tony@atomide.com>

commit 48d54f3fd20b435311f295b3bca3570096a2ac83
Author: Paul Walmsley <paul@pwsan.com>
Date:   Wed Feb 23 00:14:07 2011 -0700

    OMAP2+: hwmod: ignore attempts to re-setup a hwmod
    
    Previously, if a hwmod had already been set up, and the code attempted
    to set up the hwmod again, an error would be returned.  This is not
    really useful behavior if we wish to allow the OMAP core code to setup
    the hwmods needed for the Linux clocksources and clockevents before
    the rest of the hwmods are setup.  So, instead of generating errors,
    just ignore the attempt to re-setup the hwmod.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Benot Cousson <b-cousson@ti.com>
    Cc: Kevin Hilman <khilman@ti.com>

commit bac1a0f0bbf0b11b23fe714826f29fc9aeb35855
Author: Paul Walmsley <paul@pwsan.com>
Date:   Wed Feb 23 00:14:06 2011 -0700

    OMAP2+: hwmod: allow multiple calls to omap_hwmod_init()
    
    There's no longer any reason why we should prevent multiple
    calls to omap_hwmod_init().  It is now simply used to register an
    array of hwmods.
    
    This should allow a subset of hwmods (e.g., hwmods
    handling the system clocksource and clockevents) to be registered
    earlier than the remaining mass of hwmods.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Benot Cousson <b-cousson@ti.com>
    Cc: Kevin Hilman <khilman@ti.com>

commit 3a142a0672b48a853f00af61f184c7341ac9c99d
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Feb 25 22:34:23 2011 +0100

    clockevents: Prevent oneshot mode when broadcast device is periodic
    
    When the per cpu timer is marked CLOCK_EVT_FEAT_C3STOP, then we only
    can switch into oneshot mode, when the backup broadcast device
    supports oneshot mode as well. Otherwise we would try to switch the
    broadcast device into an unsupported mode unconditionally. This went
    unnoticed so far as the current available broadcast devices support
    oneshot mode. Seth unearthed this problem while debugging and working
    around an hpet related BIOS wreckage.
    
    Add the necessary check to tick_is_oneshot_available().
    
    Reported-and-tested-by: Seth Forshee <seth.forshee@canonical.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    LKML-Reference: <alpine.LFD.2.00.1102252231200.2701@localhost6.localdomain6>
    Cc: stable@kernel.org # .21 ->

commit 7cf37e87dd2cfa17a64f28ea7f31eed4525f79e4
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Feb 1 09:34:58 2011 +0100

    time: Fix legacy arch fallout
    
    The xtime/dotimer cleanup broke architectures which do not implement
    clockevents. Time to send out another __do_IRQ threat.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reported-by: Ingo Molnar <mingo@elte.hu>
    Cc: Torben Hohn <torbenh@gmx.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: johnstul@us.ibm.com
    Cc: yong.zhang0@gmail.com
    Cc: hch@infradead.org
    LKML-Reference: <20110127145905.23248.30458.stgit@localhost>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

commit 4e8d76373c9fd7a1c1b401fc97ba01c0ecbb888f
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Fri Jan 28 21:00:39 2011 +0000

    ARM: footbridge: convert to clockevents/clocksource
    
    The Footbridge platforms have some reasonable timers in the host bridge,
    which we use for most footbridge-based platforms.  However, NetWinder's
    clock these using a spread-spectrum clock which makes them too unstable
    for time keeping.  So we have to rely on the PIT.
    
    Convert both Footbridge timers and PIT timers to use the clocksource
    and clockevent infrastructure.  Tested on Netwinder.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

commit 1817dc0370873caff77b924b53ae489edaf9b1e2
Author: Voss, Nikolaus <N.Voss@weinmann.de>
Date:   Tue Jan 25 15:07:29 2011 -0800

    drivers/clocksource/tcb_clksrc.c: fix init sequence
    
    setup_irq() was called before clockevents_register_device() which is
    needed by the irq handler.  Bug was reproducible by restarting the
    kernel using kexec (reliable crash).
    
    Signed-off-by: Nikolaus Voss <n.voss@weinmann.de>
    Cc: David Brownell <dbrownell@users.sourceforge.net>
    Cc: Haavard Skinnemoen <hskinnemoen@atmel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit 4aed89d6b515b9185351706ca95cd712c9d8d6a3
Author: Pierre Tardy <pierre.tardy@intel.com>
Date:   Thu Jan 6 16:23:29 2011 +0100

    x86, lapic-timer: Increase the max_delta to 31 bits
    
    Latest atom socs(penwell) does not have hpet timer.
    
    As their local APIC timer is clocked at 400KHZ, and the current
    code limit their Initial Counter register to 23 bits, they
    cannot sleep more than 1.34 seconds which leads to ~2 spurious
    wakeup per second (1 per thread)
    
    These SOCs support 32bit timer so we change the max_delta to at
    least 31bits. So we can at least sleep for 300 seconds.
    
    We could not find any previous chip errata where lapic would
    only have 23 bit precision As powertop is suggesting to activate
    HPET to "sleep longer", this could mean this problem is already
    known.
    
    Problem is here since very first implementation of lapic timer
    as a clock event e9e2cdb [PATCH] clockevents: i386 drivers.
    
    Signed-off-by: Suresh Siddha <suresh.b.siddha@intel.com>
    Signed-off-by: Pierre Tardy <pierre.tardy@intel.com>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Arjan van de Ven <arjan@infradead.org>
    Cc: Adrian Bunk <bunk@stusta.de>
    Cc: H. Peter Anvin <hpa@linux.intel.com>
    Cc: john stultz <johnstul@us.ibm.com>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Cc: Andi Kleen <ak@suse.de>
    LKML-Reference: <1294327409-19426-1-git-send-email-pierre.tardy@intel.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

commit 5010f3db952b19cd353d1e90838818922d995697
Author: Magnus Damm <damm@opensource.se>
Date:   Tue Dec 21 08:40:59 2010 +0000

    ARM: mach-shmobile: sh73a0 TMU support
    
    Add support for 2 TMU timer channels on sh73a0.
    
    One timer channel is used for clocksource and
    the other is used for clockevents. All channels
    in the same TMU block share MSTP bit as usual.
    
    Signed-off-by: Magnus Damm <damm@opensource.se>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

commit 40cc52440073903f3b7477a3391c4ca0761445d0
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sun Dec 19 15:43:34 2010 +0000

    ARM: clockevents: fix IOP clock events initialization
    
    Ensure that no interrupt is pending before registering the clock
    event device, and properly initialize the periodic tick in the
    ->set_mode callback.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

commit cdaf9a2f280b25dd2fb1e04da5d3899411766e1b
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Tue Oct 5 11:29:28 2010 +0100

    ARM: fix section mismatch warnings in Versatile Express
    
    WARNING: vmlinux.o(.text+0xbf30): Section mismatch in reference from the function v2m_timer_init() to the function .init.text:sp804_clocksource_init()
    The function v2m_timer_init() references
    the function __init sp804_clocksource_init().
    This is often because v2m_timer_init lacks a __init
    annotation or the annotation of sp804_clocksource_init is wrong.
    
    WARNING: vmlinux.o(.text+0xbf3c): Section mismatch in reference from the function v2m_timer_init() to the function .init.text:sp804_clockevents_init()
    The function v2m_timer_init() references
    the function __init sp804_clockevents_init().
    This is often because v2m_timer_init lacks a __init
    annotation or the annotation of sp804_clockevents_init is wrong.
    
    WARNING: vmlinux.o(.text+0xc524): Section mismatch in reference from the function ct_ca9x4_init() to the function .init.text:l2x0_init()
    The function ct_ca9x4_init() references
    the function __init l2x0_init().
    This is often because ct_ca9x4_init lacks a __init
    annotation or the annotation of l2x0_init is wrong.
    
    WARNING: vmlinux.o(.text+0xc530): Section mismatch in reference from the function ct_ca9x4_init() to the function .init.text:clkdev_add_table()
    The function ct_ca9x4_init() references
    the function __init clkdev_add_table().
    This is often because ct_ca9x4_init lacks a __init
    annotation or the annotation of clkdev_add_table is wrong.
    
    WARNING: vmlinux.o(.text+0xc578): Section mismatch in reference from the function ct_ca9x4_init() to the (unknown reference) .init.data:(unknown)
    The function ct_ca9x4_init() references
    the (unknown reference) __initdata (unknown).
    This is often because ct_ca9x4_init lacks a __initdata
    annotation or the annotation of (unknown) is wrong.
    
    Fix these by making ct_ca9x4_init() and v2m_timer_init() both __init.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

commit 3de7b517dfacf1deb0690dbac28f917643e49975
Author: Hans J. Koch <hjk@linutronix.de>
Date:   Fri Sep 17 18:17:42 2010 +0200

    ARM: Add TCC8xxx system timer
    
    Add the system timer using clockevents with the internal TC32 timer.
    This also adds a clocksource using the same timer.
    
    Signed-off-by: "Hans J. Koch" <hjk@linutronix.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit af390084359a5de20046c901529b2b6a50b941cb
Merge: 7645e4320497 0fcb80818bc3
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Aug 6 13:12:36 2010 -0700

    Merge branch 'timers-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'timers-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip:
      Documentation: Add timers/timers-howto.txt
      timer: Added usleep_range timer
      Revert "timer: Added usleep[_range] timer"
      clockevents: Remove the per cpu tick skew
      posix_timer: Move copy_to_user(created_timer_id) down in timer_create()
      timer: Added usleep[_range] timer
      timers: Document meaning of deferrable timer

commit af5ab277ded04bd9bc6b048c5a2f0e7d70ef0867
Author: Arjan van de Ven <arjan@infradead.org>
Date:   Tue Jul 27 21:02:10 2010 -0700

    clockevents: Remove the per cpu tick skew
    
    Historically, Linux has tried to make the regular timer tick on the
    various CPUs not happen at the same time, to avoid contention on
    xtime_lock.
    
    Nowadays, with the tickless kernel, this contention no longer happens
    since time keeping and updating are done differently. In addition,
    this skew is actually hurting power consumption in a measurable way on
    many-core systems.
    
    Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>
    LKML-Reference: <20100727210210.58d3118c@infradead.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit d75d68cfef4936ddf38d2694ae2f7d1f7c45db05
Author: Paul Mackerras <paulus@samba.org>
Date:   Sun Jun 20 19:04:14 2010 +0000

    powerpc: Clean up obsolete code relating to decrementer and timebase
    
    Since the decrementer and timekeeping code was moved over to using
    the generic clockevents and timekeeping infrastructure, several
    variables and functions have been obsolete and effectively unused.
    This deletes them.
    
    In particular, wakeup_decrementer() is no longer needed since the
    generic code reprograms the decrementer as part of the process of
    resuming the timekeeping code, which happens during sysdev resume.
    Thus the wakeup_decrementer calls in the suspend_enter methods for
    52xx platforms have been removed.  The call in the powermac cpu
    frequency change code has been replaced by set_dec(1), which will
    cause a timer interrupt as soon as interrupts are enabled, and the
    generic code will then reprogram the decrementer with the correct
    value.
    
    This also simplifies the generic_suspend_en/disable_irqs functions
    and makes them static since they are not referenced outside time.c.
    The preempt_enable/disable calls are removed because the generic
    code has disabled all but the boot cpu at the point where these
    functions are called, so we can't be moved to another cpu.
    
    Signed-off-by: Paul Mackerras <paulus@samba.org>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

commit c1aa687d499a8bce55cb8cf962f0b72c0f933f14
Author: Paul Mackerras <paulus@samba.org>
Date:   Sun Jun 20 19:04:14 2010 +0000

    powerpc: Clean up obsolete code relating to decrementer and timebase
    
    Since the decrementer and timekeeping code was moved over to using
    the generic clockevents and timekeeping infrastructure, several
    variables and functions have been obsolete and effectively unused.
    This deletes them.
    
    In particular, wakeup_decrementer() is no longer needed since the
    generic code reprograms the decrementer as part of the process of
    resuming the timekeeping code, which happens during sysdev resume.
    Thus the wakeup_decrementer calls in the suspend_enter methods for
    52xx platforms have been removed.  The call in the powermac cpu
    frequency change code has been replaced by set_dec(1), which will
    cause a timer interrupt as soon as interrupts are enabled, and the
    generic code will then reprogram the decrementer with the correct
    value.
    
    This also simplifies the generic_suspend_en/disable_irqs functions
    and makes them static since they are not referenced outside time.c.
    The preempt_enable/disable calls are removed because the generic
    code has disabled all but the boot cpu at the point where these
    functions are called, so we can't be moved to another cpu.
    
    Signed-off-by: Paul Mackerras <paulus@samba.org>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

commit 843447c62b771a9ad12f0e7f4a791804b4cc99f5
Author: Suresh Siddha <suresh.b.siddha@intel.com>
Date:   Thu Apr 22 11:47:51 2010 +0200

    clockevent: Prevent dead lock on clockevents_lock
    
    This is a merge of two mainline commits, intended
    for stable@kernel.org submission for 2.6.27 kernel.
    
    commit f833bab87fca5c3ce13778421b1365845843b976
    and
    
    commit 918aae42aa9b611a3663b16ae849fdedc67c2292
    Changelog of both:
    
        Currently clockevents_notify() is called with interrupts enabled at
        some places and interrupts disabled at some other places.
    
        This results in a deadlock in this scenario.
    
        cpu A holds clockevents_lock in clockevents_notify() with irqs enabled
        cpu B waits for clockevents_lock in clockevents_notify() with irqs disabled
        cpu C doing set_mtrr() which will try to rendezvous of all the cpus.
    
        This will result in C and A come to the rendezvous point and waiting
        for B. B is stuck forever waiting for the spinlock and thus not
        reaching the rendezvous point.
    
        Fix the clockevents code so that clockevents_lock is taken with
        interrupts disabled and thus avoid the above deadlock.
    
        Also call lapic_timer_propagate_broadcast() on the destination cpu so
        that we avoid calling smp_call_function() in the clockevents notifier
        chain.
    
        This issue left us wondering if we need to change the MTRR rendezvous
        logic to use stop machine logic (instead of smp_call_function) or add
        a check in spinlock debug code to see if there are other spinlocks
        which gets taken under both interrupts enabled/disabled conditions.
    
        Signed-off-by: Suresh Siddha <suresh.b.siddha@intel.com>
        Cc: "Brown Len" <len.brown@intel.com>
        Cc: stable@kernel.org
        LKML-Reference: <1250544899.2709.210.camel@sbs-t61.sc.intel.com>
        Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    
        I got following warning on ia64 box:
          In function 'acpi_processor_power_verify':
          642: warning: passing argument 2 of 'smp_call_function_single' from
          incompatible pointer type
    
        This smp_call_function_single() was introduced by a commit
        f833bab87fca5c3ce13778421b1365845843b976:
    
        The problem is that the lapic_timer_propagate_broadcast() has 2 versions:
        One is real code that modified in the above commit, and the other is NOP
        code that used when !ARCH_APICTIMER_STOPS_ON_C3:
    
          static void lapic_timer_propagate_broadcast(struct acpi_processor *pr) { }
    
        So I got warning because of !ARCH_APICTIMER_STOPS_ON_C3.
    
        We really want to do nothing here on !ARCH_APICTIMER_STOPS_ON_C3, so
        modify lapic_timer_propagate_broadcast() of real version to use
        smp_call_function_single() in it.
    
        Signed-off-by: Hidetoshi Seto <seto.hidetoshi@jp.fujitsu.com>
        Acked-by: Suresh Siddha <suresh.b.siddha@intel.com>
        Signed-off-by: Len Brown <len.brown@intel.com>
    
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 1020738fc1de56751c902c0f26eac5a61a0d9790
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Feb 3 15:52:18 2010 -0800

    Bluetooth: Fix sleeping function in RFCOMM within invalid context
    
    commit 485f1eff73a7b932fd3abb0dfcf804e1a1f59025 upstream.
    
    With the commit 9e726b17422bade75fba94e625cd35fd1353e682 the
    rfcomm_session_put() gets accidentially called from a timeout
    callback and results in this:
    
    BUG: sleeping function called from invalid context at net/core/sock.c:1897
    in_atomic(): 1, irqs_disabled(): 0, pid: 0, name: swapper
    Pid: 0, comm: swapper Tainted: P           2.6.32 #31
    Call Trace:
     <IRQ>  [<ffffffff81036455>] __might_sleep+0xf8/0xfa
     [<ffffffff8138ef1d>] lock_sock_nested+0x29/0xc4
     [<ffffffffa03921b3>] lock_sock+0xb/0xd [l2cap]
     [<ffffffffa03948e6>] l2cap_sock_shutdown+0x1c/0x76 [l2cap]
     [<ffffffff8106adea>] ? clockevents_program_event+0x75/0x7e
     [<ffffffff8106bea2>] ? tick_dev_program_event+0x37/0xa5
     [<ffffffffa0394967>] l2cap_sock_release+0x27/0x67 [l2cap]
     [<ffffffff8138c971>] sock_release+0x1a/0x67
     [<ffffffffa03d2492>] rfcomm_session_del+0x34/0x53 [rfcomm]
     [<ffffffffa03d24c5>] rfcomm_session_put+0x14/0x16 [rfcomm]
     [<ffffffffa03d28b4>] rfcomm_session_timeout+0xe/0x1a [rfcomm]
     [<ffffffff810554a8>] run_timer_softirq+0x1e2/0x29a
     [<ffffffffa03d28a6>] ? rfcomm_session_timeout+0x0/0x1a [rfcomm]
     [<ffffffff8104e0f6>] __do_softirq+0xfe/0x1c5
     [<ffffffff8100e8ce>] ? timer_interrupt+0x1a/0x21
     [<ffffffff8100cc4c>] call_softirq+0x1c/0x28
     [<ffffffff8100e05b>] do_softirq+0x33/0x6b
     [<ffffffff8104daf6>] irq_exit+0x36/0x85
     [<ffffffff8100d7a9>] do_IRQ+0xa6/0xbd
     [<ffffffff8100c493>] ret_from_intr+0x0/0xa
     <EOI>  [<ffffffff812585b3>] ? acpi_idle_enter_bm+0x269/0x294
     [<ffffffff812585a9>] ? acpi_idle_enter_bm+0x25f/0x294
     [<ffffffff81373ddc>] ? cpuidle_idle_call+0x97/0x107
     [<ffffffff8100aca0>] ? cpu_idle+0x53/0xaa
     [<ffffffff81429006>] ? rest_init+0x7a/0x7c
     [<ffffffff8177bc8c>] ? start_kernel+0x389/0x394
     [<ffffffff8177b29c>] ? x86_64_start_reservations+0xac/0xb0
     [<ffffffff8177b384>] ? x86_64_start_kernel+0xe4/0xeb
    
    To fix this, the rfcomm_session_put() needs to be moved out of
    rfcomm_session_timeout() into rfcomm_process_sessions(). In that
    context it is perfectly fine to sleep and disconnect the socket.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Tested-by: David John <davidjon@xenontk.org>
    Cc: Chase Douglas <chase.douglas@canonical.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 888cafa05c94bccef4d7ceba7228dda7ae06f2fc
Author: Xiaotian Feng <dfeng@redhat.com>
Date:   Thu Jan 7 11:22:44 2010 +0800

    clockevent: Don't remove broadcast device when cpu is dead
    
    commit ea9d8e3f45404d411c00ae67b45cc35c58265bb7 upstream.
    
    Marc reported that the BUG_ON in clockevents_notify() triggers on his
    system. This happens because the kernel tries to remove an active
    clock event device (used for broadcasting) from the device list.
    
    The handling of devices which can be used as per cpu device and as a
    global broadcast device is suboptimal.
    
    The simplest solution for now (and for stable) is to check whether the
    device is used as global broadcast device, but this needs to be
    revisited.
    
    [ tglx: restored the cpuweight check and massaged the changelog ]
    
    Reported-by: Marc Dionne <marc.c.dionne@gmail.com>
    Tested-by: Marc Dionne <marc.c.dionne@gmail.com>
    Signed-off-by: Xiaotian Feng <dfeng@redhat.com>
    LKML-Reference: <1262834564-13033-1-git-send-email-dfeng@redhat.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 054319b5e255c0671012a5a89b344a7d55cda80c
Merge: 833961d81f0e 830ec0458c39
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Mar 26 15:10:38 2010 -0700

    Merge branch 'timers-fixes-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'timers-fixes-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip:
      time: Fix accumulation bug triggered by long delay.
      posix-cpu-timers: Reset expire cache when no timer is running
      timer stats: Fix del_timer_sync() and try_to_del_timer_sync()
      clockevents: Sanitize min_delta_ns adjustment and prevent overflows

commit 80a05b9ffa7dc13f6693902dd8999a2b61a3a0d7
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Mar 12 17:34:14 2010 +0100

    clockevents: Sanitize min_delta_ns adjustment and prevent overflows
    
    The current logic which handles clock events programming failures can
    increase min_delta_ns unlimited and even can cause overflows.
    
    Sanitize it by:
     - prevent zero increase when min_delta_ns == 1
     - limiting min_delta_ns to a jiffie
     - bail out if the jiffie limit is hit
     - add retries stats for /proc/timer_list so we can gather data
    
    Reported-by: Uwe Kleine-Koenig <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit ad001f145dcf457251e78fe2ae2ed40df1bda4ed
Author: Santosh Shilimkar <santosh.shilimkar@ti.com>
Date:   Mon Feb 22 22:09:41 2010 -0700

    OMAP4: clock: Remove clock hacks from timer-gp.c
    
    Now the omap4 clock framework is in mainline and clk_get_rate()
    is functional. Hence reomve the hardcoded clock hacks.
    
    This patch also fixes
    Division by zero in kernel.
    Backtrace:
    [<c0025fb8>] (dump_backtrace+0x0/0x110) from [<c017febc>] (dump_stack+0x18/0x1c)
     r7:60000093 r6:c0641050 r5:c0223e78 r4:c02126b4
    [<c017fea4>] (dump_stack+0x0/0x1c) from [<c00260fc>] (__div0+0x18/0x20)
    [<c00260e4>] (__div0+0x0/0x20) from [<c01431fc>] (Ldiv0+0x8/0x10)
    [<c00318d4>] (omap_dm_timer_stop+0x0/0xb0) from [<c002c148>] (omap2_gp_timer_set_mode+0x1c/0x68)
     r5:c0223e78 r4:00000000
    [<c002c12c>] (omap2_gp_timer_set_mode+0x0/0x68) from [<c0063270>] (clockevents_set_mode+0x30/0x64)
     r5:c020cae0 r4:00000000
    [<c0063240>] (clockevents_set_mode+0x0/0x64) from [<c00632fc>] (clockevents_exchange_device+0x30/0x9c)
     r5:c020cae0 r4:c02146e0
    [<c00632cc>] (clockevents_exchange_device+0x0/0x9c) from [<c00636e0>] (tick_notify+0x17c/0x404)
     r7:00000000 r6:c0641050 r5:00000000 r4:c020cae0
    [<c0063564>] (tick_notify+0x0/0x404) from [<c005d5fc>] (notifier_call_chain+0x34/0x78)
    [<c005d5c8>] (notifier_call_chain+0x0/0x78) from [<c005d684>] (__raw_notifier_call_chain+0x1c/0x24)
    [<c005d668>] (__raw_notifier_call_chain+0x0/0x24) from [<c005d6ac>] (raw_notifier_call_chain+0x20/0x28)
    [<c005d68c>] (raw_notifier_call_chain+0x0/0x28) from [<c0062e78>] (clockevents_do_notify+0x1c/0x24)
    [<c0062e5c>] (clockevents_do_notify+0x0/0x24) from [<c0062f18>] (clockevents_register_device+0x98/0xd0)
    [<c0062e80>] (clockevents_register_device+0x0/0xd0) from [<c001a194>] (percpu_timer_setup+0x80/0x9c)
     r7:00000000 r6:00000002 r5:00000002 r4:00000003
    [<c001a114>] (percpu_timer_setup+0x0/0x9c) from [<c000e9f0>] (smp_prepare_cpus+0xb0/0xe8)
    [<c000e940>] (smp_prepare_cpus+0x0/0xe8) from [<c00084e8>] (kernel_init+0x5c/0x1fc)
     r7:00000000 r6:00000000 r5:00000000 r4:c001b8a4
    [<c000848c>] (kernel_init+0x0/0x1fc) from [<c0046c50>] (do_exit+0x0/0x604)
     r7:00000000 r6:00000000 r5:00000000 r4:00000000
    
    Signed-off-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

commit 485f1eff73a7b932fd3abb0dfcf804e1a1f59025
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Feb 3 15:52:18 2010 -0800

    Bluetooth: Fix sleeping function in RFCOMM within invalid context
    
    With the commit 9e726b17422bade75fba94e625cd35fd1353e682 the
    rfcomm_session_put() gets accidentially called from a timeout
    callback and results in this:
    
    BUG: sleeping function called from invalid context at net/core/sock.c:1897
    in_atomic(): 1, irqs_disabled(): 0, pid: 0, name: swapper
    Pid: 0, comm: swapper Tainted: P           2.6.32 #31
    Call Trace:
     <IRQ>  [<ffffffff81036455>] __might_sleep+0xf8/0xfa
     [<ffffffff8138ef1d>] lock_sock_nested+0x29/0xc4
     [<ffffffffa03921b3>] lock_sock+0xb/0xd [l2cap]
     [<ffffffffa03948e6>] l2cap_sock_shutdown+0x1c/0x76 [l2cap]
     [<ffffffff8106adea>] ? clockevents_program_event+0x75/0x7e
     [<ffffffff8106bea2>] ? tick_dev_program_event+0x37/0xa5
     [<ffffffffa0394967>] l2cap_sock_release+0x27/0x67 [l2cap]
     [<ffffffff8138c971>] sock_release+0x1a/0x67
     [<ffffffffa03d2492>] rfcomm_session_del+0x34/0x53 [rfcomm]
     [<ffffffffa03d24c5>] rfcomm_session_put+0x14/0x16 [rfcomm]
     [<ffffffffa03d28b4>] rfcomm_session_timeout+0xe/0x1a [rfcomm]
     [<ffffffff810554a8>] run_timer_softirq+0x1e2/0x29a
     [<ffffffffa03d28a6>] ? rfcomm_session_timeout+0x0/0x1a [rfcomm]
     [<ffffffff8104e0f6>] __do_softirq+0xfe/0x1c5
     [<ffffffff8100e8ce>] ? timer_interrupt+0x1a/0x21
     [<ffffffff8100cc4c>] call_softirq+0x1c/0x28
     [<ffffffff8100e05b>] do_softirq+0x33/0x6b
     [<ffffffff8104daf6>] irq_exit+0x36/0x85
     [<ffffffff8100d7a9>] do_IRQ+0xa6/0xbd
     [<ffffffff8100c493>] ret_from_intr+0x0/0xa
     <EOI>  [<ffffffff812585b3>] ? acpi_idle_enter_bm+0x269/0x294
     [<ffffffff812585a9>] ? acpi_idle_enter_bm+0x25f/0x294
     [<ffffffff81373ddc>] ? cpuidle_idle_call+0x97/0x107
     [<ffffffff8100aca0>] ? cpu_idle+0x53/0xaa
     [<ffffffff81429006>] ? rest_init+0x7a/0x7c
     [<ffffffff8177bc8c>] ? start_kernel+0x389/0x394
     [<ffffffff8177b29c>] ? x86_64_start_reservations+0xac/0xb0
     [<ffffffff8177b384>] ? x86_64_start_kernel+0xe4/0xeb
    
    To fix this, the rfcomm_session_put() needs to be moved out of
    rfcomm_session_timeout() into rfcomm_process_sessions(). In that
    context it is perfectly fine to sleep and disconnect the socket.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Tested-by: David John <davidjon@xenontk.org>

commit ce946bce1761f3c9f1f1ed8c15515d70d19047e9
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Fri Oct 16 18:19:01 2009 -0400

    clockevents: Add missing include to pacify sparse
    
    commit 8e1a928a2ed7e8d5cad97c8e985294b4caedd168 upstream.
    
    Include "tick-internal.h" in order to pick up the extern function
    prototype for clockevents_shutdown(). This quiets the following sparse
    build noise:
    
      warning: symbol 'clockevents_shutdown' was not declared. Should it be static?
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    LKML-Reference: <BD79186B4FD85F4B8E60E381CAEE190901E24550@mi8nycmail19.Mi8.com>
    Reviewed-by: Yong Zhang <yong.zhang0@gmail.com>
    Cc: johnstul@us.ibm.com
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 08b8ff44354d5550d90eafd6cde87cb9f1d0ebcb
Author: Xiaotian Feng <dfeng@redhat.com>
Date:   Thu Jan 7 11:22:44 2010 +0800

    clockevent: Don't remove broadcast device when cpu is dead
    
    commit ea9d8e3f45404d411c00ae67b45cc35c58265bb7 upstream.
    
    Marc reported that the BUG_ON in clockevents_notify() triggers on his
    system. This happens because the kernel tries to remove an active
    clock event device (used for broadcasting) from the device list.
    
    The handling of devices which can be used as per cpu device and as a
    global broadcast device is suboptimal.
    
    The simplest solution for now (and for stable) is to check whether the
    device is used as global broadcast device, but this needs to be
    revisited.
    
    [ tglx: restored the cpuweight check and massaged the changelog ]
    
    Reported-by: Marc Dionne <marc.c.dionne@gmail.com>
    Tested-by: Marc Dionne <marc.c.dionne@gmail.com>
    Signed-off-by: Xiaotian Feng <dfeng@redhat.com>
    LKML-Reference: <1262834564-13033-1-git-send-email-dfeng@redhat.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit ea9d8e3f45404d411c00ae67b45cc35c58265bb7
Author: Xiaotian Feng <dfeng@redhat.com>
Date:   Thu Jan 7 11:22:44 2010 +0800

    clockevent: Don't remove broadcast device when cpu is dead
    
    Marc reported that the BUG_ON in clockevents_notify() triggers on his
    system. This happens because the kernel tries to remove an active
    clock event device (used for broadcasting) from the device list.
    
    The handling of devices which can be used as per cpu device and as a
    global broadcast device is suboptimal.
    
    The simplest solution for now (and for stable) is to check whether the
    device is used as global broadcast device, but this needs to be
    revisited.
    
    [ tglx: restored the cpuweight check and massaged the changelog ]
    
    Reported-by: Marc Dionne <marc.c.dionne@gmail.com>
    Tested-by: Marc Dionne <marc.c.dionne@gmail.com>
    Signed-off-by: Xiaotian Feng <dfeng@redhat.com>
    LKML-Reference: <1262834564-13033-1-git-send-email-dfeng@redhat.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@kernel.org

commit 1dc238632bbb4283ba2c789b2aeadb1a2743eb4f
Author: David VomLehn <dvomlehn@cisco.com>
Date:   Mon Dec 21 17:43:42 2009 -0800

    MIPS: PowerTV: Remove extra r4k_clockevent_init() call
    
    A call to r4k_clocksource_init() was added to plat_time_init(), but
    when init_mips_clock_source() calls the same function, boot fails in
    clockevents_register_device(). This patch removes the extraneous call.
    
    Signed-off-by: David VomLehn <dvomlehn@cisco.com>
    Patchwork: http://patchwork.linux-mips.org/patch/803/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

commit fa3f5a5c1c8e6a2cbc7e21755ea7c215f8cf0577
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Dec 10 15:35:10 2009 +0100

    clockevents: Prevent clockevent_devices list corruption on cpu hotplug
    
    commit bb6eddf7676e1c1f3e637aa93c5224488d99036f upstream.
    
    Xiaotian Feng triggered a list corruption in the clock events list on
    CPU hotplug and debugged the root cause.
    
    If a CPU registers more than one per cpu clock event device, then only
    the active clock event device is removed on CPU_DEAD. The unused
    devices are kept in the clock events device list.
    
    On CPU up the clock event devices are registered again, which means
    that we list_add an already enqueued list_head. That results in list
    corruption.
    
    Resolve this by removing all devices which are associated to the dead
    CPU on CPU_DEAD.
    
    Reported-by: Xiaotian Feng <dfeng@redhat.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Xiaotian Feng <dfeng@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 5c87f0c04abf876c8019c04ff581976a9a241206
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Dec 10 15:35:10 2009 +0100

    clockevents: Prevent clockevent_devices list corruption on cpu hotplug
    
    commit bb6eddf7676e1c1f3e637aa93c5224488d99036f upstream.
    
    Xiaotian Feng triggered a list corruption in the clock events list on
    CPU hotplug and debugged the root cause.
    
    If a CPU registers more than one per cpu clock event device, then only
    the active clock event device is removed on CPU_DEAD. The unused
    devices are kept in the clock events device list.
    
    On CPU up the clock event devices are registered again, which means
    that we list_add an already enqueued list_head. That results in list
    corruption.
    
    Resolve this by removing all devices which are associated to the dead
    CPU on CPU_DEAD.
    
    Reported-by: Xiaotian Feng <dfeng@redhat.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Xiaotian Feng <dfeng@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 3cd312c3e887b4bee2d94668a481b3d19c07732c
Merge: ecd5907a200b cf1e367ee84e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Dec 19 09:47:18 2009 -0800

    Merge branch 'timers-fixes-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'timers-fixes-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip:
      timers: Remove duplicate setting of new_base in __mod_timer()
      clockevents: Prevent clockevent_devices list corruption on cpu hotplug

commit 8f0ddf91f2aeb09602373e400cf8b403e9017210
Merge: 050cbb09dac0 b5f91da0a697
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Dec 15 09:02:01 2009 -0800

    Merge branch 'core-locking-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'core-locking-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip: (26 commits)
      clockevents: Convert to raw_spinlock
      clockevents: Make tick_device_lock static
      debugobjects: Convert to raw_spinlocks
      perf_event: Convert to raw_spinlock
      hrtimers: Convert to raw_spinlocks
      genirq: Convert irq_desc.lock to raw_spinlock
      smp: Convert smplocks to raw_spinlocks
      rtmutes: Convert rtmutex.lock to raw_spinlock
      sched: Convert pi_lock to raw_spinlock
      sched: Convert cpupri lock to raw_spinlock
      sched: Convert rt_runtime_lock to raw_spinlock
      sched: Convert rq->lock to raw_spinlock
      plist: Make plist debugging raw_spinlock aware
      bkl: Fixup core_lock fallout
      locking: Cleanup the name space completely
      locking: Further name space cleanups
      alpha: Fix fallout from locking changes
      locking: Implement new raw_spinlock
      locking: Convert raw_rwlock functions to arch_rwlock
      locking: Convert raw_rwlock to arch_rwlock
      ...

commit b5f91da0a6973bb6f9ff3b91b0e92c0773a458f3
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Dec 8 12:40:31 2009 +0100

    clockevents: Convert to raw_spinlock
    
    Convert locks which cannot be sleeping locks in preempt-rt to
    raw_spinlocks.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Peter Zijlstra <peterz@infradead.org>
    Acked-by: Ingo Molnar <mingo@elte.hu>

commit d192c47f25daa98996c7eae543d8a27e41247ec2
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Dec 8 12:49:26 2009 +0100

    clockevents: Make tick_device_lock static
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Peter Zijlstra <peterz@infradead.org>
    Acked-by: Ingo Molnar <mingo@elte.hu>

commit bb6eddf7676e1c1f3e637aa93c5224488d99036f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Dec 10 15:35:10 2009 +0100

    clockevents: Prevent clockevent_devices list corruption on cpu hotplug
    
    Xiaotian Feng triggered a list corruption in the clock events list on
    CPU hotplug and debugged the root cause.
    
    If a CPU registers more than one per cpu clock event device, then only
    the active clock event device is removed on CPU_DEAD. The unused
    devices are kept in the clock events device list.
    
    On CPU up the clock event devices are registered again, which means
    that we list_add an already enqueued list_head. That results in list
    corruption.
    
    Resolve this by removing all devices which are associated to the dead
    CPU on CPU_DEAD.
    
    Reported-by: Xiaotian Feng <dfeng@redhat.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Xiaotian Feng <dfeng@redhat.com>
    Cc: stable@kernel.org

commit 60d8ce2cd6c283132928c11f3fd57ff4187287e0
Merge: 849e8dea099a feae3203d711
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Dec 8 19:27:08 2009 -0800

    Merge branch 'timers-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'timers-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip:
      timers, init: Limit the number of per cpu calibration bootup messages
      posix-cpu-timers: optimize and document timer_create callback
      clockevents: Add missing include to pacify sparse
      x86: vmiclock: Fix printk format
      x86: Fix printk format due to variable type change
      sparc: fix printk for change of variable type
      clocksource/events: Fix fallout of generic code changes
      nohz: Allow 32-bit machines to sleep for more than 2.15 seconds
      nohz: Track last do_timer() cpu
      nohz: Prevent clocksource wrapping during idle
      nohz: Type cast printk argument
      mips: Use generic mult/shift factor calculation for clocks
      clocksource: Provide a generic mult/shift factor calculation
      clockevents: Use u32 for mult and shift factors
      nohz: Introduce arch_needs_cpu
      nohz: Reuse ktime in sub-functions of tick_check_idle.
      time: Remove xtime_cache
      time: Implement logarithmic time accumulation

commit 8e1a928a2ed7e8d5cad97c8e985294b4caedd168
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Fri Oct 16 18:19:01 2009 -0400

    clockevents: Add missing include to pacify sparse
    
    Include "tick-internal.h" in order to pick up the extern function
    prototype for clockevents_shutdown(). This quiets the following sparse
    build noise:
    
      warning: symbol 'clockevents_shutdown' was not declared. Should it be static?
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    LKML-Reference: <BD79186B4FD85F4B8E60E381CAEE190901E24550@mi8nycmail19.Mi8.com>
    Reviewed-by: Yong Zhang <yong.zhang0@gmail.com>
    Cc: johnstul@us.ibm.com
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 070e5c3f9989a72076e83fdd5ede3f0f3eb17264
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Nov 18 12:27:47 2009 +0100

    x86: vmiclock: Fix printk format
    
    clockevents.mult became u32. Fix the printk format.
    
    Pointed-out-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 411462f62a65eeae7f451c6eb7a38b9d8759c61a
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Nov 16 11:52:39 2009 +0100

    x86: Fix printk format due to variable type change
    
    clockevents.mult became u32. Fix the printk format.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 23af368e9a904f59256c27d371ce223d6cee0430
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Nov 11 14:05:25 2009 +0000

    clockevents: Use u32 for mult and shift factors
    
    The mult and shift factors of clock events differ in their data type
    from those of clock sources for no reason. u32 is sufficient for
    both. shift is always <= 32 and mult is limited to 2^32-1 to avoid
    64bit multiplication overflows in the conversion.
    
    Preparatory patch for a generic mult/shift factor calculation
    function.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Mikael Pettersson <mikpe@it.uu.se>
    Acked-by: Ralf Baechle <ralf@linux-mips.org>
    Acked-by: Linus Walleij <linus.walleij@stericsson.com>
    Cc: John Stultz <johnstul@us.ibm.com>
    LKML-Reference: <20091111134229.725664788@linutronix.de>

commit f533c3d340536198a4889a42a68d6c0d79a504e7
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Fri Oct 16 17:20:58 2009 +0900

    sh: Idle loop chainsawing for SMP-based light sleep.
    
    This does a bit of chainsawing of the idle loop code to get light sleep
    working on SMP. Previously this was forcing secondary CPUs in to sleep
    mode with them not coming back if they didn't have their own local
    timers. Given that we use clockevents broadcasting by default, the CPU
    managing the clockevents can't have IRQs disabled before entering its
    sleep state.
    
    This unfortunately leaves us with the age-old need_resched() race in
    between local_irq_enable() and cpu_sleep(), but at present this is
    unavoidable. After some more experimentation it may be possible to layer
    on SR.BL bit manipulation over top of this scheme to inhibit the race
    condition, but given the current potential for missing wakeups, this is
    left as a future exercise.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

commit 78f28b7c555359c67c2a0d23f7436e915329421e
Merge: 3240a77b515f 7bd867dfb4e0
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Sep 18 14:05:47 2009 -0700

    Merge branch 'x86-platform-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'x86-platform-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip: (38 commits)
      x86: Move get/set_wallclock to x86_platform_ops
      x86: platform: Fix section annotations
      x86: apic namespace cleanup
      x86: Distangle ioapic and i8259
      x86: Add Moorestown early detection
      x86: Add hardware_subarch ID for Moorestown
      x86: Add early platform detection
      x86: Move tsc_init to late_time_init
      x86: Move tsc_calibration to x86_init_ops
      x86: Replace the now identical time_32/64.c by time.c
      x86: time_32/64.c unify profile_pc
      x86: Move calibrate_cpu to tsc.c
      x86: Make timer setup and global variables the same in time_32/64.c
      x86: Remove mca bus ifdef from timer interrupt
      x86: Simplify timer_ack magic in time_32.c
      x86: Prepare unification of time_32/64.c
      x86: Remove do_timer hook
      x86: Add timer_init to x86_init_ops
      x86: Move percpu clockevents setup to x86_init_ops
      x86: Move xen_post_allocator_init into xen_pagetable_setup_done
      ...
    
    Fix up conflicts in arch/x86/include/asm/io_apic.h

commit 736decac643e8982655e22ac7f0e5e61c5b7f9bd
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Aug 19 12:35:53 2009 +0200

    x86: Move percpu clockevents setup to x86_init_ops
    
    paravirt overrides the setup of the default apic timers as per cpu
    timers. Moorestown needs to override that as well.
    
    Move it to x86_init_ops setup and create a separate x86_cpuinit struct
    which holds the function for the secondary evtl. hotplugabble CPUs.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 44afa9a4b8c5773f47e6494da12ca086c9ffea34
Merge: 7d63e6359a2e f833bab87fca
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Aug 25 11:24:04 2009 -0700

    Merge branch 'timers-fixes-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'timers-fixes-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip:
      clockevent: Prevent dead lock on clockevents_lock
      timers: Drop write permission on /proc/timer_list

commit f833bab87fca5c3ce13778421b1365845843b976
Author: Suresh Siddha <suresh.b.siddha@intel.com>
Date:   Mon Aug 17 14:34:59 2009 -0700

    clockevent: Prevent dead lock on clockevents_lock
    
    Currently clockevents_notify() is called with interrupts enabled at
    some places and interrupts disabled at some other places.
    
    This results in a deadlock in this scenario.
    
    cpu A holds clockevents_lock in clockevents_notify() with irqs enabled
    cpu B waits for clockevents_lock in clockevents_notify() with irqs disabled
    cpu C doing set_mtrr() which will try to rendezvous of all the cpus.
    
    This will result in C and A come to the rendezvous point and waiting
    for B. B is stuck forever waiting for the spinlock and thus not
    reaching the rendezvous point.
    
    Fix the clockevents code so that clockevents_lock is taken with
    interrupts disabled and thus avoid the above deadlock.
    
    Also call lapic_timer_propagate_broadcast() on the destination cpu so
    that we avoid calling smp_call_function() in the clockevents notifier
    chain.
    
    This issue left us wondering if we need to change the MTRR rendezvous
    logic to use stop machine logic (instead of smp_call_function) or add
    a check in spinlock debug code to see if there are other spinlocks
    which gets taken under both interrupts enabled/disabled conditions.
    
    Signed-off-by: Suresh Siddha <suresh.b.siddha@intel.com>
    Signed-off-by: Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>
    Cc: "Pallipadi Venkatesh" <venkatesh.pallipadi@intel.com>
    Cc: "Brown Len" <len.brown@intel.com>
    LKML-Reference: <1250544899.2709.210.camel@sbs-t61.sc.intel.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit fc6191dd301e3bc8cbb142aab1a2ec4e699cb2de
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed Aug 19 17:53:04 2009 +0900

    sh: Fix up clockevents broadcasting.
    
    This fixes up the clockevents broadcasting code as detailed in commit
    ee348d5a1d810bc9958cabb7c27302aab235d36e ("[ARM] realview: fix broadcast
    tick support"). This saves us from having to do strange ordering things
    with the broadcast clockevent device, relying on the rating instead.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

commit 6ff7041dbfeb3bd7dfe9aa67275c21199ef760d6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Jul 10 14:57:05 2009 +0200

    hrtimer: Fix migration expiry check
    
    The timer migration expiry check should prevent the migration of a
    timer to another CPU when the timer expires before the next event is
    scheduled on the other CPU. Migrating the timer might delay it because
    we can not reprogram the clock event device on the other CPU. But the
    code implementing that check has two flaws:
    
    - for !HIGHRES the check compares the expiry value with the clock
      events device expiry value which is wrong for CLOCK_REALTIME based
      timers.
    
    - the check is racy. It holds the hrtimer base lock of the target CPU,
      but the clock event device expiry value can be modified
      nevertheless, e.g. by an timer interrupt firing.
    
    The !HIGHRES case is easy to fix as we can enqueue the timer on the
    cpu which was selected by the load balancer. It runs the idle
    balancing code once per jiffy anyway. So the maximum delay for the
    timer is the same as when we keep the tick on the current cpu going.
    
    In the HIGHRES case we can get the next expiry value from the hrtimer
    cpu_base of the target CPU and serialize the update with the cpu_base
    lock. This moves the lock section in hrtimer_interrupt() so we can set
    next_event to KTIME_MAX while we are handling the expired timers and
    set it to the next expiry value after we handled the timers under the
    base lock. While the expired timers are processed timer migration is
    blocked because the expiry time of the timer is always <= KTIME_MAX.
    
    Also remove the now useless clockevents_get_next_event() function.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit be890a1a95fb439594e796f1968f86ee9f36e718
Author: Magnus Damm <damm@igel.co.jp>
Date:   Wed Jun 17 05:04:04 2009 +0000

    sh: turn off irqs when disabling CMT/TMU timers
    
    Modify the CMT and TMU drivers to disable interrupts when
    disabling the timer. Only using start/stop bits is not
    enough.
    
    This fixes a bootup hang on Migo-R when the CMT is replaced
    by TMU for clockevents but the CMT keeps on delivering irqs
    even though the timer start bit is off.
    
    Signed-off-by: Magnus Damm <damm@igel.co.jp>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

commit f9db6e095115f9411b9647bdb9d81fe11f3d8b54
Merge: 3f27c0d2a469 c81fc2c331b8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jun 15 09:58:50 2009 -0700

    Merge branch 'timers-for-linus-clockevents' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'timers-for-linus-clockevents' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip:
      clockevent: export register_device and delta2ns
      clockevents: tick_broadcast_device can become static

commit 6fe32a468521d45edc35d92cdc05cd74e930426a
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Sun Jun 14 20:02:30 2009 +0900

    sh: Bump the earlytimer probe devices up.
    
    Presently the earlytimer probe handles the clockevents driver, which
    requires that the clockevents driver be registered first. This bumps it
    up by 1 to include the clocksource device, which can be safely ignored
    if it doesn't exist, as we will simply error out on that path and defer
    to the jiffies clocksource.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

commit eea08f32adb3f97553d49a4f79a119833036000a
Author: Arun R Bharadwaj <arun@linux.vnet.ibm.com>
Date:   Thu Apr 16 12:16:41 2009 +0530

    timers: Logic to move non pinned timers
    
    * Arun R Bharadwaj <arun@linux.vnet.ibm.com> [2009-04-16 12:11:36]:
    
    This patch migrates all non pinned timers and hrtimers to the current
    idle load balancer, from all the idle CPUs. Timers firing on busy CPUs
    are not migrated.
    
    While migrating hrtimers, care should be taken to check if migrating
    a hrtimer would result in a latency or not. So we compare the expiry of the
    hrtimer with the next timer interrupt on the target cpu and migrate the
    hrtimer only if it expires *after* the next interrupt on the target cpu.
    So, added a clockevents_get_next_event() helper function to return the
    next_event on the target cpu's clock_event_device.
    
    [ tglx: cleanups and simplifications ]
    
    Signed-off-by: Arun R Bharadwaj <arun@linux.vnet.ibm.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 1fff7d359d6cc49bb9a276134bd7d90366f74110
Author: John Stultz <johnstul@us.ibm.com>
Date:   Fri May 1 13:10:25 2009 -0700

    clockevents: prevent endless loop in tick_handle_periodic()
    
    commit 74a03b69d1b5ce00a568e142ca97e76b7f5239c6 upstream.
    
    tick_handle_periodic() can lock up hard when a one shot clock event
    device is used in combination with jiffies clocksource.
    
    Avoid an endless loop issue by requiring that a highres valid
    clocksource be installed before we call tick_periodic() in a loop when
    using ONESHOT mode. The result is we will only increment jiffies once
    per interrupt until a continuous hardware clocksource is available.
    
    Without this, we can run into a endless loop, where each cycle through
    the loop, jiffies is updated which increments time by tick_period or
    more (due to clock steering), which can cause the event programming to
    think the next event was before the newly incremented time and fail
    causing tick_periodic() to be called again and the whole process loops
    forever.
    
    [ Impact: prevent hard lock up ]
    
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 2ee201a9d57df7a12e228c6a9b06a15014231b72
Author: John Stultz <johnstul@us.ibm.com>
Date:   Fri May 1 13:10:25 2009 -0700

    clockevents: prevent endless loop in tick_handle_periodic()
    
    commit 74a03b69d1b5ce00a568e142ca97e76b7f5239c6 upstream.
    
    tick_handle_periodic() can lock up hard when a one shot clock event
    device is used in combination with jiffies clocksource.
    
    Avoid an endless loop issue by requiring that a highres valid
    clocksource be installed before we call tick_periodic() in a loop when
    using ONESHOT mode. The result is we will only increment jiffies once
    per interrupt until a continuous hardware clocksource is available.
    
    Without this, we can run into a endless loop, where each cycle through
    the loop, jiffies is updated which increments time by tick_period or
    more (due to clock steering), which can cause the event programming to
    think the next event was before the newly incremented time and fail
    causing tick_periodic() to be called again and the whole process loops
    forever.
    
    [ Impact: prevent hard lock up ]
    
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 6459d7bb72e9767bc7d22f2ee44aab35188e4b8a
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Fri May 8 16:47:48 2009 +0900

    sh: Kill off dead timer sysclass pm hooks.
    
    With the conversion to generic clockevents these are completely unused,
    so just kill it off.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

commit 99ee12973e5fd1123ed1779fb4d11ac7d381d430
Merge: bcb16568275a 74a03b69d1b5
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue May 5 12:09:38 2009 -0700

    Merge branch 'timers/urgent' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'timers/urgent' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip:
      clockevents: prevent endless loop in tick_handle_periodic()

commit 25483efeb2e56521e418a59fa93401be156dc3bb
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Sun May 3 18:29:27 2009 +0900

    sh: Move dummy clockevents broadcast timer to its new home.
    
    The old arch/sh/kernel/timers/ directly will be going away completely
    once the rest of the TMU users are migrated, so move the dummy broadcast
    driver up a level in preparation.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

commit 938edae11ee3a7b20b6d754074a0f2c2edc4534b
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Sun May 3 18:12:26 2009 +0900

    sh: select both GENERIC_TIME and GENERIC_CLOCKEVENTS.
    
    Now that the rest of the timers that didn't support clockevents have been
    rewritten, both of these can be enabled by default.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

commit 9570ef20423b549757aa484ad388f9a7d5bdc4d9
Author: Magnus Damm <damm@igel.co.jp>
Date:   Fri May 1 06:51:00 2009 +0000

    clocksource: SuperH TMU Timer driver
    
    This patch adds a TMU driver for the SuperH architecture.
    
    The TMU driver is a platform driver with early platform
    support to allow using a TMU channel as clockevent or
    clocksource during system bootup or later.
    
    Clocksource or clockevent can be selected.
    Both periodic and oneshot clockevents are supported.
    
    Signed-off-by: Magnus Damm <damm@igel.co.jp>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

commit c81fc2c331b8514ad112054cd2d87e6ec132286b
Author: Magnus Damm <magnus.damm@gmail.com>
Date:   Fri May 1 14:52:47 2009 +0900

    clockevent: export register_device and delta2ns
    
    Export the following symbols using EXPORT_SYMBOL_GPL:
     - clockevent_delta2ns
     - clockevents_register_device
    
    This allows us to build SuperH clockevent and clocksource
    drivers as modules, see drivers/clocksource/sh_*.c
    
    [ Impact: allow modular build of clockevent drivers ]
    
    Signed-off-by: Magnus Damm <damm@igel.co.jp>
    LKML-Reference: <20090501055247.8286.64067.sendpatchset@rx1.opensource.se>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit a52f5c5620673c292cb159205bf0e1eb5af1985b
Author: Dmitri Vorobiev <dmitri.vorobiev@movial.com>
Date:   Fri May 1 13:10:21 2009 -0700

    clockevents: tick_broadcast_device can become static
    
    The variable tick_broadcast_device is not used outside of the
    file where it is defined, so let's make it static.
    
    Signed-off-by: Dmitri Vorobiev <dmitri.vorobiev@movial.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 74a03b69d1b5ce00a568e142ca97e76b7f5239c6
Author: John Stultz <johnstul@us.ibm.com>
Date:   Fri May 1 13:10:25 2009 -0700

    clockevents: prevent endless loop in tick_handle_periodic()
    
    tick_handle_periodic() can lock up hard when a one shot clock event
    device is used in combination with jiffies clocksource.
    
    Avoid an endless loop issue by requiring that a highres valid
    clocksource be installed before we call tick_periodic() in a loop when
    using ONESHOT mode. The result is we will only increment jiffies once
    per interrupt until a continuous hardware clocksource is available.
    
    Without this, we can run into a endless loop, where each cycle through
    the loop, jiffies is updated which increments time by tick_period or
    more (due to clock steering), which can cause the event programming to
    think the next event was before the newly incremented time and fail
    causing tick_periodic() to be called again and the whole process loops
    forever.
    
    [ Impact: prevent hard lock up ]
    
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@kernel.org

commit 3014f47460ecfb13d4169daae51f26a20bacfa17
Author: Magnus Damm <damm@igel.co.jp>
Date:   Wed Apr 29 14:50:37 2009 +0000

    clocksource: sh_cmt 16-bit fixes
    
    This patch contains various fixes for 16-bit cmt hardware.
    With this applied periodic clockevents work fine on sh7203.
    
    Signed-off-by: Magnus Damm <damm@igel.co.jp>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

commit bb3cee2b35d2b9edab71997bd06040ff37483e08
Author: Linus Walleij <linus.walleij@stericsson.com>
Date:   Thu Apr 23 10:22:13 2009 +0100

    [ARM] 5473/1: U300 core machine support
    
    This adds core support for the ST-Ericsson U300 series
    platforms: U300, U330, U335 and U365. Supports memory
    mappings, interrupt controller, system timer (clocksource
    and clockevents), and binds to the existing drivers for
    the PrimeCells used in this design: PL190 (VIC), PL180
    (MMC/SD host) and PL011 (UART). This is intented to serve
    as starting point for our mainling work, more patches to
    follow.
    
    Signed-off-by: Linus Walleij <linus.walleij@stericsson.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

commit f461ddea0af8b98e2b7940eba9c693b0ee44d64a
Author: Len Brown <len.brown@intel.com>
Date:   Thu Apr 23 18:59:43 2009 -0400

    ACPI/hpet: prevent boot hang when hpet=force used on ICH-4M
    
    Linux tells ICH4 users that they can (manually) invoke
    "hpet=force" to enable the undocumented ICH-4M HPET.
    The HPET becomes available for both clocksource and clockevents.
    
    But as of ff69f2bba67bd45514923aaedbf40fe351787c59
    (acpi: fix of pmtimer overflow that make Cx states time incorrect)
    the HPET may be used via clocksource for idle accounting, and
    hpet=force on an ICH4 box hangs boot.
    
    It turns out that touching the MMIO HPET withing
    the ARB_DIS part of C3 will hang the hardware.
    
    The fix is to simply move the timer access outside
    the ARB_DIS region.  This is a no-op on modern hardware
    because ARB_DIS is no longer used.
    
    http://bugzilla.kernel.org/show_bug.cgi?id=13087
    
    Acked-by: Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

commit 6a3395beb99d7ae882ddf701c6fa6005ad7edebf
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Thu Apr 16 15:36:13 2009 +0900

    sh: sh7724: Add CMT clockevents support.
    
    This enables support for the CMT clockevents driver on SH7724.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

commit 5ab5ab34498f94d60884c4ccea890601e429042e
Author: Dimitri Sivanich <sivanich@sgi.com>
Date:   Wed Mar 4 12:59:18 2009 -0600

    x86: UV, SGI RTC: add UV RTC clocksource/clockevents
    
    This patch provides a high resolution clock/timer source using the
    SGI UV system-wide synchronized RTC clock/timer hardware.
    
    Signed-off-by: Dimitri Sivanich <sivanich@sgi.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: john stultz <johnstul@us.ibm.com>
    LKML-Reference: <20090304185918.GC24419@sgi.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

commit 5b058bcde961bf28678a70e44c079107313543b6
Author: Frederic Weisbecker <fweisbec@gmail.com>
Date:   Tue Feb 17 18:35:34 2009 +0100

    tracing/function-graph-tracer: trace the idle tasks
    
    When the function graph tracer is activated, it iterates over the task_list
    to allocate a stack to store the return addresses.
    
    But the per cpu idle tasks are not iterated by using
    do_each_thread / while_each_thread.
    
    So we have to iterate on them manually.
    
    This fixes somes weirdness in the traces and many losses of traces.
    Examples on two cpus:
    
     0)   Xorg-4287    |   2.906 us    |              }
     0)   Xorg-4287    |   3.965 us    |            }
     0)   Xorg-4287    |   5.302 us    |          }
     ------------------------------------------
     0)   Xorg-4287    =>    <idle>-0
     ------------------------------------------
    
     0)    <idle>-0    |   2.861 us    |                        }
     0)    <idle>-0    |   0.526 us    |                        set_normalized_timespec();
     0)    <idle>-0    |   7.201 us    |                      }
     0)    <idle>-0    |   8.214 us    |                    }
     0)    <idle>-0    |               |                    clockevents_program_event() {
     0)    <idle>-0    |               |                      lapic_next_event() {
     0)    <idle>-0    |   0.510 us    |                        native_apic_mem_write();
     0)    <idle>-0    |   1.546 us    |                      }
     0)    <idle>-0    |   2.583 us    |                    }
     0)    <idle>-0    | + 12.435 us   |                  }
     0)    <idle>-0    | + 13.470 us   |                }
     0)    <idle>-0    |   0.608 us    |                _spin_unlock_irqrestore();
     0)    <idle>-0    | + 23.270 us   |              }
     0)    <idle>-0    | + 24.336 us   |            }
     0)    <idle>-0    | + 25.417 us   |          }
     0)    <idle>-0    |   0.593 us    |          _spin_unlock();
     0)    <idle>-0    | + 41.869 us   |        }
     0)    <idle>-0    | + 42.906 us   |      }
     0)    <idle>-0    | + 95.035 us   |    }
     0)    <idle>-0    |   0.540 us    |    menu_reflect();
     0)    <idle>-0    | ! 100.404 us  |  }
     0)    <idle>-0    |   0.564 us    |  mce_idle_callback();
     0)    <idle>-0    |               |  enter_idle() {
     0)    <idle>-0    |   0.526 us    |    mce_idle_callback();
     0)    <idle>-0    |   1.757 us    |  }
     0)    <idle>-0    |               |  cpuidle_idle_call() {
     0)    <idle>-0    |               |    menu_select() {
     0)    <idle>-0    |   0.525 us    |      pm_qos_requirement();
     0)    <idle>-0    |   0.518 us    |      tick_nohz_get_sleep_length();
     0)    <idle>-0    |   2.621 us    |    }
    [...]
     1)    <idle>-0    |   0.518 us    |              touch_softlockup_watchdog();
     1)    <idle>-0    | + 14.355 us   |            }
     1)    <idle>-0    | + 22.840 us   |          }
     1)    <idle>-0    | + 25.949 us   |        }
     1)    <idle>-0    |               |        handle_irq() {
     1)    <idle>-0    |   0.511 us    |          irq_to_desc();
     1)    <idle>-0    |               |          handle_edge_irq() {
     1)    <idle>-0    |   0.638 us    |            _spin_lock();
     1)    <idle>-0    |               |            ack_apic_edge() {
     1)    <idle>-0    |   0.510 us    |              irq_to_desc();
     1)    <idle>-0    |               |              move_native_irq() {
     1)    <idle>-0    |   0.510 us    |                irq_to_desc();
     1)    <idle>-0    |   1.532 us    |              }
     1)    <idle>-0    |   0.511 us    |              native_apic_mem_write();
     ------------------------------------------
     1)    <idle>-0    =>    cat-5073
     ------------------------------------------
    
     1)    cat-5073    |   3.731 us    |                    }
     1)    cat-5073    |               |                    run_local_timers() {
     1)    cat-5073    |   0.533 us    |                      hrtimer_run_queues();
     1)    cat-5073    |               |                      raise_softirq() {
     1)    cat-5073    |               |                        __raise_softirq_irqoff() {
     1)    cat-5073    |               |                          /* nr: 1 */
     1)    cat-5073    |   2.718 us    |                        }
     1)    cat-5073    |   3.814 us    |                      }
    
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

commit 5ba1ae92b6796b3367152ccd9baa022dde7eed4c
Merge: ae1a25da8448 2d68259db26a 42bb8cc5e810 6626bff24578 ff08f76d738d
Author: Ingo Molnar <mingo@elte.hu>
Date:   Sun Feb 8 20:14:11 2009 +0100

    Merge branches 'timers/clockevents', 'timers/hpet', 'timers/hrtimers' and 'timers/urgent' into timers/core

commit b0a9b5111abf60ef07eade834f480e89004c7920
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun Jan 25 11:31:36 2009 +0100

    hrtimer: prevent negative expiry value after clock_was_set()
    
    Impact: prevent false positive WARN_ON() in clockevents_program_event()
    
    clock_was_set() changes the base->offset of CLOCK_REALTIME and
    enforces the reprogramming of the clockevent device to expire timers
    which are based on CLOCK_REALTIME. If the clock change is large enough
    then the subtraction of the timer expiry value and base->offset can
    become negative which triggers the warning in
    clockevents_program_event().
    
    Check the subtraction result and set a negative value to 0.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 3fb1b6ad0679ad671bd496712b2a088550ee86b2
Author: Magnus Damm <damm@igel.co.jp>
Date:   Thu Jan 22 09:55:59 2009 +0000

    sh: CMT clockevent platform driver
    
    SuperH CMT clockevent driver.
    
    Both 16-bit and 32-bit CMT versions are supported, but only 32-bit
    is tested. This driver contains support for both clockevents and
    clocksources, but no unregistration is supported at this point.
    
    Works fine as clock source and/or event in periodic or oneshot mode.
    Tested on sh7722 and sh7723, but should work with any cpu/architecture.
    
    This version is lacking clocksource and early platform driver support
    for now - this to minimize the amount of dependencies.
    
    Signed-off-by: Magnus Damm <damm@igel.co.jp>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

commit 70f0800133b2a6d694c10908b8673a5327b3bfd6
Author: Magnus Damm <damm@igel.co.jp>
Date:   Thu Jan 22 09:55:40 2009 +0000

    sh: tmu disable support
    
    Add TMU disable support so we can use other clockevents.
    Also, setup the clockevent rating.
    
    Signed-off-by: Magnus Damm <damm@igel.co.jp>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

commit 6626bff24578753808c8b5bd4f1619e14e980f0f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun Jan 25 11:31:36 2009 +0100

    hrtimer: prevent negative expiry value after clock_was_set()
    
    Impact: prevent false positive WARN_ON() in clockevents_program_event()
    
    clock_was_set() changes the base->offset of CLOCK_REALTIME and
    enforces the reprogramming of the clockevent device to expire timers
    which are based on CLOCK_REALTIME. If the clock change is large enough
    then the subtraction of the timer expiry value and base->offset can
    become negative which triggers the warning in
    clockevents_program_event().
    
    Check the subtraction result and set a negative value to 0.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 1d4a7f1c4faf53eb9e822743ec8a70b3019a26d2
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Sun Jan 18 16:39:29 2009 +0100

    hrtimers: fix inconsistent lock state on resume in hres_timers_resume
    
    Andrey Borzenkov reported this lockdep assert:
    
    > [17854.688347] =================================
    > [17854.688347] [ INFO: inconsistent lock state ]
    > [17854.688347] 2.6.29-rc2-1avb #1
    > [17854.688347] ---------------------------------
    > [17854.688347] inconsistent {in-hardirq-W} -> {hardirq-on-W} usage.
    > [17854.688347] pm-suspend/18240 [HC0[0]:SC0[0]:HE1:SE1] takes:
    > [17854.688347]  (&cpu_base->lock){++..}, at: [<c0136fcc>] retrigger_next_event+0x5c/0xa0
    > [17854.688347] {in-hardirq-W} state was registered at:
    > [17854.688347]   [<c01443cd>] __lock_acquire+0x79d/0x1930
    > [17854.688347]   [<c01455bc>] lock_acquire+0x5c/0x80
    > [17854.688347]   [<c03092e5>] _spin_lock+0x35/0x70
    > [17854.688347]   [<c0136e61>] hrtimer_run_queues+0x31/0x140
    > [17854.688347]   [<c0128d98>] run_local_timers+0x8/0x20
    > [17854.688347]   [<c0128dd3>] update_process_times+0x23/0x60
    > [17854.688347]   [<c013e274>] tick_periodic+0x24/0x80
    > [17854.688347]   [<c013e2e2>] tick_handle_periodic+0x12/0x70
    > [17854.688347]   [<c0104e24>] timer_interrupt+0x14/0x20
    > [17854.688347]   [<c01607b9>] handle_IRQ_event+0x29/0x60
    > [17854.688347]   [<c0161c59>] handle_level_irq+0x69/0xe0
    > [17854.688347]   [<ffffffff>] 0xffffffff
    > [17854.688347] irq event stamp: 55771
    > [17854.688347] hardirqs last  enabled at (55771): [<c0309125>] _spin_unlock_irqrestore+0x35/0x60
    > [17854.688347] hardirqs last disabled at (55770): [<c0309419>] _spin_lock_irqsave+0x19/0x80
    > [17854.688347] softirqs last  enabled at (54836): [<c0124f54>] __do_softirq+0xc4/0x110
    > [17854.688347] softirqs last disabled at (54831): [<c01049ae>] do_softirq+0x8e/0xe0
    > [17854.688347]
    > [17854.688347] other info that might help us debug this:
    > [17854.688347] 3 locks held by pm-suspend/18240:
    > [17854.688347]  #0:  (&buffer->mutex){--..}, at: [<c01dd4c5>] sysfs_write_file+0x25/0x100
    > [17854.688347]  #1:  (pm_mutex){--..}, at: [<c015056f>] enter_state+0x4f/0x140
    > [17854.688347]  #2:  (dpm_list_mtx){--..}, at: [<c027880f>] device_pm_lock+0xf/0x20
    > [17854.688347]
    > [17854.688347] stack backtrace:
    > [17854.688347] Pid: 18240, comm: pm-suspend Not tainted 2.6.29-rc2-1avb #1
    > [17854.688347] Call Trace:
    > [17854.688347]  [<c0306248>] ? printk+0x18/0x20
    > [17854.688347]  [<c0141fac>] print_usage_bug+0x16c/0x1d0
    > [17854.688347]  [<c0142bcf>] mark_lock+0x8bf/0xc90
    > [17854.688347]  [<c0106b8f>] ? pit_next_event+0x2f/0x40
    > [17854.688347]  [<c01441b0>] __lock_acquire+0x580/0x1930
    > [17854.688347]  [<c030916d>] ? _spin_unlock+0x1d/0x20
    > [17854.688347]  [<c0106b8f>] ? pit_next_event+0x2f/0x40
    > [17854.688347]  [<c013dd38>] ? clockevents_program_event+0x98/0x160
    > [17854.688347]  [<c0142fe8>] ? mark_held_locks+0x48/0x90
    > [17854.688347]  [<c0309125>] ? _spin_unlock_irqrestore+0x35/0x60
    > [17854.688347]  [<c0143229>] ? trace_hardirqs_on_caller+0x139/0x190
    > [17854.688347]  [<c014328b>] ? trace_hardirqs_on+0xb/0x10
    > [17854.688347]  [<c01455bc>] lock_acquire+0x5c/0x80
    > [17854.688347]  [<c0136fcc>] ? retrigger_next_event+0x5c/0xa0
    > [17854.688347]  [<c03092e5>] _spin_lock+0x35/0x70
    > [17854.688347]  [<c0136fcc>] ? retrigger_next_event+0x5c/0xa0
    > [17854.688347]  [<c0136fcc>] retrigger_next_event+0x5c/0xa0
    > [17854.688347]  [<c013711a>] hres_timers_resume+0xa/0x10
    > [17854.688347]  [<c013aa8e>] timekeeping_resume+0xee/0x150
    > [17854.688347]  [<c0273384>] __sysdev_resume+0x14/0x50
    > [17854.688347]  [<c0273407>] sysdev_resume+0x47/0x80
    > [17854.688347]  [<c02791ab>] device_power_up+0xb/0x20
    > [17854.688347]  [<c015043f>] suspend_devices_and_enter+0xcf/0x150
    > [17854.688347]  [<c0150c2f>] ? freeze_processes+0x3f/0x90
    > [17854.688347]  [<c0150614>] enter_state+0xf4/0x140
    > [17854.688347]  [<c01506dd>] state_store+0x7d/0xc0
    > [17854.688347]  [<c0150660>] ? state_store+0x0/0xc0
    > [17854.688347]  [<c0202da4>] kobj_attr_store+0x24/0x30
    > [17854.688347]  [<c01dd53c>] sysfs_write_file+0x9c/0x100
    > [17854.688347]  [<c019916c>] vfs_write+0x9c/0x160
    > [17854.688347]  [<c0103494>] ? restore_nocheck_notrace+0x0/0xe
    > [17854.688347]  [<c01dd4a0>] ? sysfs_write_file+0x0/0x100
    > [17854.688347]  [<c01992ed>] sys_write+0x3d/0x70
    > [17854.688347]  [<c0103371>] sysenter_do_call+0x12/0x31
    
    Andrey's analysis:
    
    > timekeeping_resume() is called via class ->resume
    > method; and according to comments in sysdev_resume() and
    > device_power_up(), they are called with interrupts disabled.
    >
    > Looking at suspend_enter, irqs *are* disabled at this point.
    >
    > So it actually looks like something (may be some driver)
    > unconditionally enabled irqs in resume path.
    
    Add a debug check to test this theory. If it triggers then it
    triggers because the resume code calls it with irqs enabled,
    which is a no-no not just for timekeeping_resume(), but also
    bad for a number of other resume handlers.
    
    Reported-by: Andrey Borzenkov <arvidjaar@mail.ru>
    Signed-off-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

commit 275719089bfe7dbf446b72c3e520966e7fa42b6a
Author: Artur Skawina <art.08.09@gmail.com>
Date:   Thu Jan 15 21:07:03 2009 +0100

    p54: set_tim must be atomic.
    
    Fix for:
    
    BUG: scheduling while atomic: named/2004/0x10000200
    Pid: 2004, comm: named Not tainted 2.6.29-rc1-00271-ge9fa6b0 #45
    Call Trace:
     [<c04d4ef7>] schedule+0x2a7/0x320
     [<c03aed74>] __alloc_skb+0x34/0x110
     [<c011f5b3>] __cond_resched+0x13/0x30
     [<c04d501d>] _cond_resched+0x2d/0x40
     [<c016d8c5>] kmem_cache_alloc+0x95/0xc0
     [<c016b8d4>] check_object+0xc4/0x230
     [<c03aed74>] __alloc_skb+0x34/0x110
     [<c02ede91>] p54_alloc_skb+0x71/0xf0
     [<c02ee36f>] p54_set_tim+0x3f/0xa0
     [<c04ae064>] sta_info_set_tim_bit+0x64/0x80
     [<c04c1017>] invoke_tx_handlers+0xd57/0xd80
     [<c016c397>] free_debug_processing+0x197/0x210
     [<c03ae215>] pskb_expand_head+0xf5/0x170
     [<c04bfd94>] __ieee80211_tx_prepare+0x164/0x2f0
     [<c04c1a8d>] ieee80211_skb_resize+0x6d/0xe0
     [<c04c250f>] ieee80211_master_start_xmit+0x23f/0x550
     [<c016d188>] __slab_alloc+0x2b8/0x4f0
     [<c013a711>] getnstimeofday+0x51/0x120
     [<c03b5e7b>] dev_hard_start_xmit+0x1db/0x240
     [<c03c6a4b>] __qdisc_run+0x1ab/0x200
     [<c0136aa1>] __run_hrtimer+0x31/0xf0
     [<c03b6247>] dev_queue_xmit+0x247/0x500
     [<c04c1e56>] ieee80211_subif_start_xmit+0x356/0x7d0
     [<c0466ff7>] packet_rcv_spkt+0x37/0x150
     [<c0466ff7>] packet_rcv_spkt+0x37/0x150
     [<c03b5e7b>] dev_hard_start_xmit+0x1db/0x240
     [<c03c6a4b>] __qdisc_run+0x1ab/0x200
     [<c03b6247>] dev_queue_xmit+0x247/0x500
     [<c03bc1e2>] neigh_resolve_output+0xe2/0x200
     [<c0410080>] ip_finish_output+0x0/0x290
     [<c0410267>] ip_finish_output+0x1e7/0x290
     [<c040f355>] ip_local_out+0x15/0x20
     [<c040f5d2>] ip_push_pending_frames+0x272/0x380
     [<c042bbc6>] udp_push_pending_frames+0x146/0x3a0
     [<c042d52a>] udp_sendmsg+0x2fa/0x6b0
     [<c0433bc7>] inet_sendmsg+0x37/0x70
     [<c03a7b7e>] sock_sendmsg+0xbe/0x100
     [<c0133cd0>] autoremove_wake_function+0x0/0x50
     [<c011c043>] __wake_up_common+0x43/0x70
     [<c024a892>] copy_from_user+0x32/0x130
     [<c024a892>] copy_from_user+0x32/0x130
     [<c03b001e>] verify_iovec+0x2e/0xb0
     [<c03a7d3f>] sys_sendmsg+0x17f/0x290
     [<c017730a>] pipe_write+0x29a/0x570
     [<c013a172>] update_wall_time+0x492/0x8e0
     [<c013a711>] getnstimeofday+0x51/0x120
     [<c011b05d>] sched_slice+0x3d/0x80
     [<c013a711>] getnstimeofday+0x51/0x120
     [<c0136657>] hrtimer_forward+0x147/0x1a0
     [<c01101b0>] lapic_next_event+0x10/0x20
     [<c013ccb3>] clockevents_program_event+0xa3/0x170
     [<c03a9054>] sys_socketcall+0xa4/0x290
     [<c0110920>] smp_apic_timer_interrupt+0x40/0x70
     [<c0103165>] sysenter_do_call+0x12/0x25
    
    Signed-off-by: Artur Skawina <art.08.09@gmail.com>
    Acked-by: Christian Lamparter <chunkeey@web.de>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

commit 2d68259db26ad57fd9643f1c69b5181ec9836ca9
Author: Magnus Damm <magnus.damm@gmail.com>
Date:   Fri Jan 16 17:14:38 2009 +0900

    clockevents: let set_mode() setup delta information
    
    Allow the set_mode() clockevent callback to decide and fill in delta
    details such as shift, mult, max_delta_ns and min_delta_ns.
    
    With this change the clockevent can be registered without delta details
    which allows us to keep the parent clock disabled until the clockevent
    gets setup using set_mode().
    
    Letting set_mode() fill in or update delta details allows us to save
    power by disabling the parent clock while the clockevent is unused.
    This may however make the parent clock rate change, so next time the
    clockevent gets enabled we need let set_mode() to update the detla
    details accordingly. Doing it at registration time is not enough.
    
    Furthermore, the delta details seem unused in the case of periodic-only
    clockevent drivers, so this change also allows registration of such
    drivers without the delta details filled in.
    
    Signed-off-by: Magnus Damm <damm@igel.co.jp>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 320ab2b0b1e08e3805a3e1084a2f0eb1938d5d67
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Sat Dec 13 21:20:26 2008 +1030

    cpumask: convert struct clock_event_device to cpumask pointers.
    
    Impact: change calling convention of existing clock_event APIs
    
    struct clock_event_timer's cpumask field gets changed to take pointer,
    as does the ->broadcast function.
    
    Another single-patch change.  For safety, we BUG_ON() in
    clockevents_register_device() if it's not set.
    
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
    Cc: Ingo Molnar <mingo@elte.hu>

commit 2fcfe6b872b21639dcffbaf3ca2a84ec01d104e0
Author: Uwe Kleine-Knig <u.kleine-koenig@pengutronix.de>
Date:   Tue Dec 9 21:57:24 2008 +0100

    netx: add support for clockevents
    
    This is based on a patch by Luotao Fu <lfu@pengutronix.de>
    
    Signed-off-by: Uwe Kleine-Knig <u.kleine-koenig@pengutronix.de>
    Acked-by: Luotao Fu <lfu@pengutronix.de>
    Acked-by: Sascha Hauer <s.hauer@pengutronix.de>

commit c793033945bea23d7a6e0d8d94b2da6603e02af2
Author: Bob Copeland <me@bobcopeland.com>
Date:   Mon Nov 3 22:14:00 2008 -0500

    ath5k: correct handling of rx status fields
    
    ath5k_rx_status fields rs_antenna and rs_more are u8s, but we
    were setting them with bitwise ANDs of 32-bit values.
    
    As a consequence, jumbo frames would not be discarded as intended.
    Then, because the hw rate value of such frames is zero, and, since
    "ath5k: rates cleanup", we do not fall back to the basic rate, such
    packets would trigger the following WARN_ON:
    
    ------------[ cut here ]------------
    WARNING: at net/mac80211/rx.c:2192 __ieee80211_rx+0x4d/0x57e [mac80211]()
    Modules linked in: ath5k af_packet sha256_generic aes_i586 aes_generic cbc loop i915 drm binfmt_misc acpi_cpufreq fan container nls_utf8 hfsplus dm_crypt dm_mod kvm_intel kvm fuse sbp2 snd_hda_intel snd_pcm_oss snd_pcm snd_mixer_oss snd_seq_dummy snd_seq_oss arc4 joydev hid_apple ecb snd_seq_midi snd_rawmidi snd_seq_midi_event snd_seq snd_timer snd_seq_device usbhid appletouch mac80211 sky2 snd ehci_hcd ohci1394 bitrev crc32 sr_mod cdrom rtc sg uhci_hcd snd_page_alloc cfg80211 ieee1394 thermal ac battery processor button evdev unix [last unloaded: ath5k]
    Pid: 0, comm: swapper Tainted: G        W  2.6.28-rc2-wl #14
    Call Trace:
     [<c0123d1e>] warn_on_slowpath+0x41/0x5b
     [<c012005d>] ? sched_debug_show+0x31e/0x9c6
     [<c012489f>] ? vprintk+0x369/0x389
     [<c0309539>] ? _spin_unlock_irqrestore+0x54/0x58
     [<c011cd8f>] ? try_to_wake_up+0x14f/0x15a
     [<f81918cb>] __ieee80211_rx+0x4d/0x57e [mac80211]
     [<f828872a>] ath5k_tasklet_rx+0x5a1/0x5e4 [ath5k]
     [<c013b9cd>] ? clockevents_program_event+0xd4/0xe3
     [<c01283a9>] tasklet_action+0x94/0xfd
     [<c0127d19>] __do_softirq+0x8c/0x13e
     [<c0127e04>] do_softirq+0x39/0x55
     [<c0128082>] irq_exit+0x46/0x85
     [<c010576c>] do_IRQ+0x9a/0xb2
     [<c010461c>] common_interrupt+0x28/0x30
     [<f80e934a>] ? acpi_idle_enter_bm+0x2ad/0x31b [processor]
     [<c02976bf>] cpuidle_idle_call+0x65/0x9a
     [<c010262c>] cpu_idle+0x76/0xa6
     [<c02fb402>] rest_init+0x62/0x64
    
    Signed-off-by: Bob Copeland <me@bobcopeland.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

commit 99ebcf8285df28f32fd2d1c19a7166e70f00309c
Merge: 72558dde738b c465a76af658
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Oct 20 13:19:56 2008 -0700

    Merge branch 'v28-timers-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'v28-timers-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip: (36 commits)
      fix documentation of sysrq-q really
      Fix documentation of sysrq-q
      timer_list: add base address to clock base
      timer_list: print cpu number of clockevents device
      timer_list: print real timer address
      NOHZ: restart tick device from irq_enter()
      NOHZ: split tick_nohz_restart_sched_tick()
      NOHZ: unify the nohz function calls in irq_enter()
      timers: fix itimer/many thread hang, fix
      timers: fix itimer/many thread hang, v3
      ntp: improve adjtimex frequency rounding
      timekeeping: fix rounding problem during clock update
      ntp: let update_persistent_clock() sleep
      hrtimer: reorder struct hrtimer to save 8 bytes on 64bit builds
      posix-timers: lock_timer: make it readable
      posix-timers: lock_timer: kill the bogus ->it_id check
      posix-timers: kill ->it_sigev_signo and ->it_sigev_value
      posix-timers: sys_timer_create: cleanup the error handling
      posix-timers: move the initialization of timer->sigq from send to create path
      posix-timers: sys_timer_create: simplify and s/tasklist/rcu/
      ...
    
    Fix trivial conflicts due to sysrq-q description clahes in
    Documentation/sysrq.txt and drivers/char/sysrq.c

commit c5b77a3d3a716a5c61a1999d7f2a78e9c39fd1b0
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Sep 29 17:31:41 2008 +0200

    timer_list: print cpu number of clockevents device
    
    The per cpu clock events device output of timer_list lacks an
    association of the device to the cpu which is annoying when looking at
    the output of /proc/timer_list from a 128 way system.
    
    Add the CPU number info and mark the broadcast device in the device
    list printout.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit bc3ac469af00b0e5b7799c127d00b6650fab5587
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Sep 9 21:38:57 2008 +0200

    clockevents: remove WARN_ON which was used to gather information
    
    commit 61c22c34c6f80a8e89cff5ff717627c54cc14fd4 upstream
    
    The issue of the endless reprogramming loop due to a too small
    min_delta_ns was fixed with the previous updates of the clock events
    code, but we had no information about the spread of this problem. I
    added a WARN_ON to get automated information via kerneloops.org and to
    get some direct reports, which allowed me to analyse the affected
    machines.
    
    The WARN_ON has served its purpose and would be annoying for a release
    kernel. Remove it and just keep the information about the increase of
    the min_delta_ns value.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 45f9d5228563175bf2e340e1863f3c936a7d5888
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Sep 6 03:03:32 2008 +0200

    x86: HPET fix moronic 32/64bit thinko
    
    commit f7676254f179eac6b5244a80195ec8ae0e9d4606 upstream
    
    We use the HPET only in 32bit mode because:
    1) some HPETs are 32bit only
    2) on i386 there is no way to read/write the HPET atomic 64bit wide
    
    The HPET code unification done by the "moron of the year" did
    not take into account that unsigned long is different on 32 and
    64 bit.
    
    This thinko results in a possible endless loop in the clockevents
    code, when the return comparison fails due to the 64bit/332bit
    unawareness.
    
    unsigned long cnt = (u32) hpet_read() + delta can wrap over 32bit.
    but the final compare will fail and return -ETIME causing endless
    loops.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 92741d2d653769b582015c6a379e7b46e113435d
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Sep 6 03:01:45 2008 +0200

    clockevents: broadcast fixup possible waiters
    
    commit 7300711e8c6824fcfbd42a126980ff50439d8dd0 upstream
    
    Until the C1E patches arrived there where no users of periodic broadcast
    before switching to oneshot mode. Now we need to trigger a possible
    waiter for a periodic broadcast when switching to oneshot mode.
    Otherwise we can starve them for ever.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 9b4989324acb35a5ada4d52e13fd339e5da89762
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Sep 3 21:37:14 2008 +0000

    clockevents: prevent endless loop lockup
    
    commit 1fb9b7d29d8e85ba3196eaa7ab871bf76fc98d36 upstream
    
    The C1E/HPET bug reports on AMDX2/RS690 systems where tracked down to a
    too small value of the HPET minumum delta for programming an event.
    
    The clockevents code needs to enforce an interrupt event on the clock event
    device in some cases. The enforcement code was stupid and naive, as it just
    added the minimum delta to the current time and tried to reprogram the device.
    When the minimum delta is too small, then this loops forever.
    
    Add a sanity check. Allow reprogramming to fail 3 times, then print a warning
    and double the minimum delta value to make sure, that this does not happen again.
    Use the same function for both tick-oneshot and tick-broadcast code.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 7f0a673a75d3f9f50a64f83055b71be67526efd7
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Sep 3 21:37:08 2008 +0000

    clockevents: prevent multiple init/shutdown
    
    commit 9c17bcda991000351cb2373f78be7e4b1c44caa3 upstream
    
    While chasing the C1E/HPET bugreports I went through the clock events
    code inch by inch and found that the broadcast device can be initialized
    and shutdown multiple times. Multiple shutdowns are not critical, but
    useless waste of time. Multiple initializations are simply broken. Another
    CPU might have the device in use already after the first initialization and
    the second init could just render it unusable again.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit ea16e1b4b005e8a574efce13fb57d0fdbc543d67
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Sep 3 21:37:03 2008 +0000

    clockevents: enforce reprogram in oneshot setup
    
    commit 7205656ab48da29a95d7f55e43a81db755d3cb3a upstream
    
    In tick_oneshot_setup we program the device to the given next_event,
    but we do not check the return value. We need to make sure that the
    device is programmed enforced so the interrupt handler engine starts
    working. Split out the reprogramming function from tick_program_event()
    and call it with the device, which was handed in to tick_setup_oneshot().
    Set the force argument, so the devices is firing an interrupt.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit cf25095cf6e21b9abe299d709835db2d6338b2b5
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Sep 3 21:36:57 2008 +0000

    clockevents: prevent endless loop in periodic broadcast handler
    
    commit d4496b39559c6d43f83e4c08b899984f8b8089b5 upstream
    
    The reprogramming of the periodic broadcast handler was broken,
    when the first programming returned -ETIME. The clockevents code
    stores the new expiry value in the clock events device next_event field
    only when the programming time has not been elapsed yet. The loop in
    question calculates the new expiry value from the next_event value
    and therefor never increases.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 2a2bac600a84eedf9d9dd6766232640876593856
Author: Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>
Date:   Wed Sep 3 21:36:50 2008 +0000

    clockevents: prevent clockevent event_handler ending up handler_noop
    
    commit 7c1e76897492d92b6a1c2d6892494d39ded9680c upstream
    
    There is a ordering related problem with clockevents code, due to which
    clockevents_register_device() called after tickless/highres switch
    will not work. The new clockevent ends up with clockevents_handle_noop as
    event handler, resulting in no timer activity.
    
    The problematic path seems to be
    
    * old device already has hrtimer_interrupt as the event_handler
    * new clockevent device registers with a higher rating
    * tick_check_new_device() is called
      * clockevents_exchange_device() gets called
        * old->event_handler is set to clockevents_handle_noop
      * tick_setup_device() is called for the new device
        * which sets new->event_handler using the old->event_handler which is noop.
    
    Change the ordering so that new device inherits the proper handler.
    
    This does not have any issue in normal case as most likely all the clockevent
    devices are setup before the highres switch. But, can potentially be affecting
    some corner case where HPET force detect happens after the highres switch.
    This was a problem with HPET in MSI mode code that we have been experimenting
    with.
    
    Signed-off-by: Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>
    Signed-off-by: Shaohua Li <shaohua.li@intel.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 3aafff5cf6ddd4f8cb6df0f9cf268446bbca80ce
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Sep 9 21:38:57 2008 +0200

    clockevents: remove WARN_ON which was used to gather information
    
    commit 61c22c34c6f80a8e89cff5ff717627c54cc14fd4 upstream
    
    The issue of the endless reprogramming loop due to a too small
    min_delta_ns was fixed with the previous updates of the clock events
    code, but we had no information about the spread of this problem. I
    added a WARN_ON to get automated information via kerneloops.org and to
    get some direct reports, which allowed me to analyse the affected
    machines.
    
    The WARN_ON has served its purpose and would be annoying for a release
    kernel. Remove it and just keep the information about the increase of
    the min_delta_ns value.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 59ff733c6b6ef547bb09a9902020750dfbb2200f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Sep 6 03:03:32 2008 +0200

    x86: HPET fix moronic 32/64bit thinko
    
    commit f7676254f179eac6b5244a80195ec8ae0e9d4606 upstream
    
    We use the HPET only in 32bit mode because:
    1) some HPETs are 32bit only
    2) on i386 there is no way to read/write the HPET atomic 64bit wide
    
    The HPET code unification done by the "moron of the year" did
    not take into account that unsigned long is different on 32 and
    64 bit.
    
    This thinko results in a possible endless loop in the clockevents
    code, when the return comparison fails due to the 64bit/332bit
    unawareness.
    
    unsigned long cnt = (u32) hpet_read() + delta can wrap over 32bit.
    but the final compare will fail and return -ETIME causing endless
    loops.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 9d29a18def727d9e0d5c656cfc86a278988b7926
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Sep 6 03:01:45 2008 +0200

    clockevents: broadcast fixup possible waiters
    
    commit 7300711e8c6824fcfbd42a126980ff50439d8dd0 upstream
    
    Until the C1E patches arrived there where no users of periodic broadcast
    before switching to oneshot mode. Now we need to trigger a possible
    waiter for a periodic broadcast when switching to oneshot mode.
    Otherwise we can starve them for ever.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 19ab6cbbf02a7d4ca81ef44cc856ce11870e202b
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Sep 3 21:37:14 2008 +0000

    clockevents: prevent endless loop lockup
    
    commit 1fb9b7d29d8e85ba3196eaa7ab871bf76fc98d36 upstream
    
    The C1E/HPET bug reports on AMDX2/RS690 systems where tracked down to a
    too small value of the HPET minumum delta for programming an event.
    
    The clockevents code needs to enforce an interrupt event on the clock event
    device in some cases. The enforcement code was stupid and naive, as it just
    added the minimum delta to the current time and tried to reprogram the device.
    When the minimum delta is too small, then this loops forever.
    
    Add a sanity check. Allow reprogramming to fail 3 times, then print a warning
    and double the minimum delta value to make sure, that this does not happen again.
    Use the same function for both tick-oneshot and tick-broadcast code.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit ffa4da2a25bb4ac08f710ac99827baf48a8f8d57
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Sep 3 21:37:08 2008 +0000

    clockevents: prevent multiple init/shutdown
    
    commit 9c17bcda991000351cb2373f78be7e4b1c44caa3 upstream
    
    While chasing the C1E/HPET bugreports I went through the clock events
    code inch by inch and found that the broadcast device can be initialized
    and shutdown multiple times. Multiple shutdowns are not critical, but
    useless waste of time. Multiple initializations are simply broken. Another
    CPU might have the device in use already after the first initialization and
    the second init could just render it unusable again.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit e73068458bf253c2e738cd55080c3a54c61037ef
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Sep 3 21:37:03 2008 +0000

    clockevents: enforce reprogram in oneshot setup
    
    commit 7205656ab48da29a95d7f55e43a81db755d3cb3a upstream
    
    In tick_oneshot_setup we program the device to the given next_event,
    but we do not check the return value. We need to make sure that the
    device is programmed enforced so the interrupt handler engine starts
    working. Split out the reprogramming function from tick_program_event()
    and call it with the device, which was handed in to tick_setup_oneshot().
    Set the force argument, so the devices is firing an interrupt.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit fbbece349081a689d5687d9ebc769a847fdf423a
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Sep 3 21:36:57 2008 +0000

    clockevents: prevent endless loop in periodic broadcast handler
    
    commit d4496b39559c6d43f83e4c08b899984f8b8089b5 upstream
    
    The reprogramming of the periodic broadcast handler was broken,
    when the first programming returned -ETIME. The clockevents code
    stores the new expiry value in the clock events device next_event field
    only when the programming time has not been elapsed yet. The loop in
    question calculates the new expiry value from the next_event value
    and therefor never increases.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 6141266c43db890ada7df589358b8553de2e6322
Author: Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>
Date:   Wed Sep 3 21:36:50 2008 +0000

    clockevents: prevent clockevent event_handler ending up handler_noop
    
    commit 7c1e76897492d92b6a1c2d6892494d39ded9680c upstream
    
    There is a ordering related problem with clockevents code, due to which
    clockevents_register_device() called after tickless/highres switch
    will not work. The new clockevent ends up with clockevents_handle_noop as
    event handler, resulting in no timer activity.
    
    The problematic path seems to be
    
    * old device already has hrtimer_interrupt as the event_handler
    * new clockevent device registers with a higher rating
    * tick_check_new_device() is called
      * clockevents_exchange_device() gets called
        * old->event_handler is set to clockevents_handle_noop
      * tick_setup_device() is called for the new device
        * which sets new->event_handler using the old->event_handler which is noop.
    
    Change the ordering so that new device inherits the proper handler.
    
    This does not have any issue in normal case as most likely all the clockevent
    devices are setup before the highres switch. But, can potentially be affecting
    some corner case where HPET force detect happens after the highres switch.
    This was a problem with HPET in MSI mode code that we have been experimenting
    with.
    
    Signed-off-by: Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>
    Signed-off-by: Shaohua Li <shaohua.li@intel.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit fec6ed1d1f9b78a6acb4a3eb2c46c812ac2e96f0
Merge: b8ec322784f7 07454bfff151
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Oct 4 12:15:13 2008 -0700

    Merge branch 'timers-fixes-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'timers-fixes-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip:
      clockevents: check broadcast tick device not the clock events device

commit 07454bfff151d2465ada809bbaddf3548cc1097c
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Oct 4 10:51:07 2008 +0200

    clockevents: check broadcast tick device not the clock events device
    
    Impact: jiffies increment too fast.
    
    Hugh Dickins noted that with NOHZ=n and HIGHRES=n jiffies get
    incremented too fast. The reason is a wrong check in the broadcast
    enter/exit code, which keeps the local apic timer in periodic mode
    when the switch happens.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 8553f321e0fd29821135ac4797b5f37bf80ae2e9
Merge: be3be8905854 f8e256c687eb
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Sep 23 14:57:36 2008 -0700

    Merge branch 'timers-fixes-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'timers-fixes-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip:
      timers: fix build error in !oneshot case
      x86: c1e_idle: don't mark TSC unstable if CPU has invariant TSC
      x86: prevent C-states hang on AMD C1E enabled machines
      clockevents: prevent mode mismatch on cpu online
      clockevents: check broadcast device not tick device
      clockevents: prevent stale tick_next_period for onlining CPUs
      x86: prevent stale state of c1e_mask across CPU offline/online
      clockevents: prevent cpu online to interfere with nohz

commit 27ce4cb4a0c7cf59b9a9952266883862f2e4c99f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Sep 22 19:04:02 2008 +0200

    clockevents: prevent mode mismatch on cpu online
    
    Impact: timer hang on CPU online observed on AMD C1E systems
    
    When a CPU is brought online then the broadcast machinery can
    be in the one shot state already. Check this and setup the timer
    device of the new CPU in one shot mode so the broadcast code
    can pick up the next_event value correctly.
    
    Another AMD C1E oddity, as we switch to broadcast immediately and
    not after the full bring up via the ACPI cpu idle code.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 302745699c1b675b5d2a1af87271de10e4d96b6a
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Sep 22 19:02:25 2008 +0200

    clockevents: check broadcast device not tick device
    
    Impact: Possible hang on CPU online observed on AMD C1E machines.
    
    The broadcast setup code looks at the mode of the tick device to
    determine whether it needs to be shut down or setup. This is wrong
    when the broadcast mode is set to one shot already. This can happen
    when a CPU is brought online as it goes through the periodic setup
    first.
    
    The problem went unnoticed as sane systems do not call into that code
    before the switch to one shot for the clock event device happens.
    The AMD C1E idle routine switches over immediately and thereby shuts
    down the just setup device before the first interrupt happens.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 49d670fb8dd62d3ed4e3ed2513538ea65b051aed
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Sep 22 18:56:01 2008 +0200

    clockevents: prevent stale tick_next_period for onlining CPUs
    
    Impact: possible hang on CPU onlining in timer one shot mode.
    
    The tick_next_period variable is only used during boot on nohz/highres
    enabled systems, but for CPU onlining it needs to be maintained when
    the per cpu clock events device operates in one shot mode.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 6441402b1f173fa38e561d3cee7c01c32e5281ad
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Sep 22 18:46:37 2008 +0200

    clockevents: prevent cpu online to interfere with nohz
    
    Impact: rare hang which can be triggered on CPU online.
    
    tick_do_timer_cpu keeps track of the CPU which updates jiffies
    via do_timer. The value -1 is used to signal, that currently no
    CPU is doing this. There are two cases, where the variable can
    have this state:
    
     boot:
        necessary for systems where the boot cpu id can be != 0
    
     nohz long idle sleep:
        When the CPU which did the jiffies update last goes into
        a long idle sleep it drops the update jiffies duty so
        another CPU which is not idle can pick it up and keep
        jiffies going.
    
    Using the same value for both situations is wrong, as the CPU online
    code can see the -1 state when the timer of the newly onlined CPU is
    setup. The setup for a newly onlined CPU goes through periodic mode
    and can pick up the do_timer duty without being aware of the nohz /
    highres mode of the already running system.
    
    Use two separate states and make them constants to avoid magic
    numbers confusion.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 902f2ac9da7975a5a04fc835860f2a7096c481d3
Merge: 06d4a22be3af 2344abbcbdb8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Sep 19 16:16:50 2008 -0700

    Merge branch 'timers-fixes-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'timers-fixes-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip:
      clockevents: make device shutdown robust
      clocksource, acpi_pm.c: fix check for monotonicity
      clockevents: remove WARN_ON which was used to gather information

commit 2344abbcbdb82140050e8be29d3d55e4f6fe860b
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Sep 16 11:32:50 2008 -0700

    clockevents: make device shutdown robust
    
    The device shut down does not cleanup the next_event variable of the
    clock event device. So when the device is reactivated the possible
    stale next_event value can prevent the device to be reprogrammed as it
    claims to wait on a event already.
    
    This is the root cause of the resurfacing suspend/resume problem,
    where systems need key press to come back to life.
    
    Fix this by setting next_event to KTIME_MAX when the device is shut
    down. Use a separate function for shutdown which takes care of that
    and only keep the direct set mode call in the broadcast code, where we
    can not touch the next_event value.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit bdce291a69a4de340eb5a0f7b87dd0d49744d6b6
Merge: 93811d94f7e9 61c22c34c6f8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Sep 9 13:47:01 2008 -0700

    Merge branch 'timers-fixes-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'timers-fixes-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip:
      clockevents: remove WARN_ON which was used to gather information

commit e75b986af7881ed8d8ccb1ed154045ed17cfebd0
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Sep 9 21:38:57 2008 +0200

    clockevents: remove WARN_ON which was used to gather information
    
    The issue of the endless reprogramming loop due to a too small
    min_delta_ns was fixed with the previous updates of the clock events
    code, but we had no information about the spread of this problem. I
    added a WARN_ON to get automated information via kerneloops.org and to
    get some direct reports, which allowed me to analyse the affected
    machines.
    
    The WARN_ON has served its purpose and would be annoying for a release
    kernel. Remove it and just keep the information about the increase of
    the min_delta_ns value.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 61c22c34c6f80a8e89cff5ff717627c54cc14fd4
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Sep 9 21:38:57 2008 +0200

    clockevents: remove WARN_ON which was used to gather information
    
    The issue of the endless reprogramming loop due to a too small
    min_delta_ns was fixed with the previous updates of the clock events
    code, but we had no information about the spread of this problem. I
    added a WARN_ON to get automated information via kerneloops.org and to
    get some direct reports, which allowed me to analyse the affected
    machines.
    
    The WARN_ON has served its purpose and would be annoying for a release
    kernel. Remove it and just keep the information about the increase of
    the min_delta_ns value.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 5840263ecb95e55a2d248fc740644a2c9171a61c
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Fri Sep 5 15:36:39 2008 +0900

    sh: Don't enable clockevents broadcasting on UP SH-X3 builds.
    
    Fixes up compile errors with missing timer definitions. It's pointless to
    have this enabled anyways if CONFIG_SMP=n.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

commit f5325225658737e6c9cb8e24373e2c281a90be2a
Merge: 4747832b56a9 4ab6a2191131
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Sep 6 19:33:26 2008 -0700

    Merge branch 'timers-fixes-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'timers-fixes-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip:
      clocksource, acpi_pm.c: check for monotonicity
      clocksource, acpi_pm.c: use proper read function also in errata mode
      ntp: fix calculation of the next jiffie to trigger RTC sync
      x86: HPET: read back compare register before reading counter
      x86: HPET fix moronic 32/64bit thinko
      clockevents: broadcast fixup possible waiters
      HPET: make minimum reprogramming delta useful
      clockevents: prevent endless loop lockup
      clockevents: prevent multiple init/shutdown
      clockevents: enforce reprogram in oneshot setup
      clockevents: prevent endless loop in periodic broadcast handler
      clockevents: prevent clockevent event_handler ending up handler_noop

commit f7676254f179eac6b5244a80195ec8ae0e9d4606
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Sep 6 03:03:32 2008 +0200

    x86: HPET fix moronic 32/64bit thinko
    
    We use the HPET only in 32bit mode because:
    1) some HPETs are 32bit only
    2) on i386 there is no way to read/write the HPET atomic 64bit wide
    
    The HPET code unification done by the "moron of the year" did
    not take into account that unsigned long is different on 32 and
    64 bit.
    
    This thinko results in a possible endless loop in the clockevents
    code, when the return comparison fails due to the 64bit/332bit
    unawareness.
    
    unsigned long cnt = (u32) hpet_read() + delta can wrap over 32bit.
    but the final compare will fail and return -ETIME causing endless
    loops.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 7300711e8c6824fcfbd42a126980ff50439d8dd0
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Sep 6 03:01:45 2008 +0200

    clockevents: broadcast fixup possible waiters
    
    Until the C1E patches arrived there where no users of periodic broadcast
    before switching to oneshot mode. Now we need to trigger a possible
    waiter for a periodic broadcast when switching to oneshot mode.
    Otherwise we can starve them for ever.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 1fb9b7d29d8e85ba3196eaa7ab871bf76fc98d36
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Sep 3 21:37:14 2008 +0000

    clockevents: prevent endless loop lockup
    
    The C1E/HPET bug reports on AMDX2/RS690 systems where tracked down to a
    too small value of the HPET minumum delta for programming an event.
    
    The clockevents code needs to enforce an interrupt event on the clock event
    device in some cases. The enforcement code was stupid and naive, as it just
    added the minimum delta to the current time and tried to reprogram the device.
    When the minimum delta is too small, then this loops forever.
    
    Add a sanity check. Allow reprogramming to fail 3 times, then print a warning
    and double the minimum delta value to make sure, that this does not happen again.
    Use the same function for both tick-oneshot and tick-broadcast code.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

commit 9c17bcda991000351cb2373f78be7e4b1c44caa3
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Sep 3 21:37:08 2008 +0000

    clockevents: prevent multiple init/shutdown
    
    While chasing the C1E/HPET bugreports I went through the clock events
    code inch by inch and found that the broadcast device can be initialized
    and shutdown multiple times. Multiple shutdowns are not critical, but
    useless waste of time. Multiple initializations are simply broken. Another
    CPU might have the device in use already after the first initialization and
    the second init could just render it unusable again.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

commit 7205656ab48da29a95d7f55e43a81db755d3cb3a
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Sep 3 21:37:03 2008 +0000

    clockevents: enforce reprogram in oneshot setup
    
    In tick_oneshot_setup we program the device to the given next_event,
    but we do not check the return value. We need to make sure that the
    device is programmed enforced so the interrupt handler engine starts
    working. Split out the reprogramming function from tick_program_event()
    and call it with the device, which was handed in to tick_setup_oneshot().
    Set the force argument, so the devices is firing an interrupt.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

commit d4496b39559c6d43f83e4c08b899984f8b8089b5
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Sep 3 21:36:57 2008 +0000

    clockevents: prevent endless loop in periodic broadcast handler
    
    The reprogramming of the periodic broadcast handler was broken,
    when the first programming returned -ETIME. The clockevents code
    stores the new expiry value in the clock events device next_event field
    only when the programming time has not been elapsed yet. The loop in
    question calculates the new expiry value from the next_event value
    and therefor never increases.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

commit 7c1e76897492d92b6a1c2d6892494d39ded9680c
Author: Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>
Date:   Wed Sep 3 21:36:50 2008 +0000

    clockevents: prevent clockevent event_handler ending up handler_noop
    
    There is a ordering related problem with clockevents code, due to which
    clockevents_register_device() called after tickless/highres switch
    will not work. The new clockevent ends up with clockevents_handle_noop as
    event handler, resulting in no timer activity.
    
    The problematic path seems to be
    
    * old device already has hrtimer_interrupt as the event_handler
    * new clockevent device registers with a higher rating
    * tick_check_new_device() is called
      * clockevents_exchange_device() gets called
        * old->event_handler is set to clockevents_handle_noop
      * tick_setup_device() is called for the new device
        * which sets new->event_handler using the old->event_handler which is noop.
    
    Change the ordering so that new device inherits the proper handler.
    
    This does not have any issue in normal case as most likely all the clockevent
    devices are setup before the highres switch. But, can potentially be affecting
    some corner case where HPET force detect happens after the highres switch.
    This was a problem with HPET in MSI mode code that we have been experimenting
    with.
    
    Signed-off-by: Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>
    Signed-off-by: Shaohua Li <shaohua.li@intel.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

commit cc7a486cac78f6fc1a24e8cd63036bae8d2ab431
Author: Nick Piggin <nickpiggin@yahoo.com.au>
Date:   Mon Aug 11 13:49:30 2008 +1000

    generic-ipi: fix stack and rcu interaction bug in smp_call_function_mask()
    
    * Venki Pallipadi <venkatesh.pallipadi@intel.com> wrote:
    
    > Found a OOPS on a big SMP box during an overnight reboot test with
    > upstream git.
    >
    > Suresh and I looked at the oops and looks like the root cause is in
    > generic_smp_call_function_interrupt() and smp_call_function_mask() with
    > wait parameter.
    >
    > The actual oops looked like
    >
    > [   11.277260] BUG: unable to handle kernel paging request at ffff8802ffffffff
    > [   11.277815] IP: [<ffff8802ffffffff>] 0xffff8802ffffffff
    > [   11.278155] PGD 202063 PUD 0
    > [   11.278576] Oops: 0010 [1] SMP
    > [   11.279006] CPU 5
    > [   11.279336] Modules linked in:
    > [   11.279752] Pid: 0, comm: swapper Not tainted 2.6.27-rc2-00020-g685d87f #290
    > [   11.280039] RIP: 0010:[<ffff8802ffffffff>]  [<ffff8802ffffffff>] 0xffff8802ffffffff
    > [   11.280692] RSP: 0018:ffff88027f1f7f70  EFLAGS: 00010086
    > [   11.280976] RAX: 00000000ffffffff RBX: 0000000000000000 RCX: 0000000000000000
    > [   11.281264] RDX: 0000000000004f4e RSI: 0000000000000001 RDI: 0000000000000000
    > [   11.281624] RBP: ffff88027f1f7f98 R08: 0000000000000001 R09: ffffffff802509af
    > [   11.281925] R10: ffff8800280c2780 R11: 0000000000000000 R12: ffff88027f097d48
    > [   11.282214] R13: ffff88027f097d70 R14: 0000000000000005 R15: ffff88027e571000
    > [   11.282502] FS:  0000000000000000(0000) GS:ffff88027f1c3340(0000) knlGS:0000000000000000
    > [   11.283096] CS:  0010 DS: 0018 ES: 0018 CR0: 000000008005003b
    > [   11.283382] CR2: ffff8802ffffffff CR3: 0000000000201000 CR4: 00000000000006e0
    > [   11.283760] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
    > [   11.284048] DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400
    > [   11.284337] Process swapper (pid: 0, threadinfo ffff88027f1f2000, task ffff88027f1f0640)
    > [   11.284936] Stack:  ffffffff80250963 0000000000000212 0000000000ee8c78 0000000000ee8a66
    > [   11.285802]  ffff88027e571550 ffff88027f1f7fa8 ffffffff8021adb5 ffff88027f1f3e40
    > [   11.286599]  ffffffff8020bdd6 ffff88027f1f3e40 <EOI>  ffff88027f1f3ef8 0000000000000000
    > [   11.287120] Call Trace:
    > [   11.287768]  <IRQ>  [<ffffffff80250963>] ? generic_smp_call_function_interrupt+0x61/0x12c
    > [   11.288354]  [<ffffffff8021adb5>] smp_call_function_interrupt+0x17/0x27
    > [   11.288744]  [<ffffffff8020bdd6>] call_function_interrupt+0x66/0x70
    > [   11.289030]  <EOI>  [<ffffffff8024ab3b>] ? clockevents_notify+0x19/0x73
    > [   11.289380]  [<ffffffff803b9b75>] ? acpi_idle_enter_simple+0x18b/0x1fa
    > [   11.289760]  [<ffffffff803b9b6b>] ? acpi_idle_enter_simple+0x181/0x1fa
    > [   11.290051]  [<ffffffff8053aeca>] ? cpuidle_idle_call+0x70/0xa2
    > [   11.290338]  [<ffffffff80209f61>] ? cpu_idle+0x5f/0x7d
    > [   11.290723]  [<ffffffff8060224a>] ? start_secondary+0x14d/0x152
    > [   11.291010]
    > [   11.291287]
    > [   11.291654] Code:  Bad RIP value.
    > [   11.292041] RIP  [<ffff8802ffffffff>] 0xffff8802ffffffff
    > [   11.292380]  RSP <ffff88027f1f7f70>
    > [   11.292741] CR2: ffff8802ffffffff
    > [   11.310951] ---[ end trace 137c54d525305f1c ]---
    >
    > The problem is with the following sequence of events:
    >
    > - CPU A calls smp_call_function_mask() for CPU B with wait parameter
    > - CPU A sets up the call_function_data on the stack and does an rcu add to
    >   call_function_queue
    > - CPU A waits until the WAIT flag is cleared
    > - CPU B gets the call function interrupt and starts going through the
    >   call_function_queue
    > - CPU C also gets some other call function interrupt and starts going through
    >   the call_function_queue
    > - CPU C, which is also going through the call_function_queue, starts referencing
    >   CPU A's stack, as that element is still in call_function_queue
    > - CPU B finishes the function call that CPU A set up and as there are no other
    >   references to it, rcu deletes the call_function_data (which was from CPU A
    >   stack)
    > - CPU B sees the wait flag and just clears the flag (no call_rcu to free)
    > - CPU A which was waiting on the flag continues executing and the stack
    >   contents change
    >
    > - CPU C is still in rcu_read section accessing the CPU A's stack sees
    >   inconsistent call_funation_data and can try to execute
    >   function with some random pointer, causing stack corruption for A
    >   (by clearing the bits in mask field) and oops.
    
    Nice debugging work.
    
    I'd suggest something like the attached (boot tested) patch as the simple
    fix for now.
    
    I expect the benefits from the less synchronized, multiple-in-flight-data
    global queue will still outweigh the costs of dynamic allocations. But
    if worst comes to worst then we just go back to a globally synchronous
    one-at-a-time implementation, but that would be pretty sad!
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

commit 5deb0b2a25b7b568ab81f7c38052572ecf4ccc96
Author: Mike Travis <travis@sgi.com>
Date:   Mon May 12 21:21:13 2008 +0200

    x86: leave initial __cpu_pda array in place until cpus are booted
    
    Ingo Molnar wrote:
    ...
    > they crashed after about 3 randconfig iterations with:
    >
    >   early res: 4 [8000-afff] PGTABLE
    >   early res: 5 [b000-b87f] MEMNODEMAP
    > PANIC: early exception 0e rip 10:ffffffff8077a150 error 2 cr2 37
    > Pid: 0, comm: swapper Not tainted 2.6.25-sched-devel.git-x86-latest.git #14
    >
    > Call Trace:
    >  [<ffffffff81466196>] early_idt_handler+0x56/0x6a
    >  [<ffffffff8077a150>] ? numa_set_node+0x30/0x60
    >  [<ffffffff8077a129>] ? numa_set_node+0x9/0x60
    >  [<ffffffff8147a543>] numa_init_array+0x93/0xf0
    >  [<ffffffff8147b039>] acpi_scan_nodes+0x3b9/0x3f0
    >  [<ffffffff8147a496>] numa_initmem_init+0x136/0x150
    >  [<ffffffff8146da5f>] setup_arch+0x48f/0x700
    >  [<ffffffff802566ea>] ? clockevents_register_notifier+0x3a/0x50
    >  [<ffffffff81466a87>] start_kernel+0xd7/0x440
    >  [<ffffffff81466422>] x86_64_start_kernel+0x222/0x280
    ...
    Here's the fixup...  This one should follow the previous patches.
    
    Thanks,
    Mike
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit aa276e1cafb3ce9d01d1e837bcd67e92616013ac
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Jun 9 19:15:00 2008 +0200

    x86, clockevents: add C1E aware idle function
    
    C1E on AMD machines is like C3 but without control from the OS. Up to
    now we disabled the local apic timer for those machines as it stops
    when the CPU goes into C1E. This excludes those machines from high
    resolution timers / dynamic ticks, which hurts especially X2 based
    laptops.
    
    The current boot time C1E detection has another, more serious flaw
    as well: some BIOSes do not enable C1E until the ACPI processor module
    is loaded. This causes systems to stop working after that point.
    
    To work nicely with C1E enabled machines we use a separate idle
    function, which checks on idle entry whether C1E was enabled in the
    Interrupt Pending Message MSR. This allows us to do timer broadcasting
    for C1E and covers the late enablement of C1E as well.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

commit 18068523d3a0b41fcee5b53cdb437a0ab4d65e4b
Author: Glauber de Oliveira Costa <gcosta@redhat.com>
Date:   Fri Feb 15 17:52:47 2008 -0200

    KVM: paravirtualized clocksource: host part
    
    This is the host part of kvm clocksource implementation. As it does
    not include clockevents, it is a fairly simple implementation. We
    only have to register a per-vcpu area, and start writing to it periodically.
    
    The area is binary compatible with xen, as we use the same shadow_info
    structure.
    
    [marcelo: fix bad_page on MSR_KVM_SYSTEM_TIME]
    [avi: save full value of the msr, even if enable bit is clear]
    [avi: clear previous value of time_page]
    
    Signed-off-by: Glauber de Oliveira Costa <gcosta@redhat.com>
    Signed-off-by: Marcelo Tosatti <mtosatti@redhat.com>
    Signed-off-by: Avi Kivity <avi@qumranet.com>

commit c3823c479e1f86a0adc7bb76fcfded67b042afc3
Merge: 5dfeaef89559 ed3fa7c9510c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Apr 21 15:44:57 2008 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/hskinnemoen/avr32-2.6
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/hskinnemoen/avr32-2.6: (25 commits)
      avr32: Add hardware power-down function call
      avr32: add include/asm-avr32/serial.h
      avr32: don't offer PARPORT_PC
      avr32: don't offer CONFIG_GEN_RTC
      avr32: don't offer CONFIG_RTC
      add include/asm-avr32/xor.h
      avr32: Remove two unused #defines from mm/init.c
      avr32: Implement set_rate(), set_parent() and mode() for pll1
      avr32: Generic clockevents support
      avr32: Move sleep code into mach-at32ap
      avr32: Use constants from sysreg.h in asm.h
      avr32: Delete mostly unused header asm/intc.h
      avr32: start clocksource cleanup
      avr32: pass i2c board info through at32_add_device_twi
      avr32: cleanup - use _AC macro to define PAGE_SIZE
      Generate raw keyboard codes for AVR32 architecture
      atmel_usba_udc: Add support for AT91CAP9 UDPHS
      atmel_usba_udc: Add missing kfree() in usba_udc_remove()
      atmel_usba_udc: move endpoint declarations into platform data.
      atmel_usba_udc: Kill GPIO_PIN_NONE
      ...

commit 5dfeaef89559d4968b0470adf749659f10d722f6
Merge: 429f731dea57 259aae864cee
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Apr 21 15:43:43 2008 -0700

    Merge branch 'master' of git://git.kernel.org/pub/scm/linux/kernel/git/tglx/linux-2.6-hrt
    
    * 'master' of git://git.kernel.org/pub/scm/linux/kernel/git/tglx/linux-2.6-hrt:
      hrtimer: optimize the softirq time optimization
      hrtimer: reduce calls to hrtimer_get_softirq_time()
      clockevents: fix typo in tick-broadcast.c
      jiffies: add time_is_after_jiffies and others which compare with jiffies

commit 833df317f9ada91488898b005f4641bb674a3bae
Author: Glauber Costa <gcosta@redhat.com>
Date:   Fri Apr 18 13:38:58 2008 -0700

    clockevents: fix typo in tick-broadcast.c
    
    braodcast -> broadcast
    
    Signed-off-by: Glauber Costa <gcosta@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit e723ff666a5da8f7fda4e36ebfeafac2175a5c6e
Author: David Brownell <david-b@pacbell.net>
Date:   Thu Feb 14 11:24:02 2008 -0800

    avr32: Generic clockevents support
    
    This combines three patches from David Brownell:
      * avr32: tclib support
      * avr32: simplify clocksources
      * avr32: Turn count/compare into a oneshot clockevent device
    
    Register both TC blocks (instead of just the first one) so that
    the AT32/AT91 tclib code will pick them up (instead of just the
    avr32-only PIT-style clocksource).
    
    Rename the first one and its resources appropriately.
    
    More cleanups to the cycle counter clocksource code
    
     - Disable all the weak symbol magic; remove the AVR32-only TCB-based
       clocksource code (source and header).
    
     - Mark the __init code properly.
    
     - Don't forget to report IRQF_TIMER.
    
     - Make the system work properly with this clocksource, by preventing
       use of the CPU "idle" sleep state in the idle loop when it's used.
    
    Package the avr32 count/compare timekeeping support as a oneshot
    clockevent device, so it supports NO_HZ and high res timers.
    This means it also supports plugging in other clockevent devices
    and clocksources.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Haavard Skinnemoen <hskinnemoen@atmel.com>

commit 73e3e6481f56b3b5b618671a8d32b19a35f84316
Merge: 4adeaaf51ebc 6993fc5bbc5d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Apr 18 08:37:41 2008 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/tglx/linux-2.6-hrt
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/tglx/linux-2.6-hrt:
      clocksource: make clocksource watchdog cycle through online CPUs
      Documentation: move timer related documentation to a single place
      clockevents: optimise tick_nohz_stop_sched_tick() a bit
      locking: remove unused double_spin_lock()
      hrtimers: simplify lockdep handling
      timers: simplify lockdep handling
      posix-timers: fix shadowed variables
      timer_list: add annotations to workqueue.c
      hrtimer: use nanosleep specific restart_block fields
      hrtimer: add nanosleep specific restart_block member

commit 4cba84b5d61af81f1f329f4d05170427a9819c39
Merge: 7d939fbdfee4 ca68305bf3c7
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Apr 18 08:19:15 2008 -0700

    Merge branch 'for-linus' of git://git390.osdl.marist.edu/pub/scm/linux-2.6
    
    * 'for-linus' of git://git390.osdl.marist.edu/pub/scm/linux-2.6: (36 commits)
      [S390] Remove code duplication from monreader / dcssblk.
      [S390] kernel: show last breaking-event-address on oops
      [S390] lowcore: Change type of lowcores softirq_pending to __u32.
      [S390] zcrypt: Comments and kernel-doc cleanup
      [S390] uaccess: Always access the correct address space.
      [S390] Fix a lot of sparse warnings.
      [S390] Convert s390 to GENERIC_CLOCKEVENTS.
      [S390] genirq/clockevents: move irq affinity prototypes/inlines to interrupt.h
      [S390] Convert monitor calls to function calls.
      [S390] qdio (new feature): enhancing info-retrieval from QDIO-adapters
      [S390] replace remaining __FUNCTION__ occurrences
      [S390] remove redundant display of free swap space in show_mem()
      [S390] qdio: remove outdated developerworks link.
      [S390] Add debug_register_mode() function to debug feature API
      [S390] crypto: use more descriptive function names for init/exit routines.
      [S390] switch sched_clock to store-clock-extended.
      [S390] zcrypt: add support for large random numbers
      [S390] hw_random: allow rng_dev_read() to return hardware errors.
      [S390] Vertical cpu management.
      [S390] cpu topology support for s390.
      ...

commit 903b8a8d4835a796f582033802c83283886f4a3d
Author: Karsten Wiese <fzu@wemgehoertderstaat.de>
Date:   Thu Feb 28 15:10:50 2008 +0100

    clockevents: optimise tick_nohz_stop_sched_tick() a bit
    
    Call
            ts = &per_cpu(tick_cpu_sched, cpu);
    and
            cpu = smp_processor_id();
    once instead of twice.
    
    No functional change done, as changed code runs with local irq off.
    Reduces source lines and text size (20bytes on x86_64).
    
    [ akpm@linux-foundation.org: Build fix ]
    
    Signed-off-by: Karsten Wiese <fzu@wemgehoertderstaat.de>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit d7b906897e9caae452947e33674df0a2d6f7e10f
Author: Russell King <rmk+lkml@arm.linux.org.uk>
Date:   Thu Apr 17 07:46:24 2008 +0200

    [S390] genirq/clockevents: move irq affinity prototypes/inlines to interrupt.h
    
    > Generic code is not supposed to include irq.h. Replace this include
    > by linux/hardirq.h instead and add/replace an include of linux/irq.h
    > in asm header files where necessary.
    > This change should only matter for architectures that make use of
    > GENERIC_CLOCKEVENTS.
    > Architectures in question are mips, x86, arm, sh, powerpc, uml and sparc64.
    >
    > I did some cross compile tests for mips, x86_64, arm, powerpc and sparc64.
    > This patch fixes also build breakages caused by the include replacement in
    > tick-common.h.
    
    I generally dislike adding optional linux/* includes in asm/* includes -
    I'm nervous about this causing include loops.
    
    However, there's a separate point to be discussed here.
    
    That is, what interfaces are expected of every architecture in the kernel.
    If generic code wants to be able to set the affinity of interrupts, then
    that needs to become part of the interfaces listed in linux/interrupt.h
    rather than linux/irq.h.
    
    So what I suggest is this approach instead (against Linus' tree of a
    couple of days ago) - we move irq_set_affinity() and irq_can_set_affinity()
    to linux/interrupt.h, change the linux/irq.h includes to linux/interrupt.h
    and include asm/irq_regs.h where needed (asm/irq_regs.h is supposed to be
    rarely used include since not much touches the stacked parent context
    registers.)
    
    Build tested on ARM PXA family kernels and ARM's Realview platform
    kernels which both use genirq.
    
    [ tglx@linutronix.de: add GENERIC_HARDIRQ dependencies ]
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Signed-off-by: Heiko Carstens <heiko.carstens@de.ibm.com>

commit 5c8388e5dfa7bddfca68f16b0ef61933508b716b
Author: Tony Lindgren <tony@atomide.com>
Date:   Thu Mar 13 08:47:21 2008 +0200

    ARM: OMAP1: Timer32K: Fix timer32K for clockevents and clean it up
    
    This patch fixes timer32k for clockevents and syncs it with
    linux-omap tree.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>

commit 4d243f92e48a7913938f48fa9ebea5239168bb11
Author: David Brownell <david-b@pacbell.net>
Date:   Fri Feb 22 17:28:37 2008 -0800

    atmel_tc clocksource/clockevent code
    
    Clocksource and clockevent device based on the Atmel TC blocks.
    
    The clockevent device handles both periodic and oneshot modes, so this
    enables NO_HZ and high res timers on some platforms that previously
    couldn't use those mechanisms.
    
    This works on both AVR32 and AT91 chips, given relevant patches for
    tclib support (always) and clockevents (or else this will only look
    like a higher precision clocksource).  It's an updated and modularized
    version of an AT91-only patch that has circulated for some time now.
    
    Changes relative to the original patch:
      * Update to use new tclib API
      * Replace open-coded do-while loop using goto with a real do-while loop
      * Minor irq handler optimization: Load register base address from
        dev_id instead of a global variable.
      * Aggressively turn off clocks when the clockevent isn't being used
      * Include the clockevent code on AT91RM9200 as well. The rating is
        lower than the System Timer, so the clock will usually stay off.
      * Don't assume that the number of clocks is always equal to the
        number of irqs.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Haavard Skinnemoen <hskinnemoen@atmel.com>

commit 78489300c39e88c1f75dbc4a360176cb0778361c
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Dec 13 09:57:17 2007 +0100

    clockevents: fix reprogramming decision in oneshot broadcast
    
    patch cdc6f27d9e3c2f7ca1a3e19c6eabb1ad6a2add5d in mainline.
    
    A previous version of the code did the reprogramming of the broadcast
    device in the return from idle code. This was removed, but the logic in
    tick_handle_oneshot_broadcast() was kept the same.
    
    When a broadcast interrupt happens we signal the expiry to all CPUs
    which have an expired event. If none of the CPUs has an expired event,
    which can happen in dyntick mode, then we reprogram the broadcast
    device. We do not reprogram otherwise, but this is only correct if all
    CPUs, which are in the idle broadcast state have been woken up.
    
    The code ignores, that there might be pending not yet expired events on
    other CPUs, which are in the idle broadcast state. So the delivery of
    those events can be delayed for quite a time.
    
    Change the tick_handle_oneshot_broadcast() function to check for CPUs,
    which are in broadcast state and are not woken up by the current event,
    and enforce the rearming of the broadcast device for those CPUs.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

commit 9ef9dc69d4167276c04590d67ee55de8380bc1ad
Merge: 2c8296f8cf0e 0d899e1b0000
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Feb 4 15:29:53 2008 -0800

    Merge branch 'for-linus' of master.kernel.org:/home/rmk/linux-2.6-arm
    
    * 'for-linus' of master.kernel.org:/home/rmk/linux-2.6-arm: (44 commits)
      [ARM] 4822/1: RealView: Change the REALVIEW_MPCORE configuration option
      [ARM] 4821/1: RealView: Remove the platform dependencies from localtimer.c
      [ARM] 4820/1: RealView: Select the timer IRQ at run-time
      [ARM] 4819/1: RealView: Fix entry-macro.S to work with multiple platforms
      [ARM] 4818/1: RealView: Add core-tile detection
      [ARM] 4817/1: RealView: Move the AMBA resource definitions to realview_eb.c
      [ARM] 4816/1: RealView: Move the platform-specific definitions into board-eb.h
      [ARM] 4815/1: RealView: Add clockevents suport for the local timers
      [ARM] 4814/1: RealView: Add broadcasting clockevents support for ARM11MPCore
      [ARM] 4813/1: Add SMP helper functions for clockevents support
      [ARM] 4812/1: RealView: clockevents support for the RealView platforms
      [ARM] 4811/1: RealView: clocksource support for the RealView platforms
      [ARM] 4736/1: Export atags to userspace and allow kexec to use customised atags
      [ARM] 4798/1: pcm027: fix missing header file
      [ARM] 4803/1: pxa: fix building issue of poodle.c caused by patch 4737/1
      [ARM] 4801/1: pxa: fix building issues of missing pxa2xx-regs.h
      [ARM] pxa: introduce sysdev for pxa3xx static memory controller
      [ARM] pxa: add preliminary suspend/resume code for pxa3xx
      [ARM] pxa: introduce sysdev for GPIO register saving/restoring
      [ARM] pxa: introduce sysdev for IRQ register saving/restoring
      ...

commit 0d899e1b0000ddf78a75d7dcf9a9029d6f7f8091
Merge: a78de2f704a0 43816bcb7262 85e6c7a7dbdb 4cd9d6f774c7 c9a28fa7b9ac 41579f49da23
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Mon Feb 4 17:54:39 2008 +0000

    Merge branches 'at91', 'ixp', 'master', 'misc', 'pxa' and 'realview' into devel
    
    * at91:
      [ARM] 4802/1: Fix typo and remove vague comment
      [ARM] 4660/3: at91: allow selecting UART for early kernel messages
      [ARM] 4739/1: at91sam9263: make gpio bank C and D irqs work
    
    * ixp:
      [ARM] 4809/2: ixp4xx: Merge dsmg600-power.c into dsmg600-setup.c
      [ARM] 4808/2: ixp4xx: Merge nas100d-power.c into nas100d-setup.c
      [ARM] 4807/2: ixp4xx: Merge nslu2-power.c into nslu2-setup.c
      [ARM] 4806/1: ixp4xx: Ethernet support for the nslu2 and nas100d boards
      [ARM] 4805/1: ixp4xx: Use leds-gpio driver instead of IXP4XX-GPIO-LED driver
      [ARM] 4715/2: Ethernet support for IXDP425 boards
      [ARM] 4714/2: Headers for IXP4xx built-in Ethernet and WAN drivers
      [ARM] 4713/3: Adds drivers for IXP4xx QMgr and NPE features
      [ARM] 4712/2: Adds functions to read and write IXP4xx "feature" bits
      [ARM] 4774/2: ixp4xx: Register dsmg600 rtc i2c_board_info
      [ARM] 4773/2: ixp4xx: Register nas100d rtc i2c_board_info
      [ARM] 4772/2: ixp4xx: Register nslu2 rtc i2c_board_info
      [ARM] 4769/2: ixp4xx: Button updates for the dsmg600 board
      [ARM] 4768/2: ixp4xx: Button and LED updates for the nas100d board
      [ARM] 4767/2: ixp4xx: Add bitops.h include to io.h
      [ARM] 4766/2: ixp4xx: Update ixp4xx_defconfig, enabling all supported boards
    
    * master:
      [ARM] 4810/1: - Fix 'section mismatch' building warnings
      [ARM] xtime_seqlock: fix more ARM machines for xtime deadlocking
      [ARM] 21285 serial: fix build error
    
    * misc:
      [ARM] 4736/1: Export atags to userspace and allow kexec to use customised atags
    
    * pxa:
      [ARM] 4798/1: pcm027: fix missing header file
      [ARM] 4803/1: pxa: fix building issue of poodle.c caused by patch 4737/1
      [ARM] 4801/1: pxa: fix building issues of missing pxa2xx-regs.h
      [ARM] pxa: introduce sysdev for pxa3xx static memory controller
      [ARM] pxa: add preliminary suspend/resume code for pxa3xx
      [ARM] pxa: introduce sysdev for GPIO register saving/restoring
      [ARM] pxa: introduce sysdev for IRQ register saving/restoring
      [ARM] pxa: fix the warning of undeclared "struct pxaohci_platform_data"
      [ARM] pxa: change set_kset_name() to direct name assignment for MFP sysclass
    
    * realview:
      [ARM] 4822/1: RealView: Change the REALVIEW_MPCORE configuration option
      [ARM] 4821/1: RealView: Remove the platform dependencies from localtimer.c
      [ARM] 4820/1: RealView: Select the timer IRQ at run-time
      [ARM] 4819/1: RealView: Fix entry-macro.S to work with multiple platforms
      [ARM] 4818/1: RealView: Add core-tile detection
      [ARM] 4817/1: RealView: Move the AMBA resource definitions to realview_eb.c
      [ARM] 4816/1: RealView: Move the platform-specific definitions into board-eb.h
      [ARM] 4815/1: RealView: Add clockevents suport for the local timers
      [ARM] 4814/1: RealView: Add broadcasting clockevents support for ARM11MPCore
      [ARM] 4813/1: Add SMP helper functions for clockevents support
      [ARM] 4812/1: RealView: clockevents support for the RealView platforms
      [ARM] 4811/1: RealView: clocksource support for the RealView platforms

commit 93c2904d5081468128e66792a85439df314de773
Author: Catalin Marinas <catalin.marinas@arm.com>
Date:   Mon Feb 4 17:32:57 2008 +0100

    [ARM] 4815/1: RealView: Add clockevents suport for the local timers
    
    This patch registers the local timers on ARM11MPCore as clock event
    devices. The clock device can be set up as periodic or oneshot.
    
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

commit a8655e83fc44ec2b92cbea9f3ff3cc0da05a991c
Author: Catalin Marinas <catalin.marinas@arm.com>
Date:   Mon Feb 4 17:30:57 2008 +0100

    [ARM] 4814/1: RealView: Add broadcasting clockevents support for ARM11MPCore
    
    This patch adds dummy local timers for each CPU so that the board clock
    device is used to broadcast events to the other CPUs. The patch also
    adds the declaration for the dummy_timer_setup function (the equivalent
    of local_timer_setup when CONFIG_LOCAL_TIMERS is not set).
    
    Due to the way clockevents work, the dummy timer on the first CPU has to
    be registered before the board timer.
    
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

commit 3e459990961db7f3f2dcf21e2b38a7216dfd10dd
Author: Catalin Marinas <catalin.marinas@arm.com>
Date:   Mon Feb 4 17:28:56 2008 +0100

    [ARM] 4813/1: Add SMP helper functions for clockevents support
    
    This patch adds the smp_call_function_single and smp_timer_broadcast
    functions and modifies ipi_timer to call the platform-specific function
    local_timer_interrupt.
    
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

commit ae30ceac3c6bbacdb227816abe6f0c7ea867ac7c
Author: Catalin Marinas <catalin.marinas@arm.com>
Date:   Mon Feb 4 17:26:55 2008 +0100

    [ARM] 4812/1: RealView: clockevents support for the RealView platforms
    
    The patch updates the RealView code to the clockevents infrastructure.
    The SMP support is implemented in subsequent patches. Based on the
    Versatile implementation by Kevin Hilman.
    
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

commit 9d09951da948c0ca30944df2a9b78e68d6e0744c
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Jan 30 13:33:04 2008 +0100

    x86: preset apic clockevents multiplicator
    
    The check for an unitialized clock event device triggers, when the local
    apic timer is registered as a dummy clock event device for broadcasting.
    Preset the multiplicator to avoid a false positive.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

commit 45fe4fe19120a22f7339f5bb110447170c25fca9
Author: Ingo Molnar <mingo@elte.hu>
Date:   Wed Jan 30 13:30:03 2008 +0100

    x86: make clockevents more robust
    
    detect zero event-device multiplicators - they then cause
    division-by-zero crashes if a clockevent has been initialized
    incorrectly.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 3e3b3916a9c5c28a16528585478de19fea59816b
Merge: 51dad801e271 4aae07025265
Author: Linus Torvalds <torvalds@woody.linux-foundation.org>
Date:   Tue Dec 18 09:42:44 2007 -0800

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/x86/linux-2.6-x86
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/x86/linux-2.6-x86:
      x86: fix "Kernel panic - not syncing: IO-APIC + timer doesn't work!"
      genirq: revert lazy irq disable for simple irqs
      x86: also define AT_VECTOR_SIZE_ARCH
      x86: kprobes bugfix
      x86: jprobe bugfix
      timer: kernel/timer.c section fixes
      genirq: add unlocked version of set_irq_handler()
      clockevents: fix reprogramming decision in oneshot broadcast
      oprofile: op_model_athlon.c support for AMD family 10h barcelona performance counters

commit cdc6f27d9e3c2f7ca1a3e19c6eabb1ad6a2add5d
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Dec 18 18:05:58 2007 +0100

    clockevents: fix reprogramming decision in oneshot broadcast
    
    Resolve the following regression of a choppy, almost unusable laptop:
    
     http://lkml.org/lkml/2007/12/7/299
     http://bugzilla.kernel.org/show_bug.cgi?id=9525
    
    A previous version of the code did the reprogramming of the broadcast
    device in the return from idle code. This was removed, but the logic in
    tick_handle_oneshot_broadcast() was kept the same.
    
    When a broadcast interrupt happens we signal the expiry to all CPUs
    which have an expired event. If none of the CPUs has an expired event,
    which can happen in dyntick mode, then we reprogram the broadcast
    device. We do not reprogram otherwise, but this is only correct if all
    CPUs, which are in the idle broadcast state have been woken up.
    
    The code ignores, that there might be pending not yet expired events on
    other CPUs, which are in the idle broadcast state. So the delivery of
    those events can be delayed for quite a time.
    
    Change the tick_handle_oneshot_broadcast() function to check for CPUs,
    which are in broadcast state and are not woken up by the current event,
    and enforce the rearming of the broadcast device for those CPUs.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

commit 3e96745119d46a80b044b72634169621fc814dde
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Dec 7 19:16:17 2007 +0100

    hrtimers: avoid overflow for large relative timeouts (CVE-2007-5966)
    
    patch 62f0f61e6673e67151a7c8c0f9a09c7ea43fe2b5 in mainline
    
    Relative hrtimers with a large timeout value might end up as negative
    timer values, when the current time is added in hrtimer_start().
    
    This in turn is causing the clockevents_set_next() function to set an
    huge timeout and sleep for quite a long time when we have a clock
    source which is capable of long sleeps like HPET. With PIT this almost
    goes unnoticed as the maximum delta is ~27ms. The non-hrt/nohz code
    sorts this out in the next timer interrupt, so we never noticed that
    problem which has been there since the first day of hrtimers.
    
    This bug became more apparent in 2.6.24 which activates HPET on more
    hardware.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit ee6abc255172063680e6663d308810cef0fc7ff3
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Dec 7 19:16:17 2007 +0100

    hrtimers: avoid overflow for large relative timeouts (CVE-2007-5966)
    
    patch 62f0f61e6673e67151a7c8c0f9a09c7ea43fe2b5 in mainline
    
    Relative hrtimers with a large timeout value might end up as negative
    timer values, when the current time is added in hrtimer_start().
    
    This in turn is causing the clockevents_set_next() function to set an
    huge timeout and sleep for quite a long time when we have a clock
    source which is capable of long sleeps like HPET. With PIT this almost
    goes unnoticed as the maximum delta is ~27ms. The non-hrt/nohz code
    sorts this out in the next timer interrupt, so we never noticed that
    problem which has been there since the first day of hrtimers.
    
    This bug became more apparent in 2.6.24 which activates HPET on more
    hardware.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 2c5ea0f2d8c7d4883dd0d8ec3c7e3f3640b4f814
Merge: fa2dd441df28 e17bcb43a26a
Author: Linus Torvalds <torvalds@woody.linux-foundation.org>
Date:   Fri Dec 7 11:01:26 2007 -0800

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/x86/linux-2.6-x86
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/x86/linux-2.6-x86:
      ACPI: move timer broadcast before busmaster disable
      clockevents: warn once when program_event() is called with negative expiry
      hrtimers: avoid overflow for large relative timeouts

commit 167b1de3ee4e50d65a2bd0a2667c9cd48faf54f3
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Dec 7 19:16:17 2007 +0100

    clockevents: warn once when program_event() is called with negative expiry
    
    The hrtimer problem with large relative timeouts resulting in a
    negative expiry time went unnoticed as there is no check in the
    clockevents_program_event() code. Put a check there with a WARN_ONCE
    to avoid such problems in the future.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

commit 62f0f61e6673e67151a7c8c0f9a09c7ea43fe2b5
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Dec 7 19:16:17 2007 +0100

    hrtimers: avoid overflow for large relative timeouts
    
    Relative hrtimers with a large timeout value might end up as negative
    timer values, when the current time is added in hrtimer_start().
    
    This in turn is causing the clockevents_set_next() function to set an
    huge timeout and sleep for quite a long time when we have a clock
    source which is capable of long sleeps like HPET. With PIT this almost
    goes unnoticed as the maximum delta is ~27ms. The non-hrt/nohz code
    sorts this out in the next timer interrupt, so we never noticed that
    problem which has been there since the first day of hrtimers.
    
    This bug became more apparent in 2.6.24 which activates HPET on more
    hardware.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

commit f310d0f08fdf2c9ed846ddcb958c50507c7833b9
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Sep 22 22:29:05 2007 +0000

    ACPI: disable lower idle C-states across suspend/resume
    
    changeset b04e7bdb984e3b7f62fb7f44146a529f88cc7639 from mainline.
    
    device_suspend() calls ACPI suspend functions, which seems to have undesired
    side effects on lower idle C-states. It took me some time to realize that
    especially the VAIO BIOSes (both Andrews jinxed UP and my elfstruck SMP one)
    show this effect. I'm quite sure that other bug reports against suspend/resume
    about turning the system into a brick have the same root cause.
    
    After fishing in the dark for quite some time, I realized that removing the ACPI
    processor module before suspend (this removes the lower C-state functionality)
    made the problem disappear. Interestingly enough the propability of having a
    bricked box is influenced by various factors (interrupts, size of the ram image,
    ...). Even adding a bunch of printks in the wrong places made the problem go
    away. The previous periodic tick implementation simply pampered over the
    problem, which explains why the dyntick / clockevents changes made this more
    prominent.
    
    We avoid complex functionality during the boot process and we have to do the
    same during suspend/resume. It is a similar scenario and equaly fragile.
    
    Add suspend / resume functions to the ACPI processor code and disable the lower
    idle C-states across suspend/resume. Fall back to the default idle
    implementation (halt) instead.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Andrew Morton <akpm@linux-foundation.org>
    Cc: Len Brown <lenb@kernel.org>
    Cc: Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 93400708dba888d45b4da01e1753a3a743f44496
Merge: db3a91fe2b42 edfed66e1785
Author: Linus Torvalds <torvalds@woody.linux-foundation.org>
Date:   Mon Oct 29 07:47:05 2007 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/tglx/linux-2.6-hrt
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/tglx/linux-2.6-hrt:
      Quieten hrtimer printk: "Switched to high resolution mode .."
      timer_list: Fix printk format strings
      clockevents: unexport tick_nohz_get_sleep_length

commit 64e38eb082bd845d6758079f65b191203986336d
Author: Adrian Bunk <bunk@kernel.org>
Date:   Wed Oct 24 18:24:22 2007 +0200

    clockevents: unexport tick_nohz_get_sleep_length
    
    This patch removes the unused
    EXPORT_SYMBOL_GPL(tick_nohz_get_sleep_length).
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 65a6ec0d72a07f16719e9b7a96e1c4bae044b591
Merge: 541010e4b892 0181b61a9884
Author: Linus Torvalds <torvalds@woody.linux-foundation.org>
Date:   Mon Oct 15 16:08:50 2007 -0700

    Merge branch 'devel' of master.kernel.org:/home/rmk/linux-2.6-arm
    
    * 'devel' of master.kernel.org:/home/rmk/linux-2.6-arm: (95 commits)
      [ARM] 4578/1: CM-x270: PCMCIA support
      [ARM] 4577/1: ITE 8152 PCI bridge support
      [ARM] 4576/1: CM-X270 machine support
      [ARM] pxa: Avoid pxa_gpio_mode() in gpio_direction_{in,out}put()
      [ARM] pxa: move pxa_set_mode() from pxa2xx_mainstone.c to mainstone.c
      [ARM] pxa: move pxa_set_mode() from pxa2xx_lubbock.c to lubbock.c
      [ARM] pxa: Make cpu_is_pxaXXX dependent on configuration symbols
      [ARM] pxa: PXA3xx base support
      [NET] smc91x: fix PXA DMA support code
      [SERIAL] Fix console initialisation ordering
      [ARM] pxa: tidy up arch/arm/mach-pxa/Makefile
      [ARM] Update arch/arm/Kconfig for drivers/Kconfig changes
      [ARM] 4600/1: fix kernel build failure with build-id-supporting binutils
      [ARM] 4599/1: Preserve ATAG list for use with kexec (2.6.23)
      [ARM] Rename consistent_sync() as dma_cache_maint()
      [ARM] 4572/1: ep93xx: add cirrus logic edb9307 support
      [ARM] 4596/1: S3C2412: Correct IRQs for SDI+CF and add decoding support
      [ARM] 4595/1: ns9xxx: define registers as void __iomem * instead of volatile u32
      [ARM] 4594/1: ns9xxx: use the new gpio functions
      [ARM] 4593/1: ns9xxx: implement generic clockevents
      ...

commit 59d66ce238e573fe3369427e91a8291f2cf67891
Merge: 5c0d6b34d6ee 89039b37be7c
Author: Linus Torvalds <torvalds@woody.linux-foundation.org>
Date:   Sun Oct 14 16:47:05 2007 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/tglx/linux-2.6-x86
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/tglx/linux-2.6-x86:
      x86: force timer broadcast on late AMD C1E detection
      x86: move local APIC timer init to the end of start_secondary()
      clockevents: introduce force broadcast notifier
      x86: fix missing include for vsyscall

commit 1595f452f3d8daa066bfd3ba4120754bed3329e1
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun Oct 14 22:57:45 2007 +0200

    clockevents: introduce force broadcast notifier
    
    The 64bit SMP bootup is slightly different to the 32bit one. It enables
    the boot CPU local APIC timer before all CPUs are brought up. Some AMD C1E
    systems have the C1E feature flag only set in the secondary CPU. Due to
    the early enable of the boot CPU local APIC timer the APIC timer is
    registered as a fully functional device. When we detect the wreckage during
    the bringup of the secondary CPU, we need to force the boot CPU into
    broadcast mode.
    
    Add a new notifier reason and implement the force broadcast in the clock
    events layer.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit c0bb87f7b8a145b56d45484713e1b1f37ce7e626
Author: Uwe Kleine-Knig <ukleinek@informatik.uni-freiburg.de>
Date:   Sun Sep 30 20:36:00 2007 +0100

    [ARM] 4593/1: ns9xxx: implement generic clockevents
    
    Signed-off-by: Uwe Kleine-Knig <ukleinek@informatik.uni-freiburg.de>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

commit 5e802dfab7bbbee1e63607a3e6d1ceb78ec4ceeb
Author: David Brownell <david-b@pacbell.net>
Date:   Tue Jul 31 01:41:26 2007 +0100

    [ARM] 4539/1: clocksource and clockevents for at91rm9200
    
    GENERIC_TIME and GENERIC_CLOCKEVENTS support for the at91rm9200.
    
     - Oneshot mode (used for NO_HZ and high res timers) uses the
       alarm to emulate a real oneshot timer; the trickiest bit is
       how to avoid some lowlevel races.  Thanks to Remy Bohmer for
       various fixes to this code.
    
     - Tighten up periodic mode support using the PIT.
    
     - Streamline reads of the 32KHz counter.  Thanks to Marc Pignat
       for some testing results: the CRTR register has *very* odd
       behavior.  The reread appears to work around stranger glitches
       than just getting an old clock value (which would quickly
       self-correct).
    
     - Remove the rounding-up of tick_usec to 10.009 msec (32KiHz/100),
       since that no longer acts correct (time increases too fast).
    
    Note that the at91sam9 and at91x40 chips need other solutions,
    since they don't have the same system timer module.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Acked-by: Bill Gatliff <bgat@billgatliff.com>
    Acked-by:Remy Bohmer <linux@bohmer.net>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

commit b8ce33590687888ebb900d09557b8807c4539022
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Oct 12 23:04:07 2007 +0200

    x86_64: convert to clock events
    
    Finally switch to the clockevents code. Share code with i386 for
    hpet and PIT.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Chris Wright <chrisw@sous-sol.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>

commit c8a1d398de70a7774359b4720c392891cdd485f9
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Oct 12 23:04:06 2007 +0200

    clockevents: fix periodic broadcast for oneshot devices
    
    The next_event member of the clock event device is used to keep track
    of the next periodic event. For one shot only devices it is wrong to
    clear the variable, as the next event will be based on it.
    
    Pointed out by Ralf Baechle
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>

commit de68d9b173ee657115dd0e584c2365b7954253a5
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Oct 12 23:04:05 2007 +0200

    clockevents: Allow build w/o run-tine usage for migration purposes
    
    Migration aid to allow preparatory patches which introduce not yet
    used parts of clock events code.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>

commit 7f8033b76c8eea89dec9f658f4a31bcd4fe84bbb
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Oct 12 23:04:05 2007 +0200

    clockevents: Remove unused inline function
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>

commit e86908614f2c7fec401827e5cefd7a6ea9407f85
Merge: 547307420931 9b4b8feb962f
Author: Linus Torvalds <torvalds@woody.linux-foundation.org>
Date:   Thu Oct 11 21:55:47 2007 -0700

    Merge branch 'master' of git://git.kernel.org/pub/scm/linux/kernel/git/paulus/powerpc
    
    * 'master' of git://git.kernel.org/pub/scm/linux/kernel/git/paulus/powerpc: (408 commits)
      [POWERPC] Add memchr() to the bootwrapper
      [POWERPC] Implement logging of unhandled signals
      [POWERPC] Add legacy serial support for OPB with flattened device tree
      [POWERPC] Use 1TB segments
      [POWERPC] XilinxFB: Allow fixed framebuffer base address
      [POWERPC] XilinxFB: Add support for custom screen resolution
      [POWERPC] XilinxFB: Use pdata to pass around framebuffer parameters
      [POWERPC] PCI: Add 64-bit physical address support to setup_indirect_pci
      [POWERPC] 4xx: Kilauea defconfig file
      [POWERPC] 4xx: Kilauea DTS
      [POWERPC] 4xx: Add AMCC Kilauea eval board support to platforms/40x
      [POWERPC] 4xx: Add AMCC 405EX support to cputable.c
      [POWERPC] Adjust TASK_SIZE on ppc32 systems to 3GB that are capable
      [POWERPC] Use PAGE_OFFSET to tell if an address is user/kernel in SW TLB handlers
      [POWERPC] 85xx: Enable FP emulation in MPC8560 ADS defconfig
      [POWERPC] 85xx: Killed <asm/mpc85xx.h>
      [POWERPC] 85xx: Add cpm nodes for 8541/8555 CDS
      [POWERPC] 85xx: Convert mpc8560ads to the new CPM binding.
      [POWERPC] mpc8272ads: Remove muram from the CPM reg property.
      [POWERPC] Make clockevents work on PPC601 processors
      ...
    
    Fixed up conflict in Documentation/powerpc/booting-without-of.txt manually.

commit 7bcf7717b6a047c272410d0cd00213185fe6b99d
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Thu Oct 11 23:46:09 2007 +0100

    [MIPS] Implement clockevents for R4000-style cp0 count/compare interrupt
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

commit cdec12aebe1b10aa58bebaa05bb697843154f7f9
Author: Paul Mackerras <paulus@samba.org>
Date:   Thu Oct 11 21:46:45 2007 +1000

    [POWERPC] Make clockevents work on PPC601 processors
    
    In testing the new clocksource and clockevent code on a PPC601
    processor, I discovered that the clockevent multiplier value for the
    decrementer clockevent was overflowing.  Because the RTCL register in
    the 601 effectively counts at 1GHz (it doesn't actually, but it
    increases by 128 every 128ns), and the shift value was 32, that meant
    the multiplier value had to be 2^32, which won't fit in an unsigned
    long on 32-bit.  The same problem would arise on any platform where
    the timebase frequency was 1GHz or more (not that we actually have any
    such machines today).
    
    This fixes it by reducing the shift value to 16.  Doing the
    calculations with a resolution of 2^-16 nanoseconds (15 femtoseconds)
    should be quite adequate.  :)
    
    Signed-off-by: Paul Mackerras <paulus@samba.org>

commit d968014b7280e2c447b20363e576999040ac72ef
Author: Paul Mackerras <paulus@samba.org>
Date:   Tue Oct 9 09:59:17 2007 +1000

    [POWERPC] Prevent decrementer clockevents from firing early
    
    On old powermacs, we sometimes set the decrementer to 1 in order to
    trigger a decrementer interrupt, which we use to handle an interrupt
    that was pending at the time when it was re-enabled.  This was causing
    the decrementer clock event device to call the event function for the
    next event early, which was causing problems when high-res timers were
    not enabled.
    
    This fixes the problem by recording the timebase value at which the
    next event should occur, and checking the current timebase against the
    recorded value in timer_interrupt.  If it isn't time for the next
    event, it just reprograms the decrementer and returns.
    
    This also subtracts 1 from the value stored into the decrementer,
    which is appropriate because the decrementer interrupts on the
    transition from 0 to -1, not when the decrementer reaches 0.
    
    Signed-off-by: Paul Mackerras <paulus@samba.org>

commit d831d0b83f205888f4be4dee0a074ad67ef809b3
Author: Tony Breeds <tony@bakeyournoodle.com>
Date:   Fri Sep 21 13:26:03 2007 +1000

    [POWERPC] Implement clockevents driver for powerpc
    
    This registers a clock event structure for the decrementer and turns
    on CONFIG_GENERIC_CLOCKEVENTS, which means that we now don't need
    most of timer_interrupt(), since the work is done in generic code.
    For secondary CPUs, their decrementer clockevent is registered when
    the CPU comes up (the generic code automatically removes the
    clockevent when the CPU goes down).
    
    Signed-off-by: Tony Breeds <tony@bakeyournoodle.com>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

commit b7e113dc9d52c4a37d2da6fafe77959f3a28eccf
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Sep 22 22:29:06 2007 +0000

    clockevents: remove the suspend/resume workaround^Wthinko
    
    In a desparate attempt to fix the suspend/resume problem on Andrews
    VAIO I added a workaround which enforced the broadcast of the oneshot
    timer on resume. This was actually resolving the problem on the VAIO
    but was just a stupid workaround, which was not tackling the root
    cause: the assignement of lower idle C-States in the ACPI processor_idle
    code. The cpuidle patches, which utilize the dynamic tick feature and
    go faster into deeper C-states exposed the problem again. The correct
    solution is the previous patch, which prevents lower C-states across
    the suspend/resume.
    
    Remove the enforcement code, including the conditional broadcast timer
    arming, which helped to pamper over the real problem for quite a time.
    The oneshot broadcast flag for the cpu, which runs the resume code can
    never be set at the time when this code is executed. It only gets set,
    when the CPU is entering a lower idle C-State.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Andrew Morton <akpm@linux-foundation.org>
    Cc: Len Brown <lenb@kernel.org>
    Cc: Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit b04e7bdb984e3b7f62fb7f44146a529f88cc7639
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Sep 22 22:29:05 2007 +0000

    ACPI: disable lower idle C-states across suspend/resume
    
    device_suspend() calls ACPI suspend functions, which seems to have undesired
    side effects on lower idle C-states. It took me some time to realize that
    especially the VAIO BIOSes (both Andrews jinxed UP and my elfstruck SMP one)
    show this effect. I'm quite sure that other bug reports against suspend/resume
    about turning the system into a brick have the same root cause.
    
    After fishing in the dark for quite some time, I realized that removing the ACPI
    processor module before suspend (this removes the lower C-state functionality)
    made the problem disappear. Interestingly enough the propability of having a
    bricked box is influenced by various factors (interrupts, size of the ram image,
    ...). Even adding a bunch of printks in the wrong places made the problem go
    away. The previous periodic tick implementation simply pampered over the
    problem, which explains why the dyntick / clockevents changes made this more
    prominent.
    
    We avoid complex functionality during the boot process and we have to do the
    same during suspend/resume. It is a similar scenario and equaly fragile.
    
    Add suspend / resume functions to the ACPI processor code and disable the lower
    idle C-states across suspend/resume. Fall back to the default idle
    implementation (halt) instead.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Andrew Morton <akpm@linux-foundation.org>
    Cc: Len Brown <lenb@kernel.org>
    Cc: Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit 5e41d0d60a534d2a5dc9772600a58f44c8d12506
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun Sep 16 15:36:43 2007 +0200

    clockevents: prevent stale tick update on offline cpu
    
    Taking a cpu offline removes the cpu from the online mask before the
    CPU_DEAD notification is done. The clock events layer does the cleanup
    of the dead CPU from the CPU_DEAD notifier chain. tick_do_timer_cpu is
    used to avoid xtime lock contention by assigning the task of jiffies
    xtime updates to one CPU. If a CPU is taken offline, then this
    assignment becomes stale. This went unnoticed because most of the time
    the offline CPU went dead before the online CPU reached __cpu_die(),
    where the CPU_DEAD state is checked. In the case that the offline CPU did
    not reach the DEAD state before we reach __cpu_die(), the code in there
    goes to sleep for 100ms. Due to the stale time update assignment, the
    system is stuck forever.
    
    Take the assignment away when a cpu is not longer in the cpu_online_mask.
    We do this in the last call to tick_nohz_stop_sched_tick() when the offline
    CPU is on the way to the final play_dead() idle entry.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 31d9b3938c0459e5e9755ce0a98ac1e24eeff972
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun Sep 16 15:36:43 2007 +0200

    clockevents: do not shutdown the oneshot broadcast device
    
    When a cpu goes offline it is removed from the broadcast masks. If the
    mask becomes empty the code shuts down the broadcast device. This is
    wrong, because the broadcast device needs to be ready for the online
    cpu going idle (into a c-state, which stops the local apic timer).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 07eec6af448d13a6a520d9c6f06f2e87f61b567a
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun Sep 16 15:36:43 2007 +0200

    clockevents: Enforce oneshot broadcast when broadcast mask is set on resume
    
    The jinxed VAIO refuses to resume without hitting keys on the keyboard
    when this is not enforced. It is unclear why the cpu ends up in a lower
    C State without notifying the clock events layer, but enforcing the
    oneshot broadcast here is safe.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 729c6ba334771f28a54efd7e3b8f5ab9414ce7bc
Author: Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>
Date:   Sun Sep 16 15:36:43 2007 +0200

    ACPI: Reevaluate C/P/T states when a cpu becomes online
    
    Reevaluate C/P/T states when a cpu becomes online. This avoids
    the caching of the broadcast information in the clockevents layer.
    
    Signed-off-by: Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Len Brown <len.brown@intel.com>

commit 6ddfca9548d8ecc26096a30667423ba919109533
Author: Miao Xie <miaox@cn.fujitsu.com>
Date:   Fri Aug 10 13:01:09 2007 -0700

    timer: remove clockevents_unregister_notifier
    
    I find a function(clockevents_unregister_notifier) which is not called by
    anything in tree.
    
    Signed-off-by: Miao Xie <miaox@cn.fujitsu.com>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit 981d0f3952c977d799c2bb72e083cb9306ccb797
Author: Eric Miao <eric.y.miao@gmail.com>
Date:   Tue Jul 24 01:22:43 2007 +0100

    [ARM] 4526/1: pxa: make ARCH_PXA select GENERIC_CLOCKEVENTS
    
    make ARCH_PXA select GENERIC_CLOCKEVENTS to fix the
    building issue due to merge of clockevents based PXA
    timer
    
    Signed-off-by: eric miao <eric.y.miao@gmail.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

commit 5590a536c0bc403fc73908c66c1c88cbed735ecb
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jul 21 04:37:35 2007 -0700

    clockevents: fix device replacement
    
    When a device is replaced by a better rated device, then the broadcast
    mode needs to be evaluated again. When the new device has no requirement
    for broadcasting, then the broadcast bits for the CPU must be cleared.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: john stultz <johnstul@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit 18de5bc4c1f1f1fa5e14f354a7603bd6e9d4e3b6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jul 21 04:37:34 2007 -0700

    clockevents: fix resume logic
    
    We need to make sure, that the clockevent devices are resumed, before
    the tick is resumed. The current resume logic does not guarantee this.
    
    Add CLOCK_EVT_MODE_RESUME and call the set mode functions of the clock
    event devices before resuming the tick / oneshot functionality.
    
    Fixup the existing users.
    
    Thanks to Nigel Cunningham for tracking down a long standing thinko,
    which affected the jinxed VAIO.
    
    [akpm@linux-foundation.org: xen build fix]
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: john stultz <johnstul@us.ibm.com>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit 93da56efcf8c6a111f0349f6b7651172d4745ca0
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jul 21 04:37:33 2007 -0700

    clockevents: remove prototypes of removed functions
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: john stultz <johnstul@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit 7713a7d195c2e11d7ba6a973317da0af862d1264
Author: David Miller <davem@davemloft.net>
Date:   Mon Jul 16 17:17:44 2007 -0700

    [HRTIMER] Fix cpu pointer arg to clockevents_notify()
    
    All of the clockevent notifiers expect a pointer to
    an "unsigned int" cpu argument, but hrtimer_cpu_notify()
    passes in a pointer to a long.
    
    [ Discussed with and ok by Thomas Gleixner ]
    
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit 78c1b0657475dbafa008c71e3ccdc32141d8c7c7
Author: Andi Kleen <ak@suse.de>
Date:   Sun Jul 15 23:40:15 2007 -0700

    Remove clockevents_{release,request}_device
    
    Not called by anything in tree.
    
    Signed-off-by: Andi Kleen <ak@suse.de>
    Acked-by: Ingo Molnar <mingo@elte.hu>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: john stultz <johnstul@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit 57be2b484a417bffae66359b9b89e7239480b729
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed May 9 17:33:24 2007 +0900

    sh: clockevent/clocksource/hrtimers/nohz TMU support.
    
    This adds basic support for clockevents and clocksources,
    presently only implemented for TMU-based systems (which
    are the majority of SH-3 and SH-4 systems).
    
    The old NO_IDLE_HZ implementation is also dropped completely,
    the only users of this were on TMU-based systems anyways.
    
    More work needs to be done to generalize the TMU handling,
    in that the current implementation is rather tied to the
    notion of TMU0 and TMU1 utilization.
    
    Additionally, as more SH timers switch over to this scheme,
    we'll be able to gut most of the remaining system timer
    infrastructure that existed before.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

commit fabb5c4e4a474ff0f7d6c1d3466a1b79bbce5f49
Merge: aa12b2842aba d6444514b890
Author: Linus Torvalds <torvalds@woody.linux-foundation.org>
Date:   Sat May 5 13:30:23 2007 -0700

    Merge master.kernel.org:/pub/scm/linux/kernel/git/jejb/voyager-2.6
    
    * master.kernel.org:/pub/scm/linux/kernel/git/jejb/voyager-2.6:
      [VOYAGER] add smp alternatives
      [VOYAGER] Use modern techniques to setup and teardown low identiy mappings.
      [VOYAGER] Convert the monitor thread to use the kthread API
      [VOYAGER] clockevents driver: bring voyager in to line
      [VOYAGER] clockevents: correct boot cpu is zero assumption
      [VOYAGER] add smp_call_function_single

commit 9f483519be82420e308b9a90a96a9c62f28032ae
Author: James Bottomley <James.Bottomley@HansenPartnership.com>
Date:   Mon Apr 30 11:30:10 2007 -0500

    [VOYAGER] clockevents driver: bring voyager in to line
    
    The irq0 timer interrupt should be initiallised identically with
    mach-default.
    
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

commit 2feae2158a96aa5e02ca2e630896e6f553c36dc0
Author: James Bottomley <James.Bottomley@HansenPartnership.com>
Date:   Mon Apr 30 11:27:25 2007 -0500

    [VOYAGER] clockevents: correct boot cpu is zero assumption
    
    This isn't true for voyager, so alter setup_pit_timer() to initialise
    the cpumask from the current processor id (which should be the boot
    processor) rather than defaulting to zero.
    
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

commit 112f48716d9f292c92a033cff9e3ce7405ed4280
Author: David S. Miller <davem@sunset.davemloft.net>
Date:   Mon Mar 5 15:28:37 2007 -0800

    [SPARC64]: Add clocksource/clockevents support.
    
    I'd like to thank John Stul and others for helping
    me along the way.
    
    A lot of cleanups fell out of this.  For example, the get_compare()
    tick_op was totally unused, so was deleted.  And the most often used
    tick_op members were grouped together for cache-friendlyness.
    
    The sparc64 TSC is given to the kernel as a one-shot timer.
    
    tick_ops->init_timer() simply turns off the privileged bit in
    the tick register (when possible), and disables the interrupt
    by setting bit 63 in the compare register.  The ->disable_irq()
    op also sets this bit.
    
    tick_ops->add_compare() is changed to:
    
    1) Add the given delta to "tick" not to "compare"
    2) Return a boolean which, if true, means that the tick
       value read after writing the compare value was found
       to have incremented past the initial tick value.  This
       mirrors logic used in the HPET driver's ->next_event()
       method.
    
    Each tick_ops implementation also now provides a name string.
    And we feed this into the clocksource and clockevents layers.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 935c631db827cc3a96df4dcc6fec374b994fdbd1
Author: Ingo Molnar <mingo@elte.hu>
Date:   Wed Mar 28 13:17:18 2007 +0200

    [PATCH] hrtimers: fix reprogramming SMP race
    
    hrtimer_start() incorrectly set the 'reprogram' flag to enqueue_hrtimer(),
    which should only be 1 if the hrtimer is queued to the current CPU.
    
    Doing otherwise could result in a reprogramming of the current CPU's
    clockevents device, with a timer that is not queued to it - resulting in a
    bogus next expiry value.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Cc: Michal Piotrowski <michal.k.k.piotrowski@gmail.com>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit c7f6d15ff2664467a2cb669abcabb5ffaf719b2d
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Mar 27 09:08:26 2007 +0200

    [PATCH] i386: Fix bogus return value in hpet_next_event()
    
    The clockevents / tick management code expects an error value, when the
    event is already expired. hpet_next_event() returns 1 in that case.
    
    Fix it to return the proper -ETIME error code.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit 291bc047e125ff02c9affe06a7df28bed57b054d
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Mar 26 11:21:08 2007 +0200

    [PATCH] clockevents: remove bad designed sysfs support for now
    
    The current sysfs support of clockevents does not obey the "only one
    value per file" rule.
    
    The real fix is not 2.6.21 material. Therefor remove the sysfs support
    for now.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Ingo Molnar <mingo@elte.hu>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit ad62ca2bd89f72e9b80dfaffc463e87bec5e75cb
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Mar 22 00:11:21 2007 -0800

    [PATCH] i386: disable local apic timer via command line or dmi quirk
    
    The local APIC timer stops to work in deeper C-States.  This is handled by
    the ACPI code and a broadcast mechanism in the clockevents / tick managment
    code.
    
    Some systems do not expose the deeper C-States to the kernel, but switch
    into deeper C-States behind the kernels back.  This delays the local apic
    timer interrupts for ever and makes the systems unusable.
    
    Add a command line option to disable the local apic timer and a dmi
    quirk for known broken systems.
    
    Andi sayeth:
    
      While not wrong by itself i think it is still better to use some heuristic
      -- like "has battery in ACPI" With the DMI table if the problem is more wide
      spread we will just continue extending it.
    
      But anyways should be ok now for .21 although I'm not really happy with
      it.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Ingo Molnar <mingo@elte.hu>
    Cc: john stultz <johnstul@us.ibm.com>
    Grudgingly-acked-by: Andi Kleen <ak@suse.de>
    Cc: Len Brown <lenb@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit 6b3964cde70cfe6db79d35b42137431ef7d2f7e4
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Mar 22 22:46:18 2007 +0100

    [PATCH] i386: clockevents fix breakage on Geode/Cyrix PIT implementations
    
    The PIT has no dedicated mode for shut down. The only way to disable PIT
    is to put it into one shot mode. AMD implementations of PIT on Geode
    (also observed on Cyrix) are confused by an "empty" transition from
    CLOCK_EVT_MODE_UNUSED to CLOCK_EVT_MODE_SHUTDOWN, which puts the PIT
    into one shot mode momentarily.
    
    I realized after staring helpless at the bug report
    http://bugzilla.kernel.org/show_bug.cgi?id=8027 for quite a while, that
    the only change, which might influence the bogomips calibration, is the
    above transition during the PIT initialization.
    
    Avoiding the unnecessary switch to oneshot and later to periodic mode
    fixes the weird bogomips value and also the resulting slowness.
    
    The fix is confirmed on OLPC and another Geode based box.
    
    Note: this is unrelated to the Dual Core problem discussed here:
    http://lkml.org/lkml/2007/3/17/48
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit 25496caec111481161e7f06bbfa12a533c43cc6f
Author: Thomas Renninger <trenn@suse.de>
Date:   Tue Feb 27 12:13:00 2007 -0500

    ACPI: Only use IPI on known broken machines (AMD, Dothan/BaniasPentium M)
    
    Use IPI for blacklisted CPUs, add parameter IPI vs LAPIC
    
    Currently, Linux disables lapic timer for all machines with C2 and higher
    C-state support.
    
    According to Intel only specific Intel models (Banias/Dothan) are broken
    in respect of not waking up from C2 with lapic.
    
    However, I am not sure about the naming of the parameter and how it
    could/should get integrated into the dyntick part
    (CONFIG_GENERIC_CLOCKEVENTS). There, a more fine grained check (TSC
    still running?, ..) is needed? Does this make sense (always use
    CLOCK_EVT_NOTIFY_BROADCAST_ON, but use OFF if forced by use_ipi=0:
    clockevents_notify(use_ipi ? CLOCK_EVT_NOTIFY_BROADCAST_ON :
    CLOCK_EVT_NOTIFY_BROADCAST_OFF, &pr->id);
    
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    Signed-off-by: Len Brown <len.brown@intel.com>

commit cd05a1f818073a623455a58e756c5b419fc98db9
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Mar 17 00:25:52 2007 +0100

    [PATCH] clockevents: Fix suspend/resume to disk hangs
    
    I finally found a dual core box, which survives suspend/resume without
    crashing in the middle of nowhere. Sigh, I never figured out from the
    code and the bug reports what's going on.
    
    The observed hangs are caused by a stale state transition of the clock
    event devices, which keeps the RCU synchronization away from completion,
    when the non boot CPU is brought back up.
    
    The suspend/resume in oneshot mode needs the similar care as the
    periodic mode during suspend to RAM. My assumption that the state
    transitions during the different shutdown/bringups of s2disk would go
    through the periodic boot phase and then switch over to highres resp.
    nohz mode were simply wrong.
    
    Add the appropriate suspend / resume handling for the non periodic
    modes.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit 38bed5429987c939d86cd3da915d6706fd1e6e53
Author: Ingo Molnar <mingo@elte.hu>
Date:   Thu Feb 22 09:09:34 2007 +0100

    [PATCH] add MAINTAINERS entry for high-res timers, clockevents, dynticks
    
    Thomas is the maintainer and primary author of the high-res timers,
    clockevents and dynticks code.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit 3494c16676a21e7e53e21b08a0a469a38df6dcfb
Author: David S. Miller <davem@sunset.davemloft.net>
Date:   Sat Feb 24 22:11:42 2007 -0800

    [TICK] tick-common: Fix one-shot handling in tick_handle_periodic().
    
    When clockevents_program_event() is given an expire time in the
    past, it does not update dev->next_event, so this looping code
    would loop forever once the first in-the-past expiration time
    was used.
    
    Keep advancing "next" locally to fix this bug.
    
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 54cdfdb47f73b5af3d1ebb0f1e383efbe70fde9e
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Feb 16 01:28:11 2007 -0800

    [PATCH] hrtimers: add high resolution timer support
    
    Implement high resolution timers on top of the hrtimers infrastructure and the
    clockevents / tick-management framework.  This provides accurate timers for
    all hrtimer subsystem users.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Cc: john stultz <johnstul@us.ibm.com>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit d36b49b91065dbfa305c5a66010b3497c741eee0
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Feb 16 01:28:06 2007 -0800

    [PATCH] i386 rework local apic timer calibration
    
    The local apic timer calibration has two problem cases:
    
    1.  The calibration is based on readout of the PIT/HPET timer to detect the
       wrap of the periodic tick.  It happens that a box gets stuck in the
       calibration loop due to a PIT with a broken readout function.
    
    2.  CoreDuo boxen show a sporadic PIT runs too slow defect, which results
       in a wrong lapic calibration.  The PIT goes back to normal operation once
       the lapic timer is switched to periodic mode.
    
    Both are existing and unfixed problems in the current upstream kernel and
    prevent certain laptops and other systems from booting Linux.
    
    Rework the code to address both problems:
    
    - Make the calibration interrupt driven.  This removes the wait_timer_tick
      magic hackery from lapic.c and time_hpet.c.  The clockevents framework
      allows easy substitution of the global tick event handler for the
      calibration.  This is more accurate than monitoring jiffies.  At this point
      of the boot process, nothing disturbes the interrupt delivery, so the
      results are very accurate.
    
    - Verify the calibration against the PM timer, when available by using the
      early access function.  When the measured calibration period is outside of
      an one percent window, then the lapic timer calibration is adjusted to the
      pm timer result.
    
    - Verify the calibration by running the lapic timer with the calibration
      handler.  Disable lapic timer in case of deviation.
    
    This also removes the "synchronization" of the local apic timer to the global
    tick.  This synchronization never worked, as there is no way to synchronize
    PIT(HPET) and local APIC timer.  The synchronization by waiting for the tick
    just alignes the local APIC timer for the first events, but later the events
    drift away due to the different clocks.  Removing the "sync" is just
    randomizing the asynchronous behaviour at setup time.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Cc: Zachary Amsden <zach@vmware.com>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Cc: Rohit Seth <rohitseth@google.com>
    Cc: Andi Kleen <ak@suse.de>
    Cc: john stultz <johnstul@us.ibm.com>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit e9e2cdb412412326c4827fc78ba27f410d837e6e
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Feb 16 01:28:04 2007 -0800

    [PATCH] clockevents: i386 drivers
    
    Add clockevent drivers for i386: lapic (local) and PIT/HPET (global).  Update
    the timer IRQ to call into the PIT/HPET driver's event handler and the
    lapic-timer IRQ to call into the lapic clockevent driver.  The assignement of
    timer functionality is delegated to the core framework code and replaces the
    compile and runtime evalution in do_timer_interrupt_hook()
    
    Use the clockevents broadcast support and implement the lapic_broadcast
    function for ACPI.
    
    No changes to existing functionality.
    
    [ kdump fix from Vivek Goyal <vgoyal@in.ibm.com> ]
    [ fixes based on review feedback from Arjan van de Ven <arjan@infradead.org> ]
    Cleanups-from: Adrian Bunk <bunk@stusta.de>
    Build-fixes-from: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Cc: john stultz <johnstul@us.ibm.com>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Cc: Andi Kleen <ak@suse.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit 906568c9c668ff994f4078932ec6ae1e3950d1af
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Feb 16 01:28:01 2007 -0800

    [PATCH] tick-management: core functionality
    
    With Ingo Molnar <mingo@elte.hu>
    
    The tick-management code is the first user of the clockevents layer.  It takes
    clock event devices from the clock events core and uses them to provide the
    periodic tick.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Cc: john stultz <johnstul@us.ibm.com>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit d316c57ff6bfad9557462b9100f25c6260d2b774
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Feb 16 01:28:00 2007 -0800

    [PATCH] clockevents: add core functionality
    
    Architectures register their clock event devices, in the clock events core.
    Users of the clockevents core can get clock event devices for their use.  The
    clockevents core code provides notification mechanisms for various clock
    related management events.
    
    This allows to control the clock event devices without the architectures
    having to worry about the details of function assignment.  This is also a
    preliminary for high resolution timers and dynamic ticks to allow the core
    code to control the clock functionality without intrusive changes to the
    architecture code.
    
    [Fixes-by: Ingo Molnar <mingo@elte.hu>]
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Cc: john stultz <johnstul@us.ibm.com>
    Cc: Andi Kleen <ak@suse.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
