commit d40fd60093325cd7b77bc8622cb9593cd27fdaa6
Author: Jacob Keller <jacob.e.keller@intel.com>
Date:   Mon Dec 5 11:52:50 2022 -0800

    ice: handle flushing stale Tx timestamps in ice_ptp_tx_tstamp
    
    In the event of a PTP clock time change due to .adjtime or .settime, the
    ice driver needs to update the cached copy of the PHC time and also discard
    any outstanding Tx timestamps.
    
    This is required because otherwise the wrong copy of the PHC time will be
    used when extending the Tx timestamp. This could result in reporting
    incorrect timestamps to the stack.
    
    The current approach taken to handle this is to call
    ice_ptp_flush_tx_tracker, which will discard any timestamps which are not
    yet complete.
    
    This is problematic for two reasons:
    
    1) it could lead to a potential race condition where the wrong timestamp is
       associated with a future packet.
    
       This can occur with the following flow:
    
       1. Thread A gets request to transmit a timestamped packet, and picks an
          index and transmits the packet
    
       2. Thread B calls ice_ptp_flush_tx_tracker and sees the index in use,
          marking is as disarded. No timestamp read occurs because the status
          bit is not set, but the index is released for re-use
    
       3. Thread A gets a new request to transmit another timestamped packet,
          picks the same (now unused) index and transmits that packet.
    
       4. The PHY transmits the first packet and updates the timestamp slot and
          generates an interrupt.
    
       5. The ice_ptp_tx_tstamp thread executes and sees the interrupt and a
          valid timestamp but associates it with the new Tx SKB and not the one
          that actual timestamp for the packet as expected.
    
       This could result in the previous timestamp being assigned to a new
       packet producing incorrect timestamps and leading to incorrect behavior
       in PTP applications.
    
       This is most likely to occur when the packet rate for Tx timestamp
       requests is very high.
    
    2) on E822 hardware, we must avoid reading a timestamp index more than once
       each time its status bit is set and an interrupt is generated by
       hardware.
    
       We do have some extensive checks for the unread flag to ensure that only
       one of either the ice_ptp_flush_tx_tracker or ice_ptp_tx_tstamp threads
       read the timestamp. However, even with this we can still have cases
       where we "flush" a timestamp that was actually completed in hardware.
       This can lead to cases where we don't read the timestamp index as
       appropriate.
    
    To fix both of these issues, we must avoid calling ice_ptp_flush_tx_tracker
    outside of the teardown path.
    
    Rather than using ice_ptp_flush_tx_tracker, introduce a new state bitmap,
    the stale bitmap. Start this as cleared when we begin a new timestamp
    request. When we're about to extend a timestamp and send it up to the
    stack, first check to see if that stale bit was set. If so, drop the
    timestamp without sending it to the stack.
    
    When we need to update the cached PHC timestamp out of band, just mark all
    currently outstanding timestamps as stale. This will ensure that once
    hardware completes the timestamp we'll ignore it correctly and avoid
    reporting bogus timestamps to userspace.
    
    With this change, we fix potential issues caused  by calling
    ice_ptp_flush_tx_tracker during normal operation.
    
    Signed-off-by: Jacob Keller <jacob.e.keller@intel.com>
    Tested-by: Gurucharan G <gurucharanx.g@intel.com> (A Contingent worker at Intel)
    Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>

commit 7c77d1f9ba1137ece88223a0d49e3cb6157f89f1
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sun Jul 17 23:53:34 2022 +0200

    timekeeping: contribute wall clock to rng on time change
    
    commit b8ac29b40183a6038919768b5d189c9bd91ce9b4 upstream.
    
    The rng's random_init() function contributes the real time to the rng at
    boot time, so that events can at least start in relation to something
    particular in the real world. But this clock might not yet be set that
    point in boot, so nothing is contributed. In addition, the relation
    between minor clock changes from, say, NTP, and the cycle counter is
    potentially useful entropic data.
    
    This commit addresses this by mixing in a time stamp on calls to
    settimeofday and adjtimex. No entropy is credited in doing so, so it
    doesn't make initialization faster, but it is still useful input to
    have.
    
    Fixes: 1da177e4c3f4 ("Linux-2.6.12-rc2")
    Cc: stable@vger.kernel.org
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Eric Biggers <ebiggers@google.com>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 2f243fe8db214d9c3f682ab60d05fe5792f7e922
Author: Wolfram Sang <wsa+renesas@sang-engineering.com>
Date:   Wed Jul 13 22:46:13 2022 +0200

    selftests: timers: valid-adjtimex: build fix for newer toolchains
    
    [ Upstream commit 9a162977d20436be5678a8e21a8e58eb4616d86a ]
    
    Toolchains with an include file 'sys/timex.h' based on 3.18 will have a
    'clock_adjtime' definition added, so it can't be static in the code:
    
    valid-adjtimex.c:43:12: error: static declaration of ‘clock_adjtime’ follows non-static declaration
    
    Fixes: e03a58c320e1 ("kselftests: timers: Add adjtimex SETOFFSET validity tests")
    Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Acked-by: John Stultz <jstultz@google.com>
    Signed-off-by: Shuah Khan <skhan@linuxfoundation.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 3e4428ed322132e48e04980952f10a7dde0ac97d
Author: Wolfram Sang <wsa+renesas@sang-engineering.com>
Date:   Wed Jul 13 22:46:13 2022 +0200

    selftests: timers: valid-adjtimex: build fix for newer toolchains
    
    [ Upstream commit 9a162977d20436be5678a8e21a8e58eb4616d86a ]
    
    Toolchains with an include file 'sys/timex.h' based on 3.18 will have a
    'clock_adjtime' definition added, so it can't be static in the code:
    
    valid-adjtimex.c:43:12: error: static declaration of ‘clock_adjtime’ follows non-static declaration
    
    Fixes: e03a58c320e1 ("kselftests: timers: Add adjtimex SETOFFSET validity tests")
    Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Acked-by: John Stultz <jstultz@google.com>
    Signed-off-by: Shuah Khan <skhan@linuxfoundation.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit c66b57015ec1e03afe841b8283408f9b98eb4f04
Author: Wolfram Sang <wsa+renesas@sang-engineering.com>
Date:   Wed Jul 13 22:46:13 2022 +0200

    selftests: timers: valid-adjtimex: build fix for newer toolchains
    
    [ Upstream commit 9a162977d20436be5678a8e21a8e58eb4616d86a ]
    
    Toolchains with an include file 'sys/timex.h' based on 3.18 will have a
    'clock_adjtime' definition added, so it can't be static in the code:
    
    valid-adjtimex.c:43:12: error: static declaration of ‘clock_adjtime’ follows non-static declaration
    
    Fixes: e03a58c320e1 ("kselftests: timers: Add adjtimex SETOFFSET validity tests")
    Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Acked-by: John Stultz <jstultz@google.com>
    Signed-off-by: Shuah Khan <skhan@linuxfoundation.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit c6cf21d8d5209be883c835ebc883b5566483bfca
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sun Jul 17 23:53:34 2022 +0200

    timekeeping: contribute wall clock to rng on time change
    
    [ Upstream commit b8ac29b40183a6038919768b5d189c9bd91ce9b4 ]
    
    The rng's random_init() function contributes the real time to the rng at
    boot time, so that events can at least start in relation to something
    particular in the real world. But this clock might not yet be set that
    point in boot, so nothing is contributed. In addition, the relation
    between minor clock changes from, say, NTP, and the cycle counter is
    potentially useful entropic data.
    
    This commit addresses this by mixing in a time stamp on calls to
    settimeofday and adjtimex. No entropy is credited in doing so, so it
    doesn't make initialization faster, but it is still useful input to
    have.
    
    Fixes: 1da177e4c3f4 ("Linux-2.6.12-rc2")
    Cc: stable@vger.kernel.org
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Eric Biggers <ebiggers@google.com>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit ee3cc4c7612143bfa731725180c42e58afb70c35
Author: Wolfram Sang <wsa+renesas@sang-engineering.com>
Date:   Wed Jul 13 22:46:13 2022 +0200

    selftests: timers: valid-adjtimex: build fix for newer toolchains
    
    [ Upstream commit 9a162977d20436be5678a8e21a8e58eb4616d86a ]
    
    Toolchains with an include file 'sys/timex.h' based on 3.18 will have a
    'clock_adjtime' definition added, so it can't be static in the code:
    
    valid-adjtimex.c:43:12: error: static declaration of ‘clock_adjtime’ follows non-static declaration
    
    Fixes: e03a58c320e1 ("kselftests: timers: Add adjtimex SETOFFSET validity tests")
    Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Acked-by: John Stultz <jstultz@google.com>
    Signed-off-by: Shuah Khan <skhan@linuxfoundation.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 141c2785d940c88998d5b704bbf2e2c72b4f9cf0
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sun Jul 17 23:53:34 2022 +0200

    timekeeping: contribute wall clock to rng on time change
    
    [ Upstream commit b8ac29b40183a6038919768b5d189c9bd91ce9b4 ]
    
    The rng's random_init() function contributes the real time to the rng at
    boot time, so that events can at least start in relation to something
    particular in the real world. But this clock might not yet be set that
    point in boot, so nothing is contributed. In addition, the relation
    between minor clock changes from, say, NTP, and the cycle counter is
    potentially useful entropic data.
    
    This commit addresses this by mixing in a time stamp on calls to
    settimeofday and adjtimex. No entropy is credited in doing so, so it
    doesn't make initialization faster, but it is still useful input to
    have.
    
    Fixes: 1da177e4c3f4 ("Linux-2.6.12-rc2")
    Cc: stable@vger.kernel.org
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Eric Biggers <ebiggers@google.com>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 78834a56e8440064d8c9656f6af65f0f0a895416
Author: Wolfram Sang <wsa+renesas@sang-engineering.com>
Date:   Wed Jul 13 22:46:13 2022 +0200

    selftests: timers: valid-adjtimex: build fix for newer toolchains
    
    [ Upstream commit 9a162977d20436be5678a8e21a8e58eb4616d86a ]
    
    Toolchains with an include file 'sys/timex.h' based on 3.18 will have a
    'clock_adjtime' definition added, so it can't be static in the code:
    
    valid-adjtimex.c:43:12: error: static declaration of ‘clock_adjtime’ follows non-static declaration
    
    Fixes: e03a58c320e1 ("kselftests: timers: Add adjtimex SETOFFSET validity tests")
    Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Acked-by: John Stultz <jstultz@google.com>
    Signed-off-by: Shuah Khan <skhan@linuxfoundation.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 2d74ca7d3663d185377535c6257f14bce7d041a3
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sun Jul 17 23:53:34 2022 +0200

    timekeeping: contribute wall clock to rng on time change
    
    [ Upstream commit b8ac29b40183a6038919768b5d189c9bd91ce9b4 ]
    
    The rng's random_init() function contributes the real time to the rng at
    boot time, so that events can at least start in relation to something
    particular in the real world. But this clock might not yet be set that
    point in boot, so nothing is contributed. In addition, the relation
    between minor clock changes from, say, NTP, and the cycle counter is
    potentially useful entropic data.
    
    This commit addresses this by mixing in a time stamp on calls to
    settimeofday and adjtimex. No entropy is credited in doing so, so it
    doesn't make initialization faster, but it is still useful input to
    have.
    
    Fixes: 1da177e4c3f4 ("Linux-2.6.12-rc2")
    Cc: stable@vger.kernel.org
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Eric Biggers <ebiggers@google.com>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit bad19492a8ec5aaaab9d89756140b3d25ca3dd66
Author: Wolfram Sang <wsa+renesas@sang-engineering.com>
Date:   Wed Jul 13 22:46:13 2022 +0200

    selftests: timers: valid-adjtimex: build fix for newer toolchains
    
    [ Upstream commit 9a162977d20436be5678a8e21a8e58eb4616d86a ]
    
    Toolchains with an include file 'sys/timex.h' based on 3.18 will have a
    'clock_adjtime' definition added, so it can't be static in the code:
    
    valid-adjtimex.c:43:12: error: static declaration of ‘clock_adjtime’ follows non-static declaration
    
    Fixes: e03a58c320e1 ("kselftests: timers: Add adjtimex SETOFFSET validity tests")
    Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Acked-by: John Stultz <jstultz@google.com>
    Signed-off-by: Shuah Khan <skhan@linuxfoundation.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 96ba981f09a9ebe683ab629a1205fec120e77ce9
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sun Jul 17 23:53:34 2022 +0200

    timekeeping: contribute wall clock to rng on time change
    
    [ Upstream commit b8ac29b40183a6038919768b5d189c9bd91ce9b4 ]
    
    The rng's random_init() function contributes the real time to the rng at
    boot time, so that events can at least start in relation to something
    particular in the real world. But this clock might not yet be set that
    point in boot, so nothing is contributed. In addition, the relation
    between minor clock changes from, say, NTP, and the cycle counter is
    potentially useful entropic data.
    
    This commit addresses this by mixing in a time stamp on calls to
    settimeofday and adjtimex. No entropy is credited in doing so, so it
    doesn't make initialization faster, but it is still useful input to
    have.
    
    Fixes: 1da177e4c3f4 ("Linux-2.6.12-rc2")
    Cc: stable@vger.kernel.org
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Eric Biggers <ebiggers@google.com>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 4d34813982877767ff3459cb9ae7ce9c5488d629
Author: Wolfram Sang <wsa+renesas@sang-engineering.com>
Date:   Wed Jul 13 22:46:13 2022 +0200

    selftests: timers: valid-adjtimex: build fix for newer toolchains
    
    [ Upstream commit 9a162977d20436be5678a8e21a8e58eb4616d86a ]
    
    Toolchains with an include file 'sys/timex.h' based on 3.18 will have a
    'clock_adjtime' definition added, so it can't be static in the code:
    
    valid-adjtimex.c:43:12: error: static declaration of ‘clock_adjtime’ follows non-static declaration
    
    Fixes: e03a58c320e1 ("kselftests: timers: Add adjtimex SETOFFSET validity tests")
    Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Acked-by: John Stultz <jstultz@google.com>
    Signed-off-by: Shuah Khan <skhan@linuxfoundation.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit b1a582e64bf2229e1914068f8ee81a6f83eb0373
Author: Jacob Keller <jacob.e.keller@intel.com>
Date:   Wed Jul 27 16:16:02 2022 -0700

    ice: introduce ice_ptp_reset_cached_phctime function
    
    If the PTP hardware clock is adjusted, the ice driver must update the
    cached PHC timestamp. This is required in order to perform timestamp
    extension on the shorter timestamps captured by the PHY.
    
    Currently, we simply call ice_ptp_update_cached_phctime in the settime and
    adjtime callbacks. This has a few issues:
    
    1) if ICE_CFG_BUSY is set because another thread is updating the Rx rings,
       we will exit with an error. This is not checked, and the functions do
       not re-schedule the update. This could leave the cached timestamp
       incorrect until the next scheduled work item execution.
    
    2) even if we did handle an update, any currently outstanding Tx timestamp
       would be extended using the wrong cached PHC time. This would produce
       incorrect results.
    
    To fix these issues, introduce a new ice_ptp_reset_cached_phctime function.
    This function calls the ice_ptp_update_cached_phctime, and discards
    outstanding Tx timestamps.
    
    If the ice_ptp_update_cached_phctime function fails because ICE_CFG_BUSY is
    set, we log a warning and schedule the thread to execute soon. The update
    function is modified so that it always updates the cached copy in the PF
    regardless. This ensures we have the most up to date values possible and
    minimizes the risk of a packet timestamp being extended with the wrong
    value.
    
    It would be nice if we could skip reporting Rx timestamps until the cached
    values are up to date. However, we can't access the Rx rings while
    ICE_CFG_BUSY is set because they are actively being updated by another
    thread.
    
    Signed-off-by: Jacob Keller <jacob.e.keller@intel.com>
    Tested-by: Gurucharan <gurucharanx.g@intel.com> (A Contingent worker at Intel)
    Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>

commit e05d5b9c5bbea80313d8f58c3a80a18839b25480
Merge: 665fe72a7d4f 4062eba9f3d0
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Aug 2 19:44:56 2022 -0700

    Merge tag 'linux-kselftest-next-5.20-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/shuah/linux-kselftest
    
    Pull Kselftest updates from Shuah Khan:
    
     - timers test build fixes and cleanups for new tool chains
    
     - removing khdr from kselftest framework and main Makefile
    
     - changes to test output messages to improve reports
    
    * tag 'linux-kselftest-next-5.20-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/shuah/linux-kselftest: (24 commits)
      Makefile: replace headers_install with headers for kselftest
      selftests/landlock: drop deprecated headers dependency
      selftests: timers: clocksource-switch: adapt to kselftest framework
      selftests: timers: clocksource-switch: add 'runtime' command line parameter
      selftests: timers: clocksource-switch: add command line switch to skip sanity check
      selftests: timers: clocksource-switch: sort includes
      selftests: timers: clocksource-switch: fix passing errors from child
      selftests: timers: inconsistency-check: adapt to kselftest framework
      selftests: timers: nanosleep: adapt to kselftest framework
      selftests: timers: fix declarations of main()
      selftests: timers: valid-adjtimex: build fix for newer toolchains
      Makefile: add headers_install to kselftest targets
      selftests: drop KSFT_KHDR_INSTALL make target
      selftests: stop using KSFT_KHDR_INSTALL
      selftests: drop khdr make target
      selftests: drivers/dma-buf: Improve message in selftest summary
      selftests/kcmp: Make the test output consistent and clear
      selftests:timers: globals don't need initialization to 0
      selftests/drivers/gpu: Add error messages to drm_mm.sh
      selftests/tpm2: increase timeout for kselftests
      ...

commit b8ac29b40183a6038919768b5d189c9bd91ce9b4
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sun Jul 17 23:53:34 2022 +0200

    timekeeping: contribute wall clock to rng on time change
    
    The rng's random_init() function contributes the real time to the rng at
    boot time, so that events can at least start in relation to something
    particular in the real world. But this clock might not yet be set that
    point in boot, so nothing is contributed. In addition, the relation
    between minor clock changes from, say, NTP, and the cycle counter is
    potentially useful entropic data.
    
    This commit addresses this by mixing in a time stamp on calls to
    settimeofday and adjtimex. No entropy is credited in doing so, so it
    doesn't make initialization faster, but it is still useful input to
    have.
    
    Fixes: 1da177e4c3f4 ("Linux-2.6.12-rc2")
    Cc: stable@vger.kernel.org
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Eric Biggers <ebiggers@google.com>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

commit 9a162977d20436be5678a8e21a8e58eb4616d86a
Author: Wolfram Sang <wsa+renesas@sang-engineering.com>
Date:   Wed Jul 13 22:46:13 2022 +0200

    selftests: timers: valid-adjtimex: build fix for newer toolchains
    
    Toolchains with an include file 'sys/timex.h' based on 3.18 will have a
    'clock_adjtime' definition added, so it can't be static in the code:
    
    valid-adjtimex.c:43:12: error: static declaration of ‘clock_adjtime’ follows non-static declaration
    
    Fixes: e03a58c320e1 ("kselftests: timers: Add adjtimex SETOFFSET validity tests")
    Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Acked-by: John Stultz <jstultz@google.com>
    Signed-off-by: Shuah Khan <skhan@linuxfoundation.org>

commit b7429f8aabf58d68e1807dffdb47fe8d25bf7d11
Author: Jonathan Lemon <jonathan.lemon@gmail.com>
Date:   Fri May 13 15:52:31 2022 -0700

    ptp: ocp: have adjtime handle negative delta_ns correctly
    
    [ Upstream commit da2172a9bfec858ceeb0271b9d444378490398c8 ]
    
    delta_ns is a s64, but it was being passed ptp_ocp_adjtime_coarse
    as an u64.  Also, it turns out that timespec64_add_ns() only handles
    positive values, so perform the math with set_normalized_timespec().
    
    Fixes: 90f8f4c0e3ce ("ptp: ocp: Add ptp_ocp_adjtime_coarse for large adjustments")
    Suggested-by: Vadim Fedorenko <vfedorenko@novek.ru>
    Signed-off-by: Jonathan Lemon <jonathan.lemon@gmail.com>
    Acked-by: Vadim Fedorenko <vfedorenko@novek.ru>
    Link: https://lore.kernel.org/r/20220513225231.1412-1-jonathan.lemon@gmail.com
    Signed-off-by: Jakub Kicinski <kuba@kernel.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit da2172a9bfec858ceeb0271b9d444378490398c8
Author: Jonathan Lemon <jonathan.lemon@gmail.com>
Date:   Fri May 13 15:52:31 2022 -0700

    ptp: ocp: have adjtime handle negative delta_ns correctly
    
    delta_ns is a s64, but it was being passed ptp_ocp_adjtime_coarse
    as an u64.  Also, it turns out that timespec64_add_ns() only handles
    positive values, so perform the math with set_normalized_timespec().
    
    Fixes: 90f8f4c0e3ce ("ptp: ocp: Add ptp_ocp_adjtime_coarse for large adjustments")
    Suggested-by: Vadim Fedorenko <vfedorenko@novek.ru>
    Signed-off-by: Jonathan Lemon <jonathan.lemon@gmail.com>
    Acked-by: Vadim Fedorenko <vfedorenko@novek.ru>
    Link: https://lore.kernel.org/r/20220513225231.1412-1-jonathan.lemon@gmail.com
    Signed-off-by: Jakub Kicinski <kuba@kernel.org>

commit 3dc6ffae2da201284cb24af66af77ee0bbb2efaa
Author: Kurt Kanzenbach <kurt@linutronix.de>
Date:   Thu Apr 14 11:18:03 2022 +0200

    timekeeping: Introduce fast accessor to clock tai
    
    Introduce fast/NMI safe accessor to clock tai for tracing. The Linux kernel
    tracing infrastructure has support for using different clocks to generate
    timestamps for trace events. Especially in TSN networks it's useful to have TAI
    as trace clock, because the application scheduling is done in accordance to the
    network time, which is based on TAI. With a tai trace_clock in place, it becomes
    very convenient to correlate network activity with Linux kernel application
    traces.
    
    Use the same implementation as ktime_get_boot_fast_ns() does by reading the
    monotonic time and adding the TAI offset. The same limitations as for the fast
    boot implementation apply. The TAI offset may change at run time e.g., by
    setting the time or using adjtimex() with an offset. However, these kind of
    offset changes are rare events. Nevertheless, the user has to be aware and deal
    with it in post processing.
    
    An alternative approach would be to use the same implementation as
    ktime_get_real_fast_ns() does. However, this requires to add an additional u64
    member to the tk_read_base struct. This struct together with a seqcount is
    designed to fit into a single cache line on 64 bit architectures. Adding a new
    member would violate this constraint.
    
    Signed-off-by: Kurt Kanzenbach <kurt@linutronix.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Link: https://lore.kernel.org/r/20220414091805.89667-2-kurt@linutronix.de

commit 7180d3937acaac23eb504af24a2cc942a3b4827f
Author: Jonathan Lemon <jonathan.lemon@gmail.com>
Date:   Mon Feb 28 12:39:57 2022 -0800

    ptp: ocp: Add ptp_ocp_adjtime_coarse for large adjustments
    
    [ Upstream commit 90f8f4c0e3cebd541deaa45cf0e470bb9810dd4f ]
    
    In ("ptp: ocp: Have FPGA fold in ns adjustment for adjtime."), the
    ns adjustment was written to the FPGA register, so the clock could
    accurately perform adjustments.
    
    However, the adjtime() call passes in a s64, while the clock adjustment
    registers use a s32.  When trying to perform adjustments with a large
    value (37 sec), things fail.
    
    Examine the incoming delta, and if larger than 1 sec, use the original
    (coarse) adjustment method.  If smaller than 1 sec, then allow the
    FPGA to fold in the changes over a 1 second window.
    
    Fixes: 6d59d4fa1789 ("ptp: ocp: Have FPGA fold in ns adjustment for adjtime.")
    Signed-off-by: Jonathan Lemon <jonathan.lemon@gmail.com>
    Acked-by: Richard Cochran <richardcochran@gmail.com>
    Link: https://lore.kernel.org/r/20220228203957.367371-1-jonathan.lemon@gmail.com
    Signed-off-by: Jakub Kicinski <kuba@kernel.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit b949c21fc23ecaccef89582f251e6281cad1f81e
Merge: e58bd49da6eb 2d3916f31891
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Mar 3 11:10:56 2022 -0800

    Merge tag 'net-5.17-rc7' of git://git.kernel.org/pub/scm/linux/kernel/git/netdev/net
    
    Pull networking fixes from Jakub Kicinski:
     "Including fixes from can, xfrm, wifi, bluetooth, and netfilter.
    
      Lots of various size fixes, the length of the tag speaks for itself.
      Most of the 5.17-relevant stuff comes from xfrm, wifi and bt trees
      which had been lagging as you pointed out previously. But there's also
      a larger than we'd like portion of fixes for bugs from previous
      releases.
    
      Three more fixes still under discussion, including and xfrm revert for
      uAPI error.
    
      Current release - regressions:
    
       - iwlwifi: don't advertise TWT support, prevent FW crash
    
       - xfrm: fix the if_id check in changelink
    
       - xen/netfront: destroy queues before real_num_tx_queues is zeroed
    
       - bluetooth: fix not checking MGMT cmd pending queue, make scanning
         work again
    
      Current release - new code bugs:
    
       - mptcp: make SIOCOUTQ accurate for fallback socket
    
       - bluetooth: access skb->len after null check
    
       - bluetooth: hci_sync: fix not using conn_timeout
    
       - smc: fix cleanup when register ULP fails
    
       - dsa: restore error path of dsa_tree_change_tag_proto
    
       - iwlwifi: fix build error for IWLMEI
    
       - iwlwifi: mvm: propagate error from request_ownership to the user
    
      Previous releases - regressions:
    
       - xfrm: fix pMTU regression when reported pMTU is too small
    
       - xfrm: fix TCP MSS calculation when pMTU is close to 1280
    
       - bluetooth: fix bt_skb_sendmmsg not allocating partial chunks
    
       - ipv6: ensure we call ipv6_mc_down() at most once, prevent leaks
    
       - ipv6: prevent leaks in igmp6 when input queues get full
    
       - fix up skbs delta_truesize in UDP GRO frag_list
    
       - eth: e1000e: fix possible HW unit hang after an s0ix exit
    
       - eth: e1000e: correct NVM checksum verification flow
    
       - ptp: ocp: fix large time adjustments
    
      Previous releases - always broken:
    
       - tcp: make tcp_read_sock() more robust in presence of urgent data
    
       - xfrm: distinguishing SAs and SPs by if_id in xfrm_migrate
    
       - xfrm: fix xfrm_migrate issues when address family changes
    
       - dcb: flush lingering app table entries for unregistered devices
    
       - smc: fix unexpected SMC_CLC_DECL_ERR_REGRMB error
    
       - mac80211: fix EAPoL rekey fail in 802.3 rx path
    
       - mac80211: fix forwarded mesh frames AC & queue selection
    
       - netfilter: nf_queue: fix socket access races and bugs
    
       - batman-adv: fix ToCToU iflink problems and check the result belongs
         to the expected net namespace
    
       - can: gs_usb, etas_es58x: fix opened_channel_cnt's accounting
    
       - can: rcar_canfd: register the CAN device when fully ready
    
       - eth: igb, igc: phy: drop premature return leaking HW semaphore
    
       - eth: ixgbe: xsk: change !netif_carrier_ok() handling in
         ixgbe_xmit_zc(), prevent live lock when link goes down
    
       - eth: stmmac: only enable DMA interrupts when ready
    
       - eth: sparx5: move vlan checks before any changes are made
    
       - eth: iavf: fix races around init, removal, resets and vlan ops
    
       - ibmvnic: more reset flow fixes
    
      Misc:
    
       - eth: fix return value of __setup handlers"
    
    * tag 'net-5.17-rc7' of git://git.kernel.org/pub/scm/linux/kernel/git/netdev/net: (92 commits)
      ipv6: fix skb drops in igmp6_event_query() and igmp6_event_report()
      net: dsa: make dsa_tree_change_tag_proto actually unwind the tag proto change
      ixgbe: xsk: change !netif_carrier_ok() handling in ixgbe_xmit_zc()
      selftests: mlxsw: resource_scale: Fix return value
      selftests: mlxsw: tc_police_scale: Make test more robust
      net: dcb: disable softirqs in dcbnl_flush_dev()
      bnx2: Fix an error message
      sfc: extend the locking on mcdi->seqno
      net/smc: fix unexpected SMC_CLC_DECL_ERR_REGRMB error cause by server
      net/smc: fix unexpected SMC_CLC_DECL_ERR_REGRMB error generated by client
      net: arcnet: com20020: Fix null-ptr-deref in com20020pci_probe()
      tcp: make tcp_read_sock() more robust
      bpf, sockmap: Do not ignore orig_len parameter
      net: ipa: add an interconnect dependency
      net: fix up skbs delta_truesize in UDP GRO frag_list
      iwlwifi: mvm: return value for request_ownership
      nl80211: Update bss channel on channel switch for P2P_CLIENT
      iwlwifi: fix build error for IWLMEI
      ptp: ocp: Add ptp_ocp_adjtime_coarse for large adjustments
      batman-adv: Don't expect inter-netns unique iflink indices
      ...

commit 90f8f4c0e3cebd541deaa45cf0e470bb9810dd4f
Author: Jonathan Lemon <jonathan.lemon@gmail.com>
Date:   Mon Feb 28 12:39:57 2022 -0800

    ptp: ocp: Add ptp_ocp_adjtime_coarse for large adjustments
    
    In ("ptp: ocp: Have FPGA fold in ns adjustment for adjtime."), the
    ns adjustment was written to the FPGA register, so the clock could
    accurately perform adjustments.
    
    However, the adjtime() call passes in a s64, while the clock adjustment
    registers use a s32.  When trying to perform adjustments with a large
    value (37 sec), things fail.
    
    Examine the incoming delta, and if larger than 1 sec, use the original
    (coarse) adjustment method.  If smaller than 1 sec, then allow the
    FPGA to fold in the changes over a 1 second window.
    
    Fixes: 6d59d4fa1789 ("ptp: ocp: Have FPGA fold in ns adjustment for adjtime.")
    Signed-off-by: Jonathan Lemon <jonathan.lemon@gmail.com>
    Acked-by: Richard Cochran <richardcochran@gmail.com>
    Link: https://lore.kernel.org/r/20220228203957.367371-1-jonathan.lemon@gmail.com
    Signed-off-by: Jakub Kicinski <kuba@kernel.org>

commit 6f5173c87a5302ce66e6714a95fa06f72a849146
Author: Tom Rix <trix@redhat.com>
Date:   Mon Feb 14 06:33:27 2022 -0800

    ice: check the return of ice_ptp_gettimex64
    
    commit ed22d9c8d128293fc7b0b086c7d3654bcb99a8dd upstream.
    
    Clang static analysis reports this issue
    time64.h:69:50: warning: The left operand of '+'
      is a garbage value
      set_normalized_timespec64(&ts_delta, lhs.tv_sec + rhs.tv_sec,
                                           ~~~~~~~~~~ ^
    In ice_ptp_adjtime_nonatomic(), the timespec64 variable 'now'
    is set by ice_ptp_gettimex64().  This function can fail
    with -EBUSY, so 'now' can have a gargbage value.
    So check the return.
    
    Fixes: 06c16d89d2cb ("ice: register 1588 PTP clock device object for E810 devices")
    Signed-off-by: Tom Rix <trix@redhat.com>
    Tested-by: Gurucharan G <gurucharanx.g@intel.com> (A Contingent worker at Intel)
    Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit b3615ea66b913f8a0f767af9e3662b9e8d882c80
Author: Tom Rix <trix@redhat.com>
Date:   Mon Feb 14 06:33:27 2022 -0800

    ice: check the return of ice_ptp_gettimex64
    
    commit ed22d9c8d128293fc7b0b086c7d3654bcb99a8dd upstream.
    
    Clang static analysis reports this issue
    time64.h:69:50: warning: The left operand of '+'
      is a garbage value
      set_normalized_timespec64(&ts_delta, lhs.tv_sec + rhs.tv_sec,
                                           ~~~~~~~~~~ ^
    In ice_ptp_adjtime_nonatomic(), the timespec64 variable 'now'
    is set by ice_ptp_gettimex64().  This function can fail
    with -EBUSY, so 'now' can have a gargbage value.
    So check the return.
    
    Fixes: 06c16d89d2cb ("ice: register 1588 PTP clock device object for E810 devices")
    Signed-off-by: Tom Rix <trix@redhat.com>
    Tested-by: Gurucharan G <gurucharanx.g@intel.com> (A Contingent worker at Intel)
    Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit ed22d9c8d128293fc7b0b086c7d3654bcb99a8dd
Author: Tom Rix <trix@redhat.com>
Date:   Mon Feb 14 06:33:27 2022 -0800

    ice: check the return of ice_ptp_gettimex64
    
    Clang static analysis reports this issue
    time64.h:69:50: warning: The left operand of '+'
      is a garbage value
      set_normalized_timespec64(&ts_delta, lhs.tv_sec + rhs.tv_sec,
                                           ~~~~~~~~~~ ^
    In ice_ptp_adjtime_nonatomic(), the timespec64 variable 'now'
    is set by ice_ptp_gettimex64().  This function can fail
    with -EBUSY, so 'now' can have a gargbage value.
    So check the return.
    
    Fixes: 06c16d89d2cb ("ice: register 1588 PTP clock device object for E810 devices")
    Signed-off-by: Tom Rix <trix@redhat.com>
    Tested-by: Gurucharan G <gurucharanx.g@intel.com> (A Contingent worker at Intel)
    Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>

commit e7b0afb69083ff7199dec51e7b9b1646e799943b
Author: Pavan Chebbi <pavan.chebbi@broadcom.com>
Date:   Tue Jan 25 23:40:12 2022 -0500

    bnxt_en: Implement .adjtime() for PTP RTC mode
    
    The adjusted time is set in the PHC in RTC mode.  We also need to
    update the snapshots ptp->current_time and ptp->old_time when the
    time is adjusted.
    
    Cc: Richard Cochran <richardcochran@gmail.com>
    Reviewed-by: Somnath Kotur <somnath.kotur@broadcom.com>
    Signed-off-by: Pavan Chebbi <pavan.chebbi@broadcom.com>
    Signed-off-by: Michael Chan <michael.chan@broadcom.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 6d59d4fa1789e0ca51dc33494376272a61b80104
Author: Jonathan Lemon <jonathan.lemon@gmail.com>
Date:   Tue Sep 14 19:16:34 2021 -0700

    ptp: ocp: Have FPGA fold in ns adjustment for adjtime.
    
    The current implementation of adjtime uses gettime/settime to
    perform nanosecond adjustments.  This introduces addtional phase
    errors due to delays.
    
    Instead, use the FPGA's ability to just apply the nanosecond
    adjustment to the clock directly.
    
    Signed-off-by: Jonathan Lemon <jonathan.lemon@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 528521f72b8f615e0930ba4b07d508ec73b07837
Author: Lukas Hannen <lukas.hannen@opensource.tttech-industrial.com>
Date:   Wed Aug 25 10:12:43 2021 +0000

    time: Handle negative seconds correctly in timespec64_to_ns()
    
    commit 39ff83f2f6cc5cc1458dfcea9697f96338210beb upstream.
    
    timespec64_ns() prevents multiplication overflows by comparing the seconds
    value of the timespec to KTIME_SEC_MAX. If the value is greater or equal it
    returns KTIME_MAX.
    
    But that check casts the signed seconds value to unsigned which makes the
    comparision true for all negative values and therefore return wrongly
    KTIME_MAX.
    
    Negative second values are perfectly valid and required in some places,
    e.g. ptp_clock_adjtime().
    
    Remove the cast and add a check for the negative boundary which is required
    to prevent undefined behaviour due to multiplication underflow.
    
    Fixes: cb47755725da ("time: Prevent undefined behaviour in timespec64_to_ns()")'
    Signed-off-by: Lukas Hannen <lukas.hannen@opensource.tttech-industrial.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/AM6PR01MB541637BD6F336B8FFB72AF80EEC69@AM6PR01MB5416.eurprd01.prod.exchangelabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 6fc340fa7942890046d1b38de8a13b93768c845b
Author: Lukas Hannen <lukas.hannen@opensource.tttech-industrial.com>
Date:   Wed Aug 25 10:12:43 2021 +0000

    time: Handle negative seconds correctly in timespec64_to_ns()
    
    commit 39ff83f2f6cc5cc1458dfcea9697f96338210beb upstream.
    
    timespec64_ns() prevents multiplication overflows by comparing the seconds
    value of the timespec to KTIME_SEC_MAX. If the value is greater or equal it
    returns KTIME_MAX.
    
    But that check casts the signed seconds value to unsigned which makes the
    comparision true for all negative values and therefore return wrongly
    KTIME_MAX.
    
    Negative second values are perfectly valid and required in some places,
    e.g. ptp_clock_adjtime().
    
    Remove the cast and add a check for the negative boundary which is required
    to prevent undefined behaviour due to multiplication underflow.
    
    Fixes: cb47755725da ("time: Prevent undefined behaviour in timespec64_to_ns()")'
    Signed-off-by: Lukas Hannen <lukas.hannen@opensource.tttech-industrial.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/AM6PR01MB541637BD6F336B8FFB72AF80EEC69@AM6PR01MB5416.eurprd01.prod.exchangelabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 656f343d724b45295f73000eb6e7bd3d212af116
Author: Lukas Hannen <lukas.hannen@opensource.tttech-industrial.com>
Date:   Wed Aug 25 10:12:43 2021 +0000

    time: Handle negative seconds correctly in timespec64_to_ns()
    
    commit 39ff83f2f6cc5cc1458dfcea9697f96338210beb upstream.
    
    timespec64_ns() prevents multiplication overflows by comparing the seconds
    value of the timespec to KTIME_SEC_MAX. If the value is greater or equal it
    returns KTIME_MAX.
    
    But that check casts the signed seconds value to unsigned which makes the
    comparision true for all negative values and therefore return wrongly
    KTIME_MAX.
    
    Negative second values are perfectly valid and required in some places,
    e.g. ptp_clock_adjtime().
    
    Remove the cast and add a check for the negative boundary which is required
    to prevent undefined behaviour due to multiplication underflow.
    
    Fixes: cb47755725da ("time: Prevent undefined behaviour in timespec64_to_ns()")'
    Signed-off-by: Lukas Hannen <lukas.hannen@opensource.tttech-industrial.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/AM6PR01MB541637BD6F336B8FFB72AF80EEC69@AM6PR01MB5416.eurprd01.prod.exchangelabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 7a25a0a94c8b49759582ac6141c06af4f3e8ae8f
Author: Lukas Hannen <lukas.hannen@opensource.tttech-industrial.com>
Date:   Wed Aug 25 10:12:43 2021 +0000

    time: Handle negative seconds correctly in timespec64_to_ns()
    
    commit 39ff83f2f6cc5cc1458dfcea9697f96338210beb upstream.
    
    timespec64_ns() prevents multiplication overflows by comparing the seconds
    value of the timespec to KTIME_SEC_MAX. If the value is greater or equal it
    returns KTIME_MAX.
    
    But that check casts the signed seconds value to unsigned which makes the
    comparision true for all negative values and therefore return wrongly
    KTIME_MAX.
    
    Negative second values are perfectly valid and required in some places,
    e.g. ptp_clock_adjtime().
    
    Remove the cast and add a check for the negative boundary which is required
    to prevent undefined behaviour due to multiplication underflow.
    
    Fixes: cb47755725da ("time: Prevent undefined behaviour in timespec64_to_ns()")'
    Signed-off-by: Lukas Hannen <lukas.hannen@opensource.tttech-industrial.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/AM6PR01MB541637BD6F336B8FFB72AF80EEC69@AM6PR01MB5416.eurprd01.prod.exchangelabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 39ff83f2f6cc5cc1458dfcea9697f96338210beb
Author: Lukas Hannen <lukas.hannen@opensource.tttech-industrial.com>
Date:   Wed Aug 25 10:12:43 2021 +0000

    time: Handle negative seconds correctly in timespec64_to_ns()
    
    timespec64_ns() prevents multiplication overflows by comparing the seconds
    value of the timespec to KTIME_SEC_MAX. If the value is greater or equal it
    returns KTIME_MAX.
    
    But that check casts the signed seconds value to unsigned which makes the
    comparision true for all negative values and therefore return wrongly
    KTIME_MAX.
    
    Negative second values are perfectly valid and required in some places,
    e.g. ptp_clock_adjtime().
    
    Remove the cast and add a check for the negative boundary which is required
    to prevent undefined behaviour due to multiplication underflow.
    
    Fixes: cb47755725da ("time: Prevent undefined behaviour in timespec64_to_ns()")'
    Signed-off-by: Lukas Hannen <lukas.hannen@opensource.tttech-industrial.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/AM6PR01MB541637BD6F336B8FFB72AF80EEC69@AM6PR01MB5416.eurprd01.prod.exchangelabs.com

commit 1b267793f4fd9a089ea8558f3b6698186b9a3214
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jul 13 15:39:52 2021 +0200

    time/timekeeping: Avoid invoking clock_was_set() twice
    
    do_adjtimex() might end up scheduling a delayed clock_was_set() via
    timekeeping_advance() and then invoke clock_was_set() directly which is
    pointless.
    
    Make timekeeping_advance() return whether an invocation of clock_was_set()
    is required and handle it at the call sites which allows do_adjtimex() to
    issue a single direct call if required.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lore.kernel.org/r/20210713135158.580966888@linutronix.de

commit d5882a92ea7974edb83a0cf6bbe35c31263464ac
Author: Masami Hiramatsu <mhriamat@kernel.org>
Date:   Sun Jul 4 00:35:34 2021 +0900

    perf probe: Do not show @plt function by default
    
    Fix the perf-probe --functions option do not show the PLT
    stub symbols (*@plt) by default.
    
      -----
      $ ./perf probe -x /usr/lib64/libc-2.33.so -F | head
      a64l
      abort
      abs
      accept
      accept4
      access
      acct
      addmntent
      addseverity
      adjtime
      -----
    
    Reported-by: Thomas Richter <tmricht@linux.ibm.com>
    Signed-off-by: Masami Hiramatsu <mhriamat@kernel.org>
    Acked-by: Thomas Richter <tmricht@linux.ibm.com>
    Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Heiko Carstens <hca@linux.ibm.com>
    Cc: Masami Hiramatsu <mhiramat@kernel.org>
    Cc: Stefan Liebler <stli@linux.ibm.com>
    Cc: Sven Schnelle <svens@linux.ibm.com>
    Link: http://lore.kernel.org/lkml/162532653450.393143.12621329879630677469.stgit@devnote2
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

commit 1a852780d9d93378ae4f7d7d57213bc114c6873f
Author: Chen Jun <chenjun102@huawei.com>
Date:   Wed Apr 14 03:04:49 2021 +0000

    posix-timers: Preserve return value in clock_adjtime32()
    
    commit 2d036dfa5f10df9782f5278fc591d79d283c1fad upstream.
    
    The return value on success (>= 0) is overwritten by the return value of
    put_old_timex32(). That works correct in the fault case, but is wrong for
    the success case where put_old_timex32() returns 0.
    
    Just check the return value of put_old_timex32() and return -EFAULT in case
    it is not zero.
    
    [ tglx: Massage changelog ]
    
    Fixes: 3a4d44b61625 ("ntp: Move adjtimex related compat syscalls to native counterparts")
    Signed-off-by: Chen Jun <chenjun102@huawei.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Richard Cochran <richardcochran@gmail.com>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/20210414030449.90692-1-chenjun102@huawei.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 9fbf44e7dff41827bc4c889c392af07d1e726fe8
Author: Chen Jun <chenjun102@huawei.com>
Date:   Wed Apr 14 03:04:49 2021 +0000

    posix-timers: Preserve return value in clock_adjtime32()
    
    commit 2d036dfa5f10df9782f5278fc591d79d283c1fad upstream.
    
    The return value on success (>= 0) is overwritten by the return value of
    put_old_timex32(). That works correct in the fault case, but is wrong for
    the success case where put_old_timex32() returns 0.
    
    Just check the return value of put_old_timex32() and return -EFAULT in case
    it is not zero.
    
    [ tglx: Massage changelog ]
    
    Fixes: 3a4d44b61625 ("ntp: Move adjtimex related compat syscalls to native counterparts")
    Signed-off-by: Chen Jun <chenjun102@huawei.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Richard Cochran <richardcochran@gmail.com>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/20210414030449.90692-1-chenjun102@huawei.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 2cf62247f25903afe560f3acee7f590908fec171
Author: Chen Jun <chenjun102@huawei.com>
Date:   Wed Apr 14 03:04:49 2021 +0000

    posix-timers: Preserve return value in clock_adjtime32()
    
    commit 2d036dfa5f10df9782f5278fc591d79d283c1fad upstream.
    
    The return value on success (>= 0) is overwritten by the return value of
    put_old_timex32(). That works correct in the fault case, but is wrong for
    the success case where put_old_timex32() returns 0.
    
    Just check the return value of put_old_timex32() and return -EFAULT in case
    it is not zero.
    
    [ tglx: Massage changelog ]
    
    Fixes: 3a4d44b61625 ("ntp: Move adjtimex related compat syscalls to native counterparts")
    Signed-off-by: Chen Jun <chenjun102@huawei.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Richard Cochran <richardcochran@gmail.com>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/20210414030449.90692-1-chenjun102@huawei.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit c1b763436b0071c15206a661d79219e23bc45335
Author: Chen Jun <chenjun102@huawei.com>
Date:   Wed Apr 14 03:04:49 2021 +0000

    posix-timers: Preserve return value in clock_adjtime32()
    
    commit 2d036dfa5f10df9782f5278fc591d79d283c1fad upstream.
    
    The return value on success (>= 0) is overwritten by the return value of
    put_old_timex32(). That works correct in the fault case, but is wrong for
    the success case where put_old_timex32() returns 0.
    
    Just check the return value of put_old_timex32() and return -EFAULT in case
    it is not zero.
    
    [ tglx: Massage changelog ]
    
    Fixes: 3a4d44b61625 ("ntp: Move adjtimex related compat syscalls to native counterparts")
    Signed-off-by: Chen Jun <chenjun102@huawei.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Richard Cochran <richardcochran@gmail.com>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/20210414030449.90692-1-chenjun102@huawei.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit af830b27c34d733a0905319097894451c254bc43
Author: Chen Jun <chenjun102@huawei.com>
Date:   Wed Apr 14 03:04:49 2021 +0000

    posix-timers: Preserve return value in clock_adjtime32()
    
    commit 2d036dfa5f10df9782f5278fc591d79d283c1fad upstream.
    
    The return value on success (>= 0) is overwritten by the return value of
    put_old_timex32(). That works correct in the fault case, but is wrong for
    the success case where put_old_timex32() returns 0.
    
    Just check the return value of put_old_timex32() and return -EFAULT in case
    it is not zero.
    
    [ tglx: Massage changelog ]
    
    Fixes: 3a4d44b61625 ("ntp: Move adjtimex related compat syscalls to native counterparts")
    Signed-off-by: Chen Jun <chenjun102@huawei.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Richard Cochran <richardcochran@gmail.com>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/20210414030449.90692-1-chenjun102@huawei.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 1c5cb86cdd7fd379f9f5ef70a494fee28394a4ae
Author: Chen Jun <chenjun102@huawei.com>
Date:   Wed Apr 14 03:04:49 2021 +0000

    posix-timers: Preserve return value in clock_adjtime32()
    
    commit 2d036dfa5f10df9782f5278fc591d79d283c1fad upstream.
    
    The return value on success (>= 0) is overwritten by the return value of
    put_old_timex32(). That works correct in the fault case, but is wrong for
    the success case where put_old_timex32() returns 0.
    
    Just check the return value of put_old_timex32() and return -EFAULT in case
    it is not zero.
    
    [ tglx: Massage changelog ]
    
    Fixes: 3a4d44b61625 ("ntp: Move adjtimex related compat syscalls to native counterparts")
    Signed-off-by: Chen Jun <chenjun102@huawei.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Richard Cochran <richardcochran@gmail.com>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/20210414030449.90692-1-chenjun102@huawei.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 27d64141949e92c04d95d99f215b7f5b261bd8b1
Merge: 532062b09956 514def5dd339
Author: David S. Miller <davem@davemloft.net>
Date:   Mon May 10 14:54:23 2021 -0700

    Merge branch 'ytja1103-ptp'
    
    Radu Pirea says:
    
    ====================
    Add PTP support for TJA1103
    
    This is the PTP support for TJA1103.
    The RX timestamp is found in the reserved2 field of the PTP package.
    The TX timestamp has to be read from the phy registers. Reading of the
    timestamp works with interrupts or with polling(that starts when
    .nxp_c45_txtstamp is called).
    The implementation of .adjtime is done by read modify write because there
    is no way to atomically add/subtract a constant from the clock value.
    
    I've moved scaled_ppm_to_ppb function from ptp_clock.c to
    ptp_clock_kernel.h in  order to be able to build the driver without
    PTP_1588_CLOCK=y.
    ====================
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 87dcebff9262330ceffad8f1732f29fd35feab5a
Merge: 91552ab8ffb8 2d036dfa5f10
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Apr 26 09:54:03 2021 -0700

    Merge tag 'timers-core-2021-04-26' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer updates from Thomas Gleixner:
     "The time and timers updates contain:
    
      Core changes:
    
       - Allow runtime power management when the clocksource is changed.
    
       - A correctness fix for clock_adjtime32() so that the return value on
         success is not overwritten by the result of the copy to user.
    
       - Allow late installment of broadcast clockevent devices which was
         broken because nothing switched them over to oneshot mode. This
         went unnoticed so far because clockevent devices used to be built
         in, but now people started to make them modular.
    
       - Debugfs related simplifications
    
       - Small cleanups and improvements here and there
    
      Driver changes:
    
       - The usual set of device tree binding updates for a wide range of
         drivers/devices.
    
       - The usual updates and improvements for drivers all over the place
         but nothing outstanding.
    
       - No new clocksource/event drivers. They'll come back next time"
    
    * tag 'timers-core-2021-04-26' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (24 commits)
      posix-timers: Preserve return value in clock_adjtime32()
      tick/broadcast: Allow late registered device to enter oneshot mode
      tick: Use tick_check_replacement() instead of open coding it
      time/timecounter: Mark 1st argument of timecounter_cyc2time() as const
      dt-bindings: timer: nuvoton,npcm7xx: Add wpcm450-timer
      clocksource/drivers/arm_arch_timer: Add __ro_after_init and __init
      clocksource/drivers/timer-ti-dm: Handle dra7 timer wrap errata i940
      clocksource/drivers/timer-ti-dm: Prepare to handle dra7 timer wrap issue
      clocksource/drivers/dw_apb_timer_of: Add handling for potential memory leak
      clocksource/drivers/npcm: Add support for WPCM450
      clocksource/drivers/sh_cmt: Don't use CMTOUT_IE with R-Car Gen2/3
      clocksource/drivers/pistachio: Fix trivial typo
      clocksource/drivers/ingenic_ost: Fix return value check in ingenic_ost_probe()
      clocksource/drivers/timer-ti-dm: Add missing set_state_oneshot_stopped
      clocksource/drivers/timer-ti-dm: Fix posted mode status check order
      dt-bindings: timer: renesas,cmt: Document R8A77961
      dt-bindings: timer: renesas,cmt: Add r8a779a0 CMT support
      clocksource/drivers/ingenic-ost: Add support for the JZ4760B
      clocksource/drivers/ingenic: Add support for the JZ4760
      dt-bindings: timer: ingenic: Add compatible strings for JZ4760(B)
      ...

commit 2d036dfa5f10df9782f5278fc591d79d283c1fad
Author: Chen Jun <chenjun102@huawei.com>
Date:   Wed Apr 14 03:04:49 2021 +0000

    posix-timers: Preserve return value in clock_adjtime32()
    
    The return value on success (>= 0) is overwritten by the return value of
    put_old_timex32(). That works correct in the fault case, but is wrong for
    the success case where put_old_timex32() returns 0.
    
    Just check the return value of put_old_timex32() and return -EFAULT in case
    it is not zero.
    
    [ tglx: Massage changelog ]
    
    Fixes: 3a4d44b61625 ("ntp: Move adjtimex related compat syscalls to native counterparts")
    Signed-off-by: Chen Jun <chenjun102@huawei.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Richard Cochran <richardcochran@gmail.com>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/20210414030449.90692-1-chenjun102@huawei.com

commit 432119de33d9013467371fc85238d623f64ff67e
Author: Aya Levin <ayal@nvidia.com>
Date:   Fri Feb 12 14:30:42 2021 -0800

    net/mlx5: Add cyc2time HW translation mode support
    
    Device timestamp can be in real time mode (cycles to time translation is
    offloaded into the Hardware). With real time mode, HW provides timestamp
    which is already translated into nanoseconds.
    
    With this mode, driver adjusts both the HW and timecounter (to keep
    clock_info_page updated) using callbacks: adjfreq, adjtime and settime.
    HW clock modifications are done via MTUTC access reg commands. Driver is
    allowed to modify HW real time clock only if MCAM ptpcyc2realtime_modify
    capability is set.
    
    Add MTUTC set function to be used for configuring the HW real time
    clock. Modify existing code to support both internal timer (with
    conversion via timecounter_cyc2time() and real time (no conversions).
    
    Align the signatures of the helpers converting from timestamp to
    nanoseconds. With that, when allocating a queue assign the corresponding
    callback with respect to the capability.
    
    Adjust 1PPS timestamp calculation flows based on the timestamp mode.
    
    Cyc2time offload brings two major advantages:
    - Improve MTAE (Max Time Absolute Error) for HW TS by up to 160 ns over a
      100% loaded CPU.
    - Faster data-path timestamp to nanoseconds, as translation is
      lock-less and done in HW.
    
    On real time mode, timestamp format is 32 high bits of seconds and 32
    low bits of nanoseconds. On some flows, driver shall convert this format
    into nanoseconds wall-clock with REAL_TIME_TO_NS macro.
    
    HW supports a single clock, and it is shared by all functions on a
    device. In case real time clock is used, it is recommended to use
    a single GM to all device's functions.
    
    Signed-off-by: Eran Ben Elisha <eranbe@mellanox.com>
    Signed-off-by: Aya Levin <ayal@nvidia.com>
    Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>

commit c9e6189fb03123a7dfb93589280347b46f30b161
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun Dec 6 22:46:18 2020 +0100

    ntp: Make the RTC synchronization more reliable
    
    Miroslav reported that the periodic RTC synchronization in the NTP code
    fails more often than not to hit the specified update window.
    
    The reason is that the code uses delayed_work to schedule the update which
    needs to be in thread context as the underlying RTC might be connected via
    a slow bus, e.g. I2C. In the update function it verifies whether the
    current time is correct vs. the requirements of the underlying RTC.
    
    But delayed_work is using the timer wheel for scheduling which is
    inaccurate by design. Depending on the distance to the expiry the wheel
    gets less granular to allow batching and to avoid the cascading of the
    original timer wheel. See 500462a9de65 ("timers: Switch to a non-cascading
    wheel") and the code for further details.
    
    The code already deals with this by splitting the 660 seconds period into a
    long 659 seconds timer and then retrying with a smaller delta.
    
    But looking at the actual granularities of the timer wheel (which depend on
    the HZ configuration) the 659 seconds timer ends up in an outer wheel level
    and is affected by a worst case granularity of:
    
    HZ          Granularity
    1000        32s
     250        16s
     100        40s
    
    So the initial timer can be already off by max 12.5% which is not a big
    issue as the period of the sync is defined as ~11 minutes.
    
    The fine grained second attempt schedules to the desired update point with
    a timer expiring less than a second from now. Depending on the actual delta
    and the HZ setting even the second attempt can end up in outer wheel levels
    which have a large enough granularity to make the correctness check fail.
    
    As this is a fundamental property of the timer wheel there is no way to
    make this more accurate short of iterating in one jiffies steps towards the
    update point.
    
    Switch it to an hrtimer instead which schedules the actual update work. The
    hrtimer will expire precisely (max 1 jiffie delay when high resolution
    timers are not available). The actual scheduling delay of the work is the
    same as before.
    
    The update is triggered from do_adjtimex() which is a bit racy but not much
    more racy than it was before:
    
         if (ntp_synced())
            queue_delayed_work(system_power_efficient_wq, &sync_work, 0);
    
    which is racy when the work is currently executed and has not managed to
    reschedule itself.
    
    This becomes now:
    
         if (ntp_synced() && !hrtimer_is_queued(&sync_hrtimer))
            queue_work(system_power_efficient_wq, &sync_work, 0);
    
    which is racy when the hrtimer has expired and the work is currently
    executed and has not yet managed to rearm the hrtimer.
    
    Not a big problem as it just schedules work for nothing.
    
    The new implementation has a safe guard in place to catch the case where
    the hrtimer is queued on entry to the work function and avoids an extra
    update attempt of the RTC that way.
    
    Reported-by: Miroslav Lichvar <mlichvar@redhat.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Miroslav Lichvar <mlichvar@redhat.com>
    Reviewed-by: Jason Gunthorpe <jgg@nvidia.com>
    Acked-by: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Link: https://lore.kernel.org/r/20201206220542.062910520@linutronix.de

commit b2539aa0d7ff1e42c74a9dd8c73ec1c2771c9e5d
Author: Sven Schnelle <svens@linux.ibm.com>
Date:   Fri Jun 12 12:59:19 2020 +0200

    s390/stp: add support for leap seconds
    
    In the current implementation, leap seconds are only synchronized
    during the bootup process when the STP clock is synced. If the Leap
    second offset (LSO) changes the machine must be rebooted, which is
    not desired. This patch adds the required code to handle Leap second
    changes during runtime. If the Leap second changes, a Configuration
    change machine check is triggered. The STP code than schedules a Leap
    second insertion/deletion with do_adjtimex().
    
    Signed-off-by: Sven Schnelle <svens@linux.ibm.com>
    Reviewed-by: Alexander Egorenkov <egorenar@linux.ibm.com>
    Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>

commit 74c654a852fe94f7d5ea5ebc49f2ce6fd1a551e6
Author: Wang Hai <wanghai38@huawei.com>
Date:   Wed Sep 9 21:21:09 2020 +0800

    net: cavium: Fix a bunch of kerneldoc parameter issues
    
    Rename ptp to ptp_info.
    
    Fix W=1 compile warnings (invalid kerneldoc):
    
    drivers/net/ethernet/cavium/common/cavium_ptp.c:94: warning: Excess function parameter 'ptp' description in 'cavium_ptp_adjfine'
    drivers/net/ethernet/cavium/common/cavium_ptp.c:141: warning: Excess function parameter 'ptp' description in 'cavium_ptp_adjtime'
    drivers/net/ethernet/cavium/common/cavium_ptp.c:163: warning: Excess function parameter 'ptp' description in 'cavium_ptp_gettime'
    drivers/net/ethernet/cavium/common/cavium_ptp.c:185: warning: Excess function parameter 'ptp' description in 'cavium_ptp_settime'
    drivers/net/ethernet/cavium/common/cavium_ptp.c:208: warning: Excess function parameter 'ptp' description in 'cavium_ptp_enable'
    
    Reported-by: Hulk Robot <hulkci@huawei.com>
    Signed-off-by: Wang Hai <wanghai38@huawei.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 7ea5fda2b1325e17528e2648b913244c8be0bcc7
Author: Min Li <min.li.xe@renesas.com>
Date:   Tue Jul 28 16:00:30 2020 -0400

    ptp: ptp_clockmatrix: update to support 4.8.7 firmware
    
    With 4.8.7 firmware, adjtime can change delta instead of absolute time,
    which greately increases snap accuracy. PPS alignment doesn't have to
    be set for every single TOD change. Other minor changes includes:
    adding more debug logs, increasing snap accuracy for pre 4.8.7 firmware
    and supporting new tcs2bin format.
    
    Signed-off-by: Min Li <min.li.xe@renesas.com>
    Acked-by: Richard Cochran <richardcochran@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 43fde2214bfc82bf4f015350ad882f258bbde356
Author: Raju Rangoju <rajur@chelsio.com>
Date:   Tue Mar 24 17:10:00 2020 +0530

    cxgb4/ptp: pass the sign of offset delta in FW CMD
    
    [ Upstream commit 50e0d28d3808146cc19b0d5564ef4ba9e5bf3846 ]
    
    cxgb4_ptp_fineadjtime() doesn't pass the signedness of offset delta
    in FW_PTP_CMD. Fix it by passing correct sign.
    
    Signed-off-by: Raju Rangoju <rajur@chelsio.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 44dd5efc97dae0dc09ea9316597826c8b0fd1578
Merge: 59211053f099 5287be405ca2
Author: David S. Miller <davem@davemloft.net>
Date:   Tue Apr 21 15:38:34 2020 -0700

    Merge branch 'Support-programmable-pins-for-Ocelot-PTP-driver'
    
    Yangbo Lu says:
    
    ====================
    Support programmable pins for Ocelot PTP driver
    
    The Ocelot PTP clock driver had been embedded into ocelot.c driver.
    It had supported basic gettime64/settime64/adjtime/adjfine functions
    by now which were used by both Ocelot switch and Felix switch.
    
    This patch-set is to move current ptp clock code out of ocelot.c driver
    maintaining as a single ocelot_ptp.c driver, and to implement 4
    programmable pins with only PTP_PF_PEROUT function for now.
    The PTP_PF_EXTTS function will be supported in the future, and it should
    be implemented separately for Felix and Ocelot, because of different
    hardware interrupt implementation in them.
    
    Changes for v2:
            - Put PTP driver under drivers/net/ethernet/mscc/.
            - Dropped MAINTAINERS patch. Kept original maintaining.
            - Initialized PTP separately in ocelot/felix platforms.
            - Supported PPS case in programmable pin.
            - Supported disabling pin function since deadlock is fixed by Richard.
            - Returned -EBUSY if not finding pin available.
    Changes for v3:
            - Re-sent.
    ====================
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 2b49d128b3f8d8fff8972afcbc603802e5e40c6a
Author: Yangbo Lu <yangbo.lu@nxp.com>
Date:   Mon Apr 20 10:46:45 2020 +0800

    net: mscc: ocelot: move ocelot ptp clock code out of ocelot.c
    
    The Ocelot PTP clock driver had been embedded into ocelot.c driver.
    It had supported basic gettime64/settime64/adjtime/adjfine functions
    by now which were used by both Ocelot switch and Felix switch.
    
    This patch is to move current ptp clock code out of ocelot.c driver
    maintaining as a single ocelot_ptp.c.
    For futher new features implementation, the common code could be put
    in ocelot_ptp.c and the switch specific code should be in specific
    switch driver. The interrupt implementation in SoC is different
    between Ocelot and Felix.
    
    Signed-off-by: Yangbo Lu <yangbo.lu@nxp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 356d120756ccb593d8a9488db119cd289d5ccf10
Author: Raju Rangoju <rajur@chelsio.com>
Date:   Tue Mar 24 17:10:00 2020 +0530

    cxgb4/ptp: pass the sign of offset delta in FW CMD
    
    [ Upstream commit 50e0d28d3808146cc19b0d5564ef4ba9e5bf3846 ]
    
    cxgb4_ptp_fineadjtime() doesn't pass the signedness of offset delta
    in FW_PTP_CMD. Fix it by passing correct sign.
    
    Signed-off-by: Raju Rangoju <rajur@chelsio.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit f5429ec64f4f8583f068af04e2e00ad1b30a07f8
Author: Raju Rangoju <rajur@chelsio.com>
Date:   Tue Mar 24 17:10:00 2020 +0530

    cxgb4/ptp: pass the sign of offset delta in FW CMD
    
    [ Upstream commit 50e0d28d3808146cc19b0d5564ef4ba9e5bf3846 ]
    
    cxgb4_ptp_fineadjtime() doesn't pass the signedness of offset delta
    in FW_PTP_CMD. Fix it by passing correct sign.
    
    Signed-off-by: Raju Rangoju <rajur@chelsio.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 0c36582cf87c226f0dd07ebef3a083f4b977bdbf
Author: Raju Rangoju <rajur@chelsio.com>
Date:   Tue Mar 24 17:10:00 2020 +0530

    cxgb4/ptp: pass the sign of offset delta in FW CMD
    
    [ Upstream commit 50e0d28d3808146cc19b0d5564ef4ba9e5bf3846 ]
    
    cxgb4_ptp_fineadjtime() doesn't pass the signedness of offset delta
    in FW_PTP_CMD. Fix it by passing correct sign.
    
    Signed-off-by: Raju Rangoju <rajur@chelsio.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 50e0d28d3808146cc19b0d5564ef4ba9e5bf3846
Author: Raju Rangoju <rajur@chelsio.com>
Date:   Tue Mar 24 17:10:00 2020 +0530

    cxgb4/ptp: pass the sign of offset delta in FW CMD
    
    cxgb4_ptp_fineadjtime() doesn't pass the signedness of offset delta
    in FW_PTP_CMD. Fix it by passing correct sign.
    
    Signed-off-by: Raju Rangoju <rajur@chelsio.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 46d6b7becb1d5a8e697db786590c19e4067a975a
Merge: 545ae66582f7 11648b8339f8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Feb 2 11:50:58 2020 -0800

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/sparc
    
    Pull sparc fix from David Miller:
     "adjtimex regression fix from Arnd"
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/davem/sparc:
      sparc64: fix adjtimex regression

commit 11648b8339f840d4b1f4c54a1abec8025d9e077d
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Sat Feb 1 22:20:52 2020 +0100

    sparc64: fix adjtimex regression
    
    Anatoly Pugachev reported one of the y2038 patches to introduce
    a fatal bug from a stupid typo:
    
    [   96.384129] watchdog: BUG: soft lockup - CPU#8 stuck for 22s!
    ...
    [   96.385624]  [0000000000652ca4] handle_mm_fault+0x84/0x320
    [   96.385668]  [0000000000b6f2bc] do_sparc64_fault+0x43c/0x820
    [   96.385720]  [0000000000407754] sparc64_realfault_common+0x10/0x20
    [   96.385769]  [000000000042fa28] __do_sys_sparc_clock_adjtime+0x28/0x80
    [   96.385819]  [00000000004307f0] sys_sparc_clock_adjtime+0x10/0x20
    [   96.385866]  [0000000000406294] linux_sparc_syscall+0x34/0x44
    
    Fix the code to dereference the correct pointer again.
    
    Reported-by: Anatoly Pugachev <matorola@gmail.com>
    Tested-by: Anatoly Pugachev <matorola@gmail.com>
    Fixes: 251ec1c159e4 ("y2038: sparc: remove use of struct timex")
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 8f12f3277f06c0c8b403ac93c8a8fcd054238b5c
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Nov 8 21:34:24 2019 +0100

    ntp/y2038: Remove incorrect time_t truncation
    
    commit 2f5841349df281ecf8f81cc82d869b8476f0db0b upstream.
    
    A cast to 'time_t' was accidentally left in place during the
    conversion of __do_adjtimex() to 64-bit timestamps, so the
    resulting value is incorrectly truncated.
    
    Remove the cast so the 64-bit time gets propagated correctly.
    
    Fixes: ead25417f82e ("timex: use __kernel_timex internally")
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org
    Link: https://lkml.kernel.org/r/20191108203435.112759-2-arnd@arndb.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 3278b3b6782c562079a3e0af0979968fd94d141c
Merge: 5ffaf037e776 2f5841349df2
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Nov 16 16:08:46 2019 -0800

    Merge branch 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer fix from Ingo Molnar:
     "Fix integer truncation bug in __do_adjtimex()"
    
    * 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      ntp/y2038: Remove incorrect time_t truncation

commit 2f5841349df281ecf8f81cc82d869b8476f0db0b
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Nov 8 21:34:24 2019 +0100

    ntp/y2038: Remove incorrect time_t truncation
    
    A cast to 'time_t' was accidentally left in place during the
    conversion of __do_adjtimex() to 64-bit timestamps, so the
    resulting value is incorrectly truncated.
    
    Remove the cast so the 64-bit time gets propagated correctly.
    
    Fixes: ead25417f82e ("timex: use __kernel_timex internally")
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org
    Link: https://lkml.kernel.org/r/20191108203435.112759-2-arnd@arndb.de

commit 531716553f74c312b21b2c71a5a90b63c7b897ee
Author: Miroslav Lichvar <mlichvar@redhat.com>
Date:   Wed Apr 17 10:48:33 2019 +0200

    ntp: Allow TAI-UTC offset to be set to zero
    
    commit fdc6bae940ee9eb869e493990540098b8c0fd6ab upstream.
    
    The ADJ_TAI adjtimex mode sets the TAI-UTC offset of the system clock.
    It is typically set by NTP/PTP implementations and it is automatically
    updated by the kernel on leap seconds. The initial value is zero (which
    applications may interpret as unknown), but this value cannot be set by
    adjtimex. This limitation seems to go back to the original "nanokernel"
    implementation by David Mills.
    
    Change the ADJ_TAI check to accept zero as a valid TAI-UTC offset in
    order to allow setting it back to the initial value.
    
    Fixes: 153b5d054ac2 ("ntp: support for TAI")
    Suggested-by: Ondrej Mosnacek <omosnace@redhat.com>
    Signed-off-by: Miroslav Lichvar <mlichvar@redhat.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Link: https://lkml.kernel.org/r/20190417084833.7401-1-mlichvar@redhat.com
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit 41164dd56336bcccab95f0f0077bbbefa7891246
Author: Miroslav Lichvar <mlichvar@redhat.com>
Date:   Tue Jun 18 17:47:13 2019 +0200

    ntp: Limit TAI-UTC offset
    
    [ Upstream commit d897a4ab11dc8a9fda50d2eccc081a96a6385998 ]
    
    Don't allow the TAI-UTC offset of the system clock to be set by adjtimex()
    to a value larger than 100000 seconds.
    
    This prevents an overflow in the conversion to int, prevents the CLOCK_TAI
    clock from getting too far ahead of the CLOCK_REALTIME clock, and it is
    still large enough to allow leap seconds to be inserted at the maximum rate
    currently supported by the kernel (once per day) for the next ~270 years,
    however unlikely it is that someone can survive a catastrophic event which
    slowed down the rotation of the Earth so much.
    
    Reported-by: Weikang shi <swkhack@gmail.com>
    Signed-off-by: Miroslav Lichvar <mlichvar@redhat.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Stephen Boyd <sboyd@kernel.org>
    Link: https://lkml.kernel.org/r/20190618154713.20929-1-mlichvar@redhat.com
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 5992cebc8371cac5c1e44e64e0f2a8cbb71eb976
Author: Miroslav Lichvar <mlichvar@redhat.com>
Date:   Tue Jun 18 17:47:13 2019 +0200

    ntp: Limit TAI-UTC offset
    
    [ Upstream commit d897a4ab11dc8a9fda50d2eccc081a96a6385998 ]
    
    Don't allow the TAI-UTC offset of the system clock to be set by adjtimex()
    to a value larger than 100000 seconds.
    
    This prevents an overflow in the conversion to int, prevents the CLOCK_TAI
    clock from getting too far ahead of the CLOCK_REALTIME clock, and it is
    still large enough to allow leap seconds to be inserted at the maximum rate
    currently supported by the kernel (once per day) for the next ~270 years,
    however unlikely it is that someone can survive a catastrophic event which
    slowed down the rotation of the Earth so much.
    
    Reported-by: Weikang shi <swkhack@gmail.com>
    Signed-off-by: Miroslav Lichvar <mlichvar@redhat.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Stephen Boyd <sboyd@kernel.org>
    Link: https://lkml.kernel.org/r/20190618154713.20929-1-mlichvar@redhat.com
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit cf90753513b3e0c10096ed26175a27dc26fad4b7
Author: Miroslav Lichvar <mlichvar@redhat.com>
Date:   Tue Jun 18 17:47:13 2019 +0200

    ntp: Limit TAI-UTC offset
    
    [ Upstream commit d897a4ab11dc8a9fda50d2eccc081a96a6385998 ]
    
    Don't allow the TAI-UTC offset of the system clock to be set by adjtimex()
    to a value larger than 100000 seconds.
    
    This prevents an overflow in the conversion to int, prevents the CLOCK_TAI
    clock from getting too far ahead of the CLOCK_REALTIME clock, and it is
    still large enough to allow leap seconds to be inserted at the maximum rate
    currently supported by the kernel (once per day) for the next ~270 years,
    however unlikely it is that someone can survive a catastrophic event which
    slowed down the rotation of the Earth so much.
    
    Reported-by: Weikang shi <swkhack@gmail.com>
    Signed-off-by: Miroslav Lichvar <mlichvar@redhat.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Stephen Boyd <sboyd@kernel.org>
    Link: https://lkml.kernel.org/r/20190618154713.20929-1-mlichvar@redhat.com
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit d86c0b73f75b7732824905c7e59ed632c182bb3d
Author: Miroslav Lichvar <mlichvar@redhat.com>
Date:   Tue Jun 18 17:47:13 2019 +0200

    ntp: Limit TAI-UTC offset
    
    [ Upstream commit d897a4ab11dc8a9fda50d2eccc081a96a6385998 ]
    
    Don't allow the TAI-UTC offset of the system clock to be set by adjtimex()
    to a value larger than 100000 seconds.
    
    This prevents an overflow in the conversion to int, prevents the CLOCK_TAI
    clock from getting too far ahead of the CLOCK_REALTIME clock, and it is
    still large enough to allow leap seconds to be inserted at the maximum rate
    currently supported by the kernel (once per day) for the next ~270 years,
    however unlikely it is that someone can survive a catastrophic event which
    slowed down the rotation of the Earth so much.
    
    Reported-by: Weikang shi <swkhack@gmail.com>
    Signed-off-by: Miroslav Lichvar <mlichvar@redhat.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Stephen Boyd <sboyd@kernel.org>
    Link: https://lkml.kernel.org/r/20190618154713.20929-1-mlichvar@redhat.com
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit a0d5e56f6a05cb0ba3af8deb8df14af82a3072a9
Author: Miroslav Lichvar <mlichvar@redhat.com>
Date:   Tue Jun 18 17:47:13 2019 +0200

    ntp: Limit TAI-UTC offset
    
    [ Upstream commit d897a4ab11dc8a9fda50d2eccc081a96a6385998 ]
    
    Don't allow the TAI-UTC offset of the system clock to be set by adjtimex()
    to a value larger than 100000 seconds.
    
    This prevents an overflow in the conversion to int, prevents the CLOCK_TAI
    clock from getting too far ahead of the CLOCK_REALTIME clock, and it is
    still large enough to allow leap seconds to be inserted at the maximum rate
    currently supported by the kernel (once per day) for the next ~270 years,
    however unlikely it is that someone can survive a catastrophic event which
    slowed down the rotation of the Earth so much.
    
    Reported-by: Weikang shi <swkhack@gmail.com>
    Signed-off-by: Miroslav Lichvar <mlichvar@redhat.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Stephen Boyd <sboyd@kernel.org>
    Link: https://lkml.kernel.org/r/20190618154713.20929-1-mlichvar@redhat.com
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit b2e049098962d6fdc2d79b5bcaf816196c837e79
Author: Miroslav Lichvar <mlichvar@redhat.com>
Date:   Tue Jun 18 17:47:13 2019 +0200

    ntp: Limit TAI-UTC offset
    
    [ Upstream commit d897a4ab11dc8a9fda50d2eccc081a96a6385998 ]
    
    Don't allow the TAI-UTC offset of the system clock to be set by adjtimex()
    to a value larger than 100000 seconds.
    
    This prevents an overflow in the conversion to int, prevents the CLOCK_TAI
    clock from getting too far ahead of the CLOCK_REALTIME clock, and it is
    still large enough to allow leap seconds to be inserted at the maximum rate
    currently supported by the kernel (once per day) for the next ~270 years,
    however unlikely it is that someone can survive a catastrophic event which
    slowed down the rotation of the Earth so much.
    
    Reported-by: Weikang shi <swkhack@gmail.com>
    Signed-off-by: Miroslav Lichvar <mlichvar@redhat.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Stephen Boyd <sboyd@kernel.org>
    Link: https://lkml.kernel.org/r/20190618154713.20929-1-mlichvar@redhat.com
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 89e602ee6e82626cc74f6615950d3e5a26d7bdc9
Author: Petr Machata <petrm@mellanox.com>
Date:   Sun Jun 30 09:04:55 2019 +0300

    mlxsw: spectrum: PTP: Disable BH when working with PHC
    
    Up until now, the PTP hardware clock code was only invoked in the process
    context (SYS_clock_adjtime -> do_clock_adjtime -> k_clock::clock_adj ->
    pc_clock_adjtime -> posix_clock_operations::clock_adjtime ->
    ptp_clock_info::adjtime -> mlxsw_spectrum).
    
    In order to enable HW timestamping, which is tied into trap handling, it
    will be necessary to take the clock lock from the PCI queue handler
    tasklets as well.
    
    Therefore use the _bh variants when handling the clock lock. Incidentally,
    Documentation/ptp/ptp.txt recommends _irqsave variants, but that's
    unnecessarily strong for our needs.
    
    Signed-off-by: Petr Machata <petrm@mellanox.com>
    Acked-by: Jiri Pirko <jiri@mellanox.com>
    Signed-off-by: Ido Schimmel <idosch@mellanox.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit d897a4ab11dc8a9fda50d2eccc081a96a6385998
Author: Miroslav Lichvar <mlichvar@redhat.com>
Date:   Tue Jun 18 17:47:13 2019 +0200

    ntp: Limit TAI-UTC offset
    
    Don't allow the TAI-UTC offset of the system clock to be set by adjtimex()
    to a value larger than 100000 seconds.
    
    This prevents an overflow in the conversion to int, prevents the CLOCK_TAI
    clock from getting too far ahead of the CLOCK_REALTIME clock, and it is
    still large enough to allow leap seconds to be inserted at the maximum rate
    currently supported by the kernel (once per day) for the next ~270 years,
    however unlikely it is that someone can survive a catastrophic event which
    slowed down the rotation of the Earth so much.
    
    Reported-by: Weikang shi <swkhack@gmail.com>
    Signed-off-by: Miroslav Lichvar <mlichvar@redhat.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Stephen Boyd <sboyd@kernel.org>
    Link: https://lkml.kernel.org/r/20190618154713.20929-1-mlichvar@redhat.com

commit 90a238a8a2d2921ca9b07698a98c9140b06c89aa
Author: Miroslav Lichvar <mlichvar@redhat.com>
Date:   Wed Apr 17 10:48:33 2019 +0200

    ntp: Allow TAI-UTC offset to be set to zero
    
    [ Upstream commit fdc6bae940ee9eb869e493990540098b8c0fd6ab ]
    
    The ADJ_TAI adjtimex mode sets the TAI-UTC offset of the system clock.
    It is typically set by NTP/PTP implementations and it is automatically
    updated by the kernel on leap seconds. The initial value is zero (which
    applications may interpret as unknown), but this value cannot be set by
    adjtimex. This limitation seems to go back to the original "nanokernel"
    implementation by David Mills.
    
    Change the ADJ_TAI check to accept zero as a valid TAI-UTC offset in
    order to allow setting it back to the initial value.
    
    Fixes: 153b5d054ac2 ("ntp: support for TAI")
    Suggested-by: Ondrej Mosnacek <omosnace@redhat.com>
    Signed-off-by: Miroslav Lichvar <mlichvar@redhat.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Link: https://lkml.kernel.org/r/20190417084833.7401-1-mlichvar@redhat.com
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 5ab0886e03e48abe0ea0e8c9aabbd0ca533dafb3
Author: Miroslav Lichvar <mlichvar@redhat.com>
Date:   Wed Apr 17 10:48:33 2019 +0200

    ntp: Allow TAI-UTC offset to be set to zero
    
    [ Upstream commit fdc6bae940ee9eb869e493990540098b8c0fd6ab ]
    
    The ADJ_TAI adjtimex mode sets the TAI-UTC offset of the system clock.
    It is typically set by NTP/PTP implementations and it is automatically
    updated by the kernel on leap seconds. The initial value is zero (which
    applications may interpret as unknown), but this value cannot be set by
    adjtimex. This limitation seems to go back to the original "nanokernel"
    implementation by David Mills.
    
    Change the ADJ_TAI check to accept zero as a valid TAI-UTC offset in
    order to allow setting it back to the initial value.
    
    Fixes: 153b5d054ac2 ("ntp: support for TAI")
    Suggested-by: Ondrej Mosnacek <omosnace@redhat.com>
    Signed-off-by: Miroslav Lichvar <mlichvar@redhat.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Link: https://lkml.kernel.org/r/20190417084833.7401-1-mlichvar@redhat.com
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 4f2b302da410a5275b9a2bda4342c4b791b39bcd
Author: Miroslav Lichvar <mlichvar@redhat.com>
Date:   Wed Apr 17 10:48:33 2019 +0200

    ntp: Allow TAI-UTC offset to be set to zero
    
    [ Upstream commit fdc6bae940ee9eb869e493990540098b8c0fd6ab ]
    
    The ADJ_TAI adjtimex mode sets the TAI-UTC offset of the system clock.
    It is typically set by NTP/PTP implementations and it is automatically
    updated by the kernel on leap seconds. The initial value is zero (which
    applications may interpret as unknown), but this value cannot be set by
    adjtimex. This limitation seems to go back to the original "nanokernel"
    implementation by David Mills.
    
    Change the ADJ_TAI check to accept zero as a valid TAI-UTC offset in
    order to allow setting it back to the initial value.
    
    Fixes: 153b5d054ac2 ("ntp: support for TAI")
    Suggested-by: Ondrej Mosnacek <omosnace@redhat.com>
    Signed-off-by: Miroslav Lichvar <mlichvar@redhat.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Link: https://lkml.kernel.org/r/20190417084833.7401-1-mlichvar@redhat.com
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 0b50d08c5d854f9052e4a50769d897c6d97dc0ad
Author: Miroslav Lichvar <mlichvar@redhat.com>
Date:   Wed Apr 17 10:48:33 2019 +0200

    ntp: Allow TAI-UTC offset to be set to zero
    
    [ Upstream commit fdc6bae940ee9eb869e493990540098b8c0fd6ab ]
    
    The ADJ_TAI adjtimex mode sets the TAI-UTC offset of the system clock.
    It is typically set by NTP/PTP implementations and it is automatically
    updated by the kernel on leap seconds. The initial value is zero (which
    applications may interpret as unknown), but this value cannot be set by
    adjtimex. This limitation seems to go back to the original "nanokernel"
    implementation by David Mills.
    
    Change the ADJ_TAI check to accept zero as a valid TAI-UTC offset in
    order to allow setting it back to the initial value.
    
    Fixes: 153b5d054ac2 ("ntp: support for TAI")
    Suggested-by: Ondrej Mosnacek <omosnace@redhat.com>
    Signed-off-by: Miroslav Lichvar <mlichvar@redhat.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Link: https://lkml.kernel.org/r/20190417084833.7401-1-mlichvar@redhat.com
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 01e0054e3e0d3e00095b3999829c423a7f911363
Author: Miroslav Lichvar <mlichvar@redhat.com>
Date:   Wed Apr 17 10:48:33 2019 +0200

    ntp: Allow TAI-UTC offset to be set to zero
    
    [ Upstream commit fdc6bae940ee9eb869e493990540098b8c0fd6ab ]
    
    The ADJ_TAI adjtimex mode sets the TAI-UTC offset of the system clock.
    It is typically set by NTP/PTP implementations and it is automatically
    updated by the kernel on leap seconds. The initial value is zero (which
    applications may interpret as unknown), but this value cannot be set by
    adjtimex. This limitation seems to go back to the original "nanokernel"
    implementation by David Mills.
    
    Change the ADJ_TAI check to accept zero as a valid TAI-UTC offset in
    order to allow setting it back to the initial value.
    
    Fixes: 153b5d054ac2 ("ntp: support for TAI")
    Suggested-by: Ondrej Mosnacek <omosnace@redhat.com>
    Signed-off-by: Miroslav Lichvar <mlichvar@redhat.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Link: https://lkml.kernel.org/r/20190417084833.7401-1-mlichvar@redhat.com
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 9366211f32076a6f3265f65a4851af9af22e4403
Author: Shalom Toledo <shalomt@mellanox.com>
Date:   Tue Jun 11 18:45:12 2019 +0300

    selftests: ptp: Add Physical Hardware Clock test
    
    Test the PTP Physical Hardware Clock functionality using the "phc_ctl" (a
    part of "linuxptp").
    
    The test contains three sub-tests:
      * "settime" test
      * "adjtime" test
      * "adjfreq" test
    
    "settime" test:
      * set the PHC time to 0 seconds.
      * wait for 120.5 seconds.
      * check if PHC time equal to 120.XX seconds.
    
    "adjtime" test:
      * set the PHC time to 0 seconds.
      * adjust the time by 10 seconds.
      * check if PHC time equal to 10.XX seconds.
    
    "adjfreq" test:
      * adjust the PHC frequency to be 1% faster.
      * set the PHC time to 0 seconds.
      * wait for 100.5 seconds.
      * check if PHC time equal to 101.XX seconds.
    
    Usage:
      $ ./phc.sh /dev/ptp<X>
    
      It is possible to run a subset of the tests, for example:
        * To run only the "settime" test:
          $ TESTS="settime" ./phc.sh /dev/ptp<X>
    
    Signed-off-by: Shalom Toledo <shalomt@mellanox.com>
    Reviewed-by: Petr Machata <petrm@mellanox.com>
    Acked-by: Richard Cochran <richardcochran@gmail.com>
    Tested-by: Vladimir Oltean <olteanv@gmail.com>
    Signed-off-by: Ido Schimmel <idosch@mellanox.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit bb77f36ac21d226b8ae4311daceb983be764f746
Author: Vladimir Oltean <olteanv@gmail.com>
Date:   Sat Jun 8 15:04:34 2019 +0300

    net: dsa: sja1105: Add support for the PTP clock
    
    The design of this PHC driver is influenced by the switch's behavior
    w.r.t. timestamping.  It exposes two PTP counters, one free-running
    (PTPTSCLK) and the other offset- and frequency-corrected in hardware
    through PTPCLKVAL, PTPCLKADD and PTPCLKRATE.  The MACs can sample either
    of these for frame timestamps.
    
    However, the user manual warns that taking timestamps based on the
    corrected clock is less than useful, as the switch can deliver corrupted
    timestamps in a variety of circumstances.
    
    Therefore, this PHC uses the free-running PTPTSCLK together with a
    timecounter/cyclecounter structure that translates it into a software
    time domain.  Thus, the settime/adjtime and adjfine callbacks are
    hardware no-ops.
    
    The timestamps (introduced in a further patch) will also be translated
    to the correct time domain before being handed over to the userspace PTP
    stack.
    
    The introduction of a second set of PHC operations that operate on the
    hardware PTPCLKVAL/PTPCLKADD/PTPCLKRATE in the future is somewhat
    unavoidable, as the TTEthernet core uses the corrected PTP time domain.
    However, the free-running counter + timecounter structure combination
    will suffice for now, as the resulting timestamps yield a sub-50 ns
    synchronization offset in steady state using linuxptp.
    
    For this patch, in absence of frame timestamping, the operations of the
    switch PHC were tested by syncing it to the system time as a local slave
    clock with:
    
    phc2sys -s CLOCK_REALTIME -c swp2 -O 0 -m -S 0.01
    
    Signed-off-by: Vladimir Oltean <olteanv@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit b2c3dda6f8f06d825b9b6099f57b906c774141c0
Merge: c77ee64f8a04 fdc6bae940ee
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu May 16 11:00:20 2019 -0700

    Merge branch 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull time fixes from Ingo Molnar:
     "A TIA adjtimex interface extension, and a POSIX compliance ABI fix for
      timespec64 users"
    
    * 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      ntp: Allow TAI-UTC offset to be set to zero
      y2038: Make CONFIG_64BIT_TIME unconditional

commit fdc6bae940ee9eb869e493990540098b8c0fd6ab
Author: Miroslav Lichvar <mlichvar@redhat.com>
Date:   Wed Apr 17 10:48:33 2019 +0200

    ntp: Allow TAI-UTC offset to be set to zero
    
    The ADJ_TAI adjtimex mode sets the TAI-UTC offset of the system clock.
    It is typically set by NTP/PTP implementations and it is automatically
    updated by the kernel on leap seconds. The initial value is zero (which
    applications may interpret as unknown), but this value cannot be set by
    adjtimex. This limitation seems to go back to the original "nanokernel"
    implementation by David Mills.
    
    Change the ADJ_TAI check to accept zero as a valid TAI-UTC offset in
    order to allow setting it back to the initial value.
    
    Fixes: 153b5d054ac2 ("ntp: support for TAI")
    Suggested-by: Ondrej Mosnacek <omosnace@redhat.com>
    Signed-off-by: Miroslav Lichvar <mlichvar@redhat.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Link: https://lkml.kernel.org/r/20190417084833.7401-1-mlichvar@redhat.com

commit b95b96893c86e1f478875fe65b076753a69e1ddc
Author: Jacob Keller <jacob.e.keller@intel.com>
Date:   Mon Feb 25 11:20:05 2019 -0800

    i40e: fix i40e_ptp_adjtime when given a negative delta
    
    [ Upstream commit b3ccbbce1e455b8454d3935eb9ae0a5f18939e24 ]
    
    Commit 0ac30ce43323 ("i40e: fix up 32 bit timespec references",
    2017-07-26) claims to be cleaning up references to 32-bit timespecs.
    
    The actual contents of the commit make no sense, as it converts a call
    to timespec64_add into timespec64_add_ns. This would seem ok, if (a) the
    change was documented in the commit message, and (b) timespec64_add_ns
    supported negative numbers.
    
    timespec64_add_ns doesn't work with signed deltas, because the
    implementation is based around iter_div_u64_rem. This change resulted in
    a regression where i40e_ptp_adjtime would interpret small negative
    adjustments as large positive additions, resulting in incorrect
    behavior.
    
    This commit doesn't appear to fix anything, is not well explained, and
    introduces a bug, so lets just revert it.
    
    Reverts: 0ac30ce43323 ("i40e: fix up 32 bit timespec references", 2017-07-26)
    Signed-off-by: Jacob Keller <jacob.e.keller@intel.com>
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
    Signed-off-by: Sasha Levin (Microsoft) <sashal@kernel.org>

commit 7e8eda734d30de81d06a949c9bf9853c445ede4e
Author: Ondrej Mosnacek <omosnace@redhat.com>
Date:   Wed Apr 10 11:14:20 2019 +0200

    ntp: Audit NTP parameters adjustment
    
    Emit an audit record every time selected NTP parameters are modified
    from userspace (via adjtimex(2) or clock_adjtime(2)). These parameters
    may be used to indirectly change system clock, and thus their
    modifications should be audited.
    
    Such events will now generate records of type AUDIT_TIME_ADJNTPVAL
    containing the following fields:
      - op -- which value was adjusted:
        - offset -- corresponding to the time_offset variable
        - freq   -- corresponding to the time_freq variable
        - status -- corresponding to the time_status variable
        - adjust -- corresponding to the time_adjust variable
        - tick   -- corresponding to the tick_usec variable
        - tai    -- corresponding to the timekeeping's TAI offset
      - old -- the old value
      - new -- the new value
    
    Example records:
    
    type=TIME_ADJNTPVAL msg=audit(1530616044.507:7): op=status old=64 new=8256
    type=TIME_ADJNTPVAL msg=audit(1530616044.511:11): op=freq old=0 new=49180377088000
    
    The records of this type will be associated with the corresponding
    syscall records.
    
    An overview of parameter changes that can be done via do_adjtimex()
    (based on information from Miroslav Lichvar) and whether they are
    audited:
      __timekeeping_set_tai_offset() -- sets the offset from the
                                        International Atomic Time
                                        (AUDITED)
      NTP variables:
        time_offset -- can adjust the clock by up to 0.5 seconds per call
                       and also speed it up or slow down by up to about
                       0.05% (43 seconds per day) (AUDITED)
        time_freq -- can speed up or slow down by up to about 0.05%
                     (AUDITED)
        time_status -- can insert/delete leap seconds and it also enables/
                       disables synchronization of the hardware real-time
                       clock (AUDITED)
        time_maxerror, time_esterror -- change error estimates used to
                                        inform userspace applications
                                        (NOT AUDITED)
        time_constant -- controls the speed of the clock adjustments that
                         are made when time_offset is set (NOT AUDITED)
        time_adjust -- can temporarily speed up or slow down the clock by up
                       to 0.05% (AUDITED)
        tick_usec -- a more extreme version of time_freq; can speed up or
                     slow down the clock by up to 10% (AUDITED)
    
    Signed-off-by: Ondrej Mosnacek <omosnace@redhat.com>
    Reviewed-by: Richard Guy Briggs <rgb@redhat.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Paul Moore <paul@paul-moore.com>

commit 2d87a0674bd60d855e4008e2d84f5b23d7cb9b7d
Author: Ondrej Mosnacek <omosnace@redhat.com>
Date:   Wed Apr 10 11:14:19 2019 +0200

    timekeeping: Audit clock adjustments
    
    Emit an audit record whenever the system clock is changed (i.e. shifted
    by a non-zero offset) by a syscall from userspace. The syscalls than can
    (at the time of writing) trigger such record are:
      - settimeofday(2), stime(2), clock_settime(2) -- via
        do_settimeofday64()
      - adjtimex(2), clock_adjtime(2) -- via do_adjtimex()
    
    The new records have type AUDIT_TIME_INJOFFSET and contain the following
    fields:
      - sec -- the 'seconds' part of the offset
      - nsec -- the 'nanoseconds' part of the offset
    
    Example record (time was shifted backwards by ~15.875 seconds):
    
    type=TIME_INJOFFSET msg=audit(1530616049.652:13): sec=-16 nsec=124887145
    
    The records of this type will be associated with the corresponding
    syscall records.
    
    Signed-off-by: Ondrej Mosnacek <omosnace@redhat.com>
    Reviewed-by: Richard Guy Briggs <rgb@redhat.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    [PM: fixed a line width problem in __audit_tk_injoffset()]
    Signed-off-by: Paul Moore <paul@paul-moore.com>

commit b3ccbbce1e455b8454d3935eb9ae0a5f18939e24
Author: Jacob Keller <jacob.e.keller@intel.com>
Date:   Mon Feb 25 11:20:05 2019 -0800

    i40e: fix i40e_ptp_adjtime when given a negative delta
    
    Commit 0ac30ce43323 ("i40e: fix up 32 bit timespec references",
    2017-07-26) claims to be cleaning up references to 32-bit timespecs.
    
    The actual contents of the commit make no sense, as it converts a call
    to timespec64_add into timespec64_add_ns. This would seem ok, if (a) the
    change was documented in the commit message, and (b) timespec64_add_ns
    supported negative numbers.
    
    timespec64_add_ns doesn't work with signed deltas, because the
    implementation is based around iter_div_u64_rem. This change resulted in
    a regression where i40e_ptp_adjtime would interpret small negative
    adjustments as large positive additions, resulting in incorrect
    behavior.
    
    This commit doesn't appear to fix anything, is not well explained, and
    introduces a bug, so lets just revert it.
    
    Reverts: 0ac30ce43323 ("i40e: fix up 32 bit timespec references", 2017-07-26)
    Signed-off-by: Jacob Keller <jacob.e.keller@intel.com>
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

commit b1b988a6a035212f5ea205155c49ce449beedee8
Merge: edaed168e135 cfbe271667b7
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Mar 5 14:08:26 2019 -0800

    Merge branch 'timers-2038-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull year 2038 updates from Thomas Gleixner:
     "Another round of changes to make the kernel ready for 2038. After lots
      of preparatory work this is the first set of syscalls which are 2038
      safe:
    
        403 clock_gettime64
        404 clock_settime64
        405 clock_adjtime64
        406 clock_getres_time64
        407 clock_nanosleep_time64
        408 timer_gettime64
        409 timer_settime64
        410 timerfd_gettime64
        411 timerfd_settime64
        412 utimensat_time64
        413 pselect6_time64
        414 ppoll_time64
        416 io_pgetevents_time64
        417 recvmmsg_time64
        418 mq_timedsend_time64
        419 mq_timedreceiv_time64
        420 semtimedop_time64
        421 rt_sigtimedwait_time64
        422 futex_time64
        423 sched_rr_get_interval_time64
    
      The syscall numbers are identical all over the architectures"
    
    * 'timers-2038-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (36 commits)
      riscv: Use latest system call ABI
      checksyscalls: fix up mq_timedreceive and stat exceptions
      unicore32: Fix __ARCH_WANT_STAT64 definition
      asm-generic: Make time32 syscall numbers optional
      asm-generic: Drop getrlimit and setrlimit syscalls from default list
      32-bit userspace ABI: introduce ARCH_32BIT_OFF_T config option
      compat ABI: use non-compat openat and open_by_handle_at variants
      y2038: add 64-bit time_t syscalls to all 32-bit architectures
      y2038: rename old time and utime syscalls
      y2038: remove struct definition redirects
      y2038: use time32 syscall names on 32-bit
      syscalls: remove obsolete __IGNORE_ macros
      y2038: syscalls: rename y2038 compat syscalls
      x86/x32: use time64 versions of sigtimedwait and recvmmsg
      timex: change syscalls to use struct __kernel_timex
      timex: use __kernel_timex internally
      sparc64: add custom adjtimex/clock_adjtime functions
      time: fix sys_timer_settime prototype
      time: Add struct __kernel_timex
      time: make adjtime compat handling available for 32 bit
      ...

commit 41ea39101d6b84394fae0c12b702c4326aa71d17
Merge: fd659cc095af 48166e6ea47d
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun Feb 10 20:50:32 2019 +0100

    Merge tag 'y2038-new-syscalls' of git://git.kernel.org:/pub/scm/linux/kernel/git/arnd/playground into timers/2038
    
    Pull y2038 - time64 system calls from Arnd Bergmann:
    
    This series finally gets us to the point of having system calls with 64-bit
    time_t on all architectures, after a long time of incremental preparation
    patches.
    
    There was actually one conversion that I missed during the summer,
    i.e. Deepa's timex series, which I now updated based the 5.0-rc1 changes
    and review comments.
    
    The following system calls are now added on all 32-bit architectures using
    the same system call numbers:
    
    403 clock_gettime64
    404 clock_settime64
    405 clock_adjtime64
    406 clock_getres_time64
    407 clock_nanosleep_time64
    408 timer_gettime64
    409 timer_settime64
    410 timerfd_gettime64
    411 timerfd_settime64
    412 utimensat_time64
    413 pselect6_time64
    414 ppoll_time64
    416 io_pgetevents_time64
    417 recvmmsg_time64
    418 mq_timedsend_time64
    419 mq_timedreceiv_time64
    420 semtimedop_time64
    421 rt_sigtimedwait_time64
    422 futex_time64
    423 sched_rr_get_interval_time64
    
    Each one of these corresponds directly to an existing system call that
    includes a 'struct timespec' argument, or a structure containing a timespec
    or (in case of clock_adjtime) timeval. Not included here are new versions
    of getitimer/setitimer and getrusage/waitid, which are planned for the
    future but only needed to make a consistent API rather than for correct
    operation beyond y2038. These four system calls are based on 'timeval', and
    it has not been finally decided what the replacement kernel interface will
    use instead.
    
    So far, I have done a lot of build testing across most architectures, which
    has found a number of bugs. Runtime testing so far included testing LTP on
    32-bit ARM with the existing system calls, to ensure we do not regress for
    existing binaries, and a test with a 32-bit x86 build of LTP against a
    modified version of the musl C library that has been adapted to the new
    system call interface [3].  This library can be used for testing on all
    architectures supported by musl-1.1.21, but it is not how the support is
    getting integrated into the official musl release. Official musl support is
    planned but will require more invasive changes to the library.
    
    Link: https://lore.kernel.org/lkml/20190110162435.309262-1-arnd@arndb.de/T/
    Link: https://lore.kernel.org/lkml/20190118161835.2259170-1-arnd@arndb.de/
    Link: https://git.linaro.org/people/arnd/musl-y2038.git/ [2]

commit 3876ced476c8ec17265d1739467e726ada88b660
Author: Deepa Dinamani <deepa.kernel@gmail.com>
Date:   Mon Jul 2 22:44:22 2018 -0700

    timex: change syscalls to use struct __kernel_timex
    
    struct timex is not y2038 safe.
    Switch all the syscall apis to use y2038 safe __kernel_timex.
    
    Note that sys_adjtimex() does not have a y2038 safe solution.  C libraries
    can implement it by calling clock_adjtime(CLOCK_REALTIME, ...).
    
    Signed-off-by: Deepa Dinamani <deepa.kernel@gmail.com>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

commit 1a596398a3d75f966b75f428e992cf1f242f9a5b
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Thu Jan 3 21:12:39 2019 +0100

    sparc64: add custom adjtimex/clock_adjtime functions
    
    sparc64 is the only architecture on Linux that has a 'timeval'
    definition with a 32-bit tv_usec but a 64-bit tv_sec. This causes
    problems for sparc32 compat mode when we convert it to use the
    new __kernel_timex type that has the same layout as all other
    64-bit architectures.
    
    To avoid adding sparc64 specific code into the generic adjtimex
    implementation, this adds a wrapper in the sparc64 system call handling
    that converts the sparc64 'timex' into the new '__kernel_timex'.
    
    At this point, the two structures are defined to be identical,
    but that will change in the next step once we convert sparc32.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

commit 4d5f007eedb74d71a7bde2bff69b6a31ad8ab427
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Jan 2 13:28:47 2019 +0100

    time: make adjtime compat handling available for 32 bit
    
    We want to reuse the compat_timex handling on 32-bit architectures the
    same way we are using the compat handling for timespec when moving to
    64-bit time_t.
    
    Move all definitions related to compat_timex out of the compat code
    into the normal timekeeping code, along with a rename to old_timex32,
    corresponding to the timespec/timeval structures, and make it controlled
    by CONFIG_COMPAT_32BIT_TIME, which 32-bit architectures will then select.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

commit b12a9124eeb71d766a3e3eb594ebbb3fefc66902
Merge: 1a80dade010c e4b92b108c6c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Dec 28 12:45:04 2018 -0800

    Merge tag 'y2038-for-4.21' of ssh://gitolite.kernel.org:/pub/scm/linux/kernel/git/arnd/playground
    
    Pull y2038 updates from Arnd Bergmann:
     "More syscalls and cleanups
    
      This concludes the main part of the system call rework for 64-bit
      time_t, which has spread over most of year 2018, the last six system
      calls being
    
        - ppoll
        - pselect6
        - io_pgetevents
        - recvmmsg
        - futex
        - rt_sigtimedwait
    
      As before, nothing changes for 64-bit architectures, while 32-bit
      architectures gain another entry point that differs only in the layout
      of the timespec structure. Hopefully in the next release we can wire
      up all 22 of those system calls on all 32-bit architectures, which
      gives us a baseline version for glibc to start using them.
    
      This does not include the clock_adjtime, getrusage/waitid, and
      getitimer/setitimer system calls. I still plan to have new versions of
      those as well, but they are not required for correct operation of the
      C library since they can be emulated using the old 32-bit time_t based
      system calls.
    
      Aside from the system calls, there are also a few cleanups here,
      removing old kernel internal interfaces that have become unused after
      all references got removed. The arch/sh cleanups are part of this,
      there were posted several times over the past year without a reaction
      from the maintainers, while the corresponding changes made it into all
      other architectures"
    
    * tag 'y2038-for-4.21' of ssh://gitolite.kernel.org:/pub/scm/linux/kernel/git/arnd/playground:
      timekeeping: remove obsolete time accessors
      vfs: replace current_kernel_time64 with ktime equivalent
      timekeeping: remove timespec_add/timespec_del
      timekeeping: remove unused {read,update}_persistent_clock
      sh: remove board_time_init() callback
      sh: remove unused rtc_sh_get/set_time infrastructure
      sh: sh03: rtc: push down rtc class ops into driver
      sh: dreamcast: rtc: push down rtc class ops into driver
      y2038: signal: Add compat_sys_rt_sigtimedwait_time64
      y2038: signal: Add sys_rt_sigtimedwait_time32
      y2038: socket: Add compat_sys_recvmmsg_time64
      y2038: futex: Add support for __kernel_timespec
      y2038: futex: Move compat implementation into futex.c
      io_pgetevents: use __kernel_timespec
      pselect6: use __kernel_timespec
      ppoll: use __kernel_timespec
      signal: Add restore_user_sigmask()
      signal: Add set_user_sigmask()

commit f27bfb8884fe4abb570dbe5417008d473c01c7f7
Author: Harini Katakam <harini.katakam@xilinx.com>
Date:   Wed Jun 20 17:04:20 2018 +0530

    net: macb: Fix ptp time adjustment for large negative delta
    
    [ Upstream commit 64d7839af8c8f67daaf9bf387135052c55d85f90 ]
    
    When delta passed to gem_ptp_adjtime is negative, the sign is
    maintained in the ns_to_timespec64 conversion. Hence timespec_add
    should be used directly. timespec_sub will just subtract the negative
    value thus increasing the time difference.
    
    Signed-off-by: Harini Katakam <harini.katakam@xilinx.com>
    Acked-by: Nicolas Ferre <nicolas.ferre@microchip.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit f389c17b8dc54b474d33728e5882dcc276a467fa
Author: Harini Katakam <harini.katakam@xilinx.com>
Date:   Wed Jun 20 17:04:20 2018 +0530

    net: macb: Fix ptp time adjustment for large negative delta
    
    [ Upstream commit 64d7839af8c8f67daaf9bf387135052c55d85f90 ]
    
    When delta passed to gem_ptp_adjtime is negative, the sign is
    maintained in the ns_to_timespec64 conversion. Hence timespec_add
    should be used directly. timespec_sub will just subtract the negative
    value thus increasing the time difference.
    
    Signed-off-by: Harini Katakam <harini.katakam@xilinx.com>
    Acked-by: Nicolas Ferre <nicolas.ferre@microchip.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 0f9987b63dcc68606b82a349bbb2016b392a2c34
Author: Ondrej Mosnacek <omosnace@redhat.com>
Date:   Fri Jul 13 14:06:40 2018 +0200

    ntp: Remove redundant arguments
    
    The 'ts' argument of process_adj_status() and process_adjtimex_modes()
    is unused and can be safely removed.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Miroslav Lichvar <mlichvar@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Stephen Boyd <sboyd@kernel.org>
    Signed-off-by: Ondrej Mosnacek <omosnace@redhat.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 64d7839af8c8f67daaf9bf387135052c55d85f90
Author: Harini Katakam <harini.katakam@xilinx.com>
Date:   Wed Jun 20 17:04:20 2018 +0530

    net: macb: Fix ptp time adjustment for large negative delta
    
    When delta passed to gem_ptp_adjtime is negative, the sign is
    maintained in the ns_to_timespec64 conversion. Hence timespec_add
    should be used directly. timespec_sub will just subtract the negative
    value thus increasing the time difference.
    
    Signed-off-by: Harini Katakam <harini.katakam@xilinx.com>
    Acked-by: Nicolas Ferre <nicolas.ferre@microchip.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 1c2117b6ee880d70dbed1845e187225303317928
Author: Jann Horn <jannh@google.com>
Date:   Fri May 11 02:19:01 2018 +0200

    compat: fix 4-byte infoleak via uninitialized struct field
    
    commit 0a0b98734479aa5b3c671d5190e86273372cab95 upstream.
    
    Commit 3a4d44b61625 ("ntp: Move adjtimex related compat syscalls to
    native counterparts") removed the memset() in compat_get_timex().  Since
    then, the compat adjtimex syscall can invoke do_adjtimex() with an
    uninitialized ->tai.
    
    If do_adjtimex() doesn't write to ->tai (e.g.  because the arguments are
    invalid), compat_put_timex() then copies the uninitialized ->tai field
    to userspace.
    
    Fix it by adding the memset() back.
    
    Fixes: 3a4d44b61625 ("ntp: Move adjtimex related compat syscalls to native counterparts")
    Signed-off-by: Jann Horn <jannh@google.com>
    Acked-by: Kees Cook <keescook@chromium.org>
    Acked-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit ef7c4825fe5fe9ed251bda8d4c04d47fe33c3afb
Author: Jann Horn <jannh@google.com>
Date:   Fri May 11 02:19:01 2018 +0200

    compat: fix 4-byte infoleak via uninitialized struct field
    
    commit 0a0b98734479aa5b3c671d5190e86273372cab95 upstream.
    
    Commit 3a4d44b61625 ("ntp: Move adjtimex related compat syscalls to
    native counterparts") removed the memset() in compat_get_timex().  Since
    then, the compat adjtimex syscall can invoke do_adjtimex() with an
    uninitialized ->tai.
    
    If do_adjtimex() doesn't write to ->tai (e.g.  because the arguments are
    invalid), compat_put_timex() then copies the uninitialized ->tai field
    to userspace.
    
    Fix it by adding the memset() back.
    
    Fixes: 3a4d44b61625 ("ntp: Move adjtimex related compat syscalls to native counterparts")
    Signed-off-by: Jann Horn <jannh@google.com>
    Acked-by: Kees Cook <keescook@chromium.org>
    Acked-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 0a0b98734479aa5b3c671d5190e86273372cab95
Author: Jann Horn <jannh@google.com>
Date:   Fri May 11 02:19:01 2018 +0200

    compat: fix 4-byte infoleak via uninitialized struct field
    
    Commit 3a4d44b61625 ("ntp: Move adjtimex related compat syscalls to
    native counterparts") removed the memset() in compat_get_timex().  Since
    then, the compat adjtimex syscall can invoke do_adjtimex() with an
    uninitialized ->tai.
    
    If do_adjtimex() doesn't write to ->tai (e.g.  because the arguments are
    invalid), compat_put_timex() then copies the uninitialized ->tai field
    to userspace.
    
    Fix it by adding the memset() back.
    
    Fixes: 3a4d44b61625 ("ntp: Move adjtimex related compat syscalls to native counterparts")
    Signed-off-by: Jann Horn <jannh@google.com>
    Acked-by: Kees Cook <keescook@chromium.org>
    Acked-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit 9bdf43b3d40f8c0066eb12c7693509d2b4c5bdac
Author: Yangbo Lu <yangbo.lu@nxp.com>
Date:   Mon Apr 23 11:55:00 2018 +0800

    staging: fsl-dpaa2/rtc: add rtc driver
    
    This patch is to add driver for the DPAA2 1588 timer module (RTC)
    which interfaces to up to an unlimited number of 10/100/1000 or
    10G ethernet MACs, providing current time, alarm, and fiper support.
    The 1588 IP control block includes these distinctive features.
    
    - External GPIO trigger for time-stamping
    - 2 Time-stamp alarms
    - 3 FIPER pulse generators
    - Phase adjusted output timer clock
    
    Currently this driver only supports basic functions like
    settime/gettime/adjtime/adjfreq.
    
    Signed-off-by: Yangbo Lu <yangbo.lu@nxp.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 2977bb00bc5c1fb3966ea1529cac712ef4abf137
Author: Yangbo Lu <yangbo.lu@nxp.com>
Date:   Tue Jan 9 11:02:33 2018 +0800

    net: gianfar_ptp: move set_fipers() to spinlock protecting area
    
    [ Upstream commit 11d827a993a969c3c6ec56758ff63a44ba19b466 ]
    
    set_fipers() calling should be protected by spinlock in
    case that any interrupt breaks related registers setting
    and the function we expect. This patch is to move set_fipers()
    to spinlock protecting area in ptp_gianfar_adjtime().
    
    Signed-off-by: Yangbo Lu <yangbo.lu@nxp.com>
    Acked-by: Richard Cochran <richardcochran@gmail.com>
    Reviewed-by: Fabio Estevam <fabio.estevam@nxp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sasha Levin <alexander.levin@microsoft.com>

commit 83d9e9c211fe885d03e9acb425be3cf55c1d3bd8
Author: Yangbo Lu <yangbo.lu@nxp.com>
Date:   Tue Jan 9 11:02:33 2018 +0800

    net: gianfar_ptp: move set_fipers() to spinlock protecting area
    
    
    [ Upstream commit 11d827a993a969c3c6ec56758ff63a44ba19b466 ]
    
    set_fipers() calling should be protected by spinlock in
    case that any interrupt breaks related registers setting
    and the function we expect. This patch is to move set_fipers()
    to spinlock protecting area in ptp_gianfar_adjtime().
    
    Signed-off-by: Yangbo Lu <yangbo.lu@nxp.com>
    Acked-by: Richard Cochran <richardcochran@gmail.com>
    Reviewed-by: Fabio Estevam <fabio.estevam@nxp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sasha Levin <alexander.levin@verizon.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 3eb222174ee8b6280e552f71ed68f890bbbdc437
Author: Yangbo Lu <yangbo.lu@nxp.com>
Date:   Tue Jan 9 11:02:33 2018 +0800

    net: gianfar_ptp: move set_fipers() to spinlock protecting area
    
    
    [ Upstream commit 11d827a993a969c3c6ec56758ff63a44ba19b466 ]
    
    set_fipers() calling should be protected by spinlock in
    case that any interrupt breaks related registers setting
    and the function we expect. This patch is to move set_fipers()
    to spinlock protecting area in ptp_gianfar_adjtime().
    
    Signed-off-by: Yangbo Lu <yangbo.lu@nxp.com>
    Acked-by: Richard Cochran <richardcochran@gmail.com>
    Reviewed-by: Fabio Estevam <fabio.estevam@nxp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sasha Levin <alexander.levin@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 37d866a9e5656b2c4e32817a8cb0ff212ad227e9
Author: Yangbo Lu <yangbo.lu@nxp.com>
Date:   Tue Jan 9 11:02:33 2018 +0800

    net: gianfar_ptp: move set_fipers() to spinlock protecting area
    
    
    [ Upstream commit 11d827a993a969c3c6ec56758ff63a44ba19b466 ]
    
    set_fipers() calling should be protected by spinlock in
    case that any interrupt breaks related registers setting
    and the function we expect. This patch is to move set_fipers()
    to spinlock protecting area in ptp_gianfar_adjtime().
    
    Signed-off-by: Yangbo Lu <yangbo.lu@nxp.com>
    Acked-by: Richard Cochran <richardcochran@gmail.com>
    Reviewed-by: Fabio Estevam <fabio.estevam@nxp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sasha Levin <alexander.levin@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 62a101cde990623dbe9b9f8370ac5294f1da3229
Author: Yangbo Lu <yangbo.lu@nxp.com>
Date:   Tue Jan 9 11:02:33 2018 +0800

    net: gianfar_ptp: move set_fipers() to spinlock protecting area
    
    
    [ Upstream commit 11d827a993a969c3c6ec56758ff63a44ba19b466 ]
    
    set_fipers() calling should be protected by spinlock in
    case that any interrupt breaks related registers setting
    and the function we expect. This patch is to move set_fipers()
    to spinlock protecting area in ptp_gianfar_adjtime().
    
    Signed-off-by: Yangbo Lu <yangbo.lu@nxp.com>
    Acked-by: Richard Cochran <richardcochran@gmail.com>
    Reviewed-by: Fabio Estevam <fabio.estevam@nxp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sasha Levin <alexander.levin@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 90d17505219a7f382e6a295580e4382091bef7f6
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Nov 8 16:02:13 2017 +0100

    alpha: osf_sys.c: fix put_tv32 regression
    
    commit 47669fb6b5951d0e09fc99719653e0ac92b50b99 upstream.
    
    There was a typo in the new version of put_tv32() that caused an unguarded
    access of a user space pointer, and failed to return the correct result in
    gettimeofday(), wait4(), usleep_thread() and old_adjtimex().
    
    This fixes it to give the correct behavior again.
    
    Fixes: 1cc6c4635e9f ("osf_sys.c: switch handling of timeval32/itimerval32 to copy_{to,from}_user()")
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit c3135742ca71c0e4164e4b2e0dc0d86bbfdde9aa
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Nov 8 16:02:13 2017 +0100

    alpha: osf_sys.c: fix put_tv32 regression
    
    commit 47669fb6b5951d0e09fc99719653e0ac92b50b99 upstream.
    
    There was a typo in the new version of put_tv32() that caused an unguarded
    access of a user space pointer, and failed to return the correct result in
    gettimeofday(), wait4(), usleep_thread() and old_adjtimex().
    
    This fixes it to give the correct behavior again.
    
    Fixes: 1cc6c4635e9f ("osf_sys.c: switch handling of timeval32/itimerval32 to copy_{to,from}_user()")
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit ce4c253573ad184603e0fa77876ba155b0cde46d
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Nov 8 16:02:14 2017 +0100

    alpha: osf_sys.c: use timespec64 where appropriate
    
    Some of the syscall helper functions (do_utimes, poll_select_set_timeout,
    core_sys_select) have changed over the past year or two to use
    'timespec64' pointers rather than 'timespec'. This was fine on alpha,
    since 64-bit architectures treat the two as the same type.
    
    However, I'd like to change that behavior and make 'timespec64' a proper
    type of its own even on 64-bit architectures, and that will introduce
    harmless type mismatch warnings here.
    
    Also, I'm trying to kill off the do_gettimeofday() helper in favor of
    ktime_get() and related interfaces throughout the kernel.
    
    This changes the get_tv32/put_tv32 helper functions to also take a
    timespec64 argument rather than timeval, which allows us to simplify
    some of the syscall helpers a bit and avoid the type warnings.
    
    For the moment, wait4 and adjtimex are still better off with the old
    behavior, so I'm adding a special put_tv_to_tv32() helper for those.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

commit 47669fb6b5951d0e09fc99719653e0ac92b50b99
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Nov 8 16:02:13 2017 +0100

    alpha: osf_sys.c: fix put_tv32 regression
    
    There was a typo in the new version of put_tv32() that caused an unguarded
    access of a user space pointer, and failed to return the correct result in
    gettimeofday(), wait4(), usleep_thread() and old_adjtimex().
    
    This fixes it to give the correct behavior again.
    
    Cc: stable@vger.kernel.org
    Fixes: 1cc6c4635e9f ("osf_sys.c: switch handling of timeval32/itimerval32 to copy_{to,from}_user()")
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

commit d437e0659f4a0b683e6fd458b80d979c9fe5f72c
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Nov 8 16:02:14 2017 +0100

    alpha: osf_sys.c: use timespec64 where appropriate
    
    Some of the syscall helper functions (do_utimes, poll_select_set_timeout,
    core_sys_select) have changed over the past year or two to use
    'timespec64' pointers rather than 'timespec'. This was fine on alpha,
    since 64-bit architectures treat the two as the same type.
    
    However, I'd like to change that behavior and make 'timespec64' a proper
    type of its own even on 64-bit architectures, and that will introduce
    harmless type mismatch warnings here.
    
    Also, I'm trying to kill off the do_gettimeofday() helper in favor of
    ktime_get() and related interfaces throughout the kernel.
    
    This changes the get_tv32/put_tv32 helper functions to also take a
    timespec64 argument rather than timeval, which allows us to simplify
    some of the syscall helpers a bit and avoid the type warnings.
    
    For the moment, wait4 and adjtimex are still better off with the old
    behavior, so I'm adding a special put_tv_to_tv32() helper for those.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Matt Turner <mattst88@gmail.com>

commit 645a05a72c366529bf7e566b32ec806744883597
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Nov 8 16:02:13 2017 +0100

    alpha: osf_sys.c: fix put_tv32 regression
    
    There was a typo in the new version of put_tv32() that caused an unguarded
    access of a user space pointer, and failed to return the correct result in
    gettimeofday(), wait4(), usleep_thread() and old_adjtimex().
    
    This fixes it to give the correct behavior again.
    
    Cc: stable@vger.kernel.org
    Fixes: 1cc6c4635e9f ("osf_sys.c: switch handling of timeval32/itimerval32 to copy_{to,from}_user()")
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Matt Turner <mattst88@gmail.com>

commit 11d827a993a969c3c6ec56758ff63a44ba19b466
Author: Yangbo Lu <yangbo.lu@nxp.com>
Date:   Tue Jan 9 11:02:33 2018 +0800

    net: gianfar_ptp: move set_fipers() to spinlock protecting area
    
    set_fipers() calling should be protected by spinlock in
    case that any interrupt breaks related registers setting
    and the function we expect. This patch is to move set_fipers()
    to spinlock protecting area in ptp_gianfar_adjtime().
    
    Signed-off-by: Yangbo Lu <yangbo.lu@nxp.com>
    Acked-by: Richard Cochran <richardcochran@gmail.com>
    Reviewed-by: Fabio Estevam <fabio.estevam@nxp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 1572fa03784831b81ec26ec379374cf6bdec04fb
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Thu Oct 19 13:14:45 2017 +0200

    timekeeping: Use timespec64 in timekeeping_inject_offset
    
    As part of changing all the timekeeping code to use 64-bit
    time_t consistently, this removes the uses of timeval
    and timespec as much as possible from do_adjtimex() and
    timekeeping_inject_offset(). The timeval_inject_offset_valid()
    and timespec_inject_offset_valid() just complicate this,
    so I'm folding them into the respective callers.
    
    This leaves the actual 'struct timex' definition, which
    is part of the user-space ABI and should be dealt with
    separately when we have agreed on the ABI change.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Miroslav Lichvar <mlichvar@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Stephen Boyd <stephen.boyd@linaro.org>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit e0956dcc4ba74ec4b17e32fc9a156fcba1ef6610
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Thu Oct 19 13:14:44 2017 +0200

    timekeeping: Consolidate timekeeping_inject_offset code
    
    The code to check the adjtimex() or clock_adjtime() arguments is spread
    out across multiple files for presumably only historic reasons. As a
    preparatation for a rework to get rid of the use of 'struct timeval'
    and 'struct timespec' in there, this moves all the portions into
    kernel/time/timekeeping.c and marks them as 'static'.
    
    The warp_clock() function here is not as closely related as the others,
    but I feel it still makes sense to move it here in order to consolidate
    all callers of timekeeping_inject_offset().
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Miroslav Lichvar <mlichvar@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Stephen Boyd <stephen.boyd@linaro.org>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    [jstultz: Whitespace fixup]
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 5ab49e936a0a2d505bd1c93a9479e3d3ee67b7e7
Author: Michal Nazarewicz <mina86@mina86.com>
Date:   Mon Nov 9 14:58:10 2015 -0800

    kernel.h: make abs() work with 64-bit types
    
    commit c8299cb605b27dd5a49f7a69e48fd23e5a206298 upstream.
    
    For 64-bit arguments, the abs macro casts it to an int which leads to
    lost precision and may cause incorrect results.  To deal with 64-bit
    types abs64 macro has been introduced but still there are places where
    abs macro is used incorrectly.
    
    To deal with the problem, expand abs macro such that it operates on s64
    type when dealing with 64-bit types while still returning long when
    dealing with smaller types.
    
    This fixes one known bug (per John):
    
    The internal clocksteering done for fine-grained error correction uses a
    : logarithmic approximation, so any time adjtimex() adjusts the clock
    : steering, timekeeping_freqadjust() quickly approximates the correct clock
    : frequency over a series of ticks.
    :
    : Unfortunately, the logic in timekeeping_freqadjust(), introduced in commit
    : dc491596f639438 (Rework frequency adjustments to work better w/ nohz),
    : used the abs() function with a s64 error value to calculate the size of
    : the approximated adjustment to be made.
    :
    : Per include/linux/kernel.h: "abs() should not be used for 64-bit types
    : (s64, u64, long long) - use abs64()".
    :
    : Thus on 32-bit platforms, this resulted in the clocksteering to take a
    : quite dampended random walk trying to converge on the proper frequency,
    : which caused the adjustments to be made much slower then intended (most
    : easily observed when large adjustments are made).
    
    Signed-off-by: Michal Nazarewicz <mina86@mina86.com>
    Reported-by: John Stultz <john.stultz@linaro.org>
    Tested-by: John Stultz <john.stultz@linaro.org>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit 767392565a3e618950fe1a5ff1ba11295f6332f4
Author: Miroslav Lichvar <mlichvar@redhat.com>
Date:   Fri Jun 9 13:43:17 2017 +0200

    kselftests: timers: Add test for frequency step
    
    This test checks the response of the system clock to frequency
    steps made with adjtimex(). The frequency error and stability of
    the CLOCK_MONOTONIC clock relative to the CLOCK_MONOTONIC_RAW clock
    is measured in two intervals following the step. The test fails if
    values from the second interval exceed specified limits.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Miroslav Lichvar <mlichvar@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Stephen Boyd <stephen.boyd@linaro.org>
    Cc: Shuah Khan <shuah@kernel.org>
    Signed-off-by: Miroslav Lichvar <mlichvar@redhat.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 3a4d44b6162555070194e486ff6b3799a8d323a2
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Jun 7 09:42:34 2017 +0100

    ntp: Move adjtimex related compat syscalls to native counterparts
    
    Get rid of set_fs() mess and sanitize compat_{get,put}_timex(),
    while we are at it.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/20170607084241.28657-9-viro@ZenIV.linux.org.uk

commit 5db6db0d400edd8bec274e34960cfa22838e1df5
Merge: 5fab10041b43 2fefc97b2180
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon May 1 14:41:04 2017 -0700

    Merge branch 'work.uaccess' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull uaccess unification updates from Al Viro:
     "This is the uaccess unification pile. It's _not_ the end of uaccess
      work, but the next batch of that will go into the next cycle. This one
      mostly takes copy_from_user() and friends out of arch/* and gets the
      zero-padding behaviour in sync for all architectures.
    
      Dealing with the nocache/writethrough mess is for the next cycle;
      fortunately, that's x86-only. Same for cleanups in iov_iter.c (I am
      sold on access_ok() in there, BTW; just not in this pile), same for
      reducing __copy_... callsites, strn*... stuff, etc. - there will be a
      pile about as large as this one in the next merge window.
    
      This one sat in -next for weeks. -3KLoC"
    
    * 'work.uaccess' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs: (96 commits)
      HAVE_ARCH_HARDENED_USERCOPY is unconditional now
      CONFIG_ARCH_HAS_RAW_COPY_USER is unconditional now
      m32r: switch to RAW_COPY_USER
      hexagon: switch to RAW_COPY_USER
      microblaze: switch to RAW_COPY_USER
      get rid of padding, switch to RAW_COPY_USER
      ia64: get rid of copy_in_user()
      ia64: sanitize __access_ok()
      ia64: get rid of 'segment' argument of __do_{get,put}_user()
      ia64: get rid of 'segment' argument of __{get,put}_user_check()
      ia64: add extable.h
      powerpc: get rid of zeroing, switch to RAW_COPY_USER
      esas2r: don't open-code memdup_user()
      alpha: fix stack smashing in old_adjtimex(2)
      don't open-code kernel_setsockopt()
      mips: switch to RAW_COPY_USER
      mips: get rid of tail-zeroing in primitives
      mips: make copy_from_user() zero tail explicitly
      mips: clean and reorder the forest of macros...
      mips: consolidate __invoke_... wrappers
      ...

commit 2a610b8aa8e5bd449ba270e517b0e72295d62c9c
Merge: 78d91a75b40f a8e28440016b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Apr 9 08:26:21 2017 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull VFS fixes from Al Viro:
     "statx followup fixes and a fix for stack-smashing on alpha"
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      alpha: fix stack smashing in old_adjtimex(2)
      statx: Include a mask for stx_attributes in struct statx
      statx: Reserve the top bit of the mask for future struct expansion
      xfs: report crtime and attribute flags to statx
      ext4: Add statx support
      statx: optimize copy of struct statx to userspace
      statx: remove incorrect part of vfs_statx() comment
      statx: reject unknown flags when using NULL path
      Documentation/filesystems: fix documentation for ->getattr()

commit 1c87ea4566612ef37e31f6389cbb232bd49cdd45
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Mar 25 00:43:43 2017 -0400

    alpha: fix stack smashing in old_adjtimex(2)
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

commit 2b5efc089769cd2aa583880d29416d00e7441f39
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Mar 25 00:43:43 2017 -0400

    alpha: fix stack smashing in old_adjtimex(2)
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

commit 40d9f82750044f846005d2ac4eec65e39c1c0f7c
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Wed Dec 7 14:33:23 2016 -0800

    timekeeping: Remove unused timekeeping_{get,set}_tai_offset()
    
    The last caller to timekeeping_set_tai_offset() was in commit
    0b5154fb9040 (timekeeping: Simplify tai updating from
    do_adjtimex, 2013-03-22) and the last caller to
    timekeeping_get_tai_offset() was in commit 76f4108892d9 (hrtimer:
    Cleanup hrtimer accessors to the timekepeing state, 2014-07-16).
    Remove these unused functions now that we handle TAI offsets
    differently.
    
    Cc: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit baa73d9e478ff32d62f3f9422822b59dd9a95a21
Author: Nicolas Pitre <nico@fluxnic.net>
Date:   Fri Nov 11 00:10:10 2016 -0500

    posix-timers: Make them configurable
    
    Some embedded systems have no use for them.  This removes about
    25KB from the kernel binary size when configured out.
    
    Corresponding syscalls are routed to a stub logging the attempt to
    use those syscalls which should be enough of a clue if they were
    disabled without proper consideration. They are: timer_create,
    timer_gettime: timer_getoverrun, timer_settime, timer_delete,
    clock_adjtime, setitimer, getitimer, alarm.
    
    The clock_settime, clock_gettime, clock_getres and clock_nanosleep
    syscalls are replaced by simple wrappers compatible with CLOCK_REALTIME,
    CLOCK_MONOTONIC and CLOCK_BOOTTIME only which should cover the vast
    majority of use cases with very little code.
    
    Signed-off-by: Nicolas Pitre <nico@linaro.org>
    Acked-by: Richard Cochran <richardcochran@gmail.com>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: John Stultz <john.stultz@linaro.org>
    Reviewed-by: Josh Triplett <josh@joshtriplett.org>
    Cc: Paul Bolle <pebolle@tiscali.nl>
    Cc: linux-kbuild@vger.kernel.org
    Cc: netdev@vger.kernel.org
    Cc: Michal Marek <mmarek@suse.com>
    Cc: Edward Cree <ecree@solarflare.com>
    Link: http://lkml.kernel.org/r/1478841010-28605-7-git-send-email-nicolas.pitre@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 8c095d35c42284d6d8cd792c01afd7cdeba475db
Author: John Stultz <john.stultz@linaro.org>
Date:   Thu Jun 11 15:54:55 2015 -0700

    time: Prevent early expiry of hrtimers[CLOCK_REALTIME] at the leap second edge
    
    commit 833f32d763028c1bb371c64f457788b933773b3e upstream.
    
    Currently, leapsecond adjustments are done at tick time. As a result,
    the leapsecond was applied at the first timer tick *after* the
    leapsecond (~1-10ms late depending on HZ), rather then exactly on the
    second edge.
    
    This was in part historical from back when we were always tick based,
    but correcting this since has been avoided since it adds extra
    conditional checks in the gettime fastpath, which has performance
    overhead.
    
    However, it was recently pointed out that ABS_TIME CLOCK_REALTIME
    timers set for right after the leapsecond could fire a second early,
    since some timers may be expired before we trigger the timekeeping
    timer, which then applies the leapsecond.
    
    This isn't quite as bad as it sounds, since behaviorally it is similar
    to what is possible w/ ntpd made leapsecond adjustments done w/o using
    the kernel discipline. Where due to latencies, timers may fire just
    prior to the settimeofday call. (Also, one should note that all
    applications using CLOCK_REALTIME timers should always be careful,
    since they are prone to quirks from settimeofday() disturbances.)
    
    However, the purpose of having the kernel do the leap adjustment is to
    avoid such latencies, so I think this is worth fixing.
    
    So in order to properly keep those timers from firing a second early,
    this patch modifies the ntp and timekeeping logic so that we keep
    enough state so that the update_base_offsets_now accessor, which
    provides the hrtimer core the current time, can check and apply the
    leapsecond adjustment on the second edge. This prevents the hrtimer
    core from expiring timers too early.
    
    This patch does not modify any other time read path, so no additional
    overhead is incurred. However, this also means that the leap-second
    continues to be applied at tick time for all other read-paths.
    
    Apologies to Richard Cochran, who pushed for similar changes years
    ago, which I resisted due to the concerns about the performance
    overhead.
    
    While I suspect this isn't extremely critical, folks who care about
    strict leap-second correctness will likely want to watch
    this. Potentially a -stable candidate eventually.
    
    Originally-suggested-by: Richard Cochran <richardcochran@gmail.com>
    Reported-by: Daniel Bristot de Oliveira <bristot@redhat.com>
    Reported-by: Prarit Bhargava <prarit@redhat.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Jan Kara <jack@suse.cz>
    Cc: Jiri Bohac <jbohac@suse.cz>
    Cc: Shuah Khan <shuahkh@osg.samsung.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Link: http://lkml.kernel.org/r/1434063297-28657-4-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    [Yadi: Move do_adjtimex to timekeeping.c and solve context issues]
    Signed-off-by: Hu <yadi.hu@windriver.com>
    Signed-off-by: Zefan Li <lizefan@huawei.com>

commit 1db396648ca33eb92dd0ed5cc2ea2f58816eeb9a
Author: John Stultz <john.stultz@linaro.org>
Date:   Thu Apr 14 10:25:14 2016 -0600

    ntp: Fix ADJ_SETOFFSET being used w/ ADJ_NANO
    
    [ Upstream commit dd4e17ab704269bce71402285f5e8b9ac24b1eff ]
    
    Recently, in commit 37cf4dc3370f I forgot to check if the timeval being passed
    was actually a timespec (as is signaled with ADJ_NANO).
    
    This resulted in that patch breaking ADJ_SETOFFSET users who set
    ADJ_NANO, by rejecting valid timespecs that were compared with
    valid timeval ranges.
    
    This patch addresses this by checking for the ADJ_NANO flag and
    using the timepsec check instead in that case.
    
    Reported-by: Harald Hoyer <harald@redhat.com>
    Reported-by: Kay Sievers <kay@vrfy.org>
    Fixes: 37cf4dc3370f "time: Verify time values in adjtimex ADJ_SETOFFSET to avoid overflow"
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: David Herrmann <dh.herrmann@gmail.com>
    Link: http://lkml.kernel.org/r/1453417415-19110-2-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Sasha Levin <alexander.levin@verizon.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit e79e7333c3a3d94a2b4f10f4977b45162ef160cf
Author: John Stultz <john.stultz@linaro.org>
Date:   Thu Dec 3 22:09:31 2015 -0500

    time: Verify time values in adjtimex ADJ_SETOFFSET to avoid overflow
    
    [ Upstream commit 37cf4dc3370fbca0344e23bb96446eb2c3548ba7 ]
    
    For adjtimex()'s ADJ_SETOFFSET, make sure the tv_usec value is
    sane. We might multiply them later which can cause an overflow
    and undefined behavior.
    
    This patch introduces new helper functions to simplify the
    checking code and adds comments to clarify
    
    Orginally this patch was by Sasha Levin, but I've basically
    rewritten it, so he should get credit for finding the issue
    and I should get the blame for any mistakes made since.
    
    Also, credit to Richard Cochran for the phrasing used in the
    comment for what is considered valid here.
    
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Reported-by: Sasha Levin <sasha.levin@oracle.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Sasha Levin <alexander.levin@verizon.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 41ad022039522485456802f09d8eccebc24aac3e
Author: David Hildenbrand <dahi@linux.vnet.ibm.com>
Date:   Thu Jul 14 13:09:57 2016 +0200

    s390/time: simplify stp time syncs
    
    The way we call do_adjtimex() today is broken. It has 0 effect, as
    ADJ_OFFSET_SINGLESHOT (0x0001) in the kernel maps to !ADJ_ADJTIME
    (in contrast to user space where it maps to  ADJ_OFFSET_SINGLESHOT |
    ADJ_ADJTIME - 0x8001). !ADJ_ADJTIME will silently ignore all adjustments
    without STA_PLL being active. We could switch to ADJ_ADJTIME or turn
    STA_PLL on, but still we would run into some problems:
    
    - Even when switching to nanoseconds, we lose accuracy.
    - Successive calls to do_adjtimex() will simply overwrite any leftovers
      from the previous call (if not fully handled)
    - Anything that NTP does using the sysctl heavily interferes with our
      use.
    - !ADJ_ADJTIME will silently round stuff > or < than 0.5 seconds
    
    Reusing do_adjtimex() here just feels wrong. The whole STP synchronization
    works right now *somehow* only, as do_adjtimex() does nothing and our
    TOD clock jumps in time, although it shouldn't. This is especially bad
    as the clock could jump backwards in time. We will have to find another
    way to fix this up.
    
    As leap seconds are also not properly handled yet, let's just get rid of
    all this complex logic altogether and use the correct clock_delta for
    fixing up the clock comparator and keeping the sched_clock monotonic.
    
    This change should have 0 effect on the current STP mechanism. Once we
    know how to best handle sync events and leap second updates, we'll start
    with a fresh implementation.
    
    Signed-off-by: David Hildenbrand <dahi@linux.vnet.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

commit e3d00f2477da0e51078d6b6e8956165b05187662
Author: Helge Deller <deller@gmx.de>
Date:   Sat Jun 4 17:21:33 2016 +0200

    parisc: Fix pagefault crash in unaligned __get_user() call
    
    commit 8b78f260887df532da529f225c49195d18fef36b upstream.
    
    One of the debian buildd servers had this crash in the syslog without
    any other information:
    
     Unaligned handler failed, ret = -2
     clock_adjtime (pid 22578): Unaligned data reference (code 28)
     CPU: 1 PID: 22578 Comm: clock_adjtime Tainted: G  E  4.5.0-2-parisc64-smp #1 Debian 4.5.4-1
     task: 000000007d9960f8 ti: 00000001bde7c000 task.ti: 00000001bde7c000
    
          YZrvWESTHLNXBCVMcbcbcbcbOGFRQPDI
     PSW: 00001000000001001111100000001111 Tainted: G            E
     r00-03  000000ff0804f80f 00000001bde7c2b0 00000000402d2be8 00000001bde7c2b0
     r04-07  00000000409e1fd0 00000000fa6f7fff 00000001bde7c148 00000000fa6f7fff
     r08-11  0000000000000000 00000000ffffffff 00000000fac9bb7b 000000000002b4d4
     r12-15  000000000015241c 000000000015242c 000000000000002d 00000000fac9bb7b
     r16-19  0000000000028800 0000000000000001 0000000000000070 00000001bde7c218
     r20-23  0000000000000000 00000001bde7c210 0000000000000002 0000000000000000
     r24-27  0000000000000000 0000000000000000 00000001bde7c148 00000000409e1fd0
     r28-31  0000000000000001 00000001bde7c320 00000001bde7c350 00000001bde7c218
     sr00-03  0000000001200000 0000000001200000 0000000000000000 0000000001200000
     sr04-07  0000000000000000 0000000000000000 0000000000000000 0000000000000000
    
     IASQ: 0000000000000000 0000000000000000 IAOQ: 00000000402d2e84 00000000402d2e88
      IIR: 0ca0d089    ISR: 0000000001200000  IOR: 00000000fa6f7fff
      CPU:        1   CR30: 00000001bde7c000 CR31: ffffffffffffffff
      ORIG_R28: 00000002369fe628
      IAOQ[0]: compat_get_timex+0x2dc/0x3c0
      IAOQ[1]: compat_get_timex+0x2e0/0x3c0
      RP(r2): compat_get_timex+0x40/0x3c0
     Backtrace:
      [<00000000402d4608>] compat_SyS_clock_adjtime+0x40/0xc0
      [<0000000040205024>] syscall_exit+0x0/0x14
    
    This means the userspace program clock_adjtime called the clock_adjtime()
    syscall and then crashed inside the compat_get_timex() function.
    Syscalls should never crash programs, but instead return EFAULT.
    
    The IIR register contains the executed instruction, which disassebles
    into "ldw 0(sr3,r5),r9".
    This load-word instruction is part of __get_user() which tried to read the word
    at %r5/IOR (0xfa6f7fff). This means the unaligned handler jumped in.  The
    unaligned handler is able to emulate all ldw instructions, but it fails if it
    fails to read the source e.g. because of page fault.
    
    The following program reproduces the problem:
    
    #define _GNU_SOURCE
    #include <unistd.h>
    #include <sys/syscall.h>
    #include <sys/mman.h>
    
    int main(void) {
            /* allocate 8k */
            char *ptr = mmap(NULL, 2*4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
            /* free second half (upper 4k) and make it invalid. */
            munmap(ptr+4096, 4096);
            /* syscall where first int is unaligned and clobbers into invalid memory region */
            /* syscall should return EFAULT */
            return syscall(__NR_clock_adjtime, 0, ptr+4095);
    }
    
    To fix this issue we simply need to check if the faulting instruction address
    is in the exception fixup table when the unaligned handler failed. If it
    is, call the fixup routine instead of crashing.
    
    While looking at the unaligned handler I found another issue as well: The
    target register should not be modified if the handler was unsuccessful.
    
    Signed-off-by: Helge Deller <deller@gmx.de>
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit cc7d767c2ea2f0f658741c3cbde16a61561e7f03
Author: Helge Deller <deller@gmx.de>
Date:   Sat Jun 4 17:21:33 2016 +0200

    parisc: Fix pagefault crash in unaligned __get_user() call
    
    commit 8b78f260887df532da529f225c49195d18fef36b upstream.
    
    One of the debian buildd servers had this crash in the syslog without
    any other information:
    
     Unaligned handler failed, ret = -2
     clock_adjtime (pid 22578): Unaligned data reference (code 28)
     CPU: 1 PID: 22578 Comm: clock_adjtime Tainted: G  E  4.5.0-2-parisc64-smp #1 Debian 4.5.4-1
     task: 000000007d9960f8 ti: 00000001bde7c000 task.ti: 00000001bde7c000
    
          YZrvWESTHLNXBCVMcbcbcbcbOGFRQPDI
     PSW: 00001000000001001111100000001111 Tainted: G            E
     r00-03  000000ff0804f80f 00000001bde7c2b0 00000000402d2be8 00000001bde7c2b0
     r04-07  00000000409e1fd0 00000000fa6f7fff 00000001bde7c148 00000000fa6f7fff
     r08-11  0000000000000000 00000000ffffffff 00000000fac9bb7b 000000000002b4d4
     r12-15  000000000015241c 000000000015242c 000000000000002d 00000000fac9bb7b
     r16-19  0000000000028800 0000000000000001 0000000000000070 00000001bde7c218
     r20-23  0000000000000000 00000001bde7c210 0000000000000002 0000000000000000
     r24-27  0000000000000000 0000000000000000 00000001bde7c148 00000000409e1fd0
     r28-31  0000000000000001 00000001bde7c320 00000001bde7c350 00000001bde7c218
     sr00-03  0000000001200000 0000000001200000 0000000000000000 0000000001200000
     sr04-07  0000000000000000 0000000000000000 0000000000000000 0000000000000000
    
     IASQ: 0000000000000000 0000000000000000 IAOQ: 00000000402d2e84 00000000402d2e88
      IIR: 0ca0d089    ISR: 0000000001200000  IOR: 00000000fa6f7fff
      CPU:        1   CR30: 00000001bde7c000 CR31: ffffffffffffffff
      ORIG_R28: 00000002369fe628
      IAOQ[0]: compat_get_timex+0x2dc/0x3c0
      IAOQ[1]: compat_get_timex+0x2e0/0x3c0
      RP(r2): compat_get_timex+0x40/0x3c0
     Backtrace:
      [<00000000402d4608>] compat_SyS_clock_adjtime+0x40/0xc0
      [<0000000040205024>] syscall_exit+0x0/0x14
    
    This means the userspace program clock_adjtime called the clock_adjtime()
    syscall and then crashed inside the compat_get_timex() function.
    Syscalls should never crash programs, but instead return EFAULT.
    
    The IIR register contains the executed instruction, which disassebles
    into "ldw 0(sr3,r5),r9".
    This load-word instruction is part of __get_user() which tried to read the word
    at %r5/IOR (0xfa6f7fff). This means the unaligned handler jumped in.  The
    unaligned handler is able to emulate all ldw instructions, but it fails if it
    fails to read the source e.g. because of page fault.
    
    The following program reproduces the problem:
    
    #define _GNU_SOURCE
    #include <unistd.h>
    #include <sys/syscall.h>
    #include <sys/mman.h>
    
    int main(void) {
            /* allocate 8k */
            char *ptr = mmap(NULL, 2*4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
            /* free second half (upper 4k) and make it invalid. */
            munmap(ptr+4096, 4096);
            /* syscall where first int is unaligned and clobbers into invalid memory region */
            /* syscall should return EFAULT */
            return syscall(__NR_clock_adjtime, 0, ptr+4095);
    }
    
    To fix this issue we simply need to check if the faulting instruction address
    is in the exception fixup table when the unaligned handler failed. If it
    is, call the fixup routine instead of crashing.
    
    While looking at the unaligned handler I found another issue as well: The
    target register should not be modified if the handler was unsuccessful.
    
    Signed-off-by: Helge Deller <deller@gmx.de>
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit fcf55035f9cf155d2d63a07af15522bfafb54951
Author: Helge Deller <deller@gmx.de>
Date:   Sat Jun 4 17:21:33 2016 +0200

    parisc: Fix pagefault crash in unaligned __get_user() call
    
    commit 8b78f260887df532da529f225c49195d18fef36b upstream.
    
    One of the debian buildd servers had this crash in the syslog without
    any other information:
    
     Unaligned handler failed, ret = -2
     clock_adjtime (pid 22578): Unaligned data reference (code 28)
     CPU: 1 PID: 22578 Comm: clock_adjtime Tainted: G  E  4.5.0-2-parisc64-smp #1 Debian 4.5.4-1
     task: 000000007d9960f8 ti: 00000001bde7c000 task.ti: 00000001bde7c000
    
          YZrvWESTHLNXBCVMcbcbcbcbOGFRQPDI
     PSW: 00001000000001001111100000001111 Tainted: G            E
     r00-03  000000ff0804f80f 00000001bde7c2b0 00000000402d2be8 00000001bde7c2b0
     r04-07  00000000409e1fd0 00000000fa6f7fff 00000001bde7c148 00000000fa6f7fff
     r08-11  0000000000000000 00000000ffffffff 00000000fac9bb7b 000000000002b4d4
     r12-15  000000000015241c 000000000015242c 000000000000002d 00000000fac9bb7b
     r16-19  0000000000028800 0000000000000001 0000000000000070 00000001bde7c218
     r20-23  0000000000000000 00000001bde7c210 0000000000000002 0000000000000000
     r24-27  0000000000000000 0000000000000000 00000001bde7c148 00000000409e1fd0
     r28-31  0000000000000001 00000001bde7c320 00000001bde7c350 00000001bde7c218
     sr00-03  0000000001200000 0000000001200000 0000000000000000 0000000001200000
     sr04-07  0000000000000000 0000000000000000 0000000000000000 0000000000000000
    
     IASQ: 0000000000000000 0000000000000000 IAOQ: 00000000402d2e84 00000000402d2e88
      IIR: 0ca0d089    ISR: 0000000001200000  IOR: 00000000fa6f7fff
      CPU:        1   CR30: 00000001bde7c000 CR31: ffffffffffffffff
      ORIG_R28: 00000002369fe628
      IAOQ[0]: compat_get_timex+0x2dc/0x3c0
      IAOQ[1]: compat_get_timex+0x2e0/0x3c0
      RP(r2): compat_get_timex+0x40/0x3c0
     Backtrace:
      [<00000000402d4608>] compat_SyS_clock_adjtime+0x40/0xc0
      [<0000000040205024>] syscall_exit+0x0/0x14
    
    This means the userspace program clock_adjtime called the clock_adjtime()
    syscall and then crashed inside the compat_get_timex() function.
    Syscalls should never crash programs, but instead return EFAULT.
    
    The IIR register contains the executed instruction, which disassebles
    into "ldw 0(sr3,r5),r9".
    This load-word instruction is part of __get_user() which tried to read the word
    at %r5/IOR (0xfa6f7fff). This means the unaligned handler jumped in.  The
    unaligned handler is able to emulate all ldw instructions, but it fails if it
    fails to read the source e.g. because of page fault.
    
    The following program reproduces the problem:
    
    #define _GNU_SOURCE
    #include <unistd.h>
    #include <sys/syscall.h>
    #include <sys/mman.h>
    
    int main(void) {
            /* allocate 8k */
            char *ptr = mmap(NULL, 2*4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
            /* free second half (upper 4k) and make it invalid. */
            munmap(ptr+4096, 4096);
            /* syscall where first int is unaligned and clobbers into invalid memory region */
            /* syscall should return EFAULT */
            return syscall(__NR_clock_adjtime, 0, ptr+4095);
    }
    
    To fix this issue we simply need to check if the faulting instruction address
    is in the exception fixup table when the unaligned handler failed. If it
    is, call the fixup routine instead of crashing.
    
    While looking at the unaligned handler I found another issue as well: The
    target register should not be modified if the handler was unsuccessful.
    
    Signed-off-by: Helge Deller <deller@gmx.de>
    Cc: stable@vger.kernel.org
    Signed-off-by: Willy Tarreau <w@1wt.eu>

commit 22079c65db043d6440d2d00347556291dab779fc
Author: Helge Deller <deller@gmx.de>
Date:   Sat Jun 4 17:21:33 2016 +0200

    parisc: Fix pagefault crash in unaligned __get_user() call
    
    commit 8b78f260887df532da529f225c49195d18fef36b upstream.
    
    One of the debian buildd servers had this crash in the syslog without
    any other information:
    
     Unaligned handler failed, ret = -2
     clock_adjtime (pid 22578): Unaligned data reference (code 28)
     CPU: 1 PID: 22578 Comm: clock_adjtime Tainted: G  E  4.5.0-2-parisc64-smp #1 Debian 4.5.4-1
     task: 000000007d9960f8 ti: 00000001bde7c000 task.ti: 00000001bde7c000
    
          YZrvWESTHLNXBCVMcbcbcbcbOGFRQPDI
     PSW: 00001000000001001111100000001111 Tainted: G            E
     r00-03  000000ff0804f80f 00000001bde7c2b0 00000000402d2be8 00000001bde7c2b0
     r04-07  00000000409e1fd0 00000000fa6f7fff 00000001bde7c148 00000000fa6f7fff
     r08-11  0000000000000000 00000000ffffffff 00000000fac9bb7b 000000000002b4d4
     r12-15  000000000015241c 000000000015242c 000000000000002d 00000000fac9bb7b
     r16-19  0000000000028800 0000000000000001 0000000000000070 00000001bde7c218
     r20-23  0000000000000000 00000001bde7c210 0000000000000002 0000000000000000
     r24-27  0000000000000000 0000000000000000 00000001bde7c148 00000000409e1fd0
     r28-31  0000000000000001 00000001bde7c320 00000001bde7c350 00000001bde7c218
     sr00-03  0000000001200000 0000000001200000 0000000000000000 0000000001200000
     sr04-07  0000000000000000 0000000000000000 0000000000000000 0000000000000000
    
     IASQ: 0000000000000000 0000000000000000 IAOQ: 00000000402d2e84 00000000402d2e88
      IIR: 0ca0d089    ISR: 0000000001200000  IOR: 00000000fa6f7fff
      CPU:        1   CR30: 00000001bde7c000 CR31: ffffffffffffffff
      ORIG_R28: 00000002369fe628
      IAOQ[0]: compat_get_timex+0x2dc/0x3c0
      IAOQ[1]: compat_get_timex+0x2e0/0x3c0
      RP(r2): compat_get_timex+0x40/0x3c0
     Backtrace:
      [<00000000402d4608>] compat_SyS_clock_adjtime+0x40/0xc0
      [<0000000040205024>] syscall_exit+0x0/0x14
    
    This means the userspace program clock_adjtime called the clock_adjtime()
    syscall and then crashed inside the compat_get_timex() function.
    Syscalls should never crash programs, but instead return EFAULT.
    
    The IIR register contains the executed instruction, which disassebles
    into "ldw 0(sr3,r5),r9".
    This load-word instruction is part of __get_user() which tried to read the word
    at %r5/IOR (0xfa6f7fff). This means the unaligned handler jumped in.  The
    unaligned handler is able to emulate all ldw instructions, but it fails if it
    fails to read the source e.g. because of page fault.
    
    The following program reproduces the problem:
    
    #define _GNU_SOURCE
    #include <unistd.h>
    #include <sys/syscall.h>
    #include <sys/mman.h>
    
    int main(void) {
            /* allocate 8k */
            char *ptr = mmap(NULL, 2*4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
            /* free second half (upper 4k) and make it invalid. */
            munmap(ptr+4096, 4096);
            /* syscall where first int is unaligned and clobbers into invalid memory region */
            /* syscall should return EFAULT */
            return syscall(__NR_clock_adjtime, 0, ptr+4095);
    }
    
    To fix this issue we simply need to check if the faulting instruction address
    is in the exception fixup table when the unaligned handler failed. If it
    is, call the fixup routine instead of crashing.
    
    While looking at the unaligned handler I found another issue as well: The
    target register should not be modified if the handler was unsuccessful.
    
    Signed-off-by: Helge Deller <deller@gmx.de>
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>

commit 05e1ad39d5924a55255a39d4d404e81fe9685b58
Author: Helge Deller <deller@gmx.de>
Date:   Sat Jun 4 17:21:33 2016 +0200

    parisc: Fix pagefault crash in unaligned __get_user() call
    
    commit 8b78f260887df532da529f225c49195d18fef36b upstream.
    
    One of the debian buildd servers had this crash in the syslog without
    any other information:
    
     Unaligned handler failed, ret = -2
     clock_adjtime (pid 22578): Unaligned data reference (code 28)
     CPU: 1 PID: 22578 Comm: clock_adjtime Tainted: G  E  4.5.0-2-parisc64-smp #1 Debian 4.5.4-1
     task: 000000007d9960f8 ti: 00000001bde7c000 task.ti: 00000001bde7c000
    
          YZrvWESTHLNXBCVMcbcbcbcbOGFRQPDI
     PSW: 00001000000001001111100000001111 Tainted: G            E
     r00-03  000000ff0804f80f 00000001bde7c2b0 00000000402d2be8 00000001bde7c2b0
     r04-07  00000000409e1fd0 00000000fa6f7fff 00000001bde7c148 00000000fa6f7fff
     r08-11  0000000000000000 00000000ffffffff 00000000fac9bb7b 000000000002b4d4
     r12-15  000000000015241c 000000000015242c 000000000000002d 00000000fac9bb7b
     r16-19  0000000000028800 0000000000000001 0000000000000070 00000001bde7c218
     r20-23  0000000000000000 00000001bde7c210 0000000000000002 0000000000000000
     r24-27  0000000000000000 0000000000000000 00000001bde7c148 00000000409e1fd0
     r28-31  0000000000000001 00000001bde7c320 00000001bde7c350 00000001bde7c218
     sr00-03  0000000001200000 0000000001200000 0000000000000000 0000000001200000
     sr04-07  0000000000000000 0000000000000000 0000000000000000 0000000000000000
    
     IASQ: 0000000000000000 0000000000000000 IAOQ: 00000000402d2e84 00000000402d2e88
      IIR: 0ca0d089    ISR: 0000000001200000  IOR: 00000000fa6f7fff
      CPU:        1   CR30: 00000001bde7c000 CR31: ffffffffffffffff
      ORIG_R28: 00000002369fe628
      IAOQ[0]: compat_get_timex+0x2dc/0x3c0
      IAOQ[1]: compat_get_timex+0x2e0/0x3c0
      RP(r2): compat_get_timex+0x40/0x3c0
     Backtrace:
      [<00000000402d4608>] compat_SyS_clock_adjtime+0x40/0xc0
      [<0000000040205024>] syscall_exit+0x0/0x14
    
    This means the userspace program clock_adjtime called the clock_adjtime()
    syscall and then crashed inside the compat_get_timex() function.
    Syscalls should never crash programs, but instead return EFAULT.
    
    The IIR register contains the executed instruction, which disassebles
    into "ldw 0(sr3,r5),r9".
    This load-word instruction is part of __get_user() which tried to read the word
    at %r5/IOR (0xfa6f7fff). This means the unaligned handler jumped in.  The
    unaligned handler is able to emulate all ldw instructions, but it fails if it
    fails to read the source e.g. because of page fault.
    
    The following program reproduces the problem:
    
    #define _GNU_SOURCE
    #include <unistd.h>
    #include <sys/syscall.h>
    #include <sys/mman.h>
    
    int main(void) {
            /* allocate 8k */
            char *ptr = mmap(NULL, 2*4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
            /* free second half (upper 4k) and make it invalid. */
            munmap(ptr+4096, 4096);
            /* syscall where first int is unaligned and clobbers into invalid memory region */
            /* syscall should return EFAULT */
            return syscall(__NR_clock_adjtime, 0, ptr+4095);
    }
    
    To fix this issue we simply need to check if the faulting instruction address
    is in the exception fixup table when the unaligned handler failed. If it
    is, call the fixup routine instead of crashing.
    
    While looking at the unaligned handler I found another issue as well: The
    target register should not be modified if the handler was unsuccessful.
    
    Signed-off-by: Helge Deller <deller@gmx.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 1125f3b09513831b6863a1ed78fb0d1750105bfc
Author: Helge Deller <deller@gmx.de>
Date:   Sat Jun 4 17:21:33 2016 +0200

    parisc: Fix pagefault crash in unaligned __get_user() call
    
    commit 8b78f260887df532da529f225c49195d18fef36b upstream.
    
    One of the debian buildd servers had this crash in the syslog without
    any other information:
    
     Unaligned handler failed, ret = -2
     clock_adjtime (pid 22578): Unaligned data reference (code 28)
     CPU: 1 PID: 22578 Comm: clock_adjtime Tainted: G  E  4.5.0-2-parisc64-smp #1 Debian 4.5.4-1
     task: 000000007d9960f8 ti: 00000001bde7c000 task.ti: 00000001bde7c000
    
          YZrvWESTHLNXBCVMcbcbcbcbOGFRQPDI
     PSW: 00001000000001001111100000001111 Tainted: G            E
     r00-03  000000ff0804f80f 00000001bde7c2b0 00000000402d2be8 00000001bde7c2b0
     r04-07  00000000409e1fd0 00000000fa6f7fff 00000001bde7c148 00000000fa6f7fff
     r08-11  0000000000000000 00000000ffffffff 00000000fac9bb7b 000000000002b4d4
     r12-15  000000000015241c 000000000015242c 000000000000002d 00000000fac9bb7b
     r16-19  0000000000028800 0000000000000001 0000000000000070 00000001bde7c218
     r20-23  0000000000000000 00000001bde7c210 0000000000000002 0000000000000000
     r24-27  0000000000000000 0000000000000000 00000001bde7c148 00000000409e1fd0
     r28-31  0000000000000001 00000001bde7c320 00000001bde7c350 00000001bde7c218
     sr00-03  0000000001200000 0000000001200000 0000000000000000 0000000001200000
     sr04-07  0000000000000000 0000000000000000 0000000000000000 0000000000000000
    
     IASQ: 0000000000000000 0000000000000000 IAOQ: 00000000402d2e84 00000000402d2e88
      IIR: 0ca0d089    ISR: 0000000001200000  IOR: 00000000fa6f7fff
      CPU:        1   CR30: 00000001bde7c000 CR31: ffffffffffffffff
      ORIG_R28: 00000002369fe628
      IAOQ[0]: compat_get_timex+0x2dc/0x3c0
      IAOQ[1]: compat_get_timex+0x2e0/0x3c0
      RP(r2): compat_get_timex+0x40/0x3c0
     Backtrace:
      [<00000000402d4608>] compat_SyS_clock_adjtime+0x40/0xc0
      [<0000000040205024>] syscall_exit+0x0/0x14
    
    This means the userspace program clock_adjtime called the clock_adjtime()
    syscall and then crashed inside the compat_get_timex() function.
    Syscalls should never crash programs, but instead return EFAULT.
    
    The IIR register contains the executed instruction, which disassebles
    into "ldw 0(sr3,r5),r9".
    This load-word instruction is part of __get_user() which tried to read the word
    at %r5/IOR (0xfa6f7fff). This means the unaligned handler jumped in.  The
    unaligned handler is able to emulate all ldw instructions, but it fails if it
    fails to read the source e.g. because of page fault.
    
    The following program reproduces the problem:
    
    #define _GNU_SOURCE
    #include <unistd.h>
    #include <sys/syscall.h>
    #include <sys/mman.h>
    
    int main(void) {
            /* allocate 8k */
            char *ptr = mmap(NULL, 2*4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
            /* free second half (upper 4k) and make it invalid. */
            munmap(ptr+4096, 4096);
            /* syscall where first int is unaligned and clobbers into invalid memory region */
            /* syscall should return EFAULT */
            return syscall(__NR_clock_adjtime, 0, ptr+4095);
    }
    
    To fix this issue we simply need to check if the faulting instruction address
    is in the exception fixup table when the unaligned handler failed. If it
    is, call the fixup routine instead of crashing.
    
    While looking at the unaligned handler I found another issue as well: The
    target register should not be modified if the handler was unsuccessful.
    
    Signed-off-by: Helge Deller <deller@gmx.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 4d827bfbc042e1fc4da2cbac519946eebbe218a1
Author: Helge Deller <deller@gmx.de>
Date:   Sat Jun 4 17:21:33 2016 +0200

    parisc: Fix pagefault crash in unaligned __get_user() call
    
    commit 8b78f260887df532da529f225c49195d18fef36b upstream.
    
    One of the debian buildd servers had this crash in the syslog without
    any other information:
    
     Unaligned handler failed, ret = -2
     clock_adjtime (pid 22578): Unaligned data reference (code 28)
     CPU: 1 PID: 22578 Comm: clock_adjtime Tainted: G  E  4.5.0-2-parisc64-smp #1 Debian 4.5.4-1
     task: 000000007d9960f8 ti: 00000001bde7c000 task.ti: 00000001bde7c000
    
          YZrvWESTHLNXBCVMcbcbcbcbOGFRQPDI
     PSW: 00001000000001001111100000001111 Tainted: G            E
     r00-03  000000ff0804f80f 00000001bde7c2b0 00000000402d2be8 00000001bde7c2b0
     r04-07  00000000409e1fd0 00000000fa6f7fff 00000001bde7c148 00000000fa6f7fff
     r08-11  0000000000000000 00000000ffffffff 00000000fac9bb7b 000000000002b4d4
     r12-15  000000000015241c 000000000015242c 000000000000002d 00000000fac9bb7b
     r16-19  0000000000028800 0000000000000001 0000000000000070 00000001bde7c218
     r20-23  0000000000000000 00000001bde7c210 0000000000000002 0000000000000000
     r24-27  0000000000000000 0000000000000000 00000001bde7c148 00000000409e1fd0
     r28-31  0000000000000001 00000001bde7c320 00000001bde7c350 00000001bde7c218
     sr00-03  0000000001200000 0000000001200000 0000000000000000 0000000001200000
     sr04-07  0000000000000000 0000000000000000 0000000000000000 0000000000000000
    
     IASQ: 0000000000000000 0000000000000000 IAOQ: 00000000402d2e84 00000000402d2e88
      IIR: 0ca0d089    ISR: 0000000001200000  IOR: 00000000fa6f7fff
      CPU:        1   CR30: 00000001bde7c000 CR31: ffffffffffffffff
      ORIG_R28: 00000002369fe628
      IAOQ[0]: compat_get_timex+0x2dc/0x3c0
      IAOQ[1]: compat_get_timex+0x2e0/0x3c0
      RP(r2): compat_get_timex+0x40/0x3c0
     Backtrace:
      [<00000000402d4608>] compat_SyS_clock_adjtime+0x40/0xc0
      [<0000000040205024>] syscall_exit+0x0/0x14
    
    This means the userspace program clock_adjtime called the clock_adjtime()
    syscall and then crashed inside the compat_get_timex() function.
    Syscalls should never crash programs, but instead return EFAULT.
    
    The IIR register contains the executed instruction, which disassebles
    into "ldw 0(sr3,r5),r9".
    This load-word instruction is part of __get_user() which tried to read the word
    at %r5/IOR (0xfa6f7fff). This means the unaligned handler jumped in.  The
    unaligned handler is able to emulate all ldw instructions, but it fails if it
    fails to read the source e.g. because of page fault.
    
    The following program reproduces the problem:
    
    #define _GNU_SOURCE
    #include <unistd.h>
    #include <sys/syscall.h>
    #include <sys/mman.h>
    
    int main(void) {
            /* allocate 8k */
            char *ptr = mmap(NULL, 2*4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
            /* free second half (upper 4k) and make it invalid. */
            munmap(ptr+4096, 4096);
            /* syscall where first int is unaligned and clobbers into invalid memory region */
            /* syscall should return EFAULT */
            return syscall(__NR_clock_adjtime, 0, ptr+4095);
    }
    
    To fix this issue we simply need to check if the faulting instruction address
    is in the exception fixup table when the unaligned handler failed. If it
    is, call the fixup routine instead of crashing.
    
    While looking at the unaligned handler I found another issue as well: The
    target register should not be modified if the handler was unsuccessful.
    
    Signed-off-by: Helge Deller <deller@gmx.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit ec5ef4f89be8c7b14deb23a684b6adc3e4c3c220
Author: Helge Deller <deller@gmx.de>
Date:   Sat Jun 4 17:21:33 2016 +0200

    parisc: Fix pagefault crash in unaligned __get_user() call
    
    [ Upstream commit 8b78f260887df532da529f225c49195d18fef36b ]
    
    One of the debian buildd servers had this crash in the syslog without
    any other information:
    
     Unaligned handler failed, ret = -2
     clock_adjtime (pid 22578): Unaligned data reference (code 28)
     CPU: 1 PID: 22578 Comm: clock_adjtime Tainted: G  E  4.5.0-2-parisc64-smp #1 Debian 4.5.4-1
     task: 000000007d9960f8 ti: 00000001bde7c000 task.ti: 00000001bde7c000
    
          YZrvWESTHLNXBCVMcbcbcbcbOGFRQPDI
     PSW: 00001000000001001111100000001111 Tainted: G            E
     r00-03  000000ff0804f80f 00000001bde7c2b0 00000000402d2be8 00000001bde7c2b0
     r04-07  00000000409e1fd0 00000000fa6f7fff 00000001bde7c148 00000000fa6f7fff
     r08-11  0000000000000000 00000000ffffffff 00000000fac9bb7b 000000000002b4d4
     r12-15  000000000015241c 000000000015242c 000000000000002d 00000000fac9bb7b
     r16-19  0000000000028800 0000000000000001 0000000000000070 00000001bde7c218
     r20-23  0000000000000000 00000001bde7c210 0000000000000002 0000000000000000
     r24-27  0000000000000000 0000000000000000 00000001bde7c148 00000000409e1fd0
     r28-31  0000000000000001 00000001bde7c320 00000001bde7c350 00000001bde7c218
     sr00-03  0000000001200000 0000000001200000 0000000000000000 0000000001200000
     sr04-07  0000000000000000 0000000000000000 0000000000000000 0000000000000000
    
     IASQ: 0000000000000000 0000000000000000 IAOQ: 00000000402d2e84 00000000402d2e88
      IIR: 0ca0d089    ISR: 0000000001200000  IOR: 00000000fa6f7fff
      CPU:        1   CR30: 00000001bde7c000 CR31: ffffffffffffffff
      ORIG_R28: 00000002369fe628
      IAOQ[0]: compat_get_timex+0x2dc/0x3c0
      IAOQ[1]: compat_get_timex+0x2e0/0x3c0
      RP(r2): compat_get_timex+0x40/0x3c0
     Backtrace:
      [<00000000402d4608>] compat_SyS_clock_adjtime+0x40/0xc0
      [<0000000040205024>] syscall_exit+0x0/0x14
    
    This means the userspace program clock_adjtime called the clock_adjtime()
    syscall and then crashed inside the compat_get_timex() function.
    Syscalls should never crash programs, but instead return EFAULT.
    
    The IIR register contains the executed instruction, which disassebles
    into "ldw 0(sr3,r5),r9".
    This load-word instruction is part of __get_user() which tried to read the word
    at %r5/IOR (0xfa6f7fff). This means the unaligned handler jumped in.  The
    unaligned handler is able to emulate all ldw instructions, but it fails if it
    fails to read the source e.g. because of page fault.
    
    The following program reproduces the problem:
    
    #define _GNU_SOURCE
    #include <unistd.h>
    #include <sys/syscall.h>
    #include <sys/mman.h>
    
    int main(void) {
            /* allocate 8k */
            char *ptr = mmap(NULL, 2*4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
            /* free second half (upper 4k) and make it invalid. */
            munmap(ptr+4096, 4096);
            /* syscall where first int is unaligned and clobbers into invalid memory region */
            /* syscall should return EFAULT */
            return syscall(__NR_clock_adjtime, 0, ptr+4095);
    }
    
    To fix this issue we simply need to check if the faulting instruction address
    is in the exception fixup table when the unaligned handler failed. If it
    is, call the fixup routine instead of crashing.
    
    While looking at the unaligned handler I found another issue as well: The
    target register should not be modified if the handler was unsuccessful.
    
    Signed-off-by: Helge Deller <deller@gmx.de>
    Cc: stable@vger.kernel.org
    Signed-off-by: Sasha Levin <sasha.levin@oracle.com>

commit eb1eba6ac8e902b378d1196acb1026e91c40e736
Author: Helge Deller <deller@gmx.de>
Date:   Sat Jun 4 17:21:33 2016 +0200

    parisc: Fix pagefault crash in unaligned __get_user() call
    
    [ Upstream commit 8b78f260887df532da529f225c49195d18fef36b ]
    
    One of the debian buildd servers had this crash in the syslog without
    any other information:
    
     Unaligned handler failed, ret = -2
     clock_adjtime (pid 22578): Unaligned data reference (code 28)
     CPU: 1 PID: 22578 Comm: clock_adjtime Tainted: G  E  4.5.0-2-parisc64-smp #1 Debian 4.5.4-1
     task: 000000007d9960f8 ti: 00000001bde7c000 task.ti: 00000001bde7c000
    
          YZrvWESTHLNXBCVMcbcbcbcbOGFRQPDI
     PSW: 00001000000001001111100000001111 Tainted: G            E
     r00-03  000000ff0804f80f 00000001bde7c2b0 00000000402d2be8 00000001bde7c2b0
     r04-07  00000000409e1fd0 00000000fa6f7fff 00000001bde7c148 00000000fa6f7fff
     r08-11  0000000000000000 00000000ffffffff 00000000fac9bb7b 000000000002b4d4
     r12-15  000000000015241c 000000000015242c 000000000000002d 00000000fac9bb7b
     r16-19  0000000000028800 0000000000000001 0000000000000070 00000001bde7c218
     r20-23  0000000000000000 00000001bde7c210 0000000000000002 0000000000000000
     r24-27  0000000000000000 0000000000000000 00000001bde7c148 00000000409e1fd0
     r28-31  0000000000000001 00000001bde7c320 00000001bde7c350 00000001bde7c218
     sr00-03  0000000001200000 0000000001200000 0000000000000000 0000000001200000
     sr04-07  0000000000000000 0000000000000000 0000000000000000 0000000000000000
    
     IASQ: 0000000000000000 0000000000000000 IAOQ: 00000000402d2e84 00000000402d2e88
      IIR: 0ca0d089    ISR: 0000000001200000  IOR: 00000000fa6f7fff
      CPU:        1   CR30: 00000001bde7c000 CR31: ffffffffffffffff
      ORIG_R28: 00000002369fe628
      IAOQ[0]: compat_get_timex+0x2dc/0x3c0
      IAOQ[1]: compat_get_timex+0x2e0/0x3c0
      RP(r2): compat_get_timex+0x40/0x3c0
     Backtrace:
      [<00000000402d4608>] compat_SyS_clock_adjtime+0x40/0xc0
      [<0000000040205024>] syscall_exit+0x0/0x14
    
    This means the userspace program clock_adjtime called the clock_adjtime()
    syscall and then crashed inside the compat_get_timex() function.
    Syscalls should never crash programs, but instead return EFAULT.
    
    The IIR register contains the executed instruction, which disassebles
    into "ldw 0(sr3,r5),r9".
    This load-word instruction is part of __get_user() which tried to read the word
    at %r5/IOR (0xfa6f7fff). This means the unaligned handler jumped in.  The
    unaligned handler is able to emulate all ldw instructions, but it fails if it
    fails to read the source e.g. because of page fault.
    
    The following program reproduces the problem:
    
    #define _GNU_SOURCE
    #include <unistd.h>
    #include <sys/syscall.h>
    #include <sys/mman.h>
    
    int main(void) {
            /* allocate 8k */
            char *ptr = mmap(NULL, 2*4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
            /* free second half (upper 4k) and make it invalid. */
            munmap(ptr+4096, 4096);
            /* syscall where first int is unaligned and clobbers into invalid memory region */
            /* syscall should return EFAULT */
            return syscall(__NR_clock_adjtime, 0, ptr+4095);
    }
    
    To fix this issue we simply need to check if the faulting instruction address
    is in the exception fixup table when the unaligned handler failed. If it
    is, call the fixup routine instead of crashing.
    
    While looking at the unaligned handler I found another issue as well: The
    target register should not be modified if the handler was unsuccessful.
    
    Signed-off-by: Helge Deller <deller@gmx.de>
    Cc: stable@vger.kernel.org
    Signed-off-by: Sasha Levin <sasha.levin@oracle.com>

commit 8b78f260887df532da529f225c49195d18fef36b
Author: Helge Deller <deller@gmx.de>
Date:   Sat Jun 4 17:21:33 2016 +0200

    parisc: Fix pagefault crash in unaligned __get_user() call
    
    One of the debian buildd servers had this crash in the syslog without
    any other information:
    
     Unaligned handler failed, ret = -2
     clock_adjtime (pid 22578): Unaligned data reference (code 28)
     CPU: 1 PID: 22578 Comm: clock_adjtime Tainted: G  E  4.5.0-2-parisc64-smp #1 Debian 4.5.4-1
     task: 000000007d9960f8 ti: 00000001bde7c000 task.ti: 00000001bde7c000
    
          YZrvWESTHLNXBCVMcbcbcbcbOGFRQPDI
     PSW: 00001000000001001111100000001111 Tainted: G            E
     r00-03  000000ff0804f80f 00000001bde7c2b0 00000000402d2be8 00000001bde7c2b0
     r04-07  00000000409e1fd0 00000000fa6f7fff 00000001bde7c148 00000000fa6f7fff
     r08-11  0000000000000000 00000000ffffffff 00000000fac9bb7b 000000000002b4d4
     r12-15  000000000015241c 000000000015242c 000000000000002d 00000000fac9bb7b
     r16-19  0000000000028800 0000000000000001 0000000000000070 00000001bde7c218
     r20-23  0000000000000000 00000001bde7c210 0000000000000002 0000000000000000
     r24-27  0000000000000000 0000000000000000 00000001bde7c148 00000000409e1fd0
     r28-31  0000000000000001 00000001bde7c320 00000001bde7c350 00000001bde7c218
     sr00-03  0000000001200000 0000000001200000 0000000000000000 0000000001200000
     sr04-07  0000000000000000 0000000000000000 0000000000000000 0000000000000000
    
     IASQ: 0000000000000000 0000000000000000 IAOQ: 00000000402d2e84 00000000402d2e88
      IIR: 0ca0d089    ISR: 0000000001200000  IOR: 00000000fa6f7fff
      CPU:        1   CR30: 00000001bde7c000 CR31: ffffffffffffffff
      ORIG_R28: 00000002369fe628
      IAOQ[0]: compat_get_timex+0x2dc/0x3c0
      IAOQ[1]: compat_get_timex+0x2e0/0x3c0
      RP(r2): compat_get_timex+0x40/0x3c0
     Backtrace:
      [<00000000402d4608>] compat_SyS_clock_adjtime+0x40/0xc0
      [<0000000040205024>] syscall_exit+0x0/0x14
    
    This means the userspace program clock_adjtime called the clock_adjtime()
    syscall and then crashed inside the compat_get_timex() function.
    Syscalls should never crash programs, but instead return EFAULT.
    
    The IIR register contains the executed instruction, which disassebles
    into "ldw 0(sr3,r5),r9".
    This load-word instruction is part of __get_user() which tried to read the word
    at %r5/IOR (0xfa6f7fff). This means the unaligned handler jumped in.  The
    unaligned handler is able to emulate all ldw instructions, but it fails if it
    fails to read the source e.g. because of page fault.
    
    The following program reproduces the problem:
    
    #define _GNU_SOURCE
    #include <unistd.h>
    #include <sys/syscall.h>
    #include <sys/mman.h>
    
    int main(void) {
            /* allocate 8k */
            char *ptr = mmap(NULL, 2*4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
            /* free second half (upper 4k) and make it invalid. */
            munmap(ptr+4096, 4096);
            /* syscall where first int is unaligned and clobbers into invalid memory region */
            /* syscall should return EFAULT */
            return syscall(__NR_clock_adjtime, 0, ptr+4095);
    }
    
    To fix this issue we simply need to check if the faulting instruction address
    is in the exception fixup table when the unaligned handler failed. If it
    is, call the fixup routine instead of crashing.
    
    While looking at the unaligned handler I found another issue as well: The
    target register should not be modified if the handler was unsuccessful.
    
    Signed-off-by: Helge Deller <deller@gmx.de>
    Cc: stable@vger.kernel.org

commit dc799d0179baa7f62d2e73a8217a273ca82adbdf
Merge: 7ab85d4a8516 1ca8ec532fc2
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Jan 31 15:49:06 2016 -0800

    Merge branch 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer fixes from Thomas Gleixner:
     "The timer departement delivers:
    
       - a regression fix for the NTP code along with a proper selftest
       - prevent a spurious timer interrupt in the NOHZ lowres code
       - a fix for user space interfaces returning the remaining time on
         architectures with CONFIG_TIME_LOW_RES=y
       - a few patches to fix COMPILE_TEST fallout"
    
    * 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      tick/nohz: Set the correct expiry when switching to nohz/lowres mode
      clocksource: Fix dependencies for archs w/o HAS_IOMEM
      clocksource: Select CLKSRC_MMIO where needed
      tick/sched: Hide unused oneshot timer code
      kselftests: timers: Add adjtimex SETOFFSET validity tests
      ntp: Fix ADJ_SETOFFSET being used w/ ADJ_NANO
      itimers: Handle relative timers with CONFIG_TIME_LOW_RES proper
      posix-timers: Handle relative timers with CONFIG_TIME_LOW_RES proper
      timerfd: Handle relative timers with CONFIG_TIME_LOW_RES proper
      hrtimer: Handle remaining time proper for TIME_LOW_RES
      clockevents/tcb_clksrc: Prevent disabling an already disabled clock

commit e03a58c320e1103ebe97bda8ebdfcc5c9829c53f
Author: John Stultz <john.stultz@linaro.org>
Date:   Thu Jan 21 15:03:35 2016 -0800

    kselftests: timers: Add adjtimex SETOFFSET validity tests
    
    Add some simple tests to check both valid and invalid
    offsets when using adjtimex's ADJ_SETOFFSET method.
    
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Acked-by: Shuah Khan <shuahkh@osg.samsung.com>
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Harald Hoyer <harald@redhat.com>
    Cc: Kay Sievers <kay@vrfy.org>
    Cc: David Herrmann <dh.herrmann@gmail.com>
    Link: http://lkml.kernel.org/r/1453417415-19110-3-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit dd4e17ab704269bce71402285f5e8b9ac24b1eff
Author: John Stultz <john.stultz@linaro.org>
Date:   Thu Jan 21 15:03:34 2016 -0800

    ntp: Fix ADJ_SETOFFSET being used w/ ADJ_NANO
    
    Recently, in commit 37cf4dc3370f I forgot to check if the timeval being passed
    was actually a timespec (as is signaled with ADJ_NANO).
    
    This resulted in that patch breaking ADJ_SETOFFSET users who set
    ADJ_NANO, by rejecting valid timespecs that were compared with
    valid timeval ranges.
    
    This patch addresses this by checking for the ADJ_NANO flag and
    using the timepsec check instead in that case.
    
    Reported-by: Harald Hoyer <harald@redhat.com>
    Reported-by: Kay Sievers <kay@vrfy.org>
    Fixes: 37cf4dc3370f "time: Verify time values in adjtimex ADJ_SETOFFSET to avoid overflow"
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: David Herrmann <dh.herrmann@gmail.com>
    Link: http://lkml.kernel.org/r/1453417415-19110-2-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit ec02b076ceab63f99e5b3d80fd223d777266c236
Author: John Stultz <john.stultz@linaro.org>
Date:   Thu Dec 3 10:23:30 2015 -0800

    timekeeping: Cap adjustments so they don't exceed the maxadj value
    
    Thus its been occasionally noted that users have seen
    confusing warnings like:
    
        Adjusting tsc more than 11% (5941981 vs 7759439)
    
    We try to limit the maximum total adjustment to 11% (10% tick
    adjustment + 0.5% frequency adjustment). But this is done by
    bounding the requested adjustment values, and the internal
    steering that is done by tracking the error from what was
    requested and what was applied, does not have any such limits.
    
    This is usually not problematic, but in some cases has a risk
    that an adjustment could cause the clocksource mult value to
    overflow, so its an indication things are outside of what is
    expected.
    
    It ends up most of the reports of this 11% warning are on systems
    using chrony, which utilizes the adjtimex() ADJ_TICK interface
    (which allows a +-10% adjustment). The original rational for
    ADJ_TICK unclear to me but my assumption it was originally added
    to allow broken systems to get a big constant correction at boot
    (see adjtimex userspace package for an example) which would allow
    the system to work w/ ntpd's 0.5% adjustment limit.
    
    Chrony uses ADJ_TICK to make very aggressive short term corrections
    (usually right at startup). Which push us close enough to the max
    bound that a few late ticks can cause the internal steering to push
    past the max adjust value (tripping the warning).
    
    Thus this patch adds some extra logic to enforce the max adjustment
    cap in the internal steering.
    
    Note: This has the potential to slow corrections when the ADJ_TICK
    value is furthest away from the default value. So it would be good to
    get some testing from folks using chrony, to make sure we don't
    cause any troubles there.
    
    Cc: Miroslav Lichvar <mlichvar@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Tested-by: Miroslav Lichvar <mlichvar@redhat.com>
    Reported-by: Andy Lutomirski <luto@kernel.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 37cf4dc3370fbca0344e23bb96446eb2c3548ba7
Author: John Stultz <john.stultz@linaro.org>
Date:   Thu Dec 3 22:09:31 2015 -0500

    time: Verify time values in adjtimex ADJ_SETOFFSET to avoid overflow
    
    For adjtimex()'s ADJ_SETOFFSET, make sure the tv_usec value is
    sane. We might multiply them later which can cause an overflow
    and undefined behavior.
    
    This patch introduces new helper functions to simplify the
    checking code and adds comments to clarify
    
    Orginally this patch was by Sasha Levin, but I've basically
    rewritten it, so he should get credit for finding the issue
    and I should get the blame for any mistakes made since.
    
    Also, credit to Richard Cochran for the phrasing used in the
    comment for what is considered valid here.
    
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Reported-by: Sasha Levin <sasha.levin@oracle.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit c8299cb605b27dd5a49f7a69e48fd23e5a206298
Author: Michal Nazarewicz <mina86@mina86.com>
Date:   Mon Nov 9 14:58:10 2015 -0800

    kernel.h: make abs() work with 64-bit types
    
    For 64-bit arguments, the abs macro casts it to an int which leads to
    lost precision and may cause incorrect results.  To deal with 64-bit
    types abs64 macro has been introduced but still there are places where
    abs macro is used incorrectly.
    
    To deal with the problem, expand abs macro such that it operates on s64
    type when dealing with 64-bit types while still returning long when
    dealing with smaller types.
    
    This fixes one known bug (per John):
    
    The internal clocksteering done for fine-grained error correction uses a
    : logarithmic approximation, so any time adjtimex() adjusts the clock
    : steering, timekeeping_freqadjust() quickly approximates the correct clock
    : frequency over a series of ticks.
    :
    : Unfortunately, the logic in timekeeping_freqadjust(), introduced in commit
    : dc491596f639438 (Rework frequency adjustments to work better w/ nohz),
    : used the abs() function with a s64 error value to calculate the size of
    : the approximated adjustment to be made.
    :
    : Per include/linux/kernel.h: "abs() should not be used for 64-bit types
    : (s64, u64, long long) - use abs64()".
    :
    : Thus on 32-bit platforms, this resulted in the clocksteering to take a
    : quite dampended random walk trying to converge on the proper frequency,
    : which caused the adjustments to be made much slower then intended (most
    : easily observed when large adjustments are made).
    
    Signed-off-by: Michal Nazarewicz <mina86@mina86.com>
    Reported-by: John Stultz <john.stultz@linaro.org>
    Tested-by: John Stultz <john.stultz@linaro.org>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit b02ac6b18cd4e2c76bf0a102c20c429b973f5f76
Merge: 105ff3cbf225 bebd23a2ed31
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Nov 3 17:38:09 2015 -0800

    Merge branch 'perf-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull perf updates from Ingo Molnar:
     "Kernel side changes:
    
       - Improve accuracy of perf/sched clock on x86.  (Adrian Hunter)
    
       - Intel DS and BTS updates.  (Alexander Shishkin)
    
       - Intel cstate PMU support.  (Kan Liang)
    
       - Add group read support to perf_event_read().  (Peter Zijlstra)
    
       - Branch call hardware sampling support, implemented on x86 and
         PowerPC.  (Stephane Eranian)
    
       - Event groups transactional interface enhancements.  (Sukadev
         Bhattiprolu)
    
       - Enable proper x86/intel/uncore PMU support on multi-segment PCI
         systems.  (Taku Izumi)
    
       - ... misc fixes and cleanups.
    
      The perf tooling team was very busy again with 200+ commits, the full
      diff doesn't fit into lkml size limits.  Here's an (incomplete) list
      of the tooling highlights:
    
      New features:
    
       - Change the default event used in all tools (record/top): use the
         most precise "cycles" hw counter available, i.e. when the user
         doesn't specify any event, it will try using cycles:ppp, cycles:pp,
         etc and fall back transparently until it finds a working counter.
         (Arnaldo Carvalho de Melo)
    
       - Integration of perf with eBPF that, given an eBPF .c source file
         (or .o file built for the 'bpf' target with clang), will get it
         automatically built, validated and loaded into the kernel via the
         sys_bpf syscall, which can then be used and seen using 'perf trace'
         and other tools.
    
         (Wang Nan)
    
      Various user interface improvements:
    
       - Automatic pager invocation on long help output.  (Namhyung Kim)
    
       - Search for more options when passing args to -h, e.g.: (Arnaldo
         Carvalho de Melo)
    
            $ perf report -h interface
    
            Usage: perf report [<options>]
    
             --gtk    Use the GTK2 interface
             --stdio  Use the stdio interface
             --tui    Use the TUI interface
    
       - Show ordered command line options when -h is used or when an
         unknown option is specified.  (Arnaldo Carvalho de Melo)
    
       - If options are passed after -h, show just its descriptions, not all
         options.  (Arnaldo Carvalho de Melo)
    
       - Implement column based horizontal scrolling in the hists browser
         (top, report), making it possible to use the TUI for things like
         'perf mem report' where there are many more columns than can fit in
         a terminal.  (Arnaldo Carvalho de Melo)
    
       - Enhance the error reporting of tracepoint event parsing, e.g.:
    
           $ oldperf record -e sched:sched_switc usleep 1
           event syntax error: 'sched:sched_switc'
                                \___ unknown tracepoint
           Run 'perf list' for a list of valid events
    
         Now we get the much nicer:
    
           $ perf record -e sched:sched_switc ls
           event syntax error: 'sched:sched_switc'
                                \___ can't access trace events
    
           Error: No permissions to read /sys/kernel/debug/tracing/events/sched/sched_switc
           Hint:  Try 'sudo mount -o remount,mode=755 /sys/kernel/debug'
    
         And after we have those mount point permissions fixed:
    
           $ perf record -e sched:sched_switc ls
           event syntax error: 'sched:sched_switc'
                                \___ unknown tracepoint
    
           Error: File /sys/kernel/debug/tracing/events/sched/sched_switc not found.
           Hint:  Perhaps this kernel misses some CONFIG_ setting to enable this feature?.
    
         I.e.  basically now the event parsing routing uses the strerror_open()
         routines introduced by and used in 'perf trace' work.  (Jiri Olsa)
    
       - Fail properly when pattern matching fails to find a tracepoint,
         i.e. '-e non:existent' was being correctly handled, with a proper
         error message about that not being a valid event, but '-e
         non:existent*' wasn't, fix it.  (Jiri Olsa)
    
       - Do event name substring search as last resort in 'perf list'.
         (Arnaldo Carvalho de Melo)
    
         E.g.:
    
           # perf list clock
    
           List of pre-defined events (to be used in -e):
    
            cpu-clock                                          [Software event]
            task-clock                                         [Software event]
    
            uncore_cbox_0/clockticks/                          [Kernel PMU event]
            uncore_cbox_1/clockticks/                          [Kernel PMU event]
    
            kvm:kvm_pvclock_update                             [Tracepoint event]
            kvm:kvm_update_master_clock                        [Tracepoint event]
            power:clock_disable                                [Tracepoint event]
            power:clock_enable                                 [Tracepoint event]
            power:clock_set_rate                               [Tracepoint event]
            syscalls:sys_enter_clock_adjtime                   [Tracepoint event]
            syscalls:sys_enter_clock_getres                    [Tracepoint event]
            syscalls:sys_enter_clock_gettime                   [Tracepoint event]
            syscalls:sys_enter_clock_nanosleep                 [Tracepoint event]
            syscalls:sys_enter_clock_settime                   [Tracepoint event]
            syscalls:sys_exit_clock_adjtime                    [Tracepoint event]
            syscalls:sys_exit_clock_getres                     [Tracepoint event]
            syscalls:sys_exit_clock_gettime                    [Tracepoint event]
            syscalls:sys_exit_clock_nanosleep                  [Tracepoint event]
            syscalls:sys_exit_clock_settime                    [Tracepoint event]
    
      Intel PT hardware tracing enhancements:
    
       - Accept a zero --itrace period, meaning "as often as possible".  In
         the case of Intel PT that is the same as a period of 1 and a unit
         of 'instructions' (i.e.  --itrace=i1i).  (Adrian Hunter)
    
       - Harmonize itrace's synthesized callchains with the existing
         --max-stack tool option.  (Adrian Hunter)
    
       - Allow time to be displayed in nanoseconds in 'perf script'.
         (Adrian Hunter)
    
       - Fix potential infinite loop when handling Intel PT timestamps.
         (Adrian Hunter)
    
       - Slighly improve Intel PT debug logging.  (Adrian Hunter)
    
       - Warn when AUX data has been lost, just like when processing
         PERF_RECORD_LOST.  (Adrian Hunter)
    
       - Further document export-to-postgresql.py script.  (Adrian Hunter)
    
       - Add option to synthesize branch stack from auxtrace data.  (Adrian
         Hunter)
    
      Misc notable changes:
    
       - Switch the default callchain output mode to 'graph,0.5,caller', to
         make it look like the default for other tools, reducing the
         learning curve for people used to 'caller' based viewing.  (Arnaldo
         Carvalho de Melo)
    
       - various call chain usability enhancements.  (Namhyung Kim)
    
       - Introduce the 'P' event modifier, meaning 'max precision level,
         please', i.e.:
    
            $ perf record -e cycles:P usleep 1
    
         Is now similar to:
    
            $ perf record usleep 1
    
         Useful, for instance, when specifying multiple events.  (Jiri Olsa)
    
       - Add 'socket' sort entry, to sort by the processor socket in 'perf
         top' and 'perf report'.  (Kan Liang)
    
       - Introduce --socket-filter to 'perf report', for filtering by
         processor socket.  (Kan Liang)
    
       - Add new "Zoom into Processor Socket" operation in the perf hists
         browser, used in 'perf top' and 'perf report'.  (Kan Liang)
    
       - Allow probing on kmodules without DWARF.  (Masami Hiramatsu)
    
       - Fix 'perf probe -l' for probes added to kernel module functions.
         (Masami Hiramatsu)
    
       - Preparatory work for the 'perf stat record' feature that will allow
         generating perf.data files with counting data in addition to the
         sampling mode we have now (Jiri Olsa)
    
       - Update libtraceevent KVM plugin.  (Paolo Bonzini)
    
       - ... plus lots of other enhancements that I failed to list properly,
         by: Adrian Hunter, Alexander Shishkin, Andi Kleen, Andrzej Hajda,
         Arnaldo Carvalho de Melo, Dima Kogan, Don Zickus, Geliang Tang, He
         Kuang, Huaitong Han, Ingo Molnar, Jan Stancek, Jiri Olsa, Kan
         Liang, Kirill Tkhai, Masami Hiramatsu, Matt Fleming, Namhyung Kim,
         Paolo Bonzini, Peter Zijlstra, Rabin Vincent, Scott Wood, Stephane
         Eranian, Sukadev Bhattiprolu, Taku Izumi, Vaishali Thakkar, Wang
         Nan, Yang Shi and Yunlong Song"
    
    * 'perf-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (260 commits)
      perf unwind: Pass symbol source to libunwind
      tools build: Fix libiberty feature detection
      perf tools: Compile scriptlets to BPF objects when passing '.c' to --event
      perf record: Add clang options for compiling BPF scripts
      perf bpf: Attach eBPF filter to perf event
      perf tools: Make sure fixdep is built before libbpf
      perf script: Enable printing of branch stack
      perf trace: Add cmd string table to decode sys_bpf first arg
      perf bpf: Collect perf_evsel in BPF object files
      perf tools: Load eBPF object into kernel
      perf tools: Create probe points for BPF programs
      perf tools: Enable passing bpf object file to --event
      perf ebpf: Add the libbpf glue
      perf tools: Make perf depend on libbpf
      perf symbols: Fix endless loop in dso__split_kallsyms_for_kcore
      perf tools: Enable pre-event inherit setting by config terms
      perf symbols: we can now read separate debug-info files based on a build ID
      perf symbols: Fix type error when reading a build-id
      perf tools: Search for more options when passing args to -h
      perf stat: Cache aggregated map entries in extra cpumap
      ...

commit 7b2a4306f9e7d64bb408a6df3bb419500578068a
Merge: 316dde2fe95b 03f136a2074b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Nov 3 14:13:41 2015 -0800

    Merge branch 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer updates from Thomas Gleixner:
     "The timer departement provides:
    
       - More y2038 work in the area of ntp and pps.
    
       - Optimization of posix cpu timers
    
       - New time related selftests
    
       - Some new clocksource drivers
    
       - The usual pile of fixes, cleanups and improvements"
    
    * 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (25 commits)
      timeconst: Update path in comment
      timers/x86/hpet: Type adjustments
      clocksource/drivers/armada-370-xp: Implement ARM delay timer
      clocksource/drivers/tango_xtal: Add new timer for Tango SoCs
      clocksource/drivers/imx: Allow timer irq affinity change
      clocksource/drivers/exynos_mct: Use container_of() instead of this_cpu_ptr()
      clocksource/drivers/h8300_*: Remove unneeded memset()s
      clocksource/drivers/sh_cmt: Remove unneeded memset() in sh_cmt_setup()
      clocksource/drivers/em_sti: Remove unneeded memset()s
      clocksource/drivers/mediatek: Use GPT as sched clock source
      clockevents/drivers/mtk: Fix spurious interrupt leading to crash
      posix_cpu_timer: Reduce unnecessary sighand lock contention
      posix_cpu_timer: Convert cputimer->running to bool
      posix_cpu_timer: Check thread timers only when there are active thread timers
      posix_cpu_timer: Optimize fastpath_timer_check()
      timers, kselftest: Add 'adjtick' test to validate adjtimex() tick adjustments
      timers: Use __fls in apply_slack()
      clocksource: Remove return statement from void functions
      net: sfc: avoid using timespec
      ntp/pps: use y2038 safe types in pps_event_time
      ...

commit 1dbcfc2dcd84d2b2781fb8611fb4bcd3792c32ae
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Sep 9 16:07:30 2015 -0700

    time: Fix timekeeping_freqadjust()'s incorrect use of abs() instead of abs64()
    
    [ Upstream commit 2619d7e9c92d524cb155ec89fd72875321512e5b ]
    
    The internal clocksteering done for fine-grained error
    correction uses a logarithmic approximation, so any time
    adjtimex() adjusts the clock steering, timekeeping_freqadjust()
    quickly approximates the correct clock frequency over a series
    of ticks.
    
    Unfortunately, the logic in timekeeping_freqadjust(), introduced
    in commit:
    
      dc491596f639 ("timekeeping: Rework frequency adjustments to work better w/ nohz")
    
    used the abs() function with a s64 error value to calculate the
    size of the approximated adjustment to be made.
    
    Per include/linux/kernel.h:
    
      "abs() should not be used for 64-bit types (s64, u64, long long) - use abs64()".
    
    Thus on 32-bit platforms, this resulted in the clocksteering to
    take a quite dampended random walk trying to converge on the
    proper frequency, which caused the adjustments to be made much
    slower then intended (most easily observed when large
    adjustments are made).
    
    This patch fixes the issue by using abs64() instead.
    
    Reported-by: Nuno Gonçalves <nunojpg@gmail.com>
    Tested-by: Nuno Goncalves <nunojpg@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: <stable@vger.kernel.org> # v3.17+
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Miroslav Lichvar <mlichvar@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/1441840051-20244-1-git-send-email-john.stultz@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Sasha Levin <sasha.levin@oracle.com>

commit d6402e4ecf0d9a3ec9ceee9d218dcc7605611df7
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Sep 9 16:07:30 2015 -0700

    time: Fix timekeeping_freqadjust()'s incorrect use of abs() instead of abs64()
    
    commit 2619d7e9c92d524cb155ec89fd72875321512e5b upstream.
    
    The internal clocksteering done for fine-grained error
    correction uses a logarithmic approximation, so any time
    adjtimex() adjusts the clock steering, timekeeping_freqadjust()
    quickly approximates the correct clock frequency over a series
    of ticks.
    
    Unfortunately, the logic in timekeeping_freqadjust(), introduced
    in commit:
    
      dc491596f639 ("timekeeping: Rework frequency adjustments to work better w/ nohz")
    
    used the abs() function with a s64 error value to calculate the
    size of the approximated adjustment to be made.
    
    Per include/linux/kernel.h:
    
      "abs() should not be used for 64-bit types (s64, u64, long long) - use abs64()".
    
    Thus on 32-bit platforms, this resulted in the clocksteering to
    take a quite dampended random walk trying to converge on the
    proper frequency, which caused the adjustments to be made much
    slower then intended (most easily observed when large
    adjustments are made).
    
    This patch fixes the issue by using abs64() instead.
    
    Reported-by: Nuno Gonçalves <nunojpg@gmail.com>
    Tested-by: Nuno Goncalves <nunojpg@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Miroslav Lichvar <mlichvar@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/1441840051-20244-1-git-send-email-john.stultz@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit a5428d82f04e051e9c0d1da2b353c21be01600c7
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Sep 9 16:07:30 2015 -0700

    time: Fix timekeeping_freqadjust()'s incorrect use of abs() instead of abs64()
    
    commit 2619d7e9c92d524cb155ec89fd72875321512e5b upstream.
    
    The internal clocksteering done for fine-grained error
    correction uses a logarithmic approximation, so any time
    adjtimex() adjusts the clock steering, timekeeping_freqadjust()
    quickly approximates the correct clock frequency over a series
    of ticks.
    
    Unfortunately, the logic in timekeeping_freqadjust(), introduced
    in commit:
    
      dc491596f639 ("timekeeping: Rework frequency adjustments to work better w/ nohz")
    
    used the abs() function with a s64 error value to calculate the
    size of the approximated adjustment to be made.
    
    Per include/linux/kernel.h:
    
      "abs() should not be used for 64-bit types (s64, u64, long long) - use abs64()".
    
    Thus on 32-bit platforms, this resulted in the clocksteering to
    take a quite dampended random walk trying to converge on the
    proper frequency, which caused the adjustments to be made much
    slower then intended (most easily observed when large
    adjustments are made).
    
    This patch fixes the issue by using abs64() instead.
    
    Reported-by: Nuno Gonçalves <nunojpg@gmail.com>
    Tested-by: Nuno Goncalves <nunojpg@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Miroslav Lichvar <mlichvar@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/1441840051-20244-1-git-send-email-john.stultz@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 6035519fcf5aa17084b41790cdc584d881d82c03
Author: John Stultz <john.stultz@linaro.org>
Date:   Mon Oct 5 18:16:57 2015 -0700

    timers, kselftest: Add 'adjtick' test to validate adjtimex() tick adjustments
    
    Recently a kernel side NTP bug was fixed via the following commit:
    
      2619d7e9c92d ("time: Fix timekeeping_freqadjust()'s incorrect use of abs() instead of abs64()")
    
    When the bug was reported it was difficult to detect, except by
    tweaking the adjtimex tick value, and noticing how quickly the
    adjustment took:
    
            https://lkml.org/lkml/2015/9/1/488
    
    Thus this patch introduces a new test which manipulates the
    adjtimex tick value and validates that the results are what we
    expect.
    
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Miroslav Lichvar <mlichvar@redhat.com>
    Cc: Nuno Gonçalves <nunojpg@gmail.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Shuah Khan <shuahkh@osg.samsung.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/1444094217-20258-1-git-send-email-john.stultz@linaro.org
    [ Tidied up the code and the changelog a bit. ]
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit e3b0ac1b7a8a590440a2030e7d10d48c59ab8a2a
Merge: c2365b9388e8 19afd1041095
Author: Ingo Molnar <mingo@kernel.org>
Date:   Sat Oct 3 08:20:14 2015 +0200

    Merge tag 'perf-core-for-mingo' of git://git.kernel.org/pub/scm/linux/kernel/git/acme/linux into perf/core
    
    Pull perf/core improvements and fixes from Arnaldo Carvalho de Melo:
    
    User visible changes:
    
     - Do event name substring search as last resort in 'perf list'.
       (Arnaldo Carvalho de Melo)
    
       E.g.:
    
        # perf list clock
    
        List of pre-defined events (to be used in -e):
    
         cpu-clock                                          [Software event]
         task-clock                                         [Software event]
    
         uncore_cbox_0/clockticks/                          [Kernel PMU event]
         uncore_cbox_1/clockticks/                          [Kernel PMU event]
    
         kvm:kvm_pvclock_update                             [Tracepoint event]
         kvm:kvm_update_master_clock                        [Tracepoint event]
         power:clock_disable                                [Tracepoint event]
         power:clock_enable                                 [Tracepoint event]
         power:clock_set_rate                               [Tracepoint event]
         syscalls:sys_enter_clock_adjtime                   [Tracepoint event]
         syscalls:sys_enter_clock_getres                    [Tracepoint event]
         syscalls:sys_enter_clock_gettime                   [Tracepoint event]
         syscalls:sys_enter_clock_nanosleep                 [Tracepoint event]
         syscalls:sys_enter_clock_settime                   [Tracepoint event]
         syscalls:sys_exit_clock_adjtime                    [Tracepoint event]
         syscalls:sys_exit_clock_getres                     [Tracepoint event]
         syscalls:sys_exit_clock_gettime                    [Tracepoint event]
         syscalls:sys_exit_clock_nanosleep                  [Tracepoint event]
         syscalls:sys_exit_clock_settime                    [Tracepoint event]
    
     - Reduce min 'perf stat --interval-print/-I' to 10ms. (Kan Liang)
    
       perf stat --interval in action:
    
       # perf stat -e cycles -I 50 -a usleep $((200 * 1000))
       print interval < 100ms. The overhead percentage could be high in some cases. Please proceed with caution.
       #   time                    counts unit events
          0.050233636         48,240,396      cycles
          0.100557098         35,492,594      cycles
          0.150804687         39,295,112      cycles
          0.201032269         33,101,961      cycles
          0.201980732            786,379      cycles
      #
    
     - Allow for max_stack greater than PERF_MAX_STACK_DEPTH, as when
       synthesizing callchains from Intel PT data. (Adrian Hunter)
    
     - Allow probing on kmodules without DWARF. (Masami Hiramatsu)
    
     - Fix a segfault when processing a perf.data file with callchains using
       "perf report --call-graph none". (Namhyung Kim)
    
     - Fix unresolved COMMs in 'perf top' when -s comm is used. (Namhyung Kim)
    
     - Register idle thread in 'perf top'. (Namhyung Kim)
    
     - Change 'record.samples' type to unsigned long long, fixing output of
       number of samples in 32-bit architectures. (Yang Shi)
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 2619d7e9c92d524cb155ec89fd72875321512e5b
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Sep 9 16:07:30 2015 -0700

    time: Fix timekeeping_freqadjust()'s incorrect use of abs() instead of abs64()
    
    The internal clocksteering done for fine-grained error
    correction uses a logarithmic approximation, so any time
    adjtimex() adjusts the clock steering, timekeeping_freqadjust()
    quickly approximates the correct clock frequency over a series
    of ticks.
    
    Unfortunately, the logic in timekeeping_freqadjust(), introduced
    in commit:
    
      dc491596f639 ("timekeeping: Rework frequency adjustments to work better w/ nohz")
    
    used the abs() function with a s64 error value to calculate the
    size of the approximated adjustment to be made.
    
    Per include/linux/kernel.h:
    
      "abs() should not be used for 64-bit types (s64, u64, long long) - use abs64()".
    
    Thus on 32-bit platforms, this resulted in the clocksteering to
    take a quite dampended random walk trying to converge on the
    proper frequency, which caused the adjustments to be made much
    slower then intended (most easily observed when large
    adjustments are made).
    
    This patch fixes the issue by using abs64() instead.
    
    Reported-by: Nuno Gonçalves <nunojpg@gmail.com>
    Tested-by: Nuno Goncalves <nunojpg@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: <stable@vger.kernel.org> # v3.17+
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Miroslav Lichvar <mlichvar@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/1441840051-20244-1-git-send-email-john.stultz@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 43224b96af3154cedd7220f7b90094905f07ac78
Merge: d70b3ef54cea 1cb6c2151850
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jun 22 18:57:44 2015 -0700

    Merge branch 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer updates from Thomas Gleixner:
     "A rather largish update for everything time and timer related:
    
       - Cache footprint optimizations for both hrtimers and timer wheel
    
       - Lower the NOHZ impact on systems which have NOHZ or timer migration
         disabled at runtime.
    
       - Optimize run time overhead of hrtimer interrupt by making the clock
         offset updates smarter
    
       - hrtimer cleanups and removal of restrictions to tackle some
         problems in sched/perf
    
       - Some more leap second tweaks
    
       - Another round of changes addressing the 2038 problem
    
       - First step to change the internals of clock event devices by
         introducing the necessary infrastructure
    
       - Allow constant folding for usecs/msecs_to_jiffies()
    
       - The usual pile of clockevent/clocksource driver updates
    
      The hrtimer changes contain updates to sched, perf and x86 as they
      depend on them plus changes all over the tree to cleanup API changes
      and redundant code, which got copied all over the place.  The y2038
      changes touch s390 to remove the last non 2038 safe code related to
      boot/persistant clock"
    
    * 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (114 commits)
      clocksource: Increase dependencies of timer-stm32 to limit build wreckage
      timer: Minimize nohz off overhead
      timer: Reduce timer migration overhead if disabled
      timer: Stats: Simplify the flags handling
      timer: Replace timer base by a cpu index
      timer: Use hlist for the timer wheel hash buckets
      timer: Remove FIFO "guarantee"
      timers: Sanitize catchup_timer_jiffies() usage
      hrtimer: Allow hrtimer::function() to free the timer
      seqcount: Introduce raw_write_seqcount_barrier()
      seqcount: Rename write_seqcount_barrier()
      hrtimer: Fix hrtimer_is_queued() hole
      hrtimer: Remove HRTIMER_STATE_MIGRATE
      selftest: Timers: Avoid signal deadlock in leap-a-day
      timekeeping: Copy the shadow-timekeeper over the real timekeeper last
      clockevents: Check state instead of mode in suspend/resume path
      selftests: timers: Add leap-second timer edge testing to leap-a-day.c
      ntp: Do leapsecond adjustment in adjtimex read path
      time: Prevent early expiry of hrtimers[CLOCK_REALTIME] at the leap second edge
      ntp: Introduce and use SECS_PER_DAY macro instead of 86400
      ...

commit 96efdcf2d080687e041b0353c604b708546689fd
Author: John Stultz <john.stultz@linaro.org>
Date:   Thu Jun 11 15:54:56 2015 -0700

    ntp: Do leapsecond adjustment in adjtimex read path
    
    Since the leapsecond is applied at tick-time, this means there is a
    small window of time at the start of a leap-second where we cross into
    the next second before applying the leap.
    
    This patch modified adjtimex so that the leap-second is applied on the
    second edge. Providing more correct leapsecond behavior.
    
    This does make it so that adjtimex()'s returned time values can be
    inconsistent with time values read from gettimeofday() or
    clock_gettime(CLOCK_REALTIME,...)  for a brief period of one tick at
    the leapsecond.  However, those other interfaces do not provide the
    TIME_OOP time_state return that adjtimex() provides, which allows the
    leapsecond to be properly represented. They instead only see a time
    discontinuity, and cannot tell the first 23:59:59 from the repeated
    23:59:59 leap second.
    
    This seems like a reasonable tradeoff given clock_gettime() /
    gettimeofday() cannot properly represent a leapsecond, and users
    likely care more about performance, while folks who are using
    adjtimex() more likely care about leap-second correctness.
    
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Daniel Bristot de Oliveira <bristot@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Jan Kara <jack@suse.cz>
    Cc: Jiri Bohac <jbohac@suse.cz>
    Cc: Ingo Molnar <mingo@kernel.org>
    Link: http://lkml.kernel.org/r/1434063297-28657-5-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit f8cce9e338db5d455e62a4b9abbbeda3d5a0e203
Author: John Stultz <john.stultz@linaro.org>
Date:   Mon Feb 9 23:30:36 2015 -0800

    ntp: Fixup adjtimex freq validation on 32-bit systems
    
    commit 29183a70b0b828500816bd794b3fe192fce89f73 upstream.
    
    Additional validation of adjtimex freq values to avoid
    potential multiplication overflows were added in commit
    5e5aeb4367b (time: adjtimex: Validate the ADJ_FREQUENCY values)
    
    Unfortunately the patch used LONG_MAX/MIN instead of
    LLONG_MAX/MIN, which was fine on 64-bit systems, but being
    much smaller on 32-bit systems caused false positives
    resulting in most direct frequency adjustments to fail w/
    EINVAL.
    
    ntpd only does direct frequency adjustments at startup, so
    the issue was not as easily observed there, but other time
    sync applications like ptpd and chrony were more effected by
    the bug.
    
    See bugs:
    
      https://bugzilla.kernel.org/show_bug.cgi?id=92481
      https://bugzilla.redhat.com/show_bug.cgi?id=1188074
    
    This patch changes the checks to use LLONG_MAX for
    clarity, and additionally the checks are disabled
    on 32-bit systems since LLONG_MAX/PPM_SCALE is always
    larger then the 32-bit long freq value, so multiplication
    overflows aren't possible there.
    
    Reported-by: Josh Boyer <jwboyer@fedoraproject.org>
    Reported-by: George Joseph <george.joseph@fairview5.com>
    Tested-by: George Joseph <george.joseph@fairview5.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Link: http://lkml.kernel.org/r/1423553436-29747-1-git-send-email-john.stultz@linaro.org
    [ Prettified the changelog and the comments a bit. ]
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Zefan Li <lizefan@huawei.com>

commit 3f6d9b62622ce5dbb870160cb3da5f8bfc87adee
Author: Sasha Levin <sasha.levin@oracle.com>
Date:   Wed Dec 3 19:25:05 2014 -0500

    time: adjtimex: Validate the ADJ_FREQUENCY values
    
    commit 5e5aeb4367b450a28f447f6d5ab57d8f2ab16a5f upstream.
    
    Verify that the frequency value from userspace is valid and makes sense.
    
    Unverified values can cause overflows later on.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Sasha Levin <sasha.levin@oracle.com>
    [jstultz: Fix up bug for negative values and drop redunent cap check]
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    [lizf: Backported to 3.4: adjust context]
    Signed-off-by: Zefan Li <lizefan@huawei.com>

commit 8d30871bfd929e5d931f51caf831b3c318ffcabe
Author: John Stultz <john.stultz@linaro.org>
Date:   Mon Feb 9 23:30:36 2015 -0800

    ntp: Fixup adjtimex freq validation on 32-bit systems
    
    commit 29183a70b0b828500816bd794b3fe192fce89f73 upstream.
    
    Additional validation of adjtimex freq values to avoid
    potential multiplication overflows were added in commit
    5e5aeb4367b (time: adjtimex: Validate the ADJ_FREQUENCY values)
    
    Unfortunately the patch used LONG_MAX/MIN instead of
    LLONG_MAX/MIN, which was fine on 64-bit systems, but being
    much smaller on 32-bit systems caused false positives
    resulting in most direct frequency adjustments to fail w/
    EINVAL.
    
    ntpd only does direct frequency adjustments at startup, so
    the issue was not as easily observed there, but other time
    sync applications like ptpd and chrony were more effected by
    the bug.
    
    See bugs:
    
      https://bugzilla.kernel.org/show_bug.cgi?id=92481
      https://bugzilla.redhat.com/show_bug.cgi?id=1188074
    
    This patch changes the checks to use LLONG_MAX for
    clarity, and additionally the checks are disabled
    on 32-bit systems since LLONG_MAX/PPM_SCALE is always
    larger then the 32-bit long freq value, so multiplication
    overflows aren't possible there.
    
    Reported-by: Josh Boyer <jwboyer@fedoraproject.org>
    Reported-by: George Joseph <george.joseph@fairview5.com>
    Tested-by: George Joseph <george.joseph@fairview5.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Link: http://lkml.kernel.org/r/1423553436-29747-1-git-send-email-john.stultz@linaro.org
    [ Prettified the changelog and the comments a bit. ]
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Cc: Christian Riesch <christian.riesch@omicron.at>
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>

commit 3a92a15fba68b5c9c8b51ee98a94a3d1ff54c8e5
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Mar 11 17:40:13 2015 -0700

    selftests/timers: Add set-tai from the timetest suite
    
    This patch adds the set-tai test which ensures the tai offset
    can be set properly from adjtimex.
    
    Cc: Shuah Khan <shuahkh@osg.samsung.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Tested-by: Prarit Bhargava <prarit@redhat.com>
    Signed-off-by: Shuah Khan <shuahkh@osg.samsung.com>

commit d869424558419a4a34a12bd5187b5d6d06ee132f
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Mar 11 17:40:08 2015 -0700

    selftests/timers: Add change_skew test from timetest suite
    
    This patch adds the change_skew test which validates the
    adjtimex freq can be set to various values and then using
    the inconsistency-check, raw_skew, and nanosleep tests
    ensures time behaves properly.
    
    Cc: Shuah Khan <shuahkh@osg.samsung.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Tested-by: Prarit Bhargava <prarit@redhat.com>
    Signed-off-by: Shuah Khan <shuahkh@osg.samsung.com>

commit de52133f1892ed2c385655473df90f3d2797fff9
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Mar 11 17:40:06 2015 -0700

    selftests/timers: Add adjtimex validation test from timetest suite
    
    This adds a adjtimex validation test which checks the behavior
    for a set of valida and invalid inputs. So far this only tests
    ADJ_FREQUENCY, but hopefully will grow.
    
    Cc: Shuah Khan <shuahkh@osg.samsung.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Tested-by: Prarit Bhargava <prarit@redhat.com>
    Signed-off-by: Shuah Khan <shuahkh@osg.samsung.com>

commit 51f91cbdf5450b773eb221a2dfd141a92413370e
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Mar 11 17:40:02 2015 -0700

    selftests/timers: Add clock skew estimation test from timetest suite
    
    This adds my clock skew estimation test from the timetest suite.
    It measures the drift between CLOCK_MONOTONIC and CLOCK_MONOTONIC_RAW
    and compares it with the current frequency value from adjtimex.
    
    It sometimes can trigger false failures when ntpd isn't in a
    steady state, but its a useful too when doing adjtimex testing.
    
    Cc: Shuah Khan <shuahkh@osg.samsung.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Tested-by: Prarit Bhargava <prarit@redhat.com>
    Signed-off-by: Shuah Khan <shuahkh@osg.samsung.com>

commit 0bcbb5825c03329bcbe8a8c0b4a0aa20cec8a86a
Author: John Stultz <john.stultz@linaro.org>
Date:   Mon Feb 9 23:30:36 2015 -0800

    ntp: Fixup adjtimex freq validation on 32-bit systems
    
    commit 29183a70b0b828500816bd794b3fe192fce89f73 upstream.
    
    Additional validation of adjtimex freq values to avoid
    potential multiplication overflows were added in commit
    5e5aeb4367b (time: adjtimex: Validate the ADJ_FREQUENCY values)
    
    Unfortunately the patch used LONG_MAX/MIN instead of
    LLONG_MAX/MIN, which was fine on 64-bit systems, but being
    much smaller on 32-bit systems caused false positives
    resulting in most direct frequency adjustments to fail w/
    EINVAL.
    
    ntpd only does direct frequency adjustments at startup, so
    the issue was not as easily observed there, but other time
    sync applications like ptpd and chrony were more effected by
    the bug.
    
    See bugs:
    
      https://bugzilla.kernel.org/show_bug.cgi?id=92481
      https://bugzilla.redhat.com/show_bug.cgi?id=1188074
    
    This patch changes the checks to use LLONG_MAX for
    clarity, and additionally the checks are disabled
    on 32-bit systems since LLONG_MAX/PPM_SCALE is always
    larger then the 32-bit long freq value, so multiplication
    overflows aren't possible there.
    
    Reported-by: Josh Boyer <jwboyer@fedoraproject.org>
    Reported-by: George Joseph <george.joseph@fairview5.com>
    Tested-by: George Joseph <george.joseph@fairview5.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Link: http://lkml.kernel.org/r/1423553436-29747-1-git-send-email-john.stultz@linaro.org
    [ Prettified the changelog and the comments a bit. ]
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 20dcda8d40db528865b1aa5053b39e0a803df693
Author: John Stultz <john.stultz@linaro.org>
Date:   Mon Feb 9 23:30:36 2015 -0800

    ntp: Fixup adjtimex freq validation on 32-bit systems
    
    commit 29183a70b0b828500816bd794b3fe192fce89f73 upstream.
    
    Additional validation of adjtimex freq values to avoid
    potential multiplication overflows were added in commit
    5e5aeb4367b (time: adjtimex: Validate the ADJ_FREQUENCY values)
    
    Unfortunately the patch used LONG_MAX/MIN instead of
    LLONG_MAX/MIN, which was fine on 64-bit systems, but being
    much smaller on 32-bit systems caused false positives
    resulting in most direct frequency adjustments to fail w/
    EINVAL.
    
    ntpd only does direct frequency adjustments at startup, so
    the issue was not as easily observed there, but other time
    sync applications like ptpd and chrony were more effected by
    the bug.
    
    See bugs:
    
      https://bugzilla.kernel.org/show_bug.cgi?id=92481
      https://bugzilla.redhat.com/show_bug.cgi?id=1188074
    
    This patch changes the checks to use LLONG_MAX for
    clarity, and additionally the checks are disabled
    on 32-bit systems since LLONG_MAX/PPM_SCALE is always
    larger then the 32-bit long freq value, so multiplication
    overflows aren't possible there.
    
    Reported-by: Josh Boyer <jwboyer@fedoraproject.org>
    Reported-by: George Joseph <george.joseph@fairview5.com>
    Tested-by: George Joseph <george.joseph@fairview5.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Link: http://lkml.kernel.org/r/1423553436-29747-1-git-send-email-john.stultz@linaro.org
    [ Prettified the changelog and the comments a bit. ]
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 5e2b0b3f502ec060479d3f266b2cf9ff40ce8d2a
Author: John Stultz <john.stultz@linaro.org>
Date:   Mon Feb 9 23:30:36 2015 -0800

    ntp: Fixup adjtimex freq validation on 32-bit systems
    
    commit 29183a70b0b828500816bd794b3fe192fce89f73 upstream.
    
    Additional validation of adjtimex freq values to avoid
    potential multiplication overflows were added in commit
    5e5aeb4367b (time: adjtimex: Validate the ADJ_FREQUENCY values)
    
    Unfortunately the patch used LONG_MAX/MIN instead of
    LLONG_MAX/MIN, which was fine on 64-bit systems, but being
    much smaller on 32-bit systems caused false positives
    resulting in most direct frequency adjustments to fail w/
    EINVAL.
    
    ntpd only does direct frequency adjustments at startup, so
    the issue was not as easily observed there, but other time
    sync applications like ptpd and chrony were more effected by
    the bug.
    
    See bugs:
    
      https://bugzilla.kernel.org/show_bug.cgi?id=92481
      https://bugzilla.redhat.com/show_bug.cgi?id=1188074
    
    This patch changes the checks to use LLONG_MAX for
    clarity, and additionally the checks are disabled
    on 32-bit systems since LLONG_MAX/PPM_SCALE is always
    larger then the 32-bit long freq value, so multiplication
    overflows aren't possible there.
    
    Reported-by: Josh Boyer <jwboyer@fedoraproject.org>
    Reported-by: George Joseph <george.joseph@fairview5.com>
    Tested-by: George Joseph <george.joseph@fairview5.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Link: http://lkml.kernel.org/r/1423553436-29747-1-git-send-email-john.stultz@linaro.org
    [ Prettified the changelog and the comments a bit. ]
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 72e2d609260a5a7515d4c9d2d709759fc282e552
Author: John Stultz <john.stultz@linaro.org>
Date:   Mon Feb 9 23:30:36 2015 -0800

    ntp: Fixup adjtimex freq validation on 32-bit systems
    
    commit 29183a70b0b828500816bd794b3fe192fce89f73 upstream.
    
    Additional validation of adjtimex freq values to avoid
    potential multiplication overflows were added in commit
    5e5aeb4367b (time: adjtimex: Validate the ADJ_FREQUENCY values)
    
    Unfortunately the patch used LONG_MAX/MIN instead of
    LLONG_MAX/MIN, which was fine on 64-bit systems, but being
    much smaller on 32-bit systems caused false positives
    resulting in most direct frequency adjustments to fail w/
    EINVAL.
    
    ntpd only does direct frequency adjustments at startup, so
    the issue was not as easily observed there, but other time
    sync applications like ptpd and chrony were more effected by
    the bug.
    
    See bugs:
    
      https://bugzilla.kernel.org/show_bug.cgi?id=92481
      https://bugzilla.redhat.com/show_bug.cgi?id=1188074
    
    This patch changes the checks to use LLONG_MAX for
    clarity, and additionally the checks are disabled
    on 32-bit systems since LLONG_MAX/PPM_SCALE is always
    larger then the 32-bit long freq value, so multiplication
    overflows aren't possible there.
    
    Reported-by: Josh Boyer <jwboyer@fedoraproject.org>
    Reported-by: George Joseph <george.joseph@fairview5.com>
    Tested-by: George Joseph <george.joseph@fairview5.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Link: http://lkml.kernel.org/r/1423553436-29747-1-git-send-email-john.stultz@linaro.org
    [ Prettified the changelog and the comments a bit. ]
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit b2fcc089bcb64b2f1667eb3046cb72f9529ec2bc
Author: John Stultz <john.stultz@linaro.org>
Date:   Mon Feb 9 23:30:36 2015 -0800

    ntp: Fixup adjtimex freq validation on 32-bit systems
    
    commit 29183a70b0b828500816bd794b3fe192fce89f73 upstream.
    
    Additional validation of adjtimex freq values to avoid
    potential multiplication overflows were added in commit
    5e5aeb4367b (time: adjtimex: Validate the ADJ_FREQUENCY values)
    
    Unfortunately the patch used LONG_MAX/MIN instead of
    LLONG_MAX/MIN, which was fine on 64-bit systems, but being
    much smaller on 32-bit systems caused false positives
    resulting in most direct frequency adjustments to fail w/
    EINVAL.
    
    ntpd only does direct frequency adjustments at startup, so
    the issue was not as easily observed there, but other time
    sync applications like ptpd and chrony were more effected by
    the bug.
    
    See bugs:
    
      https://bugzilla.kernel.org/show_bug.cgi?id=92481
      https://bugzilla.redhat.com/show_bug.cgi?id=1188074
    
    This patch changes the checks to use LLONG_MAX for
    clarity, and additionally the checks are disabled
    on 32-bit systems since LLONG_MAX/PPM_SCALE is always
    larger then the 32-bit long freq value, so multiplication
    overflows aren't possible there.
    
    Reported-by: Josh Boyer <jwboyer@fedoraproject.org>
    Reported-by: George Joseph <george.joseph@fairview5.com>
    Tested-by: George Joseph <george.joseph@fairview5.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Link: http://lkml.kernel.org/r/1423553436-29747-1-git-send-email-john.stultz@linaro.org
    [ Prettified the changelog and the comments a bit. ]
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit f20f9084ff23d722a80511a2ce7dc2ea50eb79ad
Author: Sasha Levin <sasha.levin@oracle.com>
Date:   Wed Dec 3 19:25:05 2014 -0500

    time: adjtimex: Validate the ADJ_FREQUENCY values
    
    commit 5e5aeb4367b450a28f447f6d5ab57d8f2ab16a5f upstream.
    
    Verify that the frequency value from userspace is valid and makes sense.
    
    Unverified values can cause overflows later on.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Sasha Levin <sasha.levin@oracle.com>
    [jstultz: Fix up bug for negative values and drop redunent cap check]
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    [bwh: Backported to 3.2: adjust context]
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit 06246b44e252dfa2f6b7d91cf8e603d31987ea9c
Author: John Stultz <john.stultz@linaro.org>
Date:   Mon Feb 9 23:30:36 2015 -0800

    ntp: Fixup adjtimex freq validation on 32-bit systems
    
    commit 29183a70b0b828500816bd794b3fe192fce89f73 upstream.
    
    Additional validation of adjtimex freq values to avoid
    potential multiplication overflows were added in commit
    5e5aeb4367b (time: adjtimex: Validate the ADJ_FREQUENCY values)
    
    Unfortunately the patch used LONG_MAX/MIN instead of
    LLONG_MAX/MIN, which was fine on 64-bit systems, but being
    much smaller on 32-bit systems caused false positives
    resulting in most direct frequency adjustments to fail w/
    EINVAL.
    
    ntpd only does direct frequency adjustments at startup, so
    the issue was not as easily observed there, but other time
    sync applications like ptpd and chrony were more effected by
    the bug.
    
    See bugs:
    
      https://bugzilla.kernel.org/show_bug.cgi?id=92481
      https://bugzilla.redhat.com/show_bug.cgi?id=1188074
    
    This patch changes the checks to use LLONG_MAX for
    clarity, and additionally the checks are disabled
    on 32-bit systems since LLONG_MAX/PPM_SCALE is always
    larger then the 32-bit long freq value, so multiplication
    overflows aren't possible there.
    
    Reported-by: Josh Boyer <jwboyer@fedoraproject.org>
    Reported-by: George Joseph <george.joseph@fairview5.com>
    Tested-by: George Joseph <george.joseph@fairview5.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Link: http://lkml.kernel.org/r/1423553436-29747-1-git-send-email-john.stultz@linaro.org
    [ Prettified the changelog and the comments a bit. ]
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Luis Henriques <luis.henriques@canonical.com>

commit e74cd063d763d9535c7f3e2974318a7cbd64eed4
Author: Sasha Levin <sasha.levin@oracle.com>
Date:   Wed Dec 3 19:25:05 2014 -0500

    time: adjtimex: Validate the ADJ_FREQUENCY values
    
    commit 5e5aeb4367b450a28f447f6d5ab57d8f2ab16a5f upstream.
    
    Verify that the frequency value from userspace is valid and makes sense.
    
    Unverified values can cause overflows later on.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Sasha Levin <sasha.levin@oracle.com>
    [jstultz: Fix up bug for negative values and drop redunent cap check]
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Luis Henriques <luis.henriques@canonical.com>

commit f3c233d75ed0dd04e9eaf7cb43d79756fef1ef3a
Merge: 10436cf8812e 29183a70b0b8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Feb 21 11:05:22 2015 -0800

    Merge branch 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull ntp fix from Ingo Molnar:
     "An adjtimex interface regression fix for 32-bit systems"
    
    [ A check that was added in a previous commit is really only a concern
      for 64bit systems, but was applied to both 32 and 64bit systems, which
      results in breaking 32bit systems.
    
      Thus the fix here is to make the check only apply to 64bit systems ]
    
    * 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      ntp: Fixup adjtimex freq validation on 32-bit systems

commit 29183a70b0b828500816bd794b3fe192fce89f73
Author: John Stultz <john.stultz@linaro.org>
Date:   Mon Feb 9 23:30:36 2015 -0800

    ntp: Fixup adjtimex freq validation on 32-bit systems
    
    Additional validation of adjtimex freq values to avoid
    potential multiplication overflows were added in commit
    5e5aeb4367b (time: adjtimex: Validate the ADJ_FREQUENCY values)
    
    Unfortunately the patch used LONG_MAX/MIN instead of
    LLONG_MAX/MIN, which was fine on 64-bit systems, but being
    much smaller on 32-bit systems caused false positives
    resulting in most direct frequency adjustments to fail w/
    EINVAL.
    
    ntpd only does direct frequency adjustments at startup, so
    the issue was not as easily observed there, but other time
    sync applications like ptpd and chrony were more effected by
    the bug.
    
    See bugs:
    
      https://bugzilla.kernel.org/show_bug.cgi?id=92481
      https://bugzilla.redhat.com/show_bug.cgi?id=1188074
    
    This patch changes the checks to use LLONG_MAX for
    clarity, and additionally the checks are disabled
    on 32-bit systems since LLONG_MAX/PPM_SCALE is always
    larger then the 32-bit long freq value, so multiplication
    overflows aren't possible there.
    
    Reported-by: Josh Boyer <jwboyer@fedoraproject.org>
    Reported-by: George Joseph <george.joseph@fairview5.com>
    Tested-by: George Joseph <george.joseph@fairview5.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: <stable@vger.kernel.org> # v3.19+
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Link: http://lkml.kernel.org/r/1423553436-29747-1-git-send-email-john.stultz@linaro.org
    [ Prettified the changelog and the comments a bit. ]
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit f3240c1f6d18591b2c1ef33ed18d5ca91e62c104
Author: Hans-Christian Egtvedt <egtvedt@samfundet.no>
Date:   Thu Dec 25 19:58:50 2014 +0100

    avr32: wire up missing syscalls
    
    This patch adds a bunch of missing syscalls to AVR32:
    __NR_pread64
    __NR_pwrite64
    __NR_timerfd_create
    __NR_fallocate
    __NR_timerfd_settime
    __NR_timerfd_gettime
    __NR_signalfd4
    __NR_eventfd2
    __NR_epoll_create1
    __NR_dup3
    __NR_pipe2
    __NR_inotify_init1
    __NR_preadv
    __NR_pwritev
    __NR_rt_tgsigqueueinfo
    __NR_perf_event_open
    __NR_recvmmsg
    __NR_fanotify_init
    __NR_fanotify_mark
    __NR_prlimit64
    __NR_name_to_handle_at
    __NR_open_by_handle_at
    __NR_clock_adjtime
    __NR_syncfs
    __NR_sendmmsg
    __NR_process_vm_readv
    __NR_process_vm_writev
    __NR_kcmp
    __NR_finit_module
    __NR_sched_setattr
    __NR_sched_getattr
    __NR_renameat2
    __NR_seccomp
    __NR_getrandom
    __NR_memfd_create
    __NR_bpf
    __NR_execveat
    
    On AVR32, all parameters beyond the 5th are passed on the stack. System
    calls don't use the stack -- they borrow a callee-saved register
    instead. This means that syscalls that take 6 parameters must be called
    through a stub that pushes the last parameter on the stack.
    
    This relates to syscall fallocate, fanotify_mark, process_vm_readv, and
    process_vm_writev.
    
    Signed-off-by: Hans-Christian Egtvedt <egtvedt@samfundet.no>

commit 2497402c9ad62e91897fed5310f7df48bf3bca1f
Author: Sasha Levin <sasha.levin@oracle.com>
Date:   Wed Dec 3 19:25:05 2014 -0500

    time: adjtimex: Validate the ADJ_FREQUENCY values
    
    commit 5e5aeb4367b450a28f447f6d5ab57d8f2ab16a5f upstream.
    
    Verify that the frequency value from userspace is valid and makes sense.
    
    Unverified values can cause overflows later on.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Sasha Levin <sasha.levin@oracle.com>
    [jstultz: Fix up bug for negative values and drop redunent cap check]
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 09ee0cd0c2072c353bc3c096b36267bfeb0a8a9f
Author: Sasha Levin <sasha.levin@oracle.com>
Date:   Wed Dec 3 19:25:05 2014 -0500

    time: adjtimex: Validate the ADJ_FREQUENCY values
    
    commit 5e5aeb4367b450a28f447f6d5ab57d8f2ab16a5f upstream.
    
    Verify that the frequency value from userspace is valid and makes sense.
    
    Unverified values can cause overflows later on.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Sasha Levin <sasha.levin@oracle.com>
    [jstultz: Fix up bug for negative values and drop redunent cap check]
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit e8e3b6ddd0a6afa267029141946918392b425cf4
Author: Sasha Levin <sasha.levin@oracle.com>
Date:   Wed Dec 3 19:25:05 2014 -0500

    time: adjtimex: Validate the ADJ_FREQUENCY values
    
    commit 5e5aeb4367b450a28f447f6d5ab57d8f2ab16a5f upstream.
    
    Verify that the frequency value from userspace is valid and makes sense.
    
    Unverified values can cause overflows later on.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Sasha Levin <sasha.levin@oracle.com>
    [jstultz: Fix up bug for negative values and drop redunent cap check]
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit f09c62a1c27dcc43a06e5ebb27ae67306146277b
Author: Sasha Levin <sasha.levin@oracle.com>
Date:   Wed Dec 3 19:25:05 2014 -0500

    time: adjtimex: Validate the ADJ_FREQUENCY values
    
    commit 5e5aeb4367b450a28f447f6d5ab57d8f2ab16a5f upstream.
    
    Verify that the frequency value from userspace is valid and makes sense.
    
    Unverified values can cause overflows later on.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Sasha Levin <sasha.levin@oracle.com>
    [jstultz: Fix up bug for negative values and drop redunent cap check]
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>

commit b73f0c8f4ba810cd753031d18f4fab83bd9ac58f
Merge: 71a59b127273 5fbaba8603d5
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Jan 25 17:47:34 2015 -0800

    Merge branch 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer fixes from Thomas Gleixner:
     "A set of small fixes:
    
       - regression fix for exynos_mct clocksource
    
       - trivial build fix for kona clocksource
    
       - functional one liner fix for the sh_tmu clocksource
    
       - two validation fixes to prevent (root only) data corruption in the
         kernel via settimeofday and adjtimex.  Tagged for stable"
    
    * 'timers-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      time: adjtimex: Validate the ADJ_FREQUENCY values
      time: settimeofday: Validate the values of tv from user
      clocksource: sh_tmu: Set cpu_possible_mask to fix SMP broadcast
      clocksource: kona: fix __iomem annotation
      clocksource: exynos_mct: Fix bitmask regression for exynos4_mct_write

commit 8fff5e374a2f6047d1bb52288af7da119bc75765
Merge: 1c6007d59a20 0eb135ff9f19
Author: Paolo Bonzini <pbonzini@redhat.com>
Date:   Fri Jan 23 14:33:36 2015 +0100

    Merge tag 'kvm-s390-next-20150122' of git://git.kernel.org/pub/scm/linux/kernel/git/kvms390/linux into kvm-next
    
    KVM: s390: fixes and features for kvm/next (3.20)
    
    1. Generic
    - sparse warning (make function static)
    - optimize locking
    - bugfixes for interrupt injection
    - fix MVPG addressing modes
    
    2. hrtimer/wakeup fun
    A recent change can cause KVM hangs if adjtime is used in the host.
    The hrtimer might wake up too early or too late. Too early is fatal
    as vcpu_block will see that the wakeup condition is not met and
    sleep again. This CPU might never wake up again.
    This series addresses this problem. adjclock slowing down the host
    clock will result in too late wakeups. This will require more work.
    In addition to that we also change the hrtimer from REALTIME to
    MONOTONIC to avoid similar problems with timedatectl set-time.
    
    3. sigp rework
    We will move all "slow" sigps to QEMU (protected with a capability that
    can be enabled) to avoid several races between concurrent SIGP orders.
    
    4. Optimize the shadow page table
    Provide an interface to announce the maximum guest size. The kernel
    will use that to make the pagetable 2,3,4 (or theoretically) 5 levels.
    
    5. Provide an interface to set the guest TOD
    We now use two vm attributes instead of two oneregs, as oneregs are
    vcpu ioctl and we don't want to call them from other threads.
    
    6. Protected key functions
    The real HMC allows to enable/disable protected key CPACF functions.
    Lets provide an implementation + an interface for QEMU to activate
    this the protected key instructions.

commit 5e5aeb4367b450a28f447f6d5ab57d8f2ab16a5f
Author: Sasha Levin <sasha.levin@oracle.com>
Date:   Wed Dec 3 19:25:05 2014 -0500

    time: adjtimex: Validate the ADJ_FREQUENCY values
    
    Verify that the frequency value from userspace is valid and makes sense.
    
    Unverified values can cause overflows later on.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Sasha Levin <sasha.levin@oracle.com>
    [jstultz: Fix up bug for negative values and drop redunent cap check]
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 5115ec9654f87ba0d9508569f91fe1f444ffbf58
Merge: 2c90331cf5ed 2eebdde6528a
Author: David S. Miller <davem@davemloft.net>
Date:   Tue Dec 30 18:30:00 2014 -0500

    Merge branch 'timecounter'
    
    Richard Cochran says:
    
    ====================
    Time Counter fixes and improvements
    
    Several PTP Hardware Clock (PHC) drivers implement the clock in
    software using the timecounter/cyclecounter code. This series adds one
    simple improvement and one more subtle fix to the shared timecounter
    facility. Credit for this series goes to Janusz Użycki, who pointed
    the issues out to me off list.
    
    Patch #1 simply move the timecounter code into its own file. When
    working on this series, it was really annoying to see half the kernel
    recompile after every tweak to the timecounter stuff. There is no
    reason to keep this together with the clocksource code.
    
    Patch #2 implements an improved adjtime() method, and patches 3-10
    convert all of the drivers over to the new method.
    
    Patch #11 fixes a subtle but important issue with the timecounter WRT
    frequency adjustment. As it stands now, a timecounter based PHC will
    exhibit a variable frequency resolution (and variable time error)
    depending on how often the clock is read.
    
    In timecounter_read_delta(), the expression
    
       (delta * cc->mult) >> cc->shift;
    
    can lose resolution from the adjusted value of 'mult'. If the value
    of 'delta' is too small, then small changes in 'mult' have no effect.
    However, if the delta value is large enough, then small changes in
    'mult' will have an effect.
    
    Reading the clock too often means smaller 'delta' values which in turn
    will spoil the fine adjustments made to 'mult'. Up until now, this
    effect did not show up in my testing. The following example explains
    why.
    
    The CPTS has an input clock of 250 MHz, and the clock source uses
    mult=0x80000000 and shift=29, making the ticks to nanoseconds
    conversion like this:
    
       ticks * 2^31
       ------------
           2^29
    
    Imagine what happens if the clock is read every 10 milliseconds. Ten
    milliseconds are about 2500000 ticks, which corresponds to about 21
    bits. The product in the numerator has then 52 bits. After the shift
    operation, 23 bits are preserved. This results in a frequency
    adjustment resolution of about 0.1 ppm (not _too_ bad.)
    
    A frequency resolution of 1 ppm requires 20 bits.
    A frequency resolution of 1 ppb requires 30 bits.
    
    For the 250 MHz CPTS clock, reading every 4 seconds yields a 1 ppb
    resolution (which is the finest that our API allows).
    
    However, the error can be much higher if the clock is read too often
    or if time stamps occur close in time to read operations. In general
    it is really not acceptable to allow the rate of clock readings to
    influence the clock accuracy.
    ====================
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit f25a30be359d0535fb1c7c1619cabb0ad17cfbf1
Author: Richard Cochran <richardcochran@gmail.com>
Date:   Sun Dec 21 19:47:05 2014 +0100

    net: cpts: convert to timecounter adjtime.
    
    This patch changes the driver to use the new and improved method
    for adjusting the offset of a timecounter.
    
    Signed-off-by: Richard Cochran <richardcochran@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit ce51ff0937bd5596aeafd67f5a60d36016d5e040
Author: Richard Cochran <richardcochran@gmail.com>
Date:   Sun Dec 21 19:47:04 2014 +0100

    net: mlx4: convert to timecounter adjtime.
    
    This patch changes the driver to use the new and improved method
    for adjusting the offset of a timecounter.
    
    Compile tested only.
    
    Signed-off-by: Richard Cochran <richardcochran@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 826ef90dc4727c9f9cd999c830023e54d9ea3f58
Author: Richard Cochran <richardcochran@gmail.com>
Date:   Sun Dec 21 19:47:03 2014 +0100

    net: ixgbe: convert to timecounter adjtime.
    
    This patch changes the driver to use the new and improved method
    for adjusting the offset of a timecounter.
    
    Compile tested only.
    
    Signed-off-by: Richard Cochran <richardcochran@gmail.com>
    Acked-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 5ee698e3677a1af8b731cc891e94be33b6572cfd
Author: Richard Cochran <richardcochran@gmail.com>
Date:   Sun Dec 21 19:47:02 2014 +0100

    net: igb: convert to timecounter adjtime.
    
    This patch changes the driver to use the new and improved method
    for adjusting the offset of a timecounter.
    
    Signed-off-by: Richard Cochran <richardcochran@gmail.com>
    Acked-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit f4de2b95688eba646d677dd2bed8c49540c00f1e
Author: Richard Cochran <richardcochran@gmail.com>
Date:   Sun Dec 21 19:47:01 2014 +0100

    net: e1000e: convert to timecounter adjtime.
    
    This patch changes the driver to use the new and improved method
    for adjusting the offset of a timecounter.
    
    Signed-off-by: Richard Cochran <richardcochran@gmail.com>
    Acked-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 59e16961c688a50d4dae9827cc3e5c69ae98e0cb
Author: Richard Cochran <richardcochran@gmail.com>
Date:   Sun Dec 21 19:47:00 2014 +0100

    net: fec: convert to timecounter adjtime.
    
    This patch changes the driver to use the new and improved method
    for adjusting the offset of a timecounter.
    
    Compile tested only.
    
    Signed-off-by: Richard Cochran <richardcochran@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 2e5601f9aca1a83980a031f9385a95062d12e689
Author: Richard Cochran <richardcochran@gmail.com>
Date:   Sun Dec 21 19:46:59 2014 +0100

    net: bnx2x: convert to timecounter adjtime.
    
    This patch changes the driver to use the new and improved method
    for adjusting the offset of a timecounter.
    
    Compile tested only.
    
    Signed-off-by: Richard Cochran <richardcochran@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 8b976e97772cfb7e0e4eb8682d5017861dbd8796
Author: Richard Cochran <richardcochran@gmail.com>
Date:   Sun Dec 21 19:46:58 2014 +0100

    net: xgbe: convert to timecounter adjtime.
    
    This patch changes the driver to use the new and improved method
    for adjusting the offset of a timecounter.
    
    Compile tested only.
    
    Signed-off-by: Richard Cochran <richardcochran@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 796c1efd6fa0ed696d550b68f4410ab1a1749d01
Author: Richard Cochran <richardcochran@gmail.com>
Date:   Sun Dec 21 19:46:57 2014 +0100

    timecounter: provide a helper function to shift the time.
    
    Some PTP Hardware Clock drivers use a struct timecounter to represent
    their clock. To adjust the time by a given offset, these drivers all
    perform a two step read/write of their timecounter. However, it is
    better and simpler just to adjust the offset in one step. This patch
    introduces a little routine to help drivers implement the adjtime
    method.
    
    Suggested-by: Janusz Użycki <j.uzycki@elproma.com.pl>
    Signed-off-by: Richard Cochran <richardcochran@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 42e1358e103de0fe07d3e8ff40c16bb1fa844e26
Author: Christian Riesch <christian.riesch@omicron.at>
Date:   Mon Jun 16 14:46:45 2014 +0200

    ptp: In the testptp utility, use clock_adjtime from glibc when available
    
    clock_adjtime was included in glibc 2.14. _GNU_SOURCE must be defined
    to make it available.
    
    Signed-off-by: Christian Riesch <christian.riesch@omicron.at>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Acked-by: Richard Cochran <richardcochran@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 970719a34d1e443eee0d52a52b0e8a755819d4cb
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Dec 10 17:18:18 2013 -0800

    timekeeping: Avoid possible deadlock from clock_was_set_delayed
    
    commit 6fdda9a9c5db367130cf32df5d6618d08b89f46a upstream.
    
    As part of normal operaions, the hrtimer subsystem frequently calls
    into the timekeeping code, creating a locking order of
      hrtimer locks -> timekeeping locks
    
    clock_was_set_delayed() was suppoed to allow us to avoid deadlocks
    between the timekeeping the hrtimer subsystem, so that we could
    notify the hrtimer subsytem the time had changed while holding
    the timekeeping locks. This was done by scheduling delayed work
    that would run later once we were out of the timekeeing code.
    
    But unfortunately the lock chains are complex enoguh that in
    scheduling delayed work, we end up eventually trying to grab
    an hrtimer lock.
    
    Sasha Levin noticed this in testing when the new seqlock lockdep
    enablement triggered the following (somewhat abrieviated) message:
    
    [  251.100221] ======================================================
    [  251.100221] [ INFO: possible circular locking dependency detected ]
    [  251.100221] 3.13.0-rc2-next-20131206-sasha-00005-g8be2375-dirty #4053 Not tainted
    [  251.101967] -------------------------------------------------------
    [  251.101967] kworker/10:1/4506 is trying to acquire lock:
    [  251.101967]  (timekeeper_seq){----..}, at: [<ffffffff81160e96>] retrigger_next_event+0x56/0x70
    [  251.101967]
    [  251.101967] but task is already holding lock:
    [  251.101967]  (hrtimer_bases.lock#11){-.-...}, at: [<ffffffff81160e7c>] retrigger_next_event+0x3c/0x70
    [  251.101967]
    [  251.101967] which lock already depends on the new lock.
    [  251.101967]
    [  251.101967]
    [  251.101967] the existing dependency chain (in reverse order) is:
    [  251.101967]
    -> #5 (hrtimer_bases.lock#11){-.-...}:
    [snipped]
    -> #4 (&rt_b->rt_runtime_lock){-.-...}:
    [snipped]
    -> #3 (&rq->lock){-.-.-.}:
    [snipped]
    -> #2 (&p->pi_lock){-.-.-.}:
    [snipped]
    -> #1 (&(&pool->lock)->rlock){-.-...}:
    [  251.101967]        [<ffffffff81194803>] validate_chain+0x6c3/0x7b0
    [  251.101967]        [<ffffffff81194d9d>] __lock_acquire+0x4ad/0x580
    [  251.101967]        [<ffffffff81194ff2>] lock_acquire+0x182/0x1d0
    [  251.101967]        [<ffffffff84398500>] _raw_spin_lock+0x40/0x80
    [  251.101967]        [<ffffffff81153e69>] __queue_work+0x1a9/0x3f0
    [  251.101967]        [<ffffffff81154168>] queue_work_on+0x98/0x120
    [  251.101967]        [<ffffffff81161351>] clock_was_set_delayed+0x21/0x30
    [  251.101967]        [<ffffffff811c4bd1>] do_adjtimex+0x111/0x160
    [  251.101967]        [<ffffffff811e2711>] compat_sys_adjtimex+0x41/0x70
    [  251.101967]        [<ffffffff843a4b49>] ia32_sysret+0x0/0x5
    [  251.101967]
    -> #0 (timekeeper_seq){----..}:
    [snipped]
    [  251.101967] other info that might help us debug this:
    [  251.101967]
    [  251.101967] Chain exists of:
      timekeeper_seq --> &rt_b->rt_runtime_lock --> hrtimer_bases.lock#11
    
    [  251.101967]  Possible unsafe locking scenario:
    [  251.101967]
    [  251.101967]        CPU0                    CPU1
    [  251.101967]        ----                    ----
    [  251.101967]   lock(hrtimer_bases.lock#11);
    [  251.101967]                                lock(&rt_b->rt_runtime_lock);
    [  251.101967]                                lock(hrtimer_bases.lock#11);
    [  251.101967]   lock(timekeeper_seq);
    [  251.101967]
    [  251.101967]  *** DEADLOCK ***
    [  251.101967]
    [  251.101967] 3 locks held by kworker/10:1/4506:
    [  251.101967]  #0:  (events){.+.+.+}, at: [<ffffffff81154960>] process_one_work+0x200/0x530
    [  251.101967]  #1:  (hrtimer_work){+.+...}, at: [<ffffffff81154960>] process_one_work+0x200/0x530
    [  251.101967]  #2:  (hrtimer_bases.lock#11){-.-...}, at: [<ffffffff81160e7c>] retrigger_next_event+0x3c/0x70
    [  251.101967]
    [  251.101967] stack backtrace:
    [  251.101967] CPU: 10 PID: 4506 Comm: kworker/10:1 Not tainted 3.13.0-rc2-next-20131206-sasha-00005-g8be2375-dirty #4053
    [  251.101967] Workqueue: events clock_was_set_work
    
    So the best solution is to avoid calling clock_was_set_delayed() while
    holding the timekeeping lock, and instead using a flag variable to
    decide if we should call clock_was_set() once we've released the locks.
    
    This works for the case here, where the do_adjtimex() was the deadlock
    trigger point. Unfortuantely, in update_wall_time() we still hold
    the jiffies lock, which would deadlock with the ipi triggered by
    clock_was_set(), preventing us from calling it even after we drop the
    timekeeping lock. So instead call clock_was_set_delayed() at that point.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Reported-by: Sasha Levin <sasha.levin@oracle.com>
    Tested-by: Sasha Levin <sasha.levin@oracle.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 7ffbcb388ddf91af51cb24eaacb51f6f0ffd535b
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Dec 11 18:50:25 2013 -0800

    timekeeping: Fix lost updates to tai adjustment
    
    commit f55c07607a38f84b5c7e6066ee1cfe433fa5643c upstream.
    
    Since 48cdc135d4840 (Implement a shadow timekeeper), we have to
    call timekeeping_update() after any adjustment to the timekeeping
    structure in order to make sure that any adjustments to the structure
    persist.
    
    Unfortunately, the updates to the tai offset via adjtimex do not
    trigger this update, causing adjustments to the tai offset to be
    made and then over-written by the previous value at the next
    update_wall_time() call.
    
    This patch resovles the issue by calling timekeeping_update()
    right after setting the tai offset.
    
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit b6f484eae189da008d6afa7b68414bdc5d460066
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Dec 10 17:18:18 2013 -0800

    timekeeping: Avoid possible deadlock from clock_was_set_delayed
    
    commit 6fdda9a9c5db367130cf32df5d6618d08b89f46a upstream.
    
    As part of normal operaions, the hrtimer subsystem frequently calls
    into the timekeeping code, creating a locking order of
      hrtimer locks -> timekeeping locks
    
    clock_was_set_delayed() was suppoed to allow us to avoid deadlocks
    between the timekeeping the hrtimer subsystem, so that we could
    notify the hrtimer subsytem the time had changed while holding
    the timekeeping locks. This was done by scheduling delayed work
    that would run later once we were out of the timekeeing code.
    
    But unfortunately the lock chains are complex enoguh that in
    scheduling delayed work, we end up eventually trying to grab
    an hrtimer lock.
    
    Sasha Levin noticed this in testing when the new seqlock lockdep
    enablement triggered the following (somewhat abrieviated) message:
    
    [  251.100221] ======================================================
    [  251.100221] [ INFO: possible circular locking dependency detected ]
    [  251.100221] 3.13.0-rc2-next-20131206-sasha-00005-g8be2375-dirty #4053 Not tainted
    [  251.101967] -------------------------------------------------------
    [  251.101967] kworker/10:1/4506 is trying to acquire lock:
    [  251.101967]  (timekeeper_seq){----..}, at: [<ffffffff81160e96>] retrigger_next_event+0x56/0x70
    [  251.101967]
    [  251.101967] but task is already holding lock:
    [  251.101967]  (hrtimer_bases.lock#11){-.-...}, at: [<ffffffff81160e7c>] retrigger_next_event+0x3c/0x70
    [  251.101967]
    [  251.101967] which lock already depends on the new lock.
    [  251.101967]
    [  251.101967]
    [  251.101967] the existing dependency chain (in reverse order) is:
    [  251.101967]
    -> #5 (hrtimer_bases.lock#11){-.-...}:
    [snipped]
    -> #4 (&rt_b->rt_runtime_lock){-.-...}:
    [snipped]
    -> #3 (&rq->lock){-.-.-.}:
    [snipped]
    -> #2 (&p->pi_lock){-.-.-.}:
    [snipped]
    -> #1 (&(&pool->lock)->rlock){-.-...}:
    [  251.101967]        [<ffffffff81194803>] validate_chain+0x6c3/0x7b0
    [  251.101967]        [<ffffffff81194d9d>] __lock_acquire+0x4ad/0x580
    [  251.101967]        [<ffffffff81194ff2>] lock_acquire+0x182/0x1d0
    [  251.101967]        [<ffffffff84398500>] _raw_spin_lock+0x40/0x80
    [  251.101967]        [<ffffffff81153e69>] __queue_work+0x1a9/0x3f0
    [  251.101967]        [<ffffffff81154168>] queue_work_on+0x98/0x120
    [  251.101967]        [<ffffffff81161351>] clock_was_set_delayed+0x21/0x30
    [  251.101967]        [<ffffffff811c4bd1>] do_adjtimex+0x111/0x160
    [  251.101967]        [<ffffffff811e2711>] compat_sys_adjtimex+0x41/0x70
    [  251.101967]        [<ffffffff843a4b49>] ia32_sysret+0x0/0x5
    [  251.101967]
    -> #0 (timekeeper_seq){----..}:
    [snipped]
    [  251.101967] other info that might help us debug this:
    [  251.101967]
    [  251.101967] Chain exists of:
      timekeeper_seq --> &rt_b->rt_runtime_lock --> hrtimer_bases.lock#11
    
    [  251.101967]  Possible unsafe locking scenario:
    [  251.101967]
    [  251.101967]        CPU0                    CPU1
    [  251.101967]        ----                    ----
    [  251.101967]   lock(hrtimer_bases.lock#11);
    [  251.101967]                                lock(&rt_b->rt_runtime_lock);
    [  251.101967]                                lock(hrtimer_bases.lock#11);
    [  251.101967]   lock(timekeeper_seq);
    [  251.101967]
    [  251.101967]  *** DEADLOCK ***
    [  251.101967]
    [  251.101967] 3 locks held by kworker/10:1/4506:
    [  251.101967]  #0:  (events){.+.+.+}, at: [<ffffffff81154960>] process_one_work+0x200/0x530
    [  251.101967]  #1:  (hrtimer_work){+.+...}, at: [<ffffffff81154960>] process_one_work+0x200/0x530
    [  251.101967]  #2:  (hrtimer_bases.lock#11){-.-...}, at: [<ffffffff81160e7c>] retrigger_next_event+0x3c/0x70
    [  251.101967]
    [  251.101967] stack backtrace:
    [  251.101967] CPU: 10 PID: 4506 Comm: kworker/10:1 Not tainted 3.13.0-rc2-next-20131206-sasha-00005-g8be2375-dirty #4053
    [  251.101967] Workqueue: events clock_was_set_work
    
    So the best solution is to avoid calling clock_was_set_delayed() while
    holding the timekeeping lock, and instead using a flag variable to
    decide if we should call clock_was_set() once we've released the locks.
    
    This works for the case here, where the do_adjtimex() was the deadlock
    trigger point. Unfortuantely, in update_wall_time() we still hold
    the jiffies lock, which would deadlock with the ipi triggered by
    clock_was_set(), preventing us from calling it even after we drop the
    timekeeping lock. So instead call clock_was_set_delayed() at that point.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Reported-by: Sasha Levin <sasha.levin@oracle.com>
    Tested-by: Sasha Levin <sasha.levin@oracle.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 89c23e583d4f29e026b6bb4e05b12e9e85b844cb
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Dec 11 18:50:25 2013 -0800

    timekeeping: Fix lost updates to tai adjustment
    
    commit f55c07607a38f84b5c7e6066ee1cfe433fa5643c upstream.
    
    Since 48cdc135d4840 (Implement a shadow timekeeper), we have to
    call timekeeping_update() after any adjustment to the timekeeping
    structure in order to make sure that any adjustments to the structure
    persist.
    
    Unfortunately, the updates to the tai offset via adjtimex do not
    trigger this update, causing adjustments to the tai offset to be
    made and then over-written by the previous value at the next
    update_wall_time() call.
    
    This patch resovles the issue by calling timekeeping_update()
    right after setting the tai offset.
    
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit d9e8fada0c0161f6fe2499a1b7dc9ce18e20fec2
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Dec 10 17:18:18 2013 -0800

    timekeeping: Avoid possible deadlock from clock_was_set_delayed
    
    commit 6fdda9a9c5db367130cf32df5d6618d08b89f46a upstream.
    
    As part of normal operaions, the hrtimer subsystem frequently calls
    into the timekeeping code, creating a locking order of
      hrtimer locks -> timekeeping locks
    
    clock_was_set_delayed() was suppoed to allow us to avoid deadlocks
    between the timekeeping the hrtimer subsystem, so that we could
    notify the hrtimer subsytem the time had changed while holding
    the timekeeping locks. This was done by scheduling delayed work
    that would run later once we were out of the timekeeing code.
    
    But unfortunately the lock chains are complex enoguh that in
    scheduling delayed work, we end up eventually trying to grab
    an hrtimer lock.
    
    Sasha Levin noticed this in testing when the new seqlock lockdep
    enablement triggered the following (somewhat abrieviated) message:
    
    [  251.100221] ======================================================
    [  251.100221] [ INFO: possible circular locking dependency detected ]
    [  251.100221] 3.13.0-rc2-next-20131206-sasha-00005-g8be2375-dirty #4053 Not tainted
    [  251.101967] -------------------------------------------------------
    [  251.101967] kworker/10:1/4506 is trying to acquire lock:
    [  251.101967]  (timekeeper_seq){----..}, at: [<ffffffff81160e96>] retrigger_next_event+0x56/0x70
    [  251.101967]
    [  251.101967] but task is already holding lock:
    [  251.101967]  (hrtimer_bases.lock#11){-.-...}, at: [<ffffffff81160e7c>] retrigger_next_event+0x3c/0x70
    [  251.101967]
    [  251.101967] which lock already depends on the new lock.
    [  251.101967]
    [  251.101967]
    [  251.101967] the existing dependency chain (in reverse order) is:
    [  251.101967]
    -> #5 (hrtimer_bases.lock#11){-.-...}:
    [snipped]
    -> #4 (&rt_b->rt_runtime_lock){-.-...}:
    [snipped]
    -> #3 (&rq->lock){-.-.-.}:
    [snipped]
    -> #2 (&p->pi_lock){-.-.-.}:
    [snipped]
    -> #1 (&(&pool->lock)->rlock){-.-...}:
    [  251.101967]        [<ffffffff81194803>] validate_chain+0x6c3/0x7b0
    [  251.101967]        [<ffffffff81194d9d>] __lock_acquire+0x4ad/0x580
    [  251.101967]        [<ffffffff81194ff2>] lock_acquire+0x182/0x1d0
    [  251.101967]        [<ffffffff84398500>] _raw_spin_lock+0x40/0x80
    [  251.101967]        [<ffffffff81153e69>] __queue_work+0x1a9/0x3f0
    [  251.101967]        [<ffffffff81154168>] queue_work_on+0x98/0x120
    [  251.101967]        [<ffffffff81161351>] clock_was_set_delayed+0x21/0x30
    [  251.101967]        [<ffffffff811c4bd1>] do_adjtimex+0x111/0x160
    [  251.101967]        [<ffffffff811e2711>] compat_sys_adjtimex+0x41/0x70
    [  251.101967]        [<ffffffff843a4b49>] ia32_sysret+0x0/0x5
    [  251.101967]
    -> #0 (timekeeper_seq){----..}:
    [snipped]
    [  251.101967] other info that might help us debug this:
    [  251.101967]
    [  251.101967] Chain exists of:
      timekeeper_seq --> &rt_b->rt_runtime_lock --> hrtimer_bases.lock#11
    
    [  251.101967]  Possible unsafe locking scenario:
    [  251.101967]
    [  251.101967]        CPU0                    CPU1
    [  251.101967]        ----                    ----
    [  251.101967]   lock(hrtimer_bases.lock#11);
    [  251.101967]                                lock(&rt_b->rt_runtime_lock);
    [  251.101967]                                lock(hrtimer_bases.lock#11);
    [  251.101967]   lock(timekeeper_seq);
    [  251.101967]
    [  251.101967]  *** DEADLOCK ***
    [  251.101967]
    [  251.101967] 3 locks held by kworker/10:1/4506:
    [  251.101967]  #0:  (events){.+.+.+}, at: [<ffffffff81154960>] process_one_work+0x200/0x530
    [  251.101967]  #1:  (hrtimer_work){+.+...}, at: [<ffffffff81154960>] process_one_work+0x200/0x530
    [  251.101967]  #2:  (hrtimer_bases.lock#11){-.-...}, at: [<ffffffff81160e7c>] retrigger_next_event+0x3c/0x70
    [  251.101967]
    [  251.101967] stack backtrace:
    [  251.101967] CPU: 10 PID: 4506 Comm: kworker/10:1 Not tainted 3.13.0-rc2-next-20131206-sasha-00005-g8be2375-dirty #4053
    [  251.101967] Workqueue: events clock_was_set_work
    
    So the best solution is to avoid calling clock_was_set_delayed() while
    holding the timekeeping lock, and instead using a flag variable to
    decide if we should call clock_was_set() once we've released the locks.
    
    This works for the case here, where the do_adjtimex() was the deadlock
    trigger point. Unfortuantely, in update_wall_time() we still hold
    the jiffies lock, which would deadlock with the ipi triggered by
    clock_was_set(), preventing us from calling it even after we drop the
    timekeeping lock. So instead call clock_was_set_delayed() at that point.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Reported-by: Sasha Levin <sasha.levin@oracle.com>
    Tested-by: Sasha Levin <sasha.levin@oracle.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 77535a0a168b2bf7c4aa35a20792a6e895844424
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Dec 11 18:50:25 2013 -0800

    timekeeping: Fix lost updates to tai adjustment
    
    commit f55c07607a38f84b5c7e6066ee1cfe433fa5643c upstream.
    
    Since 48cdc135d4840 (Implement a shadow timekeeper), we have to
    call timekeeping_update() after any adjustment to the timekeeping
    structure in order to make sure that any adjustments to the structure
    persist.
    
    Unfortunately, the updates to the tai offset via adjtimex do not
    trigger this update, causing adjustments to the tai offset to be
    made and then over-written by the previous value at the next
    update_wall_time() call.
    
    This patch resovles the issue by calling timekeeping_update()
    right after setting the tai offset.
    
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit cf85cc93b24891b7e57b1d9939742b5774570b19
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Dec 10 17:18:18 2013 -0800

    timekeeping: Avoid possible deadlock from clock_was_set_delayed
    
    commit 6fdda9a9c5db367130cf32df5d6618d08b89f46a upstream.
    
    As part of normal operaions, the hrtimer subsystem frequently calls
    into the timekeeping code, creating a locking order of
      hrtimer locks -> timekeeping locks
    
    clock_was_set_delayed() was suppoed to allow us to avoid deadlocks
    between the timekeeping the hrtimer subsystem, so that we could
    notify the hrtimer subsytem the time had changed while holding
    the timekeeping locks. This was done by scheduling delayed work
    that would run later once we were out of the timekeeing code.
    
    But unfortunately the lock chains are complex enoguh that in
    scheduling delayed work, we end up eventually trying to grab
    an hrtimer lock.
    
    Sasha Levin noticed this in testing when the new seqlock lockdep
    enablement triggered the following (somewhat abrieviated) message:
    
    [  251.100221] ======================================================
    [  251.100221] [ INFO: possible circular locking dependency detected ]
    [  251.100221] 3.13.0-rc2-next-20131206-sasha-00005-g8be2375-dirty #4053 Not tainted
    [  251.101967] -------------------------------------------------------
    [  251.101967] kworker/10:1/4506 is trying to acquire lock:
    [  251.101967]  (timekeeper_seq){----..}, at: [<ffffffff81160e96>] retrigger_next_event+0x56/0x70
    [  251.101967]
    [  251.101967] but task is already holding lock:
    [  251.101967]  (hrtimer_bases.lock#11){-.-...}, at: [<ffffffff81160e7c>] retrigger_next_event+0x3c/0x70
    [  251.101967]
    [  251.101967] which lock already depends on the new lock.
    [  251.101967]
    [  251.101967]
    [  251.101967] the existing dependency chain (in reverse order) is:
    [  251.101967]
    -> #5 (hrtimer_bases.lock#11){-.-...}:
    [snipped]
    -> #4 (&rt_b->rt_runtime_lock){-.-...}:
    [snipped]
    -> #3 (&rq->lock){-.-.-.}:
    [snipped]
    -> #2 (&p->pi_lock){-.-.-.}:
    [snipped]
    -> #1 (&(&pool->lock)->rlock){-.-...}:
    [  251.101967]        [<ffffffff81194803>] validate_chain+0x6c3/0x7b0
    [  251.101967]        [<ffffffff81194d9d>] __lock_acquire+0x4ad/0x580
    [  251.101967]        [<ffffffff81194ff2>] lock_acquire+0x182/0x1d0
    [  251.101967]        [<ffffffff84398500>] _raw_spin_lock+0x40/0x80
    [  251.101967]        [<ffffffff81153e69>] __queue_work+0x1a9/0x3f0
    [  251.101967]        [<ffffffff81154168>] queue_work_on+0x98/0x120
    [  251.101967]        [<ffffffff81161351>] clock_was_set_delayed+0x21/0x30
    [  251.101967]        [<ffffffff811c4bd1>] do_adjtimex+0x111/0x160
    [  251.101967]        [<ffffffff811e2711>] compat_sys_adjtimex+0x41/0x70
    [  251.101967]        [<ffffffff843a4b49>] ia32_sysret+0x0/0x5
    [  251.101967]
    -> #0 (timekeeper_seq){----..}:
    [snipped]
    [  251.101967] other info that might help us debug this:
    [  251.101967]
    [  251.101967] Chain exists of:
      timekeeper_seq --> &rt_b->rt_runtime_lock --> hrtimer_bases.lock#11
    
    [  251.101967]  Possible unsafe locking scenario:
    [  251.101967]
    [  251.101967]        CPU0                    CPU1
    [  251.101967]        ----                    ----
    [  251.101967]   lock(hrtimer_bases.lock#11);
    [  251.101967]                                lock(&rt_b->rt_runtime_lock);
    [  251.101967]                                lock(hrtimer_bases.lock#11);
    [  251.101967]   lock(timekeeper_seq);
    [  251.101967]
    [  251.101967]  *** DEADLOCK ***
    [  251.101967]
    [  251.101967] 3 locks held by kworker/10:1/4506:
    [  251.101967]  #0:  (events){.+.+.+}, at: [<ffffffff81154960>] process_one_work+0x200/0x530
    [  251.101967]  #1:  (hrtimer_work){+.+...}, at: [<ffffffff81154960>] process_one_work+0x200/0x530
    [  251.101967]  #2:  (hrtimer_bases.lock#11){-.-...}, at: [<ffffffff81160e7c>] retrigger_next_event+0x3c/0x70
    [  251.101967]
    [  251.101967] stack backtrace:
    [  251.101967] CPU: 10 PID: 4506 Comm: kworker/10:1 Not tainted 3.13.0-rc2-next-20131206-sasha-00005-g8be2375-dirty #4053
    [  251.101967] Workqueue: events clock_was_set_work
    
    So the best solution is to avoid calling clock_was_set_delayed() while
    holding the timekeeping lock, and instead using a flag variable to
    decide if we should call clock_was_set() once we've released the locks.
    
    This works for the case here, where the do_adjtimex() was the deadlock
    trigger point. Unfortuantely, in update_wall_time() we still hold
    the jiffies lock, which would deadlock with the ipi triggered by
    clock_was_set(), preventing us from calling it even after we drop the
    timekeeping lock. So instead call clock_was_set_delayed() at that point.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Reported-by: Sasha Levin <sasha.levin@oracle.com>
    Tested-by: Sasha Levin <sasha.levin@oracle.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 7fb30128527a4220f181c2867edd9ac178175a87
Author: H.J. Lu <hjl.tools@gmail.com>
Date:   Fri Dec 27 14:14:17 2013 -0800

    uapi: Use __kernel_long_t in struct timex
    
    x32 adjtimex system call is the same as x86-64 adjtimex system call,
    which uses 64-bit integer for long in struct timex. But x32 long is
    32 bit.  This patch replaces long in struct timex with __kernel_long_t.
    
    Signed-off-by: H.J. Lu <hjl.tools@gmail.com>
    Link: http://lkml.kernel.org/r/1388182464-28428-2-git-send-email-hjl.tools@gmail.com
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>

commit 6fdda9a9c5db367130cf32df5d6618d08b89f46a
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Dec 10 17:18:18 2013 -0800

    timekeeping: Avoid possible deadlock from clock_was_set_delayed
    
    As part of normal operaions, the hrtimer subsystem frequently calls
    into the timekeeping code, creating a locking order of
      hrtimer locks -> timekeeping locks
    
    clock_was_set_delayed() was suppoed to allow us to avoid deadlocks
    between the timekeeping the hrtimer subsystem, so that we could
    notify the hrtimer subsytem the time had changed while holding
    the timekeeping locks. This was done by scheduling delayed work
    that would run later once we were out of the timekeeing code.
    
    But unfortunately the lock chains are complex enoguh that in
    scheduling delayed work, we end up eventually trying to grab
    an hrtimer lock.
    
    Sasha Levin noticed this in testing when the new seqlock lockdep
    enablement triggered the following (somewhat abrieviated) message:
    
    [  251.100221] ======================================================
    [  251.100221] [ INFO: possible circular locking dependency detected ]
    [  251.100221] 3.13.0-rc2-next-20131206-sasha-00005-g8be2375-dirty #4053 Not tainted
    [  251.101967] -------------------------------------------------------
    [  251.101967] kworker/10:1/4506 is trying to acquire lock:
    [  251.101967]  (timekeeper_seq){----..}, at: [<ffffffff81160e96>] retrigger_next_event+0x56/0x70
    [  251.101967]
    [  251.101967] but task is already holding lock:
    [  251.101967]  (hrtimer_bases.lock#11){-.-...}, at: [<ffffffff81160e7c>] retrigger_next_event+0x3c/0x70
    [  251.101967]
    [  251.101967] which lock already depends on the new lock.
    [  251.101967]
    [  251.101967]
    [  251.101967] the existing dependency chain (in reverse order) is:
    [  251.101967]
    -> #5 (hrtimer_bases.lock#11){-.-...}:
    [snipped]
    -> #4 (&rt_b->rt_runtime_lock){-.-...}:
    [snipped]
    -> #3 (&rq->lock){-.-.-.}:
    [snipped]
    -> #2 (&p->pi_lock){-.-.-.}:
    [snipped]
    -> #1 (&(&pool->lock)->rlock){-.-...}:
    [  251.101967]        [<ffffffff81194803>] validate_chain+0x6c3/0x7b0
    [  251.101967]        [<ffffffff81194d9d>] __lock_acquire+0x4ad/0x580
    [  251.101967]        [<ffffffff81194ff2>] lock_acquire+0x182/0x1d0
    [  251.101967]        [<ffffffff84398500>] _raw_spin_lock+0x40/0x80
    [  251.101967]        [<ffffffff81153e69>] __queue_work+0x1a9/0x3f0
    [  251.101967]        [<ffffffff81154168>] queue_work_on+0x98/0x120
    [  251.101967]        [<ffffffff81161351>] clock_was_set_delayed+0x21/0x30
    [  251.101967]        [<ffffffff811c4bd1>] do_adjtimex+0x111/0x160
    [  251.101967]        [<ffffffff811e2711>] compat_sys_adjtimex+0x41/0x70
    [  251.101967]        [<ffffffff843a4b49>] ia32_sysret+0x0/0x5
    [  251.101967]
    -> #0 (timekeeper_seq){----..}:
    [snipped]
    [  251.101967] other info that might help us debug this:
    [  251.101967]
    [  251.101967] Chain exists of:
      timekeeper_seq --> &rt_b->rt_runtime_lock --> hrtimer_bases.lock#11
    
    [  251.101967]  Possible unsafe locking scenario:
    [  251.101967]
    [  251.101967]        CPU0                    CPU1
    [  251.101967]        ----                    ----
    [  251.101967]   lock(hrtimer_bases.lock#11);
    [  251.101967]                                lock(&rt_b->rt_runtime_lock);
    [  251.101967]                                lock(hrtimer_bases.lock#11);
    [  251.101967]   lock(timekeeper_seq);
    [  251.101967]
    [  251.101967]  *** DEADLOCK ***
    [  251.101967]
    [  251.101967] 3 locks held by kworker/10:1/4506:
    [  251.101967]  #0:  (events){.+.+.+}, at: [<ffffffff81154960>] process_one_work+0x200/0x530
    [  251.101967]  #1:  (hrtimer_work){+.+...}, at: [<ffffffff81154960>] process_one_work+0x200/0x530
    [  251.101967]  #2:  (hrtimer_bases.lock#11){-.-...}, at: [<ffffffff81160e7c>] retrigger_next_event+0x3c/0x70
    [  251.101967]
    [  251.101967] stack backtrace:
    [  251.101967] CPU: 10 PID: 4506 Comm: kworker/10:1 Not tainted 3.13.0-rc2-next-20131206-sasha-00005-g8be2375-dirty #4053
    [  251.101967] Workqueue: events clock_was_set_work
    
    So the best solution is to avoid calling clock_was_set_delayed() while
    holding the timekeeping lock, and instead using a flag variable to
    decide if we should call clock_was_set() once we've released the locks.
    
    This works for the case here, where the do_adjtimex() was the deadlock
    trigger point. Unfortuantely, in update_wall_time() we still hold
    the jiffies lock, which would deadlock with the ipi triggered by
    clock_was_set(), preventing us from calling it even after we drop the
    timekeeping lock. So instead call clock_was_set_delayed() at that point.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Cc: stable <stable@vger.kernel.org> #3.10+
    Reported-by: Sasha Levin <sasha.levin@oracle.com>
    Tested-by: Sasha Levin <sasha.levin@oracle.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit f55c07607a38f84b5c7e6066ee1cfe433fa5643c
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Dec 11 18:50:25 2013 -0800

    timekeeping: Fix lost updates to tai adjustment
    
    Since 48cdc135d4840 (Implement a shadow timekeeper), we have to
    call timekeeping_update() after any adjustment to the timekeeping
    structure in order to make sure that any adjustments to the structure
    persist.
    
    Unfortunately, the updates to the tai offset via adjtimex do not
    trigger this update, causing adjustments to the tai offset to be
    made and then over-written by the previous value at the next
    update_wall_time() call.
    
    This patch resovles the issue by calling timekeeping_update()
    right after setting the tai offset.
    
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: stable <stable@vger.kernel.org> #3.10+
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 7ee4ddd24bf7ceee9400de450f69e327f7970f7c
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Sep 11 16:50:56 2013 -0700

    timekeeping: Fix HRTICK related deadlock from ntp lock changes
    
    commit 7bd36014460f793c19e7d6c94dab67b0afcfcb7f upstream.
    
    Gerlando Falauto reported that when HRTICK is enabled, it is
    possible to trigger system deadlocks. These were hard to
    reproduce, as HRTICK has been broken in the past, but seemed
    to be connected to the timekeeping_seq lock.
    
    Since seqlock/seqcount's aren't supported w/ lockdep, I added
    some extra spinlock based locking and triggered the following
    lockdep output:
    
    [   15.849182] ntpd/4062 is trying to acquire lock:
    [   15.849765]  (&(&pool->lock)->rlock){..-...}, at: [<ffffffff810aa9b5>] __queue_work+0x145/0x480
    [   15.850051]
    [   15.850051] but task is already holding lock:
    [   15.850051]  (timekeeper_lock){-.-.-.}, at: [<ffffffff810df6df>] do_adjtimex+0x7f/0x100
    
    <snip>
    
    [   15.850051] Chain exists of: &(&pool->lock)->rlock --> &p->pi_lock --> timekeeper_lock
    [   15.850051]  Possible unsafe locking scenario:
    [   15.850051]
    [   15.850051]        CPU0                    CPU1
    [   15.850051]        ----                    ----
    [   15.850051]   lock(timekeeper_lock);
    [   15.850051]                                lock(&p->pi_lock);
    [   15.850051] lock(timekeeper_lock);
    [   15.850051] lock(&(&pool->lock)->rlock);
    [   15.850051]
    [   15.850051]  *** DEADLOCK ***
    
    The deadlock was introduced by 06c017fdd4dc48451a ("timekeeping:
    Hold timekeepering locks in do_adjtimex and hardpps") in 3.10
    
    This patch avoids this deadlock, by moving the call to
    schedule_delayed_work() outside of the timekeeper lock
    critical section.
    
    Reported-by: Gerlando Falauto <gerlando.falauto@keymile.com>
    Tested-by: Lin Ming <minggr@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
    Link: http://lkml.kernel.org/r/1378943457-27314-1-git-send-email-john.stultz@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 63946e8616205dafe39b4d88f9fc3dc7c4fd79aa
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Sep 11 16:50:56 2013 -0700

    timekeeping: Fix HRTICK related deadlock from ntp lock changes
    
    commit 7bd36014460f793c19e7d6c94dab67b0afcfcb7f upstream.
    
    Gerlando Falauto reported that when HRTICK is enabled, it is
    possible to trigger system deadlocks. These were hard to
    reproduce, as HRTICK has been broken in the past, but seemed
    to be connected to the timekeeping_seq lock.
    
    Since seqlock/seqcount's aren't supported w/ lockdep, I added
    some extra spinlock based locking and triggered the following
    lockdep output:
    
    [   15.849182] ntpd/4062 is trying to acquire lock:
    [   15.849765]  (&(&pool->lock)->rlock){..-...}, at: [<ffffffff810aa9b5>] __queue_work+0x145/0x480
    [   15.850051]
    [   15.850051] but task is already holding lock:
    [   15.850051]  (timekeeper_lock){-.-.-.}, at: [<ffffffff810df6df>] do_adjtimex+0x7f/0x100
    
    <snip>
    
    [   15.850051] Chain exists of: &(&pool->lock)->rlock --> &p->pi_lock --> timekeeper_lock
    [   15.850051]  Possible unsafe locking scenario:
    [   15.850051]
    [   15.850051]        CPU0                    CPU1
    [   15.850051]        ----                    ----
    [   15.850051]   lock(timekeeper_lock);
    [   15.850051]                                lock(&p->pi_lock);
    [   15.850051] lock(timekeeper_lock);
    [   15.850051] lock(&(&pool->lock)->rlock);
    [   15.850051]
    [   15.850051]  *** DEADLOCK ***
    
    The deadlock was introduced by 06c017fdd4dc48451a ("timekeeping:
    Hold timekeepering locks in do_adjtimex and hardpps") in 3.10
    
    This patch avoids this deadlock, by moving the call to
    schedule_delayed_work() outside of the timekeeper lock
    critical section.
    
    Reported-by: Gerlando Falauto <gerlando.falauto@keymile.com>
    Tested-by: Lin Ming <minggr@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
    Link: http://lkml.kernel.org/r/1378943457-27314-1-git-send-email-john.stultz@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 7bd36014460f793c19e7d6c94dab67b0afcfcb7f
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Sep 11 16:50:56 2013 -0700

    timekeeping: Fix HRTICK related deadlock from ntp lock changes
    
    Gerlando Falauto reported that when HRTICK is enabled, it is
    possible to trigger system deadlocks. These were hard to
    reproduce, as HRTICK has been broken in the past, but seemed
    to be connected to the timekeeping_seq lock.
    
    Since seqlock/seqcount's aren't supported w/ lockdep, I added
    some extra spinlock based locking and triggered the following
    lockdep output:
    
    [   15.849182] ntpd/4062 is trying to acquire lock:
    [   15.849765]  (&(&pool->lock)->rlock){..-...}, at: [<ffffffff810aa9b5>] __queue_work+0x145/0x480
    [   15.850051]
    [   15.850051] but task is already holding lock:
    [   15.850051]  (timekeeper_lock){-.-.-.}, at: [<ffffffff810df6df>] do_adjtimex+0x7f/0x100
    
    <snip>
    
    [   15.850051] Chain exists of: &(&pool->lock)->rlock --> &p->pi_lock --> timekeeper_lock
    [   15.850051]  Possible unsafe locking scenario:
    [   15.850051]
    [   15.850051]        CPU0                    CPU1
    [   15.850051]        ----                    ----
    [   15.850051]   lock(timekeeper_lock);
    [   15.850051]                                lock(&p->pi_lock);
    [   15.850051] lock(timekeeper_lock);
    [   15.850051] lock(&(&pool->lock)->rlock);
    [   15.850051]
    [   15.850051]  *** DEADLOCK ***
    
    The deadlock was introduced by 06c017fdd4dc48451a ("timekeeping:
    Hold timekeepering locks in do_adjtimex and hardpps") in 3.10
    
    This patch avoids this deadlock, by moving the call to
    schedule_delayed_work() outside of the timekeeper lock
    critical section.
    
    Reported-by: Gerlando Falauto <gerlando.falauto@keymile.com>
    Tested-by: Lin Ming <minggr@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
    Cc: stable <stable@vger.kernel.org> #3.11, 3.10
    Link: http://lkml.kernel.org/r/1378943457-27314-1-git-send-email-john.stultz@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit ab86e974f04b1cd827a9c7c35273834ebcd9ab38
Merge: 8700c95adb03 6f7a05d7018d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Apr 30 08:15:40 2013 -0700

    Merge branch 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull core timer updates from Ingo Molnar:
     "The main changes in this cycle's merge are:
    
       - Implement shadow timekeeper to shorten in kernel reader side
         blocking, by Thomas Gleixner.
    
       - Posix timers enhancements by Pavel Emelyanov:
    
       - allocate timer ID per process, so that exact timer ID allocations
         can be re-created be checkpoint/restore code.
    
       - debuggability and tooling (/proc/PID/timers, etc.) improvements.
    
       - suspend/resume enhancements by Feng Tang: on certain new Intel Atom
         processors (Penwell and Cloverview), there is a feature that the
         TSC won't stop in S3 state, so the TSC value won't be reset to 0
         after resume.  This can be taken advantage of by the generic via
         the CLOCK_SOURCE_SUSPEND_NONSTOP flag: instead of using the RTC to
         recover/approximate sleep time, the main (and precise) clocksource
         can be used.
    
       - Fix /proc/timer_list for 4096 CPUs by Nathan Zimmer: on so many
         CPUs the file goes beyond 4MB of size and thus the current
         simplistic seqfile approach fails.  Convert /proc/timer_list to a
         proper seq_file with its own iterator.
    
       - Cleanups and refactorings of the core timekeeping code by John
         Stultz.
    
       - International Atomic Clock time is managed by the NTP code
         internally currently but not exposed externally.  Separate the TAI
         code out and add CLOCK_TAI support and TAI support to the hrtimer
         and posix-timer code, by John Stultz.
    
       - Add deep idle support enhacement to the broadcast clockevents core
         timer code, by Daniel Lezcano: add an opt-in CLOCK_EVT_FEAT_DYNIRQ
         clockevents feature (which will be utilized by future clockevents
         driver updates), which allows the use of IRQ affinities to avoid
         spurious wakeups of idle CPUs - the right CPU with an expiring
         timer will be woken.
    
       - Add new ARM bcm281xx clocksource driver, by Christian Daudt
    
       - ... various other fixes and cleanups"
    
    * 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (52 commits)
      clockevents: Set dummy handler on CPU_DEAD shutdown
      timekeeping: Update tk->cycle_last in resume
      posix-timers: Remove unused variable
      clockevents: Switch into oneshot mode even if broadcast registered late
      timer_list: Convert timer list to be a proper seq_file
      timer_list: Split timer_list_show_tickdevices
      posix-timers: Show sigevent info in proc file
      posix-timers: Introduce /proc/PID/timers file
      posix timers: Allocate timer id per process (v2)
      timekeeping: Make sure to notify hrtimers when TAI offset changes
      hrtimer: Fix ktime_add_ns() overflow on 32bit architectures
      hrtimer: Add expiry time overflow check in hrtimer_interrupt
      timekeeping: Shorten seq_count region
      timekeeping: Implement a shadow timekeeper
      timekeeping: Delay update of clock->cycle_last
      timekeeping: Store cycle_last value in timekeeper struct as well
      ntp: Remove ntp_lock, using the timekeeping locks to protect ntp state
      timekeeping: Simplify tai updating from do_adjtimex
      timekeeping: Hold timekeepering locks in do_adjtimex and hardpps
      timekeeping: Move ADJ_SETOFFSET to top level do_adjtimex()
      ...

commit 0b5154fb9040cca94e7d9893384c0e78bfe2d296
Author: John Stultz <john.stultz@linaro.org>
Date:   Fri Mar 22 14:20:03 2013 -0700

    timekeeping: Simplify tai updating from do_adjtimex
    
    Since we are taking the timekeeping locks, just go ahead
    and update any tai change directly, rather then dropping
    the lock and calling a function that will just take it again.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 06c017fdd4dc48451a29ac37fc1db4a3f86b7f40
Author: John Stultz <john.stultz@linaro.org>
Date:   Fri Mar 22 11:37:28 2013 -0700

    timekeeping: Hold timekeepering locks in do_adjtimex and hardpps
    
    In moving the NTP state to be protected by the timekeeping locks,
    be sure to acquire the timekeeping locks prior to calling
    ntp functions.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit cef90377fab488bd1f959efda178fb83250cf61d
Author: John Stultz <john.stultz@linaro.org>
Date:   Fri Mar 22 15:04:13 2013 -0700

    timekeeping: Move ADJ_SETOFFSET to top level do_adjtimex()
    
    Since ADJ_SETOFFSET adjusts the timekeeping state, process
    it as part of the top level do_adjtimex() function in
    timekeeping.c.
    
    This avoids deadlocks that could occur once we change the
    ntp locking rules.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 87ace39b7168bd9d352c1c52b6f5d88eb1876cf8
Author: John Stultz <john.stultz@linaro.org>
Date:   Fri Mar 22 12:28:15 2013 -0700

    ntp: Rework do_adjtimex to take timespec and tai arguments
    
    In order to change the locking rules, we need to provide
    the timespec and tai values rather then having the ntp
    logic acquire these values itself.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit e4085693f629ded8ac8c35b5cdd324d20242990b
Author: John Stultz <john.stultz@linaro.org>
Date:   Fri Mar 22 12:08:52 2013 -0700

    ntp: Move timex validation to timekeeping do_adjtimex call.
    
    Move logic that does not need the ntp state to be done
    in the timekeeping do_adjtimex() call.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit aa6f9c595d857328e5d815e5b94c0e7cd31a6b59
Author: John Stultz <john.stultz@linaro.org>
Date:   Fri Mar 22 11:31:29 2013 -0700

    ntp: Move do_adjtimex() and hardpps() functions to timekeeping.c
    
    In preparation for changing the ntp locking rules, move
    do_adjtimex and hardpps accessor functions to timekeeping.c,
    but keep the code logic in ntp.c.
    
    This patch also introduces a ntp_internal.h file so timekeeping
    specific interfaces of ntp.c can be more limitedly shared with
    timekeeping.c.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit ad460967a2953496ad76b1c22091ea99f21b4e86
Author: John Stultz <john.stultz@linaro.org>
Date:   Fri Mar 22 11:59:04 2013 -0700

    ntp: Split out timex validation from do_adjtimex
    
    Split out the timex validation done in do_adjtimex into a separate
    function. This will help simplify logic in following patches.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit aa94bf27d464126a42212d486211946f93d21b00
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Mon Jan 21 03:02:48 2013 +0000

    drivers/net/ethernet/sfc/ptp.c: adjust duplicate test
    
    [ Upstream commit 56567c6f8751c633581ca7c8e1cf08eed503f5ea ]
    
    Delete successive tests to the same location.  rc was previously tested and
    not subsequently updated.  efx_phc_adjtime can return an error code, so the
    call is updated so that is tested instead.
    
    A simplified version of the semantic match that finds this problem is as
    follows: (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @s exists@
    local idexpression y;
    expression x,e;
    @@
    
    *if ( \(x == NULL\|IS_ERR(x)\|y != 0\) )
     { ... when forall
       return ...; }
    ... when != \(y = e\|y += e\|y -= e\|y |= e\|y &= e\|y++\|y--\|&y\)
        when != \(XT_GETPAGE(...,y)\|WMI_CMD_BUF(...)\)
    *if ( \(x == NULL\|IS_ERR(x)\|y != 0\) )
     { ... when forall
       return ...; }
    // </smpl>
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Acked-by: Ben Hutchings <bhutchings@solarflare.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 266d7ad7f4fe2f44b91561f5b812115c1b3018ab
Merge: bcbd818c069b 36dfbbf136db
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Feb 19 19:05:45 2013 -0800

    Merge branch 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer changes from Ingo Molnar:
     "Main changes:
    
       - ntp: Add CONFIG_RTC_SYSTOHC: a generic RTC driver facility
         complementing the existing CONFIG_RTC_HCTOSYS, which uses NTP to
         keep the hardware clock updated.
    
       - posix-timers: Fix clock_adjtime to always return timex data on
         success.  This is changing the ABI, but no breakage was expected
         and found - caution is warranted nevertheless.
    
       - platform persistent clock improvements/cleanups.
    
       - clockevents: refactor timer broadcast handling to be more generic
         and less duplicated with matching architecture code (mostly ARM
         motivated.)
    
       - various fixes and cleanups"
    
    * 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      timers/x86/hpet: Use HPET_COUNTER to specify the hpet counter in vread_hpet()
      posix-cpu-timers: Fix nanosleep task_struct leak
      clockevents: Fix generic broadcast for FEAT_C3STOP
      time, Fix setting of hardware clock in NTP code
      hrtimer: Prevent hrtimer_enqueue_reprogram race
      clockevents: Add generic timer broadcast function
      clockevents: Add generic timer broadcast receiver
      timekeeping: Switch HAS_PERSISTENT_CLOCK to ALWAYS_USE_PERSISTENT_CLOCK
      x86/time/rtc: Don't print extended CMOS year when reading RTC
      x86: Select HAS_PERSISTENT_CLOCK on x86
      timekeeping: Add CONFIG_HAS_PERSISTENT_CLOCK option
      rtc: Skip the suspend/resume handling if persistent clock exist
      timekeeping: Add persistent_clock_exist flag
      posix-timers: Fix clock_adjtime to always return timex data on success
      Round the calculated scale factor in set_cyc2ns_scale()
      NTP: Add a CONFIG_RTC_SYSTOHC configuration
      MAINTAINERS: Update John Stultz's email
      time: create __getnstimeofday for WARNless calls

commit 56567c6f8751c633581ca7c8e1cf08eed503f5ea
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Mon Jan 21 03:02:48 2013 +0000

    drivers/net/ethernet/sfc/ptp.c: adjust duplicate test
    
    Delete successive tests to the same location.  rc was previously tested and
    not subsequently updated.  efx_phc_adjtime can return an error code, so the
    call is updated so that is tested instead.
    
    A simplified version of the semantic match that finds this problem is as
    follows: (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @s exists@
    local idexpression y;
    expression x,e;
    @@
    
    *if ( \(x == NULL\|IS_ERR(x)\|y != 0\) )
     { ... when forall
       return ...; }
    ... when != \(y = e\|y += e\|y -= e\|y |= e\|y &= e\|y++\|y--\|&y\)
        when != \(XT_GETPAGE(...,y)\|WMI_CMD_BUF(...)\)
    *if ( \(x == NULL\|IS_ERR(x)\|y != 0\) )
     { ... when forall
       return ...; }
    // </smpl>
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Acked-by: Ben Hutchings <bhutchings@solarflare.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 11ce0e7a9396b85a6f42cec5ec009d70d7b10652
Author: John Stultz <john.stultz@linaro.org>
Date:   Mon Sep 17 21:38:45 2012 -0400

    time: Improve sanity checking of timekeeping inputs
    
    commit 4e8b14526ca7fb046a81c94002c1c43b6fdf0e9b upstream.
    
    Unexpected behavior could occur if the time is set to a value large
    enough to overflow a 64bit ktime_t (which is something larger then the
    year 2262).
    
    Also unexpected behavior could occur if large negative offsets are
    injected via adjtimex.
    
    So this patch improves the sanity check timekeeping inputs by
    improving the timespec_valid() check, and then makes better use of
    timespec_valid() to make sure we don't set the time to an invalid
    negative value or one that overflows ktime_t.
    
    Note: This does not protect from setting the time close to overflowing
    ktime_t and then letting natural accumulation cause the overflow.
    
    Reported-by: CAI Qian <caiqian@redhat.com>
    Reported-by: Sasha Levin <levinsasha928@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Zhouping Liu <zliu@redhat.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Link: http://lkml.kernel.org/r/1344454580-17031-1-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Linux Kernel <linux-kernel@vger.kernel.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

commit f0dbe81f0e7c39783ad25d9084bbcda131508993
Author: Miroslav Lichvar <mlichvar@redhat.com>
Date:   Fri Jan 11 11:58:58 2013 +0100

    posix-timers: Fix clock_adjtime to always return timex data on success
    
    The clock_adj call returns the clock state on success, which may be a
    non-zero value (e.g. TIME_INS), but the modified timex data is copied
    back to the user only when zero value (TIME_OK) was returned. Fix the
    condition to copy the data also with positive return values.
    
    Signed-off-by: Miroslav Lichvar <mlichvar@redhat.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit 7a13eba369913bfd2f363b722d2831db5c3669df
Author: Al Viro <viro@ZenIV.linux.org.uk>
Date:   Wed Dec 5 11:48:56 2012 +0000

    arm64: compat for clock_adjtime(2) is miswired
    
    commit 18a80376ddb0bdc466995ff58c844d6fd0a65e61 upstream.
    
    struct timex is different on arm and arm64; adjtimex(2) takes care to
    convert, clock_adjtime(2) doesn't...
    
    Signed-off-by: Al Viro <viro@ZenIV.linux.org.uk>
    Acked-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 97ebe8f55ae99059c0ad3d3be5c0417647f5e3e0
Merge: d07e43d70eef d19766ec5221
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Dec 12 07:49:02 2012 -0800

    Merge tag 'arm64-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/cmarinas/linux-aarch64
    
    Pull ARM64 updates from Catalin Marinas:
    
     - Generic execve, kernel_thread, fork/vfork/clone.
    
     - Preparatory patches for KVM support (initialising EL2 mode for later
       installing KVM support, hypervisor stub).
    
     - Signal handling corner case fix (alternative signal stack set up for
       a SEGV handler, which is raised in response to RLIMIT_STACK being
       reached).
    
     - Sub-nanosecond timer error fix.
    
    * tag 'arm64-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/cmarinas/linux-aarch64: (30 commits)
      arm64: Update the MAINTAINERS entry
      arm64: compat for clock_adjtime(2) is miswired
      arm64: move FP-SIMD save/restore code to a macro
      arm64: hyp: initialize vttbr_el2 to zero
      arm64: add hypervisor stub
      arm64: record boot mode when entering the kernel
      arm64: move vector entry macro to assembler.h
      arm64: add AArch32 execution modes to ptrace.h
      arm64: expand register mapping between AArch32 and AArch64
      arm64: generic timer: use virtual counter instead of physical at EL0
      arm64: vdso: defer shifting of nanosecond component of timespec
      arm64: vdso: rework __do_get_tspec register allocation and return shift
      arm64: vdso: check sequence counter even for coarse realtime operations
      arm64: vdso: fix clocksource mask when extracting bottom 56 bits
      ARM64: Remove incorrect Kconfig symbol HAVE_SPARSE_IRQ
      Documentation: Fixes a word in Documentation/arm64/memory.txt
      arm64: Make !dirty ptes read-only
      arm64: Convert empty flush_cache_{mm,page} functions to static inline
      arm64: signal: let the compiler inline compat_get_sigframe
      arm64: signal: return struct rt_sigframe from get_sigframe
      ...
    
    Conflicts:
            arch/arm64/include/asm/unistd32.h

commit 18a80376ddb0bdc466995ff58c844d6fd0a65e61
Author: Al Viro <viro@ZenIV.linux.org.uk>
Date:   Wed Dec 5 11:48:56 2012 +0000

    arm64: compat for clock_adjtime(2) is miswired
    
    struct timex is different on arm and arm64; adjtimex(2) takes care to
    convert, clock_adjtime(2) doesn't...
    
    Signed-off-by: Al Viro <viro@ZenIV.linux.org.uk>
    Acked-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>
    Cc: <stable@vger.kernel.org>

commit 7d41e49ac2a10a269bb50b4b019d75eed16fd55d
Author: Matt Carlson <mcarlson@broadcom.com>
Date:   Mon Dec 3 19:36:58 2012 +0000

    tg3: PTP - Implement the ptp api and ethtool functions
    
    This patch adds the ptp_caps structure, ptp api implementation,
    reference clock read and register/unregister functions.  All the basic
    clock operations as described in Documentation/ptp/ptp.txt are
    supported.
    
    Frequency adjustment is performed using hardware with a 24 bit
    accumulator and a programmable correction value. On each clk, the
    correction value gets added to the accumulator and when it overflows,
    the time counter is incremented/decremented and the accumulator reset.
    
    So conversion from ppb to correction value is
            ppb * (1 << 24) / 1000000000
    
    [Re-organized to put the ptp_clock_info struct declaration in one patch,
     added ptp_clock_info.name, and added locking to tg3_ptp_adjtime() based
     on input from Richard Cochran.]
    
    Signed-off-by: Nithin Nayak Sujir <nsujir@broadcom.com>
    Signed-off-by: Michael Chan <mchan@broadcom.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 7551ed08b73e53a240c2f1281815bf693b12bd68
Author: Chris Zankel <chris@zankel.net>
Date:   Fri Oct 19 10:46:44 2012 -0700

    xtensa: add missing system calls to the syscall table
    
    commit 7216cabfff5149670445cd65d415ed5db21314b4 upstream.
    
    Add the following system calls to the syscall table:
    
    fallocate
    sendmmsg
    umount2
    syncfs
    epoll_create1
    inotify_init1
    signalfd4
    dup3
    pipe2
    timerfd_create
    timerfd_settime
    timerfd_gettime
    eventfd2
    preadv
    pwritev
    fanotify_init
    fanotify_mark
    process_vm_readv
    process_vm_writev
    name_to_handle_at
    open_by_handle_at
    sync_file_range
    perf_event_open
    rt_tgsigqueueinfo
    clock_adjtime
    prlimit64
    kcmp
    
    Note that we have to use the 'sys_sync_file_range2' version, so that
    the 64-bit arguments are aligned correctly to the argument registers.
    
    Signed-off-by: Chris Zankel <chris@zankel.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 7216cabfff5149670445cd65d415ed5db21314b4
Author: Chris Zankel <chris@zankel.net>
Date:   Fri Oct 19 10:46:44 2012 -0700

    xtensa: add missing system calls to the syscall table
    
    Add the following system calls to the syscall table:
    
    fallocate
    sendmmsg
    umount2
    syncfs
    epoll_create1
    inotify_init1
    signalfd4
    dup3
    pipe2
    timerfd_create
    timerfd_settime
    timerfd_gettime
    eventfd2
    preadv
    pwritev
    fanotify_init
    fanotify_mark
    process_vm_readv
    process_vm_writev
    name_to_handle_at
    open_by_handle_at
    sync_file_range
    perf_event_open
    rt_tgsigqueueinfo
    clock_adjtime
    prlimit64
    kcmp
    
    Note that we have to use the 'sys_sync_file_range2' version, so that
    the 64-bit arguments are aligned correctly to the argument registers.
    
    Signed-off-by: Chris Zankel <chris@zankel.net>

commit c96f4bffe5679af5b9f512f19248cd1d3a62feab
Author: John Stultz <johnstul@us.ibm.com>
Date:   Fri Jul 13 01:21:50 2012 -0400

    ntp: Fix STA_INS/DEL clearing bug
    
    commit 6b1859dba01c7d512b72d77e3fd7da8354235189 upstream.
    
    In commit 6b43ae8a619d17c4935c3320d2ef9e92bdeed05d, I
    introduced a bug that kept the STA_INS or STA_DEL bit
    from being cleared from time_status via adjtimex()
    without forcing STA_PLL first.
    
    Usually once the STA_INS is set, it isn't cleared
    until the leap second is applied, so its unlikely this
    affected anyone. However during testing I noticed it
    took some effort to cancel a leap second once STA_INS
    was set.
    
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Link: http://lkml.kernel.org/r/1342156917-25092-2-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Willy Tarreau <w@1wt.eu>

commit 436b6be6cb5bbffb227b5a414e7a1c03fe941b43
Author: John Stultz <john.stultz@linaro.org>
Date:   Mon Sep 17 22:32:08 2012 -0400

    time: Improve sanity checking of timekeeping inputs
    
    This is a -stable backport of 4e8b14526ca7fb046a81c94002c1c43b6fdf0e9b
    
    Unexpected behavior could occur if the time is set to a value large
    enough to overflow a 64bit ktime_t (which is something larger then the
    year 2262).
    
    Also unexpected behavior could occur if large negative offsets are
    injected via adjtimex.
    
    So this patch improves the sanity check timekeeping inputs by
    improving the timespec_valid() check, and then makes better use of
    timespec_valid() to make sure we don't set the time to an invalid
    negative value or one that overflows ktime_t.
    
    Note: This does not protect from setting the time close to overflowing
    ktime_t and then letting natural accumulation cause the overflow.
    
    Reported-by: CAI Qian <caiqian@redhat.com>
    Reported-by: Sasha Levin <levinsasha928@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Zhouping Liu <zliu@redhat.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: stable@vger.kernel.org
    Link: http://lkml.kernel.org/r/1344454580-17031-1-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Linux Kernel <linux-kernel@vger.kernel.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Willy Tarreau <w@1wt.eu>

commit 6a29b109b9fb4c76bf55851223ae59e3322d9616
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Jul 17 18:05:25 2012 -0400

    ntp: Fix leap-second hrtimer livelock
    
    This is a backport of 6b43ae8a619d17c4935c3320d2ef9e92bdeed05d
    
    This should have been backported when it was commited, but I
    mistook the problem as requiring the ntp_lock changes
    that landed in 3.4 in order for it to occur.
    
    Unfortunately the same issue can happen (with only one cpu)
    as follows:
    do_adjtimex()
     write_seqlock_irq(&xtime_lock);
      process_adjtimex_modes()
       process_adj_status()
        ntp_start_leap_timer()
         hrtimer_start()
          hrtimer_reprogram()
           tick_program_event()
            clockevents_program_event()
             ktime_get()
              seq = req_seqbegin(xtime_lock); [DEADLOCK]
    
    This deadlock will no always occur, as it requires the
    leap_timer to force a hrtimer_reprogram which only happens
    if its set and there's no sooner timer to expire.
    
    NOTE: This patch, being faithful to the original commit,
    introduces a bug (we don't update wall_to_monotonic),
    which will be resovled by backporting a following fix.
    
    Original commit message below:
    
    Since commit 7dffa3c673fbcf835cd7be80bb4aec8ad3f51168 the ntp
    subsystem has used an hrtimer for triggering the leapsecond
    adjustment. However, this can cause a potential livelock.
    
    Thomas diagnosed this as the following pattern:
    CPU 0                                                    CPU 1
    do_adjtimex()
      spin_lock_irq(&ntp_lock);
        process_adjtimex_modes();                            timer_interrupt()
          process_adj_status();                                do_timer()
            ntp_start_leap_timer();                             write_lock(&xtime_lock);
              hrtimer_start();                                  update_wall_time();
                 hrtimer_reprogram();                            ntp_tick_length()
                   tick_program_event()                            spin_lock(&ntp_lock);
                     clockevents_program_event()
                       ktime_get()
                         seq = req_seqbegin(xtime_lock);
    
    This patch tries to avoid the problem by reverting back to not using
    an hrtimer to inject leapseconds, and instead we handle the leapsecond
    processing in the second_overflow() function.
    
    The downside to this change is that on systems that support highres
    timers, the leap second processing will occur on a HZ tick boundary,
    (ie: ~1-10ms, depending on HZ)  after the leap second instead of
    possibly sooner (~34us in my tests w/ x86_64 lapic).
    
    This patch applies on top of tip/timers/core.
    
    CC: Sasha Levin <levinsasha928@gmail.com>
    CC: Thomas Gleixner <tglx@linutronix.de>
    Reported-by: Sasha Levin <levinsasha928@gmail.com>
    Diagnoised-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Sasha Levin <levinsasha928@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Linux Kernel <linux-kernel@vger.kernel.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Willy Tarreau <w@1wt.eu>

commit 7df3d033efb005c6018512933078566cd6f49463
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Sep 11 14:56:19 2012 -0400

    time: Improve sanity checking of timekeeping inputs
    
    commit 4e8b14526ca7fb046a81c94002c1c43b6fdf0e9b upstream.
    
    Unexpected behavior could occur if the time is set to a value large
    enough to overflow a 64bit ktime_t (which is something larger then the
    year 2262).
    
    Also unexpected behavior could occur if large negative offsets are
    injected via adjtimex.
    
    So this patch improves the sanity check timekeeping inputs by
    improving the timespec_valid() check, and then makes better use of
    timespec_valid() to make sure we don't set the time to an invalid
    negative value or one that overflows ktime_t.
    
    Note: This does not protect from setting the time close to overflowing
    ktime_t and then letting natural accumulation cause the overflow.
    
    Reported-by: CAI Qian <caiqian@redhat.com>
    Reported-by: Sasha Levin <levinsasha928@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Zhouping Liu <zliu@redhat.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Link: http://lkml.kernel.org/r/1344454580-17031-1-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 8e878154f5658ba93cf9bb2b491a930ec195de3d
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Sep 11 15:04:17 2012 -0400

    time: Improve sanity checking of timekeeping inputs
    
    commit 4e8b14526ca7fb046a81c94002c1c43b6fdf0e9b upstream.
    
    Unexpected behavior could occur if the time is set to a value large
    enough to overflow a 64bit ktime_t (which is something larger then the
    year 2262).
    
    Also unexpected behavior could occur if large negative offsets are
    injected via adjtimex.
    
    So this patch improves the sanity check timekeeping inputs by
    improving the timespec_valid() check, and then makes better use of
    timespec_valid() to make sure we don't set the time to an invalid
    negative value or one that overflows ktime_t.
    
    Note: This does not protect from setting the time close to overflowing
    ktime_t and then letting natural accumulation cause the overflow.
    
    Reported-by: CAI Qian <caiqian@redhat.com>
    Reported-by: Sasha Levin <levinsasha928@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Zhouping Liu <zliu@redhat.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Link: http://lkml.kernel.org/r/1344454580-17031-1-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 44fa9a0111168832510f8add6d589e73eac6793d
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Sep 11 20:49:51 2012 -0400

    time: Improve sanity checking of timekeeping inputs
    
    commit 4e8b14526ca7fb046a81c94002c1c43b6fdf0e9b upstream
    
    Unexpected behavior could occur if the time is set to a value large
    enough to overflow a 64bit ktime_t (which is something larger then the
    year 2262).
    
    Also unexpected behavior could occur if large negative offsets are
    injected via adjtimex.
    
    So this patch improves the sanity check timekeeping inputs by
    improving the timespec_valid() check, and then makes better use of
    timespec_valid() to make sure we don't set the time to an invalid
    negative value or one that overflows ktime_t.
    
    Note: This does not protect from setting the time close to overflowing
    ktime_t and then letting natural accumulation cause the overflow.
    
    Reported-by: CAI Qian <caiqian@redhat.com>
    Reported-by: Sasha Levin <levinsasha928@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Zhouping Liu <zliu@redhat.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Link: http://lkml.kernel.org/r/1344454580-17031-1-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 39a8cbd9ca051fb164db70315e7972de5c153c33
Author: Richard Cochran <richardcochran@gmail.com>
Date:   Sat Sep 22 07:02:01 2012 +0000

    ptp: remember the adjusted frequency
    
    This patch adds a field to the representation of a PTP hardware clock in
    order to remember the frequency adjustment value dialed by the user.
    
    Adding this field will let us answer queries in the manner of adjtimex
    in a follow on patch.
    
    Signed-off-by: Richard Cochran <richardcochran@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 8dd006cdafa7c955f6f4c66d25564d90aa29af1d
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Aug 8 15:36:20 2012 -0400

    time: Improve sanity checking of timekeeping inputs
    
    This is a -stable backport of 4e8b14526ca7fb046a81c94002c1c43b6fdf0e9b
    
    Unexpected behavior could occur if the time is set to a value large
    enough to overflow a 64bit ktime_t (which is something larger then the
    year 2262).
    
    Also unexpected behavior could occur if large negative offsets are
    injected via adjtimex.
    
    So this patch improves the sanity check timekeeping inputs by
    improving the timespec_valid() check, and then makes better use of
    timespec_valid() to make sure we don't set the time to an invalid
    negative value or one that overflows ktime_t.
    
    Note: This does not protect from setting the time close to overflowing
    ktime_t and then letting natural accumulation cause the overflow.
    
    Reported-by: CAI Qian <caiqian@redhat.com>
    Reported-by: Sasha Levin <levinsasha928@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Zhouping Liu <zliu@redhat.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Link: http://lkml.kernel.org/r/1344454580-17031-1-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Linux Kernel <linux-kernel@vger.kernel.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit d9ccaf3143473c6dd11b10d49e524eaa39fabcec
Author: John Stultz <johnstul@us.ibm.com>
Date:   Fri Jul 13 01:21:50 2012 -0400

    ntp: Fix STA_INS/DEL clearing bug
    
    commit 6b1859dba01c7d512b72d77e3fd7da8354235189 upstream.
    
    In commit 6b43ae8a619d17c4935c3320d2ef9e92bdeed05d, I
    introduced a bug that kept the STA_INS or STA_DEL bit
    from being cleared from time_status via adjtimex()
    without forcing STA_PLL first.
    
    Usually once the STA_INS is set, it isn't cleared
    until the leap second is applied, so its unlikely this
    affected anyone. However during testing I noticed it
    took some effort to cancel a leap second once STA_INS
    was set.
    
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Link: http://lkml.kernel.org/r/1342156917-25092-2-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 838955464ce6579492c1b863264ad6cfe79a9a14
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Jul 17 17:49:21 2012 -0400

    ntp: Fix leap-second hrtimer livelock
    
    commit 6b43ae8a619d17c4935c3320d2ef9e92bdeed05d upstream.
    
    This should have been backported when it was commited, but I
    mistook the problem as requiring the ntp_lock changes
    that landed in 3.4 in order for it to occur.
    
    Unfortunately the same issue can happen (with only one cpu)
    as follows:
    do_adjtimex()
     write_seqlock_irq(&xtime_lock);
      process_adjtimex_modes()
       process_adj_status()
        ntp_start_leap_timer()
         hrtimer_start()
          hrtimer_reprogram()
           tick_program_event()
            clockevents_program_event()
             ktime_get()
              seq = req_seqbegin(xtime_lock); [DEADLOCK]
    
    This deadlock will no always occur, as it requires the
    leap_timer to force a hrtimer_reprogram which only happens
    if its set and there's no sooner timer to expire.
    
    NOTE: This patch, being faithful to the original commit,
    introduces a bug (we don't update wall_to_monotonic),
    which will be resovled by backporting a following fix.
    
    Original commit message below:
    
    Since commit 7dffa3c673fbcf835cd7be80bb4aec8ad3f51168 the ntp
    subsystem has used an hrtimer for triggering the leapsecond
    adjustment. However, this can cause a potential livelock.
    
    Thomas diagnosed this as the following pattern:
    CPU 0                                                    CPU 1
    do_adjtimex()
      spin_lock_irq(&ntp_lock);
        process_adjtimex_modes();                            timer_interrupt()
          process_adj_status();                                do_timer()
            ntp_start_leap_timer();                             write_lock(&xtime_lock);
              hrtimer_start();                                  update_wall_time();
                 hrtimer_reprogram();                            ntp_tick_length()
                   tick_program_event()                            spin_lock(&ntp_lock);
                     clockevents_program_event()
                       ktime_get()
                         seq = req_seqbegin(xtime_lock);
    
    This patch tries to avoid the problem by reverting back to not using
    an hrtimer to inject leapseconds, and instead we handle the leapsecond
    processing in the second_overflow() function.
    
    The downside to this change is that on systems that support highres
    timers, the leap second processing will occur on a HZ tick boundary,
    (ie: ~1-10ms, depending on HZ)  after the leap second instead of
    possibly sooner (~34us in my tests w/ x86_64 lapic).
    
    This patch applies on top of tip/timers/core.
    
    CC: Sasha Levin <levinsasha928@gmail.com>
    CC: Thomas Gleixner <tglx@linutronix.de>
    Reported-by: Sasha Levin <levinsasha928@gmail.com>
    Diagnoised-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Sasha Levin <levinsasha928@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Linux Kernel <linux-kernel@vger.kernel.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

commit 4e8b14526ca7fb046a81c94002c1c43b6fdf0e9b
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Aug 8 15:36:20 2012 -0400

    time: Improve sanity checking of timekeeping inputs
    
    Unexpected behavior could occur if the time is set to a value large
    enough to overflow a 64bit ktime_t (which is something larger then the
    year 2262).
    
    Also unexpected behavior could occur if large negative offsets are
    injected via adjtimex.
    
    So this patch improves the sanity check timekeeping inputs by
    improving the timespec_valid() check, and then makes better use of
    timespec_valid() to make sure we don't set the time to an invalid
    negative value or one that overflows ktime_t.
    
    Note: This does not protect from setting the time close to overflowing
    ktime_t and then letting natural accumulation cause the overflow.
    
    Reported-by: CAI Qian <caiqian@redhat.com>
    Reported-by: Sasha Levin <levinsasha928@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Zhouping Liu <zliu@redhat.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: stable@vger.kernel.org
    Link: http://lkml.kernel.org/r/1344454580-17031-1-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit dccecc646f06f06db8c32fc6615fee847852cec6
Author: John Stultz <johnstul@us.ibm.com>
Date:   Fri Jul 13 01:21:50 2012 -0400

    ntp: Fix STA_INS/DEL clearing bug
    
    commit 6b1859dba01c7d512b72d77e3fd7da8354235189 upstream.
    
    In commit 6b43ae8a619d17c4935c3320d2ef9e92bdeed05d, I
    introduced a bug that kept the STA_INS or STA_DEL bit
    from being cleared from time_status via adjtimex()
    without forcing STA_PLL first.
    
    Usually once the STA_INS is set, it isn't cleared
    until the leap second is applied, so its unlikely this
    affected anyone. However during testing I noticed it
    took some effort to cancel a leap second once STA_INS
    was set.
    
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Link: http://lkml.kernel.org/r/1342156917-25092-2-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit fd25080998d00a94a87bf7fc9f843291db7250a6
Author: John Stultz <johnstul@us.ibm.com>
Date:   Fri Jul 13 01:21:50 2012 -0400

    ntp: Fix STA_INS/DEL clearing bug
    
    commit 6b1859dba01c7d512b72d77e3fd7da8354235189 upstream.
    
    In commit 6b43ae8a619d17c4935c3320d2ef9e92bdeed05d, I
    introduced a bug that kept the STA_INS or STA_DEL bit
    from being cleared from time_status via adjtimex()
    without forcing STA_PLL first.
    
    Usually once the STA_INS is set, it isn't cleared
    until the leap second is applied, so its unlikely this
    affected anyone. However during testing I noticed it
    took some effort to cancel a leap second once STA_INS
    was set.
    
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Link: http://lkml.kernel.org/r/1342156917-25092-2-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit a57ccabee60519dd90051266c00d038055b93878
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Jul 17 03:05:14 2012 -0400

    ntp: Fix leap-second hrtimer livelock
    
    This is a backport of 6b43ae8a619d17c4935c3320d2ef9e92bdeed05d
    
    This should have been backported when it was commited, but I
    mistook the problem as requiring the ntp_lock changes
    that landed in 3.4 in order for it to occur.
    
    Unfortunately the same issue can happen (with only one cpu)
    as follows:
    do_adjtimex()
     write_seqlock_irq(&xtime_lock);
      process_adjtimex_modes()
       process_adj_status()
        ntp_start_leap_timer()
         hrtimer_start()
          hrtimer_reprogram()
           tick_program_event()
            clockevents_program_event()
             ktime_get()
              seq = req_seqbegin(xtime_lock); [DEADLOCK]
    
    This deadlock will no always occur, as it requires the
    leap_timer to force a hrtimer_reprogram which only happens
    if its set and there's no sooner timer to expire.
    
    NOTE: This patch, being faithful to the original commit,
    introduces a bug (we don't update wall_to_monotonic),
    which will be resovled by backporting a following fix.
    
    Original commit message below:
    
    Since commit 7dffa3c673fbcf835cd7be80bb4aec8ad3f51168 the ntp
    subsystem has used an hrtimer for triggering the leapsecond
    adjustment. However, this can cause a potential livelock.
    
    Thomas diagnosed this as the following pattern:
    CPU 0                                                    CPU 1
    do_adjtimex()
      spin_lock_irq(&ntp_lock);
        process_adjtimex_modes();                            timer_interrupt()
          process_adj_status();                                do_timer()
            ntp_start_leap_timer();                             write_lock(&xtime_lock);
              hrtimer_start();                                  update_wall_time();
                 hrtimer_reprogram();                            ntp_tick_length()
                   tick_program_event()                            spin_lock(&ntp_lock);
                     clockevents_program_event()
                       ktime_get()
                         seq = req_seqbegin(xtime_lock);
    
    This patch tries to avoid the problem by reverting back to not using
    an hrtimer to inject leapseconds, and instead we handle the leapsecond
    processing in the second_overflow() function.
    
    The downside to this change is that on systems that support highres
    timers, the leap second processing will occur on a HZ tick boundary,
    (ie: ~1-10ms, depending on HZ)  after the leap second instead of
    possibly sooner (~34us in my tests w/ x86_64 lapic).
    
    This patch applies on top of tip/timers/core.
    
    CC: Sasha Levin <levinsasha928@gmail.com>
    CC: Thomas Gleixner <tglx@linutronix.de>
    Reported-by: Sasha Levin <levinsasha928@gmail.com>
    Diagnoised-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Sasha Levin <levinsasha928@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Linux Kernel <linux-kernel@vger.kernel.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit 9c24771f844b6f0708a72cd116953e0a128e5d2a
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Jul 17 13:33:48 2012 -0400

    ntp: Fix leap-second hrtimer livelock
    
    This is a backport of 6b43ae8a619d17c4935c3320d2ef9e92bdeed05d
    
    This should have been backported when it was commited, but I
    mistook the problem as requiring the ntp_lock changes
    that landed in 3.4 in order for it to occur.
    
    Unfortunately the same issue can happen (with only one cpu)
    as follows:
    do_adjtimex()
     write_seqlock_irq(&xtime_lock);
      process_adjtimex_modes()
       process_adj_status()
        ntp_start_leap_timer()
         hrtimer_start()
          hrtimer_reprogram()
           tick_program_event()
            clockevents_program_event()
             ktime_get()
              seq = req_seqbegin(xtime_lock); [DEADLOCK]
    
    This deadlock will no always occur, as it requires the
    leap_timer to force a hrtimer_reprogram which only happens
    if its set and there's no sooner timer to expire.
    
    NOTE: This patch, being faithful to the original commit,
    introduces a bug (we don't update wall_to_monotonic),
    which will be resovled by backporting a following fix.
    
    Original commit message below:
    
    Since commit 7dffa3c673fbcf835cd7be80bb4aec8ad3f51168 the ntp
    subsystem has used an hrtimer for triggering the leapsecond
    adjustment. However, this can cause a potential livelock.
    
    Thomas diagnosed this as the following pattern:
    CPU 0                                                    CPU 1
    do_adjtimex()
      spin_lock_irq(&ntp_lock);
        process_adjtimex_modes();                            timer_interrupt()
          process_adj_status();                                do_timer()
            ntp_start_leap_timer();                             write_lock(&xtime_lock);
              hrtimer_start();                                  update_wall_time();
                 hrtimer_reprogram();                            ntp_tick_length()
                   tick_program_event()                            spin_lock(&ntp_lock);
                     clockevents_program_event()
                       ktime_get()
                         seq = req_seqbegin(xtime_lock);
    
    This patch tries to avoid the problem by reverting back to not using
    an hrtimer to inject leapseconds, and instead we handle the leapsecond
    processing in the second_overflow() function.
    
    The downside to this change is that on systems that support highres
    timers, the leap second processing will occur on a HZ tick boundary,
    (ie: ~1-10ms, depending on HZ)  after the leap second instead of
    possibly sooner (~34us in my tests w/ x86_64 lapic).
    
    This patch applies on top of tip/timers/core.
    
    CC: Sasha Levin <levinsasha928@gmail.com>
    CC: Thomas Gleixner <tglx@linutronix.de>
    Reported-by: Sasha Levin <levinsasha928@gmail.com>
    Diagnoised-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Sasha Levin <levinsasha928@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 6b1859dba01c7d512b72d77e3fd7da8354235189
Author: John Stultz <johnstul@us.ibm.com>
Date:   Fri Jul 13 01:21:50 2012 -0400

    ntp: Fix STA_INS/DEL clearing bug
    
    In commit 6b43ae8a619d17c4935c3320d2ef9e92bdeed05d, I
    introduced a bug that kept the STA_INS or STA_DEL bit
    from being cleared from time_status via adjtimex()
    without forcing STA_PLL first.
    
    Usually once the STA_INS is set, it isn't cleared
    until the leap second is applied, so its unlikely this
    affected anyone. However during testing I noticed it
    took some effort to cancel a leap second once STA_INS
    was set.
    
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    CC: stable@vger.kernel.org # 3.4
    Link: http://lkml.kernel.org/r/1342156917-25092-2-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 6b43ae8a619d17c4935c3320d2ef9e92bdeed05d
Author: John Stultz <john.stultz@linaro.org>
Date:   Thu Mar 15 13:04:03 2012 -0700

    ntp: Fix leap-second hrtimer livelock
    
    Since commit 7dffa3c673fbcf835cd7be80bb4aec8ad3f51168 the ntp
    subsystem has used an hrtimer for triggering the leapsecond
    adjustment. However, this can cause a potential livelock.
    
    Thomas diagnosed this as the following pattern:
    CPU 0                                                    CPU 1
    do_adjtimex()
      spin_lock_irq(&ntp_lock);
        process_adjtimex_modes();                            timer_interrupt()
          process_adj_status();                                do_timer()
            ntp_start_leap_timer();                             write_lock(&xtime_lock);
              hrtimer_start();                                  update_wall_time();
                 hrtimer_reprogram();                            ntp_tick_length()
                   tick_program_event()                            spin_lock(&ntp_lock);
                     clockevents_program_event()
                       ktime_get()
                         seq = req_seqbegin(xtime_lock);
    
    This patch tries to avoid the problem by reverting back to not using
    an hrtimer to inject leapseconds, and instead we handle the leapsecond
    processing in the second_overflow() function.
    
    The downside to this change is that on systems that support highres
    timers, the leap second processing will occur on a HZ tick boundary,
    (ie: ~1-10ms, depending on HZ)  after the leap second instead of
    possibly sooner (~34us in my tests w/ x86_64 lapic).
    
    This patch applies on top of tip/timers/core.
    
    CC: Sasha Levin <levinsasha928@gmail.com>
    CC: Thomas Gleixner <tglx@linutronix.de>
    Reported-by: Sasha Levin <levinsasha928@gmail.com>
    Diagnoised-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Sasha Levin <levinsasha928@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

commit baa950b85e4a7e6965da1cf618801735584ad65e
Author: James Bottomley <James.Bottomley@HansenPartnership.com>
Date:   Fri Apr 15 08:55:45 2011 -0700

    wire up clock_adjtime syscall
    
    commit c3f957a22eca106bd28136943305b390b4337ebf upstream.
    
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 8fd886735c5309c3805b33047ae4b6868cc0d534
Author: James Bottomley <James.Bottomley@HansenPartnership.com>
Date:   Fri Apr 15 08:55:45 2011 -0700

    wire up clock_adjtime syscall
    
    commit c3f957a22eca106bd28136943305b390b4337ebf upstream.
    
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 17238005f377888b9d4583835205c77e3d781bb8
Merge: 34ea646c9f8c 7fe2ac6882f7
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun May 22 12:38:40 2011 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jejb/parisc-2.6
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jejb/parisc-2.6:
      [PARISC] wire up syncfs syscall
      [PARISC] wire up the fhandle syscalls
      [PARISC] wire up clock_adjtime syscall
      [PARISC] wire up fanotify syscalls
      [PARISC] prevent speculative re-read on cache flush
      [PARISC] only make executable areas executable
      [PARISC] fix pacache .size with new binutils

commit 90b57f35164aa715dcc7d939a88780a23231f84e
Author: Michael Cree <mcree@orcon.net.nz>
Date:   Wed May 4 08:14:50 2011 +0000

    alpha: Wire up syscalls new to 2.6.39
    
    Wire up the syscalls:
       name_to_handle_at
       open_by_handle_at
       clock_adjtime
       syncfs
    and adjust some whitespace in the neighbourhood to align commments.
    
    Signed-off-by: Michael Cree <mcree@orcon.net.nz>
    Signed-off-by: Matt Turner <mattst88@gmail.com>

commit c3f957a22eca106bd28136943305b390b4337ebf
Author: James Bottomley <James.Bottomley@HansenPartnership.com>
Date:   Fri Apr 15 08:55:45 2011 -0700

    [PARISC] wire up clock_adjtime syscall
    
    Cc: stable@kernel.org
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

commit 0d58a2824d777923b2438107053c6e073c9c5ec1
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Fri Apr 15 13:26:40 2011 +0100

    ARM: Add new syscalls
    
    Add syscalls for name_to_handle_at, open_by_handle_at, clock_adjtime
    and syncfs.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

commit 60d48c1e67dc8de0676453de18adba1768fb6fab
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Tue Apr 12 22:24:45 2011 +0200

    m68k,m68knommu: Wire up name_to_handle_at, open_by_handle_at, clock_adjtime, syncfs
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Acked-by: Greg Ungerer <gerg@uclinux.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit 4352d9d44b935e4d000be6ec89ddb55c2bf35f24
Author: Richard Cochran <richardcochran@gmail.com>
Date:   Mon Apr 4 08:31:23 2011 -0700

    ntp: fix non privileged system time shifting
    
    The ADJ_SETOFFSET bit added in commit 094aa188 ("ntp: Add ADJ_SETOFFSET
    mode bit") also introduced a way for any user to change the system time.
    Sneaky or buggy calls to adjtimex() could set
    
        ADJ_OFFSET_SS_READ | ADJ_SETOFFSET
    
    which would result in a successful call to timekeeping_inject_offset().
    This patch fixes the issue by adding the capability check.
    
    Signed-off-by: Richard Cochran <richard.cochran@omicron.at>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit 57bd35d414c453fea2b08e9dad6067ee7e6c188a
Author: Michal Simek <monstr@monstr.eu>
Date:   Thu Mar 31 08:11:47 2011 +0200

    microblaze: Wire up new syscalls
    
    Hook up name_to_handle_at, open_by_handle_at, clock_adjtime, syncfs
    
    Signed-off-by: Michal Simek <monstr@monstr.eu>

commit 834796a8493809ae6667b65c4c044066f41d32c7
Author: Stephen Rothwell <sfr@canb.auug.org.au>
Date:   Wed Mar 23 18:40:47 2011 +0000

    powerpc: Wire up new syscalls
    
    These syscalls have been added recently:
            name_to_handle_at
            open_by_handle_at
            clock_adjtime
            syncfs
    
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

commit 7c8d891c2c7714965db1685289787b0c526f9c42
Merge: 62d00867514a 54eaae3028e6
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Mar 25 17:47:04 2011 -0700

    Merge branch 'for-linus' of git://git390.marist.edu/pub/scm/linux-2.6
    
    * 'for-linus' of git://git390.marist.edu/pub/scm/linux-2.6:
      [S390] cmpxchg: implement cmpxchg64()
      [S390] xchg/cmpxchg: move to own header file
      [S390] ccwgroup_driver: remove duplicate members
      [S390] ccw_bus_type: make it static
      [S390] ccw_driver: remove duplicate members
      [S390] qdio: prevent handling of buffers if count is zero
      [S390] setup: register bss section as resource
      [S390] setup: simplify setup_resources()
      [S390] wire up sys_syncfs
      [S390] wire up sys_clock_adjtime
      [S390] wire up sys_open_by_handle_at
      [S390] wire up sys_name_to_handle_at
      [S390] oprofile: disable hw sampling for CONFIG_32BIT
      [S390] early: limit savesys cmd string handling
      [S390] early: Fix possible overlapping data buffer

commit 62d00867514ae1c81ab5e809e189ca159536daee
Merge: be4d250ab41e c8fb4022cf61
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Mar 25 17:46:34 2011 -0700

    Merge branch 'upstream' of git://git.linux-mips.org/pub/scm/upstream-linus
    
    * 'upstream' of git://git.linux-mips.org/pub/scm/upstream-linus: (49 commits)
      MIPS: JZ4740: Set nand ecc offsets for the qi_lb60 board
      MIPS: JZ4740: qi_lb60: Add gpio-charger device
      MIPS: Wire up syncfs(2).
      MIPS: Hook up name_to_handle_at, open_by_handle_at and clock_adjtime syscalls.
      MIPS: VR41xx: Convert to new irq_chip functions
      MIPS: TXx9: Convert to new irq_chip functions
      MIPS: SNI: Convert to new irq_chip functions
      MIPS: Sibyte: Convert to new irq_chip functions
      MIPS: IP32: Convert to new irq_chip functions
      MIPS: IP27: Convert to new irq_chip functions
      MIPS: IP22/IP28: Convert to new irq_chip functions
      MIPS: RB532: Convert to new irq_chip functions
      MIPS: PowerTV: Convert to new irq_chip functions
      MIPS: PNX8550: Convert to new irq_chip functions
      MIPS: PNX83xx: Convert to new irq_chip functions
      MIPS: msp71xx: Convert to new irq_chip functions
      MIPS: Loongson: Convert to new irq_chip functions
      MIPS: Use generic show_interrupts()
      MIPS: SMTC: Cleanup the hook mess and use irq_data
      MIPS: SMTC: Use irq_data in smtc_forward_irq()
      ...

commit 84ed94323e67c9f99606fb24e8c746a0d62ab95a
Author: David Daney <ddaney@caviumnetworks.com>
Date:   Fri Mar 18 10:37:23 2011 -0700

    MIPS: Hook up name_to_handle_at, open_by_handle_at and clock_adjtime syscalls.
    
    These system calls we recently added.
    
    32-bit ABIs need compat handling for sys_clock_adjtime().
    
    o32 also needs compat handling for sys_open_by_handle_at();
    
    Signed-off-by: David Daney <ddaney@caviumnetworks.com>
    To: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/2165/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

commit 26e8a33989183e81d6692aec1a77dffa266b91a2
Author: Heiko Carstens <hca@linux.ibm.com>
Date:   Wed Mar 23 10:15:57 2011 +0100

    [S390] wire up sys_clock_adjtime
    
    Signed-off-by: Heiko Carstens <heiko.carstens@de.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

commit 9298168d16faf939141cddc836b6b9b1ef2a8aac
Author: Tony Luck <tony.luck@intel.com>
Date:   Tue Mar 22 10:54:24 2011 -0700

    [IA64] New syscalls for 2.6.39
    
    Four new syscalls:
            sys_name_to_handle_at
            sys_open_by_handle_at
            sys_clock_adjtime
            sys_syncfs
    
    Signed-off-by: Tony Luck <tony.luck@intel.com>

commit f19ade4dfbfefbb44b412fc33a2db26eafd63f0e
Merge: 111f4268bd69 b3f80f6d2b08
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Mar 21 09:53:04 2011 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/sparc-2.6
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/davem/sparc-2.6:
      sparc: Add {open_by,name_to}_handle_at and clock_adjtime syscalls.
      sparc: Implement of_iomap().
      sparc: Implement of_address_to_resource().
      sparc: Provide NO_IRQ definition.

commit 6113f39dd15e4beb5ce66a8e0d9062477c5e81e3
Merge: db552b333176 339dc50e59f4
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Mar 20 17:53:50 2011 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/cmetcalf/linux-tile
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/cmetcalf/linux-tile:
      asm-generic: support clock_adjtime() in <asm-generic/unistd.h>
      arch/tile: fix futex sanitization definition/prototype mismatch

commit 339dc50e59f4ea697e2b8cd6296328a8015a6c21
Author: Chris Metcalf <cmetcalf@tilera.com>
Date:   Sat Mar 19 11:47:53 2011 -0400

    asm-generic: support clock_adjtime() in <asm-generic/unistd.h>
    
    A syscall was added without being added to asm-generic, which
    makes tile (and presumably score and unicore32) break.
    
    Signed-off-by: Chris Metcalf <cmetcalf@tilera.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Cc: Guan Xuetao <gxt@mprc.pku.edu.cn>
    Cc: Chen Liqin <liqin.chen@sunplusct.com>
    Cc: Lennox Wu <lennox.wu@gmail.com>

commit b3f80f6d2b08772d7d00f34a062ff73c95f7c45c
Author: David S. Miller <davem@davemloft.net>
Date:   Fri Mar 18 21:50:29 2011 -0700

    sparc: Add {open_by,name_to}_handle_at and clock_adjtime syscalls.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit a8d0142fb7e31a11919ef2d45d6f43e0f225f568
Author: Mike Frysinger <vapier@gentoo.org>
Date:   Fri Mar 18 04:05:23 2011 -0400

    Blackfin: wire up new syscalls
    
    Hook up name_to_handle_at, open_by_handle_at, and clock_adjtime.
    
    Signed-off-by: Mike Frysinger <vapier@gentoo.org>

commit 241eb95600be194f6b59b85c0bf41194694ebdf1
Merge: fd34b0dee4d2 3d44ae402a4e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Mar 17 09:57:10 2011 -0700

    Merge branch 'sh-latest' of git://git.kernel.org/pub/scm/linux/kernel/git/lethal/sh-2.6
    
    * 'sh-latest' of git://git.kernel.org/pub/scm/linux/kernel/git/lethal/sh-2.6: (34 commits)
      sh: Convert to generic show_interrupts.
      sh: Wire up new fhandle and clock_adjtime syscalls.
      sh: modify platform_device for sh_eth driver
      sh: add GETHER's platform_device in board-sh7757lcr
      sh: update sh7757lcr_defconfig
      sh: add platform_device of tmio_mmc and sh_mmcif to sh7757lcr
      sh: dmaengine support for SH7757
      sh: add mmc clock in clock-sh7757
      sh: add spi_board_info in sh7757lcr
      sh: add platform_device for SPI
      sh: add USB_ARCH_HAS_EHCI and OHCI for SH7757
      sh: Rename cpuidle states to fit general conventions
      serial: sh-sci: fix deadlock when resuming from S3 sleep
      sh: Enable CONFIG_GCOV_PROFILE_ALL for sh
      sh: Fix up async PCIe probing on SMP.
      serial: sh-sci: Kill off the special earlyprintk device.
      serial: sh-sci: Use dev_name() for region reservations.
      serial: sh-sci: Fix up earlyprintk port mapping.
      serial: sh-sci: Limit early console to one device.
      serial: sh-sci: Fix up break timer scheduling race.
      ...

commit a88403335a9ffc66a0a1b46b6d303512eddde846
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Thu Mar 17 17:01:24 2011 +0900

    sh: Wire up new fhandle and clock_adjtime syscalls.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

commit 420c1c572d4ceaa2f37b6311b7017ac6cf049fe2
Merge: 9620639b7ea3 6e6823d17b15
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Mar 15 18:53:35 2011 -0700

    Merge branch 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip: (62 commits)
      posix-clocks: Check write permissions in posix syscalls
      hrtimer: Remove empty hrtimer_init_hres_timer()
      hrtimer: Update hrtimer->state documentation
      hrtimer: Update base[CLOCK_BOOTTIME].offset correctly
      timers: Export CLOCK_BOOTTIME via the posix timers interface
      timers: Add CLOCK_BOOTTIME hrtimer base
      time: Extend get_xtime_and_monotonic_offset() to also return sleep
      time: Introduce get_monotonic_boottime and ktime_get_boottime
      hrtimers: extend hrtimer base code to handle more then 2 clockids
      ntp: Remove redundant and incorrect parameter check
      mn10300: Switch do_timer() to xtimer_update()
      posix clocks: Introduce dynamic clocks
      posix-timers: Cleanup namespace
      posix-timers: Add support for fd based clocks
      x86: Add clock_adjtime for x86
      posix-timers: Introduce a syscall for clock tuning.
      time: Splitout compat timex accessors
      ntp: Add ADJ_SETOFFSET mode bit
      time: Introduce timekeeping_inject_offset
      posix-timer: Update comment
      ...
    
    Fix up new system-call-related conflicts in
            arch/x86/ia32/ia32entry.S
            arch/x86/include/asm/unistd_32.h
            arch/x86/include/asm/unistd_64.h
            arch/x86/kernel/syscall_table_32.S
    (name_to_handle_at()/open_by_handle_at() vs clock_adjtime()), and some
    due to movement of get_jiffies_64() in:
            kernel/time.c

commit 6e6823d17b157f185be09f4c70181299f9273f0b
Author: Torben Hohn <torbenh@gmx.de>
Date:   Thu Mar 3 18:26:14 2011 +0100

    posix-clocks: Check write permissions in posix syscalls
    
    pc_clock_settime() and pc_clock_adjtime() do not check whether the fd
    was opened in write mode, so a clock can be set with a read only fd.
    
    [ tglx: We deliberately do not return -EPERM as we want this to be
            distingushable from the capability based permission check ]
    
    Signed-off-by: Torben Hohn <torbenh@gmx.de>
    LKML-Reference: <1299173174-348-4-git-send-email-torbenh@gmx.de>
    Cc: Richard Cochran <richard.cochran@omicron.at>
    Cc: John Stultz <johnstul@us.ibm.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>

commit 0606f422b453f76c31ab2b1bd52943ff06a2dcf2
Author: Richard Cochran <richardcochran@gmail.com>
Date:   Tue Feb 1 13:52:35 2011 +0000

    posix clocks: Introduce dynamic clocks
    
    This patch adds support for adding and removing posix clocks. The
    clock lifetime cycle is patterned after usb devices. Each clock is
    represented by a standard character device. In addition, the driver
    may optionally implement custom character device operations.
    
    The posix clock and timer system calls listed below now work with
    dynamic posix clocks, as well as the traditional static clocks.
    The following system calls are affected:
    
       - clock_adjtime (brand new syscall)
       - clock_gettime
       - clock_getres
       - clock_settime
       - timer_create
       - timer_delete
       - timer_gettime
       - timer_settime
    
    [ tglx: Adapted to the posix-timer cleanup. Moved clock_posix_dynamic
            to posix-clock.c and made all referenced functions static ]
    
    Signed-off-by: Richard Cochran <richard.cochran@omicron.at>
    Acked-by: John Stultz <johnstul@us.ibm.com>
    LKML-Reference: <20110201134420.164172635@linutronix.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit ce26efdefa5e8f22d933df72d7f7482725091d6d
Author: Richard Cochran <richard.cochran@omicron.at>
Date:   Tue Feb 1 13:52:30 2011 +0000

    x86: Add clock_adjtime for x86
    
    This patch adds the clock_adjtime system call to the x86 architecture.
    
    Signed-off-by: Richard Cochran <richard.cochran@omicron.at>
    Acked-by: John Stultz <johnstul@us.ibm.com>
    LKML-Reference: <20110201134419.968905083@linutronix.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit f1f1d5ebd10ffa4242bce7a90a56a222d6b7bc77
Author: Richard Cochran <richardcochran@gmail.com>
Date:   Tue Feb 1 13:52:26 2011 +0000

    posix-timers: Introduce a syscall for clock tuning.
    
    A new syscall is introduced that allows tuning of a POSIX clock. The
    new call, clock_adjtime, takes two parameters, the clock ID and a
    pointer to a struct timex. Any ADJTIMEX(2) operation may be requested
    via this system call, but various POSIX clocks may or may not support
    tuning.
    
    [ tglx: Adapted to the posix-timer cleanup series. Avoid copy_to_user
            in the error case ]
    
    Signed-off-by: Richard Cochran <richard.cochran@omicron.at>
    Acked-by: John Stultz <johnstul@us.ibm.com>
    LKML-Reference: <20110201134419.869804645@linutronix.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 9192f715bc6304b97fe06c6215d4897a5c279e81
Author: Ben Greear <greearb@candelatech.com>
Date:   Fri Oct 15 15:51:32 2010 -0700

    ath5k: Properly initialize ath_common->cc_lock.
    
    Otherwise, lockdep splats, at the least:
    
    INFO: trying to register non-static key.
    the code is fine but needs lockdep annotation.
    turning off the locking correctness validator.
    Pid: 0, comm: swapper Not tainted 2.6.36-rc8-wl+ #32
    Call Trace:
     [<c075d940>] ? printk+0xf/0x17
     [<c045507a>] register_lock_class+0x5a/0x29e
     [<c0456af5>] __lock_acquire+0xa2/0xb8c
     [<c0455be2>] ? mark_lock+0x1e/0x1de
     [<c041a540>] ? acpi_get_override_irq+0x85/0x8c
     [<c0455536>] ? trace_hardirqs_off+0xb/0xd
     [<c0457639>] lock_acquire+0x5a/0x78
     [<f8126835>] ? ath5k_ani_calibration+0x24/0x52b [ath5k]
     [<c075f6ed>] _raw_spin_lock_bh+0x20/0x2f
     [<f8126835>] ? ath5k_ani_calibration+0x24/0x52b [ath5k]
     [<f8126835>] ath5k_ani_calibration+0x24/0x52b [ath5k]
     [<c0438f99>] ? tasklet_action+0x3b/0xc6
     [<f8123c2b>] ath5k_tasklet_ani+0x18/0x22 [ath5k]
     [<c0438fd1>] tasklet_action+0x73/0xc6
     [<c043945f>] __do_softirq+0x86/0x111
     [<c0439520>] do_softirq+0x36/0x5a
     [<c0439659>] irq_exit+0x35/0x69
     [<c0403fb9>] do_IRQ+0x86/0x9a
     [<c04034ee>] common_interrupt+0x2e/0x40
     [<c045007b>] ? do_adjtimex+0x223/0x55e
     [<c0408245>] ? mwait_idle+0x5c/0x6c
     [<c040227f>] cpu_idle+0x4e/0x6b
     [<c074b6e9>] rest_init+0x8d/0x92
     [<c09758ea>] start_kernel+0x320/0x325
     [<c09750d0>] i386_start_kernel+0xd0/0xd7
    
    Signed-off-by: Ben Greear <greearb@candelatech.com>
    Acked-by: Bruno Randolf <br1@einfach.org>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

commit a092ff0f90cae22b2ac8028ecd2c6f6c1a9e4601
Author: John Stultz <johnstul@us.ibm.com>
Date:   Fri Oct 2 16:17:53 2009 -0700

    time: Implement logarithmic time accumulation
    
    Accumulating one tick at a time works well unless we're using NOHZ.
    Then it can be an issue, since we may have to run through the loop
    a few thousand times, which can increase timer interrupt caused
    latency.
    
    The current solution was to accumulate in half-second intervals
    with NOHZ. This kept the number of loops down, however it did
    slightly change how we make NTP adjustments. While not an issue
    with NTPd users, as NTPd makes adjustments over a longer period of
    time, other adjtimex() users have noticed the half-second
    granularity with which we can apply frequency changes to the clock.
    
    For instance, if a application tries to apply a 100ppm frequency
    correction for 20ms to correct a 2us offset, with NOHZ they either
    get no correction, or a 50us correction.
    
    Now, there will always be some granularity error for applying
    frequency corrections. However with users sensitive to this error
    have seen a 50-500x increase with NOHZ compared to running without
    NOHZ.
    
    So I figured I'd try another approach then just simply increasing
    the interval. My approach is to consume the time interval
    logarithmically. This reduces the number of times through the loop
    needed keeping latency down, while still preserving the original
    granularity error for adjtimex() changes.
    
    Further, this change allows us to remove the xtime_cache code
    (patch to follow), as xtime is always within one tick of the
    current time, instead of the half-second updates it saw before.
    
    An earlier version of this patch has been shipping to x86 users in
    the RedHat MRG releases for awhile without issue, but I've reworked
    this version to be even more careful about avoiding possible
    overflows if the shift value gets too large.
    
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: John Kacur <jkacur@redhat.com>
    Cc: Clark Williams <williams@redhat.com>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    LKML-Reference: <1254525473.7741.88.camel@localhost.localdomain>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

commit 22cfbbfd9f67b67fe073010f51cb71d3632387d5
Author: John Stultz <johnstul@us.ibm.com>
Date:   Wed May 6 11:43:57 2009 +0200

    ntp: adjust SHIFT_PLL to improve NTP convergence
    
    The conversion to the ntpv4 reference model
    f19923937321244e7dc334767eb4b67e0e3d5c74 ("ntp: convert to the NTP4
    reference model") in 2.6.19 added nanosecond resolution the adjtimex
    interface, but also changed the "stiffness" of the frequency adjustments,
    causing NTP convergence time to greatly increase.
    
    SHIFT_PLL, which reduces the stiffness of the freq adjustments, was
    designed to be inversely linked to HZ, and the reference value of 4 was
    designed for Unix systems using HZ=100.  However Linux's clock steering
    code mostly independent of HZ.
    
    So this patch reduces the SHIFT_PLL value from 4 to 2, which causes NTPd
    behavior to match kernels prior to 2.6.19, greatly reducing convergence
    times, and improving close synchronization through environmental thermal
    changes.
    
    The patch also changes some l's to L's in nearby code to avoid misreading
    50l as 501.
    
    [ Impact: tweak NTP algorithm for faster convergence ]
    
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Acked-by: Rik van Riel <riel@redhat.com>
    Cc: zippel@linux-m68k.org
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    LKML-Reference: <200905051956.n45JuVo9025575@imap1.linux-foundation.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

commit 6671de344cd661453bbee3cfde5574a974332436
Merge: 831576fe40f4 7c526e1fef8d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Mar 26 16:05:42 2009 -0700

    Merge branch 'timers-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'timers-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip: (26 commits)
      posix timers: fix RLIMIT_CPU && fork()
      time: ntp: fix bug in ntp_update_offset() & do_adjtimex(), fix
      time: ntp: clean up second_overflow()
      time: ntp: simplify ntp_tick_adj calculations
      time: ntp: make 64-bit constants more robust
      time: ntp: refactor do_adjtimex() some more
      time: ntp: refactor do_adjtimex()
      time: ntp: fix bug in ntp_update_offset() & do_adjtimex()
      time: ntp: micro-optimize ntp_update_offset()
      time: ntp: simplify ntp_update_offset_fll()
      time: ntp: refactor and clean up ntp_update_offset()
      time: ntp: refactor up ntp_update_frequency()
      time: ntp: clean up ntp_update_frequency()
      time: ntp: simplify the MAX_TICKADJ_SCALED definition
      time: ntp: simplify the second_overflow() code flow
      time: ntp: clean up kernel/time/ntp.c
      x86: hpet: stop HPET_COUNTER when programming periodic mode
      x86: hpet: provide separate functions to stop and start the counter
      x86: hpet: print HPET registers during setup (if hpet=verbose is used)
      time: apply NTP frequency/tick changes immediately
      ...

commit a2a5ac8650b570bea3cb3614f77739dcd07d6632
Author: John Stultz <johnstul@us.ibm.com>
Date:   Thu Feb 26 09:46:14 2009 -0800

    time: ntp: fix bug in ntp_update_offset() & do_adjtimex(), fix
    
    The time_status conditional was accidentally placed right after we clear
    the checked time_status bits, which causes us to take the conditional
    every time through. This fixes it by moving the conditional to before we
    clear the time_status bits.
    
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Cc: Clark Williams <williams@redhat.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

commit e96291653b2e4df02f160b574070f6e632868e5e
Author: Ingo Molnar <mingo@elte.hu>
Date:   Sun Feb 22 15:35:18 2009 +0100

    time: ntp: refactor do_adjtimex() some more
    
    Impact: cleanup, no functionality changed
    
    Further simplify do_adjtimex():
    
     - introduce the ntp_start_leap_timer() helper function
     - eliminate the goto adj_done complication
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

commit 80f2257116474ceed5fccab510b4f7245c0f49d7
Author: Ingo Molnar <mingo@elte.hu>
Date:   Sun Feb 22 15:15:32 2009 +0100

    time: ntp: refactor do_adjtimex()
    
    Impact: cleanup, no functionality changed
    
    do_adjtimex() is currently a monster function with a maze of
    branches. Refactor the txc->modes setting aspects of it into
    two new helper functions:
    
            process_adj_status()
            process_adjtimex_modes()
    
    kernel/time/ntp.o:
    
       text    data     bss     dec     hex filename
       2512     114     136    2762     aca ntp.o.before
       2512     114     136    2762     aca ntp.o.after
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

commit 10dd31a7a17254d6ba793305fc590455393e610e
Author: Ingo Molnar <mingo@elte.hu>
Date:   Sun Feb 22 13:38:40 2009 +0100

    time: ntp: fix bug in ntp_update_offset() & do_adjtimex()
    
    Impact: change (fix) the way the NTP PLL seconds offset is initialized/tracked
    
    Fix a bug and do a micro-optimization:
    
    When PLL is enabled we do not reset time_reftime. If the PLL
    was off for a long time (for example after bootup), this is
    arguably the wrong thing to do.
    
    We already had a hack for the common boot-time case in
    ntp_update_offset(), in form of:
    
            if (unlikely(time_status & STA_FREQHOLD || time_reftime == 0))
                    secs = 0;
    
    But the update delta should be reset later on too - not just when
    the PLL is enabled for the first time after bootup.
    
    So do it on !STA_PLL -> STA_PLL transitions.
    
    This changes behavior, as previously if ntpd was disabled for
    a long time and we restarted it, we'd run from that last update,
    with a very large delta.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

commit fdcedf7b75808dd72c3cc0b931be11b04d75c60a
Author: John Stultz <johnstul@us.ibm.com>
Date:   Wed Feb 18 16:02:22 2009 -0800

    time: apply NTP frequency/tick changes immediately
    
    Since the GENERIC_TIME changes landed, the adjtimex behavior changed
    for struct timex.tick and .freq changed. When the tick or freq value
    is set, we adjust the tick_length_base in ntp_update_frequency().
    However, this new value doesn't get applied to tick_length until the
    next second (via second_overflow).
    
    This means some applications that do quick time tweaking do not see the
    requested change made as quickly as expected.
    
    I've run a few tests with this change, and ntpd still functions fine.
    
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

commit 99ebcf8285df28f32fd2d1c19a7166e70f00309c
Merge: 72558dde738b c465a76af658
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Oct 20 13:19:56 2008 -0700

    Merge branch 'v28-timers-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'v28-timers-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip: (36 commits)
      fix documentation of sysrq-q really
      Fix documentation of sysrq-q
      timer_list: add base address to clock base
      timer_list: print cpu number of clockevents device
      timer_list: print real timer address
      NOHZ: restart tick device from irq_enter()
      NOHZ: split tick_nohz_restart_sched_tick()
      NOHZ: unify the nohz function calls in irq_enter()
      timers: fix itimer/many thread hang, fix
      timers: fix itimer/many thread hang, v3
      ntp: improve adjtimex frequency rounding
      timekeeping: fix rounding problem during clock update
      ntp: let update_persistent_clock() sleep
      hrtimer: reorder struct hrtimer to save 8 bytes on 64bit builds
      posix-timers: lock_timer: make it readable
      posix-timers: lock_timer: kill the bogus ->it_id check
      posix-timers: kill ->it_sigev_signo and ->it_sigev_value
      posix-timers: sys_timer_create: cleanup the error handling
      posix-timers: move the initialization of timer->sigq from send to create path
      posix-timers: sys_timer_create: simplify and s/tasklist/rcu/
      ...
    
    Fix trivial conflicts due to sysrq-q description clahes in
    Documentation/sysrq.txt and drivers/char/sysrq.c

commit d40e944c25fb4642adb2a4c580a48218a9f3f824
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Mon Sep 22 14:42:44 2008 -0700

    ntp: improve adjtimex frequency rounding
    
    Change PPM_SCALE_INV_SHIFT so that it doesn't throw away any input bits
    (19 is the amount of the factor 2 in PPM_SCALE), the output frequency
    can then be calculated back to its input value, as the inverse divide
    produce a slightly larger value, which is then correctly rounded by the
    final shift.
    
    Reported-by: Martin Ziegler <ziegler@uni-freiburg.de>
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Cc: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 916c7a855174e3b53d182b97a26b2e27a29726a1
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Wed Aug 20 16:46:08 2008 -0700

    ntp: fix ADJ_OFFSET_SS_READ bug and do_adjtimex() cleanup
    
    Thanks to the review by Michael Kerrisk a bug in the recent
    ADJ_OFFSET_SS_READ option was discovered, where the ntp time_offset was
    inadvertently set by it.  This fixes this by making the adjtime code
    more separate from the ntp_adjtime code (both of which really want to
    be separate syscalls).
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Acked-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

commit eea83d896e318bda54be2d2770d2c5d6668d11db
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Thu May 1 04:34:33 2008 -0700

    ntp: NTP4 user space bits update
    
    This adds a few more things from the ntp nanokernel related to user space.
    It's now possible to select the resolution used of some values via STA_NANO
    and the kernel reports in which mode it works (pll/fll).
    
    If some values for adjtimex() are outside the acceptable range, they are now
    simply normalized instead of letting the syscall fail.  I removed
    MOD_CLKA/MOD_CLKB as the mapping didn't really makes any sense, the kernel
    doesn't support setting the clock.
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Cc: john stultz <johnstul@us.ibm.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit ee9851b218b8bafa22942b5404505ff3d2d34324
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Thu May 1 04:34:32 2008 -0700

    ntp: cleanup ntp.c
    
    This is mostly a style cleanup of ntp.c and extracts part of do_adjtimex as
    ntp_update_offset().  Otherwise the functionality is still the same as before.
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Cc: john stultz <johnstul@us.ibm.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit 52bfb36050c8529d9031d2c2513b281a360922ec
Author: John Stultz <johnstul@us.ibm.com>
Date:   Mon Nov 26 20:42:19 2007 +0100

    time: add ADJ_OFFSET_SS_READ
    
    Michael Kerrisk reported that a long standing bug in the adjtimex()
    system call causes glibc's adjtime(3) function to deliver the wrong
    results if 'delta' is NULL.
    
    add the ADJ_OFFSET_SS_READ API detail, which will be used by glibc
    to fix this API compatibility bug.
    
    Also see: http://bugzilla.kernel.org/show_bug.cgi?id=6761
    
    [ mingo@elte.hu: added patch description and made it backwards compatible ]
    
    NOTE: the new flag is defined 0xa001 so that it returns -EINVAL on
    older kernels - this way glibc can use it safely. Suggested by Ulrich
    Drepper.
    
    Acked-by: Ulrich Drepper <drepper@redhat.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 06b32f3ab6df4c7489729f94bdc7093c72681d4b
Author: Helge Deller <deller@gmx.de>
Date:   Tue Dec 19 19:28:33 2006 +0100

    [PARISC] Handle wrapping in expand_upwards()
    
    Function expand_upwards() did not guarded against wrapping
    around to address 0. This fixes the adjtimex02 testcase from
    the Linux Test Project on a 32bit PARISC kernel.
    
    [expand_upwards is only used on parisc and ia64; it looks like it does
     the right thing on both. --kyle]
    
    Signed-off-by: Helge Deller <deller@gmx.de>
    Cc: Tony Luck <tony.luck@intel.com>
    Signed-off-by: Kyle McMartin <kyle@parisc-linux.org>

commit 87ac84f42a7a580d0dd72ae31d6a5eb4bfe04c6d
Author: David Brownell <david-b@pacbell.net>
Date:   Tue May 8 00:34:00 2007 -0700

    rtc-cmos wakeup interface
    
    I finally got around to testing the updated wakeup event hooks for rtc-cmos,
    and they follow in two patches:
    
     - Interface update ... when a simple enable_irq_wake() doesn't suffice,
       the platform data can hold suspend/resume callback hooks.
    
     - ACPI implementation ... provides callback hooks to do ACPI magic, and
       eliminate the legacy /proc/acpi/alarm file.
    
    The interface update could go into 2.6.21, but that's not essential; they
    will be NOPs on most PCs, without the ACPI stuff.
    
    I suspect the ACPI folk may have opinions about how to merge that second
    patch, and how to obsolete that legacy procfs file.  I'd like to see that
    merge into 2.6.22 if possible...
    
    As for how to kick it in ... two ways:
    
     - The appended "rtcwake" program; updated since the last time it was
       posted, it deals much better with timezones and DST.
    
     - Write the /sys/class/rtc/.../wakealarm file, then go to sleep.
    
    For some reason RTC wake from "swsusp" stopped working on a system where
    it previously worked; the alarm setting appears to get clobbered.  But
    on the bright side, RTC wake from "standby" worked on a system that had
    never been able to resume from that state before ... IDEACPI is my guess
    as to why it finally started to work.  It's the old "two steps forward,
    one step back" dance, I guess.
    
    - Dave
    
    /* gcc -Wall -Os -o rtcwake rtcwake.c */
    
    #include <stdio.h>
    #include <getopt.h>
    #include <fcntl.h>
    #include <stdlib.h>
    #include <string.h>
    #include <unistd.h>
    #include <errno.h>
    #include <time.h>
    
    #include <sys/ioctl.h>
    #include <sys/time.h>
    #include <sys/types.h>
    
    #include <linux/rtc.h>
    
    /* constants from legacy PC/AT hardware */
    #define RTC_PF  0x40
    #define RTC_AF  0x20
    #define RTC_UF  0x10
    
    /*
     * rtcwake -- enter a system sleep state until specified wakeup time.
     *
     * This uses cross-platform Linux interfaces to enter a system sleep state,
     * and leave it no later than a specified time.  It uses any RTC framework
     * driver that supports standard driver model wakeup flags.
     *
     * This is normally used like the old "apmsleep" utility, to wake from a
     * suspend state like ACPI S1 (standby) or S3 (suspend-to-RAM).  Most
     * platforms can implement those without analogues of BIOS, APM, or ACPI.
     *
     * On some systems, this can also be used like "nvram-wakeup", waking
     * from states like ACPI S4 (suspend to disk).  Not all systems have
     * persistent media that are appropriate for such suspend modes.
     *
     * The best way to set the system's RTC is so that it holds the current
     * time in UTC.  Use the "-l" flag to tell this program that the system
     * RTC uses a local timezone instead (maybe you dual-boot MS-Windows).
     */
    
    static char             *progname;
    
    #ifdef  DEBUG
    #define VERSION "1.0 dev (" __DATE__ " " __TIME__ ")"
    #else
    #define VERSION "0.9"
    #endif
    
    static unsigned         verbose;
    static int              rtc_is_utc = -1;
    
    static int may_wakeup(const char *devname)
    {
            char    buf[128], *s;
            FILE    *f;
    
            snprintf(buf, sizeof buf, "/sys/class/rtc/%s/device/power/wakeup",
                            devname);
            f = fopen(buf, "r");
            if (!f) {
                    perror(buf);
                    return 0;
            }
            fgets(buf, sizeof buf, f);
            fclose(f);
    
            s = strchr(buf, '\n');
            if (!s)
                    return 0;
            *s = 0;
    
            /* wakeup events could be disabled or not supported */
            return strcmp(buf, "enabled") == 0;
    }
    
    /* all times should be in UTC */
    static time_t   sys_time;
    static time_t   rtc_time;
    
    static int get_basetimes(int fd)
    {
            struct tm       tm;
            struct rtc_time rtc;
    
            /* this process works in RTC time, except when working
             * with the system clock (which always uses UTC).
             */
            if (rtc_is_utc)
                    setenv("TZ", "UTC", 1);
            tzset();
    
            /* read rtc and system clocks "at the same time", or as
             * precisely (+/- a second) as we can read them.
             */
            if (ioctl(fd, RTC_RD_TIME, &rtc) < 0) {
                    perror("read rtc time");
                    return 0;
            }
            sys_time = time(0);
            if (sys_time == (time_t)-1) {
                    perror("read system time");
                    return 0;
            }
    
            /* convert rtc_time to normal arithmetic-friendly form,
             * updating tm.tm_wday as used by asctime().
             */
            memset(&tm, 0, sizeof tm);
            tm.tm_sec = rtc.tm_sec;
            tm.tm_min = rtc.tm_min;
            tm.tm_hour = rtc.tm_hour;
            tm.tm_mday = rtc.tm_mday;
            tm.tm_mon = rtc.tm_mon;
            tm.tm_year = rtc.tm_year;
            tm.tm_isdst = rtc.tm_isdst;     /* stays unspecified? */
            rtc_time = mktime(&tm);
    
            if (rtc_time == (time_t)-1) {
                    perror("convert rtc time");
                    return 0;
            }
    
            if (verbose) {
                    if (!rtc_is_utc) {
                            printf("\ttzone   = %ld\n", timezone);
                            printf("\ttzname  = %s\n", tzname[daylight]);
                            gmtime_r(&rtc_time, &tm);
                    }
                    printf("\tsystime = %ld, (UTC) %s",
                                    (long) sys_time, asctime(gmtime(&sys_time)));
                    printf("\trtctime = %ld, (UTC) %s",
                                    (long) rtc_time, asctime(&tm));
            }
    
            return 1;
    }
    
    static int setup_alarm(int fd, time_t *wakeup)
    {
            struct tm               *tm;
            struct rtc_wkalrm       wake;
    
            tm = gmtime(wakeup);
    
            wake.time.tm_sec = tm->tm_sec;
            wake.time.tm_min = tm->tm_min;
            wake.time.tm_hour = tm->tm_hour;
            wake.time.tm_mday = tm->tm_mday;
            wake.time.tm_mon = tm->tm_mon;
            wake.time.tm_year = tm->tm_year;
            wake.time.tm_wday = tm->tm_wday;
            wake.time.tm_yday = tm->tm_yday;
            wake.time.tm_isdst = tm->tm_isdst;
    
            /* many rtc alarms only support up to 24 hours from 'now' ... */
            if ((rtc_time + (24 * 60 * 60)) > *wakeup) {
                    if (ioctl(fd, RTC_ALM_SET, &wake.time) < 0) {
                            perror("set rtc alarm");
                            return 0;
                    }
                    if (ioctl(fd, RTC_AIE_ON, 0) < 0) {
                            perror("enable rtc alarm");
                            return 0;
                    }
    
            /* ... so use the "more than 24 hours" request only if we must */
            } else {
                    /* avoid an extra AIE_ON call */
                    wake.enabled = 1;
    
                    if (ioctl(fd, RTC_WKALM_SET, &wake) < 0) {
                            perror("set rtc wake alarm");
                            return 0;
                    }
            }
    
            return 1;
    }
    
    static void suspend_system(const char *suspend)
    {
            FILE    *f = fopen("/sys/power/state", "w");
    
            if (!f) {
                    perror("/sys/power/state");
                    return;
            }
    
            fprintf(f, "%s\n", suspend);
            fflush(f);
    
            /* this executes after wake from suspend */
            fclose(f);
    }
    
    int main(int argc, char **argv)
    {
            static char             *devname = "rtc0";
            static unsigned         seconds = 0;
            static char             *suspend = "standby";
    
            int             t;
            int             fd;
            time_t          alarm = 0;
    
            progname = strrchr(argv[0], '/');
            if (progname)
                    progname++;
            else
                    progname = argv[0];
            if (chdir("/dev/") < 0) {
                    perror("chdir /dev");
                    return 1;
            }
    
            while ((t = getopt(argc, argv, "d:lm:s:t:uVv")) != EOF) {
                    switch (t) {
    
                    case 'd':
                            devname = optarg;
                            break;
    
                    case 'l':
                            rtc_is_utc = 0;
                            break;
    
                    /* what system power mode to use?  for now handle only
                     * standardized mode names; eventually when systems define
                     * their own state names, parse /sys/power/state.
                     *
                     * "on" is used just to test the RTC alarm mechanism,
                     * bypassing all the wakeup-from-sleep infrastructure.
                     */
                    case 'm':
                            if (strcmp(optarg, "standby") == 0
                                            || strcmp(optarg, "mem") == 0
                                            || strcmp(optarg, "disk") == 0
                                            || strcmp(optarg, "on") == 0
                                            ) {
                                    suspend = optarg;
                                    break;
                            }
                            printf("%s: unrecognized suspend state '%s'\n",
                                            progname, optarg);
                            goto usage;
    
                    /* alarm time, seconds-to-sleep (relative) */
                    case 's':
                            t = atoi(optarg);
                            if (t < 0) {
                                    printf("%s: illegal interval %s seconds\n",
                                                    progname, optarg);
                                    goto usage;
                            }
                            seconds = t;
                            break;
    
                    /* alarm time, time_t (absolute, seconds since 1/1 1970 UTC) */
                    case 't':
                            t = atoi(optarg);
                            if (t < 0) {
                                    printf("%s: illegal time_t value %s\n",
                                                    progname, optarg);
                                    goto usage;
                            }
                            alarm = t;
                            break;
    
                    case 'u':
                            rtc_is_utc = 1;
                            break;
    
                    case 'v':
                            verbose++;
                            break;
    
                    case 'V':
                            printf("%s: version %s\n", progname, VERSION);
                            break;
    
                    default:
    usage:
                            printf("usage: %s [options]"
                                    "\n\t"
                                    "-d rtc0|rtc1|...\t(select rtc)"
                                    "\n\t"
                                    "-l\t\t\t(RTC uses local timezone)"
                                    "\n\t"
                                    "-m standby|mem|...\t(sleep mode)"
                                    "\n\t"
                                    "-s seconds\t\t(seconds to sleep)"
                                    "\n\t"
                                    "-t time_t\t\t(time to wake)"
                                    "\n\t"
                                    "-u\t\t\t(RTC uses UTC)"
                                    "\n\t"
                                    "-v\t\t\t(verbose messages)"
                                    "\n\t"
                                    "-V\t\t\t(show version)"
                                    "\n",
                                    progname);
                            return 1;
                    }
            }
    
            if (!alarm && !seconds) {
                    printf("%s: must provide wake time\n", progname);
                    goto usage;
            }
    
            /* REVISIT:  if /etc/adjtime exists, read it to see what
             * the util-linux version of hwclock assumes.
             */
            if (rtc_is_utc == -1) {
                    printf("%s: assuming RTC uses UTC ...\n", progname);
                    rtc_is_utc = 1;
            }
    
            /* this RTC must exist and (if we'll sleep) be wakeup-enabled */
            fd = open(devname, O_RDONLY);
            if (fd < 0) {
                    perror(devname);
                    return 1;
            }
            if (strcmp(suspend, "on") != 0 && !may_wakeup(devname)) {
                    printf("%s: %s not enabled for wakeup events\n",
                                    progname, devname);
                    return 1;
            }
    
            /* relative or absolute alarm time, normalized to time_t */
            if (!get_basetimes(fd))
                    return 1;
            if (verbose)
                    printf("alarm %ld, sys_time %ld, rtc_time %ld, seconds %u\n",
                                    alarm, sys_time, rtc_time, seconds);
            if (alarm) {
                    if (alarm < sys_time) {
                            printf("%s: time doesn't go backward to %s",
                                            progname, ctime(&alarm));
                            return 1;
                    }
                    alarm += sys_time - rtc_time;
            } else
                    alarm = rtc_time + seconds + 1;
            if (setup_alarm(fd, &alarm) < 0)
                    return 1;
    
            sync();
            printf("%s: wakeup from \"%s\" using %s at %s",
                            progname, suspend, devname,
                            ctime(&alarm));
            fflush(stdout);
            usleep(10 * 1000);
    
            if (strcmp(suspend, "on") != 0)
                    suspend_system(suspend);
            else {
                    unsigned long data;
    
                    do {
                            t = read(fd, &data, sizeof data);
                            if (t < 0) {
                                    perror("rtc read");
                                    break;
                            }
                            if (verbose)
                                    printf("... %s: %03lx\n", devname, data);
                    } while (!(data & RTC_AF));
            }
    
            if (ioctl(fd, RTC_AIE_OFF, 0) < 0)
                    perror("disable rtc alarm interrupt");
    
            close(fd);
            return 0;
    }
    
    This patch:
    
    Make rtc-cmos do the relevant magic so this RTC can wake the system from a
    sleep state.  That magic comes in two basic flavors:
    
     - Straightforward:  enable_irq_wake(), the way it'd work on most SOC chips;
       or generally with system sleep states which don't disable core IRQ logic.
    
     - Roundabout, using non-IRQ platform hooks.  This is needed with ACPI and
       one almost-clone chip which uses a special wakeup-only alarm.  (That's
       the RTC used on Footbridge boards, FWIW, which don't do PM in Linux.)
    
    A separate patch implements those hooks for ACPI platforms, so that rtc_cmos
    can issue system wakeup events (and its sysfs "wakealarm" attribute works on
    at least some systems).
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Cc: Alessandro Zummo <a.zummo@towertech.it>
    Cc: Len Brown <lenb@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit bb1d860551c4307b1a7ee9a21b120319075e987e
Author: Jim Houston <jim.houston@comcast.net>
Date:   Sat Oct 28 10:38:56 2006 -0700

    [PATCH] time_adjust cleared before use
    
    I notice that the code which implements adjtime clears the time_adjust
    value before using it.  The attached patch makes the obvious fix.
    
    Acked-by: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Jim Houston <jim.houston@ccur.com>
    Cc: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

commit f19923937321244e7dc334767eb4b67e0e3d5c74
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Sat Sep 30 23:28:28 2006 -0700

    [PATCH] ntp: convert to the NTP4 reference model
    
    This converts the kernel ntp model into a model which matches the nanokernel
    reference implementations.  The previous patches already increased the
    resolution and precision of the computations, so that this conversion becomes
    quite simple.
    
    <linux@horizon.com> explains:
    
    The original NTP kernel interface was defined in units of microseconds.
    That's what Linux implements.  As computers have gotten faster and can now
    split microseconds easily, a new kernel interface using nanosecond units was
    defined ("the nanokernel", confusing as that name is to OS hackers), and
    there's an STA_NANO bit in the adjtimex() status field to tell the application
    which units it's using.
    
    The current ntpd supports both, but Linux loses some possible timing
    resolution because of quantization effects, and the ntpd hackers would really
    like to be able to drop the backwards compatibility code.
    
    Ulrich Windl has been maintaining a patch set to do the conversion for years,
    but it's hard to keep in sync.
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Cc: john stultz <johnstul@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

commit 8f807f8d2137ba728d22820103131038639b68a9
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Sat Sep 30 23:28:25 2006 -0700

    [PATCH] ntp: add time_adjust to tick length
    
    This folds update_ntp_one_tick() into second_overflow() and adds time_adjust
    to the tick length, this makes time_next_adjust unnecessary.  This slightly
    changes the adjtime() behaviour, instead of applying it to the next tick, it's
    applied to the next second.
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Cc: john stultz <johnstul@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

commit 37e53db8aa233c65142d63b496277bf5be9c0ade
Merge: 94b1661d08a2 7384c8bd90a4
Author: Linus Torvalds <torvalds@g5.osdl.org>
Date:   Thu Apr 27 17:01:37 2006 -0700

    Merge branch 'release' of git://git.kernel.org/pub/scm/linux/kernel/git/aegl/linux-2.6
    
    * 'release' of git://git.kernel.org/pub/scm/linux/kernel/git/aegl/linux-2.6:
      [IA64] update sn2 defconfig
      [IA64] Add mca recovery failure messages
      [IA64-SGI] fix SGI Altix tioce_reserve_m32() bug
      [IA64] enable dumps to capture second page of kernel stack
      [IA64-SGI] - Reduce overhead of reading sn_topology
      [IA64-SGI] - Fix discover of nearest cpu node to IO node
      [IA64] IOC4 config option ordering
      [IA64] Setup an IA64 specific reclaim distance
      [IA64] eliminate compile time warnings
      [IA64] eliminate compile time warnings
      [IA64-SGI] SN SAL call to inject memory errors
      [IA64] - Fix MAX_PXM_DOMAINS for systems with > 256 nodes
      [IA64] Remove unused variable in sn_sal.h
      [IA64] Remove redundant NULL checks before kfree
      [IA64] wire up compat_sys_adjtimex()

commit c6180deb1da5d087341fb5a3c1a15e61492dcd6b
Author: Tony Luck <tony.luck@intel.com>
Date:   Tue Apr 18 21:14:22 2006 -0700

    [IA64] wire up compat_sys_adjtimex()
    
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Tony Luck <tony.luck@intel.com>

commit 3158e9411a66fb98d495ac441c242264f31aaf3e
Author: Stephen Rothwell <sfr@canb.auug.org.au>
Date:   Sun Mar 26 01:37:29 2006 -0800

    [PATCH] consolidate sys32/compat_adjtimex
    
    Create compat_sys_adjtimex and use it an all appropriate places.
    
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Paul Mackerras <paulus@samba.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

commit 092b8f3488a3e50a4ab5f2f3f7c8bbf56b3144e1
Author: Paul Mackerras <paulus@samba.org>
Date:   Mon Feb 20 10:38:56 2006 +1100

    powerpc: Keep xtime and gettimeofday in sync
    
    This fixes a regression which was introduced by moving ppc32 to use
    the same sort of lockless gettimeofday as ppc64 has been using for
    some time.  This involves getting the timebase and performing some
    simple arithmetic to convert it to seconds and microseconds.  However,
    the factor and offset used there weren't being updated when NTP
    varied the tick length using adjtimex.  64-bit didn't notice the
    problem because it had a hook in the 32-bit adjtimex compat routine
    that attempted to work out what the generic timekeeping code would
    do and alter the factor and offset to match.  However, that code
    was very complex and it wasn't clear that it still matched what the
    generic code would do.
    
    Now we use the generic current_tick_length() routine that was recently
    added to check that the current tick will be as long as we expect; if
    not we recompute the factor and offset.  This keeps gettimeofday and
    xtime in sync.  In addition we check that gettimeofday hasn't got ahead
    of xtime on each timer interrupt; if it has, we resync.
    
    Signed-off-by: Paul Mackerras <paulus@samba.org>

commit 726c14bf499e91e7ede4f1728830aba05c675061
Author: Paul Mackerras <paulus@samba.org>
Date:   Fri Feb 17 10:30:23 2006 +1100

    [PATCH] Provide an interface for getting the current tick length
    
    This provides an interface for arch code to find out how many
    nanoseconds are going to be added on to xtime by the next call to
    do_timer.  The value returned is a fixed-point number in 52.12 format
    in nanoseconds.  The reason for this format is that it gives the
    full precision that the timekeeping code is using internally.
    
    The motivation for this is to fix a problem that has arisen on 32-bit
    powerpc in that the value returned by do_gettimeofday drifts apart
    from xtime if NTP is being used.  PowerPC is now using a lockless
    do_gettimeofday based on reading the timebase register and performing
    some simple arithmetic.  (This method of getting the time is also
    exported to userspace via the VDSO.)  However, the factor and offset
    it uses were calculated based on the nominal tick length and weren't
    being adjusted when NTP varied the tick length.
    
    Note that 64-bit powerpc has had the lockless do_gettimeofday for a
    long time now.  It also had an extremely hairy routine that got called
    from the 32-bit compat routine for adjtimex, which adjusted the
    factor and offset according to what it thought the timekeeping code
    was going to do.  Not only was this only called if a 32-bit task did
    adjtimex (i.e. not if a 64-bit task did adjtimex), it was also
    duplicating computations from kernel/timer.c and it wasn't clear that
    it was (still) correct.
    
    The simple solution is to ask the timekeeping code how long the
    current jiffy will be on each timer interrupt, after calling
    do_timer.  If this jiffy will be a different length from the last one,
    we then need to compute new values for the factor and offset used in
    the lockless do_gettimeofday.  In this way we can keep xtime and
    do_gettimeofday in sync, even when NTP is varying the tick length.
    
    Note that when adjtimex varies the tick length, it almost always
    introduces the variation from the next tick on.  The only case I could
    see where adjtimex would vary the length of the current tick is when
    an old-style adjtime adjustment is being cancelled.  (It's not clear
    to me why the adjustment has to be cancelled immediately rather than
    from the next tick on.)  Thus I don't see any real need for a hook in
    adjtimex; the rare case of an old-style adjustment being cancelled can
    be fixed up at the next tick.
    
    Signed-off-by: Paul Mackerras <paulus@samba.org>
    Acked-by: john stultz <johnstul@us.ibm.com>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

commit 54095a6ec7b11a008c07c5016b025206a051f560
Author: Giovambattista Pulcini <gpulcini@swintel.it>
Date:   Sat Apr 16 15:24:24 2005 -0700

    [PATCH] ppc32: Fix a problem with NTP on !(chrp||gemini)
    
    The following problem was found by Giovambattista Pulcini
    <gpulcini@swintel.it>, who also provided a partial patch, and this has been
    verified by our time guru Gabriel Paubert <paubert@iram.es>.
    
    The problem is that in do_settimeofday() we always set time_state to
    TIME_ERROR and except on two platforms, never re-set it.  This meant that
    ntp_gettime() and ntp_adjtime() always returned TIME_ERROR, incorrectly.
    Based on Gabriel's analysis, time_state is used for leap-second processing,
    and ppc shouldn't be mucking with it.
    
    Signed-off-by: Tom Rini <trini@kernel.crashing.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>
