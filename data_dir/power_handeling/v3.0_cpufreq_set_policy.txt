commit 1e32083f327184b6226ce320ef30085ce785ea4e
Author: Kevin Hao <haokexin@gmail.com>
Date:   Sun Jan 23 20:45:08 2022 +0800

    cpufreq: governor: Use kobject release() method to free dbs_data
    
    [ Upstream commit a85ee6401a47ae3fc64ba506cacb3e7873823c65 ]
    
    The struct dbs_data embeds a struct gov_attr_set and
    the struct gov_attr_set embeds a kobject. Since every kobject must have
    a release() method and we can't use kfree() to free it directly,
    so introduce cpufreq_dbs_data_release() to release the dbs_data via
    the kobject::release() method. This fixes the calltrace like below:
    
      ODEBUG: free active (active state 0) object type: timer_list hint: delayed_work_timer_fn+0x0/0x34
      WARNING: CPU: 12 PID: 810 at lib/debugobjects.c:505 debug_print_object+0xb8/0x100
      Modules linked in:
      CPU: 12 PID: 810 Comm: sh Not tainted 5.16.0-next-20220120-yocto-standard+ #536
      Hardware name: Marvell OcteonTX CN96XX board (DT)
      pstate: 60400009 (nZCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)
      pc : debug_print_object+0xb8/0x100
      lr : debug_print_object+0xb8/0x100
      sp : ffff80001dfcf9a0
      x29: ffff80001dfcf9a0 x28: 0000000000000001 x27: ffff0001464f0000
      x26: 0000000000000000 x25: ffff8000090e3f00 x24: ffff80000af60210
      x23: ffff8000094dfb78 x22: ffff8000090e3f00 x21: ffff0001080b7118
      x20: ffff80000aeb2430 x19: ffff800009e8f5e0 x18: 0000000000000000
      x17: 0000000000000002 x16: 00004d62e58be040 x15: 013590470523aff8
      x14: ffff8000090e1828 x13: 0000000001359047 x12: 00000000f5257d14
      x11: 0000000000040591 x10: 0000000066c1ffea x9 : ffff8000080d15e0
      x8 : ffff80000a1765a8 x7 : 0000000000000000 x6 : 0000000000000001
      x5 : ffff800009e8c000 x4 : ffff800009e8c760 x3 : 0000000000000000
      x2 : 0000000000000000 x1 : 0000000000000000 x0 : ffff0001474ed040
      Call trace:
       debug_print_object+0xb8/0x100
       __debug_check_no_obj_freed+0x1d0/0x25c
       debug_check_no_obj_freed+0x24/0xa0
       kfree+0x11c/0x440
       cpufreq_dbs_governor_exit+0xa8/0xac
       cpufreq_exit_governor+0x44/0x90
       cpufreq_set_policy+0x29c/0x570
       store_scaling_governor+0x110/0x154
       store+0xb0/0xe0
       sysfs_kf_write+0x58/0x84
       kernfs_fop_write_iter+0x12c/0x1c0
       new_sync_write+0xf0/0x18c
       vfs_write+0x1cc/0x220
       ksys_write+0x74/0x100
       __arm64_sys_write+0x28/0x3c
       invoke_syscall.constprop.0+0x58/0xf0
       do_el0_svc+0x70/0x170
       el0_svc+0x54/0x190
       el0t_64_sync_handler+0xa4/0x130
       el0t_64_sync+0x1a0/0x1a4
      irq event stamp: 189006
      hardirqs last  enabled at (189005): [<ffff8000080849d0>] finish_task_switch.isra.0+0xe0/0x2c0
      hardirqs last disabled at (189006): [<ffff8000090667a4>] el1_dbg+0x24/0xa0
      softirqs last  enabled at (188966): [<ffff8000080106d0>] __do_softirq+0x4b0/0x6a0
      softirqs last disabled at (188957): [<ffff80000804a618>] __irq_exit_rcu+0x108/0x1a4
    
    [ rjw: Because can be freed by the gov_attr_set_put() in
      cpufreq_dbs_governor_exit() now, it is also necessary to put the
      invocation of the governor ->exit() callback into the new
      cpufreq_dbs_data_release() function. ]
    
    Fixes: c4435630361d ("cpufreq: governor: New sysfs show/store callbacks for governor tunables")
    Signed-off-by: Kevin Hao <haokexin@gmail.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit a85ee6401a47ae3fc64ba506cacb3e7873823c65
Author: Kevin Hao <haokexin@gmail.com>
Date:   Sun Jan 23 20:45:08 2022 +0800

    cpufreq: governor: Use kobject release() method to free dbs_data
    
    The struct dbs_data embeds a struct gov_attr_set and
    the struct gov_attr_set embeds a kobject. Since every kobject must have
    a release() method and we can't use kfree() to free it directly,
    so introduce cpufreq_dbs_data_release() to release the dbs_data via
    the kobject::release() method. This fixes the calltrace like below:
    
      ODEBUG: free active (active state 0) object type: timer_list hint: delayed_work_timer_fn+0x0/0x34
      WARNING: CPU: 12 PID: 810 at lib/debugobjects.c:505 debug_print_object+0xb8/0x100
      Modules linked in:
      CPU: 12 PID: 810 Comm: sh Not tainted 5.16.0-next-20220120-yocto-standard+ #536
      Hardware name: Marvell OcteonTX CN96XX board (DT)
      pstate: 60400009 (nZCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)
      pc : debug_print_object+0xb8/0x100
      lr : debug_print_object+0xb8/0x100
      sp : ffff80001dfcf9a0
      x29: ffff80001dfcf9a0 x28: 0000000000000001 x27: ffff0001464f0000
      x26: 0000000000000000 x25: ffff8000090e3f00 x24: ffff80000af60210
      x23: ffff8000094dfb78 x22: ffff8000090e3f00 x21: ffff0001080b7118
      x20: ffff80000aeb2430 x19: ffff800009e8f5e0 x18: 0000000000000000
      x17: 0000000000000002 x16: 00004d62e58be040 x15: 013590470523aff8
      x14: ffff8000090e1828 x13: 0000000001359047 x12: 00000000f5257d14
      x11: 0000000000040591 x10: 0000000066c1ffea x9 : ffff8000080d15e0
      x8 : ffff80000a1765a8 x7 : 0000000000000000 x6 : 0000000000000001
      x5 : ffff800009e8c000 x4 : ffff800009e8c760 x3 : 0000000000000000
      x2 : 0000000000000000 x1 : 0000000000000000 x0 : ffff0001474ed040
      Call trace:
       debug_print_object+0xb8/0x100
       __debug_check_no_obj_freed+0x1d0/0x25c
       debug_check_no_obj_freed+0x24/0xa0
       kfree+0x11c/0x440
       cpufreq_dbs_governor_exit+0xa8/0xac
       cpufreq_exit_governor+0x44/0x90
       cpufreq_set_policy+0x29c/0x570
       store_scaling_governor+0x110/0x154
       store+0xb0/0xe0
       sysfs_kf_write+0x58/0x84
       kernfs_fop_write_iter+0x12c/0x1c0
       new_sync_write+0xf0/0x18c
       vfs_write+0x1cc/0x220
       ksys_write+0x74/0x100
       __arm64_sys_write+0x28/0x3c
       invoke_syscall.constprop.0+0x58/0xf0
       do_el0_svc+0x70/0x170
       el0_svc+0x54/0x190
       el0t_64_sync_handler+0xa4/0x130
       el0t_64_sync+0x1a0/0x1a4
      irq event stamp: 189006
      hardirqs last  enabled at (189005): [<ffff8000080849d0>] finish_task_switch.isra.0+0xe0/0x2c0
      hardirqs last disabled at (189006): [<ffff8000090667a4>] el1_dbg+0x24/0xa0
      softirqs last  enabled at (188966): [<ffff8000080106d0>] __do_softirq+0x4b0/0x6a0
      softirqs last disabled at (188957): [<ffff80000804a618>] __irq_exit_rcu+0x108/0x1a4
    
    [ rjw: Because can be freed by the gov_attr_set_put() in
      cpufreq_dbs_governor_exit() now, it is also necessary to put the
      invocation of the governor ->exit() callback into the new
      cpufreq_dbs_data_release() function. ]
    
    Fixes: c4435630361d ("cpufreq: governor: New sysfs show/store callbacks for governor tunables")
    Signed-off-by: Kevin Hao <haokexin@gmail.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 8d62aec52a8c5b1d25a2364b243fcc5098a2ede9
Author: Kevin Hao <haokexin@gmail.com>
Date:   Thu Aug 5 15:29:17 2021 +0800

    cpufreq: schedutil: Use kobject release() method to free sugov_tunables
    
    [ Upstream commit e5c6b312ce3cc97e90ea159446e6bfa06645364d ]
    
    The struct sugov_tunables is protected by the kobject, so we can't free
    it directly. Otherwise we would get a call trace like this:
      ODEBUG: free active (active state 0) object type: timer_list hint: delayed_work_timer_fn+0x0/0x30
      WARNING: CPU: 3 PID: 720 at lib/debugobjects.c:505 debug_print_object+0xb8/0x100
      Modules linked in:
      CPU: 3 PID: 720 Comm: a.sh Tainted: G        W         5.14.0-rc1-next-20210715-yocto-standard+ #507
      Hardware name: Marvell OcteonTX CN96XX board (DT)
      pstate: 40400009 (nZcv daif +PAN -UAO -TCO BTYPE=--)
      pc : debug_print_object+0xb8/0x100
      lr : debug_print_object+0xb8/0x100
      sp : ffff80001ecaf910
      x29: ffff80001ecaf910 x28: ffff00011b10b8d0 x27: ffff800011043d80
      x26: ffff00011a8f0000 x25: ffff800013cb3ff0 x24: 0000000000000000
      x23: ffff80001142aa68 x22: ffff800011043d80 x21: ffff00010de46f20
      x20: ffff800013c0c520 x19: ffff800011d8f5b0 x18: 0000000000000010
      x17: 6e6968207473696c x16: 5f72656d6974203a x15: 6570797420746365
      x14: 6a626f2029302065 x13: 303378302f307830 x12: 2b6e665f72656d69
      x11: ffff8000124b1560 x10: ffff800012331520 x9 : ffff8000100ca6b0
      x8 : 000000000017ffe8 x7 : c0000000fffeffff x6 : 0000000000000001
      x5 : ffff800011d8c000 x4 : ffff800011d8c740 x3 : 0000000000000000
      x2 : ffff0001108301c0 x1 : ab3c90eedf9c0f00 x0 : 0000000000000000
      Call trace:
       debug_print_object+0xb8/0x100
       __debug_check_no_obj_freed+0x1c0/0x230
       debug_check_no_obj_freed+0x20/0x88
       slab_free_freelist_hook+0x154/0x1c8
       kfree+0x114/0x5d0
       sugov_exit+0xbc/0xc0
       cpufreq_exit_governor+0x44/0x90
       cpufreq_set_policy+0x268/0x4a8
       store_scaling_governor+0xe0/0x128
       store+0xc0/0xf0
       sysfs_kf_write+0x54/0x80
       kernfs_fop_write_iter+0x128/0x1c0
       new_sync_write+0xf0/0x190
       vfs_write+0x2d4/0x478
       ksys_write+0x74/0x100
       __arm64_sys_write+0x24/0x30
       invoke_syscall.constprop.0+0x54/0xe0
       do_el0_svc+0x64/0x158
       el0_svc+0x2c/0xb0
       el0t_64_sync_handler+0xb0/0xb8
       el0t_64_sync+0x198/0x19c
      irq event stamp: 5518
      hardirqs last  enabled at (5517): [<ffff8000100cbd7c>] console_unlock+0x554/0x6c8
      hardirqs last disabled at (5518): [<ffff800010fc0638>] el1_dbg+0x28/0xa0
      softirqs last  enabled at (5504): [<ffff8000100106e0>] __do_softirq+0x4d0/0x6c0
      softirqs last disabled at (5483): [<ffff800010049548>] irq_exit+0x1b0/0x1b8
    
    So split the original sugov_tunables_free() into two functions,
    sugov_clear_global_tunables() is just used to clear the global_tunables
    and the new sugov_tunables_free() is used as kobj_type::release to
    release the sugov_tunables safely.
    
    Fixes: 9bdcb44e391d ("cpufreq: schedutil: New governor based on scheduler utilization data")
    Cc: 4.7+ <stable@vger.kernel.org> # 4.7+
    Signed-off-by: Kevin Hao <haokexin@gmail.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit a7d4fc84404d45d72f4490417e8cc3efa4af93f1
Author: Kevin Hao <haokexin@gmail.com>
Date:   Thu Aug 5 15:29:17 2021 +0800

    cpufreq: schedutil: Use kobject release() method to free sugov_tunables
    
    [ Upstream commit e5c6b312ce3cc97e90ea159446e6bfa06645364d ]
    
    The struct sugov_tunables is protected by the kobject, so we can't free
    it directly. Otherwise we would get a call trace like this:
      ODEBUG: free active (active state 0) object type: timer_list hint: delayed_work_timer_fn+0x0/0x30
      WARNING: CPU: 3 PID: 720 at lib/debugobjects.c:505 debug_print_object+0xb8/0x100
      Modules linked in:
      CPU: 3 PID: 720 Comm: a.sh Tainted: G        W         5.14.0-rc1-next-20210715-yocto-standard+ #507
      Hardware name: Marvell OcteonTX CN96XX board (DT)
      pstate: 40400009 (nZcv daif +PAN -UAO -TCO BTYPE=--)
      pc : debug_print_object+0xb8/0x100
      lr : debug_print_object+0xb8/0x100
      sp : ffff80001ecaf910
      x29: ffff80001ecaf910 x28: ffff00011b10b8d0 x27: ffff800011043d80
      x26: ffff00011a8f0000 x25: ffff800013cb3ff0 x24: 0000000000000000
      x23: ffff80001142aa68 x22: ffff800011043d80 x21: ffff00010de46f20
      x20: ffff800013c0c520 x19: ffff800011d8f5b0 x18: 0000000000000010
      x17: 6e6968207473696c x16: 5f72656d6974203a x15: 6570797420746365
      x14: 6a626f2029302065 x13: 303378302f307830 x12: 2b6e665f72656d69
      x11: ffff8000124b1560 x10: ffff800012331520 x9 : ffff8000100ca6b0
      x8 : 000000000017ffe8 x7 : c0000000fffeffff x6 : 0000000000000001
      x5 : ffff800011d8c000 x4 : ffff800011d8c740 x3 : 0000000000000000
      x2 : ffff0001108301c0 x1 : ab3c90eedf9c0f00 x0 : 0000000000000000
      Call trace:
       debug_print_object+0xb8/0x100
       __debug_check_no_obj_freed+0x1c0/0x230
       debug_check_no_obj_freed+0x20/0x88
       slab_free_freelist_hook+0x154/0x1c8
       kfree+0x114/0x5d0
       sugov_exit+0xbc/0xc0
       cpufreq_exit_governor+0x44/0x90
       cpufreq_set_policy+0x268/0x4a8
       store_scaling_governor+0xe0/0x128
       store+0xc0/0xf0
       sysfs_kf_write+0x54/0x80
       kernfs_fop_write_iter+0x128/0x1c0
       new_sync_write+0xf0/0x190
       vfs_write+0x2d4/0x478
       ksys_write+0x74/0x100
       __arm64_sys_write+0x24/0x30
       invoke_syscall.constprop.0+0x54/0xe0
       do_el0_svc+0x64/0x158
       el0_svc+0x2c/0xb0
       el0t_64_sync_handler+0xb0/0xb8
       el0t_64_sync+0x198/0x19c
      irq event stamp: 5518
      hardirqs last  enabled at (5517): [<ffff8000100cbd7c>] console_unlock+0x554/0x6c8
      hardirqs last disabled at (5518): [<ffff800010fc0638>] el1_dbg+0x28/0xa0
      softirqs last  enabled at (5504): [<ffff8000100106e0>] __do_softirq+0x4d0/0x6c0
      softirqs last disabled at (5483): [<ffff800010049548>] irq_exit+0x1b0/0x1b8
    
    So split the original sugov_tunables_free() into two functions,
    sugov_clear_global_tunables() is just used to clear the global_tunables
    and the new sugov_tunables_free() is used as kobj_type::release to
    release the sugov_tunables safely.
    
    Fixes: 9bdcb44e391d ("cpufreq: schedutil: New governor based on scheduler utilization data")
    Cc: 4.7+ <stable@vger.kernel.org> # 4.7+
    Signed-off-by: Kevin Hao <haokexin@gmail.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 67c98e023135ff81b8d52998a6fdb8ca0c518d82
Author: Kevin Hao <haokexin@gmail.com>
Date:   Thu Aug 5 15:29:17 2021 +0800

    cpufreq: schedutil: Use kobject release() method to free sugov_tunables
    
    [ Upstream commit e5c6b312ce3cc97e90ea159446e6bfa06645364d ]
    
    The struct sugov_tunables is protected by the kobject, so we can't free
    it directly. Otherwise we would get a call trace like this:
      ODEBUG: free active (active state 0) object type: timer_list hint: delayed_work_timer_fn+0x0/0x30
      WARNING: CPU: 3 PID: 720 at lib/debugobjects.c:505 debug_print_object+0xb8/0x100
      Modules linked in:
      CPU: 3 PID: 720 Comm: a.sh Tainted: G        W         5.14.0-rc1-next-20210715-yocto-standard+ #507
      Hardware name: Marvell OcteonTX CN96XX board (DT)
      pstate: 40400009 (nZcv daif +PAN -UAO -TCO BTYPE=--)
      pc : debug_print_object+0xb8/0x100
      lr : debug_print_object+0xb8/0x100
      sp : ffff80001ecaf910
      x29: ffff80001ecaf910 x28: ffff00011b10b8d0 x27: ffff800011043d80
      x26: ffff00011a8f0000 x25: ffff800013cb3ff0 x24: 0000000000000000
      x23: ffff80001142aa68 x22: ffff800011043d80 x21: ffff00010de46f20
      x20: ffff800013c0c520 x19: ffff800011d8f5b0 x18: 0000000000000010
      x17: 6e6968207473696c x16: 5f72656d6974203a x15: 6570797420746365
      x14: 6a626f2029302065 x13: 303378302f307830 x12: 2b6e665f72656d69
      x11: ffff8000124b1560 x10: ffff800012331520 x9 : ffff8000100ca6b0
      x8 : 000000000017ffe8 x7 : c0000000fffeffff x6 : 0000000000000001
      x5 : ffff800011d8c000 x4 : ffff800011d8c740 x3 : 0000000000000000
      x2 : ffff0001108301c0 x1 : ab3c90eedf9c0f00 x0 : 0000000000000000
      Call trace:
       debug_print_object+0xb8/0x100
       __debug_check_no_obj_freed+0x1c0/0x230
       debug_check_no_obj_freed+0x20/0x88
       slab_free_freelist_hook+0x154/0x1c8
       kfree+0x114/0x5d0
       sugov_exit+0xbc/0xc0
       cpufreq_exit_governor+0x44/0x90
       cpufreq_set_policy+0x268/0x4a8
       store_scaling_governor+0xe0/0x128
       store+0xc0/0xf0
       sysfs_kf_write+0x54/0x80
       kernfs_fop_write_iter+0x128/0x1c0
       new_sync_write+0xf0/0x190
       vfs_write+0x2d4/0x478
       ksys_write+0x74/0x100
       __arm64_sys_write+0x24/0x30
       invoke_syscall.constprop.0+0x54/0xe0
       do_el0_svc+0x64/0x158
       el0_svc+0x2c/0xb0
       el0t_64_sync_handler+0xb0/0xb8
       el0t_64_sync+0x198/0x19c
      irq event stamp: 5518
      hardirqs last  enabled at (5517): [<ffff8000100cbd7c>] console_unlock+0x554/0x6c8
      hardirqs last disabled at (5518): [<ffff800010fc0638>] el1_dbg+0x28/0xa0
      softirqs last  enabled at (5504): [<ffff8000100106e0>] __do_softirq+0x4d0/0x6c0
      softirqs last disabled at (5483): [<ffff800010049548>] irq_exit+0x1b0/0x1b8
    
    So split the original sugov_tunables_free() into two functions,
    sugov_clear_global_tunables() is just used to clear the global_tunables
    and the new sugov_tunables_free() is used as kobj_type::release to
    release the sugov_tunables safely.
    
    Fixes: 9bdcb44e391d ("cpufreq: schedutil: New governor based on scheduler utilization data")
    Cc: 4.7+ <stable@vger.kernel.org> # 4.7+
    Signed-off-by: Kevin Hao <haokexin@gmail.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 30d57cf2c4116ca6d34ecd1cac94ad84f8bc446c
Author: Kevin Hao <haokexin@gmail.com>
Date:   Thu Aug 5 15:29:17 2021 +0800

    cpufreq: schedutil: Use kobject release() method to free sugov_tunables
    
    [ Upstream commit e5c6b312ce3cc97e90ea159446e6bfa06645364d ]
    
    The struct sugov_tunables is protected by the kobject, so we can't free
    it directly. Otherwise we would get a call trace like this:
      ODEBUG: free active (active state 0) object type: timer_list hint: delayed_work_timer_fn+0x0/0x30
      WARNING: CPU: 3 PID: 720 at lib/debugobjects.c:505 debug_print_object+0xb8/0x100
      Modules linked in:
      CPU: 3 PID: 720 Comm: a.sh Tainted: G        W         5.14.0-rc1-next-20210715-yocto-standard+ #507
      Hardware name: Marvell OcteonTX CN96XX board (DT)
      pstate: 40400009 (nZcv daif +PAN -UAO -TCO BTYPE=--)
      pc : debug_print_object+0xb8/0x100
      lr : debug_print_object+0xb8/0x100
      sp : ffff80001ecaf910
      x29: ffff80001ecaf910 x28: ffff00011b10b8d0 x27: ffff800011043d80
      x26: ffff00011a8f0000 x25: ffff800013cb3ff0 x24: 0000000000000000
      x23: ffff80001142aa68 x22: ffff800011043d80 x21: ffff00010de46f20
      x20: ffff800013c0c520 x19: ffff800011d8f5b0 x18: 0000000000000010
      x17: 6e6968207473696c x16: 5f72656d6974203a x15: 6570797420746365
      x14: 6a626f2029302065 x13: 303378302f307830 x12: 2b6e665f72656d69
      x11: ffff8000124b1560 x10: ffff800012331520 x9 : ffff8000100ca6b0
      x8 : 000000000017ffe8 x7 : c0000000fffeffff x6 : 0000000000000001
      x5 : ffff800011d8c000 x4 : ffff800011d8c740 x3 : 0000000000000000
      x2 : ffff0001108301c0 x1 : ab3c90eedf9c0f00 x0 : 0000000000000000
      Call trace:
       debug_print_object+0xb8/0x100
       __debug_check_no_obj_freed+0x1c0/0x230
       debug_check_no_obj_freed+0x20/0x88
       slab_free_freelist_hook+0x154/0x1c8
       kfree+0x114/0x5d0
       sugov_exit+0xbc/0xc0
       cpufreq_exit_governor+0x44/0x90
       cpufreq_set_policy+0x268/0x4a8
       store_scaling_governor+0xe0/0x128
       store+0xc0/0xf0
       sysfs_kf_write+0x54/0x80
       kernfs_fop_write_iter+0x128/0x1c0
       new_sync_write+0xf0/0x190
       vfs_write+0x2d4/0x478
       ksys_write+0x74/0x100
       __arm64_sys_write+0x24/0x30
       invoke_syscall.constprop.0+0x54/0xe0
       do_el0_svc+0x64/0x158
       el0_svc+0x2c/0xb0
       el0t_64_sync_handler+0xb0/0xb8
       el0t_64_sync+0x198/0x19c
      irq event stamp: 5518
      hardirqs last  enabled at (5517): [<ffff8000100cbd7c>] console_unlock+0x554/0x6c8
      hardirqs last disabled at (5518): [<ffff800010fc0638>] el1_dbg+0x28/0xa0
      softirqs last  enabled at (5504): [<ffff8000100106e0>] __do_softirq+0x4d0/0x6c0
      softirqs last disabled at (5483): [<ffff800010049548>] irq_exit+0x1b0/0x1b8
    
    So split the original sugov_tunables_free() into two functions,
    sugov_clear_global_tunables() is just used to clear the global_tunables
    and the new sugov_tunables_free() is used as kobj_type::release to
    release the sugov_tunables safely.
    
    Fixes: 9bdcb44e391d ("cpufreq: schedutil: New governor based on scheduler utilization data")
    Cc: 4.7+ <stable@vger.kernel.org> # 4.7+
    Signed-off-by: Kevin Hao <haokexin@gmail.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 463c46705f321201090b69c4ad5da0cd2ce614c9
Author: Kevin Hao <haokexin@gmail.com>
Date:   Thu Aug 5 15:29:17 2021 +0800

    cpufreq: schedutil: Use kobject release() method to free sugov_tunables
    
    [ Upstream commit e5c6b312ce3cc97e90ea159446e6bfa06645364d ]
    
    The struct sugov_tunables is protected by the kobject, so we can't free
    it directly. Otherwise we would get a call trace like this:
      ODEBUG: free active (active state 0) object type: timer_list hint: delayed_work_timer_fn+0x0/0x30
      WARNING: CPU: 3 PID: 720 at lib/debugobjects.c:505 debug_print_object+0xb8/0x100
      Modules linked in:
      CPU: 3 PID: 720 Comm: a.sh Tainted: G        W         5.14.0-rc1-next-20210715-yocto-standard+ #507
      Hardware name: Marvell OcteonTX CN96XX board (DT)
      pstate: 40400009 (nZcv daif +PAN -UAO -TCO BTYPE=--)
      pc : debug_print_object+0xb8/0x100
      lr : debug_print_object+0xb8/0x100
      sp : ffff80001ecaf910
      x29: ffff80001ecaf910 x28: ffff00011b10b8d0 x27: ffff800011043d80
      x26: ffff00011a8f0000 x25: ffff800013cb3ff0 x24: 0000000000000000
      x23: ffff80001142aa68 x22: ffff800011043d80 x21: ffff00010de46f20
      x20: ffff800013c0c520 x19: ffff800011d8f5b0 x18: 0000000000000010
      x17: 6e6968207473696c x16: 5f72656d6974203a x15: 6570797420746365
      x14: 6a626f2029302065 x13: 303378302f307830 x12: 2b6e665f72656d69
      x11: ffff8000124b1560 x10: ffff800012331520 x9 : ffff8000100ca6b0
      x8 : 000000000017ffe8 x7 : c0000000fffeffff x6 : 0000000000000001
      x5 : ffff800011d8c000 x4 : ffff800011d8c740 x3 : 0000000000000000
      x2 : ffff0001108301c0 x1 : ab3c90eedf9c0f00 x0 : 0000000000000000
      Call trace:
       debug_print_object+0xb8/0x100
       __debug_check_no_obj_freed+0x1c0/0x230
       debug_check_no_obj_freed+0x20/0x88
       slab_free_freelist_hook+0x154/0x1c8
       kfree+0x114/0x5d0
       sugov_exit+0xbc/0xc0
       cpufreq_exit_governor+0x44/0x90
       cpufreq_set_policy+0x268/0x4a8
       store_scaling_governor+0xe0/0x128
       store+0xc0/0xf0
       sysfs_kf_write+0x54/0x80
       kernfs_fop_write_iter+0x128/0x1c0
       new_sync_write+0xf0/0x190
       vfs_write+0x2d4/0x478
       ksys_write+0x74/0x100
       __arm64_sys_write+0x24/0x30
       invoke_syscall.constprop.0+0x54/0xe0
       do_el0_svc+0x64/0x158
       el0_svc+0x2c/0xb0
       el0t_64_sync_handler+0xb0/0xb8
       el0t_64_sync+0x198/0x19c
      irq event stamp: 5518
      hardirqs last  enabled at (5517): [<ffff8000100cbd7c>] console_unlock+0x554/0x6c8
      hardirqs last disabled at (5518): [<ffff800010fc0638>] el1_dbg+0x28/0xa0
      softirqs last  enabled at (5504): [<ffff8000100106e0>] __do_softirq+0x4d0/0x6c0
      softirqs last disabled at (5483): [<ffff800010049548>] irq_exit+0x1b0/0x1b8
    
    So split the original sugov_tunables_free() into two functions,
    sugov_clear_global_tunables() is just used to clear the global_tunables
    and the new sugov_tunables_free() is used as kobj_type::release to
    release the sugov_tunables safely.
    
    Fixes: 9bdcb44e391d ("cpufreq: schedutil: New governor based on scheduler utilization data")
    Cc: 4.7+ <stable@vger.kernel.org> # 4.7+
    Signed-off-by: Kevin Hao <haokexin@gmail.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit cb4a53ba37532c861a5f3f22803391018a41849a
Author: Kevin Hao <haokexin@gmail.com>
Date:   Thu Aug 5 15:29:17 2021 +0800

    cpufreq: schedutil: Use kobject release() method to free sugov_tunables
    
    [ Upstream commit e5c6b312ce3cc97e90ea159446e6bfa06645364d ]
    
    The struct sugov_tunables is protected by the kobject, so we can't free
    it directly. Otherwise we would get a call trace like this:
      ODEBUG: free active (active state 0) object type: timer_list hint: delayed_work_timer_fn+0x0/0x30
      WARNING: CPU: 3 PID: 720 at lib/debugobjects.c:505 debug_print_object+0xb8/0x100
      Modules linked in:
      CPU: 3 PID: 720 Comm: a.sh Tainted: G        W         5.14.0-rc1-next-20210715-yocto-standard+ #507
      Hardware name: Marvell OcteonTX CN96XX board (DT)
      pstate: 40400009 (nZcv daif +PAN -UAO -TCO BTYPE=--)
      pc : debug_print_object+0xb8/0x100
      lr : debug_print_object+0xb8/0x100
      sp : ffff80001ecaf910
      x29: ffff80001ecaf910 x28: ffff00011b10b8d0 x27: ffff800011043d80
      x26: ffff00011a8f0000 x25: ffff800013cb3ff0 x24: 0000000000000000
      x23: ffff80001142aa68 x22: ffff800011043d80 x21: ffff00010de46f20
      x20: ffff800013c0c520 x19: ffff800011d8f5b0 x18: 0000000000000010
      x17: 6e6968207473696c x16: 5f72656d6974203a x15: 6570797420746365
      x14: 6a626f2029302065 x13: 303378302f307830 x12: 2b6e665f72656d69
      x11: ffff8000124b1560 x10: ffff800012331520 x9 : ffff8000100ca6b0
      x8 : 000000000017ffe8 x7 : c0000000fffeffff x6 : 0000000000000001
      x5 : ffff800011d8c000 x4 : ffff800011d8c740 x3 : 0000000000000000
      x2 : ffff0001108301c0 x1 : ab3c90eedf9c0f00 x0 : 0000000000000000
      Call trace:
       debug_print_object+0xb8/0x100
       __debug_check_no_obj_freed+0x1c0/0x230
       debug_check_no_obj_freed+0x20/0x88
       slab_free_freelist_hook+0x154/0x1c8
       kfree+0x114/0x5d0
       sugov_exit+0xbc/0xc0
       cpufreq_exit_governor+0x44/0x90
       cpufreq_set_policy+0x268/0x4a8
       store_scaling_governor+0xe0/0x128
       store+0xc0/0xf0
       sysfs_kf_write+0x54/0x80
       kernfs_fop_write_iter+0x128/0x1c0
       new_sync_write+0xf0/0x190
       vfs_write+0x2d4/0x478
       ksys_write+0x74/0x100
       __arm64_sys_write+0x24/0x30
       invoke_syscall.constprop.0+0x54/0xe0
       do_el0_svc+0x64/0x158
       el0_svc+0x2c/0xb0
       el0t_64_sync_handler+0xb0/0xb8
       el0t_64_sync+0x198/0x19c
      irq event stamp: 5518
      hardirqs last  enabled at (5517): [<ffff8000100cbd7c>] console_unlock+0x554/0x6c8
      hardirqs last disabled at (5518): [<ffff800010fc0638>] el1_dbg+0x28/0xa0
      softirqs last  enabled at (5504): [<ffff8000100106e0>] __do_softirq+0x4d0/0x6c0
      softirqs last disabled at (5483): [<ffff800010049548>] irq_exit+0x1b0/0x1b8
    
    So split the original sugov_tunables_free() into two functions,
    sugov_clear_global_tunables() is just used to clear the global_tunables
    and the new sugov_tunables_free() is used as kobj_type::release to
    release the sugov_tunables safely.
    
    Fixes: 9bdcb44e391d ("cpufreq: schedutil: New governor based on scheduler utilization data")
    Cc: 4.7+ <stable@vger.kernel.org> # 4.7+
    Signed-off-by: Kevin Hao <haokexin@gmail.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit e5c6b312ce3cc97e90ea159446e6bfa06645364d
Author: Kevin Hao <haokexin@gmail.com>
Date:   Thu Aug 5 15:29:17 2021 +0800

    cpufreq: schedutil: Use kobject release() method to free sugov_tunables
    
    The struct sugov_tunables is protected by the kobject, so we can't free
    it directly. Otherwise we would get a call trace like this:
      ODEBUG: free active (active state 0) object type: timer_list hint: delayed_work_timer_fn+0x0/0x30
      WARNING: CPU: 3 PID: 720 at lib/debugobjects.c:505 debug_print_object+0xb8/0x100
      Modules linked in:
      CPU: 3 PID: 720 Comm: a.sh Tainted: G        W         5.14.0-rc1-next-20210715-yocto-standard+ #507
      Hardware name: Marvell OcteonTX CN96XX board (DT)
      pstate: 40400009 (nZcv daif +PAN -UAO -TCO BTYPE=--)
      pc : debug_print_object+0xb8/0x100
      lr : debug_print_object+0xb8/0x100
      sp : ffff80001ecaf910
      x29: ffff80001ecaf910 x28: ffff00011b10b8d0 x27: ffff800011043d80
      x26: ffff00011a8f0000 x25: ffff800013cb3ff0 x24: 0000000000000000
      x23: ffff80001142aa68 x22: ffff800011043d80 x21: ffff00010de46f20
      x20: ffff800013c0c520 x19: ffff800011d8f5b0 x18: 0000000000000010
      x17: 6e6968207473696c x16: 5f72656d6974203a x15: 6570797420746365
      x14: 6a626f2029302065 x13: 303378302f307830 x12: 2b6e665f72656d69
      x11: ffff8000124b1560 x10: ffff800012331520 x9 : ffff8000100ca6b0
      x8 : 000000000017ffe8 x7 : c0000000fffeffff x6 : 0000000000000001
      x5 : ffff800011d8c000 x4 : ffff800011d8c740 x3 : 0000000000000000
      x2 : ffff0001108301c0 x1 : ab3c90eedf9c0f00 x0 : 0000000000000000
      Call trace:
       debug_print_object+0xb8/0x100
       __debug_check_no_obj_freed+0x1c0/0x230
       debug_check_no_obj_freed+0x20/0x88
       slab_free_freelist_hook+0x154/0x1c8
       kfree+0x114/0x5d0
       sugov_exit+0xbc/0xc0
       cpufreq_exit_governor+0x44/0x90
       cpufreq_set_policy+0x268/0x4a8
       store_scaling_governor+0xe0/0x128
       store+0xc0/0xf0
       sysfs_kf_write+0x54/0x80
       kernfs_fop_write_iter+0x128/0x1c0
       new_sync_write+0xf0/0x190
       vfs_write+0x2d4/0x478
       ksys_write+0x74/0x100
       __arm64_sys_write+0x24/0x30
       invoke_syscall.constprop.0+0x54/0xe0
       do_el0_svc+0x64/0x158
       el0_svc+0x2c/0xb0
       el0t_64_sync_handler+0xb0/0xb8
       el0t_64_sync+0x198/0x19c
      irq event stamp: 5518
      hardirqs last  enabled at (5517): [<ffff8000100cbd7c>] console_unlock+0x554/0x6c8
      hardirqs last disabled at (5518): [<ffff800010fc0638>] el1_dbg+0x28/0xa0
      softirqs last  enabled at (5504): [<ffff8000100106e0>] __do_softirq+0x4d0/0x6c0
      softirqs last disabled at (5483): [<ffff800010049548>] irq_exit+0x1b0/0x1b8
    
    So split the original sugov_tunables_free() into two functions,
    sugov_clear_global_tunables() is just used to clear the global_tunables
    and the new sugov_tunables_free() is used as kobj_type::release to
    release the sugov_tunables safely.
    
    Fixes: 9bdcb44e391d ("cpufreq: schedutil: New governor based on scheduler utilization data")
    Cc: 4.7+ <stable@vger.kernel.org> # 4.7+
    Signed-off-by: Kevin Hao <haokexin@gmail.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit a039c41fb75ddc8f915b51822b4d49a33e117cb0
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Feb 9 09:01:35 2016 +0530

    Revert "cpufreq: Drop rwsem lock around CPUFREQ_GOV_POLICY_EXIT"
    
    commit 68e80dae09033d778b98dc88e5bfe8fdade188e5 upstream.
    
    Earlier, when the struct freq-attr was used to represent governor
    attributes, the standard cpufreq show/store sysfs attribute callbacks
    were applied to the governor tunable attributes and they always acquire
    the policy->rwsem lock before carrying out the operation.  That could
    have resulted in an ABBA deadlock if governor tunable attributes are
    removed under policy->rwsem while one of them is being accessed
    concurrently (if sysfs attributes removal wins the race, it will wait
    for the access to complete with policy->rwsem held while the attribute
    callback will block on policy->rwsem indefinitely).
    
    We attempted to address this issue by dropping policy->rwsem around
    governor tunable attributes removal (that is, around invocations of the
    ->governor callback with the event arg equal to CPUFREQ_GOV_POLICY_EXIT)
    in cpufreq_set_policy(), but that opened up race conditions that had not
    been possible with policy->rwsem held all the time.
    
    The previous commit, "cpufreq: governor: New sysfs show/store callbacks
    for governor tunables", fixed the original ABBA deadlock by adding new
    governor specific show/store callbacks.
    
    We don't have to drop rwsem around invocations of governor event
    CPUFREQ_GOV_POLICY_EXIT anymore, and original fix can be reverted now.
    
    Fixes: 955ef4833574 (cpufreq: Drop rwsem lock around CPUFREQ_GOV_POLICY_EXIT)
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reported-by: Juri Lelli <juri.lelli@arm.com>
    Tested-by: Juri Lelli <juri.lelli@arm.com>
    Tested-by: Shilpasri G Bhat <shilpa.bhat@linux.vnet.ibm.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 473f1a9496a1871ab855be5f959684f1dea86bb0
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Feb 26 22:39:27 2020 +0100

    cpufreq: Fix policy initialization for internal governor drivers
    
    commit f5739cb0b56590d68d8df8a44659893b6d0084c3 upstream.
    
    Before commit 1e4f63aecb53 ("cpufreq: Avoid creating excessively
    large stack frames") the initial value of the policy field in struct
    cpufreq_policy set by the driver's ->init() callback was implicitly
    passed from cpufreq_init_policy() to cpufreq_set_policy() if the
    default governor was neither "performance" nor "powersave".  After
    that commit, however, cpufreq_init_policy() must take that case into
    consideration explicitly and handle it as appropriate, so make that
    happen.
    
    Fixes: 1e4f63aecb53 ("cpufreq: Avoid creating excessively large stack frames")
    Link: https://lore.kernel.org/linux-pm/39fb762880c27da110086741315ca8b111d781cd.camel@gmail.com/
    Reported-by: Artem Bityutskiy <dedekind1@gmail.com>
    Cc: 5.4+ <stable@vger.kernel.org> # 5.4+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 9629f47d7d1c110fe22c617dc0a52acb23b3bdf0
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Feb 26 22:39:27 2020 +0100

    cpufreq: Fix policy initialization for internal governor drivers
    
    commit f5739cb0b56590d68d8df8a44659893b6d0084c3 upstream.
    
    Before commit 1e4f63aecb53 ("cpufreq: Avoid creating excessively
    large stack frames") the initial value of the policy field in struct
    cpufreq_policy set by the driver's ->init() callback was implicitly
    passed from cpufreq_init_policy() to cpufreq_set_policy() if the
    default governor was neither "performance" nor "powersave".  After
    that commit, however, cpufreq_init_policy() must take that case into
    consideration explicitly and handle it as appropriate, so make that
    happen.
    
    Fixes: 1e4f63aecb53 ("cpufreq: Avoid creating excessively large stack frames")
    Link: https://lore.kernel.org/linux-pm/39fb762880c27da110086741315ca8b111d781cd.camel@gmail.com/
    Reported-by: Artem Bityutskiy <dedekind1@gmail.com>
    Cc: 5.4+ <stable@vger.kernel.org> # 5.4+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit f5739cb0b56590d68d8df8a44659893b6d0084c3
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Feb 26 22:39:27 2020 +0100

    cpufreq: Fix policy initialization for internal governor drivers
    
    Before commit 1e4f63aecb53 ("cpufreq: Avoid creating excessively
    large stack frames") the initial value of the policy field in struct
    cpufreq_policy set by the driver's ->init() callback was implicitly
    passed from cpufreq_init_policy() to cpufreq_set_policy() if the
    default governor was neither "performance" nor "powersave".  After
    that commit, however, cpufreq_init_policy() must take that case into
    consideration explicitly and handle it as appropriate, so make that
    happen.
    
    Fixes: 1e4f63aecb53 ("cpufreq: Avoid creating excessively large stack frames")
    Link: https://lore.kernel.org/linux-pm/39fb762880c27da110086741315ca8b111d781cd.camel@gmail.com/
    Reported-by: Artem Bityutskiy <dedekind1@gmail.com>
    Cc: 5.4+ <stable@vger.kernel.org> # 5.4+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>

commit 16d51c1c10ed9993c5d97c3126ceac5b579c60b7
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Jan 26 23:40:11 2020 +0100

    cpufreq: Avoid creating excessively large stack frames
    
    commit 1e4f63aecb53e48468661e922fc2fa3b83e55722 upstream.
    
    In the process of modifying a cpufreq policy, the cpufreq core makes
    a copy of it including all of the internals which is stored on the
    CPU stack.  Because struct cpufreq_policy is relatively large, this
    may cause the size of the stack frame to exceed the 2 KB limit and
    so the GCC complains when -Wframe-larger-than= is used.
    
    In fact, it is not necessary to copy the entire policy structure
    in order to modify it, however.
    
    First, because cpufreq_set_policy() obtains the min and max policy
    limits from frequency QoS now, it is not necessary to pass the limits
    to it from the callers.  The only things that need to be passed to it
    from there are the new governor pointer or (if there is a built-in
    governor in the driver) the "policy" value representing the governor
    choice.  They both can be passed as individual arguments, though, so
    make cpufreq_set_policy() take them this way and rework its callers
    accordingly.  This avoids making copies of cpufreq policies in the
    callers of cpufreq_set_policy().
    
    Second, cpufreq_set_policy() still needs to pass the new policy
    data to the ->verify() callback of the cpufreq driver whose task
    is to sanitize the min and max policy limits.  It still does not
    need to make a full copy of struct cpufreq_policy for this purpose,
    but it needs to pass a few items from it to the driver in case they
    are needed (different drivers have different needs in that respect
    and all of them have to be covered).  For this reason, introduce
    struct cpufreq_policy_data to hold copies of the members of
    struct cpufreq_policy used by the existing ->verify() driver
    callbacks and pass a pointer to a temporary structure of that
    type to ->verify() (instead of passing a pointer to full struct
    cpufreq_policy to it).
    
    While at it, notice that intel_pstate and longrun don't really need
    to verify the "policy" value in struct cpufreq_policy, so drop those
    check from them to avoid copying "policy" into struct
    cpufreq_policy_data (which allows it to be slightly smaller).
    
    Also while at it fix up white space in a couple of places and make
    cpufreq_set_policy() static (as it can be so).
    
    Fixes: 3000ce3c52f8 ("cpufreq: Use per-policy frequency QoS")
    Link: https://lore.kernel.org/linux-pm/CAMuHMdX6-jb1W8uC2_237m8ctCpsnGp=JCxqt8pCWVqNXHmkVg@mail.gmail.com
    Reported-by: kbuild test robot <lkp@intel.com>
    Reported-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: 5.4+ <stable@vger.kernel.org> # 5.4+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit f5f68d165dc0c8603d386ac272fbea0a1609c0de
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Jan 26 23:40:11 2020 +0100

    cpufreq: Avoid creating excessively large stack frames
    
    commit 1e4f63aecb53e48468661e922fc2fa3b83e55722 upstream.
    
    In the process of modifying a cpufreq policy, the cpufreq core makes
    a copy of it including all of the internals which is stored on the
    CPU stack.  Because struct cpufreq_policy is relatively large, this
    may cause the size of the stack frame to exceed the 2 KB limit and
    so the GCC complains when -Wframe-larger-than= is used.
    
    In fact, it is not necessary to copy the entire policy structure
    in order to modify it, however.
    
    First, because cpufreq_set_policy() obtains the min and max policy
    limits from frequency QoS now, it is not necessary to pass the limits
    to it from the callers.  The only things that need to be passed to it
    from there are the new governor pointer or (if there is a built-in
    governor in the driver) the "policy" value representing the governor
    choice.  They both can be passed as individual arguments, though, so
    make cpufreq_set_policy() take them this way and rework its callers
    accordingly.  This avoids making copies of cpufreq policies in the
    callers of cpufreq_set_policy().
    
    Second, cpufreq_set_policy() still needs to pass the new policy
    data to the ->verify() callback of the cpufreq driver whose task
    is to sanitize the min and max policy limits.  It still does not
    need to make a full copy of struct cpufreq_policy for this purpose,
    but it needs to pass a few items from it to the driver in case they
    are needed (different drivers have different needs in that respect
    and all of them have to be covered).  For this reason, introduce
    struct cpufreq_policy_data to hold copies of the members of
    struct cpufreq_policy used by the existing ->verify() driver
    callbacks and pass a pointer to a temporary structure of that
    type to ->verify() (instead of passing a pointer to full struct
    cpufreq_policy to it).
    
    While at it, notice that intel_pstate and longrun don't really need
    to verify the "policy" value in struct cpufreq_policy, so drop those
    check from them to avoid copying "policy" into struct
    cpufreq_policy_data (which allows it to be slightly smaller).
    
    Also while at it fix up white space in a couple of places and make
    cpufreq_set_policy() static (as it can be so).
    
    Fixes: 3000ce3c52f8 ("cpufreq: Use per-policy frequency QoS")
    Link: https://lore.kernel.org/linux-pm/CAMuHMdX6-jb1W8uC2_237m8ctCpsnGp=JCxqt8pCWVqNXHmkVg@mail.gmail.com
    Reported-by: kbuild test robot <lkp@intel.com>
    Reported-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: 5.4+ <stable@vger.kernel.org> # 5.4+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 1e4f63aecb53e48468661e922fc2fa3b83e55722
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Jan 26 23:40:11 2020 +0100

    cpufreq: Avoid creating excessively large stack frames
    
    In the process of modifying a cpufreq policy, the cpufreq core makes
    a copy of it including all of the internals which is stored on the
    CPU stack.  Because struct cpufreq_policy is relatively large, this
    may cause the size of the stack frame to exceed the 2 KB limit and
    so the GCC complains when -Wframe-larger-than= is used.
    
    In fact, it is not necessary to copy the entire policy structure
    in order to modify it, however.
    
    First, because cpufreq_set_policy() obtains the min and max policy
    limits from frequency QoS now, it is not necessary to pass the limits
    to it from the callers.  The only things that need to be passed to it
    from there are the new governor pointer or (if there is a built-in
    governor in the driver) the "policy" value representing the governor
    choice.  They both can be passed as individual arguments, though, so
    make cpufreq_set_policy() take them this way and rework its callers
    accordingly.  This avoids making copies of cpufreq policies in the
    callers of cpufreq_set_policy().
    
    Second, cpufreq_set_policy() still needs to pass the new policy
    data to the ->verify() callback of the cpufreq driver whose task
    is to sanitize the min and max policy limits.  It still does not
    need to make a full copy of struct cpufreq_policy for this purpose,
    but it needs to pass a few items from it to the driver in case they
    are needed (different drivers have different needs in that respect
    and all of them have to be covered).  For this reason, introduce
    struct cpufreq_policy_data to hold copies of the members of
    struct cpufreq_policy used by the existing ->verify() driver
    callbacks and pass a pointer to a temporary structure of that
    type to ->verify() (instead of passing a pointer to full struct
    cpufreq_policy to it).
    
    While at it, notice that intel_pstate and longrun don't really need
    to verify the "policy" value in struct cpufreq_policy, so drop those
    check from them to avoid copying "policy" into struct
    cpufreq_policy_data (which allows it to be slightly smaller).
    
    Also while at it fix up white space in a couple of places and make
    cpufreq_set_policy() static (as it can be so).
    
    Fixes: 3000ce3c52f8 ("cpufreq: Use per-policy frequency QoS")
    Link: https://lore.kernel.org/linux-pm/CAMuHMdX6-jb1W8uC2_237m8ctCpsnGp=JCxqt8pCWVqNXHmkVg@mail.gmail.com
    Reported-by: kbuild test robot <lkp@intel.com>
    Reported-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: 5.4+ <stable@vger.kernel.org> # 5.4+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>

commit c48b90f84a11ddcd6fee133c4929d8da037667ac
Merge: 62214039525a 46770be0cf94
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Nov 26 10:27:01 2019 +0100

    Merge branch 'pm-cpufreq'
    
    * pm-cpufreq: (23 commits)
      cpufreq: Register drivers only after CPU devices have been registered
      cpufreq: Add NULL checks to show() and store() methods of cpufreq
      cpufreq: intel_pstate: Fix plain int as pointer warning from sparse
      cpufreq: sun50i: Fix CPU speed bin detection
      cpufreq: powernv: fix stack bloat and hard limit on number of CPUs
      cpufreq: Clarify the comment in cpufreq_set_policy()
      cpufreq: vexpress-spc: find and skip duplicates when merging frequencies
      cpufreq: vexpress-spc: use macros instead of hardcoded values for cluster ids
      cpufreq: s3c64xx: Remove pointless NULL check in s3c64xx_cpufreq_driver_init
      cpufreq: imx-cpufreq-dt: Correct i.MX8MN's default speed grade value
      cpufreq: vexpress-spc: fix some coding style issues
      cpufreq: vexpress-spc: remove lots of debug messages
      cpufreq: vexpress-spc: drop unnessary cpufreq_arm_bL_ops abstraction
      cpufreq: merge arm_big_little and vexpress-spc
      cpufreq: scpi: remove stale/outdated comment about the driver
      ARM: dts: Add OPP-V2 table for AM3517
      cpufreq: ti-cpufreq: Add support for AM3517
      ARM: dts: omap36xx: using OPP1G needs to control the abb_ldo
      cpufreq: ti-cpufreq: omap36xx use "cpu0","vbb" if run in multi_regulator mode
      ARM: dts: omap3: bulk convert compatible to be explicitly ti,omap3430 or ti,omap3630 or ti,am3517
      ...

commit 737ffb27f2f1a8fe6644cac535486f7f25bbf6cb
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Oct 22 15:47:57 2019 +0530

    cpufreq: Clarify the comment in cpufreq_set_policy()
    
    One of the responsibility of the ->verify() callback is to make sure
    that the policy's min frequency is <= max frequency as this isn't
    guaranteed by the QoS framework which gave us those values.
    
    Update the comment in cpufreq_set_policy() to clarify that.
    
    Suggested-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    [ rjw: Minor changes of the new comment ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 6941051d3028963c3b0b3fcdd0815f2b51b957bb
Author: Sudeep Holla <sudeep.holla@arm.com>
Date:   Fri Oct 18 11:58:15 2019 +0100

    cpufreq: Cancel policy update work scheduled before freeing
    
    Scheduled policy update work may end up racing with the freeing of the
    policy and unregistering the driver.
    
    One possible race is as below, where the cpufreq_driver is unregistered,
    but the scheduled work gets executed at later stage when, cpufreq_driver
    is NULL (i.e. after freeing the policy and driver).
    
    Unable to handle kernel NULL pointer dereference at virtual address 0000001c
    pgd = (ptrval)
    [0000001c] *pgd=80000080204003, *pmd=00000000
    Internal error: Oops: 206 [#1] SMP THUMB2
    Modules linked in:
    CPU: 0 PID: 34 Comm: kworker/0:1 Not tainted 5.4.0-rc3-00006-g67f5a8081a4b #86
    Hardware name: ARM-Versatile Express
    Workqueue: events handle_update
    PC is at cpufreq_set_policy+0x58/0x228
    LR is at dev_pm_qos_read_value+0x77/0xac
    Control: 70c5387d  Table: 80203000  DAC: fffffffd
    Process kworker/0:1 (pid: 34, stack limit = 0x(ptrval))
            (cpufreq_set_policy) from (refresh_frequency_limits.part.24+0x37/0x48)
            (refresh_frequency_limits.part.24) from (handle_update+0x2f/0x38)
            (handle_update) from (process_one_work+0x16d/0x3cc)
            (process_one_work) from (worker_thread+0xff/0x414)
            (worker_thread) from (kthread+0xff/0x100)
            (kthread) from (ret_from_fork+0x11/0x28)
    
    Fixes: 67d874c3b2c6 ("cpufreq: Register notifiers with the PM QoS framework")
    Signed-off-by: Sudeep Holla <sudeep.holla@arm.com>
    [ rjw: Cancel the work before dropping the QoS requests ]
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit c57b25bdf7cd374af106992356536bf5df7c255b
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jul 4 13:06:22 2019 +0530

    cpufreq: intel_pstate: Reuse refresh_frequency_limits()
    
    The implementation of intel_pstate_update_max_freq() is quite similar to
    refresh_frequency_limits(), lets reuse it.
    
    Finding minimum of policy->user_policy.max and policy->cpuinfo.max_freq
    in intel_pstate_update_max_freq() is redundant as cpufreq_set_policy()
    will call the ->verify() callback of intel-pstate driver, which will do
    this comparison anyway and so dropping it from
    intel_pstate_update_max_freq() doesn't harm.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 67d874c3b2c69d65274fa5ce44ba939788d5729d
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon Jul 8 16:27:52 2019 +0530

    cpufreq: Register notifiers with the PM QoS framework
    
    Register notifiers for min/max frequency constraints with the PM QoS
    framework. The constraints are also taken into consideration in
    cpufreq_set_policy().
    
    This also relocates cpufreq_policy_put_kobj() as it is required to be
    called from cpufreq_policy_alloc() now.
    
    refresh_frequency_limits() is updated to avoid calling
    cpufreq_set_policy() for inactive policies and handle_update() is
    updated to have proper locking in place.
    
    No constraints are added until now though.
    
    Reviewed-by: Matthias Kaehlcke <mka@chromium.org>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Tested-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit ab05d97a3785088fa2964219227a1ba95d97d590
Author: Yue Hu <huyue2@yulong.com>
Date:   Mon Apr 29 15:24:18 2019 +0800

    cpufreq: Don't find governor for setpolicy drivers in cpufreq_init_policy()
    
    In cpufreq_init_policy() we will check if there's last_governor for target
    and setpolicy type. However last_governor is set only if has_target() is
    true in cpufreq_offline(). That means find last_governor for setpolicy
    type is pointless. Also new_policy.governor will not be used if ->setpolicy
    callback is set in cpufreq_set_policy().
    
    Moreover, there's duplicate ->setpolicy check in using default policy path.
    Let's add a new helper function to avoid it. Also update comments.
    
    Signed-off-by: Yue Hu <huyue2@yulong.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 9083e4986124389e2a7c0ffca95630a4983887f0
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Mar 26 12:19:52 2019 +0100

    cpufreq: intel_pstate: Update max frequency on global turbo changes
    
    While the cpuinfo.max_freq value doesn't really matter for
    intel_pstate in the active mode, in the passive mode it is used by
    governors as the maximum physical frequency of the CPU and the
    results of governor computations generally depend on it.  Also it
    is made available to user space via sysfs and it should match the
    current HW configuration.
    
    For this reason, make intel_pstate update cpuinfo.max_freq for all
    CPUs if it detects a global change of turbo frequency settings from
    "disable" to "enable" or the other way associated with a _PPC change
    notification from the platform firmware.
    
    Note that policy_is_inactive(),  cpufreq_cpu_acquire(),
    cpufreq_cpu_release(), and cpufreq_set_policy() need to be made
    available to it for this purpose.
    
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=200759
    Reported-by: Gabriele Mazzotta <gabriele.mzt@gmail.com>
    Tested-by: Gabriele Mazzotta <gabriele.mzt@gmail.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>

commit ef8006846a3a97d9d8bf49e63dba948d0d2dbbf0
Merge: 8dcd175bc3d5 1271d6d576b7
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Mar 6 12:59:46 2019 -0800

    Merge tag 'pm-5.1-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull power management updates from Rafael Wysocki:
     "These are PM-runtime framework changes to use ktime instead of jiffies
      for accounting, new PM core flag to mark devices that don't need any
      form of power management, cpuidle updates including driver API
      documentation and a new governor, cpufreq updates including a new
      driver for Armada 8K, thermal cleanups and more, some energy-aware
      scheduling (EAS) enabling changes, new chips support in the intel_idle
      and RAPL drivers and assorted cleanups in some other places.
    
      Specifics:
    
       - Update the PM-runtime framework to use ktime instead of jiffies for
         accounting (Thara Gopinath, Vincent Guittot)
    
       - Optimize the autosuspend code in the PM-runtime framework somewhat
         (Ladislav Michl)
    
       - Add a PM core flag to mark devices that don't need any form of
         power management (Sudeep Holla)
    
       - Introduce driver API documentation for cpuidle and add a new
         cpuidle governor for tickless systems (Rafael Wysocki)
    
       - Add Jacobsville support to the intel_idle driver (Zhang Rui)
    
       - Clean up a cpuidle core header file and the cpuidle-dt and ACPI
         processor-idle drivers (Yangtao Li, Joseph Lo, Yazen Ghannam)
    
       - Add new cpufreq driver for Armada 8K (Gregory Clement)
    
       - Fix and clean up cpufreq core (Rafael Wysocki, Viresh Kumar, Amit
         Kucheria)
    
       - Add support for light-weight tear-down and bring-up of CPUs to the
         cpufreq core and use it in the cpufreq-dt driver (Viresh Kumar)
    
       - Fix cpu_cooling Kconfig dependencies, add support for CPU cooling
         auto-registration to the cpufreq core and use it in multiple
         cpufreq drivers (Amit Kucheria)
    
       - Fix some minor issues and do some cleanups in the davinci,
         e_powersaver, ap806, s5pv210, qcom and kryo cpufreq drivers
         (Bartosz Golaszewski, Gustavo Silva, Julia Lawall, Pawe Chmiel,
         Taniya Das, Viresh Kumar)
    
       - Add a Hisilicon CPPC quirk to the cppc_cpufreq driver (Xiongfeng
         Wang)
    
       - Clean up the intel_pstate and acpi-cpufreq drivers (Erwan Velu,
         Rafael Wysocki)
    
       - Clean up multiple cpufreq drivers (Yangtao Li)
    
       - Update cpufreq-related MAINTAINERS entries (Baruch Siach, Lukas
         Bulwahn)
    
       - Add support for exposing the Energy Model via debugfs and make
         multiple cpufreq drivers register an Energy Model to support
         energy-aware scheduling (Quentin Perret, Dietmar Eggemann, Matthias
         Kaehlcke)
    
       - Add Ice Lake mobile and Jacobsville support to the Intel RAPL
         power-capping driver (Gayatri Kammela, Zhang Rui)
    
       - Add a power estimation helper to the operating performance points
         (OPP) framework and clean up a core function in it (Quentin Perret,
         Viresh Kumar)
    
       - Make minor improvements in the generic power domains (genpd), OPP
         and system suspend frameworks and in the PM core (Aditya Pakki,
         Douglas Anderson, Greg Kroah-Hartman, Rafael Wysocki, Yangtao Li)"
    
    * tag 'pm-5.1-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (80 commits)
      cpufreq: kryo: Release OPP tables on module removal
      cpufreq: ap806: add missing of_node_put after of_device_is_available
      cpufreq: acpi-cpufreq: Report if CPU doesn't support boost technologies
      cpufreq: Pass updated policy to driver ->setpolicy() callback
      cpufreq: Fix two debug messages in cpufreq_set_policy()
      cpufreq: Reorder and simplify cpufreq_update_policy()
      cpufreq: Add kerneldoc comments for two core functions
      PM / core: Add support to skip power management in device/driver model
      cpufreq: intel_pstate: Rework iowait boosting to be less aggressive
      cpufreq: intel_pstate: Eliminate intel_pstate_get_base_pstate()
      cpufreq: intel_pstate: Avoid redundant initialization of local vars
      powercap/intel_rapl: add Ice Lake mobile
      ACPI / processor: Set P_LVL{2,3} idle state descriptions
      cpufreq / cppc: Work around for Hisilicon CPPC cpufreq
      ACPI / CPPC: Add a helper to get desired performance
      cpufreq: davinci: move configuration to include/linux/platform_data
      cpufreq: speedstep: convert BUG() to BUG_ON()
      cpufreq: powernv: fix missing check of return value in init_powernv_pstates()
      cpufreq: longhaul: remove unneeded semicolon
      cpufreq: pcc-cpufreq: remove unneeded semicolon
      ..

commit 6a558c723ed17c588dd951cf158e4adf2c85bcee
Merge: 08a2e45ac025 185a23b6e773
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Mar 4 11:18:54 2019 +0100

    Merge branch 'pm-cpufreq'
    
    * pm-cpufreq: (48 commits)
      cpufreq: kryo: Release OPP tables on module removal
      cpufreq: ap806: add missing of_node_put after of_device_is_available
      cpufreq: acpi-cpufreq: Report if CPU doesn't support boost technologies
      cpufreq: Pass updated policy to driver ->setpolicy() callback
      cpufreq: Fix two debug messages in cpufreq_set_policy()
      cpufreq: Reorder and simplify cpufreq_update_policy()
      cpufreq: Add kerneldoc comments for two core functions
      cpufreq: intel_pstate: Rework iowait boosting to be less aggressive
      cpufreq: intel_pstate: Eliminate intel_pstate_get_base_pstate()
      cpufreq: intel_pstate: Avoid redundant initialization of local vars
      cpufreq / cppc: Work around for Hisilicon CPPC cpufreq
      ACPI / CPPC: Add a helper to get desired performance
      cpufreq: davinci: move configuration to include/linux/platform_data
      cpufreq: speedstep: convert BUG() to BUG_ON()
      cpufreq: powernv: fix missing check of return value in init_powernv_pstates()
      cpufreq: longhaul: remove unneeded semicolon
      cpufreq: pcc-cpufreq: remove unneeded semicolon
      cpufreq: Replace double NOT (!!) with single NOT (!)
      cpufreq: intel_pstate: Add reasons for failure and debug messages
      cpufreq: dt: Implement online/offline() callbacks
      ...

commit 167a38dcd5caaa85994ac8b7d2d1c20a71cd947b
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Feb 20 00:26:30 2019 +0100

    cpufreq: Pass updated policy to driver ->setpolicy() callback
    
    The invocation of the ->setpolicy() cpufreq driver callback should
    be equivalent to calling cpufreq_governor_limits(policy) for drivers
    with internal governors, but in fact it isn't so, because the
    temporary new_policy object is passed to it instead of the updated
    policy.
    
    That is a bit confusing, so make cpufreq_set_policy() pass the
    updated policy to the driver ->setpolicy() callback.
    
    No intentional changes of behavior.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>

commit 2bb4059e075dcb8d5a2f8689bb661aa76c487ab0
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Feb 20 00:25:18 2019 +0100

    cpufreq: Fix two debug messages in cpufreq_set_policy()
    
    Remove the redundant "cpufreq:" prefix from two debug messages in
    cpufreq_set_policy().
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>

commit 348a2ec5f5a5af15509252dfc6a30fa190ac0203
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Feb 20 00:24:25 2019 +0100

    cpufreq: Reorder and simplify cpufreq_update_policy()
    
    In cpufreq_update_policy(), instead of updating new_policy.cur
    separately, which is kind of confusing, because cpufreq_set_policy()
    doesn't take that value into account directly anyway, make the copy
    of the existing policy after calling cpufreq_update_current_freq().
    
    No intentional changes of behavior.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>

commit a0dbb819b84f87b3cb35083e264e9e584630e1f7
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Feb 20 00:22:51 2019 +0100

    cpufreq: Add kerneldoc comments for two core functions
    
    Add kerneldoc comments describing cpufreq_set_policy() and
    cpufreq_update_policy() as they have not been properly documented
    so far and they really need to be documented.
    
    While at it, fix white space around the cpufreq_set_policy() header.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>

commit 6f5edfa503fc5e9d142ca5865464f870a1c9622d
Author: Tao Wang <kevin.wangtao@hisilicon.com>
Date:   Sat May 26 15:16:48 2018 +0800

    cpufreq: Fix new policy initialization during limits updates via sysfs
    
    commit c7d1f119c48f64bebf0fa1e326af577c6152fe30 upstream.
    
    If the policy limits are updated via cpufreq_update_policy() and
    subsequently via sysfs, the limits stored in user_policy may be
    set incorrectly.
    
    For example, if both min and max are set via sysfs to the maximum
    available frequency, user_policy.min and user_policy.max will also
    be the maximum.  If a policy notifier triggered by
    cpufreq_update_policy() lowers both the min and the max at this
    point, that change is not reflected by the user_policy limits, so
    if the max is updated again via sysfs to the same lower value,
    then user_policy.max will be lower than user_policy.min which
    shouldn't happen.  In particular, if one of the policy CPUs is
    then taken offline and back online, cpufreq_set_policy() will
    fail for it due to a failing limits check.
    
    To prevent that from happening, initialize the min and max fields
    of the new_policy object to the ones stored in user_policy that
    were previously set via sysfs.
    
    Signed-off-by: Kevin Wangtao <kevin.wangtao@hisilicon.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    [ rjw: Subject & changelog ]
    Cc: All applicable <stable@vger.kernel.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 5930589d3f85484611a9084169c8e86a8c183284
Author: Tao Wang <kevin.wangtao@hisilicon.com>
Date:   Sat May 26 15:16:48 2018 +0800

    cpufreq: Fix new policy initialization during limits updates via sysfs
    
    commit c7d1f119c48f64bebf0fa1e326af577c6152fe30 upstream.
    
    If the policy limits are updated via cpufreq_update_policy() and
    subsequently via sysfs, the limits stored in user_policy may be
    set incorrectly.
    
    For example, if both min and max are set via sysfs to the maximum
    available frequency, user_policy.min and user_policy.max will also
    be the maximum.  If a policy notifier triggered by
    cpufreq_update_policy() lowers both the min and the max at this
    point, that change is not reflected by the user_policy limits, so
    if the max is updated again via sysfs to the same lower value,
    then user_policy.max will be lower than user_policy.min which
    shouldn't happen.  In particular, if one of the policy CPUs is
    then taken offline and back online, cpufreq_set_policy() will
    fail for it due to a failing limits check.
    
    To prevent that from happening, initialize the min and max fields
    of the new_policy object to the ones stored in user_policy that
    were previously set via sysfs.
    
    Signed-off-by: Kevin Wangtao <kevin.wangtao@hisilicon.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    [ rjw: Subject & changelog ]
    Cc: All applicable <stable@vger.kernel.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit c3c77b5db39350c8d64c85102138ab9ba6066815
Author: Tao Wang <kevin.wangtao@hisilicon.com>
Date:   Sat May 26 15:16:48 2018 +0800

    cpufreq: Fix new policy initialization during limits updates via sysfs
    
    commit c7d1f119c48f64bebf0fa1e326af577c6152fe30 upstream.
    
    If the policy limits are updated via cpufreq_update_policy() and
    subsequently via sysfs, the limits stored in user_policy may be
    set incorrectly.
    
    For example, if both min and max are set via sysfs to the maximum
    available frequency, user_policy.min and user_policy.max will also
    be the maximum.  If a policy notifier triggered by
    cpufreq_update_policy() lowers both the min and the max at this
    point, that change is not reflected by the user_policy limits, so
    if the max is updated again via sysfs to the same lower value,
    then user_policy.max will be lower than user_policy.min which
    shouldn't happen.  In particular, if one of the policy CPUs is
    then taken offline and back online, cpufreq_set_policy() will
    fail for it due to a failing limits check.
    
    To prevent that from happening, initialize the min and max fields
    of the new_policy object to the ones stored in user_policy that
    were previously set via sysfs.
    
    Signed-off-by: Kevin Wangtao <kevin.wangtao@hisilicon.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    [ rjw: Subject & changelog ]
    Cc: All applicable <stable@vger.kernel.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 52e91680cbd42fc2de610d6432fa28a47ab2d402
Author: Tao Wang <kevin.wangtao@hisilicon.com>
Date:   Sat May 26 15:16:48 2018 +0800

    cpufreq: Fix new policy initialization during limits updates via sysfs
    
    commit c7d1f119c48f64bebf0fa1e326af577c6152fe30 upstream.
    
    If the policy limits are updated via cpufreq_update_policy() and
    subsequently via sysfs, the limits stored in user_policy may be
    set incorrectly.
    
    For example, if both min and max are set via sysfs to the maximum
    available frequency, user_policy.min and user_policy.max will also
    be the maximum.  If a policy notifier triggered by
    cpufreq_update_policy() lowers both the min and the max at this
    point, that change is not reflected by the user_policy limits, so
    if the max is updated again via sysfs to the same lower value,
    then user_policy.max will be lower than user_policy.min which
    shouldn't happen.  In particular, if one of the policy CPUs is
    then taken offline and back online, cpufreq_set_policy() will
    fail for it due to a failing limits check.
    
    To prevent that from happening, initialize the min and max fields
    of the new_policy object to the ones stored in user_policy that
    were previously set via sysfs.
    
    Signed-off-by: Kevin Wangtao <kevin.wangtao@hisilicon.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    [ rjw: Subject & changelog ]
    Cc: All applicable <stable@vger.kernel.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 2243ed28c96f284c3fde9858d5c4c8a7dfc59f84
Author: Tao Wang <kevin.wangtao@hisilicon.com>
Date:   Sat May 26 15:16:48 2018 +0800

    cpufreq: Fix new policy initialization during limits updates via sysfs
    
    commit c7d1f119c48f64bebf0fa1e326af577c6152fe30 upstream.
    
    If the policy limits are updated via cpufreq_update_policy() and
    subsequently via sysfs, the limits stored in user_policy may be
    set incorrectly.
    
    For example, if both min and max are set via sysfs to the maximum
    available frequency, user_policy.min and user_policy.max will also
    be the maximum.  If a policy notifier triggered by
    cpufreq_update_policy() lowers both the min and the max at this
    point, that change is not reflected by the user_policy limits, so
    if the max is updated again via sysfs to the same lower value,
    then user_policy.max will be lower than user_policy.min which
    shouldn't happen.  In particular, if one of the policy CPUs is
    then taken offline and back online, cpufreq_set_policy() will
    fail for it due to a failing limits check.
    
    To prevent that from happening, initialize the min and max fields
    of the new_policy object to the ones stored in user_policy that
    were previously set via sysfs.
    
    Signed-off-by: Kevin Wangtao <kevin.wangtao@hisilicon.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    [ rjw: Subject & changelog ]
    Cc: All applicable <stable@vger.kernel.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit c7d1f119c48f64bebf0fa1e326af577c6152fe30
Author: Tao Wang <kevin.wangtao@hisilicon.com>
Date:   Sat May 26 15:16:48 2018 +0800

    cpufreq: Fix new policy initialization during limits updates via sysfs
    
    If the policy limits are updated via cpufreq_update_policy() and
    subsequently via sysfs, the limits stored in user_policy may be
    set incorrectly.
    
    For example, if both min and max are set via sysfs to the maximum
    available frequency, user_policy.min and user_policy.max will also
    be the maximum.  If a policy notifier triggered by
    cpufreq_update_policy() lowers both the min and the max at this
    point, that change is not reflected by the user_policy limits, so
    if the max is updated again via sysfs to the same lower value,
    then user_policy.max will be lower than user_policy.min which
    shouldn't happen.  In particular, if one of the policy CPUs is
    then taken offline and back online, cpufreq_set_policy() will
    fail for it due to a failing limits check.
    
    To prevent that from happening, initialize the min and max fields
    of the new_policy object to the ones stored in user_policy that
    were previously set via sysfs.
    
    Signed-off-by: Kevin Wangtao <kevin.wangtao@hisilicon.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    [ rjw: Subject & changelog ]
    Cc: All applicable <stable@vger.kernel.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 9a18bac19cdc52d082c362b694d37a1b7ddd4d81
Author: Chen Yu <yu.c.chen@intel.com>
Date:   Mon Jan 29 10:26:46 2018 +0800

    ACPI: processor_perflib: Do not send _PPC change notification if not ready
    
    [ Upstream commit ba1edb9a5125a617d612f98eead14b9b84e75c3a ]
    
    The following warning was triggered after resumed from S3 -
    if all the nonboot CPUs were put offline before suspend:
    
    [ 1840.329515] unchecked MSR access error: RDMSR from 0x771 at rIP: 0xffffffff86061e3a (native_read_msr+0xa/0x30)
    [ 1840.329516] Call Trace:
    [ 1840.329521]  __rdmsr_on_cpu+0x33/0x50
    [ 1840.329525]  generic_exec_single+0x81/0xb0
    [ 1840.329527]  smp_call_function_single+0xd2/0x100
    [ 1840.329530]  ? acpi_ds_result_pop+0xdd/0xf2
    [ 1840.329532]  ? acpi_ds_create_operand+0x215/0x23c
    [ 1840.329534]  rdmsrl_on_cpu+0x57/0x80
    [ 1840.329536]  ? cpumask_next+0x1b/0x20
    [ 1840.329538]  ? rdmsrl_on_cpu+0x57/0x80
    [ 1840.329541]  intel_pstate_update_perf_limits+0xf3/0x220
    [ 1840.329544]  ? notifier_call_chain+0x4a/0x70
    [ 1840.329546]  intel_pstate_set_policy+0x4e/0x150
    [ 1840.329548]  cpufreq_set_policy+0xcd/0x2f0
    [ 1840.329550]  cpufreq_update_policy+0xb2/0x130
    [ 1840.329552]  ? cpufreq_update_policy+0x130/0x130
    [ 1840.329556]  acpi_processor_ppc_has_changed+0x65/0x80
    [ 1840.329558]  acpi_processor_notify+0x80/0x100
    [ 1840.329561]  acpi_ev_notify_dispatch+0x44/0x5c
    [ 1840.329563]  acpi_os_execute_deferred+0x14/0x20
    [ 1840.329565]  process_one_work+0x193/0x3c0
    [ 1840.329567]  worker_thread+0x35/0x3b0
    [ 1840.329569]  kthread+0x125/0x140
    [ 1840.329571]  ? process_one_work+0x3c0/0x3c0
    [ 1840.329572]  ? kthread_park+0x60/0x60
    [ 1840.329575]  ? do_syscall_64+0x67/0x180
    [ 1840.329577]  ret_from_fork+0x25/0x30
    [ 1840.329585] unchecked MSR access error: WRMSR to 0x774 (tried to write 0x0000000000000000) at rIP: 0xffffffff86061f78 (native_write_msr+0x8/0x30)
    [ 1840.329586] Call Trace:
    [ 1840.329587]  __wrmsr_on_cpu+0x37/0x40
    [ 1840.329589]  generic_exec_single+0x81/0xb0
    [ 1840.329592]  smp_call_function_single+0xd2/0x100
    [ 1840.329594]  ? acpi_ds_create_operand+0x215/0x23c
    [ 1840.329595]  ? cpumask_next+0x1b/0x20
    [ 1840.329597]  wrmsrl_on_cpu+0x57/0x70
    [ 1840.329598]  ? rdmsrl_on_cpu+0x57/0x80
    [ 1840.329599]  ? wrmsrl_on_cpu+0x57/0x70
    [ 1840.329602]  intel_pstate_hwp_set+0xd3/0x150
    [ 1840.329604]  intel_pstate_set_policy+0x119/0x150
    [ 1840.329606]  cpufreq_set_policy+0xcd/0x2f0
    [ 1840.329607]  cpufreq_update_policy+0xb2/0x130
    [ 1840.329610]  ? cpufreq_update_policy+0x130/0x130
    [ 1840.329613]  acpi_processor_ppc_has_changed+0x65/0x80
    [ 1840.329615]  acpi_processor_notify+0x80/0x100
    [ 1840.329617]  acpi_ev_notify_dispatch+0x44/0x5c
    [ 1840.329619]  acpi_os_execute_deferred+0x14/0x20
    [ 1840.329620]  process_one_work+0x193/0x3c0
    [ 1840.329622]  worker_thread+0x35/0x3b0
    [ 1840.329624]  kthread+0x125/0x140
    [ 1840.329625]  ? process_one_work+0x3c0/0x3c0
    [ 1840.329626]  ? kthread_park+0x60/0x60
    [ 1840.329628]  ? do_syscall_64+0x67/0x180
    [ 1840.329631]  ret_from_fork+0x25/0x30
    
    This is because if there's only one online CPU, the MSR_PM_ENABLE
    (package wide)can not be enabled after resumed, due to
    intel_pstate_hwp_enable() will only be invoked on AP's online
    process after resumed - if there's no AP online, the HWP remains
    disabled after resumed (BIOS has disabled it in S3). Then if
    there comes a _PPC change notification which touches HWP register
    during this stage, the warning is triggered.
    
    Since we don't call acpi_processor_register_performance() when
    HWP is enabled, the pr->performance will be NULL. When this is
    NULL we don't need to do _PPC change notification.
    
    Reported-by: Doug Smythies <dsmythies@telus.net>
    Suggested-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Yu Chen <yu.c.chen@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Sasha Levin <alexander.levin@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 0194705a7be9daa82095f0580190566c5af187c3
Author: Chen Yu <yu.c.chen@intel.com>
Date:   Mon Jan 29 10:26:46 2018 +0800

    ACPI: processor_perflib: Do not send _PPC change notification if not ready
    
    [ Upstream commit ba1edb9a5125a617d612f98eead14b9b84e75c3a ]
    
    The following warning was triggered after resumed from S3 -
    if all the nonboot CPUs were put offline before suspend:
    
    [ 1840.329515] unchecked MSR access error: RDMSR from 0x771 at rIP: 0xffffffff86061e3a (native_read_msr+0xa/0x30)
    [ 1840.329516] Call Trace:
    [ 1840.329521]  __rdmsr_on_cpu+0x33/0x50
    [ 1840.329525]  generic_exec_single+0x81/0xb0
    [ 1840.329527]  smp_call_function_single+0xd2/0x100
    [ 1840.329530]  ? acpi_ds_result_pop+0xdd/0xf2
    [ 1840.329532]  ? acpi_ds_create_operand+0x215/0x23c
    [ 1840.329534]  rdmsrl_on_cpu+0x57/0x80
    [ 1840.329536]  ? cpumask_next+0x1b/0x20
    [ 1840.329538]  ? rdmsrl_on_cpu+0x57/0x80
    [ 1840.329541]  intel_pstate_update_perf_limits+0xf3/0x220
    [ 1840.329544]  ? notifier_call_chain+0x4a/0x70
    [ 1840.329546]  intel_pstate_set_policy+0x4e/0x150
    [ 1840.329548]  cpufreq_set_policy+0xcd/0x2f0
    [ 1840.329550]  cpufreq_update_policy+0xb2/0x130
    [ 1840.329552]  ? cpufreq_update_policy+0x130/0x130
    [ 1840.329556]  acpi_processor_ppc_has_changed+0x65/0x80
    [ 1840.329558]  acpi_processor_notify+0x80/0x100
    [ 1840.329561]  acpi_ev_notify_dispatch+0x44/0x5c
    [ 1840.329563]  acpi_os_execute_deferred+0x14/0x20
    [ 1840.329565]  process_one_work+0x193/0x3c0
    [ 1840.329567]  worker_thread+0x35/0x3b0
    [ 1840.329569]  kthread+0x125/0x140
    [ 1840.329571]  ? process_one_work+0x3c0/0x3c0
    [ 1840.329572]  ? kthread_park+0x60/0x60
    [ 1840.329575]  ? do_syscall_64+0x67/0x180
    [ 1840.329577]  ret_from_fork+0x25/0x30
    [ 1840.329585] unchecked MSR access error: WRMSR to 0x774 (tried to write 0x0000000000000000) at rIP: 0xffffffff86061f78 (native_write_msr+0x8/0x30)
    [ 1840.329586] Call Trace:
    [ 1840.329587]  __wrmsr_on_cpu+0x37/0x40
    [ 1840.329589]  generic_exec_single+0x81/0xb0
    [ 1840.329592]  smp_call_function_single+0xd2/0x100
    [ 1840.329594]  ? acpi_ds_create_operand+0x215/0x23c
    [ 1840.329595]  ? cpumask_next+0x1b/0x20
    [ 1840.329597]  wrmsrl_on_cpu+0x57/0x70
    [ 1840.329598]  ? rdmsrl_on_cpu+0x57/0x80
    [ 1840.329599]  ? wrmsrl_on_cpu+0x57/0x70
    [ 1840.329602]  intel_pstate_hwp_set+0xd3/0x150
    [ 1840.329604]  intel_pstate_set_policy+0x119/0x150
    [ 1840.329606]  cpufreq_set_policy+0xcd/0x2f0
    [ 1840.329607]  cpufreq_update_policy+0xb2/0x130
    [ 1840.329610]  ? cpufreq_update_policy+0x130/0x130
    [ 1840.329613]  acpi_processor_ppc_has_changed+0x65/0x80
    [ 1840.329615]  acpi_processor_notify+0x80/0x100
    [ 1840.329617]  acpi_ev_notify_dispatch+0x44/0x5c
    [ 1840.329619]  acpi_os_execute_deferred+0x14/0x20
    [ 1840.329620]  process_one_work+0x193/0x3c0
    [ 1840.329622]  worker_thread+0x35/0x3b0
    [ 1840.329624]  kthread+0x125/0x140
    [ 1840.329625]  ? process_one_work+0x3c0/0x3c0
    [ 1840.329626]  ? kthread_park+0x60/0x60
    [ 1840.329628]  ? do_syscall_64+0x67/0x180
    [ 1840.329631]  ret_from_fork+0x25/0x30
    
    This is because if there's only one online CPU, the MSR_PM_ENABLE
    (package wide)can not be enabled after resumed, due to
    intel_pstate_hwp_enable() will only be invoked on AP's online
    process after resumed - if there's no AP online, the HWP remains
    disabled after resumed (BIOS has disabled it in S3). Then if
    there comes a _PPC change notification which touches HWP register
    during this stage, the warning is triggered.
    
    Since we don't call acpi_processor_register_performance() when
    HWP is enabled, the pr->performance will be NULL. When this is
    NULL we don't need to do _PPC change notification.
    
    Reported-by: Doug Smythies <dsmythies@telus.net>
    Suggested-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Yu Chen <yu.c.chen@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Sasha Levin <alexander.levin@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 4c53640915f20c4372239348d89d4338b55da2f4
Author: Chen Yu <yu.c.chen@intel.com>
Date:   Mon Jan 29 10:26:46 2018 +0800

    ACPI: processor_perflib: Do not send _PPC change notification if not ready
    
    [ Upstream commit ba1edb9a5125a617d612f98eead14b9b84e75c3a ]
    
    The following warning was triggered after resumed from S3 -
    if all the nonboot CPUs were put offline before suspend:
    
    [ 1840.329515] unchecked MSR access error: RDMSR from 0x771 at rIP: 0xffffffff86061e3a (native_read_msr+0xa/0x30)
    [ 1840.329516] Call Trace:
    [ 1840.329521]  __rdmsr_on_cpu+0x33/0x50
    [ 1840.329525]  generic_exec_single+0x81/0xb0
    [ 1840.329527]  smp_call_function_single+0xd2/0x100
    [ 1840.329530]  ? acpi_ds_result_pop+0xdd/0xf2
    [ 1840.329532]  ? acpi_ds_create_operand+0x215/0x23c
    [ 1840.329534]  rdmsrl_on_cpu+0x57/0x80
    [ 1840.329536]  ? cpumask_next+0x1b/0x20
    [ 1840.329538]  ? rdmsrl_on_cpu+0x57/0x80
    [ 1840.329541]  intel_pstate_update_perf_limits+0xf3/0x220
    [ 1840.329544]  ? notifier_call_chain+0x4a/0x70
    [ 1840.329546]  intel_pstate_set_policy+0x4e/0x150
    [ 1840.329548]  cpufreq_set_policy+0xcd/0x2f0
    [ 1840.329550]  cpufreq_update_policy+0xb2/0x130
    [ 1840.329552]  ? cpufreq_update_policy+0x130/0x130
    [ 1840.329556]  acpi_processor_ppc_has_changed+0x65/0x80
    [ 1840.329558]  acpi_processor_notify+0x80/0x100
    [ 1840.329561]  acpi_ev_notify_dispatch+0x44/0x5c
    [ 1840.329563]  acpi_os_execute_deferred+0x14/0x20
    [ 1840.329565]  process_one_work+0x193/0x3c0
    [ 1840.329567]  worker_thread+0x35/0x3b0
    [ 1840.329569]  kthread+0x125/0x140
    [ 1840.329571]  ? process_one_work+0x3c0/0x3c0
    [ 1840.329572]  ? kthread_park+0x60/0x60
    [ 1840.329575]  ? do_syscall_64+0x67/0x180
    [ 1840.329577]  ret_from_fork+0x25/0x30
    [ 1840.329585] unchecked MSR access error: WRMSR to 0x774 (tried to write 0x0000000000000000) at rIP: 0xffffffff86061f78 (native_write_msr+0x8/0x30)
    [ 1840.329586] Call Trace:
    [ 1840.329587]  __wrmsr_on_cpu+0x37/0x40
    [ 1840.329589]  generic_exec_single+0x81/0xb0
    [ 1840.329592]  smp_call_function_single+0xd2/0x100
    [ 1840.329594]  ? acpi_ds_create_operand+0x215/0x23c
    [ 1840.329595]  ? cpumask_next+0x1b/0x20
    [ 1840.329597]  wrmsrl_on_cpu+0x57/0x70
    [ 1840.329598]  ? rdmsrl_on_cpu+0x57/0x80
    [ 1840.329599]  ? wrmsrl_on_cpu+0x57/0x70
    [ 1840.329602]  intel_pstate_hwp_set+0xd3/0x150
    [ 1840.329604]  intel_pstate_set_policy+0x119/0x150
    [ 1840.329606]  cpufreq_set_policy+0xcd/0x2f0
    [ 1840.329607]  cpufreq_update_policy+0xb2/0x130
    [ 1840.329610]  ? cpufreq_update_policy+0x130/0x130
    [ 1840.329613]  acpi_processor_ppc_has_changed+0x65/0x80
    [ 1840.329615]  acpi_processor_notify+0x80/0x100
    [ 1840.329617]  acpi_ev_notify_dispatch+0x44/0x5c
    [ 1840.329619]  acpi_os_execute_deferred+0x14/0x20
    [ 1840.329620]  process_one_work+0x193/0x3c0
    [ 1840.329622]  worker_thread+0x35/0x3b0
    [ 1840.329624]  kthread+0x125/0x140
    [ 1840.329625]  ? process_one_work+0x3c0/0x3c0
    [ 1840.329626]  ? kthread_park+0x60/0x60
    [ 1840.329628]  ? do_syscall_64+0x67/0x180
    [ 1840.329631]  ret_from_fork+0x25/0x30
    
    This is because if there's only one online CPU, the MSR_PM_ENABLE
    (package wide)can not be enabled after resumed, due to
    intel_pstate_hwp_enable() will only be invoked on AP's online
    process after resumed - if there's no AP online, the HWP remains
    disabled after resumed (BIOS has disabled it in S3). Then if
    there comes a _PPC change notification which touches HWP register
    during this stage, the warning is triggered.
    
    Since we don't call acpi_processor_register_performance() when
    HWP is enabled, the pr->performance will be NULL. When this is
    NULL we don't need to do _PPC change notification.
    
    Reported-by: Doug Smythies <dsmythies@telus.net>
    Suggested-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Yu Chen <yu.c.chen@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Sasha Levin <alexander.levin@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 51939996acde4bce855f70a32544aaf44f8e3f0a
Author: Chen Yu <yu.c.chen@intel.com>
Date:   Mon Jan 29 10:26:46 2018 +0800

    ACPI: processor_perflib: Do not send _PPC change notification if not ready
    
    
    [ Upstream commit ba1edb9a5125a617d612f98eead14b9b84e75c3a ]
    
    The following warning was triggered after resumed from S3 -
    if all the nonboot CPUs were put offline before suspend:
    
    [ 1840.329515] unchecked MSR access error: RDMSR from 0x771 at rIP: 0xffffffff86061e3a (native_read_msr+0xa/0x30)
    [ 1840.329516] Call Trace:
    [ 1840.329521]  __rdmsr_on_cpu+0x33/0x50
    [ 1840.329525]  generic_exec_single+0x81/0xb0
    [ 1840.329527]  smp_call_function_single+0xd2/0x100
    [ 1840.329530]  ? acpi_ds_result_pop+0xdd/0xf2
    [ 1840.329532]  ? acpi_ds_create_operand+0x215/0x23c
    [ 1840.329534]  rdmsrl_on_cpu+0x57/0x80
    [ 1840.329536]  ? cpumask_next+0x1b/0x20
    [ 1840.329538]  ? rdmsrl_on_cpu+0x57/0x80
    [ 1840.329541]  intel_pstate_update_perf_limits+0xf3/0x220
    [ 1840.329544]  ? notifier_call_chain+0x4a/0x70
    [ 1840.329546]  intel_pstate_set_policy+0x4e/0x150
    [ 1840.329548]  cpufreq_set_policy+0xcd/0x2f0
    [ 1840.329550]  cpufreq_update_policy+0xb2/0x130
    [ 1840.329552]  ? cpufreq_update_policy+0x130/0x130
    [ 1840.329556]  acpi_processor_ppc_has_changed+0x65/0x80
    [ 1840.329558]  acpi_processor_notify+0x80/0x100
    [ 1840.329561]  acpi_ev_notify_dispatch+0x44/0x5c
    [ 1840.329563]  acpi_os_execute_deferred+0x14/0x20
    [ 1840.329565]  process_one_work+0x193/0x3c0
    [ 1840.329567]  worker_thread+0x35/0x3b0
    [ 1840.329569]  kthread+0x125/0x140
    [ 1840.329571]  ? process_one_work+0x3c0/0x3c0
    [ 1840.329572]  ? kthread_park+0x60/0x60
    [ 1840.329575]  ? do_syscall_64+0x67/0x180
    [ 1840.329577]  ret_from_fork+0x25/0x30
    [ 1840.329585] unchecked MSR access error: WRMSR to 0x774 (tried to write 0x0000000000000000) at rIP: 0xffffffff86061f78 (native_write_msr+0x8/0x30)
    [ 1840.329586] Call Trace:
    [ 1840.329587]  __wrmsr_on_cpu+0x37/0x40
    [ 1840.329589]  generic_exec_single+0x81/0xb0
    [ 1840.329592]  smp_call_function_single+0xd2/0x100
    [ 1840.329594]  ? acpi_ds_create_operand+0x215/0x23c
    [ 1840.329595]  ? cpumask_next+0x1b/0x20
    [ 1840.329597]  wrmsrl_on_cpu+0x57/0x70
    [ 1840.329598]  ? rdmsrl_on_cpu+0x57/0x80
    [ 1840.329599]  ? wrmsrl_on_cpu+0x57/0x70
    [ 1840.329602]  intel_pstate_hwp_set+0xd3/0x150
    [ 1840.329604]  intel_pstate_set_policy+0x119/0x150
    [ 1840.329606]  cpufreq_set_policy+0xcd/0x2f0
    [ 1840.329607]  cpufreq_update_policy+0xb2/0x130
    [ 1840.329610]  ? cpufreq_update_policy+0x130/0x130
    [ 1840.329613]  acpi_processor_ppc_has_changed+0x65/0x80
    [ 1840.329615]  acpi_processor_notify+0x80/0x100
    [ 1840.329617]  acpi_ev_notify_dispatch+0x44/0x5c
    [ 1840.329619]  acpi_os_execute_deferred+0x14/0x20
    [ 1840.329620]  process_one_work+0x193/0x3c0
    [ 1840.329622]  worker_thread+0x35/0x3b0
    [ 1840.329624]  kthread+0x125/0x140
    [ 1840.329625]  ? process_one_work+0x3c0/0x3c0
    [ 1840.329626]  ? kthread_park+0x60/0x60
    [ 1840.329628]  ? do_syscall_64+0x67/0x180
    [ 1840.329631]  ret_from_fork+0x25/0x30
    
    This is because if there's only one online CPU, the MSR_PM_ENABLE
    (package wide)can not be enabled after resumed, due to
    intel_pstate_hwp_enable() will only be invoked on AP's online
    process after resumed - if there's no AP online, the HWP remains
    disabled after resumed (BIOS has disabled it in S3). Then if
    there comes a _PPC change notification which touches HWP register
    during this stage, the warning is triggered.
    
    Since we don't call acpi_processor_register_performance() when
    HWP is enabled, the pr->performance will be NULL. When this is
    NULL we don't need to do _PPC change notification.
    
    Reported-by: Doug Smythies <dsmythies@telus.net>
    Suggested-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Yu Chen <yu.c.chen@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Sasha Levin <alexander.levin@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 3f7dfb7fcf98a7e73dee018c4a68537ce7fec646
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Nov 23 14:27:07 2017 +0100

    cpufreq: Fix governor module removal race
    
    
    [ Upstream commit a8b149d32b663c1a4105273295184b78f53d33cf ]
    
    It is possible to remove a cpufreq governor module after
    cpufreq_parse_governor() has returned success in
    store_scaling_governor() and before cpufreq_set_policy()
    acquires a reference to it, because the governor list is
    not protected during that period and nothing prevents the
    governor from being unregistered then.
    
    Prevent that from happening by acquiring an extra reference
    to the governor module temporarily in cpufreq_parse_governor(),
    under cpufreq_governor_mutex, and dropping it in
    store_scaling_governor(), when cpufreq_set_policy() returns.
    
    Note that the second cpufreq_parse_governor() call site is fine,
    because it only cares about the policy member of new_policy.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Sasha Levin <alexander.levin@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit a853301f77b5c4feb5e17aebfd92018269525523
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Nov 23 14:27:07 2017 +0100

    cpufreq: Fix governor module removal race
    
    
    [ Upstream commit a8b149d32b663c1a4105273295184b78f53d33cf ]
    
    It is possible to remove a cpufreq governor module after
    cpufreq_parse_governor() has returned success in
    store_scaling_governor() and before cpufreq_set_policy()
    acquires a reference to it, because the governor list is
    not protected during that period and nothing prevents the
    governor from being unregistered then.
    
    Prevent that from happening by acquiring an extra reference
    to the governor module temporarily in cpufreq_parse_governor(),
    under cpufreq_governor_mutex, and dropping it in
    store_scaling_governor(), when cpufreq_set_policy() returns.
    
    Note that the second cpufreq_parse_governor() call site is fine,
    because it only cares about the policy member of new_policy.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Sasha Levin <alexander.levin@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 0049457bfde661cf47410eaacad65845c9a2bb45
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Nov 23 14:27:07 2017 +0100

    cpufreq: Fix governor module removal race
    
    
    [ Upstream commit a8b149d32b663c1a4105273295184b78f53d33cf ]
    
    It is possible to remove a cpufreq governor module after
    cpufreq_parse_governor() has returned success in
    store_scaling_governor() and before cpufreq_set_policy()
    acquires a reference to it, because the governor list is
    not protected during that period and nothing prevents the
    governor from being unregistered then.
    
    Prevent that from happening by acquiring an extra reference
    to the governor module temporarily in cpufreq_parse_governor(),
    under cpufreq_governor_mutex, and dropping it in
    store_scaling_governor(), when cpufreq_set_policy() returns.
    
    Note that the second cpufreq_parse_governor() call site is fine,
    because it only cares about the policy member of new_policy.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Sasha Levin <alexander.levin@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit ba1edb9a5125a617d612f98eead14b9b84e75c3a
Author: Chen Yu <yu.c.chen@intel.com>
Date:   Mon Jan 29 10:26:46 2018 +0800

    ACPI: processor_perflib: Do not send _PPC change notification if not ready
    
    The following warning was triggered after resumed from S3 -
    if all the nonboot CPUs were put offline before suspend:
    
    [ 1840.329515] unchecked MSR access error: RDMSR from 0x771 at rIP: 0xffffffff86061e3a (native_read_msr+0xa/0x30)
    [ 1840.329516] Call Trace:
    [ 1840.329521]  __rdmsr_on_cpu+0x33/0x50
    [ 1840.329525]  generic_exec_single+0x81/0xb0
    [ 1840.329527]  smp_call_function_single+0xd2/0x100
    [ 1840.329530]  ? acpi_ds_result_pop+0xdd/0xf2
    [ 1840.329532]  ? acpi_ds_create_operand+0x215/0x23c
    [ 1840.329534]  rdmsrl_on_cpu+0x57/0x80
    [ 1840.329536]  ? cpumask_next+0x1b/0x20
    [ 1840.329538]  ? rdmsrl_on_cpu+0x57/0x80
    [ 1840.329541]  intel_pstate_update_perf_limits+0xf3/0x220
    [ 1840.329544]  ? notifier_call_chain+0x4a/0x70
    [ 1840.329546]  intel_pstate_set_policy+0x4e/0x150
    [ 1840.329548]  cpufreq_set_policy+0xcd/0x2f0
    [ 1840.329550]  cpufreq_update_policy+0xb2/0x130
    [ 1840.329552]  ? cpufreq_update_policy+0x130/0x130
    [ 1840.329556]  acpi_processor_ppc_has_changed+0x65/0x80
    [ 1840.329558]  acpi_processor_notify+0x80/0x100
    [ 1840.329561]  acpi_ev_notify_dispatch+0x44/0x5c
    [ 1840.329563]  acpi_os_execute_deferred+0x14/0x20
    [ 1840.329565]  process_one_work+0x193/0x3c0
    [ 1840.329567]  worker_thread+0x35/0x3b0
    [ 1840.329569]  kthread+0x125/0x140
    [ 1840.329571]  ? process_one_work+0x3c0/0x3c0
    [ 1840.329572]  ? kthread_park+0x60/0x60
    [ 1840.329575]  ? do_syscall_64+0x67/0x180
    [ 1840.329577]  ret_from_fork+0x25/0x30
    [ 1840.329585] unchecked MSR access error: WRMSR to 0x774 (tried to write 0x0000000000000000) at rIP: 0xffffffff86061f78 (native_write_msr+0x8/0x30)
    [ 1840.329586] Call Trace:
    [ 1840.329587]  __wrmsr_on_cpu+0x37/0x40
    [ 1840.329589]  generic_exec_single+0x81/0xb0
    [ 1840.329592]  smp_call_function_single+0xd2/0x100
    [ 1840.329594]  ? acpi_ds_create_operand+0x215/0x23c
    [ 1840.329595]  ? cpumask_next+0x1b/0x20
    [ 1840.329597]  wrmsrl_on_cpu+0x57/0x70
    [ 1840.329598]  ? rdmsrl_on_cpu+0x57/0x80
    [ 1840.329599]  ? wrmsrl_on_cpu+0x57/0x70
    [ 1840.329602]  intel_pstate_hwp_set+0xd3/0x150
    [ 1840.329604]  intel_pstate_set_policy+0x119/0x150
    [ 1840.329606]  cpufreq_set_policy+0xcd/0x2f0
    [ 1840.329607]  cpufreq_update_policy+0xb2/0x130
    [ 1840.329610]  ? cpufreq_update_policy+0x130/0x130
    [ 1840.329613]  acpi_processor_ppc_has_changed+0x65/0x80
    [ 1840.329615]  acpi_processor_notify+0x80/0x100
    [ 1840.329617]  acpi_ev_notify_dispatch+0x44/0x5c
    [ 1840.329619]  acpi_os_execute_deferred+0x14/0x20
    [ 1840.329620]  process_one_work+0x193/0x3c0
    [ 1840.329622]  worker_thread+0x35/0x3b0
    [ 1840.329624]  kthread+0x125/0x140
    [ 1840.329625]  ? process_one_work+0x3c0/0x3c0
    [ 1840.329626]  ? kthread_park+0x60/0x60
    [ 1840.329628]  ? do_syscall_64+0x67/0x180
    [ 1840.329631]  ret_from_fork+0x25/0x30
    
    This is because if there's only one online CPU, the MSR_PM_ENABLE
    (package wide)can not be enabled after resumed, due to
    intel_pstate_hwp_enable() will only be invoked on AP's online
    process after resumed - if there's no AP online, the HWP remains
    disabled after resumed (BIOS has disabled it in S3). Then if
    there comes a _PPC change notification which touches HWP register
    during this stage, the warning is triggered.
    
    Since we don't call acpi_processor_register_performance() when
    HWP is enabled, the pr->performance will be NULL. When this is
    NULL we don't need to do _PPC change notification.
    
    Reported-by: Doug Smythies <dsmythies@telus.net>
    Suggested-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Yu Chen <yu.c.chen@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit a8b149d32b663c1a4105273295184b78f53d33cf
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Nov 23 14:27:07 2017 +0100

    cpufreq: Fix governor module removal race
    
    It is possible to remove a cpufreq governor module after
    cpufreq_parse_governor() has returned success in
    store_scaling_governor() and before cpufreq_set_policy()
    acquires a reference to it, because the governor list is
    not protected during that period and nothing prevents the
    governor from being unregistered then.
    
    Prevent that from happening by acquiring an extra reference
    to the governor module temporarily in cpufreq_parse_governor(),
    under cpufreq_governor_mutex, and dropping it in
    store_scaling_governor(), when cpufreq_set_policy() returns.
    
    Note that the second cpufreq_parse_governor() call site is fine,
    because it only cares about the policy member of new_policy.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 80b120ca1a75c2df093d15936ab0591d90c99de9
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Mar 23 00:00:47 2017 +0100

    cpufreq: intel_pstate: Avoid transient updates of cpuinfo.max_freq
    
    Both intel_pstate_verify_policy() and intel_cpufreq_verify_policy()
    set policy->cpuinfo.max_freq depending on the turbo status, but the
    updates made by them are discarded by the core, because the policy
    object passed to them by the core is temporary and cpuinfo.max_freq
    from that object is not copied to the final policy object in
    cpufreq_set_policy().
    
    However, cpufreq_set_policy() passes the temporary policy object
    to the ->setpolicy callback of the driver, so intel_pstate_set_policy()
    actually sees the policy->cpuinfo.max_freq value updated by
    intel_pstate_verify_policy() and not the final one.  It also
    updates policy->max sometimes which basically has no effect after
    it returns, because the core discards that update.
    
    To avoid confusion, eliminate policy->cpuinfo.max_freq updates from
    intel_pstate_verify_policy() and intel_cpufreq_verify_policy()
    entirely and check the maximum frequency explicitly in
    intel_pstate_update_perf_limits() instead of relying on the
    transiently updated policy->cpuinfo.max_freq value.
    
    Moreover, move the max->policy adjustment carried out in
    intel_pstate_set_policy() to a separate function and call that
    function from the ->verify driver callbacks to ensure that it will
    actually be effective.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 606f42265d384b9149bfb953c5dfc6d4710fef4c
Author: Prashanth Prakash <pprakash@codeaurora.org>
Date:   Thu Jan 26 11:08:32 2017 -0700

    arm64: skip register_cpufreq_notifier on ACPI-based systems
    
    On ACPI based systems where the topology is setup using the API
    store_cpu_topology, at the moment we do not have necessary code
    to parse cpu capacity and handle cpufreq notifier, thus
    resulting in a kernel panic.
    
    Stack:
            init_cpu_capacity_callback+0xb4/0x1c8
            notifier_call_chain+0x5c/0xa0
            __blocking_notifier_call_chain+0x58/0xa0
            blocking_notifier_call_chain+0x3c/0x50
            cpufreq_set_policy+0xe4/0x328
            cpufreq_init_policy+0x80/0x100
            cpufreq_online+0x418/0x710
            cpufreq_add_dev+0x118/0x180
            subsys_interface_register+0xa4/0xf8
            cpufreq_register_driver+0x1c0/0x298
            cppc_cpufreq_init+0xdc/0x1000 [cppc_cpufreq]
            do_one_initcall+0x5c/0x168
            do_init_module+0x64/0x1e4
            load_module+0x130c/0x14d0
            SyS_finit_module+0x108/0x120
            el0_svc_naked+0x24/0x28
    
    Fixes: 7202bde8b7ae ("arm64: parse cpu capacity-dmips-mhz from DT")
    Acked-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Prashanth Prakash <pprakash@codeaurora.org>
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>

commit 9e607f72748ddc5620aeeb8d1f32f30c79b360b9
Author: Denis Kirjanov <kda@linux-powerpc.org>
Date:   Wed Sep 21 14:34:58 2016 +0300

    i2c_powermac: shut up lockdep warning
    
    That's unclear why lockdep shows the following warning but adding a
    lockdep class to struct pmac_i2c_bus solves it
    
    [   20.507795] ======================================================
    [   20.507796] [ INFO: possible circular locking dependency detected ]
    [   20.507800] 4.8.0-rc7-00037-gd2ffb01 #21 Not tainted
    [   20.507801] -------------------------------------------------------
    [   20.507803] swapper/0/1 is trying to acquire lock:
    [   20.507818]  (&bus->mutex){+.+.+.}, at: [<c000000000052830>] .pmac_i2c_open+0x30/0x100
    [   20.507819]
    [   20.507819] but task is already holding lock:
    [   20.507829]  (&policy->rwsem){+.+.+.}, at: [<c00000000068adcc>] .cpufreq_online+0x1ac/0x9d0
    [   20.507830]
    [   20.507830] which lock already depends on the new lock.
    [   20.507830]
    [   20.507832]
    [   20.507832] the existing dependency chain (in reverse order) is:
    [   20.507837]
    [   20.507837] -> #4 (&policy->rwsem){+.+.+.}:
    [   20.507844]        [<c00000000082385c>] .down_write+0x6c/0x110
    [   20.507849]        [<c00000000068adcc>] .cpufreq_online+0x1ac/0x9d0
    [   20.507855]        [<c0000000004d76d8>] .subsys_interface_register+0xb8/0x110
    [   20.507860]        [<c000000000689bb0>] .cpufreq_register_driver+0x1d0/0x250
    [   20.507866]        [<c000000000b4f8f4>] .g5_cpufreq_init+0x9cc/0xa28
    [   20.507872]        [<c00000000000a98c>] .do_one_initcall+0x5c/0x1d0
    [   20.507878]        [<c000000000b0f86c>] .kernel_init_freeable+0x1ac/0x28c
    [   20.507883]        [<c00000000000b3bc>] .kernel_init+0x1c/0x140
    [   20.507887]        [<c0000000000098f4>] .ret_from_kernel_thread+0x58/0x64
    [   20.507894]
    [   20.507894] -> #3 (subsys mutex#2){+.+.+.}:
    [   20.507899]        [<c000000000820448>] .mutex_lock_nested+0xa8/0x590
    [   20.507903]        [<c0000000004d7f24>] .bus_probe_device+0x44/0xe0
    [   20.507907]        [<c0000000004d5208>] .device_add+0x508/0x730
    [   20.507911]        [<c0000000004dd528>] .register_cpu+0x118/0x190
    [   20.507916]        [<c000000000b14450>] .topology_init+0x148/0x248
    [   20.507921]        [<c00000000000a98c>] .do_one_initcall+0x5c/0x1d0
    [   20.507925]        [<c000000000b0f86c>] .kernel_init_freeable+0x1ac/0x28c
    [   20.507929]        [<c00000000000b3bc>] .kernel_init+0x1c/0x140
    [   20.507934]        [<c0000000000098f4>] .ret_from_kernel_thread+0x58/0x64
    [   20.507939]
    [   20.507939] -> #2 (cpu_add_remove_lock){+.+.+.}:
    [   20.507944]        [<c000000000820448>] .mutex_lock_nested+0xa8/0x590
    [   20.507950]        [<c000000000087a9c>] .register_cpu_notifier+0x2c/0x70
    [   20.507955]        [<c000000000b267e0>] .spawn_ksoftirqd+0x18/0x4c
    [   20.507959]        [<c00000000000a98c>] .do_one_initcall+0x5c/0x1d0
    [   20.507964]        [<c000000000b0f770>] .kernel_init_freeable+0xb0/0x28c
    [   20.507968]        [<c00000000000b3bc>] .kernel_init+0x1c/0x140
    [   20.507972]        [<c0000000000098f4>] .ret_from_kernel_thread+0x58/0x64
    [   20.507978]
    [   20.507978] -> #1 (&host->mutex){+.+.+.}:
    [   20.507982]        [<c000000000820448>] .mutex_lock_nested+0xa8/0x590
    [   20.507987]        [<c0000000000527e8>] .kw_i2c_open+0x18/0x30
    [   20.507991]        [<c000000000052894>] .pmac_i2c_open+0x94/0x100
    [   20.507995]        [<c000000000b220a0>] .smp_core99_probe+0x260/0x410
    [   20.507999]        [<c000000000b185bc>] .smp_prepare_cpus+0x280/0x2ac
    [   20.508003]        [<c000000000b0f748>] .kernel_init_freeable+0x88/0x28c
    [   20.508008]        [<c00000000000b3bc>] .kernel_init+0x1c/0x140
    [   20.508012]        [<c0000000000098f4>] .ret_from_kernel_thread+0x58/0x64
    [   20.508018]
    [   20.508018] -> #0 (&bus->mutex){+.+.+.}:
    [   20.508023]        [<c0000000000ed5b4>] .lock_acquire+0x84/0x100
    [   20.508027]        [<c000000000820448>] .mutex_lock_nested+0xa8/0x590
    [   20.508032]        [<c000000000052830>] .pmac_i2c_open+0x30/0x100
    [   20.508037]        [<c000000000052e14>] .pmac_i2c_do_begin+0x34/0x120
    [   20.508040]        [<c000000000056bc0>] .pmf_call_one+0x50/0xd0
    [   20.508045]        [<c00000000068ff1c>] .g5_pfunc_switch_volt+0x2c/0xc0
    [   20.508050]        [<c00000000068fecc>] .g5_pfunc_switch_freq+0x1cc/0x1f0
    [   20.508054]        [<c00000000068fc2c>] .g5_cpufreq_target+0x2c/0x40
    [   20.508058]        [<c0000000006873ec>] .__cpufreq_driver_target+0x23c/0x840
    [   20.508062]        [<c00000000068c798>] .cpufreq_gov_performance_limits+0x18/0x30
    [   20.508067]        [<c00000000068915c>] .cpufreq_start_governor+0xac/0x100
    [   20.508071]        [<c00000000068a788>] .cpufreq_set_policy+0x208/0x260
    [   20.508076]        [<c00000000068abdc>] .cpufreq_init_policy+0x6c/0xb0
    [   20.508081]        [<c00000000068ae70>] .cpufreq_online+0x250/0x9d0
    [   20.508085]        [<c0000000004d76d8>] .subsys_interface_register+0xb8/0x110
    [   20.508090]        [<c000000000689bb0>] .cpufreq_register_driver+0x1d0/0x250
    [   20.508094]        [<c000000000b4f8f4>] .g5_cpufreq_init+0x9cc/0xa28
    [   20.508099]        [<c00000000000a98c>] .do_one_initcall+0x5c/0x1d0
    [   20.508103]        [<c000000000b0f86c>] .kernel_init_freeable+0x1ac/0x28c
    [   20.508107]        [<c00000000000b3bc>] .kernel_init+0x1c/0x140
    [   20.508112]        [<c0000000000098f4>] .ret_from_kernel_thread+0x58/0x64
    [   20.508113]
    [   20.508113] other info that might help us debug this:
    [   20.508113]
    [   20.508121] Chain exists of:
    [   20.508121]   &bus->mutex --> subsys mutex#2 --> &policy->rwsem
    [   20.508121]
    [   20.508123]  Possible unsafe locking scenario:
    [   20.508123]
    [   20.508124]        CPU0                    CPU1
    [   20.508125]        ----                    ----
    [   20.508128]   lock(&policy->rwsem);
    [   20.508132]                                lock(subsys mutex#2);
    [   20.508135]                                lock(&policy->rwsem);
    [   20.508138]   lock(&bus->mutex);
    [   20.508139]
    [   20.508139]  *** DEADLOCK ***
    [   20.508139]
    [   20.508141] 3 locks held by swapper/0/1:
    [   20.508150]  #0:  (cpu_hotplug.lock){++++++}, at: [<c000000000087838>] .get_online_cpus+0x48/0xc0
    [   20.508159]  #1:  (subsys mutex#2){+.+.+.}, at: [<c0000000004d7670>] .subsys_interface_register+0x50/0x110
    [   20.508168]  #2:  (&policy->rwsem){+.+.+.}, at: [<c00000000068adcc>] .cpufreq_online+0x1ac/0x9d0
    [   20.508169]
    [   20.508169] stack backtrace:
    [   20.508173] CPU: 0 PID: 1 Comm: swapper/0 Not tainted 4.8.0-rc7-00037-gd2ffb01 #21
    [   20.508175] Call Trace:
    [   20.508180] [c0000000790c2b90] [c00000000082cc70] .dump_stack+0xe0/0x14c (unreliable)
    [   20.508184] [c0000000790c2c20] [c000000000828c88] .print_circular_bug+0x350/0x388
    [   20.508188] [c0000000790c2cd0] [c0000000000ecb0c] .__lock_acquire+0x196c/0x1d30
    [   20.508192] [c0000000790c2e50] [c0000000000ed5b4] .lock_acquire+0x84/0x100
    [   20.508196] [c0000000790c2f20] [c000000000820448] .mutex_lock_nested+0xa8/0x590
    [   20.508201] [c0000000790c3030] [c000000000052830] .pmac_i2c_open+0x30/0x100
    [   20.508206] [c0000000790c30c0] [c000000000052e14] .pmac_i2c_do_begin+0x34/0x120
    [   20.508209] [c0000000790c3150] [c000000000056bc0] .pmf_call_one+0x50/0xd0
    [   20.508213] [c0000000790c31e0] [c00000000068ff1c] .g5_pfunc_switch_volt+0x2c/0xc0
    [   20.508217] [c0000000790c3250] [c00000000068fecc] .g5_pfunc_switch_freq+0x1cc/0x1f0
    [   20.508221] [c0000000790c3320] [c00000000068fc2c] .g5_cpufreq_target+0x2c/0x40
    [   20.508226] [c0000000790c3390] [c0000000006873ec] .__cpufreq_driver_target+0x23c/0x840
    [   20.508230] [c0000000790c3440] [c00000000068c798] .cpufreq_gov_performance_limits+0x18/0x30
    [   20.508235] [c0000000790c34b0] [c00000000068915c] .cpufreq_start_governor+0xac/0x100
    [   20.508239] [c0000000790c3530] [c00000000068a788] .cpufreq_set_policy+0x208/0x260
    [   20.508244] [c0000000790c35d0] [c00000000068abdc] .cpufreq_init_policy+0x6c/0xb0
    [   20.508249] [c0000000790c3940] [c00000000068ae70] .cpufreq_online+0x250/0x9d0
    [   20.508253] [c0000000790c3a30] [c0000000004d76d8] .subsys_interface_register+0xb8/0x110
    [   20.508258] [c0000000790c3ad0] [c000000000689bb0] .cpufreq_register_driver+0x1d0/0x250
    [   20.508262] [c0000000790c3b60] [c000000000b4f8f4] .g5_cpufreq_init+0x9cc/0xa28
    [   20.508267] [c0000000790c3c20] [c00000000000a98c] .do_one_initcall+0x5c/0x1d0
    [   20.508271] [c0000000790c3d00] [c000000000b0f86c] .kernel_init_freeable+0x1ac/0x28c
    [   20.508276] [c0000000790c3db0] [c00000000000b3bc] .kernel_init+0x1c/0x140
    [   20.508280] [c0000000790c3e30] [c0000000000098f4] .ret_from_kernel_thread+0x58/0x64
    
    Signed-off-by: Denis Kirjanov <kda@linux-powerpc.org>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

commit dc04e6ce01005b511a2371726553992f27109f5d
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Sat Oct 8 12:42:38 2016 -0700

    cpufreq: intel_pstate: Fix unsafe HWP MSR access
    
    commit f9f4872df6e1801572949f8a370c886122d4b6da upstream.
    
    This is a requirement that MSR MSR_PM_ENABLE must be set to 0x01 before
    reading MSR_HWP_CAPABILITIES on a given CPU. If cpufreq init() is
    scheduled on a CPU which is not same as policy->cpu or migrates to a
    different CPU before calling msr read for MSR_HWP_CAPABILITIES, it
    is possible that MSR_PM_ENABLE was not to set to 0x01 on that CPU.
    This will cause GP fault. So like other places in this path
    rdmsrl_on_cpu should be used instead of rdmsrl.
    
    Moreover the scope of MSR_HWP_CAPABILITIES is on per thread basis, so it
    should be read from the same CPU, for which MSR MSR_HWP_REQUEST is
    getting set.
    
    dmesg dump or warning:
    
    [   22.014488] WARNING: CPU: 139 PID: 1 at arch/x86/mm/extable.c:50 ex_handler_rdmsr_unsafe+0x68/0x70
    [   22.014492] unchecked MSR access error: RDMSR from 0x771
    [   22.014493] Modules linked in:
    [   22.014507] CPU: 139 PID: 1 Comm: swapper/0 Not tainted 4.7.5+ #1
    ...
    ...
    [   22.014516] Call Trace:
    [   22.014542]  [<ffffffff813d7dd1>] dump_stack+0x63/0x82
    [   22.014558]  [<ffffffff8107bc8b>] __warn+0xcb/0xf0
    [   22.014561]  [<ffffffff8107bcff>] warn_slowpath_fmt+0x4f/0x60
    [   22.014563]  [<ffffffff810676f8>] ex_handler_rdmsr_unsafe+0x68/0x70
    [   22.014564]  [<ffffffff810677d9>] fixup_exception+0x39/0x50
    [   22.014604]  [<ffffffff8102e400>] do_general_protection+0x80/0x150
    [   22.014610]  [<ffffffff817f9ec8>] general_protection+0x28/0x30
    [   22.014635]  [<ffffffff81687940>] ? get_target_pstate_use_performance+0xb0/0xb0
    [   22.014642]  [<ffffffff810600c7>] ? native_read_msr+0x7/0x40
    [   22.014657]  [<ffffffff81688123>] intel_pstate_hwp_set+0x23/0x130
    [   22.014660]  [<ffffffff81688406>] intel_pstate_set_policy+0x1b6/0x340
    [   22.014662]  [<ffffffff816829bb>] cpufreq_set_policy+0xeb/0x2c0
    [   22.014664]  [<ffffffff81682f39>] cpufreq_init_policy+0x79/0xe0
    [   22.014666]  [<ffffffff81682cb0>] ? cpufreq_update_policy+0x120/0x120
    [   22.014669]  [<ffffffff816833a6>] cpufreq_online+0x406/0x820
    [   22.014671]  [<ffffffff8168381f>] cpufreq_add_dev+0x5f/0x90
    [   22.014717]  [<ffffffff81530ac8>] subsys_interface_register+0xb8/0x100
    [   22.014719]  [<ffffffff816821bc>] cpufreq_register_driver+0x14c/0x210
    [   22.014749]  [<ffffffff81fe1d90>] intel_pstate_init+0x39d/0x4d5
    [   22.014751]  [<ffffffff81fe13f2>] ? cpufreq_gov_dbs_init+0x12/0x12
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit d756b52c8bbe7735cc881dab46378518d2d4b1f1
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Sat Oct 8 12:42:38 2016 -0700

    cpufreq: intel_pstate: Fix unsafe HWP MSR access
    
    commit f9f4872df6e1801572949f8a370c886122d4b6da upstream.
    
    This is a requirement that MSR MSR_PM_ENABLE must be set to 0x01 before
    reading MSR_HWP_CAPABILITIES on a given CPU. If cpufreq init() is
    scheduled on a CPU which is not same as policy->cpu or migrates to a
    different CPU before calling msr read for MSR_HWP_CAPABILITIES, it
    is possible that MSR_PM_ENABLE was not to set to 0x01 on that CPU.
    This will cause GP fault. So like other places in this path
    rdmsrl_on_cpu should be used instead of rdmsrl.
    
    Moreover the scope of MSR_HWP_CAPABILITIES is on per thread basis, so it
    should be read from the same CPU, for which MSR MSR_HWP_REQUEST is
    getting set.
    
    dmesg dump or warning:
    
    [   22.014488] WARNING: CPU: 139 PID: 1 at arch/x86/mm/extable.c:50 ex_handler_rdmsr_unsafe+0x68/0x70
    [   22.014492] unchecked MSR access error: RDMSR from 0x771
    [   22.014493] Modules linked in:
    [   22.014507] CPU: 139 PID: 1 Comm: swapper/0 Not tainted 4.7.5+ #1
    ...
    ...
    [   22.014516] Call Trace:
    [   22.014542]  [<ffffffff813d7dd1>] dump_stack+0x63/0x82
    [   22.014558]  [<ffffffff8107bc8b>] __warn+0xcb/0xf0
    [   22.014561]  [<ffffffff8107bcff>] warn_slowpath_fmt+0x4f/0x60
    [   22.014563]  [<ffffffff810676f8>] ex_handler_rdmsr_unsafe+0x68/0x70
    [   22.014564]  [<ffffffff810677d9>] fixup_exception+0x39/0x50
    [   22.014604]  [<ffffffff8102e400>] do_general_protection+0x80/0x150
    [   22.014610]  [<ffffffff817f9ec8>] general_protection+0x28/0x30
    [   22.014635]  [<ffffffff81687940>] ? get_target_pstate_use_performance+0xb0/0xb0
    [   22.014642]  [<ffffffff810600c7>] ? native_read_msr+0x7/0x40
    [   22.014657]  [<ffffffff81688123>] intel_pstate_hwp_set+0x23/0x130
    [   22.014660]  [<ffffffff81688406>] intel_pstate_set_policy+0x1b6/0x340
    [   22.014662]  [<ffffffff816829bb>] cpufreq_set_policy+0xeb/0x2c0
    [   22.014664]  [<ffffffff81682f39>] cpufreq_init_policy+0x79/0xe0
    [   22.014666]  [<ffffffff81682cb0>] ? cpufreq_update_policy+0x120/0x120
    [   22.014669]  [<ffffffff816833a6>] cpufreq_online+0x406/0x820
    [   22.014671]  [<ffffffff8168381f>] cpufreq_add_dev+0x5f/0x90
    [   22.014717]  [<ffffffff81530ac8>] subsys_interface_register+0xb8/0x100
    [   22.014719]  [<ffffffff816821bc>] cpufreq_register_driver+0x14c/0x210
    [   22.014749]  [<ffffffff81fe1d90>] intel_pstate_init+0x39d/0x4d5
    [   22.014751]  [<ffffffff81fe13f2>] ? cpufreq_gov_dbs_init+0x12/0x12
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit f9f4872df6e1801572949f8a370c886122d4b6da
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Sat Oct 8 12:42:38 2016 -0700

    cpufreq: intel_pstate: Fix unsafe HWP MSR access
    
    This is a requirement that MSR MSR_PM_ENABLE must be set to 0x01 before
    reading MSR_HWP_CAPABILITIES on a given CPU. If cpufreq init() is
    scheduled on a CPU which is not same as policy->cpu or migrates to a
    different CPU before calling msr read for MSR_HWP_CAPABILITIES, it
    is possible that MSR_PM_ENABLE was not to set to 0x01 on that CPU.
    This will cause GP fault. So like other places in this path
    rdmsrl_on_cpu should be used instead of rdmsrl.
    
    Moreover the scope of MSR_HWP_CAPABILITIES is on per thread basis, so it
    should be read from the same CPU, for which MSR MSR_HWP_REQUEST is
    getting set.
    
    dmesg dump or warning:
    
    [   22.014488] WARNING: CPU: 139 PID: 1 at arch/x86/mm/extable.c:50 ex_handler_rdmsr_unsafe+0x68/0x70
    [   22.014492] unchecked MSR access error: RDMSR from 0x771
    [   22.014493] Modules linked in:
    [   22.014507] CPU: 139 PID: 1 Comm: swapper/0 Not tainted 4.7.5+ #1
    ...
    ...
    [   22.014516] Call Trace:
    [   22.014542]  [<ffffffff813d7dd1>] dump_stack+0x63/0x82
    [   22.014558]  [<ffffffff8107bc8b>] __warn+0xcb/0xf0
    [   22.014561]  [<ffffffff8107bcff>] warn_slowpath_fmt+0x4f/0x60
    [   22.014563]  [<ffffffff810676f8>] ex_handler_rdmsr_unsafe+0x68/0x70
    [   22.014564]  [<ffffffff810677d9>] fixup_exception+0x39/0x50
    [   22.014604]  [<ffffffff8102e400>] do_general_protection+0x80/0x150
    [   22.014610]  [<ffffffff817f9ec8>] general_protection+0x28/0x30
    [   22.014635]  [<ffffffff81687940>] ? get_target_pstate_use_performance+0xb0/0xb0
    [   22.014642]  [<ffffffff810600c7>] ? native_read_msr+0x7/0x40
    [   22.014657]  [<ffffffff81688123>] intel_pstate_hwp_set+0x23/0x130
    [   22.014660]  [<ffffffff81688406>] intel_pstate_set_policy+0x1b6/0x340
    [   22.014662]  [<ffffffff816829bb>] cpufreq_set_policy+0xeb/0x2c0
    [   22.014664]  [<ffffffff81682f39>] cpufreq_init_policy+0x79/0xe0
    [   22.014666]  [<ffffffff81682cb0>] ? cpufreq_update_policy+0x120/0x120
    [   22.014669]  [<ffffffff816833a6>] cpufreq_online+0x406/0x820
    [   22.014671]  [<ffffffff8168381f>] cpufreq_add_dev+0x5f/0x90
    [   22.014717]  [<ffffffff81530ac8>] subsys_interface_register+0xb8/0x100
    [   22.014719]  [<ffffffff816821bc>] cpufreq_register_driver+0x14c/0x210
    [   22.014749]  [<ffffffff81fe1d90>] intel_pstate_init+0x39d/0x4d5
    [   22.014751]  [<ffffffff81fe13f2>] ? cpufreq_gov_dbs_init+0x12/0x12
    
    Cc: 4.3+ <stable@vger.kernel.org> # 4.3+
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 0a300767e5882ad5b687966c80f9620aa0871be5
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Mar 21 15:45:24 2016 +0100

    cpufreq: Introduce cpufreq_start_governor()
    
    Starting a governor in cpufreq always follows the same pattern
    involving two calls to cpufreq_governor(), one with the event
    argument set to CPUFREQ_GOV_START and one with that argument set to
    CPUFREQ_GOV_LIMITS.
    
    Introduce cpufreq_start_governor() that will carry out those two
    operations and make all places where governors are started use it.
    
    That slightly modifies the behavior of cpufreq_set_policy() which
    now also will go back to the old governor if the second call to
    cpufreq_governor() (the one with event equal to CPUFREQ_GOV_LIMITS)
    fails, but that really is how it should work in the first place.
    
    Also cpufreq_resume() will now pring an error message if the
    CPUFREQ_GOV_LIMITS call to cpufreq_governor() fails, but that
    makes it follow cpufreq_add_policy_cpu() and cpufreq_offline()
    in that respect.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>

commit 68e80dae09033d778b98dc88e5bfe8fdade188e5
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Feb 9 09:01:35 2016 +0530

    Revert "cpufreq: Drop rwsem lock around CPUFREQ_GOV_POLICY_EXIT"
    
    Earlier, when the struct freq-attr was used to represent governor
    attributes, the standard cpufreq show/store sysfs attribute callbacks
    were applied to the governor tunable attributes and they always acquire
    the policy->rwsem lock before carrying out the operation.  That could
    have resulted in an ABBA deadlock if governor tunable attributes are
    removed under policy->rwsem while one of them is being accessed
    concurrently (if sysfs attributes removal wins the race, it will wait
    for the access to complete with policy->rwsem held while the attribute
    callback will block on policy->rwsem indefinitely).
    
    We attempted to address this issue by dropping policy->rwsem around
    governor tunable attributes removal (that is, around invocations of the
    ->governor callback with the event arg equal to CPUFREQ_GOV_POLICY_EXIT)
    in cpufreq_set_policy(), but that opened up race conditions that had not
    been possible with policy->rwsem held all the time.
    
    The previous commit, "cpufreq: governor: New sysfs show/store callbacks
    for governor tunables", fixed the original ABBA deadlock by adding new
    governor specific show/store callbacks.
    
    We don't have to drop rwsem around invocations of governor event
    CPUFREQ_GOV_POLICY_EXIT anymore, and original fix can be reverted now.
    
    Fixes: 955ef4833574 (cpufreq: Drop rwsem lock around CPUFREQ_GOV_POLICY_EXIT)
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reported-by: Juri Lelli <juri.lelli@arm.com>
    Tested-by: Juri Lelli <juri.lelli@arm.com>
    Tested-by: Shilpasri G Bhat <shilpa.bhat@linux.vnet.ibm.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit c4435630361d9bebf7154a0c842dc1fb7ae39c99
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Feb 9 09:01:33 2016 +0530

    cpufreq: governor: New sysfs show/store callbacks for governor tunables
    
    The ondemand and conservative governors use the global-attr or freq-attr
    structures to represent sysfs attributes corresponding to their tunables
    (which of them is actually used depends on whether or not different
    policy objects can use the same governor with different tunables at the
    same time and, consequently, on where those attributes are located in
    sysfs).
    
    Unfortunately, in the freq-attr case, the standard cpufreq show/store
    sysfs attribute callbacks are applied to the governor tunable attributes
    and they always acquire the policy->rwsem lock before carrying out the
    operation.  That may lead to an ABBA deadlock if governor tunable
    attributes are removed under policy->rwsem while one of them is being
    accessed concurrently (if sysfs attributes removal wins the race, it
    will wait for the access to complete with policy->rwsem held while the
    attribute callback will block on policy->rwsem indefinitely).
    
    We attempted to address this issue by dropping policy->rwsem around
    governor tunable attributes removal (that is, around invocations of the
    ->governor callback with the event arg equal to CPUFREQ_GOV_POLICY_EXIT)
    in cpufreq_set_policy(), but that opened up race conditions that had not
    been possible with policy->rwsem held all the time.  Therefore
    policy->rwsem cannot be dropped in cpufreq_set_policy() at any point,
    but the deadlock situation described above must be avoided too.
    
    To that end, use the observation that in principle governor tunables may
    be represented by the same data type regardless of whether the governor
    is system-wide or per-policy and introduce a new structure, struct
    governor_attr, for representing them and new corresponding macros for
    creating show/store sysfs callbacks for them.  Also make their parent
    kobject use a new kobject type whose default show/store callbacks are
    not related to the standard core cpufreq ones in any way (and they don't
    acquire policy->rwsem in particular).
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Tested-by: Juri Lelli <juri.lelli@arm.com>
    Tested-by: Shilpasri G Bhat <shilpa.bhat@linux.vnet.ibm.com>
    [ rjw: Subject & changelog + rebase ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 4ffe18c2556f2848c4e57457915b08a63dc00fd5
Merge: 498012511a06 72e624de6e6f
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Sep 1 15:52:35 2015 +0200

    Merge branch 'pm-cpufreq'
    
    * pm-cpufreq: (53 commits)
      cpufreq: speedstep-lib: Use monotonic clock
      cpufreq: powernv: Increase the verbosity of OCC console messages
      cpufreq: sfi: use kmemdup rather than duplicating its implementation
      cpufreq: drop !cpufreq_driver check from cpufreq_parse_governor()
      cpufreq: rename cpufreq_real_policy as cpufreq_user_policy
      cpufreq: remove redundant 'policy' field from user_policy
      cpufreq: remove redundant 'governor' field from user_policy
      cpufreq: update user_policy.* on success
      cpufreq: use memcpy() to copy policy
      cpufreq: remove redundant CPUFREQ_INCOMPATIBLE notifier event
      cpufreq: mediatek: Add MT8173 cpufreq driver
      dt-bindings: mediatek: Add MT8173 CPU DVFS clock bindings
      intel_pstate: append more Oracle OEM table id to vendor bypass list
      intel_pstate: Add SKY-S support
      intel_pstate: Fix possible overflow complained by Coverity
      cpufreq: Correct a freq check in cpufreq_set_policy()
      cpufreq: Lock CPU online/offline in cpufreq_register_driver()
      cpufreq: Replace recover_policy with new_policy in cpufreq_online()
      cpufreq: Separate CPU device registration from CPU online
      cpufreq: powernv: Restore cpu frequency to policy->cur on unthrottling
      ...

commit 14ca0bdfdd6b422027b9b733abb0bf151811eaa7
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon Aug 3 08:36:16 2015 +0530

    cpufreq: update user_policy.* on success
    
    'user_policy' caches properties of a policy that are set by userspace.
    And these must be updated only if cpufreq core was successful in
    updating them based on request from user space.
    
    In store_scaling_governor(), we are updating user_policy.policy and
    user_policy.governor even if cpufreq_set_policy() failed. That's
    incorrect.
    
    Fix this by updating user_policy.* only if we were successful in
    updating the properties.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 02373d7c69b4270bbab930f8a81b0721be794347
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Wed Aug 12 15:22:16 2015 +0530

    thermal: cpu_cooling: fix lockdep problems in cpu_cooling
    
    A recent change to the cpu_cooling code introduced a AB-BA deadlock
    scenario between the cpufreq_policy_notifier_list rwsem and the
    cooling_cpufreq_lock.  This is caused by cooling_cpufreq_lock being held
    before the registration/removal of the notifier block (an operation
    which takes the rwsem), and the notifier code itself which takes the
    locks in the reverse order:
    
    ======================================================
    [ INFO: possible circular locking dependency detected ]
    3.18.0+ #1453 Not tainted
    -------------------------------------------------------
    rc.local/770 is trying to acquire lock:
     (cooling_cpufreq_lock){+.+.+.}, at: [<c04abfc4>] cpufreq_thermal_notifier+0x34/0xfc
    
    but task is already holding lock:
     ((cpufreq_policy_notifier_list).rwsem){++++.+}, at: [<c0042f04>]  __blocking_notifier_call_chain+0x34/0x68
    
    which lock already depends on the new lock.
    
    the existing dependency chain (in reverse order) is:
    
    -> #1 ((cpufreq_policy_notifier_list).rwsem){++++.+}:
           [<c06bc3b0>] down_write+0x44/0x9c
           [<c0043444>] blocking_notifier_chain_register+0x28/0xd8
           [<c04ad610>] cpufreq_register_notifier+0x68/0x90
           [<c04abe4c>] __cpufreq_cooling_register.part.1+0x120/0x180
           [<c04abf44>] __cpufreq_cooling_register+0x98/0xa4
           [<c04abf8c>] cpufreq_cooling_register+0x18/0x1c
           [<bf0046f8>] imx_thermal_probe+0x1c0/0x470 [imx_thermal]
           [<c037cef8>] platform_drv_probe+0x50/0xac
           [<c037b710>] driver_probe_device+0x114/0x234
           [<c037b8cc>] __driver_attach+0x9c/0xa0
           [<c0379d68>] bus_for_each_dev+0x5c/0x90
           [<c037b204>] driver_attach+0x24/0x28
           [<c037ae7c>] bus_add_driver+0xe0/0x1d8
           [<c037c0cc>] driver_register+0x80/0xfc
           [<c037cd80>] __platform_driver_register+0x50/0x64
           [<bf007018>] 0xbf007018
           [<c0008a5c>] do_one_initcall+0x88/0x1d8
           [<c0095da4>] load_module+0x1768/0x1ef8
           [<c0096614>] SyS_init_module+0xe0/0xf4
           [<c000ec00>] ret_fast_syscall+0x0/0x48
    
    -> #0 (cooling_cpufreq_lock){+.+.+.}:
           [<c00619f8>] lock_acquire+0xb0/0x124
           [<c06ba3b4>] mutex_lock_nested+0x5c/0x3d8
           [<c04abfc4>] cpufreq_thermal_notifier+0x34/0xfc
           [<c0042bf4>] notifier_call_chain+0x4c/0x8c
           [<c0042f20>] __blocking_notifier_call_chain+0x50/0x68
           [<c0042f58>] blocking_notifier_call_chain+0x20/0x28
           [<c04ae62c>] cpufreq_set_policy+0x7c/0x1d0
           [<c04af3cc>] store_scaling_governor+0x74/0x9c
           [<c04ad418>] store+0x90/0xc0
           [<c0175384>] sysfs_kf_write+0x54/0x58
           [<c01746b4>] kernfs_fop_write+0xdc/0x190
           [<c010dcc0>] vfs_write+0xac/0x1b4
           [<c010dfec>] SyS_write+0x44/0x90
           [<c000ec00>] ret_fast_syscall+0x0/0x48
    
    other info that might help us debug this:
    
     Possible unsafe locking scenario:
    
           CPU0                    CPU1
           ----                    ----
      lock((cpufreq_policy_notifier_list).rwsem);
                                   lock(cooling_cpufreq_lock);
                                   lock((cpufreq_policy_notifier_list).rwsem);
      lock(cooling_cpufreq_lock);
    
     *** DEADLOCK ***
    
    7 locks held by rc.local/770:
     #0:  (sb_writers#6){.+.+.+}, at: [<c010dda0>] vfs_write+0x18c/0x1b4
     #1:  (&of->mutex){+.+.+.}, at: [<c0174678>] kernfs_fop_write+0xa0/0x190
     #2:  (s_active#52){.+.+.+}, at: [<c0174680>] kernfs_fop_write+0xa8/0x190
     #3:  (cpu_hotplug.lock){++++++}, at: [<c0026a60>] get_online_cpus+0x34/0x90
     #4:  (cpufreq_rwsem){.+.+.+}, at: [<c04ad3e0>] store+0x58/0xc0
     #5:  (&policy->rwsem){+.+.+.}, at: [<c04ad3f8>] store+0x70/0xc0
     #6:  ((cpufreq_policy_notifier_list).rwsem){++++.+}, at: [<c0042f04>] __blocking_notifier_call_chain+0x34/0x68
    
    stack backtrace:
    CPU: 0 PID: 770 Comm: rc.local Not tainted 3.18.0+ #1453
    Hardware name: Freescale i.MX6 Quad/DualLite (Device Tree)
    Backtrace:
    [<c00121c8>] (dump_backtrace) from [<c0012360>] (show_stack+0x18/0x1c)
     r6:c0b85a80 r5:c0b75630 r4:00000000 r3:00000000
    [<c0012348>] (show_stack) from [<c06b6c48>] (dump_stack+0x7c/0x98)
    [<c06b6bcc>] (dump_stack) from [<c06b42a4>] (print_circular_bug+0x28c/0x2d8)
     r4:c0b85a80 r3:d0071d40
    [<c06b4018>] (print_circular_bug) from [<c00613b0>] (__lock_acquire+0x1acc/0x1bb0)
     r10:c0b50660 r8:c09e6d80 r7:d0071d40 r6:c11d0f0c r5:00000007 r4:d0072240
    [<c005f8e4>] (__lock_acquire) from [<c00619f8>] (lock_acquire+0xb0/0x124)
     r10:00000000 r9:c04abfc4 r8:00000000 r7:00000000 r6:00000000 r5:c0a06f0c
     r4:00000000
    [<c0061948>] (lock_acquire) from [<c06ba3b4>] (mutex_lock_nested+0x5c/0x3d8)
     r10:ec853800 r9:c0a06ed4 r8:d0071d40 r7:c0a06ed4 r6:c11d0f0c r5:00000000
     r4:c04abfc4
    [<c06ba358>] (mutex_lock_nested) from [<c04abfc4>] (cpufreq_thermal_notifier+0x34/0xfc)
     r10:ec853800 r9:ec85380c r8:d00d7d3c r7:c0a06ed4 r6:d00d7d3c r5:00000000
     r4:fffffffe
    [<c04abf90>] (cpufreq_thermal_notifier) from [<c0042bf4>] (notifier_call_chain+0x4c/0x8c)
     r7:00000000 r6:00000000 r5:00000000 r4:fffffffe
    [<c0042ba8>] (notifier_call_chain) from [<c0042f20>] (__blocking_notifier_call_chain+0x50/0x68)
     r8:c0a072a4 r7:00000000 r6:d00d7d3c r5:ffffffff r4:c0a06fc8 r3:ffffffff
    [<c0042ed0>] (__blocking_notifier_call_chain) from [<c0042f58>] (blocking_notifier_call_chain+0x20/0x28)
     r7:ec98b540 r6:c13ebc80 r5:ed76e600 r4:d00d7d3c
    [<c0042f38>] (blocking_notifier_call_chain) from [<c04ae62c>] (cpufreq_set_policy+0x7c/0x1d0)
    [<c04ae5b0>] (cpufreq_set_policy) from [<c04af3cc>] (store_scaling_governor+0x74/0x9c)
     r7:ec98b540 r6:0000000c r5:ec98b540 r4:ed76e600
    [<c04af358>] (store_scaling_governor) from [<c04ad418>] (store+0x90/0xc0)
     r6:0000000c r5:ed76e6d4 r4:ed76e600
    [<c04ad388>] (store) from [<c0175384>] (sysfs_kf_write+0x54/0x58)
     r8:0000000c r7:d00d7f78 r6:ec98b540 r5:0000000c r4:ec853800 r3:0000000c
    [<c0175330>] (sysfs_kf_write) from [<c01746b4>] (kernfs_fop_write+0xdc/0x190)
     r6:ec98b540 r5:00000000 r4:00000000 r3:c0175330
    [<c01745d8>] (kernfs_fop_write) from [<c010dcc0>] (vfs_write+0xac/0x1b4)
     r10:0162aa70 r9:d00d6000 r8:0000000c r7:d00d7f78 r6:0162aa70 r5:0000000c
     r4:eccde500
    [<c010dc14>] (vfs_write) from [<c010dfec>] (SyS_write+0x44/0x90)
     r10:0162aa70 r8:0000000c r7:eccde500 r6:eccde500 r5:00000000 r4:00000000
    [<c010dfa8>] (SyS_write) from [<c000ec00>] (ret_fast_syscall+0x0/0x48)
     r10:00000000 r8:c000edc4 r7:00000004 r6:000216cc r5:0000000c r4:0162aa70
    
    Solve this by moving to finer grained locking - use one mutex to protect
    the cpufreq_dev_list as a whole, and a separate lock to ensure correct
    ordering of cpufreq notifier registration and removal.
    
    cooling_list_lock is taken within cooling_cpufreq_lock on
    (un)registration to preserve the behavior of the code, i.e. to
    atomically add/remove to the list and (un)register the notifier.
    
    Fixes: 2dcd851fe4b4 ("thermal: cpu_cooling: Update always cpufreq policy with
    Reviewed-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Eduardo Valentin <edubezval@gmail.com>

commit fba9573b33f8bddd772195c202f6b8ec0751cedd
Author: Pan Xinhui <xinhuix.pan@intel.com>
Date:   Thu Jul 30 18:10:40 2015 +0800

    cpufreq: Correct a freq check in cpufreq_set_policy()
    
    This check was originally added by commit 9c9a43ed2734 ("[CPUFREQ]
    return error when failing to set minfreq").It attempt to return an error
    on obviously incorrect limits when we echo xxx >.../scaling_max,min_freq
    Actually we just need check if new_policy->min > new_policy->max.
    Because at least one of max/min is copied from cpufreq_get_policy().
    
    For example, when we echo xxx > .../scaling_min_freq, new_policy is
    copied from policy in cpufreq_get_policy. new_policy->max is same with
    policy->max. new_policy->min is set to a new value.
    
    Let me explain it in deduction method, first statement in if ():
    new_policy->min > policy->max
    policy->max == new_policy->max
    ==> new_policy->min > new_policy->max
    
    second statement in if():
    new_policy->max < policy->min
    policy->max < policy->min
    ==>new_policy->min > new_policy->max (induction method)
    
    So we have proved that we only need check if new_policy->min >
    new_policy->max.
    
    After apply this patch, we can also modify ->min and ->max at same time
    if new freq range is very much different from current freq range. For
    example, if current freq range is 480000-960000, then we want to set
    this range to 1120000-2240000, we would fail in the past because
    new_policy->min > policy->max. As long as the cpufreq range is valid, we
    has no reason to reject the user. So correct the check to avoid such
    case.
    
    Signed-off-by: Pan Xinhui <xinhuix.pan@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 4bc384ae6299d3f3a948efabda2a423e2a293ee0
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Sat Jul 18 11:31:03 2015 +0530

    cpufreq: propagate errors returned from __cpufreq_governor()
    
    Return codes aren't honored properly in cpufreq_set_policy(). This can
    lead to two problems:
    - wrong errors propagated to sysfs
    - we try to do next state-change even if the previous one failed
    
    cpufreq_governor_dbs() now returns proper errors on all invalid
    state-transition requests and this code should honor that.
    
    Reviewed-and-tested-by: Preeti U Murthy <preeti@linux.vnet.ibm.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 35afd02e30d6368073df604920c4ea7cddadf5d0
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Jul 10 01:36:27 2015 +0200

    cpufreq: Initialize the governor again while restoring policy
    
    When all CPUs of a policy are hot-unplugged, we EXIT the governor but
    don't mark policy->governor as NULL. This was done in order to keep last
    used governor's information intact in sysfs, while the CPUs are offline.
    
    But we also need to clear policy->governor when restoring the policy.
    
    Because policy->governor still points to the last governor while policy
    is restored, following sequence of event happens:
     - cpufreq_init_policy() called while restoring policy
     - find_governor() matches last_governor string for present governors and
       returns last used governor's pointer, say ondemand. policy->governor
       already has the same address, unless the governor was removed in
       between.
     - cpufreq_set_policy() is called with both old/new policies governor set
       as ondemand.
     - Because governors matched, we skip governor initialization and return
       after calling __cpufreq_governor(CPUFREQ_GOV_LIMITS). Because the
       governor wasn't initialized for this policy, it returned -EBUSY.
     - cpufreq_init_policy() exits the policy on this error, but doesn't
       destroy it properly (should be fixed separately).
     - And so we enter a scenario where the policy isn't completely
       initialized but used.
    
    Fix this by setting policy->governor to NULL while restoring the policy.
    
    Reported-and-tested-by: Pi-Cheng Chen <pi-cheng.chen@linaro.org>
    Reported-and-tested-by: "Jon Medhurst (Tixy)" <tixy@linaro.org>
    Reported-and-tested-by: Steven Rostedt <rostedt@goodmis.org>
    Fixes: 18bf3a124ef8 (cpufreq: Mark policy->governor = NULL for inactive policies)
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 1edf5ca166be9dadbcb4c3fab3e8400ac73a0a5e
Author: Ethan Zhao <ethan.zhao@oracle.com>
Date:   Thu Dec 18 15:28:19 2014 +0900

    cpufreq: fix a NULL pointer dereference in __cpufreq_governor()
    
    commit cb57720bf79688d64854a0a43565aa52303c1f3f upstream.
    
    If ACPI _PPC changed notification happens before governor was initiated
    while kernel is booting, a NULL pointer dereference will be triggered:
    
    BUG: unable to handle kernel NULL pointer dereference at 0000000000000030
     IP: [<ffffffff81470453>] __cpufreq_governor+0x23/0x1e0
     PGD 0
     Oops: 0000 [#1] SMP
     ... ...
     RIP: 0010:[<ffffffff81470453>]  [<ffffffff81470453>]
     __cpufreq_governor+0x23/0x1e0
     RSP: 0018:ffff881fcfbcfbb8  EFLAGS: 00010286
     RAX: 0000000000000000 RBX: ffff881fd11b3980 RCX: ffff88407fc20000
     RDX: 0000000000000000 RSI: 0000000000000000 RDI: ffff881fd11b3980
     RBP: ffff881fcfbcfbd8 R08: 0000000000000000 R09: 000000000000000f
     R10: ffffffff818068d0 R11: 0000000000000043 R12: 0000000000000004
     R13: 0000000000000000 R14: ffffffff8196cae0 R15: 0000000000000000
     FS:  0000000000000000(0000) GS:ffff881fffc00000(0000) knlGS:0000000000000000
     CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
     CR2: 0000000000000030 CR3: 00000000018ae000 CR4: 00000000000407f0
     DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
     DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400
     Process kworker/0:3 (pid: 750, threadinfo ffff881fcfbce000, task
     ffff881fcf556400)
     Stack:
      ffff881fffc17d00 ffff881fcfbcfc18 ffff881fd11b3980 0000000000000000
      ffff881fcfbcfc08 ffffffff81470d08 ffff881fd11b3980 0000000000000007
      ffff881fcfbcfc18 ffff881fffc17d00 ffff881fcfbcfd28 ffffffff81472e9a
     Call Trace:
      [<ffffffff81470d08>] __cpufreq_set_policy+0x1b8/0x2e0
      [<ffffffff81472e9a>] cpufreq_update_policy+0xca/0x150
      [<ffffffff81472f20>] ? cpufreq_update_policy+0x150/0x150
      [<ffffffff81324a96>] acpi_processor_ppc_has_changed+0x71/0x7b
      [<ffffffff81320bcd>] acpi_processor_notify+0x55/0x115
      [<ffffffff812f9c29>] acpi_device_notify+0x19/0x1b
      [<ffffffff813084ca>] acpi_ev_notify_dispatch+0x41/0x5f
      [<ffffffff812f64a4>] acpi_os_execute_deferred+0x27/0x34
    
    The root cause is a race conditon -- cpufreq core and acpi-cpufreq driver
    were initiated, but cpufreq_governor wasn't and _PPC changed notification
    happened, __cpufreq_governor() was called within acpi_os_execute_deferred
    kernel thread context.
    
    To fix this panic issue, add pointer checking code in __cpufreq_governor()
    before pointer policy->governor is to be dereferenced.
    
    Signed-off-by: Ethan Zhao <ethan.zhao@oracle.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Luis Henriques <luis.henriques@canonical.com>

commit e4c218429fb3752cabf96724d60cbeba85e35eb2
Author: Ethan Zhao <ethan.zhao@oracle.com>
Date:   Thu Dec 18 15:28:19 2014 +0900

    cpufreq: fix a NULL pointer dereference in __cpufreq_governor()
    
    commit cb57720bf79688d64854a0a43565aa52303c1f3f upstream.
    
    If ACPI _PPC changed notification happens before governor was initiated
    while kernel is booting, a NULL pointer dereference will be triggered:
    
    BUG: unable to handle kernel NULL pointer dereference at 0000000000000030
     IP: [<ffffffff81470453>] __cpufreq_governor+0x23/0x1e0
     PGD 0
     Oops: 0000 [#1] SMP
     ... ...
     RIP: 0010:[<ffffffff81470453>]  [<ffffffff81470453>]
     __cpufreq_governor+0x23/0x1e0
     RSP: 0018:ffff881fcfbcfbb8  EFLAGS: 00010286
     RAX: 0000000000000000 RBX: ffff881fd11b3980 RCX: ffff88407fc20000
     RDX: 0000000000000000 RSI: 0000000000000000 RDI: ffff881fd11b3980
     RBP: ffff881fcfbcfbd8 R08: 0000000000000000 R09: 000000000000000f
     R10: ffffffff818068d0 R11: 0000000000000043 R12: 0000000000000004
     R13: 0000000000000000 R14: ffffffff8196cae0 R15: 0000000000000000
     FS:  0000000000000000(0000) GS:ffff881fffc00000(0000) knlGS:0000000000000000
     CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
     CR2: 0000000000000030 CR3: 00000000018ae000 CR4: 00000000000407f0
     DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
     DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400
     Process kworker/0:3 (pid: 750, threadinfo ffff881fcfbce000, task
     ffff881fcf556400)
     Stack:
      ffff881fffc17d00 ffff881fcfbcfc18 ffff881fd11b3980 0000000000000000
      ffff881fcfbcfc08 ffffffff81470d08 ffff881fd11b3980 0000000000000007
      ffff881fcfbcfc18 ffff881fffc17d00 ffff881fcfbcfd28 ffffffff81472e9a
     Call Trace:
      [<ffffffff81470d08>] __cpufreq_set_policy+0x1b8/0x2e0
      [<ffffffff81472e9a>] cpufreq_update_policy+0xca/0x150
      [<ffffffff81472f20>] ? cpufreq_update_policy+0x150/0x150
      [<ffffffff81324a96>] acpi_processor_ppc_has_changed+0x71/0x7b
      [<ffffffff81320bcd>] acpi_processor_notify+0x55/0x115
      [<ffffffff812f9c29>] acpi_device_notify+0x19/0x1b
      [<ffffffff813084ca>] acpi_ev_notify_dispatch+0x41/0x5f
      [<ffffffff812f64a4>] acpi_os_execute_deferred+0x27/0x34
    
    The root cause is a race conditon -- cpufreq core and acpi-cpufreq driver
    were initiated, but cpufreq_governor wasn't and _PPC changed notification
    happened, __cpufreq_governor() was called within acpi_os_execute_deferred
    kernel thread context.
    
    To fix this panic issue, add pointer checking code in __cpufreq_governor()
    before pointer policy->governor is to be dereferenced.
    
    Signed-off-by: Ethan Zhao <ethan.zhao@oracle.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>

commit cb57720bf79688d64854a0a43565aa52303c1f3f
Author: Ethan Zhao <ethan.zhao@oracle.com>
Date:   Thu Dec 18 15:28:19 2014 +0900

    cpufreq: fix a NULL pointer dereference in __cpufreq_governor()
    
    If ACPI _PPC changed notification happens before governor was initiated
    while kernel is booting, a NULL pointer dereference will be triggered:
    
    BUG: unable to handle kernel NULL pointer dereference at 0000000000000030
     IP: [<ffffffff81470453>] __cpufreq_governor+0x23/0x1e0
     PGD 0
     Oops: 0000 [#1] SMP
     ... ...
     RIP: 0010:[<ffffffff81470453>]  [<ffffffff81470453>]
     __cpufreq_governor+0x23/0x1e0
     RSP: 0018:ffff881fcfbcfbb8  EFLAGS: 00010286
     RAX: 0000000000000000 RBX: ffff881fd11b3980 RCX: ffff88407fc20000
     RDX: 0000000000000000 RSI: 0000000000000000 RDI: ffff881fd11b3980
     RBP: ffff881fcfbcfbd8 R08: 0000000000000000 R09: 000000000000000f
     R10: ffffffff818068d0 R11: 0000000000000043 R12: 0000000000000004
     R13: 0000000000000000 R14: ffffffff8196cae0 R15: 0000000000000000
     FS:  0000000000000000(0000) GS:ffff881fffc00000(0000) knlGS:0000000000000000
     CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
     CR2: 0000000000000030 CR3: 00000000018ae000 CR4: 00000000000407f0
     DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
     DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400
     Process kworker/0:3 (pid: 750, threadinfo ffff881fcfbce000, task
     ffff881fcf556400)
     Stack:
      ffff881fffc17d00 ffff881fcfbcfc18 ffff881fd11b3980 0000000000000000
      ffff881fcfbcfc08 ffffffff81470d08 ffff881fd11b3980 0000000000000007
      ffff881fcfbcfc18 ffff881fffc17d00 ffff881fcfbcfd28 ffffffff81472e9a
     Call Trace:
      [<ffffffff81470d08>] __cpufreq_set_policy+0x1b8/0x2e0
      [<ffffffff81472e9a>] cpufreq_update_policy+0xca/0x150
      [<ffffffff81472f20>] ? cpufreq_update_policy+0x150/0x150
      [<ffffffff81324a96>] acpi_processor_ppc_has_changed+0x71/0x7b
      [<ffffffff81320bcd>] acpi_processor_notify+0x55/0x115
      [<ffffffff812f9c29>] acpi_device_notify+0x19/0x1b
      [<ffffffff813084ca>] acpi_ev_notify_dispatch+0x41/0x5f
      [<ffffffff812f64a4>] acpi_os_execute_deferred+0x27/0x34
    
    The root cause is a race conditon -- cpufreq core and acpi-cpufreq driver
    were initiated, but cpufreq_governor wasn't and _PPC changed notification
    happened, __cpufreq_governor() was called within acpi_os_execute_deferred
    kernel thread context.
    
    To fix this panic issue, add pointer checking code in __cpufreq_governor()
    before pointer policy->governor is to be dereferenced.
    
    Signed-off-by: Ethan Zhao <ethan.zhao@oracle.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 619c144c84bd240487204e91dff88247cde68d92
Author: Vince Hsu <vinceh@nvidia.com>
Date:   Mon Nov 10 14:14:50 2014 +0800

    cpufreq: respect the min/max settings from user space
    
    When the user space tries to set scaling_(max|min)_freq through
    sysfs, the cpufreq_set_policy() asks other driver's opinions
    for the max/min frequencies. Some device drivers, like Tegra
    CPU EDP which is not upstreamed yet though, may constrain the
    CPU maximum frequency dynamically because of board design.
    So if the user space access happens and some driver is capping
    the cpu frequency at the same time, the user_policy->(max|min)
    is overridden by the capped value, and that's not expected by
    the user space. And if the user space is not invoked again,
    the CPU will always be capped by the user_policy->(max|min)
    even no drivers limit the CPU frequency any more.
    
    This patch preserves the user specified min/max settings, so that
    every time the cpufreq policy is updated, the new max/min can
    be re-evaluated correctly based on the user's expection and
    the present device drivers' status.
    
    Signed-off-by: Vince Hsu <vinceh@nvidia.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 9346dc9c64f7a4b712d3cc11092c69db479796b0
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Sep 27 21:56:08 2014 +0200

    cpufreq: pcc-cpufreq: Fix wait_event() under spinlock
    
    commit e65b5ddba84634f31d42dfd86013f4c6be5e9e32 upstream.
    
    Fix the following bug introduced by commit 8fec051eea73 (cpufreq:
    Convert existing drivers to use cpufreq_freq_transition_{begin|end})
    that forgot to move the spin_lock() in pcc_cpufreq_target() past
    cpufreq_freq_transition_begin() which calls wait_event():
    
    BUG: sleeping function called from invalid context at drivers/cpufreq/cpufreq.c:370
    in_atomic(): 1, irqs_disabled(): 0, pid: 2636, name: modprobe
    Preemption disabled at:[<ffffffffa04d74d7>] pcc_cpufreq_target+0x27/0x200 [pcc_cpufreq]
    [   51.025044]
    CPU: 57 PID: 2636 Comm: modprobe Tainted: G            E  3.17.0-default #7
    Hardware name: Hewlett-Packard ProLiant DL980 G7, BIOS P66 07/07/2010
     00000000ffffffff ffff88026c46b828 ffffffff81589dbd 0000000000000000
     ffff880037978090 ffff88026c46b848 ffffffff8108e1df ffff880037978090
     0000000000000000 ffff88026c46b878 ffffffff8108e298 ffff88026d73ec00
    Call Trace:
     [<ffffffff81589dbd>] dump_stack+0x4d/0x90
     [<ffffffff8108e1df>] ___might_sleep+0x10f/0x180
     [<ffffffff8108e298>] __might_sleep+0x48/0xd0
     [<ffffffff8145b905>] cpufreq_freq_transition_begin+0x75/0x140 drivers/cpufreq/cpufreq.c:370 wait_event(policy->transition_wait, !policy->transition_ongoing);
     [<ffffffff8108fc99>] ? preempt_count_add+0xb9/0xc0
     [<ffffffffa04d7513>] pcc_cpufreq_target+0x63/0x200 [pcc_cpufreq] drivers/cpufreq/pcc-cpufreq.c:207 spin_lock(&pcc_lock);
     [<ffffffff810e0d0f>] ? update_ts_time_stats+0x7f/0xb0
     [<ffffffff8145be55>] __cpufreq_driver_target+0x85/0x170
     [<ffffffff8145e4c8>] od_check_cpu+0xa8/0xb0
     [<ffffffff8145ef10>] dbs_check_cpu+0x180/0x1d0
     [<ffffffff8145f310>] cpufreq_governor_dbs+0x3b0/0x720
     [<ffffffff8145ebe3>] od_cpufreq_governor_dbs+0x33/0xe0
     [<ffffffff814593d9>] __cpufreq_governor+0xa9/0x210
     [<ffffffff81459fb2>] cpufreq_set_policy+0x1e2/0x2e0
     [<ffffffff8145a6cc>] cpufreq_init_policy+0x8c/0x110
     [<ffffffff8145c9a0>] ? cpufreq_update_policy+0x1b0/0x1b0
     [<ffffffff8108fb99>] ? preempt_count_sub+0xb9/0x100
     [<ffffffff8145c6c6>] __cpufreq_add_dev+0x596/0x6b0
     [<ffffffffa016c608>] ? pcc_cpufreq_probe+0x4b4/0x4b4 [pcc_cpufreq]
     [<ffffffff8145c7ee>] cpufreq_add_dev+0xe/0x10
     [<ffffffff81408e81>] subsys_interface_register+0xc1/0xf0
     [<ffffffff8108fb99>] ? preempt_count_sub+0xb9/0x100
     [<ffffffff8145b3d7>] cpufreq_register_driver+0x117/0x2a0
     [<ffffffffa016c65d>] pcc_cpufreq_init+0x55/0x9f8 [pcc_cpufreq]
     [<ffffffffa016c608>] ? pcc_cpufreq_probe+0x4b4/0x4b4 [pcc_cpufreq]
     [<ffffffff81000298>] do_one_initcall+0xc8/0x1f0
     [<ffffffff811a731d>] ? __vunmap+0x9d/0x100
     [<ffffffff810eb9a0>] do_init_module+0x30/0x1b0
     [<ffffffff810edfa6>] load_module+0x686/0x710
     [<ffffffff810ebb20>] ? do_init_module+0x1b0/0x1b0
     [<ffffffff810ee1db>] SyS_init_module+0x9b/0xc0
     [<ffffffff8158f7a9>] system_call_fastpath+0x16/0x1b
    
    Fixes: 8fec051eea73 (cpufreq: Convert existing drivers to use cpufreq_freq_transition_{begin|end})
    Reported-and-tested-by: Mike Galbraith <umgwanakikbuti@gmail.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit e65b5ddba84634f31d42dfd86013f4c6be5e9e32
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Sep 27 21:56:08 2014 +0200

    cpufreq: pcc-cpufreq: Fix wait_event() under spinlock
    
    Fix the following bug introduced by commit 8fec051eea73 (cpufreq:
    Convert existing drivers to use cpufreq_freq_transition_{begin|end})
    that forgot to move the spin_lock() in pcc_cpufreq_target() past
    cpufreq_freq_transition_begin() which calls wait_event():
    
    BUG: sleeping function called from invalid context at drivers/cpufreq/cpufreq.c:370
    in_atomic(): 1, irqs_disabled(): 0, pid: 2636, name: modprobe
    Preemption disabled at:[<ffffffffa04d74d7>] pcc_cpufreq_target+0x27/0x200 [pcc_cpufreq]
    [   51.025044]
    CPU: 57 PID: 2636 Comm: modprobe Tainted: G            E  3.17.0-default #7
    Hardware name: Hewlett-Packard ProLiant DL980 G7, BIOS P66 07/07/2010
     00000000ffffffff ffff88026c46b828 ffffffff81589dbd 0000000000000000
     ffff880037978090 ffff88026c46b848 ffffffff8108e1df ffff880037978090
     0000000000000000 ffff88026c46b878 ffffffff8108e298 ffff88026d73ec00
    Call Trace:
     [<ffffffff81589dbd>] dump_stack+0x4d/0x90
     [<ffffffff8108e1df>] ___might_sleep+0x10f/0x180
     [<ffffffff8108e298>] __might_sleep+0x48/0xd0
     [<ffffffff8145b905>] cpufreq_freq_transition_begin+0x75/0x140 drivers/cpufreq/cpufreq.c:370 wait_event(policy->transition_wait, !policy->transition_ongoing);
     [<ffffffff8108fc99>] ? preempt_count_add+0xb9/0xc0
     [<ffffffffa04d7513>] pcc_cpufreq_target+0x63/0x200 [pcc_cpufreq] drivers/cpufreq/pcc-cpufreq.c:207 spin_lock(&pcc_lock);
     [<ffffffff810e0d0f>] ? update_ts_time_stats+0x7f/0xb0
     [<ffffffff8145be55>] __cpufreq_driver_target+0x85/0x170
     [<ffffffff8145e4c8>] od_check_cpu+0xa8/0xb0
     [<ffffffff8145ef10>] dbs_check_cpu+0x180/0x1d0
     [<ffffffff8145f310>] cpufreq_governor_dbs+0x3b0/0x720
     [<ffffffff8145ebe3>] od_cpufreq_governor_dbs+0x33/0xe0
     [<ffffffff814593d9>] __cpufreq_governor+0xa9/0x210
     [<ffffffff81459fb2>] cpufreq_set_policy+0x1e2/0x2e0
     [<ffffffff8145a6cc>] cpufreq_init_policy+0x8c/0x110
     [<ffffffff8145c9a0>] ? cpufreq_update_policy+0x1b0/0x1b0
     [<ffffffff8108fb99>] ? preempt_count_sub+0xb9/0x100
     [<ffffffff8145c6c6>] __cpufreq_add_dev+0x596/0x6b0
     [<ffffffffa016c608>] ? pcc_cpufreq_probe+0x4b4/0x4b4 [pcc_cpufreq]
     [<ffffffff8145c7ee>] cpufreq_add_dev+0xe/0x10
     [<ffffffff81408e81>] subsys_interface_register+0xc1/0xf0
     [<ffffffff8108fb99>] ? preempt_count_sub+0xb9/0x100
     [<ffffffff8145b3d7>] cpufreq_register_driver+0x117/0x2a0
     [<ffffffffa016c65d>] pcc_cpufreq_init+0x55/0x9f8 [pcc_cpufreq]
     [<ffffffffa016c608>] ? pcc_cpufreq_probe+0x4b4/0x4b4 [pcc_cpufreq]
     [<ffffffff81000298>] do_one_initcall+0xc8/0x1f0
     [<ffffffff811a731d>] ? __vunmap+0x9d/0x100
     [<ffffffff810eb9a0>] do_init_module+0x30/0x1b0
     [<ffffffff810edfa6>] load_module+0x686/0x710
     [<ffffffff810ebb20>] ? do_init_module+0x1b0/0x1b0
     [<ffffffff810ee1db>] SyS_init_module+0x9b/0xc0
     [<ffffffff8158f7a9>] system_call_fastpath+0x16/0x1b
    
    Fixes: 8fec051eea73 (cpufreq: Convert existing drivers to use cpufreq_freq_transition_{begin|end})
    Reported-and-tested-by: Mike Galbraith <umgwanakikbuti@gmail.com>
    Cc: 3.15+ <stable@vger.kernel.org> # 3.15+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 3ddbd9a2d572434bd5b63757a70d9532c0027de7
Author: Bibek Basu <bbasu@nvidia.com>
Date:   Mon May 19 10:24:01 2014 +0530

    cpufreq: remove race while accessing cur_policy
    
    commit c5450db85b828d0c46ac8fc570fb8a51bf07ac40 upstream.
    
    While accessing cur_policy during executing events
    CPUFREQ_GOV_START, CPUFREQ_GOV_STOP, CPUFREQ_GOV_LIMITS,
    same mutex lock is not taken, dbs_data->mutex, which leads
    to race and data corruption while running continious suspend
    resume test. This is seen with ondemand governor with suspend
    resume test using rtcwake.
    
     Unable to handle kernel NULL pointer dereference at virtual address 00000028
     pgd = ed610000
     [00000028] *pgd=adf11831, *pte=00000000, *ppte=00000000
     Internal error: Oops: 17 [#1] PREEMPT SMP ARM
     Modules linked in: nvhost_vi
     CPU: 1 PID: 3243 Comm: rtcwake Not tainted 3.10.24-gf5cf9e5 #1
     task: ee708040 ti: ed61c000 task.ti: ed61c000
     PC is at cpufreq_governor_dbs+0x400/0x634
     LR is at cpufreq_governor_dbs+0x3f8/0x634
     pc : [<c05652b8>] lr : [<c05652b0>] psr: 600f0013
     sp : ed61dcb0 ip : 000493e0 fp : c1cc14f0
     r10: 00000000 r9 : 00000000 r8 : 00000000
     r7 : eb725280 r6 : c1cc1560 r5 : eb575200 r4 : ebad7740
     r3 : ee708040 r2 : ed61dca8 r1 : 001ebd24 r0 : 00000000
     Flags: nZCv IRQs on FIQs on Mode SVC_32 ISA ARM Segment user
     Control: 10c5387d Table: ad61006a DAC: 00000015
     [<c05652b8>] (cpufreq_governor_dbs+0x400/0x634) from [<c055f700>] (__cpufreq_governor+0x98/0x1b4)
     [<c055f700>] (__cpufreq_governor+0x98/0x1b4) from [<c0560770>] (__cpufreq_set_policy+0x250/0x320)
     [<c0560770>] (__cpufreq_set_policy+0x250/0x320) from [<c0561dcc>] (cpufreq_update_policy+0xcc/0x168)
     [<c0561dcc>] (cpufreq_update_policy+0xcc/0x168) from [<c0561ed0>] (cpu_freq_notify+0x68/0xdc)
     [<c0561ed0>] (cpu_freq_notify+0x68/0xdc) from [<c008eff8>] (notifier_call_chain+0x4c/0x8c)
     [<c008eff8>] (notifier_call_chain+0x4c/0x8c) from [<c008f3d4>] (__blocking_notifier_call_chain+0x50/0x68)
     [<c008f3d4>] (__blocking_notifier_call_chain+0x50/0x68) from [<c008f40c>] (blocking_notifier_call_chain+0x20/0x28)
     [<c008f40c>] (blocking_notifier_call_chain+0x20/0x28) from [<c00aac6c>] (pm_qos_update_bounded_target+0xd8/0x310)
     [<c00aac6c>] (pm_qos_update_bounded_target+0xd8/0x310) from [<c00ab3b0>] (__pm_qos_update_request+0x64/0x70)
     [<c00ab3b0>] (__pm_qos_update_request+0x64/0x70) from [<c004b4b8>] (tegra_pm_notify+0x114/0x134)
     [<c004b4b8>] (tegra_pm_notify+0x114/0x134) from [<c008eff8>] (notifier_call_chain+0x4c/0x8c)
     [<c008eff8>] (notifier_call_chain+0x4c/0x8c) from [<c008f3d4>] (__blocking_notifier_call_chain+0x50/0x68)
     [<c008f3d4>] (__blocking_notifier_call_chain+0x50/0x68) from [<c008f40c>] (blocking_notifier_call_chain+0x20/0x28)
     [<c008f40c>] (blocking_notifier_call_chain+0x20/0x28) from [<c00ac228>] (pm_notifier_call_chain+0x1c/0x34)
     [<c00ac228>] (pm_notifier_call_chain+0x1c/0x34) from [<c00ad38c>] (enter_state+0xec/0x128)
     [<c00ad38c>] (enter_state+0xec/0x128) from [<c00ad400>] (pm_suspend+0x38/0xa4)
     [<c00ad400>] (pm_suspend+0x38/0xa4) from [<c00ac114>] (state_store+0x70/0xc0)
     [<c00ac114>] (state_store+0x70/0xc0) from [<c027b1e8>] (kobj_attr_store+0x14/0x20)
     [<c027b1e8>] (kobj_attr_store+0x14/0x20) from [<c019cd9c>] (sysfs_write_file+0x104/0x184)
     [<c019cd9c>] (sysfs_write_file+0x104/0x184) from [<c0143038>] (vfs_write+0xd0/0x19c)
     [<c0143038>] (vfs_write+0xd0/0x19c) from [<c0143414>] (SyS_write+0x4c/0x78)
     [<c0143414>] (SyS_write+0x4c/0x78) from [<c000f080>] (ret_fast_syscall+0x0/0x30)
     Code: e1a00006 eb084346 e59b0020 e5951024 (e5903028)
     ---[ end trace 0488523c8f6b0f9d ]---
    
    Signed-off-by: Bibek Basu <bbasu@nvidia.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>

commit 89571e8509f62d950715faca2251eb2273b530a0
Author: Bibek Basu <bbasu@nvidia.com>
Date:   Mon May 19 10:24:01 2014 +0530

    cpufreq: remove race while accessing cur_policy
    
    commit c5450db85b828d0c46ac8fc570fb8a51bf07ac40 upstream.
    
    While accessing cur_policy during executing events
    CPUFREQ_GOV_START, CPUFREQ_GOV_STOP, CPUFREQ_GOV_LIMITS,
    same mutex lock is not taken, dbs_data->mutex, which leads
    to race and data corruption while running continious suspend
    resume test. This is seen with ondemand governor with suspend
    resume test using rtcwake.
    
     Unable to handle kernel NULL pointer dereference at virtual address 00000028
     pgd = ed610000
     [00000028] *pgd=adf11831, *pte=00000000, *ppte=00000000
     Internal error: Oops: 17 [#1] PREEMPT SMP ARM
     Modules linked in: nvhost_vi
     CPU: 1 PID: 3243 Comm: rtcwake Not tainted 3.10.24-gf5cf9e5 #1
     task: ee708040 ti: ed61c000 task.ti: ed61c000
     PC is at cpufreq_governor_dbs+0x400/0x634
     LR is at cpufreq_governor_dbs+0x3f8/0x634
     pc : [<c05652b8>] lr : [<c05652b0>] psr: 600f0013
     sp : ed61dcb0 ip : 000493e0 fp : c1cc14f0
     r10: 00000000 r9 : 00000000 r8 : 00000000
     r7 : eb725280 r6 : c1cc1560 r5 : eb575200 r4 : ebad7740
     r3 : ee708040 r2 : ed61dca8 r1 : 001ebd24 r0 : 00000000
     Flags: nZCv IRQs on FIQs on Mode SVC_32 ISA ARM Segment user
     Control: 10c5387d Table: ad61006a DAC: 00000015
     [<c05652b8>] (cpufreq_governor_dbs+0x400/0x634) from [<c055f700>] (__cpufreq_governor+0x98/0x1b4)
     [<c055f700>] (__cpufreq_governor+0x98/0x1b4) from [<c0560770>] (__cpufreq_set_policy+0x250/0x320)
     [<c0560770>] (__cpufreq_set_policy+0x250/0x320) from [<c0561dcc>] (cpufreq_update_policy+0xcc/0x168)
     [<c0561dcc>] (cpufreq_update_policy+0xcc/0x168) from [<c0561ed0>] (cpu_freq_notify+0x68/0xdc)
     [<c0561ed0>] (cpu_freq_notify+0x68/0xdc) from [<c008eff8>] (notifier_call_chain+0x4c/0x8c)
     [<c008eff8>] (notifier_call_chain+0x4c/0x8c) from [<c008f3d4>] (__blocking_notifier_call_chain+0x50/0x68)
     [<c008f3d4>] (__blocking_notifier_call_chain+0x50/0x68) from [<c008f40c>] (blocking_notifier_call_chain+0x20/0x28)
     [<c008f40c>] (blocking_notifier_call_chain+0x20/0x28) from [<c00aac6c>] (pm_qos_update_bounded_target+0xd8/0x310)
     [<c00aac6c>] (pm_qos_update_bounded_target+0xd8/0x310) from [<c00ab3b0>] (__pm_qos_update_request+0x64/0x70)
     [<c00ab3b0>] (__pm_qos_update_request+0x64/0x70) from [<c004b4b8>] (tegra_pm_notify+0x114/0x134)
     [<c004b4b8>] (tegra_pm_notify+0x114/0x134) from [<c008eff8>] (notifier_call_chain+0x4c/0x8c)
     [<c008eff8>] (notifier_call_chain+0x4c/0x8c) from [<c008f3d4>] (__blocking_notifier_call_chain+0x50/0x68)
     [<c008f3d4>] (__blocking_notifier_call_chain+0x50/0x68) from [<c008f40c>] (blocking_notifier_call_chain+0x20/0x28)
     [<c008f40c>] (blocking_notifier_call_chain+0x20/0x28) from [<c00ac228>] (pm_notifier_call_chain+0x1c/0x34)
     [<c00ac228>] (pm_notifier_call_chain+0x1c/0x34) from [<c00ad38c>] (enter_state+0xec/0x128)
     [<c00ad38c>] (enter_state+0xec/0x128) from [<c00ad400>] (pm_suspend+0x38/0xa4)
     [<c00ad400>] (pm_suspend+0x38/0xa4) from [<c00ac114>] (state_store+0x70/0xc0)
     [<c00ac114>] (state_store+0x70/0xc0) from [<c027b1e8>] (kobj_attr_store+0x14/0x20)
     [<c027b1e8>] (kobj_attr_store+0x14/0x20) from [<c019cd9c>] (sysfs_write_file+0x104/0x184)
     [<c019cd9c>] (sysfs_write_file+0x104/0x184) from [<c0143038>] (vfs_write+0xd0/0x19c)
     [<c0143038>] (vfs_write+0xd0/0x19c) from [<c0143414>] (SyS_write+0x4c/0x78)
     [<c0143414>] (SyS_write+0x4c/0x78) from [<c000f080>] (ret_fast_syscall+0x0/0x30)
     Code: e1a00006 eb084346 e59b0020 e5951024 (e5903028)
     ---[ end trace 0488523c8f6b0f9d ]---
    
    Signed-off-by: Bibek Basu <bbasu@nvidia.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit c5450db85b828d0c46ac8fc570fb8a51bf07ac40
Author: Bibek Basu <bbasu@nvidia.com>
Date:   Mon May 19 10:24:01 2014 +0530

    cpufreq: remove race while accessing cur_policy
    
    While accessing cur_policy during executing events
    CPUFREQ_GOV_START, CPUFREQ_GOV_STOP, CPUFREQ_GOV_LIMITS,
    same mutex lock is not taken, dbs_data->mutex, which leads
    to race and data corruption while running continious suspend
    resume test. This is seen with ondemand governor with suspend
    resume test using rtcwake.
    
     Unable to handle kernel NULL pointer dereference at virtual address 00000028
     pgd = ed610000
     [00000028] *pgd=adf11831, *pte=00000000, *ppte=00000000
     Internal error: Oops: 17 [#1] PREEMPT SMP ARM
     Modules linked in: nvhost_vi
     CPU: 1 PID: 3243 Comm: rtcwake Not tainted 3.10.24-gf5cf9e5 #1
     task: ee708040 ti: ed61c000 task.ti: ed61c000
     PC is at cpufreq_governor_dbs+0x400/0x634
     LR is at cpufreq_governor_dbs+0x3f8/0x634
     pc : [<c05652b8>] lr : [<c05652b0>] psr: 600f0013
     sp : ed61dcb0 ip : 000493e0 fp : c1cc14f0
     r10: 00000000 r9 : 00000000 r8 : 00000000
     r7 : eb725280 r6 : c1cc1560 r5 : eb575200 r4 : ebad7740
     r3 : ee708040 r2 : ed61dca8 r1 : 001ebd24 r0 : 00000000
     Flags: nZCv IRQs on FIQs on Mode SVC_32 ISA ARM Segment user
     Control: 10c5387d Table: ad61006a DAC: 00000015
     [<c05652b8>] (cpufreq_governor_dbs+0x400/0x634) from [<c055f700>] (__cpufreq_governor+0x98/0x1b4)
     [<c055f700>] (__cpufreq_governor+0x98/0x1b4) from [<c0560770>] (__cpufreq_set_policy+0x250/0x320)
     [<c0560770>] (__cpufreq_set_policy+0x250/0x320) from [<c0561dcc>] (cpufreq_update_policy+0xcc/0x168)
     [<c0561dcc>] (cpufreq_update_policy+0xcc/0x168) from [<c0561ed0>] (cpu_freq_notify+0x68/0xdc)
     [<c0561ed0>] (cpu_freq_notify+0x68/0xdc) from [<c008eff8>] (notifier_call_chain+0x4c/0x8c)
     [<c008eff8>] (notifier_call_chain+0x4c/0x8c) from [<c008f3d4>] (__blocking_notifier_call_chain+0x50/0x68)
     [<c008f3d4>] (__blocking_notifier_call_chain+0x50/0x68) from [<c008f40c>] (blocking_notifier_call_chain+0x20/0x28)
     [<c008f40c>] (blocking_notifier_call_chain+0x20/0x28) from [<c00aac6c>] (pm_qos_update_bounded_target+0xd8/0x310)
     [<c00aac6c>] (pm_qos_update_bounded_target+0xd8/0x310) from [<c00ab3b0>] (__pm_qos_update_request+0x64/0x70)
     [<c00ab3b0>] (__pm_qos_update_request+0x64/0x70) from [<c004b4b8>] (tegra_pm_notify+0x114/0x134)
     [<c004b4b8>] (tegra_pm_notify+0x114/0x134) from [<c008eff8>] (notifier_call_chain+0x4c/0x8c)
     [<c008eff8>] (notifier_call_chain+0x4c/0x8c) from [<c008f3d4>] (__blocking_notifier_call_chain+0x50/0x68)
     [<c008f3d4>] (__blocking_notifier_call_chain+0x50/0x68) from [<c008f40c>] (blocking_notifier_call_chain+0x20/0x28)
     [<c008f40c>] (blocking_notifier_call_chain+0x20/0x28) from [<c00ac228>] (pm_notifier_call_chain+0x1c/0x34)
     [<c00ac228>] (pm_notifier_call_chain+0x1c/0x34) from [<c00ad38c>] (enter_state+0xec/0x128)
     [<c00ad38c>] (enter_state+0xec/0x128) from [<c00ad400>] (pm_suspend+0x38/0xa4)
     [<c00ad400>] (pm_suspend+0x38/0xa4) from [<c00ac114>] (state_store+0x70/0xc0)
     [<c00ac114>] (state_store+0x70/0xc0) from [<c027b1e8>] (kobj_attr_store+0x14/0x20)
     [<c027b1e8>] (kobj_attr_store+0x14/0x20) from [<c019cd9c>] (sysfs_write_file+0x104/0x184)
     [<c019cd9c>] (sysfs_write_file+0x104/0x184) from [<c0143038>] (vfs_write+0xd0/0x19c)
     [<c0143038>] (vfs_write+0xd0/0x19c) from [<c0143414>] (SyS_write+0x4c/0x78)
     [<c0143414>] (SyS_write+0x4c/0x78) from [<c000f080>] (ret_fast_syscall+0x0/0x30)
     Code: e1a00006 eb084346 e59b0020 e5951024 (e5903028)
     ---[ end trace 0488523c8f6b0f9d ]---
    
    Signed-off-by: Bibek Basu <bbasu@nvidia.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Cc: 3.11+ <stable@vger.kernel.org> # 3.11+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit ba17ca46b968001df16f672ffe694fd0a12512f2
Author: Xiaoguang Chen <chenxg@marvell.com>
Date:   Wed Jun 19 15:00:07 2013 +0800

    cpufreq: Fix governor start/stop race condition
    
    commit 95731ebb114c5f0c028459388560fc2a72fe5049 upstream.
    
    Cpufreq governors' stop and start operations should be carried out
    in sequence.  Otherwise, there will be unexpected behavior, like in
    the example below.
    
    Suppose there are 4 CPUs and policy->cpu=CPU0, CPU1/2/3 are linked
    to CPU0.  The normal sequence is:
    
     1) Current governor is userspace.  An application tries to set the
        governor to ondemand.  It will call __cpufreq_set_policy() in
        which it will stop the userspace governor and then start the
        ondemand governor.
    
     2) Current governor is userspace.  The online of CPU3 runs on CPU0.
        It will call cpufreq_add_policy_cpu() in which it will first
        stop the userspace governor, and then start it again.
    
    If the sequence of the above two cases interleaves, it becomes:
    
     1) Application stops userspace governor
     2)                                  Hotplug stops userspace governor
    
    which is a problem, because the governor shouldn't be stopped twice
    in a row.  What happens next is:
    
     3) Application starts ondemand governor
     4)                                  Hotplug starts a governor
    
    In step 4, the hotplug is supposed to start the userspace governor,
    but now the governor has been changed by the application to ondemand,
    so the ondemand governor is started once again, which is incorrect.
    
    The solution is to prevent policy governors from being stopped
    multiple times in a row.  A governor should only be stopped once for
    one policy.  After it has been stopped, no more governor stop
    operations should be executed.
    
    Also add a mutex to serialize governor operations.
    
    [rjw: Changelog.  And you owe me a beverage of my choice.]
    Signed-off-by: Xiaoguang Chen <chenxg@marvell.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 1bfb1772bd0368d2220c1bc6314c04527295a3bb
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Mar 12 21:49:33 2014 +0100

    cpufreq: Skip current frequency initialization for ->setpolicy drivers
    
    commit 2ed99e39cb9392312c100d9da591c20641c64d12 upstream.
    
    After commit da60ce9f2fac (cpufreq: call cpufreq_driver->get() after
    calling ->init()) __cpufreq_add_dev() sometimes fails for CPUs handled
    by intel_pstate, because that driver may return 0 from its ->get()
    callback if it has not run long enough to collect enough samples on the
    given CPU.  That didn't happen before commit da60ce9f2fac which added
    policy->cur initialization to __cpufreq_add_dev() to help reduce code
    duplication in other cpufreq drivers.
    
    However, the code added by commit da60ce9f2fac need not be executed
    for cpufreq drivers having the ->setpolicy callback defined, because
    the subsequent invocation of cpufreq_set_policy() will use that
    callback to initialize the policy anyway and it doesn't need
    policy->cur to be initialized upfront.  The analogous code in
    cpufreq_update_policy() is also unnecessary for cpufreq drivers
    having ->setpolicy set and may be skipped for them as well.
    
    Since intel_pstate provides ->setpolicy, skipping the upfront
    policy->cur initialization for cpufreq drivers with that callback
    set will cover intel_pstate and the problem it's been having after
    commit da60ce9f2fac will be addressed.
    
    Fixes: da60ce9f2fac (cpufreq: call cpufreq_driver->get() after calling ->init())
    References: https://bugzilla.kernel.org/show_bug.cgi?id=71931
    Reported-and-tested-by: Patrik Lundquist <patrik.lundquist@gmail.com>
    Acked-by: Dirk Brandewie <dirk.j.brandewie@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 2ed99e39cb9392312c100d9da591c20641c64d12
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Mar 12 21:49:33 2014 +0100

    cpufreq: Skip current frequency initialization for ->setpolicy drivers
    
    After commit da60ce9f2fac (cpufreq: call cpufreq_driver->get() after
    calling ->init()) __cpufreq_add_dev() sometimes fails for CPUs handled
    by intel_pstate, because that driver may return 0 from its ->get()
    callback if it has not run long enough to collect enough samples on the
    given CPU.  That didn't happen before commit da60ce9f2fac which added
    policy->cur initialization to __cpufreq_add_dev() to help reduce code
    duplication in other cpufreq drivers.
    
    However, the code added by commit da60ce9f2fac need not be executed
    for cpufreq drivers having the ->setpolicy callback defined, because
    the subsequent invocation of cpufreq_set_policy() will use that
    callback to initialize the policy anyway and it doesn't need
    policy->cur to be initialized upfront.  The analogous code in
    cpufreq_update_policy() is also unnecessary for cpufreq drivers
    having ->setpolicy set and may be skipped for them as well.
    
    Since intel_pstate provides ->setpolicy, skipping the upfront
    policy->cur initialization for cpufreq drivers with that callback
    set will cover intel_pstate and the problem it's been having after
    commit da60ce9f2fac will be addressed.
    
    Fixes: da60ce9f2fac (cpufreq: call cpufreq_driver->get() after calling ->init())
    References: https://bugzilla.kernel.org/show_bug.cgi?id=71931
    Reported-and-tested-by: Patrik Lundquist <patrik.lundquist@gmail.com>
    Acked-by: Dirk Brandewie <dirk.j.brandewie@intel.com>
    Cc: 3.13+ <stable@vger.kernel.org> # 3.13+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 4e97b631f24c927b2302368f4f83efbba82076ee
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Mar 4 11:44:01 2014 +0800

    cpufreq: Initialize governor for a new policy under policy->rwsem
    
    policy->rwsem is used to lock access to all parts of code modifying
    struct cpufreq_policy, but it's not used on a new policy created by
    __cpufreq_add_dev().
    
    Because of that, if cpufreq_update_policy() is called in a tight loop
    on one CPU in parallel with offline/online of another CPU, then the
    following crash can be triggered:
    
    Unable to handle kernel NULL pointer dereference at virtual address 00000020
    pgd = c0003000
    [00000020] *pgd=80000000004003, *pmd=00000000
    Internal error: Oops: 206 [#1] PREEMPT SMP ARM
    
    PC is at __cpufreq_governor+0x10/0x1ac
    LR is at cpufreq_update_policy+0x114/0x150
    
    ---[ end trace f23a8defea6cd706 ]---
    Kernel panic - not syncing: Fatal exception
    CPU0: stopping
    CPU: 0 PID: 7136 Comm: mpdecision Tainted: G      D W    3.10.0-gd727407-00074-g979ede8 #396
    
    [<c0afe180>] (notifier_call_chain+0x40/0x68) from [<c02a23ac>] (__blocking_notifier_call_chain+0x40/0x58)
    [<c02a23ac>] (__blocking_notifier_call_chain+0x40/0x58) from [<c02a23d8>] (blocking_notifier_call_chain+0x14/0x1c)
    [<c02a23d8>] (blocking_notifier_call_chain+0x14/0x1c) from [<c0803c68>] (cpufreq_set_policy+0xd4/0x2b8)
    [<c0803c68>] (cpufreq_set_policy+0xd4/0x2b8) from [<c0803e7c>] (cpufreq_init_policy+0x30/0x98)
    [<c0803e7c>] (cpufreq_init_policy+0x30/0x98) from [<c0805a18>] (__cpufreq_add_dev.isra.17+0x4dc/0x7a4)
    [<c0805a18>] (__cpufreq_add_dev.isra.17+0x4dc/0x7a4) from [<c0805d38>] (cpufreq_cpu_callback+0x58/0x84)
    [<c0805d38>] (cpufreq_cpu_callback+0x58/0x84) from [<c0afe180>] (notifier_call_chain+0x40/0x68)
    [<c0afe180>] (notifier_call_chain+0x40/0x68) from [<c02812dc>] (__cpu_notify+0x28/0x44)
    [<c02812dc>] (__cpu_notify+0x28/0x44) from [<c0aeed90>] (_cpu_up+0xf4/0x1dc)
    [<c0aeed90>] (_cpu_up+0xf4/0x1dc) from [<c0aeeed4>] (cpu_up+0x5c/0x78)
    [<c0aeeed4>] (cpu_up+0x5c/0x78) from [<c0aec808>] (store_online+0x44/0x74)
    [<c0aec808>] (store_online+0x44/0x74) from [<c03a40f4>] (sysfs_write_file+0x108/0x14c)
    [<c03a40f4>] (sysfs_write_file+0x108/0x14c) from [<c03517d4>] (vfs_write+0xd0/0x180)
    [<c03517d4>] (vfs_write+0xd0/0x180) from [<c0351ca8>] (SyS_write+0x38/0x68)
    [<c0351ca8>] (SyS_write+0x38/0x68) from [<c0205de0>] (ret_fast_syscall+0x0/0x30)
    
    Fix that by taking locks at appropriate places in __cpufreq_add_dev()
    as well.
    
    Reported-by: Saravana Kannan <skannan@codeaurora.org>
    Suggested-by: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    [rjw: Changelog]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit d9a789c7a07e96eda7515e43932ee608dcece34d
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Feb 17 22:56:35 2014 +0100

    cpufreq: Refactor cpufreq_set_policy()
    
    Reduce the rampant usage of goto and the indentation level in
    cpufreq_set_policy() to improve the readability of that code.
    
    No functional changes should result from that.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>

commit fcd7af917abba798cd954419030142e95139359f
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Jan 7 07:10:10 2014 +0530

    cpufreq: stats: handle cpufreq_unregister_driver() and suspend/resume properly
    
    There are several problems with cpufreq stats in the way it handles
    cpufreq_unregister_driver() and suspend/resume..
    
     - We must not lose data collected so far when suspend/resume happens
       and so stats directories must not be removed/allocated during these
       operations, which is done currently.
    
     - cpufreq_stat has registered notifiers with both cpufreq and hotplug.
       It adds sysfs stats directory with a cpufreq notifier: CPUFREQ_NOTIFY
       and removes this directory with a notifier from hotplug core.
    
       In case cpufreq_unregister_driver() is called (on rmmod cpufreq driver),
       stats directories per cpu aren't removed as CPUs are still online. The
       only call cpufreq_stats gets is cpufreq_stats_update_policy_cpu() for
       all CPUs except the last of each policy. And pointer to stat information
       is stored in the entry for last CPU in the per-cpu cpufreq_stats_table.
       But policy structure would be freed inside cpufreq core and so that will
       result in memory leak inside cpufreq stats (as we are never freeing
       memory for stats).
    
       Now if we again insert the module cpufreq_register_driver() will be
       called and we will again allocate stats data and put it on for first
       CPU of every policy.  In case we only have a single CPU per policy, we
       will return with a error from cpufreq_stats_create_table() due to this
       code:
    
            if (per_cpu(cpufreq_stats_table, cpu))
                    return -EBUSY;
    
       And so probably cpufreq stats directory would not show up anymore (as
       it was added inside last policies->kobj which doesn't exist anymore).
       I haven't tested it, though. Also the values in stats files wouldn't
       be refreshed as we are using the earlier stats structure.
    
     - CPUFREQ_NOTIFY is called from cpufreq_set_policy() which is called for
       scenarios where we don't really want cpufreq_stat_notifier_policy() to get
       called. For example whenever we are changing anything related to a policy:
       min/max/current freq, etc. cpufreq_set_policy() is called and so cpufreq
       stats is notified. Where we don't do any useful stuff other than simply
       returning with -EBUSY from cpufreq_stats_create_table(). And so this
       isn't the right notifier that cpufreq stats..
    
     Due to all above reasons this patch does following changes:
     - Add new notifiers CPUFREQ_CREATE_POLICY and CPUFREQ_REMOVE_POLICY,
       which are only called when policy is created/destroyed. They aren't
       called for suspend/resume paths..
     - Use these notifiers in cpufreq_stat_notifier_policy() to create/destory
       stats sysfs entries. And so cpufreq_unregister_driver() or suspend/resume
       shouldn't be a problem for cpufreq_stats.
     - Return early from cpufreq_stat_cpu_callback() for suspend/resume sequence,
       so that we don't free stats structure.
    
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Tested-by: Nicolas Pitre <nico@linaro.org>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit a814613b9a32d9ab9578d9dab396265c826d37f0
Author: Lan Tianyu <tianyu.lan@intel.com>
Date:   Wed Sep 11 20:49:57 2013 +0800

    cpufreq / governor: Remove fossil comment
    
    cpufreq_set_policy() has been changed to origin __cpufreq_set_policy()
    and policy->lock has been converted to rewrite lock by commit 5a01f2.
    So remove the comment.
    
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Lan Tianyu <tianyu.lan@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 037ce8397d23b2f84ccfb879cf4b43277b0454e3
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Wed Oct 2 14:13:16 2013 +0530

    cpufreq: rename __cpufreq_set_policy() as cpufreq_set_policy()
    
    Earlier there used to be two functions named __cpufreq_set_policy() and
    cpufreq_set_policy(), but now we only have a single routine lets name it
    cpufreq_set_policy() instead of __cpufreq_set_policy().
    
    This also removes some invalid comments or fixes some incorrect comments.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 4f750c930822b92df74327a4d1364eff87701360
Author: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
Date:   Sat Sep 7 01:23:43 2013 +0530

    cpufreq: Synchronize the cpufreq store_*() routines with CPU hotplug
    
    The functions that are used to write to cpufreq sysfs files (such as
    store_scaling_max_freq()) are not hotplug safe. They can race with CPU
    hotplug tasks and lead to problems such as trying to acquire an already
    destroyed timer-mutex etc.
    
    Eg:
    
        __cpufreq_remove_dev()
         __cpufreq_governor(policy, CPUFREQ_GOV_STOP);
           policy->governor->governor(policy, CPUFREQ_GOV_STOP);
            cpufreq_governor_dbs()
             case CPUFREQ_GOV_STOP:
              mutex_destroy(&cpu_cdbs->timer_mutex)
              cpu_cdbs->cur_policy = NULL;
          <PREEMPT>
        store()
         __cpufreq_set_policy()
          __cpufreq_governor(policy, CPUFREQ_GOV_LIMITS);
            policy->governor->governor(policy, CPUFREQ_GOV_LIMITS);
             case CPUFREQ_GOV_LIMITS:
              mutex_lock(&cpu_cdbs->timer_mutex); <-- Warning (destroyed mutex)
               if (policy->max < cpu_cdbs->cur_policy->cur) <- cur_policy == NULL
    
    So use get_online_cpus()/put_online_cpus() in the store_*() functions, to
    synchronize with CPU hotplug. However, there is an additional point to note
    here: some parts of the CPU teardown in the cpufreq subsystem are done in
    the CPU_POST_DEAD stage, with cpu_hotplug.lock *released*. So, using the
    get/put_online_cpus() functions alone is insufficient; we should also ensure
    that we don't race with those latter steps in the hotplug sequence. We can
    easily achieve this by checking if the CPU is online before proceeding with
    the store, since the CPU would have been marked offline by the time the
    CPU_POST_DEAD notifiers are executed.
    
    Reported-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 19c763031acb831a5ab9c1a701b7fedda073eb3f
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Sat Aug 31 17:48:23 2013 +0530

    cpufreq: serialize calls to __cpufreq_governor()
    
    We can't take a big lock around __cpufreq_governor() as this causes
    recursive locking for some cases. But calls to this routine must be
    serialized for every policy. Otherwise we can see some unpredictable
    events.
    
    For example, consider following scenario:
    
    __cpufreq_remove_dev()
     __cpufreq_governor(policy, CPUFREQ_GOV_STOP);
       policy->governor->governor(policy, CPUFREQ_GOV_STOP);
        cpufreq_governor_dbs()
         case CPUFREQ_GOV_STOP:
          mutex_destroy(&cpu_cdbs->timer_mutex)
          cpu_cdbs->cur_policy = NULL;
      <PREEMPT>
    store()
     __cpufreq_set_policy()
      __cpufreq_governor(policy, CPUFREQ_GOV_LIMITS);
        policy->governor->governor(policy, CPUFREQ_GOV_LIMITS);
         case CPUFREQ_GOV_LIMITS:
          mutex_lock(&cpu_cdbs->timer_mutex); <-- Warning (destroyed mutex)
           if (policy->max < cpu_cdbs->cur_policy->cur) <- cur_policy == NULL
    
    And so store() will eventually result in a crash if cur_policy is
    NULL at this point.
    
    Introduce an additional variable which would guarantee serialization
    here.
    
    Reported-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 95731ebb114c5f0c028459388560fc2a72fe5049
Author: Xiaoguang Chen <chenxg@marvell.com>
Date:   Wed Jun 19 15:00:07 2013 +0800

    cpufreq: Fix governor start/stop race condition
    
    Cpufreq governors' stop and start operations should be carried out
    in sequence.  Otherwise, there will be unexpected behavior, like in
    the example below.
    
    Suppose there are 4 CPUs and policy->cpu=CPU0, CPU1/2/3 are linked
    to CPU0.  The normal sequence is:
    
     1) Current governor is userspace.  An application tries to set the
        governor to ondemand.  It will call __cpufreq_set_policy() in
        which it will stop the userspace governor and then start the
        ondemand governor.
    
     2) Current governor is userspace.  The online of CPU3 runs on CPU0.
        It will call cpufreq_add_policy_cpu() in which it will first
        stop the userspace governor, and then start it again.
    
    If the sequence of the above two cases interleaves, it becomes:
    
     1) Application stops userspace governor
     2)                                  Hotplug stops userspace governor
    
    which is a problem, because the governor shouldn't be stopped twice
    in a row.  What happens next is:
    
     3) Application starts ondemand governor
     4)                                  Hotplug starts a governor
    
    In step 4, the hotplug is supposed to start the userspace governor,
    but now the governor has been changed by the application to ondemand,
    so the ondemand governor is started once again, which is incorrect.
    
    The solution is to prevent policy governors from being stopped
    multiple times in a row.  A governor should only be stopped once for
    one policy.  After it has been stopped, no more governor stop
    operations should be executed.
    
    Also add a mutex to serialize governor operations.
    
    [rjw: Changelog.  And you owe me a beverage of my choice.]
    Signed-off-by: Xiaoguang Chen <chenxg@marvell.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 955ef4833574636819cd269cfbae12f79cbde63a
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu May 16 05:09:58 2013 +0000

    cpufreq: Drop rwsem lock around CPUFREQ_GOV_POLICY_EXIT
    
    With the rwsem lock around
    __cpufreq_governor(policy, CPUFREQ_GOV_POLICY_EXIT), we
    get circular dependency when we call sysfs_remove_group().
    
     ======================================================
     [ INFO: possible circular locking dependency detected ]
     3.9.0-rc7+ #15 Not tainted
     -------------------------------------------------------
     cat/2387 is trying to acquire lock:
      (&per_cpu(cpu_policy_rwsem, cpu)){+++++.}, at: [<c02f6179>] lock_policy_rwsem_read+0x25/0x34
    
     but task is already holding lock:
      (s_active#41){++++.+}, at: [<c00f9bf7>] sysfs_read_file+0x4f/0xcc
    
     which lock already depends on the new lock.
    
     the existing dependency chain (in reverse order) is:
    
    -> #1 (s_active#41){++++.+}:
            [<c0055a79>] lock_acquire+0x61/0xbc
            [<c00fabf1>] sysfs_addrm_finish+0xc1/0x128
            [<c00f9819>] sysfs_hash_and_remove+0x35/0x64
            [<c00fbe6f>] remove_files.isra.0+0x1b/0x24
            [<c00fbea5>] sysfs_remove_group+0x2d/0xa8
            [<c02f9a0b>] cpufreq_governor_interactive+0x13b/0x35c
            [<c02f61df>] __cpufreq_governor+0x2b/0x8c
            [<c02f6579>] __cpufreq_set_policy+0xa9/0xf8
            [<c02f6b75>] store_scaling_governor+0x61/0x100
            [<c02f6f4d>] store+0x39/0x60
            [<c00f9b81>] sysfs_write_file+0xed/0x114
            [<c00b3fd1>] vfs_write+0x65/0xd8
            [<c00b424b>] sys_write+0x2f/0x50
            [<c000cdc1>] ret_fast_syscall+0x1/0x52
    
    -> #0 (&per_cpu(cpu_policy_rwsem, cpu)){+++++.}:
            [<c0055253>] __lock_acquire+0xef3/0x13dc
            [<c0055a79>] lock_acquire+0x61/0xbc
            [<c03ee1f5>] down_read+0x25/0x30
            [<c02f6179>] lock_policy_rwsem_read+0x25/0x34
            [<c02f6edd>] show+0x21/0x58
            [<c00f9c0f>] sysfs_read_file+0x67/0xcc
            [<c00b40a7>] vfs_read+0x63/0xd8
            [<c00b41fb>] sys_read+0x2f/0x50
            [<c000cdc1>] ret_fast_syscall+0x1/0x52
    
     other info that might help us debug this:
    
      Possible unsafe locking scenario:
    
            CPU0                    CPU1
            ----                    ----
       lock(s_active#41);
                                    lock(&per_cpu(cpu_policy_rwsem, cpu));
                                    lock(s_active#41);
       lock(&per_cpu(cpu_policy_rwsem, cpu));
    
      *** DEADLOCK ***
    
     2 locks held by cat/2387:
      #0:  (&buffer->mutex){+.+.+.}, at: [<c00f9bcd>] sysfs_read_file+0x25/0xcc
      #1:  (s_active#41){++++.+}, at: [<c00f9bf7>] sysfs_read_file+0x4f/0xcc
    
     stack backtrace:
     [<c0011d55>] (unwind_backtrace+0x1/0x9c) from [<c03e9a09>] (print_circular_bug+0x19d/0x1e8)
     [<c03e9a09>] (print_circular_bug+0x19d/0x1e8) from [<c0055253>] (__lock_acquire+0xef3/0x13dc)
     [<c0055253>] (__lock_acquire+0xef3/0x13dc) from [<c0055a79>] (lock_acquire+0x61/0xbc)
     [<c0055a79>] (lock_acquire+0x61/0xbc) from [<c03ee1f5>] (down_read+0x25/0x30)
     [<c03ee1f5>] (down_read+0x25/0x30) from [<c02f6179>] (lock_policy_rwsem_read+0x25/0x34)
     [<c02f6179>] (lock_policy_rwsem_read+0x25/0x34) from [<c02f6edd>] (show+0x21/0x58)
     [<c02f6edd>] (show+0x21/0x58) from [<c00f9c0f>] (sysfs_read_file+0x67/0xcc)
     [<c00f9c0f>] (sysfs_read_file+0x67/0xcc) from [<c00b40a7>] (vfs_read+0x63/0xd8)
     [<c00b40a7>] (vfs_read+0x63/0xd8) from [<c00b41fb>] (sys_read+0x2f/0x50)
     [<c00b41fb>] (sys_read+0x2f/0x50) from [<c000cdc1>] (ret_fast_syscall+0x1/0x52)
    
    This lock isn't required while calling __cpufreq_governor(policy,
    CPUFREQ_GOV_POLICY_EXIT). Remove it.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit f55c9c26278b0fcfa3336eccbba3d8a782da8aed
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Wed Oct 31 05:49:13 2012 +0000

    cpufreq: Remove unnecessary initialization of a local variable
    
    Remove an unnecessary initializer for the 'ret' variable in
    __cpufreq_set_policy().
    
    [rjw: Modified the subject and changelog slightly.]
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit b1a9fec89349d9c41ff1ab519d4bfe2bb16814b8
Author: Andreas Herrmann <andreas.herrmann3@amd.com>
Date:   Tue Oct 23 00:55:10 2012 +0200

    cpufreq / powernow-k8: Remove usage of smp_processor_id() in preemptible code
    
    commit e4df1cbcc1f329e53a1fff7450b2229e0addff20 upstream.
    
    Commit 6889125b8b4e09c5e53e6ecab3433bed1ce198c9
    (cpufreq/powernow-k8: workqueue user shouldn't migrate the kworker to another CPU)
    causes powernow-k8 to trigger a preempt warning, e.g.:
    
      BUG: using smp_processor_id() in preemptible [00000000] code: cpufreq/3776
      caller is powernowk8_target+0x20/0x49
      Pid: 3776, comm: cpufreq Not tainted 3.6.0 #9
      Call Trace:
       [<ffffffff8125b447>] debug_smp_processor_id+0xc7/0xe0
       [<ffffffff814877e7>] powernowk8_target+0x20/0x49
       [<ffffffff81482b02>] __cpufreq_driver_target+0x82/0x8a
       [<ffffffff81484fc6>] cpufreq_governor_performance+0x4e/0x54
       [<ffffffff81482c50>] __cpufreq_governor+0x8c/0xc9
       [<ffffffff81482e6f>] __cpufreq_set_policy+0x1a9/0x21e
       [<ffffffff814839af>] store_scaling_governor+0x16f/0x19b
       [<ffffffff81484f16>] ? cpufreq_update_policy+0x124/0x124
       [<ffffffff8162b4a5>] ? _raw_spin_unlock_irqrestore+0x2c/0x49
       [<ffffffff81483640>] store+0x60/0x88
       [<ffffffff811708c0>] sysfs_write_file+0xf4/0x130
       [<ffffffff8111243b>] vfs_write+0xb5/0x151
       [<ffffffff811126e0>] sys_write+0x4a/0x71
       [<ffffffff816319a9>] system_call_fastpath+0x16/0x1b
    
    Fix this by by always using work_on_cpu().
    
    Signed-off-by: Andreas Herrmann <andreas.herrmann3@amd.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 0b79a8a53612672adf053aaebb74ebc51a44e321
Author: Andreas Herrmann <andreas.herrmann3@amd.com>
Date:   Tue Oct 23 00:55:10 2012 +0200

    cpufreq / powernow-k8: Remove usage of smp_processor_id() in preemptible code
    
    commit e4df1cbcc1f329e53a1fff7450b2229e0addff20 upstream.
    
    Commit 6889125b8b4e09c5e53e6ecab3433bed1ce198c9
    (cpufreq/powernow-k8: workqueue user shouldn't migrate the kworker to another CPU)
    causes powernow-k8 to trigger a preempt warning, e.g.:
    
      BUG: using smp_processor_id() in preemptible [00000000] code: cpufreq/3776
      caller is powernowk8_target+0x20/0x49
      Pid: 3776, comm: cpufreq Not tainted 3.6.0 #9
      Call Trace:
       [<ffffffff8125b447>] debug_smp_processor_id+0xc7/0xe0
       [<ffffffff814877e7>] powernowk8_target+0x20/0x49
       [<ffffffff81482b02>] __cpufreq_driver_target+0x82/0x8a
       [<ffffffff81484fc6>] cpufreq_governor_performance+0x4e/0x54
       [<ffffffff81482c50>] __cpufreq_governor+0x8c/0xc9
       [<ffffffff81482e6f>] __cpufreq_set_policy+0x1a9/0x21e
       [<ffffffff814839af>] store_scaling_governor+0x16f/0x19b
       [<ffffffff81484f16>] ? cpufreq_update_policy+0x124/0x124
       [<ffffffff8162b4a5>] ? _raw_spin_unlock_irqrestore+0x2c/0x49
       [<ffffffff81483640>] store+0x60/0x88
       [<ffffffff811708c0>] sysfs_write_file+0xf4/0x130
       [<ffffffff8111243b>] vfs_write+0xb5/0x151
       [<ffffffff811126e0>] sys_write+0x4a/0x71
       [<ffffffff816319a9>] system_call_fastpath+0x16/0x1b
    
    Fix this by by always using work_on_cpu().
    
    Signed-off-by: Andreas Herrmann <andreas.herrmann3@amd.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit eccd54a6c29b2ddce3e03e7f77b89376dd9ee1ca
Author: Andreas Herrmann <andreas.herrmann3@amd.com>
Date:   Tue Oct 23 00:55:10 2012 +0200

    cpufreq / powernow-k8: Remove usage of smp_processor_id() in preemptible code
    
    commit e4df1cbcc1f329e53a1fff7450b2229e0addff20 upstream.
    
    Commit 6889125b8b4e09c5e53e6ecab3433bed1ce198c9
    (cpufreq/powernow-k8: workqueue user shouldn't migrate the kworker to another CPU)
    causes powernow-k8 to trigger a preempt warning, e.g.:
    
      BUG: using smp_processor_id() in preemptible [00000000] code: cpufreq/3776
      caller is powernowk8_target+0x20/0x49
      Pid: 3776, comm: cpufreq Not tainted 3.6.0 #9
      Call Trace:
       [<ffffffff8125b447>] debug_smp_processor_id+0xc7/0xe0
       [<ffffffff814877e7>] powernowk8_target+0x20/0x49
       [<ffffffff81482b02>] __cpufreq_driver_target+0x82/0x8a
       [<ffffffff81484fc6>] cpufreq_governor_performance+0x4e/0x54
       [<ffffffff81482c50>] __cpufreq_governor+0x8c/0xc9
       [<ffffffff81482e6f>] __cpufreq_set_policy+0x1a9/0x21e
       [<ffffffff814839af>] store_scaling_governor+0x16f/0x19b
       [<ffffffff81484f16>] ? cpufreq_update_policy+0x124/0x124
       [<ffffffff8162b4a5>] ? _raw_spin_unlock_irqrestore+0x2c/0x49
       [<ffffffff81483640>] store+0x60/0x88
       [<ffffffff811708c0>] sysfs_write_file+0xf4/0x130
       [<ffffffff8111243b>] vfs_write+0xb5/0x151
       [<ffffffff811126e0>] sys_write+0x4a/0x71
       [<ffffffff816319a9>] system_call_fastpath+0x16/0x1b
    
    Fix this by by always using work_on_cpu().
    
    Signed-off-by: Andreas Herrmann <andreas.herrmann3@amd.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 05366b68ce37e1664b4df70912507453c7729d9b
Author: Andreas Herrmann <andreas.herrmann3@amd.com>
Date:   Tue Oct 23 00:55:10 2012 +0200

    cpufreq / powernow-k8: Remove usage of smp_processor_id() in preemptible code
    
    commit e4df1cbcc1f329e53a1fff7450b2229e0addff20 upstream.
    
    Commit 6889125b8b4e09c5e53e6ecab3433bed1ce198c9
    (cpufreq/powernow-k8: workqueue user shouldn't migrate the kworker to another CPU)
    causes powernow-k8 to trigger a preempt warning, e.g.:
    
      BUG: using smp_processor_id() in preemptible [00000000] code: cpufreq/3776
      caller is powernowk8_target+0x20/0x49
      Pid: 3776, comm: cpufreq Not tainted 3.6.0 #9
      Call Trace:
       [<ffffffff8125b447>] debug_smp_processor_id+0xc7/0xe0
       [<ffffffff814877e7>] powernowk8_target+0x20/0x49
       [<ffffffff81482b02>] __cpufreq_driver_target+0x82/0x8a
       [<ffffffff81484fc6>] cpufreq_governor_performance+0x4e/0x54
       [<ffffffff81482c50>] __cpufreq_governor+0x8c/0xc9
       [<ffffffff81482e6f>] __cpufreq_set_policy+0x1a9/0x21e
       [<ffffffff814839af>] store_scaling_governor+0x16f/0x19b
       [<ffffffff81484f16>] ? cpufreq_update_policy+0x124/0x124
       [<ffffffff8162b4a5>] ? _raw_spin_unlock_irqrestore+0x2c/0x49
       [<ffffffff81483640>] store+0x60/0x88
       [<ffffffff811708c0>] sysfs_write_file+0xf4/0x130
       [<ffffffff8111243b>] vfs_write+0xb5/0x151
       [<ffffffff811126e0>] sys_write+0x4a/0x71
       [<ffffffff816319a9>] system_call_fastpath+0x16/0x1b
    
    Fix this by by always using work_on_cpu().
    
    Signed-off-by: Andreas Herrmann <andreas.herrmann3@amd.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit e4df1cbcc1f329e53a1fff7450b2229e0addff20
Author: Andreas Herrmann <andreas.herrmann3@amd.com>
Date:   Tue Oct 23 00:55:10 2012 +0200

    cpufreq / powernow-k8: Remove usage of smp_processor_id() in preemptible code
    
    Commit 6889125b8b4e09c5e53e6ecab3433bed1ce198c9
    (cpufreq/powernow-k8: workqueue user shouldn't migrate the kworker to another CPU)
    causes powernow-k8 to trigger a preempt warning, e.g.:
    
      BUG: using smp_processor_id() in preemptible [00000000] code: cpufreq/3776
      caller is powernowk8_target+0x20/0x49
      Pid: 3776, comm: cpufreq Not tainted 3.6.0 #9
      Call Trace:
       [<ffffffff8125b447>] debug_smp_processor_id+0xc7/0xe0
       [<ffffffff814877e7>] powernowk8_target+0x20/0x49
       [<ffffffff81482b02>] __cpufreq_driver_target+0x82/0x8a
       [<ffffffff81484fc6>] cpufreq_governor_performance+0x4e/0x54
       [<ffffffff81482c50>] __cpufreq_governor+0x8c/0xc9
       [<ffffffff81482e6f>] __cpufreq_set_policy+0x1a9/0x21e
       [<ffffffff814839af>] store_scaling_governor+0x16f/0x19b
       [<ffffffff81484f16>] ? cpufreq_update_policy+0x124/0x124
       [<ffffffff8162b4a5>] ? _raw_spin_unlock_irqrestore+0x2c/0x49
       [<ffffffff81483640>] store+0x60/0x88
       [<ffffffff811708c0>] sysfs_write_file+0xf4/0x130
       [<ffffffff8111243b>] vfs_write+0xb5/0x151
       [<ffffffff811126e0>] sys_write+0x4a/0x71
       [<ffffffff816319a9>] system_call_fastpath+0x16/0x1b
    
    Fix this by by always using work_on_cpu().
    
    Signed-off-by: Andreas Herrmann <andreas.herrmann3@amd.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 46a310b80bc2c9ccc019649c9da91194cbc10944
Author: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
Date:   Thu Jun 16 15:36:38 2011 -0400

    [CPUFREQ] Don't set stat->last_index to -1 if the pol->cur has incorrect value.
    
    If the driver submitted an non-existing pol>cur value (say it
    used the default initialized value of zero), when the cpufreq
    stats tries to setup its initial values it incorrectly sets
    stat->last_index to -1 (or 0xfffff...). And cpufreq_stats_update
    tries to update at that index location and fails.
    
    This can be caused by:
    
    stat->last_index = freq_table_get_index(stat, policy->cur);
    
    not finding the appropiate frequency in the table (b/c the policy->cur
    is wrong) and we end up crashing. The fix however is
    concentrated in the 'cpufreq_stats_update' as the last_index
    (and old_index) are updated there. Which means it can reset
    the last_index to -1 again and on the next iteration cause a crash.
    
    Without this patch, the following crash is observed:
    
    powernow-k8: Found 1 AMD Athlon(tm) 64 Processor 3700+ (1 cpu cores) (version 2.20.00)
    powernow-k8: fid 0x2 (1000 MHz), vid 0x12
    powernow-k8: fid 0xa (1800 MHz), vid 0xa
    powernow-k8: fid 0xc (2000 MHz), vid 0x8
    powernow-k8: fid 0xe (2200 MHz), vid 0x8
    Marking TSC unstable due to cpufreq changes
    powernow-k8: fid trans failed, fid 0x2, curr 0x0
    BUG: unable to handle kernel paging request at ffff880807e07b78
    IP: [<ffffffff81479163>] cpufreq_stats_update+0x46/0x5b
    .. snip..
    Pid: 1, comm: swapper Not tainted 3.0.0-rc2 #45 MICRO-STAR INTERNATIONAL CO., LTD MS-7094/MS-7094
    ..snip..
    Call Trace:
     [<ffffffff81479248>] cpufreq_stat_notifier_trans+0x48/0x7c
     [<ffffffff81095d68>] notifier_call_chain+0x32/0x5e
     [<ffffffff81095e6b>] __srcu_notifier_call_chain+0x47/0x63
     [<ffffffff81095e96>] srcu_notifier_call_chain+0xf/0x11
     [<ffffffff81477e7a>] cpufreq_notify_transition+0x111/0x134
     [<ffffffff8147b0d4>] powernowk8_target+0x53b/0x617
     [<ffffffff8147723a>] __cpufreq_driver_target+0x2e/0x30
     [<ffffffff8147a127>] cpufreq_governor_dbs+0x339/0x356
     [<ffffffff81477394>] __cpufreq_governor+0xa8/0xe9
     [<ffffffff81477525>] __cpufreq_set_policy+0x132/0x13e
     [<ffffffff8147848d>] cpufreq_add_dev_interface+0x272/0x28c
    
    Reported-by: Tobias Diedrich <ranma+xen@tdiedrich.de>
    Tested-by: Tobias Diedrich <ranma+xen@tdiedrich.de>
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Signed-off-by: Dave Jones <davej@redhat.com>

commit 395913d0b1db37092ea3d9d69b832183b1dd84c5
Author: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
Date:   Mon Jun 8 13:17:31 2009 -0400

    [CPUFREQ] remove rwsem lock from CPUFREQ_GOV_STOP call (second call site)
    
    remove rwsem lock from CPUFREQ_GOV_STOP call (second call site)
    
    commit  42a06f2166f2f6f7bf04f32b4e823eacdceafdc9
    
    Missed a call site for CPUFREQ_GOV_STOP to remove the rwlock taken around the
    teardown. To make a long story short, the rwlock write-lock causes a circular
    dependency with cancel_delayed_work_sync(), because the timer handler takes the
    read lock.
    
    Note that all callers to __cpufreq_set_policy are taking the rwsem. All sysfs
    callers (writers) hold the write rwsem at the earliest sysfs calling stage.
    
    However, the rwlock write-lock is not needed upon governor stop.
    
    Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
    Acked-by: Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>
    CC: rjw@sisk.pl
    CC: mingo@elte.hu
    CC: Shaohua Li <shaohua.li@intel.com>
    CC: Pekka Enberg <penberg@cs.helsinki.fi>
    CC: Dave Young <hidave.darkstar@gmail.com>
    CC: "Rafael J. Wysocki" <rjw@sisk.pl>
    CC: Rusty Russell <rusty@rustcorp.com.au>
    CC: trenn@suse.de
    CC: sven.wegener@stealer.net
    CC: cpufreq@vger.kernel.org
    Signed-off-by: Dave Jones <davej@redhat.com>

commit 8eed1192969633780822059ebf02d693f74977c1
Author: Andreas Herrmann <andreas.herrmann3@amd.com>
Date:   Fri Nov 21 14:49:25 2008 +0100

    CPUFREQ: powernow-k8: ignore out-of-range PstateStatus value
    
    commit a266d9f1253a38ec2d5655ebcd6846298b0554f4 upstream.
    
    A workaround for AMD CPU family 11h erratum 311 might cause that the
    P-state Status Register shows a "current P-state" which is larger than
    the "current P-state limit" in P-state Current Limit Register. For the
    wrong P-state value there is no ACPI _PSS object defined and
    powernow-k8/cpufreq can't determine the proper CPU frequency for that
    state.
    
    As a consequence this can cause a panic during boot (potentially with
    all recent kernel versions -- at least I have reproduced it with
    various 2.6.27 kernels and with the current .28 series), as an
    example:
    
    powernow-k8: Found 1 AMD Turion(tm)X2 Ultra DualCore Mobile ZM-82 processors (2 \
    )
    powernow-k8:    0 : pstate 0 (2200 MHz)
    powernow-k8:    1 : pstate 1 (1100 MHz)
    powernow-k8:    2 : pstate 2 (600 MHz)
    BUG: unable to handle kernel paging request at ffff88086e7528b8
    IP: [<ffffffff80486361>] cpufreq_stats_update+0x4a/0x5f
    PGD 202063 PUD 0
    Oops: 0002 [#1] SMP
    last sysfs file:
    CPU 1
    Modules linked in:
    Pid: 1, comm: swapper Not tainted 2.6.28-rc3-dirty #16
    RIP: 0010:[<ffffffff80486361>]  [<ffffffff80486361>] cpufreq_stats_update+0x4a/0\
    f
    Synaptics claims to have extended capabilities, but I'm not able to read them.<6\
    6
    RAX: 0000000000000000 RBX: 0000000000000001 RCX: ffff88006e7528c0
    RDX: 00000000ffffffff RSI: ffff88006e54af00 RDI: ffffffff808f056c
    RBP: 00000000fffee697 R08: 0000000000000003 R09: ffff88006e73f080
    R10: 0000000000000001 R11: 00000000002191c0 R12: ffff88006fb83c10
    R13: 00000000ffffffff R14: 0000000000000001 R15: 0000000000000000
    FS:  0000000000000000(0000) GS:ffff88006fb50740(0000) knlGS:0000000000000000
    Unable to initialize Synaptics hardware.
    CS:  0010 DS: 0018 ES: 0018 CR0: 000000008005003b
    CR2: ffff88086e7528b8 CR3: 0000000000201000 CR4: 00000000000006e0
    DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
    DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400
    Process swapper (pid: 1, threadinfo ffff88006fb82000, task ffff88006fb816d0)
    Stack:
     ffff88006e74da50 0000000000000000 ffff88006e54af00 ffffffff804863c7
     ffff88006e74da50 0000000000000000 00000000ffffffff 0000000000000000
     ffff88006fb83c10 ffffffff8024b46c ffffffff808f0560 ffff88006fb83c10
    Call Trace:
     [<ffffffff804863c7>] ? cpufreq_stat_notifier_trans+0x51/0x83
     [<ffffffff8024b46c>] ? notifier_call_chain+0x29/0x4c
     [<ffffffff8024b561>] ? __srcu_notifier_call_chain+0x46/0x61
     [<ffffffff8048496d>] ? cpufreq_notify_transition+0x93/0xa9
     [<ffffffff8021ab8d>] ? powernowk8_target+0x1e8/0x5f3
     [<ffffffff80486687>] ? cpufreq_governor_performance+0x1b/0x20
     [<ffffffff80484886>] ? __cpufreq_governor+0x71/0xa8
     [<ffffffff80484b21>] ? __cpufreq_set_policy+0x101/0x13e
     [<ffffffff80485bcd>] ? cpufreq_add_dev+0x3f0/0x4cd
     [<ffffffff8048577a>] ? handle_update+0x0/0x8
     [<ffffffff803c2062>] ? sysdev_driver_register+0xb6/0x10d
     [<ffffffff8056592c>] ? powernowk8_init+0x0/0x7e
     [<ffffffff8048604c>] ? cpufreq_register_driver+0x8f/0x140
     [<ffffffff80209056>] ? _stext+0x56/0x14f
     [<ffffffff802c2234>] ? proc_register+0x122/0x17d
     [<ffffffff802c23a0>] ? create_proc_entry+0x73/0x8a
     [<ffffffff8025c259>] ? register_irq_proc+0x92/0xaa
     [<ffffffff8025c2c8>] ? init_irq_proc+0x57/0x69
     [<ffffffff807fc85f>] ? kernel_init+0x116/0x169
     [<ffffffff8020cc79>] ? child_rip+0xa/0x11
     [<ffffffff807fc749>] ? kernel_init+0x0/0x169
     [<ffffffff8020cc6f>] ? child_rip+0x0/0x11
    Code: 05 c5 83 36 00 48 c7 c2 48 5d 86 80 48 8b 04 d8 48 8b 40 08 48 8b 34 02 48\
    
    RIP  [<ffffffff80486361>] cpufreq_stats_update+0x4a/0x5f
     RSP <ffff88006fb83b20>
    CR2: ffff88086e7528b8
    ---[ end trace 0678bac75e67a2f7 ]---
    Kernel panic - not syncing: Attempted to kill init!
    
    In short, aftereffect of the wrong P-state is that
    cpufreq_stats_update() uses "-1" as index for some array in
    
    cpufreq_stats_update (unsigned int cpu)
    {
    ...
         if (stat->time_in_state)
                    stat->time_in_state[stat->last_index] =
                            cputime64_add(stat->time_in_state[stat->last_index],
                                          cputime_sub(cur_time, stat->last_time));
    ...
    }
    
    Fortunately, the wrong P-state value is returned only if the core is
    in P-state 0. This fix solves the problem by detecting the
    out-of-range P-state, ignoring it, and using "0" instead.
    
    Cc: Mark Langsdorf <mark.langsdorf@amd.com>
    Signed-off-by: Andreas Herrmann <andreas.herrmann3@amd.com>
    Signed-off-by: Dave Jones <davej@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit a266d9f1253a38ec2d5655ebcd6846298b0554f4
Author: Andreas Herrmann <andreas.herrmann3@amd.com>
Date:   Fri Nov 21 14:49:25 2008 +0100

    [CPUFREQ] powernow-k8: ignore out-of-range PstateStatus value
    
    A workaround for AMD CPU family 11h erratum 311 might cause that the
    P-state Status Register shows a "current P-state" which is larger than
    the "current P-state limit" in P-state Current Limit Register. For the
    wrong P-state value there is no ACPI _PSS object defined and
    powernow-k8/cpufreq can't determine the proper CPU frequency for that
    state.
    
    As a consequence this can cause a panic during boot (potentially with
    all recent kernel versions -- at least I have reproduced it with
    various 2.6.27 kernels and with the current .28 series), as an
    example:
    
    powernow-k8: Found 1 AMD Turion(tm)X2 Ultra DualCore Mobile ZM-82 processors (2 \
    )
    powernow-k8:    0 : pstate 0 (2200 MHz)
    powernow-k8:    1 : pstate 1 (1100 MHz)
    powernow-k8:    2 : pstate 2 (600 MHz)
    BUG: unable to handle kernel paging request at ffff88086e7528b8
    IP: [<ffffffff80486361>] cpufreq_stats_update+0x4a/0x5f
    PGD 202063 PUD 0
    Oops: 0002 [#1] SMP
    last sysfs file:
    CPU 1
    Modules linked in:
    Pid: 1, comm: swapper Not tainted 2.6.28-rc3-dirty #16
    RIP: 0010:[<ffffffff80486361>]  [<ffffffff80486361>] cpufreq_stats_update+0x4a/0\
    f
    Synaptics claims to have extended capabilities, but I'm not able to read them.<6\
    6
    RAX: 0000000000000000 RBX: 0000000000000001 RCX: ffff88006e7528c0
    RDX: 00000000ffffffff RSI: ffff88006e54af00 RDI: ffffffff808f056c
    RBP: 00000000fffee697 R08: 0000000000000003 R09: ffff88006e73f080
    R10: 0000000000000001 R11: 00000000002191c0 R12: ffff88006fb83c10
    R13: 00000000ffffffff R14: 0000000000000001 R15: 0000000000000000
    FS:  0000000000000000(0000) GS:ffff88006fb50740(0000) knlGS:0000000000000000
    Unable to initialize Synaptics hardware.
    CS:  0010 DS: 0018 ES: 0018 CR0: 000000008005003b
    CR2: ffff88086e7528b8 CR3: 0000000000201000 CR4: 00000000000006e0
    DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
    DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400
    Process swapper (pid: 1, threadinfo ffff88006fb82000, task ffff88006fb816d0)
    Stack:
     ffff88006e74da50 0000000000000000 ffff88006e54af00 ffffffff804863c7
     ffff88006e74da50 0000000000000000 00000000ffffffff 0000000000000000
     ffff88006fb83c10 ffffffff8024b46c ffffffff808f0560 ffff88006fb83c10
    Call Trace:
     [<ffffffff804863c7>] ? cpufreq_stat_notifier_trans+0x51/0x83
     [<ffffffff8024b46c>] ? notifier_call_chain+0x29/0x4c
     [<ffffffff8024b561>] ? __srcu_notifier_call_chain+0x46/0x61
     [<ffffffff8048496d>] ? cpufreq_notify_transition+0x93/0xa9
     [<ffffffff8021ab8d>] ? powernowk8_target+0x1e8/0x5f3
     [<ffffffff80486687>] ? cpufreq_governor_performance+0x1b/0x20
     [<ffffffff80484886>] ? __cpufreq_governor+0x71/0xa8
     [<ffffffff80484b21>] ? __cpufreq_set_policy+0x101/0x13e
     [<ffffffff80485bcd>] ? cpufreq_add_dev+0x3f0/0x4cd
     [<ffffffff8048577a>] ? handle_update+0x0/0x8
     [<ffffffff803c2062>] ? sysdev_driver_register+0xb6/0x10d
     [<ffffffff8056592c>] ? powernowk8_init+0x0/0x7e
     [<ffffffff8048604c>] ? cpufreq_register_driver+0x8f/0x140
     [<ffffffff80209056>] ? _stext+0x56/0x14f
     [<ffffffff802c2234>] ? proc_register+0x122/0x17d
     [<ffffffff802c23a0>] ? create_proc_entry+0x73/0x8a
     [<ffffffff8025c259>] ? register_irq_proc+0x92/0xaa
     [<ffffffff8025c2c8>] ? init_irq_proc+0x57/0x69
     [<ffffffff807fc85f>] ? kernel_init+0x116/0x169
     [<ffffffff8020cc79>] ? child_rip+0xa/0x11
     [<ffffffff807fc749>] ? kernel_init+0x0/0x169
     [<ffffffff8020cc6f>] ? child_rip+0x0/0x11
    Code: 05 c5 83 36 00 48 c7 c2 48 5d 86 80 48 8b 04 d8 48 8b 40 08 48 8b 34 02 48\
    
    RIP  [<ffffffff80486361>] cpufreq_stats_update+0x4a/0x5f
     RSP <ffff88006fb83b20>
    CR2: ffff88086e7528b8
    ---[ end trace 0678bac75e67a2f7 ]---
    Kernel panic - not syncing: Attempted to kill init!
    
    In short, aftereffect of the wrong P-state is that
    cpufreq_stats_update() uses "-1" as index for some array in
    
    cpufreq_stats_update (unsigned int cpu)
    {
    ...
         if (stat->time_in_state)
                    stat->time_in_state[stat->last_index] =
                            cputime64_add(stat->time_in_state[stat->last_index],
                                          cputime_sub(cur_time, stat->last_time));
    ...
    }
    
    Fortunately, the wrong P-state value is returned only if the core is
    in P-state 0. This fix solves the problem by detecting the
    out-of-range P-state, ignoring it, and using "0" instead.
    
    Cc: Mark Langsdorf <mark.langsdorf@amd.com>
    Signed-off-by: Andreas Herrmann <andreas.herrmann3@amd.com>
    Signed-off-by: Dave Jones <davej@redhat.com>

commit 8dbac2301d9dae0646f7b87e62f8cdee9a6e208b
Author: CHIKAMA masaki <masaki.chikama@gmail.com>
Date:   Fri Jun 6 18:41:31 2008 +0000

    cpufreq: fix null object access on Transmeta CPU
    
    upstream commit: 879000f94442860e72c934f9e568989bc7fb8ec4
    
    If cpu specific cpufreq driver(i.e.  longrun) has "setpolicy" function,
    governor object isn't set into cpufreq_policy object at "__cpufreq_set_policy"
    function in driver/cpufreq/cpufreq.c .
    
    This causes a null object access at "store_scaling_setspeed" and
    "show_scaling_setspeed" function in driver/cpufreq/cpufreq.c when reading or
    writing through /sys interface (ex.  cat
    /sys/devices/system/cpu/cpu0/cpufreq/scaling_setspeed)
    
    Addresses:
            http://bugzilla.kernel.org/show_bug.cgi?id=10654
            https://bugzilla.redhat.com/show_bug.cgi?id=443354
    
    Signed-off-by: CHIKAMA Masaki <masaki.chikama@gmail.com>
    Cc: Dave Jones <davej@codemonkey.org.uk>
    Cc: Chuck Ebbert <cebbert@redhat.com>
    Acked-by: Dominik Brodowski <linux@dominikbrodowski.net>
    Cc: <stable@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Chris Wright <chrisw@sous-sol.org>

commit 879000f94442860e72c934f9e568989bc7fb8ec4
Author: CHIKAMA masaki <masaki.chikama@gmail.com>
Date:   Thu Jun 5 22:46:33 2008 -0700

    cpufreq: fix null object access on Transmeta CPU
    
    If cpu specific cpufreq driver(i.e.  longrun) has "setpolicy" function,
    governor object isn't set into cpufreq_policy object at "__cpufreq_set_policy"
    function in driver/cpufreq/cpufreq.c .
    
    This causes a null object access at "store_scaling_setspeed" and
    "show_scaling_setspeed" function in driver/cpufreq/cpufreq.c when reading or
    writing through /sys interface (ex.  cat
    /sys/devices/system/cpu/cpu0/cpufreq/scaling_setspeed)
    
    Addresses:
            http://bugzilla.kernel.org/show_bug.cgi?id=10654
            https://bugzilla.redhat.com/show_bug.cgi?id=443354
    
    Signed-off-by: CHIKAMA Masaki <masaki.chikama@gmail.com>
    Cc: Dave Jones <davej@codemonkey.org.uk>
    Cc: Chuck Ebbert <cebbert@redhat.com>
    Acked-by: Dominik Brodowski <linux@dominikbrodowski.net>
    Cc: <stable@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit dca026139317dcbc642a30320d551f559692182f
Author: Lothar Wamann <LW@KARO-electronics.de>
Date:   Thu May 29 17:54:52 2008 +0200

    [CPUFREQ] fix double unlock of cpu_policy_rwsem in drivers/cpufreq/cpufreq.c
    
    In drivers/cpufreq/cpufreq.c the function cpufreq_add_dev() takes the
    error exit 'err_out_unregister' from different places once with the
    'cpu_policy_rwsem' lock held, once with the lock released:
    |               if (ret)
    |                       goto err_out_unregister;
    |       }
    |
    |       policy->governor = NULL; /* to assure that the starting sequence is
    |                                 * run in cpufreq_set_policy */
    |
    |       /* set default policy */
    |       ret = __cpufreq_set_policy(policy, &new_policy);
    |       policy->user_policy.policy = policy->policy;
    |       policy->user_policy.governor = policy->governor;
    |
    |       unlock_policy_rwsem_write(cpu);
    |
    |       if (ret) {
    |               dprintk("setting policy failed\n");
    |               goto err_out_unregister;
    |       }
    
    This leads to the following error message in case of a failing
    __cpufreq_set_policy() call:
    =====================================
    [ BUG: bad unlock balance detected! ]
    -------------------------------------
    swapper/1 is trying to release lock (&per_cpu(cpu_policy_rwsem, cpu)) at:
    [<c01b4564>] unlock_policy_rwsem_write+0x30/0x40
    but there are no more locks to release!
    
    other info that might help us debug this:
    1 lock held by swapper/1:
     #0:  (sysdev_drivers_lock){--..}, at: [<c018fd18>] sysdev_driver_register+0x74/0x130
    
    stack backtrace:
    [<c002f588>] (dump_stack+0x0/0x14) from [<c00692fc>] (print_unlock_inbalance_bug+0xc8/0x104)
    [<c0069234>] (print_unlock_inbalance_bug+0x0/0x104) from [<c006b7ac>] (lock_release_non_nested+0xc4/0x19c)
     r6:00000028 r5:c3c1ab80 r4:c01b4564
    [<c006b6e8>] (lock_release_non_nested+0x0/0x19c) from [<c006b9e0>] (lock_release+0x15c/0x18c)
     r8:60000013 r7:00000001 r6:c01b4564 r5:c0541bb4 r4:c3c1ab80
    [<c006b884>] (lock_release+0x0/0x18c) from [<c0061ba0>] (up_write+0x24/0x30)
     r8:c0541b80 r7:00000000 r6:ffffffea r5:c3c34828 r4:c0541b8c
    [<c0061b7c>] (up_write+0x0/0x30) from [<c01b4564>] (unlock_policy_rwsem_write+0x30/0x40)
     r4:c3c34884
    [<c01b4534>] (unlock_policy_rwsem_write+0x0/0x40) from [<c01b4c40>] (cpufreq_add_dev+0x324/0x398)
    [<c01b491c>] (cpufreq_add_dev+0x0/0x398) from [<c018fd64>] (sysdev_driver_register+0xc0/0x130)
    [<c018fca4>] (sysdev_driver_register+0x0/0x130) from [<c01b3574>] (cpufreq_register_driver+0xbc/0x174)
    
    Signed-off-by: Lothar Wamann <LW@KARO-electronics.de>
    Signed-off-by: Dave Jones <davej@redhat.com>

commit 53391fa20cab6df6b476a5a0ad6be653c9de0c46
Author: Yi Yang <yi.y.yang@intel.com>
Date:   Wed Jan 30 13:33:34 2008 +0100

    cpufreq: fix obvious condition statement error
    
    The function __cpufreq_set_policy in file drivers/cpufreq/cpufreq.c
    has a very obvious error:
    
            if (policy->min > data->min && policy->min > policy->max) {
                    ret = -EINVAL;
                    goto error_out;
            }
    
    This condtion statement is wrong because it returns -EINVAL only if
    policy->min is greater than policy->max (in this case,
    "policy->min > data->min" is true for ever.). In fact, it should
    return -EINVAL as well if policy->max is less than data->min.
    
    The correct condition should be:
    
            if (policy->min > data->max || policy->max < data->min) {
    
    The following test result testifies the above conclusion:
    
    Before applying this patch:
    
    [root@yangyi-dev /]# cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_available_frequencies
    2394000 1596000
    [root@yangyi-dev /]# echo 1596000 > /sys/devices/system/cpu/cpu0/cpufreq/scaling_max_freq
    [root@yangyi-dev /]# cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_max_freq
    1596000
    [root@yangyi-dev /]# cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_min_freq
    1596000
    [root@yangyi-dev /]# echo "2000000" > /sys/devices/system/cpu/cpu0/cpufreq/scaling_min_freq
    -bash: echo: write error: Invalid argument
    [root@yangyi-dev /]# cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_min_freq
    1596000
    [root@yangyi-dev /]# echo "0" > /sys/devices/system/cpu/cpu0/cpufreq/scaling_max_freq
    [root@yangyi-dev /]# cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_max_freq
    1596000
    [root@yangyi-dev /]# echo "1595000" > /sys/devices/system/cpu/cpu0/cpufreq/scaling_max_freq
    [root@yangyi-dev /]# cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_max_freq
    1596000
    [root@yangyi-dev /]#
    
    After applying this patch:
    
    [root@yangyi-dev /]# cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_available_frequencies
    2394000 1596000
    [root@yangyi-dev /]# echo 1596000 > /sys/devices/system/cpu/cpu0/cpufreq/scaling_max_freq
    [root@yangyi-dev /]# cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_max_freq
    1596000
    [root@yangyi-dev /]# cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_min_freq
    1596000
    [root@localhost /]# echo "2000000" > /sys/devices/system/cpu/cpu0/cpufreq/scaling_min_freq
    -bash: echo: write error: Invalid argument
    [root@localhost /]# cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_min_freq
    1596000
    [root@localhost /]# echo "0" > /sys/devices/system/cpu/cpu0/cpufreq/scaling_max_freq
    -bash: echo: write error: Invalid argument
    [root@localhost /]# echo "1595000" > /sys/devices/system/cpu/cpu0/cpufreq/scaling_max_freq
    -bash: echo: write error: Invalid argument
    [root@localhost /]# cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_max_freq
    1596000
    [root@localhost /]# echo "1596000" > /sys/devices/system/cpu/cpu0/cpufreq/scaling_max_freq
    [root@localhost /]# echo "2394000" > /sys/devices/system/cpu/cpu0/cpufreq/scaling_max_freq
    [root@localhost /]# cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_max_freq
    2394000
    [root@localhost /]
    
    Signed-off-by: Yi Yang <yi.y.yang@intel.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 1552cb923efcd0f5499104256010d2ace437581d
Author: Thomas Renninger <trenn@suse.de>
Date:   Tue Jun 5 04:14:40 2007 +1000

    [POWERPC] cbe_cpufreq: Limit frequency via cpufreq notifier chain
    
    ... and get rid of cpufreq_set_policy call that caused a build
    failure due interfering commits.
    
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    Signed-off-by: Christian Krafft <krafft@de.ibm.com>
    Signed-off-by: Arnd Bergmann <arnd.bergmann@de.ibm.com>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

commit 632786ce9ff6206951ee4c84fe5c0d5c1d12f4cc
Author: Thomas Renninger <trenn@suse.de>
Date:   Thu Apr 19 15:49:09 2007 +0200

    [CPUFREQ] Remove deprecated /proc/acpi/processor/performance write support
    
    Remove deprecated /proc/acpi/processor/performance write support
    
    Writing to /proc/acpi/processor/xy/performance interferes with sysfs
    cpufreq interface. Also removes buggy cpufreq_set_policy exported symbol.
    
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    Signed-off-by: Dave Jones <davej@redhat.com>

commit 22c970f3468a6766b362d57fa32ebb92cb8cd6db
Author: Thomas Renninger <trenn@suse.de>
Date:   Thu Apr 19 15:48:34 2007 +0200

    [CPUFREQ] Fix limited cpufreq when booted on battery
    
    References:
    https://bugzilla.novell.com/show_bug.cgi?id=231107
    https://bugzilla.novell.com/show_bug.cgi?id=264077
    
    Fix limited cpufreq when booted on battery
    
    If booted on battery:
    cpufreq_set_policy (evil) is invoked which calls verify_within_limits.
    max_freq gets lowered and therefore users_policy.max, which
    is used to restore higher freqs via update_policy later is set to the
    already limited frequency -> you can never go up again, even BIOS
    allows higher freqs later.
    
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    Signed-off-by: Dave Jones <davej@redhat.com>

commit 153d7f3fcae7ed4e19328549aa9467acdfbced10
Author: Arjan van de Ven <arjan@linux.intel.com>
Date:   Wed Jul 26 15:40:07 2006 +0200

    [PATCH] Reorganize the cpufreq cpu hotplug locking to not be totally bizare
    
    The patch below moves the cpu hotplugging higher up in the cpufreq
    layering; this is needed to avoid recursive taking of the cpu hotplug
    lock and to otherwise detangle the mess.
    
    The new rules are:
    1. you must do lock_cpu_hotplug() around the following functions:
       __cpufreq_driver_target
       __cpufreq_governor (for CPUFREQ_GOV_LIMITS operation only)
       __cpufreq_set_policy
    2. governer methods (.governer) must NOT take the lock_cpu_hotplug()
       lock in any way; they are called with the lock taken already
    3. if your governer spawns a thread that does things, like calling
       __cpufreq_driver_target, your thread must honor rule #1.
    4. the policy lock and other cpufreq internal locks nest within
       the lock_cpu_hotplug() lock.
    
    I'm not entirely happy about how the __cpufreq_governor rule ended up
    (conditional locking rule depending on the argument) but basically all
    callers pass this as a constant so it's not too horrible.
    
    The patch also removes the cpufreq_governor() function since during the
    locking audit it turned out to be entirely unused (so no need to fix it)
    
    The patch works on my testbox, but it could use more testing
    (otoh... it can't be much worse than the current code)
    
    Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

commit 7970e08bf066900efcd7794a1a338c11eb8f5141
Author: Thomas Renninger <trenn@suse.de>
Date:   Thu Apr 13 15:14:04 2006 +0200

    [CPUFREQ] If max_freq got reduced (e.g. by _PPC) a write to sysfs scaling_governor let cpufreq core stuck at low max_freq for ever
    
    The previous patch had bugs (locking and refcount).
    
    This one could also be related to the latest DELL reports.
    But they only slip into this if a user prog (e.g. powersave daemon does when
    AC got (un) plugged due to a scheme change) echos something to
    /sys/../cpufreq/scaling_governor
    while the frequencies got limited by BIOS.
    
    This one works:
    
    Subject: Max freq stucks at low freq if reduced by _PPC and sysfs gov access
    
    The problem is reproducable by(if machine is limiting freqs via BIOS):
     - Unplugging AC -> max freq gets limited
     - echo ${governor} >/sys/.../cpufreq/scaling_governor (policy->user_data.max
       gets overridden with policy->max and will never come up again.)
    
    This patch exchanged the cpufreq_set_policy call to __cpufreq_set_policy and
    duplicated it's functionality but did not override user_data.max.
    The same happens with overridding min/max values. If freqs are limited and
    you override the min freq value, the max freq global value will also get
    stuck to the limited freq, even if BIOS allows all freqs again.
    Last scenario does only happen if BIOS does not reduce the frequency
    to the lowest value (should never happen, just for correctness...)
    
     drivers/cpufreq/cpufreq.c |   17 +++++++++++++++--
     1 files changed, 15 insertions(+), 2 deletions(-)
    
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    Signed-off-by: "Pallipadi, Venkatesh" <venkatesh.pallipadi@intel.com>
    Signed-off-by: Dave Jones <davej@redhat.com>
