commit eca77a25a7cb3201738f4b55b9b8fa1089d7d002
Author: Rafael Mendonca <rafaelmendsr@gmail.com>
Date:   Fri Sep 30 19:40:57 2022 -0300

    uio: uio_dmem_genirq: Fix missing unlock in irq configuration
    
    [ Upstream commit 9de255c461d1b3f0242b3ad1450c3323a3e00b34 ]
    
    Commit b74351287d4b ("uio: fix a sleep-in-atomic-context bug in
    uio_dmem_genirq_irqcontrol()") started calling disable_irq() without
    holding the spinlock because it can sleep. However, that fix introduced
    another bug: if interrupt is already disabled and a new disable request
    comes in, then the spinlock is not unlocked:
    
    root@localhost:~# printf '\x00\x00\x00\x00' > /dev/uio0
    root@localhost:~# printf '\x00\x00\x00\x00' > /dev/uio0
    root@localhost:~# [   14.851538] BUG: scheduling while atomic: bash/223/0x00000002
    [   14.851991] Modules linked in: uio_dmem_genirq uio myfpga(OE) bochs drm_vram_helper drm_ttm_helper ttm drm_kms_helper drm snd_pcm ppdev joydev psmouse snd_timer snd e1000fb_sys_fops syscopyarea parport sysfillrect soundcore sysimgblt input_leds pcspkr i2c_piix4 serio_raw floppy evbug qemu_fw_cfg mac_hid pata_acpi ip_tables x_tables autofs4 [last unloaded: parport_pc]
    [   14.854206] CPU: 0 PID: 223 Comm: bash Tainted: G           OE      6.0.0-rc7 #21
    [   14.854786] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.0-0-gd239552ce722-prebuilt.qemu.org 04/01/2014
    [   14.855664] Call Trace:
    [   14.855861]  <TASK>
    [   14.856025]  dump_stack_lvl+0x4d/0x67
    [   14.856325]  dump_stack+0x14/0x1a
    [   14.856583]  __schedule_bug.cold+0x4b/0x5c
    [   14.856915]  __schedule+0xe81/0x13d0
    [   14.857199]  ? idr_find+0x13/0x20
    [   14.857456]  ? get_work_pool+0x2d/0x50
    [   14.857756]  ? __flush_work+0x233/0x280
    [   14.858068]  ? __schedule+0xa95/0x13d0
    [   14.858307]  ? idr_find+0x13/0x20
    [   14.858519]  ? get_work_pool+0x2d/0x50
    [   14.858798]  schedule+0x6c/0x100
    [   14.859009]  schedule_hrtimeout_range_clock+0xff/0x110
    [   14.859335]  ? tty_write_room+0x1f/0x30
    [   14.859598]  ? n_tty_poll+0x1ec/0x220
    [   14.859830]  ? tty_ldisc_deref+0x1a/0x20
    [   14.860090]  schedule_hrtimeout_range+0x17/0x20
    [   14.860373]  do_select+0x596/0x840
    [   14.860627]  ? __kernel_text_address+0x16/0x50
    [   14.860954]  ? poll_freewait+0xb0/0xb0
    [   14.861235]  ? poll_freewait+0xb0/0xb0
    [   14.861517]  ? rpm_resume+0x49d/0x780
    [   14.861798]  ? common_interrupt+0x59/0xa0
    [   14.862127]  ? asm_common_interrupt+0x2b/0x40
    [   14.862511]  ? __uart_start.isra.0+0x61/0x70
    [   14.862902]  ? __check_object_size+0x61/0x280
    [   14.863255]  core_sys_select+0x1c6/0x400
    [   14.863575]  ? vfs_write+0x1c9/0x3d0
    [   14.863853]  ? vfs_write+0x1c9/0x3d0
    [   14.864121]  ? _copy_from_user+0x45/0x70
    [   14.864526]  do_pselect.constprop.0+0xb3/0xf0
    [   14.864893]  ? do_syscall_64+0x6d/0x90
    [   14.865228]  ? do_syscall_64+0x6d/0x90
    [   14.865556]  __x64_sys_pselect6+0x76/0xa0
    [   14.865906]  do_syscall_64+0x60/0x90
    [   14.866214]  ? syscall_exit_to_user_mode+0x2a/0x50
    [   14.866640]  ? do_syscall_64+0x6d/0x90
    [   14.866972]  ? do_syscall_64+0x6d/0x90
    [   14.867286]  ? do_syscall_64+0x6d/0x90
    [   14.867626]  entry_SYSCALL_64_after_hwframe+0x63/0xcd
    [...] stripped
    [   14.872959]  </TASK>
    
    ('myfpga' is a simple 'uio_dmem_genirq' driver I wrote to test this)
    
    The implementation of "uio_dmem_genirq" was based on "uio_pdrv_genirq" and
    it is used in a similar manner to the "uio_pdrv_genirq" driver with respect
    to interrupt configuration and handling. At the time "uio_dmem_genirq" was
    introduced, both had the same implementation of the 'uio_info' handlers
    irqcontrol() and handler(). Then commit 34cb27528398 ("UIO: Fix concurrency
    issue"), which was only applied to "uio_pdrv_genirq", ended up making them
    a little different. That commit, among other things, changed disable_irq()
    to disable_irq_nosync() in the implementation of irqcontrol(). The
    motivation there was to avoid a deadlock between irqcontrol() and
    handler(), since it added a spinlock in the irq handler, and disable_irq()
    waits for the completion of the irq handler.
    
    By changing disable_irq() to disable_irq_nosync() in irqcontrol(), we also
    avoid the sleeping-while-atomic bug that commit b74351287d4b ("uio: fix a
    sleep-in-atomic-context bug in uio_dmem_genirq_irqcontrol()") was trying to
    fix. Thus, this fixes the missing unlock in irqcontrol() by importing the
    implementation of irqcontrol() handler from the "uio_pdrv_genirq" driver.
    In the end, it reverts commit b74351287d4b ("uio: fix a
    sleep-in-atomic-context bug in uio_dmem_genirq_irqcontrol()") and change
    disable_irq() to disable_irq_nosync().
    
    It is worth noting that this still does not address the concurrency issue
    fixed by commit 34cb27528398 ("UIO: Fix concurrency issue"). It will be
    addressed separately in the next commits.
    
    Split out from commit 34cb27528398 ("UIO: Fix concurrency issue").
    
    Fixes: b74351287d4b ("uio: fix a sleep-in-atomic-context bug in uio_dmem_genirq_irqcontrol()")
    Signed-off-by: Rafael Mendonca <rafaelmendsr@gmail.com>
    Link: https://lore.kernel.org/r/20220930224100.816175-2-rafaelmendsr@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 11ad95912b8bd8c5c791a6c382435116f88f2682
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Dec 2 15:30:28 2022 +0100

    PM: runtime: Do not call __rpm_callback() from rpm_idle()
    
    [ Upstream commit bc80c2e438dcbfcf748452ec0f7ad5b79ff3ad88 ]
    
    Calling __rpm_callback() from rpm_idle() after adding device links
    support to the former is a clear mistake.
    
    Not only it causes rpm_idle() to carry out unnecessary actions, but it
    is also against the assumption regarding the stability of PM-runtime
    status across __rpm_callback() invocations, because rpm_suspend() and
    rpm_resume() may run in parallel with __rpm_callback() when it is called
    by rpm_idle() and the device's PM-runtime status can be updated by any
    of them.
    
    Fixes: 21d5c57b3726 ("PM / runtime: Use device links")
    Link: https://lore.kernel.org/linux-pm/36aed941-a73e-d937-2721-4f0decd61ce0@quicinc.com
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Adrian Hunter <adrian.hunter@intel.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit ac5585bb06a2e82177269bee93e59887ce591106
Author: Rafael Mendonca <rafaelmendsr@gmail.com>
Date:   Fri Sep 30 19:40:57 2022 -0300

    uio: uio_dmem_genirq: Fix missing unlock in irq configuration
    
    [ Upstream commit 9de255c461d1b3f0242b3ad1450c3323a3e00b34 ]
    
    Commit b74351287d4b ("uio: fix a sleep-in-atomic-context bug in
    uio_dmem_genirq_irqcontrol()") started calling disable_irq() without
    holding the spinlock because it can sleep. However, that fix introduced
    another bug: if interrupt is already disabled and a new disable request
    comes in, then the spinlock is not unlocked:
    
    root@localhost:~# printf '\x00\x00\x00\x00' > /dev/uio0
    root@localhost:~# printf '\x00\x00\x00\x00' > /dev/uio0
    root@localhost:~# [   14.851538] BUG: scheduling while atomic: bash/223/0x00000002
    [   14.851991] Modules linked in: uio_dmem_genirq uio myfpga(OE) bochs drm_vram_helper drm_ttm_helper ttm drm_kms_helper drm snd_pcm ppdev joydev psmouse snd_timer snd e1000fb_sys_fops syscopyarea parport sysfillrect soundcore sysimgblt input_leds pcspkr i2c_piix4 serio_raw floppy evbug qemu_fw_cfg mac_hid pata_acpi ip_tables x_tables autofs4 [last unloaded: parport_pc]
    [   14.854206] CPU: 0 PID: 223 Comm: bash Tainted: G           OE      6.0.0-rc7 #21
    [   14.854786] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.0-0-gd239552ce722-prebuilt.qemu.org 04/01/2014
    [   14.855664] Call Trace:
    [   14.855861]  <TASK>
    [   14.856025]  dump_stack_lvl+0x4d/0x67
    [   14.856325]  dump_stack+0x14/0x1a
    [   14.856583]  __schedule_bug.cold+0x4b/0x5c
    [   14.856915]  __schedule+0xe81/0x13d0
    [   14.857199]  ? idr_find+0x13/0x20
    [   14.857456]  ? get_work_pool+0x2d/0x50
    [   14.857756]  ? __flush_work+0x233/0x280
    [   14.858068]  ? __schedule+0xa95/0x13d0
    [   14.858307]  ? idr_find+0x13/0x20
    [   14.858519]  ? get_work_pool+0x2d/0x50
    [   14.858798]  schedule+0x6c/0x100
    [   14.859009]  schedule_hrtimeout_range_clock+0xff/0x110
    [   14.859335]  ? tty_write_room+0x1f/0x30
    [   14.859598]  ? n_tty_poll+0x1ec/0x220
    [   14.859830]  ? tty_ldisc_deref+0x1a/0x20
    [   14.860090]  schedule_hrtimeout_range+0x17/0x20
    [   14.860373]  do_select+0x596/0x840
    [   14.860627]  ? __kernel_text_address+0x16/0x50
    [   14.860954]  ? poll_freewait+0xb0/0xb0
    [   14.861235]  ? poll_freewait+0xb0/0xb0
    [   14.861517]  ? rpm_resume+0x49d/0x780
    [   14.861798]  ? common_interrupt+0x59/0xa0
    [   14.862127]  ? asm_common_interrupt+0x2b/0x40
    [   14.862511]  ? __uart_start.isra.0+0x61/0x70
    [   14.862902]  ? __check_object_size+0x61/0x280
    [   14.863255]  core_sys_select+0x1c6/0x400
    [   14.863575]  ? vfs_write+0x1c9/0x3d0
    [   14.863853]  ? vfs_write+0x1c9/0x3d0
    [   14.864121]  ? _copy_from_user+0x45/0x70
    [   14.864526]  do_pselect.constprop.0+0xb3/0xf0
    [   14.864893]  ? do_syscall_64+0x6d/0x90
    [   14.865228]  ? do_syscall_64+0x6d/0x90
    [   14.865556]  __x64_sys_pselect6+0x76/0xa0
    [   14.865906]  do_syscall_64+0x60/0x90
    [   14.866214]  ? syscall_exit_to_user_mode+0x2a/0x50
    [   14.866640]  ? do_syscall_64+0x6d/0x90
    [   14.866972]  ? do_syscall_64+0x6d/0x90
    [   14.867286]  ? do_syscall_64+0x6d/0x90
    [   14.867626]  entry_SYSCALL_64_after_hwframe+0x63/0xcd
    [...] stripped
    [   14.872959]  </TASK>
    
    ('myfpga' is a simple 'uio_dmem_genirq' driver I wrote to test this)
    
    The implementation of "uio_dmem_genirq" was based on "uio_pdrv_genirq" and
    it is used in a similar manner to the "uio_pdrv_genirq" driver with respect
    to interrupt configuration and handling. At the time "uio_dmem_genirq" was
    introduced, both had the same implementation of the 'uio_info' handlers
    irqcontrol() and handler(). Then commit 34cb27528398 ("UIO: Fix concurrency
    issue"), which was only applied to "uio_pdrv_genirq", ended up making them
    a little different. That commit, among other things, changed disable_irq()
    to disable_irq_nosync() in the implementation of irqcontrol(). The
    motivation there was to avoid a deadlock between irqcontrol() and
    handler(), since it added a spinlock in the irq handler, and disable_irq()
    waits for the completion of the irq handler.
    
    By changing disable_irq() to disable_irq_nosync() in irqcontrol(), we also
    avoid the sleeping-while-atomic bug that commit b74351287d4b ("uio: fix a
    sleep-in-atomic-context bug in uio_dmem_genirq_irqcontrol()") was trying to
    fix. Thus, this fixes the missing unlock in irqcontrol() by importing the
    implementation of irqcontrol() handler from the "uio_pdrv_genirq" driver.
    In the end, it reverts commit b74351287d4b ("uio: fix a
    sleep-in-atomic-context bug in uio_dmem_genirq_irqcontrol()") and change
    disable_irq() to disable_irq_nosync().
    
    It is worth noting that this still does not address the concurrency issue
    fixed by commit 34cb27528398 ("UIO: Fix concurrency issue"). It will be
    addressed separately in the next commits.
    
    Split out from commit 34cb27528398 ("UIO: Fix concurrency issue").
    
    Fixes: b74351287d4b ("uio: fix a sleep-in-atomic-context bug in uio_dmem_genirq_irqcontrol()")
    Signed-off-by: Rafael Mendonca <rafaelmendsr@gmail.com>
    Link: https://lore.kernel.org/r/20220930224100.816175-2-rafaelmendsr@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 25890713f0f1ea7e944d362ec65caf87406d969c
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Dec 2 15:30:28 2022 +0100

    PM: runtime: Do not call __rpm_callback() from rpm_idle()
    
    [ Upstream commit bc80c2e438dcbfcf748452ec0f7ad5b79ff3ad88 ]
    
    Calling __rpm_callback() from rpm_idle() after adding device links
    support to the former is a clear mistake.
    
    Not only it causes rpm_idle() to carry out unnecessary actions, but it
    is also against the assumption regarding the stability of PM-runtime
    status across __rpm_callback() invocations, because rpm_suspend() and
    rpm_resume() may run in parallel with __rpm_callback() when it is called
    by rpm_idle() and the device's PM-runtime status can be updated by any
    of them.
    
    Fixes: 21d5c57b3726 ("PM / runtime: Use device links")
    Link: https://lore.kernel.org/linux-pm/36aed941-a73e-d937-2721-4f0decd61ce0@quicinc.com
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Adrian Hunter <adrian.hunter@intel.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit a323d24a0183be730d2398b11b3a91e5c2e222a0
Author: Rafael Mendonca <rafaelmendsr@gmail.com>
Date:   Fri Sep 30 19:40:57 2022 -0300

    uio: uio_dmem_genirq: Fix missing unlock in irq configuration
    
    [ Upstream commit 9de255c461d1b3f0242b3ad1450c3323a3e00b34 ]
    
    Commit b74351287d4b ("uio: fix a sleep-in-atomic-context bug in
    uio_dmem_genirq_irqcontrol()") started calling disable_irq() without
    holding the spinlock because it can sleep. However, that fix introduced
    another bug: if interrupt is already disabled and a new disable request
    comes in, then the spinlock is not unlocked:
    
    root@localhost:~# printf '\x00\x00\x00\x00' > /dev/uio0
    root@localhost:~# printf '\x00\x00\x00\x00' > /dev/uio0
    root@localhost:~# [   14.851538] BUG: scheduling while atomic: bash/223/0x00000002
    [   14.851991] Modules linked in: uio_dmem_genirq uio myfpga(OE) bochs drm_vram_helper drm_ttm_helper ttm drm_kms_helper drm snd_pcm ppdev joydev psmouse snd_timer snd e1000fb_sys_fops syscopyarea parport sysfillrect soundcore sysimgblt input_leds pcspkr i2c_piix4 serio_raw floppy evbug qemu_fw_cfg mac_hid pata_acpi ip_tables x_tables autofs4 [last unloaded: parport_pc]
    [   14.854206] CPU: 0 PID: 223 Comm: bash Tainted: G           OE      6.0.0-rc7 #21
    [   14.854786] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.0-0-gd239552ce722-prebuilt.qemu.org 04/01/2014
    [   14.855664] Call Trace:
    [   14.855861]  <TASK>
    [   14.856025]  dump_stack_lvl+0x4d/0x67
    [   14.856325]  dump_stack+0x14/0x1a
    [   14.856583]  __schedule_bug.cold+0x4b/0x5c
    [   14.856915]  __schedule+0xe81/0x13d0
    [   14.857199]  ? idr_find+0x13/0x20
    [   14.857456]  ? get_work_pool+0x2d/0x50
    [   14.857756]  ? __flush_work+0x233/0x280
    [   14.858068]  ? __schedule+0xa95/0x13d0
    [   14.858307]  ? idr_find+0x13/0x20
    [   14.858519]  ? get_work_pool+0x2d/0x50
    [   14.858798]  schedule+0x6c/0x100
    [   14.859009]  schedule_hrtimeout_range_clock+0xff/0x110
    [   14.859335]  ? tty_write_room+0x1f/0x30
    [   14.859598]  ? n_tty_poll+0x1ec/0x220
    [   14.859830]  ? tty_ldisc_deref+0x1a/0x20
    [   14.860090]  schedule_hrtimeout_range+0x17/0x20
    [   14.860373]  do_select+0x596/0x840
    [   14.860627]  ? __kernel_text_address+0x16/0x50
    [   14.860954]  ? poll_freewait+0xb0/0xb0
    [   14.861235]  ? poll_freewait+0xb0/0xb0
    [   14.861517]  ? rpm_resume+0x49d/0x780
    [   14.861798]  ? common_interrupt+0x59/0xa0
    [   14.862127]  ? asm_common_interrupt+0x2b/0x40
    [   14.862511]  ? __uart_start.isra.0+0x61/0x70
    [   14.862902]  ? __check_object_size+0x61/0x280
    [   14.863255]  core_sys_select+0x1c6/0x400
    [   14.863575]  ? vfs_write+0x1c9/0x3d0
    [   14.863853]  ? vfs_write+0x1c9/0x3d0
    [   14.864121]  ? _copy_from_user+0x45/0x70
    [   14.864526]  do_pselect.constprop.0+0xb3/0xf0
    [   14.864893]  ? do_syscall_64+0x6d/0x90
    [   14.865228]  ? do_syscall_64+0x6d/0x90
    [   14.865556]  __x64_sys_pselect6+0x76/0xa0
    [   14.865906]  do_syscall_64+0x60/0x90
    [   14.866214]  ? syscall_exit_to_user_mode+0x2a/0x50
    [   14.866640]  ? do_syscall_64+0x6d/0x90
    [   14.866972]  ? do_syscall_64+0x6d/0x90
    [   14.867286]  ? do_syscall_64+0x6d/0x90
    [   14.867626]  entry_SYSCALL_64_after_hwframe+0x63/0xcd
    [...] stripped
    [   14.872959]  </TASK>
    
    ('myfpga' is a simple 'uio_dmem_genirq' driver I wrote to test this)
    
    The implementation of "uio_dmem_genirq" was based on "uio_pdrv_genirq" and
    it is used in a similar manner to the "uio_pdrv_genirq" driver with respect
    to interrupt configuration and handling. At the time "uio_dmem_genirq" was
    introduced, both had the same implementation of the 'uio_info' handlers
    irqcontrol() and handler(). Then commit 34cb27528398 ("UIO: Fix concurrency
    issue"), which was only applied to "uio_pdrv_genirq", ended up making them
    a little different. That commit, among other things, changed disable_irq()
    to disable_irq_nosync() in the implementation of irqcontrol(). The
    motivation there was to avoid a deadlock between irqcontrol() and
    handler(), since it added a spinlock in the irq handler, and disable_irq()
    waits for the completion of the irq handler.
    
    By changing disable_irq() to disable_irq_nosync() in irqcontrol(), we also
    avoid the sleeping-while-atomic bug that commit b74351287d4b ("uio: fix a
    sleep-in-atomic-context bug in uio_dmem_genirq_irqcontrol()") was trying to
    fix. Thus, this fixes the missing unlock in irqcontrol() by importing the
    implementation of irqcontrol() handler from the "uio_pdrv_genirq" driver.
    In the end, it reverts commit b74351287d4b ("uio: fix a
    sleep-in-atomic-context bug in uio_dmem_genirq_irqcontrol()") and change
    disable_irq() to disable_irq_nosync().
    
    It is worth noting that this still does not address the concurrency issue
    fixed by commit 34cb27528398 ("UIO: Fix concurrency issue"). It will be
    addressed separately in the next commits.
    
    Split out from commit 34cb27528398 ("UIO: Fix concurrency issue").
    
    Fixes: b74351287d4b ("uio: fix a sleep-in-atomic-context bug in uio_dmem_genirq_irqcontrol()")
    Signed-off-by: Rafael Mendonca <rafaelmendsr@gmail.com>
    Link: https://lore.kernel.org/r/20220930224100.816175-2-rafaelmendsr@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 9bf7a0b2b15cd12e15f7858072bd89933746de67
Author: Rafael Mendonca <rafaelmendsr@gmail.com>
Date:   Fri Sep 30 19:40:57 2022 -0300

    uio: uio_dmem_genirq: Fix missing unlock in irq configuration
    
    [ Upstream commit 9de255c461d1b3f0242b3ad1450c3323a3e00b34 ]
    
    Commit b74351287d4b ("uio: fix a sleep-in-atomic-context bug in
    uio_dmem_genirq_irqcontrol()") started calling disable_irq() without
    holding the spinlock because it can sleep. However, that fix introduced
    another bug: if interrupt is already disabled and a new disable request
    comes in, then the spinlock is not unlocked:
    
    root@localhost:~# printf '\x00\x00\x00\x00' > /dev/uio0
    root@localhost:~# printf '\x00\x00\x00\x00' > /dev/uio0
    root@localhost:~# [   14.851538] BUG: scheduling while atomic: bash/223/0x00000002
    [   14.851991] Modules linked in: uio_dmem_genirq uio myfpga(OE) bochs drm_vram_helper drm_ttm_helper ttm drm_kms_helper drm snd_pcm ppdev joydev psmouse snd_timer snd e1000fb_sys_fops syscopyarea parport sysfillrect soundcore sysimgblt input_leds pcspkr i2c_piix4 serio_raw floppy evbug qemu_fw_cfg mac_hid pata_acpi ip_tables x_tables autofs4 [last unloaded: parport_pc]
    [   14.854206] CPU: 0 PID: 223 Comm: bash Tainted: G           OE      6.0.0-rc7 #21
    [   14.854786] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.0-0-gd239552ce722-prebuilt.qemu.org 04/01/2014
    [   14.855664] Call Trace:
    [   14.855861]  <TASK>
    [   14.856025]  dump_stack_lvl+0x4d/0x67
    [   14.856325]  dump_stack+0x14/0x1a
    [   14.856583]  __schedule_bug.cold+0x4b/0x5c
    [   14.856915]  __schedule+0xe81/0x13d0
    [   14.857199]  ? idr_find+0x13/0x20
    [   14.857456]  ? get_work_pool+0x2d/0x50
    [   14.857756]  ? __flush_work+0x233/0x280
    [   14.858068]  ? __schedule+0xa95/0x13d0
    [   14.858307]  ? idr_find+0x13/0x20
    [   14.858519]  ? get_work_pool+0x2d/0x50
    [   14.858798]  schedule+0x6c/0x100
    [   14.859009]  schedule_hrtimeout_range_clock+0xff/0x110
    [   14.859335]  ? tty_write_room+0x1f/0x30
    [   14.859598]  ? n_tty_poll+0x1ec/0x220
    [   14.859830]  ? tty_ldisc_deref+0x1a/0x20
    [   14.860090]  schedule_hrtimeout_range+0x17/0x20
    [   14.860373]  do_select+0x596/0x840
    [   14.860627]  ? __kernel_text_address+0x16/0x50
    [   14.860954]  ? poll_freewait+0xb0/0xb0
    [   14.861235]  ? poll_freewait+0xb0/0xb0
    [   14.861517]  ? rpm_resume+0x49d/0x780
    [   14.861798]  ? common_interrupt+0x59/0xa0
    [   14.862127]  ? asm_common_interrupt+0x2b/0x40
    [   14.862511]  ? __uart_start.isra.0+0x61/0x70
    [   14.862902]  ? __check_object_size+0x61/0x280
    [   14.863255]  core_sys_select+0x1c6/0x400
    [   14.863575]  ? vfs_write+0x1c9/0x3d0
    [   14.863853]  ? vfs_write+0x1c9/0x3d0
    [   14.864121]  ? _copy_from_user+0x45/0x70
    [   14.864526]  do_pselect.constprop.0+0xb3/0xf0
    [   14.864893]  ? do_syscall_64+0x6d/0x90
    [   14.865228]  ? do_syscall_64+0x6d/0x90
    [   14.865556]  __x64_sys_pselect6+0x76/0xa0
    [   14.865906]  do_syscall_64+0x60/0x90
    [   14.866214]  ? syscall_exit_to_user_mode+0x2a/0x50
    [   14.866640]  ? do_syscall_64+0x6d/0x90
    [   14.866972]  ? do_syscall_64+0x6d/0x90
    [   14.867286]  ? do_syscall_64+0x6d/0x90
    [   14.867626]  entry_SYSCALL_64_after_hwframe+0x63/0xcd
    [...] stripped
    [   14.872959]  </TASK>
    
    ('myfpga' is a simple 'uio_dmem_genirq' driver I wrote to test this)
    
    The implementation of "uio_dmem_genirq" was based on "uio_pdrv_genirq" and
    it is used in a similar manner to the "uio_pdrv_genirq" driver with respect
    to interrupt configuration and handling. At the time "uio_dmem_genirq" was
    introduced, both had the same implementation of the 'uio_info' handlers
    irqcontrol() and handler(). Then commit 34cb27528398 ("UIO: Fix concurrency
    issue"), which was only applied to "uio_pdrv_genirq", ended up making them
    a little different. That commit, among other things, changed disable_irq()
    to disable_irq_nosync() in the implementation of irqcontrol(). The
    motivation there was to avoid a deadlock between irqcontrol() and
    handler(), since it added a spinlock in the irq handler, and disable_irq()
    waits for the completion of the irq handler.
    
    By changing disable_irq() to disable_irq_nosync() in irqcontrol(), we also
    avoid the sleeping-while-atomic bug that commit b74351287d4b ("uio: fix a
    sleep-in-atomic-context bug in uio_dmem_genirq_irqcontrol()") was trying to
    fix. Thus, this fixes the missing unlock in irqcontrol() by importing the
    implementation of irqcontrol() handler from the "uio_pdrv_genirq" driver.
    In the end, it reverts commit b74351287d4b ("uio: fix a
    sleep-in-atomic-context bug in uio_dmem_genirq_irqcontrol()") and change
    disable_irq() to disable_irq_nosync().
    
    It is worth noting that this still does not address the concurrency issue
    fixed by commit 34cb27528398 ("UIO: Fix concurrency issue"). It will be
    addressed separately in the next commits.
    
    Split out from commit 34cb27528398 ("UIO: Fix concurrency issue").
    
    Fixes: b74351287d4b ("uio: fix a sleep-in-atomic-context bug in uio_dmem_genirq_irqcontrol()")
    Signed-off-by: Rafael Mendonca <rafaelmendsr@gmail.com>
    Link: https://lore.kernel.org/r/20220930224100.816175-2-rafaelmendsr@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit f983afc4326c91062abdab6d95312b98a9de0654
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Dec 2 15:30:28 2022 +0100

    PM: runtime: Do not call __rpm_callback() from rpm_idle()
    
    [ Upstream commit bc80c2e438dcbfcf748452ec0f7ad5b79ff3ad88 ]
    
    Calling __rpm_callback() from rpm_idle() after adding device links
    support to the former is a clear mistake.
    
    Not only it causes rpm_idle() to carry out unnecessary actions, but it
    is also against the assumption regarding the stability of PM-runtime
    status across __rpm_callback() invocations, because rpm_suspend() and
    rpm_resume() may run in parallel with __rpm_callback() when it is called
    by rpm_idle() and the device's PM-runtime status can be updated by any
    of them.
    
    Fixes: 21d5c57b3726 ("PM / runtime: Use device links")
    Link: https://lore.kernel.org/linux-pm/36aed941-a73e-d937-2721-4f0decd61ce0@quicinc.com
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Adrian Hunter <adrian.hunter@intel.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 9977cb7af5a8f4738198b020436e2e56c5cd721e
Author: Rafael Mendonca <rafaelmendsr@gmail.com>
Date:   Fri Sep 30 19:40:57 2022 -0300

    uio: uio_dmem_genirq: Fix missing unlock in irq configuration
    
    [ Upstream commit 9de255c461d1b3f0242b3ad1450c3323a3e00b34 ]
    
    Commit b74351287d4b ("uio: fix a sleep-in-atomic-context bug in
    uio_dmem_genirq_irqcontrol()") started calling disable_irq() without
    holding the spinlock because it can sleep. However, that fix introduced
    another bug: if interrupt is already disabled and a new disable request
    comes in, then the spinlock is not unlocked:
    
    root@localhost:~# printf '\x00\x00\x00\x00' > /dev/uio0
    root@localhost:~# printf '\x00\x00\x00\x00' > /dev/uio0
    root@localhost:~# [   14.851538] BUG: scheduling while atomic: bash/223/0x00000002
    [   14.851991] Modules linked in: uio_dmem_genirq uio myfpga(OE) bochs drm_vram_helper drm_ttm_helper ttm drm_kms_helper drm snd_pcm ppdev joydev psmouse snd_timer snd e1000fb_sys_fops syscopyarea parport sysfillrect soundcore sysimgblt input_leds pcspkr i2c_piix4 serio_raw floppy evbug qemu_fw_cfg mac_hid pata_acpi ip_tables x_tables autofs4 [last unloaded: parport_pc]
    [   14.854206] CPU: 0 PID: 223 Comm: bash Tainted: G           OE      6.0.0-rc7 #21
    [   14.854786] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.0-0-gd239552ce722-prebuilt.qemu.org 04/01/2014
    [   14.855664] Call Trace:
    [   14.855861]  <TASK>
    [   14.856025]  dump_stack_lvl+0x4d/0x67
    [   14.856325]  dump_stack+0x14/0x1a
    [   14.856583]  __schedule_bug.cold+0x4b/0x5c
    [   14.856915]  __schedule+0xe81/0x13d0
    [   14.857199]  ? idr_find+0x13/0x20
    [   14.857456]  ? get_work_pool+0x2d/0x50
    [   14.857756]  ? __flush_work+0x233/0x280
    [   14.858068]  ? __schedule+0xa95/0x13d0
    [   14.858307]  ? idr_find+0x13/0x20
    [   14.858519]  ? get_work_pool+0x2d/0x50
    [   14.858798]  schedule+0x6c/0x100
    [   14.859009]  schedule_hrtimeout_range_clock+0xff/0x110
    [   14.859335]  ? tty_write_room+0x1f/0x30
    [   14.859598]  ? n_tty_poll+0x1ec/0x220
    [   14.859830]  ? tty_ldisc_deref+0x1a/0x20
    [   14.860090]  schedule_hrtimeout_range+0x17/0x20
    [   14.860373]  do_select+0x596/0x840
    [   14.860627]  ? __kernel_text_address+0x16/0x50
    [   14.860954]  ? poll_freewait+0xb0/0xb0
    [   14.861235]  ? poll_freewait+0xb0/0xb0
    [   14.861517]  ? rpm_resume+0x49d/0x780
    [   14.861798]  ? common_interrupt+0x59/0xa0
    [   14.862127]  ? asm_common_interrupt+0x2b/0x40
    [   14.862511]  ? __uart_start.isra.0+0x61/0x70
    [   14.862902]  ? __check_object_size+0x61/0x280
    [   14.863255]  core_sys_select+0x1c6/0x400
    [   14.863575]  ? vfs_write+0x1c9/0x3d0
    [   14.863853]  ? vfs_write+0x1c9/0x3d0
    [   14.864121]  ? _copy_from_user+0x45/0x70
    [   14.864526]  do_pselect.constprop.0+0xb3/0xf0
    [   14.864893]  ? do_syscall_64+0x6d/0x90
    [   14.865228]  ? do_syscall_64+0x6d/0x90
    [   14.865556]  __x64_sys_pselect6+0x76/0xa0
    [   14.865906]  do_syscall_64+0x60/0x90
    [   14.866214]  ? syscall_exit_to_user_mode+0x2a/0x50
    [   14.866640]  ? do_syscall_64+0x6d/0x90
    [   14.866972]  ? do_syscall_64+0x6d/0x90
    [   14.867286]  ? do_syscall_64+0x6d/0x90
    [   14.867626]  entry_SYSCALL_64_after_hwframe+0x63/0xcd
    [...] stripped
    [   14.872959]  </TASK>
    
    ('myfpga' is a simple 'uio_dmem_genirq' driver I wrote to test this)
    
    The implementation of "uio_dmem_genirq" was based on "uio_pdrv_genirq" and
    it is used in a similar manner to the "uio_pdrv_genirq" driver with respect
    to interrupt configuration and handling. At the time "uio_dmem_genirq" was
    introduced, both had the same implementation of the 'uio_info' handlers
    irqcontrol() and handler(). Then commit 34cb27528398 ("UIO: Fix concurrency
    issue"), which was only applied to "uio_pdrv_genirq", ended up making them
    a little different. That commit, among other things, changed disable_irq()
    to disable_irq_nosync() in the implementation of irqcontrol(). The
    motivation there was to avoid a deadlock between irqcontrol() and
    handler(), since it added a spinlock in the irq handler, and disable_irq()
    waits for the completion of the irq handler.
    
    By changing disable_irq() to disable_irq_nosync() in irqcontrol(), we also
    avoid the sleeping-while-atomic bug that commit b74351287d4b ("uio: fix a
    sleep-in-atomic-context bug in uio_dmem_genirq_irqcontrol()") was trying to
    fix. Thus, this fixes the missing unlock in irqcontrol() by importing the
    implementation of irqcontrol() handler from the "uio_pdrv_genirq" driver.
    In the end, it reverts commit b74351287d4b ("uio: fix a
    sleep-in-atomic-context bug in uio_dmem_genirq_irqcontrol()") and change
    disable_irq() to disable_irq_nosync().
    
    It is worth noting that this still does not address the concurrency issue
    fixed by commit 34cb27528398 ("UIO: Fix concurrency issue"). It will be
    addressed separately in the next commits.
    
    Split out from commit 34cb27528398 ("UIO: Fix concurrency issue").
    
    Fixes: b74351287d4b ("uio: fix a sleep-in-atomic-context bug in uio_dmem_genirq_irqcontrol()")
    Signed-off-by: Rafael Mendonca <rafaelmendsr@gmail.com>
    Link: https://lore.kernel.org/r/20220930224100.816175-2-rafaelmendsr@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit a354a9e3fc3b5475b80395a3015644e26352223f
Author: Tim Huang <tim.huang@amd.com>
Date:   Mon Dec 19 18:32:32 2022 +0800

    drm/amdgpu: skip mes self test after s0i3 resume for MES IP v11.0
    
    commit 8660495a9c5b9afeec4cc006b3b75178f0fb2f10 upstream.
    
    MES is part of gfxoff and MES suspend and resume are skipped for S0i3.
    But the mes_self_test call path is still in the amdgpu_device_ip_late_init.
    it's should also be skipped for s0ix as no hardware re-initialization
    happened.
    
    Besides, mes_self_test will free the BO that triggers a lot of warning
    messages while in the suspend state.
    
    [   81.656085] WARNING: CPU: 2 PID: 1550 at drivers/gpu/drm/amd/amdgpu/amdgpu_object.c:425 amdgpu_bo_free_kernel+0xfc/0x110 [amdgpu]
    [   81.679435] Call Trace:
    [   81.679726]  <TASK>
    [   81.679981]  amdgpu_mes_remove_hw_queue+0x17a/0x230 [amdgpu]
    [   81.680857]  amdgpu_mes_self_test+0x390/0x430 [amdgpu]
    [   81.681665]  mes_v11_0_late_init+0x37/0x50 [amdgpu]
    [   81.682423]  amdgpu_device_ip_late_init+0x53/0x280 [amdgpu]
    [   81.683257]  amdgpu_device_resume+0xae/0x2a0 [amdgpu]
    [   81.684043]  amdgpu_pmops_resume+0x37/0x70 [amdgpu]
    [   81.684818]  pci_pm_resume+0x5c/0xa0
    [   81.685247]  ? pci_pm_thaw+0x90/0x90
    [   81.685658]  dpm_run_callback+0x4e/0x160
    [   81.686110]  device_resume+0xad/0x210
    [   81.686529]  async_resume+0x1e/0x40
    [   81.686931]  async_run_entry_fn+0x33/0x120
    [   81.687405]  process_one_work+0x21d/0x3f0
    [   81.687869]  worker_thread+0x4a/0x3c0
    [   81.688293]  ? process_one_work+0x3f0/0x3f0
    [   81.688777]  kthread+0xff/0x130
    [   81.689157]  ? kthread_complete_and_exit+0x20/0x20
    [   81.689707]  ret_from_fork+0x22/0x30
    [   81.690118]  </TASK>
    [   81.690380] ---[ end trace 0000000000000000 ]---
    
    v2: make the comment clean and use adev->in_s0ix instead of
    adev->suspend
    
    Signed-off-by: Tim Huang <tim.huang@amd.com>
    Reviewed-by: Mario Limonciello <mario.limonciello@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Cc: stable@vger.kernel.org # 6.0, 6.1
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit ee180e867ce4b2f744799247b81050b3e5dd62cd
Author: Rafael Mendonca <rafaelmendsr@gmail.com>
Date:   Fri Sep 30 19:40:57 2022 -0300

    uio: uio_dmem_genirq: Fix missing unlock in irq configuration
    
    [ Upstream commit 9de255c461d1b3f0242b3ad1450c3323a3e00b34 ]
    
    Commit b74351287d4b ("uio: fix a sleep-in-atomic-context bug in
    uio_dmem_genirq_irqcontrol()") started calling disable_irq() without
    holding the spinlock because it can sleep. However, that fix introduced
    another bug: if interrupt is already disabled and a new disable request
    comes in, then the spinlock is not unlocked:
    
    root@localhost:~# printf '\x00\x00\x00\x00' > /dev/uio0
    root@localhost:~# printf '\x00\x00\x00\x00' > /dev/uio0
    root@localhost:~# [   14.851538] BUG: scheduling while atomic: bash/223/0x00000002
    [   14.851991] Modules linked in: uio_dmem_genirq uio myfpga(OE) bochs drm_vram_helper drm_ttm_helper ttm drm_kms_helper drm snd_pcm ppdev joydev psmouse snd_timer snd e1000fb_sys_fops syscopyarea parport sysfillrect soundcore sysimgblt input_leds pcspkr i2c_piix4 serio_raw floppy evbug qemu_fw_cfg mac_hid pata_acpi ip_tables x_tables autofs4 [last unloaded: parport_pc]
    [   14.854206] CPU: 0 PID: 223 Comm: bash Tainted: G           OE      6.0.0-rc7 #21
    [   14.854786] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.0-0-gd239552ce722-prebuilt.qemu.org 04/01/2014
    [   14.855664] Call Trace:
    [   14.855861]  <TASK>
    [   14.856025]  dump_stack_lvl+0x4d/0x67
    [   14.856325]  dump_stack+0x14/0x1a
    [   14.856583]  __schedule_bug.cold+0x4b/0x5c
    [   14.856915]  __schedule+0xe81/0x13d0
    [   14.857199]  ? idr_find+0x13/0x20
    [   14.857456]  ? get_work_pool+0x2d/0x50
    [   14.857756]  ? __flush_work+0x233/0x280
    [   14.858068]  ? __schedule+0xa95/0x13d0
    [   14.858307]  ? idr_find+0x13/0x20
    [   14.858519]  ? get_work_pool+0x2d/0x50
    [   14.858798]  schedule+0x6c/0x100
    [   14.859009]  schedule_hrtimeout_range_clock+0xff/0x110
    [   14.859335]  ? tty_write_room+0x1f/0x30
    [   14.859598]  ? n_tty_poll+0x1ec/0x220
    [   14.859830]  ? tty_ldisc_deref+0x1a/0x20
    [   14.860090]  schedule_hrtimeout_range+0x17/0x20
    [   14.860373]  do_select+0x596/0x840
    [   14.860627]  ? __kernel_text_address+0x16/0x50
    [   14.860954]  ? poll_freewait+0xb0/0xb0
    [   14.861235]  ? poll_freewait+0xb0/0xb0
    [   14.861517]  ? rpm_resume+0x49d/0x780
    [   14.861798]  ? common_interrupt+0x59/0xa0
    [   14.862127]  ? asm_common_interrupt+0x2b/0x40
    [   14.862511]  ? __uart_start.isra.0+0x61/0x70
    [   14.862902]  ? __check_object_size+0x61/0x280
    [   14.863255]  core_sys_select+0x1c6/0x400
    [   14.863575]  ? vfs_write+0x1c9/0x3d0
    [   14.863853]  ? vfs_write+0x1c9/0x3d0
    [   14.864121]  ? _copy_from_user+0x45/0x70
    [   14.864526]  do_pselect.constprop.0+0xb3/0xf0
    [   14.864893]  ? do_syscall_64+0x6d/0x90
    [   14.865228]  ? do_syscall_64+0x6d/0x90
    [   14.865556]  __x64_sys_pselect6+0x76/0xa0
    [   14.865906]  do_syscall_64+0x60/0x90
    [   14.866214]  ? syscall_exit_to_user_mode+0x2a/0x50
    [   14.866640]  ? do_syscall_64+0x6d/0x90
    [   14.866972]  ? do_syscall_64+0x6d/0x90
    [   14.867286]  ? do_syscall_64+0x6d/0x90
    [   14.867626]  entry_SYSCALL_64_after_hwframe+0x63/0xcd
    [...] stripped
    [   14.872959]  </TASK>
    
    ('myfpga' is a simple 'uio_dmem_genirq' driver I wrote to test this)
    
    The implementation of "uio_dmem_genirq" was based on "uio_pdrv_genirq" and
    it is used in a similar manner to the "uio_pdrv_genirq" driver with respect
    to interrupt configuration and handling. At the time "uio_dmem_genirq" was
    introduced, both had the same implementation of the 'uio_info' handlers
    irqcontrol() and handler(). Then commit 34cb27528398 ("UIO: Fix concurrency
    issue"), which was only applied to "uio_pdrv_genirq", ended up making them
    a little different. That commit, among other things, changed disable_irq()
    to disable_irq_nosync() in the implementation of irqcontrol(). The
    motivation there was to avoid a deadlock between irqcontrol() and
    handler(), since it added a spinlock in the irq handler, and disable_irq()
    waits for the completion of the irq handler.
    
    By changing disable_irq() to disable_irq_nosync() in irqcontrol(), we also
    avoid the sleeping-while-atomic bug that commit b74351287d4b ("uio: fix a
    sleep-in-atomic-context bug in uio_dmem_genirq_irqcontrol()") was trying to
    fix. Thus, this fixes the missing unlock in irqcontrol() by importing the
    implementation of irqcontrol() handler from the "uio_pdrv_genirq" driver.
    In the end, it reverts commit b74351287d4b ("uio: fix a
    sleep-in-atomic-context bug in uio_dmem_genirq_irqcontrol()") and change
    disable_irq() to disable_irq_nosync().
    
    It is worth noting that this still does not address the concurrency issue
    fixed by commit 34cb27528398 ("UIO: Fix concurrency issue"). It will be
    addressed separately in the next commits.
    
    Split out from commit 34cb27528398 ("UIO: Fix concurrency issue").
    
    Fixes: b74351287d4b ("uio: fix a sleep-in-atomic-context bug in uio_dmem_genirq_irqcontrol()")
    Signed-off-by: Rafael Mendonca <rafaelmendsr@gmail.com>
    Link: https://lore.kernel.org/r/20220930224100.816175-2-rafaelmendsr@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 6a5061dd651c40cbd904cf7be67937601f9c5341
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Dec 2 15:30:28 2022 +0100

    PM: runtime: Do not call __rpm_callback() from rpm_idle()
    
    [ Upstream commit bc80c2e438dcbfcf748452ec0f7ad5b79ff3ad88 ]
    
    Calling __rpm_callback() from rpm_idle() after adding device links
    support to the former is a clear mistake.
    
    Not only it causes rpm_idle() to carry out unnecessary actions, but it
    is also against the assumption regarding the stability of PM-runtime
    status across __rpm_callback() invocations, because rpm_suspend() and
    rpm_resume() may run in parallel with __rpm_callback() when it is called
    by rpm_idle() and the device's PM-runtime status can be updated by any
    of them.
    
    Fixes: 21d5c57b3726 ("PM / runtime: Use device links")
    Link: https://lore.kernel.org/linux-pm/36aed941-a73e-d937-2721-4f0decd61ce0@quicinc.com
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Adrian Hunter <adrian.hunter@intel.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 030b6c7bb1e4edebaee2b1e48fbcc9cd5998d51d
Author: Rafael Mendonca <rafaelmendsr@gmail.com>
Date:   Fri Sep 30 19:40:57 2022 -0300

    uio: uio_dmem_genirq: Fix missing unlock in irq configuration
    
    [ Upstream commit 9de255c461d1b3f0242b3ad1450c3323a3e00b34 ]
    
    Commit b74351287d4b ("uio: fix a sleep-in-atomic-context bug in
    uio_dmem_genirq_irqcontrol()") started calling disable_irq() without
    holding the spinlock because it can sleep. However, that fix introduced
    another bug: if interrupt is already disabled and a new disable request
    comes in, then the spinlock is not unlocked:
    
    root@localhost:~# printf '\x00\x00\x00\x00' > /dev/uio0
    root@localhost:~# printf '\x00\x00\x00\x00' > /dev/uio0
    root@localhost:~# [   14.851538] BUG: scheduling while atomic: bash/223/0x00000002
    [   14.851991] Modules linked in: uio_dmem_genirq uio myfpga(OE) bochs drm_vram_helper drm_ttm_helper ttm drm_kms_helper drm snd_pcm ppdev joydev psmouse snd_timer snd e1000fb_sys_fops syscopyarea parport sysfillrect soundcore sysimgblt input_leds pcspkr i2c_piix4 serio_raw floppy evbug qemu_fw_cfg mac_hid pata_acpi ip_tables x_tables autofs4 [last unloaded: parport_pc]
    [   14.854206] CPU: 0 PID: 223 Comm: bash Tainted: G           OE      6.0.0-rc7 #21
    [   14.854786] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.0-0-gd239552ce722-prebuilt.qemu.org 04/01/2014
    [   14.855664] Call Trace:
    [   14.855861]  <TASK>
    [   14.856025]  dump_stack_lvl+0x4d/0x67
    [   14.856325]  dump_stack+0x14/0x1a
    [   14.856583]  __schedule_bug.cold+0x4b/0x5c
    [   14.856915]  __schedule+0xe81/0x13d0
    [   14.857199]  ? idr_find+0x13/0x20
    [   14.857456]  ? get_work_pool+0x2d/0x50
    [   14.857756]  ? __flush_work+0x233/0x280
    [   14.858068]  ? __schedule+0xa95/0x13d0
    [   14.858307]  ? idr_find+0x13/0x20
    [   14.858519]  ? get_work_pool+0x2d/0x50
    [   14.858798]  schedule+0x6c/0x100
    [   14.859009]  schedule_hrtimeout_range_clock+0xff/0x110
    [   14.859335]  ? tty_write_room+0x1f/0x30
    [   14.859598]  ? n_tty_poll+0x1ec/0x220
    [   14.859830]  ? tty_ldisc_deref+0x1a/0x20
    [   14.860090]  schedule_hrtimeout_range+0x17/0x20
    [   14.860373]  do_select+0x596/0x840
    [   14.860627]  ? __kernel_text_address+0x16/0x50
    [   14.860954]  ? poll_freewait+0xb0/0xb0
    [   14.861235]  ? poll_freewait+0xb0/0xb0
    [   14.861517]  ? rpm_resume+0x49d/0x780
    [   14.861798]  ? common_interrupt+0x59/0xa0
    [   14.862127]  ? asm_common_interrupt+0x2b/0x40
    [   14.862511]  ? __uart_start.isra.0+0x61/0x70
    [   14.862902]  ? __check_object_size+0x61/0x280
    [   14.863255]  core_sys_select+0x1c6/0x400
    [   14.863575]  ? vfs_write+0x1c9/0x3d0
    [   14.863853]  ? vfs_write+0x1c9/0x3d0
    [   14.864121]  ? _copy_from_user+0x45/0x70
    [   14.864526]  do_pselect.constprop.0+0xb3/0xf0
    [   14.864893]  ? do_syscall_64+0x6d/0x90
    [   14.865228]  ? do_syscall_64+0x6d/0x90
    [   14.865556]  __x64_sys_pselect6+0x76/0xa0
    [   14.865906]  do_syscall_64+0x60/0x90
    [   14.866214]  ? syscall_exit_to_user_mode+0x2a/0x50
    [   14.866640]  ? do_syscall_64+0x6d/0x90
    [   14.866972]  ? do_syscall_64+0x6d/0x90
    [   14.867286]  ? do_syscall_64+0x6d/0x90
    [   14.867626]  entry_SYSCALL_64_after_hwframe+0x63/0xcd
    [...] stripped
    [   14.872959]  </TASK>
    
    ('myfpga' is a simple 'uio_dmem_genirq' driver I wrote to test this)
    
    The implementation of "uio_dmem_genirq" was based on "uio_pdrv_genirq" and
    it is used in a similar manner to the "uio_pdrv_genirq" driver with respect
    to interrupt configuration and handling. At the time "uio_dmem_genirq" was
    introduced, both had the same implementation of the 'uio_info' handlers
    irqcontrol() and handler(). Then commit 34cb27528398 ("UIO: Fix concurrency
    issue"), which was only applied to "uio_pdrv_genirq", ended up making them
    a little different. That commit, among other things, changed disable_irq()
    to disable_irq_nosync() in the implementation of irqcontrol(). The
    motivation there was to avoid a deadlock between irqcontrol() and
    handler(), since it added a spinlock in the irq handler, and disable_irq()
    waits for the completion of the irq handler.
    
    By changing disable_irq() to disable_irq_nosync() in irqcontrol(), we also
    avoid the sleeping-while-atomic bug that commit b74351287d4b ("uio: fix a
    sleep-in-atomic-context bug in uio_dmem_genirq_irqcontrol()") was trying to
    fix. Thus, this fixes the missing unlock in irqcontrol() by importing the
    implementation of irqcontrol() handler from the "uio_pdrv_genirq" driver.
    In the end, it reverts commit b74351287d4b ("uio: fix a
    sleep-in-atomic-context bug in uio_dmem_genirq_irqcontrol()") and change
    disable_irq() to disable_irq_nosync().
    
    It is worth noting that this still does not address the concurrency issue
    fixed by commit 34cb27528398 ("UIO: Fix concurrency issue"). It will be
    addressed separately in the next commits.
    
    Split out from commit 34cb27528398 ("UIO: Fix concurrency issue").
    
    Fixes: b74351287d4b ("uio: fix a sleep-in-atomic-context bug in uio_dmem_genirq_irqcontrol()")
    Signed-off-by: Rafael Mendonca <rafaelmendsr@gmail.com>
    Link: https://lore.kernel.org/r/20220930224100.816175-2-rafaelmendsr@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit b277b15909ecb0dd3e4f41e598aa8a35bc385ad2
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Dec 2 15:30:28 2022 +0100

    PM: runtime: Do not call __rpm_callback() from rpm_idle()
    
    [ Upstream commit bc80c2e438dcbfcf748452ec0f7ad5b79ff3ad88 ]
    
    Calling __rpm_callback() from rpm_idle() after adding device links
    support to the former is a clear mistake.
    
    Not only it causes rpm_idle() to carry out unnecessary actions, but it
    is also against the assumption regarding the stability of PM-runtime
    status across __rpm_callback() invocations, because rpm_suspend() and
    rpm_resume() may run in parallel with __rpm_callback() when it is called
    by rpm_idle() and the device's PM-runtime status can be updated by any
    of them.
    
    Fixes: 21d5c57b3726 ("PM / runtime: Use device links")
    Link: https://lore.kernel.org/linux-pm/36aed941-a73e-d937-2721-4f0decd61ce0@quicinc.com
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Adrian Hunter <adrian.hunter@intel.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 79a4bdb6b9920134af1a4738a1fa36a0438cd905
Author: Rafael Mendonca <rafaelmendsr@gmail.com>
Date:   Fri Sep 30 19:40:57 2022 -0300

    uio: uio_dmem_genirq: Fix missing unlock in irq configuration
    
    [ Upstream commit 9de255c461d1b3f0242b3ad1450c3323a3e00b34 ]
    
    Commit b74351287d4b ("uio: fix a sleep-in-atomic-context bug in
    uio_dmem_genirq_irqcontrol()") started calling disable_irq() without
    holding the spinlock because it can sleep. However, that fix introduced
    another bug: if interrupt is already disabled and a new disable request
    comes in, then the spinlock is not unlocked:
    
    root@localhost:~# printf '\x00\x00\x00\x00' > /dev/uio0
    root@localhost:~# printf '\x00\x00\x00\x00' > /dev/uio0
    root@localhost:~# [   14.851538] BUG: scheduling while atomic: bash/223/0x00000002
    [   14.851991] Modules linked in: uio_dmem_genirq uio myfpga(OE) bochs drm_vram_helper drm_ttm_helper ttm drm_kms_helper drm snd_pcm ppdev joydev psmouse snd_timer snd e1000fb_sys_fops syscopyarea parport sysfillrect soundcore sysimgblt input_leds pcspkr i2c_piix4 serio_raw floppy evbug qemu_fw_cfg mac_hid pata_acpi ip_tables x_tables autofs4 [last unloaded: parport_pc]
    [   14.854206] CPU: 0 PID: 223 Comm: bash Tainted: G           OE      6.0.0-rc7 #21
    [   14.854786] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.0-0-gd239552ce722-prebuilt.qemu.org 04/01/2014
    [   14.855664] Call Trace:
    [   14.855861]  <TASK>
    [   14.856025]  dump_stack_lvl+0x4d/0x67
    [   14.856325]  dump_stack+0x14/0x1a
    [   14.856583]  __schedule_bug.cold+0x4b/0x5c
    [   14.856915]  __schedule+0xe81/0x13d0
    [   14.857199]  ? idr_find+0x13/0x20
    [   14.857456]  ? get_work_pool+0x2d/0x50
    [   14.857756]  ? __flush_work+0x233/0x280
    [   14.858068]  ? __schedule+0xa95/0x13d0
    [   14.858307]  ? idr_find+0x13/0x20
    [   14.858519]  ? get_work_pool+0x2d/0x50
    [   14.858798]  schedule+0x6c/0x100
    [   14.859009]  schedule_hrtimeout_range_clock+0xff/0x110
    [   14.859335]  ? tty_write_room+0x1f/0x30
    [   14.859598]  ? n_tty_poll+0x1ec/0x220
    [   14.859830]  ? tty_ldisc_deref+0x1a/0x20
    [   14.860090]  schedule_hrtimeout_range+0x17/0x20
    [   14.860373]  do_select+0x596/0x840
    [   14.860627]  ? __kernel_text_address+0x16/0x50
    [   14.860954]  ? poll_freewait+0xb0/0xb0
    [   14.861235]  ? poll_freewait+0xb0/0xb0
    [   14.861517]  ? rpm_resume+0x49d/0x780
    [   14.861798]  ? common_interrupt+0x59/0xa0
    [   14.862127]  ? asm_common_interrupt+0x2b/0x40
    [   14.862511]  ? __uart_start.isra.0+0x61/0x70
    [   14.862902]  ? __check_object_size+0x61/0x280
    [   14.863255]  core_sys_select+0x1c6/0x400
    [   14.863575]  ? vfs_write+0x1c9/0x3d0
    [   14.863853]  ? vfs_write+0x1c9/0x3d0
    [   14.864121]  ? _copy_from_user+0x45/0x70
    [   14.864526]  do_pselect.constprop.0+0xb3/0xf0
    [   14.864893]  ? do_syscall_64+0x6d/0x90
    [   14.865228]  ? do_syscall_64+0x6d/0x90
    [   14.865556]  __x64_sys_pselect6+0x76/0xa0
    [   14.865906]  do_syscall_64+0x60/0x90
    [   14.866214]  ? syscall_exit_to_user_mode+0x2a/0x50
    [   14.866640]  ? do_syscall_64+0x6d/0x90
    [   14.866972]  ? do_syscall_64+0x6d/0x90
    [   14.867286]  ? do_syscall_64+0x6d/0x90
    [   14.867626]  entry_SYSCALL_64_after_hwframe+0x63/0xcd
    [...] stripped
    [   14.872959]  </TASK>
    
    ('myfpga' is a simple 'uio_dmem_genirq' driver I wrote to test this)
    
    The implementation of "uio_dmem_genirq" was based on "uio_pdrv_genirq" and
    it is used in a similar manner to the "uio_pdrv_genirq" driver with respect
    to interrupt configuration and handling. At the time "uio_dmem_genirq" was
    introduced, both had the same implementation of the 'uio_info' handlers
    irqcontrol() and handler(). Then commit 34cb27528398 ("UIO: Fix concurrency
    issue"), which was only applied to "uio_pdrv_genirq", ended up making them
    a little different. That commit, among other things, changed disable_irq()
    to disable_irq_nosync() in the implementation of irqcontrol(). The
    motivation there was to avoid a deadlock between irqcontrol() and
    handler(), since it added a spinlock in the irq handler, and disable_irq()
    waits for the completion of the irq handler.
    
    By changing disable_irq() to disable_irq_nosync() in irqcontrol(), we also
    avoid the sleeping-while-atomic bug that commit b74351287d4b ("uio: fix a
    sleep-in-atomic-context bug in uio_dmem_genirq_irqcontrol()") was trying to
    fix. Thus, this fixes the missing unlock in irqcontrol() by importing the
    implementation of irqcontrol() handler from the "uio_pdrv_genirq" driver.
    In the end, it reverts commit b74351287d4b ("uio: fix a
    sleep-in-atomic-context bug in uio_dmem_genirq_irqcontrol()") and change
    disable_irq() to disable_irq_nosync().
    
    It is worth noting that this still does not address the concurrency issue
    fixed by commit 34cb27528398 ("UIO: Fix concurrency issue"). It will be
    addressed separately in the next commits.
    
    Split out from commit 34cb27528398 ("UIO: Fix concurrency issue").
    
    Fixes: b74351287d4b ("uio: fix a sleep-in-atomic-context bug in uio_dmem_genirq_irqcontrol()")
    Signed-off-by: Rafael Mendonca <rafaelmendsr@gmail.com>
    Link: https://lore.kernel.org/r/20220930224100.816175-2-rafaelmendsr@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit b55ef8508ac482703dc90d111664748dda2608c7
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Dec 2 15:30:28 2022 +0100

    PM: runtime: Do not call __rpm_callback() from rpm_idle()
    
    [ Upstream commit bc80c2e438dcbfcf748452ec0f7ad5b79ff3ad88 ]
    
    Calling __rpm_callback() from rpm_idle() after adding device links
    support to the former is a clear mistake.
    
    Not only it causes rpm_idle() to carry out unnecessary actions, but it
    is also against the assumption regarding the stability of PM-runtime
    status across __rpm_callback() invocations, because rpm_suspend() and
    rpm_resume() may run in parallel with __rpm_callback() when it is called
    by rpm_idle() and the device's PM-runtime status can be updated by any
    of them.
    
    Fixes: 21d5c57b3726 ("PM / runtime: Use device links")
    Link: https://lore.kernel.org/linux-pm/36aed941-a73e-d937-2721-4f0decd61ce0@quicinc.com
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Adrian Hunter <adrian.hunter@intel.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 8660495a9c5b9afeec4cc006b3b75178f0fb2f10
Author: Tim Huang <tim.huang@amd.com>
Date:   Mon Dec 19 18:32:32 2022 +0800

    drm/amdgpu: skip mes self test after s0i3 resume for MES IP v11.0
    
    MES is part of gfxoff and MES suspend and resume are skipped for S0i3.
    But the mes_self_test call path is still in the amdgpu_device_ip_late_init.
    it's should also be skipped for s0ix as no hardware re-initialization
    happened.
    
    Besides, mes_self_test will free the BO that triggers a lot of warning
    messages while in the suspend state.
    
    [   81.656085] WARNING: CPU: 2 PID: 1550 at drivers/gpu/drm/amd/amdgpu/amdgpu_object.c:425 amdgpu_bo_free_kernel+0xfc/0x110 [amdgpu]
    [   81.679435] Call Trace:
    [   81.679726]  <TASK>
    [   81.679981]  amdgpu_mes_remove_hw_queue+0x17a/0x230 [amdgpu]
    [   81.680857]  amdgpu_mes_self_test+0x390/0x430 [amdgpu]
    [   81.681665]  mes_v11_0_late_init+0x37/0x50 [amdgpu]
    [   81.682423]  amdgpu_device_ip_late_init+0x53/0x280 [amdgpu]
    [   81.683257]  amdgpu_device_resume+0xae/0x2a0 [amdgpu]
    [   81.684043]  amdgpu_pmops_resume+0x37/0x70 [amdgpu]
    [   81.684818]  pci_pm_resume+0x5c/0xa0
    [   81.685247]  ? pci_pm_thaw+0x90/0x90
    [   81.685658]  dpm_run_callback+0x4e/0x160
    [   81.686110]  device_resume+0xad/0x210
    [   81.686529]  async_resume+0x1e/0x40
    [   81.686931]  async_run_entry_fn+0x33/0x120
    [   81.687405]  process_one_work+0x21d/0x3f0
    [   81.687869]  worker_thread+0x4a/0x3c0
    [   81.688293]  ? process_one_work+0x3f0/0x3f0
    [   81.688777]  kthread+0xff/0x130
    [   81.689157]  ? kthread_complete_and_exit+0x20/0x20
    [   81.689707]  ret_from_fork+0x22/0x30
    [   81.690118]  </TASK>
    [   81.690380] ---[ end trace 0000000000000000 ]---
    
    v2: make the comment clean and use adev->in_s0ix instead of
    adev->suspend
    
    Signed-off-by: Tim Huang <tim.huang@amd.com>
    Reviewed-by: Mario Limonciello <mario.limonciello@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Cc: stable@vger.kernel.org # 6.0, 6.1

commit 5e26531d8113da79dbc03b92d84ea47fa87683af
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Mar 5 12:21:40 2021 +0000

    rtc: cmos: Disable irq around direct invocation of cmos_interrupt()
    
    [ Upstream commit 13be2efc390acd2a46a69a359f6efc00ca434599 ]
    
    As previously noted in commit 66e4f4a9cc38 ("rtc: cmos: Use
    spin_lock_irqsave() in cmos_interrupt()"):
    
    <4>[  254.192378] WARNING: inconsistent lock state
    <4>[  254.192384] 5.12.0-rc1-CI-CI_DRM_9834+ #1 Not tainted
    <4>[  254.192396] --------------------------------
    <4>[  254.192400] inconsistent {IN-HARDIRQ-W} -> {HARDIRQ-ON-W} usage.
    <4>[  254.192409] rtcwake/5309 [HC0[0]:SC0[0]:HE1:SE1] takes:
    <4>[  254.192429] ffffffff8263c5f8 (rtc_lock){?...}-{2:2}, at: cmos_interrupt+0x18/0x100
    <4>[  254.192481] {IN-HARDIRQ-W} state was registered at:
    <4>[  254.192488]   lock_acquire+0xd1/0x3d0
    <4>[  254.192504]   _raw_spin_lock+0x2a/0x40
    <4>[  254.192519]   cmos_interrupt+0x18/0x100
    <4>[  254.192536]   rtc_handler+0x1f/0xc0
    <4>[  254.192553]   acpi_ev_fixed_event_detect+0x109/0x13c
    <4>[  254.192574]   acpi_ev_sci_xrupt_handler+0xb/0x28
    <4>[  254.192596]   acpi_irq+0x13/0x30
    <4>[  254.192620]   __handle_irq_event_percpu+0x43/0x2c0
    <4>[  254.192641]   handle_irq_event_percpu+0x2b/0x70
    <4>[  254.192661]   handle_irq_event+0x2f/0x50
    <4>[  254.192680]   handle_fasteoi_irq+0x9e/0x150
    <4>[  254.192693]   __common_interrupt+0x76/0x140
    <4>[  254.192715]   common_interrupt+0x96/0xc0
    <4>[  254.192732]   asm_common_interrupt+0x1e/0x40
    <4>[  254.192750]   _raw_spin_unlock_irqrestore+0x38/0x60
    <4>[  254.192767]   resume_irqs+0xba/0xf0
    <4>[  254.192786]   dpm_resume_noirq+0x245/0x3d0
    <4>[  254.192811]   suspend_devices_and_enter+0x230/0xaa0
    <4>[  254.192835]   pm_suspend.cold.8+0x301/0x34a
    <4>[  254.192859]   state_store+0x7b/0xe0
    <4>[  254.192879]   kernfs_fop_write_iter+0x11d/0x1c0
    <4>[  254.192899]   new_sync_write+0x11d/0x1b0
    <4>[  254.192916]   vfs_write+0x265/0x390
    <4>[  254.192933]   ksys_write+0x5a/0xd0
    <4>[  254.192949]   do_syscall_64+0x33/0x80
    <4>[  254.192965]   entry_SYSCALL_64_after_hwframe+0x44/0xae
    <4>[  254.192986] irq event stamp: 43775
    <4>[  254.192994] hardirqs last  enabled at (43775): [<ffffffff81c00c42>] asm_sysvec_apic_timer_interrupt+0x12/0x20
    <4>[  254.193023] hardirqs last disabled at (43774): [<ffffffff81aa691a>] sysvec_apic_timer_interrupt+0xa/0xb0
    <4>[  254.193049] softirqs last  enabled at (42548): [<ffffffff81e00342>] __do_softirq+0x342/0x48e
    <4>[  254.193074] softirqs last disabled at (42543): [<ffffffff810b45fd>] irq_exit_rcu+0xad/0xd0
    <4>[  254.193101]
                      other info that might help us debug this:
    <4>[  254.193107]  Possible unsafe locking scenario:
    
    <4>[  254.193112]        CPU0
    <4>[  254.193117]        ----
    <4>[  254.193121]   lock(rtc_lock);
    <4>[  254.193137]   <Interrupt>
    <4>[  254.193142]     lock(rtc_lock);
    <4>[  254.193156]
                       *** DEADLOCK ***
    
    <4>[  254.193161] 6 locks held by rtcwake/5309:
    <4>[  254.193174]  #0: ffff888104861430 (sb_writers#5){.+.+}-{0:0}, at: ksys_write+0x5a/0xd0
    <4>[  254.193232]  #1: ffff88810f823288 (&of->mutex){+.+.}-{3:3}, at: kernfs_fop_write_iter+0xe7/0x1c0
    <4>[  254.193282]  #2: ffff888100cef3c0 (kn->active#285
    <7>[  254.192706] i915 0000:00:02.0: [drm:intel_modeset_setup_hw_state [i915]] [CRTC:51:pipe A] hw state readout: disabled
    <4>[  254.193307] ){.+.+}-{0:0}, at: kernfs_fop_write_iter+0xf0/0x1c0
    <4>[  254.193333]  #3: ffffffff82649fa8 (system_transition_mutex){+.+.}-{3:3}, at: pm_suspend.cold.8+0xce/0x34a
    <4>[  254.193387]  #4: ffffffff827a2108 (acpi_scan_lock){+.+.}-{3:3}, at: acpi_suspend_begin+0x47/0x70
    <4>[  254.193433]  #5: ffff8881019ea178 (&dev->mutex){....}-{3:3}, at: device_resume+0x68/0x1e0
    <4>[  254.193485]
                      stack backtrace:
    <4>[  254.193492] CPU: 1 PID: 5309 Comm: rtcwake Not tainted 5.12.0-rc1-CI-CI_DRM_9834+ #1
    <4>[  254.193514] Hardware name: Google Soraka/Soraka, BIOS MrChromebox-4.10 08/25/2019
    <4>[  254.193524] Call Trace:
    <4>[  254.193536]  dump_stack+0x7f/0xad
    <4>[  254.193567]  mark_lock.part.47+0x8ca/0xce0
    <4>[  254.193604]  __lock_acquire+0x39b/0x2590
    <4>[  254.193626]  ? asm_sysvec_apic_timer_interrupt+0x12/0x20
    <4>[  254.193660]  lock_acquire+0xd1/0x3d0
    <4>[  254.193677]  ? cmos_interrupt+0x18/0x100
    <4>[  254.193716]  _raw_spin_lock+0x2a/0x40
    <4>[  254.193735]  ? cmos_interrupt+0x18/0x100
    <4>[  254.193758]  cmos_interrupt+0x18/0x100
    <4>[  254.193785]  cmos_resume+0x2ac/0x2d0
    <4>[  254.193813]  ? acpi_pm_set_device_wakeup+0x1f/0x110
    <4>[  254.193842]  ? pnp_bus_suspend+0x10/0x10
    <4>[  254.193864]  pnp_bus_resume+0x5e/0x90
    <4>[  254.193885]  dpm_run_callback+0x5f/0x240
    <4>[  254.193914]  device_resume+0xb2/0x1e0
    <4>[  254.193942]  ? pm_dev_err+0x25/0x25
    <4>[  254.193974]  dpm_resume+0xea/0x3f0
    <4>[  254.194005]  dpm_resume_end+0x8/0x10
    <4>[  254.194030]  suspend_devices_and_enter+0x29b/0xaa0
    <4>[  254.194066]  pm_suspend.cold.8+0x301/0x34a
    <4>[  254.194094]  state_store+0x7b/0xe0
    <4>[  254.194124]  kernfs_fop_write_iter+0x11d/0x1c0
    <4>[  254.194151]  new_sync_write+0x11d/0x1b0
    <4>[  254.194183]  vfs_write+0x265/0x390
    <4>[  254.194207]  ksys_write+0x5a/0xd0
    <4>[  254.194232]  do_syscall_64+0x33/0x80
    <4>[  254.194251]  entry_SYSCALL_64_after_hwframe+0x44/0xae
    <4>[  254.194274] RIP: 0033:0x7f07d79691e7
    <4>[  254.194293] Code: 64 89 02 48 c7 c0 ff ff ff ff eb bb 0f 1f 80 00 00 00 00 f3 0f 1e fa 64 8b 04 25 18 00 00 00 85 c0 75 10 b8 01 00 00 00 0f 05 <48> 3d 00 f0 ff ff 77 51 c3 48 83 ec 28 48 89 54 24 18 48 89 74 24
    <4>[  254.194312] RSP: 002b:00007ffd9cc2c768 EFLAGS: 00000246 ORIG_RAX: 0000000000000001
    <4>[  254.194337] RAX: ffffffffffffffda RBX: 0000000000000004 RCX: 00007f07d79691e7
    <4>[  254.194352] RDX: 0000000000000004 RSI: 0000556ebfc63590 RDI: 000000000000000b
    <4>[  254.194366] RBP: 0000556ebfc63590 R08: 0000000000000000 R09: 0000000000000004
    <4>[  254.194379] R10: 0000556ebf0ec2a6 R11: 0000000000000246 R12: 0000000000000004
    
    which breaks S3-resume on fi-kbl-soraka presumably as that's slow enough
    to trigger the alarm during the suspend.
    
    Fixes: 6950d046eb6e ("rtc: cmos: Replace spin_lock_irqsave with spin_lock in hard IRQ")
    References: 66e4f4a9cc38 ("rtc: cmos: Use spin_lock_irqsave() in cmos_interrupt()"):
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Xiaofei Tan <tanxiaofei@huawei.com>
    Cc: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Cc: Alessandro Zummo <a.zummo@towertech.it>
    Cc: Ville Syrjl <ville.syrjala@linux.intel.com>
    Reviewed-by: Ville Syrjl <ville.syrjala@linux.intel.com>
    Signed-off-by: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Link: https://lore.kernel.org/r/20210305122140.28774-1-chris@chris-wilson.co.uk
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit bc80c2e438dcbfcf748452ec0f7ad5b79ff3ad88
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Dec 2 15:30:28 2022 +0100

    PM: runtime: Do not call __rpm_callback() from rpm_idle()
    
    Calling __rpm_callback() from rpm_idle() after adding device links
    support to the former is a clear mistake.
    
    Not only it causes rpm_idle() to carry out unnecessary actions, but it
    is also against the assumption regarding the stability of PM-runtime
    status across __rpm_callback() invocations, because rpm_suspend() and
    rpm_resume() may run in parallel with __rpm_callback() when it is called
    by rpm_idle() and the device's PM-runtime status can be updated by any
    of them.
    
    Fixes: 21d5c57b3726 ("PM / runtime: Use device links")
    Link: https://lore.kernel.org/linux-pm/36aed941-a73e-d937-2721-4f0decd61ce0@quicinc.com
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Adrian Hunter <adrian.hunter@intel.com>

commit e3f9d87d6f0732827c443bd1474df21c2fad704b
Author: Shawn Guo <shawn.guo@linaro.org>
Date:   Wed Oct 12 20:13:53 2022 +0800

    serial: imx: Add missing .thaw_noirq hook
    
    [ Upstream commit 4561d8008a467cb05ac632a215391d6b787f40aa ]
    
    The following warning is seen with non-console UART instance when
    system hibernates.
    
    [   37.371969] ------------[ cut here ]------------
    [   37.376599] uart3_root_clk already disabled
    [   37.380810] WARNING: CPU: 0 PID: 296 at drivers/clk/clk.c:952 clk_core_disable+0xa4/0xb0
    ...
    [   37.506986] Call trace:
    [   37.509432]  clk_core_disable+0xa4/0xb0
    [   37.513270]  clk_disable+0x34/0x50
    [   37.516672]  imx_uart_thaw+0x38/0x5c
    [   37.520250]  platform_pm_thaw+0x30/0x6c
    [   37.524089]  dpm_run_callback.constprop.0+0x3c/0xd4
    [   37.528972]  device_resume+0x7c/0x160
    [   37.532633]  dpm_resume+0xe8/0x230
    [   37.536036]  hibernation_snapshot+0x288/0x430
    [   37.540397]  hibernate+0x10c/0x2e0
    [   37.543798]  state_store+0xc4/0xd0
    [   37.547203]  kobj_attr_store+0x1c/0x30
    [   37.550953]  sysfs_kf_write+0x48/0x60
    [   37.554619]  kernfs_fop_write_iter+0x118/0x1ac
    [   37.559063]  new_sync_write+0xe8/0x184
    [   37.562812]  vfs_write+0x230/0x290
    [   37.566214]  ksys_write+0x68/0xf4
    [   37.569529]  __arm64_sys_write+0x20/0x2c
    [   37.573452]  invoke_syscall.constprop.0+0x50/0xf0
    [   37.578156]  do_el0_svc+0x11c/0x150
    [   37.581648]  el0_svc+0x30/0x140
    [   37.584792]  el0t_64_sync_handler+0xe8/0xf0
    [   37.588976]  el0t_64_sync+0x1a0/0x1a4
    [   37.592639] ---[ end trace 56e22eec54676d75 ]---
    
    On hibernating, pm core calls into related hooks in sequence like:
    
        .freeze
        .freeze_noirq
        .thaw_noirq
        .thaw
    
    With .thaw_noirq hook being absent, the clock will be disabled in a
    unbalanced call which results the warning above.
    
        imx_uart_freeze()
            clk_prepare_enable()
        imx_uart_suspend_noirq()
            clk_disable()
        imx_uart_thaw
            clk_disable_unprepare()
    
    Adding the missing .thaw_noirq hook as imx_uart_resume_noirq() will have
    the call sequence corrected as below and thus fix the warning.
    
        imx_uart_freeze()
            clk_prepare_enable()
        imx_uart_suspend_noirq()
            clk_disable()
        imx_uart_resume_noirq()
            clk_enable()
        imx_uart_thaw
            clk_disable_unprepare()
    
    Fixes: 09df0b3464e5 ("serial: imx: fix endless loop during suspend")
    Reviewed-by: Martin Kaiser <martin@kaiser.cx>
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>
    Link: https://lore.kernel.org/r/20221012121353.2346280-1-shawn.guo@linaro.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 0f24635c2d239020c8b0223a6911fcec5d02d5cd
Author: Mario Limonciello <mario.limonciello@amd.com>
Date:   Wed Oct 26 14:03:55 2022 -0500

    drm/amd: Fail the suspend if resources can't be evicted
    
    [ Upstream commit 8d4de331f1b24a22d18e3c6116aa25228cf54854 ]
    
    If a system does not have swap and memory is under 100% usage,
    amdgpu will fail to evict resources.  Currently the suspend
    carries on proceeding to reset the GPU:
    
    ```
    [drm] evicting device resources failed
    [drm:amdgpu_device_ip_suspend_phase2 [amdgpu]] *ERROR* suspend of IP block <vcn_v3_0> failed -12
    [drm] free PSP TMR buffer
    [TTM] Failed allocating page table
    [drm] evicting device resources failed
    amdgpu 0000:03:00.0: amdgpu: MODE1 reset
    amdgpu 0000:03:00.0: amdgpu: GPU mode1 reset
    amdgpu 0000:03:00.0: amdgpu: GPU smu mode1 reset
    ```
    
    At this point if the suspend actually succeeded I think that amdgpu
    would have recovered because the GPU would have power cut off and
    restored.  However the kernel fails to continue the suspend from the
    memory pressure and amdgpu fails to run the "resume" from the aborted
    suspend.
    
    ```
    ACPI: PM: Preparing to enter system sleep state S3
    SLUB: Unable to allocate memory on node -1, gfp=0xdc0(GFP_KERNEL|__GFP_ZERO)
      cache: Acpi-State, object size: 80, buffer size: 80, default order: 0, min order: 0
      node 0: slabs: 22, objs: 1122, free: 0
    ACPI Error: AE_NO_MEMORY, Could not update object reference count (20210730/utdelete-651)
    
    [drm:psp_hw_start [amdgpu]] *ERROR* PSP load kdb failed!
    [drm:psp_resume [amdgpu]] *ERROR* PSP resume failed
    [drm:amdgpu_device_fw_loading [amdgpu]] *ERROR* resume of IP block <psp> failed -62
    amdgpu 0000:03:00.0: amdgpu: amdgpu_device_ip_resume failed (-62).
    PM: dpm_run_callback(): pci_pm_resume+0x0/0x100 returns -62
    amdgpu 0000:03:00.0: PM: failed to resume async: error -62
    ```
    
    To avoid this series of unfortunate events, fail amdgpu's suspend
    when the memory eviction fails.  This will let the system gracefully
    recover and the user can try suspend again when the memory pressure
    is relieved.
    
    Reported-by: post@davidak.de
    Link: https://gitlab.freedesktop.org/drm/amd/-/issues/2223
    Signed-off-by: Mario Limonciello <mario.limonciello@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Acked-by: Christian Knig <christian.koenig@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit ae22294e213a402a70fa1731538367d1b758ffe7
Author: Shawn Guo <shawn.guo@linaro.org>
Date:   Wed Oct 12 20:13:53 2022 +0800

    serial: imx: Add missing .thaw_noirq hook
    
    [ Upstream commit 4561d8008a467cb05ac632a215391d6b787f40aa ]
    
    The following warning is seen with non-console UART instance when
    system hibernates.
    
    [   37.371969] ------------[ cut here ]------------
    [   37.376599] uart3_root_clk already disabled
    [   37.380810] WARNING: CPU: 0 PID: 296 at drivers/clk/clk.c:952 clk_core_disable+0xa4/0xb0
    ...
    [   37.506986] Call trace:
    [   37.509432]  clk_core_disable+0xa4/0xb0
    [   37.513270]  clk_disable+0x34/0x50
    [   37.516672]  imx_uart_thaw+0x38/0x5c
    [   37.520250]  platform_pm_thaw+0x30/0x6c
    [   37.524089]  dpm_run_callback.constprop.0+0x3c/0xd4
    [   37.528972]  device_resume+0x7c/0x160
    [   37.532633]  dpm_resume+0xe8/0x230
    [   37.536036]  hibernation_snapshot+0x288/0x430
    [   37.540397]  hibernate+0x10c/0x2e0
    [   37.543798]  state_store+0xc4/0xd0
    [   37.547203]  kobj_attr_store+0x1c/0x30
    [   37.550953]  sysfs_kf_write+0x48/0x60
    [   37.554619]  kernfs_fop_write_iter+0x118/0x1ac
    [   37.559063]  new_sync_write+0xe8/0x184
    [   37.562812]  vfs_write+0x230/0x290
    [   37.566214]  ksys_write+0x68/0xf4
    [   37.569529]  __arm64_sys_write+0x20/0x2c
    [   37.573452]  invoke_syscall.constprop.0+0x50/0xf0
    [   37.578156]  do_el0_svc+0x11c/0x150
    [   37.581648]  el0_svc+0x30/0x140
    [   37.584792]  el0t_64_sync_handler+0xe8/0xf0
    [   37.588976]  el0t_64_sync+0x1a0/0x1a4
    [   37.592639] ---[ end trace 56e22eec54676d75 ]---
    
    On hibernating, pm core calls into related hooks in sequence like:
    
        .freeze
        .freeze_noirq
        .thaw_noirq
        .thaw
    
    With .thaw_noirq hook being absent, the clock will be disabled in a
    unbalanced call which results the warning above.
    
        imx_uart_freeze()
            clk_prepare_enable()
        imx_uart_suspend_noirq()
            clk_disable()
        imx_uart_thaw
            clk_disable_unprepare()
    
    Adding the missing .thaw_noirq hook as imx_uart_resume_noirq() will have
    the call sequence corrected as below and thus fix the warning.
    
        imx_uart_freeze()
            clk_prepare_enable()
        imx_uart_suspend_noirq()
            clk_disable()
        imx_uart_resume_noirq()
            clk_enable()
        imx_uart_thaw
            clk_disable_unprepare()
    
    Fixes: 09df0b3464e5 ("serial: imx: fix endless loop during suspend")
    Reviewed-by: Martin Kaiser <martin@kaiser.cx>
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>
    Link: https://lore.kernel.org/r/20221012121353.2346280-1-shawn.guo@linaro.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 47c3bdd95505bc28c264ce1e78b985cdb05cc15f
Author: Lukas Wunner <lukas@wunner.de>
Date:   Fri Jul 1 22:47:51 2022 +0200

    usbnet: smsc95xx: Fix deadlock on runtime resume
    
    [ Upstream commit 7b960c967f2aa01ab8f45c5a0bd78e754cffdeee ]
    
    Commit 05b35e7eb9a1 ("smsc95xx: add phylib support") amended
    smsc95xx_resume() to call phy_init_hw().  That function waits for the
    device to runtime resume even though it is placed in the runtime resume
    path, causing a deadlock.
    
    The problem is that phy_init_hw() calls down to smsc95xx_mdiobus_read(),
    which never uses the _nopm variant of usbnet_read_cmd().
    
    Commit b4df480f68ae ("usbnet: smsc95xx: add reset_resume function with
    reset operation") causes a similar deadlock on resume if the device was
    already runtime suspended when entering system sleep:
    
    That's because the commit introduced smsc95xx_reset_resume(), which
    calls down to smsc95xx_reset(), which neglects to use _nopm accessors.
    
    Fix by auto-detecting whether a device access is performed by the
    suspend/resume task_struct and use the _nopm variant if so.  This works
    because the PM core guarantees that suspend/resume callbacks are run in
    task context.
    
    Stacktrace for posterity:
    
      INFO: task kworker/2:1:49 blocked for more than 122 seconds.
      Workqueue: usb_hub_wq hub_event
      schedule
      rpm_resume
      __pm_runtime_resume
      usb_autopm_get_interface
      usbnet_read_cmd
      __smsc95xx_read_reg
      __smsc95xx_phy_wait_not_busy
      __smsc95xx_mdio_read
      smsc95xx_mdiobus_read
      __mdiobus_read
      mdiobus_read
      smsc_phy_reset
      phy_init_hw
      smsc95xx_resume
      usb_resume_interface
      usb_resume_both
      usb_runtime_resume
      __rpm_callback
      rpm_callback
      rpm_resume
      __pm_runtime_resume
      usb_autoresume_device
      hub_event
      process_one_work
    
    Fixes: b4df480f68ae ("usbnet: smsc95xx: add reset_resume function with reset operation")
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Cc: stable@vger.kernel.org # v3.16+
    Cc: Andre Edich <andre.edich@microchip.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 0a3160f4ffc70ee4bfa1521f698dace06e6091fd
Author: Shawn Guo <shawn.guo@linaro.org>
Date:   Wed Oct 12 20:13:53 2022 +0800

    serial: imx: Add missing .thaw_noirq hook
    
    [ Upstream commit 4561d8008a467cb05ac632a215391d6b787f40aa ]
    
    The following warning is seen with non-console UART instance when
    system hibernates.
    
    [   37.371969] ------------[ cut here ]------------
    [   37.376599] uart3_root_clk already disabled
    [   37.380810] WARNING: CPU: 0 PID: 296 at drivers/clk/clk.c:952 clk_core_disable+0xa4/0xb0
    ...
    [   37.506986] Call trace:
    [   37.509432]  clk_core_disable+0xa4/0xb0
    [   37.513270]  clk_disable+0x34/0x50
    [   37.516672]  imx_uart_thaw+0x38/0x5c
    [   37.520250]  platform_pm_thaw+0x30/0x6c
    [   37.524089]  dpm_run_callback.constprop.0+0x3c/0xd4
    [   37.528972]  device_resume+0x7c/0x160
    [   37.532633]  dpm_resume+0xe8/0x230
    [   37.536036]  hibernation_snapshot+0x288/0x430
    [   37.540397]  hibernate+0x10c/0x2e0
    [   37.543798]  state_store+0xc4/0xd0
    [   37.547203]  kobj_attr_store+0x1c/0x30
    [   37.550953]  sysfs_kf_write+0x48/0x60
    [   37.554619]  kernfs_fop_write_iter+0x118/0x1ac
    [   37.559063]  new_sync_write+0xe8/0x184
    [   37.562812]  vfs_write+0x230/0x290
    [   37.566214]  ksys_write+0x68/0xf4
    [   37.569529]  __arm64_sys_write+0x20/0x2c
    [   37.573452]  invoke_syscall.constprop.0+0x50/0xf0
    [   37.578156]  do_el0_svc+0x11c/0x150
    [   37.581648]  el0_svc+0x30/0x140
    [   37.584792]  el0t_64_sync_handler+0xe8/0xf0
    [   37.588976]  el0t_64_sync+0x1a0/0x1a4
    [   37.592639] ---[ end trace 56e22eec54676d75 ]---
    
    On hibernating, pm core calls into related hooks in sequence like:
    
        .freeze
        .freeze_noirq
        .thaw_noirq
        .thaw
    
    With .thaw_noirq hook being absent, the clock will be disabled in a
    unbalanced call which results the warning above.
    
        imx_uart_freeze()
            clk_prepare_enable()
        imx_uart_suspend_noirq()
            clk_disable()
        imx_uart_thaw
            clk_disable_unprepare()
    
    Adding the missing .thaw_noirq hook as imx_uart_resume_noirq() will have
    the call sequence corrected as below and thus fix the warning.
    
        imx_uart_freeze()
            clk_prepare_enable()
        imx_uart_suspend_noirq()
            clk_disable()
        imx_uart_resume_noirq()
            clk_enable()
        imx_uart_thaw
            clk_disable_unprepare()
    
    Fixes: 09df0b3464e5 ("serial: imx: fix endless loop during suspend")
    Reviewed-by: Martin Kaiser <martin@kaiser.cx>
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>
    Link: https://lore.kernel.org/r/20221012121353.2346280-1-shawn.guo@linaro.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 476b09e07bd519ec7ba5941a6a6f9a02256dbb21
Author: Shawn Guo <shawn.guo@linaro.org>
Date:   Wed Oct 12 20:13:53 2022 +0800

    serial: imx: Add missing .thaw_noirq hook
    
    [ Upstream commit 4561d8008a467cb05ac632a215391d6b787f40aa ]
    
    The following warning is seen with non-console UART instance when
    system hibernates.
    
    [   37.371969] ------------[ cut here ]------------
    [   37.376599] uart3_root_clk already disabled
    [   37.380810] WARNING: CPU: 0 PID: 296 at drivers/clk/clk.c:952 clk_core_disable+0xa4/0xb0
    ...
    [   37.506986] Call trace:
    [   37.509432]  clk_core_disable+0xa4/0xb0
    [   37.513270]  clk_disable+0x34/0x50
    [   37.516672]  imx_uart_thaw+0x38/0x5c
    [   37.520250]  platform_pm_thaw+0x30/0x6c
    [   37.524089]  dpm_run_callback.constprop.0+0x3c/0xd4
    [   37.528972]  device_resume+0x7c/0x160
    [   37.532633]  dpm_resume+0xe8/0x230
    [   37.536036]  hibernation_snapshot+0x288/0x430
    [   37.540397]  hibernate+0x10c/0x2e0
    [   37.543798]  state_store+0xc4/0xd0
    [   37.547203]  kobj_attr_store+0x1c/0x30
    [   37.550953]  sysfs_kf_write+0x48/0x60
    [   37.554619]  kernfs_fop_write_iter+0x118/0x1ac
    [   37.559063]  new_sync_write+0xe8/0x184
    [   37.562812]  vfs_write+0x230/0x290
    [   37.566214]  ksys_write+0x68/0xf4
    [   37.569529]  __arm64_sys_write+0x20/0x2c
    [   37.573452]  invoke_syscall.constprop.0+0x50/0xf0
    [   37.578156]  do_el0_svc+0x11c/0x150
    [   37.581648]  el0_svc+0x30/0x140
    [   37.584792]  el0t_64_sync_handler+0xe8/0xf0
    [   37.588976]  el0t_64_sync+0x1a0/0x1a4
    [   37.592639] ---[ end trace 56e22eec54676d75 ]---
    
    On hibernating, pm core calls into related hooks in sequence like:
    
        .freeze
        .freeze_noirq
        .thaw_noirq
        .thaw
    
    With .thaw_noirq hook being absent, the clock will be disabled in a
    unbalanced call which results the warning above.
    
        imx_uart_freeze()
            clk_prepare_enable()
        imx_uart_suspend_noirq()
            clk_disable()
        imx_uart_thaw
            clk_disable_unprepare()
    
    Adding the missing .thaw_noirq hook as imx_uart_resume_noirq() will have
    the call sequence corrected as below and thus fix the warning.
    
        imx_uart_freeze()
            clk_prepare_enable()
        imx_uart_suspend_noirq()
            clk_disable()
        imx_uart_resume_noirq()
            clk_enable()
        imx_uart_thaw
            clk_disable_unprepare()
    
    Fixes: 09df0b3464e5 ("serial: imx: fix endless loop during suspend")
    Reviewed-by: Martin Kaiser <martin@kaiser.cx>
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>
    Link: https://lore.kernel.org/r/20221012121353.2346280-1-shawn.guo@linaro.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit e401312ca6e180ee1bd65f6a766e99dd40aa95e7
Author: Shawn Guo <shawn.guo@linaro.org>
Date:   Wed Oct 12 20:13:53 2022 +0800

    serial: imx: Add missing .thaw_noirq hook
    
    [ Upstream commit 4561d8008a467cb05ac632a215391d6b787f40aa ]
    
    The following warning is seen with non-console UART instance when
    system hibernates.
    
    [   37.371969] ------------[ cut here ]------------
    [   37.376599] uart3_root_clk already disabled
    [   37.380810] WARNING: CPU: 0 PID: 296 at drivers/clk/clk.c:952 clk_core_disable+0xa4/0xb0
    ...
    [   37.506986] Call trace:
    [   37.509432]  clk_core_disable+0xa4/0xb0
    [   37.513270]  clk_disable+0x34/0x50
    [   37.516672]  imx_uart_thaw+0x38/0x5c
    [   37.520250]  platform_pm_thaw+0x30/0x6c
    [   37.524089]  dpm_run_callback.constprop.0+0x3c/0xd4
    [   37.528972]  device_resume+0x7c/0x160
    [   37.532633]  dpm_resume+0xe8/0x230
    [   37.536036]  hibernation_snapshot+0x288/0x430
    [   37.540397]  hibernate+0x10c/0x2e0
    [   37.543798]  state_store+0xc4/0xd0
    [   37.547203]  kobj_attr_store+0x1c/0x30
    [   37.550953]  sysfs_kf_write+0x48/0x60
    [   37.554619]  kernfs_fop_write_iter+0x118/0x1ac
    [   37.559063]  new_sync_write+0xe8/0x184
    [   37.562812]  vfs_write+0x230/0x290
    [   37.566214]  ksys_write+0x68/0xf4
    [   37.569529]  __arm64_sys_write+0x20/0x2c
    [   37.573452]  invoke_syscall.constprop.0+0x50/0xf0
    [   37.578156]  do_el0_svc+0x11c/0x150
    [   37.581648]  el0_svc+0x30/0x140
    [   37.584792]  el0t_64_sync_handler+0xe8/0xf0
    [   37.588976]  el0t_64_sync+0x1a0/0x1a4
    [   37.592639] ---[ end trace 56e22eec54676d75 ]---
    
    On hibernating, pm core calls into related hooks in sequence like:
    
        .freeze
        .freeze_noirq
        .thaw_noirq
        .thaw
    
    With .thaw_noirq hook being absent, the clock will be disabled in a
    unbalanced call which results the warning above.
    
        imx_uart_freeze()
            clk_prepare_enable()
        imx_uart_suspend_noirq()
            clk_disable()
        imx_uart_thaw
            clk_disable_unprepare()
    
    Adding the missing .thaw_noirq hook as imx_uart_resume_noirq() will have
    the call sequence corrected as below and thus fix the warning.
    
        imx_uart_freeze()
            clk_prepare_enable()
        imx_uart_suspend_noirq()
            clk_disable()
        imx_uart_resume_noirq()
            clk_enable()
        imx_uart_thaw
            clk_disable_unprepare()
    
    Fixes: 09df0b3464e5 ("serial: imx: fix endless loop during suspend")
    Reviewed-by: Martin Kaiser <martin@kaiser.cx>
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>
    Link: https://lore.kernel.org/r/20221012121353.2346280-1-shawn.guo@linaro.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 9de255c461d1b3f0242b3ad1450c3323a3e00b34
Author: Rafael Mendonca <rafaelmendsr@gmail.com>
Date:   Fri Sep 30 19:40:57 2022 -0300

    uio: uio_dmem_genirq: Fix missing unlock in irq configuration
    
    Commit b74351287d4b ("uio: fix a sleep-in-atomic-context bug in
    uio_dmem_genirq_irqcontrol()") started calling disable_irq() without
    holding the spinlock because it can sleep. However, that fix introduced
    another bug: if interrupt is already disabled and a new disable request
    comes in, then the spinlock is not unlocked:
    
    root@localhost:~# printf '\x00\x00\x00\x00' > /dev/uio0
    root@localhost:~# printf '\x00\x00\x00\x00' > /dev/uio0
    root@localhost:~# [   14.851538] BUG: scheduling while atomic: bash/223/0x00000002
    [   14.851991] Modules linked in: uio_dmem_genirq uio myfpga(OE) bochs drm_vram_helper drm_ttm_helper ttm drm_kms_helper drm snd_pcm ppdev joydev psmouse snd_timer snd e1000fb_sys_fops syscopyarea parport sysfillrect soundcore sysimgblt input_leds pcspkr i2c_piix4 serio_raw floppy evbug qemu_fw_cfg mac_hid pata_acpi ip_tables x_tables autofs4 [last unloaded: parport_pc]
    [   14.854206] CPU: 0 PID: 223 Comm: bash Tainted: G           OE      6.0.0-rc7 #21
    [   14.854786] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.0-0-gd239552ce722-prebuilt.qemu.org 04/01/2014
    [   14.855664] Call Trace:
    [   14.855861]  <TASK>
    [   14.856025]  dump_stack_lvl+0x4d/0x67
    [   14.856325]  dump_stack+0x14/0x1a
    [   14.856583]  __schedule_bug.cold+0x4b/0x5c
    [   14.856915]  __schedule+0xe81/0x13d0
    [   14.857199]  ? idr_find+0x13/0x20
    [   14.857456]  ? get_work_pool+0x2d/0x50
    [   14.857756]  ? __flush_work+0x233/0x280
    [   14.858068]  ? __schedule+0xa95/0x13d0
    [   14.858307]  ? idr_find+0x13/0x20
    [   14.858519]  ? get_work_pool+0x2d/0x50
    [   14.858798]  schedule+0x6c/0x100
    [   14.859009]  schedule_hrtimeout_range_clock+0xff/0x110
    [   14.859335]  ? tty_write_room+0x1f/0x30
    [   14.859598]  ? n_tty_poll+0x1ec/0x220
    [   14.859830]  ? tty_ldisc_deref+0x1a/0x20
    [   14.860090]  schedule_hrtimeout_range+0x17/0x20
    [   14.860373]  do_select+0x596/0x840
    [   14.860627]  ? __kernel_text_address+0x16/0x50
    [   14.860954]  ? poll_freewait+0xb0/0xb0
    [   14.861235]  ? poll_freewait+0xb0/0xb0
    [   14.861517]  ? rpm_resume+0x49d/0x780
    [   14.861798]  ? common_interrupt+0x59/0xa0
    [   14.862127]  ? asm_common_interrupt+0x2b/0x40
    [   14.862511]  ? __uart_start.isra.0+0x61/0x70
    [   14.862902]  ? __check_object_size+0x61/0x280
    [   14.863255]  core_sys_select+0x1c6/0x400
    [   14.863575]  ? vfs_write+0x1c9/0x3d0
    [   14.863853]  ? vfs_write+0x1c9/0x3d0
    [   14.864121]  ? _copy_from_user+0x45/0x70
    [   14.864526]  do_pselect.constprop.0+0xb3/0xf0
    [   14.864893]  ? do_syscall_64+0x6d/0x90
    [   14.865228]  ? do_syscall_64+0x6d/0x90
    [   14.865556]  __x64_sys_pselect6+0x76/0xa0
    [   14.865906]  do_syscall_64+0x60/0x90
    [   14.866214]  ? syscall_exit_to_user_mode+0x2a/0x50
    [   14.866640]  ? do_syscall_64+0x6d/0x90
    [   14.866972]  ? do_syscall_64+0x6d/0x90
    [   14.867286]  ? do_syscall_64+0x6d/0x90
    [   14.867626]  entry_SYSCALL_64_after_hwframe+0x63/0xcd
    [...] stripped
    [   14.872959]  </TASK>
    
    ('myfpga' is a simple 'uio_dmem_genirq' driver I wrote to test this)
    
    The implementation of "uio_dmem_genirq" was based on "uio_pdrv_genirq" and
    it is used in a similar manner to the "uio_pdrv_genirq" driver with respect
    to interrupt configuration and handling. At the time "uio_dmem_genirq" was
    introduced, both had the same implementation of the 'uio_info' handlers
    irqcontrol() and handler(). Then commit 34cb27528398 ("UIO: Fix concurrency
    issue"), which was only applied to "uio_pdrv_genirq", ended up making them
    a little different. That commit, among other things, changed disable_irq()
    to disable_irq_nosync() in the implementation of irqcontrol(). The
    motivation there was to avoid a deadlock between irqcontrol() and
    handler(), since it added a spinlock in the irq handler, and disable_irq()
    waits for the completion of the irq handler.
    
    By changing disable_irq() to disable_irq_nosync() in irqcontrol(), we also
    avoid the sleeping-while-atomic bug that commit b74351287d4b ("uio: fix a
    sleep-in-atomic-context bug in uio_dmem_genirq_irqcontrol()") was trying to
    fix. Thus, this fixes the missing unlock in irqcontrol() by importing the
    implementation of irqcontrol() handler from the "uio_pdrv_genirq" driver.
    In the end, it reverts commit b74351287d4b ("uio: fix a
    sleep-in-atomic-context bug in uio_dmem_genirq_irqcontrol()") and change
    disable_irq() to disable_irq_nosync().
    
    It is worth noting that this still does not address the concurrency issue
    fixed by commit 34cb27528398 ("UIO: Fix concurrency issue"). It will be
    addressed separately in the next commits.
    
    Split out from commit 34cb27528398 ("UIO: Fix concurrency issue").
    
    Fixes: b74351287d4b ("uio: fix a sleep-in-atomic-context bug in uio_dmem_genirq_irqcontrol()")
    Signed-off-by: Rafael Mendonca <rafaelmendsr@gmail.com>
    Link: https://lore.kernel.org/r/20220930224100.816175-2-rafaelmendsr@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 4561d8008a467cb05ac632a215391d6b787f40aa
Author: Shawn Guo <shawn.guo@linaro.org>
Date:   Wed Oct 12 20:13:53 2022 +0800

    serial: imx: Add missing .thaw_noirq hook
    
    The following warning is seen with non-console UART instance when
    system hibernates.
    
    [   37.371969] ------------[ cut here ]------------
    [   37.376599] uart3_root_clk already disabled
    [   37.380810] WARNING: CPU: 0 PID: 296 at drivers/clk/clk.c:952 clk_core_disable+0xa4/0xb0
    ...
    [   37.506986] Call trace:
    [   37.509432]  clk_core_disable+0xa4/0xb0
    [   37.513270]  clk_disable+0x34/0x50
    [   37.516672]  imx_uart_thaw+0x38/0x5c
    [   37.520250]  platform_pm_thaw+0x30/0x6c
    [   37.524089]  dpm_run_callback.constprop.0+0x3c/0xd4
    [   37.528972]  device_resume+0x7c/0x160
    [   37.532633]  dpm_resume+0xe8/0x230
    [   37.536036]  hibernation_snapshot+0x288/0x430
    [   37.540397]  hibernate+0x10c/0x2e0
    [   37.543798]  state_store+0xc4/0xd0
    [   37.547203]  kobj_attr_store+0x1c/0x30
    [   37.550953]  sysfs_kf_write+0x48/0x60
    [   37.554619]  kernfs_fop_write_iter+0x118/0x1ac
    [   37.559063]  new_sync_write+0xe8/0x184
    [   37.562812]  vfs_write+0x230/0x290
    [   37.566214]  ksys_write+0x68/0xf4
    [   37.569529]  __arm64_sys_write+0x20/0x2c
    [   37.573452]  invoke_syscall.constprop.0+0x50/0xf0
    [   37.578156]  do_el0_svc+0x11c/0x150
    [   37.581648]  el0_svc+0x30/0x140
    [   37.584792]  el0t_64_sync_handler+0xe8/0xf0
    [   37.588976]  el0t_64_sync+0x1a0/0x1a4
    [   37.592639] ---[ end trace 56e22eec54676d75 ]---
    
    On hibernating, pm core calls into related hooks in sequence like:
    
        .freeze
        .freeze_noirq
        .thaw_noirq
        .thaw
    
    With .thaw_noirq hook being absent, the clock will be disabled in a
    unbalanced call which results the warning above.
    
        imx_uart_freeze()
            clk_prepare_enable()
        imx_uart_suspend_noirq()
            clk_disable()
        imx_uart_thaw
            clk_disable_unprepare()
    
    Adding the missing .thaw_noirq hook as imx_uart_resume_noirq() will have
    the call sequence corrected as below and thus fix the warning.
    
        imx_uart_freeze()
            clk_prepare_enable()
        imx_uart_suspend_noirq()
            clk_disable()
        imx_uart_resume_noirq()
            clk_enable()
        imx_uart_thaw
            clk_disable_unprepare()
    
    Fixes: 09df0b3464e5 ("serial: imx: fix endless loop during suspend")
    Reviewed-by: Martin Kaiser <martin@kaiser.cx>
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>
    Link: https://lore.kernel.org/r/20221012121353.2346280-1-shawn.guo@linaro.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 8d4de331f1b24a22d18e3c6116aa25228cf54854
Author: Mario Limonciello <mario.limonciello@amd.com>
Date:   Wed Oct 26 14:03:55 2022 -0500

    drm/amd: Fail the suspend if resources can't be evicted
    
    If a system does not have swap and memory is under 100% usage,
    amdgpu will fail to evict resources.  Currently the suspend
    carries on proceeding to reset the GPU:
    
    ```
    [drm] evicting device resources failed
    [drm:amdgpu_device_ip_suspend_phase2 [amdgpu]] *ERROR* suspend of IP block <vcn_v3_0> failed -12
    [drm] free PSP TMR buffer
    [TTM] Failed allocating page table
    [drm] evicting device resources failed
    amdgpu 0000:03:00.0: amdgpu: MODE1 reset
    amdgpu 0000:03:00.0: amdgpu: GPU mode1 reset
    amdgpu 0000:03:00.0: amdgpu: GPU smu mode1 reset
    ```
    
    At this point if the suspend actually succeeded I think that amdgpu
    would have recovered because the GPU would have power cut off and
    restored.  However the kernel fails to continue the suspend from the
    memory pressure and amdgpu fails to run the "resume" from the aborted
    suspend.
    
    ```
    ACPI: PM: Preparing to enter system sleep state S3
    SLUB: Unable to allocate memory on node -1, gfp=0xdc0(GFP_KERNEL|__GFP_ZERO)
      cache: Acpi-State, object size: 80, buffer size: 80, default order: 0, min order: 0
      node 0: slabs: 22, objs: 1122, free: 0
    ACPI Error: AE_NO_MEMORY, Could not update object reference count (20210730/utdelete-651)
    
    [drm:psp_hw_start [amdgpu]] *ERROR* PSP load kdb failed!
    [drm:psp_resume [amdgpu]] *ERROR* PSP resume failed
    [drm:amdgpu_device_fw_loading [amdgpu]] *ERROR* resume of IP block <psp> failed -62
    amdgpu 0000:03:00.0: amdgpu: amdgpu_device_ip_resume failed (-62).
    PM: dpm_run_callback(): pci_pm_resume+0x0/0x100 returns -62
    amdgpu 0000:03:00.0: PM: failed to resume async: error -62
    ```
    
    To avoid this series of unfortunate events, fail amdgpu's suspend
    when the memory eviction fails.  This will let the system gracefully
    recover and the user can try suspend again when the memory pressure
    is relieved.
    
    Reported-by: post@davidak.de
    Link: https://gitlab.freedesktop.org/drm/amd/-/issues/2223
    Signed-off-by: Mario Limonciello <mario.limonciello@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Acked-by: Christian Knig <christian.koenig@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

commit 7863c1552632223967f561654422cd2016c2520c
Author: Mario Limonciello <mario.limonciello@amd.com>
Date:   Wed Oct 26 14:03:55 2022 -0500

    drm/amd: Fail the suspend if resources can't be evicted
    
    If a system does not have swap and memory is under 100% usage,
    amdgpu will fail to evict resources.  Currently the suspend
    carries on proceeding to reset the GPU:
    
    ```
    [drm] evicting device resources failed
    [drm:amdgpu_device_ip_suspend_phase2 [amdgpu]] *ERROR* suspend of IP block <vcn_v3_0> failed -12
    [drm] free PSP TMR buffer
    [TTM] Failed allocating page table
    [drm] evicting device resources failed
    amdgpu 0000:03:00.0: amdgpu: MODE1 reset
    amdgpu 0000:03:00.0: amdgpu: GPU mode1 reset
    amdgpu 0000:03:00.0: amdgpu: GPU smu mode1 reset
    ```
    
    At this point if the suspend actually succeeded I think that amdgpu
    would have recovered because the GPU would have power cut off and
    restored.  However the kernel fails to continue the suspend from the
    memory pressure and amdgpu fails to run the "resume" from the aborted
    suspend.
    
    ```
    ACPI: PM: Preparing to enter system sleep state S3
    SLUB: Unable to allocate memory on node -1, gfp=0xdc0(GFP_KERNEL|__GFP_ZERO)
      cache: Acpi-State, object size: 80, buffer size: 80, default order: 0, min order: 0
      node 0: slabs: 22, objs: 1122, free: 0
    ACPI Error: AE_NO_MEMORY, Could not update object reference count (20210730/utdelete-651)
    
    [drm:psp_hw_start [amdgpu]] *ERROR* PSP load kdb failed!
    [drm:psp_resume [amdgpu]] *ERROR* PSP resume failed
    [drm:amdgpu_device_fw_loading [amdgpu]] *ERROR* resume of IP block <psp> failed -62
    amdgpu 0000:03:00.0: amdgpu: amdgpu_device_ip_resume failed (-62).
    PM: dpm_run_callback(): pci_pm_resume+0x0/0x100 returns -62
    amdgpu 0000:03:00.0: PM: failed to resume async: error -62
    ```
    
    To avoid this series of unfortunate events, fail amdgpu's suspend
    when the memory eviction fails.  This will let the system gracefully
    recover and the user can try suspend again when the memory pressure
    is relieved.
    
    Reported-by: post@davidak.de
    Link: https://gitlab.freedesktop.org/drm/amd/-/issues/2223
    Signed-off-by: Mario Limonciello <mario.limonciello@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Acked-by: Christian Knig <christian.koenig@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

commit 11a8d8774e68e07385a5b10d9546598f57ace7da
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Tue Oct 25 15:38:49 2022 -0500

    agp/nvidia: Convert to generic power management
    
    Convert agpgart-nvidia from legacy PCI power management to the generic
    power management framework.
    
    Previously agpgart-nvidia used legacy PCI power management, and
    agp_nvidia_suspend() and agp_nvidia_resume() were responsible for both
    device-specific things and generic PCI things:
    
      agp_nvidia_suspend
        pci_save_state                         <-- generic PCI
        pci_set_power_state(PCI_D3hot)         <-- generic PCI
    
      agp_nvidia_resume
        pci_set_power_state(PCI_D0)            <-- generic PCI
        pci_restore_state                      <-- generic PCI
        nvidia_configure                       <-- device-specific
    
    Convert to generic power management where the PCI bus PM methods do the
    generic PCI things, and the driver needs only the device-specific part,
    i.e.,
    
      suspend_devices_and_enter
        dpm_suspend_start(PMSG_SUSPEND)
          pci_pm_suspend                       # PCI bus .suspend() method
            agp_nvidia_suspend                 <-- not needed at all; removed
        suspend_enter
          dpm_suspend_noirq(PMSG_SUSPEND)
            pci_pm_suspend_noirq               # PCI bus .suspend_noirq() method
              pci_save_state                   <-- generic PCI
              pci_prepare_to_sleep             <-- generic PCI
                pci_set_power_state
        ...
        dpm_resume_end(PMSG_RESUME)
          pci_pm_resume                        # PCI bus .resume() method
            pci_restore_standard_config
              pci_set_power_state(PCI_D0)      <-- generic PCI
              pci_restore_state                <-- generic PCI
            agp_nvidia_resume                  # driver->pm->resume
              nvidia_configure                 <-- device-specific
    
    Based on 0aeddbd0cb07 ("via-agp: convert to generic power management") by
    Vaibhav Gupta <vaibhavgupta40@gmail.com>.
    
    Link: https://lore.kernel.org/r/20221025203852.681822-6-helgaas@kernel.org
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Dave Airlie <airlied@redhat.com>

commit 6a1274ea0e5dfb2eca85b0175820d7b5183c9cae
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Tue Oct 25 15:38:48 2022 -0500

    agp/ati: Convert to generic power management
    
    Convert agpgart-ati from legacy PCI power management to the generic power
    management framework.
    
    Previously agpgart-ati used legacy PCI power management, and
    agp_ati_suspend() and agp_ati_resume() were responsible for both
    device-specific things and generic PCI things like saving and restoring
    config space and managing power state:
    
      agp_ati_suspend
        pci_save_state                         <-- generic PCI
        pci_set_power_state(PCI_D3hot)         <-- generic PCI
    
      agp_ati_resume
        pci_set_power_state(PCI_D0)            <-- generic PCI
        pci_restore_state                      <-- generic PCI
        ati_configure                          <-- device-specific
    
    With generic power management, the PCI bus PM methods do the generic PCI
    things, and the driver needs only the device-specific part, i.e.,
    
      suspend_devices_and_enter
        dpm_suspend_start(PMSG_SUSPEND)
          pci_pm_suspend                       # PCI bus .suspend() method
            agp_ati_suspend                    <-- not needed at all; removed
        suspend_enter
          dpm_suspend_noirq(PMSG_SUSPEND)
            pci_pm_suspend_noirq               # PCI bus .suspend_noirq() method
              pci_save_state                   <-- generic PCI
              pci_prepare_to_sleep             <-- generic PCI
                pci_set_power_state
        ...
        dpm_resume_end(PMSG_RESUME)
          pci_pm_resume                        # PCI bus .resume() method
            pci_restore_standard_config
              pci_set_power_state(PCI_D0)      <-- generic PCI
              pci_restore_state                <-- generic PCI
            agp_ati_resume                     # driver->pm->resume
              ati_configure                    <-- device-specific
    
    Based on 0aeddbd0cb07 ("via-agp: convert to generic power management") by
    Vaibhav Gupta <vaibhavgupta40@gmail.com>.
    
    Link: https://lore.kernel.org/r/20221025203852.681822-5-helgaas@kernel.org
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Dave Airlie <airlied@redhat.com>

commit c78679d1fe43f9165b11c5ccd3f79c7108b066fe
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Tue Oct 25 15:38:47 2022 -0500

    agp/amd-k7: Convert to generic power management
    
    Convert agpgart-amdk7 from legacy PCI power management to the generic power
    management framework.
    
    Previously agpgart-amdk7 used legacy PCI power management, and
    agp_amdk7_suspend() and agp_amdk7_resume() were responsible for both
    device-specific things and generic PCI things like saving and restoring
    config space and managing power state:
    
      agp_amdk7_suspend
        pci_save_state                         <-- generic PCI
        pci_set_power_state                    <-- generic PCI
    
      agp_amdk7_resume
        pci_set_power_state(PCI_D0)            <-- generic PCI
        pci_restore_state                      <-- generic PCI
        amd_irongate_driver.configure          <-- device-specific
    
    Convert to generic power management where the PCI bus PM methods do the
    generic PCI things, and the driver needs only the device-specific part,
    i.e.,
    
      suspend_devices_and_enter
        dpm_suspend_start(PMSG_SUSPEND)
          pci_pm_suspend                       # PCI bus .suspend() method
            agp_amdk7_suspend                  <-- not needed at all; removed
        suspend_enter
          dpm_suspend_noirq(PMSG_SUSPEND)
            pci_pm_suspend_noirq               # PCI bus .suspend_noirq() method
              pci_save_state                   <-- generic PCI
              pci_prepare_to_sleep             <-- generic PCI
                pci_set_power_state
        ...
        dpm_resume_end(PMSG_RESUME)
          pci_pm_resume                        # PCI bus .resume() method
            pci_restore_standard_config
              pci_set_power_state(PCI_D0)      <-- generic PCI
              pci_restore_state                <-- generic PCI
            agp_amdk7_resume                   # driver->pm->resume
              amd_irongate_driver.configure    <-- device-specific
    
    Based on 0aeddbd0cb07 ("via-agp: convert to generic power management") by
    Vaibhav Gupta <vaibhavgupta40@gmail.com>.
    
    Link: https://lore.kernel.org/r/20221025203852.681822-4-helgaas@kernel.org
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Dave Airlie <airlied@redhat.com>

commit 1e911790576fec000a185b64a2810376d03eec4d
Author: Xu Qiang <xuqiang36@huawei.com>
Date:   Thu Aug 25 06:53:24 2022 +0000

    spi: qup: add missing clk_disable_unprepare on error in spi_qup_pm_resume_runtime()
    
    [ Upstream commit 494a22765ce479c9f8ad181c5d24cffda9f534bb ]
    
    Add the missing clk_disable_unprepare() before return
    from spi_qup_pm_resume_runtime() in the error handling case.
    
    Fixes: dae1a7700b34 (spi: qup: Handle clocks in pm_runtime suspend and resume)
    Signed-off-by: Xu Qiang <xuqiang36@huawei.com>
    Link: https://lore.kernel.org/r/20220825065324.68446-2-xuqiang36@huawei.com
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit df0b024ade10b0fec7d0a14261598ff322255c7b
Author: Xu Qiang <xuqiang36@huawei.com>
Date:   Thu Aug 25 06:53:24 2022 +0000

    spi: qup: add missing clk_disable_unprepare on error in spi_qup_pm_resume_runtime()
    
    [ Upstream commit 494a22765ce479c9f8ad181c5d24cffda9f534bb ]
    
    Add the missing clk_disable_unprepare() before return
    from spi_qup_pm_resume_runtime() in the error handling case.
    
    Fixes: dae1a7700b34 (spi: qup: Handle clocks in pm_runtime suspend and resume)
    Signed-off-by: Xu Qiang <xuqiang36@huawei.com>
    Link: https://lore.kernel.org/r/20220825065324.68446-2-xuqiang36@huawei.com
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit e0711e18d70faebb5e454970c5b22fbc66f69b27
Author: Xu Qiang <xuqiang36@huawei.com>
Date:   Thu Aug 25 06:53:24 2022 +0000

    spi: qup: add missing clk_disable_unprepare on error in spi_qup_pm_resume_runtime()
    
    [ Upstream commit 494a22765ce479c9f8ad181c5d24cffda9f534bb ]
    
    Add the missing clk_disable_unprepare() before return
    from spi_qup_pm_resume_runtime() in the error handling case.
    
    Fixes: dae1a7700b34 (spi: qup: Handle clocks in pm_runtime suspend and resume)
    Signed-off-by: Xu Qiang <xuqiang36@huawei.com>
    Link: https://lore.kernel.org/r/20220825065324.68446-2-xuqiang36@huawei.com
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 60a860d12dd3187eac56a49f9ab48c99d5c08152
Author: Letu Ren <fantasquex@gmail.com>
Date:   Fri Nov 12 20:06:41 2021 +0800

    scsi: qedf: Fix a UAF bug in __qedf_probe()
    
    [ Upstream commit fbfe96869b782364caebae0445763969ddb6ea67 ]
    
    In __qedf_probe(), if qedf->cdev is NULL which means
    qed_ops->common->probe() failed, then the program will goto label err1, and
    scsi_host_put() will free lport->host pointer. Because the memory qedf
    points to is allocated by libfc_host_alloc(), it will be freed by
    scsi_host_put(). However, the if statement below label err0 only checks
    whether qedf is NULL but doesn't check whether the memory has been freed.
    So a UAF bug can occur.
    
    There are two ways to reach the statements below err0. The first one is
    described as before, "qedf" should be set to NULL. The second one is goto
    "err0" directly. In the latter scenario qedf hasn't been changed and it has
    the initial value NULL. As a result the if statement is not reachable in
    any situation.
    
    The KASAN logs are as follows:
    
    [    2.312969] BUG: KASAN: use-after-free in __qedf_probe+0x5dcf/0x6bc0
    [    2.312969]
    [    2.312969] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.12.0-59-gc9ba5276e321-prebuilt.qemu.org 04/01/2014
    [    2.312969] Call Trace:
    [    2.312969]  dump_stack_lvl+0x59/0x7b
    [    2.312969]  print_address_description+0x7c/0x3b0
    [    2.312969]  ? __qedf_probe+0x5dcf/0x6bc0
    [    2.312969]  __kasan_report+0x160/0x1c0
    [    2.312969]  ? __qedf_probe+0x5dcf/0x6bc0
    [    2.312969]  kasan_report+0x4b/0x70
    [    2.312969]  ? kobject_put+0x25d/0x290
    [    2.312969]  kasan_check_range+0x2ca/0x310
    [    2.312969]  __qedf_probe+0x5dcf/0x6bc0
    [    2.312969]  ? selinux_kernfs_init_security+0xdc/0x5f0
    [    2.312969]  ? trace_rpm_return_int_rcuidle+0x18/0x120
    [    2.312969]  ? rpm_resume+0xa5c/0x16e0
    [    2.312969]  ? qedf_get_generic_tlv_data+0x160/0x160
    [    2.312969]  local_pci_probe+0x13c/0x1f0
    [    2.312969]  pci_device_probe+0x37e/0x6c0
    
    Link: https://lore.kernel.org/r/20211112120641.16073-1-fantasquex@gmail.com
    Reported-by: Zheyu Ma <zheyuma97@gmail.com>
    Acked-by: Saurav Kashyap <skashyap@marvell.com>
    Co-developed-by: Wende Tan <twd2.me@gmail.com>
    Signed-off-by: Wende Tan <twd2.me@gmail.com>
    Signed-off-by: Letu Ren <fantasquex@gmail.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 9a863b7e611a5ab0cefa9845d4be922cc2bddf94
Author: Xu Qiang <xuqiang36@huawei.com>
Date:   Thu Aug 25 06:53:24 2022 +0000

    spi: qup: add missing clk_disable_unprepare on error in spi_qup_pm_resume_runtime()
    
    [ Upstream commit 494a22765ce479c9f8ad181c5d24cffda9f534bb ]
    
    Add the missing clk_disable_unprepare() before return
    from spi_qup_pm_resume_runtime() in the error handling case.
    
    Fixes: dae1a7700b34 (spi: qup: Handle clocks in pm_runtime suspend and resume)
    Signed-off-by: Xu Qiang <xuqiang36@huawei.com>
    Link: https://lore.kernel.org/r/20220825065324.68446-2-xuqiang36@huawei.com
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit beb236b2391609867b57015b9bc92dcd7f21df1e
Author: Xu Qiang <xuqiang36@huawei.com>
Date:   Thu Aug 25 06:53:24 2022 +0000

    spi: qup: add missing clk_disable_unprepare on error in spi_qup_pm_resume_runtime()
    
    [ Upstream commit 494a22765ce479c9f8ad181c5d24cffda9f534bb ]
    
    Add the missing clk_disable_unprepare() before return
    from spi_qup_pm_resume_runtime() in the error handling case.
    
    Fixes: dae1a7700b34 (spi: qup: Handle clocks in pm_runtime suspend and resume)
    Signed-off-by: Xu Qiang <xuqiang36@huawei.com>
    Link: https://lore.kernel.org/r/20220825065324.68446-2-xuqiang36@huawei.com
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit fefd2269e681157afa75c0324fc7d6106d6a932d
Author: Xu Qiang <xuqiang36@huawei.com>
Date:   Thu Aug 25 06:53:24 2022 +0000

    spi: qup: add missing clk_disable_unprepare on error in spi_qup_pm_resume_runtime()
    
    [ Upstream commit 494a22765ce479c9f8ad181c5d24cffda9f534bb ]
    
    Add the missing clk_disable_unprepare() before return
    from spi_qup_pm_resume_runtime() in the error handling case.
    
    Fixes: dae1a7700b34 (spi: qup: Handle clocks in pm_runtime suspend and resume)
    Signed-off-by: Xu Qiang <xuqiang36@huawei.com>
    Link: https://lore.kernel.org/r/20220825065324.68446-2-xuqiang36@huawei.com
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 7fa5304c4b5b425d4a0b3acf10139a7f6108a85f
Author: Jarkko Nikula <jarkko.nikula@linux.intel.com>
Date:   Tue Sep 27 16:56:44 2022 +0300

    i2c: designware: Fix handling of real but unexpected device interrupts
    
    commit 301c8f5c32c8fb79c67539bc23972dc3ef48024c upstream.
    
    Commit c7b79a752871 ("mfd: intel-lpss: Add Intel Alder Lake PCH-S PCI
    IDs") caused a regression on certain Gigabyte motherboards for Intel
    Alder Lake-S where system crashes to NULL pointer dereference in
    i2c_dw_xfer_msg() when system resumes from S3 sleep state ("deep").
    
    I was able to debug the issue on Gigabyte Z690 AORUS ELITE and made
    following notes:
    
    - Issue happens when resuming from S3 but not when resuming from
      "s2idle"
    - PCI device 00:15.0 == i2c_designware.0 is already in D0 state when
      system enters into pci_pm_resume_noirq() while all other i2c_designware
      PCI devices are in D3. Devices were runtime suspended and in D3 prior
      entering into suspend
    - Interrupt comes after pci_pm_resume_noirq() when device interrupts are
      re-enabled
    - According to register dump the interrupt really comes from the
      i2c_designware.0. Controller is enabled, I2C target address register
      points to a one detectable I2C device address 0x60 and the
      DW_IC_RAW_INTR_STAT register START_DET, STOP_DET, ACTIVITY and
      TX_EMPTY bits are set indicating completed I2C transaction.
    
    My guess is that the firmware uses this controller to communicate with
    an on-board I2C device during resume but does not disable the controller
    before giving control to an operating system.
    
    I was told the UEFI update fixes this but never the less it revealed the
    driver is not ready to handle TX_EMPTY (or RX_FULL) interrupt when device
    is supposed to be idle and state variables are not set (especially the
    dev->msgs pointer which may point to NULL or stale old data).
    
    Introduce a new software status flag STATUS_ACTIVE indicating when the
    controller is active in driver point of view. Now treat all interrupts
    that occur when is not set as unexpected and mask all interrupts from
    the controller.
    
    Fixes: c7b79a752871 ("mfd: intel-lpss: Add Intel Alder Lake PCH-S PCI IDs")
    Reported-by: Samuel Clark <slc2015@gmail.com>
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=215907
    Cc: stable@vger.kernel.org # v5.12+
    Signed-off-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Wolfram Sang <wsa@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 4bf42b30a98e6dc9562565a8679d025a4f9a2dc0
Author: Xu Qiang <xuqiang36@huawei.com>
Date:   Thu Aug 25 06:53:24 2022 +0000

    spi: qup: add missing clk_disable_unprepare on error in spi_qup_pm_resume_runtime()
    
    [ Upstream commit 494a22765ce479c9f8ad181c5d24cffda9f534bb ]
    
    Add the missing clk_disable_unprepare() before return
    from spi_qup_pm_resume_runtime() in the error handling case.
    
    Fixes: dae1a7700b34 (spi: qup: Handle clocks in pm_runtime suspend and resume)
    Signed-off-by: Xu Qiang <xuqiang36@huawei.com>
    Link: https://lore.kernel.org/r/20220825065324.68446-2-xuqiang36@huawei.com
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit a206f7fbe9589c60fafad12884628c909ecb042f
Author: Jarkko Nikula <jarkko.nikula@linux.intel.com>
Date:   Tue Sep 27 16:56:44 2022 +0300

    i2c: designware: Fix handling of real but unexpected device interrupts
    
    commit 301c8f5c32c8fb79c67539bc23972dc3ef48024c upstream.
    
    Commit c7b79a752871 ("mfd: intel-lpss: Add Intel Alder Lake PCH-S PCI
    IDs") caused a regression on certain Gigabyte motherboards for Intel
    Alder Lake-S where system crashes to NULL pointer dereference in
    i2c_dw_xfer_msg() when system resumes from S3 sleep state ("deep").
    
    I was able to debug the issue on Gigabyte Z690 AORUS ELITE and made
    following notes:
    
    - Issue happens when resuming from S3 but not when resuming from
      "s2idle"
    - PCI device 00:15.0 == i2c_designware.0 is already in D0 state when
      system enters into pci_pm_resume_noirq() while all other i2c_designware
      PCI devices are in D3. Devices were runtime suspended and in D3 prior
      entering into suspend
    - Interrupt comes after pci_pm_resume_noirq() when device interrupts are
      re-enabled
    - According to register dump the interrupt really comes from the
      i2c_designware.0. Controller is enabled, I2C target address register
      points to a one detectable I2C device address 0x60 and the
      DW_IC_RAW_INTR_STAT register START_DET, STOP_DET, ACTIVITY and
      TX_EMPTY bits are set indicating completed I2C transaction.
    
    My guess is that the firmware uses this controller to communicate with
    an on-board I2C device during resume but does not disable the controller
    before giving control to an operating system.
    
    I was told the UEFI update fixes this but never the less it revealed the
    driver is not ready to handle TX_EMPTY (or RX_FULL) interrupt when device
    is supposed to be idle and state variables are not set (especially the
    dev->msgs pointer which may point to NULL or stale old data).
    
    Introduce a new software status flag STATUS_ACTIVE indicating when the
    controller is active in driver point of view. Now treat all interrupts
    that occur when is not set as unexpected and mask all interrupts from
    the controller.
    
    Fixes: c7b79a752871 ("mfd: intel-lpss: Add Intel Alder Lake PCH-S PCI IDs")
    Reported-by: Samuel Clark <slc2015@gmail.com>
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=215907
    Cc: stable@vger.kernel.org # v5.12+
    Signed-off-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Wolfram Sang <wsa@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 775139095bba1dff667c0483bde632ad3d0a47c9
Author: Xu Qiang <xuqiang36@huawei.com>
Date:   Thu Aug 25 06:53:24 2022 +0000

    spi: qup: add missing clk_disable_unprepare on error in spi_qup_pm_resume_runtime()
    
    [ Upstream commit 494a22765ce479c9f8ad181c5d24cffda9f534bb ]
    
    Add the missing clk_disable_unprepare() before return
    from spi_qup_pm_resume_runtime() in the error handling case.
    
    Fixes: dae1a7700b34 (spi: qup: Handle clocks in pm_runtime suspend and resume)
    Signed-off-by: Xu Qiang <xuqiang36@huawei.com>
    Link: https://lore.kernel.org/r/20220825065324.68446-2-xuqiang36@huawei.com
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit aa59ac81e859006d3a1df035a19b3f2089110f93
Author: Jarkko Nikula <jarkko.nikula@linux.intel.com>
Date:   Tue Sep 27 16:56:44 2022 +0300

    i2c: designware: Fix handling of real but unexpected device interrupts
    
    commit 301c8f5c32c8fb79c67539bc23972dc3ef48024c upstream.
    
    Commit c7b79a752871 ("mfd: intel-lpss: Add Intel Alder Lake PCH-S PCI
    IDs") caused a regression on certain Gigabyte motherboards for Intel
    Alder Lake-S where system crashes to NULL pointer dereference in
    i2c_dw_xfer_msg() when system resumes from S3 sleep state ("deep").
    
    I was able to debug the issue on Gigabyte Z690 AORUS ELITE and made
    following notes:
    
    - Issue happens when resuming from S3 but not when resuming from
      "s2idle"
    - PCI device 00:15.0 == i2c_designware.0 is already in D0 state when
      system enters into pci_pm_resume_noirq() while all other i2c_designware
      PCI devices are in D3. Devices were runtime suspended and in D3 prior
      entering into suspend
    - Interrupt comes after pci_pm_resume_noirq() when device interrupts are
      re-enabled
    - According to register dump the interrupt really comes from the
      i2c_designware.0. Controller is enabled, I2C target address register
      points to a one detectable I2C device address 0x60 and the
      DW_IC_RAW_INTR_STAT register START_DET, STOP_DET, ACTIVITY and
      TX_EMPTY bits are set indicating completed I2C transaction.
    
    My guess is that the firmware uses this controller to communicate with
    an on-board I2C device during resume but does not disable the controller
    before giving control to an operating system.
    
    I was told the UEFI update fixes this but never the less it revealed the
    driver is not ready to handle TX_EMPTY (or RX_FULL) interrupt when device
    is supposed to be idle and state variables are not set (especially the
    dev->msgs pointer which may point to NULL or stale old data).
    
    Introduce a new software status flag STATUS_ACTIVE indicating when the
    controller is active in driver point of view. Now treat all interrupts
    that occur when is not set as unexpected and mask all interrupts from
    the controller.
    
    Fixes: c7b79a752871 ("mfd: intel-lpss: Add Intel Alder Lake PCH-S PCI IDs")
    Reported-by: Samuel Clark <slc2015@gmail.com>
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=215907
    Cc: stable@vger.kernel.org # v5.12+
    Signed-off-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Wolfram Sang <wsa@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 034b30c311461a661de6da14c417e246179bb130
Author: Letu Ren <fantasquex@gmail.com>
Date:   Fri Nov 12 20:06:41 2021 +0800

    scsi: qedf: Fix a UAF bug in __qedf_probe()
    
    [ Upstream commit fbfe96869b782364caebae0445763969ddb6ea67 ]
    
    In __qedf_probe(), if qedf->cdev is NULL which means
    qed_ops->common->probe() failed, then the program will goto label err1, and
    scsi_host_put() will free lport->host pointer. Because the memory qedf
    points to is allocated by libfc_host_alloc(), it will be freed by
    scsi_host_put(). However, the if statement below label err0 only checks
    whether qedf is NULL but doesn't check whether the memory has been freed.
    So a UAF bug can occur.
    
    There are two ways to reach the statements below err0. The first one is
    described as before, "qedf" should be set to NULL. The second one is goto
    "err0" directly. In the latter scenario qedf hasn't been changed and it has
    the initial value NULL. As a result the if statement is not reachable in
    any situation.
    
    The KASAN logs are as follows:
    
    [    2.312969] BUG: KASAN: use-after-free in __qedf_probe+0x5dcf/0x6bc0
    [    2.312969]
    [    2.312969] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.12.0-59-gc9ba5276e321-prebuilt.qemu.org 04/01/2014
    [    2.312969] Call Trace:
    [    2.312969]  dump_stack_lvl+0x59/0x7b
    [    2.312969]  print_address_description+0x7c/0x3b0
    [    2.312969]  ? __qedf_probe+0x5dcf/0x6bc0
    [    2.312969]  __kasan_report+0x160/0x1c0
    [    2.312969]  ? __qedf_probe+0x5dcf/0x6bc0
    [    2.312969]  kasan_report+0x4b/0x70
    [    2.312969]  ? kobject_put+0x25d/0x290
    [    2.312969]  kasan_check_range+0x2ca/0x310
    [    2.312969]  __qedf_probe+0x5dcf/0x6bc0
    [    2.312969]  ? selinux_kernfs_init_security+0xdc/0x5f0
    [    2.312969]  ? trace_rpm_return_int_rcuidle+0x18/0x120
    [    2.312969]  ? rpm_resume+0xa5c/0x16e0
    [    2.312969]  ? qedf_get_generic_tlv_data+0x160/0x160
    [    2.312969]  local_pci_probe+0x13c/0x1f0
    [    2.312969]  pci_device_probe+0x37e/0x6c0
    
    Link: https://lore.kernel.org/r/20211112120641.16073-1-fantasquex@gmail.com
    Reported-by: Zheyu Ma <zheyuma97@gmail.com>
    Acked-by: Saurav Kashyap <skashyap@marvell.com>
    Co-developed-by: Wende Tan <twd2.me@gmail.com>
    Signed-off-by: Wende Tan <twd2.me@gmail.com>
    Signed-off-by: Letu Ren <fantasquex@gmail.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 61be8898d70463d24eac08d5a8cbf694b191be4d
Author: Letu Ren <fantasquex@gmail.com>
Date:   Fri Nov 12 20:06:41 2021 +0800

    scsi: qedf: Fix a UAF bug in __qedf_probe()
    
    [ Upstream commit fbfe96869b782364caebae0445763969ddb6ea67 ]
    
    In __qedf_probe(), if qedf->cdev is NULL which means
    qed_ops->common->probe() failed, then the program will goto label err1, and
    scsi_host_put() will free lport->host pointer. Because the memory qedf
    points to is allocated by libfc_host_alloc(), it will be freed by
    scsi_host_put(). However, the if statement below label err0 only checks
    whether qedf is NULL but doesn't check whether the memory has been freed.
    So a UAF bug can occur.
    
    There are two ways to reach the statements below err0. The first one is
    described as before, "qedf" should be set to NULL. The second one is goto
    "err0" directly. In the latter scenario qedf hasn't been changed and it has
    the initial value NULL. As a result the if statement is not reachable in
    any situation.
    
    The KASAN logs are as follows:
    
    [    2.312969] BUG: KASAN: use-after-free in __qedf_probe+0x5dcf/0x6bc0
    [    2.312969]
    [    2.312969] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.12.0-59-gc9ba5276e321-prebuilt.qemu.org 04/01/2014
    [    2.312969] Call Trace:
    [    2.312969]  dump_stack_lvl+0x59/0x7b
    [    2.312969]  print_address_description+0x7c/0x3b0
    [    2.312969]  ? __qedf_probe+0x5dcf/0x6bc0
    [    2.312969]  __kasan_report+0x160/0x1c0
    [    2.312969]  ? __qedf_probe+0x5dcf/0x6bc0
    [    2.312969]  kasan_report+0x4b/0x70
    [    2.312969]  ? kobject_put+0x25d/0x290
    [    2.312969]  kasan_check_range+0x2ca/0x310
    [    2.312969]  __qedf_probe+0x5dcf/0x6bc0
    [    2.312969]  ? selinux_kernfs_init_security+0xdc/0x5f0
    [    2.312969]  ? trace_rpm_return_int_rcuidle+0x18/0x120
    [    2.312969]  ? rpm_resume+0xa5c/0x16e0
    [    2.312969]  ? qedf_get_generic_tlv_data+0x160/0x160
    [    2.312969]  local_pci_probe+0x13c/0x1f0
    [    2.312969]  pci_device_probe+0x37e/0x6c0
    
    Link: https://lore.kernel.org/r/20211112120641.16073-1-fantasquex@gmail.com
    Reported-by: Zheyu Ma <zheyuma97@gmail.com>
    Acked-by: Saurav Kashyap <skashyap@marvell.com>
    Co-developed-by: Wende Tan <twd2.me@gmail.com>
    Signed-off-by: Wende Tan <twd2.me@gmail.com>
    Signed-off-by: Letu Ren <fantasquex@gmail.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 1030659dac4ea370090ace75b3266c3c828269aa
Author: Letu Ren <fantasquex@gmail.com>
Date:   Fri Nov 12 20:06:41 2021 +0800

    scsi: qedf: Fix a UAF bug in __qedf_probe()
    
    [ Upstream commit fbfe96869b782364caebae0445763969ddb6ea67 ]
    
    In __qedf_probe(), if qedf->cdev is NULL which means
    qed_ops->common->probe() failed, then the program will goto label err1, and
    scsi_host_put() will free lport->host pointer. Because the memory qedf
    points to is allocated by libfc_host_alloc(), it will be freed by
    scsi_host_put(). However, the if statement below label err0 only checks
    whether qedf is NULL but doesn't check whether the memory has been freed.
    So a UAF bug can occur.
    
    There are two ways to reach the statements below err0. The first one is
    described as before, "qedf" should be set to NULL. The second one is goto
    "err0" directly. In the latter scenario qedf hasn't been changed and it has
    the initial value NULL. As a result the if statement is not reachable in
    any situation.
    
    The KASAN logs are as follows:
    
    [    2.312969] BUG: KASAN: use-after-free in __qedf_probe+0x5dcf/0x6bc0
    [    2.312969]
    [    2.312969] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.12.0-59-gc9ba5276e321-prebuilt.qemu.org 04/01/2014
    [    2.312969] Call Trace:
    [    2.312969]  dump_stack_lvl+0x59/0x7b
    [    2.312969]  print_address_description+0x7c/0x3b0
    [    2.312969]  ? __qedf_probe+0x5dcf/0x6bc0
    [    2.312969]  __kasan_report+0x160/0x1c0
    [    2.312969]  ? __qedf_probe+0x5dcf/0x6bc0
    [    2.312969]  kasan_report+0x4b/0x70
    [    2.312969]  ? kobject_put+0x25d/0x290
    [    2.312969]  kasan_check_range+0x2ca/0x310
    [    2.312969]  __qedf_probe+0x5dcf/0x6bc0
    [    2.312969]  ? selinux_kernfs_init_security+0xdc/0x5f0
    [    2.312969]  ? trace_rpm_return_int_rcuidle+0x18/0x120
    [    2.312969]  ? rpm_resume+0xa5c/0x16e0
    [    2.312969]  ? qedf_get_generic_tlv_data+0x160/0x160
    [    2.312969]  local_pci_probe+0x13c/0x1f0
    [    2.312969]  pci_device_probe+0x37e/0x6c0
    
    Link: https://lore.kernel.org/r/20211112120641.16073-1-fantasquex@gmail.com
    Reported-by: Zheyu Ma <zheyuma97@gmail.com>
    Acked-by: Saurav Kashyap <skashyap@marvell.com>
    Co-developed-by: Wende Tan <twd2.me@gmail.com>
    Signed-off-by: Wende Tan <twd2.me@gmail.com>
    Signed-off-by: Letu Ren <fantasquex@gmail.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit ce57f7b2e61404e28453cd75afa2a013c263c34f
Author: Letu Ren <fantasquex@gmail.com>
Date:   Fri Nov 12 20:06:41 2021 +0800

    scsi: qedf: Fix a UAF bug in __qedf_probe()
    
    [ Upstream commit fbfe96869b782364caebae0445763969ddb6ea67 ]
    
    In __qedf_probe(), if qedf->cdev is NULL which means
    qed_ops->common->probe() failed, then the program will goto label err1, and
    scsi_host_put() will free lport->host pointer. Because the memory qedf
    points to is allocated by libfc_host_alloc(), it will be freed by
    scsi_host_put(). However, the if statement below label err0 only checks
    whether qedf is NULL but doesn't check whether the memory has been freed.
    So a UAF bug can occur.
    
    There are two ways to reach the statements below err0. The first one is
    described as before, "qedf" should be set to NULL. The second one is goto
    "err0" directly. In the latter scenario qedf hasn't been changed and it has
    the initial value NULL. As a result the if statement is not reachable in
    any situation.
    
    The KASAN logs are as follows:
    
    [    2.312969] BUG: KASAN: use-after-free in __qedf_probe+0x5dcf/0x6bc0
    [    2.312969]
    [    2.312969] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.12.0-59-gc9ba5276e321-prebuilt.qemu.org 04/01/2014
    [    2.312969] Call Trace:
    [    2.312969]  dump_stack_lvl+0x59/0x7b
    [    2.312969]  print_address_description+0x7c/0x3b0
    [    2.312969]  ? __qedf_probe+0x5dcf/0x6bc0
    [    2.312969]  __kasan_report+0x160/0x1c0
    [    2.312969]  ? __qedf_probe+0x5dcf/0x6bc0
    [    2.312969]  kasan_report+0x4b/0x70
    [    2.312969]  ? kobject_put+0x25d/0x290
    [    2.312969]  kasan_check_range+0x2ca/0x310
    [    2.312969]  __qedf_probe+0x5dcf/0x6bc0
    [    2.312969]  ? selinux_kernfs_init_security+0xdc/0x5f0
    [    2.312969]  ? trace_rpm_return_int_rcuidle+0x18/0x120
    [    2.312969]  ? rpm_resume+0xa5c/0x16e0
    [    2.312969]  ? qedf_get_generic_tlv_data+0x160/0x160
    [    2.312969]  local_pci_probe+0x13c/0x1f0
    [    2.312969]  pci_device_probe+0x37e/0x6c0
    
    Link: https://lore.kernel.org/r/20211112120641.16073-1-fantasquex@gmail.com
    Reported-by: Zheyu Ma <zheyuma97@gmail.com>
    Acked-by: Saurav Kashyap <skashyap@marvell.com>
    Co-developed-by: Wende Tan <twd2.me@gmail.com>
    Signed-off-by: Wende Tan <twd2.me@gmail.com>
    Signed-off-by: Letu Ren <fantasquex@gmail.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 301c8f5c32c8fb79c67539bc23972dc3ef48024c
Author: Jarkko Nikula <jarkko.nikula@linux.intel.com>
Date:   Tue Sep 27 16:56:44 2022 +0300

    i2c: designware: Fix handling of real but unexpected device interrupts
    
    Commit c7b79a752871 ("mfd: intel-lpss: Add Intel Alder Lake PCH-S PCI
    IDs") caused a regression on certain Gigabyte motherboards for Intel
    Alder Lake-S where system crashes to NULL pointer dereference in
    i2c_dw_xfer_msg() when system resumes from S3 sleep state ("deep").
    
    I was able to debug the issue on Gigabyte Z690 AORUS ELITE and made
    following notes:
    
    - Issue happens when resuming from S3 but not when resuming from
      "s2idle"
    - PCI device 00:15.0 == i2c_designware.0 is already in D0 state when
      system enters into pci_pm_resume_noirq() while all other i2c_designware
      PCI devices are in D3. Devices were runtime suspended and in D3 prior
      entering into suspend
    - Interrupt comes after pci_pm_resume_noirq() when device interrupts are
      re-enabled
    - According to register dump the interrupt really comes from the
      i2c_designware.0. Controller is enabled, I2C target address register
      points to a one detectable I2C device address 0x60 and the
      DW_IC_RAW_INTR_STAT register START_DET, STOP_DET, ACTIVITY and
      TX_EMPTY bits are set indicating completed I2C transaction.
    
    My guess is that the firmware uses this controller to communicate with
    an on-board I2C device during resume but does not disable the controller
    before giving control to an operating system.
    
    I was told the UEFI update fixes this but never the less it revealed the
    driver is not ready to handle TX_EMPTY (or RX_FULL) interrupt when device
    is supposed to be idle and state variables are not set (especially the
    dev->msgs pointer which may point to NULL or stale old data).
    
    Introduce a new software status flag STATUS_ACTIVE indicating when the
    controller is active in driver point of view. Now treat all interrupts
    that occur when is not set as unexpected and mask all interrupts from
    the controller.
    
    Fixes: c7b79a752871 ("mfd: intel-lpss: Add Intel Alder Lake PCH-S PCI IDs")
    Reported-by: Samuel Clark <slc2015@gmail.com>
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=215907
    Cc: stable@vger.kernel.org # v5.12+
    Signed-off-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Wolfram Sang <wsa@kernel.org>

commit c79e6fa98ca8628556a01fe277022bda64829fdf
Merge: 9388076b4ced ac73ce394a12
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Oct 3 13:26:47 2022 -0700

    Merge tag 'pm-6.1-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull power management updates from Rafael Wysocki:
     "These add support for some new hardware, extend the existing hardware
      support, fix some issues and clean up code
    
      Specifics:
    
       - Add isupport for Tiger Lake in no-HWP mode to intel_pstate (Doug
         Smythies)
    
       - Update the AMD P-state driver (Perry Yuan):
          - Fix wrong lowest perf fetch
          - Map desired perf into pstate scope for powersave governor
          - Update pstate frequency transition delay time
          - Fix initial highest_perf value
          - Clean up
    
       - Move max CPU capacity to sugov_policy in the schedutil cpufreq
         governor (Lukasz Luba)
    
       - Add SM6115 to cpufreq-dt blocklist (Adam Skladowski)
    
       - Add support for Tegra239 and minor cleanups (Sumit Gupta, ye
         xingchen, and Yang Yingliang)
    
       - Add freq qos for qcom cpufreq driver and minor cleanups (Xuewen
         Yan, and Viresh Kumar)
    
       - Minor cleanups around functions called at module_init() (Xiu
         Jianfeng)
    
       - Use module_init and add module_exit for bmips driver (Zhang
         Jianhua)
    
       - Add AlderLake-N support to intel_idle (Zhang Rui)
    
       - Replace strlcpy() with unused retval with strscpy() in intel_idle
         (Wolfram Sang)
    
       - Remove redundant check from cpuidle_switch_governor() (Yu Liao)
    
       - Replace strlcpy() with unused retval with strscpy() in the powernv
         cpuidle driver (Wolfram Sang)
    
       - Drop duplicate word from a comment in the coupled cpuidle driver
         (Jason Wang)
    
       - Make rpm_resume() return -EINPROGRESS if RPM_NOWAIT is passed to it
         in the flags and the device is about to resume (Rafael Wysocki)
    
       - Add extra debugging statement for multiple active IRQs to system
         wakeup handling code (Mario Limonciello)
    
       - Replace strlcpy() with unused retval with strscpy() in the core
         system suspend support code (Wolfram Sang)
    
       - Update the intel_rapl power capping driver:
          - Use standard Energy Unit for SPR Dram RAPL domain (Zhang Rui).
          - Add support for RAPTORLAKE_S (Zhang Rui).
          - Fix UBSAN shift-out-of-bounds issue (Chao Qin)
    
       - Handle -EPROBE_DEFER when regulator is not probed on
         mtk-ci-devfreq.c (AngeloGioacchino Del Regno)
    
       - Fix message typo and use dev_err_probe() in rockchip-dfi.c
         (Christophe JAILLET)"
    
    * tag 'pm-6.1-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (29 commits)
      cpufreq: qcom-cpufreq-hw: Add cpufreq qos for LMh
      cpufreq: Add __init annotation to module init funcs
      cpufreq: tegra194: change tegra239_cpufreq_soc to static
      PM / devfreq: rockchip-dfi: Fix an error message
      PM / devfreq: mtk-cci: Handle sram regulator probe deferral
      powercap: intel_rapl: Use standard Energy Unit for SPR Dram RAPL domain
      PM: runtime: Return -EINPROGRESS from rpm_resume() in the RPM_NOWAIT case
      intel_idle: Add AlderLake-N support
      powercap: intel_rapl: fix UBSAN shift-out-of-bounds issue
      cpufreq: tegra194: Add support for Tegra239
      cpufreq: qcom-cpufreq-hw: Fix uninitialized throttled_freq warning
      cpufreq: intel_pstate: Add Tigerlake support in no-HWP mode
      powercap: intel_rapl: Add support for RAPTORLAKE_S
      cpufreq: amd-pstate: Fix initial highest_perf value
      cpuidle: Remove redundant check in cpuidle_switch_governor()
      PM: wakeup: Add extra debugging statement for multiple active IRQs
      cpufreq: tegra194: Remove the unneeded result variable
      PM: suspend: move from strlcpy() with unused retval to strscpy()
      intel_idle: move from strlcpy() with unused retval to strscpy()
      cpuidle: powernv: move from strlcpy() with unused retval to strscpy()
      ...

commit ac73ce394a129a88cb01ce190844bcd172ce14fb
Merge: 0766fa2e8a2e 65c0c2367e9e e66332a4bc89 cb3e7d624c3f 4c081324df56
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Oct 3 20:27:49 2022 +0200

    Merge branches 'pm-cpuidle', 'pm-core', 'pm-sleep' and 'powercap'
    
    Merge cpuidle changes, PM core changes and power capping changes for
    6.1-rc1:
    
     - Add AlderLake-N support to intel_idle (Zhang Rui).
    
     - Replace strlcpy() with unused retval with strscpy() in intel_idle
       (Wolfram Sang).
    
     - Remove redundant check from cpuidle_switch_governor() (Yu Liao).
    
     - Replace strlcpy() with unused retval with strscpy() in the powernv
       cpuidle driver (Wolfram Sang).
    
     - Drop duplicate word from a comment in the coupled cpuidle driver
       (Jason Wang).
    
     - Make rpm_resume() return -EINPROGRESS if RPM_NOWAIT is passed to it
       in the flags and the device is about to resume (Rafael Wysocki).
    
     - Add extra debugging statement for multiple active IRQs to system
       wakeup handling code (Mario Limonciello).
    
     - Replace strlcpy() with unused retval with strscpy() in the core
       system suspend support code (Wolfram Sang).
    
     - Update the intel_rapl power capping driver:
       * Use standard Energy Unit for SPR Dram RAPL domain (Zhang Rui).
       * Add support for RAPTORLAKE_S (Zhang Rui).
       * Fix UBSAN shift-out-of-bounds issue (Chao Qin).
    
    * pm-cpuidle:
      intel_idle: Add AlderLake-N support
      cpuidle: Remove redundant check in cpuidle_switch_governor()
      intel_idle: move from strlcpy() with unused retval to strscpy()
      cpuidle: powernv: move from strlcpy() with unused retval to strscpy()
      cpuidle: coupled: Drop duplicate word from a comment
    
    * pm-core:
      PM: runtime: Return -EINPROGRESS from rpm_resume() in the RPM_NOWAIT case
    
    * pm-sleep:
      PM: wakeup: Add extra debugging statement for multiple active IRQs
      PM: suspend: move from strlcpy() with unused retval to strscpy()
    
    * powercap:
      powercap: intel_rapl: Use standard Energy Unit for SPR Dram RAPL domain
      powercap: intel_rapl: fix UBSAN shift-out-of-bounds issue
      powercap: intel_rapl: Add support for RAPTORLAKE_S

commit e66332a4bc89e3219baaabc7bb549d17a2c42ce9
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Sep 22 20:04:40 2022 +0200

    PM: runtime: Return -EINPROGRESS from rpm_resume() in the RPM_NOWAIT case
    
    The prospective callers of rpm_resume() passing RPM_NOWAIT to it may
    be confused when it returns 0 without actually resuming the device
    which may happen if the device is suspending at the given time and it
    will only resume when the suspend in progress has completed.  To avoid
    that confusion, return -EINPROGRESS from rpm_resume() in that case.
    
    Since none of the current callers passing RPM_NOWAIT to rpm_resume()
    check its return value, this change has no functional impact.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Reviewed-by: Douglas Anderson <dianders@chromium.org>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>

commit fbfe96869b782364caebae0445763969ddb6ea67
Author: Letu Ren <fantasquex@gmail.com>
Date:   Fri Nov 12 20:06:41 2021 +0800

    scsi: qedf: Fix a UAF bug in __qedf_probe()
    
    In __qedf_probe(), if qedf->cdev is NULL which means
    qed_ops->common->probe() failed, then the program will goto label err1, and
    scsi_host_put() will free lport->host pointer. Because the memory qedf
    points to is allocated by libfc_host_alloc(), it will be freed by
    scsi_host_put(). However, the if statement below label err0 only checks
    whether qedf is NULL but doesn't check whether the memory has been freed.
    So a UAF bug can occur.
    
    There are two ways to reach the statements below err0. The first one is
    described as before, "qedf" should be set to NULL. The second one is goto
    "err0" directly. In the latter scenario qedf hasn't been changed and it has
    the initial value NULL. As a result the if statement is not reachable in
    any situation.
    
    The KASAN logs are as follows:
    
    [    2.312969] BUG: KASAN: use-after-free in __qedf_probe+0x5dcf/0x6bc0
    [    2.312969]
    [    2.312969] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.12.0-59-gc9ba5276e321-prebuilt.qemu.org 04/01/2014
    [    2.312969] Call Trace:
    [    2.312969]  dump_stack_lvl+0x59/0x7b
    [    2.312969]  print_address_description+0x7c/0x3b0
    [    2.312969]  ? __qedf_probe+0x5dcf/0x6bc0
    [    2.312969]  __kasan_report+0x160/0x1c0
    [    2.312969]  ? __qedf_probe+0x5dcf/0x6bc0
    [    2.312969]  kasan_report+0x4b/0x70
    [    2.312969]  ? kobject_put+0x25d/0x290
    [    2.312969]  kasan_check_range+0x2ca/0x310
    [    2.312969]  __qedf_probe+0x5dcf/0x6bc0
    [    2.312969]  ? selinux_kernfs_init_security+0xdc/0x5f0
    [    2.312969]  ? trace_rpm_return_int_rcuidle+0x18/0x120
    [    2.312969]  ? rpm_resume+0xa5c/0x16e0
    [    2.312969]  ? qedf_get_generic_tlv_data+0x160/0x160
    [    2.312969]  local_pci_probe+0x13c/0x1f0
    [    2.312969]  pci_device_probe+0x37e/0x6c0
    
    Link: https://lore.kernel.org/r/20211112120641.16073-1-fantasquex@gmail.com
    Reported-by: Zheyu Ma <zheyuma97@gmail.com>
    Acked-by: Saurav Kashyap <skashyap@marvell.com>
    Co-developed-by: Wende Tan <twd2.me@gmail.com>
    Signed-off-by: Wende Tan <twd2.me@gmail.com>
    Signed-off-by: Letu Ren <fantasquex@gmail.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

commit c01163dbd1b8aa016c163ff4bf3a2e90311504f1
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Sep 9 15:25:05 2022 -0500

    PCI/PM: Always disable PTM for all devices during suspend
    
    We want to disable PTM on Root Ports because that allows some chips, e.g.,
    Intel mobile chips since Coffee Lake, to enter a lower-power PM state.
    
    That means we also have to disable PTM on downstream devices.  PCIe r6.0,
    sec 2.2.8, recommends that functions support generation of messages in
    non-D0 states, so we have to assume Switch Upstream Ports or Endpoints may
    send PTM Requests while in D1, D2, and D3hot.  A PTM message received by a
    Downstream Port (including a Root Port) with PTM disabled must be treated
    as an Unsupported Request (sec 6.21.3).
    
    PTM was previously disabled only for Root Ports, and it was disabled in
    pci_prepare_to_sleep(), which is not called at all if a driver supports
    legacy PM or does its own state saving.
    
    Instead, disable PTM early in pci_pm_suspend() and pci_pm_runtime_suspend()
    so we do it in all cases.
    
    Previously PTM was disabled *after* saving device state, so the state
    restore on resume automatically re-enabled it.  Since we now disable PTM
    *before* saving state, we must explicitly re-enable it in pci_pm_resume()
    and pci_pm_runtime_resume().
    
    Here's a sample of errors that occur when PTM is disabled only on the Root
    Port.  With this topology:
    
      0000:00:1d.0 Root Port            to [bus 08-71]
      0000:08:00.0 Switch Upstream Port to [bus 09-71]
    
    Kai-Heng reported errors like this:
    
      pcieport 0000:00:1d.0:    [20] UnsupReq               (First)
      pcieport 0000:00:1d.0: AER:   TLP Header: 34000000 08000052 00000000 00000000
    
    Decoding TLP header 0x34...... (0011 0100b) and 0x08000052:
    
      Fmt                         001b  4 DW header, no data
      Type                     1 0100b  Msg (Local - Terminate at Receiver)
      Requester ID  0x0800              Bus 08 Devfn 00.0
      Message Code    0x52  0101 0010b  PTM Request
    
    The 00:1d.0 Root Port logged an Unsupported Request error when it received
    a PTM Request with Requester ID 08:00.0.
    
    Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=215453
    Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=216210
    Fixes: a697f072f5da ("PCI: Disable PTM during suspend to save power")
    Link: https://lore.kernel.org/r/20220909202505.314195-10-helgaas@kernel.org
    Reported-by: Kai-Heng Feng <kai.heng.feng@canonical.com>
    Tested-by: Rajvi Jingar <rajvi.jingar@linux.intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>

commit 494a22765ce479c9f8ad181c5d24cffda9f534bb
Author: Xu Qiang <xuqiang36@huawei.com>
Date:   Thu Aug 25 06:53:24 2022 +0000

    spi: qup: add missing clk_disable_unprepare on error in spi_qup_pm_resume_runtime()
    
    Add the missing clk_disable_unprepare() before return
    from spi_qup_pm_resume_runtime() in the error handling case.
    
    Fixes: dae1a7700b34 (spi: qup: Handle clocks in pm_runtime suspend and resume)
    Signed-off-by: Xu Qiang <xuqiang36@huawei.com>
    Link: https://lore.kernel.org/r/20220825065324.68446-2-xuqiang36@huawei.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

commit 785538bfdd682c8e962341d585f9b88262a0475e
Author: Bart Van Assche <bvanassche@acm.org>
Date:   Tue Aug 16 10:26:38 2022 -0700

    scsi: sd: Revert "Rework asynchronous resume support"
    
    Although commit 88f1669019bd ("scsi: sd: Rework asynchronous resume support")
    eliminates a delay for some ATA disks after resume, it causes resume of ATA
    disks to fail on other setups. See also:
    
     * "Resume process hangs for 5-6 seconds starting sometime in 5.16"
       (https://bugzilla.kernel.org/show_bug.cgi?id=215880).
    
     * Geert's regression report
       (https://lore.kernel.org/linux-scsi/alpine.DEB.2.22.394.2207191125130.1006766@ramsan.of.borg/).
    
    This is what I understand about this issue:
    
     * During resume, ata_port_pm_resume() starts the SCSI error handler.  This
       changes the SCSI host state into SHOST_RECOVERY and causes
       scsi_queue_rq() to return BLK_STS_RESOURCE.
    
     * sd_resume() calls sd_start_stop_device() for ATA devices. That function
       in turn calls sd_submit_start() which tries to submit a START STOP UNIT
       command. That command can only be submitted after the SCSI error handler
       has changed the SCSI host state back to SHOST_RUNNING.
    
     * The SCSI error handler runs on its own thread and calls
       schedule_work(&(ap->scsi_rescan_task)). That causes
       ata_scsi_dev_rescan() to be called from the context of a kernel
       workqueue. That call hangs in blk_mq_get_tag(). I'm not sure why - maybe
       because all available tags have been allocated by sd_submit_start()
       calls (this is a guess).
    
    Link: https://lore.kernel.org/r/20220816172638.538734-1-bvanassche@acm.org
    Fixes: 88f1669019bd ("scsi: sd: Rework asynchronous resume support")
    Cc: Damien Le Moal <damien.lemoal@opensource.wdc.com>
    Cc: Hannes Reinecke <hare@suse.de>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: gzhqyz@gmail.com
    Reported-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Reported-by: gzhqyz@gmail.com
    Reported-and-tested-by: Vlastimil Babka <vbabka@suse.cz>
    Tested-by: John Garry <john.garry@huawei.com>
    Tested-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Bart Van Assche <bvanassche@acm.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

commit b1a412c12da61ce6c6df3bfca3a9faf294a81a2a
Author: Dave Stevenson <dave.stevenson@raspberrypi.com>
Date:   Mon Jun 13 16:47:50 2022 +0200

    drm/vc4: hdmi: Move HDMI reset to pm_resume
    
    [ Upstream commit 467e30171b5b483922b1c24c573fa50787207cb6 ]
    
    The BCM2835-37 found in the RaspberryPi 0 to 3 have a power domain
    attached to the HDMI block, handled in Linux through runtime_pm.
    
    That power domain is shared with the VEC block, so even if we put our
    runtime_pm reference in the HDMI driver it would keep being on. If the
    VEC is disabled though, the power domain would be disabled and we would
    lose any initialization done in our bind implementation.
    
    That initialization involves calling the reset function and initializing
    the CEC registers.
    
    Let's move the initialization to our runtime_resume implementation so
    that we initialize everything properly if we ever need to.
    
    Fixes: c86b41214362 ("drm/vc4: hdmi: Move the HSM clock enable to runtime_pm")
    Signed-off-by: Dave Stevenson <dave.stevenson@raspberrypi.com>
    Link: https://lore.kernel.org/r/20220613144800.326124-24-maxime@cerno.tech
    Signed-off-by: Maxime Ripard <maxime@cerno.tech>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit f924211946291d52de29b6f93202dbf80cc14629
Author: Lukas Wunner <lukas@wunner.de>
Date:   Fri Jul 1 22:47:51 2022 +0200

    usbnet: smsc95xx: Fix deadlock on runtime resume
    
    commit 7b960c967f2aa01ab8f45c5a0bd78e754cffdeee upstream.
    
    Commit 05b35e7eb9a1 ("smsc95xx: add phylib support") amended
    smsc95xx_resume() to call phy_init_hw().  That function waits for the
    device to runtime resume even though it is placed in the runtime resume
    path, causing a deadlock.
    
    The problem is that phy_init_hw() calls down to smsc95xx_mdiobus_read(),
    which never uses the _nopm variant of usbnet_read_cmd().
    
    Commit b4df480f68ae ("usbnet: smsc95xx: add reset_resume function with
    reset operation") causes a similar deadlock on resume if the device was
    already runtime suspended when entering system sleep:
    
    That's because the commit introduced smsc95xx_reset_resume(), which
    calls down to smsc95xx_reset(), which neglects to use _nopm accessors.
    
    Fix by auto-detecting whether a device access is performed by the
    suspend/resume task_struct and use the _nopm variant if so.  This works
    because the PM core guarantees that suspend/resume callbacks are run in
    task context.
    
    Stacktrace for posterity:
    
      INFO: task kworker/2:1:49 blocked for more than 122 seconds.
      Workqueue: usb_hub_wq hub_event
      schedule
      rpm_resume
      __pm_runtime_resume
      usb_autopm_get_interface
      usbnet_read_cmd
      __smsc95xx_read_reg
      __smsc95xx_phy_wait_not_busy
      __smsc95xx_mdio_read
      smsc95xx_mdiobus_read
      __mdiobus_read
      mdiobus_read
      smsc_phy_reset
      phy_init_hw
      smsc95xx_resume
      usb_resume_interface
      usb_resume_both
      usb_runtime_resume
      __rpm_callback
      rpm_callback
      rpm_resume
      __pm_runtime_resume
      usb_autoresume_device
      hub_event
      process_one_work
    
    Fixes: b4df480f68ae ("usbnet: smsc95xx: add reset_resume function with reset operation")
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Cc: stable@vger.kernel.org # v3.16+
    Cc: Andre Edich <andre.edich@microchip.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit e81395cfbe62518f41af79a1b287fc8fe7c96b37
Author: Lukas Wunner <lukas@wunner.de>
Date:   Fri Jul 1 22:47:51 2022 +0200

    usbnet: smsc95xx: Fix deadlock on runtime resume
    
    [ Upstream commit 7b960c967f2aa01ab8f45c5a0bd78e754cffdeee ]
    
    Commit 05b35e7eb9a1 ("smsc95xx: add phylib support") amended
    smsc95xx_resume() to call phy_init_hw().  That function waits for the
    device to runtime resume even though it is placed in the runtime resume
    path, causing a deadlock.
    
    The problem is that phy_init_hw() calls down to smsc95xx_mdiobus_read(),
    which never uses the _nopm variant of usbnet_read_cmd().
    
    Commit b4df480f68ae ("usbnet: smsc95xx: add reset_resume function with
    reset operation") causes a similar deadlock on resume if the device was
    already runtime suspended when entering system sleep:
    
    That's because the commit introduced smsc95xx_reset_resume(), which
    calls down to smsc95xx_reset(), which neglects to use _nopm accessors.
    
    Fix by auto-detecting whether a device access is performed by the
    suspend/resume task_struct and use the _nopm variant if so.  This works
    because the PM core guarantees that suspend/resume callbacks are run in
    task context.
    
    Stacktrace for posterity:
    
      INFO: task kworker/2:1:49 blocked for more than 122 seconds.
      Workqueue: usb_hub_wq hub_event
      schedule
      rpm_resume
      __pm_runtime_resume
      usb_autopm_get_interface
      usbnet_read_cmd
      __smsc95xx_read_reg
      __smsc95xx_phy_wait_not_busy
      __smsc95xx_mdio_read
      smsc95xx_mdiobus_read
      __mdiobus_read
      mdiobus_read
      smsc_phy_reset
      phy_init_hw
      smsc95xx_resume
      usb_resume_interface
      usb_resume_both
      usb_runtime_resume
      __rpm_callback
      rpm_callback
      rpm_resume
      __pm_runtime_resume
      usb_autoresume_device
      hub_event
      process_one_work
    
    Fixes: b4df480f68ae ("usbnet: smsc95xx: add reset_resume function with reset operation")
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Cc: stable@vger.kernel.org # v3.16+
    Cc: Andre Edich <andre.edich@microchip.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 6a612f40370cccf3fae25ca464a6fe0c05a974b6
Author: Dave Stevenson <dave.stevenson@raspberrypi.com>
Date:   Mon Jun 13 16:47:50 2022 +0200

    drm/vc4: hdmi: Move HDMI reset to pm_resume
    
    [ Upstream commit 467e30171b5b483922b1c24c573fa50787207cb6 ]
    
    The BCM2835-37 found in the RaspberryPi 0 to 3 have a power domain
    attached to the HDMI block, handled in Linux through runtime_pm.
    
    That power domain is shared with the VEC block, so even if we put our
    runtime_pm reference in the HDMI driver it would keep being on. If the
    VEC is disabled though, the power domain would be disabled and we would
    lose any initialization done in our bind implementation.
    
    That initialization involves calling the reset function and initializing
    the CEC registers.
    
    Let's move the initialization to our runtime_resume implementation so
    that we initialize everything properly if we ever need to.
    
    Fixes: c86b41214362 ("drm/vc4: hdmi: Move the HSM clock enable to runtime_pm")
    Signed-off-by: Dave Stevenson <dave.stevenson@raspberrypi.com>
    Link: https://lore.kernel.org/r/20220613144800.326124-24-maxime@cerno.tech
    Signed-off-by: Maxime Ripard <maxime@cerno.tech>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit b574d1e3e9a2432b5acd9c4a9dc8d70b6a37aaf1
Author: Lukas Wunner <lukas@wunner.de>
Date:   Fri Jul 1 22:47:51 2022 +0200

    usbnet: smsc95xx: Fix deadlock on runtime resume
    
    [ Upstream commit 7b960c967f2aa01ab8f45c5a0bd78e754cffdeee ]
    
    Commit 05b35e7eb9a1 ("smsc95xx: add phylib support") amended
    smsc95xx_resume() to call phy_init_hw().  That function waits for the
    device to runtime resume even though it is placed in the runtime resume
    path, causing a deadlock.
    
    The problem is that phy_init_hw() calls down to smsc95xx_mdiobus_read(),
    which never uses the _nopm variant of usbnet_read_cmd().
    
    Commit b4df480f68ae ("usbnet: smsc95xx: add reset_resume function with
    reset operation") causes a similar deadlock on resume if the device was
    already runtime suspended when entering system sleep:
    
    That's because the commit introduced smsc95xx_reset_resume(), which
    calls down to smsc95xx_reset(), which neglects to use _nopm accessors.
    
    Fix by auto-detecting whether a device access is performed by the
    suspend/resume task_struct and use the _nopm variant if so.  This works
    because the PM core guarantees that suspend/resume callbacks are run in
    task context.
    
    Stacktrace for posterity:
    
      INFO: task kworker/2:1:49 blocked for more than 122 seconds.
      Workqueue: usb_hub_wq hub_event
      schedule
      rpm_resume
      __pm_runtime_resume
      usb_autopm_get_interface
      usbnet_read_cmd
      __smsc95xx_read_reg
      __smsc95xx_phy_wait_not_busy
      __smsc95xx_mdio_read
      smsc95xx_mdiobus_read
      __mdiobus_read
      mdiobus_read
      smsc_phy_reset
      phy_init_hw
      smsc95xx_resume
      usb_resume_interface
      usb_resume_both
      usb_runtime_resume
      __rpm_callback
      rpm_callback
      rpm_resume
      __pm_runtime_resume
      usb_autoresume_device
      hub_event
      process_one_work
    
    Fixes: b4df480f68ae ("usbnet: smsc95xx: add reset_resume function with reset operation")
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Cc: stable@vger.kernel.org # v3.16+
    Cc: Andre Edich <andre.edich@microchip.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 702419db7ded2e3686fbc05040b61d7428d611d5
Author: Chia-Lin Kao (AceLan) <acelan.kao@canonical.com>
Date:   Wed Jul 13 19:12:24 2022 +0800

    net: atlantic: remove aq_nic_deinit() when resume
    
    [ Upstream commit 2e15c51fefaffaf9f72255eaef4fada05055e4c5 ]
    
    aq_nic_deinit() has been called while suspending, so we don't have to call
    it again on resume.
    Actually, call it again leads to another hang issue when resuming from
    S3.
    
    Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992345] Call Trace:
    Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992346] <TASK>
    Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992348] aq_nic_deinit+0xb4/0xd0 [atlantic]
    Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992356] aq_pm_thaw+0x7f/0x100 [atlantic]
    Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992362] pci_pm_resume+0x5c/0x90
    Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992366] ? pci_pm_thaw+0x80/0x80
    Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992368] dpm_run_callback+0x4e/0x120
    Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992371] device_resume+0xad/0x200
    Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992373] async_resume+0x1e/0x40
    Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992374] async_run_entry_fn+0x33/0x120
    Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992377] process_one_work+0x220/0x3c0
    Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992380] worker_thread+0x4d/0x3f0
    Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992382] ? process_one_work+0x3c0/0x3c0
    Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992384] kthread+0x12a/0x150
    Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992386] ? set_kthread_struct+0x40/0x40
    Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992387] ret_from_fork+0x22/0x30
    Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992391] </TASK>
    Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992392] ---[ end trace 1ec8c79604ed5e0d ]---
    Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992394] PM: dpm_run_callback(): pci_pm_resume+0x0/0x90 returns -110
    Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992397] atlantic 0000:02:00.0: PM: failed to resume async: error -110
    
    Fixes: 1809c30b6e5a ("net: atlantic: always deep reset on pm op, fixing up my null deref regression")
    Signed-off-by: Chia-Lin Kao (AceLan) <acelan.kao@canonical.com>
    Link: https://lore.kernel.org/r/20220713111224.1535938-2-acelan.kao@canonical.com
    Signed-off-by: Paolo Abeni <pabeni@redhat.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 58c90993933e7a76305519bc70da8c0cd2907c1f
Author: Chia-Lin Kao (AceLan) <acelan.kao@canonical.com>
Date:   Wed Jul 13 19:12:24 2022 +0800

    net: atlantic: remove aq_nic_deinit() when resume
    
    [ Upstream commit 2e15c51fefaffaf9f72255eaef4fada05055e4c5 ]
    
    aq_nic_deinit() has been called while suspending, so we don't have to call
    it again on resume.
    Actually, call it again leads to another hang issue when resuming from
    S3.
    
    Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992345] Call Trace:
    Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992346] <TASK>
    Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992348] aq_nic_deinit+0xb4/0xd0 [atlantic]
    Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992356] aq_pm_thaw+0x7f/0x100 [atlantic]
    Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992362] pci_pm_resume+0x5c/0x90
    Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992366] ? pci_pm_thaw+0x80/0x80
    Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992368] dpm_run_callback+0x4e/0x120
    Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992371] device_resume+0xad/0x200
    Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992373] async_resume+0x1e/0x40
    Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992374] async_run_entry_fn+0x33/0x120
    Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992377] process_one_work+0x220/0x3c0
    Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992380] worker_thread+0x4d/0x3f0
    Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992382] ? process_one_work+0x3c0/0x3c0
    Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992384] kthread+0x12a/0x150
    Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992386] ? set_kthread_struct+0x40/0x40
    Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992387] ret_from_fork+0x22/0x30
    Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992391] </TASK>
    Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992392] ---[ end trace 1ec8c79604ed5e0d ]---
    Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992394] PM: dpm_run_callback(): pci_pm_resume+0x0/0x90 returns -110
    Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992397] atlantic 0000:02:00.0: PM: failed to resume async: error -110
    
    Fixes: 1809c30b6e5a ("net: atlantic: always deep reset on pm op, fixing up my null deref regression")
    Signed-off-by: Chia-Lin Kao (AceLan) <acelan.kao@canonical.com>
    Link: https://lore.kernel.org/r/20220713111224.1535938-2-acelan.kao@canonical.com
    Signed-off-by: Paolo Abeni <pabeni@redhat.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit c2978d0124f26e453ed30fda6a37f62d8c7f19cb
Author: Chia-Lin Kao (AceLan) <acelan.kao@canonical.com>
Date:   Wed Jul 13 19:12:24 2022 +0800

    net: atlantic: remove aq_nic_deinit() when resume
    
    [ Upstream commit 2e15c51fefaffaf9f72255eaef4fada05055e4c5 ]
    
    aq_nic_deinit() has been called while suspending, so we don't have to call
    it again on resume.
    Actually, call it again leads to another hang issue when resuming from
    S3.
    
    Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992345] Call Trace:
    Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992346] <TASK>
    Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992348] aq_nic_deinit+0xb4/0xd0 [atlantic]
    Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992356] aq_pm_thaw+0x7f/0x100 [atlantic]
    Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992362] pci_pm_resume+0x5c/0x90
    Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992366] ? pci_pm_thaw+0x80/0x80
    Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992368] dpm_run_callback+0x4e/0x120
    Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992371] device_resume+0xad/0x200
    Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992373] async_resume+0x1e/0x40
    Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992374] async_run_entry_fn+0x33/0x120
    Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992377] process_one_work+0x220/0x3c0
    Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992380] worker_thread+0x4d/0x3f0
    Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992382] ? process_one_work+0x3c0/0x3c0
    Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992384] kthread+0x12a/0x150
    Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992386] ? set_kthread_struct+0x40/0x40
    Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992387] ret_from_fork+0x22/0x30
    Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992391] </TASK>
    Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992392] ---[ end trace 1ec8c79604ed5e0d ]---
    Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992394] PM: dpm_run_callback(): pci_pm_resume+0x0/0x90 returns -110
    Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992397] atlantic 0000:02:00.0: PM: failed to resume async: error -110
    
    Fixes: 1809c30b6e5a ("net: atlantic: always deep reset on pm op, fixing up my null deref regression")
    Signed-off-by: Chia-Lin Kao (AceLan) <acelan.kao@canonical.com>
    Link: https://lore.kernel.org/r/20220713111224.1535938-2-acelan.kao@canonical.com
    Signed-off-by: Paolo Abeni <pabeni@redhat.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 30fb034361ff1b9bfc569b2d8d66b544ea3eb18f
Author: Yuan Can <yuancan@huawei.com>
Date:   Mon Jul 4 13:01:45 2022 +0000

    crypto: ccree - Add missing clk_disable_unprepare() in cc_pm_resume()
    
    Add clk_disable_unprepare() on error path in cc_pm_resume().
    
    Reported-by: Hulk Robot <hulkci@huawei.com>
    Signed-off-by: Yuan Can <yuancan@huawei.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

commit 2e15c51fefaffaf9f72255eaef4fada05055e4c5
Author: Chia-Lin Kao (AceLan) <acelan.kao@canonical.com>
Date:   Wed Jul 13 19:12:24 2022 +0800

    net: atlantic: remove aq_nic_deinit() when resume
    
    aq_nic_deinit() has been called while suspending, so we don't have to call
    it again on resume.
    Actually, call it again leads to another hang issue when resuming from
    S3.
    
    Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992345] Call Trace:
    Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992346] <TASK>
    Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992348] aq_nic_deinit+0xb4/0xd0 [atlantic]
    Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992356] aq_pm_thaw+0x7f/0x100 [atlantic]
    Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992362] pci_pm_resume+0x5c/0x90
    Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992366] ? pci_pm_thaw+0x80/0x80
    Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992368] dpm_run_callback+0x4e/0x120
    Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992371] device_resume+0xad/0x200
    Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992373] async_resume+0x1e/0x40
    Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992374] async_run_entry_fn+0x33/0x120
    Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992377] process_one_work+0x220/0x3c0
    Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992380] worker_thread+0x4d/0x3f0
    Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992382] ? process_one_work+0x3c0/0x3c0
    Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992384] kthread+0x12a/0x150
    Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992386] ? set_kthread_struct+0x40/0x40
    Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992387] ret_from_fork+0x22/0x30
    Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992391] </TASK>
    Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992392] ---[ end trace 1ec8c79604ed5e0d ]---
    Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992394] PM: dpm_run_callback(): pci_pm_resume+0x0/0x90 returns -110
    Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992397] atlantic 0000:02:00.0: PM: failed to resume async: error -110
    
    Fixes: 1809c30b6e5a ("net: atlantic: always deep reset on pm op, fixing up my null deref regression")
    Signed-off-by: Chia-Lin Kao (AceLan) <acelan.kao@canonical.com>
    Link: https://lore.kernel.org/r/20220713111224.1535938-2-acelan.kao@canonical.com
    Signed-off-by: Paolo Abeni <pabeni@redhat.com>

commit e67bc525ace26e8dc03ca51b19579a14eaa41f32
Author: Lukas Wunner <lukas@wunner.de>
Date:   Tue Jun 28 12:15:08 2022 +0200

    net: phy: Don't trigger state machine while in suspend
    
    commit 1758bde2e4aa5ff188d53e7d9d388bbb7e12eebb upstream.
    
    Upon system sleep, mdio_bus_phy_suspend() stops the phy_state_machine(),
    but subsequent interrupts may retrigger it:
    
    They may have been left enabled to facilitate wakeup and are not
    quiesced until the ->suspend_noirq() phase.  Unwanted interrupts may
    hence occur between mdio_bus_phy_suspend() and dpm_suspend_noirq(),
    as well as between dpm_resume_noirq() and mdio_bus_phy_resume().
    
    Retriggering the phy_state_machine() through an interrupt is not only
    undesirable for the reason given in mdio_bus_phy_suspend() (freezing it
    midway with phydev->lock held), but also because the PHY may be
    inaccessible after it's suspended:  Accesses to USB-attached PHYs are
    blocked once usb_suspend_both() clears the can_submit flag and PHYs on
    PCI network cards may become inaccessible upon suspend as well.
    
    Amend phy_interrupt() to avoid triggering the state machine if the PHY
    is suspended.  Signal wakeup instead if the attached net_device or its
    parent has been configured as a wakeup source.  (Those conditions are
    identical to mdio_bus_phy_may_suspend().)  Postpone handling of the
    interrupt until the PHY has resumed.
    
    Before stopping the phy_state_machine() in mdio_bus_phy_suspend(),
    wait for a concurrent phy_interrupt() to run to completion.  That is
    necessary because phy_interrupt() may have checked the PHY's suspend
    status before the system sleep transition commenced and it may thus
    retrigger the state machine after it was stopped.
    
    Likewise, after re-enabling interrupt handling in mdio_bus_phy_resume(),
    wait for a concurrent phy_interrupt() to complete to ensure that
    interrupts which it postponed are properly rerun.
    
    The issue was exposed by commit 1ce8b37241ed ("usbnet: smsc95xx: Forward
    PHY interrupts to PHY driver to avoid polling"), but has existed since
    forever.
    
    Fixes: 541cd3ee00a4 ("phylib: Fix deadlock on resume")
    Link: https://lore.kernel.org/netdev/a5315a8a-32c2-962f-f696-de9a26d30091@samsung.com/
    Reported-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Tested-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: stable@vger.kernel.org # v2.6.33+
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Link: https://lore.kernel.org/r/b7f386d04e9b5b0e2738f0125743e30676f309ef.1656410895.git.lukas@wunner.de
    Signed-off-by: Jakub Kicinski <kuba@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 25fab798784b0312d408b827475bd5a77ff94753
Author: Lukas Wunner <lukas@wunner.de>
Date:   Tue Jun 28 12:15:08 2022 +0200

    net: phy: Don't trigger state machine while in suspend
    
    commit 1758bde2e4aa5ff188d53e7d9d388bbb7e12eebb upstream.
    
    Upon system sleep, mdio_bus_phy_suspend() stops the phy_state_machine(),
    but subsequent interrupts may retrigger it:
    
    They may have been left enabled to facilitate wakeup and are not
    quiesced until the ->suspend_noirq() phase.  Unwanted interrupts may
    hence occur between mdio_bus_phy_suspend() and dpm_suspend_noirq(),
    as well as between dpm_resume_noirq() and mdio_bus_phy_resume().
    
    Retriggering the phy_state_machine() through an interrupt is not only
    undesirable for the reason given in mdio_bus_phy_suspend() (freezing it
    midway with phydev->lock held), but also because the PHY may be
    inaccessible after it's suspended:  Accesses to USB-attached PHYs are
    blocked once usb_suspend_both() clears the can_submit flag and PHYs on
    PCI network cards may become inaccessible upon suspend as well.
    
    Amend phy_interrupt() to avoid triggering the state machine if the PHY
    is suspended.  Signal wakeup instead if the attached net_device or its
    parent has been configured as a wakeup source.  (Those conditions are
    identical to mdio_bus_phy_may_suspend().)  Postpone handling of the
    interrupt until the PHY has resumed.
    
    Before stopping the phy_state_machine() in mdio_bus_phy_suspend(),
    wait for a concurrent phy_interrupt() to run to completion.  That is
    necessary because phy_interrupt() may have checked the PHY's suspend
    status before the system sleep transition commenced and it may thus
    retrigger the state machine after it was stopped.
    
    Likewise, after re-enabling interrupt handling in mdio_bus_phy_resume(),
    wait for a concurrent phy_interrupt() to complete to ensure that
    interrupts which it postponed are properly rerun.
    
    The issue was exposed by commit 1ce8b37241ed ("usbnet: smsc95xx: Forward
    PHY interrupts to PHY driver to avoid polling"), but has existed since
    forever.
    
    Fixes: 541cd3ee00a4 ("phylib: Fix deadlock on resume")
    Link: https://lore.kernel.org/netdev/a5315a8a-32c2-962f-f696-de9a26d30091@samsung.com/
    Reported-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Tested-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: stable@vger.kernel.org # v2.6.33+
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Link: https://lore.kernel.org/r/b7f386d04e9b5b0e2738f0125743e30676f309ef.1656410895.git.lukas@wunner.de
    Signed-off-by: Jakub Kicinski <kuba@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 7b960c967f2aa01ab8f45c5a0bd78e754cffdeee
Author: Lukas Wunner <lukas@wunner.de>
Date:   Fri Jul 1 22:47:51 2022 +0200

    usbnet: smsc95xx: Fix deadlock on runtime resume
    
    Commit 05b35e7eb9a1 ("smsc95xx: add phylib support") amended
    smsc95xx_resume() to call phy_init_hw().  That function waits for the
    device to runtime resume even though it is placed in the runtime resume
    path, causing a deadlock.
    
    The problem is that phy_init_hw() calls down to smsc95xx_mdiobus_read(),
    which never uses the _nopm variant of usbnet_read_cmd().
    
    Commit b4df480f68ae ("usbnet: smsc95xx: add reset_resume function with
    reset operation") causes a similar deadlock on resume if the device was
    already runtime suspended when entering system sleep:
    
    That's because the commit introduced smsc95xx_reset_resume(), which
    calls down to smsc95xx_reset(), which neglects to use _nopm accessors.
    
    Fix by auto-detecting whether a device access is performed by the
    suspend/resume task_struct and use the _nopm variant if so.  This works
    because the PM core guarantees that suspend/resume callbacks are run in
    task context.
    
    Stacktrace for posterity:
    
      INFO: task kworker/2:1:49 blocked for more than 122 seconds.
      Workqueue: usb_hub_wq hub_event
      schedule
      rpm_resume
      __pm_runtime_resume
      usb_autopm_get_interface
      usbnet_read_cmd
      __smsc95xx_read_reg
      __smsc95xx_phy_wait_not_busy
      __smsc95xx_mdio_read
      smsc95xx_mdiobus_read
      __mdiobus_read
      mdiobus_read
      smsc_phy_reset
      phy_init_hw
      smsc95xx_resume
      usb_resume_interface
      usb_resume_both
      usb_runtime_resume
      __rpm_callback
      rpm_callback
      rpm_resume
      __pm_runtime_resume
      usb_autoresume_device
      hub_event
      process_one_work
    
    Fixes: b4df480f68ae ("usbnet: smsc95xx: add reset_resume function with reset operation")
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Cc: stable@vger.kernel.org # v3.16+
    Cc: Andre Edich <andre.edich@microchip.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 1758bde2e4aa5ff188d53e7d9d388bbb7e12eebb
Author: Lukas Wunner <lukas@wunner.de>
Date:   Tue Jun 28 12:15:08 2022 +0200

    net: phy: Don't trigger state machine while in suspend
    
    Upon system sleep, mdio_bus_phy_suspend() stops the phy_state_machine(),
    but subsequent interrupts may retrigger it:
    
    They may have been left enabled to facilitate wakeup and are not
    quiesced until the ->suspend_noirq() phase.  Unwanted interrupts may
    hence occur between mdio_bus_phy_suspend() and dpm_suspend_noirq(),
    as well as between dpm_resume_noirq() and mdio_bus_phy_resume().
    
    Retriggering the phy_state_machine() through an interrupt is not only
    undesirable for the reason given in mdio_bus_phy_suspend() (freezing it
    midway with phydev->lock held), but also because the PHY may be
    inaccessible after it's suspended:  Accesses to USB-attached PHYs are
    blocked once usb_suspend_both() clears the can_submit flag and PHYs on
    PCI network cards may become inaccessible upon suspend as well.
    
    Amend phy_interrupt() to avoid triggering the state machine if the PHY
    is suspended.  Signal wakeup instead if the attached net_device or its
    parent has been configured as a wakeup source.  (Those conditions are
    identical to mdio_bus_phy_may_suspend().)  Postpone handling of the
    interrupt until the PHY has resumed.
    
    Before stopping the phy_state_machine() in mdio_bus_phy_suspend(),
    wait for a concurrent phy_interrupt() to run to completion.  That is
    necessary because phy_interrupt() may have checked the PHY's suspend
    status before the system sleep transition commenced and it may thus
    retrigger the state machine after it was stopped.
    
    Likewise, after re-enabling interrupt handling in mdio_bus_phy_resume(),
    wait for a concurrent phy_interrupt() to complete to ensure that
    interrupts which it postponed are properly rerun.
    
    The issue was exposed by commit 1ce8b37241ed ("usbnet: smsc95xx: Forward
    PHY interrupts to PHY driver to avoid polling"), but has existed since
    forever.
    
    Fixes: 541cd3ee00a4 ("phylib: Fix deadlock on resume")
    Link: https://lore.kernel.org/netdev/a5315a8a-32c2-962f-f696-de9a26d30091@samsung.com/
    Reported-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Tested-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: stable@vger.kernel.org # v2.6.33+
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Link: https://lore.kernel.org/r/b7f386d04e9b5b0e2738f0125743e30676f309ef.1656410895.git.lukas@wunner.de
    Signed-off-by: Jakub Kicinski <kuba@kernel.org>

commit 467e30171b5b483922b1c24c573fa50787207cb6
Author: Dave Stevenson <dave.stevenson@raspberrypi.com>
Date:   Mon Jun 13 16:47:50 2022 +0200

    drm/vc4: hdmi: Move HDMI reset to pm_resume
    
    The BCM2835-37 found in the RaspberryPi 0 to 3 have a power domain
    attached to the HDMI block, handled in Linux through runtime_pm.
    
    That power domain is shared with the VEC block, so even if we put our
    runtime_pm reference in the HDMI driver it would keep being on. If the
    VEC is disabled though, the power domain would be disabled and we would
    lose any initialization done in our bind implementation.
    
    That initialization involves calling the reset function and initializing
    the CEC registers.
    
    Let's move the initialization to our runtime_resume implementation so
    that we initialize everything properly if we ever need to.
    
    Fixes: c86b41214362 ("drm/vc4: hdmi: Move the HSM clock enable to runtime_pm")
    Signed-off-by: Dave Stevenson <dave.stevenson@raspberrypi.com>
    Link: https://lore.kernel.org/r/20220613144800.326124-24-maxime@cerno.tech
    Signed-off-by: Maxime Ripard <maxime@cerno.tech>

commit 38bc4ac431684498126f9baa3a530e5a132f0173
Merge: cbe232ab07ab 1e9124df8be0
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jun 24 11:43:49 2022 -0700

    Merge tag 'drm-fixes-2022-06-24' of git://anongit.freedesktop.org/drm/drm
    
    Pull drm fixes from Dave Airlie:
     "Fixes for this week, bit larger than normal, but I think the last
      couple have been quieter, and it's only rc4.
    
      There are a lot of small msm fixes, and a slightly larger set of vc4
      fixes. The vc4 fixes clean up a lot of crashes around the rPI4
      hardware differences from earlier ones, and problems in the page flip
      and modeset code which assumed earlier hw, so I thought it would be
      okay to keep them in.
    
      Otherwise, it's a few amdgpu, i915, sun4i and a panel quirk.
    
      amdgpu:
       - Adjust GTT size logic
       - eDP fix for RMB
       - DCN 3.15 fix
       - DP training fix
       - Color encoding fix for DCN2+
    
      sun4i:
       - multiple suspend fixes
    
      vc4:
       - rework driver split for rpi4, fixes mulitple crashers.
    
      panel:
       - quirk for Aya Neo Next
    
      i915:
       - Revert low voltage SKU check removal to fix display issues
       - Apply PLL DCO fraction workaround for ADL-S
       - Don't show engine classes not present in client fdinfo
    
      msm:
       - Workaround for parade DSI bridge power sequencing
       - Fix for multi-planar YUV format offsets
       - Limiting WB modes to max sspp linewidth
       - Fixing the supported rotations to add 180 back for IGT
       - Fix to handle pm_runtime_get_sync() errors to avoid unclocked
         access in the bind() path for dpu driver
       - Fix the irq_free() without request issue which was a being hit
         frequently in CI.
       - Fix to add minimum ICC vote in the msm_mdss pm_resume path to
         address bootup splats
       - Fix to avoid dereferencing without checking in WB encoder
       - Fix to avoid crash during suspend in DP driver by ensuring
         interrupt mask bits are updated
       - Remove unused code from dpu_encoder_virt_atomic_check()
       - Fix to remove redundant init of dsc variable
       - Fix to ensure mmap offset is initialized to avoid memory corruption
         from unpin/evict
       - Fix double runpm disable in probe-defer path
       - VMA fenced-unpin fixes
       - Fix for WB max-width
       - Fix for rare dp resolution change issue"
    
    * tag 'drm-fixes-2022-06-24' of git://anongit.freedesktop.org/drm/drm: (41 commits)
      amd/display/dc: Fix COLOR_ENCODING and COLOR_RANGE doing nothing for DCN20+
      drm/amd/display: Fix typo in override_lane_settings
      drm/amd/display: Fix DC warning at driver load
      drm/amd: Revert "drm/amd/display: keep eDP Vdd on when eDP stream is already enabled"
      drm/amdgpu: Adjust logic around GTT size (v3)
      drm/sun4i: Return if frontend is not present
      drm/vc4: fix error code in vc4_check_tex_size()
      drm/sun4i: Add DMA mask and segment size
      drm/vc4: hdmi: Fixed possible integer overflow
      drm/i915/display: Re-add check for low voltage sku for max dp source rate
      drm/i915/fdinfo: Don't show engine classes not present
      drm/i915: Implement w/a 22010492432 for adl-s
      drm: panel-orientation-quirks: Add quirk for Aya Neo Next
      drm/msm/dp: force link training for display resolution change
      drm/msm/dpu: limit wb modes based on max_mixer_width
      drm/msm/dp: check core_initialized before disable interrupts at dp_display_unbind()
      drm/msm/mdp4: Fix refcount leak in mdp4_modeset_init_intf
      drm/msm: Don't overwrite hw fence in hw_init
      drm/msm: Drop update_fences()
      drm/vc4: Warn if some v3d code is run on BCM2711
      ...

commit 1e9124df8be0a43e4e9a10c5d1140d6ca8e50132
Merge: 08d27daaaa9e a6e2af64a79a
Author: Dave Airlie <airlied@redhat.com>
Date:   Fri Jun 24 10:11:26 2022 +1000

    Merge tag 'drm-msm-fixes-2022-06-20' of https://gitlab.freedesktop.org/drm/msm into drm-fixes
    
    Fixes for v5.19-rc4
    
    - Workaround for parade DSI bridge power sequencing
    - Fix for multi-planar YUV format offsets
    - Limiting WB modes to max sspp linewidth
    - Fixing the supported rotations to add 180 back for IGT
    - Fix to handle pm_runtime_get_sync() errors to avoid unclocked access
      in the bind() path for dpu driver
    - Fix the irq_free() without request issue which was a being hit frequently
      in CI.
    - Fix to add minimum ICC vote in the msm_mdss pm_resume path to address
      bootup splats
    - Fix to avoid dereferencing without checking in WB encoder
    - Fix to avoid crash during suspend in DP driver by ensuring interrupt
      mask bits are updated
    - Remove unused code from dpu_encoder_virt_atomic_check()
    - Fix to remove redundant init of dsc variable
    - Fix to ensure mmap offset is initialized to avoid memory corruption
      from unpin/evict
    - Fix double runpm disable in probe-defer path
    - VMA fenced-unpin fixes
    - Fix for WB max-width
    - Fix for rare dp resolution change issue
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    From: Rob Clark <robdclark@gmail.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/CAF6AEGvdsOF1-+WfTWyEyu33XPcvxOCU00G-dz7EF2J+fdyUHg@mail.gmail.com

commit 4ea3bfd13a2484b5f1c19f60b1dc7494f261f0a4
Author: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
Date:   Thu Jun 16 16:08:24 2022 -0500

    ASoC: SOF: pcm: use pm_resume_and_get() on component probe
    
    Before initiating IPC and/or bus transactions when loading the
    topology during a component probe, which happens on card
    registration/creation, make sure the device for the SOF driver is
    pm_runtime active.
    
    The SOF probe is not necessarily followed by the component probe, such
    a timing assumption can be broken in driver bind/unbind tests. This
    can be artifially shown if the module for the machine driver is
    'blacklisted' and the SOF device becomes pm_runtime_suspended before
    manually calling modprobe to register the card.
    
    In an initial experiment, pm_resume_and_get() was called from
    soc-component.c, since the current ASoC component model is arguably
    missing dependencies between component status and device
    status. However this approach proved too invasive and breaks all
    existing HDMI playback solutions on Intel platforms.
    
    While this will result in duplication of code, generating pm_runtime
    transitions only if strictly required for a given component makes more
    sense overall. This patch adds the pm_runtime resume transition for
    SOF only.
    
    BugLink: https://github.com/thesofproject/linux/issues/3651
    Signed-off-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Reviewed-by: Rander Wang <rander.wang@intel.com>
    Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Reviewed-by: Bard Liao <yung-chuan.liao@linux.intel.com>
    Reviewed-by: Pter Ujfalusi <peter.ujfalusi@linux.intel.com>
    Link: https://lore.kernel.org/r/20220616210825.132093-2-pierre-louis.bossart@linux.intel.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

commit 0a635239cd5484d8f2e702713ccc49ec82aa7594
Author: Biju Das <biju.das.jz@bp.renesas.com>
Date:   Fri Feb 25 17:53:16 2022 +0000

    watchdog: rzg2l_wdt: Fix 'BUG: Invalid wait context'
    
    [ Upstream commit e4cf89596c1f1e33309556699f910ced4abbaf44 ]
    
    This patch fixes the issue 'BUG: Invalid wait context' during restart()
    callback by using clk_prepare_enable() instead of pm_runtime_get_sync()
    for turning on the clocks during restart.
    
    This issue is noticed when testing with renesas_defconfig.
    
    [   42.213802] reboot: Restarting system
    [   42.217860]
    [   42.219364] =============================
    [   42.223368] [ BUG: Invalid wait context ]
    [   42.227372] 5.17.0-rc5-arm64-renesas-00002-g10393723e35e #522 Not tainted
    [   42.234153] -----------------------------
    [   42.238155] systemd-shutdow/1 is trying to lock:
    [   42.242766] ffff00000a650828 (&genpd->mlock){+.+.}-{3:3}, at: genpd_lock_mtx+0x14/0x20
    [   42.250709] other info that might help us debug this:
    [   42.255753] context-{4:4}
    [   42.258368] 2 locks held by systemd-shutdow/1:
    [   42.262806]  #0: ffff80000944e1c8 (system_transition_mutex#2){+.+.}-{3:3}, at: __do_sys_reboot+0xd0/0x250
    [   42.272388]  #1: ffff8000094c4e40 (rcu_read_lock){....}-{1:2}, at: atomic_notifier_call_chain+0x0/0x150
    [   42.281795] stack backtrace:
    [   42.284672] CPU: 0 PID: 1 Comm: systemd-shutdow Not tainted 5.17.0-rc5-arm64-renesas-00002-g10393723e35e #522
    [   42.294577] Hardware name: Renesas SMARC EVK based on r9a07g044c2 (DT)
    [   42.301096] Call trace:
    [   42.303538]  dump_backtrace+0xcc/0xd8
    [   42.307203]  show_stack+0x14/0x30
    [   42.310517]  dump_stack_lvl+0x88/0xb0
    [   42.314180]  dump_stack+0x14/0x2c
    [   42.317492]  __lock_acquire+0x1b24/0x1b50
    [   42.321502]  lock_acquire+0x120/0x3a8
    [   42.325162]  __mutex_lock+0x84/0x8f8
    [   42.328737]  mutex_lock_nested+0x30/0x58
    [   42.332658]  genpd_lock_mtx+0x14/0x20
    [   42.336319]  genpd_runtime_resume+0xc4/0x228
    [   42.340587]  __rpm_callback+0x44/0x170
    [   42.344337]  rpm_callback+0x64/0x70
    [   42.347824]  rpm_resume+0x4e0/0x6b8
    [   42.351310]  __pm_runtime_resume+0x50/0x78
    [   42.355404]  rzg2l_wdt_restart+0x28/0x68
    [   42.359329]  watchdog_restart_notifier+0x1c/0x30
    [   42.363943]  atomic_notifier_call_chain+0x94/0x150
    [   42.368732]  do_kernel_restart+0x24/0x30
    [   42.372652]  machine_restart+0x44/0x70
    [   42.376399]  kernel_restart+0x3c/0x60
    [   42.380058]  __do_sys_reboot+0x228/0x250
    [   42.383977]  __arm64_sys_reboot+0x20/0x28
    [   42.387983]  invoke_syscall+0x40/0xf8
    
    Fixes: 2cbc5cd0b55fa2 ("watchdog: Add Watchdog Timer driver for RZ/G2L")
    Signed-off-by: Biju Das <biju.das.jz@bp.renesas.com>
    Reviewed-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Reviewed-by: Guenter Roeck <linux@roeck-us.net>
    Link: https://lore.kernel.org/r/20220225175320.11041-4-biju.das.jz@bp.renesas.com
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Wim Van Sebroeck <wim@linux-watchdog.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 6505541e5298cea2b79da68ee626f583f8e18784
Author: Biju Das <biju.das.jz@bp.renesas.com>
Date:   Fri Feb 25 17:53:16 2022 +0000

    watchdog: rzg2l_wdt: Fix 'BUG: Invalid wait context'
    
    [ Upstream commit e4cf89596c1f1e33309556699f910ced4abbaf44 ]
    
    This patch fixes the issue 'BUG: Invalid wait context' during restart()
    callback by using clk_prepare_enable() instead of pm_runtime_get_sync()
    for turning on the clocks during restart.
    
    This issue is noticed when testing with renesas_defconfig.
    
    [   42.213802] reboot: Restarting system
    [   42.217860]
    [   42.219364] =============================
    [   42.223368] [ BUG: Invalid wait context ]
    [   42.227372] 5.17.0-rc5-arm64-renesas-00002-g10393723e35e #522 Not tainted
    [   42.234153] -----------------------------
    [   42.238155] systemd-shutdow/1 is trying to lock:
    [   42.242766] ffff00000a650828 (&genpd->mlock){+.+.}-{3:3}, at: genpd_lock_mtx+0x14/0x20
    [   42.250709] other info that might help us debug this:
    [   42.255753] context-{4:4}
    [   42.258368] 2 locks held by systemd-shutdow/1:
    [   42.262806]  #0: ffff80000944e1c8 (system_transition_mutex#2){+.+.}-{3:3}, at: __do_sys_reboot+0xd0/0x250
    [   42.272388]  #1: ffff8000094c4e40 (rcu_read_lock){....}-{1:2}, at: atomic_notifier_call_chain+0x0/0x150
    [   42.281795] stack backtrace:
    [   42.284672] CPU: 0 PID: 1 Comm: systemd-shutdow Not tainted 5.17.0-rc5-arm64-renesas-00002-g10393723e35e #522
    [   42.294577] Hardware name: Renesas SMARC EVK based on r9a07g044c2 (DT)
    [   42.301096] Call trace:
    [   42.303538]  dump_backtrace+0xcc/0xd8
    [   42.307203]  show_stack+0x14/0x30
    [   42.310517]  dump_stack_lvl+0x88/0xb0
    [   42.314180]  dump_stack+0x14/0x2c
    [   42.317492]  __lock_acquire+0x1b24/0x1b50
    [   42.321502]  lock_acquire+0x120/0x3a8
    [   42.325162]  __mutex_lock+0x84/0x8f8
    [   42.328737]  mutex_lock_nested+0x30/0x58
    [   42.332658]  genpd_lock_mtx+0x14/0x20
    [   42.336319]  genpd_runtime_resume+0xc4/0x228
    [   42.340587]  __rpm_callback+0x44/0x170
    [   42.344337]  rpm_callback+0x64/0x70
    [   42.347824]  rpm_resume+0x4e0/0x6b8
    [   42.351310]  __pm_runtime_resume+0x50/0x78
    [   42.355404]  rzg2l_wdt_restart+0x28/0x68
    [   42.359329]  watchdog_restart_notifier+0x1c/0x30
    [   42.363943]  atomic_notifier_call_chain+0x94/0x150
    [   42.368732]  do_kernel_restart+0x24/0x30
    [   42.372652]  machine_restart+0x44/0x70
    [   42.376399]  kernel_restart+0x3c/0x60
    [   42.380058]  __do_sys_reboot+0x228/0x250
    [   42.383977]  __arm64_sys_reboot+0x20/0x28
    [   42.387983]  invoke_syscall+0x40/0xf8
    
    Fixes: 2cbc5cd0b55fa2 ("watchdog: Add Watchdog Timer driver for RZ/G2L")
    Signed-off-by: Biju Das <biju.das.jz@bp.renesas.com>
    Reviewed-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Reviewed-by: Guenter Roeck <linux@roeck-us.net>
    Link: https://lore.kernel.org/r/20220225175320.11041-4-biju.das.jz@bp.renesas.com
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Wim Van Sebroeck <wim@linux-watchdog.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit ef10d0c68e8608848cd58fca2589685718426607
Author: Vinod Polimera <quic_vpolimer@quicinc.com>
Date:   Mon Apr 25 08:56:53 2022 +0530

    drm/msm/disp/dpu1: set vbif hw config to NULL to avoid use after memory free during pm runtime resume
    
    [ Upstream commit fa5186b279ecf44b14fb435540d2065be91cb1ed ]
    
    BUG: Unable to handle kernel paging request at virtual address 006b6b6b6b6b6be3
    
    Call trace:
      dpu_vbif_init_memtypes+0x40/0xb8
      dpu_runtime_resume+0xcc/0x1c0
      pm_generic_runtime_resume+0x30/0x44
      __genpd_runtime_resume+0x68/0x7c
      genpd_runtime_resume+0x134/0x258
      __rpm_callback+0x98/0x138
      rpm_callback+0x30/0x88
      rpm_resume+0x36c/0x49c
      __pm_runtime_resume+0x80/0xb0
      dpu_core_irq_uninstall+0x30/0xb0
      dpu_irq_uninstall+0x18/0x24
      msm_drm_uninit+0xd8/0x16c
    
    Fixes: 25fdd5933e4c ("drm/msm: Add SDM845 DPU support")
    Signed-off-by: Vinod Polimera <quic_vpolimer@quicinc.com>
    Reviewed-by: Dmitry Baryshkov <dmitry.baryshkov@linaro.org>
    Patchwork: https://patchwork.freedesktop.org/patch/483255/
    Link: https://lore.kernel.org/r/1650857213-30075-1-git-send-email-quic_vpolimer@quicinc.com
    [DB: fixed Fixes tag]
    Signed-off-by: Dmitry Baryshkov <dmitry.baryshkov@linaro.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit aa4cb188988dc6f1b3f4917d4dbc452150a5d871
Author: Vinod Polimera <quic_vpolimer@quicinc.com>
Date:   Mon Apr 25 08:56:53 2022 +0530

    drm/msm/disp/dpu1: set vbif hw config to NULL to avoid use after memory free during pm runtime resume
    
    [ Upstream commit fa5186b279ecf44b14fb435540d2065be91cb1ed ]
    
    BUG: Unable to handle kernel paging request at virtual address 006b6b6b6b6b6be3
    
    Call trace:
      dpu_vbif_init_memtypes+0x40/0xb8
      dpu_runtime_resume+0xcc/0x1c0
      pm_generic_runtime_resume+0x30/0x44
      __genpd_runtime_resume+0x68/0x7c
      genpd_runtime_resume+0x134/0x258
      __rpm_callback+0x98/0x138
      rpm_callback+0x30/0x88
      rpm_resume+0x36c/0x49c
      __pm_runtime_resume+0x80/0xb0
      dpu_core_irq_uninstall+0x30/0xb0
      dpu_irq_uninstall+0x18/0x24
      msm_drm_uninit+0xd8/0x16c
    
    Fixes: 25fdd5933e4c ("drm/msm: Add SDM845 DPU support")
    Signed-off-by: Vinod Polimera <quic_vpolimer@quicinc.com>
    Reviewed-by: Dmitry Baryshkov <dmitry.baryshkov@linaro.org>
    Patchwork: https://patchwork.freedesktop.org/patch/483255/
    Link: https://lore.kernel.org/r/1650857213-30075-1-git-send-email-quic_vpolimer@quicinc.com
    [DB: fixed Fixes tag]
    Signed-off-by: Dmitry Baryshkov <dmitry.baryshkov@linaro.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 5b0adf5cbf3b74721e4e4c4e0cadc91b8df8bcc2
Author: Vinod Polimera <quic_vpolimer@quicinc.com>
Date:   Mon Apr 25 08:56:53 2022 +0530

    drm/msm/disp/dpu1: set vbif hw config to NULL to avoid use after memory free during pm runtime resume
    
    [ Upstream commit fa5186b279ecf44b14fb435540d2065be91cb1ed ]
    
    BUG: Unable to handle kernel paging request at virtual address 006b6b6b6b6b6be3
    
    Call trace:
      dpu_vbif_init_memtypes+0x40/0xb8
      dpu_runtime_resume+0xcc/0x1c0
      pm_generic_runtime_resume+0x30/0x44
      __genpd_runtime_resume+0x68/0x7c
      genpd_runtime_resume+0x134/0x258
      __rpm_callback+0x98/0x138
      rpm_callback+0x30/0x88
      rpm_resume+0x36c/0x49c
      __pm_runtime_resume+0x80/0xb0
      dpu_core_irq_uninstall+0x30/0xb0
      dpu_irq_uninstall+0x18/0x24
      msm_drm_uninit+0xd8/0x16c
    
    Fixes: 25fdd5933e4c ("drm/msm: Add SDM845 DPU support")
    Signed-off-by: Vinod Polimera <quic_vpolimer@quicinc.com>
    Reviewed-by: Dmitry Baryshkov <dmitry.baryshkov@linaro.org>
    Patchwork: https://patchwork.freedesktop.org/patch/483255/
    Link: https://lore.kernel.org/r/1650857213-30075-1-git-send-email-quic_vpolimer@quicinc.com
    [DB: fixed Fixes tag]
    Signed-off-by: Dmitry Baryshkov <dmitry.baryshkov@linaro.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 97ac682b6f7d36be5d934f86c9911066540a68f1
Author: Vinod Polimera <quic_vpolimer@quicinc.com>
Date:   Mon Apr 25 08:56:53 2022 +0530

    drm/msm/disp/dpu1: set vbif hw config to NULL to avoid use after memory free during pm runtime resume
    
    [ Upstream commit fa5186b279ecf44b14fb435540d2065be91cb1ed ]
    
    BUG: Unable to handle kernel paging request at virtual address 006b6b6b6b6b6be3
    
    Call trace:
      dpu_vbif_init_memtypes+0x40/0xb8
      dpu_runtime_resume+0xcc/0x1c0
      pm_generic_runtime_resume+0x30/0x44
      __genpd_runtime_resume+0x68/0x7c
      genpd_runtime_resume+0x134/0x258
      __rpm_callback+0x98/0x138
      rpm_callback+0x30/0x88
      rpm_resume+0x36c/0x49c
      __pm_runtime_resume+0x80/0xb0
      dpu_core_irq_uninstall+0x30/0xb0
      dpu_irq_uninstall+0x18/0x24
      msm_drm_uninit+0xd8/0x16c
    
    Fixes: 25fdd5933e4c ("drm/msm: Add SDM845 DPU support")
    Signed-off-by: Vinod Polimera <quic_vpolimer@quicinc.com>
    Reviewed-by: Dmitry Baryshkov <dmitry.baryshkov@linaro.org>
    Patchwork: https://patchwork.freedesktop.org/patch/483255/
    Link: https://lore.kernel.org/r/1650857213-30075-1-git-send-email-quic_vpolimer@quicinc.com
    [DB: fixed Fixes tag]
    Signed-off-by: Dmitry Baryshkov <dmitry.baryshkov@linaro.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit ef4bdaac7cb5416f236613ed9337ff0ea8ee329b
Author: Vinod Polimera <quic_vpolimer@quicinc.com>
Date:   Mon Apr 25 08:56:53 2022 +0530

    drm/msm/disp/dpu1: set vbif hw config to NULL to avoid use after memory free during pm runtime resume
    
    [ Upstream commit fa5186b279ecf44b14fb435540d2065be91cb1ed ]
    
    BUG: Unable to handle kernel paging request at virtual address 006b6b6b6b6b6be3
    
    Call trace:
      dpu_vbif_init_memtypes+0x40/0xb8
      dpu_runtime_resume+0xcc/0x1c0
      pm_generic_runtime_resume+0x30/0x44
      __genpd_runtime_resume+0x68/0x7c
      genpd_runtime_resume+0x134/0x258
      __rpm_callback+0x98/0x138
      rpm_callback+0x30/0x88
      rpm_resume+0x36c/0x49c
      __pm_runtime_resume+0x80/0xb0
      dpu_core_irq_uninstall+0x30/0xb0
      dpu_irq_uninstall+0x18/0x24
      msm_drm_uninit+0xd8/0x16c
    
    Fixes: 25fdd5933e4c ("drm/msm: Add SDM845 DPU support")
    Signed-off-by: Vinod Polimera <quic_vpolimer@quicinc.com>
    Reviewed-by: Dmitry Baryshkov <dmitry.baryshkov@linaro.org>
    Patchwork: https://patchwork.freedesktop.org/patch/483255/
    Link: https://lore.kernel.org/r/1650857213-30075-1-git-send-email-quic_vpolimer@quicinc.com
    [DB: fixed Fixes tag]
    Signed-off-by: Dmitry Baryshkov <dmitry.baryshkov@linaro.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 134760263f6441741db0b2970e7face6b34b6d1c
Author: Vinod Polimera <quic_vpolimer@quicinc.com>
Date:   Mon Apr 25 08:56:53 2022 +0530

    drm/msm/disp/dpu1: set vbif hw config to NULL to avoid use after memory free during pm runtime resume
    
    [ Upstream commit fa5186b279ecf44b14fb435540d2065be91cb1ed ]
    
    BUG: Unable to handle kernel paging request at virtual address 006b6b6b6b6b6be3
    
    Call trace:
      dpu_vbif_init_memtypes+0x40/0xb8
      dpu_runtime_resume+0xcc/0x1c0
      pm_generic_runtime_resume+0x30/0x44
      __genpd_runtime_resume+0x68/0x7c
      genpd_runtime_resume+0x134/0x258
      __rpm_callback+0x98/0x138
      rpm_callback+0x30/0x88
      rpm_resume+0x36c/0x49c
      __pm_runtime_resume+0x80/0xb0
      dpu_core_irq_uninstall+0x30/0xb0
      dpu_irq_uninstall+0x18/0x24
      msm_drm_uninit+0xd8/0x16c
    
    Fixes: 25fdd5933e4c ("drm/msm: Add SDM845 DPU support")
    Signed-off-by: Vinod Polimera <quic_vpolimer@quicinc.com>
    Reviewed-by: Dmitry Baryshkov <dmitry.baryshkov@linaro.org>
    Patchwork: https://patchwork.freedesktop.org/patch/483255/
    Link: https://lore.kernel.org/r/1650857213-30075-1-git-send-email-quic_vpolimer@quicinc.com
    [DB: fixed Fixes tag]
    Signed-off-by: Dmitry Baryshkov <dmitry.baryshkov@linaro.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit b8042ff4faa59ed3608beeeddc5d87ce55c62a98
Merge: bf23729c7a5f b9364eed9232
Author: Dave Airlie <airlied@redhat.com>
Date:   Fri Jun 3 11:19:11 2022 +1000

    Merge tag 'msm-next-5.19-fixes-06-01' of https://gitlab.freedesktop.org/abhinavk/msm into drm-next
    
    5.19 fixes for msm-next
    
    - Fix to add minimum ICC vote in the msm_mdss pm_resume path to address
       bootup splats
    - Fix to avoid dereferencing without checking in WB encoder
    - Fix to avoid crash during suspend in DP driver by ensuring interrupt
       mask bits are updated
    - Remove unused code from dpu_encoder_virt_atomic_check()
    - Fix to remove redundant init of dsc variable
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    
    From: Abhinav Kumar <quic_abhinavk@quicinc.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/927b201e-a734-a29d-b9fb-b9889e1f7795@quicinc.com

commit af0f2a8cc3977e08e79a096f0c2c7a5be29b130b
Merge: 1a5409facf9c b9364eed9232
Author: Rob Clark <robdclark@chromium.org>
Date:   Wed Jun 1 17:12:50 2022 -0700

    Merge tag 'msm-next-5.19-fixes-06-01' of https://gitlab.freedesktop.org/abhinavk/msm into msm-fixes-staging
    
    5.19 fixes for msm-next
    
    - Fix to add minimum ICC vote in the msm_mdss pm_resume path to address
      bootup splats
    - Fix to avoid dereferencing without checking in WB encoder
    - Fix to avoid crash during suspend in DP driver by ensuring interrupt
      mask bits are updated
    - Remove unused code from dpu_encoder_virt_atomic_check()
    - Fix to remove redundant init of dsc variable
    
    Signed-off-by: Rob Clark <robdclark@chromium.org>

commit b9364eed9232f3d2a846f68c2307eb25c93cc2d0
Author: Douglas Anderson <dianders@chromium.org>
Date:   Tue May 31 16:01:26 2022 -0700

    drm/msm/dpu: Move min BW request and full BW disable back to mdss
    
    In commit a670ff578f1f ("drm/msm/dpu: always use mdp device to scale
    bandwidth") we fully moved interconnect stuff to the DPU driver. This
    had no change for sc7180 but _did_ have an impact for other SoCs. It
    made them match the sc7180 scheme.
    
    Unfortunately, the sc7180 scheme seems like it was a bit broken.
    Specifically the interconnect needs to be on for more than just the
    DPU driver's AXI bus. In the very least it also needs to be on for the
    DSI driver's AXI bus. This can be seen fairly easily by doing this on
    a ChromeOS sc7180-trogdor class device:
    
      set_power_policy --ac_screen_dim_delay=5 --ac_screen_off_delay=10
      sleep 10
      cd /sys/bus/platform/devices/ae94000.dsi/power
      echo on > control
    
    When you do that, you'll get a warning splat in the logs about
    "gcc_disp_hf_axi_clk status stuck at 'off'".
    
    One could argue that perhaps what I have done above is "illegal" and
    that it can't happen naturally in the system because in normal system
    usage the DPU is pretty much always on when DSI is on. That being
    said:
    * In official ChromeOS builds (admittedly a 5.4 kernel with backports)
      we have seen that splat at bootup.
    * Even though we don't use "autosuspend" for these components, we
      don't use the "put_sync" variants. Thus plausibly the DSI could stay
      "runtime enabled" past when the DPU is enabled. Techncially we
      shouldn't do that if the DPU's suspend ends up yanking our clock.
    
    Let's change things such that the "bare minimum" request for the
    interconnect happens in the mdss driver again. That means that all of
    the children can assume that the interconnect is on at the minimum
    bandwidth. We'll then let the DPU request the higher amount that it
    wants.
    
    It should be noted that this isn't as hacky of a solution as it might
    initially appear. Specifically:
    * Since MDSS and DPU individually get their own references to the
      interconnect then the framework will actually handle aggregating
      them. The two drivers are _not_ clobbering each other.
    * When the Qualcomm interconnect driver aggregates it takes the max of
      all the peaks. Thus having MDSS request a peak, as we're doing here,
      won't actually change the total interconnect bandwidth (it won't be
      added to the request for the DPU). This perhaps explains why the
      "average" requested in MDSS was historically 0 since that one
      _would_ be added in.
    
    NOTE also that in the downstream ChromeOS 5.4 and 5.15 kernels, we're
    also seeing some RPMH hangs that are addressed by this fix. These
    hangs are showing up in the field and on _some_ devices with enough
    stress testing of suspend/resume. Specifically right at suspend time
    with a stack crawl that looks like this (from chromeos-5.15 tree):
      rpmh_write_batch+0x19c/0x240
      qcom_icc_bcm_voter_commit+0x210/0x420
      qcom_icc_set+0x28/0x38
      apply_constraints+0x70/0xa4
      icc_set_bw+0x150/0x24c
      dpu_runtime_resume+0x50/0x1c4
      pm_generic_runtime_resume+0x30/0x44
      __genpd_runtime_resume+0x68/0x7c
      genpd_runtime_resume+0x12c/0x20c
      __rpm_callback+0x98/0x138
      rpm_callback+0x30/0x88
      rpm_resume+0x370/0x4a0
      __pm_runtime_resume+0x80/0xb0
      dpu_kms_enable_commit+0x24/0x30
      msm_atomic_commit_tail+0x12c/0x630
      commit_tail+0xac/0x150
      drm_atomic_helper_commit+0x114/0x11c
      drm_atomic_commit+0x68/0x78
      drm_atomic_helper_disable_all+0x158/0x1c8
      drm_atomic_helper_suspend+0xc0/0x1c0
      drm_mode_config_helper_suspend+0x2c/0x60
      msm_pm_prepare+0x2c/0x40
      pm_generic_prepare+0x30/0x44
      genpd_prepare+0x80/0xd0
      device_prepare+0x78/0x17c
      dpm_prepare+0xb0/0x384
      dpm_suspend_start+0x34/0xc0
    
    We don't completely understand all the mechanisms in play, but the
    hang seemed to come and go with random factors. It's not terribly
    surprising that the hang is gone after this patch since the line of
    code that was failing is no longer present in the kernel.
    
    Fixes: a670ff578f1f ("drm/msm/dpu: always use mdp device to scale bandwidth")
    Fixes: c33b7c0389e1 ("drm/msm/dpu: add support for clk and bw scaling for display")
    Signed-off-by: Douglas Anderson <dianders@chromium.org>
    Reviewed-by: Abhinav Kumar <quic_abhinavk@quicinc.com>
    Tested-by: Jessica Zhang <quic_jesszhan@quicinc.com> # RB3 (sdm845) and
    Reviewed-by: Stephen Boyd <swboyd@chromium.org>
    Reviewed-by: Dmitry Baryshkov <dmitry.baryshkov@linaro.org>
    Patchwork: https://patchwork.freedesktop.org/patch/487884/
    Link: https://lore.kernel.org/r/20220531160059.v2.1.Ie7f6d4bf8cce28131da31a43354727e417cae98d@changeid
    Signed-off-by: Abhinav Kumar <quic_abhinavk@quicinc.com>

commit 79f9fbe303520d2c32b70f04f2bb02cc2baaa4c3
Author: Nathan Chancellor <nathan@kernel.org>
Date:   Mon May 23 15:47:02 2022 -0700

    mailbox: qcom-ipcc: Fix -Wunused-function with CONFIG_PM_SLEEP=n
    
    When CONFIG_PM_SLEEP is not set, there is a warning that
    qcom_ipcc_pm_resume() is unused:
    
      drivers/mailbox/qcom-ipcc.c:258:12: error: 'qcom_ipcc_pm_resume' defined but not used [-Werror=unused-function]
        258 | static int qcom_ipcc_pm_resume(struct device *dev)
            |            ^~~~~~~~~~~~~~~~~~~
      cc1: all warnings being treated as errors
    
    Commit 1a3c7bb08826 ("PM: core: Add new *_PM_OPS macros, deprecate old
    ones") reworked the PM_OPS macros to avoid this problem. Use
    NOIRQ_SYSTEM_SLEEP_PM_OPS directly so that qcom_ipcc_pm_resume() always
    appears to be used to the compiler, even though it will be dead code
    eliminated in the !CONFIG_PM_SLEEP case.
    
    Fixes: c25f77899753 ("mailbox: qcom-ipcc: Log the pending interrupt during resume")
    Signed-off-by: Nathan Chancellor <nathan@kernel.org>
    Reviewed-by: Sibi Sankar <quic_sibis@quicinc.com>
    Signed-off-by: Jassi Brar <jaswinder.singh@linaro.org>

commit baa1424314f8e4bb5b266aaf9cc7fb7a9e65901b
Author: Amelie Delaunay <amelie.delaunay@foss.st.com>
Date:   Thu May 5 13:56:10 2022 +0200

    dmaengine: stm32-dma: rename pm ops before dma pause/resume introduction
    
    dmaengine framework offers device_pause and device_resume ops to pause an
    on-going transfer and resume it later.
    To avoid any misunderstanding with system sleep pm ops, rename pm ops into
    stm32_dma_pm_suspend and stm32_dma_pm_resume.
    
    Signed-off-by: Amelie Delaunay <amelie.delaunay@foss.st.com>
    Link: https://lore.kernel.org/r/20220505115611.38845-4-amelie.delaunay@foss.st.com
    Signed-off-by: Vinod Koul <vkoul@kernel.org>

commit e4cf89596c1f1e33309556699f910ced4abbaf44
Author: Biju Das <biju.das.jz@bp.renesas.com>
Date:   Fri Feb 25 17:53:16 2022 +0000

    watchdog: rzg2l_wdt: Fix 'BUG: Invalid wait context'
    
    This patch fixes the issue 'BUG: Invalid wait context' during restart()
    callback by using clk_prepare_enable() instead of pm_runtime_get_sync()
    for turning on the clocks during restart.
    
    This issue is noticed when testing with renesas_defconfig.
    
    [   42.213802] reboot: Restarting system
    [   42.217860]
    [   42.219364] =============================
    [   42.223368] [ BUG: Invalid wait context ]
    [   42.227372] 5.17.0-rc5-arm64-renesas-00002-g10393723e35e #522 Not tainted
    [   42.234153] -----------------------------
    [   42.238155] systemd-shutdow/1 is trying to lock:
    [   42.242766] ffff00000a650828 (&genpd->mlock){+.+.}-{3:3}, at: genpd_lock_mtx+0x14/0x20
    [   42.250709] other info that might help us debug this:
    [   42.255753] context-{4:4}
    [   42.258368] 2 locks held by systemd-shutdow/1:
    [   42.262806]  #0: ffff80000944e1c8 (system_transition_mutex#2){+.+.}-{3:3}, at: __do_sys_reboot+0xd0/0x250
    [   42.272388]  #1: ffff8000094c4e40 (rcu_read_lock){....}-{1:2}, at: atomic_notifier_call_chain+0x0/0x150
    [   42.281795] stack backtrace:
    [   42.284672] CPU: 0 PID: 1 Comm: systemd-shutdow Not tainted 5.17.0-rc5-arm64-renesas-00002-g10393723e35e #522
    [   42.294577] Hardware name: Renesas SMARC EVK based on r9a07g044c2 (DT)
    [   42.301096] Call trace:
    [   42.303538]  dump_backtrace+0xcc/0xd8
    [   42.307203]  show_stack+0x14/0x30
    [   42.310517]  dump_stack_lvl+0x88/0xb0
    [   42.314180]  dump_stack+0x14/0x2c
    [   42.317492]  __lock_acquire+0x1b24/0x1b50
    [   42.321502]  lock_acquire+0x120/0x3a8
    [   42.325162]  __mutex_lock+0x84/0x8f8
    [   42.328737]  mutex_lock_nested+0x30/0x58
    [   42.332658]  genpd_lock_mtx+0x14/0x20
    [   42.336319]  genpd_runtime_resume+0xc4/0x228
    [   42.340587]  __rpm_callback+0x44/0x170
    [   42.344337]  rpm_callback+0x64/0x70
    [   42.347824]  rpm_resume+0x4e0/0x6b8
    [   42.351310]  __pm_runtime_resume+0x50/0x78
    [   42.355404]  rzg2l_wdt_restart+0x28/0x68
    [   42.359329]  watchdog_restart_notifier+0x1c/0x30
    [   42.363943]  atomic_notifier_call_chain+0x94/0x150
    [   42.368732]  do_kernel_restart+0x24/0x30
    [   42.372652]  machine_restart+0x44/0x70
    [   42.376399]  kernel_restart+0x3c/0x60
    [   42.380058]  __do_sys_reboot+0x228/0x250
    [   42.383977]  __arm64_sys_reboot+0x20/0x28
    [   42.387983]  invoke_syscall+0x40/0xf8
    
    Fixes: 2cbc5cd0b55fa2 ("watchdog: Add Watchdog Timer driver for RZ/G2L")
    Signed-off-by: Biju Das <biju.das.jz@bp.renesas.com>
    Reviewed-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Reviewed-by: Guenter Roeck <linux@roeck-us.net>
    Link: https://lore.kernel.org/r/20220225175320.11041-4-biju.das.jz@bp.renesas.com
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Wim Van Sebroeck <wim@linux-watchdog.org>

commit 18a94192e20de31e7e495d7c805c8930c42e99ef
Author: Krzysztof Kozlowski <krzysztof.kozlowski@linaro.org>
Date:   Wed Apr 20 16:11:35 2022 +0200

    PCI/PM: Define pci_restore_standard_config() only for CONFIG_PM_SLEEP
    
    pci_restore_standard_config() was defined under CONFIG_PM but called only
    by pci_pm_resume() (defined under CONFIG_SUSPEND) and pci_pm_restore()
    (defined under CONFIG_HIBERNATE_CALLBACKS).  A configuration with only
    CONFIG_PM leads to a warning:
    
      drivers/pci/pci-driver.c:533:12: error: pci_restore_standard_config defined but not used [-Werror=unused-function]
    
    CONFIG_PM_SLEEP depends on CONFIG_SUSPEND and CONFIG_HIBERNATE_CALLBACKS,
    so define pci_restore_standard_config() under that instead.
    
    Link: https://lore.kernel.org/r/20220420141135.444820-1-krzysztof.kozlowski@linaro.org
    Signed-off-by: Krzysztof Kozlowski <krzysztof.kozlowski@linaro.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

commit fa5186b279ecf44b14fb435540d2065be91cb1ed
Author: Vinod Polimera <quic_vpolimer@quicinc.com>
Date:   Mon Apr 25 08:56:53 2022 +0530

    drm/msm/disp/dpu1: set vbif hw config to NULL to avoid use after memory free during pm runtime resume
    
    BUG: Unable to handle kernel paging request at virtual address 006b6b6b6b6b6be3
    
    Call trace:
      dpu_vbif_init_memtypes+0x40/0xb8
      dpu_runtime_resume+0xcc/0x1c0
      pm_generic_runtime_resume+0x30/0x44
      __genpd_runtime_resume+0x68/0x7c
      genpd_runtime_resume+0x134/0x258
      __rpm_callback+0x98/0x138
      rpm_callback+0x30/0x88
      rpm_resume+0x36c/0x49c
      __pm_runtime_resume+0x80/0xb0
      dpu_core_irq_uninstall+0x30/0xb0
      dpu_irq_uninstall+0x18/0x24
      msm_drm_uninit+0xd8/0x16c
    
    Fixes: 25fdd5933e4c ("drm/msm: Add SDM845 DPU support")
    Signed-off-by: Vinod Polimera <quic_vpolimer@quicinc.com>
    Reviewed-by: Dmitry Baryshkov <dmitry.baryshkov@linaro.org>
    Patchwork: https://patchwork.freedesktop.org/patch/483255/
    Link: https://lore.kernel.org/r/1650857213-30075-1-git-send-email-quic_vpolimer@quicinc.com
    [DB: fixed Fixes tag]
    Signed-off-by: Dmitry Baryshkov <dmitry.baryshkov@linaro.org>

commit ff32baa1f39b1adb519479a51e7acbcbfdd2206c
Author: Jakub Kdzioka <niedzejkob@invisiblethingslab.com>
Date:   Wed Mar 23 02:21:03 2022 +0100

    xen: don't hang when resuming PCI device
    
    If a xen domain with at least two VCPUs has a PCI device attached which
    enters the D3hot state during suspend, the kernel may hang while
    resuming, depending on the core on which an async resume task gets
    scheduled.
    
    The bug occurs because xen's do_suspend calls dpm_resume_start while
    only the timer of the boot CPU has been resumed (when xen_suspend called
    syscore_resume), before calling xen_arch_suspend to resume the timers of
    the other CPUs. This breaks pci_dev_d3_sleep.
    
    Thus this patch moves the call to xen_arch_resume before the call to
    dpm_resume_start, eliminating the hangs and restoring the stack-like
    structure of the suspend/restore procedure.
    
    Signed-off-by: Jakub Kdzioka <niedzejkob@invisiblethingslab.com>
    Reviewed-by: Juergen Gross <jgross@suse.com>
    Link: https://lore.kernel.org/r/20220323012103.2537-1-niedzejkob@invisiblethingslab.com
    Signed-off-by: Boris Ostrovsky <boris.ostrovsky@oracle.com>

commit 239071064732bc4a30308cbba11014aa1aab550a
Author: H. Nikolaus Schaller <hns@goldelico.com>
Date:   Tue Mar 8 13:56:06 2022 +0100

    partially Revert "usb: musb: Set the DT node on the child device"
    
    This reverts the omap2430 changes of
    
    commit cf081d009c44 ("usb: musb: Set the DT node on the child device")
    
    Since v5.17-rc1, musb is broken on the gta04 and openpandora devices
    (omap3530/dm3730). BeagleBone Black (am335x) seems to work.
    
    Symptoms of this bug are
    
    a) main symptom
    
    [   21.336517] using random host ethernet address
    [   21.341430] using host ethernet address: 32:70:05:18:ff:78
    [   21.341461] using self ethernet address: 46:10:3a:b3:af:d9
    [   21.358184] usb0: HOST MAC 32:70:05:18:ff:78
    [   21.376678] usb0: MAC 46:10:3a:b3:af:d9
    [   21.388305] using random self ethernet address
    [   21.393371] using random host ethernet address
    [   21.398162] g_ether gadget: Ethernet Gadget, version: Memorial Day 2008
    [   21.421081] g_ether gadget: g_ether ready
    [   21.492156] musb-hdrc musb-hdrc.1.auto: Could not enable: -22
    [   21.691345] musb-hdrc musb-hdrc.1.auto: Could not enable: -22
    [   21.803192] musb-hdrc musb-hdrc.1.auto: Could not enable: -22
    [   21.819427] musb-hdrc musb-hdrc.1.auto: Could not enable: -22
    [   22.124450] musb-hdrc musb-hdrc.1.auto: Could not enable: -22
    [   22.168518] musb-hdrc musb-hdrc.1.auto: Could not enable: -22
    [   22.179382] musb-hdrc musb-hdrc.1.auto: Could not enable: -22
    [   23.213592] musb-hdrc musb-hdrc.1.auto: pm runtime get failed in musb_gadget_queue
    [   23.221832] musb-hdrc musb-hdrc.1.auto: Could not enable: -22
    [   23.227905] musb-hdrc musb-hdrc.1.auto: Could not enable: -22
    [   23.239440] musb-hdrc musb-hdrc.1.auto: Could not enable: -22
    [   23.401000] musb-hdrc musb-hdrc.1.auto: Could not enable: -22
    [   23.407073] musb-hdrc musb-hdrc.1.auto: Could not enable: -22
    [   23.426361] musb-hdrc musb-hdrc.1.auto: Could not enable: -22
    [   23.734466] musb-hdrc musb-hdrc.1.auto: pm runtime get failed in musb_gadget_queue
    [   23.742462] musb-hdrc musb-hdrc.1.auto: pm runtime get failed in musb_gadget_queue
    [   23.750396] musb-hdrc musb-hdrc.1.auto: pm runtime get failed in musb_gadget_queue
    ... (repeats with high frequency)
    
    This stops if the USB cable is unplugged and restarts if it is plugged in again.
    
    b) also found in the log
    
    [    6.498107] ------------[ cut here ]------------
    [    6.502960] WARNING: CPU: 0 PID: 868 at arch/arm/mach-omap2/omap_hwmod.c:1885 _enable+0x50/0x234
    [    6.512207] omap_hwmod: usb_otg_hs: enabled state can only be entered from initialized, idle, or disabled state
    [    6.522766] Modules linked in: omap2430(+) bmp280_i2c bmp280 itg3200 at24 tsc2007 leds_tca6507 bma180 hmc5843_i2c hmc5843_core industrialio_triggered_buffer lis3lv02d_i2c kfifo_buf lis3lv02d phy_twl4030_usb snd_soc_omap_mcbsp snd_soc_ti_sdma musb_hdrc snd_soc_twl4030 gnss_sirf twl4030_vibra twl4030_madc twl4030_charger twl4030_pwrbutton gnss industrialio ehci_omap omapdrm drm_kms_helper syscopyarea sysfillrect sysimgblt fb_sys_fops drm drm_panel_orientation_quirks cec
    [    6.566436] CPU: 0 PID: 868 Comm: udevd Not tainted 5.16.0-rc5-letux+ #8251
    [    6.573730] Hardware name: Generic OMAP36xx (Flattened Device Tree)
    [    6.580322] [<c010ed30>] (unwind_backtrace) from [<c010a1d0>] (show_stack+0x10/0x14)
    [    6.588470] [<c010a1d0>] (show_stack) from [<c0897c14>] (dump_stack_lvl+0x40/0x4c)
    [    6.596405] [<c0897c14>] (dump_stack_lvl) from [<c0130cc4>] (__warn+0xb4/0xdc)
    [    6.604003] [<c0130cc4>] (__warn) from [<c0130d5c>] (warn_slowpath_fmt+0x70/0x9c)
    [    6.611846] [<c0130d5c>] (warn_slowpath_fmt) from [<c011f4d4>] (_enable+0x50/0x234)
    [    6.619903] [<c011f4d4>] (_enable) from [<c012081c>] (omap_hwmod_enable+0x28/0x40)
    [    6.627838] [<c012081c>] (omap_hwmod_enable) from [<c0120ff4>] (omap_device_enable+0x4c/0x78)
    [    6.636779] [<c0120ff4>] (omap_device_enable) from [<c0121030>] (_od_runtime_resume+0x10/0x3c)
    [    6.645812] [<c0121030>] (_od_runtime_resume) from [<c05c688c>] (__rpm_callback+0x3c/0xf4)
    [    6.654510] [<c05c688c>] (__rpm_callback) from [<c05c6994>] (rpm_callback+0x50/0x54)
    [    6.662628] [<c05c6994>] (rpm_callback) from [<c05c66b0>] (rpm_resume+0x448/0x4e4)
    [    6.670593] [<c05c66b0>] (rpm_resume) from [<c05c6784>] (__pm_runtime_resume+0x38/0x50)
    [    6.678985] [<c05c6784>] (__pm_runtime_resume) from [<bf14ab20>] (musb_init_controller+0x350/0xa5c [musb_hdrc])
    [    6.689727] [<bf14ab20>] (musb_init_controller [musb_hdrc]) from [<c05bccb8>] (platform_probe+0x58/0xa8)
    [    6.699737] [<c05bccb8>] (platform_probe) from [<c05badf0>] (really_probe+0x170/0x2fc)
    [    6.708068] [<c05badf0>] (really_probe) from [<c05bb040>] (__driver_probe_device+0xc4/0xd8)
    [    6.716827] [<c05bb040>] (__driver_probe_device) from [<c05bb084>] (driver_probe_device+0x30/0xac)
    [    6.726226] [<c05bb084>] (driver_probe_device) from [<c05bb3d0>] (__device_attach_driver+0x94/0xb4)
    [    6.735717] [<c05bb3d0>] (__device_attach_driver) from [<c05b93f8>] (bus_for_each_drv+0xa0/0xb4)
    [    6.744934] [<c05b93f8>] (bus_for_each_drv) from [<c05bb248>] (__device_attach+0xc0/0x134)
    [    6.753631] [<c05bb248>] (__device_attach) from [<c05b9fcc>] (bus_probe_device+0x28/0x80)
    [    6.762207] [<c05b9fcc>] (bus_probe_device) from [<c05b7e40>] (device_add+0x5fc/0x788)
    [    6.770507] [<c05b7e40>] (device_add) from [<c05bd240>] (platform_device_add+0x70/0x1bc)
    [    6.779022] [<c05bd240>] (platform_device_add) from [<bf177830>] (omap2430_probe+0x260/0x2d4 [omap2430])
    [    6.789001] [<bf177830>] (omap2430_probe [omap2430]) from [<c05bccb8>] (platform_probe+0x58/0xa8)
    [    6.798309] [<c05bccb8>] (platform_probe) from [<c05badf0>] (really_probe+0x170/0x2fc)
    [    6.806610] [<c05badf0>] (really_probe) from [<c05bb040>] (__driver_probe_device+0xc4/0xd8)
    [    6.815399] [<c05bb040>] (__driver_probe_device) from [<c05bb084>] (driver_probe_device+0x30/0xac)
    [    6.824798] [<c05bb084>] (driver_probe_device) from [<c05bb4b4>] (__driver_attach+0xc4/0xd8)
    [    6.833648] [<c05bb4b4>] (__driver_attach) from [<c05b9308>] (bus_for_each_dev+0x64/0xa0)
    [    6.842224] [<c05b9308>] (bus_for_each_dev) from [<c05ba248>] (bus_add_driver+0x148/0x1a4)
    [    6.850891] [<c05ba248>] (bus_add_driver) from [<c05bbd1c>] (driver_register+0xb4/0xf8)
    [    6.859313] [<c05bbd1c>] (driver_register) from [<c0101f54>] (do_one_initcall+0x90/0x1c8)
    [    6.867889] [<c0101f54>] (do_one_initcall) from [<c0893968>] (do_init_module+0x4c/0x204)
    [    6.876373] [<c0893968>] (do_init_module) from [<c01b4c30>] (load_module+0x13f0/0x1928)
    [    6.884796] [<c01b4c30>] (load_module) from [<c01b53a0>] (sys_finit_module+0xa0/0xc0)
    [    6.893005] [<c01b53a0>] (sys_finit_module) from [<c0100080>] (ret_fast_syscall+0x0/0x54)
    [    6.901580] Exception stack(0xc2807fa8 to 0xc2807ff0)
    [    6.906890] 7fa0:                   b6e517d4 00052068 00000006 b6e509f8 00000000 b6e5131c
    [    6.915466] 7fc0: b6e517d4 00052068 cd718000 0000017b 00020000 00037f78 00050048 00063368
    [    6.924011] 7fe0: bed8fef0 bed8fee0 b6e4ac4b b6f55a42
    [    6.929321] ---[ end trace d715ff121b58763c ]---
    
    c) git bisect result on testing for "musb-hdrc" in the console log:
    
    cf081d009c447647c6b36aced535ca427dbebe72 is the first bad commit
    commit cf081d009c447647c6b36aced535ca427dbebe72
    Author: Rob Herring <robh@kernel.org>
    Date:   Wed Dec 15 17:07:57 2021 -0600
    
      usb: musb: Set the DT node on the child device
    
      The musb glue drivers just copy the glue resources to the musb child device.
      Instead, set the musb child device's DT node pointer to the parent device's
      node so that platform_get_irq_byname() can find the resources in the DT.
      This removes the need for statically populating the IRQ resources from the
      DT which has been deprecated for some time.
    
      Signed-off-by: Rob Herring <robh@kernel.org>
      Link: https://lore.kernel.org/r/20211215230756.2009115-3-robh@kernel.org
      Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    
    drivers/usb/musb/am35x.c    | 2 ++
    drivers/usb/musb/da8xx.c    | 2 ++
    drivers/usb/musb/jz4740.c   | 1 +
    drivers/usb/musb/mediatek.c | 2 ++
    drivers/usb/musb/omap2430.c | 1 +
    drivers/usb/musb/ux500.c    | 1 +
    6 files changed, 9 insertions(+)
    
    Reverting this patch makes musb work again as before.
    
    Fixes: cf081d009c44 ("usb: musb: Set the DT node on the child device")
    Cc: Rob Herring <robh@kernel.org>
    Signed-off-by: H. Nikolaus Schaller <hns@goldelico.com>
    Link: https://lore.kernel.org/r/f62f5fc11f9ecae7e57f3fd66939e051bd3b11fc.1646744166.git.hns@goldelico.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit d2cc01e1794bd13199f7568298614f1bdcea1683
Author: Matthew Auld <matthew.auld@intel.com>
Date:   Fri Feb 25 10:34:43 2022 +0000

    drm/i915: apply PM_EARLY for non-GTT mappable objects
    
    On DG2 we allow objects that are smaller than the min_page_size, under
    the premise that these are never mapped by the GTT, like with the paging
    structures. Currently the suspend-resume path will try to map such
    objects through the migration vm, which hits:
    
    [  560.529217] kernel BUG at drivers/gpu/drm/i915/gt/intel_migrate.c:431!
    [  560.536081] invalid opcode: 0000 [#1] PREEMPT SMP NOPTI
    [  560.541629] CPU: 4 PID: 2062 Comm: rtcwake Tainted: G        W         5.17.0-rc5-demarchi+ #175
    [  560.550716] Hardware name: Intel Corporation CoffeeLake Client Platform/CoffeeLake S UDIMM RVP, BIOS CNLSFWR1.R00.X220.B00.2103302221 03/30/2021
    [  560.563627] RIP: 0010:emit_pte+0x2e7/0x380 [i915]
    [  560.568665] Code: ee 02 48 89 69 04 83 c6 05 83 c0 05 39 f0 0f 4f c6 48 8b 73 08 39 d0 0f 4f c2 44 89 f2 4c 8d 4a ff 49 85 f1 0f 84 62 fe ff ff <0f> 0b 48 c7 03 00 00 00 00 4d 89 c6 8b 01 48 29 ce 48 8d 57 0c 48
    [  560.587691] RSP: 0018:ffffc9000104f8a0 EFLAGS: 00010206
    [  560.592906] RAX: 0000000000000040 RBX: ffffc9000104f908 RCX: ffffc900025114d0
    [  560.600024] RDX: 0000000000010000 RSI: 00000003f9fe2000 RDI: ffffc900025114dc
    [  560.607458] RBP: 0000000001840000 R08: ffff88810f335540 R09: 000000000000ffff
    [  560.614865] R10: 000000000000081b R11: 0000000000000001 R12: 000000000000081b
    [  560.622300] R13: 0000000000000000 R14: 0000000000010000 R15: ffff888107c3e240
    [  560.629716] FS:  00007f5b7c086580(0000) GS:ffff88846dc00000(0000) knlGS:0000000000000000
    [  560.638090] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [  560.644132] CR2: 00007f3ab0a133a8 CR3: 000000010a43e003 CR4: 00000000003706e0
    [  560.651590] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
    [  560.659002] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
    [  560.666438] Call Trace:
    [  560.668885]  <TASK>
    [  560.670983]  intel_context_migrate_copy+0x1b1/0x4c0 [i915]
    [  560.676794]  __i915_ttm_move+0x628/0x790 [i915]
    [  560.681704]  ? dma_resv_iter_next+0x8f/0xb0
    [  560.686223]  ? dma_resv_iter_first+0xe5/0x140
    [  560.690894]  ? i915_deps_add_resv+0x4b/0x110 [i915]
    [  560.696147]  ? dma_resv_reserve_shared+0x161/0x310
    [  560.701228]  i915_gem_obj_copy_ttm+0x10f/0x220 [i915]
    [  560.706650]  i915_ttm_backup+0x191/0x2f0 [i915]
    [  560.711558]  i915_gem_process_region+0x266/0x3b0 [i915]
    [  560.717153]  ? verify_cpu+0xf0/0x100
    [  560.721040]  ? pci_pm_resume_early+0x20/0x20
    [  560.725603]  i915_ttm_backup_region+0x47/0x70 [i915]
    [  560.730927]  i915_gem_backup_suspend+0x141/0x170 [i91
    
    For now let's just force the memcpy path for such objects during
    suspend-resume.
    
    Fixes: 00e27ad85bc9 ("drm/i915/migrate: add acceleration support for DG2")
    Reported-by: Lucas De Marchi <lucas.demarchi@intel.com>
    Signed-off-by: Matthew Auld <matthew.auld@intel.com>
    Cc: Thomas Hellstrm <thomas.hellstrom@linux.intel.com>
    Reviewed-by: Thomas Hellstrm <thomas.hellstrom@linux.intel.com>
    Reviewed-by: Lucas De Marchi <lucas.demarchi@intel.com>
    Signed-off-by: Lucas De Marchi <lucas.demarchi@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20220225103443.225228-1-matthew.auld@intel.com

commit b296d2f6a61a071ae3fdb16dd84cd42fb784b0f9
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Fri Dec 17 15:17:09 2021 +0100

    PCI: pciehp: Use down_read/write_nested(reset_lock) to fix lockdep errors
    
    commit 085a9f43433f30cbe8a1ade62d9d7827c3217f4d upstream.
    
    Use down_read_nested() and down_write_nested() when taking the
    ctrl->reset_lock rw-sem, passing the number of PCIe hotplug controllers in
    the path to the PCI root bus as lock subclass parameter.
    
    This fixes the following false-positive lockdep report when unplugging a
    Lenovo X1C8 from a Lenovo 2nd gen TB3 dock:
    
      pcieport 0000:06:01.0: pciehp: Slot(1): Link Down
      pcieport 0000:06:01.0: pciehp: Slot(1): Card not present
      ============================================
      WARNING: possible recursive locking detected
      5.16.0-rc2+ #621 Not tainted
      --------------------------------------------
      irq/124-pciehp/86 is trying to acquire lock:
      ffff8e5ac4299ef8 (&ctrl->reset_lock){.+.+}-{3:3}, at: pciehp_check_presence+0x23/0x80
    
      but task is already holding lock:
      ffff8e5ac4298af8 (&ctrl->reset_lock){.+.+}-{3:3}, at: pciehp_ist+0xf3/0x180
    
       other info that might help us debug this:
       Possible unsafe locking scenario:
    
             CPU0
             ----
        lock(&ctrl->reset_lock);
        lock(&ctrl->reset_lock);
    
       *** DEADLOCK ***
    
       May be due to missing lock nesting notation
    
      3 locks held by irq/124-pciehp/86:
       #0: ffff8e5ac4298af8 (&ctrl->reset_lock){.+.+}-{3:3}, at: pciehp_ist+0xf3/0x180
       #1: ffffffffa3b024e8 (pci_rescan_remove_lock){+.+.}-{3:3}, at: pciehp_unconfigure_device+0x31/0x110
       #2: ffff8e5ac1ee2248 (&dev->mutex){....}-{3:3}, at: device_release_driver+0x1c/0x40
    
      stack backtrace:
      CPU: 4 PID: 86 Comm: irq/124-pciehp Not tainted 5.16.0-rc2+ #621
      Hardware name: LENOVO 20U90SIT19/20U90SIT19, BIOS N2WET30W (1.20 ) 08/26/2021
      Call Trace:
       <TASK>
       dump_stack_lvl+0x59/0x73
       __lock_acquire.cold+0xc5/0x2c6
       lock_acquire+0xb5/0x2b0
       down_read+0x3e/0x50
       pciehp_check_presence+0x23/0x80
       pciehp_runtime_resume+0x5c/0xa0
       device_for_each_child+0x45/0x70
       pcie_port_device_runtime_resume+0x20/0x30
       pci_pm_runtime_resume+0xa7/0xc0
       __rpm_callback+0x41/0x110
       rpm_callback+0x59/0x70
       rpm_resume+0x512/0x7b0
       __pm_runtime_resume+0x4a/0x90
       __device_release_driver+0x28/0x240
       device_release_driver+0x26/0x40
       pci_stop_bus_device+0x68/0x90
       pci_stop_bus_device+0x2c/0x90
       pci_stop_and_remove_bus_device+0xe/0x20
       pciehp_unconfigure_device+0x6c/0x110
       pciehp_disable_slot+0x5b/0xe0
       pciehp_handle_presence_or_link_change+0xc3/0x2f0
       pciehp_ist+0x179/0x180
    
    This lockdep warning is triggered because with Thunderbolt, hotplug ports
    are nested. When removing multiple devices in a daisy-chain, each hotplug
    port's reset_lock may be acquired recursively. It's never the same lock, so
    the lockdep splat is a false positive.
    
    Because locks at the same hierarchy level are never acquired recursively, a
    per-level lockdep class is sufficient to fix the lockdep warning.
    
    The choice to use one lockdep subclass per pcie-hotplug controller in the
    path to the root-bus was made to conserve class keys because their number
    is limited and the complexity grows quadratically with number of keys
    according to Documentation/locking/lockdep-design.rst.
    
    Link: https://lore.kernel.org/linux-pci/20190402021933.GA2966@mit.edu/
    Link: https://lore.kernel.org/linux-pci/de684a28-9038-8fc6-27ca-3f6f2f6400d7@redhat.com/
    Link: https://lore.kernel.org/r/20211217141709.379663-1-hdegoede@redhat.com
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=208855
    Reported-by: "Theodore Ts'o" <tytso@mit.edu>
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Lukas Wunner <lukas@wunner.de>
    Cc: stable@vger.kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit c2451a37174cf3d701f4b0345efbe28179202820
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Fri Dec 17 15:17:09 2021 +0100

    PCI: pciehp: Use down_read/write_nested(reset_lock) to fix lockdep errors
    
    commit 085a9f43433f30cbe8a1ade62d9d7827c3217f4d upstream.
    
    Use down_read_nested() and down_write_nested() when taking the
    ctrl->reset_lock rw-sem, passing the number of PCIe hotplug controllers in
    the path to the PCI root bus as lock subclass parameter.
    
    This fixes the following false-positive lockdep report when unplugging a
    Lenovo X1C8 from a Lenovo 2nd gen TB3 dock:
    
      pcieport 0000:06:01.0: pciehp: Slot(1): Link Down
      pcieport 0000:06:01.0: pciehp: Slot(1): Card not present
      ============================================
      WARNING: possible recursive locking detected
      5.16.0-rc2+ #621 Not tainted
      --------------------------------------------
      irq/124-pciehp/86 is trying to acquire lock:
      ffff8e5ac4299ef8 (&ctrl->reset_lock){.+.+}-{3:3}, at: pciehp_check_presence+0x23/0x80
    
      but task is already holding lock:
      ffff8e5ac4298af8 (&ctrl->reset_lock){.+.+}-{3:3}, at: pciehp_ist+0xf3/0x180
    
       other info that might help us debug this:
       Possible unsafe locking scenario:
    
             CPU0
             ----
        lock(&ctrl->reset_lock);
        lock(&ctrl->reset_lock);
    
       *** DEADLOCK ***
    
       May be due to missing lock nesting notation
    
      3 locks held by irq/124-pciehp/86:
       #0: ffff8e5ac4298af8 (&ctrl->reset_lock){.+.+}-{3:3}, at: pciehp_ist+0xf3/0x180
       #1: ffffffffa3b024e8 (pci_rescan_remove_lock){+.+.}-{3:3}, at: pciehp_unconfigure_device+0x31/0x110
       #2: ffff8e5ac1ee2248 (&dev->mutex){....}-{3:3}, at: device_release_driver+0x1c/0x40
    
      stack backtrace:
      CPU: 4 PID: 86 Comm: irq/124-pciehp Not tainted 5.16.0-rc2+ #621
      Hardware name: LENOVO 20U90SIT19/20U90SIT19, BIOS N2WET30W (1.20 ) 08/26/2021
      Call Trace:
       <TASK>
       dump_stack_lvl+0x59/0x73
       __lock_acquire.cold+0xc5/0x2c6
       lock_acquire+0xb5/0x2b0
       down_read+0x3e/0x50
       pciehp_check_presence+0x23/0x80
       pciehp_runtime_resume+0x5c/0xa0
       device_for_each_child+0x45/0x70
       pcie_port_device_runtime_resume+0x20/0x30
       pci_pm_runtime_resume+0xa7/0xc0
       __rpm_callback+0x41/0x110
       rpm_callback+0x59/0x70
       rpm_resume+0x512/0x7b0
       __pm_runtime_resume+0x4a/0x90
       __device_release_driver+0x28/0x240
       device_release_driver+0x26/0x40
       pci_stop_bus_device+0x68/0x90
       pci_stop_bus_device+0x2c/0x90
       pci_stop_and_remove_bus_device+0xe/0x20
       pciehp_unconfigure_device+0x6c/0x110
       pciehp_disable_slot+0x5b/0xe0
       pciehp_handle_presence_or_link_change+0xc3/0x2f0
       pciehp_ist+0x179/0x180
    
    This lockdep warning is triggered because with Thunderbolt, hotplug ports
    are nested. When removing multiple devices in a daisy-chain, each hotplug
    port's reset_lock may be acquired recursively. It's never the same lock, so
    the lockdep splat is a false positive.
    
    Because locks at the same hierarchy level are never acquired recursively, a
    per-level lockdep class is sufficient to fix the lockdep warning.
    
    The choice to use one lockdep subclass per pcie-hotplug controller in the
    path to the root-bus was made to conserve class keys because their number
    is limited and the complexity grows quadratically with number of keys
    according to Documentation/locking/lockdep-design.rst.
    
    Link: https://lore.kernel.org/linux-pci/20190402021933.GA2966@mit.edu/
    Link: https://lore.kernel.org/linux-pci/de684a28-9038-8fc6-27ca-3f6f2f6400d7@redhat.com/
    Link: https://lore.kernel.org/r/20211217141709.379663-1-hdegoede@redhat.com
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=208855
    Reported-by: "Theodore Ts'o" <tytso@mit.edu>
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Lukas Wunner <lukas@wunner.de>
    Cc: stable@vger.kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit def2825b09ece8c8b6e2514c8f785073bf3a864e
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Fri Dec 17 15:17:09 2021 +0100

    PCI: pciehp: Use down_read/write_nested(reset_lock) to fix lockdep errors
    
    commit 085a9f43433f30cbe8a1ade62d9d7827c3217f4d upstream.
    
    Use down_read_nested() and down_write_nested() when taking the
    ctrl->reset_lock rw-sem, passing the number of PCIe hotplug controllers in
    the path to the PCI root bus as lock subclass parameter.
    
    This fixes the following false-positive lockdep report when unplugging a
    Lenovo X1C8 from a Lenovo 2nd gen TB3 dock:
    
      pcieport 0000:06:01.0: pciehp: Slot(1): Link Down
      pcieport 0000:06:01.0: pciehp: Slot(1): Card not present
      ============================================
      WARNING: possible recursive locking detected
      5.16.0-rc2+ #621 Not tainted
      --------------------------------------------
      irq/124-pciehp/86 is trying to acquire lock:
      ffff8e5ac4299ef8 (&ctrl->reset_lock){.+.+}-{3:3}, at: pciehp_check_presence+0x23/0x80
    
      but task is already holding lock:
      ffff8e5ac4298af8 (&ctrl->reset_lock){.+.+}-{3:3}, at: pciehp_ist+0xf3/0x180
    
       other info that might help us debug this:
       Possible unsafe locking scenario:
    
             CPU0
             ----
        lock(&ctrl->reset_lock);
        lock(&ctrl->reset_lock);
    
       *** DEADLOCK ***
    
       May be due to missing lock nesting notation
    
      3 locks held by irq/124-pciehp/86:
       #0: ffff8e5ac4298af8 (&ctrl->reset_lock){.+.+}-{3:3}, at: pciehp_ist+0xf3/0x180
       #1: ffffffffa3b024e8 (pci_rescan_remove_lock){+.+.}-{3:3}, at: pciehp_unconfigure_device+0x31/0x110
       #2: ffff8e5ac1ee2248 (&dev->mutex){....}-{3:3}, at: device_release_driver+0x1c/0x40
    
      stack backtrace:
      CPU: 4 PID: 86 Comm: irq/124-pciehp Not tainted 5.16.0-rc2+ #621
      Hardware name: LENOVO 20U90SIT19/20U90SIT19, BIOS N2WET30W (1.20 ) 08/26/2021
      Call Trace:
       <TASK>
       dump_stack_lvl+0x59/0x73
       __lock_acquire.cold+0xc5/0x2c6
       lock_acquire+0xb5/0x2b0
       down_read+0x3e/0x50
       pciehp_check_presence+0x23/0x80
       pciehp_runtime_resume+0x5c/0xa0
       device_for_each_child+0x45/0x70
       pcie_port_device_runtime_resume+0x20/0x30
       pci_pm_runtime_resume+0xa7/0xc0
       __rpm_callback+0x41/0x110
       rpm_callback+0x59/0x70
       rpm_resume+0x512/0x7b0
       __pm_runtime_resume+0x4a/0x90
       __device_release_driver+0x28/0x240
       device_release_driver+0x26/0x40
       pci_stop_bus_device+0x68/0x90
       pci_stop_bus_device+0x2c/0x90
       pci_stop_and_remove_bus_device+0xe/0x20
       pciehp_unconfigure_device+0x6c/0x110
       pciehp_disable_slot+0x5b/0xe0
       pciehp_handle_presence_or_link_change+0xc3/0x2f0
       pciehp_ist+0x179/0x180
    
    This lockdep warning is triggered because with Thunderbolt, hotplug ports
    are nested. When removing multiple devices in a daisy-chain, each hotplug
    port's reset_lock may be acquired recursively. It's never the same lock, so
    the lockdep splat is a false positive.
    
    Because locks at the same hierarchy level are never acquired recursively, a
    per-level lockdep class is sufficient to fix the lockdep warning.
    
    The choice to use one lockdep subclass per pcie-hotplug controller in the
    path to the root-bus was made to conserve class keys because their number
    is limited and the complexity grows quadratically with number of keys
    according to Documentation/locking/lockdep-design.rst.
    
    Link: https://lore.kernel.org/linux-pci/20190402021933.GA2966@mit.edu/
    Link: https://lore.kernel.org/linux-pci/de684a28-9038-8fc6-27ca-3f6f2f6400d7@redhat.com/
    Link: https://lore.kernel.org/r/20211217141709.379663-1-hdegoede@redhat.com
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=208855
    Reported-by: "Theodore Ts'o" <tytso@mit.edu>
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Lukas Wunner <lukas@wunner.de>
    Cc: stable@vger.kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 085a9f43433f30cbe8a1ade62d9d7827c3217f4d
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Fri Dec 17 15:17:09 2021 +0100

    PCI: pciehp: Use down_read/write_nested(reset_lock) to fix lockdep errors
    
    Use down_read_nested() and down_write_nested() when taking the
    ctrl->reset_lock rw-sem, passing the number of PCIe hotplug controllers in
    the path to the PCI root bus as lock subclass parameter.
    
    This fixes the following false-positive lockdep report when unplugging a
    Lenovo X1C8 from a Lenovo 2nd gen TB3 dock:
    
      pcieport 0000:06:01.0: pciehp: Slot(1): Link Down
      pcieport 0000:06:01.0: pciehp: Slot(1): Card not present
      ============================================
      WARNING: possible recursive locking detected
      5.16.0-rc2+ #621 Not tainted
      --------------------------------------------
      irq/124-pciehp/86 is trying to acquire lock:
      ffff8e5ac4299ef8 (&ctrl->reset_lock){.+.+}-{3:3}, at: pciehp_check_presence+0x23/0x80
    
      but task is already holding lock:
      ffff8e5ac4298af8 (&ctrl->reset_lock){.+.+}-{3:3}, at: pciehp_ist+0xf3/0x180
    
       other info that might help us debug this:
       Possible unsafe locking scenario:
    
             CPU0
             ----
        lock(&ctrl->reset_lock);
        lock(&ctrl->reset_lock);
    
       *** DEADLOCK ***
    
       May be due to missing lock nesting notation
    
      3 locks held by irq/124-pciehp/86:
       #0: ffff8e5ac4298af8 (&ctrl->reset_lock){.+.+}-{3:3}, at: pciehp_ist+0xf3/0x180
       #1: ffffffffa3b024e8 (pci_rescan_remove_lock){+.+.}-{3:3}, at: pciehp_unconfigure_device+0x31/0x110
       #2: ffff8e5ac1ee2248 (&dev->mutex){....}-{3:3}, at: device_release_driver+0x1c/0x40
    
      stack backtrace:
      CPU: 4 PID: 86 Comm: irq/124-pciehp Not tainted 5.16.0-rc2+ #621
      Hardware name: LENOVO 20U90SIT19/20U90SIT19, BIOS N2WET30W (1.20 ) 08/26/2021
      Call Trace:
       <TASK>
       dump_stack_lvl+0x59/0x73
       __lock_acquire.cold+0xc5/0x2c6
       lock_acquire+0xb5/0x2b0
       down_read+0x3e/0x50
       pciehp_check_presence+0x23/0x80
       pciehp_runtime_resume+0x5c/0xa0
       device_for_each_child+0x45/0x70
       pcie_port_device_runtime_resume+0x20/0x30
       pci_pm_runtime_resume+0xa7/0xc0
       __rpm_callback+0x41/0x110
       rpm_callback+0x59/0x70
       rpm_resume+0x512/0x7b0
       __pm_runtime_resume+0x4a/0x90
       __device_release_driver+0x28/0x240
       device_release_driver+0x26/0x40
       pci_stop_bus_device+0x68/0x90
       pci_stop_bus_device+0x2c/0x90
       pci_stop_and_remove_bus_device+0xe/0x20
       pciehp_unconfigure_device+0x6c/0x110
       pciehp_disable_slot+0x5b/0xe0
       pciehp_handle_presence_or_link_change+0xc3/0x2f0
       pciehp_ist+0x179/0x180
    
    This lockdep warning is triggered because with Thunderbolt, hotplug ports
    are nested. When removing multiple devices in a daisy-chain, each hotplug
    port's reset_lock may be acquired recursively. It's never the same lock, so
    the lockdep splat is a false positive.
    
    Because locks at the same hierarchy level are never acquired recursively, a
    per-level lockdep class is sufficient to fix the lockdep warning.
    
    The choice to use one lockdep subclass per pcie-hotplug controller in the
    path to the root-bus was made to conserve class keys because their number
    is limited and the complexity grows quadratically with number of keys
    according to Documentation/locking/lockdep-design.rst.
    
    Link: https://lore.kernel.org/linux-pci/20190402021933.GA2966@mit.edu/
    Link: https://lore.kernel.org/linux-pci/de684a28-9038-8fc6-27ca-3f6f2f6400d7@redhat.com/
    Link: https://lore.kernel.org/r/20211217141709.379663-1-hdegoede@redhat.com
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=208855
    Reported-by: "Theodore Ts'o" <tytso@mit.edu>
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Lukas Wunner <lukas@wunner.de>
    Cc: stable@vger.kernel.org

commit 97fd2b6c0340ad06872feda449bf6168ee56a35a
Author: chen gong <curry.gong@amd.com>
Date:   Thu Dec 9 19:47:10 2021 +0800

    drm/amdgpu: When the VCN(1.0) block is suspended, powergating is explicitly enabled
    
    commit b7865173cf6ae59942e2c69326a06e1c1df5ecf6 upstream.
    
    Play a video on the raven (or PCO, raven2) platform, and then do the S3
    test. When resume, the following error will be reported:
    
    amdgpu 0000:02:00.0: [drm:amdgpu_ring_test_helper [amdgpu]] *ERROR* ring
    vcn_dec test failed (-110)
    [drm:amdgpu_device_ip_resume_phase2 [amdgpu]] *ERROR* resume of IP block
    <vcn_v1_0> failed -110
    amdgpu 0000:02:00.0: amdgpu: amdgpu_device_ip_resume failed (-110).
    PM: dpm_run_callback(): pci_pm_resume+0x0/0x90 returns -110
    
    [why]
    When playing the video: The power state flag of the vcn block is set to
    POWER_STATE_ON.
    
    When doing suspend: There is no change to the power state flag of the
    vcn block, it is still POWER_STATE_ON.
    
    When doing resume: Need to open the power gate of the vcn block and set
    the power state flag of the VCN block to POWER_STATE_ON.
    But at this time, the power state flag of the vcn block is already
    POWER_STATE_ON. The power status flag check in the "8f2cdef drm/amd/pm:
    avoid duplicate powergate/ungate setting" patch will return the
    amdgpu_dpm_set_powergating_by_smu function directly.
    As a result, the gate of the power was not opened, causing the
    subsequent ring test to fail.
    
    [how]
    In the suspend function of the vcn block, explicitly change the power
    state flag of the vcn block to POWER_STATE_OFF.
    
    BugLink: https://gitlab.freedesktop.org/drm/amd/-/issues/1828
    Signed-off-by: chen gong <curry.gong@amd.com>
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 28863ffe21ff711d5109e3c208676258bdec3a1f
Author: chen gong <curry.gong@amd.com>
Date:   Thu Dec 9 19:47:10 2021 +0800

    drm/amdgpu: When the VCN(1.0) block is suspended, powergating is explicitly enabled
    
    commit b7865173cf6ae59942e2c69326a06e1c1df5ecf6 upstream.
    
    Play a video on the raven (or PCO, raven2) platform, and then do the S3
    test. When resume, the following error will be reported:
    
    amdgpu 0000:02:00.0: [drm:amdgpu_ring_test_helper [amdgpu]] *ERROR* ring
    vcn_dec test failed (-110)
    [drm:amdgpu_device_ip_resume_phase2 [amdgpu]] *ERROR* resume of IP block
    <vcn_v1_0> failed -110
    amdgpu 0000:02:00.0: amdgpu: amdgpu_device_ip_resume failed (-110).
    PM: dpm_run_callback(): pci_pm_resume+0x0/0x90 returns -110
    
    [why]
    When playing the video: The power state flag of the vcn block is set to
    POWER_STATE_ON.
    
    When doing suspend: There is no change to the power state flag of the
    vcn block, it is still POWER_STATE_ON.
    
    When doing resume: Need to open the power gate of the vcn block and set
    the power state flag of the VCN block to POWER_STATE_ON.
    But at this time, the power state flag of the vcn block is already
    POWER_STATE_ON. The power status flag check in the "8f2cdef drm/amd/pm:
    avoid duplicate powergate/ungate setting" patch will return the
    amdgpu_dpm_set_powergating_by_smu function directly.
    As a result, the gate of the power was not opened, causing the
    subsequent ring test to fail.
    
    [how]
    In the suspend function of the vcn block, explicitly change the power
    state flag of the vcn block to POWER_STATE_OFF.
    
    BugLink: https://gitlab.freedesktop.org/drm/amd/-/issues/1828
    Signed-off-by: chen gong <curry.gong@amd.com>
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 8f58e29ed7fc37d3ca3e86668e63250a53f51fd7
Author: Kai-Heng Feng <kai.heng.feng@canonical.com>
Date:   Fri Dec 24 16:19:13 2021 +0800

    net: wwan: iosm: Let PCI core handle PCI power transition
    
    pci_pm_suspend_noirq() and pci_pm_resume_noirq() already handle power
    transition for system-wide suspend and resume, so it's not necessary to
    do it in the driver.
    
    Signed-off-by: Kai-Heng Feng <kai.heng.feng@canonical.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit b7865173cf6ae59942e2c69326a06e1c1df5ecf6
Author: chen gong <curry.gong@amd.com>
Date:   Thu Dec 9 19:47:10 2021 +0800

    drm/amdgpu: When the VCN(1.0) block is suspended, powergating is explicitly enabled
    
    Play a video on the raven (or PCO, raven2) platform, and then do the S3
    test. When resume, the following error will be reported:
    
    amdgpu 0000:02:00.0: [drm:amdgpu_ring_test_helper [amdgpu]] *ERROR* ring
    vcn_dec test failed (-110)
    [drm:amdgpu_device_ip_resume_phase2 [amdgpu]] *ERROR* resume of IP block
    <vcn_v1_0> failed -110
    amdgpu 0000:02:00.0: amdgpu: amdgpu_device_ip_resume failed (-110).
    PM: dpm_run_callback(): pci_pm_resume+0x0/0x90 returns -110
    
    [why]
    When playing the video: The power state flag of the vcn block is set to
    POWER_STATE_ON.
    
    When doing suspend: There is no change to the power state flag of the
    vcn block, it is still POWER_STATE_ON.
    
    When doing resume: Need to open the power gate of the vcn block and set
    the power state flag of the VCN block to POWER_STATE_ON.
    But at this time, the power state flag of the vcn block is already
    POWER_STATE_ON. The power status flag check in the "8f2cdef drm/amd/pm:
    avoid duplicate powergate/ungate setting" patch will return the
    amdgpu_dpm_set_powergating_by_smu function directly.
    As a result, the gate of the power was not opened, causing the
    subsequent ring test to fail.
    
    [how]
    In the suspend function of the vcn block, explicitly change the power
    state flag of the vcn block to POWER_STATE_OFF.
    
    BugLink: https://gitlab.freedesktop.org/drm/amd/-/issues/1828
    Signed-off-by: chen gong <curry.gong@amd.com>
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Cc: stable@vger.kernel.org

commit c24efa6732788f0be22cdf5d2aedd5e3117e983f
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Dec 7 19:54:32 2021 +0100

    PM: runtime: Capture device status before disabling runtime PM
    
    In some cases (for example, during system-wide suspend and resume of
    devices) it is useful to know whether or not runtime PM has ever been
    enabled for a given device and, if so, what the runtime PM status of
    it had been right before runtime PM was disabled for it last time.
    
    For this reason, introduce a new struct dev_pm_info field called
    last_status that will be used for capturing the runtime PM status of
    the device when its power.disable_depth counter changes from 0 to 1.
    
    The new field will be set to RPM_INVALID to start with and whenever
    power.disable_depth changes from 1 to 0, so it will be valid only
    when runtime PM of the device is currently disabled, but it has been
    enabled at least once.
    
    Immediately use power.last_status in rpm_resume() to make it handle
    the case when PM runtime is disabled for the device, but its runtime
    PM status is RPM_ACTIVE more consistently.  Namely, make it return 1
    if power.last_status is also equal to RPM_ACTIVE in that case (the
    idea being that if the status was RPM_ACTIVE last time when
    power.disable_depth was changing from 0 to 1 and it is still
    RPM_ACTIVE, it can be assumed to reflect what happened to the device
    last time when it was using runtime PM) and -EACCES otherwise.
    
    Update the documentation to provide a description of last_status and
    change the description of pm_runtime_resume() in it to reflect the
    new behavior of rpm_active().
    
    While at it, rearrange the code in pm_runtime_enable() to be more
    straightforward and replace the WARN() macro in it with a pr_warn()
    invocation which is less disruptive.
    
    Link: https://lore.kernel.org/linux-pm/20211026222626.39222-1-ulf.hansson@linaro.org/t/#u
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit d4c2933fb8eece9b2703e9ddd4aa8f1a77f22450
Author: chen gong <curry.gong@amd.com>
Date:   Thu Dec 9 19:47:10 2021 +0800

    drm/amdgpu: When the VCN(1.0) block is suspended, powergating is explicitly enabled
    
    Play a video on the raven (or PCO, raven2) platform, and then do the S3
    test. When resume, the following error will be reported:
    
    amdgpu 0000:02:00.0: [drm:amdgpu_ring_test_helper [amdgpu]] *ERROR* ring
    vcn_dec test failed (-110)
    [drm:amdgpu_device_ip_resume_phase2 [amdgpu]] *ERROR* resume of IP block
    <vcn_v1_0> failed -110
    amdgpu 0000:02:00.0: amdgpu: amdgpu_device_ip_resume failed (-110).
    PM: dpm_run_callback(): pci_pm_resume+0x0/0x90 returns -110
    
    [why]
    When playing the video: The power state flag of the vcn block is set to
    POWER_STATE_ON.
    
    When doing suspend: There is no change to the power state flag of the
    vcn block, it is still POWER_STATE_ON.
    
    When doing resume: Need to open the power gate of the vcn block and set
    the power state flag of the VCN block to POWER_STATE_ON.
    But at this time, the power state flag of the vcn block is already
    POWER_STATE_ON. The power status flag check in the "8f2cdef drm/amd/pm:
    avoid duplicate powergate/ungate setting" patch will return the
    amdgpu_dpm_set_powergating_by_smu function directly.
    As a result, the gate of the power was not opened, causing the
    subsequent ring test to fail.
    
    [how]
    In the suspend function of the vcn block, explicitly change the power
    state flag of the vcn block to POWER_STATE_OFF.
    
    BugLink: https://gitlab.freedesktop.org/drm/amd/-/issues/1828
    Signed-off-by: chen gong <curry.gong@amd.com>
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

commit 0aeddbd0cb078116c19b8ca511cc1882b581671b
Author: Vaibhav Gupta <vaibhavgupta40@gmail.com>
Date:   Tue Jan 12 13:39:24 2021 +0530

    via-agp: convert to generic power management
    
    Convert via-agp from legacy PCI power management to the generic power
    management framework.
    
    Previously, via-agp used legacy PCI power management, and agp_via_suspend()
    and agp_via_resume() were responsible for both device-specific things and
    generic PCI things:
    
      agp_via_suspend
        pci_save_state(pdev)                <-- generic PCI
        pci_set_power_state(pdev, pci_choose_state(pdev, state)) <-- generic PCI
    
      agp_via_resume
        pci_set_power_state(pdev, PCI_D0)   <-- generic PCI
        pci_restore_state(pdev)             <-- generic PCI
        via_configure_agp3()                <-- device-specific
        via_configure()                     <-- device-specific
    
    With generic power management, the PCI bus PM methods do the generic PCI
    things, and the driver needs only the device-specific part, i.e.,
    
      suspend_devices_and_enter
        dpm_suspend_start(PMSG_SUSPEND)
          pci_pm_suspend                    # PCI bus .suspend() method
            agp_via_suspend                 <-- not needed at all; removed
        suspend_enter
          dpm_suspend_noirq(PMSG_SUSPEND)
            pci_pm_suspend_noirq            # PCI bus .suspend_noirq() method
              pci_save_state                <-- generic PCI
              pci_prepare_to_sleep          <-- generic PCI
                pci_set_power_state
        ...
        dpm_resume_end(PMSG_RESUME)
          pci_pm_resume                     # PCI bus .resume() method
            pci_restore_standard_config
              pci_set_power_state(PCI_D0)   <-- generic PCI
              pci_restore_state             <-- generic PCI
            agp_via_resume                  # dev->driver->pm->resume
              via_configure_agp3()          <-- device-specific
              via_configure()               <-- device-specific
    
    [bhelgaas: commit log]
    Link: https://lore.kernel.org/r/20211208193305.147072-4-helgaas@kernel.org
    Signed-off-by: Vaibhav Gupta <vaibhavgupta40@gmail.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Dave Airlie <airlied@redhat.com>

commit 6d1adc3d46a785cdb3cb0352ec9ad6fee5bb892b
Author: Vaibhav Gupta <vaibhavgupta40@gmail.com>
Date:   Tue Jan 12 13:39:23 2021 +0530

    sis-agp: convert to generic power management
    
    Convert sis-agp from legacy PCI power management to the generic power
    management framework.
    
    Previously, sis-agp used legacy PCI power management, and agp_sis_suspend()
    and agp_sis_resume() were responsible for both device-specific things and
    generic PCI things:
    
      agp_sis_suspend
        pci_save_state(pdev)                <-- generic PCI
        pci_set_power_state(pdev, pci_choose_state(pdev, state)) <-- generic PCI
    
      agp_sis_resume
        pci_set_power_state(pdev, PCI_D0)   <-- generic PCI
        pci_restore_state(pdev)             <-- generic PCI
        sis_driver.configure()              <-- device-specific
    
    With generic power management, the PCI bus PM methods do the generic PCI
    things, and the driver needs only the device-specific part, i.e.,
    
      suspend_devices_and_enter
        dpm_suspend_start(PMSG_SUSPEND)
          pci_pm_suspend                    # PCI bus .suspend() method
            agp_sis_suspend                 <-- not needed at all; removed
        suspend_enter
          dpm_suspend_noirq(PMSG_SUSPEND)
            pci_pm_suspend_noirq            # PCI bus .suspend_noirq() method
              pci_save_state                <-- generic PCI
              pci_prepare_to_sleep          <-- generic PCI
                pci_set_power_state
        ...
        dpm_resume_end(PMSG_RESUME)
          pci_pm_resume                     # PCI bus .resume() method
            pci_restore_standard_config
              pci_set_power_state(PCI_D0)   <-- generic PCI
              pci_restore_state             <-- generic PCI
            agp_sis_resume                  # dev->driver->pm->resume
              sis_driver.configure()        <-- device-specific
    
    [bhelgaas: commit log]
    Link: https://lore.kernel.org/r/20211208193305.147072-3-helgaas@kernel.org
    Signed-off-by: Vaibhav Gupta <vaibhavgupta40@gmail.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Dave Airlie <airlied@redhat.com>

commit ec4e4a6fdc51f11eaa7a919e3e2a5f5a65532a6c
Author: Vaibhav Gupta <vaibhavgupta40@gmail.com>
Date:   Tue Jan 12 13:39:22 2021 +0530

    amd64-agp: convert to generic power management
    
    Convert amd64-agp from legacy PCI power management to the generic power
    management framework.
    
    Previously, amd64-agp used legacy PCI power management, and
    agp_amd64_suspend() and agp_amd64_resume() were responsible for both
    device-specific things and generic PCI things:
    
      agp_amd64_suspend
        pci_save_state(pdev)                <-- generic PCI
        pci_set_power_state(pdev, pci_choose_state(pdev, state)) <-- generic PCI
    
      agp_amd64_resume
        pci_set_power_state(pdev, PCI_D0)   <-- generic PCI
        pci_restore_state(pdev)             <-- generic PCI
        nforce3_agp_init()                  <-- device-specific
        amd_8151_configure()                <-- device-specific
    
    With generic power management, the PCI bus PM methods do the generic PCI
    things, and the driver needs only the device-specific part, i.e.,
    
      suspend_devices_and_enter
        dpm_suspend_start(PMSG_SUSPEND)
          pci_pm_suspend                    # PCI bus .suspend() method
            agp_amd64_suspend               <-- not needed at all; removed
        suspend_enter
          dpm_suspend_noirq(PMSG_SUSPEND)
            pci_pm_suspend_noirq            # PCI bus .suspend_noirq() method
              pci_save_state                <-- generic PCI
              pci_prepare_to_sleep          <-- generic PCI
                pci_set_power_state
        ...
        dpm_resume_end(PMSG_RESUME)
          pci_pm_resume                     # PCI bus .resume() method
            pci_restore_standard_config
              pci_set_power_state(PCI_D0)   <-- generic PCI
              pci_restore_state             <-- generic PCI
            agp_amd64_resume                # dev->driver->pm->resume
              nforce3_agp_init()            <-- device-specific
              amd_8151_configure()          <-- device-specific
    
    [bhelgaas: commit log]
    Link: https://lore.kernel.org/r/20211208193305.147072-2-helgaas@kernel.org
    Signed-off-by: Vaibhav Gupta <vaibhavgupta40@gmail.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Dave Airlie <airlied@redhat.com>

commit cd97b7e0d78009b45e08b92441d9562f9f37968c
Author: Vaibhav Gupta <vaibhavgupta40@gmail.com>
Date:   Wed Dec 8 13:24:48 2021 -0600

    mtip32xx: convert to generic power management
    
    Convert mtip32xx from legacy PCI power management to the generic power
    management framework.
    
    Previously, mtip32xx used legacy PCI power management, where
    mtip_pci_suspend() and mtip_pci_resume() were responsible for both
    device-specific things and generic PCI things:
    
      mtip_pci_suspend
        mtip_block_suspend(dd)              <-- device-specific
        pci_save_state(pdev)                <-- generic PCI
        pci_set_power_state(pdev, pci_choose_state(pdev, state))
    
      mtip_pci_resume
        pci_set_power_state(PCI_D0)         <-- generic PCI
        pci_restore_state(pdev)             <-- generic PCI
        pcim_enable_device(pdev)            <-- generic PCI
        pci_set_master(pdev)                <-- generic PCI
        mtip_block_resume(dd)               <-- device-specific
    
    With generic power management, the PCI bus PM methods do the generic PCI
    things, and the driver needs only the device-specific part, i.e.,
    
      suspend_devices_and_enter
        dpm_suspend_start(PMSG_SUSPEND)
          pci_pm_suspend                    # PCI bus .suspend() method
            mtip_pci_suspend                # dev->driver->pm->suspend
              mtip_block_suspend            <-- device-specific
        suspend_enter
          dpm_suspend_noirq(PMSG_SUSPEND)
            pci_pm_suspend_noirq            # PCI bus .suspend_noirq() method
              pci_save_state                <-- generic PCI
              pci_prepare_to_sleep          <-- generic PCI
                pci_set_power_state
        ...
        dpm_resume_end(PMSG_RESUME)
          pci_pm_resume                     # PCI bus .resume() method
            pci_restore_standard_config
              pci_set_power_state(PCI_D0)   <-- generic PCI
              pci_restore_state             <-- generic PCI
            mtip_pci_resume                 # dev->driver->pm->resume
              mtip_block_resume             <-- device-specific
    
    [bhelgaas: commit log]
    
    Link: https://lore.kernel.org/r/20210114115423.52414-2-vaibhavgupta40@gmail.com
    Signed-off-by: Vaibhav Gupta <vaibhavgupta40@gmail.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Link: https://lore.kernel.org/r/20211208192449.146076-4-helgaas@kernel.org
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

commit 47b355f25b55c98c63ed7346faa3e1613c895f7e
Author: Loic Poulain <loic.poulain@linaro.org>
Date:   Thu Dec 9 18:46:33 2021 +0530

    bus: mhi: core: Add support for forced PM resume
    
    commit cab2d3fd6866e089b5c50db09dece131f85bfebd upstream.
    
    For whatever reason, some devices like QCA6390, WCN6855 using ath11k
    are not in M3 state during PM resume, but still functional. The
    mhi_pm_resume should then not fail in those cases, and let the higher
    level device specific stack continue resuming process.
    
    Add an API mhi_pm_resume_force(), to force resuming irrespective of the
    current MHI state. This fixes a regression with non functional ath11k WiFi
    after suspend/resume cycle on some machines.
    
    Bug report: https://bugzilla.kernel.org/show_bug.cgi?id=214179
    
    Link: https://lore.kernel.org/regressions/871r5p0x2u.fsf@codeaurora.org/
    Fixes: 020d3b26c07a ("bus: mhi: Early MHI resume failure in non M3 state")
    Cc: stable@vger.kernel.org #5.13
    Reported-by: Kalle Valo <kvalo@codeaurora.org>
    Reported-by: Pengyu Ma <mapengyu@gmail.com>
    Tested-by: Kalle Valo <kvalo@kernel.org>
    Acked-by: Kalle Valo <kvalo@kernel.org>
    Signed-off-by: Loic Poulain <loic.poulain@linaro.org>
    [mani: Switched to API, added bug report, reported-by tags and CCed stable]
    Signed-off-by: Manivannan Sadhasivam <manivannan.sadhasivam@linaro.org>
    Link: https://lore.kernel.org/r/20211209131633.4168-1-manivannan.sadhasivam@linaro.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit cab2d3fd6866e089b5c50db09dece131f85bfebd
Author: Loic Poulain <loic.poulain@linaro.org>
Date:   Thu Dec 9 18:46:33 2021 +0530

    bus: mhi: core: Add support for forced PM resume
    
    For whatever reason, some devices like QCA6390, WCN6855 using ath11k
    are not in M3 state during PM resume, but still functional. The
    mhi_pm_resume should then not fail in those cases, and let the higher
    level device specific stack continue resuming process.
    
    Add an API mhi_pm_resume_force(), to force resuming irrespective of the
    current MHI state. This fixes a regression with non functional ath11k WiFi
    after suspend/resume cycle on some machines.
    
    Bug report: https://bugzilla.kernel.org/show_bug.cgi?id=214179
    
    Link: https://lore.kernel.org/regressions/871r5p0x2u.fsf@codeaurora.org/
    Fixes: 020d3b26c07a ("bus: mhi: Early MHI resume failure in non M3 state")
    Cc: stable@vger.kernel.org #5.13
    Reported-by: Kalle Valo <kvalo@codeaurora.org>
    Reported-by: Pengyu Ma <mapengyu@gmail.com>
    Tested-by: Kalle Valo <kvalo@kernel.org>
    Acked-by: Kalle Valo <kvalo@kernel.org>
    Signed-off-by: Loic Poulain <loic.poulain@linaro.org>
    [mani: Switched to API, added bug report, reported-by tags and CCed stable]
    Signed-off-by: Manivannan Sadhasivam <manivannan.sadhasivam@linaro.org>
    Link: https://lore.kernel.org/r/20211209131633.4168-1-manivannan.sadhasivam@linaro.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 5eca1c8412f40dd798c28549cd4c032217ad2faf
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue Sep 21 12:42:25 2021 +0300

    bus: ti-sysc: Add quirk handling for reinit on context lost
    
    [ Upstream commit 9d881361206ebcf6285c2ec2ef275aff80875347 ]
    
    Some interconnect target modules such as otg and gpmc on am335x need a
    re-init after resume. As we also have PM runtime cases where the context
    may be lost, let's handle these all with cpu_pm.
    
    For the am335x resume path, we already have cpu_pm_resume() call
    cpu_pm_cluster_exit().
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 383a44aec91c327ef4a9d03cfa65d1eaf3746c06
Author: Yong Wu <yong.wu@mediatek.com>
Date:   Wed Nov 24 09:50:42 2021 +0100

    memory: mtk-smi: Fix a null dereference for the ostd
    
    We add the ostd setting for mt8195. It introduces a KE for the
    previous SoC which doesn't have ostd setting. This is the log:
    
    Unable to handle kernel NULL pointer dereference at virtual address
    0000000000000080
    ...
    pc : mtk_smi_larb_config_port_gen2_general+0x64/0x130
    lr : mtk_smi_larb_resume+0x54/0x98
    ...
    Call trace:
     mtk_smi_larb_config_port_gen2_general+0x64/0x130
     pm_generic_runtime_resume+0x2c/0x48
     __genpd_runtime_resume+0x30/0xa8
     genpd_runtime_resume+0x94/0x2c8
     __rpm_callback+0x44/0x150
     rpm_callback+0x6c/0x78
     rpm_resume+0x310/0x558
     __pm_runtime_resume+0x3c/0x88
    
    In the code: larbostd = larb->larb_gen->ostd[larb->larbid],
    if "larb->larb_gen->ostd" is null, the "larbostd" is the offset(e.g.
    0x80 above), it's also a valid value, then accessing "larbostd[i]" in the
    "for" loop will cause the KE above. To avoid this issue, initialize
    "larbostd" to NULL when the SoC doesn't have ostd setting.
    
    Fixes: fe6dd2a4017d ("memory: mtk-smi: mt8195: Add initial setting for smi-larb")
    Signed-off-by: Yong Wu <yong.wu@mediatek.com>
    Signed-off-by: Krzysztof Kozlowski <krzysztof.kozlowski@canonical.com>
    Link: https://lore.kernel.org/r/20211108082429.15080-1-yong.wu@mediatek.com
    Link: https://lore.kernel.org/r/20211124085042.9649-3-krzysztof.kozlowski@canonical.com'
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

commit c182fa00fcdd3f191d65b0d7fbe2b0a382e0f412
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue Sep 21 12:42:25 2021 +0300

    bus: ti-sysc: Add quirk handling for reinit on context lost
    
    [ Upstream commit 9d881361206ebcf6285c2ec2ef275aff80875347 ]
    
    Some interconnect target modules such as otg and gpmc on am335x need a
    re-init after resume. As we also have PM runtime cases where the context
    may be lost, let's handle these all with cpu_pm.
    
    For the am335x resume path, we already have cpu_pm_resume() call
    cpu_pm_cluster_exit().
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 051d89f4dec2bce37a8d5471b0b1ef2796901858
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Nov 4 18:26:26 2021 +0100

    PM: sleep: Avoid calling put_device() under dpm_list_mtx
    
    commit 2aa36604e8243698ff22bd5fef0dd0c6bb07ba92 upstream.
    
    It is generally unsafe to call put_device() with dpm_list_mtx held,
    because the given device's release routine may carry out an action
    depending on that lock which then may deadlock, so modify the
    system-wide suspend and resume of devices to always drop dpm_list_mtx
    before calling put_device() (and adjust white space somewhat while
    at it).
    
    For instance, this prevents the following splat from showing up in
    the kernel log after a system resume in certain configurations:
    
    [ 3290.969514] ======================================================
    [ 3290.969517] WARNING: possible circular locking dependency detected
    [ 3290.969519] 5.15.0+ #2420 Tainted: G S
    [ 3290.969523] ------------------------------------------------------
    [ 3290.969525] systemd-sleep/4553 is trying to acquire lock:
    [ 3290.969529] ffff888117ab1138 ((wq_completion)hci0#2){+.+.}-{0:0}, at: flush_workqueue+0x87/0x4a0
    [ 3290.969554]
                   but task is already holding lock:
    [ 3290.969556] ffffffff8280fca8 (dpm_list_mtx){+.+.}-{3:3}, at: dpm_resume+0x12e/0x3e0
    [ 3290.969571]
                   which lock already depends on the new lock.
    
    [ 3290.969573]
                   the existing dependency chain (in reverse order) is:
    [ 3290.969575]
                   -> #3 (dpm_list_mtx){+.+.}-{3:3}:
    [ 3290.969583]        __mutex_lock+0x9d/0xa30
    [ 3290.969591]        device_pm_add+0x2e/0xe0
    [ 3290.969597]        device_add+0x4d5/0x8f0
    [ 3290.969605]        hci_conn_add_sysfs+0x43/0xb0 [bluetooth]
    [ 3290.969689]        hci_conn_complete_evt.isra.71+0x124/0x750 [bluetooth]
    [ 3290.969747]        hci_event_packet+0xd6c/0x28a0 [bluetooth]
    [ 3290.969798]        hci_rx_work+0x213/0x640 [bluetooth]
    [ 3290.969842]        process_one_work+0x2aa/0x650
    [ 3290.969851]        worker_thread+0x39/0x400
    [ 3290.969859]        kthread+0x142/0x170
    [ 3290.969865]        ret_from_fork+0x22/0x30
    [ 3290.969872]
                   -> #2 (&hdev->lock){+.+.}-{3:3}:
    [ 3290.969881]        __mutex_lock+0x9d/0xa30
    [ 3290.969887]        hci_event_packet+0xba/0x28a0 [bluetooth]
    [ 3290.969935]        hci_rx_work+0x213/0x640 [bluetooth]
    [ 3290.969978]        process_one_work+0x2aa/0x650
    [ 3290.969985]        worker_thread+0x39/0x400
    [ 3290.969993]        kthread+0x142/0x170
    [ 3290.969999]        ret_from_fork+0x22/0x30
    [ 3290.970004]
                   -> #1 ((work_completion)(&hdev->rx_work)){+.+.}-{0:0}:
    [ 3290.970013]        process_one_work+0x27d/0x650
    [ 3290.970020]        worker_thread+0x39/0x400
    [ 3290.970028]        kthread+0x142/0x170
    [ 3290.970033]        ret_from_fork+0x22/0x30
    [ 3290.970038]
                   -> #0 ((wq_completion)hci0#2){+.+.}-{0:0}:
    [ 3290.970047]        __lock_acquire+0x15cb/0x1b50
    [ 3290.970054]        lock_acquire+0x26c/0x300
    [ 3290.970059]        flush_workqueue+0xae/0x4a0
    [ 3290.970066]        drain_workqueue+0xa1/0x130
    [ 3290.970073]        destroy_workqueue+0x34/0x1f0
    [ 3290.970081]        hci_release_dev+0x49/0x180 [bluetooth]
    [ 3290.970130]        bt_host_release+0x1d/0x30 [bluetooth]
    [ 3290.970195]        device_release+0x33/0x90
    [ 3290.970201]        kobject_release+0x63/0x160
    [ 3290.970211]        dpm_resume+0x164/0x3e0
    [ 3290.970215]        dpm_resume_end+0xd/0x20
    [ 3290.970220]        suspend_devices_and_enter+0x1a4/0xba0
    [ 3290.970229]        pm_suspend+0x26b/0x310
    [ 3290.970236]        state_store+0x42/0x90
    [ 3290.970243]        kernfs_fop_write_iter+0x135/0x1b0
    [ 3290.970251]        new_sync_write+0x125/0x1c0
    [ 3290.970257]        vfs_write+0x360/0x3c0
    [ 3290.970263]        ksys_write+0xa7/0xe0
    [ 3290.970269]        do_syscall_64+0x3a/0x80
    [ 3290.970276]        entry_SYSCALL_64_after_hwframe+0x44/0xae
    [ 3290.970284]
                   other info that might help us debug this:
    
    [ 3290.970285] Chain exists of:
                     (wq_completion)hci0#2 --> &hdev->lock --> dpm_list_mtx
    
    [ 3290.970297]  Possible unsafe locking scenario:
    
    [ 3290.970299]        CPU0                    CPU1
    [ 3290.970300]        ----                    ----
    [ 3290.970302]   lock(dpm_list_mtx);
    [ 3290.970306]                                lock(&hdev->lock);
    [ 3290.970310]                                lock(dpm_list_mtx);
    [ 3290.970314]   lock((wq_completion)hci0#2);
    [ 3290.970319]
                    *** DEADLOCK ***
    
    [ 3290.970321] 7 locks held by systemd-sleep/4553:
    [ 3290.970325]  #0: ffff888103bcd448 (sb_writers#4){.+.+}-{0:0}, at: ksys_write+0xa7/0xe0
    [ 3290.970341]  #1: ffff888115a14488 (&of->mutex){+.+.}-{3:3}, at: kernfs_fop_write_iter+0x103/0x1b0
    [ 3290.970355]  #2: ffff888100f719e0 (kn->active#233){.+.+}-{0:0}, at: kernfs_fop_write_iter+0x10c/0x1b0
    [ 3290.970369]  #3: ffffffff82661048 (autosleep_lock){+.+.}-{3:3}, at: state_store+0x12/0x90
    [ 3290.970384]  #4: ffffffff82658ac8 (system_transition_mutex){+.+.}-{3:3}, at: pm_suspend+0x9f/0x310
    [ 3290.970399]  #5: ffffffff827f2a48 (acpi_scan_lock){+.+.}-{3:3}, at: acpi_suspend_begin+0x4c/0x80
    [ 3290.970416]  #6: ffffffff8280fca8 (dpm_list_mtx){+.+.}-{3:3}, at: dpm_resume+0x12e/0x3e0
    [ 3290.970428]
                   stack backtrace:
    [ 3290.970431] CPU: 3 PID: 4553 Comm: systemd-sleep Tainted: G S                5.15.0+ #2420
    [ 3290.970438] Hardware name: Dell Inc. XPS 13 9380/0RYJWW, BIOS 1.5.0 06/03/2019
    [ 3290.970441] Call Trace:
    [ 3290.970446]  dump_stack_lvl+0x44/0x57
    [ 3290.970454]  check_noncircular+0x105/0x120
    [ 3290.970468]  ? __lock_acquire+0x15cb/0x1b50
    [ 3290.970474]  __lock_acquire+0x15cb/0x1b50
    [ 3290.970487]  lock_acquire+0x26c/0x300
    [ 3290.970493]  ? flush_workqueue+0x87/0x4a0
    [ 3290.970503]  ? __raw_spin_lock_init+0x3b/0x60
    [ 3290.970510]  ? lockdep_init_map_type+0x58/0x240
    [ 3290.970519]  flush_workqueue+0xae/0x4a0
    [ 3290.970526]  ? flush_workqueue+0x87/0x4a0
    [ 3290.970544]  ? drain_workqueue+0xa1/0x130
    [ 3290.970552]  drain_workqueue+0xa1/0x130
    [ 3290.970561]  destroy_workqueue+0x34/0x1f0
    [ 3290.970572]  hci_release_dev+0x49/0x180 [bluetooth]
    [ 3290.970624]  bt_host_release+0x1d/0x30 [bluetooth]
    [ 3290.970687]  device_release+0x33/0x90
    [ 3290.970695]  kobject_release+0x63/0x160
    [ 3290.970705]  dpm_resume+0x164/0x3e0
    [ 3290.970710]  ? dpm_resume_early+0x251/0x3b0
    [ 3290.970718]  dpm_resume_end+0xd/0x20
    [ 3290.970723]  suspend_devices_and_enter+0x1a4/0xba0
    [ 3290.970737]  pm_suspend+0x26b/0x310
    [ 3290.970746]  state_store+0x42/0x90
    [ 3290.970755]  kernfs_fop_write_iter+0x135/0x1b0
    [ 3290.970764]  new_sync_write+0x125/0x1c0
    [ 3290.970777]  vfs_write+0x360/0x3c0
    [ 3290.970785]  ksys_write+0xa7/0xe0
    [ 3290.970794]  do_syscall_64+0x3a/0x80
    [ 3290.970803]  entry_SYSCALL_64_after_hwframe+0x44/0xae
    [ 3290.970811] RIP: 0033:0x7f41b1328164
    [ 3290.970819] Code: 00 f7 d8 64 89 02 48 c7 c0 ff ff ff ff eb b7 0f 1f 80 00 00 00 00 8b 05 4a d2 2c 00 48 63 ff 85 c0 75 13 b8 01 00 00 00 0f 05 <48> 3d 00 f0 ff ff 77 54 f3 c3 66 90 55 53 48 89 d5 48 89 f3 48 83
    [ 3290.970824] RSP: 002b:00007ffe6ae21b28 EFLAGS: 00000246 ORIG_RAX: 0000000000000001
    [ 3290.970831] RAX: ffffffffffffffda RBX: 0000000000000004 RCX: 00007f41b1328164
    [ 3290.970836] RDX: 0000000000000004 RSI: 000055965e651070 RDI: 0000000000000004
    [ 3290.970839] RBP: 000055965e651070 R08: 000055965e64f390 R09: 00007f41b1e3d1c0
    [ 3290.970843] R10: 000000000000000a R11: 0000000000000246 R12: 0000000000000004
    [ 3290.970846] R13: 0000000000000001 R14: 000055965e64f2b0 R15: 0000000000000004
    
    Cc: All applicable <stable@vger.kernel.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 3eab21ff9f879b188fb2144c709369381dbaa1b7
Author: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
Date:   Tue Oct 12 11:15:21 2021 +0100

    soundwire: bus: stop dereferencing invalid slave pointer
    
    [ Upstream commit 4cbbe74d906be0bcffbe1e74b43a00f99626a69c ]
    
    Slave pointer is invalid after end of list iteration, using this
    would result in below Memory abort.
    
    Unable to handle kernel NULL pointer dereference at virtual address 0000000000000004
    ...
    Call trace:
     __dev_printk+0x34/0x7c
     _dev_warn+0x6c/0x90
     sdw_bus_exit_clk_stop+0x194/0x1d0
     swrm_runtime_resume+0x13c/0x238
     pm_generic_runtime_resume+0x2c/0x48
     __rpm_callback+0x44/0x150
     rpm_callback+0x6c/0x78
     rpm_resume+0x314/0x558
     rpm_resume+0x378/0x558
     rpm_resume+0x378/0x558
     __pm_runtime_resume+0x3c/0x88
    
    Use bus->dev instead to print this error message.
    
    Fixes: b50bb8ba369cd ("soundwire: bus: handle -ENODATA errors in clock stop/start sequences")
    Signed-off-by: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
    Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Link: https://lore.kernel.org/r/20211012101521.32087-1-srinivas.kandagatla@linaro.org
    Signed-off-by: Vinod Koul <vkoul@kernel.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit e554c13dbe3caaa25558a845816baec77d03da7c
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Nov 4 18:26:26 2021 +0100

    PM: sleep: Avoid calling put_device() under dpm_list_mtx
    
    commit 2aa36604e8243698ff22bd5fef0dd0c6bb07ba92 upstream.
    
    It is generally unsafe to call put_device() with dpm_list_mtx held,
    because the given device's release routine may carry out an action
    depending on that lock which then may deadlock, so modify the
    system-wide suspend and resume of devices to always drop dpm_list_mtx
    before calling put_device() (and adjust white space somewhat while
    at it).
    
    For instance, this prevents the following splat from showing up in
    the kernel log after a system resume in certain configurations:
    
    [ 3290.969514] ======================================================
    [ 3290.969517] WARNING: possible circular locking dependency detected
    [ 3290.969519] 5.15.0+ #2420 Tainted: G S
    [ 3290.969523] ------------------------------------------------------
    [ 3290.969525] systemd-sleep/4553 is trying to acquire lock:
    [ 3290.969529] ffff888117ab1138 ((wq_completion)hci0#2){+.+.}-{0:0}, at: flush_workqueue+0x87/0x4a0
    [ 3290.969554]
                   but task is already holding lock:
    [ 3290.969556] ffffffff8280fca8 (dpm_list_mtx){+.+.}-{3:3}, at: dpm_resume+0x12e/0x3e0
    [ 3290.969571]
                   which lock already depends on the new lock.
    
    [ 3290.969573]
                   the existing dependency chain (in reverse order) is:
    [ 3290.969575]
                   -> #3 (dpm_list_mtx){+.+.}-{3:3}:
    [ 3290.969583]        __mutex_lock+0x9d/0xa30
    [ 3290.969591]        device_pm_add+0x2e/0xe0
    [ 3290.969597]        device_add+0x4d5/0x8f0
    [ 3290.969605]        hci_conn_add_sysfs+0x43/0xb0 [bluetooth]
    [ 3290.969689]        hci_conn_complete_evt.isra.71+0x124/0x750 [bluetooth]
    [ 3290.969747]        hci_event_packet+0xd6c/0x28a0 [bluetooth]
    [ 3290.969798]        hci_rx_work+0x213/0x640 [bluetooth]
    [ 3290.969842]        process_one_work+0x2aa/0x650
    [ 3290.969851]        worker_thread+0x39/0x400
    [ 3290.969859]        kthread+0x142/0x170
    [ 3290.969865]        ret_from_fork+0x22/0x30
    [ 3290.969872]
                   -> #2 (&hdev->lock){+.+.}-{3:3}:
    [ 3290.969881]        __mutex_lock+0x9d/0xa30
    [ 3290.969887]        hci_event_packet+0xba/0x28a0 [bluetooth]
    [ 3290.969935]        hci_rx_work+0x213/0x640 [bluetooth]
    [ 3290.969978]        process_one_work+0x2aa/0x650
    [ 3290.969985]        worker_thread+0x39/0x400
    [ 3290.969993]        kthread+0x142/0x170
    [ 3290.969999]        ret_from_fork+0x22/0x30
    [ 3290.970004]
                   -> #1 ((work_completion)(&hdev->rx_work)){+.+.}-{0:0}:
    [ 3290.970013]        process_one_work+0x27d/0x650
    [ 3290.970020]        worker_thread+0x39/0x400
    [ 3290.970028]        kthread+0x142/0x170
    [ 3290.970033]        ret_from_fork+0x22/0x30
    [ 3290.970038]
                   -> #0 ((wq_completion)hci0#2){+.+.}-{0:0}:
    [ 3290.970047]        __lock_acquire+0x15cb/0x1b50
    [ 3290.970054]        lock_acquire+0x26c/0x300
    [ 3290.970059]        flush_workqueue+0xae/0x4a0
    [ 3290.970066]        drain_workqueue+0xa1/0x130
    [ 3290.970073]        destroy_workqueue+0x34/0x1f0
    [ 3290.970081]        hci_release_dev+0x49/0x180 [bluetooth]
    [ 3290.970130]        bt_host_release+0x1d/0x30 [bluetooth]
    [ 3290.970195]        device_release+0x33/0x90
    [ 3290.970201]        kobject_release+0x63/0x160
    [ 3290.970211]        dpm_resume+0x164/0x3e0
    [ 3290.970215]        dpm_resume_end+0xd/0x20
    [ 3290.970220]        suspend_devices_and_enter+0x1a4/0xba0
    [ 3290.970229]        pm_suspend+0x26b/0x310
    [ 3290.970236]        state_store+0x42/0x90
    [ 3290.970243]        kernfs_fop_write_iter+0x135/0x1b0
    [ 3290.970251]        new_sync_write+0x125/0x1c0
    [ 3290.970257]        vfs_write+0x360/0x3c0
    [ 3290.970263]        ksys_write+0xa7/0xe0
    [ 3290.970269]        do_syscall_64+0x3a/0x80
    [ 3290.970276]        entry_SYSCALL_64_after_hwframe+0x44/0xae
    [ 3290.970284]
                   other info that might help us debug this:
    
    [ 3290.970285] Chain exists of:
                     (wq_completion)hci0#2 --> &hdev->lock --> dpm_list_mtx
    
    [ 3290.970297]  Possible unsafe locking scenario:
    
    [ 3290.970299]        CPU0                    CPU1
    [ 3290.970300]        ----                    ----
    [ 3290.970302]   lock(dpm_list_mtx);
    [ 3290.970306]                                lock(&hdev->lock);
    [ 3290.970310]                                lock(dpm_list_mtx);
    [ 3290.970314]   lock((wq_completion)hci0#2);
    [ 3290.970319]
                    *** DEADLOCK ***
    
    [ 3290.970321] 7 locks held by systemd-sleep/4553:
    [ 3290.970325]  #0: ffff888103bcd448 (sb_writers#4){.+.+}-{0:0}, at: ksys_write+0xa7/0xe0
    [ 3290.970341]  #1: ffff888115a14488 (&of->mutex){+.+.}-{3:3}, at: kernfs_fop_write_iter+0x103/0x1b0
    [ 3290.970355]  #2: ffff888100f719e0 (kn->active#233){.+.+}-{0:0}, at: kernfs_fop_write_iter+0x10c/0x1b0
    [ 3290.970369]  #3: ffffffff82661048 (autosleep_lock){+.+.}-{3:3}, at: state_store+0x12/0x90
    [ 3290.970384]  #4: ffffffff82658ac8 (system_transition_mutex){+.+.}-{3:3}, at: pm_suspend+0x9f/0x310
    [ 3290.970399]  #5: ffffffff827f2a48 (acpi_scan_lock){+.+.}-{3:3}, at: acpi_suspend_begin+0x4c/0x80
    [ 3290.970416]  #6: ffffffff8280fca8 (dpm_list_mtx){+.+.}-{3:3}, at: dpm_resume+0x12e/0x3e0
    [ 3290.970428]
                   stack backtrace:
    [ 3290.970431] CPU: 3 PID: 4553 Comm: systemd-sleep Tainted: G S                5.15.0+ #2420
    [ 3290.970438] Hardware name: Dell Inc. XPS 13 9380/0RYJWW, BIOS 1.5.0 06/03/2019
    [ 3290.970441] Call Trace:
    [ 3290.970446]  dump_stack_lvl+0x44/0x57
    [ 3290.970454]  check_noncircular+0x105/0x120
    [ 3290.970468]  ? __lock_acquire+0x15cb/0x1b50
    [ 3290.970474]  __lock_acquire+0x15cb/0x1b50
    [ 3290.970487]  lock_acquire+0x26c/0x300
    [ 3290.970493]  ? flush_workqueue+0x87/0x4a0
    [ 3290.970503]  ? __raw_spin_lock_init+0x3b/0x60
    [ 3290.970510]  ? lockdep_init_map_type+0x58/0x240
    [ 3290.970519]  flush_workqueue+0xae/0x4a0
    [ 3290.970526]  ? flush_workqueue+0x87/0x4a0
    [ 3290.970544]  ? drain_workqueue+0xa1/0x130
    [ 3290.970552]  drain_workqueue+0xa1/0x130
    [ 3290.970561]  destroy_workqueue+0x34/0x1f0
    [ 3290.970572]  hci_release_dev+0x49/0x180 [bluetooth]
    [ 3290.970624]  bt_host_release+0x1d/0x30 [bluetooth]
    [ 3290.970687]  device_release+0x33/0x90
    [ 3290.970695]  kobject_release+0x63/0x160
    [ 3290.970705]  dpm_resume+0x164/0x3e0
    [ 3290.970710]  ? dpm_resume_early+0x251/0x3b0
    [ 3290.970718]  dpm_resume_end+0xd/0x20
    [ 3290.970723]  suspend_devices_and_enter+0x1a4/0xba0
    [ 3290.970737]  pm_suspend+0x26b/0x310
    [ 3290.970746]  state_store+0x42/0x90
    [ 3290.970755]  kernfs_fop_write_iter+0x135/0x1b0
    [ 3290.970764]  new_sync_write+0x125/0x1c0
    [ 3290.970777]  vfs_write+0x360/0x3c0
    [ 3290.970785]  ksys_write+0xa7/0xe0
    [ 3290.970794]  do_syscall_64+0x3a/0x80
    [ 3290.970803]  entry_SYSCALL_64_after_hwframe+0x44/0xae
    [ 3290.970811] RIP: 0033:0x7f41b1328164
    [ 3290.970819] Code: 00 f7 d8 64 89 02 48 c7 c0 ff ff ff ff eb b7 0f 1f 80 00 00 00 00 8b 05 4a d2 2c 00 48 63 ff 85 c0 75 13 b8 01 00 00 00 0f 05 <48> 3d 00 f0 ff ff 77 54 f3 c3 66 90 55 53 48 89 d5 48 89 f3 48 83
    [ 3290.970824] RSP: 002b:00007ffe6ae21b28 EFLAGS: 00000246 ORIG_RAX: 0000000000000001
    [ 3290.970831] RAX: ffffffffffffffda RBX: 0000000000000004 RCX: 00007f41b1328164
    [ 3290.970836] RDX: 0000000000000004 RSI: 000055965e651070 RDI: 0000000000000004
    [ 3290.970839] RBP: 000055965e651070 R08: 000055965e64f390 R09: 00007f41b1e3d1c0
    [ 3290.970843] R10: 000000000000000a R11: 0000000000000246 R12: 0000000000000004
    [ 3290.970846] R13: 0000000000000001 R14: 000055965e64f2b0 R15: 0000000000000004
    
    Cc: All applicable <stable@vger.kernel.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 8104d165fe8c39f7afba419251d3369e3c119c4c
Author: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
Date:   Tue Oct 12 11:15:21 2021 +0100

    soundwire: bus: stop dereferencing invalid slave pointer
    
    [ Upstream commit 4cbbe74d906be0bcffbe1e74b43a00f99626a69c ]
    
    Slave pointer is invalid after end of list iteration, using this
    would result in below Memory abort.
    
    Unable to handle kernel NULL pointer dereference at virtual address 0000000000000004
    ...
    Call trace:
     __dev_printk+0x34/0x7c
     _dev_warn+0x6c/0x90
     sdw_bus_exit_clk_stop+0x194/0x1d0
     swrm_runtime_resume+0x13c/0x238
     pm_generic_runtime_resume+0x2c/0x48
     __rpm_callback+0x44/0x150
     rpm_callback+0x6c/0x78
     rpm_resume+0x314/0x558
     rpm_resume+0x378/0x558
     rpm_resume+0x378/0x558
     __pm_runtime_resume+0x3c/0x88
    
    Use bus->dev instead to print this error message.
    
    Fixes: b50bb8ba369cd ("soundwire: bus: handle -ENODATA errors in clock stop/start sequences")
    Signed-off-by: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
    Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Link: https://lore.kernel.org/r/20211012101521.32087-1-srinivas.kandagatla@linaro.org
    Signed-off-by: Vinod Koul <vkoul@kernel.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 2aa36604e8243698ff22bd5fef0dd0c6bb07ba92
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Nov 4 18:26:26 2021 +0100

    PM: sleep: Avoid calling put_device() under dpm_list_mtx
    
    It is generally unsafe to call put_device() with dpm_list_mtx held,
    because the given device's release routine may carry out an action
    depending on that lock which then may deadlock, so modify the
    system-wide suspend and resume of devices to always drop dpm_list_mtx
    before calling put_device() (and adjust white space somewhat while
    at it).
    
    For instance, this prevents the following splat from showing up in
    the kernel log after a system resume in certain configurations:
    
    [ 3290.969514] ======================================================
    [ 3290.969517] WARNING: possible circular locking dependency detected
    [ 3290.969519] 5.15.0+ #2420 Tainted: G S
    [ 3290.969523] ------------------------------------------------------
    [ 3290.969525] systemd-sleep/4553 is trying to acquire lock:
    [ 3290.969529] ffff888117ab1138 ((wq_completion)hci0#2){+.+.}-{0:0}, at: flush_workqueue+0x87/0x4a0
    [ 3290.969554]
                   but task is already holding lock:
    [ 3290.969556] ffffffff8280fca8 (dpm_list_mtx){+.+.}-{3:3}, at: dpm_resume+0x12e/0x3e0
    [ 3290.969571]
                   which lock already depends on the new lock.
    
    [ 3290.969573]
                   the existing dependency chain (in reverse order) is:
    [ 3290.969575]
                   -> #3 (dpm_list_mtx){+.+.}-{3:3}:
    [ 3290.969583]        __mutex_lock+0x9d/0xa30
    [ 3290.969591]        device_pm_add+0x2e/0xe0
    [ 3290.969597]        device_add+0x4d5/0x8f0
    [ 3290.969605]        hci_conn_add_sysfs+0x43/0xb0 [bluetooth]
    [ 3290.969689]        hci_conn_complete_evt.isra.71+0x124/0x750 [bluetooth]
    [ 3290.969747]        hci_event_packet+0xd6c/0x28a0 [bluetooth]
    [ 3290.969798]        hci_rx_work+0x213/0x640 [bluetooth]
    [ 3290.969842]        process_one_work+0x2aa/0x650
    [ 3290.969851]        worker_thread+0x39/0x400
    [ 3290.969859]        kthread+0x142/0x170
    [ 3290.969865]        ret_from_fork+0x22/0x30
    [ 3290.969872]
                   -> #2 (&hdev->lock){+.+.}-{3:3}:
    [ 3290.969881]        __mutex_lock+0x9d/0xa30
    [ 3290.969887]        hci_event_packet+0xba/0x28a0 [bluetooth]
    [ 3290.969935]        hci_rx_work+0x213/0x640 [bluetooth]
    [ 3290.969978]        process_one_work+0x2aa/0x650
    [ 3290.969985]        worker_thread+0x39/0x400
    [ 3290.969993]        kthread+0x142/0x170
    [ 3290.969999]        ret_from_fork+0x22/0x30
    [ 3290.970004]
                   -> #1 ((work_completion)(&hdev->rx_work)){+.+.}-{0:0}:
    [ 3290.970013]        process_one_work+0x27d/0x650
    [ 3290.970020]        worker_thread+0x39/0x400
    [ 3290.970028]        kthread+0x142/0x170
    [ 3290.970033]        ret_from_fork+0x22/0x30
    [ 3290.970038]
                   -> #0 ((wq_completion)hci0#2){+.+.}-{0:0}:
    [ 3290.970047]        __lock_acquire+0x15cb/0x1b50
    [ 3290.970054]        lock_acquire+0x26c/0x300
    [ 3290.970059]        flush_workqueue+0xae/0x4a0
    [ 3290.970066]        drain_workqueue+0xa1/0x130
    [ 3290.970073]        destroy_workqueue+0x34/0x1f0
    [ 3290.970081]        hci_release_dev+0x49/0x180 [bluetooth]
    [ 3290.970130]        bt_host_release+0x1d/0x30 [bluetooth]
    [ 3290.970195]        device_release+0x33/0x90
    [ 3290.970201]        kobject_release+0x63/0x160
    [ 3290.970211]        dpm_resume+0x164/0x3e0
    [ 3290.970215]        dpm_resume_end+0xd/0x20
    [ 3290.970220]        suspend_devices_and_enter+0x1a4/0xba0
    [ 3290.970229]        pm_suspend+0x26b/0x310
    [ 3290.970236]        state_store+0x42/0x90
    [ 3290.970243]        kernfs_fop_write_iter+0x135/0x1b0
    [ 3290.970251]        new_sync_write+0x125/0x1c0
    [ 3290.970257]        vfs_write+0x360/0x3c0
    [ 3290.970263]        ksys_write+0xa7/0xe0
    [ 3290.970269]        do_syscall_64+0x3a/0x80
    [ 3290.970276]        entry_SYSCALL_64_after_hwframe+0x44/0xae
    [ 3290.970284]
                   other info that might help us debug this:
    
    [ 3290.970285] Chain exists of:
                     (wq_completion)hci0#2 --> &hdev->lock --> dpm_list_mtx
    
    [ 3290.970297]  Possible unsafe locking scenario:
    
    [ 3290.970299]        CPU0                    CPU1
    [ 3290.970300]        ----                    ----
    [ 3290.970302]   lock(dpm_list_mtx);
    [ 3290.970306]                                lock(&hdev->lock);
    [ 3290.970310]                                lock(dpm_list_mtx);
    [ 3290.970314]   lock((wq_completion)hci0#2);
    [ 3290.970319]
                    *** DEADLOCK ***
    
    [ 3290.970321] 7 locks held by systemd-sleep/4553:
    [ 3290.970325]  #0: ffff888103bcd448 (sb_writers#4){.+.+}-{0:0}, at: ksys_write+0xa7/0xe0
    [ 3290.970341]  #1: ffff888115a14488 (&of->mutex){+.+.}-{3:3}, at: kernfs_fop_write_iter+0x103/0x1b0
    [ 3290.970355]  #2: ffff888100f719e0 (kn->active#233){.+.+}-{0:0}, at: kernfs_fop_write_iter+0x10c/0x1b0
    [ 3290.970369]  #3: ffffffff82661048 (autosleep_lock){+.+.}-{3:3}, at: state_store+0x12/0x90
    [ 3290.970384]  #4: ffffffff82658ac8 (system_transition_mutex){+.+.}-{3:3}, at: pm_suspend+0x9f/0x310
    [ 3290.970399]  #5: ffffffff827f2a48 (acpi_scan_lock){+.+.}-{3:3}, at: acpi_suspend_begin+0x4c/0x80
    [ 3290.970416]  #6: ffffffff8280fca8 (dpm_list_mtx){+.+.}-{3:3}, at: dpm_resume+0x12e/0x3e0
    [ 3290.970428]
                   stack backtrace:
    [ 3290.970431] CPU: 3 PID: 4553 Comm: systemd-sleep Tainted: G S                5.15.0+ #2420
    [ 3290.970438] Hardware name: Dell Inc. XPS 13 9380/0RYJWW, BIOS 1.5.0 06/03/2019
    [ 3290.970441] Call Trace:
    [ 3290.970446]  dump_stack_lvl+0x44/0x57
    [ 3290.970454]  check_noncircular+0x105/0x120
    [ 3290.970468]  ? __lock_acquire+0x15cb/0x1b50
    [ 3290.970474]  __lock_acquire+0x15cb/0x1b50
    [ 3290.970487]  lock_acquire+0x26c/0x300
    [ 3290.970493]  ? flush_workqueue+0x87/0x4a0
    [ 3290.970503]  ? __raw_spin_lock_init+0x3b/0x60
    [ 3290.970510]  ? lockdep_init_map_type+0x58/0x240
    [ 3290.970519]  flush_workqueue+0xae/0x4a0
    [ 3290.970526]  ? flush_workqueue+0x87/0x4a0
    [ 3290.970544]  ? drain_workqueue+0xa1/0x130
    [ 3290.970552]  drain_workqueue+0xa1/0x130
    [ 3290.970561]  destroy_workqueue+0x34/0x1f0
    [ 3290.970572]  hci_release_dev+0x49/0x180 [bluetooth]
    [ 3290.970624]  bt_host_release+0x1d/0x30 [bluetooth]
    [ 3290.970687]  device_release+0x33/0x90
    [ 3290.970695]  kobject_release+0x63/0x160
    [ 3290.970705]  dpm_resume+0x164/0x3e0
    [ 3290.970710]  ? dpm_resume_early+0x251/0x3b0
    [ 3290.970718]  dpm_resume_end+0xd/0x20
    [ 3290.970723]  suspend_devices_and_enter+0x1a4/0xba0
    [ 3290.970737]  pm_suspend+0x26b/0x310
    [ 3290.970746]  state_store+0x42/0x90
    [ 3290.970755]  kernfs_fop_write_iter+0x135/0x1b0
    [ 3290.970764]  new_sync_write+0x125/0x1c0
    [ 3290.970777]  vfs_write+0x360/0x3c0
    [ 3290.970785]  ksys_write+0xa7/0xe0
    [ 3290.970794]  do_syscall_64+0x3a/0x80
    [ 3290.970803]  entry_SYSCALL_64_after_hwframe+0x44/0xae
    [ 3290.970811] RIP: 0033:0x7f41b1328164
    [ 3290.970819] Code: 00 f7 d8 64 89 02 48 c7 c0 ff ff ff ff eb b7 0f 1f 80 00 00 00 00 8b 05 4a d2 2c 00 48 63 ff 85 c0 75 13 b8 01 00 00 00 0f 05 <48> 3d 00 f0 ff ff 77 54 f3 c3 66 90 55 53 48 89 d5 48 89 f3 48 83
    [ 3290.970824] RSP: 002b:00007ffe6ae21b28 EFLAGS: 00000246 ORIG_RAX: 0000000000000001
    [ 3290.970831] RAX: ffffffffffffffda RBX: 0000000000000004 RCX: 00007f41b1328164
    [ 3290.970836] RDX: 0000000000000004 RSI: 000055965e651070 RDI: 0000000000000004
    [ 3290.970839] RBP: 000055965e651070 R08: 000055965e64f390 R09: 00007f41b1e3d1c0
    [ 3290.970843] R10: 000000000000000a R11: 0000000000000246 R12: 0000000000000004
    [ 3290.970846] R13: 0000000000000001 R14: 000055965e64f2b0 R15: 0000000000000004
    
    Cc: All applicable <stable@vger.kernel.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 69d3c7785ec40335874d643fc3af4d4ce9570c2d
Author: Yuiko Oshino <yuiko.oshino@microchip.com>
Date:   Fri Oct 22 11:13:53 2021 -0400

    net: ethernet: microchip: lan743x: Fix driver crash when lan743x_pm_resume fails
    
    commit d6423d2ec39cce2bfca418c81ef51792891576bc upstream.
    
    The driver needs to clean up and return when the initialization fails on resume.
    
    Fixes: 23f0703c125b ("lan743x: Add main source files for new lan743x driver")
    Signed-off-by: Yuiko Oshino <yuiko.oshino@microchip.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit bfa6fbdb4e39b8483fd7ec70c4c82a5105348193
Author: Yuiko Oshino <yuiko.oshino@microchip.com>
Date:   Fri Oct 22 11:13:53 2021 -0400

    net: ethernet: microchip: lan743x: Fix driver crash when lan743x_pm_resume fails
    
    commit d6423d2ec39cce2bfca418c81ef51792891576bc upstream.
    
    The driver needs to clean up and return when the initialization fails on resume.
    
    Fixes: 23f0703c125b ("lan743x: Add main source files for new lan743x driver")
    Signed-off-by: Yuiko Oshino <yuiko.oshino@microchip.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 92507dc1efac221a315a91bb6dfd1da6e2c3eb22
Author: Yuiko Oshino <yuiko.oshino@microchip.com>
Date:   Fri Oct 22 11:13:53 2021 -0400

    net: ethernet: microchip: lan743x: Fix driver crash when lan743x_pm_resume fails
    
    commit d6423d2ec39cce2bfca418c81ef51792891576bc upstream.
    
    The driver needs to clean up and return when the initialization fails on resume.
    
    Fixes: 23f0703c125b ("lan743x: Add main source files for new lan743x driver")
    Signed-off-by: Yuiko Oshino <yuiko.oshino@microchip.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit fcda74cc95aa450a6d17780ccb1a8853cac7d0cd
Author: Yuiko Oshino <yuiko.oshino@microchip.com>
Date:   Fri Oct 22 11:13:53 2021 -0400

    net: ethernet: microchip: lan743x: Fix driver crash when lan743x_pm_resume fails
    
    commit d6423d2ec39cce2bfca418c81ef51792891576bc upstream.
    
    The driver needs to clean up and return when the initialization fails on resume.
    
    Fixes: 23f0703c125b ("lan743x: Add main source files for new lan743x driver")
    Signed-off-by: Yuiko Oshino <yuiko.oshino@microchip.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit d6423d2ec39cce2bfca418c81ef51792891576bc
Author: Yuiko Oshino <yuiko.oshino@microchip.com>
Date:   Fri Oct 22 11:13:53 2021 -0400

    net: ethernet: microchip: lan743x: Fix driver crash when lan743x_pm_resume fails
    
    The driver needs to clean up and return when the initialization fails on resume.
    
    Fixes: 23f0703c125b ("lan743x: Add main source files for new lan743x driver")
    Signed-off-by: Yuiko Oshino <yuiko.oshino@microchip.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 4cbbe74d906be0bcffbe1e74b43a00f99626a69c
Author: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
Date:   Tue Oct 12 11:15:21 2021 +0100

    soundwire: bus: stop dereferencing invalid slave pointer
    
    Slave pointer is invalid after end of list iteration, using this
    would result in below Memory abort.
    
    Unable to handle kernel NULL pointer dereference at virtual address 0000000000000004
    ...
    Call trace:
     __dev_printk+0x34/0x7c
     _dev_warn+0x6c/0x90
     sdw_bus_exit_clk_stop+0x194/0x1d0
     swrm_runtime_resume+0x13c/0x238
     pm_generic_runtime_resume+0x2c/0x48
     __rpm_callback+0x44/0x150
     rpm_callback+0x6c/0x78
     rpm_resume+0x314/0x558
     rpm_resume+0x378/0x558
     rpm_resume+0x378/0x558
     __pm_runtime_resume+0x3c/0x88
    
    Use bus->dev instead to print this error message.
    
    Fixes: b50bb8ba369cd ("soundwire: bus: handle -ENODATA errors in clock stop/start sequences")
    Signed-off-by: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
    Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Link: https://lore.kernel.org/r/20211012101521.32087-1-srinivas.kandagatla@linaro.org
    Signed-off-by: Vinod Koul <vkoul@kernel.org>

commit 85374b6392293d103c2b3406ceb9a1253f81d328
Author: Miles Chen <miles.chen@mediatek.com>
Date:   Fri Oct 15 15:46:54 2021 +0800

    scsi: sd: Fix crashes in sd_resume_runtime()
    
    After commit ed4246d37f3b ("scsi: sd: REQUEST SENSE for
    BLIST_IGN_MEDIA_CHANGE devices in runtime_resume()"), the following crash
    was observed.
    
    static int sd_resume_runtime(struct device *dev)
    {
            struct scsi_disk *sdkp = dev_get_drvdata(dev);
            struct scsi_device *sdp = sdkp->device; // sdkp == NULL and crash
    
            if (sdp->ignore_media_change) {
            ...
    }
    
    It is possible for sdkp to be NULL in sd_resume_runtime(). To fix this
    crash, follow sd_resume() to test if sdkp is NULL before dereferencing it.
    
    Crash:
    [    4.695171][  T151] Unable to handle kernel NULL pointer dereference at virtual address 0000000000000008
    [    4.696591][  T151] Mem abort info:
    [    4.697919][  T151]   ESR = 0x96000005
    [    4.699692][  T151]   EC = 0x25: DABT (current EL), IL = 32 bits
    [    4.701990][  T151]   SET = 0, FnV = 0
    [    4.702513][  T151]   EA = 0, S1PTW = 0
    [    4.704431][  T151]   FSC = 0x05: level 1 translation fault
    [    4.705254][  T151] Data abort info:
    [    4.705806][  T151]   ISV = 0, ISS = 0x00000005
    [    4.706484][  T151]   CM = 0, WnR = 0
    [    4.707048][  T151] [0000000000000008] user address but active_mm is swapper
    [    4.710577][  T151] Internal error: Oops: 96000005 [#1] PREEMPT SMP
    [    4.832361][  T151] Kernel Offset: 0x12acc80000 from 0xffffffc010000000
    [    4.833254][  T151] PHYS_OFFSET: 0x40000000
    [    4.833814][  T151] pstate: 80400005 (Nzcv daif +PAN -UAO)
    [    4.834546][  T151] pc : sd_resume_runtime+0x20/0x14c
    [    4.835227][  T151] lr : scsi_runtime_resume+0x84/0xe4
    [    4.835916][  T151] sp : ffffffc0110db8d0
    [    4.836450][  T151] x29: ffffffc0110db8d0 x28: 0000000000000001
    [    4.837258][  T151] x27: ffffff80c0bd1ac0 x26: ffffff80c0bd1ad0
    [    4.838063][  T151] x25: ffffff80cea7e448 x24: ffffffd2bf961000
    [    4.838867][  T151] x23: ffffffd2be69f838 x22: ffffffd2bd9dfb4c
    [    4.839670][  T151] x21: 0000000000000000 x20: ffffff80cea7e000
    [    4.840474][  T151] x19: ffffff80cea7e260 x18: ffffffc0110dd078
    [    4.841277][  T151] x17: 00000000658783d9 x16: 0000000051469dac
    [    4.842081][  T151] x15: 00000000b87f6327 x14: 0000000068fd680d
    [    4.842885][  T151] x13: ffffff80c0bd2470 x12: ffffffd2bfa7f5f0
    [    4.843688][  T151] x11: 0000000000000078 x10: 0000000000000001
    [    4.844492][  T151] x9 : 00000000000000b1 x8 : ffffffd2be69f88c
    [    4.845295][  T151] x7 : ffffffd2bd9e0e5c x6 : 0000000000000000
    [    4.846099][  T151] x5 : 0000000000000080 x4 : 0000000000000001
    [    4.846902][  T151] x3 : 68fd680dfe4ebe5e x2 : 0000000000000003
    [    4.847706][  T151] x1 : ffffffd2bf7f9380 x0 : ffffff80cea7e260
    [    4.856708][  T151]  die+0x16c/0x59c
    [    4.857191][  T151]  __do_kernel_fault+0x1e8/0x210
    [    4.857833][  T151]  do_page_fault+0xa4/0x654
    [    4.858418][  T151]  do_translation_fault+0x6c/0x1b0
    [    4.859083][  T151]  do_mem_abort+0x68/0x10c
    [    4.859655][  T151]  el1_abort+0x40/0x64
    [    4.860182][  T151]  el1h_64_sync_handler+0x54/0x88
    [    4.860834][  T151]  el1h_64_sync+0x7c/0x80
    [    4.861395][  T151]  sd_resume_runtime+0x20/0x14c
    [    4.862025][  T151]  scsi_runtime_resume+0x84/0xe4
    [    4.862667][  T151]  __rpm_callback+0x1f4/0x8cc
    [    4.863275][  T151]  rpm_resume+0x7e8/0xaa4
    [    4.863836][  T151]  __pm_runtime_resume+0xa0/0x110
    [    4.864489][  T151]  sd_probe+0x30/0x428
    [    4.865016][  T151]  really_probe+0x14c/0x500
    [    4.865602][  T151]  __driver_probe_device+0xb4/0x18c
    [    4.866278][  T151]  driver_probe_device+0x60/0x2c4
    [    4.866931][  T151]  __device_attach_driver+0x228/0x2bc
    [    4.867630][  T151]  __device_attach_async_helper+0x154/0x21c
    [    4.868398][  T151]  async_run_entry_fn+0x5c/0x1c4
    [    4.869038][  T151]  process_one_work+0x3ac/0x590
    [    4.869670][  T151]  worker_thread+0x320/0x758
    [    4.870265][  T151]  kthread+0x2e8/0x35c
    [    4.870792][  T151]  ret_from_fork+0x10/0x20
    
    Link: https://lore.kernel.org/r/20211015074654.19615-1-miles.chen@mediatek.com
    Fixes: ed4246d37f3b ("scsi: sd: REQUEST SENSE for BLIST_IGN_MEDIA_CHANGE devices in runtime_resume()")
    Cc: Stanley Chu <stanley.chu@mediatek.com>
    Reviewed-by: Martin Kepplinger <martin.kepplinger@puri.sm>
    Reviewed-by: Stanley Chu <stanley.chu@mediatek.com>
    Signed-off-by: Miles Chen <miles.chen@mediatek.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

commit 9463b64d1a34fc4d18f9de63f07b2400c86f8da8
Author: Kuogee Hsieh <khsieh@codeaurora.org>
Date:   Wed Sep 29 09:17:04 2021 -0700

    drm/msm/dp: only signal audio when disconnected detected at dp_pm_resume
    
    Currently there is audio not working problem after system resume from suspend
    if hdmi monitor stay plugged in at DUT. However this problem does not happen
    at normal operation but at a particular test case. The root cause is DP driver
    signal audio with connected state at resume which trigger audio trying to setup
    audio data path through DP main link but failed due to display port is not setup
    and enabled by upper layer framework yet. This patch only have DP driver signal
    audio only when DP is in disconnected state so that audio option shows correct
    state after system resume. DP driver will not signal audio with connected state
    until display enabled executed by upper layer framework where display port is
    setup completed and main link is running.
    
    Changes in V2:
    -- add details commit text
    
    Fixes: afc9b8b6bab8 ("drm/msm/dp: signal audio plugged change at dp_pm_resume")
    Signed-off-by: Kuogee Hsieh <khsieh@codeaurora.org>
    Reviewed-by: Stephen Boyd <swboyd@chromium.org>
    Link: https://lore.kernel.org/r/1632932224-25102-1-git-send-email-khsieh@codeaurora.org
    Signed-off-by: Rob Clark <robdclark@chromium.org>

commit 80e336d29217edf6bc6baa1312b0d002113b12b1
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Mar 5 12:21:40 2021 +0000

    rtc: cmos: Disable irq around direct invocation of cmos_interrupt()
    
    commit 13be2efc390acd2a46a69a359f6efc00ca434599 upstream.
    
    As previously noted in commit 66e4f4a9cc38 ("rtc: cmos: Use
    spin_lock_irqsave() in cmos_interrupt()"):
    
    <4>[  254.192378] WARNING: inconsistent lock state
    <4>[  254.192384] 5.12.0-rc1-CI-CI_DRM_9834+ #1 Not tainted
    <4>[  254.192396] --------------------------------
    <4>[  254.192400] inconsistent {IN-HARDIRQ-W} -> {HARDIRQ-ON-W} usage.
    <4>[  254.192409] rtcwake/5309 [HC0[0]:SC0[0]:HE1:SE1] takes:
    <4>[  254.192429] ffffffff8263c5f8 (rtc_lock){?...}-{2:2}, at: cmos_interrupt+0x18/0x100
    <4>[  254.192481] {IN-HARDIRQ-W} state was registered at:
    <4>[  254.192488]   lock_acquire+0xd1/0x3d0
    <4>[  254.192504]   _raw_spin_lock+0x2a/0x40
    <4>[  254.192519]   cmos_interrupt+0x18/0x100
    <4>[  254.192536]   rtc_handler+0x1f/0xc0
    <4>[  254.192553]   acpi_ev_fixed_event_detect+0x109/0x13c
    <4>[  254.192574]   acpi_ev_sci_xrupt_handler+0xb/0x28
    <4>[  254.192596]   acpi_irq+0x13/0x30
    <4>[  254.192620]   __handle_irq_event_percpu+0x43/0x2c0
    <4>[  254.192641]   handle_irq_event_percpu+0x2b/0x70
    <4>[  254.192661]   handle_irq_event+0x2f/0x50
    <4>[  254.192680]   handle_fasteoi_irq+0x9e/0x150
    <4>[  254.192693]   __common_interrupt+0x76/0x140
    <4>[  254.192715]   common_interrupt+0x96/0xc0
    <4>[  254.192732]   asm_common_interrupt+0x1e/0x40
    <4>[  254.192750]   _raw_spin_unlock_irqrestore+0x38/0x60
    <4>[  254.192767]   resume_irqs+0xba/0xf0
    <4>[  254.192786]   dpm_resume_noirq+0x245/0x3d0
    <4>[  254.192811]   suspend_devices_and_enter+0x230/0xaa0
    <4>[  254.192835]   pm_suspend.cold.8+0x301/0x34a
    <4>[  254.192859]   state_store+0x7b/0xe0
    <4>[  254.192879]   kernfs_fop_write_iter+0x11d/0x1c0
    <4>[  254.192899]   new_sync_write+0x11d/0x1b0
    <4>[  254.192916]   vfs_write+0x265/0x390
    <4>[  254.192933]   ksys_write+0x5a/0xd0
    <4>[  254.192949]   do_syscall_64+0x33/0x80
    <4>[  254.192965]   entry_SYSCALL_64_after_hwframe+0x44/0xae
    <4>[  254.192986] irq event stamp: 43775
    <4>[  254.192994] hardirqs last  enabled at (43775): [<ffffffff81c00c42>] asm_sysvec_apic_timer_interrupt+0x12/0x20
    <4>[  254.193023] hardirqs last disabled at (43774): [<ffffffff81aa691a>] sysvec_apic_timer_interrupt+0xa/0xb0
    <4>[  254.193049] softirqs last  enabled at (42548): [<ffffffff81e00342>] __do_softirq+0x342/0x48e
    <4>[  254.193074] softirqs last disabled at (42543): [<ffffffff810b45fd>] irq_exit_rcu+0xad/0xd0
    <4>[  254.193101]
                      other info that might help us debug this:
    <4>[  254.193107]  Possible unsafe locking scenario:
    
    <4>[  254.193112]        CPU0
    <4>[  254.193117]        ----
    <4>[  254.193121]   lock(rtc_lock);
    <4>[  254.193137]   <Interrupt>
    <4>[  254.193142]     lock(rtc_lock);
    <4>[  254.193156]
                       *** DEADLOCK ***
    
    <4>[  254.193161] 6 locks held by rtcwake/5309:
    <4>[  254.193174]  #0: ffff888104861430 (sb_writers#5){.+.+}-{0:0}, at: ksys_write+0x5a/0xd0
    <4>[  254.193232]  #1: ffff88810f823288 (&of->mutex){+.+.}-{3:3}, at: kernfs_fop_write_iter+0xe7/0x1c0
    <4>[  254.193282]  #2: ffff888100cef3c0 (kn->active#285
    <7>[  254.192706] i915 0000:00:02.0: [drm:intel_modeset_setup_hw_state [i915]] [CRTC:51:pipe A] hw state readout: disabled
    <4>[  254.193307] ){.+.+}-{0:0}, at: kernfs_fop_write_iter+0xf0/0x1c0
    <4>[  254.193333]  #3: ffffffff82649fa8 (system_transition_mutex){+.+.}-{3:3}, at: pm_suspend.cold.8+0xce/0x34a
    <4>[  254.193387]  #4: ffffffff827a2108 (acpi_scan_lock){+.+.}-{3:3}, at: acpi_suspend_begin+0x47/0x70
    <4>[  254.193433]  #5: ffff8881019ea178 (&dev->mutex){....}-{3:3}, at: device_resume+0x68/0x1e0
    <4>[  254.193485]
                      stack backtrace:
    <4>[  254.193492] CPU: 1 PID: 5309 Comm: rtcwake Not tainted 5.12.0-rc1-CI-CI_DRM_9834+ #1
    <4>[  254.193514] Hardware name: Google Soraka/Soraka, BIOS MrChromebox-4.10 08/25/2019
    <4>[  254.193524] Call Trace:
    <4>[  254.193536]  dump_stack+0x7f/0xad
    <4>[  254.193567]  mark_lock.part.47+0x8ca/0xce0
    <4>[  254.193604]  __lock_acquire+0x39b/0x2590
    <4>[  254.193626]  ? asm_sysvec_apic_timer_interrupt+0x12/0x20
    <4>[  254.193660]  lock_acquire+0xd1/0x3d0
    <4>[  254.193677]  ? cmos_interrupt+0x18/0x100
    <4>[  254.193716]  _raw_spin_lock+0x2a/0x40
    <4>[  254.193735]  ? cmos_interrupt+0x18/0x100
    <4>[  254.193758]  cmos_interrupt+0x18/0x100
    <4>[  254.193785]  cmos_resume+0x2ac/0x2d0
    <4>[  254.193813]  ? acpi_pm_set_device_wakeup+0x1f/0x110
    <4>[  254.193842]  ? pnp_bus_suspend+0x10/0x10
    <4>[  254.193864]  pnp_bus_resume+0x5e/0x90
    <4>[  254.193885]  dpm_run_callback+0x5f/0x240
    <4>[  254.193914]  device_resume+0xb2/0x1e0
    <4>[  254.193942]  ? pm_dev_err+0x25/0x25
    <4>[  254.193974]  dpm_resume+0xea/0x3f0
    <4>[  254.194005]  dpm_resume_end+0x8/0x10
    <4>[  254.194030]  suspend_devices_and_enter+0x29b/0xaa0
    <4>[  254.194066]  pm_suspend.cold.8+0x301/0x34a
    <4>[  254.194094]  state_store+0x7b/0xe0
    <4>[  254.194124]  kernfs_fop_write_iter+0x11d/0x1c0
    <4>[  254.194151]  new_sync_write+0x11d/0x1b0
    <4>[  254.194183]  vfs_write+0x265/0x390
    <4>[  254.194207]  ksys_write+0x5a/0xd0
    <4>[  254.194232]  do_syscall_64+0x33/0x80
    <4>[  254.194251]  entry_SYSCALL_64_after_hwframe+0x44/0xae
    <4>[  254.194274] RIP: 0033:0x7f07d79691e7
    <4>[  254.194293] Code: 64 89 02 48 c7 c0 ff ff ff ff eb bb 0f 1f 80 00 00 00 00 f3 0f 1e fa 64 8b 04 25 18 00 00 00 85 c0 75 10 b8 01 00 00 00 0f 05 <48> 3d 00 f0 ff ff 77 51 c3 48 83 ec 28 48 89 54 24 18 48 89 74 24
    <4>[  254.194312] RSP: 002b:00007ffd9cc2c768 EFLAGS: 00000246 ORIG_RAX: 0000000000000001
    <4>[  254.194337] RAX: ffffffffffffffda RBX: 0000000000000004 RCX: 00007f07d79691e7
    <4>[  254.194352] RDX: 0000000000000004 RSI: 0000556ebfc63590 RDI: 000000000000000b
    <4>[  254.194366] RBP: 0000556ebfc63590 R08: 0000000000000000 R09: 0000000000000004
    <4>[  254.194379] R10: 0000556ebf0ec2a6 R11: 0000000000000246 R12: 0000000000000004
    
    which breaks S3-resume on fi-kbl-soraka presumably as that's slow enough
    to trigger the alarm during the suspend.
    
    Fixes: 6950d046eb6e ("rtc: cmos: Replace spin_lock_irqsave with spin_lock in hard IRQ")
    References: 66e4f4a9cc38 ("rtc: cmos: Use spin_lock_irqsave() in cmos_interrupt()"):
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Xiaofei Tan <tanxiaofei@huawei.com>
    Cc: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Cc: Alessandro Zummo <a.zummo@towertech.it>
    Cc: Ville Syrjl <ville.syrjala@linux.intel.com>
    Reviewed-by: Ville Syrjl <ville.syrjala@linux.intel.com>
    Signed-off-by: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Link: https://lore.kernel.org/r/20210305122140.28774-1-chris@chris-wilson.co.uk
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 9d881361206ebcf6285c2ec2ef275aff80875347
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue Sep 21 12:42:25 2021 +0300

    bus: ti-sysc: Add quirk handling for reinit on context lost
    
    Some interconnect target modules such as otg and gpmc on am335x need a
    re-init after resume. As we also have PM runtime cases where the context
    may be lost, let's handle these all with cpu_pm.
    
    For the am335x resume path, we already have cpu_pm_resume() call
    cpu_pm_cluster_exit().
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>

commit cc371f6aa1cbda3b6ba0167d0afd8a8d1ebbba5d
Author: Kuogee Hsieh <khsieh@codeaurora.org>
Date:   Wed Aug 4 08:51:01 2021 -0700

    drm/msm/dp: update is_connected status base on sink count at dp_pm_resume()
    
    [ Upstream commit e8a767e04dbc7b201cb17ab99dca723a3488b6d4 ]
    
    Currently at dp_pm_resume() is_connected state is decided base on hpd connection
    status only. This will put is_connected in wrongly "true" state at the scenario
    that dongle attached to DUT but without hmdi cable connecting to it. Fix this
    problem by adding read sink count from dongle and decided is_connected state base
    on both sink count and hpd connection status.
    
    Changes in v2:
    -- remove dp_get_sink_count() cand call drm_dp_read_sink_count()
    
    Changes in v3:
    -- delete status local variable from dp_pm_resume()
    
    Changes in v4:
    -- delete un necessary comment at dp_pm_resume()
    
    Fixes: d9aa6571b28ba ("drm/msm/dp: check sink_count before update is_connected status")
    Signed-off-by: Kuogee Hsieh <khsieh@codeaurora.org>
    Link: https://lore.kernel.org/r/1628092261-32346-1-git-send-email-khsieh@codeaurora.org
    Tested-by: Stephen Boyd <swboyd@chromium.org>
    Reviewed-by: Stephen Boyd <swboyd@chromium.org>
    Signed-off-by: Dmitry Baryshkov <dmitry.baryshkov@linaro.org>
    Signed-off-by: Rob Clark <robdclark@chromium.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 51c8fbcfa1a230799b11eed303dbe0bc899901da
Author: Kuogee Hsieh <khsieh@codeaurora.org>
Date:   Wed Aug 4 08:51:01 2021 -0700

    drm/msm/dp: update is_connected status base on sink count at dp_pm_resume()
    
    [ Upstream commit e8a767e04dbc7b201cb17ab99dca723a3488b6d4 ]
    
    Currently at dp_pm_resume() is_connected state is decided base on hpd connection
    status only. This will put is_connected in wrongly "true" state at the scenario
    that dongle attached to DUT but without hmdi cable connecting to it. Fix this
    problem by adding read sink count from dongle and decided is_connected state base
    on both sink count and hpd connection status.
    
    Changes in v2:
    -- remove dp_get_sink_count() cand call drm_dp_read_sink_count()
    
    Changes in v3:
    -- delete status local variable from dp_pm_resume()
    
    Changes in v4:
    -- delete un necessary comment at dp_pm_resume()
    
    Fixes: d9aa6571b28ba ("drm/msm/dp: check sink_count before update is_connected status")
    Signed-off-by: Kuogee Hsieh <khsieh@codeaurora.org>
    Link: https://lore.kernel.org/r/1628092261-32346-1-git-send-email-khsieh@codeaurora.org
    Tested-by: Stephen Boyd <swboyd@chromium.org>
    Reviewed-by: Stephen Boyd <swboyd@chromium.org>
    Signed-off-by: Dmitry Baryshkov <dmitry.baryshkov@linaro.org>
    Signed-off-by: Rob Clark <robdclark@chromium.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 13be2efc390acd2a46a69a359f6efc00ca434599
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Mar 5 12:21:40 2021 +0000

    rtc: cmos: Disable irq around direct invocation of cmos_interrupt()
    
    As previously noted in commit 66e4f4a9cc38 ("rtc: cmos: Use
    spin_lock_irqsave() in cmos_interrupt()"):
    
    <4>[  254.192378] WARNING: inconsistent lock state
    <4>[  254.192384] 5.12.0-rc1-CI-CI_DRM_9834+ #1 Not tainted
    <4>[  254.192396] --------------------------------
    <4>[  254.192400] inconsistent {IN-HARDIRQ-W} -> {HARDIRQ-ON-W} usage.
    <4>[  254.192409] rtcwake/5309 [HC0[0]:SC0[0]:HE1:SE1] takes:
    <4>[  254.192429] ffffffff8263c5f8 (rtc_lock){?...}-{2:2}, at: cmos_interrupt+0x18/0x100
    <4>[  254.192481] {IN-HARDIRQ-W} state was registered at:
    <4>[  254.192488]   lock_acquire+0xd1/0x3d0
    <4>[  254.192504]   _raw_spin_lock+0x2a/0x40
    <4>[  254.192519]   cmos_interrupt+0x18/0x100
    <4>[  254.192536]   rtc_handler+0x1f/0xc0
    <4>[  254.192553]   acpi_ev_fixed_event_detect+0x109/0x13c
    <4>[  254.192574]   acpi_ev_sci_xrupt_handler+0xb/0x28
    <4>[  254.192596]   acpi_irq+0x13/0x30
    <4>[  254.192620]   __handle_irq_event_percpu+0x43/0x2c0
    <4>[  254.192641]   handle_irq_event_percpu+0x2b/0x70
    <4>[  254.192661]   handle_irq_event+0x2f/0x50
    <4>[  254.192680]   handle_fasteoi_irq+0x9e/0x150
    <4>[  254.192693]   __common_interrupt+0x76/0x140
    <4>[  254.192715]   common_interrupt+0x96/0xc0
    <4>[  254.192732]   asm_common_interrupt+0x1e/0x40
    <4>[  254.192750]   _raw_spin_unlock_irqrestore+0x38/0x60
    <4>[  254.192767]   resume_irqs+0xba/0xf0
    <4>[  254.192786]   dpm_resume_noirq+0x245/0x3d0
    <4>[  254.192811]   suspend_devices_and_enter+0x230/0xaa0
    <4>[  254.192835]   pm_suspend.cold.8+0x301/0x34a
    <4>[  254.192859]   state_store+0x7b/0xe0
    <4>[  254.192879]   kernfs_fop_write_iter+0x11d/0x1c0
    <4>[  254.192899]   new_sync_write+0x11d/0x1b0
    <4>[  254.192916]   vfs_write+0x265/0x390
    <4>[  254.192933]   ksys_write+0x5a/0xd0
    <4>[  254.192949]   do_syscall_64+0x33/0x80
    <4>[  254.192965]   entry_SYSCALL_64_after_hwframe+0x44/0xae
    <4>[  254.192986] irq event stamp: 43775
    <4>[  254.192994] hardirqs last  enabled at (43775): [<ffffffff81c00c42>] asm_sysvec_apic_timer_interrupt+0x12/0x20
    <4>[  254.193023] hardirqs last disabled at (43774): [<ffffffff81aa691a>] sysvec_apic_timer_interrupt+0xa/0xb0
    <4>[  254.193049] softirqs last  enabled at (42548): [<ffffffff81e00342>] __do_softirq+0x342/0x48e
    <4>[  254.193074] softirqs last disabled at (42543): [<ffffffff810b45fd>] irq_exit_rcu+0xad/0xd0
    <4>[  254.193101]
                      other info that might help us debug this:
    <4>[  254.193107]  Possible unsafe locking scenario:
    
    <4>[  254.193112]        CPU0
    <4>[  254.193117]        ----
    <4>[  254.193121]   lock(rtc_lock);
    <4>[  254.193137]   <Interrupt>
    <4>[  254.193142]     lock(rtc_lock);
    <4>[  254.193156]
                       *** DEADLOCK ***
    
    <4>[  254.193161] 6 locks held by rtcwake/5309:
    <4>[  254.193174]  #0: ffff888104861430 (sb_writers#5){.+.+}-{0:0}, at: ksys_write+0x5a/0xd0
    <4>[  254.193232]  #1: ffff88810f823288 (&of->mutex){+.+.}-{3:3}, at: kernfs_fop_write_iter+0xe7/0x1c0
    <4>[  254.193282]  #2: ffff888100cef3c0 (kn->active#285
    <7>[  254.192706] i915 0000:00:02.0: [drm:intel_modeset_setup_hw_state [i915]] [CRTC:51:pipe A] hw state readout: disabled
    <4>[  254.193307] ){.+.+}-{0:0}, at: kernfs_fop_write_iter+0xf0/0x1c0
    <4>[  254.193333]  #3: ffffffff82649fa8 (system_transition_mutex){+.+.}-{3:3}, at: pm_suspend.cold.8+0xce/0x34a
    <4>[  254.193387]  #4: ffffffff827a2108 (acpi_scan_lock){+.+.}-{3:3}, at: acpi_suspend_begin+0x47/0x70
    <4>[  254.193433]  #5: ffff8881019ea178 (&dev->mutex){....}-{3:3}, at: device_resume+0x68/0x1e0
    <4>[  254.193485]
                      stack backtrace:
    <4>[  254.193492] CPU: 1 PID: 5309 Comm: rtcwake Not tainted 5.12.0-rc1-CI-CI_DRM_9834+ #1
    <4>[  254.193514] Hardware name: Google Soraka/Soraka, BIOS MrChromebox-4.10 08/25/2019
    <4>[  254.193524] Call Trace:
    <4>[  254.193536]  dump_stack+0x7f/0xad
    <4>[  254.193567]  mark_lock.part.47+0x8ca/0xce0
    <4>[  254.193604]  __lock_acquire+0x39b/0x2590
    <4>[  254.193626]  ? asm_sysvec_apic_timer_interrupt+0x12/0x20
    <4>[  254.193660]  lock_acquire+0xd1/0x3d0
    <4>[  254.193677]  ? cmos_interrupt+0x18/0x100
    <4>[  254.193716]  _raw_spin_lock+0x2a/0x40
    <4>[  254.193735]  ? cmos_interrupt+0x18/0x100
    <4>[  254.193758]  cmos_interrupt+0x18/0x100
    <4>[  254.193785]  cmos_resume+0x2ac/0x2d0
    <4>[  254.193813]  ? acpi_pm_set_device_wakeup+0x1f/0x110
    <4>[  254.193842]  ? pnp_bus_suspend+0x10/0x10
    <4>[  254.193864]  pnp_bus_resume+0x5e/0x90
    <4>[  254.193885]  dpm_run_callback+0x5f/0x240
    <4>[  254.193914]  device_resume+0xb2/0x1e0
    <4>[  254.193942]  ? pm_dev_err+0x25/0x25
    <4>[  254.193974]  dpm_resume+0xea/0x3f0
    <4>[  254.194005]  dpm_resume_end+0x8/0x10
    <4>[  254.194030]  suspend_devices_and_enter+0x29b/0xaa0
    <4>[  254.194066]  pm_suspend.cold.8+0x301/0x34a
    <4>[  254.194094]  state_store+0x7b/0xe0
    <4>[  254.194124]  kernfs_fop_write_iter+0x11d/0x1c0
    <4>[  254.194151]  new_sync_write+0x11d/0x1b0
    <4>[  254.194183]  vfs_write+0x265/0x390
    <4>[  254.194207]  ksys_write+0x5a/0xd0
    <4>[  254.194232]  do_syscall_64+0x33/0x80
    <4>[  254.194251]  entry_SYSCALL_64_after_hwframe+0x44/0xae
    <4>[  254.194274] RIP: 0033:0x7f07d79691e7
    <4>[  254.194293] Code: 64 89 02 48 c7 c0 ff ff ff ff eb bb 0f 1f 80 00 00 00 00 f3 0f 1e fa 64 8b 04 25 18 00 00 00 85 c0 75 10 b8 01 00 00 00 0f 05 <48> 3d 00 f0 ff ff 77 51 c3 48 83 ec 28 48 89 54 24 18 48 89 74 24
    <4>[  254.194312] RSP: 002b:00007ffd9cc2c768 EFLAGS: 00000246 ORIG_RAX: 0000000000000001
    <4>[  254.194337] RAX: ffffffffffffffda RBX: 0000000000000004 RCX: 00007f07d79691e7
    <4>[  254.194352] RDX: 0000000000000004 RSI: 0000556ebfc63590 RDI: 000000000000000b
    <4>[  254.194366] RBP: 0000556ebfc63590 R08: 0000000000000000 R09: 0000000000000004
    <4>[  254.194379] R10: 0000556ebf0ec2a6 R11: 0000000000000246 R12: 0000000000000004
    
    which breaks S3-resume on fi-kbl-soraka presumably as that's slow enough
    to trigger the alarm during the suspend.
    
    Fixes: 6950d046eb6e ("rtc: cmos: Replace spin_lock_irqsave with spin_lock in hard IRQ")
    References: 66e4f4a9cc38 ("rtc: cmos: Use spin_lock_irqsave() in cmos_interrupt()"):
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Xiaofei Tan <tanxiaofei@huawei.com>
    Cc: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Cc: Alessandro Zummo <a.zummo@towertech.it>
    Cc: Ville Syrjl <ville.syrjala@linux.intel.com>
    Reviewed-by: Ville Syrjl <ville.syrjala@linux.intel.com>
    Signed-off-by: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Link: https://lore.kernel.org/r/20210305122140.28774-1-chris@chris-wilson.co.uk

commit 26ae419cd9eca4268c267a1910bdac4ae6ef4896
Author: Kuogee Hsieh <khsieh@codeaurora.org>
Date:   Tue Aug 10 08:29:22 2021 -0700

    drm/msm/dp: add drm debug logs to dp_pm_resume/suspend
    
    Changes in V2:
    -- correct Fixes text
    -- drop commit text
    
    Fixes: 601f0479c583 ("drm/msm/dp: add logs across DP driver for ease of debugging")
    Signed-off-by: Kuogee Hsieh <khsieh@codeaurora.org>
    Reviewed-by: Stephen Boyd <swboyd@chromium.org>
    Link: https://lore.kernel.org/r/1628609362-2109-1-git-send-email-khsieh@codeaurora.org
    Signed-off-by: Rob Clark <robdclark@chromium.org>

commit e8a767e04dbc7b201cb17ab99dca723a3488b6d4
Author: Kuogee Hsieh <khsieh@codeaurora.org>
Date:   Wed Aug 4 08:51:01 2021 -0700

    drm/msm/dp: update is_connected status base on sink count at dp_pm_resume()
    
    Currently at dp_pm_resume() is_connected state is decided base on hpd connection
    status only. This will put is_connected in wrongly "true" state at the scenario
    that dongle attached to DUT but without hmdi cable connecting to it. Fix this
    problem by adding read sink count from dongle and decided is_connected state base
    on both sink count and hpd connection status.
    
    Changes in v2:
    -- remove dp_get_sink_count() cand call drm_dp_read_sink_count()
    
    Changes in v3:
    -- delete status local variable from dp_pm_resume()
    
    Changes in v4:
    -- delete un necessary comment at dp_pm_resume()
    
    Fixes: d9aa6571b28ba ("drm/msm/dp: check sink_count before update is_connected status")
    Signed-off-by: Kuogee Hsieh <khsieh@codeaurora.org>
    Link: https://lore.kernel.org/r/1628092261-32346-1-git-send-email-khsieh@codeaurora.org
    Tested-by: Stephen Boyd <swboyd@chromium.org>
    Reviewed-by: Stephen Boyd <swboyd@chromium.org>
    Signed-off-by: Dmitry Baryshkov <dmitry.baryshkov@linaro.org>
    Signed-off-by: Rob Clark <robdclark@chromium.org>

commit 764a5bc89b12b82c18ce7ca5d7c1b10dd748a440
Merge: c71a2f65e7a1 d28e2568ac26
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jul 29 22:10:05 2021 -0700

    Merge tag 'drm-fixes-2021-07-30' of git://anongit.freedesktop.org/drm/drm
    
    Pull drm fixes from Dave Airlie:
     "Regular drm fixes pull, seems about the right size, lots of small
      fixes across the board, mostly amdgpu, but msm and i915 are in there
      along with panel and ttm.
    
      amdgpu:
       - Fix resource leak in an error path
       - Avoid stack contents exposure in error path
       - pmops check fix for S0ix vs S3
       - DCN 2.1 display fixes
       - DCN 2.0 display fix
       - Backlight control fix for laptops with HDR panels
       - Maintainers updates
    
      i915:
       - Fix vbt port mask
       - Fix around reading the right DSC disable fuse in display_ver 10
       - Split display version 9 and 10 in intel_setup_outputs
    
      msm:
       - iommu fault display fix
       - misc dp compliance fixes
       - dpu reg sizing fix
    
      panel:
       - Fix bpc for ytc700tlag_05_201c
    
      ttm:
       - debugfs init fixes"
    
    * tag 'drm-fixes-2021-07-30' of git://anongit.freedesktop.org/drm/drm:
      maintainers: add bugs and chat URLs for amdgpu
      drm/amdgpu/display: only enable aux backlight control for OLED panels
      drm/amd/display: ensure dentist display clock update finished in DCN20
      drm/amd/display: Add missing DCN21 IP parameter
      drm/amd/display: Guard DST_Y_PREFETCH register overflow in DCN21
      drm/amdgpu: Check pmops for desired suspend state
      drm/msm/dp: Initialize dp->aux->drm_dev before registration
      drm/msm/dp: signal audio plugged change at dp_pm_resume
      drm/msm/dp: Initialize the INTF_CONFIG register
      drm/msm/dp: use dp_ctrl_off_link_stream during PHY compliance test run
      drm/msm: Fix display fault handling
      drm/msm/dpu: Fix sm8250_mdp register length
      drm/amdgpu: Avoid printing of stack contents on firmware load error
      drm/amdgpu: Fix resource leak on probe error path
      drm/i915/display: split DISPLAY_VER 9 and 10 in intel_setup_outputs()
      drm/i915: fix not reading DSC disable fuse in GLK
      drm/i915/bios: Fix ports mask
      drm/panel: panel-simple: Fix proper bpc for ytc700tlag_05_201c
      drm/ttm: Initialize debugfs from ttm_global_init()

commit afc9b8b6bab8d3d3a9ae67e1d64093ad626c92a0
Author: Kuogee Hsieh <khsieh@codeaurora.org>
Date:   Fri Jul 23 09:55:39 2021 -0700

    drm/msm/dp: signal audio plugged change at dp_pm_resume
    
    There is a scenario that dp cable is unplugged from DUT during system
    suspended  will cause audio option state does not match real connection
    state. Fix this problem by Signaling audio plugged change with realtime
    connection status at dp_pm_resume() so that audio option will be in
    correct state after system resumed.
    
    Changes in V2:
    -- correct Fixes tag commit id.
    
    Fixes: f591dbb5fb8c ("drm/msm/dp: power off DP phy at suspend")
    Signed-off-by: Kuogee Hsieh <khsieh@codeaurora.org>
    Reviewed-by: Stephen Boyd <swboyd@chromium.org>
    Link: https://lore.kernel.org/r/1627059339-12142-1-git-send-email-khsieh@codeaurora.org
    Signed-off-by: Rob Clark <robdclark@chromium.org>

commit 17992ed2fb98e4c036c5af08564587d6459b84ff
Author: Kuogee Hsieh <khsieh@codeaurora.org>
Date:   Fri May 21 15:25:30 2021 -0700

    drm/msm/dp: handle irq_hpd with sink_count = 0 correctly
    
    [ Upstream commit f21c8a276c2daddddf58d483b49b01d0603f0316 ]
    
    irq_hpd interrupt should be handled after dongle plugged in and
    before dongle unplugged. Hence irq_hpd interrupt is enabled at
    the end of the plugin handle and disabled at the beginning of
    unplugged handle. Current irq_hpd with sink_count = 0 is wrongly
    handled same as the dongle unplugged which tears down the mainlink
    and disables the phy. This patch fixes this problem by only tearing
    down the mainlink but keeping phy enabled at irq_hpd with
    sink_count = 0 handle so that next irq_hpd with sink_count =1 can be
    handled by setup mainlink only. This patch also set dongle into D3
    (power off) state at end of handling irq_hpd with sink_count = 0.
    
    Changes in v2:
    -- add ctrl->phy_Power_count
    
    Changes in v3:
    -- del ctrl->phy_Power_count
    -- add phy_power_off to dp_ctrl_off_link_stream()
    
    Changes in v4:
    -- return immediately if clock disable failed at dp_ctrl_off_link_stream()
    
    Changes in v5:
    -- set dongle to D3 (power off) state at dp_ctrl_off_link_stream()
    
    Changes in v6:
    -- add Fixes tag
    
    Fixes: ea9f337ce81e ("drm/msm/dp: reset dp controller only at boot up and pm_resume")
    Signed-off-by: Kuogee Hsieh <khsieh@codeaurora.org>
    Tested-by: Stephen Boyd <swboyd@chromium.org>
    Reviewed-by: Stephen Boyd <swboyd@chromium.org>
    Link: https://lore.kernel.org/r/1621635930-30161-1-git-send-email-khsieh@codeaurora.org
    Signed-off-by: Rob Clark <robdclark@chromium.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit c687e04407bd1efef206d7278bdacdc7c6fbb1c8
Author: Kuogee Hsieh <khsieh@codeaurora.org>
Date:   Fri May 21 15:25:30 2021 -0700

    drm/msm/dp: handle irq_hpd with sink_count = 0 correctly
    
    [ Upstream commit f21c8a276c2daddddf58d483b49b01d0603f0316 ]
    
    irq_hpd interrupt should be handled after dongle plugged in and
    before dongle unplugged. Hence irq_hpd interrupt is enabled at
    the end of the plugin handle and disabled at the beginning of
    unplugged handle. Current irq_hpd with sink_count = 0 is wrongly
    handled same as the dongle unplugged which tears down the mainlink
    and disables the phy. This patch fixes this problem by only tearing
    down the mainlink but keeping phy enabled at irq_hpd with
    sink_count = 0 handle so that next irq_hpd with sink_count =1 can be
    handled by setup mainlink only. This patch also set dongle into D3
    (power off) state at end of handling irq_hpd with sink_count = 0.
    
    Changes in v2:
    -- add ctrl->phy_Power_count
    
    Changes in v3:
    -- del ctrl->phy_Power_count
    -- add phy_power_off to dp_ctrl_off_link_stream()
    
    Changes in v4:
    -- return immediately if clock disable failed at dp_ctrl_off_link_stream()
    
    Changes in v5:
    -- set dongle to D3 (power off) state at dp_ctrl_off_link_stream()
    
    Changes in v6:
    -- add Fixes tag
    
    Fixes: ea9f337ce81e ("drm/msm/dp: reset dp controller only at boot up and pm_resume")
    Signed-off-by: Kuogee Hsieh <khsieh@codeaurora.org>
    Tested-by: Stephen Boyd <swboyd@chromium.org>
    Reviewed-by: Stephen Boyd <swboyd@chromium.org>
    Link: https://lore.kernel.org/r/1621635930-30161-1-git-send-email-khsieh@codeaurora.org
    Signed-off-by: Rob Clark <robdclark@chromium.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit cac6f1b87b1f7feafb7db349a2b1ca86634bc950
Author: YueHaibing <yuehaibing@huawei.com>
Date:   Fri Jun 18 17:35:51 2021 +0800

    crypto: sl3516 - Fix build warning without CONFIG_PM
    
    drivers/crypto/gemini/sl3516-ce-core.c:345:12:
     warning: sl3516_ce_pm_resume defined but not used [-Wunused-function]
     static int sl3516_ce_pm_resume(struct device *dev)
                ^~~~~~~~~~~~~~~~~~~
    
    The driver needs PM, otherwise clock and resets are never set.
    So make it depends on PM to fix this warning.
    
    Signed-off-by: YueHaibing <yuehaibing@huawei.com>
    Suggested-by: LABBE Corentin <clabbe@baylibre.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

commit f21c8a276c2daddddf58d483b49b01d0603f0316
Author: Kuogee Hsieh <khsieh@codeaurora.org>
Date:   Fri May 21 15:25:30 2021 -0700

    drm/msm/dp: handle irq_hpd with sink_count = 0 correctly
    
    irq_hpd interrupt should be handled after dongle plugged in and
    before dongle unplugged. Hence irq_hpd interrupt is enabled at
    the end of the plugin handle and disabled at the beginning of
    unplugged handle. Current irq_hpd with sink_count = 0 is wrongly
    handled same as the dongle unplugged which tears down the mainlink
    and disables the phy. This patch fixes this problem by only tearing
    down the mainlink but keeping phy enabled at irq_hpd with
    sink_count = 0 handle so that next irq_hpd with sink_count =1 can be
    handled by setup mainlink only. This patch also set dongle into D3
    (power off) state at end of handling irq_hpd with sink_count = 0.
    
    Changes in v2:
    -- add ctrl->phy_Power_count
    
    Changes in v3:
    -- del ctrl->phy_Power_count
    -- add phy_power_off to dp_ctrl_off_link_stream()
    
    Changes in v4:
    -- return immediately if clock disable failed at dp_ctrl_off_link_stream()
    
    Changes in v5:
    -- set dongle to D3 (power off) state at dp_ctrl_off_link_stream()
    
    Changes in v6:
    -- add Fixes tag
    
    Fixes: ea9f337ce81e ("drm/msm/dp: reset dp controller only at boot up and pm_resume")
    Signed-off-by: Kuogee Hsieh <khsieh@codeaurora.org>
    Tested-by: Stephen Boyd <swboyd@chromium.org>
    Reviewed-by: Stephen Boyd <swboyd@chromium.org>
    Link: https://lore.kernel.org/r/1621635930-30161-1-git-send-email-khsieh@codeaurora.org
    Signed-off-by: Rob Clark <robdclark@chromium.org>

commit 8c51c9b59a103fe7f4ab0c81ce9a202af7f1ece1
Merge: d78f4549d35b 7cd04c863f9e
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Thu Jun 17 18:20:56 2021 +0200

    Merge tag 'iio-for-5.14b' of https://git.kernel.org/pub/scm/linux/kernel/git/jic23/iio into staging-next
    
    Jonathan writes:
    
    Second set of Counter and IIO new device support, cleanups etc for 5.14
    
    Counter
    ------
    
    First part of general rework of counter subsystem to add a chrdev interface
    for event drive data capture.  Most of it will hopefully land next cycle.
    
    * Consolidate documentation to avoid multiple copies of same docs in per
      device files.
    * Constify various arrays etc across subsystem.
    * 104-quad-8:
      - Annotate the module config parameter to avoid using it when kernel is
        locked down.
      - Spelling and trivial comment drops etc
    * Intel QEP
      - Follow up cleanups of trivial stuff from initial patch series.
    
    IIO
    ---
    
    Includes some cleanups as part of two ongoing audits
    - runtime pm usage in IIO.
    - Insufficient alignment on buffers passed to
    iio_push_to_buffers_with_timstamp()
    
    New device support
    * bosch,bmc150
      - Add ID for BMA253
    
    Minor features / cleanups / minor fixes / late breaking fixes
    * iio_push_to_buffers_with_timestamp() alignment fixes.
      This set includes those where the best option is to mark the buffer as
      __aligned(8). Normally this choice was made because there is too high a degree
      of possible variation in number of channels enabled to be able to guarantee
      the timestamp was always in the same location.  This ruled out the more
      obvious structure form used in other drivers. Only one small class of
      related issues have patches under review and we can finally tighten up the
      explicit rules to reflect the hidden requirement.
    
    * dummy
      - Kconfig build dependency fix.
    * adi,ad_sigma_delta
      - General devm related simplifications for these devices.
    * adi,adf4350
      - Fix some missing cleanup on error path.
    * adi,adis, ADC drivers.
      - Clean out unneeded spi_set_drvdata()
    * ams-taos,tcs3472
      - Fix a potential free of an irq that was never allocated.
    * atlas,sensor
      - Drop unbalanced runtime pm call and use pm_runtime_resume_and_get()
        to reduce boilerplate.
    * bosch,bma180
      - Fix bandwidth register values used.
    * bosch,bmc150
      - Fix wrong pointer being dereferenced in remove.
      - Stop device trying unregister itself rather than the second device.
      - Refactor ACPI second device handing.
      - Add support for DUAL250E ACPI HID.
      - Move some stuff into the header to enable following patches to not
        add additional accessor functions. Drop existing accessors.
      - Add support for hinge angle setting with DUAL250E ACPI DSM to ensure
        keyboard and touchpad enabled correctly when in laptop mode and disabled
        otherwise.
      - Add label attr for the multiple sensor locations with DUAL250E ACPI HID.
      - Fix scale units for bma222
      - Various reordering of devices supported lists to be alphabetical order.
      - Drop unnecessary duplicated chip_info_tbl[] entries.
      - Document that some devices have two interrupts, even if not currently
        used by the driver.
      - Move bma254 over to the bma255 driver.
      - Move to more consistent scale values, based on assumption that some
        datasheets use lower precision in their calculations in comparison
        with others.
    * hid-sensors
      - Use namespaces for exported symbols.
      - Update includes using manual inspection of output of the
        include-what-you-use tool.
    * invensense,icp10100
      - Drop unbalanced runtime pm put. Use pm_runtime_resume_and_get() to cleanly
        handle potential error.
    * invensense,mpu6050
      - Drop use of %hhx string formatting.
      - runtime pm boilerplate removal and drop an unbalanced call in remove.
    * liteon,ltr501
      - Fix inaccurate volatile register list.
      - Fix wrong mode bit.
      - Add a missing leXX_to_cpu() conversion.
      - Mark ltr501_chip_info structure as const.
    * pulsed-light-lidar:
      - Boilerplate removal using runtime_pm_resume_and_get()
    * scmi-sensors
      - Formatting of SPDX fix.
    * silabs,si1133
      - Fix a string format warning.
      - Drop remaining uses of %hhx string formatting.
    * silabs,si1145
      - Drop use of %hhx string formatting.
    * ti,ads1015
      - Drop unbalanced runtime pm call in remove and reduce boilerplate.
    
    * tag 'iio-for-5.14b' of https://git.kernel.org/pub/scm/linux/kernel/git/jic23/iio: (76 commits)
      iio: light: tcs3472: do not free unallocated IRQ
      iio: accel: bmc150: Use more consistent and accurate scale values
      iio: hid-sensors: Update header includes
      iio: pressure: icp10100: Balance runtime pm + use pm_runtime_resume_and_get()
      iio: prox: pulsed-light-v2: Use pm_runtime_resume_and_get()
      iio: chemical: atlas-sensor: Balance runtime pm + pm_runtime_resume_and_get()
      iio: adc: ads1015: Balance runtime pm + pm_runtime_resume_and_get()
      iio: imu: mpu6050: Balance runtime pm + use pm_runtime_resume_and_get()
      iio: hid-sensors: lighten exported symbols by moving to IIO_HID namespace
      iio: prox: isl29501: Fix buffer alignment in iio_push_to_buffers_with_timestamp()
      iio: light: vcnl4035: Fix buffer alignment in iio_push_to_buffers_with_timestamp()
      iio: light: vcnl4000: Fix buffer alignment in iio_push_to_buffers_with_timestamp()
      iio: magn: rm3100: Fix alignment of buffer in iio_push_to_buffers_with_timestamp()
      iio: adc: ti-ads8688: Fix alignment of buffer in iio_push_to_buffers_with_timestamp()
      iio: adc: mxs-lradc: Fix buffer alignment in iio_push_to_buffers_with_timestamp()
      iio: adc: hx711: Fix buffer alignment in iio_push_to_buffers_with_timestamp()
      iio: adc: at91-sama5d2: Fix buffer alignment in iio_push_to_buffers_with_timestamp()
      counter: interrupt-cnt: Add const qualifier for actions_list array
      iio: ltr501: mark ltr501_chip_info as const
      iio: ltr501: ltr501_read_ps(): add missing endianness conversion
      ...

commit 6485fc18faa01e8845b1e5bb55118e633f84d1f2
Author: Mario Limonciello <mario.limonciello@amd.com>
Date:   Wed Jun 9 13:40:18 2021 -0500

    ACPI: Add quirks for AMD Renoir/Lucienne CPUs to force the D3 hint
    
    AMD systems from Renoir and Lucienne require that the NVME controller
    is put into D3 over a Modern Standby / suspend-to-idle
    cycle.  This is "typically" accomplished using the `StorageD3Enable`
    property in the _DSD, but this property was introduced after many
    of these systems launched and most OEM systems don't have it in
    their BIOS.
    
    On AMD Renoir without these drives going into D3 over suspend-to-idle
    the resume will fail with the NVME controller being reset and a trace
    like this in the kernel logs:
    ```
    [   83.556118] nvme nvme0: I/O 161 QID 2 timeout, aborting
    [   83.556178] nvme nvme0: I/O 162 QID 2 timeout, aborting
    [   83.556187] nvme nvme0: I/O 163 QID 2 timeout, aborting
    [   83.556196] nvme nvme0: I/O 164 QID 2 timeout, aborting
    [   95.332114] nvme nvme0: I/O 25 QID 0 timeout, reset controller
    [   95.332843] nvme nvme0: Abort status: 0x371
    [   95.332852] nvme nvme0: Abort status: 0x371
    [   95.332856] nvme nvme0: Abort status: 0x371
    [   95.332859] nvme nvme0: Abort status: 0x371
    [   95.332909] PM: dpm_run_callback(): pci_pm_resume+0x0/0xe0 returns -16
    [   95.332936] nvme 0000:03:00.0: PM: failed to resume async: error -16
    ```
    
    The Microsoft documentation for StorageD3Enable mentioned that Windows has
    a hardcoded allowlist for D3 support, which was used for these platforms.
    Introduce quirks to hardcode them for Linux as well.
    
    As this property is now "standardized", OEM systems using AMD Cezanne and
    newer APU's have adopted this property, and quirks like this should not be
    necessary.
    
    CC: Shyam-sundar S-k <Shyam-sundar.S-k@amd.com>
    CC: Alexander Deucher <Alexander.Deucher@amd.com>
    CC: Prike Liang <prike.liang@amd.com>
    Link: https://docs.microsoft.com/en-us/windows-hardware/design/component-guidelines/power-management-for-storage-hardware-devices-intro
    Signed-off-by: Mario Limonciello <mario.limonciello@amd.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Tested-by: Julian Sikorski <belegdol@gmail.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

commit 628cf5277a3579dc80c937127a77b8fc27ed7997
Author: Kuogee Hsieh <khsieh@codeaurora.org>
Date:   Wed Apr 21 16:37:35 2021 -0700

    drm/msm/dp: check sink_count before update is_connected status
    
    commit d9aa6571b28ba0022de1e48801ff03a1854c7ef2 upstream.
    
    Link status is different from display connected status in the case
    of something like an Apple dongle where the type-c plug can be
    connected, and therefore the link is connected, but no sink is
    connected until an HDMI cable is plugged into the dongle.
    The sink_count of DPCD of dongle will increase to 1 once an HDMI
    cable is plugged into the dongle so that display connected status
    will become true. This checking also apply at pm_resume.
    
    Changes in v4:
    -- none
    
    Fixes: 94e58e2d06e3 ("drm/msm/dp: reset dp controller only at boot up and pm_resume")
    Reported-by: Stephen Boyd <swboyd@chromium.org>
    Reviewed-by: Stephen Boyd <swboyd@chromium.org>
    Tested-by: Stephen Boyd <swboyd@chromium.org>
    Signed-off-by: Kuogee Hsieh <khsieh@codeaurora.org>
    Fixes: 8ede2ecc3e5e ("drm/msm/dp: Add DP compliance tests on Snapdragon Chipsets")
    Link: https://lore.kernel.org/r/1619048258-8717-2-git-send-email-khsieh@codeaurora.org
    Signed-off-by: Rob Clark <robdclark@chromium.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 8c6d2e0ee501dc34ec0e7b5126783f2f51fca483
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed May 5 14:09:15 2021 +0300

    PM: runtime: Fix unpaired parent child_count for force_resume
    
    commit c745253e2a691a40c66790defe85c104a887e14a upstream.
    
    As pm_runtime_need_not_resume() relies also on usage_count, it can return
    a different value in pm_runtime_force_suspend() compared to when called in
    pm_runtime_force_resume(). Different return values can happen if anything
    calls PM runtime functions in between, and causes the parent child_count
    to increase on every resume.
    
    So far I've seen the issue only for omapdrm that does complicated things
    with PM runtime calls during system suspend for legacy reasons:
    
    omap_atomic_commit_tail() for omapdrm.0
     dispc_runtime_get()
      wakes up 58000000.dss as it's the dispc parent
       dispc_runtime_resume()
        rpm_resume() increases parent child_count
     dispc_runtime_put() won't idle, PM runtime suspend blocked
    pm_runtime_force_suspend() for 58000000.dss, !pm_runtime_need_not_resume()
     __update_runtime_status()
    system suspended
    pm_runtime_force_resume() for 58000000.dss, pm_runtime_need_not_resume()
     pm_runtime_enable() only called because of pm_runtime_need_not_resume()
    omap_atomic_commit_tail() for omapdrm.0
     dispc_runtime_get()
      wakes up 58000000.dss as it's the dispc parent
       dispc_runtime_resume()
        rpm_resume() increases parent child_count
     dispc_runtime_put() won't idle, PM runtime suspend blocked
    ...
    rpm_suspend for 58000000.dss but parent child_count is now unbalanced
    
    Let's fix the issue by adding a flag for needs_force_resume and use it in
    pm_runtime_force_resume() instead of pm_runtime_need_not_resume().
    
    Additionally omapdrm system suspend could be simplified later on to avoid
    lots of unnecessary PM runtime calls and the complexity it adds. The
    driver can just use internal functions that are shared between the PM
    runtime and system suspend related functions.
    
    Fixes: 4918e1f87c5f ("PM / runtime: Rework pm_runtime_force_suspend/resume()")
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Tested-by: Tomi Valkeinen <tomi.valkeinen@ideasonboard.com>
    Cc: 4.16+ <stable@vger.kernel.org> # 4.16+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 5c5b4880fe393031c82b86c37872eeee1adebeac
Author: Kuogee Hsieh <khsieh@codeaurora.org>
Date:   Wed Apr 21 16:37:35 2021 -0700

    drm/msm/dp: check sink_count before update is_connected status
    
    commit d9aa6571b28ba0022de1e48801ff03a1854c7ef2 upstream.
    
    Link status is different from display connected status in the case
    of something like an Apple dongle where the type-c plug can be
    connected, and therefore the link is connected, but no sink is
    connected until an HDMI cable is plugged into the dongle.
    The sink_count of DPCD of dongle will increase to 1 once an HDMI
    cable is plugged into the dongle so that display connected status
    will become true. This checking also apply at pm_resume.
    
    Changes in v4:
    -- none
    
    Fixes: 94e58e2d06e3 ("drm/msm/dp: reset dp controller only at boot up and pm_resume")
    Reported-by: Stephen Boyd <swboyd@chromium.org>
    Reviewed-by: Stephen Boyd <swboyd@chromium.org>
    Tested-by: Stephen Boyd <swboyd@chromium.org>
    Signed-off-by: Kuogee Hsieh <khsieh@codeaurora.org>
    Fixes: 8ede2ecc3e5e ("drm/msm/dp: Add DP compliance tests on Snapdragon Chipsets")
    Link: https://lore.kernel.org/r/1619048258-8717-2-git-send-email-khsieh@codeaurora.org
    Signed-off-by: Rob Clark <robdclark@chromium.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit b7fefdce0ed1841291a6f56fef9c9f15190b8d85
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed May 5 14:09:15 2021 +0300

    PM: runtime: Fix unpaired parent child_count for force_resume
    
    commit c745253e2a691a40c66790defe85c104a887e14a upstream.
    
    As pm_runtime_need_not_resume() relies also on usage_count, it can return
    a different value in pm_runtime_force_suspend() compared to when called in
    pm_runtime_force_resume(). Different return values can happen if anything
    calls PM runtime functions in between, and causes the parent child_count
    to increase on every resume.
    
    So far I've seen the issue only for omapdrm that does complicated things
    with PM runtime calls during system suspend for legacy reasons:
    
    omap_atomic_commit_tail() for omapdrm.0
     dispc_runtime_get()
      wakes up 58000000.dss as it's the dispc parent
       dispc_runtime_resume()
        rpm_resume() increases parent child_count
     dispc_runtime_put() won't idle, PM runtime suspend blocked
    pm_runtime_force_suspend() for 58000000.dss, !pm_runtime_need_not_resume()
     __update_runtime_status()
    system suspended
    pm_runtime_force_resume() for 58000000.dss, pm_runtime_need_not_resume()
     pm_runtime_enable() only called because of pm_runtime_need_not_resume()
    omap_atomic_commit_tail() for omapdrm.0
     dispc_runtime_get()
      wakes up 58000000.dss as it's the dispc parent
       dispc_runtime_resume()
        rpm_resume() increases parent child_count
     dispc_runtime_put() won't idle, PM runtime suspend blocked
    ...
    rpm_suspend for 58000000.dss but parent child_count is now unbalanced
    
    Let's fix the issue by adding a flag for needs_force_resume and use it in
    pm_runtime_force_resume() instead of pm_runtime_need_not_resume().
    
    Additionally omapdrm system suspend could be simplified later on to avoid
    lots of unnecessary PM runtime calls and the complexity it adds. The
    driver can just use internal functions that are shared between the PM
    runtime and system suspend related functions.
    
    Fixes: 4918e1f87c5f ("PM / runtime: Rework pm_runtime_force_suspend/resume()")
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Tested-by: Tomi Valkeinen <tomi.valkeinen@ideasonboard.com>
    Cc: 4.16+ <stable@vger.kernel.org> # 4.16+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 182f1f72af2e6803f1470a7e16a76ef0c63cc124
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed May 5 14:09:15 2021 +0300

    PM: runtime: Fix unpaired parent child_count for force_resume
    
    commit c745253e2a691a40c66790defe85c104a887e14a upstream.
    
    As pm_runtime_need_not_resume() relies also on usage_count, it can return
    a different value in pm_runtime_force_suspend() compared to when called in
    pm_runtime_force_resume(). Different return values can happen if anything
    calls PM runtime functions in between, and causes the parent child_count
    to increase on every resume.
    
    So far I've seen the issue only for omapdrm that does complicated things
    with PM runtime calls during system suspend for legacy reasons:
    
    omap_atomic_commit_tail() for omapdrm.0
     dispc_runtime_get()
      wakes up 58000000.dss as it's the dispc parent
       dispc_runtime_resume()
        rpm_resume() increases parent child_count
     dispc_runtime_put() won't idle, PM runtime suspend blocked
    pm_runtime_force_suspend() for 58000000.dss, !pm_runtime_need_not_resume()
     __update_runtime_status()
    system suspended
    pm_runtime_force_resume() for 58000000.dss, pm_runtime_need_not_resume()
     pm_runtime_enable() only called because of pm_runtime_need_not_resume()
    omap_atomic_commit_tail() for omapdrm.0
     dispc_runtime_get()
      wakes up 58000000.dss as it's the dispc parent
       dispc_runtime_resume()
        rpm_resume() increases parent child_count
     dispc_runtime_put() won't idle, PM runtime suspend blocked
    ...
    rpm_suspend for 58000000.dss but parent child_count is now unbalanced
    
    Let's fix the issue by adding a flag for needs_force_resume and use it in
    pm_runtime_force_resume() instead of pm_runtime_need_not_resume().
    
    Additionally omapdrm system suspend could be simplified later on to avoid
    lots of unnecessary PM runtime calls and the complexity it adds. The
    driver can just use internal functions that are shared between the PM
    runtime and system suspend related functions.
    
    Fixes: 4918e1f87c5f ("PM / runtime: Rework pm_runtime_force_suspend/resume()")
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Tested-by: Tomi Valkeinen <tomi.valkeinen@ideasonboard.com>
    Cc: 4.16+ <stable@vger.kernel.org> # 4.16+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 6c799f6c742718ca574d13d9b3d40592730f62c0
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed May 5 14:09:15 2021 +0300

    PM: runtime: Fix unpaired parent child_count for force_resume
    
    commit c745253e2a691a40c66790defe85c104a887e14a upstream.
    
    As pm_runtime_need_not_resume() relies also on usage_count, it can return
    a different value in pm_runtime_force_suspend() compared to when called in
    pm_runtime_force_resume(). Different return values can happen if anything
    calls PM runtime functions in between, and causes the parent child_count
    to increase on every resume.
    
    So far I've seen the issue only for omapdrm that does complicated things
    with PM runtime calls during system suspend for legacy reasons:
    
    omap_atomic_commit_tail() for omapdrm.0
     dispc_runtime_get()
      wakes up 58000000.dss as it's the dispc parent
       dispc_runtime_resume()
        rpm_resume() increases parent child_count
     dispc_runtime_put() won't idle, PM runtime suspend blocked
    pm_runtime_force_suspend() for 58000000.dss, !pm_runtime_need_not_resume()
     __update_runtime_status()
    system suspended
    pm_runtime_force_resume() for 58000000.dss, pm_runtime_need_not_resume()
     pm_runtime_enable() only called because of pm_runtime_need_not_resume()
    omap_atomic_commit_tail() for omapdrm.0
     dispc_runtime_get()
      wakes up 58000000.dss as it's the dispc parent
       dispc_runtime_resume()
        rpm_resume() increases parent child_count
     dispc_runtime_put() won't idle, PM runtime suspend blocked
    ...
    rpm_suspend for 58000000.dss but parent child_count is now unbalanced
    
    Let's fix the issue by adding a flag for needs_force_resume and use it in
    pm_runtime_force_resume() instead of pm_runtime_need_not_resume().
    
    Additionally omapdrm system suspend could be simplified later on to avoid
    lots of unnecessary PM runtime calls and the complexity it adds. The
    driver can just use internal functions that are shared between the PM
    runtime and system suspend related functions.
    
    Fixes: 4918e1f87c5f ("PM / runtime: Rework pm_runtime_force_suspend/resume()")
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Tested-by: Tomi Valkeinen <tomi.valkeinen@ideasonboard.com>
    Cc: 4.16+ <stable@vger.kernel.org> # 4.16+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit c745253e2a691a40c66790defe85c104a887e14a
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed May 5 14:09:15 2021 +0300

    PM: runtime: Fix unpaired parent child_count for force_resume
    
    As pm_runtime_need_not_resume() relies also on usage_count, it can return
    a different value in pm_runtime_force_suspend() compared to when called in
    pm_runtime_force_resume(). Different return values can happen if anything
    calls PM runtime functions in between, and causes the parent child_count
    to increase on every resume.
    
    So far I've seen the issue only for omapdrm that does complicated things
    with PM runtime calls during system suspend for legacy reasons:
    
    omap_atomic_commit_tail() for omapdrm.0
     dispc_runtime_get()
      wakes up 58000000.dss as it's the dispc parent
       dispc_runtime_resume()
        rpm_resume() increases parent child_count
     dispc_runtime_put() won't idle, PM runtime suspend blocked
    pm_runtime_force_suspend() for 58000000.dss, !pm_runtime_need_not_resume()
     __update_runtime_status()
    system suspended
    pm_runtime_force_resume() for 58000000.dss, pm_runtime_need_not_resume()
     pm_runtime_enable() only called because of pm_runtime_need_not_resume()
    omap_atomic_commit_tail() for omapdrm.0
     dispc_runtime_get()
      wakes up 58000000.dss as it's the dispc parent
       dispc_runtime_resume()
        rpm_resume() increases parent child_count
     dispc_runtime_put() won't idle, PM runtime suspend blocked
    ...
    rpm_suspend for 58000000.dss but parent child_count is now unbalanced
    
    Let's fix the issue by adding a flag for needs_force_resume and use it in
    pm_runtime_force_resume() instead of pm_runtime_need_not_resume().
    
    Additionally omapdrm system suspend could be simplified later on to avoid
    lots of unnecessary PM runtime calls and the complexity it adds. The
    driver can just use internal functions that are shared between the PM
    runtime and system suspend related functions.
    
    Fixes: 4918e1f87c5f ("PM / runtime: Rework pm_runtime_force_suspend/resume()")
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Tested-by: Tomi Valkeinen <tomi.valkeinen@ideasonboard.com>
    Cc: 4.16+ <stable@vger.kernel.org> # 4.16+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit d9aa6571b28ba0022de1e48801ff03a1854c7ef2
Author: Kuogee Hsieh <khsieh@codeaurora.org>
Date:   Wed Apr 21 16:37:35 2021 -0700

    drm/msm/dp: check sink_count before update is_connected status
    
    Link status is different from display connected status in the case
    of something like an Apple dongle where the type-c plug can be
    connected, and therefore the link is connected, but no sink is
    connected until an HDMI cable is plugged into the dongle.
    The sink_count of DPCD of dongle will increase to 1 once an HDMI
    cable is plugged into the dongle so that display connected status
    will become true. This checking also apply at pm_resume.
    
    Changes in v4:
    -- none
    
    Fixes: 94e58e2d06e3 ("drm/msm/dp: reset dp controller only at boot up and pm_resume")
    Reported-by: Stephen Boyd <swboyd@chromium.org>
    Reviewed-by: Stephen Boyd <swboyd@chromium.org>
    Tested-by: Stephen Boyd <swboyd@chromium.org>
    Signed-off-by: Kuogee Hsieh <khsieh@codeaurora.org>
    Fixes: 8ede2ecc3e5e ("drm/msm/dp: Add DP compliance tests on Snapdragon Chipsets")
    Link: https://lore.kernel.org/r/1619048258-8717-2-git-send-email-khsieh@codeaurora.org
    Signed-off-by: Rob Clark <robdclark@chromium.org>

commit 5b11705608898c31a1cae5340555ee60d5a4fa45
Author: Hsin-Yi Wang <hsinyi@chromium.org>
Date:   Tue Apr 20 16:08:53 2021 +0300

    drm/i915/selftests: Rename pm_ prefixed functions names
    
    pm_resume and pm_suspend might be conflict with the ones defined in
    include/linux/suspend.h. Rename all pm_* to igt_pm_* in selftests since
    they are only used here.
    
    v2 by Jani:
    - Use igt_ prefix instead of i915_ to avoid colliding with existing
      i915_pm_* functions
    - Rename all pm_ prefixed functions in the file
    
    Signed-off-by: Hsin-Yi Wang <hsinyi@chromium.org>
    Reported-by: kernel test robot <lkp@intel.com>
    Reviewed-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20210420130853.10573-1-jani.nikula@intel.com

commit c93ebea0cbc3ed56e05a7948adb6e7c4c4fe2f7d
Author: Guchun Chen <guchun.chen@amd.com>
Date:   Mon Mar 22 14:07:38 2021 +0800

    drm/amd/pm: fix MP1 state setting failure in s3 test
    
    Skip PP_MP1_STATE_NONE in MP1 state setting, otherwise, it will
    break S3 sequence.
    
    [   50.188269] [drm:amdgpu_device_ip_suspend_phase2 [amdgpu]] *ERROR* SMC failed to set mp1 state 0, -22
    [   50.969901] amdgpu 0000:03:00.0: amdgpu: SMU is resuming...
    [   50.970024] sd 0:0:0:0: [sda] Starting disk
    [   50.979723] serial 00:02: activated
    [   51.353644] ata4: SATA link down (SStatus 4 SControl 300)
    [   51.353669] ata3: SATA link down (SStatus 4 SControl 300)
    [   51.353747] ata6: SATA link down (SStatus 4 SControl 300)
    [   51.357694] ata1: SATA link up 6.0 Gbps (SStatus 133 SControl 300)
    [   51.357711] ata5: SATA link down (SStatus 4 SControl 300)
    [   51.357729] ata2: SATA link down (SStatus 4 SControl 300)
    [   51.358005] ata1.00: supports DRM functions and may not be fully accessible
    [   51.360491] ata1.00: supports DRM functions and may not be fully accessible
    [   51.362573] ata1.00: configured for UDMA/133
    [   51.362610] ahci 0000:00:17.0: port does not support device sleep
    [   51.362946] ata1.00: Enabling discard_zeroes_data
    [   52.566438] amdgpu 0000:03:00.0: amdgpu: Msg issuing pre-check failed and SMU may be not in the right state!
    [   54.126316] amdgpu 0000:03:00.0: amdgpu: Msg issuing pre-check failed and SMU may be not in the right state!
    [   54.126317] amdgpu 0000:03:00.0: amdgpu: Failed to SetDriverDramAddr!
    [   54.126318] amdgpu 0000:03:00.0: amdgpu: Failed to setup smc hw!
    [   54.126319] [drm:amdgpu_device_ip_resume_phase2 [amdgpu]] *ERROR* resume of IP block <smu> failed -62
    [   54.126398] amdgpu 0000:03:00.0: amdgpu: amdgpu_device_ip_resume failed (-62).
    [   54.126399] PM: dpm_run_callback(): pci_pm_resume+0x0/0x90 returns -62
    [   54.126403] PM: Device 0000:03:00.0 failed to resume async: error -62
    
    Fixes: 1689fca0d62aa7 ("drm/amd/pm: fix Navi1x runtime resume failure V2")
    Signed-off-by: Evan Quan <evan.quan@amd.com>
    Signed-off-by: Guchun Chen <guchun.chen@amd.com>
    Reviewed-by: Lijo Lazar <lijo.lazar@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

commit 5c0a3a331dc5e1b6e459e7d605396b9361ab4bfb
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Mar 19 15:47:25 2021 +0100

    Revert "PM: runtime: Update device status before letting suppliers suspend"
    
    commit 0cab893f409c53634d0d818fa414641cbcdb0dab upstream.
    
    Revert commit 44cc89f76464 ("PM: runtime: Update device status
    before letting suppliers suspend") that introduced a race condition
    into __rpm_callback() which allowed a concurrent rpm_resume() to
    run and resume the device prematurely after its status had been
    changed to RPM_SUSPENDED by __rpm_callback().
    
    Fixes: 44cc89f76464 ("PM: runtime: Update device status before letting suppliers suspend")
    Link: https://lore.kernel.org/linux-pm/24dfb6fc-5d54-6ee2-9195-26428b7ecf8a@intel.com/
    Reported-by: Adrian Hunter <adrian.hunter@intel.com>
    Cc: 4.10+ <stable@vger.kernel.org> # 4.10+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 1a33f12678fc766111c616e3e133275813e0c2c6
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Mar 19 15:47:25 2021 +0100

    Revert "PM: runtime: Update device status before letting suppliers suspend"
    
    commit 0cab893f409c53634d0d818fa414641cbcdb0dab upstream.
    
    Revert commit 44cc89f76464 ("PM: runtime: Update device status
    before letting suppliers suspend") that introduced a race condition
    into __rpm_callback() which allowed a concurrent rpm_resume() to
    run and resume the device prematurely after its status had been
    changed to RPM_SUSPENDED by __rpm_callback().
    
    Fixes: 44cc89f76464 ("PM: runtime: Update device status before letting suppliers suspend")
    Link: https://lore.kernel.org/linux-pm/24dfb6fc-5d54-6ee2-9195-26428b7ecf8a@intel.com/
    Reported-by: Adrian Hunter <adrian.hunter@intel.com>
    Cc: 4.10+ <stable@vger.kernel.org> # 4.10+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit ba4342094d71c4ceec2ef841dba2c26f49b2acfc
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Mar 19 15:47:25 2021 +0100

    Revert "PM: runtime: Update device status before letting suppliers suspend"
    
    commit 0cab893f409c53634d0d818fa414641cbcdb0dab upstream.
    
    Revert commit 44cc89f76464 ("PM: runtime: Update device status
    before letting suppliers suspend") that introduced a race condition
    into __rpm_callback() which allowed a concurrent rpm_resume() to
    run and resume the device prematurely after its status had been
    changed to RPM_SUSPENDED by __rpm_callback().
    
    Fixes: 44cc89f76464 ("PM: runtime: Update device status before letting suppliers suspend")
    Link: https://lore.kernel.org/linux-pm/24dfb6fc-5d54-6ee2-9195-26428b7ecf8a@intel.com/
    Reported-by: Adrian Hunter <adrian.hunter@intel.com>
    Cc: 4.10+ <stable@vger.kernel.org> # 4.10+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit f68e0080674da512f9dbe2cae059c641a076c593
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Mar 19 15:47:25 2021 +0100

    Revert "PM: runtime: Update device status before letting suppliers suspend"
    
    commit 0cab893f409c53634d0d818fa414641cbcdb0dab upstream.
    
    Revert commit 44cc89f76464 ("PM: runtime: Update device status
    before letting suppliers suspend") that introduced a race condition
    into __rpm_callback() which allowed a concurrent rpm_resume() to
    run and resume the device prematurely after its status had been
    changed to RPM_SUSPENDED by __rpm_callback().
    
    Fixes: 44cc89f76464 ("PM: runtime: Update device status before letting suppliers suspend")
    Link: https://lore.kernel.org/linux-pm/24dfb6fc-5d54-6ee2-9195-26428b7ecf8a@intel.com/
    Reported-by: Adrian Hunter <adrian.hunter@intel.com>
    Cc: 4.10+ <stable@vger.kernel.org> # 4.10+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 866f290149fb46cbabe897fc64f569abed4b348e
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Mar 19 15:47:25 2021 +0100

    Revert "PM: runtime: Update device status before letting suppliers suspend"
    
    commit 0cab893f409c53634d0d818fa414641cbcdb0dab upstream.
    
    Revert commit 44cc89f76464 ("PM: runtime: Update device status
    before letting suppliers suspend") that introduced a race condition
    into __rpm_callback() which allowed a concurrent rpm_resume() to
    run and resume the device prematurely after its status had been
    changed to RPM_SUSPENDED by __rpm_callback().
    
    Fixes: 44cc89f76464 ("PM: runtime: Update device status before letting suppliers suspend")
    Link: https://lore.kernel.org/linux-pm/24dfb6fc-5d54-6ee2-9195-26428b7ecf8a@intel.com/
    Reported-by: Adrian Hunter <adrian.hunter@intel.com>
    Cc: 4.10+ <stable@vger.kernel.org> # 4.10+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 0cab893f409c53634d0d818fa414641cbcdb0dab
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Mar 19 15:47:25 2021 +0100

    Revert "PM: runtime: Update device status before letting suppliers suspend"
    
    Revert commit 44cc89f76464 ("PM: runtime: Update device status
    before letting suppliers suspend") that introduced a race condition
    into __rpm_callback() which allowed a concurrent rpm_resume() to
    run and resume the device prematurely after its status had been
    changed to RPM_SUSPENDED by __rpm_callback().
    
    Fixes: 44cc89f76464 ("PM: runtime: Update device status before letting suppliers suspend")
    Link: https://lore.kernel.org/linux-pm/24dfb6fc-5d54-6ee2-9195-26428b7ecf8a@intel.com/
    Reported-by: Adrian Hunter <adrian.hunter@intel.com>
    Cc: 4.10+ <stable@vger.kernel.org> # 4.10+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>

commit ccf8b940e5fdd331231a7442cd80f0e83336cfd3
Author: Chen Yu <yu.c.chen@intel.com>
Date:   Tue Dec 1 09:21:50 2020 +0800

    e1000e: Leverage direct_complete to speed up s2ram
    
    The NIC is put in runtime suspend status when there is no cable connected.
    As a result, it is safe to keep non-wakeup NIC in runtime suspended during
    s2ram because the system does not rely on the NIC plug event nor WoL to wake
    up the system. Besides that, unlike the s2idle, s2ram does not need to
    manipulate S0ix settings during suspend.
    
    This patch introduces the .prepare() for e1000e so that if the NIC is runtime
    suspended the subsequent suspend/resume hooks will be skipped so as to speed
    up the s2ram. The pm core will check whether the NIC is a wake up device so
    there's no need to check it again in .prepare(). DPM_FLAG_SMART_PREPARE flag
    should be set during probe to ask the pci subsystem to honor the driver's
    prepare() result. Besides, the NIC remains runtime suspended after resumed
    from s2ram as there is no need to resume it.
    
    Tested on i7-2600K with 82579V NIC
    Before the patch:
    e1000e 0000:00:19.0: pci_pm_suspend+0x0/0x160 returned 0 after 225146 usecs
    e1000e 0000:00:19.0: pci_pm_resume+0x0/0x90 returned 0 after 140588 usecs
    
    After the patch:
    echo disabled > //sys/devices/pci0000\:00/0000\:00\:19.0/power/wakeup
    becomes 0 usecs because the hooks will be skipped.
    
    Suggested-by: Kai-Heng Feng <kai.heng.feng@canonical.com>
    Signed-off-by: Chen Yu <yu.c.chen@intel.com>
    Tested-by: Dvora Fuxbrumer <dvorax.fuxbrumer@linux.intel.com>
    Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>

commit ea9f337ce81e315ef5643b7c843d6d8795461a5b
Author: Kuogee Hsieh <khsieh@codeaurora.org>
Date:   Fri Feb 5 12:44:38 2021 -0800

    drm/msm/dp: reset dp controller only at boot up and pm_resume
    
    DP_SW_RESET is the global SW reset that is used to initialize DP
    controller. If DP_SW_RESET executed during connection setup,
    two HPD related side effects may occurred,
    1) pending HPD interrupts cleared unexpected
    2) re start debounce logic which trigger another interrupt
    This patch only issue DP_SW_RESET at boot up and pm_resume.
    This patch also reinit video_comp before configure dp controller
    to avoid missing VIDEO_READY interrupt.
    
    Fixes: 9fc418430c65 ("drm/msm/dp: unplug interrupt missed after irq_hpd handler")
    Signed-off-by: Kuogee Hsieh <khsieh@codeaurora.org>
    Reviewed-by: Stephen Boyd <swboyd@chromium.org>
    Signed-off-by: Rob Clark <robdclark@chromium.org>

commit d55d15a332ec651ccb49c42a8a10c03447fdf418
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue Dec 8 21:29:51 2020 -0800

    scsi: block: Do not accept any requests while suspended
    
    [ Upstream commit 52abca64fd9410ea6c9a3a74eab25663b403d7da ]
    
    blk_queue_enter() accepts BLK_MQ_REQ_PM requests independent of the runtime
    power management state. Now that SCSI domain validation no longer depends
    on this behavior, modify the behavior of blk_queue_enter() as follows:
    
       - Do not accept any requests while suspended.
    
       - Only process power management requests while suspending or resuming.
    
    Submitting BLK_MQ_REQ_PM requests to a device that is runtime suspended
    causes runtime-suspended devices not to resume as they should. The request
    which should cause a runtime resume instead gets issued directly, without
    resuming the device first. Of course the device can't handle it properly,
    the I/O fails, and the device remains suspended.
    
    The problem is fixed by checking that the queue's runtime-PM status isn't
    RPM_SUSPENDED before allowing a request to be issued, and queuing a
    runtime-resume request if it is.  In particular, the inline
    blk_pm_request_resume() routine is renamed blk_pm_resume_queue() and the
    code is unified by merging the surrounding checks into the routine.  If the
    queue isn't set up for runtime PM, or there currently is no restriction on
    allowed requests, the request is allowed.  Likewise if the BLK_MQ_REQ_PM
    flag is set and the status isn't RPM_SUSPENDED.  Otherwise a runtime resume
    is queued and the request is blocked until conditions are more suitable.
    
    [ bvanassche: modified commit message and removed Cc: stable because
      without the previous patches from this series this patch would break
      parallel SCSI domain validation + introduced queue_rpm_status() ]
    
    Link: https://lore.kernel.org/r/20201209052951.16136-9-bvanassche@acm.org
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Hannes Reinecke <hare@suse.de>
    Cc: Can Guo <cang@codeaurora.org>
    Cc: Stanley Chu <stanley.chu@mediatek.com>
    Cc: Ming Lei <ming.lei@redhat.com>
    Cc: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reported-and-tested-by: Martin Kepplinger <martin.kepplinger@puri.sm>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Reviewed-by: Can Guo <cang@codeaurora.org>
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Bart Van Assche <bvanassche@acm.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit ae5b3fc2dce45fabc8463e001aa70d1c1cabe124
Author: Kuogee Hsieh <khsieh@codeaurora.org>
Date:   Tue Nov 3 14:53:35 2020 -0800

    drm/msm/dp: return correct connection status after suspend
    
    [ Upstream commit 19e52bcb27c2ba140699d2230d722366d7d048a1 ]
    
    During suspend, dp host controller and hpd block are disabled due to
    both ahb and aux clock are disabled. Therefore hpd plug/unplug interrupts
    will not be generated. At dp_pm_resume(), reinitialize both dp host
    controller and hpd block so that hpd plug/unplug interrupts will be
    generated and handled by driver so that hpd connection state is updated
    correctly. This patch will fix link training flaky issues.
    
    Changes in v2:
    -- use container_of to cast correct dp_display_private pointer
       at both dp_pm_suspend() and dp_pm_resume().
    
    Changes in v3:
    -- replace hpd_state atomic_t  with u32
    
    Changes in v4
    -- call dp_display_host_deinit() at dp_pm_suspend()
    -- call dp_display_host_init() at msm_dp_display_enable()
    -- fix phy->init_count unbalance which causes link training failed
    
    Changes in v5
    --  add Fixes tag
    
    Fixes:  8ede2ecc3e5e (drm/msm/dp: Add DP compliance tests on Snapdragon Chipsets)
    Tested-by: Stephen Boyd <swboyd@chromium.org>
    Signed-off-by: Kuogee Hsieh <khsieh@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@chromium.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 52abca64fd9410ea6c9a3a74eab25663b403d7da
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue Dec 8 21:29:51 2020 -0800

    scsi: block: Do not accept any requests while suspended
    
    blk_queue_enter() accepts BLK_MQ_REQ_PM requests independent of the runtime
    power management state. Now that SCSI domain validation no longer depends
    on this behavior, modify the behavior of blk_queue_enter() as follows:
    
       - Do not accept any requests while suspended.
    
       - Only process power management requests while suspending or resuming.
    
    Submitting BLK_MQ_REQ_PM requests to a device that is runtime suspended
    causes runtime-suspended devices not to resume as they should. The request
    which should cause a runtime resume instead gets issued directly, without
    resuming the device first. Of course the device can't handle it properly,
    the I/O fails, and the device remains suspended.
    
    The problem is fixed by checking that the queue's runtime-PM status isn't
    RPM_SUSPENDED before allowing a request to be issued, and queuing a
    runtime-resume request if it is.  In particular, the inline
    blk_pm_request_resume() routine is renamed blk_pm_resume_queue() and the
    code is unified by merging the surrounding checks into the routine.  If the
    queue isn't set up for runtime PM, or there currently is no restriction on
    allowed requests, the request is allowed.  Likewise if the BLK_MQ_REQ_PM
    flag is set and the status isn't RPM_SUSPENDED.  Otherwise a runtime resume
    is queued and the request is blocked until conditions are more suitable.
    
    [ bvanassche: modified commit message and removed Cc: stable because
      without the previous patches from this series this patch would break
      parallel SCSI domain validation + introduced queue_rpm_status() ]
    
    Link: https://lore.kernel.org/r/20201209052951.16136-9-bvanassche@acm.org
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Hannes Reinecke <hare@suse.de>
    Cc: Can Guo <cang@codeaurora.org>
    Cc: Stanley Chu <stanley.chu@mediatek.com>
    Cc: Ming Lei <ming.lei@redhat.com>
    Cc: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reported-and-tested-by: Martin Kepplinger <martin.kepplinger@puri.sm>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Reviewed-by: Can Guo <cang@codeaurora.org>
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Bart Van Assche <bvanassche@acm.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

commit 19e52bcb27c2ba140699d2230d722366d7d048a1
Author: Kuogee Hsieh <khsieh@codeaurora.org>
Date:   Tue Nov 3 14:53:35 2020 -0800

    drm/msm/dp: return correct connection status after suspend
    
    During suspend, dp host controller and hpd block are disabled due to
    both ahb and aux clock are disabled. Therefore hpd plug/unplug interrupts
    will not be generated. At dp_pm_resume(), reinitialize both dp host
    controller and hpd block so that hpd plug/unplug interrupts will be
    generated and handled by driver so that hpd connection state is updated
    correctly. This patch will fix link training flaky issues.
    
    Changes in v2:
    -- use container_of to cast correct dp_display_private pointer
       at both dp_pm_suspend() and dp_pm_resume().
    
    Changes in v3:
    -- replace hpd_state atomic_t  with u32
    
    Changes in v4
    -- call dp_display_host_deinit() at dp_pm_suspend()
    -- call dp_display_host_init() at msm_dp_display_enable()
    -- fix phy->init_count unbalance which causes link training failed
    
    Changes in v5
    --  add Fixes tag
    
    Fixes:  8ede2ecc3e5e (drm/msm/dp: Add DP compliance tests on Snapdragon Chipsets)
    Tested-by: Stephen Boyd <swboyd@chromium.org>
    Signed-off-by: Kuogee Hsieh <khsieh@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@chromium.org>

commit 27c09484dd3d8fdb56eb3787877d6035d0e89669
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Oct 27 16:53:21 2020 +0530

    opp: Allocate the OPP table outside of opp_table_lock
    
    There is no critical section which needs protection with locks while
    allocating an OPP table, except while adding it to the opp_tables list.
    And taking the opp_table_lock for the entire duration causes circular
    dependency issues like the one mentioned below.  This patch takes
    another approach to reduce the size of the critical section to avoid
    such issues, the details of that are present within the patch.
    
     ======================================================
     WARNING: possible circular locking dependency detected
     5.4.72 #14 Not tainted
     ------------------------------------------------------
     chrome/1865 is trying to acquire lock:
     ffffffdd34921750 (opp_table_lock){+.+.}, at: _find_opp_table+0x34/0x74
    
     but task is already holding lock:
     ffffff81f0fc71a8 (reservation_ww_class_mutex){+.+.}, at: submit_lock_objects+0x70/0x1ec
    
     fscrypt: AES-256-CTS-CBC using implementation "cts-cbc-aes-ce"
     which lock already depends on the new lock.
    
     the existing dependency chain (in reverse order) is:
     -> #4 (reservation_ww_class_mutex){+.+.}:
            __mutex_lock_common+0xec/0xc0c
            ww_mutex_lock_interruptible+0x5c/0xc4
            msm_gem_fault+0x2c/0x124
            __do_fault+0x40/0x16c
            handle_mm_fault+0x7cc/0xd98
            do_page_fault+0x230/0x3b4
            do_translation_fault+0x5c/0x78
            do_mem_abort+0x4c/0xb4
            el0_da+0x1c/0x20
     -> #3 (&mm->mmap_sem){++++}:
            __might_fault+0x70/0x98
            compat_filldir+0xf8/0x48c
            dcache_readdir+0x70/0x1dc
            iterate_dir+0xd4/0x180
            __arm64_compat_sys_getdents+0xa0/0x19c
            el0_svc_common+0xa8/0x178
            el0_svc_compat_handler+0x2c/0x40
            el0_svc_compat+0x8/0x10
     -> #2 (&sb->s_type->i_mutex_key#3){++++}:
            down_write+0x54/0x16c
            start_creating+0x68/0x128
            debugfs_create_dir+0x28/0x114
            opp_debug_register+0x8c/0xc0
            _add_opp_dev_unlocked+0x5c/0x70
            _add_opp_dev+0x38/0x58
            _opp_get_opp_table+0xdc/0x1ac
            dev_pm_opp_get_opp_table_indexed+0x24/0x30
            dev_pm_opp_of_add_table_indexed+0x48/0x84
            of_genpd_add_provider_onecell+0xc0/0x1b8
            rpmhpd_probe+0x240/0x268
            platform_drv_probe+0x90/0xb0
            really_probe+0x134/0x2ec
            driver_probe_device+0x64/0xfc
            __device_attach_driver+0x8c/0xa4
            bus_for_each_drv+0x90/0xd8
            __device_attach+0xc0/0x148
            device_initial_probe+0x20/0x2c
            bus_probe_device+0x34/0x94
            device_add+0x1fc/0x3b0
            of_device_add+0x3c/0x4c
            of_platform_device_create_pdata+0xb8/0xfc
            of_platform_bus_create+0x1e4/0x368
            of_platform_populate+0x70/0xbc
            devm_of_platform_populate+0x58/0xa0
            rpmh_rsc_probe+0x36c/0x3cc
            platform_drv_probe+0x90/0xb0
            really_probe+0x134/0x2ec
            driver_probe_device+0x64/0xfc
            __device_attach_driver+0x8c/0xa4
            bus_for_each_drv+0x90/0xd8
            __device_attach+0xc0/0x148
            device_initial_probe+0x20/0x2c
            bus_probe_device+0x34/0x94
            device_add+0x1fc/0x3b0
            of_device_add+0x3c/0x4c
            of_platform_device_create_pdata+0xb8/0xfc
            of_platform_bus_create+0x1e4/0x368
            of_platform_bus_create+0x230/0x368
            of_platform_populate+0x70/0xbc
            of_platform_default_populate_init+0xa8/0xc0
            do_one_initcall+0x1c8/0x3fc
            do_initcall_level+0xb4/0x10c
            do_basic_setup+0x30/0x48
            kernel_init_freeable+0x124/0x1a4
            kernel_init+0x14/0x104
            ret_from_fork+0x10/0x18
     -> #1 (&opp_table->lock){+.+.}:
            __mutex_lock_common+0xec/0xc0c
            mutex_lock_nested+0x40/0x50
            _add_opp_dev+0x2c/0x58
            _opp_get_opp_table+0xdc/0x1ac
            dev_pm_opp_get_opp_table_indexed+0x24/0x30
            dev_pm_opp_of_add_table_indexed+0x48/0x84
            of_genpd_add_provider_onecell+0xc0/0x1b8
            rpmhpd_probe+0x240/0x268
            platform_drv_probe+0x90/0xb0
            really_probe+0x134/0x2ec
            driver_probe_device+0x64/0xfc
            __device_attach_driver+0x8c/0xa4
            bus_for_each_drv+0x90/0xd8
            __device_attach+0xc0/0x148
            device_initial_probe+0x20/0x2c
            bus_probe_device+0x34/0x94
            device_add+0x1fc/0x3b0
            of_device_add+0x3c/0x4c
            of_platform_device_create_pdata+0xb8/0xfc
            of_platform_bus_create+0x1e4/0x368
            of_platform_populate+0x70/0xbc
            devm_of_platform_populate+0x58/0xa0
            rpmh_rsc_probe+0x36c/0x3cc
            platform_drv_probe+0x90/0xb0
            really_probe+0x134/0x2ec
            driver_probe_device+0x64/0xfc
            __device_attach_driver+0x8c/0xa4
            bus_for_each_drv+0x90/0xd8
            __device_attach+0xc0/0x148
            device_initial_probe+0x20/0x2c
            bus_probe_device+0x34/0x94
            device_add+0x1fc/0x3b0
            of_device_add+0x3c/0x4c
            of_platform_device_create_pdata+0xb8/0xfc
            of_platform_bus_create+0x1e4/0x368
            of_platform_populate+0x70/0xbc
            devm_of_platform_populate+0x58/0xa0
            rpmh_rsc_probe+0x36c/0x3cc
            platform_drv_probe+0x90/0xb0
            really_probe+0x134/0x2ec
            driver_probe_device+0x64/0xfc
            __device_attach_driver+0x8c/0xa4
            bus_for_each_drv+0x90/0xd8
            __device_attach+0xc0/0x148
            device_initial_probe+0x20/0x2c
            bus_probe_device+0x34/0x94
            device_add+0x1fc/0x3b0
            of_device_add+0x3c/0x4c
            of_platform_device_create_pdata+0xb8/0xfc
            of_platform_bus_create+0x1e4/0x368
            of_platform_bus_create+0x230/0x368
            of_platform_populate+0x70/0xbc
            of_platform_default_populate_init+0xa8/0xc0
            do_one_initcall+0x1c8/0x3fc
            do_initcall_level+0xb4/0x10c
            do_basic_setup+0x30/0x48
            kernel_init_freeable+0x124/0x1a4
            kernel_init+0x14/0x104
            ret_from_fork+0x10/0x18
     -> #0 (opp_table_lock){+.+.}:
            __lock_acquire+0xee4/0x2450
            lock_acquire+0x1cc/0x210
            __mutex_lock_common+0xec/0xc0c
            mutex_lock_nested+0x40/0x50
            _find_opp_table+0x34/0x74
            dev_pm_opp_find_freq_exact+0x2c/0xdc
            a6xx_gmu_resume+0xc8/0xecc
            a6xx_pm_resume+0x148/0x200
            adreno_resume+0x28/0x34
            pm_generic_runtime_resume+0x34/0x48
            __rpm_callback+0x70/0x10c
            rpm_callback+0x34/0x8c
            rpm_resume+0x414/0x550
            __pm_runtime_resume+0x7c/0xa0
            msm_gpu_submit+0x60/0x1c0
            msm_ioctl_gem_submit+0xadc/0xb60
            drm_ioctl_kernel+0x9c/0x118
            drm_ioctl+0x27c/0x408
            drm_compat_ioctl+0xcc/0xdc
            __se_compat_sys_ioctl+0x100/0x206c
            __arm64_compat_sys_ioctl+0x20/0x2c
            el0_svc_common+0xa8/0x178
            el0_svc_compat_handler+0x2c/0x40
            el0_svc_compat+0x8/0x10
     other info that might help us debug this:
     Chain exists of: opp_table_lock --> &mm->mmap_sem --> reservation_ww_class_mutex
      Possible unsafe locking scenario:
            CPU0                    CPU1
            ----                    ----
       lock(reservation_ww_class_mutex);
                                    lock(&mm->mmap_sem);
                                    lock(reservation_ww_class_mutex);
       lock(opp_table_lock);
    
     *** DEADLOCK ***
    
     3 locks held by chrome/1865:
      #0: ffffff81edecc0d8 (&dev->struct_mutex){+.+.}, at: msm_ioctl_gem_submit+0x264/0xb60
      #1: ffffff81d0000870 (reservation_ww_class_acquire){+.+.}, at: msm_ioctl_gem_submit+0x8e8/0xb60
      #2: ffffff81f0fc71a8 (reservation_ww_class_mutex){+.+.}, at: submit_lock_objects+0x70/0x1ec
     stack backtrace:
     CPU: 0 PID: 1865 Comm: chrome Not tainted 5.4.72 #14
     Hardware name: Google Lazor (rev1+) with LTE (DT)
     Call trace:
      dump_backtrace+0x0/0x158
      show_stack+0x20/0x2c
      dump_stack+0xc8/0x160
      print_circular_bug+0x2c4/0x2c8
      check_noncircular+0x1a8/0x1b0
      __lock_acquire+0xee4/0x2450
      lock_acquire+0x1cc/0x210
      __mutex_lock_common+0xec/0xc0c
      mutex_lock_nested+0x40/0x50
      _find_opp_table+0x34/0x74
      dev_pm_opp_find_freq_exact+0x2c/0xdc
      a6xx_gmu_resume+0xc8/0xecc
      a6xx_pm_resume+0x148/0x200
      adreno_resume+0x28/0x34
      pm_generic_runtime_resume+0x34/0x48
      __rpm_callback+0x70/0x10c
      rpm_callback+0x34/0x8c
      rpm_resume+0x414/0x550
      __pm_runtime_resume+0x7c/0xa0
      msm_gpu_submit+0x60/0x1c0
      msm_ioctl_gem_submit+0xadc/0xb60
      drm_ioctl_kernel+0x9c/0x118
      drm_ioctl+0x27c/0x408
      drm_compat_ioctl+0xcc/0xdc
      __se_compat_sys_ioctl+0x100/0x206c
      __arm64_compat_sys_ioctl+0x20/0x2c
      el0_svc_common+0xa8/0x178
      el0_svc_compat_handler+0x2c/0x40
      el0_svc_compat+0x8/0x10
    
    Reported-by: Rob Clark <robdclark@gmail.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>

commit 8a988434456f0d6bac04377906d936a9b21837c8
Author: Tingwei Zhang <tingwei@codeaurora.org>
Date:   Wed Sep 16 13:17:27 2020 -0600

    coresight: cti: remove pm_runtime_get_sync() from CPU hotplug
    
    [ Upstream commit 6e8836c6df5327bdb24211424f1ad1411d1ed64a ]
    
    Below BUG is triggered by call pm_runtime_get_sync() in
    cti_cpuhp_enable_hw(). It's in CPU hotplug callback with interrupt
    disabled. Pm_runtime_get_sync() calls clock driver to enable clock
    which could sleep. Remove pm_runtime_get_sync() in cti_cpuhp_enable_hw()
    since pm_runtime_get_sync() is called in cti_enabld and pm_runtime_put()
    is called in cti_disabled. No need to increase pm count when CPU gets
    online since it's not decreased when CPU is offline.
    
    [  105.800279] BUG: scheduling while atomic: swapper/1/0/0x00000002
    [  105.800290] Modules linked in:
    [  105.800327] CPU: 1 PID: 0 Comm: swapper/1 Tainted: G        W
    5.9.0-rc1-gff1304be0a05-dirty #21
    [  105.800337] Hardware name: Thundercomm Dragonboard 845c (DT)
    [  105.800353] Call trace:
    [  105.800414]  dump_backtrace+0x0/0x1d4
    [  105.800439]  show_stack+0x14/0x1c
    [  105.800462]  dump_stack+0xc0/0x100
    [  105.800490]  __schedule_bug+0x58/0x74
    [  105.800523]  __schedule+0x590/0x65c
    [  105.800538]  schedule+0x78/0x10c
    [  105.800553]  schedule_timeout+0x188/0x250
    [  105.800585]  qmp_send.constprop.10+0x12c/0x1b0
    [  105.800599]  qmp_qdss_clk_prepare+0x18/0x20
    [  105.800622]  clk_core_prepare+0x48/0xd4
    [  105.800639]  clk_prepare+0x20/0x34
    [  105.800663]  amba_pm_runtime_resume+0x54/0x90
    [  105.800695]  __rpm_callback+0xdc/0x138
    [  105.800709]  rpm_callback+0x24/0x78
    [  105.800724]  rpm_resume+0x328/0x47c
    [  105.800739]  __pm_runtime_resume+0x50/0x74
    [  105.800768]  cti_starting_cpu+0x40/0xa4
    [  105.800795]  cpuhp_invoke_callback+0x84/0x1e0
    [  105.800814]  notify_cpu_starting+0x9c/0xb8
    [  105.800834]  secondary_start_kernel+0xd8/0x164
    [  105.800933] CPU1: Booted secondary processor 0x0000000100 [0x517f803c]
    
    Fixes: e9b880581d55 ("coresight: cti: Add CPU Hotplug handling to CTI driver")
    Reviewed-by: Mike Leach <mike.leach@linaro.org>
    Signed-off-by: Tingwei Zhang <tingwei@codeaurora.org>
    Signed-off-by: Mathieu Poirier <mathieu.poirier@linaro.org>
    Link: https://lore.kernel.org/r/20200916191737.4001561-7-mathieu.poirier@linaro.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 435fd705a501a6099155f896263dd230339aef80
Author: Tingwei Zhang <tingwei@codeaurora.org>
Date:   Wed Sep 16 13:17:27 2020 -0600

    coresight: cti: remove pm_runtime_get_sync() from CPU hotplug
    
    [ Upstream commit 6e8836c6df5327bdb24211424f1ad1411d1ed64a ]
    
    Below BUG is triggered by call pm_runtime_get_sync() in
    cti_cpuhp_enable_hw(). It's in CPU hotplug callback with interrupt
    disabled. Pm_runtime_get_sync() calls clock driver to enable clock
    which could sleep. Remove pm_runtime_get_sync() in cti_cpuhp_enable_hw()
    since pm_runtime_get_sync() is called in cti_enabld and pm_runtime_put()
    is called in cti_disabled. No need to increase pm count when CPU gets
    online since it's not decreased when CPU is offline.
    
    [  105.800279] BUG: scheduling while atomic: swapper/1/0/0x00000002
    [  105.800290] Modules linked in:
    [  105.800327] CPU: 1 PID: 0 Comm: swapper/1 Tainted: G        W
    5.9.0-rc1-gff1304be0a05-dirty #21
    [  105.800337] Hardware name: Thundercomm Dragonboard 845c (DT)
    [  105.800353] Call trace:
    [  105.800414]  dump_backtrace+0x0/0x1d4
    [  105.800439]  show_stack+0x14/0x1c
    [  105.800462]  dump_stack+0xc0/0x100
    [  105.800490]  __schedule_bug+0x58/0x74
    [  105.800523]  __schedule+0x590/0x65c
    [  105.800538]  schedule+0x78/0x10c
    [  105.800553]  schedule_timeout+0x188/0x250
    [  105.800585]  qmp_send.constprop.10+0x12c/0x1b0
    [  105.800599]  qmp_qdss_clk_prepare+0x18/0x20
    [  105.800622]  clk_core_prepare+0x48/0xd4
    [  105.800639]  clk_prepare+0x20/0x34
    [  105.800663]  amba_pm_runtime_resume+0x54/0x90
    [  105.800695]  __rpm_callback+0xdc/0x138
    [  105.800709]  rpm_callback+0x24/0x78
    [  105.800724]  rpm_resume+0x328/0x47c
    [  105.800739]  __pm_runtime_resume+0x50/0x74
    [  105.800768]  cti_starting_cpu+0x40/0xa4
    [  105.800795]  cpuhp_invoke_callback+0x84/0x1e0
    [  105.800814]  notify_cpu_starting+0x9c/0xb8
    [  105.800834]  secondary_start_kernel+0xd8/0x164
    [  105.800933] CPU1: Booted secondary processor 0x0000000100 [0x517f803c]
    
    Fixes: e9b880581d55 ("coresight: cti: Add CPU Hotplug handling to CTI driver")
    Reviewed-by: Mike Leach <mike.leach@linaro.org>
    Signed-off-by: Tingwei Zhang <tingwei@codeaurora.org>
    Signed-off-by: Mathieu Poirier <mathieu.poirier@linaro.org>
    Link: https://lore.kernel.org/r/20200916191737.4001561-7-mathieu.poirier@linaro.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 215a22ed31a1332075866eca07744d442367c04b
Author: Kai-Heng Feng <kai.heng.feng@canonical.com>
Date:   Tue Oct 27 21:00:36 2020 +0800

    ALSA: hda: Refactor codec PM to use direct-complete optimization
    
    Upon system resume, hda_codec_pm_resume() uses hda_codec_force_resume()
    to resume the codec. However, pm_runtime_force_resume() won't really
    resume the codec because of pm_runtime_need_not_resume() check.
    
    Hence, hda_codec_force_resume() schedules a jackpoll work, which is to
    really power up the codec.
    
    Instead of doing that, we can use direct-complete to make the PM flow
    more straightforward, and keep codec always suspended through system PM
    flow if conditions are met.
    
    On system suspend, PM core will decide what to do based on
    hda_codec_pm_prepare():
    - If codec is not runtime-suspended, PM core will suspend and resume the
    device as normal.
    - If codec is runtime-suspended, PM core will try to keep it suspended.
    If it's still suspended after system resume, we use
    hda_codec_pm_complete() to resume codec if it's needed.
    
    Signed-off-by: Kai-Heng Feng <kai.heng.feng@canonical.com>
    Link: https://lore.kernel.org/r/20201027130038.16463-2-kai.heng.feng@canonical.com
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

commit 93c9fce7d5f3db87f67718a2e5cf09b02c2c2c6a
Author: Jon Derrick <jonathan.derrick@intel.com>
Date:   Thu Aug 6 17:00:17 2020 -0400

    PCI: vmd: Update VMD PM to correctly use generic PCI PM
    
    The pci_save_state() call in vmd_suspend() can be performed by
    pci_pm_suspend_irq(). This also allows VMD to benefit from the call into
    pci_prepare_to_sleep().
    
    The pci_restore_state() call in vmd_resume() was restoring state after
    pci_pm_resume()::pci_restore_standard_config() had already restored state.
    It's also been suspected that the config state should have been restored
    before re-requesting IRQs instead of afterwards.
    
    Remove the pci_save_state()/pci_restore_state() calls in
    vmd_suspend()/vmd_resume() to allow proper flow through generic PCI core
    Power Management code.
    
    Link: https://lore.kernel.org/r/20200806210017.5654-1-jonathan.derrick@intel.com
    Signed-off-by: Jon Derrick <jonathan.derrick@intel.com>
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Kai-Heng Feng <kai.heng.feng@canonical.com>
    Cc: You-Sheng Yang <vicamo.yang@canonical.com>

commit 849d01ef1894d9495d7405746ed948fbce4b831b
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Tue Sep 22 09:29:31 2020 +0200

    Revert "ravb: Fixed to be able to unload modules"
    
    commit 77972b55fb9d35d4a6b0abca99abffaa4ec6a85b upstream.
    
    This reverts commit 1838d6c62f57836639bd3d83e7855e0ee4f6defc.
    
    This commit moved the ravb_mdio_init() call (and thus the
    of_mdiobus_register() call) from the ravb_probe() to the ravb_open()
    call.  This causes a regression during system resume (s2idle/s2ram), as
    new PHY devices cannot be bound while suspended.
    
    During boot, the Micrel PHY is detected like this:
    
        Micrel KSZ9031 Gigabit PHY e6800000.ethernet-ffffffff:00: attached PHY driver [Micrel KSZ9031 Gigabit PHY] (mii_bus:phy_addr=e6800000.ethernet-ffffffff:00, irq=228)
        ravb e6800000.ethernet eth0: Link is Up - 1Gbps/Full - flow control off
    
    During system suspend, (A) defer_all_probes is set to true, and (B)
    usermodehelper_disabled is set to UMH_DISABLED, to avoid drivers being
    probed while suspended.
    
      A. If CONFIG_MODULES=n, phy_device_register() calling device_add()
         merely adds the device, but does not probe it yet, as
         really_probe() returns early due to defer_all_probes being set:
    
           dpm_resume+0x128/0x4f8
             device_resume+0xcc/0x1b0
               dpm_run_callback+0x74/0x340
                 ravb_resume+0x190/0x1b8
                   ravb_open+0x84/0x770
                     of_mdiobus_register+0x1e0/0x468
                       of_mdiobus_register_phy+0x1b8/0x250
                         of_mdiobus_phy_device_register+0x178/0x1e8
                           phy_device_register+0x114/0x1b8
                             device_add+0x3d4/0x798
                               bus_probe_device+0x98/0xa0
                                 device_initial_probe+0x10/0x18
                                   __device_attach+0xe4/0x140
                                     bus_for_each_drv+0x64/0xc8
                                       __device_attach_driver+0xb8/0xe0
                                         driver_probe_device.part.11+0xc4/0xd8
                                           really_probe+0x32c/0x3b8
    
         Later, phy_attach_direct() notices no PHY driver has been bound,
         and falls back to the Generic PHY, leading to degraded operation:
    
           Generic PHY e6800000.ethernet-ffffffff:00: attached PHY driver [Generic PHY] (mii_bus:phy_addr=e6800000.ethernet-ffffffff:00, irq=POLL)
           ravb e6800000.ethernet eth0: Link is Up - 1Gbps/Full - flow control off
    
      B. If CONFIG_MODULES=y, request_module() returns early with -EBUSY due
         to UMH_DISABLED, and MDIO initialization fails completely:
    
           mdio_bus e6800000.ethernet-ffffffff:00: error -16 loading PHY driver module for ID 0x00221622
           ravb e6800000.ethernet eth0: failed to initialize MDIO
           PM: dpm_run_callback(): ravb_resume+0x0/0x1b8 returns -16
           PM: Device e6800000.ethernet failed to resume: error -16
    
         Ignoring -EBUSY in phy_request_driver_module(), like was done for
         -ENOENT in commit 21e194425abd65b5 ("net: phy: fix issue with loading
         PHY driver w/o initramfs"), would makes it fall back to the Generic
         PHY, like in the CONFIG_MODULES=n case.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Cc: stable@vger.kernel.org
    Reviewed-by: Sergei Shtylyov <sergei.shtylyov@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 4f46ef7bec86d13ac89c7976d8cb41612cd179f2
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Tue Sep 22 09:29:31 2020 +0200

    Revert "ravb: Fixed to be able to unload modules"
    
    commit 77972b55fb9d35d4a6b0abca99abffaa4ec6a85b upstream.
    
    This reverts commit 1838d6c62f57836639bd3d83e7855e0ee4f6defc.
    
    This commit moved the ravb_mdio_init() call (and thus the
    of_mdiobus_register() call) from the ravb_probe() to the ravb_open()
    call.  This causes a regression during system resume (s2idle/s2ram), as
    new PHY devices cannot be bound while suspended.
    
    During boot, the Micrel PHY is detected like this:
    
        Micrel KSZ9031 Gigabit PHY e6800000.ethernet-ffffffff:00: attached PHY driver [Micrel KSZ9031 Gigabit PHY] (mii_bus:phy_addr=e6800000.ethernet-ffffffff:00, irq=228)
        ravb e6800000.ethernet eth0: Link is Up - 1Gbps/Full - flow control off
    
    During system suspend, (A) defer_all_probes is set to true, and (B)
    usermodehelper_disabled is set to UMH_DISABLED, to avoid drivers being
    probed while suspended.
    
      A. If CONFIG_MODULES=n, phy_device_register() calling device_add()
         merely adds the device, but does not probe it yet, as
         really_probe() returns early due to defer_all_probes being set:
    
           dpm_resume+0x128/0x4f8
             device_resume+0xcc/0x1b0
               dpm_run_callback+0x74/0x340
                 ravb_resume+0x190/0x1b8
                   ravb_open+0x84/0x770
                     of_mdiobus_register+0x1e0/0x468
                       of_mdiobus_register_phy+0x1b8/0x250
                         of_mdiobus_phy_device_register+0x178/0x1e8
                           phy_device_register+0x114/0x1b8
                             device_add+0x3d4/0x798
                               bus_probe_device+0x98/0xa0
                                 device_initial_probe+0x10/0x18
                                   __device_attach+0xe4/0x140
                                     bus_for_each_drv+0x64/0xc8
                                       __device_attach_driver+0xb8/0xe0
                                         driver_probe_device.part.11+0xc4/0xd8
                                           really_probe+0x32c/0x3b8
    
         Later, phy_attach_direct() notices no PHY driver has been bound,
         and falls back to the Generic PHY, leading to degraded operation:
    
           Generic PHY e6800000.ethernet-ffffffff:00: attached PHY driver [Generic PHY] (mii_bus:phy_addr=e6800000.ethernet-ffffffff:00, irq=POLL)
           ravb e6800000.ethernet eth0: Link is Up - 1Gbps/Full - flow control off
    
      B. If CONFIG_MODULES=y, request_module() returns early with -EBUSY due
         to UMH_DISABLED, and MDIO initialization fails completely:
    
           mdio_bus e6800000.ethernet-ffffffff:00: error -16 loading PHY driver module for ID 0x00221622
           ravb e6800000.ethernet eth0: failed to initialize MDIO
           PM: dpm_run_callback(): ravb_resume+0x0/0x1b8 returns -16
           PM: Device e6800000.ethernet failed to resume: error -16
    
         Ignoring -EBUSY in phy_request_driver_module(), like was done for
         -ENOENT in commit 21e194425abd65b5 ("net: phy: fix issue with loading
         PHY driver w/o initramfs"), would makes it fall back to the Generic
         PHY, like in the CONFIG_MODULES=n case.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Cc: stable@vger.kernel.org
    Reviewed-by: Sergei Shtylyov <sergei.shtylyov@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit be92b3b5e5aae0a55699d539783ea33f34a240ff
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Tue Sep 22 09:29:31 2020 +0200

    Revert "ravb: Fixed to be able to unload modules"
    
    commit 77972b55fb9d35d4a6b0abca99abffaa4ec6a85b upstream.
    
    This reverts commit 1838d6c62f57836639bd3d83e7855e0ee4f6defc.
    
    This commit moved the ravb_mdio_init() call (and thus the
    of_mdiobus_register() call) from the ravb_probe() to the ravb_open()
    call.  This causes a regression during system resume (s2idle/s2ram), as
    new PHY devices cannot be bound while suspended.
    
    During boot, the Micrel PHY is detected like this:
    
        Micrel KSZ9031 Gigabit PHY e6800000.ethernet-ffffffff:00: attached PHY driver [Micrel KSZ9031 Gigabit PHY] (mii_bus:phy_addr=e6800000.ethernet-ffffffff:00, irq=228)
        ravb e6800000.ethernet eth0: Link is Up - 1Gbps/Full - flow control off
    
    During system suspend, (A) defer_all_probes is set to true, and (B)
    usermodehelper_disabled is set to UMH_DISABLED, to avoid drivers being
    probed while suspended.
    
      A. If CONFIG_MODULES=n, phy_device_register() calling device_add()
         merely adds the device, but does not probe it yet, as
         really_probe() returns early due to defer_all_probes being set:
    
           dpm_resume+0x128/0x4f8
             device_resume+0xcc/0x1b0
               dpm_run_callback+0x74/0x340
                 ravb_resume+0x190/0x1b8
                   ravb_open+0x84/0x770
                     of_mdiobus_register+0x1e0/0x468
                       of_mdiobus_register_phy+0x1b8/0x250
                         of_mdiobus_phy_device_register+0x178/0x1e8
                           phy_device_register+0x114/0x1b8
                             device_add+0x3d4/0x798
                               bus_probe_device+0x98/0xa0
                                 device_initial_probe+0x10/0x18
                                   __device_attach+0xe4/0x140
                                     bus_for_each_drv+0x64/0xc8
                                       __device_attach_driver+0xb8/0xe0
                                         driver_probe_device.part.11+0xc4/0xd8
                                           really_probe+0x32c/0x3b8
    
         Later, phy_attach_direct() notices no PHY driver has been bound,
         and falls back to the Generic PHY, leading to degraded operation:
    
           Generic PHY e6800000.ethernet-ffffffff:00: attached PHY driver [Generic PHY] (mii_bus:phy_addr=e6800000.ethernet-ffffffff:00, irq=POLL)
           ravb e6800000.ethernet eth0: Link is Up - 1Gbps/Full - flow control off
    
      B. If CONFIG_MODULES=y, request_module() returns early with -EBUSY due
         to UMH_DISABLED, and MDIO initialization fails completely:
    
           mdio_bus e6800000.ethernet-ffffffff:00: error -16 loading PHY driver module for ID 0x00221622
           ravb e6800000.ethernet eth0: failed to initialize MDIO
           PM: dpm_run_callback(): ravb_resume+0x0/0x1b8 returns -16
           PM: Device e6800000.ethernet failed to resume: error -16
    
         Ignoring -EBUSY in phy_request_driver_module(), like was done for
         -ENOENT in commit 21e194425abd65b5 ("net: phy: fix issue with loading
         PHY driver w/o initramfs"), would makes it fall back to the Generic
         PHY, like in the CONFIG_MODULES=n case.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Cc: stable@vger.kernel.org
    Reviewed-by: Sergei Shtylyov <sergei.shtylyov@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit ab5737277fce6bb8f6d2a0a41a88a33f64b03aa6
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Tue Sep 22 09:29:31 2020 +0200

    Revert "ravb: Fixed to be able to unload modules"
    
    commit 77972b55fb9d35d4a6b0abca99abffaa4ec6a85b upstream.
    
    This reverts commit 1838d6c62f57836639bd3d83e7855e0ee4f6defc.
    
    This commit moved the ravb_mdio_init() call (and thus the
    of_mdiobus_register() call) from the ravb_probe() to the ravb_open()
    call.  This causes a regression during system resume (s2idle/s2ram), as
    new PHY devices cannot be bound while suspended.
    
    During boot, the Micrel PHY is detected like this:
    
        Micrel KSZ9031 Gigabit PHY e6800000.ethernet-ffffffff:00: attached PHY driver [Micrel KSZ9031 Gigabit PHY] (mii_bus:phy_addr=e6800000.ethernet-ffffffff:00, irq=228)
        ravb e6800000.ethernet eth0: Link is Up - 1Gbps/Full - flow control off
    
    During system suspend, (A) defer_all_probes is set to true, and (B)
    usermodehelper_disabled is set to UMH_DISABLED, to avoid drivers being
    probed while suspended.
    
      A. If CONFIG_MODULES=n, phy_device_register() calling device_add()
         merely adds the device, but does not probe it yet, as
         really_probe() returns early due to defer_all_probes being set:
    
           dpm_resume+0x128/0x4f8
             device_resume+0xcc/0x1b0
               dpm_run_callback+0x74/0x340
                 ravb_resume+0x190/0x1b8
                   ravb_open+0x84/0x770
                     of_mdiobus_register+0x1e0/0x468
                       of_mdiobus_register_phy+0x1b8/0x250
                         of_mdiobus_phy_device_register+0x178/0x1e8
                           phy_device_register+0x114/0x1b8
                             device_add+0x3d4/0x798
                               bus_probe_device+0x98/0xa0
                                 device_initial_probe+0x10/0x18
                                   __device_attach+0xe4/0x140
                                     bus_for_each_drv+0x64/0xc8
                                       __device_attach_driver+0xb8/0xe0
                                         driver_probe_device.part.11+0xc4/0xd8
                                           really_probe+0x32c/0x3b8
    
         Later, phy_attach_direct() notices no PHY driver has been bound,
         and falls back to the Generic PHY, leading to degraded operation:
    
           Generic PHY e6800000.ethernet-ffffffff:00: attached PHY driver [Generic PHY] (mii_bus:phy_addr=e6800000.ethernet-ffffffff:00, irq=POLL)
           ravb e6800000.ethernet eth0: Link is Up - 1Gbps/Full - flow control off
    
      B. If CONFIG_MODULES=y, request_module() returns early with -EBUSY due
         to UMH_DISABLED, and MDIO initialization fails completely:
    
           mdio_bus e6800000.ethernet-ffffffff:00: error -16 loading PHY driver module for ID 0x00221622
           ravb e6800000.ethernet eth0: failed to initialize MDIO
           PM: dpm_run_callback(): ravb_resume+0x0/0x1b8 returns -16
           PM: Device e6800000.ethernet failed to resume: error -16
    
         Ignoring -EBUSY in phy_request_driver_module(), like was done for
         -ENOENT in commit 21e194425abd65b5 ("net: phy: fix issue with loading
         PHY driver w/o initramfs"), would makes it fall back to the Generic
         PHY, like in the CONFIG_MODULES=n case.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Cc: stable@vger.kernel.org
    Reviewed-by: Sergei Shtylyov <sergei.shtylyov@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 919829cea8343e6cc1e47d174c0fd3594ad7307b
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Tue Sep 22 09:29:31 2020 +0200

    Revert "ravb: Fixed to be able to unload modules"
    
    commit 77972b55fb9d35d4a6b0abca99abffaa4ec6a85b upstream.
    
    This reverts commit 1838d6c62f57836639bd3d83e7855e0ee4f6defc.
    
    This commit moved the ravb_mdio_init() call (and thus the
    of_mdiobus_register() call) from the ravb_probe() to the ravb_open()
    call.  This causes a regression during system resume (s2idle/s2ram), as
    new PHY devices cannot be bound while suspended.
    
    During boot, the Micrel PHY is detected like this:
    
        Micrel KSZ9031 Gigabit PHY e6800000.ethernet-ffffffff:00: attached PHY driver [Micrel KSZ9031 Gigabit PHY] (mii_bus:phy_addr=e6800000.ethernet-ffffffff:00, irq=228)
        ravb e6800000.ethernet eth0: Link is Up - 1Gbps/Full - flow control off
    
    During system suspend, (A) defer_all_probes is set to true, and (B)
    usermodehelper_disabled is set to UMH_DISABLED, to avoid drivers being
    probed while suspended.
    
      A. If CONFIG_MODULES=n, phy_device_register() calling device_add()
         merely adds the device, but does not probe it yet, as
         really_probe() returns early due to defer_all_probes being set:
    
           dpm_resume+0x128/0x4f8
             device_resume+0xcc/0x1b0
               dpm_run_callback+0x74/0x340
                 ravb_resume+0x190/0x1b8
                   ravb_open+0x84/0x770
                     of_mdiobus_register+0x1e0/0x468
                       of_mdiobus_register_phy+0x1b8/0x250
                         of_mdiobus_phy_device_register+0x178/0x1e8
                           phy_device_register+0x114/0x1b8
                             device_add+0x3d4/0x798
                               bus_probe_device+0x98/0xa0
                                 device_initial_probe+0x10/0x18
                                   __device_attach+0xe4/0x140
                                     bus_for_each_drv+0x64/0xc8
                                       __device_attach_driver+0xb8/0xe0
                                         driver_probe_device.part.11+0xc4/0xd8
                                           really_probe+0x32c/0x3b8
    
         Later, phy_attach_direct() notices no PHY driver has been bound,
         and falls back to the Generic PHY, leading to degraded operation:
    
           Generic PHY e6800000.ethernet-ffffffff:00: attached PHY driver [Generic PHY] (mii_bus:phy_addr=e6800000.ethernet-ffffffff:00, irq=POLL)
           ravb e6800000.ethernet eth0: Link is Up - 1Gbps/Full - flow control off
    
      B. If CONFIG_MODULES=y, request_module() returns early with -EBUSY due
         to UMH_DISABLED, and MDIO initialization fails completely:
    
           mdio_bus e6800000.ethernet-ffffffff:00: error -16 loading PHY driver module for ID 0x00221622
           ravb e6800000.ethernet eth0: failed to initialize MDIO
           PM: dpm_run_callback(): ravb_resume+0x0/0x1b8 returns -16
           PM: Device e6800000.ethernet failed to resume: error -16
    
         Ignoring -EBUSY in phy_request_driver_module(), like was done for
         -ENOENT in commit 21e194425abd65b5 ("net: phy: fix issue with loading
         PHY driver w/o initramfs"), would makes it fall back to the Generic
         PHY, like in the CONFIG_MODULES=n case.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Cc: stable@vger.kernel.org
    Reviewed-by: Sergei Shtylyov <sergei.shtylyov@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 17b0824cffb94d61866e5cdc59441a5a62576cf2
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Tue Sep 22 09:29:31 2020 +0200

    Revert "ravb: Fixed to be able to unload modules"
    
    commit 77972b55fb9d35d4a6b0abca99abffaa4ec6a85b upstream.
    
    This reverts commit 1838d6c62f57836639bd3d83e7855e0ee4f6defc.
    
    This commit moved the ravb_mdio_init() call (and thus the
    of_mdiobus_register() call) from the ravb_probe() to the ravb_open()
    call.  This causes a regression during system resume (s2idle/s2ram), as
    new PHY devices cannot be bound while suspended.
    
    During boot, the Micrel PHY is detected like this:
    
        Micrel KSZ9031 Gigabit PHY e6800000.ethernet-ffffffff:00: attached PHY driver [Micrel KSZ9031 Gigabit PHY] (mii_bus:phy_addr=e6800000.ethernet-ffffffff:00, irq=228)
        ravb e6800000.ethernet eth0: Link is Up - 1Gbps/Full - flow control off
    
    During system suspend, (A) defer_all_probes is set to true, and (B)
    usermodehelper_disabled is set to UMH_DISABLED, to avoid drivers being
    probed while suspended.
    
      A. If CONFIG_MODULES=n, phy_device_register() calling device_add()
         merely adds the device, but does not probe it yet, as
         really_probe() returns early due to defer_all_probes being set:
    
           dpm_resume+0x128/0x4f8
             device_resume+0xcc/0x1b0
               dpm_run_callback+0x74/0x340
                 ravb_resume+0x190/0x1b8
                   ravb_open+0x84/0x770
                     of_mdiobus_register+0x1e0/0x468
                       of_mdiobus_register_phy+0x1b8/0x250
                         of_mdiobus_phy_device_register+0x178/0x1e8
                           phy_device_register+0x114/0x1b8
                             device_add+0x3d4/0x798
                               bus_probe_device+0x98/0xa0
                                 device_initial_probe+0x10/0x18
                                   __device_attach+0xe4/0x140
                                     bus_for_each_drv+0x64/0xc8
                                       __device_attach_driver+0xb8/0xe0
                                         driver_probe_device.part.11+0xc4/0xd8
                                           really_probe+0x32c/0x3b8
    
         Later, phy_attach_direct() notices no PHY driver has been bound,
         and falls back to the Generic PHY, leading to degraded operation:
    
           Generic PHY e6800000.ethernet-ffffffff:00: attached PHY driver [Generic PHY] (mii_bus:phy_addr=e6800000.ethernet-ffffffff:00, irq=POLL)
           ravb e6800000.ethernet eth0: Link is Up - 1Gbps/Full - flow control off
    
      B. If CONFIG_MODULES=y, request_module() returns early with -EBUSY due
         to UMH_DISABLED, and MDIO initialization fails completely:
    
           mdio_bus e6800000.ethernet-ffffffff:00: error -16 loading PHY driver module for ID 0x00221622
           ravb e6800000.ethernet eth0: failed to initialize MDIO
           PM: dpm_run_callback(): ravb_resume+0x0/0x1b8 returns -16
           PM: Device e6800000.ethernet failed to resume: error -16
    
         Ignoring -EBUSY in phy_request_driver_module(), like was done for
         -ENOENT in commit 21e194425abd65b5 ("net: phy: fix issue with loading
         PHY driver w/o initramfs"), would makes it fall back to the Generic
         PHY, like in the CONFIG_MODULES=n case.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Cc: stable@vger.kernel.org
    Reviewed-by: Sergei Shtylyov <sergei.shtylyov@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit b14a37e011d829404c29a5ae17849d7efb034893
Author: Xiang Chen <chenxiang66@hisilicon.com>
Date:   Fri Oct 2 22:30:37 2020 +0800

    scsi: hisi_sas: Filter out new PHY up events during suspend
    
    Currently sas_resume_ha() is called while resuming the controller to wait
    for all suspended PHYs to come up and all the libsas events to be
    completed.
    
    There is a scenario which will cause task hung: For direct attach with two
    disks connected with two PHYs, disable phy0 before suspending the disk on
    phy1 and the controller, then enable phy0 and resume the controller, and
    task hung occurs as follows:
    
    [  591.901463] hisi_sas_v3_hw 0000:b4:02.0: resuming from operating state [D0]
    [  593.113525] hisi_sas_v3_hw 0000:b4:02.0: neither _PS0 nor _PR0 is defined
    [  593.120301] hisi_sas_v3_hw 0000:b4:02.0: waiting up to 25 seconds for 1 phy to resume
    [  593.120836] hisi_sas_v3_hw 0000:b4:02.0: phyup: phy0 link_rate=10(sata)
    [  593.134680] hisi_sas_v3_hw 0000:b4:02.0: phyup: phy1 link_rate=10(sata)
    [  593.134733] sas: phy-2:0 added to port-2:0, phy_mask:0x1 (5000000000000200)
    [  593.148350] sas: DOING DISCOVERY on port 0, pid:948
    [  593.153227] hisi_sas_v3_hw 0000:b4:02.0: dev[3:5] found
    [  593.159840] sas: Enter sas_scsi_recover_host busy: 0 failed: 0
    [  593.165663] sas: ata7: end_device-2:0: dev error handler
    [  593.165730] sas: ata2: end_device-2:1: dev error handler
    [  593.172532] hisi_sas_v3_hw 0000:b4:02.0: phydown: phy0 phy_state=0x2
    [  593.182570] hisi_sas_v3_hw 0000:b4:02.0: ignore flutter phy0 down
    [  593.331277] hisi_sas_v3_hw 0000:b4:02.0: phyup: phy0 link_rate=10(sata)
    [  593.498956] ata7.00: ATA-11: SAMSUNG MZ7LH960HAJR-00005, HXT7404Q, max UDMA/133
    [  593.506235] ata7.00: 1875385008 sectors, multi 16: LBA48 NCQ (depth 32)
    [  593.514295] ata7.00: configured for UDMA/133
    [  593.518557] sas: --- Exit sas_scsi_recover_host: busy: 0 failed: 0 tries: 1
    [  593.528613] sas: ata7: end_device-2:0: model:SAMSUNG MZ7LH960HAJR-00005
    serial:S45NNA0M712225
    [  593.537520] device_link_add 316: dev=2:0:2:0 supplier:2 consumer:0
    [  593.543674] device_link_add 324
    [  593.546801] device_link_add 352
    [  593.549930] device_link_add 406
    [  593.553058] device_link_add 440: dev=2:0:2:0 supplier:2 consumer:0
    [  593.559208] device_link_add 444
    [  593.562335] device_link_add 455
    [  593.565517] scsi 2:0:2:0: Direct-Access     ATA      SAMSUNG MZ7LH960 404Q PQ: 0
    ANSI: 5
    [  620.057464]  phy-2:1: resume timeout
    [  738.841445] INFO: task kworker/u256:0:8 blocked for more than 120 seconds.
    [  738.848295]       Not tainted 5.8.0-rc1-76154-g0d52b59-dirty #744
    [  738.854361] "echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
    [  738.862155] kworker/u256:0  D    0     8      2 0x00000028
    [  738.867626] Workqueue: 0000:b4:02.0_event_q sas_port_event_worker
    [  738.873693] Call trace:
    [  738.876133]  __switch_to+0xf4/0x148
    [  738.879613]  __schedule+0x270/0x5d8
    [  738.883091]  schedule+0x78/0x110
    [  738.886307]  schedule_timeout+0x1ac/0x280
    [  738.890299]  wait_for_completion+0x94/0x138
    [  738.894472]  flush_workqueue+0x114/0x438
    [  738.898377]  sas_porte_bytes_dmaed+0x400/0x500
    [  738.902801]  sas_port_event_worker+0x28/0x40
    [  738.907053]  process_one_work+0x1e8/0x360
    [  738.911046]  worker_thread+0x44/0x478
    [  738.914698]  kthread+0x150/0x158
    [  738.917915]  ret_from_fork+0x10/0x1c
    [  738.921534] INFO: task kworker/u256:1:948 blocked for more than 120 seconds.
    [  738.928550]       Not tainted 5.8.0-rc1-76154-g0d52b59-dirty #744
    [  738.934614] "echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
    [  738.942408] kworker/u256:1  D    0   948      2 0x00000028
    [  738.947873] Workqueue: 0000:b4:02.0_disco_q sas_discover_domain
    [  738.953766] Call trace:
    [  738.956203]  __switch_to+0xf4/0x148
    [  738.959678]  __schedule+0x270/0x5d8
    [  738.963152]  schedule+0x78/0x110
    [  738.966368]  rpm_resume+0xcc/0x550
    [  738.969757]  __pm_runtime_resume+0x3c/0x88
    [  738.973836]  rpm_get_suppliers+0x50/0x148
    [  738.977829]  __pm_runtime_set_status+0x124/0x2f0
    [  738.982427]  scsi_sysfs_add_sdev+0x1a0/0x2a8
    [  738.986679]  scsi_probe_and_add_lun+0x888/0xab0
    [  738.991190]  __scsi_scan_target+0xec/0x520
    [  738.995268]  scsi_scan_target+0x11c/0x128
    [  738.999261]  sas_rphy_add+0x15c/0x1e8
    [  739.002907]  sas_probe_devices+0xe4/0x150
    [  739.006899]  sas_discover_domain+0x33c/0x588
    [  739.011150]  process_one_work+0x1e8/0x360
    [  739.015143]  worker_thread+0x44/0x478
    [  739.018789]  kthread+0x150/0x158
    [  739.022003]  ret_from_fork+0x10/0x1c
    ...
    
    If an extra phy0 up happens during resume of the SAS controller, it will
    emit a new libsas event (event PORTE_BYTES_DMAED and event
    DISCE_DISCOVER_DOMAIN). We will call function scsi_sysfs_add_sdev() in
    event DISCE_DISCOVER_DOMAIN, which will call __pm_runtime_set_status() to
    resume supplier (host controller). For runtime PM core, if device is in the
    resuming state, the later resume request of the device will wait for
    previous resume request to complete synchronously. At that point in time
    the state of the controller is still resuming as it waits for all libsas
    events to be completed, while libsas event DISCE_DISCOVER_DOMAIN is blocked
    as the state of the controller is resuming which causes a deadlock.
    
    To avoid the issue, filter out new PHY up events while the controller is
    suspended.
    
    Link: https://lore.kernel.org/r/1601649038-25534-7-git-send-email-john.garry@huawei.com
    Signed-off-by: Xiang Chen <chenxiang66@hisilicon.com>
    Signed-off-by: John Garry <john.garry@huawei.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

commit cd8dda53887ad58d3e61e5bbfa5c9a7751eebf51
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Fri Mar 20 14:52:00 2020 +0200

    serial: 8250_omap: Fix sleeping function called from invalid context during probe
    
    [ Upstream commit 4ce35a3617c0ac758c61122b2218b6c8c9ac9398 ]
    
    When booting j721e the following bug is printed:
    
    [    1.154821] BUG: sleeping function called from invalid context at kernel/sched/completion.c:99
    [    1.154827] in_atomic(): 0, irqs_disabled(): 128, non_block: 0, pid: 12, name: kworker/0:1
    [    1.154832] 3 locks held by kworker/0:1/12:
    [    1.154836]  #0: ffff000840030728 ((wq_completion)events){+.+.}, at: process_one_work+0x1d4/0x6e8
    [    1.154852]  #1: ffff80001214fdd8 (deferred_probe_work){+.+.}, at: process_one_work+0x1d4/0x6e8
    [    1.154860]  #2: ffff00084060b170 (&dev->mutex){....}, at: __device_attach+0x38/0x138
    [    1.154872] irq event stamp: 63096
    [    1.154881] hardirqs last  enabled at (63095): [<ffff800010b74318>] _raw_spin_unlock_irqrestore+0x70/0x78
    [    1.154887] hardirqs last disabled at (63096): [<ffff800010b740d8>] _raw_spin_lock_irqsave+0x28/0x80
    [    1.154893] softirqs last  enabled at (62254): [<ffff800010080c88>] _stext+0x488/0x564
    [    1.154899] softirqs last disabled at (62247): [<ffff8000100fdb3c>] irq_exit+0x114/0x140
    [    1.154906] CPU: 0 PID: 12 Comm: kworker/0:1 Not tainted 5.6.0-rc6-next-20200318-00094-g45e4089b0bd3 #221
    [    1.154911] Hardware name: Texas Instruments K3 J721E SoC (DT)
    [    1.154917] Workqueue: events deferred_probe_work_func
    [    1.154923] Call trace:
    [    1.154928]  dump_backtrace+0x0/0x190
    [    1.154933]  show_stack+0x14/0x20
    [    1.154940]  dump_stack+0xe0/0x148
    [    1.154946]  ___might_sleep+0x150/0x1f0
    [    1.154952]  __might_sleep+0x4c/0x80
    [    1.154957]  wait_for_completion_timeout+0x40/0x140
    [    1.154964]  ti_sci_set_device_state+0xa0/0x158
    [    1.154969]  ti_sci_cmd_get_device_exclusive+0x14/0x20
    [    1.154977]  ti_sci_dev_start+0x34/0x50
    [    1.154984]  genpd_runtime_resume+0x78/0x1f8
    [    1.154991]  __rpm_callback+0x3c/0x140
    [    1.154996]  rpm_callback+0x20/0x80
    [    1.155001]  rpm_resume+0x568/0x758
    [    1.155007]  __pm_runtime_resume+0x44/0xb0
    [    1.155013]  omap8250_probe+0x2b4/0x508
    [    1.155019]  platform_drv_probe+0x50/0xa0
    [    1.155023]  really_probe+0xd4/0x318
    [    1.155028]  driver_probe_device+0x54/0xe8
    [    1.155033]  __device_attach_driver+0x80/0xb8
    [    1.155039]  bus_for_each_drv+0x74/0xc0
    [    1.155044]  __device_attach+0xdc/0x138
    [    1.155049]  device_initial_probe+0x10/0x18
    [    1.155053]  bus_probe_device+0x98/0xa0
    [    1.155058]  deferred_probe_work_func+0x74/0xb0
    [    1.155063]  process_one_work+0x280/0x6e8
    [    1.155068]  worker_thread+0x48/0x430
    [    1.155073]  kthread+0x108/0x138
    [    1.155079]  ret_from_fork+0x10/0x18
    
    To fix the bug we need to first call pm_runtime_enable() prior to any
    pm_runtime calls.
    
    Reported-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Link: https://lore.kernel.org/r/20200320125200.6772-1-peter.ujfalusi@ti.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 09a2cf6771059fbc49f26bc26b1d582e04a75ea6
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Fri Mar 20 14:52:00 2020 +0200

    serial: 8250_omap: Fix sleeping function called from invalid context during probe
    
    [ Upstream commit 4ce35a3617c0ac758c61122b2218b6c8c9ac9398 ]
    
    When booting j721e the following bug is printed:
    
    [    1.154821] BUG: sleeping function called from invalid context at kernel/sched/completion.c:99
    [    1.154827] in_atomic(): 0, irqs_disabled(): 128, non_block: 0, pid: 12, name: kworker/0:1
    [    1.154832] 3 locks held by kworker/0:1/12:
    [    1.154836]  #0: ffff000840030728 ((wq_completion)events){+.+.}, at: process_one_work+0x1d4/0x6e8
    [    1.154852]  #1: ffff80001214fdd8 (deferred_probe_work){+.+.}, at: process_one_work+0x1d4/0x6e8
    [    1.154860]  #2: ffff00084060b170 (&dev->mutex){....}, at: __device_attach+0x38/0x138
    [    1.154872] irq event stamp: 63096
    [    1.154881] hardirqs last  enabled at (63095): [<ffff800010b74318>] _raw_spin_unlock_irqrestore+0x70/0x78
    [    1.154887] hardirqs last disabled at (63096): [<ffff800010b740d8>] _raw_spin_lock_irqsave+0x28/0x80
    [    1.154893] softirqs last  enabled at (62254): [<ffff800010080c88>] _stext+0x488/0x564
    [    1.154899] softirqs last disabled at (62247): [<ffff8000100fdb3c>] irq_exit+0x114/0x140
    [    1.154906] CPU: 0 PID: 12 Comm: kworker/0:1 Not tainted 5.6.0-rc6-next-20200318-00094-g45e4089b0bd3 #221
    [    1.154911] Hardware name: Texas Instruments K3 J721E SoC (DT)
    [    1.154917] Workqueue: events deferred_probe_work_func
    [    1.154923] Call trace:
    [    1.154928]  dump_backtrace+0x0/0x190
    [    1.154933]  show_stack+0x14/0x20
    [    1.154940]  dump_stack+0xe0/0x148
    [    1.154946]  ___might_sleep+0x150/0x1f0
    [    1.154952]  __might_sleep+0x4c/0x80
    [    1.154957]  wait_for_completion_timeout+0x40/0x140
    [    1.154964]  ti_sci_set_device_state+0xa0/0x158
    [    1.154969]  ti_sci_cmd_get_device_exclusive+0x14/0x20
    [    1.154977]  ti_sci_dev_start+0x34/0x50
    [    1.154984]  genpd_runtime_resume+0x78/0x1f8
    [    1.154991]  __rpm_callback+0x3c/0x140
    [    1.154996]  rpm_callback+0x20/0x80
    [    1.155001]  rpm_resume+0x568/0x758
    [    1.155007]  __pm_runtime_resume+0x44/0xb0
    [    1.155013]  omap8250_probe+0x2b4/0x508
    [    1.155019]  platform_drv_probe+0x50/0xa0
    [    1.155023]  really_probe+0xd4/0x318
    [    1.155028]  driver_probe_device+0x54/0xe8
    [    1.155033]  __device_attach_driver+0x80/0xb8
    [    1.155039]  bus_for_each_drv+0x74/0xc0
    [    1.155044]  __device_attach+0xdc/0x138
    [    1.155049]  device_initial_probe+0x10/0x18
    [    1.155053]  bus_probe_device+0x98/0xa0
    [    1.155058]  deferred_probe_work_func+0x74/0xb0
    [    1.155063]  process_one_work+0x280/0x6e8
    [    1.155068]  worker_thread+0x48/0x430
    [    1.155073]  kthread+0x108/0x138
    [    1.155079]  ret_from_fork+0x10/0x18
    
    To fix the bug we need to first call pm_runtime_enable() prior to any
    pm_runtime calls.
    
    Reported-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Link: https://lore.kernel.org/r/20200320125200.6772-1-peter.ujfalusi@ti.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 10aa90fed8aafbfe14e32552742d48eb8f806311
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Fri Mar 20 14:52:00 2020 +0200

    serial: 8250_omap: Fix sleeping function called from invalid context during probe
    
    [ Upstream commit 4ce35a3617c0ac758c61122b2218b6c8c9ac9398 ]
    
    When booting j721e the following bug is printed:
    
    [    1.154821] BUG: sleeping function called from invalid context at kernel/sched/completion.c:99
    [    1.154827] in_atomic(): 0, irqs_disabled(): 128, non_block: 0, pid: 12, name: kworker/0:1
    [    1.154832] 3 locks held by kworker/0:1/12:
    [    1.154836]  #0: ffff000840030728 ((wq_completion)events){+.+.}, at: process_one_work+0x1d4/0x6e8
    [    1.154852]  #1: ffff80001214fdd8 (deferred_probe_work){+.+.}, at: process_one_work+0x1d4/0x6e8
    [    1.154860]  #2: ffff00084060b170 (&dev->mutex){....}, at: __device_attach+0x38/0x138
    [    1.154872] irq event stamp: 63096
    [    1.154881] hardirqs last  enabled at (63095): [<ffff800010b74318>] _raw_spin_unlock_irqrestore+0x70/0x78
    [    1.154887] hardirqs last disabled at (63096): [<ffff800010b740d8>] _raw_spin_lock_irqsave+0x28/0x80
    [    1.154893] softirqs last  enabled at (62254): [<ffff800010080c88>] _stext+0x488/0x564
    [    1.154899] softirqs last disabled at (62247): [<ffff8000100fdb3c>] irq_exit+0x114/0x140
    [    1.154906] CPU: 0 PID: 12 Comm: kworker/0:1 Not tainted 5.6.0-rc6-next-20200318-00094-g45e4089b0bd3 #221
    [    1.154911] Hardware name: Texas Instruments K3 J721E SoC (DT)
    [    1.154917] Workqueue: events deferred_probe_work_func
    [    1.154923] Call trace:
    [    1.154928]  dump_backtrace+0x0/0x190
    [    1.154933]  show_stack+0x14/0x20
    [    1.154940]  dump_stack+0xe0/0x148
    [    1.154946]  ___might_sleep+0x150/0x1f0
    [    1.154952]  __might_sleep+0x4c/0x80
    [    1.154957]  wait_for_completion_timeout+0x40/0x140
    [    1.154964]  ti_sci_set_device_state+0xa0/0x158
    [    1.154969]  ti_sci_cmd_get_device_exclusive+0x14/0x20
    [    1.154977]  ti_sci_dev_start+0x34/0x50
    [    1.154984]  genpd_runtime_resume+0x78/0x1f8
    [    1.154991]  __rpm_callback+0x3c/0x140
    [    1.154996]  rpm_callback+0x20/0x80
    [    1.155001]  rpm_resume+0x568/0x758
    [    1.155007]  __pm_runtime_resume+0x44/0xb0
    [    1.155013]  omap8250_probe+0x2b4/0x508
    [    1.155019]  platform_drv_probe+0x50/0xa0
    [    1.155023]  really_probe+0xd4/0x318
    [    1.155028]  driver_probe_device+0x54/0xe8
    [    1.155033]  __device_attach_driver+0x80/0xb8
    [    1.155039]  bus_for_each_drv+0x74/0xc0
    [    1.155044]  __device_attach+0xdc/0x138
    [    1.155049]  device_initial_probe+0x10/0x18
    [    1.155053]  bus_probe_device+0x98/0xa0
    [    1.155058]  deferred_probe_work_func+0x74/0xb0
    [    1.155063]  process_one_work+0x280/0x6e8
    [    1.155068]  worker_thread+0x48/0x430
    [    1.155073]  kthread+0x108/0x138
    [    1.155079]  ret_from_fork+0x10/0x18
    
    To fix the bug we need to first call pm_runtime_enable() prior to any
    pm_runtime calls.
    
    Reported-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Link: https://lore.kernel.org/r/20200320125200.6772-1-peter.ujfalusi@ti.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit e8be86c1d26c1e223c2b25fb33605ed83cf8acf3
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Fri Mar 20 14:52:00 2020 +0200

    serial: 8250_omap: Fix sleeping function called from invalid context during probe
    
    [ Upstream commit 4ce35a3617c0ac758c61122b2218b6c8c9ac9398 ]
    
    When booting j721e the following bug is printed:
    
    [    1.154821] BUG: sleeping function called from invalid context at kernel/sched/completion.c:99
    [    1.154827] in_atomic(): 0, irqs_disabled(): 128, non_block: 0, pid: 12, name: kworker/0:1
    [    1.154832] 3 locks held by kworker/0:1/12:
    [    1.154836]  #0: ffff000840030728 ((wq_completion)events){+.+.}, at: process_one_work+0x1d4/0x6e8
    [    1.154852]  #1: ffff80001214fdd8 (deferred_probe_work){+.+.}, at: process_one_work+0x1d4/0x6e8
    [    1.154860]  #2: ffff00084060b170 (&dev->mutex){....}, at: __device_attach+0x38/0x138
    [    1.154872] irq event stamp: 63096
    [    1.154881] hardirqs last  enabled at (63095): [<ffff800010b74318>] _raw_spin_unlock_irqrestore+0x70/0x78
    [    1.154887] hardirqs last disabled at (63096): [<ffff800010b740d8>] _raw_spin_lock_irqsave+0x28/0x80
    [    1.154893] softirqs last  enabled at (62254): [<ffff800010080c88>] _stext+0x488/0x564
    [    1.154899] softirqs last disabled at (62247): [<ffff8000100fdb3c>] irq_exit+0x114/0x140
    [    1.154906] CPU: 0 PID: 12 Comm: kworker/0:1 Not tainted 5.6.0-rc6-next-20200318-00094-g45e4089b0bd3 #221
    [    1.154911] Hardware name: Texas Instruments K3 J721E SoC (DT)
    [    1.154917] Workqueue: events deferred_probe_work_func
    [    1.154923] Call trace:
    [    1.154928]  dump_backtrace+0x0/0x190
    [    1.154933]  show_stack+0x14/0x20
    [    1.154940]  dump_stack+0xe0/0x148
    [    1.154946]  ___might_sleep+0x150/0x1f0
    [    1.154952]  __might_sleep+0x4c/0x80
    [    1.154957]  wait_for_completion_timeout+0x40/0x140
    [    1.154964]  ti_sci_set_device_state+0xa0/0x158
    [    1.154969]  ti_sci_cmd_get_device_exclusive+0x14/0x20
    [    1.154977]  ti_sci_dev_start+0x34/0x50
    [    1.154984]  genpd_runtime_resume+0x78/0x1f8
    [    1.154991]  __rpm_callback+0x3c/0x140
    [    1.154996]  rpm_callback+0x20/0x80
    [    1.155001]  rpm_resume+0x568/0x758
    [    1.155007]  __pm_runtime_resume+0x44/0xb0
    [    1.155013]  omap8250_probe+0x2b4/0x508
    [    1.155019]  platform_drv_probe+0x50/0xa0
    [    1.155023]  really_probe+0xd4/0x318
    [    1.155028]  driver_probe_device+0x54/0xe8
    [    1.155033]  __device_attach_driver+0x80/0xb8
    [    1.155039]  bus_for_each_drv+0x74/0xc0
    [    1.155044]  __device_attach+0xdc/0x138
    [    1.155049]  device_initial_probe+0x10/0x18
    [    1.155053]  bus_probe_device+0x98/0xa0
    [    1.155058]  deferred_probe_work_func+0x74/0xb0
    [    1.155063]  process_one_work+0x280/0x6e8
    [    1.155068]  worker_thread+0x48/0x430
    [    1.155073]  kthread+0x108/0x138
    [    1.155079]  ret_from_fork+0x10/0x18
    
    To fix the bug we need to first call pm_runtime_enable() prior to any
    pm_runtime calls.
    
    Reported-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Link: https://lore.kernel.org/r/20200320125200.6772-1-peter.ujfalusi@ti.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 66a24fb617ec9c120585a8bf8e3cbc077d77a9c2
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Fri Mar 20 14:52:00 2020 +0200

    serial: 8250_omap: Fix sleeping function called from invalid context during probe
    
    [ Upstream commit 4ce35a3617c0ac758c61122b2218b6c8c9ac9398 ]
    
    When booting j721e the following bug is printed:
    
    [    1.154821] BUG: sleeping function called from invalid context at kernel/sched/completion.c:99
    [    1.154827] in_atomic(): 0, irqs_disabled(): 128, non_block: 0, pid: 12, name: kworker/0:1
    [    1.154832] 3 locks held by kworker/0:1/12:
    [    1.154836]  #0: ffff000840030728 ((wq_completion)events){+.+.}, at: process_one_work+0x1d4/0x6e8
    [    1.154852]  #1: ffff80001214fdd8 (deferred_probe_work){+.+.}, at: process_one_work+0x1d4/0x6e8
    [    1.154860]  #2: ffff00084060b170 (&dev->mutex){....}, at: __device_attach+0x38/0x138
    [    1.154872] irq event stamp: 63096
    [    1.154881] hardirqs last  enabled at (63095): [<ffff800010b74318>] _raw_spin_unlock_irqrestore+0x70/0x78
    [    1.154887] hardirqs last disabled at (63096): [<ffff800010b740d8>] _raw_spin_lock_irqsave+0x28/0x80
    [    1.154893] softirqs last  enabled at (62254): [<ffff800010080c88>] _stext+0x488/0x564
    [    1.154899] softirqs last disabled at (62247): [<ffff8000100fdb3c>] irq_exit+0x114/0x140
    [    1.154906] CPU: 0 PID: 12 Comm: kworker/0:1 Not tainted 5.6.0-rc6-next-20200318-00094-g45e4089b0bd3 #221
    [    1.154911] Hardware name: Texas Instruments K3 J721E SoC (DT)
    [    1.154917] Workqueue: events deferred_probe_work_func
    [    1.154923] Call trace:
    [    1.154928]  dump_backtrace+0x0/0x190
    [    1.154933]  show_stack+0x14/0x20
    [    1.154940]  dump_stack+0xe0/0x148
    [    1.154946]  ___might_sleep+0x150/0x1f0
    [    1.154952]  __might_sleep+0x4c/0x80
    [    1.154957]  wait_for_completion_timeout+0x40/0x140
    [    1.154964]  ti_sci_set_device_state+0xa0/0x158
    [    1.154969]  ti_sci_cmd_get_device_exclusive+0x14/0x20
    [    1.154977]  ti_sci_dev_start+0x34/0x50
    [    1.154984]  genpd_runtime_resume+0x78/0x1f8
    [    1.154991]  __rpm_callback+0x3c/0x140
    [    1.154996]  rpm_callback+0x20/0x80
    [    1.155001]  rpm_resume+0x568/0x758
    [    1.155007]  __pm_runtime_resume+0x44/0xb0
    [    1.155013]  omap8250_probe+0x2b4/0x508
    [    1.155019]  platform_drv_probe+0x50/0xa0
    [    1.155023]  really_probe+0xd4/0x318
    [    1.155028]  driver_probe_device+0x54/0xe8
    [    1.155033]  __device_attach_driver+0x80/0xb8
    [    1.155039]  bus_for_each_drv+0x74/0xc0
    [    1.155044]  __device_attach+0xdc/0x138
    [    1.155049]  device_initial_probe+0x10/0x18
    [    1.155053]  bus_probe_device+0x98/0xa0
    [    1.155058]  deferred_probe_work_func+0x74/0xb0
    [    1.155063]  process_one_work+0x280/0x6e8
    [    1.155068]  worker_thread+0x48/0x430
    [    1.155073]  kthread+0x108/0x138
    [    1.155079]  ret_from_fork+0x10/0x18
    
    To fix the bug we need to first call pm_runtime_enable() prior to any
    pm_runtime calls.
    
    Reported-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Link: https://lore.kernel.org/r/20200320125200.6772-1-peter.ujfalusi@ti.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 77972b55fb9d35d4a6b0abca99abffaa4ec6a85b
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Tue Sep 22 09:29:31 2020 +0200

    Revert "ravb: Fixed to be able to unload modules"
    
    This reverts commit 1838d6c62f57836639bd3d83e7855e0ee4f6defc.
    
    This commit moved the ravb_mdio_init() call (and thus the
    of_mdiobus_register() call) from the ravb_probe() to the ravb_open()
    call.  This causes a regression during system resume (s2idle/s2ram), as
    new PHY devices cannot be bound while suspended.
    
    During boot, the Micrel PHY is detected like this:
    
        Micrel KSZ9031 Gigabit PHY e6800000.ethernet-ffffffff:00: attached PHY driver [Micrel KSZ9031 Gigabit PHY] (mii_bus:phy_addr=e6800000.ethernet-ffffffff:00, irq=228)
        ravb e6800000.ethernet eth0: Link is Up - 1Gbps/Full - flow control off
    
    During system suspend, (A) defer_all_probes is set to true, and (B)
    usermodehelper_disabled is set to UMH_DISABLED, to avoid drivers being
    probed while suspended.
    
      A. If CONFIG_MODULES=n, phy_device_register() calling device_add()
         merely adds the device, but does not probe it yet, as
         really_probe() returns early due to defer_all_probes being set:
    
           dpm_resume+0x128/0x4f8
             device_resume+0xcc/0x1b0
               dpm_run_callback+0x74/0x340
                 ravb_resume+0x190/0x1b8
                   ravb_open+0x84/0x770
                     of_mdiobus_register+0x1e0/0x468
                       of_mdiobus_register_phy+0x1b8/0x250
                         of_mdiobus_phy_device_register+0x178/0x1e8
                           phy_device_register+0x114/0x1b8
                             device_add+0x3d4/0x798
                               bus_probe_device+0x98/0xa0
                                 device_initial_probe+0x10/0x18
                                   __device_attach+0xe4/0x140
                                     bus_for_each_drv+0x64/0xc8
                                       __device_attach_driver+0xb8/0xe0
                                         driver_probe_device.part.11+0xc4/0xd8
                                           really_probe+0x32c/0x3b8
    
         Later, phy_attach_direct() notices no PHY driver has been bound,
         and falls back to the Generic PHY, leading to degraded operation:
    
           Generic PHY e6800000.ethernet-ffffffff:00: attached PHY driver [Generic PHY] (mii_bus:phy_addr=e6800000.ethernet-ffffffff:00, irq=POLL)
           ravb e6800000.ethernet eth0: Link is Up - 1Gbps/Full - flow control off
    
      B. If CONFIG_MODULES=y, request_module() returns early with -EBUSY due
         to UMH_DISABLED, and MDIO initialization fails completely:
    
           mdio_bus e6800000.ethernet-ffffffff:00: error -16 loading PHY driver module for ID 0x00221622
           ravb e6800000.ethernet eth0: failed to initialize MDIO
           PM: dpm_run_callback(): ravb_resume+0x0/0x1b8 returns -16
           PM: Device e6800000.ethernet failed to resume: error -16
    
         Ignoring -EBUSY in phy_request_driver_module(), like was done for
         -ENOENT in commit 21e194425abd65b5 ("net: phy: fix issue with loading
         PHY driver w/o initramfs"), would makes it fall back to the Generic
         PHY, like in the CONFIG_MODULES=n case.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Cc: stable@vger.kernel.org
    Reviewed-by: Sergei Shtylyov <sergei.shtylyov@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 6e8836c6df5327bdb24211424f1ad1411d1ed64a
Author: Tingwei Zhang <tingwei@codeaurora.org>
Date:   Wed Sep 16 13:17:27 2020 -0600

    coresight: cti: remove pm_runtime_get_sync() from CPU hotplug
    
    Below BUG is triggered by call pm_runtime_get_sync() in
    cti_cpuhp_enable_hw(). It's in CPU hotplug callback with interrupt
    disabled. Pm_runtime_get_sync() calls clock driver to enable clock
    which could sleep. Remove pm_runtime_get_sync() in cti_cpuhp_enable_hw()
    since pm_runtime_get_sync() is called in cti_enabld and pm_runtime_put()
    is called in cti_disabled. No need to increase pm count when CPU gets
    online since it's not decreased when CPU is offline.
    
    [  105.800279] BUG: scheduling while atomic: swapper/1/0/0x00000002
    [  105.800290] Modules linked in:
    [  105.800327] CPU: 1 PID: 0 Comm: swapper/1 Tainted: G        W
    5.9.0-rc1-gff1304be0a05-dirty #21
    [  105.800337] Hardware name: Thundercomm Dragonboard 845c (DT)
    [  105.800353] Call trace:
    [  105.800414]  dump_backtrace+0x0/0x1d4
    [  105.800439]  show_stack+0x14/0x1c
    [  105.800462]  dump_stack+0xc0/0x100
    [  105.800490]  __schedule_bug+0x58/0x74
    [  105.800523]  __schedule+0x590/0x65c
    [  105.800538]  schedule+0x78/0x10c
    [  105.800553]  schedule_timeout+0x188/0x250
    [  105.800585]  qmp_send.constprop.10+0x12c/0x1b0
    [  105.800599]  qmp_qdss_clk_prepare+0x18/0x20
    [  105.800622]  clk_core_prepare+0x48/0xd4
    [  105.800639]  clk_prepare+0x20/0x34
    [  105.800663]  amba_pm_runtime_resume+0x54/0x90
    [  105.800695]  __rpm_callback+0xdc/0x138
    [  105.800709]  rpm_callback+0x24/0x78
    [  105.800724]  rpm_resume+0x328/0x47c
    [  105.800739]  __pm_runtime_resume+0x50/0x74
    [  105.800768]  cti_starting_cpu+0x40/0xa4
    [  105.800795]  cpuhp_invoke_callback+0x84/0x1e0
    [  105.800814]  notify_cpu_starting+0x9c/0xb8
    [  105.800834]  secondary_start_kernel+0xd8/0x164
    [  105.800933] CPU1: Booted secondary processor 0x0000000100 [0x517f803c]
    
    Fixes: e9b880581d55 ("coresight: cti: Add CPU Hotplug handling to CTI driver")
    Reviewed-by: Mike Leach <mike.leach@linaro.org>
    Signed-off-by: Tingwei Zhang <tingwei@codeaurora.org>
    Signed-off-by: Mathieu Poirier <mathieu.poirier@linaro.org>
    Link: https://lore.kernel.org/r/20200916191737.4001561-7-mathieu.poirier@linaro.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 826dc08af3f16d0aba7d3308d3fe933d0cc5700e
Author: Tony Lindgren <tony@atomide.com>
Date:   Thu Jul 2 10:44:20 2020 -0700

    bus: ti-sysc: Fix wakeirq sleeping function called from invalid context
    
    [ Upstream commit 9f9113925018d500a95df539014d9ff11ac2c02d ]
    
    With CONFIG_DEBUG_ATOMIC_SLEEP enabled we can see the following with
    wakeirqs and serial console idled:
    
    BUG: sleeping function called from invalid context at drivers/bus/ti-sysc.c:242
    ...
    (sysc_wait_softreset) from [<c0606894>] (sysc_enable_module+0x48/0x274)
    (sysc_enable_module) from [<c0606c5c>] (sysc_runtime_resume+0x19c/0x1d8)
    (sysc_runtime_resume) from [<c0606cf0>] (sysc_child_runtime_resume+0x58/0x84)
    (sysc_child_runtime_resume) from [<c06eb7bc>] (__rpm_callback+0x30/0x12c)
    (__rpm_callback) from [<c06eb8d8>] (rpm_callback+0x20/0x80)
    (rpm_callback) from [<c06eb434>] (rpm_resume+0x638/0x7fc)
    (rpm_resume) from [<c06eb658>] (__pm_runtime_resume+0x60/0x9c)
    (__pm_runtime_resume) from [<c06edc08>] (handle_threaded_wake_irq+0x24/0x60)
    (handle_threaded_wake_irq) from [<c01befec>] (irq_thread_fn+0x1c/0x78)
    (irq_thread_fn) from [<c01bf30c>] (irq_thread+0x140/0x26c)
    
    We have __pm_runtime_resume() call the sysc_runtime_resume() with spinlock
    held and interrupts disabled.
    
    Fixes: d46f9fbec719 ("bus: ti-sysc: Use optional clocks on for enable and wait for softreset bit")
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 5a23897f7a411f32d531ac52cfbf46e39f137e87
Author: Tony Lindgren <tony@atomide.com>
Date:   Thu Jul 2 10:44:20 2020 -0700

    bus: ti-sysc: Fix wakeirq sleeping function called from invalid context
    
    [ Upstream commit 9f9113925018d500a95df539014d9ff11ac2c02d ]
    
    With CONFIG_DEBUG_ATOMIC_SLEEP enabled we can see the following with
    wakeirqs and serial console idled:
    
    BUG: sleeping function called from invalid context at drivers/bus/ti-sysc.c:242
    ...
    (sysc_wait_softreset) from [<c0606894>] (sysc_enable_module+0x48/0x274)
    (sysc_enable_module) from [<c0606c5c>] (sysc_runtime_resume+0x19c/0x1d8)
    (sysc_runtime_resume) from [<c0606cf0>] (sysc_child_runtime_resume+0x58/0x84)
    (sysc_child_runtime_resume) from [<c06eb7bc>] (__rpm_callback+0x30/0x12c)
    (__rpm_callback) from [<c06eb8d8>] (rpm_callback+0x20/0x80)
    (rpm_callback) from [<c06eb434>] (rpm_resume+0x638/0x7fc)
    (rpm_resume) from [<c06eb658>] (__pm_runtime_resume+0x60/0x9c)
    (__pm_runtime_resume) from [<c06edc08>] (handle_threaded_wake_irq+0x24/0x60)
    (handle_threaded_wake_irq) from [<c01befec>] (irq_thread_fn+0x1c/0x78)
    (irq_thread_fn) from [<c01bf30c>] (irq_thread+0x140/0x26c)
    
    We have __pm_runtime_resume() call the sysc_runtime_resume() with spinlock
    held and interrupts disabled.
    
    Fixes: d46f9fbec719 ("bus: ti-sysc: Use optional clocks on for enable and wait for softreset bit")
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 9f9113925018d500a95df539014d9ff11ac2c02d
Author: Tony Lindgren <tony@atomide.com>
Date:   Thu Jul 2 10:44:20 2020 -0700

    bus: ti-sysc: Fix wakeirq sleeping function called from invalid context
    
    With CONFIG_DEBUG_ATOMIC_SLEEP enabled we can see the following with
    wakeirqs and serial console idled:
    
    BUG: sleeping function called from invalid context at drivers/bus/ti-sysc.c:242
    ...
    (sysc_wait_softreset) from [<c0606894>] (sysc_enable_module+0x48/0x274)
    (sysc_enable_module) from [<c0606c5c>] (sysc_runtime_resume+0x19c/0x1d8)
    (sysc_runtime_resume) from [<c0606cf0>] (sysc_child_runtime_resume+0x58/0x84)
    (sysc_child_runtime_resume) from [<c06eb7bc>] (__rpm_callback+0x30/0x12c)
    (__rpm_callback) from [<c06eb8d8>] (rpm_callback+0x20/0x80)
    (rpm_callback) from [<c06eb434>] (rpm_resume+0x638/0x7fc)
    (rpm_resume) from [<c06eb658>] (__pm_runtime_resume+0x60/0x9c)
    (__pm_runtime_resume) from [<c06edc08>] (handle_threaded_wake_irq+0x24/0x60)
    (handle_threaded_wake_irq) from [<c01befec>] (irq_thread_fn+0x1c/0x78)
    (irq_thread_fn) from [<c01bf30c>] (irq_thread+0x140/0x26c)
    
    We have __pm_runtime_resume() call the sysc_runtime_resume() with spinlock
    held and interrupts disabled.
    
    Fixes: d46f9fbec719 ("bus: ti-sysc: Use optional clocks on for enable and wait for softreset bit")
    Signed-off-by: Tony Lindgren <tony@atomide.com>

commit 75603a3112664cb1f6b1508e2b489f16863bf153
Author: Nathan Chancellor <natechancellor@gmail.com>
Date:   Tue Jun 30 14:00:34 2020 -0700

    pcnet32: Mark PM functions as __maybe_unused
    
    In certain configurations without power management support, the
    following warnings happen:
    
    ../drivers/net/ethernet/amd/pcnet32.c:2928:12: warning:
    'pcnet32_pm_resume' defined but not used [-Wunused-function]
     2928 | static int pcnet32_pm_resume(struct device *device_d)
          |            ^~~~~~~~~~~~~~~~~
    ../drivers/net/ethernet/amd/pcnet32.c:2916:12: warning:
    'pcnet32_pm_suspend' defined but not used [-Wunused-function]
     2916 | static int pcnet32_pm_suspend(struct device *device_d)
          |            ^~~~~~~~~~~~~~~~~~
    
    Mark these functions as __maybe_unused to make it clear to the compiler
    that this is going to happen based on the configuration, which is the
    standard for these types of functions.
    
    Fixes: a86688fbef1b ("pcnet32: Convert to generic power management")
    Signed-off-by: Nathan Chancellor <natechancellor@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 5365fc3132a36a027fd7c2bb461e651b37f1e4d1
Author: Qais Yousef <qais.yousef@arm.com>
Date:   Mon May 18 16:49:29 2020 +0100

    usb/ohci-platform: Fix a warning when hibernating
    
    [ Upstream commit 1cb3b0095c3d0bb96912bfbbce4fc006d41f367c ]
    
    The following warning was observed when attempting to suspend to disk
    using a USB flash as a swap device.
    
    [  111.779649] ------------[ cut here ]------------
    [  111.788382] URB (____ptrval____) submitted while active
    [  111.796646] WARNING: CPU: 3 PID: 365 at drivers/usb/core/urb.c:363 usb_submit_urb+0x3d8/0x590
    [  111.805417] Modules linked in:
    [  111.808584] CPU: 3 PID: 365 Comm: kworker/3:2 Not tainted 5.6.0-rc6-00002-gdfd1731f9a3e-dirty #545
    [  111.817796] Hardware name: ARM Juno development board (r2) (DT)
    [  111.823896] Workqueue: usb_hub_wq hub_event
    [  111.828217] pstate: 60000005 (nZCv daif -PAN -UAO)
    [  111.833156] pc : usb_submit_urb+0x3d8/0x590
    [  111.837471] lr : usb_submit_urb+0x3d8/0x590
    [  111.841783] sp : ffff800018de38b0
    [  111.845205] x29: ffff800018de38b0 x28: 0000000000000003
    [  111.850682] x27: ffff000970530b20 x26: ffff8000133fd000
    [  111.856159] x25: ffff8000133fd000 x24: ffff800018de3b38
    [  111.861635] x23: 0000000000000004 x22: 0000000000000c00
    [  111.867112] x21: 0000000000000000 x20: 00000000fffffff0
    [  111.872589] x19: ffff0009704e7a00 x18: ffffffffffffffff
    [  111.878065] x17: 00000000a7c8f4bc x16: 000000002af33de8
    [  111.883542] x15: ffff8000133fda88 x14: 0720072007200720
    [  111.889019] x13: 0720072007200720 x12: 0720072007200720
    [  111.894496] x11: 0000000000000000 x10: 00000000a5286134
    [  111.899973] x9 : 0000000000000002 x8 : ffff000970c837a0
    [  111.905449] x7 : 0000000000000000 x6 : ffff800018de3570
    [  111.910926] x5 : 0000000000000001 x4 : 0000000000000003
    [  111.916401] x3 : 0000000000000000 x2 : ffff800013427118
    [  111.921879] x1 : 9d4e965b4b7d7c00 x0 : 0000000000000000
    [  111.927356] Call trace:
    [  111.929892]  usb_submit_urb+0x3d8/0x590
    [  111.933852]  hub_activate+0x108/0x7f0
    [  111.937633]  hub_resume+0xac/0x148
    [  111.941149]  usb_resume_interface.isra.10+0x60/0x138
    [  111.946265]  usb_resume_both+0xe4/0x140
    [  111.950225]  usb_runtime_resume+0x24/0x30
    [  111.954365]  __rpm_callback+0xdc/0x138
    [  111.958236]  rpm_callback+0x34/0x98
    [  111.961841]  rpm_resume+0x4a8/0x720
    [  111.965445]  rpm_resume+0x50c/0x720
    [  111.969049]  __pm_runtime_resume+0x4c/0xb8
    [  111.973276]  usb_autopm_get_interface+0x28/0x60
    [  111.977948]  hub_event+0x80/0x16d8
    [  111.981466]  process_one_work+0x2a4/0x748
    [  111.985604]  worker_thread+0x48/0x498
    [  111.989387]  kthread+0x13c/0x140
    [  111.992725]  ret_from_fork+0x10/0x18
    [  111.996415] irq event stamp: 354
    [  111.999756] hardirqs last  enabled at (353): [<ffff80001019ea1c>] console_unlock+0x504/0x5b8
    [  112.008441] hardirqs last disabled at (354): [<ffff8000100a95d0>] do_debug_exception+0x1a8/0x258
    [  112.017479] softirqs last  enabled at (350): [<ffff8000100818a4>] __do_softirq+0x4bc/0x568
    [  112.025984] softirqs last disabled at (343): [<ffff8000101145a4>] irq_exit+0x144/0x150
    [  112.034129] ---[ end trace dc96030b9cf6c8a3 ]---
    
    The problem was tracked down to a missing call to
    pm_runtime_set_active() on resume in ohci-platform.
    
    Link: https://lore.kernel.org/lkml/20200323143857.db5zphxhq4hz3hmd@e107158-lin.cambridge.arm.com/
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Qais Yousef <qais.yousef@arm.com>
    CC: Tony Prisk <linux@prisktech.co.nz>
    CC: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    CC: Mathias Nyman <mathias.nyman@intel.com>
    CC: Oliver Neukum <oneukum@suse.de>
    CC: linux-arm-kernel@lists.infradead.org
    CC: linux-usb@vger.kernel.org
    CC: linux-kernel@vger.kernel.org
    Link: https://lore.kernel.org/r/20200518154931.6144-1-qais.yousef@arm.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 652def4c63b99029fe8b898740f97329c26a2fd3
Author: Qais Yousef <qais.yousef@arm.com>
Date:   Mon May 18 16:49:29 2020 +0100

    usb/ohci-platform: Fix a warning when hibernating
    
    [ Upstream commit 1cb3b0095c3d0bb96912bfbbce4fc006d41f367c ]
    
    The following warning was observed when attempting to suspend to disk
    using a USB flash as a swap device.
    
    [  111.779649] ------------[ cut here ]------------
    [  111.788382] URB (____ptrval____) submitted while active
    [  111.796646] WARNING: CPU: 3 PID: 365 at drivers/usb/core/urb.c:363 usb_submit_urb+0x3d8/0x590
    [  111.805417] Modules linked in:
    [  111.808584] CPU: 3 PID: 365 Comm: kworker/3:2 Not tainted 5.6.0-rc6-00002-gdfd1731f9a3e-dirty #545
    [  111.817796] Hardware name: ARM Juno development board (r2) (DT)
    [  111.823896] Workqueue: usb_hub_wq hub_event
    [  111.828217] pstate: 60000005 (nZCv daif -PAN -UAO)
    [  111.833156] pc : usb_submit_urb+0x3d8/0x590
    [  111.837471] lr : usb_submit_urb+0x3d8/0x590
    [  111.841783] sp : ffff800018de38b0
    [  111.845205] x29: ffff800018de38b0 x28: 0000000000000003
    [  111.850682] x27: ffff000970530b20 x26: ffff8000133fd000
    [  111.856159] x25: ffff8000133fd000 x24: ffff800018de3b38
    [  111.861635] x23: 0000000000000004 x22: 0000000000000c00
    [  111.867112] x21: 0000000000000000 x20: 00000000fffffff0
    [  111.872589] x19: ffff0009704e7a00 x18: ffffffffffffffff
    [  111.878065] x17: 00000000a7c8f4bc x16: 000000002af33de8
    [  111.883542] x15: ffff8000133fda88 x14: 0720072007200720
    [  111.889019] x13: 0720072007200720 x12: 0720072007200720
    [  111.894496] x11: 0000000000000000 x10: 00000000a5286134
    [  111.899973] x9 : 0000000000000002 x8 : ffff000970c837a0
    [  111.905449] x7 : 0000000000000000 x6 : ffff800018de3570
    [  111.910926] x5 : 0000000000000001 x4 : 0000000000000003
    [  111.916401] x3 : 0000000000000000 x2 : ffff800013427118
    [  111.921879] x1 : 9d4e965b4b7d7c00 x0 : 0000000000000000
    [  111.927356] Call trace:
    [  111.929892]  usb_submit_urb+0x3d8/0x590
    [  111.933852]  hub_activate+0x108/0x7f0
    [  111.937633]  hub_resume+0xac/0x148
    [  111.941149]  usb_resume_interface.isra.10+0x60/0x138
    [  111.946265]  usb_resume_both+0xe4/0x140
    [  111.950225]  usb_runtime_resume+0x24/0x30
    [  111.954365]  __rpm_callback+0xdc/0x138
    [  111.958236]  rpm_callback+0x34/0x98
    [  111.961841]  rpm_resume+0x4a8/0x720
    [  111.965445]  rpm_resume+0x50c/0x720
    [  111.969049]  __pm_runtime_resume+0x4c/0xb8
    [  111.973276]  usb_autopm_get_interface+0x28/0x60
    [  111.977948]  hub_event+0x80/0x16d8
    [  111.981466]  process_one_work+0x2a4/0x748
    [  111.985604]  worker_thread+0x48/0x498
    [  111.989387]  kthread+0x13c/0x140
    [  111.992725]  ret_from_fork+0x10/0x18
    [  111.996415] irq event stamp: 354
    [  111.999756] hardirqs last  enabled at (353): [<ffff80001019ea1c>] console_unlock+0x504/0x5b8
    [  112.008441] hardirqs last disabled at (354): [<ffff8000100a95d0>] do_debug_exception+0x1a8/0x258
    [  112.017479] softirqs last  enabled at (350): [<ffff8000100818a4>] __do_softirq+0x4bc/0x568
    [  112.025984] softirqs last disabled at (343): [<ffff8000101145a4>] irq_exit+0x144/0x150
    [  112.034129] ---[ end trace dc96030b9cf6c8a3 ]---
    
    The problem was tracked down to a missing call to
    pm_runtime_set_active() on resume in ohci-platform.
    
    Link: https://lore.kernel.org/lkml/20200323143857.db5zphxhq4hz3hmd@e107158-lin.cambridge.arm.com/
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Qais Yousef <qais.yousef@arm.com>
    CC: Tony Prisk <linux@prisktech.co.nz>
    CC: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    CC: Mathias Nyman <mathias.nyman@intel.com>
    CC: Oliver Neukum <oneukum@suse.de>
    CC: linux-arm-kernel@lists.infradead.org
    CC: linux-usb@vger.kernel.org
    CC: linux-kernel@vger.kernel.org
    Link: https://lore.kernel.org/r/20200518154931.6144-1-qais.yousef@arm.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit baef809ea497a4f21fa67814b61094bbcc191c39
Author: Qais Yousef <qais.yousef@arm.com>
Date:   Mon May 18 16:49:29 2020 +0100

    usb/ohci-platform: Fix a warning when hibernating
    
    [ Upstream commit 1cb3b0095c3d0bb96912bfbbce4fc006d41f367c ]
    
    The following warning was observed when attempting to suspend to disk
    using a USB flash as a swap device.
    
    [  111.779649] ------------[ cut here ]------------
    [  111.788382] URB (____ptrval____) submitted while active
    [  111.796646] WARNING: CPU: 3 PID: 365 at drivers/usb/core/urb.c:363 usb_submit_urb+0x3d8/0x590
    [  111.805417] Modules linked in:
    [  111.808584] CPU: 3 PID: 365 Comm: kworker/3:2 Not tainted 5.6.0-rc6-00002-gdfd1731f9a3e-dirty #545
    [  111.817796] Hardware name: ARM Juno development board (r2) (DT)
    [  111.823896] Workqueue: usb_hub_wq hub_event
    [  111.828217] pstate: 60000005 (nZCv daif -PAN -UAO)
    [  111.833156] pc : usb_submit_urb+0x3d8/0x590
    [  111.837471] lr : usb_submit_urb+0x3d8/0x590
    [  111.841783] sp : ffff800018de38b0
    [  111.845205] x29: ffff800018de38b0 x28: 0000000000000003
    [  111.850682] x27: ffff000970530b20 x26: ffff8000133fd000
    [  111.856159] x25: ffff8000133fd000 x24: ffff800018de3b38
    [  111.861635] x23: 0000000000000004 x22: 0000000000000c00
    [  111.867112] x21: 0000000000000000 x20: 00000000fffffff0
    [  111.872589] x19: ffff0009704e7a00 x18: ffffffffffffffff
    [  111.878065] x17: 00000000a7c8f4bc x16: 000000002af33de8
    [  111.883542] x15: ffff8000133fda88 x14: 0720072007200720
    [  111.889019] x13: 0720072007200720 x12: 0720072007200720
    [  111.894496] x11: 0000000000000000 x10: 00000000a5286134
    [  111.899973] x9 : 0000000000000002 x8 : ffff000970c837a0
    [  111.905449] x7 : 0000000000000000 x6 : ffff800018de3570
    [  111.910926] x5 : 0000000000000001 x4 : 0000000000000003
    [  111.916401] x3 : 0000000000000000 x2 : ffff800013427118
    [  111.921879] x1 : 9d4e965b4b7d7c00 x0 : 0000000000000000
    [  111.927356] Call trace:
    [  111.929892]  usb_submit_urb+0x3d8/0x590
    [  111.933852]  hub_activate+0x108/0x7f0
    [  111.937633]  hub_resume+0xac/0x148
    [  111.941149]  usb_resume_interface.isra.10+0x60/0x138
    [  111.946265]  usb_resume_both+0xe4/0x140
    [  111.950225]  usb_runtime_resume+0x24/0x30
    [  111.954365]  __rpm_callback+0xdc/0x138
    [  111.958236]  rpm_callback+0x34/0x98
    [  111.961841]  rpm_resume+0x4a8/0x720
    [  111.965445]  rpm_resume+0x50c/0x720
    [  111.969049]  __pm_runtime_resume+0x4c/0xb8
    [  111.973276]  usb_autopm_get_interface+0x28/0x60
    [  111.977948]  hub_event+0x80/0x16d8
    [  111.981466]  process_one_work+0x2a4/0x748
    [  111.985604]  worker_thread+0x48/0x498
    [  111.989387]  kthread+0x13c/0x140
    [  111.992725]  ret_from_fork+0x10/0x18
    [  111.996415] irq event stamp: 354
    [  111.999756] hardirqs last  enabled at (353): [<ffff80001019ea1c>] console_unlock+0x504/0x5b8
    [  112.008441] hardirqs last disabled at (354): [<ffff8000100a95d0>] do_debug_exception+0x1a8/0x258
    [  112.017479] softirqs last  enabled at (350): [<ffff8000100818a4>] __do_softirq+0x4bc/0x568
    [  112.025984] softirqs last disabled at (343): [<ffff8000101145a4>] irq_exit+0x144/0x150
    [  112.034129] ---[ end trace dc96030b9cf6c8a3 ]---
    
    The problem was tracked down to a missing call to
    pm_runtime_set_active() on resume in ohci-platform.
    
    Link: https://lore.kernel.org/lkml/20200323143857.db5zphxhq4hz3hmd@e107158-lin.cambridge.arm.com/
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Qais Yousef <qais.yousef@arm.com>
    CC: Tony Prisk <linux@prisktech.co.nz>
    CC: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    CC: Mathias Nyman <mathias.nyman@intel.com>
    CC: Oliver Neukum <oneukum@suse.de>
    CC: linux-arm-kernel@lists.infradead.org
    CC: linux-usb@vger.kernel.org
    CC: linux-kernel@vger.kernel.org
    Link: https://lore.kernel.org/r/20200518154931.6144-1-qais.yousef@arm.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit c83258a757687ffccce37ed73dba56cc6d4b8a1b
Author: Qais Yousef <qais.yousef@arm.com>
Date:   Mon May 18 16:49:29 2020 +0100

    usb/ohci-platform: Fix a warning when hibernating
    
    [ Upstream commit 1cb3b0095c3d0bb96912bfbbce4fc006d41f367c ]
    
    The following warning was observed when attempting to suspend to disk
    using a USB flash as a swap device.
    
    [  111.779649] ------------[ cut here ]------------
    [  111.788382] URB (____ptrval____) submitted while active
    [  111.796646] WARNING: CPU: 3 PID: 365 at drivers/usb/core/urb.c:363 usb_submit_urb+0x3d8/0x590
    [  111.805417] Modules linked in:
    [  111.808584] CPU: 3 PID: 365 Comm: kworker/3:2 Not tainted 5.6.0-rc6-00002-gdfd1731f9a3e-dirty #545
    [  111.817796] Hardware name: ARM Juno development board (r2) (DT)
    [  111.823896] Workqueue: usb_hub_wq hub_event
    [  111.828217] pstate: 60000005 (nZCv daif -PAN -UAO)
    [  111.833156] pc : usb_submit_urb+0x3d8/0x590
    [  111.837471] lr : usb_submit_urb+0x3d8/0x590
    [  111.841783] sp : ffff800018de38b0
    [  111.845205] x29: ffff800018de38b0 x28: 0000000000000003
    [  111.850682] x27: ffff000970530b20 x26: ffff8000133fd000
    [  111.856159] x25: ffff8000133fd000 x24: ffff800018de3b38
    [  111.861635] x23: 0000000000000004 x22: 0000000000000c00
    [  111.867112] x21: 0000000000000000 x20: 00000000fffffff0
    [  111.872589] x19: ffff0009704e7a00 x18: ffffffffffffffff
    [  111.878065] x17: 00000000a7c8f4bc x16: 000000002af33de8
    [  111.883542] x15: ffff8000133fda88 x14: 0720072007200720
    [  111.889019] x13: 0720072007200720 x12: 0720072007200720
    [  111.894496] x11: 0000000000000000 x10: 00000000a5286134
    [  111.899973] x9 : 0000000000000002 x8 : ffff000970c837a0
    [  111.905449] x7 : 0000000000000000 x6 : ffff800018de3570
    [  111.910926] x5 : 0000000000000001 x4 : 0000000000000003
    [  111.916401] x3 : 0000000000000000 x2 : ffff800013427118
    [  111.921879] x1 : 9d4e965b4b7d7c00 x0 : 0000000000000000
    [  111.927356] Call trace:
    [  111.929892]  usb_submit_urb+0x3d8/0x590
    [  111.933852]  hub_activate+0x108/0x7f0
    [  111.937633]  hub_resume+0xac/0x148
    [  111.941149]  usb_resume_interface.isra.10+0x60/0x138
    [  111.946265]  usb_resume_both+0xe4/0x140
    [  111.950225]  usb_runtime_resume+0x24/0x30
    [  111.954365]  __rpm_callback+0xdc/0x138
    [  111.958236]  rpm_callback+0x34/0x98
    [  111.961841]  rpm_resume+0x4a8/0x720
    [  111.965445]  rpm_resume+0x50c/0x720
    [  111.969049]  __pm_runtime_resume+0x4c/0xb8
    [  111.973276]  usb_autopm_get_interface+0x28/0x60
    [  111.977948]  hub_event+0x80/0x16d8
    [  111.981466]  process_one_work+0x2a4/0x748
    [  111.985604]  worker_thread+0x48/0x498
    [  111.989387]  kthread+0x13c/0x140
    [  111.992725]  ret_from_fork+0x10/0x18
    [  111.996415] irq event stamp: 354
    [  111.999756] hardirqs last  enabled at (353): [<ffff80001019ea1c>] console_unlock+0x504/0x5b8
    [  112.008441] hardirqs last disabled at (354): [<ffff8000100a95d0>] do_debug_exception+0x1a8/0x258
    [  112.017479] softirqs last  enabled at (350): [<ffff8000100818a4>] __do_softirq+0x4bc/0x568
    [  112.025984] softirqs last disabled at (343): [<ffff8000101145a4>] irq_exit+0x144/0x150
    [  112.034129] ---[ end trace dc96030b9cf6c8a3 ]---
    
    The problem was tracked down to a missing call to
    pm_runtime_set_active() on resume in ohci-platform.
    
    Link: https://lore.kernel.org/lkml/20200323143857.db5zphxhq4hz3hmd@e107158-lin.cambridge.arm.com/
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Qais Yousef <qais.yousef@arm.com>
    CC: Tony Prisk <linux@prisktech.co.nz>
    CC: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    CC: Mathias Nyman <mathias.nyman@intel.com>
    CC: Oliver Neukum <oneukum@suse.de>
    CC: linux-arm-kernel@lists.infradead.org
    CC: linux-usb@vger.kernel.org
    CC: linux-kernel@vger.kernel.org
    Link: https://lore.kernel.org/r/20200518154931.6144-1-qais.yousef@arm.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit fbf719e5da126c6b391ea7b1f38d4493582d8aaf
Author: Qais Yousef <qais.yousef@arm.com>
Date:   Mon May 18 16:49:29 2020 +0100

    usb/ohci-platform: Fix a warning when hibernating
    
    [ Upstream commit 1cb3b0095c3d0bb96912bfbbce4fc006d41f367c ]
    
    The following warning was observed when attempting to suspend to disk
    using a USB flash as a swap device.
    
    [  111.779649] ------------[ cut here ]------------
    [  111.788382] URB (____ptrval____) submitted while active
    [  111.796646] WARNING: CPU: 3 PID: 365 at drivers/usb/core/urb.c:363 usb_submit_urb+0x3d8/0x590
    [  111.805417] Modules linked in:
    [  111.808584] CPU: 3 PID: 365 Comm: kworker/3:2 Not tainted 5.6.0-rc6-00002-gdfd1731f9a3e-dirty #545
    [  111.817796] Hardware name: ARM Juno development board (r2) (DT)
    [  111.823896] Workqueue: usb_hub_wq hub_event
    [  111.828217] pstate: 60000005 (nZCv daif -PAN -UAO)
    [  111.833156] pc : usb_submit_urb+0x3d8/0x590
    [  111.837471] lr : usb_submit_urb+0x3d8/0x590
    [  111.841783] sp : ffff800018de38b0
    [  111.845205] x29: ffff800018de38b0 x28: 0000000000000003
    [  111.850682] x27: ffff000970530b20 x26: ffff8000133fd000
    [  111.856159] x25: ffff8000133fd000 x24: ffff800018de3b38
    [  111.861635] x23: 0000000000000004 x22: 0000000000000c00
    [  111.867112] x21: 0000000000000000 x20: 00000000fffffff0
    [  111.872589] x19: ffff0009704e7a00 x18: ffffffffffffffff
    [  111.878065] x17: 00000000a7c8f4bc x16: 000000002af33de8
    [  111.883542] x15: ffff8000133fda88 x14: 0720072007200720
    [  111.889019] x13: 0720072007200720 x12: 0720072007200720
    [  111.894496] x11: 0000000000000000 x10: 00000000a5286134
    [  111.899973] x9 : 0000000000000002 x8 : ffff000970c837a0
    [  111.905449] x7 : 0000000000000000 x6 : ffff800018de3570
    [  111.910926] x5 : 0000000000000001 x4 : 0000000000000003
    [  111.916401] x3 : 0000000000000000 x2 : ffff800013427118
    [  111.921879] x1 : 9d4e965b4b7d7c00 x0 : 0000000000000000
    [  111.927356] Call trace:
    [  111.929892]  usb_submit_urb+0x3d8/0x590
    [  111.933852]  hub_activate+0x108/0x7f0
    [  111.937633]  hub_resume+0xac/0x148
    [  111.941149]  usb_resume_interface.isra.10+0x60/0x138
    [  111.946265]  usb_resume_both+0xe4/0x140
    [  111.950225]  usb_runtime_resume+0x24/0x30
    [  111.954365]  __rpm_callback+0xdc/0x138
    [  111.958236]  rpm_callback+0x34/0x98
    [  111.961841]  rpm_resume+0x4a8/0x720
    [  111.965445]  rpm_resume+0x50c/0x720
    [  111.969049]  __pm_runtime_resume+0x4c/0xb8
    [  111.973276]  usb_autopm_get_interface+0x28/0x60
    [  111.977948]  hub_event+0x80/0x16d8
    [  111.981466]  process_one_work+0x2a4/0x748
    [  111.985604]  worker_thread+0x48/0x498
    [  111.989387]  kthread+0x13c/0x140
    [  111.992725]  ret_from_fork+0x10/0x18
    [  111.996415] irq event stamp: 354
    [  111.999756] hardirqs last  enabled at (353): [<ffff80001019ea1c>] console_unlock+0x504/0x5b8
    [  112.008441] hardirqs last disabled at (354): [<ffff8000100a95d0>] do_debug_exception+0x1a8/0x258
    [  112.017479] softirqs last  enabled at (350): [<ffff8000100818a4>] __do_softirq+0x4bc/0x568
    [  112.025984] softirqs last disabled at (343): [<ffff8000101145a4>] irq_exit+0x144/0x150
    [  112.034129] ---[ end trace dc96030b9cf6c8a3 ]---
    
    The problem was tracked down to a missing call to
    pm_runtime_set_active() on resume in ohci-platform.
    
    Link: https://lore.kernel.org/lkml/20200323143857.db5zphxhq4hz3hmd@e107158-lin.cambridge.arm.com/
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Qais Yousef <qais.yousef@arm.com>
    CC: Tony Prisk <linux@prisktech.co.nz>
    CC: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    CC: Mathias Nyman <mathias.nyman@intel.com>
    CC: Oliver Neukum <oneukum@suse.de>
    CC: linux-arm-kernel@lists.infradead.org
    CC: linux-usb@vger.kernel.org
    CC: linux-kernel@vger.kernel.org
    Link: https://lore.kernel.org/r/20200518154931.6144-1-qais.yousef@arm.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit a45fc52449d7a0686f31c079dc5f412b11d0f187
Author: Yong Zhi <yong.zhi@intel.com>
Date:   Fri May 1 18:44:21 2020 -0500

    ASoC: max98373: reorder max98373_reset() in resume
    
    [ Upstream commit 1a446873d7dd3a450f685928ce7f1907bde4583d ]
    
    During S3 test, the following error was observed:
    
    [ 726.174237] i2c_designware i2c_designware.0: platform_pm_resume+0x0/0x3d returned 0 after 0 usecs
    [ 726.184187] max98373 i2c-MX98373:00: calling max98373_resume+0x0/0x30 [snd_soc_max98373] @ 12698, parent: i2c-11
    [ 726.195589] max98373 i2c-MX98373:00: Reset command failed. (ret:-16)
    
    When calling regmap_update_bits(), since map->reg_update_bits is NULL,
    _regmap_read() is entered with the following logic:
    
            if (!map->cache_bypass) {
                    ret = regcache_read(map, reg, val);
                    if (ret == 0)
                            return 0;
            }
    
            if (map->cache_only)
                    return -EBUSY;
    
    regcache_read() hits -EINVAL because MAX98373_R2000_SW_RESET is volatile,
    as map->cache_only is set by codec suspend, thus -EBUSY is returned.
    Fix by moving max98373_reset() after cache_only set to false in max98373_resume().
    
    Signed-off-by: Yong Zhi <yong.zhi@intel.com>
    Link: https://lore.kernel.org/r/1588376661-29799-1-git-send-email-yong.zhi@intel.com
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit fc67821bd2c23f656acc8a0dfa649ed8f94e2264
Author: Qais Yousef <qais.yousef@arm.com>
Date:   Mon May 18 16:49:29 2020 +0100

    usb/ohci-platform: Fix a warning when hibernating
    
    [ Upstream commit 1cb3b0095c3d0bb96912bfbbce4fc006d41f367c ]
    
    The following warning was observed when attempting to suspend to disk
    using a USB flash as a swap device.
    
    [  111.779649] ------------[ cut here ]------------
    [  111.788382] URB (____ptrval____) submitted while active
    [  111.796646] WARNING: CPU: 3 PID: 365 at drivers/usb/core/urb.c:363 usb_submit_urb+0x3d8/0x590
    [  111.805417] Modules linked in:
    [  111.808584] CPU: 3 PID: 365 Comm: kworker/3:2 Not tainted 5.6.0-rc6-00002-gdfd1731f9a3e-dirty #545
    [  111.817796] Hardware name: ARM Juno development board (r2) (DT)
    [  111.823896] Workqueue: usb_hub_wq hub_event
    [  111.828217] pstate: 60000005 (nZCv daif -PAN -UAO)
    [  111.833156] pc : usb_submit_urb+0x3d8/0x590
    [  111.837471] lr : usb_submit_urb+0x3d8/0x590
    [  111.841783] sp : ffff800018de38b0
    [  111.845205] x29: ffff800018de38b0 x28: 0000000000000003
    [  111.850682] x27: ffff000970530b20 x26: ffff8000133fd000
    [  111.856159] x25: ffff8000133fd000 x24: ffff800018de3b38
    [  111.861635] x23: 0000000000000004 x22: 0000000000000c00
    [  111.867112] x21: 0000000000000000 x20: 00000000fffffff0
    [  111.872589] x19: ffff0009704e7a00 x18: ffffffffffffffff
    [  111.878065] x17: 00000000a7c8f4bc x16: 000000002af33de8
    [  111.883542] x15: ffff8000133fda88 x14: 0720072007200720
    [  111.889019] x13: 0720072007200720 x12: 0720072007200720
    [  111.894496] x11: 0000000000000000 x10: 00000000a5286134
    [  111.899973] x9 : 0000000000000002 x8 : ffff000970c837a0
    [  111.905449] x7 : 0000000000000000 x6 : ffff800018de3570
    [  111.910926] x5 : 0000000000000001 x4 : 0000000000000003
    [  111.916401] x3 : 0000000000000000 x2 : ffff800013427118
    [  111.921879] x1 : 9d4e965b4b7d7c00 x0 : 0000000000000000
    [  111.927356] Call trace:
    [  111.929892]  usb_submit_urb+0x3d8/0x590
    [  111.933852]  hub_activate+0x108/0x7f0
    [  111.937633]  hub_resume+0xac/0x148
    [  111.941149]  usb_resume_interface.isra.10+0x60/0x138
    [  111.946265]  usb_resume_both+0xe4/0x140
    [  111.950225]  usb_runtime_resume+0x24/0x30
    [  111.954365]  __rpm_callback+0xdc/0x138
    [  111.958236]  rpm_callback+0x34/0x98
    [  111.961841]  rpm_resume+0x4a8/0x720
    [  111.965445]  rpm_resume+0x50c/0x720
    [  111.969049]  __pm_runtime_resume+0x4c/0xb8
    [  111.973276]  usb_autopm_get_interface+0x28/0x60
    [  111.977948]  hub_event+0x80/0x16d8
    [  111.981466]  process_one_work+0x2a4/0x748
    [  111.985604]  worker_thread+0x48/0x498
    [  111.989387]  kthread+0x13c/0x140
    [  111.992725]  ret_from_fork+0x10/0x18
    [  111.996415] irq event stamp: 354
    [  111.999756] hardirqs last  enabled at (353): [<ffff80001019ea1c>] console_unlock+0x504/0x5b8
    [  112.008441] hardirqs last disabled at (354): [<ffff8000100a95d0>] do_debug_exception+0x1a8/0x258
    [  112.017479] softirqs last  enabled at (350): [<ffff8000100818a4>] __do_softirq+0x4bc/0x568
    [  112.025984] softirqs last disabled at (343): [<ffff8000101145a4>] irq_exit+0x144/0x150
    [  112.034129] ---[ end trace dc96030b9cf6c8a3 ]---
    
    The problem was tracked down to a missing call to
    pm_runtime_set_active() on resume in ohci-platform.
    
    Link: https://lore.kernel.org/lkml/20200323143857.db5zphxhq4hz3hmd@e107158-lin.cambridge.arm.com/
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Qais Yousef <qais.yousef@arm.com>
    CC: Tony Prisk <linux@prisktech.co.nz>
    CC: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    CC: Mathias Nyman <mathias.nyman@intel.com>
    CC: Oliver Neukum <oneukum@suse.de>
    CC: linux-arm-kernel@lists.infradead.org
    CC: linux-usb@vger.kernel.org
    CC: linux-kernel@vger.kernel.org
    Link: https://lore.kernel.org/r/20200518154931.6144-1-qais.yousef@arm.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 23be2c6ff86e25f780bbd82ded0a64bc34b874f6
Author: Yong Zhi <yong.zhi@intel.com>
Date:   Fri May 1 18:44:21 2020 -0500

    ASoC: max98373: reorder max98373_reset() in resume
    
    [ Upstream commit 1a446873d7dd3a450f685928ce7f1907bde4583d ]
    
    During S3 test, the following error was observed:
    
    [ 726.174237] i2c_designware i2c_designware.0: platform_pm_resume+0x0/0x3d returned 0 after 0 usecs
    [ 726.184187] max98373 i2c-MX98373:00: calling max98373_resume+0x0/0x30 [snd_soc_max98373] @ 12698, parent: i2c-11
    [ 726.195589] max98373 i2c-MX98373:00: Reset command failed. (ret:-16)
    
    When calling regmap_update_bits(), since map->reg_update_bits is NULL,
    _regmap_read() is entered with the following logic:
    
            if (!map->cache_bypass) {
                    ret = regcache_read(map, reg, val);
                    if (ret == 0)
                            return 0;
            }
    
            if (map->cache_only)
                    return -EBUSY;
    
    regcache_read() hits -EINVAL because MAX98373_R2000_SW_RESET is volatile,
    as map->cache_only is set by codec suspend, thus -EBUSY is returned.
    Fix by moving max98373_reset() after cache_only set to false in max98373_resume().
    
    Signed-off-by: Yong Zhi <yong.zhi@intel.com>
    Link: https://lore.kernel.org/r/1588376661-29799-1-git-send-email-yong.zhi@intel.com
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit d614ebdc69e8f0ed977f0f37fea9b1a987356577
Author: Li Jun <jun.li@nxp.com>
Date:   Thu May 14 14:04:32 2020 +0300

    usb: host: xhci-plat: keep runtime active when removing host
    
    commit 1449cb2c2253d37d998c3714aa9b95416d16d379 upstream.
    
    While removing the host (e.g. for USB role switch from host to device),
    if runtime pm is enabled by user, below oops occurs on dwc3 and cdns3
    platforms.
    Keeping the xhci-plat device active during host removal, and disabling
    runtime pm before calling pm_runtime_set_suspended() fixes them.
    
    oops1:
    Unable to handle kernel NULL pointer dereference at virtual address
    0000000000000240
    Internal error: Oops: 96000004 [#1] PREEMPT SMP
    Modules linked in:
    CPU: 0 PID: 5 Comm: kworker/0:0 Not tainted 5.4.3-00107-g64d454a-dirty
    Hardware name: FSL i.MX8MP EVK (DT)
    Workqueue: pm pm_runtime_work
    pstate: 60000005 (nZCv daif -PAN -UAO)
    pc : xhci_suspend+0x34/0x698
    lr : xhci_plat_runtime_suspend+0x2c/0x38
    sp : ffff800011ddbbc0
    Call trace:
     xhci_suspend+0x34/0x698
     xhci_plat_runtime_suspend+0x2c/0x38
     pm_generic_runtime_suspend+0x28/0x40
     __rpm_callback+0xd8/0x138
     rpm_callback+0x24/0x98
     rpm_suspend+0xe0/0x448
     rpm_idle+0x124/0x140
     pm_runtime_work+0xa0/0xf8
     process_one_work+0x1dc/0x370
     worker_thread+0x48/0x468
     kthread+0xf0/0x120
     ret_from_fork+0x10/0x1c
    
    oops2:
    usb 2-1: USB disconnect, device number 2
    xhci-hcd xhci-hcd.1.auto: remove, state 4
    usb usb2: USB disconnect, device number 1
    xhci-hcd xhci-hcd.1.auto: USB bus 2 deregistered
    xhci-hcd xhci-hcd.1.auto: remove, state 4
    usb usb1: USB disconnect, device number 1
    Unable to handle kernel NULL pointer dereference at virtual address
    0000000000000138
    Internal error: Oops: 96000004 [#1] PREEMPT SMP
    Modules linked in:
    CPU: 2 PID: 7 Comm: kworker/u8:0 Not tainted 5.6.0-rc4-next-20200304-03578
    Hardware name: Freescale i.MX8QXP MEK (DT)
    Workqueue: 1-0050 tcpm_state_machine_work
    pstate: 20000005 (nzCv daif -PAN -UAO)
    pc : xhci_free_dev+0x214/0x270
    lr : xhci_plat_runtime_resume+0x78/0x88
    sp : ffff80001006b5b0
    Call trace:
     xhci_free_dev+0x214/0x270
     xhci_plat_runtime_resume+0x78/0x88
     pm_generic_runtime_resume+0x30/0x48
     __rpm_callback+0x90/0x148
     rpm_callback+0x28/0x88
     rpm_resume+0x568/0x758
     rpm_resume+0x260/0x758
     rpm_resume+0x260/0x758
     __pm_runtime_resume+0x40/0x88
     device_release_driver_internal+0xa0/0x1c8
     device_release_driver+0x1c/0x28
     bus_remove_device+0xd4/0x158
     device_del+0x15c/0x3a0
     usb_disable_device+0xb0/0x268
     usb_disconnect+0xcc/0x300
     usb_remove_hcd+0xf4/0x1dc
     xhci_plat_remove+0x78/0xe0
     platform_drv_remove+0x30/0x50
     device_release_driver_internal+0xfc/0x1c8
     device_release_driver+0x1c/0x28
     bus_remove_device+0xd4/0x158
     device_del+0x15c/0x3a0
     platform_device_del.part.0+0x20/0x90
     platform_device_unregister+0x28/0x40
     cdns3_host_exit+0x20/0x40
     cdns3_role_stop+0x60/0x90
     cdns3_role_set+0x64/0xd8
     usb_role_switch_set_role.part.0+0x3c/0x68
     usb_role_switch_set_role+0x20/0x30
     tcpm_mux_set+0x60/0xf8
     tcpm_reset_port+0xa4/0xf0
     tcpm_detach.part.0+0x28/0x50
     tcpm_state_machine_work+0x12ac/0x2360
     process_one_work+0x1c8/0x470
     worker_thread+0x50/0x428
     kthread+0xfc/0x128
     ret_from_fork+0x10/0x18
    Code: c8037c02 35ffffa3 17ffe7c3 f9800011 (c85f7c01)
    ---[ end trace 45b1a173d2679e44 ]---
    
    [minor commit message cleanup  -Mathias]
    Cc: Baolin Wang <baolin.wang@linaro.org>
    Cc: <stable@vger.kernel.org>
    Fixes: b0c69b4bace3 ("usb: host: plat: Enable xHCI plat runtime PM")
    Reviewed-by: Peter Chen <peter.chen@nxp.com>
    Tested-by: Peter Chen <peter.chen@nxp.com>
    Signed-off-by: Li Jun <jun.li@nxp.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Link: https://lore.kernel.org/r/20200514110432.25564-3-mathias.nyman@linux.intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit f1a9bed7969a00fe604530adaa437e61aa06034a
Author: Li Jun <jun.li@nxp.com>
Date:   Thu May 14 14:04:32 2020 +0300

    usb: host: xhci-plat: keep runtime active when removing host
    
    commit 1449cb2c2253d37d998c3714aa9b95416d16d379 upstream.
    
    While removing the host (e.g. for USB role switch from host to device),
    if runtime pm is enabled by user, below oops occurs on dwc3 and cdns3
    platforms.
    Keeping the xhci-plat device active during host removal, and disabling
    runtime pm before calling pm_runtime_set_suspended() fixes them.
    
    oops1:
    Unable to handle kernel NULL pointer dereference at virtual address
    0000000000000240
    Internal error: Oops: 96000004 [#1] PREEMPT SMP
    Modules linked in:
    CPU: 0 PID: 5 Comm: kworker/0:0 Not tainted 5.4.3-00107-g64d454a-dirty
    Hardware name: FSL i.MX8MP EVK (DT)
    Workqueue: pm pm_runtime_work
    pstate: 60000005 (nZCv daif -PAN -UAO)
    pc : xhci_suspend+0x34/0x698
    lr : xhci_plat_runtime_suspend+0x2c/0x38
    sp : ffff800011ddbbc0
    Call trace:
     xhci_suspend+0x34/0x698
     xhci_plat_runtime_suspend+0x2c/0x38
     pm_generic_runtime_suspend+0x28/0x40
     __rpm_callback+0xd8/0x138
     rpm_callback+0x24/0x98
     rpm_suspend+0xe0/0x448
     rpm_idle+0x124/0x140
     pm_runtime_work+0xa0/0xf8
     process_one_work+0x1dc/0x370
     worker_thread+0x48/0x468
     kthread+0xf0/0x120
     ret_from_fork+0x10/0x1c
    
    oops2:
    usb 2-1: USB disconnect, device number 2
    xhci-hcd xhci-hcd.1.auto: remove, state 4
    usb usb2: USB disconnect, device number 1
    xhci-hcd xhci-hcd.1.auto: USB bus 2 deregistered
    xhci-hcd xhci-hcd.1.auto: remove, state 4
    usb usb1: USB disconnect, device number 1
    Unable to handle kernel NULL pointer dereference at virtual address
    0000000000000138
    Internal error: Oops: 96000004 [#1] PREEMPT SMP
    Modules linked in:
    CPU: 2 PID: 7 Comm: kworker/u8:0 Not tainted 5.6.0-rc4-next-20200304-03578
    Hardware name: Freescale i.MX8QXP MEK (DT)
    Workqueue: 1-0050 tcpm_state_machine_work
    pstate: 20000005 (nzCv daif -PAN -UAO)
    pc : xhci_free_dev+0x214/0x270
    lr : xhci_plat_runtime_resume+0x78/0x88
    sp : ffff80001006b5b0
    Call trace:
     xhci_free_dev+0x214/0x270
     xhci_plat_runtime_resume+0x78/0x88
     pm_generic_runtime_resume+0x30/0x48
     __rpm_callback+0x90/0x148
     rpm_callback+0x28/0x88
     rpm_resume+0x568/0x758
     rpm_resume+0x260/0x758
     rpm_resume+0x260/0x758
     __pm_runtime_resume+0x40/0x88
     device_release_driver_internal+0xa0/0x1c8
     device_release_driver+0x1c/0x28
     bus_remove_device+0xd4/0x158
     device_del+0x15c/0x3a0
     usb_disable_device+0xb0/0x268
     usb_disconnect+0xcc/0x300
     usb_remove_hcd+0xf4/0x1dc
     xhci_plat_remove+0x78/0xe0
     platform_drv_remove+0x30/0x50
     device_release_driver_internal+0xfc/0x1c8
     device_release_driver+0x1c/0x28
     bus_remove_device+0xd4/0x158
     device_del+0x15c/0x3a0
     platform_device_del.part.0+0x20/0x90
     platform_device_unregister+0x28/0x40
     cdns3_host_exit+0x20/0x40
     cdns3_role_stop+0x60/0x90
     cdns3_role_set+0x64/0xd8
     usb_role_switch_set_role.part.0+0x3c/0x68
     usb_role_switch_set_role+0x20/0x30
     tcpm_mux_set+0x60/0xf8
     tcpm_reset_port+0xa4/0xf0
     tcpm_detach.part.0+0x28/0x50
     tcpm_state_machine_work+0x12ac/0x2360
     process_one_work+0x1c8/0x470
     worker_thread+0x50/0x428
     kthread+0xfc/0x128
     ret_from_fork+0x10/0x18
    Code: c8037c02 35ffffa3 17ffe7c3 f9800011 (c85f7c01)
    ---[ end trace 45b1a173d2679e44 ]---
    
    [minor commit message cleanup  -Mathias]
    Cc: Baolin Wang <baolin.wang@linaro.org>
    Cc: <stable@vger.kernel.org>
    Fixes: b0c69b4bace3 ("usb: host: plat: Enable xHCI plat runtime PM")
    Reviewed-by: Peter Chen <peter.chen@nxp.com>
    Tested-by: Peter Chen <peter.chen@nxp.com>
    Signed-off-by: Li Jun <jun.li@nxp.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Link: https://lore.kernel.org/r/20200514110432.25564-3-mathias.nyman@linux.intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 8fd38d318e1544ef4ac2dda0bf67c5b6a9cd5b9d
Author: Li Jun <jun.li@nxp.com>
Date:   Thu May 14 14:04:32 2020 +0300

    usb: host: xhci-plat: keep runtime active when removing host
    
    commit 1449cb2c2253d37d998c3714aa9b95416d16d379 upstream.
    
    While removing the host (e.g. for USB role switch from host to device),
    if runtime pm is enabled by user, below oops occurs on dwc3 and cdns3
    platforms.
    Keeping the xhci-plat device active during host removal, and disabling
    runtime pm before calling pm_runtime_set_suspended() fixes them.
    
    oops1:
    Unable to handle kernel NULL pointer dereference at virtual address
    0000000000000240
    Internal error: Oops: 96000004 [#1] PREEMPT SMP
    Modules linked in:
    CPU: 0 PID: 5 Comm: kworker/0:0 Not tainted 5.4.3-00107-g64d454a-dirty
    Hardware name: FSL i.MX8MP EVK (DT)
    Workqueue: pm pm_runtime_work
    pstate: 60000005 (nZCv daif -PAN -UAO)
    pc : xhci_suspend+0x34/0x698
    lr : xhci_plat_runtime_suspend+0x2c/0x38
    sp : ffff800011ddbbc0
    Call trace:
     xhci_suspend+0x34/0x698
     xhci_plat_runtime_suspend+0x2c/0x38
     pm_generic_runtime_suspend+0x28/0x40
     __rpm_callback+0xd8/0x138
     rpm_callback+0x24/0x98
     rpm_suspend+0xe0/0x448
     rpm_idle+0x124/0x140
     pm_runtime_work+0xa0/0xf8
     process_one_work+0x1dc/0x370
     worker_thread+0x48/0x468
     kthread+0xf0/0x120
     ret_from_fork+0x10/0x1c
    
    oops2:
    usb 2-1: USB disconnect, device number 2
    xhci-hcd xhci-hcd.1.auto: remove, state 4
    usb usb2: USB disconnect, device number 1
    xhci-hcd xhci-hcd.1.auto: USB bus 2 deregistered
    xhci-hcd xhci-hcd.1.auto: remove, state 4
    usb usb1: USB disconnect, device number 1
    Unable to handle kernel NULL pointer dereference at virtual address
    0000000000000138
    Internal error: Oops: 96000004 [#1] PREEMPT SMP
    Modules linked in:
    CPU: 2 PID: 7 Comm: kworker/u8:0 Not tainted 5.6.0-rc4-next-20200304-03578
    Hardware name: Freescale i.MX8QXP MEK (DT)
    Workqueue: 1-0050 tcpm_state_machine_work
    pstate: 20000005 (nzCv daif -PAN -UAO)
    pc : xhci_free_dev+0x214/0x270
    lr : xhci_plat_runtime_resume+0x78/0x88
    sp : ffff80001006b5b0
    Call trace:
     xhci_free_dev+0x214/0x270
     xhci_plat_runtime_resume+0x78/0x88
     pm_generic_runtime_resume+0x30/0x48
     __rpm_callback+0x90/0x148
     rpm_callback+0x28/0x88
     rpm_resume+0x568/0x758
     rpm_resume+0x260/0x758
     rpm_resume+0x260/0x758
     __pm_runtime_resume+0x40/0x88
     device_release_driver_internal+0xa0/0x1c8
     device_release_driver+0x1c/0x28
     bus_remove_device+0xd4/0x158
     device_del+0x15c/0x3a0
     usb_disable_device+0xb0/0x268
     usb_disconnect+0xcc/0x300
     usb_remove_hcd+0xf4/0x1dc
     xhci_plat_remove+0x78/0xe0
     platform_drv_remove+0x30/0x50
     device_release_driver_internal+0xfc/0x1c8
     device_release_driver+0x1c/0x28
     bus_remove_device+0xd4/0x158
     device_del+0x15c/0x3a0
     platform_device_del.part.0+0x20/0x90
     platform_device_unregister+0x28/0x40
     cdns3_host_exit+0x20/0x40
     cdns3_role_stop+0x60/0x90
     cdns3_role_set+0x64/0xd8
     usb_role_switch_set_role.part.0+0x3c/0x68
     usb_role_switch_set_role+0x20/0x30
     tcpm_mux_set+0x60/0xf8
     tcpm_reset_port+0xa4/0xf0
     tcpm_detach.part.0+0x28/0x50
     tcpm_state_machine_work+0x12ac/0x2360
     process_one_work+0x1c8/0x470
     worker_thread+0x50/0x428
     kthread+0xfc/0x128
     ret_from_fork+0x10/0x18
    Code: c8037c02 35ffffa3 17ffe7c3 f9800011 (c85f7c01)
    ---[ end trace 45b1a173d2679e44 ]---
    
    [minor commit message cleanup  -Mathias]
    Cc: Baolin Wang <baolin.wang@linaro.org>
    Cc: <stable@vger.kernel.org>
    Fixes: b0c69b4bace3 ("usb: host: plat: Enable xHCI plat runtime PM")
    Reviewed-by: Peter Chen <peter.chen@nxp.com>
    Tested-by: Peter Chen <peter.chen@nxp.com>
    Signed-off-by: Li Jun <jun.li@nxp.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Link: https://lore.kernel.org/r/20200514110432.25564-3-mathias.nyman@linux.intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit c4901f9fcf71faad2f0876d482508dade8488da9
Author: Li Jun <jun.li@nxp.com>
Date:   Thu May 14 14:04:32 2020 +0300

    usb: host: xhci-plat: keep runtime active when removing host
    
    commit 1449cb2c2253d37d998c3714aa9b95416d16d379 upstream.
    
    While removing the host (e.g. for USB role switch from host to device),
    if runtime pm is enabled by user, below oops occurs on dwc3 and cdns3
    platforms.
    Keeping the xhci-plat device active during host removal, and disabling
    runtime pm before calling pm_runtime_set_suspended() fixes them.
    
    oops1:
    Unable to handle kernel NULL pointer dereference at virtual address
    0000000000000240
    Internal error: Oops: 96000004 [#1] PREEMPT SMP
    Modules linked in:
    CPU: 0 PID: 5 Comm: kworker/0:0 Not tainted 5.4.3-00107-g64d454a-dirty
    Hardware name: FSL i.MX8MP EVK (DT)
    Workqueue: pm pm_runtime_work
    pstate: 60000005 (nZCv daif -PAN -UAO)
    pc : xhci_suspend+0x34/0x698
    lr : xhci_plat_runtime_suspend+0x2c/0x38
    sp : ffff800011ddbbc0
    Call trace:
     xhci_suspend+0x34/0x698
     xhci_plat_runtime_suspend+0x2c/0x38
     pm_generic_runtime_suspend+0x28/0x40
     __rpm_callback+0xd8/0x138
     rpm_callback+0x24/0x98
     rpm_suspend+0xe0/0x448
     rpm_idle+0x124/0x140
     pm_runtime_work+0xa0/0xf8
     process_one_work+0x1dc/0x370
     worker_thread+0x48/0x468
     kthread+0xf0/0x120
     ret_from_fork+0x10/0x1c
    
    oops2:
    usb 2-1: USB disconnect, device number 2
    xhci-hcd xhci-hcd.1.auto: remove, state 4
    usb usb2: USB disconnect, device number 1
    xhci-hcd xhci-hcd.1.auto: USB bus 2 deregistered
    xhci-hcd xhci-hcd.1.auto: remove, state 4
    usb usb1: USB disconnect, device number 1
    Unable to handle kernel NULL pointer dereference at virtual address
    0000000000000138
    Internal error: Oops: 96000004 [#1] PREEMPT SMP
    Modules linked in:
    CPU: 2 PID: 7 Comm: kworker/u8:0 Not tainted 5.6.0-rc4-next-20200304-03578
    Hardware name: Freescale i.MX8QXP MEK (DT)
    Workqueue: 1-0050 tcpm_state_machine_work
    pstate: 20000005 (nzCv daif -PAN -UAO)
    pc : xhci_free_dev+0x214/0x270
    lr : xhci_plat_runtime_resume+0x78/0x88
    sp : ffff80001006b5b0
    Call trace:
     xhci_free_dev+0x214/0x270
     xhci_plat_runtime_resume+0x78/0x88
     pm_generic_runtime_resume+0x30/0x48
     __rpm_callback+0x90/0x148
     rpm_callback+0x28/0x88
     rpm_resume+0x568/0x758
     rpm_resume+0x260/0x758
     rpm_resume+0x260/0x758
     __pm_runtime_resume+0x40/0x88
     device_release_driver_internal+0xa0/0x1c8
     device_release_driver+0x1c/0x28
     bus_remove_device+0xd4/0x158
     device_del+0x15c/0x3a0
     usb_disable_device+0xb0/0x268
     usb_disconnect+0xcc/0x300
     usb_remove_hcd+0xf4/0x1dc
     xhci_plat_remove+0x78/0xe0
     platform_drv_remove+0x30/0x50
     device_release_driver_internal+0xfc/0x1c8
     device_release_driver+0x1c/0x28
     bus_remove_device+0xd4/0x158
     device_del+0x15c/0x3a0
     platform_device_del.part.0+0x20/0x90
     platform_device_unregister+0x28/0x40
     cdns3_host_exit+0x20/0x40
     cdns3_role_stop+0x60/0x90
     cdns3_role_set+0x64/0xd8
     usb_role_switch_set_role.part.0+0x3c/0x68
     usb_role_switch_set_role+0x20/0x30
     tcpm_mux_set+0x60/0xf8
     tcpm_reset_port+0xa4/0xf0
     tcpm_detach.part.0+0x28/0x50
     tcpm_state_machine_work+0x12ac/0x2360
     process_one_work+0x1c8/0x470
     worker_thread+0x50/0x428
     kthread+0xfc/0x128
     ret_from_fork+0x10/0x18
    Code: c8037c02 35ffffa3 17ffe7c3 f9800011 (c85f7c01)
    ---[ end trace 45b1a173d2679e44 ]---
    
    [minor commit message cleanup  -Mathias]
    Cc: Baolin Wang <baolin.wang@linaro.org>
    Cc: <stable@vger.kernel.org>
    Fixes: b0c69b4bace3 ("usb: host: plat: Enable xHCI plat runtime PM")
    Reviewed-by: Peter Chen <peter.chen@nxp.com>
    Tested-by: Peter Chen <peter.chen@nxp.com>
    Signed-off-by: Li Jun <jun.li@nxp.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Link: https://lore.kernel.org/r/20200514110432.25564-3-mathias.nyman@linux.intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 1cb3b0095c3d0bb96912bfbbce4fc006d41f367c
Author: Qais Yousef <qais.yousef@arm.com>
Date:   Mon May 18 16:49:29 2020 +0100

    usb/ohci-platform: Fix a warning when hibernating
    
    The following warning was observed when attempting to suspend to disk
    using a USB flash as a swap device.
    
    [  111.779649] ------------[ cut here ]------------
    [  111.788382] URB (____ptrval____) submitted while active
    [  111.796646] WARNING: CPU: 3 PID: 365 at drivers/usb/core/urb.c:363 usb_submit_urb+0x3d8/0x590
    [  111.805417] Modules linked in:
    [  111.808584] CPU: 3 PID: 365 Comm: kworker/3:2 Not tainted 5.6.0-rc6-00002-gdfd1731f9a3e-dirty #545
    [  111.817796] Hardware name: ARM Juno development board (r2) (DT)
    [  111.823896] Workqueue: usb_hub_wq hub_event
    [  111.828217] pstate: 60000005 (nZCv daif -PAN -UAO)
    [  111.833156] pc : usb_submit_urb+0x3d8/0x590
    [  111.837471] lr : usb_submit_urb+0x3d8/0x590
    [  111.841783] sp : ffff800018de38b0
    [  111.845205] x29: ffff800018de38b0 x28: 0000000000000003
    [  111.850682] x27: ffff000970530b20 x26: ffff8000133fd000
    [  111.856159] x25: ffff8000133fd000 x24: ffff800018de3b38
    [  111.861635] x23: 0000000000000004 x22: 0000000000000c00
    [  111.867112] x21: 0000000000000000 x20: 00000000fffffff0
    [  111.872589] x19: ffff0009704e7a00 x18: ffffffffffffffff
    [  111.878065] x17: 00000000a7c8f4bc x16: 000000002af33de8
    [  111.883542] x15: ffff8000133fda88 x14: 0720072007200720
    [  111.889019] x13: 0720072007200720 x12: 0720072007200720
    [  111.894496] x11: 0000000000000000 x10: 00000000a5286134
    [  111.899973] x9 : 0000000000000002 x8 : ffff000970c837a0
    [  111.905449] x7 : 0000000000000000 x6 : ffff800018de3570
    [  111.910926] x5 : 0000000000000001 x4 : 0000000000000003
    [  111.916401] x3 : 0000000000000000 x2 : ffff800013427118
    [  111.921879] x1 : 9d4e965b4b7d7c00 x0 : 0000000000000000
    [  111.927356] Call trace:
    [  111.929892]  usb_submit_urb+0x3d8/0x590
    [  111.933852]  hub_activate+0x108/0x7f0
    [  111.937633]  hub_resume+0xac/0x148
    [  111.941149]  usb_resume_interface.isra.10+0x60/0x138
    [  111.946265]  usb_resume_both+0xe4/0x140
    [  111.950225]  usb_runtime_resume+0x24/0x30
    [  111.954365]  __rpm_callback+0xdc/0x138
    [  111.958236]  rpm_callback+0x34/0x98
    [  111.961841]  rpm_resume+0x4a8/0x720
    [  111.965445]  rpm_resume+0x50c/0x720
    [  111.969049]  __pm_runtime_resume+0x4c/0xb8
    [  111.973276]  usb_autopm_get_interface+0x28/0x60
    [  111.977948]  hub_event+0x80/0x16d8
    [  111.981466]  process_one_work+0x2a4/0x748
    [  111.985604]  worker_thread+0x48/0x498
    [  111.989387]  kthread+0x13c/0x140
    [  111.992725]  ret_from_fork+0x10/0x18
    [  111.996415] irq event stamp: 354
    [  111.999756] hardirqs last  enabled at (353): [<ffff80001019ea1c>] console_unlock+0x504/0x5b8
    [  112.008441] hardirqs last disabled at (354): [<ffff8000100a95d0>] do_debug_exception+0x1a8/0x258
    [  112.017479] softirqs last  enabled at (350): [<ffff8000100818a4>] __do_softirq+0x4bc/0x568
    [  112.025984] softirqs last disabled at (343): [<ffff8000101145a4>] irq_exit+0x144/0x150
    [  112.034129] ---[ end trace dc96030b9cf6c8a3 ]---
    
    The problem was tracked down to a missing call to
    pm_runtime_set_active() on resume in ohci-platform.
    
    Link: https://lore.kernel.org/lkml/20200323143857.db5zphxhq4hz3hmd@e107158-lin.cambridge.arm.com/
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Qais Yousef <qais.yousef@arm.com>
    CC: Tony Prisk <linux@prisktech.co.nz>
    CC: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    CC: Mathias Nyman <mathias.nyman@intel.com>
    CC: Oliver Neukum <oneukum@suse.de>
    CC: linux-arm-kernel@lists.infradead.org
    CC: linux-usb@vger.kernel.org
    CC: linux-kernel@vger.kernel.org
    Link: https://lore.kernel.org/r/20200518154931.6144-1-qais.yousef@arm.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 1449cb2c2253d37d998c3714aa9b95416d16d379
Author: Li Jun <jun.li@nxp.com>
Date:   Thu May 14 14:04:32 2020 +0300

    usb: host: xhci-plat: keep runtime active when removing host
    
    While removing the host (e.g. for USB role switch from host to device),
    if runtime pm is enabled by user, below oops occurs on dwc3 and cdns3
    platforms.
    Keeping the xhci-plat device active during host removal, and disabling
    runtime pm before calling pm_runtime_set_suspended() fixes them.
    
    oops1:
    Unable to handle kernel NULL pointer dereference at virtual address
    0000000000000240
    Internal error: Oops: 96000004 [#1] PREEMPT SMP
    Modules linked in:
    CPU: 0 PID: 5 Comm: kworker/0:0 Not tainted 5.4.3-00107-g64d454a-dirty
    Hardware name: FSL i.MX8MP EVK (DT)
    Workqueue: pm pm_runtime_work
    pstate: 60000005 (nZCv daif -PAN -UAO)
    pc : xhci_suspend+0x34/0x698
    lr : xhci_plat_runtime_suspend+0x2c/0x38
    sp : ffff800011ddbbc0
    Call trace:
     xhci_suspend+0x34/0x698
     xhci_plat_runtime_suspend+0x2c/0x38
     pm_generic_runtime_suspend+0x28/0x40
     __rpm_callback+0xd8/0x138
     rpm_callback+0x24/0x98
     rpm_suspend+0xe0/0x448
     rpm_idle+0x124/0x140
     pm_runtime_work+0xa0/0xf8
     process_one_work+0x1dc/0x370
     worker_thread+0x48/0x468
     kthread+0xf0/0x120
     ret_from_fork+0x10/0x1c
    
    oops2:
    usb 2-1: USB disconnect, device number 2
    xhci-hcd xhci-hcd.1.auto: remove, state 4
    usb usb2: USB disconnect, device number 1
    xhci-hcd xhci-hcd.1.auto: USB bus 2 deregistered
    xhci-hcd xhci-hcd.1.auto: remove, state 4
    usb usb1: USB disconnect, device number 1
    Unable to handle kernel NULL pointer dereference at virtual address
    0000000000000138
    Internal error: Oops: 96000004 [#1] PREEMPT SMP
    Modules linked in:
    CPU: 2 PID: 7 Comm: kworker/u8:0 Not tainted 5.6.0-rc4-next-20200304-03578
    Hardware name: Freescale i.MX8QXP MEK (DT)
    Workqueue: 1-0050 tcpm_state_machine_work
    pstate: 20000005 (nzCv daif -PAN -UAO)
    pc : xhci_free_dev+0x214/0x270
    lr : xhci_plat_runtime_resume+0x78/0x88
    sp : ffff80001006b5b0
    Call trace:
     xhci_free_dev+0x214/0x270
     xhci_plat_runtime_resume+0x78/0x88
     pm_generic_runtime_resume+0x30/0x48
     __rpm_callback+0x90/0x148
     rpm_callback+0x28/0x88
     rpm_resume+0x568/0x758
     rpm_resume+0x260/0x758
     rpm_resume+0x260/0x758
     __pm_runtime_resume+0x40/0x88
     device_release_driver_internal+0xa0/0x1c8
     device_release_driver+0x1c/0x28
     bus_remove_device+0xd4/0x158
     device_del+0x15c/0x3a0
     usb_disable_device+0xb0/0x268
     usb_disconnect+0xcc/0x300
     usb_remove_hcd+0xf4/0x1dc
     xhci_plat_remove+0x78/0xe0
     platform_drv_remove+0x30/0x50
     device_release_driver_internal+0xfc/0x1c8
     device_release_driver+0x1c/0x28
     bus_remove_device+0xd4/0x158
     device_del+0x15c/0x3a0
     platform_device_del.part.0+0x20/0x90
     platform_device_unregister+0x28/0x40
     cdns3_host_exit+0x20/0x40
     cdns3_role_stop+0x60/0x90
     cdns3_role_set+0x64/0xd8
     usb_role_switch_set_role.part.0+0x3c/0x68
     usb_role_switch_set_role+0x20/0x30
     tcpm_mux_set+0x60/0xf8
     tcpm_reset_port+0xa4/0xf0
     tcpm_detach.part.0+0x28/0x50
     tcpm_state_machine_work+0x12ac/0x2360
     process_one_work+0x1c8/0x470
     worker_thread+0x50/0x428
     kthread+0xfc/0x128
     ret_from_fork+0x10/0x18
    Code: c8037c02 35ffffa3 17ffe7c3 f9800011 (c85f7c01)
    ---[ end trace 45b1a173d2679e44 ]---
    
    [minor commit message cleanup  -Mathias]
    Cc: Baolin Wang <baolin.wang@linaro.org>
    Cc: <stable@vger.kernel.org>
    Fixes: b0c69b4bace3 ("usb: host: plat: Enable xHCI plat runtime PM")
    Reviewed-by: Peter Chen <peter.chen@nxp.com>
    Tested-by: Peter Chen <peter.chen@nxp.com>
    Signed-off-by: Li Jun <jun.li@nxp.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Link: https://lore.kernel.org/r/20200514110432.25564-3-mathias.nyman@linux.intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 24769c71b2ed25c02b3702b556f2fc5604384259
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Tue Mar 29 12:45:43 2016 +0300

    mmc: sdhci: Fix regression setting power on Trats2 board
    
    commit 1dceb0415aa0c6bc11dacdab47c9ef83a3604166 upstream.
    
    Several commits relating to setting power have been introducing
    problems by putting driver-specific rules into generic SDHCI code.
    
    Krzysztof Kozlowski reported that after commit 918f4cbd4340 ("mmc:
    sdhci: restore behavior when setting VDD via external regulator")
    on Trats2 board there are warnings for invalid VDD  value (2.8V):
    
    [    3.119656] ------------[ cut here ]------------
    [    3.119666] WARNING: CPU: 3 PID: 90 at
    ../drivers/mmc/host/sdhci.c:1234 sdhci_do_set_ios+0x4cc/0x5e0
    [    3.119669] mmc0: Invalid vdd 0x10
    [    3.119673] Modules linked in:
    [    3.119679] CPU: 3 PID: 90 Comm: kworker/3:1 Tainted: G        W
       4.5.0-next-20160324 #23
    [    3.119681] Hardware name: SAMSUNG EXYNOS (Flattened Device Tree)
    [    3.119690] Workqueue: events_freezable mmc_rescan
    [    3.119708] [<c010e0ac>] (unwind_backtrace) from [<c010ae10>]
    (show_stack+0x10/0x14)
    [    3.119719] [<c010ae10>] (show_stack) from [<c0323260>]
    (dump_stack+0x88/0x9c)
    [    3.119728] [<c0323260>] (dump_stack) from [<c011b754>] (__warn+0xe8/0x100)
    [    3.119734] [<c011b754>] (__warn) from [<c011b7a4>]
    (warn_slowpath_fmt+0x38/0x48)
    [    3.119740] [<c011b7a4>] (warn_slowpath_fmt) from [<c0527d28>]
    (sdhci_do_set_ios+0x4cc/0x5e0)
    [    3.119748] [<c0527d28>] (sdhci_do_set_ios) from [<c0528018>]
    (sdhci_runtime_resume_host+0x60/0x114)
    [    3.119758] [<c0528018>] (sdhci_runtime_resume_host) from
    [<c0402570>] (__rpm_callback+0x2c/0x60)
    [    3.119767] [<c0402570>] (__rpm_callback) from [<c04025c4>]
    (rpm_callback+0x20/0x80)
    [    3.119773] [<c04025c4>] (rpm_callback) from [<c04034b8>]
    (rpm_resume+0x36c/0x558)
    [    3.119780] [<c04034b8>] (rpm_resume) from [<c04036f0>]
    (__pm_runtime_resume+0x4c/0x64)
    [    3.119788] [<c04036f0>] (__pm_runtime_resume) from [<c0512728>]
    (__mmc_claim_host+0x170/0x1b0)
    [    3.119795] [<c0512728>] (__mmc_claim_host) from [<c0514e2c>]
    (mmc_rescan+0x54/0x348)
    [    3.119807] [<c0514e2c>] (mmc_rescan) from [<c0130dac>]
    (process_one_work+0x120/0x3f4)
    [    3.119815] [<c0130dac>] (process_one_work) from [<c01310b8>]
    (worker_thread+0x38/0x554)
    [    3.119823] [<c01310b8>] (worker_thread) from [<c01365a4>]
    (kthread+0xdc/0xf4)
    [    3.119831] [<c01365a4>] (kthread) from [<c0107878>]
    (ret_from_fork+0x14/0x3c)
    [    3.119834] ---[ end trace a22d652aa3276886 ]---
    
    Fix by adding a 'set_power' callback and restoring the default
    behaviour prior to commit 918f4cbd4340 ("mmc: sdhci: restore
    behavior when setting VDD via external regulator").  The desired
    behaviour of that commit is gotten by having sdhci-pxav3 provide
    its own set_power callback.
    
    Reported-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Link: http://lkml.kernel.org/r/CAJKOXPcGDnPm-Ykh6wHqV1YxfTaov5E8iVqBoBn4OJc7BnhgEQ@mail.gmail.com
    Fixes: 918f4cbd4340 ("mmc: sdhci: restore behavior when setting VDD...)
    Tested-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Tested-by: Ludovic Desroches <ludovic.desroches@atmel.com>
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Cc: stable@vger.kernel.org # v4.5+
    Reviewed-by: Jisheng Zhang <jszhang@marvell.com>
    Tested-by: Jisheng Zhang <jszhang@marvell.com>
    Tested-by: Jaehoon Chung <jh80.chung@samsung.com>
    Tested-by: Anand Moon <linux.amoon@gmail.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 1a446873d7dd3a450f685928ce7f1907bde4583d
Author: Yong Zhi <yong.zhi@intel.com>
Date:   Fri May 1 18:44:21 2020 -0500

    ASoC: max98373: reorder max98373_reset() in resume
    
    During S3 test, the following error was observed:
    
    [ 726.174237] i2c_designware i2c_designware.0: platform_pm_resume+0x0/0x3d returned 0 after 0 usecs
    [ 726.184187] max98373 i2c-MX98373:00: calling max98373_resume+0x0/0x30 [snd_soc_max98373] @ 12698, parent: i2c-11
    [ 726.195589] max98373 i2c-MX98373:00: Reset command failed. (ret:-16)
    
    When calling regmap_update_bits(), since map->reg_update_bits is NULL,
    _regmap_read() is entered with the following logic:
    
            if (!map->cache_bypass) {
                    ret = regcache_read(map, reg, val);
                    if (ret == 0)
                            return 0;
            }
    
            if (map->cache_only)
                    return -EBUSY;
    
    regcache_read() hits -EINVAL because MAX98373_R2000_SW_RESET is volatile,
    as map->cache_only is set by codec suspend, thus -EBUSY is returned.
    Fix by moving max98373_reset() after cache_only set to false in max98373_resume().
    
    Signed-off-by: Yong Zhi <yong.zhi@intel.com>
    Link: https://lore.kernel.org/r/1588376661-29799-1-git-send-email-yong.zhi@intel.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

commit 7f06d3a6c49499e2eebd47fffd584bfce5b3a38b
Author: George Wilson <gcwilson@linux.ibm.com>
Date:   Thu Mar 19 23:27:58 2020 -0400

    tpm: ibmvtpm: retry on H_CLOSED in tpm_ibmvtpm_send()
    
    commit eba5cf3dcb844c82f54d4a857e124824e252206d upstream.
    
    tpm_ibmvtpm_send() can fail during PowerVM Live Partition Mobility resume
    with an H_CLOSED return from ibmvtpm_send_crq().  The PAPR says, 'The
    "partner partition suspended" transport event disables the associated CRQ
    such that any H_SEND_CRQ hcall() to the associated CRQ returns H_Closed
    until the CRQ has been explicitly enabled using the H_ENABLE_CRQ hcall.'
    This patch adds a check in tpm_ibmvtpm_send() for an H_CLOSED return from
    ibmvtpm_send_crq() and in that case calls tpm_ibmvtpm_resume() and
    retries the ibmvtpm_send_crq() once.
    
    Cc: stable@vger.kernel.org # 3.7.x
    Fixes: 132f76294744 ("drivers/char/tpm: Add new device driver to support IBM vTPM")
    Reported-by: Linh Pham <phaml@us.ibm.com>
    Reviewed-by: Stefan Berger <stefanb@linux.ibm.com>
    Signed-off-by: George Wilson <gcwilson@linux.ibm.com>
    Tested-by: Linh Pham <phaml@us.ibm.com>
    Reviewed-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
    Signed-off-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 456245a1b326912c37e61d0193464f53effce3ff
Author: George Wilson <gcwilson@linux.ibm.com>
Date:   Thu Mar 19 23:27:58 2020 -0400

    tpm: ibmvtpm: retry on H_CLOSED in tpm_ibmvtpm_send()
    
    commit eba5cf3dcb844c82f54d4a857e124824e252206d upstream.
    
    tpm_ibmvtpm_send() can fail during PowerVM Live Partition Mobility resume
    with an H_CLOSED return from ibmvtpm_send_crq().  The PAPR says, 'The
    "partner partition suspended" transport event disables the associated CRQ
    such that any H_SEND_CRQ hcall() to the associated CRQ returns H_Closed
    until the CRQ has been explicitly enabled using the H_ENABLE_CRQ hcall.'
    This patch adds a check in tpm_ibmvtpm_send() for an H_CLOSED return from
    ibmvtpm_send_crq() and in that case calls tpm_ibmvtpm_resume() and
    retries the ibmvtpm_send_crq() once.
    
    Cc: stable@vger.kernel.org # 3.7.x
    Fixes: 132f76294744 ("drivers/char/tpm: Add new device driver to support IBM vTPM")
    Reported-by: Linh Pham <phaml@us.ibm.com>
    Reviewed-by: Stefan Berger <stefanb@linux.ibm.com>
    Signed-off-by: George Wilson <gcwilson@linux.ibm.com>
    Tested-by: Linh Pham <phaml@us.ibm.com>
    Reviewed-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
    Signed-off-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 3fc644fd6100ad6afa1a1a0a17f2a7ebb3412148
Author: George Wilson <gcwilson@linux.ibm.com>
Date:   Thu Mar 19 23:27:58 2020 -0400

    tpm: ibmvtpm: retry on H_CLOSED in tpm_ibmvtpm_send()
    
    commit eba5cf3dcb844c82f54d4a857e124824e252206d upstream.
    
    tpm_ibmvtpm_send() can fail during PowerVM Live Partition Mobility resume
    with an H_CLOSED return from ibmvtpm_send_crq().  The PAPR says, 'The
    "partner partition suspended" transport event disables the associated CRQ
    such that any H_SEND_CRQ hcall() to the associated CRQ returns H_Closed
    until the CRQ has been explicitly enabled using the H_ENABLE_CRQ hcall.'
    This patch adds a check in tpm_ibmvtpm_send() for an H_CLOSED return from
    ibmvtpm_send_crq() and in that case calls tpm_ibmvtpm_resume() and
    retries the ibmvtpm_send_crq() once.
    
    Cc: stable@vger.kernel.org # 3.7.x
    Fixes: 132f76294744 ("drivers/char/tpm: Add new device driver to support IBM vTPM")
    Reported-by: Linh Pham <phaml@us.ibm.com>
    Reviewed-by: Stefan Berger <stefanb@linux.ibm.com>
    Signed-off-by: George Wilson <gcwilson@linux.ibm.com>
    Tested-by: Linh Pham <phaml@us.ibm.com>
    Reviewed-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
    Signed-off-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 9c4e0cab837e0b2a3748f376828db426019c6252
Author: George Wilson <gcwilson@linux.ibm.com>
Date:   Thu Mar 19 23:27:58 2020 -0400

    tpm: ibmvtpm: retry on H_CLOSED in tpm_ibmvtpm_send()
    
    commit eba5cf3dcb844c82f54d4a857e124824e252206d upstream.
    
    tpm_ibmvtpm_send() can fail during PowerVM Live Partition Mobility resume
    with an H_CLOSED return from ibmvtpm_send_crq().  The PAPR says, 'The
    "partner partition suspended" transport event disables the associated CRQ
    such that any H_SEND_CRQ hcall() to the associated CRQ returns H_Closed
    until the CRQ has been explicitly enabled using the H_ENABLE_CRQ hcall.'
    This patch adds a check in tpm_ibmvtpm_send() for an H_CLOSED return from
    ibmvtpm_send_crq() and in that case calls tpm_ibmvtpm_resume() and
    retries the ibmvtpm_send_crq() once.
    
    Cc: stable@vger.kernel.org # 3.7.x
    Fixes: 132f76294744 ("drivers/char/tpm: Add new device driver to support IBM vTPM")
    Reported-by: Linh Pham <phaml@us.ibm.com>
    Reviewed-by: Stefan Berger <stefanb@linux.ibm.com>
    Signed-off-by: George Wilson <gcwilson@linux.ibm.com>
    Tested-by: Linh Pham <phaml@us.ibm.com>
    Reviewed-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
    Signed-off-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit eba5cf3dcb844c82f54d4a857e124824e252206d
Author: George Wilson <gcwilson@linux.ibm.com>
Date:   Thu Mar 19 23:27:58 2020 -0400

    tpm: ibmvtpm: retry on H_CLOSED in tpm_ibmvtpm_send()
    
    tpm_ibmvtpm_send() can fail during PowerVM Live Partition Mobility resume
    with an H_CLOSED return from ibmvtpm_send_crq().  The PAPR says, 'The
    "partner partition suspended" transport event disables the associated CRQ
    such that any H_SEND_CRQ hcall() to the associated CRQ returns H_Closed
    until the CRQ has been explicitly enabled using the H_ENABLE_CRQ hcall.'
    This patch adds a check in tpm_ibmvtpm_send() for an H_CLOSED return from
    ibmvtpm_send_crq() and in that case calls tpm_ibmvtpm_resume() and
    retries the ibmvtpm_send_crq() once.
    
    Cc: stable@vger.kernel.org # 3.7.x
    Fixes: 132f76294744 ("drivers/char/tpm: Add new device driver to support IBM vTPM")
    Reported-by: Linh Pham <phaml@us.ibm.com>
    Reviewed-by: Stefan Berger <stefanb@linux.ibm.com>
    Signed-off-by: George Wilson <gcwilson@linux.ibm.com>
    Tested-by: Linh Pham <phaml@us.ibm.com>
    Reviewed-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
    Signed-off-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>

commit 6595cef7a7aefc3ad60eead38289ec1792d31027
Author: Yuji Sasaki <sasakiy@chromium.org>
Date:   Fri Feb 14 13:13:40 2020 +0530

    spi: qup: call spi_qup_pm_resume_runtime before suspending
    
    [ Upstream commit 136b5cd2e2f97581ae560cff0db2a3b5369112da ]
    
    spi_qup_suspend() will cause synchronous external abort when
    runtime suspend is enabled and applied, as it tries to
    access SPI controller register while clock is already disabled
    in spi_qup_pm_suspend_runtime().
    
    Signed-off-by: Yuji sasaki <sasakiy@chromium.org>
    Signed-off-by: Vinod Koul <vkoul@kernel.org>
    Link: https://lore.kernel.org/r/20200214074340.2286170-1-vkoul@kernel.org
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit e0f5fa76696a990695e110deee83aa3f3efa0ab3
Author: Yuji Sasaki <sasakiy@chromium.org>
Date:   Fri Feb 14 13:13:40 2020 +0530

    spi: qup: call spi_qup_pm_resume_runtime before suspending
    
    [ Upstream commit 136b5cd2e2f97581ae560cff0db2a3b5369112da ]
    
    spi_qup_suspend() will cause synchronous external abort when
    runtime suspend is enabled and applied, as it tries to
    access SPI controller register while clock is already disabled
    in spi_qup_pm_suspend_runtime().
    
    Signed-off-by: Yuji sasaki <sasakiy@chromium.org>
    Signed-off-by: Vinod Koul <vkoul@kernel.org>
    Link: https://lore.kernel.org/r/20200214074340.2286170-1-vkoul@kernel.org
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 227507aa68648f6926b57ac7338047665c5d4fc1
Author: Yuji Sasaki <sasakiy@chromium.org>
Date:   Fri Feb 14 13:13:40 2020 +0530

    spi: qup: call spi_qup_pm_resume_runtime before suspending
    
    [ Upstream commit 136b5cd2e2f97581ae560cff0db2a3b5369112da ]
    
    spi_qup_suspend() will cause synchronous external abort when
    runtime suspend is enabled and applied, as it tries to
    access SPI controller register while clock is already disabled
    in spi_qup_pm_suspend_runtime().
    
    Signed-off-by: Yuji sasaki <sasakiy@chromium.org>
    Signed-off-by: Vinod Koul <vkoul@kernel.org>
    Link: https://lore.kernel.org/r/20200214074340.2286170-1-vkoul@kernel.org
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 94b248d0407c103786631cb825c0234d275fb7ce
Author: Yuji Sasaki <sasakiy@chromium.org>
Date:   Fri Feb 14 13:13:40 2020 +0530

    spi: qup: call spi_qup_pm_resume_runtime before suspending
    
    [ Upstream commit 136b5cd2e2f97581ae560cff0db2a3b5369112da ]
    
    spi_qup_suspend() will cause synchronous external abort when
    runtime suspend is enabled and applied, as it tries to
    access SPI controller register while clock is already disabled
    in spi_qup_pm_suspend_runtime().
    
    Signed-off-by: Yuji sasaki <sasakiy@chromium.org>
    Signed-off-by: Vinod Koul <vkoul@kernel.org>
    Link: https://lore.kernel.org/r/20200214074340.2286170-1-vkoul@kernel.org
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 9eee3e21a59d1b5a661c51db1207b47a5176997a
Author: Yuji Sasaki <sasakiy@chromium.org>
Date:   Fri Feb 14 13:13:40 2020 +0530

    spi: qup: call spi_qup_pm_resume_runtime before suspending
    
    [ Upstream commit 136b5cd2e2f97581ae560cff0db2a3b5369112da ]
    
    spi_qup_suspend() will cause synchronous external abort when
    runtime suspend is enabled and applied, as it tries to
    access SPI controller register while clock is already disabled
    in spi_qup_pm_suspend_runtime().
    
    Signed-off-by: Yuji sasaki <sasakiy@chromium.org>
    Signed-off-by: Vinod Koul <vkoul@kernel.org>
    Link: https://lore.kernel.org/r/20200214074340.2286170-1-vkoul@kernel.org
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit b84530ba478f05aab785ce1341fc39eb45fcb32e
Author: Yuji Sasaki <sasakiy@chromium.org>
Date:   Fri Feb 14 13:13:40 2020 +0530

    spi: qup: call spi_qup_pm_resume_runtime before suspending
    
    [ Upstream commit 136b5cd2e2f97581ae560cff0db2a3b5369112da ]
    
    spi_qup_suspend() will cause synchronous external abort when
    runtime suspend is enabled and applied, as it tries to
    access SPI controller register while clock is already disabled
    in spi_qup_pm_suspend_runtime().
    
    Signed-off-by: Yuji sasaki <sasakiy@chromium.org>
    Signed-off-by: Vinod Koul <vkoul@kernel.org>
    Link: https://lore.kernel.org/r/20200214074340.2286170-1-vkoul@kernel.org
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 4ce35a3617c0ac758c61122b2218b6c8c9ac9398
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Fri Mar 20 14:52:00 2020 +0200

    serial: 8250_omap: Fix sleeping function called from invalid context during probe
    
    When booting j721e the following bug is printed:
    
    [    1.154821] BUG: sleeping function called from invalid context at kernel/sched/completion.c:99
    [    1.154827] in_atomic(): 0, irqs_disabled(): 128, non_block: 0, pid: 12, name: kworker/0:1
    [    1.154832] 3 locks held by kworker/0:1/12:
    [    1.154836]  #0: ffff000840030728 ((wq_completion)events){+.+.}, at: process_one_work+0x1d4/0x6e8
    [    1.154852]  #1: ffff80001214fdd8 (deferred_probe_work){+.+.}, at: process_one_work+0x1d4/0x6e8
    [    1.154860]  #2: ffff00084060b170 (&dev->mutex){....}, at: __device_attach+0x38/0x138
    [    1.154872] irq event stamp: 63096
    [    1.154881] hardirqs last  enabled at (63095): [<ffff800010b74318>] _raw_spin_unlock_irqrestore+0x70/0x78
    [    1.154887] hardirqs last disabled at (63096): [<ffff800010b740d8>] _raw_spin_lock_irqsave+0x28/0x80
    [    1.154893] softirqs last  enabled at (62254): [<ffff800010080c88>] _stext+0x488/0x564
    [    1.154899] softirqs last disabled at (62247): [<ffff8000100fdb3c>] irq_exit+0x114/0x140
    [    1.154906] CPU: 0 PID: 12 Comm: kworker/0:1 Not tainted 5.6.0-rc6-next-20200318-00094-g45e4089b0bd3 #221
    [    1.154911] Hardware name: Texas Instruments K3 J721E SoC (DT)
    [    1.154917] Workqueue: events deferred_probe_work_func
    [    1.154923] Call trace:
    [    1.154928]  dump_backtrace+0x0/0x190
    [    1.154933]  show_stack+0x14/0x20
    [    1.154940]  dump_stack+0xe0/0x148
    [    1.154946]  ___might_sleep+0x150/0x1f0
    [    1.154952]  __might_sleep+0x4c/0x80
    [    1.154957]  wait_for_completion_timeout+0x40/0x140
    [    1.154964]  ti_sci_set_device_state+0xa0/0x158
    [    1.154969]  ti_sci_cmd_get_device_exclusive+0x14/0x20
    [    1.154977]  ti_sci_dev_start+0x34/0x50
    [    1.154984]  genpd_runtime_resume+0x78/0x1f8
    [    1.154991]  __rpm_callback+0x3c/0x140
    [    1.154996]  rpm_callback+0x20/0x80
    [    1.155001]  rpm_resume+0x568/0x758
    [    1.155007]  __pm_runtime_resume+0x44/0xb0
    [    1.155013]  omap8250_probe+0x2b4/0x508
    [    1.155019]  platform_drv_probe+0x50/0xa0
    [    1.155023]  really_probe+0xd4/0x318
    [    1.155028]  driver_probe_device+0x54/0xe8
    [    1.155033]  __device_attach_driver+0x80/0xb8
    [    1.155039]  bus_for_each_drv+0x74/0xc0
    [    1.155044]  __device_attach+0xdc/0x138
    [    1.155049]  device_initial_probe+0x10/0x18
    [    1.155053]  bus_probe_device+0x98/0xa0
    [    1.155058]  deferred_probe_work_func+0x74/0xb0
    [    1.155063]  process_one_work+0x280/0x6e8
    [    1.155068]  worker_thread+0x48/0x430
    [    1.155073]  kthread+0x108/0x138
    [    1.155079]  ret_from_fork+0x10/0x18
    
    To fix the bug we need to first call pm_runtime_enable() prior to any
    pm_runtime calls.
    
    Reported-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Link: https://lore.kernel.org/r/20200320125200.6772-1-peter.ujfalusi@ti.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit ae24a21bbd96a7a4a3e82890285255d7e86540f0
Merge: 43c63729c96f f9981d4f50b4
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Mar 6 14:50:16 2020 -0600

    Merge tag 'spi-fix-v5.6-rc4' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/spi
    
    Pull spi fixes from Mark Brown:
     "A selection of small fixes, mostly for drivers, that have arrived
      since the merge window. None of them are earth shattering in
      themselves but all useful for affected systems"
    
    * tag 'spi-fix-v5.6-rc4' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/spi:
      spi: spi_register_controller(): free bus id on error paths
      spi: bcm63xx-hsspi: Really keep pll clk enabled
      spi: atmel-quadspi: fix possible MMIO window size overrun
      spi/zynqmp: remove entry that causes a cs glitch
      spi: pxa2xx: Add CS control clock quirk
      spi: spidev: Fix CS polarity if GPIO descriptors are used
      spi: qup: call spi_qup_pm_resume_runtime before suspending
      spi: spi-omap2-mcspi: Support probe deferral for DMA channels
      spi: spi-omap2-mcspi: Handle DMA size restriction on AM65x

commit 9803aac7b5508718989e4cde11b854fc01037b01
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Jan 7 22:53:19 2020 +0100

    drm/komeda: mark PM functions as __maybe_unused
    
    Without this, we get a couple of warnings when CONFIG_PM
    is disabled:
    
    drivers/gpu/drm/arm/display/komeda/komeda_drv.c:156:12: error: 'komeda_rt_pm_resume' defined but not used [-Werror=unused-function]
     static int komeda_rt_pm_resume(struct device *dev)
                ^~~~~~~~~~~~~~~~~~~
    drivers/gpu/drm/arm/display/komeda/komeda_drv.c:149:12: error: 'komeda_rt_pm_suspend' defined but not used [-Werror=unused-function]
     static int komeda_rt_pm_suspend(struct device *dev)
                ^~~~~~~~~~~~~~~~~~~~
    
    Fixes: efb465088518 ("drm/komeda: Add runtime_pm support")
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Reviewed-by: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Signed-off-by: james qian wang (Arm Technology China) <james.qian.wang@arm.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200107215327.1579195-1-arnd@arndb.de

commit 66e4f4a9cc389b277e187c115a285fad2cba5485
Author: Ville Syrjl <ville.syrjala@linux.intel.com>
Date:   Fri Feb 21 16:47:39 2020 +0200

    rtc: cmos: Use spin_lock_irqsave() in cmos_interrupt()
    
    cmos_interrupt() isn't always called from hardirq context, so
    we must use spin_lock_irqsave() & co.
    
    ================================
    WARNING: inconsistent lock state
    5.6.0-rc2-CI-CI_DRM_7981+ #1 Tainted: G     U
    --------------------------------
    inconsistent {IN-HARDIRQ-W} -> {HARDIRQ-ON-W} usage.
    rtcwake/4315 [HC0[0]:SC0[0]:HE1:SE1] takes:
    ffffffff82635198 (rtc_lock){?...}, at: cmos_interrupt+0x18/0x100
    {IN-HARDIRQ-W} state was registered at:
      lock_acquire+0xa7/0x1c0
      _raw_spin_lock+0x2a/0x40
      cmos_interrupt+0x18/0x100
      rtc_handler+0x75/0xc0
      acpi_ev_fixed_event_detect+0xf9/0x132
      acpi_ev_sci_xrupt_handler+0xb/0x28
      acpi_irq+0x13/0x30
      __handle_irq_event_percpu+0x41/0x2c0
      handle_irq_event_percpu+0x2b/0x70
      handle_irq_event+0x2f/0x50
      handle_fasteoi_irq+0x8e/0x150
      do_IRQ+0x7e/0x160
      ret_from_intr+0x0/0x35
      mwait_idle+0x7e/0x200
      do_idle+0x1bb/0x260
      cpu_startup_entry+0x14/0x20
      start_secondary+0x15f/0x1b0
      secondary_startup_64+0xa4/0xb0
    irq event stamp: 42003
    hardirqs last  enabled at (42003): [<ffffffff81a36567>] _raw_spin_unlock_irqrestore+0x47/0x60
    hardirqs last disabled at (42002): [<ffffffff81a362ed>] _raw_spin_lock_irqsave+0xd/0x50
    softirqs last  enabled at (41848): [<ffffffff81e00385>] __do_softirq+0x385/0x47f
    softirqs last disabled at (41841): [<ffffffff810bab3a>] irq_exit+0xba/0xc0
    
    other info that might help us debug this:
     Possible unsafe locking scenario:
    
           CPU0
           ----
      lock(rtc_lock);
      <Interrupt>
        lock(rtc_lock);
    
     *** DEADLOCK ***
    
    6 locks held by rtcwake/4315:
     #0: ffff888175dc9408 (sb_writers#5){.+.+}, at: vfs_write+0x1a4/0x1d0
     #1: ffff88817406ca80 (&of->mutex){+.+.}, at: kernfs_fop_write+0xdd/0x1b0
     #2: ffff888179be85e0 (kn->count#236){.+.+}, at: kernfs_fop_write+0xe6/0x1b0
     #3: ffffffff82641e00 (system_transition_mutex){+.+.}, at: pm_suspend+0xb3/0x3b0
     #4: ffffffff826b3ee0 (acpi_scan_lock){+.+.}, at: acpi_suspend_begin+0x47/0x80
     #5: ffff888178fc3960 (&dev->mutex){....}, at: device_resume+0x92/0x1c0
    
    stack backtrace:
    CPU: 3 PID: 4315 Comm: rtcwake Tainted: G     U            5.6.0-rc2-CI-CI_DRM_7981+ #1
    Hardware name: Google Soraka/Soraka, BIOS MrChromebox-4.10 08/25/2019
    Call Trace:
     dump_stack+0x71/0x9b
     mark_lock+0x49a/0x500
     ? print_shortest_lock_dependencies+0x200/0x200
     __lock_acquire+0x6d4/0x15d0
     ? __lock_acquire+0x460/0x15d0
     lock_acquire+0xa7/0x1c0
     ? cmos_interrupt+0x18/0x100
     _raw_spin_lock+0x2a/0x40
     ? cmos_interrupt+0x18/0x100
     cmos_interrupt+0x18/0x100
     cmos_resume+0x1fd/0x290
     ? __acpi_pm_set_device_wakeup+0x24/0x100
     pnp_bus_resume+0x5e/0x90
     ? pnp_bus_suspend+0x10/0x10
     dpm_run_callback+0x64/0x280
     device_resume+0xd4/0x1c0
     ? dpm_watchdog_set+0x60/0x60
     dpm_resume+0x106/0x410
     ? dpm_resume_early+0x38c/0x3e0
     dpm_resume_end+0x8/0x10
     suspend_devices_and_enter+0x16f/0xbe0
     ? rcu_read_lock_sched_held+0x4d/0x80
     pm_suspend+0x344/0x3b0
     state_store+0x78/0xe0
     kernfs_fop_write+0x112/0x1b0
     vfs_write+0xb9/0x1d0
     ksys_write+0x9f/0xe0
     do_syscall_64+0x4f/0x220
     entry_SYSCALL_64_after_hwframe+0x49/0xbe
    RIP: 0033:0x7ff934307154
    Code: 89 02 48 c7 c0 ff ff ff ff c3 66 2e 0f 1f 84 00 00 00 00 00 66 90 48 8d 05 b1 07 2e 00 8b 00 85 c0 75 13 b8 01 00 00 00 0f 05 <48> 3d 00 f0 ff ff 77 54 f3 c3 66 90 41 54 55 49 89 d4 53 48 89 f5
    RSP: 002b:00007ffe2647c168 EFLAGS: 00000246 ORIG_RAX: 0000000000000001
    RAX: ffffffffffffffda RBX: 0000000000000004 RCX: 00007ff934307154
    RDX: 0000000000000004 RSI: 000055de3ec4e5a0 RDI: 000000000000000a
    RBP: 000055de3ec4e5a0 R08: 000055de3ec4c5e0 R09: 00007ff9349f3740
    R10: 000055de3ec4a010 R11: 0000000000000246 R12: 000055de3ec4c500
    R13: 0000000000000004 R14: 00007ff9345df2a0 R15: 00007ff9345de760
    
    Fixes: c6d3a278cc12 ("rtc: cmos: acknowledge ACPI driven wake alarms upon resume")
    Fixes: 311ee9c151ad ("rtc: cmos: allow using ACPI for RTC alarm instead of HPET")
    Signed-off-by: Ville Syrjl <ville.syrjala@linux.intel.com>
    Link: https://lore.kernel.org/r/20200221144739.11746-1-ville.syrjala@linux.intel.com
    Signed-off-by: Alexandre Belloni <alexandre.belloni@bootlin.com>

commit f33d807c9d8847c634ddcb033178f93347428e7b
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Tue Feb 11 19:19:11 2020 +0100

    crypto: ccree - make cc_pm_{suspend,resume}() static
    
    cc_pm_suspend() and cc_pm_resume() are not used outside
    drivers/crypto/ccree/cc_pm.c.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

commit 136b5cd2e2f97581ae560cff0db2a3b5369112da
Author: Yuji Sasaki <sasakiy@chromium.org>
Date:   Fri Feb 14 13:13:40 2020 +0530

    spi: qup: call spi_qup_pm_resume_runtime before suspending
    
    spi_qup_suspend() will cause synchronous external abort when
    runtime suspend is enabled and applied, as it tries to
    access SPI controller register while clock is already disabled
    in spi_qup_pm_suspend_runtime().
    
    Signed-off-by: Yuji sasaki <sasakiy@chromium.org>
    Signed-off-by: Vinod Koul <vkoul@kernel.org>
    Link: https://lore.kernel.org/r/20200214074340.2286170-1-vkoul@kernel.org
    Signed-off-by: Mark Brown <broonie@kernel.org>

commit 2cabe0d4cd88f7386e9c5a82236ceda46080a80b
Author: Guchun Chen <guchun.chen@amd.com>
Date:   Sun Feb 9 16:21:09 2020 +0800

    drm/amdgpu: limit GDS clearing workaround in cold boot sequence
    
    GDS clear workaround will cause gfx failure in suspend/resume case.
    
    [   98.679559] [drm:amdgpu_device_ip_late_init [amdgpu]] *ERROR* late_init of IP block <gfx_v9_0> failed -110
    [   98.679561] PM: dpm_run_callback(): pci_pm_resume+0x0/0xa0 returns -110
    [   98.679562] PM: Device 0000:03:00.0 failed to resume async: error -110
    
    As this workaround is specific to the HW bug of GDS's ECC error
    existing in cold boot up, so bypass this workaround in suspend/
    resume case after booting up.
    
    Signed-off-by: Guchun Chen <guchun.chen@amd.com>
    Reviewed-by: Hawking Zhang <Hawking.Zhang@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

commit ea6f0931c1e7a956792c34f5ec80b71746864d7d
Author: Guchun Chen <guchun.chen@amd.com>
Date:   Sun Feb 9 16:21:09 2020 +0800

    drm/amdgpu: limit GDS clearing workaround in cold boot sequence
    
    GDS clear workaround will cause gfx failure in suspend/resume case.
    
    [   98.679559] [drm:amdgpu_device_ip_late_init [amdgpu]] *ERROR* late_init of IP block <gfx_v9_0> failed -110
    [   98.679561] PM: dpm_run_callback(): pci_pm_resume+0x0/0xa0 returns -110
    [   98.679562] PM: Device 0000:03:00.0 failed to resume async: error -110
    
    As this workaround is specific to the HW bug of GDS's ECC error
    existing in cold boot up, so bypass this workaround in suspend/
    resume case after booting up.
    
    Signed-off-by: Guchun Chen <guchun.chen@amd.com>
    Reviewed-by: Hawking Zhang <Hawking.Zhang@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

commit d6a91833c6ed8a95ad1b4a5e2364bb6d4a039f25
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Feb 1 01:49:14 2019 +0100

    driver core: Fix handling of runtime PM flags in device_link_add()
    
    [ Upstream commit e2f3cd831a280fc226118d9369bf3f77aab58c56 ]
    
    After commit ead18c23c263 ("driver core: Introduce device links
    reference counting"), if there is a link between the given supplier
    and the given consumer already, device_link_add() will refcount it
    and return it unconditionally without updating its flags.  It is
    possible, however, that the second (or any subsequent) caller of
    device_link_add() for the same consumer-supplier pair will pass
    DL_FLAG_PM_RUNTIME, possibly along with DL_FLAG_RPM_ACTIVE, in flags
    to it and the existing link may not behave as expected then.
    
    First, if DL_FLAG_PM_RUNTIME is not set in the existing link's flags
    at all, it needs to be set like during the original initialization of
    the link.
    
    Second, if DL_FLAG_RPM_ACTIVE is passed to device_link_add() in flags
    (in addition to DL_FLAG_PM_RUNTIME), the existing link should to be
    updated to reflect the "active" runtime PM configuration of the
    consumer-supplier pair and extra care must be taken here to avoid
    possible destructive races with runtime PM of the consumer.
    
    To that end, redefine the rpm_active field in struct device_link
    as a refcount, initialize it to 1 and make rpm_resume() (for the
    consumer) and device_link_add() increment it whenever they acquire
    a runtime PM reference on the supplier device.  Accordingly, make
    rpm_suspend() (for the consumer) and pm_runtime_clean_up_links()
    decrement it and drop runtime PM references to the supplier
    device in a loop until rpm_active becones 1 again.
    
    Fixes: ead18c23c263 ("driver core: Introduce device links reference counting")
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit e7dd16f419c9bb9c6d4bdeeddb8465fe24e8c24d
Author: Esben Haabendal <esben@geanix.com>
Date:   Fri Jan 17 21:05:36 2020 +0100

    mtd: rawnand: gpmi: Fix suspend/resume problem
    
    commit 5bc6bb603b4d0c8802af75e4932232683ab2d761 upstream.
    
    On system resume, the gpmi clock must be enabled before accessing gpmi
    block.  Without this, resume causes something like
    
    [  661.348790] gpmi_reset_block(5cbb0f7e): module reset timeout
    [  661.348889] gpmi-nand 1806000.gpmi-nand: Error setting GPMI : -110
    [  661.348928] PM: dpm_run_callback(): platform_pm_resume+0x0/0x44 returns -110
    [  661.348961] PM: Device 1806000.gpmi-nand failed to resume: error -110
    
    Fixes: ef347c0cfd61 ("mtd: rawnand: gpmi: Implement exec_op")
    Cc: stable@vger.kernel.org
    Signed-off-by: Esben Haabendal <esben@geanix.com>
    Acked-by: Han Xu <han.xu@nxp.com>
    Signed-off-by: Miquel Raynal <miquel.raynal@bootlin.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 5bc6bb603b4d0c8802af75e4932232683ab2d761
Author: Esben Haabendal <esben@geanix.com>
Date:   Fri Jan 17 21:05:36 2020 +0100

    mtd: rawnand: gpmi: Fix suspend/resume problem
    
    On system resume, the gpmi clock must be enabled before accessing gpmi
    block.  Without this, resume causes something like
    
    [  661.348790] gpmi_reset_block(5cbb0f7e): module reset timeout
    [  661.348889] gpmi-nand 1806000.gpmi-nand: Error setting GPMI : -110
    [  661.348928] PM: dpm_run_callback(): platform_pm_resume+0x0/0x44 returns -110
    [  661.348961] PM: Device 1806000.gpmi-nand failed to resume: error -110
    
    Fixes: ef347c0cfd61 ("mtd: rawnand: gpmi: Implement exec_op")
    Cc: stable@vger.kernel.org
    Signed-off-by: Esben Haabendal <esben@geanix.com>
    Acked-by: Han Xu <han.xu@nxp.com>
    Signed-off-by: Miquel Raynal <miquel.raynal@bootlin.com>

commit 5611345ef38fb69a7eaeb1d1699799a6251cb374
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Oct 10 16:54:36 2019 -0500

    PCI/PM: Clear PCIe PME Status even for legacy power management
    
    commit ec6a75ef8e33fe33f963b916fd902c52a0be33ff upstream.
    
    Previously, pci_pm_resume_noirq() cleared the PME Status bit in the Root
    Status register only if the device had no driver or the driver did not
    implement legacy power management.  It should clear PME Status regardless
    of what sort of power management the driver supports, so do this before
    checking for legacy power management.
    
    This affects Root Ports and Root Complex Event Collectors, for which the
    usual driver is the PCIe portdrv, which implements new power management, so
    this change is just on principle, not to fix any actual defects.
    
    Fixes: a39bd851dccf ("PCI/PM: Clear PCIe PME Status bit in core, not PCIe port driver")
    Link: https://lore.kernel.org/r/20191014230016.240912-4-helgaas@kernel.org
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 3e817471a34cf94ca6edbb2e0b1076e6209153e2
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Tue Dec 3 10:13:46 2019 +0000

    drm/i915/gem: Take runtime-pm wakeref prior to unbinding
    
    Some machines require ACPI for runtime resume, and ACPI is quite kmalloc
    happy. We cannot handle kmalloc from inside the vm->mutex, as they are
    used by the shrinker, and so we must ensure the global runtime-pm is
    awake prior to unbinding to avoid the potential inversion.
    
    <4> [57.121748] ======================================================
    <4> [57.121750] WARNING: possible circular locking dependency detected
    <4> [57.121753] 5.4.0-rc8-CI-CI_DRM_7466+ #1 Tainted: G     U
    <4> [57.121754] ------------------------------------------------------
    <4> [57.121756] i915_pm_rpm/1105 is trying to acquire lock:
    <4> [57.121758] ffffffff82263a40 (fs_reclaim){+.+.}, at: fs_reclaim_acquire.part.117+0x0/0x30
    <4> [57.121766]
    but task is already holding lock:
    <4> [57.121768] ffff888475a593c0 (&vm->mutex){+.+.}, at: i915_vma_unbind+0x21/0x50 [i915]
    <4> [57.121868]
    which lock already depends on the new lock.
    
    <4> [57.121869]
    the existing dependency chain (in reverse order) is:
    <4> [57.121871]
    -> #1 (&vm->mutex){+.+.}:
    <4> [57.121951]        i915_gem_shrinker_taints_mutex+0xa2/0xd0 [i915]
    <4> [57.122028]        i915_address_space_init+0xa9/0x170 [i915]
    <4> [57.122104]        i915_ggtt_init_hw+0x47/0x130 [i915]
    <4> [57.122150]        i915_driver_probe+0xbb4/0x15f0 [i915]
    <4> [57.122197]        i915_pci_probe+0x43/0x1c0 [i915]
    <4> [57.122202]        pci_device_probe+0x9e/0x120
    <4> [57.122206]        really_probe+0xea/0x420
    <4> [57.122209]        driver_probe_device+0x10b/0x120
    <4> [57.122212]        device_driver_attach+0x4a/0x50
    <4> [57.122214]        __driver_attach+0x97/0x130
    <4> [57.122217]        bus_for_each_dev+0x74/0xc0
    <4> [57.122220]        bus_add_driver+0x142/0x220
    <4> [57.122222]        driver_register+0x56/0xf0
    <4> [57.122226]        do_one_initcall+0x58/0x2ff
    <4> [57.122230]        do_init_module+0x56/0x1f8
    <4> [57.122233]        load_module+0x243e/0x29f0
    <4> [57.122236]        __do_sys_finit_module+0xe9/0x110
    <4> [57.122239]        do_syscall_64+0x4f/0x210
    <4> [57.122242]        entry_SYSCALL_64_after_hwframe+0x49/0xbe
    <4> [57.122244]
    -> #0 (fs_reclaim){+.+.}:
    <4> [57.122249]        __lock_acquire+0x1328/0x15d0
    <4> [57.122251]        lock_acquire+0xa7/0x1c0
    <4> [57.122254]        fs_reclaim_acquire.part.117+0x24/0x30
    <4> [57.122257]        __kmalloc+0x48/0x320
    <4> [57.122261]        acpi_ns_internalize_name+0x44/0x9b
    <4> [57.122264]        acpi_ns_get_node_unlocked+0x6b/0xd3
    <4> [57.122267]        acpi_ns_get_node+0x3b/0x50
    <4> [57.122271]        acpi_get_handle+0x8a/0xb4
    <4> [57.122274]        acpi_has_method+0x1c/0x40
    <4> [57.122278]        acpi_pci_set_power_state+0x40/0xe0
    <4> [57.122281]        pci_platform_power_transition+0x3e/0x90
    <4> [57.122284]        pci_set_power_state+0x83/0xf0
    <4> [57.122287]        pci_restore_standard_config+0x22/0x40
    <4> [57.122289]        pci_pm_runtime_resume+0x23/0xc0
    <4> [57.122293]        __rpm_callback+0xb1/0x110
    <4> [57.122296]        rpm_callback+0x1a/0x70
    <4> [57.122299]        rpm_resume+0x50e/0x790
    <4> [57.122302]        __pm_runtime_resume+0x42/0x80
    <4> [57.122357]        __intel_runtime_pm_get+0x15/0x60 [i915]
    <4> [57.122435]        ggtt_unbind_vma+0x24/0x60 [i915]
    <4> [57.122514]        __i915_vma_unbind.part.39+0xb5/0x500 [i915]
    <4> [57.122593]        i915_vma_unbind+0x2d/0x50 [i915]
    <4> [57.122668]        i915_gem_object_unbind+0x11c/0x260 [i915]
    <4> [57.122740]        i915_gem_object_set_cache_level+0x32/0x90 [i915]
    <4> [57.122810]        i915_gem_set_caching_ioctl+0x1f7/0x2f0 [i915]
    <4> [57.122815]        drm_ioctl_kernel+0xa7/0xf0
    <4> [57.122818]        drm_ioctl+0x2e1/0x390
    <4> [57.122822]        do_vfs_ioctl+0xa0/0x6f0
    <4> [57.122825]        ksys_ioctl+0x35/0x60
    <4> [57.122828]        __x64_sys_ioctl+0x11/0x20
    <4> [57.122830]        do_syscall_64+0x4f/0x210
    <4> [57.122833]        entry_SYSCALL_64_after_hwframe+0x49/0xbe
    
    Closes: https://gitlab.freedesktop.org/drm/intel/issues/711
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Matthew Auld <matthew.auld@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191203101347.2836057-1-chris@chris-wilson.co.uk

commit 5b07222df0e9c2ecee316bcec2f9b3c2ecb937dd
Author: Bo Yan <byan@nvidia.com>
Date:   Tue Jan 23 13:57:55 2018 -0800

    cpufreq: Skip cpufreq resume if it's not suspended
    
    commit 703cbaa601ff3fb554d1246c336ba727cc083ea0 upstream.
    
    cpufreq_resume can be called even without preceding cpufreq_suspend.
    This can happen in following scenario:
    
        suspend_devices_and_enter
           --> dpm_suspend_start
              --> dpm_prepare
                  --> device_prepare : this function errors out
              --> dpm_suspend: this is skipped due to dpm_prepare failure
                               this means cpufreq_suspend is skipped over
           --> goto Recover_platform, due to previous error
           --> goto Resume_devices
           --> dpm_resume_end
               --> dpm_resume
                   --> cpufreq_resume
    
    In case schedutil is used as frequency governor, cpufreq_resume will
    eventually call sugov_start, which does following:
    
        memset(sg_cpu, 0, sizeof(*sg_cpu));
        ....
    
    This effectively erases function pointer for frequency update, causing
    crash later on. The function pointer would have been set correctly if
    subsequent cpufreq_add_update_util_hook runs successfully, but that
    function returns earlier because cpufreq_suspend was not called:
    
        if (WARN_ON(per_cpu(cpufreq_update_util_data, cpu)))
                    return;
    
    The fix is to check cpufreq_suspended first, if it's false, that means
    cpufreq_suspend was not called in the first place, so do not resume
    cpufreq.
    
    Signed-off-by: Bo Yan <byan@nvidia.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    [ rjw: Dropped printing a message ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 7ca04acf4f6ce4036b3eec029dd6a1888ab78216
Author: Bo Yan <byan@nvidia.com>
Date:   Tue Jan 23 13:57:55 2018 -0800

    cpufreq: Skip cpufreq resume if it's not suspended
    
    commit 703cbaa601ff3fb554d1246c336ba727cc083ea0 upstream.
    
    cpufreq_resume can be called even without preceding cpufreq_suspend.
    This can happen in following scenario:
    
        suspend_devices_and_enter
           --> dpm_suspend_start
              --> dpm_prepare
                  --> device_prepare : this function errors out
              --> dpm_suspend: this is skipped due to dpm_prepare failure
                               this means cpufreq_suspend is skipped over
           --> goto Recover_platform, due to previous error
           --> goto Resume_devices
           --> dpm_resume_end
               --> dpm_resume
                   --> cpufreq_resume
    
    In case schedutil is used as frequency governor, cpufreq_resume will
    eventually call sugov_start, which does following:
    
        memset(sg_cpu, 0, sizeof(*sg_cpu));
        ....
    
    This effectively erases function pointer for frequency update, causing
    crash later on. The function pointer would have been set correctly if
    subsequent cpufreq_add_update_util_hook runs successfully, but that
    function returns earlier because cpufreq_suspend was not called:
    
        if (WARN_ON(per_cpu(cpufreq_update_util_data, cpu)))
                    return;
    
    The fix is to check cpufreq_suspended first, if it's false, that means
    cpufreq_suspend was not called in the first place, so do not resume
    cpufreq.
    
    Signed-off-by: Bo Yan <byan@nvidia.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    [ rjw: Dropped printing a message ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 7181d93b44cb9286fc76af6be82cecb4653532e4
Author: Bo Yan <byan@nvidia.com>
Date:   Tue Jan 23 13:57:55 2018 -0800

    cpufreq: Skip cpufreq resume if it's not suspended
    
    commit 703cbaa601ff3fb554d1246c336ba727cc083ea0 upstream.
    
    cpufreq_resume can be called even without preceding cpufreq_suspend.
    This can happen in following scenario:
    
        suspend_devices_and_enter
           --> dpm_suspend_start
              --> dpm_prepare
                  --> device_prepare : this function errors out
              --> dpm_suspend: this is skipped due to dpm_prepare failure
                               this means cpufreq_suspend is skipped over
           --> goto Recover_platform, due to previous error
           --> goto Resume_devices
           --> dpm_resume_end
               --> dpm_resume
                   --> cpufreq_resume
    
    In case schedutil is used as frequency governor, cpufreq_resume will
    eventually call sugov_start, which does following:
    
        memset(sg_cpu, 0, sizeof(*sg_cpu));
        ....
    
    This effectively erases function pointer for frequency update, causing
    crash later on. The function pointer would have been set correctly if
    subsequent cpufreq_add_update_util_hook runs successfully, but that
    function returns earlier because cpufreq_suspend was not called:
    
        if (WARN_ON(per_cpu(cpufreq_update_util_data, cpu)))
                    return;
    
    The fix is to check cpufreq_suspended first, if it's false, that means
    cpufreq_suspend was not called in the first place, so do not resume
    cpufreq.
    
    Signed-off-by: Bo Yan <byan@nvidia.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    [ rjw: Dropped printing a message ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 2ea872490e18cb0d6558de518d8fc35f5671567d
Author: Pankaj Sharma <pankj.sharma@samsung.com>
Date:   Tue Nov 19 15:50:37 2019 +0530

    can: m_can_platform: set net_device structure as driver data
    
    The current code is failing during clock prepare enable because of not
    getting proper clock from platform device.
    
    [    0.852089] Call trace:
    [    0.854516]  0xffff0000fa22a668
    [    0.857638]  clk_prepare+0x20/0x34
    [    0.861019]  m_can_runtime_resume+0x2c/0xe4
    [    0.865180]  pm_generic_runtime_resume+0x28/0x38
    [    0.869770]  __rpm_callback+0x16c/0x1bc
    [    0.873583]  rpm_callback+0x24/0x78
    [    0.877050]  rpm_resume+0x428/0x560
    [    0.880517]  __pm_runtime_resume+0x7c/0xa8
    [    0.884593]  m_can_clk_start.isra.9.part.10+0x1c/0xa8
    [    0.889618]  m_can_class_register+0x138/0x370
    [    0.893950]  m_can_plat_probe+0x120/0x170
    [    0.897939]  platform_drv_probe+0x4c/0xa0
    [    0.901924]  really_probe+0xd8/0x31c
    [    0.905477]  driver_probe_device+0x58/0xe8
    [    0.909551]  device_driver_attach+0x68/0x70
    [    0.913711]  __driver_attach+0x9c/0xf8
    [    0.917437]  bus_for_each_dev+0x50/0xa0
    [    0.921251]  driver_attach+0x20/0x28
    [    0.924804]  bus_add_driver+0x148/0x1fc
    [    0.928617]  driver_register+0x6c/0x124
    [    0.932431]  __platform_driver_register+0x48/0x50
    [    0.937113]  m_can_plat_driver_init+0x18/0x20
    [    0.941446]  do_one_initcall+0x4c/0x19c
    [    0.945259]  kernel_init_freeable+0x1d0/0x280
    [    0.949591]  kernel_init+0x10/0x100
    [    0.953057]  ret_from_fork+0x10/0x18
    [    0.956614] Code: 00000000 00000000 00000000 00000000 (fa22a668)
    [    0.962681] ---[ end trace 881f71bd609de763 ]---
    [    0.967301] Kernel panic - not syncing: Attempted to kill init!
    
    A device driver for CAN controller hardware registers itself with the
    Linux network layer as a network device. So, the driver data for m_can
    should ideally be of type net_device.
    
    Fixes: f524f829b75a ("can: m_can: Create a m_can platform framework")
    Signed-off-by: Pankaj Sharma <pankj.sharma@samsung.com>
    Signed-off-by: Sriram Dash <sriram.dash@samsung.com>
    Acked-by: Dan Murphy <dmurphy@ti.com>
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>

commit 77b84bb306fd0d5d1d3a4bf1f2acf73dc971e372
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Nov 1 08:20:40 2019 -0500

    xen-platform: Convert to generic power management
    
    Convert xen-platform from the legacy PCI power management callbacks to the
    generic operations.  This is one step towards removing support for the
    legacy PCI callbacks.
    
    The generic .resume_noirq() operation is called by pci_pm_resume_noirq() at
    the same point the legacy PCI .resume_early() callback was, so this patch
    should not change the xen-platform behavior.
    
    Link: https://lore.kernel.org/r/20191101204558.210235-5-helgaas@kernel.org
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: Stefano Stabellini <sstabellini@kernel.org>
    Cc: KarimAllah Ahmed <karahmed@amazon.de>

commit f7b32a86e455b035dd45a334c203abf6fe118cf3
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Sat Oct 12 17:15:57 2019 -0500

    PCI/PM: Run resume fixups before disabling wakeup events
    
    pci_pm_resume() and pci_pm_restore() call pci_pm_default_resume(), which
    runs resume fixups before disabling wakeup events:
    
      static void pci_pm_default_resume(struct pci_dev *pci_dev)
      {
        pci_fixup_device(pci_fixup_resume, pci_dev);
        pci_enable_wake(pci_dev, PCI_D0, false);
      }
    
    pci_pm_runtime_resume() does both of these, but in the opposite order:
    
      pci_enable_wake(pci_dev, PCI_D0, false);
      pci_fixup_device(pci_fixup_resume, pci_dev);
    
    We should always use the same ordering unless there's a reason to do
    otherwise.  Change pci_pm_runtime_resume() to call pci_pm_default_resume()
    instead of open-coding this, so the fixups are always done before disabling
    wakeup events.
    
    pci_pm_default_resume() is called from pci_pm_runtime_resume(), which is
    under #ifdef CONFIG_PM.  If SUSPEND and HIBERNATION are disabled, PM_SLEEP
    is disabled also, so move pci_pm_default_resume() from #ifdef
    CONFIG_PM_SLEEP to #ifdef CONFIG_PM.
    
    Link: https://lore.kernel.org/r/20191014230016.240912-5-helgaas@kernel.org
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit ec6a75ef8e33fe33f963b916fd902c52a0be33ff
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Oct 10 16:54:36 2019 -0500

    PCI/PM: Clear PCIe PME Status even for legacy power management
    
    Previously, pci_pm_resume_noirq() cleared the PME Status bit in the Root
    Status register only if the device had no driver or the driver did not
    implement legacy power management.  It should clear PME Status regardless
    of what sort of power management the driver supports, so do this before
    checking for legacy power management.
    
    This affects Root Ports and Root Complex Event Collectors, for which the
    usual driver is the PCIe portdrv, which implements new power management, so
    this change is just on principle, not to fix any actual defects.
    
    Fixes: a39bd851dccf ("PCI/PM: Clear PCIe PME Status bit in core, not PCIe port driver")
    Link: https://lore.kernel.org/r/20191014230016.240912-4-helgaas@kernel.org
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 724f88e5ed64608d71d378688ce5dc4b4bfb9281
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Mon Jun 10 15:54:37 2019 -0700

    dma-remap: Avoid de-referencing NULL atomic_pool
    
    [ Upstream commit 4b4b077cbd0a998aebaa72c199e06b8a4c8dcfee ]
    
    With architectures allowing the kernel to be placed almost arbitrarily
    in memory (e.g.: ARM64), it is possible to have the kernel resides at
    physical addresses above 4GB, resulting in neither the default CMA area,
    nor the atomic pool from successfully allocating. This does not prevent
    specific peripherals from working though, one example is XHCI, which
    still operates correctly.
    
    Trouble comes when the XHCI driver gets suspended and resumed, since we
    can now trigger the following NPD:
    
    [   12.664170] usb usb1: root hub lost power or was reset
    [   12.669387] usb usb2: root hub lost power or was reset
    [   12.674662] Unable to handle kernel NULL pointer dereference at virtual address 00000008
    [   12.682896] pgd = ffffffc1365a7000
    [   12.686386] [00000008] *pgd=0000000136500003, *pud=0000000136500003, *pmd=0000000000000000
    [   12.694897] Internal error: Oops: 96000006 [#1] SMP
    [   12.699843] Modules linked in:
    [   12.702980] CPU: 0 PID: 1499 Comm: pml Not tainted 4.9.135-1.13pre #51
    [   12.709577] Hardware name: BCM97268DV (DT)
    [   12.713736] task: ffffffc136bb6540 task.stack: ffffffc1366cc000
    [   12.719740] PC is at addr_in_gen_pool+0x4/0x48
    [   12.724253] LR is at __dma_free+0x64/0xbc
    [   12.728325] pc : [<ffffff80083c0df8>] lr : [<ffffff80080979e0>] pstate: 60000145
    [   12.735825] sp : ffffffc1366cf990
    [   12.739196] x29: ffffffc1366cf990 x28: ffffffc1366cc000
    [   12.744608] x27: 0000000000000000 x26: ffffffc13a8568c8
    [   12.750020] x25: 0000000000000000 x24: ffffff80098f9000
    [   12.755433] x23: 000000013a5ff000 x22: ffffff8009c57000
    [   12.760844] x21: ffffffc13a856810 x20: 0000000000000000
    [   12.766255] x19: 0000000000001000 x18: 000000000000000a
    [   12.771667] x17: 0000007f917553e0 x16: 0000000000001002
    [   12.777078] x15: 00000000000a36cb x14: ffffff80898feb77
    [   12.782490] x13: ffffffffffffffff x12: 0000000000000030
    [   12.787899] x11: 00000000fffffffe x10: ffffff80098feb7f
    [   12.793311] x9 : 0000000005f5e0ff x8 : 65776f702074736f
    [   12.798723] x7 : 6c2062756820746f x6 : ffffff80098febb1
    [   12.804134] x5 : ffffff800809797c x4 : 0000000000000000
    [   12.809545] x3 : 000000013a5ff000 x2 : 0000000000000fff
    [   12.814955] x1 : ffffff8009c57000 x0 : 0000000000000000
    [   12.820363]
    [   12.821907] Process pml (pid: 1499, stack limit = 0xffffffc1366cc020)
    [   12.828421] Stack: (0xffffffc1366cf990 to 0xffffffc1366d0000)
    [   12.834240] f980:                                   ffffffc1366cf9e0 ffffff80086004d0
    [   12.842186] f9a0: ffffffc13ab08238 0000000000000010 ffffff80097c2218 ffffffc13a856810
    [   12.850131] f9c0: ffffff8009c57000 000000013a5ff000 0000000000000008 000000013a5ff000
    [   12.858076] f9e0: ffffffc1366cfa50 ffffff80085f9250 ffffffc13ab08238 0000000000000004
    [   12.866021] fa00: ffffffc13ab08000 ffffff80097b6000 ffffffc13ab08130 0000000000000001
    [   12.873966] fa20: 0000000000000008 ffffffc13a8568c8 0000000000000000 ffffffc1366cc000
    [   12.881911] fa40: ffffffc13ab08130 0000000000000001 ffffffc1366cfa90 ffffff80085e3de8
    [   12.889856] fa60: ffffffc13ab08238 0000000000000000 ffffffc136b75b00 0000000000000000
    [   12.897801] fa80: 0000000000000010 ffffff80089ccb92 ffffffc1366cfac0 ffffff80084ad040
    [   12.905746] faa0: ffffffc13a856810 0000000000000000 ffffff80084ad004 ffffff80084b91a8
    [   12.913691] fac0: ffffffc1366cfae0 ffffff80084b91b4 ffffffc13a856810 ffffff80080db5cc
    [   12.921636] fae0: ffffffc1366cfb20 ffffff80084b96bc ffffffc13a856810 0000000000000010
    [   12.929581] fb00: ffffffc13a856870 0000000000000000 ffffffc13a856810 ffffff800984d2b8
    [   12.937526] fb20: ffffffc1366cfb50 ffffff80084baa70 ffffff8009932ad0 ffffff800984d260
    [   12.945471] fb40: 0000000000000010 00000002eff0a065 ffffffc1366cfbb0 ffffff80084bafbc
    [   12.953415] fb60: 0000000000000010 0000000000000003 ffffff80098fe000 0000000000000000
    [   12.961360] fb80: ffffff80097b6000 ffffff80097b6dc8 ffffff80098c12b8 ffffff80098c12f8
    [   12.969306] fba0: ffffff8008842000 ffffff80097b6dc8 ffffffc1366cfbd0 ffffff80080e0d88
    [   12.977251] fbc0: 00000000fffffffb ffffff80080e10bc ffffffc1366cfc60 ffffff80080e16a8
    [   12.985196] fbe0: 0000000000000000 0000000000000003 ffffff80097b6000 ffffff80098fe9f0
    [   12.993140] fc00: ffffff80097d4000 ffffff8008983802 0000000000000123 0000000000000040
    [   13.001085] fc20: ffffff8008842000 ffffffc1366cc000 ffffff80089803c2 00000000ffffffff
    [   13.009029] fc40: 0000000000000000 0000000000000000 ffffffc1366cfc60 0000000000040987
    [   13.016974] fc60: ffffffc1366cfcc0 ffffff80080dfd08 0000000000000003 0000000000000004
    [   13.024919] fc80: 0000000000000003 ffffff80098fea08 ffffffc136577ec0 ffffff80089803c2
    [   13.032864] fca0: 0000000000000123 0000000000000001 0000000500000002 0000000000040987
    [   13.040809] fcc0: ffffffc1366cfd00 ffffff80083a89d4 0000000000000004 ffffffc136577ec0
    [   13.048754] fce0: ffffffc136610cc0 ffffffffffffffea ffffffc1366cfeb0 ffffffc136610cd8
    [   13.056700] fd00: ffffffc1366cfd10 ffffff800822a614 ffffffc1366cfd40 ffffff80082295d4
    [   13.064645] fd20: 0000000000000004 ffffffc136577ec0 ffffffc136610cc0 0000000021670570
    [   13.072590] fd40: ffffffc1366cfd80 ffffff80081b5d10 ffffff80097b6000 ffffffc13aae4200
    [   13.080536] fd60: ffffffc1366cfeb0 0000000000000004 0000000021670570 0000000000000004
    [   13.088481] fd80: ffffffc1366cfe30 ffffff80081b6b20 ffffffc13aae4200 0000000000000000
    [   13.096427] fda0: 0000000000000004 0000000021670570 ffffffc1366cfeb0 ffffffc13a838200
    [   13.104371] fdc0: 0000000000000000 000000000000000a ffffff80097b6000 0000000000040987
    [   13.112316] fde0: ffffffc1366cfe20 ffffff80081b3af0 ffffffc13a838200 0000000000000000
    [   13.120261] fe00: ffffffc1366cfe30 ffffff80081b6b0c ffffffc13aae4200 0000000000000000
    [   13.128206] fe20: 0000000000000004 0000000000040987 ffffffc1366cfe70 ffffff80081b7dd8
    [   13.136151] fe40: ffffff80097b6000 ffffffc13aae4200 ffffffc13aae4200 fffffffffffffff7
    [   13.144096] fe60: 0000000021670570 ffffffc13a8c63c0 0000000000000000 ffffff8008083180
    [   13.152042] fe80: ffffffffffffff1d 0000000021670570 ffffffffffffffff 0000007f917ad9b8
    [   13.159986] fea0: 0000000020000000 0000000000000015 0000000000000000 0000000000040987
    [   13.167930] fec0: 0000000000000001 0000000021670570 0000000000000004 0000000000000000
    [   13.175874] fee0: 0000000000000888 0000440110000000 000000000000006d 0000000000000003
    [   13.183819] ff00: 0000000000000040 ffffff80ffffffc8 0000000000000000 0000000000000020
    [   13.191762] ff20: 0000000000000000 0000000000000000 0000000000000001 0000000000000000
    [   13.199707] ff40: 0000000000000000 0000007f917553e0 0000000000000000 0000000000000004
    [   13.207651] ff60: 0000000021670570 0000007f91835480 0000000000000004 0000007f91831638
    [   13.215595] ff80: 0000000000000004 00000000004b0de0 00000000004b0000 0000000000000000
    [   13.223539] ffa0: 0000000000000000 0000007fc92ac8c0 0000007f9175d178 0000007fc92ac8c0
    [   13.231483] ffc0: 0000007f917ad9b8 0000000020000000 0000000000000001 0000000000000040
    [   13.239427] ffe0: 0000000000000000 0000000000000000 0000000000000000 0000000000000000
    [   13.247360] Call trace:
    [   13.249866] Exception stack(0xffffffc1366cf7a0 to 0xffffffc1366cf8d0)
    [   13.256386] f7a0: 0000000000001000 0000007fffffffff ffffffc1366cf990 ffffff80083c0df8
    [   13.264331] f7c0: 0000000060000145 ffffff80089b5001 ffffffc13ab08130 0000000000000001
    [   13.272275] f7e0: 0000000000000008 ffffffc13a8568c8 0000000000000000 0000000000000000
    [   13.280220] f800: ffffffc1366cf960 ffffffc1366cf960 ffffffc1366cf930 00000000ffffffd8
    [   13.288165] f820: ffffff8009931ac0 4554535953425553 4544006273753d4d 3831633d45434956
    [   13.296110] f840: ffff003832313a39 ffffff800845926c ffffffc1366cf880 0000000000040987
    [   13.304054] f860: 0000000000000000 ffffff8009c57000 0000000000000fff 000000013a5ff000
    [   13.311999] f880: 0000000000000000 ffffff800809797c ffffff80098febb1 6c2062756820746f
    [   13.319944] f8a0: 65776f702074736f 0000000005f5e0ff ffffff80098feb7f 00000000fffffffe
    [   13.327884] f8c0: 0000000000000030 ffffffffffffffff
    [   13.332835] [<ffffff80083c0df8>] addr_in_gen_pool+0x4/0x48
    [   13.338398] [<ffffff80086004d0>] xhci_mem_cleanup+0xc8/0x51c
    [   13.344137] [<ffffff80085f9250>] xhci_resume+0x308/0x65c
    [   13.349524] [<ffffff80085e3de8>] xhci_brcm_resume+0x84/0x8c
    [   13.355174] [<ffffff80084ad040>] platform_pm_resume+0x3c/0x64
    [   13.360997] [<ffffff80084b91b4>] dpm_run_callback+0x5c/0x15c
    [   13.366732] [<ffffff80084b96bc>] device_resume+0xc0/0x190
    [   13.372205] [<ffffff80084baa70>] dpm_resume+0x144/0x2cc
    [   13.377504] [<ffffff80084bafbc>] dpm_resume_end+0x20/0x34
    [   13.382980] [<ffffff80080e0d88>] suspend_devices_and_enter+0x104/0x704
    [   13.389585] [<ffffff80080e16a8>] pm_suspend+0x320/0x53c
    [   13.394881] [<ffffff80080dfd08>] state_store+0xbc/0xe0
    [   13.400094] [<ffffff80083a89d4>] kobj_attr_store+0x14/0x24
    [   13.405655] [<ffffff800822a614>] sysfs_kf_write+0x60/0x70
    [   13.411128] [<ffffff80082295d4>] kernfs_fop_write+0x130/0x194
    [   13.416954] [<ffffff80081b5d10>] __vfs_write+0x60/0x150
    [   13.422254] [<ffffff80081b6b20>] vfs_write+0xc8/0x164
    [   13.427376] [<ffffff80081b7dd8>] SyS_write+0x70/0xc8
    [   13.432412] [<ffffff8008083180>] el0_svc_naked+0x34/0x38
    [   13.437800] Code: 92800173 97f6fb9e 17fffff5 d1000442 (f8408c03)
    [   13.444033] ---[ end trace 2effe12f909ce205 ]---
    
    The call path leading to this problem is xhci_mem_cleanup() ->
    dma_free_coherent() -> dma_free_from_pool() -> addr_in_gen_pool. If the
    atomic_pool is NULL, we can't possibly have the address in the atomic
    pool anyway, so guard against that.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 471a739a47aa7d582f0cdf9d392957d04632bae2
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Jun 26 00:20:23 2019 +0200

    PCI: PM: Avoid skipping bus-level PM on platforms without ACPI
    
    There are platforms that do not call pm_set_suspend_via_firmware(),
    so pm_suspend_via_firmware() returns 'false' on them, but the power
    states of PCI devices (PCIe ports in particular) are changed as a
    result of powering down core platform components during system-wide
    suspend.  Thus the pm_suspend_via_firmware() checks in
    pci_pm_suspend_noirq() and pci_pm_resume_noirq() introduced by
    commit 3e26c5feed2a ("PCI: PM: Skip devices in D0 for suspend-to-
    idle") are not sufficient to determine that devices left in D0
    during suspend will remain in D0 during resume and so the bus-level
    power management can be skipped for them.
    
    For this reason, introduce a new global suspend flag,
    PM_SUSPEND_FLAG_NO_PLATFORM, set it for suspend-to-idle only
    and replace the pm_suspend_via_firmware() checks mentioned above
    with checks against this flag.
    
    Fixes: 3e26c5feed2a ("PCI: PM: Skip devices in D0 for suspend-to-idle")
    Reported-by: Jon Hunter <jonathanh@nvidia.com>
    Tested-by: Jon Hunter <jonathanh@nvidia.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>

commit 316b9ef1ee14c405f25923bf5831c0bd4bebc47a
Author: Manikanta Maddireddy <mmaddireddy@nvidia.com>
Date:   Tue Jun 18 23:31:43 2019 +0530

    PCI: tegra: Mask AFI_INTR in runtime suspend
    
    AFI_INTR is unmasked in tegra_pcie_enable_controller(), mask it to avoid
    unwanted interrupts raised by AFI after pex_rst is asserted.
    
    The following sequence triggers such scenario:
    
    - tegra_pcie_remove() triggers runtime suspend
    - pex_rst is asserted in runtime suspend
    - PRSNT_MAP bit field in RP_PRIV_MISC register changes from EP_PRSNT to
      EP_ABSNT
    - This is sensed by AFI and triggers "Slot present pin change" interrupt
    - tegra_pcie_isr() function accesses AFI register when runtime suspend
      is going through power off sequence
    
    Resulting faulty backtrace:
    
    rmmod pci-tegra
     pci_generic_config_write32: 108 callbacks suppressed
     pci_bus 0002:00: 2-byte config write to 0002:00:02.0 offset 0x4c may corrupt adjacent RW1C bits
     pci_bus 0002:00: 2-byte config write to 0002:00:02.0 offset 0x9c may corrupt adjacent RW1C bits
     pci_bus 0002:00: 2-byte config write to 0002:00:02.0 offset 0x88 may corrupt adjacent RW1C bits
     pci_bus 0002:00: 2-byte config write to 0002:00:02.0 offset 0x90 may corrupt adjacent RW1C bits
     pci_bus 0002:00: 2-byte config write to 0002:00:02.0 offset 0x4 may corrupt adjacent RW1C bits
     igb 0002:04:00.1: removed PHC on enP2p4s0f1
     igb 0002:04:00.0: removed PHC on enP2p4s0f0
     pci_bus 0002:00: 2-byte config write to 0002:00:01.0 offset 0x4c may corrupt adjacent RW1C bits
     pci_bus 0002:00: 2-byte config write to 0002:00:01.0 offset 0x9c may corrupt adjacent RW1C bits
     pci_bus 0002:00: 2-byte config write to 0002:00:01.0 offset 0x88 may corrupt adjacent RW1C bits
     pci_bus 0002:00: 2-byte config write to 0002:00:01.0 offset 0x90 may corrupt adjacent RW1C bits
     pci_bus 0002:00: 2-byte config write to 0002:00:01.0 offset 0x4 may corrupt adjacent RW1C bits
     rcu: INFO: rcu_preempt self-detected stall on CPU
     SError Interrupt on CPU0, code 0xbf000002 -- SError
     CPU: 0 PID: 0 Comm: swapper/0 Tainted: G        W         5.1.0-rc3-next-20190405-00027-gcd8110499e6f-dirty #42
     Hardware name: NVIDIA Jetson TX1 Developer Kit (DT)
     pstate: 20000085 (nzCv daIf -PAN -UAO)
     pc : tegra_pcie_isr+0x58/0x178 [pci_tegra]
     lr : tegra_pcie_isr+0x40/0x178 [pci_tegra]
     sp : ffff000010003da0
     x29: ffff000010003da0 x28: 0000000000000000
     x27: ffff8000f9e61000 x26: ffff000010fbf420
     x25: ffff000011427f93 x24: ffff8000fa600410
     x23: ffff00001129d000 x22: ffff00001129d000
     x21: ffff8000f18bf3c0 x20: 0000000000000070
     x19: 00000000ffffffff x18: 0000000000000000
     x17: 0000000000000000 x16: 0000000000000000
     x15: 0000000000000000 x14: ffff000008d40a48
     x13: ffff000008d40a30 x12: ffff000008d40a20
     x11: ffff000008d40a10 x10: ffff000008d40a00
     x9 : ffff000008d409e8 x8 : ffff000008d40ae8
     x7 : ffff000008d40ad0 x6 : ffff000010003e58
     x5 : ffff8000fac00248 x4 : 0000000000000000
     x3 : ffff000008d40b08 x2 : fffffffffffffff8
     x1 : ffff000008d3f4e8 x0 : 00000000ffffffff
     Kernel panic - not syncing: Asynchronous SError Interrupt
     CPU: 0 PID: 0 Comm: swapper/0 Tainted: G        W         5.1.0-rc3-next-20190405-00027-gcd8110499e6f-dirty #42
     Hardware name: NVIDIA Jetson TX1 Developer Kit (DT)
     Call trace:
      dump_backtrace+0x0/0x158
      show_stack+0x14/0x20
      dump_stack+0xa8/0xcc
      panic+0x140/0x2f4
      nmi_panic+0x6c/0x70
      arm64_serror_panic+0x74/0x80
      __pte_error+0x0/0x28
      el1_error+0x84/0xf8
      tegra_pcie_isr+0x58/0x178 [pci_tegra]
      __handle_irq_event_percpu+0x70/0x198
      handle_irq_event_percpu+0x34/0x88
      handle_irq_event+0x48/0x78
      handle_fasteoi_irq+0xb4/0x190
      generic_handle_irq+0x24/0x38
      __handle_domain_irq+0x5c/0xb8
      gic_handle_irq+0x58/0xa8
      el1_irq+0xb8/0x180
      cpuidle_enter_state+0x138/0x358
      cpuidle_enter+0x18/0x20
      call_cpuidle+0x1c/0x48
      do_idle+0x230/0x2d0
      cpu_startup_entry+0x20/0x28
      rest_init+0xd4/0xe0
      arch_call_rest_init+0xc/0x14
      start_kernel+0x444/0x470
    
    AFI_INTR is re-enabled on resume in tegra_pcie_pm_resume() through
    tegra_pcie_enable_controller().
    
    Signed-off-by: Manikanta Maddireddy <mmaddireddy@nvidia.com>
    [lorenzo.pieralisi@arm.com: updated log]
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Acked-by: Thierry Reding <treding@nvidia.com>

commit 61ed7ef952fc482ec8d4a966ed0d1e32df276c59
Author: Bitan Biswas <bbiswas@nvidia.com>
Date:   Fri Jun 14 05:31:39 2019 -0700

    firmware: tegra: Early resume BPMP
    
    Early resume Tegra BPMP to fix Xavier clock rate error as follows:
    
            [  159.017101] of_serial 3110000.serial: calling platform_pm_resume+0x0/0x58 @ 317, parent: cbb
            [  159.025501] of_serial 3110000.serial: platform_pm_resume+0x0/0x58 returned 0 after 14 usecs
            [  159.033694] tegra-i2c 31c0000.i2c: calling platform_pm_resume+0x0/0x58 @ 317, parent: cbb
            [  159.042254] tegra-i2c 31c0000.i2c: failed changing clock rate: -22
            [  159.048216] PM: dpm_run_callback(): platform_pm_resume+0x0/0x58 returns -22
            [  159.055553] tegra-i2c 31c0000.i2c: platform_pm_resume+0x0/0x58 returned -22 after 13072 usecs
            [  159.063875] PM: Device 31c0000.i2c failed to resume: error -22
    
    Signed-off-by: Bitan Biswas <bbiswas@nvidia.com>
    Signed-off-by: Thierry Reding <treding@nvidia.com>

commit 4b4b077cbd0a998aebaa72c199e06b8a4c8dcfee
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Mon Jun 10 15:54:37 2019 -0700

    dma-remap: Avoid de-referencing NULL atomic_pool
    
    With architectures allowing the kernel to be placed almost arbitrarily
    in memory (e.g.: ARM64), it is possible to have the kernel resides at
    physical addresses above 4GB, resulting in neither the default CMA area,
    nor the atomic pool from successfully allocating. This does not prevent
    specific peripherals from working though, one example is XHCI, which
    still operates correctly.
    
    Trouble comes when the XHCI driver gets suspended and resumed, since we
    can now trigger the following NPD:
    
    [   12.664170] usb usb1: root hub lost power or was reset
    [   12.669387] usb usb2: root hub lost power or was reset
    [   12.674662] Unable to handle kernel NULL pointer dereference at virtual address 00000008
    [   12.682896] pgd = ffffffc1365a7000
    [   12.686386] [00000008] *pgd=0000000136500003, *pud=0000000136500003, *pmd=0000000000000000
    [   12.694897] Internal error: Oops: 96000006 [#1] SMP
    [   12.699843] Modules linked in:
    [   12.702980] CPU: 0 PID: 1499 Comm: pml Not tainted 4.9.135-1.13pre #51
    [   12.709577] Hardware name: BCM97268DV (DT)
    [   12.713736] task: ffffffc136bb6540 task.stack: ffffffc1366cc000
    [   12.719740] PC is at addr_in_gen_pool+0x4/0x48
    [   12.724253] LR is at __dma_free+0x64/0xbc
    [   12.728325] pc : [<ffffff80083c0df8>] lr : [<ffffff80080979e0>] pstate: 60000145
    [   12.735825] sp : ffffffc1366cf990
    [   12.739196] x29: ffffffc1366cf990 x28: ffffffc1366cc000
    [   12.744608] x27: 0000000000000000 x26: ffffffc13a8568c8
    [   12.750020] x25: 0000000000000000 x24: ffffff80098f9000
    [   12.755433] x23: 000000013a5ff000 x22: ffffff8009c57000
    [   12.760844] x21: ffffffc13a856810 x20: 0000000000000000
    [   12.766255] x19: 0000000000001000 x18: 000000000000000a
    [   12.771667] x17: 0000007f917553e0 x16: 0000000000001002
    [   12.777078] x15: 00000000000a36cb x14: ffffff80898feb77
    [   12.782490] x13: ffffffffffffffff x12: 0000000000000030
    [   12.787899] x11: 00000000fffffffe x10: ffffff80098feb7f
    [   12.793311] x9 : 0000000005f5e0ff x8 : 65776f702074736f
    [   12.798723] x7 : 6c2062756820746f x6 : ffffff80098febb1
    [   12.804134] x5 : ffffff800809797c x4 : 0000000000000000
    [   12.809545] x3 : 000000013a5ff000 x2 : 0000000000000fff
    [   12.814955] x1 : ffffff8009c57000 x0 : 0000000000000000
    [   12.820363]
    [   12.821907] Process pml (pid: 1499, stack limit = 0xffffffc1366cc020)
    [   12.828421] Stack: (0xffffffc1366cf990 to 0xffffffc1366d0000)
    [   12.834240] f980:                                   ffffffc1366cf9e0 ffffff80086004d0
    [   12.842186] f9a0: ffffffc13ab08238 0000000000000010 ffffff80097c2218 ffffffc13a856810
    [   12.850131] f9c0: ffffff8009c57000 000000013a5ff000 0000000000000008 000000013a5ff000
    [   12.858076] f9e0: ffffffc1366cfa50 ffffff80085f9250 ffffffc13ab08238 0000000000000004
    [   12.866021] fa00: ffffffc13ab08000 ffffff80097b6000 ffffffc13ab08130 0000000000000001
    [   12.873966] fa20: 0000000000000008 ffffffc13a8568c8 0000000000000000 ffffffc1366cc000
    [   12.881911] fa40: ffffffc13ab08130 0000000000000001 ffffffc1366cfa90 ffffff80085e3de8
    [   12.889856] fa60: ffffffc13ab08238 0000000000000000 ffffffc136b75b00 0000000000000000
    [   12.897801] fa80: 0000000000000010 ffffff80089ccb92 ffffffc1366cfac0 ffffff80084ad040
    [   12.905746] faa0: ffffffc13a856810 0000000000000000 ffffff80084ad004 ffffff80084b91a8
    [   12.913691] fac0: ffffffc1366cfae0 ffffff80084b91b4 ffffffc13a856810 ffffff80080db5cc
    [   12.921636] fae0: ffffffc1366cfb20 ffffff80084b96bc ffffffc13a856810 0000000000000010
    [   12.929581] fb00: ffffffc13a856870 0000000000000000 ffffffc13a856810 ffffff800984d2b8
    [   12.937526] fb20: ffffffc1366cfb50 ffffff80084baa70 ffffff8009932ad0 ffffff800984d260
    [   12.945471] fb40: 0000000000000010 00000002eff0a065 ffffffc1366cfbb0 ffffff80084bafbc
    [   12.953415] fb60: 0000000000000010 0000000000000003 ffffff80098fe000 0000000000000000
    [   12.961360] fb80: ffffff80097b6000 ffffff80097b6dc8 ffffff80098c12b8 ffffff80098c12f8
    [   12.969306] fba0: ffffff8008842000 ffffff80097b6dc8 ffffffc1366cfbd0 ffffff80080e0d88
    [   12.977251] fbc0: 00000000fffffffb ffffff80080e10bc ffffffc1366cfc60 ffffff80080e16a8
    [   12.985196] fbe0: 0000000000000000 0000000000000003 ffffff80097b6000 ffffff80098fe9f0
    [   12.993140] fc00: ffffff80097d4000 ffffff8008983802 0000000000000123 0000000000000040
    [   13.001085] fc20: ffffff8008842000 ffffffc1366cc000 ffffff80089803c2 00000000ffffffff
    [   13.009029] fc40: 0000000000000000 0000000000000000 ffffffc1366cfc60 0000000000040987
    [   13.016974] fc60: ffffffc1366cfcc0 ffffff80080dfd08 0000000000000003 0000000000000004
    [   13.024919] fc80: 0000000000000003 ffffff80098fea08 ffffffc136577ec0 ffffff80089803c2
    [   13.032864] fca0: 0000000000000123 0000000000000001 0000000500000002 0000000000040987
    [   13.040809] fcc0: ffffffc1366cfd00 ffffff80083a89d4 0000000000000004 ffffffc136577ec0
    [   13.048754] fce0: ffffffc136610cc0 ffffffffffffffea ffffffc1366cfeb0 ffffffc136610cd8
    [   13.056700] fd00: ffffffc1366cfd10 ffffff800822a614 ffffffc1366cfd40 ffffff80082295d4
    [   13.064645] fd20: 0000000000000004 ffffffc136577ec0 ffffffc136610cc0 0000000021670570
    [   13.072590] fd40: ffffffc1366cfd80 ffffff80081b5d10 ffffff80097b6000 ffffffc13aae4200
    [   13.080536] fd60: ffffffc1366cfeb0 0000000000000004 0000000021670570 0000000000000004
    [   13.088481] fd80: ffffffc1366cfe30 ffffff80081b6b20 ffffffc13aae4200 0000000000000000
    [   13.096427] fda0: 0000000000000004 0000000021670570 ffffffc1366cfeb0 ffffffc13a838200
    [   13.104371] fdc0: 0000000000000000 000000000000000a ffffff80097b6000 0000000000040987
    [   13.112316] fde0: ffffffc1366cfe20 ffffff80081b3af0 ffffffc13a838200 0000000000000000
    [   13.120261] fe00: ffffffc1366cfe30 ffffff80081b6b0c ffffffc13aae4200 0000000000000000
    [   13.128206] fe20: 0000000000000004 0000000000040987 ffffffc1366cfe70 ffffff80081b7dd8
    [   13.136151] fe40: ffffff80097b6000 ffffffc13aae4200 ffffffc13aae4200 fffffffffffffff7
    [   13.144096] fe60: 0000000021670570 ffffffc13a8c63c0 0000000000000000 ffffff8008083180
    [   13.152042] fe80: ffffffffffffff1d 0000000021670570 ffffffffffffffff 0000007f917ad9b8
    [   13.159986] fea0: 0000000020000000 0000000000000015 0000000000000000 0000000000040987
    [   13.167930] fec0: 0000000000000001 0000000021670570 0000000000000004 0000000000000000
    [   13.175874] fee0: 0000000000000888 0000440110000000 000000000000006d 0000000000000003
    [   13.183819] ff00: 0000000000000040 ffffff80ffffffc8 0000000000000000 0000000000000020
    [   13.191762] ff20: 0000000000000000 0000000000000000 0000000000000001 0000000000000000
    [   13.199707] ff40: 0000000000000000 0000007f917553e0 0000000000000000 0000000000000004
    [   13.207651] ff60: 0000000021670570 0000007f91835480 0000000000000004 0000007f91831638
    [   13.215595] ff80: 0000000000000004 00000000004b0de0 00000000004b0000 0000000000000000
    [   13.223539] ffa0: 0000000000000000 0000007fc92ac8c0 0000007f9175d178 0000007fc92ac8c0
    [   13.231483] ffc0: 0000007f917ad9b8 0000000020000000 0000000000000001 0000000000000040
    [   13.239427] ffe0: 0000000000000000 0000000000000000 0000000000000000 0000000000000000
    [   13.247360] Call trace:
    [   13.249866] Exception stack(0xffffffc1366cf7a0 to 0xffffffc1366cf8d0)
    [   13.256386] f7a0: 0000000000001000 0000007fffffffff ffffffc1366cf990 ffffff80083c0df8
    [   13.264331] f7c0: 0000000060000145 ffffff80089b5001 ffffffc13ab08130 0000000000000001
    [   13.272275] f7e0: 0000000000000008 ffffffc13a8568c8 0000000000000000 0000000000000000
    [   13.280220] f800: ffffffc1366cf960 ffffffc1366cf960 ffffffc1366cf930 00000000ffffffd8
    [   13.288165] f820: ffffff8009931ac0 4554535953425553 4544006273753d4d 3831633d45434956
    [   13.296110] f840: ffff003832313a39 ffffff800845926c ffffffc1366cf880 0000000000040987
    [   13.304054] f860: 0000000000000000 ffffff8009c57000 0000000000000fff 000000013a5ff000
    [   13.311999] f880: 0000000000000000 ffffff800809797c ffffff80098febb1 6c2062756820746f
    [   13.319944] f8a0: 65776f702074736f 0000000005f5e0ff ffffff80098feb7f 00000000fffffffe
    [   13.327884] f8c0: 0000000000000030 ffffffffffffffff
    [   13.332835] [<ffffff80083c0df8>] addr_in_gen_pool+0x4/0x48
    [   13.338398] [<ffffff80086004d0>] xhci_mem_cleanup+0xc8/0x51c
    [   13.344137] [<ffffff80085f9250>] xhci_resume+0x308/0x65c
    [   13.349524] [<ffffff80085e3de8>] xhci_brcm_resume+0x84/0x8c
    [   13.355174] [<ffffff80084ad040>] platform_pm_resume+0x3c/0x64
    [   13.360997] [<ffffff80084b91b4>] dpm_run_callback+0x5c/0x15c
    [   13.366732] [<ffffff80084b96bc>] device_resume+0xc0/0x190
    [   13.372205] [<ffffff80084baa70>] dpm_resume+0x144/0x2cc
    [   13.377504] [<ffffff80084bafbc>] dpm_resume_end+0x20/0x34
    [   13.382980] [<ffffff80080e0d88>] suspend_devices_and_enter+0x104/0x704
    [   13.389585] [<ffffff80080e16a8>] pm_suspend+0x320/0x53c
    [   13.394881] [<ffffff80080dfd08>] state_store+0xbc/0xe0
    [   13.400094] [<ffffff80083a89d4>] kobj_attr_store+0x14/0x24
    [   13.405655] [<ffffff800822a614>] sysfs_kf_write+0x60/0x70
    [   13.411128] [<ffffff80082295d4>] kernfs_fop_write+0x130/0x194
    [   13.416954] [<ffffff80081b5d10>] __vfs_write+0x60/0x150
    [   13.422254] [<ffffff80081b6b20>] vfs_write+0xc8/0x164
    [   13.427376] [<ffffff80081b7dd8>] SyS_write+0x70/0xc8
    [   13.432412] [<ffffff8008083180>] el0_svc_naked+0x34/0x38
    [   13.437800] Code: 92800173 97f6fb9e 17fffff5 d1000442 (f8408c03)
    [   13.444033] ---[ end trace 2effe12f909ce205 ]---
    
    The call path leading to this problem is xhci_mem_cleanup() ->
    dma_free_coherent() -> dma_free_from_pool() -> addr_in_gen_pool. If the
    atomic_pool is NULL, we can't possibly have the address in the atomic
    pool anyway, so guard against that.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

commit a61373476127edac8bcc5ee9d68a74dc1b864f53
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon May 27 12:45:18 2019 +0200

    PM: sleep: Add kerneldoc comments to some functions
    
    Add kerneldoc comments to pm_suspend_via_firmware(),
    pm_resume_via_firmware() and pm_suspend_via_s2idle()
    to explain what they do.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit d491f2b75237ef37d8867830ab7fad8d9659e853
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri May 17 11:08:50 2019 +0200

    PCI: PM: Avoid possible suspend-to-idle issue
    
    If a PCI driver leaves the device handled by it in D0 and calls
    pci_save_state() on the device in its ->suspend() or ->suspend_late()
    callback, it can expect the device to stay in D0 over the whole
    s2idle cycle.  However, that may not be the case if there is a
    spurious wakeup while the system is suspended, because in that case
    pci_pm_suspend_noirq() will run again after pci_pm_resume_noirq()
    which calls pci_restore_state(), via pci_pm_default_resume_early(),
    so state_saved is cleared and the second iteration of
    pci_pm_suspend_noirq() will invoke pci_prepare_to_sleep() which
    may change the power state of the device.
    
    To avoid that, add a new internal flag, skip_bus_pm, that will be set
    by pci_pm_suspend_noirq() when it runs for the first time during the
    given system suspend-resume cycle if the state of the device has
    been saved already and the device is still in D0.  Setting that flag
    will cause the next iterations of pci_pm_suspend_noirq() to set
    state_saved for pci_pm_resume_noirq(), so that it always restores the
    device state from the originally saved data, and avoid calling
    pci_prepare_to_sleep() for the device.
    
    Fixes: 33e4f80ee69b ("ACPI / PM: Ignore spurious SCI wakeups from suspend-to-idle")
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Keith Busch <keith.busch@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>

commit dd5ce1e391cbc192280e49d968372cdcd8fd12de
Author: Ofir Drang <ofir.drang@arm.com>
Date:   Thu Apr 18 16:39:10 2019 +0300

    crypto: ccree - handle tee fips error during power management resume
    
    commit 7138377ce10455b7183c6dde4b2c51b33f464c45 upstream.
    
    in order to support cryptocell tee fips error that may occurs while
    cryptocell ree is suspended, an cc_tee_handle_fips_error  call added
    to the cc_pm_resume function.
    
    Signed-off-by: Ofir Drang <ofir.drang@arm.com>
    Signed-off-by: Gilad Ben-Yossef <gilad@benyossef.com>
    Cc: stable@vger.kernel.org # v4.19+
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit b5b076649d2ec7be156013187fa6932dffc96db3
Author: Ofir Drang <ofir.drang@arm.com>
Date:   Thu Apr 18 16:39:10 2019 +0300

    crypto: ccree - handle tee fips error during power management resume
    
    commit 7138377ce10455b7183c6dde4b2c51b33f464c45 upstream.
    
    in order to support cryptocell tee fips error that may occurs while
    cryptocell ree is suspended, an cc_tee_handle_fips_error  call added
    to the cc_pm_resume function.
    
    Signed-off-by: Ofir Drang <ofir.drang@arm.com>
    Signed-off-by: Gilad Ben-Yossef <gilad@benyossef.com>
    Cc: stable@vger.kernel.org # v4.19+
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 681f3695d514e5154997c9c3d04f4ff7128a4382
Author: Ofir Drang <ofir.drang@arm.com>
Date:   Thu Apr 18 16:39:10 2019 +0300

    crypto: ccree - handle tee fips error during power management resume
    
    commit 7138377ce10455b7183c6dde4b2c51b33f464c45 upstream.
    
    in order to support cryptocell tee fips error that may occurs while
    cryptocell ree is suspended, an cc_tee_handle_fips_error  call added
    to the cc_pm_resume function.
    
    Signed-off-by: Ofir Drang <ofir.drang@arm.com>
    Signed-off-by: Gilad Ben-Yossef <gilad@benyossef.com>
    Cc: stable@vger.kernel.org # v4.19+
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 7138377ce10455b7183c6dde4b2c51b33f464c45
Author: Ofir Drang <ofir.drang@arm.com>
Date:   Thu Apr 18 16:39:10 2019 +0300

    crypto: ccree - handle tee fips error during power management resume
    
    in order to support cryptocell tee fips error that may occurs while
    cryptocell ree is suspended, an cc_tee_handle_fips_error  call added
    to the cc_pm_resume function.
    
    Signed-off-by: Ofir Drang <ofir.drang@arm.com>
    Signed-off-by: Gilad Ben-Yossef <gilad@benyossef.com>
    Cc: stable@vger.kernel.org # v4.19+
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

commit 8bd30e5e0ec594d6200448f0c2b889bd8bd28a5a
Author: Jiada Wang <jiada_wang@mentor.com>
Date:   Tue Mar 12 15:51:28 2019 +0900

    PM / Domains: Avoid a potential deadlock
    
    [ Upstream commit 2071ac985d37efe496782c34318dbead93beb02f ]
    
    Lockdep warns that prepare_lock and genpd->mlock can cause a deadlock
    the deadlock scenario is like following:
    First thread is probing cs2000
    cs2000_probe()
      clk_register()
        __clk_core_init()
          clk_prepare_lock()                            ----> acquires prepare_lock
            cs2000_recalc_rate()
              i2c_smbus_read_byte_data()
                rcar_i2c_master_xfer()
                  dma_request_chan()
                    rcar_dmac_of_xlate()
                      rcar_dmac_alloc_chan_resources()
                        pm_runtime_get_sync()
                          __pm_runtime_resume()
                            rpm_resume()
                              rpm_callback()
                                genpd_runtime_resume()   ----> acquires genpd->mlock
    
    Second thread is attaching any device to the same PM domain
    genpd_add_device()
      genpd_lock()                                       ----> acquires genpd->mlock
        cpg_mssr_attach_dev()
          of_clk_get_from_provider()
            __of_clk_get_from_provider()
              __clk_create_clk()
                clk_prepare_lock()                       ----> acquires prepare_lock
    
    Since currently no PM provider access genpd's critical section
    in .attach_dev, and .detach_dev callbacks, so there is no need to protect
    these two callbacks with genpd->mlock.
    This patch avoids a potential deadlock by moving out .attach_dev and .detach_dev
    from genpd->mlock, so that genpd->mlock won't be held when prepare_lock is acquired
    in .attach_dev and .detach_dev
    
    Signed-off-by: Jiada Wang <jiada_wang@mentor.com>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Tested-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Reviewed-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit b63df738ce7d7b93a412d45005dc3d2331c3d1d8
Author: Jiada Wang <jiada_wang@mentor.com>
Date:   Tue Mar 12 15:51:28 2019 +0900

    PM / Domains: Avoid a potential deadlock
    
    [ Upstream commit 2071ac985d37efe496782c34318dbead93beb02f ]
    
    Lockdep warns that prepare_lock and genpd->mlock can cause a deadlock
    the deadlock scenario is like following:
    First thread is probing cs2000
    cs2000_probe()
      clk_register()
        __clk_core_init()
          clk_prepare_lock()                            ----> acquires prepare_lock
            cs2000_recalc_rate()
              i2c_smbus_read_byte_data()
                rcar_i2c_master_xfer()
                  dma_request_chan()
                    rcar_dmac_of_xlate()
                      rcar_dmac_alloc_chan_resources()
                        pm_runtime_get_sync()
                          __pm_runtime_resume()
                            rpm_resume()
                              rpm_callback()
                                genpd_runtime_resume()   ----> acquires genpd->mlock
    
    Second thread is attaching any device to the same PM domain
    genpd_add_device()
      genpd_lock()                                       ----> acquires genpd->mlock
        cpg_mssr_attach_dev()
          of_clk_get_from_provider()
            __of_clk_get_from_provider()
              __clk_create_clk()
                clk_prepare_lock()                       ----> acquires prepare_lock
    
    Since currently no PM provider access genpd's critical section
    in .attach_dev, and .detach_dev callbacks, so there is no need to protect
    these two callbacks with genpd->mlock.
    This patch avoids a potential deadlock by moving out .attach_dev and .detach_dev
    from genpd->mlock, so that genpd->mlock won't be held when prepare_lock is acquired
    in .attach_dev and .detach_dev
    
    Signed-off-by: Jiada Wang <jiada_wang@mentor.com>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Tested-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Reviewed-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 4d026d221b3435144aac0920f77595bb1806fb5e
Author: Hui Wang <hui.wang@canonical.com>
Date:   Tue Mar 19 09:28:44 2019 +0800

    ALSA: hda - Enforces runtime_resume after S3 and S4 for each codec
    
    commit b5a236c175b0d984552a5f7c9d35141024c2b261 upstream.
    
    Recently we found the audio jack detection stop working after suspend
    on many machines with Realtek codec. Sometimes the audio selection
    dialogue didn't show up after users plugged headhphone/headset into
    the headset jack, sometimes after uses plugged headphone/headset, then
    click the sound icon on the upper-right corner of gnome-desktop, it
    also showed the speaker rather than the headphone.
    
    The root cause is that before suspend, the codec already call the
    runtime_suspend since this codec is not used by any apps, then in
    resume, it will not call runtime_resume for this codec. But for some
    realtek codec (so far, alc236, alc255 and alc891) with the specific
    BIOS, if it doesn't run runtime_resume after suspend, all codec
    functions including jack detection stop working anymore.
    
    This problem existed for a long time, but it was not exposed, that is
    because when problem happens, if users play sound or open
    sound-setting to check audio device, this will trigger calling to
    runtime_resume (via snd_hda_power_up), then the codec starts working
    again before users notice this problem.
    
    Since we don't know how many codec and BIOS combinations have this
    problem, to fix it, let the driver call runtime_resume for all codecs
    in pm_resume, maybe for some codecs, this is not needed, but it is
    harmless. After a codec is runtime resumed, if it is not used by any
    apps, it will be runtime suspended soon and furthermore we don't run
    suspend frequently, this change will not add much power consumption.
    
    Fixes: cc72da7d4d06 ("ALSA: hda - Use standard runtime PM for codec power-save control")
    Signed-off-by: Hui Wang <hui.wang@canonical.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit a57af6d07512716b78f1a32d9426bcdf6aafc50c
Author: Hui Wang <hui.wang@canonical.com>
Date:   Tue Mar 19 09:28:44 2019 +0800

    ALSA: hda - Enforces runtime_resume after S3 and S4 for each codec
    
    commit b5a236c175b0d984552a5f7c9d35141024c2b261 upstream.
    
    Recently we found the audio jack detection stop working after suspend
    on many machines with Realtek codec. Sometimes the audio selection
    dialogue didn't show up after users plugged headhphone/headset into
    the headset jack, sometimes after uses plugged headphone/headset, then
    click the sound icon on the upper-right corner of gnome-desktop, it
    also showed the speaker rather than the headphone.
    
    The root cause is that before suspend, the codec already call the
    runtime_suspend since this codec is not used by any apps, then in
    resume, it will not call runtime_resume for this codec. But for some
    realtek codec (so far, alc236, alc255 and alc891) with the specific
    BIOS, if it doesn't run runtime_resume after suspend, all codec
    functions including jack detection stop working anymore.
    
    This problem existed for a long time, but it was not exposed, that is
    because when problem happens, if users play sound or open
    sound-setting to check audio device, this will trigger calling to
    runtime_resume (via snd_hda_power_up), then the codec starts working
    again before users notice this problem.
    
    Since we don't know how many codec and BIOS combinations have this
    problem, to fix it, let the driver call runtime_resume for all codecs
    in pm_resume, maybe for some codecs, this is not needed, but it is
    harmless. After a codec is runtime resumed, if it is not used by any
    apps, it will be runtime suspended soon and furthermore we don't run
    suspend frequently, this change will not add much power consumption.
    
    Fixes: cc72da7d4d06 ("ALSA: hda - Use standard runtime PM for codec power-save control")
    Signed-off-by: Hui Wang <hui.wang@canonical.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 19184190b029c034a2e6be8f0d6c6301f5da63d3
Author: Hui Wang <hui.wang@canonical.com>
Date:   Tue Mar 19 09:28:44 2019 +0800

    ALSA: hda - Enforces runtime_resume after S3 and S4 for each codec
    
    commit b5a236c175b0d984552a5f7c9d35141024c2b261 upstream.
    
    Recently we found the audio jack detection stop working after suspend
    on many machines with Realtek codec. Sometimes the audio selection
    dialogue didn't show up after users plugged headhphone/headset into
    the headset jack, sometimes after uses plugged headphone/headset, then
    click the sound icon on the upper-right corner of gnome-desktop, it
    also showed the speaker rather than the headphone.
    
    The root cause is that before suspend, the codec already call the
    runtime_suspend since this codec is not used by any apps, then in
    resume, it will not call runtime_resume for this codec. But for some
    realtek codec (so far, alc236, alc255 and alc891) with the specific
    BIOS, if it doesn't run runtime_resume after suspend, all codec
    functions including jack detection stop working anymore.
    
    This problem existed for a long time, but it was not exposed, that is
    because when problem happens, if users play sound or open
    sound-setting to check audio device, this will trigger calling to
    runtime_resume (via snd_hda_power_up), then the codec starts working
    again before users notice this problem.
    
    Since we don't know how many codec and BIOS combinations have this
    problem, to fix it, let the driver call runtime_resume for all codecs
    in pm_resume, maybe for some codecs, this is not needed, but it is
    harmless. After a codec is runtime resumed, if it is not used by any
    apps, it will be runtime suspended soon and furthermore we don't run
    suspend frequently, this change will not add much power consumption.
    
    Fixes: cc72da7d4d06 ("ALSA: hda - Use standard runtime PM for codec power-save control")
    Signed-off-by: Hui Wang <hui.wang@canonical.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 5c622e33da8febc0de0512344cd5a35c17a7676f
Author: Hui Wang <hui.wang@canonical.com>
Date:   Tue Mar 19 09:28:44 2019 +0800

    ALSA: hda - Enforces runtime_resume after S3 and S4 for each codec
    
    commit b5a236c175b0d984552a5f7c9d35141024c2b261 upstream.
    
    Recently we found the audio jack detection stop working after suspend
    on many machines with Realtek codec. Sometimes the audio selection
    dialogue didn't show up after users plugged headhphone/headset into
    the headset jack, sometimes after uses plugged headphone/headset, then
    click the sound icon on the upper-right corner of gnome-desktop, it
    also showed the speaker rather than the headphone.
    
    The root cause is that before suspend, the codec already call the
    runtime_suspend since this codec is not used by any apps, then in
    resume, it will not call runtime_resume for this codec. But for some
    realtek codec (so far, alc236, alc255 and alc891) with the specific
    BIOS, if it doesn't run runtime_resume after suspend, all codec
    functions including jack detection stop working anymore.
    
    This problem existed for a long time, but it was not exposed, that is
    because when problem happens, if users play sound or open
    sound-setting to check audio device, this will trigger calling to
    runtime_resume (via snd_hda_power_up), then the codec starts working
    again before users notice this problem.
    
    Since we don't know how many codec and BIOS combinations have this
    problem, to fix it, let the driver call runtime_resume for all codecs
    in pm_resume, maybe for some codecs, this is not needed, but it is
    harmless. After a codec is runtime resumed, if it is not used by any
    apps, it will be runtime suspended soon and furthermore we don't run
    suspend frequently, this change will not add much power consumption.
    
    Fixes: cc72da7d4d06 ("ALSA: hda - Use standard runtime PM for codec power-save control")
    Signed-off-by: Hui Wang <hui.wang@canonical.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 9e9e3a46e69d5d3ed7e4333d9ed86486fd84ffc4
Author: Hui Wang <hui.wang@canonical.com>
Date:   Tue Mar 19 09:28:44 2019 +0800

    ALSA: hda - Enforces runtime_resume after S3 and S4 for each codec
    
    commit b5a236c175b0d984552a5f7c9d35141024c2b261 upstream.
    
    Recently we found the audio jack detection stop working after suspend
    on many machines with Realtek codec. Sometimes the audio selection
    dialogue didn't show up after users plugged headhphone/headset into
    the headset jack, sometimes after uses plugged headphone/headset, then
    click the sound icon on the upper-right corner of gnome-desktop, it
    also showed the speaker rather than the headphone.
    
    The root cause is that before suspend, the codec already call the
    runtime_suspend since this codec is not used by any apps, then in
    resume, it will not call runtime_resume for this codec. But for some
    realtek codec (so far, alc236, alc255 and alc891) with the specific
    BIOS, if it doesn't run runtime_resume after suspend, all codec
    functions including jack detection stop working anymore.
    
    This problem existed for a long time, but it was not exposed, that is
    because when problem happens, if users play sound or open
    sound-setting to check audio device, this will trigger calling to
    runtime_resume (via snd_hda_power_up), then the codec starts working
    again before users notice this problem.
    
    Since we don't know how many codec and BIOS combinations have this
    problem, to fix it, let the driver call runtime_resume for all codecs
    in pm_resume, maybe for some codecs, this is not needed, but it is
    harmless. After a codec is runtime resumed, if it is not used by any
    apps, it will be runtime suspended soon and furthermore we don't run
    suspend frequently, this change will not add much power consumption.
    
    Fixes: cc72da7d4d06 ("ALSA: hda - Use standard runtime PM for codec power-save control")
    Signed-off-by: Hui Wang <hui.wang@canonical.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 2071ac985d37efe496782c34318dbead93beb02f
Author: Jiada Wang <jiada_wang@mentor.com>
Date:   Tue Mar 12 15:51:28 2019 +0900

    PM / Domains: Avoid a potential deadlock
    
    Lockdep warns that prepare_lock and genpd->mlock can cause a deadlock
    the deadlock scenario is like following:
    First thread is probing cs2000
    cs2000_probe()
      clk_register()
        __clk_core_init()
          clk_prepare_lock()                            ----> acquires prepare_lock
            cs2000_recalc_rate()
              i2c_smbus_read_byte_data()
                rcar_i2c_master_xfer()
                  dma_request_chan()
                    rcar_dmac_of_xlate()
                      rcar_dmac_alloc_chan_resources()
                        pm_runtime_get_sync()
                          __pm_runtime_resume()
                            rpm_resume()
                              rpm_callback()
                                genpd_runtime_resume()   ----> acquires genpd->mlock
    
    Second thread is attaching any device to the same PM domain
    genpd_add_device()
      genpd_lock()                                       ----> acquires genpd->mlock
        cpg_mssr_attach_dev()
          of_clk_get_from_provider()
            __of_clk_get_from_provider()
              __clk_create_clk()
                clk_prepare_lock()                       ----> acquires prepare_lock
    
    Since currently no PM provider access genpd's critical section
    in .attach_dev, and .detach_dev callbacks, so there is no need to protect
    these two callbacks with genpd->mlock.
    This patch avoids a potential deadlock by moving out .attach_dev and .detach_dev
    from genpd->mlock, so that genpd->mlock won't be held when prepare_lock is acquired
    in .attach_dev and .detach_dev
    
    Signed-off-by: Jiada Wang <jiada_wang@mentor.com>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Tested-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Reviewed-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 3a1f2f38fb82b7a3bc7351d7e38df5a1e9c901d2
Author: Joonyoung Shim <jy0922.shim@samsung.com>
Date:   Mon Feb 18 15:34:11 2019 +0100

    ARM: exynos: Add CPU state management for Exynos542x under secure firmware
    
    Add required CPU state management done via secure monitor call for
    Exynos542x running unsed Secure Firmware.
    
    Signed-off-by: Joonyoung Shim <jy0922.shim@samsung.com>
    [mszyprow: rewrote code to use defines and sysram base address instead
     of the magic numbers, added second smc call in pm_resume, rephrased
     subject and commit message]
    Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Signed-off-by: Krzysztof Kozlowski <krzk@kernel.org>

commit e74673120b6b9497f1e044b3cf75d2fb5ed61fc3
Author: Marek Szyprowski <m.szyprowski@samsung.com>
Date:   Mon Feb 18 15:34:09 2019 +0100

    ARM: exynos: Move Exynos542x CPU state reset to pm_prepare()
    
    Reset the CPU state entry in sysram in pm_prepare() callback. That entry
    doesn't need to be reset for every suspended CPU, so make it symmetic
    with the code, which restores it in pm_resume() callback.
    
    Tested on Samsung Chromebook2 Pit (Exynos5420) and Pi (Exynos5800)
    boards.
    
    Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Signed-off-by: Krzysztof Kozlowski <krzk@kernel.org>

commit b5a236c175b0d984552a5f7c9d35141024c2b261
Author: Hui Wang <hui.wang@canonical.com>
Date:   Tue Mar 19 09:28:44 2019 +0800

    ALSA: hda - Enforces runtime_resume after S3 and S4 for each codec
    
    Recently we found the audio jack detection stop working after suspend
    on many machines with Realtek codec. Sometimes the audio selection
    dialogue didn't show up after users plugged headhphone/headset into
    the headset jack, sometimes after uses plugged headphone/headset, then
    click the sound icon on the upper-right corner of gnome-desktop, it
    also showed the speaker rather than the headphone.
    
    The root cause is that before suspend, the codec already call the
    runtime_suspend since this codec is not used by any apps, then in
    resume, it will not call runtime_resume for this codec. But for some
    realtek codec (so far, alc236, alc255 and alc891) with the specific
    BIOS, if it doesn't run runtime_resume after suspend, all codec
    functions including jack detection stop working anymore.
    
    This problem existed for a long time, but it was not exposed, that is
    because when problem happens, if users play sound or open
    sound-setting to check audio device, this will trigger calling to
    runtime_resume (via snd_hda_power_up), then the codec starts working
    again before users notice this problem.
    
    Since we don't know how many codec and BIOS combinations have this
    problem, to fix it, let the driver call runtime_resume for all codecs
    in pm_resume, maybe for some codecs, this is not needed, but it is
    harmless. After a codec is runtime resumed, if it is not used by any
    apps, it will be runtime suspended soon and furthermore we don't run
    suspend frequently, this change will not add much power consumption.
    
    Fixes: cc72da7d4d06 ("ALSA: hda - Use standard runtime PM for codec power-save control")
    Signed-off-by: Hui Wang <hui.wang@canonical.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

commit d9778b266837edcd4433e3f8b478eb5c1e4592fc
Author: Logan Gunthorpe <logang@deltatee.com>
Date:   Thu Jan 17 08:46:34 2019 -0600

    PCI: Fix __initdata issue with "pci=disable_acs_redir" parameter
    
    [ Upstream commit d2fd6e81912a665993b24dcdc1c1384a42a54f7e ]
    
    The disable_acs_redir parameter stores a pointer to the string passed to
    pci_setup().  However, the string passed to PCI setup is actually a
    temporary copy allocated in static __initdata memory.  After init, once the
    memory is freed, it is no longer valid to reference this pointer.
    
    This bug was noticed in v5.0-rc1 after a change in commit c5eb1190074c
    ("PCI / PM: Allow runtime PM without callback functions") caused
    pci_disable_acs_redir() to be called during shutdown which manifested
    as an unable to handle kernel paging request at:
    
      RIP: 0010:pci_enable_acs+0x3f/0x1e0
      Call Trace:
         pci_restore_state.part.44+0x159/0x3c0
         pci_restore_standard_config+0x33/0x40
         pci_pm_runtime_resume+0x2b/0xd0
         ? pci_restore_standard_config+0x40/0x40
         __rpm_callback+0xbc/0x1b0
         rpm_callback+0x1f/0x70
         ? pci_restore_standard_config+0x40/0x40
          rpm_resume+0x4f9/0x710
         ? pci_conf1_read+0xb6/0xf0
         ? pci_conf1_write+0xb2/0xe0
         __pm_runtime_resume+0x47/0x70
         pci_device_shutdown+0x1e/0x60
         device_shutdown+0x14a/0x1f0
         kernel_restart+0xe/0x50
         __do_sys_reboot+0x1ee/0x210
         ? __fput+0x144/0x1d0
         do_writev+0x5e/0xf0
         ? do_writev+0x5e/0xf0
         do_syscall_64+0x48/0xf0
         entry_SYSCALL_64_after_hwframe+0x44/0xa9
    
    It was also likely possible to trigger this bug when hotplugging PCI
    devices.
    
    To fix this, instead of storing a pointer, we use kstrdup() to copy the
    disable_acs_redir_param to its own buffer which will never be freed.
    
    Fixes: aaca43fda742 ("PCI: Add "pci=disable_acs_redir=" parameter for peer-to-peer support")
    Tested-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Logan Gunthorpe <logang@deltatee.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit bc5d97268c0c205cbecc3c10652991503938c9f8
Author: Logan Gunthorpe <logang@deltatee.com>
Date:   Thu Jan 17 08:46:34 2019 -0600

    PCI: Fix __initdata issue with "pci=disable_acs_redir" parameter
    
    commit d2fd6e81912a665993b24dcdc1c1384a42a54f7e upstream.
    
    The disable_acs_redir parameter stores a pointer to the string passed to
    pci_setup().  However, the string passed to PCI setup is actually a
    temporary copy allocated in static __initdata memory.  After init, once the
    memory is freed, it is no longer valid to reference this pointer.
    
    This bug was noticed in v5.0-rc1 after a change in commit c5eb1190074c
    ("PCI / PM: Allow runtime PM without callback functions") caused
    pci_disable_acs_redir() to be called during shutdown which manifested
    as an unable to handle kernel paging request at:
    
      RIP: 0010:pci_enable_acs+0x3f/0x1e0
      Call Trace:
         pci_restore_state.part.44+0x159/0x3c0
         pci_restore_standard_config+0x33/0x40
         pci_pm_runtime_resume+0x2b/0xd0
         ? pci_restore_standard_config+0x40/0x40
         __rpm_callback+0xbc/0x1b0
         rpm_callback+0x1f/0x70
         ? pci_restore_standard_config+0x40/0x40
          rpm_resume+0x4f9/0x710
         ? pci_conf1_read+0xb6/0xf0
         ? pci_conf1_write+0xb2/0xe0
         __pm_runtime_resume+0x47/0x70
         pci_device_shutdown+0x1e/0x60
         device_shutdown+0x14a/0x1f0
         kernel_restart+0xe/0x50
         __do_sys_reboot+0x1ee/0x210
         ? __fput+0x144/0x1d0
         do_writev+0x5e/0xf0
         ? do_writev+0x5e/0xf0
         do_syscall_64+0x48/0xf0
         entry_SYSCALL_64_after_hwframe+0x44/0xa9
    
    It was also likely possible to trigger this bug when hotplugging PCI
    devices.
    
    To fix this, instead of storing a pointer, we use kstrdup() to copy the
    disable_acs_redir_param to its own buffer which will never be freed.
    
    Fixes: aaca43fda742 ("PCI: Add "pci=disable_acs_redir=" parameter for peer-to-peer support")
    Tested-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Logan Gunthorpe <logang@deltatee.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 74fb44863084275b952f21ec6a024af0e2e75cb8
Author: Vincent Guittot <vincent.guittot@linaro.org>
Date:   Thu Feb 21 08:59:02 2019 +0100

    PM-runtime: Fix deadlock when canceling hrtimer
    
    When rpm_resume() desactivates the autosuspend timer, it should only
    try to cancel hrtimer but not wait for the handler to finish, because
    both rpm_resume() and pm_suspend_timer_fn() take the power.lock.
    
    A deadlock is possible as follows:
    
    CPU0                              CPU1
    rpm_resume()
      spin_lock_irqsave
                                      pm_suspend_timer_fn()
                                        spin_lock_irqsave
      pm_runtime_deactivate_timer()
        hrtimer_cancel()
    
    It is sufficient to call hrtimer_try_to_cancel() from
    pm_runtime_deactivate_timer(), because dev->power.timer_expires
    reset to 0 by it, so use that function instead of hrtimer_cancel().
    
    Fixes: 8234f6734c5d ("PM-runtime: Switch autosuspend over to using hrtimers")
    Reported-by: Sunzhaosheng Sun(Zhaosheng) <sunzhaosheng@hisilicon.com>
    Signed-off-by: Vincent Guittot <vincent.guittot@linaro.org>
    [ rjw: Changelog ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit c155f6499f9797f200aa46eb3ccbf198f4206970
Author: Vincent Guittot <vincent.guittot@linaro.org>
Date:   Mon Feb 4 17:25:52 2019 +0100

    PM-runtime: Switch accounting over to ktime_get_mono_fast_ns()
    
    Similar to what happened whith autosuspend, a deadlock has been
    reported with PM-runtime accounting in the call path:
    
    change_clocksource
        ...
        write_seqcount_begin
        ...
        timekeeping_update
            ...
            sh_cmt_clocksource_enable
                ...
                rpm_resume
                    update_pm_runtime_accounting
                        ktime_get
                            do
                                read_seqcount_begin
                            while read_seqcount_retry
        ....
        write_seqcount_end
    
    Make PM-runtime accounting use ktime_get_mono_fast_ns() to avoid this
    problem.
    
    With ktime_get_mono_fast_ns(), the timestamp is not guaranteed to be
    monotonic across an update of timekeeping and as a result time can go
    backward. Add a test to skip accounting for such situation which should
    stay exceptional.
    
    Fixes: a08c2a5a3194 ("PM-runtime: Replace jiffies-based accounting with ktime-based accounting")
    Reported-by: Biju Das <biju.das@bp.renesas.com>
    Signed-off-by: Vincent Guittot <vincent.guittot@linaro.org>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    [ rjw: Subject, changelog, comment cleanup ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit e2f3cd831a280fc226118d9369bf3f77aab58c56
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Feb 1 01:49:14 2019 +0100

    driver core: Fix handling of runtime PM flags in device_link_add()
    
    After commit ead18c23c263 ("driver core: Introduce device links
    reference counting"), if there is a link between the given supplier
    and the given consumer already, device_link_add() will refcount it
    and return it unconditionally without updating its flags.  It is
    possible, however, that the second (or any subsequent) caller of
    device_link_add() for the same consumer-supplier pair will pass
    DL_FLAG_PM_RUNTIME, possibly along with DL_FLAG_RPM_ACTIVE, in flags
    to it and the existing link may not behave as expected then.
    
    First, if DL_FLAG_PM_RUNTIME is not set in the existing link's flags
    at all, it needs to be set like during the original initialization of
    the link.
    
    Second, if DL_FLAG_RPM_ACTIVE is passed to device_link_add() in flags
    (in addition to DL_FLAG_PM_RUNTIME), the existing link should to be
    updated to reflect the "active" runtime PM configuration of the
    consumer-supplier pair and extra care must be taken here to avoid
    possible destructive races with runtime PM of the consumer.
    
    To that end, redefine the rpm_active field in struct device_link
    as a refcount, initialize it to 1 and make rpm_resume() (for the
    consumer) and device_link_add() increment it whenever they acquire
    a runtime PM reference on the supplier device.  Accordingly, make
    rpm_suspend() (for the consumer) and pm_runtime_clean_up_links()
    decrement it and drop runtime PM references to the supplier
    device in a loop until rpm_active becones 1 again.
    
    Fixes: ead18c23c263 ("driver core: Introduce device links reference counting")
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 15efb47dc560849d0c07db96fdad5121f2cf736e
Author: Vincent Guittot <vincent.guittot@linaro.org>
Date:   Wed Jan 30 18:26:02 2019 +0100

    PM-runtime: Fix deadlock with ktime_get()
    
    A deadlock has been seen when swicthing clocksources which use
    PM-runtime.  The call path is:
    
    change_clocksource
        ...
        write_seqcount_begin
        ...
        timekeeping_update
            ...
            sh_cmt_clocksource_enable
                ...
                rpm_resume
                    pm_runtime_mark_last_busy
                        ktime_get
                            do
                                read_seqcount_begin
                            while read_seqcount_retry
        ....
        write_seqcount_end
    
    Although we should be safe because we haven't yet changed the
    clocksource at that time, we can't do that because of seqcount
    protection.
    
    Use ktime_get_mono_fast_ns() instead which is lock safe for such
    cases.
    
    With ktime_get_mono_fast_ns, the timestamp is not guaranteed to be
    monotonic across an update and as a result can goes backward.
    According to update_fast_timekeeper() description: "In the worst
    case, this can result is a slightly wrong timestamp (a few
    nanoseconds)". For PM-runtime autosuspend, this means only that
    the suspend decision may be slightly suboptimal.
    
    Fixes: 8234f6734c5d ("PM-runtime: Switch autosuspend over to using hrtimers")
    Reported-by: Biju Das <biju.das@bp.renesas.com>
    Signed-off-by: Vincent Guittot <vincent.guittot@linaro.org>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 81d696c7c4ff8c981333159d072da65268bfe6d5
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Tue Jan 22 11:03:57 2019 +0100

    i2c: rcar: Fix clients using i2c from suspend callback
    
    When doing s2idle/s2ram on Salvator-X(S):
    
        WARNING: CPU: 2 PID: 971 at drivers/i2c/i2c-core-base.c:1869 __i2c_transfer+0x608/0x910
    [...]
        Call trace:
         __i2c_transfer+0x608/0x910
         i2c_smbus_xfer_emulated+0x158/0x5b0
         __i2c_smbus_xfer+0x17c/0x818
         i2c_smbus_xfer+0x64/0x98
         i2c_smbus_read_byte_data+0x40/0x70
         cs2000_bset.isra.1+0x2c/0x68
         __cs2000_set_rate.constprop.7+0x80/0x148
         cs2000_resume+0x18/0x20
         dpm_run_callback+0x74/0x330
         device_resume_early+0xd4/0x120
         dpm_resume_early+0x158/0x4f8
         suspend_devices_and_enter+0x36c/0xd98
    [...]
    
    On second resume, the sound driver fails with:
    
        cs2000-cp 2-004f: pll lock failed
        rcar_sound ec500000.sound: can't use clk 1
    
    As the CS2000 clock driver needs to send I2C messages during suspend,
    the I2C controller driver should be suspended later, and resumed
    earlier.  Fix this by using the noirq sleep ops instead of the normal
    sleep ops, which are called after the late sleep ops, as used by the
    CS2000 clock driver.
    
    Fixes: 18569fa89a4db9ed ("i2c: rcar: add suspend/resume support")
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

commit d2fd6e81912a665993b24dcdc1c1384a42a54f7e
Author: Logan Gunthorpe <logang@deltatee.com>
Date:   Thu Jan 17 08:46:34 2019 -0600

    PCI: Fix __initdata issue with "pci=disable_acs_redir" parameter
    
    The disable_acs_redir parameter stores a pointer to the string passed to
    pci_setup().  However, the string passed to PCI setup is actually a
    temporary copy allocated in static __initdata memory.  After init, once the
    memory is freed, it is no longer valid to reference this pointer.
    
    This bug was noticed in v5.0-rc1 after a change in commit c5eb1190074c
    ("PCI / PM: Allow runtime PM without callback functions") caused
    pci_disable_acs_redir() to be called during shutdown which manifested
    as an unable to handle kernel paging request at:
    
      RIP: 0010:pci_enable_acs+0x3f/0x1e0
      Call Trace:
         pci_restore_state.part.44+0x159/0x3c0
         pci_restore_standard_config+0x33/0x40
         pci_pm_runtime_resume+0x2b/0xd0
         ? pci_restore_standard_config+0x40/0x40
         __rpm_callback+0xbc/0x1b0
         rpm_callback+0x1f/0x70
         ? pci_restore_standard_config+0x40/0x40
          rpm_resume+0x4f9/0x710
         ? pci_conf1_read+0xb6/0xf0
         ? pci_conf1_write+0xb2/0xe0
         __pm_runtime_resume+0x47/0x70
         pci_device_shutdown+0x1e/0x60
         device_shutdown+0x14a/0x1f0
         kernel_restart+0xe/0x50
         __do_sys_reboot+0x1ee/0x210
         ? __fput+0x144/0x1d0
         do_writev+0x5e/0xf0
         ? do_writev+0x5e/0xf0
         do_syscall_64+0x48/0xf0
         entry_SYSCALL_64_after_hwframe+0x44/0xa9
    
    It was also likely possible to trigger this bug when hotplugging PCI
    devices.
    
    To fix this, instead of storing a pointer, we use kstrdup() to copy the
    disable_acs_redir_param to its own buffer which will never be freed.
    
    Fixes: aaca43fda742 ("PCI: Add "pci=disable_acs_redir=" parameter for peer-to-peer support")
    Tested-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Logan Gunthorpe <logang@deltatee.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>

commit b2b83523b1768828c3122a2862fa0dd88fb40489
Author: Bruce Wang <bzwang@chromium.org>
Date:   Fri Oct 5 17:04:00 2018 -0400

    drm/msm/dpu: Remove dpu_kms_pm_suspend/resume
    
    PM resume was crashing during dpu_kms_pm_resume. This patch removes
    dpu_kms_pm_suspend/resume so that msm_pm_suspend/resume uses the atomic
    helpers instead (see next patch). This patch also removes
    dpu_kms_is_suspend_blocked since it is never called.
    
    v2: Reorganized patches in patchset
    
    Signed-off-by: Bruce Wang <bzwang@chromium.org>
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

commit 42387d8e4aefffe928e1a4ec99c45e6e2c4d2167
Author: Lyude Paul <lyude@redhat.com>
Date:   Wed Aug 15 15:00:15 2018 -0400

    drm/nouveau: Fix deadlocks in nouveau_connector_detect()
    
    commit 3e1a12754d4df5804bfca5dedf09d2ba291bdc2a upstream.
    
    When we disable hotplugging on the GPU, we need to be able to
    synchronize with each connector's hotplug interrupt handler before the
    interrupt is finally disabled. This can be a problem however, since
    nouveau_connector_detect() currently grabs a runtime power reference
    when handling connector probing. This will deadlock the runtime suspend
    handler like so:
    
    [  861.480896] INFO: task kworker/0:2:61 blocked for more than 120 seconds.
    [  861.483290]       Tainted: G           O      4.18.0-rc6Lyude-Test+ #1
    [  861.485158] "echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
    [  861.486332] kworker/0:2     D    0    61      2 0x80000000
    [  861.487044] Workqueue: events nouveau_display_hpd_work [nouveau]
    [  861.487737] Call Trace:
    [  861.488394]  __schedule+0x322/0xaf0
    [  861.489070]  schedule+0x33/0x90
    [  861.489744]  rpm_resume+0x19c/0x850
    [  861.490392]  ? finish_wait+0x90/0x90
    [  861.491068]  __pm_runtime_resume+0x4e/0x90
    [  861.491753]  nouveau_display_hpd_work+0x22/0x60 [nouveau]
    [  861.492416]  process_one_work+0x231/0x620
    [  861.493068]  worker_thread+0x44/0x3a0
    [  861.493722]  kthread+0x12b/0x150
    [  861.494342]  ? wq_pool_ids_show+0x140/0x140
    [  861.494991]  ? kthread_create_worker_on_cpu+0x70/0x70
    [  861.495648]  ret_from_fork+0x3a/0x50
    [  861.496304] INFO: task kworker/6:2:320 blocked for more than 120 seconds.
    [  861.496968]       Tainted: G           O      4.18.0-rc6Lyude-Test+ #1
    [  861.497654] "echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
    [  861.498341] kworker/6:2     D    0   320      2 0x80000080
    [  861.499045] Workqueue: pm pm_runtime_work
    [  861.499739] Call Trace:
    [  861.500428]  __schedule+0x322/0xaf0
    [  861.501134]  ? wait_for_completion+0x104/0x190
    [  861.501851]  schedule+0x33/0x90
    [  861.502564]  schedule_timeout+0x3a5/0x590
    [  861.503284]  ? mark_held_locks+0x58/0x80
    [  861.503988]  ? _raw_spin_unlock_irq+0x2c/0x40
    [  861.504710]  ? wait_for_completion+0x104/0x190
    [  861.505417]  ? trace_hardirqs_on_caller+0xf4/0x190
    [  861.506136]  ? wait_for_completion+0x104/0x190
    [  861.506845]  wait_for_completion+0x12c/0x190
    [  861.507555]  ? wake_up_q+0x80/0x80
    [  861.508268]  flush_work+0x1c9/0x280
    [  861.508990]  ? flush_workqueue_prep_pwqs+0x1b0/0x1b0
    [  861.509735]  nvif_notify_put+0xb1/0xc0 [nouveau]
    [  861.510482]  nouveau_display_fini+0xbd/0x170 [nouveau]
    [  861.511241]  nouveau_display_suspend+0x67/0x120 [nouveau]
    [  861.511969]  nouveau_do_suspend+0x5e/0x2d0 [nouveau]
    [  861.512715]  nouveau_pmops_runtime_suspend+0x47/0xb0 [nouveau]
    [  861.513435]  pci_pm_runtime_suspend+0x6b/0x180
    [  861.514165]  ? pci_has_legacy_pm_support+0x70/0x70
    [  861.514897]  __rpm_callback+0x7a/0x1d0
    [  861.515618]  ? pci_has_legacy_pm_support+0x70/0x70
    [  861.516313]  rpm_callback+0x24/0x80
    [  861.517027]  ? pci_has_legacy_pm_support+0x70/0x70
    [  861.517741]  rpm_suspend+0x142/0x6b0
    [  861.518449]  pm_runtime_work+0x97/0xc0
    [  861.519144]  process_one_work+0x231/0x620
    [  861.519831]  worker_thread+0x44/0x3a0
    [  861.520522]  kthread+0x12b/0x150
    [  861.521220]  ? wq_pool_ids_show+0x140/0x140
    [  861.521925]  ? kthread_create_worker_on_cpu+0x70/0x70
    [  861.522622]  ret_from_fork+0x3a/0x50
    [  861.523299] INFO: task kworker/6:0:1329 blocked for more than 120 seconds.
    [  861.523977]       Tainted: G           O      4.18.0-rc6Lyude-Test+ #1
    [  861.524644] "echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
    [  861.525349] kworker/6:0     D    0  1329      2 0x80000000
    [  861.526073] Workqueue: events nvif_notify_work [nouveau]
    [  861.526751] Call Trace:
    [  861.527411]  __schedule+0x322/0xaf0
    [  861.528089]  schedule+0x33/0x90
    [  861.528758]  rpm_resume+0x19c/0x850
    [  861.529399]  ? finish_wait+0x90/0x90
    [  861.530073]  __pm_runtime_resume+0x4e/0x90
    [  861.530798]  nouveau_connector_detect+0x7e/0x510 [nouveau]
    [  861.531459]  ? ww_mutex_lock+0x47/0x80
    [  861.532097]  ? ww_mutex_lock+0x47/0x80
    [  861.532819]  ? drm_modeset_lock+0x88/0x130 [drm]
    [  861.533481]  drm_helper_probe_detect_ctx+0xa0/0x100 [drm_kms_helper]
    [  861.534127]  drm_helper_hpd_irq_event+0xa4/0x120 [drm_kms_helper]
    [  861.534940]  nouveau_connector_hotplug+0x98/0x120 [nouveau]
    [  861.535556]  nvif_notify_work+0x2d/0xb0 [nouveau]
    [  861.536221]  process_one_work+0x231/0x620
    [  861.536994]  worker_thread+0x44/0x3a0
    [  861.537757]  kthread+0x12b/0x150
    [  861.538463]  ? wq_pool_ids_show+0x140/0x140
    [  861.539102]  ? kthread_create_worker_on_cpu+0x70/0x70
    [  861.539815]  ret_from_fork+0x3a/0x50
    [  861.540521]
                   Showing all locks held in the system:
    [  861.541696] 2 locks held by kworker/0:2/61:
    [  861.542406]  #0: 000000002dbf8af5 ((wq_completion)"events"){+.+.}, at: process_one_work+0x1b3/0x620
    [  861.543071]  #1: 0000000076868126 ((work_completion)(&drm->hpd_work)){+.+.}, at: process_one_work+0x1b3/0x620
    [  861.543814] 1 lock held by khungtaskd/64:
    [  861.544535]  #0: 0000000059db4b53 (rcu_read_lock){....}, at: debug_show_all_locks+0x23/0x185
    [  861.545160] 3 locks held by kworker/6:2/320:
    [  861.545896]  #0: 00000000d9e1bc59 ((wq_completion)"pm"){+.+.}, at: process_one_work+0x1b3/0x620
    [  861.546702]  #1: 00000000c9f92d84 ((work_completion)(&dev->power.work)){+.+.}, at: process_one_work+0x1b3/0x620
    [  861.547443]  #2: 000000004afc5de1 (drm_connector_list_iter){.+.+}, at: nouveau_display_fini+0x96/0x170 [nouveau]
    [  861.548146] 1 lock held by dmesg/983:
    [  861.548889] 2 locks held by zsh/1250:
    [  861.549605]  #0: 00000000348e3cf6 (&tty->ldisc_sem){++++}, at: ldsem_down_read+0x37/0x40
    [  861.550393]  #1: 000000007009a7a8 (&ldata->atomic_read_lock){+.+.}, at: n_tty_read+0xc1/0x870
    [  861.551122] 6 locks held by kworker/6:0/1329:
    [  861.551957]  #0: 000000002dbf8af5 ((wq_completion)"events"){+.+.}, at: process_one_work+0x1b3/0x620
    [  861.552765]  #1: 00000000ddb499ad ((work_completion)(&notify->work)#2){+.+.}, at: process_one_work+0x1b3/0x620
    [  861.553582]  #2: 000000006e013cbe (&dev->mode_config.mutex){+.+.}, at: drm_helper_hpd_irq_event+0x6c/0x120 [drm_kms_helper]
    [  861.554357]  #3: 000000004afc5de1 (drm_connector_list_iter){.+.+}, at: drm_helper_hpd_irq_event+0x78/0x120 [drm_kms_helper]
    [  861.555227]  #4: 0000000044f294d9 (crtc_ww_class_acquire){+.+.}, at: drm_helper_probe_detect_ctx+0x3d/0x100 [drm_kms_helper]
    [  861.556133]  #5: 00000000db193642 (crtc_ww_class_mutex){+.+.}, at: drm_modeset_lock+0x4b/0x130 [drm]
    
    [  861.557864] =============================================
    
    [  861.559507] NMI backtrace for cpu 2
    [  861.560363] CPU: 2 PID: 64 Comm: khungtaskd Tainted: G           O      4.18.0-rc6Lyude-Test+ #1
    [  861.561197] Hardware name: LENOVO 20EQS64N0B/20EQS64N0B, BIOS N1EET78W (1.51 ) 05/18/2018
    [  861.561948] Call Trace:
    [  861.562757]  dump_stack+0x8e/0xd3
    [  861.563516]  nmi_cpu_backtrace.cold.3+0x14/0x5a
    [  861.564269]  ? lapic_can_unplug_cpu.cold.27+0x42/0x42
    [  861.565029]  nmi_trigger_cpumask_backtrace+0xa1/0xae
    [  861.565789]  arch_trigger_cpumask_backtrace+0x19/0x20
    [  861.566558]  watchdog+0x316/0x580
    [  861.567355]  kthread+0x12b/0x150
    [  861.568114]  ? reset_hung_task_detector+0x20/0x20
    [  861.568863]  ? kthread_create_worker_on_cpu+0x70/0x70
    [  861.569598]  ret_from_fork+0x3a/0x50
    [  861.570370] Sending NMI from CPU 2 to CPUs 0-1,3-7:
    [  861.571426] NMI backtrace for cpu 6 skipped: idling at intel_idle+0x7f/0x120
    [  861.571429] NMI backtrace for cpu 7 skipped: idling at intel_idle+0x7f/0x120
    [  861.571432] NMI backtrace for cpu 3 skipped: idling at intel_idle+0x7f/0x120
    [  861.571464] NMI backtrace for cpu 5 skipped: idling at intel_idle+0x7f/0x120
    [  861.571467] NMI backtrace for cpu 0 skipped: idling at intel_idle+0x7f/0x120
    [  861.571469] NMI backtrace for cpu 4 skipped: idling at intel_idle+0x7f/0x120
    [  861.571472] NMI backtrace for cpu 1 skipped: idling at intel_idle+0x7f/0x120
    [  861.572428] Kernel panic - not syncing: hung_task: blocked tasks
    
    So: fix this by making it so that normal hotplug handling /only/ happens
    so long as the GPU is currently awake without any pending runtime PM
    requests. In the event that a hotplug occurs while the device is
    suspending or resuming, we can simply defer our response until the GPU
    is fully runtime resumed again.
    
    Changes since v4:
    - Use a new trick I came up with using pm_runtime_get() instead of the
      hackish junk we had before
    
    Signed-off-by: Lyude Paul <lyude@redhat.com>
    Reviewed-by: Karol Herbst <kherbst@redhat.com>
    Acked-by: Daniel Vetter <daniel@ffwll.ch>
    Cc: stable@vger.kernel.org
    Cc: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 9c7443a7aa646327acbaa02d16e7f7858e4e886c
Author: Lyude Paul <lyude@redhat.com>
Date:   Wed Aug 15 15:00:13 2018 -0400

    drm/nouveau/drm/nouveau: Fix deadlock with fb_helper with async RPM requests
    
    commit 7fec8f5379fb6eddabc0aaef6d2304c366808f97 upstream.
    
    Currently, nouveau uses the generic drm_fb_helper_output_poll_changed()
    function provided by DRM as it's output_poll_changed callback.
    Unfortunately however, this function doesn't grab runtime PM references
    early enough and even if it did-we can't block waiting for the device to
    resume in output_poll_changed() since it's very likely that we'll need
    to grab the fb_helper lock at some point during the runtime resume
    process. This currently results in deadlocking like so:
    
    [  246.669625] INFO: task kworker/4:0:37 blocked for more than 120 seconds.
    [  246.673398]       Not tainted 4.18.0-rc5Lyude-Test+ #2
    [  246.675271] "echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
    [  246.676527] kworker/4:0     D    0    37      2 0x80000000
    [  246.677580] Workqueue: events output_poll_execute [drm_kms_helper]
    [  246.678704] Call Trace:
    [  246.679753]  __schedule+0x322/0xaf0
    [  246.680916]  schedule+0x33/0x90
    [  246.681924]  schedule_preempt_disabled+0x15/0x20
    [  246.683023]  __mutex_lock+0x569/0x9a0
    [  246.684035]  ? kobject_uevent_env+0x117/0x7b0
    [  246.685132]  ? drm_fb_helper_hotplug_event.part.28+0x20/0xb0 [drm_kms_helper]
    [  246.686179]  mutex_lock_nested+0x1b/0x20
    [  246.687278]  ? mutex_lock_nested+0x1b/0x20
    [  246.688307]  drm_fb_helper_hotplug_event.part.28+0x20/0xb0 [drm_kms_helper]
    [  246.689420]  drm_fb_helper_output_poll_changed+0x23/0x30 [drm_kms_helper]
    [  246.690462]  drm_kms_helper_hotplug_event+0x2a/0x30 [drm_kms_helper]
    [  246.691570]  output_poll_execute+0x198/0x1c0 [drm_kms_helper]
    [  246.692611]  process_one_work+0x231/0x620
    [  246.693725]  worker_thread+0x214/0x3a0
    [  246.694756]  kthread+0x12b/0x150
    [  246.695856]  ? wq_pool_ids_show+0x140/0x140
    [  246.696888]  ? kthread_create_worker_on_cpu+0x70/0x70
    [  246.697998]  ret_from_fork+0x3a/0x50
    [  246.699034] INFO: task kworker/0:1:60 blocked for more than 120 seconds.
    [  246.700153]       Not tainted 4.18.0-rc5Lyude-Test+ #2
    [  246.701182] "echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
    [  246.702278] kworker/0:1     D    0    60      2 0x80000000
    [  246.703293] Workqueue: pm pm_runtime_work
    [  246.704393] Call Trace:
    [  246.705403]  __schedule+0x322/0xaf0
    [  246.706439]  ? wait_for_completion+0x104/0x190
    [  246.707393]  schedule+0x33/0x90
    [  246.708375]  schedule_timeout+0x3a5/0x590
    [  246.709289]  ? mark_held_locks+0x58/0x80
    [  246.710208]  ? _raw_spin_unlock_irq+0x2c/0x40
    [  246.711222]  ? wait_for_completion+0x104/0x190
    [  246.712134]  ? trace_hardirqs_on_caller+0xf4/0x190
    [  246.713094]  ? wait_for_completion+0x104/0x190
    [  246.713964]  wait_for_completion+0x12c/0x190
    [  246.714895]  ? wake_up_q+0x80/0x80
    [  246.715727]  ? get_work_pool+0x90/0x90
    [  246.716649]  flush_work+0x1c9/0x280
    [  246.717483]  ? flush_workqueue_prep_pwqs+0x1b0/0x1b0
    [  246.718442]  __cancel_work_timer+0x146/0x1d0
    [  246.719247]  cancel_delayed_work_sync+0x13/0x20
    [  246.720043]  drm_kms_helper_poll_disable+0x1f/0x30 [drm_kms_helper]
    [  246.721123]  nouveau_pmops_runtime_suspend+0x3d/0xb0 [nouveau]
    [  246.721897]  pci_pm_runtime_suspend+0x6b/0x190
    [  246.722825]  ? pci_has_legacy_pm_support+0x70/0x70
    [  246.723737]  __rpm_callback+0x7a/0x1d0
    [  246.724721]  ? pci_has_legacy_pm_support+0x70/0x70
    [  246.725607]  rpm_callback+0x24/0x80
    [  246.726553]  ? pci_has_legacy_pm_support+0x70/0x70
    [  246.727376]  rpm_suspend+0x142/0x6b0
    [  246.728185]  pm_runtime_work+0x97/0xc0
    [  246.728938]  process_one_work+0x231/0x620
    [  246.729796]  worker_thread+0x44/0x3a0
    [  246.730614]  kthread+0x12b/0x150
    [  246.731395]  ? wq_pool_ids_show+0x140/0x140
    [  246.732202]  ? kthread_create_worker_on_cpu+0x70/0x70
    [  246.732878]  ret_from_fork+0x3a/0x50
    [  246.733768] INFO: task kworker/4:2:422 blocked for more than 120 seconds.
    [  246.734587]       Not tainted 4.18.0-rc5Lyude-Test+ #2
    [  246.735393] "echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
    [  246.736113] kworker/4:2     D    0   422      2 0x80000080
    [  246.736789] Workqueue: events_long drm_dp_mst_link_probe_work [drm_kms_helper]
    [  246.737665] Call Trace:
    [  246.738490]  __schedule+0x322/0xaf0
    [  246.739250]  schedule+0x33/0x90
    [  246.739908]  rpm_resume+0x19c/0x850
    [  246.740750]  ? finish_wait+0x90/0x90
    [  246.741541]  __pm_runtime_resume+0x4e/0x90
    [  246.742370]  nv50_disp_atomic_commit+0x31/0x210 [nouveau]
    [  246.743124]  drm_atomic_commit+0x4a/0x50 [drm]
    [  246.743775]  restore_fbdev_mode_atomic+0x1c8/0x240 [drm_kms_helper]
    [  246.744603]  restore_fbdev_mode+0x31/0x140 [drm_kms_helper]
    [  246.745373]  drm_fb_helper_restore_fbdev_mode_unlocked+0x54/0xb0 [drm_kms_helper]
    [  246.746220]  drm_fb_helper_set_par+0x2d/0x50 [drm_kms_helper]
    [  246.746884]  drm_fb_helper_hotplug_event.part.28+0x96/0xb0 [drm_kms_helper]
    [  246.747675]  drm_fb_helper_output_poll_changed+0x23/0x30 [drm_kms_helper]
    [  246.748544]  drm_kms_helper_hotplug_event+0x2a/0x30 [drm_kms_helper]
    [  246.749439]  nv50_mstm_hotplug+0x15/0x20 [nouveau]
    [  246.750111]  drm_dp_send_link_address+0x177/0x1c0 [drm_kms_helper]
    [  246.750764]  drm_dp_check_and_send_link_address+0xa8/0xd0 [drm_kms_helper]
    [  246.751602]  drm_dp_mst_link_probe_work+0x51/0x90 [drm_kms_helper]
    [  246.752314]  process_one_work+0x231/0x620
    [  246.752979]  worker_thread+0x44/0x3a0
    [  246.753838]  kthread+0x12b/0x150
    [  246.754619]  ? wq_pool_ids_show+0x140/0x140
    [  246.755386]  ? kthread_create_worker_on_cpu+0x70/0x70
    [  246.756162]  ret_from_fork+0x3a/0x50
    [  246.756847]
               Showing all locks held in the system:
    [  246.758261] 3 locks held by kworker/4:0/37:
    [  246.759016]  #0: 00000000f8df4d2d ((wq_completion)"events"){+.+.}, at: process_one_work+0x1b3/0x620
    [  246.759856]  #1: 00000000e6065461 ((work_completion)(&(&dev->mode_config.output_poll_work)->work)){+.+.}, at: process_one_work+0x1b3/0x620
    [  246.760670]  #2: 00000000cb66735f (&helper->lock){+.+.}, at: drm_fb_helper_hotplug_event.part.28+0x20/0xb0 [drm_kms_helper]
    [  246.761516] 2 locks held by kworker/0:1/60:
    [  246.762274]  #0: 00000000fff6be0f ((wq_completion)"pm"){+.+.}, at: process_one_work+0x1b3/0x620
    [  246.762982]  #1: 000000005ab44fb4 ((work_completion)(&dev->power.work)){+.+.}, at: process_one_work+0x1b3/0x620
    [  246.763890] 1 lock held by khungtaskd/64:
    [  246.764664]  #0: 000000008cb8b5c3 (rcu_read_lock){....}, at: debug_show_all_locks+0x23/0x185
    [  246.765588] 5 locks held by kworker/4:2/422:
    [  246.766440]  #0: 00000000232f0959 ((wq_completion)"events_long"){+.+.}, at: process_one_work+0x1b3/0x620
    [  246.767390]  #1: 00000000bb59b134 ((work_completion)(&mgr->work)){+.+.}, at: process_one_work+0x1b3/0x620
    [  246.768154]  #2: 00000000cb66735f (&helper->lock){+.+.}, at: drm_fb_helper_restore_fbdev_mode_unlocked+0x4c/0xb0 [drm_kms_helper]
    [  246.768966]  #3: 000000004c8f0b6b (crtc_ww_class_acquire){+.+.}, at: restore_fbdev_mode_atomic+0x4b/0x240 [drm_kms_helper]
    [  246.769921]  #4: 000000004c34a296 (crtc_ww_class_mutex){+.+.}, at: drm_modeset_backoff+0x8a/0x1b0 [drm]
    [  246.770839] 1 lock held by dmesg/1038:
    [  246.771739] 2 locks held by zsh/1172:
    [  246.772650]  #0: 00000000836d0438 (&tty->ldisc_sem){++++}, at: ldsem_down_read+0x37/0x40
    [  246.773680]  #1: 000000001f4f4d48 (&ldata->atomic_read_lock){+.+.}, at: n_tty_read+0xc1/0x870
    
    [  246.775522] =============================================
    
    After trying dozens of different solutions, I found one very simple one
    that should also have the benefit of preventing us from having to fight
    locking for the rest of our lives. So, we work around these deadlocks by
    deferring all fbcon hotplug events that happen after the runtime suspend
    process starts until after the device is resumed again.
    
    Changes since v7:
     - Fixup commit message - Daniel Vetter
    
    Changes since v6:
     - Remove unused nouveau_fbcon_hotplugged_in_suspend() - Ilia
    
    Changes since v5:
     - Come up with the (hopefully final) solution for solving this dumb
       problem, one that is a lot less likely to cause issues with locking in
       the future. This should work around all deadlock conditions with fbcon
       brought up thus far.
    
    Changes since v4:
     - Add nouveau_fbcon_hotplugged_in_suspend() to workaround deadlock
       condition that Lukas described
     - Just move all of this out of drm_fb_helper. It seems that other DRM
       drivers have already figured out other workarounds for this. If other
       drivers do end up needing this in the future, we can just move this
       back into drm_fb_helper again.
    
    Changes since v3:
    - Actually check if fb_helper is NULL in both new helpers
    - Actually check drm_fbdev_emulation in both new helpers
    - Don't fire off a fb_helper hotplug unconditionally; only do it if
      the following conditions are true (as otherwise, calling this in the
      wrong spot will cause Bad Things to happen):
      - fb_helper hotplug handling was actually inhibited previously
      - fb_helper actually has a delayed hotplug pending
      - fb_helper is actually bound
      - fb_helper is actually initialized
    - Add __must_check to drm_fb_helper_suspend_hotplug(). There's no
      situation where a driver would actually want to use this without
      checking the return value, so enforce that
    - Rewrite and clarify the documentation for both helpers.
    - Make sure to return true in the drm_fb_helper_suspend_hotplug() stub
      that's provided in drm_fb_helper.h when CONFIG_DRM_FBDEV_EMULATION
      isn't enabled
    - Actually grab the toplevel fb_helper lock in
      drm_fb_helper_resume_hotplug(), since it's possible other activity
      (such as a hotplug) could be going on at the same time the driver
      calls drm_fb_helper_resume_hotplug(). We need this to check whether or
      not drm_fb_helper_hotplug_event() needs to be called anyway
    
    Signed-off-by: Lyude Paul <lyude@redhat.com>
    Reviewed-by: Karol Herbst <kherbst@redhat.com>
    Acked-by: Daniel Vetter <daniel@ffwll.ch>
    Cc: stable@vger.kernel.org
    Cc: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 86393a7e3315aa0a57e66857880a8536bab070c8
Author: Lyude Paul <lyude@redhat.com>
Date:   Wed Aug 15 15:00:15 2018 -0400

    drm/nouveau: Fix deadlocks in nouveau_connector_detect()
    
    commit 3e1a12754d4df5804bfca5dedf09d2ba291bdc2a upstream.
    
    When we disable hotplugging on the GPU, we need to be able to
    synchronize with each connector's hotplug interrupt handler before the
    interrupt is finally disabled. This can be a problem however, since
    nouveau_connector_detect() currently grabs a runtime power reference
    when handling connector probing. This will deadlock the runtime suspend
    handler like so:
    
    [  861.480896] INFO: task kworker/0:2:61 blocked for more than 120 seconds.
    [  861.483290]       Tainted: G           O      4.18.0-rc6Lyude-Test+ #1
    [  861.485158] "echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
    [  861.486332] kworker/0:2     D    0    61      2 0x80000000
    [  861.487044] Workqueue: events nouveau_display_hpd_work [nouveau]
    [  861.487737] Call Trace:
    [  861.488394]  __schedule+0x322/0xaf0
    [  861.489070]  schedule+0x33/0x90
    [  861.489744]  rpm_resume+0x19c/0x850
    [  861.490392]  ? finish_wait+0x90/0x90
    [  861.491068]  __pm_runtime_resume+0x4e/0x90
    [  861.491753]  nouveau_display_hpd_work+0x22/0x60 [nouveau]
    [  861.492416]  process_one_work+0x231/0x620
    [  861.493068]  worker_thread+0x44/0x3a0
    [  861.493722]  kthread+0x12b/0x150
    [  861.494342]  ? wq_pool_ids_show+0x140/0x140
    [  861.494991]  ? kthread_create_worker_on_cpu+0x70/0x70
    [  861.495648]  ret_from_fork+0x3a/0x50
    [  861.496304] INFO: task kworker/6:2:320 blocked for more than 120 seconds.
    [  861.496968]       Tainted: G           O      4.18.0-rc6Lyude-Test+ #1
    [  861.497654] "echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
    [  861.498341] kworker/6:2     D    0   320      2 0x80000080
    [  861.499045] Workqueue: pm pm_runtime_work
    [  861.499739] Call Trace:
    [  861.500428]  __schedule+0x322/0xaf0
    [  861.501134]  ? wait_for_completion+0x104/0x190
    [  861.501851]  schedule+0x33/0x90
    [  861.502564]  schedule_timeout+0x3a5/0x590
    [  861.503284]  ? mark_held_locks+0x58/0x80
    [  861.503988]  ? _raw_spin_unlock_irq+0x2c/0x40
    [  861.504710]  ? wait_for_completion+0x104/0x190
    [  861.505417]  ? trace_hardirqs_on_caller+0xf4/0x190
    [  861.506136]  ? wait_for_completion+0x104/0x190
    [  861.506845]  wait_for_completion+0x12c/0x190
    [  861.507555]  ? wake_up_q+0x80/0x80
    [  861.508268]  flush_work+0x1c9/0x280
    [  861.508990]  ? flush_workqueue_prep_pwqs+0x1b0/0x1b0
    [  861.509735]  nvif_notify_put+0xb1/0xc0 [nouveau]
    [  861.510482]  nouveau_display_fini+0xbd/0x170 [nouveau]
    [  861.511241]  nouveau_display_suspend+0x67/0x120 [nouveau]
    [  861.511969]  nouveau_do_suspend+0x5e/0x2d0 [nouveau]
    [  861.512715]  nouveau_pmops_runtime_suspend+0x47/0xb0 [nouveau]
    [  861.513435]  pci_pm_runtime_suspend+0x6b/0x180
    [  861.514165]  ? pci_has_legacy_pm_support+0x70/0x70
    [  861.514897]  __rpm_callback+0x7a/0x1d0
    [  861.515618]  ? pci_has_legacy_pm_support+0x70/0x70
    [  861.516313]  rpm_callback+0x24/0x80
    [  861.517027]  ? pci_has_legacy_pm_support+0x70/0x70
    [  861.517741]  rpm_suspend+0x142/0x6b0
    [  861.518449]  pm_runtime_work+0x97/0xc0
    [  861.519144]  process_one_work+0x231/0x620
    [  861.519831]  worker_thread+0x44/0x3a0
    [  861.520522]  kthread+0x12b/0x150
    [  861.521220]  ? wq_pool_ids_show+0x140/0x140
    [  861.521925]  ? kthread_create_worker_on_cpu+0x70/0x70
    [  861.522622]  ret_from_fork+0x3a/0x50
    [  861.523299] INFO: task kworker/6:0:1329 blocked for more than 120 seconds.
    [  861.523977]       Tainted: G           O      4.18.0-rc6Lyude-Test+ #1
    [  861.524644] "echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
    [  861.525349] kworker/6:0     D    0  1329      2 0x80000000
    [  861.526073] Workqueue: events nvif_notify_work [nouveau]
    [  861.526751] Call Trace:
    [  861.527411]  __schedule+0x322/0xaf0
    [  861.528089]  schedule+0x33/0x90
    [  861.528758]  rpm_resume+0x19c/0x850
    [  861.529399]  ? finish_wait+0x90/0x90
    [  861.530073]  __pm_runtime_resume+0x4e/0x90
    [  861.530798]  nouveau_connector_detect+0x7e/0x510 [nouveau]
    [  861.531459]  ? ww_mutex_lock+0x47/0x80
    [  861.532097]  ? ww_mutex_lock+0x47/0x80
    [  861.532819]  ? drm_modeset_lock+0x88/0x130 [drm]
    [  861.533481]  drm_helper_probe_detect_ctx+0xa0/0x100 [drm_kms_helper]
    [  861.534127]  drm_helper_hpd_irq_event+0xa4/0x120 [drm_kms_helper]
    [  861.534940]  nouveau_connector_hotplug+0x98/0x120 [nouveau]
    [  861.535556]  nvif_notify_work+0x2d/0xb0 [nouveau]
    [  861.536221]  process_one_work+0x231/0x620
    [  861.536994]  worker_thread+0x44/0x3a0
    [  861.537757]  kthread+0x12b/0x150
    [  861.538463]  ? wq_pool_ids_show+0x140/0x140
    [  861.539102]  ? kthread_create_worker_on_cpu+0x70/0x70
    [  861.539815]  ret_from_fork+0x3a/0x50
    [  861.540521]
                   Showing all locks held in the system:
    [  861.541696] 2 locks held by kworker/0:2/61:
    [  861.542406]  #0: 000000002dbf8af5 ((wq_completion)"events"){+.+.}, at: process_one_work+0x1b3/0x620
    [  861.543071]  #1: 0000000076868126 ((work_completion)(&drm->hpd_work)){+.+.}, at: process_one_work+0x1b3/0x620
    [  861.543814] 1 lock held by khungtaskd/64:
    [  861.544535]  #0: 0000000059db4b53 (rcu_read_lock){....}, at: debug_show_all_locks+0x23/0x185
    [  861.545160] 3 locks held by kworker/6:2/320:
    [  861.545896]  #0: 00000000d9e1bc59 ((wq_completion)"pm"){+.+.}, at: process_one_work+0x1b3/0x620
    [  861.546702]  #1: 00000000c9f92d84 ((work_completion)(&dev->power.work)){+.+.}, at: process_one_work+0x1b3/0x620
    [  861.547443]  #2: 000000004afc5de1 (drm_connector_list_iter){.+.+}, at: nouveau_display_fini+0x96/0x170 [nouveau]
    [  861.548146] 1 lock held by dmesg/983:
    [  861.548889] 2 locks held by zsh/1250:
    [  861.549605]  #0: 00000000348e3cf6 (&tty->ldisc_sem){++++}, at: ldsem_down_read+0x37/0x40
    [  861.550393]  #1: 000000007009a7a8 (&ldata->atomic_read_lock){+.+.}, at: n_tty_read+0xc1/0x870
    [  861.551122] 6 locks held by kworker/6:0/1329:
    [  861.551957]  #0: 000000002dbf8af5 ((wq_completion)"events"){+.+.}, at: process_one_work+0x1b3/0x620
    [  861.552765]  #1: 00000000ddb499ad ((work_completion)(&notify->work)#2){+.+.}, at: process_one_work+0x1b3/0x620
    [  861.553582]  #2: 000000006e013cbe (&dev->mode_config.mutex){+.+.}, at: drm_helper_hpd_irq_event+0x6c/0x120 [drm_kms_helper]
    [  861.554357]  #3: 000000004afc5de1 (drm_connector_list_iter){.+.+}, at: drm_helper_hpd_irq_event+0x78/0x120 [drm_kms_helper]
    [  861.555227]  #4: 0000000044f294d9 (crtc_ww_class_acquire){+.+.}, at: drm_helper_probe_detect_ctx+0x3d/0x100 [drm_kms_helper]
    [  861.556133]  #5: 00000000db193642 (crtc_ww_class_mutex){+.+.}, at: drm_modeset_lock+0x4b/0x130 [drm]
    
    [  861.557864] =============================================
    
    [  861.559507] NMI backtrace for cpu 2
    [  861.560363] CPU: 2 PID: 64 Comm: khungtaskd Tainted: G           O      4.18.0-rc6Lyude-Test+ #1
    [  861.561197] Hardware name: LENOVO 20EQS64N0B/20EQS64N0B, BIOS N1EET78W (1.51 ) 05/18/2018
    [  861.561948] Call Trace:
    [  861.562757]  dump_stack+0x8e/0xd3
    [  861.563516]  nmi_cpu_backtrace.cold.3+0x14/0x5a
    [  861.564269]  ? lapic_can_unplug_cpu.cold.27+0x42/0x42
    [  861.565029]  nmi_trigger_cpumask_backtrace+0xa1/0xae
    [  861.565789]  arch_trigger_cpumask_backtrace+0x19/0x20
    [  861.566558]  watchdog+0x316/0x580
    [  861.567355]  kthread+0x12b/0x150
    [  861.568114]  ? reset_hung_task_detector+0x20/0x20
    [  861.568863]  ? kthread_create_worker_on_cpu+0x70/0x70
    [  861.569598]  ret_from_fork+0x3a/0x50
    [  861.570370] Sending NMI from CPU 2 to CPUs 0-1,3-7:
    [  861.571426] NMI backtrace for cpu 6 skipped: idling at intel_idle+0x7f/0x120
    [  861.571429] NMI backtrace for cpu 7 skipped: idling at intel_idle+0x7f/0x120
    [  861.571432] NMI backtrace for cpu 3 skipped: idling at intel_idle+0x7f/0x120
    [  861.571464] NMI backtrace for cpu 5 skipped: idling at intel_idle+0x7f/0x120
    [  861.571467] NMI backtrace for cpu 0 skipped: idling at intel_idle+0x7f/0x120
    [  861.571469] NMI backtrace for cpu 4 skipped: idling at intel_idle+0x7f/0x120
    [  861.571472] NMI backtrace for cpu 1 skipped: idling at intel_idle+0x7f/0x120
    [  861.572428] Kernel panic - not syncing: hung_task: blocked tasks
    
    So: fix this by making it so that normal hotplug handling /only/ happens
    so long as the GPU is currently awake without any pending runtime PM
    requests. In the event that a hotplug occurs while the device is
    suspending or resuming, we can simply defer our response until the GPU
    is fully runtime resumed again.
    
    Changes since v4:
    - Use a new trick I came up with using pm_runtime_get() instead of the
      hackish junk we had before
    
    Signed-off-by: Lyude Paul <lyude@redhat.com>
    Reviewed-by: Karol Herbst <kherbst@redhat.com>
    Acked-by: Daniel Vetter <daniel@ffwll.ch>
    Cc: stable@vger.kernel.org
    Cc: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 3498ea8b7e3c8b2fd2575780cb76c4c91a346c6d
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Tue Sep 18 19:44:31 2018 +0200

    staging: vboxvideo: Fold vbox_drm_resume() into vbox_pm_resume()
    
    vbox_pm_resume() is the only caller of vbox_drm_resume(), so squash the
    2 functions into 1.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit c73480910e9686a5c25155cb4d418d594b678196
Author: zhong jiang <zhongjiang@huawei.com>
Date:   Mon Sep 17 18:44:19 2018 +0800

    net: ethernet: Fix a unused function warning.
    
    Fix the following compile warning:
    
    drivers/net/ethernet/microchip/lan743x_main.c:2964:12: warning: lan743x_pm_suspend defined but not used [-Wunused-function]
     static int lan743x_pm_suspend(struct device *dev)
    drivers/net/ethernet/microchip/lan743x_main.c:2987:12: warning: lan743x_pm_resume defined but not used [-Wunused-function]
     static int lan743x_pm_resume(struct device *dev)
    
    Signed-off-by: zhong jiang <zhongjiang@huawei.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 3e1a12754d4df5804bfca5dedf09d2ba291bdc2a
Author: Lyude Paul <lyude@redhat.com>
Date:   Wed Aug 15 15:00:15 2018 -0400

    drm/nouveau: Fix deadlocks in nouveau_connector_detect()
    
    When we disable hotplugging on the GPU, we need to be able to
    synchronize with each connector's hotplug interrupt handler before the
    interrupt is finally disabled. This can be a problem however, since
    nouveau_connector_detect() currently grabs a runtime power reference
    when handling connector probing. This will deadlock the runtime suspend
    handler like so:
    
    [  861.480896] INFO: task kworker/0:2:61 blocked for more than 120 seconds.
    [  861.483290]       Tainted: G           O      4.18.0-rc6Lyude-Test+ #1
    [  861.485158] "echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
    [  861.486332] kworker/0:2     D    0    61      2 0x80000000
    [  861.487044] Workqueue: events nouveau_display_hpd_work [nouveau]
    [  861.487737] Call Trace:
    [  861.488394]  __schedule+0x322/0xaf0
    [  861.489070]  schedule+0x33/0x90
    [  861.489744]  rpm_resume+0x19c/0x850
    [  861.490392]  ? finish_wait+0x90/0x90
    [  861.491068]  __pm_runtime_resume+0x4e/0x90
    [  861.491753]  nouveau_display_hpd_work+0x22/0x60 [nouveau]
    [  861.492416]  process_one_work+0x231/0x620
    [  861.493068]  worker_thread+0x44/0x3a0
    [  861.493722]  kthread+0x12b/0x150
    [  861.494342]  ? wq_pool_ids_show+0x140/0x140
    [  861.494991]  ? kthread_create_worker_on_cpu+0x70/0x70
    [  861.495648]  ret_from_fork+0x3a/0x50
    [  861.496304] INFO: task kworker/6:2:320 blocked for more than 120 seconds.
    [  861.496968]       Tainted: G           O      4.18.0-rc6Lyude-Test+ #1
    [  861.497654] "echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
    [  861.498341] kworker/6:2     D    0   320      2 0x80000080
    [  861.499045] Workqueue: pm pm_runtime_work
    [  861.499739] Call Trace:
    [  861.500428]  __schedule+0x322/0xaf0
    [  861.501134]  ? wait_for_completion+0x104/0x190
    [  861.501851]  schedule+0x33/0x90
    [  861.502564]  schedule_timeout+0x3a5/0x590
    [  861.503284]  ? mark_held_locks+0x58/0x80
    [  861.503988]  ? _raw_spin_unlock_irq+0x2c/0x40
    [  861.504710]  ? wait_for_completion+0x104/0x190
    [  861.505417]  ? trace_hardirqs_on_caller+0xf4/0x190
    [  861.506136]  ? wait_for_completion+0x104/0x190
    [  861.506845]  wait_for_completion+0x12c/0x190
    [  861.507555]  ? wake_up_q+0x80/0x80
    [  861.508268]  flush_work+0x1c9/0x280
    [  861.508990]  ? flush_workqueue_prep_pwqs+0x1b0/0x1b0
    [  861.509735]  nvif_notify_put+0xb1/0xc0 [nouveau]
    [  861.510482]  nouveau_display_fini+0xbd/0x170 [nouveau]
    [  861.511241]  nouveau_display_suspend+0x67/0x120 [nouveau]
    [  861.511969]  nouveau_do_suspend+0x5e/0x2d0 [nouveau]
    [  861.512715]  nouveau_pmops_runtime_suspend+0x47/0xb0 [nouveau]
    [  861.513435]  pci_pm_runtime_suspend+0x6b/0x180
    [  861.514165]  ? pci_has_legacy_pm_support+0x70/0x70
    [  861.514897]  __rpm_callback+0x7a/0x1d0
    [  861.515618]  ? pci_has_legacy_pm_support+0x70/0x70
    [  861.516313]  rpm_callback+0x24/0x80
    [  861.517027]  ? pci_has_legacy_pm_support+0x70/0x70
    [  861.517741]  rpm_suspend+0x142/0x6b0
    [  861.518449]  pm_runtime_work+0x97/0xc0
    [  861.519144]  process_one_work+0x231/0x620
    [  861.519831]  worker_thread+0x44/0x3a0
    [  861.520522]  kthread+0x12b/0x150
    [  861.521220]  ? wq_pool_ids_show+0x140/0x140
    [  861.521925]  ? kthread_create_worker_on_cpu+0x70/0x70
    [  861.522622]  ret_from_fork+0x3a/0x50
    [  861.523299] INFO: task kworker/6:0:1329 blocked for more than 120 seconds.
    [  861.523977]       Tainted: G           O      4.18.0-rc6Lyude-Test+ #1
    [  861.524644] "echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
    [  861.525349] kworker/6:0     D    0  1329      2 0x80000000
    [  861.526073] Workqueue: events nvif_notify_work [nouveau]
    [  861.526751] Call Trace:
    [  861.527411]  __schedule+0x322/0xaf0
    [  861.528089]  schedule+0x33/0x90
    [  861.528758]  rpm_resume+0x19c/0x850
    [  861.529399]  ? finish_wait+0x90/0x90
    [  861.530073]  __pm_runtime_resume+0x4e/0x90
    [  861.530798]  nouveau_connector_detect+0x7e/0x510 [nouveau]
    [  861.531459]  ? ww_mutex_lock+0x47/0x80
    [  861.532097]  ? ww_mutex_lock+0x47/0x80
    [  861.532819]  ? drm_modeset_lock+0x88/0x130 [drm]
    [  861.533481]  drm_helper_probe_detect_ctx+0xa0/0x100 [drm_kms_helper]
    [  861.534127]  drm_helper_hpd_irq_event+0xa4/0x120 [drm_kms_helper]
    [  861.534940]  nouveau_connector_hotplug+0x98/0x120 [nouveau]
    [  861.535556]  nvif_notify_work+0x2d/0xb0 [nouveau]
    [  861.536221]  process_one_work+0x231/0x620
    [  861.536994]  worker_thread+0x44/0x3a0
    [  861.537757]  kthread+0x12b/0x150
    [  861.538463]  ? wq_pool_ids_show+0x140/0x140
    [  861.539102]  ? kthread_create_worker_on_cpu+0x70/0x70
    [  861.539815]  ret_from_fork+0x3a/0x50
    [  861.540521]
                   Showing all locks held in the system:
    [  861.541696] 2 locks held by kworker/0:2/61:
    [  861.542406]  #0: 000000002dbf8af5 ((wq_completion)"events"){+.+.}, at: process_one_work+0x1b3/0x620
    [  861.543071]  #1: 0000000076868126 ((work_completion)(&drm->hpd_work)){+.+.}, at: process_one_work+0x1b3/0x620
    [  861.543814] 1 lock held by khungtaskd/64:
    [  861.544535]  #0: 0000000059db4b53 (rcu_read_lock){....}, at: debug_show_all_locks+0x23/0x185
    [  861.545160] 3 locks held by kworker/6:2/320:
    [  861.545896]  #0: 00000000d9e1bc59 ((wq_completion)"pm"){+.+.}, at: process_one_work+0x1b3/0x620
    [  861.546702]  #1: 00000000c9f92d84 ((work_completion)(&dev->power.work)){+.+.}, at: process_one_work+0x1b3/0x620
    [  861.547443]  #2: 000000004afc5de1 (drm_connector_list_iter){.+.+}, at: nouveau_display_fini+0x96/0x170 [nouveau]
    [  861.548146] 1 lock held by dmesg/983:
    [  861.548889] 2 locks held by zsh/1250:
    [  861.549605]  #0: 00000000348e3cf6 (&tty->ldisc_sem){++++}, at: ldsem_down_read+0x37/0x40
    [  861.550393]  #1: 000000007009a7a8 (&ldata->atomic_read_lock){+.+.}, at: n_tty_read+0xc1/0x870
    [  861.551122] 6 locks held by kworker/6:0/1329:
    [  861.551957]  #0: 000000002dbf8af5 ((wq_completion)"events"){+.+.}, at: process_one_work+0x1b3/0x620
    [  861.552765]  #1: 00000000ddb499ad ((work_completion)(&notify->work)#2){+.+.}, at: process_one_work+0x1b3/0x620
    [  861.553582]  #2: 000000006e013cbe (&dev->mode_config.mutex){+.+.}, at: drm_helper_hpd_irq_event+0x6c/0x120 [drm_kms_helper]
    [  861.554357]  #3: 000000004afc5de1 (drm_connector_list_iter){.+.+}, at: drm_helper_hpd_irq_event+0x78/0x120 [drm_kms_helper]
    [  861.555227]  #4: 0000000044f294d9 (crtc_ww_class_acquire){+.+.}, at: drm_helper_probe_detect_ctx+0x3d/0x100 [drm_kms_helper]
    [  861.556133]  #5: 00000000db193642 (crtc_ww_class_mutex){+.+.}, at: drm_modeset_lock+0x4b/0x130 [drm]
    
    [  861.557864] =============================================
    
    [  861.559507] NMI backtrace for cpu 2
    [  861.560363] CPU: 2 PID: 64 Comm: khungtaskd Tainted: G           O      4.18.0-rc6Lyude-Test+ #1
    [  861.561197] Hardware name: LENOVO 20EQS64N0B/20EQS64N0B, BIOS N1EET78W (1.51 ) 05/18/2018
    [  861.561948] Call Trace:
    [  861.562757]  dump_stack+0x8e/0xd3
    [  861.563516]  nmi_cpu_backtrace.cold.3+0x14/0x5a
    [  861.564269]  ? lapic_can_unplug_cpu.cold.27+0x42/0x42
    [  861.565029]  nmi_trigger_cpumask_backtrace+0xa1/0xae
    [  861.565789]  arch_trigger_cpumask_backtrace+0x19/0x20
    [  861.566558]  watchdog+0x316/0x580
    [  861.567355]  kthread+0x12b/0x150
    [  861.568114]  ? reset_hung_task_detector+0x20/0x20
    [  861.568863]  ? kthread_create_worker_on_cpu+0x70/0x70
    [  861.569598]  ret_from_fork+0x3a/0x50
    [  861.570370] Sending NMI from CPU 2 to CPUs 0-1,3-7:
    [  861.571426] NMI backtrace for cpu 6 skipped: idling at intel_idle+0x7f/0x120
    [  861.571429] NMI backtrace for cpu 7 skipped: idling at intel_idle+0x7f/0x120
    [  861.571432] NMI backtrace for cpu 3 skipped: idling at intel_idle+0x7f/0x120
    [  861.571464] NMI backtrace for cpu 5 skipped: idling at intel_idle+0x7f/0x120
    [  861.571467] NMI backtrace for cpu 0 skipped: idling at intel_idle+0x7f/0x120
    [  861.571469] NMI backtrace for cpu 4 skipped: idling at intel_idle+0x7f/0x120
    [  861.571472] NMI backtrace for cpu 1 skipped: idling at intel_idle+0x7f/0x120
    [  861.572428] Kernel panic - not syncing: hung_task: blocked tasks
    
    So: fix this by making it so that normal hotplug handling /only/ happens
    so long as the GPU is currently awake without any pending runtime PM
    requests. In the event that a hotplug occurs while the device is
    suspending or resuming, we can simply defer our response until the GPU
    is fully runtime resumed again.
    
    Changes since v4:
    - Use a new trick I came up with using pm_runtime_get() instead of the
      hackish junk we had before
    
    Signed-off-by: Lyude Paul <lyude@redhat.com>
    Reviewed-by: Karol Herbst <kherbst@redhat.com>
    Acked-by: Daniel Vetter <daniel@ffwll.ch>
    Cc: stable@vger.kernel.org
    Cc: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

commit 7fec8f5379fb6eddabc0aaef6d2304c366808f97
Author: Lyude Paul <lyude@redhat.com>
Date:   Wed Aug 15 15:00:13 2018 -0400

    drm/nouveau/drm/nouveau: Fix deadlock with fb_helper with async RPM requests
    
    Currently, nouveau uses the generic drm_fb_helper_output_poll_changed()
    function provided by DRM as it's output_poll_changed callback.
    Unfortunately however, this function doesn't grab runtime PM references
    early enough and even if it did-we can't block waiting for the device to
    resume in output_poll_changed() since it's very likely that we'll need
    to grab the fb_helper lock at some point during the runtime resume
    process. This currently results in deadlocking like so:
    
    [  246.669625] INFO: task kworker/4:0:37 blocked for more than 120 seconds.
    [  246.673398]       Not tainted 4.18.0-rc5Lyude-Test+ #2
    [  246.675271] "echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
    [  246.676527] kworker/4:0     D    0    37      2 0x80000000
    [  246.677580] Workqueue: events output_poll_execute [drm_kms_helper]
    [  246.678704] Call Trace:
    [  246.679753]  __schedule+0x322/0xaf0
    [  246.680916]  schedule+0x33/0x90
    [  246.681924]  schedule_preempt_disabled+0x15/0x20
    [  246.683023]  __mutex_lock+0x569/0x9a0
    [  246.684035]  ? kobject_uevent_env+0x117/0x7b0
    [  246.685132]  ? drm_fb_helper_hotplug_event.part.28+0x20/0xb0 [drm_kms_helper]
    [  246.686179]  mutex_lock_nested+0x1b/0x20
    [  246.687278]  ? mutex_lock_nested+0x1b/0x20
    [  246.688307]  drm_fb_helper_hotplug_event.part.28+0x20/0xb0 [drm_kms_helper]
    [  246.689420]  drm_fb_helper_output_poll_changed+0x23/0x30 [drm_kms_helper]
    [  246.690462]  drm_kms_helper_hotplug_event+0x2a/0x30 [drm_kms_helper]
    [  246.691570]  output_poll_execute+0x198/0x1c0 [drm_kms_helper]
    [  246.692611]  process_one_work+0x231/0x620
    [  246.693725]  worker_thread+0x214/0x3a0
    [  246.694756]  kthread+0x12b/0x150
    [  246.695856]  ? wq_pool_ids_show+0x140/0x140
    [  246.696888]  ? kthread_create_worker_on_cpu+0x70/0x70
    [  246.697998]  ret_from_fork+0x3a/0x50
    [  246.699034] INFO: task kworker/0:1:60 blocked for more than 120 seconds.
    [  246.700153]       Not tainted 4.18.0-rc5Lyude-Test+ #2
    [  246.701182] "echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
    [  246.702278] kworker/0:1     D    0    60      2 0x80000000
    [  246.703293] Workqueue: pm pm_runtime_work
    [  246.704393] Call Trace:
    [  246.705403]  __schedule+0x322/0xaf0
    [  246.706439]  ? wait_for_completion+0x104/0x190
    [  246.707393]  schedule+0x33/0x90
    [  246.708375]  schedule_timeout+0x3a5/0x590
    [  246.709289]  ? mark_held_locks+0x58/0x80
    [  246.710208]  ? _raw_spin_unlock_irq+0x2c/0x40
    [  246.711222]  ? wait_for_completion+0x104/0x190
    [  246.712134]  ? trace_hardirqs_on_caller+0xf4/0x190
    [  246.713094]  ? wait_for_completion+0x104/0x190
    [  246.713964]  wait_for_completion+0x12c/0x190
    [  246.714895]  ? wake_up_q+0x80/0x80
    [  246.715727]  ? get_work_pool+0x90/0x90
    [  246.716649]  flush_work+0x1c9/0x280
    [  246.717483]  ? flush_workqueue_prep_pwqs+0x1b0/0x1b0
    [  246.718442]  __cancel_work_timer+0x146/0x1d0
    [  246.719247]  cancel_delayed_work_sync+0x13/0x20
    [  246.720043]  drm_kms_helper_poll_disable+0x1f/0x30 [drm_kms_helper]
    [  246.721123]  nouveau_pmops_runtime_suspend+0x3d/0xb0 [nouveau]
    [  246.721897]  pci_pm_runtime_suspend+0x6b/0x190
    [  246.722825]  ? pci_has_legacy_pm_support+0x70/0x70
    [  246.723737]  __rpm_callback+0x7a/0x1d0
    [  246.724721]  ? pci_has_legacy_pm_support+0x70/0x70
    [  246.725607]  rpm_callback+0x24/0x80
    [  246.726553]  ? pci_has_legacy_pm_support+0x70/0x70
    [  246.727376]  rpm_suspend+0x142/0x6b0
    [  246.728185]  pm_runtime_work+0x97/0xc0
    [  246.728938]  process_one_work+0x231/0x620
    [  246.729796]  worker_thread+0x44/0x3a0
    [  246.730614]  kthread+0x12b/0x150
    [  246.731395]  ? wq_pool_ids_show+0x140/0x140
    [  246.732202]  ? kthread_create_worker_on_cpu+0x70/0x70
    [  246.732878]  ret_from_fork+0x3a/0x50
    [  246.733768] INFO: task kworker/4:2:422 blocked for more than 120 seconds.
    [  246.734587]       Not tainted 4.18.0-rc5Lyude-Test+ #2
    [  246.735393] "echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
    [  246.736113] kworker/4:2     D    0   422      2 0x80000080
    [  246.736789] Workqueue: events_long drm_dp_mst_link_probe_work [drm_kms_helper]
    [  246.737665] Call Trace:
    [  246.738490]  __schedule+0x322/0xaf0
    [  246.739250]  schedule+0x33/0x90
    [  246.739908]  rpm_resume+0x19c/0x850
    [  246.740750]  ? finish_wait+0x90/0x90
    [  246.741541]  __pm_runtime_resume+0x4e/0x90
    [  246.742370]  nv50_disp_atomic_commit+0x31/0x210 [nouveau]
    [  246.743124]  drm_atomic_commit+0x4a/0x50 [drm]
    [  246.743775]  restore_fbdev_mode_atomic+0x1c8/0x240 [drm_kms_helper]
    [  246.744603]  restore_fbdev_mode+0x31/0x140 [drm_kms_helper]
    [  246.745373]  drm_fb_helper_restore_fbdev_mode_unlocked+0x54/0xb0 [drm_kms_helper]
    [  246.746220]  drm_fb_helper_set_par+0x2d/0x50 [drm_kms_helper]
    [  246.746884]  drm_fb_helper_hotplug_event.part.28+0x96/0xb0 [drm_kms_helper]
    [  246.747675]  drm_fb_helper_output_poll_changed+0x23/0x30 [drm_kms_helper]
    [  246.748544]  drm_kms_helper_hotplug_event+0x2a/0x30 [drm_kms_helper]
    [  246.749439]  nv50_mstm_hotplug+0x15/0x20 [nouveau]
    [  246.750111]  drm_dp_send_link_address+0x177/0x1c0 [drm_kms_helper]
    [  246.750764]  drm_dp_check_and_send_link_address+0xa8/0xd0 [drm_kms_helper]
    [  246.751602]  drm_dp_mst_link_probe_work+0x51/0x90 [drm_kms_helper]
    [  246.752314]  process_one_work+0x231/0x620
    [  246.752979]  worker_thread+0x44/0x3a0
    [  246.753838]  kthread+0x12b/0x150
    [  246.754619]  ? wq_pool_ids_show+0x140/0x140
    [  246.755386]  ? kthread_create_worker_on_cpu+0x70/0x70
    [  246.756162]  ret_from_fork+0x3a/0x50
    [  246.756847]
               Showing all locks held in the system:
    [  246.758261] 3 locks held by kworker/4:0/37:
    [  246.759016]  #0: 00000000f8df4d2d ((wq_completion)"events"){+.+.}, at: process_one_work+0x1b3/0x620
    [  246.759856]  #1: 00000000e6065461 ((work_completion)(&(&dev->mode_config.output_poll_work)->work)){+.+.}, at: process_one_work+0x1b3/0x620
    [  246.760670]  #2: 00000000cb66735f (&helper->lock){+.+.}, at: drm_fb_helper_hotplug_event.part.28+0x20/0xb0 [drm_kms_helper]
    [  246.761516] 2 locks held by kworker/0:1/60:
    [  246.762274]  #0: 00000000fff6be0f ((wq_completion)"pm"){+.+.}, at: process_one_work+0x1b3/0x620
    [  246.762982]  #1: 000000005ab44fb4 ((work_completion)(&dev->power.work)){+.+.}, at: process_one_work+0x1b3/0x620
    [  246.763890] 1 lock held by khungtaskd/64:
    [  246.764664]  #0: 000000008cb8b5c3 (rcu_read_lock){....}, at: debug_show_all_locks+0x23/0x185
    [  246.765588] 5 locks held by kworker/4:2/422:
    [  246.766440]  #0: 00000000232f0959 ((wq_completion)"events_long"){+.+.}, at: process_one_work+0x1b3/0x620
    [  246.767390]  #1: 00000000bb59b134 ((work_completion)(&mgr->work)){+.+.}, at: process_one_work+0x1b3/0x620
    [  246.768154]  #2: 00000000cb66735f (&helper->lock){+.+.}, at: drm_fb_helper_restore_fbdev_mode_unlocked+0x4c/0xb0 [drm_kms_helper]
    [  246.768966]  #3: 000000004c8f0b6b (crtc_ww_class_acquire){+.+.}, at: restore_fbdev_mode_atomic+0x4b/0x240 [drm_kms_helper]
    [  246.769921]  #4: 000000004c34a296 (crtc_ww_class_mutex){+.+.}, at: drm_modeset_backoff+0x8a/0x1b0 [drm]
    [  246.770839] 1 lock held by dmesg/1038:
    [  246.771739] 2 locks held by zsh/1172:
    [  246.772650]  #0: 00000000836d0438 (&tty->ldisc_sem){++++}, at: ldsem_down_read+0x37/0x40
    [  246.773680]  #1: 000000001f4f4d48 (&ldata->atomic_read_lock){+.+.}, at: n_tty_read+0xc1/0x870
    
    [  246.775522] =============================================
    
    After trying dozens of different solutions, I found one very simple one
    that should also have the benefit of preventing us from having to fight
    locking for the rest of our lives. So, we work around these deadlocks by
    deferring all fbcon hotplug events that happen after the runtime suspend
    process starts until after the device is resumed again.
    
    Changes since v7:
     - Fixup commit message - Daniel Vetter
    
    Changes since v6:
     - Remove unused nouveau_fbcon_hotplugged_in_suspend() - Ilia
    
    Changes since v5:
     - Come up with the (hopefully final) solution for solving this dumb
       problem, one that is a lot less likely to cause issues with locking in
       the future. This should work around all deadlock conditions with fbcon
       brought up thus far.
    
    Changes since v4:
     - Add nouveau_fbcon_hotplugged_in_suspend() to workaround deadlock
       condition that Lukas described
     - Just move all of this out of drm_fb_helper. It seems that other DRM
       drivers have already figured out other workarounds for this. If other
       drivers do end up needing this in the future, we can just move this
       back into drm_fb_helper again.
    
    Changes since v3:
    - Actually check if fb_helper is NULL in both new helpers
    - Actually check drm_fbdev_emulation in both new helpers
    - Don't fire off a fb_helper hotplug unconditionally; only do it if
      the following conditions are true (as otherwise, calling this in the
      wrong spot will cause Bad Things to happen):
      - fb_helper hotplug handling was actually inhibited previously
      - fb_helper actually has a delayed hotplug pending
      - fb_helper is actually bound
      - fb_helper is actually initialized
    - Add __must_check to drm_fb_helper_suspend_hotplug(). There's no
      situation where a driver would actually want to use this without
      checking the return value, so enforce that
    - Rewrite and clarify the documentation for both helpers.
    - Make sure to return true in the drm_fb_helper_suspend_hotplug() stub
      that's provided in drm_fb_helper.h when CONFIG_DRM_FBDEV_EMULATION
      isn't enabled
    - Actually grab the toplevel fb_helper lock in
      drm_fb_helper_resume_hotplug(), since it's possible other activity
      (such as a hotplug) could be going on at the same time the driver
      calls drm_fb_helper_resume_hotplug(). We need this to check whether or
      not drm_fb_helper_hotplug_event() needs to be called anyway
    
    Signed-off-by: Lyude Paul <lyude@redhat.com>
    Reviewed-by: Karol Herbst <kherbst@redhat.com>
    Acked-by: Daniel Vetter <daniel@ffwll.ch>
    Cc: stable@vger.kernel.org
    Cc: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

commit d882e521074e1b7c8e22bcf21376fae5de58d82e
Author: Siva Rebbagondla <siva.rebbagondla@redpinesignals.com>
Date:   Wed Apr 11 12:13:32 2018 +0530

    rsi: Fix 'invalid vdd' warning in mmc
    
    [ Upstream commit 78e450719c702784e42af6da912d3692fd3da0cb ]
    
    While performing cleanup, driver is messing with card->ocr
    value by not masking rocr against ocr_avail. Below panic
    is observed with some of the SDIO host controllers due to
    this. Issue is resolved by reverting incorrect modifications
    to vdd.
    
    [  927.423821] mmc1: Invalid vdd 0x1f
    [  927.423925] Modules linked in: rsi_sdio(+) cmac bnep arc4 rsi_91x
                   mac80211 cfg80211 btrsi rfcomm bluetooth ecdh_generic
    [  927.424073] CPU: 0 PID: 1624 Comm: insmod Tainted: G         W        4.15.0-1000-caracalla #1
    [  927.424075] Hardware name: Dell Inc. Edge Gateway    3003/      , BIOS 01.00.06 01/22/2018
    [  927.424082] RIP: 0010:sdhci_set_power_noreg+0xdd/0x190[sdhci]
    [  927.424085] RSP: 0018:ffffac3fc064b930 EFLAGS:  00010282
    [  927.424107] Call Trace:
    [  927.424118]  sdhci_set_power+0x5a/0x60 [sdhci]
    [  927.424125]  sdhci_set_ios+0x360/0x3b0 [sdhci]
    [  927.424133]  mmc_set_initial_state+0x92/0x120
    [  927.424137]  mmc_power_up.part.34+0x33/0x1d0
    [  927.424141]  mmc_power_up+0x17/0x20
    [  927.424147]  mmc_sdio_runtime_resume+0x2d/0x50
    [  927.424151]  mmc_runtime_resume+0x17/0x20
    [  927.424156]  __rpm_callback+0xc4/0x200
    [  927.424161]  ? idr_alloc_cyclic+0x57/0xd0
    [  927.424165]  ? mmc_runtime_suspend+0x20/0x20
    [  927.424169]  rpm_callback+0x24/0x80
    [  927.424172]  ? mmc_runtime_suspend+0x20/0x20
    [  927.424176]  rpm_resume+0x4b3/0x6c0
    [  927.424181]  __pm_runtime_resume+0x4e/0x80
    [  927.424188]  driver_probe_device+0x41/0x490
    [  927.424192]  __driver_attach+0xdf/0xf0
    [  927.424196]  ? driver_probe_device+0x490/0x490
    [  927.424201]  bus_for_each_dev+0x6c/0xc0
    [  927.424205]  driver_attach+0x1e/0x20
    [  927.424209]  bus_add_driver+0x1f4/0x270
    [  927.424217]  ? rsi_sdio_ack_intr+0x50/0x50 [rsi_sdio]
    [  927.424221]  driver_register+0x60/0xe0
    [  927.424227]  ? rsi_sdio_ack_intr+0x50/0x50 [rsi_sdio]
    [  927.424231]  sdio_register_driver+0x20/0x30
    [  927.424237]  rsi_module_init+0x16/0x40 [rsi_sdio]
    
    Signed-off-by: Siva Rebbagondla <siva.rebbagondla@redpinesignals.com>
    Signed-off-by: Amitkumar Karwar <amit.karwar@redpinesignals.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
    Signed-off-by: Sasha Levin <alexander.levin@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 7315e0d38a29792cbb32b84e17e413412171e1e1
Author: Siva Rebbagondla <siva.rebbagondla@redpinesignals.com>
Date:   Wed Apr 11 12:13:32 2018 +0530

    rsi: Fix 'invalid vdd' warning in mmc
    
    [ Upstream commit 78e450719c702784e42af6da912d3692fd3da0cb ]
    
    While performing cleanup, driver is messing with card->ocr
    value by not masking rocr against ocr_avail. Below panic
    is observed with some of the SDIO host controllers due to
    this. Issue is resolved by reverting incorrect modifications
    to vdd.
    
    [  927.423821] mmc1: Invalid vdd 0x1f
    [  927.423925] Modules linked in: rsi_sdio(+) cmac bnep arc4 rsi_91x
                   mac80211 cfg80211 btrsi rfcomm bluetooth ecdh_generic
    [  927.424073] CPU: 0 PID: 1624 Comm: insmod Tainted: G         W        4.15.0-1000-caracalla #1
    [  927.424075] Hardware name: Dell Inc. Edge Gateway    3003/      , BIOS 01.00.06 01/22/2018
    [  927.424082] RIP: 0010:sdhci_set_power_noreg+0xdd/0x190[sdhci]
    [  927.424085] RSP: 0018:ffffac3fc064b930 EFLAGS:  00010282
    [  927.424107] Call Trace:
    [  927.424118]  sdhci_set_power+0x5a/0x60 [sdhci]
    [  927.424125]  sdhci_set_ios+0x360/0x3b0 [sdhci]
    [  927.424133]  mmc_set_initial_state+0x92/0x120
    [  927.424137]  mmc_power_up.part.34+0x33/0x1d0
    [  927.424141]  mmc_power_up+0x17/0x20
    [  927.424147]  mmc_sdio_runtime_resume+0x2d/0x50
    [  927.424151]  mmc_runtime_resume+0x17/0x20
    [  927.424156]  __rpm_callback+0xc4/0x200
    [  927.424161]  ? idr_alloc_cyclic+0x57/0xd0
    [  927.424165]  ? mmc_runtime_suspend+0x20/0x20
    [  927.424169]  rpm_callback+0x24/0x80
    [  927.424172]  ? mmc_runtime_suspend+0x20/0x20
    [  927.424176]  rpm_resume+0x4b3/0x6c0
    [  927.424181]  __pm_runtime_resume+0x4e/0x80
    [  927.424188]  driver_probe_device+0x41/0x490
    [  927.424192]  __driver_attach+0xdf/0xf0
    [  927.424196]  ? driver_probe_device+0x490/0x490
    [  927.424201]  bus_for_each_dev+0x6c/0xc0
    [  927.424205]  driver_attach+0x1e/0x20
    [  927.424209]  bus_add_driver+0x1f4/0x270
    [  927.424217]  ? rsi_sdio_ack_intr+0x50/0x50 [rsi_sdio]
    [  927.424221]  driver_register+0x60/0xe0
    [  927.424227]  ? rsi_sdio_ack_intr+0x50/0x50 [rsi_sdio]
    [  927.424231]  sdio_register_driver+0x20/0x30
    [  927.424237]  rsi_module_init+0x16/0x40 [rsi_sdio]
    
    Signed-off-by: Siva Rebbagondla <siva.rebbagondla@redpinesignals.com>
    Signed-off-by: Amitkumar Karwar <amit.karwar@redpinesignals.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
    Signed-off-by: Sasha Levin <alexander.levin@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 3c90e828db81b22f37fa7d37b9759cd3f1d305ba
Author: Siva Rebbagondla <siva.rebbagondla@redpinesignals.com>
Date:   Wed Apr 11 12:13:32 2018 +0530

    rsi: Fix 'invalid vdd' warning in mmc
    
    [ Upstream commit 78e450719c702784e42af6da912d3692fd3da0cb ]
    
    While performing cleanup, driver is messing with card->ocr
    value by not masking rocr against ocr_avail. Below panic
    is observed with some of the SDIO host controllers due to
    this. Issue is resolved by reverting incorrect modifications
    to vdd.
    
    [  927.423821] mmc1: Invalid vdd 0x1f
    [  927.423925] Modules linked in: rsi_sdio(+) cmac bnep arc4 rsi_91x
                   mac80211 cfg80211 btrsi rfcomm bluetooth ecdh_generic
    [  927.424073] CPU: 0 PID: 1624 Comm: insmod Tainted: G         W        4.15.0-1000-caracalla #1
    [  927.424075] Hardware name: Dell Inc. Edge Gateway    3003/      , BIOS 01.00.06 01/22/2018
    [  927.424082] RIP: 0010:sdhci_set_power_noreg+0xdd/0x190[sdhci]
    [  927.424085] RSP: 0018:ffffac3fc064b930 EFLAGS:  00010282
    [  927.424107] Call Trace:
    [  927.424118]  sdhci_set_power+0x5a/0x60 [sdhci]
    [  927.424125]  sdhci_set_ios+0x360/0x3b0 [sdhci]
    [  927.424133]  mmc_set_initial_state+0x92/0x120
    [  927.424137]  mmc_power_up.part.34+0x33/0x1d0
    [  927.424141]  mmc_power_up+0x17/0x20
    [  927.424147]  mmc_sdio_runtime_resume+0x2d/0x50
    [  927.424151]  mmc_runtime_resume+0x17/0x20
    [  927.424156]  __rpm_callback+0xc4/0x200
    [  927.424161]  ? idr_alloc_cyclic+0x57/0xd0
    [  927.424165]  ? mmc_runtime_suspend+0x20/0x20
    [  927.424169]  rpm_callback+0x24/0x80
    [  927.424172]  ? mmc_runtime_suspend+0x20/0x20
    [  927.424176]  rpm_resume+0x4b3/0x6c0
    [  927.424181]  __pm_runtime_resume+0x4e/0x80
    [  927.424188]  driver_probe_device+0x41/0x490
    [  927.424192]  __driver_attach+0xdf/0xf0
    [  927.424196]  ? driver_probe_device+0x490/0x490
    [  927.424201]  bus_for_each_dev+0x6c/0xc0
    [  927.424205]  driver_attach+0x1e/0x20
    [  927.424209]  bus_add_driver+0x1f4/0x270
    [  927.424217]  ? rsi_sdio_ack_intr+0x50/0x50 [rsi_sdio]
    [  927.424221]  driver_register+0x60/0xe0
    [  927.424227]  ? rsi_sdio_ack_intr+0x50/0x50 [rsi_sdio]
    [  927.424231]  sdio_register_driver+0x20/0x30
    [  927.424237]  rsi_module_init+0x16/0x40 [rsi_sdio]
    
    Signed-off-by: Siva Rebbagondla <siva.rebbagondla@redpinesignals.com>
    Signed-off-by: Amitkumar Karwar <amit.karwar@redpinesignals.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
    Signed-off-by: Sasha Levin <alexander.levin@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 0be8aa812cef251b4208bb51fadf3510ded74f33
Author: Siva Rebbagondla <siva.rebbagondla@redpinesignals.com>
Date:   Wed Apr 11 12:13:32 2018 +0530

    rsi: Fix 'invalid vdd' warning in mmc
    
    [ Upstream commit 78e450719c702784e42af6da912d3692fd3da0cb ]
    
    While performing cleanup, driver is messing with card->ocr
    value by not masking rocr against ocr_avail. Below panic
    is observed with some of the SDIO host controllers due to
    this. Issue is resolved by reverting incorrect modifications
    to vdd.
    
    [  927.423821] mmc1: Invalid vdd 0x1f
    [  927.423925] Modules linked in: rsi_sdio(+) cmac bnep arc4 rsi_91x
                   mac80211 cfg80211 btrsi rfcomm bluetooth ecdh_generic
    [  927.424073] CPU: 0 PID: 1624 Comm: insmod Tainted: G         W        4.15.0-1000-caracalla #1
    [  927.424075] Hardware name: Dell Inc. Edge Gateway    3003/      , BIOS 01.00.06 01/22/2018
    [  927.424082] RIP: 0010:sdhci_set_power_noreg+0xdd/0x190[sdhci]
    [  927.424085] RSP: 0018:ffffac3fc064b930 EFLAGS:  00010282
    [  927.424107] Call Trace:
    [  927.424118]  sdhci_set_power+0x5a/0x60 [sdhci]
    [  927.424125]  sdhci_set_ios+0x360/0x3b0 [sdhci]
    [  927.424133]  mmc_set_initial_state+0x92/0x120
    [  927.424137]  mmc_power_up.part.34+0x33/0x1d0
    [  927.424141]  mmc_power_up+0x17/0x20
    [  927.424147]  mmc_sdio_runtime_resume+0x2d/0x50
    [  927.424151]  mmc_runtime_resume+0x17/0x20
    [  927.424156]  __rpm_callback+0xc4/0x200
    [  927.424161]  ? idr_alloc_cyclic+0x57/0xd0
    [  927.424165]  ? mmc_runtime_suspend+0x20/0x20
    [  927.424169]  rpm_callback+0x24/0x80
    [  927.424172]  ? mmc_runtime_suspend+0x20/0x20
    [  927.424176]  rpm_resume+0x4b3/0x6c0
    [  927.424181]  __pm_runtime_resume+0x4e/0x80
    [  927.424188]  driver_probe_device+0x41/0x490
    [  927.424192]  __driver_attach+0xdf/0xf0
    [  927.424196]  ? driver_probe_device+0x490/0x490
    [  927.424201]  bus_for_each_dev+0x6c/0xc0
    [  927.424205]  driver_attach+0x1e/0x20
    [  927.424209]  bus_add_driver+0x1f4/0x270
    [  927.424217]  ? rsi_sdio_ack_intr+0x50/0x50 [rsi_sdio]
    [  927.424221]  driver_register+0x60/0xe0
    [  927.424227]  ? rsi_sdio_ack_intr+0x50/0x50 [rsi_sdio]
    [  927.424231]  sdio_register_driver+0x20/0x30
    [  927.424237]  rsi_module_init+0x16/0x40 [rsi_sdio]
    
    Signed-off-by: Siva Rebbagondla <siva.rebbagondla@redpinesignals.com>
    Signed-off-by: Amitkumar Karwar <amit.karwar@redpinesignals.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
    Signed-off-by: Sasha Levin <alexander.levin@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 5ea0308c83d12658897b364ebbb71a3d4966657a
Author: Siva Rebbagondla <siva.rebbagondla@redpinesignals.com>
Date:   Wed Apr 11 12:13:32 2018 +0530

    rsi: Fix 'invalid vdd' warning in mmc
    
    [ Upstream commit 78e450719c702784e42af6da912d3692fd3da0cb ]
    
    While performing cleanup, driver is messing with card->ocr
    value by not masking rocr against ocr_avail. Below panic
    is observed with some of the SDIO host controllers due to
    this. Issue is resolved by reverting incorrect modifications
    to vdd.
    
    [  927.423821] mmc1: Invalid vdd 0x1f
    [  927.423925] Modules linked in: rsi_sdio(+) cmac bnep arc4 rsi_91x
                   mac80211 cfg80211 btrsi rfcomm bluetooth ecdh_generic
    [  927.424073] CPU: 0 PID: 1624 Comm: insmod Tainted: G         W        4.15.0-1000-caracalla #1
    [  927.424075] Hardware name: Dell Inc. Edge Gateway    3003/      , BIOS 01.00.06 01/22/2018
    [  927.424082] RIP: 0010:sdhci_set_power_noreg+0xdd/0x190[sdhci]
    [  927.424085] RSP: 0018:ffffac3fc064b930 EFLAGS:  00010282
    [  927.424107] Call Trace:
    [  927.424118]  sdhci_set_power+0x5a/0x60 [sdhci]
    [  927.424125]  sdhci_set_ios+0x360/0x3b0 [sdhci]
    [  927.424133]  mmc_set_initial_state+0x92/0x120
    [  927.424137]  mmc_power_up.part.34+0x33/0x1d0
    [  927.424141]  mmc_power_up+0x17/0x20
    [  927.424147]  mmc_sdio_runtime_resume+0x2d/0x50
    [  927.424151]  mmc_runtime_resume+0x17/0x20
    [  927.424156]  __rpm_callback+0xc4/0x200
    [  927.424161]  ? idr_alloc_cyclic+0x57/0xd0
    [  927.424165]  ? mmc_runtime_suspend+0x20/0x20
    [  927.424169]  rpm_callback+0x24/0x80
    [  927.424172]  ? mmc_runtime_suspend+0x20/0x20
    [  927.424176]  rpm_resume+0x4b3/0x6c0
    [  927.424181]  __pm_runtime_resume+0x4e/0x80
    [  927.424188]  driver_probe_device+0x41/0x490
    [  927.424192]  __driver_attach+0xdf/0xf0
    [  927.424196]  ? driver_probe_device+0x490/0x490
    [  927.424201]  bus_for_each_dev+0x6c/0xc0
    [  927.424205]  driver_attach+0x1e/0x20
    [  927.424209]  bus_add_driver+0x1f4/0x270
    [  927.424217]  ? rsi_sdio_ack_intr+0x50/0x50 [rsi_sdio]
    [  927.424221]  driver_register+0x60/0xe0
    [  927.424227]  ? rsi_sdio_ack_intr+0x50/0x50 [rsi_sdio]
    [  927.424231]  sdio_register_driver+0x20/0x30
    [  927.424237]  rsi_module_init+0x16/0x40 [rsi_sdio]
    
    Signed-off-by: Siva Rebbagondla <siva.rebbagondla@redpinesignals.com>
    Signed-off-by: Amitkumar Karwar <amit.karwar@redpinesignals.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
    Signed-off-by: Sasha Levin <alexander.levin@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 469e764c4a3c7260b353b7bc1bd56c283cb001da
Author: Lukas Wunner <lukas@wunner.de>
Date:   Thu Jul 19 17:27:54 2018 -0500

    PCI: pciehp: Obey compulsory command delay after resume
    
    Upon resume from system sleep, the Slot Control register is written via:
    
      pci_pm_resume_noirq()
        pci_pm_default_resume_early()
          pci_restore_state()
            pci_restore_pcie_state()
    
    PCIe r4.0, sec 6.7.3.2 says that after "issuing a write transaction that
    targets any portion of the Port's Slot Control register, [...] software
    must wait for [the] command to complete before issuing the next command".
    
    pciehp currently fails to enforce that rule after the above-mentioned
    write.  Fix it.
    
    (Moving restoration of the Slot Control register to pciehp doesn't seem
    to make sense because the other PCIe hotplug drivers may need it as
    well.)
    
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

commit 7903782460ee1813d6779c968b28d0ac71b9b3ae
Author: Lukas Wunner <lukas@wunner.de>
Date:   Thu Jul 19 17:27:53 2018 -0500

    PCI: pciehp: Clear spurious events earlier on resume
    
    Thunderbolt hotplug ports that were occupied before system sleep resume
    with their downstream link in "off" state.  Only after the Thunderbolt
    controller has reestablished the PCIe tunnels does the link go up.
    As a result, a spurious Presence Detect Changed and/or Data Link Layer
    State Changed event occurs.
    
    The events are not immediately acted upon because tunnel reestablishment
    happens in the ->resume_noirq phase, when interrupts are still disabled.
    Also, notification of events may initially be disabled in the Slot
    Control register when coming out of system sleep and is reenabled in the
    ->resume_noirq phase through:
    
      pci_pm_resume_noirq()
        pci_pm_default_resume_early()
          pci_restore_state()
            pci_restore_pcie_state()
    
    It is not guaranteed that the events are acted upon at all:  PCIe r4.0,
    sec 6.7.3.4 says that "a port may optionally send an MSI when there are
    hot-plug events that occur while interrupt generation is disabled, and
    interrupt generation is subsequently enabled."  Note the "optionally".
    
    If an MSI is sent, pciehp will gratuitously turn the slot off and back
    on once the ->resume_early phase has commenced.
    
    If an MSI is not sent, the extant, unacknowledged events in the Slot
    Status register will prevent future notification of presence or link
    changes.
    
    Commit 13c65840feab ("PCI: pciehp: Clear Presence Detect and Data Link
    Layer Status Changed on resume") fixed the latter by clearing the events
    in the ->resume phase.  Move this to the ->resume_noirq phase to also
    fix the gratuitous disable/enablement of the slot.
    
    The commit further restored the Slot Control register in the ->resume
    phase, but that's dispensable because as shown above it's already been
    done in the ->resume_noirq phase.
    
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Mika Westerberg <mika.westerberg@linux.intel.com>

commit 44c7b7c90d1dabb975bbf9780016e6fca192a973
Author: Lyude Paul <lyude@redhat.com>
Date:   Fri Jul 13 13:06:33 2018 -0400

    drm/nouveau: Avoid looping through fake MST connectors
    
    commit 37afe55b4ae0600deafe7c0e0e658593c4754f1b upstream.
    
    When MST and atomic were introduced to nouveau, another structure that
    could contain a drm_connector embedded within it was introduced; struct
    nv50_mstc. This meant that we no longer would be able to simply loop
    through our connector list and assume that nouveau_connector() would
    return a proper pointer for each connector, since the assertion that
    all connectors coming from nouveau have a full nouveau_connector struct
    became invalid.
    
    Unfortunately, none of the actual code that looped through connectors
    ever got updated, which means that we've been causing invalid memory
    accesses for quite a while now.
    
    An example that was caught by KASAN:
    
    [  201.038698] ==================================================================
    [  201.038792] BUG: KASAN: slab-out-of-bounds in nvif_notify_get+0x190/0x1a0 [nouveau]
    [  201.038797] Read of size 4 at addr ffff88076738c650 by task kworker/0:3/718
    [  201.038800]
    [  201.038822] CPU: 0 PID: 718 Comm: kworker/0:3 Tainted: G           O      4.18.0-rc4Lyude-Test+ #1
    [  201.038825] Hardware name: LENOVO 20EQS64N0B/20EQS64N0B, BIOS N1EET78W (1.51 ) 05/18/2018
    [  201.038882] Workqueue: events nouveau_display_hpd_work [nouveau]
    [  201.038887] Call Trace:
    [  201.038894]  dump_stack+0xa4/0xfd
    [  201.038900]  print_address_description+0x71/0x239
    [  201.038929]  ? nvif_notify_get+0x190/0x1a0 [nouveau]
    [  201.038935]  kasan_report.cold.6+0x242/0x2fe
    [  201.038942]  __asan_report_load4_noabort+0x19/0x20
    [  201.038970]  nvif_notify_get+0x190/0x1a0 [nouveau]
    [  201.038998]  ? nvif_notify_put+0x1f0/0x1f0 [nouveau]
    [  201.039003]  ? kmsg_dump_rewind_nolock+0xe4/0xe4
    [  201.039049]  nouveau_display_init.cold.12+0x34/0x39 [nouveau]
    [  201.039089]  ? nouveau_user_framebuffer_create+0x120/0x120 [nouveau]
    [  201.039133]  nouveau_display_resume+0x5c0/0x810 [nouveau]
    [  201.039173]  ? nvkm_client_ioctl+0x20/0x20 [nouveau]
    [  201.039215]  nouveau_do_resume+0x19f/0x570 [nouveau]
    [  201.039256]  nouveau_pmops_runtime_resume+0xd8/0x2a0 [nouveau]
    [  201.039264]  pci_pm_runtime_resume+0x130/0x250
    [  201.039269]  ? pci_restore_standard_config+0x70/0x70
    [  201.039275]  __rpm_callback+0x1f2/0x5d0
    [  201.039279]  ? rpm_resume+0x560/0x18a0
    [  201.039283]  ? pci_restore_standard_config+0x70/0x70
    [  201.039287]  ? pci_restore_standard_config+0x70/0x70
    [  201.039291]  ? pci_restore_standard_config+0x70/0x70
    [  201.039296]  rpm_callback+0x175/0x210
    [  201.039300]  ? pci_restore_standard_config+0x70/0x70
    [  201.039305]  rpm_resume+0xcc3/0x18a0
    [  201.039312]  ? rpm_callback+0x210/0x210
    [  201.039317]  ? __pm_runtime_resume+0x9e/0x100
    [  201.039322]  ? kasan_check_write+0x14/0x20
    [  201.039326]  ? do_raw_spin_lock+0xc2/0x1c0
    [  201.039333]  __pm_runtime_resume+0xac/0x100
    [  201.039374]  nouveau_display_hpd_work+0x67/0x1f0 [nouveau]
    [  201.039380]  process_one_work+0x7a0/0x14d0
    [  201.039388]  ? cancel_delayed_work_sync+0x20/0x20
    [  201.039392]  ? lock_acquire+0x113/0x310
    [  201.039398]  ? kasan_check_write+0x14/0x20
    [  201.039402]  ? do_raw_spin_lock+0xc2/0x1c0
    [  201.039409]  worker_thread+0x86/0xb50
    [  201.039418]  kthread+0x2e9/0x3a0
    [  201.039422]  ? process_one_work+0x14d0/0x14d0
    [  201.039426]  ? kthread_create_worker_on_cpu+0xc0/0xc0
    [  201.039431]  ret_from_fork+0x3a/0x50
    [  201.039441]
    [  201.039444] Allocated by task 79:
    [  201.039449]  save_stack+0x43/0xd0
    [  201.039452]  kasan_kmalloc+0xc4/0xe0
    [  201.039456]  kmem_cache_alloc_trace+0x10a/0x260
    [  201.039494]  nv50_mstm_add_connector+0x9a/0x340 [nouveau]
    [  201.039504]  drm_dp_add_port+0xff5/0x1fc0 [drm_kms_helper]
    [  201.039511]  drm_dp_send_link_address+0x4a7/0x740 [drm_kms_helper]
    [  201.039518]  drm_dp_check_and_send_link_address+0x1a7/0x210 [drm_kms_helper]
    [  201.039525]  drm_dp_mst_link_probe_work+0x71/0xb0 [drm_kms_helper]
    [  201.039529]  process_one_work+0x7a0/0x14d0
    [  201.039533]  worker_thread+0x86/0xb50
    [  201.039537]  kthread+0x2e9/0x3a0
    [  201.039541]  ret_from_fork+0x3a/0x50
    [  201.039543]
    [  201.039546] Freed by task 0:
    [  201.039549] (stack is not available)
    [  201.039551]
    [  201.039555] The buggy address belongs to the object at ffff88076738c1a8
                                     which belongs to the cache kmalloc-2048 of size 2048
    [  201.039559] The buggy address is located 1192 bytes inside of
                                     2048-byte region [ffff88076738c1a8, ffff88076738c9a8)
    [  201.039563] The buggy address belongs to the page:
    [  201.039567] page:ffffea001d9ce200 count:1 mapcount:0 mapping:ffff88084000d0c0 index:0x0 compound_mapcount: 0
    [  201.039573] flags: 0x8000000000008100(slab|head)
    [  201.039578] raw: 8000000000008100 ffffea001da3be08 ffffea001da25a08 ffff88084000d0c0
    [  201.039582] raw: 0000000000000000 00000000000d000d 00000001ffffffff 0000000000000000
    [  201.039585] page dumped because: kasan: bad access detected
    [  201.039588]
    [  201.039591] Memory state around the buggy address:
    [  201.039594]  ffff88076738c500: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    [  201.039598]  ffff88076738c580: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    [  201.039601] >ffff88076738c600: 00 00 00 00 00 00 00 00 00 00 fc fc fc fc fc fc
    [  201.039604]                                                  ^
    [  201.039607]  ffff88076738c680: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
    [  201.039611]  ffff88076738c700: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
    [  201.039613] ==================================================================
    
    Signed-off-by: Lyude Paul <lyude@redhat.com>
    Cc: stable@vger.kernel.org
    Cc: Karol Herbst <karolherbst@gmail.com>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit dd1363ca743eebf1dd7ccb6f9010b9d6de3afafc
Author: Lyude Paul <lyude@redhat.com>
Date:   Fri Jul 13 13:06:33 2018 -0400

    drm/nouveau: Avoid looping through fake MST connectors
    
    commit 37afe55b4ae0600deafe7c0e0e658593c4754f1b upstream.
    
    When MST and atomic were introduced to nouveau, another structure that
    could contain a drm_connector embedded within it was introduced; struct
    nv50_mstc. This meant that we no longer would be able to simply loop
    through our connector list and assume that nouveau_connector() would
    return a proper pointer for each connector, since the assertion that
    all connectors coming from nouveau have a full nouveau_connector struct
    became invalid.
    
    Unfortunately, none of the actual code that looped through connectors
    ever got updated, which means that we've been causing invalid memory
    accesses for quite a while now.
    
    An example that was caught by KASAN:
    
    [  201.038698] ==================================================================
    [  201.038792] BUG: KASAN: slab-out-of-bounds in nvif_notify_get+0x190/0x1a0 [nouveau]
    [  201.038797] Read of size 4 at addr ffff88076738c650 by task kworker/0:3/718
    [  201.038800]
    [  201.038822] CPU: 0 PID: 718 Comm: kworker/0:3 Tainted: G           O      4.18.0-rc4Lyude-Test+ #1
    [  201.038825] Hardware name: LENOVO 20EQS64N0B/20EQS64N0B, BIOS N1EET78W (1.51 ) 05/18/2018
    [  201.038882] Workqueue: events nouveau_display_hpd_work [nouveau]
    [  201.038887] Call Trace:
    [  201.038894]  dump_stack+0xa4/0xfd
    [  201.038900]  print_address_description+0x71/0x239
    [  201.038929]  ? nvif_notify_get+0x190/0x1a0 [nouveau]
    [  201.038935]  kasan_report.cold.6+0x242/0x2fe
    [  201.038942]  __asan_report_load4_noabort+0x19/0x20
    [  201.038970]  nvif_notify_get+0x190/0x1a0 [nouveau]
    [  201.038998]  ? nvif_notify_put+0x1f0/0x1f0 [nouveau]
    [  201.039003]  ? kmsg_dump_rewind_nolock+0xe4/0xe4
    [  201.039049]  nouveau_display_init.cold.12+0x34/0x39 [nouveau]
    [  201.039089]  ? nouveau_user_framebuffer_create+0x120/0x120 [nouveau]
    [  201.039133]  nouveau_display_resume+0x5c0/0x810 [nouveau]
    [  201.039173]  ? nvkm_client_ioctl+0x20/0x20 [nouveau]
    [  201.039215]  nouveau_do_resume+0x19f/0x570 [nouveau]
    [  201.039256]  nouveau_pmops_runtime_resume+0xd8/0x2a0 [nouveau]
    [  201.039264]  pci_pm_runtime_resume+0x130/0x250
    [  201.039269]  ? pci_restore_standard_config+0x70/0x70
    [  201.039275]  __rpm_callback+0x1f2/0x5d0
    [  201.039279]  ? rpm_resume+0x560/0x18a0
    [  201.039283]  ? pci_restore_standard_config+0x70/0x70
    [  201.039287]  ? pci_restore_standard_config+0x70/0x70
    [  201.039291]  ? pci_restore_standard_config+0x70/0x70
    [  201.039296]  rpm_callback+0x175/0x210
    [  201.039300]  ? pci_restore_standard_config+0x70/0x70
    [  201.039305]  rpm_resume+0xcc3/0x18a0
    [  201.039312]  ? rpm_callback+0x210/0x210
    [  201.039317]  ? __pm_runtime_resume+0x9e/0x100
    [  201.039322]  ? kasan_check_write+0x14/0x20
    [  201.039326]  ? do_raw_spin_lock+0xc2/0x1c0
    [  201.039333]  __pm_runtime_resume+0xac/0x100
    [  201.039374]  nouveau_display_hpd_work+0x67/0x1f0 [nouveau]
    [  201.039380]  process_one_work+0x7a0/0x14d0
    [  201.039388]  ? cancel_delayed_work_sync+0x20/0x20
    [  201.039392]  ? lock_acquire+0x113/0x310
    [  201.039398]  ? kasan_check_write+0x14/0x20
    [  201.039402]  ? do_raw_spin_lock+0xc2/0x1c0
    [  201.039409]  worker_thread+0x86/0xb50
    [  201.039418]  kthread+0x2e9/0x3a0
    [  201.039422]  ? process_one_work+0x14d0/0x14d0
    [  201.039426]  ? kthread_create_worker_on_cpu+0xc0/0xc0
    [  201.039431]  ret_from_fork+0x3a/0x50
    [  201.039441]
    [  201.039444] Allocated by task 79:
    [  201.039449]  save_stack+0x43/0xd0
    [  201.039452]  kasan_kmalloc+0xc4/0xe0
    [  201.039456]  kmem_cache_alloc_trace+0x10a/0x260
    [  201.039494]  nv50_mstm_add_connector+0x9a/0x340 [nouveau]
    [  201.039504]  drm_dp_add_port+0xff5/0x1fc0 [drm_kms_helper]
    [  201.039511]  drm_dp_send_link_address+0x4a7/0x740 [drm_kms_helper]
    [  201.039518]  drm_dp_check_and_send_link_address+0x1a7/0x210 [drm_kms_helper]
    [  201.039525]  drm_dp_mst_link_probe_work+0x71/0xb0 [drm_kms_helper]
    [  201.039529]  process_one_work+0x7a0/0x14d0
    [  201.039533]  worker_thread+0x86/0xb50
    [  201.039537]  kthread+0x2e9/0x3a0
    [  201.039541]  ret_from_fork+0x3a/0x50
    [  201.039543]
    [  201.039546] Freed by task 0:
    [  201.039549] (stack is not available)
    [  201.039551]
    [  201.039555] The buggy address belongs to the object at ffff88076738c1a8
                                     which belongs to the cache kmalloc-2048 of size 2048
    [  201.039559] The buggy address is located 1192 bytes inside of
                                     2048-byte region [ffff88076738c1a8, ffff88076738c9a8)
    [  201.039563] The buggy address belongs to the page:
    [  201.039567] page:ffffea001d9ce200 count:1 mapcount:0 mapping:ffff88084000d0c0 index:0x0 compound_mapcount: 0
    [  201.039573] flags: 0x8000000000008100(slab|head)
    [  201.039578] raw: 8000000000008100 ffffea001da3be08 ffffea001da25a08 ffff88084000d0c0
    [  201.039582] raw: 0000000000000000 00000000000d000d 00000001ffffffff 0000000000000000
    [  201.039585] page dumped because: kasan: bad access detected
    [  201.039588]
    [  201.039591] Memory state around the buggy address:
    [  201.039594]  ffff88076738c500: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    [  201.039598]  ffff88076738c580: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    [  201.039601] >ffff88076738c600: 00 00 00 00 00 00 00 00 00 00 fc fc fc fc fc fc
    [  201.039604]                                                  ^
    [  201.039607]  ffff88076738c680: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
    [  201.039611]  ffff88076738c700: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
    [  201.039613] ==================================================================
    
    Signed-off-by: Lyude Paul <lyude@redhat.com>
    Cc: stable@vger.kernel.org
    Cc: Karol Herbst <karolherbst@gmail.com>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 37afe55b4ae0600deafe7c0e0e658593c4754f1b
Author: Lyude Paul <lyude@redhat.com>
Date:   Fri Jul 13 13:06:33 2018 -0400

    drm/nouveau: Avoid looping through fake MST connectors
    
    When MST and atomic were introduced to nouveau, another structure that
    could contain a drm_connector embedded within it was introduced; struct
    nv50_mstc. This meant that we no longer would be able to simply loop
    through our connector list and assume that nouveau_connector() would
    return a proper pointer for each connector, since the assertion that
    all connectors coming from nouveau have a full nouveau_connector struct
    became invalid.
    
    Unfortunately, none of the actual code that looped through connectors
    ever got updated, which means that we've been causing invalid memory
    accesses for quite a while now.
    
    An example that was caught by KASAN:
    
    [  201.038698] ==================================================================
    [  201.038792] BUG: KASAN: slab-out-of-bounds in nvif_notify_get+0x190/0x1a0 [nouveau]
    [  201.038797] Read of size 4 at addr ffff88076738c650 by task kworker/0:3/718
    [  201.038800]
    [  201.038822] CPU: 0 PID: 718 Comm: kworker/0:3 Tainted: G           O      4.18.0-rc4Lyude-Test+ #1
    [  201.038825] Hardware name: LENOVO 20EQS64N0B/20EQS64N0B, BIOS N1EET78W (1.51 ) 05/18/2018
    [  201.038882] Workqueue: events nouveau_display_hpd_work [nouveau]
    [  201.038887] Call Trace:
    [  201.038894]  dump_stack+0xa4/0xfd
    [  201.038900]  print_address_description+0x71/0x239
    [  201.038929]  ? nvif_notify_get+0x190/0x1a0 [nouveau]
    [  201.038935]  kasan_report.cold.6+0x242/0x2fe
    [  201.038942]  __asan_report_load4_noabort+0x19/0x20
    [  201.038970]  nvif_notify_get+0x190/0x1a0 [nouveau]
    [  201.038998]  ? nvif_notify_put+0x1f0/0x1f0 [nouveau]
    [  201.039003]  ? kmsg_dump_rewind_nolock+0xe4/0xe4
    [  201.039049]  nouveau_display_init.cold.12+0x34/0x39 [nouveau]
    [  201.039089]  ? nouveau_user_framebuffer_create+0x120/0x120 [nouveau]
    [  201.039133]  nouveau_display_resume+0x5c0/0x810 [nouveau]
    [  201.039173]  ? nvkm_client_ioctl+0x20/0x20 [nouveau]
    [  201.039215]  nouveau_do_resume+0x19f/0x570 [nouveau]
    [  201.039256]  nouveau_pmops_runtime_resume+0xd8/0x2a0 [nouveau]
    [  201.039264]  pci_pm_runtime_resume+0x130/0x250
    [  201.039269]  ? pci_restore_standard_config+0x70/0x70
    [  201.039275]  __rpm_callback+0x1f2/0x5d0
    [  201.039279]  ? rpm_resume+0x560/0x18a0
    [  201.039283]  ? pci_restore_standard_config+0x70/0x70
    [  201.039287]  ? pci_restore_standard_config+0x70/0x70
    [  201.039291]  ? pci_restore_standard_config+0x70/0x70
    [  201.039296]  rpm_callback+0x175/0x210
    [  201.039300]  ? pci_restore_standard_config+0x70/0x70
    [  201.039305]  rpm_resume+0xcc3/0x18a0
    [  201.039312]  ? rpm_callback+0x210/0x210
    [  201.039317]  ? __pm_runtime_resume+0x9e/0x100
    [  201.039322]  ? kasan_check_write+0x14/0x20
    [  201.039326]  ? do_raw_spin_lock+0xc2/0x1c0
    [  201.039333]  __pm_runtime_resume+0xac/0x100
    [  201.039374]  nouveau_display_hpd_work+0x67/0x1f0 [nouveau]
    [  201.039380]  process_one_work+0x7a0/0x14d0
    [  201.039388]  ? cancel_delayed_work_sync+0x20/0x20
    [  201.039392]  ? lock_acquire+0x113/0x310
    [  201.039398]  ? kasan_check_write+0x14/0x20
    [  201.039402]  ? do_raw_spin_lock+0xc2/0x1c0
    [  201.039409]  worker_thread+0x86/0xb50
    [  201.039418]  kthread+0x2e9/0x3a0
    [  201.039422]  ? process_one_work+0x14d0/0x14d0
    [  201.039426]  ? kthread_create_worker_on_cpu+0xc0/0xc0
    [  201.039431]  ret_from_fork+0x3a/0x50
    [  201.039441]
    [  201.039444] Allocated by task 79:
    [  201.039449]  save_stack+0x43/0xd0
    [  201.039452]  kasan_kmalloc+0xc4/0xe0
    [  201.039456]  kmem_cache_alloc_trace+0x10a/0x260
    [  201.039494]  nv50_mstm_add_connector+0x9a/0x340 [nouveau]
    [  201.039504]  drm_dp_add_port+0xff5/0x1fc0 [drm_kms_helper]
    [  201.039511]  drm_dp_send_link_address+0x4a7/0x740 [drm_kms_helper]
    [  201.039518]  drm_dp_check_and_send_link_address+0x1a7/0x210 [drm_kms_helper]
    [  201.039525]  drm_dp_mst_link_probe_work+0x71/0xb0 [drm_kms_helper]
    [  201.039529]  process_one_work+0x7a0/0x14d0
    [  201.039533]  worker_thread+0x86/0xb50
    [  201.039537]  kthread+0x2e9/0x3a0
    [  201.039541]  ret_from_fork+0x3a/0x50
    [  201.039543]
    [  201.039546] Freed by task 0:
    [  201.039549] (stack is not available)
    [  201.039551]
    [  201.039555] The buggy address belongs to the object at ffff88076738c1a8
                                     which belongs to the cache kmalloc-2048 of size 2048
    [  201.039559] The buggy address is located 1192 bytes inside of
                                     2048-byte region [ffff88076738c1a8, ffff88076738c9a8)
    [  201.039563] The buggy address belongs to the page:
    [  201.039567] page:ffffea001d9ce200 count:1 mapcount:0 mapping:ffff88084000d0c0 index:0x0 compound_mapcount: 0
    [  201.039573] flags: 0x8000000000008100(slab|head)
    [  201.039578] raw: 8000000000008100 ffffea001da3be08 ffffea001da25a08 ffff88084000d0c0
    [  201.039582] raw: 0000000000000000 00000000000d000d 00000001ffffffff 0000000000000000
    [  201.039585] page dumped because: kasan: bad access detected
    [  201.039588]
    [  201.039591] Memory state around the buggy address:
    [  201.039594]  ffff88076738c500: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    [  201.039598]  ffff88076738c580: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    [  201.039601] >ffff88076738c600: 00 00 00 00 00 00 00 00 00 00 fc fc fc fc fc fc
    [  201.039604]                                                  ^
    [  201.039607]  ffff88076738c680: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
    [  201.039611]  ffff88076738c700: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
    [  201.039613] ==================================================================
    
    Signed-off-by: Lyude Paul <lyude@redhat.com>
    Cc: stable@vger.kernel.org
    Cc: Karol Herbst <karolherbst@gmail.com>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

commit e368fc75c190a4ad5853e4ec5a0c8acf86bd5119
Author: Ayan Kumar Halder <ayan.halder@arm.com>
Date:   Tue May 15 17:04:19 2018 +0100

    drm/arm/malidp: Added the late system pm functions
    
    malidp_pm_suspend_late checks if the runtime status is not suspended
    and if so, invokes malidp_runtime_pm_suspend which disables the
    display engine/core interrupts and the clocks. It sets the runtime status
    as suspended.
    
    The difference between suspend() and suspend_late() is as follows:-
    1. suspend() makes the device quiescent. In our case, we invoke the DRM
    helper which disables the CRTC. This would have invoked runtime pm
    suspend but the system suspend process disables runtime pm.
    2. suspend_late() It continues the suspend operations of the drm device
    which was started by suspend(). In our case, it performs the same functionality
    as runtime_suspend().
    
    The complimentary functions are resume() and resume_early(). In the case of
    resume_early(), we invoke malidp_runtime_pm_resume() which enables the clocks
    and the interrupts. It sets the runtime status as active. If the device was
    in runtime suspend mode before system suspend was called, pm_runtime_work()
    will put the device back in runtime suspended mode( after the complete system
    has been resumed).
    
    Signed-off-by: Ayan Kumar Halder <ayan.halder@arm.com>
    Acked-by: Liviu Dudau <liviu.dudau@arm.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

commit fbcc454e8a350b929cb04fbcfdfa72fab37acf38
Author: Ayan Kumar Halder <ayan.halder@arm.com>
Date:   Tue May 15 17:04:17 2018 +0100

    drm/arm/malidp: Enable/disable interrupts in runtime pm
    
    Display and scaling engine interrupts need to be disabled when the
    runtime pm invokes malidp_runtime_pm_suspend(). Conversely, they
    need to be enabled in malidp_runtime_pm_resume().
    
    This patch depends on:
    https://lkml.org/lkml/2017/5/15/695
    
    Reported-by: Alexandru-Cosmin Gheorghe <Alexandru-Cosmin.Gheorghe@arm.com>
    Signed-off-by: Alexandru-Cosmin Gheorghe <Alexandru-Cosmin.Gheorghe@arm.com>
    Signed-off-by: Ayan Kumar Halder <ayan.halder@arm.com>
    Acked-by: Liviu Dudau <liviu.dudau@arm.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

commit ff8fc26a764acdf5e0a2f86430bcb96c7b4eebec
Author: Ayan Kumar Halder <ayan.halder@arm.com>
Date:   Tue May 15 17:04:16 2018 +0100

    drm/arm/malidp: Split malidp interrupt initialization functions.
    
    Malidp uses two interrupts ie 1. se_irq - used for memory writeback.
     and 2. de_irq - used for display output.
    Extract the hardware initialization part from malidp interrupt registration
    ie (malidp_de_irq_init()/ malidp_se_irq_init()) into a separate function
    (ie malidp_de_irq_hw_init()/malidp_se_irq_hw_init())
    which will be later invoked from runtime_pm_resume function when it needs
    to re-enable the interrupts.
    
    Signed-off-by: Ayan Kumar Halder <ayan.halder@arm.com>
    Acked-by: Liviu Dudau <liviu.dudau@arm.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

commit 37988bf8e56fcef562c054c3675de7241d1eda9a
Author: Lukas Wunner <lukas@wunner.de>
Date:   Sun Feb 11 10:38:28 2018 +0100

    drm/radeon: Fix deadlock on runtime suspend
    
    commit 15734feff2bdac24aa3266c437cffa42851990e3 upstream.
    
    radeon's ->runtime_suspend hook calls drm_kms_helper_poll_disable(),
    which waits for the output poll worker to finish if it's running.
    
    The output poll worker meanwhile calls pm_runtime_get_sync() in
    radeon's ->detect hooks, which waits for the ongoing suspend to finish,
    causing a deadlock.
    
    Fix by not acquiring a runtime PM ref if the ->detect hooks are called
    in the output poll worker's context.  This is safe because the poll
    worker is only enabled while runtime active and we know that
    ->runtime_suspend waits for it to finish.
    
    Stack trace for posterity:
    
      INFO: task kworker/0:3:31847 blocked for more than 120 seconds
      Workqueue: events output_poll_execute [drm_kms_helper]
      Call Trace:
       schedule+0x3c/0x90
       rpm_resume+0x1e2/0x690
       __pm_runtime_resume+0x3f/0x60
       radeon_lvds_detect+0x39/0xf0 [radeon]
       output_poll_execute+0xda/0x1e0 [drm_kms_helper]
       process_one_work+0x14b/0x440
       worker_thread+0x48/0x4a0
    
      INFO: task kworker/2:0:10493 blocked for more than 120 seconds.
      Workqueue: pm pm_runtime_work
      Call Trace:
       schedule+0x3c/0x90
       schedule_timeout+0x1b3/0x240
       wait_for_common+0xc2/0x180
       wait_for_completion+0x1d/0x20
       flush_work+0xfc/0x1a0
       __cancel_work_timer+0xa5/0x1d0
       cancel_delayed_work_sync+0x13/0x20
       drm_kms_helper_poll_disable+0x1f/0x30 [drm_kms_helper]
       radeon_pmops_runtime_suspend+0x3d/0xa0 [radeon]
       pci_pm_runtime_suspend+0x61/0x1a0
       vga_switcheroo_runtime_suspend+0x21/0x70
       __rpm_callback+0x32/0x70
       rpm_callback+0x24/0x80
       rpm_suspend+0x12b/0x640
       pm_runtime_work+0x6f/0xb0
       process_one_work+0x14b/0x440
       worker_thread+0x48/0x4a0
    
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=94147
    Fixes: 10ebc0bc0934 ("drm/radeon: add runtime PM support (v2)")
    Cc: Ismo Toijala <ismo.toijala@gmail.com>
    Cc: Alex Deucher <alexander.deucher@amd.com>
    Cc: Dave Airlie <airlied@redhat.com>
    Reviewed-by: Lyude Paul <lyude@redhat.com>
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Link: https://patchwork.freedesktop.org/patch/msgid/64ea02c44f91dda19bc563902b97bbc699040392.1518338789.git.lukas@wunner.de
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit 2bd9bd288e536e299b954416aa55ec610efbde06
Author: Lukas Wunner <lukas@wunner.de>
Date:   Sun Feb 11 10:38:28 2018 +0100

    drm/nouveau: Fix deadlock on runtime suspend
    
    commit d61a5c1063515e855bedb1b81e20e50b0ac3541e upstream.
    
    nouveau's ->runtime_suspend hook calls drm_kms_helper_poll_disable(),
    which waits for the output poll worker to finish if it's running.
    
    The output poll worker meanwhile calls pm_runtime_get_sync() in
    nouveau_connector_detect() which waits for the ongoing suspend to finish,
    causing a deadlock.
    
    Fix by not acquiring a runtime PM ref if nouveau_connector_detect() is
    called in the output poll worker's context.  This is safe because
    the poll worker is only enabled while runtime active and we know that
    ->runtime_suspend waits for it to finish.
    
    Other contexts calling nouveau_connector_detect() do require a runtime
    PM ref, these comprise:
    
      status_store() drm sysfs interface
      ->fill_modes drm callback
      drm_fb_helper_probe_connector_modes()
      drm_mode_getconnector()
      nouveau_connector_hotplug()
      nouveau_display_hpd_work()
      nv17_tv_set_property()
    
    Stack trace for posterity:
    
      INFO: task kworker/0:1:58 blocked for more than 120 seconds.
      Workqueue: events output_poll_execute [drm_kms_helper]
      Call Trace:
       schedule+0x28/0x80
       rpm_resume+0x107/0x6e0
       __pm_runtime_resume+0x47/0x70
       nouveau_connector_detect+0x7e/0x4a0 [nouveau]
       nouveau_connector_detect_lvds+0x132/0x180 [nouveau]
       drm_helper_probe_detect_ctx+0x85/0xd0 [drm_kms_helper]
       output_poll_execute+0x11e/0x1c0 [drm_kms_helper]
       process_one_work+0x184/0x380
       worker_thread+0x2e/0x390
    
      INFO: task kworker/0:2:252 blocked for more than 120 seconds.
      Workqueue: pm pm_runtime_work
      Call Trace:
       schedule+0x28/0x80
       schedule_timeout+0x1e3/0x370
       wait_for_completion+0x123/0x190
       flush_work+0x142/0x1c0
       nouveau_pmops_runtime_suspend+0x7e/0xd0 [nouveau]
       pci_pm_runtime_suspend+0x5c/0x180
       vga_switcheroo_runtime_suspend+0x1e/0xa0
       __rpm_callback+0xc1/0x200
       rpm_callback+0x1f/0x70
       rpm_suspend+0x13c/0x640
       pm_runtime_work+0x6e/0x90
       process_one_work+0x184/0x380
       worker_thread+0x2e/0x390
    
    Bugzilla: https://bugs.archlinux.org/task/53497
    Bugzilla: https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=870523
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=70388#c33
    Fixes: 5addcf0a5f0f ("nouveau: add runtime PM support (v0.9)")
    Cc: Ben Skeggs <bskeggs@redhat.com>
    Cc: Dave Airlie <airlied@redhat.com>
    Reviewed-by: Lyude Paul <lyude@redhat.com>
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Link: https://patchwork.freedesktop.org/patch/msgid/b7d2cbb609a80f59ccabfdf479b9d5907c603ea1.1518338789.git.lukas@wunner.de
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit 728a9dc61f132eb567f58c234e11ef80a3519cc0
Author: Tony Lindgren <tony@atomide.com>
Date:   Thu May 17 11:29:50 2018 -0700

    wlcore: sdio: Fix flakey SDIO runtime PM handling
    
    We can have pm_runtime_get_sync() return 1, and we can have
    pm_runtime_put_sync() return -EBUSY. See rpm_suspend() and
    rpm_resume() for more information.
    
    Fix the issue by returning 0 from wl12xx_sdio_power_on() on success.
    And use pm_runtime_put() instead of pm_runtime_put_sync() for
    wl12xx_sdio_power_off(), then the MMC subsystem will idle the bus
    when suitable.
    
    Otherwise wlcore can sometimes get confused and may report bogus
    errors and WLAN connection can fail.
    
    Note that while wlcore checks the return value for wl1271_power_on(),
    the return value is ignored for wl1271_power_off(). Let's fix them
    both though to avoid further confusion in the future.
    
    Fixes: 60f36637bbbd ("wlcore: sdio: allow pm to handle sdio power")
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>

commit 78e450719c702784e42af6da912d3692fd3da0cb
Author: Siva Rebbagondla <siva.rebbagondla@redpinesignals.com>
Date:   Wed Apr 11 12:13:32 2018 +0530

    rsi: Fix 'invalid vdd' warning in mmc
    
    While performing cleanup, driver is messing with card->ocr
    value by not masking rocr against ocr_avail. Below panic
    is observed with some of the SDIO host controllers due to
    this. Issue is resolved by reverting incorrect modifications
    to vdd.
    
    [  927.423821] mmc1: Invalid vdd 0x1f
    [  927.423925] Modules linked in: rsi_sdio(+) cmac bnep arc4 rsi_91x
                   mac80211 cfg80211 btrsi rfcomm bluetooth ecdh_generic
    [  927.424073] CPU: 0 PID: 1624 Comm: insmod Tainted: G         W        4.15.0-1000-caracalla #1
    [  927.424075] Hardware name: Dell Inc. Edge Gateway    3003/      , BIOS 01.00.06 01/22/2018
    [  927.424082] RIP: 0010:sdhci_set_power_noreg+0xdd/0x190[sdhci]
    [  927.424085] RSP: 0018:ffffac3fc064b930 EFLAGS:  00010282
    [  927.424107] Call Trace:
    [  927.424118]  sdhci_set_power+0x5a/0x60 [sdhci]
    [  927.424125]  sdhci_set_ios+0x360/0x3b0 [sdhci]
    [  927.424133]  mmc_set_initial_state+0x92/0x120
    [  927.424137]  mmc_power_up.part.34+0x33/0x1d0
    [  927.424141]  mmc_power_up+0x17/0x20
    [  927.424147]  mmc_sdio_runtime_resume+0x2d/0x50
    [  927.424151]  mmc_runtime_resume+0x17/0x20
    [  927.424156]  __rpm_callback+0xc4/0x200
    [  927.424161]  ? idr_alloc_cyclic+0x57/0xd0
    [  927.424165]  ? mmc_runtime_suspend+0x20/0x20
    [  927.424169]  rpm_callback+0x24/0x80
    [  927.424172]  ? mmc_runtime_suspend+0x20/0x20
    [  927.424176]  rpm_resume+0x4b3/0x6c0
    [  927.424181]  __pm_runtime_resume+0x4e/0x80
    [  927.424188]  driver_probe_device+0x41/0x490
    [  927.424192]  __driver_attach+0xdf/0xf0
    [  927.424196]  ? driver_probe_device+0x490/0x490
    [  927.424201]  bus_for_each_dev+0x6c/0xc0
    [  927.424205]  driver_attach+0x1e/0x20
    [  927.424209]  bus_add_driver+0x1f4/0x270
    [  927.424217]  ? rsi_sdio_ack_intr+0x50/0x50 [rsi_sdio]
    [  927.424221]  driver_register+0x60/0xe0
    [  927.424227]  ? rsi_sdio_ack_intr+0x50/0x50 [rsi_sdio]
    [  927.424231]  sdio_register_driver+0x20/0x30
    [  927.424237]  rsi_module_init+0x16/0x40 [rsi_sdio]
    
    Signed-off-by: Siva Rebbagondla <siva.rebbagondla@redpinesignals.com>
    Signed-off-by: Amitkumar Karwar <amit.karwar@redpinesignals.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>

commit bacc51c36ebdc39013c12d02cc9090e387c768ac
Author: Lukas Wunner <lukas@wunner.de>
Date:   Sun Feb 11 10:38:28 2018 +0100

    drm/radeon: Fix deadlock on runtime suspend
    
    commit 15734feff2bdac24aa3266c437cffa42851990e3 upstream.
    
    radeon's ->runtime_suspend hook calls drm_kms_helper_poll_disable(),
    which waits for the output poll worker to finish if it's running.
    
    The output poll worker meanwhile calls pm_runtime_get_sync() in
    radeon's ->detect hooks, which waits for the ongoing suspend to finish,
    causing a deadlock.
    
    Fix by not acquiring a runtime PM ref if the ->detect hooks are called
    in the output poll worker's context.  This is safe because the poll
    worker is only enabled while runtime active and we know that
    ->runtime_suspend waits for it to finish.
    
    Stack trace for posterity:
    
      INFO: task kworker/0:3:31847 blocked for more than 120 seconds
      Workqueue: events output_poll_execute [drm_kms_helper]
      Call Trace:
       schedule+0x3c/0x90
       rpm_resume+0x1e2/0x690
       __pm_runtime_resume+0x3f/0x60
       radeon_lvds_detect+0x39/0xf0 [radeon]
       output_poll_execute+0xda/0x1e0 [drm_kms_helper]
       process_one_work+0x14b/0x440
       worker_thread+0x48/0x4a0
    
      INFO: task kworker/2:0:10493 blocked for more than 120 seconds.
      Workqueue: pm pm_runtime_work
      Call Trace:
       schedule+0x3c/0x90
       schedule_timeout+0x1b3/0x240
       wait_for_common+0xc2/0x180
       wait_for_completion+0x1d/0x20
       flush_work+0xfc/0x1a0
       __cancel_work_timer+0xa5/0x1d0
       cancel_delayed_work_sync+0x13/0x20
       drm_kms_helper_poll_disable+0x1f/0x30 [drm_kms_helper]
       radeon_pmops_runtime_suspend+0x3d/0xa0 [radeon]
       pci_pm_runtime_suspend+0x61/0x1a0
       vga_switcheroo_runtime_suspend+0x21/0x70
       __rpm_callback+0x32/0x70
       rpm_callback+0x24/0x80
       rpm_suspend+0x12b/0x640
       pm_runtime_work+0x6f/0xb0
       process_one_work+0x14b/0x440
       worker_thread+0x48/0x4a0
    
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=94147
    Fixes: 10ebc0bc0934 ("drm/radeon: add runtime PM support (v2)")
    Cc: stable@vger.kernel.org # v3.13+: 27d4ee03078a: workqueue: Allow retrieval of current task's work struct
    Cc: stable@vger.kernel.org # v3.13+: 25c058ccaf2e: drm: Allow determining if current task is output poll worker
    Cc: Ismo Toijala <ismo.toijala@gmail.com>
    Cc: Alex Deucher <alexander.deucher@amd.com>
    Cc: Dave Airlie <airlied@redhat.com>
    Reviewed-by: Lyude Paul <lyude@redhat.com>
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Link: https://patchwork.freedesktop.org/patch/msgid/64ea02c44f91dda19bc563902b97bbc699040392.1518338789.git.lukas@wunner.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 24f82eef049e4caba0fbf6831dbc1dd255d97967
Author: Lukas Wunner <lukas@wunner.de>
Date:   Sun Feb 11 10:38:28 2018 +0100

    drm/nouveau: Fix deadlock on runtime suspend
    
    commit d61a5c1063515e855bedb1b81e20e50b0ac3541e upstream.
    
    nouveau's ->runtime_suspend hook calls drm_kms_helper_poll_disable(),
    which waits for the output poll worker to finish if it's running.
    
    The output poll worker meanwhile calls pm_runtime_get_sync() in
    nouveau_connector_detect() which waits for the ongoing suspend to finish,
    causing a deadlock.
    
    Fix by not acquiring a runtime PM ref if nouveau_connector_detect() is
    called in the output poll worker's context.  This is safe because
    the poll worker is only enabled while runtime active and we know that
    ->runtime_suspend waits for it to finish.
    
    Other contexts calling nouveau_connector_detect() do require a runtime
    PM ref, these comprise:
    
      status_store() drm sysfs interface
      ->fill_modes drm callback
      drm_fb_helper_probe_connector_modes()
      drm_mode_getconnector()
      nouveau_connector_hotplug()
      nouveau_display_hpd_work()
      nv17_tv_set_property()
    
    Stack trace for posterity:
    
      INFO: task kworker/0:1:58 blocked for more than 120 seconds.
      Workqueue: events output_poll_execute [drm_kms_helper]
      Call Trace:
       schedule+0x28/0x80
       rpm_resume+0x107/0x6e0
       __pm_runtime_resume+0x47/0x70
       nouveau_connector_detect+0x7e/0x4a0 [nouveau]
       nouveau_connector_detect_lvds+0x132/0x180 [nouveau]
       drm_helper_probe_detect_ctx+0x85/0xd0 [drm_kms_helper]
       output_poll_execute+0x11e/0x1c0 [drm_kms_helper]
       process_one_work+0x184/0x380
       worker_thread+0x2e/0x390
    
      INFO: task kworker/0:2:252 blocked for more than 120 seconds.
      Workqueue: pm pm_runtime_work
      Call Trace:
       schedule+0x28/0x80
       schedule_timeout+0x1e3/0x370
       wait_for_completion+0x123/0x190
       flush_work+0x142/0x1c0
       nouveau_pmops_runtime_suspend+0x7e/0xd0 [nouveau]
       pci_pm_runtime_suspend+0x5c/0x180
       vga_switcheroo_runtime_suspend+0x1e/0xa0
       __rpm_callback+0xc1/0x200
       rpm_callback+0x1f/0x70
       rpm_suspend+0x13c/0x640
       pm_runtime_work+0x6e/0x90
       process_one_work+0x184/0x380
       worker_thread+0x2e/0x390
    
    Bugzilla: https://bugs.archlinux.org/task/53497
    Bugzilla: https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=870523
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=70388#c33
    Fixes: 5addcf0a5f0f ("nouveau: add runtime PM support (v0.9)")
    Cc: stable@vger.kernel.org # v3.12+: 27d4ee03078a: workqueue: Allow retrieval of current task's work struct
    Cc: stable@vger.kernel.org # v3.12+: 25c058ccaf2e: drm: Allow determining if current task is output poll worker
    Cc: Ben Skeggs <bskeggs@redhat.com>
    Cc: Dave Airlie <airlied@redhat.com>
    Reviewed-by: Lyude Paul <lyude@redhat.com>
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Link: https://patchwork.freedesktop.org/patch/msgid/b7d2cbb609a80f59ccabfdf479b9d5907c603ea1.1518338789.git.lukas@wunner.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 40539a866f0c78caef415170a1f83d1b8f81d12c
Author: Lukas Wunner <lukas@wunner.de>
Date:   Sun Feb 11 10:38:28 2018 +0100

    drm/radeon: Fix deadlock on runtime suspend
    
    commit 15734feff2bdac24aa3266c437cffa42851990e3 upstream.
    
    radeon's ->runtime_suspend hook calls drm_kms_helper_poll_disable(),
    which waits for the output poll worker to finish if it's running.
    
    The output poll worker meanwhile calls pm_runtime_get_sync() in
    radeon's ->detect hooks, which waits for the ongoing suspend to finish,
    causing a deadlock.
    
    Fix by not acquiring a runtime PM ref if the ->detect hooks are called
    in the output poll worker's context.  This is safe because the poll
    worker is only enabled while runtime active and we know that
    ->runtime_suspend waits for it to finish.
    
    Stack trace for posterity:
    
      INFO: task kworker/0:3:31847 blocked for more than 120 seconds
      Workqueue: events output_poll_execute [drm_kms_helper]
      Call Trace:
       schedule+0x3c/0x90
       rpm_resume+0x1e2/0x690
       __pm_runtime_resume+0x3f/0x60
       radeon_lvds_detect+0x39/0xf0 [radeon]
       output_poll_execute+0xda/0x1e0 [drm_kms_helper]
       process_one_work+0x14b/0x440
       worker_thread+0x48/0x4a0
    
      INFO: task kworker/2:0:10493 blocked for more than 120 seconds.
      Workqueue: pm pm_runtime_work
      Call Trace:
       schedule+0x3c/0x90
       schedule_timeout+0x1b3/0x240
       wait_for_common+0xc2/0x180
       wait_for_completion+0x1d/0x20
       flush_work+0xfc/0x1a0
       __cancel_work_timer+0xa5/0x1d0
       cancel_delayed_work_sync+0x13/0x20
       drm_kms_helper_poll_disable+0x1f/0x30 [drm_kms_helper]
       radeon_pmops_runtime_suspend+0x3d/0xa0 [radeon]
       pci_pm_runtime_suspend+0x61/0x1a0
       vga_switcheroo_runtime_suspend+0x21/0x70
       __rpm_callback+0x32/0x70
       rpm_callback+0x24/0x80
       rpm_suspend+0x12b/0x640
       pm_runtime_work+0x6f/0xb0
       process_one_work+0x14b/0x440
       worker_thread+0x48/0x4a0
    
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=94147
    Fixes: 10ebc0bc0934 ("drm/radeon: add runtime PM support (v2)")
    Cc: stable@vger.kernel.org # v3.13+: 27d4ee03078a: workqueue: Allow retrieval of current task's work struct
    Cc: stable@vger.kernel.org # v3.13+: 25c058ccaf2e: drm: Allow determining if current task is output poll worker
    Cc: Ismo Toijala <ismo.toijala@gmail.com>
    Cc: Alex Deucher <alexander.deucher@amd.com>
    Cc: Dave Airlie <airlied@redhat.com>
    Reviewed-by: Lyude Paul <lyude@redhat.com>
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Link: https://patchwork.freedesktop.org/patch/msgid/64ea02c44f91dda19bc563902b97bbc699040392.1518338789.git.lukas@wunner.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit cff2a8c5f97efdff33783bd1c5e41a36b3dab356
Author: Lukas Wunner <lukas@wunner.de>
Date:   Sun Feb 11 10:38:28 2018 +0100

    drm/nouveau: Fix deadlock on runtime suspend
    
    commit d61a5c1063515e855bedb1b81e20e50b0ac3541e upstream.
    
    nouveau's ->runtime_suspend hook calls drm_kms_helper_poll_disable(),
    which waits for the output poll worker to finish if it's running.
    
    The output poll worker meanwhile calls pm_runtime_get_sync() in
    nouveau_connector_detect() which waits for the ongoing suspend to finish,
    causing a deadlock.
    
    Fix by not acquiring a runtime PM ref if nouveau_connector_detect() is
    called in the output poll worker's context.  This is safe because
    the poll worker is only enabled while runtime active and we know that
    ->runtime_suspend waits for it to finish.
    
    Other contexts calling nouveau_connector_detect() do require a runtime
    PM ref, these comprise:
    
      status_store() drm sysfs interface
      ->fill_modes drm callback
      drm_fb_helper_probe_connector_modes()
      drm_mode_getconnector()
      nouveau_connector_hotplug()
      nouveau_display_hpd_work()
      nv17_tv_set_property()
    
    Stack trace for posterity:
    
      INFO: task kworker/0:1:58 blocked for more than 120 seconds.
      Workqueue: events output_poll_execute [drm_kms_helper]
      Call Trace:
       schedule+0x28/0x80
       rpm_resume+0x107/0x6e0
       __pm_runtime_resume+0x47/0x70
       nouveau_connector_detect+0x7e/0x4a0 [nouveau]
       nouveau_connector_detect_lvds+0x132/0x180 [nouveau]
       drm_helper_probe_detect_ctx+0x85/0xd0 [drm_kms_helper]
       output_poll_execute+0x11e/0x1c0 [drm_kms_helper]
       process_one_work+0x184/0x380
       worker_thread+0x2e/0x390
    
      INFO: task kworker/0:2:252 blocked for more than 120 seconds.
      Workqueue: pm pm_runtime_work
      Call Trace:
       schedule+0x28/0x80
       schedule_timeout+0x1e3/0x370
       wait_for_completion+0x123/0x190
       flush_work+0x142/0x1c0
       nouveau_pmops_runtime_suspend+0x7e/0xd0 [nouveau]
       pci_pm_runtime_suspend+0x5c/0x180
       vga_switcheroo_runtime_suspend+0x1e/0xa0
       __rpm_callback+0xc1/0x200
       rpm_callback+0x1f/0x70
       rpm_suspend+0x13c/0x640
       pm_runtime_work+0x6e/0x90
       process_one_work+0x184/0x380
       worker_thread+0x2e/0x390
    
    Bugzilla: https://bugs.archlinux.org/task/53497
    Bugzilla: https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=870523
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=70388#c33
    Fixes: 5addcf0a5f0f ("nouveau: add runtime PM support (v0.9)")
    Cc: stable@vger.kernel.org # v3.12+: 27d4ee03078a: workqueue: Allow retrieval of current task's work struct
    Cc: stable@vger.kernel.org # v3.12+: 25c058ccaf2e: drm: Allow determining if current task is output poll worker
    Cc: Ben Skeggs <bskeggs@redhat.com>
    Cc: Dave Airlie <airlied@redhat.com>
    Reviewed-by: Lyude Paul <lyude@redhat.com>
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Link: https://patchwork.freedesktop.org/patch/msgid/b7d2cbb609a80f59ccabfdf479b9d5907c603ea1.1518338789.git.lukas@wunner.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit ae78cada27a576c5eb41fb755e7f5b438822d696
Author: Lukas Wunner <lukas@wunner.de>
Date:   Sun Feb 11 10:38:28 2018 +0100

    drm/radeon: Fix deadlock on runtime suspend
    
    commit 15734feff2bdac24aa3266c437cffa42851990e3 upstream.
    
    radeon's ->runtime_suspend hook calls drm_kms_helper_poll_disable(),
    which waits for the output poll worker to finish if it's running.
    
    The output poll worker meanwhile calls pm_runtime_get_sync() in
    radeon's ->detect hooks, which waits for the ongoing suspend to finish,
    causing a deadlock.
    
    Fix by not acquiring a runtime PM ref if the ->detect hooks are called
    in the output poll worker's context.  This is safe because the poll
    worker is only enabled while runtime active and we know that
    ->runtime_suspend waits for it to finish.
    
    Stack trace for posterity:
    
      INFO: task kworker/0:3:31847 blocked for more than 120 seconds
      Workqueue: events output_poll_execute [drm_kms_helper]
      Call Trace:
       schedule+0x3c/0x90
       rpm_resume+0x1e2/0x690
       __pm_runtime_resume+0x3f/0x60
       radeon_lvds_detect+0x39/0xf0 [radeon]
       output_poll_execute+0xda/0x1e0 [drm_kms_helper]
       process_one_work+0x14b/0x440
       worker_thread+0x48/0x4a0
    
      INFO: task kworker/2:0:10493 blocked for more than 120 seconds.
      Workqueue: pm pm_runtime_work
      Call Trace:
       schedule+0x3c/0x90
       schedule_timeout+0x1b3/0x240
       wait_for_common+0xc2/0x180
       wait_for_completion+0x1d/0x20
       flush_work+0xfc/0x1a0
       __cancel_work_timer+0xa5/0x1d0
       cancel_delayed_work_sync+0x13/0x20
       drm_kms_helper_poll_disable+0x1f/0x30 [drm_kms_helper]
       radeon_pmops_runtime_suspend+0x3d/0xa0 [radeon]
       pci_pm_runtime_suspend+0x61/0x1a0
       vga_switcheroo_runtime_suspend+0x21/0x70
       __rpm_callback+0x32/0x70
       rpm_callback+0x24/0x80
       rpm_suspend+0x12b/0x640
       pm_runtime_work+0x6f/0xb0
       process_one_work+0x14b/0x440
       worker_thread+0x48/0x4a0
    
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=94147
    Fixes: 10ebc0bc0934 ("drm/radeon: add runtime PM support (v2)")
    Cc: stable@vger.kernel.org # v3.13+: 27d4ee03078a: workqueue: Allow retrieval of current task's work struct
    Cc: stable@vger.kernel.org # v3.13+: 25c058ccaf2e: drm: Allow determining if current task is output poll worker
    Cc: Ismo Toijala <ismo.toijala@gmail.com>
    Cc: Alex Deucher <alexander.deucher@amd.com>
    Cc: Dave Airlie <airlied@redhat.com>
    Reviewed-by: Lyude Paul <lyude@redhat.com>
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Link: https://patchwork.freedesktop.org/patch/msgid/64ea02c44f91dda19bc563902b97bbc699040392.1518338789.git.lukas@wunner.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit edf309e744c0895caefc7152f8d15b453ac5fcbd
Author: Lukas Wunner <lukas@wunner.de>
Date:   Sun Feb 11 10:38:28 2018 +0100

    drm/nouveau: Fix deadlock on runtime suspend
    
    commit d61a5c1063515e855bedb1b81e20e50b0ac3541e upstream.
    
    nouveau's ->runtime_suspend hook calls drm_kms_helper_poll_disable(),
    which waits for the output poll worker to finish if it's running.
    
    The output poll worker meanwhile calls pm_runtime_get_sync() in
    nouveau_connector_detect() which waits for the ongoing suspend to finish,
    causing a deadlock.
    
    Fix by not acquiring a runtime PM ref if nouveau_connector_detect() is
    called in the output poll worker's context.  This is safe because
    the poll worker is only enabled while runtime active and we know that
    ->runtime_suspend waits for it to finish.
    
    Other contexts calling nouveau_connector_detect() do require a runtime
    PM ref, these comprise:
    
      status_store() drm sysfs interface
      ->fill_modes drm callback
      drm_fb_helper_probe_connector_modes()
      drm_mode_getconnector()
      nouveau_connector_hotplug()
      nouveau_display_hpd_work()
      nv17_tv_set_property()
    
    Stack trace for posterity:
    
      INFO: task kworker/0:1:58 blocked for more than 120 seconds.
      Workqueue: events output_poll_execute [drm_kms_helper]
      Call Trace:
       schedule+0x28/0x80
       rpm_resume+0x107/0x6e0
       __pm_runtime_resume+0x47/0x70
       nouveau_connector_detect+0x7e/0x4a0 [nouveau]
       nouveau_connector_detect_lvds+0x132/0x180 [nouveau]
       drm_helper_probe_detect_ctx+0x85/0xd0 [drm_kms_helper]
       output_poll_execute+0x11e/0x1c0 [drm_kms_helper]
       process_one_work+0x184/0x380
       worker_thread+0x2e/0x390
    
      INFO: task kworker/0:2:252 blocked for more than 120 seconds.
      Workqueue: pm pm_runtime_work
      Call Trace:
       schedule+0x28/0x80
       schedule_timeout+0x1e3/0x370
       wait_for_completion+0x123/0x190
       flush_work+0x142/0x1c0
       nouveau_pmops_runtime_suspend+0x7e/0xd0 [nouveau]
       pci_pm_runtime_suspend+0x5c/0x180
       vga_switcheroo_runtime_suspend+0x1e/0xa0
       __rpm_callback+0xc1/0x200
       rpm_callback+0x1f/0x70
       rpm_suspend+0x13c/0x640
       pm_runtime_work+0x6e/0x90
       process_one_work+0x184/0x380
       worker_thread+0x2e/0x390
    
    Bugzilla: https://bugs.archlinux.org/task/53497
    Bugzilla: https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=870523
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=70388#c33
    Fixes: 5addcf0a5f0f ("nouveau: add runtime PM support (v0.9)")
    Cc: stable@vger.kernel.org # v3.12+: 27d4ee03078a: workqueue: Allow retrieval of current task's work struct
    Cc: stable@vger.kernel.org # v3.12+: 25c058ccaf2e: drm: Allow determining if current task is output poll worker
    Cc: Ben Skeggs <bskeggs@redhat.com>
    Cc: Dave Airlie <airlied@redhat.com>
    Reviewed-by: Lyude Paul <lyude@redhat.com>
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Link: https://patchwork.freedesktop.org/patch/msgid/b7d2cbb609a80f59ccabfdf479b9d5907c603ea1.1518338789.git.lukas@wunner.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 9c1508eff805c81e81be88dec99dccc36c59fd4c
Author: Lukas Wunner <lukas@wunner.de>
Date:   Sun Feb 11 10:38:28 2018 +0100

    drm/radeon: Fix deadlock on runtime suspend
    
    commit 15734feff2bdac24aa3266c437cffa42851990e3 upstream.
    
    radeon's ->runtime_suspend hook calls drm_kms_helper_poll_disable(),
    which waits for the output poll worker to finish if it's running.
    
    The output poll worker meanwhile calls pm_runtime_get_sync() in
    radeon's ->detect hooks, which waits for the ongoing suspend to finish,
    causing a deadlock.
    
    Fix by not acquiring a runtime PM ref if the ->detect hooks are called
    in the output poll worker's context.  This is safe because the poll
    worker is only enabled while runtime active and we know that
    ->runtime_suspend waits for it to finish.
    
    Stack trace for posterity:
    
      INFO: task kworker/0:3:31847 blocked for more than 120 seconds
      Workqueue: events output_poll_execute [drm_kms_helper]
      Call Trace:
       schedule+0x3c/0x90
       rpm_resume+0x1e2/0x690
       __pm_runtime_resume+0x3f/0x60
       radeon_lvds_detect+0x39/0xf0 [radeon]
       output_poll_execute+0xda/0x1e0 [drm_kms_helper]
       process_one_work+0x14b/0x440
       worker_thread+0x48/0x4a0
    
      INFO: task kworker/2:0:10493 blocked for more than 120 seconds.
      Workqueue: pm pm_runtime_work
      Call Trace:
       schedule+0x3c/0x90
       schedule_timeout+0x1b3/0x240
       wait_for_common+0xc2/0x180
       wait_for_completion+0x1d/0x20
       flush_work+0xfc/0x1a0
       __cancel_work_timer+0xa5/0x1d0
       cancel_delayed_work_sync+0x13/0x20
       drm_kms_helper_poll_disable+0x1f/0x30 [drm_kms_helper]
       radeon_pmops_runtime_suspend+0x3d/0xa0 [radeon]
       pci_pm_runtime_suspend+0x61/0x1a0
       vga_switcheroo_runtime_suspend+0x21/0x70
       __rpm_callback+0x32/0x70
       rpm_callback+0x24/0x80
       rpm_suspend+0x12b/0x640
       pm_runtime_work+0x6f/0xb0
       process_one_work+0x14b/0x440
       worker_thread+0x48/0x4a0
    
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=94147
    Fixes: 10ebc0bc0934 ("drm/radeon: add runtime PM support (v2)")
    Cc: stable@vger.kernel.org # v3.13+: 27d4ee03078a: workqueue: Allow retrieval of current task's work struct
    Cc: stable@vger.kernel.org # v3.13+: 25c058ccaf2e: drm: Allow determining if current task is output poll worker
    Cc: Ismo Toijala <ismo.toijala@gmail.com>
    Cc: Alex Deucher <alexander.deucher@amd.com>
    Cc: Dave Airlie <airlied@redhat.com>
    Reviewed-by: Lyude Paul <lyude@redhat.com>
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Link: https://patchwork.freedesktop.org/patch/msgid/64ea02c44f91dda19bc563902b97bbc699040392.1518338789.git.lukas@wunner.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 8c13b37c887db3531970f31955d6b0445061995a
Author: Lukas Wunner <lukas@wunner.de>
Date:   Sun Feb 11 10:38:28 2018 +0100

    drm/nouveau: Fix deadlock on runtime suspend
    
    commit d61a5c1063515e855bedb1b81e20e50b0ac3541e upstream.
    
    nouveau's ->runtime_suspend hook calls drm_kms_helper_poll_disable(),
    which waits for the output poll worker to finish if it's running.
    
    The output poll worker meanwhile calls pm_runtime_get_sync() in
    nouveau_connector_detect() which waits for the ongoing suspend to finish,
    causing a deadlock.
    
    Fix by not acquiring a runtime PM ref if nouveau_connector_detect() is
    called in the output poll worker's context.  This is safe because
    the poll worker is only enabled while runtime active and we know that
    ->runtime_suspend waits for it to finish.
    
    Other contexts calling nouveau_connector_detect() do require a runtime
    PM ref, these comprise:
    
      status_store() drm sysfs interface
      ->fill_modes drm callback
      drm_fb_helper_probe_connector_modes()
      drm_mode_getconnector()
      nouveau_connector_hotplug()
      nouveau_display_hpd_work()
      nv17_tv_set_property()
    
    Stack trace for posterity:
    
      INFO: task kworker/0:1:58 blocked for more than 120 seconds.
      Workqueue: events output_poll_execute [drm_kms_helper]
      Call Trace:
       schedule+0x28/0x80
       rpm_resume+0x107/0x6e0
       __pm_runtime_resume+0x47/0x70
       nouveau_connector_detect+0x7e/0x4a0 [nouveau]
       nouveau_connector_detect_lvds+0x132/0x180 [nouveau]
       drm_helper_probe_detect_ctx+0x85/0xd0 [drm_kms_helper]
       output_poll_execute+0x11e/0x1c0 [drm_kms_helper]
       process_one_work+0x184/0x380
       worker_thread+0x2e/0x390
    
      INFO: task kworker/0:2:252 blocked for more than 120 seconds.
      Workqueue: pm pm_runtime_work
      Call Trace:
       schedule+0x28/0x80
       schedule_timeout+0x1e3/0x370
       wait_for_completion+0x123/0x190
       flush_work+0x142/0x1c0
       nouveau_pmops_runtime_suspend+0x7e/0xd0 [nouveau]
       pci_pm_runtime_suspend+0x5c/0x180
       vga_switcheroo_runtime_suspend+0x1e/0xa0
       __rpm_callback+0xc1/0x200
       rpm_callback+0x1f/0x70
       rpm_suspend+0x13c/0x640
       pm_runtime_work+0x6e/0x90
       process_one_work+0x184/0x380
       worker_thread+0x2e/0x390
    
    Bugzilla: https://bugs.archlinux.org/task/53497
    Bugzilla: https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=870523
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=70388#c33
    Fixes: 5addcf0a5f0f ("nouveau: add runtime PM support (v0.9)")
    Cc: stable@vger.kernel.org # v3.12+: 27d4ee03078a: workqueue: Allow retrieval of current task's work struct
    Cc: stable@vger.kernel.org # v3.12+: 25c058ccaf2e: drm: Allow determining if current task is output poll worker
    Cc: Ben Skeggs <bskeggs@redhat.com>
    Cc: Dave Airlie <airlied@redhat.com>
    Reviewed-by: Lyude Paul <lyude@redhat.com>
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Link: https://patchwork.freedesktop.org/patch/msgid/b7d2cbb609a80f59ccabfdf479b9d5907c603ea1.1518338789.git.lukas@wunner.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit f25c83581583eca9b1c1e6fd2914c7f8a1be22de
Author: Marek Szyprowski <m.szyprowski@samsung.com>
Date:   Mon Mar 5 09:57:40 2018 +0100

    drm/bridge: analogix_dp: Postpone enabling runtime power management
    
    Enabling runtime power management early in analogix_dp_bind() causes following
    kernel NULL pointer dereference:
    
    Unable to handle kernel NULL pointer dereference at virtual address 000007d8
    pgd = 28ffa2e4
    [000007d8] *pgd=00000000
    Internal error: Oops: 5 [#1] PREEMPT SMP ARM
    Modules linked in:
    CPU: 6 PID: 69 Comm: kworker/6:1 Not tainted 4.16.0-rc1-00062-ge25751974ba8 #3622
    Hardware name: SAMSUNG EXYNOS (Flattened Device Tree)
    Workqueue: events deferred_probe_work_func
    PC is at analogix_dp_resume+0x8/0xc0
    LR is at pm_generic_runtime_resume+0x2c/0x38
    pc : [<c0531b98>]    lr : [<c0543fec>] psr: a0000113
    sp : ee13fbd8  ip : 0000001a  fp : 00000001
    r10: ee0eb080  r9 : c0552bd8  r8 : c0fb1d98
    r7 : eebb1010  r6 : eeae9808  r5 : 00000000  r4 : d4850415
    r3 : ee0ed010  r2 : b2d05e00  r1 : 00000000  r0 : 00000000
    Flags: NzCv  IRQs on  FIQs on  Mode SVC_32  ISA ARM Segment none
    Control: 10c5387d  Table: 2000406a  DAC: 00000051
    Process kworker/6:1 (pid: 69, stack limit = 0x913205b4)
    Stack: (0xee13fbd8 to 0xee140000)
    ...
    [<c0531b98>] (analogix_dp_resume) from [<c0543fec>] (pm_generic_runtime_resume+0x2c/0x38)
    [<c0543fec>] (pm_generic_runtime_resume) from [<c054ffb4>] (__genpd_runtime_resume+0x2c/0x8c)
    [<c054ffb4>] (__genpd_runtime_resume) from [<c0552d24>] (genpd_runtime_resume+0x14c/0x258)
    [<c0552d24>] (genpd_runtime_resume) from [<c0547798>] (__rpm_callback+0x134/0x214)
    [<c0547798>] (__rpm_callback) from [<c0547898>] (rpm_callback+0x20/0x80)
    [<c0547898>] (rpm_callback) from [<c0546ff4>] (rpm_resume+0x3a0/0x734)
    [<c0546ff4>] (rpm_resume) from [<c05475ec>] (__pm_runtime_resume+0x64/0x9c)
    [<c05475ec>] (__pm_runtime_resume) from [<c053b95c>] (__device_attach+0x8c/0x134)
    [<c053b95c>] (__device_attach) from [<c053ad08>] (bus_probe_device+0x88/0x90)
    [<c053ad08>] (bus_probe_device) from [<c05390d0>] (device_add+0x3a8/0x580)
    [<c05390d0>] (device_add) from [<c06764c4>] (i2c_register_adapter+0xd4/0x3ec)
    [<c06764c4>] (i2c_register_adapter) from [<c05321c8>] (analogix_dp_bind+0x2a0/0x410)
    [<c05321c8>] (analogix_dp_bind) from [<c0528e90>] (exynos_dp_bind+0x9c/0x12c)
    [<c0528e90>] (exynos_dp_bind) from [<c0535bc4>] (component_bind_all+0xfc/0x258)
    [<c0535bc4>] (component_bind_all) from [<c0522ee8>] (exynos_drm_bind+0x15c/0x28c)
    [<c0522ee8>] (exynos_drm_bind) from [<c0536378>] (try_to_bring_up_master+0x1b8/0x29c)
    [<c0536378>] (try_to_bring_up_master) from [<c05364fc>] (component_add+0xa0/0x170)
    [<c05364fc>] (component_add) from [<c0528fe4>] (exynos_dp_probe+0x64/0xb8)
    [<c0528fe4>] (exynos_dp_probe) from [<c053debc>] (platform_drv_probe+0x50/0xb0)
    [<c053debc>] (platform_drv_probe) from [<c053bd18>] (driver_probe_device+0x2b8/0x4a0)
    [<c053bd18>] (driver_probe_device) from [<c0539e4c>] (bus_for_each_drv+0x44/0x8c)
    [<c0539e4c>] (bus_for_each_drv) from [<c053b970>] (__device_attach+0xa0/0x134)
    [<c053b970>] (__device_attach) from [<c053ad08>] (bus_probe_device+0x88/0x90)
    [<c053ad08>] (bus_probe_device) from [<c053b258>] (deferred_probe_work_func+0x3c/0x168)
    [<c053b258>] (deferred_probe_work_func) from [<c014352c>] (process_one_work+0x1d0/0x7bc)
    [<c014352c>] (process_one_work) from [<c0143b84>] (worker_thread+0x34/0x4dc)
    [<c0143b84>] (worker_thread) from [<c014a30c>] (kthread+0x128/0x164)
    [<c014a30c>] (kthread) from [<c01010b4>] (ret_from_fork+0x14/0x20)
    Exception stack(0xee13ffb0 to 0xee13fff8)
    ffa0:                                     00000000 00000000 00000000 00000000
    ffc0: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
    ffe0: 00000000 00000000 00000000 00000000 00000013 00000000
    Code: e2800e37 eafee601 e92d4070 e1a05000 (e59067d8)
    ---[ end trace bf6046013df7cab2 ]---
    
    This oops happens, because analogix_dp_bind() calls drm_dp_aux_register()
    which registers i2c adapter. I2C core tries to runtime get i2c host
    device during registration. This ends in analogix_dp_resume(), but dp
    context is NULL there. dp context is set in exynos_dp_bind() after
    executing analogix_dp_bind(). Fix this issue by postponing enabling runtime
    power management after drm_dp_aux_register().
    
    Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Tested-by: Heiko Stuebner <heiko@sntech.de>
    Reviewed-by: Heiko Stuebner <heiko@sntech.de>
    
    Signed-off-by: Andrzej Hajda <a.hajda@samsung.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180305085741.18896-3-m.szyprowski@samsung.com

commit 15734feff2bdac24aa3266c437cffa42851990e3
Author: Lukas Wunner <lukas@wunner.de>
Date:   Sun Feb 11 10:38:28 2018 +0100

    drm/radeon: Fix deadlock on runtime suspend
    
    radeon's ->runtime_suspend hook calls drm_kms_helper_poll_disable(),
    which waits for the output poll worker to finish if it's running.
    
    The output poll worker meanwhile calls pm_runtime_get_sync() in
    radeon's ->detect hooks, which waits for the ongoing suspend to finish,
    causing a deadlock.
    
    Fix by not acquiring a runtime PM ref if the ->detect hooks are called
    in the output poll worker's context.  This is safe because the poll
    worker is only enabled while runtime active and we know that
    ->runtime_suspend waits for it to finish.
    
    Stack trace for posterity:
    
      INFO: task kworker/0:3:31847 blocked for more than 120 seconds
      Workqueue: events output_poll_execute [drm_kms_helper]
      Call Trace:
       schedule+0x3c/0x90
       rpm_resume+0x1e2/0x690
       __pm_runtime_resume+0x3f/0x60
       radeon_lvds_detect+0x39/0xf0 [radeon]
       output_poll_execute+0xda/0x1e0 [drm_kms_helper]
       process_one_work+0x14b/0x440
       worker_thread+0x48/0x4a0
    
      INFO: task kworker/2:0:10493 blocked for more than 120 seconds.
      Workqueue: pm pm_runtime_work
      Call Trace:
       schedule+0x3c/0x90
       schedule_timeout+0x1b3/0x240
       wait_for_common+0xc2/0x180
       wait_for_completion+0x1d/0x20
       flush_work+0xfc/0x1a0
       __cancel_work_timer+0xa5/0x1d0
       cancel_delayed_work_sync+0x13/0x20
       drm_kms_helper_poll_disable+0x1f/0x30 [drm_kms_helper]
       radeon_pmops_runtime_suspend+0x3d/0xa0 [radeon]
       pci_pm_runtime_suspend+0x61/0x1a0
       vga_switcheroo_runtime_suspend+0x21/0x70
       __rpm_callback+0x32/0x70
       rpm_callback+0x24/0x80
       rpm_suspend+0x12b/0x640
       pm_runtime_work+0x6f/0xb0
       process_one_work+0x14b/0x440
       worker_thread+0x48/0x4a0
    
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=94147
    Fixes: 10ebc0bc0934 ("drm/radeon: add runtime PM support (v2)")
    Cc: stable@vger.kernel.org # v3.13+: 27d4ee03078a: workqueue: Allow retrieval of current task's work struct
    Cc: stable@vger.kernel.org # v3.13+: 25c058ccaf2e: drm: Allow determining if current task is output poll worker
    Cc: Ismo Toijala <ismo.toijala@gmail.com>
    Cc: Alex Deucher <alexander.deucher@amd.com>
    Cc: Dave Airlie <airlied@redhat.com>
    Reviewed-by: Lyude Paul <lyude@redhat.com>
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Link: https://patchwork.freedesktop.org/patch/msgid/64ea02c44f91dda19bc563902b97bbc699040392.1518338789.git.lukas@wunner.de

commit d61a5c1063515e855bedb1b81e20e50b0ac3541e
Author: Lukas Wunner <lukas@wunner.de>
Date:   Sun Feb 11 10:38:28 2018 +0100

    drm/nouveau: Fix deadlock on runtime suspend
    
    nouveau's ->runtime_suspend hook calls drm_kms_helper_poll_disable(),
    which waits for the output poll worker to finish if it's running.
    
    The output poll worker meanwhile calls pm_runtime_get_sync() in
    nouveau_connector_detect() which waits for the ongoing suspend to finish,
    causing a deadlock.
    
    Fix by not acquiring a runtime PM ref if nouveau_connector_detect() is
    called in the output poll worker's context.  This is safe because
    the poll worker is only enabled while runtime active and we know that
    ->runtime_suspend waits for it to finish.
    
    Other contexts calling nouveau_connector_detect() do require a runtime
    PM ref, these comprise:
    
      status_store() drm sysfs interface
      ->fill_modes drm callback
      drm_fb_helper_probe_connector_modes()
      drm_mode_getconnector()
      nouveau_connector_hotplug()
      nouveau_display_hpd_work()
      nv17_tv_set_property()
    
    Stack trace for posterity:
    
      INFO: task kworker/0:1:58 blocked for more than 120 seconds.
      Workqueue: events output_poll_execute [drm_kms_helper]
      Call Trace:
       schedule+0x28/0x80
       rpm_resume+0x107/0x6e0
       __pm_runtime_resume+0x47/0x70
       nouveau_connector_detect+0x7e/0x4a0 [nouveau]
       nouveau_connector_detect_lvds+0x132/0x180 [nouveau]
       drm_helper_probe_detect_ctx+0x85/0xd0 [drm_kms_helper]
       output_poll_execute+0x11e/0x1c0 [drm_kms_helper]
       process_one_work+0x184/0x380
       worker_thread+0x2e/0x390
    
      INFO: task kworker/0:2:252 blocked for more than 120 seconds.
      Workqueue: pm pm_runtime_work
      Call Trace:
       schedule+0x28/0x80
       schedule_timeout+0x1e3/0x370
       wait_for_completion+0x123/0x190
       flush_work+0x142/0x1c0
       nouveau_pmops_runtime_suspend+0x7e/0xd0 [nouveau]
       pci_pm_runtime_suspend+0x5c/0x180
       vga_switcheroo_runtime_suspend+0x1e/0xa0
       __rpm_callback+0xc1/0x200
       rpm_callback+0x1f/0x70
       rpm_suspend+0x13c/0x640
       pm_runtime_work+0x6e/0x90
       process_one_work+0x184/0x380
       worker_thread+0x2e/0x390
    
    Bugzilla: https://bugs.archlinux.org/task/53497
    Bugzilla: https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=870523
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=70388#c33
    Fixes: 5addcf0a5f0f ("nouveau: add runtime PM support (v0.9)")
    Cc: stable@vger.kernel.org # v3.12+: 27d4ee03078a: workqueue: Allow retrieval of current task's work struct
    Cc: stable@vger.kernel.org # v3.12+: 25c058ccaf2e: drm: Allow determining if current task is output poll worker
    Cc: Ben Skeggs <bskeggs@redhat.com>
    Cc: Dave Airlie <airlied@redhat.com>
    Reviewed-by: Lyude Paul <lyude@redhat.com>
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Link: https://patchwork.freedesktop.org/patch/msgid/b7d2cbb609a80f59ccabfdf479b9d5907c603ea1.1518338789.git.lukas@wunner.de

commit 703cbaa601ff3fb554d1246c336ba727cc083ea0
Author: Bo Yan <byan@nvidia.com>
Date:   Tue Jan 23 13:57:55 2018 -0800

    cpufreq: Skip cpufreq resume if it's not suspended
    
    cpufreq_resume can be called even without preceding cpufreq_suspend.
    This can happen in following scenario:
    
        suspend_devices_and_enter
           --> dpm_suspend_start
              --> dpm_prepare
                  --> device_prepare : this function errors out
              --> dpm_suspend: this is skipped due to dpm_prepare failure
                               this means cpufreq_suspend is skipped over
           --> goto Recover_platform, due to previous error
           --> goto Resume_devices
           --> dpm_resume_end
               --> dpm_resume
                   --> cpufreq_resume
    
    In case schedutil is used as frequency governor, cpufreq_resume will
    eventually call sugov_start, which does following:
    
        memset(sg_cpu, 0, sizeof(*sg_cpu));
        ....
    
    This effectively erases function pointer for frequency update, causing
    crash later on. The function pointer would have been set correctly if
    subsequent cpufreq_add_update_util_hook runs successfully, but that
    function returns earlier because cpufreq_suspend was not called:
    
        if (WARN_ON(per_cpu(cpufreq_update_util_data, cpu)))
                    return;
    
    The fix is to check cpufreq_suspended first, if it's false, that means
    cpufreq_suspend was not called in the first place, so do not resume
    cpufreq.
    
    Signed-off-by: Bo Yan <byan@nvidia.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    [ rjw: Dropped printing a message ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 02e45646d53bdb38bfb47b83765778d3ecb4d3b3
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Jan 3 01:37:34 2018 +0100

    PM: i2c-designware-platdrv: Optimize power management
    
    Optimize the power management in i2c-designware-platdrv by making it
    set the DPM_FLAG_SMART_SUSPEND and DPM_FLAG_LEAVE_SUSPENDED which
    allows some code to be dropped from its PM callbacks.
    
    First, setting DPM_FLAG_SMART_SUSPEND causes the intel-lpss driver
    to avoid resuming i2c-designware-platdrv devices in its ->prepare
    callback, so they can stay in runtime suspend after that point even
    if the direct-complete feature is not used for them.
    
    It also causes the ACPI PM domain and the PM core to avoid invoking
    "late" and "noirq" suspend callbacks for these devices if they are
    in runtime suspend at the beginning of the "late" phase of device
    suspend during system suspend.  That guarantees dw_i2c_plat_suspend()
    to be called for a device only if it is not in runtime suspend.
    
    Moreover, it causes the device's runtime PM status to be set to
    "active" after calling dw_i2c_plat_resume() for it, so the
    driver doesn't need internal flags to avoid invoking either
    dw_i2c_plat_suspend() or dw_i2c_plat_resume() twice in a row.
    
    Second, setting DPM_FLAG_LEAVE_SUSPENDED enables the optimization
    allowing the device to stay suspended after system resume under
    suitable conditions, so again the driver doesn't need to take
    care of that by itself.
    
    Accordingly, the internal "suspended" and "skip_resume" flags
    used by the driver are not necessary any more, so drop them and
    simplify the driver's PM callbacks.
    
    Additionally, notice that dw_i2c_plat_complete() only needs to
    schedule runtime PM resume for the device if platform firmware
    has been involved in resuming the system, so make it call
    pm_resume_via_firmware() to check that.  Also make it check the
    runtime PM status of the device instead of its direct_complete
    flag which also works if the device remained suspended due to
    the DPM_FLAG_LEAVE_SUSPENDED driver flag.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Acked-by: Wolfram Sang <wsa@the-dreams.de>
    Tested-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>

commit 203dab8395d9a6b195cbadfec59ae4899aea13f9
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Dec 18 14:45:51 2017 +0100

    wil6210: fix build warnings without CONFIG_PM
    
    The #ifdef checks are hard to get right, in this case some functions
    should have been left inside a CONFIG_PM_SLEEP check as seen by this
    message:
    
    drivers/net/wireless/ath/wil6210/pcie_bus.c:489:12: error: 'wil6210_pm_resume' defined but not used [-Werror=unused-function]
    drivers/net/wireless/ath/wil6210/pcie_bus.c:484:12: error: 'wil6210_pm_suspend' defined but not used [-Werror=unused-function]
    
    Using an __maybe_unused is easier here, so I'm replacing all the
    other #ifdef in this file as well for consistency.
    
    Fixes: 94162666cd51 ("wil6210: run-time PM when interface down")
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Kalle Valo <kvalo@qca.qualcomm.com>

commit 43fff768346810042836df325d736bd2c2a634a7
Author: Lukas Wunner <lukas@wunner.de>
Date:   Tue Dec 26 17:07:34 2017 +0200

    Bluetooth: hci_bcm: Streamline runtime PM code
    
    This driver seeks to force the Bluetooth device on for the duration of
    5 seconds when the Bluetooth device has woken the host and after a
    complete packet has been received.  It does that by calling:
    
        pm_runtime_get();
        pm_runtime_mark_last_busy();
        pm_runtime_put_autosuspend();
    
    The same can be achieved more succinctly with:
    
        pm_request_resume();
    
    That's because after runtime resuming the device, rpm_resume() invokes
    pm_runtime_mark_last_busy() followed by rpm_idle(), which will cause
    the device to be suspended after expiration of the autosuspend_delay.
    
    No functional change intended.
    
    Cc: Frdric Danis <frederic.danis.oss@gmail.com>
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

commit bd755d770ac78e8eeda05877ba66cc66f151e10e
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Nov 18 15:33:52 2017 +0100

    PCI / PM: Support for LEAVE_SUSPENDED driver flag
    
    Add support for DPM_FLAG_LEAVE_SUSPENDED to the PCI bus type by
    making it (a) set the power.may_skip_resume status bit for devices
    that, from its perspective, may be left in suspend after system
    wakeup from sleep and (b) return early from pci_pm_resume_noirq()
    for devices whose remaining resume callbacks during the transition
    under way are going to be skipped by the PM core.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>

commit 89b5489b5da226ae108481f91cd7b4762c4babf9
Author: Johan Hovold <johan@kernel.org>
Date:   Thu Aug 10 08:06:39 2017 -0700

    ARM: OMAP2+: omap_device: drop broken RPM status update from suspend_noirq
    
    commit 90de9634a5d57b92d8af4ec23aa2c9b297ec8168 upstream.
    
    Since commit a8636c89648a ("PM / Runtime: Don't allow to suspend a
    device with an active child"), which went into 4.10, it is no longer
    permitted to set RPM_SUSPENDED state for a device with active children
    (unless power.ignore_children is set).
    
    This specifically means that the attempts to do just that from the omap
    pm-domain suspend_noirq callback have since been failing whenever a
    child is active, for example:
    
      am335x-usb-childs 47400000.usb: runtime PM trying to suspend
        device but active child
    
    Silence this warning by dropping the broken pm_runtime_set_suspended()
    call from the omap suspend_noirq callback along with the redundant
    pm_runtime_set_active() in resume_noirq.
    
    This effectively reverts commit 3522bf7bfa24 ("ARM: OMAP2+: omap_device:
    maintain sane runtime pm status around suspend/resume"), which started
    updating the RPM state after the runtime_suspend callback (!) for active
    omap devices had been called during system suspend. The rationale was
    that a later pm_runtime_get_sync() would then fail (even after runtime
    pm had been disabled) and that this in turn would avoid any external
    aborts when accessing registers with clocks disabled. (See also commit
    6f3c77b040fc ("PM / Runtime: let rpm_resume() succeed if RPM_ACTIVE,
    even when disabled, v2").
    
    But during the suspend_noirq phase all children would already have been
    suspended and their drivers would specifically not attempt any further
    register accesses. And if this was all just a workaround for random
    device drivers doing cross-tree calls during system suspend, those
    drivers should be fixed and updated to explicitly model such
    dependencies using device-links instead (and either way, any such calls
    have been causing crashes since 4.10).
    
    Fixes: 3522bf7bfa24 ("ARM: OMAP2+: omap_device: maintain sane runtime pm status around suspend/resume")
    Fixes: a8636c89648a ("PM / Runtime: Don't allow to suspend a device with an active child")
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: Dave Gerlach <d-gerlach@ti.com>
    Cc: Kevin Hilman <khilman@baylibre.com>
    Cc: Nishanth Menon <nm@ti.com>
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Cc: Tony Lindgren <tony@atomide.com>
    Cc: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Tested-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit c4b65157aeefad29b2351a00a010e8c40ce7fd0e
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Oct 26 12:12:22 2017 +0200

    PCI / PM: Take SMART_SUSPEND driver flag into account
    
    Make the PCI bus type take DPM_FLAG_SMART_SUSPEND into account in its
    system-wide PM callbacks and make sure that all code that should not
    run in parallel with pci_pm_runtime_resume() is executed in the "late"
    phases of system suspend, freeze and poweroff transitions.
    
    [Note that the pm_runtime_suspended() check in pci_dev_keep_suspended()
    is an optimization, because if is not passed, all of the subsequent
    checks may be skipped and some of them are much more overhead in
    general.]
    
    Also use the observation that if the device is in runtime suspend
    at the beginning of the "late" phase of a system-wide suspend-like
    transition, its state cannot change going forward (runtime PM is
    disabled for it at that time) until the transition is over and the
    subsequent system-wide PM callbacks should be skipped for it (as
    they generally assume the device to not be suspended), so add checks
    for that in pci_pm_suspend_late/noirq(), pci_pm_freeze_late/noirq()
    and pci_pm_poweroff_late/noirq().
    
    Moreover, if pci_pm_resume_noirq() or pci_pm_restore_noirq() is
    called during the subsequent system-wide resume transition and if
    the device was left in runtime suspend previously, its runtime PM
    status needs to be changed to "active" as it is going to be put
    into the full-power state, so add checks for that too to these
    functions.
    
    In turn, if pci_pm_thaw_noirq() runs after the device has been
    left in runtime suspend, the subsequent "thaw" callbacks need
    to be skipped for it (as they may not work correctly with a
    suspended device), so set the power.direct_complete flag for the
    device then to make the PM core skip those callbacks.
    
    In addition to the above add a core helper for checking if
    DPM_FLAG_SMART_SUSPEND is set and the device runtime PM status is
    "suspended" at the same time, which is done quite often in the new
    code (and will be done elsewhere going forward too).
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>

commit b0a242894f11d2a357a77e0eedebb16477151ddd
Author: Quentin Schulz <quentin.schulz@free-electrons.com>
Date:   Tue Sep 26 14:52:18 2017 +0200

    iio: adc: sun4i-gpadc-iio: register in the thermal after registering in pm
    
    This driver has a get_temp function used by the thermal framework that
    uses pm functions.
    
    However, the driver isn't registered in pm before it is registered in
    thermal framework, resulting in the pm_resume not being called and thus
    the IP not enabled.
    
    When the IP is disabled, the raw temp value is always 0. With the
    devices currently supported, it isn't a problem since with their
    respective formula, they return a really cold SoC temperature which
    isn't a problem for the thermal framework. But for future SoC that have
    a different formula, it could return a critically hot temperature,
    forcing the thermal framework to shutdown the board.
    
    Signed-off-by: Quentin Schulz <quentin.schulz@free-electrons.com>
    Acked-by: Maxime Ripard <maxime.ripard@free-electrons.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

commit 6af1de2e4ec49635905aaed31d073a0d92c8d3bf
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Sep 6 14:58:53 2017 +0200

    ath10k: mark PM functions as __maybe_unused
    
    When CONFIG_PM_SLEEP is disabled, we get a compile-time
    warning:
    
    drivers/net/wireless/ath/ath10k/pci.c:3417:12: error: 'ath10k_pci_pm_resume' defined but not used [-Werror=unused-function]
     static int ath10k_pci_pm_resume(struct device *dev)
                ^~~~~~~~~~~~~~~~~~~~
    drivers/net/wireless/ath/ath10k/pci.c:3401:12: error: 'ath10k_pci_pm_suspend' defined but not used [-Werror=unused-function]
     static int ath10k_pci_pm_suspend(struct device *dev)
    
    Rather than fixing the #ifdef, this just marks both functions
    as __maybe_unused, which is a more robust way to do this.
    
    Fixes: 32faa3f0ee50 ("ath10k: add the PCI PM core suspend/resume ops")
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Kalle Valo <kvalo@qca.qualcomm.com>

commit 7b01463e51f6849d0787b24d06a62efcb243dd44
Merge: a1b5fd8fa29f 726fb6b4f2a8
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Sep 4 00:06:02 2017 +0200

    Merge branch 'pm-sleep'
    
    * pm-sleep:
      ACPI / PM: Check low power idle constraints for debug only
      PM / s2idle: Rename platform operations structure
      PM / s2idle: Rename ->enter_freeze to ->enter_s2idle
      PM / s2idle: Rename freeze_state enum and related items
      PM / s2idle: Rename PM_SUSPEND_FREEZE to PM_SUSPEND_TO_IDLE
      ACPI / PM: Prefer suspend-to-idle over S3 on some systems
      platform/x86: intel-hid: Wake up Dell Latitude 7275 from suspend-to-idle
      PM / suspend: Define pr_fmt() in suspend.c
      PM / suspend: Use mem_sleep_labels[] strings in messages
      PM / sleep: Put pm_test under CONFIG_PM_SLEEP_DEBUG
      PM / sleep: Check pm_wakeup_pending() in __device_suspend_noirq()
      PM / core: Add error argument to dpm_show_time()
      PM / core: Split dpm_suspend_noirq() and dpm_resume_noirq()
      PM / s2idle: Rearrange the main suspend-to-idle loop
      PM / timekeeping: Print debug messages when requested
      PM / sleep: Mark suspend/hibernation start and finish
      PM / sleep: Do not print debug messages by default
      PM / suspend: Export pm_suspend_target_state

commit 33f1d0c79b044ac8d721d24ea0adb4146824d3bf
Author: Munehisa Kamata <kamatam@amazon.com>
Date:   Wed Aug 9 15:31:40 2017 -0700

    xen-blkfront: use a right index when checking requests
    
    commit b15bd8cb37598afb2963f7eb9e2de468d2d60a2f upstream.
    
    Since commit d05d7f40791c ("Merge branch 'for-4.8/core' of
    git://git.kernel.dk/linux-block") and 3fc9d690936f ("Merge branch
    'for-4.8/drivers' of git://git.kernel.dk/linux-block"), blkfront_resume()
    has been using an index for iterating ring_info to check request when
    iterating blk_shadow in an inner loop. This seems to have been
    accidentally introduced during the massive rewrite of the block layer
    macros in the commits.
    
    This may cause crash like this:
    
    [11798.057074] BUG: unable to handle kernel NULL pointer dereference at 0000000000000048
    [11798.058832] IP: [<ffffffff814411fa>] blkfront_resume+0x10a/0x610
    ....
    [11798.061063] Call Trace:
    [11798.061063]  [<ffffffff8139ce93>] xenbus_dev_resume+0x53/0x140
    [11798.061063]  [<ffffffff8139ce40>] ? xenbus_dev_probe+0x150/0x150
    [11798.061063]  [<ffffffff813f359e>] dpm_run_callback+0x3e/0x110
    [11798.061063]  [<ffffffff813f3a08>] device_resume+0x88/0x190
    [11798.061063]  [<ffffffff813f4cc0>] dpm_resume+0x100/0x2d0
    [11798.061063]  [<ffffffff813f5221>] dpm_resume_end+0x11/0x20
    [11798.061063]  [<ffffffff813950a8>] do_suspend+0xe8/0x1a0
    [11798.061063]  [<ffffffff813954bd>] shutdown_handler+0xfd/0x130
    [11798.061063]  [<ffffffff8139aba0>] ? split+0x110/0x110
    [11798.061063]  [<ffffffff8139ac26>] xenwatch_thread+0x86/0x120
    [11798.061063]  [<ffffffff810b4570>] ? prepare_to_wait_event+0x110/0x110
    [11798.061063]  [<ffffffff8108fe57>] kthread+0xd7/0xf0
    [11798.061063]  [<ffffffff811da811>] ? kfree+0x121/0x170
    [11798.061063]  [<ffffffff8108fd80>] ? kthread_park+0x60/0x60
    [11798.061063]  [<ffffffff810863b0>] ?  call_usermodehelper_exec_work+0xb0/0xb0
    [11798.061063]  [<ffffffff810864ea>] ?  call_usermodehelper_exec_async+0x13a/0x140
    [11798.061063]  [<ffffffff81534a45>] ret_from_fork+0x25/0x30
    
    Use the right index in the inner loop.
    
    Fixes: d05d7f40791c ("Merge branch 'for-4.8/core' of git://git.kernel.dk/linux-block")
    Fixes: 3fc9d690936f ("Merge branch 'for-4.8/drivers' of git://git.kernel.dk/linux-block")
    Signed-off-by: Munehisa Kamata <kamatam@amazon.com>
    Reviewed-by: Thomas Friebel <friebelt@amazon.de>
    Reviewed-by: Eduardo Valentin <eduval@amazon.com>
    Reviewed-by: Boris Ostrovsky <boris.ostrovsky@oracle.com>
    Cc: Juergen Gross <jgross@suse.com>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Reviewed-by: Roger Pau Monne <roger.pau@citrix.com>
    Cc: xen-devel@lists.xenproject.org
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 1581d704e97d66a03fd7727bd1a9e561aff2acc5
Author: Munehisa Kamata <kamatam@amazon.com>
Date:   Wed Aug 9 15:31:40 2017 -0700

    xen-blkfront: use a right index when checking requests
    
    commit b15bd8cb37598afb2963f7eb9e2de468d2d60a2f upstream.
    
    Since commit d05d7f40791c ("Merge branch 'for-4.8/core' of
    git://git.kernel.dk/linux-block") and 3fc9d690936f ("Merge branch
    'for-4.8/drivers' of git://git.kernel.dk/linux-block"), blkfront_resume()
    has been using an index for iterating ring_info to check request when
    iterating blk_shadow in an inner loop. This seems to have been
    accidentally introduced during the massive rewrite of the block layer
    macros in the commits.
    
    This may cause crash like this:
    
    [11798.057074] BUG: unable to handle kernel NULL pointer dereference at 0000000000000048
    [11798.058832] IP: [<ffffffff814411fa>] blkfront_resume+0x10a/0x610
    ....
    [11798.061063] Call Trace:
    [11798.061063]  [<ffffffff8139ce93>] xenbus_dev_resume+0x53/0x140
    [11798.061063]  [<ffffffff8139ce40>] ? xenbus_dev_probe+0x150/0x150
    [11798.061063]  [<ffffffff813f359e>] dpm_run_callback+0x3e/0x110
    [11798.061063]  [<ffffffff813f3a08>] device_resume+0x88/0x190
    [11798.061063]  [<ffffffff813f4cc0>] dpm_resume+0x100/0x2d0
    [11798.061063]  [<ffffffff813f5221>] dpm_resume_end+0x11/0x20
    [11798.061063]  [<ffffffff813950a8>] do_suspend+0xe8/0x1a0
    [11798.061063]  [<ffffffff813954bd>] shutdown_handler+0xfd/0x130
    [11798.061063]  [<ffffffff8139aba0>] ? split+0x110/0x110
    [11798.061063]  [<ffffffff8139ac26>] xenwatch_thread+0x86/0x120
    [11798.061063]  [<ffffffff810b4570>] ? prepare_to_wait_event+0x110/0x110
    [11798.061063]  [<ffffffff8108fe57>] kthread+0xd7/0xf0
    [11798.061063]  [<ffffffff811da811>] ? kfree+0x121/0x170
    [11798.061063]  [<ffffffff8108fd80>] ? kthread_park+0x60/0x60
    [11798.061063]  [<ffffffff810863b0>] ?  call_usermodehelper_exec_work+0xb0/0xb0
    [11798.061063]  [<ffffffff810864ea>] ?  call_usermodehelper_exec_async+0x13a/0x140
    [11798.061063]  [<ffffffff81534a45>] ret_from_fork+0x25/0x30
    
    Use the right index in the inner loop.
    
    Fixes: d05d7f40791c ("Merge branch 'for-4.8/core' of git://git.kernel.dk/linux-block")
    Fixes: 3fc9d690936f ("Merge branch 'for-4.8/drivers' of git://git.kernel.dk/linux-block")
    Signed-off-by: Munehisa Kamata <kamatam@amazon.com>
    Reviewed-by: Thomas Friebel <friebelt@amazon.de>
    Reviewed-by: Eduardo Valentin <eduval@amazon.com>
    Reviewed-by: Boris Ostrovsky <boris.ostrovsky@oracle.com>
    Cc: Juergen Gross <jgross@suse.com>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Reviewed-by: Roger Pau Monne <roger.pau@citrix.com>
    Cc: xen-devel@lists.xenproject.org
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 4f608d382e6fa982655e37d0e1b6c134fdc0e4c3
Author: Yong Wu <yong.wu@mediatek.com>
Date:   Mon Aug 21 19:00:21 2017 +0800

    memory: mtk-smi: Degrade SMI init to module_init
    
    The initialization of MediaTek power manager(SCPSYS) is
    builtin_platform_driver, and SMI must depend on power-domain.
    Thus, currently subsys_initcall for SMI is unnecessary, SMI will be
    always probe defered by power-domain. Degrade it to module_init.
    
    In addition, there are two small changes about the probe sequence:
    1) Delete this two lines.
            if (!dev->pm_domain)
                    return -EPROBE_DEFER;
       This is not helpful. the platform driver framework guarantee this.
       The "dev_pm_domain_attach" in the "platform_drv_probe" will return
       EPROBE_DEFER if its powerdomain is not ready.
    
    2) Add the probe-defer for the smi-larb device should waiting for
       smi-common.
       In mt2712, there are 2 smi-commons, 10 smi-larbs. All will be
       probe-defered by the power-domain, there is seldom case that
       smi-larb probe done before smi-common. then it will hang like
       this:
    
       Unable to handle kernel NULL pointer dereference at virtual address
    00000000 pgd = ffffff800a4e0000
    [00000000] *pgd=00000000beffe003[   17.610026] , *pud=00000000beffe003
    ...
    [<ffffff800897fe04>] mtk_smi_enable+0x1c/0xd0
    [<ffffff800897fee8>] mtk_smi_larb_get+0x30/0x98
    [<ffffff80088edfa8>] mtk_mipicsi0_resume+0x38/0x1b8
    [<ffffff8008634f44>] pm_generic_runtime_resume+0x3c/0x58
    [<ffffff8008644ff8>] __genpd_runtime_resume+0x38/0x98
    [<ffffff8008647434>] genpd_runtime_resume+0x164/0x220
    [<ffffff80086372f8>] __rpm_callback+0x78/0xa0
    [<ffffff8008637358>] rpm_callback+0x38/0xa0
    [<ffffff8008638a4c>] rpm_resume+0x4a4/0x6f8
    [<ffffff8008638d04>] __pm_runtime_resume+0x64/0xa0
    [<ffffff80088ed05c>] mtk_mipicsi0_probe+0x40c/0xb70
    [<ffffff800862cdc0>] platform_drv_probe+0x58/0xc0
    [<ffffff800862a514>] driver_probe_device+0x284/0x438
    [<ffffff800862a8ac>] __device_attach_driver+0xb4/0x160
    [<ffffff8008627d58>] bus_for_each_drv+0x68/0xa8
    [<ffffff800862a0a4>] __device_attach+0xd4/0x168
    [<ffffff800862a9d4>] device_initial_probe+0x24/0x30
    [<ffffff80086291d8>] bus_probe_device+0xa0/0xa8
    [<ffffff8008629784>] deferred_probe_work_func+0x94/0xf0
    [<ffffff80080f03a8>] process_one_work+0x1d8/0x6e0
    
    Signed-off-by: Yong Wu <yong.wu@mediatek.com>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

commit b15bd8cb37598afb2963f7eb9e2de468d2d60a2f
Author: Munehisa Kamata <kamatam@amazon.com>
Date:   Wed Aug 9 15:31:40 2017 -0700

    xen-blkfront: use a right index when checking requests
    
    Since commit d05d7f40791c ("Merge branch 'for-4.8/core' of
    git://git.kernel.dk/linux-block") and 3fc9d690936f ("Merge branch
    'for-4.8/drivers' of git://git.kernel.dk/linux-block"), blkfront_resume()
    has been using an index for iterating ring_info to check request when
    iterating blk_shadow in an inner loop. This seems to have been
    accidentally introduced during the massive rewrite of the block layer
    macros in the commits.
    
    This may cause crash like this:
    
    [11798.057074] BUG: unable to handle kernel NULL pointer dereference at 0000000000000048
    [11798.058832] IP: [<ffffffff814411fa>] blkfront_resume+0x10a/0x610
    ....
    [11798.061063] Call Trace:
    [11798.061063]  [<ffffffff8139ce93>] xenbus_dev_resume+0x53/0x140
    [11798.061063]  [<ffffffff8139ce40>] ? xenbus_dev_probe+0x150/0x150
    [11798.061063]  [<ffffffff813f359e>] dpm_run_callback+0x3e/0x110
    [11798.061063]  [<ffffffff813f3a08>] device_resume+0x88/0x190
    [11798.061063]  [<ffffffff813f4cc0>] dpm_resume+0x100/0x2d0
    [11798.061063]  [<ffffffff813f5221>] dpm_resume_end+0x11/0x20
    [11798.061063]  [<ffffffff813950a8>] do_suspend+0xe8/0x1a0
    [11798.061063]  [<ffffffff813954bd>] shutdown_handler+0xfd/0x130
    [11798.061063]  [<ffffffff8139aba0>] ? split+0x110/0x110
    [11798.061063]  [<ffffffff8139ac26>] xenwatch_thread+0x86/0x120
    [11798.061063]  [<ffffffff810b4570>] ? prepare_to_wait_event+0x110/0x110
    [11798.061063]  [<ffffffff8108fe57>] kthread+0xd7/0xf0
    [11798.061063]  [<ffffffff811da811>] ? kfree+0x121/0x170
    [11798.061063]  [<ffffffff8108fd80>] ? kthread_park+0x60/0x60
    [11798.061063]  [<ffffffff810863b0>] ?  call_usermodehelper_exec_work+0xb0/0xb0
    [11798.061063]  [<ffffffff810864ea>] ?  call_usermodehelper_exec_async+0x13a/0x140
    [11798.061063]  [<ffffffff81534a45>] ret_from_fork+0x25/0x30
    
    Use the right index in the inner loop.
    
    Fixes: d05d7f40791c ("Merge branch 'for-4.8/core' of git://git.kernel.dk/linux-block")
    Fixes: 3fc9d690936f ("Merge branch 'for-4.8/drivers' of git://git.kernel.dk/linux-block")
    Signed-off-by: Munehisa Kamata <kamatam@amazon.com>
    Reviewed-by: Thomas Friebel <friebelt@amazon.de>
    Reviewed-by: Eduardo Valentin <eduval@amazon.com>
    Reviewed-by: Boris Ostrovsky <boris.ostrovsky@oracle.com>
    Cc: Juergen Gross <jgross@suse.com>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Reviewed-by: Roger Pau Monne <roger.pau@citrix.com>
    Cc: xen-devel@lists.xenproject.org
    Cc: stable@vger.kernel.org
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>

commit 557909e195aea23d9e6b29cef0be3d795f4cf675
Author: Alexander Usyskin <alexander.usyskin@intel.com>
Date:   Thu Aug 3 17:30:19 2017 +0300

    mei: exclude device from suspend direct complete optimization
    
    MEI device performs link reset during system suspend sequence.
    The link reset cannot be performed while device is in
    runtime suspend state. The resume sequence is bypassed with
    suspend direct complete optimization,so the optimization should be
    disabled for mei devices.
    
    Fixes:
     [  192.940537] Restarting tasks ...
     [  192.940610] PGI is not set
     [  192.940619] ------------[ cut here ]------------ [  192.940623]
     WARNING: CPU: 0
     me.c:653 mei_me_pg_exit_sync+0x351/0x360 [  192.940624] Modules
     linked
     in:
     [  192.940627] CPU: 0 PID: 1661 Comm: kworker/0:3 Not tainted
     4.13.0-rc2+
     #2 [  192.940628] Hardware name: Dell Inc. XPS 13 9343/0TM99H, BIOS
     A11
     12/08/2016 [  192.940630] Workqueue: pm pm_runtime_work <snip> [
     192.940642] Call Trace:
     [  192.940646]  ? pci_pme_active+0x1de/0x1f0 [  192.940649]  ?
     pci_restore_standard_config+0x50/0x50
     [  192.940651]  ? kfree+0x172/0x190
     [  192.940653]  ? kfree+0x172/0x190
     [  192.940655]  ? pci_restore_standard_config+0x50/0x50
     [  192.940663]  mei_me_pm_runtime_resume+0x3f/0xc0
     [  192.940665]  pci_pm_runtime_resume+0x7a/0xa0 [  192.940667]
     __rpm_callback+0xb9/0x1e0 [  192.940668]  ?
     preempt_count_add+0x6d/0xc0 [  192.940670]  rpm_callback+0x24/0x90 [
     192.940672]  ? pci_restore_standard_config+0x50/0x50
     [  192.940674]  rpm_resume+0x4e8/0x800 [  192.940676]
     pm_runtime_work+0x55/0xb0 [  192.940678]
     process_one_work+0x184/0x3e0 [  192.940680]
     worker_thread+0x4d/0x3a0 [ 192.940681]  ?
     preempt_count_sub+0x9b/0x100 [  192.940683]
     kthread+0x122/0x140 [  192.940684]  ? process_one_work+0x3e0/0x3e0 [
     192.940685]  ? __kthread_create_on_node+0x1a0/0x1a0
     [  192.940688]  ret_from_fork+0x27/0x40 [  192.940690] Code: 96 3a
     9e ff 48 8b 7d 98 e8 cd 21 58 00 83 bb bc 01 00 00
     04 0f 85 40 fe ff ff e9 41 fe ff ff 48 c7 c7 5f 04 99 96 e8 93 6b 9f
     ff <0f> ff e9 5d fd ff ff e8 33 fe 99 ff 0f 1f 00 0f 1f 44 00 00 55
     [  192.940719] ---[ end trace
     a86955597774ead8 ]--- [  192.942540] done.
    
    Suggested-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reported-by: Dominik Brodowski <linux@dominikbrodowski.net>
    Cc: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: Dominik Brodowski <linux@dominikbrodowski.net>
    Signed-off-by: Alexander Usyskin <alexander.usyskin@intel.com>
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 90de9634a5d57b92d8af4ec23aa2c9b297ec8168
Author: Johan Hovold <johan@kernel.org>
Date:   Thu Aug 10 08:06:39 2017 -0700

    ARM: OMAP2+: omap_device: drop broken RPM status update from suspend_noirq
    
    Since commit a8636c89648a ("PM / Runtime: Don't allow to suspend a
    device with an active child"), which went into 4.10, it is no longer
    permitted to set RPM_SUSPENDED state for a device with active children
    (unless power.ignore_children is set).
    
    This specifically means that the attempts to do just that from the omap
    pm-domain suspend_noirq callback have since been failing whenever a
    child is active, for example:
    
      am335x-usb-childs 47400000.usb: runtime PM trying to suspend
        device but active child
    
    Silence this warning by dropping the broken pm_runtime_set_suspended()
    call from the omap suspend_noirq callback along with the redundant
    pm_runtime_set_active() in resume_noirq.
    
    This effectively reverts commit 3522bf7bfa24 ("ARM: OMAP2+: omap_device:
    maintain sane runtime pm status around suspend/resume"), which started
    updating the RPM state after the runtime_suspend callback (!) for active
    omap devices had been called during system suspend. The rationale was
    that a later pm_runtime_get_sync() would then fail (even after runtime
    pm had been disabled) and that this in turn would avoid any external
    aborts when accessing registers with clocks disabled. (See also commit
    6f3c77b040fc ("PM / Runtime: let rpm_resume() succeed if RPM_ACTIVE,
    even when disabled, v2").
    
    But during the suspend_noirq phase all children would already have been
    suspended and their drivers would specifically not attempt any further
    register accesses. And if this was all just a workaround for random
    device drivers doing cross-tree calls during system suspend, those
    drivers should be fixed and updated to explicitly model such
    dependencies using device-links instead (and either way, any such calls
    have been causing crashes since 4.10).
    
    Fixes: 3522bf7bfa24 ("ARM: OMAP2+: omap_device: maintain sane runtime pm status around suspend/resume")
    Fixes: a8636c89648a ("PM / Runtime: Don't allow to suspend a device with an active child")
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: Dave Gerlach <d-gerlach@ti.com>
    Cc: Kevin Hilman <khilman@baylibre.com>
    Cc: Nishanth Menon <nm@ti.com>
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Cc: Tony Lindgren <tony@atomide.com>
    Cc: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Tested-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

commit 786f41fb6b008ea4341355b99083a38853a5311d
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Jul 21 02:09:22 2017 +0200

    PM / core: Split dpm_suspend_noirq() and dpm_resume_noirq()
    
    Put the device interrupts disabling and enabling as well as
    cpuidle_pause() and cpuidle_resume() called during the "noirq"
    stages of system suspend into separate functions to allow the
    core suspend-to-idle code to be optimized (later).
    
    The only functional difference this makes is that debug facilities
    and diagnostic tools will not include the above operations into the
    "noirq" device suspend/resume duration measurements.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 99f5ba009efddddb9d0ac34e735b2caf2c64e4a3
Author: Imre Deak <imre.deak@intel.com>
Date:   Tue May 2 15:04:09 2017 +0300

    drm/i915: Prevent the system suspend complete optimization
    
    commit 6ab92afc95c9bd6877cb42e7b24f65be887a5440 upstream.
    
    Since
    
    commit bac2a909a096c9110525c18cbb8ce73c660d5f71
    Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Date:   Wed Jan 21 02:17:42 2015 +0100
    
        PCI / PM: Avoid resuming PCI devices during system suspend
    
    PCI devices will default to allowing the system suspend complete
    optimization where devices are not woken up during system suspend if
    they were already runtime suspended. This however breaks the i915/HDA
    drivers for two reasons:
    
    - The i915 driver has system suspend specific steps that it needs to
      run, that bring the device to a different state than its runtime
      suspended state.
    
    - The HDA driver's suspend handler requires power that it will request
      from the i915 driver's power domain handler. This in turn requires the
      i915 driver to runtime resume itself, but this won't be possible if the
      suspend complete optimization is in effect: in this case the i915
      runtime PM is disabled and trying to get an RPM reference returns
      -EACCESS.
    
    Solve this by requiring the PCI/PM core to resume the device during
    system suspend which in effect disables the suspend complete optimization.
    
    Regardless of the above commit the optimization stayed disabled for DRM
    devices until
    
    commit d14d2a8453d650bea32a1c5271af1458cd283a0f
    Author: Lukas Wunner <lukas@wunner.de>
    Date:   Wed Jun 8 12:49:29 2016 +0200
    
        drm: Remove dev_pm_ops from drm_class
    
    so this patch is in practice a fix for this commit. Another reason for
    the bug staying hidden for so long is that the optimization for a device
    is disabled if it's disabled for any of its children devices. i915 may
    have a backlight device as its child which doesn't support runtime PM
    and so doesn't allow the optimization either.  So if this backlight
    device got registered the bug stayed hidden.
    
    Credits to Marta, Tomi and David who enabled pstore logging,
    that caught one instance of this issue across a suspend/
    resume-to-ram and Ville who rememberd that the optimization was enabled
    for some devices at one point.
    
    The first WARN triggered by the problem:
    
    [ 6250.746445] WARNING: CPU: 2 PID: 17384 at drivers/gpu/drm/i915/intel_runtime_pm.c:2846 intel_runtime_pm_get+0x6b/0xd0 [i915]
    [ 6250.746448] pm_runtime_get_sync() failed: -13
    [ 6250.746451] Modules linked in: snd_hda_intel i915 vgem snd_hda_codec_hdmi x86_pkg_temp_thermal intel_powerclamp coretemp crct10dif_pclmul crc32_pclmul
    snd_hda_codec_realtek snd_hda_codec_generic ghash_clmulni_intel e1000e snd_hda_codec snd_hwdep snd_hda_core ptp mei_me pps_core snd_pcm lpc_ich mei prime_
    numbers i2c_hid i2c_designware_platform i2c_designware_core [last unloaded: i915]
    [ 6250.746512] CPU: 2 PID: 17384 Comm: kworker/u8:0 Tainted: G     U  W       4.11.0-rc5-CI-CI_DRM_334+ #1
    [ 6250.746515] Hardware name:                  /NUC5i5RYB, BIOS RYBDWi35.86A.0362.2017.0118.0940 01/18/2017
    [ 6250.746521] Workqueue: events_unbound async_run_entry_fn
    [ 6250.746525] Call Trace:
    [ 6250.746530]  dump_stack+0x67/0x92
    [ 6250.746536]  __warn+0xc6/0xe0
    [ 6250.746542]  ? pci_restore_standard_config+0x40/0x40
    [ 6250.746546]  warn_slowpath_fmt+0x46/0x50
    [ 6250.746553]  ? __pm_runtime_resume+0x56/0x80
    [ 6250.746584]  intel_runtime_pm_get+0x6b/0xd0 [i915]
    [ 6250.746610]  intel_display_power_get+0x1b/0x40 [i915]
    [ 6250.746646]  i915_audio_component_get_power+0x15/0x20 [i915]
    [ 6250.746654]  snd_hdac_display_power+0xc8/0x110 [snd_hda_core]
    [ 6250.746661]  azx_runtime_resume+0x218/0x280 [snd_hda_intel]
    [ 6250.746667]  pci_pm_runtime_resume+0x76/0xa0
    [ 6250.746672]  __rpm_callback+0xb4/0x1f0
    [ 6250.746677]  ? pci_restore_standard_config+0x40/0x40
    [ 6250.746682]  rpm_callback+0x1f/0x80
    [ 6250.746686]  ? pci_restore_standard_config+0x40/0x40
    [ 6250.746690]  rpm_resume+0x4ba/0x740
    [ 6250.746698]  __pm_runtime_resume+0x49/0x80
    [ 6250.746703]  pci_pm_suspend+0x57/0x140
    [ 6250.746709]  dpm_run_callback+0x6f/0x330
    [ 6250.746713]  ? pci_pm_freeze+0xe0/0xe0
    [ 6250.746718]  __device_suspend+0xf9/0x370
    [ 6250.746724]  ? dpm_watchdog_set+0x60/0x60
    [ 6250.746730]  async_suspend+0x1a/0x90
    [ 6250.746735]  async_run_entry_fn+0x34/0x160
    [ 6250.746741]  process_one_work+0x1f2/0x6d0
    [ 6250.746749]  worker_thread+0x49/0x4a0
    [ 6250.746755]  kthread+0x107/0x140
    [ 6250.746759]  ? process_one_work+0x6d0/0x6d0
    [ 6250.746763]  ? kthread_create_on_node+0x40/0x40
    [ 6250.746768]  ret_from_fork+0x2e/0x40
    [ 6250.746778] ---[ end trace 102a62fd2160f5e6 ]---
    
    v2:
    - Use the new pci_dev->needs_resume flag, to avoid any overhead during
      the ->pm_prepare hook. (Rafael)
    
    v3:
    - Update commit message to reference the actual regressing commit.
      (Lukas)
    
    v4:
    - Rebase on v4 of patch 1/2.
    
    Fixes: d14d2a8453d6 ("drm: Remove dev_pm_ops from drm_class")
    References: https://bugs.freedesktop.org/show_bug.cgi?id=100378
    References: https://bugs.freedesktop.org/show_bug.cgi?id=100770
    Cc: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: Marta Lofstedt <marta.lofstedt@intel.com>
    Cc: David Weinehall <david.weinehall@linux.intel.com>
    Cc: Tomi Sarvela <tomi.p.sarvela@intel.com>
    Cc: Ville Syrjl <ville.syrjala@linux.intel.com>
    Cc: Mika Kuoppala <mika.kuoppala@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Takashi Iwai <tiwai@suse.de>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Lukas Wunner <lukas@wunner.de>
    Cc: linux-pci@vger.kernel.org
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reported-and-tested-by: Marta Lofstedt <marta.lofstedt@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1493726649-32094-2-git-send-email-imre.deak@intel.com
    (cherry picked from commit adfdf85d795f4d4f487b61ee0b169d64c6e19081)
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 7a7b2d5f65a7a12c4f5d43fb10913ca908102833
Author: Imre Deak <imre.deak@intel.com>
Date:   Tue May 2 15:04:09 2017 +0300

    drm/i915: Prevent the system suspend complete optimization
    
    commit 6ab92afc95c9bd6877cb42e7b24f65be887a5440 upstream.
    
    Since
    
    commit bac2a909a096c9110525c18cbb8ce73c660d5f71
    Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Date:   Wed Jan 21 02:17:42 2015 +0100
    
        PCI / PM: Avoid resuming PCI devices during system suspend
    
    PCI devices will default to allowing the system suspend complete
    optimization where devices are not woken up during system suspend if
    they were already runtime suspended. This however breaks the i915/HDA
    drivers for two reasons:
    
    - The i915 driver has system suspend specific steps that it needs to
      run, that bring the device to a different state than its runtime
      suspended state.
    
    - The HDA driver's suspend handler requires power that it will request
      from the i915 driver's power domain handler. This in turn requires the
      i915 driver to runtime resume itself, but this won't be possible if the
      suspend complete optimization is in effect: in this case the i915
      runtime PM is disabled and trying to get an RPM reference returns
      -EACCESS.
    
    Solve this by requiring the PCI/PM core to resume the device during
    system suspend which in effect disables the suspend complete optimization.
    
    Regardless of the above commit the optimization stayed disabled for DRM
    devices until
    
    commit d14d2a8453d650bea32a1c5271af1458cd283a0f
    Author: Lukas Wunner <lukas@wunner.de>
    Date:   Wed Jun 8 12:49:29 2016 +0200
    
        drm: Remove dev_pm_ops from drm_class
    
    so this patch is in practice a fix for this commit. Another reason for
    the bug staying hidden for so long is that the optimization for a device
    is disabled if it's disabled for any of its children devices. i915 may
    have a backlight device as its child which doesn't support runtime PM
    and so doesn't allow the optimization either.  So if this backlight
    device got registered the bug stayed hidden.
    
    Credits to Marta, Tomi and David who enabled pstore logging,
    that caught one instance of this issue across a suspend/
    resume-to-ram and Ville who rememberd that the optimization was enabled
    for some devices at one point.
    
    The first WARN triggered by the problem:
    
    [ 6250.746445] WARNING: CPU: 2 PID: 17384 at drivers/gpu/drm/i915/intel_runtime_pm.c:2846 intel_runtime_pm_get+0x6b/0xd0 [i915]
    [ 6250.746448] pm_runtime_get_sync() failed: -13
    [ 6250.746451] Modules linked in: snd_hda_intel i915 vgem snd_hda_codec_hdmi x86_pkg_temp_thermal intel_powerclamp coretemp crct10dif_pclmul crc32_pclmul
    snd_hda_codec_realtek snd_hda_codec_generic ghash_clmulni_intel e1000e snd_hda_codec snd_hwdep snd_hda_core ptp mei_me pps_core snd_pcm lpc_ich mei prime_
    numbers i2c_hid i2c_designware_platform i2c_designware_core [last unloaded: i915]
    [ 6250.746512] CPU: 2 PID: 17384 Comm: kworker/u8:0 Tainted: G     U  W       4.11.0-rc5-CI-CI_DRM_334+ #1
    [ 6250.746515] Hardware name:                  /NUC5i5RYB, BIOS RYBDWi35.86A.0362.2017.0118.0940 01/18/2017
    [ 6250.746521] Workqueue: events_unbound async_run_entry_fn
    [ 6250.746525] Call Trace:
    [ 6250.746530]  dump_stack+0x67/0x92
    [ 6250.746536]  __warn+0xc6/0xe0
    [ 6250.746542]  ? pci_restore_standard_config+0x40/0x40
    [ 6250.746546]  warn_slowpath_fmt+0x46/0x50
    [ 6250.746553]  ? __pm_runtime_resume+0x56/0x80
    [ 6250.746584]  intel_runtime_pm_get+0x6b/0xd0 [i915]
    [ 6250.746610]  intel_display_power_get+0x1b/0x40 [i915]
    [ 6250.746646]  i915_audio_component_get_power+0x15/0x20 [i915]
    [ 6250.746654]  snd_hdac_display_power+0xc8/0x110 [snd_hda_core]
    [ 6250.746661]  azx_runtime_resume+0x218/0x280 [snd_hda_intel]
    [ 6250.746667]  pci_pm_runtime_resume+0x76/0xa0
    [ 6250.746672]  __rpm_callback+0xb4/0x1f0
    [ 6250.746677]  ? pci_restore_standard_config+0x40/0x40
    [ 6250.746682]  rpm_callback+0x1f/0x80
    [ 6250.746686]  ? pci_restore_standard_config+0x40/0x40
    [ 6250.746690]  rpm_resume+0x4ba/0x740
    [ 6250.746698]  __pm_runtime_resume+0x49/0x80
    [ 6250.746703]  pci_pm_suspend+0x57/0x140
    [ 6250.746709]  dpm_run_callback+0x6f/0x330
    [ 6250.746713]  ? pci_pm_freeze+0xe0/0xe0
    [ 6250.746718]  __device_suspend+0xf9/0x370
    [ 6250.746724]  ? dpm_watchdog_set+0x60/0x60
    [ 6250.746730]  async_suspend+0x1a/0x90
    [ 6250.746735]  async_run_entry_fn+0x34/0x160
    [ 6250.746741]  process_one_work+0x1f2/0x6d0
    [ 6250.746749]  worker_thread+0x49/0x4a0
    [ 6250.746755]  kthread+0x107/0x140
    [ 6250.746759]  ? process_one_work+0x6d0/0x6d0
    [ 6250.746763]  ? kthread_create_on_node+0x40/0x40
    [ 6250.746768]  ret_from_fork+0x2e/0x40
    [ 6250.746778] ---[ end trace 102a62fd2160f5e6 ]---
    
    v2:
    - Use the new pci_dev->needs_resume flag, to avoid any overhead during
      the ->pm_prepare hook. (Rafael)
    
    v3:
    - Update commit message to reference the actual regressing commit.
      (Lukas)
    
    v4:
    - Rebase on v4 of patch 1/2.
    
    Fixes: d14d2a8453d6 ("drm: Remove dev_pm_ops from drm_class")
    References: https://bugs.freedesktop.org/show_bug.cgi?id=100378
    References: https://bugs.freedesktop.org/show_bug.cgi?id=100770
    Cc: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: Marta Lofstedt <marta.lofstedt@intel.com>
    Cc: David Weinehall <david.weinehall@linux.intel.com>
    Cc: Tomi Sarvela <tomi.p.sarvela@intel.com>
    Cc: Ville Syrjl <ville.syrjala@linux.intel.com>
    Cc: Mika Kuoppala <mika.kuoppala@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Takashi Iwai <tiwai@suse.de>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Lukas Wunner <lukas@wunner.de>
    Cc: linux-pci@vger.kernel.org
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reported-and-tested-by: Marta Lofstedt <marta.lofstedt@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1493726649-32094-2-git-send-email-imre.deak@intel.com
    (cherry picked from commit adfdf85d795f4d4f487b61ee0b169d64c6e19081)
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 33e4f80ee69b5168badf37edbfed796eb48434b9
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Jun 12 22:56:34 2017 +0200

    ACPI / PM: Ignore spurious SCI wakeups from suspend-to-idle
    
    The ACPI SCI (System Control Interrupt) is set up as a wakeup IRQ
    during suspend-to-idle transitions and, consequently, any events
    signaled through it wake up the system from that state.  However,
    on some systems some of the events signaled via the ACPI SCI while
    suspended to idle should not cause the system to wake up.  In fact,
    quite often they should just be discarded.
    
    Arguably, systems should not resume entirely on such events, but in
    order to decide which events really should cause the system to resume
    and which are spurious, it is necessary to resume up to the point
    when ACPI SCIs are actually handled and processed, which is after
    executing dpm_resume_noirq() in the system resume path.
    
    For this reasons, add a loop around freeze_enter() in which the
    platforms can process events signaled via multiplexed IRQ lines
    like the ACPI SCI and add suspend-to-idle hooks that can be
    used for this purpose to struct platform_freeze_ops.
    
    In the ACPI case, the ->wake hook is used for checking if the SCI
    has triggered while suspended and deferring the interrupt-induced
    system wakeup until the events signaled through it are actually
    processed sufficiently to decide whether or not the system should
    resume.  In turn, the ->sync hook allows all of the relevant event
    queues to be flushed so as to prevent events from being missed due
    to race conditions.
    
    In addition to that, some ACPI code processing wakeup events needs
    to be modified to use the "hard" version of wakeup triggers, so that
    it will cause a system resume to happen on device-induced wakeup
    events even if the "soft" mechanism to prevent the system from
    suspending is not enabled.  However, to preserve the existing
    behavior with respect to suspend-to-RAM, this only is done in
    the suspend-to-idle case and only if an SCI has occurred while
    suspended.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit d438aa223e931bfb74dd459bb6c7f3139c48b528
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Jun 12 22:49:40 2017 +0200

    USB / PCI / PM: Allow the PCI core to do the resume cleanup
    
    hcd_pci_resume_noirq() used as a universal _resume_noirq handler for
    PCI USB controllers calls pci_back_from_sleep() which is unnecessary
    and may become problematic.
    
    It is unnecessary, because the PCI bus type carries out post-suspend
    cleanup of all PCI devices during resume and that covers all things
    done by the pci_back_from_sleep().  There is no reason why USB cannot
    follow all of the other PCI devices in that respect.
    
    It will become problematic after subsequent changes that make it
    possible to go back to sleep again after executing dpm_resume_noirq()
    if no valid system wakeup events have been detected at that point.
    Namely, calling pci_back_from_sleep() at the _resume_noirq stage
    will cause the wakeup status of the devices in question to be cleared
    and if any of them has triggered system wakeup, that event may be
    missed then.
    
    For the above reasons, drop the pci_back_from_sleep() invocation
    from hcd_pci_resume_noirq().
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit f3b0fe6bfcbf9f36e7156984ad5ae6b34102c0e6
Author: Liam Breck <liam@networkimprov.net>
Date:   Wed Jan 18 09:26:49 2017 -0800

    power: supply: bq24190_charger: Call set_mode_host() on pm_resume()
    
    [ Upstream commit e05ad7e0741ce0505e1df157c62b22b95172bb97 ]
    
    pm_resume() does a register_reset() which clears charger host mode.
    
    Fix by calling set_mode_host() after the reset.
    
    Fixes: d7bf353fd0aa3 ("bq24190_charger: Add support for TI BQ24190 Battery Charger")
    Signed-off-by: Liam Breck <kernel@networkimprov.net>
    Acked-by: Mark Greer <mgreer@animalcreek.com>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Sebastian Reichel <sre@kernel.org>
    Signed-off-by: Sasha Levin <alexander.levin@verizon.com>

commit 6ab92afc95c9bd6877cb42e7b24f65be887a5440
Author: Imre Deak <imre.deak@intel.com>
Date:   Tue May 2 15:04:09 2017 +0300

    drm/i915: Prevent the system suspend complete optimization
    
    Since
    
    commit bac2a909a096c9110525c18cbb8ce73c660d5f71
    Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Date:   Wed Jan 21 02:17:42 2015 +0100
    
        PCI / PM: Avoid resuming PCI devices during system suspend
    
    PCI devices will default to allowing the system suspend complete
    optimization where devices are not woken up during system suspend if
    they were already runtime suspended. This however breaks the i915/HDA
    drivers for two reasons:
    
    - The i915 driver has system suspend specific steps that it needs to
      run, that bring the device to a different state than its runtime
      suspended state.
    
    - The HDA driver's suspend handler requires power that it will request
      from the i915 driver's power domain handler. This in turn requires the
      i915 driver to runtime resume itself, but this won't be possible if the
      suspend complete optimization is in effect: in this case the i915
      runtime PM is disabled and trying to get an RPM reference returns
      -EACCESS.
    
    Solve this by requiring the PCI/PM core to resume the device during
    system suspend which in effect disables the suspend complete optimization.
    
    Regardless of the above commit the optimization stayed disabled for DRM
    devices until
    
    commit d14d2a8453d650bea32a1c5271af1458cd283a0f
    Author: Lukas Wunner <lukas@wunner.de>
    Date:   Wed Jun 8 12:49:29 2016 +0200
    
        drm: Remove dev_pm_ops from drm_class
    
    so this patch is in practice a fix for this commit. Another reason for
    the bug staying hidden for so long is that the optimization for a device
    is disabled if it's disabled for any of its children devices. i915 may
    have a backlight device as its child which doesn't support runtime PM
    and so doesn't allow the optimization either.  So if this backlight
    device got registered the bug stayed hidden.
    
    Credits to Marta, Tomi and David who enabled pstore logging,
    that caught one instance of this issue across a suspend/
    resume-to-ram and Ville who rememberd that the optimization was enabled
    for some devices at one point.
    
    The first WARN triggered by the problem:
    
    [ 6250.746445] WARNING: CPU: 2 PID: 17384 at drivers/gpu/drm/i915/intel_runtime_pm.c:2846 intel_runtime_pm_get+0x6b/0xd0 [i915]
    [ 6250.746448] pm_runtime_get_sync() failed: -13
    [ 6250.746451] Modules linked in: snd_hda_intel i915 vgem snd_hda_codec_hdmi x86_pkg_temp_thermal intel_powerclamp coretemp crct10dif_pclmul crc32_pclmul
    snd_hda_codec_realtek snd_hda_codec_generic ghash_clmulni_intel e1000e snd_hda_codec snd_hwdep snd_hda_core ptp mei_me pps_core snd_pcm lpc_ich mei prime_
    numbers i2c_hid i2c_designware_platform i2c_designware_core [last unloaded: i915]
    [ 6250.746512] CPU: 2 PID: 17384 Comm: kworker/u8:0 Tainted: G     U  W       4.11.0-rc5-CI-CI_DRM_334+ #1
    [ 6250.746515] Hardware name:                  /NUC5i5RYB, BIOS RYBDWi35.86A.0362.2017.0118.0940 01/18/2017
    [ 6250.746521] Workqueue: events_unbound async_run_entry_fn
    [ 6250.746525] Call Trace:
    [ 6250.746530]  dump_stack+0x67/0x92
    [ 6250.746536]  __warn+0xc6/0xe0
    [ 6250.746542]  ? pci_restore_standard_config+0x40/0x40
    [ 6250.746546]  warn_slowpath_fmt+0x46/0x50
    [ 6250.746553]  ? __pm_runtime_resume+0x56/0x80
    [ 6250.746584]  intel_runtime_pm_get+0x6b/0xd0 [i915]
    [ 6250.746610]  intel_display_power_get+0x1b/0x40 [i915]
    [ 6250.746646]  i915_audio_component_get_power+0x15/0x20 [i915]
    [ 6250.746654]  snd_hdac_display_power+0xc8/0x110 [snd_hda_core]
    [ 6250.746661]  azx_runtime_resume+0x218/0x280 [snd_hda_intel]
    [ 6250.746667]  pci_pm_runtime_resume+0x76/0xa0
    [ 6250.746672]  __rpm_callback+0xb4/0x1f0
    [ 6250.746677]  ? pci_restore_standard_config+0x40/0x40
    [ 6250.746682]  rpm_callback+0x1f/0x80
    [ 6250.746686]  ? pci_restore_standard_config+0x40/0x40
    [ 6250.746690]  rpm_resume+0x4ba/0x740
    [ 6250.746698]  __pm_runtime_resume+0x49/0x80
    [ 6250.746703]  pci_pm_suspend+0x57/0x140
    [ 6250.746709]  dpm_run_callback+0x6f/0x330
    [ 6250.746713]  ? pci_pm_freeze+0xe0/0xe0
    [ 6250.746718]  __device_suspend+0xf9/0x370
    [ 6250.746724]  ? dpm_watchdog_set+0x60/0x60
    [ 6250.746730]  async_suspend+0x1a/0x90
    [ 6250.746735]  async_run_entry_fn+0x34/0x160
    [ 6250.746741]  process_one_work+0x1f2/0x6d0
    [ 6250.746749]  worker_thread+0x49/0x4a0
    [ 6250.746755]  kthread+0x107/0x140
    [ 6250.746759]  ? process_one_work+0x6d0/0x6d0
    [ 6250.746763]  ? kthread_create_on_node+0x40/0x40
    [ 6250.746768]  ret_from_fork+0x2e/0x40
    [ 6250.746778] ---[ end trace 102a62fd2160f5e6 ]---
    
    v2:
    - Use the new pci_dev->needs_resume flag, to avoid any overhead during
      the ->pm_prepare hook. (Rafael)
    
    v3:
    - Update commit message to reference the actual regressing commit.
      (Lukas)
    
    v4:
    - Rebase on v4 of patch 1/2.
    
    Fixes: d14d2a8453d6 ("drm: Remove dev_pm_ops from drm_class")
    References: https://bugs.freedesktop.org/show_bug.cgi?id=100378
    References: https://bugs.freedesktop.org/show_bug.cgi?id=100770
    Cc: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: Marta Lofstedt <marta.lofstedt@intel.com>
    Cc: David Weinehall <david.weinehall@linux.intel.com>
    Cc: Tomi Sarvela <tomi.p.sarvela@intel.com>
    Cc: Ville Syrjl <ville.syrjala@linux.intel.com>
    Cc: Mika Kuoppala <mika.kuoppala@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Takashi Iwai <tiwai@suse.de>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Lukas Wunner <lukas@wunner.de>
    Cc: linux-pci@vger.kernel.org
    Cc: <stable@vger.kernel.org> # v4.10.x: 4d071c3 - PCI/PM: Add needs_resume flag
    Cc: <stable@vger.kernel.org> # v4.10.x
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reported-and-tested-by: Marta Lofstedt <marta.lofstedt@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1493726649-32094-2-git-send-email-imre.deak@intel.com
    (cherry picked from commit adfdf85d795f4d4f487b61ee0b169d64c6e19081)
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>

commit 8fa4338acca96cbc231e4125229632e879476464
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri Jun 2 14:49:45 2017 +1000

    drm/nouveau: enable autosuspend only when it'll actually be used
    
    This prevents a deadlock that somehow results from the suspend() ->
    forbid() -> resume() callchain.
    
    [  125.266960] [drm] Initialized nouveau 1.3.1 20120801 for 0000:02:00.0 on minor 1
    [  370.120872] INFO: task kworker/4:1:77 blocked for more than 120 seconds.
    [  370.120920]       Tainted: G           O    4.12.0-rc3 #20
    [  370.120947] "echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
    [  370.120982] kworker/4:1     D13808    77      2 0x00000000
    [  370.120998] Workqueue: pm pm_runtime_work
    [  370.121004] Call Trace:
    [  370.121018]  __schedule+0x2bf/0xb40
    [  370.121025]  ? mark_held_locks+0x5f/0x90
    [  370.121038]  schedule+0x3d/0x90
    [  370.121044]  rpm_resume+0x107/0x870
    [  370.121052]  ? finish_wait+0x90/0x90
    [  370.121065]  ? pci_pm_runtime_resume+0xa0/0xa0
    [  370.121070]  pm_runtime_forbid+0x4c/0x60
    [  370.121129]  nouveau_pmops_runtime_suspend+0xaf/0xc0 [nouveau]
    [  370.121139]  pci_pm_runtime_suspend+0x5f/0x170
    [  370.121147]  ? pci_pm_runtime_resume+0xa0/0xa0
    [  370.121152]  __rpm_callback+0xb9/0x1e0
    [  370.121159]  ? pci_pm_runtime_resume+0xa0/0xa0
    [  370.121166]  rpm_callback+0x24/0x80
    [  370.121171]  ? pci_pm_runtime_resume+0xa0/0xa0
    [  370.121176]  rpm_suspend+0x138/0x6e0
    [  370.121192]  pm_runtime_work+0x7b/0xc0
    [  370.121199]  process_one_work+0x253/0x6a0
    [  370.121216]  worker_thread+0x4d/0x3b0
    [  370.121229]  kthread+0x133/0x150
    [  370.121234]  ? process_one_work+0x6a0/0x6a0
    [  370.121238]  ? kthread_create_on_node+0x70/0x70
    [  370.121246]  ret_from_fork+0x2a/0x40
    [  370.121283]
                   Showing all locks held in the system:
    [  370.121291] 2 locks held by kworker/4:1/77:
    [  370.121298]  #0:  ("pm"){.+.+.+}, at: [<ffffffffac0d3530>] process_one_work+0x1d0/0x6a0
    [  370.121315]  #1:  ((&dev->power.work)){+.+.+.}, at: [<ffffffffac0d3530>] process_one_work+0x1d0/0x6a0
    [  370.121330] 1 lock held by khungtaskd/81:
    [  370.121333]  #0:  (tasklist_lock){.+.+..}, at: [<ffffffffac10fc8d>] debug_show_all_locks+0x3d/0x1a0
    [  370.121355] 1 lock held by dmesg/1639:
    [  370.121358]  #0:  (&user->lock){+.+.+.}, at: [<ffffffffac124b6d>] devkmsg_read+0x4d/0x360
    
    [  370.121377] =============================================
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

commit cddddea5a5ddae7cd61b54de55f91b3668c10eca
Author: Liam Breck <liam@networkimprov.net>
Date:   Wed Jan 18 09:26:49 2017 -0800

    power: supply: bq24190_charger: Call set_mode_host() on pm_resume()
    
    commit e05ad7e0741ce0505e1df157c62b22b95172bb97 upstream.
    
    pm_resume() does a register_reset() which clears charger host mode.
    
    Fix by calling set_mode_host() after the reset.
    
    Fixes: d7bf353fd0aa3 ("bq24190_charger: Add support for TI BQ24190 Battery Charger")
    Signed-off-by: Liam Breck <kernel@networkimprov.net>
    Acked-by: Mark Greer <mgreer@animalcreek.com>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Sebastian Reichel <sre@kernel.org>
    [bwh: Backported to 3.16: adjust filename]
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit adfdf85d795f4d4f487b61ee0b169d64c6e19081
Author: Imre Deak <imre.deak@intel.com>
Date:   Tue May 2 15:04:09 2017 +0300

    drm/i915: Prevent the system suspend complete optimization
    
    Since
    
    commit bac2a909a096c9110525c18cbb8ce73c660d5f71
    Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Date:   Wed Jan 21 02:17:42 2015 +0100
    
        PCI / PM: Avoid resuming PCI devices during system suspend
    
    PCI devices will default to allowing the system suspend complete
    optimization where devices are not woken up during system suspend if
    they were already runtime suspended. This however breaks the i915/HDA
    drivers for two reasons:
    
    - The i915 driver has system suspend specific steps that it needs to
      run, that bring the device to a different state than its runtime
      suspended state.
    
    - The HDA driver's suspend handler requires power that it will request
      from the i915 driver's power domain handler. This in turn requires the
      i915 driver to runtime resume itself, but this won't be possible if the
      suspend complete optimization is in effect: in this case the i915
      runtime PM is disabled and trying to get an RPM reference returns
      -EACCESS.
    
    Solve this by requiring the PCI/PM core to resume the device during
    system suspend which in effect disables the suspend complete optimization.
    
    Regardless of the above commit the optimization stayed disabled for DRM
    devices until
    
    commit d14d2a8453d650bea32a1c5271af1458cd283a0f
    Author: Lukas Wunner <lukas@wunner.de>
    Date:   Wed Jun 8 12:49:29 2016 +0200
    
        drm: Remove dev_pm_ops from drm_class
    
    so this patch is in practice a fix for this commit. Another reason for
    the bug staying hidden for so long is that the optimization for a device
    is disabled if it's disabled for any of its children devices. i915 may
    have a backlight device as its child which doesn't support runtime PM
    and so doesn't allow the optimization either.  So if this backlight
    device got registered the bug stayed hidden.
    
    Credits to Marta, Tomi and David who enabled pstore logging,
    that caught one instance of this issue across a suspend/
    resume-to-ram and Ville who rememberd that the optimization was enabled
    for some devices at one point.
    
    The first WARN triggered by the problem:
    
    [ 6250.746445] WARNING: CPU: 2 PID: 17384 at drivers/gpu/drm/i915/intel_runtime_pm.c:2846 intel_runtime_pm_get+0x6b/0xd0 [i915]
    [ 6250.746448] pm_runtime_get_sync() failed: -13
    [ 6250.746451] Modules linked in: snd_hda_intel i915 vgem snd_hda_codec_hdmi x86_pkg_temp_thermal intel_powerclamp coretemp crct10dif_pclmul crc32_pclmul
    snd_hda_codec_realtek snd_hda_codec_generic ghash_clmulni_intel e1000e snd_hda_codec snd_hwdep snd_hda_core ptp mei_me pps_core snd_pcm lpc_ich mei prime_
    numbers i2c_hid i2c_designware_platform i2c_designware_core [last unloaded: i915]
    [ 6250.746512] CPU: 2 PID: 17384 Comm: kworker/u8:0 Tainted: G     U  W       4.11.0-rc5-CI-CI_DRM_334+ #1
    [ 6250.746515] Hardware name:                  /NUC5i5RYB, BIOS RYBDWi35.86A.0362.2017.0118.0940 01/18/2017
    [ 6250.746521] Workqueue: events_unbound async_run_entry_fn
    [ 6250.746525] Call Trace:
    [ 6250.746530]  dump_stack+0x67/0x92
    [ 6250.746536]  __warn+0xc6/0xe0
    [ 6250.746542]  ? pci_restore_standard_config+0x40/0x40
    [ 6250.746546]  warn_slowpath_fmt+0x46/0x50
    [ 6250.746553]  ? __pm_runtime_resume+0x56/0x80
    [ 6250.746584]  intel_runtime_pm_get+0x6b/0xd0 [i915]
    [ 6250.746610]  intel_display_power_get+0x1b/0x40 [i915]
    [ 6250.746646]  i915_audio_component_get_power+0x15/0x20 [i915]
    [ 6250.746654]  snd_hdac_display_power+0xc8/0x110 [snd_hda_core]
    [ 6250.746661]  azx_runtime_resume+0x218/0x280 [snd_hda_intel]
    [ 6250.746667]  pci_pm_runtime_resume+0x76/0xa0
    [ 6250.746672]  __rpm_callback+0xb4/0x1f0
    [ 6250.746677]  ? pci_restore_standard_config+0x40/0x40
    [ 6250.746682]  rpm_callback+0x1f/0x80
    [ 6250.746686]  ? pci_restore_standard_config+0x40/0x40
    [ 6250.746690]  rpm_resume+0x4ba/0x740
    [ 6250.746698]  __pm_runtime_resume+0x49/0x80
    [ 6250.746703]  pci_pm_suspend+0x57/0x140
    [ 6250.746709]  dpm_run_callback+0x6f/0x330
    [ 6250.746713]  ? pci_pm_freeze+0xe0/0xe0
    [ 6250.746718]  __device_suspend+0xf9/0x370
    [ 6250.746724]  ? dpm_watchdog_set+0x60/0x60
    [ 6250.746730]  async_suspend+0x1a/0x90
    [ 6250.746735]  async_run_entry_fn+0x34/0x160
    [ 6250.746741]  process_one_work+0x1f2/0x6d0
    [ 6250.746749]  worker_thread+0x49/0x4a0
    [ 6250.746755]  kthread+0x107/0x140
    [ 6250.746759]  ? process_one_work+0x6d0/0x6d0
    [ 6250.746763]  ? kthread_create_on_node+0x40/0x40
    [ 6250.746768]  ret_from_fork+0x2e/0x40
    [ 6250.746778] ---[ end trace 102a62fd2160f5e6 ]---
    
    v2:
    - Use the new pci_dev->needs_resume flag, to avoid any overhead during
      the ->pm_prepare hook. (Rafael)
    
    v3:
    - Update commit message to reference the actual regressing commit.
      (Lukas)
    
    v4:
    - Rebase on v4 of patch 1/2.
    
    Fixes: d14d2a8453d6 ("drm: Remove dev_pm_ops from drm_class")
    References: https://bugs.freedesktop.org/show_bug.cgi?id=100378
    References: https://bugs.freedesktop.org/show_bug.cgi?id=100770
    Cc: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: Marta Lofstedt <marta.lofstedt@intel.com>
    Cc: David Weinehall <david.weinehall@linux.intel.com>
    Cc: Tomi Sarvela <tomi.p.sarvela@intel.com>
    Cc: Ville Syrjl <ville.syrjala@linux.intel.com>
    Cc: Mika Kuoppala <mika.kuoppala@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Takashi Iwai <tiwai@suse.de>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Lukas Wunner <lukas@wunner.de>
    Cc: linux-pci@vger.kernel.org
    Cc: <stable@vger.kernel.org> # v4.10.x: 4d071c3 - PCI/PM: Add needs_resume flag
    Cc: <stable@vger.kernel.org> # v4.10.x
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reported-and-tested-by: Marta Lofstedt <marta.lofstedt@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1493726649-32094-2-git-send-email-imre.deak@intel.com

commit c710e9585569217d03531b5a4666bef731d2c226
Author: Liam Breck <liam@networkimprov.net>
Date:   Wed Jan 18 09:26:49 2017 -0800

    power: supply: bq24190_charger: Call set_mode_host() on pm_resume()
    
    commit e05ad7e0741ce0505e1df157c62b22b95172bb97 upstream.
    
    pm_resume() does a register_reset() which clears charger host mode.
    
    Fix by calling set_mode_host() after the reset.
    
    Fixes: d7bf353fd0aa3 ("bq24190_charger: Add support for TI BQ24190 Battery Charger")
    Signed-off-by: Liam Breck <kernel@networkimprov.net>
    Acked-by: Mark Greer <mgreer@animalcreek.com>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Sebastian Reichel <sre@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 8c94da036756c32566c2da0c5c33f519b1dbbfeb
Author: Liam Breck <liam@networkimprov.net>
Date:   Wed Jan 18 09:26:49 2017 -0800

    power: supply: bq24190_charger: Call set_mode_host() on pm_resume()
    
    commit e05ad7e0741ce0505e1df157c62b22b95172bb97 upstream.
    
    pm_resume() does a register_reset() which clears charger host mode.
    
    Fix by calling set_mode_host() after the reset.
    
    Fixes: d7bf353fd0aa3 ("bq24190_charger: Add support for TI BQ24190 Battery Charger")
    Signed-off-by: Liam Breck <kernel@networkimprov.net>
    Acked-by: Mark Greer <mgreer@animalcreek.com>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Sebastian Reichel <sre@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 20e448f2251c0a78421889267b3709758c544ff2
Author: Liam Breck <liam@networkimprov.net>
Date:   Wed Jan 18 09:26:49 2017 -0800

    power: supply: bq24190_charger: Call set_mode_host() on pm_resume()
    
    commit e05ad7e0741ce0505e1df157c62b22b95172bb97 upstream.
    
    pm_resume() does a register_reset() which clears charger host mode.
    
    Fix by calling set_mode_host() after the reset.
    
    Fixes: d7bf353fd0aa3 ("bq24190_charger: Add support for TI BQ24190 Battery Charger")
    Signed-off-by: Liam Breck <kernel@networkimprov.net>
    Acked-by: Mark Greer <mgreer@animalcreek.com>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Sebastian Reichel <sre@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 760d62e94017b55368a0905f36d47c5035c83b84
Author: Liam Breck <liam@networkimprov.net>
Date:   Wed Jan 18 09:26:49 2017 -0800

    power: supply: bq24190_charger: Call set_mode_host() on pm_resume()
    
    commit e05ad7e0741ce0505e1df157c62b22b95172bb97 upstream.
    
    pm_resume() does a register_reset() which clears charger host mode.
    
    Fix by calling set_mode_host() after the reset.
    
    Fixes: d7bf353fd0aa3 ("bq24190_charger: Add support for TI BQ24190 Battery Charger")
    Signed-off-by: Liam Breck <kernel@networkimprov.net>
    Acked-by: Mark Greer <mgreer@animalcreek.com>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Sebastian Reichel <sre@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit eed4d47efe9508b855b09754cf6de4325d8a2f0d
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Apr 26 23:23:03 2017 +0200

    ACPI / sleep: Ignore spurious SCI wakeups from suspend-to-idle
    
    The ACPI SCI (System Control Interrupt) is set up as a wakeup IRQ
    during suspend-to-idle transitions and, consequently, any events
    signaled through it wake up the system from that state.  However,
    on some systems some of the events signaled via the ACPI SCI while
    suspended to idle should not cause the system to wake up.  In fact,
    quite often they should just be discarded.
    
    Arguably, systems should not resume entirely on such events, but in
    order to decide which events really should cause the system to resume
    and which are spurious, it is necessary to resume up to the point
    when ACPI SCIs are actually handled and processed, which is after
    executing dpm_resume_noirq() in the system resume path.
    
    For this reasons, add a loop around freeze_enter() in which the
    platforms can process events signaled via multiplexed IRQ lines
    like the ACPI SCI and add suspend-to-idle hooks that can be
    used for this purpose to struct platform_freeze_ops.
    
    In the ACPI case, the ->wake hook is used for checking if the SCI
    has triggered while suspended and deferring the interrupt-induced
    system wakeup until the events signaled through it are actually
    processed sufficiently to decide whether or not the system should
    resume.  In turn, the ->sync hook allows all of the relevant event
    queues to be flushed so as to prevent events from being missed due
    to race conditions.
    
    In addition to that, some ACPI code processing wakeup events needs
    to be modified to use the "hard" version of wakeup triggers, so that
    it will cause a system resume to happen on device-induced wakeup
    events even if the "soft" mechanism to prevent the system from
    suspending is not enabled (that also helps to catch device-induced
    wakeup events occurring during suspend transitions in progress).
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 80d136e138f59de35aafb0440e8ab2f51c40ccd5
Author: Michal Hocko <mhocko@suse.com>
Date:   Wed Apr 19 09:52:46 2017 +0200

    mm: make mm_percpu_wq non freezable
    
    Geert has reported a freeze during PM resume and some additional
    debugging has shown that the device_resume worker cannot make a forward
    progress because it waits for an event which is stuck waiting in
    drain_all_pages:
    
      INFO: task kworker/u4:0:5 blocked for more than 120 seconds.
            Not tainted 4.11.0-rc7-koelsch-00029-g005882e53d62f25d-dirty #3476
      "echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
      kworker/u4:0    D    0     5      2 0x00000000
      Workqueue: events_unbound async_run_entry_fn
        __schedule
        schedule
        schedule_timeout
        wait_for_common
        dpm_wait_for_superior
        device_resume
        async_resume
        async_run_entry_fn
        process_one_work
        worker_thread
        kthread
      [...]
      bash            D    0  1703   1694 0x00000000
        __schedule
        schedule
        schedule_timeout
        wait_for_common
        flush_work
        drain_all_pages
        start_isolate_page_range
        alloc_contig_range
        cma_alloc
        __alloc_from_contiguous
        cma_allocator_alloc
        __dma_alloc
        arm_dma_alloc
        sh_eth_ring_init
        sh_eth_open
        sh_eth_resume
        dpm_run_callback
        device_resume
        dpm_resume
        dpm_resume_end
        suspend_devices_and_enter
        pm_suspend
        state_store
        kernfs_fop_write
        __vfs_write
        vfs_write
        SyS_write
      [...]
      Showing busy workqueues and worker pools:
      [...]
      workqueue mm_percpu_wq: flags=0xc
        pwq 2: cpus=1 node=0 flags=0x0 nice=0 active=0/0
          delayed: drain_local_pages_wq, vmstat_update
        pwq 0: cpus=0 node=0 flags=0x0 nice=0 active=0/0
          delayed: drain_local_pages_wq BAR(1703), vmstat_update
    
    Tetsuo has properly noted that mm_percpu_wq is created as WQ_FREEZABLE
    so it is frozen this early during resume so we are effectively
    deadlocked.  Fix this by dropping WQ_FREEZABLE when creating
    mm_percpu_wq.  We really want to have it operational all the time.
    
    Fixes: ce612879ddc7 ("mm: move pcp and lru-pcp draining into single wq")
    Reported-and-tested-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Debugged-by: Tetsuo Handa <penguin-kernel@i-love.sakura.ne.jp>
    Signed-off-by: Michal Hocko <mhocko@suse.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit c793e33749815e1415139b3157e76f3045bfe500
Author: Arend Van Spriel <arend.vanspriel@broadcom.com>
Date:   Tue Mar 28 09:11:31 2017 +0100

    cfg80211: check rdev resume callback only for registered wiphy
    
    commit b3ef5520c1eabb56064474043c7c55a1a65b8708 upstream.
    
    We got the following use-after-free KASAN report:
    
     BUG: KASAN: use-after-free in wiphy_resume+0x591/0x5a0 [cfg80211]
             at addr ffff8803fc244090
     Read of size 8 by task kworker/u16:24/2587
     CPU: 6 PID: 2587 Comm: kworker/u16:24 Tainted: G    B 4.9.13-debug+
     Hardware name: Dell Inc. XPS 15 9550/0N7TVV, BIOS 1.2.19 12/22/2016
     Workqueue: events_unbound async_run_entry_fn
      ffff880425d4f9d8 ffffffffaeedb541 ffff88042b80ef00 ffff8803fc244088
      ffff880425d4fa00 ffffffffae84d7a1 ffff880425d4fa98 ffff8803fc244080
      ffff88042b80ef00 ffff880425d4fa88 ffffffffae84da3a ffffffffc141f7d9
     Call Trace:
      [<ffffffffaeedb541>] dump_stack+0x85/0xc4
      [<ffffffffae84d7a1>] kasan_object_err+0x21/0x70
      [<ffffffffae84da3a>] kasan_report_error+0x1fa/0x500
      [<ffffffffc141f7d9>] ? cfg80211_bss_age+0x39/0xc0 [cfg80211]
      [<ffffffffc141f83a>] ? cfg80211_bss_age+0x9a/0xc0 [cfg80211]
      [<ffffffffae48d46d>] ? trace_hardirqs_on+0xd/0x10
      [<ffffffffc13fb1c0>] ? wiphy_suspend+0xc70/0xc70 [cfg80211]
      [<ffffffffae84def1>] __asan_report_load8_noabort+0x61/0x70
      [<ffffffffc13fb100>] ? wiphy_suspend+0xbb0/0xc70 [cfg80211]
      [<ffffffffc13fb751>] ? wiphy_resume+0x591/0x5a0 [cfg80211]
      [<ffffffffc13fb751>] wiphy_resume+0x591/0x5a0 [cfg80211]
      [<ffffffffc13fb1c0>] ? wiphy_suspend+0xc70/0xc70 [cfg80211]
      [<ffffffffaf3b206e>] dpm_run_callback+0x6e/0x4f0
      [<ffffffffaf3b31b2>] device_resume+0x1c2/0x670
      [<ffffffffaf3b367d>] async_resume+0x1d/0x50
      [<ffffffffae3ee84e>] async_run_entry_fn+0xfe/0x610
      [<ffffffffae3d0666>] process_one_work+0x716/0x1a50
      [<ffffffffae3d05c9>] ? process_one_work+0x679/0x1a50
      [<ffffffffafdd7b6d>] ? _raw_spin_unlock_irq+0x3d/0x60
      [<ffffffffae3cff50>] ? pwq_dec_nr_in_flight+0x2b0/0x2b0
      [<ffffffffae3d1a80>] worker_thread+0xe0/0x1460
      [<ffffffffae3d19a0>] ? process_one_work+0x1a50/0x1a50
      [<ffffffffae3e54c2>] kthread+0x222/0x2e0
      [<ffffffffae3e52a0>] ? kthread_park+0x80/0x80
      [<ffffffffae3e52a0>] ? kthread_park+0x80/0x80
      [<ffffffffae3e52a0>] ? kthread_park+0x80/0x80
      [<ffffffffafdd86aa>] ret_from_fork+0x2a/0x40
     Object at ffff8803fc244088, in cache kmalloc-1024 size: 1024
     Allocated:
     PID = 71
      save_stack_trace+0x1b/0x20
      save_stack+0x46/0xd0
      kasan_kmalloc+0xad/0xe0
      kasan_slab_alloc+0x12/0x20
      __kmalloc_track_caller+0x134/0x360
      kmemdup+0x20/0x50
      brcmf_cfg80211_attach+0x10b/0x3a90 [brcmfmac]
      brcmf_bus_start+0x19a/0x9a0 [brcmfmac]
      brcmf_pcie_setup+0x1f1a/0x3680 [brcmfmac]
      brcmf_fw_request_nvram_done+0x44c/0x11b0 [brcmfmac]
      request_firmware_work_func+0x135/0x280
      process_one_work+0x716/0x1a50
      worker_thread+0xe0/0x1460
      kthread+0x222/0x2e0
      ret_from_fork+0x2a/0x40
     Freed:
     PID = 2568
      save_stack_trace+0x1b/0x20
      save_stack+0x46/0xd0
      kasan_slab_free+0x71/0xb0
      kfree+0xe8/0x2e0
      brcmf_cfg80211_detach+0x62/0xf0 [brcmfmac]
      brcmf_detach+0x14a/0x2b0 [brcmfmac]
      brcmf_pcie_remove+0x140/0x5d0 [brcmfmac]
      brcmf_pcie_pm_leave_D3+0x198/0x2e0 [brcmfmac]
      pci_pm_resume+0x186/0x220
      dpm_run_callback+0x6e/0x4f0
      device_resume+0x1c2/0x670
      async_resume+0x1d/0x50
      async_run_entry_fn+0xfe/0x610
      process_one_work+0x716/0x1a50
      worker_thread+0xe0/0x1460
      kthread+0x222/0x2e0
      ret_from_fork+0x2a/0x40
     Memory state around the buggy address:
      ffff8803fc243f80: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
      ffff8803fc244000: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
     >ffff8803fc244080: fc fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
                              ^
      ffff8803fc244100: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
      ffff8803fc244180: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    
    What is happening is that brcmf_pcie_resume() detects a device that
    is no longer responsive and it decides to unbind resulting in a
    wiphy_unregister() and wiphy_free() call. Now the wiphy instance
    remains allocated, because PM needs to call wiphy_resume() for it.
    However, brcmfmac already does a kfree() for the struct
    cfg80211_registered_device::ops field. Change the checks in
    wiphy_resume() to only access the struct cfg80211_registered_device::ops
    if the wiphy instance is still registered at this time.
    
    Reported-by: Daniel J Blueman <daniel@quora.org>
    Reviewed-by: Hante Meuleman <hante.meuleman@broadcom.com>
    Reviewed-by: Pieter-Paul Giesberts <pieter-paul.giesberts@broadcom.com>
    Reviewed-by: Franky Lin <franky.lin@broadcom.com>
    Signed-off-by: Arend van Spriel <arend.vanspriel@broadcom.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 57e1e90dda74f87bef31bcc5eea89f775b7b3c69
Author: Arend Van Spriel <arend.vanspriel@broadcom.com>
Date:   Tue Mar 28 09:11:31 2017 +0100

    cfg80211: check rdev resume callback only for registered wiphy
    
    commit b3ef5520c1eabb56064474043c7c55a1a65b8708 upstream.
    
    We got the following use-after-free KASAN report:
    
     BUG: KASAN: use-after-free in wiphy_resume+0x591/0x5a0 [cfg80211]
             at addr ffff8803fc244090
     Read of size 8 by task kworker/u16:24/2587
     CPU: 6 PID: 2587 Comm: kworker/u16:24 Tainted: G    B 4.9.13-debug+
     Hardware name: Dell Inc. XPS 15 9550/0N7TVV, BIOS 1.2.19 12/22/2016
     Workqueue: events_unbound async_run_entry_fn
      ffff880425d4f9d8 ffffffffaeedb541 ffff88042b80ef00 ffff8803fc244088
      ffff880425d4fa00 ffffffffae84d7a1 ffff880425d4fa98 ffff8803fc244080
      ffff88042b80ef00 ffff880425d4fa88 ffffffffae84da3a ffffffffc141f7d9
     Call Trace:
      [<ffffffffaeedb541>] dump_stack+0x85/0xc4
      [<ffffffffae84d7a1>] kasan_object_err+0x21/0x70
      [<ffffffffae84da3a>] kasan_report_error+0x1fa/0x500
      [<ffffffffc141f7d9>] ? cfg80211_bss_age+0x39/0xc0 [cfg80211]
      [<ffffffffc141f83a>] ? cfg80211_bss_age+0x9a/0xc0 [cfg80211]
      [<ffffffffae48d46d>] ? trace_hardirqs_on+0xd/0x10
      [<ffffffffc13fb1c0>] ? wiphy_suspend+0xc70/0xc70 [cfg80211]
      [<ffffffffae84def1>] __asan_report_load8_noabort+0x61/0x70
      [<ffffffffc13fb100>] ? wiphy_suspend+0xbb0/0xc70 [cfg80211]
      [<ffffffffc13fb751>] ? wiphy_resume+0x591/0x5a0 [cfg80211]
      [<ffffffffc13fb751>] wiphy_resume+0x591/0x5a0 [cfg80211]
      [<ffffffffc13fb1c0>] ? wiphy_suspend+0xc70/0xc70 [cfg80211]
      [<ffffffffaf3b206e>] dpm_run_callback+0x6e/0x4f0
      [<ffffffffaf3b31b2>] device_resume+0x1c2/0x670
      [<ffffffffaf3b367d>] async_resume+0x1d/0x50
      [<ffffffffae3ee84e>] async_run_entry_fn+0xfe/0x610
      [<ffffffffae3d0666>] process_one_work+0x716/0x1a50
      [<ffffffffae3d05c9>] ? process_one_work+0x679/0x1a50
      [<ffffffffafdd7b6d>] ? _raw_spin_unlock_irq+0x3d/0x60
      [<ffffffffae3cff50>] ? pwq_dec_nr_in_flight+0x2b0/0x2b0
      [<ffffffffae3d1a80>] worker_thread+0xe0/0x1460
      [<ffffffffae3d19a0>] ? process_one_work+0x1a50/0x1a50
      [<ffffffffae3e54c2>] kthread+0x222/0x2e0
      [<ffffffffae3e52a0>] ? kthread_park+0x80/0x80
      [<ffffffffae3e52a0>] ? kthread_park+0x80/0x80
      [<ffffffffae3e52a0>] ? kthread_park+0x80/0x80
      [<ffffffffafdd86aa>] ret_from_fork+0x2a/0x40
     Object at ffff8803fc244088, in cache kmalloc-1024 size: 1024
     Allocated:
     PID = 71
      save_stack_trace+0x1b/0x20
      save_stack+0x46/0xd0
      kasan_kmalloc+0xad/0xe0
      kasan_slab_alloc+0x12/0x20
      __kmalloc_track_caller+0x134/0x360
      kmemdup+0x20/0x50
      brcmf_cfg80211_attach+0x10b/0x3a90 [brcmfmac]
      brcmf_bus_start+0x19a/0x9a0 [brcmfmac]
      brcmf_pcie_setup+0x1f1a/0x3680 [brcmfmac]
      brcmf_fw_request_nvram_done+0x44c/0x11b0 [brcmfmac]
      request_firmware_work_func+0x135/0x280
      process_one_work+0x716/0x1a50
      worker_thread+0xe0/0x1460
      kthread+0x222/0x2e0
      ret_from_fork+0x2a/0x40
     Freed:
     PID = 2568
      save_stack_trace+0x1b/0x20
      save_stack+0x46/0xd0
      kasan_slab_free+0x71/0xb0
      kfree+0xe8/0x2e0
      brcmf_cfg80211_detach+0x62/0xf0 [brcmfmac]
      brcmf_detach+0x14a/0x2b0 [brcmfmac]
      brcmf_pcie_remove+0x140/0x5d0 [brcmfmac]
      brcmf_pcie_pm_leave_D3+0x198/0x2e0 [brcmfmac]
      pci_pm_resume+0x186/0x220
      dpm_run_callback+0x6e/0x4f0
      device_resume+0x1c2/0x670
      async_resume+0x1d/0x50
      async_run_entry_fn+0xfe/0x610
      process_one_work+0x716/0x1a50
      worker_thread+0xe0/0x1460
      kthread+0x222/0x2e0
      ret_from_fork+0x2a/0x40
     Memory state around the buggy address:
      ffff8803fc243f80: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
      ffff8803fc244000: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
     >ffff8803fc244080: fc fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
                              ^
      ffff8803fc244100: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
      ffff8803fc244180: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    
    What is happening is that brcmf_pcie_resume() detects a device that
    is no longer responsive and it decides to unbind resulting in a
    wiphy_unregister() and wiphy_free() call. Now the wiphy instance
    remains allocated, because PM needs to call wiphy_resume() for it.
    However, brcmfmac already does a kfree() for the struct
    cfg80211_registered_device::ops field. Change the checks in
    wiphy_resume() to only access the struct cfg80211_registered_device::ops
    if the wiphy instance is still registered at this time.
    
    Reported-by: Daniel J Blueman <daniel@quora.org>
    Reviewed-by: Hante Meuleman <hante.meuleman@broadcom.com>
    Reviewed-by: Pieter-Paul Giesberts <pieter-paul.giesberts@broadcom.com>
    Reviewed-by: Franky Lin <franky.lin@broadcom.com>
    Signed-off-by: Arend van Spriel <arend.vanspriel@broadcom.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 67c2f3d388efe1a47e201b906d80545eaab7da22
Author: Jrmy Lefaure <jeremy.lefaure@lse.epita.fr>
Date:   Thu Mar 16 21:51:33 2017 -0400

    tpm/tpm_crb: fix unused warnings on suspend/resume functions
    
    When PM_SLEEP is disabled crb_pm_suspend and crb_pm_resume are not used by
    SET_SYSTEM_SLEEP_PM_OPS even if PM is enabled:
    
    drvers/char/tpm/tpm_crb.c:540:12: warning: crb_pm_suspend defined but not
    used [-Wunused-function]
     static int crb_pm_suspend(struct device *dev)
                ^
    drivers/char/tpm/tpm_crb.c:551:12: warning: crb_pm_resume defined but not
    used [-Wunused-function]
     static int crb_pm_resume(struct device *dev)
                ^
    
    The preprocessor condition should be on CONFIG_PM_SLEEP, not on CONFIG_PM.
    However, this patch fixes this warning by using __maybe_unused on function
    that are in the preprocessor condition.
    
    Fixes: 848efcfb560c ("tpm/tpm_crb: enter the low power state upon device suspend")
    Signed-off-by: Jrmy Lefaure <jeremy.lefaure@lse.epita.fr>
    Reviewed-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
    Tested-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
    Signed-off-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>

commit b3ef5520c1eabb56064474043c7c55a1a65b8708
Author: Arend Van Spriel <arend.vanspriel@broadcom.com>
Date:   Tue Mar 28 09:11:31 2017 +0100

    cfg80211: check rdev resume callback only for registered wiphy
    
    We got the following use-after-free KASAN report:
    
     BUG: KASAN: use-after-free in wiphy_resume+0x591/0x5a0 [cfg80211]
             at addr ffff8803fc244090
     Read of size 8 by task kworker/u16:24/2587
     CPU: 6 PID: 2587 Comm: kworker/u16:24 Tainted: G    B 4.9.13-debug+
     Hardware name: Dell Inc. XPS 15 9550/0N7TVV, BIOS 1.2.19 12/22/2016
     Workqueue: events_unbound async_run_entry_fn
      ffff880425d4f9d8 ffffffffaeedb541 ffff88042b80ef00 ffff8803fc244088
      ffff880425d4fa00 ffffffffae84d7a1 ffff880425d4fa98 ffff8803fc244080
      ffff88042b80ef00 ffff880425d4fa88 ffffffffae84da3a ffffffffc141f7d9
     Call Trace:
      [<ffffffffaeedb541>] dump_stack+0x85/0xc4
      [<ffffffffae84d7a1>] kasan_object_err+0x21/0x70
      [<ffffffffae84da3a>] kasan_report_error+0x1fa/0x500
      [<ffffffffc141f7d9>] ? cfg80211_bss_age+0x39/0xc0 [cfg80211]
      [<ffffffffc141f83a>] ? cfg80211_bss_age+0x9a/0xc0 [cfg80211]
      [<ffffffffae48d46d>] ? trace_hardirqs_on+0xd/0x10
      [<ffffffffc13fb1c0>] ? wiphy_suspend+0xc70/0xc70 [cfg80211]
      [<ffffffffae84def1>] __asan_report_load8_noabort+0x61/0x70
      [<ffffffffc13fb100>] ? wiphy_suspend+0xbb0/0xc70 [cfg80211]
      [<ffffffffc13fb751>] ? wiphy_resume+0x591/0x5a0 [cfg80211]
      [<ffffffffc13fb751>] wiphy_resume+0x591/0x5a0 [cfg80211]
      [<ffffffffc13fb1c0>] ? wiphy_suspend+0xc70/0xc70 [cfg80211]
      [<ffffffffaf3b206e>] dpm_run_callback+0x6e/0x4f0
      [<ffffffffaf3b31b2>] device_resume+0x1c2/0x670
      [<ffffffffaf3b367d>] async_resume+0x1d/0x50
      [<ffffffffae3ee84e>] async_run_entry_fn+0xfe/0x610
      [<ffffffffae3d0666>] process_one_work+0x716/0x1a50
      [<ffffffffae3d05c9>] ? process_one_work+0x679/0x1a50
      [<ffffffffafdd7b6d>] ? _raw_spin_unlock_irq+0x3d/0x60
      [<ffffffffae3cff50>] ? pwq_dec_nr_in_flight+0x2b0/0x2b0
      [<ffffffffae3d1a80>] worker_thread+0xe0/0x1460
      [<ffffffffae3d19a0>] ? process_one_work+0x1a50/0x1a50
      [<ffffffffae3e54c2>] kthread+0x222/0x2e0
      [<ffffffffae3e52a0>] ? kthread_park+0x80/0x80
      [<ffffffffae3e52a0>] ? kthread_park+0x80/0x80
      [<ffffffffae3e52a0>] ? kthread_park+0x80/0x80
      [<ffffffffafdd86aa>] ret_from_fork+0x2a/0x40
     Object at ffff8803fc244088, in cache kmalloc-1024 size: 1024
     Allocated:
     PID = 71
      save_stack_trace+0x1b/0x20
      save_stack+0x46/0xd0
      kasan_kmalloc+0xad/0xe0
      kasan_slab_alloc+0x12/0x20
      __kmalloc_track_caller+0x134/0x360
      kmemdup+0x20/0x50
      brcmf_cfg80211_attach+0x10b/0x3a90 [brcmfmac]
      brcmf_bus_start+0x19a/0x9a0 [brcmfmac]
      brcmf_pcie_setup+0x1f1a/0x3680 [brcmfmac]
      brcmf_fw_request_nvram_done+0x44c/0x11b0 [brcmfmac]
      request_firmware_work_func+0x135/0x280
      process_one_work+0x716/0x1a50
      worker_thread+0xe0/0x1460
      kthread+0x222/0x2e0
      ret_from_fork+0x2a/0x40
     Freed:
     PID = 2568
      save_stack_trace+0x1b/0x20
      save_stack+0x46/0xd0
      kasan_slab_free+0x71/0xb0
      kfree+0xe8/0x2e0
      brcmf_cfg80211_detach+0x62/0xf0 [brcmfmac]
      brcmf_detach+0x14a/0x2b0 [brcmfmac]
      brcmf_pcie_remove+0x140/0x5d0 [brcmfmac]
      brcmf_pcie_pm_leave_D3+0x198/0x2e0 [brcmfmac]
      pci_pm_resume+0x186/0x220
      dpm_run_callback+0x6e/0x4f0
      device_resume+0x1c2/0x670
      async_resume+0x1d/0x50
      async_run_entry_fn+0xfe/0x610
      process_one_work+0x716/0x1a50
      worker_thread+0xe0/0x1460
      kthread+0x222/0x2e0
      ret_from_fork+0x2a/0x40
     Memory state around the buggy address:
      ffff8803fc243f80: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
      ffff8803fc244000: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
     >ffff8803fc244080: fc fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
                              ^
      ffff8803fc244100: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
      ffff8803fc244180: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    
    What is happening is that brcmf_pcie_resume() detects a device that
    is no longer responsive and it decides to unbind resulting in a
    wiphy_unregister() and wiphy_free() call. Now the wiphy instance
    remains allocated, because PM needs to call wiphy_resume() for it.
    However, brcmfmac already does a kfree() for the struct
    cfg80211_registered_device::ops field. Change the checks in
    wiphy_resume() to only access the struct cfg80211_registered_device::ops
    if the wiphy instance is still registered at this time.
    
    Cc: stable@vger.kernel.org # 4.10.x, 4.9.x
    Reported-by: Daniel J Blueman <daniel@quora.org>
    Reviewed-by: Hante Meuleman <hante.meuleman@broadcom.com>
    Reviewed-by: Pieter-Paul Giesberts <pieter-paul.giesberts@broadcom.com>
    Reviewed-by: Franky Lin <franky.lin@broadcom.com>
    Signed-off-by: Arend van Spriel <arend.vanspriel@broadcom.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

commit 71cc22e5db8994ff69c947a296235e8547039188
Author: Ander Conselvan de Oliveira <ander.conselvan.de.oliveira@intel.com>
Date:   Wed Feb 22 08:34:30 2017 +0200

    drm/i915/glk: Don't enable DDI IO power domains during init
    
    In Geminilake, the DDI IO power domains can't be enabled before a DPLL
    is running and mapped to the appropriate DDI. At least on Geminilake,
    attempting to enable those during init will lead to a timeout.
    
    The failure to enable the power domain also causes issues with the state
    verifier during resume from suspend. After all the init power domains
    are enabled, the call to intel_power_domains_sync_hw() from the resume
    path will cause the hw_enabled field on the respective power wells to be
    false while the usage count remains above zero. Further attempts to
    enable the power domain caused by a modeset will simply update the usage
    count without doing anything else. When the state verifier attempts to
    read the state of a DDI encoder, intel_display_power_get_if_enabled()
    returns false, leading to the following WARN:
    
    WARNING: CPU: 3 PID: 1743 at drivers/gpu/drm/i915/intel_display.c:7001 verify_connector_state.isra.80+0x26c/0x2b0 [i915]
    attached crtc is active, but connector isn't
    Modules linked in: i915(E) tun ip6t_rpfilter ip6t_REJECT nf_reject_ipv6 xt_conntrack ebtable_broute bridge stp llc ebtable_nat ip6table_mangle ip6table_security ip6table_nat nf_conntrack_ipv6 nf_defrag_ipv6 nf_nat_ipv6 ip6table_raw iptable_mangle iptable_security iptable_nat nf_conntrack_ipv4 nf_defrag_ipv4 nf_nat_ipv4 nf_nat nf_conntrack iptable_raw ebtable_filter ebtables ip6table_filter ip6_tables x86_pkg_temp_thermal coretemp kvm_intel kvm i2c_algo_bit drm_kms_helper irqbypass crct10dif_pclmul crc32_pclmul ghash_clmulni_intel drm shpchp tpm_tis tpm_tis_core tpm nfsd auth_rpcgss nfs_acl lockd grace sunrpc crc32c_intel serio_raw [last unloaded: i915]
    CPU: 3 PID: 1743 Comm: kworker/u8:22 Tainted: G        W   E   4.10.0-rc3ander+ #300
    Hardware name: Intel Corp. Geminilake/GLK RVP1 DDR4 (05), BIOS GELKRVPA.X64.0023.B40.1611302145 11/30/2016
    Workqueue: events_unbound async_run_entry_fn
    Call Trace:
     dump_stack+0x86/0xc3
     __warn+0xcb/0xf0
     warn_slowpath_fmt+0x5f/0x80
     verify_connector_state.isra.80+0x26c/0x2b0 [i915]
     intel_atomic_commit_tail+0x520/0x1000 [i915]
     ? remove_wait_queue+0x70/0x70
     intel_atomic_commit+0x3f8/0x520 [i915]
     ? intel_runtime_pm_put+0x6e/0xa0 [i915]
     drm_atomic_commit+0x4b/0x50 [drm]
     __intel_display_resume+0x72/0xc0 [i915]
     intel_display_resume+0x107/0x150 [i915]
     i915_drm_resume+0xe0/0x180 [i915]
     i915_pm_restore+0x1e/0x30 [i915]
     i915_pm_resume+0xe/0x10 [i915]
     pci_pm_resume+0x64/0xa0
     dpm_run_callback+0xa1/0x2a0
     ? pci_pm_thaw+0x90/0x90
     device_resume+0xe3/0x200
     async_resume+0x1d/0x50
     async_run_entry_fn+0x39/0x170
     process_one_work+0x212/0x670
     ? process_one_work+0x197/0x670
     worker_thread+0x4e/0x490
     kthread+0x101/0x140
     ? process_one_work+0x670/0x670
     ? kthread_create_on_node+0x60/0x60
     ret_from_fork+0x2a/0x40
    
    Cc: David Weinehall <david.weinehall@linux.intel.com>
    Signed-off-by: Ander Conselvan de Oliveira <ander.conselvan.de.oliveira@intel.com>
    Reviewed-by: David Weinehall <david.weinehall@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170222063431.10060-6-ander.conselvan.de.oliveira@intel.com

commit c9b9f207b90468bf9583f7ed71c15d0142bbf9b1
Merge: 345fb0a9a634 744cc304a18f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Feb 20 10:00:10 2017 -0800

    Merge tag 'for-v4.11' of git://git.kernel.org/pub/scm/linux/kernel/git/sre/linux-power-supply
    
    Pull power supply and reset updates from Sebastian Reichel:
     "New drivers:
       - sbs-charger driver
       - max14656_charger_detector
       - axp20x_ac_power
    
      New chip/feature support"
       - axp20x_usb_power: add AXP223 support
       - tps65217: add usb charger support
       - qcom_smbb: support otg regulator
       - at91-reset: add samx7 support
    
      Dropped drivers:
       - intel_mid_battery (platform was dropped)
    
      Fixes:
       - at91-poweroff: avoid wearing off LPDDR memory
       - replace deprecated extcon API
       - lots of cleanup and style fixes
       - misc minor functionality fixes"
    
    * tag 'for-v4.11' of git://git.kernel.org/pub/scm/linux/kernel/git/sre/linux-power-supply: (84 commits)
      power: supply: add AC power supply driver for AXP20X and AXP22X PMICs
      dt-bindings: power: supply: add AXP20X/AXP22X AC power supply
      power: supply: axp20x_usb_power: use IIO channels when available
      power: supply: max14656: Export I2C and OF device ID as module aliases
      power: supply: bq2415x: check for NULL acpi_id to avoid null pointer dereference
      power: supply: bq24190_charger: Adjust formatting
      power: supply: bq24190_charger: Handle fault before status on interrupt
      power: supply: bq24190_charger: Don't read fault register outside irq_handle_thread()
      power: supply: bq24190_charger: Call power_supply_changed() for relevant component
      power: supply: bq24190_charger: Install irq_handler_thread() at end of probe()
      power: supply: bq24190_charger: Call set_mode_host() on pm_resume()
      power: supply: bq24190_charger: Fix irq trigger to IRQF_TRIGGER_FALLING
      power: supply: qcom_smbb: add regulator dependency
      power: reset: at91-reset: remove leftover platform_device_id
      power: reset: at91-reset: add samx7 support
      power: supply: max14656: fix platform_no_drv_owner.cocci warnings
      power: supply: pcf50633-charger: Compress return logic into one line.
      power: supply: ab8500_btemp: Compress return logic into one line.
      power: reset: at91-poweroff: timely shutdown LPDDR memories
      ARM: at91: define LPDDR types
      ...

commit 0bf0ee8ef9a6c120f7f320b9fb5fe1270965d828
Author: Grygorii Strashko <grygorii.strashko@ti.com>
Date:   Fri Feb 10 14:25:01 2017 -0800

    PM / wakeirq: Fix spurious wake-up events for dedicated wakeirqs
    
    Dedicated wakeirq is a one time event to wake-up the system from
    low-power state and then call pm_runtime_resume() on the device wired
    with the dedicated wakeirq.
    
    Sometimes dedicated wakeirqs can get deferred if they trigger after we
    call disable_irq_nosync() in dev_pm_disable_wake_irq(). This can happen
    if pm_runtime_get() is called around the same time a wakeirq fires.
    
    If an interrupt fires after disable_irq_nosync(), by default it will get
    tagged with IRQS_PENDING and will run later on when the interrupt is
    enabled again.
    
    Deferred wakeirqs usually just produce pointless wake-up events. But they
    can also cause suspend to fail if the deferred wakeirq fires during
    dpm_suspend_noirq() for example. So we really don't want to see the
    deferred wakeirqs triggering after the device has resumed.
    
    Let's fix the issue by setting IRQ_DISABLE_UNLAZY flag for the dedicated
    wakeirqs. The other option would be to implement irq_disable() in the
    dedicated wakeirq controller, but that's not a generic solution.
    
    For reference below is what happens with a IRQ_TYPE_EDGE_BOTH IRQ
    type wakeirq:
    
    - resume by dedicated IRQ (EDGE_FALLING)
     - suspend_enter()
      ....
     - arch_suspend_enable_irqs()
       |- dedicated IRQ armed and fired
       |- irq_pm_check_wakeup()
          |- disarm, disable IRQ and mark as IRQS_PENDING
      ....
     - dpm_resume_noirq()
       |- resume_device_irqs()
          |- __enable_irq()
             |- check_irq_resend()
                |- handle_threaded_wake_irq()
                   |- dedicated IRQ processed
       |- device_wakeup_disarm_wake_irqs()
          |- disable_irq_wake()
      ....
     !-> dedicated IRQ (EDGE_RISING)
         -| handle_edge_irq()
            |- IRQ disabled: mask_ack_irq and mark as IRQS_PENDING
      ....
    - subsequent suspend
      ....
      |- dpm_suspend_noirq()
         |- device_wakeup_arm_wake_irqs()
            |- __enable_irq()
               |- check_irq_resend()
    (a)           |- handle_threaded_wake_irq()
                     |- pm_wakeup_event() --> abort suspend
      ....
         |- suspend_device_irqs()
            |- suspend_device_irq()
               |-  dedicated IRQ armed
      ....
    (b)  |- resend_irqs
            |- irq_pm_check_wakeup()
               |- IRQ armed -> abort suspend
    
    because of pending IRQ System suspend can be aborted at points
    (a)-not armed or (b)-armed.
    
    Fixes: 4990d4fe327b (PM / Wakeirq: Add automated device wake IRQ handling)
    Signed-off-by: Grygorii Strashko <grygorii.strashko@ti.com>
    [ tony@atomide.com: added a comment, updated the description ]
    Tested-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit bc05a2e940fe96fbacf879e73139d8a66c39ab8e
Author: Tony Lindgren <tony@atomide.com>
Date:   Thu Jan 19 08:49:08 2017 -0800

    dmaengine: cppi41: Fix oops in cppi41_runtime_resume
    
    commit 362f4562466c3b9490e733e06999025638310d4a upstream.
    
    Commit fdea2d09b997 ("dmaengine: cppi41: Add basic PM runtime support")
    together with recent MUSB changes allowed USB and DMA on BeagleBone to idle
    when no cable is connected. But looks like few corner case issues still
    remain.
    
    Looks like just by re-plugging USB cable about ten or so times on BeagleBone
    when configured in USB peripheral mode we can get warnings and eventually
    trigger an oops in cppi41 DMA:
    
    WARNING: CPU: 0 PID: 14 at drivers/dma/cppi41.c:1154 cppi41_runtime_suspend+
    x28/0x38 [cppi41]
    ...
    
    WARNING: CPU: 0 PID: 14 at drivers/dma/cppi41.c:452
    push_desc_queue+0x94/0x9c [cppi41]
    ...
    
    Unable to handle kernel NULL pointer dereference at virtual
    address 00000104
    pgd = c0004000
    [00000104] *pgd=00000000
    Internal error: Oops: 805 [#1] SMP ARM
    ...
    [<bf0d92cc>] (cppi41_runtime_resume [cppi41]) from [<c0589838>]
    (__rpm_callback+0xc0/0x214)
    [<c0589838>] (__rpm_callback) from [<c05899ac>] (rpm_callback+0x20/0x80)
    [<c05899ac>] (rpm_callback) from [<c0589460>] (rpm_resume+0x504/0x78c)
    [<c0589460>] (rpm_resume) from [<c058a1a0>] (pm_runtime_work+0x60/0xa8)
    [<c058a1a0>] (pm_runtime_work) from [<c0156120>] (process_one_work+0x2b4/0x808)
    
    This is because of a race with runtime PM and cppi41_dma_issue_pending()
    as reported by Alexandre Bailon <abailon@baylibre.com> in earlier
    set of patches. Based on mailing list discussions we however came to the
    conclusion that a different fix from Alexandre's fix is needed in order
    to guarantee that DMA is really active when we try to use it.
    
    To fix the issue, we need to add a driver specific flag as we otherwise
    can have -EINPROGRESS state set by runtime PM and can't rely on
    pm_runtime_active() to tell us when we can use the DMA.
    
    And we need to make sure the DMA transfers get triggered in the queued
    order. So let's always queue the transfers, then flush the queue
    from both cppi41_dma_issue_pending() and cppi41_runtime_resume()
    as suggested by Grygorii Strashko <grygorii.strashko@ti.com> in an
    earlier example patch.
    
    For reference, this is also documented in Documentation/power/runtime_pm.txt
    in the example at the end of the file as pointed out by Grygorii Strashko
    <grygorii.strashko@ti.com>.
    
    Based on earlier patches from Alexandre Bailon <abailon@baylibre.com>
    and Grygorii Strashko <grygorii.strashko@ti.com> modified based on
    testing and what was discussed on the mailing lists.
    
    Fixes: fdea2d09b997 ("dmaengine: cppi41: Add basic PM runtime support")
    Cc: Andy Shevchenko <andy.shevchenko@gmail.com>
    Cc: Bin Liu <b-liu@ti.com>
    Cc: Grygorii Strashko <grygorii.strashko@ti.com>
    Cc: Kevin Hilman <khilman@baylibre.com>
    Cc: Patrick Titiano <ptitiano@baylibre.com>
    Cc: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
    Reported-by: Alexandre Bailon <abailon@baylibre.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Tested-by: Bin Liu <b-liu@ti.com>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 362f4562466c3b9490e733e06999025638310d4a
Author: Tony Lindgren <tony@atomide.com>
Date:   Thu Jan 19 08:49:08 2017 -0800

    dmaengine: cppi41: Fix oops in cppi41_runtime_resume
    
    Commit fdea2d09b997 ("dmaengine: cppi41: Add basic PM runtime support")
    together with recent MUSB changes allowed USB and DMA on BeagleBone to idle
    when no cable is connected. But looks like few corner case issues still
    remain.
    
    Looks like just by re-plugging USB cable about ten or so times on BeagleBone
    when configured in USB peripheral mode we can get warnings and eventually
    trigger an oops in cppi41 DMA:
    
    WARNING: CPU: 0 PID: 14 at drivers/dma/cppi41.c:1154 cppi41_runtime_suspend+
    x28/0x38 [cppi41]
    ...
    
    WARNING: CPU: 0 PID: 14 at drivers/dma/cppi41.c:452
    push_desc_queue+0x94/0x9c [cppi41]
    ...
    
    Unable to handle kernel NULL pointer dereference at virtual
    address 00000104
    pgd = c0004000
    [00000104] *pgd=00000000
    Internal error: Oops: 805 [#1] SMP ARM
    ...
    [<bf0d92cc>] (cppi41_runtime_resume [cppi41]) from [<c0589838>]
    (__rpm_callback+0xc0/0x214)
    [<c0589838>] (__rpm_callback) from [<c05899ac>] (rpm_callback+0x20/0x80)
    [<c05899ac>] (rpm_callback) from [<c0589460>] (rpm_resume+0x504/0x78c)
    [<c0589460>] (rpm_resume) from [<c058a1a0>] (pm_runtime_work+0x60/0xa8)
    [<c058a1a0>] (pm_runtime_work) from [<c0156120>] (process_one_work+0x2b4/0x808)
    
    This is because of a race with runtime PM and cppi41_dma_issue_pending()
    as reported by Alexandre Bailon <abailon@baylibre.com> in earlier
    set of patches. Based on mailing list discussions we however came to the
    conclusion that a different fix from Alexandre's fix is needed in order
    to guarantee that DMA is really active when we try to use it.
    
    To fix the issue, we need to add a driver specific flag as we otherwise
    can have -EINPROGRESS state set by runtime PM and can't rely on
    pm_runtime_active() to tell us when we can use the DMA.
    
    And we need to make sure the DMA transfers get triggered in the queued
    order. So let's always queue the transfers, then flush the queue
    from both cppi41_dma_issue_pending() and cppi41_runtime_resume()
    as suggested by Grygorii Strashko <grygorii.strashko@ti.com> in an
    earlier example patch.
    
    For reference, this is also documented in Documentation/power/runtime_pm.txt
    in the example at the end of the file as pointed out by Grygorii Strashko
    <grygorii.strashko@ti.com>.
    
    Based on earlier patches from Alexandre Bailon <abailon@baylibre.com>
    and Grygorii Strashko <grygorii.strashko@ti.com> modified based on
    testing and what was discussed on the mailing lists.
    
    Fixes: fdea2d09b997 ("dmaengine: cppi41: Add basic PM runtime support")
    Cc: Andy Shevchenko <andy.shevchenko@gmail.com>
    Cc: Bin Liu <b-liu@ti.com>
    Cc: Grygorii Strashko <grygorii.strashko@ti.com>
    Cc: Kevin Hilman <khilman@baylibre.com>
    Cc: Patrick Titiano <ptitiano@baylibre.com>
    Cc: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
    Reported-by: Alexandre Bailon <abailon@baylibre.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Tested-by: Bin Liu <b-liu@ti.com>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

commit d1242acc566a9288cbca441be1a7358c0316197e
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Jan 20 17:25:15 2017 +0100

    iio: light: cm3605: mark PM functions as __maybe_unused
    
    When CONFIG_PM_SLEEP is disabled, we get a harmless warning
    
    drivers/iio/light/cm3605.c:292:12: error: 'cm3605_pm_resume' defined but not used [-Werror=unused-function]
    drivers/iio/light/cm3605.c:281:12: error: 'cm3605_pm_suspend' defined but not used [-Werror=unused-function]
    
    Marking the functions as possibly unused avoids the warning without
    needing to add an #ifdef.
    
    Fixes: 8afa505c1230 ("iio: light: add driver for Capella CM3605")
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

commit e05ad7e0741ce0505e1df157c62b22b95172bb97
Author: Liam Breck <liam@networkimprov.net>
Date:   Wed Jan 18 09:26:49 2017 -0800

    power: supply: bq24190_charger: Call set_mode_host() on pm_resume()
    
    pm_resume() does a register_reset() which clears charger host mode.
    
    Fix by calling set_mode_host() after the reset.
    
    Fixes: d7bf353fd0aa3 ("bq24190_charger: Add support for TI BQ24190 Battery Charger")
    Signed-off-by: Liam Breck <kernel@networkimprov.net>
    Acked-by: Mark Greer <mgreer@animalcreek.com>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Sebastian Reichel <sre@kernel.org>

commit 852b7fa228567f397fe5e5a1e060794e0f0125fe
Merge: cc773e75a0e2 05a926227742 034e7906211c f5261402494a
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Dec 12 20:43:44 2016 +0100

    Merge branches 'pm-core', 'pm-qos' and 'pm-avs'
    
    * pm-core:
      PM / core: Fix bug in the error handling of async suspend
      PM / wakeirq: Fix dedicated wakeirq for drivers not using autosuspend
      PM / Runtime: Defer resuming of the device in pm_runtime_force_resume()
      PM / Runtime: Don't allow to suspend a device with an active child
      net: smsc911x: Synchronize the runtime PM status during system suspend
      PM / Runtime: Convert pm_runtime_set_suspended() to return an int
      PM / Runtime: Clarify comment in rpm_resume() when resuming the parent
      PM / Runtime: Remove the exported function pm_children_suspended()
    
    * pm-qos:
      PM / QoS: Export dev_pm_qos_update_user_latency_tolerance
      PM / QoS: Fix writing 'auto' to pm_qos_latency_tolerance_us
      PM / QoS: Improve sysfs pm_qos_latency_tolerance validation
    
    * pm-avs:
      PM / AVS: rockchip-io: make the log more consistent

commit b61abd49c5dd07d3b97b638128982c3feef99a93
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Thu Nov 24 17:30:26 2016 +0100

    drm/hisilicon/hibmc: mark PM functions __maybe_unused
    
    When CONFIG_PM_SLEEP is disabled, we get a harmless warning
    
    drm/hisilicon/hibmc/hibmc_drm_drv.c:115:12: error: hibmc_pm_resume defined but not used [-Werror=unused-function]
    drm/hisilicon/hibmc/hibmc_drm_drv.c:97:12: error: hibmc_pm_suspend defined but not used [-Werror=unused-function]
    
    Marking the functions as __maybe_unused avoids the warning without
    having to add an #ifdef.
    
    Fixes: 5e0df3a08f3d ("drm/hisilicon/hibmc: Add hisilicon hibmc drm master driver")
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/20161124163107.3914495-1-arnd@arndb.de

commit 8da5e825300bdd957767d2c99d1a6fbb96c26ccc
Author: Fabio Estevam <fabio.estevam@nxp.com>
Date:   Wed Aug 17 12:41:08 2016 -0300

    can: flexcan: fix resume function
    
    commit 4de349e786a3a2d51bd02d56f3de151bbc3c3df9 upstream.
    
    On a imx6ul-pico board the following error is seen during system suspend:
    
    dpm_run_callback(): platform_pm_resume+0x0/0x54 returns -110
    PM: Device 2090000.flexcan failed to resume: error -110
    
    The reason for this suspend error is because when the CAN interface is not
    active the clocks are disabled and then flexcan_chip_enable() will
    always fail due to a timeout error.
    
    In order to fix this issue, only call flexcan_chip_enable/disable()
    when the CAN interface is active.
    
    Based on a patch from Dong Aisheng in the NXP kernel.
    
    Signed-off-by: Fabio Estevam <fabio.estevam@nxp.com>
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit 47ed32483e1f1fc391c78466f5fd66f03078e9e4
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Wed Oct 12 12:48:26 2016 +0100

    drm/i915: Use fence_write() from rpm resume
    
    During rpm resume we restore the fences, but we do not have the
    protection of struct_mutex. This rules out updating the activity
    tracking on the fences, and requires us to rely on the rpm as the
    serialisation barrier instead.
    
    [  350.298052] [drm:intel_runtime_resume [i915]] Resuming device
    [  350.308606]
    [  350.310520] ===============================
    [  350.315560] [ INFO: suspicious RCU usage. ]
    [  350.320554] 4.8.0-rc8-bsw-rapl+ #3133 Tainted: G     U  W
    [  350.327208] -------------------------------
    [  350.331977] ../drivers/gpu/drm/i915/i915_gem_request.h:371 suspicious rcu_dereference_protected() usage!
    [  350.342619]
    [  350.342619] other info that might help us debug this:
    [  350.342619]
    [  350.351593]
    [  350.351593] rcu_scheduler_active = 1, debug_locks = 0
    [  350.358952] 3 locks held by Xorg/320:
    [  350.363077]  #0:  (&dev->mode_config.mutex){+.+.+.}, at: [<ffffffffa030589c>] drm_modeset_lock_all+0x3c/0xd0 [drm]
    [  350.375162]  #1:  (crtc_ww_class_acquire){+.+.+.}, at: [<ffffffffa03058a6>] drm_modeset_lock_all+0x46/0xd0 [drm]
    [  350.387022]  #2:  (crtc_ww_class_mutex){+.+.+.}, at: [<ffffffffa0305056>] drm_modeset_lock+0x36/0x110 [drm]
    [  350.398236]
    [  350.398236] stack backtrace:
    [  350.403196] CPU: 1 PID: 320 Comm: Xorg Tainted: G     U  W       4.8.0-rc8-bsw-rapl+ #3133
    [  350.412457] Hardware name: Intel Corporation CHERRYVIEW C0 PLATFORM/Braswell CRB, BIOS BRAS.X64.X088.R00.1510270350 10/27/2015
    [  350.425212]  0000000000000000 ffff8801680a78c8 ffffffff81332187 ffff88016c5c5000
    [  350.433611]  0000000000000001 ffff8801680a78f8 ffffffff810ca6da ffff88016cc8b0f0
    [  350.442012]  ffff88016cc80000 ffff88016cc80000 ffff880177ad0000 ffff8801680a7948
    [  350.450409] Call Trace:
    [  350.453165]  [<ffffffff81332187>] dump_stack+0x67/0x90
    [  350.458931]  [<ffffffff810ca6da>] lockdep_rcu_suspicious+0xea/0x120
    [  350.466002]  [<ffffffffa039e8dd>] fence_update+0xbd/0x670 [i915]
    [  350.472766]  [<ffffffffa039efe2>] i915_gem_restore_fences+0x52/0x70 [i915]
    [  350.480496]  [<ffffffffa0368f42>] vlv_resume_prepare+0x72/0x570 [i915]
    [  350.487839]  [<ffffffffa0369802>] intel_runtime_resume+0x102/0x210 [i915]
    [  350.495442]  [<ffffffff8137f26f>] pci_pm_runtime_resume+0x7f/0xb0
    [  350.502274]  [<ffffffff8137f1f0>] ? pci_restore_standard_config+0x40/0x40
    [  350.509883]  [<ffffffff814401c5>] __rpm_callback+0x35/0x70
    [  350.516037]  [<ffffffff8137f1f0>] ? pci_restore_standard_config+0x40/0x40
    [  350.523646]  [<ffffffff81440224>] rpm_callback+0x24/0x80
    [  350.529604]  [<ffffffff8137f1f0>] ? pci_restore_standard_config+0x40/0x40
    [  350.537212]  [<ffffffff814417bd>] rpm_resume+0x4ad/0x740
    [  350.543161]  [<ffffffff81441aa1>] __pm_runtime_resume+0x51/0x80
    [  350.549824]  [<ffffffffa03889c8>] intel_runtime_pm_get+0x28/0x90 [i915]
    [  350.557265]  [<ffffffffa0388a53>] intel_display_power_get+0x23/0x50 [i915]
    [  350.565001]  [<ffffffffa03ef23d>] intel_atomic_commit_tail+0xdfd/0x10b0 [i915]
    [  350.573106]  [<ffffffffa034b2e9>] ? drm_atomic_helper_swap_state+0x159/0x300 [drm_kms_helper]
    [  350.582659]  [<ffffffff81615091>] ? _raw_spin_unlock+0x31/0x50
    [  350.589205]  [<ffffffffa034b2e9>] ? drm_atomic_helper_swap_state+0x159/0x300 [drm_kms_helper]
    [  350.598787]  [<ffffffffa03ef8a5>] intel_atomic_commit+0x3b5/0x500 [i915]
    [  350.606319]  [<ffffffffa03061dc>] ? drm_atomic_set_crtc_for_connector+0xcc/0x100 [drm]
    [  350.615209]  [<ffffffffa0306b49>] drm_atomic_commit+0x49/0x50 [drm]
    [  350.622242]  [<ffffffffa034dee8>] drm_atomic_helper_set_config+0x88/0xc0 [drm_kms_helper]
    [  350.631419]  [<ffffffffa02f94ac>] drm_mode_set_config_internal+0x6c/0x120 [drm]
    [  350.639623]  [<ffffffffa02fa94c>] drm_mode_setcrtc+0x22c/0x4d0 [drm]
    [  350.646760]  [<ffffffffa02f0f19>] drm_ioctl+0x209/0x460 [drm]
    [  350.653217]  [<ffffffffa02fa720>] ? drm_mode_getcrtc+0x150/0x150 [drm]
    [  350.660536]  [<ffffffff810c984a>] ? __lock_is_held+0x4a/0x70
    [  350.666885]  [<ffffffff81202303>] do_vfs_ioctl+0x93/0x6b0
    [  350.672939]  [<ffffffff8120f843>] ? __fget+0x113/0x200
    [  350.678797]  [<ffffffff8120f735>] ? __fget+0x5/0x200
    [  350.684361]  [<ffffffff81202964>] SyS_ioctl+0x44/0x80
    [  350.690030]  [<ffffffff81001deb>] do_syscall_64+0x5b/0x120
    [  350.696184]  [<ffffffff81615ada>] entry_SYSCALL64_slow_path+0x25/0x25
    
    Note we also have to remember the lesson from commit 4fc788f5ee3d
    ("drm/i915: Flush delayed fence releases after reset") where we have to
    flush any changes to the fence on restore.
    
    v2: Replace call to release user mmaps with an assertion that they have
    already been zapped.
    
    Fixes: 49ef5294cda2 ("drm/i915: Move fence tracking from object to vma")
    Reported-by: Ville Syrjl <ville.syrjala@linux.intel.com>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Ville Syrjl <ville.syrjala@linux.intel.com>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: Mika Kuoppala <mika.kuoppala@intel.com>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20161012114827.17031-1-chris@chris-wilson.co.uk
    (cherry picked from commit 4676dc838b37ed8c6f3da4571cb4a04cbd604801)
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>

commit 216ef0b6b8c7f041a618913e94da52c3fdf82a99
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Mon Oct 17 20:16:59 2016 +0200

    PM / Runtime: Clarify comment in rpm_resume() when resuming the parent
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 4676dc838b37ed8c6f3da4571cb4a04cbd604801
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Wed Oct 12 12:48:26 2016 +0100

    drm/i915: Use fence_write() from rpm resume
    
    During rpm resume we restore the fences, but we do not have the
    protection of struct_mutex. This rules out updating the activity
    tracking on the fences, and requires us to rely on the rpm as the
    serialisation barrier instead.
    
    [  350.298052] [drm:intel_runtime_resume [i915]] Resuming device
    [  350.308606]
    [  350.310520] ===============================
    [  350.315560] [ INFO: suspicious RCU usage. ]
    [  350.320554] 4.8.0-rc8-bsw-rapl+ #3133 Tainted: G     U  W
    [  350.327208] -------------------------------
    [  350.331977] ../drivers/gpu/drm/i915/i915_gem_request.h:371 suspicious rcu_dereference_protected() usage!
    [  350.342619]
    [  350.342619] other info that might help us debug this:
    [  350.342619]
    [  350.351593]
    [  350.351593] rcu_scheduler_active = 1, debug_locks = 0
    [  350.358952] 3 locks held by Xorg/320:
    [  350.363077]  #0:  (&dev->mode_config.mutex){+.+.+.}, at: [<ffffffffa030589c>] drm_modeset_lock_all+0x3c/0xd0 [drm]
    [  350.375162]  #1:  (crtc_ww_class_acquire){+.+.+.}, at: [<ffffffffa03058a6>] drm_modeset_lock_all+0x46/0xd0 [drm]
    [  350.387022]  #2:  (crtc_ww_class_mutex){+.+.+.}, at: [<ffffffffa0305056>] drm_modeset_lock+0x36/0x110 [drm]
    [  350.398236]
    [  350.398236] stack backtrace:
    [  350.403196] CPU: 1 PID: 320 Comm: Xorg Tainted: G     U  W       4.8.0-rc8-bsw-rapl+ #3133
    [  350.412457] Hardware name: Intel Corporation CHERRYVIEW C0 PLATFORM/Braswell CRB, BIOS BRAS.X64.X088.R00.1510270350 10/27/2015
    [  350.425212]  0000000000000000 ffff8801680a78c8 ffffffff81332187 ffff88016c5c5000
    [  350.433611]  0000000000000001 ffff8801680a78f8 ffffffff810ca6da ffff88016cc8b0f0
    [  350.442012]  ffff88016cc80000 ffff88016cc80000 ffff880177ad0000 ffff8801680a7948
    [  350.450409] Call Trace:
    [  350.453165]  [<ffffffff81332187>] dump_stack+0x67/0x90
    [  350.458931]  [<ffffffff810ca6da>] lockdep_rcu_suspicious+0xea/0x120
    [  350.466002]  [<ffffffffa039e8dd>] fence_update+0xbd/0x670 [i915]
    [  350.472766]  [<ffffffffa039efe2>] i915_gem_restore_fences+0x52/0x70 [i915]
    [  350.480496]  [<ffffffffa0368f42>] vlv_resume_prepare+0x72/0x570 [i915]
    [  350.487839]  [<ffffffffa0369802>] intel_runtime_resume+0x102/0x210 [i915]
    [  350.495442]  [<ffffffff8137f26f>] pci_pm_runtime_resume+0x7f/0xb0
    [  350.502274]  [<ffffffff8137f1f0>] ? pci_restore_standard_config+0x40/0x40
    [  350.509883]  [<ffffffff814401c5>] __rpm_callback+0x35/0x70
    [  350.516037]  [<ffffffff8137f1f0>] ? pci_restore_standard_config+0x40/0x40
    [  350.523646]  [<ffffffff81440224>] rpm_callback+0x24/0x80
    [  350.529604]  [<ffffffff8137f1f0>] ? pci_restore_standard_config+0x40/0x40
    [  350.537212]  [<ffffffff814417bd>] rpm_resume+0x4ad/0x740
    [  350.543161]  [<ffffffff81441aa1>] __pm_runtime_resume+0x51/0x80
    [  350.549824]  [<ffffffffa03889c8>] intel_runtime_pm_get+0x28/0x90 [i915]
    [  350.557265]  [<ffffffffa0388a53>] intel_display_power_get+0x23/0x50 [i915]
    [  350.565001]  [<ffffffffa03ef23d>] intel_atomic_commit_tail+0xdfd/0x10b0 [i915]
    [  350.573106]  [<ffffffffa034b2e9>] ? drm_atomic_helper_swap_state+0x159/0x300 [drm_kms_helper]
    [  350.582659]  [<ffffffff81615091>] ? _raw_spin_unlock+0x31/0x50
    [  350.589205]  [<ffffffffa034b2e9>] ? drm_atomic_helper_swap_state+0x159/0x300 [drm_kms_helper]
    [  350.598787]  [<ffffffffa03ef8a5>] intel_atomic_commit+0x3b5/0x500 [i915]
    [  350.606319]  [<ffffffffa03061dc>] ? drm_atomic_set_crtc_for_connector+0xcc/0x100 [drm]
    [  350.615209]  [<ffffffffa0306b49>] drm_atomic_commit+0x49/0x50 [drm]
    [  350.622242]  [<ffffffffa034dee8>] drm_atomic_helper_set_config+0x88/0xc0 [drm_kms_helper]
    [  350.631419]  [<ffffffffa02f94ac>] drm_mode_set_config_internal+0x6c/0x120 [drm]
    [  350.639623]  [<ffffffffa02fa94c>] drm_mode_setcrtc+0x22c/0x4d0 [drm]
    [  350.646760]  [<ffffffffa02f0f19>] drm_ioctl+0x209/0x460 [drm]
    [  350.653217]  [<ffffffffa02fa720>] ? drm_mode_getcrtc+0x150/0x150 [drm]
    [  350.660536]  [<ffffffff810c984a>] ? __lock_is_held+0x4a/0x70
    [  350.666885]  [<ffffffff81202303>] do_vfs_ioctl+0x93/0x6b0
    [  350.672939]  [<ffffffff8120f843>] ? __fget+0x113/0x200
    [  350.678797]  [<ffffffff8120f735>] ? __fget+0x5/0x200
    [  350.684361]  [<ffffffff81202964>] SyS_ioctl+0x44/0x80
    [  350.690030]  [<ffffffff81001deb>] do_syscall_64+0x5b/0x120
    [  350.696184]  [<ffffffff81615ada>] entry_SYSCALL64_slow_path+0x25/0x25
    
    Note we also have to remember the lesson from commit 4fc788f5ee3d
    ("drm/i915: Flush delayed fence releases after reset") where we have to
    flush any changes to the fence on restore.
    
    v2: Replace call to release user mmaps with an assertion that they have
    already been zapped.
    
    Fixes: 49ef5294cda2 ("drm/i915: Move fence tracking from object to vma")
    Reported-by: Ville Syrjl <ville.syrjala@linux.intel.com>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Ville Syrjl <ville.syrjala@linux.intel.com>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: Mika Kuoppala <mika.kuoppala@intel.com>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20161012114827.17031-1-chris@chris-wilson.co.uk

commit 544baf9ab46761dc13beb9c02ecd645919b3b85d
Author: Fabio Estevam <fabio.estevam@nxp.com>
Date:   Wed Aug 17 12:41:08 2016 -0300

    can: flexcan: fix resume function
    
    commit 4de349e786a3a2d51bd02d56f3de151bbc3c3df9 upstream.
    
    On a imx6ul-pico board the following error is seen during system suspend:
    
    dpm_run_callback(): platform_pm_resume+0x0/0x54 returns -110
    PM: Device 2090000.flexcan failed to resume: error -110
    
    The reason for this suspend error is because when the CAN interface is not
    active the clocks are disabled and then flexcan_chip_enable() will
    always fail due to a timeout error.
    
    In order to fix this issue, only call flexcan_chip_enable/disable()
    when the CAN interface is active.
    
    Based on a patch from Dong Aisheng in the NXP kernel.
    
    Signed-off-by: Fabio Estevam <fabio.estevam@nxp.com>
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>

commit 0b5f2bd0dfa47e81a2c2104849c27c5be920782e
Author: Fabio Estevam <fabio.estevam@nxp.com>
Date:   Wed Aug 17 12:41:08 2016 -0300

    can: flexcan: fix resume function
    
    [ Upstream commit 4de349e786a3a2d51bd02d56f3de151bbc3c3df9 ]
    
    On a imx6ul-pico board the following error is seen during system suspend:
    
    dpm_run_callback(): platform_pm_resume+0x0/0x54 returns -110
    PM: Device 2090000.flexcan failed to resume: error -110
    
    The reason for this suspend error is because when the CAN interface is not
    active the clocks are disabled and then flexcan_chip_enable() will
    always fail due to a timeout error.
    
    In order to fix this issue, only call flexcan_chip_enable/disable()
    when the CAN interface is active.
    
    Based on a patch from Dong Aisheng in the NXP kernel.
    
    Signed-off-by: Fabio Estevam <fabio.estevam@nxp.com>
    Cc: linux-stable <stable@vger.kernel.org>
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
    Signed-off-by: Sasha Levin <alexander.levin@verizon.com>

commit fc6e4ced335133892fd436e36470b1ec3327a7a6
Author: Fabio Estevam <fabio.estevam@nxp.com>
Date:   Wed Aug 17 12:41:08 2016 -0300

    can: flexcan: fix resume function
    
    [ Upstream commit 4de349e786a3a2d51bd02d56f3de151bbc3c3df9 ]
    
    On a imx6ul-pico board the following error is seen during system suspend:
    
    dpm_run_callback(): platform_pm_resume+0x0/0x54 returns -110
    PM: Device 2090000.flexcan failed to resume: error -110
    
    The reason for this suspend error is because when the CAN interface is not
    active the clocks are disabled and then flexcan_chip_enable() will
    always fail due to a timeout error.
    
    In order to fix this issue, only call flexcan_chip_enable/disable()
    when the CAN interface is active.
    
    Based on a patch from Dong Aisheng in the NXP kernel.
    
    Signed-off-by: Fabio Estevam <fabio.estevam@nxp.com>
    Cc: linux-stable <stable@vger.kernel.org>
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
    Signed-off-by: Sasha Levin <alexander.levin@verizon.com>

commit a68022d9b59c2fc1ebe3c4133f0e2f32b4cde065
Author: Fabio Estevam <fabio.estevam@nxp.com>
Date:   Wed Aug 17 12:41:08 2016 -0300

    can: flexcan: fix resume function
    
    commit 4de349e786a3a2d51bd02d56f3de151bbc3c3df9 upstream.
    
    On a imx6ul-pico board the following error is seen during system suspend:
    
    dpm_run_callback(): platform_pm_resume+0x0/0x54 returns -110
    PM: Device 2090000.flexcan failed to resume: error -110
    
    The reason for this suspend error is because when the CAN interface is not
    active the clocks are disabled and then flexcan_chip_enable() will
    always fail due to a timeout error.
    
    In order to fix this issue, only call flexcan_chip_enable/disable()
    when the CAN interface is active.
    
    Based on a patch from Dong Aisheng in the NXP kernel.
    
    Signed-off-by: Fabio Estevam <fabio.estevam@nxp.com>
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 68e864b40b99ac0e5030a1bb1201b83f73f39d0d
Author: Fabio Estevam <fabio.estevam@nxp.com>
Date:   Wed Aug 17 12:41:08 2016 -0300

    can: flexcan: fix resume function
    
    commit 4de349e786a3a2d51bd02d56f3de151bbc3c3df9 upstream.
    
    On a imx6ul-pico board the following error is seen during system suspend:
    
    dpm_run_callback(): platform_pm_resume+0x0/0x54 returns -110
    PM: Device 2090000.flexcan failed to resume: error -110
    
    The reason for this suspend error is because when the CAN interface is not
    active the clocks are disabled and then flexcan_chip_enable() will
    always fail due to a timeout error.
    
    In order to fix this issue, only call flexcan_chip_enable/disable()
    when the CAN interface is active.
    
    Based on a patch from Dong Aisheng in the NXP kernel.
    
    Signed-off-by: Fabio Estevam <fabio.estevam@nxp.com>
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 4de349e786a3a2d51bd02d56f3de151bbc3c3df9
Author: Fabio Estevam <fabio.estevam@nxp.com>
Date:   Wed Aug 17 12:41:08 2016 -0300

    can: flexcan: fix resume function
    
    On a imx6ul-pico board the following error is seen during system suspend:
    
    dpm_run_callback(): platform_pm_resume+0x0/0x54 returns -110
    PM: Device 2090000.flexcan failed to resume: error -110
    
    The reason for this suspend error is because when the CAN interface is not
    active the clocks are disabled and then flexcan_chip_enable() will
    always fail due to a timeout error.
    
    In order to fix this issue, only call flexcan_chip_enable/disable()
    when the CAN interface is active.
    
    Based on a patch from Dong Aisheng in the NXP kernel.
    
    Signed-off-by: Fabio Estevam <fabio.estevam@nxp.com>
    Cc: linux-stable <stable@vger.kernel.org>
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>

commit e0dc7c837dd0f514abce47101c04ce0ce243188e
Author: Fabio Estevam <fabio.estevam@nxp.com>
Date:   Sun Aug 21 23:22:54 2016 -0300

    drm/fsl-dcu: disable clock on error path
    
    In fsl_dcu_drm_pm_resume() we should disable the previously enabled
    clock (fsl_dev->clk) when enabling fsl_dev->pix_clk fails.
    
    Signed-off-by: Fabio Estevam <fabio.estevam@nxp.com>
    Signed-off-by: Stefan Agner <stefan@agner.ch>

commit 9a0bcc8fe701bb6e05e622c19b5815e949c9b7c5
Merge: 15301a570754 b654c62e7734
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Sep 2 15:07:41 2016 -0700

    Merge tag 'pm-4.8-rc5' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull power management fixes from Rafael Wysocki:
     "This includes a stable-candidate cpufreq-dt driver problem fix and
      annotations of tracepoints in the runtime PM framework.
    
      Specifics:
    
       - Fix the definition of the cpufreq-dt driver's machines table
         introduced during the 4.7 cycle that should be NULL-terminated, but
         the termination entry is missing from it (Wei Yongjun).
    
       - Annotate tracepoints in the runtime PM framework's core so as to
         allow the functions containing them to be called from the idle code
         path without causing RCU to complain about illegal usage (Paul
         McKenney)"
    
    * tag 'pm-4.8-rc5' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm:
      PM / runtime: Add _rcuidle suffix to allow rpm_idle() use from idle
      PM / runtime: Add _rcuidle suffix to allow rpm_resume() to be called from idle
      cpufreq: dt: Add terminate entry for of_device_id tables

commit b654c62e7734cdcd507a5751cd940077be2ad373
Merge: bd37e022e334 d7737ce964d9
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Sep 2 22:38:30 2016 +0200

    Merge branches 'pm-cpufreq-fixes' and 'pm-core-fixes'
    
    * pm-cpufreq-fixes:
      cpufreq: dt: Add terminate entry for of_device_id tables
    
    * pm-core-fixes:
      PM / runtime: Add _rcuidle suffix to allow rpm_idle() use from idle
      PM / runtime: Add _rcuidle suffix to allow rpm_resume() to be called from idle

commit d44c950e9398e639e124014e5872480a37b67259
Author: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
Date:   Tue Apr 26 13:38:55 2016 -0700

    PM / runtime: Add _rcuidle suffix to allow rpm_resume() to be called from idle
    
    This commit applies another _rcuidle suffix to fix an RCU use from
    idle.
    
    > ===============================
    > [ INFO: suspicious RCU usage. ]
    > 4.6.0-rc5-next-20160426+ #1122 Not tainted
    > -------------------------------
    > include/trace/events/rpm.h:69 suspicious rcu_dereference_check() usage!
    >
    > other info that might help us debug this:
    >
    >
    > RCU used illegally from idle CPU!
    > rcu_scheduler_active = 1, debug_locks = 0
    > RCU used illegally from extended quiescent state!
    > 1 lock held by swapper/0/0:
    >  #0:  (&(&dev->power.lock)->rlock){-.-...}, at: [<c052e3dc>] __pm_runtime_resume+0x3c/0x64
    >
    > stack backtrace:
    > CPU: 0 PID: 0 Comm: swapper/0 Not tainted 4.6.0-rc5-next-20160426+ #1122
    > Hardware name: Generic OMAP36xx (Flattened Device Tree)
    > [<c0110290>] (unwind_backtrace) from [<c010c3a8>] (show_stack+0x10/0x14)
    > [<c010c3a8>] (show_stack) from [<c047fd68>] (dump_stack+0xb0/0xe4)
    > [<c047fd68>] (dump_stack) from [<c052e178>] (rpm_resume+0x5cc/0x7f4)
    > [<c052e178>] (rpm_resume) from [<c052e3ec>] (__pm_runtime_resume+0x4c/0x64)
    > [<c052e3ec>] (__pm_runtime_resume) from [<c04bf2c4>] (omap2_gpio_resume_after_idle+0x54/0x68)
    > [<c04bf2c4>] (omap2_gpio_resume_after_idle) from [<c01269dc>] (omap3_enter_idle_bm+0xfc/0x1ec)
    > [<c01269dc>] (omap3_enter_idle_bm) from [<c060198c>] (cpuidle_enter_state+0x80/0x3d4)
    > [<c060198c>] (cpuidle_enter_state) from [<c0183b08>] (cpu_startup_entry+0x198/0x3a0)
    > [<c0183b08>] (cpu_startup_entry) from [<c0b00c0c>] (start_kernel+0x354/0x3c8)
    > [<c0b00c0c>] (start_kernel) from [<8000807c>] (0x8000807c)
    
    Reported-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Tested-by: Tony Lindgren <tony@atomide.com>
    Tested-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 3f328647ca8f7255a8d5ca202133f25966fdf200
Author: Roger Quadros <rogerq@ti.com>
Date:   Mon May 9 11:28:37 2016 +0300

    mfd: omap-usb-tll: Fix scheduling while atomic BUG
    
    commit b49b927f16acee626c56a1af4ab4cb062f75b5df upstream.
    
    We shouldn't be calling clk_prepare_enable()/clk_prepare_disable()
    in an atomic context.
    
    Fixes the following issue:
    
    [    5.830970] ehci-omap: OMAP-EHCI Host Controller driver
    [    5.830974] driver_register 'ehci-omap'
    [    5.895849] driver_register 'wl1271_sdio'
    [    5.896870] BUG: scheduling while atomic: udevd/994/0x00000002
    [    5.896876] 4 locks held by udevd/994:
    [    5.896904]  #0:  (&dev->mutex){......}, at: [<c049597c>] __driver_attach+0x60/0xac
    [    5.896923]  #1:  (&dev->mutex){......}, at: [<c049598c>] __driver_attach+0x70/0xac
    [    5.896946]  #2:  (tll_lock){+.+...}, at: [<c04c2630>] omap_tll_enable+0x2c/0xd0
    [    5.896966]  #3:  (prepare_lock){+.+...}, at: [<c05ce9c8>] clk_prepare_lock+0x48/0xe0
    [    5.897042] Modules linked in: wlcore_sdio(+) ehci_omap(+) dwc3_omap snd_soc_ts3a225e leds_is31fl319x bq27xxx_battery_i2c tsc2007 bq27xxx_battery bq2429x_charger ina2xx tca8418_keypad as5013 leds_tca6507 twl6040_vibra gpio_twl6040 bmp085_i2c(+) palmas_gpadc usb3503 palmas_pwrbutton bmg160_i2c(+) bmp085 bma150(+) bmg160_core bmp280 input_polldev snd_soc_omap_mcbsp snd_soc_omap_mcpdm snd_soc_omap snd_pcm_dmaengine
    [    5.897048] Preemption disabled at:[<  (null)>]   (null)
    [    5.897051]
    [    5.897059] CPU: 0 PID: 994 Comm: udevd Not tainted 4.6.0-rc5-letux+ #233
    [    5.897062] Hardware name: Generic OMAP5 (Flattened Device Tree)
    [    5.897076] [<c010e714>] (unwind_backtrace) from [<c010af34>] (show_stack+0x10/0x14)
    [    5.897087] [<c010af34>] (show_stack) from [<c040aa7c>] (dump_stack+0x88/0xc0)
    [    5.897099] [<c040aa7c>] (dump_stack) from [<c020c558>] (__schedule_bug+0xac/0xd0)
    [    5.897111] [<c020c558>] (__schedule_bug) from [<c06f3d44>] (__schedule+0x88/0x7e4)
    [    5.897120] [<c06f3d44>] (__schedule) from [<c06f46d8>] (schedule+0x9c/0xc0)
    [    5.897129] [<c06f46d8>] (schedule) from [<c06f4904>] (schedule_preempt_disabled+0x14/0x20)
    [    5.897140] [<c06f4904>] (schedule_preempt_disabled) from [<c06f64e4>] (mutex_lock_nested+0x258/0x43c)
    [    5.897150] [<c06f64e4>] (mutex_lock_nested) from [<c05ce9c8>] (clk_prepare_lock+0x48/0xe0)
    [    5.897160] [<c05ce9c8>] (clk_prepare_lock) from [<c05d0e7c>] (clk_prepare+0x10/0x28)
    [    5.897169] [<c05d0e7c>] (clk_prepare) from [<c04c2668>] (omap_tll_enable+0x64/0xd0)
    [    5.897180] [<c04c2668>] (omap_tll_enable) from [<c04c1728>] (usbhs_runtime_resume+0x18/0x17c)
    [    5.897192] [<c04c1728>] (usbhs_runtime_resume) from [<c049d404>] (pm_generic_runtime_resume+0x2c/0x40)
    [    5.897202] [<c049d404>] (pm_generic_runtime_resume) from [<c049f180>] (__rpm_callback+0x38/0x68)
    [    5.897210] [<c049f180>] (__rpm_callback) from [<c049f220>] (rpm_callback+0x70/0x88)
    [    5.897218] [<c049f220>] (rpm_callback) from [<c04a0a00>] (rpm_resume+0x4ec/0x7ec)
    [    5.897227] [<c04a0a00>] (rpm_resume) from [<c04a0f48>] (__pm_runtime_resume+0x4c/0x64)
    [    5.897236] [<c04a0f48>] (__pm_runtime_resume) from [<c04958dc>] (driver_probe_device+0x30/0x70)
    [    5.897246] [<c04958dc>] (driver_probe_device) from [<c04959a4>] (__driver_attach+0x88/0xac)
    [    5.897256] [<c04959a4>] (__driver_attach) from [<c04940f8>] (bus_for_each_dev+0x50/0x84)
    [    5.897267] [<c04940f8>] (bus_for_each_dev) from [<c0494e40>] (bus_add_driver+0xcc/0x1e4)
    [    5.897276] [<c0494e40>] (bus_add_driver) from [<c0496914>] (driver_register+0xac/0xf4)
    [    5.897286] [<c0496914>] (driver_register) from [<c01018e0>] (do_one_initcall+0x100/0x1b8)
    [    5.897296] [<c01018e0>] (do_one_initcall) from [<c01c7a54>] (do_init_module+0x58/0x1c0)
    [    5.897304] [<c01c7a54>] (do_init_module) from [<c01c8a3c>] (SyS_finit_module+0x88/0x90)
    [    5.897313] [<c01c8a3c>] (SyS_finit_module) from [<c0107120>] (ret_fast_syscall+0x0/0x1c)
    [    5.912697] ------------[ cut here ]------------
    [    5.912711] WARNING: CPU: 0 PID: 994 at kernel/sched/core.c:2996 _raw_spin_unlock+0x28/0x58
    [    5.912717] DEBUG_LOCKS_WARN_ON(val > preempt_count())
    
    Reported-by: H. Nikolaus Schaller <hns@goldelico.com>
    Tested-by: H. Nikolaus Schaller <hns@goldelico.com>
    Signed-off-by: Roger Quadros <rogerq@ti.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit ccac349834cc168be606c63900b5a09840fd7b89
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri May 20 23:09:49 2016 +0200

    PM / sleep: Handle failures in device_suspend_late() consistently
    
    commit 3a17fb329da68cb00558721aff876a80bba2fdb9 upstream.
    
    Grygorii Strashko reports:
    
     The PM runtime will be left disabled for the device if its
     .suspend_late() callback fails and async suspend is not allowed
     for this device. In this case device will not be added in
     dpm_late_early_list and dpm_resume_early() will ignore this
     device, as result PM runtime will be disabled for it forever
     (side effect: after 8 subsequent failures for the same device
     the PM runtime will be reenabled due to disable_depth overflow).
    
    To fix this problem, add devices to dpm_late_early_list regardless
    of whether or not device_suspend_late() returns errors for them.
    
    That will ensure failures in there to be handled consistently for
    all devices regardless of their async suspend/resume status.
    
    Reported-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Tested-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit 8fe5616b20e5742bb5fee0e77dffe2fc76ac92a0
Author: Jyri Sarha <jsarha@ti.com>
Date:   Tue Jun 14 11:43:30 2016 +0300

    drm/tilcdc: Restore old dpms state in pm_resume()
    
    Restore old dpms state in pm_resume(). The dpms is turned off in
    pm_suspend() and it should be restored to its original state in
    pm_resume(). Without this patch the display is left blanked after a
    suspend/resume cycle.
    
    Fixes commit 614b3cfeb8d2 ("drm/tilcdc: disable the lcd controller/dma
    engine when suspend invoked")
    
    Signed-off-by: Jyri Sarha <jsarha@ti.com>

commit 213fa10db2f9c6725946cfa682990277eb9cd565
Author: Grygorii Strashko <grygorii.strashko@ti.com>
Date:   Thu Jul 28 20:50:37 2016 +0300

    ARM: OMAP2+: omap_device: fix crash on omap_device removal
    
    Below call chain causes system crash when OMAP device is
    removed by calling of_platform_depopulate()/device_del():
    
    device_del()
    - blocking_notifier_call_chain(&dev->bus->p->bus_notifier,
                                 BUS_NOTIFY_DEL_DEVICE, dev);
      - _omap_device_notifier_call()
        - omap_device_delete()
          - od->pdev->archdata.od = NULL;
            kfree(od->hwmods);
            kfree(od);
      - bus_remove_device()
        - device_release_driver()
          - __device_release_driver()
            - pm_runtime_get_sync()
               - _od_runtime_resume()
                 - omap_hwmod_enable() <- OOPS od's delted already
    
    Backtrace:
    Unable to handle kernel NULL pointer dereference at virtual address 0000000d
    pgd = eb100000
    [0000000d] *pgd=ad6e1831, *pte=00000000, *ppte=00000000
    Internal error: Oops: 17 [#1] PREEMPT SMP ARM
    CPU: 1 PID: 1273 Comm: modprobe Not tainted 4.4.15-rt19-00115-ge4d3cd3-dirty #68
    Hardware name: Generic DRA74X (Flattened Device Tree)
    task: eb1ee800 ti: ec962000 task.ti: ec962000
    PC is at omap_device_enable+0x10/0x90
    LR is at _od_runtime_resume+0x10/0x24
    [...]
    [<c00299dc>] (omap_device_enable) from [<c0029a6c>] (_od_runtime_resume+0x10/0x24)
    [<c0029a6c>] (_od_runtime_resume) from [<c04ad404>] (__rpm_callback+0x20/0x34)
    [<c04ad404>] (__rpm_callback) from [<c04ad438>] (rpm_callback+0x20/0x80)
    [<c04ad438>] (rpm_callback) from [<c04aee28>] (rpm_resume+0x48c/0x964)
    [<c04aee28>] (rpm_resume) from [<c04af360>] (__pm_runtime_resume+0x60/0x88)
    [<c04af360>] (__pm_runtime_resume) from [<c04a4974>] (__device_release_driver+0x30/0x100)
    [<c04a4974>] (__device_release_driver) from [<c04a4a60>] (device_release_driver+0x1c/0x28)
    [<c04a4a60>] (device_release_driver) from [<c04a38c0>] (bus_remove_device+0xec/0x144)
    [<c04a38c0>] (bus_remove_device) from [<c04a0764>] (device_del+0x10c/0x210)
    [<c04a0764>] (device_del) from [<c04a67b0>] (platform_device_del+0x18/0x84)
    [<c04a67b0>] (platform_device_del) from [<c04a6828>] (platform_device_unregister+0xc/0x20)
    [<c04a6828>] (platform_device_unregister) from [<c05adcfc>] (of_platform_device_destroy+0x8c/0x90)
    [<c05adcfc>] (of_platform_device_destroy) from [<c04a02f0>] (device_for_each_child+0x4c/0x78)
    [<c04a02f0>] (device_for_each_child) from [<c05adc5c>] (of_platform_depopulate+0x30/0x44)
    [<c05adc5c>] (of_platform_depopulate) from [<bf123920>] (cpsw_remove+0x68/0xf4 [ti_cpsw])
    [<bf123920>] (cpsw_remove [ti_cpsw]) from [<c04a68d8>] (platform_drv_remove+0x24/0x3c)
    [<c04a68d8>] (platform_drv_remove) from [<c04a49c8>] (__device_release_driver+0x84/0x100)
    [<c04a49c8>] (__device_release_driver) from [<c04a4b20>] (driver_detach+0xac/0xb0)
    [<c04a4b20>] (driver_detach) from [<c04a3be8>] (bus_remove_driver+0x60/0xd4)
    [<c04a3be8>] (bus_remove_driver) from [<c00d9870>] (SyS_delete_module+0x184/0x20c)
    [<c00d9870>] (SyS_delete_module) from [<c0010540>] (ret_fast_syscall+0x0/0x1c)
    Code: e3500000 e92d4070 1590630c 01a06000 (e5d6300d)
    
    Hence, fix it by using BUS_NOTIFY_REMOVED_DEVICE event for OMAP device
    deletion which is sent when DD has finished processing of device
    deletion.
    
    Cc: Tony Lindgren <tony@atomide.com>
    Cc: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 5dbf9612eeb5bcb863d727439754980847e45d5a
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Fri Jun 17 13:35:56 2016 +0200

    ALSA: hdac_regmap - fix the register access for runtime PM
    
    commit 8198868f0a283eb23e264951632ce61ec2f82228 upstream.
    
    Call path:
    
      1) snd_hdac_power_up_pm()
      2) snd_hdac_power_up()
      3) pm_runtime_get_sync()
      4) __pm_runtime_resume()
      5) rpm_resume()
    
    The rpm_resume() returns 1 when the device is already active.
    Because the return value is unmodified, the hdac regmap read/write
    functions should allow this value for the retry I/O operation, too.
    
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 089a2d8400a63701ed271c03f6bf8b2d29bb5b98
Author: Bin Liu <b-liu@ti.com>
Date:   Tue May 31 10:05:24 2016 -0500

    usb: musb: only restore devctl when session was set in backup
    
    commit 84ac5d1140f716a616522f952734e850448d2556 upstream.
    
    If the session bit was not set in the backup of devctl register,
    restoring devctl would clear the session bit. Therefor, only restore
    devctl register when the session bit was set in the backup.
    
    This solves the device enumeration failure in otg mode exposed by commit
    56f487c (PM / Runtime: Update last_busy in rpm_resume).
    
    Signed-off-by: Bin Liu <b-liu@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 7adf3cd844622756befc599ef729b87590259876
Author: Bin Liu <b-liu@ti.com>
Date:   Tue May 31 10:05:24 2016 -0500

    usb: musb: only restore devctl when session was set in backup
    
    commit 84ac5d1140f716a616522f952734e850448d2556 upstream.
    
    If the session bit was not set in the backup of devctl register,
    restoring devctl would clear the session bit. Therefor, only restore
    devctl register when the session bit was set in the backup.
    
    This solves the device enumeration failure in otg mode exposed by commit
    56f487c (PM / Runtime: Update last_busy in rpm_resume).
    
    Signed-off-by: Bin Liu <b-liu@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 0b1ca750b5fe6e457768c1b835f7f380a288ca58
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Fri Jun 17 13:35:56 2016 +0200

    ALSA: hdac_regmap - fix the register access for runtime PM
    
    [ Upstream commit 8198868f0a283eb23e264951632ce61ec2f82228 ]
    
    Call path:
    
      1) snd_hdac_power_up_pm()
      2) snd_hdac_power_up()
      3) pm_runtime_get_sync()
      4) __pm_runtime_resume()
      5) rpm_resume()
    
    The rpm_resume() returns 1 when the device is already active.
    Because the return value is unmodified, the hdac regmap read/write
    functions should allow this value for the retry I/O operation, too.
    
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Sasha Levin <sasha.levin@oracle.com>

commit 8198868f0a283eb23e264951632ce61ec2f82228
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Fri Jun 17 13:35:56 2016 +0200

    ALSA: hdac_regmap - fix the register access for runtime PM
    
    Call path:
    
      1) snd_hdac_power_up_pm()
      2) snd_hdac_power_up()
      3) pm_runtime_get_sync()
      4) __pm_runtime_resume()
      5) rpm_resume()
    
    The rpm_resume() returns 1 when the device is already active.
    Because the return value is unmodified, the hdac regmap read/write
    functions should allow this value for the retry I/O operation, too.
    
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

commit f17a0dd1c2e0d05c38589c9a13a36db455b74818
Author: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
Date:   Tue Apr 26 14:02:23 2016 -0700

    clk: Use _rcuidle suffix to allow clk_core_enable() to used from idle
    
    This commit fixes the RCU use-from-idle bug corresponding the following
    splat:
    
    > [ INFO: suspicious RCU usage. ]
    > 4.6.0-rc5-next-20160426+ #1127 Not tainted
    > -------------------------------
    > include/trace/events/clk.h:45 suspicious rcu_dereference_check() usage!
    >
    > other info that might help us debug this:
    >
    >
    > RCU used illegally from idle CPU!
    > rcu_scheduler_active = 1, debug_locks = 0
    > RCU used illegally from extended quiescent state!
    > 2 locks held by swapper/0/0:
    >  #0:  (&oh->hwmod_key#30){......}, at: [<c0121afc>] omap_hwmod_enable+0x18/0x44
    >  #1:  (enable_lock){......}, at: [<c0630684>] clk_enable_lock+0x18/0x124
    >
    > stack backtrace:
    > CPU: 0 PID: 0 Comm: swapper/0 Not tainted 4.6.0-rc5-next-20160426+ #1127
    > Hardware name: Generic OMAP36xx (Flattened Device Tree)
    > [<c0110290>] (unwind_backtrace) from [<c010c3a8>] (show_stack+0x10/0x14)
    > [<c010c3a8>] (show_stack) from [<c047fd68>] (dump_stack+0xb0/0xe4)
    > [<c047fd68>] (dump_stack) from [<c06315c0>] (clk_core_enable+0x1e0/0x36c)
    > [<c06315c0>] (clk_core_enable) from [<c0632298>] (clk_enable+0x1c/0x38)
    > [<c0632298>] (clk_enable) from [<c01204e0>] (_enable_clocks+0x18/0x7c)
    > [<c01204e0>] (_enable_clocks) from [<c012137c>] (_enable+0x114/0x2ec)
    > [<c012137c>] (_enable) from [<c0121b08>] (omap_hwmod_enable+0x24/0x44)
    > [<c0121b08>] (omap_hwmod_enable) from [<c0122ad0>] (omap_device_enable+0x3c/0x90)
    > [<c0122ad0>] (omap_device_enable) from [<c0122b34>] (_od_runtime_resume+0x10/0x38)
    > [<c0122b34>] (_od_runtime_resume) from [<c052cc00>] (__rpm_callback+0x2c/0x60)
    > [<c052cc00>] (__rpm_callback) from [<c052cc54>] (rpm_callback+0x20/0x80)
    > [<c052cc54>] (rpm_callback) from [<c052df7c>] (rpm_resume+0x3d0/0x6f0)
    > [<c052df7c>] (rpm_resume) from [<c052e2e8>] (__pm_runtime_resume+0x4c/0x64)
    > [<c052e2e8>] (__pm_runtime_resume) from [<c04bf2c4>] (omap2_gpio_resume_after_idle+0x54/0x68)
    > [<c04bf2c4>] (omap2_gpio_resume_after_idle) from [<c01269dc>] (omap3_enter_idle_bm+0xfc/0x1ec)
    > [<c01269dc>] (omap3_enter_idle_bm) from [<c0601888>] (cpuidle_enter_state+0x80/0x3d4)
    > [<c0601888>] (cpuidle_enter_state) from [<c0183b08>] (cpu_startup_entry+0x198/0x3a0)
    > [<c0183b08>] (cpu_startup_entry) from [<c0b00c0c>] (start_kernel+0x354/0x3c8)
    > [<c0b00c0c>] (start_kernel) from [<8000807c>] (0x8000807c)
    
    Reported-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Tested-by: Tony Lindgren <tony@atomide.com>
    Tested-by: Guenter Roeck <linux@roeck-us.net>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Michael Turquette <mturquette@baylibre.com>
    Cc: Stephen Boyd <sboyd@codeaurora.org>
    Cc: <linux-omap@vger.kernel.org>
    Cc: <linux-arm-kernel@lists.infradead.org>
    Cc: <linux-clk@vger.kernel.org>

commit 41103c791d4af40643183825d61eb7bb34282ac3
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri May 20 23:09:49 2016 +0200

    PM / sleep: Handle failures in device_suspend_late() consistently
    
    commit 3a17fb329da68cb00558721aff876a80bba2fdb9 upstream.
    
    Grygorii Strashko reports:
    
     The PM runtime will be left disabled for the device if its
     .suspend_late() callback fails and async suspend is not allowed
     for this device. In this case device will not be added in
     dpm_late_early_list and dpm_resume_early() will ignore this
     device, as result PM runtime will be disabled for it forever
     (side effect: after 8 subsequent failures for the same device
     the PM runtime will be reenabled due to disable_depth overflow).
    
    To fix this problem, add devices to dpm_late_early_list regardless
    of whether or not device_suspend_late() returns errors for them.
    
    That will ensure failures in there to be handled consistently for
    all devices regardless of their async suspend/resume status.
    
    Reported-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Tested-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 7360309ba4b5f4ae2839844748e23a157ffdc67d
Author: Lyude <cpaul@redhat.com>
Date:   Tue May 31 12:49:06 2016 -0400

    drm/i915: Discard previous atomic state on resume if connectors change
    
    If an MST device is disconnected while the machine is suspended, the
    number of connectors will change as well after we call
    intel_dp_mst_resume(). This means that any previous atomic state we had
    before suspending is no longer valid, since it'll still be pointing to
    missing connectors. We need to check for this before committing the
    state, otherwise we'll kernel panic on resume whenever if any MST
    display was disconnected before we started resuming:
    
    BUG: unable to handle kernel NULL pointer dereference at 0000000000000008
    IP: [<ffffffffa01588ef>] drm_atomic_helper_check_modeset+0x29f/0xb40 [drm_kms_helper]
    Call Trace:
     [<ffffffffa02354f4>] intel_atomic_check+0x34/0x1180 [i915]
     [<ffffffff810e6c3f>] ? mark_held_locks+0x6f/0xa0
     [<ffffffff810e6d99>] ? trace_hardirqs_on_caller+0x129/0x1b0
     [<ffffffffa00ff1d2>] drm_atomic_check_only+0x192/0x620 [drm]
     [<ffffffff813ee001>] ? pci_pm_thaw+0x21/0x90
     [<ffffffffa00ff677>] drm_atomic_commit+0x17/0x60 [drm]
     [<ffffffffa023e0ad>] intel_display_resume+0xbd/0x160 [i915]
     [<ffffffff813ee070>] ? pci_pm_thaw+0x90/0x90
     [<ffffffffa01b60d8>] i915_drm_resume+0xd8/0x160 [i915]
     [<ffffffffa01b6185>] i915_pm_resume+0x25/0x30 [i915]
     [<ffffffff813ee0d4>] pci_pm_resume+0x64/0xa0
     [<ffffffff814d9ea0>] dpm_run_callback+0x90/0x190
     [<ffffffff814da455>] device_resume+0xd5/0x1f0
     [<ffffffff814da58d>] async_resume+0x1d/0x50
     [<ffffffff810b6718>] async_run_entry_fn+0x48/0x150
     [<ffffffff810acc19>] process_one_work+0x1e9/0x5c0
     [<ffffffff810acb96>] ? process_one_work+0x166/0x5c0
     [<ffffffff810ad038>] worker_thread+0x48/0x4e0
     [<ffffffff810acff0>] ? process_one_work+0x5c0/0x5c0
     [<ffffffff810b3794>] kthread+0xe4/0x100
     [<ffffffff81742672>] ret_from_fork+0x22/0x50
     [<ffffffff810b36b0>] ? kthread_create_on_node+0x200/0x200
    
    Changes since v1:
      - Move drm_atomic_state_free() call down so we're holding the
        appropriate locks when destroying the atomic state
    Changes since v2:
      - Check that state != NULL before we start accessing it's members
    
    This fix is only required for 4.6 and below. David Airlie's patchseries
    for 4.7 to add connector reference counting provides a more proper fix
    for this.
    
    Upstream fix: 0552f7651bc2 ("drm/i915/mst: use reference counted
    connectors. (v3)")
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Lyude <cpaul@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 0c42f6c9199233f3947d531df81fc44574ace18e
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri May 20 23:09:49 2016 +0200

    PM / sleep: Handle failures in device_suspend_late() consistently
    
    commit 3a17fb329da68cb00558721aff876a80bba2fdb9 upstream.
    
    Grygorii Strashko reports:
    
     The PM runtime will be left disabled for the device if its
     .suspend_late() callback fails and async suspend is not allowed
     for this device. In this case device will not be added in
     dpm_late_early_list and dpm_resume_early() will ignore this
     device, as result PM runtime will be disabled for it forever
     (side effect: after 8 subsequent failures for the same device
     the PM runtime will be reenabled due to disable_depth overflow).
    
    To fix this problem, add devices to dpm_late_early_list regardless
    of whether or not device_suspend_late() returns errors for them.
    
    That will ensure failures in there to be handled consistently for
    all devices regardless of their async suspend/resume status.
    
    Reported-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Tested-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 98c28450538d0a191d031cce8852e568b62a1127
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri May 20 23:09:49 2016 +0200

    PM / sleep: Handle failures in device_suspend_late() consistently
    
    commit 3a17fb329da68cb00558721aff876a80bba2fdb9 upstream.
    
    Grygorii Strashko reports:
    
     The PM runtime will be left disabled for the device if its
     .suspend_late() callback fails and async suspend is not allowed
     for this device. In this case device will not be added in
     dpm_late_early_list and dpm_resume_early() will ignore this
     device, as result PM runtime will be disabled for it forever
     (side effect: after 8 subsequent failures for the same device
     the PM runtime will be reenabled due to disable_depth overflow).
    
    To fix this problem, add devices to dpm_late_early_list regardless
    of whether or not device_suspend_late() returns errors for them.
    
    That will ensure failures in there to be handled consistently for
    all devices regardless of their async suspend/resume status.
    
    Reported-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Tested-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 0cf266167e9f1e39bb411a49f1163f488f5a75e8
Author: Roger Quadros <rogerq@ti.com>
Date:   Mon May 9 11:28:37 2016 +0300

    mfd: omap-usb-tll: Fix scheduling while atomic BUG
    
    commit b49b927f16acee626c56a1af4ab4cb062f75b5df upstream.
    
    We shouldn't be calling clk_prepare_enable()/clk_prepare_disable()
    in an atomic context.
    
    Fixes the following issue:
    
    [    5.830970] ehci-omap: OMAP-EHCI Host Controller driver
    [    5.830974] driver_register 'ehci-omap'
    [    5.895849] driver_register 'wl1271_sdio'
    [    5.896870] BUG: scheduling while atomic: udevd/994/0x00000002
    [    5.896876] 4 locks held by udevd/994:
    [    5.896904]  #0:  (&dev->mutex){......}, at: [<c049597c>] __driver_attach+0x60/0xac
    [    5.896923]  #1:  (&dev->mutex){......}, at: [<c049598c>] __driver_attach+0x70/0xac
    [    5.896946]  #2:  (tll_lock){+.+...}, at: [<c04c2630>] omap_tll_enable+0x2c/0xd0
    [    5.896966]  #3:  (prepare_lock){+.+...}, at: [<c05ce9c8>] clk_prepare_lock+0x48/0xe0
    [    5.897042] Modules linked in: wlcore_sdio(+) ehci_omap(+) dwc3_omap snd_soc_ts3a225e leds_is31fl319x bq27xxx_battery_i2c tsc2007 bq27xxx_battery bq2429x_charger ina2xx tca8418_keypad as5013 leds_tca6507 twl6040_vibra gpio_twl6040 bmp085_i2c(+) palmas_gpadc usb3503 palmas_pwrbutton bmg160_i2c(+) bmp085 bma150(+) bmg160_core bmp280 input_polldev snd_soc_omap_mcbsp snd_soc_omap_mcpdm snd_soc_omap snd_pcm_dmaengine
    [    5.897048] Preemption disabled at:[<  (null)>]   (null)
    [    5.897051]
    [    5.897059] CPU: 0 PID: 994 Comm: udevd Not tainted 4.6.0-rc5-letux+ #233
    [    5.897062] Hardware name: Generic OMAP5 (Flattened Device Tree)
    [    5.897076] [<c010e714>] (unwind_backtrace) from [<c010af34>] (show_stack+0x10/0x14)
    [    5.897087] [<c010af34>] (show_stack) from [<c040aa7c>] (dump_stack+0x88/0xc0)
    [    5.897099] [<c040aa7c>] (dump_stack) from [<c020c558>] (__schedule_bug+0xac/0xd0)
    [    5.897111] [<c020c558>] (__schedule_bug) from [<c06f3d44>] (__schedule+0x88/0x7e4)
    [    5.897120] [<c06f3d44>] (__schedule) from [<c06f46d8>] (schedule+0x9c/0xc0)
    [    5.897129] [<c06f46d8>] (schedule) from [<c06f4904>] (schedule_preempt_disabled+0x14/0x20)
    [    5.897140] [<c06f4904>] (schedule_preempt_disabled) from [<c06f64e4>] (mutex_lock_nested+0x258/0x43c)
    [    5.897150] [<c06f64e4>] (mutex_lock_nested) from [<c05ce9c8>] (clk_prepare_lock+0x48/0xe0)
    [    5.897160] [<c05ce9c8>] (clk_prepare_lock) from [<c05d0e7c>] (clk_prepare+0x10/0x28)
    [    5.897169] [<c05d0e7c>] (clk_prepare) from [<c04c2668>] (omap_tll_enable+0x64/0xd0)
    [    5.897180] [<c04c2668>] (omap_tll_enable) from [<c04c1728>] (usbhs_runtime_resume+0x18/0x17c)
    [    5.897192] [<c04c1728>] (usbhs_runtime_resume) from [<c049d404>] (pm_generic_runtime_resume+0x2c/0x40)
    [    5.897202] [<c049d404>] (pm_generic_runtime_resume) from [<c049f180>] (__rpm_callback+0x38/0x68)
    [    5.897210] [<c049f180>] (__rpm_callback) from [<c049f220>] (rpm_callback+0x70/0x88)
    [    5.897218] [<c049f220>] (rpm_callback) from [<c04a0a00>] (rpm_resume+0x4ec/0x7ec)
    [    5.897227] [<c04a0a00>] (rpm_resume) from [<c04a0f48>] (__pm_runtime_resume+0x4c/0x64)
    [    5.897236] [<c04a0f48>] (__pm_runtime_resume) from [<c04958dc>] (driver_probe_device+0x30/0x70)
    [    5.897246] [<c04958dc>] (driver_probe_device) from [<c04959a4>] (__driver_attach+0x88/0xac)
    [    5.897256] [<c04959a4>] (__driver_attach) from [<c04940f8>] (bus_for_each_dev+0x50/0x84)
    [    5.897267] [<c04940f8>] (bus_for_each_dev) from [<c0494e40>] (bus_add_driver+0xcc/0x1e4)
    [    5.897276] [<c0494e40>] (bus_add_driver) from [<c0496914>] (driver_register+0xac/0xf4)
    [    5.897286] [<c0496914>] (driver_register) from [<c01018e0>] (do_one_initcall+0x100/0x1b8)
    [    5.897296] [<c01018e0>] (do_one_initcall) from [<c01c7a54>] (do_init_module+0x58/0x1c0)
    [    5.897304] [<c01c7a54>] (do_init_module) from [<c01c8a3c>] (SyS_finit_module+0x88/0x90)
    [    5.897313] [<c01c8a3c>] (SyS_finit_module) from [<c0107120>] (ret_fast_syscall+0x0/0x1c)
    [    5.912697] ------------[ cut here ]------------
    [    5.912711] WARNING: CPU: 0 PID: 994 at kernel/sched/core.c:2996 _raw_spin_unlock+0x28/0x58
    [    5.912717] DEBUG_LOCKS_WARN_ON(val > preempt_count())
    
    Reported-by: H. Nikolaus Schaller <hns@goldelico.com>
    Tested-by: H. Nikolaus Schaller <hns@goldelico.com>
    Signed-off-by: Roger Quadros <rogerq@ti.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Willy Tarreau <w@1wt.eu>

commit a6fccead2b1285eb96e15e219467f985db0871b9
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri May 20 23:09:49 2016 +0200

    PM / sleep: Handle failures in device_suspend_late() consistently
    
    [ Upstream commit 3a17fb329da68cb00558721aff876a80bba2fdb9 ]
    
    Grygorii Strashko reports:
    
     The PM runtime will be left disabled for the device if its
     .suspend_late() callback fails and async suspend is not allowed
     for this device. In this case device will not be added in
     dpm_late_early_list and dpm_resume_early() will ignore this
     device, as result PM runtime will be disabled for it forever
     (side effect: after 8 subsequent failures for the same device
     the PM runtime will be reenabled due to disable_depth overflow).
    
    To fix this problem, add devices to dpm_late_early_list regardless
    of whether or not device_suspend_late() returns errors for them.
    
    That will ensure failures in there to be handled consistently for
    all devices regardless of their async suspend/resume status.
    
    Reported-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Tested-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: All applicable <stable@vger.kernel.org>
    Signed-off-by: Sasha Levin <sasha.levin@oracle.com>

commit ec391566f8e498f5f3d92ff6c6abfdf6ac5a164b
Author: Roger Quadros <rogerq@ti.com>
Date:   Mon May 9 11:28:37 2016 +0300

    mfd: omap-usb-tll: Fix scheduling while atomic BUG
    
    [ Upstream commit b49b927f16acee626c56a1af4ab4cb062f75b5df ]
    
    We shouldn't be calling clk_prepare_enable()/clk_prepare_disable()
    in an atomic context.
    
    Fixes the following issue:
    
    [    5.830970] ehci-omap: OMAP-EHCI Host Controller driver
    [    5.830974] driver_register 'ehci-omap'
    [    5.895849] driver_register 'wl1271_sdio'
    [    5.896870] BUG: scheduling while atomic: udevd/994/0x00000002
    [    5.896876] 4 locks held by udevd/994:
    [    5.896904]  #0:  (&dev->mutex){......}, at: [<c049597c>] __driver_attach+0x60/0xac
    [    5.896923]  #1:  (&dev->mutex){......}, at: [<c049598c>] __driver_attach+0x70/0xac
    [    5.896946]  #2:  (tll_lock){+.+...}, at: [<c04c2630>] omap_tll_enable+0x2c/0xd0
    [    5.896966]  #3:  (prepare_lock){+.+...}, at: [<c05ce9c8>] clk_prepare_lock+0x48/0xe0
    [    5.897042] Modules linked in: wlcore_sdio(+) ehci_omap(+) dwc3_omap snd_soc_ts3a225e leds_is31fl319x bq27xxx_battery_i2c tsc2007 bq27xxx_battery bq2429x_charger ina2xx tca8418_keypad as5013 leds_tca6507 twl6040_vibra gpio_twl6040 bmp085_i2c(+) palmas_gpadc usb3503 palmas_pwrbutton bmg160_i2c(+) bmp085 bma150(+) bmg160_core bmp280 input_polldev snd_soc_omap_mcbsp snd_soc_omap_mcpdm snd_soc_omap snd_pcm_dmaengine
    [    5.897048] Preemption disabled at:[<  (null)>]   (null)
    [    5.897051]
    [    5.897059] CPU: 0 PID: 994 Comm: udevd Not tainted 4.6.0-rc5-letux+ #233
    [    5.897062] Hardware name: Generic OMAP5 (Flattened Device Tree)
    [    5.897076] [<c010e714>] (unwind_backtrace) from [<c010af34>] (show_stack+0x10/0x14)
    [    5.897087] [<c010af34>] (show_stack) from [<c040aa7c>] (dump_stack+0x88/0xc0)
    [    5.897099] [<c040aa7c>] (dump_stack) from [<c020c558>] (__schedule_bug+0xac/0xd0)
    [    5.897111] [<c020c558>] (__schedule_bug) from [<c06f3d44>] (__schedule+0x88/0x7e4)
    [    5.897120] [<c06f3d44>] (__schedule) from [<c06f46d8>] (schedule+0x9c/0xc0)
    [    5.897129] [<c06f46d8>] (schedule) from [<c06f4904>] (schedule_preempt_disabled+0x14/0x20)
    [    5.897140] [<c06f4904>] (schedule_preempt_disabled) from [<c06f64e4>] (mutex_lock_nested+0x258/0x43c)
    [    5.897150] [<c06f64e4>] (mutex_lock_nested) from [<c05ce9c8>] (clk_prepare_lock+0x48/0xe0)
    [    5.897160] [<c05ce9c8>] (clk_prepare_lock) from [<c05d0e7c>] (clk_prepare+0x10/0x28)
    [    5.897169] [<c05d0e7c>] (clk_prepare) from [<c04c2668>] (omap_tll_enable+0x64/0xd0)
    [    5.897180] [<c04c2668>] (omap_tll_enable) from [<c04c1728>] (usbhs_runtime_resume+0x18/0x17c)
    [    5.897192] [<c04c1728>] (usbhs_runtime_resume) from [<c049d404>] (pm_generic_runtime_resume+0x2c/0x40)
    [    5.897202] [<c049d404>] (pm_generic_runtime_resume) from [<c049f180>] (__rpm_callback+0x38/0x68)
    [    5.897210] [<c049f180>] (__rpm_callback) from [<c049f220>] (rpm_callback+0x70/0x88)
    [    5.897218] [<c049f220>] (rpm_callback) from [<c04a0a00>] (rpm_resume+0x4ec/0x7ec)
    [    5.897227] [<c04a0a00>] (rpm_resume) from [<c04a0f48>] (__pm_runtime_resume+0x4c/0x64)
    [    5.897236] [<c04a0f48>] (__pm_runtime_resume) from [<c04958dc>] (driver_probe_device+0x30/0x70)
    [    5.897246] [<c04958dc>] (driver_probe_device) from [<c04959a4>] (__driver_attach+0x88/0xac)
    [    5.897256] [<c04959a4>] (__driver_attach) from [<c04940f8>] (bus_for_each_dev+0x50/0x84)
    [    5.897267] [<c04940f8>] (bus_for_each_dev) from [<c0494e40>] (bus_add_driver+0xcc/0x1e4)
    [    5.897276] [<c0494e40>] (bus_add_driver) from [<c0496914>] (driver_register+0xac/0xf4)
    [    5.897286] [<c0496914>] (driver_register) from [<c01018e0>] (do_one_initcall+0x100/0x1b8)
    [    5.897296] [<c01018e0>] (do_one_initcall) from [<c01c7a54>] (do_init_module+0x58/0x1c0)
    [    5.897304] [<c01c7a54>] (do_init_module) from [<c01c8a3c>] (SyS_finit_module+0x88/0x90)
    [    5.897313] [<c01c8a3c>] (SyS_finit_module) from [<c0107120>] (ret_fast_syscall+0x0/0x1c)
    [    5.912697] ------------[ cut here ]------------
    [    5.912711] WARNING: CPU: 0 PID: 994 at kernel/sched/core.c:2996 _raw_spin_unlock+0x28/0x58
    [    5.912717] DEBUG_LOCKS_WARN_ON(val > preempt_count())
    
    Cc: <stable@vger.kernel.org>
    Reported-by: H. Nikolaus Schaller <hns@goldelico.com>
    Tested-by: H. Nikolaus Schaller <hns@goldelico.com>
    Signed-off-by: Roger Quadros <rogerq@ti.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>
    Signed-off-by: Sasha Levin <sasha.levin@oracle.com>

commit 732468f790115d012dc18a505084aa53e38f4a40
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri May 20 23:09:49 2016 +0200

    PM / sleep: Handle failures in device_suspend_late() consistently
    
    [ Upstream commit 3a17fb329da68cb00558721aff876a80bba2fdb9 ]
    
    Grygorii Strashko reports:
    
     The PM runtime will be left disabled for the device if its
     .suspend_late() callback fails and async suspend is not allowed
     for this device. In this case device will not be added in
     dpm_late_early_list and dpm_resume_early() will ignore this
     device, as result PM runtime will be disabled for it forever
     (side effect: after 8 subsequent failures for the same device
     the PM runtime will be reenabled due to disable_depth overflow).
    
    To fix this problem, add devices to dpm_late_early_list regardless
    of whether or not device_suspend_late() returns errors for them.
    
    That will ensure failures in there to be handled consistently for
    all devices regardless of their async suspend/resume status.
    
    Reported-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Tested-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: All applicable <stable@vger.kernel.org>
    Signed-off-by: Sasha Levin <sasha.levin@oracle.com>

commit 0396e2a663bb74adec5b9bd21d141bf45433c478
Author: Roger Quadros <rogerq@ti.com>
Date:   Mon May 9 11:28:37 2016 +0300

    mfd: omap-usb-tll: Fix scheduling while atomic BUG
    
    [ Upstream commit b49b927f16acee626c56a1af4ab4cb062f75b5df ]
    
    We shouldn't be calling clk_prepare_enable()/clk_prepare_disable()
    in an atomic context.
    
    Fixes the following issue:
    
    [    5.830970] ehci-omap: OMAP-EHCI Host Controller driver
    [    5.830974] driver_register 'ehci-omap'
    [    5.895849] driver_register 'wl1271_sdio'
    [    5.896870] BUG: scheduling while atomic: udevd/994/0x00000002
    [    5.896876] 4 locks held by udevd/994:
    [    5.896904]  #0:  (&dev->mutex){......}, at: [<c049597c>] __driver_attach+0x60/0xac
    [    5.896923]  #1:  (&dev->mutex){......}, at: [<c049598c>] __driver_attach+0x70/0xac
    [    5.896946]  #2:  (tll_lock){+.+...}, at: [<c04c2630>] omap_tll_enable+0x2c/0xd0
    [    5.896966]  #3:  (prepare_lock){+.+...}, at: [<c05ce9c8>] clk_prepare_lock+0x48/0xe0
    [    5.897042] Modules linked in: wlcore_sdio(+) ehci_omap(+) dwc3_omap snd_soc_ts3a225e leds_is31fl319x bq27xxx_battery_i2c tsc2007 bq27xxx_battery bq2429x_charger ina2xx tca8418_keypad as5013 leds_tca6507 twl6040_vibra gpio_twl6040 bmp085_i2c(+) palmas_gpadc usb3503 palmas_pwrbutton bmg160_i2c(+) bmp085 bma150(+) bmg160_core bmp280 input_polldev snd_soc_omap_mcbsp snd_soc_omap_mcpdm snd_soc_omap snd_pcm_dmaengine
    [    5.897048] Preemption disabled at:[<  (null)>]   (null)
    [    5.897051]
    [    5.897059] CPU: 0 PID: 994 Comm: udevd Not tainted 4.6.0-rc5-letux+ #233
    [    5.897062] Hardware name: Generic OMAP5 (Flattened Device Tree)
    [    5.897076] [<c010e714>] (unwind_backtrace) from [<c010af34>] (show_stack+0x10/0x14)
    [    5.897087] [<c010af34>] (show_stack) from [<c040aa7c>] (dump_stack+0x88/0xc0)
    [    5.897099] [<c040aa7c>] (dump_stack) from [<c020c558>] (__schedule_bug+0xac/0xd0)
    [    5.897111] [<c020c558>] (__schedule_bug) from [<c06f3d44>] (__schedule+0x88/0x7e4)
    [    5.897120] [<c06f3d44>] (__schedule) from [<c06f46d8>] (schedule+0x9c/0xc0)
    [    5.897129] [<c06f46d8>] (schedule) from [<c06f4904>] (schedule_preempt_disabled+0x14/0x20)
    [    5.897140] [<c06f4904>] (schedule_preempt_disabled) from [<c06f64e4>] (mutex_lock_nested+0x258/0x43c)
    [    5.897150] [<c06f64e4>] (mutex_lock_nested) from [<c05ce9c8>] (clk_prepare_lock+0x48/0xe0)
    [    5.897160] [<c05ce9c8>] (clk_prepare_lock) from [<c05d0e7c>] (clk_prepare+0x10/0x28)
    [    5.897169] [<c05d0e7c>] (clk_prepare) from [<c04c2668>] (omap_tll_enable+0x64/0xd0)
    [    5.897180] [<c04c2668>] (omap_tll_enable) from [<c04c1728>] (usbhs_runtime_resume+0x18/0x17c)
    [    5.897192] [<c04c1728>] (usbhs_runtime_resume) from [<c049d404>] (pm_generic_runtime_resume+0x2c/0x40)
    [    5.897202] [<c049d404>] (pm_generic_runtime_resume) from [<c049f180>] (__rpm_callback+0x38/0x68)
    [    5.897210] [<c049f180>] (__rpm_callback) from [<c049f220>] (rpm_callback+0x70/0x88)
    [    5.897218] [<c049f220>] (rpm_callback) from [<c04a0a00>] (rpm_resume+0x4ec/0x7ec)
    [    5.897227] [<c04a0a00>] (rpm_resume) from [<c04a0f48>] (__pm_runtime_resume+0x4c/0x64)
    [    5.897236] [<c04a0f48>] (__pm_runtime_resume) from [<c04958dc>] (driver_probe_device+0x30/0x70)
    [    5.897246] [<c04958dc>] (driver_probe_device) from [<c04959a4>] (__driver_attach+0x88/0xac)
    [    5.897256] [<c04959a4>] (__driver_attach) from [<c04940f8>] (bus_for_each_dev+0x50/0x84)
    [    5.897267] [<c04940f8>] (bus_for_each_dev) from [<c0494e40>] (bus_add_driver+0xcc/0x1e4)
    [    5.897276] [<c0494e40>] (bus_add_driver) from [<c0496914>] (driver_register+0xac/0xf4)
    [    5.897286] [<c0496914>] (driver_register) from [<c01018e0>] (do_one_initcall+0x100/0x1b8)
    [    5.897296] [<c01018e0>] (do_one_initcall) from [<c01c7a54>] (do_init_module+0x58/0x1c0)
    [    5.897304] [<c01c7a54>] (do_init_module) from [<c01c8a3c>] (SyS_finit_module+0x88/0x90)
    [    5.897313] [<c01c8a3c>] (SyS_finit_module) from [<c0107120>] (ret_fast_syscall+0x0/0x1c)
    [    5.912697] ------------[ cut here ]------------
    [    5.912711] WARNING: CPU: 0 PID: 994 at kernel/sched/core.c:2996 _raw_spin_unlock+0x28/0x58
    [    5.912717] DEBUG_LOCKS_WARN_ON(val > preempt_count())
    
    Cc: <stable@vger.kernel.org>
    Reported-by: H. Nikolaus Schaller <hns@goldelico.com>
    Tested-by: H. Nikolaus Schaller <hns@goldelico.com>
    Signed-off-by: Roger Quadros <rogerq@ti.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>
    Signed-off-by: Sasha Levin <sasha.levin@oracle.com>

commit 84ac5d1140f716a616522f952734e850448d2556
Author: Bin Liu <b-liu@ti.com>
Date:   Tue May 31 10:05:24 2016 -0500

    usb: musb: only restore devctl when session was set in backup
    
    If the session bit was not set in the backup of devctl register,
    restoring devctl would clear the session bit. Therefor, only restore
    devctl register when the session bit was set in the backup.
    
    This solves the device enumeration failure in otg mode exposed by commit
    56f487c (PM / Runtime: Update last_busy in rpm_resume).
    
    Cc: <stable@vger.kernel.org> # v4.2+
    Signed-off-by: Bin Liu <b-liu@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 8936cc80881638dbd5692bae55eda6d23b7bf36e
Author: Roger Quadros <rogerq@ti.com>
Date:   Mon May 9 11:28:37 2016 +0300

    mfd: omap-usb-tll: Fix scheduling while atomic BUG
    
    commit b49b927f16acee626c56a1af4ab4cb062f75b5df upstream.
    
    We shouldn't be calling clk_prepare_enable()/clk_prepare_disable()
    in an atomic context.
    
    Fixes the following issue:
    
    [    5.830970] ehci-omap: OMAP-EHCI Host Controller driver
    [    5.830974] driver_register 'ehci-omap'
    [    5.895849] driver_register 'wl1271_sdio'
    [    5.896870] BUG: scheduling while atomic: udevd/994/0x00000002
    [    5.896876] 4 locks held by udevd/994:
    [    5.896904]  #0:  (&dev->mutex){......}, at: [<c049597c>] __driver_attach+0x60/0xac
    [    5.896923]  #1:  (&dev->mutex){......}, at: [<c049598c>] __driver_attach+0x70/0xac
    [    5.896946]  #2:  (tll_lock){+.+...}, at: [<c04c2630>] omap_tll_enable+0x2c/0xd0
    [    5.896966]  #3:  (prepare_lock){+.+...}, at: [<c05ce9c8>] clk_prepare_lock+0x48/0xe0
    [    5.897042] Modules linked in: wlcore_sdio(+) ehci_omap(+) dwc3_omap snd_soc_ts3a225e leds_is31fl319x bq27xxx_battery_i2c tsc2007 bq27xxx_battery bq2429x_charger ina2xx tca8418_keypad as5013 leds_tca6507 twl6040_vibra gpio_twl6040 bmp085_i2c(+) palmas_gpadc usb3503 palmas_pwrbutton bmg160_i2c(+) bmp085 bma150(+) bmg160_core bmp280 input_polldev snd_soc_omap_mcbsp snd_soc_omap_mcpdm snd_soc_omap snd_pcm_dmaengine
    [    5.897048] Preemption disabled at:[<  (null)>]   (null)
    [    5.897051]
    [    5.897059] CPU: 0 PID: 994 Comm: udevd Not tainted 4.6.0-rc5-letux+ #233
    [    5.897062] Hardware name: Generic OMAP5 (Flattened Device Tree)
    [    5.897076] [<c010e714>] (unwind_backtrace) from [<c010af34>] (show_stack+0x10/0x14)
    [    5.897087] [<c010af34>] (show_stack) from [<c040aa7c>] (dump_stack+0x88/0xc0)
    [    5.897099] [<c040aa7c>] (dump_stack) from [<c020c558>] (__schedule_bug+0xac/0xd0)
    [    5.897111] [<c020c558>] (__schedule_bug) from [<c06f3d44>] (__schedule+0x88/0x7e4)
    [    5.897120] [<c06f3d44>] (__schedule) from [<c06f46d8>] (schedule+0x9c/0xc0)
    [    5.897129] [<c06f46d8>] (schedule) from [<c06f4904>] (schedule_preempt_disabled+0x14/0x20)
    [    5.897140] [<c06f4904>] (schedule_preempt_disabled) from [<c06f64e4>] (mutex_lock_nested+0x258/0x43c)
    [    5.897150] [<c06f64e4>] (mutex_lock_nested) from [<c05ce9c8>] (clk_prepare_lock+0x48/0xe0)
    [    5.897160] [<c05ce9c8>] (clk_prepare_lock) from [<c05d0e7c>] (clk_prepare+0x10/0x28)
    [    5.897169] [<c05d0e7c>] (clk_prepare) from [<c04c2668>] (omap_tll_enable+0x64/0xd0)
    [    5.897180] [<c04c2668>] (omap_tll_enable) from [<c04c1728>] (usbhs_runtime_resume+0x18/0x17c)
    [    5.897192] [<c04c1728>] (usbhs_runtime_resume) from [<c049d404>] (pm_generic_runtime_resume+0x2c/0x40)
    [    5.897202] [<c049d404>] (pm_generic_runtime_resume) from [<c049f180>] (__rpm_callback+0x38/0x68)
    [    5.897210] [<c049f180>] (__rpm_callback) from [<c049f220>] (rpm_callback+0x70/0x88)
    [    5.897218] [<c049f220>] (rpm_callback) from [<c04a0a00>] (rpm_resume+0x4ec/0x7ec)
    [    5.897227] [<c04a0a00>] (rpm_resume) from [<c04a0f48>] (__pm_runtime_resume+0x4c/0x64)
    [    5.897236] [<c04a0f48>] (__pm_runtime_resume) from [<c04958dc>] (driver_probe_device+0x30/0x70)
    [    5.897246] [<c04958dc>] (driver_probe_device) from [<c04959a4>] (__driver_attach+0x88/0xac)
    [    5.897256] [<c04959a4>] (__driver_attach) from [<c04940f8>] (bus_for_each_dev+0x50/0x84)
    [    5.897267] [<c04940f8>] (bus_for_each_dev) from [<c0494e40>] (bus_add_driver+0xcc/0x1e4)
    [    5.897276] [<c0494e40>] (bus_add_driver) from [<c0496914>] (driver_register+0xac/0xf4)
    [    5.897286] [<c0496914>] (driver_register) from [<c01018e0>] (do_one_initcall+0x100/0x1b8)
    [    5.897296] [<c01018e0>] (do_one_initcall) from [<c01c7a54>] (do_init_module+0x58/0x1c0)
    [    5.897304] [<c01c7a54>] (do_init_module) from [<c01c8a3c>] (SyS_finit_module+0x88/0x90)
    [    5.897313] [<c01c8a3c>] (SyS_finit_module) from [<c0107120>] (ret_fast_syscall+0x0/0x1c)
    [    5.912697] ------------[ cut here ]------------
    [    5.912711] WARNING: CPU: 0 PID: 994 at kernel/sched/core.c:2996 _raw_spin_unlock+0x28/0x58
    [    5.912717] DEBUG_LOCKS_WARN_ON(val > preempt_count())
    
    Reported-by: H. Nikolaus Schaller <hns@goldelico.com>
    Tested-by: H. Nikolaus Schaller <hns@goldelico.com>
    Signed-off-by: Roger Quadros <rogerq@ti.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 0f25db7acd51c5889de7bf0f09d1884461214179
Author: Roger Quadros <rogerq@ti.com>
Date:   Mon May 9 11:28:37 2016 +0300

    mfd: omap-usb-tll: Fix scheduling while atomic BUG
    
    commit b49b927f16acee626c56a1af4ab4cb062f75b5df upstream.
    
    We shouldn't be calling clk_prepare_enable()/clk_prepare_disable()
    in an atomic context.
    
    Fixes the following issue:
    
    [    5.830970] ehci-omap: OMAP-EHCI Host Controller driver
    [    5.830974] driver_register 'ehci-omap'
    [    5.895849] driver_register 'wl1271_sdio'
    [    5.896870] BUG: scheduling while atomic: udevd/994/0x00000002
    [    5.896876] 4 locks held by udevd/994:
    [    5.896904]  #0:  (&dev->mutex){......}, at: [<c049597c>] __driver_attach+0x60/0xac
    [    5.896923]  #1:  (&dev->mutex){......}, at: [<c049598c>] __driver_attach+0x70/0xac
    [    5.896946]  #2:  (tll_lock){+.+...}, at: [<c04c2630>] omap_tll_enable+0x2c/0xd0
    [    5.896966]  #3:  (prepare_lock){+.+...}, at: [<c05ce9c8>] clk_prepare_lock+0x48/0xe0
    [    5.897042] Modules linked in: wlcore_sdio(+) ehci_omap(+) dwc3_omap snd_soc_ts3a225e leds_is31fl319x bq27xxx_battery_i2c tsc2007 bq27xxx_battery bq2429x_charger ina2xx tca8418_keypad as5013 leds_tca6507 twl6040_vibra gpio_twl6040 bmp085_i2c(+) palmas_gpadc usb3503 palmas_pwrbutton bmg160_i2c(+) bmp085 bma150(+) bmg160_core bmp280 input_polldev snd_soc_omap_mcbsp snd_soc_omap_mcpdm snd_soc_omap snd_pcm_dmaengine
    [    5.897048] Preemption disabled at:[<  (null)>]   (null)
    [    5.897051]
    [    5.897059] CPU: 0 PID: 994 Comm: udevd Not tainted 4.6.0-rc5-letux+ #233
    [    5.897062] Hardware name: Generic OMAP5 (Flattened Device Tree)
    [    5.897076] [<c010e714>] (unwind_backtrace) from [<c010af34>] (show_stack+0x10/0x14)
    [    5.897087] [<c010af34>] (show_stack) from [<c040aa7c>] (dump_stack+0x88/0xc0)
    [    5.897099] [<c040aa7c>] (dump_stack) from [<c020c558>] (__schedule_bug+0xac/0xd0)
    [    5.897111] [<c020c558>] (__schedule_bug) from [<c06f3d44>] (__schedule+0x88/0x7e4)
    [    5.897120] [<c06f3d44>] (__schedule) from [<c06f46d8>] (schedule+0x9c/0xc0)
    [    5.897129] [<c06f46d8>] (schedule) from [<c06f4904>] (schedule_preempt_disabled+0x14/0x20)
    [    5.897140] [<c06f4904>] (schedule_preempt_disabled) from [<c06f64e4>] (mutex_lock_nested+0x258/0x43c)
    [    5.897150] [<c06f64e4>] (mutex_lock_nested) from [<c05ce9c8>] (clk_prepare_lock+0x48/0xe0)
    [    5.897160] [<c05ce9c8>] (clk_prepare_lock) from [<c05d0e7c>] (clk_prepare+0x10/0x28)
    [    5.897169] [<c05d0e7c>] (clk_prepare) from [<c04c2668>] (omap_tll_enable+0x64/0xd0)
    [    5.897180] [<c04c2668>] (omap_tll_enable) from [<c04c1728>] (usbhs_runtime_resume+0x18/0x17c)
    [    5.897192] [<c04c1728>] (usbhs_runtime_resume) from [<c049d404>] (pm_generic_runtime_resume+0x2c/0x40)
    [    5.897202] [<c049d404>] (pm_generic_runtime_resume) from [<c049f180>] (__rpm_callback+0x38/0x68)
    [    5.897210] [<c049f180>] (__rpm_callback) from [<c049f220>] (rpm_callback+0x70/0x88)
    [    5.897218] [<c049f220>] (rpm_callback) from [<c04a0a00>] (rpm_resume+0x4ec/0x7ec)
    [    5.897227] [<c04a0a00>] (rpm_resume) from [<c04a0f48>] (__pm_runtime_resume+0x4c/0x64)
    [    5.897236] [<c04a0f48>] (__pm_runtime_resume) from [<c04958dc>] (driver_probe_device+0x30/0x70)
    [    5.897246] [<c04958dc>] (driver_probe_device) from [<c04959a4>] (__driver_attach+0x88/0xac)
    [    5.897256] [<c04959a4>] (__driver_attach) from [<c04940f8>] (bus_for_each_dev+0x50/0x84)
    [    5.897267] [<c04940f8>] (bus_for_each_dev) from [<c0494e40>] (bus_add_driver+0xcc/0x1e4)
    [    5.897276] [<c0494e40>] (bus_add_driver) from [<c0496914>] (driver_register+0xac/0xf4)
    [    5.897286] [<c0496914>] (driver_register) from [<c01018e0>] (do_one_initcall+0x100/0x1b8)
    [    5.897296] [<c01018e0>] (do_one_initcall) from [<c01c7a54>] (do_init_module+0x58/0x1c0)
    [    5.897304] [<c01c7a54>] (do_init_module) from [<c01c8a3c>] (SyS_finit_module+0x88/0x90)
    [    5.897313] [<c01c8a3c>] (SyS_finit_module) from [<c0107120>] (ret_fast_syscall+0x0/0x1c)
    [    5.912697] ------------[ cut here ]------------
    [    5.912711] WARNING: CPU: 0 PID: 994 at kernel/sched/core.c:2996 _raw_spin_unlock+0x28/0x58
    [    5.912717] DEBUG_LOCKS_WARN_ON(val > preempt_count())
    
    Reported-by: H. Nikolaus Schaller <hns@goldelico.com>
    Tested-by: H. Nikolaus Schaller <hns@goldelico.com>
    Signed-off-by: Roger Quadros <rogerq@ti.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit c5215990d6ce401cefca648bff578a0a33667f75
Author: Roger Quadros <rogerq@ti.com>
Date:   Mon May 9 11:28:37 2016 +0300

    mfd: omap-usb-tll: Fix scheduling while atomic BUG
    
    commit b49b927f16acee626c56a1af4ab4cb062f75b5df upstream.
    
    We shouldn't be calling clk_prepare_enable()/clk_prepare_disable()
    in an atomic context.
    
    Fixes the following issue:
    
    [    5.830970] ehci-omap: OMAP-EHCI Host Controller driver
    [    5.830974] driver_register 'ehci-omap'
    [    5.895849] driver_register 'wl1271_sdio'
    [    5.896870] BUG: scheduling while atomic: udevd/994/0x00000002
    [    5.896876] 4 locks held by udevd/994:
    [    5.896904]  #0:  (&dev->mutex){......}, at: [<c049597c>] __driver_attach+0x60/0xac
    [    5.896923]  #1:  (&dev->mutex){......}, at: [<c049598c>] __driver_attach+0x70/0xac
    [    5.896946]  #2:  (tll_lock){+.+...}, at: [<c04c2630>] omap_tll_enable+0x2c/0xd0
    [    5.896966]  #3:  (prepare_lock){+.+...}, at: [<c05ce9c8>] clk_prepare_lock+0x48/0xe0
    [    5.897042] Modules linked in: wlcore_sdio(+) ehci_omap(+) dwc3_omap snd_soc_ts3a225e leds_is31fl319x bq27xxx_battery_i2c tsc2007 bq27xxx_battery bq2429x_charger ina2xx tca8418_keypad as5013 leds_tca6507 twl6040_vibra gpio_twl6040 bmp085_i2c(+) palmas_gpadc usb3503 palmas_pwrbutton bmg160_i2c(+) bmp085 bma150(+) bmg160_core bmp280 input_polldev snd_soc_omap_mcbsp snd_soc_omap_mcpdm snd_soc_omap snd_pcm_dmaengine
    [    5.897048] Preemption disabled at:[<  (null)>]   (null)
    [    5.897051]
    [    5.897059] CPU: 0 PID: 994 Comm: udevd Not tainted 4.6.0-rc5-letux+ #233
    [    5.897062] Hardware name: Generic OMAP5 (Flattened Device Tree)
    [    5.897076] [<c010e714>] (unwind_backtrace) from [<c010af34>] (show_stack+0x10/0x14)
    [    5.897087] [<c010af34>] (show_stack) from [<c040aa7c>] (dump_stack+0x88/0xc0)
    [    5.897099] [<c040aa7c>] (dump_stack) from [<c020c558>] (__schedule_bug+0xac/0xd0)
    [    5.897111] [<c020c558>] (__schedule_bug) from [<c06f3d44>] (__schedule+0x88/0x7e4)
    [    5.897120] [<c06f3d44>] (__schedule) from [<c06f46d8>] (schedule+0x9c/0xc0)
    [    5.897129] [<c06f46d8>] (schedule) from [<c06f4904>] (schedule_preempt_disabled+0x14/0x20)
    [    5.897140] [<c06f4904>] (schedule_preempt_disabled) from [<c06f64e4>] (mutex_lock_nested+0x258/0x43c)
    [    5.897150] [<c06f64e4>] (mutex_lock_nested) from [<c05ce9c8>] (clk_prepare_lock+0x48/0xe0)
    [    5.897160] [<c05ce9c8>] (clk_prepare_lock) from [<c05d0e7c>] (clk_prepare+0x10/0x28)
    [    5.897169] [<c05d0e7c>] (clk_prepare) from [<c04c2668>] (omap_tll_enable+0x64/0xd0)
    [    5.897180] [<c04c2668>] (omap_tll_enable) from [<c04c1728>] (usbhs_runtime_resume+0x18/0x17c)
    [    5.897192] [<c04c1728>] (usbhs_runtime_resume) from [<c049d404>] (pm_generic_runtime_resume+0x2c/0x40)
    [    5.897202] [<c049d404>] (pm_generic_runtime_resume) from [<c049f180>] (__rpm_callback+0x38/0x68)
    [    5.897210] [<c049f180>] (__rpm_callback) from [<c049f220>] (rpm_callback+0x70/0x88)
    [    5.897218] [<c049f220>] (rpm_callback) from [<c04a0a00>] (rpm_resume+0x4ec/0x7ec)
    [    5.897227] [<c04a0a00>] (rpm_resume) from [<c04a0f48>] (__pm_runtime_resume+0x4c/0x64)
    [    5.897236] [<c04a0f48>] (__pm_runtime_resume) from [<c04958dc>] (driver_probe_device+0x30/0x70)
    [    5.897246] [<c04958dc>] (driver_probe_device) from [<c04959a4>] (__driver_attach+0x88/0xac)
    [    5.897256] [<c04959a4>] (__driver_attach) from [<c04940f8>] (bus_for_each_dev+0x50/0x84)
    [    5.897267] [<c04940f8>] (bus_for_each_dev) from [<c0494e40>] (bus_add_driver+0xcc/0x1e4)
    [    5.897276] [<c0494e40>] (bus_add_driver) from [<c0496914>] (driver_register+0xac/0xf4)
    [    5.897286] [<c0496914>] (driver_register) from [<c01018e0>] (do_one_initcall+0x100/0x1b8)
    [    5.897296] [<c01018e0>] (do_one_initcall) from [<c01c7a54>] (do_init_module+0x58/0x1c0)
    [    5.897304] [<c01c7a54>] (do_init_module) from [<c01c8a3c>] (SyS_finit_module+0x88/0x90)
    [    5.897313] [<c01c8a3c>] (SyS_finit_module) from [<c0107120>] (ret_fast_syscall+0x0/0x1c)
    [    5.912697] ------------[ cut here ]------------
    [    5.912711] WARNING: CPU: 0 PID: 994 at kernel/sched/core.c:2996 _raw_spin_unlock+0x28/0x58
    [    5.912717] DEBUG_LOCKS_WARN_ON(val > preempt_count())
    
    Reported-by: H. Nikolaus Schaller <hns@goldelico.com>
    Tested-by: H. Nikolaus Schaller <hns@goldelico.com>
    Signed-off-by: Roger Quadros <rogerq@ti.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit a4b1b00865e759ff4fa4297a438b9bada67b691e
Author: Roger Quadros <rogerq@ti.com>
Date:   Mon May 9 11:28:37 2016 +0300

    mfd: omap-usb-tll: Fix scheduling while atomic BUG
    
    commit b49b927f16acee626c56a1af4ab4cb062f75b5df upstream.
    
    We shouldn't be calling clk_prepare_enable()/clk_prepare_disable()
    in an atomic context.
    
    Fixes the following issue:
    
    [    5.830970] ehci-omap: OMAP-EHCI Host Controller driver
    [    5.830974] driver_register 'ehci-omap'
    [    5.895849] driver_register 'wl1271_sdio'
    [    5.896870] BUG: scheduling while atomic: udevd/994/0x00000002
    [    5.896876] 4 locks held by udevd/994:
    [    5.896904]  #0:  (&dev->mutex){......}, at: [<c049597c>] __driver_attach+0x60/0xac
    [    5.896923]  #1:  (&dev->mutex){......}, at: [<c049598c>] __driver_attach+0x70/0xac
    [    5.896946]  #2:  (tll_lock){+.+...}, at: [<c04c2630>] omap_tll_enable+0x2c/0xd0
    [    5.896966]  #3:  (prepare_lock){+.+...}, at: [<c05ce9c8>] clk_prepare_lock+0x48/0xe0
    [    5.897042] Modules linked in: wlcore_sdio(+) ehci_omap(+) dwc3_omap snd_soc_ts3a225e leds_is31fl319x bq27xxx_battery_i2c tsc2007 bq27xxx_battery bq2429x_charger ina2xx tca8418_keypad as5013 leds_tca6507 twl6040_vibra gpio_twl6040 bmp085_i2c(+) palmas_gpadc usb3503 palmas_pwrbutton bmg160_i2c(+) bmp085 bma150(+) bmg160_core bmp280 input_polldev snd_soc_omap_mcbsp snd_soc_omap_mcpdm snd_soc_omap snd_pcm_dmaengine
    [    5.897048] Preemption disabled at:[<  (null)>]   (null)
    [    5.897051]
    [    5.897059] CPU: 0 PID: 994 Comm: udevd Not tainted 4.6.0-rc5-letux+ #233
    [    5.897062] Hardware name: Generic OMAP5 (Flattened Device Tree)
    [    5.897076] [<c010e714>] (unwind_backtrace) from [<c010af34>] (show_stack+0x10/0x14)
    [    5.897087] [<c010af34>] (show_stack) from [<c040aa7c>] (dump_stack+0x88/0xc0)
    [    5.897099] [<c040aa7c>] (dump_stack) from [<c020c558>] (__schedule_bug+0xac/0xd0)
    [    5.897111] [<c020c558>] (__schedule_bug) from [<c06f3d44>] (__schedule+0x88/0x7e4)
    [    5.897120] [<c06f3d44>] (__schedule) from [<c06f46d8>] (schedule+0x9c/0xc0)
    [    5.897129] [<c06f46d8>] (schedule) from [<c06f4904>] (schedule_preempt_disabled+0x14/0x20)
    [    5.897140] [<c06f4904>] (schedule_preempt_disabled) from [<c06f64e4>] (mutex_lock_nested+0x258/0x43c)
    [    5.897150] [<c06f64e4>] (mutex_lock_nested) from [<c05ce9c8>] (clk_prepare_lock+0x48/0xe0)
    [    5.897160] [<c05ce9c8>] (clk_prepare_lock) from [<c05d0e7c>] (clk_prepare+0x10/0x28)
    [    5.897169] [<c05d0e7c>] (clk_prepare) from [<c04c2668>] (omap_tll_enable+0x64/0xd0)
    [    5.897180] [<c04c2668>] (omap_tll_enable) from [<c04c1728>] (usbhs_runtime_resume+0x18/0x17c)
    [    5.897192] [<c04c1728>] (usbhs_runtime_resume) from [<c049d404>] (pm_generic_runtime_resume+0x2c/0x40)
    [    5.897202] [<c049d404>] (pm_generic_runtime_resume) from [<c049f180>] (__rpm_callback+0x38/0x68)
    [    5.897210] [<c049f180>] (__rpm_callback) from [<c049f220>] (rpm_callback+0x70/0x88)
    [    5.897218] [<c049f220>] (rpm_callback) from [<c04a0a00>] (rpm_resume+0x4ec/0x7ec)
    [    5.897227] [<c04a0a00>] (rpm_resume) from [<c04a0f48>] (__pm_runtime_resume+0x4c/0x64)
    [    5.897236] [<c04a0f48>] (__pm_runtime_resume) from [<c04958dc>] (driver_probe_device+0x30/0x70)
    [    5.897246] [<c04958dc>] (driver_probe_device) from [<c04959a4>] (__driver_attach+0x88/0xac)
    [    5.897256] [<c04959a4>] (__driver_attach) from [<c04940f8>] (bus_for_each_dev+0x50/0x84)
    [    5.897267] [<c04940f8>] (bus_for_each_dev) from [<c0494e40>] (bus_add_driver+0xcc/0x1e4)
    [    5.897276] [<c0494e40>] (bus_add_driver) from [<c0496914>] (driver_register+0xac/0xf4)
    [    5.897286] [<c0496914>] (driver_register) from [<c01018e0>] (do_one_initcall+0x100/0x1b8)
    [    5.897296] [<c01018e0>] (do_one_initcall) from [<c01c7a54>] (do_init_module+0x58/0x1c0)
    [    5.897304] [<c01c7a54>] (do_init_module) from [<c01c8a3c>] (SyS_finit_module+0x88/0x90)
    [    5.897313] [<c01c8a3c>] (SyS_finit_module) from [<c0107120>] (ret_fast_syscall+0x0/0x1c)
    [    5.912697] ------------[ cut here ]------------
    [    5.912711] WARNING: CPU: 0 PID: 994 at kernel/sched/core.c:2996 _raw_spin_unlock+0x28/0x58
    [    5.912717] DEBUG_LOCKS_WARN_ON(val > preempt_count())
    
    Reported-by: H. Nikolaus Schaller <hns@goldelico.com>
    Tested-by: H. Nikolaus Schaller <hns@goldelico.com>
    Signed-off-by: Roger Quadros <rogerq@ti.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 3a17fb329da68cb00558721aff876a80bba2fdb9
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri May 20 23:09:49 2016 +0200

    PM / sleep: Handle failures in device_suspend_late() consistently
    
    Grygorii Strashko reports:
    
     The PM runtime will be left disabled for the device if its
     .suspend_late() callback fails and async suspend is not allowed
     for this device. In this case device will not be added in
     dpm_late_early_list and dpm_resume_early() will ignore this
     device, as result PM runtime will be disabled for it forever
     (side effect: after 8 subsequent failures for the same device
     the PM runtime will be reenabled due to disable_depth overflow).
    
    To fix this problem, add devices to dpm_late_early_list regardless
    of whether or not device_suspend_late() returns errors for them.
    
    That will ensure failures in there to be handled consistently for
    all devices regardless of their async suspend/resume status.
    
    Reported-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Tested-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: All applicable <stable@vger.kernel.org>

commit b49b927f16acee626c56a1af4ab4cb062f75b5df
Author: Roger Quadros <rogerq@ti.com>
Date:   Mon May 9 11:28:37 2016 +0300

    mfd: omap-usb-tll: Fix scheduling while atomic BUG
    
    We shouldn't be calling clk_prepare_enable()/clk_prepare_disable()
    in an atomic context.
    
    Fixes the following issue:
    
    [    5.830970] ehci-omap: OMAP-EHCI Host Controller driver
    [    5.830974] driver_register 'ehci-omap'
    [    5.895849] driver_register 'wl1271_sdio'
    [    5.896870] BUG: scheduling while atomic: udevd/994/0x00000002
    [    5.896876] 4 locks held by udevd/994:
    [    5.896904]  #0:  (&dev->mutex){......}, at: [<c049597c>] __driver_attach+0x60/0xac
    [    5.896923]  #1:  (&dev->mutex){......}, at: [<c049598c>] __driver_attach+0x70/0xac
    [    5.896946]  #2:  (tll_lock){+.+...}, at: [<c04c2630>] omap_tll_enable+0x2c/0xd0
    [    5.896966]  #3:  (prepare_lock){+.+...}, at: [<c05ce9c8>] clk_prepare_lock+0x48/0xe0
    [    5.897042] Modules linked in: wlcore_sdio(+) ehci_omap(+) dwc3_omap snd_soc_ts3a225e leds_is31fl319x bq27xxx_battery_i2c tsc2007 bq27xxx_battery bq2429x_charger ina2xx tca8418_keypad as5013 leds_tca6507 twl6040_vibra gpio_twl6040 bmp085_i2c(+) palmas_gpadc usb3503 palmas_pwrbutton bmg160_i2c(+) bmp085 bma150(+) bmg160_core bmp280 input_polldev snd_soc_omap_mcbsp snd_soc_omap_mcpdm snd_soc_omap snd_pcm_dmaengine
    [    5.897048] Preemption disabled at:[<  (null)>]   (null)
    [    5.897051]
    [    5.897059] CPU: 0 PID: 994 Comm: udevd Not tainted 4.6.0-rc5-letux+ #233
    [    5.897062] Hardware name: Generic OMAP5 (Flattened Device Tree)
    [    5.897076] [<c010e714>] (unwind_backtrace) from [<c010af34>] (show_stack+0x10/0x14)
    [    5.897087] [<c010af34>] (show_stack) from [<c040aa7c>] (dump_stack+0x88/0xc0)
    [    5.897099] [<c040aa7c>] (dump_stack) from [<c020c558>] (__schedule_bug+0xac/0xd0)
    [    5.897111] [<c020c558>] (__schedule_bug) from [<c06f3d44>] (__schedule+0x88/0x7e4)
    [    5.897120] [<c06f3d44>] (__schedule) from [<c06f46d8>] (schedule+0x9c/0xc0)
    [    5.897129] [<c06f46d8>] (schedule) from [<c06f4904>] (schedule_preempt_disabled+0x14/0x20)
    [    5.897140] [<c06f4904>] (schedule_preempt_disabled) from [<c06f64e4>] (mutex_lock_nested+0x258/0x43c)
    [    5.897150] [<c06f64e4>] (mutex_lock_nested) from [<c05ce9c8>] (clk_prepare_lock+0x48/0xe0)
    [    5.897160] [<c05ce9c8>] (clk_prepare_lock) from [<c05d0e7c>] (clk_prepare+0x10/0x28)
    [    5.897169] [<c05d0e7c>] (clk_prepare) from [<c04c2668>] (omap_tll_enable+0x64/0xd0)
    [    5.897180] [<c04c2668>] (omap_tll_enable) from [<c04c1728>] (usbhs_runtime_resume+0x18/0x17c)
    [    5.897192] [<c04c1728>] (usbhs_runtime_resume) from [<c049d404>] (pm_generic_runtime_resume+0x2c/0x40)
    [    5.897202] [<c049d404>] (pm_generic_runtime_resume) from [<c049f180>] (__rpm_callback+0x38/0x68)
    [    5.897210] [<c049f180>] (__rpm_callback) from [<c049f220>] (rpm_callback+0x70/0x88)
    [    5.897218] [<c049f220>] (rpm_callback) from [<c04a0a00>] (rpm_resume+0x4ec/0x7ec)
    [    5.897227] [<c04a0a00>] (rpm_resume) from [<c04a0f48>] (__pm_runtime_resume+0x4c/0x64)
    [    5.897236] [<c04a0f48>] (__pm_runtime_resume) from [<c04958dc>] (driver_probe_device+0x30/0x70)
    [    5.897246] [<c04958dc>] (driver_probe_device) from [<c04959a4>] (__driver_attach+0x88/0xac)
    [    5.897256] [<c04959a4>] (__driver_attach) from [<c04940f8>] (bus_for_each_dev+0x50/0x84)
    [    5.897267] [<c04940f8>] (bus_for_each_dev) from [<c0494e40>] (bus_add_driver+0xcc/0x1e4)
    [    5.897276] [<c0494e40>] (bus_add_driver) from [<c0496914>] (driver_register+0xac/0xf4)
    [    5.897286] [<c0496914>] (driver_register) from [<c01018e0>] (do_one_initcall+0x100/0x1b8)
    [    5.897296] [<c01018e0>] (do_one_initcall) from [<c01c7a54>] (do_init_module+0x58/0x1c0)
    [    5.897304] [<c01c7a54>] (do_init_module) from [<c01c8a3c>] (SyS_finit_module+0x88/0x90)
    [    5.897313] [<c01c8a3c>] (SyS_finit_module) from [<c0107120>] (ret_fast_syscall+0x0/0x1c)
    [    5.912697] ------------[ cut here ]------------
    [    5.912711] WARNING: CPU: 0 PID: 994 at kernel/sched/core.c:2996 _raw_spin_unlock+0x28/0x58
    [    5.912717] DEBUG_LOCKS_WARN_ON(val > preempt_count())
    
    Cc: <stable@vger.kernel.org>
    Reported-by: H. Nikolaus Schaller <hns@goldelico.com>
    Tested-by: H. Nikolaus Schaller <hns@goldelico.com>
    Signed-off-by: Roger Quadros <rogerq@ti.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

commit 46d75c0b7432a53014055044fa06c0c77bf0a5b2
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Tue Mar 29 12:45:43 2016 +0300

    mmc: sdhci: Fix regression setting power on Trats2 board
    
    commit 1dceb0415aa0c6bc11dacdab47c9ef83a3604166 upstream.
    
    Several commits relating to setting power have been introducing
    problems by putting driver-specific rules into generic SDHCI code.
    
    Krzysztof Kozlowski reported that after commit 918f4cbd4340 ("mmc:
    sdhci: restore behavior when setting VDD via external regulator")
    on Trats2 board there are warnings for invalid VDD  value (2.8V):
    
    [    3.119656] ------------[ cut here ]------------
    [    3.119666] WARNING: CPU: 3 PID: 90 at
    ../drivers/mmc/host/sdhci.c:1234 sdhci_do_set_ios+0x4cc/0x5e0
    [    3.119669] mmc0: Invalid vdd 0x10
    [    3.119673] Modules linked in:
    [    3.119679] CPU: 3 PID: 90 Comm: kworker/3:1 Tainted: G        W
       4.5.0-next-20160324 #23
    [    3.119681] Hardware name: SAMSUNG EXYNOS (Flattened Device Tree)
    [    3.119690] Workqueue: events_freezable mmc_rescan
    [    3.119708] [<c010e0ac>] (unwind_backtrace) from [<c010ae10>]
    (show_stack+0x10/0x14)
    [    3.119719] [<c010ae10>] (show_stack) from [<c0323260>]
    (dump_stack+0x88/0x9c)
    [    3.119728] [<c0323260>] (dump_stack) from [<c011b754>] (__warn+0xe8/0x100)
    [    3.119734] [<c011b754>] (__warn) from [<c011b7a4>]
    (warn_slowpath_fmt+0x38/0x48)
    [    3.119740] [<c011b7a4>] (warn_slowpath_fmt) from [<c0527d28>]
    (sdhci_do_set_ios+0x4cc/0x5e0)
    [    3.119748] [<c0527d28>] (sdhci_do_set_ios) from [<c0528018>]
    (sdhci_runtime_resume_host+0x60/0x114)
    [    3.119758] [<c0528018>] (sdhci_runtime_resume_host) from
    [<c0402570>] (__rpm_callback+0x2c/0x60)
    [    3.119767] [<c0402570>] (__rpm_callback) from [<c04025c4>]
    (rpm_callback+0x20/0x80)
    [    3.119773] [<c04025c4>] (rpm_callback) from [<c04034b8>]
    (rpm_resume+0x36c/0x558)
    [    3.119780] [<c04034b8>] (rpm_resume) from [<c04036f0>]
    (__pm_runtime_resume+0x4c/0x64)
    [    3.119788] [<c04036f0>] (__pm_runtime_resume) from [<c0512728>]
    (__mmc_claim_host+0x170/0x1b0)
    [    3.119795] [<c0512728>] (__mmc_claim_host) from [<c0514e2c>]
    (mmc_rescan+0x54/0x348)
    [    3.119807] [<c0514e2c>] (mmc_rescan) from [<c0130dac>]
    (process_one_work+0x120/0x3f4)
    [    3.119815] [<c0130dac>] (process_one_work) from [<c01310b8>]
    (worker_thread+0x38/0x554)
    [    3.119823] [<c01310b8>] (worker_thread) from [<c01365a4>]
    (kthread+0xdc/0xf4)
    [    3.119831] [<c01365a4>] (kthread) from [<c0107878>]
    (ret_from_fork+0x14/0x3c)
    [    3.119834] ---[ end trace a22d652aa3276886 ]---
    
    Fix by adding a 'set_power' callback and restoring the default
    behaviour prior to commit 918f4cbd4340 ("mmc: sdhci: restore
    behavior when setting VDD via external regulator").  The desired
    behaviour of that commit is gotten by having sdhci-pxav3 provide
    its own set_power callback.
    
    Reported-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Link: http://lkml.kernel.org/r/CAJKOXPcGDnPm-Ykh6wHqV1YxfTaov5E8iVqBoBn4OJc7BnhgEQ@mail.gmail.com
    Fixes: 918f4cbd4340 ("mmc: sdhci: restore behavior when setting VDD...)
    Tested-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Tested-by: Ludovic Desroches <ludovic.desroches@atmel.com>
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Reviewed-by: Jisheng Zhang <jszhang@marvell.com>
    Tested-by: Jisheng Zhang <jszhang@marvell.com>
    Tested-by: Jaehoon Chung <jh80.chung@samsung.com>
    Tested-by: Anand Moon <linux.amoon@gmail.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 1dceb0415aa0c6bc11dacdab47c9ef83a3604166
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Tue Mar 29 12:45:43 2016 +0300

    mmc: sdhci: Fix regression setting power on Trats2 board
    
    Several commits relating to setting power have been introducing
    problems by putting driver-specific rules into generic SDHCI code.
    
    Krzysztof Kozlowski reported that after commit 918f4cbd4340 ("mmc:
    sdhci: restore behavior when setting VDD via external regulator")
    on Trats2 board there are warnings for invalid VDD  value (2.8V):
    
    [    3.119656] ------------[ cut here ]------------
    [    3.119666] WARNING: CPU: 3 PID: 90 at
    ../drivers/mmc/host/sdhci.c:1234 sdhci_do_set_ios+0x4cc/0x5e0
    [    3.119669] mmc0: Invalid vdd 0x10
    [    3.119673] Modules linked in:
    [    3.119679] CPU: 3 PID: 90 Comm: kworker/3:1 Tainted: G        W
       4.5.0-next-20160324 #23
    [    3.119681] Hardware name: SAMSUNG EXYNOS (Flattened Device Tree)
    [    3.119690] Workqueue: events_freezable mmc_rescan
    [    3.119708] [<c010e0ac>] (unwind_backtrace) from [<c010ae10>]
    (show_stack+0x10/0x14)
    [    3.119719] [<c010ae10>] (show_stack) from [<c0323260>]
    (dump_stack+0x88/0x9c)
    [    3.119728] [<c0323260>] (dump_stack) from [<c011b754>] (__warn+0xe8/0x100)
    [    3.119734] [<c011b754>] (__warn) from [<c011b7a4>]
    (warn_slowpath_fmt+0x38/0x48)
    [    3.119740] [<c011b7a4>] (warn_slowpath_fmt) from [<c0527d28>]
    (sdhci_do_set_ios+0x4cc/0x5e0)
    [    3.119748] [<c0527d28>] (sdhci_do_set_ios) from [<c0528018>]
    (sdhci_runtime_resume_host+0x60/0x114)
    [    3.119758] [<c0528018>] (sdhci_runtime_resume_host) from
    [<c0402570>] (__rpm_callback+0x2c/0x60)
    [    3.119767] [<c0402570>] (__rpm_callback) from [<c04025c4>]
    (rpm_callback+0x20/0x80)
    [    3.119773] [<c04025c4>] (rpm_callback) from [<c04034b8>]
    (rpm_resume+0x36c/0x558)
    [    3.119780] [<c04034b8>] (rpm_resume) from [<c04036f0>]
    (__pm_runtime_resume+0x4c/0x64)
    [    3.119788] [<c04036f0>] (__pm_runtime_resume) from [<c0512728>]
    (__mmc_claim_host+0x170/0x1b0)
    [    3.119795] [<c0512728>] (__mmc_claim_host) from [<c0514e2c>]
    (mmc_rescan+0x54/0x348)
    [    3.119807] [<c0514e2c>] (mmc_rescan) from [<c0130dac>]
    (process_one_work+0x120/0x3f4)
    [    3.119815] [<c0130dac>] (process_one_work) from [<c01310b8>]
    (worker_thread+0x38/0x554)
    [    3.119823] [<c01310b8>] (worker_thread) from [<c01365a4>]
    (kthread+0xdc/0xf4)
    [    3.119831] [<c01365a4>] (kthread) from [<c0107878>]
    (ret_from_fork+0x14/0x3c)
    [    3.119834] ---[ end trace a22d652aa3276886 ]---
    
    Fix by adding a 'set_power' callback and restoring the default
    behaviour prior to commit 918f4cbd4340 ("mmc: sdhci: restore
    behavior when setting VDD via external regulator").  The desired
    behaviour of that commit is gotten by having sdhci-pxav3 provide
    its own set_power callback.
    
    Reported-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Link: http://lkml.kernel.org/r/CAJKOXPcGDnPm-Ykh6wHqV1YxfTaov5E8iVqBoBn4OJc7BnhgEQ@mail.gmail.com
    Fixes: 918f4cbd4340 ("mmc: sdhci: restore behavior when setting VDD...)
    Tested-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Tested-by: Ludovic Desroches <ludovic.desroches@atmel.com>
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Cc: stable@vger.kernel.org # v4.5+
    Reviewed-by: Jisheng Zhang <jszhang@marvell.com>
    Tested-by: Jisheng Zhang <jszhang@marvell.com>
    Tested-by: Jaehoon Chung <jh80.chung@samsung.com>
    Tested-by: Anand Moon <linux.amoon@gmail.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

commit 2e33adc8018bc86c9c3f8fe6c7c494f15c2d6caf
Author: Peter Chen <peter.chen@nxp.com>
Date:   Wed Feb 24 11:05:25 2016 +0800

    usb: chipidea: otg: change workqueue ci_otg as freezable
    
    commit d144dfea8af7108f613139623e63952ed7e69c0c upstream.
    
    If we use USB ID pin as wakeup source, and there is a USB block
    device on this USB OTG (ID) cable, the system will be deadlock
    after system resume.
    
    The root cause for this problem is: the workqueue ci_otg may try
    to remove hcd before the driver resume has finished, and hcd will
    disconnect the device on it, then, it will call device_release_driver,
    and holds the device lock "dev->mutex", but it is never unlocked since
    it waits workqueue writeback to run to flush the block information, but
    the workqueue writeback is freezable, it is not thawed before driver
    resume has finished.
    
    When the driver (device: sd 0:0:0:0:) resume goes to dpm_complete, it
    tries to get its device lock "dev->mutex", but it can't get it forever,
    then the deadlock occurs. Below call stacks show the situation.
    
    So, in order to fix this problem, we need to change workqueue ci_otg
    as freezable, then the work item in this workqueue will be run after
    driver's resume, this workqueue will not be blocked forever like above
    case since the workqueue writeback has been thawed too.
    
    Tested at: i.mx6qdl-sabresd and i.mx6sx-sdb.
    
    [  555.178869] kworker/u2:13   D c07de74c     0   826      2 0x00000000
    [  555.185310] Workqueue: ci_otg ci_otg_work
    [  555.189353] Backtrace:
    [  555.191849] [<c07de4fc>] (__schedule) from [<c07dec6c>] (schedule+0x48/0xa0)
    [  555.198912]  r10:ee471ba0 r9:00000000 r8:00000000 r7:00000002 r6:ee470000 r5:ee471ba4
    [  555.206867]  r4:ee470000
    [  555.209453] [<c07dec24>] (schedule) from [<c07e2fc4>] (schedule_timeout+0x15c/0x1e0)
    [  555.217212]  r4:7fffffff r3:edc2b000
    [  555.220862] [<c07e2e68>] (schedule_timeout) from [<c07df6c8>] (wait_for_common+0x94/0x144)
    [  555.229140]  r8:00000000 r7:00000002 r6:ee470000 r5:ee471ba4 r4:7fffffff
    [  555.235980] [<c07df634>] (wait_for_common) from [<c07df790>] (wait_for_completion+0x18/0x1c)
    [  555.244430]  r10:00000001 r9:c0b5563c r8:c0042e48 r7:ef086000 r6:eea4372c r5:ef131b00
    [  555.252383]  r4:00000000
    [  555.254970] [<c07df778>] (wait_for_completion) from [<c0043cb8>] (flush_work+0x19c/0x234)
    [  555.263177] [<c0043b1c>] (flush_work) from [<c0043fac>] (flush_delayed_work+0x48/0x4c)
    [  555.271106]  r8:ed5b5000 r7:c0b38a3c r6:eea439cc r5:eea4372c r4:eea4372c
    [  555.277958] [<c0043f64>] (flush_delayed_work) from [<c00eae18>] (bdi_unregister+0x84/0xec)
    [  555.286236]  r4:eea43520 r3:20000153
    [  555.289885] [<c00ead94>] (bdi_unregister) from [<c02c2154>] (blk_cleanup_queue+0x180/0x29c)
    [  555.298250]  r5:eea43808 r4:eea43400
    [  555.301909] [<c02c1fd4>] (blk_cleanup_queue) from [<c0417914>] (__scsi_remove_device+0x48/0xb8)
    [  555.310623]  r7:00000000 r6:20000153 r5:ededa950 r4:ededa800
    [  555.316403] [<c04178cc>] (__scsi_remove_device) from [<c0415e90>] (scsi_forget_host+0x64/0x68)
    [  555.325028]  r5:ededa800 r4:ed5b5000
    [  555.328689] [<c0415e2c>] (scsi_forget_host) from [<c0409828>] (scsi_remove_host+0x78/0x104)
    [  555.337054]  r5:ed5b5068 r4:ed5b5000
    [  555.340709] [<c04097b0>] (scsi_remove_host) from [<c04cdfcc>] (usb_stor_disconnect+0x50/0xb4)
    [  555.349247]  r6:ed5b56e4 r5:ed5b5818 r4:ed5b5690 r3:00000008
    [  555.355025] [<c04cdf7c>] (usb_stor_disconnect) from [<c04b3bc8>] (usb_unbind_interface+0x78/0x25c)
    [  555.363997]  r8:c13919b4 r7:edd3c000 r6:edd3c020 r5:ee551c68 r4:ee551c00 r3:c04cdf7c
    [  555.371892] [<c04b3b50>] (usb_unbind_interface) from [<c03dc248>] (__device_release_driver+0x8c/0x118)
    [  555.381213]  r10:00000001 r9:edd90c00 r8:c13919b4 r7:ee551c68 r6:c0b546e0 r5:c0b5563c
    [  555.389167]  r4:edd3c020
    [  555.391752] [<c03dc1bc>] (__device_release_driver) from [<c03dc2fc>] (device_release_driver+0x28/0x34)
    [  555.401071]  r5:edd3c020 r4:edd3c054
    [  555.404721] [<c03dc2d4>] (device_release_driver) from [<c03db304>] (bus_remove_device+0xe0/0x110)
    [  555.413607]  r5:edd3c020 r4:ef17f04c
    [  555.417253] [<c03db224>] (bus_remove_device) from [<c03d8128>] (device_del+0x114/0x21c)
    [  555.425270]  r6:edd3c028 r5:edd3c020 r4:ee551c00 r3:00000000
    [  555.431045] [<c03d8014>] (device_del) from [<c04b1560>] (usb_disable_device+0xa4/0x1e8)
    [  555.439061]  r8:edd3c000 r7:eded8000 r6:00000000 r5:00000001 r4:ee551c00
    [  555.445906] [<c04b14bc>] (usb_disable_device) from [<c04a8e54>] (usb_disconnect+0x74/0x224)
    [  555.454271]  r9:edd90c00 r8:ee551000 r7:ee551c68 r6:ee551c9c r5:ee551c00 r4:00000001
    [  555.462156] [<c04a8de0>] (usb_disconnect) from [<c04a8fb8>] (usb_disconnect+0x1d8/0x224)
    [  555.470259]  r10:00000001 r9:edd90000 r8:ee471e2c r7:ee551468 r6:ee55149c r5:ee551400
    [  555.478213]  r4:00000001
    [  555.480797] [<c04a8de0>] (usb_disconnect) from [<c04ae5ec>] (usb_remove_hcd+0xa0/0x1ac)
    [  555.488813]  r10:00000001 r9:ee471eb0 r8:00000000 r7:ef3d9500 r6:eded810c r5:eded80b0
    [  555.496765]  r4:eded8000
    [  555.499351] [<c04ae54c>] (usb_remove_hcd) from [<c04d4158>] (host_stop+0x28/0x64)
    [  555.506847]  r6:eeb50010 r5:eded8000 r4:eeb51010
    [  555.511563] [<c04d4130>] (host_stop) from [<c04d09b8>] (ci_otg_work+0xc4/0x124)
    [  555.518885]  r6:00000001 r5:eeb50010 r4:eeb502a0 r3:c04d4130
    [  555.524665] [<c04d08f4>] (ci_otg_work) from [<c00454f0>] (process_one_work+0x194/0x420)
    [  555.532682]  r6:ef086000 r5:eeb502a0 r4:edc44480
    [  555.537393] [<c004535c>] (process_one_work) from [<c00457b0>] (worker_thread+0x34/0x514)
    [  555.545496]  r10:edc44480 r9:ef086000 r8:c0b1a100 r7:ef086034 r6:00000088 r5:edc44498
    [  555.553450]  r4:ef086000
    [  555.556032] [<c004577c>] (worker_thread) from [<c004bab4>] (kthread+0xdc/0xf8)
    [  555.563268]  r10:00000000 r9:00000000 r8:00000000 r7:c004577c r6:edc44480 r5:eddc15c0
    [  555.571221]  r4:00000000
    [  555.573804] [<c004b9d8>] (kthread) from [<c000fef0>] (ret_from_fork+0x14/0x24)
    [  555.581040]  r7:00000000 r6:00000000 r5:c004b9d8 r4:eddc15c0
    
    [  553.429383] sh              D c07de74c     0   694    691 0x00000000
    [  553.435801] Backtrace:
    [  553.438295] [<c07de4fc>] (__schedule) from [<c07dec6c>] (schedule+0x48/0xa0)
    [  553.445358]  r10:edd3c054 r9:edd3c078 r8:edddbd50 r7:edcbbc00 r6:c1377c34 r5:60000153
    [  553.453313]  r4:eddda000
    [  553.455896] [<c07dec24>] (schedule) from [<c07deff8>] (schedule_preempt_disabled+0x10/0x14)
    [  553.464261]  r4:edd3c058 r3:0000000a
    [  553.467910] [<c07defe8>] (schedule_preempt_disabled) from [<c07e0bbc>] (mutex_lock_nested+0x1a0/0x3e8)
    [  553.477254] [<c07e0a1c>] (mutex_lock_nested) from [<c03e927c>] (dpm_complete+0xc0/0x1b0)
    [  553.485358]  r10:00561408 r9:edd3c054 r8:c0b4863c r7:edddbd90 r6:c0b485d8 r5:edd3c020
    [  553.493313]  r4:edd3c0d0
    [  553.495896] [<c03e91bc>] (dpm_complete) from [<c03e9388>] (dpm_resume_end+0x1c/0x20)
    [  553.503652]  r9:00000000 r8:c0b1a9d0 r7:c1334ec0 r6:c1334edc r5:00000003 r4:00000010
    [  553.511544] [<c03e936c>] (dpm_resume_end) from [<c0079894>] (suspend_devices_and_enter+0x158/0x504)
    [  553.520604]  r4:00000000 r3:c1334efc
    [  553.524250] [<c007973c>] (suspend_devices_and_enter) from [<c0079e74>] (pm_suspend+0x234/0x2cc)
    [  553.532961]  r10:00561408 r9:ed6b7300 r8:00000004 r7:c1334eec r6:00000000 r5:c1334ee8
    [  553.540914]  r4:00000003
    [  553.543493] [<c0079c40>] (pm_suspend) from [<c0078a6c>] (state_store+0x6c/0xc0)
    
    [  555.703684] 7 locks held by kworker/u2:13/826:
    [  555.708140]  #0:  ("%s""ci_otg"){++++.+}, at: [<c0045484>] process_one_work+0x128/0x420
    [  555.716277]  #1:  ((&ci->work)){+.+.+.}, at: [<c0045484>] process_one_work+0x128/0x420
    [  555.724317]  #2:  (usb_bus_list_lock){+.+.+.}, at: [<c04ae5e4>] usb_remove_hcd+0x98/0x1ac
    [  555.732626]  #3:  (&dev->mutex){......}, at: [<c04a8e28>] usb_disconnect+0x48/0x224
    [  555.740403]  #4:  (&dev->mutex){......}, at: [<c04a8e28>] usb_disconnect+0x48/0x224
    [  555.748179]  #5:  (&dev->mutex){......}, at: [<c03dc2f4>] device_release_driver+0x20/0x34
    [  555.756487]  #6:  (&shost->scan_mutex){+.+.+.}, at: [<c04097d0>] scsi_remove_host+0x20/0x104
    
    Cc: Jun Li <jun.li@nxp.com>
    Signed-off-by: Peter Chen <peter.chen@nxp.com>
    Signed-off-by: Luis Henriques <luis.henriques@canonical.com>

commit e4477a4b702628a939d891b5631769ceb263242f
Author: Peter Chen <peter.chen@nxp.com>
Date:   Wed Feb 24 11:05:25 2016 +0800

    usb: chipidea: otg: change workqueue ci_otg as freezable
    
    [ Upstream commit d144dfea8af7108f613139623e63952ed7e69c0c ]
    
    If we use USB ID pin as wakeup source, and there is a USB block
    device on this USB OTG (ID) cable, the system will be deadlock
    after system resume.
    
    The root cause for this problem is: the workqueue ci_otg may try
    to remove hcd before the driver resume has finished, and hcd will
    disconnect the device on it, then, it will call device_release_driver,
    and holds the device lock "dev->mutex", but it is never unlocked since
    it waits workqueue writeback to run to flush the block information, but
    the workqueue writeback is freezable, it is not thawed before driver
    resume has finished.
    
    When the driver (device: sd 0:0:0:0:) resume goes to dpm_complete, it
    tries to get its device lock "dev->mutex", but it can't get it forever,
    then the deadlock occurs. Below call stacks show the situation.
    
    So, in order to fix this problem, we need to change workqueue ci_otg
    as freezable, then the work item in this workqueue will be run after
    driver's resume, this workqueue will not be blocked forever like above
    case since the workqueue writeback has been thawed too.
    
    Tested at: i.mx6qdl-sabresd and i.mx6sx-sdb.
    
    [  555.178869] kworker/u2:13   D c07de74c     0   826      2 0x00000000
    [  555.185310] Workqueue: ci_otg ci_otg_work
    [  555.189353] Backtrace:
    [  555.191849] [<c07de4fc>] (__schedule) from [<c07dec6c>] (schedule+0x48/0xa0)
    [  555.198912]  r10:ee471ba0 r9:00000000 r8:00000000 r7:00000002 r6:ee470000 r5:ee471ba4
    [  555.206867]  r4:ee470000
    [  555.209453] [<c07dec24>] (schedule) from [<c07e2fc4>] (schedule_timeout+0x15c/0x1e0)
    [  555.217212]  r4:7fffffff r3:edc2b000
    [  555.220862] [<c07e2e68>] (schedule_timeout) from [<c07df6c8>] (wait_for_common+0x94/0x144)
    [  555.229140]  r8:00000000 r7:00000002 r6:ee470000 r5:ee471ba4 r4:7fffffff
    [  555.235980] [<c07df634>] (wait_for_common) from [<c07df790>] (wait_for_completion+0x18/0x1c)
    [  555.244430]  r10:00000001 r9:c0b5563c r8:c0042e48 r7:ef086000 r6:eea4372c r5:ef131b00
    [  555.252383]  r4:00000000
    [  555.254970] [<c07df778>] (wait_for_completion) from [<c0043cb8>] (flush_work+0x19c/0x234)
    [  555.263177] [<c0043b1c>] (flush_work) from [<c0043fac>] (flush_delayed_work+0x48/0x4c)
    [  555.271106]  r8:ed5b5000 r7:c0b38a3c r6:eea439cc r5:eea4372c r4:eea4372c
    [  555.277958] [<c0043f64>] (flush_delayed_work) from [<c00eae18>] (bdi_unregister+0x84/0xec)
    [  555.286236]  r4:eea43520 r3:20000153
    [  555.289885] [<c00ead94>] (bdi_unregister) from [<c02c2154>] (blk_cleanup_queue+0x180/0x29c)
    [  555.298250]  r5:eea43808 r4:eea43400
    [  555.301909] [<c02c1fd4>] (blk_cleanup_queue) from [<c0417914>] (__scsi_remove_device+0x48/0xb8)
    [  555.310623]  r7:00000000 r6:20000153 r5:ededa950 r4:ededa800
    [  555.316403] [<c04178cc>] (__scsi_remove_device) from [<c0415e90>] (scsi_forget_host+0x64/0x68)
    [  555.325028]  r5:ededa800 r4:ed5b5000
    [  555.328689] [<c0415e2c>] (scsi_forget_host) from [<c0409828>] (scsi_remove_host+0x78/0x104)
    [  555.337054]  r5:ed5b5068 r4:ed5b5000
    [  555.340709] [<c04097b0>] (scsi_remove_host) from [<c04cdfcc>] (usb_stor_disconnect+0x50/0xb4)
    [  555.349247]  r6:ed5b56e4 r5:ed5b5818 r4:ed5b5690 r3:00000008
    [  555.355025] [<c04cdf7c>] (usb_stor_disconnect) from [<c04b3bc8>] (usb_unbind_interface+0x78/0x25c)
    [  555.363997]  r8:c13919b4 r7:edd3c000 r6:edd3c020 r5:ee551c68 r4:ee551c00 r3:c04cdf7c
    [  555.371892] [<c04b3b50>] (usb_unbind_interface) from [<c03dc248>] (__device_release_driver+0x8c/0x118)
    [  555.381213]  r10:00000001 r9:edd90c00 r8:c13919b4 r7:ee551c68 r6:c0b546e0 r5:c0b5563c
    [  555.389167]  r4:edd3c020
    [  555.391752] [<c03dc1bc>] (__device_release_driver) from [<c03dc2fc>] (device_release_driver+0x28/0x34)
    [  555.401071]  r5:edd3c020 r4:edd3c054
    [  555.404721] [<c03dc2d4>] (device_release_driver) from [<c03db304>] (bus_remove_device+0xe0/0x110)
    [  555.413607]  r5:edd3c020 r4:ef17f04c
    [  555.417253] [<c03db224>] (bus_remove_device) from [<c03d8128>] (device_del+0x114/0x21c)
    [  555.425270]  r6:edd3c028 r5:edd3c020 r4:ee551c00 r3:00000000
    [  555.431045] [<c03d8014>] (device_del) from [<c04b1560>] (usb_disable_device+0xa4/0x1e8)
    [  555.439061]  r8:edd3c000 r7:eded8000 r6:00000000 r5:00000001 r4:ee551c00
    [  555.445906] [<c04b14bc>] (usb_disable_device) from [<c04a8e54>] (usb_disconnect+0x74/0x224)
    [  555.454271]  r9:edd90c00 r8:ee551000 r7:ee551c68 r6:ee551c9c r5:ee551c00 r4:00000001
    [  555.462156] [<c04a8de0>] (usb_disconnect) from [<c04a8fb8>] (usb_disconnect+0x1d8/0x224)
    [  555.470259]  r10:00000001 r9:edd90000 r8:ee471e2c r7:ee551468 r6:ee55149c r5:ee551400
    [  555.478213]  r4:00000001
    [  555.480797] [<c04a8de0>] (usb_disconnect) from [<c04ae5ec>] (usb_remove_hcd+0xa0/0x1ac)
    [  555.488813]  r10:00000001 r9:ee471eb0 r8:00000000 r7:ef3d9500 r6:eded810c r5:eded80b0
    [  555.496765]  r4:eded8000
    [  555.499351] [<c04ae54c>] (usb_remove_hcd) from [<c04d4158>] (host_stop+0x28/0x64)
    [  555.506847]  r6:eeb50010 r5:eded8000 r4:eeb51010
    [  555.511563] [<c04d4130>] (host_stop) from [<c04d09b8>] (ci_otg_work+0xc4/0x124)
    [  555.518885]  r6:00000001 r5:eeb50010 r4:eeb502a0 r3:c04d4130
    [  555.524665] [<c04d08f4>] (ci_otg_work) from [<c00454f0>] (process_one_work+0x194/0x420)
    [  555.532682]  r6:ef086000 r5:eeb502a0 r4:edc44480
    [  555.537393] [<c004535c>] (process_one_work) from [<c00457b0>] (worker_thread+0x34/0x514)
    [  555.545496]  r10:edc44480 r9:ef086000 r8:c0b1a100 r7:ef086034 r6:00000088 r5:edc44498
    [  555.553450]  r4:ef086000
    [  555.556032] [<c004577c>] (worker_thread) from [<c004bab4>] (kthread+0xdc/0xf8)
    [  555.563268]  r10:00000000 r9:00000000 r8:00000000 r7:c004577c r6:edc44480 r5:eddc15c0
    [  555.571221]  r4:00000000
    [  555.573804] [<c004b9d8>] (kthread) from [<c000fef0>] (ret_from_fork+0x14/0x24)
    [  555.581040]  r7:00000000 r6:00000000 r5:c004b9d8 r4:eddc15c0
    
    [  553.429383] sh              D c07de74c     0   694    691 0x00000000
    [  553.435801] Backtrace:
    [  553.438295] [<c07de4fc>] (__schedule) from [<c07dec6c>] (schedule+0x48/0xa0)
    [  553.445358]  r10:edd3c054 r9:edd3c078 r8:edddbd50 r7:edcbbc00 r6:c1377c34 r5:60000153
    [  553.453313]  r4:eddda000
    [  553.455896] [<c07dec24>] (schedule) from [<c07deff8>] (schedule_preempt_disabled+0x10/0x14)
    [  553.464261]  r4:edd3c058 r3:0000000a
    [  553.467910] [<c07defe8>] (schedule_preempt_disabled) from [<c07e0bbc>] (mutex_lock_nested+0x1a0/0x3e8)
    [  553.477254] [<c07e0a1c>] (mutex_lock_nested) from [<c03e927c>] (dpm_complete+0xc0/0x1b0)
    [  553.485358]  r10:00561408 r9:edd3c054 r8:c0b4863c r7:edddbd90 r6:c0b485d8 r5:edd3c020
    [  553.493313]  r4:edd3c0d0
    [  553.495896] [<c03e91bc>] (dpm_complete) from [<c03e9388>] (dpm_resume_end+0x1c/0x20)
    [  553.503652]  r9:00000000 r8:c0b1a9d0 r7:c1334ec0 r6:c1334edc r5:00000003 r4:00000010
    [  553.511544] [<c03e936c>] (dpm_resume_end) from [<c0079894>] (suspend_devices_and_enter+0x158/0x504)
    [  553.520604]  r4:00000000 r3:c1334efc
    [  553.524250] [<c007973c>] (suspend_devices_and_enter) from [<c0079e74>] (pm_suspend+0x234/0x2cc)
    [  553.532961]  r10:00561408 r9:ed6b7300 r8:00000004 r7:c1334eec r6:00000000 r5:c1334ee8
    [  553.540914]  r4:00000003
    [  553.543493] [<c0079c40>] (pm_suspend) from [<c0078a6c>] (state_store+0x6c/0xc0)
    
    [  555.703684] 7 locks held by kworker/u2:13/826:
    [  555.708140]  #0:  ("%s""ci_otg"){++++.+}, at: [<c0045484>] process_one_work+0x128/0x420
    [  555.716277]  #1:  ((&ci->work)){+.+.+.}, at: [<c0045484>] process_one_work+0x128/0x420
    [  555.724317]  #2:  (usb_bus_list_lock){+.+.+.}, at: [<c04ae5e4>] usb_remove_hcd+0x98/0x1ac
    [  555.732626]  #3:  (&dev->mutex){......}, at: [<c04a8e28>] usb_disconnect+0x48/0x224
    [  555.740403]  #4:  (&dev->mutex){......}, at: [<c04a8e28>] usb_disconnect+0x48/0x224
    [  555.748179]  #5:  (&dev->mutex){......}, at: [<c03dc2f4>] device_release_driver+0x20/0x34
    [  555.756487]  #6:  (&shost->scan_mutex){+.+.+.}, at: [<c04097d0>] scsi_remove_host+0x20/0x104
    
    Cc: <stable@vger.kernel.org> #v3.14+
    Cc: Jun Li <jun.li@nxp.com>
    Signed-off-by: Peter Chen <peter.chen@nxp.com>
    Signed-off-by: Sasha Levin <sasha.levin@oracle.com>

commit 0ba460a5fd15673ad895a8fc51d378eb30f1922b
Author: Peter Chen <peter.chen@nxp.com>
Date:   Wed Feb 24 11:05:25 2016 +0800

    usb: chipidea: otg: change workqueue ci_otg as freezable
    
    commit d144dfea8af7108f613139623e63952ed7e69c0c upstream.
    
    If we use USB ID pin as wakeup source, and there is a USB block
    device on this USB OTG (ID) cable, the system will be deadlock
    after system resume.
    
    The root cause for this problem is: the workqueue ci_otg may try
    to remove hcd before the driver resume has finished, and hcd will
    disconnect the device on it, then, it will call device_release_driver,
    and holds the device lock "dev->mutex", but it is never unlocked since
    it waits workqueue writeback to run to flush the block information, but
    the workqueue writeback is freezable, it is not thawed before driver
    resume has finished.
    
    When the driver (device: sd 0:0:0:0:) resume goes to dpm_complete, it
    tries to get its device lock "dev->mutex", but it can't get it forever,
    then the deadlock occurs. Below call stacks show the situation.
    
    So, in order to fix this problem, we need to change workqueue ci_otg
    as freezable, then the work item in this workqueue will be run after
    driver's resume, this workqueue will not be blocked forever like above
    case since the workqueue writeback has been thawed too.
    
    Tested at: i.mx6qdl-sabresd and i.mx6sx-sdb.
    
    [  555.178869] kworker/u2:13   D c07de74c     0   826      2 0x00000000
    [  555.185310] Workqueue: ci_otg ci_otg_work
    [  555.189353] Backtrace:
    [  555.191849] [<c07de4fc>] (__schedule) from [<c07dec6c>] (schedule+0x48/0xa0)
    [  555.198912]  r10:ee471ba0 r9:00000000 r8:00000000 r7:00000002 r6:ee470000 r5:ee471ba4
    [  555.206867]  r4:ee470000
    [  555.209453] [<c07dec24>] (schedule) from [<c07e2fc4>] (schedule_timeout+0x15c/0x1e0)
    [  555.217212]  r4:7fffffff r3:edc2b000
    [  555.220862] [<c07e2e68>] (schedule_timeout) from [<c07df6c8>] (wait_for_common+0x94/0x144)
    [  555.229140]  r8:00000000 r7:00000002 r6:ee470000 r5:ee471ba4 r4:7fffffff
    [  555.235980] [<c07df634>] (wait_for_common) from [<c07df790>] (wait_for_completion+0x18/0x1c)
    [  555.244430]  r10:00000001 r9:c0b5563c r8:c0042e48 r7:ef086000 r6:eea4372c r5:ef131b00
    [  555.252383]  r4:00000000
    [  555.254970] [<c07df778>] (wait_for_completion) from [<c0043cb8>] (flush_work+0x19c/0x234)
    [  555.263177] [<c0043b1c>] (flush_work) from [<c0043fac>] (flush_delayed_work+0x48/0x4c)
    [  555.271106]  r8:ed5b5000 r7:c0b38a3c r6:eea439cc r5:eea4372c r4:eea4372c
    [  555.277958] [<c0043f64>] (flush_delayed_work) from [<c00eae18>] (bdi_unregister+0x84/0xec)
    [  555.286236]  r4:eea43520 r3:20000153
    [  555.289885] [<c00ead94>] (bdi_unregister) from [<c02c2154>] (blk_cleanup_queue+0x180/0x29c)
    [  555.298250]  r5:eea43808 r4:eea43400
    [  555.301909] [<c02c1fd4>] (blk_cleanup_queue) from [<c0417914>] (__scsi_remove_device+0x48/0xb8)
    [  555.310623]  r7:00000000 r6:20000153 r5:ededa950 r4:ededa800
    [  555.316403] [<c04178cc>] (__scsi_remove_device) from [<c0415e90>] (scsi_forget_host+0x64/0x68)
    [  555.325028]  r5:ededa800 r4:ed5b5000
    [  555.328689] [<c0415e2c>] (scsi_forget_host) from [<c0409828>] (scsi_remove_host+0x78/0x104)
    [  555.337054]  r5:ed5b5068 r4:ed5b5000
    [  555.340709] [<c04097b0>] (scsi_remove_host) from [<c04cdfcc>] (usb_stor_disconnect+0x50/0xb4)
    [  555.349247]  r6:ed5b56e4 r5:ed5b5818 r4:ed5b5690 r3:00000008
    [  555.355025] [<c04cdf7c>] (usb_stor_disconnect) from [<c04b3bc8>] (usb_unbind_interface+0x78/0x25c)
    [  555.363997]  r8:c13919b4 r7:edd3c000 r6:edd3c020 r5:ee551c68 r4:ee551c00 r3:c04cdf7c
    [  555.371892] [<c04b3b50>] (usb_unbind_interface) from [<c03dc248>] (__device_release_driver+0x8c/0x118)
    [  555.381213]  r10:00000001 r9:edd90c00 r8:c13919b4 r7:ee551c68 r6:c0b546e0 r5:c0b5563c
    [  555.389167]  r4:edd3c020
    [  555.391752] [<c03dc1bc>] (__device_release_driver) from [<c03dc2fc>] (device_release_driver+0x28/0x34)
    [  555.401071]  r5:edd3c020 r4:edd3c054
    [  555.404721] [<c03dc2d4>] (device_release_driver) from [<c03db304>] (bus_remove_device+0xe0/0x110)
    [  555.413607]  r5:edd3c020 r4:ef17f04c
    [  555.417253] [<c03db224>] (bus_remove_device) from [<c03d8128>] (device_del+0x114/0x21c)
    [  555.425270]  r6:edd3c028 r5:edd3c020 r4:ee551c00 r3:00000000
    [  555.431045] [<c03d8014>] (device_del) from [<c04b1560>] (usb_disable_device+0xa4/0x1e8)
    [  555.439061]  r8:edd3c000 r7:eded8000 r6:00000000 r5:00000001 r4:ee551c00
    [  555.445906] [<c04b14bc>] (usb_disable_device) from [<c04a8e54>] (usb_disconnect+0x74/0x224)
    [  555.454271]  r9:edd90c00 r8:ee551000 r7:ee551c68 r6:ee551c9c r5:ee551c00 r4:00000001
    [  555.462156] [<c04a8de0>] (usb_disconnect) from [<c04a8fb8>] (usb_disconnect+0x1d8/0x224)
    [  555.470259]  r10:00000001 r9:edd90000 r8:ee471e2c r7:ee551468 r6:ee55149c r5:ee551400
    [  555.478213]  r4:00000001
    [  555.480797] [<c04a8de0>] (usb_disconnect) from [<c04ae5ec>] (usb_remove_hcd+0xa0/0x1ac)
    [  555.488813]  r10:00000001 r9:ee471eb0 r8:00000000 r7:ef3d9500 r6:eded810c r5:eded80b0
    [  555.496765]  r4:eded8000
    [  555.499351] [<c04ae54c>] (usb_remove_hcd) from [<c04d4158>] (host_stop+0x28/0x64)
    [  555.506847]  r6:eeb50010 r5:eded8000 r4:eeb51010
    [  555.511563] [<c04d4130>] (host_stop) from [<c04d09b8>] (ci_otg_work+0xc4/0x124)
    [  555.518885]  r6:00000001 r5:eeb50010 r4:eeb502a0 r3:c04d4130
    [  555.524665] [<c04d08f4>] (ci_otg_work) from [<c00454f0>] (process_one_work+0x194/0x420)
    [  555.532682]  r6:ef086000 r5:eeb502a0 r4:edc44480
    [  555.537393] [<c004535c>] (process_one_work) from [<c00457b0>] (worker_thread+0x34/0x514)
    [  555.545496]  r10:edc44480 r9:ef086000 r8:c0b1a100 r7:ef086034 r6:00000088 r5:edc44498
    [  555.553450]  r4:ef086000
    [  555.556032] [<c004577c>] (worker_thread) from [<c004bab4>] (kthread+0xdc/0xf8)
    [  555.563268]  r10:00000000 r9:00000000 r8:00000000 r7:c004577c r6:edc44480 r5:eddc15c0
    [  555.571221]  r4:00000000
    [  555.573804] [<c004b9d8>] (kthread) from [<c000fef0>] (ret_from_fork+0x14/0x24)
    [  555.581040]  r7:00000000 r6:00000000 r5:c004b9d8 r4:eddc15c0
    
    [  553.429383] sh              D c07de74c     0   694    691 0x00000000
    [  553.435801] Backtrace:
    [  553.438295] [<c07de4fc>] (__schedule) from [<c07dec6c>] (schedule+0x48/0xa0)
    [  553.445358]  r10:edd3c054 r9:edd3c078 r8:edddbd50 r7:edcbbc00 r6:c1377c34 r5:60000153
    [  553.453313]  r4:eddda000
    [  553.455896] [<c07dec24>] (schedule) from [<c07deff8>] (schedule_preempt_disabled+0x10/0x14)
    [  553.464261]  r4:edd3c058 r3:0000000a
    [  553.467910] [<c07defe8>] (schedule_preempt_disabled) from [<c07e0bbc>] (mutex_lock_nested+0x1a0/0x3e8)
    [  553.477254] [<c07e0a1c>] (mutex_lock_nested) from [<c03e927c>] (dpm_complete+0xc0/0x1b0)
    [  553.485358]  r10:00561408 r9:edd3c054 r8:c0b4863c r7:edddbd90 r6:c0b485d8 r5:edd3c020
    [  553.493313]  r4:edd3c0d0
    [  553.495896] [<c03e91bc>] (dpm_complete) from [<c03e9388>] (dpm_resume_end+0x1c/0x20)
    [  553.503652]  r9:00000000 r8:c0b1a9d0 r7:c1334ec0 r6:c1334edc r5:00000003 r4:00000010
    [  553.511544] [<c03e936c>] (dpm_resume_end) from [<c0079894>] (suspend_devices_and_enter+0x158/0x504)
    [  553.520604]  r4:00000000 r3:c1334efc
    [  553.524250] [<c007973c>] (suspend_devices_and_enter) from [<c0079e74>] (pm_suspend+0x234/0x2cc)
    [  553.532961]  r10:00561408 r9:ed6b7300 r8:00000004 r7:c1334eec r6:00000000 r5:c1334ee8
    [  553.540914]  r4:00000003
    [  553.543493] [<c0079c40>] (pm_suspend) from [<c0078a6c>] (state_store+0x6c/0xc0)
    
    [  555.703684] 7 locks held by kworker/u2:13/826:
    [  555.708140]  #0:  ("%s""ci_otg"){++++.+}, at: [<c0045484>] process_one_work+0x128/0x420
    [  555.716277]  #1:  ((&ci->work)){+.+.+.}, at: [<c0045484>] process_one_work+0x128/0x420
    [  555.724317]  #2:  (usb_bus_list_lock){+.+.+.}, at: [<c04ae5e4>] usb_remove_hcd+0x98/0x1ac
    [  555.732626]  #3:  (&dev->mutex){......}, at: [<c04a8e28>] usb_disconnect+0x48/0x224
    [  555.740403]  #4:  (&dev->mutex){......}, at: [<c04a8e28>] usb_disconnect+0x48/0x224
    [  555.748179]  #5:  (&dev->mutex){......}, at: [<c03dc2f4>] device_release_driver+0x20/0x34
    [  555.756487]  #6:  (&shost->scan_mutex){+.+.+.}, at: [<c04097d0>] scsi_remove_host+0x20/0x104
    
    Cc: Jun Li <jun.li@nxp.com>
    Signed-off-by: Peter Chen <peter.chen@nxp.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit d01312328cd48d97f6a02e184017eb9568dd8fc6
Author: Peter Chen <peter.chen@nxp.com>
Date:   Wed Feb 24 11:05:25 2016 +0800

    usb: chipidea: otg: change workqueue ci_otg as freezable
    
    commit d144dfea8af7108f613139623e63952ed7e69c0c upstream.
    
    If we use USB ID pin as wakeup source, and there is a USB block
    device on this USB OTG (ID) cable, the system will be deadlock
    after system resume.
    
    The root cause for this problem is: the workqueue ci_otg may try
    to remove hcd before the driver resume has finished, and hcd will
    disconnect the device on it, then, it will call device_release_driver,
    and holds the device lock "dev->mutex", but it is never unlocked since
    it waits workqueue writeback to run to flush the block information, but
    the workqueue writeback is freezable, it is not thawed before driver
    resume has finished.
    
    When the driver (device: sd 0:0:0:0:) resume goes to dpm_complete, it
    tries to get its device lock "dev->mutex", but it can't get it forever,
    then the deadlock occurs. Below call stacks show the situation.
    
    So, in order to fix this problem, we need to change workqueue ci_otg
    as freezable, then the work item in this workqueue will be run after
    driver's resume, this workqueue will not be blocked forever like above
    case since the workqueue writeback has been thawed too.
    
    Tested at: i.mx6qdl-sabresd and i.mx6sx-sdb.
    
    [  555.178869] kworker/u2:13   D c07de74c     0   826      2 0x00000000
    [  555.185310] Workqueue: ci_otg ci_otg_work
    [  555.189353] Backtrace:
    [  555.191849] [<c07de4fc>] (__schedule) from [<c07dec6c>] (schedule+0x48/0xa0)
    [  555.198912]  r10:ee471ba0 r9:00000000 r8:00000000 r7:00000002 r6:ee470000 r5:ee471ba4
    [  555.206867]  r4:ee470000
    [  555.209453] [<c07dec24>] (schedule) from [<c07e2fc4>] (schedule_timeout+0x15c/0x1e0)
    [  555.217212]  r4:7fffffff r3:edc2b000
    [  555.220862] [<c07e2e68>] (schedule_timeout) from [<c07df6c8>] (wait_for_common+0x94/0x144)
    [  555.229140]  r8:00000000 r7:00000002 r6:ee470000 r5:ee471ba4 r4:7fffffff
    [  555.235980] [<c07df634>] (wait_for_common) from [<c07df790>] (wait_for_completion+0x18/0x1c)
    [  555.244430]  r10:00000001 r9:c0b5563c r8:c0042e48 r7:ef086000 r6:eea4372c r5:ef131b00
    [  555.252383]  r4:00000000
    [  555.254970] [<c07df778>] (wait_for_completion) from [<c0043cb8>] (flush_work+0x19c/0x234)
    [  555.263177] [<c0043b1c>] (flush_work) from [<c0043fac>] (flush_delayed_work+0x48/0x4c)
    [  555.271106]  r8:ed5b5000 r7:c0b38a3c r6:eea439cc r5:eea4372c r4:eea4372c
    [  555.277958] [<c0043f64>] (flush_delayed_work) from [<c00eae18>] (bdi_unregister+0x84/0xec)
    [  555.286236]  r4:eea43520 r3:20000153
    [  555.289885] [<c00ead94>] (bdi_unregister) from [<c02c2154>] (blk_cleanup_queue+0x180/0x29c)
    [  555.298250]  r5:eea43808 r4:eea43400
    [  555.301909] [<c02c1fd4>] (blk_cleanup_queue) from [<c0417914>] (__scsi_remove_device+0x48/0xb8)
    [  555.310623]  r7:00000000 r6:20000153 r5:ededa950 r4:ededa800
    [  555.316403] [<c04178cc>] (__scsi_remove_device) from [<c0415e90>] (scsi_forget_host+0x64/0x68)
    [  555.325028]  r5:ededa800 r4:ed5b5000
    [  555.328689] [<c0415e2c>] (scsi_forget_host) from [<c0409828>] (scsi_remove_host+0x78/0x104)
    [  555.337054]  r5:ed5b5068 r4:ed5b5000
    [  555.340709] [<c04097b0>] (scsi_remove_host) from [<c04cdfcc>] (usb_stor_disconnect+0x50/0xb4)
    [  555.349247]  r6:ed5b56e4 r5:ed5b5818 r4:ed5b5690 r3:00000008
    [  555.355025] [<c04cdf7c>] (usb_stor_disconnect) from [<c04b3bc8>] (usb_unbind_interface+0x78/0x25c)
    [  555.363997]  r8:c13919b4 r7:edd3c000 r6:edd3c020 r5:ee551c68 r4:ee551c00 r3:c04cdf7c
    [  555.371892] [<c04b3b50>] (usb_unbind_interface) from [<c03dc248>] (__device_release_driver+0x8c/0x118)
    [  555.381213]  r10:00000001 r9:edd90c00 r8:c13919b4 r7:ee551c68 r6:c0b546e0 r5:c0b5563c
    [  555.389167]  r4:edd3c020
    [  555.391752] [<c03dc1bc>] (__device_release_driver) from [<c03dc2fc>] (device_release_driver+0x28/0x34)
    [  555.401071]  r5:edd3c020 r4:edd3c054
    [  555.404721] [<c03dc2d4>] (device_release_driver) from [<c03db304>] (bus_remove_device+0xe0/0x110)
    [  555.413607]  r5:edd3c020 r4:ef17f04c
    [  555.417253] [<c03db224>] (bus_remove_device) from [<c03d8128>] (device_del+0x114/0x21c)
    [  555.425270]  r6:edd3c028 r5:edd3c020 r4:ee551c00 r3:00000000
    [  555.431045] [<c03d8014>] (device_del) from [<c04b1560>] (usb_disable_device+0xa4/0x1e8)
    [  555.439061]  r8:edd3c000 r7:eded8000 r6:00000000 r5:00000001 r4:ee551c00
    [  555.445906] [<c04b14bc>] (usb_disable_device) from [<c04a8e54>] (usb_disconnect+0x74/0x224)
    [  555.454271]  r9:edd90c00 r8:ee551000 r7:ee551c68 r6:ee551c9c r5:ee551c00 r4:00000001
    [  555.462156] [<c04a8de0>] (usb_disconnect) from [<c04a8fb8>] (usb_disconnect+0x1d8/0x224)
    [  555.470259]  r10:00000001 r9:edd90000 r8:ee471e2c r7:ee551468 r6:ee55149c r5:ee551400
    [  555.478213]  r4:00000001
    [  555.480797] [<c04a8de0>] (usb_disconnect) from [<c04ae5ec>] (usb_remove_hcd+0xa0/0x1ac)
    [  555.488813]  r10:00000001 r9:ee471eb0 r8:00000000 r7:ef3d9500 r6:eded810c r5:eded80b0
    [  555.496765]  r4:eded8000
    [  555.499351] [<c04ae54c>] (usb_remove_hcd) from [<c04d4158>] (host_stop+0x28/0x64)
    [  555.506847]  r6:eeb50010 r5:eded8000 r4:eeb51010
    [  555.511563] [<c04d4130>] (host_stop) from [<c04d09b8>] (ci_otg_work+0xc4/0x124)
    [  555.518885]  r6:00000001 r5:eeb50010 r4:eeb502a0 r3:c04d4130
    [  555.524665] [<c04d08f4>] (ci_otg_work) from [<c00454f0>] (process_one_work+0x194/0x420)
    [  555.532682]  r6:ef086000 r5:eeb502a0 r4:edc44480
    [  555.537393] [<c004535c>] (process_one_work) from [<c00457b0>] (worker_thread+0x34/0x514)
    [  555.545496]  r10:edc44480 r9:ef086000 r8:c0b1a100 r7:ef086034 r6:00000088 r5:edc44498
    [  555.553450]  r4:ef086000
    [  555.556032] [<c004577c>] (worker_thread) from [<c004bab4>] (kthread+0xdc/0xf8)
    [  555.563268]  r10:00000000 r9:00000000 r8:00000000 r7:c004577c r6:edc44480 r5:eddc15c0
    [  555.571221]  r4:00000000
    [  555.573804] [<c004b9d8>] (kthread) from [<c000fef0>] (ret_from_fork+0x14/0x24)
    [  555.581040]  r7:00000000 r6:00000000 r5:c004b9d8 r4:eddc15c0
    
    [  553.429383] sh              D c07de74c     0   694    691 0x00000000
    [  553.435801] Backtrace:
    [  553.438295] [<c07de4fc>] (__schedule) from [<c07dec6c>] (schedule+0x48/0xa0)
    [  553.445358]  r10:edd3c054 r9:edd3c078 r8:edddbd50 r7:edcbbc00 r6:c1377c34 r5:60000153
    [  553.453313]  r4:eddda000
    [  553.455896] [<c07dec24>] (schedule) from [<c07deff8>] (schedule_preempt_disabled+0x10/0x14)
    [  553.464261]  r4:edd3c058 r3:0000000a
    [  553.467910] [<c07defe8>] (schedule_preempt_disabled) from [<c07e0bbc>] (mutex_lock_nested+0x1a0/0x3e8)
    [  553.477254] [<c07e0a1c>] (mutex_lock_nested) from [<c03e927c>] (dpm_complete+0xc0/0x1b0)
    [  553.485358]  r10:00561408 r9:edd3c054 r8:c0b4863c r7:edddbd90 r6:c0b485d8 r5:edd3c020
    [  553.493313]  r4:edd3c0d0
    [  553.495896] [<c03e91bc>] (dpm_complete) from [<c03e9388>] (dpm_resume_end+0x1c/0x20)
    [  553.503652]  r9:00000000 r8:c0b1a9d0 r7:c1334ec0 r6:c1334edc r5:00000003 r4:00000010
    [  553.511544] [<c03e936c>] (dpm_resume_end) from [<c0079894>] (suspend_devices_and_enter+0x158/0x504)
    [  553.520604]  r4:00000000 r3:c1334efc
    [  553.524250] [<c007973c>] (suspend_devices_and_enter) from [<c0079e74>] (pm_suspend+0x234/0x2cc)
    [  553.532961]  r10:00561408 r9:ed6b7300 r8:00000004 r7:c1334eec r6:00000000 r5:c1334ee8
    [  553.540914]  r4:00000003
    [  553.543493] [<c0079c40>] (pm_suspend) from [<c0078a6c>] (state_store+0x6c/0xc0)
    
    [  555.703684] 7 locks held by kworker/u2:13/826:
    [  555.708140]  #0:  ("%s""ci_otg"){++++.+}, at: [<c0045484>] process_one_work+0x128/0x420
    [  555.716277]  #1:  ((&ci->work)){+.+.+.}, at: [<c0045484>] process_one_work+0x128/0x420
    [  555.724317]  #2:  (usb_bus_list_lock){+.+.+.}, at: [<c04ae5e4>] usb_remove_hcd+0x98/0x1ac
    [  555.732626]  #3:  (&dev->mutex){......}, at: [<c04a8e28>] usb_disconnect+0x48/0x224
    [  555.740403]  #4:  (&dev->mutex){......}, at: [<c04a8e28>] usb_disconnect+0x48/0x224
    [  555.748179]  #5:  (&dev->mutex){......}, at: [<c03dc2f4>] device_release_driver+0x20/0x34
    [  555.756487]  #6:  (&shost->scan_mutex){+.+.+.}, at: [<c04097d0>] scsi_remove_host+0x20/0x104
    
    Cc: Jun Li <jun.li@nxp.com>
    Signed-off-by: Peter Chen <peter.chen@nxp.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 49670184289e48451171179470a7dbbdb63f9549
Author: Peter Chen <peter.chen@nxp.com>
Date:   Wed Feb 24 11:05:25 2016 +0800

    usb: chipidea: otg: change workqueue ci_otg as freezable
    
    [ Upstream commit d144dfea8af7108f613139623e63952ed7e69c0c ]
    
    If we use USB ID pin as wakeup source, and there is a USB block
    device on this USB OTG (ID) cable, the system will be deadlock
    after system resume.
    
    The root cause for this problem is: the workqueue ci_otg may try
    to remove hcd before the driver resume has finished, and hcd will
    disconnect the device on it, then, it will call device_release_driver,
    and holds the device lock "dev->mutex", but it is never unlocked since
    it waits workqueue writeback to run to flush the block information, but
    the workqueue writeback is freezable, it is not thawed before driver
    resume has finished.
    
    When the driver (device: sd 0:0:0:0:) resume goes to dpm_complete, it
    tries to get its device lock "dev->mutex", but it can't get it forever,
    then the deadlock occurs. Below call stacks show the situation.
    
    So, in order to fix this problem, we need to change workqueue ci_otg
    as freezable, then the work item in this workqueue will be run after
    driver's resume, this workqueue will not be blocked forever like above
    case since the workqueue writeback has been thawed too.
    
    Tested at: i.mx6qdl-sabresd and i.mx6sx-sdb.
    
    [  555.178869] kworker/u2:13   D c07de74c     0   826      2 0x00000000
    [  555.185310] Workqueue: ci_otg ci_otg_work
    [  555.189353] Backtrace:
    [  555.191849] [<c07de4fc>] (__schedule) from [<c07dec6c>] (schedule+0x48/0xa0)
    [  555.198912]  r10:ee471ba0 r9:00000000 r8:00000000 r7:00000002 r6:ee470000 r5:ee471ba4
    [  555.206867]  r4:ee470000
    [  555.209453] [<c07dec24>] (schedule) from [<c07e2fc4>] (schedule_timeout+0x15c/0x1e0)
    [  555.217212]  r4:7fffffff r3:edc2b000
    [  555.220862] [<c07e2e68>] (schedule_timeout) from [<c07df6c8>] (wait_for_common+0x94/0x144)
    [  555.229140]  r8:00000000 r7:00000002 r6:ee470000 r5:ee471ba4 r4:7fffffff
    [  555.235980] [<c07df634>] (wait_for_common) from [<c07df790>] (wait_for_completion+0x18/0x1c)
    [  555.244430]  r10:00000001 r9:c0b5563c r8:c0042e48 r7:ef086000 r6:eea4372c r5:ef131b00
    [  555.252383]  r4:00000000
    [  555.254970] [<c07df778>] (wait_for_completion) from [<c0043cb8>] (flush_work+0x19c/0x234)
    [  555.263177] [<c0043b1c>] (flush_work) from [<c0043fac>] (flush_delayed_work+0x48/0x4c)
    [  555.271106]  r8:ed5b5000 r7:c0b38a3c r6:eea439cc r5:eea4372c r4:eea4372c
    [  555.277958] [<c0043f64>] (flush_delayed_work) from [<c00eae18>] (bdi_unregister+0x84/0xec)
    [  555.286236]  r4:eea43520 r3:20000153
    [  555.289885] [<c00ead94>] (bdi_unregister) from [<c02c2154>] (blk_cleanup_queue+0x180/0x29c)
    [  555.298250]  r5:eea43808 r4:eea43400
    [  555.301909] [<c02c1fd4>] (blk_cleanup_queue) from [<c0417914>] (__scsi_remove_device+0x48/0xb8)
    [  555.310623]  r7:00000000 r6:20000153 r5:ededa950 r4:ededa800
    [  555.316403] [<c04178cc>] (__scsi_remove_device) from [<c0415e90>] (scsi_forget_host+0x64/0x68)
    [  555.325028]  r5:ededa800 r4:ed5b5000
    [  555.328689] [<c0415e2c>] (scsi_forget_host) from [<c0409828>] (scsi_remove_host+0x78/0x104)
    [  555.337054]  r5:ed5b5068 r4:ed5b5000
    [  555.340709] [<c04097b0>] (scsi_remove_host) from [<c04cdfcc>] (usb_stor_disconnect+0x50/0xb4)
    [  555.349247]  r6:ed5b56e4 r5:ed5b5818 r4:ed5b5690 r3:00000008
    [  555.355025] [<c04cdf7c>] (usb_stor_disconnect) from [<c04b3bc8>] (usb_unbind_interface+0x78/0x25c)
    [  555.363997]  r8:c13919b4 r7:edd3c000 r6:edd3c020 r5:ee551c68 r4:ee551c00 r3:c04cdf7c
    [  555.371892] [<c04b3b50>] (usb_unbind_interface) from [<c03dc248>] (__device_release_driver+0x8c/0x118)
    [  555.381213]  r10:00000001 r9:edd90c00 r8:c13919b4 r7:ee551c68 r6:c0b546e0 r5:c0b5563c
    [  555.389167]  r4:edd3c020
    [  555.391752] [<c03dc1bc>] (__device_release_driver) from [<c03dc2fc>] (device_release_driver+0x28/0x34)
    [  555.401071]  r5:edd3c020 r4:edd3c054
    [  555.404721] [<c03dc2d4>] (device_release_driver) from [<c03db304>] (bus_remove_device+0xe0/0x110)
    [  555.413607]  r5:edd3c020 r4:ef17f04c
    [  555.417253] [<c03db224>] (bus_remove_device) from [<c03d8128>] (device_del+0x114/0x21c)
    [  555.425270]  r6:edd3c028 r5:edd3c020 r4:ee551c00 r3:00000000
    [  555.431045] [<c03d8014>] (device_del) from [<c04b1560>] (usb_disable_device+0xa4/0x1e8)
    [  555.439061]  r8:edd3c000 r7:eded8000 r6:00000000 r5:00000001 r4:ee551c00
    [  555.445906] [<c04b14bc>] (usb_disable_device) from [<c04a8e54>] (usb_disconnect+0x74/0x224)
    [  555.454271]  r9:edd90c00 r8:ee551000 r7:ee551c68 r6:ee551c9c r5:ee551c00 r4:00000001
    [  555.462156] [<c04a8de0>] (usb_disconnect) from [<c04a8fb8>] (usb_disconnect+0x1d8/0x224)
    [  555.470259]  r10:00000001 r9:edd90000 r8:ee471e2c r7:ee551468 r6:ee55149c r5:ee551400
    [  555.478213]  r4:00000001
    [  555.480797] [<c04a8de0>] (usb_disconnect) from [<c04ae5ec>] (usb_remove_hcd+0xa0/0x1ac)
    [  555.488813]  r10:00000001 r9:ee471eb0 r8:00000000 r7:ef3d9500 r6:eded810c r5:eded80b0
    [  555.496765]  r4:eded8000
    [  555.499351] [<c04ae54c>] (usb_remove_hcd) from [<c04d4158>] (host_stop+0x28/0x64)
    [  555.506847]  r6:eeb50010 r5:eded8000 r4:eeb51010
    [  555.511563] [<c04d4130>] (host_stop) from [<c04d09b8>] (ci_otg_work+0xc4/0x124)
    [  555.518885]  r6:00000001 r5:eeb50010 r4:eeb502a0 r3:c04d4130
    [  555.524665] [<c04d08f4>] (ci_otg_work) from [<c00454f0>] (process_one_work+0x194/0x420)
    [  555.532682]  r6:ef086000 r5:eeb502a0 r4:edc44480
    [  555.537393] [<c004535c>] (process_one_work) from [<c00457b0>] (worker_thread+0x34/0x514)
    [  555.545496]  r10:edc44480 r9:ef086000 r8:c0b1a100 r7:ef086034 r6:00000088 r5:edc44498
    [  555.553450]  r4:ef086000
    [  555.556032] [<c004577c>] (worker_thread) from [<c004bab4>] (kthread+0xdc/0xf8)
    [  555.563268]  r10:00000000 r9:00000000 r8:00000000 r7:c004577c r6:edc44480 r5:eddc15c0
    [  555.571221]  r4:00000000
    [  555.573804] [<c004b9d8>] (kthread) from [<c000fef0>] (ret_from_fork+0x14/0x24)
    [  555.581040]  r7:00000000 r6:00000000 r5:c004b9d8 r4:eddc15c0
    
    [  553.429383] sh              D c07de74c     0   694    691 0x00000000
    [  553.435801] Backtrace:
    [  553.438295] [<c07de4fc>] (__schedule) from [<c07dec6c>] (schedule+0x48/0xa0)
    [  553.445358]  r10:edd3c054 r9:edd3c078 r8:edddbd50 r7:edcbbc00 r6:c1377c34 r5:60000153
    [  553.453313]  r4:eddda000
    [  553.455896] [<c07dec24>] (schedule) from [<c07deff8>] (schedule_preempt_disabled+0x10/0x14)
    [  553.464261]  r4:edd3c058 r3:0000000a
    [  553.467910] [<c07defe8>] (schedule_preempt_disabled) from [<c07e0bbc>] (mutex_lock_nested+0x1a0/0x3e8)
    [  553.477254] [<c07e0a1c>] (mutex_lock_nested) from [<c03e927c>] (dpm_complete+0xc0/0x1b0)
    [  553.485358]  r10:00561408 r9:edd3c054 r8:c0b4863c r7:edddbd90 r6:c0b485d8 r5:edd3c020
    [  553.493313]  r4:edd3c0d0
    [  553.495896] [<c03e91bc>] (dpm_complete) from [<c03e9388>] (dpm_resume_end+0x1c/0x20)
    [  553.503652]  r9:00000000 r8:c0b1a9d0 r7:c1334ec0 r6:c1334edc r5:00000003 r4:00000010
    [  553.511544] [<c03e936c>] (dpm_resume_end) from [<c0079894>] (suspend_devices_and_enter+0x158/0x504)
    [  553.520604]  r4:00000000 r3:c1334efc
    [  553.524250] [<c007973c>] (suspend_devices_and_enter) from [<c0079e74>] (pm_suspend+0x234/0x2cc)
    [  553.532961]  r10:00561408 r9:ed6b7300 r8:00000004 r7:c1334eec r6:00000000 r5:c1334ee8
    [  553.540914]  r4:00000003
    [  553.543493] [<c0079c40>] (pm_suspend) from [<c0078a6c>] (state_store+0x6c/0xc0)
    
    [  555.703684] 7 locks held by kworker/u2:13/826:
    [  555.708140]  #0:  ("%s""ci_otg"){++++.+}, at: [<c0045484>] process_one_work+0x128/0x420
    [  555.716277]  #1:  ((&ci->work)){+.+.+.}, at: [<c0045484>] process_one_work+0x128/0x420
    [  555.724317]  #2:  (usb_bus_list_lock){+.+.+.}, at: [<c04ae5e4>] usb_remove_hcd+0x98/0x1ac
    [  555.732626]  #3:  (&dev->mutex){......}, at: [<c04a8e28>] usb_disconnect+0x48/0x224
    [  555.740403]  #4:  (&dev->mutex){......}, at: [<c04a8e28>] usb_disconnect+0x48/0x224
    [  555.748179]  #5:  (&dev->mutex){......}, at: [<c03dc2f4>] device_release_driver+0x20/0x34
    [  555.756487]  #6:  (&shost->scan_mutex){+.+.+.}, at: [<c04097d0>] scsi_remove_host+0x20/0x104
    
    Cc: <stable@vger.kernel.org> #v3.14+
    Cc: Jun Li <jun.li@nxp.com>
    Signed-off-by: Peter Chen <peter.chen@nxp.com>
    Signed-off-by: Sasha Levin <sasha.levin@oracle.com>

commit d144dfea8af7108f613139623e63952ed7e69c0c
Author: Peter Chen <peter.chen@nxp.com>
Date:   Wed Feb 24 11:05:25 2016 +0800

    usb: chipidea: otg: change workqueue ci_otg as freezable
    
    If we use USB ID pin as wakeup source, and there is a USB block
    device on this USB OTG (ID) cable, the system will be deadlock
    after system resume.
    
    The root cause for this problem is: the workqueue ci_otg may try
    to remove hcd before the driver resume has finished, and hcd will
    disconnect the device on it, then, it will call device_release_driver,
    and holds the device lock "dev->mutex", but it is never unlocked since
    it waits workqueue writeback to run to flush the block information, but
    the workqueue writeback is freezable, it is not thawed before driver
    resume has finished.
    
    When the driver (device: sd 0:0:0:0:) resume goes to dpm_complete, it
    tries to get its device lock "dev->mutex", but it can't get it forever,
    then the deadlock occurs. Below call stacks show the situation.
    
    So, in order to fix this problem, we need to change workqueue ci_otg
    as freezable, then the work item in this workqueue will be run after
    driver's resume, this workqueue will not be blocked forever like above
    case since the workqueue writeback has been thawed too.
    
    Tested at: i.mx6qdl-sabresd and i.mx6sx-sdb.
    
    [  555.178869] kworker/u2:13   D c07de74c     0   826      2 0x00000000
    [  555.185310] Workqueue: ci_otg ci_otg_work
    [  555.189353] Backtrace:
    [  555.191849] [<c07de4fc>] (__schedule) from [<c07dec6c>] (schedule+0x48/0xa0)
    [  555.198912]  r10:ee471ba0 r9:00000000 r8:00000000 r7:00000002 r6:ee470000 r5:ee471ba4
    [  555.206867]  r4:ee470000
    [  555.209453] [<c07dec24>] (schedule) from [<c07e2fc4>] (schedule_timeout+0x15c/0x1e0)
    [  555.217212]  r4:7fffffff r3:edc2b000
    [  555.220862] [<c07e2e68>] (schedule_timeout) from [<c07df6c8>] (wait_for_common+0x94/0x144)
    [  555.229140]  r8:00000000 r7:00000002 r6:ee470000 r5:ee471ba4 r4:7fffffff
    [  555.235980] [<c07df634>] (wait_for_common) from [<c07df790>] (wait_for_completion+0x18/0x1c)
    [  555.244430]  r10:00000001 r9:c0b5563c r8:c0042e48 r7:ef086000 r6:eea4372c r5:ef131b00
    [  555.252383]  r4:00000000
    [  555.254970] [<c07df778>] (wait_for_completion) from [<c0043cb8>] (flush_work+0x19c/0x234)
    [  555.263177] [<c0043b1c>] (flush_work) from [<c0043fac>] (flush_delayed_work+0x48/0x4c)
    [  555.271106]  r8:ed5b5000 r7:c0b38a3c r6:eea439cc r5:eea4372c r4:eea4372c
    [  555.277958] [<c0043f64>] (flush_delayed_work) from [<c00eae18>] (bdi_unregister+0x84/0xec)
    [  555.286236]  r4:eea43520 r3:20000153
    [  555.289885] [<c00ead94>] (bdi_unregister) from [<c02c2154>] (blk_cleanup_queue+0x180/0x29c)
    [  555.298250]  r5:eea43808 r4:eea43400
    [  555.301909] [<c02c1fd4>] (blk_cleanup_queue) from [<c0417914>] (__scsi_remove_device+0x48/0xb8)
    [  555.310623]  r7:00000000 r6:20000153 r5:ededa950 r4:ededa800
    [  555.316403] [<c04178cc>] (__scsi_remove_device) from [<c0415e90>] (scsi_forget_host+0x64/0x68)
    [  555.325028]  r5:ededa800 r4:ed5b5000
    [  555.328689] [<c0415e2c>] (scsi_forget_host) from [<c0409828>] (scsi_remove_host+0x78/0x104)
    [  555.337054]  r5:ed5b5068 r4:ed5b5000
    [  555.340709] [<c04097b0>] (scsi_remove_host) from [<c04cdfcc>] (usb_stor_disconnect+0x50/0xb4)
    [  555.349247]  r6:ed5b56e4 r5:ed5b5818 r4:ed5b5690 r3:00000008
    [  555.355025] [<c04cdf7c>] (usb_stor_disconnect) from [<c04b3bc8>] (usb_unbind_interface+0x78/0x25c)
    [  555.363997]  r8:c13919b4 r7:edd3c000 r6:edd3c020 r5:ee551c68 r4:ee551c00 r3:c04cdf7c
    [  555.371892] [<c04b3b50>] (usb_unbind_interface) from [<c03dc248>] (__device_release_driver+0x8c/0x118)
    [  555.381213]  r10:00000001 r9:edd90c00 r8:c13919b4 r7:ee551c68 r6:c0b546e0 r5:c0b5563c
    [  555.389167]  r4:edd3c020
    [  555.391752] [<c03dc1bc>] (__device_release_driver) from [<c03dc2fc>] (device_release_driver+0x28/0x34)
    [  555.401071]  r5:edd3c020 r4:edd3c054
    [  555.404721] [<c03dc2d4>] (device_release_driver) from [<c03db304>] (bus_remove_device+0xe0/0x110)
    [  555.413607]  r5:edd3c020 r4:ef17f04c
    [  555.417253] [<c03db224>] (bus_remove_device) from [<c03d8128>] (device_del+0x114/0x21c)
    [  555.425270]  r6:edd3c028 r5:edd3c020 r4:ee551c00 r3:00000000
    [  555.431045] [<c03d8014>] (device_del) from [<c04b1560>] (usb_disable_device+0xa4/0x1e8)
    [  555.439061]  r8:edd3c000 r7:eded8000 r6:00000000 r5:00000001 r4:ee551c00
    [  555.445906] [<c04b14bc>] (usb_disable_device) from [<c04a8e54>] (usb_disconnect+0x74/0x224)
    [  555.454271]  r9:edd90c00 r8:ee551000 r7:ee551c68 r6:ee551c9c r5:ee551c00 r4:00000001
    [  555.462156] [<c04a8de0>] (usb_disconnect) from [<c04a8fb8>] (usb_disconnect+0x1d8/0x224)
    [  555.470259]  r10:00000001 r9:edd90000 r8:ee471e2c r7:ee551468 r6:ee55149c r5:ee551400
    [  555.478213]  r4:00000001
    [  555.480797] [<c04a8de0>] (usb_disconnect) from [<c04ae5ec>] (usb_remove_hcd+0xa0/0x1ac)
    [  555.488813]  r10:00000001 r9:ee471eb0 r8:00000000 r7:ef3d9500 r6:eded810c r5:eded80b0
    [  555.496765]  r4:eded8000
    [  555.499351] [<c04ae54c>] (usb_remove_hcd) from [<c04d4158>] (host_stop+0x28/0x64)
    [  555.506847]  r6:eeb50010 r5:eded8000 r4:eeb51010
    [  555.511563] [<c04d4130>] (host_stop) from [<c04d09b8>] (ci_otg_work+0xc4/0x124)
    [  555.518885]  r6:00000001 r5:eeb50010 r4:eeb502a0 r3:c04d4130
    [  555.524665] [<c04d08f4>] (ci_otg_work) from [<c00454f0>] (process_one_work+0x194/0x420)
    [  555.532682]  r6:ef086000 r5:eeb502a0 r4:edc44480
    [  555.537393] [<c004535c>] (process_one_work) from [<c00457b0>] (worker_thread+0x34/0x514)
    [  555.545496]  r10:edc44480 r9:ef086000 r8:c0b1a100 r7:ef086034 r6:00000088 r5:edc44498
    [  555.553450]  r4:ef086000
    [  555.556032] [<c004577c>] (worker_thread) from [<c004bab4>] (kthread+0xdc/0xf8)
    [  555.563268]  r10:00000000 r9:00000000 r8:00000000 r7:c004577c r6:edc44480 r5:eddc15c0
    [  555.571221]  r4:00000000
    [  555.573804] [<c004b9d8>] (kthread) from [<c000fef0>] (ret_from_fork+0x14/0x24)
    [  555.581040]  r7:00000000 r6:00000000 r5:c004b9d8 r4:eddc15c0
    
    [  553.429383] sh              D c07de74c     0   694    691 0x00000000
    [  553.435801] Backtrace:
    [  553.438295] [<c07de4fc>] (__schedule) from [<c07dec6c>] (schedule+0x48/0xa0)
    [  553.445358]  r10:edd3c054 r9:edd3c078 r8:edddbd50 r7:edcbbc00 r6:c1377c34 r5:60000153
    [  553.453313]  r4:eddda000
    [  553.455896] [<c07dec24>] (schedule) from [<c07deff8>] (schedule_preempt_disabled+0x10/0x14)
    [  553.464261]  r4:edd3c058 r3:0000000a
    [  553.467910] [<c07defe8>] (schedule_preempt_disabled) from [<c07e0bbc>] (mutex_lock_nested+0x1a0/0x3e8)
    [  553.477254] [<c07e0a1c>] (mutex_lock_nested) from [<c03e927c>] (dpm_complete+0xc0/0x1b0)
    [  553.485358]  r10:00561408 r9:edd3c054 r8:c0b4863c r7:edddbd90 r6:c0b485d8 r5:edd3c020
    [  553.493313]  r4:edd3c0d0
    [  553.495896] [<c03e91bc>] (dpm_complete) from [<c03e9388>] (dpm_resume_end+0x1c/0x20)
    [  553.503652]  r9:00000000 r8:c0b1a9d0 r7:c1334ec0 r6:c1334edc r5:00000003 r4:00000010
    [  553.511544] [<c03e936c>] (dpm_resume_end) from [<c0079894>] (suspend_devices_and_enter+0x158/0x504)
    [  553.520604]  r4:00000000 r3:c1334efc
    [  553.524250] [<c007973c>] (suspend_devices_and_enter) from [<c0079e74>] (pm_suspend+0x234/0x2cc)
    [  553.532961]  r10:00561408 r9:ed6b7300 r8:00000004 r7:c1334eec r6:00000000 r5:c1334ee8
    [  553.540914]  r4:00000003
    [  553.543493] [<c0079c40>] (pm_suspend) from [<c0078a6c>] (state_store+0x6c/0xc0)
    
    [  555.703684] 7 locks held by kworker/u2:13/826:
    [  555.708140]  #0:  ("%s""ci_otg"){++++.+}, at: [<c0045484>] process_one_work+0x128/0x420
    [  555.716277]  #1:  ((&ci->work)){+.+.+.}, at: [<c0045484>] process_one_work+0x128/0x420
    [  555.724317]  #2:  (usb_bus_list_lock){+.+.+.}, at: [<c04ae5e4>] usb_remove_hcd+0x98/0x1ac
    [  555.732626]  #3:  (&dev->mutex){......}, at: [<c04a8e28>] usb_disconnect+0x48/0x224
    [  555.740403]  #4:  (&dev->mutex){......}, at: [<c04a8e28>] usb_disconnect+0x48/0x224
    [  555.748179]  #5:  (&dev->mutex){......}, at: [<c03dc2f4>] device_release_driver+0x20/0x34
    [  555.756487]  #6:  (&shost->scan_mutex){+.+.+.}, at: [<c04097d0>] scsi_remove_host+0x20/0x104
    
    Cc: <stable@vger.kernel.org> #v3.14+
    Cc: Jun Li <jun.li@nxp.com>
    Signed-off-by: Peter Chen <peter.chen@nxp.com>

commit ea49c9acf2db7082f0406bb3a570cc6bad37082b
Author: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Date:   Tue Feb 16 15:27:42 2016 +0100

    drm/i915: Lock mode_config.mutex in intel_display_resume.
    
    Unfortunately i915 is still not fully atomic, and expects mode_config.mutex
    to be held during modeset until we finally fix it.
    
    This fixes the following WARN when resuming:
    
    [  425.208983] ------------[ cut here ]------------
    [  425.208990] WARNING: CPU: 0 PID: 6828 at drivers/gpu/drm/drm_edid.c:3555 drm_select_eld+0xa5/0xd0()
    [  425.209015] Modules linked in: pl2303 usbserial snd_hda_codec_hdmi snd_hda_codec_realtek snd_hda_codec_generic intel_powerclamp coretemp i915 crct10dif_pclmul crc32_pclmul ghash_clmulni_intel snd_hda_intel snd_hda_codec snd_hwdep lpc_ich snd_hda_core snd_pcm i2c_hid i2c_designware_platform i2c_designware_core r8169 mii sdhci_acpi sdhci mmc_core
    [  425.209018] CPU: 0 PID: 6828 Comm: kworker/u4:5 Tainted: G     U  W       4.5.0-rc4-gfxbench+ #1
    [  425.209020] Hardware name: \xffffffff\xffffffff\xffffffff\xffffffff\xffffffff\xffffffff\xffffffff\xffffffff\xffffffff\xffffffff\xffffffff\xffffffff\xffffffff\xffffffff\xffffffff\xffffffff\xffffffff\xffffffff\xffffffff\xffffffff\xffffffff\xffffffff\xffffffff\xffffffff\xffffffff\xffffffff\xffffffff\xffffffff\xffffffff\xffffffff\xffffffff\xffffffff\xffffffff \xffffffff\xffffffff\xffffffff\xffffffff\xffffffff\xffffffff\xffffffff\xffffffff\xffffffff\xffffffff\xffffffff\xffffffff\xffffffff\xffffffff\xffffffff\xffffffff\xffffffff\xffffffff\xffffffff\xffffffff\xffffffff\xffffffff\xffffffff\xffffffff\xffffffff\xffffffff\xffffffff\xffffffff\xffffffff\xffffffff\xffffffff\xffffffff\xffffffff/DN2820FYK, BIOS FYBYT10H.86A.0038.2014.0717.1455 07/17/2014
    [  425.209027] Workqueue: events_unbound async_run_entry_fn
    [  425.209032]  0000000000000000 ffff880072433958 ffffffff813f6b05 0000000000000000
    [  425.209036]  ffffffff81aaef2d ffff880072433990 ffffffff81078291 ffff880036b933d8
    [  425.209039]  ffff88006d528000 ffff88006d52b3d8 ffff88006d52b3d8 ffff88007315b6f8
    [  425.209040] Call Trace:
    [  425.209045]  [<ffffffff813f6b05>] dump_stack+0x67/0x92
    [  425.209049]  [<ffffffff81078291>] warn_slowpath_common+0x81/0xc0
    [  425.209052]  [<ffffffff81078385>] warn_slowpath_null+0x15/0x20
    [  425.209054]  [<ffffffff8151e195>] drm_select_eld+0xa5/0xd0
    [  425.209101]  [<ffffffffa01f34f4>] intel_audio_codec_enable+0x44/0x160 [i915]
    [  425.209135]  [<ffffffffa023eac7>] intel_enable_hdmi_audio+0x87/0x90 [i915]
    [  425.209169]  [<ffffffffa023eb5a>] g4x_enable_hdmi+0x8a/0xa0 [i915]
    [  425.209202]  [<ffffffffa023f41b>] vlv_hdmi_pre_enable+0x1cb/0x240 [i915]
    [  425.209236]  [<ffffffffa020edcf>] valleyview_crtc_enable+0x10f/0x290 [i915]
    [  425.209270]  [<ffffffffa020ba49>] intel_atomic_commit+0x769/0x17a0 [i915]
    [  425.209274]  [<ffffffff81526ad5>] ? drm_atomic_check_only+0x145/0x660
    [  425.209276]  [<ffffffff81527022>] drm_atomic_commit+0x32/0x50
    [  425.209310]  [<ffffffffa0215fa0>] intel_display_resume+0xa0/0x130 [i915]
    [  425.209338]  [<ffffffffa018c1bb>] i915_drm_resume+0xcb/0x160 [i915]
    [  425.209366]  [<ffffffffa018c272>] i915_pm_resume+0x22/0x30 [i915]
    [  425.209370]  [<ffffffff8143d91e>] pci_pm_resume+0x6e/0xe0
    [  425.209373]  [<ffffffff8143d8b0>] ? pci_pm_resume_noirq+0xa0/0xa0
    [  425.209375]  [<ffffffff815409ae>] dpm_run_callback+0x6e/0x280
    [  425.209378]  [<ffffffff815410b2>] device_resume+0x92/0x250
    [  425.209380]  [<ffffffff81541288>] async_resume+0x18/0x40
    [  425.209382]  [<ffffffff8109c7a5>] async_run_entry_fn+0x45/0x140
    [  425.209386]  [<ffffffff81093293>] process_one_work+0x1e3/0x620
    [  425.209388]  [<ffffffff810931f7>] ? process_one_work+0x147/0x620
    [  425.209391]  [<ffffffff81093719>] worker_thread+0x49/0x490
    [  425.209393]  [<ffffffff810936d0>] ? process_one_work+0x620/0x620
    [  425.209396]  [<ffffffff81099e0a>] kthread+0xea/0x100
    [  425.209400]  [<ffffffff81099d20>] ? kthread_create_on_node+0x1f0/0x1f0
    [  425.209404]  [<ffffffff817ba03f>] ret_from_fork+0x3f/0x70
    [  425.209407]  [<ffffffff81099d20>] ? kthread_create_on_node+0x1f0/0x1f0
    [  425.209409] ---[ end trace d1b247107f34a8b2 ]---
    
    Fixes: e2c8b8701e2d ("drm/i915: Use atomic helpers for suspend, v2.")
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1455632862-18557-1-git-send-email-maarten.lankhorst@linux.intel.com
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>

commit 50eca2561beb0b7d3d43287b9e7cf8a39301c346
Author: Sam Protsenko <semen.protsenko@linaro.org>
Date:   Thu Dec 10 18:06:59 2015 +0200

    crypto: omap-des - Fix "schedule while atomic" bug
    
    When using DES module the next bug appears:
    
        BUG: scheduling while atomic: kworker/0:1/63/0x00000102
    
    With backtrace as follows:
    
    <<<<<<<<<<<<<<<<<<<<<<<<<<<<<< cut here >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
    
    [<c0012294>] (dump_backtrace) from [<c00124ac>] (show_stack+0x18/0x1c)
    [<c0012494>] (show_stack) from [<c0752554>] (dump_stack+0x84/0xc4)
    [<c07524d0>] (dump_stack) from [<c0750218>] (__schedule_bug+0x54/0x64)
    [<c07501c4>] (__schedule_bug) from [<c07548a4>] (__schedule+0x4ac/0x53c)
    [<c07543f8>] (__schedule) from [<c075496c>] (schedule+0x38/0x88)
    [<c0754934>] (schedule) from [<c03c3984>] (rpm_resume+0x158/0x59c)
    [<c03c382c>] (rpm_resume) from [<c03c3e1c>] (__pm_runtime_resume+0x54/0x6c)
    [<c03c3dc8>] (__pm_runtime_resume) from [<c0568ff8>] (omap_des_handle_queue+0x154/0x7bc)
    [<c0568ea4>] (omap_des_handle_queue) from [<c05696b8>] (omap_des_crypt+0x58/0xbc)
    [<c0569660>] (omap_des_crypt) from [<c0569730>] (omap_des_cbc_decrypt+0x14/0x18)
    [<c056971c>] (omap_des_cbc_decrypt) from [<c0297534>] (authenc_verify_ahash_done+0xe0/0xe8)
    [<c0297454>] (authenc_verify_ahash_done) from [<c056a330>] (omap_sham_finish_req+0x58/0xa8)
    [<c056a2d8>] (omap_sham_finish_req) from [<c056b714>] (omap_sham_done_task+0x1c0/0x1e0)
    [<c056b554>] (omap_sham_done_task) from [<c003e53c>] (tasklet_action+0x80/0x118)
    [<c003e4bc>] (tasklet_action) from [<c003e740>] (__do_softirq+0x11c/0x260)
    [<c003e624>] (__do_softirq) from [<c003eb64>] (irq_exit+0xc0/0xfc)
    [<c003eaa4>] (irq_exit) from [<c000f1c4>] (handle_IRQ+0x4c/0x98)
    [<c000f178>] (handle_IRQ) from [<c0008568>] (gic_handle_irq+0x34/0x64)
    [<c0008534>] (gic_handle_irq) from [<c0758540>] (__irq_svc+0x40/0x70)
    
    <<<<<<<<<<<<<<<<<<<<<<<<<<<<<< cut here >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
    
    Insight was seen in drivers/crypto/omap-sham.c driver.
    All credits for this patch go to Grygorii Strashko.
    
    Signed-off-by: Sam Protsenko <semen.protsenko@linaro.org>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

commit 29f5b34ca1a191c2cf4f6c8c12f4dec56e8d3bc1
Author: Neil Armstrong <narmstrong@baylibre.com>
Date:   Fri Nov 13 17:29:53 2015 +0100

    arm: omap2+: add missing HWMOD_NO_IDLEST in 81xx hwmod data
    
    Add missing HWMOD_NO_IDLEST hwmod flag for entries not
    having omap4 clkctrl values.
    The emac0 hwmod flag fixes the davinci_emac driver probe
    since the return of pm_resume() call is now checked.
    
    This solves the following boot errors :
    [    0.121429] omap_hwmod: l4_ls: _wait_target_ready failed: -16
    [    0.121441] omap_hwmod: l4_ls: cannot be enabled for reset (3)
    [    0.124342] omap_hwmod: l4_hs: _wait_target_ready failed: -16
    [    0.124352] omap_hwmod: l4_hs: cannot be enabled for reset (3)
    [    1.967228] omap_hwmod: emac0: _wait_target_ready failed: -16
    
    Cc: Brian Hutchinson <b.hutchman@gmail.com>
    Signed-off-by: Neil Armstrong <narmstrong@baylibre.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

commit 0122835a020a9f5c007b3a49ea9b5f1ac68fc7c7
Merge: 45d80f168d27 b9b6e4ac2da7
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Oct 23 18:21:55 2015 +0900

    Merge tag 'sound-4.3-rc7' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound
    
    Pull sound fixes from Takashi Iwai:
     "There is nothing to worry you much, only a few small & stable patches
      are found for usual stuff, HD-audio (a Lenovo laptop quirk, a fix for
      minor error handling) and ASoC (trivial fixes for RT298 and WM
      codecs).
    
      The only remaining major change is the fix for ASoC SX_TLV control
      that was overseen during refactoring, but the fix itself is trivial
      and safe"
    
    * tag 'sound-4.3-rc7' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound:
      ASoC: wm8962: mark cache_dirty flag after software reset in pm_resume
      ASoC: rt298: fix wrong setting of gpio2_en
      ASoC: wm8904: Correct number of EQ registers
      ALSA: hda - Fix deadlock at error in building PCM
      ASoC: Add info callback for SX_TLV controls
      ASoC: rt298: correct index default value
      ALSA: hda - Fix inverted internal mic on Lenovo G50-80
      ALSA: hdac: Explicitly add io.h

commit 4eb0f7abcefad2d4c127aa7502d3122635eddab0
Author: Jiada Wang <jiada_wang@mentor.com>
Date:   Tue Oct 20 11:47:11 2015 +0900

    ASoC: wm8962: mark cache_dirty flag after software reset in pm_resume
    
    By doing software reset of wm8962 in pm_resume, all registers which
    have already been set will be reset to default value without regmap
    interface be involved, thus driver need to mark cache_dirty flag,
    to let regcache can be updated by regcache_sync().
    
    Signed-off-by: Jiada Wang <jiada_wang@mentor.com>
    Acked-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

commit 1c5dd13459fe7caaeda82f7be878720c978d26f2
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Oct 7 03:03:57 2015 +0200

    input: i8042: Avoid resetting controller on system suspend/resume
    
    If the upcoming system suspend is not going to be handled by the
    platform firmware, like in the suspend-to-idle case, it is not
    necessary to reset the controller in i8042_pm_suspend(), so avoid
    doing that.
    
    Moreover, if the system resume currently in progress has not been
    started by the platform firmware, like in the suspend-to-idle case,
    i8042_controller_resume() need not be called by i8042_pm_resume(),
    so avoid doing that too in that case.
    
    Additionally, try to catch the event that woke up the system by
    calling the interrupt handler early during system resume if it has
    not been started by the platform firmware.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

commit dc2280ebf45bfa4fbc4b1588a6642aa33454a9b8
Author: Wang Dongsheng <dongsheng.wang@freescale.com>
Date:   Wed Aug 12 17:14:13 2015 +0800

    rtc: ds3232: fix WARNING trace in resume function
    
    If ds3232 work on some platform that is not implementing
    irq_set_wake, ds3232 will get a WARNING trace in resume.
    So fix ds3232->suspended state to false when irq_set_irq_wake
    return error.
    
    WARNING: CPU: 0 PID: 729 at kernel/irq/manage.c:604 irq_set_irq_wake+0x4b/0x8c()
    Unbalanced IRQ 201 wake disable
    Modules linked in:
    CPU: 0 PID: 729 Comm: sh Not tainted 3.12.19-rt30+ #25
    [<800107d9>] (unwind_backtrace+0x1/0x88) from [<8000e4ef>] (show_stack+0xb/0xc)
    [<8000e4ef>] (show_stack+0xb/0xc) from [<802b5fa9>] (dump_stack+0x4d/0x60)
    [<802b5fa9>] (dump_stack+0x4d/0x60) from [<800186dd>] (warn_slowpath_common+0x45/0x64)
    [<800186dd>] (warn_slowpath_common+0x45/0x64) from [<80018717>] (warn_slowpath_fmt+0x1b/0x24)
    [<80018717>] (warn_slowpath_fmt+0x1b/0x24) from [<8003a8d3>] (irq_set_irq_wake+0x4b/0x8c)
    [<8003a8d3>] (irq_set_irq_wake+0x4b/0x8c) from [<80204fcb>] (ds3232_resume+0x2d/0x36)
    [<80204fcb>] (ds3232_resume+0x2d/0x36) from [<801954c7>] (dpm_run_callback.isra.13+0xb/0x28)
    [<801954c7>] (dpm_run_callback.isra.13+0xb/0x28) from [<80195b1b>] (device_resume+0x7b/0xa2)
    [<80195b1b>] (device_resume+0x7b/0xa2) from [<80195f0f>] (dpm_resume+0xbb/0x19c)
    [<80195f0f>] (dpm_resume+0xbb/0x19c) from [<801960d9>] (dpm_resume_end+0x9/0x12)
    [<801960d9>] (dpm_resume_end+0x9/0x12) from [<80037e1d>] (suspend_devices_and_enter+0x17d/0x1d0)
    [<80037e1d>] (suspend_devices_and_enter+0x17d/0x1d0) from [<80037ee1>] (pm_suspend+0x71/0x128)
    [<80037ee1>] (pm_suspend+0x71/0x128) from [<80037449>] (state_store+0x6d/0x80)
    [<80037449>] (state_store+0x6d/0x80) from [<800af4d5>] (sysfs_write_file+0x9f/0xde)
    [<800af4d5>] (sysfs_write_file+0x9f/0xde) from [<8007a437>] (vfs_write+0x7b/0x104)
    [<8007a437>] (vfs_write+0x7b/0x104) from [<8007a7f7>] (SyS_write+0x27/0x48)
    [<8007a7f7>] (SyS_write+0x27/0x48) from [<8000c121>] (ret_fast_syscall+0x1/0x44)
    
    Signed-off-by: Wang Dongsheng <dongsheng.wang@freescale.com>
    Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>

commit ccfb8b2ed4d4e12c3c35de3db5fbbbaa11277736
Author: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Date:   Tue Jul 14 13:00:39 2015 +0200

    drm/i915: Do not call intel_crtc_disable if the crtc is already disabled.
    
    When resuming with dpms off, the following warn can happen:
    
    [  118.334082] ------------[ cut here ]------------
    [  118.334105] WARNING: CPU: 2 PID: 2274 at drivers/gpu/drm/i915/intel_display.c:6319 __intel_set_mode+0xae5/0xb90 [i915]()
    [  118.334106] WARN_ON(!crtc->state->enable)
    [  118.334137] Modules linked in: i915
    [  118.334139] CPU: 2 PID: 2274 Comm: kworker/u16:117 Not tainted 4.2.0-rc2-fixes+ #4148
    [  118.334140] Hardware name: LENOVO 2349AV8/2349AV8, BIOS G1ETA5WW (2.65 ) 04/15/2014
    [  118.334144] Workqueue: events_unbound async_run_entry_fn
    [  118.334147]  ffffffffc017eef0 ffff8800ada93998 ffffffff817aa62a 0000000080000001
    [  118.334149]  ffff8800ada939e8 ffff8800ada939d8 ffffffff810807e1 ffff8800ada939c8
    [  118.334151]  ffff8800cea3b3d8 0000000000000000 ffff8800ad86b008 ffff880117705668
    [  118.334151] Call Trace:
    [  118.334155]  [<ffffffff817aa62a>] dump_stack+0x4f/0x7b
    [  118.334157]  [<ffffffff810807e1>] warn_slowpath_common+0x81/0xc0
    [  118.334158]  [<ffffffff81080861>] warn_slowpath_fmt+0x41/0x50
    [  118.334173]  [<ffffffffc0120375>] __intel_set_mode+0xae5/0xb90 [i915]
    [  118.334188]  [<ffffffffc0121312>] ? intel_modeset_compute_config+0x52/0xb40 [i915]
    [  118.334191]  [<ffffffff8144de53>] ? drm_atomic_set_fb_for_plane+0x63/0x80
    [  118.334205]  [<ffffffffc01269d9>] intel_set_mode+0x29/0x60 [i915]
    [  118.334219]  [<ffffffffc012730a>] intel_crtc_restore_mode+0x13a/0x1f0 [i915]
    [  118.334232]  [<ffffffffc0101160>] ? gen6_write16+0x250/0x250 [i915]
    [  118.334246]  [<ffffffffc01283ec>] intel_modeset_setup_hw_state+0x89c/0xcd0 [i915]
    [  118.334248]  [<ffffffff8137d260>] ? pci_pm_thaw+0x90/0x90
    [  118.334255]  [<ffffffffc00ac11b>] i915_drm_resume+0xcb/0x160 [i915]
    [  118.334262]  [<ffffffffc00ac1d2>] i915_pm_resume+0x22/0x30 [i915]
    [  118.334263]  [<ffffffff8137d2c3>] pci_pm_resume+0x63/0xa0
    [  118.334266]  [<ffffffff81467550>] dpm_run_callback+0x70/0x420
    [  118.334267]  [<ffffffff81467cbd>] device_resume+0x9d/0x1c0
    [  118.334269]  [<ffffffff814673d0>] ? initcall_debug_start+0x60/0x60
    [  118.334270]  [<ffffffff81467dfc>] async_resume+0x1c/0x50
    [  118.334271]  [<ffffffff810a6a94>] async_run_entry_fn+0x34/0xd0
    [  118.334273]  [<ffffffff8109d4ad>] process_one_work+0x1dd/0x7e0
    [  118.334275]  [<ffffffff8109d41a>] ? process_one_work+0x14a/0x7e0
    [  118.334276]  [<ffffffff8109daf9>] worker_thread+0x49/0x450
    [  118.334278]  [<ffffffff8109dab0>] ? process_one_work+0x7e0/0x7e0
    [  118.334280]  [<ffffffff810a3cb9>] kthread+0xf9/0x110
    [  118.334282]  [<ffffffff810a3bc0>] ? insert_kthread_work+0x90/0x90
    [  118.334284]  [<ffffffff817b414f>] ret_from_fork+0x3f/0x70
    [  118.334286]  [<ffffffff810a3bc0>] ? insert_kthread_work+0x90/0x90
    [  118.334287] ---[ end trace 01f2cf6371b82d7a ]---
    
    This warn is harmless, and can be fixed by not calling intel_crtc_disable when
    the crtc is already disabled.
    
    Reported-and-Tested-by: Jrg Otte <jrg.otte@gmail.com>
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

commit 44b23a7ca21a27d8d47d4e9d7e27e3450db1154c
Author: Peter Antoine <peter.antoine@intel.com>
Date:   Mon May 11 08:50:45 2015 +0100

    drm/i915: Avoid GPU hang when coming out of s3 or s4
    
    commit 364aece01a2dd748fc36a1e8bf52ef639b0857bd upstream.
    
    This patch fixes a timing issue that causes a GPU hang when the system
    comes out of power saving.
    
    During pm_resume, We are submitting batchbuffers before enabling
    Interrupts this is causing us to miss the context switch interrupt,
    and in consequence intel_execlists_handle_ctx_events is not triggered.
    
    This patch is based on a patch from Deepak S <deepak.s@intel.com>
    from another platform.
    
    The patch fixes an issue introduced by:
      commit e7778be1eab918274f79603d7c17b3ec8be77386
      drm/i915: Fix startup failure in LRC mode after recent init changes
    
    The above patch added a call to init_context() to fix an issue introduced
    by a previous patch. But, it then opened up a small timing window for the
    batches being added by the init_context (basically setting up the context)
    to complete before the interrupts have been turned on, thus hanging the
    GPU.
    
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=89600
    Cc: stable@vger.kernel.org # 4.0+
    Signed-off-by: Peter Antoine <peter.antoine@intel.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    [Jani: fixed typo in subject, massaged the comments a bit]
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit ab232ba57043ca85b55ffd7125f3f2c2d7e732ec
Merge: 8ced6789da03 32e8d689dc12 56f487c78015
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Jun 19 01:18:02 2015 +0200

    Merge branches 'pm-sleep' and 'pm-runtime'
    
    * pm-sleep:
      PM / sleep: trace_device_pm_callback coverage in dpm_prepare/complete
      PM / wakeup: add a dummy wakeup_source to record statistics
      PM / sleep: Make suspend-to-idle-specific code depend on CONFIG_SUSPEND
      PM / sleep: Return -EBUSY from suspend_enter() on wakeup detection
      PM / tick: Add tracepoints for suspend-to-idle diagnostics
      PM / sleep: Fix symbol name in a comment in kernel/power/main.c
      leds / PM: fix hibernation on arm when gpio-led used with CPU led trigger
      ARM: omap-device: use SET_NOIRQ_SYSTEM_SLEEP_PM_OPS
      bus: omap_l3_noc: add missed callbacks for suspend-to-disk
      PM / sleep: Add macro to define common noirq system PM callbacks
      PM / sleep: Refine diagnostic messages in enter_state()
      PM / wakeup: validate wakeup source before activating it.
    
    * pm-runtime:
      PM / Runtime: Update last_busy in rpm_resume
      PM / runtime: add note about re-calling in during device probe()

commit dcfc7fb134afc3b8e3d1070ef6a6d6faa9d383ef
Author: Luciano Coelho <luciano.coelho@intel.com>
Date:   Tue Apr 28 08:41:55 2015 +0300

    iwlwifi: mvm: take the UCODE_DOWN reference when resuming
    
    The __iwl_mvm_resume() function always returns 1, which causes
    mac80211 to do a reconfig with IEEE80211_RECONFIG_TYPE_RESTART.  This
    type of reconfig calls iwl_mvm_restart_complete(), where we unref the
    IWL_MVM_REF_UCODE_DOWN, so we should always take the reference in this
    case.
    
    This prevents this kind of warning from happening:
    
    [40026.103025] WARNING: at /root/iwlwifi/iwlwifi-stack-dev/drivers/net/wireless/iwlwifi/mvm/mac80211.c:236 iwl_mvm_unref+0xc9/0xd0 [iwlmvm]()
    [40026.105145] Modules linked in: iwlmvm(O) iwlwifi(O) mac80211(O) cfg80211(O) compat(O) ctr ccm arc4 autofs4 snd_hda_codec_hdmi snd_hda_codec_idt joydev coretemp kvm_intel kvm aesni_intel ablk_helper cryptd lrw aes_i586 snd_hda_intel xts snd_hda_codec gf128mul snd_hwdep snd_pcm snd_seq_midi dell_wmi snd_rawmidi sparse_keymap snd_seq_midi_event snd_seq uvcvideo dell_laptop videobuf2_core dcdbas microcode videodev psmouse snd_timer videobuf2_vmalloc videobuf2_memops serio_raw snd_seq_device btusb i915 snd bluetooth lpc_ich drm_kms_helper soundcore snd_page_alloc drm i2c_algo_bit wmi parport_pc ppdev video binfmt_misc rpcsec_gss_krb5 nfsd mac_hid nfs_acl nfsv4 auth_rpcgss nfs fscache lockd sunrpc msdos lp parport sdhci_pci sdhci ahci libahci e1000e mmc_core ptp pps_core [last unloaded: compat]
    [40026.117640] CPU: 2 PID: 3827 Comm: bash Tainted: G        W  O 3.10.29-dev #1
    [40026.120216] Hardware name: Dell Inc. Latitude E6430/0CPWYR, BIOS A09 12/13/2012
    [40026.122815]  f8effd18 f8effd18 e740fd18 c168aa62 e740fd40 c103a824 c1871238 f8effd18
    [40026.125527]  000000ec f8ec79c9 f8ec79c9 d5d29ba4 d5d2a20c 00000000 e740fd50 c103a862
    [40026.128209]  00000009 00000000 e740fd7c f8ec79c9 f1c591c4 00000400 00000000 f8efb490
    [40026.130886] Call Trace:
    [40026.133506]  [<c168aa62>] dump_stack+0x16/0x18
    [40026.136115]  [<c103a824>] warn_slowpath_common+0x64/0x80
    [40026.138727]  [<f8ec79c9>] ? iwl_mvm_unref+0xc9/0xd0 [iwlmvm]
    [40026.141319]  [<f8ec79c9>] ? iwl_mvm_unref+0xc9/0xd0 [iwlmvm]
    [40026.143881]  [<c103a862>] warn_slowpath_null+0x22/0x30
    [40026.146453]  [<f8ec79c9>] iwl_mvm_unref+0xc9/0xd0 [iwlmvm]
    [40026.149030]  [<f8ec7a4d>] iwl_mvm_mac_reconfig_complete+0x7d/0x210 [iwlmvm]
    [40026.151645]  [<f8b74b20>] ? ftrace_raw_event_drv_reconfig_complete+0xc0/0xe0 [mac80211]
    [40026.154291]  [<f8b6769e>] ieee80211_reconfig+0x28e/0x2620 [mac80211]
    [40026.156920]  [<c10ef0ea>] ? ring_buffer_unlock_commit+0xba/0x100
    [40026.159585]  [<f8b4a04d>] ieee80211_resume+0x6d/0x80 [mac80211]
    [40026.162206]  [<f8a79722>] wiphy_resume+0x72/0x260 [cfg80211]
    [40026.164799]  [<c141e2e7>] ? device_resume+0x57/0x150
    [40026.167425]  [<f8a796b0>] ? wiphy_suspend+0x710/0x710 [cfg80211]
    [40026.170075]  [<c141e26e>] dpm_run_callback+0x2e/0x50
    [40026.172695]  [<c141e321>] device_resume+0x91/0x150
    [40026.175334]  [<c141f636>] dpm_resume+0xf6/0x200
    [40026.177922]  [<c141f920>] dpm_resume_end+0x10/0x20
    [40026.180489]  [<c108d9f7>] suspend_devices_and_enter+0x177/0x480
    [40026.183037]  [<c168646a>] ? printk+0x4d/0x4f
    [40026.185559]  [<c108de76>] pm_suspend+0x176/0x210
    [40026.188065]  [<c108ca5d>] state_store+0x5d/0xb0
    [40026.190581]  [<c108ca00>] ? wakeup_count_show+0x50/0x50
    [40026.193052]  [<c13208db>] kobj_attr_store+0x1b/0x30
    [40026.195608]  [<c11e3a4b>] sysfs_write_file+0xab/0x100
    [40026.198055]  [<c11e39a0>] ? sysfs_poll+0xa0/0xa0
    [40026.200469]  [<c1179655>] vfs_write+0xa5/0x1c0
    [40026.202893]  [<c1179af7>] SyS_write+0x57/0xa0
    [40026.205245]  [<c1699ec1>] sysenter_do_call+0x12/0x32
    [40026.207619] ---[ end trace db1d5a72a0381b0a ]---
    
    Signed-off-by: Luciano Coelho <luciano.coelho@intel.com>
    Reviewed-by: EliadX Peller <eliad@wizery.com>
    Reviewed-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: Emmanuel Grumbach <emmanuel.grumbach@intel.com>

commit 56f487c78015936097474fd89b2ccb229d500d0f
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed May 13 16:36:32 2015 -0700

    PM / Runtime: Update last_busy in rpm_resume
    
    If we don't update last_busy in rpm_resume, devices can go back
    to sleep immediately after resume. This happens at least in
    cases where the device has been powered off and does not have
    any interrupt pending until there's something in the FIFO.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 364aece01a2dd748fc36a1e8bf52ef639b0857bd
Author: Peter Antoine <peter.antoine@intel.com>
Date:   Mon May 11 08:50:45 2015 +0100

    drm/i915: Avoid GPU hang when coming out of s3 or s4
    
    This patch fixes a timing issue that causes a GPU hang when the system
    comes out of power saving.
    
    During pm_resume, We are submitting batchbuffers before enabling
    Interrupts this is causing us to miss the context switch interrupt,
    and in consequence intel_execlists_handle_ctx_events is not triggered.
    
    This patch is based on a patch from Deepak S <deepak.s@intel.com>
    from another platform.
    
    The patch fixes an issue introduced by:
      commit e7778be1eab918274f79603d7c17b3ec8be77386
      drm/i915: Fix startup failure in LRC mode after recent init changes
    
    The above patch added a call to init_context() to fix an issue introduced
    by a previous patch. But, it then opened up a small timing window for the
    batches being added by the init_context (basically setting up the context)
    to complete before the interrupts have been turned on, thus hanging the
    GPU.
    
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=89600
    Cc: stable@vger.kernel.org # 4.0+
    Signed-off-by: Peter Antoine <peter.antoine@intel.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    [Jani: fixed typo in subject, massaged the comments a bit]
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>

commit 8bcd2a0924ca7c226d254fa45c75c6882b60af2d
Author: Ross Lagerwall <ross.lagerwall@citrix.com>
Date:   Mon Jan 19 13:19:38 2015 +0000

    xen/manage: Fix USB interaction issues when resuming
    
    commit 72978b2fe2f2cdf9f319c6c6dcdbe92b38de2be2 upstream.
    
    Commit 61a734d305e1 ("xen/manage: Always freeze/thaw processes when
    suspend/resuming") ensured that userspace processes were always frozen
    before suspending to reduce interaction issues when resuming devices.
    However, freeze_processes() does not freeze kernel threads.  Freeze
    kernel threads as well to prevent deadlocks with the khubd thread when
    resuming devices.
    
    This is what native suspend and resume does.
    
    Example deadlock:
    [ 7279.648010]  [<ffffffff81446bde>] ? xen_poll_irq_timeout+0x3e/0x50
    [ 7279.648010]  [<ffffffff81448d60>] xen_poll_irq+0x10/0x20
    [ 7279.648010]  [<ffffffff81011723>] xen_lock_spinning+0xb3/0x120
    [ 7279.648010]  [<ffffffff810115d1>] __raw_callee_save_xen_lock_spinning+0x11/0x20
    [ 7279.648010]  [<ffffffff815620b6>] ? usb_control_msg+0xe6/0x120
    [ 7279.648010]  [<ffffffff81747e50>] ? _raw_spin_lock_irq+0x50/0x60
    [ 7279.648010]  [<ffffffff8174522c>] wait_for_completion+0xac/0x160
    [ 7279.648010]  [<ffffffff8109c520>] ? try_to_wake_up+0x2c0/0x2c0
    [ 7279.648010]  [<ffffffff814b60f2>] dpm_wait+0x32/0x40
    [ 7279.648010]  [<ffffffff814b6eb0>] device_resume+0x90/0x210
    [ 7279.648010]  [<ffffffff814b7d71>] dpm_resume+0x121/0x250
    [ 7279.648010]  [<ffffffff8144c570>] ? xenbus_dev_request_and_reply+0xc0/0xc0
    [ 7279.648010]  [<ffffffff814b80d5>] dpm_resume_end+0x15/0x30
    [ 7279.648010]  [<ffffffff81449fba>] do_suspend+0x10a/0x200
    [ 7279.648010]  [<ffffffff8144a2f0>] ? xen_pre_suspend+0x20/0x20
    [ 7279.648010]  [<ffffffff8144a1d0>] shutdown_handler+0x120/0x150
    [ 7279.648010]  [<ffffffff8144c60f>] xenwatch_thread+0x9f/0x160
    [ 7279.648010]  [<ffffffff810ac510>] ? finish_wait+0x80/0x80
    [ 7279.648010]  [<ffffffff8108d189>] kthread+0xc9/0xe0
    [ 7279.648010]  [<ffffffff8108d0c0>] ? flush_kthread_worker+0x80/0x80
    [ 7279.648010]  [<ffffffff8175087c>] ret_from_fork+0x7c/0xb0
    [ 7279.648010]  [<ffffffff8108d0c0>] ? flush_kthread_worker+0x80/0x80
    
    [ 7441.216287] INFO: task khubd:89 blocked for more than 120 seconds.
    [ 7441.219457]       Tainted: G            X 3.13.11-ckt12.kz #1
    [ 7441.222176] "echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
    [ 7441.225827] khubd           D ffff88003f433440     0    89      2 0x00000000
    [ 7441.229258]  ffff88003ceb9b98 0000000000000046 ffff88003ce83000 0000000000013440
    [ 7441.232959]  ffff88003ceb9fd8 0000000000013440 ffff88003cd13000 ffff88003ce83000
    [ 7441.236658]  0000000000000286 ffff88003d3e0000 ffff88003ceb9bd0 00000001001aa01e
    [ 7441.240415] Call Trace:
    [ 7441.241614]  [<ffffffff817442f9>] schedule+0x29/0x70
    [ 7441.243930]  [<ffffffff81743406>] schedule_timeout+0x166/0x2c0
    [ 7441.246681]  [<ffffffff81075b80>] ? call_timer_fn+0x110/0x110
    [ 7441.249339]  [<ffffffff8174357e>] schedule_timeout_uninterruptible+0x1e/0x20
    [ 7441.252644]  [<ffffffff81077710>] msleep+0x20/0x30
    [ 7441.254812]  [<ffffffff81555f00>] hub_port_reset+0xf0/0x580
    [ 7441.257400]  [<ffffffff81558465>] hub_port_init+0x75/0xb40
    [ 7441.259981]  [<ffffffff814bb3c9>] ? update_autosuspend+0x39/0x60
    [ 7441.262817]  [<ffffffff814bb4f0>] ? pm_runtime_set_autosuspend_delay+0x50/0xa0
    [ 7441.266212]  [<ffffffff8155a64a>] hub_thread+0x71a/0x1750
    [ 7441.268728]  [<ffffffff810ac510>] ? finish_wait+0x80/0x80
    [ 7441.271272]  [<ffffffff81559f30>] ? usb_port_resume+0x670/0x670
    [ 7441.274067]  [<ffffffff8108d189>] kthread+0xc9/0xe0
    [ 7441.276305]  [<ffffffff8108d0c0>] ? flush_kthread_worker+0x80/0x80
    [ 7441.279131]  [<ffffffff8175087c>] ret_from_fork+0x7c/0xb0
    [ 7441.281659]  [<ffffffff8108d0c0>] ? flush_kthread_worker+0x80/0x80
    
    Signed-off-by: Ross Lagerwall <ross.lagerwall@citrix.com>
    Signed-off-by: David Vrabel <david.vrabel@citrix.com>
    [bwh: Backported to 3.2: adjust context]
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit f13b2065de8147a1652b830ea5db961cf80c09df
Author: Rafael J. Wysocki <rjw@rjwysocki.net>
Date:   Mon Mar 9 17:03:07 2015 -0700

    Input: i8042 - allow KBD and AUX ports to wake up from suspend-to-idle
    
    While registering serio device for i8042, mark them as wakeup-capable
    and check their user space wakeup settings in i8042_pm_suspend() and
    i8042_pm_resume() to enable or disable, respectively, their interrupts
    to wake up the system.
    
    This makes it possible to use the PC keyboard to wake up the system
    from suspend-to-idle, among other things, after writing "enabled" to
    the keyboard serio device's power/wakeup sysfs attribute.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

commit ee1693299c8b5cd9ad7f861606ea9bf20ef75717
Author: Ross Lagerwall <ross.lagerwall@citrix.com>
Date:   Mon Jan 19 13:19:38 2015 +0000

    xen/manage: Fix USB interaction issues when resuming
    
    commit 72978b2fe2f2cdf9f319c6c6dcdbe92b38de2be2 upstream.
    
    Commit 61a734d305e1 ("xen/manage: Always freeze/thaw processes when
    suspend/resuming") ensured that userspace processes were always frozen
    before suspending to reduce interaction issues when resuming devices.
    However, freeze_processes() does not freeze kernel threads.  Freeze
    kernel threads as well to prevent deadlocks with the khubd thread when
    resuming devices.
    
    This is what native suspend and resume does.
    
    Example deadlock:
    [ 7279.648010]  [<ffffffff81446bde>] ? xen_poll_irq_timeout+0x3e/0x50
    [ 7279.648010]  [<ffffffff81448d60>] xen_poll_irq+0x10/0x20
    [ 7279.648010]  [<ffffffff81011723>] xen_lock_spinning+0xb3/0x120
    [ 7279.648010]  [<ffffffff810115d1>] __raw_callee_save_xen_lock_spinning+0x11/0x20
    [ 7279.648010]  [<ffffffff815620b6>] ? usb_control_msg+0xe6/0x120
    [ 7279.648010]  [<ffffffff81747e50>] ? _raw_spin_lock_irq+0x50/0x60
    [ 7279.648010]  [<ffffffff8174522c>] wait_for_completion+0xac/0x160
    [ 7279.648010]  [<ffffffff8109c520>] ? try_to_wake_up+0x2c0/0x2c0
    [ 7279.648010]  [<ffffffff814b60f2>] dpm_wait+0x32/0x40
    [ 7279.648010]  [<ffffffff814b6eb0>] device_resume+0x90/0x210
    [ 7279.648010]  [<ffffffff814b7d71>] dpm_resume+0x121/0x250
    [ 7279.648010]  [<ffffffff8144c570>] ? xenbus_dev_request_and_reply+0xc0/0xc0
    [ 7279.648010]  [<ffffffff814b80d5>] dpm_resume_end+0x15/0x30
    [ 7279.648010]  [<ffffffff81449fba>] do_suspend+0x10a/0x200
    [ 7279.648010]  [<ffffffff8144a2f0>] ? xen_pre_suspend+0x20/0x20
    [ 7279.648010]  [<ffffffff8144a1d0>] shutdown_handler+0x120/0x150
    [ 7279.648010]  [<ffffffff8144c60f>] xenwatch_thread+0x9f/0x160
    [ 7279.648010]  [<ffffffff810ac510>] ? finish_wait+0x80/0x80
    [ 7279.648010]  [<ffffffff8108d189>] kthread+0xc9/0xe0
    [ 7279.648010]  [<ffffffff8108d0c0>] ? flush_kthread_worker+0x80/0x80
    [ 7279.648010]  [<ffffffff8175087c>] ret_from_fork+0x7c/0xb0
    [ 7279.648010]  [<ffffffff8108d0c0>] ? flush_kthread_worker+0x80/0x80
    
    [ 7441.216287] INFO: task khubd:89 blocked for more than 120 seconds.
    [ 7441.219457]       Tainted: G            X 3.13.11-ckt12.kz #1
    [ 7441.222176] "echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
    [ 7441.225827] khubd           D ffff88003f433440     0    89      2 0x00000000
    [ 7441.229258]  ffff88003ceb9b98 0000000000000046 ffff88003ce83000 0000000000013440
    [ 7441.232959]  ffff88003ceb9fd8 0000000000013440 ffff88003cd13000 ffff88003ce83000
    [ 7441.236658]  0000000000000286 ffff88003d3e0000 ffff88003ceb9bd0 00000001001aa01e
    [ 7441.240415] Call Trace:
    [ 7441.241614]  [<ffffffff817442f9>] schedule+0x29/0x70
    [ 7441.243930]  [<ffffffff81743406>] schedule_timeout+0x166/0x2c0
    [ 7441.246681]  [<ffffffff81075b80>] ? call_timer_fn+0x110/0x110
    [ 7441.249339]  [<ffffffff8174357e>] schedule_timeout_uninterruptible+0x1e/0x20
    [ 7441.252644]  [<ffffffff81077710>] msleep+0x20/0x30
    [ 7441.254812]  [<ffffffff81555f00>] hub_port_reset+0xf0/0x580
    [ 7441.257400]  [<ffffffff81558465>] hub_port_init+0x75/0xb40
    [ 7441.259981]  [<ffffffff814bb3c9>] ? update_autosuspend+0x39/0x60
    [ 7441.262817]  [<ffffffff814bb4f0>] ? pm_runtime_set_autosuspend_delay+0x50/0xa0
    [ 7441.266212]  [<ffffffff8155a64a>] hub_thread+0x71a/0x1750
    [ 7441.268728]  [<ffffffff810ac510>] ? finish_wait+0x80/0x80
    [ 7441.271272]  [<ffffffff81559f30>] ? usb_port_resume+0x670/0x670
    [ 7441.274067]  [<ffffffff8108d189>] kthread+0xc9/0xe0
    [ 7441.276305]  [<ffffffff8108d0c0>] ? flush_kthread_worker+0x80/0x80
    [ 7441.279131]  [<ffffffff8175087c>] ret_from_fork+0x7c/0xb0
    [ 7441.281659]  [<ffffffff8108d0c0>] ? flush_kthread_worker+0x80/0x80
    
    Signed-off-by: Ross Lagerwall <ross.lagerwall@citrix.com>
    Signed-off-by: David Vrabel <david.vrabel@citrix.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit beb843e55e0a5b46504cc1207bdf65857accc028
Author: Ross Lagerwall <ross.lagerwall@citrix.com>
Date:   Mon Jan 19 13:19:38 2015 +0000

    xen/manage: Fix USB interaction issues when resuming
    
    commit 72978b2fe2f2cdf9f319c6c6dcdbe92b38de2be2 upstream.
    
    Commit 61a734d305e1 ("xen/manage: Always freeze/thaw processes when
    suspend/resuming") ensured that userspace processes were always frozen
    before suspending to reduce interaction issues when resuming devices.
    However, freeze_processes() does not freeze kernel threads.  Freeze
    kernel threads as well to prevent deadlocks with the khubd thread when
    resuming devices.
    
    This is what native suspend and resume does.
    
    Example deadlock:
    [ 7279.648010]  [<ffffffff81446bde>] ? xen_poll_irq_timeout+0x3e/0x50
    [ 7279.648010]  [<ffffffff81448d60>] xen_poll_irq+0x10/0x20
    [ 7279.648010]  [<ffffffff81011723>] xen_lock_spinning+0xb3/0x120
    [ 7279.648010]  [<ffffffff810115d1>] __raw_callee_save_xen_lock_spinning+0x11/0x20
    [ 7279.648010]  [<ffffffff815620b6>] ? usb_control_msg+0xe6/0x120
    [ 7279.648010]  [<ffffffff81747e50>] ? _raw_spin_lock_irq+0x50/0x60
    [ 7279.648010]  [<ffffffff8174522c>] wait_for_completion+0xac/0x160
    [ 7279.648010]  [<ffffffff8109c520>] ? try_to_wake_up+0x2c0/0x2c0
    [ 7279.648010]  [<ffffffff814b60f2>] dpm_wait+0x32/0x40
    [ 7279.648010]  [<ffffffff814b6eb0>] device_resume+0x90/0x210
    [ 7279.648010]  [<ffffffff814b7d71>] dpm_resume+0x121/0x250
    [ 7279.648010]  [<ffffffff8144c570>] ? xenbus_dev_request_and_reply+0xc0/0xc0
    [ 7279.648010]  [<ffffffff814b80d5>] dpm_resume_end+0x15/0x30
    [ 7279.648010]  [<ffffffff81449fba>] do_suspend+0x10a/0x200
    [ 7279.648010]  [<ffffffff8144a2f0>] ? xen_pre_suspend+0x20/0x20
    [ 7279.648010]  [<ffffffff8144a1d0>] shutdown_handler+0x120/0x150
    [ 7279.648010]  [<ffffffff8144c60f>] xenwatch_thread+0x9f/0x160
    [ 7279.648010]  [<ffffffff810ac510>] ? finish_wait+0x80/0x80
    [ 7279.648010]  [<ffffffff8108d189>] kthread+0xc9/0xe0
    [ 7279.648010]  [<ffffffff8108d0c0>] ? flush_kthread_worker+0x80/0x80
    [ 7279.648010]  [<ffffffff8175087c>] ret_from_fork+0x7c/0xb0
    [ 7279.648010]  [<ffffffff8108d0c0>] ? flush_kthread_worker+0x80/0x80
    
    [ 7441.216287] INFO: task khubd:89 blocked for more than 120 seconds.
    [ 7441.219457]       Tainted: G            X 3.13.11-ckt12.kz #1
    [ 7441.222176] "echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
    [ 7441.225827] khubd           D ffff88003f433440     0    89      2 0x00000000
    [ 7441.229258]  ffff88003ceb9b98 0000000000000046 ffff88003ce83000 0000000000013440
    [ 7441.232959]  ffff88003ceb9fd8 0000000000013440 ffff88003cd13000 ffff88003ce83000
    [ 7441.236658]  0000000000000286 ffff88003d3e0000 ffff88003ceb9bd0 00000001001aa01e
    [ 7441.240415] Call Trace:
    [ 7441.241614]  [<ffffffff817442f9>] schedule+0x29/0x70
    [ 7441.243930]  [<ffffffff81743406>] schedule_timeout+0x166/0x2c0
    [ 7441.246681]  [<ffffffff81075b80>] ? call_timer_fn+0x110/0x110
    [ 7441.249339]  [<ffffffff8174357e>] schedule_timeout_uninterruptible+0x1e/0x20
    [ 7441.252644]  [<ffffffff81077710>] msleep+0x20/0x30
    [ 7441.254812]  [<ffffffff81555f00>] hub_port_reset+0xf0/0x580
    [ 7441.257400]  [<ffffffff81558465>] hub_port_init+0x75/0xb40
    [ 7441.259981]  [<ffffffff814bb3c9>] ? update_autosuspend+0x39/0x60
    [ 7441.262817]  [<ffffffff814bb4f0>] ? pm_runtime_set_autosuspend_delay+0x50/0xa0
    [ 7441.266212]  [<ffffffff8155a64a>] hub_thread+0x71a/0x1750
    [ 7441.268728]  [<ffffffff810ac510>] ? finish_wait+0x80/0x80
    [ 7441.271272]  [<ffffffff81559f30>] ? usb_port_resume+0x670/0x670
    [ 7441.274067]  [<ffffffff8108d189>] kthread+0xc9/0xe0
    [ 7441.276305]  [<ffffffff8108d0c0>] ? flush_kthread_worker+0x80/0x80
    [ 7441.279131]  [<ffffffff8175087c>] ret_from_fork+0x7c/0xb0
    [ 7441.281659]  [<ffffffff8108d0c0>] ? flush_kthread_worker+0x80/0x80
    
    Signed-off-by: Ross Lagerwall <ross.lagerwall@citrix.com>
    Signed-off-by: David Vrabel <david.vrabel@citrix.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 053987b6e09119b5d323f720941670b8d878a776
Author: Ross Lagerwall <ross.lagerwall@citrix.com>
Date:   Mon Jan 19 13:19:38 2015 +0000

    xen/manage: Fix USB interaction issues when resuming
    
    commit 72978b2fe2f2cdf9f319c6c6dcdbe92b38de2be2 upstream.
    
    Commit 61a734d305e1 ("xen/manage: Always freeze/thaw processes when
    suspend/resuming") ensured that userspace processes were always frozen
    before suspending to reduce interaction issues when resuming devices.
    However, freeze_processes() does not freeze kernel threads.  Freeze
    kernel threads as well to prevent deadlocks with the khubd thread when
    resuming devices.
    
    This is what native suspend and resume does.
    
    Example deadlock:
    [ 7279.648010]  [<ffffffff81446bde>] ? xen_poll_irq_timeout+0x3e/0x50
    [ 7279.648010]  [<ffffffff81448d60>] xen_poll_irq+0x10/0x20
    [ 7279.648010]  [<ffffffff81011723>] xen_lock_spinning+0xb3/0x120
    [ 7279.648010]  [<ffffffff810115d1>] __raw_callee_save_xen_lock_spinning+0x11/0x20
    [ 7279.648010]  [<ffffffff815620b6>] ? usb_control_msg+0xe6/0x120
    [ 7279.648010]  [<ffffffff81747e50>] ? _raw_spin_lock_irq+0x50/0x60
    [ 7279.648010]  [<ffffffff8174522c>] wait_for_completion+0xac/0x160
    [ 7279.648010]  [<ffffffff8109c520>] ? try_to_wake_up+0x2c0/0x2c0
    [ 7279.648010]  [<ffffffff814b60f2>] dpm_wait+0x32/0x40
    [ 7279.648010]  [<ffffffff814b6eb0>] device_resume+0x90/0x210
    [ 7279.648010]  [<ffffffff814b7d71>] dpm_resume+0x121/0x250
    [ 7279.648010]  [<ffffffff8144c570>] ? xenbus_dev_request_and_reply+0xc0/0xc0
    [ 7279.648010]  [<ffffffff814b80d5>] dpm_resume_end+0x15/0x30
    [ 7279.648010]  [<ffffffff81449fba>] do_suspend+0x10a/0x200
    [ 7279.648010]  [<ffffffff8144a2f0>] ? xen_pre_suspend+0x20/0x20
    [ 7279.648010]  [<ffffffff8144a1d0>] shutdown_handler+0x120/0x150
    [ 7279.648010]  [<ffffffff8144c60f>] xenwatch_thread+0x9f/0x160
    [ 7279.648010]  [<ffffffff810ac510>] ? finish_wait+0x80/0x80
    [ 7279.648010]  [<ffffffff8108d189>] kthread+0xc9/0xe0
    [ 7279.648010]  [<ffffffff8108d0c0>] ? flush_kthread_worker+0x80/0x80
    [ 7279.648010]  [<ffffffff8175087c>] ret_from_fork+0x7c/0xb0
    [ 7279.648010]  [<ffffffff8108d0c0>] ? flush_kthread_worker+0x80/0x80
    
    [ 7441.216287] INFO: task khubd:89 blocked for more than 120 seconds.
    [ 7441.219457]       Tainted: G            X 3.13.11-ckt12.kz #1
    [ 7441.222176] "echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
    [ 7441.225827] khubd           D ffff88003f433440     0    89      2 0x00000000
    [ 7441.229258]  ffff88003ceb9b98 0000000000000046 ffff88003ce83000 0000000000013440
    [ 7441.232959]  ffff88003ceb9fd8 0000000000013440 ffff88003cd13000 ffff88003ce83000
    [ 7441.236658]  0000000000000286 ffff88003d3e0000 ffff88003ceb9bd0 00000001001aa01e
    [ 7441.240415] Call Trace:
    [ 7441.241614]  [<ffffffff817442f9>] schedule+0x29/0x70
    [ 7441.243930]  [<ffffffff81743406>] schedule_timeout+0x166/0x2c0
    [ 7441.246681]  [<ffffffff81075b80>] ? call_timer_fn+0x110/0x110
    [ 7441.249339]  [<ffffffff8174357e>] schedule_timeout_uninterruptible+0x1e/0x20
    [ 7441.252644]  [<ffffffff81077710>] msleep+0x20/0x30
    [ 7441.254812]  [<ffffffff81555f00>] hub_port_reset+0xf0/0x580
    [ 7441.257400]  [<ffffffff81558465>] hub_port_init+0x75/0xb40
    [ 7441.259981]  [<ffffffff814bb3c9>] ? update_autosuspend+0x39/0x60
    [ 7441.262817]  [<ffffffff814bb4f0>] ? pm_runtime_set_autosuspend_delay+0x50/0xa0
    [ 7441.266212]  [<ffffffff8155a64a>] hub_thread+0x71a/0x1750
    [ 7441.268728]  [<ffffffff810ac510>] ? finish_wait+0x80/0x80
    [ 7441.271272]  [<ffffffff81559f30>] ? usb_port_resume+0x670/0x670
    [ 7441.274067]  [<ffffffff8108d189>] kthread+0xc9/0xe0
    [ 7441.276305]  [<ffffffff8108d0c0>] ? flush_kthread_worker+0x80/0x80
    [ 7441.279131]  [<ffffffff8175087c>] ret_from_fork+0x7c/0xb0
    [ 7441.281659]  [<ffffffff8108d0c0>] ? flush_kthread_worker+0x80/0x80
    
    Signed-off-by: Ross Lagerwall <ross.lagerwall@citrix.com>
    Signed-off-by: David Vrabel <david.vrabel@citrix.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit be7a2a5d540baba26eff1bdf1402f332d392cf2b
Author: Ross Lagerwall <ross.lagerwall@citrix.com>
Date:   Mon Jan 19 13:19:38 2015 +0000

    xen/manage: Fix USB interaction issues when resuming
    
    commit 72978b2fe2f2cdf9f319c6c6dcdbe92b38de2be2 upstream.
    
    Commit 61a734d305e1 ("xen/manage: Always freeze/thaw processes when
    suspend/resuming") ensured that userspace processes were always frozen
    before suspending to reduce interaction issues when resuming devices.
    However, freeze_processes() does not freeze kernel threads.  Freeze
    kernel threads as well to prevent deadlocks with the khubd thread when
    resuming devices.
    
    This is what native suspend and resume does.
    
    Example deadlock:
    [ 7279.648010]  [<ffffffff81446bde>] ? xen_poll_irq_timeout+0x3e/0x50
    [ 7279.648010]  [<ffffffff81448d60>] xen_poll_irq+0x10/0x20
    [ 7279.648010]  [<ffffffff81011723>] xen_lock_spinning+0xb3/0x120
    [ 7279.648010]  [<ffffffff810115d1>] __raw_callee_save_xen_lock_spinning+0x11/0x20
    [ 7279.648010]  [<ffffffff815620b6>] ? usb_control_msg+0xe6/0x120
    [ 7279.648010]  [<ffffffff81747e50>] ? _raw_spin_lock_irq+0x50/0x60
    [ 7279.648010]  [<ffffffff8174522c>] wait_for_completion+0xac/0x160
    [ 7279.648010]  [<ffffffff8109c520>] ? try_to_wake_up+0x2c0/0x2c0
    [ 7279.648010]  [<ffffffff814b60f2>] dpm_wait+0x32/0x40
    [ 7279.648010]  [<ffffffff814b6eb0>] device_resume+0x90/0x210
    [ 7279.648010]  [<ffffffff814b7d71>] dpm_resume+0x121/0x250
    [ 7279.648010]  [<ffffffff8144c570>] ? xenbus_dev_request_and_reply+0xc0/0xc0
    [ 7279.648010]  [<ffffffff814b80d5>] dpm_resume_end+0x15/0x30
    [ 7279.648010]  [<ffffffff81449fba>] do_suspend+0x10a/0x200
    [ 7279.648010]  [<ffffffff8144a2f0>] ? xen_pre_suspend+0x20/0x20
    [ 7279.648010]  [<ffffffff8144a1d0>] shutdown_handler+0x120/0x150
    [ 7279.648010]  [<ffffffff8144c60f>] xenwatch_thread+0x9f/0x160
    [ 7279.648010]  [<ffffffff810ac510>] ? finish_wait+0x80/0x80
    [ 7279.648010]  [<ffffffff8108d189>] kthread+0xc9/0xe0
    [ 7279.648010]  [<ffffffff8108d0c0>] ? flush_kthread_worker+0x80/0x80
    [ 7279.648010]  [<ffffffff8175087c>] ret_from_fork+0x7c/0xb0
    [ 7279.648010]  [<ffffffff8108d0c0>] ? flush_kthread_worker+0x80/0x80
    
    [ 7441.216287] INFO: task khubd:89 blocked for more than 120 seconds.
    [ 7441.219457]       Tainted: G            X 3.13.11-ckt12.kz #1
    [ 7441.222176] "echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
    [ 7441.225827] khubd           D ffff88003f433440     0    89      2 0x00000000
    [ 7441.229258]  ffff88003ceb9b98 0000000000000046 ffff88003ce83000 0000000000013440
    [ 7441.232959]  ffff88003ceb9fd8 0000000000013440 ffff88003cd13000 ffff88003ce83000
    [ 7441.236658]  0000000000000286 ffff88003d3e0000 ffff88003ceb9bd0 00000001001aa01e
    [ 7441.240415] Call Trace:
    [ 7441.241614]  [<ffffffff817442f9>] schedule+0x29/0x70
    [ 7441.243930]  [<ffffffff81743406>] schedule_timeout+0x166/0x2c0
    [ 7441.246681]  [<ffffffff81075b80>] ? call_timer_fn+0x110/0x110
    [ 7441.249339]  [<ffffffff8174357e>] schedule_timeout_uninterruptible+0x1e/0x20
    [ 7441.252644]  [<ffffffff81077710>] msleep+0x20/0x30
    [ 7441.254812]  [<ffffffff81555f00>] hub_port_reset+0xf0/0x580
    [ 7441.257400]  [<ffffffff81558465>] hub_port_init+0x75/0xb40
    [ 7441.259981]  [<ffffffff814bb3c9>] ? update_autosuspend+0x39/0x60
    [ 7441.262817]  [<ffffffff814bb4f0>] ? pm_runtime_set_autosuspend_delay+0x50/0xa0
    [ 7441.266212]  [<ffffffff8155a64a>] hub_thread+0x71a/0x1750
    [ 7441.268728]  [<ffffffff810ac510>] ? finish_wait+0x80/0x80
    [ 7441.271272]  [<ffffffff81559f30>] ? usb_port_resume+0x670/0x670
    [ 7441.274067]  [<ffffffff8108d189>] kthread+0xc9/0xe0
    [ 7441.276305]  [<ffffffff8108d0c0>] ? flush_kthread_worker+0x80/0x80
    [ 7441.279131]  [<ffffffff8175087c>] ret_from_fork+0x7c/0xb0
    [ 7441.281659]  [<ffffffff8108d0c0>] ? flush_kthread_worker+0x80/0x80
    
    Signed-off-by: Ross Lagerwall <ross.lagerwall@citrix.com>
    Signed-off-by: David Vrabel <david.vrabel@citrix.com>
    Signed-off-by: Luis Henriques <luis.henriques@canonical.com>

commit 9e012b00fcb631454ab30d588adf2156ac8426c2
Author: Ross Lagerwall <ross.lagerwall@citrix.com>
Date:   Mon Jan 19 13:19:38 2015 +0000

    xen/manage: Fix USB interaction issues when resuming
    
    commit 72978b2fe2f2cdf9f319c6c6dcdbe92b38de2be2 upstream.
    
    Commit 61a734d305e1 ("xen/manage: Always freeze/thaw processes when
    suspend/resuming") ensured that userspace processes were always frozen
    before suspending to reduce interaction issues when resuming devices.
    However, freeze_processes() does not freeze kernel threads.  Freeze
    kernel threads as well to prevent deadlocks with the khubd thread when
    resuming devices.
    
    This is what native suspend and resume does.
    
    Example deadlock:
    [ 7279.648010]  [<ffffffff81446bde>] ? xen_poll_irq_timeout+0x3e/0x50
    [ 7279.648010]  [<ffffffff81448d60>] xen_poll_irq+0x10/0x20
    [ 7279.648010]  [<ffffffff81011723>] xen_lock_spinning+0xb3/0x120
    [ 7279.648010]  [<ffffffff810115d1>] __raw_callee_save_xen_lock_spinning+0x11/0x20
    [ 7279.648010]  [<ffffffff815620b6>] ? usb_control_msg+0xe6/0x120
    [ 7279.648010]  [<ffffffff81747e50>] ? _raw_spin_lock_irq+0x50/0x60
    [ 7279.648010]  [<ffffffff8174522c>] wait_for_completion+0xac/0x160
    [ 7279.648010]  [<ffffffff8109c520>] ? try_to_wake_up+0x2c0/0x2c0
    [ 7279.648010]  [<ffffffff814b60f2>] dpm_wait+0x32/0x40
    [ 7279.648010]  [<ffffffff814b6eb0>] device_resume+0x90/0x210
    [ 7279.648010]  [<ffffffff814b7d71>] dpm_resume+0x121/0x250
    [ 7279.648010]  [<ffffffff8144c570>] ? xenbus_dev_request_and_reply+0xc0/0xc0
    [ 7279.648010]  [<ffffffff814b80d5>] dpm_resume_end+0x15/0x30
    [ 7279.648010]  [<ffffffff81449fba>] do_suspend+0x10a/0x200
    [ 7279.648010]  [<ffffffff8144a2f0>] ? xen_pre_suspend+0x20/0x20
    [ 7279.648010]  [<ffffffff8144a1d0>] shutdown_handler+0x120/0x150
    [ 7279.648010]  [<ffffffff8144c60f>] xenwatch_thread+0x9f/0x160
    [ 7279.648010]  [<ffffffff810ac510>] ? finish_wait+0x80/0x80
    [ 7279.648010]  [<ffffffff8108d189>] kthread+0xc9/0xe0
    [ 7279.648010]  [<ffffffff8108d0c0>] ? flush_kthread_worker+0x80/0x80
    [ 7279.648010]  [<ffffffff8175087c>] ret_from_fork+0x7c/0xb0
    [ 7279.648010]  [<ffffffff8108d0c0>] ? flush_kthread_worker+0x80/0x80
    
    [ 7441.216287] INFO: task khubd:89 blocked for more than 120 seconds.
    [ 7441.219457]       Tainted: G            X 3.13.11-ckt12.kz #1
    [ 7441.222176] "echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
    [ 7441.225827] khubd           D ffff88003f433440     0    89      2 0x00000000
    [ 7441.229258]  ffff88003ceb9b98 0000000000000046 ffff88003ce83000 0000000000013440
    [ 7441.232959]  ffff88003ceb9fd8 0000000000013440 ffff88003cd13000 ffff88003ce83000
    [ 7441.236658]  0000000000000286 ffff88003d3e0000 ffff88003ceb9bd0 00000001001aa01e
    [ 7441.240415] Call Trace:
    [ 7441.241614]  [<ffffffff817442f9>] schedule+0x29/0x70
    [ 7441.243930]  [<ffffffff81743406>] schedule_timeout+0x166/0x2c0
    [ 7441.246681]  [<ffffffff81075b80>] ? call_timer_fn+0x110/0x110
    [ 7441.249339]  [<ffffffff8174357e>] schedule_timeout_uninterruptible+0x1e/0x20
    [ 7441.252644]  [<ffffffff81077710>] msleep+0x20/0x30
    [ 7441.254812]  [<ffffffff81555f00>] hub_port_reset+0xf0/0x580
    [ 7441.257400]  [<ffffffff81558465>] hub_port_init+0x75/0xb40
    [ 7441.259981]  [<ffffffff814bb3c9>] ? update_autosuspend+0x39/0x60
    [ 7441.262817]  [<ffffffff814bb4f0>] ? pm_runtime_set_autosuspend_delay+0x50/0xa0
    [ 7441.266212]  [<ffffffff8155a64a>] hub_thread+0x71a/0x1750
    [ 7441.268728]  [<ffffffff810ac510>] ? finish_wait+0x80/0x80
    [ 7441.271272]  [<ffffffff81559f30>] ? usb_port_resume+0x670/0x670
    [ 7441.274067]  [<ffffffff8108d189>] kthread+0xc9/0xe0
    [ 7441.276305]  [<ffffffff8108d0c0>] ? flush_kthread_worker+0x80/0x80
    [ 7441.279131]  [<ffffffff8175087c>] ret_from_fork+0x7c/0xb0
    [ 7441.281659]  [<ffffffff8108d0c0>] ? flush_kthread_worker+0x80/0x80
    
    Signed-off-by: Ross Lagerwall <ross.lagerwall@citrix.com>
    Signed-off-by: David Vrabel <david.vrabel@citrix.com>
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>

commit 484c213b106c2b9188744666693d57bb9fd5affe
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Feb 27 05:50:22 2015 +0900

    ARM: S3C64XX: fix building without CONFIG_PM_SLEEP
    
    arch/arm/mach-s3c64xx/built-in.o: In function `s3c_pm_restore_core':
    :(.text+0x5d0): undefined reference to `s3c_pm_do_restore_core'
    :(.text+0x5d4): undefined reference to `s3c_pm_do_restore'
    arch/arm/mach-s3c64xx/built-in.o: In function `s3c_pm_save_core':
    :(.text+0x60c): undefined reference to `s3c_pm_do_save'
    arch/arm/mach-s3c64xx/built-in.o: In function `s3c64xx_irq_pm_resume':
    :(.text+0x670): undefined reference to `s3c_pm_do_restore'
    arch/arm/mach-s3c64xx/built-in.o: In function `s3c64xx_irq_pm_suspend':
    :(.text+0x6d8): undefined reference to `s3c_pm_do_save'
    arch/arm/mach-s3c64xx/built-in.o: In function `s3c_cpu_resume':
    :(.text+0x71c): undefined reference to `cpu_resume'
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Kukjin Kim <kgene@kernel.org>

commit 74d6b3ceaa17d111220c3f09f50f901bf955d7c8
Author: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
Date:   Thu Jan 29 07:43:47 2015 +0200

    tpm: fix suspend/resume paths for TPM 2.0
    
    Fixed suspend/resume paths for TPM 2.0 and consolidated all the
    associated code to the tpm_pm_suspend() and tpm_pm_resume()
    functions. Resume path should be handled by the firmware, i.e.
    Startup(CLEAR) for hibernate and Startup(STATE) for suspend.
    
    There might be some non-PC embedded devices in the future where
    Startup() is not the handled by the FW but fixing the code for
    those IMHO should be postponed until there is hardware available
    to test the fixes although extra Startup in the driver code is
    essentially a NOP.
    
    Added Shutdown(CLEAR) to the remove paths of TIS and CRB drivers.
    Changed tpm2_shutdown() to a void function because there isn't
    much you can do except print an error message if this fails with
    a system error.
    
    Fixes: aec04cbdf723 ("tpm: TPM 2.0 FIFO Interface")
    Fixes: 30fc8d138e91 ("tpm: TPM 2.0 CRB Interface")
    [phuewe: both did send TPM_Shutdown on resume which 'disables' the TPM
    and did not send TPM2_Shutdown on teardown which leads some TPM2.0 to
    believe there was an attack (no TPM2_Shutdown = no orderly shutdown =
    attack)]
    
    Reported-by: Peter Hwe <PeterHuewe@gmx.de>
    Signed-off-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
    Tested-by: Scot Doyle <lkml14@scotdoyle.com>
    Reviewed-by: Peter Huewe <peterhuewe@gmx.de>
    Signed-off-by: Peter Huewe <peterhuewe@gmx.de>

commit 72978b2fe2f2cdf9f319c6c6dcdbe92b38de2be2
Author: Ross Lagerwall <ross.lagerwall@citrix.com>
Date:   Mon Jan 19 13:19:38 2015 +0000

    xen/manage: Fix USB interaction issues when resuming
    
    Commit 61a734d305e1 ("xen/manage: Always freeze/thaw processes when
    suspend/resuming") ensured that userspace processes were always frozen
    before suspending to reduce interaction issues when resuming devices.
    However, freeze_processes() does not freeze kernel threads.  Freeze
    kernel threads as well to prevent deadlocks with the khubd thread when
    resuming devices.
    
    This is what native suspend and resume does.
    
    Example deadlock:
    [ 7279.648010]  [<ffffffff81446bde>] ? xen_poll_irq_timeout+0x3e/0x50
    [ 7279.648010]  [<ffffffff81448d60>] xen_poll_irq+0x10/0x20
    [ 7279.648010]  [<ffffffff81011723>] xen_lock_spinning+0xb3/0x120
    [ 7279.648010]  [<ffffffff810115d1>] __raw_callee_save_xen_lock_spinning+0x11/0x20
    [ 7279.648010]  [<ffffffff815620b6>] ? usb_control_msg+0xe6/0x120
    [ 7279.648010]  [<ffffffff81747e50>] ? _raw_spin_lock_irq+0x50/0x60
    [ 7279.648010]  [<ffffffff8174522c>] wait_for_completion+0xac/0x160
    [ 7279.648010]  [<ffffffff8109c520>] ? try_to_wake_up+0x2c0/0x2c0
    [ 7279.648010]  [<ffffffff814b60f2>] dpm_wait+0x32/0x40
    [ 7279.648010]  [<ffffffff814b6eb0>] device_resume+0x90/0x210
    [ 7279.648010]  [<ffffffff814b7d71>] dpm_resume+0x121/0x250
    [ 7279.648010]  [<ffffffff8144c570>] ? xenbus_dev_request_and_reply+0xc0/0xc0
    [ 7279.648010]  [<ffffffff814b80d5>] dpm_resume_end+0x15/0x30
    [ 7279.648010]  [<ffffffff81449fba>] do_suspend+0x10a/0x200
    [ 7279.648010]  [<ffffffff8144a2f0>] ? xen_pre_suspend+0x20/0x20
    [ 7279.648010]  [<ffffffff8144a1d0>] shutdown_handler+0x120/0x150
    [ 7279.648010]  [<ffffffff8144c60f>] xenwatch_thread+0x9f/0x160
    [ 7279.648010]  [<ffffffff810ac510>] ? finish_wait+0x80/0x80
    [ 7279.648010]  [<ffffffff8108d189>] kthread+0xc9/0xe0
    [ 7279.648010]  [<ffffffff8108d0c0>] ? flush_kthread_worker+0x80/0x80
    [ 7279.648010]  [<ffffffff8175087c>] ret_from_fork+0x7c/0xb0
    [ 7279.648010]  [<ffffffff8108d0c0>] ? flush_kthread_worker+0x80/0x80
    
    [ 7441.216287] INFO: task khubd:89 blocked for more than 120 seconds.
    [ 7441.219457]       Tainted: G            X 3.13.11-ckt12.kz #1
    [ 7441.222176] "echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
    [ 7441.225827] khubd           D ffff88003f433440     0    89      2 0x00000000
    [ 7441.229258]  ffff88003ceb9b98 0000000000000046 ffff88003ce83000 0000000000013440
    [ 7441.232959]  ffff88003ceb9fd8 0000000000013440 ffff88003cd13000 ffff88003ce83000
    [ 7441.236658]  0000000000000286 ffff88003d3e0000 ffff88003ceb9bd0 00000001001aa01e
    [ 7441.240415] Call Trace:
    [ 7441.241614]  [<ffffffff817442f9>] schedule+0x29/0x70
    [ 7441.243930]  [<ffffffff81743406>] schedule_timeout+0x166/0x2c0
    [ 7441.246681]  [<ffffffff81075b80>] ? call_timer_fn+0x110/0x110
    [ 7441.249339]  [<ffffffff8174357e>] schedule_timeout_uninterruptible+0x1e/0x20
    [ 7441.252644]  [<ffffffff81077710>] msleep+0x20/0x30
    [ 7441.254812]  [<ffffffff81555f00>] hub_port_reset+0xf0/0x580
    [ 7441.257400]  [<ffffffff81558465>] hub_port_init+0x75/0xb40
    [ 7441.259981]  [<ffffffff814bb3c9>] ? update_autosuspend+0x39/0x60
    [ 7441.262817]  [<ffffffff814bb4f0>] ? pm_runtime_set_autosuspend_delay+0x50/0xa0
    [ 7441.266212]  [<ffffffff8155a64a>] hub_thread+0x71a/0x1750
    [ 7441.268728]  [<ffffffff810ac510>] ? finish_wait+0x80/0x80
    [ 7441.271272]  [<ffffffff81559f30>] ? usb_port_resume+0x670/0x670
    [ 7441.274067]  [<ffffffff8108d189>] kthread+0xc9/0xe0
    [ 7441.276305]  [<ffffffff8108d0c0>] ? flush_kthread_worker+0x80/0x80
    [ 7441.279131]  [<ffffffff8175087c>] ret_from_fork+0x7c/0xb0
    [ 7441.281659]  [<ffffffff8108d0c0>] ? flush_kthread_worker+0x80/0x80
    
    Signed-off-by: Ross Lagerwall <ross.lagerwall@citrix.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: David Vrabel <david.vrabel@citrix.com>

commit e0c4b58501fb05c14b25dabdbbbc747b53d19b98
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Fri Dec 12 14:01:49 2014 +0200

    HID: i2c-hid: Do not free buffers in i2c_hid_stop()
    
    commit 5b44c53aeb791757072be4a267255cedfff594fd upstream.
    
    When a hid driver that uses i2c-hid as transport is unloaded, the hid core
    will call i2c_hid_stop() which releases all the buffers associated with the
    device. This includes also the command buffer.
    
    Now, when the i2c-hid driver itself is unloaded it tries to power down the
    device by sending it PWR_SLEEP command. Since the command buffer is already
    released we get following crash:
    
     [   79.691459] BUG: unable to handle kernel NULL pointer dereference at           (null)
     [   79.691532] IP: [<ffffffffa05bc049>] __i2c_hid_command+0x49/0x310 [i2c_hid]
     ...
     [   79.693467] Call Trace:
     [   79.693494]  [<ffffffff810424e1>] ? __unmask_ioapic+0x21/0x30
     [   79.693537]  [<ffffffff81042855>] ? unmask_ioapic+0x25/0x40
     [   79.693581]  [<ffffffffa05bc35b>] ? i2c_hid_set_power+0x4b/0xa0 [i2c_hid]
     [   79.693632]  [<ffffffffa05bc3cf>] ? i2c_hid_runtime_resume+0x1f/0x30 [i2c_hid]
     [   79.693689]  [<ffffffff814c08fb>] ? __rpm_callback+0x2b/0x70
     [   79.693733]  [<ffffffff814c0961>] ? rpm_callback+0x21/0x90
     [   79.693776]  [<ffffffff814c0dec>] ? rpm_resume+0x41c/0x600
     [   79.693820]  [<ffffffff814c1e1c>] ? __pm_runtime_resume+0x4c/0x80
     [   79.693868]  [<ffffffff814b8588>] ? __device_release_driver+0x28/0x100
     [   79.693917]  [<ffffffff814b8d90>] ? driver_detach+0xa0/0xb0
     [   79.693959]  [<ffffffff814b82cc>] ? bus_remove_driver+0x4c/0xb0
     [   79.694006]  [<ffffffff810d1cfd>] ? SyS_delete_module+0x11d/0x1d0
     [   79.694054]  [<ffffffff8165f107>] ? int_signal+0x12/0x17
     [   79.694095]  [<ffffffff8165ee69>] ? system_call_fastpath+0x12/0x17
    
    Fix this so that we only free buffers when the i2c-hid driver itself is
    removed.
    
    Fixes: 34f439e4afcd ("HID: i2c-hid: add runtime PM support")
    Reported-by: Gabriele Mazzotta <gabriele.mzt@gmail.com>
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Reviewed-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 8bb664fb9eae47457b90ddc45a3ceaa504302727
Author: Benjamin Tissoires <benjamin.tissoires@redhat.com>
Date:   Mon Dec 1 11:52:40 2014 -0500

    HID: wacom: fix freeze on open when autosuspend is on
    
    commit dff674168878fe7b6d8b9ad60d62295ec517de79 upstream.
    
    Since the conversion from USB to HID (in v3.17), some people reported a
    freeze on boot with the wacom driver. Hans managed to get a stacktrace:
    
    [  240.272331] Call Trace:
    [  240.272338]  [<ffffffff813de7b9>] ? usb_hcd_submit_urb+0xa9/0xb10
    [  240.272347]  [<ffffffff81555579>] schedule+0x29/0x70
    [  240.272355]  [<ffffffff815559e6>] schedule_preempt_disabled+0x16/0x20
    [  240.272363]  [<ffffffff81557365>] __mutex_lock_slowpath+0xe5/0x230
    [  240.272372]  [<ffffffff815574c7>] mutex_lock+0x17/0x30
    [  240.272380]  [<ffffffffa063c1d2>] wacom_resume+0x22/0x50 [wacom]
    [  240.272396]  [<ffffffffa01aea8a>] hid_resume_common+0xba/0x110 [usbhid]
    [  240.272404]  [<ffffffff813e5890>] ? usb_runtime_suspend+0x80/0x80
    [  240.272417]  [<ffffffffa01aeb1d>] hid_resume+0x3d/0x70 [usbhid]
    [  240.272425]  [<ffffffff813e44a6>] usb_resume_interface.isra.6+0xb6/0x120
    [  240.272432]  [<ffffffff813e4774>] usb_resume_both+0x74/0x140
    [  240.272439]  [<ffffffff813e58aa>] usb_runtime_resume+0x1a/0x20
    [  240.272446]  [<ffffffff813b1912>] __rpm_callback+0x32/0x70
    [  240.272453]  [<ffffffff813b1976>] rpm_callback+0x26/0xa0
    [  240.272460]  [<ffffffff813b2d71>] rpm_resume+0x4b1/0x690
    [  240.272468]  [<ffffffff812ab992>] ? radix_tree_lookup_slot+0x22/0x50
    [  240.272475]  [<ffffffff813b2c1a>] rpm_resume+0x35a/0x690
    [  240.272482]  [<ffffffff8116e9c9>] ? zone_statistics+0x89/0xa0
    [  240.272489]  [<ffffffff813b2f90>] __pm_runtime_resume+0x40/0x60
    [  240.272497]  [<ffffffff813e4272>] usb_autopm_get_interface+0x22/0x60
    [  240.272509]  [<ffffffffa01ae8d9>] usbhid_open+0x59/0xe0 [usbhid]
    [  240.272517]  [<ffffffffa063ac85>] wacom_open+0x35/0x50 [wacom]
    [  240.272525]  [<ffffffff813f37b9>] input_open_device+0x79/0xa0
    [  240.272534]  [<ffffffffa048d1c1>] evdev_open+0x1b1/0x200 [evdev]
    [  240.272543]  [<ffffffff811c899e>] chrdev_open+0xae/0x1f0
    [  240.272549]  [<ffffffff811c88f0>] ? cdev_put+0x30/0x30
    [  240.272556]  [<ffffffff811c17e2>] do_dentry_open+0x1d2/0x320
    [  240.272562]  [<ffffffff811c1cd1>] finish_open+0x31/0x50
    [  240.272571]  [<ffffffff811d2202>] do_last.isra.36+0x652/0xe50
    [  240.272579]  [<ffffffff811d2ac7>] path_openat+0xc7/0x6f0
    [  240.272586]  [<ffffffff811cf012>] ? final_putname+0x22/0x50
    [  240.272594]  [<ffffffff811d42d2>] ? user_path_at_empty+0x72/0xd0
    [  240.272602]  [<ffffffff811d43fd>] do_filp_open+0x4d/0xc0
    [...]
    
    So here, wacom_open is called, and then wacom_resume is called by the
    PM system. However, wacom_open already took the lock when wacom_resume
    tries to get it. Freeze.
    
    A little bit of history shows that this already happened in the past
    - commit f6cd378372bf ("Input: wacom - fix runtime PM related deadlock"),
    and the solution was to call first the PM function before taking the lock.
    
    The lock was introduced in commit commit e722409445fb ("Input: wacom -
    implement suspend and autosuspend") when the autosuspend feature has
    been added. Given that usbhid already takes care of this very same
    locking between suspend/resume, I think we can simply kill the lock
    in open/close.
    
    The lock is now used also with LEDs, so we can not remove it completely.
    
    Reported-by: Hans Spath <inbox-546@hans-spath.de>
    Tested-by: Hans Spath <inbox-546@hans-spath.de>
    Signed-off-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit cfa91192af245c9d90dfd7327113e7f483a0d286
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Fri Dec 12 14:01:49 2014 +0200

    HID: i2c-hid: Do not free buffers in i2c_hid_stop()
    
    commit 5b44c53aeb791757072be4a267255cedfff594fd upstream.
    
    When a hid driver that uses i2c-hid as transport is unloaded, the hid core
    will call i2c_hid_stop() which releases all the buffers associated with the
    device. This includes also the command buffer.
    
    Now, when the i2c-hid driver itself is unloaded it tries to power down the
    device by sending it PWR_SLEEP command. Since the command buffer is already
    released we get following crash:
    
     [   79.691459] BUG: unable to handle kernel NULL pointer dereference at           (null)
     [   79.691532] IP: [<ffffffffa05bc049>] __i2c_hid_command+0x49/0x310 [i2c_hid]
     ...
     [   79.693467] Call Trace:
     [   79.693494]  [<ffffffff810424e1>] ? __unmask_ioapic+0x21/0x30
     [   79.693537]  [<ffffffff81042855>] ? unmask_ioapic+0x25/0x40
     [   79.693581]  [<ffffffffa05bc35b>] ? i2c_hid_set_power+0x4b/0xa0 [i2c_hid]
     [   79.693632]  [<ffffffffa05bc3cf>] ? i2c_hid_runtime_resume+0x1f/0x30 [i2c_hid]
     [   79.693689]  [<ffffffff814c08fb>] ? __rpm_callback+0x2b/0x70
     [   79.693733]  [<ffffffff814c0961>] ? rpm_callback+0x21/0x90
     [   79.693776]  [<ffffffff814c0dec>] ? rpm_resume+0x41c/0x600
     [   79.693820]  [<ffffffff814c1e1c>] ? __pm_runtime_resume+0x4c/0x80
     [   79.693868]  [<ffffffff814b8588>] ? __device_release_driver+0x28/0x100
     [   79.693917]  [<ffffffff814b8d90>] ? driver_detach+0xa0/0xb0
     [   79.693959]  [<ffffffff814b82cc>] ? bus_remove_driver+0x4c/0xb0
     [   79.694006]  [<ffffffff810d1cfd>] ? SyS_delete_module+0x11d/0x1d0
     [   79.694054]  [<ffffffff8165f107>] ? int_signal+0x12/0x17
     [   79.694095]  [<ffffffff8165ee69>] ? system_call_fastpath+0x12/0x17
    
    Fix this so that we only free buffers when the i2c-hid driver itself is
    removed.
    
    Fixes: 34f439e4afcd ("HID: i2c-hid: add runtime PM support")
    Reported-by: Gabriele Mazzotta <gabriele.mzt@gmail.com>
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Reviewed-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>
    Signed-off-by: Luis Henriques <luis.henriques@canonical.com>

commit 5b44c53aeb791757072be4a267255cedfff594fd
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Fri Dec 12 14:01:49 2014 +0200

    HID: i2c-hid: Do not free buffers in i2c_hid_stop()
    
    When a hid driver that uses i2c-hid as transport is unloaded, the hid core
    will call i2c_hid_stop() which releases all the buffers associated with the
    device. This includes also the command buffer.
    
    Now, when the i2c-hid driver itself is unloaded it tries to power down the
    device by sending it PWR_SLEEP command. Since the command buffer is already
    released we get following crash:
    
     [   79.691459] BUG: unable to handle kernel NULL pointer dereference at           (null)
     [   79.691532] IP: [<ffffffffa05bc049>] __i2c_hid_command+0x49/0x310 [i2c_hid]
     ...
     [   79.693467] Call Trace:
     [   79.693494]  [<ffffffff810424e1>] ? __unmask_ioapic+0x21/0x30
     [   79.693537]  [<ffffffff81042855>] ? unmask_ioapic+0x25/0x40
     [   79.693581]  [<ffffffffa05bc35b>] ? i2c_hid_set_power+0x4b/0xa0 [i2c_hid]
     [   79.693632]  [<ffffffffa05bc3cf>] ? i2c_hid_runtime_resume+0x1f/0x30 [i2c_hid]
     [   79.693689]  [<ffffffff814c08fb>] ? __rpm_callback+0x2b/0x70
     [   79.693733]  [<ffffffff814c0961>] ? rpm_callback+0x21/0x90
     [   79.693776]  [<ffffffff814c0dec>] ? rpm_resume+0x41c/0x600
     [   79.693820]  [<ffffffff814c1e1c>] ? __pm_runtime_resume+0x4c/0x80
     [   79.693868]  [<ffffffff814b8588>] ? __device_release_driver+0x28/0x100
     [   79.693917]  [<ffffffff814b8d90>] ? driver_detach+0xa0/0xb0
     [   79.693959]  [<ffffffff814b82cc>] ? bus_remove_driver+0x4c/0xb0
     [   79.694006]  [<ffffffff810d1cfd>] ? SyS_delete_module+0x11d/0x1d0
     [   79.694054]  [<ffffffff8165f107>] ? int_signal+0x12/0x17
     [   79.694095]  [<ffffffff8165ee69>] ? system_call_fastpath+0x12/0x17
    
    Fix this so that we only free buffers when the i2c-hid driver itself is
    removed.
    
    Fixes: 34f439e4afcd ("HID: i2c-hid: add runtime PM support")
    Reported-by: Gabriele Mazzotta <gabriele.mzt@gmail.com>
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Reviewed-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

commit 3a647c1d7ab08145cee4b650f5e797d168846c51
Merge: 6cd94d5e57ab 5db45002576f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Dec 9 14:48:22 2014 -0800

    Merge tag 'drivers-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC driver updates from Arnd Bergmann:
     "These are changes for drivers that are intimately tied to some SoC and
      for some reason could not get merged through the respective subsystem
      maintainer tree.
    
      The largest single change here this time around is the Tegra
      iommu/memory controller driver, which gets updated to the new iommu DT
      binding.  More drivers like this are likely to follow for the
      following merge window, but we should be able to do those through the
      iommu maintainer.
    
      Other notable changes are:
       - reset controller drivers from the reset maintainer (socfpga, sti,
         berlin)
       - fixes for the keystone navigator driver merged last time
       - at91 rtc driver changes related to the at91 cleanups
       - ARM perf driver changes from Will Deacon
       - updates for the brcmstb_gisb driver"
    
    * tag 'drivers-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (53 commits)
      clocksource: arch_timer: Allow the device tree to specify uninitialized timer registers
      clocksource: arch_timer: Fix code to use physical timers when requested
      memory: Add NVIDIA Tegra memory controller support
      bus: brcmstb_gisb: Add register offset tables for older chips
      bus: brcmstb_gisb: Look up register offsets in a table
      bus: brcmstb_gisb: Introduce wrapper functions for MMIO accesses
      bus: brcmstb_gisb: Make the driver buildable on MIPS
      of: Add NVIDIA Tegra memory controller binding
      ARM: tegra: Move AHB Kconfig to drivers/amba
      amba: Add Kconfig file
      clk: tegra: Implement memory-controller clock
      serial: samsung: Fix serial config dependencies for exynos7
      bus: brcmstb_gisb: resolve section mismatch
      ARM: common: edma: edma_pm_resume may be unused
      ARM: common: edma: add suspend resume hook
      powerpc/iommu: Rename iommu_[un]map_sg functions
      rtc: at91sam9: add DT bindings documentation
      rtc: at91sam9: use clk API instead of relying on AT91_SLOW_CLOCK
      ARM: at91: add clk_lookup entry for RTT devices
      rtc: at91sam9: rework the Kconfig description
      ...

commit dff674168878fe7b6d8b9ad60d62295ec517de79
Author: Benjamin Tissoires <benjamin.tissoires@redhat.com>
Date:   Mon Dec 1 11:52:40 2014 -0500

    HID: wacom: fix freeze on open when autosuspend is on
    
    Since the conversion from USB to HID (in v3.17), some people reported a
    freeze on boot with the wacom driver. Hans managed to get a stacktrace:
    
    [  240.272331] Call Trace:
    [  240.272338]  [<ffffffff813de7b9>] ? usb_hcd_submit_urb+0xa9/0xb10
    [  240.272347]  [<ffffffff81555579>] schedule+0x29/0x70
    [  240.272355]  [<ffffffff815559e6>] schedule_preempt_disabled+0x16/0x20
    [  240.272363]  [<ffffffff81557365>] __mutex_lock_slowpath+0xe5/0x230
    [  240.272372]  [<ffffffff815574c7>] mutex_lock+0x17/0x30
    [  240.272380]  [<ffffffffa063c1d2>] wacom_resume+0x22/0x50 [wacom]
    [  240.272396]  [<ffffffffa01aea8a>] hid_resume_common+0xba/0x110 [usbhid]
    [  240.272404]  [<ffffffff813e5890>] ? usb_runtime_suspend+0x80/0x80
    [  240.272417]  [<ffffffffa01aeb1d>] hid_resume+0x3d/0x70 [usbhid]
    [  240.272425]  [<ffffffff813e44a6>] usb_resume_interface.isra.6+0xb6/0x120
    [  240.272432]  [<ffffffff813e4774>] usb_resume_both+0x74/0x140
    [  240.272439]  [<ffffffff813e58aa>] usb_runtime_resume+0x1a/0x20
    [  240.272446]  [<ffffffff813b1912>] __rpm_callback+0x32/0x70
    [  240.272453]  [<ffffffff813b1976>] rpm_callback+0x26/0xa0
    [  240.272460]  [<ffffffff813b2d71>] rpm_resume+0x4b1/0x690
    [  240.272468]  [<ffffffff812ab992>] ? radix_tree_lookup_slot+0x22/0x50
    [  240.272475]  [<ffffffff813b2c1a>] rpm_resume+0x35a/0x690
    [  240.272482]  [<ffffffff8116e9c9>] ? zone_statistics+0x89/0xa0
    [  240.272489]  [<ffffffff813b2f90>] __pm_runtime_resume+0x40/0x60
    [  240.272497]  [<ffffffff813e4272>] usb_autopm_get_interface+0x22/0x60
    [  240.272509]  [<ffffffffa01ae8d9>] usbhid_open+0x59/0xe0 [usbhid]
    [  240.272517]  [<ffffffffa063ac85>] wacom_open+0x35/0x50 [wacom]
    [  240.272525]  [<ffffffff813f37b9>] input_open_device+0x79/0xa0
    [  240.272534]  [<ffffffffa048d1c1>] evdev_open+0x1b1/0x200 [evdev]
    [  240.272543]  [<ffffffff811c899e>] chrdev_open+0xae/0x1f0
    [  240.272549]  [<ffffffff811c88f0>] ? cdev_put+0x30/0x30
    [  240.272556]  [<ffffffff811c17e2>] do_dentry_open+0x1d2/0x320
    [  240.272562]  [<ffffffff811c1cd1>] finish_open+0x31/0x50
    [  240.272571]  [<ffffffff811d2202>] do_last.isra.36+0x652/0xe50
    [  240.272579]  [<ffffffff811d2ac7>] path_openat+0xc7/0x6f0
    [  240.272586]  [<ffffffff811cf012>] ? final_putname+0x22/0x50
    [  240.272594]  [<ffffffff811d42d2>] ? user_path_at_empty+0x72/0xd0
    [  240.272602]  [<ffffffff811d43fd>] do_filp_open+0x4d/0xc0
    [...]
    
    So here, wacom_open is called, and then wacom_resume is called by the
    PM system. However, wacom_open already took the lock when wacom_resume
    tries to get it. Freeze.
    
    A little bit of history shows that this already happened in the past
    - commit f6cd378372bf ("Input: wacom - fix runtime PM related deadlock"),
    and the solution was to call first the PM function before taking the lock.
    
    The lock was introduced in commit commit e722409445fb ("Input: wacom -
    implement suspend and autosuspend") when the autosuspend feature has
    been added. Given that usbhid already takes care of this very same
    locking between suspend/resume, I think we can simply kill the lock
    in open/close.
    
    The lock is now used also with LEDs, so we can not remove it completely.
    
    Reported-by: Hans Spath <inbox-546@hans-spath.de>
    Tested-by: Hans Spath <inbox-546@hans-spath.de>
    CC: stable@vger.kernel.org # v3.17+
    Signed-off-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

commit a850c427029e5b9953fe4d4fe4fef10a61ee165a
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Nov 21 11:48:54 2014 +0100

    ARM: common: edma: edma_pm_resume may be unused
    
    The recently introduced resume hook in the edma driver
    is not referenced when CONFIG_PM_SLEEP is not set, which
    results in a compile warning in keystone builds.
    
    This adds an appropriate #ifdef.
    
    Cc: Nishanth Menon <nm@ti.com>
    Cc: Daniel Mack <zonque@gmail.com>
    Cc: Joel Fernandes <joelf@ti.com>
    Acked-by: Sekhar Nori <nsekhar@ti.com>
    Fixes: a2b1175131: ("ARM: common: edma: add suspend resume hook")
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

commit a1fc1920aaaaeadc7cf9d80fc16e6b8eca722b44
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Thu Nov 13 18:33:08 2014 +0100

    usb: musb: core: make sure musb is in RPM_ACTIVE on resume
    
    On am335x-evm with musb in host mode and using it as a wakeup source the
    following happens once the CPU comes out of suspend to ram:
    |PM: Wakeup source MPU_WAKE
    |PM: noirq resume of devices complete after 15.453 msecs
    |PM: early resume of devices complete after 2.222 msecs
    |PM: resume of devices complete after 507.351 msecs
    |Restarting tasks ...
    |------------[ cut here ]------------
    |WARNING: CPU: 0 PID: 322 at drivers/usb/core/urb.c:339 usb_submit_urb+0x494/0x4c8()
    |URB cc0db380 submitted while active
    |[<c0348e64>] (usb_submit_urb) from [<c0340f94>] (hub_activate+0x2b8/0x49c)
    |[<c0340f94>] (hub_activate) from [<c03411dc>] (hub_resume+0x14/0x1c)
    |[<c03411dc>] (hub_resume) from [<c034be10>] (usb_resume_interface.isra.4+0xdc/0x110)
    |[<c034be10>] (usb_resume_interface.isra.4) from [<c034beb0>] (usb_resume_both+0x6c/0x13c)
    |[<c034beb0>] (usb_resume_both) from [<c034cca4>] (usb_runtime_resume+0x10/0x14)
    |[<c034cca4>] (usb_runtime_resume) from [<c02bbd80>] (__rpm_callback+0x2c/0x60)
    |[<c02bbd80>] (__rpm_callback) from [<c02bbdd4>] (rpm_callback+0x20/0x74)
    |[<c02bbdd4>] (rpm_callback) from [<c02bcc48>] (rpm_resume+0x380/0x548)
    |[<c02bcc48>] (rpm_resume) from [<c02bcb00>] (rpm_resume+0x238/0x548)
    |[<c02bcb00>] (rpm_resume) from [<c02bd08c>] (__pm_runtime_resume+0x64/0x94)
    |[<c02bd08c>] (__pm_runtime_resume) from [<c034b5a4>] (usb_autopm_get_interface+0x18/0x5c)
    |[<c034b5a4>] (usb_autopm_get_interface) from [<c03438b8>] (hub_thread+0x10c/0x115c)
    |[<c03438b8>] (hub_thread) from [<c005a70c>] (kthread+0xbc/0xd8)
    |---[ end trace 036aa5fe78203142 ]---
    |hub 1-0:1.0: activate --> -16
    |hub 2-0:1.0: activate --> -16
    
    The reason for this backtrace is the attempt of the USB code to resume
    the HUB twice and thus enqueue the status URB twice.
    Alan Stern was a great help by explaining how the USB code supposed to
    work and what is most likely the problem. The root problem is that after
    resume the musb runtime-suspend state remains RPM_SUSPENDED.
    According to git log it RPM was added for the omap2430 platform. If I
    understand it correct the omap2430 invokes a get on musb once a cable is
    connected and a put once the cable is gone. In between the device could
    go auto-idle/off. Not sure what happens when the device goes into suspend
    but then I guess it was gadget only.
    On DSPS I see only a get in probe and put in remove function. This would
    forbid RPM from working but then the devices enterns suspended state
    anyway :)
    
    To get rid of this warning, I set the device state to RPM_ACTIVE which
    the expected state.
    
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

commit 33339684de46070d34e1dc11b590971b20a3d25b
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Mon Oct 27 21:35:13 2014 +0900

    dmaengine: sirf: Add CONFIG_PM_SLEEP to suspend/resume functions
    
    Add CONFIG_PM_SLEEP to suspend/resume functions to fix the following
    build warning when CONFIG_PM_SLEEP is not selected. This is because
    sleep PM callbacks defined by SET_SYSTEM_SLEEP_PM_OPS are only used
    when the CONFIG_PM_SLEEP is enabled.
    
    drivers/dma/sirf-dma.c:838:12: warning: 'sirfsoc_dma_pm_suspend' defined but not used [-Wunused-function]
    drivers/dma/sirf-dma.c:879:12: warning: 'sirfsoc_dma_pm_resume' defined but not used [-Wunused-function]
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

commit d8494c06b6102a79d4c5cb991e5b32dc83079ab0
Author: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
Date:   Thu Aug 7 18:07:07 2014 +0200

    mmc: sdhci-s3c: fix runtime PM handling on sdhci_add_host() failure
    
    commit 221414db1934c1c883501998f510bb75acfbaa51 upstream.
    
    Runtime Power Management handling for the sdhci_add_host() failure
    case in sdhci_s3c_probe() should match the code in sdhci_s3c_remove()
    (which uses pm_runtime_disable() call which matches the earlier
    pm_runtime_enable() one).  Fix it.
    
    This patch fixes "BUG: spinlock bad magic on CPU#0, swapper/0/1" and
    "Unbalanced pm_runtime_enable!" warnings.
    
    >From the kernel log:
    ...
    [    1.659631] s3c-sdhci 12530000.sdhci: sdhci_add_host() failed
    [    1.665096] BUG: spinlock bad magic on CPU#0, swapper/0/1
    [    1.670433]  lock: 0xea01e484, .magic: 00000000, .owner: <none>/-1, .owner_cpu: 0
    [    1.677895] CPU: 0 PID: 1 Comm: swapper/0 Not tainted 3.16.0-next-20140804-00008-ga59480f-dirty #707
    [    1.687037] [<c0013ae4>] (unwind_backtrace) from [<c0010d70>] (show_stack+0x10/0x14)
    [    1.694740] [<c0010d70>] (show_stack) from [<c04050c8>] (dump_stack+0x68/0xb8)
    [    1.701948] [<c04050c8>] (dump_stack) from [<c0052558>] (do_raw_spin_lock+0x15c/0x1a4)
    [    1.709848] [<c0052558>] (do_raw_spin_lock) from [<c040a630>] (_raw_spin_lock_irqsave+0x20/0x28)
    [    1.718619] [<c040a630>] (_raw_spin_lock_irqsave) from [<c030d7d0>] (sdhci_do_set_ios+0x1c/0x5cc)
    [    1.727464] [<c030d7d0>] (sdhci_do_set_ios) from [<c030ddfc>] (sdhci_runtime_resume_host+0x50/0x104)
    [    1.736574] [<c030ddfc>] (sdhci_runtime_resume_host) from [<c02462dc>] (pm_generic_runtime_resume+0x2c/0x40)
    [    1.746383] [<c02462dc>] (pm_generic_runtime_resume) from [<c0247898>] (__rpm_callback+0x34/0x70)
    [    1.755233] [<c0247898>] (__rpm_callback) from [<c02478fc>] (rpm_callback+0x28/0x88)
    [    1.762958] [<c02478fc>] (rpm_callback) from [<c02486f0>] (rpm_resume+0x384/0x4ec)
    [    1.770511] [<c02486f0>] (rpm_resume) from [<c02488b0>] (pm_runtime_forbid+0x58/0x64)
    [    1.778325] [<c02488b0>] (pm_runtime_forbid) from [<c030ea70>] (sdhci_s3c_probe+0x4a4/0x540)
    [    1.786749] [<c030ea70>] (sdhci_s3c_probe) from [<c02429cc>] (platform_drv_probe+0x2c/0x5c)
    [    1.795076] [<c02429cc>] (platform_drv_probe) from [<c02415f0>] (driver_probe_device+0x114/0x234)
    [    1.803929] [<c02415f0>] (driver_probe_device) from [<c024179c>] (__driver_attach+0x8c/0x90)
    [    1.812347] [<c024179c>] (__driver_attach) from [<c023ffb4>] (bus_for_each_dev+0x54/0x88)
    [    1.820506] [<c023ffb4>] (bus_for_each_dev) from [<c0240df8>] (bus_add_driver+0xd8/0x1cc)
    [    1.828665] [<c0240df8>] (bus_add_driver) from [<c0241db8>] (driver_register+0x78/0xf4)
    [    1.836652] [<c0241db8>] (driver_register) from [<c00088a4>] (do_one_initcall+0x80/0x1d0)
    [    1.844816] [<c00088a4>] (do_one_initcall) from [<c059ac94>] (kernel_init_freeable+0x108/0x1d4)
    [    1.853503] [<c059ac94>] (kernel_init_freeable) from [<c0401300>] (kernel_init+0x8/0xe4)
    [    1.861568] [<c0401300>] (kernel_init) from [<c000e538>] (ret_from_fork+0x14/0x3c)
    [    1.869582] platform 12530000.sdhci: Driver s3c-sdhci requests probe deferral
    ...
    [    1.997047] s3c-sdhci 12530000.sdhci: Unbalanced pm_runtime_enable!
    ...
    [    2.027235] s3c-sdhci 12530000.sdhci: sdhci_add_host() failed
    [    2.032884] platform 12530000.sdhci: Driver s3c-sdhci requests probe deferral
    ...
    
    Tested on Hardkernel's Exynos4412 based ODROID-U3 board.
    
    Fixes: 9f4e8151dbbc ("mmc: sdhci-s3c: Enable runtime power management")
    Cc: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Cc: Jaehoon Chung <jh80.chung@samsung.com>
    Cc: Ben Dooks <ben-linux@fluff.org>
    Signed-off-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Acked-by: Kyungmin Park <kyungmin.park@samsung.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit aadefebf34df8c74cf2aa6e35459e258c85047c0
Author: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
Date:   Thu Aug 7 18:07:07 2014 +0200

    mmc: sdhci-s3c: fix runtime PM handling on sdhci_add_host() failure
    
    commit 221414db1934c1c883501998f510bb75acfbaa51 upstream.
    
    Runtime Power Management handling for the sdhci_add_host() failure
    case in sdhci_s3c_probe() should match the code in sdhci_s3c_remove()
    (which uses pm_runtime_disable() call which matches the earlier
    pm_runtime_enable() one).  Fix it.
    
    This patch fixes "BUG: spinlock bad magic on CPU#0, swapper/0/1" and
    "Unbalanced pm_runtime_enable!" warnings.
    
    >From the kernel log:
    ...
    [    1.659631] s3c-sdhci 12530000.sdhci: sdhci_add_host() failed
    [    1.665096] BUG: spinlock bad magic on CPU#0, swapper/0/1
    [    1.670433]  lock: 0xea01e484, .magic: 00000000, .owner: <none>/-1, .owner_cpu: 0
    [    1.677895] CPU: 0 PID: 1 Comm: swapper/0 Not tainted 3.16.0-next-20140804-00008-ga59480f-dirty #707
    [    1.687037] [<c0013ae4>] (unwind_backtrace) from [<c0010d70>] (show_stack+0x10/0x14)
    [    1.694740] [<c0010d70>] (show_stack) from [<c04050c8>] (dump_stack+0x68/0xb8)
    [    1.701948] [<c04050c8>] (dump_stack) from [<c0052558>] (do_raw_spin_lock+0x15c/0x1a4)
    [    1.709848] [<c0052558>] (do_raw_spin_lock) from [<c040a630>] (_raw_spin_lock_irqsave+0x20/0x28)
    [    1.718619] [<c040a630>] (_raw_spin_lock_irqsave) from [<c030d7d0>] (sdhci_do_set_ios+0x1c/0x5cc)
    [    1.727464] [<c030d7d0>] (sdhci_do_set_ios) from [<c030ddfc>] (sdhci_runtime_resume_host+0x50/0x104)
    [    1.736574] [<c030ddfc>] (sdhci_runtime_resume_host) from [<c02462dc>] (pm_generic_runtime_resume+0x2c/0x40)
    [    1.746383] [<c02462dc>] (pm_generic_runtime_resume) from [<c0247898>] (__rpm_callback+0x34/0x70)
    [    1.755233] [<c0247898>] (__rpm_callback) from [<c02478fc>] (rpm_callback+0x28/0x88)
    [    1.762958] [<c02478fc>] (rpm_callback) from [<c02486f0>] (rpm_resume+0x384/0x4ec)
    [    1.770511] [<c02486f0>] (rpm_resume) from [<c02488b0>] (pm_runtime_forbid+0x58/0x64)
    [    1.778325] [<c02488b0>] (pm_runtime_forbid) from [<c030ea70>] (sdhci_s3c_probe+0x4a4/0x540)
    [    1.786749] [<c030ea70>] (sdhci_s3c_probe) from [<c02429cc>] (platform_drv_probe+0x2c/0x5c)
    [    1.795076] [<c02429cc>] (platform_drv_probe) from [<c02415f0>] (driver_probe_device+0x114/0x234)
    [    1.803929] [<c02415f0>] (driver_probe_device) from [<c024179c>] (__driver_attach+0x8c/0x90)
    [    1.812347] [<c024179c>] (__driver_attach) from [<c023ffb4>] (bus_for_each_dev+0x54/0x88)
    [    1.820506] [<c023ffb4>] (bus_for_each_dev) from [<c0240df8>] (bus_add_driver+0xd8/0x1cc)
    [    1.828665] [<c0240df8>] (bus_add_driver) from [<c0241db8>] (driver_register+0x78/0xf4)
    [    1.836652] [<c0241db8>] (driver_register) from [<c00088a4>] (do_one_initcall+0x80/0x1d0)
    [    1.844816] [<c00088a4>] (do_one_initcall) from [<c059ac94>] (kernel_init_freeable+0x108/0x1d4)
    [    1.853503] [<c059ac94>] (kernel_init_freeable) from [<c0401300>] (kernel_init+0x8/0xe4)
    [    1.861568] [<c0401300>] (kernel_init) from [<c000e538>] (ret_from_fork+0x14/0x3c)
    [    1.869582] platform 12530000.sdhci: Driver s3c-sdhci requests probe deferral
    ...
    [    1.997047] s3c-sdhci 12530000.sdhci: Unbalanced pm_runtime_enable!
    ...
    [    2.027235] s3c-sdhci 12530000.sdhci: sdhci_add_host() failed
    [    2.032884] platform 12530000.sdhci: Driver s3c-sdhci requests probe deferral
    ...
    
    Tested on Hardkernel's Exynos4412 based ODROID-U3 board.
    
    Fixes: 9f4e8151dbbc ("mmc: sdhci-s3c: Enable runtime power management")
    Cc: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Cc: Jaehoon Chung <jh80.chung@samsung.com>
    Cc: Ben Dooks <ben-linux@fluff.org>
    Signed-off-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Acked-by: Kyungmin Park <kyungmin.park@samsung.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Luis Henriques <luis.henriques@canonical.com>

commit b528392669415dc1e53a047215e5ad6c2de879fc
Merge: 80213c03c415 9f1a05329695
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Oct 9 16:07:43 2014 -0400

    Merge tag 'pm+acpi-3.18-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull ACPI and power management updates from Rafael Wysocki:
     "Features-wise, to me the most important this time is a rework of
      wakeup interrupts handling in the core that makes them work
      consistently across all of the available sleep states, including
      suspend-to-idle.  Many thanks to Thomas Gleixner for his help with
      this work.
    
      Second is an update of the generic PM domains code that has been in
      need of some care for quite a while.  Unused code is being removed, DT
      support is being added and domains are now going to be attached to
      devices in bus type code in analogy with the ACPI PM domain.  The
      majority of work here was done by Ulf Hansson who also has been the
      most active developer this time.
    
      Apart from this we have a traditional ACPICA update, this time to
      upstream version 20140828 and a few ACPI wakeup interrupts handling
      patches on top of the general rework mentioned above.  There also are
      several cpufreq commits including renaming the cpufreq-cpu0 driver to
      cpufreq-dt, as this is what implements generic DT-based cpufreq
      support, and a new DT-based idle states infrastructure for cpuidle.
    
      In addition to that, the ACPI LPSS driver is updated, ACPI support for
      Apple machines is improved, a few bugs are fixed and a few cleanups
      are made all over.
    
      Finally, the Adaptive Voltage Scaling (AVS) subsystem now has a tree
      maintained by Kevin Hilman that will be merged through the PM tree.
    
      Numbers-wise, the generic PM domains update takes the lead this time
      with 32 non-merge commits, second is cpufreq (15 commits) and the 3rd
      place goes to the wakeup interrupts handling rework (13 commits).
    
      Specifics:
    
       - Rework the handling of wakeup IRQs by the IRQ core such that all of
         them will be switched over to "wakeup" mode in suspend_device_irqs()
         and in that mode the first interrupt will abort system suspend in
         progress or wake up the system if already in suspend-to-idle (or
         equivalent) without executing any interrupt handlers.  Among other
         things that eliminates the wakeup-related motivation to use the
         IRQF_NO_SUSPEND interrupt flag with interrupts which don't really
         need it and should not use it (Thomas Gleixner and Rafael Wysocki)
    
       - Switch over ACPI to handling wakeup interrupts with the help of the
         new mechanism introduced by the above IRQ core rework (Rafael Wysocki)
    
       - Rework the core generic PM domains code to eliminate code that's
         not used, add DT support and add a generic mechanism by which
         devices can be added to PM domains automatically during enumeration
         (Ulf Hansson, Geert Uytterhoeven and Tomasz Figa).
    
       - Add debugfs-based mechanics for debugging generic PM domains
         (Maciej Matraszek).
    
       - ACPICA update to upstream version 20140828.  Included are updates
         related to the SRAT and GTDT tables and the _PSx methods are in the
         METHOD_NAME list now (Bob Moore and Hanjun Guo).
    
       - Add _OSI("Darwin") support to the ACPI core (unfortunately, that
         can't really be done in a straightforward way) to prevent
         Thunderbolt from being turned off on Apple systems after boot (or
         after resume from system suspend) and rework the ACPI Smart Battery
         Subsystem (SBS) driver to work correctly with Apple platforms
         (Matthew Garrett and Andreas Noever).
    
       - ACPI LPSS (Low-Power Subsystem) driver update cleaning up the code,
         adding support for 133MHz I2C source clock on Intel Baytrail to it
         and making it avoid using UART RTS override with Auto Flow Control
         (Heikki Krogerus).
    
       - ACPI backlight updates removing the video_set_use_native_backlight
         quirk which is not necessary any more, making the code check the
         list of output devices returned by the _DOD method to avoid
         creating acpi_video interfaces that won't work and adding a quirk
         for Lenovo Ideapad Z570 (Hans de Goede, Aaron Lu and Stepan Bujnak)
    
       - New Win8 ACPI OSI quirks for some Dell laptops (Edward Lin)
    
       - Assorted ACPI code cleanups (Fabian Frederick, Rasmus Villemoes,
         Sudip Mukherjee, Yijing Wang, and Zhang Rui)
    
       - cpufreq core updates and cleanups (Viresh Kumar, Preeti U Murthy,
         Rasmus Villemoes)
    
       - cpufreq driver updates: cpufreq-cpu0/cpufreq-dt (driver name change
         among other things), ppc-corenet, powernv (Viresh Kumar, Preeti U
         Murthy, Shilpasri G Bhat, Lucas Stach)
    
       - cpuidle support for DT-based idle states infrastructure, new ARM64
         cpuidle driver, cpuidle core cleanups (Lorenzo Pieralisi, Rasmus
         Villemoes)
    
       - ARM big.LITTLE cpuidle driver updates: support for DT-based
         initialization and Exynos5800 compatible string (Lorenzo Pieralisi,
         Kevin Hilman)
    
       - Rework of the test_suspend kernel command line argument and a new
         trace event for console resume (Srinivas Pandruvada, Todd E Brandt)
    
       - Second attempt to optimize swsusp_free() (hibernation core) to make
         it avoid going through all PFNs which may be way too slow on some
         systems (Joerg Roedel)
    
       - devfreq updates (Paul Bolle, Punit Agrawal, rjan Eide).
    
       - rockchip-io Adaptive Voltage Scaling (AVS) driver and AVS entry
         update in MAINTAINERS (Heiko Stbner, Kevin Hilman)
    
       - PM core fix related to clock management (Geert Uytterhoeven)
    
       - PM core's sysfs code cleanup (Johannes Berg)"
    
    * tag 'pm+acpi-3.18-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (105 commits)
      ACPI / fan: printk replacement
      PM / clk: Fix crash in clocks management code if !CONFIG_PM_RUNTIME
      PM / Domains: Rename cpu_data to cpuidle_data
      cpufreq: cpufreq-dt: fix potential double put of cpu OF node
      cpufreq: cpu0: rename driver and internals to 'cpufreq_dt'
      PM / hibernate: Iterate over set bits instead of PFNs in swsusp_free()
      cpufreq: ppc-corenet: remove duplicate update of cpu_data
      ACPI / sleep: Rework the handling of ACPI GPE wakeup from suspend-to-idle
      PM / sleep: Rename platform suspend/resume functions in suspend.c
      PM / sleep: Export dpm_suspend_late/noirq() and dpm_resume_early/noirq()
      ACPICA: Introduce acpi_enable_all_wakeup_gpes()
      ACPICA: Clear all non-wakeup GPEs in acpi_hw_enable_wakeup_gpe_block()
      ACPI / video: check _DOD list when creating backlight devices
      PM / Domains: Move dev_pm_domain_attach|detach() to pm_domain.h
      cpufreq: Replace strnicmp with strncasecmp
      cpufreq: powernv: Set the cpus to nominal frequency during reboot/kexec
      cpufreq: powernv: Set the pstate of the last hotplugged out cpu in policy->cpus to minimum
      cpufreq: Allow stop CPU callback to be used by all cpufreq drivers
      PM / devfreq: exynos: Enable building exynos PPMU as module
      PM / devfreq: Export helper functions for drivers
      ...

commit 28c399e2a1ed03bd175858deef1e233317103089
Merge: 0ede470030a3 a8d46b9e4e48
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Oct 7 01:17:50 2014 +0200

    Merge branch 'acpi-pm'
    
    * acpi-pm:
      ACPI / sleep: Rework the handling of ACPI GPE wakeup from suspend-to-idle
      PM / sleep: Rename platform suspend/resume functions in suspend.c
      PM / sleep: Export dpm_suspend_late/noirq() and dpm_resume_early/noirq()

commit 20b3d5386751e331aa0ab0b4e474b1062ecb75df
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Mon Aug 18 11:57:28 2014 -0400

    drm/radeon: fix pm handling in radeon_gpu_reset
    
    commit c940b4476f4fb649f6493b6a0ae837474ded8915 upstream.
    
    pm_suspend is handled in the radeon_suspend callbacks.
    pm_resume has special handling depending on whether
    dpm or legacy pm is enabled.  Change radeon_gpu_reset
    to mirror the behavior in the suspend and resume
    pathes.
    
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Reviewed-by: Christian Knig <christian.koenig@amd.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 05396d20dc953fb4ed295693afb2095963b1c4c4
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Mon Aug 18 11:57:28 2014 -0400

    drm/radeon: fix pm handling in radeon_gpu_reset
    
    commit c940b4476f4fb649f6493b6a0ae837474ded8915 upstream.
    
    pm_suspend is handled in the radeon_suspend callbacks.
    pm_resume has special handling depending on whether
    dpm or legacy pm is enabled.  Change radeon_gpu_reset
    to mirror the behavior in the suspend and resume
    pathes.
    
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Reviewed-by: Christian Knig <christian.koenig@amd.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 2a8a8ce651d3a88fdf83e2ed15633c8d19292108
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Sep 30 02:21:34 2014 +0200

    PM / sleep: Export dpm_suspend_late/noirq() and dpm_resume_early/noirq()
    
    Subsequent change sets will add platform-related operations between
    dpm_suspend_late() and dpm_suspend_noirq() as well as between
    dpm_resume_noirq() and dpm_resume_early() in suspend_enter(), so
    export these functions for suspend_enter() to be able to call them
    separately and split the invocations of dpm_suspend_end() and
    dpm_resume_start() in there accordingly.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 221414db1934c1c883501998f510bb75acfbaa51
Author: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
Date:   Thu Aug 7 18:07:07 2014 +0200

    mmc: sdhci-s3c: fix runtime PM handling on sdhci_add_host() failure
    
    Runtime Power Management handling for the sdhci_add_host() failure
    case in sdhci_s3c_probe() should match the code in sdhci_s3c_remove()
    (which uses pm_runtime_disable() call which matches the earlier
    pm_runtime_enable() one).  Fix it.
    
    This patch fixes "BUG: spinlock bad magic on CPU#0, swapper/0/1" and
    "Unbalanced pm_runtime_enable!" warnings.
    
    >From the kernel log:
    ...
    [    1.659631] s3c-sdhci 12530000.sdhci: sdhci_add_host() failed
    [    1.665096] BUG: spinlock bad magic on CPU#0, swapper/0/1
    [    1.670433]  lock: 0xea01e484, .magic: 00000000, .owner: <none>/-1, .owner_cpu: 0
    [    1.677895] CPU: 0 PID: 1 Comm: swapper/0 Not tainted 3.16.0-next-20140804-00008-ga59480f-dirty #707
    [    1.687037] [<c0013ae4>] (unwind_backtrace) from [<c0010d70>] (show_stack+0x10/0x14)
    [    1.694740] [<c0010d70>] (show_stack) from [<c04050c8>] (dump_stack+0x68/0xb8)
    [    1.701948] [<c04050c8>] (dump_stack) from [<c0052558>] (do_raw_spin_lock+0x15c/0x1a4)
    [    1.709848] [<c0052558>] (do_raw_spin_lock) from [<c040a630>] (_raw_spin_lock_irqsave+0x20/0x28)
    [    1.718619] [<c040a630>] (_raw_spin_lock_irqsave) from [<c030d7d0>] (sdhci_do_set_ios+0x1c/0x5cc)
    [    1.727464] [<c030d7d0>] (sdhci_do_set_ios) from [<c030ddfc>] (sdhci_runtime_resume_host+0x50/0x104)
    [    1.736574] [<c030ddfc>] (sdhci_runtime_resume_host) from [<c02462dc>] (pm_generic_runtime_resume+0x2c/0x40)
    [    1.746383] [<c02462dc>] (pm_generic_runtime_resume) from [<c0247898>] (__rpm_callback+0x34/0x70)
    [    1.755233] [<c0247898>] (__rpm_callback) from [<c02478fc>] (rpm_callback+0x28/0x88)
    [    1.762958] [<c02478fc>] (rpm_callback) from [<c02486f0>] (rpm_resume+0x384/0x4ec)
    [    1.770511] [<c02486f0>] (rpm_resume) from [<c02488b0>] (pm_runtime_forbid+0x58/0x64)
    [    1.778325] [<c02488b0>] (pm_runtime_forbid) from [<c030ea70>] (sdhci_s3c_probe+0x4a4/0x540)
    [    1.786749] [<c030ea70>] (sdhci_s3c_probe) from [<c02429cc>] (platform_drv_probe+0x2c/0x5c)
    [    1.795076] [<c02429cc>] (platform_drv_probe) from [<c02415f0>] (driver_probe_device+0x114/0x234)
    [    1.803929] [<c02415f0>] (driver_probe_device) from [<c024179c>] (__driver_attach+0x8c/0x90)
    [    1.812347] [<c024179c>] (__driver_attach) from [<c023ffb4>] (bus_for_each_dev+0x54/0x88)
    [    1.820506] [<c023ffb4>] (bus_for_each_dev) from [<c0240df8>] (bus_add_driver+0xd8/0x1cc)
    [    1.828665] [<c0240df8>] (bus_add_driver) from [<c0241db8>] (driver_register+0x78/0xf4)
    [    1.836652] [<c0241db8>] (driver_register) from [<c00088a4>] (do_one_initcall+0x80/0x1d0)
    [    1.844816] [<c00088a4>] (do_one_initcall) from [<c059ac94>] (kernel_init_freeable+0x108/0x1d4)
    [    1.853503] [<c059ac94>] (kernel_init_freeable) from [<c0401300>] (kernel_init+0x8/0xe4)
    [    1.861568] [<c0401300>] (kernel_init) from [<c000e538>] (ret_from_fork+0x14/0x3c)
    [    1.869582] platform 12530000.sdhci: Driver s3c-sdhci requests probe deferral
    ...
    [    1.997047] s3c-sdhci 12530000.sdhci: Unbalanced pm_runtime_enable!
    ...
    [    2.027235] s3c-sdhci 12530000.sdhci: sdhci_add_host() failed
    [    2.032884] platform 12530000.sdhci: Driver s3c-sdhci requests probe deferral
    ...
    
    Tested on Hardkernel's Exynos4412 based ODROID-U3 board.
    
    Fixes: 9f4e8151dbbc ("mmc: sdhci-s3c: Enable runtime power management")
    Cc: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Cc: Jaehoon Chung <jh80.chung@samsung.com>
    Cc: Ben Dooks <ben-linux@fluff.org>
    Signed-off-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Acked-by: Kyungmin Park <kyungmin.park@samsung.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

commit c940b4476f4fb649f6493b6a0ae837474ded8915
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Mon Aug 18 11:57:28 2014 -0400

    drm/radeon: fix pm handling in radeon_gpu_reset
    
    pm_suspend is handled in the radeon_suspend callbacks.
    pm_resume has special handling depending on whether
    dpm or legacy pm is enabled.  Change radeon_gpu_reset
    to mirror the behavior in the suspend and resume
    pathes.
    
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Reviewed-by: Christian Knig <christian.koenig@amd.com>
    Cc: stable@vger.kernel.org

commit 150cee9cfd749b1a9f4e995d63761891d46c56de
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sat Jul 12 11:01:38 2014 +0100

    drm: bochs: fix warnings
    
    Regular nightly randconfig build testing discovered these warnings:
    
    drivers/gpu/drm/bochs/bochs_drv.c:100:12: warning: 'bochs_pm_suspend' defined but not used [-Wunused-function]
    drivers/gpu/drm/bochs/bochs_drv.c:117:12: warning: 'bochs_pm_resume' defined but not used [-Wunused-function]
    
    Fix these by adding the same condition that SET_SYSTEM_SLEEP_PM_OPS()
    uses.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

commit 8f8e7e14637a07d8bde6e4b0dc385b72d1a674fb
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sat Jul 12 11:01:43 2014 +0100

    drm: cirrus: fix warnings
    
    Regular nightly randconfig build testing discovered these warnings:
    
    drivers/gpu/drm/cirrus/cirrus_drv.c:79:12: warning: 'cirrus_pm_suspend' defined but not used [-Wunused-function]
    drivers/gpu/drm/cirrus/cirrus_drv.c:96:12: warning: 'cirrus_pm_resume' defined but not used [-Wunused-function]
    
    Fix these by adding the same condition that SET_SYSTEM_SLEEP_PM_OPS()
    uses.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

commit e7213f98d8789279f2dbc3fbf63d0d5d820390bd
Author: Shawn Guo <shawn.guo@freescale.com>
Date:   Wed May 28 23:05:39 2014 +0800

    ahci: imx: manage only sata_ref_clk in imx_sata_enable[disable]
    
    commit e6dd42a917e62d916c6e513dbf87a4dec8cf3a1c upstream.
    
    Doing suspend/resume on imx6q and imx53 boards with no SATA disk
    attached will trigger the following warning.
    
    ------------[ cut here ]------------
    WARNING: CPU: 0 PID: 661 at drivers/ata/libahci.c:224 ahci_enable_ahci+0x74/0x8)
    Modules linked in:
    CPU: 0 PID: 661 Comm: sh Tainted: G        W     3.15.0-rc5-next-20140521-000027
    Backtrace:
    [<80011c90>] (dump_backtrace) from [<80011e2c>] (show_stack+0x18/0x1c)
     r6:803a22f4 r5:00000000 r4:00000000 r3:00000000
    [<80011e14>] (show_stack) from [<80661e60>] (dump_stack+0x88/0xa4)
    [<80661dd8>] (dump_stack) from [<80028fdc>] (warn_slowpath_common+0x70/0x94)
     r5:00000009 r4:00000000
    [<80028f6c>] (warn_slowpath_common) from [<80029024>] (warn_slowpath_null+0x24/)
     r8:808f68c4 r7:00000000 r6:00000000 r5:00000000 r4:e0810004
    [<80029000>] (warn_slowpath_null) from [<803a22f4>] (ahci_enable_ahci+0x74/0x80)
    [<803a2280>] (ahci_enable_ahci) from [<803a2324>] (ahci_reset_controller+0x24/0)
     r8:ddcd9410 r7:80351178 r6:ddcd9444 r5:dde8b850 r4:e0810000 r3:ddf35e90
    [<803a2300>] (ahci_reset_controller) from [<803a2c68>] (ahci_platform_resume_ho)
     r7:80351178 r6:ddcd9444 r5:dde8b850 r4:ddcd9410
    [<803a2c30>] (ahci_platform_resume_host) from [<803a38f0>] (imx_ahci_resume+0x2)
     r5:00000000 r4:ddcd9410
    [<803a38c4>] (imx_ahci_resume) from [<803511ac>] (platform_pm_resume+0x34/0x54)
    ....
    
    The reason is that the SATA controller has no working clock at this
    point, and thus ahci_enable_ahci() fails to enable the controller.  In
    case that there is no SATA disk attached, the imx_sata_disable() gets
    called in ahci_imx_error_handler(), and both sata_clk and sata_ref_clk
    will be disabled there.  Because all the imx_sata_enable() calls
    afterward will return immediately due to imxpriv->no_device check, the
    SATA controller working clock sata_clk will never get any chance to be
    enabled again.
    
    This is a regression caused by commit 90870d79d4f2 (ahci-imx: Port to
    library-ised ahci_platform).  Before the commit, only sata_ref_clk is
    managed by the driver in enable/disable function.  But after the commit,
    all the clocks are enabled/disabled in a row by ahci platform helpers
    ahci_platform_enable[disable]_clks.  Since ahb_clk is a bus clock which
    does not have gate at all, and i.MX low-power hardware module already
    manages sata_clk across suspend/resume cycle, the only clock that needs
    to be managed by software is sata_ref_clk.
    
    So instead of using ahci_platform_enable[disable]_clks to manage all
    the clocks in a row from imx_sata_enable[disable], we should manage
    only sata_ref_clk in there.
    
    Reported-by: Fabio Estevam <fabio.estevam@freescale.com>
    Fixes: 90870d79d4f2 (ahci-imx: Port to library-ised ahci_platform)
    Signed-off-by: Shawn Guo <shawn.guo@freescale.com>
    Acked-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit e6dd42a917e62d916c6e513dbf87a4dec8cf3a1c
Author: Shawn Guo <shawn.guo@freescale.com>
Date:   Wed May 28 23:05:39 2014 +0800

    ahci: imx: manage only sata_ref_clk in imx_sata_enable[disable]
    
    Doing suspend/resume on imx6q and imx53 boards with no SATA disk
    attached will trigger the following warning.
    
    ------------[ cut here ]------------
    WARNING: CPU: 0 PID: 661 at drivers/ata/libahci.c:224 ahci_enable_ahci+0x74/0x8)
    Modules linked in:
    CPU: 0 PID: 661 Comm: sh Tainted: G        W     3.15.0-rc5-next-20140521-000027
    Backtrace:
    [<80011c90>] (dump_backtrace) from [<80011e2c>] (show_stack+0x18/0x1c)
     r6:803a22f4 r5:00000000 r4:00000000 r3:00000000
    [<80011e14>] (show_stack) from [<80661e60>] (dump_stack+0x88/0xa4)
    [<80661dd8>] (dump_stack) from [<80028fdc>] (warn_slowpath_common+0x70/0x94)
     r5:00000009 r4:00000000
    [<80028f6c>] (warn_slowpath_common) from [<80029024>] (warn_slowpath_null+0x24/)
     r8:808f68c4 r7:00000000 r6:00000000 r5:00000000 r4:e0810004
    [<80029000>] (warn_slowpath_null) from [<803a22f4>] (ahci_enable_ahci+0x74/0x80)
    [<803a2280>] (ahci_enable_ahci) from [<803a2324>] (ahci_reset_controller+0x24/0)
     r8:ddcd9410 r7:80351178 r6:ddcd9444 r5:dde8b850 r4:e0810000 r3:ddf35e90
    [<803a2300>] (ahci_reset_controller) from [<803a2c68>] (ahci_platform_resume_ho)
     r7:80351178 r6:ddcd9444 r5:dde8b850 r4:ddcd9410
    [<803a2c30>] (ahci_platform_resume_host) from [<803a38f0>] (imx_ahci_resume+0x2)
     r5:00000000 r4:ddcd9410
    [<803a38c4>] (imx_ahci_resume) from [<803511ac>] (platform_pm_resume+0x34/0x54)
    ....
    
    The reason is that the SATA controller has no working clock at this
    point, and thus ahci_enable_ahci() fails to enable the controller.  In
    case that there is no SATA disk attached, the imx_sata_disable() gets
    called in ahci_imx_error_handler(), and both sata_clk and sata_ref_clk
    will be disabled there.  Because all the imx_sata_enable() calls
    afterward will return immediately due to imxpriv->no_device check, the
    SATA controller working clock sata_clk will never get any chance to be
    enabled again.
    
    This is a regression caused by commit 90870d79d4f2 (ahci-imx: Port to
    library-ised ahci_platform).  Before the commit, only sata_ref_clk is
    managed by the driver in enable/disable function.  But after the commit,
    all the clocks are enabled/disabled in a row by ahci platform helpers
    ahci_platform_enable[disable]_clks.  Since ahb_clk is a bus clock which
    does not have gate at all, and i.MX low-power hardware module already
    manages sata_clk across suspend/resume cycle, the only clock that needs
    to be managed by software is sata_ref_clk.
    
    So instead of using ahci_platform_enable[disable]_clks to manage all
    the clocks in a row from imx_sata_enable[disable], we should manage
    only sata_ref_clk in there.
    
    Reported-by: Fabio Estevam <fabio.estevam@freescale.com>
    Fixes: 90870d79d4f2 (ahci-imx: Port to library-ised ahci_platform)
    Signed-off-by: Shawn Guo <shawn.guo@freescale.com>
    Acked-by: Hans de Goede <hdegoede@redhat.com>

commit 7027df36e41836b11f01b0d30eee40c55df7d013
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue May 20 18:09:36 2014 -0700

    usb: resume child device when port is powered on
    
    Unconditionally wake up the child device when the power session is
    recovered.
    
    This addresses the following scenarios:
    
    1/ The device may need a reset on power-session loss, without this
       change port power-on recovery exposes khubd to scenarios that
       usb_port_resume() is set to handle.  Prior to port power control the
       only time a power session would be lost is during dpm_suspend of the
       hub.  In that scenario usb_port_resume() is guaranteed to be called
       prior to khubd running for that port.  With this change we wakeup the
       child device as soon as possible (prior to khubd running again for this
       port).
    
       Although khubd has facilities to wake a child device it will only do
       so if the portstatus / portchange indicates a suspend state.  In the
       case of port power control we are not coming from a hub-port-suspend
       state.  This implementation simply uses pm_request_resume() to wake the
       device and relies on the port_dev->status_lock to prevent any collisions
       between khubd and usb_port_resume().
    
    2/ This mechanism rate limits port power toggling.  The minimum port
       power on/off period is now gated by the child device suspend/resume
       latency.  Empirically this mitigates devices downgrading their connection
       on perceived instability of the host connection.  This ratelimiting is
       really only relevant to port power control testing, but it is a nice
       side effect of closing the above race.  Namely, the race of khubd for
       the given port running while a usb_port_resume() event is pending.
    
    3/ Going forward we are finding that power-session recovery requires
       warm-resets (http://marc.info/?t=138659232900003&r=1&w=2).  This
       mechanism allows for warm-resets to be requested at the same point in
       the resume path for hub dpm_suspend power session losses, or port
       rpm_suspend power session losses.
    
    4/ If the device *was* disconnected the only time we'll know for sure is
       after a failed resume, so it's necessary for usb_port_runtime_resume()
       to expedite a usb_port_resume() to clean up the removed device.  The
       reasoning for this is "least surprise" for the user. Turning on a port
       means that hotplug detection is again enabled for the port, it is
       surprising that devices that were removed while the port was off are not
       disconnected until they are attempted to be used.  As a user "why would
       I try to use a device I removed from the system?"
    
    1, 2, and 4 are not a problem in the system dpm_resume() case because,
    although the power-session is lost, khubd is frozen until after device
    resume.  For the rpm_resume() case pm_request_resume() is used to
    request re-validation of the device, and if it happens to collide with a
    khubd run we rely on the port_dev->status_lock to synchronize those
    operations.
    
    Besides testing, the primary scenario where this mechanism is expected
    to be triggered is when the user changes the port power policy
    (control/pm_qos_no_poweroff, or power/control).   Each time power is
    enabled want to revalidate the child device, where the revalidation is
    handled by usb_port_resume().
    
    Given that this arranges for port_dev->child to be de-referenced in
    usb_port_runtime_resume() we need to make sure not to collide with
    usb_disconnect() that frees the usb_device.  To this end we hold the
    port active with the "child_usage" reference across the disconnect
    event.  Subsequently, the need to access hub->child_usage_bits lead to
    the creation of hub_disconnect_children() to remove any ambiguity of
    which "hub" is being acted on in usb_disconnect() (prompted-by sharp
    eyes from Alan).
    
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit f3f125324fc1b8500cd20a2907628f7e5d88a708
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Apr 20 23:43:01 2014 +0200

    PM / suspend: Make cpuidle work in the "freeze" state
    
    The "freeze" system sleep state introduced by commit 7e73c5ae6e79
    (PM: Introduce suspend state PM_SUSPEND_FREEZE) requires cpuidle
    to be functional when freeze_enter() is executed to work correctly
    (that is, to be able to save any more energy than runtime idle),
    but that is impossible after commit 8651f97bd951d (PM / cpuidle:
    System resume hang fix with cpuidle) which caused cpuidle to be
    paused in dpm_suspend_noirq() and resumed in dpm_resume_noirq().
    
    To avoid that problem, add cpuidle_resume() and cpuidle_pause()
    to the beginning and the end of freeze_enter(), respectively.
    
    Reported-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Preeti U Murthy <preeti@linux.vnet.ibm.com>

commit f45e5f00dacf09362a16339d372fcc96705e40c7
Author: Roger Quadros <rogerq@ti.com>
Date:   Wed Mar 26 11:43:09 2014 +0200

    usb: dwc3: core: Fix gadget for system suspend/resume
    
    During system resume, if the event buffers are not setup before
    the gadget controller starts then we start with invalid context
    and this can lead to bus access errors. This is especially true for
    platforms that loose the controller context during system suspend.
    e.g. AM437x.
    
    The following backtrace was found when the system is suspended
    and resumed with g_zero loaded on AM437x-evm (USB cable connected
    to host all the while).
    
    [  120.981506] WARNING: CPU: 0 PID: 1656 at drivers/bus/omap_l3_noc.c:137 l3_interrupt_handler+0x198/0x28c()
    [  120.981514] L3 custom error: MASTER:USB0 WR TARGET:GPMC
    [  120.981638] Modules linked in: g_mass_storage usb_f_mass_storage libcomposite configfs bufferclass_ti(O) omaplfb(O) cryptodev(O) dwc3 snd_soc_evm snd_soc_omap snd_pe
    [  120.981659] CPU: 0 PID: 1656 Comm: sh Tainted: G           O 3.12.10-gc559824 #1
    [  120.981669] Backtrace:
    [  120.981705] [<c0017880>] (dump_backtrace+0x0/0x10c) from [<c0017a1c>] (show_stack+0x18/0x1c)
    [  120.981730]  r6:c02819ac r5:00000009 r4:ec137cb8 r3:00000000
    [  120.981767] [<c0017a04>] (show_stack+0x0/0x1c) from [<c056c0b0>] (dump_stack+0x20/0x28)
    [  120.981802] [<c056c090>] (dump_stack+0x0/0x28) from [<c0046d08>] (warn_slowpath_common+0x70/0x90)
    [  120.981830] [<c0046c98>] (warn_slowpath_common+0x0/0x90) from [<c0046dcc>] (warn_slowpath_fmt+0x38/0x40)
    [  120.981856]  r8:c0855eb0 r7:00000002 r6:f1000700 r5:00000007 r4:80080003
    [  120.981886] [<c0046d94>] (warn_slowpath_fmt+0x0/0x40) from [<c02819ac>] (l3_interrupt_handler+0x198/0x28c)
    [  120.981900]  r3:c0801ab8 r2:c06cb354
    [  120.981936] [<c0281814>] (l3_interrupt_handler+0x0/0x28c) from [<c007162c>] (handle_irq_event_percpu+0x54/0x1b8)
    [  120.981962] [<c00715d8>] (handle_irq_event_percpu+0x0/0x1b8) from [<c00717c0>] (handle_irq_event+0x30/0x40)
    [  120.981993] [<c0071790>] (handle_irq_event+0x0/0x40) from [<c0074058>] (handle_fasteoi_irq+0x74/0x128)
    [  120.982006]  r4:ed0056c0 r3:00000000
    [  120.982033] [<c0073fe4>] (handle_fasteoi_irq+0x0/0x128) from [<c0070f34>] (generic_handle_irq+0x28/0x38)
    [  120.982046]  r4:0000002a r3:c0073fe4
    [  120.982085] [<c0070f0c>] (generic_handle_irq+0x0/0x38) from [<c0015560>] (handle_IRQ+0x38/0x8c)
    [  120.982098]  r4:c080137c r3:00000182
    [  120.982124] [<c0015528>] (handle_IRQ+0x0/0x8c) from [<c00087e0>] (gic_handle_irq+0x30/0x5c)
    [  120.982145]  r6:ec137dd0 r5:c07ac480 r4:fa24010c r3:00000100
    [  120.982169] [<c00087b0>] (gic_handle_irq+0x0/0x5c) from [<c056fcc0>] (__irq_svc+0x40/0x54)
    [  120.982179] Exception stack(0xec137dd0 to 0xec137e18)
    [  120.982195] 7dc0:                                     00000000 a00001d3 00000000 00000004
    [  120.982216] 7de0: a0000153 ec1d9010 c080de90 ec137e30 c080debc 00000000 ed756e44 ec137e2c
    [  120.982232] 7e00: ec137de0 ec137e18 bf1150e4 bf115474 60000153 ffffffff
    [  120.982253]  r7:ec137e04 r6:ffffffff r5:60000153 r4:bf115474
    [  120.982327] [<bf115438>] (dwc3_complete+0x0/0x40 [dwc3]) from [<c0338f50>] (dpm_complete+0xd4/0x19c)
    [  120.982341]  r5:ed756e10 r4:ed756e64
    [  120.982370] [<c0338e7c>] (dpm_complete+0x0/0x19c) from [<c0339034>] (dpm_resume_end+0x1c/0x20)
    [  120.982400] [<c0339018>] (dpm_resume_end+0x0/0x20) from [<c006d4ec>] (suspend_devices_and_enter+0x118/0x33c)
    [  120.982412]  r4:c0833da4 r3:00000000
    [  120.982436] [<c006d3d4>] (suspend_devices_and_enter+0x0/0x33c) from [<c006d928>] (pm_suspend+0x218/0x254)
    [  120.982458] [<c006d710>] (pm_suspend+0x0/0x254) from [<c006c594>] (state_store+0x70/0xc0)
    [  120.982478]  r6:c057a6cc r5:c06a8320 r4:00000003 r3:0000006d
    [  120.982515] [<c006c524>] (state_store+0x0/0xc0) from [<c0264cc0>] (kobj_attr_store+0x1c/0x28)
    [  120.982546] [<c0264ca4>] (kobj_attr_store+0x0/0x28) from [<c012ccb8>] (sysfs_write_file+0x170/0x1a4)
    [  120.982583] [<c012cb48>] (sysfs_write_file+0x0/0x1a4) from [<c00d17e4>] (vfs_write+0xb8/0x190)
    [  120.982611] [<c00d172c>] (vfs_write+0x0/0x190) from [<c00d1bf8>] (SyS_write+0x44/0x78)
    [  120.982641] [<c00d1bb4>] (SyS_write+0x0/0x78) from [<c0014660>] (ret_fast_syscall+0x0/0x30)
    
    Signed-off-by: Roger Quadros <rogerq@ti.com>
    Acked-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

commit 3c31b52f96f7b559d950b16113c0f68c72a1985e
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Apr 10 15:30:35 2014 -0700

    scsi: async sd resume
    
    async_schedule() sd resume work to allow disks and other devices to
    resume in parallel.
    
    This moves the entirety of scsi_device resume to an async context to
    ensure that scsi_device_resume() remains ordered with respect to the
    completion of the start/stop command.  For the duration of the resume,
    new command submissions (that do not originate from the scsi-core) will
    be deferred (BLKPREP_DEFER).
    
    It adds a new ASYNC_DOMAIN_EXCLUSIVE(scsi_sd_pm_domain) as a container
    of these operations.  Like scsi_sd_probe_domain it is flushed at
    sd_remove() time to ensure async ops do not continue past the
    end-of-life of the sdev.  The implementation explicitly refrains from
    reusing scsi_sd_probe_domain directly for this purpose as it is flushed
    at the end of dpm_resume(), potentially defeating some of the benefit.
    Given sdevs are quiesced it is permissible for these resume operations
    to bleed past the async_synchronize_full() calls made by the driver
    core.
    
    We defer the resolution of which pm callback to call until
    scsi_dev_type_{suspend|resume} time and guarantee that the callback
    parameter is never NULL.  With this in place the type of resume
    operation is encoded in the async function identifier.
    
    There is a concern that async resume could trigger PSU overload.  In the
    enterprise, storage enclosures enforce staggered spin-up regardless of
    what the kernel does making async scanning safe by default.  Outside of
    that context a user can disable asynchronous scanning via a kernel
    command line or CONFIG_SCSI_SCAN_ASYNC.  Honor that setting when
    deciding whether to do resume asynchronously.
    
    Inspired by Todd's analysis and initial proposal [2]:
    https://01.org/suspendresume/blogs/tebrandt/2013/hard-disk-resume-optimization-simpler-approach
    
    Cc: Len Brown <len.brown@intel.com>
    Cc: Phillip Susi <psusi@ubuntu.com>
    [alan: bug fix and clean up suggestion]
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Suggested-by: Todd Brandt <todd.e.brandt@linux.intel.com>
    [djbw: kick all resume work to the async queue]
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

commit 3916b09eed268705f738957aba6fd380470e994a
Author: Xianglong Du <Xianglong.Du@csr.com>
Date:   Thu Apr 3 14:49:53 2014 -0700

    drivers/rtc/rtc-sirfsoc.c: fix kernel panic of backing from hibernation
    
    RTC settings will be lost if power supply is cut off after hibernation
    finished, but the current "restore" function does not restore RTC related
    settings, this causes rtc_read_time failure and kernel panic:
    
      rtc rtc0: **** DPM device timeout ****
      Stack trace:
        unwind_backtrace+0x0/0xf4
        show_stack+0x10/0x14
        dpm_wd_handler+0x24/0x28
        call_timer_fn.isra.33+0x24/0x88
        run_timer_softirq+0x178/0x1f0
        __do_softirq+0x120/0x200
        do_softirq+0x54/0x5c
        irq_exit+0x9c/0xd0
        handle_IRQ+0x44/0x90
        __irq_svc+0x40/0x70
        _raw_spin_unlock_irqrestore+0x10/0x48
        sirfsoc_rtc_iobrg_readl+0x34/0x3c
        sirfsoc_rtc_read_time+0x24/0x48
        __rtc_read_time.isra.3+0x48/0x5c
        rtc_read_time+0x30/0x44
        rtc_resume.part.9+0x20/0x104
        rtc_resume+0x5c/0x64
        dpm_run_callback.isra.4+0x2c/0x74
        device_resume+0x9c/0x144
        dpm_resume+0x100/0x224
        hibernation_snapshot+0x170/0x398
        hibernate+0x13c/0x1d8
        state_store+0xb4/0xb8
        kobj_attr_store+0x14/0x20
        sysfs_write_file+0x160/0x190
        vfs_write+0xb4/0x194
        SyS_write+0x3c/0x78
    
    this patch uses SIMPLE_DEV_PM_OPS() to make restore() execute the
    existing resume() function which will restore the set of RTC.
    
    Signed-off-by: Xianglong Du <Xianglong.Du@csr.com>
    Signed-off-by: Barry Song <Baohua.Song@csr.com>
    Cc: Grant Likely <grant.likely@linaro.org>
    Cc: Rob Herring <robh+dt@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit 72f72dcc146fd7c4f9a8544626b961d52f1399b3
Author: Kevin Hao <haokexin@gmail.com>
Date:   Tue Mar 18 00:26:49 2014 -0700

    e1000e: fix the build error when PM is disabled
    
    The commit 2800209994f8 (e1000e: Refactor PM flows) changed the
    SET_SYSTEM_SLEEP_PM_OPS to open-coded assignment, but forgot to
    protect them with CONFIG_PM_SLEEP. Then cause the following build
    error when PM is disabled:
    drivers/net/ethernet/intel/e1000e/netdev.c:7079:13:
    error: 'e1000e_pm_suspend' undeclared here (not in a function)
      .suspend = e1000e_pm_suspend,
                 ^
    drivers/net/ethernet/intel/e1000e/netdev.c:7080:13:
    error: 'e1000e_pm_resume' undeclared here (not in a function)
      .resume  = e1000e_pm_resume,
                 ^
    drivers/net/ethernet/intel/e1000e/netdev.c:7082:11:
    error: 'e1000e_pm_thaw' undeclared here (not in a function)
      .thaw  = e1000e_pm_thaw,
               ^
    Signed-off-by: Kevin Hao <haokexin@gmail.com>
    Tested-by: Aaron Brown <aaron.f.brown@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 5f59df79837bb809f3945613aba5519cd9755a53
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Sat Mar 1 11:56:04 2014 +0100

    PM / runtime: Fetch runtime PM callbacks using a macro
    
    While fetching the proper runtime PM callback, we walk the hierarchy of
    device's power domains, subsystems and drivers.
    
    This is common for rpm_suspend(), rpm_idle() and rpm_resume(). Let's
    clean up the code by using a macro that handles this.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit f0ceb114aec78cc585b8e7cb3d536f8a3e386bf1
Author: Axel Lin <axel.lin@ingics.com>
Date:   Sun Feb 23 13:27:16 2014 +0800

    spi: qup: Fix build error due to a typo
    
    Fix below build error when CONFIG_PM_RUNTIME=y:
    
    C [M]  drivers/spi/spi-qup.o
    drivers/spi/spi-qup.c: In function 'spi_qup_pm_suspend_runtime':
    drivers/spi/spi-qup.c:712:12: error: 'QUP_CLOCK_AUTO_GATE' undeclared (first use in this function)
    drivers/spi/spi-qup.c:712:12: note: each undeclared identifier is reported only once for each function it appears in
    drivers/spi/spi-qup.c: In function 'spi_qup_pm_resume_runtime':
    drivers/spi/spi-qup.c:725:13: error: 'QUP_CLOCK_AUTO_GATE' undeclared (first use in this function)
    make[2]: *** [drivers/spi/spi-qup.o] Error 1
    make[1]: *** [drivers/spi] Error 2
    make: *** [drivers] Error 2
    
    Signed-off-by: Axel Lin <axel.lin@ingics.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

commit 76569faa62c46382e080c3e190c66e19515aae1c
Author: Liu, Chuansheng <chuansheng.liu@intel.com>
Date:   Tue Feb 18 10:28:45 2014 +0800

    PM / sleep: Asynchronous threads for resume_noirq
    
    In analogy with commits 5af84b82701a and 97df8c12995, using
    asynchronous threads can improve the overall resume_noirq time
    significantly.
    
    One typical case is:
    In resume_noirq phase and for the PCI devices, the function
    pci_pm_resume_noirq() will be called, and there is one d3_delay
    (10ms) at least.
    
    With the way of asynchronous threads, we just need wait d3_delay
    time once in parallel for each calling, which saves much time to
    resume quickly.
    
    Signed-off-by: Chuansheng Liu <chuansheng.liu@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 30a70b026b4cde4e51989661ff3bd0ede08d9646
Author: Felipe Balbi <balbi@ti.com>
Date:   Thu Feb 6 21:25:37 2014 +0200

    usb: musb: fix obex in g_nokia.ko causing kernel panic
    
    phy_power_off() can, depending on the PHY being used,
    start I2C transactions which shouldn't happen in
    atomic context.
    
    Current call to phy_power_off() inside omap2430_runtime
    callbacks causes the following dump, as a fix, just don't
    power off the PHY in runtime.
    
    [   18.606414] [<c037eac0>] (__schedule+0x5c/0x50c) from [<c037d3bc>] (schedule_timeout+0x1f4/0x25c)
    [   18.623809] [<c037d3bc>] (schedule_timeout+0x1f4/0x25c) from [<c037f12c>] (wait_for_common+0xc8/0x1ac)
    [   18.649291] [<c037f12c>] (wait_for_common+0xc8/0x1ac) from [<c028c1c0>] (omap_i2c_xfer+0x338/0x488)
    [   18.674499] [<c028c1c0>] (omap_i2c_xfer+0x338/0x488) from [<c0288144>] (__i2c_transfer+0x40/0x74)
    [   18.692047] [<c0288144>] (__i2c_transfer+0x40/0x74) from [<c0288a2c>] (i2c_transfer+0x6c/0x90)
    [   18.709320] [<c0288a2c>] (i2c_transfer+0x6c/0x90) from [<c02351c8>] (regmap_i2c_read+0x48/0x68)
    [   18.726715] [<c02351c8>] (regmap_i2c_read+0x48/0x68) from [<c023161c>] (_regmap_raw_read+0x128/0x220)
    [   18.752685] [<c023161c>] (_regmap_raw_read+0x128/0x220) from [<c02317b4>] (regmap_raw_read+0xa0/0x130)
    [   18.779052] [<c02317b4>] (regmap_raw_read+0xa0/0x130) from [<c023193c>] (regmap_bulk_read+0xf8/0x16c)
    [   18.805694] [<c023193c>] (regmap_bulk_read+0xf8/0x16c) from [<c0238ea8>] (twl_i2c_read+0xa4/0xe0)
    [   18.823730] [<c0238ea8>] (twl_i2c_read+0xa4/0xe0) from [<c0274d34>] (__twl4030_phy_power.isra.12+0x1c/0x58)
    [   18.850921] [<c0274d34>] (__twl4030_phy_power.isra.12+0x1c/0x58) from [<c0274df0>]
    (twl4030_phy_power.part.14+0x80/0xc8)
    [   18.879699] [<c0274df0>] (twl4030_phy_power.part.14+0x80/0xc8) from [<c0274f9c>]
    (twl4030_set_suspend+0x54/0x1e8)
    [   18.908325] [<c0274f9c>] (twl4030_set_suspend+0x54/0x1e8) from [<c027c8c4>]
    (omap2430_runtime_resume+0x5c/0x64)
    [   18.937042] [<c027c8c4>] (omap2430_runtime_resume+0x5c/0x64) from [<c0225dd0>]
    (pm_generic_runtime_resume+0x2c/0x38)
    [   18.966461] [<c0225dd0>] (pm_generic_runtime_resume+0x2c/0x38) from [<c0229fe0>] (__rpm_callback+0x54/0x80)
    [   18.995117] [<c0229fe0>] (__rpm_callback+0x54/0x80) from [<c022a04c>] (rpm_callback+0x40/0x74)
    [   19.013610] [<c022a04c>] (rpm_callback+0x40/0x74) from [<c022b3c8>] (rpm_resume+0x448/0x63c)
    [   19.031921] [<c022b3c8>] (rpm_resume+0x448/0x63c) from [<c022b2e4>] (rpm_resume+0x364/0x63c)
    [   19.050140] [<c022b2e4>] (rpm_resume+0x364/0x63c) from [<c022b874>] (__pm_runtime_resume+0x48/0x74)
    [   19.077728] [<c022b874>] (__pm_runtime_resume+0x48/0x74) from [<c027b4fc>] (musb_gadget_pullup+0x1c/0xb4)
    [   19.105895] [<c027b4fc>] (musb_gadget_pullup+0x1c/0xb4) from [<bf025c14>] (usb_function_deactivate+0x54/0xa4
    [libcomposite])
    [   19.135955] [<bf025c14>] (usb_function_deactivate+0x54/0xa4 [libcomposite]) from [<bf05b3b8>]
    (obex_bind+0x124/0x1d8 [usb_f_obex])
    [   19.166870] [<bf05b3b8>] (obex_bind+0x124/0x1d8 [usb_f_obex]) from [<bf025794>] (usb_add_function+0x58/0xf4
    [libcomposite])
    [   19.197143] [<bf025794>] (usb_add_function+0x58/0xf4 [libcomposite]) from [<bf037420>]
    (nokia_bind_config+0x204/0x250 [g_nokia])
    [   19.227905] [<bf037420>] (nokia_bind_config+0x204/0x250 [g_nokia]) from [<bf0263fc>] (usb_add_config+0x28/0xc0
    [libcomposite])
    [   19.258483] [<bf0263fc>] (usb_add_config+0x28/0xc0 [libcomposite]) from [<bf03709c>] (nokia_bind+0x9c/0x21c
    [g_nokia])
    [   19.288421] [<bf03709c>] (nokia_bind+0x9c/0x21c [g_nokia]) from [<bf0275bc>] (composite_bind+0x74/0x180
    [libcomposite])
    [   19.318420] [<bf0275bc>] (composite_bind+0x74/0x180 [libcomposite]) from [<c027d658>]
    (udc_bind_to_driver+0x2c/0xc4)
    [   19.348114] [<c027d658>] (udc_bind_to_driver+0x2c/0xc4) from [<c027d764>] (usb_gadget_probe_driver+0x74/0x94)
    [   19.377166] [<c027d764>] (usb_gadget_probe_driver+0x74/0x94) from [<c00086f8>] (do_one_initcall+0x94/0x138)
    [   19.406005] [<c00086f8>] (do_one_initcall+0x94/0x138) from [<c007a460>] (load_module+0x113c/0x13c4)
    [   19.434051] [<c007a460>] (load_module+0x113c/0x13c4) from [<c007a7b4>] (SyS_init_module+0xcc/0xec)
    [   19.462127] [<c007a7b4>] (SyS_init_module+0xcc/0xec) from [<c000dd40>] (ret_fast_syscall+0x0/0x30)
    [   19.490753] Code: 0a00002e e1a00004 eb001438 e598300c (e5d3202c)
    [   19.506805] ---[ end trace 060b62ec0d68a78b ]---
    [   19.523132] Kernel panic - not syncing: Fatal exception in interrupt
    
    dump is from 3.12-rc5 kernel
    
    Reported-by: Pali Rohr <pali.rohar@gmail.com>
    Signed-off-by: Ivaylo Dimitrov <ivo.g.dimitrov.75@gmail.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

commit 28984c7d94c27b993d09d4f2a1a2c36bfd26fd23
Author: Xianglong Du <Xianglong.Du@csr.com>
Date:   Wed Sep 11 14:24:23 2013 -0700

    drivers/rtc/rtc-sirfsoc.c: fix kernel warning during wakeup
    
    enable_irq_wake() might fail, if so, we will see kernel warning in resume
    entries due to it always calls disable_irq_wake().
    
      WARNING: at kernel/irq/manage.c:529 irq_set_irq_wake+0xc4/0xf0()
      Unbalanced IRQ 52 wake disable
      Modules linked in: ipv6 libcomposite configfs
      CPU: 0 PID: 1591 Comm: ash Tainted: G        W    3.10.0-00854-gdbd86d4-dirty #100
        (unwind_backtrace+0x0/0xf8) from (show_stack+0x10/0x14)
        (show_stack+0x10/0x14) from (warn_slowpath_common+0x54/0x68)
        (warn_slowpath_common+0x54/0x68) from (warn_slowpath_fmt+0x30/0x40)
        (warn_slowpath_fmt+0x30/0x40) from (irq_set_irq_wake+0xc4/0xf0)
        (irq_set_irq_wake+0xc4/0xf0) from (sirfsoc_rtc_restore+0x30/0x38)
        (sirfsoc_rtc_restore+0x30/0x38) from (platform_pm_restore+0x2c/0x50)
        (platform_pm_restore+0x2c/0x50) from (dpm_run_callback.clone.6+0x30/0xb0)
        (dpm_run_callback.clone.6+0x30/0xb0) from (device_resume+0x88/0x134)
        (device_resume+0x88/0x134) from (dpm_resume+0x114/0x230)
        (dpm_resume+0x114/0x230) from (hibernation_snapshot+0x178/0x1d0)
        (hibernation_snapshot+0x178/0x1d0) from (hibernate+0x130/0x1dc)
        (hibernate+0x130/0x1dc) from (state_store+0xb4/0xc0)
        (state_store+0xb4/0xc0) from (kobj_attr_store+0x14/0x20)
        (kobj_attr_store+0x14/0x20) from (sysfs_write_file+0xfc/0x17c)
        (sysfs_write_file+0xfc/0x17c) from (vfs_write+0xc8/0x194)
        (vfs_write+0xc8/0x194) from (SyS_write+0x40/0x6c)
        (SyS_write+0x40/0x6c) from (ret_fast_syscall+0x0/0x30)
    
    To avoid unbalanced "IRQ wake disable", ensure that disable_irq_wake() is
    called only when enable_irq_wake() have been successfully enabled.
    
    Signed-off-by: Xianglong Du <Xianglong.Du@csr.com>
    Signed-off-by: Barry Song <Baohua.Song@csr.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit b9c6487f8aa286e8552f7fc75206d5ed2fc5dba7
Author: jean-philippe francois <jp.francois@cynove.com>
Date:   Thu May 16 11:25:07 2013 -0700

    ARM: OMAP: fix __init section mismatch for _enable_preprogram
    
    commit 0f497039276fa2ca2ca324236848bb15c8c775dc upstream.
    
    _enable_preprogram is marked as __init, but is called from _enable
    which is not. Without this patch, the board oopses after init. Tested
    on custom hardware and on beagle board xM. Otherwise we can get:
    
    Unable to handle kernel paging request at virtual address 000b0012
    pgd = cf968000
    *pgd=8fb06831, *pte=00000000, *ppte=00000000
    PREEMPT ARM
    Modules linked in:
    CPU: 0    Not tainted  (3.9.0 #2)
    PC is at _enable_preprogram+0x1c/0x24
    LR is at omap_hwmod_enable+0x34/0x60
       psr: 80000093
    sp : cf95de08  ip : 00002de5  fp : bec33d4c
    r10: 00000000  r9 : 00000002  r8 : b6dd2c78
    r7 : 00000004  r6 : 00000000  r5 : a0000013  r4 : cf95c000
    r3 : 00000000  r2 : b6dd2c7c  r1 : 00000000  r0 : 000b0012
    Flags: Nzcv  IRQs off  FIQs on  Mode SVC_32  ISA ARM  Segment user
    Control: 10c5387d  Table: 8f968019  DAC: 00000015
    Process otpcmd (pid: 607, stack limit = 0xcf95c230)
    Stack: (0xcf95de08 to 0xcf95e000)
    de00:                   00000001 cf91f840 00000000 c001d6fc 00000002 cf91f840
    de20: cf8f7e10 c001de54 cf8f7e10 c001de78 c001de68 c01d5e80 00000000 cf8f7e10
    de40: cf8f7e10 c01d5f28 cf8f7e10 c0530d30 00000000 c01d6f28 00000000 c0088664
    de60: b6ea1000 cfb05284 cf95c000 00000001 cf95c000 60000013 00000001 cf95dee4
    de80: cf870050 c01d7308 cf870010 cf870050 00000001 c0278b14 c0526f28 00000000
    dea0: cf870050 ffff8e18 00000001 cf95dee4 00000000 c0274f7c cf870050 00000001
    dec0: cf95dee4 cf1d8484 000000e0 c0276464 00000008 cf9c0000 00000007 c0276980
    dee0: cf9c0000 00000064 00000008 cf1d8404 cf1d8400 c01cc05c 0000270a cf1d8504
    df00: 00000023 cf1d8484 00000007 c01cc670 00000bdd 00000001 00000000 cf449e60
    df20: cf1dde70 cf1d8400 bec33d18 cf1d8504 c0246f00 00000003 cf95c000 00000000
    df40: bec33d4c c01cd078 00000003 cf1d8504 00000081 c01cbcb8 bec33d18 00000003
    df60: bec33d18 c00a9034 00002000 c00a9c68 cf92fe00 00000003 c0246f00 cf92fe00
    df80: 00000000 c00a9cb0 00000003 00000000 00008e70 00000000 b6f17000 00000036
    dfa0: c000e484 c000e300 00008e70 00000000 00000003 c0246f00 bec33d18 bec33d18
    dfc0: 00008e70 00000000 b6f17000 00000036 00000000 00000000 b6f6d000 bec33d4c
    dfe0: b6ea1bd0 bec33d0c 00008c9c b6ea1bdc 60000010 00000003 00000000 00000000
    (_omap_device_enable_hwmods+0x20/0x34)
    (omap_device_enable+0x3c/0x50)
    (_od_runtime_resume+0x10/0x1c)
    (__rpm_callback+0x54/0x98)
    (rpm_callback+0x64/0x7c)
    (rpm_resume+0x434/0x554)
    (__pm_runtime_resume+0x48/0x74)
    (omap_i2c_xfer+0x28/0xe8)
    (__i2c_transfer+0x3c/0x78)
    (i2c_transfer+0x6c/0xc0)
    (i2c_master_send+0x38/0x48)
    (sha204p_send_command+0x60/0x9c)
    (sha204c_send_and_receive+0x5c/0x1e0)
    (sha204m_read+0x94/0xa0)
    (otp_do_read+0x50/0xa4)
    (vfs_ioctl+0x24/0x40)
    (do_vfs_ioctl+0x1b0/0x1c0)
    (sys_ioctl+0x38/0x54)
    (ret_fast_syscall+0x0/0x30)
    Code: e1a08002 ea000009 e598003c e592c05c (e7904003)
    
    Signed-off-by: Jean-Philippe Fran=C3=A7ois <jp.francois@cynove.com>
    Acked-by: Kevin Hilman <khilman@linaro.org>
    [tony@atomide.com: updated description with oops]
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 0f497039276fa2ca2ca324236848bb15c8c775dc
Author: jean-philippe francois <jp.francois@cynove.com>
Date:   Thu May 16 11:25:07 2013 -0700

    ARM: OMAP: fix __init section mismatch for _enable_preprogram
    
    _enable_preprogram is marked as __init, but is called from _enable
    which is not. Without this patch, the board oopses after init. Tested
    on custom hardware and on beagle board xM. Otherwise we can get:
    
    Unable to handle kernel paging request at virtual address 000b0012
    pgd = cf968000
    *pgd=8fb06831, *pte=00000000, *ppte=00000000
    PREEMPT ARM
    Modules linked in:
    CPU: 0    Not tainted  (3.9.0 #2)
    PC is at _enable_preprogram+0x1c/0x24
    LR is at omap_hwmod_enable+0x34/0x60
       psr: 80000093
    sp : cf95de08  ip : 00002de5  fp : bec33d4c
    r10: 00000000  r9 : 00000002  r8 : b6dd2c78
    r7 : 00000004  r6 : 00000000  r5 : a0000013  r4 : cf95c000
    r3 : 00000000  r2 : b6dd2c7c  r1 : 00000000  r0 : 000b0012
    Flags: Nzcv  IRQs off  FIQs on  Mode SVC_32  ISA ARM  Segment user
    Control: 10c5387d  Table: 8f968019  DAC: 00000015
    Process otpcmd (pid: 607, stack limit = 0xcf95c230)
    Stack: (0xcf95de08 to 0xcf95e000)
    de00:                   00000001 cf91f840 00000000 c001d6fc 00000002 cf91f840
    de20: cf8f7e10 c001de54 cf8f7e10 c001de78 c001de68 c01d5e80 00000000 cf8f7e10
    de40: cf8f7e10 c01d5f28 cf8f7e10 c0530d30 00000000 c01d6f28 00000000 c0088664
    de60: b6ea1000 cfb05284 cf95c000 00000001 cf95c000 60000013 00000001 cf95dee4
    de80: cf870050 c01d7308 cf870010 cf870050 00000001 c0278b14 c0526f28 00000000
    dea0: cf870050 ffff8e18 00000001 cf95dee4 00000000 c0274f7c cf870050 00000001
    dec0: cf95dee4 cf1d8484 000000e0 c0276464 00000008 cf9c0000 00000007 c0276980
    dee0: cf9c0000 00000064 00000008 cf1d8404 cf1d8400 c01cc05c 0000270a cf1d8504
    df00: 00000023 cf1d8484 00000007 c01cc670 00000bdd 00000001 00000000 cf449e60
    df20: cf1dde70 cf1d8400 bec33d18 cf1d8504 c0246f00 00000003 cf95c000 00000000
    df40: bec33d4c c01cd078 00000003 cf1d8504 00000081 c01cbcb8 bec33d18 00000003
    df60: bec33d18 c00a9034 00002000 c00a9c68 cf92fe00 00000003 c0246f00 cf92fe00
    df80: 00000000 c00a9cb0 00000003 00000000 00008e70 00000000 b6f17000 00000036
    dfa0: c000e484 c000e300 00008e70 00000000 00000003 c0246f00 bec33d18 bec33d18
    dfc0: 00008e70 00000000 b6f17000 00000036 00000000 00000000 b6f6d000 bec33d4c
    dfe0: b6ea1bd0 bec33d0c 00008c9c b6ea1bdc 60000010 00000003 00000000 00000000
    (_omap_device_enable_hwmods+0x20/0x34)
    (omap_device_enable+0x3c/0x50)
    (_od_runtime_resume+0x10/0x1c)
    (__rpm_callback+0x54/0x98)
    (rpm_callback+0x64/0x7c)
    (rpm_resume+0x434/0x554)
    (__pm_runtime_resume+0x48/0x74)
    (omap_i2c_xfer+0x28/0xe8)
    (__i2c_transfer+0x3c/0x78)
    (i2c_transfer+0x6c/0xc0)
    (i2c_master_send+0x38/0x48)
    (sha204p_send_command+0x60/0x9c)
    (sha204c_send_and_receive+0x5c/0x1e0)
    (sha204m_read+0x94/0xa0)
    (otp_do_read+0x50/0xa4)
    (vfs_ioctl+0x24/0x40)
    (do_vfs_ioctl+0x1b0/0x1c0)
    (sys_ioctl+0x38/0x54)
    (ret_fast_syscall+0x0/0x30)
    Code: e1a08002 ea000009 e598003c e592c05c (e7904003)
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Jean-Philippe Fran=C3=A7ois <jp.francois@cynove.com>
    Acked-by: Kevin Hilman <khilman@linaro.org>
    [tony@atomide.com: updated description with oops]
    Signed-off-by: Tony Lindgren <tony@atomide.com>

commit 7d54ba0e37130edda335e7f373f193014ede2a12
Author: Kevin Baradon <kevin.baradon@gmail.com>
Date:   Mon Apr 22 16:09:45 2013 -0300

    [media] media/rc/imon.c: do not try to register 2nd intf if 1st intf failed
    
    This bug could be triggered if 1st interface configuration fails:
    Apr  8 18:20:30 homeserver kernel: usb 5-1: new low-speed USB device number 2 using ohci_hcd
    Apr  8 18:20:30 homeserver kernel: input: iMON Panel, Knob and Mouse(15c2:0036) as /devices/pci0000:00/0000:00:13.0/usb5/5-1/5-1:1.0/input/input2
    Apr  8 18:20:30 homeserver kernel: Registered IR keymap rc-imon-pad
    Apr  8 18:20:30 homeserver kernel: input: iMON Remote (15c2:0036) as /devices/pci0000:00/0000:00:13.0/usb5/5-1/5-1:1.0/rc/rc0/input3
    Apr  8 18:20:30 homeserver kernel: rc0: iMON Remote (15c2:0036) as /devices/pci0000:00/0000:00:13.0/usb5/5-1/5-1:1.0/rc/rc0
    Apr  8 18:20:30 homeserver kernel: imon:send_packet: packet tx failed (-32)
    Apr  8 18:20:30 homeserver kernel: imon 5-1:1.0: remote input dev register failed
    Apr  8 18:20:30 homeserver kernel: imon 5-1:1.0: imon_init_intf0: rc device setup failed
    Apr  8 18:20:30 homeserver kernel: imon 5-1:1.0: unable to initialize intf0, err 0
    Apr  8 18:20:30 homeserver kernel: imon:imon_probe: failed to initialize context!
    Apr  8 18:20:30 homeserver kernel: imon 5-1:1.0: unable to register, err -19
    Apr  8 18:20:30 homeserver kernel: BUG: unable to handle kernel NULL pointer dereference at 00000014
    Apr  8 18:20:30 homeserver kernel: IP: [<c05c4e4c>] mutex_lock+0xc/0x30
    Apr  8 18:20:30 homeserver kernel: *pde = 00000000
    Apr  8 18:20:30 homeserver kernel: Oops: 0002 [#1] PREEMPT SMP
    Apr  8 18:20:30 homeserver kernel: Modules linked in:
    Apr  8 18:20:30 homeserver kernel: Pid: 367, comm: khubd Not tainted 3.8.3-htpc-00002-g79b1403 #23 Unknow Unknow/RS780-SB700
    Apr  8 18:20:30 homeserver kernel: EIP: 0060:[<c05c4e4c>] EFLAGS: 00010296 CPU: 1
    Apr  8 18:20:30 homeserver kernel: EIP is at mutex_lock+0xc/0x30
    Apr  8 18:20:30 homeserver kernel: EAX: 00000014 EBX: 00000014 ECX: 00000000 EDX: f590e480
    Apr  8 18:20:30 homeserver kernel: ESI: f5deac00 EDI: f590e480 EBP: f5f3ee00 ESP: f6577c28
    Apr  8 18:20:30 homeserver kernel: DS: 007b ES: 007b FS: 00d8 GS: 00e0 SS: 0068
    Apr  8 18:20:30 homeserver kernel: CR0: 8005003b CR2: 00000014 CR3: 0081b000 CR4: 000007d0
    Apr  8 18:20:30 homeserver kernel: DR0: 00000000 DR1: 00000000 DR2: 00000000 DR3: 00000000
    Apr  8 18:20:30 homeserver kernel: DR6: ffff0ff0 DR7: 00000400
    Apr  8 18:20:30 homeserver kernel: Process khubd (pid: 367, ti=f6576000 task=f649ea00 task.ti=f6576000)
    Apr  8 18:20:30 homeserver kernel: Stack:
    Apr  8 18:20:30 homeserver kernel: 00000000 f5deac00 c0448de4 f59714c0 f5deac64 c03b8ad2 f6577c90 00000004
    Apr  8 18:20:30 homeserver kernel: f649ea00 c0205142 f6779820 a1ff7f08 f5deac00 00000001 f5f3ee1c 00000014
    Apr  8 18:20:30 homeserver kernel: 00000004 00000202 15c20036 c07a03e8 fffee0ca f6795c00 f5f3ee1c f5deac00
    Apr  8 18:20:30 homeserver kernel: Call Trace:
    Apr  8 18:20:30 homeserver kernel: [<c0448de4>] ? imon_probe+0x494/0xde0
    Apr  8 18:20:30 homeserver kernel: [<c03b8ad2>] ? rpm_resume+0xb2/0x4f0
    Apr  8 18:20:30 homeserver kernel: [<c0205142>] ? sysfs_addrm_finish+0x12/0x90
    Apr  8 18:20:30 homeserver kernel: [<c04170e9>] ? usb_probe_interface+0x169/0x240
    Apr  8 18:20:30 homeserver kernel: [<c03b0ca0>] ? __driver_attach+0x80/0x80
    Apr  8 18:20:30 homeserver kernel: [<c03b0ca0>] ? __driver_attach+0x80/0x80
    Apr  8 18:20:30 homeserver kernel: [<c03b0a94>] ? driver_probe_device+0x54/0x1e0
    Apr  8 18:20:30 homeserver kernel: [<c0416abe>] ? usb_device_match+0x4e/0x80
    Apr  8 18:20:30 homeserver kernel: [<c03af314>] ? bus_for_each_drv+0x34/0x70
    Apr  8 18:20:30 homeserver kernel: [<c03b0a0b>] ? device_attach+0x7b/0x90
    Apr  8 18:20:30 homeserver kernel: [<c03b0ca0>] ? __driver_attach+0x80/0x80
    Apr  8 18:20:30 homeserver kernel: [<c03b00ff>] ? bus_probe_device+0x5f/0x80
    Apr  8 18:20:30 homeserver kernel: [<c03aeab7>] ? device_add+0x567/0x610
    Apr  8 18:20:30 homeserver kernel: [<c041a7bc>] ? usb_create_ep_devs+0x7c/0xd0
    Apr  8 18:20:30 homeserver kernel: [<c0413837>] ? create_intf_ep_devs+0x47/0x70
    Apr  8 18:20:30 homeserver kernel: [<c04156c4>] ? usb_set_configuration+0x454/0x750
    Apr  8 18:20:30 homeserver kernel: [<c03b0ca0>] ? __driver_attach+0x80/0x80
    Apr  8 18:20:30 homeserver kernel: [<c041de8a>] ? generic_probe+0x2a/0x80
    Apr  8 18:20:30 homeserver kernel: [<c03b0ca0>] ? __driver_attach+0x80/0x80
    Apr  8 18:20:30 homeserver kernel: [<c0205aff>] ? sysfs_create_link+0xf/0x20
    Apr  8 18:20:30 homeserver kernel: [<c04171db>] ? usb_probe_device+0x1b/0x40
    Apr  8 18:20:30 homeserver kernel: [<c03b0a94>] ? driver_probe_device+0x54/0x1e0
    Apr  8 18:20:30 homeserver kernel: [<c03af314>] ? bus_for_each_drv+0x34/0x70
    Apr  8 18:20:30 homeserver kernel: [<c03b0a0b>] ? device_attach+0x7b/0x90
    Apr  8 18:20:30 homeserver kernel: [<c03b0ca0>] ? __driver_attach+0x80/0x80
    Apr  8 18:20:30 homeserver kernel: [<c03b00ff>] ? bus_probe_device+0x5f/0x80
    Apr  8 18:20:30 homeserver kernel: [<c03aeab7>] ? device_add+0x567/0x610
    Apr  8 18:20:30 homeserver kernel: [<c040e6df>] ? usb_new_device+0x12f/0x1e0
    Apr  8 18:20:30 homeserver kernel: [<c040f4d8>] ? hub_thread+0x458/0x1230
    Apr  8 18:20:30 homeserver kernel: [<c015554f>] ? dequeue_task_fair+0x9f/0xc0
    Apr  8 18:20:30 homeserver kernel: [<c0131312>] ? release_task+0x1d2/0x330
    Apr  8 18:20:30 homeserver kernel: [<c01477b0>] ? abort_exclusive_wait+0x90/0x90
    Apr  8 18:20:30 homeserver kernel: [<c040f080>] ? usb_remote_wakeup+0x40/0x40
    Apr  8 18:20:30 homeserver kernel: [<c0146ed2>] ? kthread+0x92/0xa0
    Apr  8 18:20:30 homeserver kernel: [<c05c7877>] ? ret_from_kernel_thread+0x1b/0x28
    Apr  8 18:20:30 homeserver kernel: [<c0146e40>] ? kthread_freezable_should_stop+0x50/0x50
    Apr  8 18:20:30 homeserver kernel: Code: 89 04 24 89 f0 e8 05 ff ff ff 8b 5c 24 24 8b 74 24 28 8b 7c 24 2c 8b 6c 24 30 83 c4 34 c3 00 83 ec 08 89 1c 24 89 74 24 04 89 c3 <f0> ff 08 79 05 e8 ca 03 00 00 64 a1 70 d6 80 c0 8b 74 24 04 89
    Apr  8 18:20:30 homeserver kernel: EIP: [<c05c4e4c>] mutex_lock+0xc/0x30 SS:ESP 0068:f6577c28
    Apr  8 18:20:30 homeserver kernel: CR2: 0000000000000014
    Apr  8 18:20:30 homeserver kernel: ---[ end trace df134132c967205c ]---
    
    Signed-off-by: Kevin Baradon <kevin.baradon@gmail.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

commit a4c06c2a9b1cfdd6f0e310f93de35549cb72fec8
Author: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
Date:   Wed Feb 13 13:01:55 2013 -0500

    xen-blkfront: drop the use of llist_for_each_entry_safe
    
    commit f84adf4921ae3115502f44ff467b04bf2f88cf04 upstream.
    
    Replace llist_for_each_entry_safe with a while loop.
    
    llist_for_each_entry_safe can trigger a bug in GCC 4.1, so it's best
    to remove it and use a while loop and do the deletion manually.
    
    Specifically this bug can be triggered by hot-unplugging a disk, either
    by doing xm block-detach or by save/restore cycle.
    
    BUG: unable to handle kernel paging request at fffffffffffffff0
    IP: [<ffffffffa0047223>] blkif_free+0x63/0x130 [xen_blkfront]
    The crash call trace is:
            ...
    bad_area_nosemaphore+0x13/0x20
    do_page_fault+0x25e/0x4b0
    page_fault+0x25/0x30
    ? blkif_free+0x63/0x130 [xen_blkfront]
    blkfront_resume+0x46/0xa0 [xen_blkfront]
    xenbus_dev_resume+0x6c/0x140
    pm_op+0x192/0x1b0
    device_resume+0x82/0x1e0
    dpm_resume+0xc9/0x1a0
    dpm_resume_end+0x15/0x30
    do_suspend+0x117/0x1e0
    
    When drilling down to the assembler code, on newer GCC it does
    .L29:
            cmpq    $-16, %r12      #, persistent_gnt check
            je      .L30            #, out of the loop
    .L25:
            ... code in the loop
            testq   %r13, %r13      # n
            je      .L29            #, back to the top of the loop
            cmpq    $-16, %r12      #, persistent_gnt check
            movq    16(%r12), %r13  # <variable>.node.next, n
            jne     .L25            #,      back to the top of the loop
    .L30:
    
    While on GCC 4.1, it is:
    L78:
            ... code in the loop
            testq   %r13, %r13      # n
            je      .L78    #,      back to the top of the loop
            movq    16(%rbx), %r13  # <variable>.node.next, n
            jmp     .L78    #,      back to the top of the loop
    
    Which basically means that the exit loop condition instead of
    being:
    
            &(pos)->member != NULL;
    
    is:
            ;
    
    which makes the loop unbound.
    
    Since xen-blkfront is the only user of the llist_for_each_entry_safe
    macro remove it from llist.h.
    
    Orabug: 16263164
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit f84adf4921ae3115502f44ff467b04bf2f88cf04
Author: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
Date:   Wed Feb 13 13:01:55 2013 -0500

    xen-blkfront: drop the use of llist_for_each_entry_safe
    
    Replace llist_for_each_entry_safe with a while loop.
    
    llist_for_each_entry_safe can trigger a bug in GCC 4.1, so it's best
    to remove it and use a while loop and do the deletion manually.
    
    Specifically this bug can be triggered by hot-unplugging a disk, either
    by doing xm block-detach or by save/restore cycle.
    
    BUG: unable to handle kernel paging request at fffffffffffffff0
    IP: [<ffffffffa0047223>] blkif_free+0x63/0x130 [xen_blkfront]
    The crash call trace is:
            ...
    bad_area_nosemaphore+0x13/0x20
    do_page_fault+0x25e/0x4b0
    page_fault+0x25/0x30
    ? blkif_free+0x63/0x130 [xen_blkfront]
    blkfront_resume+0x46/0xa0 [xen_blkfront]
    xenbus_dev_resume+0x6c/0x140
    pm_op+0x192/0x1b0
    device_resume+0x82/0x1e0
    dpm_resume+0xc9/0x1a0
    dpm_resume_end+0x15/0x30
    do_suspend+0x117/0x1e0
    
    When drilling down to the assembler code, on newer GCC it does
    .L29:
            cmpq    $-16, %r12      #, persistent_gnt check
            je      .L30            #, out of the loop
    .L25:
            ... code in the loop
            testq   %r13, %r13      # n
            je      .L29            #, back to the top of the loop
            cmpq    $-16, %r12      #, persistent_gnt check
            movq    16(%r12), %r13  # <variable>.node.next, n
            jne     .L25            #,      back to the top of the loop
    .L30:
    
    While on GCC 4.1, it is:
    L78:
            ... code in the loop
            testq   %r13, %r13      # n
            je      .L78    #,      back to the top of the loop
            movq    16(%rbx), %r13  # <variable>.node.next, n
            jmp     .L78    #,      back to the top of the loop
    
    Which basically means that the exit loop condition instead of
    being:
    
            &(pos)->member != NULL;
    
    is:
            ;
    
    which makes the loop unbound.
    
    Since xen-blkfront is the only user of the llist_for_each_entry_safe
    macro remove it from llist.h.
    
    Orabug: 16263164
    CC: stable@vger.kernel.org
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>

commit 8e9a4a9a5c8e8765417d54ed6917c7e1e4d09f4d
Author: Tomas Winkler <tomas.winkler@intel.com>
Date:   Thu Jan 10 17:32:14 2013 +0200

    mei: drop the warning when cl is not initialized during unlinking
    
    On systems where wd and amthif is not initialized
    we will hit cl->dev == NULL. This condition is okay
    so we don't need to be laud about it.
    
    Fixes the follwing warning during suspend
    [  137.061985] WARNING: at drivers/misc/mei/client.c:315 mei_cl_unlink+0x86/0x90 [mei]()
    [  137.061986] Hardware name: 530U3BI/530U4BI/530U4BH
    [  137.062140] Modules linked in: snd_hda_codec_hdmi snd_hda_codec_realtek joydev coretemp kvm_intel snd_hda_intel snd_hda_codec kvm arc4 iwldvm snd_hwdep i915 snd_pcm mac80211 ghash_clmulni_intel snd_page_alloc aesni_intel snd_seq_midi xts snd_seq_midi_event aes_x86_64 rfcomm snd_rawmidi parport_pc bnep lrw snd_seq uvcvideo i2c_algo_bit ppdev gf128mul iwlwifi snd_timer drm_kms_helper ablk_helper cryptd drm snd_seq_device videobuf2_vmalloc psmouse videobuf2_memops snd cfg80211 btusb videobuf2_core soundcore videodev lp bluetooth samsung_laptop wmi microcode mei serio_raw mac_hid video hid_generic lpc_ich parport usbhid hid r8169
    [  137.062143] Pid: 2706, comm: kworker/u:15 Tainted: G      D W    3.8.0-rc2-next20130109-1-iniza-generic #1
    [  137.062144] Call Trace:
    [  137.062156]  [<ffffffff8105860f>] warn_slowpath_common+0x7f/0xc0
    [  137.062159]  [<ffffffff8135b1ea>] ? ioread32+0x3a/0x40
    [  137.062162]  [<ffffffff8105866a>] warn_slowpath_null+0x1a/0x20
    [  137.062168]  [<ffffffffa0076be6>] mei_cl_unlink+0x86/0x90 [mei]
    [  137.062173]  [<ffffffffa0071325>] mei_reset+0xc5/0x240 [mei]
    [  137.062178]  [<ffffffffa0073703>] mei_pci_resume+0xa3/0x110 [mei]
    [  137.062183]  [<ffffffff81379cae>] pci_pm_resume+0x7e/0xe0
    [  137.062185]  [<ffffffff81379c30>] ? pci_pm_thaw+0x80/0x80
    [  137.062189]  [<ffffffff8145a415>] dpm_run_callback.isra.6+0x25/0x50
    [  137.062192]  [<ffffffff8145a6cf>] device_resume+0x9f/0x140
    [  137.062194]  [<ffffffff8145a791>] async_resume+0x21/0x50
    [  137.062200]  [<ffffffff810858b0>] async_run_entry_fn+0x90/0x1c0
    [  137.062203]  [<ffffffff810778e5>] process_one_work+0x155/0x460
    [  137.062207]  [<ffffffff81078578>] worker_thread+0x168/0x400
    [  137.062210]  [<ffffffff81078410>] ? manage_workers+0x2b0/0x2b0
    [  137.062214]  [<ffffffff8107d9f0>] kthread+0xc0/0xd0
    [  137.062218]  [<ffffffff8107d930>] ? flush_kthread_worker+0xb0/0xb0
    [  137.062222]  [<ffffffff816bac6c>] ret_from_fork+0x7c/0xb0
    [  137.062228]  [<ffffffff8107d930>] ? flush_kthread_worker+0xb0/0xb0
    
    Reported-by: Sedat Dilek <sedat.dilek@gmail.com>
    Tested-by: Sedat Dilek <sedat.dilek@gmail.com>
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 50439c4394f0731dca76ef29916ce36abc093ad9
Author: Huang Ying <ying.huang@intel.com>
Date:   Wed Oct 24 14:54:13 2012 +0800

    PCI/PM: Fix deadlock when unbinding device if parent in D3cold
    
    commit 90b5c1d7c45eeb622302680ff96ed30c1a2b6f0e upstream.
    
    If a PCI device and its parents are put into D3cold, unbinding the
    device will trigger deadlock as follow:
    
    - driver_unbind
      - device_release_driver
        - device_lock(dev)                          <--- previous lock here
        - __device_release_driver
          - pm_runtime_get_sync
            ...
              - rpm_resume(dev)
                - rpm_resume(dev->parent)
                  ...
                    - pci_pm_runtime_resume
                      ...
                      - pci_set_power_state
                        - __pci_start_power_transition
                          - pci_wakeup_bus(dev->parent->subordinate)
                            - pci_walk_bus
                              - device_lock(dev)    <--- deadlock here
    
    
    If we do not do device_lock in pci_walk_bus, we can avoid deadlock.
    Device_lock in pci_walk_bus is introduced in commit:
    d71374dafbba7ec3f67371d3b7e9f6310a588808, corresponding email thread
    is: https://lkml.org/lkml/2006/5/26/38.  The patch author Zhang Yanmin
    said device_lock is added to pci_walk_bus because:
    
      Some error handling functions call pci_walk_bus. For example, PCIe
      aer. Here we lock the device, so the driver wouldn't detach from the
      device, as the cb might call driver's callback function.
    
    So I fixed the deadlock as follows:
    
    - remove device_lock from pci_walk_bus
    - add device_lock into callback if callback will call driver's callback
    
    I checked pci_walk_bus users one by one, and found only PCIe aer needs
    device lock.
    
    Signed-off-by: Huang Ying <ying.huang@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    CC: stable@vger.kernel.org              # v3.6+
    CC: Zhang Yanmin <yanmin.zhang@intel.com>

commit 90b5c1d7c45eeb622302680ff96ed30c1a2b6f0e
Author: Huang Ying <ying.huang@intel.com>
Date:   Wed Oct 24 14:54:13 2012 +0800

    PCI/PM: Fix deadlock when unbinding device if parent in D3cold
    
    If a PCI device and its parents are put into D3cold, unbinding the
    device will trigger deadlock as follow:
    
    - driver_unbind
      - device_release_driver
        - device_lock(dev)                          <--- previous lock here
        - __device_release_driver
          - pm_runtime_get_sync
            ...
              - rpm_resume(dev)
                - rpm_resume(dev->parent)
                  ...
                    - pci_pm_runtime_resume
                      ...
                      - pci_set_power_state
                        - __pci_start_power_transition
                          - pci_wakeup_bus(dev->parent->subordinate)
                            - pci_walk_bus
                              - device_lock(dev)    <--- deadlock here
    
    
    If we do not do device_lock in pci_walk_bus, we can avoid deadlock.
    Device_lock in pci_walk_bus is introduced in commit:
    d71374dafbba7ec3f67371d3b7e9f6310a588808, corresponding email thread
    is: https://lkml.org/lkml/2006/5/26/38.  The patch author Zhang Yanmin
    said device_lock is added to pci_walk_bus because:
    
      Some error handling functions call pci_walk_bus. For example, PCIe
      aer. Here we lock the device, so the driver wouldn't detach from the
      device, as the cb might call driver's callback function.
    
    So I fixed the deadlock as follows:
    
    - remove device_lock from pci_walk_bus
    - add device_lock into callback if callback will call driver's callback
    
    I checked pci_walk_bus users one by one, and found only PCIe aer needs
    device lock.
    
    Signed-off-by: Huang Ying <ying.huang@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    CC: stable@vger.kernel.org              # v3.6+
    CC: Zhang Yanmin <yanmin.zhang@intel.com>

commit 9e13db806e07ae9fdb1c2135fc60ea09fcbf3f3c
Author: Randy Dunlap <rdunlap@infradead.org>
Date:   Tue Oct 23 10:34:16 2012 -0700

    ALSA: ice1712: Fix build errors
    
    Fix build errors by using correct kconfig symbol name:
    
    sound/pci/ice1712/psc724.c:417:5: error: 'struct snd_ice1712' has no member named 'pm_resume'
    sound/pci/ice1712/psc724.c:418:5: error: 'struct snd_ice1712' has no member named 'pm_suspend_enabled'
    
    [Fixed another #ifdef CONFIG_PM in the same file, too, by tiwai]
    
    Signed-off-by: Randy Dunlap <rdunlap@xenotime.net>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

commit 05a65b235fb23759f3d0912f2967f6f2cd1a5c1d
Author: Feng Hong <hongfeng@marvell.com>
Date:   Wed Sep 19 14:16:00 2012 +0200

    PM / Sleep: use resume event when call dpm_resume_early
    
    commit 997a031107ec962967ce36db9bc500f1fad491c1 upstream.
    
    When dpm_suspend_noirq fail, state is PMSG_SUSPEND,
    should change to PMSG_RESUME when dpm_resume_early is called
    
    Signed-off-by: Feng Hong <hongfeng@marvell.com>
    Signed-off-by: Raul Xiong <xjian@marvell.com>
    Signed-off-by: Neil Zhang <zhangwm@marvell.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit fe3ea33e4ee9c88082e186c81690a62d99417573
Author: Feng Hong <hongfeng@marvell.com>
Date:   Wed Sep 19 14:16:00 2012 +0200

    PM / Sleep: use resume event when call dpm_resume_early
    
    commit 997a031107ec962967ce36db9bc500f1fad491c1 upstream.
    
    When dpm_suspend_noirq fail, state is PMSG_SUSPEND,
    should change to PMSG_RESUME when dpm_resume_early is called
    
    Signed-off-by: Feng Hong <hongfeng@marvell.com>
    Signed-off-by: Raul Xiong <xjian@marvell.com>
    Signed-off-by: Neil Zhang <zhangwm@marvell.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 24a0c2063c805e9cf1f3f418bb7f444b5b3f0e4e
Author: Feng Hong <hongfeng@marvell.com>
Date:   Wed Sep 19 14:16:00 2012 +0200

    PM / Sleep: use resume event when call dpm_resume_early
    
    commit 997a031107ec962967ce36db9bc500f1fad491c1 upstream.
    
    When dpm_suspend_noirq fail, state is PMSG_SUSPEND,
    should change to PMSG_RESUME when dpm_resume_early is called
    
    Signed-off-by: Feng Hong <hongfeng@marvell.com>
    Signed-off-by: Raul Xiong <xjian@marvell.com>
    Signed-off-by: Neil Zhang <zhangwm@marvell.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 16642a2e7be23bbda013fc32d8f6c68982eab603
Merge: 51562cba9893 b9142167a2bb
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Oct 2 18:32:35 2012 -0700

    Merge tag 'pm-for-3.7-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull power management updates from Rafael J Wysocki:
    
     - Improved system suspend/resume and runtime PM handling for the SH
       TMU, CMT and MTU2 clock event devices (also used by ARM/shmobile).
    
     - Generic PM domains framework extensions related to cpuidle support
       and domain objects lookup using names.
    
     - ARM/shmobile power management updates including improved support for
       the SH7372's A4S power domain containing the CPU core.
    
     - cpufreq changes related to AMD CPUs support from Matthew Garrett,
       Andre Przywara and Borislav Petkov.
    
     - cpu0 cpufreq driver from Shawn Guo.
    
     - cpufreq governor fixes related to the relaxing of limit from Michal
       Pecio.
    
     - OMAP cpufreq updates from Axel Lin and Richard Zhao.
    
     - cpuidle ladder governor fixes related to the disabling of states from
       Carsten Emde and me.
    
     - Runtime PM core updates related to the interactions with the system
       suspend core from Alan Stern and Kevin Hilman.
    
     - Wakeup sources modification allowing more helper functions to be
       called from interrupt context from John Stultz and additional
       diagnostic code from Todd Poynor.
    
     - System suspend error code path fix from Feng Hong.
    
    Fixed up conflicts in cpufreq/powernow-k8 that stemmed from the
    workqueue fixes conflicting fairly badly with the removal of support for
    hardware P-state chips.  The changes were independent but somewhat
    intertwined.
    
    * tag 'pm-for-3.7-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (76 commits)
      Revert "PM QoS: Use spinlock in the per-device PM QoS constraints code"
      PM / Runtime: let rpm_resume() succeed if RPM_ACTIVE, even when disabled, v2
      cpuidle: rename function name "__cpuidle_register_driver", v2
      cpufreq: OMAP: Check IS_ERR() instead of NULL for omap_device_get_by_hwmod_name
      cpuidle: remove some empty lines
      PM: Prevent runtime suspend during system resume
      PM QoS: Use spinlock in the per-device PM QoS constraints code
      PM / Sleep: use resume event when call dpm_resume_early
      cpuidle / ACPI : move cpuidle_device field out of the acpi_processor_power structure
      ACPI / processor: remove pointless variable initialization
      ACPI / processor: remove unused function parameter
      cpufreq: OMAP: remove loops_per_jiffy recalculate for smp
      sections: fix section conflicts in drivers/cpufreq
      cpufreq: conservative: update frequency when limits are relaxed
      cpufreq / ondemand: update frequency when limits are relaxed
      properly __init-annotate pm_sysrq_init()
      cpufreq: Add a generic cpufreq-cpu0 driver
      PM / OPP: Initialize OPP table from device tree
      ARM: add cpufreq transiton notifier to adjust loops_per_jiffy for smp
      cpufreq: Remove support for hardware P-state chips from powernow-k8
      ...

commit 7bdf66e37d4350195de86c8e44540627550a00d9
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Aug 15 21:31:55 2012 +0200

    PM / Runtime: Clear power.deferred_resume on success in rpm_suspend()
    
    commit 58a34de7b1a920d287d17d2ca08bc9aaf7e6d35b upstream.
    
    The power.deferred_resume can only be set if the runtime PM status
    of device is RPM_SUSPENDING and it should be cleared after its
    status has been changed, regardless of whether or not the runtime
    suspend has been successful.  However, it only is cleared on
    suspend failure, while it may remain set on successful suspend and
    is happily leaked to rpm_resume() executed in that case.
    
    That shouldn't happen, so if power.deferred_resume is set in
    rpm_suspend() after the status has been changed to RPM_SUSPENDED,
    clear it before calling rpm_resume().  Then, it doesn't need to be
    cleared before changing the status to RPM_SUSPENDING any more,
    because it's always cleared after the status has been changed to
    either RPM_SUSPENDED (on success) or RPM_ACTIVE (on failure).
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 30c575314dda6c51307ee06df67ae2fc44794d11
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Aug 15 21:31:45 2012 +0200

    PM / Runtime: Fix rpm_resume() return value for power.no_callbacks set
    
    commit 7f321c26c04807834fef4c524d2b21573423fc74 upstream.
    
    For devices whose power.no_callbacks flag is set, rpm_resume()
    should return 1 if the device's parent is already active, so that
    the callers of pm_runtime_get() don't think that they have to wait
    for the device to resume (asynchronously) in that case (the core
    won't queue up an asynchronous resume in that case, so there's
    nothing to wait for anyway).
    
    Modify the code accordingly (and make sure that an idle notification
    will be queued up on success, even if 1 is to be returned).
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 7f2e6defbe27240e9d51e4eee2f2568d31956b79
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Aug 15 21:31:55 2012 +0200

    PM / Runtime: Clear power.deferred_resume on success in rpm_suspend()
    
    commit 58a34de7b1a920d287d17d2ca08bc9aaf7e6d35b upstream.
    
    The power.deferred_resume can only be set if the runtime PM status
    of device is RPM_SUSPENDING and it should be cleared after its
    status has been changed, regardless of whether or not the runtime
    suspend has been successful.  However, it only is cleared on
    suspend failure, while it may remain set on successful suspend and
    is happily leaked to rpm_resume() executed in that case.
    
    That shouldn't happen, so if power.deferred_resume is set in
    rpm_suspend() after the status has been changed to RPM_SUSPENDED,
    clear it before calling rpm_resume().  Then, it doesn't need to be
    cleared before changing the status to RPM_SUSPENDING any more,
    because it's always cleared after the status has been changed to
    either RPM_SUSPENDED (on success) or RPM_ACTIVE (on failure).
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit a0bfb9191135a16c84df7ba580ea839aefff4a0f
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Aug 15 21:31:45 2012 +0200

    PM / Runtime: Fix rpm_resume() return value for power.no_callbacks set
    
    commit 7f321c26c04807834fef4c524d2b21573423fc74 upstream.
    
    For devices whose power.no_callbacks flag is set, rpm_resume()
    should return 1 if the device's parent is already active, so that
    the callers of pm_runtime_get() don't think that they have to wait
    for the device to resume (asynchronously) in that case (the core
    won't queue up an asynchronous resume in that case, so there's
    nothing to wait for anyway).
    
    Modify the code accordingly (and make sure that an idle notification
    will be queued up on success, even if 1 is to be returned).
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit d6163c4d59f7797c801e84ec537c6d7f99341717
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Aug 15 21:31:55 2012 +0200

    PM / Runtime: Clear power.deferred_resume on success in rpm_suspend()
    
    commit 58a34de7b1a920d287d17d2ca08bc9aaf7e6d35b upstream.
    
    The power.deferred_resume can only be set if the runtime PM status
    of device is RPM_SUSPENDING and it should be cleared after its
    status has been changed, regardless of whether or not the runtime
    suspend has been successful.  However, it only is cleared on
    suspend failure, while it may remain set on successful suspend and
    is happily leaked to rpm_resume() executed in that case.
    
    That shouldn't happen, so if power.deferred_resume is set in
    rpm_suspend() after the status has been changed to RPM_SUSPENDED,
    clear it before calling rpm_resume().  Then, it doesn't need to be
    cleared before changing the status to RPM_SUSPENDING any more,
    because it's always cleared after the status has been changed to
    either RPM_SUSPENDED (on success) or RPM_ACTIVE (on failure).
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 5af14b89d07f9ea69a582687adb1edcaa82f03b9
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Aug 15 21:31:45 2012 +0200

    PM / Runtime: Fix rpm_resume() return value for power.no_callbacks set
    
    commit 7f321c26c04807834fef4c524d2b21573423fc74 upstream.
    
    For devices whose power.no_callbacks flag is set, rpm_resume()
    should return 1 if the device's parent is already active, so that
    the callers of pm_runtime_get() don't think that they have to wait
    for the device to resume (asynchronously) in that case (the core
    won't queue up an asynchronous resume in that case, so there's
    nothing to wait for anyway).
    
    Modify the code accordingly (and make sure that an idle notification
    will be queued up on success, even if 1 is to be returned).
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 057d51a1268fe4be039db8ff0791fcfcb63a4f1b
Merge: 071f58279f27 88d26136a256
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Sep 24 13:31:38 2012 +0200

    Merge branch 'pm-sleep'
    
    * pm-sleep:
      PM: Prevent runtime suspend during system resume
      PM / Sleep: use resume event when call dpm_resume_early
    
    Conflicts:
            drivers/base/power/main.c (trivial)

commit 071f58279f274f749c4109aef86d899766014139
Merge: c26d4114aac5 6f3c77b040fc
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Sep 24 13:30:55 2012 +0200

    Merge branch 'pm-runtime'
    
    * pm-runtime:
      PM / Runtime: let rpm_resume() succeed if RPM_ACTIVE, even when disabled, v2

commit 6f3c77b040fc24708228607bba504878de5236d1
Author: Kevin Hilman <khilman@ti.com>
Date:   Fri Sep 21 22:47:34 2012 +0000

    PM / Runtime: let rpm_resume() succeed if RPM_ACTIVE, even when disabled, v2
    
    There are several drivers where the return value of
    pm_runtime_get_sync() is used to decide whether or not it is safe to
    access hardware and that don't provide .suspend() callbacks for system
    suspend (but may use late/noirq callbacks.)  If such a driver happens
    to call pm_runtime_get_sync() during system suspend, after the core
    has disabled runtime PM, it will get the error code and will decide
    that the hardware should not be accessed, although this may be a wrong
    conclusion, depending on the state of the device when runtime PM was
    disabled.
    
    Drivers might work around this problem by using a test like:
    
       ret = pm_runtime_get_sync(dev);
       if (!ret || (ret == -EACCES && driver_private_data(dev)->suspended)) {
          /* access hardware */
       }
    
    where driver_private_data(dev)->suspended is a flag set by the
    driver's .suspend() method (that would have to be added for this
    purpose).  However, that potentially would need to be done by multiple
    drivers which means quite a lot of duplicated code and bloat.
    
    To avoid that we can use the observation that the core sets
    dev->power.is_suspended before disabling runtime PM and use that
    instead of the driver's private flag.  Still, potentially many drivers
    would need to repeat that same check in quite a few places, so it's
    better to let the core do it.
    
    Then we can be a bit smarter and check whether or not runtime PM was
    disabled by the core only (disable_depth == 1) or by someone else in
    addition to the core (disable_depth > 1).  In the former case
    rpm_resume() can return 1 if the runtime PM status is RPM_ACTIVE,
    because it means the device was active when the core disabled runtime
    PM.  In the latter case it should still return -EACCES, because it
    isn't clear why runtime PM has been disabled.
    
    Tested on AM3730/Beagle-xM where a wakeup IRQ firing during the late
    suspend phase triggers runtime PM activity in the I2C driver since the
    wakeup IRQ is on an I2C-connected PMIC.
    
    [rjw: Modified whitespace to follow the file's convention.]
    
    Signed-off-by: Kevin Hilman <khilman@ti.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

commit 997a031107ec962967ce36db9bc500f1fad491c1
Author: Feng Hong <hongfeng@marvell.com>
Date:   Wed Sep 19 14:16:00 2012 +0200

    PM / Sleep: use resume event when call dpm_resume_early
    
    When dpm_suspend_noirq fail, state is PMSG_SUSPEND,
    should change to PMSG_RESUME when dpm_resume_early is called
    
    Signed-off-by: Feng Hong <hongfeng@marvell.com>
    Signed-off-by: Raul Xiong <xjian@marvell.com>
    Signed-off-by: Neil Zhang <zhangwm@marvell.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

commit 9379931f204703f9ccdf33b9273f3e755d86f8e6
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Aug 15 21:31:55 2012 +0200

    PM / Runtime: Clear power.deferred_resume on success in rpm_suspend()
    
    commit 58a34de7b1a920d287d17d2ca08bc9aaf7e6d35b upstream.
    
    The power.deferred_resume can only be set if the runtime PM status
    of device is RPM_SUSPENDING and it should be cleared after its
    status has been changed, regardless of whether or not the runtime
    suspend has been successful.  However, it only is cleared on
    suspend failure, while it may remain set on successful suspend and
    is happily leaked to rpm_resume() executed in that case.
    
    That shouldn't happen, so if power.deferred_resume is set in
    rpm_suspend() after the status has been changed to RPM_SUSPENDED,
    clear it before calling rpm_resume().  Then, it doesn't need to be
    cleared before changing the status to RPM_SUSPENDING any more,
    because it's always cleared after the status has been changed to
    either RPM_SUSPENDED (on success) or RPM_ACTIVE (on failure).
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit 68c4272d4202a6d4532aec0171594e079665a75e
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Aug 15 21:31:45 2012 +0200

    PM / Runtime: Fix rpm_resume() return value for power.no_callbacks set
    
    commit 7f321c26c04807834fef4c524d2b21573423fc74 upstream.
    
    For devices whose power.no_callbacks flag is set, rpm_resume()
    should return 1 if the device's parent is already active, so that
    the callers of pm_runtime_get() don't think that they have to wait
    for the device to resume (asynchronously) in that case (the core
    won't queue up an asynchronous resume in that case, so there's
    nothing to wait for anyway).
    
    Modify the code accordingly (and make sure that an idle notification
    will be queued up on success, even if 1 is to be returned).
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit d9ec0fdc24743cb6aa9b7dee9064455cd26782f9
Merge: 20fb1936dee6 3735d524da64
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Aug 18 14:39:19 2012 -0700

    Merge tag 'pm-for-3.6-rc3' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull power management fixes from Rafael J. Wysocki:
      - Fixes for three obscure problems in the runtime PM core code found
       recently.
     - Two fixes for the new "coupled" cpuidle code from Colin Cross and Jon
       Medhurst.
     - intel_idle driver fix from Konrad Rzeszutek Wilk.
    
    * tag 'pm-for-3.6-rc3' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm:
      intel_idle: Check cpu_idle_get_driver() for NULL before dereferencing it.
      cpuidle: Prevent null pointer dereference in cpuidle_coupled_cpu_notify
      cpuidle: coupled: fix sleeping while atomic in cpu notifier
      PM / Runtime: Check device PM QoS setting before "no callbacks" check
      PM / Runtime: Clear power.deferred_resume on success in rpm_suspend()
      PM / Runtime: Fix rpm_resume() return value for power.no_callbacks set

commit 58a34de7b1a920d287d17d2ca08bc9aaf7e6d35b
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Aug 15 21:31:55 2012 +0200

    PM / Runtime: Clear power.deferred_resume on success in rpm_suspend()
    
    The power.deferred_resume can only be set if the runtime PM status
    of device is RPM_SUSPENDING and it should be cleared after its
    status has been changed, regardless of whether or not the runtime
    suspend has been successful.  However, it only is cleared on
    suspend failure, while it may remain set on successful suspend and
    is happily leaked to rpm_resume() executed in that case.
    
    That shouldn't happen, so if power.deferred_resume is set in
    rpm_suspend() after the status has been changed to RPM_SUSPENDED,
    clear it before calling rpm_resume().  Then, it doesn't need to be
    cleared before changing the status to RPM_SUSPENDING any more,
    because it's always cleared after the status has been changed to
    either RPM_SUSPENDED (on success) or RPM_ACTIVE (on failure).
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Cc: stable@vger.kernel.org

commit 7f321c26c04807834fef4c524d2b21573423fc74
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Aug 15 21:31:45 2012 +0200

    PM / Runtime: Fix rpm_resume() return value for power.no_callbacks set
    
    For devices whose power.no_callbacks flag is set, rpm_resume()
    should return 1 if the device's parent is already active, so that
    the callers of pm_runtime_get() don't think that they have to wait
    for the device to resume (asynchronously) in that case (the core
    won't queue up an asynchronous resume in that case, so there's
    nothing to wait for anyway).
    
    Modify the code accordingly (and make sure that an idle notification
    will be queued up on success, even if 1 is to be returned).
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Cc: stable@vger.kernel.org

commit 46dbb0f5903b71e3c7b37e4ad707a9aa70fe3eed
Author: Colin Cross <ccross@android.com>
Date:   Thu Jul 19 10:38:06 2012 +0200

    PM / Sleep: call early resume handlers when suspend_noirq fails
    
    commit 064b021fbe470ecc9ca10f9f87af48c0fc0865fb upstream.
    
    Commit cf579dfb82550e34de7ccf3ef090d8b834ccd3a9 (PM / Sleep: Introduce
    "late suspend" and "early resume" of devices) introduced a bug where
    suspend_late handlers would be called, but if dpm_suspend_noirq returned
    an error the early_resume handlers would never be called.  All devices
    would end up on the dpm_late_early_list, and would never be resumed
    again.
    
    Fix it by calling dpm_resume_early when dpm_suspend_noirq returns
    an error.
    
    Signed-off-by: Colin Cross <ccross@android.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 87f2dfbf9bfd65659c2ac4ae68ad19d6ed569b6d
Author: Colin Cross <ccross@android.com>
Date:   Thu Jul 19 10:38:06 2012 +0200

    PM / Sleep: call early resume handlers when suspend_noirq fails
    
    commit 064b021fbe470ecc9ca10f9f87af48c0fc0865fb upstream.
    
    Commit cf579dfb82550e34de7ccf3ef090d8b834ccd3a9 (PM / Sleep: Introduce
    "late suspend" and "early resume" of devices) introduced a bug where
    suspend_late handlers would be called, but if dpm_suspend_noirq returned
    an error the early_resume handlers would never be called.  All devices
    would end up on the dpm_late_early_list, and would never be resumed
    again.
    
    Fix it by calling dpm_resume_early when dpm_suspend_noirq returns
    an error.
    
    Signed-off-by: Colin Cross <ccross@android.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 064b021fbe470ecc9ca10f9f87af48c0fc0865fb
Author: Colin Cross <ccross@android.com>
Date:   Thu Jul 19 10:38:06 2012 +0200

    PM / Sleep: call early resume handlers when suspend_noirq fails
    
    Commit cf579dfb82550e34de7ccf3ef090d8b834ccd3a9 (PM / Sleep: Introduce
    "late suspend" and "early resume" of devices) introduced a bug where
    suspend_late handlers would be called, but if dpm_suspend_noirq returned
    an error the early_resume handlers would never be called.  All devices
    would end up on the dpm_late_early_list, and would never be resumed
    again.
    
    Fix it by calling dpm_resume_early when dpm_suspend_noirq returns
    an error.
    
    Signed-off-by: Colin Cross <ccross@android.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

commit ca9a2054fe041326888811a94f17459acab9f950
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Fri Jul 6 19:09:28 2012 +0200

    tpm_nsc: Use struct dev_pm_ops for power management
    
    Make the tpm_nsc driver define its PM callbacks through
    a struct dev_pm_ops object rather than by using legacy PM hooks
    in struct platform_driver.
    
    This allows the driver to use tpm_pm_suspend() and tpm_pm_resume()
    as its PM callbacks directly, without defining its own PM callback
    routines.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

commit 8324be05380be044df8b70cb4bfb0c0b50eec3e5
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Fri Jul 6 19:09:13 2012 +0200

    tpm_atmel: Use struct dev_pm_ops for power management
    
    Make the tpm_atmel driver define its PM callbacks through
    a struct dev_pm_ops object rather than by using legacy PM hooks
    in struct platform_driver.
    
    This allows the driver to use tpm_pm_suspend() and tpm_pm_resume()
    as its PM callbacks directly, without defining its own PM callback
    routines.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

commit 16a50b1270455a6d41f9f6d8f99a72cf9d76824a
Author: Tomas Winkler <tomas.winkler@intel.com>
Date:   Wed Jun 27 17:14:20 2012 +0300

    mei: pci_resume: set IRQF_ONESHOT for msi request_threaded_irq
    
    when the default irq quick handler is used then IRQF_ONESHOT must be set
    otherwise the request fails and following error is displayed:
    
    mei 0000:00:16.0: irq 48 for MSI/MSI-X
    genirq: Threaded irq requested with handler=NULL and !ONESHOT for irq 48
    mei 0000:00:16.0: request_threaded_irq failed: irq = 48.
    dpm_run_callback(): pci_pm_resume+0x0/0x140 returns -22
    PM: Device 0000:00:16.0 failed to resume async: error -22
    
    Reported-by: Peter Wu <lekensteyn@gmail.com>
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Tested-by: Peter Wu <lekensteyn@gmail.com>
    Signed-off-by: Roland Dreier <roland@purestorage.com>
    Cc: stable <stable@vger.kernel.org> # 3.5
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit db288c9c5f9db45610dab3940377625132b4af41
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Jul 5 15:20:00 2012 -0600

    PCI / PM: restore the original behavior of pci_set_power_state()
    
    Commit cc2893b6 (PCI: Ensure we re-enable devices on resume)
    addressed the problem with USB not being powered after resume on
    recent Lenovo machines, but it did that in a suboptimal way.
    Namely, it should have changed the relevant code paths only,
    which are pci_pm_resume_noirq() and pci_pm_restore_noirq() supposed
    to restore the device's power and standard configuration registers
    after system resume from suspend or hibernation.  Instead, however,
    it modified pci_set_power_state() which is executed in several
    other situations too.  That resulted in some undesirable effects,
    like attempting to change a device's power state in the same way
    multiple times in a row (up to as many as 4 times in a row in the
    snd_hda_intel driver).
    
    Fix the bug addressed by commit cc2893b6 in an alternative way,
    by forcibly powering up all devices in pci_pm_default_resume_early(),
    which is called by pci_pm_resume_noirq() and pci_pm_restore_noirq()
    to restore the device's power and standard configuration registers,
    and modifying pci_pm_runtime_resume() to avoid the forcible power-up
    if not necessary.  Then, revert the changes made by commit cc2893b6
    to make the confusion introduced by it go away.
    
    Acked-by: Matthew Garrett <mjg@redhat.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

commit e9a34a2459723a4fed8282dd15964167bbbb6b62
Author: Ian Campbell <ian.campbell@citrix.com>
Date:   Wed Nov 9 08:53:09 2011 +0000

    genirq: Add IRQF_RESUME_EARLY and resume such IRQs earlier
    
    commit 9bab0b7fbaceec47d32db51cd9e59c82fb071f5a upstream
    
    This adds a mechanism to resume selected IRQs during syscore_resume
    instead of dpm_resume_noirq.
    
    Under Xen we need to resume IRQs associated with IPIs early enough
    that the resched IPI is unmasked and we can therefore schedule
    ourselves out of the stop_machine where the suspend/resume takes
    place.
    
    This issue was introduced by 676dc3cf5bc3 "xen: Use IRQF_FORCE_RESUME".
    
    Back ported to 2.6.32 (which lacks syscore support) by calling the relavant
    resume function directly from sysdev_resume).
    
    v2: Fixed non-x86 build errors.
    
    Signed-off-by: Ian Campbell <ian.campbell@citrix.com>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Jeremy Fitzhardinge <Jeremy.Fitzhardinge@citrix.com>
    Cc: xen-devel <xen-devel@lists.xensource.com>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Link: http://lkml.kernel.org/r/1318713254.11016.52.camel@dagon.hellion.org.uk
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    [PG: this v2 backport taken from v2.6.32.49 stable, commit 5e87d8ee34e3]
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

commit afb76df140823c57738598a876cd1d6568cd57c7
Author: Vladimir Zapolskiy <vladimir.zapolskiy@nokia.com>
Date:   Fri Dec 23 18:37:18 2011 +0200

    usb: musb: fix oops on omap2430 module unload
    
    This change prevents runtime suspend and resume actual execution, if
    omap2430 controller driver is loaded after musb-hdrc, and therefore the
    controller isn't initialized properly.
    
    The problem is reproducible with 3.1.y and 3.2 kernels.
    
    Kernel configuration of musb:
    
      % cat .config | egrep 'MUSB|GADGET'
      CONFIG_USB_MUSB_HDRC=y
      # CONFIG_USB_MUSB_TUSB6010 is not set
      CONFIG_USB_MUSB_OMAP2PLUS=m
      # CONFIG_USB_MUSB_AM35X is not set
      CONFIG_MUSB_PIO_ONLY=y
      CONFIG_USB_GADGET=y
      # CONFIG_USB_GADGET_DEBUG is not set
      # CONFIG_USB_GADGET_DEBUG_FILES is not set
      # CONFIG_USB_GADGET_DEBUG_FS is not set
      CONFIG_USB_GADGET_VBUS_DRAW=2
      CONFIG_USB_GADGET_STORAGE_NUM_BUFFERS=2
      CONFIG_USB_GADGET_MUSB_HDRC=m
      CONFIG_USB_GADGET_DUALSPEED=y
      CONFIG_USB_GADGETFS=m
      # CONFIG_USB_MIDI_GADGET is not set
    
    Fixes the following oops on module unloading:
    
      Unable to handle kernel NULL pointer dereference at virtual address 00000220
      ----8<----
      [<bf162088>] (omap2430_runtime_resume+0x24/0x54 [omap2430]) from [<c0302e34>] (pm_generic_runtime_resume+0x3c/0x50)
      [<c0302e34>] (pm_generic_runtime_resume+0x3c/0x50) from [<c0031a24>] (_od_runtime_resume+0x28/0x2c)
      [<c0031a24>] (_od_runtime_resume+0x28/0x2c) from [<c0306cb0>] (__rpm_callback+0x60/0xa0)
      [<c0306cb0>] (__rpm_callback+0x60/0xa0) from [<c0307f2c>] (rpm_resume+0x3fc/0x6e4)
      [<c0307f2c>] (rpm_resume+0x3fc/0x6e4) from [<c030851c>] (__pm_runtime_resume+0x5c/0x90)
      [<c030851c>] (__pm_runtime_resume+0x5c/0x90) from [<c02fd0dc>] (__device_release_driver+0x2c/0xd0)
      [<c02fd0dc>] (__device_release_driver+0x2c/0xd0) from [<c02fda18>] (driver_detach+0xe8/0xf4)
      [<c02fda18>] (driver_detach+0xe8/0xf4) from [<c02fcf88>] (bus_remove_driver+0xa0/0x104)
      [<c02fcf88>] (bus_remove_driver+0xa0/0x104) from [<c02fde54>] (driver_unregister+0x60/0x80)
      [<c02fde54>] (driver_unregister+0x60/0x80) from [<c02ff2d4>] (platform_driver_unregister+0x1c/0x20)
      [<c02ff2d4>] (platform_driver_unregister+0x1c/0x20) from [<bf162928>] (omap2430_exit+0x14/0x1c [omap2430])
      [<bf162928>] (omap2430_exit+0x14/0x1c [omap2430]) from [<c007d8bc>] (sys_delete_module+0x1f4/0x264)
      [<c007d8bc>] (sys_delete_module+0x1f4/0x264) from [<c000f000>] (ret_fast_syscall+0x0/0x30)
    
    Signed-off-by: Vladimir Zapolskiy <vladimir.zapolskiy@nokia.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: stable@vger.kernel.org # 3.1
    Signed-off-by: Felipe Balbi <balbi@ti.com>

commit 048be431e40ee32df8e6c1a2c216693afe3ee358
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Fri Mar 9 12:59:44 2012 +0900

    sh-sci / PM: Avoid deadlocking runtime PM
    
    The runtime PM of sh-sci devices is enabled when sci_probe() returns,
    so the pm_runtime_put_sync() executed by driver_probe_device()
    attempts to suspend the device.  Then, in some situations, a
    diagnostic message is printed to the console by one of the runtime
    suspend routines handling the sh-sci device, which causes synchronous
    runtime resume to be started from the device's own runtime suspend
    callback.  This causes rpm_resume() to be run eventually, which sees
    the RPM_SUSPENDING status set by rpm_suspend() and waits for it to
    change.  However, the device's runtime PM status cannot change at
    that point, because the routine that has set it waits for the
    rpm_suspend() to return.  A deadlock occurs as a result.
    
    To avoid that make sci_init_single() increment the device's
    runtime PM usage counter, so that it cannot be suspended by
    driver_probe_device().  That counter has to be decremented
    eventually, so make sci_startup() do that before starting to
    actually use the device and make sci_shutdown() increment it
    again before returning to balance the incrementation carried out by
    sci_startup().
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Tested-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

commit 93636af6098a627a1ddc02f2f265be4a9d337201
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Wed Feb 8 17:13:41 2012 -0800

    pcmcia: fix socket refcount decrementing on each resume
    
    commit 025e4ab3db07fcbf62c01e4f30d1012234beb980 upstream.
    
    This fixes a memory-corrupting bug: not only does it cause the warning,
    but as a result of dropping the refcount to zero, it causes the
    pcmcia_socket0 device structure to be freed while it still has
    references, causing slab caches corruption.  A fatal oops quickly
    follows this warning - often even just a 'dmesg' following the warning
    causes the kernel to oops.
    
    While testing suspend/resume on an ARM device with PCMCIA support, and a
    CF card inserted, I found that after five suspend and resumes, the
    kernel would complain, and shortly die after with slab corruption.
    
      WARNING: at include/linux/kref.h:41 kobject_get+0x28/0x50()
    
    As the message doesn't give a clue about which kobject, and the built-in
    debugging in drivers/base/power/main.c happens too late, this was added
    right before each get_device():
    
      printk("%s: %p [%s] %u\n", __func__, dev, kobject_name(&dev->kobj), atomic_read(&dev->kobj.kref.refcount));
    
    and on the 3rd s2ram cycle, the following behaviour observed:
    
    On the 3rd suspend/resume cycle:
    
      dpm_prepare: c1a0d998 [pcmcia_socket0] 3
      dpm_suspend: c1a0d998 [pcmcia_socket0] 3
      dpm_suspend_noirq: c1a0d998 [pcmcia_socket0] 3
      dpm_resume_noirq: c1a0d998 [pcmcia_socket0] 3
      dpm_resume: c1a0d998 [pcmcia_socket0] 3
      dpm_complete: c1a0d998 [pcmcia_socket0] 2
    
    4th:
    
      dpm_prepare: c1a0d998 [pcmcia_socket0] 2
      dpm_suspend: c1a0d998 [pcmcia_socket0] 2
      dpm_suspend_noirq: c1a0d998 [pcmcia_socket0] 2
      dpm_resume_noirq: c1a0d998 [pcmcia_socket0] 2
      dpm_resume: c1a0d998 [pcmcia_socket0] 2
      dpm_complete: c1a0d998 [pcmcia_socket0] 1
    
    5th:
    
      dpm_prepare: c1a0d998 [pcmcia_socket0] 1
      dpm_suspend: c1a0d998 [pcmcia_socket0] 1
      dpm_suspend_noirq: c1a0d998 [pcmcia_socket0] 1
      dpm_resume_noirq: c1a0d998 [pcmcia_socket0] 1
      dpm_resume: c1a0d998 [pcmcia_socket0] 1
      dpm_complete: c1a0d998 [pcmcia_socket0] 0
      ------------[ cut here ]------------
      WARNING: at include/linux/kref.h:41 kobject_get+0x28/0x50()
      Modules linked in: ucb1x00_core
      Backtrace:
      [<c0212090>] (dump_backtrace+0x0/0x110) from [<c04799dc>] (dump_stack+0x18/0x1c)
      [<c04799c4>] (dump_stack+0x0/0x1c) from [<c021cba0>] (warn_slowpath_common+0x50/0x68)
      [<c021cb50>] (warn_slowpath_common+0x0/0x68) from [<c021cbdc>] (warn_slowpath_null+0x24/0x28)
      [<c021cbb8>] (warn_slowpath_null+0x0/0x28) from [<c0335374>] (kobject_get+0x28/0x50)
      [<c033534c>] (kobject_get+0x0/0x50) from [<c03804f4>] (get_device+0x1c/0x24)
      [<c0388c90>] (dpm_complete+0x0/0x1a0) from [<c0389cc0>] (dpm_resume_end+0x1c/0x20)
      ...
    
    Looking at commit 7b24e7988263 ("pcmcia: split up central event handler"),
    the following change was made to cs.c:
    
                    return 0;
            }
     #endif
    -
    -       send_event(skt, CS_EVENT_PM_RESUME, CS_EVENT_PRI_LOW);
    +       if (!(skt->state & SOCKET_CARDBUS) && (skt->callback))
    +               skt->callback->early_resume(skt);
            return 0;
     }
    
    And the corresponding change in ds.c is from:
    
    -static int ds_event(struct pcmcia_socket *skt, event_t event, int priority)
    -{
    -       struct pcmcia_socket *s = pcmcia_get_socket(skt);
    ...
    -       switch (event) {
    ...
    -       case CS_EVENT_PM_RESUME:
    -               if (verify_cis_cache(skt) != 0) {
    -                       dev_dbg(&skt->dev, "cis mismatch - different card\n");
    -                       /* first, remove the card */
    -                       ds_event(skt, CS_EVENT_CARD_REMOVAL, CS_EVENT_PRI_HIGH);
    -                       mutex_lock(&s->ops_mutex);
    -                       destroy_cis_cache(skt);
    -                       kfree(skt->fake_cis);
    -                       skt->fake_cis = NULL;
    -                       s->functions = 0;
    -                       mutex_unlock(&s->ops_mutex);
    -                       /* now, add the new card */
    -                       ds_event(skt, CS_EVENT_CARD_INSERTION,
    -                                CS_EVENT_PRI_LOW);
    -               }
    -               break;
    ...
    -    }
    
    -    pcmcia_put_socket(s);
    
    -    return 0;
    -} /* ds_event */
    
    to:
    
    +static int pcmcia_bus_early_resume(struct pcmcia_socket *skt)
    +{
    +       if (!verify_cis_cache(skt)) {
    +               pcmcia_put_socket(skt);
    +               return 0;
    +       }
    
    +       dev_dbg(&skt->dev, "cis mismatch - different card\n");
    
    +       /* first, remove the card */
    +       pcmcia_bus_remove(skt);
    +       mutex_lock(&skt->ops_mutex);
    +       destroy_cis_cache(skt);
    +       kfree(skt->fake_cis);
    +       skt->fake_cis = NULL;
    +       skt->functions = 0;
    +       mutex_unlock(&skt->ops_mutex);
    
    +       /* now, add the new card */
    +       pcmcia_bus_add(skt);
    +       return 0;
    +}
    
    As can be seen, the original function called pcmcia_get_socket() and
    pcmcia_put_socket() around the guts, whereas the replacement code
    calls pcmcia_put_socket() only in one path.  This creates an imbalance
    in the refcounting.
    
    Testing with pcmcia_put_socket() put removed shows that the bug is gone:
    
      dpm_suspend: c1a10998 [pcmcia_socket0] 5
      dpm_suspend_noirq: c1a10998 [pcmcia_socket0] 5
      dpm_resume_noirq: c1a10998 [pcmcia_socket0] 5
      dpm_resume: c1a10998 [pcmcia_socket0] 5
      dpm_complete: c1a10998 [pcmcia_socket0] 5
    
    Tested-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Cc: Dominik Brodowski <linux@dominikbrodowski.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit a5e2ba3e021e7a3135a7dbb8e188d21971a59f49
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Wed Feb 8 17:13:41 2012 -0800

    pcmcia: fix socket refcount decrementing on each resume
    
    commit 025e4ab3db07fcbf62c01e4f30d1012234beb980 upstream.
    
    This fixes a memory-corrupting bug: not only does it cause the warning,
    but as a result of dropping the refcount to zero, it causes the
    pcmcia_socket0 device structure to be freed while it still has
    references, causing slab caches corruption.  A fatal oops quickly
    follows this warning - often even just a 'dmesg' following the warning
    causes the kernel to oops.
    
    While testing suspend/resume on an ARM device with PCMCIA support, and a
    CF card inserted, I found that after five suspend and resumes, the
    kernel would complain, and shortly die after with slab corruption.
    
      WARNING: at include/linux/kref.h:41 kobject_get+0x28/0x50()
    
    As the message doesn't give a clue about which kobject, and the built-in
    debugging in drivers/base/power/main.c happens too late, this was added
    right before each get_device():
    
      printk("%s: %p [%s] %u\n", __func__, dev, kobject_name(&dev->kobj), atomic_read(&dev->kobj.kref.refcount));
    
    and on the 3rd s2ram cycle, the following behaviour observed:
    
    On the 3rd suspend/resume cycle:
    
      dpm_prepare: c1a0d998 [pcmcia_socket0] 3
      dpm_suspend: c1a0d998 [pcmcia_socket0] 3
      dpm_suspend_noirq: c1a0d998 [pcmcia_socket0] 3
      dpm_resume_noirq: c1a0d998 [pcmcia_socket0] 3
      dpm_resume: c1a0d998 [pcmcia_socket0] 3
      dpm_complete: c1a0d998 [pcmcia_socket0] 2
    
    4th:
    
      dpm_prepare: c1a0d998 [pcmcia_socket0] 2
      dpm_suspend: c1a0d998 [pcmcia_socket0] 2
      dpm_suspend_noirq: c1a0d998 [pcmcia_socket0] 2
      dpm_resume_noirq: c1a0d998 [pcmcia_socket0] 2
      dpm_resume: c1a0d998 [pcmcia_socket0] 2
      dpm_complete: c1a0d998 [pcmcia_socket0] 1
    
    5th:
    
      dpm_prepare: c1a0d998 [pcmcia_socket0] 1
      dpm_suspend: c1a0d998 [pcmcia_socket0] 1
      dpm_suspend_noirq: c1a0d998 [pcmcia_socket0] 1
      dpm_resume_noirq: c1a0d998 [pcmcia_socket0] 1
      dpm_resume: c1a0d998 [pcmcia_socket0] 1
      dpm_complete: c1a0d998 [pcmcia_socket0] 0
      ------------[ cut here ]------------
      WARNING: at include/linux/kref.h:41 kobject_get+0x28/0x50()
      Modules linked in: ucb1x00_core
      Backtrace:
      [<c0212090>] (dump_backtrace+0x0/0x110) from [<c04799dc>] (dump_stack+0x18/0x1c)
      [<c04799c4>] (dump_stack+0x0/0x1c) from [<c021cba0>] (warn_slowpath_common+0x50/0x68)
      [<c021cb50>] (warn_slowpath_common+0x0/0x68) from [<c021cbdc>] (warn_slowpath_null+0x24/0x28)
      [<c021cbb8>] (warn_slowpath_null+0x0/0x28) from [<c0335374>] (kobject_get+0x28/0x50)
      [<c033534c>] (kobject_get+0x0/0x50) from [<c03804f4>] (get_device+0x1c/0x24)
      [<c0388c90>] (dpm_complete+0x0/0x1a0) from [<c0389cc0>] (dpm_resume_end+0x1c/0x20)
      ...
    
    Looking at commit 7b24e7988263 ("pcmcia: split up central event handler"),
    the following change was made to cs.c:
    
                    return 0;
            }
     #endif
    -
    -       send_event(skt, CS_EVENT_PM_RESUME, CS_EVENT_PRI_LOW);
    +       if (!(skt->state & SOCKET_CARDBUS) && (skt->callback))
    +               skt->callback->early_resume(skt);
            return 0;
     }
    
    And the corresponding change in ds.c is from:
    
    -static int ds_event(struct pcmcia_socket *skt, event_t event, int priority)
    -{
    -       struct pcmcia_socket *s = pcmcia_get_socket(skt);
    ...
    -       switch (event) {
    ...
    -       case CS_EVENT_PM_RESUME:
    -               if (verify_cis_cache(skt) != 0) {
    -                       dev_dbg(&skt->dev, "cis mismatch - different card\n");
    -                       /* first, remove the card */
    -                       ds_event(skt, CS_EVENT_CARD_REMOVAL, CS_EVENT_PRI_HIGH);
    -                       mutex_lock(&s->ops_mutex);
    -                       destroy_cis_cache(skt);
    -                       kfree(skt->fake_cis);
    -                       skt->fake_cis = NULL;
    -                       s->functions = 0;
    -                       mutex_unlock(&s->ops_mutex);
    -                       /* now, add the new card */
    -                       ds_event(skt, CS_EVENT_CARD_INSERTION,
    -                                CS_EVENT_PRI_LOW);
    -               }
    -               break;
    ...
    -    }
    
    -    pcmcia_put_socket(s);
    
    -    return 0;
    -} /* ds_event */
    
    to:
    
    +static int pcmcia_bus_early_resume(struct pcmcia_socket *skt)
    +{
    +       if (!verify_cis_cache(skt)) {
    +               pcmcia_put_socket(skt);
    +               return 0;
    +       }
    
    +       dev_dbg(&skt->dev, "cis mismatch - different card\n");
    
    +       /* first, remove the card */
    +       pcmcia_bus_remove(skt);
    +       mutex_lock(&skt->ops_mutex);
    +       destroy_cis_cache(skt);
    +       kfree(skt->fake_cis);
    +       skt->fake_cis = NULL;
    +       skt->functions = 0;
    +       mutex_unlock(&skt->ops_mutex);
    
    +       /* now, add the new card */
    +       pcmcia_bus_add(skt);
    +       return 0;
    +}
    
    As can be seen, the original function called pcmcia_get_socket() and
    pcmcia_put_socket() around the guts, whereas the replacement code
    calls pcmcia_put_socket() only in one path.  This creates an imbalance
    in the refcounting.
    
    Testing with pcmcia_put_socket() put removed shows that the bug is gone:
    
      dpm_suspend: c1a10998 [pcmcia_socket0] 5
      dpm_suspend_noirq: c1a10998 [pcmcia_socket0] 5
      dpm_resume_noirq: c1a10998 [pcmcia_socket0] 5
      dpm_resume: c1a10998 [pcmcia_socket0] 5
      dpm_complete: c1a10998 [pcmcia_socket0] 5
    
    Tested-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Cc: Dominik Brodowski <linux@dominikbrodowski.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 025e4ab3db07fcbf62c01e4f30d1012234beb980
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Wed Feb 8 17:13:41 2012 -0800

    pcmcia: fix socket refcount decrementing on each resume
    
    This fixes a memory-corrupting bug: not only does it cause the warning,
    but as a result of dropping the refcount to zero, it causes the
    pcmcia_socket0 device structure to be freed while it still has
    references, causing slab caches corruption.  A fatal oops quickly
    follows this warning - often even just a 'dmesg' following the warning
    causes the kernel to oops.
    
    While testing suspend/resume on an ARM device with PCMCIA support, and a
    CF card inserted, I found that after five suspend and resumes, the
    kernel would complain, and shortly die after with slab corruption.
    
      WARNING: at include/linux/kref.h:41 kobject_get+0x28/0x50()
    
    As the message doesn't give a clue about which kobject, and the built-in
    debugging in drivers/base/power/main.c happens too late, this was added
    right before each get_device():
    
      printk("%s: %p [%s] %u\n", __func__, dev, kobject_name(&dev->kobj), atomic_read(&dev->kobj.kref.refcount));
    
    and on the 3rd s2ram cycle, the following behaviour observed:
    
    On the 3rd suspend/resume cycle:
    
      dpm_prepare: c1a0d998 [pcmcia_socket0] 3
      dpm_suspend: c1a0d998 [pcmcia_socket0] 3
      dpm_suspend_noirq: c1a0d998 [pcmcia_socket0] 3
      dpm_resume_noirq: c1a0d998 [pcmcia_socket0] 3
      dpm_resume: c1a0d998 [pcmcia_socket0] 3
      dpm_complete: c1a0d998 [pcmcia_socket0] 2
    
    4th:
    
      dpm_prepare: c1a0d998 [pcmcia_socket0] 2
      dpm_suspend: c1a0d998 [pcmcia_socket0] 2
      dpm_suspend_noirq: c1a0d998 [pcmcia_socket0] 2
      dpm_resume_noirq: c1a0d998 [pcmcia_socket0] 2
      dpm_resume: c1a0d998 [pcmcia_socket0] 2
      dpm_complete: c1a0d998 [pcmcia_socket0] 1
    
    5th:
    
      dpm_prepare: c1a0d998 [pcmcia_socket0] 1
      dpm_suspend: c1a0d998 [pcmcia_socket0] 1
      dpm_suspend_noirq: c1a0d998 [pcmcia_socket0] 1
      dpm_resume_noirq: c1a0d998 [pcmcia_socket0] 1
      dpm_resume: c1a0d998 [pcmcia_socket0] 1
      dpm_complete: c1a0d998 [pcmcia_socket0] 0
      ------------[ cut here ]------------
      WARNING: at include/linux/kref.h:41 kobject_get+0x28/0x50()
      Modules linked in: ucb1x00_core
      Backtrace:
      [<c0212090>] (dump_backtrace+0x0/0x110) from [<c04799dc>] (dump_stack+0x18/0x1c)
      [<c04799c4>] (dump_stack+0x0/0x1c) from [<c021cba0>] (warn_slowpath_common+0x50/0x68)
      [<c021cb50>] (warn_slowpath_common+0x0/0x68) from [<c021cbdc>] (warn_slowpath_null+0x24/0x28)
      [<c021cbb8>] (warn_slowpath_null+0x0/0x28) from [<c0335374>] (kobject_get+0x28/0x50)
      [<c033534c>] (kobject_get+0x0/0x50) from [<c03804f4>] (get_device+0x1c/0x24)
      [<c0388c90>] (dpm_complete+0x0/0x1a0) from [<c0389cc0>] (dpm_resume_end+0x1c/0x20)
      ...
    
    Looking at commit 7b24e7988263 ("pcmcia: split up central event handler"),
    the following change was made to cs.c:
    
                    return 0;
            }
     #endif
    -
    -       send_event(skt, CS_EVENT_PM_RESUME, CS_EVENT_PRI_LOW);
    +       if (!(skt->state & SOCKET_CARDBUS) && (skt->callback))
    +               skt->callback->early_resume(skt);
            return 0;
     }
    
    And the corresponding change in ds.c is from:
    
    -static int ds_event(struct pcmcia_socket *skt, event_t event, int priority)
    -{
    -       struct pcmcia_socket *s = pcmcia_get_socket(skt);
    ...
    -       switch (event) {
    ...
    -       case CS_EVENT_PM_RESUME:
    -               if (verify_cis_cache(skt) != 0) {
    -                       dev_dbg(&skt->dev, "cis mismatch - different card\n");
    -                       /* first, remove the card */
    -                       ds_event(skt, CS_EVENT_CARD_REMOVAL, CS_EVENT_PRI_HIGH);
    -                       mutex_lock(&s->ops_mutex);
    -                       destroy_cis_cache(skt);
    -                       kfree(skt->fake_cis);
    -                       skt->fake_cis = NULL;
    -                       s->functions = 0;
    -                       mutex_unlock(&s->ops_mutex);
    -                       /* now, add the new card */
    -                       ds_event(skt, CS_EVENT_CARD_INSERTION,
    -                                CS_EVENT_PRI_LOW);
    -               }
    -               break;
    ...
    -    }
    
    -    pcmcia_put_socket(s);
    
    -    return 0;
    -} /* ds_event */
    
    to:
    
    +static int pcmcia_bus_early_resume(struct pcmcia_socket *skt)
    +{
    +       if (!verify_cis_cache(skt)) {
    +               pcmcia_put_socket(skt);
    +               return 0;
    +       }
    
    +       dev_dbg(&skt->dev, "cis mismatch - different card\n");
    
    +       /* first, remove the card */
    +       pcmcia_bus_remove(skt);
    +       mutex_lock(&skt->ops_mutex);
    +       destroy_cis_cache(skt);
    +       kfree(skt->fake_cis);
    +       skt->fake_cis = NULL;
    +       skt->functions = 0;
    +       mutex_unlock(&skt->ops_mutex);
    
    +       /* now, add the new card */
    +       pcmcia_bus_add(skt);
    +       return 0;
    +}
    
    As can be seen, the original function called pcmcia_get_socket() and
    pcmcia_put_socket() around the guts, whereas the replacement code
    calls pcmcia_put_socket() only in one path.  This creates an imbalance
    in the refcounting.
    
    Testing with pcmcia_put_socket() put removed shows that the bug is gone:
    
      dpm_suspend: c1a10998 [pcmcia_socket0] 5
      dpm_suspend_noirq: c1a10998 [pcmcia_socket0] 5
      dpm_resume_noirq: c1a10998 [pcmcia_socket0] 5
      dpm_resume: c1a10998 [pcmcia_socket0] 5
      dpm_complete: c1a10998 [pcmcia_socket0] 5
    
    Tested-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Cc: Dominik Brodowski <linux@dominikbrodowski.net>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit 556ef3e474dd87d627655dafdf1e7eaf4747e388
Author: Marek Szyprowski <m.szyprowski@samsung.com>
Date:   Fri Jan 27 14:47:45 2012 +0900

    ARM: EXYNOS: fix non-SMP builds for EXYNOS4
    
    This patch fixes the following build issue, which happens only if
    SMP has been disabled:
    
    arch/arm/mach-exynos/built-in.o: In function `exynos4_pm_resume':
    arch/arm/mach-exynos/pm.c:387: undefined reference to `scu_enable'
    
    Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>
    Signed-off-by: Kukjin Kim <kgene.kim@samsung.com>

commit 5e87d8ee34e32fda720f3a4e4055f570b09230d6
Author: Ian Campbell <ian.campbell@citrix.com>
Date:   Wed Nov 9 08:53:09 2011 +0000

    genirq: Add IRQF_RESUME_EARLY and resume such IRQs earlier
    
    commit 9bab0b7fbaceec47d32db51cd9e59c82fb071f5a upstream
    
    This adds a mechanism to resume selected IRQs during syscore_resume
    instead of dpm_resume_noirq.
    
    Under Xen we need to resume IRQs associated with IPIs early enough
    that the resched IPI is unmasked and we can therefore schedule
    ourselves out of the stop_machine where the suspend/resume takes
    place.
    
    This issue was introduced by 676dc3cf5bc3 "xen: Use IRQF_FORCE_RESUME".
    
    Back ported to 2.6.32 (which lacks syscore support) by calling the relavant
    resume function directly from sysdev_resume).
    
    v2: Fixed non-x86 build errors.
    
    Signed-off-by: Ian Campbell <ian.campbell@citrix.com>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Jeremy Fitzhardinge <Jeremy.Fitzhardinge@citrix.com>
    Cc: xen-devel <xen-devel@lists.xensource.com>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Link: http://lkml.kernel.org/r/1318713254.11016.52.camel@dagon.hellion.org.uk
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit cce574ff161d0f5e4263ed28a4a3785220802922
Author: Ian Campbell <ian.campbell@citrix.com>
Date:   Mon Oct 3 15:37:00 2011 +0100

    genirq: Add IRQF_RESUME_EARLY and resume such IRQs earlier
    
    commit 9bab0b7fbaceec47d32db51cd9e59c82fb071f5a upstream.
    
    This adds a mechanism to resume selected IRQs during syscore_resume
    instead of dpm_resume_noirq.
    
    Under Xen we need to resume IRQs associated with IPIs early enough
    that the resched IPI is unmasked and we can therefore schedule
    ourselves out of the stop_machine where the suspend/resume takes
    place.
    
    This issue was introduced by 676dc3cf5bc3 "xen: Use IRQF_FORCE_RESUME".
    
    Signed-off-by: Ian Campbell <ian.campbell@citrix.com>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Jeremy Fitzhardinge <Jeremy.Fitzhardinge@citrix.com>
    Cc: xen-devel <xen-devel@lists.xensource.com>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Link: http://lkml.kernel.org/r/1318713254.11016.52.camel@dagon.hellion.org.uk
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit a717f83d88fee104f61eac2ad9ad5816825f6247
Author: Ning Jiang <ning.jiang@marvell.com>
Date:   Mon Sep 5 16:28:18 2011 +0800

    serial-core: power up uart port early before we do set_termios when resuming
    
    commit 94abc56f4d90f289ea32a0a11d3577fcd8cb28fb upstream.
    
    The following patch removed uart_change_pm() in uart_resume_port():
    
    commit 5933a161abcb8d83a2c145177f48027c3c0a8995
    Author: Yin Kangkai <kangkai.yin@linux.intel.com>
        serial-core: reset the console speed on resume
    
    It will break the pxa serial driver when the system resumes from suspend mode
    as it will try to set baud rate divider register in set_termios but with
    clock off. The register value can not be set correctly on some platform if
    the clock is disabled. The pxa driver will check the value and report the
    following warning:
    
    ------------[ cut here ]------------
    WARNING: at drivers/tty/serial/pxa.c:545 serial_pxa_set_termios+0x1dc/0x250()
    Modules linked in:
    [<c0281f30>] (unwind_backtrace+0x0/0xf0) from [<c029341c>] (warn_slowpath_common+0x4c/0x64)
    [<c029341c>] (warn_slowpath_common+0x4c/0x64) from [<c029344c>] (warn_slowpath_null+0x18/0x1c)
    [<c029344c>] (warn_slowpath_null+0x18/0x1c) from [<c044b1e4>] (serial_pxa_set_termios+0x1dc/0x250)
    [<c044b1e4>] (serial_pxa_set_termios+0x1dc/0x250) from [<c044a840>] (uart_resume_port+0x128/0x2dc)
    [<c044a840>] (uart_resume_port+0x128/0x2dc) from [<c044bbe0>] (serial_pxa_resume+0x18/0x24)
    [<c044bbe0>] (serial_pxa_resume+0x18/0x24) from [<c0454d34>] (platform_pm_resume+0x40/0x4c)
    [<c0454d34>] (platform_pm_resume+0x40/0x4c) from [<c0457ebc>] (pm_op+0x68/0xb4)
    [<c0457ebc>] (pm_op+0x68/0xb4) from [<c0458368>] (device_resume+0xb0/0xec)
    [<c0458368>] (device_resume+0xb0/0xec) from [<c04584c8>] (dpm_resume+0xe0/0x194)
    [<c04584c8>] (dpm_resume+0xe0/0x194) from [<c0458588>] (dpm_resume_end+0xc/0x18)
    [<c0458588>] (dpm_resume_end+0xc/0x18) from [<c02c518c>] (suspend_devices_and_enter+0x16c/0x1ac)
    [<c02c518c>] (suspend_devices_and_enter+0x16c/0x1ac) from [<c02c5278>] (enter_state+0xac/0xdc)
    [<c02c5278>] (enter_state+0xac/0xdc) from [<c02c48ec>] (state_store+0xa0/0xbc)
    [<c02c48ec>] (state_store+0xa0/0xbc) from [<c0408f7c>] (kobj_attr_store+0x18/0x1c)
    [<c0408f7c>] (kobj_attr_store+0x18/0x1c) from [<c034a6a4>] (sysfs_write_file+0x108/0x140)
    [<c034a6a4>] (sysfs_write_file+0x108/0x140) from [<c02fb798>] (vfs_write+0xac/0x134)
    [<c02fb798>] (vfs_write+0xac/0x134) from [<c02fb8cc>] (sys_write+0x3c/0x68)
    [<c02fb8cc>] (sys_write+0x3c/0x68) from [<c027c700>] (ret_fast_syscall+0x0/0x2c)
    ---[ end trace 88289eceb4675b04 ]---
    
    This patch fix the problem by adding the power on opertion back for uart
    console when console_suspend_enabled is true.
    
    Signed-off-by: Ning Jiang <ning.jiang@marvell.com>
    Tested-by: Mayank Rana <mrana@codeaurora.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 09bb52774e0543390bdba59b67ade093d34e4906
Author: Ian Campbell <ian.campbell@citrix.com>
Date:   Mon Oct 3 15:37:00 2011 +0100

    genirq: Add IRQF_RESUME_EARLY and resume such IRQs earlier
    
    commit 9bab0b7fbaceec47d32db51cd9e59c82fb071f5a upstream.
    
    This adds a mechanism to resume selected IRQs during syscore_resume
    instead of dpm_resume_noirq.
    
    Under Xen we need to resume IRQs associated with IPIs early enough
    that the resched IPI is unmasked and we can therefore schedule
    ourselves out of the stop_machine where the suspend/resume takes
    place.
    
    This issue was introduced by 676dc3cf5bc3 "xen: Use IRQF_FORCE_RESUME".
    
    Signed-off-by: Ian Campbell <ian.campbell@citrix.com>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Jeremy Fitzhardinge <Jeremy.Fitzhardinge@citrix.com>
    Cc: xen-devel <xen-devel@lists.xensource.com>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Link: http://lkml.kernel.org/r/1318713254.11016.52.camel@dagon.hellion.org.uk
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 3e9efdd45f78e0ad859b60906c6556e8efe2579b
Author: Ning Jiang <ning.jiang@marvell.com>
Date:   Mon Sep 5 16:28:18 2011 +0800

    serial-core: power up uart port early before we do set_termios when resuming
    
    commit 94abc56f4d90f289ea32a0a11d3577fcd8cb28fb upstream.
    
    The following patch removed uart_change_pm() in uart_resume_port():
    
    commit 5933a161abcb8d83a2c145177f48027c3c0a8995
    Author: Yin Kangkai <kangkai.yin@linux.intel.com>
        serial-core: reset the console speed on resume
    
    It will break the pxa serial driver when the system resumes from suspend mode
    as it will try to set baud rate divider register in set_termios but with
    clock off. The register value can not be set correctly on some platform if
    the clock is disabled. The pxa driver will check the value and report the
    following warning:
    
    ------------[ cut here ]------------
    WARNING: at drivers/tty/serial/pxa.c:545 serial_pxa_set_termios+0x1dc/0x250()
    Modules linked in:
    [<c0281f30>] (unwind_backtrace+0x0/0xf0) from [<c029341c>] (warn_slowpath_common+0x4c/0x64)
    [<c029341c>] (warn_slowpath_common+0x4c/0x64) from [<c029344c>] (warn_slowpath_null+0x18/0x1c)
    [<c029344c>] (warn_slowpath_null+0x18/0x1c) from [<c044b1e4>] (serial_pxa_set_termios+0x1dc/0x250)
    [<c044b1e4>] (serial_pxa_set_termios+0x1dc/0x250) from [<c044a840>] (uart_resume_port+0x128/0x2dc)
    [<c044a840>] (uart_resume_port+0x128/0x2dc) from [<c044bbe0>] (serial_pxa_resume+0x18/0x24)
    [<c044bbe0>] (serial_pxa_resume+0x18/0x24) from [<c0454d34>] (platform_pm_resume+0x40/0x4c)
    [<c0454d34>] (platform_pm_resume+0x40/0x4c) from [<c0457ebc>] (pm_op+0x68/0xb4)
    [<c0457ebc>] (pm_op+0x68/0xb4) from [<c0458368>] (device_resume+0xb0/0xec)
    [<c0458368>] (device_resume+0xb0/0xec) from [<c04584c8>] (dpm_resume+0xe0/0x194)
    [<c04584c8>] (dpm_resume+0xe0/0x194) from [<c0458588>] (dpm_resume_end+0xc/0x18)
    [<c0458588>] (dpm_resume_end+0xc/0x18) from [<c02c518c>] (suspend_devices_and_enter+0x16c/0x1ac)
    [<c02c518c>] (suspend_devices_and_enter+0x16c/0x1ac) from [<c02c5278>] (enter_state+0xac/0xdc)
    [<c02c5278>] (enter_state+0xac/0xdc) from [<c02c48ec>] (state_store+0xa0/0xbc)
    [<c02c48ec>] (state_store+0xa0/0xbc) from [<c0408f7c>] (kobj_attr_store+0x18/0x1c)
    [<c0408f7c>] (kobj_attr_store+0x18/0x1c) from [<c034a6a4>] (sysfs_write_file+0x108/0x140)
    [<c034a6a4>] (sysfs_write_file+0x108/0x140) from [<c02fb798>] (vfs_write+0xac/0x134)
    [<c02fb798>] (vfs_write+0xac/0x134) from [<c02fb8cc>] (sys_write+0x3c/0x68)
    [<c02fb8cc>] (sys_write+0x3c/0x68) from [<c027c700>] (ret_fast_syscall+0x0/0x2c)
    ---[ end trace 88289eceb4675b04 ]---
    
    This patch fix the problem by adding the power on opertion back for uart
    console when console_suspend_enabled is true.
    
    Signed-off-by: Ning Jiang <ning.jiang@marvell.com>
    Tested-by: Mayank Rana <mrana@codeaurora.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 0f12a6ad9fa3a03f2bcee36c9cb704821e244c40
Author: Ian Campbell <ian.campbell@citrix.com>
Date:   Mon Oct 3 15:37:00 2011 +0100

    genirq: Add IRQF_RESUME_EARLY and resume such IRQs earlier
    
    commit 9bab0b7fbaceec47d32db51cd9e59c82fb071f5a upstream
    
    This adds a mechanism to resume selected IRQs during syscore_resume
    instead of dpm_resume_noirq.
    
    Under Xen we need to resume IRQs associated with IPIs early enough
    that the resched IPI is unmasked and we can therefore schedule
    ourselves out of the stop_machine where the suspend/resume takes
    place.
    
    This issue was introduced by 676dc3cf5bc3 "xen: Use IRQF_FORCE_RESUME".
    
    Back ported to 2.6.32 (which lacks syscore support) by calling the relavant
    resume function directly from sysdev_resume).
    
    Signed-off-by: Ian Campbell <ian.campbell@citrix.com>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Jeremy Fitzhardinge <Jeremy.Fitzhardinge@citrix.com>
    Cc: xen-devel <xen-devel@lists.xensource.com>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Link: http://lkml.kernel.org/r/1318713254.11016.52.camel@dagon.hellion.org.uk
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 9bab0b7fbaceec47d32db51cd9e59c82fb071f5a
Author: Ian Campbell <ian.campbell@citrix.com>
Date:   Mon Oct 3 15:37:00 2011 +0100

    genirq: Add IRQF_RESUME_EARLY and resume such IRQs earlier
    
    This adds a mechanism to resume selected IRQs during syscore_resume
    instead of dpm_resume_noirq.
    
    Under Xen we need to resume IRQs associated with IPIs early enough
    that the resched IPI is unmasked and we can therefore schedule
    ourselves out of the stop_machine where the suspend/resume takes
    place.
    
    This issue was introduced by 676dc3cf5bc3 "xen: Use IRQF_FORCE_RESUME".
    
    Signed-off-by: Ian Campbell <ian.campbell@citrix.com>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Jeremy Fitzhardinge <Jeremy.Fitzhardinge@citrix.com>
    Cc: xen-devel <xen-devel@lists.xensource.com>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Link: http://lkml.kernel.org/r/1318713254.11016.52.camel@dagon.hellion.org.uk
    Cc: stable@kernel.org (at least to 2.6.32.y)
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit c3dc2f14622a06488f11452b6efd1e02c5a8548b
Author: Ming Lei <ming.lei@canonical.com>
Date:   Tue Sep 27 22:54:41 2011 +0200

    PM / Runtime: Replace dev_dbg() with trace_rpm_*()
    
    This patch replaces dev_dbg with trace_rpm_* inside
    the three important functions:
    
            rpm_idle
            rpm_suspend
            rpm_resume
    
    Trace points have the below advantages compared with dev_dbg:
    
            - trace points include much runtime information(such as
            running cpu, current task, ...)
    
            - most of linux distributions may disable "verbose debug"
            driver debug compile switch, so it is very difficult to
            report/debug runtime pm related problems from distribution
            users without this kind of debug information.
    
            - for upstream kernel users, enableing the debug switch will
            produce many useless "rpm_resume" output, and it is very noise.
    
            - dev_dbg inside rpm_suspend/rpm_resume may have some effects
            on runtime pm behaviour of console devicer
    
    Signed-off-by: Ming Lei <ming.lei@canonical.com>
    Acked-by: Steven Rostedt <rostedt@goodmis.org>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

commit 53b615ccca567ada1931eb04ad0614ac150c14a3
Author: Ming Lei <ming.lei@canonical.com>
Date:   Tue Sep 27 22:53:27 2011 +0200

    PM / Runtime: Introduce trace points for tracing rpm_* functions
    
    This patch introduces 3 trace points to prepare for tracing
    rpm_idle/rpm_suspend/rpm_resume functions, so we can use these
    trace points to replace the current dev_dbg().
    
    Signed-off-by: Ming Lei <ming.lei@canonical.com>
    Acked-by: Steven Rostedt <rostedt@goodmis.org>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

commit ad3c36a534bc7b945d7bffdda1c62e13bf93489a
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Sep 27 21:54:52 2011 +0200

    PM / Runtime: Don't run callbacks under lock for power.irq_safe set
    
    The rpm_suspend() and rpm_resume() routines execute subsystem or PM
    domain callbacks under power.lock if power.irq_safe is set for the
    given device.  This is inconsistent with that rpm_idle() does after
    commit 02b2677 (PM / Runtime: Allow _put_sync() from
    interrupts-disabled context) and is problematic for subsystems and PM
    domains wanting to use power.lock for synchronization in their
    runtime PM callbacks.
    
    This change requires the code checking if the device's runtime PM
    status is RPM_SUSPENDING or RPM_RESUMING to be modified too, to take
    the power.irq_safe set case into account (that code wasn't reachable
    before with power.irq_safe set, because it's executed with the
    device's power.lock held).
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Reviewed-by: Ming Lei <tom.leiming@gmail.com>
    Reviewed-by: Kevin Hilman <khilman@ti.com>

commit 94abc56f4d90f289ea32a0a11d3577fcd8cb28fb
Author: Ning Jiang <ning.jiang@marvell.com>
Date:   Mon Sep 5 16:28:18 2011 +0800

    serial-core: power up uart port early before we do set_termios when resuming
    
    The following patch removed uart_change_pm() in uart_resume_port():
    
    commit 5933a161abcb8d83a2c145177f48027c3c0a8995
    Author: Yin Kangkai <kangkai.yin@linux.intel.com>
        serial-core: reset the console speed on resume
    
    It will break the pxa serial driver when the system resumes from suspend mode
    as it will try to set baud rate divider register in set_termios but with
    clock off. The register value can not be set correctly on some platform if
    the clock is disabled. The pxa driver will check the value and report the
    following warning:
    
    ------------[ cut here ]------------
    WARNING: at drivers/tty/serial/pxa.c:545 serial_pxa_set_termios+0x1dc/0x250()
    Modules linked in:
    [<c0281f30>] (unwind_backtrace+0x0/0xf0) from [<c029341c>] (warn_slowpath_common+0x4c/0x64)
    [<c029341c>] (warn_slowpath_common+0x4c/0x64) from [<c029344c>] (warn_slowpath_null+0x18/0x1c)
    [<c029344c>] (warn_slowpath_null+0x18/0x1c) from [<c044b1e4>] (serial_pxa_set_termios+0x1dc/0x250)
    [<c044b1e4>] (serial_pxa_set_termios+0x1dc/0x250) from [<c044a840>] (uart_resume_port+0x128/0x2dc)
    [<c044a840>] (uart_resume_port+0x128/0x2dc) from [<c044bbe0>] (serial_pxa_resume+0x18/0x24)
    [<c044bbe0>] (serial_pxa_resume+0x18/0x24) from [<c0454d34>] (platform_pm_resume+0x40/0x4c)
    [<c0454d34>] (platform_pm_resume+0x40/0x4c) from [<c0457ebc>] (pm_op+0x68/0xb4)
    [<c0457ebc>] (pm_op+0x68/0xb4) from [<c0458368>] (device_resume+0xb0/0xec)
    [<c0458368>] (device_resume+0xb0/0xec) from [<c04584c8>] (dpm_resume+0xe0/0x194)
    [<c04584c8>] (dpm_resume+0xe0/0x194) from [<c0458588>] (dpm_resume_end+0xc/0x18)
    [<c0458588>] (dpm_resume_end+0xc/0x18) from [<c02c518c>] (suspend_devices_and_enter+0x16c/0x1ac)
    [<c02c518c>] (suspend_devices_and_enter+0x16c/0x1ac) from [<c02c5278>] (enter_state+0xac/0xdc)
    [<c02c5278>] (enter_state+0xac/0xdc) from [<c02c48ec>] (state_store+0xa0/0xbc)
    [<c02c48ec>] (state_store+0xa0/0xbc) from [<c0408f7c>] (kobj_attr_store+0x18/0x1c)
    [<c0408f7c>] (kobj_attr_store+0x18/0x1c) from [<c034a6a4>] (sysfs_write_file+0x108/0x140)
    [<c034a6a4>] (sysfs_write_file+0x108/0x140) from [<c02fb798>] (vfs_write+0xac/0x134)
    [<c02fb798>] (vfs_write+0xac/0x134) from [<c02fb8cc>] (sys_write+0x3c/0x68)
    [<c02fb8cc>] (sys_write+0x3c/0x68) from [<c027c700>] (ret_fast_syscall+0x0/0x2c)
    ---[ end trace 88289eceb4675b04 ]---
    
    This patch fix the problem by adding the power on opertion back for uart
    console when console_suspend_enabled is true.
    
    Signed-off-by: Ning Jiang <ning.jiang@marvell.com>
    Tested-by: Mayank Rana <mrana@codeaurora.org>
    Cc: stable <stable@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit ecb4433550f0620f3d1471ae7099037ede30a91e
Author: Stanislaw Gruszka <sgruszka@redhat.com>
Date:   Fri Aug 12 14:00:59 2011 +0200

    mac80211: fix suspend/resume races with unregister hw
    
    Do not call ->suspend, ->resume methods after we unregister wiphy. Also
    delete sta_clanup timer after we finish wiphy unregister to avoid this:
    
    WARNING: at lib/debugobjects.c:262 debug_print_object+0x85/0xa0()
    Hardware name: 6369CTO
    ODEBUG: free active (active state 0) object type: timer_list hint: sta_info_cleanup+0x0/0x180 [mac80211]
    Modules linked in: aes_i586 aes_generic fuse bridge stp llc autofs4 sunrpc cpufreq_ondemand acpi_cpufreq mperf ext2 dm_mod uinput thinkpad_acpi hwmon sg arc4 rt2800usb rt2800lib crc_ccitt rt2x00usb rt2x00lib mac80211 cfg80211 i2c_i801 iTCO_wdt iTCO_vendor_support e1000e ext4 mbcache jbd2 sd_mod crc_t10dif sr_mod cdrom yenta_socket ahci libahci pata_acpi ata_generic ata_piix i915 drm_kms_helper drm i2c_algo_bit video [last unloaded: microcode]
    Pid: 5663, comm: pm-hibernate Not tainted 3.1.0-rc1-wl+ #19
    Call Trace:
     [<c0454cfd>] warn_slowpath_common+0x6d/0xa0
     [<c05e05e5>] ? debug_print_object+0x85/0xa0
     [<c05e05e5>] ? debug_print_object+0x85/0xa0
     [<c0454dae>] warn_slowpath_fmt+0x2e/0x30
     [<c05e05e5>] debug_print_object+0x85/0xa0
     [<f8a808e0>] ? sta_info_alloc+0x1a0/0x1a0 [mac80211]
     [<c05e0bd2>] debug_check_no_obj_freed+0xe2/0x180
     [<c051175b>] kfree+0x8b/0x150
     [<f8a126ae>] cfg80211_dev_free+0x7e/0x90 [cfg80211]
     [<f8a13afd>] wiphy_dev_release+0xd/0x10 [cfg80211]
     [<c068d959>] device_release+0x19/0x80
     [<c05d06ba>] kobject_release+0x7a/0x1c0
     [<c07646a8>] ? rtnl_unlock+0x8/0x10
     [<f8a13adb>] ? wiphy_resume+0x6b/0x80 [cfg80211]
     [<c05d0640>] ? kobject_del+0x30/0x30
     [<c05d1a6d>] kref_put+0x2d/0x60
     [<c05d056d>] kobject_put+0x1d/0x50
     [<c08015f4>] ? mutex_lock+0x14/0x40
     [<c068d60f>] put_device+0xf/0x20
     [<c069716a>] dpm_resume+0xca/0x160
     [<c04912bd>] hibernation_snapshot+0xcd/0x260
     [<c04903df>] ? freeze_processes+0x3f/0x90
     [<c049151b>] hibernate+0xcb/0x1e0
     [<c048fdc0>] ? pm_async_store+0x40/0x40
     [<c048fe60>] state_store+0xa0/0xb0
     [<c048fdc0>] ? pm_async_store+0x40/0x40
     [<c05d0200>] kobj_attr_store+0x20/0x30
     [<c0575ea4>] sysfs_write_file+0x94/0xf0
     [<c051e26a>] vfs_write+0x9a/0x160
     [<c0575e10>] ? sysfs_open_file+0x200/0x200
     [<c051e3fd>] sys_write+0x3d/0x70
     [<c080959f>] sysenter_do_call+0x12/0x28
    
    Cc: stable@kernel.org
    Signed-off-by: Stanislaw Gruszka <sgruszka@redhat.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

commit e13d8f383985b7ab8c859c1fa327e9b3d201894e
Author: Nishanth Menon <nm@ti.com>
Date:   Sat Jul 9 14:37:21 2011 -0700

    OMAP3+: SR: ensure pm-runtime callbacks can be invoked with IRQs disabled
    
    SmartReflex should be disabled while entering low power mode due to
    a) SmartReflex values are not defined for retention voltage, further
    b) with SmartReflex enabled, if CPU enters lower c-states, FSM will try
    to bump the voltage to current OPP's voltage for which it has entered c-state;
    hence SmartReflex needs to be disabled for MPU, CORE and IVA voltage
    domains in idle path before enabling auto retention voltage achievement
    on the device.
    
    However, since the current pm_runtime setup for SmartReflex devices are
    setup to allow callbacks to be invoked with interrupts enabled, calling
    SmartReflex enable/disable from other contexts such as idle paths
    where preemption is disabled causes warnings such as the following
    indicating of a potential race.
    [   82.023895] [<c04d079c>] (__irq_svc+0x3c/0x120) from [<c04d0484>] (_raw_spin_unlock_irq+0x28/0x2c)
    [   82.023895] [<c04d0484>] (_raw_spin_unlock_irq+0x28/0x2c) from [<c0323234>] (rpm_callback+0x4c/0x68)
    [   82.023956] [<c0323234>] (rpm_callback+0x4c/0x68) from [<c0323f7c>] (rpm_resume+0x338/0x53c)
    [   82.023956] [<c0323f7c>] (rpm_resume+0x338/0x53c) from [<c03243f4>] (__pm_runtime_resume+0x48/0x60)
    [   82.023986] [<c03243f4>] (__pm_runtime_resume+0x48/0x60) from [<c008aee0>] (sr_enable+0xa8/0x19c)
    [   82.023986] [<c008aee0>] (sr_enable+0xa8/0x19c) from [<c008b2fc>] (omap_sr_enable+0x50/0x90)
    [   82.024017] [<c008b2fc>] (omap_sr_enable+0x50/0x90) from [<c00888c0>] (omap4_enter_sleep+0x138/0x168)
    
    Instead, we use pm_runtime_irq_safe to tell the PM core that callbacks can be
    invoked in interrupt disabled contexts.
    
    Acked-by: Rajendra Nayak <rnayak@ti.com>
    Signed-off-by: Nishanth Menon <nm@ti.com>
    [khilman@ti.com: minor changelog edits]
    Signed-off-by: Kevin Hilman <khilman@ti.com>

commit 5c2de44417523385010b529599a2b30f290831a3
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue May 31 15:53:03 2011 +0900

    dmaengine: shdma: Fix up fallout from runtime PM changes.
    
    The runtime PM changes introduce sh_dmae_rst() wrapping via the
    runtime_resume helper, depending on dev_get_drvdata() to fetch the
    platform data needed for the DMAOR initialization default at a time
    where drvdata hasn't yet been established by the probe path, resulting
    in general probe misery:
    
            Unable to handle kernel NULL pointer dereference at virtual address 000000c4
            pc = 8025adee
            *pde = 00000000
            Oops: 0000 [#1]
            Modules linked in:
    
            Pid : 1, Comm:           swapper
            CPU : 0                  Not tainted  (3.0.0-rc1-00012-g9436b4a-dirty #1456)
    
            PC is at sh_dmae_rst+0x28/0x86
            PR is at sh_dmae_rst+0x22/0x86
            PC  : 8025adee SP  : 9e803d10 SR  : 400080f1 TEA : 000000c4
            R0  : 000000c4 R1  : 0000fff8 R2  : 00000000 R3  : 00000040
            R4  : 000000f0 R5  : 00000000 R6  : 00000000 R7  : 804f184c
            R8  : 00000000 R9  : 804dd0e8 R10 : 80283204 R11 : ffffffda
            R12 : 000000a0 R13 : 804dd18c R14 : 9e803d10
            MACH: 00000000 MACL: 00008f20 GBR : 00000000 PR  : 8025ade8
    
            Call trace:
            [<8025ae70>] sh_dmae_runtime_resume+0x24/0x34
            [<80283238>] pm_generic_runtime_resume+0x34/0x3c
            [<80283370>] rpm_callback+0x4a/0x7e
            [<80283efc>] rpm_resume+0x240/0x384
            [<80283f54>] rpm_resume+0x298/0x384
            [<8028428c>] __pm_runtime_resume+0x44/0x7c
            [<8038a358>] __ioremap_caller+0x0/0xec
            [<80284296>] __pm_runtime_resume+0x4e/0x7c
            [<8038a358>] __ioremap_caller+0x0/0xec
            [<80666254>] sh_dmae_probe+0x180/0x6a0
            [<802803ae>] platform_drv_probe+0x26/0x2e
    
    Fix up the ordering accordingly.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

commit 75bd0cbdc21d80859c80bdd5dd00125c1a3ccbca
Author: Ming Lei <tom.leiming@gmail.com>
Date:   Thu Apr 28 22:37:09 2011 +0000

    usbnet: runtime pm: fix out of memory
    
    This patch makes use of the EVENT_DEV_OPEN flag introduced recently to
    fix one out of memory issue, which can be reproduced on omap3/4 based
    pandaboard/beagle XM easily with steps below:
    
            - enable runtime pm
            echo auto > /sys/devices/platform/usbhs-omap.0/ehci-omap.0/usb1/1-1/1-1.1/power/control
    
            - ifconfig eth0 up
    
            - then out of memroy happened, see [1] for kernel message.
    
    Follows my analysis:
            - 'ifconfig eth0 up' brings eth0 out of suspend, and usbnet_resume
            is called to schedule dev->bh, then rx urbs are submited to prepare for
            recieving data;
    
            - some usbnet devices will produce garbage rx packets flood if
            info->reset is not called in usbnet_open.
    
            - so there is no enough chances for usbnet_bh to handle and release
            recieved skb buffers since many rx interrupts consumes cpu, so out of memory
            for atomic allocation in rx_submit happened.
    
    This patch fixes the issue by simply not allowing schedule of usbnet_bh until device
    is opened.
    
    [1], dmesg
    [  234.712005] smsc95xx 1-1.1:1.0: rpm_resume flags 0x4
    [  234.712066] usb 1-1.1: rpm_resume flags 0x0
    [  234.712066] usb 1-1: rpm_resume flags 0x0
    [  234.712097] usb usb1: rpm_resume flags 0x0
    [  234.712127] usb usb1: usb auto-resume
    [  234.712158] ehci-omap ehci-omap.0: resume root hub
    [  234.754028] hub 1-0:1.0: hub_resume
    [  234.754821] hub 1-0:1.0: port 1: status 0507 change 0000
    [  234.756011] hub 1-0:1.0: state 7 ports 3 chg 0000 evt 0000
    [  234.756042] hub 1-0:1.0: rpm_resume flags 0x4
    [  234.756072] usb usb1: rpm_resume flags 0x0
    [  234.756164] usb usb1: rpm_resume returns 1
    [  234.756195] hub 1-0:1.0: rpm_resume returns 0
    [  234.756195] hub 1-0:1.0: rpm_suspend flags 0x4
    [  234.756225] hub 1-0:1.0: rpm_suspend returns 0
    [  234.756256] usb usb1: rpm_resume returns 0
    [  234.757141] usb 1-1: usb auto-resume
    [  234.793151] ehci-omap ehci-omap.0: GetStatus port:1 status 001005 0  ACK POWER sig=se0 PE CONNECT
    [  234.816558] usb 1-1: finish resume
    [  234.817871] hub 1-1:1.0: hub_resume
    [  234.818420] hub 1-1:1.0: port 1: status 0507 change 0000
    [  234.820495] ehci-omap ehci-omap.0: reused qh eec50220 schedule
    [  234.820495] usb 1-1: link qh256-0001/eec50220 start 1 [1/0 us]
    [  234.820587] usb 1-1: rpm_resume returns 0
    [  234.820800] hub 1-1:1.0: state 7 ports 5 chg 0000 evt 0000
    [  234.820800] hub 1-1:1.0: rpm_resume flags 0x4
    [  234.820831] hub 1-1:1.0: rpm_resume returns 0
    [  234.820861] hub 1-1:1.0: rpm_suspend flags 0x4
    [  234.820861] hub 1-1:1.0: rpm_suspend returns 0
    [  234.821777] usb 1-1.1: usb auto-resume
    [  234.868591] hub 1-1:1.0: state 7 ports 5 chg 0000 evt 0002
    [  234.868591] hub 1-1:1.0: rpm_resume flags 0x4
    [  234.868621] hub 1-1:1.0: rpm_resume returns 0
    [  234.868652] hub 1-1:1.0: rpm_suspend flags 0x4
    [  234.868652] hub 1-1:1.0: rpm_suspend returns 0
    [  234.879486] usb 1-1.1: finish resume
    [  234.880279] usb 1-1.1: rpm_resume returns 0
    [  234.880310] smsc95xx 1-1.1:1.0: rpm_resume returns 0
    [  238.880187] ksoftirqd/0: page allocation failure. order:0, mode:0x20
    [  238.880218] Backtrace:
    [  238.880249] [<c01b9800>] (dump_backtrace+0x0/0xf8) from [<c065e1dc>] (dump_stack+0x18/0x1c)
    [  238.880249]  r6:00000000 r5:00000000 r4:00000020 r3:00000002
    [  238.880310] [<c065e1c4>] (dump_stack+0x0/0x1c) from [<c026ece4>] (__alloc_pages_nodemask+0x620/0x724)
    [  238.880340] [<c026e6c4>] (__alloc_pages_nodemask+0x0/0x724) from [<c02986d4>] (kmem_getpages.clone.34+0x34/0xc8)
    [  238.880371] [<c02986a0>] (kmem_getpages.clone.34+0x0/0xc8) from [<c02988f8>] (cache_grow.clone.42+0x84/0x154)
    [  238.880371]  r6:ef871aa4 r5:ef871a80 r4:ef81fd40 r3:00000020
    [  238.880401] [<c0298874>] (cache_grow.clone.42+0x0/0x154) from [<c0298b64>] (cache_alloc_refill+0x19c/0x1f0)
    [  238.880432] [<c02989c8>] (cache_alloc_refill+0x0/0x1f0) from [<c0299804>] (kmem_cache_alloc+0x90/0x190)
    [  238.880462] [<c0299774>] (kmem_cache_alloc+0x0/0x190) from [<c052e260>] (__alloc_skb+0x34/0xe8)
    [  238.880493] [<c052e22c>] (__alloc_skb+0x0/0xe8) from [<bf0509f4>] (rx_submit+0x2c/0x1d4 [usbnet])
    [  238.880523] [<bf0509c8>] (rx_submit+0x0/0x1d4 [usbnet]) from [<bf050d38>] (rx_complete+0x19c/0x1b0 [usbnet])
    [  238.880737] [<bf050b9c>] (rx_complete+0x0/0x1b0 [usbnet]) from [<bf006fd0>] (usb_hcd_giveback_urb+0xa8/0xf4 [usbcore])
    [  238.880737]  r8:eeeced34 r7:eeecec00 r6:eeecec00 r5:00000000 r4:eec2dd20
    [  238.880767] r3:bf050b9c
    [  238.880859] [<bf006f28>] (usb_hcd_giveback_urb+0x0/0xf4 [usbcore]) from [<bf03c8f8>] (ehci_urb_done+0xb0/0xbc [ehci_hcd])
    [  238.880859]  r6:00000000 r5:eec2dd20 r4:eeeced44 r3:eec2dd34
    [  238.880920] [<bf03c848>] (ehci_urb_done+0x0/0xbc [ehci_hcd]) from [<bf040204>] (qh_completions+0x308/0x3bc [ehci_hcd])
    [  238.880920]  r7:00000000 r6:eeda21a0 r5:ffdfe3c0 r4:eeda21ac
    [  238.880981] [<bf03fefc>] (qh_completions+0x0/0x3bc [ehci_hcd]) from [<bf040ef8>] (scan_async+0xb0/0x16c [ehci_hcd])
    [  238.881011] [<bf040e48>] (scan_async+0x0/0x16c [ehci_hcd]) from [<bf040fec>] (ehci_work+0x38/0x90 [ehci_hcd])
    [  238.881042] [<bf040fb4>] (ehci_work+0x0/0x90 [ehci_hcd]) from [<bf042940>] (ehci_irq+0x300/0x34c [ehci_hcd])
    [  238.881072]  r4:eeeced34 r3:00000001
    [  238.881134] [<bf042640>] (ehci_irq+0x0/0x34c [ehci_hcd]) from [<bf006828>] (usb_hcd_irq+0x40/0xac [usbcore])
    [  238.881195] [<bf0067e8>] (usb_hcd_irq+0x0/0xac [usbcore]) from [<c0239764>] (handle_irq_event_percpu+0xb8/0x240)
    [  238.881225]  r6:eec504e0 r5:0000006d r4:eec504e0 r3:bf0067e8
    [  238.881256] [<c02396ac>] (handle_irq_event_percpu+0x0/0x240) from [<c0239930>] (handle_irq_event+0x44/0x64)
    [  238.881256] [<c02398ec>] (handle_irq_event+0x0/0x64) from [<c023bbd0>] (handle_level_irq+0xe0/0x114)
    [  238.881286]  r6:0000006d r5:c080c14c r4:c080c100 r3:00020000
    [  238.881317] [<c023baf0>] (handle_level_irq+0x0/0x114) from [<c01ab090>] (asm_do_IRQ+0x90/0xd0)
    [  238.881317]  r5:00000000 r4:0000006d
    [  238.881347] [<c01ab000>] (asm_do_IRQ+0x0/0xd0) from [<c06624d0>] (__irq_svc+0x50/0x134)
    [  238.881378] Exception stack(0xef837e20 to 0xef837e68)
    [  238.881378] 7e20: 00000001 00185610 016cc000 c00490c0 eb380000 ef800540 00000020 00004ae0
    [  238.881408] 7e40: 00000020 bf0509f4 60000013 ef837e9c ef837e40 ef837e68 c0226f0c c0298ca0
    [  238.881408] 7e60: 20000013 ffffffff
    [  238.881408]  r5:fa240100 r4:ffffffff
    [  238.881439] [<c0298bb8>] (__kmalloc_track_caller+0x0/0x1d0) from [<c052e284>] (__alloc_skb+0x58/0xe8)
    [  238.881469] [<c052e22c>] (__alloc_skb+0x0/0xe8) from [<bf0509f4>] (rx_submit+0x2c/0x1d4 [usbnet])
    [  238.881500] [<bf0509c8>] (rx_submit+0x0/0x1d4 [usbnet]) from [<bf0513d8>] (usbnet_bh+0x1b4/0x250 [usbnet])
    [  238.881530] [<bf051224>] (usbnet_bh+0x0/0x250 [usbnet]) from [<c01f912c>] (tasklet_action+0xb0/0x1f8)
    [  238.881530]  r6:00000000 r5:ef9757f0 r4:ef9757ec r3:bf051224
    [  238.881561] [<c01f907c>] (tasklet_action+0x0/0x1f8) from [<c01f97ac>] (__do_softirq+0x140/0x290)
    [  238.881561]  r8:00000006 r7:00000101 r6:00000000 r5:c0806098 r4:00000001
    [  238.881591] r3:c01f907c
    [  238.881622] [<c01f966c>] (__do_softirq+0x0/0x290) from [<c01f99cc>] (run_ksoftirqd+0xd0/0x1f4)
    [  238.881622] [<c01f98fc>] (run_ksoftirqd+0x0/0x1f4) from [<c02113b0>] (kthread+0x90/0x98)
    [  238.881652]  r7:00000013 r6:c01f98fc r5:00000000 r4:ef831efc
    [  238.881683] [<c0211320>] (kthread+0x0/0x98) from [<c01f62f4>] (do_exit+0x0/0x374)
    [  238.881713]  r6:c01f62f4 r5:c0211320 r4:ef831efc
    [  238.881713] Mem-info:
    [  238.881744] Normal per-cpu:
    [  238.881744] CPU    0: hi:  186, btch:  31 usd:  38
    [  238.881744] CPU    1: hi:  186, btch:  31 usd: 169
    [  238.881774] HighMem per-cpu:
    [  238.881774] CPU    0: hi:   90, btch:  15 usd:  66
    [  238.881774] CPU    1: hi:   90, btch:  15 usd:  86
    [  238.881805] active_anon:544 inactive_anon:71 isolated_anon:0
    [  238.881805]  active_file:926 inactive_file:2538 isolated_file:0
    [  238.881805]  unevictable:0 dirty:10 writeback:0 unstable:0
    [  238.881805]  free:57782 slab_reclaimable:864 slab_unreclaimable:186898
    [  238.881805]  mapped:632 shmem:144 pagetables:50 bounce:0
    [  238.881835] Normal free:1328kB min:3532kB low:4412kB high:5296kB active_anon:0kB inactive_anon:0kB active_file:880kB inactive_file:848kB unevictable:0kB isolated(anon):0kB isolated(file):0kB present:780288kB mlocked:0kB dirty:36kB writeback:0kB mapped:0kB shmem:0kB slab_reclaimable:3456kB slab_unreclaimable:747592kB kernel_stack:392kB pagetables:200kB unstable:0kB bounce:0kB writeback_tmp:0kB pages_scanned:0 all_unreclaimable? no
    [  238.881866] lowmem_reserve[]: 0 1904 1904
    [  238.881896] HighMem free:229800kB min:236kB low:508kB high:784kB active_anon:2176kB inactive_anon:284kB active_file:2824kB inactive_file:9304kB unevictable:0kB isolated(anon):0kB isolated(file):0kB present:243712kB mlocked:0kB dirty:4kB writeback:0kB mapped:2528kB shmem:576kB slab_reclaimable:0kB slab_unreclaimable:0kB kernel_stack:0kB pagetables:0kB unstable:0kB bounce:0kB writeback_tmp:0kB pages_scanned:0 all_unreclaimable? no
    [  238.881927] lowmem_reserve[]: 0 0 0
    [  238.881958] Normal: 0*4kB 4*8kB 6*16kB 0*32kB 1*64kB 1*128kB 0*256kB 2*512kB 0*1024kB 0*2048kB 0*4096kB = 1344kB
    [  238.882019] HighMem: 6*4kB 2*8kB 4*16kB 4*32kB 1*64kB 1*128kB 0*256kB 2*512kB 3*1024kB 0*2048kB 55*4096kB = 229800kB
    [  238.882080] 3610 total pagecache pages
    [  238.882080] 0 pages in swap cache
    [  238.882080] Swap cache stats: add 0, delete 0, find 0/0
    [  238.882110] Free swap  = 0kB
    [  238.882110] Total swap = 0kB
    [  238.933776] 262144 pages of RAM
    [  238.933776] 58240 free pages
    [  238.933776] 10503 reserved pages
    [  238.933776] 187773 slab pages
    [  238.933807] 2475 pages shared
    [  238.933807] 0 pages swap cached
    
    Signed-off-by: Ming Lei <tom.leiming@gmail.com>
    Acked-by: Oliver Neukum <oneukum@suse.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit b3e96c0c756211e805c6941d4a6e5f6e1995cb6b
Author: Shriram Rajagopalan <rshriram@cs.ubc.ca>
Date:   Tue Feb 22 14:59:06 2011 -0800

    xen: use freeze/restore/thaw PM events for suspend/resume/chkpt
    
    Use PM_FREEZE, PM_THAW and PM_RESTORE power events for
    suspend/resume/checkpoint functionality, instead of PM_SUSPEND
    and PM_RESUME. Use of these pm events fixes the Xen Guest hangup
    when taking checkpoints. When a suspend event is cancelled
    (while taking checkpoints once/continuously), we use PM_THAW
    instead of PM_RESUME. PM_RESTORE is used when suspend is not
    cancelled. See Documentation/power/devices.txt and linux/pm.h
    for more info about freeze, thaw and restore. The sequence of
    pm events in a suspend-resume scenario is shown below.
    
            dpm_suspend_start(PMSG_FREEZE);
    
                    dpm_suspend_noirq(PMSG_FREEZE);
    
                           sysdev_suspend(PMSG_FREEZE);
                           cancelled = suspend_hypercall()
                           sysdev_resume();
    
                   dpm_resume_noirq(cancelled ? PMSG_THAW : PMSG_RESTORE);
    
           dpm_resume_end(cancelled ? PMSG_THAW : PMSG_RESTORE);
    
    Acked-by: Ian Campbell <ian.campbell@citrix.com>
    Signed-off-by: Shriram Rajagopalan <rshriram@cs.ubc.ca>
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>

commit a7b545f7fe753ca3dc1b51ca57f90cd59d974e44
Author: Eliad Peller <eliad@wizery.com>
Date:   Tue Feb 8 18:43:19 2011 +0200

    mac80211: add missing locking in ieee80211_reconfig
    
    When suspending an associated system, and then resuming,
    the station vif is being reconfigured without taking the
    sdata->u.mgd.mtx lock, which results in the following warning:
    
    WARNING: at net/mac80211/mlme.c:101 ieee80211_ap_probereq_get+0x58/0xb8 [mac80211]()
    Modules linked in: wl12xx_sdio wl12xx firmware_class crc7 mac80211 cfg80211 [last unloaded: crc7]
    Backtrace:
    [<c005432c>] (dump_backtrace+0x0/0x118) from [<c0376e28>] (dump_stack+0x20/0x24)
     r7:00000000 r6:bf12d6ec r5:bf154aac r4:00000065
    [<c0376e08>] (dump_stack+0x0/0x24) from [<c0079104>] (warn_slowpath_common+0x5c/0x74)
    [<c00790a8>] (warn_slowpath_common+0x0/0x74) from [<c0079148>] (warn_slowpath_null+0x2c/0x34)
     r9:000024ff r8:cd006460 r7:00000001 r6:00000000 r5:00000000
    r4:cf1394a0
    [<c007911c>] (warn_slowpath_null+0x0/0x34) from [<bf12d6ec>] (ieee80211_ap_probereq_get+0x58/0xb8 [mac80211])
    [<bf12d694>] (ieee80211_ap_probereq_get+0x0/0xb8 [mac80211]) from [<bf19cd04>] (wl1271_cmd_build_ap_probe_req+0x30/0xf8 [wl12xx])
     r4:cd007440
    [<bf19ccd4>] (wl1271_cmd_build_ap_probe_req+0x0/0xf8 [wl12xx]) from [<bf1995f4>] (wl1271_op_bss_info_changed+0x4c4/0x808 [wl12xx])
     r5:cd007440 r4:000003b4
    [<bf199130>] (wl1271_op_bss_info_changed+0x0/0x808 [wl12xx]) from [<bf122168>] (ieee80211_bss_info_change_notify+0x1a4/0x1f8 [mac80211])
    [<bf121fc4>] (ieee80211_bss_info_change_notify+0x0/0x1f8 [mac80211]) from [<bf141e80>] (ieee80211_reconfig+0x4d0/0x668 [mac80211])
     r8:cf0eeea4 r7:cd00671c r6:00000000 r5:cd006460 r4:cf1394a0
    [<bf1419b0>] (ieee80211_reconfig+0x0/0x668 [mac80211]) from [<bf137dd4>] (ieee80211_resume+0x60/0x70 [mac80211])
    [<bf137d74>] (ieee80211_resume+0x0/0x70 [mac80211]) from [<bf0eb930>] (wiphy_resume+0x6c/0x7c [cfg80211])
     r5:cd006248 r4:cd006110
    [<bf0eb8c4>] (wiphy_resume+0x0/0x7c [cfg80211]) from [<c0241024>] (legacy_resume+0x38/0x70)
     r7:00000000 r6:00000000 r5:cd006248 r4:cd0062fc
    [<c0240fec>] (legacy_resume+0x0/0x70) from [<c0241478>] (device_resume+0x168/0x1a0)
     r8:c04ca8d8 r7:cd00627c r6:00000010 r5:cd006248 r4:cd0062fc
    [<c0241310>] (device_resume+0x0/0x1a0) from [<c0241600>] (dpm_resume_end+0xf8/0x3bc)
     r7:00000000 r6:00000005 r5:cd006248 r4:cd0062fc
    [<c0241508>] (dpm_resume_end+0x0/0x3bc) from [<c00b2a24>] (suspend_devices_and_enter+0x1b0/0x204)
    [<c00b2874>] (suspend_devices_and_enter+0x0/0x204) from [<c00b2b68>] (enter_state+0xf0/0x148)
     r7:c037e978 r6:00000003 r5:c043d807 r4:00000000
    [<c00b2a78>] (enter_state+0x0/0x148) from [<c00b20a4>] (state_store+0xa4/0xcc)
     r7:c037e978 r6:00000003 r5:00000003 r4:c043d807
    [<c00b2000>] (state_store+0x0/0xcc) from [<c01fc90c>] (kobj_attr_store+0x20/0x24)
    [<c01fc8ec>] (kobj_attr_store+0x0/0x24) from [<c0157120>] (sysfs_write_file+0x11c/0x150)
    [<c0157004>] (sysfs_write_file+0x0/0x150) from [<c0100f84>] (vfs_write+0xc0/0x14c)
    [<c0100ec4>] (vfs_write+0x0/0x14c) from [<c01010e4>] (sys_write+0x4c/0x78)
     r8:40126000 r7:00000004 r6:cf1a7c80 r5:00000000 r4:00000000
    [<c0101098>] (sys_write+0x0/0x78) from [<c00500c0>] (ret_fast_syscall+0x0/0x30)
     r8:c00502c8 r7:00000004 r6:403525e8 r5:40126000 r4:00000004
    
    Signed-off-by: Eliad Peller <eliad@wizery.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

commit d2d8f66bb991757e360728da77920e18bd678767
Merge: 474829e875ab d63be5f924cf
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Oct 26 17:31:05 2010 -0700

    Merge branch 'pm-fixes' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/suspend-2.6
    
    * 'pm-fixes' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/suspend-2.6:
      PM / Runtime: fix recursive locking warning of lockdep from rpm_resume()

commit d63be5f924cf054e7ac18bb2761f9533039fb076
Author: Ming Lei <tom.leiming@gmail.com>
Date:   Fri Oct 22 23:48:14 2010 +0200

    PM / Runtime: fix recursive locking warning of lockdep from rpm_resume()
    
    For device with no_callbacks flag set, its power lock and its parent's
    power lock may be held nestedly in rpm_resume, so we should take
    spin_lock_nested(lock, SINGLE_DEPTH_NESTING) to acquire parent power lock
    to avoid lockdep warning.
    
    Signed-off-by: Ming Lei <tom.leiming@gmail.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

commit 71c63122c4609a917f14a79c32067a68909fc487
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Oct 4 22:08:01 2010 +0200

    PM / Runtime: Reduce code duplication in core helper functions
    
    Reduce code duplication in rpm_idle(), rpm_suspend() and rpm_resume()
    by using local pointers to store callback addresses and moving some
    duplicated code into a separate function.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Reviewed-by: Alan Stern <stern@rowland.harvard.edu>

commit 140a6c945211ee911dec776fafa52e03a7d7bb9a
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Sat Sep 25 23:35:07 2010 +0200

    PM / Runtime: Combine runtime PM entry points
    
    This patch (as1424) combines the various public entry points for the
    runtime PM routines into three simple functions: one for idle, one for
    suspend, and one for resume.  A new bitflag specifies whether or not
    to increment or decrement the usage_count field.
    
    The new entry points are named __pm_runtime_idle,
    __pm_runtime_suspend, and __pm_runtime_resume, to reflect that they
    are trampolines.  Simultaneously, the corresponding internal routines
    are renamed to rpm_idle, rpm_suspend, and rpm_resume.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

commit 753419f59e10d7181e43f0b9cc5beff43ef3f7a4
Author: Vishwanath BS <vishwanath.bs@ti.com>
Date:   Thu Sep 30 14:14:22 2010 +0200

    i2c: Fix for suspend/resume issue
    
    In current i2c core driver, call to pm_runtime_set_active from
    i2c_device_pm_resume will unconditionally enable i2c module and
    increment child count of the parent. Because of this, in CPU Idle
    path, i2c does not idle, preventing Core to enter retention. Also i2c
    module will not be suspended upon system suspend as
    pm_runtime_set_suspended is not called from i2c_device_pm_suspend.
    
    This issue is fixed by removing pm_runtime_set_active call from resume
    path which is not necessary.
    This fix has been tested on OMAP4430.
    
    Signed-off-by: Partha Basak <p-basak2@ti.com>
    Signed-off-by: Vishwanath BS <vishwanath.bs@ti.com>
    Acked-by: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Kevin Hilman <khilman@deeprootsystems.com>
    Cc: Ben Dooks <ben-linux@fluff.org>
    Signed-off-by: Jean Delvare <khali@linux-fr.org>

commit 2af3495b6359c30740b31175aa818f600f5b8bb9
Author: Colin Cross <ccross@android.com>
Date:   Fri Sep 3 01:24:07 2010 +0200

    PM: Prevent waiting forever on asynchronous resume after failing suspend
    
    commit 152e1d592071c8b312bb898bc1118b64e4aea535 upstream.
    
    During suspend, the power.completion is expected to be set when a
    device has not yet started suspending.  Set it on init to fix a
    corner case where a device is resumed when its parent has never
    suspended.
    
    Consider three drivers, A, B, and C.  The parent of A is C, and C
    has async_suspend set.  On boot, C->power.completion is initialized
    to 0.
    
    During the first suspend:
    suspend_devices_and_enter(...)
     dpm_resume(...)
      device_suspend(A)
      device_suspend(B) returns error, aborts suspend
     dpm_resume_end(...)
       dpm_resume(...)
        device_resume(A)
         dpm_wait(A->parent == C)
          wait_for_completion(C->power.completion)
    
    The wait_for_completion will never complete, because
    complete_all(C->power.completion) will only be called from
    device_suspend(C) or device_resume(C), neither of which is called
    if suspend is aborted before C.
    
    After a successful suspend->resume cycle, where B doesn't abort
    suspend, C->power.completion is left in the completed state by the
    call to device_resume(C), and the same call path will work if B
    aborts suspend.
    
    Signed-off-by: Colin Cross <ccross@android.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 152e1d592071c8b312bb898bc1118b64e4aea535
Author: Colin Cross <ccross@android.com>
Date:   Fri Sep 3 01:24:07 2010 +0200

    PM: Prevent waiting forever on asynchronous resume after failing suspend
    
    During suspend, the power.completion is expected to be set when a
    device has not yet started suspending.  Set it on init to fix a
    corner case where a device is resumed when its parent has never
    suspended.
    
    Consider three drivers, A, B, and C.  The parent of A is C, and C
    has async_suspend set.  On boot, C->power.completion is initialized
    to 0.
    
    During the first suspend:
    suspend_devices_and_enter(...)
     dpm_resume(...)
      device_suspend(A)
      device_suspend(B) returns error, aborts suspend
     dpm_resume_end(...)
       dpm_resume(...)
        device_resume(A)
         dpm_wait(A->parent == C)
          wait_for_completion(C->power.completion)
    
    The wait_for_completion will never complete, because
    complete_all(C->power.completion) will only be called from
    device_suspend(C) or device_resume(C), neither of which is called
    if suspend is aborted before C.
    
    After a successful suspend->resume cycle, where B doesn't abort
    suspend, C->power.completion is left in the completed state by the
    call to device_resume(C), and the same call path will work if B
    aborts suspend.
    
    Signed-off-by: Colin Cross <ccross@android.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

commit f6f71f187518477cecc01cd887933b5da19585e6
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Jul 7 23:43:18 2010 +0200

    PM / Hibernate: Fix hibernation_platform_enter()
    
    The hibernation_platform_enter() function calls dpm_suspend_noirq()
    instead of dpm_resume_noirq() by mistake.  Fix this.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Len Brown <len.brown@intel.com>

commit a111c28a5d47bc15ed6b644a0b7c69d748c1bdb2
Author: Ian Campbell <ian.campbell@citrix.com>
Date:   Thu Dec 17 13:57:09 2009 +0000

    xen: fix hang on suspend.
    
    commit c5cae661d6cf808b6984762f763261adf35f3eb7 upstream.
    
    In 65f63384 "xen: improve error handling in do_suspend" I said:
        - xs_suspend()/xs_resume() and dpm_suspend_noirq()/dpm_resume_noirq() were not
          nested in the obvious way.
    and changed the ordering of the calls as so:
        BEFORE              AFTER
        xs_suspend          dpm_suspend_noirq
        dpm_suspend_noirq   xs_suspend
        *SUSPEND*           *SUSPEND*
        dpm_resume_noirq    dpm_resume_noirq
        xs_resume           xs_resume
    Clearly this is not an improvement and I was talking rubbish.
    
    In particular the new ordering is susceptible to a hang if a xenstore write is
    in progress at the point at which the suspend kicks in. When the suspend
    process calls xs_suspend it tries to take the request_mutex but if a write is
    in progress it could be looping in xenbus_xs.c:read_reply() waiting for
    something to arrive on &xs_state.reply_list while holding the request_mutex
    (taken in the caller of read_reply).
    
    However if we have done dpm_suspend_noirq before xs_suspend then we won't get
    any more xenstore interrupts and process_msg() will never be woken up to add
    anything to the reply_list.
    
    Fix this by calling xs_suspend before dpm_suspend_noirq. If dpm_suspend_noirq
    fails then make sure we go through the xs_suspend_cancel() code path.
    
    Signed-off-by: Ian Campbell <ian.campbell@citrix.com>
    Acked-by: Jeremy Fitzhardinge <jeremy.fitzhardinge@citrix.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit c5cae661d6cf808b6984762f763261adf35f3eb7
Author: Ian Campbell <ian.campbell@citrix.com>
Date:   Thu Dec 17 13:57:09 2009 +0000

    xen: fix hang on suspend.
    
    In 65f63384 "xen: improve error handling in do_suspend" I said:
        - xs_suspend()/xs_resume() and dpm_suspend_noirq()/dpm_resume_noirq() were not
          nested in the obvious way.
    and changed the ordering of the calls as so:
        BEFORE              AFTER
        xs_suspend          dpm_suspend_noirq
        dpm_suspend_noirq   xs_suspend
        *SUSPEND*           *SUSPEND*
        dpm_resume_noirq    dpm_resume_noirq
        xs_resume           xs_resume
    Clearly this is not an improvement and I was talking rubbish.
    
    In particular the new ordering is susceptible to a hang if a xenstore write is
    in progress at the point at which the suspend kicks in. When the suspend
    process calls xs_suspend it tries to take the request_mutex but if a write is
    in progress it could be looping in xenbus_xs.c:read_reply() waiting for
    something to arrive on &xs_state.reply_list while holding the request_mutex
    (taken in the caller of read_reply).
    
    However if we have done dpm_suspend_noirq before xs_suspend then we won't get
    any more xenstore interrupts and process_msg() will never be woken up to add
    anything to the reply_list.
    
    Fix this by calling xs_suspend before dpm_suspend_noirq. If dpm_suspend_noirq
    fails then make sure we go through the xs_suspend_cancel() code path.
    
    Signed-off-by: Ian Campbell <ian.campbell@citrix.com>
    Acked-by: Jeremy Fitzhardinge <jeremy.fitzhardinge@citrix.com>
    Cc: Stable Kernel <stable@kernel.org>

commit 9ea8d05932c082a7ccbd9dc2e10687c88a70bd13
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Mon Jan 4 18:57:56 2010 +0000

    drm/i915: Hold struct mutex whilst pinning power context bo.
    
    Hugh found an error path where we were attempting to unref a bo without
    holding the struct mutex:
    
      [drm:intel_init_clock_gating] *ERROR* failed to pin power context: -16
      ------------[ cut here ]------------
      WARNING: at drivers/gpu/drm/drm_gem.c:438 drm_gem_object_free+0x20/0x5e()
      Hardware name: ESPRIMO Mobile V5505
      Modules linked in: snd_pcm_oss snd_mixer_oss snd_seq snd_seq_device
      Pid: 3793, comm: s2ram Not tainted 2.6.33-rc2 #4
      Call Trace:
       [<7815298e>] warn_slowpath_common+0x59/0x6b
       [<781529b3>] warn_slowpath_null+0x13/0x18
       [<78317c1a>] ? drm_gem_object_free+0x20/0x5e
       [<78317c1a>] drm_gem_object_free+0x20/0x5e
       [<78317bfa>] ? drm_gem_object_free+0x0/0x5e
       [<7829df11>] kref_put+0x38/0x45
       [<7833a5f0>] intel_init_clock_gating+0x232/0x271
       [<78317bfa>] ? drm_gem_object_free+0x0/0x5e
       [<7832c307>] i915_restore_state+0x21a/0x2b3
       [<7832379d>] i915_resume+0x3c/0xbb
       [<78174fe5>] ? trace_hardirqs_on_caller+0xfc/0x123
       [<7831c756>] ? drm_class_resume+0x0/0x3e
       [<7831c78d>] drm_class_resume+0x37/0x3e
       [<78351e0a>] legacy_resume+0x1e/0x51
       [<78351ece>] device_resume+0x91/0xab
       [<7831c756>] ? drm_class_resume+0x0/0x3e
       [<78352226>] dpm_resume+0x58/0x10f
       [<783522fb>] dpm_resume_end+0x1e/0x2c
       [<78180f80>] suspend_devices_and_enter+0x61/0x84
       [<78180ff8>] enter_state+0x55/0x83
       [<7818091c>] state_store+0x94/0xaa
       [<7829d09e>] kobj_attr_store+0x1e/0x23
       [<782098e0>] sysfs_write_file+0x66/0x99
       [<781cd2f0>] vfs_write+0x8a/0x108
       [<781cd408>] sys_write+0x3c/0x63
       [<78125c10>] sysenter_do_call+0x12/0x36
      ---[ end trace a343537f29950fda ]---
    
    It is in fact slightly more insiduous that first appears since we are
    attempting to not just free the object without the lock, but are trying
    to do the whole bo manipulation without holding the lock.
    
    Reported-by: Hugh Dickins <hugh.dickins@tiscali.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: stable@kernel.org
    Signed-off-by: Eric Anholt <eric@anholt.net>

commit f180b871d6cbcaaf9349075afb515081de073acb
Author: Ian Campbell <ian.campbell@citrix.com>
Date:   Tue Dec 1 11:47:14 2009 +0000

    xen: improve error handling in do_suspend.
    
    commit 65f63384b391bf4d384327d8a7c6de9860290b5c upstream.
    
    The existing error handling has a few issues:
    - If freeze_processes() fails it exits with shutting_down = SHUTDOWN_SUSPEND.
    - If dpm_suspend_noirq() fails it exits without resuming xenbus.
    - If stop_machine() fails it exits without resuming xenbus or calling
      dpm_resume_end().
    - xs_suspend()/xs_resume() and dpm_suspend_noirq()/dpm_resume_noirq() were not
      nested in the obvious way.
    
    Fix by ensuring each failure case goto's the correct label. Treat a failure of
    stop_machine() as a cancelled suspend in order to follow the correct resume
    path.
    
    Signed-off-by: Ian Campbell <ian.campbell@citrix.com>
    Signed-off-by: Jeremy Fitzhardinge <jeremy.fitzhardinge@citrix.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 8fd7520c678cc3d8af422bca9f22149731520f1b
Author: Jeremy Fitzhardinge <jeremy.fitzhardinge@citrix.com>
Date:   Tue Nov 24 09:58:49 2009 -0800

    xen: don't call dpm_resume_noirq() with interrupts disabled.
    
    commit 922cc38ab71d1360978e65207e4a4f4988987127 upstream.
    
    dpm_resume_noirq() takes a mutex, so it can't be called from a no-interrupt
    context.  Don't call it from within the stop-machine function, but just
    afterwards, since we're resuming anyway, regardless of what happened.
    
    Signed-off-by: Jeremy Fitzhardinge <jeremy.fitzhardinge@citrix.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit ab1831b0b87851c874a75e4b3a8538e3d76b37d7
Merge: eae6fa9b0c3e bc2c0303226e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Dec 10 09:35:02 2009 -0800

    Merge branch 'bugfix' of git://git.kernel.org/pub/scm/linux/kernel/git/jeremy/xen
    
    * 'bugfix' of git://git.kernel.org/pub/scm/linux/kernel/git/jeremy/xen:
      xen: try harder to balloon up under memory pressure.
      Xen balloon: fix totalram_pages counting.
      xen: explicitly create/destroy stop_machine workqueues outside suspend/resume region.
      xen: improve error handling in do_suspend.
      xen: don't leak IRQs over suspend/resume.
      xen: call clock resume notifier on all CPUs
      xen: use iret for return from 64b kernel to 32b usermode
      xen: don't call dpm_resume_noirq() with interrupts disabled.
      xen: register runstate info for boot CPU early
      xen: register runstate on secondary CPUs
      xen: register timer interrupt with IRQF_TIMER
      xen: correctly restore pfn_to_mfn_list_list after resume
      xen: restore runstate_info even if !have_vcpu_info_placement
      xen: re-register runstate area earlier on resume.
      xen: wait up to 5 minutes for device connetion
      xen: improvement to wait_for_devices()
      xen: fix is_disconnected_device/exists_disconnected_device
      xen/xenbus: make DEVICE_ATTR()s static

commit 65f63384b391bf4d384327d8a7c6de9860290b5c
Author: Ian Campbell <ian.campbell@citrix.com>
Date:   Tue Dec 1 11:47:14 2009 +0000

    xen: improve error handling in do_suspend.
    
    The existing error handling has a few issues:
    - If freeze_processes() fails it exits with shutting_down = SHUTDOWN_SUSPEND.
    - If dpm_suspend_noirq() fails it exits without resuming xenbus.
    - If stop_machine() fails it exits without resuming xenbus or calling
      dpm_resume_end().
    - xs_suspend()/xs_resume() and dpm_suspend_noirq()/dpm_resume_noirq() were not
      nested in the obvious way.
    
    Fix by ensuring each failure case goto's the correct label. Treat a failure of
    stop_machine() as a cancelled suspend in order to follow the correct resume
    path.
    
    Signed-off-by: Ian Campbell <ian.campbell@citrix.com>
    Signed-off-by: Jeremy Fitzhardinge <jeremy.fitzhardinge@citrix.com>
    Cc: Stable Kernel <stable@kernel.org>

commit 922cc38ab71d1360978e65207e4a4f4988987127
Author: Jeremy Fitzhardinge <jeremy.fitzhardinge@citrix.com>
Date:   Tue Nov 24 09:58:49 2009 -0800

    xen: don't call dpm_resume_noirq() with interrupts disabled.
    
    dpm_resume_noirq() takes a mutex, so it can't be called from a no-interrupt
    context.  Don't call it from within the stop-machine function, but just
    afterwards, since we're resuming anyway, regardless of what happened.
    
    Signed-off-by: Jeremy Fitzhardinge <jeremy.fitzhardinge@citrix.com>
    Cc: Stable Kernel <stable@kernel.org>

commit 4406c56d0a4da7a37b9180abeaece6cd00bcc874
Merge: 6b7b352f2102 5e3573db2bd5
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Sep 16 07:49:54 2009 -0700

    Merge branch 'linux-next' of git://git.kernel.org/pub/scm/linux/kernel/git/jbarnes/pci-2.6
    
    * 'linux-next' of git://git.kernel.org/pub/scm/linux/kernel/git/jbarnes/pci-2.6: (75 commits)
      PCI hotplug: clean up acpi_run_hpp()
      PCI hotplug: acpiphp: use generic pci_configure_slot()
      PCI hotplug: shpchp: use generic pci_configure_slot()
      PCI hotplug: pciehp: use generic pci_configure_slot()
      PCI hotplug: add pci_configure_slot()
      PCI hotplug: clean up acpi_get_hp_params_from_firmware() interface
      PCI hotplug: acpiphp: don't cache hotplug_params in acpiphp_bridge
      PCI hotplug: acpiphp: remove superfluous _HPP/_HPX evaluation
      PCI: Clear saved_state after the state has been restored
      PCI PM: Return error codes from pci_pm_resume()
      PCI: use dev_printk in quirk messages
      PCI / PCIe portdrv: Fix pcie_portdrv_slot_reset()
      PCI Hotplug: convert acpi_pci_detect_ejectable() to take an acpi_handle
      PCI Hotplug: acpiphp: find bridges the easy way
      PCI: pcie portdrv: remove unused variable
      PCI / ACPI PM: Propagate wake-up enable for devices w/o ACPI support
      ACPI PM: Replace wakeup.prepared with reference counter
      PCI PM: Introduce device flag wakeup_prepared
      PCI / ACPI PM: Rework some debug messages
      PCI PM: Simplify PCI wake-up code
      ...
    
    Fixed up conflict in arch/powerpc/kernel/pci_64.c due to OF device tree
    scanning having been moved and merged for the 32- and 64-bit cases.  The
    'needs_freset' initialization added in 6e19314cc ("PCI/powerpc: support
    PCIe fundamental reset") is now in arch/powerpc/kernel/pci_of_scan.c.

commit f86054c24565d09d1997f03192761dabf6b8a9c9
Merge: c91d7d54ea9e 33f82d141c89
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Sep 14 20:03:54 2009 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/suspend-2.6
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/suspend-2.6: (23 commits)
      at_hdmac: Rework suspend_late()/resume_early()
      PM: Reset transition_started at dpm_resume_noirq
      PM: Update kerneldoc comments in drivers/base/power/main.c
      PM: Add convenience macro to make switching to dev_pm_ops less error-prone
      hp-wmi: Switch driver to dev_pm_ops
      floppy: Switch driver to dev_pm_ops
      PM: Trivial fixes
      PM / Hibernate / Memory hotplug: Always use for_each_populated_zone()
      PM/Hibernate: Do not try to allocate too much memory too hard (rev. 2)
      PM/Hibernate: Do not release preallocated memory unnecessarily (rev. 2)
      PM/Hibernate: Rework shrinking of memory
      PM: Fix typo in label name s/Platofrm_finish/Platform_finish/
      PM: Run-time PM platform device bus support
      PM: Introduce core framework for run-time PM of I/O devices (rev. 17)
      Driver Core: Make PM operations a const pointer
      PM: Remove platform device suspend_late()/resume_early() V2
      USB: Rework musb suspend()/resume_early()
      I2C: Rework i2c-s3c2410 suspend_late()/resume() V2
      I2C: Rework i2c-pxa suspend_late()/resume_early()
      DMA: Rework txx9dmac suspend_late()/resume_early()
      ...
    
    Fix trivial conflict in drivers/base/platform.c (due to same
    constification patch being merged in both sides, along with some other
    PM work in the PM branch)

commit 999cce4a52d5abdda5d2cec6bac241899bc19e4c
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Sep 9 23:51:27 2009 +0200

    PCI PM: Return error codes from pci_pm_resume()
    
    Currently pci_pm_resume() always returns 0, which makes the error
    variable defined in there a bit pointless.  Make pci_pm_resume()
    return error codes obtained from drivers' callbacks.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

commit 3eb132c986f04f64b9c360abd67a1e0d18d6d5b4
Author: Xiaotian Feng <dfeng@redhat.com>
Date:   Thu Aug 20 20:28:33 2009 +0200

    PM: Reset transition_started at dpm_resume_noirq
    
    transition_started should be set once the preparation of devices for
    a PM has started, reset before starting to resume devices. When
    resuming devices, kernel calls dpm_resume_noirq then
    dpm_resume_end(dpm_resume).  Thus we should reset transition_started
    at dpm_resume_noirq.
    
    This patch fixes ACPI warning when resuming from suspend/hibernate:
    
    ACPI: \_SB_.PCI0.IDE1.PRI1.MAS1 - docking
    ------------[ cut here ]------------
    WARNING: at drivers/base/power/main.c:87 device_pm_add+0x8b/0xcc()
    Hardware name: OptiPlex 760
    Device: acpi
    Parentless device registered during a PM transaction
    
    [rjw: Fixed up the changelog.]
    
    Signed-off-by: Xiaotian Feng <dfeng@redhat.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

commit d161630297a20802d01c55847bfcba85d2118a9f
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Sun May 24 22:05:42 2009 +0200

    PM core: rename suspend and resume functions
    
    This patch (as1241) renames a bunch of functions in the PM core.
    Rather than go through a boring list of name changes, suffice it to
    say that in the end we have a bunch of pairs of functions:
    
            device_resume_noirq     dpm_resume_noirq
            device_resume           dpm_resume
            device_complete         dpm_complete
            device_suspend_noirq    dpm_suspend_noirq
            device_suspend          dpm_suspend
            device_prepare          dpm_prepare
    
    in which device_X does the X operation on a single device and dpm_X
    invokes device_X for all devices in the dpm_list.
    
    In addition, the old dpm_power_up and device_resume_noirq have been
    combined into a single function (dpm_resume_noirq).
    
    Lastly, dpm_suspend_start and dpm_resume_end are the renamed versions
    of the former top-level device_suspend and device_resume routines.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Magnus Damm <damm@igel.co.jp>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

commit 418e4da33f45fd7bdcce48778b149b780ff730bc
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Jan 26 21:43:08 2009 +0100

    PCI PM: Fix suspend error paths and testing facility breakage
    
    If one of device drivers refuses to suspend by returning error code
    from its ->suspend() callback, the devices that have already been
    suspended are resumed by executing their drivers' ->resume()
    callbacks.  Some of these callbacks expect the device's
    configuration space to be restored if the device has been put into
    D3 before they are called.  Unfortunately, this mechanism has been
    broken by recent changes moving the restoration of config spaces
    of some devices (most importantly, USB controllers and HDA Intel)
    into the resume callbacks executed with interrupts off.  Obviously,
    these callbacks are not invoked in the suspend error path and, as a
    result, the system cannot be successfully brought back into the
    working state in case of a suspend error.  The same thing happens
    in the hibernation error path right before putting the system into
    S4.
    
    Similarly, the suspend testing facility associated with the
    /sys/power/pm_test file is broken, because it uses the very same
    mechanism that is used in the suspend and hibernation error paths.
    
    Fix the breakage by making the PCI core restore the configuration
    spaces of PCI devices that haven't been restored already before
    pci_pm_resume() is called for those devices by the PM core.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

commit 9a2d43b7566caeeeb414aa628bc2759028897dbb
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Tue Jul 15 21:21:43 2008 +0200

    block: handle blk_pm_resume_request() requests in blk_execute_rq_nowait()
    
    For blk_pm_resume_request() requests (which are used only by IDE subsystem
    currently) the queue is stopped so we need to call ->request_fn explicitly.
    
    Thanks to:
    - Rafael for reporting/bisecting the bug
    - Borislav/Rafael for testing the fix
    
    This is a preparation for converting IDE to use blk_execute_rq().
    
    Cc: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
    Cc: Borislav Petkov <petkovbb@gmail.com>
    Cc: Jens Axboe <jens.axboe@oracle.com>
    Cc: "Rafael J. Wysocki" <rjw@sisk.pl>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

commit c6866a6ff571eebebda45bf14b5b62188768893a
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Tue Jul 15 21:21:42 2008 +0200

    ide: use __generic_unplug_device() in ide_do_drive_cmd() (take 2)
    
    * Call __elv_add_request() with 'plug' == 1 (so the device will be
      plugged) and then use __generic_unplug_device() instead of calling
      ide_do_request() directly.
    
    v2:
    * For blk_pm_resume_request() requests the queue is stopped so we
      need to call ->request_fn explicitly.
    
      Thanks to:
      - Rafael for reporting/bisecting the bug
      - Borislav/Rafael for testing the fix
    
    This is a preparation for converting IDE to use blk_execute_rq().
    
    Cc: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
    Cc: Borislav Petkov <petkovbb@gmail.com>
    Cc: Jens Axboe <jens.axboe@oracle.com>
    Cc: "Rafael J. Wysocki" <rjw@sisk.pl>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

commit e6364cd3a1a3e7c3e9a80bad15698afe6cc7ee75
Merge: b8967d8883aa 120fc3d77acf
Author: Linus Torvalds <torvalds@woody.linux-foundation.org>
Date:   Thu Feb 21 16:21:52 2008 -0800

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-2.6
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-2.6:
      modules: do not try to add sysfs attributes if !CONFIG_SYSFS
      POWERPC: fix typo in pseries/power.c
      PM: Remove unbalanced mutex_unlock() from dpm_resume()
      UIO: fix Greg's stupid changes
      stable_kernel_rules: fix must already be in mainline
      ide: mark "ide=reverse" option as obsolete
      Driver core: Fix error handling in bus_add_driver().
      driver-core: fix kernel-doc function parameters
      cpufreq: fix kobject reference count handling
      slabinfo: fall back from /sys/kernel/slab to /sys/slab
      Fix broken utf-8 encodings in ja_JP translation of stable_kernel_rules.txt

commit ec5a42465abc585a7f8117be5eecc361490e48ce
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Feb 20 02:01:41 2008 +0100

    PM: Remove unbalanced mutex_unlock() from dpm_resume()
    
    Remove an unnecessary unlocking of dpm_list_mtx in the error path
    in drivers/base/power/main.c:dpm_suspend() .
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit eb2112fbcf2d97eda221790bd53cb3a2cdf58c95
Merge: f238085415c5 618b20a13e9e
Author: Linus Torvalds <torvalds@woody.osdl.org>
Date:   Wed Dec 20 23:54:23 2006 -0800

    Merge branch 'for-linus' of master.kernel.org:/home/rmk/linux-2.6-arm
    
    * 'for-linus' of master.kernel.org:/home/rmk/linux-2.6-arm: (29 commits)
      [ARM] 4062/1: S3C24XX: Anubis and Osiris shuld have CONFIG_PM_SIMTEC
      [ARM] 4060/1: update several ARM defconfigs
      [ARM] 4061/1: xsc3: change of maintainer
      [ARM] 4059/1: VR1000: fix LED3's platform device number
      [ARM] 4022/1: iop13xx: generic irq fixups
      [ARM] 4015/1: s3c2410 cpu ifdefs
      [ARM] 4057/1: ixp23xx: unconditionally enable hardware coherency
      [ARM] 4056/1: iop13xx: fix resource.end off-by-one in flash setup
      [ARM] 4055/1: iop13xx: fix phys_io/io_pg_offst for iq81340mc/sc
      [ARM] 4054/1: ep93xx: add HWCAP_CRUNCH
      [ARM] 4052/1: S3C24XX: Fix PM in arch/arm/mach-s3c2410/Kconfig
      [ARM] Fix warnings from asm/system.h
      [ARM] 4051/1: S3C24XX: clean includes in S3C2440 and S3C2442 support
      [ARM] 4050/1: S3C24XX: remove old changelogs in arch/arm/mach-s3c2410
      [ARM] 4049/1: S3C24XX: fix sparse warning due to upf_t in regs-serial.h
      [ARM] 4048/1: S3C24XX: make s3c2410_pm_resume() static
      [ARM] 4046/1: S3C24XX: fix sparse errors arch/arm/mach-s3c2410
      [ARM] 4045/1: S3C24XX: remove old VA for non-shared areas
      [ARM] 4044/1: S3C24XX: fix sparse warnings in arch/arm/mach-s3c2410/s3c2442-clock.c
      [ARM] 4043/1: S3C24XX: fix sparse warnings in arch/arm/mach-s3c2410/s3c2440-clock.c
      ...

commit 9162b7dbf5652a4ae99980235cd8992223258408
Author: Ben Dooks <ben-linux@fluff.org>
Date:   Sun Dec 17 22:44:56 2006 +0100

    [ARM] 4048/1: S3C24XX: make s3c2410_pm_resume() static
    
    Remove warning from s3c2410_pm_resume() not being
    declared by making it static.
    
    Signed-off-by: Ben Dooks <ben-linux@fluff.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
