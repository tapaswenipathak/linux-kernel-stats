commit 3cdd91a9163248935720927531066b74f57aa43b
Author: Yongqiang Liu <liuyongqiang13@huawei.com>
Date:   Thu Nov 10 14:23:07 2022 +0000

    cpufreq: Init completion before kobject_init_and_add()
    
    commit 5c51054896bcce1d33d39fead2af73fec24f40b6 upstream.
    
    In cpufreq_policy_alloc(), it will call uninitialed completion in
    cpufreq_sysfs_release() when kobject_init_and_add() fails. And
    that will cause a crash such as the following page fault in complete:
    
    BUG: unable to handle page fault for address: fffffffffffffff8
    [..]
    RIP: 0010:complete+0x98/0x1f0
    [..]
    Call Trace:
     kobject_put+0x1be/0x4c0
     cpufreq_online.cold+0xee/0x1fd
     cpufreq_add_dev+0x183/0x1e0
     subsys_interface_register+0x3f5/0x4e0
     cpufreq_register_driver+0x3b7/0x670
     acpi_cpufreq_init+0x56c/0x1000 [acpi_cpufreq]
     do_one_initcall+0x13d/0x780
     do_init_module+0x1c3/0x630
     load_module+0x6e67/0x73b0
     __do_sys_finit_module+0x181/0x240
     do_syscall_64+0x35/0x80
     entry_SYSCALL_64_after_hwframe+0x63/0xcd
    
    Fixes: 4ebe36c94aed ("cpufreq: Fix kobject memleak")
    Signed-off-by: Yongqiang Liu <liuyongqiang13@huawei.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Cc: 5.2+ <stable@vger.kernel.org> # 5.2+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit e379b88a8f8cffc99b318e028705ed9e3da0e1e0
Author: Yongqiang Liu <liuyongqiang13@huawei.com>
Date:   Thu Nov 10 14:23:07 2022 +0000

    cpufreq: Init completion before kobject_init_and_add()
    
    commit 5c51054896bcce1d33d39fead2af73fec24f40b6 upstream.
    
    In cpufreq_policy_alloc(), it will call uninitialed completion in
    cpufreq_sysfs_release() when kobject_init_and_add() fails. And
    that will cause a crash such as the following page fault in complete:
    
    BUG: unable to handle page fault for address: fffffffffffffff8
    [..]
    RIP: 0010:complete+0x98/0x1f0
    [..]
    Call Trace:
     kobject_put+0x1be/0x4c0
     cpufreq_online.cold+0xee/0x1fd
     cpufreq_add_dev+0x183/0x1e0
     subsys_interface_register+0x3f5/0x4e0
     cpufreq_register_driver+0x3b7/0x670
     acpi_cpufreq_init+0x56c/0x1000 [acpi_cpufreq]
     do_one_initcall+0x13d/0x780
     do_init_module+0x1c3/0x630
     load_module+0x6e67/0x73b0
     __do_sys_finit_module+0x181/0x240
     do_syscall_64+0x35/0x80
     entry_SYSCALL_64_after_hwframe+0x63/0xcd
    
    Fixes: 4ebe36c94aed ("cpufreq: Fix kobject memleak")
    Signed-off-by: Yongqiang Liu <liuyongqiang13@huawei.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Cc: 5.2+ <stable@vger.kernel.org> # 5.2+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 8fb4c98f20dfca1237de2e3dfdbe78d156784fd3
Author: Yongqiang Liu <liuyongqiang13@huawei.com>
Date:   Thu Nov 10 14:23:07 2022 +0000

    cpufreq: Init completion before kobject_init_and_add()
    
    commit 5c51054896bcce1d33d39fead2af73fec24f40b6 upstream.
    
    In cpufreq_policy_alloc(), it will call uninitialed completion in
    cpufreq_sysfs_release() when kobject_init_and_add() fails. And
    that will cause a crash such as the following page fault in complete:
    
    BUG: unable to handle page fault for address: fffffffffffffff8
    [..]
    RIP: 0010:complete+0x98/0x1f0
    [..]
    Call Trace:
     kobject_put+0x1be/0x4c0
     cpufreq_online.cold+0xee/0x1fd
     cpufreq_add_dev+0x183/0x1e0
     subsys_interface_register+0x3f5/0x4e0
     cpufreq_register_driver+0x3b7/0x670
     acpi_cpufreq_init+0x56c/0x1000 [acpi_cpufreq]
     do_one_initcall+0x13d/0x780
     do_init_module+0x1c3/0x630
     load_module+0x6e67/0x73b0
     __do_sys_finit_module+0x181/0x240
     do_syscall_64+0x35/0x80
     entry_SYSCALL_64_after_hwframe+0x63/0xcd
    
    Fixes: 4ebe36c94aed ("cpufreq: Fix kobject memleak")
    Signed-off-by: Yongqiang Liu <liuyongqiang13@huawei.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Cc: 5.2+ <stable@vger.kernel.org> # 5.2+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit d88540acfc7a17079021d866de914112c396edb1
Author: Yongqiang Liu <liuyongqiang13@huawei.com>
Date:   Thu Nov 10 14:23:07 2022 +0000

    cpufreq: Init completion before kobject_init_and_add()
    
    commit 5c51054896bcce1d33d39fead2af73fec24f40b6 upstream.
    
    In cpufreq_policy_alloc(), it will call uninitialed completion in
    cpufreq_sysfs_release() when kobject_init_and_add() fails. And
    that will cause a crash such as the following page fault in complete:
    
    BUG: unable to handle page fault for address: fffffffffffffff8
    [..]
    RIP: 0010:complete+0x98/0x1f0
    [..]
    Call Trace:
     kobject_put+0x1be/0x4c0
     cpufreq_online.cold+0xee/0x1fd
     cpufreq_add_dev+0x183/0x1e0
     subsys_interface_register+0x3f5/0x4e0
     cpufreq_register_driver+0x3b7/0x670
     acpi_cpufreq_init+0x56c/0x1000 [acpi_cpufreq]
     do_one_initcall+0x13d/0x780
     do_init_module+0x1c3/0x630
     load_module+0x6e67/0x73b0
     __do_sys_finit_module+0x181/0x240
     do_syscall_64+0x35/0x80
     entry_SYSCALL_64_after_hwframe+0x63/0xcd
    
    Fixes: 4ebe36c94aed ("cpufreq: Fix kobject memleak")
    Signed-off-by: Yongqiang Liu <liuyongqiang13@huawei.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Cc: 5.2+ <stable@vger.kernel.org> # 5.2+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit e7c0c943ed675b66d4bbb16c51c6a3bb58da047e
Author: Yongqiang Liu <liuyongqiang13@huawei.com>
Date:   Thu Nov 10 14:23:07 2022 +0000

    cpufreq: Init completion before kobject_init_and_add()
    
    commit 5c51054896bcce1d33d39fead2af73fec24f40b6 upstream.
    
    In cpufreq_policy_alloc(), it will call uninitialed completion in
    cpufreq_sysfs_release() when kobject_init_and_add() fails. And
    that will cause a crash such as the following page fault in complete:
    
    BUG: unable to handle page fault for address: fffffffffffffff8
    [..]
    RIP: 0010:complete+0x98/0x1f0
    [..]
    Call Trace:
     kobject_put+0x1be/0x4c0
     cpufreq_online.cold+0xee/0x1fd
     cpufreq_add_dev+0x183/0x1e0
     subsys_interface_register+0x3f5/0x4e0
     cpufreq_register_driver+0x3b7/0x670
     acpi_cpufreq_init+0x56c/0x1000 [acpi_cpufreq]
     do_one_initcall+0x13d/0x780
     do_init_module+0x1c3/0x630
     load_module+0x6e67/0x73b0
     __do_sys_finit_module+0x181/0x240
     do_syscall_64+0x35/0x80
     entry_SYSCALL_64_after_hwframe+0x63/0xcd
    
    Fixes: 4ebe36c94aed ("cpufreq: Fix kobject memleak")
    Signed-off-by: Yongqiang Liu <liuyongqiang13@huawei.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Cc: 5.2+ <stable@vger.kernel.org> # 5.2+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 5c51054896bcce1d33d39fead2af73fec24f40b6
Author: Yongqiang Liu <liuyongqiang13@huawei.com>
Date:   Thu Nov 10 14:23:07 2022 +0000

    cpufreq: Init completion before kobject_init_and_add()
    
    In cpufreq_policy_alloc(), it will call uninitialed completion in
    cpufreq_sysfs_release() when kobject_init_and_add() fails. And
    that will cause a crash such as the following page fault in complete:
    
    BUG: unable to handle page fault for address: fffffffffffffff8
    [..]
    RIP: 0010:complete+0x98/0x1f0
    [..]
    Call Trace:
     kobject_put+0x1be/0x4c0
     cpufreq_online.cold+0xee/0x1fd
     cpufreq_add_dev+0x183/0x1e0
     subsys_interface_register+0x3f5/0x4e0
     cpufreq_register_driver+0x3b7/0x670
     acpi_cpufreq_init+0x56c/0x1000 [acpi_cpufreq]
     do_one_initcall+0x13d/0x780
     do_init_module+0x1c3/0x630
     load_module+0x6e67/0x73b0
     __do_sys_finit_module+0x181/0x240
     do_syscall_64+0x35/0x80
     entry_SYSCALL_64_after_hwframe+0x63/0xcd
    
    Fixes: 4ebe36c94aed ("cpufreq: Fix kobject memleak")
    Signed-off-by: Yongqiang Liu <liuyongqiang13@huawei.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Cc: 5.2+ <stable@vger.kernel.org> # 5.2+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 13fdbc8b8da6a2325cad3359c9a70504b0ff2f93
Author: Stuart Hayes <stuart.w.hayes@gmail.com>
Date:   Wed Nov 2 14:59:57 2022 -0500

    cpufreq: ACPI: Defer setting boost MSRs
    
    When acpi-cpufreq is loaded, boost is enabled on every CPU (by setting an
    MSR) before the driver is registered with cpufreq.  This can be very time
    consuming, because it is done with a CPU hotplug startup callback, and
    cpuhp_setup_state() schedules the callback (cpufreq_boost_online()) to run
    on each CPU one at a time, waiting for each to run before calling the next.
    
    If cpufreq_register_driver() fails--if, for example, there are no ACPI
    P-states present--this is wasted time.
    
    Since cpufreq already sets up a CPU hotplug startup callback if and when
    acpi-cpufreq is registered, set the boost MSRs in acpi_cpufreq_cpu_init(),
    which is called by the cpufreq cpuhp callback.  This allows acpi-cpufreq to
    exit quickly if it is loaded but not needed.
    
    On one system with 192 CPUs, this patch speeds up boot by about 30 seconds.
    
    Signed-off-by: Stuart Hayes <stuart.w.hayes@gmail.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit cd3da578f98f4ada35889df6fe8addee96bc4997
Author: Chen-Yu Tsai <wenst@chromium.org>
Date:   Wed Aug 25 11:37:04 2021 +0800

    regulator: vctrl: Avoid lockdep warning in enable/disable ops
    
    [ Upstream commit 21e39809fd7c4b8ff3662f23e0168e87594c8ca8 ]
    
    vctrl_enable() and vctrl_disable() call regulator_enable() and
    regulator_disable(), respectively. However, vctrl_* are regulator ops
    and should not be calling the locked regulator APIs. Doing so results in
    a lockdep warning.
    
    Instead of exporting more internal regulator ops, model the ctrl supply
    as an actual supply to vctrl-regulator. At probe time this driver still
    needs to use the consumer API to fetch its constraints, but otherwise
    lets the regulator core handle the upstream supply for it.
    
    The enable/disable/is_enabled ops are not removed, but now only track
    state internally. This preserves the original behavior with the ops
    being available, but one could argue that the original behavior was
    already incorrect: the internal state would not match the upstream
    supply if that supply had another consumer that enabled the supply,
    while vctrl-regulator was not enabled.
    
    The lockdep warning is as follows:
    
            WARNING: possible circular locking dependency detected
            5.14.0-rc6 #2 Not tainted
            ------------------------------------------------------
            swapper/0/1 is trying to acquire lock:
            ffffffc011306d00 (regulator_list_mutex){+.+.}-{3:3}, at:
                    regulator_lock_dependent (arch/arm64/include/asm/current.h:19
                                              include/linux/ww_mutex.h:111
                                              drivers/regulator/core.c:329)
    
            but task is already holding lock:
            ffffff8004a77160 (regulator_ww_class_mutex){+.+.}-{3:3}, at:
                    regulator_lock_recursive (drivers/regulator/core.c:156
                                              drivers/regulator/core.c:263)
    
            which lock already depends on the new lock.
    
            the existing dependency chain (in reverse order) is:
    
            -> #2 (regulator_ww_class_mutex){+.+.}-{3:3}:
            __mutex_lock_common (include/asm-generic/atomic-instrumented.h:606
                                 include/asm-generic/atomic-long.h:29
                                 kernel/locking/mutex.c:103
                                 kernel/locking/mutex.c:144
                                 kernel/locking/mutex.c:963)
            ww_mutex_lock (kernel/locking/mutex.c:1199)
            regulator_lock_recursive (drivers/regulator/core.c:156
                                      drivers/regulator/core.c:263)
            regulator_lock_dependent (drivers/regulator/core.c:343)
            regulator_enable (drivers/regulator/core.c:2808)
            set_machine_constraints (drivers/regulator/core.c:1536)
            regulator_register (drivers/regulator/core.c:5486)
            devm_regulator_register (drivers/regulator/devres.c:196)
            reg_fixed_voltage_probe (drivers/regulator/fixed.c:289)
            platform_probe (drivers/base/platform.c:1427)
            [...]
    
            -> #1 (regulator_ww_class_acquire){+.+.}-{0:0}:
            regulator_lock_dependent (include/linux/ww_mutex.h:129
                                      drivers/regulator/core.c:329)
            regulator_enable (drivers/regulator/core.c:2808)
            set_machine_constraints (drivers/regulator/core.c:1536)
            regulator_register (drivers/regulator/core.c:5486)
            devm_regulator_register (drivers/regulator/devres.c:196)
            reg_fixed_voltage_probe (drivers/regulator/fixed.c:289)
            [...]
    
            -> #0 (regulator_list_mutex){+.+.}-{3:3}:
            __lock_acquire (kernel/locking/lockdep.c:3052 (discriminator 4)
                            kernel/locking/lockdep.c:3174 (discriminator 4)
                            kernel/locking/lockdep.c:3789 (discriminator 4)
                            kernel/locking/lockdep.c:5015 (discriminator 4))
            lock_acquire (arch/arm64/include/asm/percpu.h:39
                          kernel/locking/lockdep.c:438
                          kernel/locking/lockdep.c:5627)
            __mutex_lock_common (include/asm-generic/atomic-instrumented.h:606
                                 include/asm-generic/atomic-long.h:29
                                 kernel/locking/mutex.c:103
                                 kernel/locking/mutex.c:144
                                 kernel/locking/mutex.c:963)
            mutex_lock_nested (kernel/locking/mutex.c:1125)
            regulator_lock_dependent (arch/arm64/include/asm/current.h:19
                                      include/linux/ww_mutex.h:111
                                      drivers/regulator/core.c:329)
            regulator_enable (drivers/regulator/core.c:2808)
            vctrl_enable (drivers/regulator/vctrl-regulator.c:400)
            _regulator_do_enable (drivers/regulator/core.c:2617)
            _regulator_enable (drivers/regulator/core.c:2764)
            regulator_enable (drivers/regulator/core.c:308
                              drivers/regulator/core.c:2809)
            _set_opp (drivers/opp/core.c:819 drivers/opp/core.c:1072)
            dev_pm_opp_set_rate (drivers/opp/core.c:1164)
            set_target (drivers/cpufreq/cpufreq-dt.c:62)
            __cpufreq_driver_target (drivers/cpufreq/cpufreq.c:2216
                                     drivers/cpufreq/cpufreq.c:2271)
            cpufreq_online (drivers/cpufreq/cpufreq.c:1488 (discriminator 2))
            cpufreq_add_dev (drivers/cpufreq/cpufreq.c:1563)
            subsys_interface_register (drivers/base/bus.c:?)
            cpufreq_register_driver (drivers/cpufreq/cpufreq.c:2819)
            dt_cpufreq_probe (drivers/cpufreq/cpufreq-dt.c:344)
            [...]
    
            other info that might help us debug this:
    
            Chain exists of:
              regulator_list_mutex --> regulator_ww_class_acquire --> regulator_ww_class_mutex
    
             Possible unsafe locking scenario:
    
                   CPU0                    CPU1
                   ----                    ----
              lock(regulator_ww_class_mutex);
                                           lock(regulator_ww_class_acquire);
                                           lock(regulator_ww_class_mutex);
              lock(regulator_list_mutex);
    
             *** DEADLOCK ***
    
            6 locks held by swapper/0/1:
            #0: ffffff8002d32188 (&dev->mutex){....}-{3:3}, at:
                    __device_driver_lock (drivers/base/dd.c:1030)
            #1: ffffffc0111a0520 (cpu_hotplug_lock){++++}-{0:0}, at:
                    cpufreq_register_driver (drivers/cpufreq/cpufreq.c:2792 (discriminator 2))
            #2: ffffff8002a8d918 (subsys mutex#9){+.+.}-{3:3}, at:
                    subsys_interface_register (drivers/base/bus.c:1033)
            #3: ffffff800341bb90 (&policy->rwsem){+.+.}-{3:3}, at:
                    cpufreq_online (include/linux/bitmap.h:285
                                    include/linux/cpumask.h:405
                                    drivers/cpufreq/cpufreq.c:1399)
            #4: ffffffc011f0b7b8 (regulator_ww_class_acquire){+.+.}-{0:0}, at:
                    regulator_enable (drivers/regulator/core.c:2808)
            #5: ffffff8004a77160 (regulator_ww_class_mutex){+.+.}-{3:3}, at:
                    regulator_lock_recursive (drivers/regulator/core.c:156
                    drivers/regulator/core.c:263)
    
            stack backtrace:
            CPU: 1 PID: 1 Comm: swapper/0 Not tainted 5.14.0-rc6 #2 7c8f8996d021ed0f65271e6aeebf7999de74a9fa
            Hardware name: Google Scarlet (DT)
            Call trace:
            dump_backtrace (arch/arm64/kernel/stacktrace.c:161)
            show_stack (arch/arm64/kernel/stacktrace.c:218)
            dump_stack_lvl (lib/dump_stack.c:106 (discriminator 2))
            dump_stack (lib/dump_stack.c:113)
            print_circular_bug (kernel/locking/lockdep.c:?)
            check_noncircular (kernel/locking/lockdep.c:?)
            __lock_acquire (kernel/locking/lockdep.c:3052 (discriminator 4)
                            kernel/locking/lockdep.c:3174 (discriminator 4)
                            kernel/locking/lockdep.c:3789 (discriminator 4)
                            kernel/locking/lockdep.c:5015 (discriminator 4))
            lock_acquire (arch/arm64/include/asm/percpu.h:39
                          kernel/locking/lockdep.c:438
                          kernel/locking/lockdep.c:5627)
            __mutex_lock_common (include/asm-generic/atomic-instrumented.h:606
                                 include/asm-generic/atomic-long.h:29
                                 kernel/locking/mutex.c:103
                                 kernel/locking/mutex.c:144
                                 kernel/locking/mutex.c:963)
            mutex_lock_nested (kernel/locking/mutex.c:1125)
            regulator_lock_dependent (arch/arm64/include/asm/current.h:19
                                      include/linux/ww_mutex.h:111
                                      drivers/regulator/core.c:329)
            regulator_enable (drivers/regulator/core.c:2808)
            vctrl_enable (drivers/regulator/vctrl-regulator.c:400)
            _regulator_do_enable (drivers/regulator/core.c:2617)
            _regulator_enable (drivers/regulator/core.c:2764)
            regulator_enable (drivers/regulator/core.c:308
                              drivers/regulator/core.c:2809)
            _set_opp (drivers/opp/core.c:819 drivers/opp/core.c:1072)
            dev_pm_opp_set_rate (drivers/opp/core.c:1164)
            set_target (drivers/cpufreq/cpufreq-dt.c:62)
            __cpufreq_driver_target (drivers/cpufreq/cpufreq.c:2216
                                     drivers/cpufreq/cpufreq.c:2271)
            cpufreq_online (drivers/cpufreq/cpufreq.c:1488 (discriminator 2))
            cpufreq_add_dev (drivers/cpufreq/cpufreq.c:1563)
            subsys_interface_register (drivers/base/bus.c:?)
            cpufreq_register_driver (drivers/cpufreq/cpufreq.c:2819)
            dt_cpufreq_probe (drivers/cpufreq/cpufreq-dt.c:344)
            [...]
    
    Reported-by: Brian Norris <briannorris@chromium.org>
    Fixes: f8702f9e4aa7 ("regulator: core: Use ww_mutex for regulators locking")
    Fixes: e9153311491d ("regulator: vctrl-regulator: Avoid deadlock getting and setting the voltage")
    Signed-off-by: Chen-Yu Tsai <wenst@chromium.org>
    Link: https://lore.kernel.org/r/20210825033704.3307263-3-wenst@chromium.org
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 841e2dca5a89a74ce3bdb2275fba12fd61457e51
Author: Chen-Yu Tsai <wenst@chromium.org>
Date:   Wed Aug 25 11:37:04 2021 +0800

    regulator: vctrl: Avoid lockdep warning in enable/disable ops
    
    [ Upstream commit 21e39809fd7c4b8ff3662f23e0168e87594c8ca8 ]
    
    vctrl_enable() and vctrl_disable() call regulator_enable() and
    regulator_disable(), respectively. However, vctrl_* are regulator ops
    and should not be calling the locked regulator APIs. Doing so results in
    a lockdep warning.
    
    Instead of exporting more internal regulator ops, model the ctrl supply
    as an actual supply to vctrl-regulator. At probe time this driver still
    needs to use the consumer API to fetch its constraints, but otherwise
    lets the regulator core handle the upstream supply for it.
    
    The enable/disable/is_enabled ops are not removed, but now only track
    state internally. This preserves the original behavior with the ops
    being available, but one could argue that the original behavior was
    already incorrect: the internal state would not match the upstream
    supply if that supply had another consumer that enabled the supply,
    while vctrl-regulator was not enabled.
    
    The lockdep warning is as follows:
    
            WARNING: possible circular locking dependency detected
            5.14.0-rc6 #2 Not tainted
            ------------------------------------------------------
            swapper/0/1 is trying to acquire lock:
            ffffffc011306d00 (regulator_list_mutex){+.+.}-{3:3}, at:
                    regulator_lock_dependent (arch/arm64/include/asm/current.h:19
                                              include/linux/ww_mutex.h:111
                                              drivers/regulator/core.c:329)
    
            but task is already holding lock:
            ffffff8004a77160 (regulator_ww_class_mutex){+.+.}-{3:3}, at:
                    regulator_lock_recursive (drivers/regulator/core.c:156
                                              drivers/regulator/core.c:263)
    
            which lock already depends on the new lock.
    
            the existing dependency chain (in reverse order) is:
    
            -> #2 (regulator_ww_class_mutex){+.+.}-{3:3}:
            __mutex_lock_common (include/asm-generic/atomic-instrumented.h:606
                                 include/asm-generic/atomic-long.h:29
                                 kernel/locking/mutex.c:103
                                 kernel/locking/mutex.c:144
                                 kernel/locking/mutex.c:963)
            ww_mutex_lock (kernel/locking/mutex.c:1199)
            regulator_lock_recursive (drivers/regulator/core.c:156
                                      drivers/regulator/core.c:263)
            regulator_lock_dependent (drivers/regulator/core.c:343)
            regulator_enable (drivers/regulator/core.c:2808)
            set_machine_constraints (drivers/regulator/core.c:1536)
            regulator_register (drivers/regulator/core.c:5486)
            devm_regulator_register (drivers/regulator/devres.c:196)
            reg_fixed_voltage_probe (drivers/regulator/fixed.c:289)
            platform_probe (drivers/base/platform.c:1427)
            [...]
    
            -> #1 (regulator_ww_class_acquire){+.+.}-{0:0}:
            regulator_lock_dependent (include/linux/ww_mutex.h:129
                                      drivers/regulator/core.c:329)
            regulator_enable (drivers/regulator/core.c:2808)
            set_machine_constraints (drivers/regulator/core.c:1536)
            regulator_register (drivers/regulator/core.c:5486)
            devm_regulator_register (drivers/regulator/devres.c:196)
            reg_fixed_voltage_probe (drivers/regulator/fixed.c:289)
            [...]
    
            -> #0 (regulator_list_mutex){+.+.}-{3:3}:
            __lock_acquire (kernel/locking/lockdep.c:3052 (discriminator 4)
                            kernel/locking/lockdep.c:3174 (discriminator 4)
                            kernel/locking/lockdep.c:3789 (discriminator 4)
                            kernel/locking/lockdep.c:5015 (discriminator 4))
            lock_acquire (arch/arm64/include/asm/percpu.h:39
                          kernel/locking/lockdep.c:438
                          kernel/locking/lockdep.c:5627)
            __mutex_lock_common (include/asm-generic/atomic-instrumented.h:606
                                 include/asm-generic/atomic-long.h:29
                                 kernel/locking/mutex.c:103
                                 kernel/locking/mutex.c:144
                                 kernel/locking/mutex.c:963)
            mutex_lock_nested (kernel/locking/mutex.c:1125)
            regulator_lock_dependent (arch/arm64/include/asm/current.h:19
                                      include/linux/ww_mutex.h:111
                                      drivers/regulator/core.c:329)
            regulator_enable (drivers/regulator/core.c:2808)
            vctrl_enable (drivers/regulator/vctrl-regulator.c:400)
            _regulator_do_enable (drivers/regulator/core.c:2617)
            _regulator_enable (drivers/regulator/core.c:2764)
            regulator_enable (drivers/regulator/core.c:308
                              drivers/regulator/core.c:2809)
            _set_opp (drivers/opp/core.c:819 drivers/opp/core.c:1072)
            dev_pm_opp_set_rate (drivers/opp/core.c:1164)
            set_target (drivers/cpufreq/cpufreq-dt.c:62)
            __cpufreq_driver_target (drivers/cpufreq/cpufreq.c:2216
                                     drivers/cpufreq/cpufreq.c:2271)
            cpufreq_online (drivers/cpufreq/cpufreq.c:1488 (discriminator 2))
            cpufreq_add_dev (drivers/cpufreq/cpufreq.c:1563)
            subsys_interface_register (drivers/base/bus.c:?)
            cpufreq_register_driver (drivers/cpufreq/cpufreq.c:2819)
            dt_cpufreq_probe (drivers/cpufreq/cpufreq-dt.c:344)
            [...]
    
            other info that might help us debug this:
    
            Chain exists of:
              regulator_list_mutex --> regulator_ww_class_acquire --> regulator_ww_class_mutex
    
             Possible unsafe locking scenario:
    
                   CPU0                    CPU1
                   ----                    ----
              lock(regulator_ww_class_mutex);
                                           lock(regulator_ww_class_acquire);
                                           lock(regulator_ww_class_mutex);
              lock(regulator_list_mutex);
    
             *** DEADLOCK ***
    
            6 locks held by swapper/0/1:
            #0: ffffff8002d32188 (&dev->mutex){....}-{3:3}, at:
                    __device_driver_lock (drivers/base/dd.c:1030)
            #1: ffffffc0111a0520 (cpu_hotplug_lock){++++}-{0:0}, at:
                    cpufreq_register_driver (drivers/cpufreq/cpufreq.c:2792 (discriminator 2))
            #2: ffffff8002a8d918 (subsys mutex#9){+.+.}-{3:3}, at:
                    subsys_interface_register (drivers/base/bus.c:1033)
            #3: ffffff800341bb90 (&policy->rwsem){+.+.}-{3:3}, at:
                    cpufreq_online (include/linux/bitmap.h:285
                                    include/linux/cpumask.h:405
                                    drivers/cpufreq/cpufreq.c:1399)
            #4: ffffffc011f0b7b8 (regulator_ww_class_acquire){+.+.}-{0:0}, at:
                    regulator_enable (drivers/regulator/core.c:2808)
            #5: ffffff8004a77160 (regulator_ww_class_mutex){+.+.}-{3:3}, at:
                    regulator_lock_recursive (drivers/regulator/core.c:156
                    drivers/regulator/core.c:263)
    
            stack backtrace:
            CPU: 1 PID: 1 Comm: swapper/0 Not tainted 5.14.0-rc6 #2 7c8f8996d021ed0f65271e6aeebf7999de74a9fa
            Hardware name: Google Scarlet (DT)
            Call trace:
            dump_backtrace (arch/arm64/kernel/stacktrace.c:161)
            show_stack (arch/arm64/kernel/stacktrace.c:218)
            dump_stack_lvl (lib/dump_stack.c:106 (discriminator 2))
            dump_stack (lib/dump_stack.c:113)
            print_circular_bug (kernel/locking/lockdep.c:?)
            check_noncircular (kernel/locking/lockdep.c:?)
            __lock_acquire (kernel/locking/lockdep.c:3052 (discriminator 4)
                            kernel/locking/lockdep.c:3174 (discriminator 4)
                            kernel/locking/lockdep.c:3789 (discriminator 4)
                            kernel/locking/lockdep.c:5015 (discriminator 4))
            lock_acquire (arch/arm64/include/asm/percpu.h:39
                          kernel/locking/lockdep.c:438
                          kernel/locking/lockdep.c:5627)
            __mutex_lock_common (include/asm-generic/atomic-instrumented.h:606
                                 include/asm-generic/atomic-long.h:29
                                 kernel/locking/mutex.c:103
                                 kernel/locking/mutex.c:144
                                 kernel/locking/mutex.c:963)
            mutex_lock_nested (kernel/locking/mutex.c:1125)
            regulator_lock_dependent (arch/arm64/include/asm/current.h:19
                                      include/linux/ww_mutex.h:111
                                      drivers/regulator/core.c:329)
            regulator_enable (drivers/regulator/core.c:2808)
            vctrl_enable (drivers/regulator/vctrl-regulator.c:400)
            _regulator_do_enable (drivers/regulator/core.c:2617)
            _regulator_enable (drivers/regulator/core.c:2764)
            regulator_enable (drivers/regulator/core.c:308
                              drivers/regulator/core.c:2809)
            _set_opp (drivers/opp/core.c:819 drivers/opp/core.c:1072)
            dev_pm_opp_set_rate (drivers/opp/core.c:1164)
            set_target (drivers/cpufreq/cpufreq-dt.c:62)
            __cpufreq_driver_target (drivers/cpufreq/cpufreq.c:2216
                                     drivers/cpufreq/cpufreq.c:2271)
            cpufreq_online (drivers/cpufreq/cpufreq.c:1488 (discriminator 2))
            cpufreq_add_dev (drivers/cpufreq/cpufreq.c:1563)
            subsys_interface_register (drivers/base/bus.c:?)
            cpufreq_register_driver (drivers/cpufreq/cpufreq.c:2819)
            dt_cpufreq_probe (drivers/cpufreq/cpufreq-dt.c:344)
            [...]
    
    Reported-by: Brian Norris <briannorris@chromium.org>
    Fixes: f8702f9e4aa7 ("regulator: core: Use ww_mutex for regulators locking")
    Fixes: e9153311491d ("regulator: vctrl-regulator: Avoid deadlock getting and setting the voltage")
    Signed-off-by: Chen-Yu Tsai <wenst@chromium.org>
    Link: https://lore.kernel.org/r/20210825033704.3307263-3-wenst@chromium.org
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit cd8cca7268a24715d640e68cd19a3645f801c5bd
Author: Chen-Yu Tsai <wenst@chromium.org>
Date:   Wed Aug 25 11:37:04 2021 +0800

    regulator: vctrl: Avoid lockdep warning in enable/disable ops
    
    [ Upstream commit 21e39809fd7c4b8ff3662f23e0168e87594c8ca8 ]
    
    vctrl_enable() and vctrl_disable() call regulator_enable() and
    regulator_disable(), respectively. However, vctrl_* are regulator ops
    and should not be calling the locked regulator APIs. Doing so results in
    a lockdep warning.
    
    Instead of exporting more internal regulator ops, model the ctrl supply
    as an actual supply to vctrl-regulator. At probe time this driver still
    needs to use the consumer API to fetch its constraints, but otherwise
    lets the regulator core handle the upstream supply for it.
    
    The enable/disable/is_enabled ops are not removed, but now only track
    state internally. This preserves the original behavior with the ops
    being available, but one could argue that the original behavior was
    already incorrect: the internal state would not match the upstream
    supply if that supply had another consumer that enabled the supply,
    while vctrl-regulator was not enabled.
    
    The lockdep warning is as follows:
    
            WARNING: possible circular locking dependency detected
            5.14.0-rc6 #2 Not tainted
            ------------------------------------------------------
            swapper/0/1 is trying to acquire lock:
            ffffffc011306d00 (regulator_list_mutex){+.+.}-{3:3}, at:
                    regulator_lock_dependent (arch/arm64/include/asm/current.h:19
                                              include/linux/ww_mutex.h:111
                                              drivers/regulator/core.c:329)
    
            but task is already holding lock:
            ffffff8004a77160 (regulator_ww_class_mutex){+.+.}-{3:3}, at:
                    regulator_lock_recursive (drivers/regulator/core.c:156
                                              drivers/regulator/core.c:263)
    
            which lock already depends on the new lock.
    
            the existing dependency chain (in reverse order) is:
    
            -> #2 (regulator_ww_class_mutex){+.+.}-{3:3}:
            __mutex_lock_common (include/asm-generic/atomic-instrumented.h:606
                                 include/asm-generic/atomic-long.h:29
                                 kernel/locking/mutex.c:103
                                 kernel/locking/mutex.c:144
                                 kernel/locking/mutex.c:963)
            ww_mutex_lock (kernel/locking/mutex.c:1199)
            regulator_lock_recursive (drivers/regulator/core.c:156
                                      drivers/regulator/core.c:263)
            regulator_lock_dependent (drivers/regulator/core.c:343)
            regulator_enable (drivers/regulator/core.c:2808)
            set_machine_constraints (drivers/regulator/core.c:1536)
            regulator_register (drivers/regulator/core.c:5486)
            devm_regulator_register (drivers/regulator/devres.c:196)
            reg_fixed_voltage_probe (drivers/regulator/fixed.c:289)
            platform_probe (drivers/base/platform.c:1427)
            [...]
    
            -> #1 (regulator_ww_class_acquire){+.+.}-{0:0}:
            regulator_lock_dependent (include/linux/ww_mutex.h:129
                                      drivers/regulator/core.c:329)
            regulator_enable (drivers/regulator/core.c:2808)
            set_machine_constraints (drivers/regulator/core.c:1536)
            regulator_register (drivers/regulator/core.c:5486)
            devm_regulator_register (drivers/regulator/devres.c:196)
            reg_fixed_voltage_probe (drivers/regulator/fixed.c:289)
            [...]
    
            -> #0 (regulator_list_mutex){+.+.}-{3:3}:
            __lock_acquire (kernel/locking/lockdep.c:3052 (discriminator 4)
                            kernel/locking/lockdep.c:3174 (discriminator 4)
                            kernel/locking/lockdep.c:3789 (discriminator 4)
                            kernel/locking/lockdep.c:5015 (discriminator 4))
            lock_acquire (arch/arm64/include/asm/percpu.h:39
                          kernel/locking/lockdep.c:438
                          kernel/locking/lockdep.c:5627)
            __mutex_lock_common (include/asm-generic/atomic-instrumented.h:606
                                 include/asm-generic/atomic-long.h:29
                                 kernel/locking/mutex.c:103
                                 kernel/locking/mutex.c:144
                                 kernel/locking/mutex.c:963)
            mutex_lock_nested (kernel/locking/mutex.c:1125)
            regulator_lock_dependent (arch/arm64/include/asm/current.h:19
                                      include/linux/ww_mutex.h:111
                                      drivers/regulator/core.c:329)
            regulator_enable (drivers/regulator/core.c:2808)
            vctrl_enable (drivers/regulator/vctrl-regulator.c:400)
            _regulator_do_enable (drivers/regulator/core.c:2617)
            _regulator_enable (drivers/regulator/core.c:2764)
            regulator_enable (drivers/regulator/core.c:308
                              drivers/regulator/core.c:2809)
            _set_opp (drivers/opp/core.c:819 drivers/opp/core.c:1072)
            dev_pm_opp_set_rate (drivers/opp/core.c:1164)
            set_target (drivers/cpufreq/cpufreq-dt.c:62)
            __cpufreq_driver_target (drivers/cpufreq/cpufreq.c:2216
                                     drivers/cpufreq/cpufreq.c:2271)
            cpufreq_online (drivers/cpufreq/cpufreq.c:1488 (discriminator 2))
            cpufreq_add_dev (drivers/cpufreq/cpufreq.c:1563)
            subsys_interface_register (drivers/base/bus.c:?)
            cpufreq_register_driver (drivers/cpufreq/cpufreq.c:2819)
            dt_cpufreq_probe (drivers/cpufreq/cpufreq-dt.c:344)
            [...]
    
            other info that might help us debug this:
    
            Chain exists of:
              regulator_list_mutex --> regulator_ww_class_acquire --> regulator_ww_class_mutex
    
             Possible unsafe locking scenario:
    
                   CPU0                    CPU1
                   ----                    ----
              lock(regulator_ww_class_mutex);
                                           lock(regulator_ww_class_acquire);
                                           lock(regulator_ww_class_mutex);
              lock(regulator_list_mutex);
    
             *** DEADLOCK ***
    
            6 locks held by swapper/0/1:
            #0: ffffff8002d32188 (&dev->mutex){....}-{3:3}, at:
                    __device_driver_lock (drivers/base/dd.c:1030)
            #1: ffffffc0111a0520 (cpu_hotplug_lock){++++}-{0:0}, at:
                    cpufreq_register_driver (drivers/cpufreq/cpufreq.c:2792 (discriminator 2))
            #2: ffffff8002a8d918 (subsys mutex#9){+.+.}-{3:3}, at:
                    subsys_interface_register (drivers/base/bus.c:1033)
            #3: ffffff800341bb90 (&policy->rwsem){+.+.}-{3:3}, at:
                    cpufreq_online (include/linux/bitmap.h:285
                                    include/linux/cpumask.h:405
                                    drivers/cpufreq/cpufreq.c:1399)
            #4: ffffffc011f0b7b8 (regulator_ww_class_acquire){+.+.}-{0:0}, at:
                    regulator_enable (drivers/regulator/core.c:2808)
            #5: ffffff8004a77160 (regulator_ww_class_mutex){+.+.}-{3:3}, at:
                    regulator_lock_recursive (drivers/regulator/core.c:156
                    drivers/regulator/core.c:263)
    
            stack backtrace:
            CPU: 1 PID: 1 Comm: swapper/0 Not tainted 5.14.0-rc6 #2 7c8f8996d021ed0f65271e6aeebf7999de74a9fa
            Hardware name: Google Scarlet (DT)
            Call trace:
            dump_backtrace (arch/arm64/kernel/stacktrace.c:161)
            show_stack (arch/arm64/kernel/stacktrace.c:218)
            dump_stack_lvl (lib/dump_stack.c:106 (discriminator 2))
            dump_stack (lib/dump_stack.c:113)
            print_circular_bug (kernel/locking/lockdep.c:?)
            check_noncircular (kernel/locking/lockdep.c:?)
            __lock_acquire (kernel/locking/lockdep.c:3052 (discriminator 4)
                            kernel/locking/lockdep.c:3174 (discriminator 4)
                            kernel/locking/lockdep.c:3789 (discriminator 4)
                            kernel/locking/lockdep.c:5015 (discriminator 4))
            lock_acquire (arch/arm64/include/asm/percpu.h:39
                          kernel/locking/lockdep.c:438
                          kernel/locking/lockdep.c:5627)
            __mutex_lock_common (include/asm-generic/atomic-instrumented.h:606
                                 include/asm-generic/atomic-long.h:29
                                 kernel/locking/mutex.c:103
                                 kernel/locking/mutex.c:144
                                 kernel/locking/mutex.c:963)
            mutex_lock_nested (kernel/locking/mutex.c:1125)
            regulator_lock_dependent (arch/arm64/include/asm/current.h:19
                                      include/linux/ww_mutex.h:111
                                      drivers/regulator/core.c:329)
            regulator_enable (drivers/regulator/core.c:2808)
            vctrl_enable (drivers/regulator/vctrl-regulator.c:400)
            _regulator_do_enable (drivers/regulator/core.c:2617)
            _regulator_enable (drivers/regulator/core.c:2764)
            regulator_enable (drivers/regulator/core.c:308
                              drivers/regulator/core.c:2809)
            _set_opp (drivers/opp/core.c:819 drivers/opp/core.c:1072)
            dev_pm_opp_set_rate (drivers/opp/core.c:1164)
            set_target (drivers/cpufreq/cpufreq-dt.c:62)
            __cpufreq_driver_target (drivers/cpufreq/cpufreq.c:2216
                                     drivers/cpufreq/cpufreq.c:2271)
            cpufreq_online (drivers/cpufreq/cpufreq.c:1488 (discriminator 2))
            cpufreq_add_dev (drivers/cpufreq/cpufreq.c:1563)
            subsys_interface_register (drivers/base/bus.c:?)
            cpufreq_register_driver (drivers/cpufreq/cpufreq.c:2819)
            dt_cpufreq_probe (drivers/cpufreq/cpufreq-dt.c:344)
            [...]
    
    Reported-by: Brian Norris <briannorris@chromium.org>
    Fixes: f8702f9e4aa7 ("regulator: core: Use ww_mutex for regulators locking")
    Fixes: e9153311491d ("regulator: vctrl-regulator: Avoid deadlock getting and setting the voltage")
    Signed-off-by: Chen-Yu Tsai <wenst@chromium.org>
    Link: https://lore.kernel.org/r/20210825033704.3307263-3-wenst@chromium.org
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 1f70517eac57fbc0b4cedab0b7aab8f653d733c7
Author: Chen-Yu Tsai <wenst@chromium.org>
Date:   Wed Aug 25 11:37:04 2021 +0800

    regulator: vctrl: Avoid lockdep warning in enable/disable ops
    
    [ Upstream commit 21e39809fd7c4b8ff3662f23e0168e87594c8ca8 ]
    
    vctrl_enable() and vctrl_disable() call regulator_enable() and
    regulator_disable(), respectively. However, vctrl_* are regulator ops
    and should not be calling the locked regulator APIs. Doing so results in
    a lockdep warning.
    
    Instead of exporting more internal regulator ops, model the ctrl supply
    as an actual supply to vctrl-regulator. At probe time this driver still
    needs to use the consumer API to fetch its constraints, but otherwise
    lets the regulator core handle the upstream supply for it.
    
    The enable/disable/is_enabled ops are not removed, but now only track
    state internally. This preserves the original behavior with the ops
    being available, but one could argue that the original behavior was
    already incorrect: the internal state would not match the upstream
    supply if that supply had another consumer that enabled the supply,
    while vctrl-regulator was not enabled.
    
    The lockdep warning is as follows:
    
            WARNING: possible circular locking dependency detected
            5.14.0-rc6 #2 Not tainted
            ------------------------------------------------------
            swapper/0/1 is trying to acquire lock:
            ffffffc011306d00 (regulator_list_mutex){+.+.}-{3:3}, at:
                    regulator_lock_dependent (arch/arm64/include/asm/current.h:19
                                              include/linux/ww_mutex.h:111
                                              drivers/regulator/core.c:329)
    
            but task is already holding lock:
            ffffff8004a77160 (regulator_ww_class_mutex){+.+.}-{3:3}, at:
                    regulator_lock_recursive (drivers/regulator/core.c:156
                                              drivers/regulator/core.c:263)
    
            which lock already depends on the new lock.
    
            the existing dependency chain (in reverse order) is:
    
            -> #2 (regulator_ww_class_mutex){+.+.}-{3:3}:
            __mutex_lock_common (include/asm-generic/atomic-instrumented.h:606
                                 include/asm-generic/atomic-long.h:29
                                 kernel/locking/mutex.c:103
                                 kernel/locking/mutex.c:144
                                 kernel/locking/mutex.c:963)
            ww_mutex_lock (kernel/locking/mutex.c:1199)
            regulator_lock_recursive (drivers/regulator/core.c:156
                                      drivers/regulator/core.c:263)
            regulator_lock_dependent (drivers/regulator/core.c:343)
            regulator_enable (drivers/regulator/core.c:2808)
            set_machine_constraints (drivers/regulator/core.c:1536)
            regulator_register (drivers/regulator/core.c:5486)
            devm_regulator_register (drivers/regulator/devres.c:196)
            reg_fixed_voltage_probe (drivers/regulator/fixed.c:289)
            platform_probe (drivers/base/platform.c:1427)
            [...]
    
            -> #1 (regulator_ww_class_acquire){+.+.}-{0:0}:
            regulator_lock_dependent (include/linux/ww_mutex.h:129
                                      drivers/regulator/core.c:329)
            regulator_enable (drivers/regulator/core.c:2808)
            set_machine_constraints (drivers/regulator/core.c:1536)
            regulator_register (drivers/regulator/core.c:5486)
            devm_regulator_register (drivers/regulator/devres.c:196)
            reg_fixed_voltage_probe (drivers/regulator/fixed.c:289)
            [...]
    
            -> #0 (regulator_list_mutex){+.+.}-{3:3}:
            __lock_acquire (kernel/locking/lockdep.c:3052 (discriminator 4)
                            kernel/locking/lockdep.c:3174 (discriminator 4)
                            kernel/locking/lockdep.c:3789 (discriminator 4)
                            kernel/locking/lockdep.c:5015 (discriminator 4))
            lock_acquire (arch/arm64/include/asm/percpu.h:39
                          kernel/locking/lockdep.c:438
                          kernel/locking/lockdep.c:5627)
            __mutex_lock_common (include/asm-generic/atomic-instrumented.h:606
                                 include/asm-generic/atomic-long.h:29
                                 kernel/locking/mutex.c:103
                                 kernel/locking/mutex.c:144
                                 kernel/locking/mutex.c:963)
            mutex_lock_nested (kernel/locking/mutex.c:1125)
            regulator_lock_dependent (arch/arm64/include/asm/current.h:19
                                      include/linux/ww_mutex.h:111
                                      drivers/regulator/core.c:329)
            regulator_enable (drivers/regulator/core.c:2808)
            vctrl_enable (drivers/regulator/vctrl-regulator.c:400)
            _regulator_do_enable (drivers/regulator/core.c:2617)
            _regulator_enable (drivers/regulator/core.c:2764)
            regulator_enable (drivers/regulator/core.c:308
                              drivers/regulator/core.c:2809)
            _set_opp (drivers/opp/core.c:819 drivers/opp/core.c:1072)
            dev_pm_opp_set_rate (drivers/opp/core.c:1164)
            set_target (drivers/cpufreq/cpufreq-dt.c:62)
            __cpufreq_driver_target (drivers/cpufreq/cpufreq.c:2216
                                     drivers/cpufreq/cpufreq.c:2271)
            cpufreq_online (drivers/cpufreq/cpufreq.c:1488 (discriminator 2))
            cpufreq_add_dev (drivers/cpufreq/cpufreq.c:1563)
            subsys_interface_register (drivers/base/bus.c:?)
            cpufreq_register_driver (drivers/cpufreq/cpufreq.c:2819)
            dt_cpufreq_probe (drivers/cpufreq/cpufreq-dt.c:344)
            [...]
    
            other info that might help us debug this:
    
            Chain exists of:
              regulator_list_mutex --> regulator_ww_class_acquire --> regulator_ww_class_mutex
    
             Possible unsafe locking scenario:
    
                   CPU0                    CPU1
                   ----                    ----
              lock(regulator_ww_class_mutex);
                                           lock(regulator_ww_class_acquire);
                                           lock(regulator_ww_class_mutex);
              lock(regulator_list_mutex);
    
             *** DEADLOCK ***
    
            6 locks held by swapper/0/1:
            #0: ffffff8002d32188 (&dev->mutex){....}-{3:3}, at:
                    __device_driver_lock (drivers/base/dd.c:1030)
            #1: ffffffc0111a0520 (cpu_hotplug_lock){++++}-{0:0}, at:
                    cpufreq_register_driver (drivers/cpufreq/cpufreq.c:2792 (discriminator 2))
            #2: ffffff8002a8d918 (subsys mutex#9){+.+.}-{3:3}, at:
                    subsys_interface_register (drivers/base/bus.c:1033)
            #3: ffffff800341bb90 (&policy->rwsem){+.+.}-{3:3}, at:
                    cpufreq_online (include/linux/bitmap.h:285
                                    include/linux/cpumask.h:405
                                    drivers/cpufreq/cpufreq.c:1399)
            #4: ffffffc011f0b7b8 (regulator_ww_class_acquire){+.+.}-{0:0}, at:
                    regulator_enable (drivers/regulator/core.c:2808)
            #5: ffffff8004a77160 (regulator_ww_class_mutex){+.+.}-{3:3}, at:
                    regulator_lock_recursive (drivers/regulator/core.c:156
                    drivers/regulator/core.c:263)
    
            stack backtrace:
            CPU: 1 PID: 1 Comm: swapper/0 Not tainted 5.14.0-rc6 #2 7c8f8996d021ed0f65271e6aeebf7999de74a9fa
            Hardware name: Google Scarlet (DT)
            Call trace:
            dump_backtrace (arch/arm64/kernel/stacktrace.c:161)
            show_stack (arch/arm64/kernel/stacktrace.c:218)
            dump_stack_lvl (lib/dump_stack.c:106 (discriminator 2))
            dump_stack (lib/dump_stack.c:113)
            print_circular_bug (kernel/locking/lockdep.c:?)
            check_noncircular (kernel/locking/lockdep.c:?)
            __lock_acquire (kernel/locking/lockdep.c:3052 (discriminator 4)
                            kernel/locking/lockdep.c:3174 (discriminator 4)
                            kernel/locking/lockdep.c:3789 (discriminator 4)
                            kernel/locking/lockdep.c:5015 (discriminator 4))
            lock_acquire (arch/arm64/include/asm/percpu.h:39
                          kernel/locking/lockdep.c:438
                          kernel/locking/lockdep.c:5627)
            __mutex_lock_common (include/asm-generic/atomic-instrumented.h:606
                                 include/asm-generic/atomic-long.h:29
                                 kernel/locking/mutex.c:103
                                 kernel/locking/mutex.c:144
                                 kernel/locking/mutex.c:963)
            mutex_lock_nested (kernel/locking/mutex.c:1125)
            regulator_lock_dependent (arch/arm64/include/asm/current.h:19
                                      include/linux/ww_mutex.h:111
                                      drivers/regulator/core.c:329)
            regulator_enable (drivers/regulator/core.c:2808)
            vctrl_enable (drivers/regulator/vctrl-regulator.c:400)
            _regulator_do_enable (drivers/regulator/core.c:2617)
            _regulator_enable (drivers/regulator/core.c:2764)
            regulator_enable (drivers/regulator/core.c:308
                              drivers/regulator/core.c:2809)
            _set_opp (drivers/opp/core.c:819 drivers/opp/core.c:1072)
            dev_pm_opp_set_rate (drivers/opp/core.c:1164)
            set_target (drivers/cpufreq/cpufreq-dt.c:62)
            __cpufreq_driver_target (drivers/cpufreq/cpufreq.c:2216
                                     drivers/cpufreq/cpufreq.c:2271)
            cpufreq_online (drivers/cpufreq/cpufreq.c:1488 (discriminator 2))
            cpufreq_add_dev (drivers/cpufreq/cpufreq.c:1563)
            subsys_interface_register (drivers/base/bus.c:?)
            cpufreq_register_driver (drivers/cpufreq/cpufreq.c:2819)
            dt_cpufreq_probe (drivers/cpufreq/cpufreq-dt.c:344)
            [...]
    
    Reported-by: Brian Norris <briannorris@chromium.org>
    Fixes: f8702f9e4aa7 ("regulator: core: Use ww_mutex for regulators locking")
    Fixes: e9153311491d ("regulator: vctrl-regulator: Avoid deadlock getting and setting the voltage")
    Signed-off-by: Chen-Yu Tsai <wenst@chromium.org>
    Link: https://lore.kernel.org/r/20210825033704.3307263-3-wenst@chromium.org
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 21e39809fd7c4b8ff3662f23e0168e87594c8ca8
Author: Chen-Yu Tsai <wenst@chromium.org>
Date:   Wed Aug 25 11:37:04 2021 +0800

    regulator: vctrl: Avoid lockdep warning in enable/disable ops
    
    vctrl_enable() and vctrl_disable() call regulator_enable() and
    regulator_disable(), respectively. However, vctrl_* are regulator ops
    and should not be calling the locked regulator APIs. Doing so results in
    a lockdep warning.
    
    Instead of exporting more internal regulator ops, model the ctrl supply
    as an actual supply to vctrl-regulator. At probe time this driver still
    needs to use the consumer API to fetch its constraints, but otherwise
    lets the regulator core handle the upstream supply for it.
    
    The enable/disable/is_enabled ops are not removed, but now only track
    state internally. This preserves the original behavior with the ops
    being available, but one could argue that the original behavior was
    already incorrect: the internal state would not match the upstream
    supply if that supply had another consumer that enabled the supply,
    while vctrl-regulator was not enabled.
    
    The lockdep warning is as follows:
    
            WARNING: possible circular locking dependency detected
            5.14.0-rc6 #2 Not tainted
            ------------------------------------------------------
            swapper/0/1 is trying to acquire lock:
            ffffffc011306d00 (regulator_list_mutex){+.+.}-{3:3}, at:
                    regulator_lock_dependent (arch/arm64/include/asm/current.h:19
                                              include/linux/ww_mutex.h:111
                                              drivers/regulator/core.c:329)
    
            but task is already holding lock:
            ffffff8004a77160 (regulator_ww_class_mutex){+.+.}-{3:3}, at:
                    regulator_lock_recursive (drivers/regulator/core.c:156
                                              drivers/regulator/core.c:263)
    
            which lock already depends on the new lock.
    
            the existing dependency chain (in reverse order) is:
    
            -> #2 (regulator_ww_class_mutex){+.+.}-{3:3}:
            __mutex_lock_common (include/asm-generic/atomic-instrumented.h:606
                                 include/asm-generic/atomic-long.h:29
                                 kernel/locking/mutex.c:103
                                 kernel/locking/mutex.c:144
                                 kernel/locking/mutex.c:963)
            ww_mutex_lock (kernel/locking/mutex.c:1199)
            regulator_lock_recursive (drivers/regulator/core.c:156
                                      drivers/regulator/core.c:263)
            regulator_lock_dependent (drivers/regulator/core.c:343)
            regulator_enable (drivers/regulator/core.c:2808)
            set_machine_constraints (drivers/regulator/core.c:1536)
            regulator_register (drivers/regulator/core.c:5486)
            devm_regulator_register (drivers/regulator/devres.c:196)
            reg_fixed_voltage_probe (drivers/regulator/fixed.c:289)
            platform_probe (drivers/base/platform.c:1427)
            [...]
    
            -> #1 (regulator_ww_class_acquire){+.+.}-{0:0}:
            regulator_lock_dependent (include/linux/ww_mutex.h:129
                                      drivers/regulator/core.c:329)
            regulator_enable (drivers/regulator/core.c:2808)
            set_machine_constraints (drivers/regulator/core.c:1536)
            regulator_register (drivers/regulator/core.c:5486)
            devm_regulator_register (drivers/regulator/devres.c:196)
            reg_fixed_voltage_probe (drivers/regulator/fixed.c:289)
            [...]
    
            -> #0 (regulator_list_mutex){+.+.}-{3:3}:
            __lock_acquire (kernel/locking/lockdep.c:3052 (discriminator 4)
                            kernel/locking/lockdep.c:3174 (discriminator 4)
                            kernel/locking/lockdep.c:3789 (discriminator 4)
                            kernel/locking/lockdep.c:5015 (discriminator 4))
            lock_acquire (arch/arm64/include/asm/percpu.h:39
                          kernel/locking/lockdep.c:438
                          kernel/locking/lockdep.c:5627)
            __mutex_lock_common (include/asm-generic/atomic-instrumented.h:606
                                 include/asm-generic/atomic-long.h:29
                                 kernel/locking/mutex.c:103
                                 kernel/locking/mutex.c:144
                                 kernel/locking/mutex.c:963)
            mutex_lock_nested (kernel/locking/mutex.c:1125)
            regulator_lock_dependent (arch/arm64/include/asm/current.h:19
                                      include/linux/ww_mutex.h:111
                                      drivers/regulator/core.c:329)
            regulator_enable (drivers/regulator/core.c:2808)
            vctrl_enable (drivers/regulator/vctrl-regulator.c:400)
            _regulator_do_enable (drivers/regulator/core.c:2617)
            _regulator_enable (drivers/regulator/core.c:2764)
            regulator_enable (drivers/regulator/core.c:308
                              drivers/regulator/core.c:2809)
            _set_opp (drivers/opp/core.c:819 drivers/opp/core.c:1072)
            dev_pm_opp_set_rate (drivers/opp/core.c:1164)
            set_target (drivers/cpufreq/cpufreq-dt.c:62)
            __cpufreq_driver_target (drivers/cpufreq/cpufreq.c:2216
                                     drivers/cpufreq/cpufreq.c:2271)
            cpufreq_online (drivers/cpufreq/cpufreq.c:1488 (discriminator 2))
            cpufreq_add_dev (drivers/cpufreq/cpufreq.c:1563)
            subsys_interface_register (drivers/base/bus.c:?)
            cpufreq_register_driver (drivers/cpufreq/cpufreq.c:2819)
            dt_cpufreq_probe (drivers/cpufreq/cpufreq-dt.c:344)
            [...]
    
            other info that might help us debug this:
    
            Chain exists of:
              regulator_list_mutex --> regulator_ww_class_acquire --> regulator_ww_class_mutex
    
             Possible unsafe locking scenario:
    
                   CPU0                    CPU1
                   ----                    ----
              lock(regulator_ww_class_mutex);
                                           lock(regulator_ww_class_acquire);
                                           lock(regulator_ww_class_mutex);
              lock(regulator_list_mutex);
    
             *** DEADLOCK ***
    
            6 locks held by swapper/0/1:
            #0: ffffff8002d32188 (&dev->mutex){....}-{3:3}, at:
                    __device_driver_lock (drivers/base/dd.c:1030)
            #1: ffffffc0111a0520 (cpu_hotplug_lock){++++}-{0:0}, at:
                    cpufreq_register_driver (drivers/cpufreq/cpufreq.c:2792 (discriminator 2))
            #2: ffffff8002a8d918 (subsys mutex#9){+.+.}-{3:3}, at:
                    subsys_interface_register (drivers/base/bus.c:1033)
            #3: ffffff800341bb90 (&policy->rwsem){+.+.}-{3:3}, at:
                    cpufreq_online (include/linux/bitmap.h:285
                                    include/linux/cpumask.h:405
                                    drivers/cpufreq/cpufreq.c:1399)
            #4: ffffffc011f0b7b8 (regulator_ww_class_acquire){+.+.}-{0:0}, at:
                    regulator_enable (drivers/regulator/core.c:2808)
            #5: ffffff8004a77160 (regulator_ww_class_mutex){+.+.}-{3:3}, at:
                    regulator_lock_recursive (drivers/regulator/core.c:156
                    drivers/regulator/core.c:263)
    
            stack backtrace:
            CPU: 1 PID: 1 Comm: swapper/0 Not tainted 5.14.0-rc6 #2 7c8f8996d021ed0f65271e6aeebf7999de74a9fa
            Hardware name: Google Scarlet (DT)
            Call trace:
            dump_backtrace (arch/arm64/kernel/stacktrace.c:161)
            show_stack (arch/arm64/kernel/stacktrace.c:218)
            dump_stack_lvl (lib/dump_stack.c:106 (discriminator 2))
            dump_stack (lib/dump_stack.c:113)
            print_circular_bug (kernel/locking/lockdep.c:?)
            check_noncircular (kernel/locking/lockdep.c:?)
            __lock_acquire (kernel/locking/lockdep.c:3052 (discriminator 4)
                            kernel/locking/lockdep.c:3174 (discriminator 4)
                            kernel/locking/lockdep.c:3789 (discriminator 4)
                            kernel/locking/lockdep.c:5015 (discriminator 4))
            lock_acquire (arch/arm64/include/asm/percpu.h:39
                          kernel/locking/lockdep.c:438
                          kernel/locking/lockdep.c:5627)
            __mutex_lock_common (include/asm-generic/atomic-instrumented.h:606
                                 include/asm-generic/atomic-long.h:29
                                 kernel/locking/mutex.c:103
                                 kernel/locking/mutex.c:144
                                 kernel/locking/mutex.c:963)
            mutex_lock_nested (kernel/locking/mutex.c:1125)
            regulator_lock_dependent (arch/arm64/include/asm/current.h:19
                                      include/linux/ww_mutex.h:111
                                      drivers/regulator/core.c:329)
            regulator_enable (drivers/regulator/core.c:2808)
            vctrl_enable (drivers/regulator/vctrl-regulator.c:400)
            _regulator_do_enable (drivers/regulator/core.c:2617)
            _regulator_enable (drivers/regulator/core.c:2764)
            regulator_enable (drivers/regulator/core.c:308
                              drivers/regulator/core.c:2809)
            _set_opp (drivers/opp/core.c:819 drivers/opp/core.c:1072)
            dev_pm_opp_set_rate (drivers/opp/core.c:1164)
            set_target (drivers/cpufreq/cpufreq-dt.c:62)
            __cpufreq_driver_target (drivers/cpufreq/cpufreq.c:2216
                                     drivers/cpufreq/cpufreq.c:2271)
            cpufreq_online (drivers/cpufreq/cpufreq.c:1488 (discriminator 2))
            cpufreq_add_dev (drivers/cpufreq/cpufreq.c:1563)
            subsys_interface_register (drivers/base/bus.c:?)
            cpufreq_register_driver (drivers/cpufreq/cpufreq.c:2819)
            dt_cpufreq_probe (drivers/cpufreq/cpufreq-dt.c:344)
            [...]
    
    Reported-by: Brian Norris <briannorris@chromium.org>
    Fixes: f8702f9e4aa7 ("regulator: core: Use ww_mutex for regulators locking")
    Fixes: e9153311491d ("regulator: vctrl-regulator: Avoid deadlock getting and setting the voltage")
    Signed-off-by: Chen-Yu Tsai <wenst@chromium.org>
    Link: https://lore.kernel.org/r/20210825033704.3307263-3-wenst@chromium.org
    Signed-off-by: Mark Brown <broonie@kernel.org>

commit 569ca6983eb072d96cc5d4b5390e6de502e2dfcf
Author: Christophe JAILLET <christophe.jaillet@wanadoo.fr>
Date:   Sun Jan 17 15:26:35 2021 +0100

    cpufreq: brcmstb-avs-cpufreq: Free resources in error path
    
    [ Upstream commit 05f456286fd489558c72a4711d22a5612c965685 ]
    
    If 'cpufreq_register_driver()' fails, we must release the resources
    allocated in 'brcm_avs_prepare_init()' as already done in the remove
    function.
    
    To do that, introduce a new function 'brcm_avs_prepare_uninit()' in order
    to avoid code duplication. This also makes the code more readable (IMHO).
    
    Fixes: de322e085995 ("cpufreq: brcmstb-avs-cpufreq: AVS CPUfreq driver for Broadcom STB SoCs")
    Signed-off-by: Christophe JAILLET <christophe.jaillet@wanadoo.fr>
    [ Viresh: Updated Subject ]
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit de17aa73c9d9f84ee21e4a7b4568c3b6c3cb9e33
Author: Christophe JAILLET <christophe.jaillet@wanadoo.fr>
Date:   Sun Jan 17 15:26:35 2021 +0100

    cpufreq: brcmstb-avs-cpufreq: Free resources in error path
    
    [ Upstream commit 05f456286fd489558c72a4711d22a5612c965685 ]
    
    If 'cpufreq_register_driver()' fails, we must release the resources
    allocated in 'brcm_avs_prepare_init()' as already done in the remove
    function.
    
    To do that, introduce a new function 'brcm_avs_prepare_uninit()' in order
    to avoid code duplication. This also makes the code more readable (IMHO).
    
    Fixes: de322e085995 ("cpufreq: brcmstb-avs-cpufreq: AVS CPUfreq driver for Broadcom STB SoCs")
    Signed-off-by: Christophe JAILLET <christophe.jaillet@wanadoo.fr>
    [ Viresh: Updated Subject ]
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 279bc604e2e913653396cebbd4fb4a3ff632257d
Author: Christophe JAILLET <christophe.jaillet@wanadoo.fr>
Date:   Sun Jan 17 15:26:35 2021 +0100

    cpufreq: brcmstb-avs-cpufreq: Free resources in error path
    
    [ Upstream commit 05f456286fd489558c72a4711d22a5612c965685 ]
    
    If 'cpufreq_register_driver()' fails, we must release the resources
    allocated in 'brcm_avs_prepare_init()' as already done in the remove
    function.
    
    To do that, introduce a new function 'brcm_avs_prepare_uninit()' in order
    to avoid code duplication. This also makes the code more readable (IMHO).
    
    Fixes: de322e085995 ("cpufreq: brcmstb-avs-cpufreq: AVS CPUfreq driver for Broadcom STB SoCs")
    Signed-off-by: Christophe JAILLET <christophe.jaillet@wanadoo.fr>
    [ Viresh: Updated Subject ]
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 1fe373d16fcccb86dcf6c12809697a1c50dc79a8
Author: Christophe JAILLET <christophe.jaillet@wanadoo.fr>
Date:   Sun Jan 17 15:26:35 2021 +0100

    cpufreq: brcmstb-avs-cpufreq: Free resources in error path
    
    [ Upstream commit 05f456286fd489558c72a4711d22a5612c965685 ]
    
    If 'cpufreq_register_driver()' fails, we must release the resources
    allocated in 'brcm_avs_prepare_init()' as already done in the remove
    function.
    
    To do that, introduce a new function 'brcm_avs_prepare_uninit()' in order
    to avoid code duplication. This also makes the code more readable (IMHO).
    
    Fixes: de322e085995 ("cpufreq: brcmstb-avs-cpufreq: AVS CPUfreq driver for Broadcom STB SoCs")
    Signed-off-by: Christophe JAILLET <christophe.jaillet@wanadoo.fr>
    [ Viresh: Updated Subject ]
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 5ae4a4b45d4396aa7f7c008c4ae9eca981d43f8c
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Feb 2 10:25:11 2021 +0530

    cpufreq: Remove CPUFREQ_STICKY flag
    
    During cpufreq driver's registration, if the ->init() callback for all
    the CPUs fail then there is not much point in keeping the driver around
    as it will only account for more of unnecessary noise, for example
    cpufreq core will try to suspend/resume the driver which never got
    registered properly.
    
    The removal of such a driver is avoided if the driver carries the
    CPUFREQ_STICKY flag. This was added way back [1] in 2004 and perhaps no
    one should ever need it now. A lot of drivers do set this flag, probably
    because they just copied it from other drivers.
    
    This was added earlier for some platforms [2] because their cpufreq
    drivers were getting registered before the CPUs were registered with
    subsys framework. And hence they used to fail.
    
    The same isn't true anymore though. The current code flow in the kernel
    is:
    
    start_kernel()
    -> kernel_init()
       -> kernel_init_freeable()
          -> do_basic_setup()
             -> driver_init()
                -> cpu_dev_init()
                   -> subsys_system_register() //For CPUs
    
             -> do_initcalls()
                -> cpufreq_register_driver()
    
    Clearly, the CPUs will always get registered with subsys framework
    before any cpufreq driver can get probed. Remove the flag and update the
    relevant drivers.
    
    Link: https://git.kernel.org/pub/scm/linux/kernel/git/tglx/history.git/commit/include/linux/cpufreq.h?id=7cc9f0d9a1ab04cedc60d64fd8dcf7df224a3b4d # [1]
    Link: https://git.kernel.org/pub/scm/linux/kernel/git/tglx/history.git/commit/arch/arm/mach-sa1100/cpu-sa1100.c?id=f59d3bbe35f6268d729f51be82af8325d62f20f5 # [2]
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 05f456286fd489558c72a4711d22a5612c965685
Author: Christophe JAILLET <christophe.jaillet@wanadoo.fr>
Date:   Sun Jan 17 15:26:35 2021 +0100

    cpufreq: brcmstb-avs-cpufreq: Free resources in error path
    
    If 'cpufreq_register_driver()' fails, we must release the resources
    allocated in 'brcm_avs_prepare_init()' as already done in the remove
    function.
    
    To do that, introduce a new function 'brcm_avs_prepare_uninit()' in order
    to avoid code duplication. This also makes the code more readable (IMHO).
    
    Fixes: de322e085995 ("cpufreq: brcmstb-avs-cpufreq: AVS CPUfreq driver for Broadcom STB SoCs")
    Signed-off-by: Christophe JAILLET <christophe.jaillet@wanadoo.fr>
    [ Viresh: Updated Subject ]
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>

commit b5a67ca2424521863a279a3abf275c422a429d4b
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Nov 14 09:06:17 2019 +0530

    cpufreq: Register drivers only after CPU devices have been registered
    
    [ Upstream commit 46770be0cf94149ca48be87719bda1d951066644 ]
    
    The cpufreq core heavily depends on the availability of the struct
    device for CPUs and if they aren't available at the time cpufreq driver
    is registered, we will never succeed in making cpufreq work.
    
    This happens due to following sequence of events:
    
    - cpufreq_register_driver()
      - subsys_interface_register()
      - return 0; //successful registration of driver
    
    ... at a later point of time
    
    - register_cpu();
      - device_register();
        - bus_probe_device();
          - sif->add_dev();
            - cpufreq_add_dev();
              - get_cpu_device(); //FAILS
      - per_cpu(cpu_sys_devices, num) = &cpu->dev; //used by get_cpu_device()
      - return 0; //CPU registered successfully
    
    Because the per-cpu variable cpu_sys_devices is set only after the CPU
    device is regsitered, cpufreq will never be able to get it when
    cpufreq_add_dev() is called.
    
    This patch avoids this failure by making sure device structure of at
    least CPU0 is available when the cpufreq driver is registered, else
    return -EPROBE_DEFER.
    
    Reported-by: Bjorn Andersson <bjorn.andersson@linaro.org>
    Co-developed-by: Amit Kucheria <amit.kucheria@linaro.org>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Tested-by: Amit Kucheria <amit.kucheria@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit f5adfa8a8d4e1f0d8dd3638d785aa2020c215fc1
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Nov 14 09:06:17 2019 +0530

    cpufreq: Register drivers only after CPU devices have been registered
    
    [ Upstream commit 46770be0cf94149ca48be87719bda1d951066644 ]
    
    The cpufreq core heavily depends on the availability of the struct
    device for CPUs and if they aren't available at the time cpufreq driver
    is registered, we will never succeed in making cpufreq work.
    
    This happens due to following sequence of events:
    
    - cpufreq_register_driver()
      - subsys_interface_register()
      - return 0; //successful registration of driver
    
    ... at a later point of time
    
    - register_cpu();
      - device_register();
        - bus_probe_device();
          - sif->add_dev();
            - cpufreq_add_dev();
              - get_cpu_device(); //FAILS
      - per_cpu(cpu_sys_devices, num) = &cpu->dev; //used by get_cpu_device()
      - return 0; //CPU registered successfully
    
    Because the per-cpu variable cpu_sys_devices is set only after the CPU
    device is regsitered, cpufreq will never be able to get it when
    cpufreq_add_dev() is called.
    
    This patch avoids this failure by making sure device structure of at
    least CPU0 is available when the cpufreq driver is registered, else
    return -EPROBE_DEFER.
    
    Reported-by: Bjorn Andersson <bjorn.andersson@linaro.org>
    Co-developed-by: Amit Kucheria <amit.kucheria@linaro.org>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Tested-by: Amit Kucheria <amit.kucheria@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 32e1ac30b613eb00d9ed78039cb7d866222b11ed
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Nov 14 09:06:17 2019 +0530

    cpufreq: Register drivers only after CPU devices have been registered
    
    [ Upstream commit 46770be0cf94149ca48be87719bda1d951066644 ]
    
    The cpufreq core heavily depends on the availability of the struct
    device for CPUs and if they aren't available at the time cpufreq driver
    is registered, we will never succeed in making cpufreq work.
    
    This happens due to following sequence of events:
    
    - cpufreq_register_driver()
      - subsys_interface_register()
      - return 0; //successful registration of driver
    
    ... at a later point of time
    
    - register_cpu();
      - device_register();
        - bus_probe_device();
          - sif->add_dev();
            - cpufreq_add_dev();
              - get_cpu_device(); //FAILS
      - per_cpu(cpu_sys_devices, num) = &cpu->dev; //used by get_cpu_device()
      - return 0; //CPU registered successfully
    
    Because the per-cpu variable cpu_sys_devices is set only after the CPU
    device is regsitered, cpufreq will never be able to get it when
    cpufreq_add_dev() is called.
    
    This patch avoids this failure by making sure device structure of at
    least CPU0 is available when the cpufreq driver is registered, else
    return -EPROBE_DEFER.
    
    Reported-by: Bjorn Andersson <bjorn.andersson@linaro.org>
    Co-developed-by: Amit Kucheria <amit.kucheria@linaro.org>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Tested-by: Amit Kucheria <amit.kucheria@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 2a6f4ab54f2421514e7dce61bddf320ce62a4959
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Nov 14 09:06:17 2019 +0530

    cpufreq: Register drivers only after CPU devices have been registered
    
    [ Upstream commit 46770be0cf94149ca48be87719bda1d951066644 ]
    
    The cpufreq core heavily depends on the availability of the struct
    device for CPUs and if they aren't available at the time cpufreq driver
    is registered, we will never succeed in making cpufreq work.
    
    This happens due to following sequence of events:
    
    - cpufreq_register_driver()
      - subsys_interface_register()
      - return 0; //successful registration of driver
    
    ... at a later point of time
    
    - register_cpu();
      - device_register();
        - bus_probe_device();
          - sif->add_dev();
            - cpufreq_add_dev();
              - get_cpu_device(); //FAILS
      - per_cpu(cpu_sys_devices, num) = &cpu->dev; //used by get_cpu_device()
      - return 0; //CPU registered successfully
    
    Because the per-cpu variable cpu_sys_devices is set only after the CPU
    device is regsitered, cpufreq will never be able to get it when
    cpufreq_add_dev() is called.
    
    This patch avoids this failure by making sure device structure of at
    least CPU0 is available when the cpufreq driver is registered, else
    return -EPROBE_DEFER.
    
    Reported-by: Bjorn Andersson <bjorn.andersson@linaro.org>
    Co-developed-by: Amit Kucheria <amit.kucheria@linaro.org>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Tested-by: Amit Kucheria <amit.kucheria@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 7c31408136db6c826911f4a214868048f30839b5
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Nov 14 09:06:17 2019 +0530

    cpufreq: Register drivers only after CPU devices have been registered
    
    [ Upstream commit 46770be0cf94149ca48be87719bda1d951066644 ]
    
    The cpufreq core heavily depends on the availability of the struct
    device for CPUs and if they aren't available at the time cpufreq driver
    is registered, we will never succeed in making cpufreq work.
    
    This happens due to following sequence of events:
    
    - cpufreq_register_driver()
      - subsys_interface_register()
      - return 0; //successful registration of driver
    
    ... at a later point of time
    
    - register_cpu();
      - device_register();
        - bus_probe_device();
          - sif->add_dev();
            - cpufreq_add_dev();
              - get_cpu_device(); //FAILS
      - per_cpu(cpu_sys_devices, num) = &cpu->dev; //used by get_cpu_device()
      - return 0; //CPU registered successfully
    
    Because the per-cpu variable cpu_sys_devices is set only after the CPU
    device is regsitered, cpufreq will never be able to get it when
    cpufreq_add_dev() is called.
    
    This patch avoids this failure by making sure device structure of at
    least CPU0 is available when the cpufreq driver is registered, else
    return -EPROBE_DEFER.
    
    Reported-by: Bjorn Andersson <bjorn.andersson@linaro.org>
    Co-developed-by: Amit Kucheria <amit.kucheria@linaro.org>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Tested-by: Amit Kucheria <amit.kucheria@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 46770be0cf94149ca48be87719bda1d951066644
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Nov 14 09:06:17 2019 +0530

    cpufreq: Register drivers only after CPU devices have been registered
    
    The cpufreq core heavily depends on the availability of the struct
    device for CPUs and if they aren't available at the time cpufreq driver
    is registered, we will never succeed in making cpufreq work.
    
    This happens due to following sequence of events:
    
    - cpufreq_register_driver()
      - subsys_interface_register()
      - return 0; //successful registration of driver
    
    ... at a later point of time
    
    - register_cpu();
      - device_register();
        - bus_probe_device();
          - sif->add_dev();
            - cpufreq_add_dev();
              - get_cpu_device(); //FAILS
      - per_cpu(cpu_sys_devices, num) = &cpu->dev; //used by get_cpu_device()
      - return 0; //CPU registered successfully
    
    Because the per-cpu variable cpu_sys_devices is set only after the CPU
    device is regsitered, cpufreq will never be able to get it when
    cpufreq_add_dev() is called.
    
    This patch avoids this failure by making sure device structure of at
    least CPU0 is available when the cpufreq driver is registered, else
    return -EPROBE_DEFER.
    
    Reported-by: Bjorn Andersson <bjorn.andersson@linaro.org>
    Co-developed-by: Amit Kucheria <amit.kucheria@linaro.org>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Tested-by: Amit Kucheria <amit.kucheria@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 89f98d7e5fa8f7e1ba627537dc8a3cef5add7b04
Author: Yue Hu <huyue2@yulong.com>
Date:   Tue Apr 9 10:25:36 2019 +0800

    cpufreq: Remove cpufreq_driver check in cpufreq_boost_supported()
    
    Currently there are three calling paths for cpufreq_boost_supported() in
    all as below, we can see the cpufreq_driver null check is needless since
    it is already checked before.
    
    <path1>
      cpufreq_enable_boost_support()
        |-> if (!cpufreq_driver)
        |-> cpufreq_boost_supported()
    
    <path2>
      cpufreq_register_driver()
        |-> if (!driver_data ...
        |-> cpufreq_driver = driver_data
        |-> cpufreq_boost_supported()
        |-> remove_boost_sysfs_file()
              |-> cpufreq_boost_supported()
    
    <path3>
      cpufreq_unregister_driver()
        |-> if (!cpufreq_driver ...
        |-> remove_boost_sysfs_file()
              |-> cpufreq_boost_supported()
    
    Signed-off-by: Yue Hu <huyue2@yulong.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit e73e81975f2447e6f556100cada64a18ec631cbb
Author: Jiada Wang <jiada_wang@mentor.com>
Date:   Tue Jul 31 21:12:22 2018 +0900

    sched/debug: Fix potential deadlock when writing to sched_features
    
    The following lockdep report can be triggered by writing to /sys/kernel/debug/sched_features:
    
      ======================================================
      WARNING: possible circular locking dependency detected
      4.18.0-rc6-00152-gcd3f77d74ac3-dirty #18 Not tainted
      ------------------------------------------------------
      sh/3358 is trying to acquire lock:
      000000004ad3989d (cpu_hotplug_lock.rw_sem){++++}, at: static_key_enable+0x14/0x30
      but task is already holding lock:
      00000000c1b31a88 (&sb->s_type->i_mutex_key#3){+.+.}, at: sched_feat_write+0x160/0x428
      which lock already depends on the new lock.
      the existing dependency chain (in reverse order) is:
      -> #3 (&sb->s_type->i_mutex_key#3){+.+.}:
             lock_acquire+0xb8/0x148
             down_write+0xac/0x140
             start_creating+0x5c/0x168
             debugfs_create_dir+0x18/0x220
             opp_debug_register+0x8c/0x120
             _add_opp_dev+0x104/0x1f8
             dev_pm_opp_get_opp_table+0x174/0x340
             _of_add_opp_table_v2+0x110/0x760
             dev_pm_opp_of_add_table+0x5c/0x240
             dev_pm_opp_of_cpumask_add_table+0x5c/0x100
             cpufreq_init+0x160/0x430
             cpufreq_online+0x1cc/0xe30
             cpufreq_add_dev+0x78/0x198
             subsys_interface_register+0x168/0x270
             cpufreq_register_driver+0x1c8/0x278
             dt_cpufreq_probe+0xdc/0x1b8
             platform_drv_probe+0xb4/0x168
             driver_probe_device+0x318/0x4b0
             __device_attach_driver+0xfc/0x1f0
             bus_for_each_drv+0xf8/0x180
             __device_attach+0x164/0x200
             device_initial_probe+0x10/0x18
             bus_probe_device+0x110/0x178
             device_add+0x6d8/0x908
             platform_device_add+0x138/0x3d8
             platform_device_register_full+0x1cc/0x1f8
             cpufreq_dt_platdev_init+0x174/0x1bc
             do_one_initcall+0xb8/0x310
             kernel_init_freeable+0x4b8/0x56c
             kernel_init+0x10/0x138
             ret_from_fork+0x10/0x18
      -> #2 (opp_table_lock){+.+.}:
             lock_acquire+0xb8/0x148
             __mutex_lock+0x104/0xf50
             mutex_lock_nested+0x1c/0x28
             _of_add_opp_table_v2+0xb4/0x760
             dev_pm_opp_of_add_table+0x5c/0x240
             dev_pm_opp_of_cpumask_add_table+0x5c/0x100
             cpufreq_init+0x160/0x430
             cpufreq_online+0x1cc/0xe30
             cpufreq_add_dev+0x78/0x198
             subsys_interface_register+0x168/0x270
             cpufreq_register_driver+0x1c8/0x278
             dt_cpufreq_probe+0xdc/0x1b8
             platform_drv_probe+0xb4/0x168
             driver_probe_device+0x318/0x4b0
             __device_attach_driver+0xfc/0x1f0
             bus_for_each_drv+0xf8/0x180
             __device_attach+0x164/0x200
             device_initial_probe+0x10/0x18
             bus_probe_device+0x110/0x178
             device_add+0x6d8/0x908
             platform_device_add+0x138/0x3d8
             platform_device_register_full+0x1cc/0x1f8
             cpufreq_dt_platdev_init+0x174/0x1bc
             do_one_initcall+0xb8/0x310
             kernel_init_freeable+0x4b8/0x56c
             kernel_init+0x10/0x138
             ret_from_fork+0x10/0x18
      -> #1 (subsys mutex#6){+.+.}:
             lock_acquire+0xb8/0x148
             __mutex_lock+0x104/0xf50
             mutex_lock_nested+0x1c/0x28
             subsys_interface_register+0xd8/0x270
             cpufreq_register_driver+0x1c8/0x278
             dt_cpufreq_probe+0xdc/0x1b8
             platform_drv_probe+0xb4/0x168
             driver_probe_device+0x318/0x4b0
             __device_attach_driver+0xfc/0x1f0
             bus_for_each_drv+0xf8/0x180
             __device_attach+0x164/0x200
             device_initial_probe+0x10/0x18
             bus_probe_device+0x110/0x178
             device_add+0x6d8/0x908
             platform_device_add+0x138/0x3d8
             platform_device_register_full+0x1cc/0x1f8
             cpufreq_dt_platdev_init+0x174/0x1bc
             do_one_initcall+0xb8/0x310
             kernel_init_freeable+0x4b8/0x56c
             kernel_init+0x10/0x138
             ret_from_fork+0x10/0x18
      -> #0 (cpu_hotplug_lock.rw_sem){++++}:
             __lock_acquire+0x203c/0x21d0
             lock_acquire+0xb8/0x148
             cpus_read_lock+0x58/0x1c8
             static_key_enable+0x14/0x30
             sched_feat_write+0x314/0x428
             full_proxy_write+0xa0/0x138
             __vfs_write+0xd8/0x388
             vfs_write+0xdc/0x318
             ksys_write+0xb4/0x138
             sys_write+0xc/0x18
             __sys_trace_return+0x0/0x4
      other info that might help us debug this:
      Chain exists of:
        cpu_hotplug_lock.rw_sem --> opp_table_lock --> &sb->s_type->i_mutex_key#3
       Possible unsafe locking scenario:
             CPU0                    CPU1
             ----                    ----
        lock(&sb->s_type->i_mutex_key#3);
                                     lock(opp_table_lock);
                                     lock(&sb->s_type->i_mutex_key#3);
        lock(cpu_hotplug_lock.rw_sem);
       *** DEADLOCK ***
      2 locks held by sh/3358:
       #0: 00000000a8c4b363 (sb_writers#10){.+.+}, at: vfs_write+0x238/0x318
       #1: 00000000c1b31a88 (&sb->s_type->i_mutex_key#3){+.+.}, at: sched_feat_write+0x160/0x428
      stack backtrace:
      CPU: 5 PID: 3358 Comm: sh Not tainted 4.18.0-rc6-00152-gcd3f77d74ac3-dirty #18
      Hardware name: Renesas H3ULCB Kingfisher board based on r8a7795 ES2.0+ (DT)
      Call trace:
       dump_backtrace+0x0/0x288
       show_stack+0x14/0x20
       dump_stack+0x13c/0x1ac
       print_circular_bug.isra.10+0x270/0x438
       check_prev_add.constprop.16+0x4dc/0xb98
       __lock_acquire+0x203c/0x21d0
       lock_acquire+0xb8/0x148
       cpus_read_lock+0x58/0x1c8
       static_key_enable+0x14/0x30
       sched_feat_write+0x314/0x428
       full_proxy_write+0xa0/0x138
       __vfs_write+0xd8/0x388
       vfs_write+0xdc/0x318
       ksys_write+0xb4/0x138
       sys_write+0xc/0x18
       __sys_trace_return+0x0/0x4
    
    This is because when loading the cpufreq_dt module we first acquire
    cpu_hotplug_lock.rw_sem lock, then in cpufreq_init(), we are taking
    the &sb->s_type->i_mutex_key lock.
    
    But when writing to /sys/kernel/debug/sched_features, the
    cpu_hotplug_lock.rw_sem lock depends on the &sb->s_type->i_mutex_key lock.
    
    To fix this bug, reverse the lock acquisition order when writing to
    sched_features, this way cpu_hotplug_lock.rw_sem no longer depends on
    &sb->s_type->i_mutex_key.
    
    Tested-by: Dietmar Eggemann <dietmar.eggemann@arm.com>
    Signed-off-by: Jiada Wang <jiada_wang@mentor.com>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: Eugeniu Rosca <erosca@de.adit-jv.com>
    Cc: George G. Davis <george_davis@mentor.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/20180731121222.26195-1-jiada_wang@mentor.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 9b3d9bb3e4deef41095e513c2ffbebab20f9a982
Author: Waiman Long <longman@redhat.com>
Date:   Tue Jul 24 14:26:05 2018 -0400

    cpufreq: Fix a circular lock dependency problem
    
    With lockdep turned on, the following circular lock dependency problem
    was reported:
    
    [   57.470040] ======================================================
    [   57.502900] WARNING: possible circular locking dependency detected
    [   57.535208] 4.18.0-0.rc3.1.el8+7.x86_64+debug #1 Tainted: G
    [   57.577761] ------------------------------------------------------
    [   57.609714] tuned/1505 is trying to acquire lock:
    [   57.633808] 00000000559deec5 (cpu_hotplug_lock.rw_sem){++++}, at: store+0x27/0x120
    [   57.672880]
    [   57.672880] but task is already holding lock:
    [   57.702184] 000000002136ca64 (kn->count#118){++++}, at: kernfs_fop_write+0x1d0/0x410
    [   57.742176]
    [   57.742176] which lock already depends on the new lock.
    [   57.742176]
    [   57.785220]
    [   57.785220] the existing dependency chain (in reverse order) is:
        :
    [   58.932512] other info that might help us debug this:
    [   58.932512]
    [   58.973344] Chain exists of:
    [   58.973344]   cpu_hotplug_lock.rw_sem --> subsys mutex#5 --> kn->count#118
    [   58.973344]
    [   59.030795]  Possible unsafe locking scenario:
    [   59.030795]
    [   59.061248]        CPU0                    CPU1
    [   59.085377]        ----                    ----
    [   59.108160]   lock(kn->count#118);
    [   59.124935]                                lock(subsys mutex#5);
    [   59.156330]                                lock(kn->count#118);
    [   59.186088]   lock(cpu_hotplug_lock.rw_sem);
    [   59.208541]
    [   59.208541]  *** DEADLOCK ***
    
    In the cpufreq_register_driver() function, the lock sequence is:
    
      cpus_read_lock --> kn->count
    
    For the cpufreq sysfs store method, the lock sequence is:
    
      kn->count --> cpus_read_lock
    
    These sequences are actually safe as they are taking a share lock on
    cpu_hotplug_lock. However, the current lockdep code doesn't check for
    share locking when detecting circular lock dependency.  Fixing that
    could be a substantial effort.
    
    Instead, we can work around this problem by using cpus_read_trylock()
    in the store method which is much simpler. The chance of not getting
    the read lock is very small. If that happens, the userspace application
    that writes the sysfs file will get an error.
    
    Signed-off-by: Waiman Long <longman@redhat.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 1ecbd7170d6579a1ee389a37bf1f0437ea01a388
Author: George Cherian <george.cherian@cavium.com>
Date:   Mon Dec 4 14:06:54 2017 +0000

    ACPI / CPPC: Fix KASAN global out of bounds warning
    
    Default value of pcc_subspace_idx is -1.
    Make sure to check pcc_subspace_idx before using the same as array index.
    This will avoid following KASAN warnings too.
    
    [   15.113449] ==================================================================
    [   15.116983] BUG: KASAN: global-out-of-bounds in cppc_get_perf_caps+0xf3/0x3b0
    [   15.116983] Read of size 8 at addr ffffffffb9a5c0d8 by task swapper/0/1
    [   15.116983] CPU: 3 PID: 1 Comm: swapper/0 Not tainted 4.15.0-rc2+ #2
    [   15.116983] Hardware name: Dell Inc. OptiPlex 7040/0Y7WYT, BIOS 1.2.8 01/26/2016
    [   15.116983] Call Trace:
    [   15.116983]  dump_stack+0x7c/0xbb
    [   15.116983]  print_address_description+0x1df/0x290
    [   15.116983]  kasan_report+0x28a/0x370
    [   15.116983]  ? cppc_get_perf_caps+0xf3/0x3b0
    [   15.116983]  cppc_get_perf_caps+0xf3/0x3b0
    [   15.116983]  ? cpc_read+0x210/0x210
    [   15.116983]  ? __rdmsr_on_cpu+0x90/0x90
    [   15.116983]  ? rdmsrl_on_cpu+0xa9/0xe0
    [   15.116983]  ? rdmsr_on_cpu+0x100/0x100
    [   15.116983]  ? wrmsrl_on_cpu+0x9c/0xd0
    [   15.116983]  ? wrmsrl_on_cpu+0x9c/0xd0
    [   15.116983]  ? wrmsr_on_cpu+0xe0/0xe0
    [   15.116983]  __intel_pstate_cpu_init.part.16+0x3a2/0x530
    [   15.116983]  ? intel_pstate_init_cpu+0x197/0x390
    [   15.116983]  ? show_no_turbo+0xe0/0xe0
    [   15.116983]  ? __lockdep_init_map+0xa0/0x290
    [   15.116983]  intel_pstate_cpu_init+0x30/0x60
    [   15.116983]  cpufreq_online+0x155/0xac0
    [   15.116983]  cpufreq_add_dev+0x9b/0xb0
    [   15.116983]  subsys_interface_register+0x1ae/0x290
    [   15.116983]  ? bus_unregister_notifier+0x40/0x40
    [   15.116983]  ? mark_held_locks+0x83/0xb0
    [   15.116983]  ? _raw_write_unlock_irqrestore+0x32/0x60
    [   15.116983]  ? intel_pstate_setup+0xc/0x104
    [   15.116983]  ? intel_pstate_setup+0xc/0x104
    [   15.116983]  ? cpufreq_register_driver+0x1ce/0x2b0
    [   15.116983]  cpufreq_register_driver+0x1ce/0x2b0
    [   15.116983]  ? intel_pstate_setup+0x104/0x104
    [   15.116983]  intel_pstate_register_driver+0x3a/0xa0
    [   15.116983]  intel_pstate_init+0x3c4/0x434
    [   15.116983]  ? intel_pstate_setup+0x104/0x104
    [   15.116983]  ? intel_pstate_setup+0x104/0x104
    [   15.116983]  do_one_initcall+0x9c/0x206
    [   15.116983]  ? parameq+0xa0/0xa0
    [   15.116983]  ? initcall_blacklisted+0x150/0x150
    [   15.116983]  ? lock_downgrade+0x2c0/0x2c0
    [   15.116983]  kernel_init_freeable+0x327/0x3f0
    [   15.116983]  ? start_kernel+0x612/0x612
    [   15.116983]  ? _raw_spin_unlock_irq+0x29/0x40
    [   15.116983]  ? finish_task_switch+0xdd/0x320
    [   15.116983]  ? finish_task_switch+0x8e/0x320
    [   15.116983]  ? rest_init+0xd0/0xd0
    [   15.116983]  kernel_init+0xf/0x11a
    [   15.116983]  ? rest_init+0xd0/0xd0
    [   15.116983]  ret_from_fork+0x24/0x30
    
    [   15.116983] The buggy address belongs to the variable:
    [   15.116983]  __key.36299+0x38/0x40
    
    [   15.116983] Memory state around the buggy address:
    [   15.116983]  ffffffffb9a5bf80: fa fa fa fa 00 fa fa fa fa fa fa fa 00 fa fa fa
    [   15.116983]  ffffffffb9a5c000: fa fa fa fa 00 fa fa fa fa fa fa fa 00 fa fa fa
    [   15.116983] >ffffffffb9a5c080: fa fa fa fa 00 fa fa fa fa fa fa fa 00 00 00 00
    [   15.116983]                                                     ^
    [   15.116983]  ffffffffb9a5c100: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    [   15.116983]  ffffffffb9a5c180: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    [   15.116983] ==================================================================
    
    Fixes: 85b1407bf6d2 (ACPI / CPPC: Make CPPC ACPI driver aware of PCC subspace IDs)
    Reported-by: Changbin Du <changbin.du@intel.com>
    Signed-off-by: George Cherian <george.cherian@cavium.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 0eedb7832e10f43980766f210b74cee15d983352
Author: David Arcari <darcari@redhat.com>
Date:   Fri May 26 11:37:31 2017 -0400

    cpufreq: cpufreq_register_driver() should return -ENODEV if init fails
    
    commit 6c77003677d5f1ce15f26d24360cb66c0bc07bb3 upstream.
    
    For a driver that does not set the CPUFREQ_STICKY flag, if all of the
    ->init() calls fail, cpufreq_register_driver() should return an error.
    This will prevent the driver from loading.
    
    Fixes: ce1bcfe94db8 (cpufreq: check cpufreq_policy_list instead of scanning policies for all CPUs)
    Signed-off-by: David Arcari <darcari@redhat.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 96d7b43b42ba55c55da2e45c9926f105565ab2d8
Author: David Arcari <darcari@redhat.com>
Date:   Fri May 26 11:37:31 2017 -0400

    cpufreq: cpufreq_register_driver() should return -ENODEV if init fails
    
    commit 6c77003677d5f1ce15f26d24360cb66c0bc07bb3 upstream.
    
    For a driver that does not set the CPUFREQ_STICKY flag, if all of the
    ->init() calls fail, cpufreq_register_driver() should return an error.
    This will prevent the driver from loading.
    
    Fixes: ce1bcfe94db8 (cpufreq: check cpufreq_policy_list instead of scanning policies for all CPUs)
    Signed-off-by: David Arcari <darcari@redhat.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 94d3dafe96f321dfe5e7c3542f1c00c4125984b4
Author: David Arcari <darcari@redhat.com>
Date:   Fri May 26 11:37:31 2017 -0400

    cpufreq: cpufreq_register_driver() should return -ENODEV if init fails
    
    commit 6c77003677d5f1ce15f26d24360cb66c0bc07bb3 upstream.
    
    For a driver that does not set the CPUFREQ_STICKY flag, if all of the
    ->init() calls fail, cpufreq_register_driver() should return an error.
    This will prevent the driver from loading.
    
    Fixes: ce1bcfe94db8 (cpufreq: check cpufreq_policy_list instead of scanning policies for all CPUs)
    Signed-off-by: David Arcari <darcari@redhat.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 5df474e63ca56a79c41fce7530882b6ff30eed37
Author: David Arcari <darcari@redhat.com>
Date:   Fri May 26 11:37:31 2017 -0400

    cpufreq: cpufreq_register_driver() should return -ENODEV if init fails
    
    [ Upstream commit 6c77003677d5f1ce15f26d24360cb66c0bc07bb3 ]
    
    For a driver that does not set the CPUFREQ_STICKY flag, if all of the
    ->init() calls fail, cpufreq_register_driver() should return an error.
    This will prevent the driver from loading.
    
    Fixes: ce1bcfe94db8 (cpufreq: check cpufreq_policy_list instead of scanning policies for all CPUs)
    Cc: 4.0+ <stable@vger.kernel.org> # 4.0+
    Signed-off-by: David Arcari <darcari@redhat.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Sasha Levin <alexander.levin@verizon.com>

commit 57caf4ec2b8bfbcb4f738ab5a12eedf3a8786045
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Jun 5 14:51:18 2017 +0200

    cpufreq: intel_pstate: Avoid division by 0 in min_perf_pct_min()
    
    Commit c5a2ee7dde89 (cpufreq: intel_pstate: Active mode P-state
    limits rework) incorrectly assumed that pstate.turbo_pstate would
    always be nonzero for CPU0 in min_perf_pct_min() if
    cpufreq_register_driver() had succeeded which may not be the case
    in virtualized environments.
    
    If that assumption doesn't hold, it leads to an early crash on boot
    in intel_pstate_register_driver(), so add a sanity check to
    min_perf_pct_min() to prevent the crash from happening.
    
    Fixes: c5a2ee7dde89 (cpufreq: intel_pstate: Active mode P-state limits rework)
    Reported-and-tested-by: Jongman Heo <jongman.heo@samsung.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 89af529a6469d612258fce5745a7d45430f316ce
Merge: 5a4829b564d2 bb5710e72c21
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jun 2 16:33:33 2017 -0700

    Merge tag 'pm-4.12-rc4' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull power management fixes from Rafael Wysocki:
     "These fix two bugs in error code paths in the cpufreq core and in the
      kirkwood-cpufreq driver.
    
      Specifics:
    
       - Make cpufreq_register_driver() return an error if the ->init()
         calls fail for all CPUs to prevent non-functional drivers from
         hanging around for no reason (David Arcari).
    
       - Make kirkwood-cpufreq check the return value of
         clk_prepare_enable() (which may fail) as appropriate (Arvind
         Yadav)"
    
    * tag 'pm-4.12-rc4' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm:
      cpufreq: kirkwood-cpufreq:- Handle return value of clk_prepare_enable()
      cpufreq: cpufreq_register_driver() should return -ENODEV if init fails

commit bb5710e72c217e5bbdf0969a2fd84f5f5ad7fc2b
Merge: 5ed02dbb4974 7575f8257279
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Jun 3 00:01:45 2017 +0200

    Merge branch 'pm-cpufreq'
    
    * pm-cpufreq:
      cpufreq: kirkwood-cpufreq:- Handle return value of clk_prepare_enable()
      cpufreq: cpufreq_register_driver() should return -ENODEV if init fails

commit 6c77003677d5f1ce15f26d24360cb66c0bc07bb3
Author: David Arcari <darcari@redhat.com>
Date:   Fri May 26 11:37:31 2017 -0400

    cpufreq: cpufreq_register_driver() should return -ENODEV if init fails
    
    For a driver that does not set the CPUFREQ_STICKY flag, if all of the
    ->init() calls fail, cpufreq_register_driver() should return an error.
    This will prevent the driver from loading.
    
    Fixes: ce1bcfe94db8 (cpufreq: check cpufreq_policy_list instead of scanning policies for all CPUs)
    Cc: 4.0+ <stable@vger.kernel.org> # 4.0+
    Signed-off-by: David Arcari <darcari@redhat.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 606f42265d384b9149bfb953c5dfc6d4710fef4c
Author: Prashanth Prakash <pprakash@codeaurora.org>
Date:   Thu Jan 26 11:08:32 2017 -0700

    arm64: skip register_cpufreq_notifier on ACPI-based systems
    
    On ACPI based systems where the topology is setup using the API
    store_cpu_topology, at the moment we do not have necessary code
    to parse cpu capacity and handle cpufreq notifier, thus
    resulting in a kernel panic.
    
    Stack:
            init_cpu_capacity_callback+0xb4/0x1c8
            notifier_call_chain+0x5c/0xa0
            __blocking_notifier_call_chain+0x58/0xa0
            blocking_notifier_call_chain+0x3c/0x50
            cpufreq_set_policy+0xe4/0x328
            cpufreq_init_policy+0x80/0x100
            cpufreq_online+0x418/0x710
            cpufreq_add_dev+0x118/0x180
            subsys_interface_register+0xa4/0xf8
            cpufreq_register_driver+0x1c0/0x298
            cppc_cpufreq_init+0xdc/0x1000 [cppc_cpufreq]
            do_one_initcall+0x5c/0x168
            do_init_module+0x64/0x1e4
            load_module+0x130c/0x14d0
            SyS_finit_module+0x108/0x120
            el0_svc_naked+0x24/0x28
    
    Fixes: 7202bde8b7ae ("arm64: parse cpu capacity-dmips-mhz from DT")
    Acked-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Prashanth Prakash <pprakash@codeaurora.org>
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>

commit 9e607f72748ddc5620aeeb8d1f32f30c79b360b9
Author: Denis Kirjanov <kda@linux-powerpc.org>
Date:   Wed Sep 21 14:34:58 2016 +0300

    i2c_powermac: shut up lockdep warning
    
    That's unclear why lockdep shows the following warning but adding a
    lockdep class to struct pmac_i2c_bus solves it
    
    [   20.507795] ======================================================
    [   20.507796] [ INFO: possible circular locking dependency detected ]
    [   20.507800] 4.8.0-rc7-00037-gd2ffb01 #21 Not tainted
    [   20.507801] -------------------------------------------------------
    [   20.507803] swapper/0/1 is trying to acquire lock:
    [   20.507818]  (&bus->mutex){+.+.+.}, at: [<c000000000052830>] .pmac_i2c_open+0x30/0x100
    [   20.507819]
    [   20.507819] but task is already holding lock:
    [   20.507829]  (&policy->rwsem){+.+.+.}, at: [<c00000000068adcc>] .cpufreq_online+0x1ac/0x9d0
    [   20.507830]
    [   20.507830] which lock already depends on the new lock.
    [   20.507830]
    [   20.507832]
    [   20.507832] the existing dependency chain (in reverse order) is:
    [   20.507837]
    [   20.507837] -> #4 (&policy->rwsem){+.+.+.}:
    [   20.507844]        [<c00000000082385c>] .down_write+0x6c/0x110
    [   20.507849]        [<c00000000068adcc>] .cpufreq_online+0x1ac/0x9d0
    [   20.507855]        [<c0000000004d76d8>] .subsys_interface_register+0xb8/0x110
    [   20.507860]        [<c000000000689bb0>] .cpufreq_register_driver+0x1d0/0x250
    [   20.507866]        [<c000000000b4f8f4>] .g5_cpufreq_init+0x9cc/0xa28
    [   20.507872]        [<c00000000000a98c>] .do_one_initcall+0x5c/0x1d0
    [   20.507878]        [<c000000000b0f86c>] .kernel_init_freeable+0x1ac/0x28c
    [   20.507883]        [<c00000000000b3bc>] .kernel_init+0x1c/0x140
    [   20.507887]        [<c0000000000098f4>] .ret_from_kernel_thread+0x58/0x64
    [   20.507894]
    [   20.507894] -> #3 (subsys mutex#2){+.+.+.}:
    [   20.507899]        [<c000000000820448>] .mutex_lock_nested+0xa8/0x590
    [   20.507903]        [<c0000000004d7f24>] .bus_probe_device+0x44/0xe0
    [   20.507907]        [<c0000000004d5208>] .device_add+0x508/0x730
    [   20.507911]        [<c0000000004dd528>] .register_cpu+0x118/0x190
    [   20.507916]        [<c000000000b14450>] .topology_init+0x148/0x248
    [   20.507921]        [<c00000000000a98c>] .do_one_initcall+0x5c/0x1d0
    [   20.507925]        [<c000000000b0f86c>] .kernel_init_freeable+0x1ac/0x28c
    [   20.507929]        [<c00000000000b3bc>] .kernel_init+0x1c/0x140
    [   20.507934]        [<c0000000000098f4>] .ret_from_kernel_thread+0x58/0x64
    [   20.507939]
    [   20.507939] -> #2 (cpu_add_remove_lock){+.+.+.}:
    [   20.507944]        [<c000000000820448>] .mutex_lock_nested+0xa8/0x590
    [   20.507950]        [<c000000000087a9c>] .register_cpu_notifier+0x2c/0x70
    [   20.507955]        [<c000000000b267e0>] .spawn_ksoftirqd+0x18/0x4c
    [   20.507959]        [<c00000000000a98c>] .do_one_initcall+0x5c/0x1d0
    [   20.507964]        [<c000000000b0f770>] .kernel_init_freeable+0xb0/0x28c
    [   20.507968]        [<c00000000000b3bc>] .kernel_init+0x1c/0x140
    [   20.507972]        [<c0000000000098f4>] .ret_from_kernel_thread+0x58/0x64
    [   20.507978]
    [   20.507978] -> #1 (&host->mutex){+.+.+.}:
    [   20.507982]        [<c000000000820448>] .mutex_lock_nested+0xa8/0x590
    [   20.507987]        [<c0000000000527e8>] .kw_i2c_open+0x18/0x30
    [   20.507991]        [<c000000000052894>] .pmac_i2c_open+0x94/0x100
    [   20.507995]        [<c000000000b220a0>] .smp_core99_probe+0x260/0x410
    [   20.507999]        [<c000000000b185bc>] .smp_prepare_cpus+0x280/0x2ac
    [   20.508003]        [<c000000000b0f748>] .kernel_init_freeable+0x88/0x28c
    [   20.508008]        [<c00000000000b3bc>] .kernel_init+0x1c/0x140
    [   20.508012]        [<c0000000000098f4>] .ret_from_kernel_thread+0x58/0x64
    [   20.508018]
    [   20.508018] -> #0 (&bus->mutex){+.+.+.}:
    [   20.508023]        [<c0000000000ed5b4>] .lock_acquire+0x84/0x100
    [   20.508027]        [<c000000000820448>] .mutex_lock_nested+0xa8/0x590
    [   20.508032]        [<c000000000052830>] .pmac_i2c_open+0x30/0x100
    [   20.508037]        [<c000000000052e14>] .pmac_i2c_do_begin+0x34/0x120
    [   20.508040]        [<c000000000056bc0>] .pmf_call_one+0x50/0xd0
    [   20.508045]        [<c00000000068ff1c>] .g5_pfunc_switch_volt+0x2c/0xc0
    [   20.508050]        [<c00000000068fecc>] .g5_pfunc_switch_freq+0x1cc/0x1f0
    [   20.508054]        [<c00000000068fc2c>] .g5_cpufreq_target+0x2c/0x40
    [   20.508058]        [<c0000000006873ec>] .__cpufreq_driver_target+0x23c/0x840
    [   20.508062]        [<c00000000068c798>] .cpufreq_gov_performance_limits+0x18/0x30
    [   20.508067]        [<c00000000068915c>] .cpufreq_start_governor+0xac/0x100
    [   20.508071]        [<c00000000068a788>] .cpufreq_set_policy+0x208/0x260
    [   20.508076]        [<c00000000068abdc>] .cpufreq_init_policy+0x6c/0xb0
    [   20.508081]        [<c00000000068ae70>] .cpufreq_online+0x250/0x9d0
    [   20.508085]        [<c0000000004d76d8>] .subsys_interface_register+0xb8/0x110
    [   20.508090]        [<c000000000689bb0>] .cpufreq_register_driver+0x1d0/0x250
    [   20.508094]        [<c000000000b4f8f4>] .g5_cpufreq_init+0x9cc/0xa28
    [   20.508099]        [<c00000000000a98c>] .do_one_initcall+0x5c/0x1d0
    [   20.508103]        [<c000000000b0f86c>] .kernel_init_freeable+0x1ac/0x28c
    [   20.508107]        [<c00000000000b3bc>] .kernel_init+0x1c/0x140
    [   20.508112]        [<c0000000000098f4>] .ret_from_kernel_thread+0x58/0x64
    [   20.508113]
    [   20.508113] other info that might help us debug this:
    [   20.508113]
    [   20.508121] Chain exists of:
    [   20.508121]   &bus->mutex --> subsys mutex#2 --> &policy->rwsem
    [   20.508121]
    [   20.508123]  Possible unsafe locking scenario:
    [   20.508123]
    [   20.508124]        CPU0                    CPU1
    [   20.508125]        ----                    ----
    [   20.508128]   lock(&policy->rwsem);
    [   20.508132]                                lock(subsys mutex#2);
    [   20.508135]                                lock(&policy->rwsem);
    [   20.508138]   lock(&bus->mutex);
    [   20.508139]
    [   20.508139]  *** DEADLOCK ***
    [   20.508139]
    [   20.508141] 3 locks held by swapper/0/1:
    [   20.508150]  #0:  (cpu_hotplug.lock){++++++}, at: [<c000000000087838>] .get_online_cpus+0x48/0xc0
    [   20.508159]  #1:  (subsys mutex#2){+.+.+.}, at: [<c0000000004d7670>] .subsys_interface_register+0x50/0x110
    [   20.508168]  #2:  (&policy->rwsem){+.+.+.}, at: [<c00000000068adcc>] .cpufreq_online+0x1ac/0x9d0
    [   20.508169]
    [   20.508169] stack backtrace:
    [   20.508173] CPU: 0 PID: 1 Comm: swapper/0 Not tainted 4.8.0-rc7-00037-gd2ffb01 #21
    [   20.508175] Call Trace:
    [   20.508180] [c0000000790c2b90] [c00000000082cc70] .dump_stack+0xe0/0x14c (unreliable)
    [   20.508184] [c0000000790c2c20] [c000000000828c88] .print_circular_bug+0x350/0x388
    [   20.508188] [c0000000790c2cd0] [c0000000000ecb0c] .__lock_acquire+0x196c/0x1d30
    [   20.508192] [c0000000790c2e50] [c0000000000ed5b4] .lock_acquire+0x84/0x100
    [   20.508196] [c0000000790c2f20] [c000000000820448] .mutex_lock_nested+0xa8/0x590
    [   20.508201] [c0000000790c3030] [c000000000052830] .pmac_i2c_open+0x30/0x100
    [   20.508206] [c0000000790c30c0] [c000000000052e14] .pmac_i2c_do_begin+0x34/0x120
    [   20.508209] [c0000000790c3150] [c000000000056bc0] .pmf_call_one+0x50/0xd0
    [   20.508213] [c0000000790c31e0] [c00000000068ff1c] .g5_pfunc_switch_volt+0x2c/0xc0
    [   20.508217] [c0000000790c3250] [c00000000068fecc] .g5_pfunc_switch_freq+0x1cc/0x1f0
    [   20.508221] [c0000000790c3320] [c00000000068fc2c] .g5_cpufreq_target+0x2c/0x40
    [   20.508226] [c0000000790c3390] [c0000000006873ec] .__cpufreq_driver_target+0x23c/0x840
    [   20.508230] [c0000000790c3440] [c00000000068c798] .cpufreq_gov_performance_limits+0x18/0x30
    [   20.508235] [c0000000790c34b0] [c00000000068915c] .cpufreq_start_governor+0xac/0x100
    [   20.508239] [c0000000790c3530] [c00000000068a788] .cpufreq_set_policy+0x208/0x260
    [   20.508244] [c0000000790c35d0] [c00000000068abdc] .cpufreq_init_policy+0x6c/0xb0
    [   20.508249] [c0000000790c3940] [c00000000068ae70] .cpufreq_online+0x250/0x9d0
    [   20.508253] [c0000000790c3a30] [c0000000004d76d8] .subsys_interface_register+0xb8/0x110
    [   20.508258] [c0000000790c3ad0] [c000000000689bb0] .cpufreq_register_driver+0x1d0/0x250
    [   20.508262] [c0000000790c3b60] [c000000000b4f8f4] .g5_cpufreq_init+0x9cc/0xa28
    [   20.508267] [c0000000790c3c20] [c00000000000a98c] .do_one_initcall+0x5c/0x1d0
    [   20.508271] [c0000000790c3d00] [c000000000b0f86c] .kernel_init_freeable+0x1ac/0x28c
    [   20.508276] [c0000000790c3db0] [c00000000000b3bc] .kernel_init+0x1c/0x140
    [   20.508280] [c0000000790c3e30] [c0000000000098f4] .ret_from_kernel_thread+0x58/0x64
    
    Signed-off-by: Denis Kirjanov <kda@linux-powerpc.org>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

commit dc04e6ce01005b511a2371726553992f27109f5d
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Sat Oct 8 12:42:38 2016 -0700

    cpufreq: intel_pstate: Fix unsafe HWP MSR access
    
    commit f9f4872df6e1801572949f8a370c886122d4b6da upstream.
    
    This is a requirement that MSR MSR_PM_ENABLE must be set to 0x01 before
    reading MSR_HWP_CAPABILITIES on a given CPU. If cpufreq init() is
    scheduled on a CPU which is not same as policy->cpu or migrates to a
    different CPU before calling msr read for MSR_HWP_CAPABILITIES, it
    is possible that MSR_PM_ENABLE was not to set to 0x01 on that CPU.
    This will cause GP fault. So like other places in this path
    rdmsrl_on_cpu should be used instead of rdmsrl.
    
    Moreover the scope of MSR_HWP_CAPABILITIES is on per thread basis, so it
    should be read from the same CPU, for which MSR MSR_HWP_REQUEST is
    getting set.
    
    dmesg dump or warning:
    
    [   22.014488] WARNING: CPU: 139 PID: 1 at arch/x86/mm/extable.c:50 ex_handler_rdmsr_unsafe+0x68/0x70
    [   22.014492] unchecked MSR access error: RDMSR from 0x771
    [   22.014493] Modules linked in:
    [   22.014507] CPU: 139 PID: 1 Comm: swapper/0 Not tainted 4.7.5+ #1
    ...
    ...
    [   22.014516] Call Trace:
    [   22.014542]  [<ffffffff813d7dd1>] dump_stack+0x63/0x82
    [   22.014558]  [<ffffffff8107bc8b>] __warn+0xcb/0xf0
    [   22.014561]  [<ffffffff8107bcff>] warn_slowpath_fmt+0x4f/0x60
    [   22.014563]  [<ffffffff810676f8>] ex_handler_rdmsr_unsafe+0x68/0x70
    [   22.014564]  [<ffffffff810677d9>] fixup_exception+0x39/0x50
    [   22.014604]  [<ffffffff8102e400>] do_general_protection+0x80/0x150
    [   22.014610]  [<ffffffff817f9ec8>] general_protection+0x28/0x30
    [   22.014635]  [<ffffffff81687940>] ? get_target_pstate_use_performance+0xb0/0xb0
    [   22.014642]  [<ffffffff810600c7>] ? native_read_msr+0x7/0x40
    [   22.014657]  [<ffffffff81688123>] intel_pstate_hwp_set+0x23/0x130
    [   22.014660]  [<ffffffff81688406>] intel_pstate_set_policy+0x1b6/0x340
    [   22.014662]  [<ffffffff816829bb>] cpufreq_set_policy+0xeb/0x2c0
    [   22.014664]  [<ffffffff81682f39>] cpufreq_init_policy+0x79/0xe0
    [   22.014666]  [<ffffffff81682cb0>] ? cpufreq_update_policy+0x120/0x120
    [   22.014669]  [<ffffffff816833a6>] cpufreq_online+0x406/0x820
    [   22.014671]  [<ffffffff8168381f>] cpufreq_add_dev+0x5f/0x90
    [   22.014717]  [<ffffffff81530ac8>] subsys_interface_register+0xb8/0x100
    [   22.014719]  [<ffffffff816821bc>] cpufreq_register_driver+0x14c/0x210
    [   22.014749]  [<ffffffff81fe1d90>] intel_pstate_init+0x39d/0x4d5
    [   22.014751]  [<ffffffff81fe13f2>] ? cpufreq_gov_dbs_init+0x12/0x12
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit d756b52c8bbe7735cc881dab46378518d2d4b1f1
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Sat Oct 8 12:42:38 2016 -0700

    cpufreq: intel_pstate: Fix unsafe HWP MSR access
    
    commit f9f4872df6e1801572949f8a370c886122d4b6da upstream.
    
    This is a requirement that MSR MSR_PM_ENABLE must be set to 0x01 before
    reading MSR_HWP_CAPABILITIES on a given CPU. If cpufreq init() is
    scheduled on a CPU which is not same as policy->cpu or migrates to a
    different CPU before calling msr read for MSR_HWP_CAPABILITIES, it
    is possible that MSR_PM_ENABLE was not to set to 0x01 on that CPU.
    This will cause GP fault. So like other places in this path
    rdmsrl_on_cpu should be used instead of rdmsrl.
    
    Moreover the scope of MSR_HWP_CAPABILITIES is on per thread basis, so it
    should be read from the same CPU, for which MSR MSR_HWP_REQUEST is
    getting set.
    
    dmesg dump or warning:
    
    [   22.014488] WARNING: CPU: 139 PID: 1 at arch/x86/mm/extable.c:50 ex_handler_rdmsr_unsafe+0x68/0x70
    [   22.014492] unchecked MSR access error: RDMSR from 0x771
    [   22.014493] Modules linked in:
    [   22.014507] CPU: 139 PID: 1 Comm: swapper/0 Not tainted 4.7.5+ #1
    ...
    ...
    [   22.014516] Call Trace:
    [   22.014542]  [<ffffffff813d7dd1>] dump_stack+0x63/0x82
    [   22.014558]  [<ffffffff8107bc8b>] __warn+0xcb/0xf0
    [   22.014561]  [<ffffffff8107bcff>] warn_slowpath_fmt+0x4f/0x60
    [   22.014563]  [<ffffffff810676f8>] ex_handler_rdmsr_unsafe+0x68/0x70
    [   22.014564]  [<ffffffff810677d9>] fixup_exception+0x39/0x50
    [   22.014604]  [<ffffffff8102e400>] do_general_protection+0x80/0x150
    [   22.014610]  [<ffffffff817f9ec8>] general_protection+0x28/0x30
    [   22.014635]  [<ffffffff81687940>] ? get_target_pstate_use_performance+0xb0/0xb0
    [   22.014642]  [<ffffffff810600c7>] ? native_read_msr+0x7/0x40
    [   22.014657]  [<ffffffff81688123>] intel_pstate_hwp_set+0x23/0x130
    [   22.014660]  [<ffffffff81688406>] intel_pstate_set_policy+0x1b6/0x340
    [   22.014662]  [<ffffffff816829bb>] cpufreq_set_policy+0xeb/0x2c0
    [   22.014664]  [<ffffffff81682f39>] cpufreq_init_policy+0x79/0xe0
    [   22.014666]  [<ffffffff81682cb0>] ? cpufreq_update_policy+0x120/0x120
    [   22.014669]  [<ffffffff816833a6>] cpufreq_online+0x406/0x820
    [   22.014671]  [<ffffffff8168381f>] cpufreq_add_dev+0x5f/0x90
    [   22.014717]  [<ffffffff81530ac8>] subsys_interface_register+0xb8/0x100
    [   22.014719]  [<ffffffff816821bc>] cpufreq_register_driver+0x14c/0x210
    [   22.014749]  [<ffffffff81fe1d90>] intel_pstate_init+0x39d/0x4d5
    [   22.014751]  [<ffffffff81fe13f2>] ? cpufreq_gov_dbs_init+0x12/0x12
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit f9f4872df6e1801572949f8a370c886122d4b6da
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Sat Oct 8 12:42:38 2016 -0700

    cpufreq: intel_pstate: Fix unsafe HWP MSR access
    
    This is a requirement that MSR MSR_PM_ENABLE must be set to 0x01 before
    reading MSR_HWP_CAPABILITIES on a given CPU. If cpufreq init() is
    scheduled on a CPU which is not same as policy->cpu or migrates to a
    different CPU before calling msr read for MSR_HWP_CAPABILITIES, it
    is possible that MSR_PM_ENABLE was not to set to 0x01 on that CPU.
    This will cause GP fault. So like other places in this path
    rdmsrl_on_cpu should be used instead of rdmsrl.
    
    Moreover the scope of MSR_HWP_CAPABILITIES is on per thread basis, so it
    should be read from the same CPU, for which MSR MSR_HWP_REQUEST is
    getting set.
    
    dmesg dump or warning:
    
    [   22.014488] WARNING: CPU: 139 PID: 1 at arch/x86/mm/extable.c:50 ex_handler_rdmsr_unsafe+0x68/0x70
    [   22.014492] unchecked MSR access error: RDMSR from 0x771
    [   22.014493] Modules linked in:
    [   22.014507] CPU: 139 PID: 1 Comm: swapper/0 Not tainted 4.7.5+ #1
    ...
    ...
    [   22.014516] Call Trace:
    [   22.014542]  [<ffffffff813d7dd1>] dump_stack+0x63/0x82
    [   22.014558]  [<ffffffff8107bc8b>] __warn+0xcb/0xf0
    [   22.014561]  [<ffffffff8107bcff>] warn_slowpath_fmt+0x4f/0x60
    [   22.014563]  [<ffffffff810676f8>] ex_handler_rdmsr_unsafe+0x68/0x70
    [   22.014564]  [<ffffffff810677d9>] fixup_exception+0x39/0x50
    [   22.014604]  [<ffffffff8102e400>] do_general_protection+0x80/0x150
    [   22.014610]  [<ffffffff817f9ec8>] general_protection+0x28/0x30
    [   22.014635]  [<ffffffff81687940>] ? get_target_pstate_use_performance+0xb0/0xb0
    [   22.014642]  [<ffffffff810600c7>] ? native_read_msr+0x7/0x40
    [   22.014657]  [<ffffffff81688123>] intel_pstate_hwp_set+0x23/0x130
    [   22.014660]  [<ffffffff81688406>] intel_pstate_set_policy+0x1b6/0x340
    [   22.014662]  [<ffffffff816829bb>] cpufreq_set_policy+0xeb/0x2c0
    [   22.014664]  [<ffffffff81682f39>] cpufreq_init_policy+0x79/0xe0
    [   22.014666]  [<ffffffff81682cb0>] ? cpufreq_update_policy+0x120/0x120
    [   22.014669]  [<ffffffff816833a6>] cpufreq_online+0x406/0x820
    [   22.014671]  [<ffffffff8168381f>] cpufreq_add_dev+0x5f/0x90
    [   22.014717]  [<ffffffff81530ac8>] subsys_interface_register+0xb8/0x100
    [   22.014719]  [<ffffffff816821bc>] cpufreq_register_driver+0x14c/0x210
    [   22.014749]  [<ffffffff81fe1d90>] intel_pstate_init+0x39d/0x4d5
    [   22.014751]  [<ffffffff81fe13f2>] ? cpufreq_gov_dbs_init+0x12/0x12
    
    Cc: 4.3+ <stable@vger.kernel.org> # 4.3+
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 5372e054a1928fe704cf0a5e2e139645a777b50a
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Tue Sep 20 16:56:28 2016 +0200

    cpufreq: Fix up conversion to hotplug state machine
    
    The function cpufreq_register_driver() returns zero on success and since
    commit 27622b061eb4 ("cpufreq: Convert to hotplug state machine")
    erroneously a positive number. Due to the "if (x) assume_error" construct
    all callers assumed an error and as a consequence the cpu freq kworker
    crashes with a NULL pointer dereference.
    
    Reset the return value back to zero in the success case.
    
    Fixes: 27622b061eb4 ("cpufreq: Convert to hotplug state machine")
    Reported-by: Borislav Petkov <bp@alien8.de>
    Reported-and-tested-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Cc: peterz@infradead.org
    Cc: rjw@rjwysocki.net
    Link: http://lkml.kernel.org/r/20160920145628.lp2bmq72ip3oiash@linutronix.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 877c057d2b3cdac9f44c0fbe48e4208375395bf0
Merge: ecc5fbd5ef47 4c2628cd7580
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed May 25 15:29:21 2016 -0700

    Merge tag 'pm-4.7-rc1-more' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull more power management updates from Rafael Wysocki:
     "These are two stable-candidate fixes (PM core, cpuidle) and a bunch of
      cpufreq cleanups.
    
      Specifics:
    
       - Stable-candidate cpuidle fix to make it check the right variable
         when deciding whether or not to enable interrupts on the local CPU
         so as to avoid enabling iterrupts too early in some cases if the
         system has both coupled and per-core idle states (Daniel Lezcano).
    
       - Stable-candidate PM core fix to make it handle failures at the
         "late suspend" stage of device suspend consistently for all devices
         regardless of whether or not async suspend/resume is enabled for
         them (Rafael Wysocki).
    
       - Cleanups in the cpufreq core, the schedutil governor and the
         intel_pstate driver (Rafael Wysocki, Pankaj Gupta, Viresh Kumar)"
    
    * tag 'pm-4.7-rc1-more' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm:
      PM / sleep: Handle failures in device_suspend_late() consistently
      cpufreq: schedutil: Improve prints messages with pr_fmt
      cpuidle: Fix cpuidle_state_is_coupled() argument in cpuidle_enter()
      cpufreq: simplified goto out in cpufreq_register_driver()
      cpufreq: governor: CPUFREQ_GOV_STOP never fails
      cpufreq: governor: CPUFREQ_GOV_POLICY_EXIT never fails
      intel_pstate: Simplify conditional in intel_pstate_set_policy()

commit 4c2628cd7580bc4f4a4994925cf366185ecc37a5
Merge: d57d39431924 60f05e86cf3e e7387da52028 3a17fb329da6
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed May 25 21:54:45 2016 +0200

    Merge branches 'pm-cpufreq', 'pm-cpuidle' and 'pm-core'
    
    * pm-cpufreq:
      cpufreq: schedutil: Improve prints messages with pr_fmt
      cpufreq: simplified goto out in cpufreq_register_driver()
      cpufreq: governor: CPUFREQ_GOV_STOP never fails
      cpufreq: governor: CPUFREQ_GOV_POLICY_EXIT never fails
      intel_pstate: Simplify conditional in intel_pstate_set_policy()
    
    * pm-cpuidle:
      cpuidle: Fix cpuidle_state_is_coupled() argument in cpuidle_enter()
    
    * pm-core:
      PM / sleep: Handle failures in device_suspend_late() consistently

commit 3834abb4e64483af7af7500e54c0a5f957a52b1b
Author: Pankaj Gupta <Pankaj.Gupta@spreadtrum.com>
Date:   Mon May 16 11:07:19 2016 +0000

    cpufreq: simplified goto out in cpufreq_register_driver()
    
    simplified goto out in cpufreq_register_driver for increasing
    code readability
    
    Signed-off-by: Pankaj Gupta <pankaj.gupta@spreadtrum.com>
    Signed-off-by: Sanjeev Yadav <sanjeev.yadav@spreadtrum.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 0ea539773e0169e14a4209d48fcb1a6a67519d6d
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon Feb 15 10:21:53 2016 +0530

    PM / OPP: Initialize u_volt_min/max to a valid value
    
    commit c88c395f4a6485f23f81e385c79945d68bcd5c5d upstream.
    
    We kept u_volt_min/max initialized to 0, when only the target voltage is
    present in DT, instead of the target/min/max triplet.
    
    This didn't go well with the regulator framework, as on few calls the
    min voltage was set to target and max was set to 0 and so resulted in a
    kernel crash like below:
    
    kernel BUG at ../drivers/regulator/core.c:216!
    
    [<c0684af4>] (regulator_check_voltage) from [<c06857ac>] (regulator_set_voltage_unlocked+0x58/0x230)
    [<c06857ac>] (regulator_set_voltage_unlocked) from [<c06859ac>] (regulator_set_voltage+0x28/0x54)
    [<c06859ac>] (regulator_set_voltage) from [<c0775b28>] (_set_opp_voltage+0x30/0x98)
    [<c0775b28>] (_set_opp_voltage) from [<c0776630>] (dev_pm_opp_set_rate+0xf0/0x28c)
    [<c0776630>] (dev_pm_opp_set_rate) from [<c096f784>] (__cpufreq_driver_target+0x184/0x2b4)
    [<c096f784>] (__cpufreq_driver_target) from [<c0973760>] (dbs_check_cpu+0x1b0/0x1f4)
    [<c0973760>] (dbs_check_cpu) from [<c0973f30>] (cpufreq_governor_dbs+0x324/0x5c4)
    [<c0973f30>] (cpufreq_governor_dbs) from [<c0970958>] (__cpufreq_governor+0xe4/0x1ec)
    [<c0970958>] (__cpufreq_governor) from [<c09711e0>] (cpufreq_init_policy+0x64/0x8c)
    [<c09711e0>] (cpufreq_init_policy) from [<c09718cc>] (cpufreq_online+0x2fc/0x708)
    [<c09718cc>] (cpufreq_online) from [<c0765ff0>] (subsys_interface_register+0x94/0xd8)
    [<c0765ff0>] (subsys_interface_register) from [<c0970530>] (cpufreq_register_driver+0x14c/0x19c)
    [<c0970530>] (cpufreq_register_driver) from [<c09746dc>] (dt_cpufreq_probe+0x70/0xec)
    [<c09746dc>] (dt_cpufreq_probe) from [<c076907c>] (platform_drv_probe+0x4c/0xb0)
    [<c076907c>] (platform_drv_probe) from [<c07678e0>] (driver_probe_device+0x214/0x2c0)
    [<c07678e0>] (driver_probe_device) from [<c0767a18>] (__driver_attach+0x8c/0x90)
    [<c0767a18>] (__driver_attach) from [<c0765c2c>] (bus_for_each_dev+0x68/0x9c)
    [<c0765c2c>] (bus_for_each_dev) from [<c0766d78>] (bus_add_driver+0x1a0/0x218)
    [<c0766d78>] (bus_add_driver) from [<c076810c>] (driver_register+0x78/0xf8)
    [<c076810c>] (driver_register) from [<c0301d74>] (do_one_initcall+0x90/0x1d8)
    [<c0301d74>] (do_one_initcall) from [<c1100e14>] (kernel_init_freeable+0x15c/0x1fc)
    [<c1100e14>] (kernel_init_freeable) from [<c0b27a0c>] (kernel_init+0x8/0xf0)
    [<c0b27a0c>] (kernel_init) from [<c0307d78>] (ret_from_fork+0x14/0x3c)
    Code: e1550004 baffffeb e3a00000 e8bd8070 (e7f001f2)
    
    Fix that by initializing u_volt_min/max to the target voltage in such cases.
    
    Reported-and-tested-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Fixes: 274659029c9d (PM / OPP: Add support to parse "operating-points-v2" bindings)
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit dabe14168a929839b4757f496ad6886489078997
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon Feb 15 10:21:53 2016 +0530

    PM / OPP: Initialize u_volt_min/max to a valid value
    
    commit c88c395f4a6485f23f81e385c79945d68bcd5c5d upstream.
    
    We kept u_volt_min/max initialized to 0, when only the target voltage is
    present in DT, instead of the target/min/max triplet.
    
    This didn't go well with the regulator framework, as on few calls the
    min voltage was set to target and max was set to 0 and so resulted in a
    kernel crash like below:
    
    kernel BUG at ../drivers/regulator/core.c:216!
    
    [<c0684af4>] (regulator_check_voltage) from [<c06857ac>] (regulator_set_voltage_unlocked+0x58/0x230)
    [<c06857ac>] (regulator_set_voltage_unlocked) from [<c06859ac>] (regulator_set_voltage+0x28/0x54)
    [<c06859ac>] (regulator_set_voltage) from [<c0775b28>] (_set_opp_voltage+0x30/0x98)
    [<c0775b28>] (_set_opp_voltage) from [<c0776630>] (dev_pm_opp_set_rate+0xf0/0x28c)
    [<c0776630>] (dev_pm_opp_set_rate) from [<c096f784>] (__cpufreq_driver_target+0x184/0x2b4)
    [<c096f784>] (__cpufreq_driver_target) from [<c0973760>] (dbs_check_cpu+0x1b0/0x1f4)
    [<c0973760>] (dbs_check_cpu) from [<c0973f30>] (cpufreq_governor_dbs+0x324/0x5c4)
    [<c0973f30>] (cpufreq_governor_dbs) from [<c0970958>] (__cpufreq_governor+0xe4/0x1ec)
    [<c0970958>] (__cpufreq_governor) from [<c09711e0>] (cpufreq_init_policy+0x64/0x8c)
    [<c09711e0>] (cpufreq_init_policy) from [<c09718cc>] (cpufreq_online+0x2fc/0x708)
    [<c09718cc>] (cpufreq_online) from [<c0765ff0>] (subsys_interface_register+0x94/0xd8)
    [<c0765ff0>] (subsys_interface_register) from [<c0970530>] (cpufreq_register_driver+0x14c/0x19c)
    [<c0970530>] (cpufreq_register_driver) from [<c09746dc>] (dt_cpufreq_probe+0x70/0xec)
    [<c09746dc>] (dt_cpufreq_probe) from [<c076907c>] (platform_drv_probe+0x4c/0xb0)
    [<c076907c>] (platform_drv_probe) from [<c07678e0>] (driver_probe_device+0x214/0x2c0)
    [<c07678e0>] (driver_probe_device) from [<c0767a18>] (__driver_attach+0x8c/0x90)
    [<c0767a18>] (__driver_attach) from [<c0765c2c>] (bus_for_each_dev+0x68/0x9c)
    [<c0765c2c>] (bus_for_each_dev) from [<c0766d78>] (bus_add_driver+0x1a0/0x218)
    [<c0766d78>] (bus_add_driver) from [<c076810c>] (driver_register+0x78/0xf8)
    [<c076810c>] (driver_register) from [<c0301d74>] (do_one_initcall+0x90/0x1d8)
    [<c0301d74>] (do_one_initcall) from [<c1100e14>] (kernel_init_freeable+0x15c/0x1fc)
    [<c1100e14>] (kernel_init_freeable) from [<c0b27a0c>] (kernel_init+0x8/0xf0)
    [<c0b27a0c>] (kernel_init) from [<c0307d78>] (ret_from_fork+0x14/0x3c)
    Code: e1550004 baffffeb e3a00000 e8bd8070 (e7f001f2)
    
    Fix that by initializing u_volt_min/max to the target voltage in such cases.
    
    Reported-and-tested-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Fixes: 274659029c9d (PM / OPP: Add support to parse "operating-points-v2" bindings)
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 63af4055726a56e04caf354aac58478d2af07ce8
Author: Eric Biggers <ebiggers3@gmail.com>
Date:   Sat Feb 20 21:50:01 2016 -0600

    cpufreq: fix comment about return value of cpufreq_register_driver()
    
    The comment has been incorrect since commit 4dea5806d332
    ("cpufreq: return EEXIST instead of EBUSY for second registering").
    
    Signed-off-by: Eric Biggers <ebiggers3@gmail.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit c88c395f4a6485f23f81e385c79945d68bcd5c5d
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon Feb 15 10:21:53 2016 +0530

    PM / OPP: Initialize u_volt_min/max to a valid value
    
    We kept u_volt_min/max initialized to 0, when only the target voltage is
    present in DT, instead of the target/min/max triplet.
    
    This didn't go well with the regulator framework, as on few calls the
    min voltage was set to target and max was set to 0 and so resulted in a
    kernel crash like below:
    
    kernel BUG at ../drivers/regulator/core.c:216!
    
    [<c0684af4>] (regulator_check_voltage) from [<c06857ac>] (regulator_set_voltage_unlocked+0x58/0x230)
    [<c06857ac>] (regulator_set_voltage_unlocked) from [<c06859ac>] (regulator_set_voltage+0x28/0x54)
    [<c06859ac>] (regulator_set_voltage) from [<c0775b28>] (_set_opp_voltage+0x30/0x98)
    [<c0775b28>] (_set_opp_voltage) from [<c0776630>] (dev_pm_opp_set_rate+0xf0/0x28c)
    [<c0776630>] (dev_pm_opp_set_rate) from [<c096f784>] (__cpufreq_driver_target+0x184/0x2b4)
    [<c096f784>] (__cpufreq_driver_target) from [<c0973760>] (dbs_check_cpu+0x1b0/0x1f4)
    [<c0973760>] (dbs_check_cpu) from [<c0973f30>] (cpufreq_governor_dbs+0x324/0x5c4)
    [<c0973f30>] (cpufreq_governor_dbs) from [<c0970958>] (__cpufreq_governor+0xe4/0x1ec)
    [<c0970958>] (__cpufreq_governor) from [<c09711e0>] (cpufreq_init_policy+0x64/0x8c)
    [<c09711e0>] (cpufreq_init_policy) from [<c09718cc>] (cpufreq_online+0x2fc/0x708)
    [<c09718cc>] (cpufreq_online) from [<c0765ff0>] (subsys_interface_register+0x94/0xd8)
    [<c0765ff0>] (subsys_interface_register) from [<c0970530>] (cpufreq_register_driver+0x14c/0x19c)
    [<c0970530>] (cpufreq_register_driver) from [<c09746dc>] (dt_cpufreq_probe+0x70/0xec)
    [<c09746dc>] (dt_cpufreq_probe) from [<c076907c>] (platform_drv_probe+0x4c/0xb0)
    [<c076907c>] (platform_drv_probe) from [<c07678e0>] (driver_probe_device+0x214/0x2c0)
    [<c07678e0>] (driver_probe_device) from [<c0767a18>] (__driver_attach+0x8c/0x90)
    [<c0767a18>] (__driver_attach) from [<c0765c2c>] (bus_for_each_dev+0x68/0x9c)
    [<c0765c2c>] (bus_for_each_dev) from [<c0766d78>] (bus_add_driver+0x1a0/0x218)
    [<c0766d78>] (bus_add_driver) from [<c076810c>] (driver_register+0x78/0xf8)
    [<c076810c>] (driver_register) from [<c0301d74>] (do_one_initcall+0x90/0x1d8)
    [<c0301d74>] (do_one_initcall) from [<c1100e14>] (kernel_init_freeable+0x15c/0x1fc)
    [<c1100e14>] (kernel_init_freeable) from [<c0b27a0c>] (kernel_init+0x8/0xf0)
    [<c0b27a0c>] (kernel_init) from [<c0307d78>] (ret_from_fork+0x14/0x3c)
    Code: e1550004 baffffeb e3a00000 e8bd8070 (e7f001f2)
    
    Fix that by initializing u_volt_min/max to the target voltage in such cases.
    
    Reported-and-tested-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Fixes: 274659029c9d (PM / OPP: Add support to parse "operating-points-v2" bindings)
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 87b4115db0239865bc812f61704bb1f43e2439b6
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Nov 5 14:21:19 2015 +0530

    PM / OPP: Protect updates to list_dev with mutex
    
    dev_opp_list_lock is used everywhere to protect device and OPP lists,
    but dev_pm_opp_set_sharing_cpus() is missed somehow. And instead we used
    rcu-lock, which wouldn't help here as we are adding a new list_dev.
    
    This also fixes a problem where we have called kzalloc(..., GFP_KERNEL)
    from within rcu-lock, which isn't allowed as kzalloc can sleep when
    called with GFP_KERNEL.
    
    With CONFIG_DEBUG_ATOMIC_SLEEP set, we get following lockdep-splat:
    
    include/linux/rcupdate.h:578 Illegal context switch in RCU read-side critical section!
    
    other info that might help us debug this:
    
    rcu_scheduler_active = 1, debug_locks = 0
    5 locks held by swapper/0/1:
     #0:  (&dev->mutex){......}, at: [<c02f68f4>] __driver_attach+0x48/0x98
     #1:  (&dev->mutex){......}, at: [<c02f6904>] __driver_attach+0x58/0x98
     #2:  (cpu_hotplug.lock){++++++}, at: [<c00249d0>] get_online_cpus+0x40/0xb0
     #3:  (subsys mutex#5){+.+.+.}, at: [<c02f4f8c>] subsys_interface_register+0x44/0xdc
     #4:  (rcu_read_lock){......}, at: [<c0305c80>] dev_pm_opp_set_sharing_cpus+0x0/0x1e4
    
    stack backtrace:
    CPU: 1 PID: 1 Comm: swapper/0 Tainted: G        W       4.3.0-rc7-00047-g81f5932958a8 #59
    Hardware name: SAMSUNG EXYNOS (Flattened Device Tree)
    [<c0016874>] (unwind_backtrace) from [<c001355c>] (show_stack+0x10/0x14)
    [<c001355c>] (show_stack) from [<c022553c>] (dump_stack+0x94/0xbc)
    [<c022553c>] (dump_stack) from [<c004904c>] (___might_sleep+0x24c/0x298)
    [<c004904c>] (___might_sleep) from [<c00f07e4>] (kmem_cache_alloc+0xe8/0x164)
    [<c00f07e4>] (kmem_cache_alloc) from [<c0305354>] (_add_list_dev+0x30/0x58)
    [<c0305354>] (_add_list_dev) from [<c0305d50>] (dev_pm_opp_set_sharing_cpus+0xd0/0x1e4)
    [<c0305d50>] (dev_pm_opp_set_sharing_cpus) from [<c040eda4>] (cpufreq_init+0x4cc/0x62c)
    [<c040eda4>] (cpufreq_init) from [<c040a964>] (cpufreq_online+0xbc/0x73c)
    [<c040a964>] (cpufreq_online) from [<c02f4fe0>] (subsys_interface_register+0x98/0xdc)
    [<c02f4fe0>] (subsys_interface_register) from [<c040a640>] (cpufreq_register_driver+0x110/0x17c)
    [<c040a640>] (cpufreq_register_driver) from [<c040ef64>] (dt_cpufreq_probe+0x60/0x8c)
    [<c040ef64>] (dt_cpufreq_probe) from [<c02f8084>] (platform_drv_probe+0x44/0xa4)
    [<c02f8084>] (platform_drv_probe) from [<c02f67c0>] (driver_probe_device+0x208/0x2f4)
    [<c02f67c0>] (driver_probe_device) from [<c02f6940>] (__driver_attach+0x94/0x98)
    [<c02f6940>] (__driver_attach) from [<c02f4c1c>] (bus_for_each_dev+0x68/0x9c)
    
    Reported-by: Michael Turquette <mturquette@baylibre.com>
    Reviewed-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Cc: 4.3 <stable@vger.kernel.org> # 4.3
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 4ffe18c2556f2848c4e57457915b08a63dc00fd5
Merge: 498012511a06 72e624de6e6f
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Sep 1 15:52:35 2015 +0200

    Merge branch 'pm-cpufreq'
    
    * pm-cpufreq: (53 commits)
      cpufreq: speedstep-lib: Use monotonic clock
      cpufreq: powernv: Increase the verbosity of OCC console messages
      cpufreq: sfi: use kmemdup rather than duplicating its implementation
      cpufreq: drop !cpufreq_driver check from cpufreq_parse_governor()
      cpufreq: rename cpufreq_real_policy as cpufreq_user_policy
      cpufreq: remove redundant 'policy' field from user_policy
      cpufreq: remove redundant 'governor' field from user_policy
      cpufreq: update user_policy.* on success
      cpufreq: use memcpy() to copy policy
      cpufreq: remove redundant CPUFREQ_INCOMPATIBLE notifier event
      cpufreq: mediatek: Add MT8173 cpufreq driver
      dt-bindings: mediatek: Add MT8173 CPU DVFS clock bindings
      intel_pstate: append more Oracle OEM table id to vendor bypass list
      intel_pstate: Add SKY-S support
      intel_pstate: Fix possible overflow complained by Coverity
      cpufreq: Correct a freq check in cpufreq_set_policy()
      cpufreq: Lock CPU online/offline in cpufreq_register_driver()
      cpufreq: Replace recover_policy with new_policy in cpufreq_online()
      cpufreq: Separate CPU device registration from CPU online
      cpufreq: powernv: Restore cpu frequency to policy->cur on unthrottling
      ...

commit 528464eaa46ae1bd319882e4dd3495802e55b8c4
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jul 23 14:32:32 2015 +0530

    thermal: remove dangling 'weight_attr' device file
    
    This file isn't getting removed while we unbind a device from thermal
    zone. And this causes following messages when the device is registered
    again:
    
    WARNING: CPU: 0 PID: 2228 at /home/viresh/linux/fs/sysfs/dir.c:31 sysfs_warn_dup+0x60/0x70()
    sysfs: cannot create duplicate filename '/devices/virtual/thermal/thermal_zone0/cdev0_weight'
    Modules linked in: cpufreq_dt(+) [last unloaded: cpufreq_dt]
    CPU: 0 PID: 2228 Comm: insmod Not tainted 4.2.0-rc3-00059-g44fffd9473eb #272
    Hardware name: SAMSUNG EXYNOS (Flattened Device Tree)
    [<c00153e8>] (unwind_backtrace) from [<c0012368>] (show_stack+0x10/0x14)
    [<c0012368>] (show_stack) from [<c053a684>] (dump_stack+0x84/0xc4)
    [<c053a684>] (dump_stack) from [<c002284c>] (warn_slowpath_common+0x80/0xb0)
    [<c002284c>] (warn_slowpath_common) from [<c00228ac>] (warn_slowpath_fmt+0x30/0x40)
    [<c00228ac>] (warn_slowpath_fmt) from [<c012d524>] (sysfs_warn_dup+0x60/0x70)
    [<c012d524>] (sysfs_warn_dup) from [<c012d244>] (sysfs_add_file_mode_ns+0x13c/0x190)
    [<c012d244>] (sysfs_add_file_mode_ns) from [<c012d2d4>] (sysfs_create_file_ns+0x3c/0x48)
    [<c012d2d4>] (sysfs_create_file_ns) from [<c03c04a8>] (thermal_zone_bind_cooling_device+0x260/0x358)
    [<c03c04a8>] (thermal_zone_bind_cooling_device) from [<c03c2e70>] (of_thermal_bind+0x88/0xb4)
    [<c03c2e70>] (of_thermal_bind) from [<c03c10d0>] (__thermal_cooling_device_register+0x17c/0x2e0)
    [<c03c10d0>] (__thermal_cooling_device_register) from [<c03c3f50>] (__cpufreq_cooling_register+0x3a0/0x51c)
    [<c03c3f50>] (__cpufreq_cooling_register) from [<bf00505c>] (cpufreq_ready+0x44/0x88 [cpufreq_dt])
    [<bf00505c>] (cpufreq_ready [cpufreq_dt]) from [<c03d6c30>] (cpufreq_add_dev+0x4a0/0x7dc)
    [<c03d6c30>] (cpufreq_add_dev) from [<c02cd3ec>] (subsys_interface_register+0x94/0xd8)
    [<c02cd3ec>] (subsys_interface_register) from [<c03d785c>] (cpufreq_register_driver+0x10c/0x1f0)
    [<c03d785c>] (cpufreq_register_driver) from [<bf0057d4>] (dt_cpufreq_probe+0x60/0x8c [cpufreq_dt])
    [<bf0057d4>] (dt_cpufreq_probe [cpufreq_dt]) from [<c02d03e4>] (platform_drv_probe+0x44/0xa4)
    [<c02d03e4>] (platform_drv_probe) from [<c02cead8>] (driver_probe_device+0x174/0x2b4)
    [<c02cead8>] (driver_probe_device) from [<c02ceca4>] (__driver_attach+0x8c/0x90)
    [<c02ceca4>] (__driver_attach) from [<c02cd078>] (bus_for_each_dev+0x68/0x9c)
    [<c02cd078>] (bus_for_each_dev) from [<c02ce2f0>] (bus_add_driver+0x19c/0x214)
    [<c02ce2f0>] (bus_add_driver) from [<c02cf490>] (driver_register+0x78/0xf8)
    [<c02cf490>] (driver_register) from [<c0009710>] (do_one_initcall+0x8c/0x1d4)
    [<c0009710>] (do_one_initcall) from [<c05396b0>] (do_init_module+0x5c/0x1b8)
    [<c05396b0>] (do_init_module) from [<c0086490>] (load_module+0xd34/0xed8)
    [<c0086490>] (load_module) from [<c0086704>] (SyS_init_module+0xd0/0x120)
    [<c0086704>] (SyS_init_module) from [<c000f480>] (ret_fast_syscall+0x0/0x3c)
    ---[ end trace 3be0e7b7dc6e3c4f ]---
    
    Fixes: db91651311c8 ("thermal: export weight to sysfs")
    Acked-by: Javi Merino <javi.merino@arm.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Eduardo Valentin <edubezval@gmail.com>

commit fdd320da84c63092fe6e155cb7b8d80f7f765fa9
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Jul 30 01:45:07 2015 +0200

    cpufreq: Lock CPU online/offline in cpufreq_register_driver()
    
    To protect against races with concurrent CPU online/offline, call
    get_online_cpus() before registering a cpufreq driver.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>

commit 9346dc9c64f7a4b712d3cc11092c69db479796b0
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Sep 27 21:56:08 2014 +0200

    cpufreq: pcc-cpufreq: Fix wait_event() under spinlock
    
    commit e65b5ddba84634f31d42dfd86013f4c6be5e9e32 upstream.
    
    Fix the following bug introduced by commit 8fec051eea73 (cpufreq:
    Convert existing drivers to use cpufreq_freq_transition_{begin|end})
    that forgot to move the spin_lock() in pcc_cpufreq_target() past
    cpufreq_freq_transition_begin() which calls wait_event():
    
    BUG: sleeping function called from invalid context at drivers/cpufreq/cpufreq.c:370
    in_atomic(): 1, irqs_disabled(): 0, pid: 2636, name: modprobe
    Preemption disabled at:[<ffffffffa04d74d7>] pcc_cpufreq_target+0x27/0x200 [pcc_cpufreq]
    [   51.025044]
    CPU: 57 PID: 2636 Comm: modprobe Tainted: G            E  3.17.0-default #7
    Hardware name: Hewlett-Packard ProLiant DL980 G7, BIOS P66 07/07/2010
     00000000ffffffff ffff88026c46b828 ffffffff81589dbd 0000000000000000
     ffff880037978090 ffff88026c46b848 ffffffff8108e1df ffff880037978090
     0000000000000000 ffff88026c46b878 ffffffff8108e298 ffff88026d73ec00
    Call Trace:
     [<ffffffff81589dbd>] dump_stack+0x4d/0x90
     [<ffffffff8108e1df>] ___might_sleep+0x10f/0x180
     [<ffffffff8108e298>] __might_sleep+0x48/0xd0
     [<ffffffff8145b905>] cpufreq_freq_transition_begin+0x75/0x140 drivers/cpufreq/cpufreq.c:370 wait_event(policy->transition_wait, !policy->transition_ongoing);
     [<ffffffff8108fc99>] ? preempt_count_add+0xb9/0xc0
     [<ffffffffa04d7513>] pcc_cpufreq_target+0x63/0x200 [pcc_cpufreq] drivers/cpufreq/pcc-cpufreq.c:207 spin_lock(&pcc_lock);
     [<ffffffff810e0d0f>] ? update_ts_time_stats+0x7f/0xb0
     [<ffffffff8145be55>] __cpufreq_driver_target+0x85/0x170
     [<ffffffff8145e4c8>] od_check_cpu+0xa8/0xb0
     [<ffffffff8145ef10>] dbs_check_cpu+0x180/0x1d0
     [<ffffffff8145f310>] cpufreq_governor_dbs+0x3b0/0x720
     [<ffffffff8145ebe3>] od_cpufreq_governor_dbs+0x33/0xe0
     [<ffffffff814593d9>] __cpufreq_governor+0xa9/0x210
     [<ffffffff81459fb2>] cpufreq_set_policy+0x1e2/0x2e0
     [<ffffffff8145a6cc>] cpufreq_init_policy+0x8c/0x110
     [<ffffffff8145c9a0>] ? cpufreq_update_policy+0x1b0/0x1b0
     [<ffffffff8108fb99>] ? preempt_count_sub+0xb9/0x100
     [<ffffffff8145c6c6>] __cpufreq_add_dev+0x596/0x6b0
     [<ffffffffa016c608>] ? pcc_cpufreq_probe+0x4b4/0x4b4 [pcc_cpufreq]
     [<ffffffff8145c7ee>] cpufreq_add_dev+0xe/0x10
     [<ffffffff81408e81>] subsys_interface_register+0xc1/0xf0
     [<ffffffff8108fb99>] ? preempt_count_sub+0xb9/0x100
     [<ffffffff8145b3d7>] cpufreq_register_driver+0x117/0x2a0
     [<ffffffffa016c65d>] pcc_cpufreq_init+0x55/0x9f8 [pcc_cpufreq]
     [<ffffffffa016c608>] ? pcc_cpufreq_probe+0x4b4/0x4b4 [pcc_cpufreq]
     [<ffffffff81000298>] do_one_initcall+0xc8/0x1f0
     [<ffffffff811a731d>] ? __vunmap+0x9d/0x100
     [<ffffffff810eb9a0>] do_init_module+0x30/0x1b0
     [<ffffffff810edfa6>] load_module+0x686/0x710
     [<ffffffff810ebb20>] ? do_init_module+0x1b0/0x1b0
     [<ffffffff810ee1db>] SyS_init_module+0x9b/0xc0
     [<ffffffff8158f7a9>] system_call_fastpath+0x16/0x1b
    
    Fixes: 8fec051eea73 (cpufreq: Convert existing drivers to use cpufreq_freq_transition_{begin|end})
    Reported-and-tested-by: Mike Galbraith <umgwanakikbuti@gmail.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit c9bf87daad34a80e4f742a94238cf8449e444add
Author: Prarit Bhargava <prarit@redhat.com>
Date:   Wed Sep 10 10:12:08 2014 -0400

    cpufreq: release policy->rwsem on error
    
    commit 7106e02baed4a72fb23de56b02ad4d31daa74d95 upstream.
    
    While debugging a cpufreq-related hardware failure on a system I saw the
    following lockdep warning:
    
     =========================
     [ BUG: held lock freed! ] 3.17.0-rc4+ #1 Tainted: G            E
     -------------------------
     insmod/2247 is freeing memory ffff88006e1b1400-ffff88006e1b17ff, with a lock still held there!
      (&policy->rwsem){+.+...}, at: [<ffffffff8156d37d>] __cpufreq_add_dev.isra.21+0x47d/0xb80
     3 locks held by insmod/2247:
      #0:  (subsys mutex#5){+.+.+.}, at: [<ffffffff81485579>] subsys_interface_register+0x69/0x120
      #1:  (cpufreq_rwsem){.+.+.+}, at: [<ffffffff8156cf73>] __cpufreq_add_dev.isra.21+0x73/0xb80
      #2:  (&policy->rwsem){+.+...}, at: [<ffffffff8156d37d>] __cpufreq_add_dev.isra.21+0x47d/0xb80
    
     stack backtrace:
     CPU: 0 PID: 2247 Comm: insmod Tainted: G            E  3.17.0-rc4+ #1
     Hardware name: HP ProLiant MicroServer Gen8, BIOS J06 08/24/2013
      0000000000000000 000000008f3063c4 ffff88006f87bb30 ffffffff8171b358
      ffff88006bcf3750 ffff88006f87bb68 ffffffff810e09e1 ffff88006e1b1400
      ffffea0001b86c00 ffffffff8156d327 ffff880073003500 0000000000000246
     Call Trace:
      [<ffffffff8171b358>] dump_stack+0x4d/0x66
      [<ffffffff810e09e1>] debug_check_no_locks_freed+0x171/0x180
      [<ffffffff8156d327>] ? __cpufreq_add_dev.isra.21+0x427/0xb80
      [<ffffffff8121412b>] kfree+0xab/0x2b0
      [<ffffffff8156d327>] __cpufreq_add_dev.isra.21+0x427/0xb80
      [<ffffffff81724cf7>] ? _raw_spin_unlock+0x27/0x40
      [<ffffffffa003517f>] ? pcc_cpufreq_do_osc+0x17f/0x17f [pcc_cpufreq]
      [<ffffffff8156da8e>] cpufreq_add_dev+0xe/0x10
      [<ffffffff814855d1>] subsys_interface_register+0xc1/0x120
      [<ffffffff8156bcf2>] cpufreq_register_driver+0x112/0x340
      [<ffffffff8121415a>] ? kfree+0xda/0x2b0
      [<ffffffffa003517f>] ? pcc_cpufreq_do_osc+0x17f/0x17f [pcc_cpufreq]
      [<ffffffffa003562e>] pcc_cpufreq_init+0x4af/0xe81 [pcc_cpufreq]
      [<ffffffffa003517f>] ? pcc_cpufreq_do_osc+0x17f/0x17f [pcc_cpufreq]
      [<ffffffff81002144>] do_one_initcall+0xd4/0x210
      [<ffffffff811f7472>] ? __vunmap+0xd2/0x120
      [<ffffffff81127155>] load_module+0x1315/0x1b70
      [<ffffffff811222a0>] ? store_uevent+0x70/0x70
      [<ffffffff811229d9>] ? copy_module_from_fd.isra.44+0x129/0x180
      [<ffffffff81127b86>] SyS_finit_module+0xa6/0xd0
      [<ffffffff81725b69>] system_call_fastpath+0x16/0x1b
     cpufreq: __cpufreq_add_dev: ->get() failed
    insmod: ERROR: could not insert module pcc-cpufreq.ko: No such device
    
    The warning occurs in the __cpufreq_add_dev() code which does
    
            down_write(&policy->rwsem);
            ...
            if (cpufreq_driver->get && !cpufreq_driver->setpolicy) {
                    policy->cur = cpufreq_driver->get(policy->cpu);
                    if (!policy->cur) {
                            pr_err("%s: ->get() failed\n", __func__);
                            goto err_get_freq;
                    }
    
    If cpufreq_driver->get(policy->cpu) returns an error we execute the
    code at err_get_freq, which does not up the policy->rwsem.  This causes
    the lockdep warning.
    
    Trivial patch to up the policy->rwsem in the error path.
    
    After the patch has been applied, and an error occurs in the
    cpufreq_driver->get(policy->cpu) call we will now see
    
    cpufreq: __cpufreq_add_dev: ->get() failed
    cpufreq: __cpufreq_add_dev: ->get() failed
    modprobe: ERROR: could not insert 'pcc_cpufreq': No such device
    
    Fixes: 4e97b631f24c (cpufreq: Initialize governor for a new policy under policy->rwsem)
    Signed-off-by: Prarit Bhargava <prarit@redhat.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 168d02c742eca20fabafddf49305a1e254be1a6d
Author: Prarit Bhargava <prarit@redhat.com>
Date:   Wed Sep 10 10:12:08 2014 -0400

    cpufreq: release policy->rwsem on error
    
    commit 7106e02baed4a72fb23de56b02ad4d31daa74d95 upstream.
    
    While debugging a cpufreq-related hardware failure on a system I saw the
    following lockdep warning:
    
     =========================
     [ BUG: held lock freed! ] 3.17.0-rc4+ #1 Tainted: G            E
     -------------------------
     insmod/2247 is freeing memory ffff88006e1b1400-ffff88006e1b17ff, with a lock still held there!
      (&policy->rwsem){+.+...}, at: [<ffffffff8156d37d>] __cpufreq_add_dev.isra.21+0x47d/0xb80
     3 locks held by insmod/2247:
      #0:  (subsys mutex#5){+.+.+.}, at: [<ffffffff81485579>] subsys_interface_register+0x69/0x120
      #1:  (cpufreq_rwsem){.+.+.+}, at: [<ffffffff8156cf73>] __cpufreq_add_dev.isra.21+0x73/0xb80
      #2:  (&policy->rwsem){+.+...}, at: [<ffffffff8156d37d>] __cpufreq_add_dev.isra.21+0x47d/0xb80
    
     stack backtrace:
     CPU: 0 PID: 2247 Comm: insmod Tainted: G            E  3.17.0-rc4+ #1
     Hardware name: HP ProLiant MicroServer Gen8, BIOS J06 08/24/2013
      0000000000000000 000000008f3063c4 ffff88006f87bb30 ffffffff8171b358
      ffff88006bcf3750 ffff88006f87bb68 ffffffff810e09e1 ffff88006e1b1400
      ffffea0001b86c00 ffffffff8156d327 ffff880073003500 0000000000000246
     Call Trace:
      [<ffffffff8171b358>] dump_stack+0x4d/0x66
      [<ffffffff810e09e1>] debug_check_no_locks_freed+0x171/0x180
      [<ffffffff8156d327>] ? __cpufreq_add_dev.isra.21+0x427/0xb80
      [<ffffffff8121412b>] kfree+0xab/0x2b0
      [<ffffffff8156d327>] __cpufreq_add_dev.isra.21+0x427/0xb80
      [<ffffffff81724cf7>] ? _raw_spin_unlock+0x27/0x40
      [<ffffffffa003517f>] ? pcc_cpufreq_do_osc+0x17f/0x17f [pcc_cpufreq]
      [<ffffffff8156da8e>] cpufreq_add_dev+0xe/0x10
      [<ffffffff814855d1>] subsys_interface_register+0xc1/0x120
      [<ffffffff8156bcf2>] cpufreq_register_driver+0x112/0x340
      [<ffffffff8121415a>] ? kfree+0xda/0x2b0
      [<ffffffffa003517f>] ? pcc_cpufreq_do_osc+0x17f/0x17f [pcc_cpufreq]
      [<ffffffffa003562e>] pcc_cpufreq_init+0x4af/0xe81 [pcc_cpufreq]
      [<ffffffffa003517f>] ? pcc_cpufreq_do_osc+0x17f/0x17f [pcc_cpufreq]
      [<ffffffff81002144>] do_one_initcall+0xd4/0x210
      [<ffffffff811f7472>] ? __vunmap+0xd2/0x120
      [<ffffffff81127155>] load_module+0x1315/0x1b70
      [<ffffffff811222a0>] ? store_uevent+0x70/0x70
      [<ffffffff811229d9>] ? copy_module_from_fd.isra.44+0x129/0x180
      [<ffffffff81127b86>] SyS_finit_module+0xa6/0xd0
      [<ffffffff81725b69>] system_call_fastpath+0x16/0x1b
     cpufreq: __cpufreq_add_dev: ->get() failed
    insmod: ERROR: could not insert module pcc-cpufreq.ko: No such device
    
    The warning occurs in the __cpufreq_add_dev() code which does
    
            down_write(&policy->rwsem);
            ...
            if (cpufreq_driver->get && !cpufreq_driver->setpolicy) {
                    policy->cur = cpufreq_driver->get(policy->cpu);
                    if (!policy->cur) {
                            pr_err("%s: ->get() failed\n", __func__);
                            goto err_get_freq;
                    }
    
    If cpufreq_driver->get(policy->cpu) returns an error we execute the
    code at err_get_freq, which does not up the policy->rwsem.  This causes
    the lockdep warning.
    
    Trivial patch to up the policy->rwsem in the error path.
    
    After the patch has been applied, and an error occurs in the
    cpufreq_driver->get(policy->cpu) call we will now see
    
    cpufreq: __cpufreq_add_dev: ->get() failed
    cpufreq: __cpufreq_add_dev: ->get() failed
    modprobe: ERROR: could not insert 'pcc_cpufreq': No such device
    
    Fixes: 4e97b631f24c (cpufreq: Initialize governor for a new policy under policy->rwsem)
    Signed-off-by: Prarit Bhargava <prarit@redhat.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 84d172d64e2985fcc14b261a2b0312eb1ee4aa23
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Wed Aug 6 22:04:58 2014 +0200

    cpufreq: OPP: Avoid sleeping while atomic
    
    commit 3c5445ce3a0c6d6935911212b735772af5115517 upstream.
    
    We allocate the cpufreq table after calling rcu_read_lock(),
    which disables preemption. This causes scheduling while atomic
    warnings. Use GFP_ATOMIC instead of GFP_KERNEL and update for
    kcalloc while we're here.
    
    BUG: sleeping function called from invalid context at mm/slub.c:1246
    in_atomic(): 0, irqs_disabled(): 0, pid: 80, name: modprobe
    5 locks held by modprobe/80:
     #0:  (&dev->mutex){......}, at: [<c050d484>] __driver_attach+0x48/0x98
     #1:  (&dev->mutex){......}, at: [<c050d494>] __driver_attach+0x58/0x98
     #2:  (subsys mutex#5){+.+.+.}, at: [<c050c114>] subsys_interface_register+0x38/0xc8
     #3:  (cpufreq_rwsem){.+.+.+}, at: [<c05a9c8c>] __cpufreq_add_dev.isra.22+0x84/0x92c
     #4:  (rcu_read_lock){......}, at: [<c05ab24c>] dev_pm_opp_init_cpufreq_table+0x18/0x10c
    Preemption disabled at:[<  (null)>]   (null)
    
    CPU: 2 PID: 80 Comm: modprobe Not tainted 3.16.0-rc3-next-20140701-00035-g286857f216aa-dirty #217
    [<c0214da8>] (unwind_backtrace) from [<c02123f8>] (show_stack+0x10/0x14)
    [<c02123f8>] (show_stack) from [<c070141c>] (dump_stack+0x70/0xbc)
    [<c070141c>] (dump_stack) from [<c02f4cb0>] (__kmalloc+0x124/0x250)
    [<c02f4cb0>] (__kmalloc) from [<c05ab270>] (dev_pm_opp_init_cpufreq_table+0x3c/0x10c)
    [<c05ab270>] (dev_pm_opp_init_cpufreq_table) from [<bf000508>] (cpufreq_init+0x48/0x378 [cpufreq_generic])
    [<bf000508>] (cpufreq_init [cpufreq_generic]) from [<c05a9e08>] (__cpufreq_add_dev.isra.22+0x200/0x92c)
    [<c05a9e08>] (__cpufreq_add_dev.isra.22) from [<c050c160>] (subsys_interface_register+0x84/0xc8)
    [<c050c160>] (subsys_interface_register) from [<c05a9494>] (cpufreq_register_driver+0x108/0x2d8)
    [<c05a9494>] (cpufreq_register_driver) from [<bf000888>] (generic_cpufreq_probe+0x50/0x74 [cpufreq_generic])
    [<bf000888>] (generic_cpufreq_probe [cpufreq_generic]) from [<c050e994>] (platform_drv_probe+0x18/0x48)
    [<c050e994>] (platform_drv_probe) from [<c050d1f4>] (driver_probe_device+0x128/0x370)
    [<c050d1f4>] (driver_probe_device) from [<c050d4d0>] (__driver_attach+0x94/0x98)
    [<c050d4d0>] (__driver_attach) from [<c050b778>] (bus_for_each_dev+0x54/0x88)
    [<c050b778>] (bus_for_each_dev) from [<c050c894>] (bus_add_driver+0xe8/0x204)
    [<c050c894>] (bus_add_driver) from [<c050dd48>] (driver_register+0x78/0xf4)
    [<c050dd48>] (driver_register) from [<c0208870>] (do_one_initcall+0xac/0x1d8)
    [<c0208870>] (do_one_initcall) from [<c028b6b4>] (load_module+0x190c/0x21e8)
    [<c028b6b4>] (load_module) from [<c028c034>] (SyS_init_module+0xa4/0x110)
    [<c028c034>] (SyS_init_module) from [<c020f0c0>] (ret_fast_syscall+0x0/0x48)
    
    Fixes: a0dd7b79657b (PM / OPP: Move cpufreq specific OPP functions out of generic OPP library)
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit e65b5ddba84634f31d42dfd86013f4c6be5e9e32
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Sep 27 21:56:08 2014 +0200

    cpufreq: pcc-cpufreq: Fix wait_event() under spinlock
    
    Fix the following bug introduced by commit 8fec051eea73 (cpufreq:
    Convert existing drivers to use cpufreq_freq_transition_{begin|end})
    that forgot to move the spin_lock() in pcc_cpufreq_target() past
    cpufreq_freq_transition_begin() which calls wait_event():
    
    BUG: sleeping function called from invalid context at drivers/cpufreq/cpufreq.c:370
    in_atomic(): 1, irqs_disabled(): 0, pid: 2636, name: modprobe
    Preemption disabled at:[<ffffffffa04d74d7>] pcc_cpufreq_target+0x27/0x200 [pcc_cpufreq]
    [   51.025044]
    CPU: 57 PID: 2636 Comm: modprobe Tainted: G            E  3.17.0-default #7
    Hardware name: Hewlett-Packard ProLiant DL980 G7, BIOS P66 07/07/2010
     00000000ffffffff ffff88026c46b828 ffffffff81589dbd 0000000000000000
     ffff880037978090 ffff88026c46b848 ffffffff8108e1df ffff880037978090
     0000000000000000 ffff88026c46b878 ffffffff8108e298 ffff88026d73ec00
    Call Trace:
     [<ffffffff81589dbd>] dump_stack+0x4d/0x90
     [<ffffffff8108e1df>] ___might_sleep+0x10f/0x180
     [<ffffffff8108e298>] __might_sleep+0x48/0xd0
     [<ffffffff8145b905>] cpufreq_freq_transition_begin+0x75/0x140 drivers/cpufreq/cpufreq.c:370 wait_event(policy->transition_wait, !policy->transition_ongoing);
     [<ffffffff8108fc99>] ? preempt_count_add+0xb9/0xc0
     [<ffffffffa04d7513>] pcc_cpufreq_target+0x63/0x200 [pcc_cpufreq] drivers/cpufreq/pcc-cpufreq.c:207 spin_lock(&pcc_lock);
     [<ffffffff810e0d0f>] ? update_ts_time_stats+0x7f/0xb0
     [<ffffffff8145be55>] __cpufreq_driver_target+0x85/0x170
     [<ffffffff8145e4c8>] od_check_cpu+0xa8/0xb0
     [<ffffffff8145ef10>] dbs_check_cpu+0x180/0x1d0
     [<ffffffff8145f310>] cpufreq_governor_dbs+0x3b0/0x720
     [<ffffffff8145ebe3>] od_cpufreq_governor_dbs+0x33/0xe0
     [<ffffffff814593d9>] __cpufreq_governor+0xa9/0x210
     [<ffffffff81459fb2>] cpufreq_set_policy+0x1e2/0x2e0
     [<ffffffff8145a6cc>] cpufreq_init_policy+0x8c/0x110
     [<ffffffff8145c9a0>] ? cpufreq_update_policy+0x1b0/0x1b0
     [<ffffffff8108fb99>] ? preempt_count_sub+0xb9/0x100
     [<ffffffff8145c6c6>] __cpufreq_add_dev+0x596/0x6b0
     [<ffffffffa016c608>] ? pcc_cpufreq_probe+0x4b4/0x4b4 [pcc_cpufreq]
     [<ffffffff8145c7ee>] cpufreq_add_dev+0xe/0x10
     [<ffffffff81408e81>] subsys_interface_register+0xc1/0xf0
     [<ffffffff8108fb99>] ? preempt_count_sub+0xb9/0x100
     [<ffffffff8145b3d7>] cpufreq_register_driver+0x117/0x2a0
     [<ffffffffa016c65d>] pcc_cpufreq_init+0x55/0x9f8 [pcc_cpufreq]
     [<ffffffffa016c608>] ? pcc_cpufreq_probe+0x4b4/0x4b4 [pcc_cpufreq]
     [<ffffffff81000298>] do_one_initcall+0xc8/0x1f0
     [<ffffffff811a731d>] ? __vunmap+0x9d/0x100
     [<ffffffff810eb9a0>] do_init_module+0x30/0x1b0
     [<ffffffff810edfa6>] load_module+0x686/0x710
     [<ffffffff810ebb20>] ? do_init_module+0x1b0/0x1b0
     [<ffffffff810ee1db>] SyS_init_module+0x9b/0xc0
     [<ffffffff8158f7a9>] system_call_fastpath+0x16/0x1b
    
    Fixes: 8fec051eea73 (cpufreq: Convert existing drivers to use cpufreq_freq_transition_{begin|end})
    Reported-and-tested-by: Mike Galbraith <umgwanakikbuti@gmail.com>
    Cc: 3.15+ <stable@vger.kernel.org> # 3.15+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 7106e02baed4a72fb23de56b02ad4d31daa74d95
Author: Prarit Bhargava <prarit@redhat.com>
Date:   Wed Sep 10 10:12:08 2014 -0400

    cpufreq: release policy->rwsem on error
    
    While debugging a cpufreq-related hardware failure on a system I saw the
    following lockdep warning:
    
     =========================
     [ BUG: held lock freed! ] 3.17.0-rc4+ #1 Tainted: G            E
     -------------------------
     insmod/2247 is freeing memory ffff88006e1b1400-ffff88006e1b17ff, with a lock still held there!
      (&policy->rwsem){+.+...}, at: [<ffffffff8156d37d>] __cpufreq_add_dev.isra.21+0x47d/0xb80
     3 locks held by insmod/2247:
      #0:  (subsys mutex#5){+.+.+.}, at: [<ffffffff81485579>] subsys_interface_register+0x69/0x120
      #1:  (cpufreq_rwsem){.+.+.+}, at: [<ffffffff8156cf73>] __cpufreq_add_dev.isra.21+0x73/0xb80
      #2:  (&policy->rwsem){+.+...}, at: [<ffffffff8156d37d>] __cpufreq_add_dev.isra.21+0x47d/0xb80
    
     stack backtrace:
     CPU: 0 PID: 2247 Comm: insmod Tainted: G            E  3.17.0-rc4+ #1
     Hardware name: HP ProLiant MicroServer Gen8, BIOS J06 08/24/2013
      0000000000000000 000000008f3063c4 ffff88006f87bb30 ffffffff8171b358
      ffff88006bcf3750 ffff88006f87bb68 ffffffff810e09e1 ffff88006e1b1400
      ffffea0001b86c00 ffffffff8156d327 ffff880073003500 0000000000000246
     Call Trace:
      [<ffffffff8171b358>] dump_stack+0x4d/0x66
      [<ffffffff810e09e1>] debug_check_no_locks_freed+0x171/0x180
      [<ffffffff8156d327>] ? __cpufreq_add_dev.isra.21+0x427/0xb80
      [<ffffffff8121412b>] kfree+0xab/0x2b0
      [<ffffffff8156d327>] __cpufreq_add_dev.isra.21+0x427/0xb80
      [<ffffffff81724cf7>] ? _raw_spin_unlock+0x27/0x40
      [<ffffffffa003517f>] ? pcc_cpufreq_do_osc+0x17f/0x17f [pcc_cpufreq]
      [<ffffffff8156da8e>] cpufreq_add_dev+0xe/0x10
      [<ffffffff814855d1>] subsys_interface_register+0xc1/0x120
      [<ffffffff8156bcf2>] cpufreq_register_driver+0x112/0x340
      [<ffffffff8121415a>] ? kfree+0xda/0x2b0
      [<ffffffffa003517f>] ? pcc_cpufreq_do_osc+0x17f/0x17f [pcc_cpufreq]
      [<ffffffffa003562e>] pcc_cpufreq_init+0x4af/0xe81 [pcc_cpufreq]
      [<ffffffffa003517f>] ? pcc_cpufreq_do_osc+0x17f/0x17f [pcc_cpufreq]
      [<ffffffff81002144>] do_one_initcall+0xd4/0x210
      [<ffffffff811f7472>] ? __vunmap+0xd2/0x120
      [<ffffffff81127155>] load_module+0x1315/0x1b70
      [<ffffffff811222a0>] ? store_uevent+0x70/0x70
      [<ffffffff811229d9>] ? copy_module_from_fd.isra.44+0x129/0x180
      [<ffffffff81127b86>] SyS_finit_module+0xa6/0xd0
      [<ffffffff81725b69>] system_call_fastpath+0x16/0x1b
     cpufreq: __cpufreq_add_dev: ->get() failed
    insmod: ERROR: could not insert module pcc-cpufreq.ko: No such device
    
    The warning occurs in the __cpufreq_add_dev() code which does
    
            down_write(&policy->rwsem);
            ...
            if (cpufreq_driver->get && !cpufreq_driver->setpolicy) {
                    policy->cur = cpufreq_driver->get(policy->cpu);
                    if (!policy->cur) {
                            pr_err("%s: ->get() failed\n", __func__);
                            goto err_get_freq;
                    }
    
    If cpufreq_driver->get(policy->cpu) returns an error we execute the
    code at err_get_freq, which does not up the policy->rwsem.  This causes
    the lockdep warning.
    
    Trivial patch to up the policy->rwsem in the error path.
    
    After the patch has been applied, and an error occurs in the
    cpufreq_driver->get(policy->cpu) call we will now see
    
    cpufreq: __cpufreq_add_dev: ->get() failed
    cpufreq: __cpufreq_add_dev: ->get() failed
    modprobe: ERROR: could not insert 'pcc_cpufreq': No such device
    
    Fixes: 4e97b631f24c (cpufreq: Initialize governor for a new policy under policy->rwsem)
    Signed-off-by: Prarit Bhargava <prarit@redhat.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Cc: 3.14+ <stable@vger.kernel.org> # 3.14+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 39c8bbaf67b157017929703a5eea7e83525b147c
Author: Uwe Kleine-Knig <u.kleine-koenig@pengutronix.de>
Date:   Fri Aug 8 08:56:30 2014 +0200

    cpufreq: arm_big_little: fix module license spec
    
    Having no license specification in a module taints the kernel during load
    with:
    
            arm_big_little: module license 'unspecified' taints kernel.
    
    and also the linker doesn't allow it to make use of GPL-exported symbols
    which in this case also results in errors like:
    
            arm_big_little: Unknown symbol cpufreq_register_driver (err 0)
    
    . The header of the driver specifies a GPL v2 license, so note that
    accordingly. While at it also add a description and an author and fix
    the license in a companion file to explicit v2.
    
    Reported-by: Andreas Schwab <schwab@suse.de>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Uwe Kleine-Knig <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 3c5445ce3a0c6d6935911212b735772af5115517
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Wed Aug 6 22:04:58 2014 +0200

    cpufreq: OPP: Avoid sleeping while atomic
    
    We allocate the cpufreq table after calling rcu_read_lock(),
    which disables preemption. This causes scheduling while atomic
    warnings. Use GFP_ATOMIC instead of GFP_KERNEL and update for
    kcalloc while we're here.
    
    BUG: sleeping function called from invalid context at mm/slub.c:1246
    in_atomic(): 0, irqs_disabled(): 0, pid: 80, name: modprobe
    5 locks held by modprobe/80:
     #0:  (&dev->mutex){......}, at: [<c050d484>] __driver_attach+0x48/0x98
     #1:  (&dev->mutex){......}, at: [<c050d494>] __driver_attach+0x58/0x98
     #2:  (subsys mutex#5){+.+.+.}, at: [<c050c114>] subsys_interface_register+0x38/0xc8
     #3:  (cpufreq_rwsem){.+.+.+}, at: [<c05a9c8c>] __cpufreq_add_dev.isra.22+0x84/0x92c
     #4:  (rcu_read_lock){......}, at: [<c05ab24c>] dev_pm_opp_init_cpufreq_table+0x18/0x10c
    Preemption disabled at:[<  (null)>]   (null)
    
    CPU: 2 PID: 80 Comm: modprobe Not tainted 3.16.0-rc3-next-20140701-00035-g286857f216aa-dirty #217
    [<c0214da8>] (unwind_backtrace) from [<c02123f8>] (show_stack+0x10/0x14)
    [<c02123f8>] (show_stack) from [<c070141c>] (dump_stack+0x70/0xbc)
    [<c070141c>] (dump_stack) from [<c02f4cb0>] (__kmalloc+0x124/0x250)
    [<c02f4cb0>] (__kmalloc) from [<c05ab270>] (dev_pm_opp_init_cpufreq_table+0x3c/0x10c)
    [<c05ab270>] (dev_pm_opp_init_cpufreq_table) from [<bf000508>] (cpufreq_init+0x48/0x378 [cpufreq_generic])
    [<bf000508>] (cpufreq_init [cpufreq_generic]) from [<c05a9e08>] (__cpufreq_add_dev.isra.22+0x200/0x92c)
    [<c05a9e08>] (__cpufreq_add_dev.isra.22) from [<c050c160>] (subsys_interface_register+0x84/0xc8)
    [<c050c160>] (subsys_interface_register) from [<c05a9494>] (cpufreq_register_driver+0x108/0x2d8)
    [<c05a9494>] (cpufreq_register_driver) from [<bf000888>] (generic_cpufreq_probe+0x50/0x74 [cpufreq_generic])
    [<bf000888>] (generic_cpufreq_probe [cpufreq_generic]) from [<c050e994>] (platform_drv_probe+0x18/0x48)
    [<c050e994>] (platform_drv_probe) from [<c050d1f4>] (driver_probe_device+0x128/0x370)
    [<c050d1f4>] (driver_probe_device) from [<c050d4d0>] (__driver_attach+0x94/0x98)
    [<c050d4d0>] (__driver_attach) from [<c050b778>] (bus_for_each_dev+0x54/0x88)
    [<c050b778>] (bus_for_each_dev) from [<c050c894>] (bus_add_driver+0xe8/0x204)
    [<c050c894>] (bus_add_driver) from [<c050dd48>] (driver_register+0x78/0xf4)
    [<c050dd48>] (driver_register) from [<c0208870>] (do_one_initcall+0xac/0x1d8)
    [<c0208870>] (do_one_initcall) from [<c028b6b4>] (load_module+0x190c/0x21e8)
    [<c028b6b4>] (load_module) from [<c028c034>] (SyS_init_module+0xa4/0x110)
    [<c028c034>] (SyS_init_module) from [<c020f0c0>] (ret_fast_syscall+0x0/0x48)
    
    Fixes: a0dd7b79657b (PM / OPP: Move cpufreq specific OPP functions out of generic OPP library)
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Cc: 3.16+ <stable@vger.kernel.org> # 3.16+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit eb8c68ef558e6cba241e7ada54f6b3427cb2bf68
Author: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
Date:   Mon Jan 27 22:50:35 2014 -0500

    acpi-cpufreq: De-register CPU notifier and free struct msr on error.
    
    If cpufreq_register_driver() fails we would free the acpi driver
    related structures but not free the ones allocated
    by acpi_cpufreq_boost_init() function. This meant that as
    the driver error-ed out and a CPU online/offline event came
    we would crash and burn as one of the CPU notifiers would point
    to garbage.
    
    Fixes: cfc9c8ed03e4 (acpi-cpufreq: Adjust the code to use the common boost attribute)
    Acked-by: Lukasz Majewski <l.majewski@samsung.com>
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit fcd7af917abba798cd954419030142e95139359f
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Jan 7 07:10:10 2014 +0530

    cpufreq: stats: handle cpufreq_unregister_driver() and suspend/resume properly
    
    There are several problems with cpufreq stats in the way it handles
    cpufreq_unregister_driver() and suspend/resume..
    
     - We must not lose data collected so far when suspend/resume happens
       and so stats directories must not be removed/allocated during these
       operations, which is done currently.
    
     - cpufreq_stat has registered notifiers with both cpufreq and hotplug.
       It adds sysfs stats directory with a cpufreq notifier: CPUFREQ_NOTIFY
       and removes this directory with a notifier from hotplug core.
    
       In case cpufreq_unregister_driver() is called (on rmmod cpufreq driver),
       stats directories per cpu aren't removed as CPUs are still online. The
       only call cpufreq_stats gets is cpufreq_stats_update_policy_cpu() for
       all CPUs except the last of each policy. And pointer to stat information
       is stored in the entry for last CPU in the per-cpu cpufreq_stats_table.
       But policy structure would be freed inside cpufreq core and so that will
       result in memory leak inside cpufreq stats (as we are never freeing
       memory for stats).
    
       Now if we again insert the module cpufreq_register_driver() will be
       called and we will again allocate stats data and put it on for first
       CPU of every policy.  In case we only have a single CPU per policy, we
       will return with a error from cpufreq_stats_create_table() due to this
       code:
    
            if (per_cpu(cpufreq_stats_table, cpu))
                    return -EBUSY;
    
       And so probably cpufreq stats directory would not show up anymore (as
       it was added inside last policies->kobj which doesn't exist anymore).
       I haven't tested it, though. Also the values in stats files wouldn't
       be refreshed as we are using the earlier stats structure.
    
     - CPUFREQ_NOTIFY is called from cpufreq_set_policy() which is called for
       scenarios where we don't really want cpufreq_stat_notifier_policy() to get
       called. For example whenever we are changing anything related to a policy:
       min/max/current freq, etc. cpufreq_set_policy() is called and so cpufreq
       stats is notified. Where we don't do any useful stuff other than simply
       returning with -EBUSY from cpufreq_stats_create_table(). And so this
       isn't the right notifier that cpufreq stats..
    
     Due to all above reasons this patch does following changes:
     - Add new notifiers CPUFREQ_CREATE_POLICY and CPUFREQ_REMOVE_POLICY,
       which are only called when policy is created/destroyed. They aren't
       called for suspend/resume paths..
     - Use these notifiers in cpufreq_stat_notifier_policy() to create/destory
       stats sysfs entries. And so cpufreq_unregister_driver() or suspend/resume
       shouldn't be a problem for cpufreq_stats.
     - Return early from cpufreq_stat_cpu_callback() for suspend/resume sequence,
       so that we don't free stats structure.
    
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Tested-by: Nicolas Pitre <nico@linaro.org>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 61f7c17bad20ccb763a35317508e3833f1cd5069
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Dec 31 13:37:46 2013 +0100

    intel_pstate: Fail initialization if P-state information is missing
    
    commit 98a947abdd54e5de909bebadfced1696ccad30cf upstream.
    
    If pstate.current_pstate is 0 after the initial
    intel_pstate_get_cpu_pstates(), this means that we were unable to
    obtain any useful P-state information and there is no reason to
    continue, so free memory and return an error in that case.
    
    This fixes the following divide error occuring in a nested KVM
    guest:
    
    Intel P-state driver initializing.
    Intel pstate controlling: cpu 0
    cpufreq: __cpufreq_add_dev: ->get() failed
    divide error: 0000 [#1] SMP
    Modules linked in:
    CPU: 0 PID: 1 Comm: swapper/0 Not tainted 3.13.0-0.rc4.git5.1.fc21.x86_64 #1
    Hardware name: Bochs Bochs, BIOS Bochs 01/01/2011
    task: ffff88001ea20000 ti: ffff88001e9bc000 task.ti: ffff88001e9bc000
    RIP: 0010:[<ffffffff815c551d>]  [<ffffffff815c551d>] intel_pstate_timer_func+0x11d/0x2b0
    RSP: 0000:ffff88001ee03e18  EFLAGS: 00010246
    RAX: 0000000000000000 RBX: ffff88001a454348 RCX: 0000000000006100
    RDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000000000000
    RBP: ffff88001ee03e38 R08: 0000000000000000 R09: 0000000000000000
    R10: ffff88001ea20000 R11: 0000000000000000 R12: 00000c0a1ea20000
    R13: 1ea200001ea20000 R14: ffffffff815c5400 R15: ffff88001a454348
    FS:  0000000000000000(0000) GS:ffff88001ee00000(0000) knlGS:0000000000000000
    CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b
    CR2: 0000000000000000 CR3: 0000000001c0c000 CR4: 00000000000006f0
    Stack:
     fffffffb1a454390 ffffffff821a4500 ffff88001a454390 0000000000000100
     ffff88001ee03ea8 ffffffff81083e9a ffffffff81083e15 ffffffff82d5ed40
     ffffffff8258cc60 0000000000000000 ffffffff81ac39de 0000000000000000
    Call Trace:
     <IRQ>
     [<ffffffff81083e9a>] call_timer_fn+0x8a/0x310
     [<ffffffff81083e15>] ? call_timer_fn+0x5/0x310
     [<ffffffff815c5400>] ? pid_param_set+0x130/0x130
     [<ffffffff81084354>] run_timer_softirq+0x234/0x380
     [<ffffffff8107aee4>] __do_softirq+0x104/0x430
     [<ffffffff8107b5fd>] irq_exit+0xcd/0xe0
     [<ffffffff81770645>] smp_apic_timer_interrupt+0x45/0x60
     [<ffffffff8176efb2>] apic_timer_interrupt+0x72/0x80
     <EOI>
     [<ffffffff810e15cd>] ? vprintk_emit+0x1dd/0x5e0
     [<ffffffff81757719>] printk+0x67/0x69
     [<ffffffff815c1493>] __cpufreq_add_dev.isra.13+0x883/0x8d0
     [<ffffffff815c14f0>] cpufreq_add_dev+0x10/0x20
     [<ffffffff814a14d1>] subsys_interface_register+0xb1/0xf0
     [<ffffffff815bf5cf>] cpufreq_register_driver+0x9f/0x210
     [<ffffffff81fb19af>] intel_pstate_init+0x27d/0x3be
     [<ffffffff81761e3e>] ? mutex_unlock+0xe/0x10
     [<ffffffff81fb1732>] ? cpufreq_gov_dbs_init+0x12/0x12
     [<ffffffff8100214a>] do_one_initcall+0xfa/0x1b0
     [<ffffffff8109dbf5>] ? parse_args+0x225/0x3f0
     [<ffffffff81f64193>] kernel_init_freeable+0x1fc/0x287
     [<ffffffff81f638d0>] ? do_early_param+0x88/0x88
     [<ffffffff8174b530>] ? rest_init+0x150/0x150
     [<ffffffff8174b53e>] kernel_init+0xe/0x130
     [<ffffffff8176e27c>] ret_from_fork+0x7c/0xb0
     [<ffffffff8174b530>] ? rest_init+0x150/0x150
    Code: c1 e0 05 48 63 bc 03 10 01 00 00 48 63 83 d0 00 00 00 48 63 d6 48 c1 e2 08 c1 e1 08 4c 63 c2 48 c1 e0 08 48 98 48 c1 e0 08 48 99 <49> f7 f8 48 98 48 0f af f8 48 c1 ff 08 29 f9 89 ca c1 fa 1f 89
    RIP  [<ffffffff815c551d>] intel_pstate_timer_func+0x11d/0x2b0
     RSP <ffff88001ee03e18>
    ---[ end trace f166110ed22cc37a ]---
    Kernel panic - not syncing: Fatal exception in interrupt
    
    Reported-and-tested-by: Kashyap Chamarthy <kchamart@redhat.com>
    Cc: Josh Boyer <jwboyer@fedoraproject.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit ec84b71390b0433179f25364979d500453bf0468
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Dec 31 13:37:46 2013 +0100

    intel_pstate: Fail initialization if P-state information is missing
    
    commit 98a947abdd54e5de909bebadfced1696ccad30cf upstream.
    
    If pstate.current_pstate is 0 after the initial
    intel_pstate_get_cpu_pstates(), this means that we were unable to
    obtain any useful P-state information and there is no reason to
    continue, so free memory and return an error in that case.
    
    This fixes the following divide error occuring in a nested KVM
    guest:
    
    Intel P-state driver initializing.
    Intel pstate controlling: cpu 0
    cpufreq: __cpufreq_add_dev: ->get() failed
    divide error: 0000 [#1] SMP
    Modules linked in:
    CPU: 0 PID: 1 Comm: swapper/0 Not tainted 3.13.0-0.rc4.git5.1.fc21.x86_64 #1
    Hardware name: Bochs Bochs, BIOS Bochs 01/01/2011
    task: ffff88001ea20000 ti: ffff88001e9bc000 task.ti: ffff88001e9bc000
    RIP: 0010:[<ffffffff815c551d>]  [<ffffffff815c551d>] intel_pstate_timer_func+0x11d/0x2b0
    RSP: 0000:ffff88001ee03e18  EFLAGS: 00010246
    RAX: 0000000000000000 RBX: ffff88001a454348 RCX: 0000000000006100
    RDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000000000000
    RBP: ffff88001ee03e38 R08: 0000000000000000 R09: 0000000000000000
    R10: ffff88001ea20000 R11: 0000000000000000 R12: 00000c0a1ea20000
    R13: 1ea200001ea20000 R14: ffffffff815c5400 R15: ffff88001a454348
    FS:  0000000000000000(0000) GS:ffff88001ee00000(0000) knlGS:0000000000000000
    CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b
    CR2: 0000000000000000 CR3: 0000000001c0c000 CR4: 00000000000006f0
    Stack:
     fffffffb1a454390 ffffffff821a4500 ffff88001a454390 0000000000000100
     ffff88001ee03ea8 ffffffff81083e9a ffffffff81083e15 ffffffff82d5ed40
     ffffffff8258cc60 0000000000000000 ffffffff81ac39de 0000000000000000
    Call Trace:
     <IRQ>
     [<ffffffff81083e9a>] call_timer_fn+0x8a/0x310
     [<ffffffff81083e15>] ? call_timer_fn+0x5/0x310
     [<ffffffff815c5400>] ? pid_param_set+0x130/0x130
     [<ffffffff81084354>] run_timer_softirq+0x234/0x380
     [<ffffffff8107aee4>] __do_softirq+0x104/0x430
     [<ffffffff8107b5fd>] irq_exit+0xcd/0xe0
     [<ffffffff81770645>] smp_apic_timer_interrupt+0x45/0x60
     [<ffffffff8176efb2>] apic_timer_interrupt+0x72/0x80
     <EOI>
     [<ffffffff810e15cd>] ? vprintk_emit+0x1dd/0x5e0
     [<ffffffff81757719>] printk+0x67/0x69
     [<ffffffff815c1493>] __cpufreq_add_dev.isra.13+0x883/0x8d0
     [<ffffffff815c14f0>] cpufreq_add_dev+0x10/0x20
     [<ffffffff814a14d1>] subsys_interface_register+0xb1/0xf0
     [<ffffffff815bf5cf>] cpufreq_register_driver+0x9f/0x210
     [<ffffffff81fb19af>] intel_pstate_init+0x27d/0x3be
     [<ffffffff81761e3e>] ? mutex_unlock+0xe/0x10
     [<ffffffff81fb1732>] ? cpufreq_gov_dbs_init+0x12/0x12
     [<ffffffff8100214a>] do_one_initcall+0xfa/0x1b0
     [<ffffffff8109dbf5>] ? parse_args+0x225/0x3f0
     [<ffffffff81f64193>] kernel_init_freeable+0x1fc/0x287
     [<ffffffff81f638d0>] ? do_early_param+0x88/0x88
     [<ffffffff8174b530>] ? rest_init+0x150/0x150
     [<ffffffff8174b53e>] kernel_init+0xe/0x130
     [<ffffffff8176e27c>] ret_from_fork+0x7c/0xb0
     [<ffffffff8174b530>] ? rest_init+0x150/0x150
    Code: c1 e0 05 48 63 bc 03 10 01 00 00 48 63 83 d0 00 00 00 48 63 d6 48 c1 e2 08 c1 e1 08 4c 63 c2 48 c1 e0 08 48 98 48 c1 e0 08 48 99 <49> f7 f8 48 98 48 0f af f8 48 c1 ff 08 29 f9 89 ca c1 fa 1f 89
    RIP  [<ffffffff815c551d>] intel_pstate_timer_func+0x11d/0x2b0
     RSP <ffff88001ee03e18>
    ---[ end trace f166110ed22cc37a ]---
    Kernel panic - not syncing: Fatal exception in interrupt
    
    Reported-and-tested-by: Kashyap Chamarthy <kchamart@redhat.com>
    Cc: Josh Boyer <jwboyer@fedoraproject.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 98a947abdd54e5de909bebadfced1696ccad30cf
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Dec 31 13:37:46 2013 +0100

    intel_pstate: Fail initialization if P-state information is missing
    
    If pstate.current_pstate is 0 after the initial
    intel_pstate_get_cpu_pstates(), this means that we were unable to
    obtain any useful P-state information and there is no reason to
    continue, so free memory and return an error in that case.
    
    This fixes the following divide error occuring in a nested KVM
    guest:
    
    Intel P-state driver initializing.
    Intel pstate controlling: cpu 0
    cpufreq: __cpufreq_add_dev: ->get() failed
    divide error: 0000 [#1] SMP
    Modules linked in:
    CPU: 0 PID: 1 Comm: swapper/0 Not tainted 3.13.0-0.rc4.git5.1.fc21.x86_64 #1
    Hardware name: Bochs Bochs, BIOS Bochs 01/01/2011
    task: ffff88001ea20000 ti: ffff88001e9bc000 task.ti: ffff88001e9bc000
    RIP: 0010:[<ffffffff815c551d>]  [<ffffffff815c551d>] intel_pstate_timer_func+0x11d/0x2b0
    RSP: 0000:ffff88001ee03e18  EFLAGS: 00010246
    RAX: 0000000000000000 RBX: ffff88001a454348 RCX: 0000000000006100
    RDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000000000000
    RBP: ffff88001ee03e38 R08: 0000000000000000 R09: 0000000000000000
    R10: ffff88001ea20000 R11: 0000000000000000 R12: 00000c0a1ea20000
    R13: 1ea200001ea20000 R14: ffffffff815c5400 R15: ffff88001a454348
    FS:  0000000000000000(0000) GS:ffff88001ee00000(0000) knlGS:0000000000000000
    CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b
    CR2: 0000000000000000 CR3: 0000000001c0c000 CR4: 00000000000006f0
    Stack:
     fffffffb1a454390 ffffffff821a4500 ffff88001a454390 0000000000000100
     ffff88001ee03ea8 ffffffff81083e9a ffffffff81083e15 ffffffff82d5ed40
     ffffffff8258cc60 0000000000000000 ffffffff81ac39de 0000000000000000
    Call Trace:
     <IRQ>
     [<ffffffff81083e9a>] call_timer_fn+0x8a/0x310
     [<ffffffff81083e15>] ? call_timer_fn+0x5/0x310
     [<ffffffff815c5400>] ? pid_param_set+0x130/0x130
     [<ffffffff81084354>] run_timer_softirq+0x234/0x380
     [<ffffffff8107aee4>] __do_softirq+0x104/0x430
     [<ffffffff8107b5fd>] irq_exit+0xcd/0xe0
     [<ffffffff81770645>] smp_apic_timer_interrupt+0x45/0x60
     [<ffffffff8176efb2>] apic_timer_interrupt+0x72/0x80
     <EOI>
     [<ffffffff810e15cd>] ? vprintk_emit+0x1dd/0x5e0
     [<ffffffff81757719>] printk+0x67/0x69
     [<ffffffff815c1493>] __cpufreq_add_dev.isra.13+0x883/0x8d0
     [<ffffffff815c14f0>] cpufreq_add_dev+0x10/0x20
     [<ffffffff814a14d1>] subsys_interface_register+0xb1/0xf0
     [<ffffffff815bf5cf>] cpufreq_register_driver+0x9f/0x210
     [<ffffffff81fb19af>] intel_pstate_init+0x27d/0x3be
     [<ffffffff81761e3e>] ? mutex_unlock+0xe/0x10
     [<ffffffff81fb1732>] ? cpufreq_gov_dbs_init+0x12/0x12
     [<ffffffff8100214a>] do_one_initcall+0xfa/0x1b0
     [<ffffffff8109dbf5>] ? parse_args+0x225/0x3f0
     [<ffffffff81f64193>] kernel_init_freeable+0x1fc/0x287
     [<ffffffff81f638d0>] ? do_early_param+0x88/0x88
     [<ffffffff8174b530>] ? rest_init+0x150/0x150
     [<ffffffff8174b53e>] kernel_init+0xe/0x130
     [<ffffffff8176e27c>] ret_from_fork+0x7c/0xb0
     [<ffffffff8174b530>] ? rest_init+0x150/0x150
    Code: c1 e0 05 48 63 bc 03 10 01 00 00 48 63 83 d0 00 00 00 48 63 d6 48 c1 e2 08 c1 e1 08 4c 63 c2 48 c1 e0 08 48 98 48 c1 e0 08 48 99 <49> f7 f8 48 98 48 0f af f8 48 c1 ff 08 29 f9 89 ca c1 fa 1f 89
    RIP  [<ffffffff815c551d>] intel_pstate_timer_func+0x11d/0x2b0
     RSP <ffff88001ee03e18>
    ---[ end trace f166110ed22cc37a ]---
    Kernel panic - not syncing: Fatal exception in interrupt
    
    Reported-and-tested-by: Kashyap Chamarthy <kchamart@redhat.com>
    Cc: Josh Boyer <jwboyer@fedoraproject.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: All applicable <stable@vger.kernel.org>

commit 8a61e12e84597b5f8155ac91b44dea866ccfaac2
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Fri Sep 20 10:43:56 2013 -0700

    acpi-cpufreq: skip loading acpi_cpufreq after intel_pstate
    
    If the hw supports intel_pstate and acpi_cpufreq, intel_pstate will
    get loaded first.
    
    acpi_cpufreq_init() will call acpi_cpufreq_early_init()
    and that will allocate perf data and init those perf data in ACPI core,
    (that will cover all CPUs). But later it will free them as
    cpufreq_register_driver(acpi_cpufreq) will fail as intel_pstate is
    already registered
    
    Use cpufreq_get_current_driver() to check if we can skip the
    acpi_cpufreq loading.
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 4dea5806d332f91d640d99943db99a5539e832c3
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Wed Sep 18 21:05:20 2013 -0700

    cpufreq: return EEXIST instead of EBUSY for second registering
    
    On systems that support intel_pstate, acpi_cpufreq fails to load, and
    udev keeps trying until trace gets filled up and kernel crashes.
    
    The root cause is driver return ret from cpufreq_register_driver(),
    because when some other driver takes over before, it will return
    EBUSY and then udev will keep trying ...
    
    cpufreq_register_driver() should return EEXIST instead so that the
    system can boot without appending intel_pstate=disable and still use
    intel_pstate.
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 5025d628c8659fbf939f929107bf76db81dcdfff
Author: Li Zhong <zhong@linux.vnet.ibm.com>
Date:   Wed Aug 21 01:31:08 2013 +0200

    cpufreq: fix bad unlock balance on !CONFIG_SMP
    
    This patch tries to fix lockdep complaint attached below.
    
    It seems that we should always read acquire the cpufreq_rwsem,
    whether CONFIG_SMP is enabled or not.  And CONFIG_HOTPLUG_CPU
    depends on CONFIG_SMP, so it seems we don't need CONFIG_SMP for the
    code enabled by CONFIG_HOTPLUG_CPU.
    
    [    0.504191] =====================================
    [    0.504627] [ BUG: bad unlock balance detected! ]
    [    0.504627] 3.11.0-rc6-next-20130819 #1 Not tainted
    [    0.504627] -------------------------------------
    [    0.504627] swapper/1 is trying to release lock (cpufreq_rwsem) at:
    [    0.504627] [<ffffffff813d927a>] cpufreq_add_dev+0x13a/0x3e0
    [    0.504627] but there are no more locks to release!
    [    0.504627]
    [    0.504627] other info that might help us debug this:
    [    0.504627] 1 lock held by swapper/1:
    [    0.504627]  #0:  (subsys mutex#4){+.+.+.}, at: [<ffffffff8134a7bf>] subsys_interface_register+0x4f/0xe0
    [    0.504627]
    [    0.504627] stack backtrace:
    [    0.504627] CPU: 0 PID: 1 Comm: swapper Not tainted 3.11.0-rc6-next-20130819 #1
    [    0.504627] Hardware name: Bochs Bochs, BIOS Bochs 01/01/2007
    [    0.504627]  ffffffff813d927a ffff88007f847c98 ffffffff814c062b ffff88007f847cc8
    [    0.504627]  ffffffff81098bce ffff88007f847cf8 ffffffff81aadc30 ffffffff813d927a
    [    0.504627]  00000000ffffffff ffff88007f847d68 ffffffff8109d0be 0000000000000006
    [    0.504627] Call Trace:
    [    0.504627]  [<ffffffff813d927a>] ? cpufreq_add_dev+0x13a/0x3e0
    [    0.504627]  [<ffffffff814c062b>] dump_stack+0x19/0x1b
    [    0.504627]  [<ffffffff81098bce>] print_unlock_imbalance_bug+0xfe/0x110
    [    0.504627]  [<ffffffff813d927a>] ? cpufreq_add_dev+0x13a/0x3e0
    [    0.504627]  [<ffffffff8109d0be>] lock_release_non_nested+0x1ee/0x310
    [    0.504627]  [<ffffffff81099d0e>] ? mark_held_locks+0xae/0x120
    [    0.504627]  [<ffffffff811510cb>] ? kfree+0xcb/0x1d0
    [    0.504627]  [<ffffffff813d77ea>] ? cpufreq_policy_free+0x4a/0x60
    [    0.504627]  [<ffffffff813d927a>] ? cpufreq_add_dev+0x13a/0x3e0
    [    0.504627]  [<ffffffff8109d2a4>] lock_release+0xc4/0x250
    [    0.504627]  [<ffffffff8106c9f3>] up_read+0x23/0x40
    [    0.504627]  [<ffffffff813d927a>] cpufreq_add_dev+0x13a/0x3e0
    [    0.504627]  [<ffffffff8134a809>] subsys_interface_register+0x99/0xe0
    [    0.504627]  [<ffffffff81b19f3b>] ? cpufreq_gov_dbs_init+0x12/0x12
    [    0.504627]  [<ffffffff813d7f0d>] cpufreq_register_driver+0x9d/0x1d0
    [    0.504627]  [<ffffffff81b19f3b>] ? cpufreq_gov_dbs_init+0x12/0x12
    [    0.504627]  [<ffffffff81b1a039>] acpi_cpufreq_init+0xfe/0x1f8
    [    0.504627]  [<ffffffff810002ba>] do_one_initcall+0xda/0x180
    [    0.504627]  [<ffffffff81ae301e>] kernel_init_freeable+0x12c/0x1bb
    [    0.504627]  [<ffffffff81ae2841>] ? do_early_param+0x8c/0x8c
    [    0.504627]  [<ffffffff814b4dd0>] ? rest_init+0x140/0x140
    [    0.504627]  [<ffffffff814b4dde>] kernel_init+0xe/0xf0
    [    0.504627]  [<ffffffff814d029a>] ret_from_fork+0x7a/0xb0
    [    0.504627]  [<ffffffff814b4dd0>] ? rest_init+0x140/0x140
    
    Signed-off-by: Li Zhong <zhong@linux.vnet.ibm.com>
    Acked-and-tested-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 1c3d85dd4e21a405e8de54131a5f759f9a0115b7
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Apr 29 00:08:16 2013 +0200

    cpufreq: Revert incorrect commit 5800043
    
    Commit 5800043 (cpufreq: convert cpufreq_driver to using RCU) causes
    the following call trace to be spit on boot:
    
     BUG: sleeping function called from invalid context at /scratch/rafael/work/linux-pm/mm/slab.c:3179
     in_atomic(): 0, irqs_disabled(): 0, pid: 292, name: systemd-udevd
     2 locks held by systemd-udevd/292:
      #0:  (subsys mutex){+.+.+.}, at: [<ffffffff8146851a>] subsys_interface_register+0x4a/0xe0
      #1:  (rcu_read_lock){.+.+.+}, at: [<ffffffff81538210>] cpufreq_add_dev_interface+0x60/0x5e0
     Pid: 292, comm: systemd-udevd Not tainted 3.9.0-rc8+ #323
     Call Trace:
      [<ffffffff81072c90>] __might_sleep+0x140/0x1f0
      [<ffffffff811581c2>] kmem_cache_alloc+0x42/0x2b0
      [<ffffffff811e7179>] sysfs_new_dirent+0x59/0x130
      [<ffffffff811e63cb>] sysfs_add_file_mode+0x6b/0x110
      [<ffffffff81538210>] ? cpufreq_add_dev_interface+0x60/0x5e0
      [<ffffffff810a3254>] ? __lock_is_held+0x54/0x80
      [<ffffffff811e647d>] sysfs_add_file+0xd/0x10
      [<ffffffff811e6541>] sysfs_create_file+0x21/0x30
      [<ffffffff81538280>] cpufreq_add_dev_interface+0xd0/0x5e0
      [<ffffffff81538210>] ? cpufreq_add_dev_interface+0x60/0x5e0
      [<ffffffffa000337f>] ? acpi_processor_get_platform_limit+0x32/0xbb [processor]
      [<ffffffffa022f540>] ? do_drv_write+0x70/0x70 [acpi_cpufreq]
      [<ffffffff810a3254>] ? __lock_is_held+0x54/0x80
      [<ffffffff8106c97e>] ? up_read+0x1e/0x40
      [<ffffffff8106e632>] ? __blocking_notifier_call_chain+0x72/0xc0
      [<ffffffff81538dbd>] cpufreq_add_dev+0x62d/0xae0
      [<ffffffff815389b8>] ? cpufreq_add_dev+0x228/0xae0
      [<ffffffff81468569>] subsys_interface_register+0x99/0xe0
      [<ffffffffa014d000>] ? 0xffffffffa014cfff
      [<ffffffff81535d5d>] cpufreq_register_driver+0x9d/0x200
      [<ffffffffa014d000>] ? 0xffffffffa014cfff
      [<ffffffffa014d0e9>] acpi_cpufreq_init+0xe9/0x1000 [acpi_cpufreq]
      [<ffffffff810002fa>] do_one_initcall+0x11a/0x170
      [<ffffffff810b4b87>] load_module+0x1cf7/0x2920
      [<ffffffff81322580>] ? ddebug_proc_open+0xb0/0xb0
      [<ffffffff816baee0>] ? retint_restore_args+0xe/0xe
      [<ffffffff810b5887>] sys_init_module+0xd7/0x120
      [<ffffffff816bb6d2>] system_call_fastpath+0x16/0x1b
    
    which is quite obvious, because that commit put (multiple instances
    of) sysfs_create_file() under rcu_read_lock()/rcu_read_unlock(),
    although sysfs_create_file() may cause memory to be allocated with
    GFP_KERNEL and that may sleep, which is not permitted in RCU read
    critical section.
    
    Revert the buggy commit altogether along with some changes on top
    of it.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 907cc908108b16ae87b7165be992511c968159f0
Author: Dirk Brandewie <dirk.brandewie@gmail.com>
Date:   Tue Mar 5 14:15:27 2013 -0800

    cpufreq / intel_pstate: Fix intel_pstate_init() error path
    
    If cpufreq_register_driver() fails just free memory that has been
    allocated and return. intel_pstate_exit() function is removed since we
    are built-in only now there is no reason for a module exit procedure.
    
    Reported-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Signed-off-by: Dirk Brandewie <dirk.j.brandewie@intel.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 2b5b4eda6132079ec9f5c623115239b62bedb9c4
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Tue Oct 12 09:09:37 2010 +0800

    acpi-cpufreq: fix a memleak when unloading driver
    
    commit dab5fff14df2cd16eb1ad4c02e83915e1063fece upstream.
    
    We didn't free per_cpu(acfreq_data, cpu)->freq_table
    when acpi_freq driver is unloaded.
    
    Resulting in the following messages in /sys/kernel/debug/kmemleak:
    
    unreferenced object 0xf6450e80 (size 64):
      comm "modprobe", pid 1066, jiffies 4294677317 (age 19290.453s)
      hex dump (first 32 bytes):
        00 00 00 00 e8 a2 24 00 01 00 00 00 00 9f 24 00  ......$.......$.
        02 00 00 00 00 6a 18 00 03 00 00 00 00 35 0c 00  .....j.......5..
      backtrace:
        [<c123ba97>] kmemleak_alloc+0x27/0x50
        [<c109f96f>] __kmalloc+0xcf/0x110
        [<f9da97ee>] acpi_cpufreq_cpu_init+0x1ee/0x4e4 [acpi_cpufreq]
        [<c11cd8d2>] cpufreq_add_dev+0x142/0x3a0
        [<c11920b7>] sysdev_driver_register+0x97/0x110
        [<c11cce56>] cpufreq_register_driver+0x86/0x140
        [<f9dad080>] 0xf9dad080
        [<c1001130>] do_one_initcall+0x30/0x160
        [<c10626e9>] sys_init_module+0x99/0x1e0
        [<c1002d97>] sysenter_do_call+0x12/0x26
        [<ffffffff>] 0xffffffff
    
    https://bugzilla.kernel.org/show_bug.cgi?id=15807#c21
    
    Tested-by: Toralf Forster <toralf.foerster@gmx.de>
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

commit eef5b035840ebdcdaa6ed18591c8e9e9cebb668c
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Tue Oct 12 09:09:37 2010 +0800

    acpi-cpufreq: fix a memleak when unloading driver
    
    commit dab5fff14df2cd16eb1ad4c02e83915e1063fece upstream.
    
    We didn't free per_cpu(acfreq_data, cpu)->freq_table
    when acpi_freq driver is unloaded.
    
    Resulting in the following messages in /sys/kernel/debug/kmemleak:
    
    unreferenced object 0xf6450e80 (size 64):
      comm "modprobe", pid 1066, jiffies 4294677317 (age 19290.453s)
      hex dump (first 32 bytes):
        00 00 00 00 e8 a2 24 00 01 00 00 00 00 9f 24 00  ......$.......$.
        02 00 00 00 00 6a 18 00 03 00 00 00 00 35 0c 00  .....j.......5..
      backtrace:
        [<c123ba97>] kmemleak_alloc+0x27/0x50
        [<c109f96f>] __kmalloc+0xcf/0x110
        [<f9da97ee>] acpi_cpufreq_cpu_init+0x1ee/0x4e4 [acpi_cpufreq]
        [<c11cd8d2>] cpufreq_add_dev+0x142/0x3a0
        [<c11920b7>] sysdev_driver_register+0x97/0x110
        [<c11cce56>] cpufreq_register_driver+0x86/0x140
        [<f9dad080>] 0xf9dad080
        [<c1001130>] do_one_initcall+0x30/0x160
        [<c10626e9>] sys_init_module+0x99/0x1e0
        [<c1002d97>] sysenter_do_call+0x12/0x26
        [<ffffffff>] 0xffffffff
    
    https://bugzilla.kernel.org/show_bug.cgi?id=15807#c21
    
    Tested-by: Toralf Forster <toralf.foerster@gmx.de>
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 8f5bc2abfd4240b1f55425a3d36b6e6c391bc148
Author: Jiri Slaby <jirislaby@kernel.org>
Date:   Tue Mar 1 17:41:10 2011 +0100

    [CPUFREQ] fix BUG on cpufreq policy init failure
    
    cpufreq_register_driver sets cpufreq_driver to a structure owned (and
    placed) in the caller's memory. If cpufreq policy fails in its ->init
    function, sysdev_driver_register returns nonzero in
    cpufreq_register_driver. Now, cpufreq_register_driver returns an error
    without setting cpufreq_driver back to NULL.
    
    Usually cpufreq policy modules are unloaded because they propagate the
    error to the module init function and return that.
    
    So a later access to any member of cpufreq_driver causes bugs like:
    BUG: unable to handle kernel paging request at ffffffffa00270a0
    IP: [<ffffffff8145eca3>] cpufreq_cpu_get+0x53/0xe0
    PGD 1805067 PUD 1809063 PMD 1c3f90067 PTE 0
    Oops: 0000 [#1] SMP
    last sysfs file: /sys/devices/virtual/net/tun0/statistics/collisions
    CPU 0
    Modules linked in: ...
    Pid: 5677, comm: thunderbird-bin Tainted: G        W   2.6.38-rc4-mm1_64+ #1389 To be filled by O.E.M./To Be Filled By O.E.M.
    RIP: 0010:[<ffffffff8145eca3>]  [<ffffffff8145eca3>] cpufreq_cpu_get+0x53/0xe0
    RSP: 0018:ffff8801aec37d98  EFLAGS: 00010086
    RAX: 0000000000000202 RBX: 0000000000000000 RCX: 0000000000000001
    RDX: ffffffffa00270a0 RSI: 0000000000001000 RDI: ffffffff8199ece8
    ...
    Call Trace:
     [<ffffffff8145f490>] cpufreq_quick_get+0x10/0x30
     [<ffffffff8103f12b>] show_cpuinfo+0x2ab/0x300
     [<ffffffff81136292>] seq_read+0xf2/0x3f0
     [<ffffffff8126c5d3>] ? __strncpy_from_user+0x33/0x60
     [<ffffffff8116850d>] proc_reg_read+0x6d/0xa0
     [<ffffffff81116e53>] vfs_read+0xc3/0x180
     [<ffffffff81116f5c>] sys_read+0x4c/0x90
     [<ffffffff81030dbb>] system_call_fastpath+0x16/0x1b
    ...
    
    It's all cause by weird fail path handling in cpufreq_register_driver.
    To fix that, shuffle the code to do proper handling with gotos.
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Signed-off-by: Dave Jones <davej@redhat.com>

commit a499d3ff08c1c10821a2a1811fe8597d50a8de62
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Tue Oct 12 09:09:37 2010 +0800

    acpi-cpufreq: fix a memleak when unloading driver
    
    commit dab5fff14df2cd16eb1ad4c02e83915e1063fece upstream.
    
    We didn't free per_cpu(acfreq_data, cpu)->freq_table
    when acpi_freq driver is unloaded.
    
    Resulting in the following messages in /sys/kernel/debug/kmemleak:
    
    unreferenced object 0xf6450e80 (size 64):
      comm "modprobe", pid 1066, jiffies 4294677317 (age 19290.453s)
      hex dump (first 32 bytes):
        00 00 00 00 e8 a2 24 00 01 00 00 00 00 9f 24 00  ......$.......$.
        02 00 00 00 00 6a 18 00 03 00 00 00 00 35 0c 00  .....j.......5..
      backtrace:
        [<c123ba97>] kmemleak_alloc+0x27/0x50
        [<c109f96f>] __kmalloc+0xcf/0x110
        [<f9da97ee>] acpi_cpufreq_cpu_init+0x1ee/0x4e4 [acpi_cpufreq]
        [<c11cd8d2>] cpufreq_add_dev+0x142/0x3a0
        [<c11920b7>] sysdev_driver_register+0x97/0x110
        [<c11cce56>] cpufreq_register_driver+0x86/0x140
        [<f9dad080>] 0xf9dad080
        [<c1001130>] do_one_initcall+0x30/0x160
        [<c10626e9>] sys_init_module+0x99/0x1e0
        [<c1002d97>] sysenter_do_call+0x12/0x26
        [<ffffffff>] 0xffffffff
    
    https://bugzilla.kernel.org/show_bug.cgi?id=15807#c21
    
    Tested-by: Toralf Forster <toralf.foerster@gmx.de>
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Andi Kleen <ak@linux.intel.com>

commit 2296669af38b934128f493bf0beee1505a26f800
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Tue Oct 12 09:09:37 2010 +0800

    acpi-cpufreq: fix a memleak when unloading driver
    
    commit dab5fff14df2cd16eb1ad4c02e83915e1063fece upstream.
    
    We didn't free per_cpu(acfreq_data, cpu)->freq_table
    when acpi_freq driver is unloaded.
    
    Resulting in the following messages in /sys/kernel/debug/kmemleak:
    
    unreferenced object 0xf6450e80 (size 64):
      comm "modprobe", pid 1066, jiffies 4294677317 (age 19290.453s)
      hex dump (first 32 bytes):
        00 00 00 00 e8 a2 24 00 01 00 00 00 00 9f 24 00  ......$.......$.
        02 00 00 00 00 6a 18 00 03 00 00 00 00 35 0c 00  .....j.......5..
      backtrace:
        [<c123ba97>] kmemleak_alloc+0x27/0x50
        [<c109f96f>] __kmalloc+0xcf/0x110
        [<f9da97ee>] acpi_cpufreq_cpu_init+0x1ee/0x4e4 [acpi_cpufreq]
        [<c11cd8d2>] cpufreq_add_dev+0x142/0x3a0
        [<c11920b7>] sysdev_driver_register+0x97/0x110
        [<c11cce56>] cpufreq_register_driver+0x86/0x140
        [<f9dad080>] 0xf9dad080
        [<c1001130>] do_one_initcall+0x30/0x160
        [<c10626e9>] sys_init_module+0x99/0x1e0
        [<c1002d97>] sysenter_do_call+0x12/0x26
        [<ffffffff>] 0xffffffff
    
    https://bugzilla.kernel.org/show_bug.cgi?id=15807#c21
    
    Tested-by: Toralf Forster <toralf.foerster@gmx.de>
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit c46e0edd8b6d4eb9789f9aa8a1315da8b0293059
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Tue Oct 12 09:09:37 2010 +0800

    acpi-cpufreq: fix a memleak when unloading driver
    
    commit dab5fff14df2cd16eb1ad4c02e83915e1063fece upstream.
    
    We didn't free per_cpu(acfreq_data, cpu)->freq_table
    when acpi_freq driver is unloaded.
    
    Resulting in the following messages in /sys/kernel/debug/kmemleak:
    
    unreferenced object 0xf6450e80 (size 64):
      comm "modprobe", pid 1066, jiffies 4294677317 (age 19290.453s)
      hex dump (first 32 bytes):
        00 00 00 00 e8 a2 24 00 01 00 00 00 00 9f 24 00  ......$.......$.
        02 00 00 00 00 6a 18 00 03 00 00 00 00 35 0c 00  .....j.......5..
      backtrace:
        [<c123ba97>] kmemleak_alloc+0x27/0x50
        [<c109f96f>] __kmalloc+0xcf/0x110
        [<f9da97ee>] acpi_cpufreq_cpu_init+0x1ee/0x4e4 [acpi_cpufreq]
        [<c11cd8d2>] cpufreq_add_dev+0x142/0x3a0
        [<c11920b7>] sysdev_driver_register+0x97/0x110
        [<c11cce56>] cpufreq_register_driver+0x86/0x140
        [<f9dad080>] 0xf9dad080
        [<c1001130>] do_one_initcall+0x30/0x160
        [<c10626e9>] sys_init_module+0x99/0x1e0
        [<c1002d97>] sysenter_do_call+0x12/0x26
        [<ffffffff>] 0xffffffff
    
    https://bugzilla.kernel.org/show_bug.cgi?id=15807#c21
    
    Tested-by: Toralf Forster <toralf.foerster@gmx.de>
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 8d41cfeeacabaaace31b13071a46b8e0e4afb592
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Tue Oct 12 09:09:37 2010 +0800

    acpi-cpufreq: fix a memleak when unloading driver
    
    commit dab5fff14df2cd16eb1ad4c02e83915e1063fece upstream.
    
    We didn't free per_cpu(acfreq_data, cpu)->freq_table
    when acpi_freq driver is unloaded.
    
    Resulting in the following messages in /sys/kernel/debug/kmemleak:
    
    unreferenced object 0xf6450e80 (size 64):
      comm "modprobe", pid 1066, jiffies 4294677317 (age 19290.453s)
      hex dump (first 32 bytes):
        00 00 00 00 e8 a2 24 00 01 00 00 00 00 9f 24 00  ......$.......$.
        02 00 00 00 00 6a 18 00 03 00 00 00 00 35 0c 00  .....j.......5..
      backtrace:
        [<c123ba97>] kmemleak_alloc+0x27/0x50
        [<c109f96f>] __kmalloc+0xcf/0x110
        [<f9da97ee>] acpi_cpufreq_cpu_init+0x1ee/0x4e4 [acpi_cpufreq]
        [<c11cd8d2>] cpufreq_add_dev+0x142/0x3a0
        [<c11920b7>] sysdev_driver_register+0x97/0x110
        [<c11cce56>] cpufreq_register_driver+0x86/0x140
        [<f9dad080>] 0xf9dad080
        [<c1001130>] do_one_initcall+0x30/0x160
        [<c10626e9>] sys_init_module+0x99/0x1e0
        [<c1002d97>] sysenter_do_call+0x12/0x26
        [<ffffffff>] 0xffffffff
    
    https://bugzilla.kernel.org/show_bug.cgi?id=15807#c21
    
    Tested-by: Toralf Forster <toralf.foerster@gmx.de>
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit dab5fff14df2cd16eb1ad4c02e83915e1063fece
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Tue Oct 12 09:09:37 2010 +0800

    acpi-cpufreq: fix a memleak when unloading driver
    
    We didn't free per_cpu(acfreq_data, cpu)->freq_table
    when acpi_freq driver is unloaded.
    
    Resulting in the following messages in /sys/kernel/debug/kmemleak:
    
    unreferenced object 0xf6450e80 (size 64):
      comm "modprobe", pid 1066, jiffies 4294677317 (age 19290.453s)
      hex dump (first 32 bytes):
        00 00 00 00 e8 a2 24 00 01 00 00 00 00 9f 24 00  ......$.......$.
        02 00 00 00 00 6a 18 00 03 00 00 00 00 35 0c 00  .....j.......5..
      backtrace:
        [<c123ba97>] kmemleak_alloc+0x27/0x50
        [<c109f96f>] __kmalloc+0xcf/0x110
        [<f9da97ee>] acpi_cpufreq_cpu_init+0x1ee/0x4e4 [acpi_cpufreq]
        [<c11cd8d2>] cpufreq_add_dev+0x142/0x3a0
        [<c11920b7>] sysdev_driver_register+0x97/0x110
        [<c11cce56>] cpufreq_register_driver+0x86/0x140
        [<f9dad080>] 0xf9dad080
        [<c1001130>] do_one_initcall+0x30/0x160
        [<c10626e9>] sys_init_module+0x99/0x1e0
        [<c1002d97>] sysenter_do_call+0x12/0x26
        [<ffffffff>] 0xffffffff
    
    https://bugzilla.kernel.org/show_bug.cgi?id=15807#c21
    
    Tested-by: Toralf Forster <toralf.foerster@gmx.de>
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

commit cad70a6ae5aaef4641a3efdfd536c30f13891afe
Author: Xiaotian Feng <dfeng@redhat.com>
Date:   Tue Jul 20 20:11:02 2010 +0800

    [CPUFREQ] fix memory leak in cpufreq_add_dev
    
    We didn't free policy->related_cpus in error path err_unlock_policy.
    This is catched by following kmemleak report:
    
    unreferenced object 0xffff88022a0b96d0 (size 512):
      comm "modprobe", pid 886, jiffies 4294689177 (age 780.694s)
      hex dump (first 32 bytes):
        00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
        00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
      backtrace:
        [<ffffffff8111ebe5>] create_object+0x186/0x281
        [<ffffffff814fad4f>] kmemleak_alloc+0x60/0xa7
        [<ffffffff8111127a>] kmem_cache_alloc_node_notrace+0x120/0x142
        [<ffffffff81262e4f>] alloc_cpumask_var_node+0x2c/0xd7
        [<ffffffff81262f0b>] alloc_cpumask_var+0x11/0x13
        [<ffffffff81262f1c>] zalloc_cpumask_var+0xf/0x11
        [<ffffffff8140fac0>] cpufreq_add_dev+0x11f/0x547
        [<ffffffff81334bda>] sysdev_driver_register+0xc2/0x11d
        [<ffffffff8140e334>] cpufreq_register_driver+0xcb/0x1b8
        [<ffffffffa032e040>] 0xffffffffa032e040
        [<ffffffff810021ba>] do_one_initcall+0x5e/0x15c
        [<ffffffff81087f94>] sys_init_module+0xa6/0x1e6
        [<ffffffff81009bc2>] system_call_fastpath+0x16/0x1b
        [<ffffffffffffffff>] 0xffffffffffffffff
    
    Signed-off-by: Xiaotian Feng <dfeng@redhat.com>
    Cc: Thomas Renninger <trenn@suse.de>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Signed-off-by: Dave Jones <davej@redhat.com>

commit 6f90388ac98e8cb2c63e307ffb13871a6b87f29b
Author: Xiaotian Feng <dfeng@redhat.com>
Date:   Tue Jul 20 20:11:02 2010 +0800

    [CPUFREQ] fix memory leak in cpufreq_add_dev
    
    We didn't free policy->related_cpus in error path err_unlock_policy.
    This is catched by following kmemleak report:
    
    unreferenced object 0xffff88022a0b96d0 (size 512):
      comm "modprobe", pid 886, jiffies 4294689177 (age 780.694s)
      hex dump (first 32 bytes):
        00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
        00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
      backtrace:
        [<ffffffff8111ebe5>] create_object+0x186/0x281
        [<ffffffff814fad4f>] kmemleak_alloc+0x60/0xa7
        [<ffffffff8111127a>] kmem_cache_alloc_node_notrace+0x120/0x142
        [<ffffffff81262e4f>] alloc_cpumask_var_node+0x2c/0xd7
        [<ffffffff81262f0b>] alloc_cpumask_var+0x11/0x13
        [<ffffffff81262f1c>] zalloc_cpumask_var+0xf/0x11
        [<ffffffff8140fac0>] cpufreq_add_dev+0x11f/0x547
        [<ffffffff81334bda>] sysdev_driver_register+0xc2/0x11d
        [<ffffffff8140e334>] cpufreq_register_driver+0xcb/0x1b8
        [<ffffffffa032e040>] 0xffffffffa032e040
        [<ffffffff810021ba>] do_one_initcall+0x5e/0x15c
        [<ffffffff81087f94>] sys_init_module+0xa6/0x1e6
        [<ffffffff81009bc2>] system_call_fastpath+0x16/0x1b
        [<ffffffffffffffff>] 0xffffffffffffffff
    
    Signed-off-by: Xiaotian Feng <dfeng@redhat.com>
    Cc: Thomas Renninger <trenn@suse.de>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Signed-off-by: Dave Jones <davej@redhat.com>

commit 8eed1192969633780822059ebf02d693f74977c1
Author: Andreas Herrmann <andreas.herrmann3@amd.com>
Date:   Fri Nov 21 14:49:25 2008 +0100

    CPUFREQ: powernow-k8: ignore out-of-range PstateStatus value
    
    commit a266d9f1253a38ec2d5655ebcd6846298b0554f4 upstream.
    
    A workaround for AMD CPU family 11h erratum 311 might cause that the
    P-state Status Register shows a "current P-state" which is larger than
    the "current P-state limit" in P-state Current Limit Register. For the
    wrong P-state value there is no ACPI _PSS object defined and
    powernow-k8/cpufreq can't determine the proper CPU frequency for that
    state.
    
    As a consequence this can cause a panic during boot (potentially with
    all recent kernel versions -- at least I have reproduced it with
    various 2.6.27 kernels and with the current .28 series), as an
    example:
    
    powernow-k8: Found 1 AMD Turion(tm)X2 Ultra DualCore Mobile ZM-82 processors (2 \
    )
    powernow-k8:    0 : pstate 0 (2200 MHz)
    powernow-k8:    1 : pstate 1 (1100 MHz)
    powernow-k8:    2 : pstate 2 (600 MHz)
    BUG: unable to handle kernel paging request at ffff88086e7528b8
    IP: [<ffffffff80486361>] cpufreq_stats_update+0x4a/0x5f
    PGD 202063 PUD 0
    Oops: 0002 [#1] SMP
    last sysfs file:
    CPU 1
    Modules linked in:
    Pid: 1, comm: swapper Not tainted 2.6.28-rc3-dirty #16
    RIP: 0010:[<ffffffff80486361>]  [<ffffffff80486361>] cpufreq_stats_update+0x4a/0\
    f
    Synaptics claims to have extended capabilities, but I'm not able to read them.<6\
    6
    RAX: 0000000000000000 RBX: 0000000000000001 RCX: ffff88006e7528c0
    RDX: 00000000ffffffff RSI: ffff88006e54af00 RDI: ffffffff808f056c
    RBP: 00000000fffee697 R08: 0000000000000003 R09: ffff88006e73f080
    R10: 0000000000000001 R11: 00000000002191c0 R12: ffff88006fb83c10
    R13: 00000000ffffffff R14: 0000000000000001 R15: 0000000000000000
    FS:  0000000000000000(0000) GS:ffff88006fb50740(0000) knlGS:0000000000000000
    Unable to initialize Synaptics hardware.
    CS:  0010 DS: 0018 ES: 0018 CR0: 000000008005003b
    CR2: ffff88086e7528b8 CR3: 0000000000201000 CR4: 00000000000006e0
    DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
    DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400
    Process swapper (pid: 1, threadinfo ffff88006fb82000, task ffff88006fb816d0)
    Stack:
     ffff88006e74da50 0000000000000000 ffff88006e54af00 ffffffff804863c7
     ffff88006e74da50 0000000000000000 00000000ffffffff 0000000000000000
     ffff88006fb83c10 ffffffff8024b46c ffffffff808f0560 ffff88006fb83c10
    Call Trace:
     [<ffffffff804863c7>] ? cpufreq_stat_notifier_trans+0x51/0x83
     [<ffffffff8024b46c>] ? notifier_call_chain+0x29/0x4c
     [<ffffffff8024b561>] ? __srcu_notifier_call_chain+0x46/0x61
     [<ffffffff8048496d>] ? cpufreq_notify_transition+0x93/0xa9
     [<ffffffff8021ab8d>] ? powernowk8_target+0x1e8/0x5f3
     [<ffffffff80486687>] ? cpufreq_governor_performance+0x1b/0x20
     [<ffffffff80484886>] ? __cpufreq_governor+0x71/0xa8
     [<ffffffff80484b21>] ? __cpufreq_set_policy+0x101/0x13e
     [<ffffffff80485bcd>] ? cpufreq_add_dev+0x3f0/0x4cd
     [<ffffffff8048577a>] ? handle_update+0x0/0x8
     [<ffffffff803c2062>] ? sysdev_driver_register+0xb6/0x10d
     [<ffffffff8056592c>] ? powernowk8_init+0x0/0x7e
     [<ffffffff8048604c>] ? cpufreq_register_driver+0x8f/0x140
     [<ffffffff80209056>] ? _stext+0x56/0x14f
     [<ffffffff802c2234>] ? proc_register+0x122/0x17d
     [<ffffffff802c23a0>] ? create_proc_entry+0x73/0x8a
     [<ffffffff8025c259>] ? register_irq_proc+0x92/0xaa
     [<ffffffff8025c2c8>] ? init_irq_proc+0x57/0x69
     [<ffffffff807fc85f>] ? kernel_init+0x116/0x169
     [<ffffffff8020cc79>] ? child_rip+0xa/0x11
     [<ffffffff807fc749>] ? kernel_init+0x0/0x169
     [<ffffffff8020cc6f>] ? child_rip+0x0/0x11
    Code: 05 c5 83 36 00 48 c7 c2 48 5d 86 80 48 8b 04 d8 48 8b 40 08 48 8b 34 02 48\
    
    RIP  [<ffffffff80486361>] cpufreq_stats_update+0x4a/0x5f
     RSP <ffff88006fb83b20>
    CR2: ffff88086e7528b8
    ---[ end trace 0678bac75e67a2f7 ]---
    Kernel panic - not syncing: Attempted to kill init!
    
    In short, aftereffect of the wrong P-state is that
    cpufreq_stats_update() uses "-1" as index for some array in
    
    cpufreq_stats_update (unsigned int cpu)
    {
    ...
         if (stat->time_in_state)
                    stat->time_in_state[stat->last_index] =
                            cputime64_add(stat->time_in_state[stat->last_index],
                                          cputime_sub(cur_time, stat->last_time));
    ...
    }
    
    Fortunately, the wrong P-state value is returned only if the core is
    in P-state 0. This fix solves the problem by detecting the
    out-of-range P-state, ignoring it, and using "0" instead.
    
    Cc: Mark Langsdorf <mark.langsdorf@amd.com>
    Signed-off-by: Andreas Herrmann <andreas.herrmann3@amd.com>
    Signed-off-by: Dave Jones <davej@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit a266d9f1253a38ec2d5655ebcd6846298b0554f4
Author: Andreas Herrmann <andreas.herrmann3@amd.com>
Date:   Fri Nov 21 14:49:25 2008 +0100

    [CPUFREQ] powernow-k8: ignore out-of-range PstateStatus value
    
    A workaround for AMD CPU family 11h erratum 311 might cause that the
    P-state Status Register shows a "current P-state" which is larger than
    the "current P-state limit" in P-state Current Limit Register. For the
    wrong P-state value there is no ACPI _PSS object defined and
    powernow-k8/cpufreq can't determine the proper CPU frequency for that
    state.
    
    As a consequence this can cause a panic during boot (potentially with
    all recent kernel versions -- at least I have reproduced it with
    various 2.6.27 kernels and with the current .28 series), as an
    example:
    
    powernow-k8: Found 1 AMD Turion(tm)X2 Ultra DualCore Mobile ZM-82 processors (2 \
    )
    powernow-k8:    0 : pstate 0 (2200 MHz)
    powernow-k8:    1 : pstate 1 (1100 MHz)
    powernow-k8:    2 : pstate 2 (600 MHz)
    BUG: unable to handle kernel paging request at ffff88086e7528b8
    IP: [<ffffffff80486361>] cpufreq_stats_update+0x4a/0x5f
    PGD 202063 PUD 0
    Oops: 0002 [#1] SMP
    last sysfs file:
    CPU 1
    Modules linked in:
    Pid: 1, comm: swapper Not tainted 2.6.28-rc3-dirty #16
    RIP: 0010:[<ffffffff80486361>]  [<ffffffff80486361>] cpufreq_stats_update+0x4a/0\
    f
    Synaptics claims to have extended capabilities, but I'm not able to read them.<6\
    6
    RAX: 0000000000000000 RBX: 0000000000000001 RCX: ffff88006e7528c0
    RDX: 00000000ffffffff RSI: ffff88006e54af00 RDI: ffffffff808f056c
    RBP: 00000000fffee697 R08: 0000000000000003 R09: ffff88006e73f080
    R10: 0000000000000001 R11: 00000000002191c0 R12: ffff88006fb83c10
    R13: 00000000ffffffff R14: 0000000000000001 R15: 0000000000000000
    FS:  0000000000000000(0000) GS:ffff88006fb50740(0000) knlGS:0000000000000000
    Unable to initialize Synaptics hardware.
    CS:  0010 DS: 0018 ES: 0018 CR0: 000000008005003b
    CR2: ffff88086e7528b8 CR3: 0000000000201000 CR4: 00000000000006e0
    DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
    DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400
    Process swapper (pid: 1, threadinfo ffff88006fb82000, task ffff88006fb816d0)
    Stack:
     ffff88006e74da50 0000000000000000 ffff88006e54af00 ffffffff804863c7
     ffff88006e74da50 0000000000000000 00000000ffffffff 0000000000000000
     ffff88006fb83c10 ffffffff8024b46c ffffffff808f0560 ffff88006fb83c10
    Call Trace:
     [<ffffffff804863c7>] ? cpufreq_stat_notifier_trans+0x51/0x83
     [<ffffffff8024b46c>] ? notifier_call_chain+0x29/0x4c
     [<ffffffff8024b561>] ? __srcu_notifier_call_chain+0x46/0x61
     [<ffffffff8048496d>] ? cpufreq_notify_transition+0x93/0xa9
     [<ffffffff8021ab8d>] ? powernowk8_target+0x1e8/0x5f3
     [<ffffffff80486687>] ? cpufreq_governor_performance+0x1b/0x20
     [<ffffffff80484886>] ? __cpufreq_governor+0x71/0xa8
     [<ffffffff80484b21>] ? __cpufreq_set_policy+0x101/0x13e
     [<ffffffff80485bcd>] ? cpufreq_add_dev+0x3f0/0x4cd
     [<ffffffff8048577a>] ? handle_update+0x0/0x8
     [<ffffffff803c2062>] ? sysdev_driver_register+0xb6/0x10d
     [<ffffffff8056592c>] ? powernowk8_init+0x0/0x7e
     [<ffffffff8048604c>] ? cpufreq_register_driver+0x8f/0x140
     [<ffffffff80209056>] ? _stext+0x56/0x14f
     [<ffffffff802c2234>] ? proc_register+0x122/0x17d
     [<ffffffff802c23a0>] ? create_proc_entry+0x73/0x8a
     [<ffffffff8025c259>] ? register_irq_proc+0x92/0xaa
     [<ffffffff8025c2c8>] ? init_irq_proc+0x57/0x69
     [<ffffffff807fc85f>] ? kernel_init+0x116/0x169
     [<ffffffff8020cc79>] ? child_rip+0xa/0x11
     [<ffffffff807fc749>] ? kernel_init+0x0/0x169
     [<ffffffff8020cc6f>] ? child_rip+0x0/0x11
    Code: 05 c5 83 36 00 48 c7 c2 48 5d 86 80 48 8b 04 d8 48 8b 40 08 48 8b 34 02 48\
    
    RIP  [<ffffffff80486361>] cpufreq_stats_update+0x4a/0x5f
     RSP <ffff88006fb83b20>
    CR2: ffff88086e7528b8
    ---[ end trace 0678bac75e67a2f7 ]---
    Kernel panic - not syncing: Attempted to kill init!
    
    In short, aftereffect of the wrong P-state is that
    cpufreq_stats_update() uses "-1" as index for some array in
    
    cpufreq_stats_update (unsigned int cpu)
    {
    ...
         if (stat->time_in_state)
                    stat->time_in_state[stat->last_index] =
                            cputime64_add(stat->time_in_state[stat->last_index],
                                          cputime_sub(cur_time, stat->last_time));
    ...
    }
    
    Fortunately, the wrong P-state value is returned only if the core is
    in P-state 0. This fix solves the problem by detecting the
    out-of-range P-state, ignoring it, and using "0" instead.
    
    Cc: Mark Langsdorf <mark.langsdorf@amd.com>
    Signed-off-by: Andreas Herrmann <andreas.herrmann3@amd.com>
    Signed-off-by: Dave Jones <davej@redhat.com>

commit 098ef215b1e87cff51f983bae4e4e1358b932ec9
Merge: b922df738374 4f6e6b9f97b0
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Oct 11 08:49:34 2008 -0700

    Merge branch 'next' of git://git.kernel.org/pub/scm/linux/kernel/git/davej/cpufreq
    
    * 'next' of git://git.kernel.org/pub/scm/linux/kernel/git/davej/cpufreq:
      [CPUFREQ] Fix BUG: using smp_processor_id() in preemptible code
      [CPUFREQ] Don't export governors for default governor
      [CPUFREQ][6/6] cpufreq: Add idle microaccounting in ondemand governor
      [CPUFREQ][5/6] cpufreq: Changes to get_cpu_idle_time_us(), used by ondemand governor
      [CPUFREQ][4/6] cpufreq_ondemand: Parameterize down differential
      [CPUFREQ][3/6] cpufreq: get_cpu_idle_time() changes in ondemand for idle-microaccounting
      [CPUFREQ][2/6] cpufreq: Change load calculation in ondemand for software coordination
      [CPUFREQ][1/6] cpufreq: Add cpu number parameter to __cpufreq_driver_getavg()
      [CPUFREQ] use deferrable delayed work init in conservative governor
      [CPUFREQ] drivers/cpufreq/cpufreq.c: Adjust error handling code involving cpufreq_cpu_put
      [CPUFREQ] add error handling for cpufreq_register_governor() error
      [CPUFREQ] acpi-cpufreq: add error handling for cpufreq_register_driver() error
      [CPUFREQ] Coding style fixes to arch/x86/kernel/cpu/cpufreq/powernow-k6.c
      [CPUFREQ] Coding style fixes to arch/x86/kernel/cpu/cpufreq/elanfreq.c

commit 847aef6ffd85787b62395b64719f8f7c5975bf1b
Author: Akinobu Mita <akinobu.mita@gmail.com>
Date:   Mon Jul 14 11:59:44 2008 +0900

    [CPUFREQ] acpi-cpufreq: add error handling for cpufreq_register_driver() error
    
    add error handling for cpufreq_register_driver() error
    
    Signed-off-by: Akinobu Mita <akinobu.mita@gmail.com>
    Cc: cpufreq@lists.linux.org.uk
    Signed-off-by: Dave Jones <davej@redhat.com>

commit dca026139317dcbc642a30320d551f559692182f
Author: Lothar Wamann <LW@KARO-electronics.de>
Date:   Thu May 29 17:54:52 2008 +0200

    [CPUFREQ] fix double unlock of cpu_policy_rwsem in drivers/cpufreq/cpufreq.c
    
    In drivers/cpufreq/cpufreq.c the function cpufreq_add_dev() takes the
    error exit 'err_out_unregister' from different places once with the
    'cpu_policy_rwsem' lock held, once with the lock released:
    |               if (ret)
    |                       goto err_out_unregister;
    |       }
    |
    |       policy->governor = NULL; /* to assure that the starting sequence is
    |                                 * run in cpufreq_set_policy */
    |
    |       /* set default policy */
    |       ret = __cpufreq_set_policy(policy, &new_policy);
    |       policy->user_policy.policy = policy->policy;
    |       policy->user_policy.governor = policy->governor;
    |
    |       unlock_policy_rwsem_write(cpu);
    |
    |       if (ret) {
    |               dprintk("setting policy failed\n");
    |               goto err_out_unregister;
    |       }
    
    This leads to the following error message in case of a failing
    __cpufreq_set_policy() call:
    =====================================
    [ BUG: bad unlock balance detected! ]
    -------------------------------------
    swapper/1 is trying to release lock (&per_cpu(cpu_policy_rwsem, cpu)) at:
    [<c01b4564>] unlock_policy_rwsem_write+0x30/0x40
    but there are no more locks to release!
    
    other info that might help us debug this:
    1 lock held by swapper/1:
     #0:  (sysdev_drivers_lock){--..}, at: [<c018fd18>] sysdev_driver_register+0x74/0x130
    
    stack backtrace:
    [<c002f588>] (dump_stack+0x0/0x14) from [<c00692fc>] (print_unlock_inbalance_bug+0xc8/0x104)
    [<c0069234>] (print_unlock_inbalance_bug+0x0/0x104) from [<c006b7ac>] (lock_release_non_nested+0xc4/0x19c)
     r6:00000028 r5:c3c1ab80 r4:c01b4564
    [<c006b6e8>] (lock_release_non_nested+0x0/0x19c) from [<c006b9e0>] (lock_release+0x15c/0x18c)
     r8:60000013 r7:00000001 r6:c01b4564 r5:c0541bb4 r4:c3c1ab80
    [<c006b884>] (lock_release+0x0/0x18c) from [<c0061ba0>] (up_write+0x24/0x30)
     r8:c0541b80 r7:00000000 r6:ffffffea r5:c3c34828 r4:c0541b8c
    [<c0061b7c>] (up_write+0x0/0x30) from [<c01b4564>] (unlock_policy_rwsem_write+0x30/0x40)
     r4:c3c34884
    [<c01b4534>] (unlock_policy_rwsem_write+0x0/0x40) from [<c01b4c40>] (cpufreq_add_dev+0x324/0x398)
    [<c01b491c>] (cpufreq_add_dev+0x0/0x398) from [<c018fd64>] (sysdev_driver_register+0xc0/0x130)
    [<c018fca4>] (sysdev_driver_register+0x0/0x130) from [<c01b3574>] (cpufreq_register_driver+0xbc/0x174)
    
    Signed-off-by: Lothar Wamann <LW@KARO-electronics.de>
    Signed-off-by: Dave Jones <davej@redhat.com>

commit f7b16c108fd044adc422ff21b5d6c16022462fd0
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Tue Apr 29 00:58:51 2008 -0700

    cpu: fix section mismatch warning in reference to register_cpu_notifier
    
    Fix following warnings:
    WARNING: vmlinux.o(.text+0xc60): Section mismatch in reference from the function kvm_init() to the function .cpuinit.text:register_cpu_notifier()
    WARNING: vmlinux.o(.text+0x33869a): Section mismatch in reference from the function xfs_icsb_init_counters() to the function .cpuinit.text:register_cpu_notifier()
    WARNING: vmlinux.o(.text+0x5556a1): Section mismatch in reference from the function acpi_processor_install_hotplug_notify() to the function .cpuinit.text:register_cpu_notifier()
    WARNING: vmlinux.o(.text+0xfe6b28): Section mismatch in reference from the function cpufreq_register_driver() to the function .cpuinit.text:register_cpu_notifier()
    
    register_cpu_notifier() are only really defined when HOTPLUG_CPU is enabled.
    So references to the function are OK.
    
    Annotate it with __ref so we do not get warnings from callers and do not get
    warnings for the functions/data used by register_cpu_notifier().
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Cc: Gautham R Shenoy <ego@in.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit f6ebef30e21638417f8f5443ba393d63a0c27e2b
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Sun Feb 17 13:22:52 2008 +0100

    [CPUFREQ] fix section mismatch warnings
    
    Fix the following warnings:
    WARNING: vmlinux.o(.text+0xfe6711): Section mismatch in reference from the function cpufreq_unregister_driver() to the variable .cpuinit.data:cpufreq_cpu_notifier
    WARNING: vmlinux.o(.text+0xfe68af): Section mismatch in reference from the function cpufreq_register_driver() to the variable .cpuinit.data:cpufreq_cpu_notifier
    WARNING: vmlinux.o(.exit.text+0xc4fa): Section mismatch in reference from the function cpufreq_stats_exit() to the variable .cpuinit.data:cpufreq_stat_cpu_notifier
    
    The warnings were casued by references to unregister_hotcpu_notifier()
    from normal functions or exit functions.
    This is flagged by modpost as a potential error because
    it does not know that for the non HOTPLUG_CPU
    scenario the unregister_hotcpu_notifier() is a nop.
    Silence the warning by replacing the __initdata
    annotation with a __refdata annotation.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Dave Jones <davej@codemonkey.org.uk>

commit a263898f628dd21e59210b547986c154788f628e
Author: Ingo Molnar <mingo@elte.hu>
Date:   Sun Dec 30 11:58:17 2007 +0100

    CPU hotplug: fix cpu_is_offline() on !CONFIG_HOTPLUG_CPU
    
    make randconfig bootup testing found that the cpufreq code
    crashes on bootup, if the powernow-k8 driver is enabled and
    if maxcpus=1 passed on the boot line to a !CONFIG_HOTPLUG_CPU
    kernel.
    
    First lockdep found out that there's an inconsistent unlock
    sequence:
    
     =====================================
     [ BUG: bad unlock balance detected! ]
     -------------------------------------
     swapper/1 is trying to release lock (&per_cpu(cpu_policy_rwsem, cpu)) at:
     [<ffffffff806ffd8e>] unlock_policy_rwsem_write+0x3c/0x42
     but there are no more locks to release!
    
    Call Trace:
     [<ffffffff806ffd8e>] unlock_policy_rwsem_write+0x3c/0x42
     [<ffffffff80251c29>] print_unlock_inbalance_bug+0x104/0x12c
     [<ffffffff80252f3a>] mark_held_locks+0x56/0x94
     [<ffffffff806ffd8e>] unlock_policy_rwsem_write+0x3c/0x42
     [<ffffffff807008b6>] cpufreq_add_dev+0x2a8/0x5c4
     ...
    
    then shortly afterwards the cpufreq code crashed on an assert:
    
     ------------[ cut here ]------------
     kernel BUG at drivers/cpufreq/cpufreq.c:1068!
     invalid opcode: 0000 [1] SMP
     [...]
     Call Trace:
      [<ffffffff805145d6>] sysdev_driver_unregister+0x5b/0x91
      [<ffffffff806ff520>] cpufreq_register_driver+0x15d/0x1a2
      [<ffffffff80cc0596>] powernowk8_init+0x86/0x94
     [...]
     ---[ end trace 1e9219be2b4431de ]---
    
    the bug was caused by maxcpus=1 bootup, which brought up the
    secondary core as !cpu_online() but !cpu_is_offline() either,
    which on on !CONFIG_HOTPLUG_CPU is always 0 (include/linux/cpu.h):
    
      /* CPUs don't go offline once they're online w/o CONFIG_HOTPLUG_CPU */
      static inline int cpu_is_offline(int cpu) { return 0; }
    
    but the cpufreq code uses cpu_online() and cpu_is_offline() in
    a mixed way - the low-level drivers use cpu_online(), while
    the cpufreq core uses cpu_is_offline(). This opened up the
    possibility to add the non-initialized sysdev device of the
    secondary core:
    
     cpufreq-core: trying to register driver powernow-k8
     cpufreq-core: adding CPU 0
     powernow-k8: BIOS error - no PSB or ACPI _PSS objects
     cpufreq-core: initialization failed
     cpufreq-core: adding CPU 1
     cpufreq-core: initialization failed
    
    which then blew up. The fix is to make cpu_is_offline() always
    the negation of cpu_online(). With that fix applied the kernel
    boots up fine without crashing:
    
     Calling initcall 0xffffffff80cc0510: powernowk8_init+0x0/0x94()
     powernow-k8: Found 1 AMD Athlon(tm) 64 X2 Dual Core Processor 3800+ processors (1 cpu cores) (version 2.20.00)
     powernow-k8: BIOS error - no PSB or ACPI _PSS objects
     initcall 0xffffffff80cc0510: powernowk8_init+0x0/0x94() returned -19.
     initcall 0xffffffff80cc0510 ran for 19 msecs: powernowk8_init+0x0/0x94()
     Calling initcall 0xffffffff80cc328f: init_lapic_nmi_sysfs+0x0/0x39()
    
    We could fix this by making CPU enumeration aware of max_cpus, but that
    would be more fragile IMO, and the cpu_online(cpu) != cpu_is_offline(cpu)
    possibility was quite confusing and a continuous source of bugs too.
    
    Most distributions have kernels with CPU hotplug enabled, so this bug
    remained hidden for a long time.
    
    Bug forensics:
    
    The broken cpu_is_offline() API variant was introduced via:
    
     commit a59d2e4e6977e7b94e003c96a41f07e96cddc340
     Author: Rusty Russell <rusty@rustcorp.com.au>
     Date:   Mon Mar 8 06:06:03 2004 -0800
    
         [PATCH] minor cleanups for hotplug CPUs
    
    ( this predates linux-2.6.git, this commit is available from Thomas's
      historic git tree. )
    
    Then 1.5 years later the cpufreq code made use of it:
    
     commit c32b6b8e524d2c337767d312814484d9289550cf
     Author: Ashok Raj <ashok.raj@intel.com>
     Date:   Sun Oct 30 14:59:54 2005 -0800
    
         [PATCH] create and destroy cpufreq sysfs entries based on cpu notifiers
    
     +       if (cpu_is_offline(cpu))
     +               return 0;
    
    which is a correct use of the subtly broken new API. v2.6.15 then
    shipped with this bug included.
    
    then it took two more years for random-kernel qa to hit it.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit 221dee285ee38099b82437531bcae9fa9cb64cc4
Author: Linus Torvalds <torvalds@woody.linux-foundation.org>
Date:   Mon Feb 26 14:55:48 2007 -0800

    Revert "[CPUFREQ] constify cpufreq_driver where possible."
    
    This reverts commit aeeddc1435c37fa3fc844f31d39c185b08de4158, which was
    half-baked and broken.  It just resulted in compile errors, since
    cpufreq_register_driver() still changes the 'driver_data' by setting
    bits in the flags field.  So claiming it is 'const' _really_ doesn't
    work.
    
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit 808c407e1a534865ca5e151b3a5bae58b73408a9
Author: Ingo Molnar <mingo@elte.hu>
Date:   Tue Jan 23 17:16:26 2007 +0100

    [PATCH] ACPI: fix cpufreq regression
    
    recently cpufreq support on my laptop (Lenovo T60) broke completely:
    when it's plugged into AC it would never go higher than 1 GHz - neither
    1.3 GHz nor 1.83 GHz is possible - no matter which governor (userspace,
    speed or ondemand) is used.
    
    after some cpufreq debugging i tracked the regression back to the
    following (totally correct) bug-fix commit:
    
       commit 0916bd3ebb7cefdd0f432e8491abe24f4b5a101e
       Author: Dave Jones <davej@redhat.com>
       Date:   Wed Nov 22 20:42:01 2006 -0500
    
        [PATCH] Correct bound checking from the value returned from _PPC method.
    
    this bugfix, which makes other laptops work, made a previously hidden
    (BIOS) bug visible on my laptop.
    
    The bug is the following: if the _PPC (Performance Present Capabilities)
    optional ACPI object is queried /after/ bootup then the BIOS reports an
    incorrect value of '2'.
    
    My laptop (Lenovo T60) has the following performance states supported:
    
       0: 1833000
       1: 1333000
       2: 1000000
    
    Per ACPI specification, a _PPC value of '0' means that all 3 performance
    states are usable. A _PPC value of '1' means states 1 .. 2 are usable, a
    value of '2' means only state '2' (slowest) is usable.
    
    now, the _PPC object is optional, and it also comes with notification.
    Furthermore, when a CPU object is initialized, the _PPC object is
    initialized as well. So the following evaluation of the _PPC object is
    superfluous:
    
     [<c028ba5f>] acpi_processor_get_platform_limit+0xa1/0xaf
     [<c028c040>] acpi_processor_register_performance+0x3b9/0x3ef
     [<c0111a85>] acpi_cpufreq_cpu_init+0xb7/0x596
     [<c03dab74>] cpufreq_add_dev+0x160/0x4a8
     [<c02bed90>] sysdev_driver_register+0x5a/0xa0
     [<c03d9c4c>] cpufreq_register_driver+0xb4/0x176
     [<c068ac08>] acpi_cpufreq_init+0xe5/0xeb
     [<c010056e>] init+0x14f/0x3dd
    
    and this is the point where my laptop's BIOS returns the incorrect value
    of '2'. Note that it has not sent any notification event, so the value
    is probably not really intentional (possibly spurious), and Windows
    likely doesnt query it after bootup either. Maybe the value is kept at
    '2' normally, and is only set to the real value when a true asynchronous
    event (such as AC plug event, battery switch, etc.) occurs.
    
    So i /think/ this is a grey area of the ACPI spec: per the letter of the
    spec the _PPC value only changes when notified, so there's no reason to
    query it after the system has booted up. So in my opinion the best (and
    most compatible) strategy would be to do the change below, and to not
    evaluate the _PPC object in the acpi_processor_get_performance_info()
    call, but only evaluate it if _PPC is present during CPU object init, or
    if it's notified during an asynchronous event. This change is more
    permissive than the previous logic, so it definitely shouldnt break any
    existing system.
    
    This also happens to fix my laptop, which is merrily chugging along at
    1.83 GHz now. Yay!
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Cc: Dave Jones <davej@redhat.com>
    Acked-by: Len Brown <len.brown@intel.com>
    Signed-off-by: Chris Wright <chrisw@sous-sol.org>

commit e4233dec749a3519069d9390561b5636a75c7579
Author: Ingo Molnar <mingo@elte.hu>
Date:   Fri Jan 26 00:56:55 2007 -0800

    [PATCH] ACPI: fix cpufreq regression
    
    Recently cpufreq support on my laptop (Lenovo T60) broke completely: when
    it's plugged into AC it would never go higher than 1 GHz - neither 1.3 GHz
    nor 1.83 GHz is possible - no matter which governor (userspace, speed or
    ondemand) is used.
    
    After some cpufreq debugging i tracked the regression back to the following
    (totally correct) bug-fix commit:
    
       commit 0916bd3ebb7cefdd0f432e8491abe24f4b5a101e
       Author: Dave Jones <davej@redhat.com>
       Date:   Wed Nov 22 20:42:01 2006 -0500
    
        [PATCH] Correct bound checking from the value returned from _PPC method.
    
    This bugfix, which makes other laptops work, made a previously hidden
    (BIOS) bug visible on my laptop.
    
    The bug is the following: if the _PPC (Performance Present Capabilities)
    optional ACPI object is queried /after/ bootup then the BIOS reports an
    incorrect value of '2'.
    
    My laptop (Lenovo T60) has the following performance states supported:
    
       0: 1833000
       1: 1333000
       2: 1000000
    
    Per ACPI specification, a _PPC value of '0' means that all 3 performance
    states are usable.  A _PPC value of '1' means states 1 ..  2 are usable, a
    value of '2' means only state '2' (slowest) is usable.
    
    now, the _PPC object is optional, and it also comes with notification.
    Furthermore, when a CPU object is initialized, the _PPC object is
    initialized as well.  So the following evaluation of the _PPC object is
    superfluous:
    
     [<c028ba5f>] acpi_processor_get_platform_limit+0xa1/0xaf
     [<c028c040>] acpi_processor_register_performance+0x3b9/0x3ef
     [<c0111a85>] acpi_cpufreq_cpu_init+0xb7/0x596
     [<c03dab74>] cpufreq_add_dev+0x160/0x4a8
     [<c02bed90>] sysdev_driver_register+0x5a/0xa0
     [<c03d9c4c>] cpufreq_register_driver+0xb4/0x176
     [<c068ac08>] acpi_cpufreq_init+0xe5/0xeb
     [<c010056e>] init+0x14f/0x3dd
    
    And this is the point where my laptop's BIOS returns the incorrect value of
    '2'.  Note that it has not sent any notification event, so the value is
    probably not really intentional (possibly spurious), and Windows likely
    doesnt query it after bootup either.  Maybe the value is kept at '2'
    normally, and is only set to the real value when a true asynchronous event
    (such as AC plug event, battery switch, etc.) occurs.
    
    So i /think/ this is a grey area of the ACPI spec: per the letter of the
    spec the _PPC value only changes when notified, so there's no reason to
    query it after the system has booted up.  So in my opinion the best (and
    most compatible) strategy would be to do the change below, and to not
    evaluate the _PPC object in the acpi_processor_get_performance_info() call,
    but only evaluate it if _PPC is present during CPU object init, or if it's
    notified during an asynchronous event.  This change is more permissive than
    the previous logic, so it definitely shouldnt break any existing system.
    
    This also happens to fix my laptop, which is merrily chugging along at
    1.83 GHz now. Yay!
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Cc: Dave Jones <davej@redhat.com>
    Acked-by: Len Brown <lenb@kernel.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit 9a7d82a89a8bf55b112f2a5c3b3f405eb95a4303
Author: Mattia Dongili <malattia@linux.it>
Date:   Wed Nov 30 22:00:59 2005 +0100

    [CPUFREQ] Move PMBASE reading away and do it only once at initialization time
    
    This patch moves away PMBASE reading and only performs it at
    cpufreq_register_driver time by exiting with -ENODEV if unable to read
    the value.
    
    Signed-off-by: Mattia Dongili <malattia@linux.it>
    Acked-by: Dominik Brodowski <linux@dominikbrodowski.net>
    Signed-off-by: Dave Jones <davej@redhat.com>
