commit 11ad95912b8bd8c5c791a6c382435116f88f2682
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Dec 2 15:30:28 2022 +0100

    PM: runtime: Do not call __rpm_callback() from rpm_idle()
    
    [ Upstream commit bc80c2e438dcbfcf748452ec0f7ad5b79ff3ad88 ]
    
    Calling __rpm_callback() from rpm_idle() after adding device links
    support to the former is a clear mistake.
    
    Not only it causes rpm_idle() to carry out unnecessary actions, but it
    is also against the assumption regarding the stability of PM-runtime
    status across __rpm_callback() invocations, because rpm_suspend() and
    rpm_resume() may run in parallel with __rpm_callback() when it is called
    by rpm_idle() and the device's PM-runtime status can be updated by any
    of them.
    
    Fixes: 21d5c57b3726 ("PM / runtime: Use device links")
    Link: https://lore.kernel.org/linux-pm/36aed941-a73e-d937-2721-4f0decd61ce0@quicinc.com
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Adrian Hunter <adrian.hunter@intel.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 25890713f0f1ea7e944d362ec65caf87406d969c
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Dec 2 15:30:28 2022 +0100

    PM: runtime: Do not call __rpm_callback() from rpm_idle()
    
    [ Upstream commit bc80c2e438dcbfcf748452ec0f7ad5b79ff3ad88 ]
    
    Calling __rpm_callback() from rpm_idle() after adding device links
    support to the former is a clear mistake.
    
    Not only it causes rpm_idle() to carry out unnecessary actions, but it
    is also against the assumption regarding the stability of PM-runtime
    status across __rpm_callback() invocations, because rpm_suspend() and
    rpm_resume() may run in parallel with __rpm_callback() when it is called
    by rpm_idle() and the device's PM-runtime status can be updated by any
    of them.
    
    Fixes: 21d5c57b3726 ("PM / runtime: Use device links")
    Link: https://lore.kernel.org/linux-pm/36aed941-a73e-d937-2721-4f0decd61ce0@quicinc.com
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Adrian Hunter <adrian.hunter@intel.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit f983afc4326c91062abdab6d95312b98a9de0654
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Dec 2 15:30:28 2022 +0100

    PM: runtime: Do not call __rpm_callback() from rpm_idle()
    
    [ Upstream commit bc80c2e438dcbfcf748452ec0f7ad5b79ff3ad88 ]
    
    Calling __rpm_callback() from rpm_idle() after adding device links
    support to the former is a clear mistake.
    
    Not only it causes rpm_idle() to carry out unnecessary actions, but it
    is also against the assumption regarding the stability of PM-runtime
    status across __rpm_callback() invocations, because rpm_suspend() and
    rpm_resume() may run in parallel with __rpm_callback() when it is called
    by rpm_idle() and the device's PM-runtime status can be updated by any
    of them.
    
    Fixes: 21d5c57b3726 ("PM / runtime: Use device links")
    Link: https://lore.kernel.org/linux-pm/36aed941-a73e-d937-2721-4f0decd61ce0@quicinc.com
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Adrian Hunter <adrian.hunter@intel.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit ed2d0e160ce4a718034c114dcdfc2bc9b5158124
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Fri Jan 6 04:01:56 2023 +0100

    tpm: Allow system suspend to continue when TPM suspend fails
    
    commit 1382999aa0548a171a272ca817f6c38e797c458c upstream.
    
    TPM 1 is sometimes broken across system suspends, due to races or
    locking issues or something else that haven't been diagnosed or fixed
    yet, most likely having to do with concurrent reads from the TPM's
    hardware random number generator driver. These issues prevent the system
    from actually suspending, with errors like:
    
      tpm tpm0: A TPM error (28) occurred continue selftest
      ...
      tpm tpm0: A TPM error (28) occurred attempting get random
      ...
      tpm tpm0: Error (28) sending savestate before suspend
      tpm_tis 00:08: PM: __pnp_bus_suspend(): tpm_pm_suspend+0x0/0x80 returns 28
      tpm_tis 00:08: PM: dpm_run_callback(): pnp_bus_suspend+0x0/0x10 returns 28
      tpm_tis 00:08: PM: failed to suspend: error 28
      PM: Some devices failed to suspend, or early wake event detected
    
    This issue was partially fixed by 23393c646142 ("char: tpm: Protect
    tpm_pm_suspend with locks"), in a last minute 6.1 commit that Linus took
    directly because the TPM maintainers weren't available. However, it
    seems like this just addresses the most common cases of the bug, rather
    than addressing it entirely. So there are more things to fix still,
    apparently.
    
    In lieu of actually fixing the underlying bug, just allow system suspend
    to continue, so that laptops still go to sleep fine. Later, this can be
    reverted when the real bug is fixed.
    
    Link: https://lore.kernel.org/lkml/7cbe96cf-e0b5-ba63-d1b4-f63d2e826efa@suse.cz/
    Cc: stable@vger.kernel.org # 6.1+
    Reported-by: Vlastimil Babka <vbabka@suse.cz>
    Suggested-by: Linus Torvalds <torvalds@linux-foundation.org>
    Acked-by: Luigi Semenzato <semenzato@chromium.org>
    Cc: Peter Huewe <peterhuewe@gmx.de>
    Cc: Jarkko Sakkinen <jarkko@kernel.org>
    Cc: James Bottomley <James.Bottomley@HansenPartnership.com>
    Cc: Johannes Altmanninger <aclopte@gmail.com>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 1382999aa0548a171a272ca817f6c38e797c458c
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Fri Jan 6 04:01:56 2023 +0100

    tpm: Allow system suspend to continue when TPM suspend fails
    
    TPM 1 is sometimes broken across system suspends, due to races or
    locking issues or something else that haven't been diagnosed or fixed
    yet, most likely having to do with concurrent reads from the TPM's
    hardware random number generator driver. These issues prevent the system
    from actually suspending, with errors like:
    
      tpm tpm0: A TPM error (28) occurred continue selftest
      ...
      tpm tpm0: A TPM error (28) occurred attempting get random
      ...
      tpm tpm0: Error (28) sending savestate before suspend
      tpm_tis 00:08: PM: __pnp_bus_suspend(): tpm_pm_suspend+0x0/0x80 returns 28
      tpm_tis 00:08: PM: dpm_run_callback(): pnp_bus_suspend+0x0/0x10 returns 28
      tpm_tis 00:08: PM: failed to suspend: error 28
      PM: Some devices failed to suspend, or early wake event detected
    
    This issue was partially fixed by 23393c646142 ("char: tpm: Protect
    tpm_pm_suspend with locks"), in a last minute 6.1 commit that Linus took
    directly because the TPM maintainers weren't available. However, it
    seems like this just addresses the most common cases of the bug, rather
    than addressing it entirely. So there are more things to fix still,
    apparently.
    
    In lieu of actually fixing the underlying bug, just allow system suspend
    to continue, so that laptops still go to sleep fine. Later, this can be
    reverted when the real bug is fixed.
    
    Link: https://lore.kernel.org/lkml/7cbe96cf-e0b5-ba63-d1b4-f63d2e826efa@suse.cz/
    Cc: stable@vger.kernel.org # 6.1+
    Reported-by: Vlastimil Babka <vbabka@suse.cz>
    Suggested-by: Linus Torvalds <torvalds@linux-foundation.org>
    Acked-by: Luigi Semenzato <semenzato@chromium.org>
    Cc: Peter Huewe <peterhuewe@gmx.de>
    Cc: Jarkko Sakkinen <jarkko@kernel.org>
    Cc: James Bottomley <James.Bottomley@HansenPartnership.com>
    Cc: Johannes Altmanninger <aclopte@gmail.com>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit 6a5061dd651c40cbd904cf7be67937601f9c5341
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Dec 2 15:30:28 2022 +0100

    PM: runtime: Do not call __rpm_callback() from rpm_idle()
    
    [ Upstream commit bc80c2e438dcbfcf748452ec0f7ad5b79ff3ad88 ]
    
    Calling __rpm_callback() from rpm_idle() after adding device links
    support to the former is a clear mistake.
    
    Not only it causes rpm_idle() to carry out unnecessary actions, but it
    is also against the assumption regarding the stability of PM-runtime
    status across __rpm_callback() invocations, because rpm_suspend() and
    rpm_resume() may run in parallel with __rpm_callback() when it is called
    by rpm_idle() and the device's PM-runtime status can be updated by any
    of them.
    
    Fixes: 21d5c57b3726 ("PM / runtime: Use device links")
    Link: https://lore.kernel.org/linux-pm/36aed941-a73e-d937-2721-4f0decd61ce0@quicinc.com
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Adrian Hunter <adrian.hunter@intel.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit b277b15909ecb0dd3e4f41e598aa8a35bc385ad2
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Dec 2 15:30:28 2022 +0100

    PM: runtime: Do not call __rpm_callback() from rpm_idle()
    
    [ Upstream commit bc80c2e438dcbfcf748452ec0f7ad5b79ff3ad88 ]
    
    Calling __rpm_callback() from rpm_idle() after adding device links
    support to the former is a clear mistake.
    
    Not only it causes rpm_idle() to carry out unnecessary actions, but it
    is also against the assumption regarding the stability of PM-runtime
    status across __rpm_callback() invocations, because rpm_suspend() and
    rpm_resume() may run in parallel with __rpm_callback() when it is called
    by rpm_idle() and the device's PM-runtime status can be updated by any
    of them.
    
    Fixes: 21d5c57b3726 ("PM / runtime: Use device links")
    Link: https://lore.kernel.org/linux-pm/36aed941-a73e-d937-2721-4f0decd61ce0@quicinc.com
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Adrian Hunter <adrian.hunter@intel.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit b55ef8508ac482703dc90d111664748dda2608c7
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Dec 2 15:30:28 2022 +0100

    PM: runtime: Do not call __rpm_callback() from rpm_idle()
    
    [ Upstream commit bc80c2e438dcbfcf748452ec0f7ad5b79ff3ad88 ]
    
    Calling __rpm_callback() from rpm_idle() after adding device links
    support to the former is a clear mistake.
    
    Not only it causes rpm_idle() to carry out unnecessary actions, but it
    is also against the assumption regarding the stability of PM-runtime
    status across __rpm_callback() invocations, because rpm_suspend() and
    rpm_resume() may run in parallel with __rpm_callback() when it is called
    by rpm_idle() and the device's PM-runtime status can be updated by any
    of them.
    
    Fixes: 21d5c57b3726 ("PM / runtime: Use device links")
    Link: https://lore.kernel.org/linux-pm/36aed941-a73e-d937-2721-4f0decd61ce0@quicinc.com
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Adrian Hunter <adrian.hunter@intel.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 5e26531d8113da79dbc03b92d84ea47fa87683af
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Mar 5 12:21:40 2021 +0000

    rtc: cmos: Disable irq around direct invocation of cmos_interrupt()
    
    [ Upstream commit 13be2efc390acd2a46a69a359f6efc00ca434599 ]
    
    As previously noted in commit 66e4f4a9cc38 ("rtc: cmos: Use
    spin_lock_irqsave() in cmos_interrupt()"):
    
    <4>[  254.192378] WARNING: inconsistent lock state
    <4>[  254.192384] 5.12.0-rc1-CI-CI_DRM_9834+ #1 Not tainted
    <4>[  254.192396] --------------------------------
    <4>[  254.192400] inconsistent {IN-HARDIRQ-W} -> {HARDIRQ-ON-W} usage.
    <4>[  254.192409] rtcwake/5309 [HC0[0]:SC0[0]:HE1:SE1] takes:
    <4>[  254.192429] ffffffff8263c5f8 (rtc_lock){?...}-{2:2}, at: cmos_interrupt+0x18/0x100
    <4>[  254.192481] {IN-HARDIRQ-W} state was registered at:
    <4>[  254.192488]   lock_acquire+0xd1/0x3d0
    <4>[  254.192504]   _raw_spin_lock+0x2a/0x40
    <4>[  254.192519]   cmos_interrupt+0x18/0x100
    <4>[  254.192536]   rtc_handler+0x1f/0xc0
    <4>[  254.192553]   acpi_ev_fixed_event_detect+0x109/0x13c
    <4>[  254.192574]   acpi_ev_sci_xrupt_handler+0xb/0x28
    <4>[  254.192596]   acpi_irq+0x13/0x30
    <4>[  254.192620]   __handle_irq_event_percpu+0x43/0x2c0
    <4>[  254.192641]   handle_irq_event_percpu+0x2b/0x70
    <4>[  254.192661]   handle_irq_event+0x2f/0x50
    <4>[  254.192680]   handle_fasteoi_irq+0x9e/0x150
    <4>[  254.192693]   __common_interrupt+0x76/0x140
    <4>[  254.192715]   common_interrupt+0x96/0xc0
    <4>[  254.192732]   asm_common_interrupt+0x1e/0x40
    <4>[  254.192750]   _raw_spin_unlock_irqrestore+0x38/0x60
    <4>[  254.192767]   resume_irqs+0xba/0xf0
    <4>[  254.192786]   dpm_resume_noirq+0x245/0x3d0
    <4>[  254.192811]   suspend_devices_and_enter+0x230/0xaa0
    <4>[  254.192835]   pm_suspend.cold.8+0x301/0x34a
    <4>[  254.192859]   state_store+0x7b/0xe0
    <4>[  254.192879]   kernfs_fop_write_iter+0x11d/0x1c0
    <4>[  254.192899]   new_sync_write+0x11d/0x1b0
    <4>[  254.192916]   vfs_write+0x265/0x390
    <4>[  254.192933]   ksys_write+0x5a/0xd0
    <4>[  254.192949]   do_syscall_64+0x33/0x80
    <4>[  254.192965]   entry_SYSCALL_64_after_hwframe+0x44/0xae
    <4>[  254.192986] irq event stamp: 43775
    <4>[  254.192994] hardirqs last  enabled at (43775): [<ffffffff81c00c42>] asm_sysvec_apic_timer_interrupt+0x12/0x20
    <4>[  254.193023] hardirqs last disabled at (43774): [<ffffffff81aa691a>] sysvec_apic_timer_interrupt+0xa/0xb0
    <4>[  254.193049] softirqs last  enabled at (42548): [<ffffffff81e00342>] __do_softirq+0x342/0x48e
    <4>[  254.193074] softirqs last disabled at (42543): [<ffffffff810b45fd>] irq_exit_rcu+0xad/0xd0
    <4>[  254.193101]
                      other info that might help us debug this:
    <4>[  254.193107]  Possible unsafe locking scenario:
    
    <4>[  254.193112]        CPU0
    <4>[  254.193117]        ----
    <4>[  254.193121]   lock(rtc_lock);
    <4>[  254.193137]   <Interrupt>
    <4>[  254.193142]     lock(rtc_lock);
    <4>[  254.193156]
                       *** DEADLOCK ***
    
    <4>[  254.193161] 6 locks held by rtcwake/5309:
    <4>[  254.193174]  #0: ffff888104861430 (sb_writers#5){.+.+}-{0:0}, at: ksys_write+0x5a/0xd0
    <4>[  254.193232]  #1: ffff88810f823288 (&of->mutex){+.+.}-{3:3}, at: kernfs_fop_write_iter+0xe7/0x1c0
    <4>[  254.193282]  #2: ffff888100cef3c0 (kn->active#285
    <7>[  254.192706] i915 0000:00:02.0: [drm:intel_modeset_setup_hw_state [i915]] [CRTC:51:pipe A] hw state readout: disabled
    <4>[  254.193307] ){.+.+}-{0:0}, at: kernfs_fop_write_iter+0xf0/0x1c0
    <4>[  254.193333]  #3: ffffffff82649fa8 (system_transition_mutex){+.+.}-{3:3}, at: pm_suspend.cold.8+0xce/0x34a
    <4>[  254.193387]  #4: ffffffff827a2108 (acpi_scan_lock){+.+.}-{3:3}, at: acpi_suspend_begin+0x47/0x70
    <4>[  254.193433]  #5: ffff8881019ea178 (&dev->mutex){....}-{3:3}, at: device_resume+0x68/0x1e0
    <4>[  254.193485]
                      stack backtrace:
    <4>[  254.193492] CPU: 1 PID: 5309 Comm: rtcwake Not tainted 5.12.0-rc1-CI-CI_DRM_9834+ #1
    <4>[  254.193514] Hardware name: Google Soraka/Soraka, BIOS MrChromebox-4.10 08/25/2019
    <4>[  254.193524] Call Trace:
    <4>[  254.193536]  dump_stack+0x7f/0xad
    <4>[  254.193567]  mark_lock.part.47+0x8ca/0xce0
    <4>[  254.193604]  __lock_acquire+0x39b/0x2590
    <4>[  254.193626]  ? asm_sysvec_apic_timer_interrupt+0x12/0x20
    <4>[  254.193660]  lock_acquire+0xd1/0x3d0
    <4>[  254.193677]  ? cmos_interrupt+0x18/0x100
    <4>[  254.193716]  _raw_spin_lock+0x2a/0x40
    <4>[  254.193735]  ? cmos_interrupt+0x18/0x100
    <4>[  254.193758]  cmos_interrupt+0x18/0x100
    <4>[  254.193785]  cmos_resume+0x2ac/0x2d0
    <4>[  254.193813]  ? acpi_pm_set_device_wakeup+0x1f/0x110
    <4>[  254.193842]  ? pnp_bus_suspend+0x10/0x10
    <4>[  254.193864]  pnp_bus_resume+0x5e/0x90
    <4>[  254.193885]  dpm_run_callback+0x5f/0x240
    <4>[  254.193914]  device_resume+0xb2/0x1e0
    <4>[  254.193942]  ? pm_dev_err+0x25/0x25
    <4>[  254.193974]  dpm_resume+0xea/0x3f0
    <4>[  254.194005]  dpm_resume_end+0x8/0x10
    <4>[  254.194030]  suspend_devices_and_enter+0x29b/0xaa0
    <4>[  254.194066]  pm_suspend.cold.8+0x301/0x34a
    <4>[  254.194094]  state_store+0x7b/0xe0
    <4>[  254.194124]  kernfs_fop_write_iter+0x11d/0x1c0
    <4>[  254.194151]  new_sync_write+0x11d/0x1b0
    <4>[  254.194183]  vfs_write+0x265/0x390
    <4>[  254.194207]  ksys_write+0x5a/0xd0
    <4>[  254.194232]  do_syscall_64+0x33/0x80
    <4>[  254.194251]  entry_SYSCALL_64_after_hwframe+0x44/0xae
    <4>[  254.194274] RIP: 0033:0x7f07d79691e7
    <4>[  254.194293] Code: 64 89 02 48 c7 c0 ff ff ff ff eb bb 0f 1f 80 00 00 00 00 f3 0f 1e fa 64 8b 04 25 18 00 00 00 85 c0 75 10 b8 01 00 00 00 0f 05 <48> 3d 00 f0 ff ff 77 51 c3 48 83 ec 28 48 89 54 24 18 48 89 74 24
    <4>[  254.194312] RSP: 002b:00007ffd9cc2c768 EFLAGS: 00000246 ORIG_RAX: 0000000000000001
    <4>[  254.194337] RAX: ffffffffffffffda RBX: 0000000000000004 RCX: 00007f07d79691e7
    <4>[  254.194352] RDX: 0000000000000004 RSI: 0000556ebfc63590 RDI: 000000000000000b
    <4>[  254.194366] RBP: 0000556ebfc63590 R08: 0000000000000000 R09: 0000000000000004
    <4>[  254.194379] R10: 0000556ebf0ec2a6 R11: 0000000000000246 R12: 0000000000000004
    
    which breaks S3-resume on fi-kbl-soraka presumably as that's slow enough
    to trigger the alarm during the suspend.
    
    Fixes: 6950d046eb6e ("rtc: cmos: Replace spin_lock_irqsave with spin_lock in hard IRQ")
    References: 66e4f4a9cc38 ("rtc: cmos: Use spin_lock_irqsave() in cmos_interrupt()"):
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Xiaofei Tan <tanxiaofei@huawei.com>
    Cc: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Cc: Alessandro Zummo <a.zummo@towertech.it>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Link: https://lore.kernel.org/r/20210305122140.28774-1-chris@chris-wilson.co.uk
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 25b78bf98b07ff5aceb9b1e24f72ec0236c5c053
Author: Jan Dabros <jsd@semihalf.com>
Date:   Mon Nov 28 20:56:51 2022 +0100

    char: tpm: Protect tpm_pm_suspend with locks
    
    commit 23393c6461422df5bf8084a086ada9a7e17dc2ba upstream.
    
    Currently tpm transactions are executed unconditionally in
    tpm_pm_suspend() function, which may lead to races with other tpm
    accessors in the system.
    
    Specifically, the hw_random tpm driver makes use of tpm_get_random(),
    and this function is called in a loop from a kthread, which means it's
    not frozen alongside userspace, and so can race with the work done
    during system suspend:
    
      tpm tpm0: tpm_transmit: tpm_recv: error -52
      tpm tpm0: invalid TPM_STS.x 0xff, dumping stack for forensics
      CPU: 0 PID: 1 Comm: init Not tainted 6.1.0-rc5+ #135
      Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.0-20220807_005459-localhost 04/01/2014
      Call Trace:
       tpm_tis_status.cold+0x19/0x20
       tpm_transmit+0x13b/0x390
       tpm_transmit_cmd+0x20/0x80
       tpm1_pm_suspend+0xa6/0x110
       tpm_pm_suspend+0x53/0x80
       __pnp_bus_suspend+0x35/0xe0
       __device_suspend+0x10f/0x350
    
    Fix this by calling tpm_try_get_ops(), which itself is a wrapper around
    tpm_chip_start(), but takes the appropriate mutex.
    
    Signed-off-by: Jan Dabros <jsd@semihalf.com>
    Reported-by: Vlastimil Babka <vbabka@suse.cz>
    Tested-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Tested-by: Vlastimil Babka <vbabka@suse.cz>
    Link: https://lore.kernel.org/all/c5ba47ef-393f-1fba-30bd-1230d1b4b592@suse.cz/
    Cc: stable@vger.kernel.org
    Fixes: e891db1a18bf ("tpm: turn on TPM on suspend for TPM 1.x")
    [Jason: reworked commit message, added metadata]
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Reviewed-by: Jarkko Sakkinen <jarkko@kernel.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 56929ca9a99644f692b10f2b327624350ea5b7c5
Author: Stephen Boyd <swboyd@chromium.org>
Date:   Thu Nov 3 11:30:30 2022 -0700

    clk: qcom: gdsc: Remove direct runtime PM calls
    
    [ Upstream commit 4cc47e8add635408e063c98b52d56b7ceacf0b70 ]
    
    We shouldn't be calling runtime PM APIs from within the genpd
    enable/disable path for a couple reasons.
    
    First, this causes an AA lockdep splat[1] because genpd can call into
    genpd code again while holding the genpd lock.
    
    WARNING: possible recursive locking detected
    5.19.0-rc2-lockdep+ #7 Not tainted
    --------------------------------------------
    kworker/2:1/49 is trying to acquire lock:
    ffffffeea0370788 (&genpd->mlock){+.+.}-{3:3}, at: genpd_lock_mtx+0x24/0x30
    
    but task is already holding lock:
    ffffffeea03710a8 (&genpd->mlock){+.+.}-{3:3}, at: genpd_lock_mtx+0x24/0x30
    
    other info that might help us debug this:
     Possible unsafe locking scenario:
    
           CPU0
           ----
      lock(&genpd->mlock);
      lock(&genpd->mlock);
    
     *** DEADLOCK ***
    
     May be due to missing lock nesting notation
    
    3 locks held by kworker/2:1/49:
     #0: 74ffff80811a5748 ((wq_completion)pm){+.+.}-{0:0}, at: process_one_work+0x320/0x5fc
     #1: ffffffc008537cf8 ((work_completion)(&genpd->power_off_work)){+.+.}-{0:0}, at: process_one_work+0x354/0x5fc
     #2: ffffffeea03710a8 (&genpd->mlock){+.+.}-{3:3}, at: genpd_lock_mtx+0x24/0x30
    
    stack backtrace:
    CPU: 2 PID: 49 Comm: kworker/2:1 Not tainted 5.19.0-rc2-lockdep+ #7
    Hardware name: Google Lazor (rev3 - 8) with KB Backlight (DT)
    Workqueue: pm genpd_power_off_work_fn
    Call trace:
     dump_backtrace+0x1a0/0x200
     show_stack+0x24/0x30
     dump_stack_lvl+0x7c/0xa0
     dump_stack+0x18/0x44
     __lock_acquire+0xb38/0x3634
     lock_acquire+0x180/0x2d4
     __mutex_lock_common+0x118/0xe30
     mutex_lock_nested+0x70/0x7c
     genpd_lock_mtx+0x24/0x30
     genpd_runtime_suspend+0x2f0/0x414
     __rpm_callback+0xdc/0x1b8
     rpm_callback+0x4c/0xcc
     rpm_suspend+0x21c/0x5f0
     rpm_idle+0x17c/0x1e0
     __pm_runtime_idle+0x78/0xcc
     gdsc_disable+0x24c/0x26c
     _genpd_power_off+0xd4/0x1c4
     genpd_power_off+0x2d8/0x41c
     genpd_power_off_work_fn+0x60/0x94
     process_one_work+0x398/0x5fc
     worker_thread+0x42c/0x6c4
     kthread+0x194/0x1b4
     ret_from_fork+0x10/0x20
    
    Second, this confuses runtime PM on CoachZ for the camera devices by
    causing the camera clock controller's runtime PM usage_count to go
    negative after resuming from suspend. This is because runtime PM is
    being used on the clock controller while runtime PM is disabled for the
    device.
    
    The reason for the negative count is because a GDSC is represented as a
    genpd and each genpd that is attached to a device is resumed during the
    noirq phase of system wide suspend/resume (see the noirq suspend ops
    assignment in pm_genpd_init() for more details). The camera GDSCs are
    attached to camera devices with the 'power-domains' property in DT.
    Every device has runtime PM disabled in the late system suspend phase
    via __device_suspend_late(). Runtime PM is not usable until runtime PM
    is enabled in device_resume_early(). The noirq phases run after the
    'late' and before the 'early' phase of suspend/resume. When the genpds
    are resumed in genpd_resume_noirq(), we call down into gdsc_enable()
    that calls pm_runtime_resume_and_get() and that returns -EACCES to
    indicate failure to resume because runtime PM is disabled for all
    devices.
    
    Upon closer inspection, calling runtime PM APIs like this in the GDSC
    driver doesn't make sense. It was intended to make sure the GDSC for the
    clock controller providing other GDSCs was enabled, specifically the
    MMCX GDSC for the display clk controller on SM8250 (sm8250-dispcc), so
    that GDSC register accesses succeeded. That will already happen because
    we make the 'dev->pm_domain' a parent domain of each GDSC we register in
    gdsc_register() via pm_genpd_add_subdomain(). When any of these GDSCs
    are accessed, we'll enable the parent domain (in this specific case
    MMCX).
    
    We also remove any getting of runtime PM during registration, because
    when a genpd is registered it increments the count on the parent if the
    genpd itself is already enabled.
    
    Cc: Dmitry Baryshkov <dmitry.baryshkov@linaro.org>
    Cc: Johan Hovold <johan+linaro@kernel.org>
    Cc: Ulf Hansson <ulf.hansson@linaro.org>
    Cc: Taniya Das <quic_tdas@quicinc.com>
    Cc: Satya Priya <quic_c_skakit@quicinc.com>
    Reviewed-by: Douglas Anderson <dianders@chromium.org>
    Tested-by: Douglas Anderson <dianders@chromium.org>
    Cc: Matthias Kaehlcke <mka@chromium.org>
    Reported-by: Stephen Boyd <swboyd@chromium.org>
    Link: https://lore.kernel.org/r/CAE-0n52xbZeJ66RaKwggeRB57fUAwjvxGxfFMKOKJMKVyFTe+w@mail.gmail.com [1]
    Fixes: 1b771839de05 ("clk: qcom: gdsc: enable optional power domain support")
    Signed-off-by: Stephen Boyd <swboyd@chromium.org>
    Link: https://lore.kernel.org/r/20221103183030.3594899-1-swboyd@chromium.org
    Tested-by: Johan Hovold <johan+linaro@kernel.org>
    Reviewed-by: Johan Hovold <johan+linaro@kernel.org>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 571b6bbbf54d835ea6120f65575cb55cd767e603
Author: Jan Dabros <jsd@semihalf.com>
Date:   Mon Nov 28 20:56:51 2022 +0100

    char: tpm: Protect tpm_pm_suspend with locks
    
    commit 23393c6461422df5bf8084a086ada9a7e17dc2ba upstream.
    
    Currently tpm transactions are executed unconditionally in
    tpm_pm_suspend() function, which may lead to races with other tpm
    accessors in the system.
    
    Specifically, the hw_random tpm driver makes use of tpm_get_random(),
    and this function is called in a loop from a kthread, which means it's
    not frozen alongside userspace, and so can race with the work done
    during system suspend:
    
      tpm tpm0: tpm_transmit: tpm_recv: error -52
      tpm tpm0: invalid TPM_STS.x 0xff, dumping stack for forensics
      CPU: 0 PID: 1 Comm: init Not tainted 6.1.0-rc5+ #135
      Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.0-20220807_005459-localhost 04/01/2014
      Call Trace:
       tpm_tis_status.cold+0x19/0x20
       tpm_transmit+0x13b/0x390
       tpm_transmit_cmd+0x20/0x80
       tpm1_pm_suspend+0xa6/0x110
       tpm_pm_suspend+0x53/0x80
       __pnp_bus_suspend+0x35/0xe0
       __device_suspend+0x10f/0x350
    
    Fix this by calling tpm_try_get_ops(), which itself is a wrapper around
    tpm_chip_start(), but takes the appropriate mutex.
    
    Signed-off-by: Jan Dabros <jsd@semihalf.com>
    Reported-by: Vlastimil Babka <vbabka@suse.cz>
    Tested-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Tested-by: Vlastimil Babka <vbabka@suse.cz>
    Link: https://lore.kernel.org/all/c5ba47ef-393f-1fba-30bd-1230d1b4b592@suse.cz/
    Cc: stable@vger.kernel.org
    Fixes: e891db1a18bf ("tpm: turn on TPM on suspend for TPM 1.x")
    [Jason: reworked commit message, added metadata]
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Reviewed-by: Jarkko Sakkinen <jarkko@kernel.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 4e0d6c687c925e27fd4bc78a2721d10acf5614d6
Author: Jan Dabros <jsd@semihalf.com>
Date:   Mon Nov 28 20:56:51 2022 +0100

    char: tpm: Protect tpm_pm_suspend with locks
    
    commit 23393c6461422df5bf8084a086ada9a7e17dc2ba upstream.
    
    Currently tpm transactions are executed unconditionally in
    tpm_pm_suspend() function, which may lead to races with other tpm
    accessors in the system.
    
    Specifically, the hw_random tpm driver makes use of tpm_get_random(),
    and this function is called in a loop from a kthread, which means it's
    not frozen alongside userspace, and so can race with the work done
    during system suspend:
    
      tpm tpm0: tpm_transmit: tpm_recv: error -52
      tpm tpm0: invalid TPM_STS.x 0xff, dumping stack for forensics
      CPU: 0 PID: 1 Comm: init Not tainted 6.1.0-rc5+ #135
      Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.0-20220807_005459-localhost 04/01/2014
      Call Trace:
       tpm_tis_status.cold+0x19/0x20
       tpm_transmit+0x13b/0x390
       tpm_transmit_cmd+0x20/0x80
       tpm1_pm_suspend+0xa6/0x110
       tpm_pm_suspend+0x53/0x80
       __pnp_bus_suspend+0x35/0xe0
       __device_suspend+0x10f/0x350
    
    Fix this by calling tpm_try_get_ops(), which itself is a wrapper around
    tpm_chip_start(), but takes the appropriate mutex.
    
    Signed-off-by: Jan Dabros <jsd@semihalf.com>
    Reported-by: Vlastimil Babka <vbabka@suse.cz>
    Tested-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Tested-by: Vlastimil Babka <vbabka@suse.cz>
    Link: https://lore.kernel.org/all/c5ba47ef-393f-1fba-30bd-1230d1b4b592@suse.cz/
    Cc: stable@vger.kernel.org
    Fixes: e891db1a18bf ("tpm: turn on TPM on suspend for TPM 1.x")
    [Jason: reworked commit message, added metadata]
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Reviewed-by: Jarkko Sakkinen <jarkko@kernel.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 7462cd2443bc30488d29428ff8e13f96f8262f14
Author: Pawan Gupta <pawan.kumar.gupta@linux.intel.com>
Date:   Thu Dec 1 12:19:41 2022 -0800

    x86/pm: Add enumeration check before spec MSRs save/restore setup
    
    commit 50bcceb7724e471d9b591803889df45dcbb584bc upstream.
    
    pm_save_spec_msr() keeps a list of all the MSRs which _might_ need
    to be saved and restored at hibernate and resume. However, it has
    zero awareness of CPU support for these MSRs. It mostly works by
    unconditionally attempting to manipulate these MSRs and relying on
    rdmsrl_safe() being able to handle a #GP on CPUs where the support is
    unavailable.
    
    However, it's possible for reads (RDMSR) to be supported for a given MSR
    while writes (WRMSR) are not. In this case, msr_build_context() sees
    a successful read (RDMSR) and marks the MSR as valid. Then, later, a
    write (WRMSR) fails, producing a nasty (but harmless) error message.
    This causes restore_processor_state() to try and restore it, but writing
    this MSR is not allowed on the Intel Atom N2600 leading to:
    
      unchecked MSR access error: WRMSR to 0x122 (tried to write 0x0000000000000002) \
         at rIP: 0xffffffff8b07a574 (native_write_msr+0x4/0x20)
      Call Trace:
       <TASK>
       restore_processor_state
       x86_acpi_suspend_lowlevel
       acpi_suspend_enter
       suspend_devices_and_enter
       pm_suspend.cold
       state_store
       kernfs_fop_write_iter
       vfs_write
       ksys_write
       do_syscall_64
       ? do_syscall_64
       ? up_read
       ? lock_is_held_type
       ? asm_exc_page_fault
       ? lockdep_hardirqs_on
       entry_SYSCALL_64_after_hwframe
    
    To fix this, add the corresponding X86_FEATURE bit for each MSR.  Avoid
    trying to manipulate the MSR when the feature bit is clear. This
    required adding a X86_FEATURE bit for MSRs that do not have one already,
    but it's a small price to pay.
    
      [ bp: Move struct msr_enumeration inside the only function that uses it. ]
      [Pawan: Resolve build issue in backport]
    
    Fixes: 73924ec4d560 ("x86/pm: Save the MSR validity status at context setup")
    Reported-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Pawan Gupta <pawan.kumar.gupta@linux.intel.com>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Reviewed-by: Dave Hansen <dave.hansen@linux.intel.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: <stable@kernel.org>
    Link: https://lore.kernel.org/r/c24db75d69df6e66c0465e13676ad3f2837a2ed8.1668539735.git.pawan.kumar.gupta@linux.intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit d699373ac5f3545243d3c73a1ccab77fdef8cec6
Author: Jan Dabros <jsd@semihalf.com>
Date:   Mon Nov 28 20:56:51 2022 +0100

    char: tpm: Protect tpm_pm_suspend with locks
    
    commit 23393c6461422df5bf8084a086ada9a7e17dc2ba upstream.
    
    Currently tpm transactions are executed unconditionally in
    tpm_pm_suspend() function, which may lead to races with other tpm
    accessors in the system.
    
    Specifically, the hw_random tpm driver makes use of tpm_get_random(),
    and this function is called in a loop from a kthread, which means it's
    not frozen alongside userspace, and so can race with the work done
    during system suspend:
    
      tpm tpm0: tpm_transmit: tpm_recv: error -52
      tpm tpm0: invalid TPM_STS.x 0xff, dumping stack for forensics
      CPU: 0 PID: 1 Comm: init Not tainted 6.1.0-rc5+ #135
      Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.0-20220807_005459-localhost 04/01/2014
      Call Trace:
       tpm_tis_status.cold+0x19/0x20
       tpm_transmit+0x13b/0x390
       tpm_transmit_cmd+0x20/0x80
       tpm1_pm_suspend+0xa6/0x110
       tpm_pm_suspend+0x53/0x80
       __pnp_bus_suspend+0x35/0xe0
       __device_suspend+0x10f/0x350
    
    Fix this by calling tpm_try_get_ops(), which itself is a wrapper around
    tpm_chip_start(), but takes the appropriate mutex.
    
    Signed-off-by: Jan Dabros <jsd@semihalf.com>
    Reported-by: Vlastimil Babka <vbabka@suse.cz>
    Tested-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Tested-by: Vlastimil Babka <vbabka@suse.cz>
    Link: https://lore.kernel.org/all/c5ba47ef-393f-1fba-30bd-1230d1b4b592@suse.cz/
    Cc: stable@vger.kernel.org
    Fixes: e891db1a18bf ("tpm: turn on TPM on suspend for TPM 1.x")
    [Jason: reworked commit message, added metadata]
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Reviewed-by: Jarkko Sakkinen <jarkko@kernel.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit b5041a3daa7fe7489b51411a22eda2d3ef79bb63
Author: Pawan Gupta <pawan.kumar.gupta@linux.intel.com>
Date:   Thu Dec 1 14:55:50 2022 -0800

    x86/pm: Add enumeration check before spec MSRs save/restore setup
    
    commit 50bcceb7724e471d9b591803889df45dcbb584bc upstream.
    
    pm_save_spec_msr() keeps a list of all the MSRs which _might_ need
    to be saved and restored at hibernate and resume. However, it has
    zero awareness of CPU support for these MSRs. It mostly works by
    unconditionally attempting to manipulate these MSRs and relying on
    rdmsrl_safe() being able to handle a #GP on CPUs where the support is
    unavailable.
    
    However, it's possible for reads (RDMSR) to be supported for a given MSR
    while writes (WRMSR) are not. In this case, msr_build_context() sees
    a successful read (RDMSR) and marks the MSR as valid. Then, later, a
    write (WRMSR) fails, producing a nasty (but harmless) error message.
    This causes restore_processor_state() to try and restore it, but writing
    this MSR is not allowed on the Intel Atom N2600 leading to:
    
      unchecked MSR access error: WRMSR to 0x122 (tried to write 0x0000000000000002) \
         at rIP: 0xffffffff8b07a574 (native_write_msr+0x4/0x20)
      Call Trace:
       <TASK>
       restore_processor_state
       x86_acpi_suspend_lowlevel
       acpi_suspend_enter
       suspend_devices_and_enter
       pm_suspend.cold
       state_store
       kernfs_fop_write_iter
       vfs_write
       ksys_write
       do_syscall_64
       ? do_syscall_64
       ? up_read
       ? lock_is_held_type
       ? asm_exc_page_fault
       ? lockdep_hardirqs_on
       entry_SYSCALL_64_after_hwframe
    
    To fix this, add the corresponding X86_FEATURE bit for each MSR.  Avoid
    trying to manipulate the MSR when the feature bit is clear. This
    required adding a X86_FEATURE bit for MSRs that do not have one already,
    but it's a small price to pay.
    
      [ bp: Move struct msr_enumeration inside the only function that uses it. ]
      [Pawan: Resolve build issue in backport]
    
    Fixes: 73924ec4d560 ("x86/pm: Save the MSR validity status at context setup")
    Reported-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Pawan Gupta <pawan.kumar.gupta@linux.intel.com>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Reviewed-by: Dave Hansen <dave.hansen@linux.intel.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: <stable@kernel.org>
    Link: https://lore.kernel.org/r/c24db75d69df6e66c0465e13676ad3f2837a2ed8.1668539735.git.pawan.kumar.gupta@linux.intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 6960c31df2df9ca8da467014f5d58ec866e603ea
Author: Pawan Gupta <pawan.kumar.gupta@linux.intel.com>
Date:   Thu Dec 1 18:29:20 2022 -0800

    x86/pm: Add enumeration check before spec MSRs save/restore setup
    
    commit 50bcceb7724e471d9b591803889df45dcbb584bc upstream.
    
    pm_save_spec_msr() keeps a list of all the MSRs which _might_ need
    to be saved and restored at hibernate and resume. However, it has
    zero awareness of CPU support for these MSRs. It mostly works by
    unconditionally attempting to manipulate these MSRs and relying on
    rdmsrl_safe() being able to handle a #GP on CPUs where the support is
    unavailable.
    
    However, it's possible for reads (RDMSR) to be supported for a given MSR
    while writes (WRMSR) are not. In this case, msr_build_context() sees
    a successful read (RDMSR) and marks the MSR as valid. Then, later, a
    write (WRMSR) fails, producing a nasty (but harmless) error message.
    This causes restore_processor_state() to try and restore it, but writing
    this MSR is not allowed on the Intel Atom N2600 leading to:
    
      unchecked MSR access error: WRMSR to 0x122 (tried to write 0x0000000000000002) \
         at rIP: 0xffffffff8b07a574 (native_write_msr+0x4/0x20)
      Call Trace:
       <TASK>
       restore_processor_state
       x86_acpi_suspend_lowlevel
       acpi_suspend_enter
       suspend_devices_and_enter
       pm_suspend.cold
       state_store
       kernfs_fop_write_iter
       vfs_write
       ksys_write
       do_syscall_64
       ? do_syscall_64
       ? up_read
       ? lock_is_held_type
       ? asm_exc_page_fault
       ? lockdep_hardirqs_on
       entry_SYSCALL_64_after_hwframe
    
    To fix this, add the corresponding X86_FEATURE bit for each MSR.  Avoid
    trying to manipulate the MSR when the feature bit is clear. This
    required adding a X86_FEATURE bit for MSRs that do not have one already,
    but it's a small price to pay.
    
      [ bp: Move struct msr_enumeration inside the only function that uses it. ]
      [Pawan: Resolve build issue in backport]
    
    Fixes: 73924ec4d560 ("x86/pm: Save the MSR validity status at context setup")
    Reported-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Pawan Gupta <pawan.kumar.gupta@linux.intel.com>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Reviewed-by: Dave Hansen <dave.hansen@linux.intel.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: <stable@kernel.org>
    Link: https://lore.kernel.org/r/c24db75d69df6e66c0465e13676ad3f2837a2ed8.1668539735.git.pawan.kumar.gupta@linux.intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 8055cd48abb143d7da371962c0c44a6801e90aa0
Author: Pawan Gupta <pawan.kumar.gupta@linux.intel.com>
Date:   Thu Dec 1 19:45:21 2022 -0800

    x86/pm: Add enumeration check before spec MSRs save/restore setup
    
    commit 50bcceb7724e471d9b591803889df45dcbb584bc upstream.
    
    pm_save_spec_msr() keeps a list of all the MSRs which _might_ need
    to be saved and restored at hibernate and resume. However, it has
    zero awareness of CPU support for these MSRs. It mostly works by
    unconditionally attempting to manipulate these MSRs and relying on
    rdmsrl_safe() being able to handle a #GP on CPUs where the support is
    unavailable.
    
    However, it's possible for reads (RDMSR) to be supported for a given MSR
    while writes (WRMSR) are not. In this case, msr_build_context() sees
    a successful read (RDMSR) and marks the MSR as valid. Then, later, a
    write (WRMSR) fails, producing a nasty (but harmless) error message.
    This causes restore_processor_state() to try and restore it, but writing
    this MSR is not allowed on the Intel Atom N2600 leading to:
    
      unchecked MSR access error: WRMSR to 0x122 (tried to write 0x0000000000000002) \
         at rIP: 0xffffffff8b07a574 (native_write_msr+0x4/0x20)
      Call Trace:
       <TASK>
       restore_processor_state
       x86_acpi_suspend_lowlevel
       acpi_suspend_enter
       suspend_devices_and_enter
       pm_suspend.cold
       state_store
       kernfs_fop_write_iter
       vfs_write
       ksys_write
       do_syscall_64
       ? do_syscall_64
       ? up_read
       ? lock_is_held_type
       ? asm_exc_page_fault
       ? lockdep_hardirqs_on
       entry_SYSCALL_64_after_hwframe
    
    To fix this, add the corresponding X86_FEATURE bit for each MSR.  Avoid
    trying to manipulate the MSR when the feature bit is clear. This
    required adding a X86_FEATURE bit for MSRs that do not have one already,
    but it's a small price to pay.
    
      [ bp: Move struct msr_enumeration inside the only function that uses it. ]
      [Pawan: Resolve build issue in backport]
    
    Fixes: 73924ec4d560 ("x86/pm: Save the MSR validity status at context setup")
    Reported-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Pawan Gupta <pawan.kumar.gupta@linux.intel.com>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Reviewed-by: Dave Hansen <dave.hansen@linux.intel.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: <stable@kernel.org>
    Link: https://lore.kernel.org/r/c24db75d69df6e66c0465e13676ad3f2837a2ed8.1668539735.git.pawan.kumar.gupta@linux.intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit fee642b7337815e8645ddf204cc532d8f549b70a
Author: Pawan Gupta <pawan.kumar.gupta@linux.intel.com>
Date:   Thu Dec 1 20:23:18 2022 -0800

    x86/pm: Add enumeration check before spec MSRs save/restore setup
    
    commit 50bcceb7724e471d9b591803889df45dcbb584bc upstream.
    
    pm_save_spec_msr() keeps a list of all the MSRs which _might_ need
    to be saved and restored at hibernate and resume. However, it has
    zero awareness of CPU support for these MSRs. It mostly works by
    unconditionally attempting to manipulate these MSRs and relying on
    rdmsrl_safe() being able to handle a #GP on CPUs where the support is
    unavailable.
    
    However, it's possible for reads (RDMSR) to be supported for a given MSR
    while writes (WRMSR) are not. In this case, msr_build_context() sees
    a successful read (RDMSR) and marks the MSR as valid. Then, later, a
    write (WRMSR) fails, producing a nasty (but harmless) error message.
    This causes restore_processor_state() to try and restore it, but writing
    this MSR is not allowed on the Intel Atom N2600 leading to:
    
      unchecked MSR access error: WRMSR to 0x122 (tried to write 0x0000000000000002) \
         at rIP: 0xffffffff8b07a574 (native_write_msr+0x4/0x20)
      Call Trace:
       <TASK>
       restore_processor_state
       x86_acpi_suspend_lowlevel
       acpi_suspend_enter
       suspend_devices_and_enter
       pm_suspend.cold
       state_store
       kernfs_fop_write_iter
       vfs_write
       ksys_write
       do_syscall_64
       ? do_syscall_64
       ? up_read
       ? lock_is_held_type
       ? asm_exc_page_fault
       ? lockdep_hardirqs_on
       entry_SYSCALL_64_after_hwframe
    
    To fix this, add the corresponding X86_FEATURE bit for each MSR.  Avoid
    trying to manipulate the MSR when the feature bit is clear. This
    required adding a X86_FEATURE bit for MSRs that do not have one already,
    but it's a small price to pay.
    
      [ bp: Move struct msr_enumeration inside the only function that uses it. ]
      [Pawan: Resolve build issue in backport]
    
    Fixes: 73924ec4d560 ("x86/pm: Save the MSR validity status at context setup")
    Reported-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Pawan Gupta <pawan.kumar.gupta@linux.intel.com>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Reviewed-by: Dave Hansen <dave.hansen@linux.intel.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: <stable@kernel.org>
    Link: https://lore.kernel.org/r/c24db75d69df6e66c0465e13676ad3f2837a2ed8.1668539735.git.pawan.kumar.gupta@linux.intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit bc80c2e438dcbfcf748452ec0f7ad5b79ff3ad88
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Dec 2 15:30:28 2022 +0100

    PM: runtime: Do not call __rpm_callback() from rpm_idle()
    
    Calling __rpm_callback() from rpm_idle() after adding device links
    support to the former is a clear mistake.
    
    Not only it causes rpm_idle() to carry out unnecessary actions, but it
    is also against the assumption regarding the stability of PM-runtime
    status across __rpm_callback() invocations, because rpm_suspend() and
    rpm_resume() may run in parallel with __rpm_callback() when it is called
    by rpm_idle() and the device's PM-runtime status can be updated by any
    of them.
    
    Fixes: 21d5c57b3726 ("PM / runtime: Use device links")
    Link: https://lore.kernel.org/linux-pm/36aed941-a73e-d937-2721-4f0decd61ce0@quicinc.com
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Adrian Hunter <adrian.hunter@intel.com>

commit 23393c6461422df5bf8084a086ada9a7e17dc2ba
Author: Jan Dabros <jsd@semihalf.com>
Date:   Mon Nov 28 20:56:51 2022 +0100

    char: tpm: Protect tpm_pm_suspend with locks
    
    Currently tpm transactions are executed unconditionally in
    tpm_pm_suspend() function, which may lead to races with other tpm
    accessors in the system.
    
    Specifically, the hw_random tpm driver makes use of tpm_get_random(),
    and this function is called in a loop from a kthread, which means it's
    not frozen alongside userspace, and so can race with the work done
    during system suspend:
    
      tpm tpm0: tpm_transmit: tpm_recv: error -52
      tpm tpm0: invalid TPM_STS.x 0xff, dumping stack for forensics
      CPU: 0 PID: 1 Comm: init Not tainted 6.1.0-rc5+ #135
      Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.0-20220807_005459-localhost 04/01/2014
      Call Trace:
       tpm_tis_status.cold+0x19/0x20
       tpm_transmit+0x13b/0x390
       tpm_transmit_cmd+0x20/0x80
       tpm1_pm_suspend+0xa6/0x110
       tpm_pm_suspend+0x53/0x80
       __pnp_bus_suspend+0x35/0xe0
       __device_suspend+0x10f/0x350
    
    Fix this by calling tpm_try_get_ops(), which itself is a wrapper around
    tpm_chip_start(), but takes the appropriate mutex.
    
    Signed-off-by: Jan Dabros <jsd@semihalf.com>
    Reported-by: Vlastimil Babka <vbabka@suse.cz>
    Tested-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Tested-by: Vlastimil Babka <vbabka@suse.cz>
    Link: https://lore.kernel.org/all/c5ba47ef-393f-1fba-30bd-1230d1b4b592@suse.cz/
    Cc: stable@vger.kernel.org
    Fixes: e891db1a18bf ("tpm: turn on TPM on suspend for TPM 1.x")
    [Jason: reworked commit message, added metadata]
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Reviewed-by: Jarkko Sakkinen <jarkko@kernel.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit 61fbd56be51af7db779dae71776c47b0a22c93a8
Author: Pawan Gupta <pawan.kumar.gupta@linux.intel.com>
Date:   Tue Nov 15 11:17:06 2022 -0800

    x86/pm: Add enumeration check before spec MSRs save/restore setup
    
    commit 50bcceb7724e471d9b591803889df45dcbb584bc upstream.
    
    pm_save_spec_msr() keeps a list of all the MSRs which _might_ need
    to be saved and restored at hibernate and resume. However, it has
    zero awareness of CPU support for these MSRs. It mostly works by
    unconditionally attempting to manipulate these MSRs and relying on
    rdmsrl_safe() being able to handle a #GP on CPUs where the support is
    unavailable.
    
    However, it's possible for reads (RDMSR) to be supported for a given MSR
    while writes (WRMSR) are not. In this case, msr_build_context() sees
    a successful read (RDMSR) and marks the MSR as valid. Then, later, a
    write (WRMSR) fails, producing a nasty (but harmless) error message.
    This causes restore_processor_state() to try and restore it, but writing
    this MSR is not allowed on the Intel Atom N2600 leading to:
    
      unchecked MSR access error: WRMSR to 0x122 (tried to write 0x0000000000000002) \
         at rIP: 0xffffffff8b07a574 (native_write_msr+0x4/0x20)
      Call Trace:
       <TASK>
       restore_processor_state
       x86_acpi_suspend_lowlevel
       acpi_suspend_enter
       suspend_devices_and_enter
       pm_suspend.cold
       state_store
       kernfs_fop_write_iter
       vfs_write
       ksys_write
       do_syscall_64
       ? do_syscall_64
       ? up_read
       ? lock_is_held_type
       ? asm_exc_page_fault
       ? lockdep_hardirqs_on
       entry_SYSCALL_64_after_hwframe
    
    To fix this, add the corresponding X86_FEATURE bit for each MSR.  Avoid
    trying to manipulate the MSR when the feature bit is clear. This
    required adding a X86_FEATURE bit for MSRs that do not have one already,
    but it's a small price to pay.
    
      [ bp: Move struct msr_enumeration inside the only function that uses it. ]
    
    Fixes: 73924ec4d560 ("x86/pm: Save the MSR validity status at context setup")
    Reported-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Pawan Gupta <pawan.kumar.gupta@linux.intel.com>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Reviewed-by: Dave Hansen <dave.hansen@linux.intel.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: <stable@kernel.org>
    Link: https://lore.kernel.org/r/c24db75d69df6e66c0465e13676ad3f2837a2ed8.1668539735.git.pawan.kumar.gupta@linux.intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit d048f7481524a7b15a6262f697016149859f4c1b
Author: Pawan Gupta <pawan.kumar.gupta@linux.intel.com>
Date:   Tue Nov 15 11:17:06 2022 -0800

    x86/pm: Add enumeration check before spec MSRs save/restore setup
    
    commit 50bcceb7724e471d9b591803889df45dcbb584bc upstream.
    
    pm_save_spec_msr() keeps a list of all the MSRs which _might_ need
    to be saved and restored at hibernate and resume. However, it has
    zero awareness of CPU support for these MSRs. It mostly works by
    unconditionally attempting to manipulate these MSRs and relying on
    rdmsrl_safe() being able to handle a #GP on CPUs where the support is
    unavailable.
    
    However, it's possible for reads (RDMSR) to be supported for a given MSR
    while writes (WRMSR) are not. In this case, msr_build_context() sees
    a successful read (RDMSR) and marks the MSR as valid. Then, later, a
    write (WRMSR) fails, producing a nasty (but harmless) error message.
    This causes restore_processor_state() to try and restore it, but writing
    this MSR is not allowed on the Intel Atom N2600 leading to:
    
      unchecked MSR access error: WRMSR to 0x122 (tried to write 0x0000000000000002) \
         at rIP: 0xffffffff8b07a574 (native_write_msr+0x4/0x20)
      Call Trace:
       <TASK>
       restore_processor_state
       x86_acpi_suspend_lowlevel
       acpi_suspend_enter
       suspend_devices_and_enter
       pm_suspend.cold
       state_store
       kernfs_fop_write_iter
       vfs_write
       ksys_write
       do_syscall_64
       ? do_syscall_64
       ? up_read
       ? lock_is_held_type
       ? asm_exc_page_fault
       ? lockdep_hardirqs_on
       entry_SYSCALL_64_after_hwframe
    
    To fix this, add the corresponding X86_FEATURE bit for each MSR.  Avoid
    trying to manipulate the MSR when the feature bit is clear. This
    required adding a X86_FEATURE bit for MSRs that do not have one already,
    but it's a small price to pay.
    
      [ bp: Move struct msr_enumeration inside the only function that uses it. ]
    
    Fixes: 73924ec4d560 ("x86/pm: Save the MSR validity status at context setup")
    Reported-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Pawan Gupta <pawan.kumar.gupta@linux.intel.com>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Reviewed-by: Dave Hansen <dave.hansen@linux.intel.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: <stable@kernel.org>
    Link: https://lore.kernel.org/r/c24db75d69df6e66c0465e13676ad3f2837a2ed8.1668539735.git.pawan.kumar.gupta@linux.intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 50bcceb7724e471d9b591803889df45dcbb584bc
Author: Pawan Gupta <pawan.kumar.gupta@linux.intel.com>
Date:   Tue Nov 15 11:17:06 2022 -0800

    x86/pm: Add enumeration check before spec MSRs save/restore setup
    
    pm_save_spec_msr() keeps a list of all the MSRs which _might_ need
    to be saved and restored at hibernate and resume. However, it has
    zero awareness of CPU support for these MSRs. It mostly works by
    unconditionally attempting to manipulate these MSRs and relying on
    rdmsrl_safe() being able to handle a #GP on CPUs where the support is
    unavailable.
    
    However, it's possible for reads (RDMSR) to be supported for a given MSR
    while writes (WRMSR) are not. In this case, msr_build_context() sees
    a successful read (RDMSR) and marks the MSR as valid. Then, later, a
    write (WRMSR) fails, producing a nasty (but harmless) error message.
    This causes restore_processor_state() to try and restore it, but writing
    this MSR is not allowed on the Intel Atom N2600 leading to:
    
      unchecked MSR access error: WRMSR to 0x122 (tried to write 0x0000000000000002) \
         at rIP: 0xffffffff8b07a574 (native_write_msr+0x4/0x20)
      Call Trace:
       <TASK>
       restore_processor_state
       x86_acpi_suspend_lowlevel
       acpi_suspend_enter
       suspend_devices_and_enter
       pm_suspend.cold
       state_store
       kernfs_fop_write_iter
       vfs_write
       ksys_write
       do_syscall_64
       ? do_syscall_64
       ? up_read
       ? lock_is_held_type
       ? asm_exc_page_fault
       ? lockdep_hardirqs_on
       entry_SYSCALL_64_after_hwframe
    
    To fix this, add the corresponding X86_FEATURE bit for each MSR.  Avoid
    trying to manipulate the MSR when the feature bit is clear. This
    required adding a X86_FEATURE bit for MSRs that do not have one already,
    but it's a small price to pay.
    
      [ bp: Move struct msr_enumeration inside the only function that uses it. ]
    
    Fixes: 73924ec4d560 ("x86/pm: Save the MSR validity status at context setup")
    Reported-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Pawan Gupta <pawan.kumar.gupta@linux.intel.com>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Reviewed-by: Dave Hansen <dave.hansen@linux.intel.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: <stable@kernel.org>
    Link: https://lore.kernel.org/r/c24db75d69df6e66c0465e13676ad3f2837a2ed8.1668539735.git.pawan.kumar.gupta@linux.intel.com

commit 4cc47e8add635408e063c98b52d56b7ceacf0b70
Author: Stephen Boyd <swboyd@chromium.org>
Date:   Thu Nov 3 11:30:30 2022 -0700

    clk: qcom: gdsc: Remove direct runtime PM calls
    
    We shouldn't be calling runtime PM APIs from within the genpd
    enable/disable path for a couple reasons.
    
    First, this causes an AA lockdep splat[1] because genpd can call into
    genpd code again while holding the genpd lock.
    
    WARNING: possible recursive locking detected
    5.19.0-rc2-lockdep+ #7 Not tainted
    --------------------------------------------
    kworker/2:1/49 is trying to acquire lock:
    ffffffeea0370788 (&genpd->mlock){+.+.}-{3:3}, at: genpd_lock_mtx+0x24/0x30
    
    but task is already holding lock:
    ffffffeea03710a8 (&genpd->mlock){+.+.}-{3:3}, at: genpd_lock_mtx+0x24/0x30
    
    other info that might help us debug this:
     Possible unsafe locking scenario:
    
           CPU0
           ----
      lock(&genpd->mlock);
      lock(&genpd->mlock);
    
     *** DEADLOCK ***
    
     May be due to missing lock nesting notation
    
    3 locks held by kworker/2:1/49:
     #0: 74ffff80811a5748 ((wq_completion)pm){+.+.}-{0:0}, at: process_one_work+0x320/0x5fc
     #1: ffffffc008537cf8 ((work_completion)(&genpd->power_off_work)){+.+.}-{0:0}, at: process_one_work+0x354/0x5fc
     #2: ffffffeea03710a8 (&genpd->mlock){+.+.}-{3:3}, at: genpd_lock_mtx+0x24/0x30
    
    stack backtrace:
    CPU: 2 PID: 49 Comm: kworker/2:1 Not tainted 5.19.0-rc2-lockdep+ #7
    Hardware name: Google Lazor (rev3 - 8) with KB Backlight (DT)
    Workqueue: pm genpd_power_off_work_fn
    Call trace:
     dump_backtrace+0x1a0/0x200
     show_stack+0x24/0x30
     dump_stack_lvl+0x7c/0xa0
     dump_stack+0x18/0x44
     __lock_acquire+0xb38/0x3634
     lock_acquire+0x180/0x2d4
     __mutex_lock_common+0x118/0xe30
     mutex_lock_nested+0x70/0x7c
     genpd_lock_mtx+0x24/0x30
     genpd_runtime_suspend+0x2f0/0x414
     __rpm_callback+0xdc/0x1b8
     rpm_callback+0x4c/0xcc
     rpm_suspend+0x21c/0x5f0
     rpm_idle+0x17c/0x1e0
     __pm_runtime_idle+0x78/0xcc
     gdsc_disable+0x24c/0x26c
     _genpd_power_off+0xd4/0x1c4
     genpd_power_off+0x2d8/0x41c
     genpd_power_off_work_fn+0x60/0x94
     process_one_work+0x398/0x5fc
     worker_thread+0x42c/0x6c4
     kthread+0x194/0x1b4
     ret_from_fork+0x10/0x20
    
    Second, this confuses runtime PM on CoachZ for the camera devices by
    causing the camera clock controller's runtime PM usage_count to go
    negative after resuming from suspend. This is because runtime PM is
    being used on the clock controller while runtime PM is disabled for the
    device.
    
    The reason for the negative count is because a GDSC is represented as a
    genpd and each genpd that is attached to a device is resumed during the
    noirq phase of system wide suspend/resume (see the noirq suspend ops
    assignment in pm_genpd_init() for more details). The camera GDSCs are
    attached to camera devices with the 'power-domains' property in DT.
    Every device has runtime PM disabled in the late system suspend phase
    via __device_suspend_late(). Runtime PM is not usable until runtime PM
    is enabled in device_resume_early(). The noirq phases run after the
    'late' and before the 'early' phase of suspend/resume. When the genpds
    are resumed in genpd_resume_noirq(), we call down into gdsc_enable()
    that calls pm_runtime_resume_and_get() and that returns -EACCES to
    indicate failure to resume because runtime PM is disabled for all
    devices.
    
    Upon closer inspection, calling runtime PM APIs like this in the GDSC
    driver doesn't make sense. It was intended to make sure the GDSC for the
    clock controller providing other GDSCs was enabled, specifically the
    MMCX GDSC for the display clk controller on SM8250 (sm8250-dispcc), so
    that GDSC register accesses succeeded. That will already happen because
    we make the 'dev->pm_domain' a parent domain of each GDSC we register in
    gdsc_register() via pm_genpd_add_subdomain(). When any of these GDSCs
    are accessed, we'll enable the parent domain (in this specific case
    MMCX).
    
    We also remove any getting of runtime PM during registration, because
    when a genpd is registered it increments the count on the parent if the
    genpd itself is already enabled.
    
    Cc: Dmitry Baryshkov <dmitry.baryshkov@linaro.org>
    Cc: Johan Hovold <johan+linaro@kernel.org>
    Cc: Ulf Hansson <ulf.hansson@linaro.org>
    Cc: Taniya Das <quic_tdas@quicinc.com>
    Cc: Satya Priya <quic_c_skakit@quicinc.com>
    Reviewed-by: Douglas Anderson <dianders@chromium.org>
    Tested-by: Douglas Anderson <dianders@chromium.org>
    Cc: Matthias Kaehlcke <mka@chromium.org>
    Reported-by: Stephen Boyd <swboyd@chromium.org>
    Link: https://lore.kernel.org/r/CAE-0n52xbZeJ66RaKwggeRB57fUAwjvxGxfFMKOKJMKVyFTe+w@mail.gmail.com [1]
    Fixes: 1b771839de05 ("clk: qcom: gdsc: enable optional power domain support")
    Signed-off-by: Stephen Boyd <swboyd@chromium.org>
    Link: https://lore.kernel.org/r/20221103183030.3594899-1-swboyd@chromium.org
    Tested-by: Johan Hovold <johan+linaro@kernel.org>
    Reviewed-by: Johan Hovold <johan+linaro@kernel.org>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

commit 11a8d8774e68e07385a5b10d9546598f57ace7da
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Tue Oct 25 15:38:49 2022 -0500

    agp/nvidia: Convert to generic power management
    
    Convert agpgart-nvidia from legacy PCI power management to the generic
    power management framework.
    
    Previously agpgart-nvidia used legacy PCI power management, and
    agp_nvidia_suspend() and agp_nvidia_resume() were responsible for both
    device-specific things and generic PCI things:
    
      agp_nvidia_suspend
        pci_save_state                         <-- generic PCI
        pci_set_power_state(PCI_D3hot)         <-- generic PCI
    
      agp_nvidia_resume
        pci_set_power_state(PCI_D0)            <-- generic PCI
        pci_restore_state                      <-- generic PCI
        nvidia_configure                       <-- device-specific
    
    Convert to generic power management where the PCI bus PM methods do the
    generic PCI things, and the driver needs only the device-specific part,
    i.e.,
    
      suspend_devices_and_enter
        dpm_suspend_start(PMSG_SUSPEND)
          pci_pm_suspend                       # PCI bus .suspend() method
            agp_nvidia_suspend                 <-- not needed at all; removed
        suspend_enter
          dpm_suspend_noirq(PMSG_SUSPEND)
            pci_pm_suspend_noirq               # PCI bus .suspend_noirq() method
              pci_save_state                   <-- generic PCI
              pci_prepare_to_sleep             <-- generic PCI
                pci_set_power_state
        ...
        dpm_resume_end(PMSG_RESUME)
          pci_pm_resume                        # PCI bus .resume() method
            pci_restore_standard_config
              pci_set_power_state(PCI_D0)      <-- generic PCI
              pci_restore_state                <-- generic PCI
            agp_nvidia_resume                  # driver->pm->resume
              nvidia_configure                 <-- device-specific
    
    Based on 0aeddbd0cb07 ("via-agp: convert to generic power management") by
    Vaibhav Gupta <vaibhavgupta40@gmail.com>.
    
    Link: https://lore.kernel.org/r/20221025203852.681822-6-helgaas@kernel.org
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Dave Airlie <airlied@redhat.com>

commit 6a1274ea0e5dfb2eca85b0175820d7b5183c9cae
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Tue Oct 25 15:38:48 2022 -0500

    agp/ati: Convert to generic power management
    
    Convert agpgart-ati from legacy PCI power management to the generic power
    management framework.
    
    Previously agpgart-ati used legacy PCI power management, and
    agp_ati_suspend() and agp_ati_resume() were responsible for both
    device-specific things and generic PCI things like saving and restoring
    config space and managing power state:
    
      agp_ati_suspend
        pci_save_state                         <-- generic PCI
        pci_set_power_state(PCI_D3hot)         <-- generic PCI
    
      agp_ati_resume
        pci_set_power_state(PCI_D0)            <-- generic PCI
        pci_restore_state                      <-- generic PCI
        ati_configure                          <-- device-specific
    
    With generic power management, the PCI bus PM methods do the generic PCI
    things, and the driver needs only the device-specific part, i.e.,
    
      suspend_devices_and_enter
        dpm_suspend_start(PMSG_SUSPEND)
          pci_pm_suspend                       # PCI bus .suspend() method
            agp_ati_suspend                    <-- not needed at all; removed
        suspend_enter
          dpm_suspend_noirq(PMSG_SUSPEND)
            pci_pm_suspend_noirq               # PCI bus .suspend_noirq() method
              pci_save_state                   <-- generic PCI
              pci_prepare_to_sleep             <-- generic PCI
                pci_set_power_state
        ...
        dpm_resume_end(PMSG_RESUME)
          pci_pm_resume                        # PCI bus .resume() method
            pci_restore_standard_config
              pci_set_power_state(PCI_D0)      <-- generic PCI
              pci_restore_state                <-- generic PCI
            agp_ati_resume                     # driver->pm->resume
              ati_configure                    <-- device-specific
    
    Based on 0aeddbd0cb07 ("via-agp: convert to generic power management") by
    Vaibhav Gupta <vaibhavgupta40@gmail.com>.
    
    Link: https://lore.kernel.org/r/20221025203852.681822-5-helgaas@kernel.org
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Dave Airlie <airlied@redhat.com>

commit c78679d1fe43f9165b11c5ccd3f79c7108b066fe
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Tue Oct 25 15:38:47 2022 -0500

    agp/amd-k7: Convert to generic power management
    
    Convert agpgart-amdk7 from legacy PCI power management to the generic power
    management framework.
    
    Previously agpgart-amdk7 used legacy PCI power management, and
    agp_amdk7_suspend() and agp_amdk7_resume() were responsible for both
    device-specific things and generic PCI things like saving and restoring
    config space and managing power state:
    
      agp_amdk7_suspend
        pci_save_state                         <-- generic PCI
        pci_set_power_state                    <-- generic PCI
    
      agp_amdk7_resume
        pci_set_power_state(PCI_D0)            <-- generic PCI
        pci_restore_state                      <-- generic PCI
        amd_irongate_driver.configure          <-- device-specific
    
    Convert to generic power management where the PCI bus PM methods do the
    generic PCI things, and the driver needs only the device-specific part,
    i.e.,
    
      suspend_devices_and_enter
        dpm_suspend_start(PMSG_SUSPEND)
          pci_pm_suspend                       # PCI bus .suspend() method
            agp_amdk7_suspend                  <-- not needed at all; removed
        suspend_enter
          dpm_suspend_noirq(PMSG_SUSPEND)
            pci_pm_suspend_noirq               # PCI bus .suspend_noirq() method
              pci_save_state                   <-- generic PCI
              pci_prepare_to_sleep             <-- generic PCI
                pci_set_power_state
        ...
        dpm_resume_end(PMSG_RESUME)
          pci_pm_resume                        # PCI bus .resume() method
            pci_restore_standard_config
              pci_set_power_state(PCI_D0)      <-- generic PCI
              pci_restore_state                <-- generic PCI
            agp_amdk7_resume                   # driver->pm->resume
              amd_irongate_driver.configure    <-- device-specific
    
    Based on 0aeddbd0cb07 ("via-agp: convert to generic power management") by
    Vaibhav Gupta <vaibhavgupta40@gmail.com>.
    
    Link: https://lore.kernel.org/r/20221025203852.681822-4-helgaas@kernel.org
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Dave Airlie <airlied@redhat.com>

commit 57d849636a04a12713dd3a10a97cb9658ec7edf6
Author: Kefeng Wang <wangkefeng.wang@huawei.com>
Date:   Wed Oct 12 11:06:35 2022 +0800

    clk: at91: fix the build with binutils 2.27
    
    There is an issue when build with older versions of binutils 2.27.0,
    
    arch/arm/mach-at91/pm_suspend.S: Assembler messages:
    arch/arm/mach-at91/pm_suspend.S:1086: Error: garbage following instruction -- `ldr tmp1,=0x00020010UL'
    
    Use UL() macro to fix the issue in assembly file.
    
    Fixes: 4fd36e458392 ("ARM: at91: pm: add plla disable/enable support for sam9x60")
    Signed-off-by: Kefeng Wang <wangkefeng.wang@huawei.com>
    Link: https://lore.kernel.org/r/20221012030635.13140-1-wangkefeng.wang@huawei.com
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

commit 034f93fcb12f579c0108c7e2ca2d17ec4e5170aa
Merge: 519e512110e4 3e347969a577
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Oct 5 17:32:53 2022 -0500

    Merge branch 'pci/pm'
    
    - Cache the PTM capability offset instead of searching for it every time
      (Bjorn Helgaas)
    
    - Separate PTM configuration from PTM enable (Bjorn Helgaas)
    
    - Add pci_suspend_ptm() and pci_resume_ptm() to disable and re-enable PTM
      on suspend/resume so some Root Ports can safely enter a lower-power PM
      state (Bjorn Helgaas)
    
    - Disable PTM for all devices during suspend; previously we only did this
      for Root Ports and even then only in certain cases (Bjorn Helgaas)
    
    - Simplify pci_pm_suspend_noirq() (Rajvi Jingar)
    
    - Reduce the delay after transitions to/from D3hot by using usleep_range()
      instead of msleep(), which reduces the typical delay from 19ms to 10ms
      (Sajid Dalvi, Will McVicker)
    
    * pci/pm:
      PCI/PM: Reduce D3hot delay with usleep_range()
      PCI/PM: Simplify pci_pm_suspend_noirq()
      PCI/PM: Always disable PTM for all devices during suspend
      PCI/PTM: Consolidate PTM interface declarations
      PCI/PTM: Reorder functions in logical order
      PCI/PTM: Preserve RsvdP bits in PTM Control register
      PCI/PTM: Move pci_ptm_info() body into its only caller
      PCI/PTM: Add pci_suspend_ptm() and pci_resume_ptm()
      PCI/PTM: Separate configuration and enable
      PCI/PTM: Add pci_upstream_ptm() helper
      PCI/PTM: Cache PTM Capability offset

commit 4c00cba122f3f3ae54aa5a3a1aec3afc7a2e6f94
Author: Rajvi Jingar <rajvi.jingar@linux.intel.com>
Date:   Tue Aug 30 03:49:12 2022 -0700

    PCI/PM: Simplify pci_pm_suspend_noirq()
    
    We always want to save the device state unless the driver has already done
    it.  Rearrange the checking in pci_pm_suspend_noirq() to make this more
    clear.  No functional change intended.
    
    [bhelgaas: commit log, rewrap comment]
    Link: https://lore.kernel.org/r/20220830104913.1620539-1-rajvi.jingar@linux.intel.com
    Signed-off-by: Rajvi Jingar <rajvi.jingar@linux.intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit c01163dbd1b8aa016c163ff4bf3a2e90311504f1
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Sep 9 15:25:05 2022 -0500

    PCI/PM: Always disable PTM for all devices during suspend
    
    We want to disable PTM on Root Ports because that allows some chips, e.g.,
    Intel mobile chips since Coffee Lake, to enter a lower-power PM state.
    
    That means we also have to disable PTM on downstream devices.  PCIe r6.0,
    sec 2.2.8, recommends that functions support generation of messages in
    non-D0 states, so we have to assume Switch Upstream Ports or Endpoints may
    send PTM Requests while in D1, D2, and D3hot.  A PTM message received by a
    Downstream Port (including a Root Port) with PTM disabled must be treated
    as an Unsupported Request (sec 6.21.3).
    
    PTM was previously disabled only for Root Ports, and it was disabled in
    pci_prepare_to_sleep(), which is not called at all if a driver supports
    legacy PM or does its own state saving.
    
    Instead, disable PTM early in pci_pm_suspend() and pci_pm_runtime_suspend()
    so we do it in all cases.
    
    Previously PTM was disabled *after* saving device state, so the state
    restore on resume automatically re-enabled it.  Since we now disable PTM
    *before* saving state, we must explicitly re-enable it in pci_pm_resume()
    and pci_pm_runtime_resume().
    
    Here's a sample of errors that occur when PTM is disabled only on the Root
    Port.  With this topology:
    
      0000:00:1d.0 Root Port            to [bus 08-71]
      0000:08:00.0 Switch Upstream Port to [bus 09-71]
    
    Kai-Heng reported errors like this:
    
      pcieport 0000:00:1d.0:    [20] UnsupReq               (First)
      pcieport 0000:00:1d.0: AER:   TLP Header: 34000000 08000052 00000000 00000000
    
    Decoding TLP header 0x34...... (0011 0100b) and 0x08000052:
    
      Fmt                         001b  4 DW header, no data
      Type                     1 0100b  Msg (Local - Terminate at Receiver)
      Requester ID  0x0800              Bus 08 Devfn 00.0
      Message Code    0x52  0101 0010b  PTM Request
    
    The 00:1d.0 Root Port logged an Unsupported Request error when it received
    a PTM Request with Requester ID 08:00.0.
    
    Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=215453
    Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=216210
    Fixes: a697f072f5da ("PCI: Disable PTM during suspend to save power")
    Link: https://lore.kernel.org/r/20220909202505.314195-10-helgaas@kernel.org
    Reported-by: Kai-Heng Feng <kai.heng.feng@canonical.com>
    Tested-by: Rajvi Jingar <rajvi.jingar@linux.intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>

commit fee6073051c394dbec21d7024d90e31e0ff3f678
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Aug 25 20:47:28 2022 +0200

    ata: ahci: Do not check ACPI_FADT_LOW_POWER_S0
    
    The ACPI_FADT_LOW_POWER_S0 flag merely means that it is better to
    use low-power S0 idle on the given platform than S3 (provided that
    the latter is supported) and it doesn't preclude using either of
    them (which of them will be used depends on the choices made by user
    space).
    
    For this reason, there is no benefit from checking that flag in
    ahci_update_initial_lpm_policy().
    
    First off, it cannot be a bug to do S3 with policy set to either
    ATA_LPM_MIN_POWER_WITH_PARTIAL or ATA_LPM_MIN_POWER, because S3 can be
    used on systems with ACPI_FADT_LOW_POWER_S0 set and it must work if
    really supported, so the ACPI_FADT_LOW_POWER_S0 check is not needed to
    protect the S3-capable systems from failing.
    
    Second, suspend-to-idle can be carried out on a system with
    ACPI_FADT_LOW_POWER_S0 unset and it is expected to work, so if setting
    policy to either ATA_LPM_MIN_POWER_WITH_PARTIAL or ATA_LPM_MIN_POWER is
    needed to handle that case correctly, it should be done regardless of
    the ACPI_FADT_LOW_POWER_S0 value.
    
    Accordingly, replace the ACPI_FADT_LOW_POWER_S0 check in
    ahci_update_initial_lpm_policy() with pm_suspend_default_s2idle()
    which is more general and also takes the user's preference into
    account and drop the CONFIG_ACPI #ifdef around it that is not necessary
    any more.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Mario Limonciello <mario.limonciello@amd.com>
    Signed-off-by: Damien Le Moal <damien.lemoal@opensource.wdc.com>

commit 23bf155476539354ab5c8cc9bb460fd1209b39b5
Author: Chia-Lin Kao (AceLan) <acelan.kao@canonical.com>
Date:   Mon Aug 8 16:18:45 2022 +0800

    net: atlantic: fix aq_vec index out of range error
    
    commit 2ba5e47fb75fbb8fab45f5c1bc8d5c33d8834bd3 upstream.
    
    The final update statement of the for loop exceeds the array range, the
    dereference of self->aq_vec[i] is not checked and then leads to the
    index out of range error.
    Also fixed this kind of coding style in other for loop.
    
    [   97.937604] UBSAN: array-index-out-of-bounds in drivers/net/ethernet/aquantia/atlantic/aq_nic.c:1404:48
    [   97.937607] index 8 is out of range for type 'aq_vec_s *[8]'
    [   97.937608] CPU: 38 PID: 3767 Comm: kworker/u256:18 Not tainted 5.19.0+ #2
    [   97.937610] Hardware name: Dell Inc. Precision 7865 Tower/, BIOS 1.0.0 06/12/2022
    [   97.937611] Workqueue: events_unbound async_run_entry_fn
    [   97.937616] Call Trace:
    [   97.937617]  <TASK>
    [   97.937619]  dump_stack_lvl+0x49/0x63
    [   97.937624]  dump_stack+0x10/0x16
    [   97.937626]  ubsan_epilogue+0x9/0x3f
    [   97.937627]  __ubsan_handle_out_of_bounds.cold+0x44/0x49
    [   97.937629]  ? __scm_send+0x348/0x440
    [   97.937632]  ? aq_vec_stop+0x72/0x80 [atlantic]
    [   97.937639]  aq_nic_stop+0x1b6/0x1c0 [atlantic]
    [   97.937644]  aq_suspend_common+0x88/0x90 [atlantic]
    [   97.937648]  aq_pm_suspend_poweroff+0xe/0x20 [atlantic]
    [   97.937653]  pci_pm_suspend+0x7e/0x1a0
    [   97.937655]  ? pci_pm_suspend_noirq+0x2b0/0x2b0
    [   97.937657]  dpm_run_callback+0x54/0x190
    [   97.937660]  __device_suspend+0x14c/0x4d0
    [   97.937661]  async_suspend+0x23/0x70
    [   97.937663]  async_run_entry_fn+0x33/0x120
    [   97.937664]  process_one_work+0x21f/0x3f0
    [   97.937666]  worker_thread+0x4a/0x3c0
    [   97.937668]  ? process_one_work+0x3f0/0x3f0
    [   97.937669]  kthread+0xf0/0x120
    [   97.937671]  ? kthread_complete_and_exit+0x20/0x20
    [   97.937672]  ret_from_fork+0x22/0x30
    [   97.937676]  </TASK>
    
    v2. fixed "warning: variable 'aq_vec' set but not used"
    
    v3. simplified a for loop
    
    Fixes: 97bde5c4f909 ("net: ethernet: aquantia: Support for NIC-specific code")
    Signed-off-by: Chia-Lin Kao (AceLan) <acelan.kao@canonical.com>
    Acked-by: Sudarsana Reddy Kalluru <skalluru@marvell.com>
    Link: https://lore.kernel.org/r/20220808081845.42005-1-acelan.kao@canonical.com
    Signed-off-by: Jakub Kicinski <kuba@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 9bd970d4097287778a4449452e70b35d0bfaa3aa
Author: Arunpravin Paneer Selvam <Arunpravin.PaneerSelvam@amd.com>
Date:   Tue Aug 9 02:56:23 2022 -0700

    drm/ttm: Fix dummy res NULL ptr deref bug
    
    commit cf4b7387c0a842d64bdd7c353e6d3298174a7740 upstream.
    
    Check the bo->resource value before accessing the resource
    mem_type.
    
    v2: Fix commit description unwrapped warning
    
    <log snip>
    [   40.191227][  T184] general protection fault, probably for non-canonical address 0xdffffc0000000002: 0000 [#1] SMP KASAN PTI
    [   40.192995][  T184] KASAN: null-ptr-deref in range [0x0000000000000010-0x0000000000000017]
    [   40.194411][  T184] CPU: 1 PID: 184 Comm: systemd-udevd Not tainted 5.19.0-rc4-00721-gb297c22b7070 #1
    [   40.196063][  T184] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.0-debian-1.16.0-4 04/01/2014
    [   40.199605][  T184] RIP: 0010:ttm_bo_validate+0x1b3/0x240 [ttm]
    [   40.200754][  T184] Code: e8 72 c5 ff ff 83 f8 b8 74 d4 85 c0 75 54 49 8b 9e 58 01 00 00 48 b8 00 00 00 00 00 fc ff df 48 8d 7b 10 48 89 fa 48 c1 ea 03 <0f> b6 04 02 84 c0 74 04 3c 03 7e 44 8b 53 10 31 c0 85 d2 0f 85 58
    [   40.203685][  T184] RSP: 0018:ffffc900006df0c8 EFLAGS: 00010202
    [   40.204630][  T184] RAX: dffffc0000000000 RBX: 0000000000000000 RCX: 1ffff1102f4bb71b
    [   40.205864][  T184] RDX: 0000000000000002 RSI: ffffc900006df208 RDI: 0000000000000010
    [   40.207102][  T184] RBP: 1ffff920000dbe1a R08: ffffc900006df208 R09: 0000000000000000
    [   40.208394][  T184] R10: ffff88817a5f0000 R11: 0000000000000001 R12: ffffc900006df110
    [   40.209692][  T184] R13: ffffc900006df0f0 R14: ffff88817a5db800 R15: ffffc900006df208
    [   40.210862][  T184] FS:  00007f6b1d16e8c0(0000) GS:ffff88839d700000(0000) knlGS:0000000000000000
    [   40.212250][  T184] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [   40.213275][  T184] CR2: 000055a1001d4ff0 CR3: 00000001700f4000 CR4: 00000000000006e0
    [   40.214469][  T184] Call Trace:
    [   40.214974][  T184]  <TASK>
    [   40.215438][  T184]  ? ttm_bo_bounce_temp_buffer+0x140/0x140 [ttm]
    [   40.216572][  T184]  ? mutex_spin_on_owner+0x240/0x240
    [   40.217456][  T184]  ? drm_vma_offset_add+0xaa/0x100 [drm]
    [   40.218457][  T184]  ttm_bo_init_reserved+0x3d6/0x540 [ttm]
    [   40.219410][  T184]  ? shmem_get_inode+0x744/0x980
    [   40.220231][  T184]  ttm_bo_init_validate+0xb1/0x200 [ttm]
    [   40.221172][  T184]  ? bo_driver_evict_flags+0x340/0x340 [drm_vram_helper]
    [   40.222530][  T184]  ? ttm_bo_init_reserved+0x540/0x540 [ttm]
    [   40.223643][  T184]  ? __do_sys_finit_module+0x11a/0x1c0
    [   40.224654][  T184]  ? __shmem_file_setup+0x102/0x280
    [   40.234764][  T184]  drm_gem_vram_create+0x305/0x480 [drm_vram_helper]
    [   40.235766][  T184]  ? bo_driver_evict_flags+0x340/0x340 [drm_vram_helper]
    [   40.236846][  T184]  ? __kasan_slab_free+0x108/0x180
    [   40.237650][  T184]  drm_gem_vram_fill_create_dumb+0x134/0x340 [drm_vram_helper]
    [   40.238864][  T184]  ? local_pci_probe+0xdf/0x180
    [   40.239674][  T184]  ? drmm_vram_helper_init+0x400/0x400 [drm_vram_helper]
    [   40.240826][  T184]  drm_client_framebuffer_create+0x19c/0x400 [drm]
    [   40.241955][  T184]  ? drm_client_buffer_delete+0x200/0x200 [drm]
    [   40.243001][  T184]  ? drm_client_pick_crtcs+0x554/0xb80 [drm]
    [   40.244030][  T184]  drm_fb_helper_generic_probe+0x23f/0x940 [drm_kms_helper]
    [   40.245226][  T184]  ? __cond_resched+0x1c/0xc0
    [   40.245987][  T184]  ? drm_fb_helper_memory_range_to_clip+0x180/0x180 [drm_kms_helper]
    [   40.247316][  T184]  ? mutex_unlock+0x80/0x100
    [   40.248005][  T184]  ? __mutex_unlock_slowpath+0x2c0/0x2c0
    [   40.249083][  T184]  drm_fb_helper_single_fb_probe+0x907/0xf00 [drm_kms_helper]
    [   40.250314][  T184]  ? drm_fb_helper_check_var+0x1180/0x1180 [drm_kms_helper]
    [   40.251540][  T184]  ? __cond_resched+0x1c/0xc0
    [   40.252321][  T184]  ? mutex_lock+0x9f/0x100
    [   40.253062][  T184]  __drm_fb_helper_initial_config_and_unlock+0xb9/0x2c0 [drm_kms_helper]
    [   40.254394][  T184]  drm_fbdev_client_hotplug+0x56f/0x840 [drm_kms_helper]
    [   40.255477][  T184]  drm_fbdev_generic_setup+0x165/0x3c0 [drm_kms_helper]
    [   40.256607][  T184]  bochs_pci_probe+0x6b7/0x900 [bochs]
    [   40.257515][  T184]  ? _raw_spin_lock_irqsave+0x87/0x100
    [   40.258312][  T184]  ? bochs_hw_init+0x480/0x480 [bochs]
    [   40.259244][  T184]  ? bochs_hw_init+0x480/0x480 [bochs]
    [   40.260186][  T184]  local_pci_probe+0xdf/0x180
    [   40.260928][  T184]  pci_call_probe+0x15f/0x500
    [   40.265798][  T184]  ? _raw_spin_lock+0x81/0x100
    [   40.266508][  T184]  ? pci_pm_suspend_noirq+0x980/0x980
    [   40.267322][  T184]  ? pci_assign_irq+0x81/0x280
    [   40.268096][  T184]  ? pci_match_device+0x351/0x6c0
    [   40.268883][  T184]  ? kernfs_put+0x18/0x40
    [   40.269611][  T184]  pci_device_probe+0xee/0x240
    [   40.270352][  T184]  really_probe+0x435/0xa80
    [   40.271021][  T184]  __driver_probe_device+0x2ab/0x480
    [   40.271828][  T184]  driver_probe_device+0x49/0x140
    [   40.272627][  T184]  __driver_attach+0x1bd/0x4c0
    [   40.273372][  T184]  ? __device_attach_driver+0x240/0x240
    [   40.274273][  T184]  bus_for_each_dev+0x11e/0x1c0
    [   40.275080][  T184]  ? subsys_dev_iter_exit+0x40/0x40
    [   40.275951][  T184]  ? klist_add_tail+0x132/0x280
    [   40.276767][  T184]  bus_add_driver+0x39b/0x580
    [   40.277574][  T184]  driver_register+0x20f/0x3c0
    [   40.278281][  T184]  ? 0xffffffffc04a2000
    [   40.278894][  T184]  do_one_initcall+0x8a/0x300
    [   40.279642][  T184]  ? trace_event_raw_event_initcall_level+0x1c0/0x1c0
    [   40.280707][  T184]  ? kasan_unpoison+0x23/0x80
    [   40.281479][  T184]  ? kasan_unpoison+0x23/0x80
    [   40.282197][  T184]  do_init_module+0x190/0x640
    [   40.282926][  T184]  load_module+0x221b/0x2780
    [   40.283611][  T184]  ? layout_and_allocate+0x5c0/0x5c0
    [   40.284401][  T184]  ? kernel_read_file+0x286/0x6c0
    [   40.285216][  T184]  ? __x64_sys_fspick+0x2c0/0x2c0
    [   40.286043][  T184]  ? mmap_region+0x4e7/0x1300
    [   40.286832][  T184]  ? __do_sys_finit_module+0x11a/0x1c0
    [   40.287743][  T184]  __do_sys_finit_module+0x11a/0x1c0
    [   40.288636][  T184]  ? __ia32_sys_init_module+0xc0/0xc0
    [   40.289557][  T184]  ? __seccomp_filter+0x15e/0xc80
    [   40.290341][  T184]  ? vm_mmap_pgoff+0x185/0x240
    [   40.291060][  T184]  do_syscall_64+0x3b/0xc0
    [   40.291763][  T184]  entry_SYSCALL_64_after_hwframe+0x46/0xb0
    [   40.292678][  T184] RIP: 0033:0x7f6b1d6279b9
    [   40.293438][  T184] Code: 00 c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 44 00 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 8b 0d a7 54 0c 00 f7 d8 64 89 01 48
    [   40.296302][  T184] RSP: 002b:00007ffe7f51b798 EFLAGS: 00000246 ORIG_RAX: 0000000000000139
    [   40.297633][  T184] RAX: ffffffffffffffda RBX: 00005642dcca2880 RCX: 00007f6b1d6279b9
    [   40.298890][  T184] RDX: 0000000000000000 RSI: 00007f6b1d7b2e2d RDI: 0000000000000016
    [   40.300199][  T184] RBP: 0000000000020000 R08: 0000000000000000 R09: 00005642dccd5530
    [   40.301547][  T184] R10: 0000000000000016 R11: 0000000000000246 R12: 00007f6b1d7b2e2d
    [   40.302698][  T184] R13: 0000000000000000 R14: 00005642dcca4230 R15: 00005642dcca2880
    
    Signed-off-by: Arunpravin Paneer Selvam <Arunpravin.PaneerSelvam@amd.com>
    Reported-by: kernel test robot <oliver.sang@intel.com>
    Reviewed-by: Christian König <christian.koenig@amd.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20220726162205.2778-1-Arunpravin.PaneerSelvam@amd.com
    Link: https://patchwork.freedesktop.org/patch/msgid/20220809095623.3569-1-Arunpravin.PaneerSelvam@amd.com
    Signed-off-by: Christian König <christian.koenig@amd.com>
    CC: stable@vger.kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 422a02a771599cac96f2b2900d993e0bb7ba5b88
Author: Chia-Lin Kao (AceLan) <acelan.kao@canonical.com>
Date:   Mon Aug 8 16:18:45 2022 +0800

    net: atlantic: fix aq_vec index out of range error
    
    commit 2ba5e47fb75fbb8fab45f5c1bc8d5c33d8834bd3 upstream.
    
    The final update statement of the for loop exceeds the array range, the
    dereference of self->aq_vec[i] is not checked and then leads to the
    index out of range error.
    Also fixed this kind of coding style in other for loop.
    
    [   97.937604] UBSAN: array-index-out-of-bounds in drivers/net/ethernet/aquantia/atlantic/aq_nic.c:1404:48
    [   97.937607] index 8 is out of range for type 'aq_vec_s *[8]'
    [   97.937608] CPU: 38 PID: 3767 Comm: kworker/u256:18 Not tainted 5.19.0+ #2
    [   97.937610] Hardware name: Dell Inc. Precision 7865 Tower/, BIOS 1.0.0 06/12/2022
    [   97.937611] Workqueue: events_unbound async_run_entry_fn
    [   97.937616] Call Trace:
    [   97.937617]  <TASK>
    [   97.937619]  dump_stack_lvl+0x49/0x63
    [   97.937624]  dump_stack+0x10/0x16
    [   97.937626]  ubsan_epilogue+0x9/0x3f
    [   97.937627]  __ubsan_handle_out_of_bounds.cold+0x44/0x49
    [   97.937629]  ? __scm_send+0x348/0x440
    [   97.937632]  ? aq_vec_stop+0x72/0x80 [atlantic]
    [   97.937639]  aq_nic_stop+0x1b6/0x1c0 [atlantic]
    [   97.937644]  aq_suspend_common+0x88/0x90 [atlantic]
    [   97.937648]  aq_pm_suspend_poweroff+0xe/0x20 [atlantic]
    [   97.937653]  pci_pm_suspend+0x7e/0x1a0
    [   97.937655]  ? pci_pm_suspend_noirq+0x2b0/0x2b0
    [   97.937657]  dpm_run_callback+0x54/0x190
    [   97.937660]  __device_suspend+0x14c/0x4d0
    [   97.937661]  async_suspend+0x23/0x70
    [   97.937663]  async_run_entry_fn+0x33/0x120
    [   97.937664]  process_one_work+0x21f/0x3f0
    [   97.937666]  worker_thread+0x4a/0x3c0
    [   97.937668]  ? process_one_work+0x3f0/0x3f0
    [   97.937669]  kthread+0xf0/0x120
    [   97.937671]  ? kthread_complete_and_exit+0x20/0x20
    [   97.937672]  ret_from_fork+0x22/0x30
    [   97.937676]  </TASK>
    
    v2. fixed "warning: variable 'aq_vec' set but not used"
    
    v3. simplified a for loop
    
    Fixes: 97bde5c4f909 ("net: ethernet: aquantia: Support for NIC-specific code")
    Signed-off-by: Chia-Lin Kao (AceLan) <acelan.kao@canonical.com>
    Acked-by: Sudarsana Reddy Kalluru <skalluru@marvell.com>
    Link: https://lore.kernel.org/r/20220808081845.42005-1-acelan.kao@canonical.com
    Signed-off-by: Jakub Kicinski <kuba@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 76672cd326c146ded2c2712ff257b8908dcf23d8
Author: Arunpravin Paneer Selvam <Arunpravin.PaneerSelvam@amd.com>
Date:   Tue Aug 9 02:56:23 2022 -0700

    drm/ttm: Fix dummy res NULL ptr deref bug
    
    commit cf4b7387c0a842d64bdd7c353e6d3298174a7740 upstream.
    
    Check the bo->resource value before accessing the resource
    mem_type.
    
    v2: Fix commit description unwrapped warning
    
    <log snip>
    [   40.191227][  T184] general protection fault, probably for non-canonical address 0xdffffc0000000002: 0000 [#1] SMP KASAN PTI
    [   40.192995][  T184] KASAN: null-ptr-deref in range [0x0000000000000010-0x0000000000000017]
    [   40.194411][  T184] CPU: 1 PID: 184 Comm: systemd-udevd Not tainted 5.19.0-rc4-00721-gb297c22b7070 #1
    [   40.196063][  T184] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.0-debian-1.16.0-4 04/01/2014
    [   40.199605][  T184] RIP: 0010:ttm_bo_validate+0x1b3/0x240 [ttm]
    [   40.200754][  T184] Code: e8 72 c5 ff ff 83 f8 b8 74 d4 85 c0 75 54 49 8b 9e 58 01 00 00 48 b8 00 00 00 00 00 fc ff df 48 8d 7b 10 48 89 fa 48 c1 ea 03 <0f> b6 04 02 84 c0 74 04 3c 03 7e 44 8b 53 10 31 c0 85 d2 0f 85 58
    [   40.203685][  T184] RSP: 0018:ffffc900006df0c8 EFLAGS: 00010202
    [   40.204630][  T184] RAX: dffffc0000000000 RBX: 0000000000000000 RCX: 1ffff1102f4bb71b
    [   40.205864][  T184] RDX: 0000000000000002 RSI: ffffc900006df208 RDI: 0000000000000010
    [   40.207102][  T184] RBP: 1ffff920000dbe1a R08: ffffc900006df208 R09: 0000000000000000
    [   40.208394][  T184] R10: ffff88817a5f0000 R11: 0000000000000001 R12: ffffc900006df110
    [   40.209692][  T184] R13: ffffc900006df0f0 R14: ffff88817a5db800 R15: ffffc900006df208
    [   40.210862][  T184] FS:  00007f6b1d16e8c0(0000) GS:ffff88839d700000(0000) knlGS:0000000000000000
    [   40.212250][  T184] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [   40.213275][  T184] CR2: 000055a1001d4ff0 CR3: 00000001700f4000 CR4: 00000000000006e0
    [   40.214469][  T184] Call Trace:
    [   40.214974][  T184]  <TASK>
    [   40.215438][  T184]  ? ttm_bo_bounce_temp_buffer+0x140/0x140 [ttm]
    [   40.216572][  T184]  ? mutex_spin_on_owner+0x240/0x240
    [   40.217456][  T184]  ? drm_vma_offset_add+0xaa/0x100 [drm]
    [   40.218457][  T184]  ttm_bo_init_reserved+0x3d6/0x540 [ttm]
    [   40.219410][  T184]  ? shmem_get_inode+0x744/0x980
    [   40.220231][  T184]  ttm_bo_init_validate+0xb1/0x200 [ttm]
    [   40.221172][  T184]  ? bo_driver_evict_flags+0x340/0x340 [drm_vram_helper]
    [   40.222530][  T184]  ? ttm_bo_init_reserved+0x540/0x540 [ttm]
    [   40.223643][  T184]  ? __do_sys_finit_module+0x11a/0x1c0
    [   40.224654][  T184]  ? __shmem_file_setup+0x102/0x280
    [   40.234764][  T184]  drm_gem_vram_create+0x305/0x480 [drm_vram_helper]
    [   40.235766][  T184]  ? bo_driver_evict_flags+0x340/0x340 [drm_vram_helper]
    [   40.236846][  T184]  ? __kasan_slab_free+0x108/0x180
    [   40.237650][  T184]  drm_gem_vram_fill_create_dumb+0x134/0x340 [drm_vram_helper]
    [   40.238864][  T184]  ? local_pci_probe+0xdf/0x180
    [   40.239674][  T184]  ? drmm_vram_helper_init+0x400/0x400 [drm_vram_helper]
    [   40.240826][  T184]  drm_client_framebuffer_create+0x19c/0x400 [drm]
    [   40.241955][  T184]  ? drm_client_buffer_delete+0x200/0x200 [drm]
    [   40.243001][  T184]  ? drm_client_pick_crtcs+0x554/0xb80 [drm]
    [   40.244030][  T184]  drm_fb_helper_generic_probe+0x23f/0x940 [drm_kms_helper]
    [   40.245226][  T184]  ? __cond_resched+0x1c/0xc0
    [   40.245987][  T184]  ? drm_fb_helper_memory_range_to_clip+0x180/0x180 [drm_kms_helper]
    [   40.247316][  T184]  ? mutex_unlock+0x80/0x100
    [   40.248005][  T184]  ? __mutex_unlock_slowpath+0x2c0/0x2c0
    [   40.249083][  T184]  drm_fb_helper_single_fb_probe+0x907/0xf00 [drm_kms_helper]
    [   40.250314][  T184]  ? drm_fb_helper_check_var+0x1180/0x1180 [drm_kms_helper]
    [   40.251540][  T184]  ? __cond_resched+0x1c/0xc0
    [   40.252321][  T184]  ? mutex_lock+0x9f/0x100
    [   40.253062][  T184]  __drm_fb_helper_initial_config_and_unlock+0xb9/0x2c0 [drm_kms_helper]
    [   40.254394][  T184]  drm_fbdev_client_hotplug+0x56f/0x840 [drm_kms_helper]
    [   40.255477][  T184]  drm_fbdev_generic_setup+0x165/0x3c0 [drm_kms_helper]
    [   40.256607][  T184]  bochs_pci_probe+0x6b7/0x900 [bochs]
    [   40.257515][  T184]  ? _raw_spin_lock_irqsave+0x87/0x100
    [   40.258312][  T184]  ? bochs_hw_init+0x480/0x480 [bochs]
    [   40.259244][  T184]  ? bochs_hw_init+0x480/0x480 [bochs]
    [   40.260186][  T184]  local_pci_probe+0xdf/0x180
    [   40.260928][  T184]  pci_call_probe+0x15f/0x500
    [   40.265798][  T184]  ? _raw_spin_lock+0x81/0x100
    [   40.266508][  T184]  ? pci_pm_suspend_noirq+0x980/0x980
    [   40.267322][  T184]  ? pci_assign_irq+0x81/0x280
    [   40.268096][  T184]  ? pci_match_device+0x351/0x6c0
    [   40.268883][  T184]  ? kernfs_put+0x18/0x40
    [   40.269611][  T184]  pci_device_probe+0xee/0x240
    [   40.270352][  T184]  really_probe+0x435/0xa80
    [   40.271021][  T184]  __driver_probe_device+0x2ab/0x480
    [   40.271828][  T184]  driver_probe_device+0x49/0x140
    [   40.272627][  T184]  __driver_attach+0x1bd/0x4c0
    [   40.273372][  T184]  ? __device_attach_driver+0x240/0x240
    [   40.274273][  T184]  bus_for_each_dev+0x11e/0x1c0
    [   40.275080][  T184]  ? subsys_dev_iter_exit+0x40/0x40
    [   40.275951][  T184]  ? klist_add_tail+0x132/0x280
    [   40.276767][  T184]  bus_add_driver+0x39b/0x580
    [   40.277574][  T184]  driver_register+0x20f/0x3c0
    [   40.278281][  T184]  ? 0xffffffffc04a2000
    [   40.278894][  T184]  do_one_initcall+0x8a/0x300
    [   40.279642][  T184]  ? trace_event_raw_event_initcall_level+0x1c0/0x1c0
    [   40.280707][  T184]  ? kasan_unpoison+0x23/0x80
    [   40.281479][  T184]  ? kasan_unpoison+0x23/0x80
    [   40.282197][  T184]  do_init_module+0x190/0x640
    [   40.282926][  T184]  load_module+0x221b/0x2780
    [   40.283611][  T184]  ? layout_and_allocate+0x5c0/0x5c0
    [   40.284401][  T184]  ? kernel_read_file+0x286/0x6c0
    [   40.285216][  T184]  ? __x64_sys_fspick+0x2c0/0x2c0
    [   40.286043][  T184]  ? mmap_region+0x4e7/0x1300
    [   40.286832][  T184]  ? __do_sys_finit_module+0x11a/0x1c0
    [   40.287743][  T184]  __do_sys_finit_module+0x11a/0x1c0
    [   40.288636][  T184]  ? __ia32_sys_init_module+0xc0/0xc0
    [   40.289557][  T184]  ? __seccomp_filter+0x15e/0xc80
    [   40.290341][  T184]  ? vm_mmap_pgoff+0x185/0x240
    [   40.291060][  T184]  do_syscall_64+0x3b/0xc0
    [   40.291763][  T184]  entry_SYSCALL_64_after_hwframe+0x46/0xb0
    [   40.292678][  T184] RIP: 0033:0x7f6b1d6279b9
    [   40.293438][  T184] Code: 00 c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 44 00 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 8b 0d a7 54 0c 00 f7 d8 64 89 01 48
    [   40.296302][  T184] RSP: 002b:00007ffe7f51b798 EFLAGS: 00000246 ORIG_RAX: 0000000000000139
    [   40.297633][  T184] RAX: ffffffffffffffda RBX: 00005642dcca2880 RCX: 00007f6b1d6279b9
    [   40.298890][  T184] RDX: 0000000000000000 RSI: 00007f6b1d7b2e2d RDI: 0000000000000016
    [   40.300199][  T184] RBP: 0000000000020000 R08: 0000000000000000 R09: 00005642dccd5530
    [   40.301547][  T184] R10: 0000000000000016 R11: 0000000000000246 R12: 00007f6b1d7b2e2d
    [   40.302698][  T184] R13: 0000000000000000 R14: 00005642dcca4230 R15: 00005642dcca2880
    
    Signed-off-by: Arunpravin Paneer Selvam <Arunpravin.PaneerSelvam@amd.com>
    Reported-by: kernel test robot <oliver.sang@intel.com>
    Reviewed-by: Christian König <christian.koenig@amd.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20220726162205.2778-1-Arunpravin.PaneerSelvam@amd.com
    Link: https://patchwork.freedesktop.org/patch/msgid/20220809095623.3569-1-Arunpravin.PaneerSelvam@amd.com
    Signed-off-by: Christian König <christian.koenig@amd.com>
    CC: stable@vger.kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit df60c534d4c5a681172952dd4b475a5d818b3a86
Author: Chia-Lin Kao (AceLan) <acelan.kao@canonical.com>
Date:   Mon Aug 8 16:18:45 2022 +0800

    net: atlantic: fix aq_vec index out of range error
    
    commit 2ba5e47fb75fbb8fab45f5c1bc8d5c33d8834bd3 upstream.
    
    The final update statement of the for loop exceeds the array range, the
    dereference of self->aq_vec[i] is not checked and then leads to the
    index out of range error.
    Also fixed this kind of coding style in other for loop.
    
    [   97.937604] UBSAN: array-index-out-of-bounds in drivers/net/ethernet/aquantia/atlantic/aq_nic.c:1404:48
    [   97.937607] index 8 is out of range for type 'aq_vec_s *[8]'
    [   97.937608] CPU: 38 PID: 3767 Comm: kworker/u256:18 Not tainted 5.19.0+ #2
    [   97.937610] Hardware name: Dell Inc. Precision 7865 Tower/, BIOS 1.0.0 06/12/2022
    [   97.937611] Workqueue: events_unbound async_run_entry_fn
    [   97.937616] Call Trace:
    [   97.937617]  <TASK>
    [   97.937619]  dump_stack_lvl+0x49/0x63
    [   97.937624]  dump_stack+0x10/0x16
    [   97.937626]  ubsan_epilogue+0x9/0x3f
    [   97.937627]  __ubsan_handle_out_of_bounds.cold+0x44/0x49
    [   97.937629]  ? __scm_send+0x348/0x440
    [   97.937632]  ? aq_vec_stop+0x72/0x80 [atlantic]
    [   97.937639]  aq_nic_stop+0x1b6/0x1c0 [atlantic]
    [   97.937644]  aq_suspend_common+0x88/0x90 [atlantic]
    [   97.937648]  aq_pm_suspend_poweroff+0xe/0x20 [atlantic]
    [   97.937653]  pci_pm_suspend+0x7e/0x1a0
    [   97.937655]  ? pci_pm_suspend_noirq+0x2b0/0x2b0
    [   97.937657]  dpm_run_callback+0x54/0x190
    [   97.937660]  __device_suspend+0x14c/0x4d0
    [   97.937661]  async_suspend+0x23/0x70
    [   97.937663]  async_run_entry_fn+0x33/0x120
    [   97.937664]  process_one_work+0x21f/0x3f0
    [   97.937666]  worker_thread+0x4a/0x3c0
    [   97.937668]  ? process_one_work+0x3f0/0x3f0
    [   97.937669]  kthread+0xf0/0x120
    [   97.937671]  ? kthread_complete_and_exit+0x20/0x20
    [   97.937672]  ret_from_fork+0x22/0x30
    [   97.937676]  </TASK>
    
    v2. fixed "warning: variable 'aq_vec' set but not used"
    
    v3. simplified a for loop
    
    Fixes: 97bde5c4f909 ("net: ethernet: aquantia: Support for NIC-specific code")
    Signed-off-by: Chia-Lin Kao (AceLan) <acelan.kao@canonical.com>
    Acked-by: Sudarsana Reddy Kalluru <skalluru@marvell.com>
    Link: https://lore.kernel.org/r/20220808081845.42005-1-acelan.kao@canonical.com
    Signed-off-by: Jakub Kicinski <kuba@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 2ba5e47fb75fbb8fab45f5c1bc8d5c33d8834bd3
Author: Chia-Lin Kao (AceLan) <acelan.kao@canonical.com>
Date:   Mon Aug 8 16:18:45 2022 +0800

    net: atlantic: fix aq_vec index out of range error
    
    The final update statement of the for loop exceeds the array range, the
    dereference of self->aq_vec[i] is not checked and then leads to the
    index out of range error.
    Also fixed this kind of coding style in other for loop.
    
    [   97.937604] UBSAN: array-index-out-of-bounds in drivers/net/ethernet/aquantia/atlantic/aq_nic.c:1404:48
    [   97.937607] index 8 is out of range for type 'aq_vec_s *[8]'
    [   97.937608] CPU: 38 PID: 3767 Comm: kworker/u256:18 Not tainted 5.19.0+ #2
    [   97.937610] Hardware name: Dell Inc. Precision 7865 Tower/, BIOS 1.0.0 06/12/2022
    [   97.937611] Workqueue: events_unbound async_run_entry_fn
    [   97.937616] Call Trace:
    [   97.937617]  <TASK>
    [   97.937619]  dump_stack_lvl+0x49/0x63
    [   97.937624]  dump_stack+0x10/0x16
    [   97.937626]  ubsan_epilogue+0x9/0x3f
    [   97.937627]  __ubsan_handle_out_of_bounds.cold+0x44/0x49
    [   97.937629]  ? __scm_send+0x348/0x440
    [   97.937632]  ? aq_vec_stop+0x72/0x80 [atlantic]
    [   97.937639]  aq_nic_stop+0x1b6/0x1c0 [atlantic]
    [   97.937644]  aq_suspend_common+0x88/0x90 [atlantic]
    [   97.937648]  aq_pm_suspend_poweroff+0xe/0x20 [atlantic]
    [   97.937653]  pci_pm_suspend+0x7e/0x1a0
    [   97.937655]  ? pci_pm_suspend_noirq+0x2b0/0x2b0
    [   97.937657]  dpm_run_callback+0x54/0x190
    [   97.937660]  __device_suspend+0x14c/0x4d0
    [   97.937661]  async_suspend+0x23/0x70
    [   97.937663]  async_run_entry_fn+0x33/0x120
    [   97.937664]  process_one_work+0x21f/0x3f0
    [   97.937666]  worker_thread+0x4a/0x3c0
    [   97.937668]  ? process_one_work+0x3f0/0x3f0
    [   97.937669]  kthread+0xf0/0x120
    [   97.937671]  ? kthread_complete_and_exit+0x20/0x20
    [   97.937672]  ret_from_fork+0x22/0x30
    [   97.937676]  </TASK>
    
    v2. fixed "warning: variable 'aq_vec' set but not used"
    
    v3. simplified a for loop
    
    Fixes: 97bde5c4f909 ("net: ethernet: aquantia: Support for NIC-specific code")
    Signed-off-by: Chia-Lin Kao (AceLan) <acelan.kao@canonical.com>
    Acked-by: Sudarsana Reddy Kalluru <skalluru@marvell.com>
    Link: https://lore.kernel.org/r/20220808081845.42005-1-acelan.kao@canonical.com
    Signed-off-by: Jakub Kicinski <kuba@kernel.org>

commit cf4b7387c0a842d64bdd7c353e6d3298174a7740
Author: Arunpravin Paneer Selvam <Arunpravin.PaneerSelvam@amd.com>
Date:   Tue Aug 9 02:56:23 2022 -0700

    drm/ttm: Fix dummy res NULL ptr deref bug
    
    Check the bo->resource value before accessing the resource
    mem_type.
    
    v2: Fix commit description unwrapped warning
    
    <log snip>
    [   40.191227][  T184] general protection fault, probably for non-canonical address 0xdffffc0000000002: 0000 [#1] SMP KASAN PTI
    [   40.192995][  T184] KASAN: null-ptr-deref in range [0x0000000000000010-0x0000000000000017]
    [   40.194411][  T184] CPU: 1 PID: 184 Comm: systemd-udevd Not tainted 5.19.0-rc4-00721-gb297c22b7070 #1
    [   40.196063][  T184] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.0-debian-1.16.0-4 04/01/2014
    [   40.199605][  T184] RIP: 0010:ttm_bo_validate+0x1b3/0x240 [ttm]
    [   40.200754][  T184] Code: e8 72 c5 ff ff 83 f8 b8 74 d4 85 c0 75 54 49 8b 9e 58 01 00 00 48 b8 00 00 00 00 00 fc ff df 48 8d 7b 10 48 89 fa 48 c1 ea 03 <0f> b6 04 02 84 c0 74 04 3c 03 7e 44 8b 53 10 31 c0 85 d2 0f 85 58
    [   40.203685][  T184] RSP: 0018:ffffc900006df0c8 EFLAGS: 00010202
    [   40.204630][  T184] RAX: dffffc0000000000 RBX: 0000000000000000 RCX: 1ffff1102f4bb71b
    [   40.205864][  T184] RDX: 0000000000000002 RSI: ffffc900006df208 RDI: 0000000000000010
    [   40.207102][  T184] RBP: 1ffff920000dbe1a R08: ffffc900006df208 R09: 0000000000000000
    [   40.208394][  T184] R10: ffff88817a5f0000 R11: 0000000000000001 R12: ffffc900006df110
    [   40.209692][  T184] R13: ffffc900006df0f0 R14: ffff88817a5db800 R15: ffffc900006df208
    [   40.210862][  T184] FS:  00007f6b1d16e8c0(0000) GS:ffff88839d700000(0000) knlGS:0000000000000000
    [   40.212250][  T184] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [   40.213275][  T184] CR2: 000055a1001d4ff0 CR3: 00000001700f4000 CR4: 00000000000006e0
    [   40.214469][  T184] Call Trace:
    [   40.214974][  T184]  <TASK>
    [   40.215438][  T184]  ? ttm_bo_bounce_temp_buffer+0x140/0x140 [ttm]
    [   40.216572][  T184]  ? mutex_spin_on_owner+0x240/0x240
    [   40.217456][  T184]  ? drm_vma_offset_add+0xaa/0x100 [drm]
    [   40.218457][  T184]  ttm_bo_init_reserved+0x3d6/0x540 [ttm]
    [   40.219410][  T184]  ? shmem_get_inode+0x744/0x980
    [   40.220231][  T184]  ttm_bo_init_validate+0xb1/0x200 [ttm]
    [   40.221172][  T184]  ? bo_driver_evict_flags+0x340/0x340 [drm_vram_helper]
    [   40.222530][  T184]  ? ttm_bo_init_reserved+0x540/0x540 [ttm]
    [   40.223643][  T184]  ? __do_sys_finit_module+0x11a/0x1c0
    [   40.224654][  T184]  ? __shmem_file_setup+0x102/0x280
    [   40.234764][  T184]  drm_gem_vram_create+0x305/0x480 [drm_vram_helper]
    [   40.235766][  T184]  ? bo_driver_evict_flags+0x340/0x340 [drm_vram_helper]
    [   40.236846][  T184]  ? __kasan_slab_free+0x108/0x180
    [   40.237650][  T184]  drm_gem_vram_fill_create_dumb+0x134/0x340 [drm_vram_helper]
    [   40.238864][  T184]  ? local_pci_probe+0xdf/0x180
    [   40.239674][  T184]  ? drmm_vram_helper_init+0x400/0x400 [drm_vram_helper]
    [   40.240826][  T184]  drm_client_framebuffer_create+0x19c/0x400 [drm]
    [   40.241955][  T184]  ? drm_client_buffer_delete+0x200/0x200 [drm]
    [   40.243001][  T184]  ? drm_client_pick_crtcs+0x554/0xb80 [drm]
    [   40.244030][  T184]  drm_fb_helper_generic_probe+0x23f/0x940 [drm_kms_helper]
    [   40.245226][  T184]  ? __cond_resched+0x1c/0xc0
    [   40.245987][  T184]  ? drm_fb_helper_memory_range_to_clip+0x180/0x180 [drm_kms_helper]
    [   40.247316][  T184]  ? mutex_unlock+0x80/0x100
    [   40.248005][  T184]  ? __mutex_unlock_slowpath+0x2c0/0x2c0
    [   40.249083][  T184]  drm_fb_helper_single_fb_probe+0x907/0xf00 [drm_kms_helper]
    [   40.250314][  T184]  ? drm_fb_helper_check_var+0x1180/0x1180 [drm_kms_helper]
    [   40.251540][  T184]  ? __cond_resched+0x1c/0xc0
    [   40.252321][  T184]  ? mutex_lock+0x9f/0x100
    [   40.253062][  T184]  __drm_fb_helper_initial_config_and_unlock+0xb9/0x2c0 [drm_kms_helper]
    [   40.254394][  T184]  drm_fbdev_client_hotplug+0x56f/0x840 [drm_kms_helper]
    [   40.255477][  T184]  drm_fbdev_generic_setup+0x165/0x3c0 [drm_kms_helper]
    [   40.256607][  T184]  bochs_pci_probe+0x6b7/0x900 [bochs]
    [   40.257515][  T184]  ? _raw_spin_lock_irqsave+0x87/0x100
    [   40.258312][  T184]  ? bochs_hw_init+0x480/0x480 [bochs]
    [   40.259244][  T184]  ? bochs_hw_init+0x480/0x480 [bochs]
    [   40.260186][  T184]  local_pci_probe+0xdf/0x180
    [   40.260928][  T184]  pci_call_probe+0x15f/0x500
    [   40.265798][  T184]  ? _raw_spin_lock+0x81/0x100
    [   40.266508][  T184]  ? pci_pm_suspend_noirq+0x980/0x980
    [   40.267322][  T184]  ? pci_assign_irq+0x81/0x280
    [   40.268096][  T184]  ? pci_match_device+0x351/0x6c0
    [   40.268883][  T184]  ? kernfs_put+0x18/0x40
    [   40.269611][  T184]  pci_device_probe+0xee/0x240
    [   40.270352][  T184]  really_probe+0x435/0xa80
    [   40.271021][  T184]  __driver_probe_device+0x2ab/0x480
    [   40.271828][  T184]  driver_probe_device+0x49/0x140
    [   40.272627][  T184]  __driver_attach+0x1bd/0x4c0
    [   40.273372][  T184]  ? __device_attach_driver+0x240/0x240
    [   40.274273][  T184]  bus_for_each_dev+0x11e/0x1c0
    [   40.275080][  T184]  ? subsys_dev_iter_exit+0x40/0x40
    [   40.275951][  T184]  ? klist_add_tail+0x132/0x280
    [   40.276767][  T184]  bus_add_driver+0x39b/0x580
    [   40.277574][  T184]  driver_register+0x20f/0x3c0
    [   40.278281][  T184]  ? 0xffffffffc04a2000
    [   40.278894][  T184]  do_one_initcall+0x8a/0x300
    [   40.279642][  T184]  ? trace_event_raw_event_initcall_level+0x1c0/0x1c0
    [   40.280707][  T184]  ? kasan_unpoison+0x23/0x80
    [   40.281479][  T184]  ? kasan_unpoison+0x23/0x80
    [   40.282197][  T184]  do_init_module+0x190/0x640
    [   40.282926][  T184]  load_module+0x221b/0x2780
    [   40.283611][  T184]  ? layout_and_allocate+0x5c0/0x5c0
    [   40.284401][  T184]  ? kernel_read_file+0x286/0x6c0
    [   40.285216][  T184]  ? __x64_sys_fspick+0x2c0/0x2c0
    [   40.286043][  T184]  ? mmap_region+0x4e7/0x1300
    [   40.286832][  T184]  ? __do_sys_finit_module+0x11a/0x1c0
    [   40.287743][  T184]  __do_sys_finit_module+0x11a/0x1c0
    [   40.288636][  T184]  ? __ia32_sys_init_module+0xc0/0xc0
    [   40.289557][  T184]  ? __seccomp_filter+0x15e/0xc80
    [   40.290341][  T184]  ? vm_mmap_pgoff+0x185/0x240
    [   40.291060][  T184]  do_syscall_64+0x3b/0xc0
    [   40.291763][  T184]  entry_SYSCALL_64_after_hwframe+0x46/0xb0
    [   40.292678][  T184] RIP: 0033:0x7f6b1d6279b9
    [   40.293438][  T184] Code: 00 c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 44 00 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 8b 0d a7 54 0c 00 f7 d8 64 89 01 48
    [   40.296302][  T184] RSP: 002b:00007ffe7f51b798 EFLAGS: 00000246 ORIG_RAX: 0000000000000139
    [   40.297633][  T184] RAX: ffffffffffffffda RBX: 00005642dcca2880 RCX: 00007f6b1d6279b9
    [   40.298890][  T184] RDX: 0000000000000000 RSI: 00007f6b1d7b2e2d RDI: 0000000000000016
    [   40.300199][  T184] RBP: 0000000000020000 R08: 0000000000000000 R09: 00005642dccd5530
    [   40.301547][  T184] R10: 0000000000000016 R11: 0000000000000246 R12: 00007f6b1d7b2e2d
    [   40.302698][  T184] R13: 0000000000000000 R14: 00005642dcca4230 R15: 00005642dcca2880
    
    Signed-off-by: Arunpravin Paneer Selvam <Arunpravin.PaneerSelvam@amd.com>
    Reported-by: kernel test robot <oliver.sang@intel.com>
    Reviewed-by: Christian König <christian.koenig@amd.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20220726162205.2778-1-Arunpravin.PaneerSelvam@amd.com
    Link: https://patchwork.freedesktop.org/patch/msgid/20220809095623.3569-1-Arunpravin.PaneerSelvam@amd.com
    Signed-off-by: Christian König <christian.koenig@amd.com>
    CC: stable@vger.kernel.org

commit b3ca7aff3cbb074a466c90e1463b9b59e97ea94e
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Jul 14 21:11:26 2022 +0200

    intel: thermal: PCH: Drop ACPI_FADT_LOW_POWER_S0 check
    
    If ACPI_FADT_LOW_POWER_S0 is not set, this doesn't mean that low-power
    S0 idle is not usable.  It merely means that using S3 on the given
    system is more beneficial from the energy saving perspective than using
    low-power S0 idle, as long as S3 is supported.
    
    Suspend-to-idle is still a valid suspend mode if ACPI_FADT_LOW_POWER_S0
    is not set and the pm_suspend_via_firmware() check in pch_wpt_suspend()
    is sufficient to distinguish suspend-to-idle from S3, so drop the
    confusing ACPI_FADT_LOW_POWER_S0 check.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Zhang Rui <rui.zhang@intel.com>

commit e67bc525ace26e8dc03ca51b19579a14eaa41f32
Author: Lukas Wunner <lukas@wunner.de>
Date:   Tue Jun 28 12:15:08 2022 +0200

    net: phy: Don't trigger state machine while in suspend
    
    commit 1758bde2e4aa5ff188d53e7d9d388bbb7e12eebb upstream.
    
    Upon system sleep, mdio_bus_phy_suspend() stops the phy_state_machine(),
    but subsequent interrupts may retrigger it:
    
    They may have been left enabled to facilitate wakeup and are not
    quiesced until the ->suspend_noirq() phase.  Unwanted interrupts may
    hence occur between mdio_bus_phy_suspend() and dpm_suspend_noirq(),
    as well as between dpm_resume_noirq() and mdio_bus_phy_resume().
    
    Retriggering the phy_state_machine() through an interrupt is not only
    undesirable for the reason given in mdio_bus_phy_suspend() (freezing it
    midway with phydev->lock held), but also because the PHY may be
    inaccessible after it's suspended:  Accesses to USB-attached PHYs are
    blocked once usb_suspend_both() clears the can_submit flag and PHYs on
    PCI network cards may become inaccessible upon suspend as well.
    
    Amend phy_interrupt() to avoid triggering the state machine if the PHY
    is suspended.  Signal wakeup instead if the attached net_device or its
    parent has been configured as a wakeup source.  (Those conditions are
    identical to mdio_bus_phy_may_suspend().)  Postpone handling of the
    interrupt until the PHY has resumed.
    
    Before stopping the phy_state_machine() in mdio_bus_phy_suspend(),
    wait for a concurrent phy_interrupt() to run to completion.  That is
    necessary because phy_interrupt() may have checked the PHY's suspend
    status before the system sleep transition commenced and it may thus
    retrigger the state machine after it was stopped.
    
    Likewise, after re-enabling interrupt handling in mdio_bus_phy_resume(),
    wait for a concurrent phy_interrupt() to complete to ensure that
    interrupts which it postponed are properly rerun.
    
    The issue was exposed by commit 1ce8b37241ed ("usbnet: smsc95xx: Forward
    PHY interrupts to PHY driver to avoid polling"), but has existed since
    forever.
    
    Fixes: 541cd3ee00a4 ("phylib: Fix deadlock on resume")
    Link: https://lore.kernel.org/netdev/a5315a8a-32c2-962f-f696-de9a26d30091@samsung.com/
    Reported-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Tested-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: stable@vger.kernel.org # v2.6.33+
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Link: https://lore.kernel.org/r/b7f386d04e9b5b0e2738f0125743e30676f309ef.1656410895.git.lukas@wunner.de
    Signed-off-by: Jakub Kicinski <kuba@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 25fab798784b0312d408b827475bd5a77ff94753
Author: Lukas Wunner <lukas@wunner.de>
Date:   Tue Jun 28 12:15:08 2022 +0200

    net: phy: Don't trigger state machine while in suspend
    
    commit 1758bde2e4aa5ff188d53e7d9d388bbb7e12eebb upstream.
    
    Upon system sleep, mdio_bus_phy_suspend() stops the phy_state_machine(),
    but subsequent interrupts may retrigger it:
    
    They may have been left enabled to facilitate wakeup and are not
    quiesced until the ->suspend_noirq() phase.  Unwanted interrupts may
    hence occur between mdio_bus_phy_suspend() and dpm_suspend_noirq(),
    as well as between dpm_resume_noirq() and mdio_bus_phy_resume().
    
    Retriggering the phy_state_machine() through an interrupt is not only
    undesirable for the reason given in mdio_bus_phy_suspend() (freezing it
    midway with phydev->lock held), but also because the PHY may be
    inaccessible after it's suspended:  Accesses to USB-attached PHYs are
    blocked once usb_suspend_both() clears the can_submit flag and PHYs on
    PCI network cards may become inaccessible upon suspend as well.
    
    Amend phy_interrupt() to avoid triggering the state machine if the PHY
    is suspended.  Signal wakeup instead if the attached net_device or its
    parent has been configured as a wakeup source.  (Those conditions are
    identical to mdio_bus_phy_may_suspend().)  Postpone handling of the
    interrupt until the PHY has resumed.
    
    Before stopping the phy_state_machine() in mdio_bus_phy_suspend(),
    wait for a concurrent phy_interrupt() to run to completion.  That is
    necessary because phy_interrupt() may have checked the PHY's suspend
    status before the system sleep transition commenced and it may thus
    retrigger the state machine after it was stopped.
    
    Likewise, after re-enabling interrupt handling in mdio_bus_phy_resume(),
    wait for a concurrent phy_interrupt() to complete to ensure that
    interrupts which it postponed are properly rerun.
    
    The issue was exposed by commit 1ce8b37241ed ("usbnet: smsc95xx: Forward
    PHY interrupts to PHY driver to avoid polling"), but has existed since
    forever.
    
    Fixes: 541cd3ee00a4 ("phylib: Fix deadlock on resume")
    Link: https://lore.kernel.org/netdev/a5315a8a-32c2-962f-f696-de9a26d30091@samsung.com/
    Reported-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Tested-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: stable@vger.kernel.org # v2.6.33+
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Link: https://lore.kernel.org/r/b7f386d04e9b5b0e2738f0125743e30676f309ef.1656410895.git.lukas@wunner.de
    Signed-off-by: Jakub Kicinski <kuba@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 1758bde2e4aa5ff188d53e7d9d388bbb7e12eebb
Author: Lukas Wunner <lukas@wunner.de>
Date:   Tue Jun 28 12:15:08 2022 +0200

    net: phy: Don't trigger state machine while in suspend
    
    Upon system sleep, mdio_bus_phy_suspend() stops the phy_state_machine(),
    but subsequent interrupts may retrigger it:
    
    They may have been left enabled to facilitate wakeup and are not
    quiesced until the ->suspend_noirq() phase.  Unwanted interrupts may
    hence occur between mdio_bus_phy_suspend() and dpm_suspend_noirq(),
    as well as between dpm_resume_noirq() and mdio_bus_phy_resume().
    
    Retriggering the phy_state_machine() through an interrupt is not only
    undesirable for the reason given in mdio_bus_phy_suspend() (freezing it
    midway with phydev->lock held), but also because the PHY may be
    inaccessible after it's suspended:  Accesses to USB-attached PHYs are
    blocked once usb_suspend_both() clears the can_submit flag and PHYs on
    PCI network cards may become inaccessible upon suspend as well.
    
    Amend phy_interrupt() to avoid triggering the state machine if the PHY
    is suspended.  Signal wakeup instead if the attached net_device or its
    parent has been configured as a wakeup source.  (Those conditions are
    identical to mdio_bus_phy_may_suspend().)  Postpone handling of the
    interrupt until the PHY has resumed.
    
    Before stopping the phy_state_machine() in mdio_bus_phy_suspend(),
    wait for a concurrent phy_interrupt() to run to completion.  That is
    necessary because phy_interrupt() may have checked the PHY's suspend
    status before the system sleep transition commenced and it may thus
    retrigger the state machine after it was stopped.
    
    Likewise, after re-enabling interrupt handling in mdio_bus_phy_resume(),
    wait for a concurrent phy_interrupt() to complete to ensure that
    interrupts which it postponed are properly rerun.
    
    The issue was exposed by commit 1ce8b37241ed ("usbnet: smsc95xx: Forward
    PHY interrupts to PHY driver to avoid polling"), but has existed since
    forever.
    
    Fixes: 541cd3ee00a4 ("phylib: Fix deadlock on resume")
    Link: https://lore.kernel.org/netdev/a5315a8a-32c2-962f-f696-de9a26d30091@samsung.com/
    Reported-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Tested-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: stable@vger.kernel.org # v2.6.33+
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Link: https://lore.kernel.org/r/b7f386d04e9b5b0e2738f0125743e30676f309ef.1656410895.git.lukas@wunner.de
    Signed-off-by: Jakub Kicinski <kuba@kernel.org>

commit 796d3acd7d9ed88a0309d123f6f6b235136043c5
Author: Kuogee Hsieh <quic_khsieh@quicinc.com>
Date:   Tue Jan 18 10:47:25 2022 -0800

    drm/msm/dp: do not initialize phy until plugin interrupt received
    
    [ Upstream commit 989ebe7bc4463002c210db0010c8475797a9098f ]
    
    Current DP drivers have regulators, clocks, irq and phy are grouped
    together within a function and executed not in a symmetric manner.
    This increase difficulty of code maintenance and limited code scalability.
    This patch divides the driver life cycle of operation into four states,
    resume (including booting up), dongle plugin, dongle unplugged and suspend.
    Regulators, core clocks and irq are grouped together and enabled at resume
    (or booting up) so that the DP controller is armed and ready to receive HPD
    plugin interrupts. HPD plugin interrupt is generated when a dongle plugs
    into DUT (device under test). Once HPD plugin interrupt is received, DP
    controller will initialize phy so that dpcd read/write will function and
    following link training can be proceeded successfully. DP phy will be
    disabled after main link is teared down at end of unplugged HPD interrupt
    handle triggered by dongle unplugged out of DUT. Finally regulators, code
    clocks and irq are disabled at corresponding suspension.
    
    Changes in V2:
    -- removed unnecessary dp_ctrl NULL check
    -- removed unnecessary phy init_count and power_count DRM_DEBUG_DP logs
    -- remove flip parameter out of dp_ctrl_irq_enable()
    -- add fixes tag
    
    Changes in V3:
    -- call dp_display_host_phy_init() instead of dp_ctrl_phy_init() at
            dp_display_host_init() for eDP
    
    Changes in V4:
    -- rewording commit text to match this commit changes
    
    Changes in V5:
    -- rebase on top of msm-next branch
    
    Changes in V6:
    -- delete flip variable
    
    Changes in V7:
    -- dp_ctrl_irq_enable/disabe() merged into dp_ctrl_reset_irq_ctrl()
    
    Changes in V8:
    -- add more detail comment regrading dp phy at dp_display_host_init()
    
    Changes in V9:
    -- remove set phy_initialized to false when -ECONNRESET detected
    
    Changes in v10:
    --  group into one series
    
    Changes in v11:
    -- drop drm/msm/dp: dp_link_parse_sink_count() return immediately
            if aux read
    
    Changes in v12:
    -- move dp_display_host_phy_exit() after dp_display_host_deinit()
    
    Changes in v13:
    -- do not execute phy_init until plugged_in interrupt for edp, same as DP.
    
    Changes in v14:
    -- remove redundant dp->core_initialized = false form dp_pm_suspend.
    
    Changes in v15:
    -- remove core_initialized flag check at both host_init and host_deinit
    
    Changes in v16:
    -- remove dp_display_host_phy_exit core_initialized=false at dp_pm_suspend
    
    Changes in v17:
    -- remove core_initialized checking before execute attention_cb()
    
    Changes in v18:
    -- remove core_initialized checking at dp_pm_suspend
    
    Fixes: 8ede2ecc3e5e ("drm/msm/dp: Add DP compliance tests on Snapdragon Chipsets")
    Signed-off-by: Kuogee Hsieh <quic_khsieh@quicinc.com>
    Reviewed-by: Stephen Boyd <swboyd@chromium.org>
    Link: https://lore.kernel.org/r/1642531648-8448-2-git-send-email-quic_khsieh@quicinc.com
    Signed-off-by: Dmitry Baryshkov <dmitry.baryshkov@linaro.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 0769d0a7ae3c26c0f2210578f83b3d1b30391601
Author: Kuogee Hsieh <quic_khsieh@quicinc.com>
Date:   Wed Jun 22 12:55:31 2022 -0700

    drm/msm/dp: reset drm_dev to NULL at dp_display_unbind()
    
    During msm initialize phase, dp_display_unbind() will be called to undo
    initializations had been done by dp_display_bind() previously if there is
    error happen at msm_drm_bind. Under this kind of circumstance, drm_device
    may not be populated completed which causes system crash at drm_dev_dbg().
    This patch reset drm_dev to NULL so that following drm_dev_dbg() will not
    refer to any internal fields of drm_device to prevent system from crashing.
    Below are panic stack trace,
    
    [   53.584904] Unable to handle kernel paging request at virtual address 0000000070018001
    .
    [   53.702212] Hardware name: Qualcomm Technologies, Inc. sc7280 CRD platform (rev5+) (DT)
    [   53.710445] pstate: 20400009 (nzCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)
    [   53.717596] pc : string_nocheck+0x1c/0x64
    [   53.721738] lr : string+0x54/0x60
    [   53.725162] sp : ffffffc013d6b650
    [   53.728590] pmr_save: 000000e0
    [   53.731743] x29: ffffffc013d6b650 x28: 0000000000000002 x27: 0000000000ffffff
    [   53.739083] x26: ffffffc013d6b710 x25: ffffffd07a066ae0 x24: ffffffd07a419f97
    [   53.746420] x23: ffffffd07a419f99 x22: ffffff81fef360d4 x21: ffffff81fef364d4
    [   53.753760] x20: ffffffc013d6b6f8 x19: ffffffd07a06683c x18: 0000000000000000
    [   53.761093] x17: 4020386678302f30 x16: 00000000000000b0 x15: ffffffd0797523c8
    [   53.768429] x14: 0000000000000004 x13: ffff0000ffffff00 x12: ffffffd07a066b2c
    [   53.775780] x11: 0000000000000000 x10: 000000000000013c x9 : 0000000000000000
    [   53.783117] x8 : ffffff81fef364d4 x7 : 0000000000000000 x6 : 0000000000000000
    [   53.790445] x5 : 0000000000000000 x4 : ffff0a00ffffff04 x3 : ffff0a00ffffff04
    [   53.797783] x2 : 0000000070018001 x1 : ffffffffffffffff x0 : ffffff81fef360d4
    [   53.805136] Call trace:
    [   53.807667]  string_nocheck+0x1c/0x64
    [   53.811439]  string+0x54/0x60
    [   53.814498]  vsnprintf+0x374/0x53c
    [   53.818009]  pointer+0x3dc/0x40c
    [   53.821340]  vsnprintf+0x398/0x53c
    [   53.824854]  vscnprintf+0x3c/0x88
    [   53.828274]  __trace_array_vprintk+0xcc/0x2d4
    [   53.832768]  trace_array_printk+0x8c/0xb4
    [   53.836900]  drm_trace_printf+0x74/0x9c
    [   53.840875]  drm_dev_dbg+0xfc/0x1b8
    [   53.844480]  dp_pm_suspend+0x70/0xf8
    [   53.848164]  dpm_run_callback+0x60/0x1a0
    [   53.852222]  __device_suspend+0x304/0x3f4
    [   53.856363]  dpm_suspend+0xf8/0x3a8
    [   53.859959]  dpm_suspend_start+0x8c/0xc0
    
    Fixes: 570d3e5d28db ("drm/msm/dp: stop event kernel thread when DP unbind")
    Signed-off-by: Kuogee Hsieh <quic_khsieh@quicinc.com>
    Reviewed-by: Dmitry Baryshkov <dmitry.baryshkov@linaro.org>
    Reviewed-by: Stephen Boyd <swboyd@chromium.org>
    Patchwork: https://patchwork.freedesktop.org/patch/490756/
    Link: https://lore.kernel.org/r/1655927731-22396-1-git-send-email-quic_khsieh@quicinc.com
    Signed-off-by: Abhinav Kumar <quic_abhinavk@quicinc.com>

commit b9364eed9232f3d2a846f68c2307eb25c93cc2d0
Author: Douglas Anderson <dianders@chromium.org>
Date:   Tue May 31 16:01:26 2022 -0700

    drm/msm/dpu: Move min BW request and full BW disable back to mdss
    
    In commit a670ff578f1f ("drm/msm/dpu: always use mdp device to scale
    bandwidth") we fully moved interconnect stuff to the DPU driver. This
    had no change for sc7180 but _did_ have an impact for other SoCs. It
    made them match the sc7180 scheme.
    
    Unfortunately, the sc7180 scheme seems like it was a bit broken.
    Specifically the interconnect needs to be on for more than just the
    DPU driver's AXI bus. In the very least it also needs to be on for the
    DSI driver's AXI bus. This can be seen fairly easily by doing this on
    a ChromeOS sc7180-trogdor class device:
    
      set_power_policy --ac_screen_dim_delay=5 --ac_screen_off_delay=10
      sleep 10
      cd /sys/bus/platform/devices/ae94000.dsi/power
      echo on > control
    
    When you do that, you'll get a warning splat in the logs about
    "gcc_disp_hf_axi_clk status stuck at 'off'".
    
    One could argue that perhaps what I have done above is "illegal" and
    that it can't happen naturally in the system because in normal system
    usage the DPU is pretty much always on when DSI is on. That being
    said:
    * In official ChromeOS builds (admittedly a 5.4 kernel with backports)
      we have seen that splat at bootup.
    * Even though we don't use "autosuspend" for these components, we
      don't use the "put_sync" variants. Thus plausibly the DSI could stay
      "runtime enabled" past when the DPU is enabled. Techncially we
      shouldn't do that if the DPU's suspend ends up yanking our clock.
    
    Let's change things such that the "bare minimum" request for the
    interconnect happens in the mdss driver again. That means that all of
    the children can assume that the interconnect is on at the minimum
    bandwidth. We'll then let the DPU request the higher amount that it
    wants.
    
    It should be noted that this isn't as hacky of a solution as it might
    initially appear. Specifically:
    * Since MDSS and DPU individually get their own references to the
      interconnect then the framework will actually handle aggregating
      them. The two drivers are _not_ clobbering each other.
    * When the Qualcomm interconnect driver aggregates it takes the max of
      all the peaks. Thus having MDSS request a peak, as we're doing here,
      won't actually change the total interconnect bandwidth (it won't be
      added to the request for the DPU). This perhaps explains why the
      "average" requested in MDSS was historically 0 since that one
      _would_ be added in.
    
    NOTE also that in the downstream ChromeOS 5.4 and 5.15 kernels, we're
    also seeing some RPMH hangs that are addressed by this fix. These
    hangs are showing up in the field and on _some_ devices with enough
    stress testing of suspend/resume. Specifically right at suspend time
    with a stack crawl that looks like this (from chromeos-5.15 tree):
      rpmh_write_batch+0x19c/0x240
      qcom_icc_bcm_voter_commit+0x210/0x420
      qcom_icc_set+0x28/0x38
      apply_constraints+0x70/0xa4
      icc_set_bw+0x150/0x24c
      dpu_runtime_resume+0x50/0x1c4
      pm_generic_runtime_resume+0x30/0x44
      __genpd_runtime_resume+0x68/0x7c
      genpd_runtime_resume+0x12c/0x20c
      __rpm_callback+0x98/0x138
      rpm_callback+0x30/0x88
      rpm_resume+0x370/0x4a0
      __pm_runtime_resume+0x80/0xb0
      dpu_kms_enable_commit+0x24/0x30
      msm_atomic_commit_tail+0x12c/0x630
      commit_tail+0xac/0x150
      drm_atomic_helper_commit+0x114/0x11c
      drm_atomic_commit+0x68/0x78
      drm_atomic_helper_disable_all+0x158/0x1c8
      drm_atomic_helper_suspend+0xc0/0x1c0
      drm_mode_config_helper_suspend+0x2c/0x60
      msm_pm_prepare+0x2c/0x40
      pm_generic_prepare+0x30/0x44
      genpd_prepare+0x80/0xd0
      device_prepare+0x78/0x17c
      dpm_prepare+0xb0/0x384
      dpm_suspend_start+0x34/0xc0
    
    We don't completely understand all the mechanisms in play, but the
    hang seemed to come and go with random factors. It's not terribly
    surprising that the hang is gone after this patch since the line of
    code that was failing is no longer present in the kernel.
    
    Fixes: a670ff578f1f ("drm/msm/dpu: always use mdp device to scale bandwidth")
    Fixes: c33b7c0389e1 ("drm/msm/dpu: add support for clk and bw scaling for display")
    Signed-off-by: Douglas Anderson <dianders@chromium.org>
    Reviewed-by: Abhinav Kumar <quic_abhinavk@quicinc.com>
    Tested-by: Jessica Zhang <quic_jesszhan@quicinc.com> # RB3 (sdm845) and
    Reviewed-by: Stephen Boyd <swboyd@chromium.org>
    Reviewed-by: Dmitry Baryshkov <dmitry.baryshkov@linaro.org>
    Patchwork: https://patchwork.freedesktop.org/patch/487884/
    Link: https://lore.kernel.org/r/20220531160059.v2.1.Ie7f6d4bf8cce28131da31a43354727e417cae98d@changeid
    Signed-off-by: Abhinav Kumar <quic_abhinavk@quicinc.com>

commit baa1424314f8e4bb5b266aaf9cc7fb7a9e65901b
Author: Amelie Delaunay <amelie.delaunay@foss.st.com>
Date:   Thu May 5 13:56:10 2022 +0200

    dmaengine: stm32-dma: rename pm ops before dma pause/resume introduction
    
    dmaengine framework offers device_pause and device_resume ops to pause an
    on-going transfer and resume it later.
    To avoid any misunderstanding with system sleep pm ops, rename pm ops into
    stm32_dma_pm_suspend and stm32_dma_pm_resume.
    
    Signed-off-by: Amelie Delaunay <amelie.delaunay@foss.st.com>
    Link: https://lore.kernel.org/r/20220505115611.38845-4-amelie.delaunay@foss.st.com
    Signed-off-by: Vinod Koul <vkoul@kernel.org>

commit dc53866d5ca95e7028690961c32c7faaea6bb098
Author: Borislav Petkov <bp@suse.de>
Date:   Tue Apr 19 09:52:41 2022 -0700

    x86/cpu: Load microcode during restore_processor_state()
    
    commit f9e14dbbd454581061c736bf70bf5cbb15ac927c upstream.
    
    When resuming from system sleep state, restore_processor_state()
    restores the boot CPU MSRs. These MSRs could be emulated by microcode.
    If microcode is not loaded yet, writing to emulated MSRs leads to
    unchecked MSR access error:
    
      ...
      PM: Calling lapic_suspend+0x0/0x210
      unchecked MSR access error: WRMSR to 0x10f (tried to write 0x0...0) at rIP: ... (native_write_msr)
      Call Trace:
        <TASK>
        ? restore_processor_state
        x86_acpi_suspend_lowlevel
        acpi_suspend_enter
        suspend_devices_and_enter
        pm_suspend.cold
        state_store
        kobj_attr_store
        sysfs_kf_write
        kernfs_fop_write_iter
        new_sync_write
        vfs_write
        ksys_write
        __x64_sys_write
        do_syscall_64
        entry_SYSCALL_64_after_hwframe
       RIP: 0033:0x7fda13c260a7
    
    To ensure microcode emulated MSRs are available for restoration, load
    the microcode on the boot CPU before restoring these MSRs.
    
      [ Pawan: write commit message and productize it. ]
    
    Fixes: e2a1256b17b1 ("x86/speculation: Restore speculation related MSRs during S3 resume")
    Reported-by: Kyle D. Pelton <kyle.d.pelton@intel.com>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Signed-off-by: Pawan Gupta <pawan.kumar.gupta@linux.intel.com>
    Tested-by: Kyle D. Pelton <kyle.d.pelton@intel.com>
    Cc: stable@vger.kernel.org
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=215841
    Link: https://lore.kernel.org/r/4350dfbf785cd482d3fafa72b2b49c83102df3ce.1650386317.git.pawan.kumar.gupta@linux.intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 6e0925dcbe7d44c5cf4735fd668663aa4a66e96a
Author: Borislav Petkov <bp@suse.de>
Date:   Tue Apr 19 09:52:41 2022 -0700

    x86/cpu: Load microcode during restore_processor_state()
    
    commit f9e14dbbd454581061c736bf70bf5cbb15ac927c upstream.
    
    When resuming from system sleep state, restore_processor_state()
    restores the boot CPU MSRs. These MSRs could be emulated by microcode.
    If microcode is not loaded yet, writing to emulated MSRs leads to
    unchecked MSR access error:
    
      ...
      PM: Calling lapic_suspend+0x0/0x210
      unchecked MSR access error: WRMSR to 0x10f (tried to write 0x0...0) at rIP: ... (native_write_msr)
      Call Trace:
        <TASK>
        ? restore_processor_state
        x86_acpi_suspend_lowlevel
        acpi_suspend_enter
        suspend_devices_and_enter
        pm_suspend.cold
        state_store
        kobj_attr_store
        sysfs_kf_write
        kernfs_fop_write_iter
        new_sync_write
        vfs_write
        ksys_write
        __x64_sys_write
        do_syscall_64
        entry_SYSCALL_64_after_hwframe
       RIP: 0033:0x7fda13c260a7
    
    To ensure microcode emulated MSRs are available for restoration, load
    the microcode on the boot CPU before restoring these MSRs.
    
      [ Pawan: write commit message and productize it. ]
    
    Fixes: e2a1256b17b1 ("x86/speculation: Restore speculation related MSRs during S3 resume")
    Reported-by: Kyle D. Pelton <kyle.d.pelton@intel.com>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Signed-off-by: Pawan Gupta <pawan.kumar.gupta@linux.intel.com>
    Tested-by: Kyle D. Pelton <kyle.d.pelton@intel.com>
    Cc: stable@vger.kernel.org
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=215841
    Link: https://lore.kernel.org/r/4350dfbf785cd482d3fafa72b2b49c83102df3ce.1650386317.git.pawan.kumar.gupta@linux.intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit c421e3a8e90cc408b4455f81a043d759a62a3265
Author: Borislav Petkov <bp@suse.de>
Date:   Tue Apr 19 09:52:41 2022 -0700

    x86/cpu: Load microcode during restore_processor_state()
    
    commit f9e14dbbd454581061c736bf70bf5cbb15ac927c upstream.
    
    When resuming from system sleep state, restore_processor_state()
    restores the boot CPU MSRs. These MSRs could be emulated by microcode.
    If microcode is not loaded yet, writing to emulated MSRs leads to
    unchecked MSR access error:
    
      ...
      PM: Calling lapic_suspend+0x0/0x210
      unchecked MSR access error: WRMSR to 0x10f (tried to write 0x0...0) at rIP: ... (native_write_msr)
      Call Trace:
        <TASK>
        ? restore_processor_state
        x86_acpi_suspend_lowlevel
        acpi_suspend_enter
        suspend_devices_and_enter
        pm_suspend.cold
        state_store
        kobj_attr_store
        sysfs_kf_write
        kernfs_fop_write_iter
        new_sync_write
        vfs_write
        ksys_write
        __x64_sys_write
        do_syscall_64
        entry_SYSCALL_64_after_hwframe
       RIP: 0033:0x7fda13c260a7
    
    To ensure microcode emulated MSRs are available for restoration, load
    the microcode on the boot CPU before restoring these MSRs.
    
      [ Pawan: write commit message and productize it. ]
    
    Fixes: e2a1256b17b1 ("x86/speculation: Restore speculation related MSRs during S3 resume")
    Reported-by: Kyle D. Pelton <kyle.d.pelton@intel.com>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Signed-off-by: Pawan Gupta <pawan.kumar.gupta@linux.intel.com>
    Tested-by: Kyle D. Pelton <kyle.d.pelton@intel.com>
    Cc: stable@vger.kernel.org
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=215841
    Link: https://lore.kernel.org/r/4350dfbf785cd482d3fafa72b2b49c83102df3ce.1650386317.git.pawan.kumar.gupta@linux.intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 6da3c47264b2083006262f9c733b6597bf191d9b
Merge: c908565eecf2 c9933d494c54
Author: David S. Miller <davem@davemloft.net>
Date:   Mon May 9 10:51:59 2022 +0100

    Merge branch 'wwan-t7xx'
    
    Ricardo Martinez says:
    
    ====================
    net: wwan: t7xx: PCIe driver for MediaTek M.2 modem
    
    t7xx is the PCIe host device driver for Intel 5G 5000 M.2 solution which
    is based on MediaTek's T700 modem to provide WWAN connectivity.
    The driver uses the WWAN framework infrastructure to create the following
    control ports and network interfaces:
    * /dev/wwan0mbim0 - Interface conforming to the MBIM protocol.
      Applications like libmbim [1] or Modem Manager [2] from v1.16 onwards
      with [3][4] can use it to enable data communication towards WWAN.
    * /dev/wwan0at0 - Interface that supports AT commands.
    * wwan0 - Primary network interface for IP traffic.
    
    The main blocks in t7xx driver are:
    * PCIe layer - Implements probe, removal, and power management callbacks.
    * Port-proxy - Provides a common interface to interact with different types
      of ports such as WWAN ports.
    * Modem control & status monitor - Implements the entry point for modem
      initialization, reset and exit, as well as exception handling.
    * CLDMA (Control Layer DMA) - Manages the HW used by the port layer to send
      control messages to the modem using MediaTek's CCCI (Cross-Core
      Communication Interface) protocol.
    * DPMAIF (Data Plane Modem AP Interface) - Controls the HW that provides
      uplink and downlink queues for the data path. The data exchange takes
      place using circular buffers to share data buffer addresses and metadata
      to describe the packets.
    * MHCCIF (Modem Host Cross-Core Interface) - Provides interrupt channels
      for bidirectional event notification such as handshake, exception, PM and
      port enumeration.
    
    The compilation of the t7xx driver is enabled by the CONFIG_MTK_T7XX config
    option which depends on CONFIG_WWAN.
    This driver was originally developed by MediaTek. Intel adapted t7xx to
    the WWAN framework, optimized and refactored the driver source code in close
    collaboration with MediaTek. This will enable getting the t7xx driver on the
    Approved Vendor List for interested OEM's and ODM's productization plans
    with Intel 5G 5000 M.2 solution.
    
    List of contributors:
    Amir Hanania <amir.hanania@intel.com>
    Andriy Shevchenko <andriy.shevchenko@linux.intel.com>
    Chandrashekar Devegowda <chandrashekar.devegowda@intel.com>
    Dinesh Sharma <dinesh.sharma@intel.com>
    Eliot Lee <eliot.lee@intel.com>
    Haijun Liu <haijun.liu@mediatek.com>
    M Chetan Kumar <m.chetan.kumar@intel.com>
    Mika Westerberg <mika.westerberg@linux.intel.com>
    Moises Veleta <moises.veleta@intel.com>
    Pierre-louis Bossart <pierre-louis.bossart@intel.com>
    Chiranjeevi Rapolu <chiranjeevi.rapolu@intel.com>
    Ricardo Martinez <ricardo.martinez@linux.intel.com>
    Madhusmita Sahu <madhusmita.sahu@intel.com>
    Muralidharan Sethuraman <muralidharan.sethuraman@intel.com>
    Soumya Prakash Mishra <Soumya.Prakash.Mishra@intel.com>
    Sreehari Kancharla <sreehari.kancharla@intel.com>
    Suresh Nagaraj <suresh.nagaraj@intel.com>
    
    [1] https://www.freedesktop.org/software/libmbim/
    [2] https://www.freedesktop.org/software/ModemManager/
    [3] https://gitlab.freedesktop.org/mobile-broadband/ModemManager/-/merge_requests/582
    [4] https://gitlab.freedesktop.org/mobile-broadband/ModemManager/-/merge_requests/523
    
    V8:
    - Rebase skb_data_area_size() patch (02).
    
    V7:
    - Delete unused macros.
    - Avoid duplicated calls to le32_to_cpu().
    - Fix 'out of bounds' compilation error.
    - Rename port_number to port_count.
    - Remove '!!' when the destination variable is a boolean.
    - Remove unneeded spinlock around rx_length_th.
    - Remove common field from union inside dpmaif_drb struct.
    - Use 'goto' for the exit flow in t7xx_pci_enable_sleep().
    - Merge CLDMA tgpd and rgpd structs.
    - Add comments to clarify skb consumption by ports.
    - Introduce skb_data_area_size() helper.
    - Declare the port config array as constant.
    - Update CLDMA_JUMBO_BUFF_SZ definition when ccci_header
      is introduced by port-proxy patch.
    - Update Reviewed-by tags.
    - Simplify t7xx_dpmaif_tx_send_skb() and make t7xx_dpmaif_add_skb_to_ring()
      report the tx queue full state early.
    
    V6:
    - Remove unneeded initializations and bit masks.
    - Remove t7xx_common.h file.
    - Add comment to circular linking in GPD list.
    - Use min instead of min_t.
    - Use int for local indexes instead of short or char.
    - Update the commit message in CLDMA patch about dependencies on core patch.
    - Add space between contributor name and email address.
    - Rename registers with double negatives
      e.g. DIS_ASPM_LOWPWR_CLR_0 -> ENABLE_ASPM_LOWPWR.
    - Fix a race condition in pci sleep resource locking.
    - Initialize interrupts with t7xx_pcie_mac_set_int() instead of 'clear'.
    - Remove duplicate spin_lock_init(&md->exp_lock).
    - Remove .ndo_select_queue callback due to singular TX queue.
    - Remove call to deprecated netif_rx_any_context().
    - Fix include guard name in t7xx_hif_dpmaif.h.
    - Remove unused q_num parameter in DPMAIF functions.
    - Do not serialize the drb_wr_idx write in t7xx_dpmaif_add_skb_to_ring()
      and the read from t7xx_txq_drb_wr_available().
    - Fix potential leak in t7xx_dpmaif_add_skb_to_ring().
    - Unionize:
        DRB structs: msg and pd.
        PIT structs: msg and pd.
    - Replace list_head & spinlock with skb_buff_head in dpmaif_tx_queue.
    - Remove rx_length_th check in TX WWAN port flow.
    - Remove wwan_remove_port() from the critical section in WWAN port uninit.
    - Use skb_end_pointer() to avoid conditional compilation.
    - Simplify the loop in t7xx_port_ctrl_tx() by checking the buffer offset
      instead of calculating the number of required packets.
    - Remove the code for unused channel PORT_CH_STATUS_RX.
    - Remove bit flags from ports. Ports can check chan_enable instead of the
      PORT_F_RX_ALLOW_DROP flag.
    - Use INVALID_SEQ_NUM to identify the first seq number.
    - Rename port_static to port_conf and ports_private to ports.
    - Implement t7xx_port_send_skb() and t7xx_port_send_ctl_skb() in a layered
      approach to reduce duplicated code and simplify the CCCI header handling.
    - Move wwan_port_rx() call from port-proxy to WWAN port.
    - Rename t7xx_port_recv_skb() to t7xx_port_enqueue_skb().
    - Move control message parsing logic from port-proxy to control port,
      preserve the endianness when parsing the message and make port-proxy
      export a function to enable/disable ports.
    - Use flexible arrays for:
        port-proxy ports.
        payload data in t7xx_fsm_event, port_msg, and mtk_runtime_feature.
    
    v5:
    - Update Intel's copyright years to 2021-2022.
    - Remove circular dependency between DPMAIF HW (07) and HIF (08).
    - Keep separate patches for CLDMA (02) and Core (03)
      but improve the code split by decoupling CLDMA from
      modem ops and cleaning up t7xx_common.h.
    - Rename ID_CLDMA0/ID_CLDMA1 to CLDMA_ID_AP/CLDMA_ID_MD.
    - Consistently use CLDMA's ring_lock to protect tr_ring.
    - Free resources first and then print messages.
    - Implement suggested name changes.
    - Do not explicitly include dev_printk.h.
    - Remove redundant dev_err()s.
    - Fix possible memory leak during probe.
    - Remove infrastructure for legacy interrupts.
    - Remove unused macros and variables, including those that
      can be replaced with constants.
    - Remove PCIE_MAC_MSIX_MSK_SET macro which is duplicated code.
    - Refactor __t7xx_pci_pm_suspend() for clarity.
    - Refactor t7xx_cldma_rx_ring_init() and t7xx_cldma_tx_ring_init().
    - Do not use & for function callbacks.
    - Declare a structure to access skb->cb[] data.
    - Use skb_put_data instead of memcpy.
    - No need to use kfree_sensitive.
    - Use dev_kfree_skb() instead of kfree_skb().
    - Refactor t7xx_prepare_device_rt_data() to remove potential leaks,
      avoid unneeded memset and keep rt_data and packet_size updates
      inside the same 'if' block.
    - Set port's rx_length_th back to 0 during uninit.
    - Remove unneeded 'blocking' parameter from t7xx_cldma_send_skb().
    - Return -EIO in t7xx_cldma_send_skb() if the queue is inactive.
    - Refactor t7xx_cldma_qs_are_active() to use pci_device_is_present().
    - Simplify t7xx_cldma_stop_q() and rename it to t7xx_cldma_stop_all_qs().
    - Fix potential leaks in t7xx_cldma_init().
    - Improve error handling in fsm_append_event and fsm_routine_starting().
    - Propagate return codes from fsm_append_cmd() and t7xx_fsm_append_event().
    - Refactor fsm_wait_for_event() to avoid unnecessary sleep.
    - Create the WWAN ports and net device only after the modem is in
      the ready state.
    - Refactor t7xx_port_proxy_recv_skb() and port_recv_skb().
    - Rename t7xx_port_check_rx_seq_num() as t7xx_port_next_rx_seq_num()
      and fix the seq_num logic to handle overflows.
    - Declare seq_nums as u16 instead of short.
    - Use unsigned int for local indexes.
    - Use min_t instead of the ternary operator.
    - Refactor the loop in t7xx_dpmaif_rx_data_collect() to avoid a dead
      condition check.
    - Use a bitmap (bat_bitmap) instead of an array to keep track of
      the DRB status. Used in t7xx_dpmaif_avail_pkt_bat_cnt().
    - Refactor t7xx_dpmaif_tx_send_skb() to protect tx_submit_skb_cnt
      with spinlock and remove the misleading tx_drb_available variable.
    - Consolidate bit operations before endianness conversion.
    - Use C bit fields in dpmaif_drb_skb struct which is not HW related.
    - Add back the que_started check in t7xx_select_tx_queue().
    - Create a helper function to get the DRB count.
    - Simplify the use of 'usage' during t7xx_ccmni_close().
    - Enforce CCMNI MTU selection with BUILD_BUG_ON() instead of a comment.
    - Remove t7xx_ccmni_ctrl->capability parameter which remains constant.
    
    v4:
    - Implement list_prev_entry_circular() and list_next_entry_circular() macros.
    - Remove inline from all c files.
    - Define ioread32_poll_timeout_atomic() helper macro.
    - Fix return code for WWAN port tx op.
    - Allow AT commands fragmentation same as MBIM commands.
    - Introduce t7xx_common.h file in the first patch.
    - Rename functions and variables as suggested in v3.
    - Reduce code duplication by creating fsm_wait_for_event() helper function.
    - Remove unneeded dev_err in t7xx_fsm_clr_event().
    - Remove unused variable last_state from struct t7xx_fsm_ctl.
    - Remove unused variable txq_select_times from struct dpmaif_ctrl.
    - Replace ETXTBSY with EBUSY.
    - Refactor t7xx_dpmaif_rx_buf_alloc() to remove an unneeded allocation.
    - Fix potential leak at t7xx_dpmaif_rx_frag_alloc().
    - Simplify return value handling at t7xx_dpmaif_rx_start().
    - Add a helper to handle the common part of CCCI header initialization.
    - Make sure interrupts are enabled during PM resume.
    - Add a parameter to t7xx_fsm_append_cmd() to tell if it is in interrupt context.
    
    v3:
    - Avoid unneeded ping-pong changes between patches.
    - Use t7xx_ prefix in functions.
    - Use t7xx_ prefix in generic structs where mtk_ or ccci prefix was used.
    - Update Authors/Contributors header.
    - Remove skb pools used for control path.
    - Remove skb pools used for RX data path.
    - Do not use dedicated TX queue for ACK-only packets.
    - Remove __packed attribute from GPD structs.
    - Remove the infrastructure for test and debug ports.
    - Use the skb control buffer to store metadata.
    - Get the IP packet type from RX PIT.
    - Merge variable declaration and simple assignments.
    - Use preferred coding patterns.
    - Remove global variables.
    - Declare HW facing structure members as little endian.
    - Rename goto tags to describe what is going to be done.
    - Do not use variable length arrays.
    - Remove unneeded blank lines source code and kdoc headers.
    - Use C99 initialization format for port-proxy ports.
    - Clean up comments.
    - Review included headers.
    - Better use of 100 column limit.
    - Remove unneeded mb() in CLDMA.
    - Remove unneeded spin locks and atomics.
    - Handle read_poll_timeout error.
    - Use dev_err_ratelimited() where required.
    - Fix resource leak when requesting IRQs.
    - Use generic DEFAULT_TX_QUEUE_LEN instead custom macro.
    - Use ETH_DATA_LEN instead of defining WWAN_DEFAULT_MTU.
    - Use sizeof() instead of defines when the size of structures is required.
    - Remove unneeded code from netdev:
        No need to configure HW address length
        No need to implement .ndo_change_mtu
        Remove random address generation
    - Code simplifications by using kernel provided functions and macros such as:
        module_pci_driver
        PTR_ERR_OR_ZERO
        for_each_set_bit
        pci_device_is_present
        skb_queue_purge
        list_prev_entry
        __ffs64
    
    v2:
    - Replace pdev->driver->name with dev_driver_string(&pdev->dev).
    - Replace random_ether_addr() with eth_random_addr().
    - Update kernel-doc comment for enum data_policy.
    - Indicate the driver is 'Supported' instead of 'Maintained'.
    - Fix the Signed-of-by and Co-developed-by tags in the patches.
    - Added authors and contributors in the top comment of the src files.
    ====================

commit c56ab397a121804c337036cbbaf8f19ce587dc9c
Author: Borislav Petkov <bp@suse.de>
Date:   Tue Apr 19 09:52:41 2022 -0700

    x86/cpu: Load microcode during restore_processor_state()
    
    commit f9e14dbbd454581061c736bf70bf5cbb15ac927c upstream.
    
    When resuming from system sleep state, restore_processor_state()
    restores the boot CPU MSRs. These MSRs could be emulated by microcode.
    If microcode is not loaded yet, writing to emulated MSRs leads to
    unchecked MSR access error:
    
      ...
      PM: Calling lapic_suspend+0x0/0x210
      unchecked MSR access error: WRMSR to 0x10f (tried to write 0x0...0) at rIP: ... (native_write_msr)
      Call Trace:
        <TASK>
        ? restore_processor_state
        x86_acpi_suspend_lowlevel
        acpi_suspend_enter
        suspend_devices_and_enter
        pm_suspend.cold
        state_store
        kobj_attr_store
        sysfs_kf_write
        kernfs_fop_write_iter
        new_sync_write
        vfs_write
        ksys_write
        __x64_sys_write
        do_syscall_64
        entry_SYSCALL_64_after_hwframe
       RIP: 0033:0x7fda13c260a7
    
    To ensure microcode emulated MSRs are available for restoration, load
    the microcode on the boot CPU before restoring these MSRs.
    
      [ Pawan: write commit message and productize it. ]
    
    Fixes: e2a1256b17b1 ("x86/speculation: Restore speculation related MSRs during S3 resume")
    Reported-by: Kyle D. Pelton <kyle.d.pelton@intel.com>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Signed-off-by: Pawan Gupta <pawan.kumar.gupta@linux.intel.com>
    Tested-by: Kyle D. Pelton <kyle.d.pelton@intel.com>
    Cc: stable@vger.kernel.org
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=215841
    Link: https://lore.kernel.org/r/4350dfbf785cd482d3fafa72b2b49c83102df3ce.1650386317.git.pawan.kumar.gupta@linux.intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit f858bd6536e1136765097171c338c9457a1f390d
Author: Borislav Petkov <bp@suse.de>
Date:   Tue Apr 19 09:52:41 2022 -0700

    x86/cpu: Load microcode during restore_processor_state()
    
    commit f9e14dbbd454581061c736bf70bf5cbb15ac927c upstream.
    
    When resuming from system sleep state, restore_processor_state()
    restores the boot CPU MSRs. These MSRs could be emulated by microcode.
    If microcode is not loaded yet, writing to emulated MSRs leads to
    unchecked MSR access error:
    
      ...
      PM: Calling lapic_suspend+0x0/0x210
      unchecked MSR access error: WRMSR to 0x10f (tried to write 0x0...0) at rIP: ... (native_write_msr)
      Call Trace:
        <TASK>
        ? restore_processor_state
        x86_acpi_suspend_lowlevel
        acpi_suspend_enter
        suspend_devices_and_enter
        pm_suspend.cold
        state_store
        kobj_attr_store
        sysfs_kf_write
        kernfs_fop_write_iter
        new_sync_write
        vfs_write
        ksys_write
        __x64_sys_write
        do_syscall_64
        entry_SYSCALL_64_after_hwframe
       RIP: 0033:0x7fda13c260a7
    
    To ensure microcode emulated MSRs are available for restoration, load
    the microcode on the boot CPU before restoring these MSRs.
    
      [ Pawan: write commit message and productize it. ]
    
    Fixes: e2a1256b17b1 ("x86/speculation: Restore speculation related MSRs during S3 resume")
    Reported-by: Kyle D. Pelton <kyle.d.pelton@intel.com>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Signed-off-by: Pawan Gupta <pawan.kumar.gupta@linux.intel.com>
    Tested-by: Kyle D. Pelton <kyle.d.pelton@intel.com>
    Cc: stable@vger.kernel.org
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=215841
    Link: https://lore.kernel.org/r/4350dfbf785cd482d3fafa72b2b49c83102df3ce.1650386317.git.pawan.kumar.gupta@linux.intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 2ab14625b879eec22854f1dbe61d51570b427513
Author: Borislav Petkov <bp@suse.de>
Date:   Tue Apr 19 09:52:41 2022 -0700

    x86/cpu: Load microcode during restore_processor_state()
    
    commit f9e14dbbd454581061c736bf70bf5cbb15ac927c upstream.
    
    When resuming from system sleep state, restore_processor_state()
    restores the boot CPU MSRs. These MSRs could be emulated by microcode.
    If microcode is not loaded yet, writing to emulated MSRs leads to
    unchecked MSR access error:
    
      ...
      PM: Calling lapic_suspend+0x0/0x210
      unchecked MSR access error: WRMSR to 0x10f (tried to write 0x0...0) at rIP: ... (native_write_msr)
      Call Trace:
        <TASK>
        ? restore_processor_state
        x86_acpi_suspend_lowlevel
        acpi_suspend_enter
        suspend_devices_and_enter
        pm_suspend.cold
        state_store
        kobj_attr_store
        sysfs_kf_write
        kernfs_fop_write_iter
        new_sync_write
        vfs_write
        ksys_write
        __x64_sys_write
        do_syscall_64
        entry_SYSCALL_64_after_hwframe
       RIP: 0033:0x7fda13c260a7
    
    To ensure microcode emulated MSRs are available for restoration, load
    the microcode on the boot CPU before restoring these MSRs.
    
      [ Pawan: write commit message and productize it. ]
    
    Fixes: e2a1256b17b1 ("x86/speculation: Restore speculation related MSRs during S3 resume")
    Reported-by: Kyle D. Pelton <kyle.d.pelton@intel.com>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Signed-off-by: Pawan Gupta <pawan.kumar.gupta@linux.intel.com>
    Tested-by: Kyle D. Pelton <kyle.d.pelton@intel.com>
    Cc: stable@vger.kernel.org
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=215841
    Link: https://lore.kernel.org/r/4350dfbf785cd482d3fafa72b2b49c83102df3ce.1650386317.git.pawan.kumar.gupta@linux.intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit a6d9847a4f8267239979d6e8f08a289dc1dc5ae2
Author: Borislav Petkov <bp@suse.de>
Date:   Tue Apr 19 09:52:41 2022 -0700

    x86/cpu: Load microcode during restore_processor_state()
    
    commit f9e14dbbd454581061c736bf70bf5cbb15ac927c upstream.
    
    When resuming from system sleep state, restore_processor_state()
    restores the boot CPU MSRs. These MSRs could be emulated by microcode.
    If microcode is not loaded yet, writing to emulated MSRs leads to
    unchecked MSR access error:
    
      ...
      PM: Calling lapic_suspend+0x0/0x210
      unchecked MSR access error: WRMSR to 0x10f (tried to write 0x0...0) at rIP: ... (native_write_msr)
      Call Trace:
        <TASK>
        ? restore_processor_state
        x86_acpi_suspend_lowlevel
        acpi_suspend_enter
        suspend_devices_and_enter
        pm_suspend.cold
        state_store
        kobj_attr_store
        sysfs_kf_write
        kernfs_fop_write_iter
        new_sync_write
        vfs_write
        ksys_write
        __x64_sys_write
        do_syscall_64
        entry_SYSCALL_64_after_hwframe
       RIP: 0033:0x7fda13c260a7
    
    To ensure microcode emulated MSRs are available for restoration, load
    the microcode on the boot CPU before restoring these MSRs.
    
      [ Pawan: write commit message and productize it. ]
    
    Fixes: e2a1256b17b1 ("x86/speculation: Restore speculation related MSRs during S3 resume")
    Reported-by: Kyle D. Pelton <kyle.d.pelton@intel.com>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Signed-off-by: Pawan Gupta <pawan.kumar.gupta@linux.intel.com>
    Tested-by: Kyle D. Pelton <kyle.d.pelton@intel.com>
    Cc: stable@vger.kernel.org
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=215841
    Link: https://lore.kernel.org/r/4350dfbf785cd482d3fafa72b2b49c83102df3ce.1650386317.git.pawan.kumar.gupta@linux.intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit f9e14dbbd454581061c736bf70bf5cbb15ac927c
Author: Borislav Petkov <bp@suse.de>
Date:   Tue Apr 19 09:52:41 2022 -0700

    x86/cpu: Load microcode during restore_processor_state()
    
    When resuming from system sleep state, restore_processor_state()
    restores the boot CPU MSRs. These MSRs could be emulated by microcode.
    If microcode is not loaded yet, writing to emulated MSRs leads to
    unchecked MSR access error:
    
      ...
      PM: Calling lapic_suspend+0x0/0x210
      unchecked MSR access error: WRMSR to 0x10f (tried to write 0x0...0) at rIP: ... (native_write_msr)
      Call Trace:
        <TASK>
        ? restore_processor_state
        x86_acpi_suspend_lowlevel
        acpi_suspend_enter
        suspend_devices_and_enter
        pm_suspend.cold
        state_store
        kobj_attr_store
        sysfs_kf_write
        kernfs_fop_write_iter
        new_sync_write
        vfs_write
        ksys_write
        __x64_sys_write
        do_syscall_64
        entry_SYSCALL_64_after_hwframe
       RIP: 0033:0x7fda13c260a7
    
    To ensure microcode emulated MSRs are available for restoration, load
    the microcode on the boot CPU before restoring these MSRs.
    
      [ Pawan: write commit message and productize it. ]
    
    Fixes: e2a1256b17b1 ("x86/speculation: Restore speculation related MSRs during S3 resume")
    Reported-by: Kyle D. Pelton <kyle.d.pelton@intel.com>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Signed-off-by: Pawan Gupta <pawan.kumar.gupta@linux.intel.com>
    Tested-by: Kyle D. Pelton <kyle.d.pelton@intel.com>
    Cc: stable@vger.kernel.org
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=215841
    Link: https://lore.kernel.org/r/4350dfbf785cd482d3fafa72b2b49c83102df3ce.1650386317.git.pawan.kumar.gupta@linux.intel.com

commit fed4cef115ab21a18faf499b3fa9b9a4b544f941
Author: Kalle Valo <quic_kvalo@quicinc.com>
Date:   Thu Jan 27 11:01:16 2022 +0200

    ath11k: pci: fix crash on suspend if board file is not found
    
    [ Upstream commit b4f4c56459a5c744f7f066b9fc2b54ea995030c5 ]
    
    Mario reported that the kernel was crashing on suspend if ath11k was not able
    to find a board file:
    
    [  473.693286] PM: Suspending system (s2idle)
    [  473.693291] printk: Suspending console(s) (use no_console_suspend to debug)
    [  474.407787] BUG: unable to handle page fault for address: 0000000000002070
    [  474.407791] #PF: supervisor read access in kernel mode
    [  474.407794] #PF: error_code(0x0000) - not-present page
    [  474.407798] PGD 0 P4D 0
    [  474.407801] Oops: 0000 [#1] PREEMPT SMP NOPTI
    [  474.407805] CPU: 2 PID: 2350 Comm: kworker/u32:14 Tainted: G        W         5.16.0 #248
    [...]
    [  474.407868] Call Trace:
    [  474.407870]  <TASK>
    [  474.407874]  ? _raw_spin_lock_irqsave+0x2a/0x60
    [  474.407882]  ? lock_timer_base+0x72/0xa0
    [  474.407889]  ? _raw_spin_unlock_irqrestore+0x29/0x3d
    [  474.407892]  ? try_to_del_timer_sync+0x54/0x80
    [  474.407896]  ath11k_dp_rx_pktlog_stop+0x49/0xc0 [ath11k]
    [  474.407912]  ath11k_core_suspend+0x34/0x130 [ath11k]
    [  474.407923]  ath11k_pci_pm_suspend+0x1b/0x50 [ath11k_pci]
    [  474.407928]  pci_pm_suspend+0x7e/0x170
    [  474.407935]  ? pci_pm_freeze+0xc0/0xc0
    [  474.407939]  dpm_run_callback+0x4e/0x150
    [  474.407947]  __device_suspend+0x148/0x4c0
    [  474.407951]  async_suspend+0x20/0x90
    dmesg-efi-164255130401001:
    Oops#1 Part1
    [  474.407955]  async_run_entry_fn+0x33/0x120
    [  474.407959]  process_one_work+0x220/0x3f0
    [  474.407966]  worker_thread+0x4a/0x3d0
    [  474.407971]  kthread+0x17a/0x1a0
    [  474.407975]  ? process_one_work+0x3f0/0x3f0
    [  474.407979]  ? set_kthread_struct+0x40/0x40
    [  474.407983]  ret_from_fork+0x22/0x30
    [  474.407991]  </TASK>
    
    The issue here is that board file loading happens after ath11k_pci_probe()
    succesfully returns (ath11k initialisation happends asynchronously) and the
    suspend handler is still enabled, of course failing as ath11k is not properly
    initialised. Fix this by checking ATH11K_FLAG_QMI_FAIL during both suspend and
    resume.
    
    Tested-on: WCN6855 hw2.0 PCI WLAN.HSP.1.1-03003-QCAHSPSWPL_V1_V2_SILICONZ_LITE-2
    
    Reported-by: Mario Limonciello <mario.limonciello@amd.com>
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=215504
    Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
    Link: https://lore.kernel.org/r/20220127090117.2024-1-kvalo@kernel.org
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit f3c5ef433da82d257337424b3647ce9dcb37d4b5
Author: Kalle Valo <quic_kvalo@quicinc.com>
Date:   Thu Jan 27 11:01:16 2022 +0200

    ath11k: pci: fix crash on suspend if board file is not found
    
    [ Upstream commit b4f4c56459a5c744f7f066b9fc2b54ea995030c5 ]
    
    Mario reported that the kernel was crashing on suspend if ath11k was not able
    to find a board file:
    
    [  473.693286] PM: Suspending system (s2idle)
    [  473.693291] printk: Suspending console(s) (use no_console_suspend to debug)
    [  474.407787] BUG: unable to handle page fault for address: 0000000000002070
    [  474.407791] #PF: supervisor read access in kernel mode
    [  474.407794] #PF: error_code(0x0000) - not-present page
    [  474.407798] PGD 0 P4D 0
    [  474.407801] Oops: 0000 [#1] PREEMPT SMP NOPTI
    [  474.407805] CPU: 2 PID: 2350 Comm: kworker/u32:14 Tainted: G        W         5.16.0 #248
    [...]
    [  474.407868] Call Trace:
    [  474.407870]  <TASK>
    [  474.407874]  ? _raw_spin_lock_irqsave+0x2a/0x60
    [  474.407882]  ? lock_timer_base+0x72/0xa0
    [  474.407889]  ? _raw_spin_unlock_irqrestore+0x29/0x3d
    [  474.407892]  ? try_to_del_timer_sync+0x54/0x80
    [  474.407896]  ath11k_dp_rx_pktlog_stop+0x49/0xc0 [ath11k]
    [  474.407912]  ath11k_core_suspend+0x34/0x130 [ath11k]
    [  474.407923]  ath11k_pci_pm_suspend+0x1b/0x50 [ath11k_pci]
    [  474.407928]  pci_pm_suspend+0x7e/0x170
    [  474.407935]  ? pci_pm_freeze+0xc0/0xc0
    [  474.407939]  dpm_run_callback+0x4e/0x150
    [  474.407947]  __device_suspend+0x148/0x4c0
    [  474.407951]  async_suspend+0x20/0x90
    dmesg-efi-164255130401001:
    Oops#1 Part1
    [  474.407955]  async_run_entry_fn+0x33/0x120
    [  474.407959]  process_one_work+0x220/0x3f0
    [  474.407966]  worker_thread+0x4a/0x3d0
    [  474.407971]  kthread+0x17a/0x1a0
    [  474.407975]  ? process_one_work+0x3f0/0x3f0
    [  474.407979]  ? set_kthread_struct+0x40/0x40
    [  474.407983]  ret_from_fork+0x22/0x30
    [  474.407991]  </TASK>
    
    The issue here is that board file loading happens after ath11k_pci_probe()
    succesfully returns (ath11k initialisation happends asynchronously) and the
    suspend handler is still enabled, of course failing as ath11k is not properly
    initialised. Fix this by checking ATH11K_FLAG_QMI_FAIL during both suspend and
    resume.
    
    Tested-on: WCN6855 hw2.0 PCI WLAN.HSP.1.1-03003-QCAHSPSWPL_V1_V2_SILICONZ_LITE-2
    
    Reported-by: Mario Limonciello <mario.limonciello@amd.com>
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=215504
    Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
    Link: https://lore.kernel.org/r/20220127090117.2024-1-kvalo@kernel.org
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit aeed776c00e804a0f7896db39c7c661cea34ee1f
Author: Kalle Valo <quic_kvalo@quicinc.com>
Date:   Thu Jan 27 11:01:16 2022 +0200

    ath11k: pci: fix crash on suspend if board file is not found
    
    [ Upstream commit b4f4c56459a5c744f7f066b9fc2b54ea995030c5 ]
    
    Mario reported that the kernel was crashing on suspend if ath11k was not able
    to find a board file:
    
    [  473.693286] PM: Suspending system (s2idle)
    [  473.693291] printk: Suspending console(s) (use no_console_suspend to debug)
    [  474.407787] BUG: unable to handle page fault for address: 0000000000002070
    [  474.407791] #PF: supervisor read access in kernel mode
    [  474.407794] #PF: error_code(0x0000) - not-present page
    [  474.407798] PGD 0 P4D 0
    [  474.407801] Oops: 0000 [#1] PREEMPT SMP NOPTI
    [  474.407805] CPU: 2 PID: 2350 Comm: kworker/u32:14 Tainted: G        W         5.16.0 #248
    [...]
    [  474.407868] Call Trace:
    [  474.407870]  <TASK>
    [  474.407874]  ? _raw_spin_lock_irqsave+0x2a/0x60
    [  474.407882]  ? lock_timer_base+0x72/0xa0
    [  474.407889]  ? _raw_spin_unlock_irqrestore+0x29/0x3d
    [  474.407892]  ? try_to_del_timer_sync+0x54/0x80
    [  474.407896]  ath11k_dp_rx_pktlog_stop+0x49/0xc0 [ath11k]
    [  474.407912]  ath11k_core_suspend+0x34/0x130 [ath11k]
    [  474.407923]  ath11k_pci_pm_suspend+0x1b/0x50 [ath11k_pci]
    [  474.407928]  pci_pm_suspend+0x7e/0x170
    [  474.407935]  ? pci_pm_freeze+0xc0/0xc0
    [  474.407939]  dpm_run_callback+0x4e/0x150
    [  474.407947]  __device_suspend+0x148/0x4c0
    [  474.407951]  async_suspend+0x20/0x90
    dmesg-efi-164255130401001:
    Oops#1 Part1
    [  474.407955]  async_run_entry_fn+0x33/0x120
    [  474.407959]  process_one_work+0x220/0x3f0
    [  474.407966]  worker_thread+0x4a/0x3d0
    [  474.407971]  kthread+0x17a/0x1a0
    [  474.407975]  ? process_one_work+0x3f0/0x3f0
    [  474.407979]  ? set_kthread_struct+0x40/0x40
    [  474.407983]  ret_from_fork+0x22/0x30
    [  474.407991]  </TASK>
    
    The issue here is that board file loading happens after ath11k_pci_probe()
    succesfully returns (ath11k initialisation happends asynchronously) and the
    suspend handler is still enabled, of course failing as ath11k is not properly
    initialised. Fix this by checking ATH11K_FLAG_QMI_FAIL during both suspend and
    resume.
    
    Tested-on: WCN6855 hw2.0 PCI WLAN.HSP.1.1-03003-QCAHSPSWPL_V1_V2_SILICONZ_LITE-2
    
    Reported-by: Mario Limonciello <mario.limonciello@amd.com>
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=215504
    Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
    Link: https://lore.kernel.org/r/20220127090117.2024-1-kvalo@kernel.org
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 3795c424ffcbb101bfefe78ca25a96558adedcb6
Author: Kuogee Hsieh <quic_khsieh@quicinc.com>
Date:   Tue Jan 18 10:47:25 2022 -0800

    drm/msm/dp: do not initialize phy until plugin interrupt received
    
    [ Upstream commit 989ebe7bc4463002c210db0010c8475797a9098f ]
    
    Current DP drivers have regulators, clocks, irq and phy are grouped
    together within a function and executed not in a symmetric manner.
    This increase difficulty of code maintenance and limited code scalability.
    This patch divides the driver life cycle of operation into four states,
    resume (including booting up), dongle plugin, dongle unplugged and suspend.
    Regulators, core clocks and irq are grouped together and enabled at resume
    (or booting up) so that the DP controller is armed and ready to receive HPD
    plugin interrupts. HPD plugin interrupt is generated when a dongle plugs
    into DUT (device under test). Once HPD plugin interrupt is received, DP
    controller will initialize phy so that dpcd read/write will function and
    following link training can be proceeded successfully. DP phy will be
    disabled after main link is teared down at end of unplugged HPD interrupt
    handle triggered by dongle unplugged out of DUT. Finally regulators, code
    clocks and irq are disabled at corresponding suspension.
    
    Changes in V2:
    -- removed unnecessary dp_ctrl NULL check
    -- removed unnecessary phy init_count and power_count DRM_DEBUG_DP logs
    -- remove flip parameter out of dp_ctrl_irq_enable()
    -- add fixes tag
    
    Changes in V3:
    -- call dp_display_host_phy_init() instead of dp_ctrl_phy_init() at
            dp_display_host_init() for eDP
    
    Changes in V4:
    -- rewording commit text to match this commit changes
    
    Changes in V5:
    -- rebase on top of msm-next branch
    
    Changes in V6:
    -- delete flip variable
    
    Changes in V7:
    -- dp_ctrl_irq_enable/disabe() merged into dp_ctrl_reset_irq_ctrl()
    
    Changes in V8:
    -- add more detail comment regrading dp phy at dp_display_host_init()
    
    Changes in V9:
    -- remove set phy_initialized to false when -ECONNRESET detected
    
    Changes in v10:
    --  group into one series
    
    Changes in v11:
    -- drop drm/msm/dp: dp_link_parse_sink_count() return immediately
            if aux read
    
    Changes in v12:
    -- move dp_display_host_phy_exit() after dp_display_host_deinit()
    
    Changes in v13:
    -- do not execute phy_init until plugged_in interrupt for edp, same as DP.
    
    Changes in v14:
    -- remove redundant dp->core_initialized = false form dp_pm_suspend.
    
    Changes in v15:
    -- remove core_initialized flag check at both host_init and host_deinit
    
    Changes in v16:
    -- remove dp_display_host_phy_exit core_initialized=false at dp_pm_suspend
    
    Changes in v17:
    -- remove core_initialized checking before execute attention_cb()
    
    Changes in v18:
    -- remove core_initialized checking at dp_pm_suspend
    
    Fixes: 8ede2ecc3e5e ("drm/msm/dp: Add DP compliance tests on Snapdragon Chipsets")
    Signed-off-by: Kuogee Hsieh <quic_khsieh@quicinc.com>
    Reviewed-by: Stephen Boyd <swboyd@chromium.org>
    Link: https://lore.kernel.org/r/1642531648-8448-2-git-send-email-quic_khsieh@quicinc.com
    Signed-off-by: Dmitry Baryshkov <dmitry.baryshkov@linaro.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 400705c50bbf184794c885d1efad7fe9ccf1471a
Author: Wen Gong <quic_wgong@quicinc.com>
Date:   Tue Jan 11 16:42:52 2022 +0200

    ath11k: free peer for station when disconnect from AP for QCA6390/WCN6855
    
    [ Upstream commit 212ad7cb7d7592669c067125949e0a8e31ce6a0b ]
    
    Commit b4a0f54156ac ("ath11k: move peer delete after vdev stop of station
    for QCA6390 and WCN6855") is to fix firmware crash by changing the WMI
    command sequence, but actually skip all the peer delete operation, then
    it lead commit 58595c9874c6 ("ath11k: Fixing dangling pointer issue upon
    peer delete failure") not take effect, and then happened a use-after-free
    warning from KASAN. because the peer->sta is not set to NULL and then used
    later.
    
    Change to only skip the WMI_PEER_DELETE_CMDID for QCA6390/WCN6855.
    
    log of user-after-free:
    
    [  534.888665] BUG: KASAN: use-after-free in ath11k_dp_rx_update_peer_stats+0x912/0xc10 [ath11k]
    [  534.888696] Read of size 8 at addr ffff8881396bb1b8 by task rtcwake/2860
    
    [  534.888705] CPU: 4 PID: 2860 Comm: rtcwake Kdump: loaded Tainted: G        W         5.15.0-wt-ath+ #523
    [  534.888712] Hardware name: Intel(R) Client Systems NUC8i7HVK/NUC8i7HVB, BIOS HNKBLi70.86A.0067.2021.0528.1339 05/28/2021
    [  534.888716] Call Trace:
    [  534.888720]  <IRQ>
    [  534.888726]  dump_stack_lvl+0x57/0x7d
    [  534.888736]  print_address_description.constprop.0+0x1f/0x170
    [  534.888745]  ? ath11k_dp_rx_update_peer_stats+0x912/0xc10 [ath11k]
    [  534.888771]  kasan_report.cold+0x83/0xdf
    [  534.888783]  ? ath11k_dp_rx_update_peer_stats+0x912/0xc10 [ath11k]
    [  534.888810]  ath11k_dp_rx_update_peer_stats+0x912/0xc10 [ath11k]
    [  534.888840]  ath11k_dp_rx_process_mon_status+0x529/0xa70 [ath11k]
    [  534.888874]  ? ath11k_dp_rx_mon_status_bufs_replenish+0x3f0/0x3f0 [ath11k]
    [  534.888897]  ? check_prev_add+0x20f0/0x20f0
    [  534.888922]  ? __lock_acquire+0xb72/0x1870
    [  534.888937]  ? find_held_lock+0x33/0x110
    [  534.888954]  ath11k_dp_rx_process_mon_rings+0x297/0x520 [ath11k]
    [  534.888981]  ? rcu_read_unlock+0x40/0x40
    [  534.888990]  ? ath11k_dp_rx_pdev_alloc+0xd90/0xd90 [ath11k]
    [  534.889026]  ath11k_dp_service_mon_ring+0x67/0xe0 [ath11k]
    [  534.889053]  ? ath11k_dp_rx_process_mon_rings+0x520/0x520 [ath11k]
    [  534.889075]  call_timer_fn+0x167/0x4a0
    [  534.889084]  ? add_timer_on+0x3b0/0x3b0
    [  534.889103]  ? lockdep_hardirqs_on_prepare.part.0+0x18c/0x370
    [  534.889117]  __run_timers.part.0+0x539/0x8b0
    [  534.889123]  ? ath11k_dp_rx_process_mon_rings+0x520/0x520 [ath11k]
    [  534.889157]  ? call_timer_fn+0x4a0/0x4a0
    [  534.889164]  ? mark_lock_irq+0x1c30/0x1c30
    [  534.889173]  ? clockevents_program_event+0xdd/0x280
    [  534.889189]  ? mark_held_locks+0xa5/0xe0
    [  534.889203]  run_timer_softirq+0x97/0x180
    [  534.889213]  __do_softirq+0x276/0x86a
    [  534.889230]  __irq_exit_rcu+0x11c/0x180
    [  534.889238]  irq_exit_rcu+0x5/0x20
    [  534.889244]  sysvec_apic_timer_interrupt+0x8e/0xc0
    [  534.889251]  </IRQ>
    [  534.889254]  <TASK>
    [  534.889259]  asm_sysvec_apic_timer_interrupt+0x12/0x20
    [  534.889265] RIP: 0010:_raw_spin_unlock_irqrestore+0x38/0x70
    [  534.889271] Code: 74 24 10 e8 ea c2 bf fd 48 89 ef e8 12 53 c0 fd 81 e3 00 02 00 00 75 25 9c 58 f6 c4 02 75 2d 48 85 db 74 01 fb bf 01 00 00 00 <e8> 13 a7 b5 fd 65 8b 05 cc d9 9c 5e 85 c0 74 0a 5b 5d c3 e8 a0 ee
    [  534.889276] RSP: 0018:ffffc90002e5f880 EFLAGS: 00000206
    [  534.889284] RAX: 0000000000000006 RBX: 0000000000000200 RCX: ffffffff9f256f10
    [  534.889289] RDX: 0000000000000000 RSI: ffffffffa1c6e420 RDI: 0000000000000001
    [  534.889293] RBP: ffff8881095e6200 R08: 0000000000000001 R09: ffffffffa40d2b8f
    [  534.889298] R10: fffffbfff481a571 R11: 0000000000000001 R12: ffff8881095e6e68
    [  534.889302] R13: ffffc90002e5f908 R14: 0000000000000246 R15: 0000000000000000
    [  534.889316]  ? mark_lock+0xd0/0x14a0
    [  534.889332]  klist_next+0x1d4/0x450
    [  534.889340]  ? dpm_wait_for_subordinate+0x2d0/0x2d0
    [  534.889350]  device_for_each_child+0xa8/0x140
    [  534.889360]  ? device_remove_class_symlinks+0x1b0/0x1b0
    [  534.889370]  ? __lock_release+0x4bd/0x9f0
    [  534.889378]  ? dpm_suspend+0x26b/0x3f0
    [  534.889390]  dpm_wait_for_subordinate+0x82/0x2d0
    [  534.889400]  ? dpm_for_each_dev+0xa0/0xa0
    [  534.889410]  ? dpm_suspend+0x233/0x3f0
    [  534.889427]  __device_suspend+0xd4/0x10c0
    [  534.889440]  ? wait_for_completion_io+0x270/0x270
    [  534.889456]  ? async_suspend_late+0xe0/0xe0
    [  534.889463]  ? async_schedule_node_domain+0x468/0x640
    [  534.889482]  dpm_suspend+0x25a/0x3f0
    [  534.889491]  ? dpm_suspend_end+0x1a0/0x1a0
    [  534.889497]  ? ktime_get+0x214/0x2f0
    [  534.889502]  ? lockdep_hardirqs_on+0x79/0x100
    [  534.889509]  ? recalibrate_cpu_khz+0x10/0x10
    [  534.889516]  ? ktime_get+0x119/0x2f0
    [  534.889528]  dpm_suspend_start+0xab/0xc0
    [  534.889538]  suspend_devices_and_enter+0x1ca/0x350
    [  534.889546]  ? suspend_enter+0x850/0x850
    [  534.889566]  enter_state+0x27c/0x3d7
    [  534.889575]  pm_suspend.cold+0x42/0x189
    [  534.889583]  state_store+0xab/0x160
    [  534.889595]  ? sysfs_file_ops+0x160/0x160
    [  534.889601]  kernfs_fop_write_iter+0x2b5/0x450
    [  534.889615]  new_sync_write+0x36a/0x600
    [  534.889625]  ? new_sync_read+0x600/0x600
    [  534.889639]  ? rcu_read_unlock+0x40/0x40
    [  534.889668]  vfs_write+0x619/0x910
    [  534.889681]  ksys_write+0xf4/0x1d0
    [  534.889689]  ? __ia32_sys_read+0xa0/0xa0
    [  534.889699]  ? lockdep_hardirqs_on_prepare.part.0+0x18c/0x370
    [  534.889707]  ? syscall_enter_from_user_mode+0x1d/0x50
    [  534.889719]  do_syscall_64+0x3b/0x90
    [  534.889725]  entry_SYSCALL_64_after_hwframe+0x44/0xae
    [  534.889731] RIP: 0033:0x7f0b9bc931e7
    [  534.889736] Code: 64 89 02 48 c7 c0 ff ff ff ff eb bb 0f 1f 80 00 00 00 00 f3 0f 1e fa 64 8b 04 25 18 00 00 00 85 c0 75 10 b8 01 00 00 00 0f 05 <48> 3d 00 f0 ff ff 77 51 c3 48 83 ec 28 48 89 54 24 18 48 89 74 24
    [  534.889741] RSP: 002b:00007ffd9d34cc88 EFLAGS: 00000246 ORIG_RAX: 0000000000000001
    [  534.889749] RAX: ffffffffffffffda RBX: 0000000000000004 RCX: 00007f0b9bc931e7
    [  534.889753] RDX: 0000000000000004 RSI: 0000561cd023c5f0 RDI: 0000000000000004
    [  534.889757] RBP: 0000561cd023c5f0 R08: 0000000000000000 R09: 0000000000000004
    [  534.889761] R10: 0000561ccef842a6 R11: 0000000000000246 R12: 0000000000000004
    [  534.889765] R13: 0000561cd0239590 R14: 00007f0b9bd6f4a0 R15: 00007f0b9bd6e8a0
    [  534.889789]  </TASK>
    
    [  534.889796] Allocated by task 2711:
    [  534.889800]  kasan_save_stack+0x1b/0x40
    [  534.889805]  __kasan_kmalloc+0x7c/0x90
    [  534.889810]  sta_info_alloc+0x98/0x1ef0 [mac80211]
    [  534.889874]  ieee80211_prep_connection+0x30b/0x11e0 [mac80211]
    [  534.889950]  ieee80211_mgd_auth+0x529/0xe00 [mac80211]
    [  534.890024]  cfg80211_mlme_auth+0x332/0x6f0 [cfg80211]
    [  534.890090]  nl80211_authenticate+0x839/0xcf0 [cfg80211]
    [  534.890147]  genl_family_rcv_msg_doit+0x1f4/0x2f0
    [  534.890154]  genl_rcv_msg+0x280/0x500
    [  534.890160]  netlink_rcv_skb+0x11c/0x340
    [  534.890165]  genl_rcv+0x1f/0x30
    [  534.890170]  netlink_unicast+0x42b/0x700
    [  534.890176]  netlink_sendmsg+0x71b/0xc60
    [  534.890181]  sock_sendmsg+0xdf/0x110
    [  534.890187]  ____sys_sendmsg+0x5c0/0x850
    [  534.890192]  ___sys_sendmsg+0xe4/0x160
    [  534.890197]  __sys_sendmsg+0xb2/0x140
    [  534.890202]  do_syscall_64+0x3b/0x90
    [  534.890207]  entry_SYSCALL_64_after_hwframe+0x44/0xae
    
    [  534.890215] Freed by task 2825:
    [  534.890218]  kasan_save_stack+0x1b/0x40
    [  534.890223]  kasan_set_track+0x1c/0x30
    [  534.890227]  kasan_set_free_info+0x20/0x30
    [  534.890232]  __kasan_slab_free+0xce/0x100
    [  534.890237]  slab_free_freelist_hook+0xf0/0x1a0
    [  534.890242]  kfree+0xe5/0x370
    [  534.890248]  __sta_info_flush+0x333/0x4b0 [mac80211]
    [  534.890308]  ieee80211_set_disassoc+0x324/0xd20 [mac80211]
    [  534.890382]  ieee80211_mgd_deauth+0x537/0xee0 [mac80211]
    [  534.890472]  cfg80211_mlme_deauth+0x349/0x810 [cfg80211]
    [  534.890526]  cfg80211_mlme_down+0x1ce/0x270 [cfg80211]
    [  534.890578]  cfg80211_disconnect+0x4f5/0x7b0 [cfg80211]
    [  534.890631]  cfg80211_leave+0x24/0x40 [cfg80211]
    [  534.890677]  wiphy_suspend+0x23d/0x2f0 [cfg80211]
    [  534.890723]  dpm_run_callback+0xf4/0x1b0
    [  534.890728]  __device_suspend+0x648/0x10c0
    [  534.890733]  async_suspend+0x16/0xe0
    [  534.890737]  async_run_entry_fn+0x90/0x4f0
    [  534.890741]  process_one_work+0x866/0x1490
    [  534.890747]  worker_thread+0x596/0x1010
    [  534.890751]  kthread+0x35d/0x420
    [  534.890756]  ret_from_fork+0x22/0x30
    
    [  534.890763] The buggy address belongs to the object at ffff8881396ba000
                    which belongs to the cache kmalloc-8k of size 8192
    [  534.890767] The buggy address is located 4536 bytes inside of
                    8192-byte region [ffff8881396ba000, ffff8881396bc000)
    [  534.890772] The buggy address belongs to the page:
    [  534.890775] page:ffffea0004e5ae00 refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x1396b8
    [  534.890780] head:ffffea0004e5ae00 order:3 compound_mapcount:0 compound_pincount:0
    [  534.890784] flags: 0x200000000010200(slab|head|node=0|zone=2)
    [  534.890791] raw: 0200000000010200 ffffea000562be08 ffffea0004b04c08 ffff88810004e340
    [  534.890795] raw: 0000000000000000 0000000000010001 00000001ffffffff 0000000000000000
    [  534.890798] page dumped because: kasan: bad access detected
    
    [  534.890804] Memory state around the buggy address:
    [  534.890807]  ffff8881396bb080: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [  534.890811]  ffff8881396bb100: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [  534.890814] >ffff8881396bb180: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [  534.890817]                                         ^
    [  534.890821]  ffff8881396bb200: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [  534.890824]  ffff8881396bb280: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [  534.890827] ==================================================================
    [  534.890830] Disabling lock debugging due to kernel taint
    
    Tested-on: WCN6855 hw2.0 PCI WLAN.HSP.1.1-01720.1-QCAHSPSWPL_V1_V2_SILICONZ_LITE-1
    
    Fixes: b4a0f54156ac ("ath11k: move peer delete after vdev stop of station for QCA6390 and WCN6855")
    Signed-off-by: Wen Gong <quic_wgong@quicinc.com>
    Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
    Link: https://lore.kernel.org/r/20211222070431.29595-1-quic_wgong@quicinc.com
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit e0fe243d3c936beb02697440a1e4c5a26da3fd30
Author: Wanpeng Li <wanpengli@tencent.com>
Date:   Tue Feb 15 02:15:42 2022 -0800

    KVM: Fix lockdep false negative during host resume
    
    [ Upstream commit 4cb9a998b1ce25fad74a82f5a5c45a4ef40de337 ]
    
    I saw the below splatting after the host suspended and resumed.
    
       WARNING: CPU: 0 PID: 2943 at kvm/arch/x86/kvm/../../../virt/kvm/kvm_main.c:5531 kvm_resume+0x2c/0x30 [kvm]
       CPU: 0 PID: 2943 Comm: step_after_susp Tainted: G        W IOE     5.17.0-rc3+ #4
       RIP: 0010:kvm_resume+0x2c/0x30 [kvm]
       Call Trace:
        <TASK>
        syscore_resume+0x90/0x340
        suspend_devices_and_enter+0xaee/0xe90
        pm_suspend.cold+0x36b/0x3c2
        state_store+0x82/0xf0
        kernfs_fop_write_iter+0x1b6/0x260
        new_sync_write+0x258/0x370
        vfs_write+0x33f/0x510
        ksys_write+0xc9/0x160
        do_syscall_64+0x3b/0xc0
        entry_SYSCALL_64_after_hwframe+0x44/0xae
    
    lockdep_is_held() can return -1 when lockdep is disabled which triggers
    this warning. Let's use lockdep_assert_not_held() which can detect
    incorrect calls while holding a lock and it also avoids false negatives
    when lockdep is disabled.
    
    Signed-off-by: Wanpeng Li <wanpengli@tencent.com>
    Message-Id: <1644920142-81249-1-git-send-email-wanpengli@tencent.com>
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit e160ee96d03ffd239c80fd54f759e87368468349
Author: Wanpeng Li <wanpengli@tencent.com>
Date:   Tue Feb 15 02:15:42 2022 -0800

    KVM: Fix lockdep false negative during host resume
    
    [ Upstream commit 4cb9a998b1ce25fad74a82f5a5c45a4ef40de337 ]
    
    I saw the below splatting after the host suspended and resumed.
    
       WARNING: CPU: 0 PID: 2943 at kvm/arch/x86/kvm/../../../virt/kvm/kvm_main.c:5531 kvm_resume+0x2c/0x30 [kvm]
       CPU: 0 PID: 2943 Comm: step_after_susp Tainted: G        W IOE     5.17.0-rc3+ #4
       RIP: 0010:kvm_resume+0x2c/0x30 [kvm]
       Call Trace:
        <TASK>
        syscore_resume+0x90/0x340
        suspend_devices_and_enter+0xaee/0xe90
        pm_suspend.cold+0x36b/0x3c2
        state_store+0x82/0xf0
        kernfs_fop_write_iter+0x1b6/0x260
        new_sync_write+0x258/0x370
        vfs_write+0x33f/0x510
        ksys_write+0xc9/0x160
        do_syscall_64+0x3b/0xc0
        entry_SYSCALL_64_after_hwframe+0x44/0xae
    
    lockdep_is_held() can return -1 when lockdep is disabled which triggers
    this warning. Let's use lockdep_assert_not_held() which can detect
    incorrect calls while holding a lock and it also avoids false negatives
    when lockdep is disabled.
    
    Signed-off-by: Wanpeng Li <wanpengli@tencent.com>
    Message-Id: <1644920142-81249-1-git-send-email-wanpengli@tencent.com>
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 91ec77924714b67a6fbe9f6631dd639012fb76eb
Author: Chen Yu <yu.c.chen@intel.com>
Date:   Tue Mar 8 09:20:30 2022 -0800

    e1000e: Print PHY register address when MDI read/write fails
    
    There is occasional suspend error from e1000e which blocks the
    system from further suspending. And the issue was found on
    a WhiskeyLake-U platform with I219-V:
    
    [   20.078957] PM: pci_pm_suspend(): e1000e_pm_suspend+0x0/0x780 [e1000e] returns -2
    [   20.078970] PM: dpm_run_callback(): pci_pm_suspend+0x0/0x170 returns -2
    [   20.078974] e1000e 0000:00:1f.6: PM: pci_pm_suspend+0x0/0x170 returned -2 after 371012 usecs
    [   20.078978] e1000e 0000:00:1f.6: PM: failed to suspend async: error -2
    
    According to the code flow, this might be caused by broken MDI read/write
    to PHY registers. However currently the code does not tell us which
    register is broken. Thus enhance the debug information to print the
    offender PHY register. So the next the issue is reproduced, this
    information could be used for narrow down.
    
    Acked-by: Paul Menzel <pmenzel@molgen.mpg.de>
    Reported-by: Todd Brandt <todd.e.brandt@intel.com>
    Signed-off-by: Chen Yu <yu.c.chen@intel.com>
    Tested-by: Naama Meir <naamax.meir@linux.intel.com>
    Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
    Link: https://lore.kernel.org/r/20220308172030.451566-1-anthony.l.nguyen@intel.com
    Signed-off-by: Jakub Kicinski <kuba@kernel.org>

commit a759de6991b35ad437adba32b5f0cb2fd9e75929
Author: Youngjin Jang <yj84.jang@samsung.com>
Date:   Tue Mar 8 04:07:39 2022 +0900

    PM: sleep: Add device name to suspend_report_result()
    
    Currently, suspend_report_result() prints only function information.
    
    If any driver uses a common PM function, nobody knows who exactly
    called the failing function.
    
    A device pinter is needed to recognize the failing device.
    
    For example:
    
     PM: dpm_run_callback(): pnp_bus_suspend+0x0/0x10 returns 0
     PM: dpm_run_callback(): pci_pm_suspend+0x0/0x150 returns 0
    
    become after the change:
    
     serial 00:05: PM: dpm_run_callback(): pnp_bus_suspend+0x0/0x10 returns 0
     pci 0000:00:01.3: PM: dpm_run_callback(): pci_pm_suspend+0x0/0x150 returns 0
    
    Signed-off-by: Youngjin Jang <yj84.jang@samsung.com>
    [ rjw: Changelog edits ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 3a6cddab2d807242b8461404203e51e0ca490f77
Author: Muhammad Usama Anjum <usama.anjum@collabora.com>
Date:   Fri Jan 28 18:07:22 2022 +0100

    media: imx: imx8mq-mipi_csi2: Remove unneeded code
    
    ret is constant in imx8mq_mipi_csi_pm_suspend(). This function cannot
    return error. Remove the return variable. Simplify other functions which
    are using this function.
    
    Signed-off-by: Muhammad Usama Anjum <usama.anjum@collabora.com>
    Reviewed-by: Fabio Estevam <festevam@gmail.com>
    Signed-off-by: Hans Verkuil <hverkuil-cisco@xs4all.nl>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@kernel.org>

commit eb3f05179a27b98f99e590bf2164582113f23f7e
Author: Yake Yang <yake.yang@mediatek.com>
Date:   Wed Feb 23 07:56:00 2022 +0800

    Bluetooth: btmtksdio: Fix kernel oops when sdio suspend.
    
    Do not kfree the skb when the skb failed to send with __hci_cmd_sync
    
    2435.241210] Call trace:
    [ 2435.241224]  kfree_skb+0x20/0x140
    [ 2435.241240]  btmtksdio_sdio_wakeup+0x8c/0xcc
    [ 2435.241360]  hci_suspend_notifier+0x108/0x184
    [ 2435.241377]  notifier_call_chain_robust+0x58/0xd8
    [ 2435.241390]  blocking_notifier_call_chain_robust+0x54/0x84
    [ 2435.241402]  pm_notifier_call_chain_robust+0x2c/0x4c
    [ 2435.241414]  suspend_prepare+0x40/0x238
    [ 2435.241425]  enter_state+0xec/0x3a8
    [ 2435.241436]  pm_suspend+0x60/0xcc
    [ 2435.241446]  state_store+0xb8/0x114
    [ 2435.241460]  kobj_attr_store+0x18/0x2c
    [ 2435.241473]  sysfs_kf_write+0x44/0x58
    [ 2435.241486]  kernfs_fop_write_iter+0xf4/0x190
    [ 2435.241500]  vfs_write+0x2b0/0x2e4
    [ 2435.241511]  ksys_write+0x80/0xec
    [ 2435.241523]  __arm64_sys_write+0x24/0x30
    [ 2435.241538]  el0_svc_common+0xf0/0x1d8
    [ 2435.241550]  do_el0_svc_compat+0x28/0x54
    [ 2435.241564]  el0_svc_compat+0x10/0x1c
    [ 2435.241574]  el0_sync_compat_handler+0xa8/0xcc
    [ 2435.241586]  el0_sync_compat+0x188/0x1c0
    [ 2435.241606] Code: a9014ff4 910003fd b40002c0 aa0003f3 (b84d4c08)
    [ 2435.241619] ---[ end trace d496539b850baf14 ]---
    
    Fixes: ce64b3e94919  ("Bluetooth: mt7921s: Support wake on bluetooth")
    Co-developed-by: Sean Wang <sean.wang@mediatek.com>
    Signed-off-by: Sean Wang <sean.wang@mediatek.com>
    Signed-off-by: Yake Yang <yake.yang@mediatek.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

commit 989ebe7bc4463002c210db0010c8475797a9098f
Author: Kuogee Hsieh <quic_khsieh@quicinc.com>
Date:   Tue Jan 18 10:47:25 2022 -0800

    drm/msm/dp: do not initialize phy until plugin interrupt received
    
    Current DP drivers have regulators, clocks, irq and phy are grouped
    together within a function and executed not in a symmetric manner.
    This increase difficulty of code maintenance and limited code scalability.
    This patch divides the driver life cycle of operation into four states,
    resume (including booting up), dongle plugin, dongle unplugged and suspend.
    Regulators, core clocks and irq are grouped together and enabled at resume
    (or booting up) so that the DP controller is armed and ready to receive HPD
    plugin interrupts. HPD plugin interrupt is generated when a dongle plugs
    into DUT (device under test). Once HPD plugin interrupt is received, DP
    controller will initialize phy so that dpcd read/write will function and
    following link training can be proceeded successfully. DP phy will be
    disabled after main link is teared down at end of unplugged HPD interrupt
    handle triggered by dongle unplugged out of DUT. Finally regulators, code
    clocks and irq are disabled at corresponding suspension.
    
    Changes in V2:
    -- removed unnecessary dp_ctrl NULL check
    -- removed unnecessary phy init_count and power_count DRM_DEBUG_DP logs
    -- remove flip parameter out of dp_ctrl_irq_enable()
    -- add fixes tag
    
    Changes in V3:
    -- call dp_display_host_phy_init() instead of dp_ctrl_phy_init() at
            dp_display_host_init() for eDP
    
    Changes in V4:
    -- rewording commit text to match this commit changes
    
    Changes in V5:
    -- rebase on top of msm-next branch
    
    Changes in V6:
    -- delete flip variable
    
    Changes in V7:
    -- dp_ctrl_irq_enable/disabe() merged into dp_ctrl_reset_irq_ctrl()
    
    Changes in V8:
    -- add more detail comment regrading dp phy at dp_display_host_init()
    
    Changes in V9:
    -- remove set phy_initialized to false when -ECONNRESET detected
    
    Changes in v10:
    --  group into one series
    
    Changes in v11:
    -- drop drm/msm/dp: dp_link_parse_sink_count() return immediately
            if aux read
    
    Changes in v12:
    -- move dp_display_host_phy_exit() after dp_display_host_deinit()
    
    Changes in v13:
    -- do not execute phy_init until plugged_in interrupt for edp, same as DP.
    
    Changes in v14:
    -- remove redundant dp->core_initialized = false form dp_pm_suspend.
    
    Changes in v15:
    -- remove core_initialized flag check at both host_init and host_deinit
    
    Changes in v16:
    -- remove dp_display_host_phy_exit core_initialized=false at dp_pm_suspend
    
    Changes in v17:
    -- remove core_initialized checking before execute attention_cb()
    
    Changes in v18:
    -- remove core_initialized checking at dp_pm_suspend
    
    Fixes: 8ede2ecc3e5e ("drm/msm/dp: Add DP compliance tests on Snapdragon Chipsets")
    Signed-off-by: Kuogee Hsieh <quic_khsieh@quicinc.com>
    Reviewed-by: Stephen Boyd <swboyd@chromium.org>
    Link: https://lore.kernel.org/r/1642531648-8448-2-git-send-email-quic_khsieh@quicinc.com
    Signed-off-by: Dmitry Baryshkov <dmitry.baryshkov@linaro.org>

commit 4cb9a998b1ce25fad74a82f5a5c45a4ef40de337
Author: Wanpeng Li <wanpengli@tencent.com>
Date:   Tue Feb 15 02:15:42 2022 -0800

    KVM: Fix lockdep false negative during host resume
    
    I saw the below splatting after the host suspended and resumed.
    
       WARNING: CPU: 0 PID: 2943 at kvm/arch/x86/kvm/../../../virt/kvm/kvm_main.c:5531 kvm_resume+0x2c/0x30 [kvm]
       CPU: 0 PID: 2943 Comm: step_after_susp Tainted: G        W IOE     5.17.0-rc3+ #4
       RIP: 0010:kvm_resume+0x2c/0x30 [kvm]
       Call Trace:
        <TASK>
        syscore_resume+0x90/0x340
        suspend_devices_and_enter+0xaee/0xe90
        pm_suspend.cold+0x36b/0x3c2
        state_store+0x82/0xf0
        kernfs_fop_write_iter+0x1b6/0x260
        new_sync_write+0x258/0x370
        vfs_write+0x33f/0x510
        ksys_write+0xc9/0x160
        do_syscall_64+0x3b/0xc0
        entry_SYSCALL_64_after_hwframe+0x44/0xae
    
    lockdep_is_held() can return -1 when lockdep is disabled which triggers
    this warning. Let's use lockdep_assert_not_held() which can detect
    incorrect calls while holding a lock and it also avoids false negatives
    when lockdep is disabled.
    
    Signed-off-by: Wanpeng Li <wanpengli@tencent.com>
    Message-Id: <1644920142-81249-1-git-send-email-wanpengli@tencent.com>
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>

commit 8b05ad29acb972850ad795fa850e814b2e758b83
Author: Frank Li <Frank.Li@nxp.com>
Date:   Mon Jan 10 11:27:38 2022 -0600

    usb: xhci-plat: fix crash when suspend if remote wake enable
    
    commit 9df478463d9feb90dae24f183383961cf123a0ec upstream.
    
    Crashed at i.mx8qm platform when suspend if enable remote wakeup
    
    Internal error: synchronous external abort: 96000210 [#1] PREEMPT SMP
    Modules linked in:
    CPU: 2 PID: 244 Comm: kworker/u12:6 Not tainted 5.15.5-dirty #12
    Hardware name: Freescale i.MX8QM MEK (DT)
    Workqueue: events_unbound async_run_entry_fn
    pstate: 600000c5 (nZCv daIF -PAN -UAO -TCO -DIT -SSBS BTYPE=--)
    pc : xhci_disable_hub_port_wake.isra.62+0x60/0xf8
    lr : xhci_disable_hub_port_wake.isra.62+0x34/0xf8
    sp : ffff80001394bbf0
    x29: ffff80001394bbf0 x28: 0000000000000000 x27: ffff00081193b578
    x26: ffff00081193b570 x25: 0000000000000000 x24: 0000000000000000
    x23: ffff00081193a29c x22: 0000000000020001 x21: 0000000000000001
    x20: 0000000000000000 x19: ffff800014e90490 x18: 0000000000000000
    x17: 0000000000000000 x16: 0000000000000000 x15: 0000000000000000
    x14: 0000000000000000 x13: 0000000000000002 x12: 0000000000000000
    x11: 0000000000000000 x10: 0000000000000960 x9 : ffff80001394baa0
    x8 : ffff0008145d1780 x7 : ffff0008f95b8e80 x6 : 000000001853b453
    x5 : 0000000000000496 x4 : 0000000000000000 x3 : ffff00081193a29c
    x2 : 0000000000000001 x1 : 0000000000000000 x0 : ffff000814591620
    Call trace:
     xhci_disable_hub_port_wake.isra.62+0x60/0xf8
     xhci_suspend+0x58/0x510
     xhci_plat_suspend+0x50/0x78
     platform_pm_suspend+0x2c/0x78
     dpm_run_callback.isra.25+0x50/0xe8
     __device_suspend+0x108/0x3c0
    
    The basic flow:
            1. run time suspend call xhci_suspend, xhci parent devices gate the clock.
            2. echo mem >/sys/power/state, system _device_suspend call xhci_suspend
            3. xhci_suspend call xhci_disable_hub_port_wake, which access register,
               but clock already gated by run time suspend.
    
    This problem was hidden by power domain driver, which call run time resume before it.
    
    But the below commit remove it and make this issue happen.
            commit c1df456d0f06e ("PM: domains: Don't runtime resume devices at genpd_prepare()")
    
    This patch call run time resume before suspend to make sure clock is on
    before access register.
    
    Reviewed-by: Peter Chen <peter.chen@kernel.org>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Frank Li <Frank.Li@nxp.com>
    Testeb-by: Abel Vesa <abel.vesa@nxp.com>
    Link: https://lore.kernel.org/r/20220110172738.31686-1-Frank.Li@nxp.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit d5755832a1e47f5d8773f0776e211ecd4e02da72
Author: Frank Li <Frank.Li@nxp.com>
Date:   Mon Jan 10 11:27:38 2022 -0600

    usb: xhci-plat: fix crash when suspend if remote wake enable
    
    commit 9df478463d9feb90dae24f183383961cf123a0ec upstream.
    
    Crashed at i.mx8qm platform when suspend if enable remote wakeup
    
    Internal error: synchronous external abort: 96000210 [#1] PREEMPT SMP
    Modules linked in:
    CPU: 2 PID: 244 Comm: kworker/u12:6 Not tainted 5.15.5-dirty #12
    Hardware name: Freescale i.MX8QM MEK (DT)
    Workqueue: events_unbound async_run_entry_fn
    pstate: 600000c5 (nZCv daIF -PAN -UAO -TCO -DIT -SSBS BTYPE=--)
    pc : xhci_disable_hub_port_wake.isra.62+0x60/0xf8
    lr : xhci_disable_hub_port_wake.isra.62+0x34/0xf8
    sp : ffff80001394bbf0
    x29: ffff80001394bbf0 x28: 0000000000000000 x27: ffff00081193b578
    x26: ffff00081193b570 x25: 0000000000000000 x24: 0000000000000000
    x23: ffff00081193a29c x22: 0000000000020001 x21: 0000000000000001
    x20: 0000000000000000 x19: ffff800014e90490 x18: 0000000000000000
    x17: 0000000000000000 x16: 0000000000000000 x15: 0000000000000000
    x14: 0000000000000000 x13: 0000000000000002 x12: 0000000000000000
    x11: 0000000000000000 x10: 0000000000000960 x9 : ffff80001394baa0
    x8 : ffff0008145d1780 x7 : ffff0008f95b8e80 x6 : 000000001853b453
    x5 : 0000000000000496 x4 : 0000000000000000 x3 : ffff00081193a29c
    x2 : 0000000000000001 x1 : 0000000000000000 x0 : ffff000814591620
    Call trace:
     xhci_disable_hub_port_wake.isra.62+0x60/0xf8
     xhci_suspend+0x58/0x510
     xhci_plat_suspend+0x50/0x78
     platform_pm_suspend+0x2c/0x78
     dpm_run_callback.isra.25+0x50/0xe8
     __device_suspend+0x108/0x3c0
    
    The basic flow:
            1. run time suspend call xhci_suspend, xhci parent devices gate the clock.
            2. echo mem >/sys/power/state, system _device_suspend call xhci_suspend
            3. xhci_suspend call xhci_disable_hub_port_wake, which access register,
               but clock already gated by run time suspend.
    
    This problem was hidden by power domain driver, which call run time resume before it.
    
    But the below commit remove it and make this issue happen.
            commit c1df456d0f06e ("PM: domains: Don't runtime resume devices at genpd_prepare()")
    
    This patch call run time resume before suspend to make sure clock is on
    before access register.
    
    Reviewed-by: Peter Chen <peter.chen@kernel.org>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Frank Li <Frank.Li@nxp.com>
    Testeb-by: Abel Vesa <abel.vesa@nxp.com>
    Link: https://lore.kernel.org/r/20220110172738.31686-1-Frank.Li@nxp.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 20c51a4c52208f98e27308c456a1951778f41fa5
Author: Frank Li <Frank.Li@nxp.com>
Date:   Mon Jan 10 11:27:38 2022 -0600

    usb: xhci-plat: fix crash when suspend if remote wake enable
    
    commit 9df478463d9feb90dae24f183383961cf123a0ec upstream.
    
    Crashed at i.mx8qm platform when suspend if enable remote wakeup
    
    Internal error: synchronous external abort: 96000210 [#1] PREEMPT SMP
    Modules linked in:
    CPU: 2 PID: 244 Comm: kworker/u12:6 Not tainted 5.15.5-dirty #12
    Hardware name: Freescale i.MX8QM MEK (DT)
    Workqueue: events_unbound async_run_entry_fn
    pstate: 600000c5 (nZCv daIF -PAN -UAO -TCO -DIT -SSBS BTYPE=--)
    pc : xhci_disable_hub_port_wake.isra.62+0x60/0xf8
    lr : xhci_disable_hub_port_wake.isra.62+0x34/0xf8
    sp : ffff80001394bbf0
    x29: ffff80001394bbf0 x28: 0000000000000000 x27: ffff00081193b578
    x26: ffff00081193b570 x25: 0000000000000000 x24: 0000000000000000
    x23: ffff00081193a29c x22: 0000000000020001 x21: 0000000000000001
    x20: 0000000000000000 x19: ffff800014e90490 x18: 0000000000000000
    x17: 0000000000000000 x16: 0000000000000000 x15: 0000000000000000
    x14: 0000000000000000 x13: 0000000000000002 x12: 0000000000000000
    x11: 0000000000000000 x10: 0000000000000960 x9 : ffff80001394baa0
    x8 : ffff0008145d1780 x7 : ffff0008f95b8e80 x6 : 000000001853b453
    x5 : 0000000000000496 x4 : 0000000000000000 x3 : ffff00081193a29c
    x2 : 0000000000000001 x1 : 0000000000000000 x0 : ffff000814591620
    Call trace:
     xhci_disable_hub_port_wake.isra.62+0x60/0xf8
     xhci_suspend+0x58/0x510
     xhci_plat_suspend+0x50/0x78
     platform_pm_suspend+0x2c/0x78
     dpm_run_callback.isra.25+0x50/0xe8
     __device_suspend+0x108/0x3c0
    
    The basic flow:
            1. run time suspend call xhci_suspend, xhci parent devices gate the clock.
            2. echo mem >/sys/power/state, system _device_suspend call xhci_suspend
            3. xhci_suspend call xhci_disable_hub_port_wake, which access register,
               but clock already gated by run time suspend.
    
    This problem was hidden by power domain driver, which call run time resume before it.
    
    But the below commit remove it and make this issue happen.
            commit c1df456d0f06e ("PM: domains: Don't runtime resume devices at genpd_prepare()")
    
    This patch call run time resume before suspend to make sure clock is on
    before access register.
    
    Reviewed-by: Peter Chen <peter.chen@kernel.org>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Frank Li <Frank.Li@nxp.com>
    Testeb-by: Abel Vesa <abel.vesa@nxp.com>
    Link: https://lore.kernel.org/r/20220110172738.31686-1-Frank.Li@nxp.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit b4f4c56459a5c744f7f066b9fc2b54ea995030c5
Author: Kalle Valo <quic_kvalo@quicinc.com>
Date:   Thu Jan 27 11:01:16 2022 +0200

    ath11k: pci: fix crash on suspend if board file is not found
    
    Mario reported that the kernel was crashing on suspend if ath11k was not able
    to find a board file:
    
    [  473.693286] PM: Suspending system (s2idle)
    [  473.693291] printk: Suspending console(s) (use no_console_suspend to debug)
    [  474.407787] BUG: unable to handle page fault for address: 0000000000002070
    [  474.407791] #PF: supervisor read access in kernel mode
    [  474.407794] #PF: error_code(0x0000) - not-present page
    [  474.407798] PGD 0 P4D 0
    [  474.407801] Oops: 0000 [#1] PREEMPT SMP NOPTI
    [  474.407805] CPU: 2 PID: 2350 Comm: kworker/u32:14 Tainted: G        W         5.16.0 #248
    [...]
    [  474.407868] Call Trace:
    [  474.407870]  <TASK>
    [  474.407874]  ? _raw_spin_lock_irqsave+0x2a/0x60
    [  474.407882]  ? lock_timer_base+0x72/0xa0
    [  474.407889]  ? _raw_spin_unlock_irqrestore+0x29/0x3d
    [  474.407892]  ? try_to_del_timer_sync+0x54/0x80
    [  474.407896]  ath11k_dp_rx_pktlog_stop+0x49/0xc0 [ath11k]
    [  474.407912]  ath11k_core_suspend+0x34/0x130 [ath11k]
    [  474.407923]  ath11k_pci_pm_suspend+0x1b/0x50 [ath11k_pci]
    [  474.407928]  pci_pm_suspend+0x7e/0x170
    [  474.407935]  ? pci_pm_freeze+0xc0/0xc0
    [  474.407939]  dpm_run_callback+0x4e/0x150
    [  474.407947]  __device_suspend+0x148/0x4c0
    [  474.407951]  async_suspend+0x20/0x90
    dmesg-efi-164255130401001:
    Oops#1 Part1
    [  474.407955]  async_run_entry_fn+0x33/0x120
    [  474.407959]  process_one_work+0x220/0x3f0
    [  474.407966]  worker_thread+0x4a/0x3d0
    [  474.407971]  kthread+0x17a/0x1a0
    [  474.407975]  ? process_one_work+0x3f0/0x3f0
    [  474.407979]  ? set_kthread_struct+0x40/0x40
    [  474.407983]  ret_from_fork+0x22/0x30
    [  474.407991]  </TASK>
    
    The issue here is that board file loading happens after ath11k_pci_probe()
    succesfully returns (ath11k initialisation happends asynchronously) and the
    suspend handler is still enabled, of course failing as ath11k is not properly
    initialised. Fix this by checking ATH11K_FLAG_QMI_FAIL during both suspend and
    resume.
    
    Tested-on: WCN6855 hw2.0 PCI WLAN.HSP.1.1-03003-QCAHSPSWPL_V1_V2_SILICONZ_LITE-2
    
    Reported-by: Mario Limonciello <mario.limonciello@amd.com>
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=215504
    Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
    Link: https://lore.kernel.org/r/20220127090117.2024-1-kvalo@kernel.org

commit 9a54e17bd8d4015bce7249112ef40e86af01c1fa
Author: Sudeep Holla <sudeep.holla@arm.com>
Date:   Wed Dec 22 17:31:54 2021 +0100

    ACPICA: Fix wrong interpretation of PCC address
    
    [ Upstream commit 9a3b8655db1ada31c82189ae13f40eb25da48c35 ]
    
    ACPICA commit 41be6afacfdaec2dba3a5ed368736babc2a7aa5c
    
    With the PCC Opregion in the firmware and we are hitting below kernel crash:
    
    -->8
    Unable to handle kernel NULL pointer dereference at virtual address 0000000000000010
     Workqueue: pm pm_runtime_work
     pstate: 80000005 (Nzcv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--)
     pc : __memcpy+0x54/0x260
     lr : acpi_ex_write_data_to_field+0xb8/0x194
     Call trace:
      __memcpy+0x54/0x260
      acpi_ex_store_object_to_node+0xa4/0x1d4
      acpi_ex_store+0x44/0x164
      acpi_ex_opcode_1A_1T_1R+0x25c/0x508
      acpi_ds_exec_end_op+0x1b4/0x44c
      acpi_ps_parse_loop+0x3a8/0x614
      acpi_ps_parse_aml+0x90/0x2f4
      acpi_ps_execute_method+0x11c/0x19c
      acpi_ns_evaluate+0x1ec/0x2b0
      acpi_evaluate_object+0x170/0x2b0
      acpi_device_set_power+0x118/0x310
      acpi_dev_suspend+0xd4/0x180
      acpi_subsys_runtime_suspend+0x28/0x38
      __rpm_callback+0x74/0x328
      rpm_suspend+0x2d8/0x624
      pm_runtime_work+0xa4/0xb8
      process_one_work+0x194/0x25c
      worker_thread+0x260/0x49c
      kthread+0x14c/0x30c
      ret_from_fork+0x10/0x20
     Code: f9000006 f81f80a7 d65f03c0 361000c2 (b9400026)
     ---[ end trace 24d8a032fa77b68a ]---
    
    The reason for the crash is that the PCC channel index passed via region.address
    in acpi_ex_store_object_to_node is interpreted as the channel subtype
    incorrectly.
    
    Assuming the PCC op_region support is not used by any other type, let us
    remove the subtype check as the AML has no access to the subtype information.
    Once we remove it, the kernel crash disappears and correctly complains about
    missing PCC Opregion handler.
    
    ACPI Error: No handler for Region [PFRM] ((____ptrval____)) [PCC] (20210730/evregion-130)
    ACPI Error: Region PCC (ID=10) has no handler (20210730/exfldio-261)
    ACPI Error: Aborting method \_SB.ETH0._PS3 due to previous error (AE_NOT_EXIST) (20210730/psparse-531)
    
    Link: https://github.com/acpica/acpica/commit/41be6afa
    Signed-off-by: Sudeep Holla <sudeep.holla@arm.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit a4c7a12027f2fc4dc6346a24fd3ab829e97955a3
Author: Sudeep Holla <sudeep.holla@arm.com>
Date:   Wed Dec 22 17:31:54 2021 +0100

    ACPICA: Fix wrong interpretation of PCC address
    
    [ Upstream commit 9a3b8655db1ada31c82189ae13f40eb25da48c35 ]
    
    ACPICA commit 41be6afacfdaec2dba3a5ed368736babc2a7aa5c
    
    With the PCC Opregion in the firmware and we are hitting below kernel crash:
    
    -->8
    Unable to handle kernel NULL pointer dereference at virtual address 0000000000000010
     Workqueue: pm pm_runtime_work
     pstate: 80000005 (Nzcv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--)
     pc : __memcpy+0x54/0x260
     lr : acpi_ex_write_data_to_field+0xb8/0x194
     Call trace:
      __memcpy+0x54/0x260
      acpi_ex_store_object_to_node+0xa4/0x1d4
      acpi_ex_store+0x44/0x164
      acpi_ex_opcode_1A_1T_1R+0x25c/0x508
      acpi_ds_exec_end_op+0x1b4/0x44c
      acpi_ps_parse_loop+0x3a8/0x614
      acpi_ps_parse_aml+0x90/0x2f4
      acpi_ps_execute_method+0x11c/0x19c
      acpi_ns_evaluate+0x1ec/0x2b0
      acpi_evaluate_object+0x170/0x2b0
      acpi_device_set_power+0x118/0x310
      acpi_dev_suspend+0xd4/0x180
      acpi_subsys_runtime_suspend+0x28/0x38
      __rpm_callback+0x74/0x328
      rpm_suspend+0x2d8/0x624
      pm_runtime_work+0xa4/0xb8
      process_one_work+0x194/0x25c
      worker_thread+0x260/0x49c
      kthread+0x14c/0x30c
      ret_from_fork+0x10/0x20
     Code: f9000006 f81f80a7 d65f03c0 361000c2 (b9400026)
     ---[ end trace 24d8a032fa77b68a ]---
    
    The reason for the crash is that the PCC channel index passed via region.address
    in acpi_ex_store_object_to_node is interpreted as the channel subtype
    incorrectly.
    
    Assuming the PCC op_region support is not used by any other type, let us
    remove the subtype check as the AML has no access to the subtype information.
    Once we remove it, the kernel crash disappears and correctly complains about
    missing PCC Opregion handler.
    
    ACPI Error: No handler for Region [PFRM] ((____ptrval____)) [PCC] (20210730/evregion-130)
    ACPI Error: Region PCC (ID=10) has no handler (20210730/exfldio-261)
    ACPI Error: Aborting method \_SB.ETH0._PS3 due to previous error (AE_NOT_EXIST) (20210730/psparse-531)
    
    Link: https://github.com/acpica/acpica/commit/41be6afa
    Signed-off-by: Sudeep Holla <sudeep.holla@arm.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 8544074762e2675f068617df5fcdeb1a1923f740
Author: Sudeep Holla <sudeep.holla@arm.com>
Date:   Wed Dec 22 17:31:54 2021 +0100

    ACPICA: Fix wrong interpretation of PCC address
    
    [ Upstream commit 9a3b8655db1ada31c82189ae13f40eb25da48c35 ]
    
    ACPICA commit 41be6afacfdaec2dba3a5ed368736babc2a7aa5c
    
    With the PCC Opregion in the firmware and we are hitting below kernel crash:
    
    -->8
    Unable to handle kernel NULL pointer dereference at virtual address 0000000000000010
     Workqueue: pm pm_runtime_work
     pstate: 80000005 (Nzcv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--)
     pc : __memcpy+0x54/0x260
     lr : acpi_ex_write_data_to_field+0xb8/0x194
     Call trace:
      __memcpy+0x54/0x260
      acpi_ex_store_object_to_node+0xa4/0x1d4
      acpi_ex_store+0x44/0x164
      acpi_ex_opcode_1A_1T_1R+0x25c/0x508
      acpi_ds_exec_end_op+0x1b4/0x44c
      acpi_ps_parse_loop+0x3a8/0x614
      acpi_ps_parse_aml+0x90/0x2f4
      acpi_ps_execute_method+0x11c/0x19c
      acpi_ns_evaluate+0x1ec/0x2b0
      acpi_evaluate_object+0x170/0x2b0
      acpi_device_set_power+0x118/0x310
      acpi_dev_suspend+0xd4/0x180
      acpi_subsys_runtime_suspend+0x28/0x38
      __rpm_callback+0x74/0x328
      rpm_suspend+0x2d8/0x624
      pm_runtime_work+0xa4/0xb8
      process_one_work+0x194/0x25c
      worker_thread+0x260/0x49c
      kthread+0x14c/0x30c
      ret_from_fork+0x10/0x20
     Code: f9000006 f81f80a7 d65f03c0 361000c2 (b9400026)
     ---[ end trace 24d8a032fa77b68a ]---
    
    The reason for the crash is that the PCC channel index passed via region.address
    in acpi_ex_store_object_to_node is interpreted as the channel subtype
    incorrectly.
    
    Assuming the PCC op_region support is not used by any other type, let us
    remove the subtype check as the AML has no access to the subtype information.
    Once we remove it, the kernel crash disappears and correctly complains about
    missing PCC Opregion handler.
    
    ACPI Error: No handler for Region [PFRM] ((____ptrval____)) [PCC] (20210730/evregion-130)
    ACPI Error: Region PCC (ID=10) has no handler (20210730/exfldio-261)
    ACPI Error: Aborting method \_SB.ETH0._PS3 due to previous error (AE_NOT_EXIST) (20210730/psparse-531)
    
    Link: https://github.com/acpica/acpica/commit/41be6afa
    Signed-off-by: Sudeep Holla <sudeep.holla@arm.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit de85f5861894854b8c3a5e8fb593b3eb700bdb27
Author: Sudeep Holla <sudeep.holla@arm.com>
Date:   Wed Dec 22 17:31:54 2021 +0100

    ACPICA: Fix wrong interpretation of PCC address
    
    [ Upstream commit 9a3b8655db1ada31c82189ae13f40eb25da48c35 ]
    
    ACPICA commit 41be6afacfdaec2dba3a5ed368736babc2a7aa5c
    
    With the PCC Opregion in the firmware and we are hitting below kernel crash:
    
    -->8
    Unable to handle kernel NULL pointer dereference at virtual address 0000000000000010
     Workqueue: pm pm_runtime_work
     pstate: 80000005 (Nzcv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--)
     pc : __memcpy+0x54/0x260
     lr : acpi_ex_write_data_to_field+0xb8/0x194
     Call trace:
      __memcpy+0x54/0x260
      acpi_ex_store_object_to_node+0xa4/0x1d4
      acpi_ex_store+0x44/0x164
      acpi_ex_opcode_1A_1T_1R+0x25c/0x508
      acpi_ds_exec_end_op+0x1b4/0x44c
      acpi_ps_parse_loop+0x3a8/0x614
      acpi_ps_parse_aml+0x90/0x2f4
      acpi_ps_execute_method+0x11c/0x19c
      acpi_ns_evaluate+0x1ec/0x2b0
      acpi_evaluate_object+0x170/0x2b0
      acpi_device_set_power+0x118/0x310
      acpi_dev_suspend+0xd4/0x180
      acpi_subsys_runtime_suspend+0x28/0x38
      __rpm_callback+0x74/0x328
      rpm_suspend+0x2d8/0x624
      pm_runtime_work+0xa4/0xb8
      process_one_work+0x194/0x25c
      worker_thread+0x260/0x49c
      kthread+0x14c/0x30c
      ret_from_fork+0x10/0x20
     Code: f9000006 f81f80a7 d65f03c0 361000c2 (b9400026)
     ---[ end trace 24d8a032fa77b68a ]---
    
    The reason for the crash is that the PCC channel index passed via region.address
    in acpi_ex_store_object_to_node is interpreted as the channel subtype
    incorrectly.
    
    Assuming the PCC op_region support is not used by any other type, let us
    remove the subtype check as the AML has no access to the subtype information.
    Once we remove it, the kernel crash disappears and correctly complains about
    missing PCC Opregion handler.
    
    ACPI Error: No handler for Region [PFRM] ((____ptrval____)) [PCC] (20210730/evregion-130)
    ACPI Error: Region PCC (ID=10) has no handler (20210730/exfldio-261)
    ACPI Error: Aborting method \_SB.ETH0._PS3 due to previous error (AE_NOT_EXIST) (20210730/psparse-531)
    
    Link: https://github.com/acpica/acpica/commit/41be6afa
    Signed-off-by: Sudeep Holla <sudeep.holla@arm.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 9df478463d9feb90dae24f183383961cf123a0ec
Author: Frank Li <Frank.Li@nxp.com>
Date:   Mon Jan 10 11:27:38 2022 -0600

    usb: xhci-plat: fix crash when suspend if remote wake enable
    
    Crashed at i.mx8qm platform when suspend if enable remote wakeup
    
    Internal error: synchronous external abort: 96000210 [#1] PREEMPT SMP
    Modules linked in:
    CPU: 2 PID: 244 Comm: kworker/u12:6 Not tainted 5.15.5-dirty #12
    Hardware name: Freescale i.MX8QM MEK (DT)
    Workqueue: events_unbound async_run_entry_fn
    pstate: 600000c5 (nZCv daIF -PAN -UAO -TCO -DIT -SSBS BTYPE=--)
    pc : xhci_disable_hub_port_wake.isra.62+0x60/0xf8
    lr : xhci_disable_hub_port_wake.isra.62+0x34/0xf8
    sp : ffff80001394bbf0
    x29: ffff80001394bbf0 x28: 0000000000000000 x27: ffff00081193b578
    x26: ffff00081193b570 x25: 0000000000000000 x24: 0000000000000000
    x23: ffff00081193a29c x22: 0000000000020001 x21: 0000000000000001
    x20: 0000000000000000 x19: ffff800014e90490 x18: 0000000000000000
    x17: 0000000000000000 x16: 0000000000000000 x15: 0000000000000000
    x14: 0000000000000000 x13: 0000000000000002 x12: 0000000000000000
    x11: 0000000000000000 x10: 0000000000000960 x9 : ffff80001394baa0
    x8 : ffff0008145d1780 x7 : ffff0008f95b8e80 x6 : 000000001853b453
    x5 : 0000000000000496 x4 : 0000000000000000 x3 : ffff00081193a29c
    x2 : 0000000000000001 x1 : 0000000000000000 x0 : ffff000814591620
    Call trace:
     xhci_disable_hub_port_wake.isra.62+0x60/0xf8
     xhci_suspend+0x58/0x510
     xhci_plat_suspend+0x50/0x78
     platform_pm_suspend+0x2c/0x78
     dpm_run_callback.isra.25+0x50/0xe8
     __device_suspend+0x108/0x3c0
    
    The basic flow:
            1. run time suspend call xhci_suspend, xhci parent devices gate the clock.
            2. echo mem >/sys/power/state, system _device_suspend call xhci_suspend
            3. xhci_suspend call xhci_disable_hub_port_wake, which access register,
               but clock already gated by run time suspend.
    
    This problem was hidden by power domain driver, which call run time resume before it.
    
    But the below commit remove it and make this issue happen.
            commit c1df456d0f06e ("PM: domains: Don't runtime resume devices at genpd_prepare()")
    
    This patch call run time resume before suspend to make sure clock is on
    before access register.
    
    Reviewed-by: Peter Chen <peter.chen@kernel.org>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Frank Li <Frank.Li@nxp.com>
    Testeb-by: Abel Vesa <abel.vesa@nxp.com>
    Link: https://lore.kernel.org/r/20220110172738.31686-1-Frank.Li@nxp.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 212ad7cb7d7592669c067125949e0a8e31ce6a0b
Author: Wen Gong <quic_wgong@quicinc.com>
Date:   Tue Jan 11 16:42:52 2022 +0200

    ath11k: free peer for station when disconnect from AP for QCA6390/WCN6855
    
    Commit b4a0f54156ac ("ath11k: move peer delete after vdev stop of station
    for QCA6390 and WCN6855") is to fix firmware crash by changing the WMI
    command sequence, but actually skip all the peer delete operation, then
    it lead commit 58595c9874c6 ("ath11k: Fixing dangling pointer issue upon
    peer delete failure") not take effect, and then happened a use-after-free
    warning from KASAN. because the peer->sta is not set to NULL and then used
    later.
    
    Change to only skip the WMI_PEER_DELETE_CMDID for QCA6390/WCN6855.
    
    log of user-after-free:
    
    [  534.888665] BUG: KASAN: use-after-free in ath11k_dp_rx_update_peer_stats+0x912/0xc10 [ath11k]
    [  534.888696] Read of size 8 at addr ffff8881396bb1b8 by task rtcwake/2860
    
    [  534.888705] CPU: 4 PID: 2860 Comm: rtcwake Kdump: loaded Tainted: G        W         5.15.0-wt-ath+ #523
    [  534.888712] Hardware name: Intel(R) Client Systems NUC8i7HVK/NUC8i7HVB, BIOS HNKBLi70.86A.0067.2021.0528.1339 05/28/2021
    [  534.888716] Call Trace:
    [  534.888720]  <IRQ>
    [  534.888726]  dump_stack_lvl+0x57/0x7d
    [  534.888736]  print_address_description.constprop.0+0x1f/0x170
    [  534.888745]  ? ath11k_dp_rx_update_peer_stats+0x912/0xc10 [ath11k]
    [  534.888771]  kasan_report.cold+0x83/0xdf
    [  534.888783]  ? ath11k_dp_rx_update_peer_stats+0x912/0xc10 [ath11k]
    [  534.888810]  ath11k_dp_rx_update_peer_stats+0x912/0xc10 [ath11k]
    [  534.888840]  ath11k_dp_rx_process_mon_status+0x529/0xa70 [ath11k]
    [  534.888874]  ? ath11k_dp_rx_mon_status_bufs_replenish+0x3f0/0x3f0 [ath11k]
    [  534.888897]  ? check_prev_add+0x20f0/0x20f0
    [  534.888922]  ? __lock_acquire+0xb72/0x1870
    [  534.888937]  ? find_held_lock+0x33/0x110
    [  534.888954]  ath11k_dp_rx_process_mon_rings+0x297/0x520 [ath11k]
    [  534.888981]  ? rcu_read_unlock+0x40/0x40
    [  534.888990]  ? ath11k_dp_rx_pdev_alloc+0xd90/0xd90 [ath11k]
    [  534.889026]  ath11k_dp_service_mon_ring+0x67/0xe0 [ath11k]
    [  534.889053]  ? ath11k_dp_rx_process_mon_rings+0x520/0x520 [ath11k]
    [  534.889075]  call_timer_fn+0x167/0x4a0
    [  534.889084]  ? add_timer_on+0x3b0/0x3b0
    [  534.889103]  ? lockdep_hardirqs_on_prepare.part.0+0x18c/0x370
    [  534.889117]  __run_timers.part.0+0x539/0x8b0
    [  534.889123]  ? ath11k_dp_rx_process_mon_rings+0x520/0x520 [ath11k]
    [  534.889157]  ? call_timer_fn+0x4a0/0x4a0
    [  534.889164]  ? mark_lock_irq+0x1c30/0x1c30
    [  534.889173]  ? clockevents_program_event+0xdd/0x280
    [  534.889189]  ? mark_held_locks+0xa5/0xe0
    [  534.889203]  run_timer_softirq+0x97/0x180
    [  534.889213]  __do_softirq+0x276/0x86a
    [  534.889230]  __irq_exit_rcu+0x11c/0x180
    [  534.889238]  irq_exit_rcu+0x5/0x20
    [  534.889244]  sysvec_apic_timer_interrupt+0x8e/0xc0
    [  534.889251]  </IRQ>
    [  534.889254]  <TASK>
    [  534.889259]  asm_sysvec_apic_timer_interrupt+0x12/0x20
    [  534.889265] RIP: 0010:_raw_spin_unlock_irqrestore+0x38/0x70
    [  534.889271] Code: 74 24 10 e8 ea c2 bf fd 48 89 ef e8 12 53 c0 fd 81 e3 00 02 00 00 75 25 9c 58 f6 c4 02 75 2d 48 85 db 74 01 fb bf 01 00 00 00 <e8> 13 a7 b5 fd 65 8b 05 cc d9 9c 5e 85 c0 74 0a 5b 5d c3 e8 a0 ee
    [  534.889276] RSP: 0018:ffffc90002e5f880 EFLAGS: 00000206
    [  534.889284] RAX: 0000000000000006 RBX: 0000000000000200 RCX: ffffffff9f256f10
    [  534.889289] RDX: 0000000000000000 RSI: ffffffffa1c6e420 RDI: 0000000000000001
    [  534.889293] RBP: ffff8881095e6200 R08: 0000000000000001 R09: ffffffffa40d2b8f
    [  534.889298] R10: fffffbfff481a571 R11: 0000000000000001 R12: ffff8881095e6e68
    [  534.889302] R13: ffffc90002e5f908 R14: 0000000000000246 R15: 0000000000000000
    [  534.889316]  ? mark_lock+0xd0/0x14a0
    [  534.889332]  klist_next+0x1d4/0x450
    [  534.889340]  ? dpm_wait_for_subordinate+0x2d0/0x2d0
    [  534.889350]  device_for_each_child+0xa8/0x140
    [  534.889360]  ? device_remove_class_symlinks+0x1b0/0x1b0
    [  534.889370]  ? __lock_release+0x4bd/0x9f0
    [  534.889378]  ? dpm_suspend+0x26b/0x3f0
    [  534.889390]  dpm_wait_for_subordinate+0x82/0x2d0
    [  534.889400]  ? dpm_for_each_dev+0xa0/0xa0
    [  534.889410]  ? dpm_suspend+0x233/0x3f0
    [  534.889427]  __device_suspend+0xd4/0x10c0
    [  534.889440]  ? wait_for_completion_io+0x270/0x270
    [  534.889456]  ? async_suspend_late+0xe0/0xe0
    [  534.889463]  ? async_schedule_node_domain+0x468/0x640
    [  534.889482]  dpm_suspend+0x25a/0x3f0
    [  534.889491]  ? dpm_suspend_end+0x1a0/0x1a0
    [  534.889497]  ? ktime_get+0x214/0x2f0
    [  534.889502]  ? lockdep_hardirqs_on+0x79/0x100
    [  534.889509]  ? recalibrate_cpu_khz+0x10/0x10
    [  534.889516]  ? ktime_get+0x119/0x2f0
    [  534.889528]  dpm_suspend_start+0xab/0xc0
    [  534.889538]  suspend_devices_and_enter+0x1ca/0x350
    [  534.889546]  ? suspend_enter+0x850/0x850
    [  534.889566]  enter_state+0x27c/0x3d7
    [  534.889575]  pm_suspend.cold+0x42/0x189
    [  534.889583]  state_store+0xab/0x160
    [  534.889595]  ? sysfs_file_ops+0x160/0x160
    [  534.889601]  kernfs_fop_write_iter+0x2b5/0x450
    [  534.889615]  new_sync_write+0x36a/0x600
    [  534.889625]  ? new_sync_read+0x600/0x600
    [  534.889639]  ? rcu_read_unlock+0x40/0x40
    [  534.889668]  vfs_write+0x619/0x910
    [  534.889681]  ksys_write+0xf4/0x1d0
    [  534.889689]  ? __ia32_sys_read+0xa0/0xa0
    [  534.889699]  ? lockdep_hardirqs_on_prepare.part.0+0x18c/0x370
    [  534.889707]  ? syscall_enter_from_user_mode+0x1d/0x50
    [  534.889719]  do_syscall_64+0x3b/0x90
    [  534.889725]  entry_SYSCALL_64_after_hwframe+0x44/0xae
    [  534.889731] RIP: 0033:0x7f0b9bc931e7
    [  534.889736] Code: 64 89 02 48 c7 c0 ff ff ff ff eb bb 0f 1f 80 00 00 00 00 f3 0f 1e fa 64 8b 04 25 18 00 00 00 85 c0 75 10 b8 01 00 00 00 0f 05 <48> 3d 00 f0 ff ff 77 51 c3 48 83 ec 28 48 89 54 24 18 48 89 74 24
    [  534.889741] RSP: 002b:00007ffd9d34cc88 EFLAGS: 00000246 ORIG_RAX: 0000000000000001
    [  534.889749] RAX: ffffffffffffffda RBX: 0000000000000004 RCX: 00007f0b9bc931e7
    [  534.889753] RDX: 0000000000000004 RSI: 0000561cd023c5f0 RDI: 0000000000000004
    [  534.889757] RBP: 0000561cd023c5f0 R08: 0000000000000000 R09: 0000000000000004
    [  534.889761] R10: 0000561ccef842a6 R11: 0000000000000246 R12: 0000000000000004
    [  534.889765] R13: 0000561cd0239590 R14: 00007f0b9bd6f4a0 R15: 00007f0b9bd6e8a0
    [  534.889789]  </TASK>
    
    [  534.889796] Allocated by task 2711:
    [  534.889800]  kasan_save_stack+0x1b/0x40
    [  534.889805]  __kasan_kmalloc+0x7c/0x90
    [  534.889810]  sta_info_alloc+0x98/0x1ef0 [mac80211]
    [  534.889874]  ieee80211_prep_connection+0x30b/0x11e0 [mac80211]
    [  534.889950]  ieee80211_mgd_auth+0x529/0xe00 [mac80211]
    [  534.890024]  cfg80211_mlme_auth+0x332/0x6f0 [cfg80211]
    [  534.890090]  nl80211_authenticate+0x839/0xcf0 [cfg80211]
    [  534.890147]  genl_family_rcv_msg_doit+0x1f4/0x2f0
    [  534.890154]  genl_rcv_msg+0x280/0x500
    [  534.890160]  netlink_rcv_skb+0x11c/0x340
    [  534.890165]  genl_rcv+0x1f/0x30
    [  534.890170]  netlink_unicast+0x42b/0x700
    [  534.890176]  netlink_sendmsg+0x71b/0xc60
    [  534.890181]  sock_sendmsg+0xdf/0x110
    [  534.890187]  ____sys_sendmsg+0x5c0/0x850
    [  534.890192]  ___sys_sendmsg+0xe4/0x160
    [  534.890197]  __sys_sendmsg+0xb2/0x140
    [  534.890202]  do_syscall_64+0x3b/0x90
    [  534.890207]  entry_SYSCALL_64_after_hwframe+0x44/0xae
    
    [  534.890215] Freed by task 2825:
    [  534.890218]  kasan_save_stack+0x1b/0x40
    [  534.890223]  kasan_set_track+0x1c/0x30
    [  534.890227]  kasan_set_free_info+0x20/0x30
    [  534.890232]  __kasan_slab_free+0xce/0x100
    [  534.890237]  slab_free_freelist_hook+0xf0/0x1a0
    [  534.890242]  kfree+0xe5/0x370
    [  534.890248]  __sta_info_flush+0x333/0x4b0 [mac80211]
    [  534.890308]  ieee80211_set_disassoc+0x324/0xd20 [mac80211]
    [  534.890382]  ieee80211_mgd_deauth+0x537/0xee0 [mac80211]
    [  534.890472]  cfg80211_mlme_deauth+0x349/0x810 [cfg80211]
    [  534.890526]  cfg80211_mlme_down+0x1ce/0x270 [cfg80211]
    [  534.890578]  cfg80211_disconnect+0x4f5/0x7b0 [cfg80211]
    [  534.890631]  cfg80211_leave+0x24/0x40 [cfg80211]
    [  534.890677]  wiphy_suspend+0x23d/0x2f0 [cfg80211]
    [  534.890723]  dpm_run_callback+0xf4/0x1b0
    [  534.890728]  __device_suspend+0x648/0x10c0
    [  534.890733]  async_suspend+0x16/0xe0
    [  534.890737]  async_run_entry_fn+0x90/0x4f0
    [  534.890741]  process_one_work+0x866/0x1490
    [  534.890747]  worker_thread+0x596/0x1010
    [  534.890751]  kthread+0x35d/0x420
    [  534.890756]  ret_from_fork+0x22/0x30
    
    [  534.890763] The buggy address belongs to the object at ffff8881396ba000
                    which belongs to the cache kmalloc-8k of size 8192
    [  534.890767] The buggy address is located 4536 bytes inside of
                    8192-byte region [ffff8881396ba000, ffff8881396bc000)
    [  534.890772] The buggy address belongs to the page:
    [  534.890775] page:ffffea0004e5ae00 refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x1396b8
    [  534.890780] head:ffffea0004e5ae00 order:3 compound_mapcount:0 compound_pincount:0
    [  534.890784] flags: 0x200000000010200(slab|head|node=0|zone=2)
    [  534.890791] raw: 0200000000010200 ffffea000562be08 ffffea0004b04c08 ffff88810004e340
    [  534.890795] raw: 0000000000000000 0000000000010001 00000001ffffffff 0000000000000000
    [  534.890798] page dumped because: kasan: bad access detected
    
    [  534.890804] Memory state around the buggy address:
    [  534.890807]  ffff8881396bb080: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [  534.890811]  ffff8881396bb100: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [  534.890814] >ffff8881396bb180: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [  534.890817]                                         ^
    [  534.890821]  ffff8881396bb200: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [  534.890824]  ffff8881396bb280: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [  534.890827] ==================================================================
    [  534.890830] Disabling lock debugging due to kernel taint
    
    Tested-on: WCN6855 hw2.0 PCI WLAN.HSP.1.1-01720.1-QCAHSPSWPL_V1_V2_SILICONZ_LITE-1
    
    Fixes: b4a0f54156ac ("ath11k: move peer delete after vdev stop of station for QCA6390 and WCN6855")
    Signed-off-by: Wen Gong <quic_wgong@quicinc.com>
    Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
    Link: https://lore.kernel.org/r/20211222070431.29595-1-quic_wgong@quicinc.com

commit 9a3b8655db1ada31c82189ae13f40eb25da48c35
Author: Sudeep Holla <sudeep.holla@arm.com>
Date:   Wed Dec 22 17:31:54 2021 +0100

    ACPICA: Fix wrong interpretation of PCC address
    
    ACPICA commit 41be6afacfdaec2dba3a5ed368736babc2a7aa5c
    
    With the PCC Opregion in the firmware and we are hitting below kernel crash:
    
    -->8
    Unable to handle kernel NULL pointer dereference at virtual address 0000000000000010
     Workqueue: pm pm_runtime_work
     pstate: 80000005 (Nzcv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--)
     pc : __memcpy+0x54/0x260
     lr : acpi_ex_write_data_to_field+0xb8/0x194
     Call trace:
      __memcpy+0x54/0x260
      acpi_ex_store_object_to_node+0xa4/0x1d4
      acpi_ex_store+0x44/0x164
      acpi_ex_opcode_1A_1T_1R+0x25c/0x508
      acpi_ds_exec_end_op+0x1b4/0x44c
      acpi_ps_parse_loop+0x3a8/0x614
      acpi_ps_parse_aml+0x90/0x2f4
      acpi_ps_execute_method+0x11c/0x19c
      acpi_ns_evaluate+0x1ec/0x2b0
      acpi_evaluate_object+0x170/0x2b0
      acpi_device_set_power+0x118/0x310
      acpi_dev_suspend+0xd4/0x180
      acpi_subsys_runtime_suspend+0x28/0x38
      __rpm_callback+0x74/0x328
      rpm_suspend+0x2d8/0x624
      pm_runtime_work+0xa4/0xb8
      process_one_work+0x194/0x25c
      worker_thread+0x260/0x49c
      kthread+0x14c/0x30c
      ret_from_fork+0x10/0x20
     Code: f9000006 f81f80a7 d65f03c0 361000c2 (b9400026)
     ---[ end trace 24d8a032fa77b68a ]---
    
    The reason for the crash is that the PCC channel index passed via region.address
    in acpi_ex_store_object_to_node is interpreted as the channel subtype
    incorrectly.
    
    Assuming the PCC op_region support is not used by any other type, let us
    remove the subtype check as the AML has no access to the subtype information.
    Once we remove it, the kernel crash disappears and correctly complains about
    missing PCC Opregion handler.
    
    ACPI Error: No handler for Region [PFRM] ((____ptrval____)) [PCC] (20210730/evregion-130)
    ACPI Error: Region PCC (ID=10) has no handler (20210730/exfldio-261)
    ACPI Error: Aborting method \_SB.ETH0._PS3 due to previous error (AE_NOT_EXIST) (20210730/psparse-531)
    
    Link: https://github.com/acpica/acpica/commit/41be6afa
    Signed-off-by: Sudeep Holla <sudeep.holla@arm.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 8f58e29ed7fc37d3ca3e86668e63250a53f51fd7
Author: Kai-Heng Feng <kai.heng.feng@canonical.com>
Date:   Fri Dec 24 16:19:13 2021 +0800

    net: wwan: iosm: Let PCI core handle PCI power transition
    
    pci_pm_suspend_noirq() and pci_pm_resume_noirq() already handle power
    transition for system-wide suspend and resume, so it's not necessary to
    do it in the driver.
    
    Signed-off-by: Kai-Heng Feng <kai.heng.feng@canonical.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 0aeddbd0cb078116c19b8ca511cc1882b581671b
Author: Vaibhav Gupta <vaibhavgupta40@gmail.com>
Date:   Tue Jan 12 13:39:24 2021 +0530

    via-agp: convert to generic power management
    
    Convert via-agp from legacy PCI power management to the generic power
    management framework.
    
    Previously, via-agp used legacy PCI power management, and agp_via_suspend()
    and agp_via_resume() were responsible for both device-specific things and
    generic PCI things:
    
      agp_via_suspend
        pci_save_state(pdev)                <-- generic PCI
        pci_set_power_state(pdev, pci_choose_state(pdev, state)) <-- generic PCI
    
      agp_via_resume
        pci_set_power_state(pdev, PCI_D0)   <-- generic PCI
        pci_restore_state(pdev)             <-- generic PCI
        via_configure_agp3()                <-- device-specific
        via_configure()                     <-- device-specific
    
    With generic power management, the PCI bus PM methods do the generic PCI
    things, and the driver needs only the device-specific part, i.e.,
    
      suspend_devices_and_enter
        dpm_suspend_start(PMSG_SUSPEND)
          pci_pm_suspend                    # PCI bus .suspend() method
            agp_via_suspend                 <-- not needed at all; removed
        suspend_enter
          dpm_suspend_noirq(PMSG_SUSPEND)
            pci_pm_suspend_noirq            # PCI bus .suspend_noirq() method
              pci_save_state                <-- generic PCI
              pci_prepare_to_sleep          <-- generic PCI
                pci_set_power_state
        ...
        dpm_resume_end(PMSG_RESUME)
          pci_pm_resume                     # PCI bus .resume() method
            pci_restore_standard_config
              pci_set_power_state(PCI_D0)   <-- generic PCI
              pci_restore_state             <-- generic PCI
            agp_via_resume                  # dev->driver->pm->resume
              via_configure_agp3()          <-- device-specific
              via_configure()               <-- device-specific
    
    [bhelgaas: commit log]
    Link: https://lore.kernel.org/r/20211208193305.147072-4-helgaas@kernel.org
    Signed-off-by: Vaibhav Gupta <vaibhavgupta40@gmail.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Dave Airlie <airlied@redhat.com>

commit 6d1adc3d46a785cdb3cb0352ec9ad6fee5bb892b
Author: Vaibhav Gupta <vaibhavgupta40@gmail.com>
Date:   Tue Jan 12 13:39:23 2021 +0530

    sis-agp: convert to generic power management
    
    Convert sis-agp from legacy PCI power management to the generic power
    management framework.
    
    Previously, sis-agp used legacy PCI power management, and agp_sis_suspend()
    and agp_sis_resume() were responsible for both device-specific things and
    generic PCI things:
    
      agp_sis_suspend
        pci_save_state(pdev)                <-- generic PCI
        pci_set_power_state(pdev, pci_choose_state(pdev, state)) <-- generic PCI
    
      agp_sis_resume
        pci_set_power_state(pdev, PCI_D0)   <-- generic PCI
        pci_restore_state(pdev)             <-- generic PCI
        sis_driver.configure()              <-- device-specific
    
    With generic power management, the PCI bus PM methods do the generic PCI
    things, and the driver needs only the device-specific part, i.e.,
    
      suspend_devices_and_enter
        dpm_suspend_start(PMSG_SUSPEND)
          pci_pm_suspend                    # PCI bus .suspend() method
            agp_sis_suspend                 <-- not needed at all; removed
        suspend_enter
          dpm_suspend_noirq(PMSG_SUSPEND)
            pci_pm_suspend_noirq            # PCI bus .suspend_noirq() method
              pci_save_state                <-- generic PCI
              pci_prepare_to_sleep          <-- generic PCI
                pci_set_power_state
        ...
        dpm_resume_end(PMSG_RESUME)
          pci_pm_resume                     # PCI bus .resume() method
            pci_restore_standard_config
              pci_set_power_state(PCI_D0)   <-- generic PCI
              pci_restore_state             <-- generic PCI
            agp_sis_resume                  # dev->driver->pm->resume
              sis_driver.configure()        <-- device-specific
    
    [bhelgaas: commit log]
    Link: https://lore.kernel.org/r/20211208193305.147072-3-helgaas@kernel.org
    Signed-off-by: Vaibhav Gupta <vaibhavgupta40@gmail.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Dave Airlie <airlied@redhat.com>

commit ec4e4a6fdc51f11eaa7a919e3e2a5f5a65532a6c
Author: Vaibhav Gupta <vaibhavgupta40@gmail.com>
Date:   Tue Jan 12 13:39:22 2021 +0530

    amd64-agp: convert to generic power management
    
    Convert amd64-agp from legacy PCI power management to the generic power
    management framework.
    
    Previously, amd64-agp used legacy PCI power management, and
    agp_amd64_suspend() and agp_amd64_resume() were responsible for both
    device-specific things and generic PCI things:
    
      agp_amd64_suspend
        pci_save_state(pdev)                <-- generic PCI
        pci_set_power_state(pdev, pci_choose_state(pdev, state)) <-- generic PCI
    
      agp_amd64_resume
        pci_set_power_state(pdev, PCI_D0)   <-- generic PCI
        pci_restore_state(pdev)             <-- generic PCI
        nforce3_agp_init()                  <-- device-specific
        amd_8151_configure()                <-- device-specific
    
    With generic power management, the PCI bus PM methods do the generic PCI
    things, and the driver needs only the device-specific part, i.e.,
    
      suspend_devices_and_enter
        dpm_suspend_start(PMSG_SUSPEND)
          pci_pm_suspend                    # PCI bus .suspend() method
            agp_amd64_suspend               <-- not needed at all; removed
        suspend_enter
          dpm_suspend_noirq(PMSG_SUSPEND)
            pci_pm_suspend_noirq            # PCI bus .suspend_noirq() method
              pci_save_state                <-- generic PCI
              pci_prepare_to_sleep          <-- generic PCI
                pci_set_power_state
        ...
        dpm_resume_end(PMSG_RESUME)
          pci_pm_resume                     # PCI bus .resume() method
            pci_restore_standard_config
              pci_set_power_state(PCI_D0)   <-- generic PCI
              pci_restore_state             <-- generic PCI
            agp_amd64_resume                # dev->driver->pm->resume
              nforce3_agp_init()            <-- device-specific
              amd_8151_configure()          <-- device-specific
    
    [bhelgaas: commit log]
    Link: https://lore.kernel.org/r/20211208193305.147072-2-helgaas@kernel.org
    Signed-off-by: Vaibhav Gupta <vaibhavgupta40@gmail.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Dave Airlie <airlied@redhat.com>

commit cd97b7e0d78009b45e08b92441d9562f9f37968c
Author: Vaibhav Gupta <vaibhavgupta40@gmail.com>
Date:   Wed Dec 8 13:24:48 2021 -0600

    mtip32xx: convert to generic power management
    
    Convert mtip32xx from legacy PCI power management to the generic power
    management framework.
    
    Previously, mtip32xx used legacy PCI power management, where
    mtip_pci_suspend() and mtip_pci_resume() were responsible for both
    device-specific things and generic PCI things:
    
      mtip_pci_suspend
        mtip_block_suspend(dd)              <-- device-specific
        pci_save_state(pdev)                <-- generic PCI
        pci_set_power_state(pdev, pci_choose_state(pdev, state))
    
      mtip_pci_resume
        pci_set_power_state(PCI_D0)         <-- generic PCI
        pci_restore_state(pdev)             <-- generic PCI
        pcim_enable_device(pdev)            <-- generic PCI
        pci_set_master(pdev)                <-- generic PCI
        mtip_block_resume(dd)               <-- device-specific
    
    With generic power management, the PCI bus PM methods do the generic PCI
    things, and the driver needs only the device-specific part, i.e.,
    
      suspend_devices_and_enter
        dpm_suspend_start(PMSG_SUSPEND)
          pci_pm_suspend                    # PCI bus .suspend() method
            mtip_pci_suspend                # dev->driver->pm->suspend
              mtip_block_suspend            <-- device-specific
        suspend_enter
          dpm_suspend_noirq(PMSG_SUSPEND)
            pci_pm_suspend_noirq            # PCI bus .suspend_noirq() method
              pci_save_state                <-- generic PCI
              pci_prepare_to_sleep          <-- generic PCI
                pci_set_power_state
        ...
        dpm_resume_end(PMSG_RESUME)
          pci_pm_resume                     # PCI bus .resume() method
            pci_restore_standard_config
              pci_set_power_state(PCI_D0)   <-- generic PCI
              pci_restore_state             <-- generic PCI
            mtip_pci_resume                 # dev->driver->pm->resume
              mtip_block_resume             <-- device-specific
    
    [bhelgaas: commit log]
    
    Link: https://lore.kernel.org/r/20210114115423.52414-2-vaibhavgupta40@gmail.com
    Signed-off-by: Vaibhav Gupta <vaibhavgupta40@gmail.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Link: https://lore.kernel.org/r/20211208192449.146076-4-helgaas@kernel.org
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

commit 051d89f4dec2bce37a8d5471b0b1ef2796901858
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Nov 4 18:26:26 2021 +0100

    PM: sleep: Avoid calling put_device() under dpm_list_mtx
    
    commit 2aa36604e8243698ff22bd5fef0dd0c6bb07ba92 upstream.
    
    It is generally unsafe to call put_device() with dpm_list_mtx held,
    because the given device's release routine may carry out an action
    depending on that lock which then may deadlock, so modify the
    system-wide suspend and resume of devices to always drop dpm_list_mtx
    before calling put_device() (and adjust white space somewhat while
    at it).
    
    For instance, this prevents the following splat from showing up in
    the kernel log after a system resume in certain configurations:
    
    [ 3290.969514] ======================================================
    [ 3290.969517] WARNING: possible circular locking dependency detected
    [ 3290.969519] 5.15.0+ #2420 Tainted: G S
    [ 3290.969523] ------------------------------------------------------
    [ 3290.969525] systemd-sleep/4553 is trying to acquire lock:
    [ 3290.969529] ffff888117ab1138 ((wq_completion)hci0#2){+.+.}-{0:0}, at: flush_workqueue+0x87/0x4a0
    [ 3290.969554]
                   but task is already holding lock:
    [ 3290.969556] ffffffff8280fca8 (dpm_list_mtx){+.+.}-{3:3}, at: dpm_resume+0x12e/0x3e0
    [ 3290.969571]
                   which lock already depends on the new lock.
    
    [ 3290.969573]
                   the existing dependency chain (in reverse order) is:
    [ 3290.969575]
                   -> #3 (dpm_list_mtx){+.+.}-{3:3}:
    [ 3290.969583]        __mutex_lock+0x9d/0xa30
    [ 3290.969591]        device_pm_add+0x2e/0xe0
    [ 3290.969597]        device_add+0x4d5/0x8f0
    [ 3290.969605]        hci_conn_add_sysfs+0x43/0xb0 [bluetooth]
    [ 3290.969689]        hci_conn_complete_evt.isra.71+0x124/0x750 [bluetooth]
    [ 3290.969747]        hci_event_packet+0xd6c/0x28a0 [bluetooth]
    [ 3290.969798]        hci_rx_work+0x213/0x640 [bluetooth]
    [ 3290.969842]        process_one_work+0x2aa/0x650
    [ 3290.969851]        worker_thread+0x39/0x400
    [ 3290.969859]        kthread+0x142/0x170
    [ 3290.969865]        ret_from_fork+0x22/0x30
    [ 3290.969872]
                   -> #2 (&hdev->lock){+.+.}-{3:3}:
    [ 3290.969881]        __mutex_lock+0x9d/0xa30
    [ 3290.969887]        hci_event_packet+0xba/0x28a0 [bluetooth]
    [ 3290.969935]        hci_rx_work+0x213/0x640 [bluetooth]
    [ 3290.969978]        process_one_work+0x2aa/0x650
    [ 3290.969985]        worker_thread+0x39/0x400
    [ 3290.969993]        kthread+0x142/0x170
    [ 3290.969999]        ret_from_fork+0x22/0x30
    [ 3290.970004]
                   -> #1 ((work_completion)(&hdev->rx_work)){+.+.}-{0:0}:
    [ 3290.970013]        process_one_work+0x27d/0x650
    [ 3290.970020]        worker_thread+0x39/0x400
    [ 3290.970028]        kthread+0x142/0x170
    [ 3290.970033]        ret_from_fork+0x22/0x30
    [ 3290.970038]
                   -> #0 ((wq_completion)hci0#2){+.+.}-{0:0}:
    [ 3290.970047]        __lock_acquire+0x15cb/0x1b50
    [ 3290.970054]        lock_acquire+0x26c/0x300
    [ 3290.970059]        flush_workqueue+0xae/0x4a0
    [ 3290.970066]        drain_workqueue+0xa1/0x130
    [ 3290.970073]        destroy_workqueue+0x34/0x1f0
    [ 3290.970081]        hci_release_dev+0x49/0x180 [bluetooth]
    [ 3290.970130]        bt_host_release+0x1d/0x30 [bluetooth]
    [ 3290.970195]        device_release+0x33/0x90
    [ 3290.970201]        kobject_release+0x63/0x160
    [ 3290.970211]        dpm_resume+0x164/0x3e0
    [ 3290.970215]        dpm_resume_end+0xd/0x20
    [ 3290.970220]        suspend_devices_and_enter+0x1a4/0xba0
    [ 3290.970229]        pm_suspend+0x26b/0x310
    [ 3290.970236]        state_store+0x42/0x90
    [ 3290.970243]        kernfs_fop_write_iter+0x135/0x1b0
    [ 3290.970251]        new_sync_write+0x125/0x1c0
    [ 3290.970257]        vfs_write+0x360/0x3c0
    [ 3290.970263]        ksys_write+0xa7/0xe0
    [ 3290.970269]        do_syscall_64+0x3a/0x80
    [ 3290.970276]        entry_SYSCALL_64_after_hwframe+0x44/0xae
    [ 3290.970284]
                   other info that might help us debug this:
    
    [ 3290.970285] Chain exists of:
                     (wq_completion)hci0#2 --> &hdev->lock --> dpm_list_mtx
    
    [ 3290.970297]  Possible unsafe locking scenario:
    
    [ 3290.970299]        CPU0                    CPU1
    [ 3290.970300]        ----                    ----
    [ 3290.970302]   lock(dpm_list_mtx);
    [ 3290.970306]                                lock(&hdev->lock);
    [ 3290.970310]                                lock(dpm_list_mtx);
    [ 3290.970314]   lock((wq_completion)hci0#2);
    [ 3290.970319]
                    *** DEADLOCK ***
    
    [ 3290.970321] 7 locks held by systemd-sleep/4553:
    [ 3290.970325]  #0: ffff888103bcd448 (sb_writers#4){.+.+}-{0:0}, at: ksys_write+0xa7/0xe0
    [ 3290.970341]  #1: ffff888115a14488 (&of->mutex){+.+.}-{3:3}, at: kernfs_fop_write_iter+0x103/0x1b0
    [ 3290.970355]  #2: ffff888100f719e0 (kn->active#233){.+.+}-{0:0}, at: kernfs_fop_write_iter+0x10c/0x1b0
    [ 3290.970369]  #3: ffffffff82661048 (autosleep_lock){+.+.}-{3:3}, at: state_store+0x12/0x90
    [ 3290.970384]  #4: ffffffff82658ac8 (system_transition_mutex){+.+.}-{3:3}, at: pm_suspend+0x9f/0x310
    [ 3290.970399]  #5: ffffffff827f2a48 (acpi_scan_lock){+.+.}-{3:3}, at: acpi_suspend_begin+0x4c/0x80
    [ 3290.970416]  #6: ffffffff8280fca8 (dpm_list_mtx){+.+.}-{3:3}, at: dpm_resume+0x12e/0x3e0
    [ 3290.970428]
                   stack backtrace:
    [ 3290.970431] CPU: 3 PID: 4553 Comm: systemd-sleep Tainted: G S                5.15.0+ #2420
    [ 3290.970438] Hardware name: Dell Inc. XPS 13 9380/0RYJWW, BIOS 1.5.0 06/03/2019
    [ 3290.970441] Call Trace:
    [ 3290.970446]  dump_stack_lvl+0x44/0x57
    [ 3290.970454]  check_noncircular+0x105/0x120
    [ 3290.970468]  ? __lock_acquire+0x15cb/0x1b50
    [ 3290.970474]  __lock_acquire+0x15cb/0x1b50
    [ 3290.970487]  lock_acquire+0x26c/0x300
    [ 3290.970493]  ? flush_workqueue+0x87/0x4a0
    [ 3290.970503]  ? __raw_spin_lock_init+0x3b/0x60
    [ 3290.970510]  ? lockdep_init_map_type+0x58/0x240
    [ 3290.970519]  flush_workqueue+0xae/0x4a0
    [ 3290.970526]  ? flush_workqueue+0x87/0x4a0
    [ 3290.970544]  ? drain_workqueue+0xa1/0x130
    [ 3290.970552]  drain_workqueue+0xa1/0x130
    [ 3290.970561]  destroy_workqueue+0x34/0x1f0
    [ 3290.970572]  hci_release_dev+0x49/0x180 [bluetooth]
    [ 3290.970624]  bt_host_release+0x1d/0x30 [bluetooth]
    [ 3290.970687]  device_release+0x33/0x90
    [ 3290.970695]  kobject_release+0x63/0x160
    [ 3290.970705]  dpm_resume+0x164/0x3e0
    [ 3290.970710]  ? dpm_resume_early+0x251/0x3b0
    [ 3290.970718]  dpm_resume_end+0xd/0x20
    [ 3290.970723]  suspend_devices_and_enter+0x1a4/0xba0
    [ 3290.970737]  pm_suspend+0x26b/0x310
    [ 3290.970746]  state_store+0x42/0x90
    [ 3290.970755]  kernfs_fop_write_iter+0x135/0x1b0
    [ 3290.970764]  new_sync_write+0x125/0x1c0
    [ 3290.970777]  vfs_write+0x360/0x3c0
    [ 3290.970785]  ksys_write+0xa7/0xe0
    [ 3290.970794]  do_syscall_64+0x3a/0x80
    [ 3290.970803]  entry_SYSCALL_64_after_hwframe+0x44/0xae
    [ 3290.970811] RIP: 0033:0x7f41b1328164
    [ 3290.970819] Code: 00 f7 d8 64 89 02 48 c7 c0 ff ff ff ff eb b7 0f 1f 80 00 00 00 00 8b 05 4a d2 2c 00 48 63 ff 85 c0 75 13 b8 01 00 00 00 0f 05 <48> 3d 00 f0 ff ff 77 54 f3 c3 66 90 55 53 48 89 d5 48 89 f3 48 83
    [ 3290.970824] RSP: 002b:00007ffe6ae21b28 EFLAGS: 00000246 ORIG_RAX: 0000000000000001
    [ 3290.970831] RAX: ffffffffffffffda RBX: 0000000000000004 RCX: 00007f41b1328164
    [ 3290.970836] RDX: 0000000000000004 RSI: 000055965e651070 RDI: 0000000000000004
    [ 3290.970839] RBP: 000055965e651070 R08: 000055965e64f390 R09: 00007f41b1e3d1c0
    [ 3290.970843] R10: 000000000000000a R11: 0000000000000246 R12: 0000000000000004
    [ 3290.970846] R13: 0000000000000001 R14: 000055965e64f2b0 R15: 0000000000000004
    
    Cc: All applicable <stable@vger.kernel.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit e554c13dbe3caaa25558a845816baec77d03da7c
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Nov 4 18:26:26 2021 +0100

    PM: sleep: Avoid calling put_device() under dpm_list_mtx
    
    commit 2aa36604e8243698ff22bd5fef0dd0c6bb07ba92 upstream.
    
    It is generally unsafe to call put_device() with dpm_list_mtx held,
    because the given device's release routine may carry out an action
    depending on that lock which then may deadlock, so modify the
    system-wide suspend and resume of devices to always drop dpm_list_mtx
    before calling put_device() (and adjust white space somewhat while
    at it).
    
    For instance, this prevents the following splat from showing up in
    the kernel log after a system resume in certain configurations:
    
    [ 3290.969514] ======================================================
    [ 3290.969517] WARNING: possible circular locking dependency detected
    [ 3290.969519] 5.15.0+ #2420 Tainted: G S
    [ 3290.969523] ------------------------------------------------------
    [ 3290.969525] systemd-sleep/4553 is trying to acquire lock:
    [ 3290.969529] ffff888117ab1138 ((wq_completion)hci0#2){+.+.}-{0:0}, at: flush_workqueue+0x87/0x4a0
    [ 3290.969554]
                   but task is already holding lock:
    [ 3290.969556] ffffffff8280fca8 (dpm_list_mtx){+.+.}-{3:3}, at: dpm_resume+0x12e/0x3e0
    [ 3290.969571]
                   which lock already depends on the new lock.
    
    [ 3290.969573]
                   the existing dependency chain (in reverse order) is:
    [ 3290.969575]
                   -> #3 (dpm_list_mtx){+.+.}-{3:3}:
    [ 3290.969583]        __mutex_lock+0x9d/0xa30
    [ 3290.969591]        device_pm_add+0x2e/0xe0
    [ 3290.969597]        device_add+0x4d5/0x8f0
    [ 3290.969605]        hci_conn_add_sysfs+0x43/0xb0 [bluetooth]
    [ 3290.969689]        hci_conn_complete_evt.isra.71+0x124/0x750 [bluetooth]
    [ 3290.969747]        hci_event_packet+0xd6c/0x28a0 [bluetooth]
    [ 3290.969798]        hci_rx_work+0x213/0x640 [bluetooth]
    [ 3290.969842]        process_one_work+0x2aa/0x650
    [ 3290.969851]        worker_thread+0x39/0x400
    [ 3290.969859]        kthread+0x142/0x170
    [ 3290.969865]        ret_from_fork+0x22/0x30
    [ 3290.969872]
                   -> #2 (&hdev->lock){+.+.}-{3:3}:
    [ 3290.969881]        __mutex_lock+0x9d/0xa30
    [ 3290.969887]        hci_event_packet+0xba/0x28a0 [bluetooth]
    [ 3290.969935]        hci_rx_work+0x213/0x640 [bluetooth]
    [ 3290.969978]        process_one_work+0x2aa/0x650
    [ 3290.969985]        worker_thread+0x39/0x400
    [ 3290.969993]        kthread+0x142/0x170
    [ 3290.969999]        ret_from_fork+0x22/0x30
    [ 3290.970004]
                   -> #1 ((work_completion)(&hdev->rx_work)){+.+.}-{0:0}:
    [ 3290.970013]        process_one_work+0x27d/0x650
    [ 3290.970020]        worker_thread+0x39/0x400
    [ 3290.970028]        kthread+0x142/0x170
    [ 3290.970033]        ret_from_fork+0x22/0x30
    [ 3290.970038]
                   -> #0 ((wq_completion)hci0#2){+.+.}-{0:0}:
    [ 3290.970047]        __lock_acquire+0x15cb/0x1b50
    [ 3290.970054]        lock_acquire+0x26c/0x300
    [ 3290.970059]        flush_workqueue+0xae/0x4a0
    [ 3290.970066]        drain_workqueue+0xa1/0x130
    [ 3290.970073]        destroy_workqueue+0x34/0x1f0
    [ 3290.970081]        hci_release_dev+0x49/0x180 [bluetooth]
    [ 3290.970130]        bt_host_release+0x1d/0x30 [bluetooth]
    [ 3290.970195]        device_release+0x33/0x90
    [ 3290.970201]        kobject_release+0x63/0x160
    [ 3290.970211]        dpm_resume+0x164/0x3e0
    [ 3290.970215]        dpm_resume_end+0xd/0x20
    [ 3290.970220]        suspend_devices_and_enter+0x1a4/0xba0
    [ 3290.970229]        pm_suspend+0x26b/0x310
    [ 3290.970236]        state_store+0x42/0x90
    [ 3290.970243]        kernfs_fop_write_iter+0x135/0x1b0
    [ 3290.970251]        new_sync_write+0x125/0x1c0
    [ 3290.970257]        vfs_write+0x360/0x3c0
    [ 3290.970263]        ksys_write+0xa7/0xe0
    [ 3290.970269]        do_syscall_64+0x3a/0x80
    [ 3290.970276]        entry_SYSCALL_64_after_hwframe+0x44/0xae
    [ 3290.970284]
                   other info that might help us debug this:
    
    [ 3290.970285] Chain exists of:
                     (wq_completion)hci0#2 --> &hdev->lock --> dpm_list_mtx
    
    [ 3290.970297]  Possible unsafe locking scenario:
    
    [ 3290.970299]        CPU0                    CPU1
    [ 3290.970300]        ----                    ----
    [ 3290.970302]   lock(dpm_list_mtx);
    [ 3290.970306]                                lock(&hdev->lock);
    [ 3290.970310]                                lock(dpm_list_mtx);
    [ 3290.970314]   lock((wq_completion)hci0#2);
    [ 3290.970319]
                    *** DEADLOCK ***
    
    [ 3290.970321] 7 locks held by systemd-sleep/4553:
    [ 3290.970325]  #0: ffff888103bcd448 (sb_writers#4){.+.+}-{0:0}, at: ksys_write+0xa7/0xe0
    [ 3290.970341]  #1: ffff888115a14488 (&of->mutex){+.+.}-{3:3}, at: kernfs_fop_write_iter+0x103/0x1b0
    [ 3290.970355]  #2: ffff888100f719e0 (kn->active#233){.+.+}-{0:0}, at: kernfs_fop_write_iter+0x10c/0x1b0
    [ 3290.970369]  #3: ffffffff82661048 (autosleep_lock){+.+.}-{3:3}, at: state_store+0x12/0x90
    [ 3290.970384]  #4: ffffffff82658ac8 (system_transition_mutex){+.+.}-{3:3}, at: pm_suspend+0x9f/0x310
    [ 3290.970399]  #5: ffffffff827f2a48 (acpi_scan_lock){+.+.}-{3:3}, at: acpi_suspend_begin+0x4c/0x80
    [ 3290.970416]  #6: ffffffff8280fca8 (dpm_list_mtx){+.+.}-{3:3}, at: dpm_resume+0x12e/0x3e0
    [ 3290.970428]
                   stack backtrace:
    [ 3290.970431] CPU: 3 PID: 4553 Comm: systemd-sleep Tainted: G S                5.15.0+ #2420
    [ 3290.970438] Hardware name: Dell Inc. XPS 13 9380/0RYJWW, BIOS 1.5.0 06/03/2019
    [ 3290.970441] Call Trace:
    [ 3290.970446]  dump_stack_lvl+0x44/0x57
    [ 3290.970454]  check_noncircular+0x105/0x120
    [ 3290.970468]  ? __lock_acquire+0x15cb/0x1b50
    [ 3290.970474]  __lock_acquire+0x15cb/0x1b50
    [ 3290.970487]  lock_acquire+0x26c/0x300
    [ 3290.970493]  ? flush_workqueue+0x87/0x4a0
    [ 3290.970503]  ? __raw_spin_lock_init+0x3b/0x60
    [ 3290.970510]  ? lockdep_init_map_type+0x58/0x240
    [ 3290.970519]  flush_workqueue+0xae/0x4a0
    [ 3290.970526]  ? flush_workqueue+0x87/0x4a0
    [ 3290.970544]  ? drain_workqueue+0xa1/0x130
    [ 3290.970552]  drain_workqueue+0xa1/0x130
    [ 3290.970561]  destroy_workqueue+0x34/0x1f0
    [ 3290.970572]  hci_release_dev+0x49/0x180 [bluetooth]
    [ 3290.970624]  bt_host_release+0x1d/0x30 [bluetooth]
    [ 3290.970687]  device_release+0x33/0x90
    [ 3290.970695]  kobject_release+0x63/0x160
    [ 3290.970705]  dpm_resume+0x164/0x3e0
    [ 3290.970710]  ? dpm_resume_early+0x251/0x3b0
    [ 3290.970718]  dpm_resume_end+0xd/0x20
    [ 3290.970723]  suspend_devices_and_enter+0x1a4/0xba0
    [ 3290.970737]  pm_suspend+0x26b/0x310
    [ 3290.970746]  state_store+0x42/0x90
    [ 3290.970755]  kernfs_fop_write_iter+0x135/0x1b0
    [ 3290.970764]  new_sync_write+0x125/0x1c0
    [ 3290.970777]  vfs_write+0x360/0x3c0
    [ 3290.970785]  ksys_write+0xa7/0xe0
    [ 3290.970794]  do_syscall_64+0x3a/0x80
    [ 3290.970803]  entry_SYSCALL_64_after_hwframe+0x44/0xae
    [ 3290.970811] RIP: 0033:0x7f41b1328164
    [ 3290.970819] Code: 00 f7 d8 64 89 02 48 c7 c0 ff ff ff ff eb b7 0f 1f 80 00 00 00 00 8b 05 4a d2 2c 00 48 63 ff 85 c0 75 13 b8 01 00 00 00 0f 05 <48> 3d 00 f0 ff ff 77 54 f3 c3 66 90 55 53 48 89 d5 48 89 f3 48 83
    [ 3290.970824] RSP: 002b:00007ffe6ae21b28 EFLAGS: 00000246 ORIG_RAX: 0000000000000001
    [ 3290.970831] RAX: ffffffffffffffda RBX: 0000000000000004 RCX: 00007f41b1328164
    [ 3290.970836] RDX: 0000000000000004 RSI: 000055965e651070 RDI: 0000000000000004
    [ 3290.970839] RBP: 000055965e651070 R08: 000055965e64f390 R09: 00007f41b1e3d1c0
    [ 3290.970843] R10: 000000000000000a R11: 0000000000000246 R12: 0000000000000004
    [ 3290.970846] R13: 0000000000000001 R14: 000055965e64f2b0 R15: 0000000000000004
    
    Cc: All applicable <stable@vger.kernel.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 2aa36604e8243698ff22bd5fef0dd0c6bb07ba92
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Nov 4 18:26:26 2021 +0100

    PM: sleep: Avoid calling put_device() under dpm_list_mtx
    
    It is generally unsafe to call put_device() with dpm_list_mtx held,
    because the given device's release routine may carry out an action
    depending on that lock which then may deadlock, so modify the
    system-wide suspend and resume of devices to always drop dpm_list_mtx
    before calling put_device() (and adjust white space somewhat while
    at it).
    
    For instance, this prevents the following splat from showing up in
    the kernel log after a system resume in certain configurations:
    
    [ 3290.969514] ======================================================
    [ 3290.969517] WARNING: possible circular locking dependency detected
    [ 3290.969519] 5.15.0+ #2420 Tainted: G S
    [ 3290.969523] ------------------------------------------------------
    [ 3290.969525] systemd-sleep/4553 is trying to acquire lock:
    [ 3290.969529] ffff888117ab1138 ((wq_completion)hci0#2){+.+.}-{0:0}, at: flush_workqueue+0x87/0x4a0
    [ 3290.969554]
                   but task is already holding lock:
    [ 3290.969556] ffffffff8280fca8 (dpm_list_mtx){+.+.}-{3:3}, at: dpm_resume+0x12e/0x3e0
    [ 3290.969571]
                   which lock already depends on the new lock.
    
    [ 3290.969573]
                   the existing dependency chain (in reverse order) is:
    [ 3290.969575]
                   -> #3 (dpm_list_mtx){+.+.}-{3:3}:
    [ 3290.969583]        __mutex_lock+0x9d/0xa30
    [ 3290.969591]        device_pm_add+0x2e/0xe0
    [ 3290.969597]        device_add+0x4d5/0x8f0
    [ 3290.969605]        hci_conn_add_sysfs+0x43/0xb0 [bluetooth]
    [ 3290.969689]        hci_conn_complete_evt.isra.71+0x124/0x750 [bluetooth]
    [ 3290.969747]        hci_event_packet+0xd6c/0x28a0 [bluetooth]
    [ 3290.969798]        hci_rx_work+0x213/0x640 [bluetooth]
    [ 3290.969842]        process_one_work+0x2aa/0x650
    [ 3290.969851]        worker_thread+0x39/0x400
    [ 3290.969859]        kthread+0x142/0x170
    [ 3290.969865]        ret_from_fork+0x22/0x30
    [ 3290.969872]
                   -> #2 (&hdev->lock){+.+.}-{3:3}:
    [ 3290.969881]        __mutex_lock+0x9d/0xa30
    [ 3290.969887]        hci_event_packet+0xba/0x28a0 [bluetooth]
    [ 3290.969935]        hci_rx_work+0x213/0x640 [bluetooth]
    [ 3290.969978]        process_one_work+0x2aa/0x650
    [ 3290.969985]        worker_thread+0x39/0x400
    [ 3290.969993]        kthread+0x142/0x170
    [ 3290.969999]        ret_from_fork+0x22/0x30
    [ 3290.970004]
                   -> #1 ((work_completion)(&hdev->rx_work)){+.+.}-{0:0}:
    [ 3290.970013]        process_one_work+0x27d/0x650
    [ 3290.970020]        worker_thread+0x39/0x400
    [ 3290.970028]        kthread+0x142/0x170
    [ 3290.970033]        ret_from_fork+0x22/0x30
    [ 3290.970038]
                   -> #0 ((wq_completion)hci0#2){+.+.}-{0:0}:
    [ 3290.970047]        __lock_acquire+0x15cb/0x1b50
    [ 3290.970054]        lock_acquire+0x26c/0x300
    [ 3290.970059]        flush_workqueue+0xae/0x4a0
    [ 3290.970066]        drain_workqueue+0xa1/0x130
    [ 3290.970073]        destroy_workqueue+0x34/0x1f0
    [ 3290.970081]        hci_release_dev+0x49/0x180 [bluetooth]
    [ 3290.970130]        bt_host_release+0x1d/0x30 [bluetooth]
    [ 3290.970195]        device_release+0x33/0x90
    [ 3290.970201]        kobject_release+0x63/0x160
    [ 3290.970211]        dpm_resume+0x164/0x3e0
    [ 3290.970215]        dpm_resume_end+0xd/0x20
    [ 3290.970220]        suspend_devices_and_enter+0x1a4/0xba0
    [ 3290.970229]        pm_suspend+0x26b/0x310
    [ 3290.970236]        state_store+0x42/0x90
    [ 3290.970243]        kernfs_fop_write_iter+0x135/0x1b0
    [ 3290.970251]        new_sync_write+0x125/0x1c0
    [ 3290.970257]        vfs_write+0x360/0x3c0
    [ 3290.970263]        ksys_write+0xa7/0xe0
    [ 3290.970269]        do_syscall_64+0x3a/0x80
    [ 3290.970276]        entry_SYSCALL_64_after_hwframe+0x44/0xae
    [ 3290.970284]
                   other info that might help us debug this:
    
    [ 3290.970285] Chain exists of:
                     (wq_completion)hci0#2 --> &hdev->lock --> dpm_list_mtx
    
    [ 3290.970297]  Possible unsafe locking scenario:
    
    [ 3290.970299]        CPU0                    CPU1
    [ 3290.970300]        ----                    ----
    [ 3290.970302]   lock(dpm_list_mtx);
    [ 3290.970306]                                lock(&hdev->lock);
    [ 3290.970310]                                lock(dpm_list_mtx);
    [ 3290.970314]   lock((wq_completion)hci0#2);
    [ 3290.970319]
                    *** DEADLOCK ***
    
    [ 3290.970321] 7 locks held by systemd-sleep/4553:
    [ 3290.970325]  #0: ffff888103bcd448 (sb_writers#4){.+.+}-{0:0}, at: ksys_write+0xa7/0xe0
    [ 3290.970341]  #1: ffff888115a14488 (&of->mutex){+.+.}-{3:3}, at: kernfs_fop_write_iter+0x103/0x1b0
    [ 3290.970355]  #2: ffff888100f719e0 (kn->active#233){.+.+}-{0:0}, at: kernfs_fop_write_iter+0x10c/0x1b0
    [ 3290.970369]  #3: ffffffff82661048 (autosleep_lock){+.+.}-{3:3}, at: state_store+0x12/0x90
    [ 3290.970384]  #4: ffffffff82658ac8 (system_transition_mutex){+.+.}-{3:3}, at: pm_suspend+0x9f/0x310
    [ 3290.970399]  #5: ffffffff827f2a48 (acpi_scan_lock){+.+.}-{3:3}, at: acpi_suspend_begin+0x4c/0x80
    [ 3290.970416]  #6: ffffffff8280fca8 (dpm_list_mtx){+.+.}-{3:3}, at: dpm_resume+0x12e/0x3e0
    [ 3290.970428]
                   stack backtrace:
    [ 3290.970431] CPU: 3 PID: 4553 Comm: systemd-sleep Tainted: G S                5.15.0+ #2420
    [ 3290.970438] Hardware name: Dell Inc. XPS 13 9380/0RYJWW, BIOS 1.5.0 06/03/2019
    [ 3290.970441] Call Trace:
    [ 3290.970446]  dump_stack_lvl+0x44/0x57
    [ 3290.970454]  check_noncircular+0x105/0x120
    [ 3290.970468]  ? __lock_acquire+0x15cb/0x1b50
    [ 3290.970474]  __lock_acquire+0x15cb/0x1b50
    [ 3290.970487]  lock_acquire+0x26c/0x300
    [ 3290.970493]  ? flush_workqueue+0x87/0x4a0
    [ 3290.970503]  ? __raw_spin_lock_init+0x3b/0x60
    [ 3290.970510]  ? lockdep_init_map_type+0x58/0x240
    [ 3290.970519]  flush_workqueue+0xae/0x4a0
    [ 3290.970526]  ? flush_workqueue+0x87/0x4a0
    [ 3290.970544]  ? drain_workqueue+0xa1/0x130
    [ 3290.970552]  drain_workqueue+0xa1/0x130
    [ 3290.970561]  destroy_workqueue+0x34/0x1f0
    [ 3290.970572]  hci_release_dev+0x49/0x180 [bluetooth]
    [ 3290.970624]  bt_host_release+0x1d/0x30 [bluetooth]
    [ 3290.970687]  device_release+0x33/0x90
    [ 3290.970695]  kobject_release+0x63/0x160
    [ 3290.970705]  dpm_resume+0x164/0x3e0
    [ 3290.970710]  ? dpm_resume_early+0x251/0x3b0
    [ 3290.970718]  dpm_resume_end+0xd/0x20
    [ 3290.970723]  suspend_devices_and_enter+0x1a4/0xba0
    [ 3290.970737]  pm_suspend+0x26b/0x310
    [ 3290.970746]  state_store+0x42/0x90
    [ 3290.970755]  kernfs_fop_write_iter+0x135/0x1b0
    [ 3290.970764]  new_sync_write+0x125/0x1c0
    [ 3290.970777]  vfs_write+0x360/0x3c0
    [ 3290.970785]  ksys_write+0xa7/0xe0
    [ 3290.970794]  do_syscall_64+0x3a/0x80
    [ 3290.970803]  entry_SYSCALL_64_after_hwframe+0x44/0xae
    [ 3290.970811] RIP: 0033:0x7f41b1328164
    [ 3290.970819] Code: 00 f7 d8 64 89 02 48 c7 c0 ff ff ff ff eb b7 0f 1f 80 00 00 00 00 8b 05 4a d2 2c 00 48 63 ff 85 c0 75 13 b8 01 00 00 00 0f 05 <48> 3d 00 f0 ff ff 77 54 f3 c3 66 90 55 53 48 89 d5 48 89 f3 48 83
    [ 3290.970824] RSP: 002b:00007ffe6ae21b28 EFLAGS: 00000246 ORIG_RAX: 0000000000000001
    [ 3290.970831] RAX: ffffffffffffffda RBX: 0000000000000004 RCX: 00007f41b1328164
    [ 3290.970836] RDX: 0000000000000004 RSI: 000055965e651070 RDI: 0000000000000004
    [ 3290.970839] RBP: 000055965e651070 R08: 000055965e64f390 R09: 00007f41b1e3d1c0
    [ 3290.970843] R10: 000000000000000a R11: 0000000000000246 R12: 0000000000000004
    [ 3290.970846] R13: 0000000000000001 R14: 000055965e64f2b0 R15: 0000000000000004
    
    Cc: All applicable <stable@vger.kernel.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit a2bd7be12b9edab5736a9a95bceccfbdf7520fdd
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Fri Oct 29 14:38:55 2021 +0200

    PM: sleep: Fix runtime PM based cpuidle support
    
    In the cpuidle-psci case, runtime PM in combination with the generic PM
    domain (genpd), may be used when entering/exiting a shared idlestate. More
    precisely, genpd relies on runtime PM to be enabled for the attached device
    (in this case it belongs to a CPU), to properly manage the reference
    counting of its PM domain.
    
    This works fine most of the time, but during system suspend in
    dpm_suspend_late(), the PM core disables runtime PM for all devices. Beyond
    this point, calls to pm_runtime_get_sync() to runtime resume a device may
    fail and therefore it could also mess up the reference counting in genpd.
    
    To fix this problem, let's call wake_up_all_idle_cpus() in
    dpm_suspend_late(), prior to disabling runtime PM. In this way a device
    that belongs to a CPU, becomes runtime resumed through cpuidle-psci and
    stays like that, because the runtime PM usage count has been bumped in
    device_prepare().
    
    Diagnosed-by: Maulik Shah <mkshah@codeaurora.org>
    Suggested-by: Rafael J. Wysocki <rafael@kernel.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit c55388167775960412fe576a343f4c9001523786
Author: Claudiu Beznea <claudiu.beznea@microchip.com>
Date:   Mon Oct 11 14:27:08 2021 +0300

    clk: at91: clk-master: add register definition for sama7g5's master clock
    
    SAMA7G5 has 4 master clocks (MCK1..4) which are controlled though the
    register at offset 0x30 (relative to PMC). In the last/first phase of
    suspend/resume procedure (which is architecture specific) the parent
    of master clocks are changed (via assembly code) for more power saving
    (see file arch/arm/mach-at91/pm_suspend.S, macros at91_mckx_ps_enable
    and at91_mckx_ps_restore). Thus the macros corresponding to register
    at offset 0x30 need to be shared b/w clk-master.c and pm_suspend.S.
    commit ec03f18cc222 ("clk: at91: add register definition for sama7g5's
    master clock") introduced the proper macros but didn't adapted the
    clk-master.c as well. Thus, this commit adapt the clk-master.c to use
    the macros introduced in commit ec03f18cc222 ("clk: at91: add register
    definition for sama7g5's master clock").
    
    Signed-off-by: Claudiu Beznea <claudiu.beznea@microchip.com>
    Link: https://lore.kernel.org/r/20211011112719.3951784-5-claudiu.beznea@microchip.com
    Acked-by: Nicolas Ferre <nicolas.ferre@microchip.com>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

commit 999522e04054593a724fd76af38e13274b26bd2f
Author: Tony Lindgren <tony@atomide.com>
Date:   Fri Feb 9 08:11:26 2018 -0800

    PM / wakeirq: Fix unbalanced IRQ enable for wakeirq
    
    commit 69728051f5bf15efaf6edfbcfe1b5a49a2437918 upstream.
    
    If a device is runtime PM suspended when we enter suspend and has
    a dedicated wake IRQ, we can get the following warning:
    
    WARNING: CPU: 0 PID: 108 at kernel/irq/manage.c:526 enable_irq+0x40/0x94
    [  102.087860] Unbalanced enable for IRQ 147
    ...
    (enable_irq) from [<c06117a8>] (dev_pm_arm_wake_irq+0x4c/0x60)
    (dev_pm_arm_wake_irq) from [<c0618360>]
     (device_wakeup_arm_wake_irqs+0x58/0x9c)
    (device_wakeup_arm_wake_irqs) from [<c0615948>]
    (dpm_suspend_noirq+0x10/0x48)
    (dpm_suspend_noirq) from [<c01ac7ac>]
    (suspend_devices_and_enter+0x30c/0xf14)
    (suspend_devices_and_enter) from [<c01adf20>]
    (enter_state+0xad4/0xbd8)
    (enter_state) from [<c01ad3ec>] (pm_suspend+0x38/0x98)
    (pm_suspend) from [<c01ab3e8>] (state_store+0x68/0xc8)
    
    This is because the dedicated wake IRQ for the device may have been
    already enabled earlier by dev_pm_enable_wake_irq_check().  Fix the
    issue by checking for runtime PM suspended status.
    
    This issue can be easily reproduced by setting serial console log level
    to zero, letting the serial console idle, and suspend the system from
    an ssh terminal.  On resume, dmesg will have the warning above.
    
    The reason why I have not run into this issue earlier has been that I
    typically run my PM test cases from on a serial console instead over ssh.
    
    Fixes: c84345597558 (PM / wakeirq: Enable dedicated wakeirq for suspend)
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Nobuhiro Iwamatsu (CIP) <nobuhiro1.iwamatsu@toshiba.co.jp>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 14d55678b18681af0f2a72a7c48da8f9e7018aec
Author: Tony Lindgren <tony@atomide.com>
Date:   Fri Feb 9 08:11:26 2018 -0800

    PM / wakeirq: Fix unbalanced IRQ enable for wakeirq
    
    commit 69728051f5bf15efaf6edfbcfe1b5a49a2437918 upstream.
    
    If a device is runtime PM suspended when we enter suspend and has
    a dedicated wake IRQ, we can get the following warning:
    
    WARNING: CPU: 0 PID: 108 at kernel/irq/manage.c:526 enable_irq+0x40/0x94
    [  102.087860] Unbalanced enable for IRQ 147
    ...
    (enable_irq) from [<c06117a8>] (dev_pm_arm_wake_irq+0x4c/0x60)
    (dev_pm_arm_wake_irq) from [<c0618360>]
     (device_wakeup_arm_wake_irqs+0x58/0x9c)
    (device_wakeup_arm_wake_irqs) from [<c0615948>]
    (dpm_suspend_noirq+0x10/0x48)
    (dpm_suspend_noirq) from [<c01ac7ac>]
    (suspend_devices_and_enter+0x30c/0xf14)
    (suspend_devices_and_enter) from [<c01adf20>]
    (enter_state+0xad4/0xbd8)
    (enter_state) from [<c01ad3ec>] (pm_suspend+0x38/0x98)
    (pm_suspend) from [<c01ab3e8>] (state_store+0x68/0xc8)
    
    This is because the dedicated wake IRQ for the device may have been
    already enabled earlier by dev_pm_enable_wake_irq_check().  Fix the
    issue by checking for runtime PM suspended status.
    
    This issue can be easily reproduced by setting serial console log level
    to zero, letting the serial console idle, and suspend the system from
    an ssh terminal.  On resume, dmesg will have the warning above.
    
    The reason why I have not run into this issue earlier has been that I
    typically run my PM test cases from on a serial console instead over ssh.
    
    Fixes: c84345597558 (PM / wakeirq: Enable dedicated wakeirq for suspend)
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Nobuhiro Iwamatsu (CIP) <nobuhiro1.iwamatsu@toshiba.co.jp>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 80e336d29217edf6bc6baa1312b0d002113b12b1
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Mar 5 12:21:40 2021 +0000

    rtc: cmos: Disable irq around direct invocation of cmos_interrupt()
    
    commit 13be2efc390acd2a46a69a359f6efc00ca434599 upstream.
    
    As previously noted in commit 66e4f4a9cc38 ("rtc: cmos: Use
    spin_lock_irqsave() in cmos_interrupt()"):
    
    <4>[  254.192378] WARNING: inconsistent lock state
    <4>[  254.192384] 5.12.0-rc1-CI-CI_DRM_9834+ #1 Not tainted
    <4>[  254.192396] --------------------------------
    <4>[  254.192400] inconsistent {IN-HARDIRQ-W} -> {HARDIRQ-ON-W} usage.
    <4>[  254.192409] rtcwake/5309 [HC0[0]:SC0[0]:HE1:SE1] takes:
    <4>[  254.192429] ffffffff8263c5f8 (rtc_lock){?...}-{2:2}, at: cmos_interrupt+0x18/0x100
    <4>[  254.192481] {IN-HARDIRQ-W} state was registered at:
    <4>[  254.192488]   lock_acquire+0xd1/0x3d0
    <4>[  254.192504]   _raw_spin_lock+0x2a/0x40
    <4>[  254.192519]   cmos_interrupt+0x18/0x100
    <4>[  254.192536]   rtc_handler+0x1f/0xc0
    <4>[  254.192553]   acpi_ev_fixed_event_detect+0x109/0x13c
    <4>[  254.192574]   acpi_ev_sci_xrupt_handler+0xb/0x28
    <4>[  254.192596]   acpi_irq+0x13/0x30
    <4>[  254.192620]   __handle_irq_event_percpu+0x43/0x2c0
    <4>[  254.192641]   handle_irq_event_percpu+0x2b/0x70
    <4>[  254.192661]   handle_irq_event+0x2f/0x50
    <4>[  254.192680]   handle_fasteoi_irq+0x9e/0x150
    <4>[  254.192693]   __common_interrupt+0x76/0x140
    <4>[  254.192715]   common_interrupt+0x96/0xc0
    <4>[  254.192732]   asm_common_interrupt+0x1e/0x40
    <4>[  254.192750]   _raw_spin_unlock_irqrestore+0x38/0x60
    <4>[  254.192767]   resume_irqs+0xba/0xf0
    <4>[  254.192786]   dpm_resume_noirq+0x245/0x3d0
    <4>[  254.192811]   suspend_devices_and_enter+0x230/0xaa0
    <4>[  254.192835]   pm_suspend.cold.8+0x301/0x34a
    <4>[  254.192859]   state_store+0x7b/0xe0
    <4>[  254.192879]   kernfs_fop_write_iter+0x11d/0x1c0
    <4>[  254.192899]   new_sync_write+0x11d/0x1b0
    <4>[  254.192916]   vfs_write+0x265/0x390
    <4>[  254.192933]   ksys_write+0x5a/0xd0
    <4>[  254.192949]   do_syscall_64+0x33/0x80
    <4>[  254.192965]   entry_SYSCALL_64_after_hwframe+0x44/0xae
    <4>[  254.192986] irq event stamp: 43775
    <4>[  254.192994] hardirqs last  enabled at (43775): [<ffffffff81c00c42>] asm_sysvec_apic_timer_interrupt+0x12/0x20
    <4>[  254.193023] hardirqs last disabled at (43774): [<ffffffff81aa691a>] sysvec_apic_timer_interrupt+0xa/0xb0
    <4>[  254.193049] softirqs last  enabled at (42548): [<ffffffff81e00342>] __do_softirq+0x342/0x48e
    <4>[  254.193074] softirqs last disabled at (42543): [<ffffffff810b45fd>] irq_exit_rcu+0xad/0xd0
    <4>[  254.193101]
                      other info that might help us debug this:
    <4>[  254.193107]  Possible unsafe locking scenario:
    
    <4>[  254.193112]        CPU0
    <4>[  254.193117]        ----
    <4>[  254.193121]   lock(rtc_lock);
    <4>[  254.193137]   <Interrupt>
    <4>[  254.193142]     lock(rtc_lock);
    <4>[  254.193156]
                       *** DEADLOCK ***
    
    <4>[  254.193161] 6 locks held by rtcwake/5309:
    <4>[  254.193174]  #0: ffff888104861430 (sb_writers#5){.+.+}-{0:0}, at: ksys_write+0x5a/0xd0
    <4>[  254.193232]  #1: ffff88810f823288 (&of->mutex){+.+.}-{3:3}, at: kernfs_fop_write_iter+0xe7/0x1c0
    <4>[  254.193282]  #2: ffff888100cef3c0 (kn->active#285
    <7>[  254.192706] i915 0000:00:02.0: [drm:intel_modeset_setup_hw_state [i915]] [CRTC:51:pipe A] hw state readout: disabled
    <4>[  254.193307] ){.+.+}-{0:0}, at: kernfs_fop_write_iter+0xf0/0x1c0
    <4>[  254.193333]  #3: ffffffff82649fa8 (system_transition_mutex){+.+.}-{3:3}, at: pm_suspend.cold.8+0xce/0x34a
    <4>[  254.193387]  #4: ffffffff827a2108 (acpi_scan_lock){+.+.}-{3:3}, at: acpi_suspend_begin+0x47/0x70
    <4>[  254.193433]  #5: ffff8881019ea178 (&dev->mutex){....}-{3:3}, at: device_resume+0x68/0x1e0
    <4>[  254.193485]
                      stack backtrace:
    <4>[  254.193492] CPU: 1 PID: 5309 Comm: rtcwake Not tainted 5.12.0-rc1-CI-CI_DRM_9834+ #1
    <4>[  254.193514] Hardware name: Google Soraka/Soraka, BIOS MrChromebox-4.10 08/25/2019
    <4>[  254.193524] Call Trace:
    <4>[  254.193536]  dump_stack+0x7f/0xad
    <4>[  254.193567]  mark_lock.part.47+0x8ca/0xce0
    <4>[  254.193604]  __lock_acquire+0x39b/0x2590
    <4>[  254.193626]  ? asm_sysvec_apic_timer_interrupt+0x12/0x20
    <4>[  254.193660]  lock_acquire+0xd1/0x3d0
    <4>[  254.193677]  ? cmos_interrupt+0x18/0x100
    <4>[  254.193716]  _raw_spin_lock+0x2a/0x40
    <4>[  254.193735]  ? cmos_interrupt+0x18/0x100
    <4>[  254.193758]  cmos_interrupt+0x18/0x100
    <4>[  254.193785]  cmos_resume+0x2ac/0x2d0
    <4>[  254.193813]  ? acpi_pm_set_device_wakeup+0x1f/0x110
    <4>[  254.193842]  ? pnp_bus_suspend+0x10/0x10
    <4>[  254.193864]  pnp_bus_resume+0x5e/0x90
    <4>[  254.193885]  dpm_run_callback+0x5f/0x240
    <4>[  254.193914]  device_resume+0xb2/0x1e0
    <4>[  254.193942]  ? pm_dev_err+0x25/0x25
    <4>[  254.193974]  dpm_resume+0xea/0x3f0
    <4>[  254.194005]  dpm_resume_end+0x8/0x10
    <4>[  254.194030]  suspend_devices_and_enter+0x29b/0xaa0
    <4>[  254.194066]  pm_suspend.cold.8+0x301/0x34a
    <4>[  254.194094]  state_store+0x7b/0xe0
    <4>[  254.194124]  kernfs_fop_write_iter+0x11d/0x1c0
    <4>[  254.194151]  new_sync_write+0x11d/0x1b0
    <4>[  254.194183]  vfs_write+0x265/0x390
    <4>[  254.194207]  ksys_write+0x5a/0xd0
    <4>[  254.194232]  do_syscall_64+0x33/0x80
    <4>[  254.194251]  entry_SYSCALL_64_after_hwframe+0x44/0xae
    <4>[  254.194274] RIP: 0033:0x7f07d79691e7
    <4>[  254.194293] Code: 64 89 02 48 c7 c0 ff ff ff ff eb bb 0f 1f 80 00 00 00 00 f3 0f 1e fa 64 8b 04 25 18 00 00 00 85 c0 75 10 b8 01 00 00 00 0f 05 <48> 3d 00 f0 ff ff 77 51 c3 48 83 ec 28 48 89 54 24 18 48 89 74 24
    <4>[  254.194312] RSP: 002b:00007ffd9cc2c768 EFLAGS: 00000246 ORIG_RAX: 0000000000000001
    <4>[  254.194337] RAX: ffffffffffffffda RBX: 0000000000000004 RCX: 00007f07d79691e7
    <4>[  254.194352] RDX: 0000000000000004 RSI: 0000556ebfc63590 RDI: 000000000000000b
    <4>[  254.194366] RBP: 0000556ebfc63590 R08: 0000000000000000 R09: 0000000000000004
    <4>[  254.194379] R10: 0000556ebf0ec2a6 R11: 0000000000000246 R12: 0000000000000004
    
    which breaks S3-resume on fi-kbl-soraka presumably as that's slow enough
    to trigger the alarm during the suspend.
    
    Fixes: 6950d046eb6e ("rtc: cmos: Replace spin_lock_irqsave with spin_lock in hard IRQ")
    References: 66e4f4a9cc38 ("rtc: cmos: Use spin_lock_irqsave() in cmos_interrupt()"):
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Xiaofei Tan <tanxiaofei@huawei.com>
    Cc: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Cc: Alessandro Zummo <a.zummo@towertech.it>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Link: https://lore.kernel.org/r/20210305122140.28774-1-chris@chris-wilson.co.uk
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 8382463047e6901f02a900a16b52030c593922f3
Author: Chunfeng Yun <chunfeng.yun@mediatek.com>
Date:   Tue Aug 17 16:36:23 2021 +0800

    usb: xhci-mtk: fix use-after-free of mtk->hcd
    
    [ Upstream commit 7f85c16f40d8be5656fb3476909db5c3a5a9c6ea ]
    
     BUG: KASAN: use-after-free in usb_hcd_is_primary_hcd+0x38/0x60
     Call trace:
      dump_backtrace+0x0/0x3dc
      show_stack+0x20/0x2c
      dump_stack+0x15c/0x1d4
      print_address_description+0x7c/0x510
      kasan_report+0x164/0x1ac
      __asan_report_load8_noabort+0x44/0x50
      usb_hcd_is_primary_hcd+0x38/0x60
      xhci_mtk_runtime_suspend+0x68/0x148
      pm_generic_runtime_suspend+0x90/0xac
      __rpm_callback+0xb8/0x1f4
      rpm_callback+0x54/0x1d0
      rpm_suspend+0x4e0/0xc84
      __pm_runtime_suspend+0xc4/0x114
      xhci_mtk_probe+0xa58/0xd00
    
    This may happen when probe fails, needn't suspend it synchronously,
    fix it by using pm_runtime_put_noidle().
    
    Reported-by: Pi Hsun <pihsun@google.com>
    Signed-off-by: Chunfeng Yun <chunfeng.yun@mediatek.com>
    Link: https://lore.kernel.org/r/1629189389-18779-3-git-send-email-chunfeng.yun@mediatek.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 2307e86bfaac20e2e30e9bcd0881abd737201f13
Author: Chunfeng Yun <chunfeng.yun@mediatek.com>
Date:   Tue Aug 17 16:36:23 2021 +0800

    usb: xhci-mtk: fix use-after-free of mtk->hcd
    
    [ Upstream commit 7f85c16f40d8be5656fb3476909db5c3a5a9c6ea ]
    
     BUG: KASAN: use-after-free in usb_hcd_is_primary_hcd+0x38/0x60
     Call trace:
      dump_backtrace+0x0/0x3dc
      show_stack+0x20/0x2c
      dump_stack+0x15c/0x1d4
      print_address_description+0x7c/0x510
      kasan_report+0x164/0x1ac
      __asan_report_load8_noabort+0x44/0x50
      usb_hcd_is_primary_hcd+0x38/0x60
      xhci_mtk_runtime_suspend+0x68/0x148
      pm_generic_runtime_suspend+0x90/0xac
      __rpm_callback+0xb8/0x1f4
      rpm_callback+0x54/0x1d0
      rpm_suspend+0x4e0/0xc84
      __pm_runtime_suspend+0xc4/0x114
      xhci_mtk_probe+0xa58/0xd00
    
    This may happen when probe fails, needn't suspend it synchronously,
    fix it by using pm_runtime_put_noidle().
    
    Reported-by: Pi Hsun <pihsun@google.com>
    Signed-off-by: Chunfeng Yun <chunfeng.yun@mediatek.com>
    Link: https://lore.kernel.org/r/1629189389-18779-3-git-send-email-chunfeng.yun@mediatek.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 301de697d869be6564aebeb5ab811c84c0a7abed
Author: Vladimir Oltean <vladimir.oltean@nxp.com>
Date:   Tue Sep 14 17:05:15 2021 +0300

    Revert "net: phy: Uniform PHY driver access"
    
    This reverts commit 3ac8eed62596387214869319379c1fcba264d8c6, which did
    more than it said on the box, and not only it replaced to_phy_driver
    with phydev->drv, but it also removed the "!drv" check, without actually
    explaining why that is fine.
    
    That patch in fact breaks suspend/resume on any system which has PHY
    devices with no drivers bound.
    
    The stack trace is:
    
    Unable to handle kernel NULL pointer dereference at virtual address 00000000000000e8
    pc : mdio_bus_phy_suspend+0xd8/0xec
    lr : dpm_run_callback+0x38/0x90
    Call trace:
     mdio_bus_phy_suspend+0xd8/0xec
     dpm_run_callback+0x38/0x90
     __device_suspend+0x108/0x3cc
     dpm_suspend+0x140/0x210
     dpm_suspend_start+0x7c/0xa0
     suspend_devices_and_enter+0x13c/0x540
     pm_suspend+0x2a4/0x330
    
    Examples why that assumption is not fine:
    
    - There is an MDIO bus with a PHY device that doesn't have a specific
      PHY driver loaded, because mdiobus_register() automatically creates a
      PHY device for it but there is no specific PHY driver in the system.
      Normally under those circumstances, the generic PHY driver will be
      bound lazily to it (at phy_attach_direct time). But some Ethernet
      drivers attach to their PHY at .ndo_open time. Until then it, the
      to-be-driven-by-genphy PHY device will not have a driver. The blamed
      patch amounts to saying "you need to open all net devices before the
      system can suspend, to avoid the NULL pointer dereference".
    
    - There is any raw MDIO device which has 'plausible' values in the PHY
      ID registers 2 and 3, which is located on an MDIO bus whose driver
      does not set bus->phy_mask = ~0 (which prevents auto-scanning of PHY
      devices). An example could be a MAC's internal MDIO bus with PCS
      devices on it, for serial links such as SGMII. PHY devices will get
      created for those PCSes too, due to that MDIO bus auto-scanning, and
      although those PHY devices are not used, they do not bother anybody
      either. PCS devices are usually managed in Linux as raw MDIO devices.
      Nonetheless, they do not have a PHY driver, nor does anybody attempt
      to connect to them (because they are not a PHY), and therefore this
      patch breaks that.
    
    The goal itself of the patch is questionable, so I am going for a
    straight revert. to_phy_driver does not seem to have a need to be
    replaced by phydev->drv, in fact that might even trigger code paths
    which were not given too deep of a thought.
    
    For instance:
    
    phy_probe populates phydev->drv at the beginning, but does not clean it
    up on any error (including EPROBE_DEFER). So if the phydev driver
    requests probe deferral, phydev->drv will remain populated despite there
    being no driver bound.
    
    If a system suspend starts in between the initial probe deferral request
    and the subsequent probe retry, we will be calling the phydev->drv->suspend
    method, but _before_ any phydev->drv->probe call has succeeded.
    
    That is to say, if the phydev->drv is allocating any driver-private data
    structure in ->probe, it pretty much expects that data structure to be
    available in ->suspend. But it may not. That is a pretty insane
    environment to present to PHY drivers.
    
    In the code structure before the blamed patch, mdio_bus_phy_may_suspend
    would just say "no, don't suspend" to any PHY device which does not have
    a driver pointer _in_the_device_structure_ (not the phydev->drv). That
    would essentially ensure that ->suspend will never get called for a
    device that has not yet successfully completed probe. This is the code
    structure the patch is returning to, via the revert.
    
    Fixes: 3ac8eed62596 ("net: phy: Uniform PHY driver access")
    Signed-off-by: Vladimir Oltean <vladimir.oltean@nxp.com>
    Acked-by: Florian Fainelli <f.fainelli@gmail.com>
    Link: https://lore.kernel.org/r/20210914140515.2311548-1-vladimir.oltean@nxp.com
    Signed-off-by: Jakub Kicinski <kuba@kernel.org>

commit 13be2efc390acd2a46a69a359f6efc00ca434599
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Mar 5 12:21:40 2021 +0000

    rtc: cmos: Disable irq around direct invocation of cmos_interrupt()
    
    As previously noted in commit 66e4f4a9cc38 ("rtc: cmos: Use
    spin_lock_irqsave() in cmos_interrupt()"):
    
    <4>[  254.192378] WARNING: inconsistent lock state
    <4>[  254.192384] 5.12.0-rc1-CI-CI_DRM_9834+ #1 Not tainted
    <4>[  254.192396] --------------------------------
    <4>[  254.192400] inconsistent {IN-HARDIRQ-W} -> {HARDIRQ-ON-W} usage.
    <4>[  254.192409] rtcwake/5309 [HC0[0]:SC0[0]:HE1:SE1] takes:
    <4>[  254.192429] ffffffff8263c5f8 (rtc_lock){?...}-{2:2}, at: cmos_interrupt+0x18/0x100
    <4>[  254.192481] {IN-HARDIRQ-W} state was registered at:
    <4>[  254.192488]   lock_acquire+0xd1/0x3d0
    <4>[  254.192504]   _raw_spin_lock+0x2a/0x40
    <4>[  254.192519]   cmos_interrupt+0x18/0x100
    <4>[  254.192536]   rtc_handler+0x1f/0xc0
    <4>[  254.192553]   acpi_ev_fixed_event_detect+0x109/0x13c
    <4>[  254.192574]   acpi_ev_sci_xrupt_handler+0xb/0x28
    <4>[  254.192596]   acpi_irq+0x13/0x30
    <4>[  254.192620]   __handle_irq_event_percpu+0x43/0x2c0
    <4>[  254.192641]   handle_irq_event_percpu+0x2b/0x70
    <4>[  254.192661]   handle_irq_event+0x2f/0x50
    <4>[  254.192680]   handle_fasteoi_irq+0x9e/0x150
    <4>[  254.192693]   __common_interrupt+0x76/0x140
    <4>[  254.192715]   common_interrupt+0x96/0xc0
    <4>[  254.192732]   asm_common_interrupt+0x1e/0x40
    <4>[  254.192750]   _raw_spin_unlock_irqrestore+0x38/0x60
    <4>[  254.192767]   resume_irqs+0xba/0xf0
    <4>[  254.192786]   dpm_resume_noirq+0x245/0x3d0
    <4>[  254.192811]   suspend_devices_and_enter+0x230/0xaa0
    <4>[  254.192835]   pm_suspend.cold.8+0x301/0x34a
    <4>[  254.192859]   state_store+0x7b/0xe0
    <4>[  254.192879]   kernfs_fop_write_iter+0x11d/0x1c0
    <4>[  254.192899]   new_sync_write+0x11d/0x1b0
    <4>[  254.192916]   vfs_write+0x265/0x390
    <4>[  254.192933]   ksys_write+0x5a/0xd0
    <4>[  254.192949]   do_syscall_64+0x33/0x80
    <4>[  254.192965]   entry_SYSCALL_64_after_hwframe+0x44/0xae
    <4>[  254.192986] irq event stamp: 43775
    <4>[  254.192994] hardirqs last  enabled at (43775): [<ffffffff81c00c42>] asm_sysvec_apic_timer_interrupt+0x12/0x20
    <4>[  254.193023] hardirqs last disabled at (43774): [<ffffffff81aa691a>] sysvec_apic_timer_interrupt+0xa/0xb0
    <4>[  254.193049] softirqs last  enabled at (42548): [<ffffffff81e00342>] __do_softirq+0x342/0x48e
    <4>[  254.193074] softirqs last disabled at (42543): [<ffffffff810b45fd>] irq_exit_rcu+0xad/0xd0
    <4>[  254.193101]
                      other info that might help us debug this:
    <4>[  254.193107]  Possible unsafe locking scenario:
    
    <4>[  254.193112]        CPU0
    <4>[  254.193117]        ----
    <4>[  254.193121]   lock(rtc_lock);
    <4>[  254.193137]   <Interrupt>
    <4>[  254.193142]     lock(rtc_lock);
    <4>[  254.193156]
                       *** DEADLOCK ***
    
    <4>[  254.193161] 6 locks held by rtcwake/5309:
    <4>[  254.193174]  #0: ffff888104861430 (sb_writers#5){.+.+}-{0:0}, at: ksys_write+0x5a/0xd0
    <4>[  254.193232]  #1: ffff88810f823288 (&of->mutex){+.+.}-{3:3}, at: kernfs_fop_write_iter+0xe7/0x1c0
    <4>[  254.193282]  #2: ffff888100cef3c0 (kn->active#285
    <7>[  254.192706] i915 0000:00:02.0: [drm:intel_modeset_setup_hw_state [i915]] [CRTC:51:pipe A] hw state readout: disabled
    <4>[  254.193307] ){.+.+}-{0:0}, at: kernfs_fop_write_iter+0xf0/0x1c0
    <4>[  254.193333]  #3: ffffffff82649fa8 (system_transition_mutex){+.+.}-{3:3}, at: pm_suspend.cold.8+0xce/0x34a
    <4>[  254.193387]  #4: ffffffff827a2108 (acpi_scan_lock){+.+.}-{3:3}, at: acpi_suspend_begin+0x47/0x70
    <4>[  254.193433]  #5: ffff8881019ea178 (&dev->mutex){....}-{3:3}, at: device_resume+0x68/0x1e0
    <4>[  254.193485]
                      stack backtrace:
    <4>[  254.193492] CPU: 1 PID: 5309 Comm: rtcwake Not tainted 5.12.0-rc1-CI-CI_DRM_9834+ #1
    <4>[  254.193514] Hardware name: Google Soraka/Soraka, BIOS MrChromebox-4.10 08/25/2019
    <4>[  254.193524] Call Trace:
    <4>[  254.193536]  dump_stack+0x7f/0xad
    <4>[  254.193567]  mark_lock.part.47+0x8ca/0xce0
    <4>[  254.193604]  __lock_acquire+0x39b/0x2590
    <4>[  254.193626]  ? asm_sysvec_apic_timer_interrupt+0x12/0x20
    <4>[  254.193660]  lock_acquire+0xd1/0x3d0
    <4>[  254.193677]  ? cmos_interrupt+0x18/0x100
    <4>[  254.193716]  _raw_spin_lock+0x2a/0x40
    <4>[  254.193735]  ? cmos_interrupt+0x18/0x100
    <4>[  254.193758]  cmos_interrupt+0x18/0x100
    <4>[  254.193785]  cmos_resume+0x2ac/0x2d0
    <4>[  254.193813]  ? acpi_pm_set_device_wakeup+0x1f/0x110
    <4>[  254.193842]  ? pnp_bus_suspend+0x10/0x10
    <4>[  254.193864]  pnp_bus_resume+0x5e/0x90
    <4>[  254.193885]  dpm_run_callback+0x5f/0x240
    <4>[  254.193914]  device_resume+0xb2/0x1e0
    <4>[  254.193942]  ? pm_dev_err+0x25/0x25
    <4>[  254.193974]  dpm_resume+0xea/0x3f0
    <4>[  254.194005]  dpm_resume_end+0x8/0x10
    <4>[  254.194030]  suspend_devices_and_enter+0x29b/0xaa0
    <4>[  254.194066]  pm_suspend.cold.8+0x301/0x34a
    <4>[  254.194094]  state_store+0x7b/0xe0
    <4>[  254.194124]  kernfs_fop_write_iter+0x11d/0x1c0
    <4>[  254.194151]  new_sync_write+0x11d/0x1b0
    <4>[  254.194183]  vfs_write+0x265/0x390
    <4>[  254.194207]  ksys_write+0x5a/0xd0
    <4>[  254.194232]  do_syscall_64+0x33/0x80
    <4>[  254.194251]  entry_SYSCALL_64_after_hwframe+0x44/0xae
    <4>[  254.194274] RIP: 0033:0x7f07d79691e7
    <4>[  254.194293] Code: 64 89 02 48 c7 c0 ff ff ff ff eb bb 0f 1f 80 00 00 00 00 f3 0f 1e fa 64 8b 04 25 18 00 00 00 85 c0 75 10 b8 01 00 00 00 0f 05 <48> 3d 00 f0 ff ff 77 51 c3 48 83 ec 28 48 89 54 24 18 48 89 74 24
    <4>[  254.194312] RSP: 002b:00007ffd9cc2c768 EFLAGS: 00000246 ORIG_RAX: 0000000000000001
    <4>[  254.194337] RAX: ffffffffffffffda RBX: 0000000000000004 RCX: 00007f07d79691e7
    <4>[  254.194352] RDX: 0000000000000004 RSI: 0000556ebfc63590 RDI: 000000000000000b
    <4>[  254.194366] RBP: 0000556ebfc63590 R08: 0000000000000000 R09: 0000000000000004
    <4>[  254.194379] R10: 0000556ebf0ec2a6 R11: 0000000000000246 R12: 0000000000000004
    
    which breaks S3-resume on fi-kbl-soraka presumably as that's slow enough
    to trigger the alarm during the suspend.
    
    Fixes: 6950d046eb6e ("rtc: cmos: Replace spin_lock_irqsave with spin_lock in hard IRQ")
    References: 66e4f4a9cc38 ("rtc: cmos: Use spin_lock_irqsave() in cmos_interrupt()"):
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Xiaofei Tan <tanxiaofei@huawei.com>
    Cc: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Cc: Alessandro Zummo <a.zummo@towertech.it>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Link: https://lore.kernel.org/r/20210305122140.28774-1-chris@chris-wilson.co.uk

commit 05366fb0bfd1f19114cb99a6007b79fea9069ed5
Author: Borislav Petkov <bp@suse.de>
Date:   Tue Aug 24 11:42:47 2021 +0200

    drm/amdgpu: Fix build with missing pm_suspend_target_state module export
    
    commit c41a4e877a185241d8e83501453326fb98f67354 upstream.
    
    Building a randconfig here triggered:
    
      ERROR: modpost: "pm_suspend_target_state" [drivers/gpu/drm/amd/amdgpu/amdgpu.ko] undefined!
    
    because the module export of that symbol happens in
    kernel/power/suspend.c which is enabled with CONFIG_SUSPEND.
    
    The ifdef guards in amdgpu_acpi_is_s0ix_supported(), however, test for
    CONFIG_PM_SLEEP which is defined like this:
    
      config PM_SLEEP
              def_bool y
              depends on SUSPEND || HIBERNATE_CALLBACKS
    
    and that randconfig has:
    
      # CONFIG_SUSPEND is not set
      CONFIG_HIBERNATE_CALLBACKS=y
    
    leading to the module export missing.
    
    Change the ifdeffery to depend directly on CONFIG_SUSPEND.
    
    Fixes: 5706cb3c910c ("drm/amdgpu: fix checking pmops when PM_SLEEP is not enabled")
    Reviewed-by: Lijo Lazar <lijo.lazar@amd.com>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Link: https://lkml.kernel.org/r/YSP6Lv53QV0cOAsd@zn.tnic
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 477f70cd2a67904e04c2c2b9bd0fa2e95222f2f6
Merge: 835d31d319d9 8f0284f190e6
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Sep 1 11:26:46 2021 -0700

    Merge tag 'drm-next-2021-08-31-1' of git://anongit.freedesktop.org/drm/drm
    
    Pull drm updates from Dave Airlie:
     "Highlights:
    
       - i915 has seen a lot of refactoring and uAPI cleanups due to a
         change in the upstream direction going forward
    
         This has all been audited with known userspace, but there may be
         some pitfalls that were missed.
    
       - i915 now uses common TTM to enable discrete memory on DG1/2 GPUs
    
       - i915 enables Jasper and Elkhart Lake by default and has preliminary
         XeHP/DG2 support
    
       - amdgpu adds support for Cyan Skillfish
    
       - lots of implicit fencing rules documented and fixed up in drivers
    
       - msm now uses the core scheduler
    
       - the irq midlayer has been removed for non-legacy drivers
    
       - the sysfb code now works on more than x86.
    
      Otherwise the usual smattering of stuff everywhere, panels, bridges,
      refactorings.
    
      Detailed summary:
    
      core:
       - extract i915 eDP backlight into core
       - DP aux bus support
       - drm_device.irq_enabled removed
       - port drivers to native irq interfaces
       - export gem shadow plane handling for vgem
       - print proper driver name in framebuffer registration
       - driver fixes for implicit fencing rules
       - ARM fixed rate compression modifier added
       - updated fb damage handling
       - rmfb ioctl logging/docs
       - drop drm_gem_object_put_locked
       - define DRM_FORMAT_MAX_PLANES
       - add gem fb vmap/vunmap helpers
       - add lockdep_assert(once) helpers
       - mark drm irq midlayer as legacy
       - use offset adjusted bo mapping conversion
    
      vgaarb:
       - cleanups
    
      fbdev:
       - extend efifb handling to all arches
       - div by 0 fixes for multiple drivers
    
      udmabuf:
       - add hugepage mapping support
    
      dma-buf:
       - non-dynamic exporter fixups
       - document implicit fencing rules
    
      amdgpu:
       - Initial Cyan Skillfish support
       - switch virtual DCE over to vkms based atomic
       - VCN/JPEG power down fixes
       - NAVI PCIE link handling fixes
       - AMD HDMI freesync fixes
       - Yellow Carp + Beige Goby fixes
       - Clockgating/S0ix/SMU/EEPROM fixes
       - embed hw fence in job
       - rework dma-resv handling
       - ensure eviction to system ram
    
      amdkfd:
       - uapi: SVM address range query added
       - sysfs leak fix
       - GPUVM TLB optimizations
       - vmfault/migration counters
    
      i915:
       - Enable JSL and EHL by default
       - preliminary XeHP/DG2 support
       - remove all CNL support (never shipped)
       - move to TTM for discrete memory support
       - allow mixed object mmap handling
       - GEM uAPI spring cleaning
           - add I915_MMAP_OBJECT_FIXED
           - reinstate ADL-P mmap ioctls
           - drop a bunch of unused by userspace features
           - disable and remove GPU relocations
       - revert some i915 misfeatures
       - major refactoring of GuC for Gen11+
       - execbuffer object locking separate step
       - reject caching/set-domain on discrete
       - Enable pipe DMC loading on XE-LPD and ADL-P
       - add PSF GV point support
       - Refactor and fix DDI buffer translations
       - Clean up FBC CFB allocation code
       - Finish INTEL_GEN() and friends macro conversions
    
      nouveau:
       - add eDP backlight support
       - implicit fence fix
    
      msm:
       - a680/7c3 support
       - drm/scheduler conversion
    
      panfrost:
       - rework GPU reset
    
      virtio:
       - fix fencing for planes
    
      ast:
       - add detect support
    
      bochs:
       - move to tiny GPU driver
    
      vc4:
       - use hotplug irqs
       - HDMI codec support
    
      vmwgfx:
       - use internal vmware device headers
    
      ingenic:
       - demidlayering irq
    
      rcar-du:
       - shutdown fixes
       - convert to bridge connector helpers
    
      zynqmp-dsub:
       - misc fixes
    
      mgag200:
       - convert PLL handling to atomic
    
      mediatek:
       - MT8133 AAL support
       - gem mmap object support
       - MT8167 support
    
      etnaviv:
       - NXP Layerscape LS1028A SoC support
       - GEM mmap cleanups
    
      tegra:
       - new user API
    
      exynos:
       - missing unlock fix
       - build warning fix
       - use refcount_t"
    
    * tag 'drm-next-2021-08-31-1' of git://anongit.freedesktop.org/drm/drm: (1318 commits)
      drm/amd/display: Move AllowDRAMSelfRefreshOrDRAMClockChangeInVblank to bounding box
      drm/amd/display: Remove duplicate dml init
      drm/amd/display: Update bounding box states (v2)
      drm/amd/display: Update number of DCN3 clock states
      drm/amdgpu: disable GFX CGCG in aldebaran
      drm/amdgpu: Clear RAS interrupt status on aldebaran
      drm/amdgpu: Add support for RAS XGMI err query
      drm/amdkfd: Account for SH/SE count when setting up cu masks.
      drm/amdgpu: rename amdgpu_bo_get_preferred_pin_domain
      drm/amdgpu: drop redundant cancel_delayed_work_sync call
      drm/amdgpu: add missing cleanups for more ASICs on UVD/VCE suspend
      drm/amdgpu: add missing cleanups for Polaris12 UVD/VCE on suspend
      drm/amdkfd: map SVM range with correct access permission
      drm/amdkfd: check access permisson to restore retry fault
      drm/amdgpu: Update RAS XGMI Error Query
      drm/amdgpu: Add driver infrastructure for MCA RAS
      drm/amd/display: Add Logging for HDMI color depth information
      drm/amd/amdgpu: consolidate PSP TA init shared buf functions
      drm/amd/amdgpu: add name field back to ras_common_if
      drm/amdgpu: Fix build with missing pm_suspend_target_state module export
      ...

commit 77dd11439b86e3f7990e4c0c9e0b67dca82750ba
Merge: 73367f05b25d 9fe4f5a24fda
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Aug 26 18:44:25 2021 -0700

    Merge tag 'drm-fixes-2021-08-27' of git://anongit.freedesktop.org/drm/drm
    
    Pull drm fixes from Dave Airlie:
     "Last set of fixes for 5.14, nothing major a couple of i915, couple of
      imx and a few amdgpu. All pretty small.
    
      i915:
       - Fix syncmap memory leak
       - Drop redundant display port debug print
    
      amdgpu:
       - Fix for pinning display buffers multiple times
       - Fix delayed work handling for GFXOFF
       - Fix build when CONFIG_SUSPEND is not set
    
      imx:
       - fix planar offset calculations
       - fix accidental partial revert"
    
    * tag 'drm-fixes-2021-08-27' of git://anongit.freedesktop.org/drm/drm:
      drm/i915/dp: Drop redundant debug print
      drm/i915: Fix syncmap memory leak
      drm/amdgpu: Fix build with missing pm_suspend_target_state module export
      drm/amdgpu: Cancel delayed work when GFXOFF is disabled
      drm/amdgpu: use the preferred pin domain after the check
      drm/imx: ipuv3-plane: fix accidental partial revert of 8 pixel alignment fix
      gpu: ipu-v3: Fix i.MX IPU-v3 offset calculations for (semi)planar U/V formats

commit 7f85c16f40d8be5656fb3476909db5c3a5a9c6ea
Author: Chunfeng Yun <chunfeng.yun@mediatek.com>
Date:   Tue Aug 17 16:36:23 2021 +0800

    usb: xhci-mtk: fix use-after-free of mtk->hcd
    
     BUG: KASAN: use-after-free in usb_hcd_is_primary_hcd+0x38/0x60
     Call trace:
      dump_backtrace+0x0/0x3dc
      show_stack+0x20/0x2c
      dump_stack+0x15c/0x1d4
      print_address_description+0x7c/0x510
      kasan_report+0x164/0x1ac
      __asan_report_load8_noabort+0x44/0x50
      usb_hcd_is_primary_hcd+0x38/0x60
      xhci_mtk_runtime_suspend+0x68/0x148
      pm_generic_runtime_suspend+0x90/0xac
      __rpm_callback+0xb8/0x1f4
      rpm_callback+0x54/0x1d0
      rpm_suspend+0x4e0/0xc84
      __pm_runtime_suspend+0xc4/0x114
      xhci_mtk_probe+0xa58/0xd00
    
    This may happen when probe fails, needn't suspend it synchronously,
    fix it by using pm_runtime_put_noidle().
    
    Reported-by: Pi Hsun <pihsun@google.com>
    Signed-off-by: Chunfeng Yun <chunfeng.yun@mediatek.com>
    Link: https://lore.kernel.org/r/1629189389-18779-3-git-send-email-chunfeng.yun@mediatek.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit a47f6a5806da4f24fbb66148a1519bf72fe060db
Author: Borislav Petkov <bp@suse.de>
Date:   Tue Aug 24 11:42:47 2021 +0200

    drm/amdgpu: Fix build with missing pm_suspend_target_state module export
    
    Building a randconfig here triggered:
    
      ERROR: modpost: "pm_suspend_target_state" [drivers/gpu/drm/amd/amdgpu/amdgpu.ko] undefined!
    
    because the module export of that symbol happens in
    kernel/power/suspend.c which is enabled with CONFIG_SUSPEND.
    
    The ifdef guards in amdgpu_acpi_is_s0ix_supported(), however, test for
    CONFIG_PM_SLEEP which is defined like this:
    
      config PM_SLEEP
              def_bool y
              depends on SUSPEND || HIBERNATE_CALLBACKS
    
    and that randconfig has:
    
      # CONFIG_SUSPEND is not set
      CONFIG_HIBERNATE_CALLBACKS=y
    
    leading to the module export missing.
    
    Change the ifdeffery to depend directly on CONFIG_SUSPEND.
    
    Fixes: 5706cb3c910c ("drm/amdgpu: fix checking pmops when PM_SLEEP is not enabled")
    Reviewed-by: Lijo Lazar <lijo.lazar@amd.com>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Link: https://lkml.kernel.org/r/YSP6Lv53QV0cOAsd@zn.tnic
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Cc: stable@vger.kernel.org

commit c41a4e877a185241d8e83501453326fb98f67354
Author: Borislav Petkov <bp@suse.de>
Date:   Tue Aug 24 11:42:47 2021 +0200

    drm/amdgpu: Fix build with missing pm_suspend_target_state module export
    
    Building a randconfig here triggered:
    
      ERROR: modpost: "pm_suspend_target_state" [drivers/gpu/drm/amd/amdgpu/amdgpu.ko] undefined!
    
    because the module export of that symbol happens in
    kernel/power/suspend.c which is enabled with CONFIG_SUSPEND.
    
    The ifdef guards in amdgpu_acpi_is_s0ix_supported(), however, test for
    CONFIG_PM_SLEEP which is defined like this:
    
      config PM_SLEEP
              def_bool y
              depends on SUSPEND || HIBERNATE_CALLBACKS
    
    and that randconfig has:
    
      # CONFIG_SUSPEND is not set
      CONFIG_HIBERNATE_CALLBACKS=y
    
    leading to the module export missing.
    
    Change the ifdeffery to depend directly on CONFIG_SUSPEND.
    
    Fixes: 5706cb3c910c ("drm/amdgpu: fix checking pmops when PM_SLEEP is not enabled")
    Reviewed-by: Lijo Lazar <lijo.lazar@amd.com>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Link: https://lkml.kernel.org/r/YSP6Lv53QV0cOAsd@zn.tnic
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Cc: stable@vger.kernel.org

commit 8330879408e590b0d576e2e65a0ced4d9ae804bb
Author: Randy Dunlap <rdunlap@infradead.org>
Date:   Thu Jul 29 20:03:47 2021 -0700

    drm/amdgpu: fix checking pmops when PM_SLEEP is not enabled
    
    commit 5706cb3c910cc8283f344bc37a889a8d523a2c6d upstream.
    
    'pm_suspend_target_state' is only available when CONFIG_PM_SLEEP
    is set/enabled. OTOH, when both SUSPEND and HIBERNATION are not set,
    PM_SLEEP is not set, so this variable cannot be used.
    
    ../drivers/gpu/drm/amd/amdgpu/amdgpu_acpi.c: In function ‘amdgpu_acpi_is_s0ix_active’:
    ../drivers/gpu/drm/amd/amdgpu/amdgpu_acpi.c:1046:11: error: ‘pm_suspend_target_state’ undeclared (first use in this function); did you mean ‘__KSYM_pm_suspend_target_state’?
        return pm_suspend_target_state == PM_SUSPEND_TO_IDLE;
               ^~~~~~~~~~~~~~~~~~~~~~~
               __KSYM_pm_suspend_target_state
    
    Also use shorter IS_ENABLED(CONFIG_foo) notation for checking the
    2 config symbols.
    
    Fixes: 91e273712ab8dd ("drm/amdgpu: Check pmops for desired suspend state")
    Signed-off-by: Randy Dunlap <rdunlap@infradead.org>
    Cc: Alex Deucher <alexander.deucher@amd.com>
    Cc: Christian König <christian.koenig@amd.com>
    Cc: "Pan, Xinhui" <Xinhui.Pan@amd.com>
    Cc: amd-gfx@lists.freedesktop.org
    Cc: dri-devel@lists.freedesktop.org
    Cc: linux-next@vger.kernel.org
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 8d70136e2dc76f085b7423b993e13527f5a1fd7e
Author: Randy Dunlap <rdunlap@infradead.org>
Date:   Thu Jul 29 20:03:47 2021 -0700

    drm/amdgpu: fix checking pmops when PM_SLEEP is not enabled
    
    'pm_suspend_target_state' is only available when CONFIG_PM_SLEEP
    is set/enabled. OTOH, when both SUSPEND and HIBERNATION are not set,
    PM_SLEEP is not set, so this variable cannot be used.
    
    ../drivers/gpu/drm/amd/amdgpu/amdgpu_acpi.c: In function ‘amdgpu_acpi_is_s0ix_active’:
    ../drivers/gpu/drm/amd/amdgpu/amdgpu_acpi.c:1046:11: error: ‘pm_suspend_target_state’ undeclared (first use in this function); did you mean ‘__KSYM_pm_suspend_target_state’?
        return pm_suspend_target_state == PM_SUSPEND_TO_IDLE;
               ^~~~~~~~~~~~~~~~~~~~~~~
               __KSYM_pm_suspend_target_state
    
    Also use shorter IS_ENABLED(CONFIG_foo) notation for checking the
    2 config symbols.
    
    Fixes: 91e273712ab8dd ("drm/amdgpu: Check pmops for desired suspend state")
    Signed-off-by: Randy Dunlap <rdunlap@infradead.org>
    Cc: Alex Deucher <alexander.deucher@amd.com>
    Cc: Christian König <christian.koenig@amd.com>
    Cc: "Pan, Xinhui" <Xinhui.Pan@amd.com>
    Cc: amd-gfx@lists.freedesktop.org
    Cc: dri-devel@lists.freedesktop.org
    Cc: linux-next@vger.kernel.org
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

commit 5706cb3c910cc8283f344bc37a889a8d523a2c6d
Author: Randy Dunlap <rdunlap@infradead.org>
Date:   Thu Jul 29 20:03:47 2021 -0700

    drm/amdgpu: fix checking pmops when PM_SLEEP is not enabled
    
    'pm_suspend_target_state' is only available when CONFIG_PM_SLEEP
    is set/enabled. OTOH, when both SUSPEND and HIBERNATION are not set,
    PM_SLEEP is not set, so this variable cannot be used.
    
    ../drivers/gpu/drm/amd/amdgpu/amdgpu_acpi.c: In function ‘amdgpu_acpi_is_s0ix_active’:
    ../drivers/gpu/drm/amd/amdgpu/amdgpu_acpi.c:1046:11: error: ‘pm_suspend_target_state’ undeclared (first use in this function); did you mean ‘__KSYM_pm_suspend_target_state’?
        return pm_suspend_target_state == PM_SUSPEND_TO_IDLE;
               ^~~~~~~~~~~~~~~~~~~~~~~
               __KSYM_pm_suspend_target_state
    
    Also use shorter IS_ENABLED(CONFIG_foo) notation for checking the
    2 config symbols.
    
    Fixes: 91e273712ab8dd ("drm/amdgpu: Check pmops for desired suspend state")
    Signed-off-by: Randy Dunlap <rdunlap@infradead.org>
    Cc: Alex Deucher <alexander.deucher@amd.com>
    Cc: Christian König <christian.koenig@amd.com>
    Cc: "Pan, Xinhui" <Xinhui.Pan@amd.com>
    Cc: amd-gfx@lists.freedesktop.org
    Cc: dri-devel@lists.freedesktop.org
    Cc: linux-next@vger.kernel.org
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Cc: stable@vger.kernel.org

commit 7fd445618a314f4a5c229398e829f9b860a47ab1
Author: Sean Wang <sean.wang@mediatek.com>
Date:   Thu May 20 11:46:39 2021 +0800

    mt76: mt7921: fix invalid register access in wake_work
    
    [ Upstream commit f86625ae0e35924ed495cdf0ff2d3133cb6e3010 ]
    
    Make sure mt7921_pm_wake_work wouldn't be scheduled after the driver is
    in suspend mode to fix the following the kernel crash.
    
    [ 3515.390012] mt7921e 0000:01:00.0: calling pci_pm_suspend+0x0/0x22c @ 2869, parent: 0000:00:00.0
    [ 3515.390015] mt7921e 0000:01:00.0: mt7921_pci_suspend +
    [ 3515.396395] anx7625 3-0058: anx7625_suspend+0x0/0x6c returned 0 after 0 usecs
    [ 3515.405965] mt7921e 0000:01:00.0: mt7921_pci_suspend -
    [ 3515.411336] usb 1-1.4: usb_dev_suspend+0x0/0x2c returned 0 after 1 usecs
    [ 3515.411513] SError Interrupt on CPU7, code 0xbe000011 -- SError
    [ 3515.411515] CPU: 7 PID: 2849 Comm: kworker/u16:27 Not tainted 5.4.114 #44
    [ 3515.411516] Hardware name: MediaTek Asurada rev1 board (DT)
    [ 3515.411517] Workqueue: mt76 mt7921_pm_wake_work [mt7921e]
    [ 3515.411518] pstate: 80c00009 (Nzcv daif +PAN +UAO)
    [ 3515.411519] pc : mt76_mmio_rr+0x30/0xf0 [mt76]
    [ 3515.411520] lr : mt7921_rr+0x38/0x44 [mt7921e]
    [ 3515.411520] sp : ffffffc015813c50
    [ 3515.411521] x29: ffffffc015813c50 x28: 0000000000000402
    [ 3515.411522] x27: ffffffe5a2012138 x26: ffffffe5a1eea018
    [ 3515.411524] x25: 00000000328be505 x24: 00000000000a0002
    [ 3515.411525] x23: 0000000000000006 x22: ffffffbd29b7a300
    [ 3515.411527] x21: ffffffbd29b7a300 x20: 00000000000e0010
    [ 3515.411528] x19: 00000000eac08f43 x18: 0000000000000000
    [ 3515.411529] x17: 0000000000000000 x16: ffffffe5a16b2914
    [ 3515.411531] x15: 0000000000000010 x14: 0000000000000010
    [ 3515.411532] x13: 00000000003dd3a2 x12: 0000000000010000
    [ 3515.411533] x11: ffffffe597abec14 x10: 0000000000000010
    [ 3515.411535] x9 : ffffffe597abeba8 x8 : ffffffc013ce0010
    [ 3515.411536] x7 : 000000b2b5593519 x6 : 0000000000300000
    [ 3515.411537] x5 : 0000000000000000 x4 : 0000000000000032
    [ 3515.411539] x3 : 0000000000000000 x2 : 0000000000000004
    [ 3515.411540] x1 : 00000000000e0010 x0 : ffffffbd29b7a300
    [ 3515.411542] Kernel panic - not syncing: Asynchronous SError Interrupt
    [ 3515.411543] CPU: 7 PID: 2849 Comm: kworker/u16:27 Not tainted 5.4.114 #44
    [ 3515.411544] Hardware name: MediaTek Asurada rev1 board (DT)
    [ 3515.411544] Workqueue: mt76 mt7921_pm_wake_work [mt7921e]
    [ 3515.411545] Call trace:
    [ 3515.411546]  dump_backtrace+0x0/0x14c
    [ 3515.411546]  show_stack+0x20/0x2c
    [ 3515.411547]  dump_stack+0xa0/0xfc
    [ 3515.411548]  panic+0x154/0x350
    [ 3515.411548]  panic+0x0/0x350
    [ 3515.411549]  arm64_serror_panic+0x78/0x84
    [ 3515.411550]  do_serror+0x0/0x118
    [ 3515.411550]  do_serror+0xa4/0x118
    [ 3515.411551]  el1_error+0x84/0xf8
    [ 3515.411552]  mt76_mmio_rr+0x30/0xf0 [mt76]
    [ 3515.411552]  mt7921_rr+0x38/0x44 [mt7921e]
    [ 3515.411553]  __mt76_poll_msec+0x5c/0x9c [mt76]
    [ 3515.411554]  __mt7921_mcu_drv_pmctrl+0x50/0x94 [mt7921e]
    [ 3515.411555]  mt7921_mcu_drv_pmctrl+0x38/0xb0 [mt7921e]
    [ 3515.411555]  mt7921_pm_wake_work+0x34/0xd4 [mt7921e]
    [ 3515.411556]  process_one_work+0x208/0x3c8
    [ 3515.411557]  worker_thread+0x23c/0x3e8
    [ 3515.411557]  kthread+0x144/0x178
    [ 3515.411558]  ret_from_fork+0x10/0x18
    [ 3515.418831] SMP: stopping secondary CPUs
    [ 3515.418832] Kernel Offset: 0x2590c00000 from 0xffffffc010000000
    [ 3515.418832] PHYS_OFFSET: 0xffffffc400000000
    [ 3515.418833] CPU features: 0x080026,2a80aa18
    [ 3515.418834] Memory Limit: none
    [DL] 00000000 00000000 010701
    
    Fixes: 1d8efc741df80 ("mt76: mt7921: introduce Runtime PM support")
    Co-developed-by: Lorenzo Bianconi <lorenzo@kernel.org>
    Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
    Signed-off-by: Sean Wang <sean.wang@mediatek.com>
    Signed-off-by: Felix Fietkau <nbd@nbd.name>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit f77ecd22b784132ae5c5eb62cb1a563a4f0e8225
Author: Dafna Hirschfeld <dafna.hirschfeld@collabora.com>
Date:   Fri Apr 23 19:27:45 2021 +0200

    media: mtk-vpu: on suspend, read/write regs only if vpu is running
    
    [ Upstream commit 11420749c6b4b237361750de3d5b5579175f8622 ]
    
    If the vpu is not running, we should not rely on VPU_IDLE_REG
    value. In this case, the suspend cb should only unprepare the
    clock. This fixes a system-wide suspend to ram failure:
    
    [  273.073363] PM: suspend entry (deep)
    [  273.410502] mtk-msdc 11230000.mmc: phase: [map:ffffffff] [maxlen:32] [final:10]
    [  273.455926] Filesystems sync: 0.378 seconds
    [  273.589707] Freezing user space processes ... (elapsed 0.003 seconds) done.
    [  273.600104] OOM killer disabled.
    [  273.603409] Freezing remaining freezable tasks ... (elapsed 0.001 seconds) done.
    [  273.613361] mwifiex_sdio mmc2:0001:1: None of the WOWLAN triggers enabled
    [  274.784952] mtk_vpu 10020000.vpu: vpu idle timeout
    [  274.789764] PM: dpm_run_callback(): platform_pm_suspend+0x0/0x70 returns -5
    [  274.796740] mtk_vpu 10020000.vpu: PM: failed to suspend: error -5
    [  274.802842] PM: Some devices failed to suspend, or early wake event detected
    [  275.426489] OOM killer enabled.
    [  275.429718] Restarting tasks ...
    [  275.435765] done.
    [  275.447510] PM: suspend exit
    
    Fixes: 1f565e263c3e ("media: mtk-vpu: VPU should be in idle state before system is suspended")
    Signed-off-by: Dafna Hirschfeld <dafna.hirschfeld@collabora.com>
    Signed-off-by: Hans Verkuil <hverkuil-cisco@xs4all.nl>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+huawei@kernel.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 49d6019ac1033316ebd447d00922ea6b6a6eb974
Author: Dafna Hirschfeld <dafna.hirschfeld@collabora.com>
Date:   Fri Apr 23 19:27:45 2021 +0200

    media: mtk-vpu: on suspend, read/write regs only if vpu is running
    
    [ Upstream commit 11420749c6b4b237361750de3d5b5579175f8622 ]
    
    If the vpu is not running, we should not rely on VPU_IDLE_REG
    value. In this case, the suspend cb should only unprepare the
    clock. This fixes a system-wide suspend to ram failure:
    
    [  273.073363] PM: suspend entry (deep)
    [  273.410502] mtk-msdc 11230000.mmc: phase: [map:ffffffff] [maxlen:32] [final:10]
    [  273.455926] Filesystems sync: 0.378 seconds
    [  273.589707] Freezing user space processes ... (elapsed 0.003 seconds) done.
    [  273.600104] OOM killer disabled.
    [  273.603409] Freezing remaining freezable tasks ... (elapsed 0.001 seconds) done.
    [  273.613361] mwifiex_sdio mmc2:0001:1: None of the WOWLAN triggers enabled
    [  274.784952] mtk_vpu 10020000.vpu: vpu idle timeout
    [  274.789764] PM: dpm_run_callback(): platform_pm_suspend+0x0/0x70 returns -5
    [  274.796740] mtk_vpu 10020000.vpu: PM: failed to suspend: error -5
    [  274.802842] PM: Some devices failed to suspend, or early wake event detected
    [  275.426489] OOM killer enabled.
    [  275.429718] Restarting tasks ...
    [  275.435765] done.
    [  275.447510] PM: suspend exit
    
    Fixes: 1f565e263c3e ("media: mtk-vpu: VPU should be in idle state before system is suspended")
    Signed-off-by: Dafna Hirschfeld <dafna.hirschfeld@collabora.com>
    Signed-off-by: Hans Verkuil <hverkuil-cisco@xs4all.nl>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+huawei@kernel.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 6e2a98bc902ce347747fabb133485d7ce2bdd7e4
Author: Petr Mladek <pmladek@suse.com>
Date:   Thu Jun 24 18:39:48 2021 -0700

    kthread: prevent deadlock when kthread_mod_delayed_work() races with kthread_cancel_delayed_work_sync()
    
    commit 5fa54346caf67b4b1b10b1f390316ae466da4d53 upstream.
    
    The system might hang with the following backtrace:
    
            schedule+0x80/0x100
            schedule_timeout+0x48/0x138
            wait_for_common+0xa4/0x134
            wait_for_completion+0x1c/0x2c
            kthread_flush_work+0x114/0x1cc
            kthread_cancel_work_sync.llvm.16514401384283632983+0xe8/0x144
            kthread_cancel_delayed_work_sync+0x18/0x2c
            xxxx_pm_notify+0xb0/0xd8
            blocking_notifier_call_chain_robust+0x80/0x194
            pm_notifier_call_chain_robust+0x28/0x4c
            suspend_prepare+0x40/0x260
            enter_state+0x80/0x3f4
            pm_suspend+0x60/0xdc
            state_store+0x108/0x144
            kobj_attr_store+0x38/0x88
            sysfs_kf_write+0x64/0xc0
            kernfs_fop_write_iter+0x108/0x1d0
            vfs_write+0x2f4/0x368
            ksys_write+0x7c/0xec
    
    It is caused by the following race between kthread_mod_delayed_work()
    and kthread_cancel_delayed_work_sync():
    
    CPU0                            CPU1
    
    Context: Thread A               Context: Thread B
    
    kthread_mod_delayed_work()
      spin_lock()
      __kthread_cancel_work()
         spin_unlock()
         del_timer_sync()
                                    kthread_cancel_delayed_work_sync()
                                      spin_lock()
                                      __kthread_cancel_work()
                                        spin_unlock()
                                        del_timer_sync()
                                        spin_lock()
    
                                      work->canceling++
                                      spin_unlock
         spin_lock()
       queue_delayed_work()
         // dwork is put into the worker->delayed_work_list
    
       spin_unlock()
    
                                      kthread_flush_work()
         // flush_work is put at the tail of the dwork
    
                                        wait_for_completion()
    
    Context: IRQ
    
      kthread_delayed_work_timer_fn()
        spin_lock()
        list_del_init(&work->node);
        spin_unlock()
    
    BANG: flush_work is not longer linked and will never get proceed.
    
    The problem is that kthread_mod_delayed_work() checks work->canceling
    flag before canceling the timer.
    
    A simple solution is to (re)check work->canceling after
    __kthread_cancel_work().  But then it is not clear what should be
    returned when __kthread_cancel_work() removed the work from the queue
    (list) and it can't queue it again with the new @delay.
    
    The return value might be used for reference counting.  The caller has
    to know whether a new work has been queued or an existing one was
    replaced.
    
    The proper solution is that kthread_mod_delayed_work() will remove the
    work from the queue (list) _only_ when work->canceling is not set.  The
    flag must be checked after the timer is stopped and the remaining
    operations can be done under worker->lock.
    
    Note that kthread_mod_delayed_work() could remove the timer and then
    bail out.  It is fine.  The other canceling caller needs to cancel the
    timer as well.  The important thing is that the queue (list)
    manipulation is done atomically under worker->lock.
    
    Link: https://lkml.kernel.org/r/20210610133051.15337-3-pmladek@suse.com
    Fixes: 9a6b06c8d9a220860468a ("kthread: allow to modify delayed kthread work")
    Signed-off-by: Petr Mladek <pmladek@suse.com>
    Reported-by: Martin Liu <liumartin@google.com>
    Cc: <jenhaochen@google.com>
    Cc: Minchan Kim <minchan@google.com>
    Cc: Nathan Chancellor <nathan@kernel.org>
    Cc: Nick Desaulniers <ndesaulniers@google.com>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 5f0185cd37347267ff06dd61cd0131b27f164ac5
Author: Petr Mladek <pmladek@suse.com>
Date:   Thu Jun 24 18:39:48 2021 -0700

    kthread: prevent deadlock when kthread_mod_delayed_work() races with kthread_cancel_delayed_work_sync()
    
    commit 5fa54346caf67b4b1b10b1f390316ae466da4d53 upstream.
    
    The system might hang with the following backtrace:
    
            schedule+0x80/0x100
            schedule_timeout+0x48/0x138
            wait_for_common+0xa4/0x134
            wait_for_completion+0x1c/0x2c
            kthread_flush_work+0x114/0x1cc
            kthread_cancel_work_sync.llvm.16514401384283632983+0xe8/0x144
            kthread_cancel_delayed_work_sync+0x18/0x2c
            xxxx_pm_notify+0xb0/0xd8
            blocking_notifier_call_chain_robust+0x80/0x194
            pm_notifier_call_chain_robust+0x28/0x4c
            suspend_prepare+0x40/0x260
            enter_state+0x80/0x3f4
            pm_suspend+0x60/0xdc
            state_store+0x108/0x144
            kobj_attr_store+0x38/0x88
            sysfs_kf_write+0x64/0xc0
            kernfs_fop_write_iter+0x108/0x1d0
            vfs_write+0x2f4/0x368
            ksys_write+0x7c/0xec
    
    It is caused by the following race between kthread_mod_delayed_work()
    and kthread_cancel_delayed_work_sync():
    
    CPU0                            CPU1
    
    Context: Thread A               Context: Thread B
    
    kthread_mod_delayed_work()
      spin_lock()
      __kthread_cancel_work()
         spin_unlock()
         del_timer_sync()
                                    kthread_cancel_delayed_work_sync()
                                      spin_lock()
                                      __kthread_cancel_work()
                                        spin_unlock()
                                        del_timer_sync()
                                        spin_lock()
    
                                      work->canceling++
                                      spin_unlock
         spin_lock()
       queue_delayed_work()
         // dwork is put into the worker->delayed_work_list
    
       spin_unlock()
    
                                      kthread_flush_work()
         // flush_work is put at the tail of the dwork
    
                                        wait_for_completion()
    
    Context: IRQ
    
      kthread_delayed_work_timer_fn()
        spin_lock()
        list_del_init(&work->node);
        spin_unlock()
    
    BANG: flush_work is not longer linked and will never get proceed.
    
    The problem is that kthread_mod_delayed_work() checks work->canceling
    flag before canceling the timer.
    
    A simple solution is to (re)check work->canceling after
    __kthread_cancel_work().  But then it is not clear what should be
    returned when __kthread_cancel_work() removed the work from the queue
    (list) and it can't queue it again with the new @delay.
    
    The return value might be used for reference counting.  The caller has
    to know whether a new work has been queued or an existing one was
    replaced.
    
    The proper solution is that kthread_mod_delayed_work() will remove the
    work from the queue (list) _only_ when work->canceling is not set.  The
    flag must be checked after the timer is stopped and the remaining
    operations can be done under worker->lock.
    
    Note that kthread_mod_delayed_work() could remove the timer and then
    bail out.  It is fine.  The other canceling caller needs to cancel the
    timer as well.  The important thing is that the queue (list)
    manipulation is done atomically under worker->lock.
    
    Link: https://lkml.kernel.org/r/20210610133051.15337-3-pmladek@suse.com
    Fixes: 9a6b06c8d9a220860468a ("kthread: allow to modify delayed kthread work")
    Signed-off-by: Petr Mladek <pmladek@suse.com>
    Reported-by: Martin Liu <liumartin@google.com>
    Cc: <jenhaochen@google.com>
    Cc: Minchan Kim <minchan@google.com>
    Cc: Nathan Chancellor <nathan@kernel.org>
    Cc: Nick Desaulniers <ndesaulniers@google.com>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 5d27e1503b17db8571a4e71b6146644ab29c18a7
Author: Petr Mladek <pmladek@suse.com>
Date:   Thu Jun 24 18:39:48 2021 -0700

    kthread: prevent deadlock when kthread_mod_delayed_work() races with kthread_cancel_delayed_work_sync()
    
    commit 5fa54346caf67b4b1b10b1f390316ae466da4d53 upstream.
    
    The system might hang with the following backtrace:
    
            schedule+0x80/0x100
            schedule_timeout+0x48/0x138
            wait_for_common+0xa4/0x134
            wait_for_completion+0x1c/0x2c
            kthread_flush_work+0x114/0x1cc
            kthread_cancel_work_sync.llvm.16514401384283632983+0xe8/0x144
            kthread_cancel_delayed_work_sync+0x18/0x2c
            xxxx_pm_notify+0xb0/0xd8
            blocking_notifier_call_chain_robust+0x80/0x194
            pm_notifier_call_chain_robust+0x28/0x4c
            suspend_prepare+0x40/0x260
            enter_state+0x80/0x3f4
            pm_suspend+0x60/0xdc
            state_store+0x108/0x144
            kobj_attr_store+0x38/0x88
            sysfs_kf_write+0x64/0xc0
            kernfs_fop_write_iter+0x108/0x1d0
            vfs_write+0x2f4/0x368
            ksys_write+0x7c/0xec
    
    It is caused by the following race between kthread_mod_delayed_work()
    and kthread_cancel_delayed_work_sync():
    
    CPU0                            CPU1
    
    Context: Thread A               Context: Thread B
    
    kthread_mod_delayed_work()
      spin_lock()
      __kthread_cancel_work()
         spin_unlock()
         del_timer_sync()
                                    kthread_cancel_delayed_work_sync()
                                      spin_lock()
                                      __kthread_cancel_work()
                                        spin_unlock()
                                        del_timer_sync()
                                        spin_lock()
    
                                      work->canceling++
                                      spin_unlock
         spin_lock()
       queue_delayed_work()
         // dwork is put into the worker->delayed_work_list
    
       spin_unlock()
    
                                      kthread_flush_work()
         // flush_work is put at the tail of the dwork
    
                                        wait_for_completion()
    
    Context: IRQ
    
      kthread_delayed_work_timer_fn()
        spin_lock()
        list_del_init(&work->node);
        spin_unlock()
    
    BANG: flush_work is not longer linked and will never get proceed.
    
    The problem is that kthread_mod_delayed_work() checks work->canceling
    flag before canceling the timer.
    
    A simple solution is to (re)check work->canceling after
    __kthread_cancel_work().  But then it is not clear what should be
    returned when __kthread_cancel_work() removed the work from the queue
    (list) and it can't queue it again with the new @delay.
    
    The return value might be used for reference counting.  The caller has
    to know whether a new work has been queued or an existing one was
    replaced.
    
    The proper solution is that kthread_mod_delayed_work() will remove the
    work from the queue (list) _only_ when work->canceling is not set.  The
    flag must be checked after the timer is stopped and the remaining
    operations can be done under worker->lock.
    
    Note that kthread_mod_delayed_work() could remove the timer and then
    bail out.  It is fine.  The other canceling caller needs to cancel the
    timer as well.  The important thing is that the queue (list)
    manipulation is done atomically under worker->lock.
    
    Link: https://lkml.kernel.org/r/20210610133051.15337-3-pmladek@suse.com
    Fixes: 9a6b06c8d9a220860468a ("kthread: allow to modify delayed kthread work")
    Signed-off-by: Petr Mladek <pmladek@suse.com>
    Reported-by: Martin Liu <liumartin@google.com>
    Cc: <jenhaochen@google.com>
    Cc: Minchan Kim <minchan@google.com>
    Cc: Nathan Chancellor <nathan@kernel.org>
    Cc: Nick Desaulniers <ndesaulniers@google.com>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 42f11f0fe9770a4c8ac18e6a44d18a08d16c2c66
Author: Petr Mladek <pmladek@suse.com>
Date:   Thu Jun 24 18:39:48 2021 -0700

    kthread: prevent deadlock when kthread_mod_delayed_work() races with kthread_cancel_delayed_work_sync()
    
    commit 5fa54346caf67b4b1b10b1f390316ae466da4d53 upstream.
    
    The system might hang with the following backtrace:
    
            schedule+0x80/0x100
            schedule_timeout+0x48/0x138
            wait_for_common+0xa4/0x134
            wait_for_completion+0x1c/0x2c
            kthread_flush_work+0x114/0x1cc
            kthread_cancel_work_sync.llvm.16514401384283632983+0xe8/0x144
            kthread_cancel_delayed_work_sync+0x18/0x2c
            xxxx_pm_notify+0xb0/0xd8
            blocking_notifier_call_chain_robust+0x80/0x194
            pm_notifier_call_chain_robust+0x28/0x4c
            suspend_prepare+0x40/0x260
            enter_state+0x80/0x3f4
            pm_suspend+0x60/0xdc
            state_store+0x108/0x144
            kobj_attr_store+0x38/0x88
            sysfs_kf_write+0x64/0xc0
            kernfs_fop_write_iter+0x108/0x1d0
            vfs_write+0x2f4/0x368
            ksys_write+0x7c/0xec
    
    It is caused by the following race between kthread_mod_delayed_work()
    and kthread_cancel_delayed_work_sync():
    
    CPU0                            CPU1
    
    Context: Thread A               Context: Thread B
    
    kthread_mod_delayed_work()
      spin_lock()
      __kthread_cancel_work()
         spin_unlock()
         del_timer_sync()
                                    kthread_cancel_delayed_work_sync()
                                      spin_lock()
                                      __kthread_cancel_work()
                                        spin_unlock()
                                        del_timer_sync()
                                        spin_lock()
    
                                      work->canceling++
                                      spin_unlock
         spin_lock()
       queue_delayed_work()
         // dwork is put into the worker->delayed_work_list
    
       spin_unlock()
    
                                      kthread_flush_work()
         // flush_work is put at the tail of the dwork
    
                                        wait_for_completion()
    
    Context: IRQ
    
      kthread_delayed_work_timer_fn()
        spin_lock()
        list_del_init(&work->node);
        spin_unlock()
    
    BANG: flush_work is not longer linked and will never get proceed.
    
    The problem is that kthread_mod_delayed_work() checks work->canceling
    flag before canceling the timer.
    
    A simple solution is to (re)check work->canceling after
    __kthread_cancel_work().  But then it is not clear what should be
    returned when __kthread_cancel_work() removed the work from the queue
    (list) and it can't queue it again with the new @delay.
    
    The return value might be used for reference counting.  The caller has
    to know whether a new work has been queued or an existing one was
    replaced.
    
    The proper solution is that kthread_mod_delayed_work() will remove the
    work from the queue (list) _only_ when work->canceling is not set.  The
    flag must be checked after the timer is stopped and the remaining
    operations can be done under worker->lock.
    
    Note that kthread_mod_delayed_work() could remove the timer and then
    bail out.  It is fine.  The other canceling caller needs to cancel the
    timer as well.  The important thing is that the queue (list)
    manipulation is done atomically under worker->lock.
    
    Link: https://lkml.kernel.org/r/20210610133051.15337-3-pmladek@suse.com
    Fixes: 9a6b06c8d9a220860468a ("kthread: allow to modify delayed kthread work")
    Signed-off-by: Petr Mladek <pmladek@suse.com>
    Reported-by: Martin Liu <liumartin@google.com>
    Cc: <jenhaochen@google.com>
    Cc: Minchan Kim <minchan@google.com>
    Cc: Nathan Chancellor <nathan@kernel.org>
    Cc: Nick Desaulniers <ndesaulniers@google.com>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 2b35a4eaaaae26f3f22bfb1a8b7ca1e994bae063
Author: Petr Mladek <pmladek@suse.com>
Date:   Thu Jun 24 18:39:48 2021 -0700

    kthread: prevent deadlock when kthread_mod_delayed_work() races with kthread_cancel_delayed_work_sync()
    
    commit 5fa54346caf67b4b1b10b1f390316ae466da4d53 upstream.
    
    The system might hang with the following backtrace:
    
            schedule+0x80/0x100
            schedule_timeout+0x48/0x138
            wait_for_common+0xa4/0x134
            wait_for_completion+0x1c/0x2c
            kthread_flush_work+0x114/0x1cc
            kthread_cancel_work_sync.llvm.16514401384283632983+0xe8/0x144
            kthread_cancel_delayed_work_sync+0x18/0x2c
            xxxx_pm_notify+0xb0/0xd8
            blocking_notifier_call_chain_robust+0x80/0x194
            pm_notifier_call_chain_robust+0x28/0x4c
            suspend_prepare+0x40/0x260
            enter_state+0x80/0x3f4
            pm_suspend+0x60/0xdc
            state_store+0x108/0x144
            kobj_attr_store+0x38/0x88
            sysfs_kf_write+0x64/0xc0
            kernfs_fop_write_iter+0x108/0x1d0
            vfs_write+0x2f4/0x368
            ksys_write+0x7c/0xec
    
    It is caused by the following race between kthread_mod_delayed_work()
    and kthread_cancel_delayed_work_sync():
    
    CPU0                            CPU1
    
    Context: Thread A               Context: Thread B
    
    kthread_mod_delayed_work()
      spin_lock()
      __kthread_cancel_work()
         spin_unlock()
         del_timer_sync()
                                    kthread_cancel_delayed_work_sync()
                                      spin_lock()
                                      __kthread_cancel_work()
                                        spin_unlock()
                                        del_timer_sync()
                                        spin_lock()
    
                                      work->canceling++
                                      spin_unlock
         spin_lock()
       queue_delayed_work()
         // dwork is put into the worker->delayed_work_list
    
       spin_unlock()
    
                                      kthread_flush_work()
         // flush_work is put at the tail of the dwork
    
                                        wait_for_completion()
    
    Context: IRQ
    
      kthread_delayed_work_timer_fn()
        spin_lock()
        list_del_init(&work->node);
        spin_unlock()
    
    BANG: flush_work is not longer linked and will never get proceed.
    
    The problem is that kthread_mod_delayed_work() checks work->canceling
    flag before canceling the timer.
    
    A simple solution is to (re)check work->canceling after
    __kthread_cancel_work().  But then it is not clear what should be
    returned when __kthread_cancel_work() removed the work from the queue
    (list) and it can't queue it again with the new @delay.
    
    The return value might be used for reference counting.  The caller has
    to know whether a new work has been queued or an existing one was
    replaced.
    
    The proper solution is that kthread_mod_delayed_work() will remove the
    work from the queue (list) _only_ when work->canceling is not set.  The
    flag must be checked after the timer is stopped and the remaining
    operations can be done under worker->lock.
    
    Note that kthread_mod_delayed_work() could remove the timer and then
    bail out.  It is fine.  The other canceling caller needs to cancel the
    timer as well.  The important thing is that the queue (list)
    manipulation is done atomically under worker->lock.
    
    Link: https://lkml.kernel.org/r/20210610133051.15337-3-pmladek@suse.com
    Fixes: 9a6b06c8d9a220860468a ("kthread: allow to modify delayed kthread work")
    Signed-off-by: Petr Mladek <pmladek@suse.com>
    Reported-by: Martin Liu <liumartin@google.com>
    Cc: <jenhaochen@google.com>
    Cc: Minchan Kim <minchan@google.com>
    Cc: Nathan Chancellor <nathan@kernel.org>
    Cc: Nick Desaulniers <ndesaulniers@google.com>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit eb674f16f19498b21d43a1283c3fe424d0b65f2c
Author: Petr Mladek <pmladek@suse.com>
Date:   Thu Jun 24 18:39:48 2021 -0700

    kthread: prevent deadlock when kthread_mod_delayed_work() races with kthread_cancel_delayed_work_sync()
    
    commit 5fa54346caf67b4b1b10b1f390316ae466da4d53 upstream.
    
    The system might hang with the following backtrace:
    
            schedule+0x80/0x100
            schedule_timeout+0x48/0x138
            wait_for_common+0xa4/0x134
            wait_for_completion+0x1c/0x2c
            kthread_flush_work+0x114/0x1cc
            kthread_cancel_work_sync.llvm.16514401384283632983+0xe8/0x144
            kthread_cancel_delayed_work_sync+0x18/0x2c
            xxxx_pm_notify+0xb0/0xd8
            blocking_notifier_call_chain_robust+0x80/0x194
            pm_notifier_call_chain_robust+0x28/0x4c
            suspend_prepare+0x40/0x260
            enter_state+0x80/0x3f4
            pm_suspend+0x60/0xdc
            state_store+0x108/0x144
            kobj_attr_store+0x38/0x88
            sysfs_kf_write+0x64/0xc0
            kernfs_fop_write_iter+0x108/0x1d0
            vfs_write+0x2f4/0x368
            ksys_write+0x7c/0xec
    
    It is caused by the following race between kthread_mod_delayed_work()
    and kthread_cancel_delayed_work_sync():
    
    CPU0                            CPU1
    
    Context: Thread A               Context: Thread B
    
    kthread_mod_delayed_work()
      spin_lock()
      __kthread_cancel_work()
         spin_unlock()
         del_timer_sync()
                                    kthread_cancel_delayed_work_sync()
                                      spin_lock()
                                      __kthread_cancel_work()
                                        spin_unlock()
                                        del_timer_sync()
                                        spin_lock()
    
                                      work->canceling++
                                      spin_unlock
         spin_lock()
       queue_delayed_work()
         // dwork is put into the worker->delayed_work_list
    
       spin_unlock()
    
                                      kthread_flush_work()
         // flush_work is put at the tail of the dwork
    
                                        wait_for_completion()
    
    Context: IRQ
    
      kthread_delayed_work_timer_fn()
        spin_lock()
        list_del_init(&work->node);
        spin_unlock()
    
    BANG: flush_work is not longer linked and will never get proceed.
    
    The problem is that kthread_mod_delayed_work() checks work->canceling
    flag before canceling the timer.
    
    A simple solution is to (re)check work->canceling after
    __kthread_cancel_work().  But then it is not clear what should be
    returned when __kthread_cancel_work() removed the work from the queue
    (list) and it can't queue it again with the new @delay.
    
    The return value might be used for reference counting.  The caller has
    to know whether a new work has been queued or an existing one was
    replaced.
    
    The proper solution is that kthread_mod_delayed_work() will remove the
    work from the queue (list) _only_ when work->canceling is not set.  The
    flag must be checked after the timer is stopped and the remaining
    operations can be done under worker->lock.
    
    Note that kthread_mod_delayed_work() could remove the timer and then
    bail out.  It is fine.  The other canceling caller needs to cancel the
    timer as well.  The important thing is that the queue (list)
    manipulation is done atomically under worker->lock.
    
    Link: https://lkml.kernel.org/r/20210610133051.15337-3-pmladek@suse.com
    Fixes: 9a6b06c8d9a220860468a ("kthread: allow to modify delayed kthread work")
    Signed-off-by: Petr Mladek <pmladek@suse.com>
    Reported-by: Martin Liu <liumartin@google.com>
    Cc: <jenhaochen@google.com>
    Cc: Minchan Kim <minchan@google.com>
    Cc: Nathan Chancellor <nathan@kernel.org>
    Cc: Nick Desaulniers <ndesaulniers@google.com>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 11420749c6b4b237361750de3d5b5579175f8622
Author: Dafna Hirschfeld <dafna.hirschfeld@collabora.com>
Date:   Fri Apr 23 19:27:45 2021 +0200

    media: mtk-vpu: on suspend, read/write regs only if vpu is running
    
    If the vpu is not running, we should not rely on VPU_IDLE_REG
    value. In this case, the suspend cb should only unprepare the
    clock. This fixes a system-wide suspend to ram failure:
    
    [  273.073363] PM: suspend entry (deep)
    [  273.410502] mtk-msdc 11230000.mmc: phase: [map:ffffffff] [maxlen:32] [final:10]
    [  273.455926] Filesystems sync: 0.378 seconds
    [  273.589707] Freezing user space processes ... (elapsed 0.003 seconds) done.
    [  273.600104] OOM killer disabled.
    [  273.603409] Freezing remaining freezable tasks ... (elapsed 0.001 seconds) done.
    [  273.613361] mwifiex_sdio mmc2:0001:1: None of the WOWLAN triggers enabled
    [  274.784952] mtk_vpu 10020000.vpu: vpu idle timeout
    [  274.789764] PM: dpm_run_callback(): platform_pm_suspend+0x0/0x70 returns -5
    [  274.796740] mtk_vpu 10020000.vpu: PM: failed to suspend: error -5
    [  274.802842] PM: Some devices failed to suspend, or early wake event detected
    [  275.426489] OOM killer enabled.
    [  275.429718] Restarting tasks ...
    [  275.435765] done.
    [  275.447510] PM: suspend exit
    
    Fixes: 1f565e263c3e ("media: mtk-vpu: VPU should be in idle state before system is suspended")
    Signed-off-by: Dafna Hirschfeld <dafna.hirschfeld@collabora.com>
    Signed-off-by: Hans Verkuil <hverkuil-cisco@xs4all.nl>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+huawei@kernel.org>

commit 5fa54346caf67b4b1b10b1f390316ae466da4d53
Author: Petr Mladek <pmladek@suse.com>
Date:   Thu Jun 24 18:39:48 2021 -0700

    kthread: prevent deadlock when kthread_mod_delayed_work() races with kthread_cancel_delayed_work_sync()
    
    The system might hang with the following backtrace:
    
            schedule+0x80/0x100
            schedule_timeout+0x48/0x138
            wait_for_common+0xa4/0x134
            wait_for_completion+0x1c/0x2c
            kthread_flush_work+0x114/0x1cc
            kthread_cancel_work_sync.llvm.16514401384283632983+0xe8/0x144
            kthread_cancel_delayed_work_sync+0x18/0x2c
            xxxx_pm_notify+0xb0/0xd8
            blocking_notifier_call_chain_robust+0x80/0x194
            pm_notifier_call_chain_robust+0x28/0x4c
            suspend_prepare+0x40/0x260
            enter_state+0x80/0x3f4
            pm_suspend+0x60/0xdc
            state_store+0x108/0x144
            kobj_attr_store+0x38/0x88
            sysfs_kf_write+0x64/0xc0
            kernfs_fop_write_iter+0x108/0x1d0
            vfs_write+0x2f4/0x368
            ksys_write+0x7c/0xec
    
    It is caused by the following race between kthread_mod_delayed_work()
    and kthread_cancel_delayed_work_sync():
    
    CPU0                            CPU1
    
    Context: Thread A               Context: Thread B
    
    kthread_mod_delayed_work()
      spin_lock()
      __kthread_cancel_work()
         spin_unlock()
         del_timer_sync()
                                    kthread_cancel_delayed_work_sync()
                                      spin_lock()
                                      __kthread_cancel_work()
                                        spin_unlock()
                                        del_timer_sync()
                                        spin_lock()
    
                                      work->canceling++
                                      spin_unlock
         spin_lock()
       queue_delayed_work()
         // dwork is put into the worker->delayed_work_list
    
       spin_unlock()
    
                                      kthread_flush_work()
         // flush_work is put at the tail of the dwork
    
                                        wait_for_completion()
    
    Context: IRQ
    
      kthread_delayed_work_timer_fn()
        spin_lock()
        list_del_init(&work->node);
        spin_unlock()
    
    BANG: flush_work is not longer linked and will never get proceed.
    
    The problem is that kthread_mod_delayed_work() checks work->canceling
    flag before canceling the timer.
    
    A simple solution is to (re)check work->canceling after
    __kthread_cancel_work().  But then it is not clear what should be
    returned when __kthread_cancel_work() removed the work from the queue
    (list) and it can't queue it again with the new @delay.
    
    The return value might be used for reference counting.  The caller has
    to know whether a new work has been queued or an existing one was
    replaced.
    
    The proper solution is that kthread_mod_delayed_work() will remove the
    work from the queue (list) _only_ when work->canceling is not set.  The
    flag must be checked after the timer is stopped and the remaining
    operations can be done under worker->lock.
    
    Note that kthread_mod_delayed_work() could remove the timer and then
    bail out.  It is fine.  The other canceling caller needs to cancel the
    timer as well.  The important thing is that the queue (list)
    manipulation is done atomically under worker->lock.
    
    Link: https://lkml.kernel.org/r/20210610133051.15337-3-pmladek@suse.com
    Fixes: 9a6b06c8d9a220860468a ("kthread: allow to modify delayed kthread work")
    Signed-off-by: Petr Mladek <pmladek@suse.com>
    Reported-by: Martin Liu <liumartin@google.com>
    Cc: <jenhaochen@google.com>
    Cc: Minchan Kim <minchan@google.com>
    Cc: Nathan Chancellor <nathan@kernel.org>
    Cc: Nick Desaulniers <ndesaulniers@google.com>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit f591dbb5fb8c82569378893b48f0ac9ebec78289
Author: Kuogee Hsieh <khsieh@codeaurora.org>
Date:   Thu Jun 3 08:40:46 2021 -0700

    drm/msm/dp: power off DP phy at suspend
    
    Normal DP suspend operation contains two steps, display off followed
    by dp suspend, to complete system wide suspending cycle if display is
    up at that time. In this case, DP phy will be powered off at display
    off. However there is an exception case that depending on the timing
    of dongle plug in during system wide suspending, sometimes display off
    procedure may be skipped and dp suspend was called directly. In this
    case, dp phy is stay at powered on (phy->power_count = 1) so that at
    next resume dp driver crash at main link clock enable due to phy is
    not physically powered on. This patch will call dp_ctrl_off_link_stream()
    to tear down main link and power off phy at dp_pm_suspend() if main link
    had been brought up.
    
    Changes in V2:
    -- stashed changes into dp_ctrl.c
    -- add is_phy_on to monitor phy state
    
    Changes in V3:
    -- delete is_phy_on
    -- call dp_ctrl_off_link_stream() from dp_pm_suspend()
    
    Changes in V4:
    -- delete changes made at dp_power.c
    -- move main link status checking to dp_pm_suspend
    
    Changes in V5:
    -- correct commit id at Fixes tag
    
    Fixes: 8dbde399044b ("drm/msm/dp: handle irq_hpd with sink_count = 0 correctly)
    Signed-off-by: Kuogee Hsieh <khsieh@codeaurora.org>
    Tested-by: Stephen Boyd <swboyd@chromium.org>
    Reviewed-by: Stephen Boyd <swboyd@chromium.org>
    Link: https://lore.kernel.org/r/1622734846-14179-1-git-send-email-khsieh@codeaurora.org
    Signed-off-by: Rob Clark <robdclark@chromium.org>

commit f86625ae0e35924ed495cdf0ff2d3133cb6e3010
Author: Sean Wang <sean.wang@mediatek.com>
Date:   Thu May 20 11:46:39 2021 +0800

    mt76: mt7921: fix invalid register access in wake_work
    
    Make sure mt7921_pm_wake_work wouldn't be scheduled after the driver is
    in suspend mode to fix the following the kernel crash.
    
    [ 3515.390012] mt7921e 0000:01:00.0: calling pci_pm_suspend+0x0/0x22c @ 2869, parent: 0000:00:00.0
    [ 3515.390015] mt7921e 0000:01:00.0: mt7921_pci_suspend +
    [ 3515.396395] anx7625 3-0058: anx7625_suspend+0x0/0x6c returned 0 after 0 usecs
    [ 3515.405965] mt7921e 0000:01:00.0: mt7921_pci_suspend -
    [ 3515.411336] usb 1-1.4: usb_dev_suspend+0x0/0x2c returned 0 after 1 usecs
    [ 3515.411513] SError Interrupt on CPU7, code 0xbe000011 -- SError
    [ 3515.411515] CPU: 7 PID: 2849 Comm: kworker/u16:27 Not tainted 5.4.114 #44
    [ 3515.411516] Hardware name: MediaTek Asurada rev1 board (DT)
    [ 3515.411517] Workqueue: mt76 mt7921_pm_wake_work [mt7921e]
    [ 3515.411518] pstate: 80c00009 (Nzcv daif +PAN +UAO)
    [ 3515.411519] pc : mt76_mmio_rr+0x30/0xf0 [mt76]
    [ 3515.411520] lr : mt7921_rr+0x38/0x44 [mt7921e]
    [ 3515.411520] sp : ffffffc015813c50
    [ 3515.411521] x29: ffffffc015813c50 x28: 0000000000000402
    [ 3515.411522] x27: ffffffe5a2012138 x26: ffffffe5a1eea018
    [ 3515.411524] x25: 00000000328be505 x24: 00000000000a0002
    [ 3515.411525] x23: 0000000000000006 x22: ffffffbd29b7a300
    [ 3515.411527] x21: ffffffbd29b7a300 x20: 00000000000e0010
    [ 3515.411528] x19: 00000000eac08f43 x18: 0000000000000000
    [ 3515.411529] x17: 0000000000000000 x16: ffffffe5a16b2914
    [ 3515.411531] x15: 0000000000000010 x14: 0000000000000010
    [ 3515.411532] x13: 00000000003dd3a2 x12: 0000000000010000
    [ 3515.411533] x11: ffffffe597abec14 x10: 0000000000000010
    [ 3515.411535] x9 : ffffffe597abeba8 x8 : ffffffc013ce0010
    [ 3515.411536] x7 : 000000b2b5593519 x6 : 0000000000300000
    [ 3515.411537] x5 : 0000000000000000 x4 : 0000000000000032
    [ 3515.411539] x3 : 0000000000000000 x2 : 0000000000000004
    [ 3515.411540] x1 : 00000000000e0010 x0 : ffffffbd29b7a300
    [ 3515.411542] Kernel panic - not syncing: Asynchronous SError Interrupt
    [ 3515.411543] CPU: 7 PID: 2849 Comm: kworker/u16:27 Not tainted 5.4.114 #44
    [ 3515.411544] Hardware name: MediaTek Asurada rev1 board (DT)
    [ 3515.411544] Workqueue: mt76 mt7921_pm_wake_work [mt7921e]
    [ 3515.411545] Call trace:
    [ 3515.411546]  dump_backtrace+0x0/0x14c
    [ 3515.411546]  show_stack+0x20/0x2c
    [ 3515.411547]  dump_stack+0xa0/0xfc
    [ 3515.411548]  panic+0x154/0x350
    [ 3515.411548]  panic+0x0/0x350
    [ 3515.411549]  arm64_serror_panic+0x78/0x84
    [ 3515.411550]  do_serror+0x0/0x118
    [ 3515.411550]  do_serror+0xa4/0x118
    [ 3515.411551]  el1_error+0x84/0xf8
    [ 3515.411552]  mt76_mmio_rr+0x30/0xf0 [mt76]
    [ 3515.411552]  mt7921_rr+0x38/0x44 [mt7921e]
    [ 3515.411553]  __mt76_poll_msec+0x5c/0x9c [mt76]
    [ 3515.411554]  __mt7921_mcu_drv_pmctrl+0x50/0x94 [mt7921e]
    [ 3515.411555]  mt7921_mcu_drv_pmctrl+0x38/0xb0 [mt7921e]
    [ 3515.411555]  mt7921_pm_wake_work+0x34/0xd4 [mt7921e]
    [ 3515.411556]  process_one_work+0x208/0x3c8
    [ 3515.411557]  worker_thread+0x23c/0x3e8
    [ 3515.411557]  kthread+0x144/0x178
    [ 3515.411558]  ret_from_fork+0x10/0x18
    [ 3515.418831] SMP: stopping secondary CPUs
    [ 3515.418832] Kernel Offset: 0x2590c00000 from 0xffffffc010000000
    [ 3515.418832] PHYS_OFFSET: 0xffffffc400000000
    [ 3515.418833] CPU features: 0x080026,2a80aa18
    [ 3515.418834] Memory Limit: none
    [DL] 00000000 00000000 010701
    
    Fixes: 1d8efc741df80 ("mt76: mt7921: introduce Runtime PM support")
    Co-developed-by: Lorenzo Bianconi <lorenzo@kernel.org>
    Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
    Signed-off-by: Sean Wang <sean.wang@mediatek.com>
    Signed-off-by: Felix Fietkau <nbd@nbd.name>

commit 0c010eae2febe81d7d25d554471cc015b950e0a1
Author: Jonathan Marek <jonathan@marek.ca>
Date:   Thu May 13 13:14:00 2021 -0400

    drm/msm/a6xx: avoid shadow NULL reference in failure path
    
    commit ce86c239e4d218ae6040bec18e6d19a58edb8b7c upstream.
    
    If a6xx_hw_init() fails before creating the shadow_bo, the a6xx_pm_suspend
    code referencing it will crash. Change the condition to one that avoids
    this problem (note: creation of shadow_bo is behind this same condition)
    
    Fixes: e8b0b994c3a5 ("drm/msm/a6xx: Clear shadow on suspend")
    Signed-off-by: Jonathan Marek <jonathan@marek.ca>
    Reviewed-by: Akhil P Oommen <akhilpo@codeaurora.org>
    Link: https://lore.kernel.org/r/20210513171431.18632-6-jonathan@marek.ca
    Signed-off-by: Rob Clark <robdclark@chromium.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit fd681a8c7ac8f649a0718f6cbf2fe75d0587c9a2
Author: Jonathan Marek <jonathan@marek.ca>
Date:   Thu May 13 13:14:00 2021 -0400

    drm/msm/a6xx: avoid shadow NULL reference in failure path
    
    commit ce86c239e4d218ae6040bec18e6d19a58edb8b7c upstream.
    
    If a6xx_hw_init() fails before creating the shadow_bo, the a6xx_pm_suspend
    code referencing it will crash. Change the condition to one that avoids
    this problem (note: creation of shadow_bo is behind this same condition)
    
    Fixes: e8b0b994c3a5 ("drm/msm/a6xx: Clear shadow on suspend")
    Signed-off-by: Jonathan Marek <jonathan@marek.ca>
    Reviewed-by: Akhil P Oommen <akhilpo@codeaurora.org>
    Link: https://lore.kernel.org/r/20210513171431.18632-6-jonathan@marek.ca
    Signed-off-by: Rob Clark <robdclark@chromium.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit ce86c239e4d218ae6040bec18e6d19a58edb8b7c
Author: Jonathan Marek <jonathan@marek.ca>
Date:   Thu May 13 13:14:00 2021 -0400

    drm/msm/a6xx: avoid shadow NULL reference in failure path
    
    If a6xx_hw_init() fails before creating the shadow_bo, the a6xx_pm_suspend
    code referencing it will crash. Change the condition to one that avoids
    this problem (note: creation of shadow_bo is behind this same condition)
    
    Fixes: e8b0b994c3a5 ("drm/msm/a6xx: Clear shadow on suspend")
    Signed-off-by: Jonathan Marek <jonathan@marek.ca>
    Reviewed-by: Akhil P Oommen <akhilpo@codeaurora.org>
    Link: https://lore.kernel.org/r/20210513171431.18632-6-jonathan@marek.ca
    Signed-off-by: Rob Clark <robdclark@chromium.org>

commit bce24d9300c32be06939d4afa528f7e3fb7ac85e
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Wed May 12 14:55:23 2021 +0200

    platform/x86: intel_int0002_vgpio: Only call enable_irq_wake() when using s2idle
    
    [ Upstream commit b68e182a3062e326b891f47152a3a1b84abccf0f ]
    
    Commit 871f1f2bcb01 ("platform/x86: intel_int0002_vgpio: Only implement
    irq_set_wake on Bay Trail") stopped passing irq_set_wake requests on to
    the parents IRQ because this was breaking suspend (causing immediate
    wakeups) on an Asus E202SA.
    
    This workaround for the Asus E202SA is causing wakeup by USB keyboard to
    not work on other devices with Airmont CPU cores such as the Medion Akoya
    E1239T. In hindsight the problem with the Asus E202SA has nothing to do
    with Silvermont vs Airmont CPU cores, so the differentiation between the
    2 types of CPU cores introduced by the previous fix is wrong.
    
    The real issue at hand is s2idle vs S3 suspend where the suspend is
    mostly handled by firmware. The parent IRQ for the INT0002 device is shared
    with the ACPI SCI and the real problem is that the INT0002 code should not
    be messing with the wakeup settings of that IRQ when suspend/resume is
    being handled by the firmware.
    
    Note that on systems which support both s2idle and S3 suspend, which
    suspend method to use can be changed at runtime.
    
    This patch fixes both the Asus E202SA spurious wakeups issue as well as
    the wakeup by USB keyboard not working on the Medion Akoya E1239T issue.
    
    These are both fixed by replacing the old workaround with delaying the
    enable_irq_wake(parent_irq) call till system-suspend time and protecting
    it with a !pm_suspend_via_firmware() check so that we still do not call
    it on devices using firmware-based (S3) suspend such as the Asus E202SA.
    
    Note rather then adding #ifdef CONFIG_PM_SLEEP, this commit simply adds
    a "depends on PM_SLEEP" to the Kconfig since this drivers whole purpose
    is to deal with wakeup events, so using it without CONFIG_PM_SLEEP makes
    no sense.
    
    Cc: Maxim Mikityanskiy <maxtram95@gmail.com>
    Fixes: 871f1f2bcb01 ("platform/x86: intel_int0002_vgpio: Only implement irq_set_wake on Bay Trail")
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Link: https://lore.kernel.org/r/20210512125523.55215-2-hdegoede@redhat.com
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit b8ff3221771a5a335cd795bfc6d5eba70b220b8f
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Wed May 12 14:55:23 2021 +0200

    platform/x86: intel_int0002_vgpio: Only call enable_irq_wake() when using s2idle
    
    [ Upstream commit b68e182a3062e326b891f47152a3a1b84abccf0f ]
    
    Commit 871f1f2bcb01 ("platform/x86: intel_int0002_vgpio: Only implement
    irq_set_wake on Bay Trail") stopped passing irq_set_wake requests on to
    the parents IRQ because this was breaking suspend (causing immediate
    wakeups) on an Asus E202SA.
    
    This workaround for the Asus E202SA is causing wakeup by USB keyboard to
    not work on other devices with Airmont CPU cores such as the Medion Akoya
    E1239T. In hindsight the problem with the Asus E202SA has nothing to do
    with Silvermont vs Airmont CPU cores, so the differentiation between the
    2 types of CPU cores introduced by the previous fix is wrong.
    
    The real issue at hand is s2idle vs S3 suspend where the suspend is
    mostly handled by firmware. The parent IRQ for the INT0002 device is shared
    with the ACPI SCI and the real problem is that the INT0002 code should not
    be messing with the wakeup settings of that IRQ when suspend/resume is
    being handled by the firmware.
    
    Note that on systems which support both s2idle and S3 suspend, which
    suspend method to use can be changed at runtime.
    
    This patch fixes both the Asus E202SA spurious wakeups issue as well as
    the wakeup by USB keyboard not working on the Medion Akoya E1239T issue.
    
    These are both fixed by replacing the old workaround with delaying the
    enable_irq_wake(parent_irq) call till system-suspend time and protecting
    it with a !pm_suspend_via_firmware() check so that we still do not call
    it on devices using firmware-based (S3) suspend such as the Asus E202SA.
    
    Note rather then adding #ifdef CONFIG_PM_SLEEP, this commit simply adds
    a "depends on PM_SLEEP" to the Kconfig since this drivers whole purpose
    is to deal with wakeup events, so using it without CONFIG_PM_SLEEP makes
    no sense.
    
    Cc: Maxim Mikityanskiy <maxtram95@gmail.com>
    Fixes: 871f1f2bcb01 ("platform/x86: intel_int0002_vgpio: Only implement irq_set_wake on Bay Trail")
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Link: https://lore.kernel.org/r/20210512125523.55215-2-hdegoede@redhat.com
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit b68e182a3062e326b891f47152a3a1b84abccf0f
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Wed May 12 14:55:23 2021 +0200

    platform/x86: intel_int0002_vgpio: Only call enable_irq_wake() when using s2idle
    
    Commit 871f1f2bcb01 ("platform/x86: intel_int0002_vgpio: Only implement
    irq_set_wake on Bay Trail") stopped passing irq_set_wake requests on to
    the parents IRQ because this was breaking suspend (causing immediate
    wakeups) on an Asus E202SA.
    
    This workaround for the Asus E202SA is causing wakeup by USB keyboard to
    not work on other devices with Airmont CPU cores such as the Medion Akoya
    E1239T. In hindsight the problem with the Asus E202SA has nothing to do
    with Silvermont vs Airmont CPU cores, so the differentiation between the
    2 types of CPU cores introduced by the previous fix is wrong.
    
    The real issue at hand is s2idle vs S3 suspend where the suspend is
    mostly handled by firmware. The parent IRQ for the INT0002 device is shared
    with the ACPI SCI and the real problem is that the INT0002 code should not
    be messing with the wakeup settings of that IRQ when suspend/resume is
    being handled by the firmware.
    
    Note that on systems which support both s2idle and S3 suspend, which
    suspend method to use can be changed at runtime.
    
    This patch fixes both the Asus E202SA spurious wakeups issue as well as
    the wakeup by USB keyboard not working on the Medion Akoya E1239T issue.
    
    These are both fixed by replacing the old workaround with delaying the
    enable_irq_wake(parent_irq) call till system-suspend time and protecting
    it with a !pm_suspend_via_firmware() check so that we still do not call
    it on devices using firmware-based (S3) suspend such as the Asus E202SA.
    
    Note rather then adding #ifdef CONFIG_PM_SLEEP, this commit simply adds
    a "depends on PM_SLEEP" to the Kconfig since this drivers whole purpose
    is to deal with wakeup events, so using it without CONFIG_PM_SLEEP makes
    no sense.
    
    Cc: Maxim Mikityanskiy <maxtram95@gmail.com>
    Fixes: 871f1f2bcb01 ("platform/x86: intel_int0002_vgpio: Only implement irq_set_wake on Bay Trail")
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Link: https://lore.kernel.org/r/20210512125523.55215-2-hdegoede@redhat.com

commit 8c6d2e0ee501dc34ec0e7b5126783f2f51fca483
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed May 5 14:09:15 2021 +0300

    PM: runtime: Fix unpaired parent child_count for force_resume
    
    commit c745253e2a691a40c66790defe85c104a887e14a upstream.
    
    As pm_runtime_need_not_resume() relies also on usage_count, it can return
    a different value in pm_runtime_force_suspend() compared to when called in
    pm_runtime_force_resume(). Different return values can happen if anything
    calls PM runtime functions in between, and causes the parent child_count
    to increase on every resume.
    
    So far I've seen the issue only for omapdrm that does complicated things
    with PM runtime calls during system suspend for legacy reasons:
    
    omap_atomic_commit_tail() for omapdrm.0
     dispc_runtime_get()
      wakes up 58000000.dss as it's the dispc parent
       dispc_runtime_resume()
        rpm_resume() increases parent child_count
     dispc_runtime_put() won't idle, PM runtime suspend blocked
    pm_runtime_force_suspend() for 58000000.dss, !pm_runtime_need_not_resume()
     __update_runtime_status()
    system suspended
    pm_runtime_force_resume() for 58000000.dss, pm_runtime_need_not_resume()
     pm_runtime_enable() only called because of pm_runtime_need_not_resume()
    omap_atomic_commit_tail() for omapdrm.0
     dispc_runtime_get()
      wakes up 58000000.dss as it's the dispc parent
       dispc_runtime_resume()
        rpm_resume() increases parent child_count
     dispc_runtime_put() won't idle, PM runtime suspend blocked
    ...
    rpm_suspend for 58000000.dss but parent child_count is now unbalanced
    
    Let's fix the issue by adding a flag for needs_force_resume and use it in
    pm_runtime_force_resume() instead of pm_runtime_need_not_resume().
    
    Additionally omapdrm system suspend could be simplified later on to avoid
    lots of unnecessary PM runtime calls and the complexity it adds. The
    driver can just use internal functions that are shared between the PM
    runtime and system suspend related functions.
    
    Fixes: 4918e1f87c5f ("PM / runtime: Rework pm_runtime_force_suspend/resume()")
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Tested-by: Tomi Valkeinen <tomi.valkeinen@ideasonboard.com>
    Cc: 4.16+ <stable@vger.kernel.org> # 4.16+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit b7fefdce0ed1841291a6f56fef9c9f15190b8d85
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed May 5 14:09:15 2021 +0300

    PM: runtime: Fix unpaired parent child_count for force_resume
    
    commit c745253e2a691a40c66790defe85c104a887e14a upstream.
    
    As pm_runtime_need_not_resume() relies also on usage_count, it can return
    a different value in pm_runtime_force_suspend() compared to when called in
    pm_runtime_force_resume(). Different return values can happen if anything
    calls PM runtime functions in between, and causes the parent child_count
    to increase on every resume.
    
    So far I've seen the issue only for omapdrm that does complicated things
    with PM runtime calls during system suspend for legacy reasons:
    
    omap_atomic_commit_tail() for omapdrm.0
     dispc_runtime_get()
      wakes up 58000000.dss as it's the dispc parent
       dispc_runtime_resume()
        rpm_resume() increases parent child_count
     dispc_runtime_put() won't idle, PM runtime suspend blocked
    pm_runtime_force_suspend() for 58000000.dss, !pm_runtime_need_not_resume()
     __update_runtime_status()
    system suspended
    pm_runtime_force_resume() for 58000000.dss, pm_runtime_need_not_resume()
     pm_runtime_enable() only called because of pm_runtime_need_not_resume()
    omap_atomic_commit_tail() for omapdrm.0
     dispc_runtime_get()
      wakes up 58000000.dss as it's the dispc parent
       dispc_runtime_resume()
        rpm_resume() increases parent child_count
     dispc_runtime_put() won't idle, PM runtime suspend blocked
    ...
    rpm_suspend for 58000000.dss but parent child_count is now unbalanced
    
    Let's fix the issue by adding a flag for needs_force_resume and use it in
    pm_runtime_force_resume() instead of pm_runtime_need_not_resume().
    
    Additionally omapdrm system suspend could be simplified later on to avoid
    lots of unnecessary PM runtime calls and the complexity it adds. The
    driver can just use internal functions that are shared between the PM
    runtime and system suspend related functions.
    
    Fixes: 4918e1f87c5f ("PM / runtime: Rework pm_runtime_force_suspend/resume()")
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Tested-by: Tomi Valkeinen <tomi.valkeinen@ideasonboard.com>
    Cc: 4.16+ <stable@vger.kernel.org> # 4.16+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 182f1f72af2e6803f1470a7e16a76ef0c63cc124
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed May 5 14:09:15 2021 +0300

    PM: runtime: Fix unpaired parent child_count for force_resume
    
    commit c745253e2a691a40c66790defe85c104a887e14a upstream.
    
    As pm_runtime_need_not_resume() relies also on usage_count, it can return
    a different value in pm_runtime_force_suspend() compared to when called in
    pm_runtime_force_resume(). Different return values can happen if anything
    calls PM runtime functions in between, and causes the parent child_count
    to increase on every resume.
    
    So far I've seen the issue only for omapdrm that does complicated things
    with PM runtime calls during system suspend for legacy reasons:
    
    omap_atomic_commit_tail() for omapdrm.0
     dispc_runtime_get()
      wakes up 58000000.dss as it's the dispc parent
       dispc_runtime_resume()
        rpm_resume() increases parent child_count
     dispc_runtime_put() won't idle, PM runtime suspend blocked
    pm_runtime_force_suspend() for 58000000.dss, !pm_runtime_need_not_resume()
     __update_runtime_status()
    system suspended
    pm_runtime_force_resume() for 58000000.dss, pm_runtime_need_not_resume()
     pm_runtime_enable() only called because of pm_runtime_need_not_resume()
    omap_atomic_commit_tail() for omapdrm.0
     dispc_runtime_get()
      wakes up 58000000.dss as it's the dispc parent
       dispc_runtime_resume()
        rpm_resume() increases parent child_count
     dispc_runtime_put() won't idle, PM runtime suspend blocked
    ...
    rpm_suspend for 58000000.dss but parent child_count is now unbalanced
    
    Let's fix the issue by adding a flag for needs_force_resume and use it in
    pm_runtime_force_resume() instead of pm_runtime_need_not_resume().
    
    Additionally omapdrm system suspend could be simplified later on to avoid
    lots of unnecessary PM runtime calls and the complexity it adds. The
    driver can just use internal functions that are shared between the PM
    runtime and system suspend related functions.
    
    Fixes: 4918e1f87c5f ("PM / runtime: Rework pm_runtime_force_suspend/resume()")
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Tested-by: Tomi Valkeinen <tomi.valkeinen@ideasonboard.com>
    Cc: 4.16+ <stable@vger.kernel.org> # 4.16+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 6c799f6c742718ca574d13d9b3d40592730f62c0
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed May 5 14:09:15 2021 +0300

    PM: runtime: Fix unpaired parent child_count for force_resume
    
    commit c745253e2a691a40c66790defe85c104a887e14a upstream.
    
    As pm_runtime_need_not_resume() relies also on usage_count, it can return
    a different value in pm_runtime_force_suspend() compared to when called in
    pm_runtime_force_resume(). Different return values can happen if anything
    calls PM runtime functions in between, and causes the parent child_count
    to increase on every resume.
    
    So far I've seen the issue only for omapdrm that does complicated things
    with PM runtime calls during system suspend for legacy reasons:
    
    omap_atomic_commit_tail() for omapdrm.0
     dispc_runtime_get()
      wakes up 58000000.dss as it's the dispc parent
       dispc_runtime_resume()
        rpm_resume() increases parent child_count
     dispc_runtime_put() won't idle, PM runtime suspend blocked
    pm_runtime_force_suspend() for 58000000.dss, !pm_runtime_need_not_resume()
     __update_runtime_status()
    system suspended
    pm_runtime_force_resume() for 58000000.dss, pm_runtime_need_not_resume()
     pm_runtime_enable() only called because of pm_runtime_need_not_resume()
    omap_atomic_commit_tail() for omapdrm.0
     dispc_runtime_get()
      wakes up 58000000.dss as it's the dispc parent
       dispc_runtime_resume()
        rpm_resume() increases parent child_count
     dispc_runtime_put() won't idle, PM runtime suspend blocked
    ...
    rpm_suspend for 58000000.dss but parent child_count is now unbalanced
    
    Let's fix the issue by adding a flag for needs_force_resume and use it in
    pm_runtime_force_resume() instead of pm_runtime_need_not_resume().
    
    Additionally omapdrm system suspend could be simplified later on to avoid
    lots of unnecessary PM runtime calls and the complexity it adds. The
    driver can just use internal functions that are shared between the PM
    runtime and system suspend related functions.
    
    Fixes: 4918e1f87c5f ("PM / runtime: Rework pm_runtime_force_suspend/resume()")
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Tested-by: Tomi Valkeinen <tomi.valkeinen@ideasonboard.com>
    Cc: 4.16+ <stable@vger.kernel.org> # 4.16+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit b13cbc536990ff609afa878b6211cd6f6265ba60
Author: Sean Wang <sean.wang@mediatek.com>
Date:   Mon Apr 19 23:58:05 2021 +0800

    mt76: mt7921: fix possible invalid register access
    
    [ Upstream commit fe3fccde8870764ba3e60610774bd7bc9f8faeff ]
    
    Disable the interrupt and synchronze for the pending irq handlers to ensure
    the irq tasklet is not being scheduled after the suspend to avoid the
    possible invalid register access acts when the host pcie controller is
    suspended.
    
    [17932.910534] mt7921e 0000:01:00.0: pci_pm_suspend+0x0/0x22c returned 0 after 21375 usecs
    [17932.910590] pcieport 0000:00:00.0: calling pci_pm_suspend+0x0/0x22c @ 18565, parent: pci0000:00
    [17932.910602] pcieport 0000:00:00.0: pci_pm_suspend+0x0/0x22c returned 0 after 8 usecs
    [17932.910671] mtk-pcie 11230000.pcie: calling platform_pm_suspend+0x0/0x60 @ 22783, parent: soc
    [17932.910674] mtk-pcie 11230000.pcie: platform_pm_suspend+0x0/0x60 returned 0 after 0 usecs
    
    ...
    
    17933.615352] x1 : 00000000000d4200 x0 : ffffff8269ca2300
    [17933.620666] Call trace:
    [17933.623127]  mt76_mmio_rr+0x28/0xf0 [mt76]
    [17933.627234]  mt7921_rr+0x38/0x44 [mt7921e]
    [17933.631339]  mt7921_irq_tasklet+0x54/0x1d8 [mt7921e]
    [17933.636309]  tasklet_action_common+0x12c/0x16c
    [17933.640754]  tasklet_action+0x24/0x2c
    [17933.644418]  __do_softirq+0x16c/0x344
    [17933.648082]  irq_exit+0xa8/0xac
    [17933.651224]  scheduler_ipi+0xd4/0x148
    [17933.654890]  handle_IPI+0x164/0x2d4
    [17933.658379]  gic_handle_irq+0x140/0x178
    [17933.662216]  el1_irq+0xb8/0x180
    [17933.665361]  cpuidle_enter_state+0xf8/0x204
    [17933.669544]  cpuidle_enter+0x38/0x4c
    [17933.673122]  do_idle+0x1a4/0x2a8
    [17933.676352]  cpu_startup_entry+0x24/0x28
    [17933.680276]  rest_init+0xd4/0xe0
    [17933.683508]  arch_call_rest_init+0x10/0x18
    [17933.687606]  start_kernel+0x340/0x3b4
    [17933.691279] Code: aa0003f5 d503201f f953eaa8 8b344108 (b9400113)
    [17933.697373] ---[ end trace a24b8e26ffbda3c5 ]---
    [17933.767846] Kernel panic - not syncing: Fatal exception in interrupt
    
    Fixes: ffa1bf97425b ("mt76: mt7921: introduce PM support")
    Signed-off-by: Sean Wang <sean.wang@mediatek.com>
    Signed-off-by: Felix Fietkau <nbd@nbd.name>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 5cad9e2caa9613fdcd246bd4ebf0ffbec1cba2ca
Author: Dafna Hirschfeld <dafna.hirschfeld@collabora.com>
Date:   Fri Apr 16 12:54:49 2021 +0200

    iommu/mediatek: Always enable the clk on resume
    
    [ Upstream commit b34ea31fe013569d42b7e8681ef3f717f77c5b72 ]
    
    In mtk_iommu_runtime_resume always enable the clk, even
    if m4u_dom is null. Otherwise the 'suspend' cb might
    disable the clk which is already disabled causing the warning:
    
    [    1.586104] infra_m4u already disabled
    [    1.586133] WARNING: CPU: 0 PID: 121 at drivers/clk/clk.c:952 clk_core_disable+0xb0/0xb8
    [    1.594391] mtk-iommu 10205000.iommu: bound 18001000.larb (ops mtk_smi_larb_component_ops)
    [    1.598108] Modules linked in:
    [    1.598114] CPU: 0 PID: 121 Comm: kworker/0:2 Not tainted 5.12.0-rc5 #69
    [    1.609246] mtk-iommu 10205000.iommu: bound 14027000.larb (ops mtk_smi_larb_component_ops)
    [    1.617487] Hardware name: Google Elm (DT)
    [    1.617491] Workqueue: pm pm_runtime_work
    [    1.620545] mtk-iommu 10205000.iommu: bound 19001000.larb (ops mtk_smi_larb_component_ops)
    
    [    1.627229] pstate: 60000085 (nZCv daIf -PAN -UAO -TCO BTYPE=--)
    [    1.659297] pc : clk_core_disable+0xb0/0xb8
    [    1.663475] lr : clk_core_disable+0xb0/0xb8
    [    1.667652] sp : ffff800011b9bbe0
    [    1.670959] x29: ffff800011b9bbe0 x28: 0000000000000000
    [    1.676267] x27: ffff800011448000 x26: ffff8000100cfd98
    [    1.681574] x25: ffff800011b9bd48 x24: 0000000000000000
    [    1.686882] x23: 0000000000000000 x22: ffff8000106fad90
    [    1.692189] x21: 000000000000000a x20: ffff0000c0048500
    [    1.697496] x19: ffff0000c0048500 x18: ffffffffffffffff
    [    1.702804] x17: 0000000000000000 x16: 0000000000000000
    [    1.708112] x15: ffff800011460300 x14: fffffffffffe0000
    [    1.713420] x13: ffff8000114602d8 x12: 0720072007200720
    [    1.718727] x11: 0720072007200720 x10: 0720072007200720
    [    1.724035] x9 : ffff800011b9bbe0 x8 : ffff800011b9bbe0
    [    1.729342] x7 : 0000000000000009 x6 : ffff8000114b8328
    [    1.734649] x5 : 0000000000000000 x4 : 0000000000000000
    [    1.739956] x3 : 00000000ffffffff x2 : ffff800011460298
    [    1.745263] x1 : 1af1d7de276f4500 x0 : 0000000000000000
    [    1.750572] Call trace:
    [    1.753010]  clk_core_disable+0xb0/0xb8
    [    1.756840]  clk_core_disable_lock+0x24/0x40
    [    1.761105]  clk_disable+0x20/0x30
    [    1.764501]  mtk_iommu_runtime_suspend+0x88/0xa8
    [    1.769114]  pm_generic_runtime_suspend+0x2c/0x48
    [    1.773815]  __rpm_callback+0xe0/0x178
    [    1.777559]  rpm_callback+0x24/0x88
    [    1.781041]  rpm_suspend+0xdc/0x470
    [    1.784523]  rpm_idle+0x12c/0x170
    [    1.787831]  pm_runtime_work+0xa8/0xc0
    [    1.791573]  process_one_work+0x1e8/0x360
    [    1.795580]  worker_thread+0x44/0x478
    [    1.799237]  kthread+0x150/0x158
    [    1.802460]  ret_from_fork+0x10/0x30
    [    1.806034] ---[ end trace 82402920ef64573b ]---
    [    1.810728] ------------[ cut here ]------------
    
    In addition, we now don't need to enable the clock from the
    function mtk_iommu_hw_init since it is already enabled by the resume.
    
    Fixes: c0b57581b73b ("iommu/mediatek: Add power-domain operation")
    Signed-off-by: Dafna Hirschfeld <dafna.hirschfeld@collabora.com>
    Reviewed-by: Yong Wu <yong.wu@mediatek.com>
    Link: https://lore.kernel.org/r/20210416105449.4744-1-dafna.hirschfeld@collabora.com
    Signed-off-by: Joerg Roedel <jroedel@suse.de>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit b294ff3e34490f36233230e9ca70503d3924a6f3
Author: Asutosh Das <asutoshd@codeaurora.org>
Date:   Fri Apr 23 17:20:16 2021 -0700

    scsi: ufs: core: Enable power management for wlun
    
    During runtime-suspend of ufs host, the SCSI devices are already suspended
    and so are the queues associated with them. However, the ufs host sends SSU
    (START_STOP_UNIT) to the wlun during runtime-suspend.
    
    During the process blk_queue_enter() checks if the queue is not in suspended
    state. If so, it waits for the queue to resume, and never comes out of
    it. Commit 52abca64fd94 ("scsi: block: Do not accept any requests while
    suspended") adds the check to see if the queue is in suspended state in
    blk_queue_enter().
    
    Call trace:
     __switch_to+0x174/0x2c4
     __schedule+0x478/0x764
     schedule+0x9c/0xe0
     blk_queue_enter+0x158/0x228
     blk_mq_alloc_request+0x40/0xa4
     blk_get_request+0x2c/0x70
     __scsi_execute+0x60/0x1c4
     ufshcd_set_dev_pwr_mode+0x124/0x1e4
     ufshcd_suspend+0x208/0x83c
     ufshcd_runtime_suspend+0x40/0x154
     ufshcd_pltfrm_runtime_suspend+0x14/0x20
     pm_generic_runtime_suspend+0x28/0x3c
     __rpm_callback+0x80/0x2a4
     rpm_suspend+0x308/0x614
     rpm_idle+0x158/0x228
     pm_runtime_work+0x84/0xac
     process_one_work+0x1f0/0x470
     worker_thread+0x26c/0x4c8
     kthread+0x13c/0x320
     ret_from_fork+0x10/0x18
    
    Fix this by registering ufs device wlun as a SCSI driver and registering it
    for block runtime-pm. Also make this a supplier for all other LUNs. This
    way the wlun device suspends after all the consumers and resumes after HBA
    resumes. This also registers a new SCSI driver for rpmb wlun. This new
    driver is mostly used to clear rpmb uac.
    
    [mkp: resolve merge conflict with 5.13-rc1 and fix doc warning]
    
    Fixed smatch warnings:
    Reported-by: kernel test robot <lkp@intel.com>
    Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
    
    Link: https://lore.kernel.org/r/4662c462e79e3e7f541f54f88f8993f421026d83.1619223249.git.asutoshd@codeaurora.org
    Reviewed-by: Adrian Hunter <adrian.hunter@intel.com>
    Co-developed-by: Can Guo <cang@codeaurora.org>
    Signed-off-by: Can Guo <cang@codeaurora.org>
    Signed-off-by: Asutosh Das <asutoshd@codeaurora.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

commit c745253e2a691a40c66790defe85c104a887e14a
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed May 5 14:09:15 2021 +0300

    PM: runtime: Fix unpaired parent child_count for force_resume
    
    As pm_runtime_need_not_resume() relies also on usage_count, it can return
    a different value in pm_runtime_force_suspend() compared to when called in
    pm_runtime_force_resume(). Different return values can happen if anything
    calls PM runtime functions in between, and causes the parent child_count
    to increase on every resume.
    
    So far I've seen the issue only for omapdrm that does complicated things
    with PM runtime calls during system suspend for legacy reasons:
    
    omap_atomic_commit_tail() for omapdrm.0
     dispc_runtime_get()
      wakes up 58000000.dss as it's the dispc parent
       dispc_runtime_resume()
        rpm_resume() increases parent child_count
     dispc_runtime_put() won't idle, PM runtime suspend blocked
    pm_runtime_force_suspend() for 58000000.dss, !pm_runtime_need_not_resume()
     __update_runtime_status()
    system suspended
    pm_runtime_force_resume() for 58000000.dss, pm_runtime_need_not_resume()
     pm_runtime_enable() only called because of pm_runtime_need_not_resume()
    omap_atomic_commit_tail() for omapdrm.0
     dispc_runtime_get()
      wakes up 58000000.dss as it's the dispc parent
       dispc_runtime_resume()
        rpm_resume() increases parent child_count
     dispc_runtime_put() won't idle, PM runtime suspend blocked
    ...
    rpm_suspend for 58000000.dss but parent child_count is now unbalanced
    
    Let's fix the issue by adding a flag for needs_force_resume and use it in
    pm_runtime_force_resume() instead of pm_runtime_need_not_resume().
    
    Additionally omapdrm system suspend could be simplified later on to avoid
    lots of unnecessary PM runtime calls and the complexity it adds. The
    driver can just use internal functions that are shared between the PM
    runtime and system suspend related functions.
    
    Fixes: 4918e1f87c5f ("PM / runtime: Rework pm_runtime_force_suspend/resume()")
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Tested-by: Tomi Valkeinen <tomi.valkeinen@ideasonboard.com>
    Cc: 4.16+ <stable@vger.kernel.org> # 4.16+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit fe3fccde8870764ba3e60610774bd7bc9f8faeff
Author: Sean Wang <sean.wang@mediatek.com>
Date:   Mon Apr 19 23:58:05 2021 +0800

    mt76: mt7921: fix possible invalid register access
    
    Disable the interrupt and synchronze for the pending irq handlers to ensure
    the irq tasklet is not being scheduled after the suspend to avoid the
    possible invalid register access acts when the host pcie controller is
    suspended.
    
    [17932.910534] mt7921e 0000:01:00.0: pci_pm_suspend+0x0/0x22c returned 0 after 21375 usecs
    [17932.910590] pcieport 0000:00:00.0: calling pci_pm_suspend+0x0/0x22c @ 18565, parent: pci0000:00
    [17932.910602] pcieport 0000:00:00.0: pci_pm_suspend+0x0/0x22c returned 0 after 8 usecs
    [17932.910671] mtk-pcie 11230000.pcie: calling platform_pm_suspend+0x0/0x60 @ 22783, parent: soc
    [17932.910674] mtk-pcie 11230000.pcie: platform_pm_suspend+0x0/0x60 returned 0 after 0 usecs
    
    ...
    
    17933.615352] x1 : 00000000000d4200 x0 : ffffff8269ca2300
    [17933.620666] Call trace:
    [17933.623127]  mt76_mmio_rr+0x28/0xf0 [mt76]
    [17933.627234]  mt7921_rr+0x38/0x44 [mt7921e]
    [17933.631339]  mt7921_irq_tasklet+0x54/0x1d8 [mt7921e]
    [17933.636309]  tasklet_action_common+0x12c/0x16c
    [17933.640754]  tasklet_action+0x24/0x2c
    [17933.644418]  __do_softirq+0x16c/0x344
    [17933.648082]  irq_exit+0xa8/0xac
    [17933.651224]  scheduler_ipi+0xd4/0x148
    [17933.654890]  handle_IPI+0x164/0x2d4
    [17933.658379]  gic_handle_irq+0x140/0x178
    [17933.662216]  el1_irq+0xb8/0x180
    [17933.665361]  cpuidle_enter_state+0xf8/0x204
    [17933.669544]  cpuidle_enter+0x38/0x4c
    [17933.673122]  do_idle+0x1a4/0x2a8
    [17933.676352]  cpu_startup_entry+0x24/0x28
    [17933.680276]  rest_init+0xd4/0xe0
    [17933.683508]  arch_call_rest_init+0x10/0x18
    [17933.687606]  start_kernel+0x340/0x3b4
    [17933.691279] Code: aa0003f5 d503201f f953eaa8 8b344108 (b9400113)
    [17933.697373] ---[ end trace a24b8e26ffbda3c5 ]---
    [17933.767846] Kernel panic - not syncing: Fatal exception in interrupt
    
    Fixes: ffa1bf97425b ("mt76: mt7921: introduce PM support")
    Signed-off-by: Sean Wang <sean.wang@mediatek.com>
    Signed-off-by: Felix Fietkau <nbd@nbd.name>

commit f1b4be4a753caa4056496f679d70550d0c11a264
Author: Yongxin Liu <yongxin.liu@windriver.com>
Date:   Mon Mar 22 15:14:48 2021 +0800

    ixgbe: fix unbalanced device enable/disable in suspend/resume
    
    commit debb9df311582c83fe369baa35fa4b92e8a9c58a upstream.
    
    pci_disable_device() called in __ixgbe_shutdown() decreases
    dev->enable_cnt by 1. pci_enable_device_mem() which increases
    dev->enable_cnt by 1, was removed from ixgbe_resume() in commit
    6f82b2558735 ("ixgbe: use generic power management"). This caused
    unbalanced increase/decrease. So add pci_enable_device_mem() back.
    
    Fix the following call trace.
    
      ixgbe 0000:17:00.1: disabling already-disabled device
      Call Trace:
       __ixgbe_shutdown+0x10a/0x1e0 [ixgbe]
       ixgbe_suspend+0x32/0x70 [ixgbe]
       pci_pm_suspend+0x87/0x160
       ? pci_pm_freeze+0xd0/0xd0
       dpm_run_callback+0x42/0x170
       __device_suspend+0x114/0x460
       async_suspend+0x1f/0xa0
       async_run_entry_fn+0x3c/0xf0
       process_one_work+0x1dd/0x410
       worker_thread+0x34/0x3f0
       ? cancel_delayed_work+0x90/0x90
       kthread+0x14c/0x170
       ? kthread_park+0x90/0x90
       ret_from_fork+0x1f/0x30
    
    Fixes: 6f82b2558735 ("ixgbe: use generic power management")
    Signed-off-by: Yongxin Liu <yongxin.liu@windriver.com>
    Tested-by: Dave Switzer <david.switzer@intel.com>
    Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit be07581aacae7cd0a073afae8e8862032f794309
Author: Yongxin Liu <yongxin.liu@windriver.com>
Date:   Mon Mar 22 15:14:48 2021 +0800

    ixgbe: fix unbalanced device enable/disable in suspend/resume
    
    commit debb9df311582c83fe369baa35fa4b92e8a9c58a upstream.
    
    pci_disable_device() called in __ixgbe_shutdown() decreases
    dev->enable_cnt by 1. pci_enable_device_mem() which increases
    dev->enable_cnt by 1, was removed from ixgbe_resume() in commit
    6f82b2558735 ("ixgbe: use generic power management"). This caused
    unbalanced increase/decrease. So add pci_enable_device_mem() back.
    
    Fix the following call trace.
    
      ixgbe 0000:17:00.1: disabling already-disabled device
      Call Trace:
       __ixgbe_shutdown+0x10a/0x1e0 [ixgbe]
       ixgbe_suspend+0x32/0x70 [ixgbe]
       pci_pm_suspend+0x87/0x160
       ? pci_pm_freeze+0xd0/0xd0
       dpm_run_callback+0x42/0x170
       __device_suspend+0x114/0x460
       async_suspend+0x1f/0xa0
       async_run_entry_fn+0x3c/0xf0
       process_one_work+0x1dd/0x410
       worker_thread+0x34/0x3f0
       ? cancel_delayed_work+0x90/0x90
       kthread+0x14c/0x170
       ? kthread_park+0x90/0x90
       ret_from_fork+0x1f/0x30
    
    Fixes: 6f82b2558735 ("ixgbe: use generic power management")
    Signed-off-by: Yongxin Liu <yongxin.liu@windriver.com>
    Tested-by: Dave Switzer <david.switzer@intel.com>
    Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 5b11705608898c31a1cae5340555ee60d5a4fa45
Author: Hsin-Yi Wang <hsinyi@chromium.org>
Date:   Tue Apr 20 16:08:53 2021 +0300

    drm/i915/selftests: Rename pm_ prefixed functions names
    
    pm_resume and pm_suspend might be conflict with the ones defined in
    include/linux/suspend.h. Rename all pm_* to igt_pm_* in selftests since
    they are only used here.
    
    v2 by Jani:
    - Use igt_ prefix instead of i915_ to avoid colliding with existing
      i915_pm_* functions
    - Rename all pm_ prefixed functions in the file
    
    Signed-off-by: Hsin-Yi Wang <hsinyi@chromium.org>
    Reported-by: kernel test robot <lkp@intel.com>
    Reviewed-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20210420130853.10573-1-jani.nikula@intel.com

commit b34ea31fe013569d42b7e8681ef3f717f77c5b72
Author: Dafna Hirschfeld <dafna.hirschfeld@collabora.com>
Date:   Fri Apr 16 12:54:49 2021 +0200

    iommu/mediatek: Always enable the clk on resume
    
    In mtk_iommu_runtime_resume always enable the clk, even
    if m4u_dom is null. Otherwise the 'suspend' cb might
    disable the clk which is already disabled causing the warning:
    
    [    1.586104] infra_m4u already disabled
    [    1.586133] WARNING: CPU: 0 PID: 121 at drivers/clk/clk.c:952 clk_core_disable+0xb0/0xb8
    [    1.594391] mtk-iommu 10205000.iommu: bound 18001000.larb (ops mtk_smi_larb_component_ops)
    [    1.598108] Modules linked in:
    [    1.598114] CPU: 0 PID: 121 Comm: kworker/0:2 Not tainted 5.12.0-rc5 #69
    [    1.609246] mtk-iommu 10205000.iommu: bound 14027000.larb (ops mtk_smi_larb_component_ops)
    [    1.617487] Hardware name: Google Elm (DT)
    [    1.617491] Workqueue: pm pm_runtime_work
    [    1.620545] mtk-iommu 10205000.iommu: bound 19001000.larb (ops mtk_smi_larb_component_ops)
    
    [    1.627229] pstate: 60000085 (nZCv daIf -PAN -UAO -TCO BTYPE=--)
    [    1.659297] pc : clk_core_disable+0xb0/0xb8
    [    1.663475] lr : clk_core_disable+0xb0/0xb8
    [    1.667652] sp : ffff800011b9bbe0
    [    1.670959] x29: ffff800011b9bbe0 x28: 0000000000000000
    [    1.676267] x27: ffff800011448000 x26: ffff8000100cfd98
    [    1.681574] x25: ffff800011b9bd48 x24: 0000000000000000
    [    1.686882] x23: 0000000000000000 x22: ffff8000106fad90
    [    1.692189] x21: 000000000000000a x20: ffff0000c0048500
    [    1.697496] x19: ffff0000c0048500 x18: ffffffffffffffff
    [    1.702804] x17: 0000000000000000 x16: 0000000000000000
    [    1.708112] x15: ffff800011460300 x14: fffffffffffe0000
    [    1.713420] x13: ffff8000114602d8 x12: 0720072007200720
    [    1.718727] x11: 0720072007200720 x10: 0720072007200720
    [    1.724035] x9 : ffff800011b9bbe0 x8 : ffff800011b9bbe0
    [    1.729342] x7 : 0000000000000009 x6 : ffff8000114b8328
    [    1.734649] x5 : 0000000000000000 x4 : 0000000000000000
    [    1.739956] x3 : 00000000ffffffff x2 : ffff800011460298
    [    1.745263] x1 : 1af1d7de276f4500 x0 : 0000000000000000
    [    1.750572] Call trace:
    [    1.753010]  clk_core_disable+0xb0/0xb8
    [    1.756840]  clk_core_disable_lock+0x24/0x40
    [    1.761105]  clk_disable+0x20/0x30
    [    1.764501]  mtk_iommu_runtime_suspend+0x88/0xa8
    [    1.769114]  pm_generic_runtime_suspend+0x2c/0x48
    [    1.773815]  __rpm_callback+0xe0/0x178
    [    1.777559]  rpm_callback+0x24/0x88
    [    1.781041]  rpm_suspend+0xdc/0x470
    [    1.784523]  rpm_idle+0x12c/0x170
    [    1.787831]  pm_runtime_work+0xa8/0xc0
    [    1.791573]  process_one_work+0x1e8/0x360
    [    1.795580]  worker_thread+0x44/0x478
    [    1.799237]  kthread+0x150/0x158
    [    1.802460]  ret_from_fork+0x10/0x30
    [    1.806034] ---[ end trace 82402920ef64573b ]---
    [    1.810728] ------------[ cut here ]------------
    
    In addition, we now don't need to enable the clock from the
    function mtk_iommu_hw_init since it is already enabled by the resume.
    
    Fixes: c0b57581b73b ("iommu/mediatek: Add power-domain operation")
    Signed-off-by: Dafna Hirschfeld <dafna.hirschfeld@collabora.com>
    Reviewed-by: Yong Wu <yong.wu@mediatek.com>
    Link: https://lore.kernel.org/r/20210416105449.4744-1-dafna.hirschfeld@collabora.com
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

commit debb9df311582c83fe369baa35fa4b92e8a9c58a
Author: Yongxin Liu <yongxin.liu@windriver.com>
Date:   Mon Mar 22 15:14:48 2021 +0800

    ixgbe: fix unbalanced device enable/disable in suspend/resume
    
    pci_disable_device() called in __ixgbe_shutdown() decreases
    dev->enable_cnt by 1. pci_enable_device_mem() which increases
    dev->enable_cnt by 1, was removed from ixgbe_resume() in commit
    6f82b2558735 ("ixgbe: use generic power management"). This caused
    unbalanced increase/decrease. So add pci_enable_device_mem() back.
    
    Fix the following call trace.
    
      ixgbe 0000:17:00.1: disabling already-disabled device
      Call Trace:
       __ixgbe_shutdown+0x10a/0x1e0 [ixgbe]
       ixgbe_suspend+0x32/0x70 [ixgbe]
       pci_pm_suspend+0x87/0x160
       ? pci_pm_freeze+0xd0/0xd0
       dpm_run_callback+0x42/0x170
       __device_suspend+0x114/0x460
       async_suspend+0x1f/0xa0
       async_run_entry_fn+0x3c/0xf0
       process_one_work+0x1dd/0x410
       worker_thread+0x34/0x3f0
       ? cancel_delayed_work+0x90/0x90
       kthread+0x14c/0x170
       ? kthread_park+0x90/0x90
       ret_from_fork+0x1f/0x30
    
    Fixes: 6f82b2558735 ("ixgbe: use generic power management")
    Signed-off-by: Yongxin Liu <yongxin.liu@windriver.com>
    Tested-by: Dave Switzer <david.switzer@intel.com>
    Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>

commit 12c0632b25794ed4de46427811e71fee66f19f15
Author: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
Date:   Wed Mar 31 18:26:10 2021 -0500

    PM: runtime: remove kernel-doc warnings
    
    remove make W=1 warnings
    
    drivers/base/power/runtime.c:926: warning: Function parameter or
    member 'timer' not described in 'pm_suspend_timer_fn'
    
    drivers/base/power/runtime.c:926: warning: Excess function parameter
    'data' description in 'pm_suspend_timer_fn'
    
    Signed-off-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit fa4addf30c2cd8de776bc38a31580613aed7cdf9
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Mar 19 15:47:31 2021 +0100

    PM: runtime: Defer suspending suppliers
    
    [ Upstream commit 5244f5e2d801259af877ee759e8c22364c607072 ]
    
    Because the PM-runtime status of the device is not updated in
    __rpm_callback(), attempts to suspend the suppliers of the given
    device triggered by the rpm_put_suppliers() call in there may
    cause a supplier to be suspended completely before the status of
    the consumer is updated to RPM_SUSPENDED, which is confusing.
    
    To avoid that (1) modify __rpm_callback() to only decrease the
    PM-runtime usage counter of each supplier and (2) make rpm_suspend()
    try to suspend the suppliers after changing the consumer's status to
    RPM_SUSPENDED, in analogy with the device's parent.
    
    Link: https://lore.kernel.org/linux-pm/CAPDyKFqm06KDw_p8WXsM4dijDbho4bb6T4k50UqqvR1_COsp8g@mail.gmail.com/
    Fixes: 21d5c57b3726 ("PM / runtime: Use device links")
    Reported-by: elaine.zhang <zhangqing@rock-chips.com>
    Diagnosed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 65c021e7359006cf6bd632941f667c84f0be8a04
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Mar 19 15:47:31 2021 +0100

    PM: runtime: Defer suspending suppliers
    
    [ Upstream commit 5244f5e2d801259af877ee759e8c22364c607072 ]
    
    Because the PM-runtime status of the device is not updated in
    __rpm_callback(), attempts to suspend the suppliers of the given
    device triggered by the rpm_put_suppliers() call in there may
    cause a supplier to be suspended completely before the status of
    the consumer is updated to RPM_SUSPENDED, which is confusing.
    
    To avoid that (1) modify __rpm_callback() to only decrease the
    PM-runtime usage counter of each supplier and (2) make rpm_suspend()
    try to suspend the suppliers after changing the consumer's status to
    RPM_SUSPENDED, in analogy with the device's parent.
    
    Link: https://lore.kernel.org/linux-pm/CAPDyKFqm06KDw_p8WXsM4dijDbho4bb6T4k50UqqvR1_COsp8g@mail.gmail.com/
    Fixes: 21d5c57b3726 ("PM / runtime: Use device links")
    Reported-by: elaine.zhang <zhangqing@rock-chips.com>
    Diagnosed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 8b39e4df84a01ffab0165e985a39034076d11011
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Mar 19 15:47:31 2021 +0100

    PM: runtime: Defer suspending suppliers
    
    [ Upstream commit 5244f5e2d801259af877ee759e8c22364c607072 ]
    
    Because the PM-runtime status of the device is not updated in
    __rpm_callback(), attempts to suspend the suppliers of the given
    device triggered by the rpm_put_suppliers() call in there may
    cause a supplier to be suspended completely before the status of
    the consumer is updated to RPM_SUSPENDED, which is confusing.
    
    To avoid that (1) modify __rpm_callback() to only decrease the
    PM-runtime usage counter of each supplier and (2) make rpm_suspend()
    try to suspend the suppliers after changing the consumer's status to
    RPM_SUSPENDED, in analogy with the device's parent.
    
    Link: https://lore.kernel.org/linux-pm/CAPDyKFqm06KDw_p8WXsM4dijDbho4bb6T4k50UqqvR1_COsp8g@mail.gmail.com/
    Fixes: 21d5c57b3726 ("PM / runtime: Use device links")
    Reported-by: elaine.zhang <zhangqing@rock-chips.com>
    Diagnosed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit d4c7c28806616809e3baa0b7cd8c665516b2726d
Author: Niklas Söderlund <niklas.soderlund+renesas@ragnatech.se>
Date:   Thu Feb 11 14:43:18 2021 +0100

    timekeeping: Allow runtime PM from change_clocksource()
    
    The struct clocksource callbacks enable() and disable() are described as a
    way to allow clock sources to enter a power save mode. See commit
    4614e6adafa2 ("clocksource: add enable() and disable() callbacks")
    
    But using runtime PM from these callbacks triggers a cyclic lockdep warning when
    switching clock source using change_clocksource().
    
      # echo e60f0000.timer > /sys/devices/system/clocksource/clocksource0/current_clocksource
       ======================================================
       WARNING: possible circular locking dependency detected
       ------------------------------------------------------
       migration/0/11 is trying to acquire lock:
       ffff0000403ed220 (&dev->power.lock){-...}-{2:2}, at: __pm_runtime_resume+0x40/0x74
    
       but task is already holding lock:
       ffff8000113c8f88 (tk_core.seq.seqcount){----}-{0:0}, at: multi_cpu_stop+0xa4/0x190
    
       which lock already depends on the new lock.
    
       the existing dependency chain (in reverse order) is:
    
       -> #2 (tk_core.seq.seqcount){----}-{0:0}:
              ktime_get+0x28/0xa0
              hrtimer_start_range_ns+0x210/0x2dc
              generic_sched_clock_init+0x70/0x88
              sched_clock_init+0x40/0x64
              start_kernel+0x494/0x524
    
       -> #1 (hrtimer_bases.lock){-.-.}-{2:2}:
              hrtimer_start_range_ns+0x68/0x2dc
              rpm_suspend+0x308/0x5dc
              rpm_idle+0xc4/0x2a4
              pm_runtime_work+0x98/0xc0
              process_one_work+0x294/0x6f0
              worker_thread+0x70/0x45c
              kthread+0x154/0x160
              ret_from_fork+0x10/0x20
    
       -> #0 (&dev->power.lock){-...}-{2:2}:
              _raw_spin_lock_irqsave+0x7c/0xc4
              __pm_runtime_resume+0x40/0x74
              sh_cmt_start+0x1c4/0x260
              sh_cmt_clocksource_enable+0x28/0x50
              change_clocksource+0x9c/0x160
              multi_cpu_stop+0xa4/0x190
              cpu_stopper_thread+0x90/0x154
              smpboot_thread_fn+0x244/0x270
              kthread+0x154/0x160
              ret_from_fork+0x10/0x20
    
       other info that might help us debug this:
    
       Chain exists of:
         &dev->power.lock --> hrtimer_bases.lock --> tk_core.seq.seqcount
    
        Possible unsafe locking scenario:
    
              CPU0                    CPU1
              ----                    ----
         lock(tk_core.seq.seqcount);
                                      lock(hrtimer_bases.lock);
                                      lock(tk_core.seq.seqcount);
         lock(&dev->power.lock);
    
        *** DEADLOCK ***
    
       2 locks held by migration/0/11:
        #0: ffff8000113c9278 (timekeeper_lock){-.-.}-{2:2}, at: change_clocksource+0x2c/0x160
        #1: ffff8000113c8f88 (tk_core.seq.seqcount){----}-{0:0}, at: multi_cpu_stop+0xa4/0x190
    
    Rework change_clocksource() so it enables the new clocksource and disables
    the old clocksource outside of the timekeeper_lock and seqcount write held
    region. There is no requirement that these callbacks are invoked from the
    lock held region.
    
    Signed-off-by: Niklas Söderlund <niklas.soderlund+renesas@ragnatech.se>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Link: https://lore.kernel.org/r/20210211134318.323910-1-niklas.soderlund+renesas@ragnatech.se

commit 5244f5e2d801259af877ee759e8c22364c607072
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Mar 19 15:47:31 2021 +0100

    PM: runtime: Defer suspending suppliers
    
    Because the PM-runtime status of the device is not updated in
    __rpm_callback(), attempts to suspend the suppliers of the given
    device triggered by the rpm_put_suppliers() call in there may
    cause a supplier to be suspended completely before the status of
    the consumer is updated to RPM_SUSPENDED, which is confusing.
    
    To avoid that (1) modify __rpm_callback() to only decrease the
    PM-runtime usage counter of each supplier and (2) make rpm_suspend()
    try to suspend the suppliers after changing the consumer's status to
    RPM_SUSPENDED, in analogy with the device's parent.
    
    Link: https://lore.kernel.org/linux-pm/CAPDyKFqm06KDw_p8WXsM4dijDbho4bb6T4k50UqqvR1_COsp8g@mail.gmail.com/
    Fixes: 21d5c57b3726 ("PM / runtime: Use device links")
    Reported-by: elaine.zhang <zhangqing@rock-chips.com>
    Diagnosed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit ccf8b940e5fdd331231a7442cd80f0e83336cfd3
Author: Chen Yu <yu.c.chen@intel.com>
Date:   Tue Dec 1 09:21:50 2020 +0800

    e1000e: Leverage direct_complete to speed up s2ram
    
    The NIC is put in runtime suspend status when there is no cable connected.
    As a result, it is safe to keep non-wakeup NIC in runtime suspended during
    s2ram because the system does not rely on the NIC plug event nor WoL to wake
    up the system. Besides that, unlike the s2idle, s2ram does not need to
    manipulate S0ix settings during suspend.
    
    This patch introduces the .prepare() for e1000e so that if the NIC is runtime
    suspended the subsequent suspend/resume hooks will be skipped so as to speed
    up the s2ram. The pm core will check whether the NIC is a wake up device so
    there's no need to check it again in .prepare(). DPM_FLAG_SMART_PREPARE flag
    should be set during probe to ask the pci subsystem to honor the driver's
    prepare() result. Besides, the NIC remains runtime suspended after resumed
    from s2ram as there is no need to resume it.
    
    Tested on i7-2600K with 82579V NIC
    Before the patch:
    e1000e 0000:00:19.0: pci_pm_suspend+0x0/0x160 returned 0 after 225146 usecs
    e1000e 0000:00:19.0: pci_pm_resume+0x0/0x90 returned 0 after 140588 usecs
    
    After the patch:
    echo disabled > //sys/devices/pci0000\:00/0000\:00\:19.0/power/wakeup
    becomes 0 usecs because the hooks will be skipped.
    
    Suggested-by: Kai-Heng Feng <kai.heng.feng@canonical.com>
    Signed-off-by: Chen Yu <yu.c.chen@intel.com>
    Tested-by: Dvora Fuxbrumer <dvorax.fuxbrumer@linux.intel.com>
    Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>

commit 3217a275a0352aa98773c63f2f0cc7dbd81dea14
Author: Vamshi K Sthambamkadi <vamshi.k.sthambamkadi@gmail.com>
Date:   Thu Jan 14 16:51:47 2021 +0530

    Bluetooth: btusb: fix memory leak on suspend and resume
    
    [ Upstream commit 5ff20cbe6752a5bc06ff58fee8aa11a0d5075819 ]
    
    kmemleak report:
    unreferenced object 0xffff9b1127f00500 (size 208):
      comm "kworker/u17:2", pid 500, jiffies 4294937470 (age 580.136s)
      hex dump (first 32 bytes):
        00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
        00 60 ed 05 11 9b ff ff 00 00 00 00 00 00 00 00  .`..............
      backtrace:
        [<000000006ab3fd59>] kmem_cache_alloc_node+0x17a/0x480
        [<0000000051a5f6f9>] __alloc_skb+0x5b/0x1d0
        [<0000000037e2d252>] hci_prepare_cmd+0x32/0xc0 [bluetooth]
        [<0000000010b586d5>] hci_req_add_ev+0x84/0xe0 [bluetooth]
        [<00000000d2deb520>] hci_req_clear_event_filter+0x42/0x70 [bluetooth]
        [<00000000f864bd8c>] hci_req_prepare_suspend+0x84/0x470 [bluetooth]
        [<000000001deb2cc4>] hci_prepare_suspend+0x31/0x40 [bluetooth]
        [<000000002677dd79>] process_one_work+0x209/0x3b0
        [<00000000aaa62b07>] worker_thread+0x34/0x400
        [<00000000826d176c>] kthread+0x126/0x140
        [<000000002305e558>] ret_from_fork+0x22/0x30
    unreferenced object 0xffff9b1125c6ee00 (size 512):
      comm "kworker/u17:2", pid 500, jiffies 4294937470 (age 580.136s)
      hex dump (first 32 bytes):
        04 00 00 00 0d 00 00 00 05 0c 01 00 11 9b ff ff  ................
        00 00 00 00 00 00 00 00 01 00 00 00 00 00 00 00  ................
      backtrace:
        [<000000009f07c0cc>] slab_post_alloc_hook+0x59/0x270
        [<0000000049431dc2>] __kmalloc_node_track_caller+0x15f/0x330
        [<00000000027a42f6>] __kmalloc_reserve.isra.70+0x31/0x90
        [<00000000e8e3e76a>] __alloc_skb+0x87/0x1d0
        [<0000000037e2d252>] hci_prepare_cmd+0x32/0xc0 [bluetooth]
        [<0000000010b586d5>] hci_req_add_ev+0x84/0xe0 [bluetooth]
        [<00000000d2deb520>] hci_req_clear_event_filter+0x42/0x70 [bluetooth]
        [<00000000f864bd8c>] hci_req_prepare_suspend+0x84/0x470 [bluetooth]
        [<000000001deb2cc4>] hci_prepare_suspend+0x31/0x40 [bluetooth]
        [<000000002677dd79>] process_one_work+0x209/0x3b0
        [<00000000aaa62b07>] worker_thread+0x34/0x400
        [<00000000826d176c>] kthread+0x126/0x140
        [<000000002305e558>] ret_from_fork+0x22/0x30
    unreferenced object 0xffff9b112b395788 (size 8):
      comm "kworker/u17:2", pid 500, jiffies 4294937470 (age 580.136s)
      hex dump (first 8 bytes):
        20 00 00 00 00 00 04 00                           .......
      backtrace:
        [<0000000052dc28d2>] kmem_cache_alloc_trace+0x15e/0x460
        [<0000000046147591>] alloc_ctrl_urb+0x52/0xe0 [btusb]
        [<00000000a2ed3e9e>] btusb_send_frame+0x91/0x100 [btusb]
        [<000000001e66030e>] hci_send_frame+0x7e/0xf0 [bluetooth]
        [<00000000bf6b7269>] hci_cmd_work+0xc5/0x130 [bluetooth]
        [<000000002677dd79>] process_one_work+0x209/0x3b0
        [<00000000aaa62b07>] worker_thread+0x34/0x400
        [<00000000826d176c>] kthread+0x126/0x140
        [<000000002305e558>] ret_from_fork+0x22/0x30
    
    In pm sleep-resume context, while the btusb device rebinds, it enters
    hci_unregister_dev(), whilst there is a possibility of hdev receiving
    PM_POST_SUSPEND suspend_notifier event, leading to generation of msg
    frames. When hci_unregister_dev() completes, i.e. hdev context is
    destroyed/freed, those intermittently sent msg frames cause memory
    leak.
    
    BUG details:
    Below is stack trace of thread that enters hci_unregister_dev(), marks
    the hdev flag HCI_UNREGISTER to 1, and then goes onto to wait on notifier
    lock - refer unregister_pm_notifier().
    
      hci_unregister_dev+0xa5/0x320 [bluetoot]
      btusb_disconnect+0x68/0x150 [btusb]
      usb_unbind_interface+0x77/0x250
      ? kernfs_remove_by_name_ns+0x75/0xa0
      device_release_driver_internal+0xfe/0x1
      device_release_driver+0x12/0x20
      bus_remove_device+0xe1/0x150
      device_del+0x192/0x3e0
      ? usb_remove_ep_devs+0x1f/0x30
      usb_disable_device+0x92/0x1b0
      usb_disconnect+0xc2/0x270
      hub_event+0x9f6/0x15d0
      ? rpm_idle+0x23/0x360
      ? rpm_idle+0x26b/0x360
      process_one_work+0x209/0x3b0
      worker_thread+0x34/0x400
      ? process_one_work+0x3b0/0x3b0
      kthread+0x126/0x140
      ? kthread_park+0x90/0x90
      ret_from_fork+0x22/0x30
    
    Below is stack trace of thread executing hci_suspend_notifier() which
    processes the PM_POST_SUSPEND event, while the unbinding thread is
    waiting on lock.
    
      hci_suspend_notifier.cold.39+0x5/0x2b [bluetooth]
      blocking_notifier_call_chain+0x69/0x90
      pm_notifier_call_chain+0x1a/0x20
      pm_suspend.cold.9+0x334/0x352
      state_store+0x84/0xf0
      kobj_attr_store+0x12/0x20
      sysfs_kf_write+0x3b/0x40
      kernfs_fop_write+0xda/0x1c0
      vfs_write+0xbb/0x250
      ksys_write+0x61/0xe0
      __x64_sys_write+0x1a/0x20
      do_syscall_64+0x37/0x80
      entry_SYSCALL_64_after_hwframe+0x44/0xa9
    
    Fix hci_suspend_notifer(), not to act on events when flag HCI_UNREGISTER
    is set.
    
    Signed-off-by: Vamshi K Sthambamkadi <vamshi.k.sthambamkadi@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit b9afcdcddff68eee8d04b0cfa30e08e156e6839e
Author: Vamshi K Sthambamkadi <vamshi.k.sthambamkadi@gmail.com>
Date:   Thu Jan 14 16:51:47 2021 +0530

    Bluetooth: btusb: fix memory leak on suspend and resume
    
    [ Upstream commit 5ff20cbe6752a5bc06ff58fee8aa11a0d5075819 ]
    
    kmemleak report:
    unreferenced object 0xffff9b1127f00500 (size 208):
      comm "kworker/u17:2", pid 500, jiffies 4294937470 (age 580.136s)
      hex dump (first 32 bytes):
        00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
        00 60 ed 05 11 9b ff ff 00 00 00 00 00 00 00 00  .`..............
      backtrace:
        [<000000006ab3fd59>] kmem_cache_alloc_node+0x17a/0x480
        [<0000000051a5f6f9>] __alloc_skb+0x5b/0x1d0
        [<0000000037e2d252>] hci_prepare_cmd+0x32/0xc0 [bluetooth]
        [<0000000010b586d5>] hci_req_add_ev+0x84/0xe0 [bluetooth]
        [<00000000d2deb520>] hci_req_clear_event_filter+0x42/0x70 [bluetooth]
        [<00000000f864bd8c>] hci_req_prepare_suspend+0x84/0x470 [bluetooth]
        [<000000001deb2cc4>] hci_prepare_suspend+0x31/0x40 [bluetooth]
        [<000000002677dd79>] process_one_work+0x209/0x3b0
        [<00000000aaa62b07>] worker_thread+0x34/0x400
        [<00000000826d176c>] kthread+0x126/0x140
        [<000000002305e558>] ret_from_fork+0x22/0x30
    unreferenced object 0xffff9b1125c6ee00 (size 512):
      comm "kworker/u17:2", pid 500, jiffies 4294937470 (age 580.136s)
      hex dump (first 32 bytes):
        04 00 00 00 0d 00 00 00 05 0c 01 00 11 9b ff ff  ................
        00 00 00 00 00 00 00 00 01 00 00 00 00 00 00 00  ................
      backtrace:
        [<000000009f07c0cc>] slab_post_alloc_hook+0x59/0x270
        [<0000000049431dc2>] __kmalloc_node_track_caller+0x15f/0x330
        [<00000000027a42f6>] __kmalloc_reserve.isra.70+0x31/0x90
        [<00000000e8e3e76a>] __alloc_skb+0x87/0x1d0
        [<0000000037e2d252>] hci_prepare_cmd+0x32/0xc0 [bluetooth]
        [<0000000010b586d5>] hci_req_add_ev+0x84/0xe0 [bluetooth]
        [<00000000d2deb520>] hci_req_clear_event_filter+0x42/0x70 [bluetooth]
        [<00000000f864bd8c>] hci_req_prepare_suspend+0x84/0x470 [bluetooth]
        [<000000001deb2cc4>] hci_prepare_suspend+0x31/0x40 [bluetooth]
        [<000000002677dd79>] process_one_work+0x209/0x3b0
        [<00000000aaa62b07>] worker_thread+0x34/0x400
        [<00000000826d176c>] kthread+0x126/0x140
        [<000000002305e558>] ret_from_fork+0x22/0x30
    unreferenced object 0xffff9b112b395788 (size 8):
      comm "kworker/u17:2", pid 500, jiffies 4294937470 (age 580.136s)
      hex dump (first 8 bytes):
        20 00 00 00 00 00 04 00                           .......
      backtrace:
        [<0000000052dc28d2>] kmem_cache_alloc_trace+0x15e/0x460
        [<0000000046147591>] alloc_ctrl_urb+0x52/0xe0 [btusb]
        [<00000000a2ed3e9e>] btusb_send_frame+0x91/0x100 [btusb]
        [<000000001e66030e>] hci_send_frame+0x7e/0xf0 [bluetooth]
        [<00000000bf6b7269>] hci_cmd_work+0xc5/0x130 [bluetooth]
        [<000000002677dd79>] process_one_work+0x209/0x3b0
        [<00000000aaa62b07>] worker_thread+0x34/0x400
        [<00000000826d176c>] kthread+0x126/0x140
        [<000000002305e558>] ret_from_fork+0x22/0x30
    
    In pm sleep-resume context, while the btusb device rebinds, it enters
    hci_unregister_dev(), whilst there is a possibility of hdev receiving
    PM_POST_SUSPEND suspend_notifier event, leading to generation of msg
    frames. When hci_unregister_dev() completes, i.e. hdev context is
    destroyed/freed, those intermittently sent msg frames cause memory
    leak.
    
    BUG details:
    Below is stack trace of thread that enters hci_unregister_dev(), marks
    the hdev flag HCI_UNREGISTER to 1, and then goes onto to wait on notifier
    lock - refer unregister_pm_notifier().
    
      hci_unregister_dev+0xa5/0x320 [bluetoot]
      btusb_disconnect+0x68/0x150 [btusb]
      usb_unbind_interface+0x77/0x250
      ? kernfs_remove_by_name_ns+0x75/0xa0
      device_release_driver_internal+0xfe/0x1
      device_release_driver+0x12/0x20
      bus_remove_device+0xe1/0x150
      device_del+0x192/0x3e0
      ? usb_remove_ep_devs+0x1f/0x30
      usb_disable_device+0x92/0x1b0
      usb_disconnect+0xc2/0x270
      hub_event+0x9f6/0x15d0
      ? rpm_idle+0x23/0x360
      ? rpm_idle+0x26b/0x360
      process_one_work+0x209/0x3b0
      worker_thread+0x34/0x400
      ? process_one_work+0x3b0/0x3b0
      kthread+0x126/0x140
      ? kthread_park+0x90/0x90
      ret_from_fork+0x22/0x30
    
    Below is stack trace of thread executing hci_suspend_notifier() which
    processes the PM_POST_SUSPEND event, while the unbinding thread is
    waiting on lock.
    
      hci_suspend_notifier.cold.39+0x5/0x2b [bluetooth]
      blocking_notifier_call_chain+0x69/0x90
      pm_notifier_call_chain+0x1a/0x20
      pm_suspend.cold.9+0x334/0x352
      state_store+0x84/0xf0
      kobj_attr_store+0x12/0x20
      sysfs_kf_write+0x3b/0x40
      kernfs_fop_write+0xda/0x1c0
      vfs_write+0xbb/0x250
      ksys_write+0x61/0xe0
      __x64_sys_write+0x1a/0x20
      do_syscall_64+0x37/0x80
      entry_SYSCALL_64_after_hwframe+0x44/0xa9
    
    Fix hci_suspend_notifer(), not to act on events when flag HCI_UNREGISTER
    is set.
    
    Signed-off-by: Vamshi K Sthambamkadi <vamshi.k.sthambamkadi@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 55eceabb139a4c01e1d8b5fff51e3a482c949a13
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Thu Feb 4 17:01:20 2021 +0100

    ARM: at91: use proper asm syntax in pm_suspend
    
    [ Upstream commit d30337da8677cd73cb19444436b311c13e57356f ]
    
    Compiling with the clang integrated assembler warns about
    a recently added instruction:
    
    <instantiation>:14:13: error: unknown token in expression
     ldr tmp1, =#0x00020010UL
    arch/arm/mach-at91/pm_suspend.S:542:2: note: while in macro instantiation
     at91_plla_enable
    
    Remove the extra '#' character that is not used for the 'ldr'
    instruction when doing an indirect load of a constant.
    
    Fixes: 4fd36e458392 ("ARM: at91: pm: add plla disable/enable support for sam9x60")
    Tested-by: Claudiu Beznea <claudiu.beznea@microchip.com>
    Reviewed-by: Claudiu Beznea <claudiu.beznea@microchip.com>
    Reviewed-by: Nathan Chancellor <nathan@kernel.org>
    Acked-by: Nicolas Ferre <nicolas.ferre@microchip.com>
    Link: https://lore.kernel.org/r/20210204160129.2249394-1-arnd@kernel.org'
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 4641cecc3dbfc757e829a29e61877d8bb0d58d94
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Thu Feb 4 17:01:20 2021 +0100

    ARM: at91: use proper asm syntax in pm_suspend
    
    [ Upstream commit d30337da8677cd73cb19444436b311c13e57356f ]
    
    Compiling with the clang integrated assembler warns about
    a recently added instruction:
    
    <instantiation>:14:13: error: unknown token in expression
     ldr tmp1, =#0x00020010UL
    arch/arm/mach-at91/pm_suspend.S:542:2: note: while in macro instantiation
     at91_plla_enable
    
    Remove the extra '#' character that is not used for the 'ldr'
    instruction when doing an indirect load of a constant.
    
    Fixes: 4fd36e458392 ("ARM: at91: pm: add plla disable/enable support for sam9x60")
    Tested-by: Claudiu Beznea <claudiu.beznea@microchip.com>
    Reviewed-by: Claudiu Beznea <claudiu.beznea@microchip.com>
    Reviewed-by: Nathan Chancellor <nathan@kernel.org>
    Acked-by: Nicolas Ferre <nicolas.ferre@microchip.com>
    Link: https://lore.kernel.org/r/20210204160129.2249394-1-arnd@kernel.org'
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 7ddfe9a6a3b323c96ceddbdbb92debb9611e32c0
Merge: 51e6d17809c8 090e502e4e63
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Feb 20 18:09:40 2021 -0800

    Merge tag 'arm-fixes-v5.12' of git://git.kernel.org/pub/scm/linux/kernel/git/soc/soc
    
    Pull ARM SoC fixes from Arnd Bergmann:
     "There are only two left-over remaining non-urgent ARM SoC bug fixes:
    
       - A build fix for the Atmel SAM9 platform to allow building with the
         clang integrated assembler
    
       - A DT fix for ethernet on Intel SoCFPGA, this has been broken since
         it was added in v5.4"
    
    * tag 'arm-fixes-v5.12' of git://git.kernel.org/pub/scm/linux/kernel/git/soc/soc:
      ARM: at91: use proper asm syntax in pm_suspend
      arm64: dts: agilex: fix phy interface bit shift for gmac1 and gmac2

commit d30337da8677cd73cb19444436b311c13e57356f
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Thu Feb 4 17:01:20 2021 +0100

    ARM: at91: use proper asm syntax in pm_suspend
    
    Compiling with the clang integrated assembler warns about
    a recently added instruction:
    
    <instantiation>:14:13: error: unknown token in expression
     ldr tmp1, =#0x00020010UL
    arch/arm/mach-at91/pm_suspend.S:542:2: note: while in macro instantiation
     at91_plla_enable
    
    Remove the extra '#' character that is not used for the 'ldr'
    instruction when doing an indirect load of a constant.
    
    Fixes: 4fd36e458392 ("ARM: at91: pm: add plla disable/enable support for sam9x60")
    Tested-by: Claudiu Beznea <claudiu.beznea@microchip.com>
    Reviewed-by: Claudiu Beznea <claudiu.beznea@microchip.com>
    Reviewed-by: Nathan Chancellor <nathan@kernel.org>
    Acked-by: Nicolas Ferre <nicolas.ferre@microchip.com>
    Link: https://lore.kernel.org/r/20210204160129.2249394-1-arnd@kernel.org'
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

commit 5ff20cbe6752a5bc06ff58fee8aa11a0d5075819
Author: Vamshi K Sthambamkadi <vamshi.k.sthambamkadi@gmail.com>
Date:   Thu Jan 14 16:51:47 2021 +0530

    Bluetooth: btusb: fix memory leak on suspend and resume
    
    kmemleak report:
    unreferenced object 0xffff9b1127f00500 (size 208):
      comm "kworker/u17:2", pid 500, jiffies 4294937470 (age 580.136s)
      hex dump (first 32 bytes):
        00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
        00 60 ed 05 11 9b ff ff 00 00 00 00 00 00 00 00  .`..............
      backtrace:
        [<000000006ab3fd59>] kmem_cache_alloc_node+0x17a/0x480
        [<0000000051a5f6f9>] __alloc_skb+0x5b/0x1d0
        [<0000000037e2d252>] hci_prepare_cmd+0x32/0xc0 [bluetooth]
        [<0000000010b586d5>] hci_req_add_ev+0x84/0xe0 [bluetooth]
        [<00000000d2deb520>] hci_req_clear_event_filter+0x42/0x70 [bluetooth]
        [<00000000f864bd8c>] hci_req_prepare_suspend+0x84/0x470 [bluetooth]
        [<000000001deb2cc4>] hci_prepare_suspend+0x31/0x40 [bluetooth]
        [<000000002677dd79>] process_one_work+0x209/0x3b0
        [<00000000aaa62b07>] worker_thread+0x34/0x400
        [<00000000826d176c>] kthread+0x126/0x140
        [<000000002305e558>] ret_from_fork+0x22/0x30
    unreferenced object 0xffff9b1125c6ee00 (size 512):
      comm "kworker/u17:2", pid 500, jiffies 4294937470 (age 580.136s)
      hex dump (first 32 bytes):
        04 00 00 00 0d 00 00 00 05 0c 01 00 11 9b ff ff  ................
        00 00 00 00 00 00 00 00 01 00 00 00 00 00 00 00  ................
      backtrace:
        [<000000009f07c0cc>] slab_post_alloc_hook+0x59/0x270
        [<0000000049431dc2>] __kmalloc_node_track_caller+0x15f/0x330
        [<00000000027a42f6>] __kmalloc_reserve.isra.70+0x31/0x90
        [<00000000e8e3e76a>] __alloc_skb+0x87/0x1d0
        [<0000000037e2d252>] hci_prepare_cmd+0x32/0xc0 [bluetooth]
        [<0000000010b586d5>] hci_req_add_ev+0x84/0xe0 [bluetooth]
        [<00000000d2deb520>] hci_req_clear_event_filter+0x42/0x70 [bluetooth]
        [<00000000f864bd8c>] hci_req_prepare_suspend+0x84/0x470 [bluetooth]
        [<000000001deb2cc4>] hci_prepare_suspend+0x31/0x40 [bluetooth]
        [<000000002677dd79>] process_one_work+0x209/0x3b0
        [<00000000aaa62b07>] worker_thread+0x34/0x400
        [<00000000826d176c>] kthread+0x126/0x140
        [<000000002305e558>] ret_from_fork+0x22/0x30
    unreferenced object 0xffff9b112b395788 (size 8):
      comm "kworker/u17:2", pid 500, jiffies 4294937470 (age 580.136s)
      hex dump (first 8 bytes):
        20 00 00 00 00 00 04 00                           .......
      backtrace:
        [<0000000052dc28d2>] kmem_cache_alloc_trace+0x15e/0x460
        [<0000000046147591>] alloc_ctrl_urb+0x52/0xe0 [btusb]
        [<00000000a2ed3e9e>] btusb_send_frame+0x91/0x100 [btusb]
        [<000000001e66030e>] hci_send_frame+0x7e/0xf0 [bluetooth]
        [<00000000bf6b7269>] hci_cmd_work+0xc5/0x130 [bluetooth]
        [<000000002677dd79>] process_one_work+0x209/0x3b0
        [<00000000aaa62b07>] worker_thread+0x34/0x400
        [<00000000826d176c>] kthread+0x126/0x140
        [<000000002305e558>] ret_from_fork+0x22/0x30
    
    In pm sleep-resume context, while the btusb device rebinds, it enters
    hci_unregister_dev(), whilst there is a possibility of hdev receiving
    PM_POST_SUSPEND suspend_notifier event, leading to generation of msg
    frames. When hci_unregister_dev() completes, i.e. hdev context is
    destroyed/freed, those intermittently sent msg frames cause memory
    leak.
    
    BUG details:
    Below is stack trace of thread that enters hci_unregister_dev(), marks
    the hdev flag HCI_UNREGISTER to 1, and then goes onto to wait on notifier
    lock - refer unregister_pm_notifier().
    
      hci_unregister_dev+0xa5/0x320 [bluetoot]
      btusb_disconnect+0x68/0x150 [btusb]
      usb_unbind_interface+0x77/0x250
      ? kernfs_remove_by_name_ns+0x75/0xa0
      device_release_driver_internal+0xfe/0x1
      device_release_driver+0x12/0x20
      bus_remove_device+0xe1/0x150
      device_del+0x192/0x3e0
      ? usb_remove_ep_devs+0x1f/0x30
      usb_disable_device+0x92/0x1b0
      usb_disconnect+0xc2/0x270
      hub_event+0x9f6/0x15d0
      ? rpm_idle+0x23/0x360
      ? rpm_idle+0x26b/0x360
      process_one_work+0x209/0x3b0
      worker_thread+0x34/0x400
      ? process_one_work+0x3b0/0x3b0
      kthread+0x126/0x140
      ? kthread_park+0x90/0x90
      ret_from_fork+0x22/0x30
    
    Below is stack trace of thread executing hci_suspend_notifier() which
    processes the PM_POST_SUSPEND event, while the unbinding thread is
    waiting on lock.
    
      hci_suspend_notifier.cold.39+0x5/0x2b [bluetooth]
      blocking_notifier_call_chain+0x69/0x90
      pm_notifier_call_chain+0x1a/0x20
      pm_suspend.cold.9+0x334/0x352
      state_store+0x84/0xf0
      kobj_attr_store+0x12/0x20
      sysfs_kf_write+0x3b/0x40
      kernfs_fop_write+0xda/0x1c0
      vfs_write+0xbb/0x250
      ksys_write+0x61/0xe0
      __x64_sys_write+0x1a/0x20
      do_syscall_64+0x37/0x80
      entry_SYSCALL_64_after_hwframe+0x44/0xa9
    
    Fix hci_suspend_notifer(), not to act on events when flag HCI_UNREGISTER
    is set.
    
    Signed-off-by: Vamshi K Sthambamkadi <vamshi.k.sthambamkadi@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

commit b155175979e165803b8ab8d2c476f6a005166e5f
Author: Nathan Lynch <nathanl@linux.ibm.com>
Date:   Mon Dec 7 15:51:49 2020 -0600

    powerpc/pseries/hibernation: drop pseries_suspend_begin() from suspend ops
    
    [ Upstream commit 52719fce3f4c7a8ac9eaa191e8d75a697f9fbcbc ]
    
    There are three ways pseries_suspend_begin() can be reached:
    
    1. When "mem" is written to /sys/power/state:
    
    kobj_attr_store()
    -> state_store()
      -> pm_suspend()
        -> suspend_devices_and_enter()
          -> pseries_suspend_begin()
    
    This never works because there is no way to supply a valid stream id
    using this interface, and H_VASI_STATE is called with a stream id of
    zero. So this call path is useless at best.
    
    2. When a stream id is written to /sys/devices/system/power/hibernate.
    pseries_suspend_begin() is polled directly from store_hibernate()
    until the stream is in the "Suspending" state (i.e. the platform is
    ready for the OS to suspend execution):
    
    dev_attr_store()
    -> store_hibernate()
      -> pseries_suspend_begin()
    
    3. When a stream id is written to /sys/devices/system/power/hibernate
    (continued). After #2, pseries_suspend_begin() is called once again
    from the pm core:
    
    dev_attr_store()
    -> store_hibernate()
      -> pm_suspend()
        -> suspend_devices_and_enter()
          -> pseries_suspend_begin()
    
    This is redundant because the VASI suspend state is already known to
    be Suspending.
    
    The begin() callback of platform_suspend_ops is optional, so we can
    simply remove that assignment with no loss of function.
    
    Fixes: 32d8ad4e621d ("powerpc/pseries: Partition hibernation support")
    Signed-off-by: Nathan Lynch <nathanl@linux.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Link: https://lore.kernel.org/r/20201207215200.1785968-18-nathanl@linux.ibm.com
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 0ad229df47324a453f86612c42144cca053f9a43
Author: JC Kuo <jckuo@nvidia.com>
Date:   Tue Nov 17 16:38:03 2020 +0800

    phy: tegra: xusb: Fix usb_phy device driver field
    
    [ Upstream commit 4ea0bf2a52f1eea76578eac5a9148d95f5e181c0 ]
    
    In commit "phy: tegra: xusb: Add usb-phy support", an OTG capable PHY
    device, such as phy-usb2.0 device of Jetson-TX1 platform, will be
    bound to the tegra-xusb-padctl driver by the following line in
    tegra_xusb_setup_usb_role_switch().
    
            port->usb_phy.dev->driver = port->padctl->dev->driver;
    
    With this, dev_pm_ops set of tegra-xusb-padctl driver will be invoked
    for the OTG capable PHY incorrectly as below logs show.
    
    This commit fixes the issue by assigning an empty driver to it.
    
    [  153.451108] tegra-xusb-padctl phy-usb2.0: > tegra_xusb_padctl_suspend_noirq(dev=ffff000080917000)
    [  153.460353] tegra-xusb-padctl phy-usb2.0:   driver: ffff8000114453e0 (tegra_xusb_padctl_driver)
    [  153.469245] tegra-xusb-padctl phy-usb2.0:   padctl: ffff0000829f6480
    [  153.475772] tegra-xusb-padctl phy-usb2.0:     soc: ef7bdd7fffffffff (0xef7bdd7fffffffff)
    [  153.484061] Unable to handle kernel paging request at virtual address 007bdd800000004f
    [  153.492132] Mem abort info:
    [  153.495083]   ESR = 0x96000004
    [  153.498308]   EC = 0x25: DABT (current EL), IL = 32 bits
    [  153.503771]   SET = 0, FnV = 0
    [  153.506979]   EA = 0, S1PTW = 0
    [  153.510260] Data abort info:
    [  153.513200]   ISV = 0, ISS = 0x00000004
    [  153.517181]   CM = 0, WnR = 0
    [  153.520302] [007bdd800000004f] address between user and kernel address ranges
    [  153.527600] Internal error: Oops: 96000004 [#1] PREEMPT SMP
    [  153.533231] Modules linked in: nouveau panel_simple tegra_video(C) tegra_drm drm_ttm_helper videobuf2_dma_contig ttm videobuf2_memops cec videobuf2_v4l2 videobuf2_common drm_kms_helper v4l2_fwnode videodev drm mc snd_hda_codec_hdmi cdc_ether usbnet snd_hda_tegra r8152 crct10dif_ce snd_hda_codec snd_hda_core tegra_xudc host1x lp855x_bl at24 ip_tables x_tables ipv6
    [  153.566417] CPU: 0 PID: 300 Comm: systemd-sleep Tainted: G         C        5.10.0-rc3-next-20201113-00019-g5c064d5372b0-dirty #624
    [  153.578283] Hardware name: NVIDIA Jetson TX1 Developer Kit (DT)
    [  153.584281] pstate: 40000005 (nZcv daif -PAN -UAO -TCO BTYPE=--)
    [  153.590381] pc : tegra_xusb_padctl_suspend_noirq+0x88/0x100
    [  153.596016] lr : tegra_xusb_padctl_suspend_noirq+0x80/0x100
    [  153.601632] sp : ffff8000120dbb60
    [  153.604999] x29: ffff8000120dbb60 x28: ffff000080a1df00
    [  153.610430] x27: 0000000000000002 x26: ffff8000106f8540
    [  153.615858] x25: ffff8000113ac4a4 x24: ffff80001148c198
    [  153.621277] x23: ffff800010c4538c x22: 0000000000000002
    [  153.626692] x21: ffff800010ccde80 x20: ffff0000829f6480
    [  153.632107] x19: ffff000080917000 x18: 0000000000000030
    [  153.637521] x17: 0000000000000000 x16: 0000000000000000
    [  153.642933] x15: ffff000080a1e380 x14: 74636461702d6273
    [  153.648346] x13: ffff8000113ad058 x12: 0000000000000f39
    [  153.653759] x11: 0000000000000513 x10: ffff800011405058
    [  153.659176] x9 : 00000000fffff000 x8 : ffff8000113ad058
    [  153.664590] x7 : ffff800011405058 x6 : 0000000000000000
    [  153.670002] x5 : 0000000000000000 x4 : ffff0000fe908bc0
    [  153.675414] x3 : ffff0000fe910228 x2 : 162ef67e0581e700
    [  153.680826] x1 : 162ef67e0581e700 x0 : ef7bdd7fffffffff
    [  153.686241] Call trace:
    [  153.688769]  tegra_xusb_padctl_suspend_noirq+0x88/0x100
    [  153.694077]  __device_suspend_noirq+0x68/0x1cc
    [  153.698594]  dpm_noirq_suspend_devices+0x10c/0x1d0
    [  153.703456]  dpm_suspend_noirq+0x28/0xa0
    [  153.707461]  suspend_devices_and_enter+0x234/0x4bc
    [  153.712314]  pm_suspend+0x1e4/0x270
    [  153.715868]  state_store+0x8c/0x110
    [  153.719440]  kobj_attr_store+0x1c/0x30
    [  153.723259]  sysfs_kf_write+0x4c/0x7c
    [  153.726981]  kernfs_fop_write+0x124/0x240
    [  153.731065]  vfs_write+0xe4/0x204
    [  153.734449]  ksys_write+0x6c/0x100
    [  153.737925]  __arm64_sys_write+0x20/0x30
    [  153.741931]  el0_svc_common.constprop.0+0x78/0x1a0
    [  153.746789]  do_el0_svc+0x24/0x90
    [  153.750181]  el0_sync_handler+0x254/0x260
    [  153.754251]  el0_sync+0x174/0x180
    [  153.757663] Code: aa0303e2 94000f64 f9405680 b40000e0 (f9402803)
    [  153.763826] ---[ end trace 81543a3394cb409d ]---
    
    Fixes: e8f7d2f409a1 ("phy: tegra: xusb: Add usb-phy support")
    
    Signed-off-by: JC Kuo <jckuo@nvidia.com>
    Acked-by: Thierry Reding <treding@nvidia.com>
    Link: https://lore.kernel.org/r/20201117083803.185209-1-jckuo@nvidia.com
    Signed-off-by: Vinod Koul <vkoul@kernel.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit ae5b3fc2dce45fabc8463e001aa70d1c1cabe124
Author: Kuogee Hsieh <khsieh@codeaurora.org>
Date:   Tue Nov 3 14:53:35 2020 -0800

    drm/msm/dp: return correct connection status after suspend
    
    [ Upstream commit 19e52bcb27c2ba140699d2230d722366d7d048a1 ]
    
    During suspend, dp host controller and hpd block are disabled due to
    both ahb and aux clock are disabled. Therefore hpd plug/unplug interrupts
    will not be generated. At dp_pm_resume(), reinitialize both dp host
    controller and hpd block so that hpd plug/unplug interrupts will be
    generated and handled by driver so that hpd connection state is updated
    correctly. This patch will fix link training flaky issues.
    
    Changes in v2:
    -- use container_of to cast correct dp_display_private pointer
       at both dp_pm_suspend() and dp_pm_resume().
    
    Changes in v3:
    -- replace hpd_state atomic_t  with u32
    
    Changes in v4
    -- call dp_display_host_deinit() at dp_pm_suspend()
    -- call dp_display_host_init() at msm_dp_display_enable()
    -- fix phy->init_count unbalance which causes link training failed
    
    Changes in v5
    --  add Fixes tag
    
    Fixes:  8ede2ecc3e5e (drm/msm/dp: Add DP compliance tests on Snapdragon Chipsets)
    Tested-by: Stephen Boyd <swboyd@chromium.org>
    Signed-off-by: Kuogee Hsieh <khsieh@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@chromium.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit c4115721d1f017170e7230d3324dfd841d9254a4
Author: Nathan Lynch <nathanl@linux.ibm.com>
Date:   Mon Dec 7 15:51:49 2020 -0600

    powerpc/pseries/hibernation: drop pseries_suspend_begin() from suspend ops
    
    [ Upstream commit 52719fce3f4c7a8ac9eaa191e8d75a697f9fbcbc ]
    
    There are three ways pseries_suspend_begin() can be reached:
    
    1. When "mem" is written to /sys/power/state:
    
    kobj_attr_store()
    -> state_store()
      -> pm_suspend()
        -> suspend_devices_and_enter()
          -> pseries_suspend_begin()
    
    This never works because there is no way to supply a valid stream id
    using this interface, and H_VASI_STATE is called with a stream id of
    zero. So this call path is useless at best.
    
    2. When a stream id is written to /sys/devices/system/power/hibernate.
    pseries_suspend_begin() is polled directly from store_hibernate()
    until the stream is in the "Suspending" state (i.e. the platform is
    ready for the OS to suspend execution):
    
    dev_attr_store()
    -> store_hibernate()
      -> pseries_suspend_begin()
    
    3. When a stream id is written to /sys/devices/system/power/hibernate
    (continued). After #2, pseries_suspend_begin() is called once again
    from the pm core:
    
    dev_attr_store()
    -> store_hibernate()
      -> pm_suspend()
        -> suspend_devices_and_enter()
          -> pseries_suspend_begin()
    
    This is redundant because the VASI suspend state is already known to
    be Suspending.
    
    The begin() callback of platform_suspend_ops is optional, so we can
    simply remove that assignment with no loss of function.
    
    Fixes: 32d8ad4e621d ("powerpc/pseries: Partition hibernation support")
    Signed-off-by: Nathan Lynch <nathanl@linux.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Link: https://lore.kernel.org/r/20201207215200.1785968-18-nathanl@linux.ibm.com
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 6495fddfcaa8b220358b24609cd9b12bd76a6ff5
Author: Nathan Lynch <nathanl@linux.ibm.com>
Date:   Mon Dec 7 15:51:49 2020 -0600

    powerpc/pseries/hibernation: drop pseries_suspend_begin() from suspend ops
    
    [ Upstream commit 52719fce3f4c7a8ac9eaa191e8d75a697f9fbcbc ]
    
    There are three ways pseries_suspend_begin() can be reached:
    
    1. When "mem" is written to /sys/power/state:
    
    kobj_attr_store()
    -> state_store()
      -> pm_suspend()
        -> suspend_devices_and_enter()
          -> pseries_suspend_begin()
    
    This never works because there is no way to supply a valid stream id
    using this interface, and H_VASI_STATE is called with a stream id of
    zero. So this call path is useless at best.
    
    2. When a stream id is written to /sys/devices/system/power/hibernate.
    pseries_suspend_begin() is polled directly from store_hibernate()
    until the stream is in the "Suspending" state (i.e. the platform is
    ready for the OS to suspend execution):
    
    dev_attr_store()
    -> store_hibernate()
      -> pseries_suspend_begin()
    
    3. When a stream id is written to /sys/devices/system/power/hibernate
    (continued). After #2, pseries_suspend_begin() is called once again
    from the pm core:
    
    dev_attr_store()
    -> store_hibernate()
      -> pm_suspend()
        -> suspend_devices_and_enter()
          -> pseries_suspend_begin()
    
    This is redundant because the VASI suspend state is already known to
    be Suspending.
    
    The begin() callback of platform_suspend_ops is optional, so we can
    simply remove that assignment with no loss of function.
    
    Fixes: 32d8ad4e621d ("powerpc/pseries: Partition hibernation support")
    Signed-off-by: Nathan Lynch <nathanl@linux.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Link: https://lore.kernel.org/r/20201207215200.1785968-18-nathanl@linux.ibm.com
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit b7c1ee5025b48fe25418d36e72b6bfb0c7078f3e
Author: Nathan Lynch <nathanl@linux.ibm.com>
Date:   Mon Dec 7 15:51:49 2020 -0600

    powerpc/pseries/hibernation: drop pseries_suspend_begin() from suspend ops
    
    [ Upstream commit 52719fce3f4c7a8ac9eaa191e8d75a697f9fbcbc ]
    
    There are three ways pseries_suspend_begin() can be reached:
    
    1. When "mem" is written to /sys/power/state:
    
    kobj_attr_store()
    -> state_store()
      -> pm_suspend()
        -> suspend_devices_and_enter()
          -> pseries_suspend_begin()
    
    This never works because there is no way to supply a valid stream id
    using this interface, and H_VASI_STATE is called with a stream id of
    zero. So this call path is useless at best.
    
    2. When a stream id is written to /sys/devices/system/power/hibernate.
    pseries_suspend_begin() is polled directly from store_hibernate()
    until the stream is in the "Suspending" state (i.e. the platform is
    ready for the OS to suspend execution):
    
    dev_attr_store()
    -> store_hibernate()
      -> pseries_suspend_begin()
    
    3. When a stream id is written to /sys/devices/system/power/hibernate
    (continued). After #2, pseries_suspend_begin() is called once again
    from the pm core:
    
    dev_attr_store()
    -> store_hibernate()
      -> pm_suspend()
        -> suspend_devices_and_enter()
          -> pseries_suspend_begin()
    
    This is redundant because the VASI suspend state is already known to
    be Suspending.
    
    The begin() callback of platform_suspend_ops is optional, so we can
    simply remove that assignment with no loss of function.
    
    Fixes: 32d8ad4e621d ("powerpc/pseries: Partition hibernation support")
    Signed-off-by: Nathan Lynch <nathanl@linux.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Link: https://lore.kernel.org/r/20201207215200.1785968-18-nathanl@linux.ibm.com
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 0af1cd189e00936ce59157b34641b008f843336c
Author: Nathan Lynch <nathanl@linux.ibm.com>
Date:   Mon Dec 7 15:51:49 2020 -0600

    powerpc/pseries/hibernation: drop pseries_suspend_begin() from suspend ops
    
    [ Upstream commit 52719fce3f4c7a8ac9eaa191e8d75a697f9fbcbc ]
    
    There are three ways pseries_suspend_begin() can be reached:
    
    1. When "mem" is written to /sys/power/state:
    
    kobj_attr_store()
    -> state_store()
      -> pm_suspend()
        -> suspend_devices_and_enter()
          -> pseries_suspend_begin()
    
    This never works because there is no way to supply a valid stream id
    using this interface, and H_VASI_STATE is called with a stream id of
    zero. So this call path is useless at best.
    
    2. When a stream id is written to /sys/devices/system/power/hibernate.
    pseries_suspend_begin() is polled directly from store_hibernate()
    until the stream is in the "Suspending" state (i.e. the platform is
    ready for the OS to suspend execution):
    
    dev_attr_store()
    -> store_hibernate()
      -> pseries_suspend_begin()
    
    3. When a stream id is written to /sys/devices/system/power/hibernate
    (continued). After #2, pseries_suspend_begin() is called once again
    from the pm core:
    
    dev_attr_store()
    -> store_hibernate()
      -> pm_suspend()
        -> suspend_devices_and_enter()
          -> pseries_suspend_begin()
    
    This is redundant because the VASI suspend state is already known to
    be Suspending.
    
    The begin() callback of platform_suspend_ops is optional, so we can
    simply remove that assignment with no loss of function.
    
    Fixes: 32d8ad4e621d ("powerpc/pseries: Partition hibernation support")
    Signed-off-by: Nathan Lynch <nathanl@linux.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Link: https://lore.kernel.org/r/20201207215200.1785968-18-nathanl@linux.ibm.com
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 20e5b2fa8f9fea01be3edf91fb7f6860ce169ee0
Author: Nathan Lynch <nathanl@linux.ibm.com>
Date:   Mon Dec 7 15:51:49 2020 -0600

    powerpc/pseries/hibernation: drop pseries_suspend_begin() from suspend ops
    
    [ Upstream commit 52719fce3f4c7a8ac9eaa191e8d75a697f9fbcbc ]
    
    There are three ways pseries_suspend_begin() can be reached:
    
    1. When "mem" is written to /sys/power/state:
    
    kobj_attr_store()
    -> state_store()
      -> pm_suspend()
        -> suspend_devices_and_enter()
          -> pseries_suspend_begin()
    
    This never works because there is no way to supply a valid stream id
    using this interface, and H_VASI_STATE is called with a stream id of
    zero. So this call path is useless at best.
    
    2. When a stream id is written to /sys/devices/system/power/hibernate.
    pseries_suspend_begin() is polled directly from store_hibernate()
    until the stream is in the "Suspending" state (i.e. the platform is
    ready for the OS to suspend execution):
    
    dev_attr_store()
    -> store_hibernate()
      -> pseries_suspend_begin()
    
    3. When a stream id is written to /sys/devices/system/power/hibernate
    (continued). After #2, pseries_suspend_begin() is called once again
    from the pm core:
    
    dev_attr_store()
    -> store_hibernate()
      -> pm_suspend()
        -> suspend_devices_and_enter()
          -> pseries_suspend_begin()
    
    This is redundant because the VASI suspend state is already known to
    be Suspending.
    
    The begin() callback of platform_suspend_ops is optional, so we can
    simply remove that assignment with no loss of function.
    
    Fixes: 32d8ad4e621d ("powerpc/pseries: Partition hibernation support")
    Signed-off-by: Nathan Lynch <nathanl@linux.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Link: https://lore.kernel.org/r/20201207215200.1785968-18-nathanl@linux.ibm.com
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 52719fce3f4c7a8ac9eaa191e8d75a697f9fbcbc
Author: Nathan Lynch <nathanl@linux.ibm.com>
Date:   Mon Dec 7 15:51:49 2020 -0600

    powerpc/pseries/hibernation: drop pseries_suspend_begin() from suspend ops
    
    There are three ways pseries_suspend_begin() can be reached:
    
    1. When "mem" is written to /sys/power/state:
    
    kobj_attr_store()
    -> state_store()
      -> pm_suspend()
        -> suspend_devices_and_enter()
          -> pseries_suspend_begin()
    
    This never works because there is no way to supply a valid stream id
    using this interface, and H_VASI_STATE is called with a stream id of
    zero. So this call path is useless at best.
    
    2. When a stream id is written to /sys/devices/system/power/hibernate.
    pseries_suspend_begin() is polled directly from store_hibernate()
    until the stream is in the "Suspending" state (i.e. the platform is
    ready for the OS to suspend execution):
    
    dev_attr_store()
    -> store_hibernate()
      -> pseries_suspend_begin()
    
    3. When a stream id is written to /sys/devices/system/power/hibernate
    (continued). After #2, pseries_suspend_begin() is called once again
    from the pm core:
    
    dev_attr_store()
    -> store_hibernate()
      -> pm_suspend()
        -> suspend_devices_and_enter()
          -> pseries_suspend_begin()
    
    This is redundant because the VASI suspend state is already known to
    be Suspending.
    
    The begin() callback of platform_suspend_ops is optional, so we can
    simply remove that assignment with no loss of function.
    
    Fixes: 32d8ad4e621d ("powerpc/pseries: Partition hibernation support")
    Signed-off-by: Nathan Lynch <nathanl@linux.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Link: https://lore.kernel.org/r/20201207215200.1785968-18-nathanl@linux.ibm.com

commit 8ae954caf49ac403c177d117fb8e05cbc866aa3c
Author: Niklas Söderlund <niklas.soderlund+renesas@ragnatech.se>
Date:   Sat Dec 5 03:19:20 2020 +0100

    clocksource/drivers/sh_cmt: Fix potential deadlock when calling runtime PM
    
    The ch->lock is used to protect the whole enable() and read() of
    sh_cmt's implementation of struct clocksource. The enable()
    implementation calls pm_runtime_get_sync() which may result in the clock
    source to be read() triggering a cyclic lockdep warning for the
    ch->lock.
    
    The sh_cmt driver implement its own balancing of calls to
    sh_cmt_{enable,disable}() with flags in sh_cmt_{start,stop}(). It does
    this to deal with that start and stop are shared between the clock
    source and clock event providers. While this could be improved on
    verifying corner cases based on any substantial rework on all devices
    this driver supports might prove hard.
    
    As a first step separate the PM handling for clock event and clock
    source. Always put/get the device when enabling/disabling the clock
    source but keep the clock event logic unchanged. This allows the sh_cmt
    implementation of struct clocksource to call PM without holding the
    ch->lock and avoiding the deadlock.
    
    Triggering and log of the deadlock warning,
    
      # echo e60f0000.timer > /sys/devices/system/clocksource/clocksource0/current_clocksource
      [   46.948370] ======================================================
      [   46.954730] WARNING: possible circular locking dependency detected
      [   46.961094] 5.10.0-rc6-arm64-renesas-00001-g0e5fd7414e8b #36 Not tainted
      [   46.967985] ------------------------------------------------------
      [   46.974342] migration/0/11 is trying to acquire lock:
      [   46.979543] ffff0000403ed220 (&dev->power.lock){-...}-{2:2}, at: __pm_runtime_resume+0x40/0x74
      [   46.988445]
      [   46.988445] but task is already holding lock:
      [   46.994441] ffff000040ad0298 (&ch->lock){....}-{2:2}, at: sh_cmt_start+0x28/0x210
      [   47.002173]
      [   47.002173] which lock already depends on the new lock.
      [   47.002173]
      [   47.010573]
      [   47.010573] the existing dependency chain (in reverse order) is:
      [   47.018262]
      [   47.018262] -> #3 (&ch->lock){....}-{2:2}:
      [   47.024033]        lock_acquire.part.0+0x120/0x330
      [   47.028970]        lock_acquire+0x64/0x80
      [   47.033105]        _raw_spin_lock_irqsave+0x7c/0xc4
      [   47.038130]        sh_cmt_start+0x28/0x210
      [   47.042352]        sh_cmt_clocksource_enable+0x28/0x50
      [   47.047644]        change_clocksource+0x9c/0x160
      [   47.052402]        multi_cpu_stop+0xa4/0x190
      [   47.056799]        cpu_stopper_thread+0x90/0x154
      [   47.061557]        smpboot_thread_fn+0x244/0x270
      [   47.066310]        kthread+0x154/0x160
      [   47.070175]        ret_from_fork+0x10/0x20
      [   47.074390]
      [   47.074390] -> #2 (tk_core.seq.seqcount){----}-{0:0}:
      [   47.081136]        lock_acquire.part.0+0x120/0x330
      [   47.086070]        lock_acquire+0x64/0x80
      [   47.090203]        seqcount_lockdep_reader_access.constprop.0+0x74/0x100
      [   47.097096]        ktime_get+0x28/0xa0
      [   47.100960]        hrtimer_start_range_ns+0x210/0x2dc
      [   47.106164]        generic_sched_clock_init+0x70/0x88
      [   47.111364]        sched_clock_init+0x40/0x64
      [   47.115853]        start_kernel+0x494/0x524
      [   47.120156]
      [   47.120156] -> #1 (hrtimer_bases.lock){-.-.}-{2:2}:
      [   47.126721]        lock_acquire.part.0+0x120/0x330
      [   47.136042]        lock_acquire+0x64/0x80
      [   47.144461]        _raw_spin_lock_irqsave+0x7c/0xc4
      [   47.153721]        hrtimer_start_range_ns+0x68/0x2dc
      [   47.163054]        rpm_suspend+0x308/0x5dc
      [   47.171473]        rpm_idle+0xc4/0x2a4
      [   47.179550]        pm_runtime_work+0x98/0xc0
      [   47.188209]        process_one_work+0x294/0x6f0
      [   47.197142]        worker_thread+0x70/0x45c
      [   47.205661]        kthread+0x154/0x160
      [   47.213673]        ret_from_fork+0x10/0x20
      [   47.221957]
      [   47.221957] -> #0 (&dev->power.lock){-...}-{2:2}:
      [   47.236292]        check_noncircular+0x128/0x140
      [   47.244907]        __lock_acquire+0x13b0/0x204c
      [   47.253332]        lock_acquire.part.0+0x120/0x330
      [   47.262033]        lock_acquire+0x64/0x80
      [   47.269826]        _raw_spin_lock_irqsave+0x7c/0xc4
      [   47.278430]        __pm_runtime_resume+0x40/0x74
      [   47.286758]        sh_cmt_start+0x84/0x210
      [   47.294537]        sh_cmt_clocksource_enable+0x28/0x50
      [   47.303449]        change_clocksource+0x9c/0x160
      [   47.311783]        multi_cpu_stop+0xa4/0x190
      [   47.319720]        cpu_stopper_thread+0x90/0x154
      [   47.328022]        smpboot_thread_fn+0x244/0x270
      [   47.336298]        kthread+0x154/0x160
      [   47.343708]        ret_from_fork+0x10/0x20
      [   47.351445]
      [   47.351445] other info that might help us debug this:
      [   47.351445]
      [   47.370225] Chain exists of:
      [   47.370225]   &dev->power.lock --> tk_core.seq.seqcount --> &ch->lock
      [   47.370225]
      [   47.392003]  Possible unsafe locking scenario:
      [   47.392003]
      [   47.405314]        CPU0                    CPU1
      [   47.413569]        ----                    ----
      [   47.421768]   lock(&ch->lock);
      [   47.428425]                                lock(tk_core.seq.seqcount);
      [   47.438701]                                lock(&ch->lock);
      [   47.447930]   lock(&dev->power.lock);
      [   47.455172]
      [   47.455172]  *** DEADLOCK ***
      [   47.455172]
      [   47.471433] 3 locks held by migration/0/11:
      [   47.479099]  #0: ffff8000113c9278 (timekeeper_lock){-.-.}-{2:2}, at: change_clocksource+0x2c/0x160
      [   47.491834]  #1: ffff8000113c8f88 (tk_core.seq.seqcount){----}-{0:0}, at: multi_cpu_stop+0xa4/0x190
      [   47.504727]  #2: ffff000040ad0298 (&ch->lock){....}-{2:2}, at: sh_cmt_start+0x28/0x210
      [   47.516541]
      [   47.516541] stack backtrace:
      [   47.528480] CPU: 0 PID: 11 Comm: migration/0 Not tainted 5.10.0-rc6-arm64-renesas-00001-g0e5fd7414e8b #36
      [   47.542147] Hardware name: Renesas Salvator-X 2nd version board based on r8a77965 (DT)
      [   47.554241] Call trace:
      [   47.560832]  dump_backtrace+0x0/0x190
      [   47.568670]  show_stack+0x14/0x30
      [   47.576144]  dump_stack+0xe8/0x130
      [   47.583670]  print_circular_bug+0x1f0/0x200
      [   47.592015]  check_noncircular+0x128/0x140
      [   47.600289]  __lock_acquire+0x13b0/0x204c
      [   47.608486]  lock_acquire.part.0+0x120/0x330
      [   47.616953]  lock_acquire+0x64/0x80
      [   47.624582]  _raw_spin_lock_irqsave+0x7c/0xc4
      [   47.633114]  __pm_runtime_resume+0x40/0x74
      [   47.641371]  sh_cmt_start+0x84/0x210
      [   47.649115]  sh_cmt_clocksource_enable+0x28/0x50
      [   47.657916]  change_clocksource+0x9c/0x160
      [   47.666165]  multi_cpu_stop+0xa4/0x190
      [   47.674056]  cpu_stopper_thread+0x90/0x154
      [   47.682308]  smpboot_thread_fn+0x244/0x270
      [   47.690560]  kthread+0x154/0x160
      [   47.697927]  ret_from_fork+0x10/0x20
      [   47.708447] clocksource: Switched to clocksource e60f0000.timer
    
    Signed-off-by: Niklas Söderlund <niklas.soderlund+renesas@ragnatech.se>
    Reviewed-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Link: https://lore.kernel.org/r/20201205021921.1456190-2-niklas.soderlund+renesas@ragnatech.se

commit 4ea0bf2a52f1eea76578eac5a9148d95f5e181c0
Author: JC Kuo <jckuo@nvidia.com>
Date:   Tue Nov 17 16:38:03 2020 +0800

    phy: tegra: xusb: Fix usb_phy device driver field
    
    In commit "phy: tegra: xusb: Add usb-phy support", an OTG capable PHY
    device, such as phy-usb2.0 device of Jetson-TX1 platform, will be
    bound to the tegra-xusb-padctl driver by the following line in
    tegra_xusb_setup_usb_role_switch().
    
            port->usb_phy.dev->driver = port->padctl->dev->driver;
    
    With this, dev_pm_ops set of tegra-xusb-padctl driver will be invoked
    for the OTG capable PHY incorrectly as below logs show.
    
    This commit fixes the issue by assigning an empty driver to it.
    
    [  153.451108] tegra-xusb-padctl phy-usb2.0: > tegra_xusb_padctl_suspend_noirq(dev=ffff000080917000)
    [  153.460353] tegra-xusb-padctl phy-usb2.0:   driver: ffff8000114453e0 (tegra_xusb_padctl_driver)
    [  153.469245] tegra-xusb-padctl phy-usb2.0:   padctl: ffff0000829f6480
    [  153.475772] tegra-xusb-padctl phy-usb2.0:     soc: ef7bdd7fffffffff (0xef7bdd7fffffffff)
    [  153.484061] Unable to handle kernel paging request at virtual address 007bdd800000004f
    [  153.492132] Mem abort info:
    [  153.495083]   ESR = 0x96000004
    [  153.498308]   EC = 0x25: DABT (current EL), IL = 32 bits
    [  153.503771]   SET = 0, FnV = 0
    [  153.506979]   EA = 0, S1PTW = 0
    [  153.510260] Data abort info:
    [  153.513200]   ISV = 0, ISS = 0x00000004
    [  153.517181]   CM = 0, WnR = 0
    [  153.520302] [007bdd800000004f] address between user and kernel address ranges
    [  153.527600] Internal error: Oops: 96000004 [#1] PREEMPT SMP
    [  153.533231] Modules linked in: nouveau panel_simple tegra_video(C) tegra_drm drm_ttm_helper videobuf2_dma_contig ttm videobuf2_memops cec videobuf2_v4l2 videobuf2_common drm_kms_helper v4l2_fwnode videodev drm mc snd_hda_codec_hdmi cdc_ether usbnet snd_hda_tegra r8152 crct10dif_ce snd_hda_codec snd_hda_core tegra_xudc host1x lp855x_bl at24 ip_tables x_tables ipv6
    [  153.566417] CPU: 0 PID: 300 Comm: systemd-sleep Tainted: G         C        5.10.0-rc3-next-20201113-00019-g5c064d5372b0-dirty #624
    [  153.578283] Hardware name: NVIDIA Jetson TX1 Developer Kit (DT)
    [  153.584281] pstate: 40000005 (nZcv daif -PAN -UAO -TCO BTYPE=--)
    [  153.590381] pc : tegra_xusb_padctl_suspend_noirq+0x88/0x100
    [  153.596016] lr : tegra_xusb_padctl_suspend_noirq+0x80/0x100
    [  153.601632] sp : ffff8000120dbb60
    [  153.604999] x29: ffff8000120dbb60 x28: ffff000080a1df00
    [  153.610430] x27: 0000000000000002 x26: ffff8000106f8540
    [  153.615858] x25: ffff8000113ac4a4 x24: ffff80001148c198
    [  153.621277] x23: ffff800010c4538c x22: 0000000000000002
    [  153.626692] x21: ffff800010ccde80 x20: ffff0000829f6480
    [  153.632107] x19: ffff000080917000 x18: 0000000000000030
    [  153.637521] x17: 0000000000000000 x16: 0000000000000000
    [  153.642933] x15: ffff000080a1e380 x14: 74636461702d6273
    [  153.648346] x13: ffff8000113ad058 x12: 0000000000000f39
    [  153.653759] x11: 0000000000000513 x10: ffff800011405058
    [  153.659176] x9 : 00000000fffff000 x8 : ffff8000113ad058
    [  153.664590] x7 : ffff800011405058 x6 : 0000000000000000
    [  153.670002] x5 : 0000000000000000 x4 : ffff0000fe908bc0
    [  153.675414] x3 : ffff0000fe910228 x2 : 162ef67e0581e700
    [  153.680826] x1 : 162ef67e0581e700 x0 : ef7bdd7fffffffff
    [  153.686241] Call trace:
    [  153.688769]  tegra_xusb_padctl_suspend_noirq+0x88/0x100
    [  153.694077]  __device_suspend_noirq+0x68/0x1cc
    [  153.698594]  dpm_noirq_suspend_devices+0x10c/0x1d0
    [  153.703456]  dpm_suspend_noirq+0x28/0xa0
    [  153.707461]  suspend_devices_and_enter+0x234/0x4bc
    [  153.712314]  pm_suspend+0x1e4/0x270
    [  153.715868]  state_store+0x8c/0x110
    [  153.719440]  kobj_attr_store+0x1c/0x30
    [  153.723259]  sysfs_kf_write+0x4c/0x7c
    [  153.726981]  kernfs_fop_write+0x124/0x240
    [  153.731065]  vfs_write+0xe4/0x204
    [  153.734449]  ksys_write+0x6c/0x100
    [  153.737925]  __arm64_sys_write+0x20/0x30
    [  153.741931]  el0_svc_common.constprop.0+0x78/0x1a0
    [  153.746789]  do_el0_svc+0x24/0x90
    [  153.750181]  el0_sync_handler+0x254/0x260
    [  153.754251]  el0_sync+0x174/0x180
    [  153.757663] Code: aa0303e2 94000f64 f9405680 b40000e0 (f9402803)
    [  153.763826] ---[ end trace 81543a3394cb409d ]---
    
    Fixes: e8f7d2f409a1 ("phy: tegra: xusb: Add usb-phy support")
    
    Signed-off-by: JC Kuo <jckuo@nvidia.com>
    Acked-by: Thierry Reding <treding@nvidia.com>
    Link: https://lore.kernel.org/r/20201117083803.185209-1-jckuo@nvidia.com
    Signed-off-by: Vinod Koul <vkoul@kernel.org>

commit eba0d703b3ca5f1f24df3798c936906f2da39058
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Tue Nov 17 10:21:37 2020 +0300

    drm/kmb: Remove an unnecessary NULL check
    
    The NULL checking isn't done consistently in this function and it leads
    to a static checker warning:
    
        drivers/gpu/drm/kmb/kmb_drv.c:561 kmb_pm_suspend()
        error: we previously assumed 'drm' could be null (see line 559)
    
    Fortunately "drm" cannot be NULL at this point so the check can just be
    removed.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Reviewed-by: Anitha Chrisanthus <anitha.chrisanthus@intel.com>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Link: https://patchwork.freedesktop.org/patch/msgid/20201117072137.GB1111239@mwanda

commit baed393e8550fa075512772fad27e98ba9dcb527
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Nov 27 09:07:40 2020 +0900

    ASoC: soc-core: add soc_dapm_suspend_resume()
    
    snd_soc_suspend() and soc_resume_deferred() are calling
    same snd_soc_dapm_stream_event() with same logic with different parameter.
    This patch adds new soc_dapm_suspend_resume() and share the code.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87im9rekfp.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

commit 19e52bcb27c2ba140699d2230d722366d7d048a1
Author: Kuogee Hsieh <khsieh@codeaurora.org>
Date:   Tue Nov 3 14:53:35 2020 -0800

    drm/msm/dp: return correct connection status after suspend
    
    During suspend, dp host controller and hpd block are disabled due to
    both ahb and aux clock are disabled. Therefore hpd plug/unplug interrupts
    will not be generated. At dp_pm_resume(), reinitialize both dp host
    controller and hpd block so that hpd plug/unplug interrupts will be
    generated and handled by driver so that hpd connection state is updated
    correctly. This patch will fix link training flaky issues.
    
    Changes in v2:
    -- use container_of to cast correct dp_display_private pointer
       at both dp_pm_suspend() and dp_pm_resume().
    
    Changes in v3:
    -- replace hpd_state atomic_t  with u32
    
    Changes in v4
    -- call dp_display_host_deinit() at dp_pm_suspend()
    -- call dp_display_host_init() at msm_dp_display_enable()
    -- fix phy->init_count unbalance which causes link training failed
    
    Changes in v5
    --  add Fixes tag
    
    Fixes:  8ede2ecc3e5e (drm/msm/dp: Add DP compliance tests on Snapdragon Chipsets)
    Tested-by: Stephen Boyd <swboyd@chromium.org>
    Signed-off-by: Kuogee Hsieh <khsieh@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@chromium.org>

commit 054ace8119b2043cc1661bac82af2a9a505e4e0f
Author: Li Jun <jun.li@nxp.com>
Date:   Tue Jul 28 20:42:40 2020 +0800

    usb: dwc3: core: don't trigger runtime pm when remove driver
    
    commit 266d0493900ac5d6a21cdbe6b1624ed2da94d47a upstream.
    
    No need to trigger runtime pm in driver removal, otherwise if user
    disable auto suspend via sys file, runtime suspend may be entered,
    which will call dwc3_core_exit() again and there will be clock disable
    not balance warning:
    
    [ 2026.820154] xhci-hcd xhci-hcd.0.auto: remove, state 4
    [ 2026.825268] usb usb2: USB disconnect, device number 1
    [ 2026.831017] xhci-hcd xhci-hcd.0.auto: USB bus 2 deregistered
    [ 2026.836806] xhci-hcd xhci-hcd.0.auto: remove, state 4
    [ 2026.842029] usb usb1: USB disconnect, device number 1
    [ 2026.848029] xhci-hcd xhci-hcd.0.auto: USB bus 1 deregistered
    [ 2026.865889] ------------[ cut here ]------------
    [ 2026.870506] usb2_ctrl_root_clk already disabled
    [ 2026.875082] WARNING: CPU: 0 PID: 731 at drivers/clk/clk.c:958
    clk_core_disable+0xa0/0xa8
    [ 2026.883170] Modules linked in: dwc3(-) phy_fsl_imx8mq_usb [last
    unloaded: dwc3]
    [ 2026.890488] CPU: 0 PID: 731 Comm: rmmod Not tainted
    5.8.0-rc7-00280-g9d08cca-dirty #245
    [ 2026.898489] Hardware name: NXP i.MX8MQ EVK (DT)
    [ 2026.903020] pstate: 20000085 (nzCv daIf -PAN -UAO BTYPE=--)
    [ 2026.908594] pc : clk_core_disable+0xa0/0xa8
    [ 2026.912777] lr : clk_core_disable+0xa0/0xa8
    [ 2026.916958] sp : ffff8000121b39a0
    [ 2026.920271] x29: ffff8000121b39a0 x28: ffff0000b11f3700
    [ 2026.925583] x27: 0000000000000000 x26: ffff0000b539c700
    [ 2026.930895] x25: 000001d7e44e1232 x24: ffff0000b76fa800
    [ 2026.936208] x23: ffff0000b76fa6f8 x22: ffff800008d01040
    [ 2026.941520] x21: ffff0000b539ce00 x20: ffff0000b7105000
    [ 2026.946832] x19: ffff0000b7105000 x18: 0000000000000010
    [ 2026.952144] x17: 0000000000000001 x16: 0000000000000000
    [ 2026.957456] x15: ffff0000b11f3b70 x14: ffffffffffffffff
    [ 2026.962768] x13: ffff8000921b36f7 x12: ffff8000121b36ff
    [ 2026.968080] x11: ffff8000119e1000 x10: ffff800011bf26d0
    [ 2026.973392] x9 : 0000000000000000 x8 : ffff800011bf3000
    [ 2026.978704] x7 : ffff800010695d68 x6 : 0000000000000252
    [ 2026.984016] x5 : ffff0000bb9881f0 x4 : 0000000000000000
    [ 2026.989327] x3 : 0000000000000027 x2 : 0000000000000023
    [ 2026.994639] x1 : ac2fa471aa7cab00 x0 : 0000000000000000
    [ 2026.999951] Call trace:
    [ 2027.002401]  clk_core_disable+0xa0/0xa8
    [ 2027.006238]  clk_core_disable_lock+0x20/0x38
    [ 2027.010508]  clk_disable+0x1c/0x28
    [ 2027.013911]  clk_bulk_disable+0x34/0x50
    [ 2027.017758]  dwc3_core_exit+0xec/0x110 [dwc3]
    [ 2027.022122]  dwc3_suspend_common+0x84/0x188 [dwc3]
    [ 2027.026919]  dwc3_runtime_suspend+0x74/0x9c [dwc3]
    [ 2027.031712]  pm_generic_runtime_suspend+0x28/0x40
    [ 2027.036419]  genpd_runtime_suspend+0xa0/0x258
    [ 2027.040777]  __rpm_callback+0x88/0x140
    [ 2027.044526]  rpm_callback+0x20/0x80
    [ 2027.048015]  rpm_suspend+0xd0/0x418
    [ 2027.051503]  __pm_runtime_suspend+0x58/0xa0
    [ 2027.055693]  dwc3_runtime_idle+0x7c/0x90 [dwc3]
    [ 2027.060224]  __rpm_callback+0x88/0x140
    [ 2027.063973]  rpm_idle+0x78/0x150
    [ 2027.067201]  __pm_runtime_idle+0x58/0xa0
    [ 2027.071130]  dwc3_remove+0x64/0xc0 [dwc3]
    [ 2027.075140]  platform_drv_remove+0x28/0x48
    [ 2027.079239]  device_release_driver_internal+0xf4/0x1c0
    [ 2027.084377]  driver_detach+0x4c/0xd8
    [ 2027.087954]  bus_remove_driver+0x54/0xa8
    [ 2027.091877]  driver_unregister+0x2c/0x58
    [ 2027.095799]  platform_driver_unregister+0x10/0x18
    [ 2027.100509]  dwc3_driver_exit+0x14/0x1408 [dwc3]
    [ 2027.105129]  __arm64_sys_delete_module+0x178/0x218
    [ 2027.109922]  el0_svc_common.constprop.0+0x68/0x160
    [ 2027.114714]  do_el0_svc+0x20/0x80
    [ 2027.118031]  el0_sync_handler+0x88/0x190
    [ 2027.121953]  el0_sync+0x140/0x180
    [ 2027.125267] ---[ end trace 027f4f8189958f1f ]---
    [ 2027.129976] ------------[ cut here ]------------
    
    Fixes: fc8bb91bc83e ("usb: dwc3: implement runtime PM")
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Li Jun <jun.li@nxp.com>
    Signed-off-by: Felipe Balbi <balbi@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 47d52604b8e87bc05ca30933bd7c8b3adcccc2da
Author: Li Jun <jun.li@nxp.com>
Date:   Tue Jul 28 20:42:40 2020 +0800

    usb: dwc3: core: don't trigger runtime pm when remove driver
    
    commit 266d0493900ac5d6a21cdbe6b1624ed2da94d47a upstream.
    
    No need to trigger runtime pm in driver removal, otherwise if user
    disable auto suspend via sys file, runtime suspend may be entered,
    which will call dwc3_core_exit() again and there will be clock disable
    not balance warning:
    
    [ 2026.820154] xhci-hcd xhci-hcd.0.auto: remove, state 4
    [ 2026.825268] usb usb2: USB disconnect, device number 1
    [ 2026.831017] xhci-hcd xhci-hcd.0.auto: USB bus 2 deregistered
    [ 2026.836806] xhci-hcd xhci-hcd.0.auto: remove, state 4
    [ 2026.842029] usb usb1: USB disconnect, device number 1
    [ 2026.848029] xhci-hcd xhci-hcd.0.auto: USB bus 1 deregistered
    [ 2026.865889] ------------[ cut here ]------------
    [ 2026.870506] usb2_ctrl_root_clk already disabled
    [ 2026.875082] WARNING: CPU: 0 PID: 731 at drivers/clk/clk.c:958
    clk_core_disable+0xa0/0xa8
    [ 2026.883170] Modules linked in: dwc3(-) phy_fsl_imx8mq_usb [last
    unloaded: dwc3]
    [ 2026.890488] CPU: 0 PID: 731 Comm: rmmod Not tainted
    5.8.0-rc7-00280-g9d08cca-dirty #245
    [ 2026.898489] Hardware name: NXP i.MX8MQ EVK (DT)
    [ 2026.903020] pstate: 20000085 (nzCv daIf -PAN -UAO BTYPE=--)
    [ 2026.908594] pc : clk_core_disable+0xa0/0xa8
    [ 2026.912777] lr : clk_core_disable+0xa0/0xa8
    [ 2026.916958] sp : ffff8000121b39a0
    [ 2026.920271] x29: ffff8000121b39a0 x28: ffff0000b11f3700
    [ 2026.925583] x27: 0000000000000000 x26: ffff0000b539c700
    [ 2026.930895] x25: 000001d7e44e1232 x24: ffff0000b76fa800
    [ 2026.936208] x23: ffff0000b76fa6f8 x22: ffff800008d01040
    [ 2026.941520] x21: ffff0000b539ce00 x20: ffff0000b7105000
    [ 2026.946832] x19: ffff0000b7105000 x18: 0000000000000010
    [ 2026.952144] x17: 0000000000000001 x16: 0000000000000000
    [ 2026.957456] x15: ffff0000b11f3b70 x14: ffffffffffffffff
    [ 2026.962768] x13: ffff8000921b36f7 x12: ffff8000121b36ff
    [ 2026.968080] x11: ffff8000119e1000 x10: ffff800011bf26d0
    [ 2026.973392] x9 : 0000000000000000 x8 : ffff800011bf3000
    [ 2026.978704] x7 : ffff800010695d68 x6 : 0000000000000252
    [ 2026.984016] x5 : ffff0000bb9881f0 x4 : 0000000000000000
    [ 2026.989327] x3 : 0000000000000027 x2 : 0000000000000023
    [ 2026.994639] x1 : ac2fa471aa7cab00 x0 : 0000000000000000
    [ 2026.999951] Call trace:
    [ 2027.002401]  clk_core_disable+0xa0/0xa8
    [ 2027.006238]  clk_core_disable_lock+0x20/0x38
    [ 2027.010508]  clk_disable+0x1c/0x28
    [ 2027.013911]  clk_bulk_disable+0x34/0x50
    [ 2027.017758]  dwc3_core_exit+0xec/0x110 [dwc3]
    [ 2027.022122]  dwc3_suspend_common+0x84/0x188 [dwc3]
    [ 2027.026919]  dwc3_runtime_suspend+0x74/0x9c [dwc3]
    [ 2027.031712]  pm_generic_runtime_suspend+0x28/0x40
    [ 2027.036419]  genpd_runtime_suspend+0xa0/0x258
    [ 2027.040777]  __rpm_callback+0x88/0x140
    [ 2027.044526]  rpm_callback+0x20/0x80
    [ 2027.048015]  rpm_suspend+0xd0/0x418
    [ 2027.051503]  __pm_runtime_suspend+0x58/0xa0
    [ 2027.055693]  dwc3_runtime_idle+0x7c/0x90 [dwc3]
    [ 2027.060224]  __rpm_callback+0x88/0x140
    [ 2027.063973]  rpm_idle+0x78/0x150
    [ 2027.067201]  __pm_runtime_idle+0x58/0xa0
    [ 2027.071130]  dwc3_remove+0x64/0xc0 [dwc3]
    [ 2027.075140]  platform_drv_remove+0x28/0x48
    [ 2027.079239]  device_release_driver_internal+0xf4/0x1c0
    [ 2027.084377]  driver_detach+0x4c/0xd8
    [ 2027.087954]  bus_remove_driver+0x54/0xa8
    [ 2027.091877]  driver_unregister+0x2c/0x58
    [ 2027.095799]  platform_driver_unregister+0x10/0x18
    [ 2027.100509]  dwc3_driver_exit+0x14/0x1408 [dwc3]
    [ 2027.105129]  __arm64_sys_delete_module+0x178/0x218
    [ 2027.109922]  el0_svc_common.constprop.0+0x68/0x160
    [ 2027.114714]  do_el0_svc+0x20/0x80
    [ 2027.118031]  el0_sync_handler+0x88/0x190
    [ 2027.121953]  el0_sync+0x140/0x180
    [ 2027.125267] ---[ end trace 027f4f8189958f1f ]---
    [ 2027.129976] ------------[ cut here ]------------
    
    Fixes: fc8bb91bc83e ("usb: dwc3: implement runtime PM")
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Li Jun <jun.li@nxp.com>
    Signed-off-by: Felipe Balbi <balbi@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 97224cdc0440b006b60239b90cd2c1ffb8bb23aa
Author: Li Jun <jun.li@nxp.com>
Date:   Tue Jul 28 20:42:40 2020 +0800

    usb: dwc3: core: don't trigger runtime pm when remove driver
    
    commit 266d0493900ac5d6a21cdbe6b1624ed2da94d47a upstream.
    
    No need to trigger runtime pm in driver removal, otherwise if user
    disable auto suspend via sys file, runtime suspend may be entered,
    which will call dwc3_core_exit() again and there will be clock disable
    not balance warning:
    
    [ 2026.820154] xhci-hcd xhci-hcd.0.auto: remove, state 4
    [ 2026.825268] usb usb2: USB disconnect, device number 1
    [ 2026.831017] xhci-hcd xhci-hcd.0.auto: USB bus 2 deregistered
    [ 2026.836806] xhci-hcd xhci-hcd.0.auto: remove, state 4
    [ 2026.842029] usb usb1: USB disconnect, device number 1
    [ 2026.848029] xhci-hcd xhci-hcd.0.auto: USB bus 1 deregistered
    [ 2026.865889] ------------[ cut here ]------------
    [ 2026.870506] usb2_ctrl_root_clk already disabled
    [ 2026.875082] WARNING: CPU: 0 PID: 731 at drivers/clk/clk.c:958
    clk_core_disable+0xa0/0xa8
    [ 2026.883170] Modules linked in: dwc3(-) phy_fsl_imx8mq_usb [last
    unloaded: dwc3]
    [ 2026.890488] CPU: 0 PID: 731 Comm: rmmod Not tainted
    5.8.0-rc7-00280-g9d08cca-dirty #245
    [ 2026.898489] Hardware name: NXP i.MX8MQ EVK (DT)
    [ 2026.903020] pstate: 20000085 (nzCv daIf -PAN -UAO BTYPE=--)
    [ 2026.908594] pc : clk_core_disable+0xa0/0xa8
    [ 2026.912777] lr : clk_core_disable+0xa0/0xa8
    [ 2026.916958] sp : ffff8000121b39a0
    [ 2026.920271] x29: ffff8000121b39a0 x28: ffff0000b11f3700
    [ 2026.925583] x27: 0000000000000000 x26: ffff0000b539c700
    [ 2026.930895] x25: 000001d7e44e1232 x24: ffff0000b76fa800
    [ 2026.936208] x23: ffff0000b76fa6f8 x22: ffff800008d01040
    [ 2026.941520] x21: ffff0000b539ce00 x20: ffff0000b7105000
    [ 2026.946832] x19: ffff0000b7105000 x18: 0000000000000010
    [ 2026.952144] x17: 0000000000000001 x16: 0000000000000000
    [ 2026.957456] x15: ffff0000b11f3b70 x14: ffffffffffffffff
    [ 2026.962768] x13: ffff8000921b36f7 x12: ffff8000121b36ff
    [ 2026.968080] x11: ffff8000119e1000 x10: ffff800011bf26d0
    [ 2026.973392] x9 : 0000000000000000 x8 : ffff800011bf3000
    [ 2026.978704] x7 : ffff800010695d68 x6 : 0000000000000252
    [ 2026.984016] x5 : ffff0000bb9881f0 x4 : 0000000000000000
    [ 2026.989327] x3 : 0000000000000027 x2 : 0000000000000023
    [ 2026.994639] x1 : ac2fa471aa7cab00 x0 : 0000000000000000
    [ 2026.999951] Call trace:
    [ 2027.002401]  clk_core_disable+0xa0/0xa8
    [ 2027.006238]  clk_core_disable_lock+0x20/0x38
    [ 2027.010508]  clk_disable+0x1c/0x28
    [ 2027.013911]  clk_bulk_disable+0x34/0x50
    [ 2027.017758]  dwc3_core_exit+0xec/0x110 [dwc3]
    [ 2027.022122]  dwc3_suspend_common+0x84/0x188 [dwc3]
    [ 2027.026919]  dwc3_runtime_suspend+0x74/0x9c [dwc3]
    [ 2027.031712]  pm_generic_runtime_suspend+0x28/0x40
    [ 2027.036419]  genpd_runtime_suspend+0xa0/0x258
    [ 2027.040777]  __rpm_callback+0x88/0x140
    [ 2027.044526]  rpm_callback+0x20/0x80
    [ 2027.048015]  rpm_suspend+0xd0/0x418
    [ 2027.051503]  __pm_runtime_suspend+0x58/0xa0
    [ 2027.055693]  dwc3_runtime_idle+0x7c/0x90 [dwc3]
    [ 2027.060224]  __rpm_callback+0x88/0x140
    [ 2027.063973]  rpm_idle+0x78/0x150
    [ 2027.067201]  __pm_runtime_idle+0x58/0xa0
    [ 2027.071130]  dwc3_remove+0x64/0xc0 [dwc3]
    [ 2027.075140]  platform_drv_remove+0x28/0x48
    [ 2027.079239]  device_release_driver_internal+0xf4/0x1c0
    [ 2027.084377]  driver_detach+0x4c/0xd8
    [ 2027.087954]  bus_remove_driver+0x54/0xa8
    [ 2027.091877]  driver_unregister+0x2c/0x58
    [ 2027.095799]  platform_driver_unregister+0x10/0x18
    [ 2027.100509]  dwc3_driver_exit+0x14/0x1408 [dwc3]
    [ 2027.105129]  __arm64_sys_delete_module+0x178/0x218
    [ 2027.109922]  el0_svc_common.constprop.0+0x68/0x160
    [ 2027.114714]  do_el0_svc+0x20/0x80
    [ 2027.118031]  el0_sync_handler+0x88/0x190
    [ 2027.121953]  el0_sync+0x140/0x180
    [ 2027.125267] ---[ end trace 027f4f8189958f1f ]---
    [ 2027.129976] ------------[ cut here ]------------
    
    Fixes: fc8bb91bc83e ("usb: dwc3: implement runtime PM")
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Li Jun <jun.li@nxp.com>
    Signed-off-by: Felipe Balbi <balbi@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit f324c9f5ba40ae617c9601743be42e1449e3c305
Author: Li Jun <jun.li@nxp.com>
Date:   Tue Jul 28 20:42:40 2020 +0800

    usb: dwc3: core: don't trigger runtime pm when remove driver
    
    commit 266d0493900ac5d6a21cdbe6b1624ed2da94d47a upstream.
    
    No need to trigger runtime pm in driver removal, otherwise if user
    disable auto suspend via sys file, runtime suspend may be entered,
    which will call dwc3_core_exit() again and there will be clock disable
    not balance warning:
    
    [ 2026.820154] xhci-hcd xhci-hcd.0.auto: remove, state 4
    [ 2026.825268] usb usb2: USB disconnect, device number 1
    [ 2026.831017] xhci-hcd xhci-hcd.0.auto: USB bus 2 deregistered
    [ 2026.836806] xhci-hcd xhci-hcd.0.auto: remove, state 4
    [ 2026.842029] usb usb1: USB disconnect, device number 1
    [ 2026.848029] xhci-hcd xhci-hcd.0.auto: USB bus 1 deregistered
    [ 2026.865889] ------------[ cut here ]------------
    [ 2026.870506] usb2_ctrl_root_clk already disabled
    [ 2026.875082] WARNING: CPU: 0 PID: 731 at drivers/clk/clk.c:958
    clk_core_disable+0xa0/0xa8
    [ 2026.883170] Modules linked in: dwc3(-) phy_fsl_imx8mq_usb [last
    unloaded: dwc3]
    [ 2026.890488] CPU: 0 PID: 731 Comm: rmmod Not tainted
    5.8.0-rc7-00280-g9d08cca-dirty #245
    [ 2026.898489] Hardware name: NXP i.MX8MQ EVK (DT)
    [ 2026.903020] pstate: 20000085 (nzCv daIf -PAN -UAO BTYPE=--)
    [ 2026.908594] pc : clk_core_disable+0xa0/0xa8
    [ 2026.912777] lr : clk_core_disable+0xa0/0xa8
    [ 2026.916958] sp : ffff8000121b39a0
    [ 2026.920271] x29: ffff8000121b39a0 x28: ffff0000b11f3700
    [ 2026.925583] x27: 0000000000000000 x26: ffff0000b539c700
    [ 2026.930895] x25: 000001d7e44e1232 x24: ffff0000b76fa800
    [ 2026.936208] x23: ffff0000b76fa6f8 x22: ffff800008d01040
    [ 2026.941520] x21: ffff0000b539ce00 x20: ffff0000b7105000
    [ 2026.946832] x19: ffff0000b7105000 x18: 0000000000000010
    [ 2026.952144] x17: 0000000000000001 x16: 0000000000000000
    [ 2026.957456] x15: ffff0000b11f3b70 x14: ffffffffffffffff
    [ 2026.962768] x13: ffff8000921b36f7 x12: ffff8000121b36ff
    [ 2026.968080] x11: ffff8000119e1000 x10: ffff800011bf26d0
    [ 2026.973392] x9 : 0000000000000000 x8 : ffff800011bf3000
    [ 2026.978704] x7 : ffff800010695d68 x6 : 0000000000000252
    [ 2026.984016] x5 : ffff0000bb9881f0 x4 : 0000000000000000
    [ 2026.989327] x3 : 0000000000000027 x2 : 0000000000000023
    [ 2026.994639] x1 : ac2fa471aa7cab00 x0 : 0000000000000000
    [ 2026.999951] Call trace:
    [ 2027.002401]  clk_core_disable+0xa0/0xa8
    [ 2027.006238]  clk_core_disable_lock+0x20/0x38
    [ 2027.010508]  clk_disable+0x1c/0x28
    [ 2027.013911]  clk_bulk_disable+0x34/0x50
    [ 2027.017758]  dwc3_core_exit+0xec/0x110 [dwc3]
    [ 2027.022122]  dwc3_suspend_common+0x84/0x188 [dwc3]
    [ 2027.026919]  dwc3_runtime_suspend+0x74/0x9c [dwc3]
    [ 2027.031712]  pm_generic_runtime_suspend+0x28/0x40
    [ 2027.036419]  genpd_runtime_suspend+0xa0/0x258
    [ 2027.040777]  __rpm_callback+0x88/0x140
    [ 2027.044526]  rpm_callback+0x20/0x80
    [ 2027.048015]  rpm_suspend+0xd0/0x418
    [ 2027.051503]  __pm_runtime_suspend+0x58/0xa0
    [ 2027.055693]  dwc3_runtime_idle+0x7c/0x90 [dwc3]
    [ 2027.060224]  __rpm_callback+0x88/0x140
    [ 2027.063973]  rpm_idle+0x78/0x150
    [ 2027.067201]  __pm_runtime_idle+0x58/0xa0
    [ 2027.071130]  dwc3_remove+0x64/0xc0 [dwc3]
    [ 2027.075140]  platform_drv_remove+0x28/0x48
    [ 2027.079239]  device_release_driver_internal+0xf4/0x1c0
    [ 2027.084377]  driver_detach+0x4c/0xd8
    [ 2027.087954]  bus_remove_driver+0x54/0xa8
    [ 2027.091877]  driver_unregister+0x2c/0x58
    [ 2027.095799]  platform_driver_unregister+0x10/0x18
    [ 2027.100509]  dwc3_driver_exit+0x14/0x1408 [dwc3]
    [ 2027.105129]  __arm64_sys_delete_module+0x178/0x218
    [ 2027.109922]  el0_svc_common.constprop.0+0x68/0x160
    [ 2027.114714]  do_el0_svc+0x20/0x80
    [ 2027.118031]  el0_sync_handler+0x88/0x190
    [ 2027.121953]  el0_sync+0x140/0x180
    [ 2027.125267] ---[ end trace 027f4f8189958f1f ]---
    [ 2027.129976] ------------[ cut here ]------------
    
    Fixes: fc8bb91bc83e ("usb: dwc3: implement runtime PM")
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Li Jun <jun.li@nxp.com>
    Signed-off-by: Felipe Balbi <balbi@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit d92f1821ad6de4ab754ab7bd30cde747fef07a4d
Author: Li Jun <jun.li@nxp.com>
Date:   Tue Jul 28 20:42:40 2020 +0800

    usb: dwc3: core: don't trigger runtime pm when remove driver
    
    commit 266d0493900ac5d6a21cdbe6b1624ed2da94d47a upstream.
    
    No need to trigger runtime pm in driver removal, otherwise if user
    disable auto suspend via sys file, runtime suspend may be entered,
    which will call dwc3_core_exit() again and there will be clock disable
    not balance warning:
    
    [ 2026.820154] xhci-hcd xhci-hcd.0.auto: remove, state 4
    [ 2026.825268] usb usb2: USB disconnect, device number 1
    [ 2026.831017] xhci-hcd xhci-hcd.0.auto: USB bus 2 deregistered
    [ 2026.836806] xhci-hcd xhci-hcd.0.auto: remove, state 4
    [ 2026.842029] usb usb1: USB disconnect, device number 1
    [ 2026.848029] xhci-hcd xhci-hcd.0.auto: USB bus 1 deregistered
    [ 2026.865889] ------------[ cut here ]------------
    [ 2026.870506] usb2_ctrl_root_clk already disabled
    [ 2026.875082] WARNING: CPU: 0 PID: 731 at drivers/clk/clk.c:958
    clk_core_disable+0xa0/0xa8
    [ 2026.883170] Modules linked in: dwc3(-) phy_fsl_imx8mq_usb [last
    unloaded: dwc3]
    [ 2026.890488] CPU: 0 PID: 731 Comm: rmmod Not tainted
    5.8.0-rc7-00280-g9d08cca-dirty #245
    [ 2026.898489] Hardware name: NXP i.MX8MQ EVK (DT)
    [ 2026.903020] pstate: 20000085 (nzCv daIf -PAN -UAO BTYPE=--)
    [ 2026.908594] pc : clk_core_disable+0xa0/0xa8
    [ 2026.912777] lr : clk_core_disable+0xa0/0xa8
    [ 2026.916958] sp : ffff8000121b39a0
    [ 2026.920271] x29: ffff8000121b39a0 x28: ffff0000b11f3700
    [ 2026.925583] x27: 0000000000000000 x26: ffff0000b539c700
    [ 2026.930895] x25: 000001d7e44e1232 x24: ffff0000b76fa800
    [ 2026.936208] x23: ffff0000b76fa6f8 x22: ffff800008d01040
    [ 2026.941520] x21: ffff0000b539ce00 x20: ffff0000b7105000
    [ 2026.946832] x19: ffff0000b7105000 x18: 0000000000000010
    [ 2026.952144] x17: 0000000000000001 x16: 0000000000000000
    [ 2026.957456] x15: ffff0000b11f3b70 x14: ffffffffffffffff
    [ 2026.962768] x13: ffff8000921b36f7 x12: ffff8000121b36ff
    [ 2026.968080] x11: ffff8000119e1000 x10: ffff800011bf26d0
    [ 2026.973392] x9 : 0000000000000000 x8 : ffff800011bf3000
    [ 2026.978704] x7 : ffff800010695d68 x6 : 0000000000000252
    [ 2026.984016] x5 : ffff0000bb9881f0 x4 : 0000000000000000
    [ 2026.989327] x3 : 0000000000000027 x2 : 0000000000000023
    [ 2026.994639] x1 : ac2fa471aa7cab00 x0 : 0000000000000000
    [ 2026.999951] Call trace:
    [ 2027.002401]  clk_core_disable+0xa0/0xa8
    [ 2027.006238]  clk_core_disable_lock+0x20/0x38
    [ 2027.010508]  clk_disable+0x1c/0x28
    [ 2027.013911]  clk_bulk_disable+0x34/0x50
    [ 2027.017758]  dwc3_core_exit+0xec/0x110 [dwc3]
    [ 2027.022122]  dwc3_suspend_common+0x84/0x188 [dwc3]
    [ 2027.026919]  dwc3_runtime_suspend+0x74/0x9c [dwc3]
    [ 2027.031712]  pm_generic_runtime_suspend+0x28/0x40
    [ 2027.036419]  genpd_runtime_suspend+0xa0/0x258
    [ 2027.040777]  __rpm_callback+0x88/0x140
    [ 2027.044526]  rpm_callback+0x20/0x80
    [ 2027.048015]  rpm_suspend+0xd0/0x418
    [ 2027.051503]  __pm_runtime_suspend+0x58/0xa0
    [ 2027.055693]  dwc3_runtime_idle+0x7c/0x90 [dwc3]
    [ 2027.060224]  __rpm_callback+0x88/0x140
    [ 2027.063973]  rpm_idle+0x78/0x150
    [ 2027.067201]  __pm_runtime_idle+0x58/0xa0
    [ 2027.071130]  dwc3_remove+0x64/0xc0 [dwc3]
    [ 2027.075140]  platform_drv_remove+0x28/0x48
    [ 2027.079239]  device_release_driver_internal+0xf4/0x1c0
    [ 2027.084377]  driver_detach+0x4c/0xd8
    [ 2027.087954]  bus_remove_driver+0x54/0xa8
    [ 2027.091877]  driver_unregister+0x2c/0x58
    [ 2027.095799]  platform_driver_unregister+0x10/0x18
    [ 2027.100509]  dwc3_driver_exit+0x14/0x1408 [dwc3]
    [ 2027.105129]  __arm64_sys_delete_module+0x178/0x218
    [ 2027.109922]  el0_svc_common.constprop.0+0x68/0x160
    [ 2027.114714]  do_el0_svc+0x20/0x80
    [ 2027.118031]  el0_sync_handler+0x88/0x190
    [ 2027.121953]  el0_sync+0x140/0x180
    [ 2027.125267] ---[ end trace 027f4f8189958f1f ]---
    [ 2027.129976] ------------[ cut here ]------------
    
    Fixes: fc8bb91bc83e ("usb: dwc3: implement runtime PM")
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Li Jun <jun.li@nxp.com>
    Signed-off-by: Felipe Balbi <balbi@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 70ed5fdd90ffd91385cd5bba1ab4626c00a2feb3
Author: Grygorii Strashko <grygorii.strashko@ti.com>
Date:   Fri Sep 18 19:55:18 2020 +0300

    PM: runtime: Fix timer_expires data type on 32-bit arches
    
    commit 6b61d49a55796dbbc479eeb4465e59fd656c719c upstream.
    
    Commit 8234f6734c5d ("PM-runtime: Switch autosuspend over to using
    hrtimers") switched PM runtime autosuspend to use hrtimers and all
    related time accounting in ns, but missed to update the timer_expires
    data type in struct dev_pm_info to u64.
    
    This causes the timer_expires value to be truncated on 32-bit
    architectures when assignment is done from u64 values:
    
    rpm_suspend()
    |- dev->power.timer_expires = expires;
    
    Fix it by changing the timer_expires type to u64.
    
    Fixes: 8234f6734c5d ("PM-runtime: Switch autosuspend over to using hrtimers")
    Signed-off-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Acked-by: Vincent Guittot <vincent.guittot@linaro.org>
    Cc: 5.0+ <stable@vger.kernel.org> # 5.0+
    [ rjw: Subject and changelog edits ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit f6b94060a123b3e59f90147a26e727af38e85bd1
Author: Grygorii Strashko <grygorii.strashko@ti.com>
Date:   Fri Sep 18 19:55:18 2020 +0300

    PM: runtime: Fix timer_expires data type on 32-bit arches
    
    commit 6b61d49a55796dbbc479eeb4465e59fd656c719c upstream.
    
    Commit 8234f6734c5d ("PM-runtime: Switch autosuspend over to using
    hrtimers") switched PM runtime autosuspend to use hrtimers and all
    related time accounting in ns, but missed to update the timer_expires
    data type in struct dev_pm_info to u64.
    
    This causes the timer_expires value to be truncated on 32-bit
    architectures when assignment is done from u64 values:
    
    rpm_suspend()
    |- dev->power.timer_expires = expires;
    
    Fix it by changing the timer_expires type to u64.
    
    Fixes: 8234f6734c5d ("PM-runtime: Switch autosuspend over to using hrtimers")
    Signed-off-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Acked-by: Vincent Guittot <vincent.guittot@linaro.org>
    Cc: 5.0+ <stable@vger.kernel.org> # 5.0+
    [ rjw: Subject and changelog edits ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 9f531583c1f06c1b374e79654be65a511e669a25
Author: Grygorii Strashko <grygorii.strashko@ti.com>
Date:   Fri Sep 18 19:55:18 2020 +0300

    PM: runtime: Fix timer_expires data type on 32-bit arches
    
    commit 6b61d49a55796dbbc479eeb4465e59fd656c719c upstream.
    
    Commit 8234f6734c5d ("PM-runtime: Switch autosuspend over to using
    hrtimers") switched PM runtime autosuspend to use hrtimers and all
    related time accounting in ns, but missed to update the timer_expires
    data type in struct dev_pm_info to u64.
    
    This causes the timer_expires value to be truncated on 32-bit
    architectures when assignment is done from u64 values:
    
    rpm_suspend()
    |- dev->power.timer_expires = expires;
    
    Fix it by changing the timer_expires type to u64.
    
    Fixes: 8234f6734c5d ("PM-runtime: Switch autosuspend over to using hrtimers")
    Signed-off-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Acked-by: Vincent Guittot <vincent.guittot@linaro.org>
    Cc: 5.0+ <stable@vger.kernel.org> # 5.0+
    [ rjw: Subject and changelog edits ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 93c9fce7d5f3db87f67718a2e5cf09b02c2c2c6a
Author: Jon Derrick <jonathan.derrick@intel.com>
Date:   Thu Aug 6 17:00:17 2020 -0400

    PCI: vmd: Update VMD PM to correctly use generic PCI PM
    
    The pci_save_state() call in vmd_suspend() can be performed by
    pci_pm_suspend_irq(). This also allows VMD to benefit from the call into
    pci_prepare_to_sleep().
    
    The pci_restore_state() call in vmd_resume() was restoring state after
    pci_pm_resume()::pci_restore_standard_config() had already restored state.
    It's also been suspected that the config state should have been restored
    before re-requesting IRQs instead of afterwards.
    
    Remove the pci_save_state()/pci_restore_state() calls in
    vmd_suspend()/vmd_resume() to allow proper flow through generic PCI core
    Power Management code.
    
    Link: https://lore.kernel.org/r/20200806210017.5654-1-jonathan.derrick@intel.com
    Signed-off-by: Jon Derrick <jonathan.derrick@intel.com>
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Kai-Heng Feng <kai.heng.feng@canonical.com>
    Cc: You-Sheng Yang <vicamo.yang@canonical.com>

commit 266d0493900ac5d6a21cdbe6b1624ed2da94d47a
Author: Li Jun <jun.li@nxp.com>
Date:   Tue Jul 28 20:42:40 2020 +0800

    usb: dwc3: core: don't trigger runtime pm when remove driver
    
    No need to trigger runtime pm in driver removal, otherwise if user
    disable auto suspend via sys file, runtime suspend may be entered,
    which will call dwc3_core_exit() again and there will be clock disable
    not balance warning:
    
    [ 2026.820154] xhci-hcd xhci-hcd.0.auto: remove, state 4
    [ 2026.825268] usb usb2: USB disconnect, device number 1
    [ 2026.831017] xhci-hcd xhci-hcd.0.auto: USB bus 2 deregistered
    [ 2026.836806] xhci-hcd xhci-hcd.0.auto: remove, state 4
    [ 2026.842029] usb usb1: USB disconnect, device number 1
    [ 2026.848029] xhci-hcd xhci-hcd.0.auto: USB bus 1 deregistered
    [ 2026.865889] ------------[ cut here ]------------
    [ 2026.870506] usb2_ctrl_root_clk already disabled
    [ 2026.875082] WARNING: CPU: 0 PID: 731 at drivers/clk/clk.c:958
    clk_core_disable+0xa0/0xa8
    [ 2026.883170] Modules linked in: dwc3(-) phy_fsl_imx8mq_usb [last
    unloaded: dwc3]
    [ 2026.890488] CPU: 0 PID: 731 Comm: rmmod Not tainted
    5.8.0-rc7-00280-g9d08cca-dirty #245
    [ 2026.898489] Hardware name: NXP i.MX8MQ EVK (DT)
    [ 2026.903020] pstate: 20000085 (nzCv daIf -PAN -UAO BTYPE=--)
    [ 2026.908594] pc : clk_core_disable+0xa0/0xa8
    [ 2026.912777] lr : clk_core_disable+0xa0/0xa8
    [ 2026.916958] sp : ffff8000121b39a0
    [ 2026.920271] x29: ffff8000121b39a0 x28: ffff0000b11f3700
    [ 2026.925583] x27: 0000000000000000 x26: ffff0000b539c700
    [ 2026.930895] x25: 000001d7e44e1232 x24: ffff0000b76fa800
    [ 2026.936208] x23: ffff0000b76fa6f8 x22: ffff800008d01040
    [ 2026.941520] x21: ffff0000b539ce00 x20: ffff0000b7105000
    [ 2026.946832] x19: ffff0000b7105000 x18: 0000000000000010
    [ 2026.952144] x17: 0000000000000001 x16: 0000000000000000
    [ 2026.957456] x15: ffff0000b11f3b70 x14: ffffffffffffffff
    [ 2026.962768] x13: ffff8000921b36f7 x12: ffff8000121b36ff
    [ 2026.968080] x11: ffff8000119e1000 x10: ffff800011bf26d0
    [ 2026.973392] x9 : 0000000000000000 x8 : ffff800011bf3000
    [ 2026.978704] x7 : ffff800010695d68 x6 : 0000000000000252
    [ 2026.984016] x5 : ffff0000bb9881f0 x4 : 0000000000000000
    [ 2026.989327] x3 : 0000000000000027 x2 : 0000000000000023
    [ 2026.994639] x1 : ac2fa471aa7cab00 x0 : 0000000000000000
    [ 2026.999951] Call trace:
    [ 2027.002401]  clk_core_disable+0xa0/0xa8
    [ 2027.006238]  clk_core_disable_lock+0x20/0x38
    [ 2027.010508]  clk_disable+0x1c/0x28
    [ 2027.013911]  clk_bulk_disable+0x34/0x50
    [ 2027.017758]  dwc3_core_exit+0xec/0x110 [dwc3]
    [ 2027.022122]  dwc3_suspend_common+0x84/0x188 [dwc3]
    [ 2027.026919]  dwc3_runtime_suspend+0x74/0x9c [dwc3]
    [ 2027.031712]  pm_generic_runtime_suspend+0x28/0x40
    [ 2027.036419]  genpd_runtime_suspend+0xa0/0x258
    [ 2027.040777]  __rpm_callback+0x88/0x140
    [ 2027.044526]  rpm_callback+0x20/0x80
    [ 2027.048015]  rpm_suspend+0xd0/0x418
    [ 2027.051503]  __pm_runtime_suspend+0x58/0xa0
    [ 2027.055693]  dwc3_runtime_idle+0x7c/0x90 [dwc3]
    [ 2027.060224]  __rpm_callback+0x88/0x140
    [ 2027.063973]  rpm_idle+0x78/0x150
    [ 2027.067201]  __pm_runtime_idle+0x58/0xa0
    [ 2027.071130]  dwc3_remove+0x64/0xc0 [dwc3]
    [ 2027.075140]  platform_drv_remove+0x28/0x48
    [ 2027.079239]  device_release_driver_internal+0xf4/0x1c0
    [ 2027.084377]  driver_detach+0x4c/0xd8
    [ 2027.087954]  bus_remove_driver+0x54/0xa8
    [ 2027.091877]  driver_unregister+0x2c/0x58
    [ 2027.095799]  platform_driver_unregister+0x10/0x18
    [ 2027.100509]  dwc3_driver_exit+0x14/0x1408 [dwc3]
    [ 2027.105129]  __arm64_sys_delete_module+0x178/0x218
    [ 2027.109922]  el0_svc_common.constprop.0+0x68/0x160
    [ 2027.114714]  do_el0_svc+0x20/0x80
    [ 2027.118031]  el0_sync_handler+0x88/0x190
    [ 2027.121953]  el0_sync+0x140/0x180
    [ 2027.125267] ---[ end trace 027f4f8189958f1f ]---
    [ 2027.129976] ------------[ cut here ]------------
    
    Fixes: fc8bb91bc83e ("usb: dwc3: implement runtime PM")
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Li Jun <jun.li@nxp.com>
    Signed-off-by: Felipe Balbi <balbi@kernel.org>

commit 6b61d49a55796dbbc479eeb4465e59fd656c719c
Author: Grygorii Strashko <grygorii.strashko@ti.com>
Date:   Fri Sep 18 19:55:18 2020 +0300

    PM: runtime: Fix timer_expires data type on 32-bit arches
    
    Commit 8234f6734c5d ("PM-runtime: Switch autosuspend over to using
    hrtimers") switched PM runtime autosuspend to use hrtimers and all
    related time accounting in ns, but missed to update the timer_expires
    data type in struct dev_pm_info to u64.
    
    This causes the timer_expires value to be truncated on 32-bit
    architectures when assignment is done from u64 values:
    
    rpm_suspend()
    |- dev->power.timer_expires = expires;
    
    Fix it by changing the timer_expires type to u64.
    
    Fixes: 8234f6734c5d ("PM-runtime: Switch autosuspend over to using hrtimers")
    Signed-off-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Acked-by: Vincent Guittot <vincent.guittot@linaro.org>
    Cc: 5.0+ <stable@vger.kernel.org> # 5.0+
    [ rjw: Subject and changelog edits ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 46237bf3ee834252edb73cfc48855e99b3bd744b
Author: Zheng Yongjun <zhengyongjun3@huawei.com>
Date:   Wed Sep 23 11:21:40 2020 +0800

    net: microchip: Make `lan743x_pm_suspend` function return right value
    
    drivers/net/ethernet/microchip/lan743x_main.c: In function lan743x_pm_suspend:
    
    `ret` is set but not used. In fact, `pci_prepare_to_sleep` function value should
    be the right value of `lan743x_pm_suspend` function, therefore, fix it.
    
    Signed-off-by: Zheng Yongjun <zhengyongjun3@huawei.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 816adf48d9fffde87f769812f0f4a4d81b79d026
Author: Dan Robertson <dan@dlrobertson.com>
Date:   Mon Jul 13 12:05:22 2020 -0400

    usb: dwc3: meson-g12a: fix shared reset control use
    
    [ Upstream commit 7a410953d1fb4dbe91ffcfdee9cbbf889d19b0d7 ]
    
    The reset is a shared reset line, but reset_control_reset is still used
    and reset_control_deassert is not guaranteed to have been called before
    the first reset_control_assert call. When suspending the following
    warning may be seen:
    
    WARNING: CPU: 1 PID: 5530 at drivers/reset/core.c:355 reset_control_assert+0x184/0x19c
    Hardware name: Hardkernel ODROID-N2 (DT)
    [..]
    pc : reset_control_assert+0x184/0x19c
    lr : dwc3_meson_g12a_suspend+0x68/0x7c
    [..]
    Call trace:
     reset_control_assert+0x184/0x19c
     dwc3_meson_g12a_suspend+0x68/0x7c
     platform_pm_suspend+0x28/0x54
     __device_suspend+0x590/0xabc
     dpm_suspend+0x104/0x404
     dpm_suspend_start+0x84/0x1bc
     suspend_devices_and_enter+0xc4/0x4fc
     pm_suspend+0x198/0x2d4
    
    Fixes: 6d9fa35a347a87 ("usb: dwc3: meson-g12a: get the reset as shared")
    Signed-off-by: Dan Robertson <dan@dlrobertson.com>
    Signed-off-by: Felipe Balbi <balbi@kernel.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 7a410953d1fb4dbe91ffcfdee9cbbf889d19b0d7
Author: Dan Robertson <dan@dlrobertson.com>
Date:   Mon Jul 13 12:05:22 2020 -0400

    usb: dwc3: meson-g12a: fix shared reset control use
    
    The reset is a shared reset line, but reset_control_reset is still used
    and reset_control_deassert is not guaranteed to have been called before
    the first reset_control_assert call. When suspending the following
    warning may be seen:
    
    WARNING: CPU: 1 PID: 5530 at drivers/reset/core.c:355 reset_control_assert+0x184/0x19c
    Hardware name: Hardkernel ODROID-N2 (DT)
    [..]
    pc : reset_control_assert+0x184/0x19c
    lr : dwc3_meson_g12a_suspend+0x68/0x7c
    [..]
    Call trace:
     reset_control_assert+0x184/0x19c
     dwc3_meson_g12a_suspend+0x68/0x7c
     platform_pm_suspend+0x28/0x54
     __device_suspend+0x590/0xabc
     dpm_suspend+0x104/0x404
     dpm_suspend_start+0x84/0x1bc
     suspend_devices_and_enter+0xc4/0x4fc
     pm_suspend+0x198/0x2d4
    
    Fixes: 6d9fa35a347a87 ("usb: dwc3: meson-g12a: get the reset as shared")
    Signed-off-by: Dan Robertson <dan@dlrobertson.com>
    Signed-off-by: Felipe Balbi <balbi@kernel.org>

commit 898503ee0b9b27c214ad0e584a1fcfec24e71ef0
Author: Lee Jones <lee.jones@linaro.org>
Date:   Mon Jul 13 15:49:20 2020 +0100

    pinctrl: pinctrl-at91-pio4: PM related attribute descriptions
    
    Fixes the following W=1 kernel build warning(s):
    
     drivers/pinctrl/pinctrl-at91-pio4.c:132: warning: Function parameter or member 'pm_wakeup_sources' not described in 'atmel_pioctrl'
     drivers/pinctrl/pinctrl-at91-pio4.c:132: warning: Function parameter or member 'pm_suspend_backup' not described in 'atmel_pioctrl'
    
    Signed-off-by: Lee Jones <lee.jones@linaro.org>
    Cc: Ludovic Desroches <ludovic.desroches@microchip.com>
    Cc: Nicolas Ferre <nicolas.ferre@microchip.com>
    Cc: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Link: https://lore.kernel.org/r/20200713144930.1034632-16-lee.jones@linaro.org
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

commit e5e2b5087d32e0737a919bfb232c49ecd627420c
Author: Kai-Heng Feng <kai.heng.feng@canonical.com>
Date:   Wed Jun 24 16:59:49 2020 +0300

    xhci: Poll for U0 after disabling USB2 LPM
    
    commit b3d71abd135e6919ca0b6cab463738472653ddfb upstream.
    
    USB2 devices with LPM enabled may interrupt the system suspend:
    [  932.510475] usb 1-7: usb suspend, wakeup 0
    [  932.510549] hub 1-0:1.0: hub_suspend
    [  932.510581] usb usb1: bus suspend, wakeup 0
    [  932.510590] xhci_hcd 0000:00:14.0: port 9 not suspended
    [  932.510593] xhci_hcd 0000:00:14.0: port 8 not suspended
    ..
    [  932.520323] xhci_hcd 0000:00:14.0: Port change event, 1-7, id 7, portsc: 0x400e03
    ..
    [  932.591405] PM: pci_pm_suspend(): hcd_pci_suspend+0x0/0x30 returns -16
    [  932.591414] PM: dpm_run_callback(): pci_pm_suspend+0x0/0x160 returns -16
    [  932.591418] PM: Device 0000:00:14.0 failed to suspend async: error -16
    
    During system suspend, USB core will let HC suspends the device if it
    doesn't have remote wakeup enabled and doesn't have any children.
    However, from the log above we can see that the usb 1-7 doesn't get bus
    suspended due to not in U0. After a while the port finished U2 -> U0
    transition, interrupts the suspend process.
    
    The observation is that after disabling LPM, port doesn't transit to U0
    immediately and can linger in U2. xHCI spec 4.23.5.2 states that the
    maximum exit latency for USB2 LPM should be BESL + 10us. The BESL for
    the affected device is advertised as 400us, which is still not enough
    based on my testing result.
    
    So let's use the maximum permitted latency, 10000, to poll for U0
    status to solve the issue.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Kai-Heng Feng <kai.heng.feng@canonical.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Link: https://lore.kernel.org/r/20200624135949.22611-6-mathias.nyman@linux.intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 75603a3112664cb1f6b1508e2b489f16863bf153
Author: Nathan Chancellor <natechancellor@gmail.com>
Date:   Tue Jun 30 14:00:34 2020 -0700

    pcnet32: Mark PM functions as __maybe_unused
    
    In certain configurations without power management support, the
    following warnings happen:
    
    ../drivers/net/ethernet/amd/pcnet32.c:2928:12: warning:
    'pcnet32_pm_resume' defined but not used [-Wunused-function]
     2928 | static int pcnet32_pm_resume(struct device *device_d)
          |            ^~~~~~~~~~~~~~~~~
    ../drivers/net/ethernet/amd/pcnet32.c:2916:12: warning:
    'pcnet32_pm_suspend' defined but not used [-Wunused-function]
     2916 | static int pcnet32_pm_suspend(struct device *device_d)
          |            ^~~~~~~~~~~~~~~~~~
    
    Mark these functions as __maybe_unused to make it clear to the compiler
    that this is going to happen based on the configuration, which is the
    standard for these types of functions.
    
    Fixes: a86688fbef1b ("pcnet32: Convert to generic power management")
    Signed-off-by: Nathan Chancellor <natechancellor@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit dfa2cacd9f4811982d9d450fb0bf07526f56e9a2
Author: Kai-Heng Feng <kai.heng.feng@canonical.com>
Date:   Wed Jun 24 16:59:49 2020 +0300

    xhci: Poll for U0 after disabling USB2 LPM
    
    [ Upstream commit b3d71abd135e6919ca0b6cab463738472653ddfb ]
    
    USB2 devices with LPM enabled may interrupt the system suspend:
    [  932.510475] usb 1-7: usb suspend, wakeup 0
    [  932.510549] hub 1-0:1.0: hub_suspend
    [  932.510581] usb usb1: bus suspend, wakeup 0
    [  932.510590] xhci_hcd 0000:00:14.0: port 9 not suspended
    [  932.510593] xhci_hcd 0000:00:14.0: port 8 not suspended
    ..
    [  932.520323] xhci_hcd 0000:00:14.0: Port change event, 1-7, id 7, portsc: 0x400e03
    ..
    [  932.591405] PM: pci_pm_suspend(): hcd_pci_suspend+0x0/0x30 returns -16
    [  932.591414] PM: dpm_run_callback(): pci_pm_suspend+0x0/0x160 returns -16
    [  932.591418] PM: Device 0000:00:14.0 failed to suspend async: error -16
    
    During system suspend, USB core will let HC suspends the device if it
    doesn't have remote wakeup enabled and doesn't have any children.
    However, from the log above we can see that the usb 1-7 doesn't get bus
    suspended due to not in U0. After a while the port finished U2 -> U0
    transition, interrupts the suspend process.
    
    The observation is that after disabling LPM, port doesn't transit to U0
    immediately and can linger in U2. xHCI spec 4.23.5.2 states that the
    maximum exit latency for USB2 LPM should be BESL + 10us. The BESL for
    the affected device is advertised as 400us, which is still not enough
    based on my testing result.
    
    So let's use the maximum permitted latency, 10000, to poll for U0
    status to solve the issue.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Kai-Heng Feng <kai.heng.feng@canonical.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Link: https://lore.kernel.org/r/20200624135949.22611-6-mathias.nyman@linux.intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 2b4f83cca72c34a1694a0e55193874728c30041e
Author: Kai-Heng Feng <kai.heng.feng@canonical.com>
Date:   Wed Jun 24 16:59:49 2020 +0300

    xhci: Poll for U0 after disabling USB2 LPM
    
    [ Upstream commit b3d71abd135e6919ca0b6cab463738472653ddfb ]
    
    USB2 devices with LPM enabled may interrupt the system suspend:
    [  932.510475] usb 1-7: usb suspend, wakeup 0
    [  932.510549] hub 1-0:1.0: hub_suspend
    [  932.510581] usb usb1: bus suspend, wakeup 0
    [  932.510590] xhci_hcd 0000:00:14.0: port 9 not suspended
    [  932.510593] xhci_hcd 0000:00:14.0: port 8 not suspended
    ..
    [  932.520323] xhci_hcd 0000:00:14.0: Port change event, 1-7, id 7, portsc: 0x400e03
    ..
    [  932.591405] PM: pci_pm_suspend(): hcd_pci_suspend+0x0/0x30 returns -16
    [  932.591414] PM: dpm_run_callback(): pci_pm_suspend+0x0/0x160 returns -16
    [  932.591418] PM: Device 0000:00:14.0 failed to suspend async: error -16
    
    During system suspend, USB core will let HC suspends the device if it
    doesn't have remote wakeup enabled and doesn't have any children.
    However, from the log above we can see that the usb 1-7 doesn't get bus
    suspended due to not in U0. After a while the port finished U2 -> U0
    transition, interrupts the suspend process.
    
    The observation is that after disabling LPM, port doesn't transit to U0
    immediately and can linger in U2. xHCI spec 4.23.5.2 states that the
    maximum exit latency for USB2 LPM should be BESL + 10us. The BESL for
    the affected device is advertised as 400us, which is still not enough
    based on my testing result.
    
    So let's use the maximum permitted latency, 10000, to poll for U0
    status to solve the issue.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Kai-Heng Feng <kai.heng.feng@canonical.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Link: https://lore.kernel.org/r/20200624135949.22611-6-mathias.nyman@linux.intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit c1e71a51c2f522ebabcc289ea3366a47e48c4a3e
Author: Kai-Heng Feng <kai.heng.feng@canonical.com>
Date:   Wed Jun 24 16:59:49 2020 +0300

    xhci: Poll for U0 after disabling USB2 LPM
    
    commit b3d71abd135e6919ca0b6cab463738472653ddfb upstream.
    
    USB2 devices with LPM enabled may interrupt the system suspend:
    [  932.510475] usb 1-7: usb suspend, wakeup 0
    [  932.510549] hub 1-0:1.0: hub_suspend
    [  932.510581] usb usb1: bus suspend, wakeup 0
    [  932.510590] xhci_hcd 0000:00:14.0: port 9 not suspended
    [  932.510593] xhci_hcd 0000:00:14.0: port 8 not suspended
    ..
    [  932.520323] xhci_hcd 0000:00:14.0: Port change event, 1-7, id 7, portsc: 0x400e03
    ..
    [  932.591405] PM: pci_pm_suspend(): hcd_pci_suspend+0x0/0x30 returns -16
    [  932.591414] PM: dpm_run_callback(): pci_pm_suspend+0x0/0x160 returns -16
    [  932.591418] PM: Device 0000:00:14.0 failed to suspend async: error -16
    
    During system suspend, USB core will let HC suspends the device if it
    doesn't have remote wakeup enabled and doesn't have any children.
    However, from the log above we can see that the usb 1-7 doesn't get bus
    suspended due to not in U0. After a while the port finished U2 -> U0
    transition, interrupts the suspend process.
    
    The observation is that after disabling LPM, port doesn't transit to U0
    immediately and can linger in U2. xHCI spec 4.23.5.2 states that the
    maximum exit latency for USB2 LPM should be BESL + 10us. The BESL for
    the affected device is advertised as 400us, which is still not enough
    based on my testing result.
    
    So let's use the maximum permitted latency, 10000, to poll for U0
    status to solve the issue.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Kai-Heng Feng <kai.heng.feng@canonical.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Link: https://lore.kernel.org/r/20200624135949.22611-6-mathias.nyman@linux.intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit cc32d9df84143ea2e58697e7e31dd70d3e64d32a
Author: Kai-Heng Feng <kai.heng.feng@canonical.com>
Date:   Wed Jun 24 16:59:49 2020 +0300

    xhci: Poll for U0 after disabling USB2 LPM
    
    commit b3d71abd135e6919ca0b6cab463738472653ddfb upstream.
    
    USB2 devices with LPM enabled may interrupt the system suspend:
    [  932.510475] usb 1-7: usb suspend, wakeup 0
    [  932.510549] hub 1-0:1.0: hub_suspend
    [  932.510581] usb usb1: bus suspend, wakeup 0
    [  932.510590] xhci_hcd 0000:00:14.0: port 9 not suspended
    [  932.510593] xhci_hcd 0000:00:14.0: port 8 not suspended
    ..
    [  932.520323] xhci_hcd 0000:00:14.0: Port change event, 1-7, id 7, portsc: 0x400e03
    ..
    [  932.591405] PM: pci_pm_suspend(): hcd_pci_suspend+0x0/0x30 returns -16
    [  932.591414] PM: dpm_run_callback(): pci_pm_suspend+0x0/0x160 returns -16
    [  932.591418] PM: Device 0000:00:14.0 failed to suspend async: error -16
    
    During system suspend, USB core will let HC suspends the device if it
    doesn't have remote wakeup enabled and doesn't have any children.
    However, from the log above we can see that the usb 1-7 doesn't get bus
    suspended due to not in U0. After a while the port finished U2 -> U0
    transition, interrupts the suspend process.
    
    The observation is that after disabling LPM, port doesn't transit to U0
    immediately and can linger in U2. xHCI spec 4.23.5.2 states that the
    maximum exit latency for USB2 LPM should be BESL + 10us. The BESL for
    the affected device is advertised as 400us, which is still not enough
    based on my testing result.
    
    So let's use the maximum permitted latency, 10000, to poll for U0
    status to solve the issue.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Kai-Heng Feng <kai.heng.feng@canonical.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Link: https://lore.kernel.org/r/20200624135949.22611-6-mathias.nyman@linux.intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 09ec04369def1a92755d8dbb981e9f17e5319996
Author: Kai-Heng Feng <kai.heng.feng@canonical.com>
Date:   Wed Jun 24 16:59:49 2020 +0300

    xhci: Poll for U0 after disabling USB2 LPM
    
    [ Upstream commit b3d71abd135e6919ca0b6cab463738472653ddfb ]
    
    USB2 devices with LPM enabled may interrupt the system suspend:
    [  932.510475] usb 1-7: usb suspend, wakeup 0
    [  932.510549] hub 1-0:1.0: hub_suspend
    [  932.510581] usb usb1: bus suspend, wakeup 0
    [  932.510590] xhci_hcd 0000:00:14.0: port 9 not suspended
    [  932.510593] xhci_hcd 0000:00:14.0: port 8 not suspended
    ..
    [  932.520323] xhci_hcd 0000:00:14.0: Port change event, 1-7, id 7, portsc: 0x400e03
    ..
    [  932.591405] PM: pci_pm_suspend(): hcd_pci_suspend+0x0/0x30 returns -16
    [  932.591414] PM: dpm_run_callback(): pci_pm_suspend+0x0/0x160 returns -16
    [  932.591418] PM: Device 0000:00:14.0 failed to suspend async: error -16
    
    During system suspend, USB core will let HC suspends the device if it
    doesn't have remote wakeup enabled and doesn't have any children.
    However, from the log above we can see that the usb 1-7 doesn't get bus
    suspended due to not in U0. After a while the port finished U2 -> U0
    transition, interrupts the suspend process.
    
    The observation is that after disabling LPM, port doesn't transit to U0
    immediately and can linger in U2. xHCI spec 4.23.5.2 states that the
    maximum exit latency for USB2 LPM should be BESL + 10us. The BESL for
    the affected device is advertised as 400us, which is still not enough
    based on my testing result.
    
    So let's use the maximum permitted latency, 10000, to poll for U0
    status to solve the issue.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Kai-Heng Feng <kai.heng.feng@canonical.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Link: https://lore.kernel.org/r/20200624135949.22611-6-mathias.nyman@linux.intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit b3d71abd135e6919ca0b6cab463738472653ddfb
Author: Kai-Heng Feng <kai.heng.feng@canonical.com>
Date:   Wed Jun 24 16:59:49 2020 +0300

    xhci: Poll for U0 after disabling USB2 LPM
    
    USB2 devices with LPM enabled may interrupt the system suspend:
    [  932.510475] usb 1-7: usb suspend, wakeup 0
    [  932.510549] hub 1-0:1.0: hub_suspend
    [  932.510581] usb usb1: bus suspend, wakeup 0
    [  932.510590] xhci_hcd 0000:00:14.0: port 9 not suspended
    [  932.510593] xhci_hcd 0000:00:14.0: port 8 not suspended
    ..
    [  932.520323] xhci_hcd 0000:00:14.0: Port change event, 1-7, id 7, portsc: 0x400e03
    ..
    [  932.591405] PM: pci_pm_suspend(): hcd_pci_suspend+0x0/0x30 returns -16
    [  932.591414] PM: dpm_run_callback(): pci_pm_suspend+0x0/0x160 returns -16
    [  932.591418] PM: Device 0000:00:14.0 failed to suspend async: error -16
    
    During system suspend, USB core will let HC suspends the device if it
    doesn't have remote wakeup enabled and doesn't have any children.
    However, from the log above we can see that the usb 1-7 doesn't get bus
    suspended due to not in U0. After a while the port finished U2 -> U0
    transition, interrupts the suspend process.
    
    The observation is that after disabling LPM, port doesn't transit to U0
    immediately and can linger in U2. xHCI spec 4.23.5.2 states that the
    maximum exit latency for USB2 LPM should be BESL + 10us. The BESL for
    the affected device is advertised as 400us, which is still not enough
    based on my testing result.
    
    So let's use the maximum permitted latency, 10000, to poll for U0
    status to solve the issue.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Kai-Heng Feng <kai.heng.feng@canonical.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Link: https://lore.kernel.org/r/20200624135949.22611-6-mathias.nyman@linux.intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 8f4f1a9b20d7a5c741078d08b6b32aaa323401f1
Author: Bernard Zhao <bernard@vivo.com>
Date:   Tue Apr 28 06:17:47 2020 -0700

    drm/meson: pm resume add return errno branch
    
    [ Upstream commit c54a8f1f329197d83d941ad84c4aa38bf282cbbd ]
    
    pm_resump api did not handle drm_mode_config_helper_resume error.
    This change add handle to return drm_mode_config_helper_resume`s
    error number. This code logic is aligned with api pm_suspend.
    After this change, the code maybe a bit readable.
    
    Signed-off-by: Bernard Zhao <bernard@vivo.com>
    Signed-off-by: Neil Armstrong <narmstrong@baylibre.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200428131747.2099-1-bernard@vivo.com
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 355ba37d756c38962fe9bb616f5f48eb12a7e11e
Merge: a5a82e0a5918 a34024d98eea
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jun 2 13:17:23 2020 -0700

    Merge tag 'pm-5.8-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull power management updates from Rafael Wysocki:
     "These rework the system-wide PM driver flags, make runtime switching
      of cpuidle governors easier, improve the user space hibernation
      interface code, add intel-speed-select interface documentation, add
      more debug messages to the ACPI code handling suspend to idle, update
      the cpufreq core and drivers, fix a minor issue in the cpuidle core
      and update two cpuidle drivers, improve the PM-runtime framework,
      update the Intel RAPL power capping driver, update devfreq core and
      drivers, and clean up the cpupower utility.
    
      Specifics:
    
       - Rework the system-wide PM driver flags to make them easier to
         understand and use and update their documentation (Rafael Wysocki,
         Alan Stern).
    
       - Allow cpuidle governors to be switched at run time regardless of
         the kernel configuration and update the related documentation
         accordingly (Hanjun Guo).
    
       - Improve the resume device handling in the user space hibernarion
         interface code (Domenico Andreoli).
    
       - Document the intel-speed-select sysfs interface (Srinivas
         Pandruvada).
    
       - Make the ACPI code handing suspend to idle print more debug
         messages to help diagnose issues with it (Rafael Wysocki).
    
       - Fix a helper routine in the cpufreq core and correct a typo in the
         struct cpufreq_driver kerneldoc comment (Rafael Wysocki, Wang
         Wenhu).
    
       - Update cpufreq drivers:
    
          - Make the intel_pstate driver start in the passive mode by
            default on systems without HWP (Rafael Wysocki).
    
          - Add i.MX7ULP support to the imx-cpufreq-dt driver and add
            i.MX7ULP to the cpufreq-dt-platdev blacklist (Peng Fan).
    
          - Convert the qoriq cpufreq driver to a platform one, make the
            platform code create a suitable device object for it and add
            platform dependencies to it (Mian Yousaf Kaukab, Geert
            Uytterhoeven).
    
          - Fix wrong compatible binding in the qcom driver (Ansuel Smith).
    
          - Build the omap driver by default for ARCH_OMAP2PLUS (Anders
            Roxell).
    
          - Add r8a7742 SoC support to the dt cpufreq driver (Lad
            Prabhakar).
    
       - Update cpuidle core and drivers:
    
          - Fix three reference count leaks in error code paths in the
            cpuidle core (Qiushi Wu).
    
          - Convert Qualcomm SPM to a generic cpuidle driver (Stephan
            Gerhold).
    
          - Fix up the execution order when entering a domain idle state in
            the PSCI driver (Ulf Hansson).
    
       - Fix a reference counting issue related to clock management and
         clean up two oddities in the PM-runtime framework (Rafael Wysocki,
         Andy Shevchenko).
    
       - Add ElkhartLake support to the Intel RAPL power capping driver and
         remove an unused local MSR definition from it (Jacob Pan, Sumeet
         Pawnikar).
    
       - Update devfreq core and drivers:
    
          - Replace strncpy() with strscpy() in the devfreq core and use
            lockdep asserts instead of manual checks for a locked mutex in
            it (Dmitry Osipenko, Krzysztof Kozlowski).
    
          - Add a generic imx bus scaling driver and make it register an
            interconnect device (Leonard Crestez, Gustavo A. R. Silva).
    
          - Make the cpufreq notifier in the tegra30 driver take boosting
            into account and delete an unuseful error message from that
            driver (Dmitry Osipenko, Markus Elfring).
    
       - Remove unneeded semicolon from the cpupower code (Zou Wei)"
    
    * tag 'pm-5.8-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (51 commits)
      cpuidle: Fix three reference count leaks
      PM: runtime: Replace pm_runtime_callbacks_present()
      PM / devfreq: Use lockdep asserts instead of manual checks for locked mutex
      PM / devfreq: imx-bus: Fix inconsistent IS_ERR and PTR_ERR
      PM / devfreq: Replace strncpy with strscpy
      PM / devfreq: imx: Register interconnect device
      PM / devfreq: Add generic imx bus scaling driver
      PM / devfreq: tegra30: Delete an error message in tegra_devfreq_probe()
      PM / devfreq: tegra30: Make CPUFreq notifier to take into account boosting
      PM: hibernate: Restrict writes to the resume device
      PM: runtime: clk: Fix clk_pm_runtime_get() error path
      cpuidle: Convert Qualcomm SPM driver to a generic CPUidle driver
      ACPI: EC: PM: s2idle: Extend GPE dispatching debug message
      ACPI: PM: s2idle: Print type of wakeup debug messages
      powercap: RAPL: remove unused local MSR define
      PM: runtime: Make clear what we do when conditions are wrong in rpm_suspend()
      Documentation: admin-guide: pm: Document intel-speed-select
      PM: hibernate: Split off snapshot dev option
      PM: hibernate: Incorporate concurrency handling
      Documentation: ABI: make current_governer_ro as a candidate for removal
      ...

commit be6018a44c2479d22fef40eb6f5a3442627b8bcb
Merge: 5fcd73590192 9a7875461fd0 ad1e4f74c072
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Jun 1 15:19:08 2020 +0200

    Merge branches 'pm-core' and 'pm-sleep'
    
    * pm-core:
      PM: runtime: Replace pm_runtime_callbacks_present()
      PM: runtime: clk: Fix clk_pm_runtime_get() error path
      PM: runtime: Make clear what we do when conditions are wrong in rpm_suspend()
    
    * pm-sleep:
      PM: hibernate: Restrict writes to the resume device
      PM: hibernate: Split off snapshot dev option
      PM: hibernate: Incorporate concurrency handling
      PM: sleep: Helpful edits for devices.rst documentation
      Documentation: PM: sleep: Update driver flags documentation
      PM: sleep: core: Rename DPM_FLAG_LEAVE_SUSPENDED
      PM: sleep: core: Rename DPM_FLAG_NEVER_SKIP
      PM: sleep: core: Rename dev_pm_smart_suspend_and_suspended()
      PM: sleep: core: Rename dev_pm_may_skip_resume()
      PM: sleep: core: Rework the power.may_skip_resume handling
      PM: sleep: core: Do not skip callbacks in the resume phase
      PM: sleep: core: Fold functions into their callers
      PM: sleep: core: Simplify the SMART_SUSPEND flag handling

commit 3618bbaaa898cf48e859736120a775fcb56f3838
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Fri May 22 18:09:55 2020 +0300

    PM: runtime: Make clear what we do when conditions are wrong in rpm_suspend()
    
    rpm_suspend() simple bails out when conditions are wrong. But this is not
    immediately obvious from the code.  Make it clear what we do when conditions
    are wrong in rpm_suspend().
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit d614ebdc69e8f0ed977f0f37fea9b1a987356577
Author: Li Jun <jun.li@nxp.com>
Date:   Thu May 14 14:04:32 2020 +0300

    usb: host: xhci-plat: keep runtime active when removing host
    
    commit 1449cb2c2253d37d998c3714aa9b95416d16d379 upstream.
    
    While removing the host (e.g. for USB role switch from host to device),
    if runtime pm is enabled by user, below oops occurs on dwc3 and cdns3
    platforms.
    Keeping the xhci-plat device active during host removal, and disabling
    runtime pm before calling pm_runtime_set_suspended() fixes them.
    
    oops1:
    Unable to handle kernel NULL pointer dereference at virtual address
    0000000000000240
    Internal error: Oops: 96000004 [#1] PREEMPT SMP
    Modules linked in:
    CPU: 0 PID: 5 Comm: kworker/0:0 Not tainted 5.4.3-00107-g64d454a-dirty
    Hardware name: FSL i.MX8MP EVK (DT)
    Workqueue: pm pm_runtime_work
    pstate: 60000005 (nZCv daif -PAN -UAO)
    pc : xhci_suspend+0x34/0x698
    lr : xhci_plat_runtime_suspend+0x2c/0x38
    sp : ffff800011ddbbc0
    Call trace:
     xhci_suspend+0x34/0x698
     xhci_plat_runtime_suspend+0x2c/0x38
     pm_generic_runtime_suspend+0x28/0x40
     __rpm_callback+0xd8/0x138
     rpm_callback+0x24/0x98
     rpm_suspend+0xe0/0x448
     rpm_idle+0x124/0x140
     pm_runtime_work+0xa0/0xf8
     process_one_work+0x1dc/0x370
     worker_thread+0x48/0x468
     kthread+0xf0/0x120
     ret_from_fork+0x10/0x1c
    
    oops2:
    usb 2-1: USB disconnect, device number 2
    xhci-hcd xhci-hcd.1.auto: remove, state 4
    usb usb2: USB disconnect, device number 1
    xhci-hcd xhci-hcd.1.auto: USB bus 2 deregistered
    xhci-hcd xhci-hcd.1.auto: remove, state 4
    usb usb1: USB disconnect, device number 1
    Unable to handle kernel NULL pointer dereference at virtual address
    0000000000000138
    Internal error: Oops: 96000004 [#1] PREEMPT SMP
    Modules linked in:
    CPU: 2 PID: 7 Comm: kworker/u8:0 Not tainted 5.6.0-rc4-next-20200304-03578
    Hardware name: Freescale i.MX8QXP MEK (DT)
    Workqueue: 1-0050 tcpm_state_machine_work
    pstate: 20000005 (nzCv daif -PAN -UAO)
    pc : xhci_free_dev+0x214/0x270
    lr : xhci_plat_runtime_resume+0x78/0x88
    sp : ffff80001006b5b0
    Call trace:
     xhci_free_dev+0x214/0x270
     xhci_plat_runtime_resume+0x78/0x88
     pm_generic_runtime_resume+0x30/0x48
     __rpm_callback+0x90/0x148
     rpm_callback+0x28/0x88
     rpm_resume+0x568/0x758
     rpm_resume+0x260/0x758
     rpm_resume+0x260/0x758
     __pm_runtime_resume+0x40/0x88
     device_release_driver_internal+0xa0/0x1c8
     device_release_driver+0x1c/0x28
     bus_remove_device+0xd4/0x158
     device_del+0x15c/0x3a0
     usb_disable_device+0xb0/0x268
     usb_disconnect+0xcc/0x300
     usb_remove_hcd+0xf4/0x1dc
     xhci_plat_remove+0x78/0xe0
     platform_drv_remove+0x30/0x50
     device_release_driver_internal+0xfc/0x1c8
     device_release_driver+0x1c/0x28
     bus_remove_device+0xd4/0x158
     device_del+0x15c/0x3a0
     platform_device_del.part.0+0x20/0x90
     platform_device_unregister+0x28/0x40
     cdns3_host_exit+0x20/0x40
     cdns3_role_stop+0x60/0x90
     cdns3_role_set+0x64/0xd8
     usb_role_switch_set_role.part.0+0x3c/0x68
     usb_role_switch_set_role+0x20/0x30
     tcpm_mux_set+0x60/0xf8
     tcpm_reset_port+0xa4/0xf0
     tcpm_detach.part.0+0x28/0x50
     tcpm_state_machine_work+0x12ac/0x2360
     process_one_work+0x1c8/0x470
     worker_thread+0x50/0x428
     kthread+0xfc/0x128
     ret_from_fork+0x10/0x18
    Code: c8037c02 35ffffa3 17ffe7c3 f9800011 (c85f7c01)
    ---[ end trace 45b1a173d2679e44 ]---
    
    [minor commit message cleanup  -Mathias]
    Cc: Baolin Wang <baolin.wang@linaro.org>
    Cc: <stable@vger.kernel.org>
    Fixes: b0c69b4bace3 ("usb: host: plat: Enable xHCI plat runtime PM")
    Reviewed-by: Peter Chen <peter.chen@nxp.com>
    Tested-by: Peter Chen <peter.chen@nxp.com>
    Signed-off-by: Li Jun <jun.li@nxp.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Link: https://lore.kernel.org/r/20200514110432.25564-3-mathias.nyman@linux.intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit f1a9bed7969a00fe604530adaa437e61aa06034a
Author: Li Jun <jun.li@nxp.com>
Date:   Thu May 14 14:04:32 2020 +0300

    usb: host: xhci-plat: keep runtime active when removing host
    
    commit 1449cb2c2253d37d998c3714aa9b95416d16d379 upstream.
    
    While removing the host (e.g. for USB role switch from host to device),
    if runtime pm is enabled by user, below oops occurs on dwc3 and cdns3
    platforms.
    Keeping the xhci-plat device active during host removal, and disabling
    runtime pm before calling pm_runtime_set_suspended() fixes them.
    
    oops1:
    Unable to handle kernel NULL pointer dereference at virtual address
    0000000000000240
    Internal error: Oops: 96000004 [#1] PREEMPT SMP
    Modules linked in:
    CPU: 0 PID: 5 Comm: kworker/0:0 Not tainted 5.4.3-00107-g64d454a-dirty
    Hardware name: FSL i.MX8MP EVK (DT)
    Workqueue: pm pm_runtime_work
    pstate: 60000005 (nZCv daif -PAN -UAO)
    pc : xhci_suspend+0x34/0x698
    lr : xhci_plat_runtime_suspend+0x2c/0x38
    sp : ffff800011ddbbc0
    Call trace:
     xhci_suspend+0x34/0x698
     xhci_plat_runtime_suspend+0x2c/0x38
     pm_generic_runtime_suspend+0x28/0x40
     __rpm_callback+0xd8/0x138
     rpm_callback+0x24/0x98
     rpm_suspend+0xe0/0x448
     rpm_idle+0x124/0x140
     pm_runtime_work+0xa0/0xf8
     process_one_work+0x1dc/0x370
     worker_thread+0x48/0x468
     kthread+0xf0/0x120
     ret_from_fork+0x10/0x1c
    
    oops2:
    usb 2-1: USB disconnect, device number 2
    xhci-hcd xhci-hcd.1.auto: remove, state 4
    usb usb2: USB disconnect, device number 1
    xhci-hcd xhci-hcd.1.auto: USB bus 2 deregistered
    xhci-hcd xhci-hcd.1.auto: remove, state 4
    usb usb1: USB disconnect, device number 1
    Unable to handle kernel NULL pointer dereference at virtual address
    0000000000000138
    Internal error: Oops: 96000004 [#1] PREEMPT SMP
    Modules linked in:
    CPU: 2 PID: 7 Comm: kworker/u8:0 Not tainted 5.6.0-rc4-next-20200304-03578
    Hardware name: Freescale i.MX8QXP MEK (DT)
    Workqueue: 1-0050 tcpm_state_machine_work
    pstate: 20000005 (nzCv daif -PAN -UAO)
    pc : xhci_free_dev+0x214/0x270
    lr : xhci_plat_runtime_resume+0x78/0x88
    sp : ffff80001006b5b0
    Call trace:
     xhci_free_dev+0x214/0x270
     xhci_plat_runtime_resume+0x78/0x88
     pm_generic_runtime_resume+0x30/0x48
     __rpm_callback+0x90/0x148
     rpm_callback+0x28/0x88
     rpm_resume+0x568/0x758
     rpm_resume+0x260/0x758
     rpm_resume+0x260/0x758
     __pm_runtime_resume+0x40/0x88
     device_release_driver_internal+0xa0/0x1c8
     device_release_driver+0x1c/0x28
     bus_remove_device+0xd4/0x158
     device_del+0x15c/0x3a0
     usb_disable_device+0xb0/0x268
     usb_disconnect+0xcc/0x300
     usb_remove_hcd+0xf4/0x1dc
     xhci_plat_remove+0x78/0xe0
     platform_drv_remove+0x30/0x50
     device_release_driver_internal+0xfc/0x1c8
     device_release_driver+0x1c/0x28
     bus_remove_device+0xd4/0x158
     device_del+0x15c/0x3a0
     platform_device_del.part.0+0x20/0x90
     platform_device_unregister+0x28/0x40
     cdns3_host_exit+0x20/0x40
     cdns3_role_stop+0x60/0x90
     cdns3_role_set+0x64/0xd8
     usb_role_switch_set_role.part.0+0x3c/0x68
     usb_role_switch_set_role+0x20/0x30
     tcpm_mux_set+0x60/0xf8
     tcpm_reset_port+0xa4/0xf0
     tcpm_detach.part.0+0x28/0x50
     tcpm_state_machine_work+0x12ac/0x2360
     process_one_work+0x1c8/0x470
     worker_thread+0x50/0x428
     kthread+0xfc/0x128
     ret_from_fork+0x10/0x18
    Code: c8037c02 35ffffa3 17ffe7c3 f9800011 (c85f7c01)
    ---[ end trace 45b1a173d2679e44 ]---
    
    [minor commit message cleanup  -Mathias]
    Cc: Baolin Wang <baolin.wang@linaro.org>
    Cc: <stable@vger.kernel.org>
    Fixes: b0c69b4bace3 ("usb: host: plat: Enable xHCI plat runtime PM")
    Reviewed-by: Peter Chen <peter.chen@nxp.com>
    Tested-by: Peter Chen <peter.chen@nxp.com>
    Signed-off-by: Li Jun <jun.li@nxp.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Link: https://lore.kernel.org/r/20200514110432.25564-3-mathias.nyman@linux.intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 8fd38d318e1544ef4ac2dda0bf67c5b6a9cd5b9d
Author: Li Jun <jun.li@nxp.com>
Date:   Thu May 14 14:04:32 2020 +0300

    usb: host: xhci-plat: keep runtime active when removing host
    
    commit 1449cb2c2253d37d998c3714aa9b95416d16d379 upstream.
    
    While removing the host (e.g. for USB role switch from host to device),
    if runtime pm is enabled by user, below oops occurs on dwc3 and cdns3
    platforms.
    Keeping the xhci-plat device active during host removal, and disabling
    runtime pm before calling pm_runtime_set_suspended() fixes them.
    
    oops1:
    Unable to handle kernel NULL pointer dereference at virtual address
    0000000000000240
    Internal error: Oops: 96000004 [#1] PREEMPT SMP
    Modules linked in:
    CPU: 0 PID: 5 Comm: kworker/0:0 Not tainted 5.4.3-00107-g64d454a-dirty
    Hardware name: FSL i.MX8MP EVK (DT)
    Workqueue: pm pm_runtime_work
    pstate: 60000005 (nZCv daif -PAN -UAO)
    pc : xhci_suspend+0x34/0x698
    lr : xhci_plat_runtime_suspend+0x2c/0x38
    sp : ffff800011ddbbc0
    Call trace:
     xhci_suspend+0x34/0x698
     xhci_plat_runtime_suspend+0x2c/0x38
     pm_generic_runtime_suspend+0x28/0x40
     __rpm_callback+0xd8/0x138
     rpm_callback+0x24/0x98
     rpm_suspend+0xe0/0x448
     rpm_idle+0x124/0x140
     pm_runtime_work+0xa0/0xf8
     process_one_work+0x1dc/0x370
     worker_thread+0x48/0x468
     kthread+0xf0/0x120
     ret_from_fork+0x10/0x1c
    
    oops2:
    usb 2-1: USB disconnect, device number 2
    xhci-hcd xhci-hcd.1.auto: remove, state 4
    usb usb2: USB disconnect, device number 1
    xhci-hcd xhci-hcd.1.auto: USB bus 2 deregistered
    xhci-hcd xhci-hcd.1.auto: remove, state 4
    usb usb1: USB disconnect, device number 1
    Unable to handle kernel NULL pointer dereference at virtual address
    0000000000000138
    Internal error: Oops: 96000004 [#1] PREEMPT SMP
    Modules linked in:
    CPU: 2 PID: 7 Comm: kworker/u8:0 Not tainted 5.6.0-rc4-next-20200304-03578
    Hardware name: Freescale i.MX8QXP MEK (DT)
    Workqueue: 1-0050 tcpm_state_machine_work
    pstate: 20000005 (nzCv daif -PAN -UAO)
    pc : xhci_free_dev+0x214/0x270
    lr : xhci_plat_runtime_resume+0x78/0x88
    sp : ffff80001006b5b0
    Call trace:
     xhci_free_dev+0x214/0x270
     xhci_plat_runtime_resume+0x78/0x88
     pm_generic_runtime_resume+0x30/0x48
     __rpm_callback+0x90/0x148
     rpm_callback+0x28/0x88
     rpm_resume+0x568/0x758
     rpm_resume+0x260/0x758
     rpm_resume+0x260/0x758
     __pm_runtime_resume+0x40/0x88
     device_release_driver_internal+0xa0/0x1c8
     device_release_driver+0x1c/0x28
     bus_remove_device+0xd4/0x158
     device_del+0x15c/0x3a0
     usb_disable_device+0xb0/0x268
     usb_disconnect+0xcc/0x300
     usb_remove_hcd+0xf4/0x1dc
     xhci_plat_remove+0x78/0xe0
     platform_drv_remove+0x30/0x50
     device_release_driver_internal+0xfc/0x1c8
     device_release_driver+0x1c/0x28
     bus_remove_device+0xd4/0x158
     device_del+0x15c/0x3a0
     platform_device_del.part.0+0x20/0x90
     platform_device_unregister+0x28/0x40
     cdns3_host_exit+0x20/0x40
     cdns3_role_stop+0x60/0x90
     cdns3_role_set+0x64/0xd8
     usb_role_switch_set_role.part.0+0x3c/0x68
     usb_role_switch_set_role+0x20/0x30
     tcpm_mux_set+0x60/0xf8
     tcpm_reset_port+0xa4/0xf0
     tcpm_detach.part.0+0x28/0x50
     tcpm_state_machine_work+0x12ac/0x2360
     process_one_work+0x1c8/0x470
     worker_thread+0x50/0x428
     kthread+0xfc/0x128
     ret_from_fork+0x10/0x18
    Code: c8037c02 35ffffa3 17ffe7c3 f9800011 (c85f7c01)
    ---[ end trace 45b1a173d2679e44 ]---
    
    [minor commit message cleanup  -Mathias]
    Cc: Baolin Wang <baolin.wang@linaro.org>
    Cc: <stable@vger.kernel.org>
    Fixes: b0c69b4bace3 ("usb: host: plat: Enable xHCI plat runtime PM")
    Reviewed-by: Peter Chen <peter.chen@nxp.com>
    Tested-by: Peter Chen <peter.chen@nxp.com>
    Signed-off-by: Li Jun <jun.li@nxp.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Link: https://lore.kernel.org/r/20200514110432.25564-3-mathias.nyman@linux.intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit c4901f9fcf71faad2f0876d482508dade8488da9
Author: Li Jun <jun.li@nxp.com>
Date:   Thu May 14 14:04:32 2020 +0300

    usb: host: xhci-plat: keep runtime active when removing host
    
    commit 1449cb2c2253d37d998c3714aa9b95416d16d379 upstream.
    
    While removing the host (e.g. for USB role switch from host to device),
    if runtime pm is enabled by user, below oops occurs on dwc3 and cdns3
    platforms.
    Keeping the xhci-plat device active during host removal, and disabling
    runtime pm before calling pm_runtime_set_suspended() fixes them.
    
    oops1:
    Unable to handle kernel NULL pointer dereference at virtual address
    0000000000000240
    Internal error: Oops: 96000004 [#1] PREEMPT SMP
    Modules linked in:
    CPU: 0 PID: 5 Comm: kworker/0:0 Not tainted 5.4.3-00107-g64d454a-dirty
    Hardware name: FSL i.MX8MP EVK (DT)
    Workqueue: pm pm_runtime_work
    pstate: 60000005 (nZCv daif -PAN -UAO)
    pc : xhci_suspend+0x34/0x698
    lr : xhci_plat_runtime_suspend+0x2c/0x38
    sp : ffff800011ddbbc0
    Call trace:
     xhci_suspend+0x34/0x698
     xhci_plat_runtime_suspend+0x2c/0x38
     pm_generic_runtime_suspend+0x28/0x40
     __rpm_callback+0xd8/0x138
     rpm_callback+0x24/0x98
     rpm_suspend+0xe0/0x448
     rpm_idle+0x124/0x140
     pm_runtime_work+0xa0/0xf8
     process_one_work+0x1dc/0x370
     worker_thread+0x48/0x468
     kthread+0xf0/0x120
     ret_from_fork+0x10/0x1c
    
    oops2:
    usb 2-1: USB disconnect, device number 2
    xhci-hcd xhci-hcd.1.auto: remove, state 4
    usb usb2: USB disconnect, device number 1
    xhci-hcd xhci-hcd.1.auto: USB bus 2 deregistered
    xhci-hcd xhci-hcd.1.auto: remove, state 4
    usb usb1: USB disconnect, device number 1
    Unable to handle kernel NULL pointer dereference at virtual address
    0000000000000138
    Internal error: Oops: 96000004 [#1] PREEMPT SMP
    Modules linked in:
    CPU: 2 PID: 7 Comm: kworker/u8:0 Not tainted 5.6.0-rc4-next-20200304-03578
    Hardware name: Freescale i.MX8QXP MEK (DT)
    Workqueue: 1-0050 tcpm_state_machine_work
    pstate: 20000005 (nzCv daif -PAN -UAO)
    pc : xhci_free_dev+0x214/0x270
    lr : xhci_plat_runtime_resume+0x78/0x88
    sp : ffff80001006b5b0
    Call trace:
     xhci_free_dev+0x214/0x270
     xhci_plat_runtime_resume+0x78/0x88
     pm_generic_runtime_resume+0x30/0x48
     __rpm_callback+0x90/0x148
     rpm_callback+0x28/0x88
     rpm_resume+0x568/0x758
     rpm_resume+0x260/0x758
     rpm_resume+0x260/0x758
     __pm_runtime_resume+0x40/0x88
     device_release_driver_internal+0xa0/0x1c8
     device_release_driver+0x1c/0x28
     bus_remove_device+0xd4/0x158
     device_del+0x15c/0x3a0
     usb_disable_device+0xb0/0x268
     usb_disconnect+0xcc/0x300
     usb_remove_hcd+0xf4/0x1dc
     xhci_plat_remove+0x78/0xe0
     platform_drv_remove+0x30/0x50
     device_release_driver_internal+0xfc/0x1c8
     device_release_driver+0x1c/0x28
     bus_remove_device+0xd4/0x158
     device_del+0x15c/0x3a0
     platform_device_del.part.0+0x20/0x90
     platform_device_unregister+0x28/0x40
     cdns3_host_exit+0x20/0x40
     cdns3_role_stop+0x60/0x90
     cdns3_role_set+0x64/0xd8
     usb_role_switch_set_role.part.0+0x3c/0x68
     usb_role_switch_set_role+0x20/0x30
     tcpm_mux_set+0x60/0xf8
     tcpm_reset_port+0xa4/0xf0
     tcpm_detach.part.0+0x28/0x50
     tcpm_state_machine_work+0x12ac/0x2360
     process_one_work+0x1c8/0x470
     worker_thread+0x50/0x428
     kthread+0xfc/0x128
     ret_from_fork+0x10/0x18
    Code: c8037c02 35ffffa3 17ffe7c3 f9800011 (c85f7c01)
    ---[ end trace 45b1a173d2679e44 ]---
    
    [minor commit message cleanup  -Mathias]
    Cc: Baolin Wang <baolin.wang@linaro.org>
    Cc: <stable@vger.kernel.org>
    Fixes: b0c69b4bace3 ("usb: host: plat: Enable xHCI plat runtime PM")
    Reviewed-by: Peter Chen <peter.chen@nxp.com>
    Tested-by: Peter Chen <peter.chen@nxp.com>
    Signed-off-by: Li Jun <jun.li@nxp.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Link: https://lore.kernel.org/r/20200514110432.25564-3-mathias.nyman@linux.intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 1449cb2c2253d37d998c3714aa9b95416d16d379
Author: Li Jun <jun.li@nxp.com>
Date:   Thu May 14 14:04:32 2020 +0300

    usb: host: xhci-plat: keep runtime active when removing host
    
    While removing the host (e.g. for USB role switch from host to device),
    if runtime pm is enabled by user, below oops occurs on dwc3 and cdns3
    platforms.
    Keeping the xhci-plat device active during host removal, and disabling
    runtime pm before calling pm_runtime_set_suspended() fixes them.
    
    oops1:
    Unable to handle kernel NULL pointer dereference at virtual address
    0000000000000240
    Internal error: Oops: 96000004 [#1] PREEMPT SMP
    Modules linked in:
    CPU: 0 PID: 5 Comm: kworker/0:0 Not tainted 5.4.3-00107-g64d454a-dirty
    Hardware name: FSL i.MX8MP EVK (DT)
    Workqueue: pm pm_runtime_work
    pstate: 60000005 (nZCv daif -PAN -UAO)
    pc : xhci_suspend+0x34/0x698
    lr : xhci_plat_runtime_suspend+0x2c/0x38
    sp : ffff800011ddbbc0
    Call trace:
     xhci_suspend+0x34/0x698
     xhci_plat_runtime_suspend+0x2c/0x38
     pm_generic_runtime_suspend+0x28/0x40
     __rpm_callback+0xd8/0x138
     rpm_callback+0x24/0x98
     rpm_suspend+0xe0/0x448
     rpm_idle+0x124/0x140
     pm_runtime_work+0xa0/0xf8
     process_one_work+0x1dc/0x370
     worker_thread+0x48/0x468
     kthread+0xf0/0x120
     ret_from_fork+0x10/0x1c
    
    oops2:
    usb 2-1: USB disconnect, device number 2
    xhci-hcd xhci-hcd.1.auto: remove, state 4
    usb usb2: USB disconnect, device number 1
    xhci-hcd xhci-hcd.1.auto: USB bus 2 deregistered
    xhci-hcd xhci-hcd.1.auto: remove, state 4
    usb usb1: USB disconnect, device number 1
    Unable to handle kernel NULL pointer dereference at virtual address
    0000000000000138
    Internal error: Oops: 96000004 [#1] PREEMPT SMP
    Modules linked in:
    CPU: 2 PID: 7 Comm: kworker/u8:0 Not tainted 5.6.0-rc4-next-20200304-03578
    Hardware name: Freescale i.MX8QXP MEK (DT)
    Workqueue: 1-0050 tcpm_state_machine_work
    pstate: 20000005 (nzCv daif -PAN -UAO)
    pc : xhci_free_dev+0x214/0x270
    lr : xhci_plat_runtime_resume+0x78/0x88
    sp : ffff80001006b5b0
    Call trace:
     xhci_free_dev+0x214/0x270
     xhci_plat_runtime_resume+0x78/0x88
     pm_generic_runtime_resume+0x30/0x48
     __rpm_callback+0x90/0x148
     rpm_callback+0x28/0x88
     rpm_resume+0x568/0x758
     rpm_resume+0x260/0x758
     rpm_resume+0x260/0x758
     __pm_runtime_resume+0x40/0x88
     device_release_driver_internal+0xa0/0x1c8
     device_release_driver+0x1c/0x28
     bus_remove_device+0xd4/0x158
     device_del+0x15c/0x3a0
     usb_disable_device+0xb0/0x268
     usb_disconnect+0xcc/0x300
     usb_remove_hcd+0xf4/0x1dc
     xhci_plat_remove+0x78/0xe0
     platform_drv_remove+0x30/0x50
     device_release_driver_internal+0xfc/0x1c8
     device_release_driver+0x1c/0x28
     bus_remove_device+0xd4/0x158
     device_del+0x15c/0x3a0
     platform_device_del.part.0+0x20/0x90
     platform_device_unregister+0x28/0x40
     cdns3_host_exit+0x20/0x40
     cdns3_role_stop+0x60/0x90
     cdns3_role_set+0x64/0xd8
     usb_role_switch_set_role.part.0+0x3c/0x68
     usb_role_switch_set_role+0x20/0x30
     tcpm_mux_set+0x60/0xf8
     tcpm_reset_port+0xa4/0xf0
     tcpm_detach.part.0+0x28/0x50
     tcpm_state_machine_work+0x12ac/0x2360
     process_one_work+0x1c8/0x470
     worker_thread+0x50/0x428
     kthread+0xfc/0x128
     ret_from_fork+0x10/0x18
    Code: c8037c02 35ffffa3 17ffe7c3 f9800011 (c85f7c01)
    ---[ end trace 45b1a173d2679e44 ]---
    
    [minor commit message cleanup  -Mathias]
    Cc: Baolin Wang <baolin.wang@linaro.org>
    Cc: <stable@vger.kernel.org>
    Fixes: b0c69b4bace3 ("usb: host: plat: Enable xHCI plat runtime PM")
    Reviewed-by: Peter Chen <peter.chen@nxp.com>
    Tested-by: Peter Chen <peter.chen@nxp.com>
    Signed-off-by: Li Jun <jun.li@nxp.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Link: https://lore.kernel.org/r/20200514110432.25564-3-mathias.nyman@linux.intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit c54a8f1f329197d83d941ad84c4aa38bf282cbbd
Author: Bernard Zhao <bernard@vivo.com>
Date:   Tue Apr 28 06:17:47 2020 -0700

    drm/meson: pm resume add return errno branch
    
    pm_resump api did not handle drm_mode_config_helper_resume error.
    This change add handle to return drm_mode_config_helper_resume`s
    error number. This code logic is aligned with api pm_suspend.
    After this change, the code maybe a bit readable.
    
    Signed-off-by: Bernard Zhao <bernard@vivo.com>
    Signed-off-by: Neil Armstrong <narmstrong@baylibre.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200428131747.2099-1-bernard@vivo.com

commit fb6823a6f9801dbe86b6551103f477dd3c5d115a
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed May 13 08:56:26 2020 -0700

    ARM: dts: Fix wrong mdio clock for dm814x
    
    Recent PTP-specific cpsw driver changes started exposing an issue on at
    at least j5eco-evm:
    
    Unhandled fault: external abort on non-linefetch (0x1008) at 0xf0169004
    ...
    (davinci_mdio_runtime_suspend) from [<c063f2a4>] (__rpm_callback+0x84/0x154)
    (__rpm_callback) from [<c063f394>] (rpm_callback+0x20/0x80)
    (rpm_callback) from [<c063f4f0>] (rpm_suspend+0xfc/0x6ac)
    (rpm_suspend) from [<c0640af0>] (pm_runtime_work+0x88/0xa4)
    (pm_runtime_work) from [<c0155338>] (process_one_work+0x228/0x568)
    ...
    
    Let's fix the issue by using the correct mdio clock as suggested by
    Grygorii Strashko <grygorii.strashko@ti.com>.
    
    The DM814_ETHERNET_CPGMAC0_CLKCTRL clock is the interconnect target module
    clock and managed by ti-sysc.
    
    Fixes: 6398f3478e45 ("ARM: dts: Configure interconnect target module for dm814x cpsw")
    Cc: Grygorii Strashko <grygorii.strashko@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

commit 2852b559afdfe9f29ec36a73b4410440aa749caa
Author: Marek Szyprowski <m.szyprowski@samsung.com>
Date:   Tue Nov 12 11:47:34 2019 +0100

    PM / devfreq: Add missing locking while setting suspend_freq
    
    commit e1e047ace8cef6d143f38c7d769753f133becbe6 upstream.
    
    Commit 2abb0d5268ae ("PM / devfreq: Lock devfreq in trans_stat_show")
    revealed a missing locking while calling devfreq_update_status() function
    during suspend/resume cycle.
    
    Code analysis revealed that devfreq_set_target() function was called
    without needed locks held for setting device specific suspend_freq if such
    has been defined. This patch fixes that by adding the needed locking, what
    fixes following kernel warning on Exynos4412-based OdroidU3 board during
    system suspend:
    
    PM: suspend entry (deep)
    Filesystems sync: 0.002 seconds
    Freezing user space processes ... (elapsed 0.001 seconds) done.
    OOM killer disabled.
    Freezing remaining freezable tasks ... (elapsed 0.001 seconds) done.
    ------------[ cut here ]------------
    WARNING: CPU: 2 PID: 1385 at drivers/devfreq/devfreq.c:204 devfreq_update_status+0xc0/0x188
    Modules linked in:
    CPU: 2 PID: 1385 Comm: rtcwake Not tainted 5.4.0-rc6-next-20191111 #6848
    Hardware name: SAMSUNG EXYNOS (Flattened Device Tree)
    [<c0112588>] (unwind_backtrace) from [<c010e070>] (show_stack+0x10/0x14)
    [<c010e070>] (show_stack) from [<c0afb010>] (dump_stack+0xb4/0xe0)
    [<c0afb010>] (dump_stack) from [<c01272e0>] (__warn+0xf4/0x10c)
    [<c01272e0>] (__warn) from [<c01273a8>] (warn_slowpath_fmt+0xb0/0xb8)
    [<c01273a8>] (warn_slowpath_fmt) from [<c07d105c>] (devfreq_update_status+0xc0/0x188)
    [<c07d105c>] (devfreq_update_status) from [<c07d2d70>] (devfreq_set_target+0xb0/0x15c)
    [<c07d2d70>] (devfreq_set_target) from [<c07d3598>] (devfreq_suspend+0x2c/0x64)
    [<c07d3598>] (devfreq_suspend) from [<c05de0b0>] (dpm_suspend+0xa4/0x57c)
    [<c05de0b0>] (dpm_suspend) from [<c05def74>] (dpm_suspend_start+0x98/0xa0)
    [<c05def74>] (dpm_suspend_start) from [<c0195b58>] (suspend_devices_and_enter+0xec/0xc74)
    [<c0195b58>] (suspend_devices_and_enter) from [<c0196a20>] (pm_suspend+0x340/0x410)
    [<c0196a20>] (pm_suspend) from [<c019480c>] (state_store+0x6c/0xc8)
    [<c019480c>] (state_store) from [<c033fc50>] (kernfs_fop_write+0x10c/0x228)
    [<c033fc50>] (kernfs_fop_write) from [<c02a6d3c>] (__vfs_write+0x30/0x1d0)
    [<c02a6d3c>] (__vfs_write) from [<c02a9afc>] (vfs_write+0xa4/0x180)
    [<c02a9afc>] (vfs_write) from [<c02a9d58>] (ksys_write+0x60/0xd8)
    [<c02a9d58>] (ksys_write) from [<c0101000>] (ret_fast_syscall+0x0/0x28)
    Exception stack(0xed3d7fa8 to 0xed3d7ff0)
    ...
    irq event stamp: 9667
    hardirqs last  enabled at (9679): [<c0b1e7c4>] _raw_spin_unlock_irq+0x20/0x58
    hardirqs last disabled at (9698): [<c0b16a20>] __schedule+0xd8/0x818
    softirqs last  enabled at (9694): [<c01026fc>] __do_softirq+0x4fc/0x5fc
    softirqs last disabled at (9719): [<c012fe68>] irq_exit+0x16c/0x170
    ---[ end trace 41ac5b57d046bdbc ]---
    ------------[ cut here ]------------
    
    Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Acked-by: Chanwoo Choi <cw00.choi@samsung.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit f7766d1fdf5fffd45b8816f114ac7f7b9dd6489e
Author: Suman Anna <s-anna@ti.com>
Date:   Sun Apr 10 13:20:11 2016 -0600

    ARM: OMAP2+: hwmod: fix _idle() hwmod state sanity check sequence
    
    commit c20c8f750d9f8f8617f07ee2352d3ff560e66bc2 upstream.
    
    The omap_hwmod _enable() function can return success without setting
    the hwmod state to _HWMOD_STATE_ENABLED for IPs with reset lines when
    all of the reset lines are asserted. The omap_hwmod _idle() function
    also performs a similar check, but after checking for the hwmod state
    first. This triggers the WARN when pm_runtime_get and pm_runtime_put
    are invoked on IPs with all reset lines asserted. Reverse the checks
    for hwmod state and reset lines status to fix this.
    
    Issue found during a unbind operation on a device with reset lines
    still asserted, example backtrace below
    
     ------------[ cut here ]------------
     WARNING: CPU: 1 PID: 879 at arch/arm/mach-omap2/omap_hwmod.c:2207 _idle+0x1e4/0x240()
     omap_hwmod: mmu_dsp: idle state can only be entered from enabled state
     Modules linked in:
     CPU: 1 PID: 879 Comm: sh Not tainted 4.4.0-00008-ga989d951331a #3
     Hardware name: Generic OMAP5 (Flattened Device Tree)
     [<c0018e60>] (unwind_backtrace) from [<c0014dc4>] (show_stack+0x10/0x14)
     [<c0014dc4>] (show_stack) from [<c037ac28>] (dump_stack+0x90/0xc0)
     [<c037ac28>] (dump_stack) from [<c003f420>] (warn_slowpath_common+0x78/0xb4)
     [<c003f420>] (warn_slowpath_common) from [<c003f48c>] (warn_slowpath_fmt+0x30/0x40)
     [<c003f48c>] (warn_slowpath_fmt) from [<c0028c20>] (_idle+0x1e4/0x240)
     [<c0028c20>] (_idle) from [<c0029080>] (omap_hwmod_idle+0x28/0x48)
     [<c0029080>] (omap_hwmod_idle) from [<c002a5a4>] (omap_device_idle+0x3c/0x90)
     [<c002a5a4>] (omap_device_idle) from [<c0427a90>] (__rpm_callback+0x2c/0x60)
     [<c0427a90>] (__rpm_callback) from [<c0427ae4>] (rpm_callback+0x20/0x80)
     [<c0427ae4>] (rpm_callback) from [<c0427f84>] (rpm_suspend+0x138/0x74c)
     [<c0427f84>] (rpm_suspend) from [<c0428b78>] (__pm_runtime_idle+0x78/0xa8)
     [<c0428b78>] (__pm_runtime_idle) from [<c041f514>] (__device_release_driver+0x64/0x100)
     [<c041f514>] (__device_release_driver) from [<c041f5d0>] (device_release_driver+0x20/0x2c)
     [<c041f5d0>] (device_release_driver) from [<c041d85c>] (unbind_store+0x78/0xf8)
     [<c041d85c>] (unbind_store) from [<c0206df8>] (kernfs_fop_write+0xc0/0x1c4)
     [<c0206df8>] (kernfs_fop_write) from [<c018a120>] (__vfs_write+0x20/0xdc)
     [<c018a120>] (__vfs_write) from [<c018a9cc>] (vfs_write+0x90/0x164)
     [<c018a9cc>] (vfs_write) from [<c018b1f0>] (SyS_write+0x44/0x9c)
     [<c018b1f0>] (SyS_write) from [<c0010420>] (ret_fast_syscall+0x0/0x1c)
     ---[ end trace a4182013c75a9f50 ]---
    
    While at this, fix the sequence in _shutdown() as well, though there
    is no easy reproducible scenario.
    
    Fixes: 747834ab8347 ("ARM: OMAP2+: hwmod: revise hardreset behavior")
    Signed-off-by: Suman Anna <s-anna@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit a19b2be507973e96bc484bee24119ce4d9f9a9a7
Author: Dexuan Cui <decui@microsoft.com>
Date:   Thu Apr 23 20:40:16 2020 -0700

    PM: hibernate: Freeze kernel threads in software_resume()
    
    commit 2351f8d295ed63393190e39c2f7c1fee1a80578f upstream.
    
    Currently the kernel threads are not frozen in software_resume(), so
    between dpm_suspend_start(PMSG_QUIESCE) and resume_target_kernel(),
    system_freezable_power_efficient_wq can still try to submit SCSI
    commands and this can cause a panic since the low level SCSI driver
    (e.g. hv_storvsc) has quiesced the SCSI adapter and can not accept
    any SCSI commands: https://lkml.org/lkml/2020/4/10/47
    
    At first I posted a fix (https://lkml.org/lkml/2020/4/21/1318) trying
    to resolve the issue from hv_storvsc, but with the help of
    Bart Van Assche, I realized it's better to fix software_resume(),
    since this looks like a generic issue, not only pertaining to SCSI.
    
    Cc: All applicable <stable@vger.kernel.org>
    Signed-off-by: Dexuan Cui <decui@microsoft.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit c554ab856b668df35c69db6a54ad4e7660e362f2
Author: Dexuan Cui <decui@microsoft.com>
Date:   Thu Apr 23 20:40:16 2020 -0700

    PM: hibernate: Freeze kernel threads in software_resume()
    
    commit 2351f8d295ed63393190e39c2f7c1fee1a80578f upstream.
    
    Currently the kernel threads are not frozen in software_resume(), so
    between dpm_suspend_start(PMSG_QUIESCE) and resume_target_kernel(),
    system_freezable_power_efficient_wq can still try to submit SCSI
    commands and this can cause a panic since the low level SCSI driver
    (e.g. hv_storvsc) has quiesced the SCSI adapter and can not accept
    any SCSI commands: https://lkml.org/lkml/2020/4/10/47
    
    At first I posted a fix (https://lkml.org/lkml/2020/4/21/1318) trying
    to resolve the issue from hv_storvsc, but with the help of
    Bart Van Assche, I realized it's better to fix software_resume(),
    since this looks like a generic issue, not only pertaining to SCSI.
    
    Cc: All applicable <stable@vger.kernel.org>
    Signed-off-by: Dexuan Cui <decui@microsoft.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 3904bdf0821c40352495f632862637080e6bd744
Author: Dexuan Cui <decui@microsoft.com>
Date:   Thu Apr 23 20:40:16 2020 -0700

    PM: hibernate: Freeze kernel threads in software_resume()
    
    commit 2351f8d295ed63393190e39c2f7c1fee1a80578f upstream.
    
    Currently the kernel threads are not frozen in software_resume(), so
    between dpm_suspend_start(PMSG_QUIESCE) and resume_target_kernel(),
    system_freezable_power_efficient_wq can still try to submit SCSI
    commands and this can cause a panic since the low level SCSI driver
    (e.g. hv_storvsc) has quiesced the SCSI adapter and can not accept
    any SCSI commands: https://lkml.org/lkml/2020/4/10/47
    
    At first I posted a fix (https://lkml.org/lkml/2020/4/21/1318) trying
    to resolve the issue from hv_storvsc, but with the help of
    Bart Van Assche, I realized it's better to fix software_resume(),
    since this looks like a generic issue, not only pertaining to SCSI.
    
    Cc: All applicable <stable@vger.kernel.org>
    Signed-off-by: Dexuan Cui <decui@microsoft.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 3ad04be60c18651061096d42c5056bb28a5a4ce4
Author: Dexuan Cui <decui@microsoft.com>
Date:   Thu Apr 23 20:40:16 2020 -0700

    PM: hibernate: Freeze kernel threads in software_resume()
    
    commit 2351f8d295ed63393190e39c2f7c1fee1a80578f upstream.
    
    Currently the kernel threads are not frozen in software_resume(), so
    between dpm_suspend_start(PMSG_QUIESCE) and resume_target_kernel(),
    system_freezable_power_efficient_wq can still try to submit SCSI
    commands and this can cause a panic since the low level SCSI driver
    (e.g. hv_storvsc) has quiesced the SCSI adapter and can not accept
    any SCSI commands: https://lkml.org/lkml/2020/4/10/47
    
    At first I posted a fix (https://lkml.org/lkml/2020/4/21/1318) trying
    to resolve the issue from hv_storvsc, but with the help of
    Bart Van Assche, I realized it's better to fix software_resume(),
    since this looks like a generic issue, not only pertaining to SCSI.
    
    Cc: All applicable <stable@vger.kernel.org>
    Signed-off-by: Dexuan Cui <decui@microsoft.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 9199193d8dc094127b36ce679bfef463fc2e81ba
Author: Dexuan Cui <decui@microsoft.com>
Date:   Thu Apr 23 20:40:16 2020 -0700

    PM: hibernate: Freeze kernel threads in software_resume()
    
    commit 2351f8d295ed63393190e39c2f7c1fee1a80578f upstream.
    
    Currently the kernel threads are not frozen in software_resume(), so
    between dpm_suspend_start(PMSG_QUIESCE) and resume_target_kernel(),
    system_freezable_power_efficient_wq can still try to submit SCSI
    commands and this can cause a panic since the low level SCSI driver
    (e.g. hv_storvsc) has quiesced the SCSI adapter and can not accept
    any SCSI commands: https://lkml.org/lkml/2020/4/10/47
    
    At first I posted a fix (https://lkml.org/lkml/2020/4/21/1318) trying
    to resolve the issue from hv_storvsc, but with the help of
    Bart Van Assche, I realized it's better to fix software_resume(),
    since this looks like a generic issue, not only pertaining to SCSI.
    
    Cc: All applicable <stable@vger.kernel.org>
    Signed-off-by: Dexuan Cui <decui@microsoft.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 2351f8d295ed63393190e39c2f7c1fee1a80578f
Author: Dexuan Cui <decui@microsoft.com>
Date:   Thu Apr 23 20:40:16 2020 -0700

    PM: hibernate: Freeze kernel threads in software_resume()
    
    Currently the kernel threads are not frozen in software_resume(), so
    between dpm_suspend_start(PMSG_QUIESCE) and resume_target_kernel(),
    system_freezable_power_efficient_wq can still try to submit SCSI
    commands and this can cause a panic since the low level SCSI driver
    (e.g. hv_storvsc) has quiesced the SCSI adapter and can not accept
    any SCSI commands: https://lkml.org/lkml/2020/4/10/47
    
    At first I posted a fix (https://lkml.org/lkml/2020/4/21/1318) trying
    to resolve the issue from hv_storvsc, but with the help of
    Bart Van Assche, I realized it's better to fix software_resume(),
    since this looks like a generic issue, not only pertaining to SCSI.
    
    Cc: All applicable <stable@vger.kernel.org>
    Signed-off-by: Dexuan Cui <decui@microsoft.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 2c9a583be132d1be1ba54f3433b4d817f15c5464
Author: Todd Brandt <todd.e.brandt@linux.intel.com>
Date:   Wed Apr 8 10:58:19 2020 -0700

    pm-graph v5.6
    
    sleepgraph:
     - force usage of python3 instead of using system default
     - fix bugzilla 204773 (https://bugzilla.kernel.org/show_bug.cgi?id=204773)
     - fix issue of platform info not being reset in -multi (logs fill up)
     - change -ftop call to "pm_suspend", this is one level below state_store
     - add -wificheck command to read out the current wifi device details
     - change -wifi behavior to poll /proc/net/wireless for wifi connect
     - add wifi reconnect time to timeline, include time in summary column
     - add "fail on wifi_resume" to timeline and summary when wifi fails
     - add a set of commands to collect data before/after suspend in the log
     - add "-cmdinfo" command which prints out all the data collected
     - check for cmd info tools at start, print found/missing in green/red
     - fix kernel suspend time calculation: tool used to look for start of
        pm_suspend_console, but the order has changed. latest kernel starts
        with ksys_sync, use this instead
     - include time spent in mem/disk in the header (same as freeze/standby)
     - ignore turbostat 32-bit capability warnings
     - print to result.txt when -skiphtml is used, just say result: pass
     - don't exit on SIGTSTP, it's a ctrl-Z and the tool may come back
     - -multi argument supports duration as well as count: hours, minutes, seconds
     - update the -multi status output to be more informative
     - -maxfail sets maximum consecutive fails before a -multi run is aborted
     - in -summary, ignore dmesg/ftrace/html files that are 0 size
    
    bootgraph:
     - force usage of python3 instead of using system default
    
    README:
     - add endurance testing instructions
    
    Makefile:
     - remove pycache on uninstall
    
    Signed-off-by: Todd Brandt <todd.e.brandt@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 6595cef7a7aefc3ad60eead38289ec1792d31027
Author: Yuji Sasaki <sasakiy@chromium.org>
Date:   Fri Feb 14 13:13:40 2020 +0530

    spi: qup: call spi_qup_pm_resume_runtime before suspending
    
    [ Upstream commit 136b5cd2e2f97581ae560cff0db2a3b5369112da ]
    
    spi_qup_suspend() will cause synchronous external abort when
    runtime suspend is enabled and applied, as it tries to
    access SPI controller register while clock is already disabled
    in spi_qup_pm_suspend_runtime().
    
    Signed-off-by: Yuji sasaki <sasakiy@chromium.org>
    Signed-off-by: Vinod Koul <vkoul@kernel.org>
    Link: https://lore.kernel.org/r/20200214074340.2286170-1-vkoul@kernel.org
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit e0f5fa76696a990695e110deee83aa3f3efa0ab3
Author: Yuji Sasaki <sasakiy@chromium.org>
Date:   Fri Feb 14 13:13:40 2020 +0530

    spi: qup: call spi_qup_pm_resume_runtime before suspending
    
    [ Upstream commit 136b5cd2e2f97581ae560cff0db2a3b5369112da ]
    
    spi_qup_suspend() will cause synchronous external abort when
    runtime suspend is enabled and applied, as it tries to
    access SPI controller register while clock is already disabled
    in spi_qup_pm_suspend_runtime().
    
    Signed-off-by: Yuji sasaki <sasakiy@chromium.org>
    Signed-off-by: Vinod Koul <vkoul@kernel.org>
    Link: https://lore.kernel.org/r/20200214074340.2286170-1-vkoul@kernel.org
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 227507aa68648f6926b57ac7338047665c5d4fc1
Author: Yuji Sasaki <sasakiy@chromium.org>
Date:   Fri Feb 14 13:13:40 2020 +0530

    spi: qup: call spi_qup_pm_resume_runtime before suspending
    
    [ Upstream commit 136b5cd2e2f97581ae560cff0db2a3b5369112da ]
    
    spi_qup_suspend() will cause synchronous external abort when
    runtime suspend is enabled and applied, as it tries to
    access SPI controller register while clock is already disabled
    in spi_qup_pm_suspend_runtime().
    
    Signed-off-by: Yuji sasaki <sasakiy@chromium.org>
    Signed-off-by: Vinod Koul <vkoul@kernel.org>
    Link: https://lore.kernel.org/r/20200214074340.2286170-1-vkoul@kernel.org
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit ec18b456be46f5ddc9e9c1750fa1ea03f4f3920c
Merge: fd91e03e5fe3 bb1a0e87e1c5
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Mar 25 21:04:15 2020 +0100

    Merge tag 'at91-5.7-soc' of git://git.kernel.org/pub/scm/linux/kernel/git/at91/linux into arm/soc
    
    AT91 SoC for 5.7
    
     - Rework PM to support sam9x60
    
    * tag 'at91-5.7-soc' of git://git.kernel.org/pub/scm/linux/kernel/git/at91/linux:
      ARM: at91: pm: add quirk for sam9x60's ulp1
      ARM: at91: pm: add plla disable/enable support for sam9x60
      clk: at91: move sam9x60's PLL register offsets to PMC header
      ARM: at91: pm: s/sfr/sfrbu in pm_suspend.S
      ARM: at91: pm: add pmc_version member to at91_pm_data
      ARM: at91: pm: add macros for plla disable/enable
      ARM: at91: pm: revert do not disable/enable PLLA for ULP modes
      ARM: at91: pm: use proper master clock register offset
      ARM: at91: Drop unneeded select of COMMON_CLK
    
    Link: https://lore.kernel.org/r/20200322090116.GA208895@piout.net
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

commit 94b248d0407c103786631cb825c0234d275fb7ce
Author: Yuji Sasaki <sasakiy@chromium.org>
Date:   Fri Feb 14 13:13:40 2020 +0530

    spi: qup: call spi_qup_pm_resume_runtime before suspending
    
    [ Upstream commit 136b5cd2e2f97581ae560cff0db2a3b5369112da ]
    
    spi_qup_suspend() will cause synchronous external abort when
    runtime suspend is enabled and applied, as it tries to
    access SPI controller register while clock is already disabled
    in spi_qup_pm_suspend_runtime().
    
    Signed-off-by: Yuji sasaki <sasakiy@chromium.org>
    Signed-off-by: Vinod Koul <vkoul@kernel.org>
    Link: https://lore.kernel.org/r/20200214074340.2286170-1-vkoul@kernel.org
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 9eee3e21a59d1b5a661c51db1207b47a5176997a
Author: Yuji Sasaki <sasakiy@chromium.org>
Date:   Fri Feb 14 13:13:40 2020 +0530

    spi: qup: call spi_qup_pm_resume_runtime before suspending
    
    [ Upstream commit 136b5cd2e2f97581ae560cff0db2a3b5369112da ]
    
    spi_qup_suspend() will cause synchronous external abort when
    runtime suspend is enabled and applied, as it tries to
    access SPI controller register while clock is already disabled
    in spi_qup_pm_suspend_runtime().
    
    Signed-off-by: Yuji sasaki <sasakiy@chromium.org>
    Signed-off-by: Vinod Koul <vkoul@kernel.org>
    Link: https://lore.kernel.org/r/20200214074340.2286170-1-vkoul@kernel.org
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit b84530ba478f05aab785ce1341fc39eb45fcb32e
Author: Yuji Sasaki <sasakiy@chromium.org>
Date:   Fri Feb 14 13:13:40 2020 +0530

    spi: qup: call spi_qup_pm_resume_runtime before suspending
    
    [ Upstream commit 136b5cd2e2f97581ae560cff0db2a3b5369112da ]
    
    spi_qup_suspend() will cause synchronous external abort when
    runtime suspend is enabled and applied, as it tries to
    access SPI controller register while clock is already disabled
    in spi_qup_pm_suspend_runtime().
    
    Signed-off-by: Yuji sasaki <sasakiy@chromium.org>
    Signed-off-by: Vinod Koul <vkoul@kernel.org>
    Link: https://lore.kernel.org/r/20200214074340.2286170-1-vkoul@kernel.org
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit efde2659b0fe835732047357b2902cca14f054d9
Author: Stephen Boyd <swboyd@chromium.org>
Date:   Tue Jan 14 17:37:51 2020 -0800

    drivers: qcom: rpmh-rsc: Use rcuidle tracepoints for rpmh
    
    This tracepoint is hit now that we call into the rpmh code from the cpu
    idle path. Let's move this to be an rcuidle tracepoint so that we avoid
    the RCU idle splat below
    
     =============================
     WARNING: suspicious RCU usage
     5.4.10 #68 Tainted: G S
     -----------------------------
     drivers/soc/qcom/trace-rpmh.h:72 suspicious rcu_dereference_check() usage!
    
     other info that might help us debug this:
    
     RCU used illegally from idle CPU!
     rcu_scheduler_active = 2, debug_locks = 1
     RCU used illegally from extended quiescent state!
     5 locks held by swapper/2/0:
      #0: ffffff81745d6ee8 (&(&genpd->slock)->rlock){+.+.}, at: genpd_lock_spin+0x1c/0x2c
      #1: ffffff81745da6e8 (&(&genpd->slock)->rlock/1){....}, at: genpd_lock_nested_spin+0x24/0x34
      #2: ffffff8174f2ca20 (&(&genpd->slock)->rlock/2){....}, at: genpd_lock_nested_spin+0x24/0x34
      #3: ffffff8174f2c300 (&(&drv->client.cache_lock)->rlock){....}, at: rpmh_flush+0x48/0x24c
      #4: ffffff8174f2c150 (&(&tcs->lock)->rlock){+.+.}, at: rpmh_rsc_write_ctrl_data+0x74/0x270
    
     stack backtrace:
     CPU: 2 PID: 0 Comm: swapper/2 Tainted: G S                5.4.10 #68
     Call trace:
      dump_backtrace+0x0/0x174
      show_stack+0x20/0x2c
      dump_stack+0xc8/0x124
      lockdep_rcu_suspicious+0xe4/0x104
      __tcs_buffer_write+0x230/0x2d0
      rpmh_rsc_write_ctrl_data+0x210/0x270
      rpmh_flush+0x84/0x24c
      rpmh_domain_power_off+0x78/0x98
      _genpd_power_off+0x40/0xc0
      genpd_power_off+0x168/0x208
      genpd_power_off+0x1e0/0x208
      genpd_power_off+0x1e0/0x208
      genpd_runtime_suspend+0x1ac/0x220
      __rpm_callback+0x70/0xfc
      rpm_callback+0x34/0x8c
      rpm_suspend+0x218/0x4a4
      __pm_runtime_suspend+0x88/0xac
      psci_enter_domain_idle_state+0x3c/0xb4
      cpuidle_enter_state+0xb8/0x284
      cpuidle_enter+0x38/0x4c
      call_cpuidle+0x3c/0x68
      do_idle+0x194/0x260
      cpu_startup_entry+0x24/0x28
      secondary_start_kernel+0x150/0x15c
    
    Acked-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Douglas Anderson <dianders@chromium.org>
    Tested-by: Sai Prakash Ranjan <saiprakash.ranjan@codeaurora.org>
    Fixes: a65a397f2451 ("cpuidle: psci: Add support for PM domains by using genpd")
    Reported-by: Sai Prakash Ranjan <saiprakash.ranjan@codeaurora.org>
    Cc: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Stephen Boyd <swboyd@chromium.org>
    Link: https://lore.kernel.org/r/20200115013751.249588-1-swboyd@chromium.org
    Signed-off-by: Bjorn Andersson <bjorn.andersson@linaro.org>

commit 9803aac7b5508718989e4cde11b854fc01037b01
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Jan 7 22:53:19 2020 +0100

    drm/komeda: mark PM functions as __maybe_unused
    
    Without this, we get a couple of warnings when CONFIG_PM
    is disabled:
    
    drivers/gpu/drm/arm/display/komeda/komeda_drv.c:156:12: error: 'komeda_rt_pm_resume' defined but not used [-Werror=unused-function]
     static int komeda_rt_pm_resume(struct device *dev)
                ^~~~~~~~~~~~~~~~~~~
    drivers/gpu/drm/arm/display/komeda/komeda_drv.c:149:12: error: 'komeda_rt_pm_suspend' defined but not used [-Werror=unused-function]
     static int komeda_rt_pm_suspend(struct device *dev)
                ^~~~~~~~~~~~~~~~~~~~
    
    Fixes: efb465088518 ("drm/komeda: Add runtime_pm support")
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Reviewed-by: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Signed-off-by: james qian wang (Arm Technology China) <james.qian.wang@arm.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200107215327.1579195-1-arnd@arndb.de

commit 66e4f4a9cc389b277e187c115a285fad2cba5485
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Fri Feb 21 16:47:39 2020 +0200

    rtc: cmos: Use spin_lock_irqsave() in cmos_interrupt()
    
    cmos_interrupt() isn't always called from hardirq context, so
    we must use spin_lock_irqsave() & co.
    
    ================================
    WARNING: inconsistent lock state
    5.6.0-rc2-CI-CI_DRM_7981+ #1 Tainted: G     U
    --------------------------------
    inconsistent {IN-HARDIRQ-W} -> {HARDIRQ-ON-W} usage.
    rtcwake/4315 [HC0[0]:SC0[0]:HE1:SE1] takes:
    ffffffff82635198 (rtc_lock){?...}, at: cmos_interrupt+0x18/0x100
    {IN-HARDIRQ-W} state was registered at:
      lock_acquire+0xa7/0x1c0
      _raw_spin_lock+0x2a/0x40
      cmos_interrupt+0x18/0x100
      rtc_handler+0x75/0xc0
      acpi_ev_fixed_event_detect+0xf9/0x132
      acpi_ev_sci_xrupt_handler+0xb/0x28
      acpi_irq+0x13/0x30
      __handle_irq_event_percpu+0x41/0x2c0
      handle_irq_event_percpu+0x2b/0x70
      handle_irq_event+0x2f/0x50
      handle_fasteoi_irq+0x8e/0x150
      do_IRQ+0x7e/0x160
      ret_from_intr+0x0/0x35
      mwait_idle+0x7e/0x200
      do_idle+0x1bb/0x260
      cpu_startup_entry+0x14/0x20
      start_secondary+0x15f/0x1b0
      secondary_startup_64+0xa4/0xb0
    irq event stamp: 42003
    hardirqs last  enabled at (42003): [<ffffffff81a36567>] _raw_spin_unlock_irqrestore+0x47/0x60
    hardirqs last disabled at (42002): [<ffffffff81a362ed>] _raw_spin_lock_irqsave+0xd/0x50
    softirqs last  enabled at (41848): [<ffffffff81e00385>] __do_softirq+0x385/0x47f
    softirqs last disabled at (41841): [<ffffffff810bab3a>] irq_exit+0xba/0xc0
    
    other info that might help us debug this:
     Possible unsafe locking scenario:
    
           CPU0
           ----
      lock(rtc_lock);
      <Interrupt>
        lock(rtc_lock);
    
     *** DEADLOCK ***
    
    6 locks held by rtcwake/4315:
     #0: ffff888175dc9408 (sb_writers#5){.+.+}, at: vfs_write+0x1a4/0x1d0
     #1: ffff88817406ca80 (&of->mutex){+.+.}, at: kernfs_fop_write+0xdd/0x1b0
     #2: ffff888179be85e0 (kn->count#236){.+.+}, at: kernfs_fop_write+0xe6/0x1b0
     #3: ffffffff82641e00 (system_transition_mutex){+.+.}, at: pm_suspend+0xb3/0x3b0
     #4: ffffffff826b3ee0 (acpi_scan_lock){+.+.}, at: acpi_suspend_begin+0x47/0x80
     #5: ffff888178fc3960 (&dev->mutex){....}, at: device_resume+0x92/0x1c0
    
    stack backtrace:
    CPU: 3 PID: 4315 Comm: rtcwake Tainted: G     U            5.6.0-rc2-CI-CI_DRM_7981+ #1
    Hardware name: Google Soraka/Soraka, BIOS MrChromebox-4.10 08/25/2019
    Call Trace:
     dump_stack+0x71/0x9b
     mark_lock+0x49a/0x500
     ? print_shortest_lock_dependencies+0x200/0x200
     __lock_acquire+0x6d4/0x15d0
     ? __lock_acquire+0x460/0x15d0
     lock_acquire+0xa7/0x1c0
     ? cmos_interrupt+0x18/0x100
     _raw_spin_lock+0x2a/0x40
     ? cmos_interrupt+0x18/0x100
     cmos_interrupt+0x18/0x100
     cmos_resume+0x1fd/0x290
     ? __acpi_pm_set_device_wakeup+0x24/0x100
     pnp_bus_resume+0x5e/0x90
     ? pnp_bus_suspend+0x10/0x10
     dpm_run_callback+0x64/0x280
     device_resume+0xd4/0x1c0
     ? dpm_watchdog_set+0x60/0x60
     dpm_resume+0x106/0x410
     ? dpm_resume_early+0x38c/0x3e0
     dpm_resume_end+0x8/0x10
     suspend_devices_and_enter+0x16f/0xbe0
     ? rcu_read_lock_sched_held+0x4d/0x80
     pm_suspend+0x344/0x3b0
     state_store+0x78/0xe0
     kernfs_fop_write+0x112/0x1b0
     vfs_write+0xb9/0x1d0
     ksys_write+0x9f/0xe0
     do_syscall_64+0x4f/0x220
     entry_SYSCALL_64_after_hwframe+0x49/0xbe
    RIP: 0033:0x7ff934307154
    Code: 89 02 48 c7 c0 ff ff ff ff c3 66 2e 0f 1f 84 00 00 00 00 00 66 90 48 8d 05 b1 07 2e 00 8b 00 85 c0 75 13 b8 01 00 00 00 0f 05 <48> 3d 00 f0 ff ff 77 54 f3 c3 66 90 41 54 55 49 89 d4 53 48 89 f5
    RSP: 002b:00007ffe2647c168 EFLAGS: 00000246 ORIG_RAX: 0000000000000001
    RAX: ffffffffffffffda RBX: 0000000000000004 RCX: 00007ff934307154
    RDX: 0000000000000004 RSI: 000055de3ec4e5a0 RDI: 000000000000000a
    RBP: 000055de3ec4e5a0 R08: 000055de3ec4c5e0 R09: 00007ff9349f3740
    R10: 000055de3ec4a010 R11: 0000000000000246 R12: 000055de3ec4c500
    R13: 0000000000000004 R14: 00007ff9345df2a0 R15: 00007ff9345de760
    
    Fixes: c6d3a278cc12 ("rtc: cmos: acknowledge ACPI driven wake alarms upon resume")
    Fixes: 311ee9c151ad ("rtc: cmos: allow using ACPI for RTC alarm instead of HPET")
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://lore.kernel.org/r/20200221144739.11746-1-ville.syrjala@linux.intel.com
    Signed-off-by: Alexandre Belloni <alexandre.belloni@bootlin.com>

commit 1a910c11d35bfacb68a3e650fbc087491e92661f
Author: Guido Günther <agx@sigxcpu.org>
Date:   Mon Mar 2 20:13:35 2020 +0100

    drm/etnaviv: Ignore MC when checking runtime suspend idleness
    
    Without that runtime suspend is often blocked due to
    etnaviv_gpu_rpm_suspend() returning -EBUSY since the FE seems to trigger
    the MC in its idle loop.
    
    Ignoring the MC bit makes the GPU suspend as expected. This was tested
    on GC7000.
    
    Signed-off-by: Guido Günther <agx@sigxcpu.org>
    Signed-off-by: Lucas Stach <l.stach@pengutronix.de>

commit 3edd9f0b3c000ace984dc90bb05d8dc196871337
Author: Stephen Boyd <swboyd@chromium.org>
Date:   Tue Jan 14 15:11:03 2020 -0800

    gpiolib: Set lockdep class for hierarchical irq domains
    
    [ Upstream commit c34f6dc8c9e6bbe9fba1d53acd6d9a3889599da3 ]
    
    I see the following lockdep splat in the qcom pinctrl driver when
    attempting to suspend the device.
    
     ============================================
     WARNING: possible recursive locking detected
     5.4.2 #2 Tainted: G S
     --------------------------------------------
     cat/6536 is trying to acquire lock:
     ffffff814787ccc0 (&irq_desc_lock_class){-.-.}, at: __irq_get_desc_lock+0x64/0x94
    
     but task is already holding lock:
     ffffff81436740c0 (&irq_desc_lock_class){-.-.}, at: __irq_get_desc_lock+0x64/0x94
    
     other info that might help us debug this:
      Possible unsafe locking scenario:
    
            CPU0
            ----
       lock(&irq_desc_lock_class);
       lock(&irq_desc_lock_class);
    
      *** DEADLOCK ***
    
      May be due to missing lock nesting notation
    
     7 locks held by cat/6536:
      #0: ffffff8140e0c420 (sb_writers#7){.+.+}, at: vfs_write+0xc8/0x19c
      #1: ffffff8121eec480 (&of->mutex){+.+.}, at: kernfs_fop_write+0x128/0x1f4
      #2: ffffff8147cad668 (kn->count#263){.+.+}, at: kernfs_fop_write+0x130/0x1f4
      #3: ffffffd011446000 (system_transition_mutex){+.+.}, at: pm_suspend+0x108/0x354
      #4: ffffff814302b970 (&dev->mutex){....}, at: __device_suspend+0x16c/0x420
      #5: ffffff81436740c0 (&irq_desc_lock_class){-.-.}, at: __irq_get_desc_lock+0x64/0x94
      #6: ffffff81479b8c10 (&pctrl->lock){....}, at: msm_gpio_irq_set_wake+0x48/0x7c
    
     stack backtrace:
     CPU: 4 PID: 6536 Comm: cat Tainted: G S                5.4.2 #2
     Call trace:
      dump_backtrace+0x0/0x174
      show_stack+0x20/0x2c
      dump_stack+0xdc/0x144
      __lock_acquire+0x52c/0x2268
      lock_acquire+0x1dc/0x220
      _raw_spin_lock_irqsave+0x64/0x80
      __irq_get_desc_lock+0x64/0x94
      irq_set_irq_wake+0x40/0x144
      msm_gpio_irq_set_wake+0x5c/0x7c
      set_irq_wake_real+0x40/0x5c
      irq_set_irq_wake+0x70/0x144
      cros_ec_rtc_suspend+0x38/0x4c
      platform_pm_suspend+0x34/0x60
      dpm_run_callback+0x64/0xcc
      __device_suspend+0x314/0x420
      dpm_suspend+0xf8/0x298
      dpm_suspend_start+0x84/0xb4
      suspend_devices_and_enter+0xbc/0x628
      pm_suspend+0x214/0x354
      state_store+0xb0/0x108
      kobj_attr_store+0x14/0x24
      sysfs_kf_write+0x4c/0x64
      kernfs_fop_write+0x158/0x1f4
      __vfs_write+0x54/0x18c
      vfs_write+0xdc/0x19c
      ksys_write+0x7c/0xe4
      __arm64_sys_write+0x20/0x2c
      el0_svc_common+0xa8/0x160
      el0_svc_compat_handler+0x2c/0x38
      el0_svc_compat+0x8/0x10
    
    This is because the msm_gpio_irq_set_wake() function calls
    irq_set_irq_wake() as a backup in case the irq comes in during the path
    to idle. Given that we're calling irqchip functions from within an
    irqchip we need to set the lockdep class to be different for this child
    controller vs. the default one that the parent irqchip gets.
    
    This used to be done before this driver was converted to hierarchical
    irq domains in commit e35a6ae0eb3a ("pinctrl/msm: Setup GPIO chip in
    hierarchy") via the gpiochip_irq_map() function. With hierarchical irq
    domains this function has been replaced by
    gpiochip_hierarchy_irq_domain_alloc(). Therefore, set the lockdep class
    like was done previously in the irq domain path so we can avoid this
    lockdep warning.
    
    Fixes: fdd61a013a24 ("gpio: Add support for hierarchical IRQ domains")
    Cc: Thierry Reding <treding@nvidia.com>
    Cc: Brian Masney <masneyb@onstation.org>
    Cc: Lina Iyer <ilina@codeaurora.org>
    Cc: Marc Zyngier <maz@kernel.org>
    Cc: Maulik Shah <mkshah@codeaurora.org>
    Signed-off-by: Stephen Boyd <swboyd@chromium.org>
    Link: https://lore.kernel.org/r/20200114231103.85641-1-swboyd@chromium.org
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 13d368cd1e13ee5f709caa6847aa3f0cbbda1ddb
Author: Stephen Boyd <swboyd@chromium.org>
Date:   Tue Jan 14 15:11:03 2020 -0800

    gpiolib: Set lockdep class for hierarchical irq domains
    
    [ Upstream commit c34f6dc8c9e6bbe9fba1d53acd6d9a3889599da3 ]
    
    I see the following lockdep splat in the qcom pinctrl driver when
    attempting to suspend the device.
    
     ============================================
     WARNING: possible recursive locking detected
     5.4.2 #2 Tainted: G S
     --------------------------------------------
     cat/6536 is trying to acquire lock:
     ffffff814787ccc0 (&irq_desc_lock_class){-.-.}, at: __irq_get_desc_lock+0x64/0x94
    
     but task is already holding lock:
     ffffff81436740c0 (&irq_desc_lock_class){-.-.}, at: __irq_get_desc_lock+0x64/0x94
    
     other info that might help us debug this:
      Possible unsafe locking scenario:
    
            CPU0
            ----
       lock(&irq_desc_lock_class);
       lock(&irq_desc_lock_class);
    
      *** DEADLOCK ***
    
      May be due to missing lock nesting notation
    
     7 locks held by cat/6536:
      #0: ffffff8140e0c420 (sb_writers#7){.+.+}, at: vfs_write+0xc8/0x19c
      #1: ffffff8121eec480 (&of->mutex){+.+.}, at: kernfs_fop_write+0x128/0x1f4
      #2: ffffff8147cad668 (kn->count#263){.+.+}, at: kernfs_fop_write+0x130/0x1f4
      #3: ffffffd011446000 (system_transition_mutex){+.+.}, at: pm_suspend+0x108/0x354
      #4: ffffff814302b970 (&dev->mutex){....}, at: __device_suspend+0x16c/0x420
      #5: ffffff81436740c0 (&irq_desc_lock_class){-.-.}, at: __irq_get_desc_lock+0x64/0x94
      #6: ffffff81479b8c10 (&pctrl->lock){....}, at: msm_gpio_irq_set_wake+0x48/0x7c
    
     stack backtrace:
     CPU: 4 PID: 6536 Comm: cat Tainted: G S                5.4.2 #2
     Call trace:
      dump_backtrace+0x0/0x174
      show_stack+0x20/0x2c
      dump_stack+0xdc/0x144
      __lock_acquire+0x52c/0x2268
      lock_acquire+0x1dc/0x220
      _raw_spin_lock_irqsave+0x64/0x80
      __irq_get_desc_lock+0x64/0x94
      irq_set_irq_wake+0x40/0x144
      msm_gpio_irq_set_wake+0x5c/0x7c
      set_irq_wake_real+0x40/0x5c
      irq_set_irq_wake+0x70/0x144
      cros_ec_rtc_suspend+0x38/0x4c
      platform_pm_suspend+0x34/0x60
      dpm_run_callback+0x64/0xcc
      __device_suspend+0x314/0x420
      dpm_suspend+0xf8/0x298
      dpm_suspend_start+0x84/0xb4
      suspend_devices_and_enter+0xbc/0x628
      pm_suspend+0x214/0x354
      state_store+0xb0/0x108
      kobj_attr_store+0x14/0x24
      sysfs_kf_write+0x4c/0x64
      kernfs_fop_write+0x158/0x1f4
      __vfs_write+0x54/0x18c
      vfs_write+0xdc/0x19c
      ksys_write+0x7c/0xe4
      __arm64_sys_write+0x20/0x2c
      el0_svc_common+0xa8/0x160
      el0_svc_compat_handler+0x2c/0x38
      el0_svc_compat+0x8/0x10
    
    This is because the msm_gpio_irq_set_wake() function calls
    irq_set_irq_wake() as a backup in case the irq comes in during the path
    to idle. Given that we're calling irqchip functions from within an
    irqchip we need to set the lockdep class to be different for this child
    controller vs. the default one that the parent irqchip gets.
    
    This used to be done before this driver was converted to hierarchical
    irq domains in commit e35a6ae0eb3a ("pinctrl/msm: Setup GPIO chip in
    hierarchy") via the gpiochip_irq_map() function. With hierarchical irq
    domains this function has been replaced by
    gpiochip_hierarchy_irq_domain_alloc(). Therefore, set the lockdep class
    like was done previously in the irq domain path so we can avoid this
    lockdep warning.
    
    Fixes: fdd61a013a24 ("gpio: Add support for hierarchical IRQ domains")
    Cc: Thierry Reding <treding@nvidia.com>
    Cc: Brian Masney <masneyb@onstation.org>
    Cc: Lina Iyer <ilina@codeaurora.org>
    Cc: Marc Zyngier <maz@kernel.org>
    Cc: Maulik Shah <mkshah@codeaurora.org>
    Signed-off-by: Stephen Boyd <swboyd@chromium.org>
    Link: https://lore.kernel.org/r/20200114231103.85641-1-swboyd@chromium.org
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit f33d807c9d8847c634ddcb033178f93347428e7b
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Tue Feb 11 19:19:11 2020 +0100

    crypto: ccree - make cc_pm_{suspend,resume}() static
    
    cc_pm_suspend() and cc_pm_resume() are not used outside
    drivers/crypto/ccree/cc_pm.c.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

commit 136b5cd2e2f97581ae560cff0db2a3b5369112da
Author: Yuji Sasaki <sasakiy@chromium.org>
Date:   Fri Feb 14 13:13:40 2020 +0530

    spi: qup: call spi_qup_pm_resume_runtime before suspending
    
    spi_qup_suspend() will cause synchronous external abort when
    runtime suspend is enabled and applied, as it tries to
    access SPI controller register while clock is already disabled
    in spi_qup_pm_suspend_runtime().
    
    Signed-off-by: Yuji sasaki <sasakiy@chromium.org>
    Signed-off-by: Vinod Koul <vkoul@kernel.org>
    Link: https://lore.kernel.org/r/20200214074340.2286170-1-vkoul@kernel.org
    Signed-off-by: Mark Brown <broonie@kernel.org>

commit 6c6c559f1f8e275ff48a2c92bb5ffbd7e4331c62
Author: Stephen Boyd <swboyd@chromium.org>
Date:   Tue Jan 21 10:37:48 2020 -0800

    spmi: pmic-arb: Set lockdep class for hierarchical irq domains
    
    commit 2d5a2f913b658a7ae984773a63318ed4daadf4af upstream.
    
    I see the following lockdep splat in the qcom pinctrl driver when
    attempting to suspend the device.
    
     WARNING: possible recursive locking detected
     5.4.11 #3 Tainted: G        W
     --------------------------------------------
     cat/3074 is trying to acquire lock:
     ffffff81f49804c0 (&irq_desc_lock_class){-.-.}, at: __irq_get_desc_lock+0x64/0x94
    
     but task is already holding lock:
     ffffff81f1cc10c0 (&irq_desc_lock_class){-.-.}, at: __irq_get_desc_lock+0x64/0x94
    
     other info that might help us debug this:
      Possible unsafe locking scenario:
    
            CPU0
            ----
       lock(&irq_desc_lock_class);
       lock(&irq_desc_lock_class);
    
      *** DEADLOCK ***
    
      May be due to missing lock nesting notation
    
     6 locks held by cat/3074:
      #0: ffffff81f01d9420 (sb_writers#7){.+.+}, at: vfs_write+0xd0/0x1a4
      #1: ffffff81bd7d2080 (&of->mutex){+.+.}, at: kernfs_fop_write+0x12c/0x1fc
      #2: ffffff81f4c322f0 (kn->count#337){.+.+}, at: kernfs_fop_write+0x134/0x1fc
      #3: ffffffe411a41d60 (system_transition_mutex){+.+.}, at: pm_suspend+0x108/0x348
      #4: ffffff81f1c5e970 (&dev->mutex){....}, at: __device_suspend+0x168/0x41c
      #5: ffffff81f1cc10c0 (&irq_desc_lock_class){-.-.}, at: __irq_get_desc_lock+0x64/0x94
    
     stack backtrace:
     CPU: 5 PID: 3074 Comm: cat Tainted: G        W         5.4.11 #3
     Hardware name: Google Cheza (rev3+) (DT)
     Call trace:
      dump_backtrace+0x0/0x174
      show_stack+0x20/0x2c
      dump_stack+0xc8/0x124
      __lock_acquire+0x460/0x2388
      lock_acquire+0x1cc/0x210
      _raw_spin_lock_irqsave+0x64/0x80
      __irq_get_desc_lock+0x64/0x94
      irq_set_irq_wake+0x40/0x144
      qpnpint_irq_set_wake+0x28/0x34
      set_irq_wake_real+0x40/0x5c
      irq_set_irq_wake+0x70/0x144
      pm8941_pwrkey_suspend+0x34/0x44
      platform_pm_suspend+0x34/0x60
      dpm_run_callback+0x64/0xcc
      __device_suspend+0x310/0x41c
      dpm_suspend+0xf8/0x298
      dpm_suspend_start+0x84/0xb4
      suspend_devices_and_enter+0xbc/0x620
      pm_suspend+0x210/0x348
      state_store+0xb0/0x108
      kobj_attr_store+0x14/0x24
      sysfs_kf_write+0x4c/0x64
      kernfs_fop_write+0x15c/0x1fc
      __vfs_write+0x54/0x18c
      vfs_write+0xe4/0x1a4
      ksys_write+0x7c/0xe4
      __arm64_sys_write+0x20/0x2c
      el0_svc_common+0xa8/0x160
      el0_svc_handler+0x7c/0x98
      el0_svc+0x8/0xc
    
    Set a lockdep class when we map the irq so that irq_set_wake() doesn't
    warn about a lockdep bug that doesn't exist.
    
    Fixes: 12a9eeaebba3 ("spmi: pmic-arb: convert to v2 irq interfaces to support hierarchical IRQ chips")
    Cc: Douglas Anderson <dianders@chromium.org>
    Cc: Brian Masney <masneyb@onstation.org>
    Cc: Lina Iyer <ilina@codeaurora.org>
    Cc: Maulik Shah <mkshah@codeaurora.org>
    Cc: Bjorn Andersson <bjorn.andersson@linaro.org>
    Signed-off-by: Stephen Boyd <swboyd@chromium.org>
    Link: https://lore.kernel.org/r/20200121183748.68662-1-swboyd@chromium.org
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 1d2a31baf6b620663367dfa0cfcc39bf3f56338d
Author: Stephen Boyd <swboyd@chromium.org>
Date:   Tue Jan 21 10:37:48 2020 -0800

    spmi: pmic-arb: Set lockdep class for hierarchical irq domains
    
    commit 2d5a2f913b658a7ae984773a63318ed4daadf4af upstream.
    
    I see the following lockdep splat in the qcom pinctrl driver when
    attempting to suspend the device.
    
     WARNING: possible recursive locking detected
     5.4.11 #3 Tainted: G        W
     --------------------------------------------
     cat/3074 is trying to acquire lock:
     ffffff81f49804c0 (&irq_desc_lock_class){-.-.}, at: __irq_get_desc_lock+0x64/0x94
    
     but task is already holding lock:
     ffffff81f1cc10c0 (&irq_desc_lock_class){-.-.}, at: __irq_get_desc_lock+0x64/0x94
    
     other info that might help us debug this:
      Possible unsafe locking scenario:
    
            CPU0
            ----
       lock(&irq_desc_lock_class);
       lock(&irq_desc_lock_class);
    
      *** DEADLOCK ***
    
      May be due to missing lock nesting notation
    
     6 locks held by cat/3074:
      #0: ffffff81f01d9420 (sb_writers#7){.+.+}, at: vfs_write+0xd0/0x1a4
      #1: ffffff81bd7d2080 (&of->mutex){+.+.}, at: kernfs_fop_write+0x12c/0x1fc
      #2: ffffff81f4c322f0 (kn->count#337){.+.+}, at: kernfs_fop_write+0x134/0x1fc
      #3: ffffffe411a41d60 (system_transition_mutex){+.+.}, at: pm_suspend+0x108/0x348
      #4: ffffff81f1c5e970 (&dev->mutex){....}, at: __device_suspend+0x168/0x41c
      #5: ffffff81f1cc10c0 (&irq_desc_lock_class){-.-.}, at: __irq_get_desc_lock+0x64/0x94
    
     stack backtrace:
     CPU: 5 PID: 3074 Comm: cat Tainted: G        W         5.4.11 #3
     Hardware name: Google Cheza (rev3+) (DT)
     Call trace:
      dump_backtrace+0x0/0x174
      show_stack+0x20/0x2c
      dump_stack+0xc8/0x124
      __lock_acquire+0x460/0x2388
      lock_acquire+0x1cc/0x210
      _raw_spin_lock_irqsave+0x64/0x80
      __irq_get_desc_lock+0x64/0x94
      irq_set_irq_wake+0x40/0x144
      qpnpint_irq_set_wake+0x28/0x34
      set_irq_wake_real+0x40/0x5c
      irq_set_irq_wake+0x70/0x144
      pm8941_pwrkey_suspend+0x34/0x44
      platform_pm_suspend+0x34/0x60
      dpm_run_callback+0x64/0xcc
      __device_suspend+0x310/0x41c
      dpm_suspend+0xf8/0x298
      dpm_suspend_start+0x84/0xb4
      suspend_devices_and_enter+0xbc/0x620
      pm_suspend+0x210/0x348
      state_store+0xb0/0x108
      kobj_attr_store+0x14/0x24
      sysfs_kf_write+0x4c/0x64
      kernfs_fop_write+0x15c/0x1fc
      __vfs_write+0x54/0x18c
      vfs_write+0xe4/0x1a4
      ksys_write+0x7c/0xe4
      __arm64_sys_write+0x20/0x2c
      el0_svc_common+0xa8/0x160
      el0_svc_handler+0x7c/0x98
      el0_svc+0x8/0xc
    
    Set a lockdep class when we map the irq so that irq_set_wake() doesn't
    warn about a lockdep bug that doesn't exist.
    
    Fixes: 12a9eeaebba3 ("spmi: pmic-arb: convert to v2 irq interfaces to support hierarchical IRQ chips")
    Cc: Douglas Anderson <dianders@chromium.org>
    Cc: Brian Masney <masneyb@onstation.org>
    Cc: Lina Iyer <ilina@codeaurora.org>
    Cc: Maulik Shah <mkshah@codeaurora.org>
    Cc: Bjorn Andersson <bjorn.andersson@linaro.org>
    Signed-off-by: Stephen Boyd <swboyd@chromium.org>
    Link: https://lore.kernel.org/r/20200121183748.68662-1-swboyd@chromium.org
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit e13208ab5d938e51e46ba44a1dec8073142c3d8c
Author: Claudiu Beznea <claudiu.beznea@microchip.com>
Date:   Mon Jan 20 14:10:06 2020 +0200

    clk: at91: move sam9x60's PLL register offsets to PMC header
    
    Move SAM9X60's PLL register offsets to PMC header so that the
    definitions would also be available from arch/arm/mach-at91/pm_suspend.S.
    This is necessary to disable/enable PLLA for SAM9X60 on suspend/resume.
    
    Signed-off-by: Claudiu Beznea <claudiu.beznea@microchip.com>
    Acked-by: Stephen Boyd <sboyd@kernel.org>
    Signed-off-by: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Link: https://lore.kernel.org/r/1579522208-19523-7-git-send-email-claudiu.beznea@microchip.com

commit 4a877560fe047c08b31e698a2668878bbead5f35
Author: Claudiu Beznea <claudiu.beznea@microchip.com>
Date:   Mon Jan 20 14:10:05 2020 +0200

    ARM: at91: pm: s/sfr/sfrbu in pm_suspend.S
    
    s/sfr/sfrbu in pm_suspend.S.
    
    Signed-off-by: Claudiu Beznea <claudiu.beznea@microchip.com>
    Signed-off-by: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Link: https://lore.kernel.org/r/1579522208-19523-6-git-send-email-claudiu.beznea@microchip.com

commit 6ec1587b5c172f53ff27e8c00e6ff9927d2650d4
Author: Claudiu Beznea <claudiu.beznea@microchip.com>
Date:   Mon Jan 20 14:10:01 2020 +0200

    ARM: at91: pm: use proper master clock register offset
    
    SAM9X60's PMC has different master clock register offset than the other
    SoCs' PMC. Due to this, specify master clock register offset based
    on PMC compatible and pass it to pm_suspend.S since it is also needed
    in there. When PM part for SAM9X60 was published the SAM9X60's PMC
    (commit f6deae46039c ("clk: at91: add sam9x60 pmc driver")) wasn't
    integrated.
    
    Fixes: 01c7031cfa73 ("ARM: at91: pm: initial PM support for SAM9X60")
    Signed-off-by: Claudiu Beznea <claudiu.beznea@microchip.com>
    Signed-off-by: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Link: https://lore.kernel.org/r/1579522208-19523-2-git-send-email-claudiu.beznea@microchip.com

commit 1e9353e5079e5e00d85b34d9ba9bb5351a931ee4
Author: Stephen Boyd <swboyd@chromium.org>
Date:   Tue Jan 21 10:09:50 2020 -0800

    pinctrl: qcom: Don't lock around irq_set_irq_wake()
    
    commit 1d44616e7549d0154c1224a3eee3c407029294dc upstream.
    
    We don't need to hold the local pinctrl lock here to set irq wake on the
    summary irq line. Doing so only leads to lockdep warnings instead of
    protecting us from anything. Remove the locking.
    
     WARNING: possible circular locking dependency detected
     5.4.11 #2 Tainted: G        W
     ------------------------------------------------------
     cat/3083 is trying to acquire lock:
     ffffff81f4fa58c0 (&irq_desc_lock_class){-.-.}, at: __irq_get_desc_lock+0x64/0x94
    
     but task is already holding lock:
     ffffff81f4880c18 (&pctrl->lock){-.-.}, at: msm_gpio_irq_set_wake+0x48/0x7c
    
     which lock already depends on the new lock.
    
     the existing dependency chain (in reverse order) is:
    
     -> #1 (&pctrl->lock){-.-.}:
            _raw_spin_lock_irqsave+0x64/0x80
            msm_gpio_irq_ack+0x68/0xf4
            __irq_do_set_handler+0xe0/0x180
            __irq_set_handler+0x60/0x9c
            irq_domain_set_info+0x90/0xb4
            gpiochip_hierarchy_irq_domain_alloc+0x110/0x200
            __irq_domain_alloc_irqs+0x130/0x29c
            irq_create_fwspec_mapping+0x1f0/0x300
            irq_create_of_mapping+0x70/0x98
            of_irq_get+0xa4/0xd4
            spi_drv_probe+0x4c/0xb0
            really_probe+0x138/0x3f0
            driver_probe_device+0x70/0x140
            __device_attach_driver+0x9c/0x110
            bus_for_each_drv+0x88/0xd0
            __device_attach+0xb0/0x160
            device_initial_probe+0x20/0x2c
            bus_probe_device+0x34/0x94
            device_add+0x35c/0x3f0
            spi_add_device+0xbc/0x194
            of_register_spi_devices+0x2c8/0x408
            spi_register_controller+0x57c/0x6fc
            spi_geni_probe+0x260/0x328
            platform_drv_probe+0x90/0xb0
            really_probe+0x138/0x3f0
            driver_probe_device+0x70/0x140
            device_driver_attach+0x4c/0x6c
            __driver_attach+0xcc/0x154
            bus_for_each_dev+0x84/0xcc
            driver_attach+0x2c/0x38
            bus_add_driver+0x108/0x1fc
            driver_register+0x64/0xf8
            __platform_driver_register+0x4c/0x58
            spi_geni_driver_init+0x1c/0x24
            do_one_initcall+0x1a4/0x3e8
            do_initcall_level+0xb4/0xcc
            do_basic_setup+0x30/0x48
            kernel_init_freeable+0x124/0x1a8
            kernel_init+0x14/0x100
            ret_from_fork+0x10/0x18
    
     -> #0 (&irq_desc_lock_class){-.-.}:
            __lock_acquire+0xeb4/0x2388
            lock_acquire+0x1cc/0x210
            _raw_spin_lock_irqsave+0x64/0x80
            __irq_get_desc_lock+0x64/0x94
            irq_set_irq_wake+0x40/0x144
            msm_gpio_irq_set_wake+0x5c/0x7c
            set_irq_wake_real+0x40/0x5c
            irq_set_irq_wake+0x70/0x144
            cros_ec_rtc_suspend+0x38/0x4c
            platform_pm_suspend+0x34/0x60
            dpm_run_callback+0x64/0xcc
            __device_suspend+0x310/0x41c
            dpm_suspend+0xf8/0x298
            dpm_suspend_start+0x84/0xb4
            suspend_devices_and_enter+0xbc/0x620
            pm_suspend+0x210/0x348
            state_store+0xb0/0x108
            kobj_attr_store+0x14/0x24
            sysfs_kf_write+0x4c/0x64
            kernfs_fop_write+0x15c/0x1fc
            __vfs_write+0x54/0x18c
            vfs_write+0xe4/0x1a4
            ksys_write+0x7c/0xe4
            __arm64_sys_write+0x20/0x2c
            el0_svc_common+0xa8/0x160
            el0_svc_handler+0x7c/0x98
            el0_svc+0x8/0xc
    
     other info that might help us debug this:
    
      Possible unsafe locking scenario:
    
            CPU0                    CPU1
            ----                    ----
       lock(&pctrl->lock);
                                    lock(&irq_desc_lock_class);
                                    lock(&pctrl->lock);
       lock(&irq_desc_lock_class);
    
      *** DEADLOCK ***
    
     7 locks held by cat/3083:
      #0: ffffff81f06d1420 (sb_writers#7){.+.+}, at: vfs_write+0xd0/0x1a4
      #1: ffffff81c8935680 (&of->mutex){+.+.}, at: kernfs_fop_write+0x12c/0x1fc
      #2: ffffff81f4c322f0 (kn->count#337){.+.+}, at: kernfs_fop_write+0x134/0x1fc
      #3: ffffffe89a641d60 (system_transition_mutex){+.+.}, at: pm_suspend+0x108/0x348
      #4: ffffff81f190e970 (&dev->mutex){....}, at: __device_suspend+0x168/0x41c
      #5: ffffff81f183d8c0 (lock_class){-.-.}, at: __irq_get_desc_lock+0x64/0x94
      #6: ffffff81f4880c18 (&pctrl->lock){-.-.}, at: msm_gpio_irq_set_wake+0x48/0x7c
    
     stack backtrace:
     CPU: 4 PID: 3083 Comm: cat Tainted: G        W         5.4.11 #2
     Hardware name: Google Cheza (rev3+) (DT)
     Call trace:
      dump_backtrace+0x0/0x174
      show_stack+0x20/0x2c
      dump_stack+0xc8/0x124
      print_circular_bug+0x2ac/0x2c4
      check_noncircular+0x1a0/0x1a8
      __lock_acquire+0xeb4/0x2388
      lock_acquire+0x1cc/0x210
      _raw_spin_lock_irqsave+0x64/0x80
      __irq_get_desc_lock+0x64/0x94
      irq_set_irq_wake+0x40/0x144
      msm_gpio_irq_set_wake+0x5c/0x7c
      set_irq_wake_real+0x40/0x5c
      irq_set_irq_wake+0x70/0x144
      cros_ec_rtc_suspend+0x38/0x4c
      platform_pm_suspend+0x34/0x60
      dpm_run_callback+0x64/0xcc
      __device_suspend+0x310/0x41c
      dpm_suspend+0xf8/0x298
      dpm_suspend_start+0x84/0xb4
      suspend_devices_and_enter+0xbc/0x620
      pm_suspend+0x210/0x348
      state_store+0xb0/0x108
      kobj_attr_store+0x14/0x24
      sysfs_kf_write+0x4c/0x64
      kernfs_fop_write+0x15c/0x1fc
      __vfs_write+0x54/0x18c
      vfs_write+0xe4/0x1a4
      ksys_write+0x7c/0xe4
      __arm64_sys_write+0x20/0x2c
      el0_svc_common+0xa8/0x160
      el0_svc_handler+0x7c/0x98
      el0_svc+0x8/0xc
    
    Fixes: 6aced33f4974 ("pinctrl: msm: drop wake_irqs bitmap")
    Cc: Douglas Anderson <dianders@chromium.org>
    Cc: Brian Masney <masneyb@onstation.org>
    Cc: Lina Iyer <ilina@codeaurora.org>
    Cc: Maulik Shah <mkshah@codeaurora.org>
    Signed-off-by: Stephen Boyd <swboyd@chromium.org>
    Link: https://lore.kernel.org/r/20200121180950.36959-1-swboyd@chromium.org
    Reviewed-by: Bjorn Andersson <bjorn.andersson@linaro.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 9cc68ee1d92e3ab5bd5c821e5c1f387b0e16a669
Author: Jordan Crouse <jcrouse@codeaurora.org>
Date:   Wed Feb 5 13:48:17 2020 -0700

    drm/msm: Fix a6xx GMU shutdown sequence
    
    Commit e812744c5f95 ("drm: msm: a6xx: Add support for A618") missed
    updating the VBIF flush in a6xx_gmu_shutdown and instead
    inserted the new sequence into a6xx_pm_suspend along with a redundant
    GMU idle.
    
    Move a6xx_bus_clear_pending_transactions to a6xx_gmu.c and use it in
    the appropriate place in the shutdown routine and remove the redundant
    idle call.
    
    v2: Remove newly unused variable that was triggering a warning
    
    Signed-off-by: Jordan Crouse <jcrouse@codeaurora.org>
    Reviewed-by: Rob Clark <robdclark@gmail.com>
    Fixes: e812744c5f95 ("drm: msm: a6xx: Add support for A618")
    Tested-by: Douglas Anderson <dianders@chromium.org>
    Signed-off-by: Rob Clark <robdclark@chromium.org>

commit 2d5a2f913b658a7ae984773a63318ed4daadf4af
Author: Stephen Boyd <swboyd@chromium.org>
Date:   Tue Jan 21 10:37:48 2020 -0800

    spmi: pmic-arb: Set lockdep class for hierarchical irq domains
    
    I see the following lockdep splat in the qcom pinctrl driver when
    attempting to suspend the device.
    
     WARNING: possible recursive locking detected
     5.4.11 #3 Tainted: G        W
     --------------------------------------------
     cat/3074 is trying to acquire lock:
     ffffff81f49804c0 (&irq_desc_lock_class){-.-.}, at: __irq_get_desc_lock+0x64/0x94
    
     but task is already holding lock:
     ffffff81f1cc10c0 (&irq_desc_lock_class){-.-.}, at: __irq_get_desc_lock+0x64/0x94
    
     other info that might help us debug this:
      Possible unsafe locking scenario:
    
            CPU0
            ----
       lock(&irq_desc_lock_class);
       lock(&irq_desc_lock_class);
    
      *** DEADLOCK ***
    
      May be due to missing lock nesting notation
    
     6 locks held by cat/3074:
      #0: ffffff81f01d9420 (sb_writers#7){.+.+}, at: vfs_write+0xd0/0x1a4
      #1: ffffff81bd7d2080 (&of->mutex){+.+.}, at: kernfs_fop_write+0x12c/0x1fc
      #2: ffffff81f4c322f0 (kn->count#337){.+.+}, at: kernfs_fop_write+0x134/0x1fc
      #3: ffffffe411a41d60 (system_transition_mutex){+.+.}, at: pm_suspend+0x108/0x348
      #4: ffffff81f1c5e970 (&dev->mutex){....}, at: __device_suspend+0x168/0x41c
      #5: ffffff81f1cc10c0 (&irq_desc_lock_class){-.-.}, at: __irq_get_desc_lock+0x64/0x94
    
     stack backtrace:
     CPU: 5 PID: 3074 Comm: cat Tainted: G        W         5.4.11 #3
     Hardware name: Google Cheza (rev3+) (DT)
     Call trace:
      dump_backtrace+0x0/0x174
      show_stack+0x20/0x2c
      dump_stack+0xc8/0x124
      __lock_acquire+0x460/0x2388
      lock_acquire+0x1cc/0x210
      _raw_spin_lock_irqsave+0x64/0x80
      __irq_get_desc_lock+0x64/0x94
      irq_set_irq_wake+0x40/0x144
      qpnpint_irq_set_wake+0x28/0x34
      set_irq_wake_real+0x40/0x5c
      irq_set_irq_wake+0x70/0x144
      pm8941_pwrkey_suspend+0x34/0x44
      platform_pm_suspend+0x34/0x60
      dpm_run_callback+0x64/0xcc
      __device_suspend+0x310/0x41c
      dpm_suspend+0xf8/0x298
      dpm_suspend_start+0x84/0xb4
      suspend_devices_and_enter+0xbc/0x620
      pm_suspend+0x210/0x348
      state_store+0xb0/0x108
      kobj_attr_store+0x14/0x24
      sysfs_kf_write+0x4c/0x64
      kernfs_fop_write+0x15c/0x1fc
      __vfs_write+0x54/0x18c
      vfs_write+0xe4/0x1a4
      ksys_write+0x7c/0xe4
      __arm64_sys_write+0x20/0x2c
      el0_svc_common+0xa8/0x160
      el0_svc_handler+0x7c/0x98
      el0_svc+0x8/0xc
    
    Set a lockdep class when we map the irq so that irq_set_wake() doesn't
    warn about a lockdep bug that doesn't exist.
    
    Fixes: 12a9eeaebba3 ("spmi: pmic-arb: convert to v2 irq interfaces to support hierarchical IRQ chips")
    Cc: Douglas Anderson <dianders@chromium.org>
    Cc: Brian Masney <masneyb@onstation.org>
    Cc: Lina Iyer <ilina@codeaurora.org>
    Cc: Maulik Shah <mkshah@codeaurora.org>
    Cc: Bjorn Andersson <bjorn.andersson@linaro.org>
    Signed-off-by: Stephen Boyd <swboyd@chromium.org>
    Link: https://lore.kernel.org/r/20200121183748.68662-1-swboyd@chromium.org
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

commit d6a91833c6ed8a95ad1b4a5e2364bb6d4a039f25
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Feb 1 01:49:14 2019 +0100

    driver core: Fix handling of runtime PM flags in device_link_add()
    
    [ Upstream commit e2f3cd831a280fc226118d9369bf3f77aab58c56 ]
    
    After commit ead18c23c263 ("driver core: Introduce device links
    reference counting"), if there is a link between the given supplier
    and the given consumer already, device_link_add() will refcount it
    and return it unconditionally without updating its flags.  It is
    possible, however, that the second (or any subsequent) caller of
    device_link_add() for the same consumer-supplier pair will pass
    DL_FLAG_PM_RUNTIME, possibly along with DL_FLAG_RPM_ACTIVE, in flags
    to it and the existing link may not behave as expected then.
    
    First, if DL_FLAG_PM_RUNTIME is not set in the existing link's flags
    at all, it needs to be set like during the original initialization of
    the link.
    
    Second, if DL_FLAG_RPM_ACTIVE is passed to device_link_add() in flags
    (in addition to DL_FLAG_PM_RUNTIME), the existing link should to be
    updated to reflect the "active" runtime PM configuration of the
    consumer-supplier pair and extra care must be taken here to avoid
    possible destructive races with runtime PM of the consumer.
    
    To that end, redefine the rpm_active field in struct device_link
    as a refcount, initialize it to 1 and make rpm_resume() (for the
    consumer) and device_link_add() increment it whenever they acquire
    a runtime PM reference on the supplier device.  Accordingly, make
    rpm_suspend() (for the consumer) and pm_runtime_clean_up_links()
    decrement it and drop runtime PM references to the supplier
    device in a loop until rpm_active becones 1 again.
    
    Fixes: ead18c23c263 ("driver core: Introduce device links reference counting")
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 1d44616e7549d0154c1224a3eee3c407029294dc
Author: Stephen Boyd <swboyd@chromium.org>
Date:   Tue Jan 21 10:09:50 2020 -0800

    pinctrl: qcom: Don't lock around irq_set_irq_wake()
    
    We don't need to hold the local pinctrl lock here to set irq wake on the
    summary irq line. Doing so only leads to lockdep warnings instead of
    protecting us from anything. Remove the locking.
    
     WARNING: possible circular locking dependency detected
     5.4.11 #2 Tainted: G        W
     ------------------------------------------------------
     cat/3083 is trying to acquire lock:
     ffffff81f4fa58c0 (&irq_desc_lock_class){-.-.}, at: __irq_get_desc_lock+0x64/0x94
    
     but task is already holding lock:
     ffffff81f4880c18 (&pctrl->lock){-.-.}, at: msm_gpio_irq_set_wake+0x48/0x7c
    
     which lock already depends on the new lock.
    
     the existing dependency chain (in reverse order) is:
    
     -> #1 (&pctrl->lock){-.-.}:
            _raw_spin_lock_irqsave+0x64/0x80
            msm_gpio_irq_ack+0x68/0xf4
            __irq_do_set_handler+0xe0/0x180
            __irq_set_handler+0x60/0x9c
            irq_domain_set_info+0x90/0xb4
            gpiochip_hierarchy_irq_domain_alloc+0x110/0x200
            __irq_domain_alloc_irqs+0x130/0x29c
            irq_create_fwspec_mapping+0x1f0/0x300
            irq_create_of_mapping+0x70/0x98
            of_irq_get+0xa4/0xd4
            spi_drv_probe+0x4c/0xb0
            really_probe+0x138/0x3f0
            driver_probe_device+0x70/0x140
            __device_attach_driver+0x9c/0x110
            bus_for_each_drv+0x88/0xd0
            __device_attach+0xb0/0x160
            device_initial_probe+0x20/0x2c
            bus_probe_device+0x34/0x94
            device_add+0x35c/0x3f0
            spi_add_device+0xbc/0x194
            of_register_spi_devices+0x2c8/0x408
            spi_register_controller+0x57c/0x6fc
            spi_geni_probe+0x260/0x328
            platform_drv_probe+0x90/0xb0
            really_probe+0x138/0x3f0
            driver_probe_device+0x70/0x140
            device_driver_attach+0x4c/0x6c
            __driver_attach+0xcc/0x154
            bus_for_each_dev+0x84/0xcc
            driver_attach+0x2c/0x38
            bus_add_driver+0x108/0x1fc
            driver_register+0x64/0xf8
            __platform_driver_register+0x4c/0x58
            spi_geni_driver_init+0x1c/0x24
            do_one_initcall+0x1a4/0x3e8
            do_initcall_level+0xb4/0xcc
            do_basic_setup+0x30/0x48
            kernel_init_freeable+0x124/0x1a8
            kernel_init+0x14/0x100
            ret_from_fork+0x10/0x18
    
     -> #0 (&irq_desc_lock_class){-.-.}:
            __lock_acquire+0xeb4/0x2388
            lock_acquire+0x1cc/0x210
            _raw_spin_lock_irqsave+0x64/0x80
            __irq_get_desc_lock+0x64/0x94
            irq_set_irq_wake+0x40/0x144
            msm_gpio_irq_set_wake+0x5c/0x7c
            set_irq_wake_real+0x40/0x5c
            irq_set_irq_wake+0x70/0x144
            cros_ec_rtc_suspend+0x38/0x4c
            platform_pm_suspend+0x34/0x60
            dpm_run_callback+0x64/0xcc
            __device_suspend+0x310/0x41c
            dpm_suspend+0xf8/0x298
            dpm_suspend_start+0x84/0xb4
            suspend_devices_and_enter+0xbc/0x620
            pm_suspend+0x210/0x348
            state_store+0xb0/0x108
            kobj_attr_store+0x14/0x24
            sysfs_kf_write+0x4c/0x64
            kernfs_fop_write+0x15c/0x1fc
            __vfs_write+0x54/0x18c
            vfs_write+0xe4/0x1a4
            ksys_write+0x7c/0xe4
            __arm64_sys_write+0x20/0x2c
            el0_svc_common+0xa8/0x160
            el0_svc_handler+0x7c/0x98
            el0_svc+0x8/0xc
    
     other info that might help us debug this:
    
      Possible unsafe locking scenario:
    
            CPU0                    CPU1
            ----                    ----
       lock(&pctrl->lock);
                                    lock(&irq_desc_lock_class);
                                    lock(&pctrl->lock);
       lock(&irq_desc_lock_class);
    
      *** DEADLOCK ***
    
     7 locks held by cat/3083:
      #0: ffffff81f06d1420 (sb_writers#7){.+.+}, at: vfs_write+0xd0/0x1a4
      #1: ffffff81c8935680 (&of->mutex){+.+.}, at: kernfs_fop_write+0x12c/0x1fc
      #2: ffffff81f4c322f0 (kn->count#337){.+.+}, at: kernfs_fop_write+0x134/0x1fc
      #3: ffffffe89a641d60 (system_transition_mutex){+.+.}, at: pm_suspend+0x108/0x348
      #4: ffffff81f190e970 (&dev->mutex){....}, at: __device_suspend+0x168/0x41c
      #5: ffffff81f183d8c0 (lock_class){-.-.}, at: __irq_get_desc_lock+0x64/0x94
      #6: ffffff81f4880c18 (&pctrl->lock){-.-.}, at: msm_gpio_irq_set_wake+0x48/0x7c
    
     stack backtrace:
     CPU: 4 PID: 3083 Comm: cat Tainted: G        W         5.4.11 #2
     Hardware name: Google Cheza (rev3+) (DT)
     Call trace:
      dump_backtrace+0x0/0x174
      show_stack+0x20/0x2c
      dump_stack+0xc8/0x124
      print_circular_bug+0x2ac/0x2c4
      check_noncircular+0x1a0/0x1a8
      __lock_acquire+0xeb4/0x2388
      lock_acquire+0x1cc/0x210
      _raw_spin_lock_irqsave+0x64/0x80
      __irq_get_desc_lock+0x64/0x94
      irq_set_irq_wake+0x40/0x144
      msm_gpio_irq_set_wake+0x5c/0x7c
      set_irq_wake_real+0x40/0x5c
      irq_set_irq_wake+0x70/0x144
      cros_ec_rtc_suspend+0x38/0x4c
      platform_pm_suspend+0x34/0x60
      dpm_run_callback+0x64/0xcc
      __device_suspend+0x310/0x41c
      dpm_suspend+0xf8/0x298
      dpm_suspend_start+0x84/0xb4
      suspend_devices_and_enter+0xbc/0x620
      pm_suspend+0x210/0x348
      state_store+0xb0/0x108
      kobj_attr_store+0x14/0x24
      sysfs_kf_write+0x4c/0x64
      kernfs_fop_write+0x15c/0x1fc
      __vfs_write+0x54/0x18c
      vfs_write+0xe4/0x1a4
      ksys_write+0x7c/0xe4
      __arm64_sys_write+0x20/0x2c
      el0_svc_common+0xa8/0x160
      el0_svc_handler+0x7c/0x98
      el0_svc+0x8/0xc
    
    Fixes: 6aced33f4974 ("pinctrl: msm: drop wake_irqs bitmap")
    Cc: Douglas Anderson <dianders@chromium.org>
    Cc: Brian Masney <masneyb@onstation.org>
    Cc: Lina Iyer <ilina@codeaurora.org>
    Cc: Maulik Shah <mkshah@codeaurora.org>
    Signed-off-by: Stephen Boyd <swboyd@chromium.org>
    Link: https://lore.kernel.org/r/20200121180950.36959-1-swboyd@chromium.org
    Reviewed-by: Bjorn Andersson <bjorn.andersson@linaro.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

commit c34f6dc8c9e6bbe9fba1d53acd6d9a3889599da3
Author: Stephen Boyd <swboyd@chromium.org>
Date:   Tue Jan 14 15:11:03 2020 -0800

    gpiolib: Set lockdep class for hierarchical irq domains
    
    I see the following lockdep splat in the qcom pinctrl driver when
    attempting to suspend the device.
    
     ============================================
     WARNING: possible recursive locking detected
     5.4.2 #2 Tainted: G S
     --------------------------------------------
     cat/6536 is trying to acquire lock:
     ffffff814787ccc0 (&irq_desc_lock_class){-.-.}, at: __irq_get_desc_lock+0x64/0x94
    
     but task is already holding lock:
     ffffff81436740c0 (&irq_desc_lock_class){-.-.}, at: __irq_get_desc_lock+0x64/0x94
    
     other info that might help us debug this:
      Possible unsafe locking scenario:
    
            CPU0
            ----
       lock(&irq_desc_lock_class);
       lock(&irq_desc_lock_class);
    
      *** DEADLOCK ***
    
      May be due to missing lock nesting notation
    
     7 locks held by cat/6536:
      #0: ffffff8140e0c420 (sb_writers#7){.+.+}, at: vfs_write+0xc8/0x19c
      #1: ffffff8121eec480 (&of->mutex){+.+.}, at: kernfs_fop_write+0x128/0x1f4
      #2: ffffff8147cad668 (kn->count#263){.+.+}, at: kernfs_fop_write+0x130/0x1f4
      #3: ffffffd011446000 (system_transition_mutex){+.+.}, at: pm_suspend+0x108/0x354
      #4: ffffff814302b970 (&dev->mutex){....}, at: __device_suspend+0x16c/0x420
      #5: ffffff81436740c0 (&irq_desc_lock_class){-.-.}, at: __irq_get_desc_lock+0x64/0x94
      #6: ffffff81479b8c10 (&pctrl->lock){....}, at: msm_gpio_irq_set_wake+0x48/0x7c
    
     stack backtrace:
     CPU: 4 PID: 6536 Comm: cat Tainted: G S                5.4.2 #2
     Call trace:
      dump_backtrace+0x0/0x174
      show_stack+0x20/0x2c
      dump_stack+0xdc/0x144
      __lock_acquire+0x52c/0x2268
      lock_acquire+0x1dc/0x220
      _raw_spin_lock_irqsave+0x64/0x80
      __irq_get_desc_lock+0x64/0x94
      irq_set_irq_wake+0x40/0x144
      msm_gpio_irq_set_wake+0x5c/0x7c
      set_irq_wake_real+0x40/0x5c
      irq_set_irq_wake+0x70/0x144
      cros_ec_rtc_suspend+0x38/0x4c
      platform_pm_suspend+0x34/0x60
      dpm_run_callback+0x64/0xcc
      __device_suspend+0x314/0x420
      dpm_suspend+0xf8/0x298
      dpm_suspend_start+0x84/0xb4
      suspend_devices_and_enter+0xbc/0x628
      pm_suspend+0x214/0x354
      state_store+0xb0/0x108
      kobj_attr_store+0x14/0x24
      sysfs_kf_write+0x4c/0x64
      kernfs_fop_write+0x158/0x1f4
      __vfs_write+0x54/0x18c
      vfs_write+0xdc/0x19c
      ksys_write+0x7c/0xe4
      __arm64_sys_write+0x20/0x2c
      el0_svc_common+0xa8/0x160
      el0_svc_compat_handler+0x2c/0x38
      el0_svc_compat+0x8/0x10
    
    This is because the msm_gpio_irq_set_wake() function calls
    irq_set_irq_wake() as a backup in case the irq comes in during the path
    to idle. Given that we're calling irqchip functions from within an
    irqchip we need to set the lockdep class to be different for this child
    controller vs. the default one that the parent irqchip gets.
    
    This used to be done before this driver was converted to hierarchical
    irq domains in commit e35a6ae0eb3a ("pinctrl/msm: Setup GPIO chip in
    hierarchy") via the gpiochip_irq_map() function. With hierarchical irq
    domains this function has been replaced by
    gpiochip_hierarchy_irq_domain_alloc(). Therefore, set the lockdep class
    like was done previously in the irq domain path so we can avoid this
    lockdep warning.
    
    Fixes: fdd61a013a24 ("gpio: Add support for hierarchical IRQ domains")
    Cc: Thierry Reding <treding@nvidia.com>
    Cc: Brian Masney <masneyb@onstation.org>
    Cc: Lina Iyer <ilina@codeaurora.org>
    Cc: Marc Zyngier <maz@kernel.org>
    Cc: Maulik Shah <mkshah@codeaurora.org>
    Signed-off-by: Stephen Boyd <swboyd@chromium.org>
    Link: https://lore.kernel.org/r/20200114231103.85641-1-swboyd@chromium.org
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

commit e29242ad813c71e8e6a22c4f13f420a2297ac716
Author: Marek Szyprowski <m.szyprowski@samsung.com>
Date:   Fri Jan 10 11:05:40 2020 +0100

    power: supply: max17040: Correct IRQ wake handling
    
    Don't disable IRQ wake feature without prior enabling it.
    
    This fixes following warning observed on Exynos3250-based Rinato board:
    ------------[ cut here ]------------
    WARNING: CPU: 0 PID: 1288 at kernel/irq/manage.c:724 irq_set_irq_wake+0xfc/0x134
    Unbalanced IRQ 83 wake disable
    Modules linked in:
    CPU: 0 PID: 1288 Comm: rtcwake Not tainted 5.5.0-rc5-next-20200110-00031-g6289fffbb3f5 #7266
    Hardware name: Samsung Exynos (Flattened Device Tree)
    [<c0112e48>] (unwind_backtrace) from [<c010e090>] (show_stack+0x10/0x14)
    [<c010e090>] (show_stack) from [<c0b25b28>] (dump_stack+0xa4/0xd0)
    [<c0b25b28>] (dump_stack) from [<c0128088>] (__warn+0xf4/0x10c)
    [<c0128088>] (__warn) from [<c0128114>] (warn_slowpath_fmt+0x74/0xb8)
    [<c0128114>] (warn_slowpath_fmt) from [<c019e9a0>] (irq_set_irq_wake+0xfc/0x134)
    [<c019e9a0>] (irq_set_irq_wake) from [<c0772708>] (max17040_suspend+0x50/0x58)
    [<c0772708>] (max17040_suspend) from [<c05f55ac>] (dpm_run_callback+0xb4/0x400)
    [<c05f55ac>] (dpm_run_callback) from [<c05f5e38>] (__device_suspend+0x140/0x814)
    [<c05f5e38>] (__device_suspend) from [<c05f9548>] (dpm_suspend+0x16c/0x564)
    [<c05f9548>] (dpm_suspend) from [<c05fa2e4>] (dpm_suspend_start+0x90/0x98)
    [<c05fa2e4>] (dpm_suspend_start) from [<c01977f4>] (suspend_devices_and_enter+0xec/0xc0c)
    [<c01977f4>] (suspend_devices_and_enter) from [<c019862c>] (pm_suspend+0x318/0x3e8)
    [<c019862c>] (pm_suspend) from [<c01963cc>] (state_store+0x68/0xc8)
    [<c01963cc>] (state_store) from [<c03531a4>] (kernfs_fop_write+0x10c/0x220)
    [<c03531a4>] (kernfs_fop_write) from [<c02b44c4>] (__vfs_write+0x2c/0x1c4)
    [<c02b44c4>] (__vfs_write) from [<c02b7288>] (vfs_write+0xa4/0x180)
    [<c02b7288>] (vfs_write) from [<c02b74d0>] (ksys_write+0x58/0xcc)
    [<c02b74d0>] (ksys_write) from [<c0101000>] (ret_fast_syscall+0x0/0x28)
    Exception stack(0xd6e83fa8 to 0xd6e83ff0)
    ...
    irq event stamp: 18028
    hardirqs last  enabled at (18027): [<c014b99c>] cancel_delayed_work+0x84/0xf8
    hardirqs last disabled at (18028): [<c0b49b1c>] _raw_spin_lock_irqsave+0x1c/0x58
    softirqs last  enabled at (17876): [<c01026d8>] __do_softirq+0x4f0/0x5e4
    softirqs last disabled at (17869): [<c0130d34>] irq_exit+0x16c/0x170
    ---[ end trace 0728005730004e60 ]---
    
    Fixes: 2e17ed94de68 ("power: supply: max17040: Add IRQ handler for low SOC alert")
    Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Reviewed-by: Krzysztof Kozlowski <krzk@kernel.org>
    Signed-off-by: Sebastian Reichel <sebastian.reichel@collabora.com>

commit e3b11282495b9530f87a28f5e982d9aaae29c4c9
Author: Kai-Heng Feng <kai.heng.feng@canonical.com>
Date:   Wed Dec 11 16:20:05 2019 +0200

    xhci: Increase STS_HALT timeout in xhci_suspend()
    
    commit 7c67cf6658cec70d8a43229f2ce74ca1443dc95e upstream.
    
    I've recently observed failed xHCI suspend attempt on AMD Raven Ridge
    system:
    kernel: xhci_hcd 0000:04:00.4: WARN: xHC CMD_RUN timeout
    kernel: PM: suspend_common(): xhci_pci_suspend+0x0/0xd0 returns -110
    kernel: PM: pci_pm_suspend(): hcd_pci_suspend+0x0/0x30 returns -110
    kernel: PM: dpm_run_callback(): pci_pm_suspend+0x0/0x150 returns -110
    kernel: PM: Device 0000:04:00.4 failed to suspend async: error -110
    
    Similar to commit ac343366846a ("xhci: Increase STS_SAVE timeout in
    xhci_suspend()") we also need to increase the HALT timeout to make it be
    able to suspend again.
    
    Cc: <stable@vger.kernel.org> # 5.2+
    Fixes: f7fac17ca925 ("xhci: Convert xhci_handshake() to use readl_poll_timeout_atomic()")
    Signed-off-by: Kai-Heng Feng <kai.heng.feng@canonical.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Link: https://lore.kernel.org/r/20191211142007.8847-5-mathias.nyman@linux.intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 88569efc8a66caa73e8c6168406f6f85aaeac432
Author: Kai-Heng Feng <kai.heng.feng@canonical.com>
Date:   Wed Dec 11 16:20:05 2019 +0200

    xhci: Increase STS_HALT timeout in xhci_suspend()
    
    commit 7c67cf6658cec70d8a43229f2ce74ca1443dc95e upstream.
    
    I've recently observed failed xHCI suspend attempt on AMD Raven Ridge
    system:
    kernel: xhci_hcd 0000:04:00.4: WARN: xHC CMD_RUN timeout
    kernel: PM: suspend_common(): xhci_pci_suspend+0x0/0xd0 returns -110
    kernel: PM: pci_pm_suspend(): hcd_pci_suspend+0x0/0x30 returns -110
    kernel: PM: dpm_run_callback(): pci_pm_suspend+0x0/0x150 returns -110
    kernel: PM: Device 0000:04:00.4 failed to suspend async: error -110
    
    Similar to commit ac343366846a ("xhci: Increase STS_SAVE timeout in
    xhci_suspend()") we also need to increase the HALT timeout to make it be
    able to suspend again.
    
    Cc: <stable@vger.kernel.org> # 5.2+
    Fixes: f7fac17ca925 ("xhci: Convert xhci_handshake() to use readl_poll_timeout_atomic()")
    Signed-off-by: Kai-Heng Feng <kai.heng.feng@canonical.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Link: https://lore.kernel.org/r/20191211142007.8847-5-mathias.nyman@linux.intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 6b399e679da42f76abdeab9722e687a61bb581f5
Author: Kai-Heng Feng <kai.heng.feng@canonical.com>
Date:   Wed Dec 11 16:20:05 2019 +0200

    xhci: Increase STS_HALT timeout in xhci_suspend()
    
    commit 7c67cf6658cec70d8a43229f2ce74ca1443dc95e upstream.
    
    I've recently observed failed xHCI suspend attempt on AMD Raven Ridge
    system:
    kernel: xhci_hcd 0000:04:00.4: WARN: xHC CMD_RUN timeout
    kernel: PM: suspend_common(): xhci_pci_suspend+0x0/0xd0 returns -110
    kernel: PM: pci_pm_suspend(): hcd_pci_suspend+0x0/0x30 returns -110
    kernel: PM: dpm_run_callback(): pci_pm_suspend+0x0/0x150 returns -110
    kernel: PM: Device 0000:04:00.4 failed to suspend async: error -110
    
    Similar to commit ac343366846a ("xhci: Increase STS_SAVE timeout in
    xhci_suspend()") we also need to increase the HALT timeout to make it be
    able to suspend again.
    
    Cc: <stable@vger.kernel.org> # 5.2+
    Fixes: f7fac17ca925 ("xhci: Convert xhci_handshake() to use readl_poll_timeout_atomic()")
    Signed-off-by: Kai-Heng Feng <kai.heng.feng@canonical.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Link: https://lore.kernel.org/r/20191211142007.8847-5-mathias.nyman@linux.intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 5ce600f893ec04433aac2e84ba93bcc5fc266c96
Author: Kai-Heng Feng <kai.heng.feng@canonical.com>
Date:   Wed Dec 11 16:20:05 2019 +0200

    xhci: Increase STS_HALT timeout in xhci_suspend()
    
    commit 7c67cf6658cec70d8a43229f2ce74ca1443dc95e upstream.
    
    I've recently observed failed xHCI suspend attempt on AMD Raven Ridge
    system:
    kernel: xhci_hcd 0000:04:00.4: WARN: xHC CMD_RUN timeout
    kernel: PM: suspend_common(): xhci_pci_suspend+0x0/0xd0 returns -110
    kernel: PM: pci_pm_suspend(): hcd_pci_suspend+0x0/0x30 returns -110
    kernel: PM: dpm_run_callback(): pci_pm_suspend+0x0/0x150 returns -110
    kernel: PM: Device 0000:04:00.4 failed to suspend async: error -110
    
    Similar to commit ac343366846a ("xhci: Increase STS_SAVE timeout in
    xhci_suspend()") we also need to increase the HALT timeout to make it be
    able to suspend again.
    
    Cc: <stable@vger.kernel.org> # 5.2+
    Fixes: f7fac17ca925 ("xhci: Convert xhci_handshake() to use readl_poll_timeout_atomic()")
    Signed-off-by: Kai-Heng Feng <kai.heng.feng@canonical.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Link: https://lore.kernel.org/r/20191211142007.8847-5-mathias.nyman@linux.intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit c9382a9ac1db15cd9c507e34c16177be1f3d2376
Author: Kai-Heng Feng <kai.heng.feng@canonical.com>
Date:   Wed Dec 11 16:20:05 2019 +0200

    xhci: Increase STS_HALT timeout in xhci_suspend()
    
    commit 7c67cf6658cec70d8a43229f2ce74ca1443dc95e upstream.
    
    I've recently observed failed xHCI suspend attempt on AMD Raven Ridge
    system:
    kernel: xhci_hcd 0000:04:00.4: WARN: xHC CMD_RUN timeout
    kernel: PM: suspend_common(): xhci_pci_suspend+0x0/0xd0 returns -110
    kernel: PM: pci_pm_suspend(): hcd_pci_suspend+0x0/0x30 returns -110
    kernel: PM: dpm_run_callback(): pci_pm_suspend+0x0/0x150 returns -110
    kernel: PM: Device 0000:04:00.4 failed to suspend async: error -110
    
    Similar to commit ac343366846a ("xhci: Increase STS_SAVE timeout in
    xhci_suspend()") we also need to increase the HALT timeout to make it be
    able to suspend again.
    
    Cc: <stable@vger.kernel.org> # 5.2+
    Fixes: f7fac17ca925 ("xhci: Convert xhci_handshake() to use readl_poll_timeout_atomic()")
    Signed-off-by: Kai-Heng Feng <kai.heng.feng@canonical.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Link: https://lore.kernel.org/r/20191211142007.8847-5-mathias.nyman@linux.intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 89071f7513d5a92943cbd481d28003e5b617eec6
Author: Kai-Heng Feng <kai.heng.feng@canonical.com>
Date:   Wed Dec 11 16:20:05 2019 +0200

    xhci: Increase STS_HALT timeout in xhci_suspend()
    
    commit 7c67cf6658cec70d8a43229f2ce74ca1443dc95e upstream.
    
    I've recently observed failed xHCI suspend attempt on AMD Raven Ridge
    system:
    kernel: xhci_hcd 0000:04:00.4: WARN: xHC CMD_RUN timeout
    kernel: PM: suspend_common(): xhci_pci_suspend+0x0/0xd0 returns -110
    kernel: PM: pci_pm_suspend(): hcd_pci_suspend+0x0/0x30 returns -110
    kernel: PM: dpm_run_callback(): pci_pm_suspend+0x0/0x150 returns -110
    kernel: PM: Device 0000:04:00.4 failed to suspend async: error -110
    
    Similar to commit ac343366846a ("xhci: Increase STS_SAVE timeout in
    xhci_suspend()") we also need to increase the HALT timeout to make it be
    able to suspend again.
    
    Cc: <stable@vger.kernel.org> # 5.2+
    Fixes: f7fac17ca925 ("xhci: Convert xhci_handshake() to use readl_poll_timeout_atomic()")
    Signed-off-by: Kai-Heng Feng <kai.heng.feng@canonical.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Link: https://lore.kernel.org/r/20191211142007.8847-5-mathias.nyman@linux.intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 7c67cf6658cec70d8a43229f2ce74ca1443dc95e
Author: Kai-Heng Feng <kai.heng.feng@canonical.com>
Date:   Wed Dec 11 16:20:05 2019 +0200

    xhci: Increase STS_HALT timeout in xhci_suspend()
    
    I've recently observed failed xHCI suspend attempt on AMD Raven Ridge
    system:
    kernel: xhci_hcd 0000:04:00.4: WARN: xHC CMD_RUN timeout
    kernel: PM: suspend_common(): xhci_pci_suspend+0x0/0xd0 returns -110
    kernel: PM: pci_pm_suspend(): hcd_pci_suspend+0x0/0x30 returns -110
    kernel: PM: dpm_run_callback(): pci_pm_suspend+0x0/0x150 returns -110
    kernel: PM: Device 0000:04:00.4 failed to suspend async: error -110
    
    Similar to commit ac343366846a ("xhci: Increase STS_SAVE timeout in
    xhci_suspend()") we also need to increase the HALT timeout to make it be
    able to suspend again.
    
    Cc: <stable@vger.kernel.org> # 5.2+
    Fixes: f7fac17ca925 ("xhci: Convert xhci_handshake() to use readl_poll_timeout_atomic()")
    Signed-off-by: Kai-Heng Feng <kai.heng.feng@canonical.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Link: https://lore.kernel.org/r/20191211142007.8847-5-mathias.nyman@linux.intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit f68190c8cb753b0d150daa9d5e2b72ca0dfecf5c
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Thu Dec 5 15:37:46 2019 +0100

    dmaengine: pl330: Convert to the *_late and *_early system sleep callbacks
    
    It has turned out that it's in general a good idea for dmaengines to allow
    DMA requests during the entire dpm_suspend() phase. Therefore, convert the
    pl330 driver into using SET_LATE_SYSTEM_SLEEP_PM_OPS.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Tested-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Link: https://lore.kernel.org/r/20191205143746.24873-3-ulf.hansson@linaro.org
    Signed-off-by: Vinod Koul <vkoul@kernel.org>

commit 5b07222df0e9c2ecee316bcec2f9b3c2ecb937dd
Author: Bo Yan <byan@nvidia.com>
Date:   Tue Jan 23 13:57:55 2018 -0800

    cpufreq: Skip cpufreq resume if it's not suspended
    
    commit 703cbaa601ff3fb554d1246c336ba727cc083ea0 upstream.
    
    cpufreq_resume can be called even without preceding cpufreq_suspend.
    This can happen in following scenario:
    
        suspend_devices_and_enter
           --> dpm_suspend_start
              --> dpm_prepare
                  --> device_prepare : this function errors out
              --> dpm_suspend: this is skipped due to dpm_prepare failure
                               this means cpufreq_suspend is skipped over
           --> goto Recover_platform, due to previous error
           --> goto Resume_devices
           --> dpm_resume_end
               --> dpm_resume
                   --> cpufreq_resume
    
    In case schedutil is used as frequency governor, cpufreq_resume will
    eventually call sugov_start, which does following:
    
        memset(sg_cpu, 0, sizeof(*sg_cpu));
        ....
    
    This effectively erases function pointer for frequency update, causing
    crash later on. The function pointer would have been set correctly if
    subsequent cpufreq_add_update_util_hook runs successfully, but that
    function returns earlier because cpufreq_suspend was not called:
    
        if (WARN_ON(per_cpu(cpufreq_update_util_data, cpu)))
                    return;
    
    The fix is to check cpufreq_suspended first, if it's false, that means
    cpufreq_suspend was not called in the first place, so do not resume
    cpufreq.
    
    Signed-off-by: Bo Yan <byan@nvidia.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    [ rjw: Dropped printing a message ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit e1e047ace8cef6d143f38c7d769753f133becbe6
Author: Marek Szyprowski <m.szyprowski@samsung.com>
Date:   Tue Nov 12 11:47:34 2019 +0100

    PM / devfreq: Add missing locking while setting suspend_freq
    
    Commit 2abb0d5268ae ("PM / devfreq: Lock devfreq in trans_stat_show")
    revealed a missing locking while calling devfreq_update_status() function
    during suspend/resume cycle.
    
    Code analysis revealed that devfreq_set_target() function was called
    without needed locks held for setting device specific suspend_freq if such
    has been defined. This patch fixes that by adding the needed locking, what
    fixes following kernel warning on Exynos4412-based OdroidU3 board during
    system suspend:
    
    PM: suspend entry (deep)
    Filesystems sync: 0.002 seconds
    Freezing user space processes ... (elapsed 0.001 seconds) done.
    OOM killer disabled.
    Freezing remaining freezable tasks ... (elapsed 0.001 seconds) done.
    ------------[ cut here ]------------
    WARNING: CPU: 2 PID: 1385 at drivers/devfreq/devfreq.c:204 devfreq_update_status+0xc0/0x188
    Modules linked in:
    CPU: 2 PID: 1385 Comm: rtcwake Not tainted 5.4.0-rc6-next-20191111 #6848
    Hardware name: SAMSUNG EXYNOS (Flattened Device Tree)
    [<c0112588>] (unwind_backtrace) from [<c010e070>] (show_stack+0x10/0x14)
    [<c010e070>] (show_stack) from [<c0afb010>] (dump_stack+0xb4/0xe0)
    [<c0afb010>] (dump_stack) from [<c01272e0>] (__warn+0xf4/0x10c)
    [<c01272e0>] (__warn) from [<c01273a8>] (warn_slowpath_fmt+0xb0/0xb8)
    [<c01273a8>] (warn_slowpath_fmt) from [<c07d105c>] (devfreq_update_status+0xc0/0x188)
    [<c07d105c>] (devfreq_update_status) from [<c07d2d70>] (devfreq_set_target+0xb0/0x15c)
    [<c07d2d70>] (devfreq_set_target) from [<c07d3598>] (devfreq_suspend+0x2c/0x64)
    [<c07d3598>] (devfreq_suspend) from [<c05de0b0>] (dpm_suspend+0xa4/0x57c)
    [<c05de0b0>] (dpm_suspend) from [<c05def74>] (dpm_suspend_start+0x98/0xa0)
    [<c05def74>] (dpm_suspend_start) from [<c0195b58>] (suspend_devices_and_enter+0xec/0xc74)
    [<c0195b58>] (suspend_devices_and_enter) from [<c0196a20>] (pm_suspend+0x340/0x410)
    [<c0196a20>] (pm_suspend) from [<c019480c>] (state_store+0x6c/0xc8)
    [<c019480c>] (state_store) from [<c033fc50>] (kernfs_fop_write+0x10c/0x228)
    [<c033fc50>] (kernfs_fop_write) from [<c02a6d3c>] (__vfs_write+0x30/0x1d0)
    [<c02a6d3c>] (__vfs_write) from [<c02a9afc>] (vfs_write+0xa4/0x180)
    [<c02a9afc>] (vfs_write) from [<c02a9d58>] (ksys_write+0x60/0xd8)
    [<c02a9d58>] (ksys_write) from [<c0101000>] (ret_fast_syscall+0x0/0x28)
    Exception stack(0xed3d7fa8 to 0xed3d7ff0)
    ...
    irq event stamp: 9667
    hardirqs last  enabled at (9679): [<c0b1e7c4>] _raw_spin_unlock_irq+0x20/0x58
    hardirqs last disabled at (9698): [<c0b16a20>] __schedule+0xd8/0x818
    softirqs last  enabled at (9694): [<c01026fc>] __do_softirq+0x4fc/0x5fc
    softirqs last disabled at (9719): [<c012fe68>] irq_exit+0x16c/0x170
    ---[ end trace 41ac5b57d046bdbc ]---
    ------------[ cut here ]------------
    
    Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Acked-by: Chanwoo Choi <cw00.choi@samsung.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 7ca04acf4f6ce4036b3eec029dd6a1888ab78216
Author: Bo Yan <byan@nvidia.com>
Date:   Tue Jan 23 13:57:55 2018 -0800

    cpufreq: Skip cpufreq resume if it's not suspended
    
    commit 703cbaa601ff3fb554d1246c336ba727cc083ea0 upstream.
    
    cpufreq_resume can be called even without preceding cpufreq_suspend.
    This can happen in following scenario:
    
        suspend_devices_and_enter
           --> dpm_suspend_start
              --> dpm_prepare
                  --> device_prepare : this function errors out
              --> dpm_suspend: this is skipped due to dpm_prepare failure
                               this means cpufreq_suspend is skipped over
           --> goto Recover_platform, due to previous error
           --> goto Resume_devices
           --> dpm_resume_end
               --> dpm_resume
                   --> cpufreq_resume
    
    In case schedutil is used as frequency governor, cpufreq_resume will
    eventually call sugov_start, which does following:
    
        memset(sg_cpu, 0, sizeof(*sg_cpu));
        ....
    
    This effectively erases function pointer for frequency update, causing
    crash later on. The function pointer would have been set correctly if
    subsequent cpufreq_add_update_util_hook runs successfully, but that
    function returns earlier because cpufreq_suspend was not called:
    
        if (WARN_ON(per_cpu(cpufreq_update_util_data, cpu)))
                    return;
    
    The fix is to check cpufreq_suspended first, if it's false, that means
    cpufreq_suspend was not called in the first place, so do not resume
    cpufreq.
    
    Signed-off-by: Bo Yan <byan@nvidia.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    [ rjw: Dropped printing a message ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 7181d93b44cb9286fc76af6be82cecb4653532e4
Author: Bo Yan <byan@nvidia.com>
Date:   Tue Jan 23 13:57:55 2018 -0800

    cpufreq: Skip cpufreq resume if it's not suspended
    
    commit 703cbaa601ff3fb554d1246c336ba727cc083ea0 upstream.
    
    cpufreq_resume can be called even without preceding cpufreq_suspend.
    This can happen in following scenario:
    
        suspend_devices_and_enter
           --> dpm_suspend_start
              --> dpm_prepare
                  --> device_prepare : this function errors out
              --> dpm_suspend: this is skipped due to dpm_prepare failure
                               this means cpufreq_suspend is skipped over
           --> goto Recover_platform, due to previous error
           --> goto Resume_devices
           --> dpm_resume_end
               --> dpm_resume
                   --> cpufreq_resume
    
    In case schedutil is used as frequency governor, cpufreq_resume will
    eventually call sugov_start, which does following:
    
        memset(sg_cpu, 0, sizeof(*sg_cpu));
        ....
    
    This effectively erases function pointer for frequency update, causing
    crash later on. The function pointer would have been set correctly if
    subsequent cpufreq_add_update_util_hook runs successfully, but that
    function returns earlier because cpufreq_suspend was not called:
    
        if (WARN_ON(per_cpu(cpufreq_update_util_data, cpu)))
                    return;
    
    The fix is to check cpufreq_suspended first, if it's false, that means
    cpufreq_suspend was not called in the first place, so do not resume
    cpufreq.
    
    Signed-off-by: Bo Yan <byan@nvidia.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    [ rjw: Dropped printing a message ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit ac82fc83270884adea31d9dec22db09392058bf7
Author: Dexuan Cui <decui@microsoft.com>
Date:   Sun Nov 24 21:33:52 2019 -0800

    PCI: hv: Add hibernation support
    
    Add suspend() and resume() functions so that Hyper-V virtual PCI devices
    are handled properly when the VM hibernates and resumes from
    hibernation.
    
    Note that the suspend() function must make sure there are no pending
    work items before calling vmbus_close(), since it runs in a process
    context as a callback in dpm_suspend(). When it starts to run, the
    channel callback hv_pci_onchannelcallback(), which runs in a tasklet
    context, can be still running concurrently and scheduling new work items
    onto hbus->wq in hv_pci_devices_present() and hv_pci_eject_device(), and
    the work item handlers can access the vmbus channel, which can be being
    closed by hv_pci_suspend(), e.g. the work item handler
    pci_devices_present_work() -> new_pcichild_device() writes to the vmbus
    channel.
    
    To eliminate the race, hv_pci_suspend() disables the channel callback
    tasklet, sets hbus->state to hv_pcibus_removing, and re-enables the
    tasklet.  This way, when hv_pci_suspend() proceeds, it knows that no new
    work item can be scheduled, and then it flushes hbus->wq and safely
    closes the vmbus channel.
    
    Signed-off-by: Dexuan Cui <decui@microsoft.com>
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Reviewed-by: Michael Kelley <mikelley@microsoft.com>

commit 732f9ca4a737aea3983ad86007e88e7fffe8cd6a
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Wed Nov 20 18:22:09 2019 +0000

    drm/i915/gt: Fixup config ifdeffery for pm_suspend_target_state
    
    pm_suspend_target_state is declared under CONFIG_PM_SLEEP but only
    defined under CONFIG_SUSPEND. Play safe and only use the symbol if it is
    both declared and defined.
    
    Reported-by: kbuild-all@lists.01.org
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Fixes: a70a9e998e8e ("drm/i915: Defer rc6 shutdown to suspend_late")
    Cc: Andi Shyti <andi.shyti@intel.com>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191120182209.3967833-1-chris@chris-wilson.co.uk
    Signed-off-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>

commit e435c608e89a23aaf0c71280f3be50775d7fdf23
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Wed Nov 20 18:22:09 2019 +0000

    drm/i915/gt: Fixup config ifdeffery for pm_suspend_target_state
    
    pm_suspend_target_state is declared under CONFIG_PM_SLEEP but only
    defined under CONFIG_SUSPEND. Play safe and only use the symbol if it is
    both declared and defined.
    
    Reported-by: kbuild-all@lists.01.org
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Fixes: a70a9e998e8e ("drm/i915: Defer rc6 shutdown to suspend_late")
    Cc: Andi Shyti <andi.shyti@intel.com>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191120182209.3967833-1-chris@chris-wilson.co.uk

commit de8d059ffbd669ca00311548b8851341eb89ee5f
Author: Jon Hunter <jonathanh@nvidia.com>
Date:   Tue Sep 10 10:29:17 2019 +0100

    i2c: tegra: Move suspend handling to NOIRQ phase
    
    [ Upstream commit 8ebf15e9c869e764b3aab4928938ee68c0e2bd6d ]
    
    Commit acc8abcb2a9c ("i2c: tegra: Add suspend-resume support") added
    suspend support for the Tegra I2C driver and following this change on
    Tegra30 the following WARNING is seen on entering suspend ...
    
     WARNING: CPU: 2 PID: 689 at /dvs/git/dirty/git-master_l4t-upstream/kernel/drivers/i2c/i2c-core.h:54 __i2c_transfer+0x35c/0x70c
     i2c i2c-4: Transfer while suspended
     Modules linked in: brcmfmac brcmutil
     CPU: 2 PID: 689 Comm: rtcwake Not tainted 5.3.0-rc7-g089cf7f6ecb2 #1
     Hardware name: NVIDIA Tegra SoC (Flattened Device Tree)
     [<c0112264>] (unwind_backtrace) from [<c010ca94>] (show_stack+0x10/0x14)
     [<c010ca94>] (show_stack) from [<c0a77024>] (dump_stack+0xb4/0xc8)
     [<c0a77024>] (dump_stack) from [<c0124198>] (__warn+0xe0/0xf8)
     [<c0124198>] (__warn) from [<c01241f8>] (warn_slowpath_fmt+0x48/0x6c)
     [<c01241f8>] (warn_slowpath_fmt) from [<c06f6c40>] (__i2c_transfer+0x35c/0x70c)
     [<c06f6c40>] (__i2c_transfer) from [<c06f7048>] (i2c_transfer+0x58/0xf4)
     [<c06f7048>] (i2c_transfer) from [<c06f7130>] (i2c_transfer_buffer_flags+0x4c/0x70)
     [<c06f7130>] (i2c_transfer_buffer_flags) from [<c05bee78>] (regmap_i2c_write+0x14/0x30)
     [<c05bee78>] (regmap_i2c_write) from [<c05b9cac>] (_regmap_raw_write_impl+0x35c/0x868)
     [<c05b9cac>] (_regmap_raw_write_impl) from [<c05b984c>] (_regmap_update_bits+0xe4/0xec)
     [<c05b984c>] (_regmap_update_bits) from [<c05bad04>] (regmap_update_bits_base+0x50/0x74)
     [<c05bad04>] (regmap_update_bits_base) from [<c04d453c>] (regulator_disable_regmap+0x44/0x54)
     [<c04d453c>] (regulator_disable_regmap) from [<c04cf9d4>] (_regulator_do_disable+0xf8/0x268)
     [<c04cf9d4>] (_regulator_do_disable) from [<c04d1694>] (_regulator_disable+0xf4/0x19c)
     [<c04d1694>] (_regulator_disable) from [<c04d1770>] (regulator_disable+0x34/0x64)
     [<c04d1770>] (regulator_disable) from [<c04d2310>] (regulator_bulk_disable+0x28/0xb4)
     [<c04d2310>] (regulator_bulk_disable) from [<c0495cd4>] (tegra_pcie_power_off+0x64/0xa8)
     [<c0495cd4>] (tegra_pcie_power_off) from [<c0495f74>] (tegra_pcie_pm_suspend+0x25c/0x3f4)
     [<c0495f74>] (tegra_pcie_pm_suspend) from [<c05af48c>] (dpm_run_callback+0x38/0x1d4)
     [<c05af48c>] (dpm_run_callback) from [<c05afe30>] (__device_suspend_noirq+0xc0/0x2b8)
     [<c05afe30>] (__device_suspend_noirq) from [<c05b1c24>] (dpm_noirq_suspend_devices+0x100/0x37c)
     [<c05b1c24>] (dpm_noirq_suspend_devices) from [<c05b1ebc>] (dpm_suspend_noirq+0x1c/0x48)
     [<c05b1ebc>] (dpm_suspend_noirq) from [<c017d2c0>] (suspend_devices_and_enter+0x1d0/0xa00)
     [<c017d2c0>] (suspend_devices_and_enter) from [<c017dd10>] (pm_suspend+0x220/0x74c)
     [<c017dd10>] (pm_suspend) from [<c017c2c8>] (state_store+0x6c/0xc8)
     [<c017c2c8>] (state_store) from [<c02ef398>] (kernfs_fop_write+0xe8/0x1c4)
     [<c02ef398>] (kernfs_fop_write) from [<c0271e38>] (__vfs_write+0x2c/0x1c4)
     [<c0271e38>] (__vfs_write) from [<c02748dc>] (vfs_write+0xa4/0x184)
     [<c02748dc>] (vfs_write) from [<c0274b7c>] (ksys_write+0x9c/0xdc)
     [<c0274b7c>] (ksys_write) from [<c0101000>] (ret_fast_syscall+0x0/0x54)
     Exception stack(0xe9f21fa8 to 0xe9f21ff0)
     1fa0:                   0000006c 004b2438 00000004 004b2438 00000004 00000000
     1fc0: 0000006c 004b2438 004b1228 00000004 00000004 00000004 0049e78c 004b1228
     1fe0: 00000004 be9809b8 b6f0bc0b b6e96206
    
    The problem is that the Tegra PCIe driver indirectly uses I2C for
    controlling some regulators and the I2C driver is now being suspended
    before the PCIe driver causing the PCIe suspend to fail. The Tegra PCIe
    driver is suspended during the NOIRQ phase and this cannot be changed
    due to other dependencies. Therefore, we also need to move the suspend
    handling for the Tegra I2C driver to the NOIRQ phase as well.
    
    In order to move the I2C suspend handling to the NOIRQ phase we also
    need to avoid calling pm_runtime_get/put() because per commit
    1e2ef05bb8cf ("PM: Limit race conditions between runtime PM and system
    sleep (v2)") these cannot be called early in resume. The function
    tegra_i2c_init(), called during resume, calls pm_runtime_get/put() and
    so move these calls outside of tegra_i2c_init(), so this function can
    be used during the NOIRQ resume phase.
    
    Fixes: acc8abcb2a9c ("i2c: tegra: Add suspend-resume support")
    
    Signed-off-by: Jon Hunter <jonathanh@nvidia.com>
    Acked-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit b71e15e286dd18aaaaf76d3474e61bc71c03c2ce
Author: Stanley Chu <stanley.chu@mediatek.com>
Date:   Wed Jun 12 23:19:05 2019 +0800

    scsi: ufs: Avoid runtime suspend possibly being blocked forever
    
    commit 24e2e7a19f7e4b83d0d5189040d997bce3596473 upstream.
    
    UFS runtime suspend can be triggered after pm_runtime_enable() is invoked
    in ufshcd_pltfrm_init(). However if the first runtime suspend is triggered
    before binding ufs_hba structure to ufs device structure via
    platform_set_drvdata(), then UFS runtime suspend will be no longer
    triggered in the future because its dev->power.runtime_error was set in the
    first triggering and does not have any chance to be cleared.
    
    To be more clear, dev->power.runtime_error is set if hba is NULL in
    ufshcd_runtime_suspend() which returns -EINVAL to rpm_callback() where
    dev->power.runtime_error is set as -EINVAL. In this case, any future
    rpm_suspend() for UFS device fails because rpm_check_suspend_allowed()
    fails due to non-zero
    dev->power.runtime_error.
    
    To resolve this issue, make sure the first UFS runtime suspend get valid
    "hba" in ufshcd_runtime_suspend(): Enable UFS runtime PM only after hba is
    successfully bound to UFS device structure.
    
    Fixes: 62694735ca95 ([SCSI] ufs: Add runtime PM support for UFS host controller driver)
    Signed-off-by: Stanley Chu <stanley.chu@mediatek.com>
    Reviewed-by: Avri Altman <avri.altman@wdc.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
    [bwh: Backported to 3.16:
     - ufshcd_pltrfm_probe() doesn't allocate or free the host structure
     - Adjust context]
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit 8ebf15e9c869e764b3aab4928938ee68c0e2bd6d
Author: Jon Hunter <jonathanh@nvidia.com>
Date:   Tue Sep 10 10:29:17 2019 +0100

    i2c: tegra: Move suspend handling to NOIRQ phase
    
    Commit acc8abcb2a9c ("i2c: tegra: Add suspend-resume support") added
    suspend support for the Tegra I2C driver and following this change on
    Tegra30 the following WARNING is seen on entering suspend ...
    
     WARNING: CPU: 2 PID: 689 at /dvs/git/dirty/git-master_l4t-upstream/kernel/drivers/i2c/i2c-core.h:54 __i2c_transfer+0x35c/0x70c
     i2c i2c-4: Transfer while suspended
     Modules linked in: brcmfmac brcmutil
     CPU: 2 PID: 689 Comm: rtcwake Not tainted 5.3.0-rc7-g089cf7f6ecb2 #1
     Hardware name: NVIDIA Tegra SoC (Flattened Device Tree)
     [<c0112264>] (unwind_backtrace) from [<c010ca94>] (show_stack+0x10/0x14)
     [<c010ca94>] (show_stack) from [<c0a77024>] (dump_stack+0xb4/0xc8)
     [<c0a77024>] (dump_stack) from [<c0124198>] (__warn+0xe0/0xf8)
     [<c0124198>] (__warn) from [<c01241f8>] (warn_slowpath_fmt+0x48/0x6c)
     [<c01241f8>] (warn_slowpath_fmt) from [<c06f6c40>] (__i2c_transfer+0x35c/0x70c)
     [<c06f6c40>] (__i2c_transfer) from [<c06f7048>] (i2c_transfer+0x58/0xf4)
     [<c06f7048>] (i2c_transfer) from [<c06f7130>] (i2c_transfer_buffer_flags+0x4c/0x70)
     [<c06f7130>] (i2c_transfer_buffer_flags) from [<c05bee78>] (regmap_i2c_write+0x14/0x30)
     [<c05bee78>] (regmap_i2c_write) from [<c05b9cac>] (_regmap_raw_write_impl+0x35c/0x868)
     [<c05b9cac>] (_regmap_raw_write_impl) from [<c05b984c>] (_regmap_update_bits+0xe4/0xec)
     [<c05b984c>] (_regmap_update_bits) from [<c05bad04>] (regmap_update_bits_base+0x50/0x74)
     [<c05bad04>] (regmap_update_bits_base) from [<c04d453c>] (regulator_disable_regmap+0x44/0x54)
     [<c04d453c>] (regulator_disable_regmap) from [<c04cf9d4>] (_regulator_do_disable+0xf8/0x268)
     [<c04cf9d4>] (_regulator_do_disable) from [<c04d1694>] (_regulator_disable+0xf4/0x19c)
     [<c04d1694>] (_regulator_disable) from [<c04d1770>] (regulator_disable+0x34/0x64)
     [<c04d1770>] (regulator_disable) from [<c04d2310>] (regulator_bulk_disable+0x28/0xb4)
     [<c04d2310>] (regulator_bulk_disable) from [<c0495cd4>] (tegra_pcie_power_off+0x64/0xa8)
     [<c0495cd4>] (tegra_pcie_power_off) from [<c0495f74>] (tegra_pcie_pm_suspend+0x25c/0x3f4)
     [<c0495f74>] (tegra_pcie_pm_suspend) from [<c05af48c>] (dpm_run_callback+0x38/0x1d4)
     [<c05af48c>] (dpm_run_callback) from [<c05afe30>] (__device_suspend_noirq+0xc0/0x2b8)
     [<c05afe30>] (__device_suspend_noirq) from [<c05b1c24>] (dpm_noirq_suspend_devices+0x100/0x37c)
     [<c05b1c24>] (dpm_noirq_suspend_devices) from [<c05b1ebc>] (dpm_suspend_noirq+0x1c/0x48)
     [<c05b1ebc>] (dpm_suspend_noirq) from [<c017d2c0>] (suspend_devices_and_enter+0x1d0/0xa00)
     [<c017d2c0>] (suspend_devices_and_enter) from [<c017dd10>] (pm_suspend+0x220/0x74c)
     [<c017dd10>] (pm_suspend) from [<c017c2c8>] (state_store+0x6c/0xc8)
     [<c017c2c8>] (state_store) from [<c02ef398>] (kernfs_fop_write+0xe8/0x1c4)
     [<c02ef398>] (kernfs_fop_write) from [<c0271e38>] (__vfs_write+0x2c/0x1c4)
     [<c0271e38>] (__vfs_write) from [<c02748dc>] (vfs_write+0xa4/0x184)
     [<c02748dc>] (vfs_write) from [<c0274b7c>] (ksys_write+0x9c/0xdc)
     [<c0274b7c>] (ksys_write) from [<c0101000>] (ret_fast_syscall+0x0/0x54)
     Exception stack(0xe9f21fa8 to 0xe9f21ff0)
     1fa0:                   0000006c 004b2438 00000004 004b2438 00000004 00000000
     1fc0: 0000006c 004b2438 004b1228 00000004 00000004 00000004 0049e78c 004b1228
     1fe0: 00000004 be9809b8 b6f0bc0b b6e96206
    
    The problem is that the Tegra PCIe driver indirectly uses I2C for
    controlling some regulators and the I2C driver is now being suspended
    before the PCIe driver causing the PCIe suspend to fail. The Tegra PCIe
    driver is suspended during the NOIRQ phase and this cannot be changed
    due to other dependencies. Therefore, we also need to move the suspend
    handling for the Tegra I2C driver to the NOIRQ phase as well.
    
    In order to move the I2C suspend handling to the NOIRQ phase we also
    need to avoid calling pm_runtime_get/put() because per commit
    1e2ef05bb8cf ("PM: Limit race conditions between runtime PM and system
    sleep (v2)") these cannot be called early in resume. The function
    tegra_i2c_init(), called during resume, calls pm_runtime_get/put() and
    so move these calls outside of tegra_i2c_init(), so this function can
    be used during the NOIRQ resume phase.
    
    Fixes: acc8abcb2a9c ("i2c: tegra: Add suspend-resume support")
    
    Signed-off-by: Jon Hunter <jonathanh@nvidia.com>
    Acked-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

commit d19bdb876bece27187d4ffbc272672e1239cd313
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Aug 8 11:39:23 2019 +0200

    intel-hid: Disable button array during suspend-to-idle
    
    Notice that intel_button_array_enable() never disables the power
    button which is the only one needed to wake up the system from
    suspend-to-idle, so it can be safely called during suspend-to-idle
    as well as during "regular" system suspend, and rearrange the
    code in the driver's "suspend" and "resume" callbacks accordingly.
    
    While at it, use pm_suspend_no_platform() to check if the current
    suspend-resume cycle is suspend-to-idle, as that is the only
    case when the device should be enabled while suspended.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

commit 6e86633a791fdf631617ef3a9af3263141d34bc9
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Jul 31 11:05:42 2019 +0200

    ACPI: PM: s2idle: Eliminate acpi_sleep_no_ec_events()
    
    Change acpi_ec_suspend() to use pm_suspend_no_platform() instead of
    acpi_sleep_no_ec_events(), which allows the latter to be eliminated
    along with the s2idle_in_progress variable which is only used by it.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Tested-by: Kai-Heng Feng <kai.heng.feng@canonical.com>

commit 724f88e5ed64608d71d378688ce5dc4b4bfb9281
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Mon Jun 10 15:54:37 2019 -0700

    dma-remap: Avoid de-referencing NULL atomic_pool
    
    [ Upstream commit 4b4b077cbd0a998aebaa72c199e06b8a4c8dcfee ]
    
    With architectures allowing the kernel to be placed almost arbitrarily
    in memory (e.g.: ARM64), it is possible to have the kernel resides at
    physical addresses above 4GB, resulting in neither the default CMA area,
    nor the atomic pool from successfully allocating. This does not prevent
    specific peripherals from working though, one example is XHCI, which
    still operates correctly.
    
    Trouble comes when the XHCI driver gets suspended and resumed, since we
    can now trigger the following NPD:
    
    [   12.664170] usb usb1: root hub lost power or was reset
    [   12.669387] usb usb2: root hub lost power or was reset
    [   12.674662] Unable to handle kernel NULL pointer dereference at virtual address 00000008
    [   12.682896] pgd = ffffffc1365a7000
    [   12.686386] [00000008] *pgd=0000000136500003, *pud=0000000136500003, *pmd=0000000000000000
    [   12.694897] Internal error: Oops: 96000006 [#1] SMP
    [   12.699843] Modules linked in:
    [   12.702980] CPU: 0 PID: 1499 Comm: pml Not tainted 4.9.135-1.13pre #51
    [   12.709577] Hardware name: BCM97268DV (DT)
    [   12.713736] task: ffffffc136bb6540 task.stack: ffffffc1366cc000
    [   12.719740] PC is at addr_in_gen_pool+0x4/0x48
    [   12.724253] LR is at __dma_free+0x64/0xbc
    [   12.728325] pc : [<ffffff80083c0df8>] lr : [<ffffff80080979e0>] pstate: 60000145
    [   12.735825] sp : ffffffc1366cf990
    [   12.739196] x29: ffffffc1366cf990 x28: ffffffc1366cc000
    [   12.744608] x27: 0000000000000000 x26: ffffffc13a8568c8
    [   12.750020] x25: 0000000000000000 x24: ffffff80098f9000
    [   12.755433] x23: 000000013a5ff000 x22: ffffff8009c57000
    [   12.760844] x21: ffffffc13a856810 x20: 0000000000000000
    [   12.766255] x19: 0000000000001000 x18: 000000000000000a
    [   12.771667] x17: 0000007f917553e0 x16: 0000000000001002
    [   12.777078] x15: 00000000000a36cb x14: ffffff80898feb77
    [   12.782490] x13: ffffffffffffffff x12: 0000000000000030
    [   12.787899] x11: 00000000fffffffe x10: ffffff80098feb7f
    [   12.793311] x9 : 0000000005f5e0ff x8 : 65776f702074736f
    [   12.798723] x7 : 6c2062756820746f x6 : ffffff80098febb1
    [   12.804134] x5 : ffffff800809797c x4 : 0000000000000000
    [   12.809545] x3 : 000000013a5ff000 x2 : 0000000000000fff
    [   12.814955] x1 : ffffff8009c57000 x0 : 0000000000000000
    [   12.820363]
    [   12.821907] Process pml (pid: 1499, stack limit = 0xffffffc1366cc020)
    [   12.828421] Stack: (0xffffffc1366cf990 to 0xffffffc1366d0000)
    [   12.834240] f980:                                   ffffffc1366cf9e0 ffffff80086004d0
    [   12.842186] f9a0: ffffffc13ab08238 0000000000000010 ffffff80097c2218 ffffffc13a856810
    [   12.850131] f9c0: ffffff8009c57000 000000013a5ff000 0000000000000008 000000013a5ff000
    [   12.858076] f9e0: ffffffc1366cfa50 ffffff80085f9250 ffffffc13ab08238 0000000000000004
    [   12.866021] fa00: ffffffc13ab08000 ffffff80097b6000 ffffffc13ab08130 0000000000000001
    [   12.873966] fa20: 0000000000000008 ffffffc13a8568c8 0000000000000000 ffffffc1366cc000
    [   12.881911] fa40: ffffffc13ab08130 0000000000000001 ffffffc1366cfa90 ffffff80085e3de8
    [   12.889856] fa60: ffffffc13ab08238 0000000000000000 ffffffc136b75b00 0000000000000000
    [   12.897801] fa80: 0000000000000010 ffffff80089ccb92 ffffffc1366cfac0 ffffff80084ad040
    [   12.905746] faa0: ffffffc13a856810 0000000000000000 ffffff80084ad004 ffffff80084b91a8
    [   12.913691] fac0: ffffffc1366cfae0 ffffff80084b91b4 ffffffc13a856810 ffffff80080db5cc
    [   12.921636] fae0: ffffffc1366cfb20 ffffff80084b96bc ffffffc13a856810 0000000000000010
    [   12.929581] fb00: ffffffc13a856870 0000000000000000 ffffffc13a856810 ffffff800984d2b8
    [   12.937526] fb20: ffffffc1366cfb50 ffffff80084baa70 ffffff8009932ad0 ffffff800984d260
    [   12.945471] fb40: 0000000000000010 00000002eff0a065 ffffffc1366cfbb0 ffffff80084bafbc
    [   12.953415] fb60: 0000000000000010 0000000000000003 ffffff80098fe000 0000000000000000
    [   12.961360] fb80: ffffff80097b6000 ffffff80097b6dc8 ffffff80098c12b8 ffffff80098c12f8
    [   12.969306] fba0: ffffff8008842000 ffffff80097b6dc8 ffffffc1366cfbd0 ffffff80080e0d88
    [   12.977251] fbc0: 00000000fffffffb ffffff80080e10bc ffffffc1366cfc60 ffffff80080e16a8
    [   12.985196] fbe0: 0000000000000000 0000000000000003 ffffff80097b6000 ffffff80098fe9f0
    [   12.993140] fc00: ffffff80097d4000 ffffff8008983802 0000000000000123 0000000000000040
    [   13.001085] fc20: ffffff8008842000 ffffffc1366cc000 ffffff80089803c2 00000000ffffffff
    [   13.009029] fc40: 0000000000000000 0000000000000000 ffffffc1366cfc60 0000000000040987
    [   13.016974] fc60: ffffffc1366cfcc0 ffffff80080dfd08 0000000000000003 0000000000000004
    [   13.024919] fc80: 0000000000000003 ffffff80098fea08 ffffffc136577ec0 ffffff80089803c2
    [   13.032864] fca0: 0000000000000123 0000000000000001 0000000500000002 0000000000040987
    [   13.040809] fcc0: ffffffc1366cfd00 ffffff80083a89d4 0000000000000004 ffffffc136577ec0
    [   13.048754] fce0: ffffffc136610cc0 ffffffffffffffea ffffffc1366cfeb0 ffffffc136610cd8
    [   13.056700] fd00: ffffffc1366cfd10 ffffff800822a614 ffffffc1366cfd40 ffffff80082295d4
    [   13.064645] fd20: 0000000000000004 ffffffc136577ec0 ffffffc136610cc0 0000000021670570
    [   13.072590] fd40: ffffffc1366cfd80 ffffff80081b5d10 ffffff80097b6000 ffffffc13aae4200
    [   13.080536] fd60: ffffffc1366cfeb0 0000000000000004 0000000021670570 0000000000000004
    [   13.088481] fd80: ffffffc1366cfe30 ffffff80081b6b20 ffffffc13aae4200 0000000000000000
    [   13.096427] fda0: 0000000000000004 0000000021670570 ffffffc1366cfeb0 ffffffc13a838200
    [   13.104371] fdc0: 0000000000000000 000000000000000a ffffff80097b6000 0000000000040987
    [   13.112316] fde0: ffffffc1366cfe20 ffffff80081b3af0 ffffffc13a838200 0000000000000000
    [   13.120261] fe00: ffffffc1366cfe30 ffffff80081b6b0c ffffffc13aae4200 0000000000000000
    [   13.128206] fe20: 0000000000000004 0000000000040987 ffffffc1366cfe70 ffffff80081b7dd8
    [   13.136151] fe40: ffffff80097b6000 ffffffc13aae4200 ffffffc13aae4200 fffffffffffffff7
    [   13.144096] fe60: 0000000021670570 ffffffc13a8c63c0 0000000000000000 ffffff8008083180
    [   13.152042] fe80: ffffffffffffff1d 0000000021670570 ffffffffffffffff 0000007f917ad9b8
    [   13.159986] fea0: 0000000020000000 0000000000000015 0000000000000000 0000000000040987
    [   13.167930] fec0: 0000000000000001 0000000021670570 0000000000000004 0000000000000000
    [   13.175874] fee0: 0000000000000888 0000440110000000 000000000000006d 0000000000000003
    [   13.183819] ff00: 0000000000000040 ffffff80ffffffc8 0000000000000000 0000000000000020
    [   13.191762] ff20: 0000000000000000 0000000000000000 0000000000000001 0000000000000000
    [   13.199707] ff40: 0000000000000000 0000007f917553e0 0000000000000000 0000000000000004
    [   13.207651] ff60: 0000000021670570 0000007f91835480 0000000000000004 0000007f91831638
    [   13.215595] ff80: 0000000000000004 00000000004b0de0 00000000004b0000 0000000000000000
    [   13.223539] ffa0: 0000000000000000 0000007fc92ac8c0 0000007f9175d178 0000007fc92ac8c0
    [   13.231483] ffc0: 0000007f917ad9b8 0000000020000000 0000000000000001 0000000000000040
    [   13.239427] ffe0: 0000000000000000 0000000000000000 0000000000000000 0000000000000000
    [   13.247360] Call trace:
    [   13.249866] Exception stack(0xffffffc1366cf7a0 to 0xffffffc1366cf8d0)
    [   13.256386] f7a0: 0000000000001000 0000007fffffffff ffffffc1366cf990 ffffff80083c0df8
    [   13.264331] f7c0: 0000000060000145 ffffff80089b5001 ffffffc13ab08130 0000000000000001
    [   13.272275] f7e0: 0000000000000008 ffffffc13a8568c8 0000000000000000 0000000000000000
    [   13.280220] f800: ffffffc1366cf960 ffffffc1366cf960 ffffffc1366cf930 00000000ffffffd8
    [   13.288165] f820: ffffff8009931ac0 4554535953425553 4544006273753d4d 3831633d45434956
    [   13.296110] f840: ffff003832313a39 ffffff800845926c ffffffc1366cf880 0000000000040987
    [   13.304054] f860: 0000000000000000 ffffff8009c57000 0000000000000fff 000000013a5ff000
    [   13.311999] f880: 0000000000000000 ffffff800809797c ffffff80098febb1 6c2062756820746f
    [   13.319944] f8a0: 65776f702074736f 0000000005f5e0ff ffffff80098feb7f 00000000fffffffe
    [   13.327884] f8c0: 0000000000000030 ffffffffffffffff
    [   13.332835] [<ffffff80083c0df8>] addr_in_gen_pool+0x4/0x48
    [   13.338398] [<ffffff80086004d0>] xhci_mem_cleanup+0xc8/0x51c
    [   13.344137] [<ffffff80085f9250>] xhci_resume+0x308/0x65c
    [   13.349524] [<ffffff80085e3de8>] xhci_brcm_resume+0x84/0x8c
    [   13.355174] [<ffffff80084ad040>] platform_pm_resume+0x3c/0x64
    [   13.360997] [<ffffff80084b91b4>] dpm_run_callback+0x5c/0x15c
    [   13.366732] [<ffffff80084b96bc>] device_resume+0xc0/0x190
    [   13.372205] [<ffffff80084baa70>] dpm_resume+0x144/0x2cc
    [   13.377504] [<ffffff80084bafbc>] dpm_resume_end+0x20/0x34
    [   13.382980] [<ffffff80080e0d88>] suspend_devices_and_enter+0x104/0x704
    [   13.389585] [<ffffff80080e16a8>] pm_suspend+0x320/0x53c
    [   13.394881] [<ffffff80080dfd08>] state_store+0xbc/0xe0
    [   13.400094] [<ffffff80083a89d4>] kobj_attr_store+0x14/0x24
    [   13.405655] [<ffffff800822a614>] sysfs_kf_write+0x60/0x70
    [   13.411128] [<ffffff80082295d4>] kernfs_fop_write+0x130/0x194
    [   13.416954] [<ffffff80081b5d10>] __vfs_write+0x60/0x150
    [   13.422254] [<ffffff80081b6b20>] vfs_write+0xc8/0x164
    [   13.427376] [<ffffff80081b7dd8>] SyS_write+0x70/0xc8
    [   13.432412] [<ffffff8008083180>] el0_svc_naked+0x34/0x38
    [   13.437800] Code: 92800173 97f6fb9e 17fffff5 d1000442 (f8408c03)
    [   13.444033] ---[ end trace 2effe12f909ce205 ]---
    
    The call path leading to this problem is xhci_mem_cleanup() ->
    dma_free_coherent() -> dma_free_from_pool() -> addr_in_gen_pool. If the
    atomic_pool is NULL, we can't possibly have the address in the atomic
    pool anyway, so guard against that.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit e6c2b0a5bb7e208123db4f7c7ac70414de32165e
Author: Stanley Chu <stanley.chu@mediatek.com>
Date:   Wed Jun 12 23:19:05 2019 +0800

    scsi: ufs: Avoid runtime suspend possibly being blocked forever
    
    commit 24e2e7a19f7e4b83d0d5189040d997bce3596473 upstream.
    
    UFS runtime suspend can be triggered after pm_runtime_enable() is invoked
    in ufshcd_pltfrm_init(). However if the first runtime suspend is triggered
    before binding ufs_hba structure to ufs device structure via
    platform_set_drvdata(), then UFS runtime suspend will be no longer
    triggered in the future because its dev->power.runtime_error was set in the
    first triggering and does not have any chance to be cleared.
    
    To be more clear, dev->power.runtime_error is set if hba is NULL in
    ufshcd_runtime_suspend() which returns -EINVAL to rpm_callback() where
    dev->power.runtime_error is set as -EINVAL. In this case, any future
    rpm_suspend() for UFS device fails because rpm_check_suspend_allowed()
    fails due to non-zero
    dev->power.runtime_error.
    
    To resolve this issue, make sure the first UFS runtime suspend get valid
    "hba" in ufshcd_runtime_suspend(): Enable UFS runtime PM only after hba is
    successfully bound to UFS device structure.
    
    Fixes: 62694735ca95 ([SCSI] ufs: Add runtime PM support for UFS host controller driver)
    Cc: stable@vger.kernel.org
    Signed-off-by: Stanley Chu <stanley.chu@mediatek.com>
    Reviewed-by: Avri Altman <avri.altman@wdc.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 3dbeb448543efc01f04cadd6d358b9f33dd20d31
Merge: 50e163d43ab1 02bd45a28bf3
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Jul 8 10:51:25 2019 +0200

    Merge branch 'pm-sleep'
    
    * pm-sleep:
      PM: sleep: Drop dev_pm_skip_next_resume_phases()
      ACPI: PM: Drop unused function and function header
      ACPI: PM: Introduce "poweroff" callbacks for ACPI PM domain and LPSS
      ACPI: PM: Simplify and fix PM domain hibernation callbacks
      PCI: PM: Simplify bus-level hibernation callbacks
      PM: ACPI/PCI: Resume all devices during hibernation
      kernel: power: swap: use kzalloc() instead of kmalloc() followed by memset()
      PM: sleep: Update struct wakeup_source documentation
      drivers: base: power: remove wakeup_sources_stats_dentry variable
      PM: suspend: Rename pm_suspend_via_s2idle()
      PM: sleep: Show how long dpm_suspend_start() and dpm_suspend_end() take
      PM: hibernate: powerpc: Expose pfn_is_nosave() prototype

commit 471a739a47aa7d582f0cdf9d392957d04632bae2
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Jun 26 00:20:23 2019 +0200

    PCI: PM: Avoid skipping bus-level PM on platforms without ACPI
    
    There are platforms that do not call pm_set_suspend_via_firmware(),
    so pm_suspend_via_firmware() returns 'false' on them, but the power
    states of PCI devices (PCIe ports in particular) are changed as a
    result of powering down core platform components during system-wide
    suspend.  Thus the pm_suspend_via_firmware() checks in
    pci_pm_suspend_noirq() and pci_pm_resume_noirq() introduced by
    commit 3e26c5feed2a ("PCI: PM: Skip devices in D0 for suspend-to-
    idle") are not sufficient to determine that devices left in D0
    during suspend will remain in D0 during resume and so the bus-level
    power management can be skipped for them.
    
    For this reason, introduce a new global suspend flag,
    PM_SUSPEND_FLAG_NO_PLATFORM, set it for suspend-to-idle only
    and replace the pm_suspend_via_firmware() checks mentioned above
    with checks against this flag.
    
    Fixes: 3e26c5feed2a ("PCI: PM: Skip devices in D0 for suspend-to-idle")
    Reported-by: Jon Hunter <jonathanh@nvidia.com>
    Tested-by: Jon Hunter <jonathanh@nvidia.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>

commit 73e3c601e9dc28a01c5087f4056c8bd89f4c582b
Author: Stanley Chu <stanley.chu@mediatek.com>
Date:   Wed Jun 12 23:19:05 2019 +0800

    scsi: ufs: Avoid runtime suspend possibly being blocked forever
    
    commit 24e2e7a19f7e4b83d0d5189040d997bce3596473 upstream.
    
    UFS runtime suspend can be triggered after pm_runtime_enable() is invoked
    in ufshcd_pltfrm_init(). However if the first runtime suspend is triggered
    before binding ufs_hba structure to ufs device structure via
    platform_set_drvdata(), then UFS runtime suspend will be no longer
    triggered in the future because its dev->power.runtime_error was set in the
    first triggering and does not have any chance to be cleared.
    
    To be more clear, dev->power.runtime_error is set if hba is NULL in
    ufshcd_runtime_suspend() which returns -EINVAL to rpm_callback() where
    dev->power.runtime_error is set as -EINVAL. In this case, any future
    rpm_suspend() for UFS device fails because rpm_check_suspend_allowed()
    fails due to non-zero
    dev->power.runtime_error.
    
    To resolve this issue, make sure the first UFS runtime suspend get valid
    "hba" in ufshcd_runtime_suspend(): Enable UFS runtime PM only after hba is
    successfully bound to UFS device structure.
    
    Fixes: 62694735ca95 ([SCSI] ufs: Add runtime PM support for UFS host controller driver)
    Cc: stable@vger.kernel.org
    Signed-off-by: Stanley Chu <stanley.chu@mediatek.com>
    Reviewed-by: Avri Altman <avri.altman@wdc.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 0746b2f501428d01fc45e36023aaf58c43b18650
Author: Stanley Chu <stanley.chu@mediatek.com>
Date:   Wed Jun 12 23:19:05 2019 +0800

    scsi: ufs: Avoid runtime suspend possibly being blocked forever
    
    commit 24e2e7a19f7e4b83d0d5189040d997bce3596473 upstream.
    
    UFS runtime suspend can be triggered after pm_runtime_enable() is invoked
    in ufshcd_pltfrm_init(). However if the first runtime suspend is triggered
    before binding ufs_hba structure to ufs device structure via
    platform_set_drvdata(), then UFS runtime suspend will be no longer
    triggered in the future because its dev->power.runtime_error was set in the
    first triggering and does not have any chance to be cleared.
    
    To be more clear, dev->power.runtime_error is set if hba is NULL in
    ufshcd_runtime_suspend() which returns -EINVAL to rpm_callback() where
    dev->power.runtime_error is set as -EINVAL. In this case, any future
    rpm_suspend() for UFS device fails because rpm_check_suspend_allowed()
    fails due to non-zero
    dev->power.runtime_error.
    
    To resolve this issue, make sure the first UFS runtime suspend get valid
    "hba" in ufshcd_runtime_suspend(): Enable UFS runtime PM only after hba is
    successfully bound to UFS device structure.
    
    Fixes: 62694735ca95 ([SCSI] ufs: Add runtime PM support for UFS host controller driver)
    Cc: stable@vger.kernel.org
    Signed-off-by: Stanley Chu <stanley.chu@mediatek.com>
    Reviewed-by: Avri Altman <avri.altman@wdc.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit c0d4c85bc39fb5639cf6377eff98cee03af2d5a5
Author: Stanley Chu <stanley.chu@mediatek.com>
Date:   Wed Jun 12 23:19:05 2019 +0800

    scsi: ufs: Avoid runtime suspend possibly being blocked forever
    
    commit 24e2e7a19f7e4b83d0d5189040d997bce3596473 upstream.
    
    UFS runtime suspend can be triggered after pm_runtime_enable() is invoked
    in ufshcd_pltfrm_init(). However if the first runtime suspend is triggered
    before binding ufs_hba structure to ufs device structure via
    platform_set_drvdata(), then UFS runtime suspend will be no longer
    triggered in the future because its dev->power.runtime_error was set in the
    first triggering and does not have any chance to be cleared.
    
    To be more clear, dev->power.runtime_error is set if hba is NULL in
    ufshcd_runtime_suspend() which returns -EINVAL to rpm_callback() where
    dev->power.runtime_error is set as -EINVAL. In this case, any future
    rpm_suspend() for UFS device fails because rpm_check_suspend_allowed()
    fails due to non-zero
    dev->power.runtime_error.
    
    To resolve this issue, make sure the first UFS runtime suspend get valid
    "hba" in ufshcd_runtime_suspend(): Enable UFS runtime PM only after hba is
    successfully bound to UFS device structure.
    
    Fixes: 62694735ca95 ([SCSI] ufs: Add runtime PM support for UFS host controller driver)
    Cc: stable@vger.kernel.org
    Signed-off-by: Stanley Chu <stanley.chu@mediatek.com>
    Reviewed-by: Avri Altman <avri.altman@wdc.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 38fbd5c2d5721f6f0a40d8bf6e58e9a05df56c7e
Author: Marek Szyprowski <m.szyprowski@samsung.com>
Date:   Mon Feb 18 15:34:12 2019 +0100

    ARM: exynos: Fix undefined instruction during Exynos5422 resume
    
    [ Upstream commit 4d8e3e951a856777720272ce27f2c738a3eeef8c ]
    
    During early system resume on Exynos5422 with performance counters enabled
    the following kernel oops happens:
    
        Internal error: Oops - undefined instruction: 0 [#1] PREEMPT SMP ARM
        Modules linked in:
        CPU: 0 PID: 1433 Comm: bash Tainted: G        W         5.0.0-rc5-next-20190208-00023-gd5fb5a8a13e6-dirty #5480
        Hardware name: SAMSUNG EXYNOS (Flattened Device Tree)
        ...
        Flags: nZCv  IRQs off  FIQs off  Mode SVC_32  ISA ARM  Segment none
        Control: 10c5387d  Table: 4451006a  DAC: 00000051
        Process bash (pid: 1433, stack limit = 0xb7e0e22f)
        ...
        (reset_ctrl_regs) from [<c0112ad0>] (dbg_cpu_pm_notify+0x1c/0x24)
        (dbg_cpu_pm_notify) from [<c014c840>] (notifier_call_chain+0x44/0x84)
        (notifier_call_chain) from [<c014cbc0>] (__atomic_notifier_call_chain+0x7c/0x128)
        (__atomic_notifier_call_chain) from [<c01ffaac>] (cpu_pm_notify+0x30/0x54)
        (cpu_pm_notify) from [<c055116c>] (syscore_resume+0x98/0x3f4)
        (syscore_resume) from [<c0189350>] (suspend_devices_and_enter+0x97c/0xe74)
        (suspend_devices_and_enter) from [<c0189fb8>] (pm_suspend+0x770/0xc04)
        (pm_suspend) from [<c0187740>] (state_store+0x6c/0xcc)
        (state_store) from [<c09fa698>] (kobj_attr_store+0x14/0x20)
        (kobj_attr_store) from [<c030159c>] (sysfs_kf_write+0x4c/0x50)
        (sysfs_kf_write) from [<c0300620>] (kernfs_fop_write+0xfc/0x1e0)
        (kernfs_fop_write) from [<c0282be8>] (__vfs_write+0x2c/0x160)
        (__vfs_write) from [<c0282ea4>] (vfs_write+0xa4/0x16c)
        (vfs_write) from [<c0283080>] (ksys_write+0x40/0x8c)
        (ksys_write) from [<c0101000>] (ret_fast_syscall+0x0/0x28)
    
    Undefined instruction is triggered during CP14 reset, because bits: #16
    (Secure privileged invasive debug disabled) and #17 (Secure privileged
    noninvasive debug disable) are set in DSCR. Those bits depend on SPNIDEN
    and SPIDEN lines, which are provided by Secure JTAG hardware block. That
    block in turn is powered from cluster 0 (big/Eagle), but the Exynos5422
    boots on cluster 1 (LITTLE/KFC).
    
    To fix this issue it is enough to turn on the power on the cluster 0 for
    a while. This lets the Secure JTAG block to propagate the needed signals
    to LITTLE/KFC cores and change their DSCR.
    
    Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Signed-off-by: Krzysztof Kozlowski <krzk@kernel.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 1beeb0459cb2145e1eb99b7f5751b29205a0205e
Author: Marek Szyprowski <m.szyprowski@samsung.com>
Date:   Mon Feb 18 15:34:12 2019 +0100

    ARM: exynos: Fix undefined instruction during Exynos5422 resume
    
    [ Upstream commit 4d8e3e951a856777720272ce27f2c738a3eeef8c ]
    
    During early system resume on Exynos5422 with performance counters enabled
    the following kernel oops happens:
    
        Internal error: Oops - undefined instruction: 0 [#1] PREEMPT SMP ARM
        Modules linked in:
        CPU: 0 PID: 1433 Comm: bash Tainted: G        W         5.0.0-rc5-next-20190208-00023-gd5fb5a8a13e6-dirty #5480
        Hardware name: SAMSUNG EXYNOS (Flattened Device Tree)
        ...
        Flags: nZCv  IRQs off  FIQs off  Mode SVC_32  ISA ARM  Segment none
        Control: 10c5387d  Table: 4451006a  DAC: 00000051
        Process bash (pid: 1433, stack limit = 0xb7e0e22f)
        ...
        (reset_ctrl_regs) from [<c0112ad0>] (dbg_cpu_pm_notify+0x1c/0x24)
        (dbg_cpu_pm_notify) from [<c014c840>] (notifier_call_chain+0x44/0x84)
        (notifier_call_chain) from [<c014cbc0>] (__atomic_notifier_call_chain+0x7c/0x128)
        (__atomic_notifier_call_chain) from [<c01ffaac>] (cpu_pm_notify+0x30/0x54)
        (cpu_pm_notify) from [<c055116c>] (syscore_resume+0x98/0x3f4)
        (syscore_resume) from [<c0189350>] (suspend_devices_and_enter+0x97c/0xe74)
        (suspend_devices_and_enter) from [<c0189fb8>] (pm_suspend+0x770/0xc04)
        (pm_suspend) from [<c0187740>] (state_store+0x6c/0xcc)
        (state_store) from [<c09fa698>] (kobj_attr_store+0x14/0x20)
        (kobj_attr_store) from [<c030159c>] (sysfs_kf_write+0x4c/0x50)
        (sysfs_kf_write) from [<c0300620>] (kernfs_fop_write+0xfc/0x1e0)
        (kernfs_fop_write) from [<c0282be8>] (__vfs_write+0x2c/0x160)
        (__vfs_write) from [<c0282ea4>] (vfs_write+0xa4/0x16c)
        (vfs_write) from [<c0283080>] (ksys_write+0x40/0x8c)
        (ksys_write) from [<c0101000>] (ret_fast_syscall+0x0/0x28)
    
    Undefined instruction is triggered during CP14 reset, because bits: #16
    (Secure privileged invasive debug disabled) and #17 (Secure privileged
    noninvasive debug disable) are set in DSCR. Those bits depend on SPNIDEN
    and SPIDEN lines, which are provided by Secure JTAG hardware block. That
    block in turn is powered from cluster 0 (big/Eagle), but the Exynos5422
    boots on cluster 1 (LITTLE/KFC).
    
    To fix this issue it is enough to turn on the power on the cluster 0 for
    a while. This lets the Secure JTAG block to propagate the needed signals
    to LITTLE/KFC cores and change their DSCR.
    
    Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Signed-off-by: Krzysztof Kozlowski <krzk@kernel.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 0b385a0c3bd3f6d1044728b732bfc7dfb01c9fb5
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Jun 18 10:18:28 2019 +0200

    PM: suspend: Rename pm_suspend_via_s2idle()
    
    The name of pm_suspend_via_s2idle() is confusing, as it doesn't
    reflect the purpose of the function precisely enough and it is
    very similar to pm_suspend_via_firmware(), which has a different
    purpose, so rename it as pm_suspend_default_s2idle() and update
    its only caller, i8042_register_ports(), accordingly.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

commit 24e2e7a19f7e4b83d0d5189040d997bce3596473
Author: Stanley Chu <stanley.chu@mediatek.com>
Date:   Wed Jun 12 23:19:05 2019 +0800

    scsi: ufs: Avoid runtime suspend possibly being blocked forever
    
    UFS runtime suspend can be triggered after pm_runtime_enable() is invoked
    in ufshcd_pltfrm_init(). However if the first runtime suspend is triggered
    before binding ufs_hba structure to ufs device structure via
    platform_set_drvdata(), then UFS runtime suspend will be no longer
    triggered in the future because its dev->power.runtime_error was set in the
    first triggering and does not have any chance to be cleared.
    
    To be more clear, dev->power.runtime_error is set if hba is NULL in
    ufshcd_runtime_suspend() which returns -EINVAL to rpm_callback() where
    dev->power.runtime_error is set as -EINVAL. In this case, any future
    rpm_suspend() for UFS device fails because rpm_check_suspend_allowed()
    fails due to non-zero
    dev->power.runtime_error.
    
    To resolve this issue, make sure the first UFS runtime suspend get valid
    "hba" in ufshcd_runtime_suspend(): Enable UFS runtime PM only after hba is
    successfully bound to UFS device structure.
    
    Fixes: 62694735ca95 ([SCSI] ufs: Add runtime PM support for UFS host controller driver)
    Cc: stable@vger.kernel.org
    Signed-off-by: Stanley Chu <stanley.chu@mediatek.com>
    Reviewed-by: Avri Altman <avri.altman@wdc.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

commit 03b7af1ef4992bd0dc2b758e94698054fbbb19eb
Author: Jordan Crouse <jcrouse@codeaurora.org>
Date:   Tue May 7 13:18:11 2019 -0600

    drm/msm/adreno: Call pm_runtime_force_suspend() during unbind
    
    The GPU specific pm_suspend code assumes that the hardware is active
    when the function is called, which it usually is when called as part
    of pm_runtime.  But during unbind, the pm_suspend functions are called
    blindly resulting in a bit of a when the hardware wasn't already
    active (or booted, in the case of the GMU).
    
    Instead of calling the pm_suspend function directly, use
    pm_runtime_force_suspend() which should check the correct state of
    runtime and call the functions on our behalf or skip them if they are
    not needed.
    
    Signed-off-by: Jordan Crouse <jcrouse@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@chromium.org>

commit 0c7376ada9508141becec9b897d73b65ce66a15a
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Jun 7 00:32:31 2019 +0200

    PCI: PM: Replace pci_dev_keep_suspended() with two functions
    
    The code in pci_dev_keep_suspended() is relatively hard to follow due
    to the negative checks in it and in its callers and the function has
    a possible side-effect (disabling the PME) which doesn't really match
    its role.
    
    For this reason, move the PME disabling from pci_dev_keep_suspended()
    to a separate function and change the semantics (and name) of the
    rest of it, so that 'true' is returned when the device needs to be
    resumed (and not the other way around).  Change the callers of
    pci_dev_keep_suspended() accordingly.
    
    While at it, make the code flow in pci_pm_poweroff() reflect the
    pci_pm_suspend() more closely to avoid arbitrary differences between
    them.
    
    This is a cosmetic change with no intention to alter behavior.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>

commit 34cf175a429cac538eca353b21d46054e5a4705a
Author: Marek Szyprowski <m.szyprowski@samsung.com>
Date:   Mon Feb 18 15:34:12 2019 +0100

    ARM: exynos: Fix undefined instruction during Exynos5422 resume
    
    [ Upstream commit 4d8e3e951a856777720272ce27f2c738a3eeef8c ]
    
    During early system resume on Exynos5422 with performance counters enabled
    the following kernel oops happens:
    
        Internal error: Oops - undefined instruction: 0 [#1] PREEMPT SMP ARM
        Modules linked in:
        CPU: 0 PID: 1433 Comm: bash Tainted: G        W         5.0.0-rc5-next-20190208-00023-gd5fb5a8a13e6-dirty #5480
        Hardware name: SAMSUNG EXYNOS (Flattened Device Tree)
        ...
        Flags: nZCv  IRQs off  FIQs off  Mode SVC_32  ISA ARM  Segment none
        Control: 10c5387d  Table: 4451006a  DAC: 00000051
        Process bash (pid: 1433, stack limit = 0xb7e0e22f)
        ...
        (reset_ctrl_regs) from [<c0112ad0>] (dbg_cpu_pm_notify+0x1c/0x24)
        (dbg_cpu_pm_notify) from [<c014c840>] (notifier_call_chain+0x44/0x84)
        (notifier_call_chain) from [<c014cbc0>] (__atomic_notifier_call_chain+0x7c/0x128)
        (__atomic_notifier_call_chain) from [<c01ffaac>] (cpu_pm_notify+0x30/0x54)
        (cpu_pm_notify) from [<c055116c>] (syscore_resume+0x98/0x3f4)
        (syscore_resume) from [<c0189350>] (suspend_devices_and_enter+0x97c/0xe74)
        (suspend_devices_and_enter) from [<c0189fb8>] (pm_suspend+0x770/0xc04)
        (pm_suspend) from [<c0187740>] (state_store+0x6c/0xcc)
        (state_store) from [<c09fa698>] (kobj_attr_store+0x14/0x20)
        (kobj_attr_store) from [<c030159c>] (sysfs_kf_write+0x4c/0x50)
        (sysfs_kf_write) from [<c0300620>] (kernfs_fop_write+0xfc/0x1e0)
        (kernfs_fop_write) from [<c0282be8>] (__vfs_write+0x2c/0x160)
        (__vfs_write) from [<c0282ea4>] (vfs_write+0xa4/0x16c)
        (vfs_write) from [<c0283080>] (ksys_write+0x40/0x8c)
        (ksys_write) from [<c0101000>] (ret_fast_syscall+0x0/0x28)
    
    Undefined instruction is triggered during CP14 reset, because bits: #16
    (Secure privileged invasive debug disabled) and #17 (Secure privileged
    noninvasive debug disable) are set in DSCR. Those bits depend on SPNIDEN
    and SPIDEN lines, which are provided by Secure JTAG hardware block. That
    block in turn is powered from cluster 0 (big/Eagle), but the Exynos5422
    boots on cluster 1 (LITTLE/KFC).
    
    To fix this issue it is enough to turn on the power on the cluster 0 for
    a while. This lets the Secure JTAG block to propagate the needed signals
    to LITTLE/KFC cores and change their DSCR.
    
    Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Signed-off-by: Krzysztof Kozlowski <krzk@kernel.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit ce183fad3aa844379825372e3768e32c499d491e
Author: Marek Szyprowski <m.szyprowski@samsung.com>
Date:   Mon Feb 18 15:34:12 2019 +0100

    ARM: exynos: Fix undefined instruction during Exynos5422 resume
    
    [ Upstream commit 4d8e3e951a856777720272ce27f2c738a3eeef8c ]
    
    During early system resume on Exynos5422 with performance counters enabled
    the following kernel oops happens:
    
        Internal error: Oops - undefined instruction: 0 [#1] PREEMPT SMP ARM
        Modules linked in:
        CPU: 0 PID: 1433 Comm: bash Tainted: G        W         5.0.0-rc5-next-20190208-00023-gd5fb5a8a13e6-dirty #5480
        Hardware name: SAMSUNG EXYNOS (Flattened Device Tree)
        ...
        Flags: nZCv  IRQs off  FIQs off  Mode SVC_32  ISA ARM  Segment none
        Control: 10c5387d  Table: 4451006a  DAC: 00000051
        Process bash (pid: 1433, stack limit = 0xb7e0e22f)
        ...
        (reset_ctrl_regs) from [<c0112ad0>] (dbg_cpu_pm_notify+0x1c/0x24)
        (dbg_cpu_pm_notify) from [<c014c840>] (notifier_call_chain+0x44/0x84)
        (notifier_call_chain) from [<c014cbc0>] (__atomic_notifier_call_chain+0x7c/0x128)
        (__atomic_notifier_call_chain) from [<c01ffaac>] (cpu_pm_notify+0x30/0x54)
        (cpu_pm_notify) from [<c055116c>] (syscore_resume+0x98/0x3f4)
        (syscore_resume) from [<c0189350>] (suspend_devices_and_enter+0x97c/0xe74)
        (suspend_devices_and_enter) from [<c0189fb8>] (pm_suspend+0x770/0xc04)
        (pm_suspend) from [<c0187740>] (state_store+0x6c/0xcc)
        (state_store) from [<c09fa698>] (kobj_attr_store+0x14/0x20)
        (kobj_attr_store) from [<c030159c>] (sysfs_kf_write+0x4c/0x50)
        (sysfs_kf_write) from [<c0300620>] (kernfs_fop_write+0xfc/0x1e0)
        (kernfs_fop_write) from [<c0282be8>] (__vfs_write+0x2c/0x160)
        (__vfs_write) from [<c0282ea4>] (vfs_write+0xa4/0x16c)
        (vfs_write) from [<c0283080>] (ksys_write+0x40/0x8c)
        (ksys_write) from [<c0101000>] (ret_fast_syscall+0x0/0x28)
    
    Undefined instruction is triggered during CP14 reset, because bits: #16
    (Secure privileged invasive debug disabled) and #17 (Secure privileged
    noninvasive debug disable) are set in DSCR. Those bits depend on SPNIDEN
    and SPIDEN lines, which are provided by Secure JTAG hardware block. That
    block in turn is powered from cluster 0 (big/Eagle), but the Exynos5422
    boots on cluster 1 (LITTLE/KFC).
    
    To fix this issue it is enough to turn on the power on the cluster 0 for
    a while. This lets the Secure JTAG block to propagate the needed signals
    to LITTLE/KFC cores and change their DSCR.
    
    Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Signed-off-by: Krzysztof Kozlowski <krzk@kernel.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 06a9410221368ead1f971db464db3666840e535a
Author: Marek Szyprowski <m.szyprowski@samsung.com>
Date:   Mon Feb 18 15:34:12 2019 +0100

    ARM: exynos: Fix undefined instruction during Exynos5422 resume
    
    [ Upstream commit 4d8e3e951a856777720272ce27f2c738a3eeef8c ]
    
    During early system resume on Exynos5422 with performance counters enabled
    the following kernel oops happens:
    
        Internal error: Oops - undefined instruction: 0 [#1] PREEMPT SMP ARM
        Modules linked in:
        CPU: 0 PID: 1433 Comm: bash Tainted: G        W         5.0.0-rc5-next-20190208-00023-gd5fb5a8a13e6-dirty #5480
        Hardware name: SAMSUNG EXYNOS (Flattened Device Tree)
        ...
        Flags: nZCv  IRQs off  FIQs off  Mode SVC_32  ISA ARM  Segment none
        Control: 10c5387d  Table: 4451006a  DAC: 00000051
        Process bash (pid: 1433, stack limit = 0xb7e0e22f)
        ...
        (reset_ctrl_regs) from [<c0112ad0>] (dbg_cpu_pm_notify+0x1c/0x24)
        (dbg_cpu_pm_notify) from [<c014c840>] (notifier_call_chain+0x44/0x84)
        (notifier_call_chain) from [<c014cbc0>] (__atomic_notifier_call_chain+0x7c/0x128)
        (__atomic_notifier_call_chain) from [<c01ffaac>] (cpu_pm_notify+0x30/0x54)
        (cpu_pm_notify) from [<c055116c>] (syscore_resume+0x98/0x3f4)
        (syscore_resume) from [<c0189350>] (suspend_devices_and_enter+0x97c/0xe74)
        (suspend_devices_and_enter) from [<c0189fb8>] (pm_suspend+0x770/0xc04)
        (pm_suspend) from [<c0187740>] (state_store+0x6c/0xcc)
        (state_store) from [<c09fa698>] (kobj_attr_store+0x14/0x20)
        (kobj_attr_store) from [<c030159c>] (sysfs_kf_write+0x4c/0x50)
        (sysfs_kf_write) from [<c0300620>] (kernfs_fop_write+0xfc/0x1e0)
        (kernfs_fop_write) from [<c0282be8>] (__vfs_write+0x2c/0x160)
        (__vfs_write) from [<c0282ea4>] (vfs_write+0xa4/0x16c)
        (vfs_write) from [<c0283080>] (ksys_write+0x40/0x8c)
        (ksys_write) from [<c0101000>] (ret_fast_syscall+0x0/0x28)
    
    Undefined instruction is triggered during CP14 reset, because bits: #16
    (Secure privileged invasive debug disabled) and #17 (Secure privileged
    noninvasive debug disable) are set in DSCR. Those bits depend on SPNIDEN
    and SPIDEN lines, which are provided by Secure JTAG hardware block. That
    block in turn is powered from cluster 0 (big/Eagle), but the Exynos5422
    boots on cluster 1 (LITTLE/KFC).
    
    To fix this issue it is enough to turn on the power on the cluster 0 for
    a while. This lets the Secure JTAG block to propagate the needed signals
    to LITTLE/KFC cores and change their DSCR.
    
    Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Signed-off-by: Krzysztof Kozlowski <krzk@kernel.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 4b4b077cbd0a998aebaa72c199e06b8a4c8dcfee
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Mon Jun 10 15:54:37 2019 -0700

    dma-remap: Avoid de-referencing NULL atomic_pool
    
    With architectures allowing the kernel to be placed almost arbitrarily
    in memory (e.g.: ARM64), it is possible to have the kernel resides at
    physical addresses above 4GB, resulting in neither the default CMA area,
    nor the atomic pool from successfully allocating. This does not prevent
    specific peripherals from working though, one example is XHCI, which
    still operates correctly.
    
    Trouble comes when the XHCI driver gets suspended and resumed, since we
    can now trigger the following NPD:
    
    [   12.664170] usb usb1: root hub lost power or was reset
    [   12.669387] usb usb2: root hub lost power or was reset
    [   12.674662] Unable to handle kernel NULL pointer dereference at virtual address 00000008
    [   12.682896] pgd = ffffffc1365a7000
    [   12.686386] [00000008] *pgd=0000000136500003, *pud=0000000136500003, *pmd=0000000000000000
    [   12.694897] Internal error: Oops: 96000006 [#1] SMP
    [   12.699843] Modules linked in:
    [   12.702980] CPU: 0 PID: 1499 Comm: pml Not tainted 4.9.135-1.13pre #51
    [   12.709577] Hardware name: BCM97268DV (DT)
    [   12.713736] task: ffffffc136bb6540 task.stack: ffffffc1366cc000
    [   12.719740] PC is at addr_in_gen_pool+0x4/0x48
    [   12.724253] LR is at __dma_free+0x64/0xbc
    [   12.728325] pc : [<ffffff80083c0df8>] lr : [<ffffff80080979e0>] pstate: 60000145
    [   12.735825] sp : ffffffc1366cf990
    [   12.739196] x29: ffffffc1366cf990 x28: ffffffc1366cc000
    [   12.744608] x27: 0000000000000000 x26: ffffffc13a8568c8
    [   12.750020] x25: 0000000000000000 x24: ffffff80098f9000
    [   12.755433] x23: 000000013a5ff000 x22: ffffff8009c57000
    [   12.760844] x21: ffffffc13a856810 x20: 0000000000000000
    [   12.766255] x19: 0000000000001000 x18: 000000000000000a
    [   12.771667] x17: 0000007f917553e0 x16: 0000000000001002
    [   12.777078] x15: 00000000000a36cb x14: ffffff80898feb77
    [   12.782490] x13: ffffffffffffffff x12: 0000000000000030
    [   12.787899] x11: 00000000fffffffe x10: ffffff80098feb7f
    [   12.793311] x9 : 0000000005f5e0ff x8 : 65776f702074736f
    [   12.798723] x7 : 6c2062756820746f x6 : ffffff80098febb1
    [   12.804134] x5 : ffffff800809797c x4 : 0000000000000000
    [   12.809545] x3 : 000000013a5ff000 x2 : 0000000000000fff
    [   12.814955] x1 : ffffff8009c57000 x0 : 0000000000000000
    [   12.820363]
    [   12.821907] Process pml (pid: 1499, stack limit = 0xffffffc1366cc020)
    [   12.828421] Stack: (0xffffffc1366cf990 to 0xffffffc1366d0000)
    [   12.834240] f980:                                   ffffffc1366cf9e0 ffffff80086004d0
    [   12.842186] f9a0: ffffffc13ab08238 0000000000000010 ffffff80097c2218 ffffffc13a856810
    [   12.850131] f9c0: ffffff8009c57000 000000013a5ff000 0000000000000008 000000013a5ff000
    [   12.858076] f9e0: ffffffc1366cfa50 ffffff80085f9250 ffffffc13ab08238 0000000000000004
    [   12.866021] fa00: ffffffc13ab08000 ffffff80097b6000 ffffffc13ab08130 0000000000000001
    [   12.873966] fa20: 0000000000000008 ffffffc13a8568c8 0000000000000000 ffffffc1366cc000
    [   12.881911] fa40: ffffffc13ab08130 0000000000000001 ffffffc1366cfa90 ffffff80085e3de8
    [   12.889856] fa60: ffffffc13ab08238 0000000000000000 ffffffc136b75b00 0000000000000000
    [   12.897801] fa80: 0000000000000010 ffffff80089ccb92 ffffffc1366cfac0 ffffff80084ad040
    [   12.905746] faa0: ffffffc13a856810 0000000000000000 ffffff80084ad004 ffffff80084b91a8
    [   12.913691] fac0: ffffffc1366cfae0 ffffff80084b91b4 ffffffc13a856810 ffffff80080db5cc
    [   12.921636] fae0: ffffffc1366cfb20 ffffff80084b96bc ffffffc13a856810 0000000000000010
    [   12.929581] fb00: ffffffc13a856870 0000000000000000 ffffffc13a856810 ffffff800984d2b8
    [   12.937526] fb20: ffffffc1366cfb50 ffffff80084baa70 ffffff8009932ad0 ffffff800984d260
    [   12.945471] fb40: 0000000000000010 00000002eff0a065 ffffffc1366cfbb0 ffffff80084bafbc
    [   12.953415] fb60: 0000000000000010 0000000000000003 ffffff80098fe000 0000000000000000
    [   12.961360] fb80: ffffff80097b6000 ffffff80097b6dc8 ffffff80098c12b8 ffffff80098c12f8
    [   12.969306] fba0: ffffff8008842000 ffffff80097b6dc8 ffffffc1366cfbd0 ffffff80080e0d88
    [   12.977251] fbc0: 00000000fffffffb ffffff80080e10bc ffffffc1366cfc60 ffffff80080e16a8
    [   12.985196] fbe0: 0000000000000000 0000000000000003 ffffff80097b6000 ffffff80098fe9f0
    [   12.993140] fc00: ffffff80097d4000 ffffff8008983802 0000000000000123 0000000000000040
    [   13.001085] fc20: ffffff8008842000 ffffffc1366cc000 ffffff80089803c2 00000000ffffffff
    [   13.009029] fc40: 0000000000000000 0000000000000000 ffffffc1366cfc60 0000000000040987
    [   13.016974] fc60: ffffffc1366cfcc0 ffffff80080dfd08 0000000000000003 0000000000000004
    [   13.024919] fc80: 0000000000000003 ffffff80098fea08 ffffffc136577ec0 ffffff80089803c2
    [   13.032864] fca0: 0000000000000123 0000000000000001 0000000500000002 0000000000040987
    [   13.040809] fcc0: ffffffc1366cfd00 ffffff80083a89d4 0000000000000004 ffffffc136577ec0
    [   13.048754] fce0: ffffffc136610cc0 ffffffffffffffea ffffffc1366cfeb0 ffffffc136610cd8
    [   13.056700] fd00: ffffffc1366cfd10 ffffff800822a614 ffffffc1366cfd40 ffffff80082295d4
    [   13.064645] fd20: 0000000000000004 ffffffc136577ec0 ffffffc136610cc0 0000000021670570
    [   13.072590] fd40: ffffffc1366cfd80 ffffff80081b5d10 ffffff80097b6000 ffffffc13aae4200
    [   13.080536] fd60: ffffffc1366cfeb0 0000000000000004 0000000021670570 0000000000000004
    [   13.088481] fd80: ffffffc1366cfe30 ffffff80081b6b20 ffffffc13aae4200 0000000000000000
    [   13.096427] fda0: 0000000000000004 0000000021670570 ffffffc1366cfeb0 ffffffc13a838200
    [   13.104371] fdc0: 0000000000000000 000000000000000a ffffff80097b6000 0000000000040987
    [   13.112316] fde0: ffffffc1366cfe20 ffffff80081b3af0 ffffffc13a838200 0000000000000000
    [   13.120261] fe00: ffffffc1366cfe30 ffffff80081b6b0c ffffffc13aae4200 0000000000000000
    [   13.128206] fe20: 0000000000000004 0000000000040987 ffffffc1366cfe70 ffffff80081b7dd8
    [   13.136151] fe40: ffffff80097b6000 ffffffc13aae4200 ffffffc13aae4200 fffffffffffffff7
    [   13.144096] fe60: 0000000021670570 ffffffc13a8c63c0 0000000000000000 ffffff8008083180
    [   13.152042] fe80: ffffffffffffff1d 0000000021670570 ffffffffffffffff 0000007f917ad9b8
    [   13.159986] fea0: 0000000020000000 0000000000000015 0000000000000000 0000000000040987
    [   13.167930] fec0: 0000000000000001 0000000021670570 0000000000000004 0000000000000000
    [   13.175874] fee0: 0000000000000888 0000440110000000 000000000000006d 0000000000000003
    [   13.183819] ff00: 0000000000000040 ffffff80ffffffc8 0000000000000000 0000000000000020
    [   13.191762] ff20: 0000000000000000 0000000000000000 0000000000000001 0000000000000000
    [   13.199707] ff40: 0000000000000000 0000007f917553e0 0000000000000000 0000000000000004
    [   13.207651] ff60: 0000000021670570 0000007f91835480 0000000000000004 0000007f91831638
    [   13.215595] ff80: 0000000000000004 00000000004b0de0 00000000004b0000 0000000000000000
    [   13.223539] ffa0: 0000000000000000 0000007fc92ac8c0 0000007f9175d178 0000007fc92ac8c0
    [   13.231483] ffc0: 0000007f917ad9b8 0000000020000000 0000000000000001 0000000000000040
    [   13.239427] ffe0: 0000000000000000 0000000000000000 0000000000000000 0000000000000000
    [   13.247360] Call trace:
    [   13.249866] Exception stack(0xffffffc1366cf7a0 to 0xffffffc1366cf8d0)
    [   13.256386] f7a0: 0000000000001000 0000007fffffffff ffffffc1366cf990 ffffff80083c0df8
    [   13.264331] f7c0: 0000000060000145 ffffff80089b5001 ffffffc13ab08130 0000000000000001
    [   13.272275] f7e0: 0000000000000008 ffffffc13a8568c8 0000000000000000 0000000000000000
    [   13.280220] f800: ffffffc1366cf960 ffffffc1366cf960 ffffffc1366cf930 00000000ffffffd8
    [   13.288165] f820: ffffff8009931ac0 4554535953425553 4544006273753d4d 3831633d45434956
    [   13.296110] f840: ffff003832313a39 ffffff800845926c ffffffc1366cf880 0000000000040987
    [   13.304054] f860: 0000000000000000 ffffff8009c57000 0000000000000fff 000000013a5ff000
    [   13.311999] f880: 0000000000000000 ffffff800809797c ffffff80098febb1 6c2062756820746f
    [   13.319944] f8a0: 65776f702074736f 0000000005f5e0ff ffffff80098feb7f 00000000fffffffe
    [   13.327884] f8c0: 0000000000000030 ffffffffffffffff
    [   13.332835] [<ffffff80083c0df8>] addr_in_gen_pool+0x4/0x48
    [   13.338398] [<ffffff80086004d0>] xhci_mem_cleanup+0xc8/0x51c
    [   13.344137] [<ffffff80085f9250>] xhci_resume+0x308/0x65c
    [   13.349524] [<ffffff80085e3de8>] xhci_brcm_resume+0x84/0x8c
    [   13.355174] [<ffffff80084ad040>] platform_pm_resume+0x3c/0x64
    [   13.360997] [<ffffff80084b91b4>] dpm_run_callback+0x5c/0x15c
    [   13.366732] [<ffffff80084b96bc>] device_resume+0xc0/0x190
    [   13.372205] [<ffffff80084baa70>] dpm_resume+0x144/0x2cc
    [   13.377504] [<ffffff80084bafbc>] dpm_resume_end+0x20/0x34
    [   13.382980] [<ffffff80080e0d88>] suspend_devices_and_enter+0x104/0x704
    [   13.389585] [<ffffff80080e16a8>] pm_suspend+0x320/0x53c
    [   13.394881] [<ffffff80080dfd08>] state_store+0xbc/0xe0
    [   13.400094] [<ffffff80083a89d4>] kobj_attr_store+0x14/0x24
    [   13.405655] [<ffffff800822a614>] sysfs_kf_write+0x60/0x70
    [   13.411128] [<ffffff80082295d4>] kernfs_fop_write+0x130/0x194
    [   13.416954] [<ffffff80081b5d10>] __vfs_write+0x60/0x150
    [   13.422254] [<ffffff80081b6b20>] vfs_write+0xc8/0x164
    [   13.427376] [<ffffff80081b7dd8>] SyS_write+0x70/0xc8
    [   13.432412] [<ffffff8008083180>] el0_svc_naked+0x34/0x38
    [   13.437800] Code: 92800173 97f6fb9e 17fffff5 d1000442 (f8408c03)
    [   13.444033] ---[ end trace 2effe12f909ce205 ]---
    
    The call path leading to this problem is xhci_mem_cleanup() ->
    dma_free_coherent() -> dma_free_from_pool() -> addr_in_gen_pool. If the
    atomic_pool is NULL, we can't possibly have the address in the atomic
    pool anyway, so guard against that.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

commit 3540d38dd38308b811c6ddaf2fde03e9948cc1c1
Author: Bart Van Assche <bvanassche@acm.org>
Date:   Wed Jun 5 09:12:37 2019 -0700

    PM: sleep: Show how long dpm_suspend_start() and dpm_suspend_end() take
    
    When debugging device driver power management code it is convenient to
    know how much time is spent in the "suspend start" and "suspend end"
    phases. Hence log the time spent in these phases.
    
    Signed-off-by: Bart Van Assche <bvanassche@acm.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit a61373476127edac8bcc5ee9d68a74dc1b864f53
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon May 27 12:45:18 2019 +0200

    PM: sleep: Add kerneldoc comments to some functions
    
    Add kerneldoc comments to pm_suspend_via_firmware(),
    pm_resume_via_firmware() and pm_suspend_via_s2idle()
    to explain what they do.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 663411719895b93e3e57709441585377a8e867f0
Author: Marek Szyprowski <m.szyprowski@samsung.com>
Date:   Wed Mar 27 10:56:08 2019 +0100

    usb: dwc3: move synchronize_irq() out of the spinlock protected block
    
    [ Upstream commit 41a91c606e7d2b74358a944525267cc451c271e8 ]
    
    dwc3_gadget_suspend() is called under dwc->lock spinlock. In such context
    calling synchronize_irq() is not allowed. Move the problematic call out
    of the protected block to fix the following kernel BUG during system
    suspend:
    
    BUG: sleeping function called from invalid context at kernel/irq/manage.c:112
    in_atomic(): 1, irqs_disabled(): 128, pid: 1601, name: rtcwake
    6 locks held by rtcwake/1601:
     #0: f70ac2a2 (sb_writers#7){.+.+}, at: vfs_write+0x130/0x16c
     #1: b5fe1270 (&of->mutex){+.+.}, at: kernfs_fop_write+0xc0/0x1e4
     #2: 7e597705 (kn->count#60){.+.+}, at: kernfs_fop_write+0xc8/0x1e4
     #3: 8b3527d0 (system_transition_mutex){+.+.}, at: pm_suspend+0xc4/0xc04
     #4: fc7f1c42 (&dev->mutex){....}, at: __device_suspend+0xd8/0x74c
     #5: 4b36507e (&(&dwc->lock)->rlock){....}, at: dwc3_gadget_suspend+0x24/0x3c
    irq event stamp: 11252
    hardirqs last  enabled at (11251): [<c09c54a4>] _raw_spin_unlock_irqrestore+0x6c/0x74
    hardirqs last disabled at (11252): [<c09c4d44>] _raw_spin_lock_irqsave+0x1c/0x5c
    softirqs last  enabled at (9744): [<c0102564>] __do_softirq+0x3a4/0x66c
    softirqs last disabled at (9737): [<c0128528>] irq_exit+0x140/0x168
    Preemption disabled at:
    [<00000000>]   (null)
    CPU: 7 PID: 1601 Comm: rtcwake Not tainted
    5.0.0-rc3-next-20190122-00039-ga3f4ee4f8a52 #5252
    Hardware name: SAMSUNG EXYNOS (Flattened Device Tree)
    [<c01110f0>] (unwind_backtrace) from [<c010d120>] (show_stack+0x10/0x14)
    [<c010d120>] (show_stack) from [<c09a4d04>] (dump_stack+0x90/0xc8)
    [<c09a4d04>] (dump_stack) from [<c014c700>] (___might_sleep+0x22c/0x2c8)
    [<c014c700>] (___might_sleep) from [<c0189d68>] (synchronize_irq+0x28/0x84)
    [<c0189d68>] (synchronize_irq) from [<c05cbbf8>] (dwc3_gadget_suspend+0x34/0x3c)
    [<c05cbbf8>] (dwc3_gadget_suspend) from [<c05bd020>] (dwc3_suspend_common+0x154/0x410)
    [<c05bd020>] (dwc3_suspend_common) from [<c05bd34c>] (dwc3_suspend+0x14/0x2c)
    [<c05bd34c>] (dwc3_suspend) from [<c051c730>] (platform_pm_suspend+0x2c/0x54)
    [<c051c730>] (platform_pm_suspend) from [<c05285d4>] (dpm_run_callback+0xa4/0x3dc)
    [<c05285d4>] (dpm_run_callback) from [<c0528a40>] (__device_suspend+0x134/0x74c)
    [<c0528a40>] (__device_suspend) from [<c052c508>] (dpm_suspend+0x174/0x588)
    [<c052c508>] (dpm_suspend) from [<c0182134>] (suspend_devices_and_enter+0xc0/0xe74)
    [<c0182134>] (suspend_devices_and_enter) from [<c0183658>] (pm_suspend+0x770/0xc04)
    [<c0183658>] (pm_suspend) from [<c0180ddc>] (state_store+0x6c/0xcc)
    [<c0180ddc>] (state_store) from [<c09a9a70>] (kobj_attr_store+0x14/0x20)
    [<c09a9a70>] (kobj_attr_store) from [<c02d6800>] (sysfs_kf_write+0x4c/0x50)
    [<c02d6800>] (sysfs_kf_write) from [<c02d594c>] (kernfs_fop_write+0xfc/0x1e4)
    [<c02d594c>] (kernfs_fop_write) from [<c02593d8>] (__vfs_write+0x2c/0x160)
    [<c02593d8>] (__vfs_write) from [<c0259694>] (vfs_write+0xa4/0x16c)
    [<c0259694>] (vfs_write) from [<c0259870>] (ksys_write+0x40/0x8c)
    [<c0259870>] (ksys_write) from [<c0101000>] (ret_fast_syscall+0x0/0x28)
    Exception stack(0xed55ffa8 to 0xed55fff0)
    ...
    
    Fixes: 01c10880d242 ("usb: dwc3: gadget: synchronize_irq dwc irq in suspend")
    Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit d9681887b3249f37854775bd899beacb820d4aa2
Author: Marek Szyprowski <m.szyprowski@samsung.com>
Date:   Wed Mar 27 10:56:08 2019 +0100

    usb: dwc3: move synchronize_irq() out of the spinlock protected block
    
    [ Upstream commit 41a91c606e7d2b74358a944525267cc451c271e8 ]
    
    dwc3_gadget_suspend() is called under dwc->lock spinlock. In such context
    calling synchronize_irq() is not allowed. Move the problematic call out
    of the protected block to fix the following kernel BUG during system
    suspend:
    
    BUG: sleeping function called from invalid context at kernel/irq/manage.c:112
    in_atomic(): 1, irqs_disabled(): 128, pid: 1601, name: rtcwake
    6 locks held by rtcwake/1601:
     #0: f70ac2a2 (sb_writers#7){.+.+}, at: vfs_write+0x130/0x16c
     #1: b5fe1270 (&of->mutex){+.+.}, at: kernfs_fop_write+0xc0/0x1e4
     #2: 7e597705 (kn->count#60){.+.+}, at: kernfs_fop_write+0xc8/0x1e4
     #3: 8b3527d0 (system_transition_mutex){+.+.}, at: pm_suspend+0xc4/0xc04
     #4: fc7f1c42 (&dev->mutex){....}, at: __device_suspend+0xd8/0x74c
     #5: 4b36507e (&(&dwc->lock)->rlock){....}, at: dwc3_gadget_suspend+0x24/0x3c
    irq event stamp: 11252
    hardirqs last  enabled at (11251): [<c09c54a4>] _raw_spin_unlock_irqrestore+0x6c/0x74
    hardirqs last disabled at (11252): [<c09c4d44>] _raw_spin_lock_irqsave+0x1c/0x5c
    softirqs last  enabled at (9744): [<c0102564>] __do_softirq+0x3a4/0x66c
    softirqs last disabled at (9737): [<c0128528>] irq_exit+0x140/0x168
    Preemption disabled at:
    [<00000000>]   (null)
    CPU: 7 PID: 1601 Comm: rtcwake Not tainted
    5.0.0-rc3-next-20190122-00039-ga3f4ee4f8a52 #5252
    Hardware name: SAMSUNG EXYNOS (Flattened Device Tree)
    [<c01110f0>] (unwind_backtrace) from [<c010d120>] (show_stack+0x10/0x14)
    [<c010d120>] (show_stack) from [<c09a4d04>] (dump_stack+0x90/0xc8)
    [<c09a4d04>] (dump_stack) from [<c014c700>] (___might_sleep+0x22c/0x2c8)
    [<c014c700>] (___might_sleep) from [<c0189d68>] (synchronize_irq+0x28/0x84)
    [<c0189d68>] (synchronize_irq) from [<c05cbbf8>] (dwc3_gadget_suspend+0x34/0x3c)
    [<c05cbbf8>] (dwc3_gadget_suspend) from [<c05bd020>] (dwc3_suspend_common+0x154/0x410)
    [<c05bd020>] (dwc3_suspend_common) from [<c05bd34c>] (dwc3_suspend+0x14/0x2c)
    [<c05bd34c>] (dwc3_suspend) from [<c051c730>] (platform_pm_suspend+0x2c/0x54)
    [<c051c730>] (platform_pm_suspend) from [<c05285d4>] (dpm_run_callback+0xa4/0x3dc)
    [<c05285d4>] (dpm_run_callback) from [<c0528a40>] (__device_suspend+0x134/0x74c)
    [<c0528a40>] (__device_suspend) from [<c052c508>] (dpm_suspend+0x174/0x588)
    [<c052c508>] (dpm_suspend) from [<c0182134>] (suspend_devices_and_enter+0xc0/0xe74)
    [<c0182134>] (suspend_devices_and_enter) from [<c0183658>] (pm_suspend+0x770/0xc04)
    [<c0183658>] (pm_suspend) from [<c0180ddc>] (state_store+0x6c/0xcc)
    [<c0180ddc>] (state_store) from [<c09a9a70>] (kobj_attr_store+0x14/0x20)
    [<c09a9a70>] (kobj_attr_store) from [<c02d6800>] (sysfs_kf_write+0x4c/0x50)
    [<c02d6800>] (sysfs_kf_write) from [<c02d594c>] (kernfs_fop_write+0xfc/0x1e4)
    [<c02d594c>] (kernfs_fop_write) from [<c02593d8>] (__vfs_write+0x2c/0x160)
    [<c02593d8>] (__vfs_write) from [<c0259694>] (vfs_write+0xa4/0x16c)
    [<c0259694>] (vfs_write) from [<c0259870>] (ksys_write+0x40/0x8c)
    [<c0259870>] (ksys_write) from [<c0101000>] (ret_fast_syscall+0x0/0x28)
    Exception stack(0xed55ffa8 to 0xed55fff0)
    ...
    
    Fixes: 01c10880d242 ("usb: dwc3: gadget: synchronize_irq dwc irq in suspend")
    Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 79137ab40c3b7cc2fbaefbc3f9281c47afb95cfc
Author: Marek Szyprowski <m.szyprowski@samsung.com>
Date:   Wed Mar 27 10:56:08 2019 +0100

    usb: dwc3: move synchronize_irq() out of the spinlock protected block
    
    [ Upstream commit 41a91c606e7d2b74358a944525267cc451c271e8 ]
    
    dwc3_gadget_suspend() is called under dwc->lock spinlock. In such context
    calling synchronize_irq() is not allowed. Move the problematic call out
    of the protected block to fix the following kernel BUG during system
    suspend:
    
    BUG: sleeping function called from invalid context at kernel/irq/manage.c:112
    in_atomic(): 1, irqs_disabled(): 128, pid: 1601, name: rtcwake
    6 locks held by rtcwake/1601:
     #0: f70ac2a2 (sb_writers#7){.+.+}, at: vfs_write+0x130/0x16c
     #1: b5fe1270 (&of->mutex){+.+.}, at: kernfs_fop_write+0xc0/0x1e4
     #2: 7e597705 (kn->count#60){.+.+}, at: kernfs_fop_write+0xc8/0x1e4
     #3: 8b3527d0 (system_transition_mutex){+.+.}, at: pm_suspend+0xc4/0xc04
     #4: fc7f1c42 (&dev->mutex){....}, at: __device_suspend+0xd8/0x74c
     #5: 4b36507e (&(&dwc->lock)->rlock){....}, at: dwc3_gadget_suspend+0x24/0x3c
    irq event stamp: 11252
    hardirqs last  enabled at (11251): [<c09c54a4>] _raw_spin_unlock_irqrestore+0x6c/0x74
    hardirqs last disabled at (11252): [<c09c4d44>] _raw_spin_lock_irqsave+0x1c/0x5c
    softirqs last  enabled at (9744): [<c0102564>] __do_softirq+0x3a4/0x66c
    softirqs last disabled at (9737): [<c0128528>] irq_exit+0x140/0x168
    Preemption disabled at:
    [<00000000>]   (null)
    CPU: 7 PID: 1601 Comm: rtcwake Not tainted
    5.0.0-rc3-next-20190122-00039-ga3f4ee4f8a52 #5252
    Hardware name: SAMSUNG EXYNOS (Flattened Device Tree)
    [<c01110f0>] (unwind_backtrace) from [<c010d120>] (show_stack+0x10/0x14)
    [<c010d120>] (show_stack) from [<c09a4d04>] (dump_stack+0x90/0xc8)
    [<c09a4d04>] (dump_stack) from [<c014c700>] (___might_sleep+0x22c/0x2c8)
    [<c014c700>] (___might_sleep) from [<c0189d68>] (synchronize_irq+0x28/0x84)
    [<c0189d68>] (synchronize_irq) from [<c05cbbf8>] (dwc3_gadget_suspend+0x34/0x3c)
    [<c05cbbf8>] (dwc3_gadget_suspend) from [<c05bd020>] (dwc3_suspend_common+0x154/0x410)
    [<c05bd020>] (dwc3_suspend_common) from [<c05bd34c>] (dwc3_suspend+0x14/0x2c)
    [<c05bd34c>] (dwc3_suspend) from [<c051c730>] (platform_pm_suspend+0x2c/0x54)
    [<c051c730>] (platform_pm_suspend) from [<c05285d4>] (dpm_run_callback+0xa4/0x3dc)
    [<c05285d4>] (dpm_run_callback) from [<c0528a40>] (__device_suspend+0x134/0x74c)
    [<c0528a40>] (__device_suspend) from [<c052c508>] (dpm_suspend+0x174/0x588)
    [<c052c508>] (dpm_suspend) from [<c0182134>] (suspend_devices_and_enter+0xc0/0xe74)
    [<c0182134>] (suspend_devices_and_enter) from [<c0183658>] (pm_suspend+0x770/0xc04)
    [<c0183658>] (pm_suspend) from [<c0180ddc>] (state_store+0x6c/0xcc)
    [<c0180ddc>] (state_store) from [<c09a9a70>] (kobj_attr_store+0x14/0x20)
    [<c09a9a70>] (kobj_attr_store) from [<c02d6800>] (sysfs_kf_write+0x4c/0x50)
    [<c02d6800>] (sysfs_kf_write) from [<c02d594c>] (kernfs_fop_write+0xfc/0x1e4)
    [<c02d594c>] (kernfs_fop_write) from [<c02593d8>] (__vfs_write+0x2c/0x160)
    [<c02593d8>] (__vfs_write) from [<c0259694>] (vfs_write+0xa4/0x16c)
    [<c0259694>] (vfs_write) from [<c0259870>] (ksys_write+0x40/0x8c)
    [<c0259870>] (ksys_write) from [<c0101000>] (ret_fast_syscall+0x0/0x28)
    Exception stack(0xed55ffa8 to 0xed55fff0)
    ...
    
    Fixes: 01c10880d242 ("usb: dwc3: gadget: synchronize_irq dwc irq in suspend")
    Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit d491f2b75237ef37d8867830ab7fad8d9659e853
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri May 17 11:08:50 2019 +0200

    PCI: PM: Avoid possible suspend-to-idle issue
    
    If a PCI driver leaves the device handled by it in D0 and calls
    pci_save_state() on the device in its ->suspend() or ->suspend_late()
    callback, it can expect the device to stay in D0 over the whole
    s2idle cycle.  However, that may not be the case if there is a
    spurious wakeup while the system is suspended, because in that case
    pci_pm_suspend_noirq() will run again after pci_pm_resume_noirq()
    which calls pci_restore_state(), via pci_pm_default_resume_early(),
    so state_saved is cleared and the second iteration of
    pci_pm_suspend_noirq() will invoke pci_prepare_to_sleep() which
    may change the power state of the device.
    
    To avoid that, add a new internal flag, skip_bus_pm, that will be set
    by pci_pm_suspend_noirq() when it runs for the first time during the
    given system suspend-resume cycle if the state of the device has
    been saved already and the device is still in D0.  Setting that flag
    will cause the next iterations of pci_pm_suspend_noirq() to set
    state_saved for pci_pm_resume_noirq(), so that it always restores the
    device state from the originally saved data, and avoid calling
    pci_prepare_to_sleep() for the device.
    
    Fixes: 33e4f80ee69b ("ACPI / PM: Ignore spurious SCI wakeups from suspend-to-idle")
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Keith Busch <keith.busch@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>

commit bb1869012d7b78d1474808cb4c8bd8b272645876
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu May 16 12:43:19 2019 +0200

    ACPI: PM: Call pm_set_suspend_via_firmware() during hibernation
    
    On systems with ACPI platform firmware the last stage of hibernation
    is analogous to system suspend to S3 (suspend-to-RAM), so it should
    be handled analogously.  In particular, pm_suspend_via_firmware()
    should return 'true' in that stage to let the callers of it know that
    control will be passed to the platform firmware going forward, so
    pm_set_suspend_via_firmware() needs to be called then in analogy with
    acpi_suspend_begin().
    
    However, the platform hibernation ->begin() callback is invoked
    during the "freeze" transition (before creating a snapshot image of
    system memory) as well as during the "hibernate" transition which is
    the last stage of it and pm_set_suspend_via_firmware() should be
    invoked by that callback in the latter stage only.
    
    In order to implement that redefine the hibernation ->begin()
    callback to take a pm_message_t argument to indicate which stage
    of hibernation is taking place and rework acpi_hibernation_begin()
    and acpi_hibernation_begin_old() to take it into account as needed.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 2eb06c306a579853346d22eda73332ed4f3e81e3
Author: Wanpeng Li <wanpengli@tencent.com>
Date:   Fri May 17 16:49:49 2019 +0800

    KVM: Fix spinlock taken warning during host resume
    
     WARNING: CPU: 0 PID: 13554 at kvm/arch/x86/kvm//../../../virt/kvm/kvm_main.c:4183 kvm_resume+0x3c/0x40 [kvm]
      CPU: 0 PID: 13554 Comm: step_after_susp Tainted: G           OE     5.1.0-rc4+ #1
      RIP: 0010:kvm_resume+0x3c/0x40 [kvm]
      Call Trace:
       syscore_resume+0x63/0x2d0
       suspend_devices_and_enter+0x9d1/0xa40
       pm_suspend+0x33a/0x3b0
       state_store+0x82/0xf0
       kobj_attr_store+0x12/0x20
       sysfs_kf_write+0x4b/0x60
       kernfs_fop_write+0x120/0x1a0
       __vfs_write+0x1b/0x40
       vfs_write+0xcd/0x1d0
       ksys_write+0x5f/0xe0
       __x64_sys_write+0x1a/0x20
       do_syscall_64+0x6f/0x6c0
       entry_SYSCALL_64_after_hwframe+0x49/0xbe
    
    Commit ca84d1a24 (KVM: x86: Add clock sync request to hardware enable) mentioned
    that "we always hold kvm_lock when hardware_enable is called.  The one place that
    doesn't need to worry about it is resume, as resuming a frozen CPU, the spinlock
    won't be taken." However, commit 6706dae9 (virt/kvm: Replace spin_is_locked() with
    lockdep) introduces a bug, it asserts when the lock is not held which is contrary
    to the original goal.
    
    This patch fixes it by WARN_ON when the lock is held.
    
    Cc: Paolo Bonzini <pbonzini@redhat.com>
    Cc: Radim Krčmář <rkrcmar@redhat.com>
    Cc: Paul E. McKenney <paulmck@linux.ibm.com>
    Signed-off-by: Wanpeng Li <wanpengli@tencent.com>
    Fixes: 6706dae9 ("virt/kvm: Replace spin_is_locked() with lockdep")
    [Wrap with #ifdef CONFIG_LOCKDEP - Paolo]
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>

commit a67f81c85e93462b6395c582a10d36d7f9ae6f1c
Author: Josh Poimboeuf <jpoimboe@redhat.com>
Date:   Fri Dec 2 11:42:21 2016 -0600

    x86/suspend: fix false positive KASAN warning on suspend/resume
    
    commit b53f40db59b27b62bc294c30506b02a0cae47e0b upstream.
    
    Resuming from a suspend operation is showing a KASAN false positive
    warning:
    
      BUG: KASAN: stack-out-of-bounds in unwind_get_return_address+0x11d/0x130 at addr ffff8803867d7878
      Read of size 8 by task pm-suspend/7774
      page:ffffea000e19f5c0 count:0 mapcount:0 mapping:          (null) index:0x0
      flags: 0x2ffff0000000000()
      page dumped because: kasan: bad access detected
      CPU: 0 PID: 7774 Comm: pm-suspend Tainted: G    B           4.9.0-rc7+ #8
      Hardware name: Gigabyte Technology Co., Ltd. Z170X-UD5/Z170X-UD5-CF, BIOS F5 03/07/2016
      Call Trace:
        dump_stack+0x63/0x82
        kasan_report_error+0x4b4/0x4e0
        ? acpi_hw_read_port+0xd0/0x1ea
        ? kfree_const+0x22/0x30
        ? acpi_hw_validate_io_request+0x1a6/0x1a6
        __asan_report_load8_noabort+0x61/0x70
        ? unwind_get_return_address+0x11d/0x130
        unwind_get_return_address+0x11d/0x130
        ? unwind_next_frame+0x97/0xf0
        __save_stack_trace+0x92/0x100
        save_stack_trace+0x1b/0x20
        save_stack+0x46/0xd0
        ? save_stack_trace+0x1b/0x20
        ? save_stack+0x46/0xd0
        ? kasan_kmalloc+0xad/0xe0
        ? kasan_slab_alloc+0x12/0x20
        ? acpi_hw_read+0x2b6/0x3aa
        ? acpi_hw_validate_register+0x20b/0x20b
        ? acpi_hw_write_port+0x72/0xc7
        ? acpi_hw_write+0x11f/0x15f
        ? acpi_hw_read_multiple+0x19f/0x19f
        ? memcpy+0x45/0x50
        ? acpi_hw_write_port+0x72/0xc7
        ? acpi_hw_write+0x11f/0x15f
        ? acpi_hw_read_multiple+0x19f/0x19f
        ? kasan_unpoison_shadow+0x36/0x50
        kasan_kmalloc+0xad/0xe0
        kasan_slab_alloc+0x12/0x20
        kmem_cache_alloc_trace+0xbc/0x1e0
        ? acpi_get_sleep_type_data+0x9a/0x578
        acpi_get_sleep_type_data+0x9a/0x578
        acpi_hw_legacy_wake_prep+0x88/0x22c
        ? acpi_hw_legacy_sleep+0x3c7/0x3c7
        ? acpi_write_bit_register+0x28d/0x2d3
        ? acpi_read_bit_register+0x19b/0x19b
        acpi_hw_sleep_dispatch+0xb5/0xba
        acpi_leave_sleep_state_prep+0x17/0x19
        acpi_suspend_enter+0x154/0x1e0
        ? trace_suspend_resume+0xe8/0xe8
        suspend_devices_and_enter+0xb09/0xdb0
        ? printk+0xa8/0xd8
        ? arch_suspend_enable_irqs+0x20/0x20
        ? try_to_freeze_tasks+0x295/0x600
        pm_suspend+0x6c9/0x780
        ? finish_wait+0x1f0/0x1f0
        ? suspend_devices_and_enter+0xdb0/0xdb0
        state_store+0xa2/0x120
        ? kobj_attr_show+0x60/0x60
        kobj_attr_store+0x36/0x70
        sysfs_kf_write+0x131/0x200
        kernfs_fop_write+0x295/0x3f0
        __vfs_write+0xef/0x760
        ? handle_mm_fault+0x1346/0x35e0
        ? do_iter_readv_writev+0x660/0x660
        ? __pmd_alloc+0x310/0x310
        ? do_lock_file_wait+0x1e0/0x1e0
        ? apparmor_file_permission+0x18/0x20
        ? security_file_permission+0x73/0x1c0
        ? rw_verify_area+0xbd/0x2b0
        vfs_write+0x149/0x4a0
        SyS_write+0xd9/0x1c0
        ? SyS_read+0x1c0/0x1c0
        entry_SYSCALL_64_fastpath+0x1e/0xad
      Memory state around the buggy address:
       ffff8803867d7700: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
       ffff8803867d7780: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
      >ffff8803867d7800: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 f4
                                                                      ^
       ffff8803867d7880: f3 f3 f3 f3 00 00 00 00 00 00 00 00 00 00 00 00
       ffff8803867d7900: 00 00 00 f1 f1 f1 f1 04 f4 f4 f4 f3 f3 f3 f3 00
    
    KASAN instrumentation poisons the stack when entering a function and
    unpoisons it when exiting the function.  However, in the suspend path,
    some functions never return, so their stack never gets unpoisoned,
    resulting in stale KASAN shadow data which can cause later false
    positive warnings like the one above.
    
    Reported-by: Scott Bauer <scott.bauer@intel.com>
    Signed-off-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Acked-by: Andrey Ryabinin <aryabinin@virtuozzo.com>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Andrey Konovalov <andreyknvl@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 41a91c606e7d2b74358a944525267cc451c271e8
Author: Marek Szyprowski <m.szyprowski@samsung.com>
Date:   Wed Mar 27 10:56:08 2019 +0100

    usb: dwc3: move synchronize_irq() out of the spinlock protected block
    
    dwc3_gadget_suspend() is called under dwc->lock spinlock. In such context
    calling synchronize_irq() is not allowed. Move the problematic call out
    of the protected block to fix the following kernel BUG during system
    suspend:
    
    BUG: sleeping function called from invalid context at kernel/irq/manage.c:112
    in_atomic(): 1, irqs_disabled(): 128, pid: 1601, name: rtcwake
    6 locks held by rtcwake/1601:
     #0: f70ac2a2 (sb_writers#7){.+.+}, at: vfs_write+0x130/0x16c
     #1: b5fe1270 (&of->mutex){+.+.}, at: kernfs_fop_write+0xc0/0x1e4
     #2: 7e597705 (kn->count#60){.+.+}, at: kernfs_fop_write+0xc8/0x1e4
     #3: 8b3527d0 (system_transition_mutex){+.+.}, at: pm_suspend+0xc4/0xc04
     #4: fc7f1c42 (&dev->mutex){....}, at: __device_suspend+0xd8/0x74c
     #5: 4b36507e (&(&dwc->lock)->rlock){....}, at: dwc3_gadget_suspend+0x24/0x3c
    irq event stamp: 11252
    hardirqs last  enabled at (11251): [<c09c54a4>] _raw_spin_unlock_irqrestore+0x6c/0x74
    hardirqs last disabled at (11252): [<c09c4d44>] _raw_spin_lock_irqsave+0x1c/0x5c
    softirqs last  enabled at (9744): [<c0102564>] __do_softirq+0x3a4/0x66c
    softirqs last disabled at (9737): [<c0128528>] irq_exit+0x140/0x168
    Preemption disabled at:
    [<00000000>]   (null)
    CPU: 7 PID: 1601 Comm: rtcwake Not tainted
    5.0.0-rc3-next-20190122-00039-ga3f4ee4f8a52 #5252
    Hardware name: SAMSUNG EXYNOS (Flattened Device Tree)
    [<c01110f0>] (unwind_backtrace) from [<c010d120>] (show_stack+0x10/0x14)
    [<c010d120>] (show_stack) from [<c09a4d04>] (dump_stack+0x90/0xc8)
    [<c09a4d04>] (dump_stack) from [<c014c700>] (___might_sleep+0x22c/0x2c8)
    [<c014c700>] (___might_sleep) from [<c0189d68>] (synchronize_irq+0x28/0x84)
    [<c0189d68>] (synchronize_irq) from [<c05cbbf8>] (dwc3_gadget_suspend+0x34/0x3c)
    [<c05cbbf8>] (dwc3_gadget_suspend) from [<c05bd020>] (dwc3_suspend_common+0x154/0x410)
    [<c05bd020>] (dwc3_suspend_common) from [<c05bd34c>] (dwc3_suspend+0x14/0x2c)
    [<c05bd34c>] (dwc3_suspend) from [<c051c730>] (platform_pm_suspend+0x2c/0x54)
    [<c051c730>] (platform_pm_suspend) from [<c05285d4>] (dpm_run_callback+0xa4/0x3dc)
    [<c05285d4>] (dpm_run_callback) from [<c0528a40>] (__device_suspend+0x134/0x74c)
    [<c0528a40>] (__device_suspend) from [<c052c508>] (dpm_suspend+0x174/0x588)
    [<c052c508>] (dpm_suspend) from [<c0182134>] (suspend_devices_and_enter+0xc0/0xe74)
    [<c0182134>] (suspend_devices_and_enter) from [<c0183658>] (pm_suspend+0x770/0xc04)
    [<c0183658>] (pm_suspend) from [<c0180ddc>] (state_store+0x6c/0xcc)
    [<c0180ddc>] (state_store) from [<c09a9a70>] (kobj_attr_store+0x14/0x20)
    [<c09a9a70>] (kobj_attr_store) from [<c02d6800>] (sysfs_kf_write+0x4c/0x50)
    [<c02d6800>] (sysfs_kf_write) from [<c02d594c>] (kernfs_fop_write+0xfc/0x1e4)
    [<c02d594c>] (kernfs_fop_write) from [<c02593d8>] (__vfs_write+0x2c/0x160)
    [<c02593d8>] (__vfs_write) from [<c0259694>] (vfs_write+0xa4/0x16c)
    [<c0259694>] (vfs_write) from [<c0259870>] (ksys_write+0x40/0x8c)
    [<c0259870>] (ksys_write) from [<c0101000>] (ret_fast_syscall+0x0/0x28)
    Exception stack(0xed55ffa8 to 0xed55fff0)
    ...
    
    Fixes: 01c10880d242 ("usb: dwc3: gadget: synchronize_irq dwc irq in suspend")
    Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

commit 1e3975db46daaf51e1fd35ae8b69b304895eeddd
Author: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
Date:   Fri Sep 28 15:32:46 2018 +0200

    ARM: samsung: Limit SAMSUNG_PM_CHECK config option to non-Exynos platforms
    
    [ Upstream commit 6862fdf2201ab67cd962dbf0643d37db909f4860 ]
    
    "S3C2410 PM Suspend Memory CRC" feature (controlled by
    SAMSUNG_PM_CHECK config option) is incompatible with highmem
    (uses phys_to_virt() instead of proper mapping) which is used by
    the majority of Exynos boards. The issue manifests itself in OOPS
    on affected boards, i.e. on Odroid-U3 I got the following one:
    
    Unable to handle kernel paging request at virtual address f0000000
    pgd = 1c0f9bb4
    [f0000000] *pgd=00000000
    Internal error: Oops: 5 [#1] PREEMPT SMP ARM
    [<c0458034>] (crc32_le) from [<c0121f8c>] (s3c_pm_makecheck+0x34/0x54)
    [<c0121f8c>] (s3c_pm_makecheck) from [<c0121efc>] (s3c_pm_run_res+0x74/0x8c)
    [<c0121efc>] (s3c_pm_run_res) from [<c0121ecc>] (s3c_pm_run_res+0x44/0x8c)
    [<c0121ecc>] (s3c_pm_run_res) from [<c01210b8>] (exynos_suspend_enter+0x64/0x148)
    [<c01210b8>] (exynos_suspend_enter) from [<c018893c>] (suspend_devices_and_enter+0x9ec/0xe74)
    [<c018893c>] (suspend_devices_and_enter) from [<c0189534>] (pm_suspend+0x770/0xc04)
    [<c0189534>] (pm_suspend) from [<c0186ce8>] (state_store+0x6c/0xcc)
    [<c0186ce8>] (state_store) from [<c09db434>] (kobj_attr_store+0x14/0x20)
    [<c09db434>] (kobj_attr_store) from [<c02fa63c>] (sysfs_kf_write+0x4c/0x50)
    [<c02fa63c>] (sysfs_kf_write) from [<c02f97a4>] (kernfs_fop_write+0xfc/0x1e4)
    [<c02f97a4>] (kernfs_fop_write) from [<c027b198>] (__vfs_write+0x2c/0x140)
    [<c027b198>] (__vfs_write) from [<c027b418>] (vfs_write+0xa4/0x160)
    [<c027b418>] (vfs_write) from [<c027b5d8>] (ksys_write+0x40/0x8c)
    [<c027b5d8>] (ksys_write) from [<c0101000>] (ret_fast_syscall+0x0/0x28)
    
    Add PLAT_S3C24XX, ARCH_S3C64XX and ARCH_S5PV210 dependencies to
    SAMSUNG_PM_CHECK config option to hide it on Exynos platforms.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Signed-off-by: Krzysztof Kozlowski <krzk@kernel.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 6a701889a8f9138018e34b45feacc53a37a6ab58
Author: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
Date:   Fri Sep 28 15:32:46 2018 +0200

    ARM: samsung: Limit SAMSUNG_PM_CHECK config option to non-Exynos platforms
    
    [ Upstream commit 6862fdf2201ab67cd962dbf0643d37db909f4860 ]
    
    "S3C2410 PM Suspend Memory CRC" feature (controlled by
    SAMSUNG_PM_CHECK config option) is incompatible with highmem
    (uses phys_to_virt() instead of proper mapping) which is used by
    the majority of Exynos boards. The issue manifests itself in OOPS
    on affected boards, i.e. on Odroid-U3 I got the following one:
    
    Unable to handle kernel paging request at virtual address f0000000
    pgd = 1c0f9bb4
    [f0000000] *pgd=00000000
    Internal error: Oops: 5 [#1] PREEMPT SMP ARM
    [<c0458034>] (crc32_le) from [<c0121f8c>] (s3c_pm_makecheck+0x34/0x54)
    [<c0121f8c>] (s3c_pm_makecheck) from [<c0121efc>] (s3c_pm_run_res+0x74/0x8c)
    [<c0121efc>] (s3c_pm_run_res) from [<c0121ecc>] (s3c_pm_run_res+0x44/0x8c)
    [<c0121ecc>] (s3c_pm_run_res) from [<c01210b8>] (exynos_suspend_enter+0x64/0x148)
    [<c01210b8>] (exynos_suspend_enter) from [<c018893c>] (suspend_devices_and_enter+0x9ec/0xe74)
    [<c018893c>] (suspend_devices_and_enter) from [<c0189534>] (pm_suspend+0x770/0xc04)
    [<c0189534>] (pm_suspend) from [<c0186ce8>] (state_store+0x6c/0xcc)
    [<c0186ce8>] (state_store) from [<c09db434>] (kobj_attr_store+0x14/0x20)
    [<c09db434>] (kobj_attr_store) from [<c02fa63c>] (sysfs_kf_write+0x4c/0x50)
    [<c02fa63c>] (sysfs_kf_write) from [<c02f97a4>] (kernfs_fop_write+0xfc/0x1e4)
    [<c02f97a4>] (kernfs_fop_write) from [<c027b198>] (__vfs_write+0x2c/0x140)
    [<c027b198>] (__vfs_write) from [<c027b418>] (vfs_write+0xa4/0x160)
    [<c027b418>] (vfs_write) from [<c027b5d8>] (ksys_write+0x40/0x8c)
    [<c027b5d8>] (ksys_write) from [<c0101000>] (ret_fast_syscall+0x0/0x28)
    
    Add PLAT_S3C24XX, ARCH_S3C64XX and ARCH_S5PV210 dependencies to
    SAMSUNG_PM_CHECK config option to hide it on Exynos platforms.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Signed-off-by: Krzysztof Kozlowski <krzk@kernel.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit a33383757975c454f5f8ffaf984939b5650b42fd
Author: Kevin Wang <kevin1.wang@amd.com>
Date:   Fri Feb 22 12:36:49 2019 +0800

    drm/amdkfd: use init_mqd function to allocate object for hid_mqd (CI)
    
    [ Upstream commit cac734c2dbd2514f14c8c6a17caba1990d83bf1d ]
    
    if use the legacy method to allocate object, when mqd_hiq need to run
    uninit code, it will be cause WARNING call trace.
    
    eg: (s3 suspend test)
    [   34.918944] Call Trace:
    [   34.918948]  [<ffffffff92961dc1>] dump_stack+0x19/0x1b
    [   34.918950]  [<ffffffff92297648>] __warn+0xd8/0x100
    [   34.918951]  [<ffffffff9229778d>] warn_slowpath_null+0x1d/0x20
    [   34.918991]  [<ffffffffc03ce1fe>] uninit_mqd_hiq_sdma+0x4e/0x50 [amdgpu]
    [   34.919028]  [<ffffffffc03d0ef7>] uninitialize+0x37/0xe0 [amdgpu]
    [   34.919064]  [<ffffffffc03d15a6>] kernel_queue_uninit+0x16/0x30 [amdgpu]
    [   34.919086]  [<ffffffffc03d26c2>] pm_uninit+0x12/0x20 [amdgpu]
    [   34.919107]  [<ffffffffc03d4915>] stop_nocpsch+0x15/0x20 [amdgpu]
    [   34.919129]  [<ffffffffc03c1dce>] kgd2kfd_suspend.part.4+0x2e/0x50 [amdgpu]
    [   34.919150]  [<ffffffffc03c2667>] kgd2kfd_suspend+0x17/0x20 [amdgpu]
    [   34.919171]  [<ffffffffc03c103a>] amdgpu_amdkfd_suspend+0x1a/0x20 [amdgpu]
    [   34.919187]  [<ffffffffc02ec428>] amdgpu_device_suspend+0x88/0x3a0 [amdgpu]
    [   34.919189]  [<ffffffff922e22cf>] ? enqueue_entity+0x2ef/0xbe0
    [   34.919205]  [<ffffffffc02e8220>] amdgpu_pmops_suspend+0x20/0x30 [amdgpu]
    [   34.919207]  [<ffffffff925c56ff>] pci_pm_suspend+0x6f/0x150
    [   34.919208]  [<ffffffff925c5690>] ? pci_pm_freeze+0xf0/0xf0
    [   34.919210]  [<ffffffff926b45c6>] dpm_run_callback+0x46/0x90
    [   34.919212]  [<ffffffff926b49db>] __device_suspend+0xfb/0x2a0
    [   34.919213]  [<ffffffff926b4b9f>] async_suspend+0x1f/0xa0
    [   34.919214]  [<ffffffff922c918f>] async_run_entry_fn+0x3f/0x130
    [   34.919216]  [<ffffffff922b9d4f>] process_one_work+0x17f/0x440
    [   34.919217]  [<ffffffff922bade6>] worker_thread+0x126/0x3c0
    [   34.919218]  [<ffffffff922bacc0>] ? manage_workers.isra.25+0x2a0/0x2a0
    [   34.919220]  [<ffffffff922c1c31>] kthread+0xd1/0xe0
    [   34.919221]  [<ffffffff922c1b60>] ? insert_kthread_work+0x40/0x40
    [   34.919222]  [<ffffffff92974c1d>] ret_from_fork_nospec_begin+0x7/0x21
    [   34.919224]  [<ffffffff922c1b60>] ? insert_kthread_work+0x40/0x40
    [   34.919224] ---[ end trace 38cd9f65c963adad ]---
    
    Signed-off-by: Kevin Wang <kevin1.wang@amd.com>
    Reviewed-by: Oak Zeng <Oak.Zeng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 539282e9cd9bac049c08c62279277188e141ad24
Author: Kevin Wang <kevin1.wang@amd.com>
Date:   Fri Feb 22 12:36:49 2019 +0800

    drm/amdkfd: use init_mqd function to allocate object for hid_mqd (CI)
    
    [ Upstream commit cac734c2dbd2514f14c8c6a17caba1990d83bf1d ]
    
    if use the legacy method to allocate object, when mqd_hiq need to run
    uninit code, it will be cause WARNING call trace.
    
    eg: (s3 suspend test)
    [   34.918944] Call Trace:
    [   34.918948]  [<ffffffff92961dc1>] dump_stack+0x19/0x1b
    [   34.918950]  [<ffffffff92297648>] __warn+0xd8/0x100
    [   34.918951]  [<ffffffff9229778d>] warn_slowpath_null+0x1d/0x20
    [   34.918991]  [<ffffffffc03ce1fe>] uninit_mqd_hiq_sdma+0x4e/0x50 [amdgpu]
    [   34.919028]  [<ffffffffc03d0ef7>] uninitialize+0x37/0xe0 [amdgpu]
    [   34.919064]  [<ffffffffc03d15a6>] kernel_queue_uninit+0x16/0x30 [amdgpu]
    [   34.919086]  [<ffffffffc03d26c2>] pm_uninit+0x12/0x20 [amdgpu]
    [   34.919107]  [<ffffffffc03d4915>] stop_nocpsch+0x15/0x20 [amdgpu]
    [   34.919129]  [<ffffffffc03c1dce>] kgd2kfd_suspend.part.4+0x2e/0x50 [amdgpu]
    [   34.919150]  [<ffffffffc03c2667>] kgd2kfd_suspend+0x17/0x20 [amdgpu]
    [   34.919171]  [<ffffffffc03c103a>] amdgpu_amdkfd_suspend+0x1a/0x20 [amdgpu]
    [   34.919187]  [<ffffffffc02ec428>] amdgpu_device_suspend+0x88/0x3a0 [amdgpu]
    [   34.919189]  [<ffffffff922e22cf>] ? enqueue_entity+0x2ef/0xbe0
    [   34.919205]  [<ffffffffc02e8220>] amdgpu_pmops_suspend+0x20/0x30 [amdgpu]
    [   34.919207]  [<ffffffff925c56ff>] pci_pm_suspend+0x6f/0x150
    [   34.919208]  [<ffffffff925c5690>] ? pci_pm_freeze+0xf0/0xf0
    [   34.919210]  [<ffffffff926b45c6>] dpm_run_callback+0x46/0x90
    [   34.919212]  [<ffffffff926b49db>] __device_suspend+0xfb/0x2a0
    [   34.919213]  [<ffffffff926b4b9f>] async_suspend+0x1f/0xa0
    [   34.919214]  [<ffffffff922c918f>] async_run_entry_fn+0x3f/0x130
    [   34.919216]  [<ffffffff922b9d4f>] process_one_work+0x17f/0x440
    [   34.919217]  [<ffffffff922bade6>] worker_thread+0x126/0x3c0
    [   34.919218]  [<ffffffff922bacc0>] ? manage_workers.isra.25+0x2a0/0x2a0
    [   34.919220]  [<ffffffff922c1c31>] kthread+0xd1/0xe0
    [   34.919221]  [<ffffffff922c1b60>] ? insert_kthread_work+0x40/0x40
    [   34.919222]  [<ffffffff92974c1d>] ret_from_fork_nospec_begin+0x7/0x21
    [   34.919224]  [<ffffffff922c1b60>] ? insert_kthread_work+0x40/0x40
    [   34.919224] ---[ end trace 38cd9f65c963adad ]---
    
    Signed-off-by: Kevin Wang <kevin1.wang@amd.com>
    Reviewed-by: Oak Zeng <Oak.Zeng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 491dee743d6bc62b5629b985bf768994276afb7c
Author: Vitaly Kuznetsov <vkuznets@redhat.com>
Date:   Wed Oct 17 13:23:55 2018 +0200

    kernel: hung_task.c: disable on suspend
    
    [ Upstream commit a1c6ca3c6de763459a6e93b644ec6518c890ba1c ]
    
    It is possible to observe hung_task complaints when system goes to
    suspend-to-idle state:
    
     # echo freeze > /sys/power/state
    
     PM: Syncing filesystems ... done.
     Freezing user space processes ... (elapsed 0.001 seconds) done.
     OOM killer disabled.
     Freezing remaining freezable tasks ... (elapsed 0.002 seconds) done.
     sd 0:0:0:0: [sda] Synchronizing SCSI cache
     INFO: task bash:1569 blocked for more than 120 seconds.
           Not tainted 4.19.0-rc3_+ #687
     "echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
     bash            D    0  1569    604 0x00000000
     Call Trace:
      ? __schedule+0x1fe/0x7e0
      schedule+0x28/0x80
      suspend_devices_and_enter+0x4ac/0x750
      pm_suspend+0x2c0/0x310
    
    Register a PM notifier to disable the detector on suspend and re-enable
    back on wakeup.
    
    Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 360186d8ab0263831a3193a6a7018668404889d3
Author: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
Date:   Fri Sep 28 15:32:46 2018 +0200

    ARM: samsung: Limit SAMSUNG_PM_CHECK config option to non-Exynos platforms
    
    [ Upstream commit 6862fdf2201ab67cd962dbf0643d37db909f4860 ]
    
    "S3C2410 PM Suspend Memory CRC" feature (controlled by
    SAMSUNG_PM_CHECK config option) is incompatible with highmem
    (uses phys_to_virt() instead of proper mapping) which is used by
    the majority of Exynos boards. The issue manifests itself in OOPS
    on affected boards, i.e. on Odroid-U3 I got the following one:
    
    Unable to handle kernel paging request at virtual address f0000000
    pgd = 1c0f9bb4
    [f0000000] *pgd=00000000
    Internal error: Oops: 5 [#1] PREEMPT SMP ARM
    [<c0458034>] (crc32_le) from [<c0121f8c>] (s3c_pm_makecheck+0x34/0x54)
    [<c0121f8c>] (s3c_pm_makecheck) from [<c0121efc>] (s3c_pm_run_res+0x74/0x8c)
    [<c0121efc>] (s3c_pm_run_res) from [<c0121ecc>] (s3c_pm_run_res+0x44/0x8c)
    [<c0121ecc>] (s3c_pm_run_res) from [<c01210b8>] (exynos_suspend_enter+0x64/0x148)
    [<c01210b8>] (exynos_suspend_enter) from [<c018893c>] (suspend_devices_and_enter+0x9ec/0xe74)
    [<c018893c>] (suspend_devices_and_enter) from [<c0189534>] (pm_suspend+0x770/0xc04)
    [<c0189534>] (pm_suspend) from [<c0186ce8>] (state_store+0x6c/0xcc)
    [<c0186ce8>] (state_store) from [<c09db434>] (kobj_attr_store+0x14/0x20)
    [<c09db434>] (kobj_attr_store) from [<c02fa63c>] (sysfs_kf_write+0x4c/0x50)
    [<c02fa63c>] (sysfs_kf_write) from [<c02f97a4>] (kernfs_fop_write+0xfc/0x1e4)
    [<c02f97a4>] (kernfs_fop_write) from [<c027b198>] (__vfs_write+0x2c/0x140)
    [<c027b198>] (__vfs_write) from [<c027b418>] (vfs_write+0xa4/0x160)
    [<c027b418>] (vfs_write) from [<c027b5d8>] (ksys_write+0x40/0x8c)
    [<c027b5d8>] (ksys_write) from [<c0101000>] (ret_fast_syscall+0x0/0x28)
    
    Add PLAT_S3C24XX, ARCH_S3C64XX and ARCH_S5PV210 dependencies to
    SAMSUNG_PM_CHECK config option to hide it on Exynos platforms.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Signed-off-by: Krzysztof Kozlowski <krzk@kernel.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 86c7f76a8930556ec515095363ddaa0604486cdd
Author: Kevin Wang <kevin1.wang@amd.com>
Date:   Fri Feb 22 12:36:49 2019 +0800

    drm/amdkfd: use init_mqd function to allocate object for hid_mqd (CI)
    
    [ Upstream commit cac734c2dbd2514f14c8c6a17caba1990d83bf1d ]
    
    if use the legacy method to allocate object, when mqd_hiq need to run
    uninit code, it will be cause WARNING call trace.
    
    eg: (s3 suspend test)
    [   34.918944] Call Trace:
    [   34.918948]  [<ffffffff92961dc1>] dump_stack+0x19/0x1b
    [   34.918950]  [<ffffffff92297648>] __warn+0xd8/0x100
    [   34.918951]  [<ffffffff9229778d>] warn_slowpath_null+0x1d/0x20
    [   34.918991]  [<ffffffffc03ce1fe>] uninit_mqd_hiq_sdma+0x4e/0x50 [amdgpu]
    [   34.919028]  [<ffffffffc03d0ef7>] uninitialize+0x37/0xe0 [amdgpu]
    [   34.919064]  [<ffffffffc03d15a6>] kernel_queue_uninit+0x16/0x30 [amdgpu]
    [   34.919086]  [<ffffffffc03d26c2>] pm_uninit+0x12/0x20 [amdgpu]
    [   34.919107]  [<ffffffffc03d4915>] stop_nocpsch+0x15/0x20 [amdgpu]
    [   34.919129]  [<ffffffffc03c1dce>] kgd2kfd_suspend.part.4+0x2e/0x50 [amdgpu]
    [   34.919150]  [<ffffffffc03c2667>] kgd2kfd_suspend+0x17/0x20 [amdgpu]
    [   34.919171]  [<ffffffffc03c103a>] amdgpu_amdkfd_suspend+0x1a/0x20 [amdgpu]
    [   34.919187]  [<ffffffffc02ec428>] amdgpu_device_suspend+0x88/0x3a0 [amdgpu]
    [   34.919189]  [<ffffffff922e22cf>] ? enqueue_entity+0x2ef/0xbe0
    [   34.919205]  [<ffffffffc02e8220>] amdgpu_pmops_suspend+0x20/0x30 [amdgpu]
    [   34.919207]  [<ffffffff925c56ff>] pci_pm_suspend+0x6f/0x150
    [   34.919208]  [<ffffffff925c5690>] ? pci_pm_freeze+0xf0/0xf0
    [   34.919210]  [<ffffffff926b45c6>] dpm_run_callback+0x46/0x90
    [   34.919212]  [<ffffffff926b49db>] __device_suspend+0xfb/0x2a0
    [   34.919213]  [<ffffffff926b4b9f>] async_suspend+0x1f/0xa0
    [   34.919214]  [<ffffffff922c918f>] async_run_entry_fn+0x3f/0x130
    [   34.919216]  [<ffffffff922b9d4f>] process_one_work+0x17f/0x440
    [   34.919217]  [<ffffffff922bade6>] worker_thread+0x126/0x3c0
    [   34.919218]  [<ffffffff922bacc0>] ? manage_workers.isra.25+0x2a0/0x2a0
    [   34.919220]  [<ffffffff922c1c31>] kthread+0xd1/0xe0
    [   34.919221]  [<ffffffff922c1b60>] ? insert_kthread_work+0x40/0x40
    [   34.919222]  [<ffffffff92974c1d>] ret_from_fork_nospec_begin+0x7/0x21
    [   34.919224]  [<ffffffff922c1b60>] ? insert_kthread_work+0x40/0x40
    [   34.919224] ---[ end trace 38cd9f65c963adad ]---
    
    Signed-off-by: Kevin Wang <kevin1.wang@amd.com>
    Reviewed-by: Oak Zeng <Oak.Zeng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 507f2f17e044b3efc6516ad0ae66fb244752c569
Author: Vitaly Kuznetsov <vkuznets@redhat.com>
Date:   Wed Oct 17 13:23:55 2018 +0200

    kernel: hung_task.c: disable on suspend
    
    [ Upstream commit a1c6ca3c6de763459a6e93b644ec6518c890ba1c ]
    
    It is possible to observe hung_task complaints when system goes to
    suspend-to-idle state:
    
     # echo freeze > /sys/power/state
    
     PM: Syncing filesystems ... done.
     Freezing user space processes ... (elapsed 0.001 seconds) done.
     OOM killer disabled.
     Freezing remaining freezable tasks ... (elapsed 0.002 seconds) done.
     sd 0:0:0:0: [sda] Synchronizing SCSI cache
     INFO: task bash:1569 blocked for more than 120 seconds.
           Not tainted 4.19.0-rc3_+ #687
     "echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
     bash            D    0  1569    604 0x00000000
     Call Trace:
      ? __schedule+0x1fe/0x7e0
      schedule+0x28/0x80
      suspend_devices_and_enter+0x4ac/0x750
      pm_suspend+0x2c0/0x310
    
    Register a PM notifier to disable the detector on suspend and re-enable
    back on wakeup.
    
    Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit ef9f432612e56651d2aa2984763ff1ba69621e82
Author: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
Date:   Fri Sep 28 15:32:46 2018 +0200

    ARM: samsung: Limit SAMSUNG_PM_CHECK config option to non-Exynos platforms
    
    [ Upstream commit 6862fdf2201ab67cd962dbf0643d37db909f4860 ]
    
    "S3C2410 PM Suspend Memory CRC" feature (controlled by
    SAMSUNG_PM_CHECK config option) is incompatible with highmem
    (uses phys_to_virt() instead of proper mapping) which is used by
    the majority of Exynos boards. The issue manifests itself in OOPS
    on affected boards, i.e. on Odroid-U3 I got the following one:
    
    Unable to handle kernel paging request at virtual address f0000000
    pgd = 1c0f9bb4
    [f0000000] *pgd=00000000
    Internal error: Oops: 5 [#1] PREEMPT SMP ARM
    [<c0458034>] (crc32_le) from [<c0121f8c>] (s3c_pm_makecheck+0x34/0x54)
    [<c0121f8c>] (s3c_pm_makecheck) from [<c0121efc>] (s3c_pm_run_res+0x74/0x8c)
    [<c0121efc>] (s3c_pm_run_res) from [<c0121ecc>] (s3c_pm_run_res+0x44/0x8c)
    [<c0121ecc>] (s3c_pm_run_res) from [<c01210b8>] (exynos_suspend_enter+0x64/0x148)
    [<c01210b8>] (exynos_suspend_enter) from [<c018893c>] (suspend_devices_and_enter+0x9ec/0xe74)
    [<c018893c>] (suspend_devices_and_enter) from [<c0189534>] (pm_suspend+0x770/0xc04)
    [<c0189534>] (pm_suspend) from [<c0186ce8>] (state_store+0x6c/0xcc)
    [<c0186ce8>] (state_store) from [<c09db434>] (kobj_attr_store+0x14/0x20)
    [<c09db434>] (kobj_attr_store) from [<c02fa63c>] (sysfs_kf_write+0x4c/0x50)
    [<c02fa63c>] (sysfs_kf_write) from [<c02f97a4>] (kernfs_fop_write+0xfc/0x1e4)
    [<c02f97a4>] (kernfs_fop_write) from [<c027b198>] (__vfs_write+0x2c/0x140)
    [<c027b198>] (__vfs_write) from [<c027b418>] (vfs_write+0xa4/0x160)
    [<c027b418>] (vfs_write) from [<c027b5d8>] (ksys_write+0x40/0x8c)
    [<c027b5d8>] (ksys_write) from [<c0101000>] (ret_fast_syscall+0x0/0x28)
    
    Add PLAT_S3C24XX, ARCH_S3C64XX and ARCH_S5PV210 dependencies to
    SAMSUNG_PM_CHECK config option to hide it on Exynos platforms.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Signed-off-by: Krzysztof Kozlowski <krzk@kernel.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit e538759bd9099d15f0e99070c6193d571e7420d2
Author: Vitaly Kuznetsov <vkuznets@redhat.com>
Date:   Wed Oct 17 13:23:55 2018 +0200

    kernel: hung_task.c: disable on suspend
    
    [ Upstream commit a1c6ca3c6de763459a6e93b644ec6518c890ba1c ]
    
    It is possible to observe hung_task complaints when system goes to
    suspend-to-idle state:
    
     # echo freeze > /sys/power/state
    
     PM: Syncing filesystems ... done.
     Freezing user space processes ... (elapsed 0.001 seconds) done.
     OOM killer disabled.
     Freezing remaining freezable tasks ... (elapsed 0.002 seconds) done.
     sd 0:0:0:0: [sda] Synchronizing SCSI cache
     INFO: task bash:1569 blocked for more than 120 seconds.
           Not tainted 4.19.0-rc3_+ #687
     "echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
     bash            D    0  1569    604 0x00000000
     Call Trace:
      ? __schedule+0x1fe/0x7e0
      schedule+0x28/0x80
      suspend_devices_and_enter+0x4ac/0x750
      pm_suspend+0x2c0/0x310
    
    Register a PM notifier to disable the detector on suspend and re-enable
    back on wakeup.
    
    Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 5a57645460fea411a7c97fcf121658d16253b1d9
Author: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
Date:   Fri Sep 28 15:32:46 2018 +0200

    ARM: samsung: Limit SAMSUNG_PM_CHECK config option to non-Exynos platforms
    
    [ Upstream commit 6862fdf2201ab67cd962dbf0643d37db909f4860 ]
    
    "S3C2410 PM Suspend Memory CRC" feature (controlled by
    SAMSUNG_PM_CHECK config option) is incompatible with highmem
    (uses phys_to_virt() instead of proper mapping) which is used by
    the majority of Exynos boards. The issue manifests itself in OOPS
    on affected boards, i.e. on Odroid-U3 I got the following one:
    
    Unable to handle kernel paging request at virtual address f0000000
    pgd = 1c0f9bb4
    [f0000000] *pgd=00000000
    Internal error: Oops: 5 [#1] PREEMPT SMP ARM
    [<c0458034>] (crc32_le) from [<c0121f8c>] (s3c_pm_makecheck+0x34/0x54)
    [<c0121f8c>] (s3c_pm_makecheck) from [<c0121efc>] (s3c_pm_run_res+0x74/0x8c)
    [<c0121efc>] (s3c_pm_run_res) from [<c0121ecc>] (s3c_pm_run_res+0x44/0x8c)
    [<c0121ecc>] (s3c_pm_run_res) from [<c01210b8>] (exynos_suspend_enter+0x64/0x148)
    [<c01210b8>] (exynos_suspend_enter) from [<c018893c>] (suspend_devices_and_enter+0x9ec/0xe74)
    [<c018893c>] (suspend_devices_and_enter) from [<c0189534>] (pm_suspend+0x770/0xc04)
    [<c0189534>] (pm_suspend) from [<c0186ce8>] (state_store+0x6c/0xcc)
    [<c0186ce8>] (state_store) from [<c09db434>] (kobj_attr_store+0x14/0x20)
    [<c09db434>] (kobj_attr_store) from [<c02fa63c>] (sysfs_kf_write+0x4c/0x50)
    [<c02fa63c>] (sysfs_kf_write) from [<c02f97a4>] (kernfs_fop_write+0xfc/0x1e4)
    [<c02f97a4>] (kernfs_fop_write) from [<c027b198>] (__vfs_write+0x2c/0x140)
    [<c027b198>] (__vfs_write) from [<c027b418>] (vfs_write+0xa4/0x160)
    [<c027b418>] (vfs_write) from [<c027b5d8>] (ksys_write+0x40/0x8c)
    [<c027b5d8>] (ksys_write) from [<c0101000>] (ret_fast_syscall+0x0/0x28)
    
    Add PLAT_S3C24XX, ARCH_S3C64XX and ARCH_S5PV210 dependencies to
    SAMSUNG_PM_CHECK config option to hide it on Exynos platforms.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Signed-off-by: Krzysztof Kozlowski <krzk@kernel.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 7c394c70a3945d31817826454a7a40a80ef2c0a0
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Fri Mar 22 15:39:48 2019 -0700

    ASoC: intel: Fix crash at suspend/resume after failed codec registration
    
    commit 8f71370f4b02730e8c27faf460af7a3586e24e1f upstream.
    
    If codec registration fails after the ASoC Intel SST driver has been probed,
    the kernel will Oops and crash at suspend/resume.
    
    general protection fault: 0000 [#1] PREEMPT SMP KASAN PTI
    CPU: 1 PID: 2811 Comm: cat Tainted: G        W         4.19.30 #15
    Hardware name: GOOGLE Clapper, BIOS Google_Clapper.5216.199.7 08/22/2014
    RIP: 0010:snd_soc_suspend+0x5a/0xd21
    Code: 03 80 3c 10 00 49 89 d7 74 0b 48 89 df e8 71 72 c4 fe 4c 89
    fa 48 8b 03 48 89 45 d0 48 8d 98 a0 01 00 00 48 89 d8 48 c1 e8 03
    <8a> 04 10 84 c0 0f 85 85 0c 00 00 80 3b 00 0f 84 6b 0c 00 00 48 8b
    RSP: 0018:ffff888035407750 EFLAGS: 00010202
    RAX: 0000000000000034 RBX: 00000000000001a0 RCX: 0000000000000000
    RDX: dffffc0000000000 RSI: 0000000000000008 RDI: ffff88805c417098
    RBP: ffff8880354077b0 R08: dffffc0000000000 R09: ffffed100b975718
    R10: 0000000000000001 R11: ffffffff949ea4a3 R12: 1ffff1100b975746
    R13: dffffc0000000000 R14: ffff88805cba4588 R15: dffffc0000000000
    FS:  0000794a78e91b80(0000) GS:ffff888068d00000(0000) knlGS:0000000000000000
    CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    CR2: 00007bd5283ccf58 CR3: 000000004b7aa000 CR4: 00000000001006e0
    Call Trace:
    ? dpm_complete+0x67b/0x67b
    ? i915_gem_suspend+0x14d/0x1ad
    sst_soc_prepare+0x91/0x1dd
    ? sst_be_hw_params+0x7e/0x7e
    dpm_prepare+0x39a/0x88b
    dpm_suspend_start+0x13/0x9d
    suspend_devices_and_enter+0x18f/0xbd7
    ? arch_suspend_enable_irqs+0x11/0x11
    ? printk+0xd9/0x12d
    ? lock_release+0x95f/0x95f
    ? log_buf_vmcoreinfo_setup+0x131/0x131
    ? rcu_read_lock_sched_held+0x140/0x22a
    ? __bpf_trace_rcu_utilization+0xa/0xa
    ? __pm_pr_dbg+0x186/0x190
    ? pm_notifier_call_chain+0x39/0x39
    ? suspend_test+0x9d/0x9d
    pm_suspend+0x2f4/0x728
    ? trace_suspend_resume+0x3da/0x3da
    ? lock_release+0x95f/0x95f
    ? kernfs_fop_write+0x19f/0x32d
    state_store+0xd8/0x147
    ? sysfs_kf_read+0x155/0x155
    kernfs_fop_write+0x23e/0x32d
    __vfs_write+0x108/0x608
    ? vfs_read+0x2e9/0x2e9
    ? rcu_read_lock_sched_held+0x140/0x22a
    ? __bpf_trace_rcu_utilization+0xa/0xa
    ? debug_smp_processor_id+0x10/0x10
    ? selinux_file_permission+0x1c5/0x3c8
    ? rcu_sync_lockdep_assert+0x6a/0xad
    ? __sb_start_write+0x129/0x2ac
    vfs_write+0x1aa/0x434
    ksys_write+0xfe/0x1be
    ? __ia32_sys_read+0x82/0x82
    do_syscall_64+0xcd/0x120
    entry_SYSCALL_64_after_hwframe+0x49/0xbe
    
    In the observed situation, the problem is seen because the codec driver
    failed to probe due to a hardware problem.
    
    max98090 i2c-193C9890:00: Failed to read device revision: -1
    max98090 i2c-193C9890:00: ASoC: failed to probe component -1
    cht-bsw-max98090 cht-bsw-max98090: ASoC: failed to instantiate card -1
    cht-bsw-max98090 cht-bsw-max98090: snd_soc_register_card failed -1
    cht-bsw-max98090: probe of cht-bsw-max98090 failed with error -1
    
    The problem is similar to the problem solved with commit 2fc995a87f2e
    ("ASoC: intel: Fix crash at suspend/resume without card registration"),
    but codec registration fails at a later point. At that time, the pointer
    checked with the above mentioned commit is already set, but it is not
    cleared if the device is subsequently removed. Adding a remove function
    to clear the pointer fixes the problem.
    
    Cc: stable@vger.kernel.org
    Cc: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Cc: Curtis Malainey <cujomalainey@chromium.org>
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Acked-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 19b0a7f5a0835b86a0aff57fc51ba1fffbe704c1
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Fri Mar 22 15:39:48 2019 -0700

    ASoC: intel: Fix crash at suspend/resume after failed codec registration
    
    commit 8f71370f4b02730e8c27faf460af7a3586e24e1f upstream.
    
    If codec registration fails after the ASoC Intel SST driver has been probed,
    the kernel will Oops and crash at suspend/resume.
    
    general protection fault: 0000 [#1] PREEMPT SMP KASAN PTI
    CPU: 1 PID: 2811 Comm: cat Tainted: G        W         4.19.30 #15
    Hardware name: GOOGLE Clapper, BIOS Google_Clapper.5216.199.7 08/22/2014
    RIP: 0010:snd_soc_suspend+0x5a/0xd21
    Code: 03 80 3c 10 00 49 89 d7 74 0b 48 89 df e8 71 72 c4 fe 4c 89
    fa 48 8b 03 48 89 45 d0 48 8d 98 a0 01 00 00 48 89 d8 48 c1 e8 03
    <8a> 04 10 84 c0 0f 85 85 0c 00 00 80 3b 00 0f 84 6b 0c 00 00 48 8b
    RSP: 0018:ffff888035407750 EFLAGS: 00010202
    RAX: 0000000000000034 RBX: 00000000000001a0 RCX: 0000000000000000
    RDX: dffffc0000000000 RSI: 0000000000000008 RDI: ffff88805c417098
    RBP: ffff8880354077b0 R08: dffffc0000000000 R09: ffffed100b975718
    R10: 0000000000000001 R11: ffffffff949ea4a3 R12: 1ffff1100b975746
    R13: dffffc0000000000 R14: ffff88805cba4588 R15: dffffc0000000000
    FS:  0000794a78e91b80(0000) GS:ffff888068d00000(0000) knlGS:0000000000000000
    CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    CR2: 00007bd5283ccf58 CR3: 000000004b7aa000 CR4: 00000000001006e0
    Call Trace:
    ? dpm_complete+0x67b/0x67b
    ? i915_gem_suspend+0x14d/0x1ad
    sst_soc_prepare+0x91/0x1dd
    ? sst_be_hw_params+0x7e/0x7e
    dpm_prepare+0x39a/0x88b
    dpm_suspend_start+0x13/0x9d
    suspend_devices_and_enter+0x18f/0xbd7
    ? arch_suspend_enable_irqs+0x11/0x11
    ? printk+0xd9/0x12d
    ? lock_release+0x95f/0x95f
    ? log_buf_vmcoreinfo_setup+0x131/0x131
    ? rcu_read_lock_sched_held+0x140/0x22a
    ? __bpf_trace_rcu_utilization+0xa/0xa
    ? __pm_pr_dbg+0x186/0x190
    ? pm_notifier_call_chain+0x39/0x39
    ? suspend_test+0x9d/0x9d
    pm_suspend+0x2f4/0x728
    ? trace_suspend_resume+0x3da/0x3da
    ? lock_release+0x95f/0x95f
    ? kernfs_fop_write+0x19f/0x32d
    state_store+0xd8/0x147
    ? sysfs_kf_read+0x155/0x155
    kernfs_fop_write+0x23e/0x32d
    __vfs_write+0x108/0x608
    ? vfs_read+0x2e9/0x2e9
    ? rcu_read_lock_sched_held+0x140/0x22a
    ? __bpf_trace_rcu_utilization+0xa/0xa
    ? debug_smp_processor_id+0x10/0x10
    ? selinux_file_permission+0x1c5/0x3c8
    ? rcu_sync_lockdep_assert+0x6a/0xad
    ? __sb_start_write+0x129/0x2ac
    vfs_write+0x1aa/0x434
    ksys_write+0xfe/0x1be
    ? __ia32_sys_read+0x82/0x82
    do_syscall_64+0xcd/0x120
    entry_SYSCALL_64_after_hwframe+0x49/0xbe
    
    In the observed situation, the problem is seen because the codec driver
    failed to probe due to a hardware problem.
    
    max98090 i2c-193C9890:00: Failed to read device revision: -1
    max98090 i2c-193C9890:00: ASoC: failed to probe component -1
    cht-bsw-max98090 cht-bsw-max98090: ASoC: failed to instantiate card -1
    cht-bsw-max98090 cht-bsw-max98090: snd_soc_register_card failed -1
    cht-bsw-max98090: probe of cht-bsw-max98090 failed with error -1
    
    The problem is similar to the problem solved with commit 2fc995a87f2e
    ("ASoC: intel: Fix crash at suspend/resume without card registration"),
    but codec registration fails at a later point. At that time, the pointer
    checked with the above mentioned commit is already set, but it is not
    cleared if the device is subsequently removed. Adding a remove function
    to clear the pointer fixes the problem.
    
    Cc: stable@vger.kernel.org
    Cc: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Cc: Curtis Malainey <cujomalainey@chromium.org>
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Acked-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit eaedc0d379da6d1157a4f274d186001d11615b2b
Author: Claudiu Beznea <claudiu.beznea@microchip.com>
Date:   Thu Feb 14 15:54:57 2019 +0000

    ARM: at91: pm: add ULP1 support for SAM9X60
    
    Add ULP1 support for SAM9X60. In pm_suspend.S enable RC oscillator in
    PMC if it is not enabled. At resume the state before suspend is
    restored.
    
    Signed-off-by: Claudiu Beznea <claudiu.beznea@microchip.com>
    Acked-by: Stephen Boyd <sboyd@kernel.org>
    Signed-off-by: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Signed-off-by: Ludovic Desroches <ludovic.desroches@microchip.com>

commit 8f71370f4b02730e8c27faf460af7a3586e24e1f
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Fri Mar 22 15:39:48 2019 -0700

    ASoC: intel: Fix crash at suspend/resume after failed codec registration
    
    If codec registration fails after the ASoC Intel SST driver has been probed,
    the kernel will Oops and crash at suspend/resume.
    
    general protection fault: 0000 [#1] PREEMPT SMP KASAN PTI
    CPU: 1 PID: 2811 Comm: cat Tainted: G        W         4.19.30 #15
    Hardware name: GOOGLE Clapper, BIOS Google_Clapper.5216.199.7 08/22/2014
    RIP: 0010:snd_soc_suspend+0x5a/0xd21
    Code: 03 80 3c 10 00 49 89 d7 74 0b 48 89 df e8 71 72 c4 fe 4c 89
    fa 48 8b 03 48 89 45 d0 48 8d 98 a0 01 00 00 48 89 d8 48 c1 e8 03
    <8a> 04 10 84 c0 0f 85 85 0c 00 00 80 3b 00 0f 84 6b 0c 00 00 48 8b
    RSP: 0018:ffff888035407750 EFLAGS: 00010202
    RAX: 0000000000000034 RBX: 00000000000001a0 RCX: 0000000000000000
    RDX: dffffc0000000000 RSI: 0000000000000008 RDI: ffff88805c417098
    RBP: ffff8880354077b0 R08: dffffc0000000000 R09: ffffed100b975718
    R10: 0000000000000001 R11: ffffffff949ea4a3 R12: 1ffff1100b975746
    R13: dffffc0000000000 R14: ffff88805cba4588 R15: dffffc0000000000
    FS:  0000794a78e91b80(0000) GS:ffff888068d00000(0000) knlGS:0000000000000000
    CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    CR2: 00007bd5283ccf58 CR3: 000000004b7aa000 CR4: 00000000001006e0
    Call Trace:
    ? dpm_complete+0x67b/0x67b
    ? i915_gem_suspend+0x14d/0x1ad
    sst_soc_prepare+0x91/0x1dd
    ? sst_be_hw_params+0x7e/0x7e
    dpm_prepare+0x39a/0x88b
    dpm_suspend_start+0x13/0x9d
    suspend_devices_and_enter+0x18f/0xbd7
    ? arch_suspend_enable_irqs+0x11/0x11
    ? printk+0xd9/0x12d
    ? lock_release+0x95f/0x95f
    ? log_buf_vmcoreinfo_setup+0x131/0x131
    ? rcu_read_lock_sched_held+0x140/0x22a
    ? __bpf_trace_rcu_utilization+0xa/0xa
    ? __pm_pr_dbg+0x186/0x190
    ? pm_notifier_call_chain+0x39/0x39
    ? suspend_test+0x9d/0x9d
    pm_suspend+0x2f4/0x728
    ? trace_suspend_resume+0x3da/0x3da
    ? lock_release+0x95f/0x95f
    ? kernfs_fop_write+0x19f/0x32d
    state_store+0xd8/0x147
    ? sysfs_kf_read+0x155/0x155
    kernfs_fop_write+0x23e/0x32d
    __vfs_write+0x108/0x608
    ? vfs_read+0x2e9/0x2e9
    ? rcu_read_lock_sched_held+0x140/0x22a
    ? __bpf_trace_rcu_utilization+0xa/0xa
    ? debug_smp_processor_id+0x10/0x10
    ? selinux_file_permission+0x1c5/0x3c8
    ? rcu_sync_lockdep_assert+0x6a/0xad
    ? __sb_start_write+0x129/0x2ac
    vfs_write+0x1aa/0x434
    ksys_write+0xfe/0x1be
    ? __ia32_sys_read+0x82/0x82
    do_syscall_64+0xcd/0x120
    entry_SYSCALL_64_after_hwframe+0x49/0xbe
    
    In the observed situation, the problem is seen because the codec driver
    failed to probe due to a hardware problem.
    
    max98090 i2c-193C9890:00: Failed to read device revision: -1
    max98090 i2c-193C9890:00: ASoC: failed to probe component -1
    cht-bsw-max98090 cht-bsw-max98090: ASoC: failed to instantiate card -1
    cht-bsw-max98090 cht-bsw-max98090: snd_soc_register_card failed -1
    cht-bsw-max98090: probe of cht-bsw-max98090 failed with error -1
    
    The problem is similar to the problem solved with commit 2fc995a87f2e
    ("ASoC: intel: Fix crash at suspend/resume without card registration"),
    but codec registration fails at a later point. At that time, the pointer
    checked with the above mentioned commit is already set, but it is not
    cleared if the device is subsequently removed. Adding a remove function
    to clear the pointer fixes the problem.
    
    Cc: stable@vger.kernel.org
    Cc: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Cc: Curtis Malainey <cujomalainey@chromium.org>
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Acked-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

commit d9d7760c1e45ecb9c4c2e6a2d2668ad2bd10f10c
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon Feb 11 14:59:07 2019 -0800

    clk: clk-twl6040: Fix imprecise external abort for pdmclk
    
    commit 5ae51d67aec95f6f9386aa8dd5db424964895575 upstream.
    
    I noticed that modprobe clk-twl6040 can fail after a cold boot with:
    abe_cm:clk:0010:0: failed to enable
    ...
    Unhandled fault: imprecise external abort (0x1406) at 0xbe896b20
    
    WARNING: CPU: 1 PID: 29 at drivers/clk/clk.c:828 clk_core_disable_lock+0x18/0x24
    ...
    (clk_core_disable_lock) from [<c0123534>] (_disable_clocks+0x18/0x90)
    (_disable_clocks) from [<c0124040>] (_idle+0x17c/0x244)
    (_idle) from [<c0125ad4>] (omap_hwmod_idle+0x24/0x44)
    (omap_hwmod_idle) from [<c053a038>] (sysc_runtime_suspend+0x48/0x108)
    (sysc_runtime_suspend) from [<c06084c4>] (__rpm_callback+0x144/0x1d8)
    (__rpm_callback) from [<c0608578>] (rpm_callback+0x20/0x80)
    (rpm_callback) from [<c0607034>] (rpm_suspend+0x120/0x694)
    (rpm_suspend) from [<c0607a78>] (__pm_runtime_idle+0x60/0x84)
    (__pm_runtime_idle) from [<c053aaf0>] (sysc_probe+0x874/0xf2c)
    (sysc_probe) from [<c05fecd4>] (platform_drv_probe+0x48/0x98)
    
    After searching around for a similar issue, I came across an earlier fix
    that never got merged upstream in the Android tree for glass-omap-xrr02.
    There is patch "MFD: twl6040-codec: Implement PDMCLK cold temp errata"
    by Misael Lopez Cruz <misael.lopez@ti.com>.
    
    Based on my observations, this fix is also needed when cold booting
    devices, and not just for deeper idle modes. Since we now have a clock
    driver for pdmclk, let's fix the issue in twl6040_pdmclk_prepare().
    
    Cc: Misael Lopez Cruz <misael.lopez@ti.com>
    Cc: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Acked-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 028cbca07ab58f77a532b3587ac4ba9d85fd5f55
Author: Stephen Boyd <swboyd@chromium.org>
Date:   Tue Jan 15 14:54:47 2019 -0800

    soc: qcom: rpmh: Avoid accessing freed memory from batch API
    
    commit baef1c90aac7e5bf13f0360a3b334825a23d31a1 upstream.
    
    Using the batch API from the interconnect driver sometimes leads to a
    KASAN error due to an access to freed memory. This is easier to trigger
    with threadirqs on the kernel commandline.
    
     BUG: KASAN: use-after-free in rpmh_tx_done+0x114/0x12c
     Read of size 1 at addr fffffff51414ad84 by task irq/110-apps_rs/57
    
     CPU: 0 PID: 57 Comm: irq/110-apps_rs Tainted: G        W         4.19.10 #72
     Call trace:
      dump_backtrace+0x0/0x2f8
      show_stack+0x20/0x2c
      __dump_stack+0x20/0x28
      dump_stack+0xcc/0x10c
      print_address_description+0x74/0x240
      kasan_report+0x250/0x26c
      __asan_report_load1_noabort+0x20/0x2c
      rpmh_tx_done+0x114/0x12c
      tcs_tx_done+0x450/0x768
      irq_forced_thread_fn+0x58/0x9c
      irq_thread+0x120/0x1dc
      kthread+0x248/0x260
      ret_from_fork+0x10/0x18
    
     Allocated by task 385:
      kasan_kmalloc+0xac/0x148
      __kmalloc+0x170/0x1e4
      rpmh_write_batch+0x174/0x540
      qcom_icc_set+0x8dc/0x9ac
      icc_set+0x288/0x2e8
      a6xx_gmu_stop+0x320/0x3c0
      a6xx_pm_suspend+0x108/0x124
      adreno_suspend+0x50/0x60
      pm_generic_runtime_suspend+0x60/0x78
      __rpm_callback+0x214/0x32c
      rpm_callback+0x54/0x184
      rpm_suspend+0x3f8/0xa90
      pm_runtime_work+0xb4/0x178
      process_one_work+0x544/0xbc0
      worker_thread+0x514/0x7d0
      kthread+0x248/0x260
      ret_from_fork+0x10/0x18
    
     Freed by task 385:
      __kasan_slab_free+0x12c/0x1e0
      kasan_slab_free+0x10/0x1c
      kfree+0x134/0x588
      rpmh_write_batch+0x49c/0x540
      qcom_icc_set+0x8dc/0x9ac
      icc_set+0x288/0x2e8
      a6xx_gmu_stop+0x320/0x3c0
      a6xx_pm_suspend+0x108/0x124
      adreno_suspend+0x50/0x60
     cr50_spi spi5.0: SPI transfer timed out
      pm_generic_runtime_suspend+0x60/0x78
      __rpm_callback+0x214/0x32c
      rpm_callback+0x54/0x184
      rpm_suspend+0x3f8/0xa90
      pm_runtime_work+0xb4/0x178
      process_one_work+0x544/0xbc0
      worker_thread+0x514/0x7d0
      kthread+0x248/0x260
      ret_from_fork+0x10/0x18
    
     The buggy address belongs to the object at fffffff51414ac80
      which belongs to the cache kmalloc-512 of size 512
     The buggy address is located 260 bytes inside of
      512-byte region [fffffff51414ac80, fffffff51414ae80)
     The buggy address belongs to the page:
     page:ffffffbfd4505200 count:1 mapcount:0 mapping:fffffff51e00c680 index:0x0 compound_mapcount: 0
     flags: 0x4000000000008100(slab|head)
     raw: 4000000000008100 ffffffbfd4529008 ffffffbfd44f9208 fffffff51e00c680
     raw: 0000000000000000 0000000000200020 00000001ffffffff 0000000000000000
     page dumped because: kasan: bad access detected
    
     Memory state around the buggy address:
      fffffff51414ac80: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
      fffffff51414ad00: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
     >fffffff51414ad80: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
                        ^
      fffffff51414ae00: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
      fffffff51414ae80: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
    
    The batch API sets the same completion for each rpmh message that's sent
    and then loops through all the messages and waits for that single
    completion declared on the stack to be completed before returning from
    the function and freeing the message structures. Unfortunately, some
    messages may still be in process and 'stuck' in the TCS. At some later
    point, the tcs_tx_done() interrupt will run and try to process messages
    that have already been freed at the end of rpmh_write_batch(). This will
    in turn access the 'needs_free' member of the rpmh_request structure and
    cause KASAN to complain. Furthermore, if there's a message that's
    completed in rpmh_tx_done() and freed immediately after the complete()
    call is made we'll be racing with potentially freed memory when
    accessing the 'needs_free' member:
    
            CPU0                         CPU1
            ----                         ----
            rpmh_tx_done()
             complete(&compl)
                                         wait_for_completion(&compl)
                                         kfree(rpm_msg)
             if (rpm_msg->needs_free)
             <KASAN warning splat>
    
    Let's fix this by allocating a chunk of completions for each message and
    waiting for all of them to be completed before returning from the batch
    API. Alternatively, we could wait for the last message in the batch, but
    that may be a more complicated change because it looks like
    tcs_tx_done() just iterates through the indices of the queue and
    completes each message instead of tracking the last inserted message and
    completing that first.
    
    Fixes: c8790cb6da58 ("drivers: qcom: rpmh: add support for batch RPMH request")
    Cc: Lina Iyer <ilina@codeaurora.org>
    Cc: "Raju P.L.S.S.S.N" <rplsssn@codeaurora.org>
    Cc: Matthias Kaehlcke <mka@chromium.org>
    Cc: Evan Green <evgreen@chromium.org>
    Cc: stable@vger.kernel.org
    Reviewed-by: Lina Iyer <ilina@codeaurora.org>
    Reviewed-by: Evan Green <evgreen@chromium.org>
    Signed-off-by: Stephen Boyd <swboyd@chromium.org>
    Signed-off-by: Bjorn Andersson <bjorn.andersson@linaro.org>
    Signed-off-by: Andy Gross <andy.gross@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 9aba7a8fd163b8a58a25505692542c184ab44b7f
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon Feb 11 14:59:07 2019 -0800

    clk: clk-twl6040: Fix imprecise external abort for pdmclk
    
    commit 5ae51d67aec95f6f9386aa8dd5db424964895575 upstream.
    
    I noticed that modprobe clk-twl6040 can fail after a cold boot with:
    abe_cm:clk:0010:0: failed to enable
    ...
    Unhandled fault: imprecise external abort (0x1406) at 0xbe896b20
    
    WARNING: CPU: 1 PID: 29 at drivers/clk/clk.c:828 clk_core_disable_lock+0x18/0x24
    ...
    (clk_core_disable_lock) from [<c0123534>] (_disable_clocks+0x18/0x90)
    (_disable_clocks) from [<c0124040>] (_idle+0x17c/0x244)
    (_idle) from [<c0125ad4>] (omap_hwmod_idle+0x24/0x44)
    (omap_hwmod_idle) from [<c053a038>] (sysc_runtime_suspend+0x48/0x108)
    (sysc_runtime_suspend) from [<c06084c4>] (__rpm_callback+0x144/0x1d8)
    (__rpm_callback) from [<c0608578>] (rpm_callback+0x20/0x80)
    (rpm_callback) from [<c0607034>] (rpm_suspend+0x120/0x694)
    (rpm_suspend) from [<c0607a78>] (__pm_runtime_idle+0x60/0x84)
    (__pm_runtime_idle) from [<c053aaf0>] (sysc_probe+0x874/0xf2c)
    (sysc_probe) from [<c05fecd4>] (platform_drv_probe+0x48/0x98)
    
    After searching around for a similar issue, I came across an earlier fix
    that never got merged upstream in the Android tree for glass-omap-xrr02.
    There is patch "MFD: twl6040-codec: Implement PDMCLK cold temp errata"
    by Misael Lopez Cruz <misael.lopez@ti.com>.
    
    Based on my observations, this fix is also needed when cold booting
    devices, and not just for deeper idle modes. Since we now have a clock
    driver for pdmclk, let's fix the issue in twl6040_pdmclk_prepare().
    
    Cc: Misael Lopez Cruz <misael.lopez@ti.com>
    Cc: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Acked-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 02c55be588b10afc0c91ff50930717ec08c31c84
Author: Stephen Boyd <swboyd@chromium.org>
Date:   Tue Jan 15 14:54:47 2019 -0800

    soc: qcom: rpmh: Avoid accessing freed memory from batch API
    
    commit baef1c90aac7e5bf13f0360a3b334825a23d31a1 upstream.
    
    Using the batch API from the interconnect driver sometimes leads to a
    KASAN error due to an access to freed memory. This is easier to trigger
    with threadirqs on the kernel commandline.
    
     BUG: KASAN: use-after-free in rpmh_tx_done+0x114/0x12c
     Read of size 1 at addr fffffff51414ad84 by task irq/110-apps_rs/57
    
     CPU: 0 PID: 57 Comm: irq/110-apps_rs Tainted: G        W         4.19.10 #72
     Call trace:
      dump_backtrace+0x0/0x2f8
      show_stack+0x20/0x2c
      __dump_stack+0x20/0x28
      dump_stack+0xcc/0x10c
      print_address_description+0x74/0x240
      kasan_report+0x250/0x26c
      __asan_report_load1_noabort+0x20/0x2c
      rpmh_tx_done+0x114/0x12c
      tcs_tx_done+0x450/0x768
      irq_forced_thread_fn+0x58/0x9c
      irq_thread+0x120/0x1dc
      kthread+0x248/0x260
      ret_from_fork+0x10/0x18
    
     Allocated by task 385:
      kasan_kmalloc+0xac/0x148
      __kmalloc+0x170/0x1e4
      rpmh_write_batch+0x174/0x540
      qcom_icc_set+0x8dc/0x9ac
      icc_set+0x288/0x2e8
      a6xx_gmu_stop+0x320/0x3c0
      a6xx_pm_suspend+0x108/0x124
      adreno_suspend+0x50/0x60
      pm_generic_runtime_suspend+0x60/0x78
      __rpm_callback+0x214/0x32c
      rpm_callback+0x54/0x184
      rpm_suspend+0x3f8/0xa90
      pm_runtime_work+0xb4/0x178
      process_one_work+0x544/0xbc0
      worker_thread+0x514/0x7d0
      kthread+0x248/0x260
      ret_from_fork+0x10/0x18
    
     Freed by task 385:
      __kasan_slab_free+0x12c/0x1e0
      kasan_slab_free+0x10/0x1c
      kfree+0x134/0x588
      rpmh_write_batch+0x49c/0x540
      qcom_icc_set+0x8dc/0x9ac
      icc_set+0x288/0x2e8
      a6xx_gmu_stop+0x320/0x3c0
      a6xx_pm_suspend+0x108/0x124
      adreno_suspend+0x50/0x60
     cr50_spi spi5.0: SPI transfer timed out
      pm_generic_runtime_suspend+0x60/0x78
      __rpm_callback+0x214/0x32c
      rpm_callback+0x54/0x184
      rpm_suspend+0x3f8/0xa90
      pm_runtime_work+0xb4/0x178
      process_one_work+0x544/0xbc0
      worker_thread+0x514/0x7d0
      kthread+0x248/0x260
      ret_from_fork+0x10/0x18
    
     The buggy address belongs to the object at fffffff51414ac80
      which belongs to the cache kmalloc-512 of size 512
     The buggy address is located 260 bytes inside of
      512-byte region [fffffff51414ac80, fffffff51414ae80)
     The buggy address belongs to the page:
     page:ffffffbfd4505200 count:1 mapcount:0 mapping:fffffff51e00c680 index:0x0 compound_mapcount: 0
     flags: 0x4000000000008100(slab|head)
     raw: 4000000000008100 ffffffbfd4529008 ffffffbfd44f9208 fffffff51e00c680
     raw: 0000000000000000 0000000000200020 00000001ffffffff 0000000000000000
     page dumped because: kasan: bad access detected
    
     Memory state around the buggy address:
      fffffff51414ac80: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
      fffffff51414ad00: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
     >fffffff51414ad80: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
                        ^
      fffffff51414ae00: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
      fffffff51414ae80: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
    
    The batch API sets the same completion for each rpmh message that's sent
    and then loops through all the messages and waits for that single
    completion declared on the stack to be completed before returning from
    the function and freeing the message structures. Unfortunately, some
    messages may still be in process and 'stuck' in the TCS. At some later
    point, the tcs_tx_done() interrupt will run and try to process messages
    that have already been freed at the end of rpmh_write_batch(). This will
    in turn access the 'needs_free' member of the rpmh_request structure and
    cause KASAN to complain. Furthermore, if there's a message that's
    completed in rpmh_tx_done() and freed immediately after the complete()
    call is made we'll be racing with potentially freed memory when
    accessing the 'needs_free' member:
    
            CPU0                         CPU1
            ----                         ----
            rpmh_tx_done()
             complete(&compl)
                                         wait_for_completion(&compl)
                                         kfree(rpm_msg)
             if (rpm_msg->needs_free)
             <KASAN warning splat>
    
    Let's fix this by allocating a chunk of completions for each message and
    waiting for all of them to be completed before returning from the batch
    API. Alternatively, we could wait for the last message in the batch, but
    that may be a more complicated change because it looks like
    tcs_tx_done() just iterates through the indices of the queue and
    completes each message instead of tracking the last inserted message and
    completing that first.
    
    Fixes: c8790cb6da58 ("drivers: qcom: rpmh: add support for batch RPMH request")
    Cc: Lina Iyer <ilina@codeaurora.org>
    Cc: "Raju P.L.S.S.S.N" <rplsssn@codeaurora.org>
    Cc: Matthias Kaehlcke <mka@chromium.org>
    Cc: Evan Green <evgreen@chromium.org>
    Cc: stable@vger.kernel.org
    Reviewed-by: Lina Iyer <ilina@codeaurora.org>
    Reviewed-by: Evan Green <evgreen@chromium.org>
    Signed-off-by: Stephen Boyd <swboyd@chromium.org>
    Signed-off-by: Bjorn Andersson <bjorn.andersson@linaro.org>
    Signed-off-by: Andy Gross <andy.gross@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 55e62bb2c13c3e05f3ef1cbba96be1db358dd7ce
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon Feb 11 14:59:07 2019 -0800

    clk: clk-twl6040: Fix imprecise external abort for pdmclk
    
    commit 5ae51d67aec95f6f9386aa8dd5db424964895575 upstream.
    
    I noticed that modprobe clk-twl6040 can fail after a cold boot with:
    abe_cm:clk:0010:0: failed to enable
    ...
    Unhandled fault: imprecise external abort (0x1406) at 0xbe896b20
    
    WARNING: CPU: 1 PID: 29 at drivers/clk/clk.c:828 clk_core_disable_lock+0x18/0x24
    ...
    (clk_core_disable_lock) from [<c0123534>] (_disable_clocks+0x18/0x90)
    (_disable_clocks) from [<c0124040>] (_idle+0x17c/0x244)
    (_idle) from [<c0125ad4>] (omap_hwmod_idle+0x24/0x44)
    (omap_hwmod_idle) from [<c053a038>] (sysc_runtime_suspend+0x48/0x108)
    (sysc_runtime_suspend) from [<c06084c4>] (__rpm_callback+0x144/0x1d8)
    (__rpm_callback) from [<c0608578>] (rpm_callback+0x20/0x80)
    (rpm_callback) from [<c0607034>] (rpm_suspend+0x120/0x694)
    (rpm_suspend) from [<c0607a78>] (__pm_runtime_idle+0x60/0x84)
    (__pm_runtime_idle) from [<c053aaf0>] (sysc_probe+0x874/0xf2c)
    (sysc_probe) from [<c05fecd4>] (platform_drv_probe+0x48/0x98)
    
    After searching around for a similar issue, I came across an earlier fix
    that never got merged upstream in the Android tree for glass-omap-xrr02.
    There is patch "MFD: twl6040-codec: Implement PDMCLK cold temp errata"
    by Misael Lopez Cruz <misael.lopez@ti.com>.
    
    Based on my observations, this fix is also needed when cold booting
    devices, and not just for deeper idle modes. Since we now have a clock
    driver for pdmclk, let's fix the issue in twl6040_pdmclk_prepare().
    
    Cc: Misael Lopez Cruz <misael.lopez@ti.com>
    Cc: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Acked-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 51e197bc7d1bad26b9746c9267fb969c432064a4
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon Feb 11 14:59:07 2019 -0800

    clk: clk-twl6040: Fix imprecise external abort for pdmclk
    
    commit 5ae51d67aec95f6f9386aa8dd5db424964895575 upstream.
    
    I noticed that modprobe clk-twl6040 can fail after a cold boot with:
    abe_cm:clk:0010:0: failed to enable
    ...
    Unhandled fault: imprecise external abort (0x1406) at 0xbe896b20
    
    WARNING: CPU: 1 PID: 29 at drivers/clk/clk.c:828 clk_core_disable_lock+0x18/0x24
    ...
    (clk_core_disable_lock) from [<c0123534>] (_disable_clocks+0x18/0x90)
    (_disable_clocks) from [<c0124040>] (_idle+0x17c/0x244)
    (_idle) from [<c0125ad4>] (omap_hwmod_idle+0x24/0x44)
    (omap_hwmod_idle) from [<c053a038>] (sysc_runtime_suspend+0x48/0x108)
    (sysc_runtime_suspend) from [<c06084c4>] (__rpm_callback+0x144/0x1d8)
    (__rpm_callback) from [<c0608578>] (rpm_callback+0x20/0x80)
    (rpm_callback) from [<c0607034>] (rpm_suspend+0x120/0x694)
    (rpm_suspend) from [<c0607a78>] (__pm_runtime_idle+0x60/0x84)
    (__pm_runtime_idle) from [<c053aaf0>] (sysc_probe+0x874/0xf2c)
    (sysc_probe) from [<c05fecd4>] (platform_drv_probe+0x48/0x98)
    
    After searching around for a similar issue, I came across an earlier fix
    that never got merged upstream in the Android tree for glass-omap-xrr02.
    There is patch "MFD: twl6040-codec: Implement PDMCLK cold temp errata"
    by Misael Lopez Cruz <misael.lopez@ti.com>.
    
    Based on my observations, this fix is also needed when cold booting
    devices, and not just for deeper idle modes. Since we now have a clock
    driver for pdmclk, let's fix the issue in twl6040_pdmclk_prepare().
    
    Cc: Misael Lopez Cruz <misael.lopez@ti.com>
    Cc: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Acked-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 4d8e3e951a856777720272ce27f2c738a3eeef8c
Author: Marek Szyprowski <m.szyprowski@samsung.com>
Date:   Mon Feb 18 15:34:12 2019 +0100

    ARM: exynos: Fix undefined instruction during Exynos5422 resume
    
    During early system resume on Exynos5422 with performance counters enabled
    the following kernel oops happens:
    
        Internal error: Oops - undefined instruction: 0 [#1] PREEMPT SMP ARM
        Modules linked in:
        CPU: 0 PID: 1433 Comm: bash Tainted: G        W         5.0.0-rc5-next-20190208-00023-gd5fb5a8a13e6-dirty #5480
        Hardware name: SAMSUNG EXYNOS (Flattened Device Tree)
        ...
        Flags: nZCv  IRQs off  FIQs off  Mode SVC_32  ISA ARM  Segment none
        Control: 10c5387d  Table: 4451006a  DAC: 00000051
        Process bash (pid: 1433, stack limit = 0xb7e0e22f)
        ...
        (reset_ctrl_regs) from [<c0112ad0>] (dbg_cpu_pm_notify+0x1c/0x24)
        (dbg_cpu_pm_notify) from [<c014c840>] (notifier_call_chain+0x44/0x84)
        (notifier_call_chain) from [<c014cbc0>] (__atomic_notifier_call_chain+0x7c/0x128)
        (__atomic_notifier_call_chain) from [<c01ffaac>] (cpu_pm_notify+0x30/0x54)
        (cpu_pm_notify) from [<c055116c>] (syscore_resume+0x98/0x3f4)
        (syscore_resume) from [<c0189350>] (suspend_devices_and_enter+0x97c/0xe74)
        (suspend_devices_and_enter) from [<c0189fb8>] (pm_suspend+0x770/0xc04)
        (pm_suspend) from [<c0187740>] (state_store+0x6c/0xcc)
        (state_store) from [<c09fa698>] (kobj_attr_store+0x14/0x20)
        (kobj_attr_store) from [<c030159c>] (sysfs_kf_write+0x4c/0x50)
        (sysfs_kf_write) from [<c0300620>] (kernfs_fop_write+0xfc/0x1e0)
        (kernfs_fop_write) from [<c0282be8>] (__vfs_write+0x2c/0x160)
        (__vfs_write) from [<c0282ea4>] (vfs_write+0xa4/0x16c)
        (vfs_write) from [<c0283080>] (ksys_write+0x40/0x8c)
        (ksys_write) from [<c0101000>] (ret_fast_syscall+0x0/0x28)
    
    Undefined instruction is triggered during CP14 reset, because bits: #16
    (Secure privileged invasive debug disabled) and #17 (Secure privileged
    noninvasive debug disable) are set in DSCR. Those bits depend on SPNIDEN
    and SPIDEN lines, which are provided by Secure JTAG hardware block. That
    block in turn is powered from cluster 0 (big/Eagle), but the Exynos5422
    boots on cluster 1 (LITTLE/KFC).
    
    To fix this issue it is enough to turn on the power on the cluster 0 for
    a while. This lets the Secure JTAG block to propagate the needed signals
    to LITTLE/KFC cores and change their DSCR.
    
    Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Signed-off-by: Krzysztof Kozlowski <krzk@kernel.org>

commit 57aeef7f7a6848024b92c32bf23e8c85a8ac896d
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Tue Mar 19 09:32:36 2019 -0700

    platform/chrome: cros_ec_debugfs: cancel/schedule logging work only if supported
    
    The following traceback was reported on ASUS C201, which does not support
    console logging.
    
    ------------[ cut here ]------------
    WARNING: CPU: 2 PID: 361 at kernel/workqueue.c:3030 __flush_work+0x38/0x154
    Modules linked in: snd_soc_hdmi_codec cros_ec_debugfs cros_ec_sysfs uvcvideo dw_hdmi_cec dw_hdmi_i2s_audio videobuf2_vmalloc cfg80211 gpio_charger rk_crypto rfkill videobuf2_memops videobuf2_v4l2 des_generic videobuf2_common ofpart m25p80 spi_nor tpm_i2c_infineon sbs_battery mtd tpm joydev cros_ec_dev coreboot_table evdev mousedev ip_tables x_tables [last unloaded: brcmutil]
    CPU: 2 PID: 361 Comm: systemd-sleep Not tainted 5.1.0-rc1-1-ARCH+ #1
    Hardware name: Rockchip (Device Tree)
    [<c020e4b0>] (unwind_backtrace) from [<c020ac18>] (show_stack+0x10/0x14)
    [<c020ac18>] (show_stack) from [<c07a3e04>] (dump_stack+0x7c/0x9c)
    [<c07a3e04>] (dump_stack) from [<c0222748>] (__warn+0xd0/0xec)
    [<c0222748>] (__warn) from [<c022279c>] (warn_slowpath_null+0x38/0x44)
    [<c022279c>] (warn_slowpath_null) from [<c02365d0>] (__flush_work+0x38/0x154)
    [<c02365d0>] (__flush_work) from [<c023786c>] (__cancel_work_timer+0x114/0x1a4)
    [<c023786c>] (__cancel_work_timer) from [<bf33233c>] (cros_ec_debugfs_suspend+0x14/0x1c [cros_ec_debugfs])
    [<bf33233c>] (cros_ec_debugfs_suspend [cros_ec_debugfs]) from [<c056a888>] (dpm_run_callback+0x64/0xcc)
    [<c056a888>] (dpm_run_callback) from [<c056ad2c>] (__device_suspend+0x174/0x3a8)
    [<c056ad2c>] (__device_suspend) from [<c056b9e0>] (dpm_suspend+0x174/0x1e0)
    [<c056b9e0>] (dpm_suspend) from [<c026b3e0>] (suspend_devices_and_enter+0x6c/0x50c)
    [<c026b3e0>] (suspend_devices_and_enter) from [<c026ba8c>] (pm_suspend+0x20c/0x274)
    [<c026ba8c>] (pm_suspend) from [<c026a628>] (state_store+0x54/0x88)
    [<c026a628>] (state_store) from [<c03cd2d0>] (kernfs_fop_write+0x114/0x180)
    [<c03cd2d0>] (kernfs_fop_write) from [<c035d48c>] (__vfs_write+0x1c/0x154)
    [<c035d48c>] (__vfs_write) from [<c035f9e8>] (vfs_write+0xb8/0x198)
    [<c035f9e8>] (vfs_write) from [<c035fbc0>] (ksys_write+0x3c/0x74)
    [<c035fbc0>] (ksys_write) from [<c0201000>] (ret_fast_syscall+0x0/0x4c)
    Exception stack(0xe9365fa8 to 0xe9365ff0)
    5fa0: 00000004 beef8b28 00000004 beef8b28 00000004 00000000
    5fc0: 00000004 beef8b28 02319170 00000004 beef8b28 00000004 b6f3d900 beef8b74
    5fe0: 0000006c beef8a98 b6c0adac b6c66534
    ---[ end trace f4ee5df14e8ea0ec ]---
    
    If console logging is not supported, the work structure is never
    initialized, resulting in the traceback. Calling cancel/schedule functions
    conditionally fixes the problem.
    
    While at it, also fix error handling in the probe function.
    
    Reported-by: Urja Rannikko <urjaman@gmail.com>
    Cc: Urja Rannikko <urjaman@gmail.com>
    Fixes: 6fce0a2cf5a05 ("mfd / platform: cros_ec: Move debugfs attributes to its own driver")
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Benson Leung <bleung@chromium.org>

commit cac734c2dbd2514f14c8c6a17caba1990d83bf1d
Author: Kevin Wang <kevin1.wang@amd.com>
Date:   Fri Feb 22 12:36:49 2019 +0800

    drm/amdkfd: use init_mqd function to allocate object for hid_mqd (CI)
    
    if use the legacy method to allocate object, when mqd_hiq need to run
    uninit code, it will be cause WARNING call trace.
    
    eg: (s3 suspend test)
    [   34.918944] Call Trace:
    [   34.918948]  [<ffffffff92961dc1>] dump_stack+0x19/0x1b
    [   34.918950]  [<ffffffff92297648>] __warn+0xd8/0x100
    [   34.918951]  [<ffffffff9229778d>] warn_slowpath_null+0x1d/0x20
    [   34.918991]  [<ffffffffc03ce1fe>] uninit_mqd_hiq_sdma+0x4e/0x50 [amdgpu]
    [   34.919028]  [<ffffffffc03d0ef7>] uninitialize+0x37/0xe0 [amdgpu]
    [   34.919064]  [<ffffffffc03d15a6>] kernel_queue_uninit+0x16/0x30 [amdgpu]
    [   34.919086]  [<ffffffffc03d26c2>] pm_uninit+0x12/0x20 [amdgpu]
    [   34.919107]  [<ffffffffc03d4915>] stop_nocpsch+0x15/0x20 [amdgpu]
    [   34.919129]  [<ffffffffc03c1dce>] kgd2kfd_suspend.part.4+0x2e/0x50 [amdgpu]
    [   34.919150]  [<ffffffffc03c2667>] kgd2kfd_suspend+0x17/0x20 [amdgpu]
    [   34.919171]  [<ffffffffc03c103a>] amdgpu_amdkfd_suspend+0x1a/0x20 [amdgpu]
    [   34.919187]  [<ffffffffc02ec428>] amdgpu_device_suspend+0x88/0x3a0 [amdgpu]
    [   34.919189]  [<ffffffff922e22cf>] ? enqueue_entity+0x2ef/0xbe0
    [   34.919205]  [<ffffffffc02e8220>] amdgpu_pmops_suspend+0x20/0x30 [amdgpu]
    [   34.919207]  [<ffffffff925c56ff>] pci_pm_suspend+0x6f/0x150
    [   34.919208]  [<ffffffff925c5690>] ? pci_pm_freeze+0xf0/0xf0
    [   34.919210]  [<ffffffff926b45c6>] dpm_run_callback+0x46/0x90
    [   34.919212]  [<ffffffff926b49db>] __device_suspend+0xfb/0x2a0
    [   34.919213]  [<ffffffff926b4b9f>] async_suspend+0x1f/0xa0
    [   34.919214]  [<ffffffff922c918f>] async_run_entry_fn+0x3f/0x130
    [   34.919216]  [<ffffffff922b9d4f>] process_one_work+0x17f/0x440
    [   34.919217]  [<ffffffff922bade6>] worker_thread+0x126/0x3c0
    [   34.919218]  [<ffffffff922bacc0>] ? manage_workers.isra.25+0x2a0/0x2a0
    [   34.919220]  [<ffffffff922c1c31>] kthread+0xd1/0xe0
    [   34.919221]  [<ffffffff922c1b60>] ? insert_kthread_work+0x40/0x40
    [   34.919222]  [<ffffffff92974c1d>] ret_from_fork_nospec_begin+0x7/0x21
    [   34.919224]  [<ffffffff922c1b60>] ? insert_kthread_work+0x40/0x40
    [   34.919224] ---[ end trace 38cd9f65c963adad ]---
    
    Signed-off-by: Kevin Wang <kevin1.wang@amd.com>
    Reviewed-by: Oak Zeng <Oak.Zeng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

commit 5ae51d67aec95f6f9386aa8dd5db424964895575
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon Feb 11 14:59:07 2019 -0800

    clk: clk-twl6040: Fix imprecise external abort for pdmclk
    
    I noticed that modprobe clk-twl6040 can fail after a cold boot with:
    abe_cm:clk:0010:0: failed to enable
    ...
    Unhandled fault: imprecise external abort (0x1406) at 0xbe896b20
    
    WARNING: CPU: 1 PID: 29 at drivers/clk/clk.c:828 clk_core_disable_lock+0x18/0x24
    ...
    (clk_core_disable_lock) from [<c0123534>] (_disable_clocks+0x18/0x90)
    (_disable_clocks) from [<c0124040>] (_idle+0x17c/0x244)
    (_idle) from [<c0125ad4>] (omap_hwmod_idle+0x24/0x44)
    (omap_hwmod_idle) from [<c053a038>] (sysc_runtime_suspend+0x48/0x108)
    (sysc_runtime_suspend) from [<c06084c4>] (__rpm_callback+0x144/0x1d8)
    (__rpm_callback) from [<c0608578>] (rpm_callback+0x20/0x80)
    (rpm_callback) from [<c0607034>] (rpm_suspend+0x120/0x694)
    (rpm_suspend) from [<c0607a78>] (__pm_runtime_idle+0x60/0x84)
    (__pm_runtime_idle) from [<c053aaf0>] (sysc_probe+0x874/0xf2c)
    (sysc_probe) from [<c05fecd4>] (platform_drv_probe+0x48/0x98)
    
    After searching around for a similar issue, I came across an earlier fix
    that never got merged upstream in the Android tree for glass-omap-xrr02.
    There is patch "MFD: twl6040-codec: Implement PDMCLK cold temp errata"
    by Misael Lopez Cruz <misael.lopez@ti.com>.
    
    Based on my observations, this fix is also needed when cold booting
    devices, and not just for deeper idle modes. Since we now have a clock
    driver for pdmclk, let's fix the issue in twl6040_pdmclk_prepare().
    
    Cc: Misael Lopez Cruz <misael.lopez@ti.com>
    Cc: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Acked-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

commit 74fb44863084275b952f21ec6a024af0e2e75cb8
Author: Vincent Guittot <vincent.guittot@linaro.org>
Date:   Thu Feb 21 08:59:02 2019 +0100

    PM-runtime: Fix deadlock when canceling hrtimer
    
    When rpm_resume() desactivates the autosuspend timer, it should only
    try to cancel hrtimer but not wait for the handler to finish, because
    both rpm_resume() and pm_suspend_timer_fn() take the power.lock.
    
    A deadlock is possible as follows:
    
    CPU0                              CPU1
    rpm_resume()
      spin_lock_irqsave
                                      pm_suspend_timer_fn()
                                        spin_lock_irqsave
      pm_runtime_deactivate_timer()
        hrtimer_cancel()
    
    It is sufficient to call hrtimer_try_to_cancel() from
    pm_runtime_deactivate_timer(), because dev->power.timer_expires
    reset to 0 by it, so use that function instead of hrtimer_cancel().
    
    Fixes: 8234f6734c5d ("PM-runtime: Switch autosuspend over to using hrtimers")
    Reported-by: Sunzhaosheng Sun(Zhaosheng) <sunzhaosheng@hisilicon.com>
    Signed-off-by: Vincent Guittot <vincent.guittot@linaro.org>
    [ rjw: Changelog ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit a3fbfae82b4cb3ff9928e29f34c64d0507cad874
Author: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
Date:   Mon Nov 5 02:07:56 2018 +0200

    tpm: take TPM chip power gating out of tpm_transmit()
    
    Call tpm_chip_start() and tpm_chip_stop() in
    
    * tpm_chip_register()
    * tpm_class_shutdown()
    * tpm_del_char_device()
    * tpm_pm_suspend()
    * tpm_try_get_ops() and tpm_put_ops()
    * tpm2_del_space()
    
    And remove these calls from tpm_transmit(). The core reason for this
    change is that in tpm_vtpm_proxy a locality change requires a virtual
    TPM command (a command made up just for that driver).
    
    The consequence of this is that this commit removes the remaining nested
    calls.
    
    Signed-off-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
    Reviewed-by: Stefan Berger <stefanb@linux.ibm.com>
    Tested-by: Stefan Berger <stefanb@linux.ibm.com>
    Reviewed-by: Jerry Snitselaar <jsnitsel@redhat.com>
    Reviewed-by: James Bottomley <James.Bottomley@HansenPartnership.com>
    Tested-by: Alexander Steffen <Alexander.Steffen@infineon.com>

commit baef1c90aac7e5bf13f0360a3b334825a23d31a1
Author: Stephen Boyd <swboyd@chromium.org>
Date:   Tue Jan 15 14:54:47 2019 -0800

    soc: qcom: rpmh: Avoid accessing freed memory from batch API
    
    Using the batch API from the interconnect driver sometimes leads to a
    KASAN error due to an access to freed memory. This is easier to trigger
    with threadirqs on the kernel commandline.
    
     BUG: KASAN: use-after-free in rpmh_tx_done+0x114/0x12c
     Read of size 1 at addr fffffff51414ad84 by task irq/110-apps_rs/57
    
     CPU: 0 PID: 57 Comm: irq/110-apps_rs Tainted: G        W         4.19.10 #72
     Call trace:
      dump_backtrace+0x0/0x2f8
      show_stack+0x20/0x2c
      __dump_stack+0x20/0x28
      dump_stack+0xcc/0x10c
      print_address_description+0x74/0x240
      kasan_report+0x250/0x26c
      __asan_report_load1_noabort+0x20/0x2c
      rpmh_tx_done+0x114/0x12c
      tcs_tx_done+0x450/0x768
      irq_forced_thread_fn+0x58/0x9c
      irq_thread+0x120/0x1dc
      kthread+0x248/0x260
      ret_from_fork+0x10/0x18
    
     Allocated by task 385:
      kasan_kmalloc+0xac/0x148
      __kmalloc+0x170/0x1e4
      rpmh_write_batch+0x174/0x540
      qcom_icc_set+0x8dc/0x9ac
      icc_set+0x288/0x2e8
      a6xx_gmu_stop+0x320/0x3c0
      a6xx_pm_suspend+0x108/0x124
      adreno_suspend+0x50/0x60
      pm_generic_runtime_suspend+0x60/0x78
      __rpm_callback+0x214/0x32c
      rpm_callback+0x54/0x184
      rpm_suspend+0x3f8/0xa90
      pm_runtime_work+0xb4/0x178
      process_one_work+0x544/0xbc0
      worker_thread+0x514/0x7d0
      kthread+0x248/0x260
      ret_from_fork+0x10/0x18
    
     Freed by task 385:
      __kasan_slab_free+0x12c/0x1e0
      kasan_slab_free+0x10/0x1c
      kfree+0x134/0x588
      rpmh_write_batch+0x49c/0x540
      qcom_icc_set+0x8dc/0x9ac
      icc_set+0x288/0x2e8
      a6xx_gmu_stop+0x320/0x3c0
      a6xx_pm_suspend+0x108/0x124
      adreno_suspend+0x50/0x60
     cr50_spi spi5.0: SPI transfer timed out
      pm_generic_runtime_suspend+0x60/0x78
      __rpm_callback+0x214/0x32c
      rpm_callback+0x54/0x184
      rpm_suspend+0x3f8/0xa90
      pm_runtime_work+0xb4/0x178
      process_one_work+0x544/0xbc0
      worker_thread+0x514/0x7d0
      kthread+0x248/0x260
      ret_from_fork+0x10/0x18
    
     The buggy address belongs to the object at fffffff51414ac80
      which belongs to the cache kmalloc-512 of size 512
     The buggy address is located 260 bytes inside of
      512-byte region [fffffff51414ac80, fffffff51414ae80)
     The buggy address belongs to the page:
     page:ffffffbfd4505200 count:1 mapcount:0 mapping:fffffff51e00c680 index:0x0 compound_mapcount: 0
     flags: 0x4000000000008100(slab|head)
     raw: 4000000000008100 ffffffbfd4529008 ffffffbfd44f9208 fffffff51e00c680
     raw: 0000000000000000 0000000000200020 00000001ffffffff 0000000000000000
     page dumped because: kasan: bad access detected
    
     Memory state around the buggy address:
      fffffff51414ac80: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
      fffffff51414ad00: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
     >fffffff51414ad80: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
                        ^
      fffffff51414ae00: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
      fffffff51414ae80: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
    
    The batch API sets the same completion for each rpmh message that's sent
    and then loops through all the messages and waits for that single
    completion declared on the stack to be completed before returning from
    the function and freeing the message structures. Unfortunately, some
    messages may still be in process and 'stuck' in the TCS. At some later
    point, the tcs_tx_done() interrupt will run and try to process messages
    that have already been freed at the end of rpmh_write_batch(). This will
    in turn access the 'needs_free' member of the rpmh_request structure and
    cause KASAN to complain. Furthermore, if there's a message that's
    completed in rpmh_tx_done() and freed immediately after the complete()
    call is made we'll be racing with potentially freed memory when
    accessing the 'needs_free' member:
    
            CPU0                         CPU1
            ----                         ----
            rpmh_tx_done()
             complete(&compl)
                                         wait_for_completion(&compl)
                                         kfree(rpm_msg)
             if (rpm_msg->needs_free)
             <KASAN warning splat>
    
    Let's fix this by allocating a chunk of completions for each message and
    waiting for all of them to be completed before returning from the batch
    API. Alternatively, we could wait for the last message in the batch, but
    that may be a more complicated change because it looks like
    tcs_tx_done() just iterates through the indices of the queue and
    completes each message instead of tracking the last inserted message and
    completing that first.
    
    Fixes: c8790cb6da58 ("drivers: qcom: rpmh: add support for batch RPMH request")
    Cc: Lina Iyer <ilina@codeaurora.org>
    Cc: "Raju P.L.S.S.S.N" <rplsssn@codeaurora.org>
    Cc: Matthias Kaehlcke <mka@chromium.org>
    Cc: Evan Green <evgreen@chromium.org>
    Cc: stable@vger.kernel.org
    Reviewed-by: Lina Iyer <ilina@codeaurora.org>
    Reviewed-by: Evan Green <evgreen@chromium.org>
    Signed-off-by: Stephen Boyd <swboyd@chromium.org>
    Signed-off-by: Bjorn Andersson <bjorn.andersson@linaro.org>
    Signed-off-by: Andy Gross <andy.gross@linaro.org>

commit e2f3cd831a280fc226118d9369bf3f77aab58c56
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Feb 1 01:49:14 2019 +0100

    driver core: Fix handling of runtime PM flags in device_link_add()
    
    After commit ead18c23c263 ("driver core: Introduce device links
    reference counting"), if there is a link between the given supplier
    and the given consumer already, device_link_add() will refcount it
    and return it unconditionally without updating its flags.  It is
    possible, however, that the second (or any subsequent) caller of
    device_link_add() for the same consumer-supplier pair will pass
    DL_FLAG_PM_RUNTIME, possibly along with DL_FLAG_RPM_ACTIVE, in flags
    to it and the existing link may not behave as expected then.
    
    First, if DL_FLAG_PM_RUNTIME is not set in the existing link's flags
    at all, it needs to be set like during the original initialization of
    the link.
    
    Second, if DL_FLAG_RPM_ACTIVE is passed to device_link_add() in flags
    (in addition to DL_FLAG_PM_RUNTIME), the existing link should to be
    updated to reflect the "active" runtime PM configuration of the
    consumer-supplier pair and extra care must be taken here to avoid
    possible destructive races with runtime PM of the consumer.
    
    To that end, redefine the rpm_active field in struct device_link
    as a refcount, initialize it to 1 and make rpm_resume() (for the
    consumer) and device_link_add() increment it whenever they acquire
    a runtime PM reference on the supplier device.  Accordingly, make
    rpm_suspend() (for the consumer) and pm_runtime_clean_up_links()
    decrement it and drop runtime PM references to the supplier
    device in a loop until rpm_active becones 1 again.
    
    Fixes: ead18c23c263 ("driver core: Introduce device links reference counting")
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 8234f6734c5d74ac794e5517437f51c57d65f865
Author: Vincent Guittot <vincent.guittot@linaro.org>
Date:   Fri Dec 14 15:22:25 2018 +0100

    PM-runtime: Switch autosuspend over to using hrtimers
    
    PM-runtime uses the timer infrastructure for autosuspend. This implies
    that the minimum time before autosuspending a device is in the range
    of 1 tick included to 2 ticks excluded
     -On arm64 this means between 4ms and 8ms with default jiffies
      configuration
     -And on arm, it is between 10ms and 20ms
    
    These values are quite high for embedded systems which sometimes want
    the duration to be in the range of 1 ms.
    
    It is possible to switch autosuspend over to using hrtimers to get
    finer granularity for short durations and take advantage of slack to
    retain some margins and get long timeouts with minimum wakeups.
    
    On an arm64 platform that uses 1ms for autosuspending timeout of its
    GPU, idle power is reduced by 10% with hrtimer.
    
    The latency impact on arm64 hikey octo cores is:
     - mark_last_busy: from 1.11 us to 1.25 us
     - rpm_suspend: from 15.54 us to 15.38 us
    [Only the code path of rpm_suspend() that starts hrtimer has been
    measured.]
    
    arm64 image (arm64 default defconfig) decreases by around 3KB
    with following details:
    
    $ size vmlinux-timer
       text    data     bss     dec     hex filename
    12034646        6869268  386840 19290754        1265a82 vmlinux
    
    $ size vmlinux-hrtimer
       text    data     bss     dec     hex filename
    12030550        6870164  387032 19287746        1264ec2 vmlinux
    
    The latency impact on arm 32bits snowball dual cores is :
     - mark_last_busy: from 0.31 us usec to 0.77 us
     - rpm_suspend: from 6.83 us to 6.67 usec
    
    The increase of the image for snowball platform that I used for
    testing performance impact, is neglictable (244B).
    
    $ size vmlinux-timer
       text    data     bss     dec     hex filename
    7157961 2119580  264120 9541661  91981d build-ux500/vmlinux
    
    size vmlinux-hrtimer
       text    data     bss     dec     hex filename
    7157773 2119884  264248 9541905  919911 vmlinux-hrtimer
    
    And arm 32bits image (multi_v7_defconfig) increases by around 1.7KB
    with following details:
    
    $ size vmlinux-timer
       text    data     bss     dec     hex filename
    13304443        6803420  402768 20510631        138f7a7 vmlinux
    
    $ size vmlinux-hrtimer
       text    data     bss     dec     hex filename
    13304299        6805276  402768 20512343        138fe57 vmlinux
    
    Signed-off-by: Vincent Guittot <vincent.guittot@linaro.org>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit a5a6cebdd016e2d1cc3c60359fce846d5efe16f4
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Oct 4 11:08:12 2018 +0200

    PM / core: Clear the direct_complete flag on errors
    
    commit 69e445ab8b66a9f30519842ef18be555d3ee9b51 upstream.
    
    If __device_suspend() runs asynchronously (in which case the device
    passed to it is in dpm_suspended_list at that point) and it returns
    early on an error or pending wakeup, and the power.direct_complete
    flag has been set for the device already, the subsequent
    device_resume() will be confused by that and it will call
    pm_runtime_enable() incorrectly, as runtime PM has not been
    disabled for the device by __device_suspend().
    
    To avoid that, clear power.direct_complete if __device_suspend()
    is not going to disable runtime PM for the device before returning.
    
    Fixes: aae4518b3124 (PM / sleep: Mechanism to avoid resuming runtime-suspended devices unnecessarily)
    Reported-by: Al Cooper <alcooperx@gmail.com>
    Tested-by: Al Cooper <alcooperx@gmail.com>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit 3750e78c72da3c35292dcf531ebe3062faaa33bc
Author: Bruce Wang <bzwang@chromium.org>
Date:   Fri Oct 5 17:04:01 2018 -0400

    drm/msm: Cut dpu_kms hooks from msm_pm_suspend/resume
    
    Removes the traces of the non-atomic helper calls in
    msm_pm_suspend/resume since we just deleted those functions (see patch
    1). Also removes the drm_kms_helper_poll_disable/enable calls, since
    the DRM_CONNECTOR_POLL_CONNECT flag is never set so periodic polling
    doesn't happen anyways.
    
    v2: reorganized patch order
    v3: made error checks less severe
    
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Bruce Wang <bzwang@chromium.org>
    Signed-off-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

commit b2b83523b1768828c3122a2862fa0dd88fb40489
Author: Bruce Wang <bzwang@chromium.org>
Date:   Fri Oct 5 17:04:00 2018 -0400

    drm/msm/dpu: Remove dpu_kms_pm_suspend/resume
    
    PM resume was crashing during dpu_kms_pm_resume. This patch removes
    dpu_kms_pm_suspend/resume so that msm_pm_suspend/resume uses the atomic
    helpers instead (see next patch). This patch also removes
    dpu_kms_is_suspend_blocked since it is never called.
    
    v2: Reorganized patches in patchset
    
    Signed-off-by: Bruce Wang <bzwang@chromium.org>
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

commit 9315e73ac87065acd898d3f15b9f524ca86736a7
Author: Tomas Winkler <tomas.winkler@intel.com>
Date:   Fri Oct 19 21:23:05 2018 +0300

    tpm1: reimplement SAVESTATE using tpm_buf
    
    In tpm1_pm_suspend() function reimplement,
    TPM_ORD_SAVESTATE comamnd using tpm_buf.
    
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Reviewed-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
    Tested-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
    Signed-off-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>

commit c82a330ceceda28304e37bab35128fa0c9c7f172
Author: Tomas Winkler <tomas.winkler@intel.com>
Date:   Fri Oct 19 21:22:57 2018 +0300

    tpm: factor out tpm 1.x pm suspend flow into tpm1-cmd.c
    
    Factor out TPM 1.x suspend flow from tpm-interface.c into a new function
    tpm1_pm_suspend() in tpm1-cmd.c
    
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Reviewed-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
    Tested-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
    Signed-off-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>

commit bcd49e86710b42f15c7512de594d23b3ae0b21d7
Author: Huang Ying <ying.huang@intel.com>
Date:   Fri Oct 26 15:03:46 2018 -0700

    mm/swapfile.c: use __try_to_reclaim_swap() in free_swap_and_cache()
    
    The code path to reclaim the swap entry in free_swap_and_cache() is
    almost same as that of __try_to_reclaim_swap().  The largest
    difference is just coding style.  So the support to the additional
    requirement of free_swap_and_cache() is added into
    __try_to_reclaim_swap().  free_swap_and_cache() is changed to call
    __try_to_reclaim_swap(), and delete the duplicated code.  This will
    improve code readability and reduce the potential bugs.
    
    There are 2 functionality differences between __try_to_reclaim_swap()
    and swap entry reclaim code of free_swap_and_cache().
    
    - free_swap_and_cache() only reclaims the swap entry if the page is
      unmapped or swap is getting full.  The support has been added into
      __try_to_reclaim_swap().
    
    - try_to_free_swap() (called by __try_to_reclaim_swap()) checks
      pm_suspended_storage(), while free_swap_and_cache() not.  I think
      this is OK.  Because the page and the swap entry can be reclaimed
      later eventually.
    
    Link: http://lkml.kernel.org/r/20180827075535.17406-2-ying.huang@intel.com
    Signed-off-by: "Huang, Ying" <ying.huang@intel.com>
    Reviewed-by: Andrew Morton <akpm@linux-foundation.org>
    Cc: Dave Hansen <dave.hansen@linux.intel.com>
    Cc: Michal Hocko <mhocko@suse.com>
    Cc: Johannes Weiner <hannes@cmpxchg.org>
    Cc: Shaohua Li <shli@kernel.org>
    Cc: Hugh Dickins <hughd@google.com>
    Cc: Minchan Kim <minchan@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit a1c6ca3c6de763459a6e93b644ec6518c890ba1c
Author: Vitaly Kuznetsov <vkuznets@redhat.com>
Date:   Wed Oct 17 13:23:55 2018 +0200

    kernel: hung_task.c: disable on suspend
    
    It is possible to observe hung_task complaints when system goes to
    suspend-to-idle state:
    
     # echo freeze > /sys/power/state
    
     PM: Syncing filesystems ... done.
     Freezing user space processes ... (elapsed 0.001 seconds) done.
     OOM killer disabled.
     Freezing remaining freezable tasks ... (elapsed 0.002 seconds) done.
     sd 0:0:0:0: [sda] Synchronizing SCSI cache
     INFO: task bash:1569 blocked for more than 120 seconds.
           Not tainted 4.19.0-rc3_+ #687
     "echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
     bash            D    0  1569    604 0x00000000
     Call Trace:
      ? __schedule+0x1fe/0x7e0
      schedule+0x28/0x80
      suspend_devices_and_enter+0x4ac/0x750
      pm_suspend+0x2c0/0x310
    
    Register a PM notifier to disable the detector on suspend and re-enable
    back on wakeup.
    
    Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit a92f4488357e3a5baa444d0b51ef240003805c06
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Oct 4 11:08:12 2018 +0200

    PM / core: Clear the direct_complete flag on errors
    
    commit 69e445ab8b66a9f30519842ef18be555d3ee9b51 upstream.
    
    If __device_suspend() runs asynchronously (in which case the device
    passed to it is in dpm_suspended_list at that point) and it returns
    early on an error or pending wakeup, and the power.direct_complete
    flag has been set for the device already, the subsequent
    device_resume() will be confused by that and it will call
    pm_runtime_enable() incorrectly, as runtime PM has not been
    disabled for the device by __device_suspend().
    
    To avoid that, clear power.direct_complete if __device_suspend()
    is not going to disable runtime PM for the device before returning.
    
    Fixes: aae4518b3124 (PM / sleep: Mechanism to avoid resuming runtime-suspended devices unnecessarily)
    Reported-by: Al Cooper <alcooperx@gmail.com>
    Tested-by: Al Cooper <alcooperx@gmail.com>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Cc: 3.16+ <stable@vger.kernel.org> # 3.16+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 1364055c96c5359bfe74637e41ba673956ac9c93
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Oct 4 11:08:12 2018 +0200

    PM / core: Clear the direct_complete flag on errors
    
    commit 69e445ab8b66a9f30519842ef18be555d3ee9b51 upstream.
    
    If __device_suspend() runs asynchronously (in which case the device
    passed to it is in dpm_suspended_list at that point) and it returns
    early on an error or pending wakeup, and the power.direct_complete
    flag has been set for the device already, the subsequent
    device_resume() will be confused by that and it will call
    pm_runtime_enable() incorrectly, as runtime PM has not been
    disabled for the device by __device_suspend().
    
    To avoid that, clear power.direct_complete if __device_suspend()
    is not going to disable runtime PM for the device before returning.
    
    Fixes: aae4518b3124 (PM / sleep: Mechanism to avoid resuming runtime-suspended devices unnecessarily)
    Reported-by: Al Cooper <alcooperx@gmail.com>
    Tested-by: Al Cooper <alcooperx@gmail.com>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Cc: 3.16+ <stable@vger.kernel.org> # 3.16+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 75b66cc009433bff1dd31382d06b9d64d8e1cc25
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Oct 4 11:08:12 2018 +0200

    PM / core: Clear the direct_complete flag on errors
    
    commit 69e445ab8b66a9f30519842ef18be555d3ee9b51 upstream.
    
    If __device_suspend() runs asynchronously (in which case the device
    passed to it is in dpm_suspended_list at that point) and it returns
    early on an error or pending wakeup, and the power.direct_complete
    flag has been set for the device already, the subsequent
    device_resume() will be confused by that and it will call
    pm_runtime_enable() incorrectly, as runtime PM has not been
    disabled for the device by __device_suspend().
    
    To avoid that, clear power.direct_complete if __device_suspend()
    is not going to disable runtime PM for the device before returning.
    
    Fixes: aae4518b3124 (PM / sleep: Mechanism to avoid resuming runtime-suspended devices unnecessarily)
    Reported-by: Al Cooper <alcooperx@gmail.com>
    Tested-by: Al Cooper <alcooperx@gmail.com>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Cc: 3.16+ <stable@vger.kernel.org> # 3.16+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 1516d9fa636f1e6276bf37086d06f9847c25bc59
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Oct 4 11:08:12 2018 +0200

    PM / core: Clear the direct_complete flag on errors
    
    commit 69e445ab8b66a9f30519842ef18be555d3ee9b51 upstream.
    
    If __device_suspend() runs asynchronously (in which case the device
    passed to it is in dpm_suspended_list at that point) and it returns
    early on an error or pending wakeup, and the power.direct_complete
    flag has been set for the device already, the subsequent
    device_resume() will be confused by that and it will call
    pm_runtime_enable() incorrectly, as runtime PM has not been
    disabled for the device by __device_suspend().
    
    To avoid that, clear power.direct_complete if __device_suspend()
    is not going to disable runtime PM for the device before returning.
    
    Fixes: aae4518b3124 (PM / sleep: Mechanism to avoid resuming runtime-suspended devices unnecessarily)
    Reported-by: Al Cooper <alcooperx@gmail.com>
    Tested-by: Al Cooper <alcooperx@gmail.com>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Cc: 3.16+ <stable@vger.kernel.org> # 3.16+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit d9e61bdd84b279ec94207ed335de5991ffd384d8
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Oct 4 11:08:12 2018 +0200

    PM / core: Clear the direct_complete flag on errors
    
    commit 69e445ab8b66a9f30519842ef18be555d3ee9b51 upstream.
    
    If __device_suspend() runs asynchronously (in which case the device
    passed to it is in dpm_suspended_list at that point) and it returns
    early on an error or pending wakeup, and the power.direct_complete
    flag has been set for the device already, the subsequent
    device_resume() will be confused by that and it will call
    pm_runtime_enable() incorrectly, as runtime PM has not been
    disabled for the device by __device_suspend().
    
    To avoid that, clear power.direct_complete if __device_suspend()
    is not going to disable runtime PM for the device before returning.
    
    Fixes: aae4518b3124 (PM / sleep: Mechanism to avoid resuming runtime-suspended devices unnecessarily)
    Reported-by: Al Cooper <alcooperx@gmail.com>
    Tested-by: Al Cooper <alcooperx@gmail.com>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Cc: 3.16+ <stable@vger.kernel.org> # 3.16+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 69e445ab8b66a9f30519842ef18be555d3ee9b51
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Oct 4 11:08:12 2018 +0200

    PM / core: Clear the direct_complete flag on errors
    
    If __device_suspend() runs asynchronously (in which case the device
    passed to it is in dpm_suspended_list at that point) and it returns
    early on an error or pending wakeup, and the power.direct_complete
    flag has been set for the device already, the subsequent
    device_resume() will be confused by that and it will call
    pm_runtime_enable() incorrectly, as runtime PM has not been
    disabled for the device by __device_suspend().
    
    To avoid that, clear power.direct_complete if __device_suspend()
    is not going to disable runtime PM for the device before returning.
    
    Fixes: aae4518b3124 (PM / sleep: Mechanism to avoid resuming runtime-suspended devices unnecessarily)
    Reported-by: Al Cooper <alcooperx@gmail.com>
    Tested-by: Al Cooper <alcooperx@gmail.com>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Cc: 3.16+ <stable@vger.kernel.org> # 3.16+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 791d54fa054d304636fa783f6f082a9dd934ec6a
Author: Alexandru Gheorghe <alexandru-cosmin.gheorghe@arm.com>
Date:   Fri Sep 21 14:39:44 2018 +0100

    drm/malidp: Fix smart layer when doing pm_suspend/resume
    
    Smart layer enable rectangles is set to 1 when the driver is probed,
    however when doing pm_suspend the value is lost and it's not set again
    making the SMART_LAYER unusable, fix that by initializing the number
    of rectangles everytime we do a plane update.
    
    Signed-off-by: Alexandru Gheorghe <alexandru-cosmin.gheorghe@arm.com>
    Acked-by: Liviu Dudau <liviu.dudau@arm.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

commit 6862fdf2201ab67cd962dbf0643d37db909f4860
Author: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
Date:   Fri Sep 28 15:32:46 2018 +0200

    ARM: samsung: Limit SAMSUNG_PM_CHECK config option to non-Exynos platforms
    
    "S3C2410 PM Suspend Memory CRC" feature (controlled by
    SAMSUNG_PM_CHECK config option) is incompatible with highmem
    (uses phys_to_virt() instead of proper mapping) which is used by
    the majority of Exynos boards. The issue manifests itself in OOPS
    on affected boards, i.e. on Odroid-U3 I got the following one:
    
    Unable to handle kernel paging request at virtual address f0000000
    pgd = 1c0f9bb4
    [f0000000] *pgd=00000000
    Internal error: Oops: 5 [#1] PREEMPT SMP ARM
    [<c0458034>] (crc32_le) from [<c0121f8c>] (s3c_pm_makecheck+0x34/0x54)
    [<c0121f8c>] (s3c_pm_makecheck) from [<c0121efc>] (s3c_pm_run_res+0x74/0x8c)
    [<c0121efc>] (s3c_pm_run_res) from [<c0121ecc>] (s3c_pm_run_res+0x44/0x8c)
    [<c0121ecc>] (s3c_pm_run_res) from [<c01210b8>] (exynos_suspend_enter+0x64/0x148)
    [<c01210b8>] (exynos_suspend_enter) from [<c018893c>] (suspend_devices_and_enter+0x9ec/0xe74)
    [<c018893c>] (suspend_devices_and_enter) from [<c0189534>] (pm_suspend+0x770/0xc04)
    [<c0189534>] (pm_suspend) from [<c0186ce8>] (state_store+0x6c/0xcc)
    [<c0186ce8>] (state_store) from [<c09db434>] (kobj_attr_store+0x14/0x20)
    [<c09db434>] (kobj_attr_store) from [<c02fa63c>] (sysfs_kf_write+0x4c/0x50)
    [<c02fa63c>] (sysfs_kf_write) from [<c02f97a4>] (kernfs_fop_write+0xfc/0x1e4)
    [<c02f97a4>] (kernfs_fop_write) from [<c027b198>] (__vfs_write+0x2c/0x140)
    [<c027b198>] (__vfs_write) from [<c027b418>] (vfs_write+0xa4/0x160)
    [<c027b418>] (vfs_write) from [<c027b5d8>] (ksys_write+0x40/0x8c)
    [<c027b5d8>] (ksys_write) from [<c0101000>] (ret_fast_syscall+0x0/0x28)
    
    Add PLAT_S3C24XX, ARCH_S3C64XX and ARCH_S5PV210 dependencies to
    SAMSUNG_PM_CHECK config option to hide it on Exynos platforms.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Signed-off-by: Krzysztof Kozlowski <krzk@kernel.org>

commit 42387d8e4aefffe928e1a4ec99c45e6e2c4d2167
Author: Lyude Paul <lyude@redhat.com>
Date:   Wed Aug 15 15:00:15 2018 -0400

    drm/nouveau: Fix deadlocks in nouveau_connector_detect()
    
    commit 3e1a12754d4df5804bfca5dedf09d2ba291bdc2a upstream.
    
    When we disable hotplugging on the GPU, we need to be able to
    synchronize with each connector's hotplug interrupt handler before the
    interrupt is finally disabled. This can be a problem however, since
    nouveau_connector_detect() currently grabs a runtime power reference
    when handling connector probing. This will deadlock the runtime suspend
    handler like so:
    
    [  861.480896] INFO: task kworker/0:2:61 blocked for more than 120 seconds.
    [  861.483290]       Tainted: G           O      4.18.0-rc6Lyude-Test+ #1
    [  861.485158] "echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
    [  861.486332] kworker/0:2     D    0    61      2 0x80000000
    [  861.487044] Workqueue: events nouveau_display_hpd_work [nouveau]
    [  861.487737] Call Trace:
    [  861.488394]  __schedule+0x322/0xaf0
    [  861.489070]  schedule+0x33/0x90
    [  861.489744]  rpm_resume+0x19c/0x850
    [  861.490392]  ? finish_wait+0x90/0x90
    [  861.491068]  __pm_runtime_resume+0x4e/0x90
    [  861.491753]  nouveau_display_hpd_work+0x22/0x60 [nouveau]
    [  861.492416]  process_one_work+0x231/0x620
    [  861.493068]  worker_thread+0x44/0x3a0
    [  861.493722]  kthread+0x12b/0x150
    [  861.494342]  ? wq_pool_ids_show+0x140/0x140
    [  861.494991]  ? kthread_create_worker_on_cpu+0x70/0x70
    [  861.495648]  ret_from_fork+0x3a/0x50
    [  861.496304] INFO: task kworker/6:2:320 blocked for more than 120 seconds.
    [  861.496968]       Tainted: G           O      4.18.0-rc6Lyude-Test+ #1
    [  861.497654] "echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
    [  861.498341] kworker/6:2     D    0   320      2 0x80000080
    [  861.499045] Workqueue: pm pm_runtime_work
    [  861.499739] Call Trace:
    [  861.500428]  __schedule+0x322/0xaf0
    [  861.501134]  ? wait_for_completion+0x104/0x190
    [  861.501851]  schedule+0x33/0x90
    [  861.502564]  schedule_timeout+0x3a5/0x590
    [  861.503284]  ? mark_held_locks+0x58/0x80
    [  861.503988]  ? _raw_spin_unlock_irq+0x2c/0x40
    [  861.504710]  ? wait_for_completion+0x104/0x190
    [  861.505417]  ? trace_hardirqs_on_caller+0xf4/0x190
    [  861.506136]  ? wait_for_completion+0x104/0x190
    [  861.506845]  wait_for_completion+0x12c/0x190
    [  861.507555]  ? wake_up_q+0x80/0x80
    [  861.508268]  flush_work+0x1c9/0x280
    [  861.508990]  ? flush_workqueue_prep_pwqs+0x1b0/0x1b0
    [  861.509735]  nvif_notify_put+0xb1/0xc0 [nouveau]
    [  861.510482]  nouveau_display_fini+0xbd/0x170 [nouveau]
    [  861.511241]  nouveau_display_suspend+0x67/0x120 [nouveau]
    [  861.511969]  nouveau_do_suspend+0x5e/0x2d0 [nouveau]
    [  861.512715]  nouveau_pmops_runtime_suspend+0x47/0xb0 [nouveau]
    [  861.513435]  pci_pm_runtime_suspend+0x6b/0x180
    [  861.514165]  ? pci_has_legacy_pm_support+0x70/0x70
    [  861.514897]  __rpm_callback+0x7a/0x1d0
    [  861.515618]  ? pci_has_legacy_pm_support+0x70/0x70
    [  861.516313]  rpm_callback+0x24/0x80
    [  861.517027]  ? pci_has_legacy_pm_support+0x70/0x70
    [  861.517741]  rpm_suspend+0x142/0x6b0
    [  861.518449]  pm_runtime_work+0x97/0xc0
    [  861.519144]  process_one_work+0x231/0x620
    [  861.519831]  worker_thread+0x44/0x3a0
    [  861.520522]  kthread+0x12b/0x150
    [  861.521220]  ? wq_pool_ids_show+0x140/0x140
    [  861.521925]  ? kthread_create_worker_on_cpu+0x70/0x70
    [  861.522622]  ret_from_fork+0x3a/0x50
    [  861.523299] INFO: task kworker/6:0:1329 blocked for more than 120 seconds.
    [  861.523977]       Tainted: G           O      4.18.0-rc6Lyude-Test+ #1
    [  861.524644] "echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
    [  861.525349] kworker/6:0     D    0  1329      2 0x80000000
    [  861.526073] Workqueue: events nvif_notify_work [nouveau]
    [  861.526751] Call Trace:
    [  861.527411]  __schedule+0x322/0xaf0
    [  861.528089]  schedule+0x33/0x90
    [  861.528758]  rpm_resume+0x19c/0x850
    [  861.529399]  ? finish_wait+0x90/0x90
    [  861.530073]  __pm_runtime_resume+0x4e/0x90
    [  861.530798]  nouveau_connector_detect+0x7e/0x510 [nouveau]
    [  861.531459]  ? ww_mutex_lock+0x47/0x80
    [  861.532097]  ? ww_mutex_lock+0x47/0x80
    [  861.532819]  ? drm_modeset_lock+0x88/0x130 [drm]
    [  861.533481]  drm_helper_probe_detect_ctx+0xa0/0x100 [drm_kms_helper]
    [  861.534127]  drm_helper_hpd_irq_event+0xa4/0x120 [drm_kms_helper]
    [  861.534940]  nouveau_connector_hotplug+0x98/0x120 [nouveau]
    [  861.535556]  nvif_notify_work+0x2d/0xb0 [nouveau]
    [  861.536221]  process_one_work+0x231/0x620
    [  861.536994]  worker_thread+0x44/0x3a0
    [  861.537757]  kthread+0x12b/0x150
    [  861.538463]  ? wq_pool_ids_show+0x140/0x140
    [  861.539102]  ? kthread_create_worker_on_cpu+0x70/0x70
    [  861.539815]  ret_from_fork+0x3a/0x50
    [  861.540521]
                   Showing all locks held in the system:
    [  861.541696] 2 locks held by kworker/0:2/61:
    [  861.542406]  #0: 000000002dbf8af5 ((wq_completion)"events"){+.+.}, at: process_one_work+0x1b3/0x620
    [  861.543071]  #1: 0000000076868126 ((work_completion)(&drm->hpd_work)){+.+.}, at: process_one_work+0x1b3/0x620
    [  861.543814] 1 lock held by khungtaskd/64:
    [  861.544535]  #0: 0000000059db4b53 (rcu_read_lock){....}, at: debug_show_all_locks+0x23/0x185
    [  861.545160] 3 locks held by kworker/6:2/320:
    [  861.545896]  #0: 00000000d9e1bc59 ((wq_completion)"pm"){+.+.}, at: process_one_work+0x1b3/0x620
    [  861.546702]  #1: 00000000c9f92d84 ((work_completion)(&dev->power.work)){+.+.}, at: process_one_work+0x1b3/0x620
    [  861.547443]  #2: 000000004afc5de1 (drm_connector_list_iter){.+.+}, at: nouveau_display_fini+0x96/0x170 [nouveau]
    [  861.548146] 1 lock held by dmesg/983:
    [  861.548889] 2 locks held by zsh/1250:
    [  861.549605]  #0: 00000000348e3cf6 (&tty->ldisc_sem){++++}, at: ldsem_down_read+0x37/0x40
    [  861.550393]  #1: 000000007009a7a8 (&ldata->atomic_read_lock){+.+.}, at: n_tty_read+0xc1/0x870
    [  861.551122] 6 locks held by kworker/6:0/1329:
    [  861.551957]  #0: 000000002dbf8af5 ((wq_completion)"events"){+.+.}, at: process_one_work+0x1b3/0x620
    [  861.552765]  #1: 00000000ddb499ad ((work_completion)(&notify->work)#2){+.+.}, at: process_one_work+0x1b3/0x620
    [  861.553582]  #2: 000000006e013cbe (&dev->mode_config.mutex){+.+.}, at: drm_helper_hpd_irq_event+0x6c/0x120 [drm_kms_helper]
    [  861.554357]  #3: 000000004afc5de1 (drm_connector_list_iter){.+.+}, at: drm_helper_hpd_irq_event+0x78/0x120 [drm_kms_helper]
    [  861.555227]  #4: 0000000044f294d9 (crtc_ww_class_acquire){+.+.}, at: drm_helper_probe_detect_ctx+0x3d/0x100 [drm_kms_helper]
    [  861.556133]  #5: 00000000db193642 (crtc_ww_class_mutex){+.+.}, at: drm_modeset_lock+0x4b/0x130 [drm]
    
    [  861.557864] =============================================
    
    [  861.559507] NMI backtrace for cpu 2
    [  861.560363] CPU: 2 PID: 64 Comm: khungtaskd Tainted: G           O      4.18.0-rc6Lyude-Test+ #1
    [  861.561197] Hardware name: LENOVO 20EQS64N0B/20EQS64N0B, BIOS N1EET78W (1.51 ) 05/18/2018
    [  861.561948] Call Trace:
    [  861.562757]  dump_stack+0x8e/0xd3
    [  861.563516]  nmi_cpu_backtrace.cold.3+0x14/0x5a
    [  861.564269]  ? lapic_can_unplug_cpu.cold.27+0x42/0x42
    [  861.565029]  nmi_trigger_cpumask_backtrace+0xa1/0xae
    [  861.565789]  arch_trigger_cpumask_backtrace+0x19/0x20
    [  861.566558]  watchdog+0x316/0x580
    [  861.567355]  kthread+0x12b/0x150
    [  861.568114]  ? reset_hung_task_detector+0x20/0x20
    [  861.568863]  ? kthread_create_worker_on_cpu+0x70/0x70
    [  861.569598]  ret_from_fork+0x3a/0x50
    [  861.570370] Sending NMI from CPU 2 to CPUs 0-1,3-7:
    [  861.571426] NMI backtrace for cpu 6 skipped: idling at intel_idle+0x7f/0x120
    [  861.571429] NMI backtrace for cpu 7 skipped: idling at intel_idle+0x7f/0x120
    [  861.571432] NMI backtrace for cpu 3 skipped: idling at intel_idle+0x7f/0x120
    [  861.571464] NMI backtrace for cpu 5 skipped: idling at intel_idle+0x7f/0x120
    [  861.571467] NMI backtrace for cpu 0 skipped: idling at intel_idle+0x7f/0x120
    [  861.571469] NMI backtrace for cpu 4 skipped: idling at intel_idle+0x7f/0x120
    [  861.571472] NMI backtrace for cpu 1 skipped: idling at intel_idle+0x7f/0x120
    [  861.572428] Kernel panic - not syncing: hung_task: blocked tasks
    
    So: fix this by making it so that normal hotplug handling /only/ happens
    so long as the GPU is currently awake without any pending runtime PM
    requests. In the event that a hotplug occurs while the device is
    suspending or resuming, we can simply defer our response until the GPU
    is fully runtime resumed again.
    
    Changes since v4:
    - Use a new trick I came up with using pm_runtime_get() instead of the
      hackish junk we had before
    
    Signed-off-by: Lyude Paul <lyude@redhat.com>
    Reviewed-by: Karol Herbst <kherbst@redhat.com>
    Acked-by: Daniel Vetter <daniel@ffwll.ch>
    Cc: stable@vger.kernel.org
    Cc: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 9c7443a7aa646327acbaa02d16e7f7858e4e886c
Author: Lyude Paul <lyude@redhat.com>
Date:   Wed Aug 15 15:00:13 2018 -0400

    drm/nouveau/drm/nouveau: Fix deadlock with fb_helper with async RPM requests
    
    commit 7fec8f5379fb6eddabc0aaef6d2304c366808f97 upstream.
    
    Currently, nouveau uses the generic drm_fb_helper_output_poll_changed()
    function provided by DRM as it's output_poll_changed callback.
    Unfortunately however, this function doesn't grab runtime PM references
    early enough and even if it did-we can't block waiting for the device to
    resume in output_poll_changed() since it's very likely that we'll need
    to grab the fb_helper lock at some point during the runtime resume
    process. This currently results in deadlocking like so:
    
    [  246.669625] INFO: task kworker/4:0:37 blocked for more than 120 seconds.
    [  246.673398]       Not tainted 4.18.0-rc5Lyude-Test+ #2
    [  246.675271] "echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
    [  246.676527] kworker/4:0     D    0    37      2 0x80000000
    [  246.677580] Workqueue: events output_poll_execute [drm_kms_helper]
    [  246.678704] Call Trace:
    [  246.679753]  __schedule+0x322/0xaf0
    [  246.680916]  schedule+0x33/0x90
    [  246.681924]  schedule_preempt_disabled+0x15/0x20
    [  246.683023]  __mutex_lock+0x569/0x9a0
    [  246.684035]  ? kobject_uevent_env+0x117/0x7b0
    [  246.685132]  ? drm_fb_helper_hotplug_event.part.28+0x20/0xb0 [drm_kms_helper]
    [  246.686179]  mutex_lock_nested+0x1b/0x20
    [  246.687278]  ? mutex_lock_nested+0x1b/0x20
    [  246.688307]  drm_fb_helper_hotplug_event.part.28+0x20/0xb0 [drm_kms_helper]
    [  246.689420]  drm_fb_helper_output_poll_changed+0x23/0x30 [drm_kms_helper]
    [  246.690462]  drm_kms_helper_hotplug_event+0x2a/0x30 [drm_kms_helper]
    [  246.691570]  output_poll_execute+0x198/0x1c0 [drm_kms_helper]
    [  246.692611]  process_one_work+0x231/0x620
    [  246.693725]  worker_thread+0x214/0x3a0
    [  246.694756]  kthread+0x12b/0x150
    [  246.695856]  ? wq_pool_ids_show+0x140/0x140
    [  246.696888]  ? kthread_create_worker_on_cpu+0x70/0x70
    [  246.697998]  ret_from_fork+0x3a/0x50
    [  246.699034] INFO: task kworker/0:1:60 blocked for more than 120 seconds.
    [  246.700153]       Not tainted 4.18.0-rc5Lyude-Test+ #2
    [  246.701182] "echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
    [  246.702278] kworker/0:1     D    0    60      2 0x80000000
    [  246.703293] Workqueue: pm pm_runtime_work
    [  246.704393] Call Trace:
    [  246.705403]  __schedule+0x322/0xaf0
    [  246.706439]  ? wait_for_completion+0x104/0x190
    [  246.707393]  schedule+0x33/0x90
    [  246.708375]  schedule_timeout+0x3a5/0x590
    [  246.709289]  ? mark_held_locks+0x58/0x80
    [  246.710208]  ? _raw_spin_unlock_irq+0x2c/0x40
    [  246.711222]  ? wait_for_completion+0x104/0x190
    [  246.712134]  ? trace_hardirqs_on_caller+0xf4/0x190
    [  246.713094]  ? wait_for_completion+0x104/0x190
    [  246.713964]  wait_for_completion+0x12c/0x190
    [  246.714895]  ? wake_up_q+0x80/0x80
    [  246.715727]  ? get_work_pool+0x90/0x90
    [  246.716649]  flush_work+0x1c9/0x280
    [  246.717483]  ? flush_workqueue_prep_pwqs+0x1b0/0x1b0
    [  246.718442]  __cancel_work_timer+0x146/0x1d0
    [  246.719247]  cancel_delayed_work_sync+0x13/0x20
    [  246.720043]  drm_kms_helper_poll_disable+0x1f/0x30 [drm_kms_helper]
    [  246.721123]  nouveau_pmops_runtime_suspend+0x3d/0xb0 [nouveau]
    [  246.721897]  pci_pm_runtime_suspend+0x6b/0x190
    [  246.722825]  ? pci_has_legacy_pm_support+0x70/0x70
    [  246.723737]  __rpm_callback+0x7a/0x1d0
    [  246.724721]  ? pci_has_legacy_pm_support+0x70/0x70
    [  246.725607]  rpm_callback+0x24/0x80
    [  246.726553]  ? pci_has_legacy_pm_support+0x70/0x70
    [  246.727376]  rpm_suspend+0x142/0x6b0
    [  246.728185]  pm_runtime_work+0x97/0xc0
    [  246.728938]  process_one_work+0x231/0x620
    [  246.729796]  worker_thread+0x44/0x3a0
    [  246.730614]  kthread+0x12b/0x150
    [  246.731395]  ? wq_pool_ids_show+0x140/0x140
    [  246.732202]  ? kthread_create_worker_on_cpu+0x70/0x70
    [  246.732878]  ret_from_fork+0x3a/0x50
    [  246.733768] INFO: task kworker/4:2:422 blocked for more than 120 seconds.
    [  246.734587]       Not tainted 4.18.0-rc5Lyude-Test+ #2
    [  246.735393] "echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
    [  246.736113] kworker/4:2     D    0   422      2 0x80000080
    [  246.736789] Workqueue: events_long drm_dp_mst_link_probe_work [drm_kms_helper]
    [  246.737665] Call Trace:
    [  246.738490]  __schedule+0x322/0xaf0
    [  246.739250]  schedule+0x33/0x90
    [  246.739908]  rpm_resume+0x19c/0x850
    [  246.740750]  ? finish_wait+0x90/0x90
    [  246.741541]  __pm_runtime_resume+0x4e/0x90
    [  246.742370]  nv50_disp_atomic_commit+0x31/0x210 [nouveau]
    [  246.743124]  drm_atomic_commit+0x4a/0x50 [drm]
    [  246.743775]  restore_fbdev_mode_atomic+0x1c8/0x240 [drm_kms_helper]
    [  246.744603]  restore_fbdev_mode+0x31/0x140 [drm_kms_helper]
    [  246.745373]  drm_fb_helper_restore_fbdev_mode_unlocked+0x54/0xb0 [drm_kms_helper]
    [  246.746220]  drm_fb_helper_set_par+0x2d/0x50 [drm_kms_helper]
    [  246.746884]  drm_fb_helper_hotplug_event.part.28+0x96/0xb0 [drm_kms_helper]
    [  246.747675]  drm_fb_helper_output_poll_changed+0x23/0x30 [drm_kms_helper]
    [  246.748544]  drm_kms_helper_hotplug_event+0x2a/0x30 [drm_kms_helper]
    [  246.749439]  nv50_mstm_hotplug+0x15/0x20 [nouveau]
    [  246.750111]  drm_dp_send_link_address+0x177/0x1c0 [drm_kms_helper]
    [  246.750764]  drm_dp_check_and_send_link_address+0xa8/0xd0 [drm_kms_helper]
    [  246.751602]  drm_dp_mst_link_probe_work+0x51/0x90 [drm_kms_helper]
    [  246.752314]  process_one_work+0x231/0x620
    [  246.752979]  worker_thread+0x44/0x3a0
    [  246.753838]  kthread+0x12b/0x150
    [  246.754619]  ? wq_pool_ids_show+0x140/0x140
    [  246.755386]  ? kthread_create_worker_on_cpu+0x70/0x70
    [  246.756162]  ret_from_fork+0x3a/0x50
    [  246.756847]
               Showing all locks held in the system:
    [  246.758261] 3 locks held by kworker/4:0/37:
    [  246.759016]  #0: 00000000f8df4d2d ((wq_completion)"events"){+.+.}, at: process_one_work+0x1b3/0x620
    [  246.759856]  #1: 00000000e6065461 ((work_completion)(&(&dev->mode_config.output_poll_work)->work)){+.+.}, at: process_one_work+0x1b3/0x620
    [  246.760670]  #2: 00000000cb66735f (&helper->lock){+.+.}, at: drm_fb_helper_hotplug_event.part.28+0x20/0xb0 [drm_kms_helper]
    [  246.761516] 2 locks held by kworker/0:1/60:
    [  246.762274]  #0: 00000000fff6be0f ((wq_completion)"pm"){+.+.}, at: process_one_work+0x1b3/0x620
    [  246.762982]  #1: 000000005ab44fb4 ((work_completion)(&dev->power.work)){+.+.}, at: process_one_work+0x1b3/0x620
    [  246.763890] 1 lock held by khungtaskd/64:
    [  246.764664]  #0: 000000008cb8b5c3 (rcu_read_lock){....}, at: debug_show_all_locks+0x23/0x185
    [  246.765588] 5 locks held by kworker/4:2/422:
    [  246.766440]  #0: 00000000232f0959 ((wq_completion)"events_long"){+.+.}, at: process_one_work+0x1b3/0x620
    [  246.767390]  #1: 00000000bb59b134 ((work_completion)(&mgr->work)){+.+.}, at: process_one_work+0x1b3/0x620
    [  246.768154]  #2: 00000000cb66735f (&helper->lock){+.+.}, at: drm_fb_helper_restore_fbdev_mode_unlocked+0x4c/0xb0 [drm_kms_helper]
    [  246.768966]  #3: 000000004c8f0b6b (crtc_ww_class_acquire){+.+.}, at: restore_fbdev_mode_atomic+0x4b/0x240 [drm_kms_helper]
    [  246.769921]  #4: 000000004c34a296 (crtc_ww_class_mutex){+.+.}, at: drm_modeset_backoff+0x8a/0x1b0 [drm]
    [  246.770839] 1 lock held by dmesg/1038:
    [  246.771739] 2 locks held by zsh/1172:
    [  246.772650]  #0: 00000000836d0438 (&tty->ldisc_sem){++++}, at: ldsem_down_read+0x37/0x40
    [  246.773680]  #1: 000000001f4f4d48 (&ldata->atomic_read_lock){+.+.}, at: n_tty_read+0xc1/0x870
    
    [  246.775522] =============================================
    
    After trying dozens of different solutions, I found one very simple one
    that should also have the benefit of preventing us from having to fight
    locking for the rest of our lives. So, we work around these deadlocks by
    deferring all fbcon hotplug events that happen after the runtime suspend
    process starts until after the device is resumed again.
    
    Changes since v7:
     - Fixup commit message - Daniel Vetter
    
    Changes since v6:
     - Remove unused nouveau_fbcon_hotplugged_in_suspend() - Ilia
    
    Changes since v5:
     - Come up with the (hopefully final) solution for solving this dumb
       problem, one that is a lot less likely to cause issues with locking in
       the future. This should work around all deadlock conditions with fbcon
       brought up thus far.
    
    Changes since v4:
     - Add nouveau_fbcon_hotplugged_in_suspend() to workaround deadlock
       condition that Lukas described
     - Just move all of this out of drm_fb_helper. It seems that other DRM
       drivers have already figured out other workarounds for this. If other
       drivers do end up needing this in the future, we can just move this
       back into drm_fb_helper again.
    
    Changes since v3:
    - Actually check if fb_helper is NULL in both new helpers
    - Actually check drm_fbdev_emulation in both new helpers
    - Don't fire off a fb_helper hotplug unconditionally; only do it if
      the following conditions are true (as otherwise, calling this in the
      wrong spot will cause Bad Things to happen):
      - fb_helper hotplug handling was actually inhibited previously
      - fb_helper actually has a delayed hotplug pending
      - fb_helper is actually bound
      - fb_helper is actually initialized
    - Add __must_check to drm_fb_helper_suspend_hotplug(). There's no
      situation where a driver would actually want to use this without
      checking the return value, so enforce that
    - Rewrite and clarify the documentation for both helpers.
    - Make sure to return true in the drm_fb_helper_suspend_hotplug() stub
      that's provided in drm_fb_helper.h when CONFIG_DRM_FBDEV_EMULATION
      isn't enabled
    - Actually grab the toplevel fb_helper lock in
      drm_fb_helper_resume_hotplug(), since it's possible other activity
      (such as a hotplug) could be going on at the same time the driver
      calls drm_fb_helper_resume_hotplug(). We need this to check whether or
      not drm_fb_helper_hotplug_event() needs to be called anyway
    
    Signed-off-by: Lyude Paul <lyude@redhat.com>
    Reviewed-by: Karol Herbst <kherbst@redhat.com>
    Acked-by: Daniel Vetter <daniel@ffwll.ch>
    Cc: stable@vger.kernel.org
    Cc: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 86393a7e3315aa0a57e66857880a8536bab070c8
Author: Lyude Paul <lyude@redhat.com>
Date:   Wed Aug 15 15:00:15 2018 -0400

    drm/nouveau: Fix deadlocks in nouveau_connector_detect()
    
    commit 3e1a12754d4df5804bfca5dedf09d2ba291bdc2a upstream.
    
    When we disable hotplugging on the GPU, we need to be able to
    synchronize with each connector's hotplug interrupt handler before the
    interrupt is finally disabled. This can be a problem however, since
    nouveau_connector_detect() currently grabs a runtime power reference
    when handling connector probing. This will deadlock the runtime suspend
    handler like so:
    
    [  861.480896] INFO: task kworker/0:2:61 blocked for more than 120 seconds.
    [  861.483290]       Tainted: G           O      4.18.0-rc6Lyude-Test+ #1
    [  861.485158] "echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
    [  861.486332] kworker/0:2     D    0    61      2 0x80000000
    [  861.487044] Workqueue: events nouveau_display_hpd_work [nouveau]
    [  861.487737] Call Trace:
    [  861.488394]  __schedule+0x322/0xaf0
    [  861.489070]  schedule+0x33/0x90
    [  861.489744]  rpm_resume+0x19c/0x850
    [  861.490392]  ? finish_wait+0x90/0x90
    [  861.491068]  __pm_runtime_resume+0x4e/0x90
    [  861.491753]  nouveau_display_hpd_work+0x22/0x60 [nouveau]
    [  861.492416]  process_one_work+0x231/0x620
    [  861.493068]  worker_thread+0x44/0x3a0
    [  861.493722]  kthread+0x12b/0x150
    [  861.494342]  ? wq_pool_ids_show+0x140/0x140
    [  861.494991]  ? kthread_create_worker_on_cpu+0x70/0x70
    [  861.495648]  ret_from_fork+0x3a/0x50
    [  861.496304] INFO: task kworker/6:2:320 blocked for more than 120 seconds.
    [  861.496968]       Tainted: G           O      4.18.0-rc6Lyude-Test+ #1
    [  861.497654] "echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
    [  861.498341] kworker/6:2     D    0   320      2 0x80000080
    [  861.499045] Workqueue: pm pm_runtime_work
    [  861.499739] Call Trace:
    [  861.500428]  __schedule+0x322/0xaf0
    [  861.501134]  ? wait_for_completion+0x104/0x190
    [  861.501851]  schedule+0x33/0x90
    [  861.502564]  schedule_timeout+0x3a5/0x590
    [  861.503284]  ? mark_held_locks+0x58/0x80
    [  861.503988]  ? _raw_spin_unlock_irq+0x2c/0x40
    [  861.504710]  ? wait_for_completion+0x104/0x190
    [  861.505417]  ? trace_hardirqs_on_caller+0xf4/0x190
    [  861.506136]  ? wait_for_completion+0x104/0x190
    [  861.506845]  wait_for_completion+0x12c/0x190
    [  861.507555]  ? wake_up_q+0x80/0x80
    [  861.508268]  flush_work+0x1c9/0x280
    [  861.508990]  ? flush_workqueue_prep_pwqs+0x1b0/0x1b0
    [  861.509735]  nvif_notify_put+0xb1/0xc0 [nouveau]
    [  861.510482]  nouveau_display_fini+0xbd/0x170 [nouveau]
    [  861.511241]  nouveau_display_suspend+0x67/0x120 [nouveau]
    [  861.511969]  nouveau_do_suspend+0x5e/0x2d0 [nouveau]
    [  861.512715]  nouveau_pmops_runtime_suspend+0x47/0xb0 [nouveau]
    [  861.513435]  pci_pm_runtime_suspend+0x6b/0x180
    [  861.514165]  ? pci_has_legacy_pm_support+0x70/0x70
    [  861.514897]  __rpm_callback+0x7a/0x1d0
    [  861.515618]  ? pci_has_legacy_pm_support+0x70/0x70
    [  861.516313]  rpm_callback+0x24/0x80
    [  861.517027]  ? pci_has_legacy_pm_support+0x70/0x70
    [  861.517741]  rpm_suspend+0x142/0x6b0
    [  861.518449]  pm_runtime_work+0x97/0xc0
    [  861.519144]  process_one_work+0x231/0x620
    [  861.519831]  worker_thread+0x44/0x3a0
    [  861.520522]  kthread+0x12b/0x150
    [  861.521220]  ? wq_pool_ids_show+0x140/0x140
    [  861.521925]  ? kthread_create_worker_on_cpu+0x70/0x70
    [  861.522622]  ret_from_fork+0x3a/0x50
    [  861.523299] INFO: task kworker/6:0:1329 blocked for more than 120 seconds.
    [  861.523977]       Tainted: G           O      4.18.0-rc6Lyude-Test+ #1
    [  861.524644] "echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
    [  861.525349] kworker/6:0     D    0  1329      2 0x80000000
    [  861.526073] Workqueue: events nvif_notify_work [nouveau]
    [  861.526751] Call Trace:
    [  861.527411]  __schedule+0x322/0xaf0
    [  861.528089]  schedule+0x33/0x90
    [  861.528758]  rpm_resume+0x19c/0x850
    [  861.529399]  ? finish_wait+0x90/0x90
    [  861.530073]  __pm_runtime_resume+0x4e/0x90
    [  861.530798]  nouveau_connector_detect+0x7e/0x510 [nouveau]
    [  861.531459]  ? ww_mutex_lock+0x47/0x80
    [  861.532097]  ? ww_mutex_lock+0x47/0x80
    [  861.532819]  ? drm_modeset_lock+0x88/0x130 [drm]
    [  861.533481]  drm_helper_probe_detect_ctx+0xa0/0x100 [drm_kms_helper]
    [  861.534127]  drm_helper_hpd_irq_event+0xa4/0x120 [drm_kms_helper]
    [  861.534940]  nouveau_connector_hotplug+0x98/0x120 [nouveau]
    [  861.535556]  nvif_notify_work+0x2d/0xb0 [nouveau]
    [  861.536221]  process_one_work+0x231/0x620
    [  861.536994]  worker_thread+0x44/0x3a0
    [  861.537757]  kthread+0x12b/0x150
    [  861.538463]  ? wq_pool_ids_show+0x140/0x140
    [  861.539102]  ? kthread_create_worker_on_cpu+0x70/0x70
    [  861.539815]  ret_from_fork+0x3a/0x50
    [  861.540521]
                   Showing all locks held in the system:
    [  861.541696] 2 locks held by kworker/0:2/61:
    [  861.542406]  #0: 000000002dbf8af5 ((wq_completion)"events"){+.+.}, at: process_one_work+0x1b3/0x620
    [  861.543071]  #1: 0000000076868126 ((work_completion)(&drm->hpd_work)){+.+.}, at: process_one_work+0x1b3/0x620
    [  861.543814] 1 lock held by khungtaskd/64:
    [  861.544535]  #0: 0000000059db4b53 (rcu_read_lock){....}, at: debug_show_all_locks+0x23/0x185
    [  861.545160] 3 locks held by kworker/6:2/320:
    [  861.545896]  #0: 00000000d9e1bc59 ((wq_completion)"pm"){+.+.}, at: process_one_work+0x1b3/0x620
    [  861.546702]  #1: 00000000c9f92d84 ((work_completion)(&dev->power.work)){+.+.}, at: process_one_work+0x1b3/0x620
    [  861.547443]  #2: 000000004afc5de1 (drm_connector_list_iter){.+.+}, at: nouveau_display_fini+0x96/0x170 [nouveau]
    [  861.548146] 1 lock held by dmesg/983:
    [  861.548889] 2 locks held by zsh/1250:
    [  861.549605]  #0: 00000000348e3cf6 (&tty->ldisc_sem){++++}, at: ldsem_down_read+0x37/0x40
    [  861.550393]  #1: 000000007009a7a8 (&ldata->atomic_read_lock){+.+.}, at: n_tty_read+0xc1/0x870
    [  861.551122] 6 locks held by kworker/6:0/1329:
    [  861.551957]  #0: 000000002dbf8af5 ((wq_completion)"events"){+.+.}, at: process_one_work+0x1b3/0x620
    [  861.552765]  #1: 00000000ddb499ad ((work_completion)(&notify->work)#2){+.+.}, at: process_one_work+0x1b3/0x620
    [  861.553582]  #2: 000000006e013cbe (&dev->mode_config.mutex){+.+.}, at: drm_helper_hpd_irq_event+0x6c/0x120 [drm_kms_helper]
    [  861.554357]  #3: 000000004afc5de1 (drm_connector_list_iter){.+.+}, at: drm_helper_hpd_irq_event+0x78/0x120 [drm_kms_helper]
    [  861.555227]  #4: 0000000044f294d9 (crtc_ww_class_acquire){+.+.}, at: drm_helper_probe_detect_ctx+0x3d/0x100 [drm_kms_helper]
    [  861.556133]  #5: 00000000db193642 (crtc_ww_class_mutex){+.+.}, at: drm_modeset_lock+0x4b/0x130 [drm]
    
    [  861.557864] =============================================
    
    [  861.559507] NMI backtrace for cpu 2
    [  861.560363] CPU: 2 PID: 64 Comm: khungtaskd Tainted: G           O      4.18.0-rc6Lyude-Test+ #1
    [  861.561197] Hardware name: LENOVO 20EQS64N0B/20EQS64N0B, BIOS N1EET78W (1.51 ) 05/18/2018
    [  861.561948] Call Trace:
    [  861.562757]  dump_stack+0x8e/0xd3
    [  861.563516]  nmi_cpu_backtrace.cold.3+0x14/0x5a
    [  861.564269]  ? lapic_can_unplug_cpu.cold.27+0x42/0x42
    [  861.565029]  nmi_trigger_cpumask_backtrace+0xa1/0xae
    [  861.565789]  arch_trigger_cpumask_backtrace+0x19/0x20
    [  861.566558]  watchdog+0x316/0x580
    [  861.567355]  kthread+0x12b/0x150
    [  861.568114]  ? reset_hung_task_detector+0x20/0x20
    [  861.568863]  ? kthread_create_worker_on_cpu+0x70/0x70
    [  861.569598]  ret_from_fork+0x3a/0x50
    [  861.570370] Sending NMI from CPU 2 to CPUs 0-1,3-7:
    [  861.571426] NMI backtrace for cpu 6 skipped: idling at intel_idle+0x7f/0x120
    [  861.571429] NMI backtrace for cpu 7 skipped: idling at intel_idle+0x7f/0x120
    [  861.571432] NMI backtrace for cpu 3 skipped: idling at intel_idle+0x7f/0x120
    [  861.571464] NMI backtrace for cpu 5 skipped: idling at intel_idle+0x7f/0x120
    [  861.571467] NMI backtrace for cpu 0 skipped: idling at intel_idle+0x7f/0x120
    [  861.571469] NMI backtrace for cpu 4 skipped: idling at intel_idle+0x7f/0x120
    [  861.571472] NMI backtrace for cpu 1 skipped: idling at intel_idle+0x7f/0x120
    [  861.572428] Kernel panic - not syncing: hung_task: blocked tasks
    
    So: fix this by making it so that normal hotplug handling /only/ happens
    so long as the GPU is currently awake without any pending runtime PM
    requests. In the event that a hotplug occurs while the device is
    suspending or resuming, we can simply defer our response until the GPU
    is fully runtime resumed again.
    
    Changes since v4:
    - Use a new trick I came up with using pm_runtime_get() instead of the
      hackish junk we had before
    
    Signed-off-by: Lyude Paul <lyude@redhat.com>
    Reviewed-by: Karol Herbst <kherbst@redhat.com>
    Acked-by: Daniel Vetter <daniel@ffwll.ch>
    Cc: stable@vger.kernel.org
    Cc: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit e5d857d5f1fc0893a2efa46a7acdec1ef67363d7
Author: Tomas Winkler <tomas.winkler@intel.com>
Date:   Thu Jun 28 18:13:33 2018 +0300

    tpm: separate cmd_ready/go_idle from runtime_pm
    
    commit 627448e85c766587f6fdde1ea3886d6615081c77 upstream.
    
    Fix tpm ptt initialization error:
    tpm tpm0: A TPM error (378) occurred get tpm pcr allocation.
    
    We cannot use go_idle cmd_ready commands via runtime_pm handles
    as with the introduction of localities this is no longer an optional
    feature, while runtime pm can be not enabled.
    Though cmd_ready/go_idle provides a power saving, it's also a part of
    TPM2 protocol and should be called explicitly.
    This patch exposes cmd_read/go_idle via tpm class ops and removes
    runtime pm support as it is not used by any driver.
    
    When calling from nested context always use both flags:
    TPM_TRANSMIT_UNLOCKED and TPM_TRANSMIT_RAW. Both are needed to resolve
    tpm spaces and locality request recursive calls to tpm_transmit().
    TPM_TRANSMIT_RAW should never be used standalone as it will fail
    on double locking. While TPM_TRANSMIT_UNLOCKED standalone should be
    called from non-recursive locked contexts.
    
    New wrappers are added tpm_cmd_ready() and tpm_go_idle() to
    streamline tpm_try_transmit code.
    
    tpm_crb no longer needs own power saving functions and can drop using
    tpm_pm_suspend/resume.
    
    This patch cannot be really separated from the locality fix.
    Fixes: 888d867df441 (tpm: cmd_ready command can be issued only after granting locality)
    
    Cc: stable@vger.kernel.org
    Fixes: 888d867df441 (tpm: cmd_ready command can be issued only after granting locality)
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Tested-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
    Reviewed-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
    Signed-off-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit c73480910e9686a5c25155cb4d418d594b678196
Author: zhong jiang <zhongjiang@huawei.com>
Date:   Mon Sep 17 18:44:19 2018 +0800

    net: ethernet: Fix a unused function warning.
    
    Fix the following compile warning:
    
    drivers/net/ethernet/microchip/lan743x_main.c:2964:12: warning: lan743x_pm_suspend defined but not used [-Wunused-function]
     static int lan743x_pm_suspend(struct device *dev)
    drivers/net/ethernet/microchip/lan743x_main.c:2987:12: warning: lan743x_pm_resume defined but not used [-Wunused-function]
     static int lan743x_pm_resume(struct device *dev)
    
    Signed-off-by: zhong jiang <zhongjiang@huawei.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 3e1a12754d4df5804bfca5dedf09d2ba291bdc2a
Author: Lyude Paul <lyude@redhat.com>
Date:   Wed Aug 15 15:00:15 2018 -0400

    drm/nouveau: Fix deadlocks in nouveau_connector_detect()
    
    When we disable hotplugging on the GPU, we need to be able to
    synchronize with each connector's hotplug interrupt handler before the
    interrupt is finally disabled. This can be a problem however, since
    nouveau_connector_detect() currently grabs a runtime power reference
    when handling connector probing. This will deadlock the runtime suspend
    handler like so:
    
    [  861.480896] INFO: task kworker/0:2:61 blocked for more than 120 seconds.
    [  861.483290]       Tainted: G           O      4.18.0-rc6Lyude-Test+ #1
    [  861.485158] "echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
    [  861.486332] kworker/0:2     D    0    61      2 0x80000000
    [  861.487044] Workqueue: events nouveau_display_hpd_work [nouveau]
    [  861.487737] Call Trace:
    [  861.488394]  __schedule+0x322/0xaf0
    [  861.489070]  schedule+0x33/0x90
    [  861.489744]  rpm_resume+0x19c/0x850
    [  861.490392]  ? finish_wait+0x90/0x90
    [  861.491068]  __pm_runtime_resume+0x4e/0x90
    [  861.491753]  nouveau_display_hpd_work+0x22/0x60 [nouveau]
    [  861.492416]  process_one_work+0x231/0x620
    [  861.493068]  worker_thread+0x44/0x3a0
    [  861.493722]  kthread+0x12b/0x150
    [  861.494342]  ? wq_pool_ids_show+0x140/0x140
    [  861.494991]  ? kthread_create_worker_on_cpu+0x70/0x70
    [  861.495648]  ret_from_fork+0x3a/0x50
    [  861.496304] INFO: task kworker/6:2:320 blocked for more than 120 seconds.
    [  861.496968]       Tainted: G           O      4.18.0-rc6Lyude-Test+ #1
    [  861.497654] "echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
    [  861.498341] kworker/6:2     D    0   320      2 0x80000080
    [  861.499045] Workqueue: pm pm_runtime_work
    [  861.499739] Call Trace:
    [  861.500428]  __schedule+0x322/0xaf0
    [  861.501134]  ? wait_for_completion+0x104/0x190
    [  861.501851]  schedule+0x33/0x90
    [  861.502564]  schedule_timeout+0x3a5/0x590
    [  861.503284]  ? mark_held_locks+0x58/0x80
    [  861.503988]  ? _raw_spin_unlock_irq+0x2c/0x40
    [  861.504710]  ? wait_for_completion+0x104/0x190
    [  861.505417]  ? trace_hardirqs_on_caller+0xf4/0x190
    [  861.506136]  ? wait_for_completion+0x104/0x190
    [  861.506845]  wait_for_completion+0x12c/0x190
    [  861.507555]  ? wake_up_q+0x80/0x80
    [  861.508268]  flush_work+0x1c9/0x280
    [  861.508990]  ? flush_workqueue_prep_pwqs+0x1b0/0x1b0
    [  861.509735]  nvif_notify_put+0xb1/0xc0 [nouveau]
    [  861.510482]  nouveau_display_fini+0xbd/0x170 [nouveau]
    [  861.511241]  nouveau_display_suspend+0x67/0x120 [nouveau]
    [  861.511969]  nouveau_do_suspend+0x5e/0x2d0 [nouveau]
    [  861.512715]  nouveau_pmops_runtime_suspend+0x47/0xb0 [nouveau]
    [  861.513435]  pci_pm_runtime_suspend+0x6b/0x180
    [  861.514165]  ? pci_has_legacy_pm_support+0x70/0x70
    [  861.514897]  __rpm_callback+0x7a/0x1d0
    [  861.515618]  ? pci_has_legacy_pm_support+0x70/0x70
    [  861.516313]  rpm_callback+0x24/0x80
    [  861.517027]  ? pci_has_legacy_pm_support+0x70/0x70
    [  861.517741]  rpm_suspend+0x142/0x6b0
    [  861.518449]  pm_runtime_work+0x97/0xc0
    [  861.519144]  process_one_work+0x231/0x620
    [  861.519831]  worker_thread+0x44/0x3a0
    [  861.520522]  kthread+0x12b/0x150
    [  861.521220]  ? wq_pool_ids_show+0x140/0x140
    [  861.521925]  ? kthread_create_worker_on_cpu+0x70/0x70
    [  861.522622]  ret_from_fork+0x3a/0x50
    [  861.523299] INFO: task kworker/6:0:1329 blocked for more than 120 seconds.
    [  861.523977]       Tainted: G           O      4.18.0-rc6Lyude-Test+ #1
    [  861.524644] "echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
    [  861.525349] kworker/6:0     D    0  1329      2 0x80000000
    [  861.526073] Workqueue: events nvif_notify_work [nouveau]
    [  861.526751] Call Trace:
    [  861.527411]  __schedule+0x322/0xaf0
    [  861.528089]  schedule+0x33/0x90
    [  861.528758]  rpm_resume+0x19c/0x850
    [  861.529399]  ? finish_wait+0x90/0x90
    [  861.530073]  __pm_runtime_resume+0x4e/0x90
    [  861.530798]  nouveau_connector_detect+0x7e/0x510 [nouveau]
    [  861.531459]  ? ww_mutex_lock+0x47/0x80
    [  861.532097]  ? ww_mutex_lock+0x47/0x80
    [  861.532819]  ? drm_modeset_lock+0x88/0x130 [drm]
    [  861.533481]  drm_helper_probe_detect_ctx+0xa0/0x100 [drm_kms_helper]
    [  861.534127]  drm_helper_hpd_irq_event+0xa4/0x120 [drm_kms_helper]
    [  861.534940]  nouveau_connector_hotplug+0x98/0x120 [nouveau]
    [  861.535556]  nvif_notify_work+0x2d/0xb0 [nouveau]
    [  861.536221]  process_one_work+0x231/0x620
    [  861.536994]  worker_thread+0x44/0x3a0
    [  861.537757]  kthread+0x12b/0x150
    [  861.538463]  ? wq_pool_ids_show+0x140/0x140
    [  861.539102]  ? kthread_create_worker_on_cpu+0x70/0x70
    [  861.539815]  ret_from_fork+0x3a/0x50
    [  861.540521]
                   Showing all locks held in the system:
    [  861.541696] 2 locks held by kworker/0:2/61:
    [  861.542406]  #0: 000000002dbf8af5 ((wq_completion)"events"){+.+.}, at: process_one_work+0x1b3/0x620
    [  861.543071]  #1: 0000000076868126 ((work_completion)(&drm->hpd_work)){+.+.}, at: process_one_work+0x1b3/0x620
    [  861.543814] 1 lock held by khungtaskd/64:
    [  861.544535]  #0: 0000000059db4b53 (rcu_read_lock){....}, at: debug_show_all_locks+0x23/0x185
    [  861.545160] 3 locks held by kworker/6:2/320:
    [  861.545896]  #0: 00000000d9e1bc59 ((wq_completion)"pm"){+.+.}, at: process_one_work+0x1b3/0x620
    [  861.546702]  #1: 00000000c9f92d84 ((work_completion)(&dev->power.work)){+.+.}, at: process_one_work+0x1b3/0x620
    [  861.547443]  #2: 000000004afc5de1 (drm_connector_list_iter){.+.+}, at: nouveau_display_fini+0x96/0x170 [nouveau]
    [  861.548146] 1 lock held by dmesg/983:
    [  861.548889] 2 locks held by zsh/1250:
    [  861.549605]  #0: 00000000348e3cf6 (&tty->ldisc_sem){++++}, at: ldsem_down_read+0x37/0x40
    [  861.550393]  #1: 000000007009a7a8 (&ldata->atomic_read_lock){+.+.}, at: n_tty_read+0xc1/0x870
    [  861.551122] 6 locks held by kworker/6:0/1329:
    [  861.551957]  #0: 000000002dbf8af5 ((wq_completion)"events"){+.+.}, at: process_one_work+0x1b3/0x620
    [  861.552765]  #1: 00000000ddb499ad ((work_completion)(&notify->work)#2){+.+.}, at: process_one_work+0x1b3/0x620
    [  861.553582]  #2: 000000006e013cbe (&dev->mode_config.mutex){+.+.}, at: drm_helper_hpd_irq_event+0x6c/0x120 [drm_kms_helper]
    [  861.554357]  #3: 000000004afc5de1 (drm_connector_list_iter){.+.+}, at: drm_helper_hpd_irq_event+0x78/0x120 [drm_kms_helper]
    [  861.555227]  #4: 0000000044f294d9 (crtc_ww_class_acquire){+.+.}, at: drm_helper_probe_detect_ctx+0x3d/0x100 [drm_kms_helper]
    [  861.556133]  #5: 00000000db193642 (crtc_ww_class_mutex){+.+.}, at: drm_modeset_lock+0x4b/0x130 [drm]
    
    [  861.557864] =============================================
    
    [  861.559507] NMI backtrace for cpu 2
    [  861.560363] CPU: 2 PID: 64 Comm: khungtaskd Tainted: G           O      4.18.0-rc6Lyude-Test+ #1
    [  861.561197] Hardware name: LENOVO 20EQS64N0B/20EQS64N0B, BIOS N1EET78W (1.51 ) 05/18/2018
    [  861.561948] Call Trace:
    [  861.562757]  dump_stack+0x8e/0xd3
    [  861.563516]  nmi_cpu_backtrace.cold.3+0x14/0x5a
    [  861.564269]  ? lapic_can_unplug_cpu.cold.27+0x42/0x42
    [  861.565029]  nmi_trigger_cpumask_backtrace+0xa1/0xae
    [  861.565789]  arch_trigger_cpumask_backtrace+0x19/0x20
    [  861.566558]  watchdog+0x316/0x580
    [  861.567355]  kthread+0x12b/0x150
    [  861.568114]  ? reset_hung_task_detector+0x20/0x20
    [  861.568863]  ? kthread_create_worker_on_cpu+0x70/0x70
    [  861.569598]  ret_from_fork+0x3a/0x50
    [  861.570370] Sending NMI from CPU 2 to CPUs 0-1,3-7:
    [  861.571426] NMI backtrace for cpu 6 skipped: idling at intel_idle+0x7f/0x120
    [  861.571429] NMI backtrace for cpu 7 skipped: idling at intel_idle+0x7f/0x120
    [  861.571432] NMI backtrace for cpu 3 skipped: idling at intel_idle+0x7f/0x120
    [  861.571464] NMI backtrace for cpu 5 skipped: idling at intel_idle+0x7f/0x120
    [  861.571467] NMI backtrace for cpu 0 skipped: idling at intel_idle+0x7f/0x120
    [  861.571469] NMI backtrace for cpu 4 skipped: idling at intel_idle+0x7f/0x120
    [  861.571472] NMI backtrace for cpu 1 skipped: idling at intel_idle+0x7f/0x120
    [  861.572428] Kernel panic - not syncing: hung_task: blocked tasks
    
    So: fix this by making it so that normal hotplug handling /only/ happens
    so long as the GPU is currently awake without any pending runtime PM
    requests. In the event that a hotplug occurs while the device is
    suspending or resuming, we can simply defer our response until the GPU
    is fully runtime resumed again.
    
    Changes since v4:
    - Use a new trick I came up with using pm_runtime_get() instead of the
      hackish junk we had before
    
    Signed-off-by: Lyude Paul <lyude@redhat.com>
    Reviewed-by: Karol Herbst <kherbst@redhat.com>
    Acked-by: Daniel Vetter <daniel@ffwll.ch>
    Cc: stable@vger.kernel.org
    Cc: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

commit 7fec8f5379fb6eddabc0aaef6d2304c366808f97
Author: Lyude Paul <lyude@redhat.com>
Date:   Wed Aug 15 15:00:13 2018 -0400

    drm/nouveau/drm/nouveau: Fix deadlock with fb_helper with async RPM requests
    
    Currently, nouveau uses the generic drm_fb_helper_output_poll_changed()
    function provided by DRM as it's output_poll_changed callback.
    Unfortunately however, this function doesn't grab runtime PM references
    early enough and even if it did-we can't block waiting for the device to
    resume in output_poll_changed() since it's very likely that we'll need
    to grab the fb_helper lock at some point during the runtime resume
    process. This currently results in deadlocking like so:
    
    [  246.669625] INFO: task kworker/4:0:37 blocked for more than 120 seconds.
    [  246.673398]       Not tainted 4.18.0-rc5Lyude-Test+ #2
    [  246.675271] "echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
    [  246.676527] kworker/4:0     D    0    37      2 0x80000000
    [  246.677580] Workqueue: events output_poll_execute [drm_kms_helper]
    [  246.678704] Call Trace:
    [  246.679753]  __schedule+0x322/0xaf0
    [  246.680916]  schedule+0x33/0x90
    [  246.681924]  schedule_preempt_disabled+0x15/0x20
    [  246.683023]  __mutex_lock+0x569/0x9a0
    [  246.684035]  ? kobject_uevent_env+0x117/0x7b0
    [  246.685132]  ? drm_fb_helper_hotplug_event.part.28+0x20/0xb0 [drm_kms_helper]
    [  246.686179]  mutex_lock_nested+0x1b/0x20
    [  246.687278]  ? mutex_lock_nested+0x1b/0x20
    [  246.688307]  drm_fb_helper_hotplug_event.part.28+0x20/0xb0 [drm_kms_helper]
    [  246.689420]  drm_fb_helper_output_poll_changed+0x23/0x30 [drm_kms_helper]
    [  246.690462]  drm_kms_helper_hotplug_event+0x2a/0x30 [drm_kms_helper]
    [  246.691570]  output_poll_execute+0x198/0x1c0 [drm_kms_helper]
    [  246.692611]  process_one_work+0x231/0x620
    [  246.693725]  worker_thread+0x214/0x3a0
    [  246.694756]  kthread+0x12b/0x150
    [  246.695856]  ? wq_pool_ids_show+0x140/0x140
    [  246.696888]  ? kthread_create_worker_on_cpu+0x70/0x70
    [  246.697998]  ret_from_fork+0x3a/0x50
    [  246.699034] INFO: task kworker/0:1:60 blocked for more than 120 seconds.
    [  246.700153]       Not tainted 4.18.0-rc5Lyude-Test+ #2
    [  246.701182] "echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
    [  246.702278] kworker/0:1     D    0    60      2 0x80000000
    [  246.703293] Workqueue: pm pm_runtime_work
    [  246.704393] Call Trace:
    [  246.705403]  __schedule+0x322/0xaf0
    [  246.706439]  ? wait_for_completion+0x104/0x190
    [  246.707393]  schedule+0x33/0x90
    [  246.708375]  schedule_timeout+0x3a5/0x590
    [  246.709289]  ? mark_held_locks+0x58/0x80
    [  246.710208]  ? _raw_spin_unlock_irq+0x2c/0x40
    [  246.711222]  ? wait_for_completion+0x104/0x190
    [  246.712134]  ? trace_hardirqs_on_caller+0xf4/0x190
    [  246.713094]  ? wait_for_completion+0x104/0x190
    [  246.713964]  wait_for_completion+0x12c/0x190
    [  246.714895]  ? wake_up_q+0x80/0x80
    [  246.715727]  ? get_work_pool+0x90/0x90
    [  246.716649]  flush_work+0x1c9/0x280
    [  246.717483]  ? flush_workqueue_prep_pwqs+0x1b0/0x1b0
    [  246.718442]  __cancel_work_timer+0x146/0x1d0
    [  246.719247]  cancel_delayed_work_sync+0x13/0x20
    [  246.720043]  drm_kms_helper_poll_disable+0x1f/0x30 [drm_kms_helper]
    [  246.721123]  nouveau_pmops_runtime_suspend+0x3d/0xb0 [nouveau]
    [  246.721897]  pci_pm_runtime_suspend+0x6b/0x190
    [  246.722825]  ? pci_has_legacy_pm_support+0x70/0x70
    [  246.723737]  __rpm_callback+0x7a/0x1d0
    [  246.724721]  ? pci_has_legacy_pm_support+0x70/0x70
    [  246.725607]  rpm_callback+0x24/0x80
    [  246.726553]  ? pci_has_legacy_pm_support+0x70/0x70
    [  246.727376]  rpm_suspend+0x142/0x6b0
    [  246.728185]  pm_runtime_work+0x97/0xc0
    [  246.728938]  process_one_work+0x231/0x620
    [  246.729796]  worker_thread+0x44/0x3a0
    [  246.730614]  kthread+0x12b/0x150
    [  246.731395]  ? wq_pool_ids_show+0x140/0x140
    [  246.732202]  ? kthread_create_worker_on_cpu+0x70/0x70
    [  246.732878]  ret_from_fork+0x3a/0x50
    [  246.733768] INFO: task kworker/4:2:422 blocked for more than 120 seconds.
    [  246.734587]       Not tainted 4.18.0-rc5Lyude-Test+ #2
    [  246.735393] "echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
    [  246.736113] kworker/4:2     D    0   422      2 0x80000080
    [  246.736789] Workqueue: events_long drm_dp_mst_link_probe_work [drm_kms_helper]
    [  246.737665] Call Trace:
    [  246.738490]  __schedule+0x322/0xaf0
    [  246.739250]  schedule+0x33/0x90
    [  246.739908]  rpm_resume+0x19c/0x850
    [  246.740750]  ? finish_wait+0x90/0x90
    [  246.741541]  __pm_runtime_resume+0x4e/0x90
    [  246.742370]  nv50_disp_atomic_commit+0x31/0x210 [nouveau]
    [  246.743124]  drm_atomic_commit+0x4a/0x50 [drm]
    [  246.743775]  restore_fbdev_mode_atomic+0x1c8/0x240 [drm_kms_helper]
    [  246.744603]  restore_fbdev_mode+0x31/0x140 [drm_kms_helper]
    [  246.745373]  drm_fb_helper_restore_fbdev_mode_unlocked+0x54/0xb0 [drm_kms_helper]
    [  246.746220]  drm_fb_helper_set_par+0x2d/0x50 [drm_kms_helper]
    [  246.746884]  drm_fb_helper_hotplug_event.part.28+0x96/0xb0 [drm_kms_helper]
    [  246.747675]  drm_fb_helper_output_poll_changed+0x23/0x30 [drm_kms_helper]
    [  246.748544]  drm_kms_helper_hotplug_event+0x2a/0x30 [drm_kms_helper]
    [  246.749439]  nv50_mstm_hotplug+0x15/0x20 [nouveau]
    [  246.750111]  drm_dp_send_link_address+0x177/0x1c0 [drm_kms_helper]
    [  246.750764]  drm_dp_check_and_send_link_address+0xa8/0xd0 [drm_kms_helper]
    [  246.751602]  drm_dp_mst_link_probe_work+0x51/0x90 [drm_kms_helper]
    [  246.752314]  process_one_work+0x231/0x620
    [  246.752979]  worker_thread+0x44/0x3a0
    [  246.753838]  kthread+0x12b/0x150
    [  246.754619]  ? wq_pool_ids_show+0x140/0x140
    [  246.755386]  ? kthread_create_worker_on_cpu+0x70/0x70
    [  246.756162]  ret_from_fork+0x3a/0x50
    [  246.756847]
               Showing all locks held in the system:
    [  246.758261] 3 locks held by kworker/4:0/37:
    [  246.759016]  #0: 00000000f8df4d2d ((wq_completion)"events"){+.+.}, at: process_one_work+0x1b3/0x620
    [  246.759856]  #1: 00000000e6065461 ((work_completion)(&(&dev->mode_config.output_poll_work)->work)){+.+.}, at: process_one_work+0x1b3/0x620
    [  246.760670]  #2: 00000000cb66735f (&helper->lock){+.+.}, at: drm_fb_helper_hotplug_event.part.28+0x20/0xb0 [drm_kms_helper]
    [  246.761516] 2 locks held by kworker/0:1/60:
    [  246.762274]  #0: 00000000fff6be0f ((wq_completion)"pm"){+.+.}, at: process_one_work+0x1b3/0x620
    [  246.762982]  #1: 000000005ab44fb4 ((work_completion)(&dev->power.work)){+.+.}, at: process_one_work+0x1b3/0x620
    [  246.763890] 1 lock held by khungtaskd/64:
    [  246.764664]  #0: 000000008cb8b5c3 (rcu_read_lock){....}, at: debug_show_all_locks+0x23/0x185
    [  246.765588] 5 locks held by kworker/4:2/422:
    [  246.766440]  #0: 00000000232f0959 ((wq_completion)"events_long"){+.+.}, at: process_one_work+0x1b3/0x620
    [  246.767390]  #1: 00000000bb59b134 ((work_completion)(&mgr->work)){+.+.}, at: process_one_work+0x1b3/0x620
    [  246.768154]  #2: 00000000cb66735f (&helper->lock){+.+.}, at: drm_fb_helper_restore_fbdev_mode_unlocked+0x4c/0xb0 [drm_kms_helper]
    [  246.768966]  #3: 000000004c8f0b6b (crtc_ww_class_acquire){+.+.}, at: restore_fbdev_mode_atomic+0x4b/0x240 [drm_kms_helper]
    [  246.769921]  #4: 000000004c34a296 (crtc_ww_class_mutex){+.+.}, at: drm_modeset_backoff+0x8a/0x1b0 [drm]
    [  246.770839] 1 lock held by dmesg/1038:
    [  246.771739] 2 locks held by zsh/1172:
    [  246.772650]  #0: 00000000836d0438 (&tty->ldisc_sem){++++}, at: ldsem_down_read+0x37/0x40
    [  246.773680]  #1: 000000001f4f4d48 (&ldata->atomic_read_lock){+.+.}, at: n_tty_read+0xc1/0x870
    
    [  246.775522] =============================================
    
    After trying dozens of different solutions, I found one very simple one
    that should also have the benefit of preventing us from having to fight
    locking for the rest of our lives. So, we work around these deadlocks by
    deferring all fbcon hotplug events that happen after the runtime suspend
    process starts until after the device is resumed again.
    
    Changes since v7:
     - Fixup commit message - Daniel Vetter
    
    Changes since v6:
     - Remove unused nouveau_fbcon_hotplugged_in_suspend() - Ilia
    
    Changes since v5:
     - Come up with the (hopefully final) solution for solving this dumb
       problem, one that is a lot less likely to cause issues with locking in
       the future. This should work around all deadlock conditions with fbcon
       brought up thus far.
    
    Changes since v4:
     - Add nouveau_fbcon_hotplugged_in_suspend() to workaround deadlock
       condition that Lukas described
     - Just move all of this out of drm_fb_helper. It seems that other DRM
       drivers have already figured out other workarounds for this. If other
       drivers do end up needing this in the future, we can just move this
       back into drm_fb_helper again.
    
    Changes since v3:
    - Actually check if fb_helper is NULL in both new helpers
    - Actually check drm_fbdev_emulation in both new helpers
    - Don't fire off a fb_helper hotplug unconditionally; only do it if
      the following conditions are true (as otherwise, calling this in the
      wrong spot will cause Bad Things to happen):
      - fb_helper hotplug handling was actually inhibited previously
      - fb_helper actually has a delayed hotplug pending
      - fb_helper is actually bound
      - fb_helper is actually initialized
    - Add __must_check to drm_fb_helper_suspend_hotplug(). There's no
      situation where a driver would actually want to use this without
      checking the return value, so enforce that
    - Rewrite and clarify the documentation for both helpers.
    - Make sure to return true in the drm_fb_helper_suspend_hotplug() stub
      that's provided in drm_fb_helper.h when CONFIG_DRM_FBDEV_EMULATION
      isn't enabled
    - Actually grab the toplevel fb_helper lock in
      drm_fb_helper_resume_hotplug(), since it's possible other activity
      (such as a hotplug) could be going on at the same time the driver
      calls drm_fb_helper_resume_hotplug(). We need this to check whether or
      not drm_fb_helper_hotplug_event() needs to be called anyway
    
    Signed-off-by: Lyude Paul <lyude@redhat.com>
    Reviewed-by: Karol Herbst <kherbst@redhat.com>
    Acked-by: Daniel Vetter <daniel@ffwll.ch>
    Cc: stable@vger.kernel.org
    Cc: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

commit 7624ac8705f5cc2d59259c1a7259170b89402685
Author: Tomas Winkler <tomas.winkler@intel.com>
Date:   Thu Jun 28 18:13:33 2018 +0300

    tpm: separate cmd_ready/go_idle from runtime_pm
    
    commit 627448e85c766587f6fdde1ea3886d6615081c77 upstream.
    
    Fix tpm ptt initialization error:
    tpm tpm0: A TPM error (378) occurred get tpm pcr allocation.
    
    We cannot use go_idle cmd_ready commands via runtime_pm handles
    as with the introduction of localities this is no longer an optional
    feature, while runtime pm can be not enabled.
    Though cmd_ready/go_idle provides a power saving, it's also a part of
    TPM2 protocol and should be called explicitly.
    This patch exposes cmd_read/go_idle via tpm class ops and removes
    runtime pm support as it is not used by any driver.
    
    When calling from nested context always use both flags:
    TPM_TRANSMIT_UNLOCKED and TPM_TRANSMIT_RAW. Both are needed to resolve
    tpm spaces and locality request recursive calls to tpm_transmit().
    TPM_TRANSMIT_RAW should never be used standalone as it will fail
    on double locking. While TPM_TRANSMIT_UNLOCKED standalone should be
    called from non-recursive locked contexts.
    
    New wrappers are added tpm_cmd_ready() and tpm_go_idle() to
    streamline tpm_try_transmit code.
    
    tpm_crb no longer needs own power saving functions and can drop using
    tpm_pm_suspend/resume.
    
    This patch cannot be really separated from the locality fix.
    Fixes: 888d867df441 (tpm: cmd_ready command can be issued only after granting locality)
    
    Cc: stable@vger.kernel.org
    Fixes: 888d867df441 (tpm: cmd_ready command can be issued only after granting locality)
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Tested-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
    Reviewed-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
    Signed-off-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 52b9b51a5f4f55d80ef7ccb4558520464d7be076
Author: Liwei Song <liwei.song@windriver.com>
Date:   Tue Jun 13 00:59:53 2017 -0400

    i2c: ismt: fix wrong device address when unmap the data buffer
    
    commit 17e83549e199d89aace7788a9f11c108671eecf5 upstream.
    
    Fix the following kernel bug:
    
    kernel BUG at drivers/iommu/intel-iommu.c:3260!
    invalid opcode: 0000 [#5] PREEMPT SMP
    Hardware name: Intel Corp. Harcuvar/Server, BIOS HAVLCRB0.X64.0013.D39.1608311820 08/31/2016
    task: ffff880175389950 ti: ffff880176bec000 task.ti: ffff880176bec000
    RIP: 0010:[<ffffffff8150a83b>]  [<ffffffff8150a83b>] intel_unmap+0x25b/0x260
    RSP: 0018:ffff880176bef5e8  EFLAGS: 00010296
    RAX: 0000000000000024 RBX: ffff8800773c7c88 RCX: 000000000000ce04
    RDX: 0000000080000000 RSI: 0000000000000000 RDI: 0000000000000009
    RBP: ffff880176bef638 R08: 0000000000000010 R09: 0000000000000004
    R10: ffff880175389c78 R11: 0000000000000a4f R12: ffff8800773c7868
    R13: 00000000ffffac88 R14: ffff8800773c7818 R15: 0000000000000001
    FS:  00007fef21258700(0000) GS:ffff88017b5c0000(0000) knlGS:0000000000000000
    CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    CR2: 000000000066d6d8 CR3: 000000007118c000 CR4: 00000000003406e0
    Stack:
     00000000ffffac88 ffffffff8199867f ffff880176bef5f8 ffff880100000030
     ffff880176bef668 ffff8800773c7c88 ffff880178288098 ffff8800772c0010
     ffff8800773c7818 0000000000000001 ffff880176bef648 ffffffff8150a86e
    Call Trace:
     [<ffffffff8199867f>] ? printk+0x46/0x48
     [<ffffffff8150a86e>] intel_unmap_page+0xe/0x10
     [<ffffffffa039d99b>] ismt_access+0x27b/0x8fa [i2c_ismt]
     [<ffffffff81554420>] ? __pm_runtime_suspend+0xa0/0xa0
     [<ffffffff815544a0>] ? pm_suspend_timer_fn+0x80/0x80
     [<ffffffff81554420>] ? __pm_runtime_suspend+0xa0/0xa0
     [<ffffffff815544a0>] ? pm_suspend_timer_fn+0x80/0x80
     [<ffffffff8143dfd0>] ? pci_bus_read_dev_vendor_id+0xf0/0xf0
     [<ffffffff8172b36c>] i2c_smbus_xfer+0xec/0x4b0
     [<ffffffff810aa4d5>] ? vprintk_emit+0x345/0x530
     [<ffffffffa038936b>] i2cdev_ioctl_smbus+0x12b/0x240 [i2c_dev]
     [<ffffffff810aa829>] ? vprintk_default+0x29/0x40
     [<ffffffffa0389b33>] i2cdev_ioctl+0x63/0x1ec [i2c_dev]
     [<ffffffff811b04c8>] do_vfs_ioctl+0x328/0x5d0
     [<ffffffff8119d8ec>] ? vfs_write+0x11c/0x190
     [<ffffffff8109d449>] ? rt_up_read+0x19/0x20
     [<ffffffff811b07f1>] SyS_ioctl+0x81/0xa0
     [<ffffffff819a351b>] system_call_fastpath+0x16/0x6e
    
    This happen When run "i2cdetect -y 0" detect SMBus iSMT adapter.
    
    After finished I2C block read/write, when unmap the data buffer,
    a wrong device address was pass to dma_unmap_single().
    
    To fix this, give dma_unmap_single() the "dev" parameter, just like
    what dma_map_single() does, then unmap can find the right devices.
    
    Fixes: 13f35ac14cd0 ("i2c: Adding support for Intel iSMT SMBus 2.0 host controller")
    Signed-off-by: Liwei Song <liwei.song@windriver.com>
    Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 3abc229cfc033612acf27a9efbe9a44ea9004592
Author: Liwei Song <liwei.song@windriver.com>
Date:   Tue Jun 13 00:59:53 2017 -0400

    i2c: ismt: fix wrong device address when unmap the data buffer
    
    commit 17e83549e199d89aace7788a9f11c108671eecf5 upstream.
    
    Fix the following kernel bug:
    
    kernel BUG at drivers/iommu/intel-iommu.c:3260!
    invalid opcode: 0000 [#5] PREEMPT SMP
    Hardware name: Intel Corp. Harcuvar/Server, BIOS HAVLCRB0.X64.0013.D39.1608311820 08/31/2016
    task: ffff880175389950 ti: ffff880176bec000 task.ti: ffff880176bec000
    RIP: 0010:[<ffffffff8150a83b>]  [<ffffffff8150a83b>] intel_unmap+0x25b/0x260
    RSP: 0018:ffff880176bef5e8  EFLAGS: 00010296
    RAX: 0000000000000024 RBX: ffff8800773c7c88 RCX: 000000000000ce04
    RDX: 0000000080000000 RSI: 0000000000000000 RDI: 0000000000000009
    RBP: ffff880176bef638 R08: 0000000000000010 R09: 0000000000000004
    R10: ffff880175389c78 R11: 0000000000000a4f R12: ffff8800773c7868
    R13: 00000000ffffac88 R14: ffff8800773c7818 R15: 0000000000000001
    FS:  00007fef21258700(0000) GS:ffff88017b5c0000(0000) knlGS:0000000000000000
    CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    CR2: 000000000066d6d8 CR3: 000000007118c000 CR4: 00000000003406e0
    Stack:
     00000000ffffac88 ffffffff8199867f ffff880176bef5f8 ffff880100000030
     ffff880176bef668 ffff8800773c7c88 ffff880178288098 ffff8800772c0010
     ffff8800773c7818 0000000000000001 ffff880176bef648 ffffffff8150a86e
    Call Trace:
     [<ffffffff8199867f>] ? printk+0x46/0x48
     [<ffffffff8150a86e>] intel_unmap_page+0xe/0x10
     [<ffffffffa039d99b>] ismt_access+0x27b/0x8fa [i2c_ismt]
     [<ffffffff81554420>] ? __pm_runtime_suspend+0xa0/0xa0
     [<ffffffff815544a0>] ? pm_suspend_timer_fn+0x80/0x80
     [<ffffffff81554420>] ? __pm_runtime_suspend+0xa0/0xa0
     [<ffffffff815544a0>] ? pm_suspend_timer_fn+0x80/0x80
     [<ffffffff8143dfd0>] ? pci_bus_read_dev_vendor_id+0xf0/0xf0
     [<ffffffff8172b36c>] i2c_smbus_xfer+0xec/0x4b0
     [<ffffffff810aa4d5>] ? vprintk_emit+0x345/0x530
     [<ffffffffa038936b>] i2cdev_ioctl_smbus+0x12b/0x240 [i2c_dev]
     [<ffffffff810aa829>] ? vprintk_default+0x29/0x40
     [<ffffffffa0389b33>] i2cdev_ioctl+0x63/0x1ec [i2c_dev]
     [<ffffffff811b04c8>] do_vfs_ioctl+0x328/0x5d0
     [<ffffffff8119d8ec>] ? vfs_write+0x11c/0x190
     [<ffffffff8109d449>] ? rt_up_read+0x19/0x20
     [<ffffffff811b07f1>] SyS_ioctl+0x81/0xa0
     [<ffffffff819a351b>] system_call_fastpath+0x16/0x6e
    
    This happen When run "i2cdetect -y 0" detect SMBus iSMT adapter.
    
    After finished I2C block read/write, when unmap the data buffer,
    a wrong device address was pass to dma_unmap_single().
    
    To fix this, give dma_unmap_single() the "dev" parameter, just like
    what dma_map_single() does, then unmap can find the right devices.
    
    Fixes: 13f35ac14cd0 ("i2c: Adding support for Intel iSMT SMBus 2.0 host controller")
    Signed-off-by: Liwei Song <liwei.song@windriver.com>
    Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 982ad049e60e54f5a1425123637b770ad3f65df6
Author: Liwei Song <liwei.song@windriver.com>
Date:   Tue Jun 13 00:59:53 2017 -0400

    i2c: ismt: fix wrong device address when unmap the data buffer
    
    commit 17e83549e199d89aace7788a9f11c108671eecf5 upstream.
    
    Fix the following kernel bug:
    
    kernel BUG at drivers/iommu/intel-iommu.c:3260!
    invalid opcode: 0000 [#5] PREEMPT SMP
    Hardware name: Intel Corp. Harcuvar/Server, BIOS HAVLCRB0.X64.0013.D39.1608311820 08/31/2016
    task: ffff880175389950 ti: ffff880176bec000 task.ti: ffff880176bec000
    RIP: 0010:[<ffffffff8150a83b>]  [<ffffffff8150a83b>] intel_unmap+0x25b/0x260
    RSP: 0018:ffff880176bef5e8  EFLAGS: 00010296
    RAX: 0000000000000024 RBX: ffff8800773c7c88 RCX: 000000000000ce04
    RDX: 0000000080000000 RSI: 0000000000000000 RDI: 0000000000000009
    RBP: ffff880176bef638 R08: 0000000000000010 R09: 0000000000000004
    R10: ffff880175389c78 R11: 0000000000000a4f R12: ffff8800773c7868
    R13: 00000000ffffac88 R14: ffff8800773c7818 R15: 0000000000000001
    FS:  00007fef21258700(0000) GS:ffff88017b5c0000(0000) knlGS:0000000000000000
    CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    CR2: 000000000066d6d8 CR3: 000000007118c000 CR4: 00000000003406e0
    Stack:
     00000000ffffac88 ffffffff8199867f ffff880176bef5f8 ffff880100000030
     ffff880176bef668 ffff8800773c7c88 ffff880178288098 ffff8800772c0010
     ffff8800773c7818 0000000000000001 ffff880176bef648 ffffffff8150a86e
    Call Trace:
     [<ffffffff8199867f>] ? printk+0x46/0x48
     [<ffffffff8150a86e>] intel_unmap_page+0xe/0x10
     [<ffffffffa039d99b>] ismt_access+0x27b/0x8fa [i2c_ismt]
     [<ffffffff81554420>] ? __pm_runtime_suspend+0xa0/0xa0
     [<ffffffff815544a0>] ? pm_suspend_timer_fn+0x80/0x80
     [<ffffffff81554420>] ? __pm_runtime_suspend+0xa0/0xa0
     [<ffffffff815544a0>] ? pm_suspend_timer_fn+0x80/0x80
     [<ffffffff8143dfd0>] ? pci_bus_read_dev_vendor_id+0xf0/0xf0
     [<ffffffff8172b36c>] i2c_smbus_xfer+0xec/0x4b0
     [<ffffffff810aa4d5>] ? vprintk_emit+0x345/0x530
     [<ffffffffa038936b>] i2cdev_ioctl_smbus+0x12b/0x240 [i2c_dev]
     [<ffffffff810aa829>] ? vprintk_default+0x29/0x40
     [<ffffffffa0389b33>] i2cdev_ioctl+0x63/0x1ec [i2c_dev]
     [<ffffffff811b04c8>] do_vfs_ioctl+0x328/0x5d0
     [<ffffffff8119d8ec>] ? vfs_write+0x11c/0x190
     [<ffffffff8109d449>] ? rt_up_read+0x19/0x20
     [<ffffffff811b07f1>] SyS_ioctl+0x81/0xa0
     [<ffffffff819a351b>] system_call_fastpath+0x16/0x6e
    
    This happen When run "i2cdetect -y 0" detect SMBus iSMT adapter.
    
    After finished I2C block read/write, when unmap the data buffer,
    a wrong device address was pass to dma_unmap_single().
    
    To fix this, give dma_unmap_single() the "dev" parameter, just like
    what dma_map_single() does, then unmap can find the right devices.
    
    Fixes: 13f35ac14cd0 ("i2c: Adding support for Intel iSMT SMBus 2.0 host controller")
    Signed-off-by: Liwei Song <liwei.song@windriver.com>
    Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 627448e85c766587f6fdde1ea3886d6615081c77
Author: Tomas Winkler <tomas.winkler@intel.com>
Date:   Thu Jun 28 18:13:33 2018 +0300

    tpm: separate cmd_ready/go_idle from runtime_pm
    
    Fix tpm ptt initialization error:
    tpm tpm0: A TPM error (378) occurred get tpm pcr allocation.
    
    We cannot use go_idle cmd_ready commands via runtime_pm handles
    as with the introduction of localities this is no longer an optional
    feature, while runtime pm can be not enabled.
    Though cmd_ready/go_idle provides a power saving, it's also a part of
    TPM2 protocol and should be called explicitly.
    This patch exposes cmd_read/go_idle via tpm class ops and removes
    runtime pm support as it is not used by any driver.
    
    When calling from nested context always use both flags:
    TPM_TRANSMIT_UNLOCKED and TPM_TRANSMIT_RAW. Both are needed to resolve
    tpm spaces and locality request recursive calls to tpm_transmit().
    TPM_TRANSMIT_RAW should never be used standalone as it will fail
    on double locking. While TPM_TRANSMIT_UNLOCKED standalone should be
    called from non-recursive locked contexts.
    
    New wrappers are added tpm_cmd_ready() and tpm_go_idle() to
    streamline tpm_try_transmit code.
    
    tpm_crb no longer needs own power saving functions and can drop using
    tpm_pm_suspend/resume.
    
    This patch cannot be really separated from the locality fix.
    Fixes: 888d867df441 (tpm: cmd_ready command can be issued only after granting locality)
    
    Cc: stable@vger.kernel.org
    Fixes: 888d867df441 (tpm: cmd_ready command can be issued only after granting locality)
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Tested-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
    Reviewed-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
    Signed-off-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>

commit 036bfeb33b89578ab924fa198213260659e08dc8
Author: Jeykumar Sankaran <jsanka@codeaurora.org>
Date:   Wed Jun 27 15:24:17 2018 -0400

    drm/msm: Add pm_suspend/resume callbacks to msm_kms
    
    Used by the dpu driver for custom suspend/resume.
    
    Changes in v3:
    - None
    
    Signed-off-by: Jeykumar Sankaran <jsanka@codeaurora.org>
    [seanpaul split this out of the megapatch]
    Signed-off-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

commit c9eaaa1773982e30fcb6e9f2e2db878490c0f730
Merge: 8760c4d6d5f7 43e8fe9b844b
Author: David S. Miller <davem@davemloft.net>
Date:   Mon Jul 23 14:09:19 2018 -0700

    Merge branch 'lan743x-Add-features-to-lan743x-driver'
    
    Bryan Whitehead says:
    
    ====================
    lan743x: Add features to lan743x driver
    
    This patch series adds extra features to the lan743x driver.
    
    Updates for v4:
    Patch 6/8 - Modified get/set_wol to use super set of
                MAC and PHY driver support.
    Patch 7/9 - In set_eee, return the return value from phy_ethtool_set_eee.
    
    Updates for v3:
    Removed patch 9 from this series, regarding PTP support
    Patch 6/8 - Add call to phy_ethtool_get_wol to lan743x_ethtool_get_wol
    Patch 7/8 - Add call to phy_ethtool_set_eee on (!eee->eee_enabled)
    
    Updates for v2:
    Patch 3/9 - Used ARRAY_SIZE macro in lan743x_ethtool_get_ethtool_stats.
    Patch 5/9 - Used MAX_EEPROM_SIZE in lan743x_ethtool_set_eeprom.
    Patch 6/9 - Removed unnecessary read of PMT_CTL.
                Used CRC algorithm from lib.
                Removed PHY interrupt settings from lan743x_pm_suspend
                Change "#if CONFIG_PM" to "#ifdef CONFIG_PM"
    ====================
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 5b56c182edb1224bc1a97a1c74003eaa0eb59daf
Author: Wenyou Yang <wenyou.yang@atmel.com>
Date:   Tue Jul 17 11:26:55 2018 +0300

    ARM: at91: pm: Add ULP1 mode support
    
    In the ULP1 mode, in order to achieve the lowest power consumption
    with the system in retention mode and be able to resume on the wake
    up events, all the clocks are shut off, inclusive the embedded 12MHz
    RC oscillator, and the number of wake up sources is limited as well.
    When the wake up event is asserted, the embedded 12MHz RC oscillator
    restarts automatically.
    
    The ULP1 (Ultra Low-power mode 1) is introduced by SAMA5D2.
    
    The previous size of pm_suspend.o was 2148 bytes. With the addition of
    ULP1 mode the new size of pm_suspend.o raised at 2456 bytes.
    
    Signed-off-by: Wenyou Yang <wenyou.yang@atmel.com>
    Signed-off-by: Ludovic Desroches <ludovic.desroches@microchip.com>
    [claudiu.beznea@microchip.com: aligned with 4.18-rc1]
    Signed-off-by: Claudiu Beznea <claudiu.beznea@microchip.com>
    Signed-off-by: Alexandre Belloni <alexandre.belloni@bootlin.com>

commit f1454959ad89f9fe2b6862fa3c41070feaffeab9
Merge: 5d58093285d0 92748beac07c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jul 11 10:00:22 2018 -0700

    Merge tag 'mmc-v4.18-rc3' of git://git.kernel.org/pub/scm/linux/kernel/git/ulfh/mmc
    
    Pull MMC fixes from Ulf Hansson:
     "MMC core:
       - Fixup devname in /proc/interrupts for card detect GPIO
    
      MMC host:
       - sdhci-esdhc-imx: Allow 1.8V speed-modes without 100/200MHz pinctrls
       - sunxi: Disable IRQ in low power state to prevent IRQ storm
       - dw_mmc: Fix card threshold control configuration
       - renesas_sdhi_internal_dmac: Fixup DMA error paths"
    
    * tag 'mmc-v4.18-rc3' of git://git.kernel.org/pub/scm/linux/kernel/git/ulfh/mmc:
      mmc: sdhci-esdhc-imx: allow 1.8V modes without 100/200MHz pinctrl states
      mmc: sunxi: Disable irq during pm_suspend
      mmc: dw_mmc: fix card threshold control configuration
      mmc: core: cd_label must be last entry of mmc_gpio struct
      mmc: renesas_sdhi_internal_dmac: Cannot clear the RX_IN_USE in abort
      mmc: renesas_sdhi_internal_dmac: Fix missing unmap in error patch

commit e368fc75c190a4ad5853e4ec5a0c8acf86bd5119
Author: Ayan Kumar Halder <ayan.halder@arm.com>
Date:   Tue May 15 17:04:19 2018 +0100

    drm/arm/malidp: Added the late system pm functions
    
    malidp_pm_suspend_late checks if the runtime status is not suspended
    and if so, invokes malidp_runtime_pm_suspend which disables the
    display engine/core interrupts and the clocks. It sets the runtime status
    as suspended.
    
    The difference between suspend() and suspend_late() is as follows:-
    1. suspend() makes the device quiescent. In our case, we invoke the DRM
    helper which disables the CRTC. This would have invoked runtime pm
    suspend but the system suspend process disables runtime pm.
    2. suspend_late() It continues the suspend operations of the drm device
    which was started by suspend(). In our case, it performs the same functionality
    as runtime_suspend().
    
    The complimentary functions are resume() and resume_early(). In the case of
    resume_early(), we invoke malidp_runtime_pm_resume() which enables the clocks
    and the interrupts. It sets the runtime status as active. If the device was
    in runtime suspend mode before system suspend was called, pm_runtime_work()
    will put the device back in runtime suspended mode( after the complete system
    has been resumed).
    
    Signed-off-by: Ayan Kumar Halder <ayan.halder@arm.com>
    Acked-by: Liviu Dudau <liviu.dudau@arm.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

commit fbcc454e8a350b929cb04fbcfdfa72fab37acf38
Author: Ayan Kumar Halder <ayan.halder@arm.com>
Date:   Tue May 15 17:04:17 2018 +0100

    drm/arm/malidp: Enable/disable interrupts in runtime pm
    
    Display and scaling engine interrupts need to be disabled when the
    runtime pm invokes malidp_runtime_pm_suspend(). Conversely, they
    need to be enabled in malidp_runtime_pm_resume().
    
    This patch depends on:
    https://lkml.org/lkml/2017/5/15/695
    
    Reported-by: Alexandru-Cosmin Gheorghe <Alexandru-Cosmin.Gheorghe@arm.com>
    Signed-off-by: Alexandru-Cosmin Gheorghe <Alexandru-Cosmin.Gheorghe@arm.com>
    Signed-off-by: Ayan Kumar Halder <ayan.halder@arm.com>
    Acked-by: Liviu Dudau <liviu.dudau@arm.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

commit b8ba3578752b7aae5b6f8bd235873ea112969ff9
Author: Stefan Mavrodiev <stefan@olimex.com>
Date:   Wed Jul 4 09:28:59 2018 +0300

    mmc: sunxi: Disable irq during pm_suspend
    
    When mmc host controller enters suspend state, the clocks are
    disabled, but irqs are not. For some reason the irqchip emits
    false interrupts, which causes system lock loop.
    
    Debug log is:
      ...
      sunxi-mmc 1c11000.mmc: setting clk to 52000000, rounded 51200000
      sunxi-mmc 1c11000.mmc: enabling the clock
      sunxi-mmc 1c11000.mmc: cmd 13(8000014d) arg 10000 ie 0x0000bbc6 len 0
      sunxi-mmc 1c11000.mmc: irq: rq (ptrval) mi 00000004 idi 00000000
      sunxi-mmc 1c11000.mmc: cmd 6(80000146) arg 3210101 ie 0x0000bbc6 len 0
      sunxi-mmc 1c11000.mmc: irq: rq (ptrval) mi 00000004 idi 00000000
      sunxi-mmc 1c11000.mmc: cmd 13(8000014d) arg 10000 ie 0x0000bbc6 len 0
      sunxi-mmc 1c11000.mmc: irq: rq (ptrval) mi 00000004 idi 00000000
      mmc1: new DDR MMC card at address 0001
      mmcblk1: mmc1:0001 AGND3R 14.6 GiB
      mmcblk1boot0: mmc1:0001 AGND3R partition 1 4.00 MiB
      mmcblk1boot1: mmc1:0001 AGND3R partition 2 4.00 MiB
      sunxi-mmc 1c11000.mmc: cmd 18(80003352) arg 0 ie 0x0000fbc2 len 409
      sunxi-mmc 1c11000.mmc: irq: rq (ptrval) mi 00004000 idi 00000002
       mmcblk1: p1
      sunxi-mmc 1c11000.mmc: irq: rq   (null) mi 00000000 idi 00000000
      sunxi-mmc 1c11000.mmc: irq: rq   (null) mi 00000000 idi 00000000
      sunxi-mmc 1c11000.mmc: irq: rq   (null) mi 00000000 idi 00000000
      sunxi-mmc 1c11000.mmc: irq: rq   (null) mi 00000000 idi 00000000
    and so on...
    
    This issue apears on eMMC cards, routed on MMC2 slot. The patch is
    tested with A20-OLinuXino-MICRO/LIME/LIME2 boards.
    
    Fixes: 9a8e1e8cc2c0 ("mmc: sunxi: Add runtime_pm support")
    Signed-off-by: Stefan Mavrodiev <stefan@olimex.com>
    Acked-by: Maxime Ripard <maxime.ripard@bootlin.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

commit 5d647d72e2893e14f52f8b6f5568f775d08f9c4e
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri May 18 10:17:42 2018 +0200

    PCI / PM: Do not clear state_saved for devices that remain suspended
    
    commit 656088aa9b513907833ba091d0dcde87571fe05b upstream.
    
    The state_saved flag should not be cleared in pci_pm_suspend() if the
    given device is going to remain suspended, or the device's config
    space will not be restored properly during the subsequent resume.
    
    Namely, if the device is going to stay in suspend, both the late
    and noirq callbacks return early for it, so if its state_saved flag
    is cleared in pci_pm_suspend(), it will remain unset throughout the
    remaining part of suspend and resume and pci_restore_state() called
    for the device going forward will return without doing anything.
    
    For this reason, change pci_pm_suspend() to only clear state_saved
    if the given device is not going to remain suspended.  [This is
    analogous to what commit ae860a19f37c (PCI / PM: Do not clear
    state_saved in pci_pm_freeze() when smart suspend is set) did for
    hibernation.]
    
    Fixes: c4b65157aeef (PCI / PM: Take SMART_SUSPEND driver flag into account)
    Cc: 4.15+ <stable@vger.kernel.org> # 4.15+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 37988bf8e56fcef562c054c3675de7241d1eda9a
Author: Lukas Wunner <lukas@wunner.de>
Date:   Sun Feb 11 10:38:28 2018 +0100

    drm/radeon: Fix deadlock on runtime suspend
    
    commit 15734feff2bdac24aa3266c437cffa42851990e3 upstream.
    
    radeon's ->runtime_suspend hook calls drm_kms_helper_poll_disable(),
    which waits for the output poll worker to finish if it's running.
    
    The output poll worker meanwhile calls pm_runtime_get_sync() in
    radeon's ->detect hooks, which waits for the ongoing suspend to finish,
    causing a deadlock.
    
    Fix by not acquiring a runtime PM ref if the ->detect hooks are called
    in the output poll worker's context.  This is safe because the poll
    worker is only enabled while runtime active and we know that
    ->runtime_suspend waits for it to finish.
    
    Stack trace for posterity:
    
      INFO: task kworker/0:3:31847 blocked for more than 120 seconds
      Workqueue: events output_poll_execute [drm_kms_helper]
      Call Trace:
       schedule+0x3c/0x90
       rpm_resume+0x1e2/0x690
       __pm_runtime_resume+0x3f/0x60
       radeon_lvds_detect+0x39/0xf0 [radeon]
       output_poll_execute+0xda/0x1e0 [drm_kms_helper]
       process_one_work+0x14b/0x440
       worker_thread+0x48/0x4a0
    
      INFO: task kworker/2:0:10493 blocked for more than 120 seconds.
      Workqueue: pm pm_runtime_work
      Call Trace:
       schedule+0x3c/0x90
       schedule_timeout+0x1b3/0x240
       wait_for_common+0xc2/0x180
       wait_for_completion+0x1d/0x20
       flush_work+0xfc/0x1a0
       __cancel_work_timer+0xa5/0x1d0
       cancel_delayed_work_sync+0x13/0x20
       drm_kms_helper_poll_disable+0x1f/0x30 [drm_kms_helper]
       radeon_pmops_runtime_suspend+0x3d/0xa0 [radeon]
       pci_pm_runtime_suspend+0x61/0x1a0
       vga_switcheroo_runtime_suspend+0x21/0x70
       __rpm_callback+0x32/0x70
       rpm_callback+0x24/0x80
       rpm_suspend+0x12b/0x640
       pm_runtime_work+0x6f/0xb0
       process_one_work+0x14b/0x440
       worker_thread+0x48/0x4a0
    
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=94147
    Fixes: 10ebc0bc0934 ("drm/radeon: add runtime PM support (v2)")
    Cc: Ismo Toijala <ismo.toijala@gmail.com>
    Cc: Alex Deucher <alexander.deucher@amd.com>
    Cc: Dave Airlie <airlied@redhat.com>
    Reviewed-by: Lyude Paul <lyude@redhat.com>
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Link: https://patchwork.freedesktop.org/patch/msgid/64ea02c44f91dda19bc563902b97bbc699040392.1518338789.git.lukas@wunner.de
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit 2bd9bd288e536e299b954416aa55ec610efbde06
Author: Lukas Wunner <lukas@wunner.de>
Date:   Sun Feb 11 10:38:28 2018 +0100

    drm/nouveau: Fix deadlock on runtime suspend
    
    commit d61a5c1063515e855bedb1b81e20e50b0ac3541e upstream.
    
    nouveau's ->runtime_suspend hook calls drm_kms_helper_poll_disable(),
    which waits for the output poll worker to finish if it's running.
    
    The output poll worker meanwhile calls pm_runtime_get_sync() in
    nouveau_connector_detect() which waits for the ongoing suspend to finish,
    causing a deadlock.
    
    Fix by not acquiring a runtime PM ref if nouveau_connector_detect() is
    called in the output poll worker's context.  This is safe because
    the poll worker is only enabled while runtime active and we know that
    ->runtime_suspend waits for it to finish.
    
    Other contexts calling nouveau_connector_detect() do require a runtime
    PM ref, these comprise:
    
      status_store() drm sysfs interface
      ->fill_modes drm callback
      drm_fb_helper_probe_connector_modes()
      drm_mode_getconnector()
      nouveau_connector_hotplug()
      nouveau_display_hpd_work()
      nv17_tv_set_property()
    
    Stack trace for posterity:
    
      INFO: task kworker/0:1:58 blocked for more than 120 seconds.
      Workqueue: events output_poll_execute [drm_kms_helper]
      Call Trace:
       schedule+0x28/0x80
       rpm_resume+0x107/0x6e0
       __pm_runtime_resume+0x47/0x70
       nouveau_connector_detect+0x7e/0x4a0 [nouveau]
       nouveau_connector_detect_lvds+0x132/0x180 [nouveau]
       drm_helper_probe_detect_ctx+0x85/0xd0 [drm_kms_helper]
       output_poll_execute+0x11e/0x1c0 [drm_kms_helper]
       process_one_work+0x184/0x380
       worker_thread+0x2e/0x390
    
      INFO: task kworker/0:2:252 blocked for more than 120 seconds.
      Workqueue: pm pm_runtime_work
      Call Trace:
       schedule+0x28/0x80
       schedule_timeout+0x1e3/0x370
       wait_for_completion+0x123/0x190
       flush_work+0x142/0x1c0
       nouveau_pmops_runtime_suspend+0x7e/0xd0 [nouveau]
       pci_pm_runtime_suspend+0x5c/0x180
       vga_switcheroo_runtime_suspend+0x1e/0xa0
       __rpm_callback+0xc1/0x200
       rpm_callback+0x1f/0x70
       rpm_suspend+0x13c/0x640
       pm_runtime_work+0x6e/0x90
       process_one_work+0x184/0x380
       worker_thread+0x2e/0x390
    
    Bugzilla: https://bugs.archlinux.org/task/53497
    Bugzilla: https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=870523
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=70388#c33
    Fixes: 5addcf0a5f0f ("nouveau: add runtime PM support (v0.9)")
    Cc: Ben Skeggs <bskeggs@redhat.com>
    Cc: Dave Airlie <airlied@redhat.com>
    Reviewed-by: Lyude Paul <lyude@redhat.com>
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Link: https://patchwork.freedesktop.org/patch/msgid/b7d2cbb609a80f59ccabfdf479b9d5907c603ea1.1518338789.git.lukas@wunner.de
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit e15d87912c534e7bbf1f53667ce263ccd8c18ef8
Author: Vivek Gautam <vivek.gautam@codeaurora.org>
Date:   Tue Jan 16 16:26:56 2018 +0530

    phy: qcom-qmp: Fix phy pipe clock gating
    
    [ Upstream commit f8ba22a39e985c93e278709b1d5f20857a26b49b ]
    
    Pipe clock comes out of the phy and is available as long as
    the phy is turned on. Clock controller fails to gate this
    clock after the phy is turned off and generates a warning.
    
    / # [   33.048561] gcc_usb3_phy_pipe_clk status stuck at 'on'
    [   33.048585] ------------[ cut here ]------------
    [   33.052621] WARNING: CPU: 1 PID: 18 at ../drivers/clk/qcom/clk-branch.c:97 clk_branch_wait+0xf0/0x108
    [   33.057384] Modules linked in:
    [   33.066497] CPU: 1 PID: 18 Comm: kworker/1:0 Tainted: G        W       4.12.0-rc7-00024-gfe926e34c36d-dirty #96
    [   33.069451] Hardware name: Qualcomm Technologies, Inc. DB820c (DT)
    ...
    [   33.278565] [<ffff00000849b27c>] clk_branch_wait+0xf0/0x108
    [   33.286375] [<ffff00000849b2f4>] clk_branch2_disable+0x28/0x34
    [   33.291761] [<ffff0000084868dc>] clk_core_disable+0x5c/0x88
    [   33.297660] [<ffff000008487d68>] clk_core_disable_lock+0x20/0x34
    [   33.303129] [<ffff000008487d98>] clk_disable+0x1c/0x24
    [   33.309384] [<ffff0000083ccd78>] qcom_qmp_phy_poweroff+0x20/0x48
    [   33.314328] [<ffff0000083c53f4>] phy_power_off+0x80/0xdc
    [   33.320492] [<ffff00000875c950>] dwc3_core_exit+0x94/0xa0
    [   33.325784] [<ffff00000875c9ac>] dwc3_suspend_common+0x50/0x60
    [   33.331080] [<ffff00000875ca04>] dwc3_runtime_suspend+0x48/0x6c
    [   33.336810] [<ffff0000085b82f4>] pm_generic_runtime_suspend+0x28/0x38
    [   33.342627] [<ffff0000085bace0>] __rpm_callback+0x150/0x254
    [   33.349222] [<ffff0000085bae08>] rpm_callback+0x24/0x78
    [   33.354604] [<ffff0000085b9fd8>] rpm_suspend+0xe0/0x4e4
    [   33.359813] [<ffff0000085bb784>] pm_runtime_work+0xdc/0xf0
    [   33.365028] [<ffff0000080d7b30>] process_one_work+0x12c/0x28c
    [   33.370576] [<ffff0000080d7ce8>] worker_thread+0x58/0x3b8
    [   33.376393] [<ffff0000080dd4a8>] kthread+0x100/0x12c
    [   33.381776] [<ffff0000080836c0>] ret_from_fork+0x10/0x50
    
    Fix this by disabling it as the first thing in phy_exit().
    
    Fixes: e78f3d15e115 ("phy: qcom-qmp: new qmp phy driver for qcom-chipsets")
    Signed-off-by: Vivek Gautam <vivek.gautam@codeaurora.org>
    Signed-off-by: Manu Gautam <mgautam@codeaurora.org>
    Signed-off-by: Kishon Vijay Abraham I <kishon@ti.com>
    Signed-off-by: Sasha Levin <alexander.levin@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 3b64e1cf6b929e23e7949c55637f241bbad3e48c
Author: Vivek Gautam <vivek.gautam@codeaurora.org>
Date:   Tue Jan 16 16:26:56 2018 +0530

    phy: qcom-qmp: Fix phy pipe clock gating
    
    [ Upstream commit f8ba22a39e985c93e278709b1d5f20857a26b49b ]
    
    Pipe clock comes out of the phy and is available as long as
    the phy is turned on. Clock controller fails to gate this
    clock after the phy is turned off and generates a warning.
    
    / # [   33.048561] gcc_usb3_phy_pipe_clk status stuck at 'on'
    [   33.048585] ------------[ cut here ]------------
    [   33.052621] WARNING: CPU: 1 PID: 18 at ../drivers/clk/qcom/clk-branch.c:97 clk_branch_wait+0xf0/0x108
    [   33.057384] Modules linked in:
    [   33.066497] CPU: 1 PID: 18 Comm: kworker/1:0 Tainted: G        W       4.12.0-rc7-00024-gfe926e34c36d-dirty #96
    [   33.069451] Hardware name: Qualcomm Technologies, Inc. DB820c (DT)
    ...
    [   33.278565] [<ffff00000849b27c>] clk_branch_wait+0xf0/0x108
    [   33.286375] [<ffff00000849b2f4>] clk_branch2_disable+0x28/0x34
    [   33.291761] [<ffff0000084868dc>] clk_core_disable+0x5c/0x88
    [   33.297660] [<ffff000008487d68>] clk_core_disable_lock+0x20/0x34
    [   33.303129] [<ffff000008487d98>] clk_disable+0x1c/0x24
    [   33.309384] [<ffff0000083ccd78>] qcom_qmp_phy_poweroff+0x20/0x48
    [   33.314328] [<ffff0000083c53f4>] phy_power_off+0x80/0xdc
    [   33.320492] [<ffff00000875c950>] dwc3_core_exit+0x94/0xa0
    [   33.325784] [<ffff00000875c9ac>] dwc3_suspend_common+0x50/0x60
    [   33.331080] [<ffff00000875ca04>] dwc3_runtime_suspend+0x48/0x6c
    [   33.336810] [<ffff0000085b82f4>] pm_generic_runtime_suspend+0x28/0x38
    [   33.342627] [<ffff0000085bace0>] __rpm_callback+0x150/0x254
    [   33.349222] [<ffff0000085bae08>] rpm_callback+0x24/0x78
    [   33.354604] [<ffff0000085b9fd8>] rpm_suspend+0xe0/0x4e4
    [   33.359813] [<ffff0000085bb784>] pm_runtime_work+0xdc/0xf0
    [   33.365028] [<ffff0000080d7b30>] process_one_work+0x12c/0x28c
    [   33.370576] [<ffff0000080d7ce8>] worker_thread+0x58/0x3b8
    [   33.376393] [<ffff0000080dd4a8>] kthread+0x100/0x12c
    [   33.381776] [<ffff0000080836c0>] ret_from_fork+0x10/0x50
    
    Fix this by disabling it as the first thing in phy_exit().
    
    Fixes: e78f3d15e115 ("phy: qcom-qmp: new qmp phy driver for qcom-chipsets")
    Signed-off-by: Vivek Gautam <vivek.gautam@codeaurora.org>
    Signed-off-by: Manu Gautam <mgautam@codeaurora.org>
    Signed-off-by: Kishon Vijay Abraham I <kishon@ti.com>
    Signed-off-by: Sasha Levin <alexander.levin@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 728a9dc61f132eb567f58c234e11ef80a3519cc0
Author: Tony Lindgren <tony@atomide.com>
Date:   Thu May 17 11:29:50 2018 -0700

    wlcore: sdio: Fix flakey SDIO runtime PM handling
    
    We can have pm_runtime_get_sync() return 1, and we can have
    pm_runtime_put_sync() return -EBUSY. See rpm_suspend() and
    rpm_resume() for more information.
    
    Fix the issue by returning 0 from wl12xx_sdio_power_on() on success.
    And use pm_runtime_put() instead of pm_runtime_put_sync() for
    wl12xx_sdio_power_off(), then the MMC subsystem will idle the bus
    when suitable.
    
    Otherwise wlcore can sometimes get confused and may report bogus
    errors and WLAN connection can fail.
    
    Note that while wlcore checks the return value for wl1271_power_on(),
    the return value is ignored for wl1271_power_off(). Let's fix them
    both though to avoid further confusion in the future.
    
    Fixes: 60f36637bbbd ("wlcore: sdio: allow pm to handle sdio power")
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>

commit 656088aa9b513907833ba091d0dcde87571fe05b
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri May 18 10:17:42 2018 +0200

    PCI / PM: Do not clear state_saved for devices that remain suspended
    
    The state_saved flag should not be cleared in pci_pm_suspend() if the
    given device is going to remain suspended, or the device's config
    space will not be restored properly during the subsequent resume.
    
    Namely, if the device is going to stay in suspend, both the late
    and noirq callbacks return early for it, so if its state_saved flag
    is cleared in pci_pm_suspend(), it will remain unset throughout the
    remaining part of suspend and resume and pci_restore_state() called
    for the device going forward will return without doing anything.
    
    For this reason, change pci_pm_suspend() to only clear state_saved
    if the given device is not going to remain suspended.  [This is
    analogous to what commit ae860a19f37c (PCI / PM: Do not clear
    state_saved in pci_pm_freeze() when smart suspend is set) did for
    hibernation.]
    
    Fixes: c4b65157aeef (PCI / PM: Take SMART_SUSPEND driver flag into account)
    Cc: 4.15+ <stable@vger.kernel.org> # 4.15+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>

commit 655db3c608e0bb4a496b4842379af3e71768f134
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Wed May 31 18:50:43 2017 +0300

    e1000e: Undo e1000e_pm_freeze if __e1000_shutdown fails
    
    [ Upstream commit 833521ebc65b1c3092e5c0d8a97092f98eec595d ]
    
    An error during suspend (e100e_pm_suspend),
    
    [  429.994338] ACPI : EC: event blocked
    [  429.994633] e1000e: EEE TX LPI TIMER: 00000011
    [  430.955451] pci_pm_suspend(): e1000e_pm_suspend+0x0/0x30 [e1000e] returns -2
    [  430.955454] dpm_run_callback(): pci_pm_suspend+0x0/0x140 returns -2
    [  430.955458] PM: Device 0000:00:19.0 failed to suspend async: error -2
    [  430.955581] PM: Some devices failed to suspend, or early wake event detected
    [  430.957709] ACPI : EC: event unblocked
    
    lead to complete failure:
    
    [  432.585002] ------------[ cut here ]------------
    [  432.585013] WARNING: CPU: 3 PID: 8372 at kernel/irq/manage.c:1478 __free_irq+0x9f/0x280
    [  432.585015] Trying to free already-free IRQ 20
    [  432.585016] Modules linked in: cdc_ncm usbnet x86_pkg_temp_thermal intel_powerclamp coretemp mii crct10dif_pclmul crc32_pclmul ghash_clmulni_intel snd_hda_codec_hdmi snd_hda_codec_realtek snd_hda_codec_generic snd_hda_intel snd_hda_codec snd_hwdep lpc_ich snd_hda_core snd_pcm mei_me mei sdhci_pci sdhci i915 mmc_core e1000e ptp pps_core prime_numbers
    [  432.585042] CPU: 3 PID: 8372 Comm: kworker/u16:40 Tainted: G     U          4.10.0-rc8-CI-Patchwork_3870+ #1
    [  432.585044] Hardware name: LENOVO 2356GCG/2356GCG, BIOS G7ET31WW (1.13 ) 07/02/2012
    [  432.585050] Workqueue: events_unbound async_run_entry_fn
    [  432.585051] Call Trace:
    [  432.585058]  dump_stack+0x67/0x92
    [  432.585062]  __warn+0xc6/0xe0
    [  432.585065]  warn_slowpath_fmt+0x4a/0x50
    [  432.585070]  ? _raw_spin_lock_irqsave+0x49/0x60
    [  432.585072]  __free_irq+0x9f/0x280
    [  432.585075]  free_irq+0x34/0x80
    [  432.585089]  e1000_free_irq+0x65/0x70 [e1000e]
    [  432.585098]  e1000e_pm_freeze+0x7a/0xb0 [e1000e]
    [  432.585106]  e1000e_pm_suspend+0x21/0x30 [e1000e]
    [  432.585113]  pci_pm_suspend+0x71/0x140
    [  432.585118]  dpm_run_callback+0x6f/0x330
    [  432.585122]  ? pci_pm_freeze+0xe0/0xe0
    [  432.585125]  __device_suspend+0xea/0x330
    [  432.585128]  async_suspend+0x1a/0x90
    [  432.585132]  async_run_entry_fn+0x34/0x160
    [  432.585137]  process_one_work+0x1f4/0x6d0
    [  432.585140]  ? process_one_work+0x16e/0x6d0
    [  432.585143]  worker_thread+0x49/0x4a0
    [  432.585145]  kthread+0x107/0x140
    [  432.585148]  ? process_one_work+0x6d0/0x6d0
    [  432.585150]  ? kthread_create_on_node+0x40/0x40
    [  432.585154]  ret_from_fork+0x2e/0x40
    [  432.585156] ---[ end trace 6712df7f8c4b9124 ]---
    
    The unwind failures stems from commit 2800209994f8 ("e1000e: Refactor PM
    flows"), but it may be a later patch that introduced the non-recoverable
    behaviour.
    
    Fixes: 2800209994f8 ("e1000e: Refactor PM flows")
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=99847
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Tested-by: Aaron Brown <aaron.f.brown@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
    Signed-off-by: Sasha Levin <alexander.levin@microsoft.com>

commit 9bae54942b13ea9862e9137b403308a3fd4cec3b
Author: lionel.debieve@st.com <lionel.debieve@st.com>
Date:   Mon Apr 23 17:04:26 2018 +0200

    hwrng: stm32 - fix pm_suspend issue
    
    When suspend is called after pm_runtime_suspend,
    same callback is used and access to rng register is
    freezing system. By calling the pm_runtime_force_suspend,
    it first checks that runtime has been already done.
    
    Signed-off-by: Lionel Debieve <lionel.debieve@st.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

commit c064b7c1d203cd5d781c316ac9c8049ba772684f
Author: Tony Lindgren <tony@atomide.com>
Date:   Fri Feb 9 08:11:26 2018 -0800

    PM / wakeirq: Fix unbalanced IRQ enable for wakeirq
    
    
    [ Upstream commit 69728051f5bf15efaf6edfbcfe1b5a49a2437918 ]
    
    If a device is runtime PM suspended when we enter suspend and has
    a dedicated wake IRQ, we can get the following warning:
    
    WARNING: CPU: 0 PID: 108 at kernel/irq/manage.c:526 enable_irq+0x40/0x94
    [  102.087860] Unbalanced enable for IRQ 147
    ...
    (enable_irq) from [<c06117a8>] (dev_pm_arm_wake_irq+0x4c/0x60)
    (dev_pm_arm_wake_irq) from [<c0618360>]
     (device_wakeup_arm_wake_irqs+0x58/0x9c)
    (device_wakeup_arm_wake_irqs) from [<c0615948>]
    (dpm_suspend_noirq+0x10/0x48)
    (dpm_suspend_noirq) from [<c01ac7ac>]
    (suspend_devices_and_enter+0x30c/0xf14)
    (suspend_devices_and_enter) from [<c01adf20>]
    (enter_state+0xad4/0xbd8)
    (enter_state) from [<c01ad3ec>] (pm_suspend+0x38/0x98)
    (pm_suspend) from [<c01ab3e8>] (state_store+0x68/0xc8)
    
    This is because the dedicated wake IRQ for the device may have been
    already enabled earlier by dev_pm_enable_wake_irq_check().  Fix the
    issue by checking for runtime PM suspended status.
    
    This issue can be easily reproduced by setting serial console log level
    to zero, letting the serial console idle, and suspend the system from
    an ssh terminal.  On resume, dmesg will have the warning above.
    
    The reason why I have not run into this issue earlier has been that I
    typically run my PM test cases from on a serial console instead over ssh.
    
    Fixes: c84345597558 (PM / wakeirq: Enable dedicated wakeirq for suspend)
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Sasha Levin <alexander.levin@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 8d7f1fde9d8df8ae9393c6902470222305ac03b0
Author: Wanpeng Li <wanpeng.li@hotmail.com>
Date:   Sun May 7 00:14:22 2017 -0700

    block/mq: fix potential deadlock during cpu hotplug
    
    commit 51d638b1f56a0bfd9219800620994794a1a2b219 upstream.
    
    This can be triggered by hot-unplug one cpu.
    
    ======================================================
     [ INFO: possible circular locking dependency detected ]
     4.11.0+ #17 Not tainted
     -------------------------------------------------------
     step_after_susp/2640 is trying to acquire lock:
      (all_q_mutex){+.+...}, at: [<ffffffffb33f95b8>] blk_mq_queue_reinit_work+0x18/0x110
    
     but task is already holding lock:
      (cpu_hotplug.lock){+.+.+.}, at: [<ffffffffb306d04f>] cpu_hotplug_begin+0x7f/0xe0
    
     which lock already depends on the new lock.
    
     the existing dependency chain (in reverse order) is:
    
     -> #1 (cpu_hotplug.lock){+.+.+.}:
            lock_acquire+0x11c/0x230
            __mutex_lock+0x92/0x990
            mutex_lock_nested+0x1b/0x20
            get_online_cpus+0x64/0x80
            blk_mq_init_allocated_queue+0x3a0/0x4e0
            blk_mq_init_queue+0x3a/0x60
            loop_add+0xe5/0x280
            loop_init+0x124/0x177
            do_one_initcall+0x53/0x1c0
            kernel_init_freeable+0x1e3/0x27f
            kernel_init+0xe/0x100
            ret_from_fork+0x31/0x40
    
     -> #0 (all_q_mutex){+.+...}:
            __lock_acquire+0x189a/0x18a0
            lock_acquire+0x11c/0x230
            __mutex_lock+0x92/0x990
            mutex_lock_nested+0x1b/0x20
            blk_mq_queue_reinit_work+0x18/0x110
            blk_mq_queue_reinit_dead+0x1c/0x20
            cpuhp_invoke_callback+0x1f2/0x810
            cpuhp_down_callbacks+0x42/0x80
            _cpu_down+0xb2/0xe0
            freeze_secondary_cpus+0xb6/0x390
            suspend_devices_and_enter+0x3b3/0xa40
            pm_suspend+0x129/0x490
            state_store+0x82/0xf0
            kobj_attr_store+0xf/0x20
            sysfs_kf_write+0x45/0x60
            kernfs_fop_write+0x135/0x1c0
            __vfs_write+0x37/0x160
            vfs_write+0xcd/0x1d0
            SyS_write+0x58/0xc0
            do_syscall_64+0x8f/0x710
            return_from_SYSCALL_64+0x0/0x7a
    
     other info that might help us debug this:
    
      Possible unsafe locking scenario:
    
            CPU0                    CPU1
            ----                    ----
       lock(cpu_hotplug.lock);
                                    lock(all_q_mutex);
                                    lock(cpu_hotplug.lock);
       lock(all_q_mutex);
    
      *** DEADLOCK ***
    
     8 locks held by step_after_susp/2640:
      #0:  (sb_writers#6){.+.+.+}, at: [<ffffffffb3244aed>] vfs_write+0x1ad/0x1d0
      #1:  (&of->mutex){+.+.+.}, at: [<ffffffffb32d3a51>] kernfs_fop_write+0x101/0x1c0
      #2:  (s_active#166){.+.+.+}, at: [<ffffffffb32d3a59>] kernfs_fop_write+0x109/0x1c0
      #3:  (pm_mutex){+.+...}, at: [<ffffffffb30d2ecd>] pm_suspend+0x21d/0x490
      #4:  (acpi_scan_lock){+.+.+.}, at: [<ffffffffb34dc3d7>] acpi_scan_lock_acquire+0x17/0x20
      #5:  (cpu_add_remove_lock){+.+.+.}, at: [<ffffffffb306d6d7>] freeze_secondary_cpus+0x27/0x390
      #6:  (cpu_hotplug.dep_map){++++++}, at: [<ffffffffb306cfd5>] cpu_hotplug_begin+0x5/0xe0
      #7:  (cpu_hotplug.lock){+.+.+.}, at: [<ffffffffb306d04f>] cpu_hotplug_begin+0x7f/0xe0
    
     stack backtrace:
     CPU: 3 PID: 2640 Comm: step_after_susp Not tainted 4.11.0+ #17
     Hardware name: Dell Inc. OptiPlex 7040/0JCTF8, BIOS 1.4.9 09/12/2016
     Call Trace:
      dump_stack+0x99/0xce
      print_circular_bug+0x1fa/0x270
      __lock_acquire+0x189a/0x18a0
      lock_acquire+0x11c/0x230
      ? lock_acquire+0x11c/0x230
      ? blk_mq_queue_reinit_work+0x18/0x110
      ? blk_mq_queue_reinit_work+0x18/0x110
      __mutex_lock+0x92/0x990
      ? blk_mq_queue_reinit_work+0x18/0x110
      ? kmem_cache_free+0x2cb/0x330
      ? anon_transport_class_unregister+0x20/0x20
      ? blk_mq_queue_reinit_work+0x110/0x110
      mutex_lock_nested+0x1b/0x20
      ? mutex_lock_nested+0x1b/0x20
      blk_mq_queue_reinit_work+0x18/0x110
      blk_mq_queue_reinit_dead+0x1c/0x20
      cpuhp_invoke_callback+0x1f2/0x810
      ? __flow_cache_shrink+0x160/0x160
      cpuhp_down_callbacks+0x42/0x80
      _cpu_down+0xb2/0xe0
      freeze_secondary_cpus+0xb6/0x390
      suspend_devices_and_enter+0x3b3/0xa40
      ? rcu_read_lock_sched_held+0x79/0x80
      pm_suspend+0x129/0x490
      state_store+0x82/0xf0
      kobj_attr_store+0xf/0x20
      sysfs_kf_write+0x45/0x60
      kernfs_fop_write+0x135/0x1c0
      __vfs_write+0x37/0x160
      ? rcu_read_lock_sched_held+0x79/0x80
      ? rcu_sync_lockdep_assert+0x2f/0x60
      ? __sb_start_write+0xd9/0x1c0
      ? vfs_write+0x1ad/0x1d0
      vfs_write+0xcd/0x1d0
      SyS_write+0x58/0xc0
      ? rcu_read_lock_sched_held+0x79/0x80
      do_syscall_64+0x8f/0x710
      ? trace_hardirqs_on_thunk+0x1a/0x1c
      entry_SYSCALL64_slow_path+0x25/0x25
    
    The cpu hotplug path will hold cpu_hotplug.lock and then reinit all exiting
    queues for blk mq w/ all_q_mutex, however, blk_mq_init_allocated_queue() will
    contend these two locks in the inversion order. This is due to commit eabe06595d62
    (blk/mq: Cure cpu hotplug lock inversion), it fixes a cpu hotplug lock inversion
    issue because of hotplug rework, however the hotplug rework is still work-in-progress
    and lives in a -tip branch and mainline cannot yet trigger that splat. The commit
    breaks the linus's tree in the merge window, so this patch reverts the lock order
    and avoids to splat linus's tree.
    
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Wanpeng Li <wanpeng.li@hotmail.com>
    Signed-off-by: Jens Axboe <axboe@fb.com>
    Cc: Thierry Escande <thierry.escande@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 85fcf68b0216c9a1347e19dfa1f744bcd77f7892
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Wed May 31 18:50:43 2017 +0300

    e1000e: Undo e1000e_pm_freeze if __e1000_shutdown fails
    
    
    [ Upstream commit 833521ebc65b1c3092e5c0d8a97092f98eec595d ]
    
    An error during suspend (e100e_pm_suspend),
    
    [  429.994338] ACPI : EC: event blocked
    [  429.994633] e1000e: EEE TX LPI TIMER: 00000011
    [  430.955451] pci_pm_suspend(): e1000e_pm_suspend+0x0/0x30 [e1000e] returns -2
    [  430.955454] dpm_run_callback(): pci_pm_suspend+0x0/0x140 returns -2
    [  430.955458] PM: Device 0000:00:19.0 failed to suspend async: error -2
    [  430.955581] PM: Some devices failed to suspend, or early wake event detected
    [  430.957709] ACPI : EC: event unblocked
    
    lead to complete failure:
    
    [  432.585002] ------------[ cut here ]------------
    [  432.585013] WARNING: CPU: 3 PID: 8372 at kernel/irq/manage.c:1478 __free_irq+0x9f/0x280
    [  432.585015] Trying to free already-free IRQ 20
    [  432.585016] Modules linked in: cdc_ncm usbnet x86_pkg_temp_thermal intel_powerclamp coretemp mii crct10dif_pclmul crc32_pclmul ghash_clmulni_intel snd_hda_codec_hdmi snd_hda_codec_realtek snd_hda_codec_generic snd_hda_intel snd_hda_codec snd_hwdep lpc_ich snd_hda_core snd_pcm mei_me mei sdhci_pci sdhci i915 mmc_core e1000e ptp pps_core prime_numbers
    [  432.585042] CPU: 3 PID: 8372 Comm: kworker/u16:40 Tainted: G     U          4.10.0-rc8-CI-Patchwork_3870+ #1
    [  432.585044] Hardware name: LENOVO 2356GCG/2356GCG, BIOS G7ET31WW (1.13 ) 07/02/2012
    [  432.585050] Workqueue: events_unbound async_run_entry_fn
    [  432.585051] Call Trace:
    [  432.585058]  dump_stack+0x67/0x92
    [  432.585062]  __warn+0xc6/0xe0
    [  432.585065]  warn_slowpath_fmt+0x4a/0x50
    [  432.585070]  ? _raw_spin_lock_irqsave+0x49/0x60
    [  432.585072]  __free_irq+0x9f/0x280
    [  432.585075]  free_irq+0x34/0x80
    [  432.585089]  e1000_free_irq+0x65/0x70 [e1000e]
    [  432.585098]  e1000e_pm_freeze+0x7a/0xb0 [e1000e]
    [  432.585106]  e1000e_pm_suspend+0x21/0x30 [e1000e]
    [  432.585113]  pci_pm_suspend+0x71/0x140
    [  432.585118]  dpm_run_callback+0x6f/0x330
    [  432.585122]  ? pci_pm_freeze+0xe0/0xe0
    [  432.585125]  __device_suspend+0xea/0x330
    [  432.585128]  async_suspend+0x1a/0x90
    [  432.585132]  async_run_entry_fn+0x34/0x160
    [  432.585137]  process_one_work+0x1f4/0x6d0
    [  432.585140]  ? process_one_work+0x16e/0x6d0
    [  432.585143]  worker_thread+0x49/0x4a0
    [  432.585145]  kthread+0x107/0x140
    [  432.585148]  ? process_one_work+0x6d0/0x6d0
    [  432.585150]  ? kthread_create_on_node+0x40/0x40
    [  432.585154]  ret_from_fork+0x2e/0x40
    [  432.585156] ---[ end trace 6712df7f8c4b9124 ]---
    
    The unwind failures stems from commit 2800209994f8 ("e1000e: Refactor PM
    flows"), but it may be a later patch that introduced the non-recoverable
    behaviour.
    
    Fixes: 2800209994f8 ("e1000e: Refactor PM flows")
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=99847
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Tested-by: Aaron Brown <aaron.f.brown@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
    Signed-off-by: Sasha Levin <alexander.levin@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit aec0f7859616d2f260deefe034461077684a9a8e
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Wed May 31 18:50:43 2017 +0300

    e1000e: Undo e1000e_pm_freeze if __e1000_shutdown fails
    
    
    [ Upstream commit 833521ebc65b1c3092e5c0d8a97092f98eec595d ]
    
    An error during suspend (e100e_pm_suspend),
    
    [  429.994338] ACPI : EC: event blocked
    [  429.994633] e1000e: EEE TX LPI TIMER: 00000011
    [  430.955451] pci_pm_suspend(): e1000e_pm_suspend+0x0/0x30 [e1000e] returns -2
    [  430.955454] dpm_run_callback(): pci_pm_suspend+0x0/0x140 returns -2
    [  430.955458] PM: Device 0000:00:19.0 failed to suspend async: error -2
    [  430.955581] PM: Some devices failed to suspend, or early wake event detected
    [  430.957709] ACPI : EC: event unblocked
    
    lead to complete failure:
    
    [  432.585002] ------------[ cut here ]------------
    [  432.585013] WARNING: CPU: 3 PID: 8372 at kernel/irq/manage.c:1478 __free_irq+0x9f/0x280
    [  432.585015] Trying to free already-free IRQ 20
    [  432.585016] Modules linked in: cdc_ncm usbnet x86_pkg_temp_thermal intel_powerclamp coretemp mii crct10dif_pclmul crc32_pclmul ghash_clmulni_intel snd_hda_codec_hdmi snd_hda_codec_realtek snd_hda_codec_generic snd_hda_intel snd_hda_codec snd_hwdep lpc_ich snd_hda_core snd_pcm mei_me mei sdhci_pci sdhci i915 mmc_core e1000e ptp pps_core prime_numbers
    [  432.585042] CPU: 3 PID: 8372 Comm: kworker/u16:40 Tainted: G     U          4.10.0-rc8-CI-Patchwork_3870+ #1
    [  432.585044] Hardware name: LENOVO 2356GCG/2356GCG, BIOS G7ET31WW (1.13 ) 07/02/2012
    [  432.585050] Workqueue: events_unbound async_run_entry_fn
    [  432.585051] Call Trace:
    [  432.585058]  dump_stack+0x67/0x92
    [  432.585062]  __warn+0xc6/0xe0
    [  432.585065]  warn_slowpath_fmt+0x4a/0x50
    [  432.585070]  ? _raw_spin_lock_irqsave+0x49/0x60
    [  432.585072]  __free_irq+0x9f/0x280
    [  432.585075]  free_irq+0x34/0x80
    [  432.585089]  e1000_free_irq+0x65/0x70 [e1000e]
    [  432.585098]  e1000e_pm_freeze+0x7a/0xb0 [e1000e]
    [  432.585106]  e1000e_pm_suspend+0x21/0x30 [e1000e]
    [  432.585113]  pci_pm_suspend+0x71/0x140
    [  432.585118]  dpm_run_callback+0x6f/0x330
    [  432.585122]  ? pci_pm_freeze+0xe0/0xe0
    [  432.585125]  __device_suspend+0xea/0x330
    [  432.585128]  async_suspend+0x1a/0x90
    [  432.585132]  async_run_entry_fn+0x34/0x160
    [  432.585137]  process_one_work+0x1f4/0x6d0
    [  432.585140]  ? process_one_work+0x16e/0x6d0
    [  432.585143]  worker_thread+0x49/0x4a0
    [  432.585145]  kthread+0x107/0x140
    [  432.585148]  ? process_one_work+0x6d0/0x6d0
    [  432.585150]  ? kthread_create_on_node+0x40/0x40
    [  432.585154]  ret_from_fork+0x2e/0x40
    [  432.585156] ---[ end trace 6712df7f8c4b9124 ]---
    
    The unwind failures stems from commit 2800209994f8 ("e1000e: Refactor PM
    flows"), but it may be a later patch that introduced the non-recoverable
    behaviour.
    
    Fixes: 2800209994f8 ("e1000e: Refactor PM flows")
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=99847
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Tested-by: Aaron Brown <aaron.f.brown@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
    Signed-off-by: Sasha Levin <alexander.levin@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit d54421849563260d8344a5f60190188822214cda
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Wed May 31 18:50:43 2017 +0300

    e1000e: Undo e1000e_pm_freeze if __e1000_shutdown fails
    
    
    [ Upstream commit 833521ebc65b1c3092e5c0d8a97092f98eec595d ]
    
    An error during suspend (e100e_pm_suspend),
    
    [  429.994338] ACPI : EC: event blocked
    [  429.994633] e1000e: EEE TX LPI TIMER: 00000011
    [  430.955451] pci_pm_suspend(): e1000e_pm_suspend+0x0/0x30 [e1000e] returns -2
    [  430.955454] dpm_run_callback(): pci_pm_suspend+0x0/0x140 returns -2
    [  430.955458] PM: Device 0000:00:19.0 failed to suspend async: error -2
    [  430.955581] PM: Some devices failed to suspend, or early wake event detected
    [  430.957709] ACPI : EC: event unblocked
    
    lead to complete failure:
    
    [  432.585002] ------------[ cut here ]------------
    [  432.585013] WARNING: CPU: 3 PID: 8372 at kernel/irq/manage.c:1478 __free_irq+0x9f/0x280
    [  432.585015] Trying to free already-free IRQ 20
    [  432.585016] Modules linked in: cdc_ncm usbnet x86_pkg_temp_thermal intel_powerclamp coretemp mii crct10dif_pclmul crc32_pclmul ghash_clmulni_intel snd_hda_codec_hdmi snd_hda_codec_realtek snd_hda_codec_generic snd_hda_intel snd_hda_codec snd_hwdep lpc_ich snd_hda_core snd_pcm mei_me mei sdhci_pci sdhci i915 mmc_core e1000e ptp pps_core prime_numbers
    [  432.585042] CPU: 3 PID: 8372 Comm: kworker/u16:40 Tainted: G     U          4.10.0-rc8-CI-Patchwork_3870+ #1
    [  432.585044] Hardware name: LENOVO 2356GCG/2356GCG, BIOS G7ET31WW (1.13 ) 07/02/2012
    [  432.585050] Workqueue: events_unbound async_run_entry_fn
    [  432.585051] Call Trace:
    [  432.585058]  dump_stack+0x67/0x92
    [  432.585062]  __warn+0xc6/0xe0
    [  432.585065]  warn_slowpath_fmt+0x4a/0x50
    [  432.585070]  ? _raw_spin_lock_irqsave+0x49/0x60
    [  432.585072]  __free_irq+0x9f/0x280
    [  432.585075]  free_irq+0x34/0x80
    [  432.585089]  e1000_free_irq+0x65/0x70 [e1000e]
    [  432.585098]  e1000e_pm_freeze+0x7a/0xb0 [e1000e]
    [  432.585106]  e1000e_pm_suspend+0x21/0x30 [e1000e]
    [  432.585113]  pci_pm_suspend+0x71/0x140
    [  432.585118]  dpm_run_callback+0x6f/0x330
    [  432.585122]  ? pci_pm_freeze+0xe0/0xe0
    [  432.585125]  __device_suspend+0xea/0x330
    [  432.585128]  async_suspend+0x1a/0x90
    [  432.585132]  async_run_entry_fn+0x34/0x160
    [  432.585137]  process_one_work+0x1f4/0x6d0
    [  432.585140]  ? process_one_work+0x16e/0x6d0
    [  432.585143]  worker_thread+0x49/0x4a0
    [  432.585145]  kthread+0x107/0x140
    [  432.585148]  ? process_one_work+0x6d0/0x6d0
    [  432.585150]  ? kthread_create_on_node+0x40/0x40
    [  432.585154]  ret_from_fork+0x2e/0x40
    [  432.585156] ---[ end trace 6712df7f8c4b9124 ]---
    
    The unwind failures stems from commit 2800209994f8 ("e1000e: Refactor PM
    flows"), but it may be a later patch that introduced the non-recoverable
    behaviour.
    
    Fixes: 2800209994f8 ("e1000e: Refactor PM flows")
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=99847
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Tested-by: Aaron Brown <aaron.f.brown@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
    Signed-off-by: Sasha Levin <alexander.levin@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit bacc51c36ebdc39013c12d02cc9090e387c768ac
Author: Lukas Wunner <lukas@wunner.de>
Date:   Sun Feb 11 10:38:28 2018 +0100

    drm/radeon: Fix deadlock on runtime suspend
    
    commit 15734feff2bdac24aa3266c437cffa42851990e3 upstream.
    
    radeon's ->runtime_suspend hook calls drm_kms_helper_poll_disable(),
    which waits for the output poll worker to finish if it's running.
    
    The output poll worker meanwhile calls pm_runtime_get_sync() in
    radeon's ->detect hooks, which waits for the ongoing suspend to finish,
    causing a deadlock.
    
    Fix by not acquiring a runtime PM ref if the ->detect hooks are called
    in the output poll worker's context.  This is safe because the poll
    worker is only enabled while runtime active and we know that
    ->runtime_suspend waits for it to finish.
    
    Stack trace for posterity:
    
      INFO: task kworker/0:3:31847 blocked for more than 120 seconds
      Workqueue: events output_poll_execute [drm_kms_helper]
      Call Trace:
       schedule+0x3c/0x90
       rpm_resume+0x1e2/0x690
       __pm_runtime_resume+0x3f/0x60
       radeon_lvds_detect+0x39/0xf0 [radeon]
       output_poll_execute+0xda/0x1e0 [drm_kms_helper]
       process_one_work+0x14b/0x440
       worker_thread+0x48/0x4a0
    
      INFO: task kworker/2:0:10493 blocked for more than 120 seconds.
      Workqueue: pm pm_runtime_work
      Call Trace:
       schedule+0x3c/0x90
       schedule_timeout+0x1b3/0x240
       wait_for_common+0xc2/0x180
       wait_for_completion+0x1d/0x20
       flush_work+0xfc/0x1a0
       __cancel_work_timer+0xa5/0x1d0
       cancel_delayed_work_sync+0x13/0x20
       drm_kms_helper_poll_disable+0x1f/0x30 [drm_kms_helper]
       radeon_pmops_runtime_suspend+0x3d/0xa0 [radeon]
       pci_pm_runtime_suspend+0x61/0x1a0
       vga_switcheroo_runtime_suspend+0x21/0x70
       __rpm_callback+0x32/0x70
       rpm_callback+0x24/0x80
       rpm_suspend+0x12b/0x640
       pm_runtime_work+0x6f/0xb0
       process_one_work+0x14b/0x440
       worker_thread+0x48/0x4a0
    
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=94147
    Fixes: 10ebc0bc0934 ("drm/radeon: add runtime PM support (v2)")
    Cc: stable@vger.kernel.org # v3.13+: 27d4ee03078a: workqueue: Allow retrieval of current task's work struct
    Cc: stable@vger.kernel.org # v3.13+: 25c058ccaf2e: drm: Allow determining if current task is output poll worker
    Cc: Ismo Toijala <ismo.toijala@gmail.com>
    Cc: Alex Deucher <alexander.deucher@amd.com>
    Cc: Dave Airlie <airlied@redhat.com>
    Reviewed-by: Lyude Paul <lyude@redhat.com>
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Link: https://patchwork.freedesktop.org/patch/msgid/64ea02c44f91dda19bc563902b97bbc699040392.1518338789.git.lukas@wunner.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 24f82eef049e4caba0fbf6831dbc1dd255d97967
Author: Lukas Wunner <lukas@wunner.de>
Date:   Sun Feb 11 10:38:28 2018 +0100

    drm/nouveau: Fix deadlock on runtime suspend
    
    commit d61a5c1063515e855bedb1b81e20e50b0ac3541e upstream.
    
    nouveau's ->runtime_suspend hook calls drm_kms_helper_poll_disable(),
    which waits for the output poll worker to finish if it's running.
    
    The output poll worker meanwhile calls pm_runtime_get_sync() in
    nouveau_connector_detect() which waits for the ongoing suspend to finish,
    causing a deadlock.
    
    Fix by not acquiring a runtime PM ref if nouveau_connector_detect() is
    called in the output poll worker's context.  This is safe because
    the poll worker is only enabled while runtime active and we know that
    ->runtime_suspend waits for it to finish.
    
    Other contexts calling nouveau_connector_detect() do require a runtime
    PM ref, these comprise:
    
      status_store() drm sysfs interface
      ->fill_modes drm callback
      drm_fb_helper_probe_connector_modes()
      drm_mode_getconnector()
      nouveau_connector_hotplug()
      nouveau_display_hpd_work()
      nv17_tv_set_property()
    
    Stack trace for posterity:
    
      INFO: task kworker/0:1:58 blocked for more than 120 seconds.
      Workqueue: events output_poll_execute [drm_kms_helper]
      Call Trace:
       schedule+0x28/0x80
       rpm_resume+0x107/0x6e0
       __pm_runtime_resume+0x47/0x70
       nouveau_connector_detect+0x7e/0x4a0 [nouveau]
       nouveau_connector_detect_lvds+0x132/0x180 [nouveau]
       drm_helper_probe_detect_ctx+0x85/0xd0 [drm_kms_helper]
       output_poll_execute+0x11e/0x1c0 [drm_kms_helper]
       process_one_work+0x184/0x380
       worker_thread+0x2e/0x390
    
      INFO: task kworker/0:2:252 blocked for more than 120 seconds.
      Workqueue: pm pm_runtime_work
      Call Trace:
       schedule+0x28/0x80
       schedule_timeout+0x1e3/0x370
       wait_for_completion+0x123/0x190
       flush_work+0x142/0x1c0
       nouveau_pmops_runtime_suspend+0x7e/0xd0 [nouveau]
       pci_pm_runtime_suspend+0x5c/0x180
       vga_switcheroo_runtime_suspend+0x1e/0xa0
       __rpm_callback+0xc1/0x200
       rpm_callback+0x1f/0x70
       rpm_suspend+0x13c/0x640
       pm_runtime_work+0x6e/0x90
       process_one_work+0x184/0x380
       worker_thread+0x2e/0x390
    
    Bugzilla: https://bugs.archlinux.org/task/53497
    Bugzilla: https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=870523
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=70388#c33
    Fixes: 5addcf0a5f0f ("nouveau: add runtime PM support (v0.9)")
    Cc: stable@vger.kernel.org # v3.12+: 27d4ee03078a: workqueue: Allow retrieval of current task's work struct
    Cc: stable@vger.kernel.org # v3.12+: 25c058ccaf2e: drm: Allow determining if current task is output poll worker
    Cc: Ben Skeggs <bskeggs@redhat.com>
    Cc: Dave Airlie <airlied@redhat.com>
    Reviewed-by: Lyude Paul <lyude@redhat.com>
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Link: https://patchwork.freedesktop.org/patch/msgid/b7d2cbb609a80f59ccabfdf479b9d5907c603ea1.1518338789.git.lukas@wunner.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 40539a866f0c78caef415170a1f83d1b8f81d12c
Author: Lukas Wunner <lukas@wunner.de>
Date:   Sun Feb 11 10:38:28 2018 +0100

    drm/radeon: Fix deadlock on runtime suspend
    
    commit 15734feff2bdac24aa3266c437cffa42851990e3 upstream.
    
    radeon's ->runtime_suspend hook calls drm_kms_helper_poll_disable(),
    which waits for the output poll worker to finish if it's running.
    
    The output poll worker meanwhile calls pm_runtime_get_sync() in
    radeon's ->detect hooks, which waits for the ongoing suspend to finish,
    causing a deadlock.
    
    Fix by not acquiring a runtime PM ref if the ->detect hooks are called
    in the output poll worker's context.  This is safe because the poll
    worker is only enabled while runtime active and we know that
    ->runtime_suspend waits for it to finish.
    
    Stack trace for posterity:
    
      INFO: task kworker/0:3:31847 blocked for more than 120 seconds
      Workqueue: events output_poll_execute [drm_kms_helper]
      Call Trace:
       schedule+0x3c/0x90
       rpm_resume+0x1e2/0x690
       __pm_runtime_resume+0x3f/0x60
       radeon_lvds_detect+0x39/0xf0 [radeon]
       output_poll_execute+0xda/0x1e0 [drm_kms_helper]
       process_one_work+0x14b/0x440
       worker_thread+0x48/0x4a0
    
      INFO: task kworker/2:0:10493 blocked for more than 120 seconds.
      Workqueue: pm pm_runtime_work
      Call Trace:
       schedule+0x3c/0x90
       schedule_timeout+0x1b3/0x240
       wait_for_common+0xc2/0x180
       wait_for_completion+0x1d/0x20
       flush_work+0xfc/0x1a0
       __cancel_work_timer+0xa5/0x1d0
       cancel_delayed_work_sync+0x13/0x20
       drm_kms_helper_poll_disable+0x1f/0x30 [drm_kms_helper]
       radeon_pmops_runtime_suspend+0x3d/0xa0 [radeon]
       pci_pm_runtime_suspend+0x61/0x1a0
       vga_switcheroo_runtime_suspend+0x21/0x70
       __rpm_callback+0x32/0x70
       rpm_callback+0x24/0x80
       rpm_suspend+0x12b/0x640
       pm_runtime_work+0x6f/0xb0
       process_one_work+0x14b/0x440
       worker_thread+0x48/0x4a0
    
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=94147
    Fixes: 10ebc0bc0934 ("drm/radeon: add runtime PM support (v2)")
    Cc: stable@vger.kernel.org # v3.13+: 27d4ee03078a: workqueue: Allow retrieval of current task's work struct
    Cc: stable@vger.kernel.org # v3.13+: 25c058ccaf2e: drm: Allow determining if current task is output poll worker
    Cc: Ismo Toijala <ismo.toijala@gmail.com>
    Cc: Alex Deucher <alexander.deucher@amd.com>
    Cc: Dave Airlie <airlied@redhat.com>
    Reviewed-by: Lyude Paul <lyude@redhat.com>
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Link: https://patchwork.freedesktop.org/patch/msgid/64ea02c44f91dda19bc563902b97bbc699040392.1518338789.git.lukas@wunner.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit cff2a8c5f97efdff33783bd1c5e41a36b3dab356
Author: Lukas Wunner <lukas@wunner.de>
Date:   Sun Feb 11 10:38:28 2018 +0100

    drm/nouveau: Fix deadlock on runtime suspend
    
    commit d61a5c1063515e855bedb1b81e20e50b0ac3541e upstream.
    
    nouveau's ->runtime_suspend hook calls drm_kms_helper_poll_disable(),
    which waits for the output poll worker to finish if it's running.
    
    The output poll worker meanwhile calls pm_runtime_get_sync() in
    nouveau_connector_detect() which waits for the ongoing suspend to finish,
    causing a deadlock.
    
    Fix by not acquiring a runtime PM ref if nouveau_connector_detect() is
    called in the output poll worker's context.  This is safe because
    the poll worker is only enabled while runtime active and we know that
    ->runtime_suspend waits for it to finish.
    
    Other contexts calling nouveau_connector_detect() do require a runtime
    PM ref, these comprise:
    
      status_store() drm sysfs interface
      ->fill_modes drm callback
      drm_fb_helper_probe_connector_modes()
      drm_mode_getconnector()
      nouveau_connector_hotplug()
      nouveau_display_hpd_work()
      nv17_tv_set_property()
    
    Stack trace for posterity:
    
      INFO: task kworker/0:1:58 blocked for more than 120 seconds.
      Workqueue: events output_poll_execute [drm_kms_helper]
      Call Trace:
       schedule+0x28/0x80
       rpm_resume+0x107/0x6e0
       __pm_runtime_resume+0x47/0x70
       nouveau_connector_detect+0x7e/0x4a0 [nouveau]
       nouveau_connector_detect_lvds+0x132/0x180 [nouveau]
       drm_helper_probe_detect_ctx+0x85/0xd0 [drm_kms_helper]
       output_poll_execute+0x11e/0x1c0 [drm_kms_helper]
       process_one_work+0x184/0x380
       worker_thread+0x2e/0x390
    
      INFO: task kworker/0:2:252 blocked for more than 120 seconds.
      Workqueue: pm pm_runtime_work
      Call Trace:
       schedule+0x28/0x80
       schedule_timeout+0x1e3/0x370
       wait_for_completion+0x123/0x190
       flush_work+0x142/0x1c0
       nouveau_pmops_runtime_suspend+0x7e/0xd0 [nouveau]
       pci_pm_runtime_suspend+0x5c/0x180
       vga_switcheroo_runtime_suspend+0x1e/0xa0
       __rpm_callback+0xc1/0x200
       rpm_callback+0x1f/0x70
       rpm_suspend+0x13c/0x640
       pm_runtime_work+0x6e/0x90
       process_one_work+0x184/0x380
       worker_thread+0x2e/0x390
    
    Bugzilla: https://bugs.archlinux.org/task/53497
    Bugzilla: https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=870523
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=70388#c33
    Fixes: 5addcf0a5f0f ("nouveau: add runtime PM support (v0.9)")
    Cc: stable@vger.kernel.org # v3.12+: 27d4ee03078a: workqueue: Allow retrieval of current task's work struct
    Cc: stable@vger.kernel.org # v3.12+: 25c058ccaf2e: drm: Allow determining if current task is output poll worker
    Cc: Ben Skeggs <bskeggs@redhat.com>
    Cc: Dave Airlie <airlied@redhat.com>
    Reviewed-by: Lyude Paul <lyude@redhat.com>
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Link: https://patchwork.freedesktop.org/patch/msgid/b7d2cbb609a80f59ccabfdf479b9d5907c603ea1.1518338789.git.lukas@wunner.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit ae78cada27a576c5eb41fb755e7f5b438822d696
Author: Lukas Wunner <lukas@wunner.de>
Date:   Sun Feb 11 10:38:28 2018 +0100

    drm/radeon: Fix deadlock on runtime suspend
    
    commit 15734feff2bdac24aa3266c437cffa42851990e3 upstream.
    
    radeon's ->runtime_suspend hook calls drm_kms_helper_poll_disable(),
    which waits for the output poll worker to finish if it's running.
    
    The output poll worker meanwhile calls pm_runtime_get_sync() in
    radeon's ->detect hooks, which waits for the ongoing suspend to finish,
    causing a deadlock.
    
    Fix by not acquiring a runtime PM ref if the ->detect hooks are called
    in the output poll worker's context.  This is safe because the poll
    worker is only enabled while runtime active and we know that
    ->runtime_suspend waits for it to finish.
    
    Stack trace for posterity:
    
      INFO: task kworker/0:3:31847 blocked for more than 120 seconds
      Workqueue: events output_poll_execute [drm_kms_helper]
      Call Trace:
       schedule+0x3c/0x90
       rpm_resume+0x1e2/0x690
       __pm_runtime_resume+0x3f/0x60
       radeon_lvds_detect+0x39/0xf0 [radeon]
       output_poll_execute+0xda/0x1e0 [drm_kms_helper]
       process_one_work+0x14b/0x440
       worker_thread+0x48/0x4a0
    
      INFO: task kworker/2:0:10493 blocked for more than 120 seconds.
      Workqueue: pm pm_runtime_work
      Call Trace:
       schedule+0x3c/0x90
       schedule_timeout+0x1b3/0x240
       wait_for_common+0xc2/0x180
       wait_for_completion+0x1d/0x20
       flush_work+0xfc/0x1a0
       __cancel_work_timer+0xa5/0x1d0
       cancel_delayed_work_sync+0x13/0x20
       drm_kms_helper_poll_disable+0x1f/0x30 [drm_kms_helper]
       radeon_pmops_runtime_suspend+0x3d/0xa0 [radeon]
       pci_pm_runtime_suspend+0x61/0x1a0
       vga_switcheroo_runtime_suspend+0x21/0x70
       __rpm_callback+0x32/0x70
       rpm_callback+0x24/0x80
       rpm_suspend+0x12b/0x640
       pm_runtime_work+0x6f/0xb0
       process_one_work+0x14b/0x440
       worker_thread+0x48/0x4a0
    
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=94147
    Fixes: 10ebc0bc0934 ("drm/radeon: add runtime PM support (v2)")
    Cc: stable@vger.kernel.org # v3.13+: 27d4ee03078a: workqueue: Allow retrieval of current task's work struct
    Cc: stable@vger.kernel.org # v3.13+: 25c058ccaf2e: drm: Allow determining if current task is output poll worker
    Cc: Ismo Toijala <ismo.toijala@gmail.com>
    Cc: Alex Deucher <alexander.deucher@amd.com>
    Cc: Dave Airlie <airlied@redhat.com>
    Reviewed-by: Lyude Paul <lyude@redhat.com>
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Link: https://patchwork.freedesktop.org/patch/msgid/64ea02c44f91dda19bc563902b97bbc699040392.1518338789.git.lukas@wunner.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit edf309e744c0895caefc7152f8d15b453ac5fcbd
Author: Lukas Wunner <lukas@wunner.de>
Date:   Sun Feb 11 10:38:28 2018 +0100

    drm/nouveau: Fix deadlock on runtime suspend
    
    commit d61a5c1063515e855bedb1b81e20e50b0ac3541e upstream.
    
    nouveau's ->runtime_suspend hook calls drm_kms_helper_poll_disable(),
    which waits for the output poll worker to finish if it's running.
    
    The output poll worker meanwhile calls pm_runtime_get_sync() in
    nouveau_connector_detect() which waits for the ongoing suspend to finish,
    causing a deadlock.
    
    Fix by not acquiring a runtime PM ref if nouveau_connector_detect() is
    called in the output poll worker's context.  This is safe because
    the poll worker is only enabled while runtime active and we know that
    ->runtime_suspend waits for it to finish.
    
    Other contexts calling nouveau_connector_detect() do require a runtime
    PM ref, these comprise:
    
      status_store() drm sysfs interface
      ->fill_modes drm callback
      drm_fb_helper_probe_connector_modes()
      drm_mode_getconnector()
      nouveau_connector_hotplug()
      nouveau_display_hpd_work()
      nv17_tv_set_property()
    
    Stack trace for posterity:
    
      INFO: task kworker/0:1:58 blocked for more than 120 seconds.
      Workqueue: events output_poll_execute [drm_kms_helper]
      Call Trace:
       schedule+0x28/0x80
       rpm_resume+0x107/0x6e0
       __pm_runtime_resume+0x47/0x70
       nouveau_connector_detect+0x7e/0x4a0 [nouveau]
       nouveau_connector_detect_lvds+0x132/0x180 [nouveau]
       drm_helper_probe_detect_ctx+0x85/0xd0 [drm_kms_helper]
       output_poll_execute+0x11e/0x1c0 [drm_kms_helper]
       process_one_work+0x184/0x380
       worker_thread+0x2e/0x390
    
      INFO: task kworker/0:2:252 blocked for more than 120 seconds.
      Workqueue: pm pm_runtime_work
      Call Trace:
       schedule+0x28/0x80
       schedule_timeout+0x1e3/0x370
       wait_for_completion+0x123/0x190
       flush_work+0x142/0x1c0
       nouveau_pmops_runtime_suspend+0x7e/0xd0 [nouveau]
       pci_pm_runtime_suspend+0x5c/0x180
       vga_switcheroo_runtime_suspend+0x1e/0xa0
       __rpm_callback+0xc1/0x200
       rpm_callback+0x1f/0x70
       rpm_suspend+0x13c/0x640
       pm_runtime_work+0x6e/0x90
       process_one_work+0x184/0x380
       worker_thread+0x2e/0x390
    
    Bugzilla: https://bugs.archlinux.org/task/53497
    Bugzilla: https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=870523
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=70388#c33
    Fixes: 5addcf0a5f0f ("nouveau: add runtime PM support (v0.9)")
    Cc: stable@vger.kernel.org # v3.12+: 27d4ee03078a: workqueue: Allow retrieval of current task's work struct
    Cc: stable@vger.kernel.org # v3.12+: 25c058ccaf2e: drm: Allow determining if current task is output poll worker
    Cc: Ben Skeggs <bskeggs@redhat.com>
    Cc: Dave Airlie <airlied@redhat.com>
    Reviewed-by: Lyude Paul <lyude@redhat.com>
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Link: https://patchwork.freedesktop.org/patch/msgid/b7d2cbb609a80f59ccabfdf479b9d5907c603ea1.1518338789.git.lukas@wunner.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 9c1508eff805c81e81be88dec99dccc36c59fd4c
Author: Lukas Wunner <lukas@wunner.de>
Date:   Sun Feb 11 10:38:28 2018 +0100

    drm/radeon: Fix deadlock on runtime suspend
    
    commit 15734feff2bdac24aa3266c437cffa42851990e3 upstream.
    
    radeon's ->runtime_suspend hook calls drm_kms_helper_poll_disable(),
    which waits for the output poll worker to finish if it's running.
    
    The output poll worker meanwhile calls pm_runtime_get_sync() in
    radeon's ->detect hooks, which waits for the ongoing suspend to finish,
    causing a deadlock.
    
    Fix by not acquiring a runtime PM ref if the ->detect hooks are called
    in the output poll worker's context.  This is safe because the poll
    worker is only enabled while runtime active and we know that
    ->runtime_suspend waits for it to finish.
    
    Stack trace for posterity:
    
      INFO: task kworker/0:3:31847 blocked for more than 120 seconds
      Workqueue: events output_poll_execute [drm_kms_helper]
      Call Trace:
       schedule+0x3c/0x90
       rpm_resume+0x1e2/0x690
       __pm_runtime_resume+0x3f/0x60
       radeon_lvds_detect+0x39/0xf0 [radeon]
       output_poll_execute+0xda/0x1e0 [drm_kms_helper]
       process_one_work+0x14b/0x440
       worker_thread+0x48/0x4a0
    
      INFO: task kworker/2:0:10493 blocked for more than 120 seconds.
      Workqueue: pm pm_runtime_work
      Call Trace:
       schedule+0x3c/0x90
       schedule_timeout+0x1b3/0x240
       wait_for_common+0xc2/0x180
       wait_for_completion+0x1d/0x20
       flush_work+0xfc/0x1a0
       __cancel_work_timer+0xa5/0x1d0
       cancel_delayed_work_sync+0x13/0x20
       drm_kms_helper_poll_disable+0x1f/0x30 [drm_kms_helper]
       radeon_pmops_runtime_suspend+0x3d/0xa0 [radeon]
       pci_pm_runtime_suspend+0x61/0x1a0
       vga_switcheroo_runtime_suspend+0x21/0x70
       __rpm_callback+0x32/0x70
       rpm_callback+0x24/0x80
       rpm_suspend+0x12b/0x640
       pm_runtime_work+0x6f/0xb0
       process_one_work+0x14b/0x440
       worker_thread+0x48/0x4a0
    
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=94147
    Fixes: 10ebc0bc0934 ("drm/radeon: add runtime PM support (v2)")
    Cc: stable@vger.kernel.org # v3.13+: 27d4ee03078a: workqueue: Allow retrieval of current task's work struct
    Cc: stable@vger.kernel.org # v3.13+: 25c058ccaf2e: drm: Allow determining if current task is output poll worker
    Cc: Ismo Toijala <ismo.toijala@gmail.com>
    Cc: Alex Deucher <alexander.deucher@amd.com>
    Cc: Dave Airlie <airlied@redhat.com>
    Reviewed-by: Lyude Paul <lyude@redhat.com>
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Link: https://patchwork.freedesktop.org/patch/msgid/64ea02c44f91dda19bc563902b97bbc699040392.1518338789.git.lukas@wunner.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 8c13b37c887db3531970f31955d6b0445061995a
Author: Lukas Wunner <lukas@wunner.de>
Date:   Sun Feb 11 10:38:28 2018 +0100

    drm/nouveau: Fix deadlock on runtime suspend
    
    commit d61a5c1063515e855bedb1b81e20e50b0ac3541e upstream.
    
    nouveau's ->runtime_suspend hook calls drm_kms_helper_poll_disable(),
    which waits for the output poll worker to finish if it's running.
    
    The output poll worker meanwhile calls pm_runtime_get_sync() in
    nouveau_connector_detect() which waits for the ongoing suspend to finish,
    causing a deadlock.
    
    Fix by not acquiring a runtime PM ref if nouveau_connector_detect() is
    called in the output poll worker's context.  This is safe because
    the poll worker is only enabled while runtime active and we know that
    ->runtime_suspend waits for it to finish.
    
    Other contexts calling nouveau_connector_detect() do require a runtime
    PM ref, these comprise:
    
      status_store() drm sysfs interface
      ->fill_modes drm callback
      drm_fb_helper_probe_connector_modes()
      drm_mode_getconnector()
      nouveau_connector_hotplug()
      nouveau_display_hpd_work()
      nv17_tv_set_property()
    
    Stack trace for posterity:
    
      INFO: task kworker/0:1:58 blocked for more than 120 seconds.
      Workqueue: events output_poll_execute [drm_kms_helper]
      Call Trace:
       schedule+0x28/0x80
       rpm_resume+0x107/0x6e0
       __pm_runtime_resume+0x47/0x70
       nouveau_connector_detect+0x7e/0x4a0 [nouveau]
       nouveau_connector_detect_lvds+0x132/0x180 [nouveau]
       drm_helper_probe_detect_ctx+0x85/0xd0 [drm_kms_helper]
       output_poll_execute+0x11e/0x1c0 [drm_kms_helper]
       process_one_work+0x184/0x380
       worker_thread+0x2e/0x390
    
      INFO: task kworker/0:2:252 blocked for more than 120 seconds.
      Workqueue: pm pm_runtime_work
      Call Trace:
       schedule+0x28/0x80
       schedule_timeout+0x1e3/0x370
       wait_for_completion+0x123/0x190
       flush_work+0x142/0x1c0
       nouveau_pmops_runtime_suspend+0x7e/0xd0 [nouveau]
       pci_pm_runtime_suspend+0x5c/0x180
       vga_switcheroo_runtime_suspend+0x1e/0xa0
       __rpm_callback+0xc1/0x200
       rpm_callback+0x1f/0x70
       rpm_suspend+0x13c/0x640
       pm_runtime_work+0x6e/0x90
       process_one_work+0x184/0x380
       worker_thread+0x2e/0x390
    
    Bugzilla: https://bugs.archlinux.org/task/53497
    Bugzilla: https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=870523
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=70388#c33
    Fixes: 5addcf0a5f0f ("nouveau: add runtime PM support (v0.9)")
    Cc: stable@vger.kernel.org # v3.12+: 27d4ee03078a: workqueue: Allow retrieval of current task's work struct
    Cc: stable@vger.kernel.org # v3.12+: 25c058ccaf2e: drm: Allow determining if current task is output poll worker
    Cc: Ben Skeggs <bskeggs@redhat.com>
    Cc: Dave Airlie <airlied@redhat.com>
    Reviewed-by: Lyude Paul <lyude@redhat.com>
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Link: https://patchwork.freedesktop.org/patch/msgid/b7d2cbb609a80f59ccabfdf479b9d5907c603ea1.1518338789.git.lukas@wunner.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit f8ba22a39e985c93e278709b1d5f20857a26b49b
Author: Vivek Gautam <vivek.gautam@codeaurora.org>
Date:   Tue Jan 16 16:26:56 2018 +0530

    phy: qcom-qmp: Fix phy pipe clock gating
    
    Pipe clock comes out of the phy and is available as long as
    the phy is turned on. Clock controller fails to gate this
    clock after the phy is turned off and generates a warning.
    
    / # [   33.048561] gcc_usb3_phy_pipe_clk status stuck at 'on'
    [   33.048585] ------------[ cut here ]------------
    [   33.052621] WARNING: CPU: 1 PID: 18 at ../drivers/clk/qcom/clk-branch.c:97 clk_branch_wait+0xf0/0x108
    [   33.057384] Modules linked in:
    [   33.066497] CPU: 1 PID: 18 Comm: kworker/1:0 Tainted: G        W       4.12.0-rc7-00024-gfe926e34c36d-dirty #96
    [   33.069451] Hardware name: Qualcomm Technologies, Inc. DB820c (DT)
    ...
    [   33.278565] [<ffff00000849b27c>] clk_branch_wait+0xf0/0x108
    [   33.286375] [<ffff00000849b2f4>] clk_branch2_disable+0x28/0x34
    [   33.291761] [<ffff0000084868dc>] clk_core_disable+0x5c/0x88
    [   33.297660] [<ffff000008487d68>] clk_core_disable_lock+0x20/0x34
    [   33.303129] [<ffff000008487d98>] clk_disable+0x1c/0x24
    [   33.309384] [<ffff0000083ccd78>] qcom_qmp_phy_poweroff+0x20/0x48
    [   33.314328] [<ffff0000083c53f4>] phy_power_off+0x80/0xdc
    [   33.320492] [<ffff00000875c950>] dwc3_core_exit+0x94/0xa0
    [   33.325784] [<ffff00000875c9ac>] dwc3_suspend_common+0x50/0x60
    [   33.331080] [<ffff00000875ca04>] dwc3_runtime_suspend+0x48/0x6c
    [   33.336810] [<ffff0000085b82f4>] pm_generic_runtime_suspend+0x28/0x38
    [   33.342627] [<ffff0000085bace0>] __rpm_callback+0x150/0x254
    [   33.349222] [<ffff0000085bae08>] rpm_callback+0x24/0x78
    [   33.354604] [<ffff0000085b9fd8>] rpm_suspend+0xe0/0x4e4
    [   33.359813] [<ffff0000085bb784>] pm_runtime_work+0xdc/0xf0
    [   33.365028] [<ffff0000080d7b30>] process_one_work+0x12c/0x28c
    [   33.370576] [<ffff0000080d7ce8>] worker_thread+0x58/0x3b8
    [   33.376393] [<ffff0000080dd4a8>] kthread+0x100/0x12c
    [   33.381776] [<ffff0000080836c0>] ret_from_fork+0x10/0x50
    
    Fix this by disabling it as the first thing in phy_exit().
    
    Fixes: e78f3d15e115 ("phy: qcom-qmp: new qmp phy driver for qcom-chipsets")
    Signed-off-by: Vivek Gautam <vivek.gautam@codeaurora.org>
    Signed-off-by: Manu Gautam <mgautam@codeaurora.org>
    Signed-off-by: Kishon Vijay Abraham I <kishon@ti.com>

commit 15734feff2bdac24aa3266c437cffa42851990e3
Author: Lukas Wunner <lukas@wunner.de>
Date:   Sun Feb 11 10:38:28 2018 +0100

    drm/radeon: Fix deadlock on runtime suspend
    
    radeon's ->runtime_suspend hook calls drm_kms_helper_poll_disable(),
    which waits for the output poll worker to finish if it's running.
    
    The output poll worker meanwhile calls pm_runtime_get_sync() in
    radeon's ->detect hooks, which waits for the ongoing suspend to finish,
    causing a deadlock.
    
    Fix by not acquiring a runtime PM ref if the ->detect hooks are called
    in the output poll worker's context.  This is safe because the poll
    worker is only enabled while runtime active and we know that
    ->runtime_suspend waits for it to finish.
    
    Stack trace for posterity:
    
      INFO: task kworker/0:3:31847 blocked for more than 120 seconds
      Workqueue: events output_poll_execute [drm_kms_helper]
      Call Trace:
       schedule+0x3c/0x90
       rpm_resume+0x1e2/0x690
       __pm_runtime_resume+0x3f/0x60
       radeon_lvds_detect+0x39/0xf0 [radeon]
       output_poll_execute+0xda/0x1e0 [drm_kms_helper]
       process_one_work+0x14b/0x440
       worker_thread+0x48/0x4a0
    
      INFO: task kworker/2:0:10493 blocked for more than 120 seconds.
      Workqueue: pm pm_runtime_work
      Call Trace:
       schedule+0x3c/0x90
       schedule_timeout+0x1b3/0x240
       wait_for_common+0xc2/0x180
       wait_for_completion+0x1d/0x20
       flush_work+0xfc/0x1a0
       __cancel_work_timer+0xa5/0x1d0
       cancel_delayed_work_sync+0x13/0x20
       drm_kms_helper_poll_disable+0x1f/0x30 [drm_kms_helper]
       radeon_pmops_runtime_suspend+0x3d/0xa0 [radeon]
       pci_pm_runtime_suspend+0x61/0x1a0
       vga_switcheroo_runtime_suspend+0x21/0x70
       __rpm_callback+0x32/0x70
       rpm_callback+0x24/0x80
       rpm_suspend+0x12b/0x640
       pm_runtime_work+0x6f/0xb0
       process_one_work+0x14b/0x440
       worker_thread+0x48/0x4a0
    
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=94147
    Fixes: 10ebc0bc0934 ("drm/radeon: add runtime PM support (v2)")
    Cc: stable@vger.kernel.org # v3.13+: 27d4ee03078a: workqueue: Allow retrieval of current task's work struct
    Cc: stable@vger.kernel.org # v3.13+: 25c058ccaf2e: drm: Allow determining if current task is output poll worker
    Cc: Ismo Toijala <ismo.toijala@gmail.com>
    Cc: Alex Deucher <alexander.deucher@amd.com>
    Cc: Dave Airlie <airlied@redhat.com>
    Reviewed-by: Lyude Paul <lyude@redhat.com>
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Link: https://patchwork.freedesktop.org/patch/msgid/64ea02c44f91dda19bc563902b97bbc699040392.1518338789.git.lukas@wunner.de

commit d61a5c1063515e855bedb1b81e20e50b0ac3541e
Author: Lukas Wunner <lukas@wunner.de>
Date:   Sun Feb 11 10:38:28 2018 +0100

    drm/nouveau: Fix deadlock on runtime suspend
    
    nouveau's ->runtime_suspend hook calls drm_kms_helper_poll_disable(),
    which waits for the output poll worker to finish if it's running.
    
    The output poll worker meanwhile calls pm_runtime_get_sync() in
    nouveau_connector_detect() which waits for the ongoing suspend to finish,
    causing a deadlock.
    
    Fix by not acquiring a runtime PM ref if nouveau_connector_detect() is
    called in the output poll worker's context.  This is safe because
    the poll worker is only enabled while runtime active and we know that
    ->runtime_suspend waits for it to finish.
    
    Other contexts calling nouveau_connector_detect() do require a runtime
    PM ref, these comprise:
    
      status_store() drm sysfs interface
      ->fill_modes drm callback
      drm_fb_helper_probe_connector_modes()
      drm_mode_getconnector()
      nouveau_connector_hotplug()
      nouveau_display_hpd_work()
      nv17_tv_set_property()
    
    Stack trace for posterity:
    
      INFO: task kworker/0:1:58 blocked for more than 120 seconds.
      Workqueue: events output_poll_execute [drm_kms_helper]
      Call Trace:
       schedule+0x28/0x80
       rpm_resume+0x107/0x6e0
       __pm_runtime_resume+0x47/0x70
       nouveau_connector_detect+0x7e/0x4a0 [nouveau]
       nouveau_connector_detect_lvds+0x132/0x180 [nouveau]
       drm_helper_probe_detect_ctx+0x85/0xd0 [drm_kms_helper]
       output_poll_execute+0x11e/0x1c0 [drm_kms_helper]
       process_one_work+0x184/0x380
       worker_thread+0x2e/0x390
    
      INFO: task kworker/0:2:252 blocked for more than 120 seconds.
      Workqueue: pm pm_runtime_work
      Call Trace:
       schedule+0x28/0x80
       schedule_timeout+0x1e3/0x370
       wait_for_completion+0x123/0x190
       flush_work+0x142/0x1c0
       nouveau_pmops_runtime_suspend+0x7e/0xd0 [nouveau]
       pci_pm_runtime_suspend+0x5c/0x180
       vga_switcheroo_runtime_suspend+0x1e/0xa0
       __rpm_callback+0xc1/0x200
       rpm_callback+0x1f/0x70
       rpm_suspend+0x13c/0x640
       pm_runtime_work+0x6e/0x90
       process_one_work+0x184/0x380
       worker_thread+0x2e/0x390
    
    Bugzilla: https://bugs.archlinux.org/task/53497
    Bugzilla: https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=870523
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=70388#c33
    Fixes: 5addcf0a5f0f ("nouveau: add runtime PM support (v0.9)")
    Cc: stable@vger.kernel.org # v3.12+: 27d4ee03078a: workqueue: Allow retrieval of current task's work struct
    Cc: stable@vger.kernel.org # v3.12+: 25c058ccaf2e: drm: Allow determining if current task is output poll worker
    Cc: Ben Skeggs <bskeggs@redhat.com>
    Cc: Dave Airlie <airlied@redhat.com>
    Reviewed-by: Lyude Paul <lyude@redhat.com>
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Link: https://patchwork.freedesktop.org/patch/msgid/b7d2cbb609a80f59ccabfdf479b9d5907c603ea1.1518338789.git.lukas@wunner.de

commit 69728051f5bf15efaf6edfbcfe1b5a49a2437918
Author: Tony Lindgren <tony@atomide.com>
Date:   Fri Feb 9 08:11:26 2018 -0800

    PM / wakeirq: Fix unbalanced IRQ enable for wakeirq
    
    If a device is runtime PM suspended when we enter suspend and has
    a dedicated wake IRQ, we can get the following warning:
    
    WARNING: CPU: 0 PID: 108 at kernel/irq/manage.c:526 enable_irq+0x40/0x94
    [  102.087860] Unbalanced enable for IRQ 147
    ...
    (enable_irq) from [<c06117a8>] (dev_pm_arm_wake_irq+0x4c/0x60)
    (dev_pm_arm_wake_irq) from [<c0618360>]
     (device_wakeup_arm_wake_irqs+0x58/0x9c)
    (device_wakeup_arm_wake_irqs) from [<c0615948>]
    (dpm_suspend_noirq+0x10/0x48)
    (dpm_suspend_noirq) from [<c01ac7ac>]
    (suspend_devices_and_enter+0x30c/0xf14)
    (suspend_devices_and_enter) from [<c01adf20>]
    (enter_state+0xad4/0xbd8)
    (enter_state) from [<c01ad3ec>] (pm_suspend+0x38/0x98)
    (pm_suspend) from [<c01ab3e8>] (state_store+0x68/0xc8)
    
    This is because the dedicated wake IRQ for the device may have been
    already enabled earlier by dev_pm_enable_wake_irq_check().  Fix the
    issue by checking for runtime PM suspended status.
    
    This issue can be easily reproduced by setting serial console log level
    to zero, letting the serial console idle, and suspend the system from
    an ssh terminal.  On resume, dmesg will have the warning above.
    
    The reason why I have not run into this issue earlier has been that I
    typically run my PM test cases from on a serial console instead over ssh.
    
    Fixes: c84345597558 (PM / wakeirq: Enable dedicated wakeirq for suspend)
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 703cbaa601ff3fb554d1246c336ba727cc083ea0
Author: Bo Yan <byan@nvidia.com>
Date:   Tue Jan 23 13:57:55 2018 -0800

    cpufreq: Skip cpufreq resume if it's not suspended
    
    cpufreq_resume can be called even without preceding cpufreq_suspend.
    This can happen in following scenario:
    
        suspend_devices_and_enter
           --> dpm_suspend_start
              --> dpm_prepare
                  --> device_prepare : this function errors out
              --> dpm_suspend: this is skipped due to dpm_prepare failure
                               this means cpufreq_suspend is skipped over
           --> goto Recover_platform, due to previous error
           --> goto Resume_devices
           --> dpm_resume_end
               --> dpm_resume
                   --> cpufreq_resume
    
    In case schedutil is used as frequency governor, cpufreq_resume will
    eventually call sugov_start, which does following:
    
        memset(sg_cpu, 0, sizeof(*sg_cpu));
        ....
    
    This effectively erases function pointer for frequency update, causing
    crash later on. The function pointer would have been set correctly if
    subsequent cpufreq_add_update_util_hook runs successfully, but that
    function returns earlier because cpufreq_suspend was not called:
    
        if (WARN_ON(per_cpu(cpufreq_update_util_data, cpu)))
                    return;
    
    The fix is to check cpufreq_suspended first, if it's false, that means
    cpufreq_suspend was not called in the first place, so do not resume
    cpufreq.
    
    Signed-off-by: Bo Yan <byan@nvidia.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    [ rjw: Dropped printing a message ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 203dab8395d9a6b195cbadfec59ae4899aea13f9
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Dec 18 14:45:51 2017 +0100

    wil6210: fix build warnings without CONFIG_PM
    
    The #ifdef checks are hard to get right, in this case some functions
    should have been left inside a CONFIG_PM_SLEEP check as seen by this
    message:
    
    drivers/net/wireless/ath/wil6210/pcie_bus.c:489:12: error: 'wil6210_pm_resume' defined but not used [-Werror=unused-function]
    drivers/net/wireless/ath/wil6210/pcie_bus.c:484:12: error: 'wil6210_pm_suspend' defined but not used [-Werror=unused-function]
    
    Using an __maybe_unused is easier here, so I'm replacing all the
    other #ifdef in this file as well for consistency.
    
    Fixes: 94162666cd51 ("wil6210: run-time PM when interface down")
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Kalle Valo <kvalo@qca.qualcomm.com>

commit f93b123370688313fb3624aa7cb3ebfc6019c24e
Author: Andrey Konovalov <andreyknvl@google.com>
Date:   Mon Nov 6 13:26:46 2017 +0100

    net: usb: asix: fill null-ptr-deref in asix_suspend
    
    
    [ Upstream commit 8f5624629105589bcc23d0e51cc01bd8103d09a5 ]
    
    When asix_suspend() is called dev->driver_priv might not have been
    assigned a value, so we need to check that it's not NULL.
    
    Similar issue is present in asix_resume(), this patch fixes it as well.
    
    Found by syzkaller.
    
    kasan: CONFIG_KASAN_INLINE enabled
    kasan: GPF could be caused by NULL-ptr deref or user memory access
    general protection fault: 0000 [#1] PREEMPT SMP KASAN
    Modules linked in:
    CPU: 0 PID: 24 Comm: kworker/0:1 Not tainted 4.14.0-rc4-43422-geccacdd69a8c #400
    Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Bochs 01/01/2011
    Workqueue: usb_hub_wq hub_event
    task: ffff88006bb36300 task.stack: ffff88006bba8000
    RIP: 0010:asix_suspend+0x76/0xc0 drivers/net/usb/asix_devices.c:629
    RSP: 0018:ffff88006bbae718 EFLAGS: 00010202
    RAX: dffffc0000000000 RBX: ffff880061ba3b80 RCX: 1ffff1000c34d644
    RDX: 0000000000000001 RSI: 0000000000000402 RDI: 0000000000000008
    RBP: ffff88006bbae738 R08: 1ffff1000d775cad R09: 0000000000000000
    R10: 0000000000000000 R11: 0000000000000000 R12: ffff8800630a8b40
    R13: 0000000000000000 R14: 0000000000000402 R15: ffff880061ba3b80
    FS:  0000000000000000(0000) GS:ffff88006c600000(0000) knlGS:0000000000000000
    CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    CR2: 00007ff33cf89000 CR3: 0000000061c0a000 CR4: 00000000000006f0
    Call Trace:
     usb_suspend_interface drivers/usb/core/driver.c:1209
     usb_suspend_both+0x27f/0x7e0 drivers/usb/core/driver.c:1314
     usb_runtime_suspend+0x41/0x120 drivers/usb/core/driver.c:1852
     __rpm_callback+0x339/0xb60 drivers/base/power/runtime.c:334
     rpm_callback+0x106/0x220 drivers/base/power/runtime.c:461
     rpm_suspend+0x465/0x1980 drivers/base/power/runtime.c:596
     __pm_runtime_suspend+0x11e/0x230 drivers/base/power/runtime.c:1009
     pm_runtime_put_sync_autosuspend ./include/linux/pm_runtime.h:251
     usb_new_device+0xa37/0x1020 drivers/usb/core/hub.c:2487
     hub_port_connect drivers/usb/core/hub.c:4903
     hub_port_connect_change drivers/usb/core/hub.c:5009
     port_event drivers/usb/core/hub.c:5115
     hub_event+0x194d/0x3740 drivers/usb/core/hub.c:5195
     process_one_work+0xc7f/0x1db0 kernel/workqueue.c:2119
     worker_thread+0x221/0x1850 kernel/workqueue.c:2253
     kthread+0x3a1/0x470 kernel/kthread.c:231
     ret_from_fork+0x2a/0x40 arch/x86/entry/entry_64.S:431
    Code: 8d 7c 24 20 48 89 fa 48 c1 ea 03 80 3c 02 00 75 5b 48 b8 00 00
    00 00 00 fc ff df 4d 8b 6c 24 20 49 8d 7d 08 48 89 fa 48 c1 ea 03 <80>
    3c 02 00 75 34 4d 8b 6d 08 4d 85 ed 74 0b e8 26 2b 51 fd 4c
    RIP: asix_suspend+0x76/0xc0 RSP: ffff88006bbae718
    ---[ end trace dfc4f5649284342c ]---
    
    Signed-off-by: Andrey Konovalov <andreyknvl@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 58baa36d3728eea14884f74817d5749b32b0cdeb
Author: Andrey Konovalov <andreyknvl@google.com>
Date:   Mon Nov 6 13:26:46 2017 +0100

    net: usb: asix: fill null-ptr-deref in asix_suspend
    
    
    [ Upstream commit 8f5624629105589bcc23d0e51cc01bd8103d09a5 ]
    
    When asix_suspend() is called dev->driver_priv might not have been
    assigned a value, so we need to check that it's not NULL.
    
    Similar issue is present in asix_resume(), this patch fixes it as well.
    
    Found by syzkaller.
    
    kasan: CONFIG_KASAN_INLINE enabled
    kasan: GPF could be caused by NULL-ptr deref or user memory access
    general protection fault: 0000 [#1] PREEMPT SMP KASAN
    Modules linked in:
    CPU: 0 PID: 24 Comm: kworker/0:1 Not tainted 4.14.0-rc4-43422-geccacdd69a8c #400
    Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Bochs 01/01/2011
    Workqueue: usb_hub_wq hub_event
    task: ffff88006bb36300 task.stack: ffff88006bba8000
    RIP: 0010:asix_suspend+0x76/0xc0 drivers/net/usb/asix_devices.c:629
    RSP: 0018:ffff88006bbae718 EFLAGS: 00010202
    RAX: dffffc0000000000 RBX: ffff880061ba3b80 RCX: 1ffff1000c34d644
    RDX: 0000000000000001 RSI: 0000000000000402 RDI: 0000000000000008
    RBP: ffff88006bbae738 R08: 1ffff1000d775cad R09: 0000000000000000
    R10: 0000000000000000 R11: 0000000000000000 R12: ffff8800630a8b40
    R13: 0000000000000000 R14: 0000000000000402 R15: ffff880061ba3b80
    FS:  0000000000000000(0000) GS:ffff88006c600000(0000) knlGS:0000000000000000
    CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    CR2: 00007ff33cf89000 CR3: 0000000061c0a000 CR4: 00000000000006f0
    Call Trace:
     usb_suspend_interface drivers/usb/core/driver.c:1209
     usb_suspend_both+0x27f/0x7e0 drivers/usb/core/driver.c:1314
     usb_runtime_suspend+0x41/0x120 drivers/usb/core/driver.c:1852
     __rpm_callback+0x339/0xb60 drivers/base/power/runtime.c:334
     rpm_callback+0x106/0x220 drivers/base/power/runtime.c:461
     rpm_suspend+0x465/0x1980 drivers/base/power/runtime.c:596
     __pm_runtime_suspend+0x11e/0x230 drivers/base/power/runtime.c:1009
     pm_runtime_put_sync_autosuspend ./include/linux/pm_runtime.h:251
     usb_new_device+0xa37/0x1020 drivers/usb/core/hub.c:2487
     hub_port_connect drivers/usb/core/hub.c:4903
     hub_port_connect_change drivers/usb/core/hub.c:5009
     port_event drivers/usb/core/hub.c:5115
     hub_event+0x194d/0x3740 drivers/usb/core/hub.c:5195
     process_one_work+0xc7f/0x1db0 kernel/workqueue.c:2119
     worker_thread+0x221/0x1850 kernel/workqueue.c:2253
     kthread+0x3a1/0x470 kernel/kthread.c:231
     ret_from_fork+0x2a/0x40 arch/x86/entry/entry_64.S:431
    Code: 8d 7c 24 20 48 89 fa 48 c1 ea 03 80 3c 02 00 75 5b 48 b8 00 00
    00 00 00 fc ff df 4d 8b 6c 24 20 49 8d 7d 08 48 89 fa 48 c1 ea 03 <80>
    3c 02 00 75 34 4d 8b 6d 08 4d 85 ed 74 0b e8 26 2b 51 fd 4c
    RIP: asix_suspend+0x76/0xc0 RSP: ffff88006bbae718
    ---[ end trace dfc4f5649284342c ]---
    
    Signed-off-by: Andrey Konovalov <andreyknvl@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 8f5624629105589bcc23d0e51cc01bd8103d09a5
Author: Andrey Konovalov <andreyknvl@google.com>
Date:   Mon Nov 6 13:26:46 2017 +0100

    net: usb: asix: fill null-ptr-deref in asix_suspend
    
    When asix_suspend() is called dev->driver_priv might not have been
    assigned a value, so we need to check that it's not NULL.
    
    Similar issue is present in asix_resume(), this patch fixes it as well.
    
    Found by syzkaller.
    
    kasan: CONFIG_KASAN_INLINE enabled
    kasan: GPF could be caused by NULL-ptr deref or user memory access
    general protection fault: 0000 [#1] PREEMPT SMP KASAN
    Modules linked in:
    CPU: 0 PID: 24 Comm: kworker/0:1 Not tainted 4.14.0-rc4-43422-geccacdd69a8c #400
    Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Bochs 01/01/2011
    Workqueue: usb_hub_wq hub_event
    task: ffff88006bb36300 task.stack: ffff88006bba8000
    RIP: 0010:asix_suspend+0x76/0xc0 drivers/net/usb/asix_devices.c:629
    RSP: 0018:ffff88006bbae718 EFLAGS: 00010202
    RAX: dffffc0000000000 RBX: ffff880061ba3b80 RCX: 1ffff1000c34d644
    RDX: 0000000000000001 RSI: 0000000000000402 RDI: 0000000000000008
    RBP: ffff88006bbae738 R08: 1ffff1000d775cad R09: 0000000000000000
    R10: 0000000000000000 R11: 0000000000000000 R12: ffff8800630a8b40
    R13: 0000000000000000 R14: 0000000000000402 R15: ffff880061ba3b80
    FS:  0000000000000000(0000) GS:ffff88006c600000(0000) knlGS:0000000000000000
    CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    CR2: 00007ff33cf89000 CR3: 0000000061c0a000 CR4: 00000000000006f0
    Call Trace:
     usb_suspend_interface drivers/usb/core/driver.c:1209
     usb_suspend_both+0x27f/0x7e0 drivers/usb/core/driver.c:1314
     usb_runtime_suspend+0x41/0x120 drivers/usb/core/driver.c:1852
     __rpm_callback+0x339/0xb60 drivers/base/power/runtime.c:334
     rpm_callback+0x106/0x220 drivers/base/power/runtime.c:461
     rpm_suspend+0x465/0x1980 drivers/base/power/runtime.c:596
     __pm_runtime_suspend+0x11e/0x230 drivers/base/power/runtime.c:1009
     pm_runtime_put_sync_autosuspend ./include/linux/pm_runtime.h:251
     usb_new_device+0xa37/0x1020 drivers/usb/core/hub.c:2487
     hub_port_connect drivers/usb/core/hub.c:4903
     hub_port_connect_change drivers/usb/core/hub.c:5009
     port_event drivers/usb/core/hub.c:5115
     hub_event+0x194d/0x3740 drivers/usb/core/hub.c:5195
     process_one_work+0xc7f/0x1db0 kernel/workqueue.c:2119
     worker_thread+0x221/0x1850 kernel/workqueue.c:2253
     kthread+0x3a1/0x470 kernel/kthread.c:231
     ret_from_fork+0x2a/0x40 arch/x86/entry/entry_64.S:431
    Code: 8d 7c 24 20 48 89 fa 48 c1 ea 03 80 3c 02 00 75 5b 48 b8 00 00
    00 00 00 fc ff df 4d 8b 6c 24 20 49 8d 7d 08 48 89 fa 48 c1 ea 03 <80>
    3c 02 00 75 34 4d 8b 6d 08 4d 85 ed 74 0b e8 26 2b 51 fd 4c
    RIP: asix_suspend+0x76/0xc0 RSP: ffff88006bbae718
    ---[ end trace dfc4f5649284342c ]---
    
    Signed-off-by: Andrey Konovalov <andreyknvl@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 7da4cd97f58be693edb2f7b89f3c58ded51f5ad2
Author: Grygorii Strashko <grygorii.strashko@ti.com>
Date:   Sat Oct 7 22:36:47 2017 +0000

    PM / wakeirq: report a wakeup_event on dedicated wekup irq
    
    
    [ Upstream commit 09bb6e93956ae5175b96905b723ec879c3ca0765 ]
    
    There are two reasons for reporting wakeup event when dedicated wakeup
    IRQ is triggered:
    
    - wakeup events accounting, so proper statistical data will be
      displayed in sysfs and debugfs;
    
    - there are small window when System is entering suspend during which
      dedicated wakeup IRQ can be lost:
    
    dpm_suspend_noirq()
      |- device_wakeup_arm_wake_irqs()
          |- dev_pm_arm_wake_irq(X)
             |- IRQ is enabled and marked as wakeup source
    [1]...
      |- suspend_device_irqs()
         |- suspend_device_irq(X)
            |- irqd_set(X, IRQD_WAKEUP_ARMED);
               |- wakup IRQ armed
    
    The wakeup IRQ can be lost if it's triggered at point [1]
    and not armed yet.
    
    Hence, fix above cases by adding simple pm_wakeup_event() call in
    handle_threaded_wake_irq().
    
    Fixes: 4990d4fe327b (PM / Wakeirq: Add automated device wake IRQ handling)
    Signed-off-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Tested-by: Keerthy <j-keerthy@ti.com>
    [ tony@atomide.com: added missing return to avoid warnings ]
    Tested-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    
    Signed-off-by: Sasha Levin <alexander.levin@verizon.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit ba28f16cfa2a410ba8aff60c2918417b91e05871
Author: Grygorii Strashko <grygorii.strashko@ti.com>
Date:   Sat Oct 7 22:37:43 2017 +0000

    PM / wakeirq: report a wakeup_event on dedicated wekup irq
    
    
    [ Upstream commit 09bb6e93956ae5175b96905b723ec879c3ca0765 ]
    
    There are two reasons for reporting wakeup event when dedicated wakeup
    IRQ is triggered:
    
    - wakeup events accounting, so proper statistical data will be
      displayed in sysfs and debugfs;
    
    - there are small window when System is entering suspend during which
      dedicated wakeup IRQ can be lost:
    
    dpm_suspend_noirq()
      |- device_wakeup_arm_wake_irqs()
          |- dev_pm_arm_wake_irq(X)
             |- IRQ is enabled and marked as wakeup source
    [1]...
      |- suspend_device_irqs()
         |- suspend_device_irq(X)
            |- irqd_set(X, IRQD_WAKEUP_ARMED);
               |- wakup IRQ armed
    
    The wakeup IRQ can be lost if it's triggered at point [1]
    and not armed yet.
    
    Hence, fix above cases by adding simple pm_wakeup_event() call in
    handle_threaded_wake_irq().
    
    Fixes: 4990d4fe327b (PM / Wakeirq: Add automated device wake IRQ handling)
    Signed-off-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Tested-by: Keerthy <j-keerthy@ti.com>
    [ tony@atomide.com: added missing return to avoid warnings ]
    Tested-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    
    Signed-off-by: Sasha Levin <alexander.levin@verizon.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit c4b65157aeefad29b2351a00a010e8c40ce7fd0e
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Oct 26 12:12:22 2017 +0200

    PCI / PM: Take SMART_SUSPEND driver flag into account
    
    Make the PCI bus type take DPM_FLAG_SMART_SUSPEND into account in its
    system-wide PM callbacks and make sure that all code that should not
    run in parallel with pci_pm_runtime_resume() is executed in the "late"
    phases of system suspend, freeze and poweroff transitions.
    
    [Note that the pm_runtime_suspended() check in pci_dev_keep_suspended()
    is an optimization, because if is not passed, all of the subsequent
    checks may be skipped and some of them are much more overhead in
    general.]
    
    Also use the observation that if the device is in runtime suspend
    at the beginning of the "late" phase of a system-wide suspend-like
    transition, its state cannot change going forward (runtime PM is
    disabled for it at that time) until the transition is over and the
    subsequent system-wide PM callbacks should be skipped for it (as
    they generally assume the device to not be suspended), so add checks
    for that in pci_pm_suspend_late/noirq(), pci_pm_freeze_late/noirq()
    and pci_pm_poweroff_late/noirq().
    
    Moreover, if pci_pm_resume_noirq() or pci_pm_restore_noirq() is
    called during the subsequent system-wide resume transition and if
    the device was left in runtime suspend previously, its runtime PM
    status needs to be changed to "active" as it is going to be put
    into the full-power state, so add checks for that too to these
    functions.
    
    In turn, if pci_pm_thaw_noirq() runs after the device has been
    left in runtime suspend, the subsequent "thaw" callbacks need
    to be skipped for it (as they may not work correctly with a
    suspended device), so set the power.direct_complete flag for the
    device then to make the PM core skip those callbacks.
    
    In addition to the above add a core helper for checking if
    DPM_FLAG_SMART_SUSPEND is set and the device runtime PM status is
    "suspended" at the same time, which is done quite often in the new
    code (and will be done elsewhere going forward too).
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>

commit baedf68a068ca29624f241426843635920f16e1d
Author: Andrey Konovalov <andreyknvl@google.com>
Date:   Thu Nov 2 21:26:59 2017 +0100

    net: usb: asix: fill null-ptr-deref in asix_suspend
    
    When asix_suspend() is called dev->driver_priv might not have been
    assigned a value, so we need to check that it's not NULL.
    
    Found by syzkaller.
    
    kasan: CONFIG_KASAN_INLINE enabled
    kasan: GPF could be caused by NULL-ptr deref or user memory access
    general protection fault: 0000 [#1] PREEMPT SMP KASAN
    Modules linked in:
    CPU: 0 PID: 24 Comm: kworker/0:1 Not tainted 4.14.0-rc4-43422-geccacdd69a8c #400
    Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Bochs 01/01/2011
    Workqueue: usb_hub_wq hub_event
    task: ffff88006bb36300 task.stack: ffff88006bba8000
    RIP: 0010:asix_suspend+0x76/0xc0 drivers/net/usb/asix_devices.c:629
    RSP: 0018:ffff88006bbae718 EFLAGS: 00010202
    RAX: dffffc0000000000 RBX: ffff880061ba3b80 RCX: 1ffff1000c34d644
    RDX: 0000000000000001 RSI: 0000000000000402 RDI: 0000000000000008
    RBP: ffff88006bbae738 R08: 1ffff1000d775cad R09: 0000000000000000
    R10: 0000000000000000 R11: 0000000000000000 R12: ffff8800630a8b40
    R13: 0000000000000000 R14: 0000000000000402 R15: ffff880061ba3b80
    FS:  0000000000000000(0000) GS:ffff88006c600000(0000) knlGS:0000000000000000
    CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    CR2: 00007ff33cf89000 CR3: 0000000061c0a000 CR4: 00000000000006f0
    Call Trace:
     usb_suspend_interface drivers/usb/core/driver.c:1209
     usb_suspend_both+0x27f/0x7e0 drivers/usb/core/driver.c:1314
     usb_runtime_suspend+0x41/0x120 drivers/usb/core/driver.c:1852
     __rpm_callback+0x339/0xb60 drivers/base/power/runtime.c:334
     rpm_callback+0x106/0x220 drivers/base/power/runtime.c:461
     rpm_suspend+0x465/0x1980 drivers/base/power/runtime.c:596
     __pm_runtime_suspend+0x11e/0x230 drivers/base/power/runtime.c:1009
     pm_runtime_put_sync_autosuspend ./include/linux/pm_runtime.h:251
     usb_new_device+0xa37/0x1020 drivers/usb/core/hub.c:2487
     hub_port_connect drivers/usb/core/hub.c:4903
     hub_port_connect_change drivers/usb/core/hub.c:5009
     port_event drivers/usb/core/hub.c:5115
     hub_event+0x194d/0x3740 drivers/usb/core/hub.c:5195
     process_one_work+0xc7f/0x1db0 kernel/workqueue.c:2119
     worker_thread+0x221/0x1850 kernel/workqueue.c:2253
     kthread+0x3a1/0x470 kernel/kthread.c:231
     ret_from_fork+0x2a/0x40 arch/x86/entry/entry_64.S:431
    Code: 8d 7c 24 20 48 89 fa 48 c1 ea 03 80 3c 02 00 75 5b 48 b8 00 00
    00 00 00 fc ff df 4d 8b 6c 24 20 49 8d 7d 08 48 89 fa 48 c1 ea 03 <80>
    3c 02 00 75 34 4d 8b 6d 08 4d 85 ed 74 0b e8 26 2b 51 fd 4c
    RIP: asix_suspend+0x76/0xc0 RSP: ffff88006bbae718
    ---[ end trace dfc4f5649284342c ]---
    
    Signed-off-by: Andrey Konovalov <andreyknvl@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 072983423fe2a5e80bd070d1a43944bb023a0ec3
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Wed May 31 18:50:43 2017 +0300

    e1000e: Undo e1000e_pm_freeze if __e1000_shutdown fails
    
    commit 833521ebc65b1c3092e5c0d8a97092f98eec595d upstream.
    
    An error during suspend (e100e_pm_suspend),
    
    [  429.994338] ACPI : EC: event blocked
    [  429.994633] e1000e: EEE TX LPI TIMER: 00000011
    [  430.955451] pci_pm_suspend(): e1000e_pm_suspend+0x0/0x30 [e1000e] returns -2
    [  430.955454] dpm_run_callback(): pci_pm_suspend+0x0/0x140 returns -2
    [  430.955458] PM: Device 0000:00:19.0 failed to suspend async: error -2
    [  430.955581] PM: Some devices failed to suspend, or early wake event detected
    [  430.957709] ACPI : EC: event unblocked
    
    lead to complete failure:
    
    [  432.585002] ------------[ cut here ]------------
    [  432.585013] WARNING: CPU: 3 PID: 8372 at kernel/irq/manage.c:1478 __free_irq+0x9f/0x280
    [  432.585015] Trying to free already-free IRQ 20
    [  432.585016] Modules linked in: cdc_ncm usbnet x86_pkg_temp_thermal intel_powerclamp coretemp mii crct10dif_pclmul crc32_pclmul ghash_clmulni_intel snd_hda_codec_hdmi snd_hda_codec_realtek snd_hda_codec_generic snd_hda_intel snd_hda_codec snd_hwdep lpc_ich snd_hda_core snd_pcm mei_me mei sdhci_pci sdhci i915 mmc_core e1000e ptp pps_core prime_numbers
    [  432.585042] CPU: 3 PID: 8372 Comm: kworker/u16:40 Tainted: G     U          4.10.0-rc8-CI-Patchwork_3870+ #1
    [  432.585044] Hardware name: LENOVO 2356GCG/2356GCG, BIOS G7ET31WW (1.13 ) 07/02/2012
    [  432.585050] Workqueue: events_unbound async_run_entry_fn
    [  432.585051] Call Trace:
    [  432.585058]  dump_stack+0x67/0x92
    [  432.585062]  __warn+0xc6/0xe0
    [  432.585065]  warn_slowpath_fmt+0x4a/0x50
    [  432.585070]  ? _raw_spin_lock_irqsave+0x49/0x60
    [  432.585072]  __free_irq+0x9f/0x280
    [  432.585075]  free_irq+0x34/0x80
    [  432.585089]  e1000_free_irq+0x65/0x70 [e1000e]
    [  432.585098]  e1000e_pm_freeze+0x7a/0xb0 [e1000e]
    [  432.585106]  e1000e_pm_suspend+0x21/0x30 [e1000e]
    [  432.585113]  pci_pm_suspend+0x71/0x140
    [  432.585118]  dpm_run_callback+0x6f/0x330
    [  432.585122]  ? pci_pm_freeze+0xe0/0xe0
    [  432.585125]  __device_suspend+0xea/0x330
    [  432.585128]  async_suspend+0x1a/0x90
    [  432.585132]  async_run_entry_fn+0x34/0x160
    [  432.585137]  process_one_work+0x1f4/0x6d0
    [  432.585140]  ? process_one_work+0x16e/0x6d0
    [  432.585143]  worker_thread+0x49/0x4a0
    [  432.585145]  kthread+0x107/0x140
    [  432.585148]  ? process_one_work+0x6d0/0x6d0
    [  432.585150]  ? kthread_create_on_node+0x40/0x40
    [  432.585154]  ret_from_fork+0x2e/0x40
    [  432.585156] ---[ end trace 6712df7f8c4b9124 ]---
    
    The unwind failures stems from commit 2800209994f8 ("e1000e: Refactor PM
    flows"), but it may be a later patch that introduced the non-recoverable
    behaviour.
    
    Fixes: 2800209994f8 ("e1000e: Refactor PM flows")
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=99847
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Tested-by: Aaron Brown <aaron.f.brown@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit 1cb31d3fd4d96b19624328da0a0496adf76f98a6
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Sep 25 01:33:13 2017 +0200

    PCI / PM: Do not resume any devices in pci_pm_prepare()
    
    It should not be necessary to resume devices with ignore_children set
    in pci_pm_prepare(), because they should be resumed explicitly by
    their children drivers during suspend if need be and they will be
    resumed by pci_pm_suspend() after that anyway, so avoid doing that.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 6af1de2e4ec49635905aaed31d073a0d92c8d3bf
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Sep 6 14:58:53 2017 +0200

    ath10k: mark PM functions as __maybe_unused
    
    When CONFIG_PM_SLEEP is disabled, we get a compile-time
    warning:
    
    drivers/net/wireless/ath/ath10k/pci.c:3417:12: error: 'ath10k_pci_pm_resume' defined but not used [-Werror=unused-function]
     static int ath10k_pci_pm_resume(struct device *dev)
                ^~~~~~~~~~~~~~~~~~~~
    drivers/net/wireless/ath/ath10k/pci.c:3401:12: error: 'ath10k_pci_pm_suspend' defined but not used [-Werror=unused-function]
     static int ath10k_pci_pm_suspend(struct device *dev)
    
    Rather than fixing the #ifdef, this just marks both functions
    as __maybe_unused, which is a more robust way to do this.
    
    Fixes: 32faa3f0ee50 ("ath10k: add the PCI PM core suspend/resume ops")
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Kalle Valo <kvalo@qca.qualcomm.com>

commit 576c94048c0ea741fc297568850f59b25f776ea1
Author: Liwei Song <liwei.song@windriver.com>
Date:   Tue Jun 13 00:59:53 2017 -0400

    i2c: ismt: fix wrong device address when unmap the data buffer
    
    commit 17e83549e199d89aace7788a9f11c108671eecf5 upstream.
    
    Fix the following kernel bug:
    
    kernel BUG at drivers/iommu/intel-iommu.c:3260!
    invalid opcode: 0000 [#5] PREEMPT SMP
    Hardware name: Intel Corp. Harcuvar/Server, BIOS HAVLCRB0.X64.0013.D39.1608311820 08/31/2016
    task: ffff880175389950 ti: ffff880176bec000 task.ti: ffff880176bec000
    RIP: 0010:[<ffffffff8150a83b>]  [<ffffffff8150a83b>] intel_unmap+0x25b/0x260
    RSP: 0018:ffff880176bef5e8  EFLAGS: 00010296
    RAX: 0000000000000024 RBX: ffff8800773c7c88 RCX: 000000000000ce04
    RDX: 0000000080000000 RSI: 0000000000000000 RDI: 0000000000000009
    RBP: ffff880176bef638 R08: 0000000000000010 R09: 0000000000000004
    R10: ffff880175389c78 R11: 0000000000000a4f R12: ffff8800773c7868
    R13: 00000000ffffac88 R14: ffff8800773c7818 R15: 0000000000000001
    FS:  00007fef21258700(0000) GS:ffff88017b5c0000(0000) knlGS:0000000000000000
    CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    CR2: 000000000066d6d8 CR3: 000000007118c000 CR4: 00000000003406e0
    Stack:
     00000000ffffac88 ffffffff8199867f ffff880176bef5f8 ffff880100000030
     ffff880176bef668 ffff8800773c7c88 ffff880178288098 ffff8800772c0010
     ffff8800773c7818 0000000000000001 ffff880176bef648 ffffffff8150a86e
    Call Trace:
     [<ffffffff8199867f>] ? printk+0x46/0x48
     [<ffffffff8150a86e>] intel_unmap_page+0xe/0x10
     [<ffffffffa039d99b>] ismt_access+0x27b/0x8fa [i2c_ismt]
     [<ffffffff81554420>] ? __pm_runtime_suspend+0xa0/0xa0
     [<ffffffff815544a0>] ? pm_suspend_timer_fn+0x80/0x80
     [<ffffffff81554420>] ? __pm_runtime_suspend+0xa0/0xa0
     [<ffffffff815544a0>] ? pm_suspend_timer_fn+0x80/0x80
     [<ffffffff8143dfd0>] ? pci_bus_read_dev_vendor_id+0xf0/0xf0
     [<ffffffff8172b36c>] i2c_smbus_xfer+0xec/0x4b0
     [<ffffffff810aa4d5>] ? vprintk_emit+0x345/0x530
     [<ffffffffa038936b>] i2cdev_ioctl_smbus+0x12b/0x240 [i2c_dev]
     [<ffffffff810aa829>] ? vprintk_default+0x29/0x40
     [<ffffffffa0389b33>] i2cdev_ioctl+0x63/0x1ec [i2c_dev]
     [<ffffffff811b04c8>] do_vfs_ioctl+0x328/0x5d0
     [<ffffffff8119d8ec>] ? vfs_write+0x11c/0x190
     [<ffffffff8109d449>] ? rt_up_read+0x19/0x20
     [<ffffffff811b07f1>] SyS_ioctl+0x81/0xa0
     [<ffffffff819a351b>] system_call_fastpath+0x16/0x6e
    
    This happen When run "i2cdetect -y 0" detect SMBus iSMT adapter.
    
    After finished I2C block read/write, when unmap the data buffer,
    a wrong device address was pass to dma_unmap_single().
    
    To fix this, give dma_unmap_single() the "dev" parameter, just like
    what dma_map_single() does, then unmap can find the right devices.
    
    Fixes: 13f35ac14cd0 ("i2c: Adding support for Intel iSMT SMBus 2.0 host controller")
    Signed-off-by: Liwei Song <liwei.song@windriver.com>
    Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit 80cdcd7f533585a62fa31f87a25ab5dbfd5e0e1a
Author: Johan Hovold <johan@kernel.org>
Date:   Thu Aug 24 11:38:36 2017 -0500

    USB: musb: fix external abort on suspend
    
    commit 082df8be455ade361748f0385aa6c9c8d07be167 upstream.
    
    Make sure that the controller is runtime resumed when system suspending
    to avoid an external abort when accessing the interrupt registers:
    
      Unhandled fault: external abort on non-linefetch (0x1008) at 0xd025840a
      ...
      [<c05481a4>] (musb_default_readb) from [<c0545abc>] (musb_disable_interrupts+0x84/0xa8)
      [<c0545abc>] (musb_disable_interrupts) from [<c0546b08>] (musb_suspend+0x38/0xb8)
      [<c0546b08>] (musb_suspend) from [<c04a57f8>] (platform_pm_suspend+0x3c/0x64)
    
    This is easily reproduced on a BBB by enabling the peripheral port only
    (as the host port may enable the shared clock) and keeping it
    disconnected so that the controller is runtime suspended. (Well, you
    would also need to the not-yet-merged am33xx-suspend patches by Dave
    Gerlach to be able to suspend the BBB.)
    
    This is a regression that was introduced by commit 1c4d0b4e1806 ("usb:
    musb: Remove pm_runtime_set_irq_safe") which allowed the parent glue
    device to runtime suspend and thereby exposed a couple of older issues:
    
    Register accesses without explicitly making sure the controller is
    runtime resumed during suspend was first introduced by commit c338412b5ded
    ("usb: musb: unconditionally save and restore the context on suspend")
    in 3.14.
    
    Commit a1fc1920aaaa ("usb: musb: core: make sure musb is in RPM_ACTIVE on
    resume") later started setting the RPM status to active during resume,
    and this was also implicitly relying on the parent always being active.
    Since commit 71723f95463d ("PM / runtime: print error when activating a
    child to unactive parent") this now also results in the following
    warning:
    
      musb-hdrc musb-hdrc.0: runtime PM trying to activate child device
        musb-hdrc.0 but parent (47401400.usb) is not active
    
    This patch has been verified on 4.13-rc2, 4.12 and 4.9 using a BBB
    (the dsps glue would always be active also in 4.8).
    
    Fixes: c338412b5ded ("usb: musb: unconditionally save and restore the context on suspend")
    Fixes: a1fc1920aaaa ("usb: musb: core: make sure musb is in RPM_ACTIVE on resume")
    Fixes: 1c4d0b4e1806 ("usb: musb: Remove pm_runtime_set_irq_safe")
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: Daniel Mack <zonque@gmail.com>
    Cc: Dave Gerlach <d-gerlach@ti.com>
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Cc: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Cc: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Bin Liu <b-liu@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 68596cc2106016950eab542851e179e5401fa130
Author: Johan Hovold <johan@kernel.org>
Date:   Thu Aug 24 11:38:36 2017 -0500

    USB: musb: fix external abort on suspend
    
    commit 082df8be455ade361748f0385aa6c9c8d07be167 upstream.
    
    Make sure that the controller is runtime resumed when system suspending
    to avoid an external abort when accessing the interrupt registers:
    
      Unhandled fault: external abort on non-linefetch (0x1008) at 0xd025840a
      ...
      [<c05481a4>] (musb_default_readb) from [<c0545abc>] (musb_disable_interrupts+0x84/0xa8)
      [<c0545abc>] (musb_disable_interrupts) from [<c0546b08>] (musb_suspend+0x38/0xb8)
      [<c0546b08>] (musb_suspend) from [<c04a57f8>] (platform_pm_suspend+0x3c/0x64)
    
    This is easily reproduced on a BBB by enabling the peripheral port only
    (as the host port may enable the shared clock) and keeping it
    disconnected so that the controller is runtime suspended. (Well, you
    would also need to the not-yet-merged am33xx-suspend patches by Dave
    Gerlach to be able to suspend the BBB.)
    
    This is a regression that was introduced by commit 1c4d0b4e1806 ("usb:
    musb: Remove pm_runtime_set_irq_safe") which allowed the parent glue
    device to runtime suspend and thereby exposed a couple of older issues:
    
    Register accesses without explicitly making sure the controller is
    runtime resumed during suspend was first introduced by commit c338412b5ded
    ("usb: musb: unconditionally save and restore the context on suspend")
    in 3.14.
    
    Commit a1fc1920aaaa ("usb: musb: core: make sure musb is in RPM_ACTIVE on
    resume") later started setting the RPM status to active during resume,
    and this was also implicitly relying on the parent always being active.
    Since commit 71723f95463d ("PM / runtime: print error when activating a
    child to unactive parent") this now also results in the following
    warning:
    
      musb-hdrc musb-hdrc.0: runtime PM trying to activate child device
        musb-hdrc.0 but parent (47401400.usb) is not active
    
    This patch has been verified on 4.13-rc2, 4.12 and 4.9 using a BBB
    (the dsps glue would always be active also in 4.8).
    
    Fixes: c338412b5ded ("usb: musb: unconditionally save and restore the context on suspend")
    Fixes: a1fc1920aaaa ("usb: musb: core: make sure musb is in RPM_ACTIVE on resume")
    Fixes: 1c4d0b4e1806 ("usb: musb: Remove pm_runtime_set_irq_safe")
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: Daniel Mack <zonque@gmail.com>
    Cc: Dave Gerlach <d-gerlach@ti.com>
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Cc: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Cc: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Bin Liu <b-liu@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 26be1058110efbc6dcc266bf25558e2381da339d
Author: Johan Hovold <johan@kernel.org>
Date:   Thu Aug 24 11:38:36 2017 -0500

    USB: musb: fix external abort on suspend
    
    commit 082df8be455ade361748f0385aa6c9c8d07be167 upstream.
    
    Make sure that the controller is runtime resumed when system suspending
    to avoid an external abort when accessing the interrupt registers:
    
      Unhandled fault: external abort on non-linefetch (0x1008) at 0xd025840a
      ...
      [<c05481a4>] (musb_default_readb) from [<c0545abc>] (musb_disable_interrupts+0x84/0xa8)
      [<c0545abc>] (musb_disable_interrupts) from [<c0546b08>] (musb_suspend+0x38/0xb8)
      [<c0546b08>] (musb_suspend) from [<c04a57f8>] (platform_pm_suspend+0x3c/0x64)
    
    This is easily reproduced on a BBB by enabling the peripheral port only
    (as the host port may enable the shared clock) and keeping it
    disconnected so that the controller is runtime suspended. (Well, you
    would also need to the not-yet-merged am33xx-suspend patches by Dave
    Gerlach to be able to suspend the BBB.)
    
    This is a regression that was introduced by commit 1c4d0b4e1806 ("usb:
    musb: Remove pm_runtime_set_irq_safe") which allowed the parent glue
    device to runtime suspend and thereby exposed a couple of older issues:
    
    Register accesses without explicitly making sure the controller is
    runtime resumed during suspend was first introduced by commit c338412b5ded
    ("usb: musb: unconditionally save and restore the context on suspend")
    in 3.14.
    
    Commit a1fc1920aaaa ("usb: musb: core: make sure musb is in RPM_ACTIVE on
    resume") later started setting the RPM status to active during resume,
    and this was also implicitly relying on the parent always being active.
    Since commit 71723f95463d ("PM / runtime: print error when activating a
    child to unactive parent") this now also results in the following
    warning:
    
      musb-hdrc musb-hdrc.0: runtime PM trying to activate child device
        musb-hdrc.0 but parent (47401400.usb) is not active
    
    This patch has been verified on 4.13-rc2, 4.12 and 4.9 using a BBB
    (the dsps glue would always be active also in 4.8).
    
    Fixes: c338412b5ded ("usb: musb: unconditionally save and restore the context on suspend")
    Fixes: a1fc1920aaaa ("usb: musb: core: make sure musb is in RPM_ACTIVE on resume")
    Fixes: 1c4d0b4e1806 ("usb: musb: Remove pm_runtime_set_irq_safe")
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: Daniel Mack <zonque@gmail.com>
    Cc: Dave Gerlach <d-gerlach@ti.com>
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Cc: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Cc: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Bin Liu <b-liu@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 7b01463e51f6849d0787b24d06a62efcb243dd44
Merge: a1b5fd8fa29f 726fb6b4f2a8
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Sep 4 00:06:02 2017 +0200

    Merge branch 'pm-sleep'
    
    * pm-sleep:
      ACPI / PM: Check low power idle constraints for debug only
      PM / s2idle: Rename platform operations structure
      PM / s2idle: Rename ->enter_freeze to ->enter_s2idle
      PM / s2idle: Rename freeze_state enum and related items
      PM / s2idle: Rename PM_SUSPEND_FREEZE to PM_SUSPEND_TO_IDLE
      ACPI / PM: Prefer suspend-to-idle over S3 on some systems
      platform/x86: intel-hid: Wake up Dell Latitude 7275 from suspend-to-idle
      PM / suspend: Define pr_fmt() in suspend.c
      PM / suspend: Use mem_sleep_labels[] strings in messages
      PM / sleep: Put pm_test under CONFIG_PM_SLEEP_DEBUG
      PM / sleep: Check pm_wakeup_pending() in __device_suspend_noirq()
      PM / core: Add error argument to dpm_show_time()
      PM / core: Split dpm_suspend_noirq() and dpm_resume_noirq()
      PM / s2idle: Rearrange the main suspend-to-idle loop
      PM / timekeeping: Print debug messages when requested
      PM / sleep: Mark suspend/hibernation start and finish
      PM / sleep: Do not print debug messages by default
      PM / suspend: Export pm_suspend_target_state

commit 7def9a2418430a8af2a56023769ccdcdea7cd7e1
Author: Arvind Yadav <arvind.yadav.cs@gmail.com>
Date:   Wed Aug 30 22:18:20 2017 +0530

    powerpc/4xx: Constify cpm_suspend_ops
    
    struct platform_suspend_ops are not supposed to change at runtime.
    Functions suspend_set_ops working with const platform_suspend_ops. So
    mark the non-const structs as const.
    
    Signed-off-by: Arvind Yadav <arvind.yadav.cs@gmail.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

commit 082df8be455ade361748f0385aa6c9c8d07be167
Author: Johan Hovold <johan@kernel.org>
Date:   Thu Aug 24 11:38:36 2017 -0500

    USB: musb: fix external abort on suspend
    
    Make sure that the controller is runtime resumed when system suspending
    to avoid an external abort when accessing the interrupt registers:
    
      Unhandled fault: external abort on non-linefetch (0x1008) at 0xd025840a
      ...
      [<c05481a4>] (musb_default_readb) from [<c0545abc>] (musb_disable_interrupts+0x84/0xa8)
      [<c0545abc>] (musb_disable_interrupts) from [<c0546b08>] (musb_suspend+0x38/0xb8)
      [<c0546b08>] (musb_suspend) from [<c04a57f8>] (platform_pm_suspend+0x3c/0x64)
    
    This is easily reproduced on a BBB by enabling the peripheral port only
    (as the host port may enable the shared clock) and keeping it
    disconnected so that the controller is runtime suspended. (Well, you
    would also need to the not-yet-merged am33xx-suspend patches by Dave
    Gerlach to be able to suspend the BBB.)
    
    This is a regression that was introduced by commit 1c4d0b4e1806 ("usb:
    musb: Remove pm_runtime_set_irq_safe") which allowed the parent glue
    device to runtime suspend and thereby exposed a couple of older issues:
    
    Register accesses without explicitly making sure the controller is
    runtime resumed during suspend was first introduced by commit c338412b5ded
    ("usb: musb: unconditionally save and restore the context on suspend")
    in 3.14.
    
    Commit a1fc1920aaaa ("usb: musb: core: make sure musb is in RPM_ACTIVE on
    resume") later started setting the RPM status to active during resume,
    and this was also implicitly relying on the parent always being active.
    Since commit 71723f95463d ("PM / runtime: print error when activating a
    child to unactive parent") this now also results in the following
    warning:
    
      musb-hdrc musb-hdrc.0: runtime PM trying to activate child device
        musb-hdrc.0 but parent (47401400.usb) is not active
    
    This patch has been verified on 4.13-rc2, 4.12 and 4.9 using a BBB
    (the dsps glue would always be active also in 4.8).
    
    Fixes: c338412b5ded ("usb: musb: unconditionally save and restore the context on suspend")
    Fixes: a1fc1920aaaa ("usb: musb: core: make sure musb is in RPM_ACTIVE on resume")
    Fixes: 1c4d0b4e1806 ("usb: musb: Remove pm_runtime_set_irq_safe")
    Cc: stable <stable@vger.kernel.org>     # 4.8+
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: Daniel Mack <zonque@gmail.com>
    Cc: Dave Gerlach <d-gerlach@ti.com>
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Cc: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Cc: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Bin Liu <b-liu@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit daeaf55aab069b1bee324ec58c809b1a9a8302a7
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Mon Mar 20 11:16:11 2017 -0700

    usb: hub: Fix error loop seen after hub communication errors
    
    commit 245b2eecee2aac6fdc77dcafaa73c33f9644c3c7 upstream.
    
    While stress testing a usb controller using a bind/unbind looop, the
    following error loop was observed.
    
    usb 7-1.2: new low-speed USB device number 3 using xhci-hcd
    usb 7-1.2: hub failed to enable device, error -108
    usb 7-1-port2: cannot disable (err = -22)
    usb 7-1-port2: couldn't allocate usb_device
    usb 7-1-port2: cannot disable (err = -22)
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: activate --> -22
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: activate --> -22
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: activate --> -22
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: activate --> -22
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: activate --> -22
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: activate --> -22
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: activate --> -22
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: activate --> -22
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    ** 57 printk messages dropped ** hub 7-1:1.0: activate --> -22
    ** 82 printk messages dropped ** hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    
    This continues forever. After adding tracebacks into the code,
    the call sequence leading to this is found to be as follows.
    
    [<ffffffc0007fc8e0>] hub_activate+0x368/0x7b8
    [<ffffffc0007fceb4>] hub_resume+0x2c/0x3c
    [<ffffffc00080b3b8>] usb_resume_interface.isra.6+0x128/0x158
    [<ffffffc00080b5d0>] usb_suspend_both+0x1e8/0x288
    [<ffffffc00080c9c4>] usb_runtime_suspend+0x3c/0x98
    [<ffffffc0007820a0>] __rpm_callback+0x48/0x7c
    [<ffffffc00078217c>] rpm_callback+0xa8/0xd4
    [<ffffffc000786234>] rpm_suspend+0x84/0x758
    [<ffffffc000786ca4>] rpm_idle+0x2c8/0x498
    [<ffffffc000786ed4>] __pm_runtime_idle+0x60/0xac
    [<ffffffc00080eba8>] usb_autopm_put_interface+0x6c/0x7c
    [<ffffffc000803798>] hub_event+0x10ac/0x12ac
    [<ffffffc000249bb8>] process_one_work+0x390/0x6b8
    [<ffffffc00024abcc>] worker_thread+0x480/0x610
    [<ffffffc000251a80>] kthread+0x164/0x178
    [<ffffffc0002045d0>] ret_from_fork+0x10/0x40
    
    kick_hub_wq() is called from hub_activate() even after failures to
    communicate with the hub. This results in an endless sequence of
    hub event -> hub activate -> wq trigger -> hub event -> ...
    
    Provide two solutions for the problem.
    
    - Only trigger the hub event queue if communication with the hub
      is successful.
    - After a suspend failure, only resume already suspended interfaces
      if the communication with the device is still possible.
    
    Each of the changes fixes the observed problem. Use both to improve
    robustness.
    
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    [bwh: Backported to 3.16: adjust context]
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit a2b0358b2c4ebb194c0a69a1834d6099fba8fe8b
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Mon Mar 20 11:16:11 2017 -0700

    usb: hub: Fix error loop seen after hub communication errors
    
    commit 245b2eecee2aac6fdc77dcafaa73c33f9644c3c7 upstream.
    
    While stress testing a usb controller using a bind/unbind looop, the
    following error loop was observed.
    
    usb 7-1.2: new low-speed USB device number 3 using xhci-hcd
    usb 7-1.2: hub failed to enable device, error -108
    usb 7-1-port2: cannot disable (err = -22)
    usb 7-1-port2: couldn't allocate usb_device
    usb 7-1-port2: cannot disable (err = -22)
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: activate --> -22
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: activate --> -22
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: activate --> -22
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: activate --> -22
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: activate --> -22
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: activate --> -22
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: activate --> -22
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: activate --> -22
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    ** 57 printk messages dropped ** hub 7-1:1.0: activate --> -22
    ** 82 printk messages dropped ** hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    
    This continues forever. After adding tracebacks into the code,
    the call sequence leading to this is found to be as follows.
    
    [<ffffffc0007fc8e0>] hub_activate+0x368/0x7b8
    [<ffffffc0007fceb4>] hub_resume+0x2c/0x3c
    [<ffffffc00080b3b8>] usb_resume_interface.isra.6+0x128/0x158
    [<ffffffc00080b5d0>] usb_suspend_both+0x1e8/0x288
    [<ffffffc00080c9c4>] usb_runtime_suspend+0x3c/0x98
    [<ffffffc0007820a0>] __rpm_callback+0x48/0x7c
    [<ffffffc00078217c>] rpm_callback+0xa8/0xd4
    [<ffffffc000786234>] rpm_suspend+0x84/0x758
    [<ffffffc000786ca4>] rpm_idle+0x2c8/0x498
    [<ffffffc000786ed4>] __pm_runtime_idle+0x60/0xac
    [<ffffffc00080eba8>] usb_autopm_put_interface+0x6c/0x7c
    [<ffffffc000803798>] hub_event+0x10ac/0x12ac
    [<ffffffc000249bb8>] process_one_work+0x390/0x6b8
    [<ffffffc00024abcc>] worker_thread+0x480/0x610
    [<ffffffc000251a80>] kthread+0x164/0x178
    [<ffffffc0002045d0>] ret_from_fork+0x10/0x40
    
    kick_hub_wq() is called from hub_activate() even after failures to
    communicate with the hub. This results in an endless sequence of
    hub event -> hub activate -> wq trigger -> hub event -> ...
    
    Provide two solutions for the problem.
    
    - Only trigger the hub event queue if communication with the hub
      is successful.
    - After a suspend failure, only resume already suspended interfaces
      if the communication with the device is still possible.
    
    Each of the changes fixes the observed problem. Use both to improve
    robustness.
    
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    [bwh: Backported to 3.2: adjust context]
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit 786f41fb6b008ea4341355b99083a38853a5311d
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Jul 21 02:09:22 2017 +0200

    PM / core: Split dpm_suspend_noirq() and dpm_resume_noirq()
    
    Put the device interrupts disabling and enabling as well as
    cpuidle_pause() and cpuidle_resume() called during the "noirq"
    stages of system suspend into separate functions to allow the
    core suspend-to-idle code to be optimized (later).
    
    The only functional difference this makes is that debug facilities
    and diagnostic tools will not include the above operations into the
    "noirq" device suspend/resume duration measurements.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 8e6bcd9f7eac47104ce6c5d82c554c9b244b38e1
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Jul 21 02:07:54 2017 +0200

    PM / s2idle: Rearrange the main suspend-to-idle loop
    
    As a preparation for subsequent changes, rearrange the core
    suspend-to-idle code by moving the initial invocation of
    dpm_suspend_noirq() into s2idle_loop().
    
    This also causes debug messages from that code to appear in
    a less confusing order.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit bd8c9ba3b1e2037af5af4e48aea1087212838179
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Mon Jul 17 17:19:25 2017 -0700

    PM / suspend: Export pm_suspend_target_state
    
    Have the core suspend/resume framework store the system-wide suspend
    state (suspend_state_t) we are about to enter, and expose it to drivers
    via pm_suspend_target_state in order to retrieve that. The state is
    assigned in suspend_devices_and_enter().
    
    This is useful for platform specific drivers that may need to take a
    slightly different suspend/resume path based on the system's
    suspend/resume state being entered.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 1d80df93d9d170eba8c3654719e5857307efd077
Author: Brian Norris <briannorris@chromium.org>
Date:   Fri Jun 23 13:59:11 2017 -0700

    Revert "pinctrl: rockchip: avoid hardirq-unsafe functions in irq_chip"
    
    This reverts commit 88bb94216f59e10802aaf78c858a4146085faf18.
    
    It introduced a new CONFIG_DEBUG_ATOMIC_SLEEP warning in v4.12-rc1:
    
    [ 7226.716713] BUG: sleeping function called from invalid context at kernel/locking/mutex.c:238
    [ 7226.716716] in_atomic(): 0, irqs_disabled(): 0, pid: 1708, name: bash
    [ 7226.716722] CPU: 1 PID: 1708 Comm: bash Not tainted 4.12.0-rc6+ #1213
    [ 7226.716724] Hardware name: Google Kevin (DT)
    [ 7226.716726] Call trace:
    [ 7226.716738] [<ffffff8008089928>] dump_backtrace+0x0/0x24c
    [ 7226.716743] [<ffffff8008089b94>] show_stack+0x20/0x28
    [ 7226.716749] [<ffffff8008371370>] dump_stack+0x90/0xb0
    [ 7226.716755] [<ffffff80080cd2a0>] ___might_sleep+0x10c/0x124
    [ 7226.716760] [<ffffff80080cd330>] __might_sleep+0x78/0x88
    [ 7226.716765] [<ffffff800879e210>] mutex_lock+0x2c/0x64
    [ 7226.716771] [<ffffff80083ad678>] rockchip_irq_bus_lock+0x30/0x3c
    [ 7226.716777] [<ffffff80080f6d40>] __irq_get_desc_lock+0x78/0x98
    [ 7226.716782] [<ffffff80080f7e6c>] irq_set_irq_wake+0x44/0x12c
    [ 7226.716787] [<ffffff8008486e18>] dev_pm_arm_wake_irq+0x4c/0x58
    [ 7226.716792] [<ffffff800848b80c>] device_wakeup_arm_wake_irqs+0x3c/0x58
    [ 7226.716796] [<ffffff80084896fc>] dpm_suspend_noirq+0xf8/0x3a0
    [ 7226.716800] [<ffffff80080f1384>] suspend_devices_and_enter+0x1a4/0x9a8
    [ 7226.716803] [<ffffff80080f21ec>] pm_suspend+0x664/0x6a4
    [ 7226.716807] [<ffffff80080f04d8>] state_store+0xd4/0xf8
    ...
    
    It was reported on -rc1, and it's still not fixed in -rc6, so it should
    just be reverted.
    
    Cc: John Keeping <john@metanate.com>
    Signed-off-by: Brian Norris <briannorris@chromium.org>
    Reviewed-by: Heiko Stuebner <heiko@sntech.de>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

commit 99f5ba009efddddb9d0ac34e735b2caf2c64e4a3
Author: Imre Deak <imre.deak@intel.com>
Date:   Tue May 2 15:04:09 2017 +0300

    drm/i915: Prevent the system suspend complete optimization
    
    commit 6ab92afc95c9bd6877cb42e7b24f65be887a5440 upstream.
    
    Since
    
    commit bac2a909a096c9110525c18cbb8ce73c660d5f71
    Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Date:   Wed Jan 21 02:17:42 2015 +0100
    
        PCI / PM: Avoid resuming PCI devices during system suspend
    
    PCI devices will default to allowing the system suspend complete
    optimization where devices are not woken up during system suspend if
    they were already runtime suspended. This however breaks the i915/HDA
    drivers for two reasons:
    
    - The i915 driver has system suspend specific steps that it needs to
      run, that bring the device to a different state than its runtime
      suspended state.
    
    - The HDA driver's suspend handler requires power that it will request
      from the i915 driver's power domain handler. This in turn requires the
      i915 driver to runtime resume itself, but this won't be possible if the
      suspend complete optimization is in effect: in this case the i915
      runtime PM is disabled and trying to get an RPM reference returns
      -EACCESS.
    
    Solve this by requiring the PCI/PM core to resume the device during
    system suspend which in effect disables the suspend complete optimization.
    
    Regardless of the above commit the optimization stayed disabled for DRM
    devices until
    
    commit d14d2a8453d650bea32a1c5271af1458cd283a0f
    Author: Lukas Wunner <lukas@wunner.de>
    Date:   Wed Jun 8 12:49:29 2016 +0200
    
        drm: Remove dev_pm_ops from drm_class
    
    so this patch is in practice a fix for this commit. Another reason for
    the bug staying hidden for so long is that the optimization for a device
    is disabled if it's disabled for any of its children devices. i915 may
    have a backlight device as its child which doesn't support runtime PM
    and so doesn't allow the optimization either.  So if this backlight
    device got registered the bug stayed hidden.
    
    Credits to Marta, Tomi and David who enabled pstore logging,
    that caught one instance of this issue across a suspend/
    resume-to-ram and Ville who rememberd that the optimization was enabled
    for some devices at one point.
    
    The first WARN triggered by the problem:
    
    [ 6250.746445] WARNING: CPU: 2 PID: 17384 at drivers/gpu/drm/i915/intel_runtime_pm.c:2846 intel_runtime_pm_get+0x6b/0xd0 [i915]
    [ 6250.746448] pm_runtime_get_sync() failed: -13
    [ 6250.746451] Modules linked in: snd_hda_intel i915 vgem snd_hda_codec_hdmi x86_pkg_temp_thermal intel_powerclamp coretemp crct10dif_pclmul crc32_pclmul
    snd_hda_codec_realtek snd_hda_codec_generic ghash_clmulni_intel e1000e snd_hda_codec snd_hwdep snd_hda_core ptp mei_me pps_core snd_pcm lpc_ich mei prime_
    numbers i2c_hid i2c_designware_platform i2c_designware_core [last unloaded: i915]
    [ 6250.746512] CPU: 2 PID: 17384 Comm: kworker/u8:0 Tainted: G     U  W       4.11.0-rc5-CI-CI_DRM_334+ #1
    [ 6250.746515] Hardware name:                  /NUC5i5RYB, BIOS RYBDWi35.86A.0362.2017.0118.0940 01/18/2017
    [ 6250.746521] Workqueue: events_unbound async_run_entry_fn
    [ 6250.746525] Call Trace:
    [ 6250.746530]  dump_stack+0x67/0x92
    [ 6250.746536]  __warn+0xc6/0xe0
    [ 6250.746542]  ? pci_restore_standard_config+0x40/0x40
    [ 6250.746546]  warn_slowpath_fmt+0x46/0x50
    [ 6250.746553]  ? __pm_runtime_resume+0x56/0x80
    [ 6250.746584]  intel_runtime_pm_get+0x6b/0xd0 [i915]
    [ 6250.746610]  intel_display_power_get+0x1b/0x40 [i915]
    [ 6250.746646]  i915_audio_component_get_power+0x15/0x20 [i915]
    [ 6250.746654]  snd_hdac_display_power+0xc8/0x110 [snd_hda_core]
    [ 6250.746661]  azx_runtime_resume+0x218/0x280 [snd_hda_intel]
    [ 6250.746667]  pci_pm_runtime_resume+0x76/0xa0
    [ 6250.746672]  __rpm_callback+0xb4/0x1f0
    [ 6250.746677]  ? pci_restore_standard_config+0x40/0x40
    [ 6250.746682]  rpm_callback+0x1f/0x80
    [ 6250.746686]  ? pci_restore_standard_config+0x40/0x40
    [ 6250.746690]  rpm_resume+0x4ba/0x740
    [ 6250.746698]  __pm_runtime_resume+0x49/0x80
    [ 6250.746703]  pci_pm_suspend+0x57/0x140
    [ 6250.746709]  dpm_run_callback+0x6f/0x330
    [ 6250.746713]  ? pci_pm_freeze+0xe0/0xe0
    [ 6250.746718]  __device_suspend+0xf9/0x370
    [ 6250.746724]  ? dpm_watchdog_set+0x60/0x60
    [ 6250.746730]  async_suspend+0x1a/0x90
    [ 6250.746735]  async_run_entry_fn+0x34/0x160
    [ 6250.746741]  process_one_work+0x1f2/0x6d0
    [ 6250.746749]  worker_thread+0x49/0x4a0
    [ 6250.746755]  kthread+0x107/0x140
    [ 6250.746759]  ? process_one_work+0x6d0/0x6d0
    [ 6250.746763]  ? kthread_create_on_node+0x40/0x40
    [ 6250.746768]  ret_from_fork+0x2e/0x40
    [ 6250.746778] ---[ end trace 102a62fd2160f5e6 ]---
    
    v2:
    - Use the new pci_dev->needs_resume flag, to avoid any overhead during
      the ->pm_prepare hook. (Rafael)
    
    v3:
    - Update commit message to reference the actual regressing commit.
      (Lukas)
    
    v4:
    - Rebase on v4 of patch 1/2.
    
    Fixes: d14d2a8453d6 ("drm: Remove dev_pm_ops from drm_class")
    References: https://bugs.freedesktop.org/show_bug.cgi?id=100378
    References: https://bugs.freedesktop.org/show_bug.cgi?id=100770
    Cc: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: Marta Lofstedt <marta.lofstedt@intel.com>
    Cc: David Weinehall <david.weinehall@linux.intel.com>
    Cc: Tomi Sarvela <tomi.p.sarvela@intel.com>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: Mika Kuoppala <mika.kuoppala@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Takashi Iwai <tiwai@suse.de>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Lukas Wunner <lukas@wunner.de>
    Cc: linux-pci@vger.kernel.org
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reported-and-tested-by: Marta Lofstedt <marta.lofstedt@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1493726649-32094-2-git-send-email-imre.deak@intel.com
    (cherry picked from commit adfdf85d795f4d4f487b61ee0b169d64c6e19081)
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 7a7b2d5f65a7a12c4f5d43fb10913ca908102833
Author: Imre Deak <imre.deak@intel.com>
Date:   Tue May 2 15:04:09 2017 +0300

    drm/i915: Prevent the system suspend complete optimization
    
    commit 6ab92afc95c9bd6877cb42e7b24f65be887a5440 upstream.
    
    Since
    
    commit bac2a909a096c9110525c18cbb8ce73c660d5f71
    Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Date:   Wed Jan 21 02:17:42 2015 +0100
    
        PCI / PM: Avoid resuming PCI devices during system suspend
    
    PCI devices will default to allowing the system suspend complete
    optimization where devices are not woken up during system suspend if
    they were already runtime suspended. This however breaks the i915/HDA
    drivers for two reasons:
    
    - The i915 driver has system suspend specific steps that it needs to
      run, that bring the device to a different state than its runtime
      suspended state.
    
    - The HDA driver's suspend handler requires power that it will request
      from the i915 driver's power domain handler. This in turn requires the
      i915 driver to runtime resume itself, but this won't be possible if the
      suspend complete optimization is in effect: in this case the i915
      runtime PM is disabled and trying to get an RPM reference returns
      -EACCESS.
    
    Solve this by requiring the PCI/PM core to resume the device during
    system suspend which in effect disables the suspend complete optimization.
    
    Regardless of the above commit the optimization stayed disabled for DRM
    devices until
    
    commit d14d2a8453d650bea32a1c5271af1458cd283a0f
    Author: Lukas Wunner <lukas@wunner.de>
    Date:   Wed Jun 8 12:49:29 2016 +0200
    
        drm: Remove dev_pm_ops from drm_class
    
    so this patch is in practice a fix for this commit. Another reason for
    the bug staying hidden for so long is that the optimization for a device
    is disabled if it's disabled for any of its children devices. i915 may
    have a backlight device as its child which doesn't support runtime PM
    and so doesn't allow the optimization either.  So if this backlight
    device got registered the bug stayed hidden.
    
    Credits to Marta, Tomi and David who enabled pstore logging,
    that caught one instance of this issue across a suspend/
    resume-to-ram and Ville who rememberd that the optimization was enabled
    for some devices at one point.
    
    The first WARN triggered by the problem:
    
    [ 6250.746445] WARNING: CPU: 2 PID: 17384 at drivers/gpu/drm/i915/intel_runtime_pm.c:2846 intel_runtime_pm_get+0x6b/0xd0 [i915]
    [ 6250.746448] pm_runtime_get_sync() failed: -13
    [ 6250.746451] Modules linked in: snd_hda_intel i915 vgem snd_hda_codec_hdmi x86_pkg_temp_thermal intel_powerclamp coretemp crct10dif_pclmul crc32_pclmul
    snd_hda_codec_realtek snd_hda_codec_generic ghash_clmulni_intel e1000e snd_hda_codec snd_hwdep snd_hda_core ptp mei_me pps_core snd_pcm lpc_ich mei prime_
    numbers i2c_hid i2c_designware_platform i2c_designware_core [last unloaded: i915]
    [ 6250.746512] CPU: 2 PID: 17384 Comm: kworker/u8:0 Tainted: G     U  W       4.11.0-rc5-CI-CI_DRM_334+ #1
    [ 6250.746515] Hardware name:                  /NUC5i5RYB, BIOS RYBDWi35.86A.0362.2017.0118.0940 01/18/2017
    [ 6250.746521] Workqueue: events_unbound async_run_entry_fn
    [ 6250.746525] Call Trace:
    [ 6250.746530]  dump_stack+0x67/0x92
    [ 6250.746536]  __warn+0xc6/0xe0
    [ 6250.746542]  ? pci_restore_standard_config+0x40/0x40
    [ 6250.746546]  warn_slowpath_fmt+0x46/0x50
    [ 6250.746553]  ? __pm_runtime_resume+0x56/0x80
    [ 6250.746584]  intel_runtime_pm_get+0x6b/0xd0 [i915]
    [ 6250.746610]  intel_display_power_get+0x1b/0x40 [i915]
    [ 6250.746646]  i915_audio_component_get_power+0x15/0x20 [i915]
    [ 6250.746654]  snd_hdac_display_power+0xc8/0x110 [snd_hda_core]
    [ 6250.746661]  azx_runtime_resume+0x218/0x280 [snd_hda_intel]
    [ 6250.746667]  pci_pm_runtime_resume+0x76/0xa0
    [ 6250.746672]  __rpm_callback+0xb4/0x1f0
    [ 6250.746677]  ? pci_restore_standard_config+0x40/0x40
    [ 6250.746682]  rpm_callback+0x1f/0x80
    [ 6250.746686]  ? pci_restore_standard_config+0x40/0x40
    [ 6250.746690]  rpm_resume+0x4ba/0x740
    [ 6250.746698]  __pm_runtime_resume+0x49/0x80
    [ 6250.746703]  pci_pm_suspend+0x57/0x140
    [ 6250.746709]  dpm_run_callback+0x6f/0x330
    [ 6250.746713]  ? pci_pm_freeze+0xe0/0xe0
    [ 6250.746718]  __device_suspend+0xf9/0x370
    [ 6250.746724]  ? dpm_watchdog_set+0x60/0x60
    [ 6250.746730]  async_suspend+0x1a/0x90
    [ 6250.746735]  async_run_entry_fn+0x34/0x160
    [ 6250.746741]  process_one_work+0x1f2/0x6d0
    [ 6250.746749]  worker_thread+0x49/0x4a0
    [ 6250.746755]  kthread+0x107/0x140
    [ 6250.746759]  ? process_one_work+0x6d0/0x6d0
    [ 6250.746763]  ? kthread_create_on_node+0x40/0x40
    [ 6250.746768]  ret_from_fork+0x2e/0x40
    [ 6250.746778] ---[ end trace 102a62fd2160f5e6 ]---
    
    v2:
    - Use the new pci_dev->needs_resume flag, to avoid any overhead during
      the ->pm_prepare hook. (Rafael)
    
    v3:
    - Update commit message to reference the actual regressing commit.
      (Lukas)
    
    v4:
    - Rebase on v4 of patch 1/2.
    
    Fixes: d14d2a8453d6 ("drm: Remove dev_pm_ops from drm_class")
    References: https://bugs.freedesktop.org/show_bug.cgi?id=100378
    References: https://bugs.freedesktop.org/show_bug.cgi?id=100770
    Cc: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: Marta Lofstedt <marta.lofstedt@intel.com>
    Cc: David Weinehall <david.weinehall@linux.intel.com>
    Cc: Tomi Sarvela <tomi.p.sarvela@intel.com>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: Mika Kuoppala <mika.kuoppala@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Takashi Iwai <tiwai@suse.de>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Lukas Wunner <lukas@wunner.de>
    Cc: linux-pci@vger.kernel.org
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reported-and-tested-by: Marta Lofstedt <marta.lofstedt@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1493726649-32094-2-git-send-email-imre.deak@intel.com
    (cherry picked from commit adfdf85d795f4d4f487b61ee0b169d64c6e19081)
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 17e83549e199d89aace7788a9f11c108671eecf5
Author: Liwei Song <liwei.song@windriver.com>
Date:   Tue Jun 13 00:59:53 2017 -0400

    i2c: ismt: fix wrong device address when unmap the data buffer
    
    Fix the following kernel bug:
    
    kernel BUG at drivers/iommu/intel-iommu.c:3260!
    invalid opcode: 0000 [#5] PREEMPT SMP
    Hardware name: Intel Corp. Harcuvar/Server, BIOS HAVLCRB0.X64.0013.D39.1608311820 08/31/2016
    task: ffff880175389950 ti: ffff880176bec000 task.ti: ffff880176bec000
    RIP: 0010:[<ffffffff8150a83b>]  [<ffffffff8150a83b>] intel_unmap+0x25b/0x260
    RSP: 0018:ffff880176bef5e8  EFLAGS: 00010296
    RAX: 0000000000000024 RBX: ffff8800773c7c88 RCX: 000000000000ce04
    RDX: 0000000080000000 RSI: 0000000000000000 RDI: 0000000000000009
    RBP: ffff880176bef638 R08: 0000000000000010 R09: 0000000000000004
    R10: ffff880175389c78 R11: 0000000000000a4f R12: ffff8800773c7868
    R13: 00000000ffffac88 R14: ffff8800773c7818 R15: 0000000000000001
    FS:  00007fef21258700(0000) GS:ffff88017b5c0000(0000) knlGS:0000000000000000
    CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    CR2: 000000000066d6d8 CR3: 000000007118c000 CR4: 00000000003406e0
    Stack:
     00000000ffffac88 ffffffff8199867f ffff880176bef5f8 ffff880100000030
     ffff880176bef668 ffff8800773c7c88 ffff880178288098 ffff8800772c0010
     ffff8800773c7818 0000000000000001 ffff880176bef648 ffffffff8150a86e
    Call Trace:
     [<ffffffff8199867f>] ? printk+0x46/0x48
     [<ffffffff8150a86e>] intel_unmap_page+0xe/0x10
     [<ffffffffa039d99b>] ismt_access+0x27b/0x8fa [i2c_ismt]
     [<ffffffff81554420>] ? __pm_runtime_suspend+0xa0/0xa0
     [<ffffffff815544a0>] ? pm_suspend_timer_fn+0x80/0x80
     [<ffffffff81554420>] ? __pm_runtime_suspend+0xa0/0xa0
     [<ffffffff815544a0>] ? pm_suspend_timer_fn+0x80/0x80
     [<ffffffff8143dfd0>] ? pci_bus_read_dev_vendor_id+0xf0/0xf0
     [<ffffffff8172b36c>] i2c_smbus_xfer+0xec/0x4b0
     [<ffffffff810aa4d5>] ? vprintk_emit+0x345/0x530
     [<ffffffffa038936b>] i2cdev_ioctl_smbus+0x12b/0x240 [i2c_dev]
     [<ffffffff810aa829>] ? vprintk_default+0x29/0x40
     [<ffffffffa0389b33>] i2cdev_ioctl+0x63/0x1ec [i2c_dev]
     [<ffffffff811b04c8>] do_vfs_ioctl+0x328/0x5d0
     [<ffffffff8119d8ec>] ? vfs_write+0x11c/0x190
     [<ffffffff8109d449>] ? rt_up_read+0x19/0x20
     [<ffffffff811b07f1>] SyS_ioctl+0x81/0xa0
     [<ffffffff819a351b>] system_call_fastpath+0x16/0x6e
    
    This happen When run "i2cdetect -y 0" detect SMBus iSMT adapter.
    
    After finished I2C block read/write, when unmap the data buffer,
    a wrong device address was pass to dma_unmap_single().
    
    To fix this, give dma_unmap_single() the "dev" parameter, just like
    what dma_map_single() does, then unmap can find the right devices.
    
    Fixes: 13f35ac14cd0 ("i2c: Adding support for Intel iSMT SMBus 2.0 host controller")
    Signed-off-by: Liwei Song <liwei.song@windriver.com>
    Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

commit 175d5b2a570cc0f79a23dbaf86e35e660f6f544f
Author: Roberto Sassu <roberto.sassu@huawei.com>
Date:   Thu May 4 13:16:47 2017 +0200

    tpm: move TPM 1.2 code of tpm_pcr_extend() to tpm1_pcr_extend()
    
    In preparation of the modifications to tpm_pcr_extend(), which will
    allow callers to supply a digest for each PCR bank of a TPM 2.0,
    the TPM 1.2 specific code has been moved to tpm1_pcr_extend().
    
    tpm1_pcr_extend() uses tpm_buf_init() to prepare the command buffer,
    which offers protection against buffer overflow. It is called by
    tpm_pcr_extend() and tpm_pm_suspend().
    
    Signed-off-by: Roberto Sassu <roberto.sassu@huawei.com>
    Reviewed-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
    Tested-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
    Signed-off-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>

commit 3948b57bd592c05bd6c08b3fea0862473cf9d5d9
Merge: b3fd82207e27 833521ebc65b
Author: David S. Miller <davem@davemloft.net>
Date:   Thu Jun 8 14:41:19 2017 -0400

    Merge branch '1GbE' of git://git.kernel.org/pub/scm/linux/kernel/git/jkirsher/next-queue
    
    Jeff Kirsher says:
    
    ====================
    1GbE Intel Wired LAN Driver Updates 2017-06-07
    
    This series contains a fix for e1000e and igb.
    
    Colin Ian King fixes sparse warnings in igb by making functions static.
    
    Chris Wilson provides a fix for a previous commit which is causing an
    issue during suspend "e1000e_pm_suspend()", where we need to run
    e1000e_pm_thaw() if __e1000_shutdown() is unsuccessful.
    ====================
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 833521ebc65b1c3092e5c0d8a97092f98eec595d
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Wed May 31 18:50:43 2017 +0300

    e1000e: Undo e1000e_pm_freeze if __e1000_shutdown fails
    
    An error during suspend (e100e_pm_suspend),
    
    [  429.994338] ACPI : EC: event blocked
    [  429.994633] e1000e: EEE TX LPI TIMER: 00000011
    [  430.955451] pci_pm_suspend(): e1000e_pm_suspend+0x0/0x30 [e1000e] returns -2
    [  430.955454] dpm_run_callback(): pci_pm_suspend+0x0/0x140 returns -2
    [  430.955458] PM: Device 0000:00:19.0 failed to suspend async: error -2
    [  430.955581] PM: Some devices failed to suspend, or early wake event detected
    [  430.957709] ACPI : EC: event unblocked
    
    lead to complete failure:
    
    [  432.585002] ------------[ cut here ]------------
    [  432.585013] WARNING: CPU: 3 PID: 8372 at kernel/irq/manage.c:1478 __free_irq+0x9f/0x280
    [  432.585015] Trying to free already-free IRQ 20
    [  432.585016] Modules linked in: cdc_ncm usbnet x86_pkg_temp_thermal intel_powerclamp coretemp mii crct10dif_pclmul crc32_pclmul ghash_clmulni_intel snd_hda_codec_hdmi snd_hda_codec_realtek snd_hda_codec_generic snd_hda_intel snd_hda_codec snd_hwdep lpc_ich snd_hda_core snd_pcm mei_me mei sdhci_pci sdhci i915 mmc_core e1000e ptp pps_core prime_numbers
    [  432.585042] CPU: 3 PID: 8372 Comm: kworker/u16:40 Tainted: G     U          4.10.0-rc8-CI-Patchwork_3870+ #1
    [  432.585044] Hardware name: LENOVO 2356GCG/2356GCG, BIOS G7ET31WW (1.13 ) 07/02/2012
    [  432.585050] Workqueue: events_unbound async_run_entry_fn
    [  432.585051] Call Trace:
    [  432.585058]  dump_stack+0x67/0x92
    [  432.585062]  __warn+0xc6/0xe0
    [  432.585065]  warn_slowpath_fmt+0x4a/0x50
    [  432.585070]  ? _raw_spin_lock_irqsave+0x49/0x60
    [  432.585072]  __free_irq+0x9f/0x280
    [  432.585075]  free_irq+0x34/0x80
    [  432.585089]  e1000_free_irq+0x65/0x70 [e1000e]
    [  432.585098]  e1000e_pm_freeze+0x7a/0xb0 [e1000e]
    [  432.585106]  e1000e_pm_suspend+0x21/0x30 [e1000e]
    [  432.585113]  pci_pm_suspend+0x71/0x140
    [  432.585118]  dpm_run_callback+0x6f/0x330
    [  432.585122]  ? pci_pm_freeze+0xe0/0xe0
    [  432.585125]  __device_suspend+0xea/0x330
    [  432.585128]  async_suspend+0x1a/0x90
    [  432.585132]  async_run_entry_fn+0x34/0x160
    [  432.585137]  process_one_work+0x1f4/0x6d0
    [  432.585140]  ? process_one_work+0x16e/0x6d0
    [  432.585143]  worker_thread+0x49/0x4a0
    [  432.585145]  kthread+0x107/0x140
    [  432.585148]  ? process_one_work+0x6d0/0x6d0
    [  432.585150]  ? kthread_create_on_node+0x40/0x40
    [  432.585154]  ret_from_fork+0x2e/0x40
    [  432.585156] ---[ end trace 6712df7f8c4b9124 ]---
    
    The unwind failures stems from commit 2800209994f8 ("e1000e: Refactor PM
    flows"), but it may be a later patch that introduced the non-recoverable
    behaviour.
    
    Fixes: 2800209994f8 ("e1000e: Refactor PM flows")
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=99847
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Tested-by: Aaron Brown <aaron.f.brown@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

commit 6ab92afc95c9bd6877cb42e7b24f65be887a5440
Author: Imre Deak <imre.deak@intel.com>
Date:   Tue May 2 15:04:09 2017 +0300

    drm/i915: Prevent the system suspend complete optimization
    
    Since
    
    commit bac2a909a096c9110525c18cbb8ce73c660d5f71
    Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Date:   Wed Jan 21 02:17:42 2015 +0100
    
        PCI / PM: Avoid resuming PCI devices during system suspend
    
    PCI devices will default to allowing the system suspend complete
    optimization where devices are not woken up during system suspend if
    they were already runtime suspended. This however breaks the i915/HDA
    drivers for two reasons:
    
    - The i915 driver has system suspend specific steps that it needs to
      run, that bring the device to a different state than its runtime
      suspended state.
    
    - The HDA driver's suspend handler requires power that it will request
      from the i915 driver's power domain handler. This in turn requires the
      i915 driver to runtime resume itself, but this won't be possible if the
      suspend complete optimization is in effect: in this case the i915
      runtime PM is disabled and trying to get an RPM reference returns
      -EACCESS.
    
    Solve this by requiring the PCI/PM core to resume the device during
    system suspend which in effect disables the suspend complete optimization.
    
    Regardless of the above commit the optimization stayed disabled for DRM
    devices until
    
    commit d14d2a8453d650bea32a1c5271af1458cd283a0f
    Author: Lukas Wunner <lukas@wunner.de>
    Date:   Wed Jun 8 12:49:29 2016 +0200
    
        drm: Remove dev_pm_ops from drm_class
    
    so this patch is in practice a fix for this commit. Another reason for
    the bug staying hidden for so long is that the optimization for a device
    is disabled if it's disabled for any of its children devices. i915 may
    have a backlight device as its child which doesn't support runtime PM
    and so doesn't allow the optimization either.  So if this backlight
    device got registered the bug stayed hidden.
    
    Credits to Marta, Tomi and David who enabled pstore logging,
    that caught one instance of this issue across a suspend/
    resume-to-ram and Ville who rememberd that the optimization was enabled
    for some devices at one point.
    
    The first WARN triggered by the problem:
    
    [ 6250.746445] WARNING: CPU: 2 PID: 17384 at drivers/gpu/drm/i915/intel_runtime_pm.c:2846 intel_runtime_pm_get+0x6b/0xd0 [i915]
    [ 6250.746448] pm_runtime_get_sync() failed: -13
    [ 6250.746451] Modules linked in: snd_hda_intel i915 vgem snd_hda_codec_hdmi x86_pkg_temp_thermal intel_powerclamp coretemp crct10dif_pclmul crc32_pclmul
    snd_hda_codec_realtek snd_hda_codec_generic ghash_clmulni_intel e1000e snd_hda_codec snd_hwdep snd_hda_core ptp mei_me pps_core snd_pcm lpc_ich mei prime_
    numbers i2c_hid i2c_designware_platform i2c_designware_core [last unloaded: i915]
    [ 6250.746512] CPU: 2 PID: 17384 Comm: kworker/u8:0 Tainted: G     U  W       4.11.0-rc5-CI-CI_DRM_334+ #1
    [ 6250.746515] Hardware name:                  /NUC5i5RYB, BIOS RYBDWi35.86A.0362.2017.0118.0940 01/18/2017
    [ 6250.746521] Workqueue: events_unbound async_run_entry_fn
    [ 6250.746525] Call Trace:
    [ 6250.746530]  dump_stack+0x67/0x92
    [ 6250.746536]  __warn+0xc6/0xe0
    [ 6250.746542]  ? pci_restore_standard_config+0x40/0x40
    [ 6250.746546]  warn_slowpath_fmt+0x46/0x50
    [ 6250.746553]  ? __pm_runtime_resume+0x56/0x80
    [ 6250.746584]  intel_runtime_pm_get+0x6b/0xd0 [i915]
    [ 6250.746610]  intel_display_power_get+0x1b/0x40 [i915]
    [ 6250.746646]  i915_audio_component_get_power+0x15/0x20 [i915]
    [ 6250.746654]  snd_hdac_display_power+0xc8/0x110 [snd_hda_core]
    [ 6250.746661]  azx_runtime_resume+0x218/0x280 [snd_hda_intel]
    [ 6250.746667]  pci_pm_runtime_resume+0x76/0xa0
    [ 6250.746672]  __rpm_callback+0xb4/0x1f0
    [ 6250.746677]  ? pci_restore_standard_config+0x40/0x40
    [ 6250.746682]  rpm_callback+0x1f/0x80
    [ 6250.746686]  ? pci_restore_standard_config+0x40/0x40
    [ 6250.746690]  rpm_resume+0x4ba/0x740
    [ 6250.746698]  __pm_runtime_resume+0x49/0x80
    [ 6250.746703]  pci_pm_suspend+0x57/0x140
    [ 6250.746709]  dpm_run_callback+0x6f/0x330
    [ 6250.746713]  ? pci_pm_freeze+0xe0/0xe0
    [ 6250.746718]  __device_suspend+0xf9/0x370
    [ 6250.746724]  ? dpm_watchdog_set+0x60/0x60
    [ 6250.746730]  async_suspend+0x1a/0x90
    [ 6250.746735]  async_run_entry_fn+0x34/0x160
    [ 6250.746741]  process_one_work+0x1f2/0x6d0
    [ 6250.746749]  worker_thread+0x49/0x4a0
    [ 6250.746755]  kthread+0x107/0x140
    [ 6250.746759]  ? process_one_work+0x6d0/0x6d0
    [ 6250.746763]  ? kthread_create_on_node+0x40/0x40
    [ 6250.746768]  ret_from_fork+0x2e/0x40
    [ 6250.746778] ---[ end trace 102a62fd2160f5e6 ]---
    
    v2:
    - Use the new pci_dev->needs_resume flag, to avoid any overhead during
      the ->pm_prepare hook. (Rafael)
    
    v3:
    - Update commit message to reference the actual regressing commit.
      (Lukas)
    
    v4:
    - Rebase on v4 of patch 1/2.
    
    Fixes: d14d2a8453d6 ("drm: Remove dev_pm_ops from drm_class")
    References: https://bugs.freedesktop.org/show_bug.cgi?id=100378
    References: https://bugs.freedesktop.org/show_bug.cgi?id=100770
    Cc: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: Marta Lofstedt <marta.lofstedt@intel.com>
    Cc: David Weinehall <david.weinehall@linux.intel.com>
    Cc: Tomi Sarvela <tomi.p.sarvela@intel.com>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: Mika Kuoppala <mika.kuoppala@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Takashi Iwai <tiwai@suse.de>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Lukas Wunner <lukas@wunner.de>
    Cc: linux-pci@vger.kernel.org
    Cc: <stable@vger.kernel.org> # v4.10.x: 4d071c3 - PCI/PM: Add needs_resume flag
    Cc: <stable@vger.kernel.org> # v4.10.x
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reported-and-tested-by: Marta Lofstedt <marta.lofstedt@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1493726649-32094-2-git-send-email-imre.deak@intel.com
    (cherry picked from commit adfdf85d795f4d4f487b61ee0b169d64c6e19081)
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>

commit 8fa4338acca96cbc231e4125229632e879476464
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri Jun 2 14:49:45 2017 +1000

    drm/nouveau: enable autosuspend only when it'll actually be used
    
    This prevents a deadlock that somehow results from the suspend() ->
    forbid() -> resume() callchain.
    
    [  125.266960] [drm] Initialized nouveau 1.3.1 20120801 for 0000:02:00.0 on minor 1
    [  370.120872] INFO: task kworker/4:1:77 blocked for more than 120 seconds.
    [  370.120920]       Tainted: G           O    4.12.0-rc3 #20
    [  370.120947] "echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
    [  370.120982] kworker/4:1     D13808    77      2 0x00000000
    [  370.120998] Workqueue: pm pm_runtime_work
    [  370.121004] Call Trace:
    [  370.121018]  __schedule+0x2bf/0xb40
    [  370.121025]  ? mark_held_locks+0x5f/0x90
    [  370.121038]  schedule+0x3d/0x90
    [  370.121044]  rpm_resume+0x107/0x870
    [  370.121052]  ? finish_wait+0x90/0x90
    [  370.121065]  ? pci_pm_runtime_resume+0xa0/0xa0
    [  370.121070]  pm_runtime_forbid+0x4c/0x60
    [  370.121129]  nouveau_pmops_runtime_suspend+0xaf/0xc0 [nouveau]
    [  370.121139]  pci_pm_runtime_suspend+0x5f/0x170
    [  370.121147]  ? pci_pm_runtime_resume+0xa0/0xa0
    [  370.121152]  __rpm_callback+0xb9/0x1e0
    [  370.121159]  ? pci_pm_runtime_resume+0xa0/0xa0
    [  370.121166]  rpm_callback+0x24/0x80
    [  370.121171]  ? pci_pm_runtime_resume+0xa0/0xa0
    [  370.121176]  rpm_suspend+0x138/0x6e0
    [  370.121192]  pm_runtime_work+0x7b/0xc0
    [  370.121199]  process_one_work+0x253/0x6a0
    [  370.121216]  worker_thread+0x4d/0x3b0
    [  370.121229]  kthread+0x133/0x150
    [  370.121234]  ? process_one_work+0x6a0/0x6a0
    [  370.121238]  ? kthread_create_on_node+0x70/0x70
    [  370.121246]  ret_from_fork+0x2a/0x40
    [  370.121283]
                   Showing all locks held in the system:
    [  370.121291] 2 locks held by kworker/4:1/77:
    [  370.121298]  #0:  ("pm"){.+.+.+}, at: [<ffffffffac0d3530>] process_one_work+0x1d0/0x6a0
    [  370.121315]  #1:  ((&dev->power.work)){+.+.+.}, at: [<ffffffffac0d3530>] process_one_work+0x1d0/0x6a0
    [  370.121330] 1 lock held by khungtaskd/81:
    [  370.121333]  #0:  (tasklist_lock){.+.+..}, at: [<ffffffffac10fc8d>] debug_show_all_locks+0x3d/0x1a0
    [  370.121355] 1 lock held by dmesg/1639:
    [  370.121358]  #0:  (&user->lock){+.+.+.}, at: [<ffffffffac124b6d>] devkmsg_read+0x4d/0x360
    
    [  370.121377] =============================================
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

commit adfdf85d795f4d4f487b61ee0b169d64c6e19081
Author: Imre Deak <imre.deak@intel.com>
Date:   Tue May 2 15:04:09 2017 +0300

    drm/i915: Prevent the system suspend complete optimization
    
    Since
    
    commit bac2a909a096c9110525c18cbb8ce73c660d5f71
    Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Date:   Wed Jan 21 02:17:42 2015 +0100
    
        PCI / PM: Avoid resuming PCI devices during system suspend
    
    PCI devices will default to allowing the system suspend complete
    optimization where devices are not woken up during system suspend if
    they were already runtime suspended. This however breaks the i915/HDA
    drivers for two reasons:
    
    - The i915 driver has system suspend specific steps that it needs to
      run, that bring the device to a different state than its runtime
      suspended state.
    
    - The HDA driver's suspend handler requires power that it will request
      from the i915 driver's power domain handler. This in turn requires the
      i915 driver to runtime resume itself, but this won't be possible if the
      suspend complete optimization is in effect: in this case the i915
      runtime PM is disabled and trying to get an RPM reference returns
      -EACCESS.
    
    Solve this by requiring the PCI/PM core to resume the device during
    system suspend which in effect disables the suspend complete optimization.
    
    Regardless of the above commit the optimization stayed disabled for DRM
    devices until
    
    commit d14d2a8453d650bea32a1c5271af1458cd283a0f
    Author: Lukas Wunner <lukas@wunner.de>
    Date:   Wed Jun 8 12:49:29 2016 +0200
    
        drm: Remove dev_pm_ops from drm_class
    
    so this patch is in practice a fix for this commit. Another reason for
    the bug staying hidden for so long is that the optimization for a device
    is disabled if it's disabled for any of its children devices. i915 may
    have a backlight device as its child which doesn't support runtime PM
    and so doesn't allow the optimization either.  So if this backlight
    device got registered the bug stayed hidden.
    
    Credits to Marta, Tomi and David who enabled pstore logging,
    that caught one instance of this issue across a suspend/
    resume-to-ram and Ville who rememberd that the optimization was enabled
    for some devices at one point.
    
    The first WARN triggered by the problem:
    
    [ 6250.746445] WARNING: CPU: 2 PID: 17384 at drivers/gpu/drm/i915/intel_runtime_pm.c:2846 intel_runtime_pm_get+0x6b/0xd0 [i915]
    [ 6250.746448] pm_runtime_get_sync() failed: -13
    [ 6250.746451] Modules linked in: snd_hda_intel i915 vgem snd_hda_codec_hdmi x86_pkg_temp_thermal intel_powerclamp coretemp crct10dif_pclmul crc32_pclmul
    snd_hda_codec_realtek snd_hda_codec_generic ghash_clmulni_intel e1000e snd_hda_codec snd_hwdep snd_hda_core ptp mei_me pps_core snd_pcm lpc_ich mei prime_
    numbers i2c_hid i2c_designware_platform i2c_designware_core [last unloaded: i915]
    [ 6250.746512] CPU: 2 PID: 17384 Comm: kworker/u8:0 Tainted: G     U  W       4.11.0-rc5-CI-CI_DRM_334+ #1
    [ 6250.746515] Hardware name:                  /NUC5i5RYB, BIOS RYBDWi35.86A.0362.2017.0118.0940 01/18/2017
    [ 6250.746521] Workqueue: events_unbound async_run_entry_fn
    [ 6250.746525] Call Trace:
    [ 6250.746530]  dump_stack+0x67/0x92
    [ 6250.746536]  __warn+0xc6/0xe0
    [ 6250.746542]  ? pci_restore_standard_config+0x40/0x40
    [ 6250.746546]  warn_slowpath_fmt+0x46/0x50
    [ 6250.746553]  ? __pm_runtime_resume+0x56/0x80
    [ 6250.746584]  intel_runtime_pm_get+0x6b/0xd0 [i915]
    [ 6250.746610]  intel_display_power_get+0x1b/0x40 [i915]
    [ 6250.746646]  i915_audio_component_get_power+0x15/0x20 [i915]
    [ 6250.746654]  snd_hdac_display_power+0xc8/0x110 [snd_hda_core]
    [ 6250.746661]  azx_runtime_resume+0x218/0x280 [snd_hda_intel]
    [ 6250.746667]  pci_pm_runtime_resume+0x76/0xa0
    [ 6250.746672]  __rpm_callback+0xb4/0x1f0
    [ 6250.746677]  ? pci_restore_standard_config+0x40/0x40
    [ 6250.746682]  rpm_callback+0x1f/0x80
    [ 6250.746686]  ? pci_restore_standard_config+0x40/0x40
    [ 6250.746690]  rpm_resume+0x4ba/0x740
    [ 6250.746698]  __pm_runtime_resume+0x49/0x80
    [ 6250.746703]  pci_pm_suspend+0x57/0x140
    [ 6250.746709]  dpm_run_callback+0x6f/0x330
    [ 6250.746713]  ? pci_pm_freeze+0xe0/0xe0
    [ 6250.746718]  __device_suspend+0xf9/0x370
    [ 6250.746724]  ? dpm_watchdog_set+0x60/0x60
    [ 6250.746730]  async_suspend+0x1a/0x90
    [ 6250.746735]  async_run_entry_fn+0x34/0x160
    [ 6250.746741]  process_one_work+0x1f2/0x6d0
    [ 6250.746749]  worker_thread+0x49/0x4a0
    [ 6250.746755]  kthread+0x107/0x140
    [ 6250.746759]  ? process_one_work+0x6d0/0x6d0
    [ 6250.746763]  ? kthread_create_on_node+0x40/0x40
    [ 6250.746768]  ret_from_fork+0x2e/0x40
    [ 6250.746778] ---[ end trace 102a62fd2160f5e6 ]---
    
    v2:
    - Use the new pci_dev->needs_resume flag, to avoid any overhead during
      the ->pm_prepare hook. (Rafael)
    
    v3:
    - Update commit message to reference the actual regressing commit.
      (Lukas)
    
    v4:
    - Rebase on v4 of patch 1/2.
    
    Fixes: d14d2a8453d6 ("drm: Remove dev_pm_ops from drm_class")
    References: https://bugs.freedesktop.org/show_bug.cgi?id=100378
    References: https://bugs.freedesktop.org/show_bug.cgi?id=100770
    Cc: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: Marta Lofstedt <marta.lofstedt@intel.com>
    Cc: David Weinehall <david.weinehall@linux.intel.com>
    Cc: Tomi Sarvela <tomi.p.sarvela@intel.com>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: Mika Kuoppala <mika.kuoppala@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Takashi Iwai <tiwai@suse.de>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Lukas Wunner <lukas@wunner.de>
    Cc: linux-pci@vger.kernel.org
    Cc: <stable@vger.kernel.org> # v4.10.x: 4d071c3 - PCI/PM: Add needs_resume flag
    Cc: <stable@vger.kernel.org> # v4.10.x
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reported-and-tested-by: Marta Lofstedt <marta.lofstedt@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1493726649-32094-2-git-send-email-imre.deak@intel.com

commit d926ceaa72c89eb928f02b19ac602db6884dc0f3
Author: Marek Szyprowski <m.szyprowski@samsung.com>
Date:   Thu Feb 23 08:43:27 2017 -0300

    s5p-mfc: Fix race between interrupt routine and device functions
    
    commit 0c32b8ec02832df167e16ad659cb11dc148f2ddf upstream.
    
    Interrupt routine must wake process waiting for given interrupt AFTER
    updating driver's internal structures and contexts. Doing it in-between
    is a serious bug. This patch moves all calls to the wake() function to
    the end of the interrupt processing block to avoid potential and real
    races, especially on multi-core platforms. This also fixes following issue
    reported from clock core (clocks were disabled in interrupt after being
    unprepared from the other place in the driver, the stack trace however
    points to the different place than s5p_mfc driver because of the race):
    
    WARNING: CPU: 1 PID: 18 at drivers/clk/clk.c:544 clk_core_unprepare+0xc8/0x108
    Modules linked in:
    CPU: 1 PID: 18 Comm: kworker/1:0 Not tainted 4.10.0-next-20170223-00070-g04e18bc99ab9-dirty #2154
    Hardware name: SAMSUNG EXYNOS (Flattened Device Tree)
    Workqueue: pm pm_runtime_work
    [<c010d8b0>] (unwind_backtrace) from [<c010a534>] (show_stack+0x10/0x14)
    [<c010a534>] (show_stack) from [<c033292c>] (dump_stack+0x74/0x94)
    [<c033292c>] (dump_stack) from [<c011cef4>] (__warn+0xd4/0x100)
    [<c011cef4>] (__warn) from [<c011cf40>] (warn_slowpath_null+0x20/0x28)
    [<c011cf40>] (warn_slowpath_null) from [<c0387a84>] (clk_core_unprepare+0xc8/0x108)
    [<c0387a84>] (clk_core_unprepare) from [<c0389d84>] (clk_unprepare+0x24/0x2c)
    [<c0389d84>] (clk_unprepare) from [<c03d4660>] (exynos_sysmmu_suspend+0x48/0x60)
    [<c03d4660>] (exynos_sysmmu_suspend) from [<c042b9b0>] (pm_generic_runtime_suspend+0x2c/0x38)
    [<c042b9b0>] (pm_generic_runtime_suspend) from [<c0437580>] (genpd_runtime_suspend+0x94/0x220)
    [<c0437580>] (genpd_runtime_suspend) from [<c042e240>] (__rpm_callback+0x134/0x208)
    [<c042e240>] (__rpm_callback) from [<c042e334>] (rpm_callback+0x20/0x80)
    [<c042e334>] (rpm_callback) from [<c042d3b8>] (rpm_suspend+0xdc/0x458)
    [<c042d3b8>] (rpm_suspend) from [<c042ea24>] (pm_runtime_work+0x80/0x90)
    [<c042ea24>] (pm_runtime_work) from [<c01322c4>] (process_one_work+0x120/0x318)
    [<c01322c4>] (process_one_work) from [<c0132520>] (worker_thread+0x2c/0x4ac)
    [<c0132520>] (worker_thread) from [<c0137ab0>] (kthread+0xfc/0x134)
    [<c0137ab0>] (kthread) from [<c0107978>] (ret_from_fork+0x14/0x3c)
    ---[ end trace 1ead49a7bb83f0d8 ]---
    
    Fixes: af93574678108 ("[media] MFC: Add MFC 5.1 V4L2 driver")
    
    Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Reviewed-by: Javier Martinez Canillas <javier@osg.samsung.com>
    Signed-off-by: Sylwester Nawrocki <s.nawrocki@samsung.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 826ca313fd1068d4128f97ac6893156b5e303e9c
Author: Jeeja KP <jeeja.kp@intel.com>
Date:   Wed May 10 11:51:58 2017 +0530

    ALSA: hda: Fix cpu lockup when stopping the cmd dmas
    
    commit 960013762df0a214b57f2fce655422fb52bdfd2c upstream.
    
    Using jiffies in hdac_wait_for_cmd_dmas() to determine when to time out
    when interrupts are off (snd_hdac_bus_stop_cmd_io()/spin_lock_irq())
    causes hard lockup so unlock while waiting using jiffies.
    
    ---<-snip->---
    <0>[ 1211.603046] NMI watchdog: Watchdog detected hard LOCKUP on cpu 3
    <4>[ 1211.603047] Modules linked in: snd_hda_intel i915 vgem
    <4>[ 1211.603053] irq event stamp: 13366
    <4>[ 1211.603053] hardirqs last  enabled at (13365):
    ...
    <4>[ 1211.603059] Call Trace:
    <4>[ 1211.603059]  ? delay_tsc+0x3d/0xc0
    <4>[ 1211.603059]  __delay+0xa/0x10
    <4>[ 1211.603060]  __const_udelay+0x31/0x40
    <4>[ 1211.603060]  snd_hdac_bus_stop_cmd_io+0x96/0xe0 [snd_hda_core]
    <4>[ 1211.603060]  ? azx_dev_disconnect+0x20/0x20 [snd_hda_intel]
    <4>[ 1211.603061]  snd_hdac_bus_stop_chip+0xb1/0x100 [snd_hda_core]
    <4>[ 1211.603061]  azx_stop_chip+0x9/0x10 [snd_hda_codec]
    <4>[ 1211.603061]  azx_suspend+0x72/0x220 [snd_hda_intel]
    <4>[ 1211.603061]  pci_pm_suspend+0x71/0x140
    <4>[ 1211.603062]  dpm_run_callback+0x6f/0x330
    <4>[ 1211.603062]  ? pci_pm_freeze+0xe0/0xe0
    <4>[ 1211.603062]  __device_suspend+0xf9/0x370
    <4>[ 1211.603062]  ? dpm_watchdog_set+0x60/0x60
    <4>[ 1211.603063]  async_suspend+0x1a/0x90
    <4>[ 1211.603063]  async_run_entry_fn+0x34/0x160
    <4>[ 1211.603063]  process_one_work+0x1f4/0x6d0
    <4>[ 1211.603063]  ? process_one_work+0x16e/0x6d0
    <4>[ 1211.603064]  worker_thread+0x49/0x4a0
    <4>[ 1211.603064]  kthread+0x107/0x140
    <4>[ 1211.603064]  ? process_one_work+0x6d0/0x6d0
    <4>[ 1211.603065]  ? kthread_create_on_node+0x40/0x40
    <4>[ 1211.603065]  ret_from_fork+0x2e/0x40
    
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=100419
    Fixes: 38b19ed7f81ec ("ALSA: hda: fix to wait for RIRB & CORB DMA to set")
    Reported-by: Marta Lofstedt <marta.lofstedt@intel.com>
    Suggested-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jeeja KP <jeeja.kp@intel.com>
    Acked-by: Vinod Koul <vinod.koul@intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit e2f95f88106f32b1e82898d0a2a757366e2cbc5f
Author: Marek Szyprowski <m.szyprowski@samsung.com>
Date:   Thu Feb 23 08:43:27 2017 -0300

    s5p-mfc: Fix race between interrupt routine and device functions
    
    commit 0c32b8ec02832df167e16ad659cb11dc148f2ddf upstream.
    
    Interrupt routine must wake process waiting for given interrupt AFTER
    updating driver's internal structures and contexts. Doing it in-between
    is a serious bug. This patch moves all calls to the wake() function to
    the end of the interrupt processing block to avoid potential and real
    races, especially on multi-core platforms. This also fixes following issue
    reported from clock core (clocks were disabled in interrupt after being
    unprepared from the other place in the driver, the stack trace however
    points to the different place than s5p_mfc driver because of the race):
    
    WARNING: CPU: 1 PID: 18 at drivers/clk/clk.c:544 clk_core_unprepare+0xc8/0x108
    Modules linked in:
    CPU: 1 PID: 18 Comm: kworker/1:0 Not tainted 4.10.0-next-20170223-00070-g04e18bc99ab9-dirty #2154
    Hardware name: SAMSUNG EXYNOS (Flattened Device Tree)
    Workqueue: pm pm_runtime_work
    [<c010d8b0>] (unwind_backtrace) from [<c010a534>] (show_stack+0x10/0x14)
    [<c010a534>] (show_stack) from [<c033292c>] (dump_stack+0x74/0x94)
    [<c033292c>] (dump_stack) from [<c011cef4>] (__warn+0xd4/0x100)
    [<c011cef4>] (__warn) from [<c011cf40>] (warn_slowpath_null+0x20/0x28)
    [<c011cf40>] (warn_slowpath_null) from [<c0387a84>] (clk_core_unprepare+0xc8/0x108)
    [<c0387a84>] (clk_core_unprepare) from [<c0389d84>] (clk_unprepare+0x24/0x2c)
    [<c0389d84>] (clk_unprepare) from [<c03d4660>] (exynos_sysmmu_suspend+0x48/0x60)
    [<c03d4660>] (exynos_sysmmu_suspend) from [<c042b9b0>] (pm_generic_runtime_suspend+0x2c/0x38)
    [<c042b9b0>] (pm_generic_runtime_suspend) from [<c0437580>] (genpd_runtime_suspend+0x94/0x220)
    [<c0437580>] (genpd_runtime_suspend) from [<c042e240>] (__rpm_callback+0x134/0x208)
    [<c042e240>] (__rpm_callback) from [<c042e334>] (rpm_callback+0x20/0x80)
    [<c042e334>] (rpm_callback) from [<c042d3b8>] (rpm_suspend+0xdc/0x458)
    [<c042d3b8>] (rpm_suspend) from [<c042ea24>] (pm_runtime_work+0x80/0x90)
    [<c042ea24>] (pm_runtime_work) from [<c01322c4>] (process_one_work+0x120/0x318)
    [<c01322c4>] (process_one_work) from [<c0132520>] (worker_thread+0x2c/0x4ac)
    [<c0132520>] (worker_thread) from [<c0137ab0>] (kthread+0xfc/0x134)
    [<c0137ab0>] (kthread) from [<c0107978>] (ret_from_fork+0x14/0x3c)
    ---[ end trace 1ead49a7bb83f0d8 ]---
    
    Fixes: af93574678108 ("[media] MFC: Add MFC 5.1 V4L2 driver")
    
    Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Reviewed-by: Javier Martinez Canillas <javier@osg.samsung.com>
    Signed-off-by: Sylwester Nawrocki <s.nawrocki@samsung.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 0251f6affb1170a3c3364651a1c2757526cbfb88
Author: Jeeja KP <jeeja.kp@intel.com>
Date:   Wed May 10 11:51:58 2017 +0530

    ALSA: hda: Fix cpu lockup when stopping the cmd dmas
    
    commit 960013762df0a214b57f2fce655422fb52bdfd2c upstream.
    
    Using jiffies in hdac_wait_for_cmd_dmas() to determine when to time out
    when interrupts are off (snd_hdac_bus_stop_cmd_io()/spin_lock_irq())
    causes hard lockup so unlock while waiting using jiffies.
    
    ---<-snip->---
    <0>[ 1211.603046] NMI watchdog: Watchdog detected hard LOCKUP on cpu 3
    <4>[ 1211.603047] Modules linked in: snd_hda_intel i915 vgem
    <4>[ 1211.603053] irq event stamp: 13366
    <4>[ 1211.603053] hardirqs last  enabled at (13365):
    ...
    <4>[ 1211.603059] Call Trace:
    <4>[ 1211.603059]  ? delay_tsc+0x3d/0xc0
    <4>[ 1211.603059]  __delay+0xa/0x10
    <4>[ 1211.603060]  __const_udelay+0x31/0x40
    <4>[ 1211.603060]  snd_hdac_bus_stop_cmd_io+0x96/0xe0 [snd_hda_core]
    <4>[ 1211.603060]  ? azx_dev_disconnect+0x20/0x20 [snd_hda_intel]
    <4>[ 1211.603061]  snd_hdac_bus_stop_chip+0xb1/0x100 [snd_hda_core]
    <4>[ 1211.603061]  azx_stop_chip+0x9/0x10 [snd_hda_codec]
    <4>[ 1211.603061]  azx_suspend+0x72/0x220 [snd_hda_intel]
    <4>[ 1211.603061]  pci_pm_suspend+0x71/0x140
    <4>[ 1211.603062]  dpm_run_callback+0x6f/0x330
    <4>[ 1211.603062]  ? pci_pm_freeze+0xe0/0xe0
    <4>[ 1211.603062]  __device_suspend+0xf9/0x370
    <4>[ 1211.603062]  ? dpm_watchdog_set+0x60/0x60
    <4>[ 1211.603063]  async_suspend+0x1a/0x90
    <4>[ 1211.603063]  async_run_entry_fn+0x34/0x160
    <4>[ 1211.603063]  process_one_work+0x1f4/0x6d0
    <4>[ 1211.603063]  ? process_one_work+0x16e/0x6d0
    <4>[ 1211.603064]  worker_thread+0x49/0x4a0
    <4>[ 1211.603064]  kthread+0x107/0x140
    <4>[ 1211.603064]  ? process_one_work+0x6d0/0x6d0
    <4>[ 1211.603065]  ? kthread_create_on_node+0x40/0x40
    <4>[ 1211.603065]  ret_from_fork+0x2e/0x40
    
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=100419
    Fixes: 38b19ed7f81ec ("ALSA: hda: fix to wait for RIRB & CORB DMA to set")
    Reported-by: Marta Lofstedt <marta.lofstedt@intel.com>
    Suggested-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jeeja KP <jeeja.kp@intel.com>
    Acked-by: Vinod Koul <vinod.koul@intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 90d4e2a6592da98bfa99941bddd0d83ae789a565
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Mon Mar 20 11:16:11 2017 -0700

    usb: hub: Fix error loop seen after hub communication errors
    
    commit 245b2eecee2aac6fdc77dcafaa73c33f9644c3c7 upstream.
    
    While stress testing a usb controller using a bind/unbind looop, the
    following error loop was observed.
    
    usb 7-1.2: new low-speed USB device number 3 using xhci-hcd
    usb 7-1.2: hub failed to enable device, error -108
    usb 7-1-port2: cannot disable (err = -22)
    usb 7-1-port2: couldn't allocate usb_device
    usb 7-1-port2: cannot disable (err = -22)
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: activate --> -22
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: activate --> -22
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: activate --> -22
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: activate --> -22
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: activate --> -22
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: activate --> -22
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: activate --> -22
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: activate --> -22
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    ** 57 printk messages dropped ** hub 7-1:1.0: activate --> -22
    ** 82 printk messages dropped ** hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    
    This continues forever. After adding tracebacks into the code,
    the call sequence leading to this is found to be as follows.
    
    [<ffffffc0007fc8e0>] hub_activate+0x368/0x7b8
    [<ffffffc0007fceb4>] hub_resume+0x2c/0x3c
    [<ffffffc00080b3b8>] usb_resume_interface.isra.6+0x128/0x158
    [<ffffffc00080b5d0>] usb_suspend_both+0x1e8/0x288
    [<ffffffc00080c9c4>] usb_runtime_suspend+0x3c/0x98
    [<ffffffc0007820a0>] __rpm_callback+0x48/0x7c
    [<ffffffc00078217c>] rpm_callback+0xa8/0xd4
    [<ffffffc000786234>] rpm_suspend+0x84/0x758
    [<ffffffc000786ca4>] rpm_idle+0x2c8/0x498
    [<ffffffc000786ed4>] __pm_runtime_idle+0x60/0xac
    [<ffffffc00080eba8>] usb_autopm_put_interface+0x6c/0x7c
    [<ffffffc000803798>] hub_event+0x10ac/0x12ac
    [<ffffffc000249bb8>] process_one_work+0x390/0x6b8
    [<ffffffc00024abcc>] worker_thread+0x480/0x610
    [<ffffffc000251a80>] kthread+0x164/0x178
    [<ffffffc0002045d0>] ret_from_fork+0x10/0x40
    
    kick_hub_wq() is called from hub_activate() even after failures to
    communicate with the hub. This results in an endless sequence of
    hub event -> hub activate -> wq trigger -> hub event -> ...
    
    Provide two solutions for the problem.
    
    - Only trigger the hub event queue if communication with the hub
      is successful.
    - After a suspend failure, only resume already suspended interfaces
      if the communication with the device is still possible.
    
    Each of the changes fixes the observed problem. Use both to improve
    robustness.
    
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 5830c376e3afad4272e31e2eab87f04333f0ca80
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Mon Mar 20 11:16:11 2017 -0700

    usb: hub: Fix error loop seen after hub communication errors
    
    commit 245b2eecee2aac6fdc77dcafaa73c33f9644c3c7 upstream.
    
    While stress testing a usb controller using a bind/unbind looop, the
    following error loop was observed.
    
    usb 7-1.2: new low-speed USB device number 3 using xhci-hcd
    usb 7-1.2: hub failed to enable device, error -108
    usb 7-1-port2: cannot disable (err = -22)
    usb 7-1-port2: couldn't allocate usb_device
    usb 7-1-port2: cannot disable (err = -22)
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: activate --> -22
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: activate --> -22
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: activate --> -22
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: activate --> -22
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: activate --> -22
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: activate --> -22
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: activate --> -22
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: activate --> -22
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    ** 57 printk messages dropped ** hub 7-1:1.0: activate --> -22
    ** 82 printk messages dropped ** hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    
    This continues forever. After adding tracebacks into the code,
    the call sequence leading to this is found to be as follows.
    
    [<ffffffc0007fc8e0>] hub_activate+0x368/0x7b8
    [<ffffffc0007fceb4>] hub_resume+0x2c/0x3c
    [<ffffffc00080b3b8>] usb_resume_interface.isra.6+0x128/0x158
    [<ffffffc00080b5d0>] usb_suspend_both+0x1e8/0x288
    [<ffffffc00080c9c4>] usb_runtime_suspend+0x3c/0x98
    [<ffffffc0007820a0>] __rpm_callback+0x48/0x7c
    [<ffffffc00078217c>] rpm_callback+0xa8/0xd4
    [<ffffffc000786234>] rpm_suspend+0x84/0x758
    [<ffffffc000786ca4>] rpm_idle+0x2c8/0x498
    [<ffffffc000786ed4>] __pm_runtime_idle+0x60/0xac
    [<ffffffc00080eba8>] usb_autopm_put_interface+0x6c/0x7c
    [<ffffffc000803798>] hub_event+0x10ac/0x12ac
    [<ffffffc000249bb8>] process_one_work+0x390/0x6b8
    [<ffffffc00024abcc>] worker_thread+0x480/0x610
    [<ffffffc000251a80>] kthread+0x164/0x178
    [<ffffffc0002045d0>] ret_from_fork+0x10/0x40
    
    kick_hub_wq() is called from hub_activate() even after failures to
    communicate with the hub. This results in an endless sequence of
    hub event -> hub activate -> wq trigger -> hub event -> ...
    
    Provide two solutions for the problem.
    
    - Only trigger the hub event queue if communication with the hub
      is successful.
    - After a suspend failure, only resume already suspended interfaces
      if the communication with the device is still possible.
    
    Each of the changes fixes the observed problem. Use both to improve
    robustness.
    
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 181b0de7f7cc80bfaca75b69872e4648fc03c782
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Mon Mar 20 11:16:11 2017 -0700

    usb: hub: Fix error loop seen after hub communication errors
    
    commit 245b2eecee2aac6fdc77dcafaa73c33f9644c3c7 upstream.
    
    While stress testing a usb controller using a bind/unbind looop, the
    following error loop was observed.
    
    usb 7-1.2: new low-speed USB device number 3 using xhci-hcd
    usb 7-1.2: hub failed to enable device, error -108
    usb 7-1-port2: cannot disable (err = -22)
    usb 7-1-port2: couldn't allocate usb_device
    usb 7-1-port2: cannot disable (err = -22)
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: activate --> -22
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: activate --> -22
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: activate --> -22
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: activate --> -22
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: activate --> -22
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: activate --> -22
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: activate --> -22
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: activate --> -22
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    ** 57 printk messages dropped ** hub 7-1:1.0: activate --> -22
    ** 82 printk messages dropped ** hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    
    This continues forever. After adding tracebacks into the code,
    the call sequence leading to this is found to be as follows.
    
    [<ffffffc0007fc8e0>] hub_activate+0x368/0x7b8
    [<ffffffc0007fceb4>] hub_resume+0x2c/0x3c
    [<ffffffc00080b3b8>] usb_resume_interface.isra.6+0x128/0x158
    [<ffffffc00080b5d0>] usb_suspend_both+0x1e8/0x288
    [<ffffffc00080c9c4>] usb_runtime_suspend+0x3c/0x98
    [<ffffffc0007820a0>] __rpm_callback+0x48/0x7c
    [<ffffffc00078217c>] rpm_callback+0xa8/0xd4
    [<ffffffc000786234>] rpm_suspend+0x84/0x758
    [<ffffffc000786ca4>] rpm_idle+0x2c8/0x498
    [<ffffffc000786ed4>] __pm_runtime_idle+0x60/0xac
    [<ffffffc00080eba8>] usb_autopm_put_interface+0x6c/0x7c
    [<ffffffc000803798>] hub_event+0x10ac/0x12ac
    [<ffffffc000249bb8>] process_one_work+0x390/0x6b8
    [<ffffffc00024abcc>] worker_thread+0x480/0x610
    [<ffffffc000251a80>] kthread+0x164/0x178
    [<ffffffc0002045d0>] ret_from_fork+0x10/0x40
    
    kick_hub_wq() is called from hub_activate() even after failures to
    communicate with the hub. This results in an endless sequence of
    hub event -> hub activate -> wq trigger -> hub event -> ...
    
    Provide two solutions for the problem.
    
    - Only trigger the hub event queue if communication with the hub
      is successful.
    - After a suspend failure, only resume already suspended interfaces
      if the communication with the device is still possible.
    
    Each of the changes fixes the observed problem. Use both to improve
    robustness.
    
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 0b4dad7c2cf4139989386db0ac0cf86639692fd9
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Mon Mar 20 11:16:11 2017 -0700

    usb: hub: Fix error loop seen after hub communication errors
    
    commit 245b2eecee2aac6fdc77dcafaa73c33f9644c3c7 upstream.
    
    While stress testing a usb controller using a bind/unbind looop, the
    following error loop was observed.
    
    usb 7-1.2: new low-speed USB device number 3 using xhci-hcd
    usb 7-1.2: hub failed to enable device, error -108
    usb 7-1-port2: cannot disable (err = -22)
    usb 7-1-port2: couldn't allocate usb_device
    usb 7-1-port2: cannot disable (err = -22)
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: activate --> -22
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: activate --> -22
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: activate --> -22
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: activate --> -22
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: activate --> -22
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: activate --> -22
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: activate --> -22
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: activate --> -22
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    ** 57 printk messages dropped ** hub 7-1:1.0: activate --> -22
    ** 82 printk messages dropped ** hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    
    This continues forever. After adding tracebacks into the code,
    the call sequence leading to this is found to be as follows.
    
    [<ffffffc0007fc8e0>] hub_activate+0x368/0x7b8
    [<ffffffc0007fceb4>] hub_resume+0x2c/0x3c
    [<ffffffc00080b3b8>] usb_resume_interface.isra.6+0x128/0x158
    [<ffffffc00080b5d0>] usb_suspend_both+0x1e8/0x288
    [<ffffffc00080c9c4>] usb_runtime_suspend+0x3c/0x98
    [<ffffffc0007820a0>] __rpm_callback+0x48/0x7c
    [<ffffffc00078217c>] rpm_callback+0xa8/0xd4
    [<ffffffc000786234>] rpm_suspend+0x84/0x758
    [<ffffffc000786ca4>] rpm_idle+0x2c8/0x498
    [<ffffffc000786ed4>] __pm_runtime_idle+0x60/0xac
    [<ffffffc00080eba8>] usb_autopm_put_interface+0x6c/0x7c
    [<ffffffc000803798>] hub_event+0x10ac/0x12ac
    [<ffffffc000249bb8>] process_one_work+0x390/0x6b8
    [<ffffffc00024abcc>] worker_thread+0x480/0x610
    [<ffffffc000251a80>] kthread+0x164/0x178
    [<ffffffc0002045d0>] ret_from_fork+0x10/0x40
    
    kick_hub_wq() is called from hub_activate() even after failures to
    communicate with the hub. This results in an endless sequence of
    hub event -> hub activate -> wq trigger -> hub event -> ...
    
    Provide two solutions for the problem.
    
    - Only trigger the hub event queue if communication with the hub
      is successful.
    - After a suspend failure, only resume already suspended interfaces
      if the communication with the device is still possible.
    
    Each of the changes fixes the observed problem. Use both to improve
    robustness.
    
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 50b7c322cfc8b44a36b1373dab2177db23e3282c
Author: Rui Miguel Silva <rmfrfs@gmail.com>
Date:   Fri May 12 21:16:15 2017 +0100

    staging: typec: fusb302: refactor resume retry mechanism
    
    The i2c functions need to test the pm_suspend state and do, if needed, some
    retry before i2c operations. This code was repeated 4x.
    
    To isolate this, create a new function to check suspend state and call it in
    every need place.
    
    As at it, move the error message from pr_err to dev_err.
    
    Signed-off-by: Rui Miguel Silva <rmfrfs@gmail.com>
    Acked-by: Yueyao Zhu <yueyao.zhu@gmail.com>
    Reviewed-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 960013762df0a214b57f2fce655422fb52bdfd2c
Author: Jeeja KP <jeeja.kp@intel.com>
Date:   Wed May 10 11:51:58 2017 +0530

    ALSA: hda: Fix cpu lockup when stopping the cmd dmas
    
    Using jiffies in hdac_wait_for_cmd_dmas() to determine when to time out
    when interrupts are off (snd_hdac_bus_stop_cmd_io()/spin_lock_irq())
    causes hard lockup so unlock while waiting using jiffies.
    
    ---<-snip->---
    <0>[ 1211.603046] NMI watchdog: Watchdog detected hard LOCKUP on cpu 3
    <4>[ 1211.603047] Modules linked in: snd_hda_intel i915 vgem
    <4>[ 1211.603053] irq event stamp: 13366
    <4>[ 1211.603053] hardirqs last  enabled at (13365):
    ...
    <4>[ 1211.603059] Call Trace:
    <4>[ 1211.603059]  ? delay_tsc+0x3d/0xc0
    <4>[ 1211.603059]  __delay+0xa/0x10
    <4>[ 1211.603060]  __const_udelay+0x31/0x40
    <4>[ 1211.603060]  snd_hdac_bus_stop_cmd_io+0x96/0xe0 [snd_hda_core]
    <4>[ 1211.603060]  ? azx_dev_disconnect+0x20/0x20 [snd_hda_intel]
    <4>[ 1211.603061]  snd_hdac_bus_stop_chip+0xb1/0x100 [snd_hda_core]
    <4>[ 1211.603061]  azx_stop_chip+0x9/0x10 [snd_hda_codec]
    <4>[ 1211.603061]  azx_suspend+0x72/0x220 [snd_hda_intel]
    <4>[ 1211.603061]  pci_pm_suspend+0x71/0x140
    <4>[ 1211.603062]  dpm_run_callback+0x6f/0x330
    <4>[ 1211.603062]  ? pci_pm_freeze+0xe0/0xe0
    <4>[ 1211.603062]  __device_suspend+0xf9/0x370
    <4>[ 1211.603062]  ? dpm_watchdog_set+0x60/0x60
    <4>[ 1211.603063]  async_suspend+0x1a/0x90
    <4>[ 1211.603063]  async_run_entry_fn+0x34/0x160
    <4>[ 1211.603063]  process_one_work+0x1f4/0x6d0
    <4>[ 1211.603063]  ? process_one_work+0x16e/0x6d0
    <4>[ 1211.603064]  worker_thread+0x49/0x4a0
    <4>[ 1211.603064]  kthread+0x107/0x140
    <4>[ 1211.603064]  ? process_one_work+0x6d0/0x6d0
    <4>[ 1211.603065]  ? kthread_create_on_node+0x40/0x40
    <4>[ 1211.603065]  ret_from_fork+0x2e/0x40
    
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=100419
    Fixes: 38b19ed7f81ec ("ALSA: hda: fix to wait for RIRB & CORB DMA to set")
    Reported-by: Marta Lofstedt <marta.lofstedt@intel.com>
    Suggested-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jeeja KP <jeeja.kp@intel.com>
    Acked-by: Vinod Koul <vinod.koul@intel.com>
    CC: stable <stable@vger.kernel.org> # 4.7
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

commit 8d648aad05811ccc07df22834de60a7bf8d9e0e6
Merge: e07e368b27c3 17e310b8eef5
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue May 9 09:49:36 2017 -0700

    Merge tag 'armsoc-soc' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC platform updates from Olof Johansson:
     "SoC platform changes (arch/arm/mach-*). This merge window, the bulk is
      for a few platforms:
    
      Gemini:
       - Legacy platform that Linus Walleij has converted to multiplatform
         and DT, so a handful of various tweaks there, removal of some old
         stale support, etc.
    
      Atmel AT91:
       - Fixup of various power management related pieces
       - Move of SoC detection to a drivers/soc driver instead
    
      ST Micro STM32:
       - New SoC support: STM32H743
    
      TI platforms:
       - More driver support for Davinci (SATA in particular)
       - Removal of some old stale hwmod files (linkspace platform)
    
      Misc:
       - A couple of smaller patches for i.MX, sunxi, hisi"
    
    * tag 'armsoc-soc' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (57 commits)
      ARM: davinci: Add clock for CPPI 4.1 DMA engine
      ARM: mxs: add support for I2SE Duckbill 2 boards
      MAINTAINERS: Update the Allwinner sunXi entry
      ARM: i.MX25: globally disable supervisor protect
      ARM: at91: move SoC detection to its own driver
      ARM: at91: pm: correct typo
      ARM: at91: pm: Remove at91_pm_set_standby
      ARM: at91: pm: Merge all at91sam9*_pm_init
      ARM: at91: pm: Tie the USB clock mask to the pmc
      ARM: at91: pm: Tie the memory controller type to the ramc id
      ARM: at91: pm: Workaround DDRSDRC self-refresh bug with LPDDR1 memories.
      ARM: at91: pm: Simplify at91rm9200_standby
      ARM: at91: pm: Use struct at91_pm_data in pm_suspend.S
      ARM: at91: pm: Move global variables into at91_pm_data
      ARM: at91: pm: Move at91_ramc_read/write to pm.c
      ARM: at91: pm: Cleanup headers
      MAINTAINERS: Add memory drivers to AT91 entry
      MAINTAINERS: Update AT91 entry
      ARM: davinci: add pata_bk3710 libata driver support
      ARM: OMAP2+: mark omap_init_rng as __init
      ...

commit 51d638b1f56a0bfd9219800620994794a1a2b219
Author: Wanpeng Li <wanpeng.li@hotmail.com>
Date:   Sun May 7 00:14:22 2017 -0700

    block/mq: fix potential deadlock during cpu hotplug
    
    This can be triggered by hot-unplug one cpu.
    
    ======================================================
     [ INFO: possible circular locking dependency detected ]
     4.11.0+ #17 Not tainted
     -------------------------------------------------------
     step_after_susp/2640 is trying to acquire lock:
      (all_q_mutex){+.+...}, at: [<ffffffffb33f95b8>] blk_mq_queue_reinit_work+0x18/0x110
    
     but task is already holding lock:
      (cpu_hotplug.lock){+.+.+.}, at: [<ffffffffb306d04f>] cpu_hotplug_begin+0x7f/0xe0
    
     which lock already depends on the new lock.
    
     the existing dependency chain (in reverse order) is:
    
     -> #1 (cpu_hotplug.lock){+.+.+.}:
            lock_acquire+0x11c/0x230
            __mutex_lock+0x92/0x990
            mutex_lock_nested+0x1b/0x20
            get_online_cpus+0x64/0x80
            blk_mq_init_allocated_queue+0x3a0/0x4e0
            blk_mq_init_queue+0x3a/0x60
            loop_add+0xe5/0x280
            loop_init+0x124/0x177
            do_one_initcall+0x53/0x1c0
            kernel_init_freeable+0x1e3/0x27f
            kernel_init+0xe/0x100
            ret_from_fork+0x31/0x40
    
     -> #0 (all_q_mutex){+.+...}:
            __lock_acquire+0x189a/0x18a0
            lock_acquire+0x11c/0x230
            __mutex_lock+0x92/0x990
            mutex_lock_nested+0x1b/0x20
            blk_mq_queue_reinit_work+0x18/0x110
            blk_mq_queue_reinit_dead+0x1c/0x20
            cpuhp_invoke_callback+0x1f2/0x810
            cpuhp_down_callbacks+0x42/0x80
            _cpu_down+0xb2/0xe0
            freeze_secondary_cpus+0xb6/0x390
            suspend_devices_and_enter+0x3b3/0xa40
            pm_suspend+0x129/0x490
            state_store+0x82/0xf0
            kobj_attr_store+0xf/0x20
            sysfs_kf_write+0x45/0x60
            kernfs_fop_write+0x135/0x1c0
            __vfs_write+0x37/0x160
            vfs_write+0xcd/0x1d0
            SyS_write+0x58/0xc0
            do_syscall_64+0x8f/0x710
            return_from_SYSCALL_64+0x0/0x7a
    
     other info that might help us debug this:
    
      Possible unsafe locking scenario:
    
            CPU0                    CPU1
            ----                    ----
       lock(cpu_hotplug.lock);
                                    lock(all_q_mutex);
                                    lock(cpu_hotplug.lock);
       lock(all_q_mutex);
    
      *** DEADLOCK ***
    
     8 locks held by step_after_susp/2640:
      #0:  (sb_writers#6){.+.+.+}, at: [<ffffffffb3244aed>] vfs_write+0x1ad/0x1d0
      #1:  (&of->mutex){+.+.+.}, at: [<ffffffffb32d3a51>] kernfs_fop_write+0x101/0x1c0
      #2:  (s_active#166){.+.+.+}, at: [<ffffffffb32d3a59>] kernfs_fop_write+0x109/0x1c0
      #3:  (pm_mutex){+.+...}, at: [<ffffffffb30d2ecd>] pm_suspend+0x21d/0x490
      #4:  (acpi_scan_lock){+.+.+.}, at: [<ffffffffb34dc3d7>] acpi_scan_lock_acquire+0x17/0x20
      #5:  (cpu_add_remove_lock){+.+.+.}, at: [<ffffffffb306d6d7>] freeze_secondary_cpus+0x27/0x390
      #6:  (cpu_hotplug.dep_map){++++++}, at: [<ffffffffb306cfd5>] cpu_hotplug_begin+0x5/0xe0
      #7:  (cpu_hotplug.lock){+.+.+.}, at: [<ffffffffb306d04f>] cpu_hotplug_begin+0x7f/0xe0
    
     stack backtrace:
     CPU: 3 PID: 2640 Comm: step_after_susp Not tainted 4.11.0+ #17
     Hardware name: Dell Inc. OptiPlex 7040/0JCTF8, BIOS 1.4.9 09/12/2016
     Call Trace:
      dump_stack+0x99/0xce
      print_circular_bug+0x1fa/0x270
      __lock_acquire+0x189a/0x18a0
      lock_acquire+0x11c/0x230
      ? lock_acquire+0x11c/0x230
      ? blk_mq_queue_reinit_work+0x18/0x110
      ? blk_mq_queue_reinit_work+0x18/0x110
      __mutex_lock+0x92/0x990
      ? blk_mq_queue_reinit_work+0x18/0x110
      ? kmem_cache_free+0x2cb/0x330
      ? anon_transport_class_unregister+0x20/0x20
      ? blk_mq_queue_reinit_work+0x110/0x110
      mutex_lock_nested+0x1b/0x20
      ? mutex_lock_nested+0x1b/0x20
      blk_mq_queue_reinit_work+0x18/0x110
      blk_mq_queue_reinit_dead+0x1c/0x20
      cpuhp_invoke_callback+0x1f2/0x810
      ? __flow_cache_shrink+0x160/0x160
      cpuhp_down_callbacks+0x42/0x80
      _cpu_down+0xb2/0xe0
      freeze_secondary_cpus+0xb6/0x390
      suspend_devices_and_enter+0x3b3/0xa40
      ? rcu_read_lock_sched_held+0x79/0x80
      pm_suspend+0x129/0x490
      state_store+0x82/0xf0
      kobj_attr_store+0xf/0x20
      sysfs_kf_write+0x45/0x60
      kernfs_fop_write+0x135/0x1c0
      __vfs_write+0x37/0x160
      ? rcu_read_lock_sched_held+0x79/0x80
      ? rcu_sync_lockdep_assert+0x2f/0x60
      ? __sb_start_write+0xd9/0x1c0
      ? vfs_write+0x1ad/0x1d0
      vfs_write+0xcd/0x1d0
      SyS_write+0x58/0xc0
      ? rcu_read_lock_sched_held+0x79/0x80
      do_syscall_64+0x8f/0x710
      ? trace_hardirqs_on_thunk+0x1a/0x1c
      entry_SYSCALL64_slow_path+0x25/0x25
    
    The cpu hotplug path will hold cpu_hotplug.lock and then reinit all exiting
    queues for blk mq w/ all_q_mutex, however, blk_mq_init_allocated_queue() will
    contend these two locks in the inversion order. This is due to commit eabe06595d62
    (blk/mq: Cure cpu hotplug lock inversion), it fixes a cpu hotplug lock inversion
    issue because of hotplug rework, however the hotplug rework is still work-in-progress
    and lives in a -tip branch and mainline cannot yet trigger that splat. The commit
    breaks the linus's tree in the merge window, so this patch reverts the lock order
    and avoids to splat linus's tree.
    
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Wanpeng Li <wanpeng.li@hotmail.com>
    Signed-off-by: Jens Axboe <axboe@fb.com>

commit 96dabe99cae8a1b5fc645f213eeac928541d3899
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Apr 21 14:58:15 2017 +0100

    drm/i915: Avoid busy-spinning on VLV_GLTC_PW_STATUS mmio
    
    The busy-spin, as the first stage of intel_wait_for_register(), is
    currently under suspicion for causing:
    
    [   62.034926] NMI watchdog: Watchdog detected hard LOCKUP on cpu 1
    [   62.034928] Modules linked in: i2c_dev i915 intel_gtt drm_kms_helper prime_numbers
    [   62.034932] CPU: 1 PID: 183 Comm: kworker/1:2 Not tainted 4.11.0-rc7+ #471
    [   62.034933] Hardware name:                  /        , BIOS PYBSWCEL.86A.0027.2015.0507.1758 05/07/2015
    [   62.034934] Workqueue: pm pm_runtime_work
    [   62.034936] task: ffff880275a04ec0 task.stack: ffffc900002d8000
    [   62.034936] RIP: 0010:__intel_wait_for_register_fw+0x77/0x1a0 [i915]
    [   62.034937] RSP: 0018:ffffc900002dbc38 EFLAGS: 00000082
    [   62.034939] RAX: ffffc90003530094 RBX: 0000000000130094 RCX: 0000000000000001
    [   62.034940] RDX: 00000000000000a1 RSI: ffff88027fd15e58 RDI: 0000000000000000
    [   62.034941] RBP: ffffc900002dbc78 R08: 0000000000000002 R09: 0000000000000000
    [   62.034942] R10: ffffc900002dbc18 R11: ffff880276429dd0 R12: ffff8802707c0000
    [   62.034943] R13: 00000000000000a0 R14: 0000000000000000 R15: 00000000fffefc10
    [   62.034945] FS:  0000000000000000(0000) GS:ffff88027fd00000(0000) knlGS:0000000000000000
    [   62.034945] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [   62.034947] CR2: 00007ffd3cd98ff8 CR3: 0000000274c19000 CR4: 00000000001006e0
    [   62.034947] Call Trace:
    [   62.034948]  intel_wait_for_register+0x77/0x140 [i915]
    [   62.034949]  vlv_suspend_complete+0x23/0x5b0 [i915]
    [   62.034950]  intel_runtime_suspend+0x16c/0x2a0 [i915]
    [   62.034950]  pci_pm_runtime_suspend+0x50/0x180
    [   62.034951]  ? pci_pm_runtime_resume+0xa0/0xa0
    [   62.034952]  __rpm_callback+0xc5/0x210
    [   62.034953]  rpm_callback+0x1f/0x80
    [   62.034953]  ? pci_pm_runtime_resume+0xa0/0xa0
    [   62.034954]  rpm_suspend+0x118/0x580
    [   62.034955]  pm_runtime_work+0x64/0x90
    [   62.034956]  process_one_work+0x1bb/0x3e0
    [   62.034956]  worker_thread+0x46/0x4f0
    [   62.034957]  ? __schedule+0x18b/0x610
    [   62.034958]  kthread+0xff/0x140
    [   62.034958]  ? process_one_work+0x3e0/0x3e0
    [   62.034959]  ? kthread_create_on_node+
    
    and related hard lockups in CI for byt and bsw.
    
    Note this effectively reverts commits 41ce405e6894 and b27366958869
    ("drm/i915: Convert wait_for(I915_READ(reg)) to intel_wait_for_register()")
    
    v2: Convert bool allow into a u32 mask for clarity and repeat the
    comment on vlv rc6 timing to justify the 3ms timeout used for the wait (Ville)
    
    Fixes: 41ce405e6894 ("drm/i915: Convert wait_for(I915_READ(reg)) to intel_wait_for_register()")
    Fixes: b27366958869 ("drm/i915: Convert wait_for(I915_READ(reg)) to intel_wait_for_register()")
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=100718
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: Tomi Sarvela <tomi.p.sarvela@intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170421135815.11897-1-chris@chris-wilson.co.uk
    Tested-by: Tomi Sarvela <tomi.p.sarvela@intel.com>
    (cherry picked from commit 3dd14c04d77d7d702de5aa7157df4cc9417329f3)
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>

commit 3dd14c04d77d7d702de5aa7157df4cc9417329f3
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Apr 21 14:58:15 2017 +0100

    drm/i915: Avoid busy-spinning on VLV_GLTC_PW_STATUS mmio
    
    The busy-spin, as the first stage of intel_wait_for_register(), is
    currently under suspicion for causing:
    
    [   62.034926] NMI watchdog: Watchdog detected hard LOCKUP on cpu 1
    [   62.034928] Modules linked in: i2c_dev i915 intel_gtt drm_kms_helper prime_numbers
    [   62.034932] CPU: 1 PID: 183 Comm: kworker/1:2 Not tainted 4.11.0-rc7+ #471
    [   62.034933] Hardware name:                  /        , BIOS PYBSWCEL.86A.0027.2015.0507.1758 05/07/2015
    [   62.034934] Workqueue: pm pm_runtime_work
    [   62.034936] task: ffff880275a04ec0 task.stack: ffffc900002d8000
    [   62.034936] RIP: 0010:__intel_wait_for_register_fw+0x77/0x1a0 [i915]
    [   62.034937] RSP: 0018:ffffc900002dbc38 EFLAGS: 00000082
    [   62.034939] RAX: ffffc90003530094 RBX: 0000000000130094 RCX: 0000000000000001
    [   62.034940] RDX: 00000000000000a1 RSI: ffff88027fd15e58 RDI: 0000000000000000
    [   62.034941] RBP: ffffc900002dbc78 R08: 0000000000000002 R09: 0000000000000000
    [   62.034942] R10: ffffc900002dbc18 R11: ffff880276429dd0 R12: ffff8802707c0000
    [   62.034943] R13: 00000000000000a0 R14: 0000000000000000 R15: 00000000fffefc10
    [   62.034945] FS:  0000000000000000(0000) GS:ffff88027fd00000(0000) knlGS:0000000000000000
    [   62.034945] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [   62.034947] CR2: 00007ffd3cd98ff8 CR3: 0000000274c19000 CR4: 00000000001006e0
    [   62.034947] Call Trace:
    [   62.034948]  intel_wait_for_register+0x77/0x140 [i915]
    [   62.034949]  vlv_suspend_complete+0x23/0x5b0 [i915]
    [   62.034950]  intel_runtime_suspend+0x16c/0x2a0 [i915]
    [   62.034950]  pci_pm_runtime_suspend+0x50/0x180
    [   62.034951]  ? pci_pm_runtime_resume+0xa0/0xa0
    [   62.034952]  __rpm_callback+0xc5/0x210
    [   62.034953]  rpm_callback+0x1f/0x80
    [   62.034953]  ? pci_pm_runtime_resume+0xa0/0xa0
    [   62.034954]  rpm_suspend+0x118/0x580
    [   62.034955]  pm_runtime_work+0x64/0x90
    [   62.034956]  process_one_work+0x1bb/0x3e0
    [   62.034956]  worker_thread+0x46/0x4f0
    [   62.034957]  ? __schedule+0x18b/0x610
    [   62.034958]  kthread+0xff/0x140
    [   62.034958]  ? process_one_work+0x3e0/0x3e0
    [   62.034959]  ? kthread_create_on_node+
    
    and related hard lockups in CI for byt and bsw.
    
    Note this effectively reverts commits 41ce405e6894 and b27366958869
    ("drm/i915: Convert wait_for(I915_READ(reg)) to intel_wait_for_register()")
    
    v2: Convert bool allow into a u32 mask for clarity and repeat the
    comment on vlv rc6 timing to justify the 3ms timeout used for the wait (Ville)
    
    Fixes: 41ce405e6894 ("drm/i915: Convert wait_for(I915_READ(reg)) to intel_wait_for_register()")
    Fixes: b27366958869 ("drm/i915: Convert wait_for(I915_READ(reg)) to intel_wait_for_register()")
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=100718
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: Tomi Sarvela <tomi.p.sarvela@intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170421135815.11897-1-chris@chris-wilson.co.uk
    Tested-by: Tomi Sarvela <tomi.p.sarvela@intel.com>

commit 80d136e138f59de35aafb0440e8ab2f51c40ccd5
Author: Michal Hocko <mhocko@suse.com>
Date:   Wed Apr 19 09:52:46 2017 +0200

    mm: make mm_percpu_wq non freezable
    
    Geert has reported a freeze during PM resume and some additional
    debugging has shown that the device_resume worker cannot make a forward
    progress because it waits for an event which is stuck waiting in
    drain_all_pages:
    
      INFO: task kworker/u4:0:5 blocked for more than 120 seconds.
            Not tainted 4.11.0-rc7-koelsch-00029-g005882e53d62f25d-dirty #3476
      "echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
      kworker/u4:0    D    0     5      2 0x00000000
      Workqueue: events_unbound async_run_entry_fn
        __schedule
        schedule
        schedule_timeout
        wait_for_common
        dpm_wait_for_superior
        device_resume
        async_resume
        async_run_entry_fn
        process_one_work
        worker_thread
        kthread
      [...]
      bash            D    0  1703   1694 0x00000000
        __schedule
        schedule
        schedule_timeout
        wait_for_common
        flush_work
        drain_all_pages
        start_isolate_page_range
        alloc_contig_range
        cma_alloc
        __alloc_from_contiguous
        cma_allocator_alloc
        __dma_alloc
        arm_dma_alloc
        sh_eth_ring_init
        sh_eth_open
        sh_eth_resume
        dpm_run_callback
        device_resume
        dpm_resume
        dpm_resume_end
        suspend_devices_and_enter
        pm_suspend
        state_store
        kernfs_fop_write
        __vfs_write
        vfs_write
        SyS_write
      [...]
      Showing busy workqueues and worker pools:
      [...]
      workqueue mm_percpu_wq: flags=0xc
        pwq 2: cpus=1 node=0 flags=0x0 nice=0 active=0/0
          delayed: drain_local_pages_wq, vmstat_update
        pwq 0: cpus=0 node=0 flags=0x0 nice=0 active=0/0
          delayed: drain_local_pages_wq BAR(1703), vmstat_update
    
    Tetsuo has properly noted that mm_percpu_wq is created as WQ_FREEZABLE
    so it is frozen this early during resume so we are effectively
    deadlocked.  Fix this by dropping WQ_FREEZABLE when creating
    mm_percpu_wq.  We really want to have it operational all the time.
    
    Fixes: ce612879ddc7 ("mm: move pcp and lru-pcp draining into single wq")
    Reported-and-tested-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Debugged-by: Tetsuo Handa <penguin-kernel@i-love.sakura.ne.jp>
    Signed-off-by: Michal Hocko <mhocko@suse.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit 1bbecc8cd0a4192ec2a30f6cb3e6f4bd166f576a
Merge: d7718c147a89 b32de9dd38fc
Author: Olof Johansson <olof@lixom.net>
Date:   Wed Apr 19 07:03:33 2017 -0700

    Merge tag 'at91-ab-4.12-soc' of git://git.kernel.org/pub/scm/linux/kernel/git/abelloni/linux into next/soc
    
    SoC for 4.12:
    
     - huge PM cleanup
     - Move SoC detection to its own driver
    
    * tag 'at91-ab-4.12-soc' of git://git.kernel.org/pub/scm/linux/kernel/git/abelloni/linux:
      ARM: at91: move SoC detection to its own driver
      ARM: at91: pm: correct typo
      ARM: at91: pm: Remove at91_pm_set_standby
      ARM: at91: pm: Merge all at91sam9*_pm_init
      ARM: at91: pm: Tie the USB clock mask to the pmc
      ARM: at91: pm: Tie the memory controller type to the ramc id
      ARM: at91: pm: Workaround DDRSDRC self-refresh bug with LPDDR1 memories.
      ARM: at91: pm: Simplify at91rm9200_standby
      ARM: at91: pm: Use struct at91_pm_data in pm_suspend.S
      ARM: at91: pm: Move global variables into at91_pm_data
      ARM: at91: pm: Move at91_ramc_read/write to pm.c
      ARM: at91: pm: Cleanup headers
      MAINTAINERS: Add memory drivers to AT91 entry
      MAINTAINERS: Update AT91 entry
      ARM: at91: pm: cpu_idle: switch DDR to power-down mode
      Revert "ARM: at91/dt: sama5d2: Use new compatible for ohci node"
    
    Signed-off-by: Olof Johansson <olof@lixom.net>

commit 0c32b8ec02832df167e16ad659cb11dc148f2ddf
Author: Marek Szyprowski <m.szyprowski@samsung.com>
Date:   Thu Feb 23 08:43:27 2017 -0300

    [media] s5p-mfc: Fix race between interrupt routine and device functions
    
    Interrupt routine must wake process waiting for given interrupt AFTER
    updating driver's internal structures and contexts. Doing it in-between
    is a serious bug. This patch moves all calls to the wake() function to
    the end of the interrupt processing block to avoid potential and real
    races, especially on multi-core platforms. This also fixes following issue
    reported from clock core (clocks were disabled in interrupt after being
    unprepared from the other place in the driver, the stack trace however
    points to the different place than s5p_mfc driver because of the race):
    
    WARNING: CPU: 1 PID: 18 at drivers/clk/clk.c:544 clk_core_unprepare+0xc8/0x108
    Modules linked in:
    CPU: 1 PID: 18 Comm: kworker/1:0 Not tainted 4.10.0-next-20170223-00070-g04e18bc99ab9-dirty #2154
    Hardware name: SAMSUNG EXYNOS (Flattened Device Tree)
    Workqueue: pm pm_runtime_work
    [<c010d8b0>] (unwind_backtrace) from [<c010a534>] (show_stack+0x10/0x14)
    [<c010a534>] (show_stack) from [<c033292c>] (dump_stack+0x74/0x94)
    [<c033292c>] (dump_stack) from [<c011cef4>] (__warn+0xd4/0x100)
    [<c011cef4>] (__warn) from [<c011cf40>] (warn_slowpath_null+0x20/0x28)
    [<c011cf40>] (warn_slowpath_null) from [<c0387a84>] (clk_core_unprepare+0xc8/0x108)
    [<c0387a84>] (clk_core_unprepare) from [<c0389d84>] (clk_unprepare+0x24/0x2c)
    [<c0389d84>] (clk_unprepare) from [<c03d4660>] (exynos_sysmmu_suspend+0x48/0x60)
    [<c03d4660>] (exynos_sysmmu_suspend) from [<c042b9b0>] (pm_generic_runtime_suspend+0x2c/0x38)
    [<c042b9b0>] (pm_generic_runtime_suspend) from [<c0437580>] (genpd_runtime_suspend+0x94/0x220)
    [<c0437580>] (genpd_runtime_suspend) from [<c042e240>] (__rpm_callback+0x134/0x208)
    [<c042e240>] (__rpm_callback) from [<c042e334>] (rpm_callback+0x20/0x80)
    [<c042e334>] (rpm_callback) from [<c042d3b8>] (rpm_suspend+0xdc/0x458)
    [<c042d3b8>] (rpm_suspend) from [<c042ea24>] (pm_runtime_work+0x80/0x90)
    [<c042ea24>] (pm_runtime_work) from [<c01322c4>] (process_one_work+0x120/0x318)
    [<c01322c4>] (process_one_work) from [<c0132520>] (worker_thread+0x2c/0x4ac)
    [<c0132520>] (worker_thread) from [<c0137ab0>] (kthread+0xfc/0x134)
    [<c0137ab0>] (kthread) from [<c0107978>] (ret_from_fork+0x14/0x3c)
    ---[ end trace 1ead49a7bb83f0d8 ]---
    
    Fixes: af93574678108 ("[media] MFC: Add MFC 5.1 V4L2 driver")
    
    Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
    CC: stable@vger.kernel.org # v4.5+
    Reviewed-by: Javier Martinez Canillas <javier@osg.samsung.com>
    Signed-off-by: Sylwester Nawrocki <s.nawrocki@samsung.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

commit 67c2f3d388efe1a47e201b906d80545eaab7da22
Author: Jérémy Lefaure <jeremy.lefaure@lse.epita.fr>
Date:   Thu Mar 16 21:51:33 2017 -0400

    tpm/tpm_crb: fix unused warnings on suspend/resume functions
    
    When PM_SLEEP is disabled crb_pm_suspend and crb_pm_resume are not used by
    SET_SYSTEM_SLEEP_PM_OPS even if PM is enabled:
    
    drvers/char/tpm/tpm_crb.c:540:12: warning: ‘crb_pm_suspend’ defined but not
    used [-Wunused-function]
     static int crb_pm_suspend(struct device *dev)
                ^
    drivers/char/tpm/tpm_crb.c:551:12: warning: ‘crb_pm_resume’ defined but not
    used [-Wunused-function]
     static int crb_pm_resume(struct device *dev)
                ^
    
    The preprocessor condition should be on CONFIG_PM_SLEEP, not on CONFIG_PM.
    However, this patch fixes this warning by using __maybe_unused on function
    that are in the preprocessor condition.
    
    Fixes: 848efcfb560c ("tpm/tpm_crb: enter the low power state upon device suspend")
    Signed-off-by: Jérémy Lefaure <jeremy.lefaure@lse.epita.fr>
    Reviewed-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
    Tested-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
    Signed-off-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>

commit 56387634b7604c141b8645d2377980164e18da0d
Author: Alexandre Belloni <alexandre.belloni@free-electrons.com>
Date:   Wed Feb 1 22:10:34 2017 +0100

    ARM: at91: pm: Workaround DDRSDRC self-refresh bug with LPDDR1 memories.
    
    As already explained for pm_suspend.S, the DDRSDR controller fails to put
    LPDDR1 memories in self-refresh. Force the controller to think it has DDR2
    memories during the self-refresh period, as the DDR2 self-refresh spec is
    equivalent to LPDDR1, and is correctly implemented in the controller.
    
    Acked-by: Wenyou Yang <wenyou.yang@atmel.com>
    Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>

commit 65cc1a59d192be1df33633d3fe668a1e3e0edc36
Author: Alexandre Belloni <alexandre.belloni@free-electrons.com>
Date:   Tue Jan 31 18:12:57 2017 +0100

    ARM: at91: pm: Use struct at91_pm_data in pm_suspend.S
    
    The number of register we can safely pass to at91_pm_suspend_in_sram is
    limited. Instead, pass the address to the at91_pm_data structure.
    
    The offsets are automatically generated to avoid hardcoding them.
    
    Acked-by: Wenyou Yang <wenyou.yang@atmel.com>
    Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>

commit 245b2eecee2aac6fdc77dcafaa73c33f9644c3c7
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Mon Mar 20 11:16:11 2017 -0700

    usb: hub: Fix error loop seen after hub communication errors
    
    While stress testing a usb controller using a bind/unbind looop, the
    following error loop was observed.
    
    usb 7-1.2: new low-speed USB device number 3 using xhci-hcd
    usb 7-1.2: hub failed to enable device, error -108
    usb 7-1-port2: cannot disable (err = -22)
    usb 7-1-port2: couldn't allocate usb_device
    usb 7-1-port2: cannot disable (err = -22)
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: activate --> -22
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: activate --> -22
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: activate --> -22
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: activate --> -22
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: activate --> -22
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: activate --> -22
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: activate --> -22
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: activate --> -22
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    ** 57 printk messages dropped ** hub 7-1:1.0: activate --> -22
    ** 82 printk messages dropped ** hub 7-1:1.0: hub_ext_port_status failed (err = -22)
    
    This continues forever. After adding tracebacks into the code,
    the call sequence leading to this is found to be as follows.
    
    [<ffffffc0007fc8e0>] hub_activate+0x368/0x7b8
    [<ffffffc0007fceb4>] hub_resume+0x2c/0x3c
    [<ffffffc00080b3b8>] usb_resume_interface.isra.6+0x128/0x158
    [<ffffffc00080b5d0>] usb_suspend_both+0x1e8/0x288
    [<ffffffc00080c9c4>] usb_runtime_suspend+0x3c/0x98
    [<ffffffc0007820a0>] __rpm_callback+0x48/0x7c
    [<ffffffc00078217c>] rpm_callback+0xa8/0xd4
    [<ffffffc000786234>] rpm_suspend+0x84/0x758
    [<ffffffc000786ca4>] rpm_idle+0x2c8/0x498
    [<ffffffc000786ed4>] __pm_runtime_idle+0x60/0xac
    [<ffffffc00080eba8>] usb_autopm_put_interface+0x6c/0x7c
    [<ffffffc000803798>] hub_event+0x10ac/0x12ac
    [<ffffffc000249bb8>] process_one_work+0x390/0x6b8
    [<ffffffc00024abcc>] worker_thread+0x480/0x610
    [<ffffffc000251a80>] kthread+0x164/0x178
    [<ffffffc0002045d0>] ret_from_fork+0x10/0x40
    
    kick_hub_wq() is called from hub_activate() even after failures to
    communicate with the hub. This results in an endless sequence of
    hub event -> hub activate -> wq trigger -> hub event -> ...
    
    Provide two solutions for the problem.
    
    - Only trigger the hub event queue if communication with the hub
      is successful.
    - After a suspend failure, only resume already suspended interfaces
      if the communication with the device is still possible.
    
    Each of the changes fixes the observed problem. Use both to improve
    robustness.
    
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 215d4d62ccfd585854b17f621342762784dde8c3
Author: Sergey Senozhatsky <sergey.senozhatsky.work@gmail.com>
Date:   Wed Feb 15 13:43:32 2017 +0900

    timekeeping: Use deferred printk() in debug code
    
    commit f222449c9dfad7c9bb8cb53e64c5c407b172ebbc upstream.
    
    We cannot do printk() from tk_debug_account_sleep_time(), because
    tk_debug_account_sleep_time() is called under tk_core seq lock.
    The reason why printk() is unsafe there is that console_sem may
    invoke scheduler (up()->wake_up_process()->activate_task()), which,
    in turn, can return back to timekeeping code, for instance, via
    get_time()->ktime_get(), deadlocking the system on tk_core seq lock.
    
    [   48.950592] ======================================================
    [   48.950622] [ INFO: possible circular locking dependency detected ]
    [   48.950622] 4.10.0-rc7-next-20170213+ #101 Not tainted
    [   48.950622] -------------------------------------------------------
    [   48.950622] kworker/0:0/3 is trying to acquire lock:
    [   48.950653]  (tk_core){----..}, at: [<c01cc624>] retrigger_next_event+0x4c/0x90
    [   48.950683]
                   but task is already holding lock:
    [   48.950683]  (hrtimer_bases.lock){-.-...}, at: [<c01cc610>] retrigger_next_event+0x38/0x90
    [   48.950714]
                   which lock already depends on the new lock.
    
    [   48.950714]
                   the existing dependency chain (in reverse order) is:
    [   48.950714]
                   -> #5 (hrtimer_bases.lock){-.-...}:
    [   48.950744]        _raw_spin_lock_irqsave+0x50/0x64
    [   48.950775]        lock_hrtimer_base+0x28/0x58
    [   48.950775]        hrtimer_start_range_ns+0x20/0x5c8
    [   48.950775]        __enqueue_rt_entity+0x320/0x360
    [   48.950805]        enqueue_rt_entity+0x2c/0x44
    [   48.950805]        enqueue_task_rt+0x24/0x94
    [   48.950836]        ttwu_do_activate+0x54/0xc0
    [   48.950836]        try_to_wake_up+0x248/0x5c8
    [   48.950836]        __setup_irq+0x420/0x5f0
    [   48.950836]        request_threaded_irq+0xdc/0x184
    [   48.950866]        devm_request_threaded_irq+0x58/0xa4
    [   48.950866]        omap_i2c_probe+0x530/0x6a0
    [   48.950897]        platform_drv_probe+0x50/0xb0
    [   48.950897]        driver_probe_device+0x1f8/0x2cc
    [   48.950897]        __driver_attach+0xc0/0xc4
    [   48.950927]        bus_for_each_dev+0x6c/0xa0
    [   48.950927]        bus_add_driver+0x100/0x210
    [   48.950927]        driver_register+0x78/0xf4
    [   48.950958]        do_one_initcall+0x3c/0x16c
    [   48.950958]        kernel_init_freeable+0x20c/0x2d8
    [   48.950958]        kernel_init+0x8/0x110
    [   48.950988]        ret_from_fork+0x14/0x24
    [   48.950988]
                   -> #4 (&rt_b->rt_runtime_lock){-.-...}:
    [   48.951019]        _raw_spin_lock+0x40/0x50
    [   48.951019]        rq_offline_rt+0x9c/0x2bc
    [   48.951019]        set_rq_offline.part.2+0x2c/0x58
    [   48.951049]        rq_attach_root+0x134/0x144
    [   48.951049]        cpu_attach_domain+0x18c/0x6f4
    [   48.951049]        build_sched_domains+0xba4/0xd80
    [   48.951080]        sched_init_smp+0x68/0x10c
    [   48.951080]        kernel_init_freeable+0x160/0x2d8
    [   48.951080]        kernel_init+0x8/0x110
    [   48.951080]        ret_from_fork+0x14/0x24
    [   48.951110]
                   -> #3 (&rq->lock){-.-.-.}:
    [   48.951110]        _raw_spin_lock+0x40/0x50
    [   48.951141]        task_fork_fair+0x30/0x124
    [   48.951141]        sched_fork+0x194/0x2e0
    [   48.951141]        copy_process.part.5+0x448/0x1a20
    [   48.951171]        _do_fork+0x98/0x7e8
    [   48.951171]        kernel_thread+0x2c/0x34
    [   48.951171]        rest_init+0x1c/0x18c
    [   48.951202]        start_kernel+0x35c/0x3d4
    [   48.951202]        0x8000807c
    [   48.951202]
                   -> #2 (&p->pi_lock){-.-.-.}:
    [   48.951232]        _raw_spin_lock_irqsave+0x50/0x64
    [   48.951232]        try_to_wake_up+0x30/0x5c8
    [   48.951232]        up+0x4c/0x60
    [   48.951263]        __up_console_sem+0x2c/0x58
    [   48.951263]        console_unlock+0x3b4/0x650
    [   48.951263]        vprintk_emit+0x270/0x474
    [   48.951293]        vprintk_default+0x20/0x28
    [   48.951293]        printk+0x20/0x30
    [   48.951324]        kauditd_hold_skb+0x94/0xb8
    [   48.951324]        kauditd_thread+0x1a4/0x56c
    [   48.951324]        kthread+0x104/0x148
    [   48.951354]        ret_from_fork+0x14/0x24
    [   48.951354]
                   -> #1 ((console_sem).lock){-.....}:
    [   48.951385]        _raw_spin_lock_irqsave+0x50/0x64
    [   48.951385]        down_trylock+0xc/0x2c
    [   48.951385]        __down_trylock_console_sem+0x24/0x80
    [   48.951385]        console_trylock+0x10/0x8c
    [   48.951416]        vprintk_emit+0x264/0x474
    [   48.951416]        vprintk_default+0x20/0x28
    [   48.951416]        printk+0x20/0x30
    [   48.951446]        tk_debug_account_sleep_time+0x5c/0x70
    [   48.951446]        __timekeeping_inject_sleeptime.constprop.3+0x170/0x1a0
    [   48.951446]        timekeeping_resume+0x218/0x23c
    [   48.951477]        syscore_resume+0x94/0x42c
    [   48.951477]        suspend_enter+0x554/0x9b4
    [   48.951477]        suspend_devices_and_enter+0xd8/0x4b4
    [   48.951507]        enter_state+0x934/0xbd4
    [   48.951507]        pm_suspend+0x14/0x70
    [   48.951507]        state_store+0x68/0xc8
    [   48.951538]        kernfs_fop_write+0xf4/0x1f8
    [   48.951538]        __vfs_write+0x1c/0x114
    [   48.951538]        vfs_write+0xa0/0x168
    [   48.951568]        SyS_write+0x3c/0x90
    [   48.951568]        __sys_trace_return+0x0/0x10
    [   48.951568]
                   -> #0 (tk_core){----..}:
    [   48.951599]        lock_acquire+0xe0/0x294
    [   48.951599]        ktime_get_update_offsets_now+0x5c/0x1d4
    [   48.951629]        retrigger_next_event+0x4c/0x90
    [   48.951629]        on_each_cpu+0x40/0x7c
    [   48.951629]        clock_was_set_work+0x14/0x20
    [   48.951660]        process_one_work+0x2b4/0x808
    [   48.951660]        worker_thread+0x3c/0x550
    [   48.951660]        kthread+0x104/0x148
    [   48.951690]        ret_from_fork+0x14/0x24
    [   48.951690]
                   other info that might help us debug this:
    
    [   48.951690] Chain exists of:
                     tk_core --> &rt_b->rt_runtime_lock --> hrtimer_bases.lock
    
    [   48.951721]  Possible unsafe locking scenario:
    
    [   48.951721]        CPU0                    CPU1
    [   48.951721]        ----                    ----
    [   48.951721]   lock(hrtimer_bases.lock);
    [   48.951751]                                lock(&rt_b->rt_runtime_lock);
    [   48.951751]                                lock(hrtimer_bases.lock);
    [   48.951751]   lock(tk_core);
    [   48.951782]
                    *** DEADLOCK ***
    
    [   48.951782] 3 locks held by kworker/0:0/3:
    [   48.951782]  #0:  ("events"){.+.+.+}, at: [<c0156590>] process_one_work+0x1f8/0x808
    [   48.951812]  #1:  (hrtimer_work){+.+...}, at: [<c0156590>] process_one_work+0x1f8/0x808
    [   48.951843]  #2:  (hrtimer_bases.lock){-.-...}, at: [<c01cc610>] retrigger_next_event+0x38/0x90
    [   48.951843]   stack backtrace:
    [   48.951873] CPU: 0 PID: 3 Comm: kworker/0:0 Not tainted 4.10.0-rc7-next-20170213+
    [   48.951904] Workqueue: events clock_was_set_work
    [   48.951904] [<c0110208>] (unwind_backtrace) from [<c010c224>] (show_stack+0x10/0x14)
    [   48.951934] [<c010c224>] (show_stack) from [<c04ca6c0>] (dump_stack+0xac/0xe0)
    [   48.951934] [<c04ca6c0>] (dump_stack) from [<c019b5cc>] (print_circular_bug+0x1d0/0x308)
    [   48.951965] [<c019b5cc>] (print_circular_bug) from [<c019d2a8>] (validate_chain+0xf50/0x1324)
    [   48.951965] [<c019d2a8>] (validate_chain) from [<c019ec18>] (__lock_acquire+0x468/0x7e8)
    [   48.951995] [<c019ec18>] (__lock_acquire) from [<c019f634>] (lock_acquire+0xe0/0x294)
    [   48.951995] [<c019f634>] (lock_acquire) from [<c01d0ea0>] (ktime_get_update_offsets_now+0x5c/0x1d4)
    [   48.952026] [<c01d0ea0>] (ktime_get_update_offsets_now) from [<c01cc624>] (retrigger_next_event+0x4c/0x90)
    [   48.952026] [<c01cc624>] (retrigger_next_event) from [<c01e4e24>] (on_each_cpu+0x40/0x7c)
    [   48.952056] [<c01e4e24>] (on_each_cpu) from [<c01cafc4>] (clock_was_set_work+0x14/0x20)
    [   48.952056] [<c01cafc4>] (clock_was_set_work) from [<c015664c>] (process_one_work+0x2b4/0x808)
    [   48.952087] [<c015664c>] (process_one_work) from [<c0157774>] (worker_thread+0x3c/0x550)
    [   48.952087] [<c0157774>] (worker_thread) from [<c015d644>] (kthread+0x104/0x148)
    [   48.952087] [<c015d644>] (kthread) from [<c0107830>] (ret_from_fork+0x14/0x24)
    
    Replace printk() with printk_deferred(), which does not call into
    the scheduler.
    
    Fixes: 0bf43f15db85 ("timekeeping: Prints the amounts of time spent during suspend")
    Reported-and-tested-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Cc: Petr Mladek <pmladek@suse.com>
    Cc: Sergey Senozhatsky <sergey.senozhatsky.work@gmail.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: "Rafael J . Wysocki" <rjw@rjwysocki.net>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: John Stultz <john.stultz@linaro.org>
    Link: http://lkml.kernel.org/r/20170215044332.30449-1-sergey.senozhatsky@gmail.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit f222449c9dfad7c9bb8cb53e64c5c407b172ebbc
Author: Sergey Senozhatsky <sergey.senozhatsky.work@gmail.com>
Date:   Wed Feb 15 13:43:32 2017 +0900

    timekeeping: Use deferred printk() in debug code
    
    We cannot do printk() from tk_debug_account_sleep_time(), because
    tk_debug_account_sleep_time() is called under tk_core seq lock.
    The reason why printk() is unsafe there is that console_sem may
    invoke scheduler (up()->wake_up_process()->activate_task()), which,
    in turn, can return back to timekeeping code, for instance, via
    get_time()->ktime_get(), deadlocking the system on tk_core seq lock.
    
    [   48.950592] ======================================================
    [   48.950622] [ INFO: possible circular locking dependency detected ]
    [   48.950622] 4.10.0-rc7-next-20170213+ #101 Not tainted
    [   48.950622] -------------------------------------------------------
    [   48.950622] kworker/0:0/3 is trying to acquire lock:
    [   48.950653]  (tk_core){----..}, at: [<c01cc624>] retrigger_next_event+0x4c/0x90
    [   48.950683]
                   but task is already holding lock:
    [   48.950683]  (hrtimer_bases.lock){-.-...}, at: [<c01cc610>] retrigger_next_event+0x38/0x90
    [   48.950714]
                   which lock already depends on the new lock.
    
    [   48.950714]
                   the existing dependency chain (in reverse order) is:
    [   48.950714]
                   -> #5 (hrtimer_bases.lock){-.-...}:
    [   48.950744]        _raw_spin_lock_irqsave+0x50/0x64
    [   48.950775]        lock_hrtimer_base+0x28/0x58
    [   48.950775]        hrtimer_start_range_ns+0x20/0x5c8
    [   48.950775]        __enqueue_rt_entity+0x320/0x360
    [   48.950805]        enqueue_rt_entity+0x2c/0x44
    [   48.950805]        enqueue_task_rt+0x24/0x94
    [   48.950836]        ttwu_do_activate+0x54/0xc0
    [   48.950836]        try_to_wake_up+0x248/0x5c8
    [   48.950836]        __setup_irq+0x420/0x5f0
    [   48.950836]        request_threaded_irq+0xdc/0x184
    [   48.950866]        devm_request_threaded_irq+0x58/0xa4
    [   48.950866]        omap_i2c_probe+0x530/0x6a0
    [   48.950897]        platform_drv_probe+0x50/0xb0
    [   48.950897]        driver_probe_device+0x1f8/0x2cc
    [   48.950897]        __driver_attach+0xc0/0xc4
    [   48.950927]        bus_for_each_dev+0x6c/0xa0
    [   48.950927]        bus_add_driver+0x100/0x210
    [   48.950927]        driver_register+0x78/0xf4
    [   48.950958]        do_one_initcall+0x3c/0x16c
    [   48.950958]        kernel_init_freeable+0x20c/0x2d8
    [   48.950958]        kernel_init+0x8/0x110
    [   48.950988]        ret_from_fork+0x14/0x24
    [   48.950988]
                   -> #4 (&rt_b->rt_runtime_lock){-.-...}:
    [   48.951019]        _raw_spin_lock+0x40/0x50
    [   48.951019]        rq_offline_rt+0x9c/0x2bc
    [   48.951019]        set_rq_offline.part.2+0x2c/0x58
    [   48.951049]        rq_attach_root+0x134/0x144
    [   48.951049]        cpu_attach_domain+0x18c/0x6f4
    [   48.951049]        build_sched_domains+0xba4/0xd80
    [   48.951080]        sched_init_smp+0x68/0x10c
    [   48.951080]        kernel_init_freeable+0x160/0x2d8
    [   48.951080]        kernel_init+0x8/0x110
    [   48.951080]        ret_from_fork+0x14/0x24
    [   48.951110]
                   -> #3 (&rq->lock){-.-.-.}:
    [   48.951110]        _raw_spin_lock+0x40/0x50
    [   48.951141]        task_fork_fair+0x30/0x124
    [   48.951141]        sched_fork+0x194/0x2e0
    [   48.951141]        copy_process.part.5+0x448/0x1a20
    [   48.951171]        _do_fork+0x98/0x7e8
    [   48.951171]        kernel_thread+0x2c/0x34
    [   48.951171]        rest_init+0x1c/0x18c
    [   48.951202]        start_kernel+0x35c/0x3d4
    [   48.951202]        0x8000807c
    [   48.951202]
                   -> #2 (&p->pi_lock){-.-.-.}:
    [   48.951232]        _raw_spin_lock_irqsave+0x50/0x64
    [   48.951232]        try_to_wake_up+0x30/0x5c8
    [   48.951232]        up+0x4c/0x60
    [   48.951263]        __up_console_sem+0x2c/0x58
    [   48.951263]        console_unlock+0x3b4/0x650
    [   48.951263]        vprintk_emit+0x270/0x474
    [   48.951293]        vprintk_default+0x20/0x28
    [   48.951293]        printk+0x20/0x30
    [   48.951324]        kauditd_hold_skb+0x94/0xb8
    [   48.951324]        kauditd_thread+0x1a4/0x56c
    [   48.951324]        kthread+0x104/0x148
    [   48.951354]        ret_from_fork+0x14/0x24
    [   48.951354]
                   -> #1 ((console_sem).lock){-.....}:
    [   48.951385]        _raw_spin_lock_irqsave+0x50/0x64
    [   48.951385]        down_trylock+0xc/0x2c
    [   48.951385]        __down_trylock_console_sem+0x24/0x80
    [   48.951385]        console_trylock+0x10/0x8c
    [   48.951416]        vprintk_emit+0x264/0x474
    [   48.951416]        vprintk_default+0x20/0x28
    [   48.951416]        printk+0x20/0x30
    [   48.951446]        tk_debug_account_sleep_time+0x5c/0x70
    [   48.951446]        __timekeeping_inject_sleeptime.constprop.3+0x170/0x1a0
    [   48.951446]        timekeeping_resume+0x218/0x23c
    [   48.951477]        syscore_resume+0x94/0x42c
    [   48.951477]        suspend_enter+0x554/0x9b4
    [   48.951477]        suspend_devices_and_enter+0xd8/0x4b4
    [   48.951507]        enter_state+0x934/0xbd4
    [   48.951507]        pm_suspend+0x14/0x70
    [   48.951507]        state_store+0x68/0xc8
    [   48.951538]        kernfs_fop_write+0xf4/0x1f8
    [   48.951538]        __vfs_write+0x1c/0x114
    [   48.951538]        vfs_write+0xa0/0x168
    [   48.951568]        SyS_write+0x3c/0x90
    [   48.951568]        __sys_trace_return+0x0/0x10
    [   48.951568]
                   -> #0 (tk_core){----..}:
    [   48.951599]        lock_acquire+0xe0/0x294
    [   48.951599]        ktime_get_update_offsets_now+0x5c/0x1d4
    [   48.951629]        retrigger_next_event+0x4c/0x90
    [   48.951629]        on_each_cpu+0x40/0x7c
    [   48.951629]        clock_was_set_work+0x14/0x20
    [   48.951660]        process_one_work+0x2b4/0x808
    [   48.951660]        worker_thread+0x3c/0x550
    [   48.951660]        kthread+0x104/0x148
    [   48.951690]        ret_from_fork+0x14/0x24
    [   48.951690]
                   other info that might help us debug this:
    
    [   48.951690] Chain exists of:
                     tk_core --> &rt_b->rt_runtime_lock --> hrtimer_bases.lock
    
    [   48.951721]  Possible unsafe locking scenario:
    
    [   48.951721]        CPU0                    CPU1
    [   48.951721]        ----                    ----
    [   48.951721]   lock(hrtimer_bases.lock);
    [   48.951751]                                lock(&rt_b->rt_runtime_lock);
    [   48.951751]                                lock(hrtimer_bases.lock);
    [   48.951751]   lock(tk_core);
    [   48.951782]
                    *** DEADLOCK ***
    
    [   48.951782] 3 locks held by kworker/0:0/3:
    [   48.951782]  #0:  ("events"){.+.+.+}, at: [<c0156590>] process_one_work+0x1f8/0x808
    [   48.951812]  #1:  (hrtimer_work){+.+...}, at: [<c0156590>] process_one_work+0x1f8/0x808
    [   48.951843]  #2:  (hrtimer_bases.lock){-.-...}, at: [<c01cc610>] retrigger_next_event+0x38/0x90
    [   48.951843]   stack backtrace:
    [   48.951873] CPU: 0 PID: 3 Comm: kworker/0:0 Not tainted 4.10.0-rc7-next-20170213+
    [   48.951904] Workqueue: events clock_was_set_work
    [   48.951904] [<c0110208>] (unwind_backtrace) from [<c010c224>] (show_stack+0x10/0x14)
    [   48.951934] [<c010c224>] (show_stack) from [<c04ca6c0>] (dump_stack+0xac/0xe0)
    [   48.951934] [<c04ca6c0>] (dump_stack) from [<c019b5cc>] (print_circular_bug+0x1d0/0x308)
    [   48.951965] [<c019b5cc>] (print_circular_bug) from [<c019d2a8>] (validate_chain+0xf50/0x1324)
    [   48.951965] [<c019d2a8>] (validate_chain) from [<c019ec18>] (__lock_acquire+0x468/0x7e8)
    [   48.951995] [<c019ec18>] (__lock_acquire) from [<c019f634>] (lock_acquire+0xe0/0x294)
    [   48.951995] [<c019f634>] (lock_acquire) from [<c01d0ea0>] (ktime_get_update_offsets_now+0x5c/0x1d4)
    [   48.952026] [<c01d0ea0>] (ktime_get_update_offsets_now) from [<c01cc624>] (retrigger_next_event+0x4c/0x90)
    [   48.952026] [<c01cc624>] (retrigger_next_event) from [<c01e4e24>] (on_each_cpu+0x40/0x7c)
    [   48.952056] [<c01e4e24>] (on_each_cpu) from [<c01cafc4>] (clock_was_set_work+0x14/0x20)
    [   48.952056] [<c01cafc4>] (clock_was_set_work) from [<c015664c>] (process_one_work+0x2b4/0x808)
    [   48.952087] [<c015664c>] (process_one_work) from [<c0157774>] (worker_thread+0x3c/0x550)
    [   48.952087] [<c0157774>] (worker_thread) from [<c015d644>] (kthread+0x104/0x148)
    [   48.952087] [<c015d644>] (kthread) from [<c0107830>] (ret_from_fork+0x14/0x24)
    
    Replace printk() with printk_deferred(), which does not call into
    the scheduler.
    
    Fixes: 0bf43f15db85 ("timekeeping: Prints the amounts of time spent during suspend")
    Reported-and-tested-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Cc: Petr Mladek <pmladek@suse.com>
    Cc: Sergey Senozhatsky <sergey.senozhatsky.work@gmail.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: "Rafael J . Wysocki" <rjw@rjwysocki.net>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: "[4.9+]" <stable@vger.kernel.org>
    Link: http://lkml.kernel.org/r/20170215044332.30449-1-sergey.senozhatsky@gmail.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 09bb6e93956ae5175b96905b723ec879c3ca0765
Author: Grygorii Strashko <grygorii.strashko@ti.com>
Date:   Mon Feb 13 12:43:22 2017 -0800

    PM / wakeirq: report a wakeup_event on dedicated wekup irq
    
    There are two reasons for reporting wakeup event when dedicated wakeup
    IRQ is triggered:
    
    - wakeup events accounting, so proper statistical data will be
      displayed in sysfs and debugfs;
    
    - there are small window when System is entering suspend during which
      dedicated wakeup IRQ can be lost:
    
    dpm_suspend_noirq()
      |- device_wakeup_arm_wake_irqs()
          |- dev_pm_arm_wake_irq(X)
             |- IRQ is enabled and marked as wakeup source
    [1]...
      |- suspend_device_irqs()
         |- suspend_device_irq(X)
            |- irqd_set(X, IRQD_WAKEUP_ARMED);
               |- wakup IRQ armed
    
    The wakeup IRQ can be lost if it's triggered at point [1]
    and not armed yet.
    
    Hence, fix above cases by adding simple pm_wakeup_event() call in
    handle_threaded_wake_irq().
    
    Fixes: 4990d4fe327b (PM / Wakeirq: Add automated device wake IRQ handling)
    Signed-off-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Tested-by: Keerthy <j-keerthy@ti.com>
    [ tony@atomide.com: added missing return to avoid warnings ]
    Tested-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 0bf0ee8ef9a6c120f7f320b9fb5fe1270965d828
Author: Grygorii Strashko <grygorii.strashko@ti.com>
Date:   Fri Feb 10 14:25:01 2017 -0800

    PM / wakeirq: Fix spurious wake-up events for dedicated wakeirqs
    
    Dedicated wakeirq is a one time event to wake-up the system from
    low-power state and then call pm_runtime_resume() on the device wired
    with the dedicated wakeirq.
    
    Sometimes dedicated wakeirqs can get deferred if they trigger after we
    call disable_irq_nosync() in dev_pm_disable_wake_irq(). This can happen
    if pm_runtime_get() is called around the same time a wakeirq fires.
    
    If an interrupt fires after disable_irq_nosync(), by default it will get
    tagged with IRQS_PENDING and will run later on when the interrupt is
    enabled again.
    
    Deferred wakeirqs usually just produce pointless wake-up events. But they
    can also cause suspend to fail if the deferred wakeirq fires during
    dpm_suspend_noirq() for example. So we really don't want to see the
    deferred wakeirqs triggering after the device has resumed.
    
    Let's fix the issue by setting IRQ_DISABLE_UNLAZY flag for the dedicated
    wakeirqs. The other option would be to implement irq_disable() in the
    dedicated wakeirq controller, but that's not a generic solution.
    
    For reference below is what happens with a IRQ_TYPE_EDGE_BOTH IRQ
    type wakeirq:
    
    - resume by dedicated IRQ (EDGE_FALLING)
     - suspend_enter()
      ....
     - arch_suspend_enable_irqs()
       |- dedicated IRQ armed and fired
       |- irq_pm_check_wakeup()
          |- disarm, disable IRQ and mark as IRQS_PENDING
      ....
     - dpm_resume_noirq()
       |- resume_device_irqs()
          |- __enable_irq()
             |- check_irq_resend()
                |- handle_threaded_wake_irq()
                   |- dedicated IRQ processed
       |- device_wakeup_disarm_wake_irqs()
          |- disable_irq_wake()
      ....
     !-> dedicated IRQ (EDGE_RISING)
         -| handle_edge_irq()
            |- IRQ disabled: mask_ack_irq and mark as IRQS_PENDING
      ....
    - subsequent suspend
      ....
      |- dpm_suspend_noirq()
         |- device_wakeup_arm_wake_irqs()
            |- __enable_irq()
               |- check_irq_resend()
    (a)           |- handle_threaded_wake_irq()
                     |- pm_wakeup_event() --> abort suspend
      ....
         |- suspend_device_irqs()
            |- suspend_device_irq()
               |-  dedicated IRQ armed
      ....
    (b)  |- resend_irqs
            |- irq_pm_check_wakeup()
               |- IRQ armed -> abort suspend
    
    because of pending IRQ System suspend can be aborted at points
    (a)-not armed or (b)-armed.
    
    Fixes: 4990d4fe327b (PM / Wakeirq: Add automated device wake IRQ handling)
    Signed-off-by: Grygorii Strashko <grygorii.strashko@ti.com>
    [ tony@atomide.com: added a comment, updated the description ]
    Tested-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 9c576bd35ef4086f25c04ec662019c33494ee2fb
Author: Shawn Nematbakhsh <shawnn@chromium.org>
Date:   Fri Jan 13 16:04:32 2017 +0100

    mfd: cros_ec: Send correct suspend/resume event to EC
    
    pm_suspend_via_firmware() will return false for platforms with ACPI
    disabled and ACPI is a prerequisite for S0ix support.
    
    With this patch, sleep state event sent to EC is forced to S3 if ACPI is
    disabled.
    
    Signed-off-by: Shawn Nematbakhsh <shawnn@chromium.org>
    Signed-off-by: Thierry Escande <thierry.escande@collabora.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

commit 83bf6d55c132d5c4f773e5a04149c05f4aa0c2ad
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Feb 3 12:57:17 2017 +0000

    drm/i915: Remove overzealous fence warn on runtime suspend
    
    The goal of the WARN was to catch when we are still actively using the
    fence as we go into the runtime suspend. However, the reg->pin_count is
    too coarse as it does not distinguish between exclusive ownership of the
    fence register from activity.
    
    I've not improved on the WARN, nor have we captured this WARN in an
    exact igt, but it is showing up regularly in the wild:
    
    [ 1915.935332] WARNING: CPU: 1 PID: 10861 at drivers/gpu/drm/i915/i915_gem.c:2022 i915_gem_runtime_suspend+0x116/0x130 [i915]
    [ 1915.935383] WARN_ON(reg->pin_count)[ 1915.935399] Modules linked in:
     snd_hda_intel i915 drm_kms_helper vgem netconsole scsi_transport_iscsi fuse vfat fat x86_pkg_temp_thermal coretemp intel_cstate intel_uncore snd_hda_codec_hdmi snd_hda_codec_generic snd_hda_codec snd_hwdep snd_hda_core snd_pcm snd_timer snd mei_me mei serio_raw intel_rapl_perf intel_pch_thermal soundcore wmi acpi_pad i2c_algo_bit syscopyarea sysfillrect sysimgblt fb_sys_fops drm r8169 mii video [last unloaded: drm_kms_helper]
    [ 1915.935785] CPU: 1 PID: 10861 Comm: kworker/1:0 Tainted: G     U  W       4.9.0-rc5+ #170
    [ 1915.935799] Hardware name: LENOVO 80MX/Lenovo E31-80, BIOS DCCN34WW(V2.03) 12/01/2015
    [ 1915.935822] Workqueue: pm pm_runtime_work
    [ 1915.935845]  ffffc900044fbbf0 ffffffffac3220bc ffffc900044fbc40 0000000000000000
    [ 1915.935890]  ffffc900044fbc30 ffffffffac059bcb 000007e6044fbc60 ffff8801626e3198
    [ 1915.935937]  ffff8801626e0000 0000000000000002 ffffffffc05e5d4e 0000000000000000
    [ 1915.935985] Call Trace:
    [ 1915.936013]  [<ffffffffac3220bc>] dump_stack+0x4f/0x73
    [ 1915.936038]  [<ffffffffac059bcb>] __warn+0xcb/0xf0
    [ 1915.936060]  [<ffffffffac059c4f>] warn_slowpath_fmt+0x5f/0x80
    [ 1915.936158]  [<ffffffffc052d916>] i915_gem_runtime_suspend+0x116/0x130 [i915]
    [ 1915.936251]  [<ffffffffc04f1c74>] intel_runtime_suspend+0x64/0x280 [i915]
    [ 1915.936277]  [<ffffffffac0926f1>] ? dequeue_entity+0x241/0xbc0
    [ 1915.936298]  [<ffffffffac36bb85>] pci_pm_runtime_suspend+0x55/0x180
    [ 1915.936317]  [<ffffffffac36bb30>] ? pci_pm_runtime_resume+0xa0/0xa0
    [ 1915.936339]  [<ffffffffac4514e2>] __rpm_callback+0x32/0x70
    [ 1915.936356]  [<ffffffffac451544>] rpm_callback+0x24/0x80
    [ 1915.936375]  [<ffffffffac36bb30>] ? pci_pm_runtime_resume+0xa0/0xa0
    [ 1915.936392]  [<ffffffffac45222d>] rpm_suspend+0x12d/0x680
    [ 1915.936415]  [<ffffffffac69f6d7>] ? _raw_spin_unlock_irq+0x17/0x30
    [ 1915.936435]  [<ffffffffac0810b8>] ? finish_task_switch+0x88/0x220
    [ 1915.936455]  [<ffffffffac4534bf>] pm_runtime_work+0x6f/0xb0
    [ 1915.936477]  [<ffffffffac074353>] process_one_work+0x1f3/0x4d0
    [ 1915.936501]  [<ffffffffac074678>] worker_thread+0x48/0x4e0
    [ 1915.936523]  [<ffffffffac074630>] ? process_one_work+0x4d0/0x4d0
    [ 1915.936542]  [<ffffffffac074630>] ? process_one_work+0x4d0/0x4d0
    [ 1915.936559]  [<ffffffffac07a2c9>] kthread+0xd9/0xf0
    [ 1915.936580]  [<ffffffffac07a1f0>] ? kthread_park+0x60/0x60
    [ 1915.936600]  [<ffffffffac69fe62>] ret_from_fork+0x22/0x30
    
    In the case the register is pinned, it should be present and we will
    need to invalidate them to be restored upon resume as we cannot expect
    the owner of the pin to call get_fence prior to use after resume.
    
    Fixes: 7c108fd8feac ("drm/i915: Move fence cancellation to runtime suspend")
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=98804
    Reported-by: Lionel Landwerlin <lionel.g.landwerlin@linux.intel.com>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: Imre Deak <imre.deak@linux.intel.com>
    Cc: Jani Nikula <jani.nikula@linux.intel.com>
    Cc: <drm-intel-fixes@lists.freedesktop.org> # v4.10-rc1+
    Link: http://patchwork.freedesktop.org/patch/msgid/20170203125717.8431-1-chris@chris-wilson.co.uk
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    (cherry picked from commit e0ec3ec698851a6c97a12d696407b3ff77700c23)
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>

commit e0ec3ec698851a6c97a12d696407b3ff77700c23
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Feb 3 12:57:17 2017 +0000

    drm/i915: Remove overzealous fence warn on runtime suspend
    
    The goal of the WARN was to catch when we are still actively using the
    fence as we go into the runtime suspend. However, the reg->pin_count is
    too coarse as it does not distinguish between exclusive ownership of the
    fence register from activity.
    
    I've not improved on the WARN, nor have we captured this WARN in an
    exact igt, but it is showing up regularly in the wild:
    
    [ 1915.935332] WARNING: CPU: 1 PID: 10861 at drivers/gpu/drm/i915/i915_gem.c:2022 i915_gem_runtime_suspend+0x116/0x130 [i915]
    [ 1915.935383] WARN_ON(reg->pin_count)[ 1915.935399] Modules linked in:
     snd_hda_intel i915 drm_kms_helper vgem netconsole scsi_transport_iscsi fuse vfat fat x86_pkg_temp_thermal coretemp intel_cstate intel_uncore snd_hda_codec_hdmi snd_hda_codec_generic snd_hda_codec snd_hwdep snd_hda_core snd_pcm snd_timer snd mei_me mei serio_raw intel_rapl_perf intel_pch_thermal soundcore wmi acpi_pad i2c_algo_bit syscopyarea sysfillrect sysimgblt fb_sys_fops drm r8169 mii video [last unloaded: drm_kms_helper]
    [ 1915.935785] CPU: 1 PID: 10861 Comm: kworker/1:0 Tainted: G     U  W       4.9.0-rc5+ #170
    [ 1915.935799] Hardware name: LENOVO 80MX/Lenovo E31-80, BIOS DCCN34WW(V2.03) 12/01/2015
    [ 1915.935822] Workqueue: pm pm_runtime_work
    [ 1915.935845]  ffffc900044fbbf0 ffffffffac3220bc ffffc900044fbc40 0000000000000000
    [ 1915.935890]  ffffc900044fbc30 ffffffffac059bcb 000007e6044fbc60 ffff8801626e3198
    [ 1915.935937]  ffff8801626e0000 0000000000000002 ffffffffc05e5d4e 0000000000000000
    [ 1915.935985] Call Trace:
    [ 1915.936013]  [<ffffffffac3220bc>] dump_stack+0x4f/0x73
    [ 1915.936038]  [<ffffffffac059bcb>] __warn+0xcb/0xf0
    [ 1915.936060]  [<ffffffffac059c4f>] warn_slowpath_fmt+0x5f/0x80
    [ 1915.936158]  [<ffffffffc052d916>] i915_gem_runtime_suspend+0x116/0x130 [i915]
    [ 1915.936251]  [<ffffffffc04f1c74>] intel_runtime_suspend+0x64/0x280 [i915]
    [ 1915.936277]  [<ffffffffac0926f1>] ? dequeue_entity+0x241/0xbc0
    [ 1915.936298]  [<ffffffffac36bb85>] pci_pm_runtime_suspend+0x55/0x180
    [ 1915.936317]  [<ffffffffac36bb30>] ? pci_pm_runtime_resume+0xa0/0xa0
    [ 1915.936339]  [<ffffffffac4514e2>] __rpm_callback+0x32/0x70
    [ 1915.936356]  [<ffffffffac451544>] rpm_callback+0x24/0x80
    [ 1915.936375]  [<ffffffffac36bb30>] ? pci_pm_runtime_resume+0xa0/0xa0
    [ 1915.936392]  [<ffffffffac45222d>] rpm_suspend+0x12d/0x680
    [ 1915.936415]  [<ffffffffac69f6d7>] ? _raw_spin_unlock_irq+0x17/0x30
    [ 1915.936435]  [<ffffffffac0810b8>] ? finish_task_switch+0x88/0x220
    [ 1915.936455]  [<ffffffffac4534bf>] pm_runtime_work+0x6f/0xb0
    [ 1915.936477]  [<ffffffffac074353>] process_one_work+0x1f3/0x4d0
    [ 1915.936501]  [<ffffffffac074678>] worker_thread+0x48/0x4e0
    [ 1915.936523]  [<ffffffffac074630>] ? process_one_work+0x4d0/0x4d0
    [ 1915.936542]  [<ffffffffac074630>] ? process_one_work+0x4d0/0x4d0
    [ 1915.936559]  [<ffffffffac07a2c9>] kthread+0xd9/0xf0
    [ 1915.936580]  [<ffffffffac07a1f0>] ? kthread_park+0x60/0x60
    [ 1915.936600]  [<ffffffffac69fe62>] ret_from_fork+0x22/0x30
    
    In the case the register is pinned, it should be present and we will
    need to invalidate them to be restored upon resume as we cannot expect
    the owner of the pin to call get_fence prior to use after resume.
    
    Fixes: 7c108fd8feac ("drm/i915: Move fence cancellation to runtime suspend")
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=98804
    Reported-by: Lionel Landwerlin <lionel.g.landwerlin@linux.intel.com>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: Imre Deak <imre.deak@linux.intel.com>
    Cc: Jani Nikula <jani.nikula@linux.intel.com>
    Cc: <drm-intel-fixes@lists.freedesktop.org> # v4.10-rc1+
    Link: http://patchwork.freedesktop.org/patch/msgid/20170203125717.8431-1-chris@chris-wilson.co.uk
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>

commit 1c33dc1015be482ca1a248981698d75369ce8cdc
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Tue Jan 24 16:30:19 2017 +0100

    drivers: firmware: psci: Use __pa_symbol for cpu_resume
    
    If CONFIG_DEBUG_VIRTUAL=y, during s2ram:
    
        virt_to_phys used for non-linear address: ffffff80085db280 (cpu_resume+0x0/0x20)
        ------------[ cut here ]------------
        WARNING: CPU: 0 PID: 1628 at arch/arm64/mm/physaddr.c:14 __virt_to_phys+0x28/0x60
        ...
        [<ffffff800809abb4>] __virt_to_phys+0x28/0x60
        [<ffffff80084a0c38>] psci_system_suspend+0x20/0x44
        [<ffffff8008095b28>] cpu_suspend+0x3c/0x68
        [<ffffff80084a0b48>] psci_system_suspend_enter+0x18/0x20
        [<ffffff80080ea3e0>] suspend_devices_and_enter+0x3f8/0x7e8
        [<ffffff80080ead14>] pm_suspend+0x544/0x5f4
    
    Fixes: 1a08e3d9e0ac4577 ("drivers: firmware: psci: Use __pa_symbol for kernel symbol")
    Acked-by: Mark Rutland <mark.rutland@arm.com>
    Acked-by: Laura Abbott <labbott@redhat.com>
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

commit d1242acc566a9288cbca441be1a7358c0316197e
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Jan 20 17:25:15 2017 +0100

    iio: light: cm3605: mark PM functions as __maybe_unused
    
    When CONFIG_PM_SLEEP is disabled, we get a harmless warning
    
    drivers/iio/light/cm3605.c:292:12: error: 'cm3605_pm_resume' defined but not used [-Werror=unused-function]
    drivers/iio/light/cm3605.c:281:12: error: 'cm3605_pm_suspend' defined but not used [-Werror=unused-function]
    
    Marking the functions as possibly unused avoids the warning without
    needing to add an #ifdef.
    
    Fixes: 8afa505c1230 ("iio: light: add driver for Capella CM3605")
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

commit a6d0744b18ae2e697fbd50b7986ee9eed96efe75
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Nov 25 16:54:06 2016 +0100

    ASoC: intel: Fix crash at suspend/resume without card registration
    
    [ Upstream commit 2fc995a87f2efcd803438f07bfecd35cc3d90d32 ]
    
    When ASoC Intel SST Medfield driver is probed but without codec / card
    assigned, it causes an Oops and freezes the kernel at suspend/resume,
    
     PM: Suspending system (freeze)
     Suspending console(s) (use no_console_suspend to debug)
     BUG: unable to handle kernel NULL pointer dereference at 0000000000000018
     IP: [<ffffffffc09d9409>] sst_soc_prepare+0x19/0xa0 [snd_soc_sst_mfld_platform]
     Oops: 0000 [#1] PREEMPT SMP
     CPU: 0 PID: 1552 Comm: systemd-sleep Tainted: G W 4.9.0-rc6-1.g5f5c2ad-default #1
     Call Trace:
      [<ffffffffb45318f9>] dpm_prepare+0x209/0x460
      [<ffffffffb4531b61>] dpm_suspend_start+0x11/0x60
      [<ffffffffb40d3cc2>] suspend_devices_and_enter+0xb2/0x710
      [<ffffffffb40d462e>] pm_suspend+0x30e/0x390
      [<ffffffffb40d2eba>] state_store+0x8a/0x90
      [<ffffffffb43c670f>] kobj_attr_store+0xf/0x20
      [<ffffffffb42b0d97>] sysfs_kf_write+0x37/0x40
      [<ffffffffb42b02bc>] kernfs_fop_write+0x11c/0x1b0
      [<ffffffffb422be68>] __vfs_write+0x28/0x140
      [<ffffffffb43728a8>] ? apparmor_file_permission+0x18/0x20
      [<ffffffffb433b2ab>] ? security_file_permission+0x3b/0xc0
      [<ffffffffb422d095>] vfs_write+0xb5/0x1a0
      [<ffffffffb422e3d6>] SyS_write+0x46/0xa0
      [<ffffffffb4719fbb>] entry_SYSCALL_64_fastpath+0x1e/0xad
    
    Add proper NULL checks in the PM code of mdfld driver.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Acked-by: Vinod Koul <vinod.koul@intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Sasha Levin <alexander.levin@verizon.com>

commit 65f796837e0051e11334b0c075b153d5d3d4d2c5
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon Dec 5 16:38:16 2016 -0800

    PM / wakeirq: Fix dedicated wakeirq for drivers not using autosuspend
    
    commit bed570307ed78f21b77cb04a1df781dee4a8f05a upstream.
    
    I noticed some wakeirq flakeyness with consumer drivers not using
    autosuspend. For drivers not using autosuspend, the wakeirq may never
    get unmasked in rpm_suspend() because of irq desc->depth.
    
    We are configuring dedicated wakeirqs to start with IRQ_NOAUTOEN as we
    naturally don't want them running until rpm_suspend() is called.
    
    However, when a consumer driver initially calls pm_runtime_get(), we
    now wrongly start with disable_irq_nosync() call on the dedicated
    wakeirq that is disabled to start with.
    
    This causes desc->depth to toggle between 1 and 2 instead of the usual
    0 and 1. This can prevent enable_irq() from unmasking the wakeirq as
    that only happens at desc->depth 1.
    
    This does not necessarily show up with drivers using autosuspend as
    there is time for disable_irq_nosync() before rpm_suspend() gets called
    after the autosuspend timeout.
    
    Let's fix the issue by adding wirq->status that lazily gets set on
    the first rpm_suspend(). We also need PM runtime core private functions
    for dev_pm_enable_wake_irq_check() and dev_pm_disable_wake_irq_check()
    so we can enable the dedicated wakeirq on the first rpm_suspend().
    
    While at it, let's also fix the comments for dev_pm_enable_wake_irq()
    and dev_pm_disable_wake_irq(). Those can still be used by the consumer
    drivers as needed because the IRQ core manages the interrupt usecount
    for us.
    
    Fixes: 4990d4fe327b (PM / Wakeirq: Add automated device wake IRQ handling)
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit b0cb7f60998c776fa5696f24a21b685954b15881
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon Dec 5 16:38:16 2016 -0800

    PM / wakeirq: Fix dedicated wakeirq for drivers not using autosuspend
    
    commit bed570307ed78f21b77cb04a1df781dee4a8f05a upstream.
    
    I noticed some wakeirq flakeyness with consumer drivers not using
    autosuspend. For drivers not using autosuspend, the wakeirq may never
    get unmasked in rpm_suspend() because of irq desc->depth.
    
    We are configuring dedicated wakeirqs to start with IRQ_NOAUTOEN as we
    naturally don't want them running until rpm_suspend() is called.
    
    However, when a consumer driver initially calls pm_runtime_get(), we
    now wrongly start with disable_irq_nosync() call on the dedicated
    wakeirq that is disabled to start with.
    
    This causes desc->depth to toggle between 1 and 2 instead of the usual
    0 and 1. This can prevent enable_irq() from unmasking the wakeirq as
    that only happens at desc->depth 1.
    
    This does not necessarily show up with drivers using autosuspend as
    there is time for disable_irq_nosync() before rpm_suspend() gets called
    after the autosuspend timeout.
    
    Let's fix the issue by adding wirq->status that lazily gets set on
    the first rpm_suspend(). We also need PM runtime core private functions
    for dev_pm_enable_wake_irq_check() and dev_pm_disable_wake_irq_check()
    so we can enable the dedicated wakeirq on the first rpm_suspend().
    
    While at it, let's also fix the comments for dev_pm_enable_wake_irq()
    and dev_pm_disable_wake_irq(). Those can still be used by the consumer
    drivers as needed because the IRQ core manages the interrupt usecount
    for us.
    
    Fixes: 4990d4fe327b (PM / Wakeirq: Add automated device wake IRQ handling)
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 6cb589c7529f1c7bdb923ad49ec758e29a0ed345
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Nov 25 16:54:06 2016 +0100

    ASoC: intel: Fix crash at suspend/resume without card registration
    
    commit 2fc995a87f2efcd803438f07bfecd35cc3d90d32 upstream.
    
    When ASoC Intel SST Medfield driver is probed but without codec / card
    assigned, it causes an Oops and freezes the kernel at suspend/resume,
    
     PM: Suspending system (freeze)
     Suspending console(s) (use no_console_suspend to debug)
     BUG: unable to handle kernel NULL pointer dereference at 0000000000000018
     IP: [<ffffffffc09d9409>] sst_soc_prepare+0x19/0xa0 [snd_soc_sst_mfld_platform]
     Oops: 0000 [#1] PREEMPT SMP
     CPU: 0 PID: 1552 Comm: systemd-sleep Tainted: G W 4.9.0-rc6-1.g5f5c2ad-default #1
     Call Trace:
      [<ffffffffb45318f9>] dpm_prepare+0x209/0x460
      [<ffffffffb4531b61>] dpm_suspend_start+0x11/0x60
      [<ffffffffb40d3cc2>] suspend_devices_and_enter+0xb2/0x710
      [<ffffffffb40d462e>] pm_suspend+0x30e/0x390
      [<ffffffffb40d2eba>] state_store+0x8a/0x90
      [<ffffffffb43c670f>] kobj_attr_store+0xf/0x20
      [<ffffffffb42b0d97>] sysfs_kf_write+0x37/0x40
      [<ffffffffb42b02bc>] kernfs_fop_write+0x11c/0x1b0
      [<ffffffffb422be68>] __vfs_write+0x28/0x140
      [<ffffffffb43728a8>] ? apparmor_file_permission+0x18/0x20
      [<ffffffffb433b2ab>] ? security_file_permission+0x3b/0xc0
      [<ffffffffb422d095>] vfs_write+0xb5/0x1a0
      [<ffffffffb422e3d6>] SyS_write+0x46/0xa0
      [<ffffffffb4719fbb>] entry_SYSCALL_64_fastpath+0x1e/0xad
    
    Add proper NULL checks in the PM code of mdfld driver.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Acked-by: Vinod Koul <vinod.koul@intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 6dcb01e7833369acd7ff3b54f49a0a99f4fdf6c2
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Nov 25 16:54:06 2016 +0100

    ASoC: intel: Fix crash at suspend/resume without card registration
    
    commit 2fc995a87f2efcd803438f07bfecd35cc3d90d32 upstream.
    
    When ASoC Intel SST Medfield driver is probed but without codec / card
    assigned, it causes an Oops and freezes the kernel at suspend/resume,
    
     PM: Suspending system (freeze)
     Suspending console(s) (use no_console_suspend to debug)
     BUG: unable to handle kernel NULL pointer dereference at 0000000000000018
     IP: [<ffffffffc09d9409>] sst_soc_prepare+0x19/0xa0 [snd_soc_sst_mfld_platform]
     Oops: 0000 [#1] PREEMPT SMP
     CPU: 0 PID: 1552 Comm: systemd-sleep Tainted: G W 4.9.0-rc6-1.g5f5c2ad-default #1
     Call Trace:
      [<ffffffffb45318f9>] dpm_prepare+0x209/0x460
      [<ffffffffb4531b61>] dpm_suspend_start+0x11/0x60
      [<ffffffffb40d3cc2>] suspend_devices_and_enter+0xb2/0x710
      [<ffffffffb40d462e>] pm_suspend+0x30e/0x390
      [<ffffffffb40d2eba>] state_store+0x8a/0x90
      [<ffffffffb43c670f>] kobj_attr_store+0xf/0x20
      [<ffffffffb42b0d97>] sysfs_kf_write+0x37/0x40
      [<ffffffffb42b02bc>] kernfs_fop_write+0x11c/0x1b0
      [<ffffffffb422be68>] __vfs_write+0x28/0x140
      [<ffffffffb43728a8>] ? apparmor_file_permission+0x18/0x20
      [<ffffffffb433b2ab>] ? security_file_permission+0x3b/0xc0
      [<ffffffffb422d095>] vfs_write+0xb5/0x1a0
      [<ffffffffb422e3d6>] SyS_write+0x46/0xa0
      [<ffffffffb4719fbb>] entry_SYSCALL_64_fastpath+0x1e/0xad
    
    Add proper NULL checks in the PM code of mdfld driver.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Acked-by: Vinod Koul <vinod.koul@intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 41c856b329008609157199552e767a7a02d62cd1
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Nov 25 16:54:06 2016 +0100

    ASoC: intel: Fix crash at suspend/resume without card registration
    
    commit 2fc995a87f2efcd803438f07bfecd35cc3d90d32 upstream.
    
    When ASoC Intel SST Medfield driver is probed but without codec / card
    assigned, it causes an Oops and freezes the kernel at suspend/resume,
    
     PM: Suspending system (freeze)
     Suspending console(s) (use no_console_suspend to debug)
     BUG: unable to handle kernel NULL pointer dereference at 0000000000000018
     IP: [<ffffffffc09d9409>] sst_soc_prepare+0x19/0xa0 [snd_soc_sst_mfld_platform]
     Oops: 0000 [#1] PREEMPT SMP
     CPU: 0 PID: 1552 Comm: systemd-sleep Tainted: G W 4.9.0-rc6-1.g5f5c2ad-default #1
     Call Trace:
      [<ffffffffb45318f9>] dpm_prepare+0x209/0x460
      [<ffffffffb4531b61>] dpm_suspend_start+0x11/0x60
      [<ffffffffb40d3cc2>] suspend_devices_and_enter+0xb2/0x710
      [<ffffffffb40d462e>] pm_suspend+0x30e/0x390
      [<ffffffffb40d2eba>] state_store+0x8a/0x90
      [<ffffffffb43c670f>] kobj_attr_store+0xf/0x20
      [<ffffffffb42b0d97>] sysfs_kf_write+0x37/0x40
      [<ffffffffb42b02bc>] kernfs_fop_write+0x11c/0x1b0
      [<ffffffffb422be68>] __vfs_write+0x28/0x140
      [<ffffffffb43728a8>] ? apparmor_file_permission+0x18/0x20
      [<ffffffffb433b2ab>] ? security_file_permission+0x3b/0xc0
      [<ffffffffb422d095>] vfs_write+0xb5/0x1a0
      [<ffffffffb422e3d6>] SyS_write+0x46/0xa0
      [<ffffffffb4719fbb>] entry_SYSCALL_64_fastpath+0x1e/0xad
    
    Add proper NULL checks in the PM code of mdfld driver.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Acked-by: Vinod Koul <vinod.koul@intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 2ef7ff03a9b050f393344a4537efb176de0c7eb2
Author: Vinod Koul <vkoul@kernel.org>
Date:   Fri Dec 9 15:24:12 2016 +0530

    dmaengine: sirf-dma: remove unused ‘sdesc’
    
    In sirfsoc_dma_pm_suspend(), variable ‘sdesc’ is initialized but never used, which
    leads to warning with W=1.
    
    drivers/dma/sirf-dma.c: In function 'sirfsoc_dma_pm_suspend':
    drivers/dma/sirf-dma.c:1014:27: warning: variable 'sdesc' set but not used [-Wunused-but-set-variable]
    
    So remove it.
    
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

commit bed570307ed78f21b77cb04a1df781dee4a8f05a
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon Dec 5 16:38:16 2016 -0800

    PM / wakeirq: Fix dedicated wakeirq for drivers not using autosuspend
    
    I noticed some wakeirq flakeyness with consumer drivers not using
    autosuspend. For drivers not using autosuspend, the wakeirq may never
    get unmasked in rpm_suspend() because of irq desc->depth.
    
    We are configuring dedicated wakeirqs to start with IRQ_NOAUTOEN as we
    naturally don't want them running until rpm_suspend() is called.
    
    However, when a consumer driver initially calls pm_runtime_get(), we
    now wrongly start with disable_irq_nosync() call on the dedicated
    wakeirq that is disabled to start with.
    
    This causes desc->depth to toggle between 1 and 2 instead of the usual
    0 and 1. This can prevent enable_irq() from unmasking the wakeirq as
    that only happens at desc->depth 1.
    
    This does not necessarily show up with drivers using autosuspend as
    there is time for disable_irq_nosync() before rpm_suspend() gets called
    after the autosuspend timeout.
    
    Let's fix the issue by adding wirq->status that lazily gets set on
    the first rpm_suspend(). We also need PM runtime core private functions
    for dev_pm_enable_wake_irq_check() and dev_pm_disable_wake_irq_check()
    so we can enable the dedicated wakeirq on the first rpm_suspend().
    
    While at it, let's also fix the comments for dev_pm_enable_wake_irq()
    and dev_pm_disable_wake_irq(). Those can still be used by the consumer
    drivers as needed because the IRQ core manages the interrupt usecount
    for us.
    
    Fixes: 4990d4fe327b (PM / Wakeirq: Add automated device wake IRQ handling)
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit b53f40db59b27b62bc294c30506b02a0cae47e0b
Author: Josh Poimboeuf <jpoimboe@redhat.com>
Date:   Fri Dec 2 11:42:21 2016 -0600

    x86/suspend: fix false positive KASAN warning on suspend/resume
    
    Resuming from a suspend operation is showing a KASAN false positive
    warning:
    
      BUG: KASAN: stack-out-of-bounds in unwind_get_return_address+0x11d/0x130 at addr ffff8803867d7878
      Read of size 8 by task pm-suspend/7774
      page:ffffea000e19f5c0 count:0 mapcount:0 mapping:          (null) index:0x0
      flags: 0x2ffff0000000000()
      page dumped because: kasan: bad access detected
      CPU: 0 PID: 7774 Comm: pm-suspend Tainted: G    B           4.9.0-rc7+ #8
      Hardware name: Gigabyte Technology Co., Ltd. Z170X-UD5/Z170X-UD5-CF, BIOS F5 03/07/2016
      Call Trace:
        dump_stack+0x63/0x82
        kasan_report_error+0x4b4/0x4e0
        ? acpi_hw_read_port+0xd0/0x1ea
        ? kfree_const+0x22/0x30
        ? acpi_hw_validate_io_request+0x1a6/0x1a6
        __asan_report_load8_noabort+0x61/0x70
        ? unwind_get_return_address+0x11d/0x130
        unwind_get_return_address+0x11d/0x130
        ? unwind_next_frame+0x97/0xf0
        __save_stack_trace+0x92/0x100
        save_stack_trace+0x1b/0x20
        save_stack+0x46/0xd0
        ? save_stack_trace+0x1b/0x20
        ? save_stack+0x46/0xd0
        ? kasan_kmalloc+0xad/0xe0
        ? kasan_slab_alloc+0x12/0x20
        ? acpi_hw_read+0x2b6/0x3aa
        ? acpi_hw_validate_register+0x20b/0x20b
        ? acpi_hw_write_port+0x72/0xc7
        ? acpi_hw_write+0x11f/0x15f
        ? acpi_hw_read_multiple+0x19f/0x19f
        ? memcpy+0x45/0x50
        ? acpi_hw_write_port+0x72/0xc7
        ? acpi_hw_write+0x11f/0x15f
        ? acpi_hw_read_multiple+0x19f/0x19f
        ? kasan_unpoison_shadow+0x36/0x50
        kasan_kmalloc+0xad/0xe0
        kasan_slab_alloc+0x12/0x20
        kmem_cache_alloc_trace+0xbc/0x1e0
        ? acpi_get_sleep_type_data+0x9a/0x578
        acpi_get_sleep_type_data+0x9a/0x578
        acpi_hw_legacy_wake_prep+0x88/0x22c
        ? acpi_hw_legacy_sleep+0x3c7/0x3c7
        ? acpi_write_bit_register+0x28d/0x2d3
        ? acpi_read_bit_register+0x19b/0x19b
        acpi_hw_sleep_dispatch+0xb5/0xba
        acpi_leave_sleep_state_prep+0x17/0x19
        acpi_suspend_enter+0x154/0x1e0
        ? trace_suspend_resume+0xe8/0xe8
        suspend_devices_and_enter+0xb09/0xdb0
        ? printk+0xa8/0xd8
        ? arch_suspend_enable_irqs+0x20/0x20
        ? try_to_freeze_tasks+0x295/0x600
        pm_suspend+0x6c9/0x780
        ? finish_wait+0x1f0/0x1f0
        ? suspend_devices_and_enter+0xdb0/0xdb0
        state_store+0xa2/0x120
        ? kobj_attr_show+0x60/0x60
        kobj_attr_store+0x36/0x70
        sysfs_kf_write+0x131/0x200
        kernfs_fop_write+0x295/0x3f0
        __vfs_write+0xef/0x760
        ? handle_mm_fault+0x1346/0x35e0
        ? do_iter_readv_writev+0x660/0x660
        ? __pmd_alloc+0x310/0x310
        ? do_lock_file_wait+0x1e0/0x1e0
        ? apparmor_file_permission+0x18/0x20
        ? security_file_permission+0x73/0x1c0
        ? rw_verify_area+0xbd/0x2b0
        vfs_write+0x149/0x4a0
        SyS_write+0xd9/0x1c0
        ? SyS_read+0x1c0/0x1c0
        entry_SYSCALL_64_fastpath+0x1e/0xad
      Memory state around the buggy address:
       ffff8803867d7700: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
       ffff8803867d7780: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
      >ffff8803867d7800: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 f4
                                                                      ^
       ffff8803867d7880: f3 f3 f3 f3 00 00 00 00 00 00 00 00 00 00 00 00
       ffff8803867d7900: 00 00 00 f1 f1 f1 f1 04 f4 f4 f4 f3 f3 f3 f3 00
    
    KASAN instrumentation poisons the stack when entering a function and
    unpoisons it when exiting the function.  However, in the suspend path,
    some functions never return, so their stack never gets unpoisoned,
    resulting in stale KASAN shadow data which can cause later false
    positive warnings like the one above.
    
    Reported-by: Scott Bauer <scott.bauer@intel.com>
    Signed-off-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Acked-by: Andrey Ryabinin <aryabinin@virtuozzo.com>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 2fc995a87f2efcd803438f07bfecd35cc3d90d32
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Nov 25 16:54:06 2016 +0100

    ASoC: intel: Fix crash at suspend/resume without card registration
    
    When ASoC Intel SST Medfield driver is probed but without codec / card
    assigned, it causes an Oops and freezes the kernel at suspend/resume,
    
     PM: Suspending system (freeze)
     Suspending console(s) (use no_console_suspend to debug)
     BUG: unable to handle kernel NULL pointer dereference at 0000000000000018
     IP: [<ffffffffc09d9409>] sst_soc_prepare+0x19/0xa0 [snd_soc_sst_mfld_platform]
     Oops: 0000 [#1] PREEMPT SMP
     CPU: 0 PID: 1552 Comm: systemd-sleep Tainted: G W 4.9.0-rc6-1.g5f5c2ad-default #1
     Call Trace:
      [<ffffffffb45318f9>] dpm_prepare+0x209/0x460
      [<ffffffffb4531b61>] dpm_suspend_start+0x11/0x60
      [<ffffffffb40d3cc2>] suspend_devices_and_enter+0xb2/0x710
      [<ffffffffb40d462e>] pm_suspend+0x30e/0x390
      [<ffffffffb40d2eba>] state_store+0x8a/0x90
      [<ffffffffb43c670f>] kobj_attr_store+0xf/0x20
      [<ffffffffb42b0d97>] sysfs_kf_write+0x37/0x40
      [<ffffffffb42b02bc>] kernfs_fop_write+0x11c/0x1b0
      [<ffffffffb422be68>] __vfs_write+0x28/0x140
      [<ffffffffb43728a8>] ? apparmor_file_permission+0x18/0x20
      [<ffffffffb433b2ab>] ? security_file_permission+0x3b/0xc0
      [<ffffffffb422d095>] vfs_write+0xb5/0x1a0
      [<ffffffffb422e3d6>] SyS_write+0x46/0xa0
      [<ffffffffb4719fbb>] entry_SYSCALL_64_fastpath+0x1e/0xad
    
    Add proper NULL checks in the PM code of mdfld driver.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Acked-by: Vinod Koul <vinod.koul@intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Cc: <stable@vger.kernel.org>

commit b61abd49c5dd07d3b97b638128982c3feef99a93
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Thu Nov 24 17:30:26 2016 +0100

    drm/hisilicon/hibmc: mark PM functions __maybe_unused
    
    When CONFIG_PM_SLEEP is disabled, we get a harmless warning
    
    drm/hisilicon/hibmc/hibmc_drm_drv.c:115:12: error: ‘hibmc_pm_resume’ defined but not used [-Werror=unused-function]
    drm/hisilicon/hibmc/hibmc_drm_drv.c:97:12: error: ‘hibmc_pm_suspend’ defined but not used [-Werror=unused-function]
    
    Marking the functions as __maybe_unused avoids the warning without
    having to add an #ifdef.
    
    Fixes: 5e0df3a08f3d ("drm/hisilicon/hibmc: Add hisilicon hibmc drm master driver")
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/20161124163107.3914495-1-arnd@arndb.de

commit f1790ee2d43355e0d1cf9392a5de8bb47e016540
Author: Sudeep Holla <Sudeep.Holla@arm.com>
Date:   Thu Aug 25 12:23:39 2016 +0100

    i2c: qup: skip qup_i2c_suspend if the device is already runtime suspended
    
    commit 331dcf421c34d227784d07943eb01e4023a42b0a upstream.
    
    If the i2c device is already runtime suspended, if qup_i2c_suspend is
    executed during suspend-to-idle or suspend-to-ram it will result in the
    following splat:
    
    WARNING: CPU: 3 PID: 1593 at drivers/clk/clk.c:476 clk_core_unprepare+0x80/0x90
    Modules linked in:
    
    CPU: 3 PID: 1593 Comm: bash Tainted: G        W       4.8.0-rc3 #14
    Hardware name: Qualcomm Technologies, Inc. APQ 8016 SBC (DT)
    PC is at clk_core_unprepare+0x80/0x90
    LR is at clk_unprepare+0x28/0x40
    pc : [<ffff0000086eecf0>] lr : [<ffff0000086f0c58>] pstate: 60000145
    Call trace:
     clk_core_unprepare+0x80/0x90
     qup_i2c_disable_clocks+0x2c/0x68
     qup_i2c_suspend+0x10/0x20
     platform_pm_suspend+0x24/0x68
     ...
    
    This patch fixes the issue by executing qup_i2c_pm_suspend_runtime
    conditionally in qup_i2c_suspend.
    
    Signed-off-by: Sudeep Holla <sudeep.holla@arm.com>
    Reviewed-by: Andy Gross <andy.gross@linaro.org>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit c6a6330706148e7d5265c3dd658d25843c83390f
Author: Lukas Wunner <lukas@wunner.de>
Date:   Fri Oct 28 10:52:06 2016 +0200

    PCI: Activate runtime PM on a PCIe port only if it can suspend
    
    Currently pcie_portdrv_probe() activates runtime PM on a PCIe port even
    if it will never actually suspend because the BIOS is too old or the
    "pcie_port_pm=off" option was specified on the kernel command line.
    
    A few CPU cycles can be saved by not activating runtime PM at all in these
    cases, because rpm_idle() and rpm_suspend() will bail out right at the
    beginning when calling rpm_check_suspend_allowed(), instead of carrying out
    various locking and assignments, invoking rpm_callback(), getting back
    -EBUSY and rolling everything back.
    
    The conditions checked in pci_bridge_d3_possible() are all static, they
    never change during uptime of the system, hence it's safe to call this to
    determine if runtime PM should be activated.
    
    No functional change intended.
    
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 536d599d4a5104a8f1f771d3a8db97138b0c9ebb
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed Nov 16 13:21:25 2016 -0600

    usb: musb: Add missing pm_runtime_disable and drop 2430 PM timeout
    
    We are missing pm_runtime_disable() in 2430 glue layer. Further,
    we only need to enable PM runtime and disable it on exit. With
    musb_core.c doing PM, the glue layer as a parent will always be
    active when musb_core.c is active.
    
    This fixes host enumeration issues with some devices as reported
    by Ladislav Michl <ladis@linux-mips.org>.
    
    And holding an RPM reference while deregistering the child would
    lead to a crash in omap2430_runtime_suspend() which dereferences
    the now freed child's driver data on put as pointed out by
    Johan Hovold <johan@kernel.org>:
    
    Unable to handle kernel paging request at virtual address 6b6b6f17
    ...
    [<c05453d4>] (omap2430_runtime_suspend) from [<c0481410>]
     (pm_generic_runtime_suspend+0x3c/0x48)
    [<c0481410>] (pm_generic_runtime_suspend) from [<c0121028>]
     (_od_runtime_suspend+0x1c/0x30)
    [<c0121028>] (_od_runtime_suspend) from [<c04833b0>] (__rpm_callback+0x3c/0x70)
    [<c04833b0>] (__rpm_callback) from [<c0483414>] (rpm_callback+0x30/0x90)
    [<c0483414>] (rpm_callback) from [<c0483984>] (rpm_suspend+0x118/0x6b4)
    [<c0483984>] (rpm_suspend) from [<c04840f4>] (rpm_idle+0x104/0x440)
    [<c04840f4>] (rpm_idle) from [<c04844ac>] (__pm_runtime_idle+0x7c/0xb0)
    [<c04844ac>] (__pm_runtime_idle) from [<c0545458>] (omap2430_remove+0x38/0x58)
    [<c0545458>] (omap2430_remove) from [<c047b2bc>] (platform_drv_remove+0x34/0x4c)
    
    Note that if changes are needed to the autosuspend timeout, it should
    be done in musb_core.c.
    
    Reported-by: Ladislav Michl <ladis@linux-mips.org>
    Fixes: 87326e858448 ("usb: musb: Remove extra PM runtime calls from
    2430 glue layer")
    Tested-by: Ladislav Michl <ladis@linux-mips.org>
    Reviewed-by: Johan Hovold <johan@kernel.org>
    Tested-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Bin Liu <b-liu@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit ec7ce653d9f6eb22404dee468bf63d8fcaff9c42
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Wed Sep 21 14:51:07 2016 +0100

    drm/i915: Only shrink the unbound objects during freeze
    
    At the point of creating the hibernation image, the runtime power manage
    core is disabled - and using the rpm functions triggers a warn.
    i915_gem_shrink_all() tries to unbind objects, which requires device
    access and so tries to how an rpm reference triggering a warning:
    
    [   44.235420] ------------[ cut here ]------------
    [   44.235424] WARNING: CPU: 2 PID: 2199 at drivers/gpu/drm/i915/intel_runtime_pm.c:2688 intel_runtime_pm_get_if_in_use+0xe6/0xf0
    [   44.235426] WARN_ON_ONCE(ret < 0)
    [   44.235445] Modules linked in: ctr ccm arc4 rt2800usb rt2x00usb rt2800lib rt2x00lib crc_ccitt mac80211 cmac cfg80211 btusb rfcomm bnep btrtl btbcm btintel bluetooth dcdbas x86_pkg_temp_thermal intel_powerclamp coretemp snd_hda_codec_realtek crct10dif_pclmul crc32_pclmul ghash_clmulni_intel snd_hda_codec_generic aesni_intel snd_hda_codec_hdmi aes_x86_64 lrw gf128mul snd_hda_intel glue_helper ablk_helper cryptd snd_hda_codec hid_multitouch joydev snd_hda_core binfmt_misc i2c_hid serio_raw snd_pcm acpi_pad snd_timer snd i2c_designware_platform 8250_dw nls_iso8859_1 i2c_designware_core lpc_ich mfd_core soundcore usbhid hid psmouse ahci libahci
    [   44.235447] CPU: 2 PID: 2199 Comm: kworker/u8:8 Not tainted 4.8.0-rc5+ #130
    [   44.235447] Hardware name: Dell Inc. XPS 13 9343/0310JH, BIOS A07 11/11/2015
    [   44.235450] Workqueue: events_unbound async_run_entry_fn
    [   44.235453]  0000000000000000 ffff8801b2f7fb98 ffffffff81306c2f ffff8801b2f7fbe8
    [   44.235454]  0000000000000000 ffff8801b2f7fbd8 ffffffff81056c01 00000a801f50ecc0
    [   44.235456]  ffff88020ce50000 ffff88020ce59b60 ffffffff81a60b5c ffffffff81414840
    [   44.235456] Call Trace:
    [   44.235459]  [<ffffffff81306c2f>] dump_stack+0x4d/0x6e
    [   44.235461]  [<ffffffff81056c01>] __warn+0xd1/0xf0
    [   44.235464]  [<ffffffff81414840>] ? i915_pm_suspend_late+0x30/0x30
    [   44.235465]  [<ffffffff81056c6f>] warn_slowpath_fmt+0x4f/0x60
    [   44.235468]  [<ffffffff814e73ce>] ? pm_runtime_get_if_in_use+0x6e/0xa0
    [   44.235469]  [<ffffffff81433526>] intel_runtime_pm_get_if_in_use+0xe6/0xf0
    [   44.235471]  [<ffffffff81458a26>] i915_gem_shrink+0x306/0x360
    [   44.235473]  [<ffffffff81343fd4>] ? pci_platform_power_transition+0x24/0x90
    [   44.235475]  [<ffffffff81414840>] ? i915_pm_suspend_late+0x30/0x30
    [   44.235476]  [<ffffffff81458dfb>] i915_gem_shrink_all+0x1b/0x30
    [   44.235478]  [<ffffffff814560b3>] i915_gem_freeze_late+0x33/0x90
    [   44.235479]  [<ffffffff81414877>] i915_pm_freeze_late+0x37/0x40
    [   44.235481]  [<ffffffff814e9b8e>] dpm_run_callback+0x4e/0x130
    [   44.235483]  [<ffffffff814ea5db>] __device_suspend_late+0xdb/0x1f0
    [   44.235484]  [<ffffffff814ea70f>] async_suspend_late+0x1f/0xa0
    [   44.235486]  [<ffffffff81077557>] async_run_entry_fn+0x37/0x150
    [   44.235488]  [<ffffffff8106f518>] process_one_work+0x148/0x3f0
    [   44.235490]  [<ffffffff8106f8eb>] worker_thread+0x12b/0x490
    [   44.235491]  [<ffffffff8106f7c0>] ? process_one_work+0x3f0/0x3f0
    [   44.235492]  [<ffffffff81074d09>] kthread+0xc9/0xe0
    [   44.235495]  [<ffffffff816e257f>] ret_from_fork+0x1f/0x40
    [   44.235496]  [<ffffffff81074c40>] ? kthread_park+0x60/0x60
    [   44.235497] ---[ end trace e438706b97c7f132 ]---
    
    Alternatively, to actually shrink everything we have to do so slightly
    earlier in the hibernation process.
    
    To keep lockdep silent, we need to take struct_mutex for the shrinker
    even though we know that we are the only user during the freeze.
    
    Fixes: 7aab2d534e35 ("drm/i915: Shrink objects prior to hibernation")
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20160921135108.29574-2-chris@chris-wilson.co.uk
    (cherry picked from commit 6a800eabba34945c2986d70114b41d564bad52a8)
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>

commit 05e5e96324402c5066a763315d8159c9b8c94e22
Author: Sudeep Holla <Sudeep.Holla@arm.com>
Date:   Thu Aug 25 12:23:39 2016 +0100

    i2c: qup: skip qup_i2c_suspend if the device is already runtime suspended
    
    commit 331dcf421c34d227784d07943eb01e4023a42b0a upstream.
    
    If the i2c device is already runtime suspended, if qup_i2c_suspend is
    executed during suspend-to-idle or suspend-to-ram it will result in the
    following splat:
    
    WARNING: CPU: 3 PID: 1593 at drivers/clk/clk.c:476 clk_core_unprepare+0x80/0x90
    Modules linked in:
    
    CPU: 3 PID: 1593 Comm: bash Tainted: G        W       4.8.0-rc3 #14
    Hardware name: Qualcomm Technologies, Inc. APQ 8016 SBC (DT)
    PC is at clk_core_unprepare+0x80/0x90
    LR is at clk_unprepare+0x28/0x40
    pc : [<ffff0000086eecf0>] lr : [<ffff0000086f0c58>] pstate: 60000145
    Call trace:
     clk_core_unprepare+0x80/0x90
     qup_i2c_disable_clocks+0x2c/0x68
     qup_i2c_suspend+0x10/0x20
     platform_pm_suspend+0x24/0x68
     ...
    
    This patch fixes the issue by executing qup_i2c_pm_suspend_runtime
    conditionally in qup_i2c_suspend.
    
    Signed-off-by: Sudeep Holla <sudeep.holla@arm.com>
    Reviewed-by: Andy Gross <andy.gross@linaro.org>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 4b37b0ca71844614ada140b88dcee7fc2e8d1680
Author: Sudeep Holla <Sudeep.Holla@arm.com>
Date:   Thu Aug 25 12:23:39 2016 +0100

    i2c: qup: skip qup_i2c_suspend if the device is already runtime suspended
    
    commit 331dcf421c34d227784d07943eb01e4023a42b0a upstream.
    
    If the i2c device is already runtime suspended, if qup_i2c_suspend is
    executed during suspend-to-idle or suspend-to-ram it will result in the
    following splat:
    
    WARNING: CPU: 3 PID: 1593 at drivers/clk/clk.c:476 clk_core_unprepare+0x80/0x90
    Modules linked in:
    
    CPU: 3 PID: 1593 Comm: bash Tainted: G        W       4.8.0-rc3 #14
    Hardware name: Qualcomm Technologies, Inc. APQ 8016 SBC (DT)
    PC is at clk_core_unprepare+0x80/0x90
    LR is at clk_unprepare+0x28/0x40
    pc : [<ffff0000086eecf0>] lr : [<ffff0000086f0c58>] pstate: 60000145
    Call trace:
     clk_core_unprepare+0x80/0x90
     qup_i2c_disable_clocks+0x2c/0x68
     qup_i2c_suspend+0x10/0x20
     platform_pm_suspend+0x24/0x68
     ...
    
    This patch fixes the issue by executing qup_i2c_pm_suspend_runtime
    conditionally in qup_i2c_suspend.
    
    Signed-off-by: Sudeep Holla <sudeep.holla@arm.com>
    Reviewed-by: Andy Gross <andy.gross@linaro.org>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 331dcf421c34d227784d07943eb01e4023a42b0a
Author: Sudeep Holla <Sudeep.Holla@arm.com>
Date:   Thu Aug 25 12:23:39 2016 +0100

    i2c: qup: skip qup_i2c_suspend if the device is already runtime suspended
    
    If the i2c device is already runtime suspended, if qup_i2c_suspend is
    executed during suspend-to-idle or suspend-to-ram it will result in the
    following splat:
    
    WARNING: CPU: 3 PID: 1593 at drivers/clk/clk.c:476 clk_core_unprepare+0x80/0x90
    Modules linked in:
    
    CPU: 3 PID: 1593 Comm: bash Tainted: G        W       4.8.0-rc3 #14
    Hardware name: Qualcomm Technologies, Inc. APQ 8016 SBC (DT)
    PC is at clk_core_unprepare+0x80/0x90
    LR is at clk_unprepare+0x28/0x40
    pc : [<ffff0000086eecf0>] lr : [<ffff0000086f0c58>] pstate: 60000145
    Call trace:
     clk_core_unprepare+0x80/0x90
     qup_i2c_disable_clocks+0x2c/0x68
     qup_i2c_suspend+0x10/0x20
     platform_pm_suspend+0x24/0x68
     ...
    
    This patch fixes the issue by executing qup_i2c_pm_suspend_runtime
    conditionally in qup_i2c_suspend.
    
    Signed-off-by: Sudeep Holla <sudeep.holla@arm.com>
    Reviewed-by: Andy Gross <andy.gross@linaro.org>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>
    Cc: stable@kernel.org

commit 6a800eabba34945c2986d70114b41d564bad52a8
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Wed Sep 21 14:51:07 2016 +0100

    drm/i915: Only shrink the unbound objects during freeze
    
    At the point of creating the hibernation image, the runtime power manage
    core is disabled - and using the rpm functions triggers a warn.
    i915_gem_shrink_all() tries to unbind objects, which requires device
    access and so tries to how an rpm reference triggering a warning:
    
    [   44.235420] ------------[ cut here ]------------
    [   44.235424] WARNING: CPU: 2 PID: 2199 at drivers/gpu/drm/i915/intel_runtime_pm.c:2688 intel_runtime_pm_get_if_in_use+0xe6/0xf0
    [   44.235426] WARN_ON_ONCE(ret < 0)
    [   44.235445] Modules linked in: ctr ccm arc4 rt2800usb rt2x00usb rt2800lib rt2x00lib crc_ccitt mac80211 cmac cfg80211 btusb rfcomm bnep btrtl btbcm btintel bluetooth dcdbas x86_pkg_temp_thermal intel_powerclamp coretemp snd_hda_codec_realtek crct10dif_pclmul crc32_pclmul ghash_clmulni_intel snd_hda_codec_generic aesni_intel snd_hda_codec_hdmi aes_x86_64 lrw gf128mul snd_hda_intel glue_helper ablk_helper cryptd snd_hda_codec hid_multitouch joydev snd_hda_core binfmt_misc i2c_hid serio_raw snd_pcm acpi_pad snd_timer snd i2c_designware_platform 8250_dw nls_iso8859_1 i2c_designware_core lpc_ich mfd_core soundcore usbhid hid psmouse ahci libahci
    [   44.235447] CPU: 2 PID: 2199 Comm: kworker/u8:8 Not tainted 4.8.0-rc5+ #130
    [   44.235447] Hardware name: Dell Inc. XPS 13 9343/0310JH, BIOS A07 11/11/2015
    [   44.235450] Workqueue: events_unbound async_run_entry_fn
    [   44.235453]  0000000000000000 ffff8801b2f7fb98 ffffffff81306c2f ffff8801b2f7fbe8
    [   44.235454]  0000000000000000 ffff8801b2f7fbd8 ffffffff81056c01 00000a801f50ecc0
    [   44.235456]  ffff88020ce50000 ffff88020ce59b60 ffffffff81a60b5c ffffffff81414840
    [   44.235456] Call Trace:
    [   44.235459]  [<ffffffff81306c2f>] dump_stack+0x4d/0x6e
    [   44.235461]  [<ffffffff81056c01>] __warn+0xd1/0xf0
    [   44.235464]  [<ffffffff81414840>] ? i915_pm_suspend_late+0x30/0x30
    [   44.235465]  [<ffffffff81056c6f>] warn_slowpath_fmt+0x4f/0x60
    [   44.235468]  [<ffffffff814e73ce>] ? pm_runtime_get_if_in_use+0x6e/0xa0
    [   44.235469]  [<ffffffff81433526>] intel_runtime_pm_get_if_in_use+0xe6/0xf0
    [   44.235471]  [<ffffffff81458a26>] i915_gem_shrink+0x306/0x360
    [   44.235473]  [<ffffffff81343fd4>] ? pci_platform_power_transition+0x24/0x90
    [   44.235475]  [<ffffffff81414840>] ? i915_pm_suspend_late+0x30/0x30
    [   44.235476]  [<ffffffff81458dfb>] i915_gem_shrink_all+0x1b/0x30
    [   44.235478]  [<ffffffff814560b3>] i915_gem_freeze_late+0x33/0x90
    [   44.235479]  [<ffffffff81414877>] i915_pm_freeze_late+0x37/0x40
    [   44.235481]  [<ffffffff814e9b8e>] dpm_run_callback+0x4e/0x130
    [   44.235483]  [<ffffffff814ea5db>] __device_suspend_late+0xdb/0x1f0
    [   44.235484]  [<ffffffff814ea70f>] async_suspend_late+0x1f/0xa0
    [   44.235486]  [<ffffffff81077557>] async_run_entry_fn+0x37/0x150
    [   44.235488]  [<ffffffff8106f518>] process_one_work+0x148/0x3f0
    [   44.235490]  [<ffffffff8106f8eb>] worker_thread+0x12b/0x490
    [   44.235491]  [<ffffffff8106f7c0>] ? process_one_work+0x3f0/0x3f0
    [   44.235492]  [<ffffffff81074d09>] kthread+0xc9/0xe0
    [   44.235495]  [<ffffffff816e257f>] ret_from_fork+0x1f/0x40
    [   44.235496]  [<ffffffff81074c40>] ? kthread_park+0x60/0x60
    [   44.235497] ---[ end trace e438706b97c7f132 ]---
    
    Alternatively, to actually shrink everything we have to do so slightly
    earlier in the hibernation process.
    
    To keep lockdep silent, we need to take struct_mutex for the shrinker
    even though we know that we are the only user during the freeze.
    
    Fixes: 7aab2d534e35 ("drm/i915: Shrink objects prior to hibernation")
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20160921135108.29574-2-chris@chris-wilson.co.uk

commit 778935778c3b88e5152a88765850009006ef2e32
Author: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
Date:   Tue Apr 26 10:42:25 2016 -0700

    PM / runtime: Use _rcuidle for runtime suspend tracepoints
    
    Further testing with false negatives suppressed by commit 293e2421fe25
    ("rcu: Remove superfluous versions of rcu_read_lock_sched_held()")
    identified a few more unprotected uses of RCU from the idle loop.
    Because RCU actively ignores idle-loop code (for energy-efficiency
    reasons, among other things), using RCU from the idle loop can result
    in too-short grace periods, in turn resulting in arbitrary misbehavior.
    
    The affected function is rpm_suspend().
    
    The resulting lockdep-RCU splat is as follows:
    
    ------------------------------------------------------------------------
    
    Warning from omap3
    
    ===============================
    [ INFO: suspicious RCU usage. ]
    4.6.0-rc5-next-20160426+ #1112 Not tainted
    -------------------------------
    include/trace/events/rpm.h:63 suspicious rcu_dereference_check() usage!
    
    other info that might help us debug this:
    
    RCU used illegally from idle CPU!
    rcu_scheduler_active = 1, debug_locks = 0
    RCU used illegally from extended quiescent state!
    1 lock held by swapper/0/0:
     #0:  (&(&dev->power.lock)->rlock){-.-...}, at: [<c052ee24>] __pm_runtime_suspend+0x54/0x84
    
    stack backtrace:
    CPU: 0 PID: 0 Comm: swapper/0 Not tainted 4.6.0-rc5-next-20160426+ #1112
    Hardware name: Generic OMAP36xx (Flattened Device Tree)
    [<c0110308>] (unwind_backtrace) from [<c010c3a8>] (show_stack+0x10/0x14)
    [<c010c3a8>] (show_stack) from [<c047fec8>] (dump_stack+0xb0/0xe4)
    [<c047fec8>] (dump_stack) from [<c052d7b4>] (rpm_suspend+0x604/0x7e4)
    [<c052d7b4>] (rpm_suspend) from [<c052ee34>] (__pm_runtime_suspend+0x64/0x84)
    [<c052ee34>] (__pm_runtime_suspend) from [<c04bf3bc>] (omap2_gpio_prepare_for_idle+0x5c/0x70)
    [<c04bf3bc>] (omap2_gpio_prepare_for_idle) from [<c01255e8>] (omap_sram_idle+0x140/0x244)
    [<c01255e8>] (omap_sram_idle) from [<c0126b48>] (omap3_enter_idle_bm+0xfc/0x1ec)
    [<c0126b48>] (omap3_enter_idle_bm) from [<c0601db8>] (cpuidle_enter_state+0x80/0x3d4)
    [<c0601db8>] (cpuidle_enter_state) from [<c0183c74>] (cpu_startup_entry+0x198/0x3a0)
    [<c0183c74>] (cpu_startup_entry) from [<c0b00c0c>] (start_kernel+0x354/0x3c8)
    [<c0b00c0c>] (start_kernel) from [<8000807c>] (0x8000807c)
    
    ------------------------------------------------------------------------
    
    Reported-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Tested-by: Tony Lindgren <tony@atomide.com>
    Tested-by: Guenter Roeck <linux@roeck-us.net>
    [ rjw: Subject ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit d7737ce964d944dd07e25b0f569edcd550ede18c
Author: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
Date:   Tue Apr 26 13:03:51 2016 -0700

    PM / runtime: Add _rcuidle suffix to allow rpm_idle() use from idle
    
    This commit appends a few _rcuidle suffixes to fix the following
    RCU-used-from-idle bug:
    
    > ===============================
    > [ INFO: suspicious RCU usage. ]
    > 4.6.0-rc5-next-20160426+ #1116 Not tainted
    > -------------------------------
    > include/trace/events/rpm.h:95 suspicious rcu_dereference_check() usage!
    >
    > other info that might help us debug this:
    >
    >
    > RCU used illegally from idle CPU!
    > rcu_scheduler_active = 1, debug_locks = 0
    > RCU used illegally from extended quiescent state!
    > 1 lock held by swapper/0/0:
    >  #0:  (&(&dev->power.lock)->rlock){-.-...}, at: [<c052cc2c>] __rpm_callback+0x58/0x60
    >
    > stack backtrace:
    > CPU: 0 PID: 0 Comm: swapper/0 Not tainted 4.6.0-rc5-next-20160426+ #1116
    > Hardware name: Generic OMAP36xx (Flattened Device Tree)
    > [<c0110290>] (unwind_backtrace) from [<c010c3a8>] (show_stack+0x10/0x14)
    > [<c010c3a8>] (show_stack) from [<c047fd68>] (dump_stack+0xb0/0xe4)
    > [<c047fd68>] (dump_stack) from [<c052d5d0>] (rpm_suspend+0x580/0x768)
    > [<c052d5d0>] (rpm_suspend) from [<c052ec58>] (__pm_runtime_suspend+0x64/0x84)
    > [<c052ec58>] (__pm_runtime_suspend) from [<c04bf25c>] (omap2_gpio_prepare_for_idle+0x5c/0x70)
    > [<c04bf25c>] (omap2_gpio_prepare_for_idle) from [<c0125568>] (omap_sram_idle+0x140/0x244)
    > [<c0125568>] (omap_sram_idle) from [<c01269dc>] (omap3_enter_idle_bm+0xfc/0x1ec)
    > [<c01269dc>] (omap3_enter_idle_bm) from [<c0601bdc>] (cpuidle_enter_state+0x80/0x3d4)
    > [<c0601bdc>] (cpuidle_enter_state) from [<c0183b08>] (cpu_startup_entry+0x198/0x3a0)
    > [<c0183b08>] (cpu_startup_entry) from [<c0b00c0c>] (start_kernel+0x354/0x3c8)
    > [<c0b00c0c>] (start_kernel) from [<8000807c>] (0x8000807c)
    
    In the immortal words of Steven Rostedt, "*Whack* *Whack* *Whack*!!!"
    
    Reported-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Tested-by: Tony Lindgren <tony@atomide.com>
    Tested-by: Guenter Roeck <linux@roeck-us.net>
    WhACKED-by: Steven Rostedt <rostedt@goodmis.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 3de7eed08b1c71a7bce23f91315fa63eb2d25cbb
Author: Suman Anna <s-anna@ti.com>
Date:   Sun Apr 10 13:20:11 2016 -0600

    ARM: OMAP2+: hwmod: fix _idle() hwmod state sanity check sequence
    
    commit c20c8f750d9f8f8617f07ee2352d3ff560e66bc2 upstream.
    
    The omap_hwmod _enable() function can return success without setting
    the hwmod state to _HWMOD_STATE_ENABLED for IPs with reset lines when
    all of the reset lines are asserted. The omap_hwmod _idle() function
    also performs a similar check, but after checking for the hwmod state
    first. This triggers the WARN when pm_runtime_get and pm_runtime_put
    are invoked on IPs with all reset lines asserted. Reverse the checks
    for hwmod state and reset lines status to fix this.
    
    Issue found during a unbind operation on a device with reset lines
    still asserted, example backtrace below
    
     ------------[ cut here ]------------
     WARNING: CPU: 1 PID: 879 at arch/arm/mach-omap2/omap_hwmod.c:2207 _idle+0x1e4/0x240()
     omap_hwmod: mmu_dsp: idle state can only be entered from enabled state
     Modules linked in:
     CPU: 1 PID: 879 Comm: sh Not tainted 4.4.0-00008-ga989d951331a #3
     Hardware name: Generic OMAP5 (Flattened Device Tree)
     [<c0018e60>] (unwind_backtrace) from [<c0014dc4>] (show_stack+0x10/0x14)
     [<c0014dc4>] (show_stack) from [<c037ac28>] (dump_stack+0x90/0xc0)
     [<c037ac28>] (dump_stack) from [<c003f420>] (warn_slowpath_common+0x78/0xb4)
     [<c003f420>] (warn_slowpath_common) from [<c003f48c>] (warn_slowpath_fmt+0x30/0x40)
     [<c003f48c>] (warn_slowpath_fmt) from [<c0028c20>] (_idle+0x1e4/0x240)
     [<c0028c20>] (_idle) from [<c0029080>] (omap_hwmod_idle+0x28/0x48)
     [<c0029080>] (omap_hwmod_idle) from [<c002a5a4>] (omap_device_idle+0x3c/0x90)
     [<c002a5a4>] (omap_device_idle) from [<c0427a90>] (__rpm_callback+0x2c/0x60)
     [<c0427a90>] (__rpm_callback) from [<c0427ae4>] (rpm_callback+0x20/0x80)
     [<c0427ae4>] (rpm_callback) from [<c0427f84>] (rpm_suspend+0x138/0x74c)
     [<c0427f84>] (rpm_suspend) from [<c0428b78>] (__pm_runtime_idle+0x78/0xa8)
     [<c0428b78>] (__pm_runtime_idle) from [<c041f514>] (__device_release_driver+0x64/0x100)
     [<c041f514>] (__device_release_driver) from [<c041f5d0>] (device_release_driver+0x20/0x2c)
     [<c041f5d0>] (device_release_driver) from [<c041d85c>] (unbind_store+0x78/0xf8)
     [<c041d85c>] (unbind_store) from [<c0206df8>] (kernfs_fop_write+0xc0/0x1c4)
     [<c0206df8>] (kernfs_fop_write) from [<c018a120>] (__vfs_write+0x20/0xdc)
     [<c018a120>] (__vfs_write) from [<c018a9cc>] (vfs_write+0x90/0x164)
     [<c018a9cc>] (vfs_write) from [<c018b1f0>] (SyS_write+0x44/0x9c)
     [<c018b1f0>] (SyS_write) from [<c0010420>] (ret_fast_syscall+0x0/0x1c)
     ---[ end trace a4182013c75a9f50 ]---
    
    While at this, fix the sequence in _shutdown() as well, though there
    is no easy reproducible scenario.
    
    Fixes: 747834ab8347 ("ARM: OMAP2+: hwmod: revise hardreset behavior")
    Signed-off-by: Suman Anna <s-anna@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit 8fe5616b20e5742bb5fee0e77dffe2fc76ac92a0
Author: Jyri Sarha <jsarha@ti.com>
Date:   Tue Jun 14 11:43:30 2016 +0300

    drm/tilcdc: Restore old dpms state in pm_resume()
    
    Restore old dpms state in pm_resume(). The dpms is turned off in
    pm_suspend() and it should be restored to its original state in
    pm_resume(). Without this patch the display is left blanked after a
    suspend/resume cycle.
    
    Fixes commit 614b3cfeb8d2 ("drm/tilcdc: disable the lcd controller/dma
    engine when suspend invoked")
    
    Signed-off-by: Jyri Sarha <jsarha@ti.com>

commit 71723f95463d284004bd0afe1825e6790a0c90d0
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Mon Jun 20 11:14:26 2016 +0200

    PM / runtime: print error when activating a child to unactive parent
    
    The code currently silently bails out with -EBUSY if you try to
    activate a child to an inactive parent.
    
    This typically happens when you have a runtime suspended parent
    and runtime resume your child, but forgot to set .ignore_children
    on the parent to true with pm_suspend_ignore_children(dev).
    
    Silently ignoring this error is not good as it gives rise to
    other strange behaviour like double-resume of devices after
    silently bailing out of the .runtime_resume() callback.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 43043a55b27f4a1f249f43a863402d645786c9bc
Author: Ben Dooks <ben.dooks@codethink.co.uk>
Date:   Tue Jun 7 20:03:46 2016 +0100

    mvebu: fix missing include of common.h in pm.c
    
    The mvebu_pm_suspend_init() is missing a definition, so
    include common.h which defines this function into pm.c to
    fix the following warning:
    
    arch/arm/mach-mvebu/pm.c:235:12: warning: symbol 'mvebu_pm_suspend_init' was not declared. Should it be static?
    
    Signed-off-by: Ben Dooks <ben.dooks@codethink.co.uk>
    Signed-off-by: Gregory CLEMENT <gregory.clement@free-electrons.com>

commit 2f87a6ea1b0c4dfb71acf40d24f12b27e7680794
Author: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
Date:   Tue Apr 26 12:43:57 2016 -0700

    clk: Add _rcuidle tracepoints to allow clk_core_disable() use from idle
    
    This commit adds an _rcuidle suffix to a pair of trace events to
    prevent the following splat:
    
    > ===============================
    > [ INFO: suspicious RCU usage. ]
    > 4.6.0-rc5-next-20160426+ #1114 Not tainted
    > -------------------------------
    > include/trace/events/clk.h:59 suspicious rcu_dereference_check() usage!
    >
    > other info that might help us debug this:
    >
    >
    > RCU used illegally from idle CPU!
    > rcu_scheduler_active = 1, debug_locks = 0
    > RCU used illegally from extended quiescent state!
    > 2 locks held by swapper/0/0:
    >  #0:  (&oh->hwmod_key#30){......}, at: [<c0121b40>] omap_hwmod_idle+0x18/0x44
    >  #1:  (enable_lock){......}, at: [<c0630998>] clk_enable_lock+0x18/0x124
    >
    > stack backtrace:
    > CPU: 0 PID: 0 Comm: swapper/0 Not tainted 4.6.0-rc5-next-20160426+ #1114
    > Hardware name: Generic OMAP36xx (Flattened Device Tree)
    > [<c0110290>] (unwind_backtrace) from [<c010c3a8>] (show_stack+0x10/0x14)
    > [<c010c3a8>] (show_stack) from [<c047fd68>] (dump_stack+0xb0/0xe4)
    > [<c047fd68>] (dump_stack) from [<c0631618>] (clk_core_disable+0x17c/0x348)
    > [<c0631618>] (clk_core_disable) from [<c0632774>] (clk_disable+0x24/0x30)
    > [<c0632774>] (clk_disable) from [<c0120590>] (_disable_clocks+0x18/0x7c)
    > [<c0120590>] (_disable_clocks) from [<c0121680>] (_idle+0x12c/0x230)
    > [<c0121680>] (_idle) from [<c0121b4c>] (omap_hwmod_idle+0x24/0x44)
    > [<c0121b4c>] (omap_hwmod_idle) from [<c0122c24>] (omap_device_idle+0x3c/0x90)
    > [<c0122c24>] (omap_device_idle) from [<c052cc00>] (__rpm_callback+0x2c/0x60)
    > [<c052cc00>] (__rpm_callback) from [<c052cc54>] (rpm_callback+0x20/0x80)
    > [<c052cc54>] (rpm_callback) from [<c052d150>] (rpm_suspend+0x100/0x768)
    > [<c052d150>] (rpm_suspend) from [<c052ec58>] (__pm_runtime_suspend+0x64/0x84)
    > [<c052ec58>] (__pm_runtime_suspend) from [<c04bf25c>] (omap2_gpio_prepare_for_idle+0x5c/0x70)
    > [<c04bf25c>] (omap2_gpio_prepare_for_idle) from [<c0125568>] (omap_sram_idle+0x140/0x244)
    > [<c0125568>] (omap_sram_idle) from [<c01269dc>] (omap3_enter_idle_bm+0xfc/0x1ec)
    > [<c01269dc>] (omap3_enter_idle_bm) from [<c0601bdc>] (cpuidle_enter_state+0x80/0x3d4)
    > [<c0601bdc>] (cpuidle_enter_state) from [<c0183b08>] (cpu_startup_entry+0x198/0x3a0)
    > [<c0183b08>] (cpu_startup_entry) from [<c0b00c0c>] (start_kernel+0x354/0x3c8)
    > [<c0b00c0c>] (start_kernel) from [<8000807c>] (0x8000807c)
    
    Reported-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Tested-by: Tony Lindgren <tony@atomide.com>
    Tested-by: Guenter Roeck <linux@roeck-us.net>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Michael Turquette <mturquette@baylibre.com>
    Cc: Stephen Boyd <sboyd@codeaurora.org>
    Cc: <linux-omap@vger.kernel.org>
    Cc: <linux-arm-kernel@lists.infradead.org>
    Cc: <linux-clk@vger.kernel.org>

commit 43f7f88b9362e1f26603b45932069bbd6e15a1e1
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Thu Jun 2 11:17:11 2016 +0300

    PCI: Don't clear d3cold_allowed for PCIe ports
    
    The PCI core skips bridges and ports when the system is suspended.  The PCI
    core checks return value of pci_has_subordinate() in pci_pm_suspend_noirq()
    to skip all devices where it is non-zero (which means PCI bridges and PCIe
    ports).
    
    Since PCIe ports are never suspended in the first place, there is no need
    to set d3cold_allowed for them.
    
    Tested-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit e4234a1fc343ca35f852bc527fae56fade879d4a
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Thu Mar 31 11:45:06 2016 +0100

    kernfs: Move faulting copy_user operations outside of the mutex
    
    A fault in a user provided buffer may lead anywhere, and lockdep warns
    that we have a potential deadlock between the mm->mmap_sem and the
    kernfs file mutex:
    
    [   82.811702] ======================================================
    [   82.811705] [ INFO: possible circular locking dependency detected ]
    [   82.811709] 4.5.0-rc4-gfxbench+ #1 Not tainted
    [   82.811711] -------------------------------------------------------
    [   82.811714] kms_setmode/5859 is trying to acquire lock:
    [   82.811717]  (&dev->struct_mutex){+.+.+.}, at: [<ffffffff8150d9c1>] drm_gem_mmap+0x1a1/0x270
    [   82.811731]
    but task is already holding lock:
    [   82.811734]  (&mm->mmap_sem){++++++}, at: [<ffffffff8117b364>] vm_mmap_pgoff+0x44/0xa0
    [   82.811745]
    which lock already depends on the new lock.
    
    [   82.811749]
    the existing dependency chain (in reverse order) is:
    [   82.811752]
    -> #3 (&mm->mmap_sem){++++++}:
    [   82.811761]        [<ffffffff810cc883>] lock_acquire+0xc3/0x1d0
    [   82.811766]        [<ffffffff8118bc65>] __might_fault+0x75/0xa0
    [   82.811771]        [<ffffffff8124da4a>] kernfs_fop_write+0x8a/0x180
    [   82.811787]        [<ffffffff811d1023>] __vfs_write+0x23/0xe0
    [   82.811792]        [<ffffffff811d1d74>] vfs_write+0xa4/0x190
    [   82.811797]        [<ffffffff811d2c14>] SyS_write+0x44/0xb0
    [   82.811801]        [<ffffffff817bb81b>] entry_SYSCALL_64_fastpath+0x16/0x73
    [   82.811807]
    -> #2 (s_active#6){++++.+}:
    [   82.811814]        [<ffffffff810cc883>] lock_acquire+0xc3/0x1d0
    [   82.811819]        [<ffffffff8124c070>] __kernfs_remove+0x210/0x2f0
    [   82.811823]        [<ffffffff8124d040>] kernfs_remove_by_name_ns+0x40/0xa0
    [   82.811828]        [<ffffffff8124e9e0>] sysfs_remove_file_ns+0x10/0x20
    [   82.811832]        [<ffffffff815318d4>] device_del+0x124/0x250
    [   82.811837]        [<ffffffff81531a19>] device_unregister+0x19/0x60
    [   82.811841]        [<ffffffff8153c051>] cpu_cache_sysfs_exit+0x51/0xb0
    [   82.811846]        [<ffffffff8153c628>] cacheinfo_cpu_callback+0x38/0x70
    [   82.811851]        [<ffffffff8109ae89>] notifier_call_chain+0x39/0xa0
    [   82.811856]        [<ffffffff8109aef9>] __raw_notifier_call_chain+0x9/0x10
    [   82.811860]        [<ffffffff810786de>] cpu_notify+0x1e/0x40
    [   82.811865]        [<ffffffff81078779>] cpu_notify_nofail+0x9/0x20
    [   82.811869]        [<ffffffff81078ac3>] _cpu_down+0x233/0x340
    [   82.811874]        [<ffffffff81079019>] disable_nonboot_cpus+0xc9/0x350
    [   82.811878]        [<ffffffff810d2e11>] suspend_devices_and_enter+0x5a1/0xb50
    [   82.811883]        [<ffffffff810d3903>] pm_suspend+0x543/0x8d0
    [   82.811888]        [<ffffffff810d1b77>] state_store+0x77/0xe0
    [   82.811892]        [<ffffffff813fa68f>] kobj_attr_store+0xf/0x20
    [   82.811897]        [<ffffffff8124e740>] sysfs_kf_write+0x40/0x50
    [   82.811902]        [<ffffffff8124dafc>] kernfs_fop_write+0x13c/0x180
    [   82.811906]        [<ffffffff811d1023>] __vfs_write+0x23/0xe0
    [   82.811910]        [<ffffffff811d1d74>] vfs_write+0xa4/0x190
    [   82.811914]        [<ffffffff811d2c14>] SyS_write+0x44/0xb0
    [   82.811918]        [<ffffffff817bb81b>] entry_SYSCALL_64_fastpath+0x16/0x73
    [   82.811923]
    -> #1 (cpu_hotplug.lock){+.+.+.}:
    [   82.811929]        [<ffffffff810cc883>] lock_acquire+0xc3/0x1d0
    [   82.811933]        [<ffffffff817b6f72>] mutex_lock_nested+0x62/0x3b0
    [   82.811940]        [<ffffffff810784c1>] get_online_cpus+0x61/0x80
    [   82.811944]        [<ffffffff811170eb>] stop_machine+0x1b/0xe0
    [   82.811949]        [<ffffffffa0178edd>] gen8_ggtt_insert_entries__BKL+0x2d/0x30 [i915]
    [   82.812009]        [<ffffffffa017d3a6>] ggtt_bind_vma+0x46/0x70 [i915]
    [   82.812045]        [<ffffffffa017eb70>] i915_vma_bind+0x140/0x290 [i915]
    [   82.812081]        [<ffffffffa01862b9>] i915_gem_object_do_pin+0x899/0xb00 [i915]
    [   82.812117]        [<ffffffffa0186555>] i915_gem_object_pin+0x35/0x40 [i915]
    [   82.812154]        [<ffffffffa019a23e>] intel_init_pipe_control+0xbe/0x210 [i915]
    [   82.812192]        [<ffffffffa0197312>] intel_logical_rings_init+0xe2/0xde0 [i915]
    [   82.812232]        [<ffffffffa0186fe3>] i915_gem_init+0xf3/0x130 [i915]
    [   82.812278]        [<ffffffffa02097ed>] i915_driver_load+0xf2d/0x1770 [i915]
    [   82.812318]        [<ffffffff81512474>] drm_dev_register+0xa4/0xb0
    [   82.812323]        [<ffffffff8151467e>] drm_get_pci_dev+0xce/0x1e0
    [   82.812328]        [<ffffffffa01472cf>] i915_pci_probe+0x2f/0x50 [i915]
    [   82.812360]        [<ffffffff8143f907>] pci_device_probe+0x87/0xf0
    [   82.812366]        [<ffffffff81535f89>] driver_probe_device+0x229/0x450
    [   82.812371]        [<ffffffff81536233>] __driver_attach+0x83/0x90
    [   82.812375]        [<ffffffff81533c61>] bus_for_each_dev+0x61/0xa0
    [   82.812380]        [<ffffffff81535879>] driver_attach+0x19/0x20
    [   82.812384]        [<ffffffff8153535f>] bus_add_driver+0x1ef/0x290
    [   82.812388]        [<ffffffff81536e9b>] driver_register+0x5b/0xe0
    [   82.812393]        [<ffffffff8143e83b>] __pci_register_driver+0x5b/0x60
    [   82.812398]        [<ffffffff81514866>] drm_pci_init+0xd6/0x100
    [   82.812402]        [<ffffffffa027c094>] 0xffffffffa027c094
    [   82.812406]        [<ffffffff810003de>] do_one_initcall+0xae/0x1d0
    [   82.812412]        [<ffffffff811595a0>] do_init_module+0x5b/0x1cb
    [   82.812417]        [<ffffffff81106160>] load_module+0x1c20/0x2480
    [   82.812422]        [<ffffffff81106bae>] SyS_finit_module+0x7e/0xa0
    [   82.812428]        [<ffffffff817bb81b>] entry_SYSCALL_64_fastpath+0x16/0x73
    [   82.812433]
    -> #0 (&dev->struct_mutex){+.+.+.}:
    [   82.812439]        [<ffffffff810cbe59>] __lock_acquire+0x1fc9/0x20f0
    [   82.812443]        [<ffffffff810cc883>] lock_acquire+0xc3/0x1d0
    [   82.812456]        [<ffffffff8150d9e7>] drm_gem_mmap+0x1c7/0x270
    [   82.812460]        [<ffffffff81196a14>] mmap_region+0x334/0x580
    [   82.812466]        [<ffffffff81196fc4>] do_mmap+0x364/0x410
    [   82.812470]        [<ffffffff8117b38d>] vm_mmap_pgoff+0x6d/0xa0
    [   82.812474]        [<ffffffff811950f4>] SyS_mmap_pgoff+0x184/0x220
    [   82.812479]        [<ffffffff8100a0fd>] SyS_mmap+0x1d/0x20
    [   82.812484]        [<ffffffff817bb81b>] entry_SYSCALL_64_fastpath+0x16/0x73
    [   82.812489]
    other info that might help us debug this:
    
    [   82.812493] Chain exists of:
      &dev->struct_mutex --> s_active#6 --> &mm->mmap_sem
    
    [   82.812502]  Possible unsafe locking scenario:
    
    [   82.812506]        CPU0                    CPU1
    [   82.812508]        ----                    ----
    [   82.812510]   lock(&mm->mmap_sem);
    [   82.812514]                                lock(s_active#6);
    [   82.812519]                                lock(&mm->mmap_sem);
    [   82.812522]   lock(&dev->struct_mutex);
    [   82.812526]
     *** DEADLOCK ***
    
    [   82.812531] 1 lock held by kms_setmode/5859:
    [   82.812533]  #0:  (&mm->mmap_sem){++++++}, at: [<ffffffff8117b364>] vm_mmap_pgoff+0x44/0xa0
    [   82.812541]
    stack backtrace:
    [   82.812547] CPU: 0 PID: 5859 Comm: kms_setmode Not tainted 4.5.0-rc4-gfxbench+ #1
    [   82.812550] Hardware name:                  /NUC5CPYB, BIOS PYBSWCEL.86A.0040.2015.0814.1353 08/14/2015
    [   82.812553]  0000000000000000 ffff880079407bf0 ffffffff813f8505 ffffffff825fb270
    [   82.812560]  ffffffff825c4190 ffff880079407c30 ffffffff810c84ac ffff880079407c90
    [   82.812566]  ffff8800797ed328 ffff8800797ecb00 0000000000000001 ffff8800797ed350
    [   82.812573] Call Trace:
    [   82.812578]  [<ffffffff813f8505>] dump_stack+0x67/0x92
    [   82.812582]  [<ffffffff810c84ac>] print_circular_bug+0x1fc/0x310
    [   82.812586]  [<ffffffff810cbe59>] __lock_acquire+0x1fc9/0x20f0
    [   82.812590]  [<ffffffff810cc883>] lock_acquire+0xc3/0x1d0
    [   82.812594]  [<ffffffff8150d9c1>] ? drm_gem_mmap+0x1a1/0x270
    [   82.812599]  [<ffffffff8150d9e7>] drm_gem_mmap+0x1c7/0x270
    [   82.812603]  [<ffffffff8150d9c1>] ? drm_gem_mmap+0x1a1/0x270
    [   82.812608]  [<ffffffff81196a14>] mmap_region+0x334/0x580
    [   82.812612]  [<ffffffff81196fc4>] do_mmap+0x364/0x410
    [   82.812616]  [<ffffffff8117b38d>] vm_mmap_pgoff+0x6d/0xa0
    [   82.812629]  [<ffffffff811950f4>] SyS_mmap_pgoff+0x184/0x220
    [   82.812633]  [<ffffffff8100a0fd>] SyS_mmap+0x1d/0x20
    [   82.812637]  [<ffffffff817bb81b>] entry_SYSCALL_64_fastpath+0x16/0x73
    
    Highly unlikely though this scenario is, we can avoid the issue entirely
    by moving the copy operation from out under the kernfs_get_active()
    tracking by assigning the preallocated buffer its own mutex. The
    temporary buffer allocation doesn't require mutex locking as it is
    entirely local.
    
    The locked section was extended by the addition of the preallocated buf
    to speed up md user operations in
    
    commit 2b75869bba676c248d8d25ae6d2bd9221dfffdb6
    Author: NeilBrown <neilb@suse.de>
    Date:   Mon Oct 13 16:41:28 2014 +1100
    
        sysfs/kernfs: allow attributes to request write buffer be pre-allocated.
    
    Reported-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=94350
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: NeilBrown <neilb@suse.de>
    Acked-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 372a12ed9d99c02f105278a9b75f0cb176d15cc1
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Fri Apr 8 13:40:53 2016 +0200

    PM / Runtime: Move ignore_children flag under CONFIG_PM
    
    The ignore_children flag is used only when CONFIG_PM is set, so let's move
    it into that section within the struct dev_pm_info.
    
    Move also the corresponding pm_suspend_ignore_children() API out of
    device.h into pm_runtime.h, to be consistent with similar APIs.
    
    Unfortunate this causes the Toshiba PCI SD mmc host driver to fail to
    compile as it needs pm_runtime.h, so let's fix this here as well.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 04f59143b571161d25315dd52d7a2ecc022cb71a
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Apr 12 09:57:35 2016 +0200

    i2c: let I2C masters ignore their children for PM
    
    When using a certain I2C device with runtime PM enabled on
    a certain I2C bus adaper the following happens:
    
    struct amba_device *foo
       \
       struct i2c_adapter *bar
          \
          struct i2c_client *baz
    
    The AMBA device foo has its device PM struct set to ignore
    children with pm_suspend_ignore_children(&foo->dev, true).
    This makes runtime PM work just fine locally in the driver:
    the fact that devices on the bus are suspended or resumed
    individually does not affect its operation, and the hardware
    does not power up unless transferring messages.
    
    However this child ignorance property is not inherited into
    the struct i2c_adapter *bar.
    
    On system suspend things will work fine.
    
    On system resume the following annoying phenomenon occurs:
    
    - In the pm_runtime_force_resume() path of
      struct i2c_client *baz, pm_runtime_set_active(&baz->dev); is
      eventually called.
    
    - This becomes __pm_runtime_set_status(&baz->dev, RPM_ACTIVE);
    
    - __pm_runtime_set_status() detects that RPM state is changed,
      and checks whether the parent is:
      not active (RPM_ACTIVE) and not ignoring its children
      If this happens it concludes something is wrong, because
      a parent that is not ignoring its children must be active
      before any children activate.
    
    - Since the struct i2c_adapter *bar does not ignore
      its children, the PM core thinks that it must indeed go
      online before its children, the check bails out with
      -EBUSY, i.e. the i2c_client *baz thinks it can't work
      because it's parent is not online, and it respects its
      parent.
    
    - In the driver the .resume() callback returns -EBUSY from
      the runtime_force_resume() call as per above. This leaves
      the device in a suspended state, leading to bad behaviour
      later when the device is used. The following debug
      print is made with an extra printg patch but illustrates
      the problem:
    
    [   17.040832] bh1780 2-0029: parent (i2c-2) is not active
                   parent->power.ignore_children = 0
    [   17.040832] bh1780 2-0029: pm_runtime_force_resume:
                   pm_runtime_set_active() failed (-16)
    [   17.040863] dpm_run_callback():
                   pm_runtime_force_resume+0x0/0x88 returns -16
    [   17.040863] PM: Device 2-0029 failed to resume: error -16
    
    Fix this by letting all struct i2c_adapter:s ignore their
    children: i2c children have no business doing keeping
    their parents awake: they are completely autonomous
    devices that just use their parent to talk, a usecase
    which must be power managed in the host on a per-message
    basis.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

commit 4cd4ebbdf533ed316ce377b66ae508cc6d1d0162
Author: Lukas Wunner <lukas@wunner.de>
Date:   Wed Mar 23 00:11:20 2016 +0100

    PM / sleep: Clear pm_suspend_global_flags upon hibernate
    
    commit 276142730c39c9839465a36a90e5674a8c34e839 upstream.
    
    When suspending to RAM, waking up and later suspending to disk,
    we gratuitously runtime resume devices after the thaw phase.
    This does not occur if we always suspend to RAM or always to disk.
    
    pm_complete_with_resume_check(), which gets called from
    pci_pm_complete() among others, schedules a runtime resume
    if PM_SUSPEND_FLAG_FW_RESUME is set. The flag is set during
    a suspend-to-RAM cycle. It is cleared at the beginning of
    the suspend-to-RAM cycle but not afterwards and it is not
    cleared during a suspend-to-disk cycle at all. Fix it.
    
    Fixes: ef25ba047601 (PM / sleep: Add flags to indicate platform firmware involvement)
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit ab8a436573282b96a22bb2fd20bb91b1f544b724
Author: Lukas Wunner <lukas@wunner.de>
Date:   Wed Mar 23 00:11:20 2016 +0100

    PM / sleep: Clear pm_suspend_global_flags upon hibernate
    
    commit 276142730c39c9839465a36a90e5674a8c34e839 upstream.
    
    When suspending to RAM, waking up and later suspending to disk,
    we gratuitously runtime resume devices after the thaw phase.
    This does not occur if we always suspend to RAM or always to disk.
    
    pm_complete_with_resume_check(), which gets called from
    pci_pm_complete() among others, schedules a runtime resume
    if PM_SUSPEND_FLAG_FW_RESUME is set. The flag is set during
    a suspend-to-RAM cycle. It is cleared at the beginning of
    the suspend-to-RAM cycle but not afterwards and it is not
    cleared during a suspend-to-disk cycle at all. Fix it.
    
    Fixes: ef25ba047601 (PM / sleep: Add flags to indicate platform firmware involvement)
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit c20c8f750d9f8f8617f07ee2352d3ff560e66bc2
Author: Suman Anna <s-anna@ti.com>
Date:   Sun Apr 10 13:20:11 2016 -0600

    ARM: OMAP2+: hwmod: fix _idle() hwmod state sanity check sequence
    
    The omap_hwmod _enable() function can return success without setting
    the hwmod state to _HWMOD_STATE_ENABLED for IPs with reset lines when
    all of the reset lines are asserted. The omap_hwmod _idle() function
    also performs a similar check, but after checking for the hwmod state
    first. This triggers the WARN when pm_runtime_get and pm_runtime_put
    are invoked on IPs with all reset lines asserted. Reverse the checks
    for hwmod state and reset lines status to fix this.
    
    Issue found during a unbind operation on a device with reset lines
    still asserted, example backtrace below
    
     ------------[ cut here ]------------
     WARNING: CPU: 1 PID: 879 at arch/arm/mach-omap2/omap_hwmod.c:2207 _idle+0x1e4/0x240()
     omap_hwmod: mmu_dsp: idle state can only be entered from enabled state
     Modules linked in:
     CPU: 1 PID: 879 Comm: sh Not tainted 4.4.0-00008-ga989d951331a #3
     Hardware name: Generic OMAP5 (Flattened Device Tree)
     [<c0018e60>] (unwind_backtrace) from [<c0014dc4>] (show_stack+0x10/0x14)
     [<c0014dc4>] (show_stack) from [<c037ac28>] (dump_stack+0x90/0xc0)
     [<c037ac28>] (dump_stack) from [<c003f420>] (warn_slowpath_common+0x78/0xb4)
     [<c003f420>] (warn_slowpath_common) from [<c003f48c>] (warn_slowpath_fmt+0x30/0x40)
     [<c003f48c>] (warn_slowpath_fmt) from [<c0028c20>] (_idle+0x1e4/0x240)
     [<c0028c20>] (_idle) from [<c0029080>] (omap_hwmod_idle+0x28/0x48)
     [<c0029080>] (omap_hwmod_idle) from [<c002a5a4>] (omap_device_idle+0x3c/0x90)
     [<c002a5a4>] (omap_device_idle) from [<c0427a90>] (__rpm_callback+0x2c/0x60)
     [<c0427a90>] (__rpm_callback) from [<c0427ae4>] (rpm_callback+0x20/0x80)
     [<c0427ae4>] (rpm_callback) from [<c0427f84>] (rpm_suspend+0x138/0x74c)
     [<c0427f84>] (rpm_suspend) from [<c0428b78>] (__pm_runtime_idle+0x78/0xa8)
     [<c0428b78>] (__pm_runtime_idle) from [<c041f514>] (__device_release_driver+0x64/0x100)
     [<c041f514>] (__device_release_driver) from [<c041f5d0>] (device_release_driver+0x20/0x2c)
     [<c041f5d0>] (device_release_driver) from [<c041d85c>] (unbind_store+0x78/0xf8)
     [<c041d85c>] (unbind_store) from [<c0206df8>] (kernfs_fop_write+0xc0/0x1c4)
     [<c0206df8>] (kernfs_fop_write) from [<c018a120>] (__vfs_write+0x20/0xdc)
     [<c018a120>] (__vfs_write) from [<c018a9cc>] (vfs_write+0x90/0x164)
     [<c018a9cc>] (vfs_write) from [<c018b1f0>] (SyS_write+0x44/0x9c)
     [<c018b1f0>] (SyS_write) from [<c0010420>] (ret_fast_syscall+0x0/0x1c)
     ---[ end trace a4182013c75a9f50 ]---
    
    While at this, fix the sequence in _shutdown() as well, though there
    is no easy reproducible scenario.
    
    Fixes: 747834ab8347 ("ARM: OMAP2+: hwmod: revise hardreset behavior")
    Signed-off-by: Suman Anna <s-anna@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

commit c783e6fd7fe4d34f0231d0d8da36497404aa6d93
Author: Nishanth Menon <nm@ti.com>
Date:   Fri Apr 1 17:53:05 2016 -0500

    ARM: OMAP: DRA7: wakeupgen: Skip SAR save for wakeupgen
    
    DRA7 has no SAR region for automated save and restore of wakeupgen,
    which does not make real since the SoC really does not do legacy OFF
    mode anymore. Further wakeupgen should never loose context in CSWR
    retention mode for MPU domain on DRA7 since that is the deepest state
    we will enter.
    
    So, just skip, instead of oopsing as follows while attemptint to enter
    suspend on BeagleBoard-X15.
    [   55.589771] Unable to handle kernel paging request at virtual address 00002684
    [   55.589771] pgd = ec69c000
    [...]
    [   55.589771] [<c0123cc8>] (irq_notifier) from [<c015ad70>] (notifier_call_chain+0x4c/0x8c)
    [   55.589771] [<c015ad70>] (notifier_call_chain) from [<c021469c>] (cpu_cluster_pm_enter+0x2c/0x78)
    [   55.589771] [<c021469c>] (cpu_cluster_pm_enter) from [<c0514508>] (syscore_suspend+0xb8/0x31c)
    [   55.589771] [<c0514508>] (syscore_suspend) from [<c0197d24>] (suspend_devices_and_enter+0x308/0x9e4)
    [   55.589771] [<c0197d24>] (suspend_devices_and_enter) from [<c0198a40>] (pm_suspend+0x640/0x75c)
    [   55.589771] [<c0198a40>] (pm_suspend) from [<c0196bcc>] (state_store+0x64/0xb8)
    [   55.589771] [<c0196bcc>] (state_store) from [<c0307914>] (kernfs_fop_write+0xc0/0x1bc)
    [   55.589771] [<c0307914>] (kernfs_fop_write) from [<c028ac80>] (__vfs_write+0x1c/0xd8)
    [   55.589771] [<c028ac80>] (__vfs_write) from [<c028bb70>] (vfs_write+0x90/0x16c)
    [   55.589771] [<c028bb70>] (vfs_write) from [<c028c890>] (SyS_write+0x44/0x9c)
    [   55.589771] [<c028c890>] (SyS_write) from [<c0107840>] (ret_fast_syscall+0x0/0x1c)
    [...]
    
    Signed-off-by: Nishanth Menon <nm@ti.com>
    Tested-by: Keerthy <j-keerthy@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

commit f75587b8ca69768c6cf8a38a0b61e68e1bea3d36
Author: Nishanth Menon <nm@ti.com>
Date:   Fri Apr 1 08:52:47 2016 -0500

    extcon: palmas: Drop stray IRQF_EARLY_RESUME flag
    
    Palmas extcon IRQs are nested threaded and wired to the Palmas
    interrupt controller. So, this flag is not required for nested
    IRQs anymore, since commit 3c646f2c6aa9 ("genirq: Don't suspend
    nested_thread irqs over system suspend") was merged. However, the
    fix in commit ae64e42cc2b3 ("extcon: palmas: Drop IRQF_EARLY_RESUME
    flag") missed a stray flag causing the following crash on resume on
    BeagleBoard-X15 platform:
    
    [   53.670141] Unhandled fault: imprecise external abort (0x1406) at 0x00000000
    [..]
    [   53.670141] [<c04ae734>] (omap_set_gpio_triggering) from [<c04aeb94>] (omap_gpio_unmask_irq+0xc0/0xc4)
    [   53.670141] [<c04aeb94>] (omap_gpio_unmask_irq) from [<c01a0b88>] (irq_enable+0x30/0x44)
    [   53.670141] [<c01a0b88>] (irq_enable) from [<c019ebd8>] (__enable_irq+0x54/0x78)
    [   53.670141] [<c019ebd8>] (__enable_irq) from [<c01a4e60>] (resume_irqs+0xe8/0x100)
    [   53.670141] [<c01a4e60>] (resume_irqs) from [<c0514840>] (syscore_resume+0x94/0x298)
    [   53.670141] [<c0514840>] (syscore_resume) from [<c01981cc>] (suspend_devices_and_enter+0x790/0x9e4)
    [   53.670141] [<c01981cc>] (suspend_devices_and_enter) from [<c0198a60>] (pm_suspend+0x640/0x75c)
    [   53.670141] [<c0198a60>] (pm_suspend) from [<c0196bec>] (state_store+0x64/0xb8)
    [   53.670141] [<c0196bec>] (state_store) from [<c0307944>] (kernfs_fop_write+0xc0/0x1bc)
    [   53.670141] [<c0307944>] (kernfs_fop_write) from [<c028acb0>] (__vfs_write+0x1c/0xd8)
    [   53.670141] [<c028acb0>] (__vfs_write) from [<c028bba0>] (vfs_write+0x90/0x16c)
    [   53.670141] [<c028bba0>] (vfs_write) from [<c028c8c0>] (SyS_write+0x44/0x9c)
    [   53.670141] [<c028c8c0>] (SyS_write) from [<c0107840>] (ret_fast_syscall+0x0/0x1c)
    [..]
    
    Fixes: ae64e42cc2b3 ("extcon: palmas: Drop IRQF_EARLY_RESUME flag")
    Cc: Grygorii Strashko <grygorii.strashko@ti.com>
    Cc: MyungJoo Ham <myungjoo.ham@samsung.com>
    Cc: Chanwoo Choi <cw00.choi@samsung.com>
    Cc: Tony Lindgren <tony@atomide.com>
    Cc: Lee Jones <lee.jones@linaro.org>
    Cc: Roger Quadros <rogerq@ti.com>
    
    Reviewed-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Signed-off-by: Nishanth Menon <nm@ti.com>
    Acked-by: Roger Quadros <rogerq@ti.com>
    Signed-off-by: Chanwoo Choi <cw00.choi@samsung.com>

commit 3d66c6ba3f978fa88d62b83ad35e9adc31c8ea9e
Merge: 8407ef468589 ee0140dc8ffc
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Mar 24 22:59:58 2016 -0700

    Merge tag 'pm+acpi-4.6-rc1-2' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull more power management and ACPI updates from Rafael Wysocki:
     "The second batch of power management and ACPI updates for v4.6.
    
      Included are fixups on top of the previous PM/ACPI pull request and
      other material that didn't make into it but still should go into 4.6.
    
      Among other things, there's a fix for an intel_pstate driver issue
      uncovered by recent cpufreq changes, a workaround for a boot hang on
      Skylake-H related to the handling of deep C-states by the platform and
      a PCI/ACPI fix for the handling of IO port resources on non-x86
      architectures plus some new device IDs and similar.
    
      Specifics:
    
       - Fix for an intel_pstate driver issue related to the handling of MSR
         updates uncovered by the recent cpufreq rework (Rafael Wysocki).
    
       - cpufreq core cleanups related to starting governors and frequency
         synchronization during resume from system suspend and a locking fix
         for cpufreq_quick_get() (Rafael Wysocki, Richard Cochran).
    
       - acpi-cpufreq and powernv cpufreq driver updates (Jisheng Zhang,
         Michael Neuling, Richard Cochran, Shilpasri Bhat).
    
       - intel_idle driver update preventing some Skylake-H systems from
         hanging during initialization by disabling deep C-states mishandled
         by the platform in the problematic configurations (Len Brown).
    
       - Intel Xeon Phi Processor x200 support for intel_idle
         (Dasaratharaman Chandramouli).
    
       - cpuidle menu governor updates to make it always honor PM QoS
         latency constraints (and prevent C1 from being used as the fallback
         C-state on x86 when they are set below its exit latency) and to
         restore the previous behavior to fall back to C1 if the next timer
         event is set far enough in the future that was changed in 4.4 which
         led to an energy consumption regression (Rik van Riel, Rafael
         Wysocki).
    
       - New device ID for a future AMD UART controller in the ACPI driver
         for AMD SoCs (Wang Hongcheng).
    
       - Rockchip rk3399 support for the rockchip-io-domain adaptive voltage
         scaling (AVS) driver (David Wu).
    
       - ACPI PCI resources management fix for the handling of IO space
         resources on architectures where the IO space is memory mapped
         (IA64 and ARM64) broken by the introduction of common ACPI
         resources parsing for PCI host bridges in 4.4 (Lorenzo Pieralisi).
    
       - Fix for the ACPI backend of the generic device properties API to
         make it parse non-device (data node only) children of an ACPI
         device correctly (Irina Tirdea).
    
       - Fixes for the handling of global suspend flags (introduced in 4.4)
         during hibernation and resume from it (Lukas Wunner).
    
       - Support for obtaining configuration information from Device Trees
         in the PM clocks framework (Jon Hunter).
    
       - ACPI _DSM helper code and devfreq framework cleanups (Colin Ian
         King, Geert Uytterhoeven)"
    
    * tag 'pm+acpi-4.6-rc1-2' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (23 commits)
      PM / AVS: rockchip-io: add io selectors and supplies for rk3399
      intel_idle: Support for Intel Xeon Phi Processor x200 Product Family
      intel_idle: prevent SKL-H boot failure when C8+C9+C10 enabled
      ACPI / PM: Runtime resume devices when waking from hibernate
      PM / sleep: Clear pm_suspend_global_flags upon hibernate
      cpufreq: governor: Always schedule work on the CPU running update
      cpufreq: Always update current frequency before startig governor
      cpufreq: Introduce cpufreq_update_current_freq()
      cpufreq: Introduce cpufreq_start_governor()
      cpufreq: powernv: Add sysfs attributes to show throttle stats
      cpufreq: acpi-cpufreq: make Intel/AMD MSR access, io port access static
      PCI: ACPI: IA64: fix IO port generic range check
      ACPI / util: cast data to u64 before shifting to fix sign extension
      cpufreq: powernv: Define per_cpu chip pointer to optimize hot-path
      cpuidle: menu: Fall back to polling if next timer event is near
      cpufreq: acpi-cpufreq: Clean up hot plug notifier callback
      intel_pstate: Do not call wrmsrl_on_cpu() with disabled interrupts
      cpufreq: Make cpufreq_quick_get() safe to call
      ACPI / property: fix data node parsing in acpi_get_next_subnode()
      ACPI / APD: Add device HID for future AMD UART controller
      ...

commit 3513ac743df4a8522270bde4a20d75a42874487e
Merge: 33068b61f8c0 f447671b9e4f 02113ba93ea4 027b6934aaa3 fbda4b38fa39
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Mar 25 00:58:18 2016 +0100

    Merge branches 'pm-avs', 'pm-clk', 'pm-devfreq' and 'pm-sleep'
    
    * pm-avs:
      PM / AVS: rockchip-io: add io selectors and supplies for rk3399
    
    * pm-clk:
      PM / clk: Add support for obtaining clocks from device-tree
    
    * pm-devfreq:
      PM / devfreq: Spelling s/frequnecy/frequency/
    
    * pm-sleep:
      ACPI / PM: Runtime resume devices when waking from hibernate
      PM / sleep: Clear pm_suspend_global_flags upon hibernate

commit 2e33adc8018bc86c9c3f8fe6c7c494f15c2d6caf
Author: Peter Chen <peter.chen@nxp.com>
Date:   Wed Feb 24 11:05:25 2016 +0800

    usb: chipidea: otg: change workqueue ci_otg as freezable
    
    commit d144dfea8af7108f613139623e63952ed7e69c0c upstream.
    
    If we use USB ID pin as wakeup source, and there is a USB block
    device on this USB OTG (ID) cable, the system will be deadlock
    after system resume.
    
    The root cause for this problem is: the workqueue ci_otg may try
    to remove hcd before the driver resume has finished, and hcd will
    disconnect the device on it, then, it will call device_release_driver,
    and holds the device lock "dev->mutex", but it is never unlocked since
    it waits workqueue writeback to run to flush the block information, but
    the workqueue writeback is freezable, it is not thawed before driver
    resume has finished.
    
    When the driver (device: sd 0:0:0:0:) resume goes to dpm_complete, it
    tries to get its device lock "dev->mutex", but it can't get it forever,
    then the deadlock occurs. Below call stacks show the situation.
    
    So, in order to fix this problem, we need to change workqueue ci_otg
    as freezable, then the work item in this workqueue will be run after
    driver's resume, this workqueue will not be blocked forever like above
    case since the workqueue writeback has been thawed too.
    
    Tested at: i.mx6qdl-sabresd and i.mx6sx-sdb.
    
    [  555.178869] kworker/u2:13   D c07de74c     0   826      2 0x00000000
    [  555.185310] Workqueue: ci_otg ci_otg_work
    [  555.189353] Backtrace:
    [  555.191849] [<c07de4fc>] (__schedule) from [<c07dec6c>] (schedule+0x48/0xa0)
    [  555.198912]  r10:ee471ba0 r9:00000000 r8:00000000 r7:00000002 r6:ee470000 r5:ee471ba4
    [  555.206867]  r4:ee470000
    [  555.209453] [<c07dec24>] (schedule) from [<c07e2fc4>] (schedule_timeout+0x15c/0x1e0)
    [  555.217212]  r4:7fffffff r3:edc2b000
    [  555.220862] [<c07e2e68>] (schedule_timeout) from [<c07df6c8>] (wait_for_common+0x94/0x144)
    [  555.229140]  r8:00000000 r7:00000002 r6:ee470000 r5:ee471ba4 r4:7fffffff
    [  555.235980] [<c07df634>] (wait_for_common) from [<c07df790>] (wait_for_completion+0x18/0x1c)
    [  555.244430]  r10:00000001 r9:c0b5563c r8:c0042e48 r7:ef086000 r6:eea4372c r5:ef131b00
    [  555.252383]  r4:00000000
    [  555.254970] [<c07df778>] (wait_for_completion) from [<c0043cb8>] (flush_work+0x19c/0x234)
    [  555.263177] [<c0043b1c>] (flush_work) from [<c0043fac>] (flush_delayed_work+0x48/0x4c)
    [  555.271106]  r8:ed5b5000 r7:c0b38a3c r6:eea439cc r5:eea4372c r4:eea4372c
    [  555.277958] [<c0043f64>] (flush_delayed_work) from [<c00eae18>] (bdi_unregister+0x84/0xec)
    [  555.286236]  r4:eea43520 r3:20000153
    [  555.289885] [<c00ead94>] (bdi_unregister) from [<c02c2154>] (blk_cleanup_queue+0x180/0x29c)
    [  555.298250]  r5:eea43808 r4:eea43400
    [  555.301909] [<c02c1fd4>] (blk_cleanup_queue) from [<c0417914>] (__scsi_remove_device+0x48/0xb8)
    [  555.310623]  r7:00000000 r6:20000153 r5:ededa950 r4:ededa800
    [  555.316403] [<c04178cc>] (__scsi_remove_device) from [<c0415e90>] (scsi_forget_host+0x64/0x68)
    [  555.325028]  r5:ededa800 r4:ed5b5000
    [  555.328689] [<c0415e2c>] (scsi_forget_host) from [<c0409828>] (scsi_remove_host+0x78/0x104)
    [  555.337054]  r5:ed5b5068 r4:ed5b5000
    [  555.340709] [<c04097b0>] (scsi_remove_host) from [<c04cdfcc>] (usb_stor_disconnect+0x50/0xb4)
    [  555.349247]  r6:ed5b56e4 r5:ed5b5818 r4:ed5b5690 r3:00000008
    [  555.355025] [<c04cdf7c>] (usb_stor_disconnect) from [<c04b3bc8>] (usb_unbind_interface+0x78/0x25c)
    [  555.363997]  r8:c13919b4 r7:edd3c000 r6:edd3c020 r5:ee551c68 r4:ee551c00 r3:c04cdf7c
    [  555.371892] [<c04b3b50>] (usb_unbind_interface) from [<c03dc248>] (__device_release_driver+0x8c/0x118)
    [  555.381213]  r10:00000001 r9:edd90c00 r8:c13919b4 r7:ee551c68 r6:c0b546e0 r5:c0b5563c
    [  555.389167]  r4:edd3c020
    [  555.391752] [<c03dc1bc>] (__device_release_driver) from [<c03dc2fc>] (device_release_driver+0x28/0x34)
    [  555.401071]  r5:edd3c020 r4:edd3c054
    [  555.404721] [<c03dc2d4>] (device_release_driver) from [<c03db304>] (bus_remove_device+0xe0/0x110)
    [  555.413607]  r5:edd3c020 r4:ef17f04c
    [  555.417253] [<c03db224>] (bus_remove_device) from [<c03d8128>] (device_del+0x114/0x21c)
    [  555.425270]  r6:edd3c028 r5:edd3c020 r4:ee551c00 r3:00000000
    [  555.431045] [<c03d8014>] (device_del) from [<c04b1560>] (usb_disable_device+0xa4/0x1e8)
    [  555.439061]  r8:edd3c000 r7:eded8000 r6:00000000 r5:00000001 r4:ee551c00
    [  555.445906] [<c04b14bc>] (usb_disable_device) from [<c04a8e54>] (usb_disconnect+0x74/0x224)
    [  555.454271]  r9:edd90c00 r8:ee551000 r7:ee551c68 r6:ee551c9c r5:ee551c00 r4:00000001
    [  555.462156] [<c04a8de0>] (usb_disconnect) from [<c04a8fb8>] (usb_disconnect+0x1d8/0x224)
    [  555.470259]  r10:00000001 r9:edd90000 r8:ee471e2c r7:ee551468 r6:ee55149c r5:ee551400
    [  555.478213]  r4:00000001
    [  555.480797] [<c04a8de0>] (usb_disconnect) from [<c04ae5ec>] (usb_remove_hcd+0xa0/0x1ac)
    [  555.488813]  r10:00000001 r9:ee471eb0 r8:00000000 r7:ef3d9500 r6:eded810c r5:eded80b0
    [  555.496765]  r4:eded8000
    [  555.499351] [<c04ae54c>] (usb_remove_hcd) from [<c04d4158>] (host_stop+0x28/0x64)
    [  555.506847]  r6:eeb50010 r5:eded8000 r4:eeb51010
    [  555.511563] [<c04d4130>] (host_stop) from [<c04d09b8>] (ci_otg_work+0xc4/0x124)
    [  555.518885]  r6:00000001 r5:eeb50010 r4:eeb502a0 r3:c04d4130
    [  555.524665] [<c04d08f4>] (ci_otg_work) from [<c00454f0>] (process_one_work+0x194/0x420)
    [  555.532682]  r6:ef086000 r5:eeb502a0 r4:edc44480
    [  555.537393] [<c004535c>] (process_one_work) from [<c00457b0>] (worker_thread+0x34/0x514)
    [  555.545496]  r10:edc44480 r9:ef086000 r8:c0b1a100 r7:ef086034 r6:00000088 r5:edc44498
    [  555.553450]  r4:ef086000
    [  555.556032] [<c004577c>] (worker_thread) from [<c004bab4>] (kthread+0xdc/0xf8)
    [  555.563268]  r10:00000000 r9:00000000 r8:00000000 r7:c004577c r6:edc44480 r5:eddc15c0
    [  555.571221]  r4:00000000
    [  555.573804] [<c004b9d8>] (kthread) from [<c000fef0>] (ret_from_fork+0x14/0x24)
    [  555.581040]  r7:00000000 r6:00000000 r5:c004b9d8 r4:eddc15c0
    
    [  553.429383] sh              D c07de74c     0   694    691 0x00000000
    [  553.435801] Backtrace:
    [  553.438295] [<c07de4fc>] (__schedule) from [<c07dec6c>] (schedule+0x48/0xa0)
    [  553.445358]  r10:edd3c054 r9:edd3c078 r8:edddbd50 r7:edcbbc00 r6:c1377c34 r5:60000153
    [  553.453313]  r4:eddda000
    [  553.455896] [<c07dec24>] (schedule) from [<c07deff8>] (schedule_preempt_disabled+0x10/0x14)
    [  553.464261]  r4:edd3c058 r3:0000000a
    [  553.467910] [<c07defe8>] (schedule_preempt_disabled) from [<c07e0bbc>] (mutex_lock_nested+0x1a0/0x3e8)
    [  553.477254] [<c07e0a1c>] (mutex_lock_nested) from [<c03e927c>] (dpm_complete+0xc0/0x1b0)
    [  553.485358]  r10:00561408 r9:edd3c054 r8:c0b4863c r7:edddbd90 r6:c0b485d8 r5:edd3c020
    [  553.493313]  r4:edd3c0d0
    [  553.495896] [<c03e91bc>] (dpm_complete) from [<c03e9388>] (dpm_resume_end+0x1c/0x20)
    [  553.503652]  r9:00000000 r8:c0b1a9d0 r7:c1334ec0 r6:c1334edc r5:00000003 r4:00000010
    [  553.511544] [<c03e936c>] (dpm_resume_end) from [<c0079894>] (suspend_devices_and_enter+0x158/0x504)
    [  553.520604]  r4:00000000 r3:c1334efc
    [  553.524250] [<c007973c>] (suspend_devices_and_enter) from [<c0079e74>] (pm_suspend+0x234/0x2cc)
    [  553.532961]  r10:00561408 r9:ed6b7300 r8:00000004 r7:c1334eec r6:00000000 r5:c1334ee8
    [  553.540914]  r4:00000003
    [  553.543493] [<c0079c40>] (pm_suspend) from [<c0078a6c>] (state_store+0x6c/0xc0)
    
    [  555.703684] 7 locks held by kworker/u2:13/826:
    [  555.708140]  #0:  ("%s""ci_otg"){++++.+}, at: [<c0045484>] process_one_work+0x128/0x420
    [  555.716277]  #1:  ((&ci->work)){+.+.+.}, at: [<c0045484>] process_one_work+0x128/0x420
    [  555.724317]  #2:  (usb_bus_list_lock){+.+.+.}, at: [<c04ae5e4>] usb_remove_hcd+0x98/0x1ac
    [  555.732626]  #3:  (&dev->mutex){......}, at: [<c04a8e28>] usb_disconnect+0x48/0x224
    [  555.740403]  #4:  (&dev->mutex){......}, at: [<c04a8e28>] usb_disconnect+0x48/0x224
    [  555.748179]  #5:  (&dev->mutex){......}, at: [<c03dc2f4>] device_release_driver+0x20/0x34
    [  555.756487]  #6:  (&shost->scan_mutex){+.+.+.}, at: [<c04097d0>] scsi_remove_host+0x20/0x104
    
    Cc: Jun Li <jun.li@nxp.com>
    Signed-off-by: Peter Chen <peter.chen@nxp.com>
    Signed-off-by: Luis Henriques <luis.henriques@canonical.com>

commit 276142730c39c9839465a36a90e5674a8c34e839
Author: Lukas Wunner <lukas@wunner.de>
Date:   Wed Mar 23 00:11:20 2016 +0100

    PM / sleep: Clear pm_suspend_global_flags upon hibernate
    
    When suspending to RAM, waking up and later suspending to disk,
    we gratuitously runtime resume devices after the thaw phase.
    This does not occur if we always suspend to RAM or always to disk.
    
    pm_complete_with_resume_check(), which gets called from
    pci_pm_complete() among others, schedules a runtime resume
    if PM_SUSPEND_FLAG_FW_RESUME is set. The flag is set during
    a suspend-to-RAM cycle. It is cleared at the beginning of
    the suspend-to-RAM cycle but not afterwards and it is not
    cleared during a suspend-to-disk cycle at all. Fix it.
    
    Fixes: ef25ba047601 (PM / sleep: Add flags to indicate platform firmware involvement)
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Cc: 4.4+ <stable@vger.kernel.org> # 4.4+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit e4477a4b702628a939d891b5631769ceb263242f
Author: Peter Chen <peter.chen@nxp.com>
Date:   Wed Feb 24 11:05:25 2016 +0800

    usb: chipidea: otg: change workqueue ci_otg as freezable
    
    [ Upstream commit d144dfea8af7108f613139623e63952ed7e69c0c ]
    
    If we use USB ID pin as wakeup source, and there is a USB block
    device on this USB OTG (ID) cable, the system will be deadlock
    after system resume.
    
    The root cause for this problem is: the workqueue ci_otg may try
    to remove hcd before the driver resume has finished, and hcd will
    disconnect the device on it, then, it will call device_release_driver,
    and holds the device lock "dev->mutex", but it is never unlocked since
    it waits workqueue writeback to run to flush the block information, but
    the workqueue writeback is freezable, it is not thawed before driver
    resume has finished.
    
    When the driver (device: sd 0:0:0:0:) resume goes to dpm_complete, it
    tries to get its device lock "dev->mutex", but it can't get it forever,
    then the deadlock occurs. Below call stacks show the situation.
    
    So, in order to fix this problem, we need to change workqueue ci_otg
    as freezable, then the work item in this workqueue will be run after
    driver's resume, this workqueue will not be blocked forever like above
    case since the workqueue writeback has been thawed too.
    
    Tested at: i.mx6qdl-sabresd and i.mx6sx-sdb.
    
    [  555.178869] kworker/u2:13   D c07de74c     0   826      2 0x00000000
    [  555.185310] Workqueue: ci_otg ci_otg_work
    [  555.189353] Backtrace:
    [  555.191849] [<c07de4fc>] (__schedule) from [<c07dec6c>] (schedule+0x48/0xa0)
    [  555.198912]  r10:ee471ba0 r9:00000000 r8:00000000 r7:00000002 r6:ee470000 r5:ee471ba4
    [  555.206867]  r4:ee470000
    [  555.209453] [<c07dec24>] (schedule) from [<c07e2fc4>] (schedule_timeout+0x15c/0x1e0)
    [  555.217212]  r4:7fffffff r3:edc2b000
    [  555.220862] [<c07e2e68>] (schedule_timeout) from [<c07df6c8>] (wait_for_common+0x94/0x144)
    [  555.229140]  r8:00000000 r7:00000002 r6:ee470000 r5:ee471ba4 r4:7fffffff
    [  555.235980] [<c07df634>] (wait_for_common) from [<c07df790>] (wait_for_completion+0x18/0x1c)
    [  555.244430]  r10:00000001 r9:c0b5563c r8:c0042e48 r7:ef086000 r6:eea4372c r5:ef131b00
    [  555.252383]  r4:00000000
    [  555.254970] [<c07df778>] (wait_for_completion) from [<c0043cb8>] (flush_work+0x19c/0x234)
    [  555.263177] [<c0043b1c>] (flush_work) from [<c0043fac>] (flush_delayed_work+0x48/0x4c)
    [  555.271106]  r8:ed5b5000 r7:c0b38a3c r6:eea439cc r5:eea4372c r4:eea4372c
    [  555.277958] [<c0043f64>] (flush_delayed_work) from [<c00eae18>] (bdi_unregister+0x84/0xec)
    [  555.286236]  r4:eea43520 r3:20000153
    [  555.289885] [<c00ead94>] (bdi_unregister) from [<c02c2154>] (blk_cleanup_queue+0x180/0x29c)
    [  555.298250]  r5:eea43808 r4:eea43400
    [  555.301909] [<c02c1fd4>] (blk_cleanup_queue) from [<c0417914>] (__scsi_remove_device+0x48/0xb8)
    [  555.310623]  r7:00000000 r6:20000153 r5:ededa950 r4:ededa800
    [  555.316403] [<c04178cc>] (__scsi_remove_device) from [<c0415e90>] (scsi_forget_host+0x64/0x68)
    [  555.325028]  r5:ededa800 r4:ed5b5000
    [  555.328689] [<c0415e2c>] (scsi_forget_host) from [<c0409828>] (scsi_remove_host+0x78/0x104)
    [  555.337054]  r5:ed5b5068 r4:ed5b5000
    [  555.340709] [<c04097b0>] (scsi_remove_host) from [<c04cdfcc>] (usb_stor_disconnect+0x50/0xb4)
    [  555.349247]  r6:ed5b56e4 r5:ed5b5818 r4:ed5b5690 r3:00000008
    [  555.355025] [<c04cdf7c>] (usb_stor_disconnect) from [<c04b3bc8>] (usb_unbind_interface+0x78/0x25c)
    [  555.363997]  r8:c13919b4 r7:edd3c000 r6:edd3c020 r5:ee551c68 r4:ee551c00 r3:c04cdf7c
    [  555.371892] [<c04b3b50>] (usb_unbind_interface) from [<c03dc248>] (__device_release_driver+0x8c/0x118)
    [  555.381213]  r10:00000001 r9:edd90c00 r8:c13919b4 r7:ee551c68 r6:c0b546e0 r5:c0b5563c
    [  555.389167]  r4:edd3c020
    [  555.391752] [<c03dc1bc>] (__device_release_driver) from [<c03dc2fc>] (device_release_driver+0x28/0x34)
    [  555.401071]  r5:edd3c020 r4:edd3c054
    [  555.404721] [<c03dc2d4>] (device_release_driver) from [<c03db304>] (bus_remove_device+0xe0/0x110)
    [  555.413607]  r5:edd3c020 r4:ef17f04c
    [  555.417253] [<c03db224>] (bus_remove_device) from [<c03d8128>] (device_del+0x114/0x21c)
    [  555.425270]  r6:edd3c028 r5:edd3c020 r4:ee551c00 r3:00000000
    [  555.431045] [<c03d8014>] (device_del) from [<c04b1560>] (usb_disable_device+0xa4/0x1e8)
    [  555.439061]  r8:edd3c000 r7:eded8000 r6:00000000 r5:00000001 r4:ee551c00
    [  555.445906] [<c04b14bc>] (usb_disable_device) from [<c04a8e54>] (usb_disconnect+0x74/0x224)
    [  555.454271]  r9:edd90c00 r8:ee551000 r7:ee551c68 r6:ee551c9c r5:ee551c00 r4:00000001
    [  555.462156] [<c04a8de0>] (usb_disconnect) from [<c04a8fb8>] (usb_disconnect+0x1d8/0x224)
    [  555.470259]  r10:00000001 r9:edd90000 r8:ee471e2c r7:ee551468 r6:ee55149c r5:ee551400
    [  555.478213]  r4:00000001
    [  555.480797] [<c04a8de0>] (usb_disconnect) from [<c04ae5ec>] (usb_remove_hcd+0xa0/0x1ac)
    [  555.488813]  r10:00000001 r9:ee471eb0 r8:00000000 r7:ef3d9500 r6:eded810c r5:eded80b0
    [  555.496765]  r4:eded8000
    [  555.499351] [<c04ae54c>] (usb_remove_hcd) from [<c04d4158>] (host_stop+0x28/0x64)
    [  555.506847]  r6:eeb50010 r5:eded8000 r4:eeb51010
    [  555.511563] [<c04d4130>] (host_stop) from [<c04d09b8>] (ci_otg_work+0xc4/0x124)
    [  555.518885]  r6:00000001 r5:eeb50010 r4:eeb502a0 r3:c04d4130
    [  555.524665] [<c04d08f4>] (ci_otg_work) from [<c00454f0>] (process_one_work+0x194/0x420)
    [  555.532682]  r6:ef086000 r5:eeb502a0 r4:edc44480
    [  555.537393] [<c004535c>] (process_one_work) from [<c00457b0>] (worker_thread+0x34/0x514)
    [  555.545496]  r10:edc44480 r9:ef086000 r8:c0b1a100 r7:ef086034 r6:00000088 r5:edc44498
    [  555.553450]  r4:ef086000
    [  555.556032] [<c004577c>] (worker_thread) from [<c004bab4>] (kthread+0xdc/0xf8)
    [  555.563268]  r10:00000000 r9:00000000 r8:00000000 r7:c004577c r6:edc44480 r5:eddc15c0
    [  555.571221]  r4:00000000
    [  555.573804] [<c004b9d8>] (kthread) from [<c000fef0>] (ret_from_fork+0x14/0x24)
    [  555.581040]  r7:00000000 r6:00000000 r5:c004b9d8 r4:eddc15c0
    
    [  553.429383] sh              D c07de74c     0   694    691 0x00000000
    [  553.435801] Backtrace:
    [  553.438295] [<c07de4fc>] (__schedule) from [<c07dec6c>] (schedule+0x48/0xa0)
    [  553.445358]  r10:edd3c054 r9:edd3c078 r8:edddbd50 r7:edcbbc00 r6:c1377c34 r5:60000153
    [  553.453313]  r4:eddda000
    [  553.455896] [<c07dec24>] (schedule) from [<c07deff8>] (schedule_preempt_disabled+0x10/0x14)
    [  553.464261]  r4:edd3c058 r3:0000000a
    [  553.467910] [<c07defe8>] (schedule_preempt_disabled) from [<c07e0bbc>] (mutex_lock_nested+0x1a0/0x3e8)
    [  553.477254] [<c07e0a1c>] (mutex_lock_nested) from [<c03e927c>] (dpm_complete+0xc0/0x1b0)
    [  553.485358]  r10:00561408 r9:edd3c054 r8:c0b4863c r7:edddbd90 r6:c0b485d8 r5:edd3c020
    [  553.493313]  r4:edd3c0d0
    [  553.495896] [<c03e91bc>] (dpm_complete) from [<c03e9388>] (dpm_resume_end+0x1c/0x20)
    [  553.503652]  r9:00000000 r8:c0b1a9d0 r7:c1334ec0 r6:c1334edc r5:00000003 r4:00000010
    [  553.511544] [<c03e936c>] (dpm_resume_end) from [<c0079894>] (suspend_devices_and_enter+0x158/0x504)
    [  553.520604]  r4:00000000 r3:c1334efc
    [  553.524250] [<c007973c>] (suspend_devices_and_enter) from [<c0079e74>] (pm_suspend+0x234/0x2cc)
    [  553.532961]  r10:00561408 r9:ed6b7300 r8:00000004 r7:c1334eec r6:00000000 r5:c1334ee8
    [  553.540914]  r4:00000003
    [  553.543493] [<c0079c40>] (pm_suspend) from [<c0078a6c>] (state_store+0x6c/0xc0)
    
    [  555.703684] 7 locks held by kworker/u2:13/826:
    [  555.708140]  #0:  ("%s""ci_otg"){++++.+}, at: [<c0045484>] process_one_work+0x128/0x420
    [  555.716277]  #1:  ((&ci->work)){+.+.+.}, at: [<c0045484>] process_one_work+0x128/0x420
    [  555.724317]  #2:  (usb_bus_list_lock){+.+.+.}, at: [<c04ae5e4>] usb_remove_hcd+0x98/0x1ac
    [  555.732626]  #3:  (&dev->mutex){......}, at: [<c04a8e28>] usb_disconnect+0x48/0x224
    [  555.740403]  #4:  (&dev->mutex){......}, at: [<c04a8e28>] usb_disconnect+0x48/0x224
    [  555.748179]  #5:  (&dev->mutex){......}, at: [<c03dc2f4>] device_release_driver+0x20/0x34
    [  555.756487]  #6:  (&shost->scan_mutex){+.+.+.}, at: [<c04097d0>] scsi_remove_host+0x20/0x104
    
    Cc: <stable@vger.kernel.org> #v3.14+
    Cc: Jun Li <jun.li@nxp.com>
    Signed-off-by: Peter Chen <peter.chen@nxp.com>
    Signed-off-by: Sasha Levin <sasha.levin@oracle.com>

commit 107b87133361aa5502d7d3c82cdfff77bf8ebe18
Author: Hui Wang <hui.wang@canonical.com>
Date:   Wed Mar 9 15:25:26 2016 +0800

    brcmfmac: Remove waitqueue_active check
    
    We met a problem of pm_suspend  when repeated closing/opening the lid
    on a Lenovo laptop (1/20 reproduce rate), below is the log:
    
    [ 199.735876] PM: Entering mem sleep
    [ 199.750516] e1000e: EEE TX LPI TIMER: 00000011
    [ 199.856638] Trying to free nonexistent resource <000000000000d000-000000000000d0ff>
    [ 201.753566] brcmfmac: brcmf_pcie_suspend: Timeout on response for entering D3 substate
    [ 201.753581] pci_legacy_suspend(): brcmf_pcie_suspend+0x0/0x1f0 [brcmfmac] returns -5
    [ 201.753585] dpm_run_callback(): pci_pm_suspend+0x0/0x160 returns -5
    [ 201.753589] PM: Device 0000:04:00.0 failed to suspend async: error -5
    
    Through debugging, we found when problem happens, it is not the device
    fails to enter D3, but the signal D3_ACK comes too early to pass the
    waitqueue_active() check.
    
    Just like this:
    brcmf_pcie_send_mb_data(devinfo, BRCMF_H2D_HOST_D3_INFORM);
    // signal is triggered here
    wait_event_timeout(devinfo->mbdata_resp_wait, devinfo->mbdata_completed,
                       BRCMF_PCIE_MBDATA_TIMEOUT);
    
    So far I think it is safe to remove waitqueue_active check since there
    is only one place to trigger this signal (sending
    BRCMF_H2D_HOST_D3_INFORM). And it is not a problem calling wake_up
    event earlier than calling wait_event.
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Hante Meuleman <meuleman@broadcom.com>
    Cc: Franky (Zhenhui) Lin <frankyl@broadcom.com>
    Cc: Pieter-Paul Giesberts <pieterpg@broadcom.com>
    Cc: Arend van Spriel <arend@broadcom.com>
    Signed-off-by: Hui Wang <hui.wang@canonical.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>

commit 0ba460a5fd15673ad895a8fc51d378eb30f1922b
Author: Peter Chen <peter.chen@nxp.com>
Date:   Wed Feb 24 11:05:25 2016 +0800

    usb: chipidea: otg: change workqueue ci_otg as freezable
    
    commit d144dfea8af7108f613139623e63952ed7e69c0c upstream.
    
    If we use USB ID pin as wakeup source, and there is a USB block
    device on this USB OTG (ID) cable, the system will be deadlock
    after system resume.
    
    The root cause for this problem is: the workqueue ci_otg may try
    to remove hcd before the driver resume has finished, and hcd will
    disconnect the device on it, then, it will call device_release_driver,
    and holds the device lock "dev->mutex", but it is never unlocked since
    it waits workqueue writeback to run to flush the block information, but
    the workqueue writeback is freezable, it is not thawed before driver
    resume has finished.
    
    When the driver (device: sd 0:0:0:0:) resume goes to dpm_complete, it
    tries to get its device lock "dev->mutex", but it can't get it forever,
    then the deadlock occurs. Below call stacks show the situation.
    
    So, in order to fix this problem, we need to change workqueue ci_otg
    as freezable, then the work item in this workqueue will be run after
    driver's resume, this workqueue will not be blocked forever like above
    case since the workqueue writeback has been thawed too.
    
    Tested at: i.mx6qdl-sabresd and i.mx6sx-sdb.
    
    [  555.178869] kworker/u2:13   D c07de74c     0   826      2 0x00000000
    [  555.185310] Workqueue: ci_otg ci_otg_work
    [  555.189353] Backtrace:
    [  555.191849] [<c07de4fc>] (__schedule) from [<c07dec6c>] (schedule+0x48/0xa0)
    [  555.198912]  r10:ee471ba0 r9:00000000 r8:00000000 r7:00000002 r6:ee470000 r5:ee471ba4
    [  555.206867]  r4:ee470000
    [  555.209453] [<c07dec24>] (schedule) from [<c07e2fc4>] (schedule_timeout+0x15c/0x1e0)
    [  555.217212]  r4:7fffffff r3:edc2b000
    [  555.220862] [<c07e2e68>] (schedule_timeout) from [<c07df6c8>] (wait_for_common+0x94/0x144)
    [  555.229140]  r8:00000000 r7:00000002 r6:ee470000 r5:ee471ba4 r4:7fffffff
    [  555.235980] [<c07df634>] (wait_for_common) from [<c07df790>] (wait_for_completion+0x18/0x1c)
    [  555.244430]  r10:00000001 r9:c0b5563c r8:c0042e48 r7:ef086000 r6:eea4372c r5:ef131b00
    [  555.252383]  r4:00000000
    [  555.254970] [<c07df778>] (wait_for_completion) from [<c0043cb8>] (flush_work+0x19c/0x234)
    [  555.263177] [<c0043b1c>] (flush_work) from [<c0043fac>] (flush_delayed_work+0x48/0x4c)
    [  555.271106]  r8:ed5b5000 r7:c0b38a3c r6:eea439cc r5:eea4372c r4:eea4372c
    [  555.277958] [<c0043f64>] (flush_delayed_work) from [<c00eae18>] (bdi_unregister+0x84/0xec)
    [  555.286236]  r4:eea43520 r3:20000153
    [  555.289885] [<c00ead94>] (bdi_unregister) from [<c02c2154>] (blk_cleanup_queue+0x180/0x29c)
    [  555.298250]  r5:eea43808 r4:eea43400
    [  555.301909] [<c02c1fd4>] (blk_cleanup_queue) from [<c0417914>] (__scsi_remove_device+0x48/0xb8)
    [  555.310623]  r7:00000000 r6:20000153 r5:ededa950 r4:ededa800
    [  555.316403] [<c04178cc>] (__scsi_remove_device) from [<c0415e90>] (scsi_forget_host+0x64/0x68)
    [  555.325028]  r5:ededa800 r4:ed5b5000
    [  555.328689] [<c0415e2c>] (scsi_forget_host) from [<c0409828>] (scsi_remove_host+0x78/0x104)
    [  555.337054]  r5:ed5b5068 r4:ed5b5000
    [  555.340709] [<c04097b0>] (scsi_remove_host) from [<c04cdfcc>] (usb_stor_disconnect+0x50/0xb4)
    [  555.349247]  r6:ed5b56e4 r5:ed5b5818 r4:ed5b5690 r3:00000008
    [  555.355025] [<c04cdf7c>] (usb_stor_disconnect) from [<c04b3bc8>] (usb_unbind_interface+0x78/0x25c)
    [  555.363997]  r8:c13919b4 r7:edd3c000 r6:edd3c020 r5:ee551c68 r4:ee551c00 r3:c04cdf7c
    [  555.371892] [<c04b3b50>] (usb_unbind_interface) from [<c03dc248>] (__device_release_driver+0x8c/0x118)
    [  555.381213]  r10:00000001 r9:edd90c00 r8:c13919b4 r7:ee551c68 r6:c0b546e0 r5:c0b5563c
    [  555.389167]  r4:edd3c020
    [  555.391752] [<c03dc1bc>] (__device_release_driver) from [<c03dc2fc>] (device_release_driver+0x28/0x34)
    [  555.401071]  r5:edd3c020 r4:edd3c054
    [  555.404721] [<c03dc2d4>] (device_release_driver) from [<c03db304>] (bus_remove_device+0xe0/0x110)
    [  555.413607]  r5:edd3c020 r4:ef17f04c
    [  555.417253] [<c03db224>] (bus_remove_device) from [<c03d8128>] (device_del+0x114/0x21c)
    [  555.425270]  r6:edd3c028 r5:edd3c020 r4:ee551c00 r3:00000000
    [  555.431045] [<c03d8014>] (device_del) from [<c04b1560>] (usb_disable_device+0xa4/0x1e8)
    [  555.439061]  r8:edd3c000 r7:eded8000 r6:00000000 r5:00000001 r4:ee551c00
    [  555.445906] [<c04b14bc>] (usb_disable_device) from [<c04a8e54>] (usb_disconnect+0x74/0x224)
    [  555.454271]  r9:edd90c00 r8:ee551000 r7:ee551c68 r6:ee551c9c r5:ee551c00 r4:00000001
    [  555.462156] [<c04a8de0>] (usb_disconnect) from [<c04a8fb8>] (usb_disconnect+0x1d8/0x224)
    [  555.470259]  r10:00000001 r9:edd90000 r8:ee471e2c r7:ee551468 r6:ee55149c r5:ee551400
    [  555.478213]  r4:00000001
    [  555.480797] [<c04a8de0>] (usb_disconnect) from [<c04ae5ec>] (usb_remove_hcd+0xa0/0x1ac)
    [  555.488813]  r10:00000001 r9:ee471eb0 r8:00000000 r7:ef3d9500 r6:eded810c r5:eded80b0
    [  555.496765]  r4:eded8000
    [  555.499351] [<c04ae54c>] (usb_remove_hcd) from [<c04d4158>] (host_stop+0x28/0x64)
    [  555.506847]  r6:eeb50010 r5:eded8000 r4:eeb51010
    [  555.511563] [<c04d4130>] (host_stop) from [<c04d09b8>] (ci_otg_work+0xc4/0x124)
    [  555.518885]  r6:00000001 r5:eeb50010 r4:eeb502a0 r3:c04d4130
    [  555.524665] [<c04d08f4>] (ci_otg_work) from [<c00454f0>] (process_one_work+0x194/0x420)
    [  555.532682]  r6:ef086000 r5:eeb502a0 r4:edc44480
    [  555.537393] [<c004535c>] (process_one_work) from [<c00457b0>] (worker_thread+0x34/0x514)
    [  555.545496]  r10:edc44480 r9:ef086000 r8:c0b1a100 r7:ef086034 r6:00000088 r5:edc44498
    [  555.553450]  r4:ef086000
    [  555.556032] [<c004577c>] (worker_thread) from [<c004bab4>] (kthread+0xdc/0xf8)
    [  555.563268]  r10:00000000 r9:00000000 r8:00000000 r7:c004577c r6:edc44480 r5:eddc15c0
    [  555.571221]  r4:00000000
    [  555.573804] [<c004b9d8>] (kthread) from [<c000fef0>] (ret_from_fork+0x14/0x24)
    [  555.581040]  r7:00000000 r6:00000000 r5:c004b9d8 r4:eddc15c0
    
    [  553.429383] sh              D c07de74c     0   694    691 0x00000000
    [  553.435801] Backtrace:
    [  553.438295] [<c07de4fc>] (__schedule) from [<c07dec6c>] (schedule+0x48/0xa0)
    [  553.445358]  r10:edd3c054 r9:edd3c078 r8:edddbd50 r7:edcbbc00 r6:c1377c34 r5:60000153
    [  553.453313]  r4:eddda000
    [  553.455896] [<c07dec24>] (schedule) from [<c07deff8>] (schedule_preempt_disabled+0x10/0x14)
    [  553.464261]  r4:edd3c058 r3:0000000a
    [  553.467910] [<c07defe8>] (schedule_preempt_disabled) from [<c07e0bbc>] (mutex_lock_nested+0x1a0/0x3e8)
    [  553.477254] [<c07e0a1c>] (mutex_lock_nested) from [<c03e927c>] (dpm_complete+0xc0/0x1b0)
    [  553.485358]  r10:00561408 r9:edd3c054 r8:c0b4863c r7:edddbd90 r6:c0b485d8 r5:edd3c020
    [  553.493313]  r4:edd3c0d0
    [  553.495896] [<c03e91bc>] (dpm_complete) from [<c03e9388>] (dpm_resume_end+0x1c/0x20)
    [  553.503652]  r9:00000000 r8:c0b1a9d0 r7:c1334ec0 r6:c1334edc r5:00000003 r4:00000010
    [  553.511544] [<c03e936c>] (dpm_resume_end) from [<c0079894>] (suspend_devices_and_enter+0x158/0x504)
    [  553.520604]  r4:00000000 r3:c1334efc
    [  553.524250] [<c007973c>] (suspend_devices_and_enter) from [<c0079e74>] (pm_suspend+0x234/0x2cc)
    [  553.532961]  r10:00561408 r9:ed6b7300 r8:00000004 r7:c1334eec r6:00000000 r5:c1334ee8
    [  553.540914]  r4:00000003
    [  553.543493] [<c0079c40>] (pm_suspend) from [<c0078a6c>] (state_store+0x6c/0xc0)
    
    [  555.703684] 7 locks held by kworker/u2:13/826:
    [  555.708140]  #0:  ("%s""ci_otg"){++++.+}, at: [<c0045484>] process_one_work+0x128/0x420
    [  555.716277]  #1:  ((&ci->work)){+.+.+.}, at: [<c0045484>] process_one_work+0x128/0x420
    [  555.724317]  #2:  (usb_bus_list_lock){+.+.+.}, at: [<c04ae5e4>] usb_remove_hcd+0x98/0x1ac
    [  555.732626]  #3:  (&dev->mutex){......}, at: [<c04a8e28>] usb_disconnect+0x48/0x224
    [  555.740403]  #4:  (&dev->mutex){......}, at: [<c04a8e28>] usb_disconnect+0x48/0x224
    [  555.748179]  #5:  (&dev->mutex){......}, at: [<c03dc2f4>] device_release_driver+0x20/0x34
    [  555.756487]  #6:  (&shost->scan_mutex){+.+.+.}, at: [<c04097d0>] scsi_remove_host+0x20/0x104
    
    Cc: Jun Li <jun.li@nxp.com>
    Signed-off-by: Peter Chen <peter.chen@nxp.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit d01312328cd48d97f6a02e184017eb9568dd8fc6
Author: Peter Chen <peter.chen@nxp.com>
Date:   Wed Feb 24 11:05:25 2016 +0800

    usb: chipidea: otg: change workqueue ci_otg as freezable
    
    commit d144dfea8af7108f613139623e63952ed7e69c0c upstream.
    
    If we use USB ID pin as wakeup source, and there is a USB block
    device on this USB OTG (ID) cable, the system will be deadlock
    after system resume.
    
    The root cause for this problem is: the workqueue ci_otg may try
    to remove hcd before the driver resume has finished, and hcd will
    disconnect the device on it, then, it will call device_release_driver,
    and holds the device lock "dev->mutex", but it is never unlocked since
    it waits workqueue writeback to run to flush the block information, but
    the workqueue writeback is freezable, it is not thawed before driver
    resume has finished.
    
    When the driver (device: sd 0:0:0:0:) resume goes to dpm_complete, it
    tries to get its device lock "dev->mutex", but it can't get it forever,
    then the deadlock occurs. Below call stacks show the situation.
    
    So, in order to fix this problem, we need to change workqueue ci_otg
    as freezable, then the work item in this workqueue will be run after
    driver's resume, this workqueue will not be blocked forever like above
    case since the workqueue writeback has been thawed too.
    
    Tested at: i.mx6qdl-sabresd and i.mx6sx-sdb.
    
    [  555.178869] kworker/u2:13   D c07de74c     0   826      2 0x00000000
    [  555.185310] Workqueue: ci_otg ci_otg_work
    [  555.189353] Backtrace:
    [  555.191849] [<c07de4fc>] (__schedule) from [<c07dec6c>] (schedule+0x48/0xa0)
    [  555.198912]  r10:ee471ba0 r9:00000000 r8:00000000 r7:00000002 r6:ee470000 r5:ee471ba4
    [  555.206867]  r4:ee470000
    [  555.209453] [<c07dec24>] (schedule) from [<c07e2fc4>] (schedule_timeout+0x15c/0x1e0)
    [  555.217212]  r4:7fffffff r3:edc2b000
    [  555.220862] [<c07e2e68>] (schedule_timeout) from [<c07df6c8>] (wait_for_common+0x94/0x144)
    [  555.229140]  r8:00000000 r7:00000002 r6:ee470000 r5:ee471ba4 r4:7fffffff
    [  555.235980] [<c07df634>] (wait_for_common) from [<c07df790>] (wait_for_completion+0x18/0x1c)
    [  555.244430]  r10:00000001 r9:c0b5563c r8:c0042e48 r7:ef086000 r6:eea4372c r5:ef131b00
    [  555.252383]  r4:00000000
    [  555.254970] [<c07df778>] (wait_for_completion) from [<c0043cb8>] (flush_work+0x19c/0x234)
    [  555.263177] [<c0043b1c>] (flush_work) from [<c0043fac>] (flush_delayed_work+0x48/0x4c)
    [  555.271106]  r8:ed5b5000 r7:c0b38a3c r6:eea439cc r5:eea4372c r4:eea4372c
    [  555.277958] [<c0043f64>] (flush_delayed_work) from [<c00eae18>] (bdi_unregister+0x84/0xec)
    [  555.286236]  r4:eea43520 r3:20000153
    [  555.289885] [<c00ead94>] (bdi_unregister) from [<c02c2154>] (blk_cleanup_queue+0x180/0x29c)
    [  555.298250]  r5:eea43808 r4:eea43400
    [  555.301909] [<c02c1fd4>] (blk_cleanup_queue) from [<c0417914>] (__scsi_remove_device+0x48/0xb8)
    [  555.310623]  r7:00000000 r6:20000153 r5:ededa950 r4:ededa800
    [  555.316403] [<c04178cc>] (__scsi_remove_device) from [<c0415e90>] (scsi_forget_host+0x64/0x68)
    [  555.325028]  r5:ededa800 r4:ed5b5000
    [  555.328689] [<c0415e2c>] (scsi_forget_host) from [<c0409828>] (scsi_remove_host+0x78/0x104)
    [  555.337054]  r5:ed5b5068 r4:ed5b5000
    [  555.340709] [<c04097b0>] (scsi_remove_host) from [<c04cdfcc>] (usb_stor_disconnect+0x50/0xb4)
    [  555.349247]  r6:ed5b56e4 r5:ed5b5818 r4:ed5b5690 r3:00000008
    [  555.355025] [<c04cdf7c>] (usb_stor_disconnect) from [<c04b3bc8>] (usb_unbind_interface+0x78/0x25c)
    [  555.363997]  r8:c13919b4 r7:edd3c000 r6:edd3c020 r5:ee551c68 r4:ee551c00 r3:c04cdf7c
    [  555.371892] [<c04b3b50>] (usb_unbind_interface) from [<c03dc248>] (__device_release_driver+0x8c/0x118)
    [  555.381213]  r10:00000001 r9:edd90c00 r8:c13919b4 r7:ee551c68 r6:c0b546e0 r5:c0b5563c
    [  555.389167]  r4:edd3c020
    [  555.391752] [<c03dc1bc>] (__device_release_driver) from [<c03dc2fc>] (device_release_driver+0x28/0x34)
    [  555.401071]  r5:edd3c020 r4:edd3c054
    [  555.404721] [<c03dc2d4>] (device_release_driver) from [<c03db304>] (bus_remove_device+0xe0/0x110)
    [  555.413607]  r5:edd3c020 r4:ef17f04c
    [  555.417253] [<c03db224>] (bus_remove_device) from [<c03d8128>] (device_del+0x114/0x21c)
    [  555.425270]  r6:edd3c028 r5:edd3c020 r4:ee551c00 r3:00000000
    [  555.431045] [<c03d8014>] (device_del) from [<c04b1560>] (usb_disable_device+0xa4/0x1e8)
    [  555.439061]  r8:edd3c000 r7:eded8000 r6:00000000 r5:00000001 r4:ee551c00
    [  555.445906] [<c04b14bc>] (usb_disable_device) from [<c04a8e54>] (usb_disconnect+0x74/0x224)
    [  555.454271]  r9:edd90c00 r8:ee551000 r7:ee551c68 r6:ee551c9c r5:ee551c00 r4:00000001
    [  555.462156] [<c04a8de0>] (usb_disconnect) from [<c04a8fb8>] (usb_disconnect+0x1d8/0x224)
    [  555.470259]  r10:00000001 r9:edd90000 r8:ee471e2c r7:ee551468 r6:ee55149c r5:ee551400
    [  555.478213]  r4:00000001
    [  555.480797] [<c04a8de0>] (usb_disconnect) from [<c04ae5ec>] (usb_remove_hcd+0xa0/0x1ac)
    [  555.488813]  r10:00000001 r9:ee471eb0 r8:00000000 r7:ef3d9500 r6:eded810c r5:eded80b0
    [  555.496765]  r4:eded8000
    [  555.499351] [<c04ae54c>] (usb_remove_hcd) from [<c04d4158>] (host_stop+0x28/0x64)
    [  555.506847]  r6:eeb50010 r5:eded8000 r4:eeb51010
    [  555.511563] [<c04d4130>] (host_stop) from [<c04d09b8>] (ci_otg_work+0xc4/0x124)
    [  555.518885]  r6:00000001 r5:eeb50010 r4:eeb502a0 r3:c04d4130
    [  555.524665] [<c04d08f4>] (ci_otg_work) from [<c00454f0>] (process_one_work+0x194/0x420)
    [  555.532682]  r6:ef086000 r5:eeb502a0 r4:edc44480
    [  555.537393] [<c004535c>] (process_one_work) from [<c00457b0>] (worker_thread+0x34/0x514)
    [  555.545496]  r10:edc44480 r9:ef086000 r8:c0b1a100 r7:ef086034 r6:00000088 r5:edc44498
    [  555.553450]  r4:ef086000
    [  555.556032] [<c004577c>] (worker_thread) from [<c004bab4>] (kthread+0xdc/0xf8)
    [  555.563268]  r10:00000000 r9:00000000 r8:00000000 r7:c004577c r6:edc44480 r5:eddc15c0
    [  555.571221]  r4:00000000
    [  555.573804] [<c004b9d8>] (kthread) from [<c000fef0>] (ret_from_fork+0x14/0x24)
    [  555.581040]  r7:00000000 r6:00000000 r5:c004b9d8 r4:eddc15c0
    
    [  553.429383] sh              D c07de74c     0   694    691 0x00000000
    [  553.435801] Backtrace:
    [  553.438295] [<c07de4fc>] (__schedule) from [<c07dec6c>] (schedule+0x48/0xa0)
    [  553.445358]  r10:edd3c054 r9:edd3c078 r8:edddbd50 r7:edcbbc00 r6:c1377c34 r5:60000153
    [  553.453313]  r4:eddda000
    [  553.455896] [<c07dec24>] (schedule) from [<c07deff8>] (schedule_preempt_disabled+0x10/0x14)
    [  553.464261]  r4:edd3c058 r3:0000000a
    [  553.467910] [<c07defe8>] (schedule_preempt_disabled) from [<c07e0bbc>] (mutex_lock_nested+0x1a0/0x3e8)
    [  553.477254] [<c07e0a1c>] (mutex_lock_nested) from [<c03e927c>] (dpm_complete+0xc0/0x1b0)
    [  553.485358]  r10:00561408 r9:edd3c054 r8:c0b4863c r7:edddbd90 r6:c0b485d8 r5:edd3c020
    [  553.493313]  r4:edd3c0d0
    [  553.495896] [<c03e91bc>] (dpm_complete) from [<c03e9388>] (dpm_resume_end+0x1c/0x20)
    [  553.503652]  r9:00000000 r8:c0b1a9d0 r7:c1334ec0 r6:c1334edc r5:00000003 r4:00000010
    [  553.511544] [<c03e936c>] (dpm_resume_end) from [<c0079894>] (suspend_devices_and_enter+0x158/0x504)
    [  553.520604]  r4:00000000 r3:c1334efc
    [  553.524250] [<c007973c>] (suspend_devices_and_enter) from [<c0079e74>] (pm_suspend+0x234/0x2cc)
    [  553.532961]  r10:00561408 r9:ed6b7300 r8:00000004 r7:c1334eec r6:00000000 r5:c1334ee8
    [  553.540914]  r4:00000003
    [  553.543493] [<c0079c40>] (pm_suspend) from [<c0078a6c>] (state_store+0x6c/0xc0)
    
    [  555.703684] 7 locks held by kworker/u2:13/826:
    [  555.708140]  #0:  ("%s""ci_otg"){++++.+}, at: [<c0045484>] process_one_work+0x128/0x420
    [  555.716277]  #1:  ((&ci->work)){+.+.+.}, at: [<c0045484>] process_one_work+0x128/0x420
    [  555.724317]  #2:  (usb_bus_list_lock){+.+.+.}, at: [<c04ae5e4>] usb_remove_hcd+0x98/0x1ac
    [  555.732626]  #3:  (&dev->mutex){......}, at: [<c04a8e28>] usb_disconnect+0x48/0x224
    [  555.740403]  #4:  (&dev->mutex){......}, at: [<c04a8e28>] usb_disconnect+0x48/0x224
    [  555.748179]  #5:  (&dev->mutex){......}, at: [<c03dc2f4>] device_release_driver+0x20/0x34
    [  555.756487]  #6:  (&shost->scan_mutex){+.+.+.}, at: [<c04097d0>] scsi_remove_host+0x20/0x104
    
    Cc: Jun Li <jun.li@nxp.com>
    Signed-off-by: Peter Chen <peter.chen@nxp.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 49670184289e48451171179470a7dbbdb63f9549
Author: Peter Chen <peter.chen@nxp.com>
Date:   Wed Feb 24 11:05:25 2016 +0800

    usb: chipidea: otg: change workqueue ci_otg as freezable
    
    [ Upstream commit d144dfea8af7108f613139623e63952ed7e69c0c ]
    
    If we use USB ID pin as wakeup source, and there is a USB block
    device on this USB OTG (ID) cable, the system will be deadlock
    after system resume.
    
    The root cause for this problem is: the workqueue ci_otg may try
    to remove hcd before the driver resume has finished, and hcd will
    disconnect the device on it, then, it will call device_release_driver,
    and holds the device lock "dev->mutex", but it is never unlocked since
    it waits workqueue writeback to run to flush the block information, but
    the workqueue writeback is freezable, it is not thawed before driver
    resume has finished.
    
    When the driver (device: sd 0:0:0:0:) resume goes to dpm_complete, it
    tries to get its device lock "dev->mutex", but it can't get it forever,
    then the deadlock occurs. Below call stacks show the situation.
    
    So, in order to fix this problem, we need to change workqueue ci_otg
    as freezable, then the work item in this workqueue will be run after
    driver's resume, this workqueue will not be blocked forever like above
    case since the workqueue writeback has been thawed too.
    
    Tested at: i.mx6qdl-sabresd and i.mx6sx-sdb.
    
    [  555.178869] kworker/u2:13   D c07de74c     0   826      2 0x00000000
    [  555.185310] Workqueue: ci_otg ci_otg_work
    [  555.189353] Backtrace:
    [  555.191849] [<c07de4fc>] (__schedule) from [<c07dec6c>] (schedule+0x48/0xa0)
    [  555.198912]  r10:ee471ba0 r9:00000000 r8:00000000 r7:00000002 r6:ee470000 r5:ee471ba4
    [  555.206867]  r4:ee470000
    [  555.209453] [<c07dec24>] (schedule) from [<c07e2fc4>] (schedule_timeout+0x15c/0x1e0)
    [  555.217212]  r4:7fffffff r3:edc2b000
    [  555.220862] [<c07e2e68>] (schedule_timeout) from [<c07df6c8>] (wait_for_common+0x94/0x144)
    [  555.229140]  r8:00000000 r7:00000002 r6:ee470000 r5:ee471ba4 r4:7fffffff
    [  555.235980] [<c07df634>] (wait_for_common) from [<c07df790>] (wait_for_completion+0x18/0x1c)
    [  555.244430]  r10:00000001 r9:c0b5563c r8:c0042e48 r7:ef086000 r6:eea4372c r5:ef131b00
    [  555.252383]  r4:00000000
    [  555.254970] [<c07df778>] (wait_for_completion) from [<c0043cb8>] (flush_work+0x19c/0x234)
    [  555.263177] [<c0043b1c>] (flush_work) from [<c0043fac>] (flush_delayed_work+0x48/0x4c)
    [  555.271106]  r8:ed5b5000 r7:c0b38a3c r6:eea439cc r5:eea4372c r4:eea4372c
    [  555.277958] [<c0043f64>] (flush_delayed_work) from [<c00eae18>] (bdi_unregister+0x84/0xec)
    [  555.286236]  r4:eea43520 r3:20000153
    [  555.289885] [<c00ead94>] (bdi_unregister) from [<c02c2154>] (blk_cleanup_queue+0x180/0x29c)
    [  555.298250]  r5:eea43808 r4:eea43400
    [  555.301909] [<c02c1fd4>] (blk_cleanup_queue) from [<c0417914>] (__scsi_remove_device+0x48/0xb8)
    [  555.310623]  r7:00000000 r6:20000153 r5:ededa950 r4:ededa800
    [  555.316403] [<c04178cc>] (__scsi_remove_device) from [<c0415e90>] (scsi_forget_host+0x64/0x68)
    [  555.325028]  r5:ededa800 r4:ed5b5000
    [  555.328689] [<c0415e2c>] (scsi_forget_host) from [<c0409828>] (scsi_remove_host+0x78/0x104)
    [  555.337054]  r5:ed5b5068 r4:ed5b5000
    [  555.340709] [<c04097b0>] (scsi_remove_host) from [<c04cdfcc>] (usb_stor_disconnect+0x50/0xb4)
    [  555.349247]  r6:ed5b56e4 r5:ed5b5818 r4:ed5b5690 r3:00000008
    [  555.355025] [<c04cdf7c>] (usb_stor_disconnect) from [<c04b3bc8>] (usb_unbind_interface+0x78/0x25c)
    [  555.363997]  r8:c13919b4 r7:edd3c000 r6:edd3c020 r5:ee551c68 r4:ee551c00 r3:c04cdf7c
    [  555.371892] [<c04b3b50>] (usb_unbind_interface) from [<c03dc248>] (__device_release_driver+0x8c/0x118)
    [  555.381213]  r10:00000001 r9:edd90c00 r8:c13919b4 r7:ee551c68 r6:c0b546e0 r5:c0b5563c
    [  555.389167]  r4:edd3c020
    [  555.391752] [<c03dc1bc>] (__device_release_driver) from [<c03dc2fc>] (device_release_driver+0x28/0x34)
    [  555.401071]  r5:edd3c020 r4:edd3c054
    [  555.404721] [<c03dc2d4>] (device_release_driver) from [<c03db304>] (bus_remove_device+0xe0/0x110)
    [  555.413607]  r5:edd3c020 r4:ef17f04c
    [  555.417253] [<c03db224>] (bus_remove_device) from [<c03d8128>] (device_del+0x114/0x21c)
    [  555.425270]  r6:edd3c028 r5:edd3c020 r4:ee551c00 r3:00000000
    [  555.431045] [<c03d8014>] (device_del) from [<c04b1560>] (usb_disable_device+0xa4/0x1e8)
    [  555.439061]  r8:edd3c000 r7:eded8000 r6:00000000 r5:00000001 r4:ee551c00
    [  555.445906] [<c04b14bc>] (usb_disable_device) from [<c04a8e54>] (usb_disconnect+0x74/0x224)
    [  555.454271]  r9:edd90c00 r8:ee551000 r7:ee551c68 r6:ee551c9c r5:ee551c00 r4:00000001
    [  555.462156] [<c04a8de0>] (usb_disconnect) from [<c04a8fb8>] (usb_disconnect+0x1d8/0x224)
    [  555.470259]  r10:00000001 r9:edd90000 r8:ee471e2c r7:ee551468 r6:ee55149c r5:ee551400
    [  555.478213]  r4:00000001
    [  555.480797] [<c04a8de0>] (usb_disconnect) from [<c04ae5ec>] (usb_remove_hcd+0xa0/0x1ac)
    [  555.488813]  r10:00000001 r9:ee471eb0 r8:00000000 r7:ef3d9500 r6:eded810c r5:eded80b0
    [  555.496765]  r4:eded8000
    [  555.499351] [<c04ae54c>] (usb_remove_hcd) from [<c04d4158>] (host_stop+0x28/0x64)
    [  555.506847]  r6:eeb50010 r5:eded8000 r4:eeb51010
    [  555.511563] [<c04d4130>] (host_stop) from [<c04d09b8>] (ci_otg_work+0xc4/0x124)
    [  555.518885]  r6:00000001 r5:eeb50010 r4:eeb502a0 r3:c04d4130
    [  555.524665] [<c04d08f4>] (ci_otg_work) from [<c00454f0>] (process_one_work+0x194/0x420)
    [  555.532682]  r6:ef086000 r5:eeb502a0 r4:edc44480
    [  555.537393] [<c004535c>] (process_one_work) from [<c00457b0>] (worker_thread+0x34/0x514)
    [  555.545496]  r10:edc44480 r9:ef086000 r8:c0b1a100 r7:ef086034 r6:00000088 r5:edc44498
    [  555.553450]  r4:ef086000
    [  555.556032] [<c004577c>] (worker_thread) from [<c004bab4>] (kthread+0xdc/0xf8)
    [  555.563268]  r10:00000000 r9:00000000 r8:00000000 r7:c004577c r6:edc44480 r5:eddc15c0
    [  555.571221]  r4:00000000
    [  555.573804] [<c004b9d8>] (kthread) from [<c000fef0>] (ret_from_fork+0x14/0x24)
    [  555.581040]  r7:00000000 r6:00000000 r5:c004b9d8 r4:eddc15c0
    
    [  553.429383] sh              D c07de74c     0   694    691 0x00000000
    [  553.435801] Backtrace:
    [  553.438295] [<c07de4fc>] (__schedule) from [<c07dec6c>] (schedule+0x48/0xa0)
    [  553.445358]  r10:edd3c054 r9:edd3c078 r8:edddbd50 r7:edcbbc00 r6:c1377c34 r5:60000153
    [  553.453313]  r4:eddda000
    [  553.455896] [<c07dec24>] (schedule) from [<c07deff8>] (schedule_preempt_disabled+0x10/0x14)
    [  553.464261]  r4:edd3c058 r3:0000000a
    [  553.467910] [<c07defe8>] (schedule_preempt_disabled) from [<c07e0bbc>] (mutex_lock_nested+0x1a0/0x3e8)
    [  553.477254] [<c07e0a1c>] (mutex_lock_nested) from [<c03e927c>] (dpm_complete+0xc0/0x1b0)
    [  553.485358]  r10:00561408 r9:edd3c054 r8:c0b4863c r7:edddbd90 r6:c0b485d8 r5:edd3c020
    [  553.493313]  r4:edd3c0d0
    [  553.495896] [<c03e91bc>] (dpm_complete) from [<c03e9388>] (dpm_resume_end+0x1c/0x20)
    [  553.503652]  r9:00000000 r8:c0b1a9d0 r7:c1334ec0 r6:c1334edc r5:00000003 r4:00000010
    [  553.511544] [<c03e936c>] (dpm_resume_end) from [<c0079894>] (suspend_devices_and_enter+0x158/0x504)
    [  553.520604]  r4:00000000 r3:c1334efc
    [  553.524250] [<c007973c>] (suspend_devices_and_enter) from [<c0079e74>] (pm_suspend+0x234/0x2cc)
    [  553.532961]  r10:00561408 r9:ed6b7300 r8:00000004 r7:c1334eec r6:00000000 r5:c1334ee8
    [  553.540914]  r4:00000003
    [  553.543493] [<c0079c40>] (pm_suspend) from [<c0078a6c>] (state_store+0x6c/0xc0)
    
    [  555.703684] 7 locks held by kworker/u2:13/826:
    [  555.708140]  #0:  ("%s""ci_otg"){++++.+}, at: [<c0045484>] process_one_work+0x128/0x420
    [  555.716277]  #1:  ((&ci->work)){+.+.+.}, at: [<c0045484>] process_one_work+0x128/0x420
    [  555.724317]  #2:  (usb_bus_list_lock){+.+.+.}, at: [<c04ae5e4>] usb_remove_hcd+0x98/0x1ac
    [  555.732626]  #3:  (&dev->mutex){......}, at: [<c04a8e28>] usb_disconnect+0x48/0x224
    [  555.740403]  #4:  (&dev->mutex){......}, at: [<c04a8e28>] usb_disconnect+0x48/0x224
    [  555.748179]  #5:  (&dev->mutex){......}, at: [<c03dc2f4>] device_release_driver+0x20/0x34
    [  555.756487]  #6:  (&shost->scan_mutex){+.+.+.}, at: [<c04097d0>] scsi_remove_host+0x20/0x104
    
    Cc: <stable@vger.kernel.org> #v3.14+
    Cc: Jun Li <jun.li@nxp.com>
    Signed-off-by: Peter Chen <peter.chen@nxp.com>
    Signed-off-by: Sasha Levin <sasha.levin@oracle.com>

commit 30ff5957c3f1887d04ca01d839dc382739e48bde
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Fri Feb 26 19:39:57 2016 +0200

    ALSA: hda - Autosuspend controller after probe even if codecs are already suspended
    
    azx_probe_continue() uses pm_runtime_put_noidle() to drop the rpm
    usage_count, which means that if it's the last reference the
    autosuspend of the controller won't actually happen. So if the codecs
    autosuspend before the azx_probe_continue() drops the last
    reference we'll fail to autosuspend the controller. This does happen
    in practice, but not every time. As can be seen in [1] the controller
    autosuspend attempt fails due to the usage_count when suspending the
    codecs. A bit later we see the the contoller usage_count dropping to
    zero without further attempts at autosuspend.
    
    Fix the problem by using pm_runtime_put_autosuspend() instead, which
    will kick off the autosuspend of the controller even if the codecs
    are already asleep. As can be seen in [2] the controller autosuspend
    still fails while suspending the codecs, but later on we see another
    autosuspend attempt after dropping the usage_count to 0.
    
    I was also a bit worried that there might still be a race between the
    controller autosuspend and the rest of the code in azx_probe_continue().
    So I also tried replacing the the put_noidle() with put_sync_suspend().
    No explosions occurred, so I'm somewhat satisfied that there are no
    serious problems in this area.
    
    [1]
     kworker/1:2-122   [001] ....    63.661310: __pm_runtime_suspend: hdaudioC0D0 usage_count 0
     kworker/1:2-122   [001] d..2    63.661316: rpm_suspend: hdaudioC0D0 flags-d cnt-0  dep-0  auto-1 p-0 irq-0 child-0
     kworker/1:2-122   [001] d..1    63.661317: rpm_check_suspend_allowed: hdaudioC0D0 retval 0
     kworker/1:2-122   [001] d..2    63.661332: rpm_return_int: rpm_suspend+0x406/0x5e8:hdaudioC0D0 ret=0
     kworker/1:1-72    [001] d..2    63.661543: rpm_suspend: hdaudioC0D0 flags-a cnt-0  dep-0  auto-1 p-0 irq-0 child-0
     kworker/1:1-72    [001] d..1    63.661544: rpm_check_suspend_allowed: hdaudioC0D0 retval 0
     kworker/1:1-72    [001] ....    63.661545: hda_codec_runtime_suspend: hdaudioC0D0 suspend
     kworker/1:1-72    [001] d..2    63.661614: rpm_idle: 0000:00:03.0 flags-1 cnt-1  dep-0  auto-1 p-0 irq-0 child-0
     kworker/1:1-72    [001] d..1    63.661615: rpm_check_suspend_allowed: 0000:00:03.0 usage_count 1
     kworker/1:1-72    [001] d..1    63.661615: rpm_check_suspend_allowed: 0000:00:03.0 retval -11
     kworker/1:1-72    [001] d..2    63.661616: rpm_return_int: rpm_idle+0x249/0x487:0000:00:03.0 ret=-11
     kworker/1:1-72    [001] d..2    63.661616: rpm_return_int: rpm_suspend+0x406/0x5e8:hdaudioC0D0 ret=0
     kworker/1:2-122   [001] d..2    63.664834: rpm_idle: hdaudioC0D0 flags-8 cnt-0  dep-0  auto-1 p-0 irq-0 child-0
     kworker/1:2-122   [001] d..1    63.664835: rpm_check_suspend_allowed: hdaudioC0D0 retval 1
     kworker/1:2-122   [001] d..2    63.664836: rpm_return_int: rpm_idle+0x249/0x487:hdaudioC0D0 ret=-11
     kworker/1:2-122   [001] d..2    63.664841: rpm_idle: hdaudioC0D0 flags-8 cnt-0  dep-0  auto-1 p-0 irq-0 child-0
     kworker/1:2-122   [001] d..1    63.664841: rpm_check_suspend_allowed: hdaudioC0D0 retval 1
     kworker/1:2-122   [001] d..2    63.664841: rpm_return_int: rpm_idle+0x249/0x487:hdaudioC0D0 ret=-11
     kworker/1:2-122   [001] ....    63.664842: azx_probe_continue: 0000:00:03.0 usage_count=0
    
    [2]
     kworker/0:0-4     [000] ....    50.354567: __pm_runtime_suspend: hdaudioC0D0 usage_count 0
     kworker/0:0-4     [000] d..2    50.354574: rpm_suspend: hdaudioC0D0 flags-d cnt-0  dep-0  auto-1 p-0 irq-0 child-0
     kworker/0:0-4     [000] d..1    50.354575: rpm_check_suspend_allowed: hdaudioC0D0 retval 0
     kworker/0:0-4     [000] d..2    50.354589: rpm_return_int: rpm_suspend+0x406/0x5e8:hdaudioC0D0 ret=0
     kworker/0:2-135   [000] d..2    50.354809: rpm_suspend: hdaudioC0D0 flags-a cnt-0  dep-0  auto-1 p-0 irq-0 child-0
     kworker/0:2-135   [000] d..1    50.354810: rpm_check_suspend_allowed: hdaudioC0D0 retval 0
     kworker/0:2-135   [000] ....    50.354816: hda_codec_runtime_suspend: hdaudioC0D0 suspend
     kworker/0:2-135   [000] d..2    50.354908: rpm_idle: 0000:00:03.0 flags-1 cnt-1  dep-0  auto-1 p-0 irq-0 child-0
     kworker/0:2-135   [000] d..1    50.354909: rpm_check_suspend_allowed: 0000:00:03.0 usage_count 1
     kworker/0:2-135   [000] d..1    50.354909: rpm_check_suspend_allowed: 0000:00:03.0 retval -11
     kworker/0:2-135   [000] d..2    50.354909: rpm_return_int: rpm_idle+0x249/0x487:0000:00:03.0 ret=-11
     kworker/0:2-135   [000] d..2    50.354910: rpm_return_int: rpm_suspend+0x406/0x5e8:hdaudioC0D0 ret=0
     kworker/0:0-4     [000] d..2    50.373791: rpm_idle: hdaudioC0D0 flags-8 cnt-0  dep-0  auto-1 p-0 irq-0 child-0
     kworker/0:0-4     [000] d..1    50.373792: rpm_check_suspend_allowed: hdaudioC0D0 retval 1
     kworker/0:0-4     [000] d..2    50.373793: rpm_return_int: rpm_idle+0x249/0x487:hdaudioC0D0 ret=-11
     kworker/0:0-4     [000] d..2    50.373797: rpm_idle: hdaudioC0D0 flags-8 cnt-0  dep-0  auto-1 p-0 irq-0 child-0
     kworker/0:0-4     [000] d..1    50.373798: rpm_check_suspend_allowed: hdaudioC0D0 retval 1
     kworker/0:0-4     [000] d..2    50.373798: rpm_return_int: rpm_idle+0x249/0x487:hdaudioC0D0 ret=-11
     kworker/0:0-4     [000] ....    50.373799: __pm_runtime_suspend: 0000:00:03.0 usage_count 0
     kworker/0:0-4     [000] d..2    50.373800: rpm_suspend: 0000:00:03.0 flags-d cnt-0  dep-0  auto-1 p-0 irq-0 child-0
     kworker/0:0-4     [000] d..1    50.373800: rpm_check_suspend_allowed: 0000:00:03.0 retval 0
     kworker/0:0-4     [000] d..2    50.373803: rpm_return_int: rpm_suspend+0x406/0x5e8:0000:00:03.0 ret=0
     kworker/0:0-4     [000] d..2    50.385164: rpm_suspend: 0000:00:03.0 flags-a cnt-0  dep-0  auto-1 p-0 irq-0 child-0
     kworker/0:0-4     [000] d..1    50.385165: rpm_check_suspend_allowed: 0000:00:03.0 retval 0
     kworker/0:0-4     [000] ....    50.385174: azx_runtime_suspend: 0000:00:03.0 azx suspend releaseing power well
     kworker/0:0-4     [000] ....    50.385179: azx_runtime_suspend: 0000:00:03.0 azx suspend
     kworker/0:0-4     [000] d..2    50.386872: rpm_return_int: rpm_suspend+0x406/0x5e8:0000:00:03.0 ret=0
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

commit 85fd27f80b3641c9af9f04cde1b712c8c20916d8
Author: Darren Etheridge <detheridge@ti.com>
Date:   Fri Sep 19 01:42:57 2014 +0000

    drm/tilcdc: fix kernel panic on suspend when no hdmi monitor connected
    
    On BeagleBone Black if no HDMI monitor is connected and suspend
    is requested a kernel panic will result:
    
    root@am335x-evm:~# echo mem > /sys/power/state
    [ 65.548710] PM: Syncing filesystems ... done.
    [ 65.631311] Freezing user space processes ... (elapsed 0.006 seconds) done.
    [ 65.648619] Freezing remaining freezable tasks ... (elapsed 0.005 seconds) done.
    [ 65.833500] Unhandled fault: external abort on non-linefetch (0x1028) at 0xfa30e004
    [ 65.841692] Internal error: : 1028 [#1] SMP ARM
      <snip>
    [ 66.105287] [<c03765f0>] (platform_pm_suspend) from [<c037b6d4>] (dpm_run_callback+0x34/0x70)
    [ 66.114370] [<c037b6d4>] (dpm_run_callback) from [<c037ba84>] (__device_suspend+0x10c/0x2f4)
    [ 66.123357] [<c037ba84>] (__device_suspend) from [<c037d004>] (dpm_suspend+0x58/0x218)
    [ 66.131796] [<c037d004>] (dpm_suspend) from [<c008d948>] (suspend_devices_and_enter+0x9c/0x3c0)
    [ 66.141055] [<c008d948>] (suspend_devices_and_enter) from [<c008de7c>] (pm_suspend+0x210/0x24c)
    [ 66.150312] [<c008de7c>] (pm_suspend) from [<c008cabc>] (state_store+0x68/0xb8)
    [ 66.158103] [<c008cabc>] (state_store) from [<c02e9654>] (kobj_attr_store+0x14/0x20)
    [ 66.166355] [<c02e9654>] (kobj_attr_store) from [<c0185c70>] (sysfs_kf_write+0x4c/0x50)
    [ 66.174883] [<c0185c70>] (sysfs_kf_write) from [<c018926c>] (kernfs_fop_write+0xb4/0x150)
    [ 66.183598] [<c018926c>] (kernfs_fop_write) from [<c0122638>] (vfs_write+0xa8/0x180)
    [ 66.191846] [<c0122638>] (vfs_write) from [<c01229f8>] (SyS_write+0x40/0x8c)
    [ 66.199365] [<c01229f8>] (SyS_write) from [<c000e580>] (ret_fast_syscall+0x0/0x48)
    [ 66.207426] Code: e595c210 e5932000 e59cc000 e08c2002 (e592c000)
    
    This is because the lcdc module is not enabled when no monitor is detected
    to save power.  However the suspend handler just blindly tries to save the
    lcdc state by copying out the pertinent registers. However module is off
    so no good things happen when you try and access it.
    
    This patch only saves off the registers if the module is enabled, and
    then only restores the registers on resume if they were saved off during
    suspend.
    
    Signed-off-by: Darren Etheridge <detheridge@ti.com>
    Tested-by: Dave Gerlach <d-gerlach@ti.com>
    Acked-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Jyri Sarha <jsarha@ti.com>
    Reviewed-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

commit d144dfea8af7108f613139623e63952ed7e69c0c
Author: Peter Chen <peter.chen@nxp.com>
Date:   Wed Feb 24 11:05:25 2016 +0800

    usb: chipidea: otg: change workqueue ci_otg as freezable
    
    If we use USB ID pin as wakeup source, and there is a USB block
    device on this USB OTG (ID) cable, the system will be deadlock
    after system resume.
    
    The root cause for this problem is: the workqueue ci_otg may try
    to remove hcd before the driver resume has finished, and hcd will
    disconnect the device on it, then, it will call device_release_driver,
    and holds the device lock "dev->mutex", but it is never unlocked since
    it waits workqueue writeback to run to flush the block information, but
    the workqueue writeback is freezable, it is not thawed before driver
    resume has finished.
    
    When the driver (device: sd 0:0:0:0:) resume goes to dpm_complete, it
    tries to get its device lock "dev->mutex", but it can't get it forever,
    then the deadlock occurs. Below call stacks show the situation.
    
    So, in order to fix this problem, we need to change workqueue ci_otg
    as freezable, then the work item in this workqueue will be run after
    driver's resume, this workqueue will not be blocked forever like above
    case since the workqueue writeback has been thawed too.
    
    Tested at: i.mx6qdl-sabresd and i.mx6sx-sdb.
    
    [  555.178869] kworker/u2:13   D c07de74c     0   826      2 0x00000000
    [  555.185310] Workqueue: ci_otg ci_otg_work
    [  555.189353] Backtrace:
    [  555.191849] [<c07de4fc>] (__schedule) from [<c07dec6c>] (schedule+0x48/0xa0)
    [  555.198912]  r10:ee471ba0 r9:00000000 r8:00000000 r7:00000002 r6:ee470000 r5:ee471ba4
    [  555.206867]  r4:ee470000
    [  555.209453] [<c07dec24>] (schedule) from [<c07e2fc4>] (schedule_timeout+0x15c/0x1e0)
    [  555.217212]  r4:7fffffff r3:edc2b000
    [  555.220862] [<c07e2e68>] (schedule_timeout) from [<c07df6c8>] (wait_for_common+0x94/0x144)
    [  555.229140]  r8:00000000 r7:00000002 r6:ee470000 r5:ee471ba4 r4:7fffffff
    [  555.235980] [<c07df634>] (wait_for_common) from [<c07df790>] (wait_for_completion+0x18/0x1c)
    [  555.244430]  r10:00000001 r9:c0b5563c r8:c0042e48 r7:ef086000 r6:eea4372c r5:ef131b00
    [  555.252383]  r4:00000000
    [  555.254970] [<c07df778>] (wait_for_completion) from [<c0043cb8>] (flush_work+0x19c/0x234)
    [  555.263177] [<c0043b1c>] (flush_work) from [<c0043fac>] (flush_delayed_work+0x48/0x4c)
    [  555.271106]  r8:ed5b5000 r7:c0b38a3c r6:eea439cc r5:eea4372c r4:eea4372c
    [  555.277958] [<c0043f64>] (flush_delayed_work) from [<c00eae18>] (bdi_unregister+0x84/0xec)
    [  555.286236]  r4:eea43520 r3:20000153
    [  555.289885] [<c00ead94>] (bdi_unregister) from [<c02c2154>] (blk_cleanup_queue+0x180/0x29c)
    [  555.298250]  r5:eea43808 r4:eea43400
    [  555.301909] [<c02c1fd4>] (blk_cleanup_queue) from [<c0417914>] (__scsi_remove_device+0x48/0xb8)
    [  555.310623]  r7:00000000 r6:20000153 r5:ededa950 r4:ededa800
    [  555.316403] [<c04178cc>] (__scsi_remove_device) from [<c0415e90>] (scsi_forget_host+0x64/0x68)
    [  555.325028]  r5:ededa800 r4:ed5b5000
    [  555.328689] [<c0415e2c>] (scsi_forget_host) from [<c0409828>] (scsi_remove_host+0x78/0x104)
    [  555.337054]  r5:ed5b5068 r4:ed5b5000
    [  555.340709] [<c04097b0>] (scsi_remove_host) from [<c04cdfcc>] (usb_stor_disconnect+0x50/0xb4)
    [  555.349247]  r6:ed5b56e4 r5:ed5b5818 r4:ed5b5690 r3:00000008
    [  555.355025] [<c04cdf7c>] (usb_stor_disconnect) from [<c04b3bc8>] (usb_unbind_interface+0x78/0x25c)
    [  555.363997]  r8:c13919b4 r7:edd3c000 r6:edd3c020 r5:ee551c68 r4:ee551c00 r3:c04cdf7c
    [  555.371892] [<c04b3b50>] (usb_unbind_interface) from [<c03dc248>] (__device_release_driver+0x8c/0x118)
    [  555.381213]  r10:00000001 r9:edd90c00 r8:c13919b4 r7:ee551c68 r6:c0b546e0 r5:c0b5563c
    [  555.389167]  r4:edd3c020
    [  555.391752] [<c03dc1bc>] (__device_release_driver) from [<c03dc2fc>] (device_release_driver+0x28/0x34)
    [  555.401071]  r5:edd3c020 r4:edd3c054
    [  555.404721] [<c03dc2d4>] (device_release_driver) from [<c03db304>] (bus_remove_device+0xe0/0x110)
    [  555.413607]  r5:edd3c020 r4:ef17f04c
    [  555.417253] [<c03db224>] (bus_remove_device) from [<c03d8128>] (device_del+0x114/0x21c)
    [  555.425270]  r6:edd3c028 r5:edd3c020 r4:ee551c00 r3:00000000
    [  555.431045] [<c03d8014>] (device_del) from [<c04b1560>] (usb_disable_device+0xa4/0x1e8)
    [  555.439061]  r8:edd3c000 r7:eded8000 r6:00000000 r5:00000001 r4:ee551c00
    [  555.445906] [<c04b14bc>] (usb_disable_device) from [<c04a8e54>] (usb_disconnect+0x74/0x224)
    [  555.454271]  r9:edd90c00 r8:ee551000 r7:ee551c68 r6:ee551c9c r5:ee551c00 r4:00000001
    [  555.462156] [<c04a8de0>] (usb_disconnect) from [<c04a8fb8>] (usb_disconnect+0x1d8/0x224)
    [  555.470259]  r10:00000001 r9:edd90000 r8:ee471e2c r7:ee551468 r6:ee55149c r5:ee551400
    [  555.478213]  r4:00000001
    [  555.480797] [<c04a8de0>] (usb_disconnect) from [<c04ae5ec>] (usb_remove_hcd+0xa0/0x1ac)
    [  555.488813]  r10:00000001 r9:ee471eb0 r8:00000000 r7:ef3d9500 r6:eded810c r5:eded80b0
    [  555.496765]  r4:eded8000
    [  555.499351] [<c04ae54c>] (usb_remove_hcd) from [<c04d4158>] (host_stop+0x28/0x64)
    [  555.506847]  r6:eeb50010 r5:eded8000 r4:eeb51010
    [  555.511563] [<c04d4130>] (host_stop) from [<c04d09b8>] (ci_otg_work+0xc4/0x124)
    [  555.518885]  r6:00000001 r5:eeb50010 r4:eeb502a0 r3:c04d4130
    [  555.524665] [<c04d08f4>] (ci_otg_work) from [<c00454f0>] (process_one_work+0x194/0x420)
    [  555.532682]  r6:ef086000 r5:eeb502a0 r4:edc44480
    [  555.537393] [<c004535c>] (process_one_work) from [<c00457b0>] (worker_thread+0x34/0x514)
    [  555.545496]  r10:edc44480 r9:ef086000 r8:c0b1a100 r7:ef086034 r6:00000088 r5:edc44498
    [  555.553450]  r4:ef086000
    [  555.556032] [<c004577c>] (worker_thread) from [<c004bab4>] (kthread+0xdc/0xf8)
    [  555.563268]  r10:00000000 r9:00000000 r8:00000000 r7:c004577c r6:edc44480 r5:eddc15c0
    [  555.571221]  r4:00000000
    [  555.573804] [<c004b9d8>] (kthread) from [<c000fef0>] (ret_from_fork+0x14/0x24)
    [  555.581040]  r7:00000000 r6:00000000 r5:c004b9d8 r4:eddc15c0
    
    [  553.429383] sh              D c07de74c     0   694    691 0x00000000
    [  553.435801] Backtrace:
    [  553.438295] [<c07de4fc>] (__schedule) from [<c07dec6c>] (schedule+0x48/0xa0)
    [  553.445358]  r10:edd3c054 r9:edd3c078 r8:edddbd50 r7:edcbbc00 r6:c1377c34 r5:60000153
    [  553.453313]  r4:eddda000
    [  553.455896] [<c07dec24>] (schedule) from [<c07deff8>] (schedule_preempt_disabled+0x10/0x14)
    [  553.464261]  r4:edd3c058 r3:0000000a
    [  553.467910] [<c07defe8>] (schedule_preempt_disabled) from [<c07e0bbc>] (mutex_lock_nested+0x1a0/0x3e8)
    [  553.477254] [<c07e0a1c>] (mutex_lock_nested) from [<c03e927c>] (dpm_complete+0xc0/0x1b0)
    [  553.485358]  r10:00561408 r9:edd3c054 r8:c0b4863c r7:edddbd90 r6:c0b485d8 r5:edd3c020
    [  553.493313]  r4:edd3c0d0
    [  553.495896] [<c03e91bc>] (dpm_complete) from [<c03e9388>] (dpm_resume_end+0x1c/0x20)
    [  553.503652]  r9:00000000 r8:c0b1a9d0 r7:c1334ec0 r6:c1334edc r5:00000003 r4:00000010
    [  553.511544] [<c03e936c>] (dpm_resume_end) from [<c0079894>] (suspend_devices_and_enter+0x158/0x504)
    [  553.520604]  r4:00000000 r3:c1334efc
    [  553.524250] [<c007973c>] (suspend_devices_and_enter) from [<c0079e74>] (pm_suspend+0x234/0x2cc)
    [  553.532961]  r10:00561408 r9:ed6b7300 r8:00000004 r7:c1334eec r6:00000000 r5:c1334ee8
    [  553.540914]  r4:00000003
    [  553.543493] [<c0079c40>] (pm_suspend) from [<c0078a6c>] (state_store+0x6c/0xc0)
    
    [  555.703684] 7 locks held by kworker/u2:13/826:
    [  555.708140]  #0:  ("%s""ci_otg"){++++.+}, at: [<c0045484>] process_one_work+0x128/0x420
    [  555.716277]  #1:  ((&ci->work)){+.+.+.}, at: [<c0045484>] process_one_work+0x128/0x420
    [  555.724317]  #2:  (usb_bus_list_lock){+.+.+.}, at: [<c04ae5e4>] usb_remove_hcd+0x98/0x1ac
    [  555.732626]  #3:  (&dev->mutex){......}, at: [<c04a8e28>] usb_disconnect+0x48/0x224
    [  555.740403]  #4:  (&dev->mutex){......}, at: [<c04a8e28>] usb_disconnect+0x48/0x224
    [  555.748179]  #5:  (&dev->mutex){......}, at: [<c03dc2f4>] device_release_driver+0x20/0x34
    [  555.756487]  #6:  (&shost->scan_mutex){+.+.+.}, at: [<c04097d0>] scsi_remove_host+0x20/0x104
    
    Cc: <stable@vger.kernel.org> #v3.14+
    Cc: Jun Li <jun.li@nxp.com>
    Signed-off-by: Peter Chen <peter.chen@nxp.com>

commit 41cfd64cf49fc84837341732a142f3d4cdc1e83a
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon Feb 22 10:27:46 2016 +0530

    intel_pstate: Update frequencies of policy->cpus only from ->set_policy()
    
    The intel-pstate driver is using intel_pstate_hwp_set() from two
    separate paths, i.e. ->set_policy() callback and sysfs update path for
    the files present in /sys/devices/system/cpu/intel_pstate/ directory.
    
    While an update to the sysfs path applies to all the CPUs being managed
    by the driver (which essentially means all the online CPUs), the update
    via the ->set_policy() callback applies to a smaller group of CPUs
    managed by the policy for which ->set_policy() is called.
    
    And so, intel_pstate_hwp_set() should update frequencies of only the
    CPUs that are part of policy->cpus mask, while it is called from
    ->set_policy() callback.
    
    In order to do that, add a parameter (cpumask) to intel_pstate_hwp_set()
    and apply the frequency changes only to the concerned CPUs.
    
    For ->set_policy() path, we are only concerned about policy->cpus, and
    so policy->rwsem lock taken by the core prior to calling ->set_policy()
    is enough to take care of any races. The larger lock acquired by
    get_online_cpus() is required only for the updates to sysfs files.
    
    Add another routine, intel_pstate_hwp_set_online_cpus(), and call it
    from the sysfs update paths.
    
    This also fixes a lockdep reported recently, where policy->rwsem and
    get_online_cpus() could have been acquired in any order causing an ABBA
    deadlock. The sequence of events leading to that was:
    
    intel_pstate_init(...)
            ...cpufreq_online(...)
                    down_write(&policy->rwsem); // Locks policy->rwsem
                    ...
                    cpufreq_init_policy(policy);
                            ...intel_pstate_hwp_set();
                                    get_online_cpus(); // Temporarily locks cpu_hotplug.lock
                    ...
                    up_write(&policy->rwsem);
    
    pm_suspend(...)
            ...disable_nonboot_cpus()
                    _cpu_down()
                            cpu_hotplug_begin(); // Locks cpu_hotplug.lock
                            __cpu_notify(CPU_DOWN_PREPARE, ...);
                                    ...cpufreq_offline_prepare();
                                            down_write(&policy->rwsem); // Locks policy->rwsem
    
    Reported-and-tested-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Acked-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 29add68d16474b7e8e3eadd94da4e909533b99d2
Author: Martin Fuzzey <mfuzzey@parkeon.com>
Date:   Tue Jan 5 16:53:31 2016 +0100

    serial: imx: Fix suspend / resume.
    
    When a non console i.MX UART is enabled in the device tree,
    system suspend fails due to an unprepared clock:
    
    [  638.794563] PM: Syncing filesystems ... done.
    [  638.878902] Freezing user space processes ... (elapsed 0.002 seconds) done.
    [  638.888454] Freezing remaining freezable tasks ... (elapsed 0.001 seconds) done.
    [  638.996697] PM: suspend of devices complete after 97.200 msecs
    [  639.002611] PM: suspend devices took 0.100 seconds
    [  639.013020] PM: late suspend of devices complete after 2.288 msecs
    [  639.021486] ------------[ cut here ]------------
    [  639.026147] WARNING: CPU: 0 PID: 488 at drivers/clk/clk.c:732 clk_core_enable+0xc0/0x12c()
    [  639.034413] Modules linked in:
    [  639.037490] CPU: 0 PID: 488 Comm: system_server Tainted: G        W       4.4.0-rc5-pknbsp-svn2214-atag-v4.4-rc5-121-gebfd9cb #1304
    [  639.049312] Hardware name: Freescale i.MX53 (Device Tree Support)
    [  639.055444] [<c0016d54>] (unwind_backtrace) from [<c00140f8>] (show_stack+0x20/0x24)
    [  639.063199] [<c00140f8>] (show_stack) from [<c02c99a0>] (dump_stack+0x20/0x28)
    [  639.070442] [<c02c99a0>] (dump_stack) from [<c0024ca8>] (warn_slowpath_common+0x88/0xc0)
    [  639.078541] [<c0024ca8>] (warn_slowpath_common) from [<c0024d0c>] (warn_slowpath_null+0x2c/0x34)
    [  639.087332] [<c0024d0c>] (warn_slowpath_null) from [<c05171e8>] (clk_core_enable+0xc0/0x12c)
    [  639.095777] [<c05171e8>] (clk_core_enable) from [<c05172f8>] (clk_enable+0x2c/0x40)
    [  639.103441] [<c05172f8>] (clk_enable) from [<c0349880>] (imx_serial_port_suspend_noirq+0x20/0xe0)
    [  639.112336] [<c0349880>] (imx_serial_port_suspend_noirq) from [<c03a26a0>] (dpm_run_callback+0x68/0x16c)
    [  639.121825] [<c03a26a0>] (dpm_run_callback) from [<c03a2898>] (__device_suspend_noirq+0xf4/0x22c)
    [  639.130705] [<c03a2898>] (__device_suspend_noirq) from [<c03a4b0c>] (dpm_suspend_noirq+0x148/0x30c)
    [  639.139764] [<c03a4b0c>] (dpm_suspend_noirq) from [<c00511d4>] (suspend_devices_and_enter+0x2e8/0x6a4)
    [  639.149078] [<c00511d4>] (suspend_devices_and_enter) from [<c00518a0>] (pm_suspend+0x310/0x4b8)
    [  639.157782] [<c00518a0>] (pm_suspend) from [<c00500ec>] (state_store+0x7c/0xcc)
    [  639.165099] [<c00500ec>] (state_store) from [<c02cb6dc>] (kobj_attr_store+0x1c/0x28)
    [  639.172858] [<c02cb6dc>] (kobj_attr_store) from [<c01633d4>] (sysfs_kf_write+0x54/0x58)
    [  639.180871] [<c01633d4>] (sysfs_kf_write) from [<c01629b4>] (kernfs_fop_write+0x100/0x1c8)
    [  639.189152] [<c01629b4>] (kernfs_fop_write) from [<c00fb8b8>] (__vfs_write+0x3c/0xe8)
    [  639.196991] [<c00fb8b8>] (__vfs_write) from [<c00fc810>] (vfs_write+0xa4/0x160)
    [  639.204307] [<c00fc810>] (vfs_write) from [<c00fcac4>] (SyS_write+0x4c/0x98)
    [  639.211363] [<c00fcac4>] (SyS_write) from [<c0010760>] (ret_fast_syscall+0x0/0x3c)
    
    This does not happen for the common case of a single UART used as a console
    (since imx_console_setup() already does a prepare)
    
    Signed-off-by: Martin Fuzzey <mfuzzey@parkeon.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit a9a54caed96561d01f1d923df61bd11b71df4b93
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Jan 29 15:06:30 2016 +0100

    ARM: pxa: move extern declarations to pm.h
    
    When CONFIG_IWMMXT is disabled, we get a warning in pxa3xx.c:
    
    arch/arm/mach-pxa/pxa3xx.c: In function 'pxa3xx_cpu_pm_suspend':
    arch/arm/mach-pxa/pxa3xx.c:109:2: error: ISO C90 forbids mixed declarations and code [-Werror=declaration-after-statement]
    
    It turns out that there is an 'extern' declaration in the
    middle of a function.
    
    For consistency, this moves the declaration and two others from
    the same file into pm.h.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Robert Jarzmik <robert.jarzmik@free.fr>

commit 48d6d4f8e499a546f3bf03b1afefba59a5216e28
Author: Patrick Doyle <pdoyle@irobot.com>
Date:   Fri Oct 16 12:39:05 2015 +0200

    ARM: at91: pm: at91_pm_suspend_in_sram() must be 8-byte aligned
    
    commit 5fcf8d1a0e84792b2bc44922c5d833dab96a9c1e upstream.
    
    fncpy() requires that the source and the destination are both 8-byte
    aligned.
    
    Signed-off-by: Patrick Doyle <pdoyle@irobot.com>
    Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Acked-by: Nicolas Ferre <nicolas.ferre@atmel.com>
    Fixes: d94e688cae56 ("ARM: at91/pm: move the copying the sram function to the sram initialization phase")
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 7e84bf710a83452d594155e0392a2d138efc4d94
Author: Patrick Doyle <pdoyle@irobot.com>
Date:   Fri Oct 16 12:39:05 2015 +0200

    ARM: at91: pm: at91_pm_suspend_in_sram() must be 8-byte aligned
    
    commit 5fcf8d1a0e84792b2bc44922c5d833dab96a9c1e upstream.
    
    fncpy() requires that the source and the destination are both 8-byte
    aligned.
    
    Signed-off-by: Patrick Doyle <pdoyle@irobot.com>
    Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Acked-by: Nicolas Ferre <nicolas.ferre@atmel.com>
    Fixes: d94e688cae56 ("ARM: at91/pm: move the copying the sram function to the sram initialization phase")
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 3b389e9e73e0c5cc15d6e002129fc8b85aa700b6
Author: Patrick Doyle <pdoyle@irobot.com>
Date:   Fri Oct 16 12:39:05 2015 +0200

    ARM: at91: pm: at91_pm_suspend_in_sram() must be 8-byte aligned
    
    commit 5fcf8d1a0e84792b2bc44922c5d833dab96a9c1e upstream.
    
    fncpy() requires that the source and the destination are both 8-byte
    aligned.
    
    Signed-off-by: Patrick Doyle <pdoyle@irobot.com>
    Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Acked-by: Nicolas Ferre <nicolas.ferre@atmel.com>
    Fixes: d94e688cae56 ("ARM: at91/pm: move the copying the sram function to the sram initialization phase")
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 06bf403de344a8a0811ebd24992d2a08022c5225
Author: Imre Deak <imre.deak@intel.com>
Date:   Mon Nov 30 21:02:55 2015 +0200

    PCI / PM: Tune down retryable runtime suspend error messages
    
    The runtime PM core doesn't treat EBUSY and EAGAIN retvals from the driver
    suspend hooks as errors, but they still show up as errors in dmesg. Tune
    them down. See rpm_suspend() for details of handling these return values.
    
    Note that we use dev_dbg() for the retryable retvals, so after this
    change you'll need either CONFIG_DYNAMIC_DEBUG or CONFIG_PCI_DEBUG
    for them to show up in the log.
    
    One problem caused by this was noticed by Daniel: the i915 driver
    returns EAGAIN to signal a temporary failure to suspend and as a request
    towards the RPM core for scheduling a suspend again. This is a normal
    event, but the resulting error message flags a breakage during the
    driver's automated testing which parses dmesg and picks up the error.
    
    Reported-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: https://bugs.freedesktop.org/show_bug.cgi?id=92992
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 2e35c8833bc737a0c87a18e9b8c0de8495467d97
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Tue Nov 24 18:47:25 2015 +0200

    drm/i915: remove duplicate definition of for_each_power_domain
    
    commit b04c5bd6fda54703e56f29569e4bca489d6c5a5c
    Author: Borun Fu <borun.fu@intel.com>
    Date:   Sat Jul 12 10:02:27 2014 +0530
    
        drm/i915: Power gating display wells during i915_pm_suspend
    
    moved for_each_power_domain from intel_display.c to i915_drv.h but we
    still have the definition around in intel_display.c, due to a merge
    conflict resolution gone wrong in
    
    commit 4dac3edfe68e5e1b3c2216b84ba160572420fa40
    Merge: 487777673e35 e05444be705b
    Author: Daniel Vetter <daniel.vetter@ffwll.ch>
    Date:   Tue Jul 29 20:49:36 2014 +0200
    
        Merge remote-tracking branch 'airlied/drm-next' into drm-intel-next
    
    Just remove the extra definition left behind.
    
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1448383645-7615-1-git-send-email-jani.nikula@intel.com

commit 56e0464980febfa50432a070261579415c72664e
Merge: a5e1d715a8d0 b1e4006aeda8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Nov 10 14:56:23 2015 -0800

    Merge tag 'armsoc-soc' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC platform updates from Olof Johansson:
     "New and/or improved SoC support for this release:
    
      Marvell Berlin:
         - Enable standard DT-based cpufreq
         - Add CPU hotplug support
    
      Freescale:
         - Ethernet init for i.MX7D
         - Suspend/resume support for i.MX6UL
    
      Allwinner:
         - Support for R8 chipset (used on NTC's $9 C.H.I.P board)
    
      Mediatek:
         - SMP support for some platforms
    
      Uniphier:
         - L2 support
         - Cleaned up SMP support, etc.
    
      plus a handful of other patches around above functionality, and a few
      other smaller changes"
    
    * tag 'armsoc-soc' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (42 commits)
      ARM: uniphier: rework SMP operations to use trampoline code
      ARM: uniphier: add outer cache support
      Documentation: EXYNOS: Update bootloader interface on exynos542x
      ARM: mvebu: add broken-idle option
      ARM: orion5x: use mac_pton() helper
      ARM: at91: pm: at91_pm_suspend_in_sram() must be 8-byte aligned
      ARM: sunxi: Add R8 support
      ARM: digicolor: select pinctrl/gpio driver
      arm: berlin: add CPU hotplug support
      arm: berlin: use non-self-cleared reset register to reset cpu
      ARM: mediatek: add smp bringup code
      ARM: mediatek: enable gpt6 on boot up to make arch timer working
      soc: mediatek: Fix random hang up issue while kernel init
      soc: ti: qmss: make acc queue support optional in the driver
      soc: ti: add firmware file name as part of the driver
      Documentation: dt: soc: Add description for knav qmss driver
      ARM: S3C64XX: Use PWM lookup table for mach-smartq
      ARM: S3C64XX: Use PWM lookup table for mach-hmt
      ARM: S3C64XX: Use PWM lookup table for mach-crag6410
      ARM: S3C64XX: Use PWM lookup table for smdk6410
      ...

commit 44024ce036e9b837b63f84004f1e63f2a277378a
Merge: fa54cda779ce 5fcf8d1a0e84
Author: Olof Johansson <olof@lixom.net>
Date:   Mon Oct 26 09:44:48 2015 +0900

    Merge tag 'at91-ab-soc2' of git://git.kernel.org/pub/scm/linux/kernel/git/abelloni/linux into next/soc
    
    More SoC changes for 4.4:
     - a great fix for PM/suspend/resume
    
    * tag 'at91-ab-soc2' of git://git.kernel.org/pub/scm/linux/kernel/git/abelloni/linux:
      ARM: at91: pm: at91_pm_suspend_in_sram() must be 8-byte aligned
    
    Signed-off-by: Olof Johansson <olof@lixom.net>

commit 5fcf8d1a0e84792b2bc44922c5d833dab96a9c1e
Author: Patrick Doyle <pdoyle@irobot.com>
Date:   Fri Oct 16 12:39:05 2015 +0200

    ARM: at91: pm: at91_pm_suspend_in_sram() must be 8-byte aligned
    
    fncpy() requires that the source and the destination are both 8-byte
    aligned.
    
    Signed-off-by: Patrick Doyle <pdoyle@irobot.com>
    Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Acked-by: Nicolas Ferre <nicolas.ferre@atmel.com>
    Fixes: d94e688cae56 ("ARM: at91/pm: move the copying the sram function to the sram initialization phase")
    Cc: <stable@vger.kernel.org> # 4.1+

commit 1c5dd13459fe7caaeda82f7be878720c978d26f2
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Oct 7 03:03:57 2015 +0200

    input: i8042: Avoid resetting controller on system suspend/resume
    
    If the upcoming system suspend is not going to be handled by the
    platform firmware, like in the suspend-to-idle case, it is not
    necessary to reset the controller in i8042_pm_suspend(), so avoid
    doing that.
    
    Moreover, if the system resume currently in progress has not been
    started by the platform firmware, like in the suspend-to-idle case,
    i8042_controller_resume() need not be called by i8042_pm_resume(),
    so avoid doing that too in that case.
    
    Additionally, try to catch the event that woke up the system by
    calling the interrupt handler early during system resume if it has
    not been started by the platform firmware.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

commit a9cb0fe4895cae95b49934af6fdcc54aa04e723d
Author: Loic Poulain <loic.poulain@intel.com>
Date:   Fri Sep 4 17:39:25 2015 +0200

    Bluetooth: hci_intel: Fix warnings due to unused lpm functions
    
    intel_lpm_suspend/resume are only used in case of CONFIG_PM.
    
    Signed-off-by: Loic Poulain <loic.poulain@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

commit aa6802df09fe324c2c19d75ab1a9a001cd7e4d4a
Author: Loic Poulain <loic.poulain@intel.com>
Date:   Wed Sep 2 12:04:12 2015 +0200

    Bluetooth: hci_intel: Add PM support
    
    Add PM suspend/resume callbacks which call lpm_suspend/resume.
    Add LPM ack in threaded IRQ handler to notify the controller that
    resume is complete.
    Protect hci_uart against concurrent removing during suspend/resume.
    
    Signed-off-by: Loic Poulain <loic.poulain@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

commit 769b5cf78e6c653c2f513649ee6c4e7a06723872
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Wed Sep 9 13:42:54 2015 +0200

    irqchip/renesas-intc-irqpin: Use a separate lockdep class
    
    The renesas-intc-irqpin interrupt controller is cascaded to the GIC.
    Hence when propagating wake-up settings to its parent interrupt
    controller, the following lockdep warning is printed:
    
        =============================================
        [ INFO: possible recursive locking detected ]
        4.2.0-armadillo-10725-g50fcd7643c034198 #781 Not tainted
        ---------------------------------------------
        s2ram/1179 is trying to acquire lock:
        (&irq_desc_lock_class){-.-...}, at: [<c005bb54>] __irq_get_desc_lock+0x78/0x94
    
        but task is already holding lock:
        (&irq_desc_lock_class){-.-...}, at: [<c005bb54>] __irq_get_desc_lock+0x78/0x94
    
        other info that might help us debug this:
        Possible unsafe locking scenario:
    
              CPU0
              ----
         lock(&irq_desc_lock_class);
         lock(&irq_desc_lock_class);
    
        *** DEADLOCK ***
    
        May be due to missing lock nesting notation
    
        7 locks held by s2ram/1179:
        #0:  (sb_writers#7){.+.+.+}, at: [<c00c9708>] __sb_start_write+0x64/0xb8
        #1:  (&of->mutex){+.+.+.}, at: [<c0125a00>] kernfs_fop_write+0x78/0x1a0
        #2:  (s_active#23){.+.+.+}, at: [<c0125a08>] kernfs_fop_write+0x80/0x1a0
        #3:  (autosleep_lock){+.+.+.}, at: [<c0058244>] pm_autosleep_lock+0x18/0x20
        #4:  (pm_mutex){+.+.+.}, at: [<c0057e50>] pm_suspend+0x54/0x248
        #5:  (&dev->mutex){......}, at: [<c0243a20>] __device_suspend+0xdc/0x240
        #6:  (&irq_desc_lock_class){-.-...}, at: [<c005bb54>] __irq_get_desc_lock+0x78/0x94
    
        stack backtrace:
        CPU: 0 PID: 1179 Comm: s2ram Not tainted 4.2.0-armadillo-10725-g50fcd7643c034198
    
        Hardware name: Generic R8A7740 (Flattened Device Tree)
        [<c00129f4>] (dump_backtrace) from [<c0012bec>] (show_stack+0x18/0x1c)
        [<c0012bd4>] (show_stack) from [<c03f5d94>] (dump_stack+0x20/0x28)
        [<c03f5d74>] (dump_stack) from [<c00514d4>] (__lock_acquire+0x67c/0x1b88)
        [<c0050e58>] (__lock_acquire) from [<c0052df8>] (lock_acquire+0x9c/0xbc)
        [<c0052d5c>] (lock_acquire) from [<c03fb068>] (_raw_spin_lock_irqsave+0x44/0x58)
        [<c03fb024>] (_raw_spin_lock_irqsave) from [<c005bb54>] (__irq_get_desc_lock+0x78/0x94
        [<c005badc>] (__irq_get_desc_lock) from [<c005c3d8>] (irq_set_irq_wake+0x28/0x100)
        [<c005c3b0>] (irq_set_irq_wake) from [<c01e50d0>] (intc_irqpin_irq_set_wake+0x24/0x4c)
        [<c01e50ac>] (intc_irqpin_irq_set_wake) from [<c005c17c>] (set_irq_wake_real+0x3c/0x50
        [<c005c140>] (set_irq_wake_real) from [<c005c414>] (irq_set_irq_wake+0x64/0x100)
        [<c005c3b0>] (irq_set_irq_wake) from [<c02a19b4>] (gpio_keys_suspend+0x60/0xa0)
        [<c02a1954>] (gpio_keys_suspend) from [<c023b750>] (platform_pm_suspend+0x3c/0x5c)
    
    Avoid this false positive by using a separate lockdep class for INTC
    External IRQ Pin interrupts.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Cc: Grygorii Strashko <grygorii.strashko@ti.com>
    Cc: Magnus Damm <magnus.damm@gmail.com>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Link: http://lkml.kernel.org/r/1441798974-25716-3-git-send-email-geert%2Brenesas@glider.be
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit b1370658804510f6a1c0517a8ff1c9534d371edd
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Wed Sep 9 13:42:53 2015 +0200

    irqchip/renesas-irqc: Use a separate lockdep class
    
    The renesas-irqc interrupt controller is cascaded to the GIC. Hence when
    propagating wake-up settings to its parent interrupt controller, the
    following lockdep warning is printed:
    
        =============================================
        [ INFO: possible recursive locking detected ]
        4.2.0-ape6evm-10725-g50fcd7643c034198 #280 Not tainted
        ---------------------------------------------
        s2ram/1072 is trying to acquire lock:
        (&irq_desc_lock_class){-.-...}, at: [<c008d3fc>] __irq_get_desc_lock+0x58/0x98
    
        but task is already holding lock:
        (&irq_desc_lock_class){-.-...}, at: [<c008d3fc>] __irq_get_desc_lock+0x58/0x98
    
        other info that might help us debug this:
        Possible unsafe locking scenario:
    
              CPU0
              ----
         lock(&irq_desc_lock_class);
         lock(&irq_desc_lock_class);
    
        *** DEADLOCK ***
    
        May be due to missing lock nesting notation
    
        6 locks held by s2ram/1072:
        #0:  (sb_writers#7){.+.+.+}, at: [<c012eb14>] __sb_start_write+0xa0/0xa8
        #1:  (&of->mutex){+.+.+.}, at: [<c019396c>] kernfs_fop_write+0x4c/0x1bc
        #2:  (s_active#24){.+.+.+}, at: [<c0193974>] kernfs_fop_write+0x54/0x1bc
        #3:  (pm_mutex){+.+.+.}, at: [<c008213c>] pm_suspend+0x10c/0x510
        #4:  (&dev->mutex){......}, at: [<c02af3c4>] __device_suspend+0xdc/0x2cc
        #5:  (&irq_desc_lock_class){-.-...}, at: [<c008d3fc>] __irq_get_desc_lock+0x58/0x98
    
        stack backtrace:
        CPU: 0 PID: 1072 Comm: s2ram Not tainted 4.2.0-ape6evm-10725-g50fcd7643c034198 #280
        Hardware name: Generic R8A73A4 (Flattened Device Tree)
        [<c0018078>] (unwind_backtrace) from [<c00144f0>] (show_stack+0x10/0x14)
        [<c00144f0>] (show_stack) from [<c0451f14>] (dump_stack+0x88/0x98)
        [<c0451f14>] (dump_stack) from [<c007b29c>] (__lock_acquire+0x15cc/0x20e4)
        [<c007b29c>] (__lock_acquire) from [<c007c6e0>] (lock_acquire+0xac/0x12c)
        [<c007c6e0>] (lock_acquire) from [<c0457c00>] (_raw_spin_lock_irqsave+0x40/0x54)
        [<c0457c00>] (_raw_spin_lock_irqsave) from [<c008d3fc>] (__irq_get_desc_lock+0x58/0x98)
        [<c008d3fc>] (__irq_get_desc_lock) from [<c008ebbc>] (irq_set_irq_wake+0x20/0xf8)
        [<c008ebbc>] (irq_set_irq_wake) from [<c0260770>] (irqc_irq_set_wake+0x20/0x4c)
        [<c0260770>] (irqc_irq_set_wake) from [<c008ec28>] (irq_set_irq_wake+0x8c/0xf8)
        [<c008ec28>] (irq_set_irq_wake) from [<c02cb8c0>] (gpio_keys_suspend+0x74/0xc0)
        [<c02cb8c0>] (gpio_keys_suspend) from [<c02ae8cc>] (dpm_run_callback+0x54/0x124)
    
    Avoid this false positive by using a separate lockdep class for IRQC
    interrupts.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Cc: Grygorii Strashko <grygorii.strashko@ti.com>
    Cc: Magnus Damm <magnus.damm@gmail.com>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Link: http://lkml.kernel.org/r/1441798974-25716-2-git-send-email-geert%2Brenesas@glider.be
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit dc2280ebf45bfa4fbc4b1588a6642aa33454a9b8
Author: Wang Dongsheng <dongsheng.wang@freescale.com>
Date:   Wed Aug 12 17:14:13 2015 +0800

    rtc: ds3232: fix WARNING trace in resume function
    
    If ds3232 work on some platform that is not implementing
    irq_set_wake, ds3232 will get a WARNING trace in resume.
    So fix ds3232->suspended state to false when irq_set_irq_wake
    return error.
    
    WARNING: CPU: 0 PID: 729 at kernel/irq/manage.c:604 irq_set_irq_wake+0x4b/0x8c()
    Unbalanced IRQ 201 wake disable
    Modules linked in:
    CPU: 0 PID: 729 Comm: sh Not tainted 3.12.19-rt30+ #25
    [<800107d9>] (unwind_backtrace+0x1/0x88) from [<8000e4ef>] (show_stack+0xb/0xc)
    [<8000e4ef>] (show_stack+0xb/0xc) from [<802b5fa9>] (dump_stack+0x4d/0x60)
    [<802b5fa9>] (dump_stack+0x4d/0x60) from [<800186dd>] (warn_slowpath_common+0x45/0x64)
    [<800186dd>] (warn_slowpath_common+0x45/0x64) from [<80018717>] (warn_slowpath_fmt+0x1b/0x24)
    [<80018717>] (warn_slowpath_fmt+0x1b/0x24) from [<8003a8d3>] (irq_set_irq_wake+0x4b/0x8c)
    [<8003a8d3>] (irq_set_irq_wake+0x4b/0x8c) from [<80204fcb>] (ds3232_resume+0x2d/0x36)
    [<80204fcb>] (ds3232_resume+0x2d/0x36) from [<801954c7>] (dpm_run_callback.isra.13+0xb/0x28)
    [<801954c7>] (dpm_run_callback.isra.13+0xb/0x28) from [<80195b1b>] (device_resume+0x7b/0xa2)
    [<80195b1b>] (device_resume+0x7b/0xa2) from [<80195f0f>] (dpm_resume+0xbb/0x19c)
    [<80195f0f>] (dpm_resume+0xbb/0x19c) from [<801960d9>] (dpm_resume_end+0x9/0x12)
    [<801960d9>] (dpm_resume_end+0x9/0x12) from [<80037e1d>] (suspend_devices_and_enter+0x17d/0x1d0)
    [<80037e1d>] (suspend_devices_and_enter+0x17d/0x1d0) from [<80037ee1>] (pm_suspend+0x71/0x128)
    [<80037ee1>] (pm_suspend+0x71/0x128) from [<80037449>] (state_store+0x6d/0x80)
    [<80037449>] (state_store+0x6d/0x80) from [<800af4d5>] (sysfs_write_file+0x9f/0xde)
    [<800af4d5>] (sysfs_write_file+0x9f/0xde) from [<8007a437>] (vfs_write+0x7b/0x104)
    [<8007a437>] (vfs_write+0x7b/0x104) from [<8007a7f7>] (SyS_write+0x27/0x48)
    [<8007a7f7>] (SyS_write+0x27/0x48) from [<8000c121>] (ret_fast_syscall+0x1/0x44)
    
    Signed-off-by: Wang Dongsheng <dongsheng.wang@freescale.com>
    Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>

commit fe8291e82b5d0b79b743683e5c0fb7e273f7a99a
Author: Grygorii Strashko <grygorii.strashko@ti.com>
Date:   Tue Sep 1 13:59:24 2015 -0700

    ARM: OMAP2+: omap-device: fix race deferred probe of omap_hsmmc vs omap_device_late_init
    
    Kernel fails to boot 50% of times (form build to build) with
    RT-patchset applied due to the following race - on late boot
    stages deferred_probe_work_func->omap_hsmmc_probe races with omap_device_late_ini.
    
    The same issue has been reported now on linux-next (4.3) by Keerthy [1]
    
    late_initcall
     - deferred_probe_initcal() tries to re-probe all pending driver's probe.
    
    - later on, some driver is probing in this case It's cpsw.c
      (but could be any other drivers)
      cpsw_init
      - platform_driver_register
        - really_probe
           - driver_bound
             - driver_deferred_probe_trigger
      and boot proceed.
      So, at this moment we have deferred_probe_work_func scheduled.
    
    late_initcall_sync
      - omap_device_late_init
        - omap_device_idle
    
    CPU1                                    CPU2
      - deferred_probe_work_func
        - really_probe
          - omap_hsmmc_probe
            - pm_runtime_get_sync
                                            late_initcall_sync
                                            - omap_device_late_init
                                                    if (od->_driver_status != BUS_NOTIFY_BOUND_DRIVER) {
                                                            if (od->_state == OMAP_DEVICE_STATE_ENABLED) {
                                                                    - omap_device_idle [ops - IP is disabled]
            - [fail]
            - pm_runtime_put_sync
              - omap_hsmmc_runtime_suspend [ooops!]
    
    == log ==
     omap_hsmmc 480b4000.mmc: unable to get vmmc regulator -517
     davinci_mdio 48485000.mdio: davinci mdio revision 1.6
     davinci_mdio 48485000.mdio: detected phy mask fffffff3
     libphy: 48485000.mdio: probed
     davinci_mdio 48485000.mdio: phy[2]: device 48485000.mdio:02, driver unknown
     davinci_mdio 48485000.mdio: phy[3]: device 48485000.mdio:03, driver unknown
     omap_hsmmc 480b4000.mmc: unable to get vmmc regulator -517
     cpsw 48484000.ethernet: Detected MACID = b4:99:4c:c7:d2:48
     cpsw 48484000.ethernet: cpsw: Detected MACID = b4:99:4c:c7:d2:49
     hctosys: unable to open rtc device (rtc0)
     omap_hsmmc 480b4000.mmc: omap_device_late_idle: enabled but no driver.  Idling
     ldousb: disabling
     Unhandled fault: imprecise external abort (0x1406) at 0x00000000
     [00000000] *pgd=00000000
     Internal error: : 1406 [#1] PREEMPT SMP ARM
     Modules linked in:
     CPU: 1 PID: 58 Comm: kworker/u4:1 Not tainted 4.1.2-rt1-00467-g6da3c0a-dirty #5
     Hardware name: Generic DRA74X (Flattened Device Tree)
     Workqueue: deferwq deferred_probe_work_func
     task: ee6ddb00 ti: edd3c000 task.ti: edd3c000
     PC is at omap_hsmmc_runtime_suspend+0x1c/0x12c
     LR is at _od_runtime_suspend+0xc/0x24
     pc : [<c0471998>]    lr : [<c0029590>]    psr: a0000013
     sp : edd3dda0  ip : ee6ddb00  fp : c07be540
     r10: 00000000  r9 : c07be540  r8 : 00000008
     r7 : 00000000  r6 : ee646c10  r5 : ee646c10  r4 : edd79380
     r3 : fa0b4100  r2 : 00000000  r1 : 00000000  r0 : ee646c10
     Flags: NzCv  IRQs on  FIQs on  Mode SVC_32  ISA ARM  Segment kernel
     Control: 10c5387d  Table: 8000406a  DAC: 00000015
     Process kworker/u4:1 (pid: 58, stack limit = 0xedd3c218)
     Stack: (0xedd3dda0 to 0xedd3e000)
     dda0: ee646c70 ee646c10 c0029584 00000000 00000008 c0029590 ee646c70 ee646c10
     ddc0: c0029584 c03adfb8 ee646c10 00000004 0000000c c03adff0 ee646c10 00000004
     dde0: 0000000c c03ae4ec 00000000 edd3c000 ee646c10 00000004 ee646c70 00000004
     de00: fa0b4000 c03aec20 ee6ddb00 ee646c10 00000004 ee646c70 ee646c10 fffffdfb
     de20: edd79380 00000000 fa0b4000 c03aee90 fffffdfb edd79000 ee646c00 c0474290
     de40: 00000000 edda24c0 edd79380 edc81f00 00000000 00000200 00000001 c06dd488
     de60: edda3960 ee646c10 ee646c10 c0824cc4 fffffdfb c0880c94 00000002 edc92600
     de80: c0836378 c03a7f84 ee646c10 c0824cc4 00000000 c0880c80 c0880c94 c03a6568
     dea0: 00000000 ee646c10 c03a66ac ee4f8000 00000000 00000001 edc92600 c03a4b40
     dec0: ee404c94 edc83c4c ee646c10 ee646c10 ee646c44 c03a63c4 ee646c10 ee646c10
     dee0: c0814448 c03a5aa8 ee646c10 c0814220 edd3c000 c03a5ec0 c0814250 ee6be400
     df00: edd3c000 c004e5bc ee6ddb01 00000078 ee6ddb00 ee4f8000 ee6be418 edd3c000
     df20: ee4f8028 00000088 c0836045 ee4f8000 ee6be400 c004e928 ee4f8028 00000000
     df40: c004e8ec 00000000 ee6bf1c0 ee6be400 c004e8ec 00000000 00000000 00000000
     df60: 00000000 c0053450 2e56fa97 00000000 afdffbd7 ee6be400 00000000 00000000
     df80: edd3df80 edd3df80 00000000 00000000 edd3df90 edd3df90 edd3dfac ee6bf1c0
     dfa0: c0053384 00000000 00000000 c000f668 00000000 00000000 00000000 00000000
     dfc0: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
     dfe0: 00000000 00000000 00000000 00000000 00000013 00000000 f1fc9d7e febfbdff
     [<c0471998>] (omap_hsmmc_runtime_suspend) from [<c0029590>] (_od_runtime_suspend+0xc/0x24)
     [<c0029590>] (_od_runtime_suspend) from [<c03adfb8>] (__rpm_callback+0x24/0x3c)
     [<c03adfb8>] (__rpm_callback) from [<c03adff0>] (rpm_callback+0x20/0x80)
     [<c03adff0>] (rpm_callback) from [<c03ae4ec>] (rpm_suspend+0xe4/0x618)
     [<c03ae4ec>] (rpm_suspend) from [<c03aee90>] (__pm_runtime_idle+0x60/0x80)
     [<c03aee90>] (__pm_runtime_idle) from [<c0474290>] (omap_hsmmc_probe+0x6bc/0xa7c)
     [<c0474290>] (omap_hsmmc_probe) from [<c03a7f84>] (platform_drv_probe+0x44/0xa4)
     [<c03a7f84>] (platform_drv_probe) from [<c03a6568>] (driver_probe_device+0x170/0x2b4)
     [<c03a6568>] (driver_probe_device) from [<c03a4b40>] (bus_for_each_drv+0x64/0x98)
     [<c03a4b40>] (bus_for_each_drv) from [<c03a63c4>] (device_attach+0x70/0x88)
     [<c03a63c4>] (device_attach) from [<c03a5aa8>] (bus_probe_device+0x84/0xac)
     [<c03a5aa8>] (bus_probe_device) from [<c03a5ec0>] (deferred_probe_work_func+0x58/0x88)
     [<c03a5ec0>] (deferred_probe_work_func) from [<c004e5bc>] (process_one_work+0x134/0x464)
     [<c004e5bc>] (process_one_work) from [<c004e928>] (worker_thread+0x3c/0x4fc)
     [<c004e928>] (worker_thread) from [<c0053450>] (kthread+0xcc/0xe4)
     [<c0053450>] (kthread) from [<c000f668>] (ret_from_fork+0x14/0x2c)
     Code: e594302c e593202c e584205c e594302c (e5932128)
     ---[ end trace 0000000000000002 ]---
    
    The issue happens because omap_device_late_init() do not take into
    account that some drivers are present, but their probes were not
    finished successfully and where deferred instead. This is the valid
    case, and omap_device_late_init() should not idle such devices.
    
    To fix this issue, the value of omap_device->_driver_status field
    should be checked not only for BUS_NOTIFY_BOUND_DRIVER (driver is
    present and has been bound to device successfully), but also checked
    for BUS_NOTIFY_BIND_DRIVER (driver about to be bound) - which means
    driver is present and there was try to bind it to device.
    
    [1] http://www.spinics.net/lists/arm-kernel/msg441880.html
    Cc: Tero Kristo <t-kristo@ti.com>
    Cc: Keerthy <j-keerthy@ti.com>
    Tested-by: Keerthy <j-keerthy@ti.com>
    Signed-off-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

commit a0a8bcf4670c2c696e6e83742539a5e0dd7a62d6
Author: Grygorii Strashko <grygorii.strashko@ti.com>
Date:   Mon Aug 17 15:35:23 2015 +0300

    gpiolib: irqchip: use different lockdep class for each gpio irqchip
    
    Since IRQ chip helpers were introduced drivers lose ability to
    register separate lockdep classes for each registered GPIO IRQ
    chip and the gpiolib now is using shared lockdep class for
    all GPIO IRQ chips (gpiochip_irq_lock_class).
    As result, lockdep will produce warning when there are min two
    stacked GPIO chips and all of them are interrupt controllers.
    
    HW configuration which generates lockdep warning (TI dra7-evm):
    
    [SOC GPIO bankA.gpioX]
      <- irq - [pcf875x.gpioY]
                <- irq - DevZ.enable_irq_wake(pcf_gpioY_irq);
    The issue was reported in [1] and discussed [2].
    
    =============================================
    [ INFO: possible recursive locking detected ]
    4.2.0-rc6-00013-g5d050ed-dirty #55 Not tainted
    ---------------------------------------------
    sh/63 is trying to acquire lock:
     (class){......}, at: [<c009b91c>] __irq_get_desc_lock+0x50/0x94
    
    but task is already holding lock:
     (class){......}, at: [<c009b91c>] __irq_get_desc_lock+0x50/0x94
    
    other info that might help us debug this:
     Possible unsafe locking scenario:
    
           CPU0
           ----
      lock(class);
      lock(class);
    
     *** DEADLOCK ***
    
     May be due to missing lock nesting notation
    
    7 locks held by sh/63:
     #0:  (sb_writers#4){.+.+.+}, at: [<c016bbb8>] vfs_write+0x13c/0x164
     #1:  (&of->mutex){+.+.+.}, at: [<c01debf4>] kernfs_fop_write+0x4c/0x1a0
     #2:  (s_active#36){.+.+.+}, at: [<c01debfc>] kernfs_fop_write+0x54/0x1a0
     #3:  (pm_mutex){+.+.+.}, at: [<c009758c>] pm_suspend+0xec/0x4c4
     #4:  (&dev->mutex){......}, at: [<c03f77f8>] __device_suspend+0xd4/0x398
     #5:  (&gpio->lock){+.+.+.}, at: [<c009b940>] __irq_get_desc_lock+0x74/0x94
     #6:  (class){......}, at: [<c009b91c>] __irq_get_desc_lock+0x50/0x94
    
    stack backtrace:
    CPU: 0 PID: 63 Comm: sh Not tainted 4.2.0-rc6-00013-g5d050ed-dirty #55
    Hardware name: Generic DRA74X (Flattened Device Tree)
    [<c0016e24>] (unwind_backtrace) from [<c0013338>] (show_stack+0x10/0x14)
    [<c0013338>] (show_stack) from [<c05f6b24>] (dump_stack+0x84/0x9c)
    [<c05f6b24>] (dump_stack) from [<c00903f4>] (__lock_acquire+0x19c0/0x1e20)
    [<c00903f4>] (__lock_acquire) from [<c0091098>] (lock_acquire+0xa8/0x128)
    [<c0091098>] (lock_acquire) from [<c05fd61c>] (_raw_spin_lock_irqsave+0x38/0x4c)
    [<c05fd61c>] (_raw_spin_lock_irqsave) from [<c009b91c>] (__irq_get_desc_lock+0x50/0x94)
    [<c009b91c>] (__irq_get_desc_lock) from [<c009c4f4>] (irq_set_irq_wake+0x20/0xfc)
    [<c009c4f4>] (irq_set_irq_wake) from [<c0393ac4>] (pcf857x_irq_set_wake+0x24/0x54)
    [<c0393ac4>] (pcf857x_irq_set_wake) from [<c009c560>] (irq_set_irq_wake+0x8c/0xfc)
    [<c009c560>] (irq_set_irq_wake) from [<c04a02ac>] (gpio_keys_suspend+0x70/0xd4)
    [<c04a02ac>] (gpio_keys_suspend) from [<c03f6a00>] (dpm_run_callback+0x50/0x124)
    [<c03f6a00>] (dpm_run_callback) from [<c03f7830>] (__device_suspend+0x10c/0x398)
    [<c03f7830>] (__device_suspend) from [<c03f90f0>] (dpm_suspend+0x134/0x2f4)
    [<c03f90f0>] (dpm_suspend) from [<c0096e20>] (suspend_devices_and_enter+0xa8/0x728)
    [<c0096e20>] (suspend_devices_and_enter) from [<c00977cc>] (pm_suspend+0x32c/0x4c4)
    [<c00977cc>] (pm_suspend) from [<c0096060>] (state_store+0x64/0xb8)
    [<c0096060>] (state_store) from [<c01dec64>] (kernfs_fop_write+0xbc/0x1a0)
    [<c01dec64>] (kernfs_fop_write) from [<c016b280>] (__vfs_write+0x20/0xd8)
    [<c016b280>] (__vfs_write) from [<c016bb0c>] (vfs_write+0x90/0x164)
    [<c016bb0c>] (vfs_write) from [<c016c330>] (SyS_write+0x44/0x9c)
    [<c016c330>] (SyS_write) from [<c000f500>] (ret_fast_syscall+0x0/0x54)
    
    Lets fix it by using separate lockdep class for each registered GPIO
    IRQ Chip. This is done by wrapping gpiochip_irqchip_add call into macros.
    
    The implementation of this patch inspired by solution done by Nicolas
    Boichat for regmap [3]
    
    [1] http://www.spinics.net/lists/linux-gpio/msg05844.html
    [2] http://www.spinics.net/lists/linux-gpio/msg06021.html
    [3] http://www.spinics.net/lists/arm-kernel/msg429834.html
    
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Roger Quadros <rogerq@ti.com>
    Reported-by: Roger Quadros <rogerq@ti.com>
    Tested-by: Roger Quadros <rogerq@ti.com>
    Signed-off-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

commit 8b14821a5c45e3472082c60723ca54cf2fe9c2f3
Author: Daniel Baluta <daniel.baluta@intel.com>
Date:   Tue Jul 14 17:56:52 2015 +0300

    iio: magnetometer: mmc35240: Fix crash in pm suspend
    
    We must set i2c client private data at probe in order to
    correctly retrieve it in pm suspend/resume, preventing
    the following crash:
    
    [ 321.790582] PM: Syncing filesystems ... done.
    [ 322.364440] PM: Preparing system for mem sleep
    [ 322.400047] PM: Entering mem sleep
    [ 322.462178] BUG: unable to handle kernel NULL pointer dereference at 0000036c
    [ 322.469119] IP: [<80e0b3d2>] mmc35240_suspend+0x12/0x30
    [ 322.474291] *pdpt = 000000002fd6f001 *pde = 0000000000000000
    [ 322.479967] Oops: 0000 1 PREEMPT SMP
    [ 322.496516] task: a86d0df0 ti: a8766000 task.ti: a8766000
    [ 322.570744] Call Trace:
    [ 322.573217] [<80c0d2d1>] pm_generic_suspend+0x21/0x30
    [ 322.578284] [<80d042ab>] i2c_device_pm_suspend+0x1b/0x30
    
    Signed-off-by: Daniel Baluta <daniel.baluta@intel.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

commit 9083905a2a13dec4093a9c35a9b7f60037b87672
Author: Johannes Weiner <hannes@cmpxchg.org>
Date:   Wed Jun 24 16:57:21 2015 -0700

    mm: page_alloc: inline should_alloc_retry()
    
    The should_alloc_retry() function was meant to encapsulate retry
    conditions of the allocator slowpath, but there are still checks
    remaining in the main function, and much of how the retrying is
    performed also depends on the OOM killer progress.  The physical
    separation of those conditions make the code hard to follow.
    
    Inline the should_alloc_retry() checks.  Notes:
    
    - The __GFP_NOFAIL check is already done in __alloc_pages_may_oom(),
      replace it with looping on OOM killer progress
    
    - The pm_suspended_storage() check is meant to skip the OOM killer
      when reclaim has no IO available, move to __alloc_pages_may_oom()
    
    - The order <= PAGE_ALLOC_COSTLY order is re-united with its original
      counterpart of checking whether reclaim actually made any progress
    
    Signed-off-by: Johannes Weiner <hannes@cmpxchg.org>
    Acked-by: Michal Hocko <mhocko@suse.cz>
    Cc: David Rientjes <rientjes@google.com>
    Cc: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
    Cc: Andrea Arcangeli <aarcange@redhat.com>
    Cc: Dave Chinner <david@fromorbit.com>
    Cc: Vlastimil Babka <vbabka@suse.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit 73fd965093417091ace8fb526da9f81261171589
Author: Luciano Coelho <luciano.coelho@intel.com>
Date:   Mon May 4 17:03:17 2015 +0300

    iwlwifi: mvm: clean net-detect info if device was reset during suspend
    
    commit a500e469ead055f35c7b2d0a1104e1bd58e34e70 upstream.
    
    If the device is reset during suspend with net-detect enabled, we
    leave the net-detect information dangling and this causes the next
    suspend to fail with a warning:
    
    [21795.351010] WARNING: at /root/iwlwifi/iwlwifi-stack-dev/drivers/net/wireless/iwlwifi/mvm/d3.c:989 __iwl_mvm_suspend.isra.6+0x2be/0x460 [iwlmvm]()
    [21795.353253] Modules linked in: iwlmvm(O) iwlwifi(O) mac80211(O) cfg80211(O) compat(O) [...]
    [21795.366168] CPU: 1 PID: 3645 Comm: bash Tainted: G           O 3.10.29-dev #1
    [21795.368785] Hardware name: Dell Inc. Latitude E6430/0CPWYR, BIOS A09 12/13/2012
    [21795.371441]  f8ec6748 f8ec6748 e51f3ce8 c168aa62 e51f3d10 c103a824 c1871238 f8ec6748
    [21795.374228]  000003dd f8eb982e f8eb982e 00000000 c3408ed4 c41edbbc e51f3d20 c103a862
    [21795.377006]  00000009 00000000 e51f3da8 f8eb982e c41ee3dc 00000004 e7970000 e51f3d74
    [21795.379792] Call Trace:
    [21795.382461]  [<c168aa62>] dump_stack+0x16/0x18
    [21795.385133]  [<c103a824>] warn_slowpath_common+0x64/0x80
    [21795.387803]  [<f8eb982e>] ? __iwl_mvm_suspend.isra.6+0x2be/0x460 [iwlmvm]
    [21795.390485]  [<f8eb982e>] ? __iwl_mvm_suspend.isra.6+0x2be/0x460 [iwlmvm]
    [21795.393124]  [<c103a862>] warn_slowpath_null+0x22/0x30
    [21795.395787]  [<f8eb982e>] __iwl_mvm_suspend.isra.6+0x2be/0x460 [iwlmvm]
    [21795.398464]  [<f8eb9d7c>] iwl_mvm_suspend+0xec/0x140 [iwlmvm]
    [21795.401127]  [<c104be11>] ? del_timer_sync+0xa1/0xc0
    [21795.403800]  [<f8d4107e>] __ieee80211_suspend+0x1de/0xff0 [mac80211]
    [21795.406459]  [<c168e43d>] ? mutex_lock_nested+0x25d/0x350
    [21795.409084]  [<c1586b64>] ? rtnl_lock+0x14/0x20
    [21795.411685]  [<f8cf0076>] ieee80211_suspend+0x16/0x20 [mac80211]
    [21795.414318]  [<f8c4e014>] wiphy_suspend+0x74/0x710 [cfg80211]
    [21795.416916]  [<c141e612>] __device_suspend+0x1e2/0x220
    [21795.419521]  [<f8c4dfa0>] ? addresses_show+0xa0/0xa0 [cfg80211]
    [21795.422097]  [<c141f997>] dpm_suspend+0x67/0x210
    [21795.424661]  [<c141fd6f>] dpm_suspend_start+0x4f/0x60
    [21795.427219]  [<c108d8e0>] suspend_devices_and_enter+0x60/0x480
    [21795.429768]  [<c168646a>] ? printk+0x4d/0x4f
    [21795.432295]  [<c108de76>] pm_suspend+0x176/0x210
    [21795.434830]  [<c108ca5d>] state_store+0x5d/0xb0
    [21795.437410]  [<c108ca00>] ? wakeup_count_show+0x50/0x50
    [21795.439961]  [<c13208db>] kobj_attr_store+0x1b/0x30
    [21795.442514]  [<c11e3a4b>] sysfs_write_file+0xab/0x100
    [21795.445088]  [<c11e39a0>] ? sysfs_poll+0xa0/0xa0
    [21795.447659]  [<c1179655>] vfs_write+0xa5/0x1c0
    [21795.450212]  [<c1179af7>] SyS_write+0x57/0xa0
    [21795.452699]  [<c1699ec1>] sysenter_do_call+0x12/0x32
    [21795.455146] ---[ end trace faf5321baba2bfdb ]---
    
    To fix this, call the iwl_mvm_free_nd() function in case of any error
    during resume.  Additionally, rename the "out_unlock" label to err to
    make it clearer that it's only called in error conditions.
    
    Signed-off-by: Luciano Coelho <luciano.coelho@intel.com>
    Signed-off-by: Emmanuel Grumbach <emmanuel.grumbach@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 1045745742fc12c1320ccce849ca2810c6563f8d
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Thu Apr 30 11:42:54 2015 -0400

    drm/amdgpu: fix error handling in cz_dpm_hw_fini/cz_dpm_suspend
    
    Need to unlock the mutex on error.
    
    Noticed-by: Dan Carpenter <dan.carpenter@oracle.com>
    Reviewed-by: Christian König <christian.koenig@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

commit a500e469ead055f35c7b2d0a1104e1bd58e34e70
Author: Luciano Coelho <luciano.coelho@intel.com>
Date:   Mon May 4 17:03:17 2015 +0300

    iwlwifi: mvm: clean net-detect info if device was reset during suspend
    
    If the device is reset during suspend with net-detect enabled, we
    leave the net-detect information dangling and this causes the next
    suspend to fail with a warning:
    
    [21795.351010] WARNING: at /root/iwlwifi/iwlwifi-stack-dev/drivers/net/wireless/iwlwifi/mvm/d3.c:989 __iwl_mvm_suspend.isra.6+0x2be/0x460 [iwlmvm]()
    [21795.353253] Modules linked in: iwlmvm(O) iwlwifi(O) mac80211(O) cfg80211(O) compat(O) [...]
    [21795.366168] CPU: 1 PID: 3645 Comm: bash Tainted: G           O 3.10.29-dev #1
    [21795.368785] Hardware name: Dell Inc. Latitude E6430/0CPWYR, BIOS A09 12/13/2012
    [21795.371441]  f8ec6748 f8ec6748 e51f3ce8 c168aa62 e51f3d10 c103a824 c1871238 f8ec6748
    [21795.374228]  000003dd f8eb982e f8eb982e 00000000 c3408ed4 c41edbbc e51f3d20 c103a862
    [21795.377006]  00000009 00000000 e51f3da8 f8eb982e c41ee3dc 00000004 e7970000 e51f3d74
    [21795.379792] Call Trace:
    [21795.382461]  [<c168aa62>] dump_stack+0x16/0x18
    [21795.385133]  [<c103a824>] warn_slowpath_common+0x64/0x80
    [21795.387803]  [<f8eb982e>] ? __iwl_mvm_suspend.isra.6+0x2be/0x460 [iwlmvm]
    [21795.390485]  [<f8eb982e>] ? __iwl_mvm_suspend.isra.6+0x2be/0x460 [iwlmvm]
    [21795.393124]  [<c103a862>] warn_slowpath_null+0x22/0x30
    [21795.395787]  [<f8eb982e>] __iwl_mvm_suspend.isra.6+0x2be/0x460 [iwlmvm]
    [21795.398464]  [<f8eb9d7c>] iwl_mvm_suspend+0xec/0x140 [iwlmvm]
    [21795.401127]  [<c104be11>] ? del_timer_sync+0xa1/0xc0
    [21795.403800]  [<f8d4107e>] __ieee80211_suspend+0x1de/0xff0 [mac80211]
    [21795.406459]  [<c168e43d>] ? mutex_lock_nested+0x25d/0x350
    [21795.409084]  [<c1586b64>] ? rtnl_lock+0x14/0x20
    [21795.411685]  [<f8cf0076>] ieee80211_suspend+0x16/0x20 [mac80211]
    [21795.414318]  [<f8c4e014>] wiphy_suspend+0x74/0x710 [cfg80211]
    [21795.416916]  [<c141e612>] __device_suspend+0x1e2/0x220
    [21795.419521]  [<f8c4dfa0>] ? addresses_show+0xa0/0xa0 [cfg80211]
    [21795.422097]  [<c141f997>] dpm_suspend+0x67/0x210
    [21795.424661]  [<c141fd6f>] dpm_suspend_start+0x4f/0x60
    [21795.427219]  [<c108d8e0>] suspend_devices_and_enter+0x60/0x480
    [21795.429768]  [<c168646a>] ? printk+0x4d/0x4f
    [21795.432295]  [<c108de76>] pm_suspend+0x176/0x210
    [21795.434830]  [<c108ca5d>] state_store+0x5d/0xb0
    [21795.437410]  [<c108ca00>] ? wakeup_count_show+0x50/0x50
    [21795.439961]  [<c13208db>] kobj_attr_store+0x1b/0x30
    [21795.442514]  [<c11e3a4b>] sysfs_write_file+0xab/0x100
    [21795.445088]  [<c11e39a0>] ? sysfs_poll+0xa0/0xa0
    [21795.447659]  [<c1179655>] vfs_write+0xa5/0x1c0
    [21795.450212]  [<c1179af7>] SyS_write+0x57/0xa0
    [21795.452699]  [<c1699ec1>] sysenter_do_call+0x12/0x32
    [21795.455146] ---[ end trace faf5321baba2bfdb ]---
    
    To fix this, call the iwl_mvm_free_nd() function in case of any error
    during resume.  Additionally, rename the "out_unlock" label to err to
    make it clearer that it's only called in error conditions.
    
    Cc: stable@vger.kernel.org [3.19+]
    Signed-off-by: Luciano Coelho <luciano.coelho@intel.com>
    Signed-off-by: Emmanuel Grumbach <emmanuel.grumbach@intel.com>

commit dcfc7fb134afc3b8e3d1070ef6a6d6faa9d383ef
Author: Luciano Coelho <luciano.coelho@intel.com>
Date:   Tue Apr 28 08:41:55 2015 +0300

    iwlwifi: mvm: take the UCODE_DOWN reference when resuming
    
    The __iwl_mvm_resume() function always returns 1, which causes
    mac80211 to do a reconfig with IEEE80211_RECONFIG_TYPE_RESTART.  This
    type of reconfig calls iwl_mvm_restart_complete(), where we unref the
    IWL_MVM_REF_UCODE_DOWN, so we should always take the reference in this
    case.
    
    This prevents this kind of warning from happening:
    
    [40026.103025] WARNING: at /root/iwlwifi/iwlwifi-stack-dev/drivers/net/wireless/iwlwifi/mvm/mac80211.c:236 iwl_mvm_unref+0xc9/0xd0 [iwlmvm]()
    [40026.105145] Modules linked in: iwlmvm(O) iwlwifi(O) mac80211(O) cfg80211(O) compat(O) ctr ccm arc4 autofs4 snd_hda_codec_hdmi snd_hda_codec_idt joydev coretemp kvm_intel kvm aesni_intel ablk_helper cryptd lrw aes_i586 snd_hda_intel xts snd_hda_codec gf128mul snd_hwdep snd_pcm snd_seq_midi dell_wmi snd_rawmidi sparse_keymap snd_seq_midi_event snd_seq uvcvideo dell_laptop videobuf2_core dcdbas microcode videodev psmouse snd_timer videobuf2_vmalloc videobuf2_memops serio_raw snd_seq_device btusb i915 snd bluetooth lpc_ich drm_kms_helper soundcore snd_page_alloc drm i2c_algo_bit wmi parport_pc ppdev video binfmt_misc rpcsec_gss_krb5 nfsd mac_hid nfs_acl nfsv4 auth_rpcgss nfs fscache lockd sunrpc msdos lp parport sdhci_pci sdhci ahci libahci e1000e mmc_core ptp pps_core [last unloaded: compat]
    [40026.117640] CPU: 2 PID: 3827 Comm: bash Tainted: G        W  O 3.10.29-dev #1
    [40026.120216] Hardware name: Dell Inc. Latitude E6430/0CPWYR, BIOS A09 12/13/2012
    [40026.122815]  f8effd18 f8effd18 e740fd18 c168aa62 e740fd40 c103a824 c1871238 f8effd18
    [40026.125527]  000000ec f8ec79c9 f8ec79c9 d5d29ba4 d5d2a20c 00000000 e740fd50 c103a862
    [40026.128209]  00000009 00000000 e740fd7c f8ec79c9 f1c591c4 00000400 00000000 f8efb490
    [40026.130886] Call Trace:
    [40026.133506]  [<c168aa62>] dump_stack+0x16/0x18
    [40026.136115]  [<c103a824>] warn_slowpath_common+0x64/0x80
    [40026.138727]  [<f8ec79c9>] ? iwl_mvm_unref+0xc9/0xd0 [iwlmvm]
    [40026.141319]  [<f8ec79c9>] ? iwl_mvm_unref+0xc9/0xd0 [iwlmvm]
    [40026.143881]  [<c103a862>] warn_slowpath_null+0x22/0x30
    [40026.146453]  [<f8ec79c9>] iwl_mvm_unref+0xc9/0xd0 [iwlmvm]
    [40026.149030]  [<f8ec7a4d>] iwl_mvm_mac_reconfig_complete+0x7d/0x210 [iwlmvm]
    [40026.151645]  [<f8b74b20>] ? ftrace_raw_event_drv_reconfig_complete+0xc0/0xe0 [mac80211]
    [40026.154291]  [<f8b6769e>] ieee80211_reconfig+0x28e/0x2620 [mac80211]
    [40026.156920]  [<c10ef0ea>] ? ring_buffer_unlock_commit+0xba/0x100
    [40026.159585]  [<f8b4a04d>] ieee80211_resume+0x6d/0x80 [mac80211]
    [40026.162206]  [<f8a79722>] wiphy_resume+0x72/0x260 [cfg80211]
    [40026.164799]  [<c141e2e7>] ? device_resume+0x57/0x150
    [40026.167425]  [<f8a796b0>] ? wiphy_suspend+0x710/0x710 [cfg80211]
    [40026.170075]  [<c141e26e>] dpm_run_callback+0x2e/0x50
    [40026.172695]  [<c141e321>] device_resume+0x91/0x150
    [40026.175334]  [<c141f636>] dpm_resume+0xf6/0x200
    [40026.177922]  [<c141f920>] dpm_resume_end+0x10/0x20
    [40026.180489]  [<c108d9f7>] suspend_devices_and_enter+0x177/0x480
    [40026.183037]  [<c168646a>] ? printk+0x4d/0x4f
    [40026.185559]  [<c108de76>] pm_suspend+0x176/0x210
    [40026.188065]  [<c108ca5d>] state_store+0x5d/0xb0
    [40026.190581]  [<c108ca00>] ? wakeup_count_show+0x50/0x50
    [40026.193052]  [<c13208db>] kobj_attr_store+0x1b/0x30
    [40026.195608]  [<c11e3a4b>] sysfs_write_file+0xab/0x100
    [40026.198055]  [<c11e39a0>] ? sysfs_poll+0xa0/0xa0
    [40026.200469]  [<c1179655>] vfs_write+0xa5/0x1c0
    [40026.202893]  [<c1179af7>] SyS_write+0x57/0xa0
    [40026.205245]  [<c1699ec1>] sysenter_do_call+0x12/0x32
    [40026.207619] ---[ end trace db1d5a72a0381b0a ]---
    
    Signed-off-by: Luciano Coelho <luciano.coelho@intel.com>
    Reviewed-by: EliadX Peller <eliad@wizery.com>
    Reviewed-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: Emmanuel Grumbach <emmanuel.grumbach@intel.com>

commit e5ac320de1fe3ef5a5afa5f8a0cd19b0c5373a37
Merge: 7d2b6ef19cf0 89522f0f8bd5
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Apr 22 09:20:15 2015 -0700

    Merge tag 'armsoc-multiplatform' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC multiplatform code changes from Olof Johansson:
     "The changes here belong to two main platforms:
    
       - Atmel At91 is flipping the bit and going multiplatform.  This
         includes some cleanups and removal of code, and the final flip of
         config dependencies
    
       - Shmobile has several platforms that are going multiplatform, but
         this branch also contains a bunch of cleanups that they weren't
         able to keep separate in a good way.  THere's also a removal of one
         of their SoCs and the corresponding boards (sh7372 and mackerel)"
    
    * tag 'armsoc-multiplatform' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (67 commits)
      ARM: at91/pm: move AT91_MEMCTRL_* to pm.h
      ARM: at91/pm: move the standby functions to pm.c
      ARM: at91: fix pm_suspend.S compilation when ARMv6 is selected
      ARM: at91: add a Kconfig dependency on multi-platform
      ARM: at91: drop AT91_TIMER_HZ
      ARM: at91: remove hardware.h
      ARM: at91: remove SoC headers
      ARM: at91: remove useless mach/cpu.h
      ARM: at91: remove unused headers
      ARM: at91: switch at91_dt_defconfig to multiplatform
      ARM: at91: switch to multiplatform
      ARM: shmobile: r8a7778: enable multiplatform target
      ARM: shmobile: bockw: add sound to DT
      ARM: shmobile: r8a7778: add sound to DT
      ARM: shmobile: bockw: add devices hooked up to i2c0 to DT
      DT: i2c: add trivial binding for OKI ML86V7667 video decoder
      ARM: shmobile: r8a7778: common clock framework CPG driver
      ARM: shmobile: bockw dts: set extal clock frequency
      ARM: shmobile: bockw dts: Move Ethernet node to BSC
      ARM: shmobile: r8a73a4: Remove legacy code
      ...

commit 31f7dc796998d2967e999a0f9229d8a50c7b348d
Author: Krzysztof Kozlowski <krzk@kernel.org>
Date:   Tue Apr 14 22:24:13 2015 +0900

    ACPI / battery: Fix doubly added battery on system suspend
    
    Commit 297d716f6260 ("power_supply: Change ownership from driver to
    core") inverted the logic in battery_notify().  As an effect already
    present battery was re-added on each system suspend or hibernation.
    
        WARNING: CPU: 0 PID: 303 at ../fs/sysfs/dir.c:31 sysfs_warn_dup+0x68/0x80()
        sysfs: cannot create duplicate filename '/devices/LNXSYSTM:00/LNXSYBUS:00/PNP0A03:00/PNP0C0A:00/power_supply/BAT0'
        CPU: 0 PID: 303 Comm: rtcwake Not tainted 4.0.0-ARCH-02621-g07e6253af953 #48
        Call Trace:
          sysfs_create_dir_ns+0x8d/0xa0
          kobject_add_internal+0xb6/0x370
          kobject_add+0x6f/0xd0
          device_add+0x120/0x6c0
          __power_supply_register+0x145/0x290
          power_supply_register_no_ws+0x10/0x20
          sysfs_add_battery+0x84/0xc5 [battery]
          battery_notify+0x45/0x6b [battery]
          notifier_call_chain+0x4f/0x80
          __blocking_notifier_call_chain+0x4b/0x70
          blocking_notifier_call_chain+0x16/0x20
          pm_notifier_call_chain+0x1a/0x40
          pm_suspend+0x3ed/0x4e0
    
    Signed-off-by: Krzysztof Kozlowski <k.kozlowski.k@gmail.com>
    Reported-by: Linus Torvalds <torvalds@linux-foundation.org>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-By: Sebastian Reichel <sre@kernel.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit 89522f0f8bd5056dec21bb7de073cbd5886e435c
Merge: e8621d83c10e 2e57dc087c27
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Apr 14 01:50:21 2015 +0200

    Merge tag 'at91-cleanup4_bis' of git://git.kernel.org/pub/scm/linux/kernel/git/nferre/linux-at91 into next/multiplatform
    
    Pull "Fourth batch of cleanup for 4.1" from Nicolas Ferre:
    
    - 1 issues revealed by the kbuild test robot fixed
    - move of some functions and macros into relevant files to be able to
      streamline the at91 specific header afterwards
    
    * tag 'at91-cleanup4_bis' of git://git.kernel.org/pub/scm/linux/kernel/git/nferre/linux-at91:
      ARM: at91/pm: move AT91_MEMCTRL_* to pm.h
      ARM: at91/pm: move the standby functions to pm.c
      ARM: at91: fix pm_suspend.S compilation when ARMv6 is selected

commit 176a1b3dadf08835b9435bed4957daa066702a39
Author: Alexandre Belloni <alexandre.belloni@free-electrons.com>
Date:   Thu Mar 19 21:14:40 2015 +0100

    ARM: at91: fix pm_suspend.S compilation when ARMv6 is selected
    
    When compiling for multiplatform for both ARMv6 and ARMv7, the default compiler
    flags are for ARMv6, and results in:
    
    arch/arm/mach-at91/pm_suspend.S:144: Error: selected processor does not support ARM mode `dsb'
    
    Enforce ARMv7 flags for pm_suspend.o when CPU_V7 is selected.
    
    Reported-by: kbuild test robot <fengguang.wu@intel.com>
    Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Signed-off-by: Nicolas Ferre <nicolas.ferre@atmel.com>

commit 61e975e46864cbcf7707c980173bc7efe781edb5
Author: Imre Deak <imre.deak@intel.com>
Date:   Thu Jan 8 17:54:13 2015 +0200

    drm/i915: add dev_to_i915 helper
    
    commit 888d0d421663313739a8bf93459c6ba61fd4b121 upstream.
    
    This will be needed by later patches, so factor it out.
    
    No functional change.
    
    v2:
    - s/dev_to_i915_priv/dev_to_i915/ (Jani)
    - don't use the helper in i915_pm_suspend (Chris)
    - simplify the helper (Chris)
    v3:
    - remove redundant upcasting in the helper (Daniel)
    
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 6b37729bd184fdd44f144c6cc4951b06b55bcf4b
Author: Peter Huewe <peterhuewe@gmx.de>
Date:   Mon Mar 16 22:26:21 2015 +0100

    tpm/tpm_infineon: Use struct dev_pm_ops for power management
    
    Make the tpm_infineon driver define its PM callbacks through
    a struct dev_pm_ops object rather than by using legacy PM hooks
    in struct pnp_driver.
    
    This allows the driver to use tpm_pm_suspend() as its suspend
    callback directly, so we can remove the duplicated savestate code.
    
    Signed-off-by: Peter Huewe <peterhuewe@gmx.de>

commit 63fb2e854dd6c43f527d8cbe4d19c58ba2cc1ee3
Merge: 4c0714290c8d 598e085590fc
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Mar 13 22:08:58 2015 +0100

    Merge tag 'at91-cleanup2' of git://git.kernel.org/pub/scm/linux/kernel/git/nferre/linux-at91 into next/cleanup
    
    Pull "Second batch of cleanup for 4.1" from Nicolas Ferre:
    
    - remove unused matrix header files
    - dbgu + chip identification: new driver for SoC detection
      this allow to remove all additional io mapping
    - remove old non-standard AT91 setup code
    
    First batch of cleanup for 4.1:
      - little phy fixup that is not needed anymore
      - hudge cleanup of the PM code:
      - removal of "use slow clock" option => always use this for suspend to RAM
      - quicker suspend as the asm function is copied only once to SRAM
      - use of the same asm function for "standby" and "mem" types of suspend
        actions
      - adaptation to the ARMv7 processors
    
    * tag 'at91-cleanup2' of git://git.kernel.org/pub/scm/linux/kernel/git/nferre/linux-at91: (44 commits)
      ARM: at91: remove old setup
      ARM: at91: sama5d4: remove useless map_io
      ARM: at91: sama5 use SoC detection infrastructure
      ARM: at91: at91sam9: use SoC detection infrastructure
      ARM: at91: at91rm9200 use SoC detection infrastructure
      ARM: at91: add soc detection infrastructure
      ARM: at91/dt: introduce atmel,<chip>-dbgu
      ARM: at91: remove unused _matrix.h headers
      ARM: at91: remove unused at91_ioremap_matrix and header
      ARM: at91: remove NEED_MACH_IO_H
      ARM: at91/pm: flush data cache and clean, invalidate and disable the L2 cache
      ARM: at91/pm_suspend: add the WFI instruction support for ARMv7
      ARM: at91/pm: remove unused void (*at91_pm_standby)(void)
      ARM: at91/pm: rename function name: at91_slow_clock() --> at91_pm_suspend_sram_fn()
      ARM: at91/pm: rename file name: pm_slowclock.S --> pm_suspend.S
      ARM: at91/pm: standby mode uses same sram function as suspend to memory mode
      ARM: at91/pm: move the copying the sram function to the sram initialization phase
      ARM: at91/pm_slowclock: create the procedure to handle the sdram self-refresh
      ARM: at91/pm_slowclock: remove clocks which are already stopped when entering slow clock mode
      ARM: at91/pm: remove CONFIG_AT91_SLOW_CLOCK config option
      ...

commit 20567658b8f010eea287087bfdbeb25757801aed
Author: Wenyou Yang <wenyou.yang@atmel.com>
Date:   Mon Mar 9 11:53:46 2015 +0800

    ARM: at91/pm_suspend: add the WFI instruction support for ARMv7
    
    Add the WFI instruction to make the cpu to the idle state.
    In the meanwhile, disable the processor's clock.
    
    Signed-off-by: Wenyou Yang <wenyou.yang@atmel.com>
    Acked-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Tested-by: Sylvain Rochet <sylvain.rochet@finsecur.com>
    Signed-off-by: Nicolas Ferre <nicolas.ferre@atmel.com>

commit 5726a8b9686348e8d203f1bbf9d5fc1bb5899518
Author: Wenyou Yang <wenyou.yang@atmel.com>
Date:   Mon Mar 9 11:51:09 2015 +0800

    ARM: at91/pm: rename function name: at91_slow_clock() --> at91_pm_suspend_sram_fn()
    
    As the file name is renamed, rename the function name at91_slow_clock()
    --> at91_pm_suspend_sram_fn(), rename the function handler's name at the
    same time.
    
    Signed-off-by: Wenyou Yang <wenyou.yang@atmel.com>
    Acked-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Tested-by: Sylvain Rochet <sylvain.rochet@finsecur.com>
    [nicolas.ferre@atmel.com: little update of the commit message]
    Signed-off-by: Nicolas Ferre <nicolas.ferre@atmel.com>

commit 828b98fa380662406f9a84e09372b18e45babbf2
Author: Wenyou Yang <wenyou.yang@atmel.com>
Date:   Mon Mar 9 11:50:29 2015 +0800

    ARM: at91/pm: rename file name: pm_slowclock.S --> pm_suspend.S
    
    Because the sram function is used for both suspend to memory and the suspend
    to standby mode, renaming is more elegant.
    
    Signed-off-by: Wenyou Yang <wenyou.yang@atmel.com>
    Acked-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Tested-by: Sylvain Rochet <sylvain.rochet@finsecur.com>
    Signed-off-by: Nicolas Ferre <nicolas.ferre@atmel.com>

commit f13b2065de8147a1652b830ea5db961cf80c09df
Author: Rafael J. Wysocki <rjw@rjwysocki.net>
Date:   Mon Mar 9 17:03:07 2015 -0700

    Input: i8042 - allow KBD and AUX ports to wake up from suspend-to-idle
    
    While registering serio device for i8042, mark them as wakeup-capable
    and check their user space wakeup settings in i8042_pm_suspend() and
    i8042_pm_resume() to enable or disable, respectively, their interrupts
    to wake up the system.
    
    This makes it possible to use the PC keyboard to wake up the system
    from suspend-to-idle, among other things, after writing "enabled" to
    the keyboard serio device's power/wakeup sysfs attribute.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

commit 484c213b106c2b9188744666693d57bb9fd5affe
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Feb 27 05:50:22 2015 +0900

    ARM: S3C64XX: fix building without CONFIG_PM_SLEEP
    
    arch/arm/mach-s3c64xx/built-in.o: In function `s3c_pm_restore_core':
    :(.text+0x5d0): undefined reference to `s3c_pm_do_restore_core'
    :(.text+0x5d4): undefined reference to `s3c_pm_do_restore'
    arch/arm/mach-s3c64xx/built-in.o: In function `s3c_pm_save_core':
    :(.text+0x60c): undefined reference to `s3c_pm_do_save'
    arch/arm/mach-s3c64xx/built-in.o: In function `s3c64xx_irq_pm_resume':
    :(.text+0x670): undefined reference to `s3c_pm_do_restore'
    arch/arm/mach-s3c64xx/built-in.o: In function `s3c64xx_irq_pm_suspend':
    :(.text+0x6d8): undefined reference to `s3c_pm_do_save'
    arch/arm/mach-s3c64xx/built-in.o: In function `s3c_cpu_resume':
    :(.text+0x71c): undefined reference to `cpu_resume'
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Kukjin Kim <kgene@kernel.org>

commit 74d6b3ceaa17d111220c3f09f50f901bf955d7c8
Author: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
Date:   Thu Jan 29 07:43:47 2015 +0200

    tpm: fix suspend/resume paths for TPM 2.0
    
    Fixed suspend/resume paths for TPM 2.0 and consolidated all the
    associated code to the tpm_pm_suspend() and tpm_pm_resume()
    functions. Resume path should be handled by the firmware, i.e.
    Startup(CLEAR) for hibernate and Startup(STATE) for suspend.
    
    There might be some non-PC embedded devices in the future where
    Startup() is not the handled by the FW but fixing the code for
    those IMHO should be postponed until there is hardware available
    to test the fixes although extra Startup in the driver code is
    essentially a NOP.
    
    Added Shutdown(CLEAR) to the remove paths of TIS and CRB drivers.
    Changed tpm2_shutdown() to a void function because there isn't
    much you can do except print an error message if this fails with
    a system error.
    
    Fixes: aec04cbdf723 ("tpm: TPM 2.0 FIFO Interface")
    Fixes: 30fc8d138e91 ("tpm: TPM 2.0 CRB Interface")
    [phuewe: both did send TPM_Shutdown on resume which 'disables' the TPM
    and did not send TPM2_Shutdown on teardown which leads some TPM2.0 to
    believe there was an attack (no TPM2_Shutdown = no orderly shutdown =
    attack)]
    
    Reported-by: Peter Hüwe <PeterHuewe@gmx.de>
    Signed-off-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
    Tested-by: Scot Doyle <lkml14@scotdoyle.com>
    Reviewed-by: Peter Huewe <peterhuewe@gmx.de>
    Signed-off-by: Peter Huewe <peterhuewe@gmx.de>

commit 888d0d421663313739a8bf93459c6ba61fd4b121
Author: Imre Deak <imre.deak@intel.com>
Date:   Thu Jan 8 17:54:13 2015 +0200

    drm/i915: add dev_to_i915 helper
    
    This will be needed by later patches, so factor it out.
    
    No functional change.
    
    v2:
    - s/dev_to_i915_priv/dev_to_i915/ (Jani)
    - don't use the helper in i915_pm_suspend (Chris)
    - simplify the helper (Chris)
    v3:
    - remove redundant upcasting in the helper (Daniel)
    
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

commit 33339684de46070d34e1dc11b590971b20a3d25b
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Mon Oct 27 21:35:13 2014 +0900

    dmaengine: sirf: Add CONFIG_PM_SLEEP to suspend/resume functions
    
    Add CONFIG_PM_SLEEP to suspend/resume functions to fix the following
    build warning when CONFIG_PM_SLEEP is not selected. This is because
    sleep PM callbacks defined by SET_SYSTEM_SLEEP_PM_OPS are only used
    when the CONFIG_PM_SLEEP is enabled.
    
    drivers/dma/sirf-dma.c:838:12: warning: 'sirfsoc_dma_pm_suspend' defined but not used [-Wunused-function]
    drivers/dma/sirf-dma.c:879:12: warning: 'sirfsoc_dma_pm_resume' defined but not used [-Wunused-function]
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

commit 15e9f1d69c64b0a18c32867f8821c8dfe450b7ed
Author: Dmitry Eremin-Solenikov <dbaryshkov@gmail.com>
Date:   Thu Nov 6 14:08:29 2014 +0300

    spi: pxa2xx: toggle clocks on suspend if not disabled by runtime PM
    
    commit 2b9375b91bef65b837bed61a05fb387159b38ddf upstream.
    
    If PM_RUNTIME is enabled, it is easy to trigger the following backtrace
    on pxa2xx hosts:
    
    ------------[ cut here ]------------
    WARNING: CPU: 0 PID: 1 at /home/lumag/linux/arch/arm/mach-pxa/clock.c:35 clk_disable+0xa0/0xa8()
    Modules linked in:
    CPU: 0 PID: 1 Comm: swapper Not tainted 3.17.0-00007-g1b3d2ee-dirty #104
    [<c000de68>] (unwind_backtrace) from [<c000c078>] (show_stack+0x10/0x14)
    [<c000c078>] (show_stack) from [<c001d75c>] (warn_slowpath_common+0x6c/0x8c)
    [<c001d75c>] (warn_slowpath_common) from [<c001d818>] (warn_slowpath_null+0x1c/0x24)
    [<c001d818>] (warn_slowpath_null) from [<c0015e80>] (clk_disable+0xa0/0xa8)
    [<c0015e80>] (clk_disable) from [<c02507f8>] (pxa2xx_spi_suspend+0x2c/0x34)
    [<c02507f8>] (pxa2xx_spi_suspend) from [<c0200360>] (platform_pm_suspend+0x2c/0x54)
    [<c0200360>] (platform_pm_suspend) from [<c0207fec>] (dpm_run_callback.isra.14+0x2c/0x74)
    [<c0207fec>] (dpm_run_callback.isra.14) from [<c0209254>] (__device_suspend+0x120/0x2f8)
    [<c0209254>] (__device_suspend) from [<c0209a94>] (dpm_suspend+0x50/0x208)
    [<c0209a94>] (dpm_suspend) from [<c00455ac>] (suspend_devices_and_enter+0x8c/0x3a0)
    [<c00455ac>] (suspend_devices_and_enter) from [<c0045ad4>] (pm_suspend+0x214/0x2a8)
    [<c0045ad4>] (pm_suspend) from [<c04b5c34>] (test_suspend+0x14c/0x1dc)
    [<c04b5c34>] (test_suspend) from [<c000880c>] (do_one_initcall+0x8c/0x1fc)
    [<c000880c>] (do_one_initcall) from [<c04aecfc>] (kernel_init_freeable+0xf4/0x1b4)
    [<c04aecfc>] (kernel_init_freeable) from [<c0378078>] (kernel_init+0x8/0xec)
    [<c0378078>] (kernel_init) from [<c0009590>] (ret_from_fork+0x14/0x24)
    ---[ end trace 46524156d8faa4f6 ]---
    
    This happens because suspend function tries to disable a clock that is
    already disabled by runtime_suspend callback. Add if
    (!pm_runtime_suspended()) checks to suspend/resume path.
    
    Fixes: 7d94a505858 (spi/pxa2xx: add support for runtime PM)
    Signed-off-by: Dmitry Eremin-Solenikov <dbaryshkov@gmail.com>
    Reported-by: Andrea Adami <andrea.adami@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit b8edc5dc0ae741cba4b094b220cf8721db5192ec
Author: Dmitry Eremin-Solenikov <dbaryshkov@gmail.com>
Date:   Thu Nov 6 14:08:29 2014 +0300

    spi: pxa2xx: toggle clocks on suspend if not disabled by runtime PM
    
    commit 2b9375b91bef65b837bed61a05fb387159b38ddf upstream.
    
    If PM_RUNTIME is enabled, it is easy to trigger the following backtrace
    on pxa2xx hosts:
    
    ------------[ cut here ]------------
    WARNING: CPU: 0 PID: 1 at /home/lumag/linux/arch/arm/mach-pxa/clock.c:35 clk_disable+0xa0/0xa8()
    Modules linked in:
    CPU: 0 PID: 1 Comm: swapper Not tainted 3.17.0-00007-g1b3d2ee-dirty #104
    [<c000de68>] (unwind_backtrace) from [<c000c078>] (show_stack+0x10/0x14)
    [<c000c078>] (show_stack) from [<c001d75c>] (warn_slowpath_common+0x6c/0x8c)
    [<c001d75c>] (warn_slowpath_common) from [<c001d818>] (warn_slowpath_null+0x1c/0x24)
    [<c001d818>] (warn_slowpath_null) from [<c0015e80>] (clk_disable+0xa0/0xa8)
    [<c0015e80>] (clk_disable) from [<c02507f8>] (pxa2xx_spi_suspend+0x2c/0x34)
    [<c02507f8>] (pxa2xx_spi_suspend) from [<c0200360>] (platform_pm_suspend+0x2c/0x54)
    [<c0200360>] (platform_pm_suspend) from [<c0207fec>] (dpm_run_callback.isra.14+0x2c/0x74)
    [<c0207fec>] (dpm_run_callback.isra.14) from [<c0209254>] (__device_suspend+0x120/0x2f8)
    [<c0209254>] (__device_suspend) from [<c0209a94>] (dpm_suspend+0x50/0x208)
    [<c0209a94>] (dpm_suspend) from [<c00455ac>] (suspend_devices_and_enter+0x8c/0x3a0)
    [<c00455ac>] (suspend_devices_and_enter) from [<c0045ad4>] (pm_suspend+0x214/0x2a8)
    [<c0045ad4>] (pm_suspend) from [<c04b5c34>] (test_suspend+0x14c/0x1dc)
    [<c04b5c34>] (test_suspend) from [<c000880c>] (do_one_initcall+0x8c/0x1fc)
    [<c000880c>] (do_one_initcall) from [<c04aecfc>] (kernel_init_freeable+0xf4/0x1b4)
    [<c04aecfc>] (kernel_init_freeable) from [<c0378078>] (kernel_init+0x8/0xec)
    [<c0378078>] (kernel_init) from [<c0009590>] (ret_from_fork+0x14/0x24)
    ---[ end trace 46524156d8faa4f6 ]---
    
    This happens because suspend function tries to disable a clock that is
    already disabled by runtime_suspend callback. Add if
    (!pm_runtime_suspended()) checks to suspend/resume path.
    
    Fixes: 7d94a505858 (spi/pxa2xx: add support for runtime PM)
    Signed-off-by: Dmitry Eremin-Solenikov <dbaryshkov@gmail.com>
    Reported-by: Andrea Adami <andrea.adami@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit c822fb57ba12fbf0b989c201e400a5f71c9fade5
Author: Dmitry Eremin-Solenikov <dbaryshkov@gmail.com>
Date:   Thu Nov 6 14:08:29 2014 +0300

    spi: pxa2xx: toggle clocks on suspend if not disabled by runtime PM
    
    commit 2b9375b91bef65b837bed61a05fb387159b38ddf upstream.
    
    If PM_RUNTIME is enabled, it is easy to trigger the following backtrace
    on pxa2xx hosts:
    
    ------------[ cut here ]------------
    WARNING: CPU: 0 PID: 1 at /home/lumag/linux/arch/arm/mach-pxa/clock.c:35 clk_disable+0xa0/0xa8()
    Modules linked in:
    CPU: 0 PID: 1 Comm: swapper Not tainted 3.17.0-00007-g1b3d2ee-dirty #104
    [<c000de68>] (unwind_backtrace) from [<c000c078>] (show_stack+0x10/0x14)
    [<c000c078>] (show_stack) from [<c001d75c>] (warn_slowpath_common+0x6c/0x8c)
    [<c001d75c>] (warn_slowpath_common) from [<c001d818>] (warn_slowpath_null+0x1c/0x24)
    [<c001d818>] (warn_slowpath_null) from [<c0015e80>] (clk_disable+0xa0/0xa8)
    [<c0015e80>] (clk_disable) from [<c02507f8>] (pxa2xx_spi_suspend+0x2c/0x34)
    [<c02507f8>] (pxa2xx_spi_suspend) from [<c0200360>] (platform_pm_suspend+0x2c/0x54)
    [<c0200360>] (platform_pm_suspend) from [<c0207fec>] (dpm_run_callback.isra.14+0x2c/0x74)
    [<c0207fec>] (dpm_run_callback.isra.14) from [<c0209254>] (__device_suspend+0x120/0x2f8)
    [<c0209254>] (__device_suspend) from [<c0209a94>] (dpm_suspend+0x50/0x208)
    [<c0209a94>] (dpm_suspend) from [<c00455ac>] (suspend_devices_and_enter+0x8c/0x3a0)
    [<c00455ac>] (suspend_devices_and_enter) from [<c0045ad4>] (pm_suspend+0x214/0x2a8)
    [<c0045ad4>] (pm_suspend) from [<c04b5c34>] (test_suspend+0x14c/0x1dc)
    [<c04b5c34>] (test_suspend) from [<c000880c>] (do_one_initcall+0x8c/0x1fc)
    [<c000880c>] (do_one_initcall) from [<c04aecfc>] (kernel_init_freeable+0xf4/0x1b4)
    [<c04aecfc>] (kernel_init_freeable) from [<c0378078>] (kernel_init+0x8/0xec)
    [<c0378078>] (kernel_init) from [<c0009590>] (ret_from_fork+0x14/0x24)
    ---[ end trace 46524156d8faa4f6 ]---
    
    This happens because suspend function tries to disable a clock that is
    already disabled by runtime_suspend callback. Add if
    (!pm_runtime_suspended()) checks to suspend/resume path.
    
    Fixes: 7d94a505858 (spi/pxa2xx: add support for runtime PM)
    Signed-off-by: Dmitry Eremin-Solenikov <dbaryshkov@gmail.com>
    Reported-by: Andrea Adami <andrea.adami@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit a650b0c90ccaf86437e1c1c961c41a232fe8aca6
Author: Dmitry Eremin-Solenikov <dbaryshkov@gmail.com>
Date:   Thu Nov 6 14:08:29 2014 +0300

    spi: pxa2xx: toggle clocks on suspend if not disabled by runtime PM
    
    commit 2b9375b91bef65b837bed61a05fb387159b38ddf upstream.
    
    If PM_RUNTIME is enabled, it is easy to trigger the following backtrace
    on pxa2xx hosts:
    
    ------------[ cut here ]------------
    WARNING: CPU: 0 PID: 1 at /home/lumag/linux/arch/arm/mach-pxa/clock.c:35 clk_disable+0xa0/0xa8()
    Modules linked in:
    CPU: 0 PID: 1 Comm: swapper Not tainted 3.17.0-00007-g1b3d2ee-dirty #104
    [<c000de68>] (unwind_backtrace) from [<c000c078>] (show_stack+0x10/0x14)
    [<c000c078>] (show_stack) from [<c001d75c>] (warn_slowpath_common+0x6c/0x8c)
    [<c001d75c>] (warn_slowpath_common) from [<c001d818>] (warn_slowpath_null+0x1c/0x24)
    [<c001d818>] (warn_slowpath_null) from [<c0015e80>] (clk_disable+0xa0/0xa8)
    [<c0015e80>] (clk_disable) from [<c02507f8>] (pxa2xx_spi_suspend+0x2c/0x34)
    [<c02507f8>] (pxa2xx_spi_suspend) from [<c0200360>] (platform_pm_suspend+0x2c/0x54)
    [<c0200360>] (platform_pm_suspend) from [<c0207fec>] (dpm_run_callback.isra.14+0x2c/0x74)
    [<c0207fec>] (dpm_run_callback.isra.14) from [<c0209254>] (__device_suspend+0x120/0x2f8)
    [<c0209254>] (__device_suspend) from [<c0209a94>] (dpm_suspend+0x50/0x208)
    [<c0209a94>] (dpm_suspend) from [<c00455ac>] (suspend_devices_and_enter+0x8c/0x3a0)
    [<c00455ac>] (suspend_devices_and_enter) from [<c0045ad4>] (pm_suspend+0x214/0x2a8)
    [<c0045ad4>] (pm_suspend) from [<c04b5c34>] (test_suspend+0x14c/0x1dc)
    [<c04b5c34>] (test_suspend) from [<c000880c>] (do_one_initcall+0x8c/0x1fc)
    [<c000880c>] (do_one_initcall) from [<c04aecfc>] (kernel_init_freeable+0xf4/0x1b4)
    [<c04aecfc>] (kernel_init_freeable) from [<c0378078>] (kernel_init+0x8/0xec)
    [<c0378078>] (kernel_init) from [<c0009590>] (ret_from_fork+0x14/0x24)
    ---[ end trace 46524156d8faa4f6 ]---
    
    This happens because suspend function tries to disable a clock that is
    already disabled by runtime_suspend callback. Add if
    (!pm_runtime_suspended()) checks to suspend/resume path.
    
    Fixes: 7d94a505858 (spi/pxa2xx: add support for runtime PM)
    Signed-off-by: Dmitry Eremin-Solenikov <dbaryshkov@gmail.com>
    Reported-by: Andrea Adami <andrea.adami@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Luis Henriques <luis.henriques@canonical.com>

commit 45b5df583c2c1d0e68f09e18b6c88cf476c6354e
Author: Dmitry Eremin-Solenikov <dbaryshkov@gmail.com>
Date:   Thu Nov 6 14:08:29 2014 +0300

    spi: pxa2xx: toggle clocks on suspend if not disabled by runtime PM
    
    commit 2b9375b91bef65b837bed61a05fb387159b38ddf upstream.
    
    If PM_RUNTIME is enabled, it is easy to trigger the following backtrace
    on pxa2xx hosts:
    
    ------------[ cut here ]------------
    WARNING: CPU: 0 PID: 1 at /home/lumag/linux/arch/arm/mach-pxa/clock.c:35 clk_disable+0xa0/0xa8()
    Modules linked in:
    CPU: 0 PID: 1 Comm: swapper Not tainted 3.17.0-00007-g1b3d2ee-dirty #104
    [<c000de68>] (unwind_backtrace) from [<c000c078>] (show_stack+0x10/0x14)
    [<c000c078>] (show_stack) from [<c001d75c>] (warn_slowpath_common+0x6c/0x8c)
    [<c001d75c>] (warn_slowpath_common) from [<c001d818>] (warn_slowpath_null+0x1c/0x24)
    [<c001d818>] (warn_slowpath_null) from [<c0015e80>] (clk_disable+0xa0/0xa8)
    [<c0015e80>] (clk_disable) from [<c02507f8>] (pxa2xx_spi_suspend+0x2c/0x34)
    [<c02507f8>] (pxa2xx_spi_suspend) from [<c0200360>] (platform_pm_suspend+0x2c/0x54)
    [<c0200360>] (platform_pm_suspend) from [<c0207fec>] (dpm_run_callback.isra.14+0x2c/0x74)
    [<c0207fec>] (dpm_run_callback.isra.14) from [<c0209254>] (__device_suspend+0x120/0x2f8)
    [<c0209254>] (__device_suspend) from [<c0209a94>] (dpm_suspend+0x50/0x208)
    [<c0209a94>] (dpm_suspend) from [<c00455ac>] (suspend_devices_and_enter+0x8c/0x3a0)
    [<c00455ac>] (suspend_devices_and_enter) from [<c0045ad4>] (pm_suspend+0x214/0x2a8)
    [<c0045ad4>] (pm_suspend) from [<c04b5c34>] (test_suspend+0x14c/0x1dc)
    [<c04b5c34>] (test_suspend) from [<c000880c>] (do_one_initcall+0x8c/0x1fc)
    [<c000880c>] (do_one_initcall) from [<c04aecfc>] (kernel_init_freeable+0xf4/0x1b4)
    [<c04aecfc>] (kernel_init_freeable) from [<c0378078>] (kernel_init+0x8/0xec)
    [<c0378078>] (kernel_init) from [<c0009590>] (ret_from_fork+0x14/0x24)
    ---[ end trace 46524156d8faa4f6 ]---
    
    This happens because suspend function tries to disable a clock that is
    already disabled by runtime_suspend callback. Add if
    (!pm_runtime_suspended()) checks to suspend/resume path.
    
    Fixes: 7d94a505858 (spi/pxa2xx: add support for runtime PM)
    Signed-off-by: Dmitry Eremin-Solenikov <dbaryshkov@gmail.com>
    Reported-by: Andrea Adami <andrea.adami@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>

commit 67732cd34382066ae5df313b6dad65ab14b9735f
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Tue Nov 11 11:07:08 2014 +0100

    PM / Domains: Fix initial default state of the need_restore flag
    
    The initial state of the device's need_restore flag should'nt depend on
    the current state of the PM domain. For example it should be perfectly
    valid to attach an inactive device to a powered PM domain.
    
    The pm_genpd_dev_need_restore() API allow us to update the need_restore
    flag to somewhat cope with such scenarios. Typically that should have
    been done from drivers/buses ->probe() since it's those that put the
    requirements on the value of the need_restore flag.
    
    Until recently, the Exynos SOCs were the only user of the
    pm_genpd_dev_need_restore() API, though invoking it from a centralized
    location while adding devices to their PM domains.
    
    Due to that Exynos now have swithed to the generic OF-based PM domain
    look-up, it's no longer possible to invoke the API from a centralized
    location. The reason is because devices are now added to their PM
    domains during the probe sequence.
    
    Commit "ARM: exynos: Move to generic PM domain DT bindings"
    did the switch for Exynos to the generic OF-based PM domain look-up,
    but it also removed the call to pm_genpd_dev_need_restore(). This
    caused a regression for some of the Exynos drivers.
    
    To handle things more properly in the generic PM domain, let's change
    the default initial value of the need_restore flag to reflect that the
    state is unknown. As soon as some of the runtime PM callbacks gets
    invoked, update the initial value accordingly.
    
    Moreover, since the generic PM domain is verifying that all devices
    are both runtime PM enabled and suspended, using pm_runtime_suspended()
    while pm_genpd_poweroff() is invoked from the scheduled work, we can be
    sure of that the PM domain won't be powering off while having active
    devices.
    
    Do note that, the generic PM domain can still only know about active
    devices which has been activated through invoking its runtime PM resume
    callback. In other words, buses/drivers using pm_runtime_set_active()
    during ->probe() will still suffer from a race condition, potentially
    probing a device without having its PM domain being powered. That issue
    will have to be solved using a different approach.
    
    This a log from the boot regression for Exynos5, which is being fixed in
    this patch.
    
    ------------[ cut here ]------------
    WARNING: CPU: 0 PID: 308 at ../drivers/clk/clk.c:851 clk_disable+0x24/0x30()
    Modules linked in:
    CPU: 0 PID: 308 Comm: kworker/0:1 Not tainted 3.18.0-rc3-00569-gbd9449f-dirty #10
    Workqueue: pm pm_runtime_work
    [<c0013c64>] (unwind_backtrace) from [<c0010dec>] (show_stack+0x10/0x14)
    [<c0010dec>] (show_stack) from [<c03ee4cc>] (dump_stack+0x70/0xbc)
    [<c03ee4cc>] (dump_stack) from [<c0020d34>] (warn_slowpath_common+0x64/0x88)
    [<c0020d34>] (warn_slowpath_common) from [<c0020d74>] (warn_slowpath_null+0x1c/0x24)
    [<c0020d74>] (warn_slowpath_null) from [<c03107b0>] (clk_disable+0x24/0x30)
    [<c03107b0>] (clk_disable) from [<c02cc834>] (gsc_runtime_suspend+0x128/0x160)
    [<c02cc834>] (gsc_runtime_suspend) from [<c0249024>] (pm_generic_runtime_suspend+0x2c/0x38)
    [<c0249024>] (pm_generic_runtime_suspend) from [<c024f44c>] (pm_genpd_default_save_state+0x2c/0x8c)
    [<c024f44c>] (pm_genpd_default_save_state) from [<c024ff2c>] (pm_genpd_poweroff+0x224/0x3ec)
    [<c024ff2c>] (pm_genpd_poweroff) from [<c02501b4>] (pm_genpd_runtime_suspend+0x9c/0xcc)
    [<c02501b4>] (pm_genpd_runtime_suspend) from [<c024a4f8>] (__rpm_callback+0x2c/0x60)
    [<c024a4f8>] (__rpm_callback) from [<c024a54c>] (rpm_callback+0x20/0x74)
    [<c024a54c>] (rpm_callback) from [<c024a930>] (rpm_suspend+0xd4/0x43c)
    [<c024a930>] (rpm_suspend) from [<c024bbcc>] (pm_runtime_work+0x80/0x90)
    [<c024bbcc>] (pm_runtime_work) from [<c0032a9c>] (process_one_work+0x12c/0x314)
    [<c0032a9c>] (process_one_work) from [<c0032cf4>] (worker_thread+0x3c/0x4b0)
    [<c0032cf4>] (worker_thread) from [<c003747c>] (kthread+0xcc/0xe8)
    [<c003747c>] (kthread) from [<c000e738>] (ret_from_fork+0x14/0x3c)
    ---[ end trace 40cd58bcd6988f12 ]---
    
    Fixes: a4a8c2c4962bb655 (ARM: exynos: Move to generic PM domain DT bindings)
    Reported-and-tested0by: Sylwester Nawrocki <s.nawrocki@samsung.com>
    Reviewed-by: Sylwester Nawrocki <s.nawrocki@samsung.com>
    Reviewed-by: Kevin Hilman <khilman@linaro.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 2b9375b91bef65b837bed61a05fb387159b38ddf
Author: Dmitry Eremin-Solenikov <dbaryshkov@gmail.com>
Date:   Thu Nov 6 14:08:29 2014 +0300

    spi: pxa2xx: toggle clocks on suspend if not disabled by runtime PM
    
    If PM_RUNTIME is enabled, it is easy to trigger the following backtrace
    on pxa2xx hosts:
    
    ------------[ cut here ]------------
    WARNING: CPU: 0 PID: 1 at /home/lumag/linux/arch/arm/mach-pxa/clock.c:35 clk_disable+0xa0/0xa8()
    Modules linked in:
    CPU: 0 PID: 1 Comm: swapper Not tainted 3.17.0-00007-g1b3d2ee-dirty #104
    [<c000de68>] (unwind_backtrace) from [<c000c078>] (show_stack+0x10/0x14)
    [<c000c078>] (show_stack) from [<c001d75c>] (warn_slowpath_common+0x6c/0x8c)
    [<c001d75c>] (warn_slowpath_common) from [<c001d818>] (warn_slowpath_null+0x1c/0x24)
    [<c001d818>] (warn_slowpath_null) from [<c0015e80>] (clk_disable+0xa0/0xa8)
    [<c0015e80>] (clk_disable) from [<c02507f8>] (pxa2xx_spi_suspend+0x2c/0x34)
    [<c02507f8>] (pxa2xx_spi_suspend) from [<c0200360>] (platform_pm_suspend+0x2c/0x54)
    [<c0200360>] (platform_pm_suspend) from [<c0207fec>] (dpm_run_callback.isra.14+0x2c/0x74)
    [<c0207fec>] (dpm_run_callback.isra.14) from [<c0209254>] (__device_suspend+0x120/0x2f8)
    [<c0209254>] (__device_suspend) from [<c0209a94>] (dpm_suspend+0x50/0x208)
    [<c0209a94>] (dpm_suspend) from [<c00455ac>] (suspend_devices_and_enter+0x8c/0x3a0)
    [<c00455ac>] (suspend_devices_and_enter) from [<c0045ad4>] (pm_suspend+0x214/0x2a8)
    [<c0045ad4>] (pm_suspend) from [<c04b5c34>] (test_suspend+0x14c/0x1dc)
    [<c04b5c34>] (test_suspend) from [<c000880c>] (do_one_initcall+0x8c/0x1fc)
    [<c000880c>] (do_one_initcall) from [<c04aecfc>] (kernel_init_freeable+0xf4/0x1b4)
    [<c04aecfc>] (kernel_init_freeable) from [<c0378078>] (kernel_init+0x8/0xec)
    [<c0378078>] (kernel_init) from [<c0009590>] (ret_from_fork+0x14/0x24)
    ---[ end trace 46524156d8faa4f6 ]---
    
    This happens because suspend function tries to disable a clock that is
    already disabled by runtime_suspend callback. Add if
    (!pm_runtime_suspended()) checks to suspend/resume path.
    
    Fixes: 7d94a505858 (spi/pxa2xx: add support for runtime PM)
    Signed-off-by: Dmitry Eremin-Solenikov <dbaryshkov@gmail.com>
    Reported-by: Andrea Adami <andrea.adami@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Cc: stable@vger.kernel.org

commit f4c4a4e068a3f43b84bc1bcb9beb295dd5ff2529
Author: Nimrod Andy <B38611@freescale.com>
Date:   Mon Nov 3 13:26:50 2014 +0800

    net: fec: fix suspend broken on multiple MACs sillicons
    
    On i.MX6SX sdb platform, there has two same enet MACs, after system up,
    just eth0 is up, and then do suspend/resume test:
    
    [   50.437967] PM: Syncing filesystems ... done.
    [   50.476924] Freezing user space processes ... (elapsed 0.005 seconds) done.
    [   50.490093] Freezing remaining freezable tasks ... (elapsed 0.004 seconds) done.
    [   50.559771] ------------[ cut here ]------------
    [   50.564453] WARNING: CPU: 0 PID: 575 at drivers/clk/clk.c:851 __clk_disable+0x60/0x6c()
    [   50.572475] Modules linked in:
    [   50.575578] CPU: 0 PID: 575 Comm: sh Not tainted 3.18.0-rc2-next-20141031-00007-gf61135b #21
    [   50.584031] Backtrace:
    [   50.586550] [<80011ecc>] (dump_backtrace) from [<8001206c>] (show_stack+0x18/0x1c)
    [   50.594136]  r6:808a7a54 r5:00000000 r4:00000000 r3:00000000
    [   50.599920] [<80012054>] (show_stack) from [<806ab3c0>] (dump_stack+0x80/0x9c)
    [   50.607187] [<806ab340>] (dump_stack) from [<8002a3e8>] (warn_slowpath_common+0x6c/0x8c)
    [   50.615294]  r5:00000353 r4:00000000
    [   50.618940] [<8002a37c>] (warn_slowpath_common) from [<8002a42c>] (warn_slowpath_null+0x24/0x2c)
    [   50.627738]  r8:00000000 r7:be144c44 r6:be015600 r5:80070013 r4:be015600
    [   50.634573] [<8002a408>] (warn_slowpath_null) from [<804f8d4c>] (__clk_disable+0x60/0x6c)
    [   50.642777] [<804f8cec>] (__clk_disable) from [<804f8e5c>] (clk_disable+0x2c/0x38)
    [   50.650359]  r4:be015600 r3:00000000
    [   50.654006] [<804f8e30>] (clk_disable) from [<80420ab4>] (fec_enet_clk_enable+0xc4/0x258)
    [   50.662196]  r5:be3cb620 r4:be3cb000
    [   50.665838] [<804209f0>] (fec_enet_clk_enable) from [<80421178>] (fec_suspend+0x30/0x180)
    [   50.674026]  r7:be144c44 r6:be144c10 r5:8037f5a4 r4:be3cb000
    [   50.679802] [<80421148>] (fec_suspend) from [<8037f5d8>] (platform_pm_suspend+0x34/0x64)
    [   50.687906]  r10:00000000 r9:00000000 r8:00000000 r7:be144c44 r6:be144c10 r5:8037f5a4
    [   50.695852]  r4:be144c10 r3:80421148
    [   50.699511] [<8037f5a4>] (platform_pm_suspend) from [<8038784c>] (dpm_run_callback.isra.14+0x34/0x6c)
    [   50.708764] [<80387818>] (dpm_run_callback.isra.14) from [<80387f00>] (__device_suspend+0x12c/0x2a4)
    [   50.717909]  r9:8098ec8c r8:80973bec r6:00000002 r5:811c7038 r4:be144c10
    [   50.724746] [<80387dd4>] (__device_suspend) from [<803894fc>] (dpm_suspend+0x64/0x224)
    [   50.732675]  r8:80973bec r7:be144c10 r6:8098ec24 r5:811c7038 r4:be144cc4
    [   50.739509] [<80389498>] (dpm_suspend) from [<8038999c>] (dpm_suspend_start+0x60/0x68)
    [   50.747438]  r10:8082fa24 r9:00000000 r8:00000004 r7:00000003 r6:00000000 r5:8116ec80
    [   50.755386]  r4:00000002
    [   50.757969] [<8038993c>] (dpm_suspend_start) from [<800679d8>] (suspend_devices_and_enter+0x90/0x3ec)
    [   50.767202]  r4:00000003 r3:8116eca0
    [   50.770843] [<80067948>] (suspend_devices_and_enter) from [<80067f40>] (pm_suspend+0x20c/0x2a4)
    [   50.779553]  r8:00000004 r7:00000003 r6:00000000 r5:8116ec8c r4:00000003
    [   50.786394] [<80067d34>] (pm_suspend) from [<80066858>] (state_store+0x70/0xc0)
    [   50.793718]  r6:8116ec90 r5:00000003 r4:bd88a800 r3:0000006d
    [   50.799496] [<800667e8>] (state_store) from [<802b0384>] (kobj_attr_store+0x1c/0x28)
    [   50.807251]  r10:bd399f78 r8:00000000 r7:bd88a800 r6:bd88a800 r5:00000004 r4:bd085680
    [   50.815219] [<802b0368>] (kobj_attr_store) from [<80153090>] (sysfs_kf_write+0x54/0x58)
    [   50.823252] [<8015303c>] (sysfs_kf_write) from [<80151fd8>] (kernfs_fop_write+0xd0/0x194)
    [   50.831441]  r6:00000004 r5:bd08568c r4:bd085680 r3:8015303c
    [   50.837220] [<80151f08>] (kernfs_fop_write) from [<800eddb4>] (vfs_write+0xb8/0x1a8)
    [   50.844975]  r10:00000000 r9:00000000 r8:00000000 r7:bd399f78 r6:01336408 r5:00000004
    [   50.852924]  r4:bc584dc0
    [   50.855505] [<800edcfc>] (vfs_write) from [<800ee0b8>] (SyS_write+0x48/0x88)
    [   50.862567]  r10:00000000 r8:00000000 r7:01336408 r6:00000004 r5:bc584dc0 r4:bc584dc0
    [   50.870537] [<800ee070>] (SyS_write) from [<8000eb00>] (ret_fast_syscall+0x0/0x48)
    [   50.878120]  r9:bd398000 r8:8000ecc4 r7:00000004 r6:76f42b48 r5:01336408 r4:00000004
    [   50.885983] ---[ end trace 7545115d752a316a ]---
    [   50.890765] ------------[ cut here ]------------
    
    The root cause is that eth1 is not opened and clock is not enabled, and .suspend() still
    call .fec_enet_clk_enable() to disable clock.
    
    To avoid the broken, let it check network device up status by calling .netif_running()
    before disable/enable clocks.
    
    Signed-off-by: Fugang Duan <B38611@freescale.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit f042e9cbae607c323e3de86fc714b7306774a151
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Mon Oct 13 11:04:21 2014 +0200

    usb: musb: musb_dsps: fix NULL pointer in suspend
    
    So testing managed to configure musb in DMA mode but not load the
    matching cppi41 driver for DMA. This results in
    
    |musb-hdrc musb-hdrc.0.auto: Failed to request rx1.
    |musb-hdrc musb-hdrc.0.auto: musb_init_controller failed with status -517
    |platform musb-hdrc.0.auto: Driver musb-hdrc requests probe deferral
    
    which is "okay". Once the driver is loaded we re-try probing and
    everyone is happy. Until then if you try suspend say
        echo mem > /sys/power/state
    then you go boom
    
    |Unable to handle kernel NULL pointer dereference at virtual address 000003a4
    |pgd = cf50c000
    |[000003a4] *pgd=8f6a3831, *pte=00000000, *ppte=00000000
    |Internal error: Oops: 17 [#1] ARM
    |PC is at dsps_suspend+0x18/0x9c [musb_dsps]
    |LR is at dsps_suspend+0x18/0x9c [musb_dsps]
    |pc : [<bf08e268>] lr : [<bf08e268>] psr: a0000013
    |sp : cbd97e00 ip : c0af4394 fp : 00000000
    |r10: c0831d90 r9 : 00000002 r8 : cf6da410
    |r7 : c03ba4dc r6 : bf08f224 r5 : 00000000 r4 : cbc5fcd0
    |r3 : bf08e250 r2 : bf08f264 r1 : cf6da410 r0 : 00000000
    |[<bf08e268>] (dsps_suspend [musb_dsps]) from [<c03ba508>] (platform_pm_suspend+0x2c/0x54)
    |Code: e1a04000 e9900041 e2800010 eb4caa8e (e59053a4)
    
    because platform_get_drvdata(glue->musb) returns a NULL pointer as long as the
    device is not fully probed.
    
    Tested-by: George Cherian <george.cherian@ti.com>
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

commit c2dd114d24865662a6d7381b101741fc898a0059
Author: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
Date:   Thu Sep 25 17:59:41 2014 +0900

    ARM: EXYNOS: fix register setup for AFTR mode code
    
    Add S5P_CENTRAL_SEQ_OPTION register setup to cpuidle AFTR mode code
    by moving the relevant code from exynos_pm_suspend() (used only by
    suspend) to exynos_pm_central_suspend() (used by both suspend and
    AFTR).  Without this setup AFTR mode doesn't show any benefit over
    WFI one (at least on Exynos4412 SoC).  When this setup is applied
    AFTR mode reduces power consumption by ~12% (as measured on Trats2
    board).
    
    This change is a preparation for adding secure firmware support to
    EXYNOS cpuidle driver.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Acked-by: Kyungmin Park <kyungmin.park@samsung.com>
    Signed-off-by: Kukjin Kim <kgene.kim@samsung.com>

commit b528392669415dc1e53a047215e5ad6c2de879fc
Merge: 80213c03c415 9f1a05329695
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Oct 9 16:07:43 2014 -0400

    Merge tag 'pm+acpi-3.18-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull ACPI and power management updates from Rafael Wysocki:
     "Features-wise, to me the most important this time is a rework of
      wakeup interrupts handling in the core that makes them work
      consistently across all of the available sleep states, including
      suspend-to-idle.  Many thanks to Thomas Gleixner for his help with
      this work.
    
      Second is an update of the generic PM domains code that has been in
      need of some care for quite a while.  Unused code is being removed, DT
      support is being added and domains are now going to be attached to
      devices in bus type code in analogy with the ACPI PM domain.  The
      majority of work here was done by Ulf Hansson who also has been the
      most active developer this time.
    
      Apart from this we have a traditional ACPICA update, this time to
      upstream version 20140828 and a few ACPI wakeup interrupts handling
      patches on top of the general rework mentioned above.  There also are
      several cpufreq commits including renaming the cpufreq-cpu0 driver to
      cpufreq-dt, as this is what implements generic DT-based cpufreq
      support, and a new DT-based idle states infrastructure for cpuidle.
    
      In addition to that, the ACPI LPSS driver is updated, ACPI support for
      Apple machines is improved, a few bugs are fixed and a few cleanups
      are made all over.
    
      Finally, the Adaptive Voltage Scaling (AVS) subsystem now has a tree
      maintained by Kevin Hilman that will be merged through the PM tree.
    
      Numbers-wise, the generic PM domains update takes the lead this time
      with 32 non-merge commits, second is cpufreq (15 commits) and the 3rd
      place goes to the wakeup interrupts handling rework (13 commits).
    
      Specifics:
    
       - Rework the handling of wakeup IRQs by the IRQ core such that all of
         them will be switched over to "wakeup" mode in suspend_device_irqs()
         and in that mode the first interrupt will abort system suspend in
         progress or wake up the system if already in suspend-to-idle (or
         equivalent) without executing any interrupt handlers.  Among other
         things that eliminates the wakeup-related motivation to use the
         IRQF_NO_SUSPEND interrupt flag with interrupts which don't really
         need it and should not use it (Thomas Gleixner and Rafael Wysocki)
    
       - Switch over ACPI to handling wakeup interrupts with the help of the
         new mechanism introduced by the above IRQ core rework (Rafael Wysocki)
    
       - Rework the core generic PM domains code to eliminate code that's
         not used, add DT support and add a generic mechanism by which
         devices can be added to PM domains automatically during enumeration
         (Ulf Hansson, Geert Uytterhoeven and Tomasz Figa).
    
       - Add debugfs-based mechanics for debugging generic PM domains
         (Maciej Matraszek).
    
       - ACPICA update to upstream version 20140828.  Included are updates
         related to the SRAT and GTDT tables and the _PSx methods are in the
         METHOD_NAME list now (Bob Moore and Hanjun Guo).
    
       - Add _OSI("Darwin") support to the ACPI core (unfortunately, that
         can't really be done in a straightforward way) to prevent
         Thunderbolt from being turned off on Apple systems after boot (or
         after resume from system suspend) and rework the ACPI Smart Battery
         Subsystem (SBS) driver to work correctly with Apple platforms
         (Matthew Garrett and Andreas Noever).
    
       - ACPI LPSS (Low-Power Subsystem) driver update cleaning up the code,
         adding support for 133MHz I2C source clock on Intel Baytrail to it
         and making it avoid using UART RTS override with Auto Flow Control
         (Heikki Krogerus).
    
       - ACPI backlight updates removing the video_set_use_native_backlight
         quirk which is not necessary any more, making the code check the
         list of output devices returned by the _DOD method to avoid
         creating acpi_video interfaces that won't work and adding a quirk
         for Lenovo Ideapad Z570 (Hans de Goede, Aaron Lu and Stepan Bujnak)
    
       - New Win8 ACPI OSI quirks for some Dell laptops (Edward Lin)
    
       - Assorted ACPI code cleanups (Fabian Frederick, Rasmus Villemoes,
         Sudip Mukherjee, Yijing Wang, and Zhang Rui)
    
       - cpufreq core updates and cleanups (Viresh Kumar, Preeti U Murthy,
         Rasmus Villemoes)
    
       - cpufreq driver updates: cpufreq-cpu0/cpufreq-dt (driver name change
         among other things), ppc-corenet, powernv (Viresh Kumar, Preeti U
         Murthy, Shilpasri G Bhat, Lucas Stach)
    
       - cpuidle support for DT-based idle states infrastructure, new ARM64
         cpuidle driver, cpuidle core cleanups (Lorenzo Pieralisi, Rasmus
         Villemoes)
    
       - ARM big.LITTLE cpuidle driver updates: support for DT-based
         initialization and Exynos5800 compatible string (Lorenzo Pieralisi,
         Kevin Hilman)
    
       - Rework of the test_suspend kernel command line argument and a new
         trace event for console resume (Srinivas Pandruvada, Todd E Brandt)
    
       - Second attempt to optimize swsusp_free() (hibernation core) to make
         it avoid going through all PFNs which may be way too slow on some
         systems (Joerg Roedel)
    
       - devfreq updates (Paul Bolle, Punit Agrawal, Ãrjan Eide).
    
       - rockchip-io Adaptive Voltage Scaling (AVS) driver and AVS entry
         update in MAINTAINERS (Heiko Stübner, Kevin Hilman)
    
       - PM core fix related to clock management (Geert Uytterhoeven)
    
       - PM core's sysfs code cleanup (Johannes Berg)"
    
    * tag 'pm+acpi-3.18-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (105 commits)
      ACPI / fan: printk replacement
      PM / clk: Fix crash in clocks management code if !CONFIG_PM_RUNTIME
      PM / Domains: Rename cpu_data to cpuidle_data
      cpufreq: cpufreq-dt: fix potential double put of cpu OF node
      cpufreq: cpu0: rename driver and internals to 'cpufreq_dt'
      PM / hibernate: Iterate over set bits instead of PFNs in swsusp_free()
      cpufreq: ppc-corenet: remove duplicate update of cpu_data
      ACPI / sleep: Rework the handling of ACPI GPE wakeup from suspend-to-idle
      PM / sleep: Rename platform suspend/resume functions in suspend.c
      PM / sleep: Export dpm_suspend_late/noirq() and dpm_resume_early/noirq()
      ACPICA: Introduce acpi_enable_all_wakeup_gpes()
      ACPICA: Clear all non-wakeup GPEs in acpi_hw_enable_wakeup_gpe_block()
      ACPI / video: check _DOD list when creating backlight devices
      PM / Domains: Move dev_pm_domain_attach|detach() to pm_domain.h
      cpufreq: Replace strnicmp with strncasecmp
      cpufreq: powernv: Set the cpus to nominal frequency during reboot/kexec
      cpufreq: powernv: Set the pstate of the last hotplugged out cpu in policy->cpus to minimum
      cpufreq: Allow stop CPU callback to be used by all cpufreq drivers
      PM / devfreq: exynos: Enable building exynos PPMU as module
      PM / devfreq: Export helper functions for drivers
      ...

commit 28c399e2a1ed03bd175858deef1e233317103089
Merge: 0ede470030a3 a8d46b9e4e48
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Oct 7 01:17:50 2014 +0200

    Merge branch 'acpi-pm'
    
    * acpi-pm:
      ACPI / sleep: Rework the handling of ACPI GPE wakeup from suspend-to-idle
      PM / sleep: Rename platform suspend/resume functions in suspend.c
      PM / sleep: Export dpm_suspend_late/noirq() and dpm_resume_early/noirq()

commit 20b3d5386751e331aa0ab0b4e474b1062ecb75df
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Mon Aug 18 11:57:28 2014 -0400

    drm/radeon: fix pm handling in radeon_gpu_reset
    
    commit c940b4476f4fb649f6493b6a0ae837474ded8915 upstream.
    
    pm_suspend is handled in the radeon_suspend callbacks.
    pm_resume has special handling depending on whether
    dpm or legacy pm is enabled.  Change radeon_gpu_reset
    to mirror the behavior in the suspend and resume
    pathes.
    
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Reviewed-by: Christian König <christian.koenig@amd.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 05396d20dc953fb4ed295693afb2095963b1c4c4
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Mon Aug 18 11:57:28 2014 -0400

    drm/radeon: fix pm handling in radeon_gpu_reset
    
    commit c940b4476f4fb649f6493b6a0ae837474ded8915 upstream.
    
    pm_suspend is handled in the radeon_suspend callbacks.
    pm_resume has special handling depending on whether
    dpm or legacy pm is enabled.  Change radeon_gpu_reset
    to mirror the behavior in the suspend and resume
    pathes.
    
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Reviewed-by: Christian König <christian.koenig@amd.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 2a8a8ce651d3a88fdf83e2ed15633c8d19292108
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Sep 30 02:21:34 2014 +0200

    PM / sleep: Export dpm_suspend_late/noirq() and dpm_resume_early/noirq()
    
    Subsequent change sets will add platform-related operations between
    dpm_suspend_late() and dpm_suspend_noirq() as well as between
    dpm_resume_noirq() and dpm_resume_early() in suspend_enter(), so
    export these functions for suspend_enter() to be able to call them
    separately and split the invocations of dpm_suspend_end() and
    dpm_resume_start() in there accordingly.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit c940b4476f4fb649f6493b6a0ae837474ded8915
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Mon Aug 18 11:57:28 2014 -0400

    drm/radeon: fix pm handling in radeon_gpu_reset
    
    pm_suspend is handled in the radeon_suspend callbacks.
    pm_resume has special handling depending on whether
    dpm or legacy pm is enabled.  Change radeon_gpu_reset
    to mirror the behavior in the suspend and resume
    pathes.
    
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Reviewed-by: Christian König <christian.koenig@amd.com>
    Cc: stable@vger.kernel.org

commit d50a1907a3675300da14105add721826d73df63f
Author: Krzysztof Kozlowski <krzk@kernel.org>
Date:   Mon Jun 30 15:25:44 2014 +0200

    drm/exynos: Fix NULL pointer exception when suspending without components
    
    Fix a NULL pointer exception when main exynos drm driver was probed
    successfully but no components were added (e.g. by incomplete DTS). In
    such case the exynos_drm_load() is never called and drvdata is NULL.
    
    The NULL pointer exception may theoretically also happen as a effect of race between
    adding components and main driver: if suspend of the driver happens
    before adding components.
    
    Trace:
    [    1.190295] [drm] Initialized drm 1.1.0 20060810
    [    1.195209] exynos-drm-ipp exynos-drm-ipp: drm ipp registered successfully.
    (...)
    [   24.001743] PM: Syncing filesystems ... done.
    [   24.002177] Freezing user space processes ... (elapsed 0.000 seconds) done.
    [   24.007403] Freezing remaining freezable tasks ... (elapsed 0.001 seconds) done.
    [   24.032559] Unable to handle kernel NULL pointer dereference at virtual address 00000134
    [   24.035007] pgd = dedd8000
    [   24.037734] [00000134] *pgd=5ee13831, *pte=00000000, *ppte=00000000
    [   24.043953] Internal error: Oops: 17 [#1] PREEMPT SMP ARM
    [   24.049329] Modules linked in:
    [   24.052371] CPU: 0 PID: 1 Comm: sh Not tainted 3.16.0-rc3-00035-geba20bbdde04-dirty #51
    [   24.060354] task: df478000 ti: df480000 task.ti: df480000
    [   24.065743] PC is at mutex_lock+0x10/0x50
    [   24.069733] LR is at drm_modeset_lock_all+0x30/0xbc
    [   24.074590] pc : [<c048516c>]    lr : [<c02a14b4>]    psr: a0000013
    [   24.074590] sp : df481db8  ip : 00000000  fp : c05e524c
    [   24.086045] r10: 00000002  r9 : c02c1fe4  r8 : deca5e44
    [   24.091253] r7 : 00000000  r6 : 00000000  r5 : 0000014c  r4 : 00000134
    [   24.097763] r3 : 00000000  r2 : 00000000  r1 : 00000000  r0 : 00000134
    [   24.104275] Flags: NzCv  IRQs on  FIQs on  Mode SVC_32  ISA ARM  Segment user
    [   24.111391] Control: 10c53c7d  Table: 5edd806a  DAC: 00000015
    [   24.117120] Process sh (pid: 1, stack limit = 0xdf480240)
    [   24.122502] Stack: (0xdf481db8 to 0xdf482000)
    [   24.126843] 1da0:                                                       dee01d80 c02a14b4
    [   24.135004] 1dc0: 00000000 00000000 c07aff98 c02aec7c 00000002 00000000 00000000 c07aff98
    [   24.143164] 1de0: deca5e10 c02aecf4 c02aecd4 c02c2010 00000000 c02c9470 00000000 00000000
    [   24.151322] 1e00: 00000000 00000000 deca5e10 deca5e10 00000000 c07aff98 00000002 deca5e44
    [   24.159482] 1e20: c06d8f78 c06fb800 deca5e78 c02ca660 df7baf00 007b0aa0 deca5e10 c06fb7c8
    [   24.167641] 1e40: c07aff98 00000000 00000002 c02cbe18 9757aec5 00000005 9757aec5 00000005
    [   24.175801] 1e60: ded1d380 00000003 00000003 c05c74d8 ded1d380 c07209d4 c05c7514 c07105d8
    [   24.183960] 1e80: 01e2a738 c0068a74 00000000 c05c7514 ded1d380 c071c6e0 00000004 c07105d8
    [   24.192119] 1ea0: 01e2a738 c047f1e0 c0600cc0 df481ec4 00000003 00000000 00000003 c05c74d8
    [   24.200278] 1ec0: ded1d380 c071c6e0 c05c7514 c07105d8 01e2a738 c0069444 c06d905c 00000003
    [   24.208438] 1ee0: 00000003 ded1d380 c06d9064 00000004 c05c3fc0 c0067d4c df535ab0 ded1d380
    [   24.216596] 1f00: df481f80 ded1d380 00000004 ded1d1cc ded1d1c0 c0221724 00000004 c016ca6c
    [   24.224756] 1f20: c016ca28 00000000 00000000 c016c1d4 00000000 00000000 b6f37000 df481f80
    [   24.232915] 1f40: decedd80 00000004 df480000 df480000 b6f37000 c0110920 df47839c 60000013
    [   24.241074] 1f60: 00000000 00000000 decedd80 decedd80 00000004 df480000 b6f37000 c0110da8
    [   24.249233] 1f80: 00000000 00000000 00000004 b6edf5d8 00000004 b6f37000 00000004 c000f2a8
    [   24.257393] 1fa0: 00001000 c000f0e0 b6edf5d8 00000004 00000001 b6f37000 00000004 00000000
    [   24.265551] 1fc0: b6edf5d8 00000004 b6f37000 00000004 00000004 00000001 00000000 01e2a738
    [   24.273711] 1fe0: 00000000 beba0a20 b6e1f4f0 b6e7022c 60000010 00000001 ffffffff ffffffff
    [   24.281885] [<c048516c>] (mutex_lock) from [<c02a14b4>] (drm_modeset_lock_all+0x30/0xbc)
    [   24.289950] [<c02a14b4>] (drm_modeset_lock_all) from [<c02aec7c>] (exynos_drm_suspend+0xc/0x64)
    [   24.298627] [<c02aec7c>] (exynos_drm_suspend) from [<c02aecf4>] (exynos_drm_sys_suspend+0x20/0x34)
    [   24.307568] [<c02aecf4>] (exynos_drm_sys_suspend) from [<c02c2010>] (platform_pm_suspend+0x2c/0x54)
    [   24.316597] [<c02c2010>] (platform_pm_suspend) from [<c02c9470>] (dpm_run_callback+0x48/0x170)
    [   24.325188] [<c02c9470>] (dpm_run_callback) from [<c02ca660>] (__device_suspend+0x128/0x39c)
    [   24.333606] [<c02ca660>] (__device_suspend) from [<c02cbe18>] (dpm_suspend+0x5c/0x314)
    [   24.341506] [<c02cbe18>] (dpm_suspend) from [<c0068a74>] (suspend_devices_and_enter+0x8c/0x598)
    [   24.350185] [<c0068a74>] (suspend_devices_and_enter) from [<c0069444>] (pm_suspend+0x4c4/0x5d0)
    [   24.358862] [<c0069444>] (pm_suspend) from [<c0067d4c>] (state_store+0x70/0xd4)
    [   24.366156] [<c0067d4c>] (state_store) from [<c0221724>] (kobj_attr_store+0x14/0x20)
    [   24.373885] [<c0221724>] (kobj_attr_store) from [<c016ca6c>] (sysfs_kf_write+0x44/0x48)
    [   24.381867] [<c016ca6c>] (sysfs_kf_write) from [<c016c1d4>] (kernfs_fop_write+0xc0/0x17c)
    [   24.390027] [<c016c1d4>] (kernfs_fop_write) from [<c0110920>] (vfs_write+0xa0/0x1c4)
    [   24.397750] [<c0110920>] (vfs_write) from [<c0110da8>] (SyS_write+0x40/0x8c)
    [   24.404782] [<c0110da8>] (SyS_write) from [<c000f0e0>] (ret_fast_syscall+0x0/0x3c)
    [   24.412332] Code: e92d4010 e1a04000 f57ff05b f590f000 (e1903f9f)
    [   24.418448] ---[ end trace cfa06690eabe8dd5 ]---
    [   24.423032] Kernel panic - not syncing: Fatal exception
    [   24.428220] CPU1: stopping
    [   24.430905] CPU: 1 PID: 0 Comm: swapper/1 Tainted: G      D       3.16.0-rc3-00035-geba20bbdde04-dirty #51
    [   24.440549] [<c0016440>] (unwind_backtrace) from [<c001294c>] (show_stack+0x10/0x14)
    [   24.448269] [<c001294c>] (show_stack) from [<c04811e8>] (dump_stack+0x80/0xcc)
    [   24.455472] [<c04811e8>] (dump_stack) from [<c001495c>] (handle_IPI+0x130/0x15c)
    [   24.462850] [<c001495c>] (handle_IPI) from [<c000862c>] (gic_handle_irq+0x60/0x68)
    [   24.470400] [<c000862c>] (gic_handle_irq) from [<c0013440>] (__irq_svc+0x40/0x70)
    [   24.477860] Exception stack(0xdf4bdf88 to 0xdf4bdfd0)
    [   24.482898] df80:                   ffffffed 00000000 00000000 00000000 df4bc000 c06d042c
    [   24.491058] dfa0: 00000000 ffffffed c06d03c0 00000000 c070c288 00000000 00000000 df4bdfd0
    [   24.499214] dfc0: c0010324 c0010328 60000013 ffffffff
    [   24.504254] [<c0013440>] (__irq_svc) from [<c0010328>] (arch_cpu_idle+0x28/0x30)
    [   24.511634] [<c0010328>] (arch_cpu_idle) from [<c005f110>] (cpu_startup_entry+0x2c4/0x3f0)
    [   24.519878] [<c005f110>] (cpu_startup_entry) from [<400086c4>] (0x400086c4)
    [   24.526821] ---[ end Kernel panic - not syncing: Fatal exception
    
    Signed-off-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Signed-off-by: Inki Dae <inki.dae@samsung.com>

commit b04c5bd6fda54703e56f29569e4bca489d6c5a5c
Author: Borun Fu <borun.fu@intel.com>
Date:   Sat Jul 12 10:02:27 2014 +0530

    drm/i915: Power gating display wells during i915_pm_suspend
    
    On VLV, after i915_pm_suspend display power wells are staying
    power ungated. So, after initiating mem sleep "echo mem > /sys/power/state"
    Display is staing D0 State. There might be better way/place to power gate
    these wells. Also, we need to make sure that if wells are power gated due to
    DPMS OFF sequence, they need not be turned off by i915_pm_suspend again.
    
    v2: Extracted helper for intel_crtc_disable and power gating CRTC power wells.
    [Daniel]
    
    Cc: Imre Deak <imre.deak@intel.com>
    Cc: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: Jani Nikula <jani.nikula@linux.intel.com>
    Change-Id: I34c80da66aa24c423a5576c68aa1f3a8d0f43848
    Signed-off-by: Borun Fu <borun.fu@intel.com>
    Signed-off-by: Sagar Kamble <sagar.a.kamble@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

commit 150cee9cfd749b1a9f4e995d63761891d46c56de
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sat Jul 12 11:01:38 2014 +0100

    drm: bochs: fix warnings
    
    Regular nightly randconfig build testing discovered these warnings:
    
    drivers/gpu/drm/bochs/bochs_drv.c:100:12: warning: 'bochs_pm_suspend' defined but not used [-Wunused-function]
    drivers/gpu/drm/bochs/bochs_drv.c:117:12: warning: 'bochs_pm_resume' defined but not used [-Wunused-function]
    
    Fix these by adding the same condition that SET_SYSTEM_SLEEP_PM_OPS()
    uses.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

commit 8f8e7e14637a07d8bde6e4b0dc385b72d1a674fb
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sat Jul 12 11:01:43 2014 +0100

    drm: cirrus: fix warnings
    
    Regular nightly randconfig build testing discovered these warnings:
    
    drivers/gpu/drm/cirrus/cirrus_drv.c:79:12: warning: 'cirrus_pm_suspend' defined but not used [-Wunused-function]
    drivers/gpu/drm/cirrus/cirrus_drv.c:96:12: warning: 'cirrus_pm_resume' defined but not used [-Wunused-function]
    
    Fix these by adding the same condition that SET_SYSTEM_SLEEP_PM_OPS()
    uses.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

commit 3ddbd9a2d572434bd5b63757a70d9532c0027de7
Author: Bibek Basu <bbasu@nvidia.com>
Date:   Mon May 19 10:24:01 2014 +0530

    cpufreq: remove race while accessing cur_policy
    
    commit c5450db85b828d0c46ac8fc570fb8a51bf07ac40 upstream.
    
    While accessing cur_policy during executing events
    CPUFREQ_GOV_START, CPUFREQ_GOV_STOP, CPUFREQ_GOV_LIMITS,
    same mutex lock is not taken, dbs_data->mutex, which leads
    to race and data corruption while running continious suspend
    resume test. This is seen with ondemand governor with suspend
    resume test using rtcwake.
    
     Unable to handle kernel NULL pointer dereference at virtual address 00000028
     pgd = ed610000
     [00000028] *pgd=adf11831, *pte=00000000, *ppte=00000000
     Internal error: Oops: 17 [#1] PREEMPT SMP ARM
     Modules linked in: nvhost_vi
     CPU: 1 PID: 3243 Comm: rtcwake Not tainted 3.10.24-gf5cf9e5 #1
     task: ee708040 ti: ed61c000 task.ti: ed61c000
     PC is at cpufreq_governor_dbs+0x400/0x634
     LR is at cpufreq_governor_dbs+0x3f8/0x634
     pc : [<c05652b8>] lr : [<c05652b0>] psr: 600f0013
     sp : ed61dcb0 ip : 000493e0 fp : c1cc14f0
     r10: 00000000 r9 : 00000000 r8 : 00000000
     r7 : eb725280 r6 : c1cc1560 r5 : eb575200 r4 : ebad7740
     r3 : ee708040 r2 : ed61dca8 r1 : 001ebd24 r0 : 00000000
     Flags: nZCv IRQs on FIQs on Mode SVC_32 ISA ARM Segment user
     Control: 10c5387d Table: ad61006a DAC: 00000015
     [<c05652b8>] (cpufreq_governor_dbs+0x400/0x634) from [<c055f700>] (__cpufreq_governor+0x98/0x1b4)
     [<c055f700>] (__cpufreq_governor+0x98/0x1b4) from [<c0560770>] (__cpufreq_set_policy+0x250/0x320)
     [<c0560770>] (__cpufreq_set_policy+0x250/0x320) from [<c0561dcc>] (cpufreq_update_policy+0xcc/0x168)
     [<c0561dcc>] (cpufreq_update_policy+0xcc/0x168) from [<c0561ed0>] (cpu_freq_notify+0x68/0xdc)
     [<c0561ed0>] (cpu_freq_notify+0x68/0xdc) from [<c008eff8>] (notifier_call_chain+0x4c/0x8c)
     [<c008eff8>] (notifier_call_chain+0x4c/0x8c) from [<c008f3d4>] (__blocking_notifier_call_chain+0x50/0x68)
     [<c008f3d4>] (__blocking_notifier_call_chain+0x50/0x68) from [<c008f40c>] (blocking_notifier_call_chain+0x20/0x28)
     [<c008f40c>] (blocking_notifier_call_chain+0x20/0x28) from [<c00aac6c>] (pm_qos_update_bounded_target+0xd8/0x310)
     [<c00aac6c>] (pm_qos_update_bounded_target+0xd8/0x310) from [<c00ab3b0>] (__pm_qos_update_request+0x64/0x70)
     [<c00ab3b0>] (__pm_qos_update_request+0x64/0x70) from [<c004b4b8>] (tegra_pm_notify+0x114/0x134)
     [<c004b4b8>] (tegra_pm_notify+0x114/0x134) from [<c008eff8>] (notifier_call_chain+0x4c/0x8c)
     [<c008eff8>] (notifier_call_chain+0x4c/0x8c) from [<c008f3d4>] (__blocking_notifier_call_chain+0x50/0x68)
     [<c008f3d4>] (__blocking_notifier_call_chain+0x50/0x68) from [<c008f40c>] (blocking_notifier_call_chain+0x20/0x28)
     [<c008f40c>] (blocking_notifier_call_chain+0x20/0x28) from [<c00ac228>] (pm_notifier_call_chain+0x1c/0x34)
     [<c00ac228>] (pm_notifier_call_chain+0x1c/0x34) from [<c00ad38c>] (enter_state+0xec/0x128)
     [<c00ad38c>] (enter_state+0xec/0x128) from [<c00ad400>] (pm_suspend+0x38/0xa4)
     [<c00ad400>] (pm_suspend+0x38/0xa4) from [<c00ac114>] (state_store+0x70/0xc0)
     [<c00ac114>] (state_store+0x70/0xc0) from [<c027b1e8>] (kobj_attr_store+0x14/0x20)
     [<c027b1e8>] (kobj_attr_store+0x14/0x20) from [<c019cd9c>] (sysfs_write_file+0x104/0x184)
     [<c019cd9c>] (sysfs_write_file+0x104/0x184) from [<c0143038>] (vfs_write+0xd0/0x19c)
     [<c0143038>] (vfs_write+0xd0/0x19c) from [<c0143414>] (SyS_write+0x4c/0x78)
     [<c0143414>] (SyS_write+0x4c/0x78) from [<c000f080>] (ret_fast_syscall+0x0/0x30)
     Code: e1a00006 eb084346 e59b0020 e5951024 (e5903028)
     ---[ end trace 0488523c8f6b0f9d ]---
    
    Signed-off-by: Bibek Basu <bbasu@nvidia.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>

commit 89571e8509f62d950715faca2251eb2273b530a0
Author: Bibek Basu <bbasu@nvidia.com>
Date:   Mon May 19 10:24:01 2014 +0530

    cpufreq: remove race while accessing cur_policy
    
    commit c5450db85b828d0c46ac8fc570fb8a51bf07ac40 upstream.
    
    While accessing cur_policy during executing events
    CPUFREQ_GOV_START, CPUFREQ_GOV_STOP, CPUFREQ_GOV_LIMITS,
    same mutex lock is not taken, dbs_data->mutex, which leads
    to race and data corruption while running continious suspend
    resume test. This is seen with ondemand governor with suspend
    resume test using rtcwake.
    
     Unable to handle kernel NULL pointer dereference at virtual address 00000028
     pgd = ed610000
     [00000028] *pgd=adf11831, *pte=00000000, *ppte=00000000
     Internal error: Oops: 17 [#1] PREEMPT SMP ARM
     Modules linked in: nvhost_vi
     CPU: 1 PID: 3243 Comm: rtcwake Not tainted 3.10.24-gf5cf9e5 #1
     task: ee708040 ti: ed61c000 task.ti: ed61c000
     PC is at cpufreq_governor_dbs+0x400/0x634
     LR is at cpufreq_governor_dbs+0x3f8/0x634
     pc : [<c05652b8>] lr : [<c05652b0>] psr: 600f0013
     sp : ed61dcb0 ip : 000493e0 fp : c1cc14f0
     r10: 00000000 r9 : 00000000 r8 : 00000000
     r7 : eb725280 r6 : c1cc1560 r5 : eb575200 r4 : ebad7740
     r3 : ee708040 r2 : ed61dca8 r1 : 001ebd24 r0 : 00000000
     Flags: nZCv IRQs on FIQs on Mode SVC_32 ISA ARM Segment user
     Control: 10c5387d Table: ad61006a DAC: 00000015
     [<c05652b8>] (cpufreq_governor_dbs+0x400/0x634) from [<c055f700>] (__cpufreq_governor+0x98/0x1b4)
     [<c055f700>] (__cpufreq_governor+0x98/0x1b4) from [<c0560770>] (__cpufreq_set_policy+0x250/0x320)
     [<c0560770>] (__cpufreq_set_policy+0x250/0x320) from [<c0561dcc>] (cpufreq_update_policy+0xcc/0x168)
     [<c0561dcc>] (cpufreq_update_policy+0xcc/0x168) from [<c0561ed0>] (cpu_freq_notify+0x68/0xdc)
     [<c0561ed0>] (cpu_freq_notify+0x68/0xdc) from [<c008eff8>] (notifier_call_chain+0x4c/0x8c)
     [<c008eff8>] (notifier_call_chain+0x4c/0x8c) from [<c008f3d4>] (__blocking_notifier_call_chain+0x50/0x68)
     [<c008f3d4>] (__blocking_notifier_call_chain+0x50/0x68) from [<c008f40c>] (blocking_notifier_call_chain+0x20/0x28)
     [<c008f40c>] (blocking_notifier_call_chain+0x20/0x28) from [<c00aac6c>] (pm_qos_update_bounded_target+0xd8/0x310)
     [<c00aac6c>] (pm_qos_update_bounded_target+0xd8/0x310) from [<c00ab3b0>] (__pm_qos_update_request+0x64/0x70)
     [<c00ab3b0>] (__pm_qos_update_request+0x64/0x70) from [<c004b4b8>] (tegra_pm_notify+0x114/0x134)
     [<c004b4b8>] (tegra_pm_notify+0x114/0x134) from [<c008eff8>] (notifier_call_chain+0x4c/0x8c)
     [<c008eff8>] (notifier_call_chain+0x4c/0x8c) from [<c008f3d4>] (__blocking_notifier_call_chain+0x50/0x68)
     [<c008f3d4>] (__blocking_notifier_call_chain+0x50/0x68) from [<c008f40c>] (blocking_notifier_call_chain+0x20/0x28)
     [<c008f40c>] (blocking_notifier_call_chain+0x20/0x28) from [<c00ac228>] (pm_notifier_call_chain+0x1c/0x34)
     [<c00ac228>] (pm_notifier_call_chain+0x1c/0x34) from [<c00ad38c>] (enter_state+0xec/0x128)
     [<c00ad38c>] (enter_state+0xec/0x128) from [<c00ad400>] (pm_suspend+0x38/0xa4)
     [<c00ad400>] (pm_suspend+0x38/0xa4) from [<c00ac114>] (state_store+0x70/0xc0)
     [<c00ac114>] (state_store+0x70/0xc0) from [<c027b1e8>] (kobj_attr_store+0x14/0x20)
     [<c027b1e8>] (kobj_attr_store+0x14/0x20) from [<c019cd9c>] (sysfs_write_file+0x104/0x184)
     [<c019cd9c>] (sysfs_write_file+0x104/0x184) from [<c0143038>] (vfs_write+0xd0/0x19c)
     [<c0143038>] (vfs_write+0xd0/0x19c) from [<c0143414>] (SyS_write+0x4c/0x78)
     [<c0143414>] (SyS_write+0x4c/0x78) from [<c000f080>] (ret_fast_syscall+0x0/0x30)
     Code: e1a00006 eb084346 e59b0020 e5951024 (e5903028)
     ---[ end trace 0488523c8f6b0f9d ]---
    
    Signed-off-by: Bibek Basu <bbasu@nvidia.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit b6911bba598f5d611f7fdbb87b5af7f1712dbe9d
Author: Paul Burton <paul.burton@mips.com>
Date:   Wed May 7 12:20:57 2014 +0100

    MIPS: Malta: add suspend state entry code
    
    This patch introduces code which will enter a suspend state via the
    PIIX4. This can only be done when PCI support is enabled since it
    requires access to PCI I/O space and the generation of a special cycle
    on the PCI bus. In cases where PCI is disabled the mips_pm_suspend
    function will simply always return an error.
    
    Signed-off-by: Paul Burton <paul.burton@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/6905/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

commit 7027df36e41836b11f01b0d30eee40c55df7d013
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue May 20 18:09:36 2014 -0700

    usb: resume child device when port is powered on
    
    Unconditionally wake up the child device when the power session is
    recovered.
    
    This addresses the following scenarios:
    
    1/ The device may need a reset on power-session loss, without this
       change port power-on recovery exposes khubd to scenarios that
       usb_port_resume() is set to handle.  Prior to port power control the
       only time a power session would be lost is during dpm_suspend of the
       hub.  In that scenario usb_port_resume() is guaranteed to be called
       prior to khubd running for that port.  With this change we wakeup the
       child device as soon as possible (prior to khubd running again for this
       port).
    
       Although khubd has facilities to wake a child device it will only do
       so if the portstatus / portchange indicates a suspend state.  In the
       case of port power control we are not coming from a hub-port-suspend
       state.  This implementation simply uses pm_request_resume() to wake the
       device and relies on the port_dev->status_lock to prevent any collisions
       between khubd and usb_port_resume().
    
    2/ This mechanism rate limits port power toggling.  The minimum port
       power on/off period is now gated by the child device suspend/resume
       latency.  Empirically this mitigates devices downgrading their connection
       on perceived instability of the host connection.  This ratelimiting is
       really only relevant to port power control testing, but it is a nice
       side effect of closing the above race.  Namely, the race of khubd for
       the given port running while a usb_port_resume() event is pending.
    
    3/ Going forward we are finding that power-session recovery requires
       warm-resets (http://marc.info/?t=138659232900003&r=1&w=2).  This
       mechanism allows for warm-resets to be requested at the same point in
       the resume path for hub dpm_suspend power session losses, or port
       rpm_suspend power session losses.
    
    4/ If the device *was* disconnected the only time we'll know for sure is
       after a failed resume, so it's necessary for usb_port_runtime_resume()
       to expedite a usb_port_resume() to clean up the removed device.  The
       reasoning for this is "least surprise" for the user. Turning on a port
       means that hotplug detection is again enabled for the port, it is
       surprising that devices that were removed while the port was off are not
       disconnected until they are attempted to be used.  As a user "why would
       I try to use a device I removed from the system?"
    
    1, 2, and 4 are not a problem in the system dpm_resume() case because,
    although the power-session is lost, khubd is frozen until after device
    resume.  For the rpm_resume() case pm_request_resume() is used to
    request re-validation of the device, and if it happens to collide with a
    khubd run we rely on the port_dev->status_lock to synchronize those
    operations.
    
    Besides testing, the primary scenario where this mechanism is expected
    to be triggered is when the user changes the port power policy
    (control/pm_qos_no_poweroff, or power/control).   Each time power is
    enabled want to revalidate the child device, where the revalidation is
    handled by usb_port_resume().
    
    Given that this arranges for port_dev->child to be de-referenced in
    usb_port_runtime_resume() we need to make sure not to collide with
    usb_disconnect() that frees the usb_device.  To this end we hold the
    port active with the "child_usage" reference across the disconnect
    event.  Subsequently, the need to access hub->child_usage_bits lead to
    the creation of hub_disconnect_children() to remove any ambiguity of
    which "hub" is being acted on in usb_disconnect() (prompted-by sharp
    eyes from Alan).
    
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit c5450db85b828d0c46ac8fc570fb8a51bf07ac40
Author: Bibek Basu <bbasu@nvidia.com>
Date:   Mon May 19 10:24:01 2014 +0530

    cpufreq: remove race while accessing cur_policy
    
    While accessing cur_policy during executing events
    CPUFREQ_GOV_START, CPUFREQ_GOV_STOP, CPUFREQ_GOV_LIMITS,
    same mutex lock is not taken, dbs_data->mutex, which leads
    to race and data corruption while running continious suspend
    resume test. This is seen with ondemand governor with suspend
    resume test using rtcwake.
    
     Unable to handle kernel NULL pointer dereference at virtual address 00000028
     pgd = ed610000
     [00000028] *pgd=adf11831, *pte=00000000, *ppte=00000000
     Internal error: Oops: 17 [#1] PREEMPT SMP ARM
     Modules linked in: nvhost_vi
     CPU: 1 PID: 3243 Comm: rtcwake Not tainted 3.10.24-gf5cf9e5 #1
     task: ee708040 ti: ed61c000 task.ti: ed61c000
     PC is at cpufreq_governor_dbs+0x400/0x634
     LR is at cpufreq_governor_dbs+0x3f8/0x634
     pc : [<c05652b8>] lr : [<c05652b0>] psr: 600f0013
     sp : ed61dcb0 ip : 000493e0 fp : c1cc14f0
     r10: 00000000 r9 : 00000000 r8 : 00000000
     r7 : eb725280 r6 : c1cc1560 r5 : eb575200 r4 : ebad7740
     r3 : ee708040 r2 : ed61dca8 r1 : 001ebd24 r0 : 00000000
     Flags: nZCv IRQs on FIQs on Mode SVC_32 ISA ARM Segment user
     Control: 10c5387d Table: ad61006a DAC: 00000015
     [<c05652b8>] (cpufreq_governor_dbs+0x400/0x634) from [<c055f700>] (__cpufreq_governor+0x98/0x1b4)
     [<c055f700>] (__cpufreq_governor+0x98/0x1b4) from [<c0560770>] (__cpufreq_set_policy+0x250/0x320)
     [<c0560770>] (__cpufreq_set_policy+0x250/0x320) from [<c0561dcc>] (cpufreq_update_policy+0xcc/0x168)
     [<c0561dcc>] (cpufreq_update_policy+0xcc/0x168) from [<c0561ed0>] (cpu_freq_notify+0x68/0xdc)
     [<c0561ed0>] (cpu_freq_notify+0x68/0xdc) from [<c008eff8>] (notifier_call_chain+0x4c/0x8c)
     [<c008eff8>] (notifier_call_chain+0x4c/0x8c) from [<c008f3d4>] (__blocking_notifier_call_chain+0x50/0x68)
     [<c008f3d4>] (__blocking_notifier_call_chain+0x50/0x68) from [<c008f40c>] (blocking_notifier_call_chain+0x20/0x28)
     [<c008f40c>] (blocking_notifier_call_chain+0x20/0x28) from [<c00aac6c>] (pm_qos_update_bounded_target+0xd8/0x310)
     [<c00aac6c>] (pm_qos_update_bounded_target+0xd8/0x310) from [<c00ab3b0>] (__pm_qos_update_request+0x64/0x70)
     [<c00ab3b0>] (__pm_qos_update_request+0x64/0x70) from [<c004b4b8>] (tegra_pm_notify+0x114/0x134)
     [<c004b4b8>] (tegra_pm_notify+0x114/0x134) from [<c008eff8>] (notifier_call_chain+0x4c/0x8c)
     [<c008eff8>] (notifier_call_chain+0x4c/0x8c) from [<c008f3d4>] (__blocking_notifier_call_chain+0x50/0x68)
     [<c008f3d4>] (__blocking_notifier_call_chain+0x50/0x68) from [<c008f40c>] (blocking_notifier_call_chain+0x20/0x28)
     [<c008f40c>] (blocking_notifier_call_chain+0x20/0x28) from [<c00ac228>] (pm_notifier_call_chain+0x1c/0x34)
     [<c00ac228>] (pm_notifier_call_chain+0x1c/0x34) from [<c00ad38c>] (enter_state+0xec/0x128)
     [<c00ad38c>] (enter_state+0xec/0x128) from [<c00ad400>] (pm_suspend+0x38/0xa4)
     [<c00ad400>] (pm_suspend+0x38/0xa4) from [<c00ac114>] (state_store+0x70/0xc0)
     [<c00ac114>] (state_store+0x70/0xc0) from [<c027b1e8>] (kobj_attr_store+0x14/0x20)
     [<c027b1e8>] (kobj_attr_store+0x14/0x20) from [<c019cd9c>] (sysfs_write_file+0x104/0x184)
     [<c019cd9c>] (sysfs_write_file+0x104/0x184) from [<c0143038>] (vfs_write+0xd0/0x19c)
     [<c0143038>] (vfs_write+0xd0/0x19c) from [<c0143414>] (SyS_write+0x4c/0x78)
     [<c0143414>] (SyS_write+0x4c/0x78) from [<c000f080>] (ret_fast_syscall+0x0/0x30)
     Code: e1a00006 eb084346 e59b0020 e5951024 (e5903028)
     ---[ end trace 0488523c8f6b0f9d ]---
    
    Signed-off-by: Bibek Basu <bbasu@nvidia.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Cc: 3.11+ <stable@vger.kernel.org> # 3.11+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit f3f125324fc1b8500cd20a2907628f7e5d88a708
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Apr 20 23:43:01 2014 +0200

    PM / suspend: Make cpuidle work in the "freeze" state
    
    The "freeze" system sleep state introduced by commit 7e73c5ae6e79
    (PM: Introduce suspend state PM_SUSPEND_FREEZE) requires cpuidle
    to be functional when freeze_enter() is executed to work correctly
    (that is, to be able to save any more energy than runtime idle),
    but that is impossible after commit 8651f97bd951d (PM / cpuidle:
    System resume hang fix with cpuidle) which caused cpuidle to be
    paused in dpm_suspend_noirq() and resumed in dpm_resume_noirq().
    
    To avoid that problem, add cpuidle_resume() and cpuidle_pause()
    to the beginning and the end of freeze_enter(), respectively.
    
    Reported-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Preeti U Murthy <preeti@linux.vnet.ibm.com>

commit f45e5f00dacf09362a16339d372fcc96705e40c7
Author: Roger Quadros <rogerq@ti.com>
Date:   Wed Mar 26 11:43:09 2014 +0200

    usb: dwc3: core: Fix gadget for system suspend/resume
    
    During system resume, if the event buffers are not setup before
    the gadget controller starts then we start with invalid context
    and this can lead to bus access errors. This is especially true for
    platforms that loose the controller context during system suspend.
    e.g. AM437x.
    
    The following backtrace was found when the system is suspended
    and resumed with g_zero loaded on AM437x-evm (USB cable connected
    to host all the while).
    
    [  120.981506] WARNING: CPU: 0 PID: 1656 at drivers/bus/omap_l3_noc.c:137 l3_interrupt_handler+0x198/0x28c()
    [  120.981514] L3 custom error: MASTER:USB0 WR TARGET:GPMC
    [  120.981638] Modules linked in: g_mass_storage usb_f_mass_storage libcomposite configfs bufferclass_ti(O) omaplfb(O) cryptodev(O) dwc3 snd_soc_evm snd_soc_omap snd_pe
    [  120.981659] CPU: 0 PID: 1656 Comm: sh Tainted: G           O 3.12.10-gc559824 #1
    [  120.981669] Backtrace:
    [  120.981705] [<c0017880>] (dump_backtrace+0x0/0x10c) from [<c0017a1c>] (show_stack+0x18/0x1c)
    [  120.981730]  r6:c02819ac r5:00000009 r4:ec137cb8 r3:00000000
    [  120.981767] [<c0017a04>] (show_stack+0x0/0x1c) from [<c056c0b0>] (dump_stack+0x20/0x28)
    [  120.981802] [<c056c090>] (dump_stack+0x0/0x28) from [<c0046d08>] (warn_slowpath_common+0x70/0x90)
    [  120.981830] [<c0046c98>] (warn_slowpath_common+0x0/0x90) from [<c0046dcc>] (warn_slowpath_fmt+0x38/0x40)
    [  120.981856]  r8:c0855eb0 r7:00000002 r6:f1000700 r5:00000007 r4:80080003
    [  120.981886] [<c0046d94>] (warn_slowpath_fmt+0x0/0x40) from [<c02819ac>] (l3_interrupt_handler+0x198/0x28c)
    [  120.981900]  r3:c0801ab8 r2:c06cb354
    [  120.981936] [<c0281814>] (l3_interrupt_handler+0x0/0x28c) from [<c007162c>] (handle_irq_event_percpu+0x54/0x1b8)
    [  120.981962] [<c00715d8>] (handle_irq_event_percpu+0x0/0x1b8) from [<c00717c0>] (handle_irq_event+0x30/0x40)
    [  120.981993] [<c0071790>] (handle_irq_event+0x0/0x40) from [<c0074058>] (handle_fasteoi_irq+0x74/0x128)
    [  120.982006]  r4:ed0056c0 r3:00000000
    [  120.982033] [<c0073fe4>] (handle_fasteoi_irq+0x0/0x128) from [<c0070f34>] (generic_handle_irq+0x28/0x38)
    [  120.982046]  r4:0000002a r3:c0073fe4
    [  120.982085] [<c0070f0c>] (generic_handle_irq+0x0/0x38) from [<c0015560>] (handle_IRQ+0x38/0x8c)
    [  120.982098]  r4:c080137c r3:00000182
    [  120.982124] [<c0015528>] (handle_IRQ+0x0/0x8c) from [<c00087e0>] (gic_handle_irq+0x30/0x5c)
    [  120.982145]  r6:ec137dd0 r5:c07ac480 r4:fa24010c r3:00000100
    [  120.982169] [<c00087b0>] (gic_handle_irq+0x0/0x5c) from [<c056fcc0>] (__irq_svc+0x40/0x54)
    [  120.982179] Exception stack(0xec137dd0 to 0xec137e18)
    [  120.982195] 7dc0:                                     00000000 a00001d3 00000000 00000004
    [  120.982216] 7de0: a0000153 ec1d9010 c080de90 ec137e30 c080debc 00000000 ed756e44 ec137e2c
    [  120.982232] 7e00: ec137de0 ec137e18 bf1150e4 bf115474 60000153 ffffffff
    [  120.982253]  r7:ec137e04 r6:ffffffff r5:60000153 r4:bf115474
    [  120.982327] [<bf115438>] (dwc3_complete+0x0/0x40 [dwc3]) from [<c0338f50>] (dpm_complete+0xd4/0x19c)
    [  120.982341]  r5:ed756e10 r4:ed756e64
    [  120.982370] [<c0338e7c>] (dpm_complete+0x0/0x19c) from [<c0339034>] (dpm_resume_end+0x1c/0x20)
    [  120.982400] [<c0339018>] (dpm_resume_end+0x0/0x20) from [<c006d4ec>] (suspend_devices_and_enter+0x118/0x33c)
    [  120.982412]  r4:c0833da4 r3:00000000
    [  120.982436] [<c006d3d4>] (suspend_devices_and_enter+0x0/0x33c) from [<c006d928>] (pm_suspend+0x218/0x254)
    [  120.982458] [<c006d710>] (pm_suspend+0x0/0x254) from [<c006c594>] (state_store+0x70/0xc0)
    [  120.982478]  r6:c057a6cc r5:c06a8320 r4:00000003 r3:0000006d
    [  120.982515] [<c006c524>] (state_store+0x0/0xc0) from [<c0264cc0>] (kobj_attr_store+0x1c/0x28)
    [  120.982546] [<c0264ca4>] (kobj_attr_store+0x0/0x28) from [<c012ccb8>] (sysfs_write_file+0x170/0x1a4)
    [  120.982583] [<c012cb48>] (sysfs_write_file+0x0/0x1a4) from [<c00d17e4>] (vfs_write+0xb8/0x190)
    [  120.982611] [<c00d172c>] (vfs_write+0x0/0x190) from [<c00d1bf8>] (SyS_write+0x44/0x78)
    [  120.982641] [<c00d1bb4>] (SyS_write+0x0/0x78) from [<c0014660>] (ret_fast_syscall+0x0/0x30)
    
    Signed-off-by: Roger Quadros <rogerq@ti.com>
    Acked-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

commit 72581487a61f6304a7cc32e189eb65fb1c920a53
Author: Jane Li <jiel@marvell.com>
Date:   Thu Apr 3 14:48:45 2014 -0700

    printk: fix one circular lockdep warning about console_lock
    
    Fix a warning about possible circular locking dependency.
    
    If do in following sequence:
    
        enter suspend ->  resume ->  plug-out CPUx (echo 0 > cpux/online)
    
    lockdep will show warning as following:
    
      ======================================================
      [ INFO: possible circular locking dependency detected ]
      3.10.0 #2 Tainted: G           O
      -------------------------------------------------------
      sh/1271 is trying to acquire lock:
      (console_lock){+.+.+.}, at: console_cpu_notify+0x20/0x2c
      but task is already holding lock:
      (cpu_hotplug.lock){+.+.+.}, at: cpu_hotplug_begin+0x2c/0x58
      which lock already depends on the new lock.
    
      the existing dependency chain (in reverse order) is:
      -> #2 (cpu_hotplug.lock){+.+.+.}:
        lock_acquire+0x98/0x12c
        mutex_lock_nested+0x50/0x3d8
        cpu_hotplug_begin+0x2c/0x58
        _cpu_up+0x24/0x154
        cpu_up+0x64/0x84
        smp_init+0x9c/0xd4
        kernel_init_freeable+0x78/0x1c8
        kernel_init+0x8/0xe4
        ret_from_fork+0x14/0x2c
    
      -> #1 (cpu_add_remove_lock){+.+.+.}:
        lock_acquire+0x98/0x12c
        mutex_lock_nested+0x50/0x3d8
        disable_nonboot_cpus+0x8/0xe8
        suspend_devices_and_enter+0x214/0x448
        pm_suspend+0x1e4/0x284
        try_to_suspend+0xa4/0xbc
        process_one_work+0x1c4/0x4fc
        worker_thread+0x138/0x37c
        kthread+0xa4/0xb0
        ret_from_fork+0x14/0x2c
    
      -> #0 (console_lock){+.+.+.}:
        __lock_acquire+0x1b38/0x1b80
        lock_acquire+0x98/0x12c
        console_lock+0x54/0x68
        console_cpu_notify+0x20/0x2c
        notifier_call_chain+0x44/0x84
        __cpu_notify+0x2c/0x48
        cpu_notify_nofail+0x8/0x14
        _cpu_down+0xf4/0x258
        cpu_down+0x24/0x40
        store_online+0x30/0x74
        dev_attr_store+0x18/0x24
        sysfs_write_file+0x16c/0x19c
        vfs_write+0xb4/0x190
        SyS_write+0x3c/0x70
        ret_fast_syscall+0x0/0x48
    
      Chain exists of:
         console_lock --> cpu_add_remove_lock --> cpu_hotplug.lock
    
      Possible unsafe locking scenario:
             CPU0                    CPU1
             ----                    ----
      lock(cpu_hotplug.lock);
                                     lock(cpu_add_remove_lock);
                                     lock(cpu_hotplug.lock);
      lock(console_lock);
        *** DEADLOCK ***
    
    There are three locks involved in two sequence:
    a) pm suspend:
            console_lock (@suspend_console())
            cpu_add_remove_lock (@disable_nonboot_cpus())
            cpu_hotplug.lock (@_cpu_down())
    b) Plug-out CPUx:
            cpu_add_remove_lock (@(cpu_down())
            cpu_hotplug.lock (@_cpu_down())
            console_lock (@console_cpu_notify()) => Lockdeps prints warning log.
    
    There should be not real deadlock, as flag of console_suspended can
    protect this.
    
    Although console_suspend() releases console_sem, it doesn't tell lockdep
    about it.  That results in the lockdep warning about circular locking
    when doing the following: enter suspend -> resume -> plug-out CPUx (echo
    0 > cpux/online)
    
    Fix the problem by telling lockdep we actually released the semaphore in
    console_suspend() and acquired it again in console_resume().
    
    Signed-off-by: Jane Li <jiel@marvell.com>
    Reviewed-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit 48b16180d0d91324e5d2423c6d53d97bbe3dcc14
Author: Wang Dongsheng <dongsheng.wang@freescale.com>
Date:   Thu Mar 20 11:19:37 2014 +0800

    fsl/pci: The new pci suspend/resume implementation
    
    If we do nothing in suspend/resume, some platform PCIe ip-block
    can't guarantee the link back to L0 state from sleep, then, when
    we read the EP device will hang. Only we send pme turnoff message
    in pci controller suspend, and send pme exit message in resume, the
    link state will be normal.
    
    When we send pme turnoff message in pci controller suspend, the
    links will into l2/l3 ready, then, host cannot communicate with
    ep device, but pci-driver will call back EP device to save them
    state. So we need to change platform_driver->suspend/resume to
    syscore->suspend/resume.
    
    So the new suspend/resume implementation, send pme turnoff message
    in suspend, and send pme exit message in resume. And add a PME handler,
    to response PME & message interrupt.
    
    Change platform_driver->suspend/resume to syscore->suspend/resume.
    pci-driver will call back EP device, to save EP state in
    pci_pm_suspend_noirq, so we need to keep the link, until
    pci_pm_suspend_noirq finish.
    
    Signed-off-by: Wang Dongsheng <dongsheng.wang@freescale.com>
    Signed-off-by: Scott Wood <scottwood@freescale.com>

commit 72f72dcc146fd7c4f9a8544626b961d52f1399b3
Author: Kevin Hao <haokexin@gmail.com>
Date:   Tue Mar 18 00:26:49 2014 -0700

    e1000e: fix the build error when PM is disabled
    
    The commit 2800209994f8 (e1000e: Refactor PM flows) changed the
    SET_SYSTEM_SLEEP_PM_OPS to open-coded assignment, but forgot to
    protect them with CONFIG_PM_SLEEP. Then cause the following build
    error when PM is disabled:
    drivers/net/ethernet/intel/e1000e/netdev.c:7079:13:
    error: 'e1000e_pm_suspend' undeclared here (not in a function)
      .suspend = e1000e_pm_suspend,
                 ^
    drivers/net/ethernet/intel/e1000e/netdev.c:7080:13:
    error: 'e1000e_pm_resume' undeclared here (not in a function)
      .resume  = e1000e_pm_resume,
                 ^
    drivers/net/ethernet/intel/e1000e/netdev.c:7082:11:
    error: 'e1000e_pm_thaw' undeclared here (not in a function)
      .thaw  = e1000e_pm_thaw,
               ^
    Signed-off-by: Kevin Hao <haokexin@gmail.com>
    Tested-by: Aaron Brown <aaron.f.brown@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit cd979883b9ede90643e019f33cb317933eb867b4
Author: Stanislaw Gruszka <sgruszka@redhat.com>
Date:   Wed Feb 26 11:30:30 2014 +0100

    xen/acpi-processor: fix enabling interrupts on syscore_resume
    
    syscore->resume() callback is expected to do not enable interrupts,
    it generates warning like below otherwise:
    
    [ 9386.365390] WARNING: CPU: 0 PID: 6733 at drivers/base/syscore.c:104 syscore_resume+0x9a/0xe0()
    [ 9386.365403] Interrupts enabled after xen_acpi_processor_resume+0x0/0x34 [xen_acpi_processor]
    ...
    [ 9386.365429] Call Trace:
    [ 9386.365434]  [<ffffffff81667a8b>] dump_stack+0x45/0x56
    [ 9386.365437]  [<ffffffff8106921d>] warn_slowpath_common+0x7d/0xa0
    [ 9386.365439]  [<ffffffff8106928c>] warn_slowpath_fmt+0x4c/0x50
    [ 9386.365442]  [<ffffffffa0261bb0>] ? xen_upload_processor_pm_data+0x300/0x300 [xen_acpi_processor]
    [ 9386.365443]  [<ffffffff814055fa>] syscore_resume+0x9a/0xe0
    [ 9386.365445]  [<ffffffff810aef42>] suspend_devices_and_enter+0x402/0x470
    [ 9386.365447]  [<ffffffff810af128>] pm_suspend+0x178/0x260
    
    On xen_acpi_processor_resume() we call various procedures, which are
    non atomic and can enable interrupts. To prevent the issue introduce
    separate resume notify called after we enable interrupts on resume
    and before we call other drivers resume callbacks.
    
    Signed-off-by: Stanislaw Gruszka <sgruszka@redhat.com>
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>

commit 8a3433570cb91d5e4d276f9f7e9820a77e4331a7
Author: Shawn Guo <shawn.guo@linaro.org>
Date:   Sat Feb 8 13:20:35 2014 +0800

    ASoC: fsl: fix pm support of machine drivers
    
    commit 47cf84e17ebb79a20e6244b954c4ea4e18a82d43 upstream.
    
    The commit 1abe729 (ASoC: fsl: Add missing pm to current machine
    drivers) enables pm support for a few IMX machine drivers.  But it does
    not update dev drvdata to be the pointer to 'card'.  This causes the
    kernel dump below in system suspend, because snd_soc_suspend() expects
    that the dev drvdata points to 'card', while it still points to the
    private data of machine driver.
    
    This patch fixes imx-sgtl5000 and imx-wm8962 by attaching 'card' to dev
    drvdata and private data to card drvdata.  For imx-mc13783, I simply
    revert the pm change because it must be broken for the same reason and
    I don't have hardware to test pm enabling code.
    
    $ echo mem > /sys/power/state
    PM: Syncing filesystems ... done.
    PM: Preparing system for mem sleep
    mmc1: card e624 removed
    Freezing user space processes ... (elapsed 0.002 seconds) done.
    Freezing remaining freezable tasks ... (elapsed 0.002 seconds) done.
    PM: Entering mem sleep
    INFO: trying to register non-static key.
    the code is fine but needs lockdep annotation.
    turning off the locking correctness validator.
    CPU: 0 PID: 1861 Comm: bash Not tainted 3.14.0-rc1+ #1648
    Backtrace:
    [<80012144>] (dump_backtrace) from [<800122e4>] (show_stack+0x18/0x1c)
     r6:8079c77c r5:00000c5a r4:00000000 r3:00000000
    [<800122cc>] (show_stack) from [<80637ac0>] (dump_stack+0x78/0x94)
    [<80637a48>] (dump_stack) from [<80028918>] (warn_slowpath_common+0x6c/0x8c)
     r4:bdb21c38 r3:be62df00
    [<800288ac>] (warn_slowpath_common) from [<800289dc>] (warn_slowpath_fmt+0x38/0x40)
     r8:be62e3a8 r7:bf122960 r6:00000005 r5:00000000 r4:00000000
    [<800289a8>] (warn_slowpath_fmt) from [<8006518c>] (__lock_acquire+0x1ae0/0x1ce0)
     r3:8079d598 r2:80799e70
    [<800636ac>] (__lock_acquire) from [<80065894>] (lock_acquire+0x68/0x7c)
     r10:bdb20000 r9:be62df00 r8:00000000 r7:00000000 r6:60000013 r5:bdb20000
     r4:00000000
    [<8006582c>] (lock_acquire) from [<8063c938>] (mutex_lock_nested+0x5c/0x3b8)
     r7:00000000 r6:80dfc78c r5:804be444 r4:bf122928
    [<8063c8dc>] (mutex_lock_nested) from [<804be444>] (snd_soc_suspend+0x34/0x42c)
     r10:00000000 r9:00000000 r8:00000000 r7:bf1c4444 r6:bf1c4410 r5:be978150
     r4:be978010
    [<804be410>] (snd_soc_suspend) from [<8034392c>] (platform_pm_suspend+0x34/0x64)
     r10:00000000 r8:00000000 r7:bf1c4444 r6:bf1c4410 r5:803438f8 r4:bf1c4410
    [<803438f8>] (platform_pm_suspend) from [<80348e18>] (dpm_run_callback.isra.7+0x34/0x6c)
    [<80348de4>] (dpm_run_callback.isra.7) from [<80349354>] (__device_suspend+0x10c/0x220)
     r9:808dd974 r8:808c4a5c r6:00000002 r5:80e5001c r4:bf1c4410
    [<80349248>] (__device_suspend) from [<8034a338>] (dpm_suspend+0x60/0x220)
     r7:bf1c4410 r6:808dd90c r5:80e5001c r4:bf1c44c0
    [<8034a2d8>] (dpm_suspend) from [<8034a790>] (dpm_suspend_start+0x60/0x68)
     r10:8079a818 r9:00000000 r8:00000004 r7:80dfbe90 r6:80641eec r5:00000000
     r4:00000002
    [<8034a730>] (dpm_suspend_start) from [<8006a788>] (suspend_devices_and_enter+0x74/0x318)
     r4:00000003 r3:80dfbe98
    [<8006a714>] (suspend_devices_and_enter) from [<8006abd8>] (pm_suspend+0x1ac/0x244)
     r10:8079a818 r8:00000004 r7:00000003 r6:80641eec r5:00000000 r4:00000003
    [<8006aa2c>] (pm_suspend) from [<80069a4c>] (state_store+0x70/0xc0)
     r5:00000003 r4:bd85ea40
    [<800699dc>] (state_store) from [<80294034>] (kobj_attr_store+0x1c/0x28)
     r10:beb9fe08 r8:00000000 r7:bdb21f78 r6:bd85ea40 r5:00000004 r4:beb9fe00
    [<80294018>] (kobj_attr_store) from [<80140f90>] (sysfs_kf_write+0x54/0x58)
    [<80140f3c>] (sysfs_kf_write) from [<8014474c>] (kernfs_fop_write+0xc4/0x160)
     r6:bd85ea40 r5:beb9fe00 r4:00000004 r3:80140f3c
    [<80144688>] (kernfs_fop_write) from [<800dfa14>] (vfs_write+0xbc/0x184)
     r10:00000000 r9:00000000 r8:00000000 r7:bdb21f78 r6:00500c08 r5:00000004
     r4:be782600
    [<800df958>] (vfs_write) from [<800dfe00>] (SyS_write+0x48/0x70)
     r10:00000000 r8:00000000 r7:00000004 r6:00500c08 r5:00000000 r4:be782600
    [<800dfdb8>] (SyS_write) from [<8000e800>] (ret_fast_syscall+0x0/0x48)
     r9:bdb20000 r8:8000e9c4 r7:00000004 r6:00500c08 r5:00000004 r4:76eb65e0
    
    Fixes: 1abe729 (ASoC: fsl: Add missing pm to current machine drivers)
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>
    Signed-off-by: Mark Brown <broonie@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 5f59df79837bb809f3945613aba5519cd9755a53
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Sat Mar 1 11:56:04 2014 +0100

    PM / runtime: Fetch runtime PM callbacks using a macro
    
    While fetching the proper runtime PM callback, we walk the hierarchy of
    device's power domains, subsystems and drivers.
    
    This is common for rpm_suspend(), rpm_idle() and rpm_resume(). Let's
    clean up the code by using a macro that handles this.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit f0ceb114aec78cc585b8e7cb3d536f8a3e386bf1
Author: Axel Lin <axel.lin@ingics.com>
Date:   Sun Feb 23 13:27:16 2014 +0800

    spi: qup: Fix build error due to a typo
    
    Fix below build error when CONFIG_PM_RUNTIME=y:
    
    C [M]  drivers/spi/spi-qup.o
    drivers/spi/spi-qup.c: In function 'spi_qup_pm_suspend_runtime':
    drivers/spi/spi-qup.c:712:12: error: 'QUP_CLOCK_AUTO_GATE' undeclared (first use in this function)
    drivers/spi/spi-qup.c:712:12: note: each undeclared identifier is reported only once for each function it appears in
    drivers/spi/spi-qup.c: In function 'spi_qup_pm_resume_runtime':
    drivers/spi/spi-qup.c:725:13: error: 'QUP_CLOCK_AUTO_GATE' undeclared (first use in this function)
    make[2]: *** [drivers/spi/spi-qup.o] Error 1
    make[1]: *** [drivers/spi] Error 2
    make: *** [drivers] Error 2
    
    Signed-off-by: Axel Lin <axel.lin@ingics.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

commit 6964d91db2becfe80658f50584d264708ca7f49e
Author: viresh kumar <viresh.kumar@linaro.org>
Date:   Mon Feb 17 14:52:11 2014 +0530

    cpufreq: remove sysfs link when a cpu != policy->cpu, is removed
    
    Commit 42f921a (cpufreq: remove sysfs files for CPUs which failed to
    come back after resume) tried to do this but missed this piece of code
    to fix.
    
    Currently we are getting this on suspend/resume:
    
    ------------[ cut here ]------------
    WARNING: CPU: 0 PID: 877 at fs/sysfs/dir.c:52 sysfs_warn_dup+0x68/0x84()
    sysfs: cannot create duplicate filename '/devices/system/cpu/cpu1/cpufreq'
    Modules linked in: brcmfmac brcmutil
    CPU: 0 PID: 877 Comm: test-rtc-resume Not tainted 3.14.0-rc2-00259-g9398a10cd964 #12
    [<c0015bac>] (unwind_backtrace) from [<c0011850>] (show_stack+0x10/0x14)
    [<c0011850>] (show_stack) from [<c056e018>] (dump_stack+0x80/0xcc)
    [<c056e018>] (dump_stack) from [<c0025e44>] (warn_slowpath_common+0x64/0x88)
    [<c0025e44>] (warn_slowpath_common) from [<c0025efc>] (warn_slowpath_fmt+0x30/0x40)
    [<c0025efc>] (warn_slowpath_fmt) from [<c012776c>] (sysfs_warn_dup+0x68/0x84)
    [<c012776c>] (sysfs_warn_dup) from [<c0127a54>] (sysfs_do_create_link_sd+0xb0/0xb8)
    [<c0127a54>] (sysfs_do_create_link_sd) from [<c038ef64>] (__cpufreq_add_dev.isra.27+0x2a8/0x814)
    [<c038ef64>] (__cpufreq_add_dev.isra.27) from [<c038f548>] (cpufreq_cpu_callback+0x70/0x8c)
    [<c038f548>] (cpufreq_cpu_callback) from [<c0043864>] (notifier_call_chain+0x44/0x84)
    [<c0043864>] (notifier_call_chain) from [<c0025f60>] (__cpu_notify+0x28/0x44)
    [<c0025f60>] (__cpu_notify) from [<c00261e8>] (_cpu_up+0xf0/0x140)
    [<c00261e8>] (_cpu_up) from [<c0569eb8>] (enable_nonboot_cpus+0x68/0xb0)
    [<c0569eb8>] (enable_nonboot_cpus) from [<c006339c>] (suspend_devices_and_enter+0x198/0x2dc)
    [<c006339c>] (suspend_devices_and_enter) from [<c0063654>] (pm_suspend+0x174/0x1e8)
    [<c0063654>] (pm_suspend) from [<c00624e0>] (state_store+0x6c/0xbc)
    [<c00624e0>] (state_store) from [<c01fc200>] (kobj_attr_store+0x14/0x20)
    [<c01fc200>] (kobj_attr_store) from [<c0126e50>] (sysfs_kf_write+0x44/0x48)
    [<c0126e50>] (sysfs_kf_write) from [<c012a274>] (kernfs_fop_write+0xb4/0x14c)
    [<c012a274>] (kernfs_fop_write) from [<c00d4818>] (vfs_write+0xa8/0x180)
    [<c00d4818>] (vfs_write) from [<c00d4bb8>] (SyS_write+0x3c/0x70)
    [<c00d4bb8>] (SyS_write) from [<c000e620>] (ret_fast_syscall+0x0/0x30)
    ---[ end trace 76969904b614c18f ]---
    
    Fix this by removing sysfs link for cpufreq directory when cpu removed
    isn't policy->cpu.
    
    Revamps: 42f921a (cpufreq: remove sysfs files for CPUs which failed to come back after resume)
    Reported-and-tested-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 47cf84e17ebb79a20e6244b954c4ea4e18a82d43
Author: Shawn Guo <shawn.guo@linaro.org>
Date:   Sat Feb 8 13:20:35 2014 +0800

    ASoC: fsl: fix pm support of machine drivers
    
    The commit 1abe729 (ASoC: fsl: Add missing pm to current machine
    drivers) enables pm support for a few IMX machine drivers.  But it does
    not update dev drvdata to be the pointer to 'card'.  This causes the
    kernel dump below in system suspend, because snd_soc_suspend() expects
    that the dev drvdata points to 'card', while it still points to the
    private data of machine driver.
    
    This patch fixes imx-sgtl5000 and imx-wm8962 by attaching 'card' to dev
    drvdata and private data to card drvdata.  For imx-mc13783, I simply
    revert the pm change because it must be broken for the same reason and
    I don't have hardware to test pm enabling code.
    
    $ echo mem > /sys/power/state
    PM: Syncing filesystems ... done.
    PM: Preparing system for mem sleep
    mmc1: card e624 removed
    Freezing user space processes ... (elapsed 0.002 seconds) done.
    Freezing remaining freezable tasks ... (elapsed 0.002 seconds) done.
    PM: Entering mem sleep
    INFO: trying to register non-static key.
    the code is fine but needs lockdep annotation.
    turning off the locking correctness validator.
    CPU: 0 PID: 1861 Comm: bash Not tainted 3.14.0-rc1+ #1648
    Backtrace:
    [<80012144>] (dump_backtrace) from [<800122e4>] (show_stack+0x18/0x1c)
     r6:8079c77c r5:00000c5a r4:00000000 r3:00000000
    [<800122cc>] (show_stack) from [<80637ac0>] (dump_stack+0x78/0x94)
    [<80637a48>] (dump_stack) from [<80028918>] (warn_slowpath_common+0x6c/0x8c)
     r4:bdb21c38 r3:be62df00
    [<800288ac>] (warn_slowpath_common) from [<800289dc>] (warn_slowpath_fmt+0x38/0x40)
     r8:be62e3a8 r7:bf122960 r6:00000005 r5:00000000 r4:00000000
    [<800289a8>] (warn_slowpath_fmt) from [<8006518c>] (__lock_acquire+0x1ae0/0x1ce0)
     r3:8079d598 r2:80799e70
    [<800636ac>] (__lock_acquire) from [<80065894>] (lock_acquire+0x68/0x7c)
     r10:bdb20000 r9:be62df00 r8:00000000 r7:00000000 r6:60000013 r5:bdb20000
     r4:00000000
    [<8006582c>] (lock_acquire) from [<8063c938>] (mutex_lock_nested+0x5c/0x3b8)
     r7:00000000 r6:80dfc78c r5:804be444 r4:bf122928
    [<8063c8dc>] (mutex_lock_nested) from [<804be444>] (snd_soc_suspend+0x34/0x42c)
     r10:00000000 r9:00000000 r8:00000000 r7:bf1c4444 r6:bf1c4410 r5:be978150
     r4:be978010
    [<804be410>] (snd_soc_suspend) from [<8034392c>] (platform_pm_suspend+0x34/0x64)
     r10:00000000 r8:00000000 r7:bf1c4444 r6:bf1c4410 r5:803438f8 r4:bf1c4410
    [<803438f8>] (platform_pm_suspend) from [<80348e18>] (dpm_run_callback.isra.7+0x34/0x6c)
    [<80348de4>] (dpm_run_callback.isra.7) from [<80349354>] (__device_suspend+0x10c/0x220)
     r9:808dd974 r8:808c4a5c r6:00000002 r5:80e5001c r4:bf1c4410
    [<80349248>] (__device_suspend) from [<8034a338>] (dpm_suspend+0x60/0x220)
     r7:bf1c4410 r6:808dd90c r5:80e5001c r4:bf1c44c0
    [<8034a2d8>] (dpm_suspend) from [<8034a790>] (dpm_suspend_start+0x60/0x68)
     r10:8079a818 r9:00000000 r8:00000004 r7:80dfbe90 r6:80641eec r5:00000000
     r4:00000002
    [<8034a730>] (dpm_suspend_start) from [<8006a788>] (suspend_devices_and_enter+0x74/0x318)
     r4:00000003 r3:80dfbe98
    [<8006a714>] (suspend_devices_and_enter) from [<8006abd8>] (pm_suspend+0x1ac/0x244)
     r10:8079a818 r8:00000004 r7:00000003 r6:80641eec r5:00000000 r4:00000003
    [<8006aa2c>] (pm_suspend) from [<80069a4c>] (state_store+0x70/0xc0)
     r5:00000003 r4:bd85ea40
    [<800699dc>] (state_store) from [<80294034>] (kobj_attr_store+0x1c/0x28)
     r10:beb9fe08 r8:00000000 r7:bdb21f78 r6:bd85ea40 r5:00000004 r4:beb9fe00
    [<80294018>] (kobj_attr_store) from [<80140f90>] (sysfs_kf_write+0x54/0x58)
    [<80140f3c>] (sysfs_kf_write) from [<8014474c>] (kernfs_fop_write+0xc4/0x160)
     r6:bd85ea40 r5:beb9fe00 r4:00000004 r3:80140f3c
    [<80144688>] (kernfs_fop_write) from [<800dfa14>] (vfs_write+0xbc/0x184)
     r10:00000000 r9:00000000 r8:00000000 r7:bdb21f78 r6:00500c08 r5:00000004
     r4:be782600
    [<800df958>] (vfs_write) from [<800dfe00>] (SyS_write+0x48/0x70)
     r10:00000000 r8:00000000 r7:00000004 r6:00500c08 r5:00000000 r4:be782600
    [<800dfdb8>] (SyS_write) from [<8000e800>] (ret_fast_syscall+0x0/0x48)
     r9:bdb20000 r8:8000e9c4 r7:00000004 r6:00500c08 r5:00000004 r4:76eb65e0
    
    Fixes: 1abe729 (ASoC: fsl: Add missing pm to current machine drivers)
    Cc: stable@vger.kernel.org
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>
    Signed-off-by: Mark Brown <broonie@linaro.org>

commit 9d7fd21acb2094d38d8560b0b3c91fa31efa6a71
Author: Krzysztof Kozlowski <krzk@kernel.org>
Date:   Mon Oct 21 15:42:50 2013 +0200

    spi/s3c64xx: Fix doubled clock disable on suspend
    
    Fix doubled clock disable and unprepare during PM suspend which triggered
    the warnings:
    
    WARNING: at drivers/clk/clk.c:800 clk_disable+0x18/0x24()
    Modules linked in:
    CPU: 0 PID: 1745 Comm: sh Not tainted 3.10.14-01211-ge2549bb-dirty #62
    [<c0015980>] (unwind_backtrace+0x0/0x138) from [<c0012a44>] (show_stack+0x10/0x14)
    [<c0012a44>] (show_stack+0x10/0x14) from [<c0022818>] (warn_slowpath_common+0x4c/0x68)
    [<c0022818>] (warn_slowpath_common+0x4c/0x68) from [<c0022850>] (warn_slowpath_null+0x1c/0x24)
    [<c0022850>] (warn_slowpath_null+0x1c/0x24) from [<c036e274>] (clk_disable+0x18/0x24)
    [<c036e274>] (clk_disable+0x18/0x24) from [<c02d5f78>] (s3c64xx_spi_suspend+0x28/0x54)
    [<c02d5f78>] (s3c64xx_spi_suspend+0x28/0x54) from [<c02b3a54>] (platform_pm_suspend+0x2c/0x5c)
    [<c02b3a54>] (platform_pm_suspend+0x2c/0x5c) from [<c02b8a30>] (dpm_run_callback+0x44/0x7c)
    [<c02b8a30>] (dpm_run_callback+0x44/0x7c) from [<c02b8b70>] (__device_suspend+0x108/0x300)
    [<c02b8b70>] (__device_suspend+0x108/0x300) from [<c02ba4e0>] (dpm_suspend+0x54/0x208)
    [<c02ba4e0>] (dpm_suspend+0x54/0x208) from [<c0066bcc>] (suspend_devices_and_enter+0x98/0x458)
    [<c0066bcc>] (suspend_devices_and_enter+0x98/0x458) from [<c0067150>] (pm_suspend+0x1c4/0x25c)
    [<c0067150>] (pm_suspend+0x1c4/0x25c) from [<c0066044>] (state_store+0x6c/0xbc)
    [<c0066044>] (state_store+0x6c/0xbc) from [<c0203290>] (kobj_attr_store+0x14/0x20)
    [<c0203290>] (kobj_attr_store+0x14/0x20) from [<c0157530>] (sysfs_write_file+0xfc/0x164)
    [<c0157530>] (sysfs_write_file+0xfc/0x164) from [<c00fd6b0>] (vfs_write+0xbc/0x1bc)
    [<c00fd6b0>] (vfs_write+0xbc/0x1bc) from [<c00fdaf0>] (SyS_write+0x40/0x68)
    [<c00fdaf0>] (SyS_write+0x40/0x68) from [<c000ea80>] (ret_fast_syscall+0x0/0x3c)
    
    The clocks may be already disabled before suspending. Check PM runtime
    suspend status and disable clocks only if device is not suspended.
    During resume do not enable the clocks if device is runtime suspended.
    
    Signed-off-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>
    Reviewed-by: Sylwester Nawrocki <s.nawrocki@samsung.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

commit d66e6db28df330c0e5b61f9863754fc2fd37f8ca
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Tue Oct 15 22:25:08 2013 +0200

    PM / Runtime: Respect autosuspend when idle triggers suspend
    
    For devices which don't have a .runtime_idle() callback or if it
    returns 0, rpm_idle() will end up in triggering a call to
    rpm_suspend(), thus trying to carry out a runtime suspend directly
    from runtime_idle().
    
    In the above situation we want to respect devices which has enabled
    autosuspend, we therfore append the flag sent to rpm_suspend with
    RPM_AUTO.
    
    Do note that drivers still needs to update the device last busy mark,
    to control the delay for this circumstance.
    
    Updated runtime PM documentation accordingly.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Acked-by: Kevin Hilman <khilman@linaro.org>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 64270d82d4bf7fb8e5347c41ea7d0477aa551391
Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Date:   Fri Sep 27 16:54:42 2013 +0100

    ARM: vexpress: tc2: fix hotplug/idle/kexec race on cluster power down
    
    On the TC2 testchip, when all CPUs in a cluster enter standbywfi
    and commit a power down request, the power controller will wait
    for standbywfil2 coming from L2 cache controller to shut the
    cluster down.
    By the time all CPUs in a cluster commit a power down request
    and enter wfi, the power controller cannot backtrack, or put it
    another way, a CPU must not be allowed to complete execution
    independently of the power controller, the only way for it to
    resume properly must be upon wake-up IRQ pending and subsequent
    reset triggered from the power controller.
    
    Current MCPM back-end for TC2 disables the GIC CPU IF only when
    power down is committed through the tc2_pm_suspend() method, that
    makes sense since a suspended CPU is still online and can receive
    interrupts whereas a hotplugged CPU, since it is offline,
    migrated all IRQs and shutdown the per-CPU peripherals, hence
    their PPIs.
    
    The flaw with this reasoning is the following. If all CPUs in
    a clusters are entering a power down state either through CPU
    idle or CPU hotplug, when the last man successfully completes
    the MCPM power down sequence (and executes wfi), power controller
    waits for L2 wfi signal to quiesce the cluster and shut it down.
    If, when all CPUs are sitting in wfi, an online CPU hotplugs back
    in one of the CPUs in the cluster being shutdown, that CPU
    receives an IPI that causes wfi to complete (since tc2_pm_down()
    method does not disable the GIC CPU IF in that case - CPU being
    hotplugged out, not idle) and the power controller will never see
    the stanbywfil2 signal coming from L2 that is required for
    shutdown to happen and the system deadlocks.
    
    Further to this issue, kexec hotplugs secondary CPUs out during
    kernel reload/restart.
    Because kexec may (deliberately) trash the old kernel text, it is
    not OK for CPUs to follow the MCPM soft reboot path, since
    instructions after the WFI may have been replaced by kexec.
    
    If tc2_pm_down() does not disable the GIC cpu interface, there is a
    race between CPU powerdown in the old kernel and the IPI from the
    new kernel that triggers secondary boot, particularly if the
    powerdown is slow (due to L2 cache cleaning for example).  If the
    new kernel wins the race, the affected CPU(s) will not really be
    reset and may execute garbage after the WFI.
    
    The only solution to this problem consists in disabling the GIC
    CPU IF on a CPU committed to power down regardless of the power
    down entry method (CPU hotplug or CPU idle). This way, CPU wake-up
    is under power controller control, which prevents unexpected wfi
    exit caused by a pending IRQ.
    
    This patch moves the GIC CPU IF disable call in the TC2 MCPM
    implementation from the tc2_pm_suspend() method to the
    tc2_pm_down() method to fix the mentioned race condition(s).
    
    Reviewed-by: Dave Martin <Dave.Martin@arm.com>
    Tested-by: Dave Martin <Dave.Martin@arm.com> (for kexec)
    Signed-off-by: Sudeep KarkadaNagesha <sudeep.karkadanagesha@arm.com>
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Signed-off-by: Olof Johansson <olof@lixom.net>

commit a35c6322e52c550b61a04a44df27d22394ee0a2c
Merge: bef4a0ab9846 158a71f83800
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Sep 9 16:08:13 2013 -0700

    Merge tag 'drivers-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC driver update from Kevin Hilman:
     "This contains the ARM SoC related driver updates for v3.12.  The only
      thing this cycle are core PM updates and CPUidle support for ARM's TC2
      big.LITTLE development platform"
    
    * tag 'drivers-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc:
      cpuidle: big.LITTLE: vexpress-TC2 CPU idle driver
      ARM: vexpress: tc2: disable GIC CPU IF in tc2_pm_suspend
      drivers: irq-chip: irq-gic: introduce gic_cpu_if_down()

commit aaf75e454cc5e16e7f24bd87590b2d882ddb1671
Merge: b36f4be3de1b 14d2c34cfa00
Author: Olof Johansson <olof@lixom.net>
Date:   Wed Aug 28 11:29:18 2013 -0700

    Merge branch 'cpuidle/biglittle' into next/drivers
    
    From Lorenzo Pieralisi:
    This patch series contains:
    
    - GIC driver update to add a method to disable the GIC CPU IF
    - TC2 MCPM update to add GIC CPU disabling to suspend method
    - TC2 CPU idle big.LITTLE driver
    
    * cpuidle/biglittle:
      cpuidle: big.LITTLE: vexpress-TC2 CPU idle driver
      ARM: vexpress: tc2: disable GIC CPU IF in tc2_pm_suspend
      drivers: irq-chip: irq-gic: introduce gic_cpu_if_down()
      ARM: vexpress/TC2: implement PM suspend method
      ARM: vexpress/TC2: basic PM support
      ARM: vexpress: Add SCC to V2P-CA15_A7's device tree
      ARM: vexpress/TC2: add Serial Power Controller (SPC) support
      ARM: vexpress/dcscb: fix cache disabling sequences
    
    Signed-off-by: Olof Johansson <olof@lixom.net>

commit 9ee2ee0f0576fc070b02e5d31a2c4d09c39f439a
Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Date:   Wed Jul 24 12:05:01 2013 +0100

    ARM: vexpress: tc2: disable GIC CPU IF in tc2_pm_suspend
    
    To prevent cores from exiting wfi when they are about to be shut down
    the GIC CPU IF must be disabled so that the GIC CPU IF IRQ output line
    is not asserted to the cores. wfi completion must be prevented since,
    in absence of coordinating HW logic, if the power controller receives
    a standbywfi signal but in the meantime the processor restarts executing
    owing to a pending IRQ, the core might be reset when running in a
    non-quiescent state (eg with pending load/store transactions)
    
    Raw GIC distributor IRQ signals are routed to the power controller, that
    is capable of taking core out of reset on pending IRQs even if their GIC
    CPU IF is disabled, thus keeping the normal wfi behaviour.
    
    GIC CPU IF is restored upon CPU wake-up by the respective MCPM API
    consumers (ie CPU idle driver and suspend to RAM thread).
    
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Signed-off-by: Olof Johansson <olof@lixom.net>

commit f991fae5c6d42dfc5029150b05a78cf3f6c18cc9
Merge: d4141531f63a 2c843bd92ec2
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jul 3 14:35:40 2013 -0700

    Merge tag 'pm+acpi-3.11-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull power management and ACPI updates from Rafael Wysocki:
     "This time the total number of ACPI commits is slightly greater than
      the number of cpufreq commits, but Viresh Kumar (who works on cpufreq)
      remains the most active patch submitter.
    
      To me, the most significant change is the addition of offline/online
      device operations to the driver core (with the Greg's blessing) and
      the related modifications of the ACPI core hotplug code.  Next are the
      freezer updates from Colin Cross that should make the freezing of
      tasks a bit less heavy weight.
    
      We also have a couple of regression fixes, a number of fixes for
      issues that have not been identified as regressions, two new drivers
      and a bunch of cleanups all over.
    
      Highlights:
    
       - Hotplug changes to support graceful hot-removal failures.
    
         It sometimes is necessary to fail device hot-removal operations
         gracefully if they cannot be carried out completely.  For example,
         if memory from a memory module being hot-removed has been allocated
         for the kernel's own use and cannot be moved elsewhere, it's
         desirable to fail the hot-removal operation in a graceful way
         rather than to crash the kernel, but currenty a success or a kernel
         crash are the only possible outcomes of an attempted memory
         hot-removal.  Needless to say, that is not a very attractive
         alternative and it had to be addressed.
    
         However, in order to make it work for memory, I first had to make
         it work for CPUs and for this purpose I needed to modify the ACPI
         processor driver.  It's been split into two parts, a resident one
         handling the low-level initialization/cleanup and a modular one
         playing the actual driver's role (but it binds to the CPU system
         device objects rather than to the ACPI device objects representing
         processors).  That's been sort of like a live brain surgery on a
         patient who's riding a bike.
    
         So this is a little scary, but since we found and fixed a couple of
         regressions it caused to happen during the early linux-next testing
         (a month ago), nobody has complained.
    
         As a bonus we remove some duplicated ACPI hotplug code, because the
         ACPI-based CPU hotplug is now going to use the common ACPI hotplug
         code.
    
       - Lighter weight freezing of tasks.
    
         These changes from Colin Cross and Mandeep Singh Baines are
         targeted at making the freezing of tasks a bit less heavy weight
         operation.  They reduce the number of tasks woken up every time
         during the freezing, by using the observation that the freezer
         simply doesn't need to wake up some of them and wait for them all
         to call refrigerator().  The time needed for the freezer to decide
         to report a failure is reduced too.
    
         Also reintroduced is the check causing a lockdep warining to
         trigger when try_to_freeze() is called with locks held (which is
         generally unsafe and shouldn't happen).
    
       - cpufreq updates
    
         First off, a commit from Srivatsa S Bhat fixes a resume regression
         introduced during the 3.10 cycle causing some cpufreq sysfs
         attributes to return wrong values to user space after resume.  The
         fix is kind of fresh, but also it's pretty obvious once Srivatsa
         has identified the root cause.
    
         Second, we have a new freqdomain_cpus sysfs attribute for the
         acpi-cpufreq driver to provide information previously available via
         related_cpus.  From Lan Tianyu.
    
         Finally, we fix a number of issues, mostly related to the
         CPUFREQ_POSTCHANGE notifier and cpufreq Kconfig options and clean
         up some code.  The majority of changes from Viresh Kumar with bits
         from Jacob Shin, Heiko Stübner, Xiaoguang Chen, Ezequiel Garcia,
         Arnd Bergmann, and Tang Yuantian.
    
       - ACPICA update
    
         A usual bunch of updates from the ACPICA upstream.
    
         During the 3.4 cycle we introduced support for ACPI 5 extended
         sleep registers, but they are only supposed to be used if the
         HW-reduced mode bit is set in the FADT flags and the code attempted
         to use them without checking that bit.  That caused suspend/resume
         regressions to happen on some systems.  Fix from Lv Zheng causes
         those registers to be used only if the HW-reduced mode bit is set.
    
         Apart from this some other ACPICA bugs are fixed and code cleanups
         are made by Bob Moore, Tomasz Nowicki, Lv Zheng, Chao Guan, and
         Zhang Rui.
    
       - cpuidle updates
    
         New driver for Xilinx Zynq processors is added by Michal Simek.
    
         Multidriver support simplification, addition of some missing
         kerneldoc comments and Kconfig-related fixes come from Daniel
         Lezcano.
    
       - ACPI power management updates
    
         Changes to make suspend/resume work correctly in Xen guests from
         Konrad Rzeszutek Wilk, sparse warning fix from Fengguang Wu and
         cleanups and fixes of the ACPI device power state selection
         routine.
    
       - ACPI documentation updates
    
         Some previously missing pieces of ACPI documentation are added by
         Lv Zheng and Aaron Lu (hopefully, that will help people to
         uderstand how the ACPI subsystem works) and one outdated doc is
         updated by Hanjun Guo.
    
       - Assorted ACPI updates
    
         We finally nailed down the IA-64 issue that was the reason for
         reverting commit 9f29ab11ddbf ("ACPI / scan: do not match drivers
         against objects having scan handlers"), so we can fix it and move
         the ACPI scan handler check added to the ACPI video driver back to
         the core.
    
         A mechanism for adding CMOS RTC address space handlers is
         introduced by Lan Tianyu to allow some EC-related breakage to be
         fixed on some systems.
    
         A spec-compliant implementation of acpi_os_get_timer() is added by
         Mika Westerberg.
    
         The evaluation of _STA is added to do_acpi_find_child() to avoid
         situations in which a pointer to a disabled device object is
         returned instead of an enabled one with the same _ADR value.  From
         Jeff Wu.
    
         Intel BayTrail PCH (Platform Controller Hub) support is added to
         the ACPI driver for Intel Low-Power Subsystems (LPSS) and that
         driver is modified to work around a couple of known BIOS issues.
         Changes from Mika Westerberg and Heikki Krogerus.
    
         The EC driver is fixed by Vasiliy Kulikov to use get_user() and
         put_user() instead of dereferencing user space pointers blindly.
    
         Code cleanups are made by Bjorn Helgaas, Nicholas Mazzuca and Toshi
         Kani.
    
       - Assorted power management updates
    
         The "runtime idle" helper routine is changed to take the return
         values of the callbacks executed by it into account and to call
         rpm_suspend() if they return 0, which allows us to reduce the
         overall code bloat a bit (by dropping some code that's not
         necessary any more after that modification).
    
         The runtime PM documentation is updated by Alan Stern (to reflect
         the "runtime idle" behavior change).
    
         New trace points for PM QoS are added by Sahara
         (<keun-o.park@windriver.com>).
    
         PM QoS documentation is updated by Lan Tianyu.
    
         Code cleanups are made and minor issues are addressed by Bernie
         Thompson, Bjorn Helgaas, Julius Werner, and Shuah Khan.
    
       - devfreq updates
    
         New driver for the Exynos5-bus device from Abhilash Kesavan.
    
         Minor cleanups, fixes and MAINTAINERS update from MyungJoo Ham,
         Abhilash Kesavan, Paul Bolle, Rajagopal Venkat, and Wei Yongjun.
    
       - OMAP power management updates
    
         Adaptive Voltage Scaling (AVS) SmartReflex voltage control driver
         updates from Andrii Tseglytskyi and Nishanth Menon."
    
    * tag 'pm+acpi-3.11-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (162 commits)
      cpufreq: Fix cpufreq regression after suspend/resume
      ACPI / PM: Fix possible NULL pointer deref in acpi_pm_device_sleep_state()
      PM / Sleep: Warn about system time after resume with pm_trace
      cpufreq: don't leave stale policy pointer in cdbs->cur_policy
      acpi-cpufreq: Add new sysfs attribute freqdomain_cpus
      cpufreq: make sure frequency transitions are serialized
      ACPI: implement acpi_os_get_timer() according the spec
      ACPI / EC: Add HP Folio 13 to ec_dmi_table in order to skip DSDT scan
      ACPI: Add CMOS RTC Operation Region handler support
      ACPI / processor: Drop unused variable from processor_perflib.c
      cpufreq: tegra: call CPUFREQ_POSTCHANGE notfier in error cases
      cpufreq: s3c64xx: call CPUFREQ_POSTCHANGE notfier in error cases
      cpufreq: omap: call CPUFREQ_POSTCHANGE notfier in error cases
      cpufreq: imx6q: call CPUFREQ_POSTCHANGE notfier in error cases
      cpufreq: exynos: call CPUFREQ_POSTCHANGE notfier in error cases
      cpufreq: dbx500: call CPUFREQ_POSTCHANGE notfier in error cases
      cpufreq: davinci: call CPUFREQ_POSTCHANGE notfier in error cases
      cpufreq: arm-big-little: call CPUFREQ_POSTCHANGE notfier in error cases
      cpufreq: powernow-k8: call CPUFREQ_POSTCHANGE notfier in error cases
      cpufreq: pcc: call CPUFREQ_POSTCHANGE notfier in error cases
      ...

commit 2786aae7fc935e44f81d5f359b6a768c81b46a9b
Author: Sebastian Siewior <bigeasy@linutronix.de>
Date:   Wed Jun 5 18:54:00 2013 +0200

    net/ti davinci_mdio: don't hold a spin lock while calling pm_runtime
    
    was playing with suspend and run into this:
    
    |BUG: sleeping function called from invalid context at drivers/base/power/runtime.c:891
    |in_atomic(): 1, irqs_disabled(): 0, pid: 1963, name: bash
    |6 locks held by bash/1963:
    |CPU: 0 PID: 1963 Comm: bash Not tainted 3.10.0-rc4+ #50
    |[<c0014fdc>] (unwind_backtrace+0x0/0xf8) from [<c0011da4>] (show_stack+0x10/0x14)
    |[<c0011da4>] (show_stack+0x10/0x14) from [<c02e8680>] (__pm_runtime_idle+0xa4/0xac)
    |[<c02e8680>] (__pm_runtime_idle+0xa4/0xac) from [<c0341158>] (davinci_mdio_suspend+0x6c/0x9c)
    |[<c0341158>] (davinci_mdio_suspend+0x6c/0x9c) from [<c02e0628>] (platform_pm_suspend+0x2c/0x54)
    |[<c02e0628>] (platform_pm_suspend+0x2c/0x54) from [<c02e52bc>] (dpm_run_callback.isra.3+0x2c/0x64)
    |[<c02e52bc>] (dpm_run_callback.isra.3+0x2c/0x64) from [<c02e57e4>] (__device_suspend+0x100/0x22c)
    |[<c02e57e4>] (__device_suspend+0x100/0x22c) from [<c02e67e8>] (dpm_suspend+0x68/0x230)
    |[<c02e67e8>] (dpm_suspend+0x68/0x230) from [<c0072a20>] (suspend_devices_and_enter+0x68/0x350)
    |[<c0072a20>] (suspend_devices_and_enter+0x68/0x350) from [<c0072f18>] (pm_suspend+0x210/0x24c)
    |[<c0072f18>] (pm_suspend+0x210/0x24c) from [<c0071c74>] (state_store+0x6c/0xbc)
    |[<c0071c74>] (state_store+0x6c/0xbc) from [<c02714dc>] (kobj_attr_store+0x14/0x20)
    |[<c02714dc>] (kobj_attr_store+0x14/0x20) from [<c01341a0>] (sysfs_write_file+0x16c/0x19c)
    |[<c01341a0>] (sysfs_write_file+0x16c/0x19c) from [<c00ddfe4>] (vfs_write+0xb4/0x190)
    |[<c00ddfe4>] (vfs_write+0xb4/0x190) from [<c00de3a4>] (SyS_write+0x3c/0x70)
    |[<c00de3a4>] (SyS_write+0x3c/0x70) from [<c000e2c0>] (ret_fast_syscall+0x0/0x48)
    
    I don't see a reason why the pm_runtime call must be under the lock.
    Further I don't understand why this is a spinlock and not mutex.
    
    Cc: Mugunthan V N <mugunthanvnm@ti.com>
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Acked-by: Mugunthan V N <mugunthanvnm@ti.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 45f0a85c8258741d11bda25c0a5669c06267204a
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Jun 3 21:49:52 2013 +0200

    PM / Runtime: Rework the "runtime idle" helper routine
    
    The "runtime idle" helper routine, rpm_idle(), currently ignores
    return values from .runtime_idle() callbacks executed by it.
    However, it turns out that many subsystems use
    pm_generic_runtime_idle() which checks the return value of the
    driver's callback and executes pm_runtime_suspend() for the device
    unless that value is not 0.  If that logic is moved to rpm_idle()
    instead, pm_generic_runtime_idle() can be dropped and its users
    will not need any .runtime_idle() callbacks any more.
    
    Moreover, the PCI, SCSI, and SATA subsystems' .runtime_idle()
    routines, pci_pm_runtime_idle(), scsi_runtime_idle(), and
    ata_port_runtime_idle(), respectively, as well as a few drivers'
    ones may be simplified if rpm_idle() calls rpm_suspend() after 0 has
    been returned by the .runtime_idle() callback executed by it.
    
    To reduce overall code bloat, make the changes described above.
    
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Tested-by: Kevin Hilman <khilman@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Kevin Hilman <khilman@linaro.org>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>

commit 1a276b80466bbd195cf94ec7178f68f2ab351467
Author: Ben Chan <benchan@chromium.org>
Date:   Sat Nov 24 19:35:36 2012 -0800

    staging: gdm72xx: protect access of rx / tx structs
    
    This patch applies spinlock to protect access to rx / tx structs in
    certain call sites, which fixes the following crash in gdm_suspend.
    It also fixes usb_set_intfdata() in gdm_usb_probe to avoid setting an
    already freed phy_dev.
    
    <5>[ 4996.815018] [<7f0074b0>] (gdm_suspend+0x1c/0x2b4 [gdmwm]) from [<803020a4>] (usb_suspend_both+0x80/0x1a0)
    <5>[ 4996.815055] [<803020a4>] (usb_suspend_both+0x80/0x1a0) from [<80302c84>] (usb_runtime_suspend+0x38/0x64)
    <5>[ 4996.815089] [<80302c84>] (usb_runtime_suspend+0x38/0x64) from [<802becc0>] (__rpm_callback+0x48/0x78)
    <5>[ 4996.815118] [<802becc0>] (__rpm_callback+0x48/0x78) from [<802bf8dc>] (rpm_suspend+0x394/0x5ec)
    <5>[ 4996.815145] [<802bf8dc>] (rpm_suspend+0x394/0x5ec) from [<802c0550>] (pm_runtime_work+0x8c/0xa4)
    <5>[ 4996.815177] [<802c0550>] (pm_runtime_work+0x8c/0xa4) from [<800456cc>] (process_one_work+0x264/0x438)
    <5>[ 4996.815209] [<800456cc>] (process_one_work+0x264/0x438) from [<80045acc>] (worker_thread+0x22c/0x3b8)
    <5>[ 4996.815239] [<80045acc>] (worker_thread+0x22c/0x3b8) from [<8004a43c>] (kthread+0x9c/0xa8)
    <5>[ 4996.815270] [<8004a43c>] (kthread+0x9c/0xa8) from [<8000f160>] (kernel_thread_exit+0x0/0x8)
    <0>[ 4996.815295] Code: e92d4000 e8bd4000 e2800020 eb4ab9a1 (e5905000)
    
    Signed-off-by: Ben Chan <benchan@chromium.org>
    Signed-off-by: Sameer Nanda <snanda@chromium.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 4e79752c25ec221ac1e28f8875b539ed7631a0db
Author: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
Date:   Wed Nov 7 13:35:32 2012 -0800

    sched: Mark RCU reader in sched_show_task()
    
    When sched_show_task() is invoked from try_to_freeze_tasks(), there is
    no RCU read-side critical section, resulting in the following splat:
    
    [  125.780730] ===============================
    [  125.780766] [ INFO: suspicious RCU usage. ]
    [  125.780804] 3.7.0-rc3+ #988 Not tainted
    [  125.780838] -------------------------------
    [  125.780875] /home/rafael/src/linux/kernel/sched/core.c:4497 suspicious rcu_dereference_check() usage!
    [  125.780946]
    [  125.780946] other info that might help us debug this:
    [  125.780946]
    [  125.781031]
    [  125.781031] rcu_scheduler_active = 1, debug_locks = 0
    [  125.781087] 4 locks held by s2ram/4211:
    [  125.781120]  #0:  (&buffer->mutex){+.+.+.}, at: [<ffffffff811e2acf>] sysfs_write_file+0x3f/0x160
    [  125.781233]  #1:  (s_active#94){.+.+.+}, at: [<ffffffff811e2b58>] sysfs_write_file+0xc8/0x160
    [  125.781339]  #2:  (pm_mutex){+.+.+.}, at: [<ffffffff81090a81>] pm_suspend+0x81/0x230
    [  125.781439]  #3:  (tasklist_lock){.?.?..}, at: [<ffffffff8108feed>] try_to_freeze_tasks+0x2cd/0x3f0
    [  125.781543]
    [  125.781543] stack backtrace:
    [  125.781584] Pid: 4211, comm: s2ram Not tainted 3.7.0-rc3+ #988
    [  125.781632] Call Trace:
    [  125.781662]  [<ffffffff810a3c73>] lockdep_rcu_suspicious+0x103/0x140
    [  125.781719]  [<ffffffff8107cf21>] sched_show_task+0x121/0x180
    [  125.781770]  [<ffffffff8108ffb4>] try_to_freeze_tasks+0x394/0x3f0
    [  125.781823]  [<ffffffff810903b5>] freeze_kernel_threads+0x25/0x80
    [  125.781876]  [<ffffffff81090b65>] pm_suspend+0x165/0x230
    [  125.781924]  [<ffffffff8108fa29>] state_store+0x99/0x100
    [  125.781975]  [<ffffffff812f5867>] kobj_attr_store+0x17/0x20
    [  125.782038]  [<ffffffff811e2b71>] sysfs_write_file+0xe1/0x160
    [  125.782091]  [<ffffffff811667a6>] vfs_write+0xc6/0x180
    [  125.782138]  [<ffffffff81166ada>] sys_write+0x5a/0xa0
    [  125.782185]  [<ffffffff812ff6ae>] ? trace_hardirqs_on_thunk+0x3a/0x3f
    [  125.782242]  [<ffffffff81669dd2>] system_call_fastpath+0x16/0x1b
    
    This commit therefore adds the needed RCU read-side critical section.
    
    Reported-by: "Rafael J. Wysocki" <rjw@sisk.pl>
    Signed-off-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>

commit 9e13db806e07ae9fdb1c2135fc60ea09fcbf3f3c
Author: Randy Dunlap <rdunlap@infradead.org>
Date:   Tue Oct 23 10:34:16 2012 -0700

    ALSA: ice1712: Fix build errors
    
    Fix build errors by using correct kconfig symbol name:
    
    sound/pci/ice1712/psc724.c:417:5: error: 'struct snd_ice1712' has no member named 'pm_resume'
    sound/pci/ice1712/psc724.c:418:5: error: 'struct snd_ice1712' has no member named 'pm_suspend_enabled'
    
    [Fixed another #ifdef CONFIG_PM in the same file, too, by tiwai]
    
    Signed-off-by: Randy Dunlap <rdunlap@xenotime.net>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

commit 05a65b235fb23759f3d0912f2967f6f2cd1a5c1d
Author: Feng Hong <hongfeng@marvell.com>
Date:   Wed Sep 19 14:16:00 2012 +0200

    PM / Sleep: use resume event when call dpm_resume_early
    
    commit 997a031107ec962967ce36db9bc500f1fad491c1 upstream.
    
    When dpm_suspend_noirq fail, state is PMSG_SUSPEND,
    should change to PMSG_RESUME when dpm_resume_early is called
    
    Signed-off-by: Feng Hong <hongfeng@marvell.com>
    Signed-off-by: Raul Xiong <xjian@marvell.com>
    Signed-off-by: Neil Zhang <zhangwm@marvell.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit fe3ea33e4ee9c88082e186c81690a62d99417573
Author: Feng Hong <hongfeng@marvell.com>
Date:   Wed Sep 19 14:16:00 2012 +0200

    PM / Sleep: use resume event when call dpm_resume_early
    
    commit 997a031107ec962967ce36db9bc500f1fad491c1 upstream.
    
    When dpm_suspend_noirq fail, state is PMSG_SUSPEND,
    should change to PMSG_RESUME when dpm_resume_early is called
    
    Signed-off-by: Feng Hong <hongfeng@marvell.com>
    Signed-off-by: Raul Xiong <xjian@marvell.com>
    Signed-off-by: Neil Zhang <zhangwm@marvell.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 24a0c2063c805e9cf1f3f418bb7f444b5b3f0e4e
Author: Feng Hong <hongfeng@marvell.com>
Date:   Wed Sep 19 14:16:00 2012 +0200

    PM / Sleep: use resume event when call dpm_resume_early
    
    commit 997a031107ec962967ce36db9bc500f1fad491c1 upstream.
    
    When dpm_suspend_noirq fail, state is PMSG_SUSPEND,
    should change to PMSG_RESUME when dpm_resume_early is called
    
    Signed-off-by: Feng Hong <hongfeng@marvell.com>
    Signed-off-by: Raul Xiong <xjian@marvell.com>
    Signed-off-by: Neil Zhang <zhangwm@marvell.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 387a8cbdf84d5c417d24eabfdf9fe4e0b94458da
Author: Chander Kashyap <chander.kashyap@linaro.org>
Date:   Fri Sep 14 09:08:50 2012 +0000

    mmc: sdhci-s3c: Fix crash on module insertion for second time
    
    If sdhci-s3c driver is built as module, it gives following error if inserted
    again after removing. This was happening as pm_runtime_use_autosuspend() is
    called in sdhci_s3c_probe() function but in sdhci_s3c_remove() its
    complementary pm_runtime_dont_use_autosuspend() is not called.
    
    BUG: spinlock bad magic on CPU#1, insmod/955
     lock: 0xee771368, .magic: 00000000, .owner: insmod/955, .owner_cpu: 1
    [<c00147e0>] (unwind_backtrace+0x0/0xf8) from [<c0136b40>] (do_raw_spin_unlock+0xa4/0xe4)
    [<c0136b40>] (do_raw_spin_unlock+0xa4/0xe4) from [<c01be508>] (_raw_spin_unlock_irqrestore+0xc/0x38)
    [<c01be508>] (_raw_spin_unlock_irqrestore+0xc/0x38) from [<c01a9334>] (sdhci_runtime_suspend_host+0x54/0x80)
    [<c01a9334>] (sdhci_runtime_suspend_host+0x54/0x80) from [<bf0060a8>] (sdhci_s3c_runtime_suspend+0x14/0x38 [sdhci_s3c])
    [<bf0060a8>] (sdhci_s3c_runtime_suspend+0x14/0x38 [sdhci_s3c]) from [<c016cb00>] (pm_generic_runtime_suspend+0x2c/0x40)
    [<c016cb00>] (pm_generic_runtime_suspend+0x2c/0x40) from [<c0170090>] (__rpm_callback+0x70/0x98)
    [<c0170090>] (__rpm_callback+0x70/0x98) from [<c01703f0>] (rpm_suspend+0xf0/0x534)
    [<c01703f0>] (rpm_suspend+0xf0/0x534) from [<c0171670>] (__pm_runtime_suspend+0x5c/0x74)
    [<c0171670>] (__pm_runtime_suspend+0x5c/0x74) from [<c016d018>] (pm_generic_runtime_idle+0x44/0x4c)
    [<c016d018>] (pm_generic_runtime_idle+0x44/0x4c) from [<c0170090>] (__rpm_callback+0x70/0x98)
    [<c0170090>] (__rpm_callback+0x70/0x98) from [<c0170984>] (rpm_idle+0xdc/0x18c)
    [<c0170984>] (rpm_idle+0xdc/0x18c) from [<c0171608>] (pm_runtime_set_autosuspend_delay+0x30/0x3c)
    [<c0171608>] (pm_runtime_set_autosuspend_delay+0x30/0x3c) from [<bf0069c4>] (sdhci_s3c_probe+0x35c/0x52c [sdhci_s3c])
    [<bf0069c4>] (sdhci_s3c_probe+0x35c/0x52c [sdhci_s3c]) from [<c016a014>] (platform_drv_probe+0x18/0x1c)
    
    Signed-off-by: Chander Kashyap <chander.kashyap@linaro.org>
    Acked-by: Jaehoon Chung <jh80.chung@samsung.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

commit 70581c172679ca0a29da01c6bb40577c804476da
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Aug 15 21:32:04 2012 +0200

    PM / Runtime: Check device PM QoS setting before "no callbacks" check
    
    commit 55d7ec4520e86d735d178c15d7df33d507bd43c6 upstream.
    
    If __dev_pm_qos_read_value(dev) returns a negative value,
    rpm_suspend() should return -EPERM for dev even if its
    power.no_callbacks flag is set.  For this to happen, the device's
    power.no_callbacks flag has to be checked after the PM QoS check,
    so move the PM QoS check to rpm_check_suspend_allowed() (this will
    make it cover idle notifications as well as runtime suspend too).
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 7bdf66e37d4350195de86c8e44540627550a00d9
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Aug 15 21:31:55 2012 +0200

    PM / Runtime: Clear power.deferred_resume on success in rpm_suspend()
    
    commit 58a34de7b1a920d287d17d2ca08bc9aaf7e6d35b upstream.
    
    The power.deferred_resume can only be set if the runtime PM status
    of device is RPM_SUSPENDING and it should be cleared after its
    status has been changed, regardless of whether or not the runtime
    suspend has been successful.  However, it only is cleared on
    suspend failure, while it may remain set on successful suspend and
    is happily leaked to rpm_resume() executed in that case.
    
    That shouldn't happen, so if power.deferred_resume is set in
    rpm_suspend() after the status has been changed to RPM_SUSPENDED,
    clear it before calling rpm_resume().  Then, it doesn't need to be
    cleared before changing the status to RPM_SUSPENDING any more,
    because it's always cleared after the status has been changed to
    either RPM_SUSPENDED (on success) or RPM_ACTIVE (on failure).
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 7f2e6defbe27240e9d51e4eee2f2568d31956b79
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Aug 15 21:31:55 2012 +0200

    PM / Runtime: Clear power.deferred_resume on success in rpm_suspend()
    
    commit 58a34de7b1a920d287d17d2ca08bc9aaf7e6d35b upstream.
    
    The power.deferred_resume can only be set if the runtime PM status
    of device is RPM_SUSPENDING and it should be cleared after its
    status has been changed, regardless of whether or not the runtime
    suspend has been successful.  However, it only is cleared on
    suspend failure, while it may remain set on successful suspend and
    is happily leaked to rpm_resume() executed in that case.
    
    That shouldn't happen, so if power.deferred_resume is set in
    rpm_suspend() after the status has been changed to RPM_SUSPENDED,
    clear it before calling rpm_resume().  Then, it doesn't need to be
    cleared before changing the status to RPM_SUSPENDING any more,
    because it's always cleared after the status has been changed to
    either RPM_SUSPENDED (on success) or RPM_ACTIVE (on failure).
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit d6163c4d59f7797c801e84ec537c6d7f99341717
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Aug 15 21:31:55 2012 +0200

    PM / Runtime: Clear power.deferred_resume on success in rpm_suspend()
    
    commit 58a34de7b1a920d287d17d2ca08bc9aaf7e6d35b upstream.
    
    The power.deferred_resume can only be set if the runtime PM status
    of device is RPM_SUSPENDING and it should be cleared after its
    status has been changed, regardless of whether or not the runtime
    suspend has been successful.  However, it only is cleared on
    suspend failure, while it may remain set on successful suspend and
    is happily leaked to rpm_resume() executed in that case.
    
    That shouldn't happen, so if power.deferred_resume is set in
    rpm_suspend() after the status has been changed to RPM_SUSPENDED,
    clear it before calling rpm_resume().  Then, it doesn't need to be
    cleared before changing the status to RPM_SUSPENDING any more,
    because it's always cleared after the status has been changed to
    either RPM_SUSPENDED (on success) or RPM_ACTIVE (on failure).
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 997a031107ec962967ce36db9bc500f1fad491c1
Author: Feng Hong <hongfeng@marvell.com>
Date:   Wed Sep 19 14:16:00 2012 +0200

    PM / Sleep: use resume event when call dpm_resume_early
    
    When dpm_suspend_noirq fail, state is PMSG_SUSPEND,
    should change to PMSG_RESUME when dpm_resume_early is called
    
    Signed-off-by: Feng Hong <hongfeng@marvell.com>
    Signed-off-by: Raul Xiong <xjian@marvell.com>
    Signed-off-by: Neil Zhang <zhangwm@marvell.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

commit 9379931f204703f9ccdf33b9273f3e755d86f8e6
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Aug 15 21:31:55 2012 +0200

    PM / Runtime: Clear power.deferred_resume on success in rpm_suspend()
    
    commit 58a34de7b1a920d287d17d2ca08bc9aaf7e6d35b upstream.
    
    The power.deferred_resume can only be set if the runtime PM status
    of device is RPM_SUSPENDING and it should be cleared after its
    status has been changed, regardless of whether or not the runtime
    suspend has been successful.  However, it only is cleared on
    suspend failure, while it may remain set on successful suspend and
    is happily leaked to rpm_resume() executed in that case.
    
    That shouldn't happen, so if power.deferred_resume is set in
    rpm_suspend() after the status has been changed to RPM_SUSPENDED,
    clear it before calling rpm_resume().  Then, it doesn't need to be
    cleared before changing the status to RPM_SUSPENDING any more,
    because it's always cleared after the status has been changed to
    either RPM_SUSPENDED (on success) or RPM_ACTIVE (on failure).
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit d9ec0fdc24743cb6aa9b7dee9064455cd26782f9
Merge: 20fb1936dee6 3735d524da64
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Aug 18 14:39:19 2012 -0700

    Merge tag 'pm-for-3.6-rc3' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull power management fixes from Rafael J. Wysocki:
      - Fixes for three obscure problems in the runtime PM core code found
       recently.
     - Two fixes for the new "coupled" cpuidle code from Colin Cross and Jon
       Medhurst.
     - intel_idle driver fix from Konrad Rzeszutek Wilk.
    
    * tag 'pm-for-3.6-rc3' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm:
      intel_idle: Check cpu_idle_get_driver() for NULL before dereferencing it.
      cpuidle: Prevent null pointer dereference in cpuidle_coupled_cpu_notify
      cpuidle: coupled: fix sleeping while atomic in cpu notifier
      PM / Runtime: Check device PM QoS setting before "no callbacks" check
      PM / Runtime: Clear power.deferred_resume on success in rpm_suspend()
      PM / Runtime: Fix rpm_resume() return value for power.no_callbacks set

commit 7db9f90917b40dde4c5ea003cf58cd9eddb557c1
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Wed Sep 21 20:55:04 2011 +0200

    PM / Suspend: Off by one in pm_suspend()
    
    commit 528f7ce6e439edeac38f6b3f8561f1be129b5e91 upstream.
    
    In enter_state() we use "state" as an offset for the pm_states[]
    array.  The pm_states[] array only has PM_SUSPEND_MAX elements so
    this test is off by one.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

commit 55d7ec4520e86d735d178c15d7df33d507bd43c6
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Aug 15 21:32:04 2012 +0200

    PM / Runtime: Check device PM QoS setting before "no callbacks" check
    
    If __dev_pm_qos_read_value(dev) returns a negative value,
    rpm_suspend() should return -EPERM for dev even if its
    power.no_callbacks flag is set.  For this to happen, the device's
    power.no_callbacks flag has to be checked after the PM QoS check,
    so move the PM QoS check to rpm_check_suspend_allowed() (this will
    make it cover idle notifications as well as runtime suspend too).
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Cc: stable@vger.kernel.org

commit 58a34de7b1a920d287d17d2ca08bc9aaf7e6d35b
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Aug 15 21:31:55 2012 +0200

    PM / Runtime: Clear power.deferred_resume on success in rpm_suspend()
    
    The power.deferred_resume can only be set if the runtime PM status
    of device is RPM_SUSPENDING and it should be cleared after its
    status has been changed, regardless of whether or not the runtime
    suspend has been successful.  However, it only is cleared on
    suspend failure, while it may remain set on successful suspend and
    is happily leaked to rpm_resume() executed in that case.
    
    That shouldn't happen, so if power.deferred_resume is set in
    rpm_suspend() after the status has been changed to RPM_SUSPENDED,
    clear it before calling rpm_resume().  Then, it doesn't need to be
    cleared before changing the status to RPM_SUSPENDING any more,
    because it's always cleared after the status has been changed to
    either RPM_SUSPENDED (on success) or RPM_ACTIVE (on failure).
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Cc: stable@vger.kernel.org

commit f95f7ae189b51123becde905e934954c86c8a0e2
Author: Colin Cross <ccross@android.com>
Date:   Fri Jul 20 02:03:42 2012 +0100

    ARM: 7477/1: vfp: Always save VFP state in vfp_pm_suspend on UP
    
    commit 24b35521b8ddf088531258f06f681bb7b227bf47 upstream.
    
    vfp_pm_suspend should save the VFP state in suspend after
    any lazy context switch.  If it only saves when the VFP is enabled,
    the state can get lost when, on a UP system:
      Thread 1 uses the VFP
      Context switch occurs to thread 2, VFP is disabled but the
         VFP context is not saved
      Thread 2 initiates suspend
      vfp_pm_suspend is called with the VFP disabled, and the unsaved
         VFP context of Thread 1 in the registers
    
    Modify vfp_pm_suspend to save the VFP context whenever
    vfp_current_hw_state is not NULL.
    
    Includes a fix from Ido Yariv <ido@wizery.com>, who pointed out that on
    SMP systems, the state pointer can be pointing to a freed task struct if
    a task exited on another cpu, fixed by using #ifndef CONFIG_SMP in the
    new if clause.
    
    Signed-off-by: Colin Cross <ccross@android.com>
    Cc: Barry Song <bs14@csr.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Ido Yariv <ido@wizery.com>
    Cc: Daniel Drake <dsd@laptop.org>
    Cc: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit ea2ebaa71c978254c2a93bf561236aec8a167166
Author: Colin Cross <ccross@android.com>
Date:   Fri Jul 20 02:03:43 2012 +0100

    ARM: 7476/1: vfp: only clear vfp state for current cpu in vfp_pm_suspend
    
    commit a84b895a2348f0dbff31b71ddf954f70a6cde368 upstream.
    
    vfp_pm_suspend runs on each cpu, only clear the hardware state
    pointer for the current cpu.  Prevents a possible crash if one
    cpu clears the hw state pointer when another cpu has already
    checked if it is valid.
    
    Signed-off-by: Colin Cross <ccross@android.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 2a105235094eeae46dc0d2386600f4a481a05d84
Author: Colin Cross <ccross@android.com>
Date:   Fri Jul 20 02:03:42 2012 +0100

    ARM: 7477/1: vfp: Always save VFP state in vfp_pm_suspend on UP
    
    commit 24b35521b8ddf088531258f06f681bb7b227bf47 upstream.
    
    vfp_pm_suspend should save the VFP state in suspend after
    any lazy context switch.  If it only saves when the VFP is enabled,
    the state can get lost when, on a UP system:
      Thread 1 uses the VFP
      Context switch occurs to thread 2, VFP is disabled but the
         VFP context is not saved
      Thread 2 initiates suspend
      vfp_pm_suspend is called with the VFP disabled, and the unsaved
         VFP context of Thread 1 in the registers
    
    Modify vfp_pm_suspend to save the VFP context whenever
    vfp_current_hw_state is not NULL.
    
    Includes a fix from Ido Yariv <ido@wizery.com>, who pointed out that on
    SMP systems, the state pointer can be pointing to a freed task struct if
    a task exited on another cpu, fixed by using #ifndef CONFIG_SMP in the
    new if clause.
    
    Signed-off-by: Colin Cross <ccross@android.com>
    Cc: Barry Song <bs14@csr.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Ido Yariv <ido@wizery.com>
    Cc: Daniel Drake <dsd@laptop.org>
    Cc: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit fae218a1ff5ebe36893dcc89935df3a9c2681022
Author: Colin Cross <ccross@android.com>
Date:   Fri Jul 20 02:03:43 2012 +0100

    ARM: 7476/1: vfp: only clear vfp state for current cpu in vfp_pm_suspend
    
    commit a84b895a2348f0dbff31b71ddf954f70a6cde368 upstream.
    
    vfp_pm_suspend runs on each cpu, only clear the hardware state
    pointer for the current cpu.  Prevents a possible crash if one
    cpu clears the hw state pointer when another cpu has already
    checked if it is valid.
    
    Signed-off-by: Colin Cross <ccross@android.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit cdab6eed39be615703f582831765e14fb0452842
Author: Colin Cross <ccross@android.com>
Date:   Fri Jul 20 02:03:42 2012 +0100

    ARM: 7477/1: vfp: Always save VFP state in vfp_pm_suspend on UP
    
    commit 24b35521b8ddf088531258f06f681bb7b227bf47 upstream.
    
    vfp_pm_suspend should save the VFP state in suspend after
    any lazy context switch.  If it only saves when the VFP is enabled,
    the state can get lost when, on a UP system:
      Thread 1 uses the VFP
      Context switch occurs to thread 2, VFP is disabled but the
         VFP context is not saved
      Thread 2 initiates suspend
      vfp_pm_suspend is called with the VFP disabled, and the unsaved
         VFP context of Thread 1 in the registers
    
    Modify vfp_pm_suspend to save the VFP context whenever
    vfp_current_hw_state is not NULL.
    
    Includes a fix from Ido Yariv <ido@wizery.com>, who pointed out that on
    SMP systems, the state pointer can be pointing to a freed task struct if
    a task exited on another cpu, fixed by using #ifndef CONFIG_SMP in the
    new if clause.
    
    Cc: Barry Song <bs14@csr.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Ido Yariv <ido@wizery.com>
    Cc: Daniel Drake <dsd@laptop.org>
    Cc: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Colin Cross <ccross@android.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit fc257bc543a3b08545e2332574a12893f0e54c85
Author: Colin Cross <ccross@android.com>
Date:   Fri Jul 20 02:03:43 2012 +0100

    ARM: 7476/1: vfp: only clear vfp state for current cpu in vfp_pm_suspend
    
    commit a84b895a2348f0dbff31b71ddf954f70a6cde368 upstream.
    
    vfp_pm_suspend runs on each cpu, only clear the hardware state
    pointer for the current cpu.  Prevents a possible crash if one
    cpu clears the hw state pointer when another cpu has already
    checked if it is valid.
    
    Signed-off-by: Colin Cross <ccross@android.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit 46dbb0f5903b71e3c7b37e4ad707a9aa70fe3eed
Author: Colin Cross <ccross@android.com>
Date:   Thu Jul 19 10:38:06 2012 +0200

    PM / Sleep: call early resume handlers when suspend_noirq fails
    
    commit 064b021fbe470ecc9ca10f9f87af48c0fc0865fb upstream.
    
    Commit cf579dfb82550e34de7ccf3ef090d8b834ccd3a9 (PM / Sleep: Introduce
    "late suspend" and "early resume" of devices) introduced a bug where
    suspend_late handlers would be called, but if dpm_suspend_noirq returned
    an error the early_resume handlers would never be called.  All devices
    would end up on the dpm_late_early_list, and would never be resumed
    again.
    
    Fix it by calling dpm_resume_early when dpm_suspend_noirq returns
    an error.
    
    Signed-off-by: Colin Cross <ccross@android.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 87f2dfbf9bfd65659c2ac4ae68ad19d6ed569b6d
Author: Colin Cross <ccross@android.com>
Date:   Thu Jul 19 10:38:06 2012 +0200

    PM / Sleep: call early resume handlers when suspend_noirq fails
    
    commit 064b021fbe470ecc9ca10f9f87af48c0fc0865fb upstream.
    
    Commit cf579dfb82550e34de7ccf3ef090d8b834ccd3a9 (PM / Sleep: Introduce
    "late suspend" and "early resume" of devices) introduced a bug where
    suspend_late handlers would be called, but if dpm_suspend_noirq returned
    an error the early_resume handlers would never be called.  All devices
    would end up on the dpm_late_early_list, and would never be resumed
    again.
    
    Fix it by calling dpm_resume_early when dpm_suspend_noirq returns
    an error.
    
    Signed-off-by: Colin Cross <ccross@android.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 9a2533c3eb91b3e769c2612c5d68e811bfc0ecf6
Merge: d4fdc32517ef b74253f78400
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Aug 1 16:30:45 2012 -0700

    Merge branch 'fixes' of git://git.linaro.org/people/rmk/linux-arm
    
    Pull ARM fixes from Russell King:
     "This fixes various issues found during July"
    
    * 'fixes' of git://git.linaro.org/people/rmk/linux-arm:
      ARM: 7479/1: mm: avoid NULL dereference when flushing gate_vma with VIVT caches
      ARM: Fix undefined instruction exception handling
      ARM: 7480/1: only call smp_send_stop() on SMP
      ARM: 7478/1: errata: extend workaround for erratum #720789
      ARM: 7477/1: vfp: Always save VFP state in vfp_pm_suspend on UP
      ARM: 7476/1: vfp: only clear vfp state for current cpu in vfp_pm_suspend
      ARM: 7468/1: ftrace: Trace function entry before updating index
      ARM: 7467/1: mutex: use generic xchg-based implementation for ARMv6+
      ARM: 7466/1: disable interrupt before spinning endlessly
      ARM: 7465/1: Handle >4GB memory sizes in device tree and mem=size@start option

commit 24b35521b8ddf088531258f06f681bb7b227bf47
Author: Colin Cross <ccross@android.com>
Date:   Fri Jul 20 02:03:42 2012 +0100

    ARM: 7477/1: vfp: Always save VFP state in vfp_pm_suspend on UP
    
    vfp_pm_suspend should save the VFP state in suspend after
    any lazy context switch.  If it only saves when the VFP is enabled,
    the state can get lost when, on a UP system:
      Thread 1 uses the VFP
      Context switch occurs to thread 2, VFP is disabled but the
         VFP context is not saved
      Thread 2 initiates suspend
      vfp_pm_suspend is called with the VFP disabled, and the unsaved
         VFP context of Thread 1 in the registers
    
    Modify vfp_pm_suspend to save the VFP context whenever
    vfp_current_hw_state is not NULL.
    
    Includes a fix from Ido Yariv <ido@wizery.com>, who pointed out that on
    SMP systems, the state pointer can be pointing to a freed task struct if
    a task exited on another cpu, fixed by using #ifndef CONFIG_SMP in the
    new if clause.
    
    Cc: Barry Song <bs14@csr.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Ido Yariv <ido@wizery.com>
    Cc: Daniel Drake <dsd@laptop.org>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Colin Cross <ccross@android.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

commit a84b895a2348f0dbff31b71ddf954f70a6cde368
Author: Colin Cross <ccross@android.com>
Date:   Fri Jul 20 02:03:43 2012 +0100

    ARM: 7476/1: vfp: only clear vfp state for current cpu in vfp_pm_suspend
    
    vfp_pm_suspend runs on each cpu, only clear the hardware state
    pointer for the current cpu.  Prevents a possible crash if one
    cpu clears the hw state pointer when another cpu has already
    checked if it is valid.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Colin Cross <ccross@android.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

commit 064b021fbe470ecc9ca10f9f87af48c0fc0865fb
Author: Colin Cross <ccross@android.com>
Date:   Thu Jul 19 10:38:06 2012 +0200

    PM / Sleep: call early resume handlers when suspend_noirq fails
    
    Commit cf579dfb82550e34de7ccf3ef090d8b834ccd3a9 (PM / Sleep: Introduce
    "late suspend" and "early resume" of devices) introduced a bug where
    suspend_late handlers would be called, but if dpm_suspend_noirq returned
    an error the early_resume handlers would never be called.  All devices
    would end up on the dpm_late_early_list, and would never be resumed
    again.
    
    Fix it by calling dpm_resume_early when dpm_suspend_noirq returns
    an error.
    
    Signed-off-by: Colin Cross <ccross@android.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

commit bfaa07bc322085582bdc40babb9d0cce17b57380
Merge: 6148d38b37ce b45bae36b805
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Jul 19 00:03:42 2012 +0200

    Merge branch 'pm-drivers'
    
    * pm-drivers:
      rtc-cmos: report wakeups from interrupt handler
      PM / crypto / ux500: Use struct dev_pm_ops for power management
      PM / IPMI: Remove empty legacy PCI PM callbacks
      tpm_nsc: Use struct dev_pm_ops for power management
      tpm_tis: Use struct dev_pm_ops for power management
      tpm_atmel: Use struct dev_pm_ops for power management
      PM / TPM: Drop unused pm_message_t argument from tpm_pm_suspend()
      omap-rng: Use struct dev_pm_ops for power management
      mg_disk: Use struct dev_pm_ops for power management
      msi-laptop: Use struct dev_pm_ops for power management
      hdaps: Use struct dev_pm_ops for power management
      sonypi: Use struct dev_pm_ops for power management
      intel_mid_thermal: Use struct dev_pm_ops for power management
      acer-wmi: Use struct dev_pm_ops for power management
      intel_ips: Remove empty legacy PM callbacks
      thinkpad_acpi: Use struct dev_pm_ops instead of legacy PM routines
      thinkpad_acpi: Drop pm_message_t arguments from suspend routines

commit 7664e969359917ba3212c5d6efdec494eaf8586e
Author: Sachin Kamat <sachin.kamat@linaro.org>
Date:   Tue Jul 17 22:38:08 2012 +0200

    PM / Sleep: Add missing static storage class specifiers in main.c
    
    Fix the following sparse warnings:
    drivers/base/power/main.c:48:1: warning: symbol 'dpm_prepared_list' was not declared. Should it be static?
    drivers/base/power/main.c:49:1: warning: symbol 'dpm_suspended_list' was not declared. Should it be static?
    drivers/base/power/main.c:50:1: warning: symbol 'dpm_late_early_list' was not declared. Should it be static?
    drivers/base/power/main.c:51:1: warning: symbol 'dpm_noirq_list' was not declared. Should it be static?
    
    Signed-off-by: Sachin Kamat <sachin.kamat@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

commit ca9a2054fe041326888811a94f17459acab9f950
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Fri Jul 6 19:09:28 2012 +0200

    tpm_nsc: Use struct dev_pm_ops for power management
    
    Make the tpm_nsc driver define its PM callbacks through
    a struct dev_pm_ops object rather than by using legacy PM hooks
    in struct platform_driver.
    
    This allows the driver to use tpm_pm_suspend() and tpm_pm_resume()
    as its PM callbacks directly, without defining its own PM callback
    routines.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

commit b633f0507e19224f1527921644722bfb36db9bb0
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Fri Jul 6 19:09:20 2012 +0200

    tpm_tis: Use struct dev_pm_ops for power management
    
    Make the tpm_tis driver define its PM callbacks through
    a struct dev_pm_ops object rather than by using legacy PM hooks
    in struct platform_driver.
    
    This allows the driver to use tpm_pm_suspend() as its suspend
    callback directly, without defining its own suspend callback
    routine.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

commit 8324be05380be044df8b70cb4bfb0c0b50eec3e5
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Fri Jul 6 19:09:13 2012 +0200

    tpm_atmel: Use struct dev_pm_ops for power management
    
    Make the tpm_atmel driver define its PM callbacks through
    a struct dev_pm_ops object rather than by using legacy PM hooks
    in struct platform_driver.
    
    This allows the driver to use tpm_pm_suspend() and tpm_pm_resume()
    as its PM callbacks directly, without defining its own PM callback
    routines.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

commit 035e2ce8eb7412dbcb8522c19676a1dd52f3c024
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Fri Jul 6 19:09:01 2012 +0200

    PM / TPM: Drop unused pm_message_t argument from tpm_pm_suspend()
    
    The tpm_pm_suspend()'s second argument of type pm_message_t is not
    used, so remove it.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

commit 8651f97bd951d0bb1c10fa24e3fa3455193f3548
Author: Preeti U Murthy <preeti@linux.vnet.ibm.com>
Date:   Mon Jul 9 10:12:56 2012 +0200

    PM / cpuidle: System resume hang fix with cpuidle
    
    On certain bios, resume hangs if cpus are allowed to enter idle states
    during suspend [1].
    
    This was fixed in apci idle driver [2].But intel_idle driver does not
    have this fix. Thus instead of replicating the fix in both the idle
    drivers, or in more platform specific idle drivers if needed, the
    more general cpuidle infrastructure could handle this.
    
    A suspend callback in cpuidle_driver could handle this fix. But
    a cpuidle_driver provides only basic functionalities like platform idle
    state detection capability and mechanisms to support entry and exit
    into CPU idle states. All other cpuidle functions are found in the
    cpuidle generic infrastructure for good reason that all cpuidle
    drivers, irrepective of their platforms will support these functions.
    
    One option therefore would be to register a suspend callback in cpuidle
    which handles this fix. This could be called through a PM_SUSPEND_PREPARE
    notifier. But this is too generic a notfier for a driver to handle.
    
    Also, ideally the job of cpuidle is not to handle side effects of suspend.
    It should expose the interfaces which "handle cpuidle 'during' suspend"
    or any other operation, which the subsystems call during that respective
    operation.
    
    The fix demands that during suspend, no cpus should be allowed to enter
    deep C-states. The interface cpuidle_uninstall_idle_handler() in cpuidle
    ensures that. Not just that it also kicks all the cpus which are already
    in idle out of their idle states which was being done during cpu hotplug
    through a CPU_DYING_FROZEN callbacks.
    
    Now the question arises about when during suspend should
    cpuidle_uninstall_idle_handler() be called. Since we are dealing with
    drivers it seems best to call this function during dpm_suspend().
    Delaying the call till dpm_suspend_noirq() does no harm, as long as it is
    before cpu_hotplug_begin() to avoid race conditions with cpu hotpulg
    operations. In dpm_suspend_noirq(), it would be wise to place this call
    before suspend_device_irqs() to avoid ugly interactions with the same.
    
    Ananlogously, during resume.
    
    References:
    [1] https://bugs.launchpad.net/ubuntu/+source/linux/+bug/674075.
    [2] http://marc.info/?l=linux-pm&m=133958534231884&w=2
    
    Reported-and-tested-by: Dave Hansen <dave@linux.vnet.ibm.com>
    Signed-off-by: Preeti U Murthy <preeti@linux.vnet.ibm.com>
    Reviewed-by: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

commit 316efab3e949e4fbdacb0975bf33adbad89115db
Author: Sylwester Nawrocki <s.nawrocki@samsung.com>
Date:   Fri May 18 13:31:28 2012 -0300

    [media] s5p-fimc: Fix fimc-lite system wide suspend procedure
    
    Only suspend the video pipeline devices if they were active before
    the pm.suspend() helper is called. This patch prevents following error:
    
    /# echo mem > /sys/power/state
    [   34.965000] PM: Syncing filesystems ... done.
    [   35.035000] Freezing user space processes ... (elapsed 0.01 seconds) done.
    ...
    [   35.105000] dpm_run_callback(): platform_pm_suspend+0x0/0x5c returns -22
    [   35.105000] PM: Device exynos-fimc-lite.1 failed to suspend: error -22
    [   35.105000] PM: Some devices failed to suspend
    
    Signed-off-by: Sylwester Nawrocki <s.nawrocki@samsung.com>
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

commit dc457078d4da76e3951e55e00d3801bf8217c683
Author: Nicolas Pitre <nicolas.pitre@linaro.org>
Date:   Wed May 9 22:32:43 2012 +0100

    ARM: 7415/1: vfp: convert printk's to pr_*'s
    
    This is mainly to get rid of the "vfp_pm_suspend: saving vfp state"
    message flooding the kernel message ring by default.
    
    Signed-off-by: Nicolas Pitre <nico@linaro.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

commit f77621cc640a7c50b3d8c5254ecc5d91eaa99d0d
Author: Poddar, Sourav <sourav.poddar@ti.com>
Date:   Thu May 10 22:32:00 2012 -0700

    Input: omap-keypad - dynamically handle register offsets
    
    Hi Dmitry,
    
    On Wed, May 9, 2012 at 3:14 PM, Poddar, Sourav <sourav.poddar@ti.com> wrote:
    > Hi Dmitry,
    >
    > I did some minor fixes to the patch which you suggested above and
    > the keypad is functional now.
    >
    > Changes:
    > - Move "pm_runtime_enable" before using "pm_runtime_get_sync".
    >
    > Sending the patch inlined..(also attached).
    >
    > From: G, Manjunath Kondaiah <manjugk@ti.com>
    > Date: Mon, 10 Oct 2011 20:52:05 +0530
    > Subject: [PATCH] Input: omap-keypad: dynamically handle register offsets
    >
    > Keypad controller register offsets are different for omap4
    > and omap5. Handle these offsets through static mapping and
    > assign these mappings during run time.
    >
    > Tested on omap4430 sdp with 3.4-rc3.
    > Tested on omap5430evm with 3.1-custom kernel.
    >
    > Cc: Andrew Morton <akpm@linux-foundation.org>
    > Signed-off-by: Felipe Balbi <balbi@ti.com>
    > Signed-off-by: G, Manjunath Kondaiah <manjugk@ti.com>
    > Signed-off-by: Sourav Poddar <sourav.poddar@ti.com>
    > Signed-off-by: Dmitry Torokhov <dtor@mail.ru>
    > ---
    >  drivers/input/keyboard/Kconfig        |    4 +-
    >  drivers/input/keyboard/omap4-keypad.c |  120 +++++++++++++++++++++++++-------
    >  2 files changed, 95 insertions(+), 29 deletions(-)
    >
    > diff --git a/drivers/input/keyboard/Kconfig b/drivers/input/keyboard/Kconfig
    > index f354813..33bbdee 100644
    > --- a/drivers/input/keyboard/Kconfig
    > +++ b/drivers/input/keyboard/Kconfig
    > @@ -512,9 +512,9 @@ config KEYBOARD_OMAP
    >          module will be called omap-keypad.
    >
    >  config KEYBOARD_OMAP4
    > -       tristate "TI OMAP4 keypad support"
    > +       tristate "TI OMAP4+ keypad support"
    >        help
    > -         Say Y here if you want to use the OMAP4 keypad.
    > +         Say Y here if you want to use the OMAP4+ keypad.
    >
    >          To compile this driver as a module, choose M here: the
    >          module will be called omap4-keypad.
    > diff --git a/drivers/input/keyboard/omap4-keypad.c
    > b/drivers/input/keyboard/omap4-keypad.c
    > index e809ac0..d7102e8 100644
    > --- a/drivers/input/keyboard/omap4-keypad.c
    > +++ b/drivers/input/keyboard/omap4-keypad.c
    > @@ -68,19 +68,52 @@
    >
    >  #define OMAP4_MASK_IRQSTATUSDISABLE    0xFFFF
    >
    > +enum {
    > +       KBD_REVISION_OMAP4 = 0,
    > +       KBD_REVISION_OMAP5,
    > +};
    > +
    >  struct omap4_keypad {
    >        struct input_dev *input;
    >
    >        void __iomem *base;
    > -       int irq;
    > +       unsigned int irq;
    >
    >        unsigned int rows;
    >        unsigned int cols;
    > +       u32 reg_offset;
    > +       u32 irqreg_offset;
    >        unsigned int row_shift;
    >        unsigned char key_state[8];
    >        unsigned short keymap[];
    >  };
    >
    > +static int kbd_readl(struct omap4_keypad *keypad_data, u32 offset)
    > +{
    > +       return __raw_readl(keypad_data->base +
    > +                               keypad_data->reg_offset + offset);
    > +}
    > +
    > +static void kbd_writel(struct omap4_keypad *keypad_data, u32 offset, u32 value)
    > +{
    > +       __raw_writel(value,
    > +                    keypad_data->base + keypad_data->reg_offset + offset);
    > +}
    > +
    > +static int kbd_read_irqreg(struct omap4_keypad *keypad_data, u32 offset)
    > +{
    > +       return __raw_readl(keypad_data->base +
    > +                               keypad_data->irqreg_offset + offset);
    > +}
    > +
    > +static void kbd_write_irqreg(struct omap4_keypad *keypad_data,
    > +                            u32 offset, u32 value)
    > +{
    > +       __raw_writel(value,
    > +                    keypad_data->base + keypad_data->irqreg_offset + offset);
    > +}
    > +
    > +
    >  /* Interrupt handler */
    >  static irqreturn_t omap4_keypad_interrupt(int irq, void *dev_id)
    >  {
    > @@ -91,12 +124,11 @@ static irqreturn_t omap4_keypad_interrupt(int
    > irq, void *dev_id)
    >        u32 *new_state = (u32 *) key_state;
    >
    >        /* Disable interrupts */
    > -       __raw_writel(OMAP4_VAL_IRQDISABLE,
    > -                    keypad_data->base + OMAP4_KBD_IRQENABLE);
    > +       kbd_write_irqreg(keypad_data, OMAP4_KBD_IRQENABLE,
    > +                        OMAP4_VAL_IRQDISABLE);
    >
    > -       *new_state = __raw_readl(keypad_data->base + OMAP4_KBD_FULLCODE31_0);
    > -       *(new_state + 1) = __raw_readl(keypad_data->base
    > -                                               + OMAP4_KBD_FULLCODE63_32);
    > +       *new_state = kbd_readl(keypad_data, OMAP4_KBD_FULLCODE31_0);
    > +       *(new_state + 1) = kbd_readl(keypad_data, OMAP4_KBD_FULLCODE63_32);
    >
    >        for (row = 0; row < keypad_data->rows; row++) {
    >                changed = key_state[row] ^ keypad_data->key_state[row];
    > @@ -121,12 +153,13 @@ static irqreturn_t omap4_keypad_interrupt(int
    > irq, void *dev_id)
    >                sizeof(keypad_data->key_state));
    >
    >        /* clear pending interrupts */
    > -       __raw_writel(__raw_readl(keypad_data->base + OMAP4_KBD_IRQSTATUS),
    > -                       keypad_data->base + OMAP4_KBD_IRQSTATUS);
    > +       kbd_write_irqreg(keypad_data, OMAP4_KBD_IRQSTATUS,
    > +                        kbd_read_irqreg(keypad_data, OMAP4_KBD_IRQSTATUS));
    >
    >        /* enable interrupts */
    > -       __raw_writel(OMAP4_DEF_IRQENABLE_EVENTEN | OMAP4_DEF_IRQENABLE_LONGKEY,
    > -                       keypad_data->base + OMAP4_KBD_IRQENABLE);
    > +       kbd_write_irqreg(keypad_data, OMAP4_KBD_IRQENABLE,
    > +               OMAP4_DEF_IRQENABLE_EVENTEN |
    > +                               OMAP4_DEF_IRQENABLE_LONGKEY);
    >
    >        return IRQ_HANDLED;
    >  }
    > @@ -139,16 +172,17 @@ static int omap4_keypad_open(struct input_dev *input)
    >
    >        disable_irq(keypad_data->irq);
    >
    > -       __raw_writel(OMAP4_VAL_FUNCTIONALCFG,
    > -                       keypad_data->base + OMAP4_KBD_CTRL);
    > -       __raw_writel(OMAP4_VAL_DEBOUNCINGTIME,
    > -                       keypad_data->base + OMAP4_KBD_DEBOUNCINGTIME);
    > -       __raw_writel(OMAP4_VAL_IRQDISABLE,
    > -                       keypad_data->base + OMAP4_KBD_IRQSTATUS);
    > -       __raw_writel(OMAP4_DEF_IRQENABLE_EVENTEN | OMAP4_DEF_IRQENABLE_LONGKEY,
    > -                       keypad_data->base + OMAP4_KBD_IRQENABLE);
    > -       __raw_writel(OMAP4_DEF_WUP_EVENT_ENA | OMAP4_DEF_WUP_LONG_KEY_ENA,
    > -                       keypad_data->base + OMAP4_KBD_WAKEUPENABLE);
    > +       kbd_writel(keypad_data, OMAP4_KBD_CTRL,
    > +                       OMAP4_VAL_FUNCTIONALCFG);
    > +       kbd_writel(keypad_data, OMAP4_KBD_DEBOUNCINGTIME,
    > +                       OMAP4_VAL_DEBOUNCINGTIME);
    > +       kbd_write_irqreg(keypad_data, OMAP4_KBD_IRQSTATUS,
    > +                       OMAP4_VAL_IRQDISABLE);
    > +       kbd_write_irqreg(keypad_data, OMAP4_KBD_IRQENABLE,
    > +                       OMAP4_DEF_IRQENABLE_EVENTEN |
    > +                               OMAP4_DEF_IRQENABLE_LONGKEY);
    > +       kbd_writel(keypad_data, OMAP4_KBD_WAKEUPENABLE,
    > +                       OMAP4_DEF_WUP_EVENT_ENA | OMAP4_DEF_WUP_LONG_KEY_ENA);
    >
    >        enable_irq(keypad_data->irq);
    >
    > @@ -162,12 +196,12 @@ static void omap4_keypad_close(struct input_dev *input)
    >        disable_irq(keypad_data->irq);
    >
    >        /* Disable interrupts */
    > -       __raw_writel(OMAP4_VAL_IRQDISABLE,
    > -                    keypad_data->base + OMAP4_KBD_IRQENABLE);
    > +       kbd_write_irqreg(keypad_data, OMAP4_KBD_IRQENABLE,
    > +                        OMAP4_VAL_IRQDISABLE);
    >
    >        /* clear pending interrupts */
    > -       __raw_writel(__raw_readl(keypad_data->base + OMAP4_KBD_IRQSTATUS),
    > -                       keypad_data->base + OMAP4_KBD_IRQSTATUS);
    > +       kbd_write_irqreg(keypad_data, OMAP4_KBD_IRQSTATUS,
    > +                        kbd_read_irqreg(keypad_data, OMAP4_KBD_IRQSTATUS));
    >
    >        enable_irq(keypad_data->irq);
    >
    > @@ -182,6 +216,7 @@ static int __devinit omap4_keypad_probe(struct
    > platform_device *pdev)
    >        struct resource *res;
    >        resource_size_t size;
    >        unsigned int row_shift, max_keys;
    > +       int rev;
    >        int irq;
    >        int error;
    >
    > @@ -241,11 +276,40 @@ static int __devinit omap4_keypad_probe(struct
    > platform_device *pdev)
    >        keypad_data->rows = pdata->rows;
    >        keypad_data->cols = pdata->cols;
    >
    > +       /*
    > +       * Enable clocks for the keypad module so that we can read
    > +       * revision register.
    > +       */
    > +       pm_runtime_enable(&pdev->dev);
    > +       error = pm_runtime_get_sync(&pdev->dev);
    > +       if (error) {
    > +               dev_err(&pdev->dev, "pm_runtime_get_sync() failed\n");
    > +               goto err_unmap;
    > +       }
    > +       rev = __raw_readl(keypad_data->base + OMAP4_KBD_REVISION);
    > +       rev &= 0x03 << 30;
    > +       rev >>= 30;
    > +       switch (rev) {
    > +       case KBD_REVISION_OMAP4:
    > +               keypad_data->reg_offset = 0x00;
    > +               keypad_data->irqreg_offset = 0x00;
    > +               break;
    > +       case KBD_REVISION_OMAP5:
    > +               keypad_data->reg_offset = 0x10;
    > +               keypad_data->irqreg_offset = 0x0c;
    > +               break;
    > +       default:
    > +               dev_err(&pdev->dev,
    > +                       "Keypad reports unsupported revision %d", rev);
    > +               error = -EINVAL;
    > +               goto err_pm_put_sync;
    > +       }
    > +
    >        /* input device allocation */
    >        keypad_data->input = input_dev = input_allocate_device();
    >        if (!input_dev) {
    >                error = -ENOMEM;
    > -               goto err_unmap;
    > +               goto err_pm_put_sync;
    >        }
    >
    >        input_dev->name = pdev->name;
    > @@ -273,14 +337,14 @@ static int __devinit omap4_keypad_probe(struct
    > platform_device *pdev)
    >                        input_dev->keycode, input_dev->keybit);
    >
    >        error = request_irq(keypad_data->irq, omap4_keypad_interrupt,
    > -                            IRQF_TRIGGER_RISING,
    > +                           IRQF_DISABLED | IRQF_TRIGGER_RISING,
    Sorry, " IRQF_DISABLED" got included by mistake.
    Removing this stray change and sending it again.
    
    >                             "omap4-keypad", keypad_data);
    >        if (error) {
    >                dev_err(&pdev->dev, "failed to register interrupt\n");
    >                goto err_free_input;
    >        }
    >
    > -       pm_runtime_enable(&pdev->dev);
    > +       pm_runtime_put_sync(&pdev->dev);
    >
    >        error = input_register_device(keypad_data->input);
    >        if (error < 0) {
    > @@ -296,6 +360,8 @@ err_pm_disable:
    >        free_irq(keypad_data->irq, keypad_data);
    >  err_free_input:
    >        input_free_device(input_dev);
    > +err_pm_put_sync:
    > +       pm_runtime_put_sync(&pdev->dev);
    >  err_unmap:
    >        iounmap(keypad_data->base);
    >  err_release_mem:
    >
    >
    > ~Sourav
    >
    > On Wed, May 9, 2012 at 1:15 PM, Dmitry Torokhov
    > <dmitry.torokhov@gmail.com> wrote:
    >>> Hi Dmitry ,
    >>>
    >>>
    >>> On Wed, May 9, 2012 at 10:48 AM, Dmitry Torokhov
    >>> <dmitry.torokhov@gmail.com> wrote:
    >>> > Ho Sourav,
    >>> >
    >>> > On Thu, Apr 26, 2012 at 11:24:37AM +0530, Sourav Poddar wrote:
    >>> >>
    >>> >> -config KEYBOARD_OMAP4
    >>> >> -     tristate "TI OMAP4 keypad support"
    >>> >> +config KEYBOARD_OMAP4+
    >>> >
    >>> > I think this works purely by accident - '+' sign getting dropped by
    >>> > parser...
    >>> >
    >>> >> @@ -139,16 +192,33 @@ static int omap4_keypad_open(struct input_dev *input)
    >>> >>
    >>> >>       disable_irq(keypad_data->irq);
    >>> >>
    >>> >> -     __raw_writel(OMAP4_VAL_FUNCTIONALCFG,
    >>> >> -                     keypad_data->base + OMAP4_KBD_CTRL);
    >>> >> -     __raw_writel(OMAP4_VAL_DEBOUNCINGTIME,
    >>> >> -                     keypad_data->base + OMAP4_KBD_DEBOUNCINGTIME);
    >>> >> -     __raw_writel(OMAP4_VAL_IRQDISABLE,
    >>> >> -                     keypad_data->base + OMAP4_KBD_IRQSTATUS);
    >>> >> -     __raw_writel(OMAP4_DEF_IRQENABLE_EVENTEN | OMAP4_DEF_IRQENABLE_LONGKEY,
    >>> >> -                     keypad_data->base + OMAP4_KBD_IRQENABLE);
    >>> >> -     __raw_writel(OMAP4_DEF_WUP_EVENT_ENA | OMAP4_DEF_WUP_LONG_KEY_ENA,
    >>> >> -                     keypad_data->base + OMAP4_KBD_WAKEUPENABLE);
    >>> >> +     keypad_data->revision = kbd_read_revision(keypad_data,
    >>> >> +                     OMAP4_KBD_REVISION);
    >>> >> +     switch (keypad_data->revision) {
    >>> >> +     case 1:
    >>> >> +             keypad_data->irqstatus = OMAP4_KBD_IRQSTATUS + 0x0c;
    >>> >> +             keypad_data->irqenable = OMAP4_KBD_IRQENABLE + 0x0c;
    >>> >> +             keypad_data->reg_offset = 0x10;
    >>> >> +             break;
    >>> >
    >>> > This should be done in probe().
    >>> >
    >>> Dont we then require "pm_runtime_put_sync" in probe, since we are trying
    >>> to read the keypad revision register.?
    >>
    >> Ah, indeed, but I think not pm_runtime_get_sync() but
    >> pm_runtime_set_active().
    >>
    >> Not sure if this will fix the crash...
    >>
    >> --
    >> Dmitry
    >>
    >>
    >> Input: omap-keypad - dynamically handle register offsets
    >>
    >> From: G, Manjunath Kondaiah <manjugk@ti.com>
    >>
    >> Keypad controller register offsets are different for omap4
    >> and omap5. Handle these offsets through static mapping and
    >> assign these mappings during run time.
    >>
    >> Tested on omap4430 sdp with 3.4-rc3.
    >> Tested on omap5430evm with 3.1-custom kernel.
    >>
    >> Signed-off-by: Felipe Balbi <balbi@ti.com>
    >> Signed-off-by: G, Manjunath Kondaiah <manjugk@ti.com>
    >> Signed-off-by: Sourav Poddar <sourav.poddar@ti.com>
    >> Signed-off-by: Dmitry Torokhov <dtor@mail.ru>
    >> ---
    >>
    >>  drivers/input/keyboard/Kconfig        |    4 +
    >>  drivers/input/keyboard/omap4-keypad.c |  117 ++++++++++++++++++++++++++-------
    >>  2 files changed, 94 insertions(+), 27 deletions(-)
    >>
    >>
    >> diff --git a/drivers/input/keyboard/Kconfig b/drivers/input/keyboard/Kconfig
    >> index 20a3753..84ee155 100644
    >> --- a/drivers/input/keyboard/Kconfig
    >> +++ b/drivers/input/keyboard/Kconfig
    >> @@ -531,9 +531,9 @@ config KEYBOARD_OMAP
    >>          module will be called omap-keypad.
    >>
    >>  config KEYBOARD_OMAP4
    >> -       tristate "TI OMAP4 keypad support"
    >> +       tristate "TI OMAP4+ keypad support"
    >>        help
    >> -         Say Y here if you want to use the OMAP4 keypad.
    >> +         Say Y here if you want to use the OMAP4+ keypad.
    >>
    >>          To compile this driver as a module, choose M here: the
    >>          module will be called omap4-keypad.
    >> diff --git a/drivers/input/keyboard/omap4-keypad.c b/drivers/input/keyboard/omap4-keypad.c
    >> index e809ac0..c9fd0df 100644
    >> --- a/drivers/input/keyboard/omap4-keypad.c
    >> +++ b/drivers/input/keyboard/omap4-keypad.c
    >> @@ -68,19 +68,52 @@
    >>
    >>  #define OMAP4_MASK_IRQSTATUSDISABLE    0xFFFF
    >>
    >> +enum {
    >> +       KBD_REVISION_OMAP4 = 0,
    >> +       KBD_REVISION_OMAP5,
    >> +};
    >> +
    >>  struct omap4_keypad {
    >>        struct input_dev *input;
    >>
    >>        void __iomem *base;
    >> -       int irq;
    >> +       unsigned int irq;
    >>
    >>        unsigned int rows;
    >>        unsigned int cols;
    >> +       u32 reg_offset;
    >> +       u32 irqreg_offset;
    >>        unsigned int row_shift;
    >>        unsigned char key_state[8];
    >>        unsigned short keymap[];
    >>  };
    >>
    >> +static int kbd_readl(struct omap4_keypad *keypad_data, u32 offset)
    >> +{
    >> +       return __raw_readl(keypad_data->base +
    >> +                               keypad_data->reg_offset + offset);
    >> +}
    >> +
    >> +static void kbd_writel(struct omap4_keypad *keypad_data, u32 offset, u32 value)
    >> +{
    >> +       __raw_writel(value,
    >> +                    keypad_data->base + keypad_data->reg_offset + offset);
    >> +}
    >> +
    >> +static int kbd_read_irqreg(struct omap4_keypad *keypad_data, u32 offset)
    >> +{
    >> +       return __raw_readl(keypad_data->base +
    >> +                               keypad_data->irqreg_offset + offset);
    >> +}
    >> +
    >> +static void kbd_write_irqreg(struct omap4_keypad *keypad_data,
    >> +                            u32 offset, u32 value)
    >> +{
    >> +       __raw_writel(value,
    >> +                    keypad_data->base + keypad_data->irqreg_offset + offset);
    >> +}
    >> +
    >> +
    >>  /* Interrupt handler */
    >>  static irqreturn_t omap4_keypad_interrupt(int irq, void *dev_id)
    >>  {
    >> @@ -91,12 +124,11 @@ static irqreturn_t omap4_keypad_interrupt(int irq, void *dev_id)
    >>        u32 *new_state = (u32 *) key_state;
    >>
    >>        /* Disable interrupts */
    >> -       __raw_writel(OMAP4_VAL_IRQDISABLE,
    >> -                    keypad_data->base + OMAP4_KBD_IRQENABLE);
    >> +       kbd_write_irqreg(keypad_data, OMAP4_KBD_IRQENABLE,
    >> +                        OMAP4_VAL_IRQDISABLE);
    >>
    >> -       *new_state = __raw_readl(keypad_data->base + OMAP4_KBD_FULLCODE31_0);
    >> -       *(new_state + 1) = __raw_readl(keypad_data->base
    >> -                                               + OMAP4_KBD_FULLCODE63_32);
    >> +       *new_state = kbd_readl(keypad_data, OMAP4_KBD_FULLCODE31_0);
    >> +       *(new_state + 1) = kbd_readl(keypad_data, OMAP4_KBD_FULLCODE63_32);
    >>
    >>        for (row = 0; row < keypad_data->rows; row++) {
    >>                changed = key_state[row] ^ keypad_data->key_state[row];
    >> @@ -121,12 +153,13 @@ static irqreturn_t omap4_keypad_interrupt(int irq, void *dev_id)
    >>                sizeof(keypad_data->key_state));
    >>
    >>        /* clear pending interrupts */
    >> -       __raw_writel(__raw_readl(keypad_data->base + OMAP4_KBD_IRQSTATUS),
    >> -                       keypad_data->base + OMAP4_KBD_IRQSTATUS);
    >> +       kbd_write_irqreg(keypad_data, OMAP4_KBD_IRQSTATUS,
    >> +                        kbd_read_irqreg(keypad_data, OMAP4_KBD_IRQSTATUS));
    >>
    >>        /* enable interrupts */
    >> -       __raw_writel(OMAP4_DEF_IRQENABLE_EVENTEN | OMAP4_DEF_IRQENABLE_LONGKEY,
    >> -                       keypad_data->base + OMAP4_KBD_IRQENABLE);
    >> +       kbd_write_irqreg(keypad_data, OMAP4_KBD_IRQENABLE,
    >> +               OMAP4_DEF_IRQENABLE_EVENTEN |
    >> +                               OMAP4_DEF_IRQENABLE_LONGKEY);
    >>
    >>        return IRQ_HANDLED;
    >>  }
    >> @@ -139,16 +172,17 @@ static int omap4_keypad_open(struct input_dev *input)
    >>
    >>        disable_irq(keypad_data->irq);
    >>
    >> -       __raw_writel(OMAP4_VAL_FUNCTIONALCFG,
    >> -                       keypad_data->base + OMAP4_KBD_CTRL);
    >> -       __raw_writel(OMAP4_VAL_DEBOUNCINGTIME,
    >> -                       keypad_data->base + OMAP4_KBD_DEBOUNCINGTIME);
    >> -       __raw_writel(OMAP4_VAL_IRQDISABLE,
    >> -                       keypad_data->base + OMAP4_KBD_IRQSTATUS);
    >> -       __raw_writel(OMAP4_DEF_IRQENABLE_EVENTEN | OMAP4_DEF_IRQENABLE_LONGKEY,
    >> -                       keypad_data->base + OMAP4_KBD_IRQENABLE);
    >> -       __raw_writel(OMAP4_DEF_WUP_EVENT_ENA | OMAP4_DEF_WUP_LONG_KEY_ENA,
    >> -                       keypad_data->base + OMAP4_KBD_WAKEUPENABLE);
    >> +       kbd_writel(keypad_data, OMAP4_KBD_CTRL,
    >> +                       OMAP4_VAL_FUNCTIONALCFG);
    >> +       kbd_writel(keypad_data, OMAP4_KBD_DEBOUNCINGTIME,
    >> +                       OMAP4_VAL_DEBOUNCINGTIME);
    >> +       kbd_write_irqreg(keypad_data, OMAP4_KBD_IRQSTATUS,
    >> +                       OMAP4_VAL_IRQDISABLE);
    >> +       kbd_write_irqreg(keypad_data, OMAP4_KBD_IRQENABLE,
    >> +                       OMAP4_DEF_IRQENABLE_EVENTEN |
    >> +                               OMAP4_DEF_IRQENABLE_LONGKEY);
    >> +       kbd_writel(keypad_data, OMAP4_KBD_WAKEUPENABLE,
    >> +                       OMAP4_DEF_WUP_EVENT_ENA | OMAP4_DEF_WUP_LONG_KEY_ENA);
    >>
    >>        enable_irq(keypad_data->irq);
    >>
    >> @@ -162,12 +196,12 @@ static void omap4_keypad_close(struct input_dev *input)
    >>        disable_irq(keypad_data->irq);
    >>
    >>        /* Disable interrupts */
    >> -       __raw_writel(OMAP4_VAL_IRQDISABLE,
    >> -                    keypad_data->base + OMAP4_KBD_IRQENABLE);
    >> +       kbd_write_irqreg(keypad_data, OMAP4_KBD_IRQENABLE,
    >> +                        OMAP4_VAL_IRQDISABLE);
    >>
    >>        /* clear pending interrupts */
    >> -       __raw_writel(__raw_readl(keypad_data->base + OMAP4_KBD_IRQSTATUS),
    >> -                       keypad_data->base + OMAP4_KBD_IRQSTATUS);
    >> +       kbd_write_irqreg(keypad_data, OMAP4_KBD_IRQSTATUS,
    >> +                        kbd_read_irqreg(keypad_data, OMAP4_KBD_IRQSTATUS));
    >>
    >>        enable_irq(keypad_data->irq);
    >>
    >> @@ -182,6 +216,7 @@ static int __devinit omap4_keypad_probe(struct platform_device *pdev)
    >>        struct resource *res;
    >>        resource_size_t size;
    >>        unsigned int row_shift, max_keys;
    >> +       int rev;
    >>        int irq;
    >>        int error;
    >>
    >> @@ -241,11 +276,40 @@ static int __devinit omap4_keypad_probe(struct platform_device *pdev)
    >>        keypad_data->rows = pdata->rows;
    >>        keypad_data->cols = pdata->cols;
    >>
    >> +       /*
    >> +        * Mark device as active (and wake up its parent) so we can read
    >> +        * revision register.
    >> +        */
    >> +       error = pm_runtime_set_active(&pdev->dev);
    >> +       if (error) {
    >> +               dev_err(&pdev->dev, "pm_runtime_set_active() failed\n");
    >> +               goto err_unmap;
    >> +       }
    >> +
    >> +       rev = __raw_readl(keypad_data->base + OMAP4_KBD_REVISION);
    >> +       rev &= 0x03 << 30;
    >> +       rev >>= 30;
    >> +       switch (rev) {
    >> +       case KBD_REVISION_OMAP4:
    >> +               keypad_data->reg_offset = 0x00;
    >> +               keypad_data->irqreg_offset = 0x00;
    >> +               break;
    >> +       case KBD_REVISION_OMAP5:
    >> +               keypad_data->reg_offset = 0x10;
    >> +               keypad_data->irqreg_offset = 0x0c;
    >> +               break;
    >> +       default:
    >> +               dev_err(&pdev->dev,
    >> +                       "Keypad reports unsupported revision %d", rev);
    >> +               error = -EINVAL;
    >> +               goto err_pm_suspended;
    >> +       }
    >> +
    >>        /* input device allocation */
    >>        keypad_data->input = input_dev = input_allocate_device();
    >>        if (!input_dev) {
    >>                error = -ENOMEM;
    >> -               goto err_unmap;
    >> +               goto err_pm_suspended;
    >>        }
    >>
    >>        input_dev->name = pdev->name;
    >> @@ -281,6 +345,7 @@ static int __devinit omap4_keypad_probe(struct platform_device *pdev)
    >>        }
    >>
    >>        pm_runtime_enable(&pdev->dev);
    >> +       pm_runtime_put_sync(&pdev->dev);
    >>
    >>        error = input_register_device(keypad_data->input);
    >>        if (error < 0) {
    >> @@ -296,6 +361,8 @@ err_pm_disable:
    >>        free_irq(keypad_data->irq, keypad_data);
    >>  err_free_input:
    >>        input_free_device(input_dev);
    >> +err_pm_suspended:
    >> +       pm_runtime_set_suspended(&pdev->dev);
    >>  err_unmap:
    >>        iounmap(keypad_data->base);
    >>  err_release_mem:
    
    From: G, Manjunath Kondaiah <manjugk@ti.com>
    Date: Mon, 10 Oct 2011 20:52:05 +0530
    Subject: [PATCH] Input: omap-keypad: dynamically handle register offsets
    
    Keypad controller register offsets are different for omap4
    and omap5. Handle these offsets through static mapping and
    assign these mappings during run time.
    
    Tested on omap4430 sdp with 3.4-rc3.
    Tested on omap5430evm with 3.1-custom kernel.
    
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: G, Manjunath Kondaiah <manjugk@ti.com>
    Signed-off-by: Sourav Poddar <sourav.poddar@ti.com>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

commit 7483b4a4d9abf9dcf1ffe6e805ead2847ec3264e
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun Apr 29 22:53:22 2012 +0200

    PM / Sleep: Implement opportunistic sleep, v2
    
    Introduce a mechanism by which the kernel can trigger global
    transitions to a sleep state chosen by user space if there are no
    active wakeup sources.
    
    It consists of a new sysfs attribute, /sys/power/autosleep, that
    can be written one of the strings returned by reads from
    /sys/power/state, an ordered workqueue and a work item carrying out
    the "suspend" operations.  If a string representing the system's
    sleep state is written to /sys/power/autosleep, the work item
    triggering transitions to that state is queued up and it requeues
    itself after every execution until user space writes "off" to
    /sys/power/autosleep.
    
    That work item enables the detection of wakeup events using the
    functions already defined in drivers/base/power/wakeup.c (with one
    small modification) and calls either pm_suspend(), or hibernate() to
    put the system into a sleep state.  If a wakeup event is reported
    while the transition is in progress, it will abort the transition and
    the "system suspend" work item will be queued up again.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Reviewed-by: NeilBrown <neilb@suse.de>

commit 327acb4361452fc79e4f2f38f366f9baa55e3676
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Mar 26 22:46:52 2012 +0200

    PM / Runtime: don't forget to wake up waitqueue on failure
    
    commit f2791d733a2f06997b573d1a3cfde21e6f529826 upstream.
    
    This patch (as1535) fixes a bug in the runtime PM core.  When a
    runtime suspend attempt completes, whether successfully or not, the
    device's power.wait_queue is supposed to be signalled.  But this
    doesn't happen in the failure pathway of rpm_suspend() when another
    autosuspend attempt is rescheduled.  As a result, a task can get stuck
    indefinitely on the wait queue (I have seen this happen in testing).
    
    The patch fixes the problem by moving the wake_up_all() call up near
    the start of the failure code.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit f2791d733a2f06997b573d1a3cfde21e6f529826
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Mar 26 22:46:52 2012 +0200

    PM / Runtime: don't forget to wake up waitqueue on failure
    
    This patch (as1535) fixes a bug in the runtime PM core.  When a
    runtime suspend attempt completes, whether successfully or not, the
    device's power.wait_queue is supposed to be signalled.  But this
    doesn't happen in the failure pathway of rpm_suspend() when another
    autosuspend attempt is rescheduled.  As a result, a task can get stuck
    indefinitely on the wait queue (I have seen this happen in testing).
    
    The patch fixes the problem by moving the wake_up_all() call up near
    the start of the failure code.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    CC: <stable@vger.kernel.org>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

commit 048be431e40ee32df8e6c1a2c216693afe3ee358
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Fri Mar 9 12:59:44 2012 +0900

    sh-sci / PM: Avoid deadlocking runtime PM
    
    The runtime PM of sh-sci devices is enabled when sci_probe() returns,
    so the pm_runtime_put_sync() executed by driver_probe_device()
    attempts to suspend the device.  Then, in some situations, a
    diagnostic message is printed to the console by one of the runtime
    suspend routines handling the sh-sci device, which causes synchronous
    runtime resume to be started from the device's own runtime suspend
    callback.  This causes rpm_resume() to be run eventually, which sees
    the RPM_SUSPENDING status set by rpm_suspend() and waits for it to
    change.  However, the device's runtime PM status cannot change at
    that point, because the routine that has set it waits for the
    rpm_suspend() to return.  A deadlock occurs as a result.
    
    To avoid that make sci_init_single() increment the device's
    runtime PM usage counter, so that it cannot be suspended by
    driver_probe_device().  That counter has to be decremented
    eventually, so make sci_startup() do that before starting to
    actually use the device and make sci_shutdown() increment it
    again before returning to balance the incrementation carried out by
    sci_startup().
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Tested-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

commit bc25cf508942c56810d4fb623ef27b56ccef7783
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Feb 13 16:29:33 2012 +0100

    PM / Sleep: Drop suspend_stats_update()
    
    Since suspend_stats_update() is only called from pm_suspend(),
    move its code directly into that function and remove the static
    inline definition from include/linux/suspend.h.  Clean_up
    pm_suspend() in the process.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>

commit 93e1ee43a72b11e1b50aab87046c131a836a4456
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Feb 13 16:29:24 2012 +0100

    PM / Sleep: Make enter_state() in kernel/power/suspend.c static
    
    The enter_state() function in kernel/power/suspend.c should be
    static and state_store() in kernel/power/suspend.c should call
    pm_suspend() instead of it, so make that happen (which also reduces
    code duplication related to suspend statistics).
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>

commit 93636af6098a627a1ddc02f2f265be4a9d337201
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Wed Feb 8 17:13:41 2012 -0800

    pcmcia: fix socket refcount decrementing on each resume
    
    commit 025e4ab3db07fcbf62c01e4f30d1012234beb980 upstream.
    
    This fixes a memory-corrupting bug: not only does it cause the warning,
    but as a result of dropping the refcount to zero, it causes the
    pcmcia_socket0 device structure to be freed while it still has
    references, causing slab caches corruption.  A fatal oops quickly
    follows this warning - often even just a 'dmesg' following the warning
    causes the kernel to oops.
    
    While testing suspend/resume on an ARM device with PCMCIA support, and a
    CF card inserted, I found that after five suspend and resumes, the
    kernel would complain, and shortly die after with slab corruption.
    
      WARNING: at include/linux/kref.h:41 kobject_get+0x28/0x50()
    
    As the message doesn't give a clue about which kobject, and the built-in
    debugging in drivers/base/power/main.c happens too late, this was added
    right before each get_device():
    
      printk("%s: %p [%s] %u\n", __func__, dev, kobject_name(&dev->kobj), atomic_read(&dev->kobj.kref.refcount));
    
    and on the 3rd s2ram cycle, the following behaviour observed:
    
    On the 3rd suspend/resume cycle:
    
      dpm_prepare: c1a0d998 [pcmcia_socket0] 3
      dpm_suspend: c1a0d998 [pcmcia_socket0] 3
      dpm_suspend_noirq: c1a0d998 [pcmcia_socket0] 3
      dpm_resume_noirq: c1a0d998 [pcmcia_socket0] 3
      dpm_resume: c1a0d998 [pcmcia_socket0] 3
      dpm_complete: c1a0d998 [pcmcia_socket0] 2
    
    4th:
    
      dpm_prepare: c1a0d998 [pcmcia_socket0] 2
      dpm_suspend: c1a0d998 [pcmcia_socket0] 2
      dpm_suspend_noirq: c1a0d998 [pcmcia_socket0] 2
      dpm_resume_noirq: c1a0d998 [pcmcia_socket0] 2
      dpm_resume: c1a0d998 [pcmcia_socket0] 2
      dpm_complete: c1a0d998 [pcmcia_socket0] 1
    
    5th:
    
      dpm_prepare: c1a0d998 [pcmcia_socket0] 1
      dpm_suspend: c1a0d998 [pcmcia_socket0] 1
      dpm_suspend_noirq: c1a0d998 [pcmcia_socket0] 1
      dpm_resume_noirq: c1a0d998 [pcmcia_socket0] 1
      dpm_resume: c1a0d998 [pcmcia_socket0] 1
      dpm_complete: c1a0d998 [pcmcia_socket0] 0
      ------------[ cut here ]------------
      WARNING: at include/linux/kref.h:41 kobject_get+0x28/0x50()
      Modules linked in: ucb1x00_core
      Backtrace:
      [<c0212090>] (dump_backtrace+0x0/0x110) from [<c04799dc>] (dump_stack+0x18/0x1c)
      [<c04799c4>] (dump_stack+0x0/0x1c) from [<c021cba0>] (warn_slowpath_common+0x50/0x68)
      [<c021cb50>] (warn_slowpath_common+0x0/0x68) from [<c021cbdc>] (warn_slowpath_null+0x24/0x28)
      [<c021cbb8>] (warn_slowpath_null+0x0/0x28) from [<c0335374>] (kobject_get+0x28/0x50)
      [<c033534c>] (kobject_get+0x0/0x50) from [<c03804f4>] (get_device+0x1c/0x24)
      [<c0388c90>] (dpm_complete+0x0/0x1a0) from [<c0389cc0>] (dpm_resume_end+0x1c/0x20)
      ...
    
    Looking at commit 7b24e7988263 ("pcmcia: split up central event handler"),
    the following change was made to cs.c:
    
                    return 0;
            }
     #endif
    -
    -       send_event(skt, CS_EVENT_PM_RESUME, CS_EVENT_PRI_LOW);
    +       if (!(skt->state & SOCKET_CARDBUS) && (skt->callback))
    +               skt->callback->early_resume(skt);
            return 0;
     }
    
    And the corresponding change in ds.c is from:
    
    -static int ds_event(struct pcmcia_socket *skt, event_t event, int priority)
    -{
    -       struct pcmcia_socket *s = pcmcia_get_socket(skt);
    ...
    -       switch (event) {
    ...
    -       case CS_EVENT_PM_RESUME:
    -               if (verify_cis_cache(skt) != 0) {
    -                       dev_dbg(&skt->dev, "cis mismatch - different card\n");
    -                       /* first, remove the card */
    -                       ds_event(skt, CS_EVENT_CARD_REMOVAL, CS_EVENT_PRI_HIGH);
    -                       mutex_lock(&s->ops_mutex);
    -                       destroy_cis_cache(skt);
    -                       kfree(skt->fake_cis);
    -                       skt->fake_cis = NULL;
    -                       s->functions = 0;
    -                       mutex_unlock(&s->ops_mutex);
    -                       /* now, add the new card */
    -                       ds_event(skt, CS_EVENT_CARD_INSERTION,
    -                                CS_EVENT_PRI_LOW);
    -               }
    -               break;
    ...
    -    }
    
    -    pcmcia_put_socket(s);
    
    -    return 0;
    -} /* ds_event */
    
    to:
    
    +static int pcmcia_bus_early_resume(struct pcmcia_socket *skt)
    +{
    +       if (!verify_cis_cache(skt)) {
    +               pcmcia_put_socket(skt);
    +               return 0;
    +       }
    
    +       dev_dbg(&skt->dev, "cis mismatch - different card\n");
    
    +       /* first, remove the card */
    +       pcmcia_bus_remove(skt);
    +       mutex_lock(&skt->ops_mutex);
    +       destroy_cis_cache(skt);
    +       kfree(skt->fake_cis);
    +       skt->fake_cis = NULL;
    +       skt->functions = 0;
    +       mutex_unlock(&skt->ops_mutex);
    
    +       /* now, add the new card */
    +       pcmcia_bus_add(skt);
    +       return 0;
    +}
    
    As can be seen, the original function called pcmcia_get_socket() and
    pcmcia_put_socket() around the guts, whereas the replacement code
    calls pcmcia_put_socket() only in one path.  This creates an imbalance
    in the refcounting.
    
    Testing with pcmcia_put_socket() put removed shows that the bug is gone:
    
      dpm_suspend: c1a10998 [pcmcia_socket0] 5
      dpm_suspend_noirq: c1a10998 [pcmcia_socket0] 5
      dpm_resume_noirq: c1a10998 [pcmcia_socket0] 5
      dpm_resume: c1a10998 [pcmcia_socket0] 5
      dpm_complete: c1a10998 [pcmcia_socket0] 5
    
    Tested-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Cc: Dominik Brodowski <linux@dominikbrodowski.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit a5e2ba3e021e7a3135a7dbb8e188d21971a59f49
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Wed Feb 8 17:13:41 2012 -0800

    pcmcia: fix socket refcount decrementing on each resume
    
    commit 025e4ab3db07fcbf62c01e4f30d1012234beb980 upstream.
    
    This fixes a memory-corrupting bug: not only does it cause the warning,
    but as a result of dropping the refcount to zero, it causes the
    pcmcia_socket0 device structure to be freed while it still has
    references, causing slab caches corruption.  A fatal oops quickly
    follows this warning - often even just a 'dmesg' following the warning
    causes the kernel to oops.
    
    While testing suspend/resume on an ARM device with PCMCIA support, and a
    CF card inserted, I found that after five suspend and resumes, the
    kernel would complain, and shortly die after with slab corruption.
    
      WARNING: at include/linux/kref.h:41 kobject_get+0x28/0x50()
    
    As the message doesn't give a clue about which kobject, and the built-in
    debugging in drivers/base/power/main.c happens too late, this was added
    right before each get_device():
    
      printk("%s: %p [%s] %u\n", __func__, dev, kobject_name(&dev->kobj), atomic_read(&dev->kobj.kref.refcount));
    
    and on the 3rd s2ram cycle, the following behaviour observed:
    
    On the 3rd suspend/resume cycle:
    
      dpm_prepare: c1a0d998 [pcmcia_socket0] 3
      dpm_suspend: c1a0d998 [pcmcia_socket0] 3
      dpm_suspend_noirq: c1a0d998 [pcmcia_socket0] 3
      dpm_resume_noirq: c1a0d998 [pcmcia_socket0] 3
      dpm_resume: c1a0d998 [pcmcia_socket0] 3
      dpm_complete: c1a0d998 [pcmcia_socket0] 2
    
    4th:
    
      dpm_prepare: c1a0d998 [pcmcia_socket0] 2
      dpm_suspend: c1a0d998 [pcmcia_socket0] 2
      dpm_suspend_noirq: c1a0d998 [pcmcia_socket0] 2
      dpm_resume_noirq: c1a0d998 [pcmcia_socket0] 2
      dpm_resume: c1a0d998 [pcmcia_socket0] 2
      dpm_complete: c1a0d998 [pcmcia_socket0] 1
    
    5th:
    
      dpm_prepare: c1a0d998 [pcmcia_socket0] 1
      dpm_suspend: c1a0d998 [pcmcia_socket0] 1
      dpm_suspend_noirq: c1a0d998 [pcmcia_socket0] 1
      dpm_resume_noirq: c1a0d998 [pcmcia_socket0] 1
      dpm_resume: c1a0d998 [pcmcia_socket0] 1
      dpm_complete: c1a0d998 [pcmcia_socket0] 0
      ------------[ cut here ]------------
      WARNING: at include/linux/kref.h:41 kobject_get+0x28/0x50()
      Modules linked in: ucb1x00_core
      Backtrace:
      [<c0212090>] (dump_backtrace+0x0/0x110) from [<c04799dc>] (dump_stack+0x18/0x1c)
      [<c04799c4>] (dump_stack+0x0/0x1c) from [<c021cba0>] (warn_slowpath_common+0x50/0x68)
      [<c021cb50>] (warn_slowpath_common+0x0/0x68) from [<c021cbdc>] (warn_slowpath_null+0x24/0x28)
      [<c021cbb8>] (warn_slowpath_null+0x0/0x28) from [<c0335374>] (kobject_get+0x28/0x50)
      [<c033534c>] (kobject_get+0x0/0x50) from [<c03804f4>] (get_device+0x1c/0x24)
      [<c0388c90>] (dpm_complete+0x0/0x1a0) from [<c0389cc0>] (dpm_resume_end+0x1c/0x20)
      ...
    
    Looking at commit 7b24e7988263 ("pcmcia: split up central event handler"),
    the following change was made to cs.c:
    
                    return 0;
            }
     #endif
    -
    -       send_event(skt, CS_EVENT_PM_RESUME, CS_EVENT_PRI_LOW);
    +       if (!(skt->state & SOCKET_CARDBUS) && (skt->callback))
    +               skt->callback->early_resume(skt);
            return 0;
     }
    
    And the corresponding change in ds.c is from:
    
    -static int ds_event(struct pcmcia_socket *skt, event_t event, int priority)
    -{
    -       struct pcmcia_socket *s = pcmcia_get_socket(skt);
    ...
    -       switch (event) {
    ...
    -       case CS_EVENT_PM_RESUME:
    -               if (verify_cis_cache(skt) != 0) {
    -                       dev_dbg(&skt->dev, "cis mismatch - different card\n");
    -                       /* first, remove the card */
    -                       ds_event(skt, CS_EVENT_CARD_REMOVAL, CS_EVENT_PRI_HIGH);
    -                       mutex_lock(&s->ops_mutex);
    -                       destroy_cis_cache(skt);
    -                       kfree(skt->fake_cis);
    -                       skt->fake_cis = NULL;
    -                       s->functions = 0;
    -                       mutex_unlock(&s->ops_mutex);
    -                       /* now, add the new card */
    -                       ds_event(skt, CS_EVENT_CARD_INSERTION,
    -                                CS_EVENT_PRI_LOW);
    -               }
    -               break;
    ...
    -    }
    
    -    pcmcia_put_socket(s);
    
    -    return 0;
    -} /* ds_event */
    
    to:
    
    +static int pcmcia_bus_early_resume(struct pcmcia_socket *skt)
    +{
    +       if (!verify_cis_cache(skt)) {
    +               pcmcia_put_socket(skt);
    +               return 0;
    +       }
    
    +       dev_dbg(&skt->dev, "cis mismatch - different card\n");
    
    +       /* first, remove the card */
    +       pcmcia_bus_remove(skt);
    +       mutex_lock(&skt->ops_mutex);
    +       destroy_cis_cache(skt);
    +       kfree(skt->fake_cis);
    +       skt->fake_cis = NULL;
    +       skt->functions = 0;
    +       mutex_unlock(&skt->ops_mutex);
    
    +       /* now, add the new card */
    +       pcmcia_bus_add(skt);
    +       return 0;
    +}
    
    As can be seen, the original function called pcmcia_get_socket() and
    pcmcia_put_socket() around the guts, whereas the replacement code
    calls pcmcia_put_socket() only in one path.  This creates an imbalance
    in the refcounting.
    
    Testing with pcmcia_put_socket() put removed shows that the bug is gone:
    
      dpm_suspend: c1a10998 [pcmcia_socket0] 5
      dpm_suspend_noirq: c1a10998 [pcmcia_socket0] 5
      dpm_resume_noirq: c1a10998 [pcmcia_socket0] 5
      dpm_resume: c1a10998 [pcmcia_socket0] 5
      dpm_complete: c1a10998 [pcmcia_socket0] 5
    
    Tested-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Cc: Dominik Brodowski <linux@dominikbrodowski.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 025e4ab3db07fcbf62c01e4f30d1012234beb980
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Wed Feb 8 17:13:41 2012 -0800

    pcmcia: fix socket refcount decrementing on each resume
    
    This fixes a memory-corrupting bug: not only does it cause the warning,
    but as a result of dropping the refcount to zero, it causes the
    pcmcia_socket0 device structure to be freed while it still has
    references, causing slab caches corruption.  A fatal oops quickly
    follows this warning - often even just a 'dmesg' following the warning
    causes the kernel to oops.
    
    While testing suspend/resume on an ARM device with PCMCIA support, and a
    CF card inserted, I found that after five suspend and resumes, the
    kernel would complain, and shortly die after with slab corruption.
    
      WARNING: at include/linux/kref.h:41 kobject_get+0x28/0x50()
    
    As the message doesn't give a clue about which kobject, and the built-in
    debugging in drivers/base/power/main.c happens too late, this was added
    right before each get_device():
    
      printk("%s: %p [%s] %u\n", __func__, dev, kobject_name(&dev->kobj), atomic_read(&dev->kobj.kref.refcount));
    
    and on the 3rd s2ram cycle, the following behaviour observed:
    
    On the 3rd suspend/resume cycle:
    
      dpm_prepare: c1a0d998 [pcmcia_socket0] 3
      dpm_suspend: c1a0d998 [pcmcia_socket0] 3
      dpm_suspend_noirq: c1a0d998 [pcmcia_socket0] 3
      dpm_resume_noirq: c1a0d998 [pcmcia_socket0] 3
      dpm_resume: c1a0d998 [pcmcia_socket0] 3
      dpm_complete: c1a0d998 [pcmcia_socket0] 2
    
    4th:
    
      dpm_prepare: c1a0d998 [pcmcia_socket0] 2
      dpm_suspend: c1a0d998 [pcmcia_socket0] 2
      dpm_suspend_noirq: c1a0d998 [pcmcia_socket0] 2
      dpm_resume_noirq: c1a0d998 [pcmcia_socket0] 2
      dpm_resume: c1a0d998 [pcmcia_socket0] 2
      dpm_complete: c1a0d998 [pcmcia_socket0] 1
    
    5th:
    
      dpm_prepare: c1a0d998 [pcmcia_socket0] 1
      dpm_suspend: c1a0d998 [pcmcia_socket0] 1
      dpm_suspend_noirq: c1a0d998 [pcmcia_socket0] 1
      dpm_resume_noirq: c1a0d998 [pcmcia_socket0] 1
      dpm_resume: c1a0d998 [pcmcia_socket0] 1
      dpm_complete: c1a0d998 [pcmcia_socket0] 0
      ------------[ cut here ]------------
      WARNING: at include/linux/kref.h:41 kobject_get+0x28/0x50()
      Modules linked in: ucb1x00_core
      Backtrace:
      [<c0212090>] (dump_backtrace+0x0/0x110) from [<c04799dc>] (dump_stack+0x18/0x1c)
      [<c04799c4>] (dump_stack+0x0/0x1c) from [<c021cba0>] (warn_slowpath_common+0x50/0x68)
      [<c021cb50>] (warn_slowpath_common+0x0/0x68) from [<c021cbdc>] (warn_slowpath_null+0x24/0x28)
      [<c021cbb8>] (warn_slowpath_null+0x0/0x28) from [<c0335374>] (kobject_get+0x28/0x50)
      [<c033534c>] (kobject_get+0x0/0x50) from [<c03804f4>] (get_device+0x1c/0x24)
      [<c0388c90>] (dpm_complete+0x0/0x1a0) from [<c0389cc0>] (dpm_resume_end+0x1c/0x20)
      ...
    
    Looking at commit 7b24e7988263 ("pcmcia: split up central event handler"),
    the following change was made to cs.c:
    
                    return 0;
            }
     #endif
    -
    -       send_event(skt, CS_EVENT_PM_RESUME, CS_EVENT_PRI_LOW);
    +       if (!(skt->state & SOCKET_CARDBUS) && (skt->callback))
    +               skt->callback->early_resume(skt);
            return 0;
     }
    
    And the corresponding change in ds.c is from:
    
    -static int ds_event(struct pcmcia_socket *skt, event_t event, int priority)
    -{
    -       struct pcmcia_socket *s = pcmcia_get_socket(skt);
    ...
    -       switch (event) {
    ...
    -       case CS_EVENT_PM_RESUME:
    -               if (verify_cis_cache(skt) != 0) {
    -                       dev_dbg(&skt->dev, "cis mismatch - different card\n");
    -                       /* first, remove the card */
    -                       ds_event(skt, CS_EVENT_CARD_REMOVAL, CS_EVENT_PRI_HIGH);
    -                       mutex_lock(&s->ops_mutex);
    -                       destroy_cis_cache(skt);
    -                       kfree(skt->fake_cis);
    -                       skt->fake_cis = NULL;
    -                       s->functions = 0;
    -                       mutex_unlock(&s->ops_mutex);
    -                       /* now, add the new card */
    -                       ds_event(skt, CS_EVENT_CARD_INSERTION,
    -                                CS_EVENT_PRI_LOW);
    -               }
    -               break;
    ...
    -    }
    
    -    pcmcia_put_socket(s);
    
    -    return 0;
    -} /* ds_event */
    
    to:
    
    +static int pcmcia_bus_early_resume(struct pcmcia_socket *skt)
    +{
    +       if (!verify_cis_cache(skt)) {
    +               pcmcia_put_socket(skt);
    +               return 0;
    +       }
    
    +       dev_dbg(&skt->dev, "cis mismatch - different card\n");
    
    +       /* first, remove the card */
    +       pcmcia_bus_remove(skt);
    +       mutex_lock(&skt->ops_mutex);
    +       destroy_cis_cache(skt);
    +       kfree(skt->fake_cis);
    +       skt->fake_cis = NULL;
    +       skt->functions = 0;
    +       mutex_unlock(&skt->ops_mutex);
    
    +       /* now, add the new card */
    +       pcmcia_bus_add(skt);
    +       return 0;
    +}
    
    As can be seen, the original function called pcmcia_get_socket() and
    pcmcia_put_socket() around the guts, whereas the replacement code
    calls pcmcia_put_socket() only in one path.  This creates an imbalance
    in the refcounting.
    
    Testing with pcmcia_put_socket() put removed shows that the bug is gone:
    
      dpm_suspend: c1a10998 [pcmcia_socket0] 5
      dpm_suspend_noirq: c1a10998 [pcmcia_socket0] 5
      dpm_resume_noirq: c1a10998 [pcmcia_socket0] 5
      dpm_resume: c1a10998 [pcmcia_socket0] 5
      dpm_complete: c1a10998 [pcmcia_socket0] 5
    
    Tested-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Cc: Dominik Brodowski <linux@dominikbrodowski.net>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit c4b16f7f222bb71d44a94a75f291d3fc2c9292b5
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Wed Sep 21 20:55:04 2011 +0200

    PM / Suspend: Off by one in pm_suspend()
    
    commit 528f7ce6e439edeac38f6b3f8561f1be129b5e91 upstream.
    
    In enter_state() we use "state" as an offset for the pm_states[]
    array.  The pm_states[] array only has PM_SUSPEND_MAX elements so
    this test is off by one.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit ca9b9d7bf6fc89a8a72c6aa37c683d02b7782b0b
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Wed Sep 21 20:55:04 2011 +0200

    PM / Suspend: Off by one in pm_suspend()
    
    commit 528f7ce6e439edeac38f6b3f8561f1be129b5e91 upstream.
    
    In enter_state() we use "state" as an offset for the pm_states[]
    array.  The pm_states[] array only has PM_SUSPEND_MAX elements so
    this test is off by one.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit f450df800450e9c7ec8c53bdb72d6c4ef5f17d4e
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Wed Sep 21 20:55:04 2011 +0200

    PM / Suspend: Off by one in pm_suspend()
    
    commit 528f7ce6e439edeac38f6b3f8561f1be129b5e91 upstream.
    
    In enter_state() we use "state" as an offset for the pm_states[]
    array.  The pm_states[] array only has PM_SUSPEND_MAX elements so
    this test is off by one.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 52c2843322362bfd847bdda1d3cebc751de68e5b
Author: Octavian Purdila <octavian.purdila@intel.com>
Date:   Thu Oct 6 11:26:37 2011 -0700

    i2c-designware: Fix PCI core warning on suspend/resume
    
    PCI core warns if the legacy PM and new PM functions are
    present. Update the driver to only use the new power management
    framework.
    
    This patch fixes the following warning seen during suspend/resume:
    
    <7>[   24.193850] i2c-designware-pci 0000:08:13.0: suspend
    <4>[   24.193866] ------------[ cut here ]------------
    <4>[   24.193892] WARNING: at drivers/pci/pci-driver.c:605 pci_has_legacy_pm_support+0x48/0x4d()
    <4>[   24.193925] Hardware name: OakTrail
    <4>[   24.193936] Modules linked in:
    <4>[   24.193958] Pid: 2834, comm: kworker/u:22 Tainted: G        W   2.6.36greenridge-01402-gc8047e6 #171
    <4>[   24.193974] Call Trace:
    <4>[   24.193999]  [<c1033a93>] warn_slowpath_common+0x66/0xc2
    <4>[   24.194025]  [<c1164143>] ? pci_has_legacy_pm_support+0x48/0x4d
    <4>[   24.194052]  [<c1033afe>] warn_slowpath_null+0xf/0x13
    <4>[   24.194079]  [<c1164143>] pci_has_legacy_pm_support+0x48/0x4d
    <4>[   24.194106]  [<c11643ff>] pci_pm_suspend+0x22/0x154
    <4>[   24.194131]  [<c11643dd>] ? pci_pm_suspend+0x0/0x154
    <4>[   24.194156]  [<c11e8a7a>] pm_op+0x3e/0x95
    <4>[   24.194182]  [<c11e931d>] __device_suspend+0x12e/0x194
    <4>[   24.194208]  [<c11e974d>] ? dpm_drv_timeout+0x0/0x47
    <4>[   24.194237]  [<c11e9729>] async_suspend+0x16/0x3a
    <4>[   24.194265]  [<c104de8e>] async_run_entry_fn+0x97/0x135
    <4>[   24.194291]  [<c1043c34>] process_one_work+0x1c9/0x2db
    
    Signed-off-by: Octavian Purdila <octavian.purdila@intel.com>
    Signed-off-by: Dirk Brandewie <dirk.brandewie@gmail.com>
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Ben Dooks <ben-linux@fluff.org>

commit 7e0bb71e75020348bee523720a0c2f04cc72f540
Merge: b9e2780d576a 0ab1e79b825a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Oct 25 15:18:39 2011 +0200

    Merge branch 'pm-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    * 'pm-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (63 commits)
      PM / Clocks: Remove redundant NULL checks before kfree()
      PM / Documentation: Update docs about suspend and CPU hotplug
      ACPI / PM: Add Sony VGN-FW21E to nonvs blacklist.
      ARM: mach-shmobile: sh7372 A4R support (v4)
      ARM: mach-shmobile: sh7372 A3SP support (v4)
      PM / Sleep: Mark devices involved in wakeup signaling during suspend
      PM / Hibernate: Improve performance of LZO/plain hibernation, checksum image
      PM / Hibernate: Do not initialize static and extern variables to 0
      PM / Freezer: Make fake_signal_wake_up() wake TASK_KILLABLE tasks too
      PM / Hibernate: Add resumedelay kernel param in addition to resumewait
      MAINTAINERS: Update linux-pm list address
      PM / ACPI: Blacklist Vaio VGN-FW520F machine known to require acpi_sleep=nonvs
      PM / ACPI: Blacklist Sony Vaio known to require acpi_sleep=nonvs
      PM / Hibernate: Add resumewait param to support MMC-like devices as resume file
      PM / Hibernate: Fix typo in a kerneldoc comment
      PM / Hibernate: Freeze kernel threads after preallocating memory
      PM: Update the policy on default wakeup settings
      PM / VT: Cleanup #if defined uglyness and fix compile error
      PM / Suspend: Off by one in pm_suspend()
      PM / Hibernate: Include storage keys in hibernation image on s390
      ...

commit 528f7ce6e439edeac38f6b3f8561f1be129b5e91
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Wed Sep 21 20:55:04 2011 +0200

    PM / Suspend: Off by one in pm_suspend()
    
    In enter_state() we use "state" as an offset for the pm_states[]
    array.  The pm_states[] array only has PM_SUSPEND_MAX elements so
    this test is off by one.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: stable@kernel.org

commit 9bd717c0dc8224cadfd66df7eeff98c987711d98
Merge: 7811ac276bb9 857b36c7b038
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun Oct 16 23:26:49 2011 +0200

    Merge branch 'pm-runtime' into pm-for-linus
    
    * pm-runtime:
      PM / Runtime: Handle .runtime_suspend() failure correctly
      PM / Runtime: Fix kerneldoc comment for rpm_suspend()
      PM / Runtime: Update document about callbacks

commit 857b36c7b038ac56a882ee914df93e5985443074
Author: Ming Lei <ming.lei@canonical.com>
Date:   Wed Oct 12 22:59:33 2011 +0200

    PM / Runtime: Handle .runtime_suspend() failure correctly
    
    If .runtime_suspend() returns -EAGAIN or -EBUSY, the device should
    still be in ACTIVE state, so it is not necessary to send an idle
    notification to its parent.  If .runtime_suspend() returns other
    fatal failure, it doesn't make sense to send idle notification to
    its parent.
    
    Skip parent idle notification when failure is returned from
    .runtime_suspend() and update comments in rpm_suspend() to reflect
    that change.
    
    [rjw: Modified the subject and changelog slightly.]
    
    Signed-off-by: Ming Lei <ming.lei@canonical.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

commit 47d8f0bac0fda4c15a030f92cd6da6c6bed87459
Author: Ming Lei <ming.lei@canonical.com>
Date:   Wed Oct 12 11:53:32 2011 +0800

    PM / Runtime: Fix kerneldoc comment for rpm_suspend()
    
    This patch fix kerneldoc comments for rpm_suspend():
    
     - 'Cancel a pending idle notification' should be put before, also
       should be changed to 'Cancel a pending idle notification,
       autosuspend or suspend'.
    
     - idle notification for the device after succeeding suspend has
       been removed, so update the comment accordingly.
    
    [rjw: Modified the subject and changelog slightly.]
    
    Signed-off-by: Ming Lei <ming.lei@canonical.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

commit c3dc2f14622a06488f11452b6efd1e02c5a8548b
Author: Ming Lei <ming.lei@canonical.com>
Date:   Tue Sep 27 22:54:41 2011 +0200

    PM / Runtime: Replace dev_dbg() with trace_rpm_*()
    
    This patch replaces dev_dbg with trace_rpm_* inside
    the three important functions:
    
            rpm_idle
            rpm_suspend
            rpm_resume
    
    Trace points have the below advantages compared with dev_dbg:
    
            - trace points include much runtime information(such as
            running cpu, current task, ...)
    
            - most of linux distributions may disable "verbose debug"
            driver debug compile switch, so it is very difficult to
            report/debug runtime pm related problems from distribution
            users without this kind of debug information.
    
            - for upstream kernel users, enableing the debug switch will
            produce many useless "rpm_resume" output, and it is very noise.
    
            - dev_dbg inside rpm_suspend/rpm_resume may have some effects
            on runtime pm behaviour of console devicer
    
    Signed-off-by: Ming Lei <ming.lei@canonical.com>
    Acked-by: Steven Rostedt <rostedt@goodmis.org>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

commit 53b615ccca567ada1931eb04ad0614ac150c14a3
Author: Ming Lei <ming.lei@canonical.com>
Date:   Tue Sep 27 22:53:27 2011 +0200

    PM / Runtime: Introduce trace points for tracing rpm_* functions
    
    This patch introduces 3 trace points to prepare for tracing
    rpm_idle/rpm_suspend/rpm_resume functions, so we can use these
    trace points to replace the current dev_dbg().
    
    Signed-off-by: Ming Lei <ming.lei@canonical.com>
    Acked-by: Steven Rostedt <rostedt@goodmis.org>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

commit ad3c36a534bc7b945d7bffdda1c62e13bf93489a
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Sep 27 21:54:52 2011 +0200

    PM / Runtime: Don't run callbacks under lock for power.irq_safe set
    
    The rpm_suspend() and rpm_resume() routines execute subsystem or PM
    domain callbacks under power.lock if power.irq_safe is set for the
    given device.  This is inconsistent with that rpm_idle() does after
    commit 02b2677 (PM / Runtime: Allow _put_sync() from
    interrupts-disabled context) and is problematic for subsystems and PM
    domains wanting to use power.lock for synchronization in their
    runtime PM callbacks.
    
    This change requires the code checking if the device's runtime PM
    status is RPM_SUSPENDING or RPM_RESUMING to be modified too, to take
    the power.irq_safe set case into account (that code wasn't reachable
    before with power.irq_safe set, because it's executed with the
    device's power.lock held).
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Reviewed-by: Ming Lei <tom.leiming@gmail.com>
    Reviewed-by: Kevin Hilman <khilman@ti.com>

commit 81fdcbdd2dc212eb5d89b5fa4e1f69b48843d037
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Sat Jun 18 22:42:09 2011 +0200

    PM: Fix async resume following suspend failure
    
    commit 6d0e0e84f66d32c33511984dd3badd32364b863c upstream.
    
    The PM core doesn't handle suspend failures correctly when it comes to
    asynchronously suspended devices.  These devices are moved onto the
    dpm_suspended_list as soon as the corresponding async thread is
    started up, and they remain on the list even if they fail to suspend
    or the sleep transition is cancelled before they get suspended.  As a
    result, when the PM core unwinds the transition, it tries to resume
    the devices even though they were never suspended.
    
    This patch (as1474) fixes the problem by adding a new "is_suspended"
    flag to dev_pm_info.  Devices are resumed only if the flag is set.
    
    [rjw:
     * Moved the dev->power.is_suspended check into device_resume(),
       because we need to complete dev->power.completion and clear
       dev->power.is_prepared too for devices whose
       dev->power.is_suspended flags are unset.
     * Fixed __device_suspend() to avoid setting dev->power.is_suspended
       if async_error is different from zero.]
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit a534bb6eea72c0d082dd2faab85450e5554ba1c8
Author: Tomas Winkler <tomas.winkler@intel.com>
Date:   Mon Jun 13 16:39:31 2011 +0300

    Staging: mei: fix suspend failure
    
    wait_event_interruptible_timeout return value was wrongly used.
    The remaining timeout was used as the error code.
    This fix translated wait_event_interruptible_timeout return value
    into error code that can be propagated.
    
    [10291.674121] pci_pm_suspend(): mei_pci_suspend+0x0/0x8b [mei] returns 2500
    It's thinkpad t400 with
    00:03.0 Communication controller [0780]: Intel Corporation Mobile 4 Series Chipset MEI Controller [8086:2a44] (rev 07)
    
    Reported-by: Arkadiusz Miskiewicz <a.miskiewicz@gmail.com>
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 6d0e0e84f66d32c33511984dd3badd32364b863c
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Sat Jun 18 22:42:09 2011 +0200

    PM: Fix async resume following suspend failure
    
    The PM core doesn't handle suspend failures correctly when it comes to
    asynchronously suspended devices.  These devices are moved onto the
    dpm_suspended_list as soon as the corresponding async thread is
    started up, and they remain on the list even if they fail to suspend
    or the sleep transition is cancelled before they get suspended.  As a
    result, when the PM core unwinds the transition, it tries to resume
    the devices even though they were never suspended.
    
    This patch (as1474) fixes the problem by adding a new "is_suspended"
    flag to dev_pm_info.  Devices are resumed only if the flag is set.
    
    [rjw:
     * Moved the dev->power.is_suspended check into device_resume(),
       because we need to complete dev->power.completion and clear
       dev->power.is_prepared too for devices whose
       dev->power.is_suspended flags are unset.
     * Fixed __device_suspend() to avoid setting dev->power.is_suspended
       if async_error is different from zero.]
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: stable@kernel.org

commit fda5fe19725edd6805f2fd742235d1a0d0ba93f5
Author: Paul Parsons <lost.distance@yahoo.com>
Date:   Fri May 13 02:46:03 2011 +0100

    apm-emulation: apm_mutex breaks ACK; remove it
    
    apm_mutex is locked by a process (e.g. apm -s) at the start of apm_ioctl() and
    remains locked while pm_suspend() is called. Any subsequent process trying to
    ACK the suspend (e.g. apmd) is then blocked at the start of apm_ioctl(),
    causing the suspend to be delayed for 5 seconds in apm_suspend_notifier()
    while the ACK times out. In short, ACKs don't work.
    
    The driver's data structures are sufficiently protected by assorted locks. And
    pm_suspend() has its own mutex to prevent reentrancy. Consequently there is no
    obvious requirement for apm_mutex, which evolved from earlier BKL calls. So
    let's remove it.
    
    Signed-off-by: Paul Parsons <lost.distance@yahoo.com>
    Acked-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

commit 75bd0cbdc21d80859c80bdd5dd00125c1a3ccbca
Author: Ming Lei <tom.leiming@gmail.com>
Date:   Thu Apr 28 22:37:09 2011 +0000

    usbnet: runtime pm: fix out of memory
    
    This patch makes use of the EVENT_DEV_OPEN flag introduced recently to
    fix one out of memory issue, which can be reproduced on omap3/4 based
    pandaboard/beagle XM easily with steps below:
    
            - enable runtime pm
            echo auto > /sys/devices/platform/usbhs-omap.0/ehci-omap.0/usb1/1-1/1-1.1/power/control
    
            - ifconfig eth0 up
    
            - then out of memroy happened, see [1] for kernel message.
    
    Follows my analysis:
            - 'ifconfig eth0 up' brings eth0 out of suspend, and usbnet_resume
            is called to schedule dev->bh, then rx urbs are submited to prepare for
            recieving data;
    
            - some usbnet devices will produce garbage rx packets flood if
            info->reset is not called in usbnet_open.
    
            - so there is no enough chances for usbnet_bh to handle and release
            recieved skb buffers since many rx interrupts consumes cpu, so out of memory
            for atomic allocation in rx_submit happened.
    
    This patch fixes the issue by simply not allowing schedule of usbnet_bh until device
    is opened.
    
    [1], dmesg
    [  234.712005] smsc95xx 1-1.1:1.0: rpm_resume flags 0x4
    [  234.712066] usb 1-1.1: rpm_resume flags 0x0
    [  234.712066] usb 1-1: rpm_resume flags 0x0
    [  234.712097] usb usb1: rpm_resume flags 0x0
    [  234.712127] usb usb1: usb auto-resume
    [  234.712158] ehci-omap ehci-omap.0: resume root hub
    [  234.754028] hub 1-0:1.0: hub_resume
    [  234.754821] hub 1-0:1.0: port 1: status 0507 change 0000
    [  234.756011] hub 1-0:1.0: state 7 ports 3 chg 0000 evt 0000
    [  234.756042] hub 1-0:1.0: rpm_resume flags 0x4
    [  234.756072] usb usb1: rpm_resume flags 0x0
    [  234.756164] usb usb1: rpm_resume returns 1
    [  234.756195] hub 1-0:1.0: rpm_resume returns 0
    [  234.756195] hub 1-0:1.0: rpm_suspend flags 0x4
    [  234.756225] hub 1-0:1.0: rpm_suspend returns 0
    [  234.756256] usb usb1: rpm_resume returns 0
    [  234.757141] usb 1-1: usb auto-resume
    [  234.793151] ehci-omap ehci-omap.0: GetStatus port:1 status 001005 0  ACK POWER sig=se0 PE CONNECT
    [  234.816558] usb 1-1: finish resume
    [  234.817871] hub 1-1:1.0: hub_resume
    [  234.818420] hub 1-1:1.0: port 1: status 0507 change 0000
    [  234.820495] ehci-omap ehci-omap.0: reused qh eec50220 schedule
    [  234.820495] usb 1-1: link qh256-0001/eec50220 start 1 [1/0 us]
    [  234.820587] usb 1-1: rpm_resume returns 0
    [  234.820800] hub 1-1:1.0: state 7 ports 5 chg 0000 evt 0000
    [  234.820800] hub 1-1:1.0: rpm_resume flags 0x4
    [  234.820831] hub 1-1:1.0: rpm_resume returns 0
    [  234.820861] hub 1-1:1.0: rpm_suspend flags 0x4
    [  234.820861] hub 1-1:1.0: rpm_suspend returns 0
    [  234.821777] usb 1-1.1: usb auto-resume
    [  234.868591] hub 1-1:1.0: state 7 ports 5 chg 0000 evt 0002
    [  234.868591] hub 1-1:1.0: rpm_resume flags 0x4
    [  234.868621] hub 1-1:1.0: rpm_resume returns 0
    [  234.868652] hub 1-1:1.0: rpm_suspend flags 0x4
    [  234.868652] hub 1-1:1.0: rpm_suspend returns 0
    [  234.879486] usb 1-1.1: finish resume
    [  234.880279] usb 1-1.1: rpm_resume returns 0
    [  234.880310] smsc95xx 1-1.1:1.0: rpm_resume returns 0
    [  238.880187] ksoftirqd/0: page allocation failure. order:0, mode:0x20
    [  238.880218] Backtrace:
    [  238.880249] [<c01b9800>] (dump_backtrace+0x0/0xf8) from [<c065e1dc>] (dump_stack+0x18/0x1c)
    [  238.880249]  r6:00000000 r5:00000000 r4:00000020 r3:00000002
    [  238.880310] [<c065e1c4>] (dump_stack+0x0/0x1c) from [<c026ece4>] (__alloc_pages_nodemask+0x620/0x724)
    [  238.880340] [<c026e6c4>] (__alloc_pages_nodemask+0x0/0x724) from [<c02986d4>] (kmem_getpages.clone.34+0x34/0xc8)
    [  238.880371] [<c02986a0>] (kmem_getpages.clone.34+0x0/0xc8) from [<c02988f8>] (cache_grow.clone.42+0x84/0x154)
    [  238.880371]  r6:ef871aa4 r5:ef871a80 r4:ef81fd40 r3:00000020
    [  238.880401] [<c0298874>] (cache_grow.clone.42+0x0/0x154) from [<c0298b64>] (cache_alloc_refill+0x19c/0x1f0)
    [  238.880432] [<c02989c8>] (cache_alloc_refill+0x0/0x1f0) from [<c0299804>] (kmem_cache_alloc+0x90/0x190)
    [  238.880462] [<c0299774>] (kmem_cache_alloc+0x0/0x190) from [<c052e260>] (__alloc_skb+0x34/0xe8)
    [  238.880493] [<c052e22c>] (__alloc_skb+0x0/0xe8) from [<bf0509f4>] (rx_submit+0x2c/0x1d4 [usbnet])
    [  238.880523] [<bf0509c8>] (rx_submit+0x0/0x1d4 [usbnet]) from [<bf050d38>] (rx_complete+0x19c/0x1b0 [usbnet])
    [  238.880737] [<bf050b9c>] (rx_complete+0x0/0x1b0 [usbnet]) from [<bf006fd0>] (usb_hcd_giveback_urb+0xa8/0xf4 [usbcore])
    [  238.880737]  r8:eeeced34 r7:eeecec00 r6:eeecec00 r5:00000000 r4:eec2dd20
    [  238.880767] r3:bf050b9c
    [  238.880859] [<bf006f28>] (usb_hcd_giveback_urb+0x0/0xf4 [usbcore]) from [<bf03c8f8>] (ehci_urb_done+0xb0/0xbc [ehci_hcd])
    [  238.880859]  r6:00000000 r5:eec2dd20 r4:eeeced44 r3:eec2dd34
    [  238.880920] [<bf03c848>] (ehci_urb_done+0x0/0xbc [ehci_hcd]) from [<bf040204>] (qh_completions+0x308/0x3bc [ehci_hcd])
    [  238.880920]  r7:00000000 r6:eeda21a0 r5:ffdfe3c0 r4:eeda21ac
    [  238.880981] [<bf03fefc>] (qh_completions+0x0/0x3bc [ehci_hcd]) from [<bf040ef8>] (scan_async+0xb0/0x16c [ehci_hcd])
    [  238.881011] [<bf040e48>] (scan_async+0x0/0x16c [ehci_hcd]) from [<bf040fec>] (ehci_work+0x38/0x90 [ehci_hcd])
    [  238.881042] [<bf040fb4>] (ehci_work+0x0/0x90 [ehci_hcd]) from [<bf042940>] (ehci_irq+0x300/0x34c [ehci_hcd])
    [  238.881072]  r4:eeeced34 r3:00000001
    [  238.881134] [<bf042640>] (ehci_irq+0x0/0x34c [ehci_hcd]) from [<bf006828>] (usb_hcd_irq+0x40/0xac [usbcore])
    [  238.881195] [<bf0067e8>] (usb_hcd_irq+0x0/0xac [usbcore]) from [<c0239764>] (handle_irq_event_percpu+0xb8/0x240)
    [  238.881225]  r6:eec504e0 r5:0000006d r4:eec504e0 r3:bf0067e8
    [  238.881256] [<c02396ac>] (handle_irq_event_percpu+0x0/0x240) from [<c0239930>] (handle_irq_event+0x44/0x64)
    [  238.881256] [<c02398ec>] (handle_irq_event+0x0/0x64) from [<c023bbd0>] (handle_level_irq+0xe0/0x114)
    [  238.881286]  r6:0000006d r5:c080c14c r4:c080c100 r3:00020000
    [  238.881317] [<c023baf0>] (handle_level_irq+0x0/0x114) from [<c01ab090>] (asm_do_IRQ+0x90/0xd0)
    [  238.881317]  r5:00000000 r4:0000006d
    [  238.881347] [<c01ab000>] (asm_do_IRQ+0x0/0xd0) from [<c06624d0>] (__irq_svc+0x50/0x134)
    [  238.881378] Exception stack(0xef837e20 to 0xef837e68)
    [  238.881378] 7e20: 00000001 00185610 016cc000 c00490c0 eb380000 ef800540 00000020 00004ae0
    [  238.881408] 7e40: 00000020 bf0509f4 60000013 ef837e9c ef837e40 ef837e68 c0226f0c c0298ca0
    [  238.881408] 7e60: 20000013 ffffffff
    [  238.881408]  r5:fa240100 r4:ffffffff
    [  238.881439] [<c0298bb8>] (__kmalloc_track_caller+0x0/0x1d0) from [<c052e284>] (__alloc_skb+0x58/0xe8)
    [  238.881469] [<c052e22c>] (__alloc_skb+0x0/0xe8) from [<bf0509f4>] (rx_submit+0x2c/0x1d4 [usbnet])
    [  238.881500] [<bf0509c8>] (rx_submit+0x0/0x1d4 [usbnet]) from [<bf0513d8>] (usbnet_bh+0x1b4/0x250 [usbnet])
    [  238.881530] [<bf051224>] (usbnet_bh+0x0/0x250 [usbnet]) from [<c01f912c>] (tasklet_action+0xb0/0x1f8)
    [  238.881530]  r6:00000000 r5:ef9757f0 r4:ef9757ec r3:bf051224
    [  238.881561] [<c01f907c>] (tasklet_action+0x0/0x1f8) from [<c01f97ac>] (__do_softirq+0x140/0x290)
    [  238.881561]  r8:00000006 r7:00000101 r6:00000000 r5:c0806098 r4:00000001
    [  238.881591] r3:c01f907c
    [  238.881622] [<c01f966c>] (__do_softirq+0x0/0x290) from [<c01f99cc>] (run_ksoftirqd+0xd0/0x1f4)
    [  238.881622] [<c01f98fc>] (run_ksoftirqd+0x0/0x1f4) from [<c02113b0>] (kthread+0x90/0x98)
    [  238.881652]  r7:00000013 r6:c01f98fc r5:00000000 r4:ef831efc
    [  238.881683] [<c0211320>] (kthread+0x0/0x98) from [<c01f62f4>] (do_exit+0x0/0x374)
    [  238.881713]  r6:c01f62f4 r5:c0211320 r4:ef831efc
    [  238.881713] Mem-info:
    [  238.881744] Normal per-cpu:
    [  238.881744] CPU    0: hi:  186, btch:  31 usd:  38
    [  238.881744] CPU    1: hi:  186, btch:  31 usd: 169
    [  238.881774] HighMem per-cpu:
    [  238.881774] CPU    0: hi:   90, btch:  15 usd:  66
    [  238.881774] CPU    1: hi:   90, btch:  15 usd:  86
    [  238.881805] active_anon:544 inactive_anon:71 isolated_anon:0
    [  238.881805]  active_file:926 inactive_file:2538 isolated_file:0
    [  238.881805]  unevictable:0 dirty:10 writeback:0 unstable:0
    [  238.881805]  free:57782 slab_reclaimable:864 slab_unreclaimable:186898
    [  238.881805]  mapped:632 shmem:144 pagetables:50 bounce:0
    [  238.881835] Normal free:1328kB min:3532kB low:4412kB high:5296kB active_anon:0kB inactive_anon:0kB active_file:880kB inactive_file:848kB unevictable:0kB isolated(anon):0kB isolated(file):0kB present:780288kB mlocked:0kB dirty:36kB writeback:0kB mapped:0kB shmem:0kB slab_reclaimable:3456kB slab_unreclaimable:747592kB kernel_stack:392kB pagetables:200kB unstable:0kB bounce:0kB writeback_tmp:0kB pages_scanned:0 all_unreclaimable? no
    [  238.881866] lowmem_reserve[]: 0 1904 1904
    [  238.881896] HighMem free:229800kB min:236kB low:508kB high:784kB active_anon:2176kB inactive_anon:284kB active_file:2824kB inactive_file:9304kB unevictable:0kB isolated(anon):0kB isolated(file):0kB present:243712kB mlocked:0kB dirty:4kB writeback:0kB mapped:2528kB shmem:576kB slab_reclaimable:0kB slab_unreclaimable:0kB kernel_stack:0kB pagetables:0kB unstable:0kB bounce:0kB writeback_tmp:0kB pages_scanned:0 all_unreclaimable? no
    [  238.881927] lowmem_reserve[]: 0 0 0
    [  238.881958] Normal: 0*4kB 4*8kB 6*16kB 0*32kB 1*64kB 1*128kB 0*256kB 2*512kB 0*1024kB 0*2048kB 0*4096kB = 1344kB
    [  238.882019] HighMem: 6*4kB 2*8kB 4*16kB 4*32kB 1*64kB 1*128kB 0*256kB 2*512kB 3*1024kB 0*2048kB 55*4096kB = 229800kB
    [  238.882080] 3610 total pagecache pages
    [  238.882080] 0 pages in swap cache
    [  238.882080] Swap cache stats: add 0, delete 0, find 0/0
    [  238.882110] Free swap  = 0kB
    [  238.882110] Total swap = 0kB
    [  238.933776] 262144 pages of RAM
    [  238.933776] 58240 free pages
    [  238.933776] 10503 reserved pages
    [  238.933776] 187773 slab pages
    [  238.933807] 2475 pages shared
    [  238.933807] 0 pages swap cached
    
    Signed-off-by: Ming Lei <tom.leiming@gmail.com>
    Acked-by: Oliver Neukum <oneukum@suse.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit b3e96c0c756211e805c6941d4a6e5f6e1995cb6b
Author: Shriram Rajagopalan <rshriram@cs.ubc.ca>
Date:   Tue Feb 22 14:59:06 2011 -0800

    xen: use freeze/restore/thaw PM events for suspend/resume/chkpt
    
    Use PM_FREEZE, PM_THAW and PM_RESTORE power events for
    suspend/resume/checkpoint functionality, instead of PM_SUSPEND
    and PM_RESUME. Use of these pm events fixes the Xen Guest hangup
    when taking checkpoints. When a suspend event is cancelled
    (while taking checkpoints once/continuously), we use PM_THAW
    instead of PM_RESUME. PM_RESTORE is used when suspend is not
    cancelled. See Documentation/power/devices.txt and linux/pm.h
    for more info about freeze, thaw and restore. The sequence of
    pm events in a suspend-resume scenario is shown below.
    
            dpm_suspend_start(PMSG_FREEZE);
    
                    dpm_suspend_noirq(PMSG_FREEZE);
    
                           sysdev_suspend(PMSG_FREEZE);
                           cancelled = suspend_hypercall()
                           sysdev_resume();
    
                   dpm_resume_noirq(cancelled ? PMSG_THAW : PMSG_RESTORE);
    
           dpm_resume_end(cancelled ? PMSG_THAW : PMSG_RESTORE);
    
    Acked-by: Ian Campbell <ian.campbell@citrix.com>
    Signed-off-by: Shriram Rajagopalan <rshriram@cs.ubc.ca>
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>

commit 3e3742bc3d042533355fdc13dcec17deb5b584fa
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue Jan 25 20:50:07 2011 +0100

    PM / Runtime: Don't enable interrupts while running in_interrupt
    
    commit c3810c88788d505d4ffd786addd111b745e42161 upstream.
    
    This patch (as1445) fixes a bug in the runtime PM core left over from
    the addition of the no_callbacks flag.  If this flag is set then it is
    possible for rpm_suspend() to be called in_interrupt, so when
    releasing spinlocks it's important not to re-enable interrupts.
    
    To avoid an unnecessary save-and-restore of the interrupt flag, the
    patch also inlines a pm_request_idle() call.
    
    This fixes Bugzilla #27482.
    
    (The offending code was added in 2.6.37, so it's not necessary to apply
    this to any earlier stable kernels.)
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Reported-by: tim blechmann <tim@klingt.org>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit f67b9afe61d12e770b44944dfbb96cd74d8da024
Author: Yin Kangkai <kangkai.yin@intel.com>
Date:   Fri Jan 28 12:04:35 2011 +0800

    USB: EHCI: fix scheduling while atomic during suspend
    
    commit 148fc55fd0449683a1d15bf219ad8d8b6fa17545 upstream.
    
    There is a msleep with spin lock held during ehci pci suspend, which will
    cause kernel BUG: scheduling while atomic. Fix that.
    
    [  184.139620] BUG: scheduling while atomic: kworker/u:11/416/0x00000002
    [  184.139632] 4 locks held by kworker/u:11/416:
    [  184.139640]  #0:  (events_unbound){+.+.+.}, at: [<c104ddd4>] process_one_work+0x1b3/0x4cb
    [  184.139669]  #1:  ((&entry->work)){+.+.+.}, at: [<c104ddd4>] process_one_work+0x1b3/0x4cb
    [  184.139686]  #2:  (&__lockdep_no_validate__){+.+.+.}, at: [<c127cde3>] __device_suspend+0x2c/0x154
    [  184.139706]  #3:  (&(&ehci->lock)->rlock){-.-...}, at: [<c132f3d8>] ehci_pci_suspend+0x35/0x7b
    [  184.139725] Modules linked in: serio_raw pegasus joydev mrst_gfx(C) battery
    [  184.139748] irq event stamp: 52
    [  184.139753] hardirqs last  enabled at (51): [<c14fdaac>] mutex_lock_nested+0x258/0x293
    [  184.139766] hardirqs last disabled at (52): [<c14fe7b4>] _raw_spin_lock_irqsave+0xf/0x3e
    [  184.139777] softirqs last  enabled at (0): [<c10371c1>] copy_process+0x3d2/0x109d
    [  184.139789] softirqs last disabled at (0): [<  (null)>]   (null)
    [  184.139802] Pid: 416, comm: kworker/u:11 Tainted: G         C  2.6.37-6.3-adaptation-oaktrail #37
    [  184.139809] Call Trace:
    [  184.139820]  [<c102eeff>] __schedule_bug+0x5e/0x65
    [  184.139829]  [<c14fbca5>] schedule+0xac/0xc4c
    [  184.139840]  [<c11d4845>] ? string+0x37/0x8b
    [  184.139853]  [<c1044f21>] ? lock_timer_base+0x1f/0x3e
    [  184.139863]  [<c14fe7da>] ? _raw_spin_lock_irqsave+0x35/0x3e
    [  184.139876]  [<c1061590>] ? trace_hardirqs_off+0xb/0xd
    [  184.139885]  [<c14fccdc>] schedule_timeout+0x283/0x2d9
    [  184.139896]  [<c104516f>] ? process_timeout+0x0/0xa
    [  184.139906]  [<c14fcd47>] schedule_timeout_uninterruptible+0x15/0x17
    [  184.139916]  [<c104566a>] msleep+0x10/0x16
    [  184.139926]  [<c132f316>] ehci_adjust_port_wakeup_flags+0x69/0xf6
    [  184.139937]  [<c132f3eb>] ehci_pci_suspend+0x48/0x7b
    [  184.139946]  [<c1326587>] suspend_common+0x52/0xbb
    [  184.139956]  [<c1326625>] hcd_pci_suspend+0x26/0x28
    [  184.139967]  [<c11e7182>] pci_pm_suspend+0x5f/0xd0
    [  184.139976]  [<c127ca3a>] pm_op+0x5d/0xf0
    [  184.139986]  [<c127ceac>] __device_suspend+0xf5/0x154
    [  184.139996]  [<c127d2c8>] async_suspend+0x16/0x3a
    [  184.140006]  [<c1058f54>] async_run_entry_fn+0x89/0x111
    [  184.140016]  [<c104deb6>] process_one_work+0x295/0x4cb
    [  184.140026]  [<c1058ecb>] ? async_run_entry_fn+0x0/0x111
    [  184.140036]  [<c104e3d0>] worker_thread+0x17f/0x298
    [  184.140045]  [<c104e251>] ? worker_thread+0x0/0x298
    [  184.140055]  [<c105277f>] kthread+0x64/0x69
    [  184.140064]  [<c105271b>] ? kthread+0x0/0x69
    [  184.140075]  [<c1002efa>] kernel_thread_helper+0x6/0x1a
    
    Signed-off-by: Yin Kangkai <kangkai.yin@intel.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    CC: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 8a7dfbe3f7930c25c16f54b5d638350d03594f2f
Author: Yin Kangkai <kangkai.yin@intel.com>
Date:   Fri Jan 28 12:04:35 2011 +0800

    USB: EHCI: fix scheduling while atomic during suspend
    
    commit 148fc55fd0449683a1d15bf219ad8d8b6fa17545 upstream.
    
    There is a msleep with spin lock held during ehci pci suspend, which will
    cause kernel BUG: scheduling while atomic. Fix that.
    
    [  184.139620] BUG: scheduling while atomic: kworker/u:11/416/0x00000002
    [  184.139632] 4 locks held by kworker/u:11/416:
    [  184.139640]  #0:  (events_unbound){+.+.+.}, at: [<c104ddd4>] process_one_work+0x1b3/0x4cb
    [  184.139669]  #1:  ((&entry->work)){+.+.+.}, at: [<c104ddd4>] process_one_work+0x1b3/0x4cb
    [  184.139686]  #2:  (&__lockdep_no_validate__){+.+.+.}, at: [<c127cde3>] __device_suspend+0x2c/0x154
    [  184.139706]  #3:  (&(&ehci->lock)->rlock){-.-...}, at: [<c132f3d8>] ehci_pci_suspend+0x35/0x7b
    [  184.139725] Modules linked in: serio_raw pegasus joydev mrst_gfx(C) battery
    [  184.139748] irq event stamp: 52
    [  184.139753] hardirqs last  enabled at (51): [<c14fdaac>] mutex_lock_nested+0x258/0x293
    [  184.139766] hardirqs last disabled at (52): [<c14fe7b4>] _raw_spin_lock_irqsave+0xf/0x3e
    [  184.139777] softirqs last  enabled at (0): [<c10371c1>] copy_process+0x3d2/0x109d
    [  184.139789] softirqs last disabled at (0): [<  (null)>]   (null)
    [  184.139802] Pid: 416, comm: kworker/u:11 Tainted: G         C  2.6.37-6.3-adaptation-oaktrail #37
    [  184.139809] Call Trace:
    [  184.139820]  [<c102eeff>] __schedule_bug+0x5e/0x65
    [  184.139829]  [<c14fbca5>] schedule+0xac/0xc4c
    [  184.139840]  [<c11d4845>] ? string+0x37/0x8b
    [  184.139853]  [<c1044f21>] ? lock_timer_base+0x1f/0x3e
    [  184.139863]  [<c14fe7da>] ? _raw_spin_lock_irqsave+0x35/0x3e
    [  184.139876]  [<c1061590>] ? trace_hardirqs_off+0xb/0xd
    [  184.139885]  [<c14fccdc>] schedule_timeout+0x283/0x2d9
    [  184.139896]  [<c104516f>] ? process_timeout+0x0/0xa
    [  184.139906]  [<c14fcd47>] schedule_timeout_uninterruptible+0x15/0x17
    [  184.139916]  [<c104566a>] msleep+0x10/0x16
    [  184.139926]  [<c132f316>] ehci_adjust_port_wakeup_flags+0x69/0xf6
    [  184.139937]  [<c132f3eb>] ehci_pci_suspend+0x48/0x7b
    [  184.139946]  [<c1326587>] suspend_common+0x52/0xbb
    [  184.139956]  [<c1326625>] hcd_pci_suspend+0x26/0x28
    [  184.139967]  [<c11e7182>] pci_pm_suspend+0x5f/0xd0
    [  184.139976]  [<c127ca3a>] pm_op+0x5d/0xf0
    [  184.139986]  [<c127ceac>] __device_suspend+0xf5/0x154
    [  184.139996]  [<c127d2c8>] async_suspend+0x16/0x3a
    [  184.140006]  [<c1058f54>] async_run_entry_fn+0x89/0x111
    [  184.140016]  [<c104deb6>] process_one_work+0x295/0x4cb
    [  184.140026]  [<c1058ecb>] ? async_run_entry_fn+0x0/0x111
    [  184.140036]  [<c104e3d0>] worker_thread+0x17f/0x298
    [  184.140045]  [<c104e251>] ? worker_thread+0x0/0x298
    [  184.140055]  [<c105277f>] kthread+0x64/0x69
    [  184.140064]  [<c105271b>] ? kthread+0x0/0x69
    [  184.140075]  [<c1002efa>] kernel_thread_helper+0x6/0x1a
    
    Signed-off-by: Yin Kangkai <kangkai.yin@intel.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    CC: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 148fc55fd0449683a1d15bf219ad8d8b6fa17545
Author: Yin Kangkai <kangkai.yin@intel.com>
Date:   Fri Jan 28 12:04:35 2011 +0800

    USB: EHCI: fix scheduling while atomic during suspend
    
    There is a msleep with spin lock held during ehci pci suspend, which will
    cause kernel BUG: scheduling while atomic. Fix that.
    
    [  184.139620] BUG: scheduling while atomic: kworker/u:11/416/0x00000002
    [  184.139632] 4 locks held by kworker/u:11/416:
    [  184.139640]  #0:  (events_unbound){+.+.+.}, at: [<c104ddd4>] process_one_work+0x1b3/0x4cb
    [  184.139669]  #1:  ((&entry->work)){+.+.+.}, at: [<c104ddd4>] process_one_work+0x1b3/0x4cb
    [  184.139686]  #2:  (&__lockdep_no_validate__){+.+.+.}, at: [<c127cde3>] __device_suspend+0x2c/0x154
    [  184.139706]  #3:  (&(&ehci->lock)->rlock){-.-...}, at: [<c132f3d8>] ehci_pci_suspend+0x35/0x7b
    [  184.139725] Modules linked in: serio_raw pegasus joydev mrst_gfx(C) battery
    [  184.139748] irq event stamp: 52
    [  184.139753] hardirqs last  enabled at (51): [<c14fdaac>] mutex_lock_nested+0x258/0x293
    [  184.139766] hardirqs last disabled at (52): [<c14fe7b4>] _raw_spin_lock_irqsave+0xf/0x3e
    [  184.139777] softirqs last  enabled at (0): [<c10371c1>] copy_process+0x3d2/0x109d
    [  184.139789] softirqs last disabled at (0): [<  (null)>]   (null)
    [  184.139802] Pid: 416, comm: kworker/u:11 Tainted: G         C  2.6.37-6.3-adaptation-oaktrail #37
    [  184.139809] Call Trace:
    [  184.139820]  [<c102eeff>] __schedule_bug+0x5e/0x65
    [  184.139829]  [<c14fbca5>] schedule+0xac/0xc4c
    [  184.139840]  [<c11d4845>] ? string+0x37/0x8b
    [  184.139853]  [<c1044f21>] ? lock_timer_base+0x1f/0x3e
    [  184.139863]  [<c14fe7da>] ? _raw_spin_lock_irqsave+0x35/0x3e
    [  184.139876]  [<c1061590>] ? trace_hardirqs_off+0xb/0xd
    [  184.139885]  [<c14fccdc>] schedule_timeout+0x283/0x2d9
    [  184.139896]  [<c104516f>] ? process_timeout+0x0/0xa
    [  184.139906]  [<c14fcd47>] schedule_timeout_uninterruptible+0x15/0x17
    [  184.139916]  [<c104566a>] msleep+0x10/0x16
    [  184.139926]  [<c132f316>] ehci_adjust_port_wakeup_flags+0x69/0xf6
    [  184.139937]  [<c132f3eb>] ehci_pci_suspend+0x48/0x7b
    [  184.139946]  [<c1326587>] suspend_common+0x52/0xbb
    [  184.139956]  [<c1326625>] hcd_pci_suspend+0x26/0x28
    [  184.139967]  [<c11e7182>] pci_pm_suspend+0x5f/0xd0
    [  184.139976]  [<c127ca3a>] pm_op+0x5d/0xf0
    [  184.139986]  [<c127ceac>] __device_suspend+0xf5/0x154
    [  184.139996]  [<c127d2c8>] async_suspend+0x16/0x3a
    [  184.140006]  [<c1058f54>] async_run_entry_fn+0x89/0x111
    [  184.140016]  [<c104deb6>] process_one_work+0x295/0x4cb
    [  184.140026]  [<c1058ecb>] ? async_run_entry_fn+0x0/0x111
    [  184.140036]  [<c104e3d0>] worker_thread+0x17f/0x298
    [  184.140045]  [<c104e251>] ? worker_thread+0x0/0x298
    [  184.140055]  [<c105277f>] kthread+0x64/0x69
    [  184.140064]  [<c105271b>] ? kthread+0x0/0x69
    [  184.140075]  [<c1002efa>] kernel_thread_helper+0x6/0x1a
    
    Signed-off-by: Yin Kangkai <kangkai.yin@intel.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    CC: David Brownell <dbrownell@users.sourceforge.net>
    CC: stable@kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit c3810c88788d505d4ffd786addd111b745e42161
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue Jan 25 20:50:07 2011 +0100

    PM / Runtime: Don't enable interrupts while running in_interrupt
    
    This patch (as1445) fixes a bug in the runtime PM core left over from
    the addition of the no_callbacks flag.  If this flag is set then it is
    possible for rpm_suspend() to be called in_interrupt, so when
    releasing spinlocks it's important not to re-enable interrupts.
    
    To avoid an unnecessary save-and-restore of the interrupt flag, the
    patch also inlines a pm_request_idle() call.
    
    This fixes Bugzilla #27482.
    
    (The offending code was added in 2.6.37, so it's not necessary to apply
    this to any earlier stable kernels.)
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Reported-by: tim blechmann <tim@klingt.org>
    CC: <stable@kernel.org>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

commit 63cb57e4d31311bf80639d07ba006d39651304bb
Author: Ohad Ben-Cohen <ohad@wizery.com>
Date:   Wed Oct 13 09:31:56 2010 +0200

    mmc: sdio: fix SDIO suspend/resume regression
    
    commit 1c8cf9c997a4a6b36e907c7ede5f048aeaab1644 upstream.
    
    Fix SDIO suspend/resume regression introduced by 4c2ef25fe0b "mmc: fix
    all hangs related to mmc/sd card insert/removal during suspend/resume":
    
      PM: Syncing filesystems ... done.
      Freezing user space processes ... (elapsed 0.01 seconds) done.
      Freezing remaining freezable tasks ... (elapsed 0.01 seconds) done.
      Suspending console(s) (use no_console_suspend to debug)
      pm_op(): platform_pm_suspend+0x0/0x5c returns -38
      PM: Device pxa2xx-mci.0 failed to suspend: error -38
      PM: Some devices failed to suspend
    
    4c2ef25fe0b moved the card removal/insertion mechanism out of MMC's
    suspend/resume path and into pm notifiers (mmc_pm_notify), and that
    broke SDIO's expectation that mmc_suspend_host() will remove the card,
    and squash the error, in case -ENOSYS is returned from the bus suspend
    handler (mmc_sdio_suspend() in this case).
    
    mmc_sdio_suspend() is using this whenever at least one of the card's SDIO
    function drivers does not have suspend/resume handlers - in that case
    it is agreed to force removal of the entire card.
    
    This patch fixes this regression by trivially bringing back that part of
    mmc_suspend_host(), which was removed by 4c2ef25fe0b.
    
    Reported-and-tested-by: Sven Neumann <s.neumann@raumfeld.com>
    Signed-off-by: Ohad Ben-Cohen <ohad@wizery.com>
    Cc: Maxim Levitsky <maximlevitsky@gmail.com>
    Acked-by: Nicolas Pitre <nico@fluxnic.net>
    Signed-off-by: Chris Ball <cjb@laptop.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit a8fe1500986c32b46b36118aa250f6badca11bfc
Merge: 94ebd235c493 f0d3d9894e43
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Oct 21 12:41:19 2010 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jmorris/security-testing-2.6
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jmorris/security-testing-2.6: (26 commits)
      selinux: include vmalloc.h for vmalloc_user
      secmark: fix config problem when CONFIG_NF_CONNTRACK_SECMARK is not set
      selinux: implement mmap on /selinux/policy
      SELinux: allow userspace to read policy back out of the kernel
      SELinux: drop useless (and incorrect) AVTAB_MAX_SIZE
      SELinux: deterministic ordering of range transition rules
      kernel: roundup should only reference arguments once
      kernel: rounddown helper function
      secmark: export secctx, drop secmark in procfs
      conntrack: export lsm context rather than internal secid via netlink
      security: secid_to_secctx returns len when data is NULL
      secmark: make secmark object handling generic
      secmark: do not return early if there was no error
      AppArmor: Ensure the size of the copy is < the buffer allocated to hold it
      TOMOYO: Print URL information before panic().
      security: remove unused parameter from security_task_setscheduler()
      tpm: change 'tpm_suspend_pcr' to be module parameter
      selinux: fix up style problem on /selinux/status
      selinux: change to new flag variable
      selinux: really fix dependency causing parallel compile failure.
      ...

commit 9b3056cca09529d34af2d81305b2a9c6b622ca1b
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Fri Oct 1 14:16:39 2010 -0700

    tpm: change 'tpm_suspend_pcr' to be module parameter
    
    Fix the following warning:
    
    drivers/char/tpm/tpm.c:1085: warning: `tpm_suspend_setup' defined but not used
    
    and make the workaround operable in case when TPM is compiled as a module.
    As a side-effect the option will be called tpm.suspend_pcr.
    
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>
    Cc: Rajiv Andrade <srajiv@linux.vnet.ibm.com>
    Cc: David Safford <safford@watson.ibm.com>
    Cc: James Morris <jmorris@namei.org>
    Cc: Debora Velarde <debora@linux.vnet.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: James Morris <jmorris@namei.org>

commit 363129ea90e0835b8552b797714cd200f674e287
Author: Mike Frysinger <vapier@gentoo.org>
Date:   Sat Oct 16 13:24:52 2010 -0400

    ALSA: fix unused warnings with snd_power_get_state
    
    If we compile the ASoC code with PM disabled, we hit stuff like:
    sound/soc/soc-dapm.c: In function 'snd_soc_dapm_suspend_check':
    sound/soc/soc-dapm.c:440: warning: unused variable 'codec'
    
    So tweak the stub macro to avoid these issues.
    
    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

commit 71c63122c4609a917f14a79c32067a68909fc487
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Oct 4 22:08:01 2010 +0200

    PM / Runtime: Reduce code duplication in core helper functions
    
    Reduce code duplication in rpm_idle(), rpm_suspend() and rpm_resume()
    by using local pointers to store callback addresses and moving some
    duplicated code into a separate function.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Reviewed-by: Alan Stern <stern@rowland.harvard.edu>

commit 140a6c945211ee911dec776fafa52e03a7d7bb9a
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Sat Sep 25 23:35:07 2010 +0200

    PM / Runtime: Combine runtime PM entry points
    
    This patch (as1424) combines the various public entry points for the
    runtime PM routines into three simple functions: one for idle, one for
    suspend, and one for resume.  A new bitflag specifies whether or not
    to increment or decrement the usage_count field.
    
    The new entry points are named __pm_runtime_idle,
    __pm_runtime_suspend, and __pm_runtime_resume, to reflect that they
    are trampolines.  Simultaneously, the corresponding internal routines
    are renamed to rpm_idle, rpm_suspend, and rpm_resume.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

commit 1c8cf9c997a4a6b36e907c7ede5f048aeaab1644
Author: Ohad Ben-Cohen <ohad@wizery.com>
Date:   Wed Oct 13 09:31:56 2010 +0200

    mmc: sdio: fix SDIO suspend/resume regression
    
    Fix SDIO suspend/resume regression introduced by 4c2ef25fe0b "mmc: fix
    all hangs related to mmc/sd card insert/removal during suspend/resume":
    
      PM: Syncing filesystems ... done.
      Freezing user space processes ... (elapsed 0.01 seconds) done.
      Freezing remaining freezable tasks ... (elapsed 0.01 seconds) done.
      Suspending console(s) (use no_console_suspend to debug)
      pm_op(): platform_pm_suspend+0x0/0x5c returns -38
      PM: Device pxa2xx-mci.0 failed to suspend: error -38
      PM: Some devices failed to suspend
    
    4c2ef25fe0b moved the card removal/insertion mechanism out of MMC's
    suspend/resume path and into pm notifiers (mmc_pm_notify), and that
    broke SDIO's expectation that mmc_suspend_host() will remove the card,
    and squash the error, in case -ENOSYS is returned from the bus suspend
    handler (mmc_sdio_suspend() in this case).
    
    mmc_sdio_suspend() is using this whenever at least one of the card's SDIO
    function drivers does not have suspend/resume handlers - in that case
    it is agreed to force removal of the entire card.
    
    This patch fixes this regression by trivially bringing back that part of
    mmc_suspend_host(), which was removed by 4c2ef25fe0b.
    
    Reported-and-tested-by: Sven Neumann <s.neumann@raumfeld.com>
    Signed-off-by: Ohad Ben-Cohen <ohad@wizery.com>
    Cc: Maxim Levitsky <maximlevitsky@gmail.com>
    Cc: <stable@kernel.org>
    Acked-by: Nicolas Pitre <nico@fluxnic.net>
    Signed-off-by: Chris Ball <cjb@laptop.org>

commit 753419f59e10d7181e43f0b9cc5beff43ef3f7a4
Author: Vishwanath BS <vishwanath.bs@ti.com>
Date:   Thu Sep 30 14:14:22 2010 +0200

    i2c: Fix for suspend/resume issue
    
    In current i2c core driver, call to pm_runtime_set_active from
    i2c_device_pm_resume will unconditionally enable i2c module and
    increment child count of the parent. Because of this, in CPU Idle
    path, i2c does not idle, preventing Core to enter retention. Also i2c
    module will not be suspended upon system suspend as
    pm_runtime_set_suspended is not called from i2c_device_pm_suspend.
    
    This issue is fixed by removing pm_runtime_set_active call from resume
    path which is not necessary.
    This fix has been tested on OMAP4430.
    
    Signed-off-by: Partha Basak <p-basak2@ti.com>
    Signed-off-by: Vishwanath BS <vishwanath.bs@ti.com>
    Acked-by: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Kevin Hilman <khilman@deeprootsystems.com>
    Cc: Ben Dooks <ben-linux@fluff.org>
    Signed-off-by: Jean Delvare <khali@linux-fr.org>

commit 925a7e4a56ab113a1703caf76be0311f70d53b89
Author: Ian Campbell <ian.campbell@citrix.com>
Date:   Thu Jul 29 11:16:35 2010 +0100

    xen: Do not suspend IPI IRQs.
    
    commit 4877c737283813bdb4bebfa3168c1585f6e3a8ca upstream.
    
    In general the semantics of IPIs are that they are are expected to
    continue functioning after dpm_suspend_noirq().
    
    Specifically I have seen a deadlock between the callfunc IPI and the
    stop machine used by xen's do_suspend() routine. If one CPU has already
    called dpm_suspend_noirq() then there is a window where it can be sent
    a callfunc IPI before all the other CPUs have entered stop_cpu().
    
    If this happens then the first CPU ends up spinning in stop_cpu()
    waiting for the other to rendezvous in state STOPMACHINE_PREPARE while
    the other is spinning in csd_lock_wait().
    
    Signed-off-by: Ian Campbell <ian.campbell@citrix.com>
    Cc: Jeremy Fitzhardinge <jeremy@goop.org>
    Cc: xen-devel@lists.xensource.com
    LKML-Reference: <1280398595-29708-4-git-send-email-ian.campbell@citrix.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit fccf1002f4767104ed75422d9e34f21e4a29661f
Author: Ian Campbell <ian.campbell@citrix.com>
Date:   Thu Jul 29 11:16:35 2010 +0100

    xen: Do not suspend IPI IRQs.
    
    commit 4877c737283813bdb4bebfa3168c1585f6e3a8ca upstream.
    
    In general the semantics of IPIs are that they are are expected to
    continue functioning after dpm_suspend_noirq().
    
    Specifically I have seen a deadlock between the callfunc IPI and the
    stop machine used by xen's do_suspend() routine. If one CPU has already
    called dpm_suspend_noirq() then there is a window where it can be sent
    a callfunc IPI before all the other CPUs have entered stop_cpu().
    
    If this happens then the first CPU ends up spinning in stop_cpu()
    waiting for the other to rendezvous in state STOPMACHINE_PREPARE while
    the other is spinning in csd_lock_wait().
    
    Signed-off-by: Ian Campbell <ian.campbell@citrix.com>
    Cc: Jeremy Fitzhardinge <jeremy@goop.org>
    Cc: xen-devel@lists.xensource.com
    LKML-Reference: <1280398595-29708-4-git-send-email-ian.campbell@citrix.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 7d9deb060ffb6c6b38414210f1f2589c524ad1d6
Author: Ian Campbell <ian.campbell@citrix.com>
Date:   Thu Jul 29 11:16:35 2010 +0100

    xen: Do not suspend IPI IRQs.
    
    commit 4877c737283813bdb4bebfa3168c1585f6e3a8ca upstream.
    
    In general the semantics of IPIs are that they are are expected to
    continue functioning after dpm_suspend_noirq().
    
    Specifically I have seen a deadlock between the callfunc IPI and the
    stop machine used by xen's do_suspend() routine. If one CPU has already
    called dpm_suspend_noirq() then there is a window where it can be sent
    a callfunc IPI before all the other CPUs have entered stop_cpu().
    
    If this happens then the first CPU ends up spinning in stop_cpu()
    waiting for the other to rendezvous in state STOPMACHINE_PREPARE while
    the other is spinning in csd_lock_wait().
    
    Signed-off-by: Ian Campbell <ian.campbell@citrix.com>
    Cc: Jeremy Fitzhardinge <jeremy@goop.org>
    Cc: xen-devel@lists.xensource.com
    LKML-Reference: <1280398595-29708-4-git-send-email-ian.campbell@citrix.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 4877c737283813bdb4bebfa3168c1585f6e3a8ca
Author: Ian Campbell <ian.campbell@citrix.com>
Date:   Thu Jul 29 11:16:35 2010 +0100

    xen: Do not suspend IPI IRQs.
    
    In general the semantics of IPIs are that they are are expected to
    continue functioning after dpm_suspend_noirq().
    
    Specifically I have seen a deadlock between the callfunc IPI and the
    stop machine used by xen's do_suspend() routine. If one CPU has already
    called dpm_suspend_noirq() then there is a window where it can be sent
    a callfunc IPI before all the other CPUs have entered stop_cpu().
    
    If this happens then the first CPU ends up spinning in stop_cpu()
    waiting for the other to rendezvous in state STOPMACHINE_PREPARE while
    the other is spinning in csd_lock_wait().
    
    Signed-off-by: Ian Campbell <ian.campbell@citrix.com>
    Cc: Jeremy Fitzhardinge <jeremy@goop.org>
    Cc: xen-devel@lists.xensource.com
    LKML-Reference: <1280398595-29708-4-git-send-email-ian.campbell@citrix.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit f6f71f187518477cecc01cd887933b5da19585e6
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Jul 7 23:43:18 2010 +0200

    PM / Hibernate: Fix hibernation_platform_enter()
    
    The hibernation_platform_enter() function calls dpm_suspend_noirq()
    instead of dpm_resume_noirq() by mistake.  Fix this.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Len Brown <len.brown@intel.com>

commit 3f53eb6f84545a7fc55a36657755371f42c63fca
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Jun 17 23:02:27 2010 +0000

    DRM / radeon / KMS: Fix hibernation regression related to radeon PM (was: Re: [Regression, post-2.6.34] Hibernation broken on machines with radeon/KMS and r300)
    
    There is a regression from 2.6.34 related to the recent radeon power
    management changes, caused by attempting to cancel a delayed work
    item that's never been scheduled.  However, the code as is has some
    other issues potentially leading to visible problems.
    
    First, the mutex around cancel_delayed_work() in radeon_pm_suspend()
    doesn't really serve any purpose, because cancel_delayed_work() only
    tries to delete the work's timer.  Moreover, it doesn't prevent the
    work handler from running, so the handler can do some wrong things if
    it wins the race and in that case it will rearm itself to do some
    more wrong things going forward.  So, I think it's better to wait for
    the handler to return in case it's already been queued up for
    execution.  Also, it should be prevented from rearming itself in that
    case.
    
    Second, in radeon_set_pm_method() the cancel_delayed_work() is not
    sufficient to prevent the work handler from running and queing up
    itself for the next run (the failure scenario is that
    cancel_delayed_work() returns 0, so the handler is run, it waits on
    the mutex and then rearms itself after the mutex has been released),
    so again the work handler should be prevented from rearming itself in
    that case..
    
    Finally, there's a potential deadlock in radeon_pm_fini(), because
    cancel_delayed_work_sync() is called under rdev->pm.mutex, but the
    work handler tries to acquire the same mutex (if it wins the race).
    
    Fix the issues described above.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Reviewed-by: Alex Deucher <alexdeucher@gmail.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

commit 9949788b793826f2d19e929ac0219ad0e0891e2d
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Fri May 7 20:24:05 2010 +0100

    ASoC: Refactor DAPM suspend handling
    
    Instead of using stream events to handle power down during suspend
    integrate the handling with the normal widget path checking by
    replacing all cases where we report a connected endpoint in a path
    with a function snd_soc_dapm_suspend_check() which looks at the ALSA
    power state for the card and reports false if we are in a D3 state.
    
    Since the core moves us into D3 prior to initating the suspend all
    power checks during suspend will cause the widgets to be powered
    down. In order to ensure that widgets are powered up on resume set
    the card to D2 at the start of resume handling (ALSA API calls
    require D0 so we are still protected against userspace access).
    
    Tested-by: Peter Ujfalusi <peter.ujfalusi@nokia.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

commit a111c28a5d47bc15ed6b644a0b7c69d748c1bdb2
Author: Ian Campbell <ian.campbell@citrix.com>
Date:   Thu Dec 17 13:57:09 2009 +0000

    xen: fix hang on suspend.
    
    commit c5cae661d6cf808b6984762f763261adf35f3eb7 upstream.
    
    In 65f63384 "xen: improve error handling in do_suspend" I said:
        - xs_suspend()/xs_resume() and dpm_suspend_noirq()/dpm_resume_noirq() were not
          nested in the obvious way.
    and changed the ordering of the calls as so:
        BEFORE              AFTER
        xs_suspend          dpm_suspend_noirq
        dpm_suspend_noirq   xs_suspend
        *SUSPEND*           *SUSPEND*
        dpm_resume_noirq    dpm_resume_noirq
        xs_resume           xs_resume
    Clearly this is not an improvement and I was talking rubbish.
    
    In particular the new ordering is susceptible to a hang if a xenstore write is
    in progress at the point at which the suspend kicks in. When the suspend
    process calls xs_suspend it tries to take the request_mutex but if a write is
    in progress it could be looping in xenbus_xs.c:read_reply() waiting for
    something to arrive on &xs_state.reply_list while holding the request_mutex
    (taken in the caller of read_reply).
    
    However if we have done dpm_suspend_noirq before xs_suspend then we won't get
    any more xenstore interrupts and process_msg() will never be woken up to add
    anything to the reply_list.
    
    Fix this by calling xs_suspend before dpm_suspend_noirq. If dpm_suspend_noirq
    fails then make sure we go through the xs_suspend_cancel() code path.
    
    Signed-off-by: Ian Campbell <ian.campbell@citrix.com>
    Acked-by: Jeremy Fitzhardinge <jeremy.fitzhardinge@citrix.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit c5cae661d6cf808b6984762f763261adf35f3eb7
Author: Ian Campbell <ian.campbell@citrix.com>
Date:   Thu Dec 17 13:57:09 2009 +0000

    xen: fix hang on suspend.
    
    In 65f63384 "xen: improve error handling in do_suspend" I said:
        - xs_suspend()/xs_resume() and dpm_suspend_noirq()/dpm_resume_noirq() were not
          nested in the obvious way.
    and changed the ordering of the calls as so:
        BEFORE              AFTER
        xs_suspend          dpm_suspend_noirq
        dpm_suspend_noirq   xs_suspend
        *SUSPEND*           *SUSPEND*
        dpm_resume_noirq    dpm_resume_noirq
        xs_resume           xs_resume
    Clearly this is not an improvement and I was talking rubbish.
    
    In particular the new ordering is susceptible to a hang if a xenstore write is
    in progress at the point at which the suspend kicks in. When the suspend
    process calls xs_suspend it tries to take the request_mutex but if a write is
    in progress it could be looping in xenbus_xs.c:read_reply() waiting for
    something to arrive on &xs_state.reply_list while holding the request_mutex
    (taken in the caller of read_reply).
    
    However if we have done dpm_suspend_noirq before xs_suspend then we won't get
    any more xenstore interrupts and process_msg() will never be woken up to add
    anything to the reply_list.
    
    Fix this by calling xs_suspend before dpm_suspend_noirq. If dpm_suspend_noirq
    fails then make sure we go through the xs_suspend_cancel() code path.
    
    Signed-off-by: Ian Campbell <ian.campbell@citrix.com>
    Acked-by: Jeremy Fitzhardinge <jeremy.fitzhardinge@citrix.com>
    Cc: Stable Kernel <stable@kernel.org>

commit f180b871d6cbcaaf9349075afb515081de073acb
Author: Ian Campbell <ian.campbell@citrix.com>
Date:   Tue Dec 1 11:47:14 2009 +0000

    xen: improve error handling in do_suspend.
    
    commit 65f63384b391bf4d384327d8a7c6de9860290b5c upstream.
    
    The existing error handling has a few issues:
    - If freeze_processes() fails it exits with shutting_down = SHUTDOWN_SUSPEND.
    - If dpm_suspend_noirq() fails it exits without resuming xenbus.
    - If stop_machine() fails it exits without resuming xenbus or calling
      dpm_resume_end().
    - xs_suspend()/xs_resume() and dpm_suspend_noirq()/dpm_resume_noirq() were not
      nested in the obvious way.
    
    Fix by ensuring each failure case goto's the correct label. Treat a failure of
    stop_machine() as a cancelled suspend in order to follow the correct resume
    path.
    
    Signed-off-by: Ian Campbell <ian.campbell@citrix.com>
    Signed-off-by: Jeremy Fitzhardinge <jeremy.fitzhardinge@citrix.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit d7b1aedc1a241dcde39a8a35757b6b0797eac5ff
Author: Ian Campbell <ian.campbell@citrix.com>
Date:   Tue Nov 24 10:16:23 2009 +0000

    xen: register timer interrupt with IRQF_TIMER
    
    commit f350c7922faad3397c98c81a9e5658f5a1ef0214 upstream.
    
    Otherwise the timer is disabled by dpm_suspend_noirq() which in turn prevents
    correct operation of stop_machine on multi-processor systems and breaks
    suspend.
    
    Signed-off-by: Ian Campbell <ian.campbell@citrix.com>
    Signed-off-by: Jeremy Fitzhardinge <jeremy.fitzhardinge@citrix.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 65f63384b391bf4d384327d8a7c6de9860290b5c
Author: Ian Campbell <ian.campbell@citrix.com>
Date:   Tue Dec 1 11:47:14 2009 +0000

    xen: improve error handling in do_suspend.
    
    The existing error handling has a few issues:
    - If freeze_processes() fails it exits with shutting_down = SHUTDOWN_SUSPEND.
    - If dpm_suspend_noirq() fails it exits without resuming xenbus.
    - If stop_machine() fails it exits without resuming xenbus or calling
      dpm_resume_end().
    - xs_suspend()/xs_resume() and dpm_suspend_noirq()/dpm_resume_noirq() were not
      nested in the obvious way.
    
    Fix by ensuring each failure case goto's the correct label. Treat a failure of
    stop_machine() as a cancelled suspend in order to follow the correct resume
    path.
    
    Signed-off-by: Ian Campbell <ian.campbell@citrix.com>
    Signed-off-by: Jeremy Fitzhardinge <jeremy.fitzhardinge@citrix.com>
    Cc: Stable Kernel <stable@kernel.org>

commit f350c7922faad3397c98c81a9e5658f5a1ef0214
Author: Ian Campbell <ian.campbell@citrix.com>
Date:   Tue Nov 24 10:16:23 2009 +0000

    xen: register timer interrupt with IRQF_TIMER
    
    Otherwise the timer is disabled by dpm_suspend_noirq() which in turn prevents
    correct operation of stop_machine on multi-processor systems and breaks
    suspend.
    
    Signed-off-by: Ian Campbell <ian.campbell@citrix.com>
    Signed-off-by: Jeremy Fitzhardinge <jeremy.fitzhardinge@citrix.com>
    Cc: Stable Kernel <stable@kernel.org>

commit bf97402052483c125a9ea7bf13df0dd9b4134078
Author: Dan Carpenter <error27@gmail.com>
Date:   Mon Nov 16 11:07:17 2009 +0200

    ALSA: ice1724 - make some bitfields unsigned
    
    This is a clean up and doesn't change the behavior.
    
    Bit fields should always be unsigned.  Otherwise pm_suspend_enabled will
    be -1 when you want it to be 1.  The other bad thing is that the sparse
    checker will complain 36 times if they aren't unsigned.
    
    The other bitfields in that struct are unsigned already.
    
    Signed-off-by: Dan Carpenter <error27@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

commit 679be3ba0c493eb66d22c206273729ce50925e85
Author: Jesse Brandeburg <jesse.brandeburg@intel.com>
Date:   Tue Jun 30 12:45:34 2009 +0000

    e1000: fix unmap bug
    
    as reported by kerneloops.org
    
    [  121.781161] ------------[ cut here ]------------
    [  121.781171] WARNING: at lib/dma-debug.c:793 check_unmap+0x14e/0x577()
    [  121.781173] Hardware name: S5520HC
    [  121.781177] e1000 0000:0a:00.0: DMA-API: device driver tries to free DMA
    memory it has not allocated [device address=0x00000001d688b0fa] [size=1522
    bytes]
    [  121.781180] Modules linked in: e1000 mdio  dca [last unloaded: ixgbe]
    [  121.781187] Pid: 4793, comm: bash Tainted: P 2.6.30-master-06161113 #3
    [  121.781190] Call Trace:
    [  121.781195]  [<ffffffff8123056f>] ? check_unmap+0x14e/0x577
    [  121.781201]  [<ffffffff81057a19>] warn_slowpath_common+0x77/0x8f
    [  121.781205]  [<ffffffff81057ae1>] warn_slowpath_fmt+0x9f/0xa1
    [  121.781212]  [<ffffffff81477ce2>] ? _spin_lock_irqsave+0x3f/0x49
    [  121.781216]  [<ffffffff8122fa97>] ? get_hash_bucket+0x28/0x33
    [  121.781220]  [<ffffffff8123056f>] check_unmap+0x14e/0x577
    [  121.781225]  [<ffffffff810e4f48>] ? check_bytes_and_report+0x38/0xcb
    [  121.781230]  [<ffffffff81230bbf>] debug_dma_unmap_page+0x80/0x92
    [  121.781234]  [<ffffffff8122e549>] ? unmap_single+0x1a/0x4e
    [  121.781239]  [<ffffffff813901e1>] ? __kfree_skb+0x74/0x78
    [  121.781250]  [<ffffffffa00662ef>] pci_unmap_single+0x64/0x6d [e1000]
    [  121.781259]  [<ffffffffa0066344>] e1000_clean_rx_ring+0x4c/0xbf [e1000]
    [  121.781268]  [<ffffffffa00663df>] e1000_clean_all_rx_rings+0x28/0x36 [e1000]
    [  121.781277]  [<ffffffffa0067464>] e1000_down+0x138/0x141 [e1000]
    [  121.781286]  [<ffffffffa00681c2>] __e1000_shutdown+0x6b/0x198 [e1000]
    [  121.781296]  [<ffffffffa0068405>] e1000_suspend+0x17/0x50 [e1000]
    [  121.781301]  [<ffffffff81237665>] pci_legacy_suspend+0x3b/0xbe
    [  121.781305]  [<ffffffff81237bc6>] pci_pm_suspend+0x3e/0xf1
    [  121.781310]  [<ffffffff812eaf1c>] pm_op+0x57/0xde
    [  121.781314]  [<ffffffff812eb444>] dpm_suspend_start+0x31e/0x470
    [  121.781319]  [<ffffffff810877da>] suspend_devices_and_enter+0x3e/0x1a2
    [  121.781323]  [<ffffffff81087a0f>] enter_state+0xd1/0x127
    [  121.781327]  [<ffffffff8108717a>] state_store+0xa7/0xc9
    [  121.781332]  [<ffffffff81221843>] kobj_attr_store+0x17/0x19
    [  121.781336]  [<ffffffff8113c01e>] sysfs_write_file+0xe5/0x121
    [  121.781341]  [<ffffffff810ed165>] vfs_write+0xab/0x105
    [  121.781344]  [<ffffffff810ed279>] sys_write+0x47/0x6d
    [  121.781349]  [<ffffffff81027aab>] system_call_fastpath+0x16/0x1b
    [  121.781352] ---[ end trace 97bacaaac2ed7786 ]---
    
    Fix is to correctly zero out internal ->dma value when unmapping
    and make sure never to unmap unless there specifically was a mapping done.
    
    Signed-off-by: Jesse Brandeburg <jesse.brandeburg@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit d161630297a20802d01c55847bfcba85d2118a9f
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Sun May 24 22:05:42 2009 +0200

    PM core: rename suspend and resume functions
    
    This patch (as1241) renames a bunch of functions in the PM core.
    Rather than go through a boring list of name changes, suffice it to
    say that in the end we have a bunch of pairs of functions:
    
            device_resume_noirq     dpm_resume_noirq
            device_resume           dpm_resume
            device_complete         dpm_complete
            device_suspend_noirq    dpm_suspend_noirq
            device_suspend          dpm_suspend
            device_prepare          dpm_prepare
    
    in which device_X does the X operation on a single device and dpm_X
    invokes device_X for all devices in the dpm_list.
    
    In addition, the old dpm_power_up and device_resume_noirq have been
    combined into a single function (dpm_resume_noirq).
    
    Lastly, dpm_suspend_start and dpm_resume_end are the renamed versions
    of the former top-level device_suspend and device_resume routines.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Magnus Damm <damm@igel.co.jp>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

commit 51cdd9289d2e0d83eb32ed6d7a42596b02bf924e
Author: Pavel Machek <pavel@ucw.cz>
Date:   Thu Jun 11 23:25:09 2009 +0800

    [ARM] pxa/sharpsl_pm: zaurus needs generic pxa suspend/resume routines
    
    For suspend/resume to work, spitz needs pxa_pm_suspend/resume to be
    called. Otherwise PSPR is not set properly, and system will die during
    resume.
    
    Signed-off-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Eric Miao <eric.y.miao@gmail.com>

commit c4e061ace75513aee227090486cc46dec7810c00
Author: Reinette Chatre <reinette.chatre@intel.com>
Date:   Tue Feb 3 10:20:03 2009 -0800

    iwlwifi: save PCI state before suspend, restore after resume
    
    This is the right thing to do and fixes the following warning:
    
    [  115.012278] ------------[ cut here ]------------
    [  115.012281] WARNING: at drivers/pci/pci-driver.c:370
    pci_legacy_suspend+0x85/0xc2()
    [  115.012285] Hardware name: Latitude D630
    [  115.012301] PCI PM: Device state not saved by
    iwl3945_pci_suspend+0x0/0x4c [iwl3945]
    [  115.012304] Modules linked in: fuse nfsd lockd nfs_acl auth_rpcgss
    exportfs sunrpc ipv6 acpi_cpufreq kvm_intel kvm snd_hda_codec_idt
    snd_hda_intel snd_hda_codec snd_hwdep arc4 snd_seq_device snd_pcm_oss
    snd_mixer_oss ecb snd_pcm cryptomgr aead snd_timer crypto_blkcipher
    snd snd_page_alloc ohci1394 crypto_hash crypto_algapi ch341 ieee1394
    usbserial thermal iwl3945 mac80211 led_class lib80211 tg3 processor
    i2c_i801 i2c_core sg cfg80211 libphy usbhid battery ac button sr_mod
    cdrom evdev dcdbas ata_generic ata_piix libata sd_mod scsi_mod ext3
    jbd mbcache uhci_hcd ohci_hcd ehci_hcd usbcore [last unloaded:
    microcode]
    [  115.012374] Pid: 4163, comm: pm-suspend Not tainted
    2.6.29-rc3-00227-gf1dd849-dirty #67
    [  115.012377] Call Trace:
    [  115.012382]  [<ffffffff8023d04d>] warn_slowpath+0xb1/0xed
    [  115.012387]  [<ffffffff80450b5e>] ? _spin_unlock_irqrestore+0x5c/0x78
    [  115.012390]  [<ffffffff80254f08>] ? up+0x34/0x39
    [  115.012394]  [<ffffffff80362319>] ? acpi_ut_release_mutex+0x5d/0x61
    [  115.012397]  [<ffffffff803584b2>] ? acpi_get_data+0x5e/0x70
    [  115.012400]  [<ffffffff80363dd9>] ? acpi_bus_get_device+0x25/0x39
    [  115.012403]  [<ffffffff80363e98>] ? acpi_bus_power_manageable+0x11/0x29
    [  115.012406]  [<ffffffff803462f7>] ? acpi_pci_power_manageable+0x17/0x19
    [  115.012410]  [<ffffffff8033ddfd>] ? pci_set_power_state+0xcc/0x101
    [  115.012418]  [<ffffffffa01f28e9>] ? iwl3945_pci_suspend+0x0/0x4c [iwl3945]
    [  115.012422]  [<ffffffff803401e6>] pci_legacy_suspend+0x85/0xc2
    [  115.012425]  [<ffffffff80340316>] pci_pm_suspend+0x34/0x86
    [  115.012429]  [<ffffffff8039d7ce>] pm_op+0x52/0xe5
    [  115.012432]  [<ffffffff8039dd78>] device_suspend+0x32a/0x451
    [  115.012436]  [<ffffffff80269ec2>] suspend_devices_and_enter+0x3e/0x13a
    [  115.012439]  [<ffffffff8026a128>] enter_state+0x110/0x164
    [  115.012442]  [<ffffffff8026a233>] state_store+0xb7/0xd7
    [  115.012446]  [<ffffffff8032f95f>] kobj_attr_store+0x17/0x19
    [  115.012449]  [<ffffffff80307d64>] sysfs_write_file+0xe4/0x119
    [  115.012453]  [<ffffffff802baa7a>] vfs_write+0xae/0x137
    [  115.012456]  [<ffffffff802babc7>] sys_write+0x47/0x70
    [  115.012459]  [<ffffffff8020b73a>] system_call_fastpath+0x16/0x1b
    [  115.012467] ---[ end trace 829828966f6f24dc ]---
    
    Signed-off-by: Reinette Chatre <reinette.chatre@intel.com>
    Tested-by: Ming Lei <tom.leiming@gmail.com>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

commit 6f051069d8a2045666055e3020ae8a7dec9762e0
Author: Anton Vorontsov <avorontsov@ru.mvista.com>
Date:   Thu Jan 22 13:51:24 2009 -0800

    phylib: Fix oops in suspend/resume paths
    
    Suspend/resume routines check for phydrv != NULL, but that is
    wrong because "phydrv" comes from container_of(drv). If drv is NULL,
    then container_of(drv) will return non-NULL result, and the checks
    won't work.
    
    The Freescale TBI PHYs are driver-less, so "drv" is NULL, and that
    leads to the following oops:
    
    Unable to handle kernel paging request for data at address 0xffffffe4
    Faulting instruction address: 0xc0215554
    Oops: Kernel access of bad area, sig: 11 [#1]
    [...]
    NIP [c0215554] mdio_bus_suspend+0x34/0x70
    LR [c01cc508] suspend_device+0x258/0x2bc
    Call Trace:
    [cfad3da0] [cfad3db8] 0xcfad3db8 (unreliable)
    [cfad3db0] [c01cc508] suspend_device+0x258/0x2bc
    [cfad3dd0] [c01cc62c] dpm_suspend+0xc0/0x140
    [cfad3e20] [c01cc6f4] device_suspend+0x48/0x5c
    [cfad3e40] [c0068dd8] suspend_devices_and_enter+0x8c/0x148
    [cfad3e60] [c00690f8] enter_state+0x100/0x118
    [cfad3e80] [c00691c0] state_store+0xb0/0xe4
    [cfad3ea0] [c018c938] kobj_attr_store+0x24/0x3c
    [cfad3eb0] [c00ea9a8] flush_write_buffer+0x58/0x7c
    [cfad3ed0] [c00eadf0] sysfs_write_file+0x58/0xa0
    [cfad3ef0] [c009e810] vfs_write+0xb4/0x16c
    [cfad3f10] [c009ed40] sys_write+0x4c/0x90
    [cfad3f40] [c0014954] ret_from_syscall+0x0/0x38
    [...]
    
    This patch fixes the issue, plus removes unneeded parentheses
    and fixes indentation level in mdio_bus_suspend().
    
    Signed-off-by: Anton Vorontsov <avorontsov@ru.mvista.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit d20a4dca47d2cd027ed58a13f91b424affd1f449
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Wed Jun 11 22:03:10 2008 +0200

    APM emulation: Notify about all suspend events, not just APM invoked ones (v2)
    
    This revamps the apm-emulation code to get suspend notifications
    regardless of what way pm_suspend() was invoked, whether via the
    apm ioctl or via /sys/power/state. Also do some code cleanup and
    add comments while at it.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Len Brown <len.brown@intel.com>
    Signed-off-by: Andi Kleen <ak@linux.intel.com>

commit 1b3cbec1dcb6747b587b40335f5de1d9e035063c
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri Feb 29 11:50:22 2008 -0500

    PM: fix new mutex-locking bug in the PM core
    
    This patch (as1041) fixes a bug introduced by the
    acquire-all-device-semaphores reversion.  The error pathway of
    dpm_suspend() fails to reacquire a mutex it should be holding.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit ec5a42465abc585a7f8117be5eecc361490e48ce
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Feb 20 02:01:41 2008 +0100

    PM: Remove unbalanced mutex_unlock() from dpm_resume()
    
    Remove an unnecessary unlocking of dpm_list_mtx in the error path
    in drivers/base/power/main.c:dpm_suspend() .
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit f91266edba3c6ef001819c5abe4c3a0643f66fc9
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Wed Dec 12 01:25:59 2007 +1100

    [POWERPC] powermac: Use generic suspend code
    
    This adds platform_suspend_ops for PMU based machines, directly in
    the PMU driver.  This allows suspending via /sys/power/state
    on powerbooks.
    
    The patch also replaces the PMU ioctl with a simple call to
    pm_suspend(PM_SUSPEND_MEM).
    
    Additionally, it cleans up some debug code.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

commit eebdf7d7c478682756fd29d376223f350311f105
Author: David Brownell <david-b@pacbell.net>
Date:   Mon Apr 2 12:48:10 2007 -0700

    ARM: OMAP: OSK led fixes
    
    Bugfixes for the OSK led support:
    
     - Fix Kconfig merge glitches:  Mistral handles idle and timer leds just fine
     - Fix pm_suspend() runtime botch:  can't sleep, so can't touch tps65010 leds
    
    Improvements:
     - Switch sense of Mistral idle led, so idle == off
    
    Probably the TPS65010 leds should be handled only by the "new led" API.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

commit ab3bfca7abf3fd0fe41d26d839610a787aa7e587
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Sun May 6 14:50:49 2007 -0700

    remove software_suspend()
    
    Remove software_suspend() and all its users since
    pm_suspend(PM_SUSPEND_DISK) should be equivalent and there's no point in
    having two interfaces for the same thing.
    
    The patch also changes the valid_state function to return 0 (false) for
    PM_SUSPEND_DISK when SOFTWARE_SUSPEND is not configured instead of
    accepting it and having the whole thing fail later.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Acked-by: "Rafael J. Wysocki" <rjw@sisk.pl>
    Cc: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit 0709db6072c2e799eba1aa61bd19e0d7f38aa2cd
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun May 6 14:50:45 2007 -0700

    swsusp: use GFP_KERNEL for creating basic data structures
    
    Make swsusp call create_basic_memory_bitmaps() before processes are frozen, so
    that GFP_KERNEL allocations can be made in it.  Additionally, ensure that the
    swsusp's userland interface won't be used while either pm_suspend_disk() or
    software_resume() is being executed.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit 4f2849e49cbaf8373163211bb811a8457b46cc4e
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Tue Feb 20 15:23:57 2007 +0000

    [ARM] Fix jornada720 build errors
    
    kernel/built-in.o: In function `pm_suspend':
    utsname_sysctl.c:(.text+0x23008): multiple definition of `pm_suspend'
    arch/arm/mach-sa1100/built-in.o:arch/arm/mach-sa1100/sleep.S:(.text+0xf68): first defined here
    arm-linux-ld: Warning: size of symbol `pm_suspend' changed from 20 in arch/arm/mach-sa1100/built-in.o to 44 in kernel/built-in.o
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

commit 408966b85e47859a488f0f6e8c83f09beb563081
Author: Kristoffer Ericson <Kristoffer_e1@hotmail.com>
Date:   Wed Dec 13 21:32:08 2006 +0100

    [ARM] 4017/1: [Jornada7xx] - Updating Jornada720.c
    
    * HP Jornada 720 uses epson 1356 chip for graphics. This chip is compatible with s1d13xxxfb driver.
    
    * HP Jornada 720 uses a Microprocessor Control Unit to talk to various
    hardware. We add it as a platform device in jornada720_init()
    
    * We provide pm_suspend() to avoid unresolved symbols in apm.o. We are
    unable to truly suspend now, hence the stub.
    
    * Speaker/microphone enabling got removed because it will be placed in the alsa driver.
    
    Signed-off-by: Filip Zyzniewski <(address hidden)>
    Signed-off-by: Kristoffer Ericson <(address hidden)>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

commit 4cf303487d5dddaace2daca8437c555f3f0bc1aa
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Wed Dec 6 20:36:06 2006 -0800

    [PATCH] Export pm_suspend for the shared APM emulation
    
    The new shared APM emulation just like its ARM and MIPS predecessors uses
    pm_suspend() which was only exported on SH.  Move export to close to it's
    definition where it really should be anyway.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
    Cc: Russell King <rmk@arm.linux.org.uk>
    Cc: Paul Mundt <lethal@linux-sh.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

commit 0245b3e787dc3267a915e1f56419e7e9c197e148
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun Oct 30 15:00:01 2005 -0800

    [PATCH] swsusp: two simplifications
    
    The following patch simplifies the progress meter in disk.c:free_some_memory()
    and makes disk.c:pm_suspend_disk() call device_resume() explicitly in the
    suspend path.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@suse.cz>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>
