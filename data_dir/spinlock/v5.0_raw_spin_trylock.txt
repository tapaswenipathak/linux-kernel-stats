commit 9b83ec63d0de7b1f379daa1571e128bc7b9570f8
Author: Frederick Lawler <fred@cloudflare.com>
Date:   Mon Jan 9 10:39:06 2023 -0600

    net: sched: disallow noqueue for qdisc classes
    
    commit 96398560f26aa07e8f2969d73c8197e6a6d10407 upstream.
    
    While experimenting with applying noqueue to a classful queue discipline,
    we discovered a NULL pointer dereference in the __dev_queue_xmit()
    path that generates a kernel OOPS:
    
        # dev=enp0s5
        # tc qdisc replace dev $dev root handle 1: htb default 1
        # tc class add dev $dev parent 1: classid 1:1 htb rate 10mbit
        # tc qdisc add dev $dev parent 1:1 handle 10: noqueue
        # ping -I $dev -w 1 -c 1 1.1.1.1
    
    [    2.172856] BUG: kernel NULL pointer dereference, address: 0000000000000000
    [    2.173217] #PF: supervisor instruction fetch in kernel mode
    ...
    [    2.178451] Call Trace:
    [    2.178577]  <TASK>
    [    2.178686]  htb_enqueue+0x1c8/0x370
    [    2.178880]  dev_qdisc_enqueue+0x15/0x90
    [    2.179093]  __dev_queue_xmit+0x798/0xd00
    [    2.179305]  ? _raw_write_lock_bh+0xe/0x30
    [    2.179522]  ? __local_bh_enable_ip+0x32/0x70
    [    2.179759]  ? ___neigh_create+0x610/0x840
    [    2.179968]  ? eth_header+0x21/0xc0
    [    2.180144]  ip_finish_output2+0x15e/0x4f0
    [    2.180348]  ? dst_output+0x30/0x30
    [    2.180525]  ip_push_pending_frames+0x9d/0xb0
    [    2.180739]  raw_sendmsg+0x601/0xcb0
    [    2.180916]  ? _raw_spin_trylock+0xe/0x50
    [    2.181112]  ? _raw_spin_unlock_irqrestore+0x16/0x30
    [    2.181354]  ? get_page_from_freelist+0xcd6/0xdf0
    [    2.181594]  ? sock_sendmsg+0x56/0x60
    [    2.181781]  sock_sendmsg+0x56/0x60
    [    2.181958]  __sys_sendto+0xf7/0x160
    [    2.182139]  ? handle_mm_fault+0x6e/0x1d0
    [    2.182366]  ? do_user_addr_fault+0x1e1/0x660
    [    2.182627]  __x64_sys_sendto+0x1b/0x30
    [    2.182881]  do_syscall_64+0x38/0x90
    [    2.183085]  entry_SYSCALL_64_after_hwframe+0x63/0xcd
    ...
    [    2.187402]  </TASK>
    
    Previously in commit d66d6c3152e8 ("net: sched: register noqueue
    qdisc"), NULL was set for the noqueue discipline on noqueue init
    so that __dev_queue_xmit() falls through for the noqueue case. This
    also sets a bypass of the enqueue NULL check in the
    register_qdisc() function for the struct noqueue_disc_ops.
    
    Classful queue disciplines make it past the NULL check in
    __dev_queue_xmit() because the discipline is set to htb (in this case),
    and then in the call to __dev_xmit_skb(), it calls into htb_enqueue()
    which grabs a leaf node for a class and then calls qdisc_enqueue() by
    passing in a queue discipline which assumes ->enqueue() is not set to NULL.
    
    Fix this by not allowing classes to be assigned to the noqueue
    discipline. Linux TC Notes states that classes cannot be set to
    the noqueue discipline. [1] Let's enforce that here.
    
    Links:
    1. https://linux-tc-notes.sourceforge.net/tc/doc/sch_noqueue.txt
    
    Fixes: d66d6c3152e8 ("net: sched: register noqueue qdisc")
    Cc: stable@vger.kernel.org
    Signed-off-by: Frederick Lawler <fred@cloudflare.com>
    Reviewed-by: Jakub Sitnicki <jakub@cloudflare.com>
    Link: https://lore.kernel.org/r/20230109163906.706000-1-fred@cloudflare.com
    Signed-off-by: Jakub Kicinski <kuba@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 0195d5ad539382a83e1bfaab51b93b8685f0b7c7
Author: Frederick Lawler <fred@cloudflare.com>
Date:   Mon Jan 9 10:39:06 2023 -0600

    net: sched: disallow noqueue for qdisc classes
    
    commit 96398560f26aa07e8f2969d73c8197e6a6d10407 upstream.
    
    While experimenting with applying noqueue to a classful queue discipline,
    we discovered a NULL pointer dereference in the __dev_queue_xmit()
    path that generates a kernel OOPS:
    
        # dev=enp0s5
        # tc qdisc replace dev $dev root handle 1: htb default 1
        # tc class add dev $dev parent 1: classid 1:1 htb rate 10mbit
        # tc qdisc add dev $dev parent 1:1 handle 10: noqueue
        # ping -I $dev -w 1 -c 1 1.1.1.1
    
    [    2.172856] BUG: kernel NULL pointer dereference, address: 0000000000000000
    [    2.173217] #PF: supervisor instruction fetch in kernel mode
    ...
    [    2.178451] Call Trace:
    [    2.178577]  <TASK>
    [    2.178686]  htb_enqueue+0x1c8/0x370
    [    2.178880]  dev_qdisc_enqueue+0x15/0x90
    [    2.179093]  __dev_queue_xmit+0x798/0xd00
    [    2.179305]  ? _raw_write_lock_bh+0xe/0x30
    [    2.179522]  ? __local_bh_enable_ip+0x32/0x70
    [    2.179759]  ? ___neigh_create+0x610/0x840
    [    2.179968]  ? eth_header+0x21/0xc0
    [    2.180144]  ip_finish_output2+0x15e/0x4f0
    [    2.180348]  ? dst_output+0x30/0x30
    [    2.180525]  ip_push_pending_frames+0x9d/0xb0
    [    2.180739]  raw_sendmsg+0x601/0xcb0
    [    2.180916]  ? _raw_spin_trylock+0xe/0x50
    [    2.181112]  ? _raw_spin_unlock_irqrestore+0x16/0x30
    [    2.181354]  ? get_page_from_freelist+0xcd6/0xdf0
    [    2.181594]  ? sock_sendmsg+0x56/0x60
    [    2.181781]  sock_sendmsg+0x56/0x60
    [    2.181958]  __sys_sendto+0xf7/0x160
    [    2.182139]  ? handle_mm_fault+0x6e/0x1d0
    [    2.182366]  ? do_user_addr_fault+0x1e1/0x660
    [    2.182627]  __x64_sys_sendto+0x1b/0x30
    [    2.182881]  do_syscall_64+0x38/0x90
    [    2.183085]  entry_SYSCALL_64_after_hwframe+0x63/0xcd
    ...
    [    2.187402]  </TASK>
    
    Previously in commit d66d6c3152e8 ("net: sched: register noqueue
    qdisc"), NULL was set for the noqueue discipline on noqueue init
    so that __dev_queue_xmit() falls through for the noqueue case. This
    also sets a bypass of the enqueue NULL check in the
    register_qdisc() function for the struct noqueue_disc_ops.
    
    Classful queue disciplines make it past the NULL check in
    __dev_queue_xmit() because the discipline is set to htb (in this case),
    and then in the call to __dev_xmit_skb(), it calls into htb_enqueue()
    which grabs a leaf node for a class and then calls qdisc_enqueue() by
    passing in a queue discipline which assumes ->enqueue() is not set to NULL.
    
    Fix this by not allowing classes to be assigned to the noqueue
    discipline. Linux TC Notes states that classes cannot be set to
    the noqueue discipline. [1] Let's enforce that here.
    
    Links:
    1. https://linux-tc-notes.sourceforge.net/tc/doc/sch_noqueue.txt
    
    Fixes: d66d6c3152e8 ("net: sched: register noqueue qdisc")
    Cc: stable@vger.kernel.org
    Signed-off-by: Frederick Lawler <fred@cloudflare.com>
    Reviewed-by: Jakub Sitnicki <jakub@cloudflare.com>
    Link: https://lore.kernel.org/r/20230109163906.706000-1-fred@cloudflare.com
    Signed-off-by: Jakub Kicinski <kuba@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 4574e32cbf652d7efcaa6076558752f770b01757
Author: Frederick Lawler <fred@cloudflare.com>
Date:   Mon Jan 9 10:39:06 2023 -0600

    net: sched: disallow noqueue for qdisc classes
    
    commit 96398560f26aa07e8f2969d73c8197e6a6d10407 upstream.
    
    While experimenting with applying noqueue to a classful queue discipline,
    we discovered a NULL pointer dereference in the __dev_queue_xmit()
    path that generates a kernel OOPS:
    
        # dev=enp0s5
        # tc qdisc replace dev $dev root handle 1: htb default 1
        # tc class add dev $dev parent 1: classid 1:1 htb rate 10mbit
        # tc qdisc add dev $dev parent 1:1 handle 10: noqueue
        # ping -I $dev -w 1 -c 1 1.1.1.1
    
    [    2.172856] BUG: kernel NULL pointer dereference, address: 0000000000000000
    [    2.173217] #PF: supervisor instruction fetch in kernel mode
    ...
    [    2.178451] Call Trace:
    [    2.178577]  <TASK>
    [    2.178686]  htb_enqueue+0x1c8/0x370
    [    2.178880]  dev_qdisc_enqueue+0x15/0x90
    [    2.179093]  __dev_queue_xmit+0x798/0xd00
    [    2.179305]  ? _raw_write_lock_bh+0xe/0x30
    [    2.179522]  ? __local_bh_enable_ip+0x32/0x70
    [    2.179759]  ? ___neigh_create+0x610/0x840
    [    2.179968]  ? eth_header+0x21/0xc0
    [    2.180144]  ip_finish_output2+0x15e/0x4f0
    [    2.180348]  ? dst_output+0x30/0x30
    [    2.180525]  ip_push_pending_frames+0x9d/0xb0
    [    2.180739]  raw_sendmsg+0x601/0xcb0
    [    2.180916]  ? _raw_spin_trylock+0xe/0x50
    [    2.181112]  ? _raw_spin_unlock_irqrestore+0x16/0x30
    [    2.181354]  ? get_page_from_freelist+0xcd6/0xdf0
    [    2.181594]  ? sock_sendmsg+0x56/0x60
    [    2.181781]  sock_sendmsg+0x56/0x60
    [    2.181958]  __sys_sendto+0xf7/0x160
    [    2.182139]  ? handle_mm_fault+0x6e/0x1d0
    [    2.182366]  ? do_user_addr_fault+0x1e1/0x660
    [    2.182627]  __x64_sys_sendto+0x1b/0x30
    [    2.182881]  do_syscall_64+0x38/0x90
    [    2.183085]  entry_SYSCALL_64_after_hwframe+0x63/0xcd
    ...
    [    2.187402]  </TASK>
    
    Previously in commit d66d6c3152e8 ("net: sched: register noqueue
    qdisc"), NULL was set for the noqueue discipline on noqueue init
    so that __dev_queue_xmit() falls through for the noqueue case. This
    also sets a bypass of the enqueue NULL check in the
    register_qdisc() function for the struct noqueue_disc_ops.
    
    Classful queue disciplines make it past the NULL check in
    __dev_queue_xmit() because the discipline is set to htb (in this case),
    and then in the call to __dev_xmit_skb(), it calls into htb_enqueue()
    which grabs a leaf node for a class and then calls qdisc_enqueue() by
    passing in a queue discipline which assumes ->enqueue() is not set to NULL.
    
    Fix this by not allowing classes to be assigned to the noqueue
    discipline. Linux TC Notes states that classes cannot be set to
    the noqueue discipline. [1] Let's enforce that here.
    
    Links:
    1. https://linux-tc-notes.sourceforge.net/tc/doc/sch_noqueue.txt
    
    Fixes: d66d6c3152e8 ("net: sched: register noqueue qdisc")
    Cc: stable@vger.kernel.org
    Signed-off-by: Frederick Lawler <fred@cloudflare.com>
    Reviewed-by: Jakub Sitnicki <jakub@cloudflare.com>
    Link: https://lore.kernel.org/r/20230109163906.706000-1-fred@cloudflare.com
    Signed-off-by: Jakub Kicinski <kuba@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 3a415d59c1dbec9d772dbfab2d2520d98360caae
Author: Eric Dumazet <edumazet@google.com>
Date:   Fri Jan 13 16:48:49 2023 +0000

    net/sched: sch_taprio: fix possible use-after-free
    
    syzbot reported a nasty crash [1] in net_tx_action() which
    made little sense until we got a repro.
    
    This repro installs a taprio qdisc, but providing an
    invalid TCA_RATE attribute.
    
    qdisc_create() has to destroy the just initialized
    taprio qdisc, and taprio_destroy() is called.
    
    However, the hrtimer used by taprio had already fired,
    therefore advance_sched() called __netif_schedule().
    
    Then net_tx_action was trying to use a destroyed qdisc.
    
    We can not undo the __netif_schedule(), so we must wait
    until one cpu serviced the qdisc before we can proceed.
    
    Many thanks to Alexander Potapenko for his help.
    
    [1]
    BUG: KMSAN: uninit-value in queued_spin_trylock include/asm-generic/qspinlock.h:94 [inline]
    BUG: KMSAN: uninit-value in do_raw_spin_trylock include/linux/spinlock.h:191 [inline]
    BUG: KMSAN: uninit-value in __raw_spin_trylock include/linux/spinlock_api_smp.h:89 [inline]
    BUG: KMSAN: uninit-value in _raw_spin_trylock+0x92/0xa0 kernel/locking/spinlock.c:138
     queued_spin_trylock include/asm-generic/qspinlock.h:94 [inline]
     do_raw_spin_trylock include/linux/spinlock.h:191 [inline]
     __raw_spin_trylock include/linux/spinlock_api_smp.h:89 [inline]
     _raw_spin_trylock+0x92/0xa0 kernel/locking/spinlock.c:138
     spin_trylock include/linux/spinlock.h:359 [inline]
     qdisc_run_begin include/net/sch_generic.h:187 [inline]
     qdisc_run+0xee/0x540 include/net/pkt_sched.h:125
     net_tx_action+0x77c/0x9a0 net/core/dev.c:5086
     __do_softirq+0x1cc/0x7fb kernel/softirq.c:571
     run_ksoftirqd+0x2c/0x50 kernel/softirq.c:934
     smpboot_thread_fn+0x554/0x9f0 kernel/smpboot.c:164
     kthread+0x31b/0x430 kernel/kthread.c:376
     ret_from_fork+0x1f/0x30
    
    Uninit was created at:
     slab_post_alloc_hook mm/slab.h:732 [inline]
     slab_alloc_node mm/slub.c:3258 [inline]
     __kmalloc_node_track_caller+0x814/0x1250 mm/slub.c:4970
     kmalloc_reserve net/core/skbuff.c:358 [inline]
     __alloc_skb+0x346/0xcf0 net/core/skbuff.c:430
     alloc_skb include/linux/skbuff.h:1257 [inline]
     nlmsg_new include/net/netlink.h:953 [inline]
     netlink_ack+0x5f3/0x12b0 net/netlink/af_netlink.c:2436
     netlink_rcv_skb+0x55d/0x6c0 net/netlink/af_netlink.c:2507
     rtnetlink_rcv+0x30/0x40 net/core/rtnetlink.c:6108
     netlink_unicast_kernel net/netlink/af_netlink.c:1319 [inline]
     netlink_unicast+0xf3b/0x1270 net/netlink/af_netlink.c:1345
     netlink_sendmsg+0x1288/0x1440 net/netlink/af_netlink.c:1921
     sock_sendmsg_nosec net/socket.c:714 [inline]
     sock_sendmsg net/socket.c:734 [inline]
     ____sys_sendmsg+0xabc/0xe90 net/socket.c:2482
     ___sys_sendmsg+0x2a1/0x3f0 net/socket.c:2536
     __sys_sendmsg net/socket.c:2565 [inline]
     __do_sys_sendmsg net/socket.c:2574 [inline]
     __se_sys_sendmsg net/socket.c:2572 [inline]
     __x64_sys_sendmsg+0x367/0x540 net/socket.c:2572
     do_syscall_x64 arch/x86/entry/common.c:50 [inline]
     do_syscall_64+0x3d/0xb0 arch/x86/entry/common.c:80
     entry_SYSCALL_64_after_hwframe+0x63/0xcd
    
    CPU: 0 PID: 13 Comm: ksoftirqd/0 Not tainted 6.0.0-rc2-syzkaller-47461-gac3859c02d7f #0
    Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 07/22/2022
    
    Fixes: 5a781ccbd19e ("tc: Add support for configuring the taprio scheduler")
    Reported-by: syzbot <syzkaller@googlegroups.com>
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Cc: Alexander Potapenko <glider@google.com>
    Cc: Vinicius Costa Gomes <vinicius.gomes@intel.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit e8988e878af693ac13b0fa80ba2e72d22d68f2dd
Author: Frederick Lawler <fred@cloudflare.com>
Date:   Mon Jan 9 10:39:06 2023 -0600

    net: sched: disallow noqueue for qdisc classes
    
    commit 96398560f26aa07e8f2969d73c8197e6a6d10407 upstream.
    
    While experimenting with applying noqueue to a classful queue discipline,
    we discovered a NULL pointer dereference in the __dev_queue_xmit()
    path that generates a kernel OOPS:
    
        # dev=enp0s5
        # tc qdisc replace dev $dev root handle 1: htb default 1
        # tc class add dev $dev parent 1: classid 1:1 htb rate 10mbit
        # tc qdisc add dev $dev parent 1:1 handle 10: noqueue
        # ping -I $dev -w 1 -c 1 1.1.1.1
    
    [    2.172856] BUG: kernel NULL pointer dereference, address: 0000000000000000
    [    2.173217] #PF: supervisor instruction fetch in kernel mode
    ...
    [    2.178451] Call Trace:
    [    2.178577]  <TASK>
    [    2.178686]  htb_enqueue+0x1c8/0x370
    [    2.178880]  dev_qdisc_enqueue+0x15/0x90
    [    2.179093]  __dev_queue_xmit+0x798/0xd00
    [    2.179305]  ? _raw_write_lock_bh+0xe/0x30
    [    2.179522]  ? __local_bh_enable_ip+0x32/0x70
    [    2.179759]  ? ___neigh_create+0x610/0x840
    [    2.179968]  ? eth_header+0x21/0xc0
    [    2.180144]  ip_finish_output2+0x15e/0x4f0
    [    2.180348]  ? dst_output+0x30/0x30
    [    2.180525]  ip_push_pending_frames+0x9d/0xb0
    [    2.180739]  raw_sendmsg+0x601/0xcb0
    [    2.180916]  ? _raw_spin_trylock+0xe/0x50
    [    2.181112]  ? _raw_spin_unlock_irqrestore+0x16/0x30
    [    2.181354]  ? get_page_from_freelist+0xcd6/0xdf0
    [    2.181594]  ? sock_sendmsg+0x56/0x60
    [    2.181781]  sock_sendmsg+0x56/0x60
    [    2.181958]  __sys_sendto+0xf7/0x160
    [    2.182139]  ? handle_mm_fault+0x6e/0x1d0
    [    2.182366]  ? do_user_addr_fault+0x1e1/0x660
    [    2.182627]  __x64_sys_sendto+0x1b/0x30
    [    2.182881]  do_syscall_64+0x38/0x90
    [    2.183085]  entry_SYSCALL_64_after_hwframe+0x63/0xcd
    ...
    [    2.187402]  </TASK>
    
    Previously in commit d66d6c3152e8 ("net: sched: register noqueue
    qdisc"), NULL was set for the noqueue discipline on noqueue init
    so that __dev_queue_xmit() falls through for the noqueue case. This
    also sets a bypass of the enqueue NULL check in the
    register_qdisc() function for the struct noqueue_disc_ops.
    
    Classful queue disciplines make it past the NULL check in
    __dev_queue_xmit() because the discipline is set to htb (in this case),
    and then in the call to __dev_xmit_skb(), it calls into htb_enqueue()
    which grabs a leaf node for a class and then calls qdisc_enqueue() by
    passing in a queue discipline which assumes ->enqueue() is not set to NULL.
    
    Fix this by not allowing classes to be assigned to the noqueue
    discipline. Linux TC Notes states that classes cannot be set to
    the noqueue discipline. [1] Let's enforce that here.
    
    Links:
    1. https://linux-tc-notes.sourceforge.net/tc/doc/sch_noqueue.txt
    
    Fixes: d66d6c3152e8 ("net: sched: register noqueue qdisc")
    Cc: stable@vger.kernel.org
    Signed-off-by: Frederick Lawler <fred@cloudflare.com>
    Reviewed-by: Jakub Sitnicki <jakub@cloudflare.com>
    Link: https://lore.kernel.org/r/20230109163906.706000-1-fred@cloudflare.com
    Signed-off-by: Jakub Kicinski <kuba@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 04941c1d5bb59d64165e09813de2947bdf6f4f28
Author: Frederick Lawler <fred@cloudflare.com>
Date:   Mon Jan 9 10:39:06 2023 -0600

    net: sched: disallow noqueue for qdisc classes
    
    commit 96398560f26aa07e8f2969d73c8197e6a6d10407 upstream.
    
    While experimenting with applying noqueue to a classful queue discipline,
    we discovered a NULL pointer dereference in the __dev_queue_xmit()
    path that generates a kernel OOPS:
    
        # dev=enp0s5
        # tc qdisc replace dev $dev root handle 1: htb default 1
        # tc class add dev $dev parent 1: classid 1:1 htb rate 10mbit
        # tc qdisc add dev $dev parent 1:1 handle 10: noqueue
        # ping -I $dev -w 1 -c 1 1.1.1.1
    
    [    2.172856] BUG: kernel NULL pointer dereference, address: 0000000000000000
    [    2.173217] #PF: supervisor instruction fetch in kernel mode
    ...
    [    2.178451] Call Trace:
    [    2.178577]  <TASK>
    [    2.178686]  htb_enqueue+0x1c8/0x370
    [    2.178880]  dev_qdisc_enqueue+0x15/0x90
    [    2.179093]  __dev_queue_xmit+0x798/0xd00
    [    2.179305]  ? _raw_write_lock_bh+0xe/0x30
    [    2.179522]  ? __local_bh_enable_ip+0x32/0x70
    [    2.179759]  ? ___neigh_create+0x610/0x840
    [    2.179968]  ? eth_header+0x21/0xc0
    [    2.180144]  ip_finish_output2+0x15e/0x4f0
    [    2.180348]  ? dst_output+0x30/0x30
    [    2.180525]  ip_push_pending_frames+0x9d/0xb0
    [    2.180739]  raw_sendmsg+0x601/0xcb0
    [    2.180916]  ? _raw_spin_trylock+0xe/0x50
    [    2.181112]  ? _raw_spin_unlock_irqrestore+0x16/0x30
    [    2.181354]  ? get_page_from_freelist+0xcd6/0xdf0
    [    2.181594]  ? sock_sendmsg+0x56/0x60
    [    2.181781]  sock_sendmsg+0x56/0x60
    [    2.181958]  __sys_sendto+0xf7/0x160
    [    2.182139]  ? handle_mm_fault+0x6e/0x1d0
    [    2.182366]  ? do_user_addr_fault+0x1e1/0x660
    [    2.182627]  __x64_sys_sendto+0x1b/0x30
    [    2.182881]  do_syscall_64+0x38/0x90
    [    2.183085]  entry_SYSCALL_64_after_hwframe+0x63/0xcd
    ...
    [    2.187402]  </TASK>
    
    Previously in commit d66d6c3152e8 ("net: sched: register noqueue
    qdisc"), NULL was set for the noqueue discipline on noqueue init
    so that __dev_queue_xmit() falls through for the noqueue case. This
    also sets a bypass of the enqueue NULL check in the
    register_qdisc() function for the struct noqueue_disc_ops.
    
    Classful queue disciplines make it past the NULL check in
    __dev_queue_xmit() because the discipline is set to htb (in this case),
    and then in the call to __dev_xmit_skb(), it calls into htb_enqueue()
    which grabs a leaf node for a class and then calls qdisc_enqueue() by
    passing in a queue discipline which assumes ->enqueue() is not set to NULL.
    
    Fix this by not allowing classes to be assigned to the noqueue
    discipline. Linux TC Notes states that classes cannot be set to
    the noqueue discipline. [1] Let's enforce that here.
    
    Links:
    1. https://linux-tc-notes.sourceforge.net/tc/doc/sch_noqueue.txt
    
    Fixes: d66d6c3152e8 ("net: sched: register noqueue qdisc")
    Cc: stable@vger.kernel.org
    Signed-off-by: Frederick Lawler <fred@cloudflare.com>
    Reviewed-by: Jakub Sitnicki <jakub@cloudflare.com>
    Link: https://lore.kernel.org/r/20230109163906.706000-1-fred@cloudflare.com
    Signed-off-by: Jakub Kicinski <kuba@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 9f7bc28a6b8afc2274e25650511555e93f45470f
Author: Frederick Lawler <fred@cloudflare.com>
Date:   Mon Jan 9 10:39:06 2023 -0600

    net: sched: disallow noqueue for qdisc classes
    
    commit 96398560f26aa07e8f2969d73c8197e6a6d10407 upstream.
    
    While experimenting with applying noqueue to a classful queue discipline,
    we discovered a NULL pointer dereference in the __dev_queue_xmit()
    path that generates a kernel OOPS:
    
        # dev=enp0s5
        # tc qdisc replace dev $dev root handle 1: htb default 1
        # tc class add dev $dev parent 1: classid 1:1 htb rate 10mbit
        # tc qdisc add dev $dev parent 1:1 handle 10: noqueue
        # ping -I $dev -w 1 -c 1 1.1.1.1
    
    [    2.172856] BUG: kernel NULL pointer dereference, address: 0000000000000000
    [    2.173217] #PF: supervisor instruction fetch in kernel mode
    ...
    [    2.178451] Call Trace:
    [    2.178577]  <TASK>
    [    2.178686]  htb_enqueue+0x1c8/0x370
    [    2.178880]  dev_qdisc_enqueue+0x15/0x90
    [    2.179093]  __dev_queue_xmit+0x798/0xd00
    [    2.179305]  ? _raw_write_lock_bh+0xe/0x30
    [    2.179522]  ? __local_bh_enable_ip+0x32/0x70
    [    2.179759]  ? ___neigh_create+0x610/0x840
    [    2.179968]  ? eth_header+0x21/0xc0
    [    2.180144]  ip_finish_output2+0x15e/0x4f0
    [    2.180348]  ? dst_output+0x30/0x30
    [    2.180525]  ip_push_pending_frames+0x9d/0xb0
    [    2.180739]  raw_sendmsg+0x601/0xcb0
    [    2.180916]  ? _raw_spin_trylock+0xe/0x50
    [    2.181112]  ? _raw_spin_unlock_irqrestore+0x16/0x30
    [    2.181354]  ? get_page_from_freelist+0xcd6/0xdf0
    [    2.181594]  ? sock_sendmsg+0x56/0x60
    [    2.181781]  sock_sendmsg+0x56/0x60
    [    2.181958]  __sys_sendto+0xf7/0x160
    [    2.182139]  ? handle_mm_fault+0x6e/0x1d0
    [    2.182366]  ? do_user_addr_fault+0x1e1/0x660
    [    2.182627]  __x64_sys_sendto+0x1b/0x30
    [    2.182881]  do_syscall_64+0x38/0x90
    [    2.183085]  entry_SYSCALL_64_after_hwframe+0x63/0xcd
    ...
    [    2.187402]  </TASK>
    
    Previously in commit d66d6c3152e8 ("net: sched: register noqueue
    qdisc"), NULL was set for the noqueue discipline on noqueue init
    so that __dev_queue_xmit() falls through for the noqueue case. This
    also sets a bypass of the enqueue NULL check in the
    register_qdisc() function for the struct noqueue_disc_ops.
    
    Classful queue disciplines make it past the NULL check in
    __dev_queue_xmit() because the discipline is set to htb (in this case),
    and then in the call to __dev_xmit_skb(), it calls into htb_enqueue()
    which grabs a leaf node for a class and then calls qdisc_enqueue() by
    passing in a queue discipline which assumes ->enqueue() is not set to NULL.
    
    Fix this by not allowing classes to be assigned to the noqueue
    discipline. Linux TC Notes states that classes cannot be set to
    the noqueue discipline. [1] Let's enforce that here.
    
    Links:
    1. https://linux-tc-notes.sourceforge.net/tc/doc/sch_noqueue.txt
    
    Fixes: d66d6c3152e8 ("net: sched: register noqueue qdisc")
    Cc: stable@vger.kernel.org
    Signed-off-by: Frederick Lawler <fred@cloudflare.com>
    Reviewed-by: Jakub Sitnicki <jakub@cloudflare.com>
    Link: https://lore.kernel.org/r/20230109163906.706000-1-fred@cloudflare.com
    Signed-off-by: Jakub Kicinski <kuba@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 96398560f26aa07e8f2969d73c8197e6a6d10407
Author: Frederick Lawler <fred@cloudflare.com>
Date:   Mon Jan 9 10:39:06 2023 -0600

    net: sched: disallow noqueue for qdisc classes
    
    While experimenting with applying noqueue to a classful queue discipline,
    we discovered a NULL pointer dereference in the __dev_queue_xmit()
    path that generates a kernel OOPS:
    
        # dev=enp0s5
        # tc qdisc replace dev $dev root handle 1: htb default 1
        # tc class add dev $dev parent 1: classid 1:1 htb rate 10mbit
        # tc qdisc add dev $dev parent 1:1 handle 10: noqueue
        # ping -I $dev -w 1 -c 1 1.1.1.1
    
    [    2.172856] BUG: kernel NULL pointer dereference, address: 0000000000000000
    [    2.173217] #PF: supervisor instruction fetch in kernel mode
    ...
    [    2.178451] Call Trace:
    [    2.178577]  <TASK>
    [    2.178686]  htb_enqueue+0x1c8/0x370
    [    2.178880]  dev_qdisc_enqueue+0x15/0x90
    [    2.179093]  __dev_queue_xmit+0x798/0xd00
    [    2.179305]  ? _raw_write_lock_bh+0xe/0x30
    [    2.179522]  ? __local_bh_enable_ip+0x32/0x70
    [    2.179759]  ? ___neigh_create+0x610/0x840
    [    2.179968]  ? eth_header+0x21/0xc0
    [    2.180144]  ip_finish_output2+0x15e/0x4f0
    [    2.180348]  ? dst_output+0x30/0x30
    [    2.180525]  ip_push_pending_frames+0x9d/0xb0
    [    2.180739]  raw_sendmsg+0x601/0xcb0
    [    2.180916]  ? _raw_spin_trylock+0xe/0x50
    [    2.181112]  ? _raw_spin_unlock_irqrestore+0x16/0x30
    [    2.181354]  ? get_page_from_freelist+0xcd6/0xdf0
    [    2.181594]  ? sock_sendmsg+0x56/0x60
    [    2.181781]  sock_sendmsg+0x56/0x60
    [    2.181958]  __sys_sendto+0xf7/0x160
    [    2.182139]  ? handle_mm_fault+0x6e/0x1d0
    [    2.182366]  ? do_user_addr_fault+0x1e1/0x660
    [    2.182627]  __x64_sys_sendto+0x1b/0x30
    [    2.182881]  do_syscall_64+0x38/0x90
    [    2.183085]  entry_SYSCALL_64_after_hwframe+0x63/0xcd
    ...
    [    2.187402]  </TASK>
    
    Previously in commit d66d6c3152e8 ("net: sched: register noqueue
    qdisc"), NULL was set for the noqueue discipline on noqueue init
    so that __dev_queue_xmit() falls through for the noqueue case. This
    also sets a bypass of the enqueue NULL check in the
    register_qdisc() function for the struct noqueue_disc_ops.
    
    Classful queue disciplines make it past the NULL check in
    __dev_queue_xmit() because the discipline is set to htb (in this case),
    and then in the call to __dev_xmit_skb(), it calls into htb_enqueue()
    which grabs a leaf node for a class and then calls qdisc_enqueue() by
    passing in a queue discipline which assumes ->enqueue() is not set to NULL.
    
    Fix this by not allowing classes to be assigned to the noqueue
    discipline. Linux TC Notes states that classes cannot be set to
    the noqueue discipline. [1] Let's enforce that here.
    
    Links:
    1. https://linux-tc-notes.sourceforge.net/tc/doc/sch_noqueue.txt
    
    Fixes: d66d6c3152e8 ("net: sched: register noqueue qdisc")
    Cc: stable@vger.kernel.org
    Signed-off-by: Frederick Lawler <fred@cloudflare.com>
    Reviewed-by: Jakub Sitnicki <jakub@cloudflare.com>
    Link: https://lore.kernel.org/r/20230109163906.706000-1-fred@cloudflare.com
    Signed-off-by: Jakub Kicinski <kuba@kernel.org>

commit 1aa262c1d056551dd1246115af8b7e351184deae
Author: Naohiro Aota <naohiro.aota@wdc.com>
Date:   Mon Aug 22 15:07:03 2022 +0900

    btrfs: replace BTRFS_MAX_EXTENT_SIZE with fs_info->max_extent_size
    
    commit f7b12a62f008a3041f42f2426983e59a6a0a3c59 upstream
    
    On zoned filesystem, data write out is limited by max_zone_append_size,
    and a large ordered extent is split according the size of a bio. OTOH,
    the number of extents to be written is calculated using
    BTRFS_MAX_EXTENT_SIZE, and that estimated number is used to reserve the
    metadata bytes to update and/or create the metadata items.
    
    The metadata reservation is done at e.g, btrfs_buffered_write() and then
    released according to the estimation changes. Thus, if the number of extent
    increases massively, the reserved metadata can run out.
    
    The increase of the number of extents easily occurs on zoned filesystem
    if BTRFS_MAX_EXTENT_SIZE > max_zone_append_size. And, it causes the
    following warning on a small RAM environment with disabling metadata
    over-commit (in the following patch).
    
    [75721.498492] ------------[ cut here ]------------
    [75721.505624] BTRFS: block rsv 1 returned -28
    [75721.512230] WARNING: CPU: 24 PID: 2327559 at fs/btrfs/block-rsv.c:537 btrfs_use_block_rsv+0x560/0x760 [btrfs]
    [75721.581854] CPU: 24 PID: 2327559 Comm: kworker/u64:10 Kdump: loaded Tainted: G        W         5.18.0-rc2-BTRFS-ZNS+ #109
    [75721.597200] Hardware name: Supermicro Super Server/H12SSL-NT, BIOS 2.0 02/22/2021
    [75721.607310] Workqueue: btrfs-endio-write btrfs_work_helper [btrfs]
    [75721.616209] RIP: 0010:btrfs_use_block_rsv+0x560/0x760 [btrfs]
    [75721.646649] RSP: 0018:ffffc9000fbdf3e0 EFLAGS: 00010286
    [75721.654126] RAX: 0000000000000000 RBX: 0000000000004000 RCX: 0000000000000000
    [75721.663524] RDX: 0000000000000004 RSI: 0000000000000008 RDI: fffff52001f7be6e
    [75721.672921] RBP: ffffc9000fbdf420 R08: 0000000000000001 R09: ffff889f8d1fc6c7
    [75721.682493] R10: ffffed13f1a3f8d8 R11: 0000000000000001 R12: ffff88980a3c0e28
    [75721.692284] R13: ffff889b66590000 R14: ffff88980a3c0e40 R15: ffff88980a3c0e8a
    [75721.701878] FS:  0000000000000000(0000) GS:ffff889f8d000000(0000) knlGS:0000000000000000
    [75721.712601] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [75721.720726] CR2: 000055d12e05c018 CR3: 0000800193594000 CR4: 0000000000350ee0
    [75721.730499] Call Trace:
    [75721.735166]  <TASK>
    [75721.739886]  btrfs_alloc_tree_block+0x1e1/0x1100 [btrfs]
    [75721.747545]  ? btrfs_alloc_logged_file_extent+0x550/0x550 [btrfs]
    [75721.756145]  ? btrfs_get_32+0xea/0x2d0 [btrfs]
    [75721.762852]  ? btrfs_get_32+0xea/0x2d0 [btrfs]
    [75721.769520]  ? push_leaf_left+0x420/0x620 [btrfs]
    [75721.776431]  ? memcpy+0x4e/0x60
    [75721.781931]  split_leaf+0x433/0x12d0 [btrfs]
    [75721.788392]  ? btrfs_get_token_32+0x580/0x580 [btrfs]
    [75721.795636]  ? push_for_double_split.isra.0+0x420/0x420 [btrfs]
    [75721.803759]  ? leaf_space_used+0x15d/0x1a0 [btrfs]
    [75721.811156]  btrfs_search_slot+0x1bc3/0x2790 [btrfs]
    [75721.818300]  ? lock_downgrade+0x7c0/0x7c0
    [75721.824411]  ? free_extent_buffer.part.0+0x107/0x200 [btrfs]
    [75721.832456]  ? split_leaf+0x12d0/0x12d0 [btrfs]
    [75721.839149]  ? free_extent_buffer.part.0+0x14f/0x200 [btrfs]
    [75721.846945]  ? free_extent_buffer+0x13/0x20 [btrfs]
    [75721.853960]  ? btrfs_release_path+0x4b/0x190 [btrfs]
    [75721.861429]  btrfs_csum_file_blocks+0x85c/0x1500 [btrfs]
    [75721.869313]  ? rcu_read_lock_sched_held+0x16/0x80
    [75721.876085]  ? lock_release+0x552/0xf80
    [75721.881957]  ? btrfs_del_csums+0x8c0/0x8c0 [btrfs]
    [75721.888886]  ? __kasan_check_write+0x14/0x20
    [75721.895152]  ? do_raw_read_unlock+0x44/0x80
    [75721.901323]  ? _raw_write_lock_irq+0x60/0x80
    [75721.907983]  ? btrfs_global_root+0xb9/0xe0 [btrfs]
    [75721.915166]  ? btrfs_csum_root+0x12b/0x180 [btrfs]
    [75721.921918]  ? btrfs_get_global_root+0x820/0x820 [btrfs]
    [75721.929166]  ? _raw_write_unlock+0x23/0x40
    [75721.935116]  ? unpin_extent_cache+0x1e3/0x390 [btrfs]
    [75721.942041]  btrfs_finish_ordered_io.isra.0+0xa0c/0x1dc0 [btrfs]
    [75721.949906]  ? try_to_wake_up+0x30/0x14a0
    [75721.955700]  ? btrfs_unlink_subvol+0xda0/0xda0 [btrfs]
    [75721.962661]  ? rcu_read_lock_sched_held+0x16/0x80
    [75721.969111]  ? lock_acquire+0x41b/0x4c0
    [75721.974982]  finish_ordered_fn+0x15/0x20 [btrfs]
    [75721.981639]  btrfs_work_helper+0x1af/0xa80 [btrfs]
    [75721.988184]  ? _raw_spin_unlock_irq+0x28/0x50
    [75721.994643]  process_one_work+0x815/0x1460
    [75722.000444]  ? pwq_dec_nr_in_flight+0x250/0x250
    [75722.006643]  ? do_raw_spin_trylock+0xbb/0x190
    [75722.013086]  worker_thread+0x59a/0xeb0
    [75722.018511]  kthread+0x2ac/0x360
    [75722.023428]  ? process_one_work+0x1460/0x1460
    [75722.029431]  ? kthread_complete_and_exit+0x30/0x30
    [75722.036044]  ret_from_fork+0x22/0x30
    [75722.041255]  </TASK>
    [75722.045047] irq event stamp: 0
    [75722.049703] hardirqs last  enabled at (0): [<0000000000000000>] 0x0
    [75722.057610] hardirqs last disabled at (0): [<ffffffff8118a94a>] copy_process+0x1c1a/0x66b0
    [75722.067533] softirqs last  enabled at (0): [<ffffffff8118a989>] copy_process+0x1c59/0x66b0
    [75722.077423] softirqs last disabled at (0): [<0000000000000000>] 0x0
    [75722.085335] ---[ end trace 0000000000000000 ]---
    
    To fix the estimation, we need to introduce fs_info->max_extent_size to
    replace BTRFS_MAX_EXTENT_SIZE, which allow setting the different size for
    regular vs zoned filesystem.
    
    Set fs_info->max_extent_size to BTRFS_MAX_EXTENT_SIZE by default. On zoned
    filesystem, it is set to fs_info->max_zone_append_size.
    
    CC: stable@vger.kernel.org # 5.12+
    Fixes: d8e3fb106f39 ("btrfs: zoned: use ZONE_APPEND write for zoned mode")
    Reviewed-by: Johannes Thumshirn <johannes.thumshirn@wdc.com>
    Signed-off-by: Naohiro Aota <naohiro.aota@wdc.com>
    Signed-off-by: David Sterba <dsterba@suse.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 096e8eb9639b342bc35f9b741cf05e26d0106e92
Author: Naohiro Aota <naohiro.aota@wdc.com>
Date:   Sat Jul 9 08:18:40 2022 +0900

    btrfs: replace BTRFS_MAX_EXTENT_SIZE with fs_info->max_extent_size
    
    [ Upstream commit f7b12a62f008a3041f42f2426983e59a6a0a3c59 ]
    
    On zoned filesystem, data write out is limited by max_zone_append_size,
    and a large ordered extent is split according the size of a bio. OTOH,
    the number of extents to be written is calculated using
    BTRFS_MAX_EXTENT_SIZE, and that estimated number is used to reserve the
    metadata bytes to update and/or create the metadata items.
    
    The metadata reservation is done at e.g, btrfs_buffered_write() and then
    released according to the estimation changes. Thus, if the number of extent
    increases massively, the reserved metadata can run out.
    
    The increase of the number of extents easily occurs on zoned filesystem
    if BTRFS_MAX_EXTENT_SIZE > max_zone_append_size. And, it causes the
    following warning on a small RAM environment with disabling metadata
    over-commit (in the following patch).
    
    [75721.498492] ------------[ cut here ]------------
    [75721.505624] BTRFS: block rsv 1 returned -28
    [75721.512230] WARNING: CPU: 24 PID: 2327559 at fs/btrfs/block-rsv.c:537 btrfs_use_block_rsv+0x560/0x760 [btrfs]
    [75721.581854] CPU: 24 PID: 2327559 Comm: kworker/u64:10 Kdump: loaded Tainted: G        W         5.18.0-rc2-BTRFS-ZNS+ #109
    [75721.597200] Hardware name: Supermicro Super Server/H12SSL-NT, BIOS 2.0 02/22/2021
    [75721.607310] Workqueue: btrfs-endio-write btrfs_work_helper [btrfs]
    [75721.616209] RIP: 0010:btrfs_use_block_rsv+0x560/0x760 [btrfs]
    [75721.646649] RSP: 0018:ffffc9000fbdf3e0 EFLAGS: 00010286
    [75721.654126] RAX: 0000000000000000 RBX: 0000000000004000 RCX: 0000000000000000
    [75721.663524] RDX: 0000000000000004 RSI: 0000000000000008 RDI: fffff52001f7be6e
    [75721.672921] RBP: ffffc9000fbdf420 R08: 0000000000000001 R09: ffff889f8d1fc6c7
    [75721.682493] R10: ffffed13f1a3f8d8 R11: 0000000000000001 R12: ffff88980a3c0e28
    [75721.692284] R13: ffff889b66590000 R14: ffff88980a3c0e40 R15: ffff88980a3c0e8a
    [75721.701878] FS:  0000000000000000(0000) GS:ffff889f8d000000(0000) knlGS:0000000000000000
    [75721.712601] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [75721.720726] CR2: 000055d12e05c018 CR3: 0000800193594000 CR4: 0000000000350ee0
    [75721.730499] Call Trace:
    [75721.735166]  <TASK>
    [75721.739886]  btrfs_alloc_tree_block+0x1e1/0x1100 [btrfs]
    [75721.747545]  ? btrfs_alloc_logged_file_extent+0x550/0x550 [btrfs]
    [75721.756145]  ? btrfs_get_32+0xea/0x2d0 [btrfs]
    [75721.762852]  ? btrfs_get_32+0xea/0x2d0 [btrfs]
    [75721.769520]  ? push_leaf_left+0x420/0x620 [btrfs]
    [75721.776431]  ? memcpy+0x4e/0x60
    [75721.781931]  split_leaf+0x433/0x12d0 [btrfs]
    [75721.788392]  ? btrfs_get_token_32+0x580/0x580 [btrfs]
    [75721.795636]  ? push_for_double_split.isra.0+0x420/0x420 [btrfs]
    [75721.803759]  ? leaf_space_used+0x15d/0x1a0 [btrfs]
    [75721.811156]  btrfs_search_slot+0x1bc3/0x2790 [btrfs]
    [75721.818300]  ? lock_downgrade+0x7c0/0x7c0
    [75721.824411]  ? free_extent_buffer.part.0+0x107/0x200 [btrfs]
    [75721.832456]  ? split_leaf+0x12d0/0x12d0 [btrfs]
    [75721.839149]  ? free_extent_buffer.part.0+0x14f/0x200 [btrfs]
    [75721.846945]  ? free_extent_buffer+0x13/0x20 [btrfs]
    [75721.853960]  ? btrfs_release_path+0x4b/0x190 [btrfs]
    [75721.861429]  btrfs_csum_file_blocks+0x85c/0x1500 [btrfs]
    [75721.869313]  ? rcu_read_lock_sched_held+0x16/0x80
    [75721.876085]  ? lock_release+0x552/0xf80
    [75721.881957]  ? btrfs_del_csums+0x8c0/0x8c0 [btrfs]
    [75721.888886]  ? __kasan_check_write+0x14/0x20
    [75721.895152]  ? do_raw_read_unlock+0x44/0x80
    [75721.901323]  ? _raw_write_lock_irq+0x60/0x80
    [75721.907983]  ? btrfs_global_root+0xb9/0xe0 [btrfs]
    [75721.915166]  ? btrfs_csum_root+0x12b/0x180 [btrfs]
    [75721.921918]  ? btrfs_get_global_root+0x820/0x820 [btrfs]
    [75721.929166]  ? _raw_write_unlock+0x23/0x40
    [75721.935116]  ? unpin_extent_cache+0x1e3/0x390 [btrfs]
    [75721.942041]  btrfs_finish_ordered_io.isra.0+0xa0c/0x1dc0 [btrfs]
    [75721.949906]  ? try_to_wake_up+0x30/0x14a0
    [75721.955700]  ? btrfs_unlink_subvol+0xda0/0xda0 [btrfs]
    [75721.962661]  ? rcu_read_lock_sched_held+0x16/0x80
    [75721.969111]  ? lock_acquire+0x41b/0x4c0
    [75721.974982]  finish_ordered_fn+0x15/0x20 [btrfs]
    [75721.981639]  btrfs_work_helper+0x1af/0xa80 [btrfs]
    [75721.988184]  ? _raw_spin_unlock_irq+0x28/0x50
    [75721.994643]  process_one_work+0x815/0x1460
    [75722.000444]  ? pwq_dec_nr_in_flight+0x250/0x250
    [75722.006643]  ? do_raw_spin_trylock+0xbb/0x190
    [75722.013086]  worker_thread+0x59a/0xeb0
    [75722.018511]  kthread+0x2ac/0x360
    [75722.023428]  ? process_one_work+0x1460/0x1460
    [75722.029431]  ? kthread_complete_and_exit+0x30/0x30
    [75722.036044]  ret_from_fork+0x22/0x30
    [75722.041255]  </TASK>
    [75722.045047] irq event stamp: 0
    [75722.049703] hardirqs last  enabled at (0): [<0000000000000000>] 0x0
    [75722.057610] hardirqs last disabled at (0): [<ffffffff8118a94a>] copy_process+0x1c1a/0x66b0
    [75722.067533] softirqs last  enabled at (0): [<ffffffff8118a989>] copy_process+0x1c59/0x66b0
    [75722.077423] softirqs last disabled at (0): [<0000000000000000>] 0x0
    [75722.085335] ---[ end trace 0000000000000000 ]---
    
    To fix the estimation, we need to introduce fs_info->max_extent_size to
    replace BTRFS_MAX_EXTENT_SIZE, which allow setting the different size for
    regular vs zoned filesystem.
    
    Set fs_info->max_extent_size to BTRFS_MAX_EXTENT_SIZE by default. On zoned
    filesystem, it is set to fs_info->max_zone_append_size.
    
    CC: stable@vger.kernel.org # 5.12+
    Fixes: d8e3fb106f39 ("btrfs: zoned: use ZONE_APPEND write for zoned mode")
    Reviewed-by: Johannes Thumshirn <johannes.thumshirn@wdc.com>
    Signed-off-by: Naohiro Aota <naohiro.aota@wdc.com>
    Signed-off-by: David Sterba <dsterba@suse.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 6cb4b96df97082a54634ba02196516919cda228c
Author: Naohiro Aota <naohiro.aota@wdc.com>
Date:   Sat Jul 9 08:18:40 2022 +0900

    btrfs: replace BTRFS_MAX_EXTENT_SIZE with fs_info->max_extent_size
    
    [ Upstream commit f7b12a62f008a3041f42f2426983e59a6a0a3c59 ]
    
    On zoned filesystem, data write out is limited by max_zone_append_size,
    and a large ordered extent is split according the size of a bio. OTOH,
    the number of extents to be written is calculated using
    BTRFS_MAX_EXTENT_SIZE, and that estimated number is used to reserve the
    metadata bytes to update and/or create the metadata items.
    
    The metadata reservation is done at e.g, btrfs_buffered_write() and then
    released according to the estimation changes. Thus, if the number of extent
    increases massively, the reserved metadata can run out.
    
    The increase of the number of extents easily occurs on zoned filesystem
    if BTRFS_MAX_EXTENT_SIZE > max_zone_append_size. And, it causes the
    following warning on a small RAM environment with disabling metadata
    over-commit (in the following patch).
    
    [75721.498492] ------------[ cut here ]------------
    [75721.505624] BTRFS: block rsv 1 returned -28
    [75721.512230] WARNING: CPU: 24 PID: 2327559 at fs/btrfs/block-rsv.c:537 btrfs_use_block_rsv+0x560/0x760 [btrfs]
    [75721.581854] CPU: 24 PID: 2327559 Comm: kworker/u64:10 Kdump: loaded Tainted: G        W         5.18.0-rc2-BTRFS-ZNS+ #109
    [75721.597200] Hardware name: Supermicro Super Server/H12SSL-NT, BIOS 2.0 02/22/2021
    [75721.607310] Workqueue: btrfs-endio-write btrfs_work_helper [btrfs]
    [75721.616209] RIP: 0010:btrfs_use_block_rsv+0x560/0x760 [btrfs]
    [75721.646649] RSP: 0018:ffffc9000fbdf3e0 EFLAGS: 00010286
    [75721.654126] RAX: 0000000000000000 RBX: 0000000000004000 RCX: 0000000000000000
    [75721.663524] RDX: 0000000000000004 RSI: 0000000000000008 RDI: fffff52001f7be6e
    [75721.672921] RBP: ffffc9000fbdf420 R08: 0000000000000001 R09: ffff889f8d1fc6c7
    [75721.682493] R10: ffffed13f1a3f8d8 R11: 0000000000000001 R12: ffff88980a3c0e28
    [75721.692284] R13: ffff889b66590000 R14: ffff88980a3c0e40 R15: ffff88980a3c0e8a
    [75721.701878] FS:  0000000000000000(0000) GS:ffff889f8d000000(0000) knlGS:0000000000000000
    [75721.712601] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [75721.720726] CR2: 000055d12e05c018 CR3: 0000800193594000 CR4: 0000000000350ee0
    [75721.730499] Call Trace:
    [75721.735166]  <TASK>
    [75721.739886]  btrfs_alloc_tree_block+0x1e1/0x1100 [btrfs]
    [75721.747545]  ? btrfs_alloc_logged_file_extent+0x550/0x550 [btrfs]
    [75721.756145]  ? btrfs_get_32+0xea/0x2d0 [btrfs]
    [75721.762852]  ? btrfs_get_32+0xea/0x2d0 [btrfs]
    [75721.769520]  ? push_leaf_left+0x420/0x620 [btrfs]
    [75721.776431]  ? memcpy+0x4e/0x60
    [75721.781931]  split_leaf+0x433/0x12d0 [btrfs]
    [75721.788392]  ? btrfs_get_token_32+0x580/0x580 [btrfs]
    [75721.795636]  ? push_for_double_split.isra.0+0x420/0x420 [btrfs]
    [75721.803759]  ? leaf_space_used+0x15d/0x1a0 [btrfs]
    [75721.811156]  btrfs_search_slot+0x1bc3/0x2790 [btrfs]
    [75721.818300]  ? lock_downgrade+0x7c0/0x7c0
    [75721.824411]  ? free_extent_buffer.part.0+0x107/0x200 [btrfs]
    [75721.832456]  ? split_leaf+0x12d0/0x12d0 [btrfs]
    [75721.839149]  ? free_extent_buffer.part.0+0x14f/0x200 [btrfs]
    [75721.846945]  ? free_extent_buffer+0x13/0x20 [btrfs]
    [75721.853960]  ? btrfs_release_path+0x4b/0x190 [btrfs]
    [75721.861429]  btrfs_csum_file_blocks+0x85c/0x1500 [btrfs]
    [75721.869313]  ? rcu_read_lock_sched_held+0x16/0x80
    [75721.876085]  ? lock_release+0x552/0xf80
    [75721.881957]  ? btrfs_del_csums+0x8c0/0x8c0 [btrfs]
    [75721.888886]  ? __kasan_check_write+0x14/0x20
    [75721.895152]  ? do_raw_read_unlock+0x44/0x80
    [75721.901323]  ? _raw_write_lock_irq+0x60/0x80
    [75721.907983]  ? btrfs_global_root+0xb9/0xe0 [btrfs]
    [75721.915166]  ? btrfs_csum_root+0x12b/0x180 [btrfs]
    [75721.921918]  ? btrfs_get_global_root+0x820/0x820 [btrfs]
    [75721.929166]  ? _raw_write_unlock+0x23/0x40
    [75721.935116]  ? unpin_extent_cache+0x1e3/0x390 [btrfs]
    [75721.942041]  btrfs_finish_ordered_io.isra.0+0xa0c/0x1dc0 [btrfs]
    [75721.949906]  ? try_to_wake_up+0x30/0x14a0
    [75721.955700]  ? btrfs_unlink_subvol+0xda0/0xda0 [btrfs]
    [75721.962661]  ? rcu_read_lock_sched_held+0x16/0x80
    [75721.969111]  ? lock_acquire+0x41b/0x4c0
    [75721.974982]  finish_ordered_fn+0x15/0x20 [btrfs]
    [75721.981639]  btrfs_work_helper+0x1af/0xa80 [btrfs]
    [75721.988184]  ? _raw_spin_unlock_irq+0x28/0x50
    [75721.994643]  process_one_work+0x815/0x1460
    [75722.000444]  ? pwq_dec_nr_in_flight+0x250/0x250
    [75722.006643]  ? do_raw_spin_trylock+0xbb/0x190
    [75722.013086]  worker_thread+0x59a/0xeb0
    [75722.018511]  kthread+0x2ac/0x360
    [75722.023428]  ? process_one_work+0x1460/0x1460
    [75722.029431]  ? kthread_complete_and_exit+0x30/0x30
    [75722.036044]  ret_from_fork+0x22/0x30
    [75722.041255]  </TASK>
    [75722.045047] irq event stamp: 0
    [75722.049703] hardirqs last  enabled at (0): [<0000000000000000>] 0x0
    [75722.057610] hardirqs last disabled at (0): [<ffffffff8118a94a>] copy_process+0x1c1a/0x66b0
    [75722.067533] softirqs last  enabled at (0): [<ffffffff8118a989>] copy_process+0x1c59/0x66b0
    [75722.077423] softirqs last disabled at (0): [<0000000000000000>] 0x0
    [75722.085335] ---[ end trace 0000000000000000 ]---
    
    To fix the estimation, we need to introduce fs_info->max_extent_size to
    replace BTRFS_MAX_EXTENT_SIZE, which allow setting the different size for
    regular vs zoned filesystem.
    
    Set fs_info->max_extent_size to BTRFS_MAX_EXTENT_SIZE by default. On zoned
    filesystem, it is set to fs_info->max_zone_append_size.
    
    CC: stable@vger.kernel.org # 5.12+
    Fixes: d8e3fb106f39 ("btrfs: zoned: use ZONE_APPEND write for zoned mode")
    Reviewed-by: Johannes Thumshirn <johannes.thumshirn@wdc.com>
    Signed-off-by: Naohiro Aota <naohiro.aota@wdc.com>
    Signed-off-by: David Sterba <dsterba@suse.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit f7b12a62f008a3041f42f2426983e59a6a0a3c59
Author: Naohiro Aota <naohiro.aota@wdc.com>
Date:   Sat Jul 9 08:18:40 2022 +0900

    btrfs: replace BTRFS_MAX_EXTENT_SIZE with fs_info->max_extent_size
    
    On zoned filesystem, data write out is limited by max_zone_append_size,
    and a large ordered extent is split according the size of a bio. OTOH,
    the number of extents to be written is calculated using
    BTRFS_MAX_EXTENT_SIZE, and that estimated number is used to reserve the
    metadata bytes to update and/or create the metadata items.
    
    The metadata reservation is done at e.g, btrfs_buffered_write() and then
    released according to the estimation changes. Thus, if the number of extent
    increases massively, the reserved metadata can run out.
    
    The increase of the number of extents easily occurs on zoned filesystem
    if BTRFS_MAX_EXTENT_SIZE > max_zone_append_size. And, it causes the
    following warning on a small RAM environment with disabling metadata
    over-commit (in the following patch).
    
    [75721.498492] ------------[ cut here ]------------
    [75721.505624] BTRFS: block rsv 1 returned -28
    [75721.512230] WARNING: CPU: 24 PID: 2327559 at fs/btrfs/block-rsv.c:537 btrfs_use_block_rsv+0x560/0x760 [btrfs]
    [75721.581854] CPU: 24 PID: 2327559 Comm: kworker/u64:10 Kdump: loaded Tainted: G        W         5.18.0-rc2-BTRFS-ZNS+ #109
    [75721.597200] Hardware name: Supermicro Super Server/H12SSL-NT, BIOS 2.0 02/22/2021
    [75721.607310] Workqueue: btrfs-endio-write btrfs_work_helper [btrfs]
    [75721.616209] RIP: 0010:btrfs_use_block_rsv+0x560/0x760 [btrfs]
    [75721.646649] RSP: 0018:ffffc9000fbdf3e0 EFLAGS: 00010286
    [75721.654126] RAX: 0000000000000000 RBX: 0000000000004000 RCX: 0000000000000000
    [75721.663524] RDX: 0000000000000004 RSI: 0000000000000008 RDI: fffff52001f7be6e
    [75721.672921] RBP: ffffc9000fbdf420 R08: 0000000000000001 R09: ffff889f8d1fc6c7
    [75721.682493] R10: ffffed13f1a3f8d8 R11: 0000000000000001 R12: ffff88980a3c0e28
    [75721.692284] R13: ffff889b66590000 R14: ffff88980a3c0e40 R15: ffff88980a3c0e8a
    [75721.701878] FS:  0000000000000000(0000) GS:ffff889f8d000000(0000) knlGS:0000000000000000
    [75721.712601] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [75721.720726] CR2: 000055d12e05c018 CR3: 0000800193594000 CR4: 0000000000350ee0
    [75721.730499] Call Trace:
    [75721.735166]  <TASK>
    [75721.739886]  btrfs_alloc_tree_block+0x1e1/0x1100 [btrfs]
    [75721.747545]  ? btrfs_alloc_logged_file_extent+0x550/0x550 [btrfs]
    [75721.756145]  ? btrfs_get_32+0xea/0x2d0 [btrfs]
    [75721.762852]  ? btrfs_get_32+0xea/0x2d0 [btrfs]
    [75721.769520]  ? push_leaf_left+0x420/0x620 [btrfs]
    [75721.776431]  ? memcpy+0x4e/0x60
    [75721.781931]  split_leaf+0x433/0x12d0 [btrfs]
    [75721.788392]  ? btrfs_get_token_32+0x580/0x580 [btrfs]
    [75721.795636]  ? push_for_double_split.isra.0+0x420/0x420 [btrfs]
    [75721.803759]  ? leaf_space_used+0x15d/0x1a0 [btrfs]
    [75721.811156]  btrfs_search_slot+0x1bc3/0x2790 [btrfs]
    [75721.818300]  ? lock_downgrade+0x7c0/0x7c0
    [75721.824411]  ? free_extent_buffer.part.0+0x107/0x200 [btrfs]
    [75721.832456]  ? split_leaf+0x12d0/0x12d0 [btrfs]
    [75721.839149]  ? free_extent_buffer.part.0+0x14f/0x200 [btrfs]
    [75721.846945]  ? free_extent_buffer+0x13/0x20 [btrfs]
    [75721.853960]  ? btrfs_release_path+0x4b/0x190 [btrfs]
    [75721.861429]  btrfs_csum_file_blocks+0x85c/0x1500 [btrfs]
    [75721.869313]  ? rcu_read_lock_sched_held+0x16/0x80
    [75721.876085]  ? lock_release+0x552/0xf80
    [75721.881957]  ? btrfs_del_csums+0x8c0/0x8c0 [btrfs]
    [75721.888886]  ? __kasan_check_write+0x14/0x20
    [75721.895152]  ? do_raw_read_unlock+0x44/0x80
    [75721.901323]  ? _raw_write_lock_irq+0x60/0x80
    [75721.907983]  ? btrfs_global_root+0xb9/0xe0 [btrfs]
    [75721.915166]  ? btrfs_csum_root+0x12b/0x180 [btrfs]
    [75721.921918]  ? btrfs_get_global_root+0x820/0x820 [btrfs]
    [75721.929166]  ? _raw_write_unlock+0x23/0x40
    [75721.935116]  ? unpin_extent_cache+0x1e3/0x390 [btrfs]
    [75721.942041]  btrfs_finish_ordered_io.isra.0+0xa0c/0x1dc0 [btrfs]
    [75721.949906]  ? try_to_wake_up+0x30/0x14a0
    [75721.955700]  ? btrfs_unlink_subvol+0xda0/0xda0 [btrfs]
    [75721.962661]  ? rcu_read_lock_sched_held+0x16/0x80
    [75721.969111]  ? lock_acquire+0x41b/0x4c0
    [75721.974982]  finish_ordered_fn+0x15/0x20 [btrfs]
    [75721.981639]  btrfs_work_helper+0x1af/0xa80 [btrfs]
    [75721.988184]  ? _raw_spin_unlock_irq+0x28/0x50
    [75721.994643]  process_one_work+0x815/0x1460
    [75722.000444]  ? pwq_dec_nr_in_flight+0x250/0x250
    [75722.006643]  ? do_raw_spin_trylock+0xbb/0x190
    [75722.013086]  worker_thread+0x59a/0xeb0
    [75722.018511]  kthread+0x2ac/0x360
    [75722.023428]  ? process_one_work+0x1460/0x1460
    [75722.029431]  ? kthread_complete_and_exit+0x30/0x30
    [75722.036044]  ret_from_fork+0x22/0x30
    [75722.041255]  </TASK>
    [75722.045047] irq event stamp: 0
    [75722.049703] hardirqs last  enabled at (0): [<0000000000000000>] 0x0
    [75722.057610] hardirqs last disabled at (0): [<ffffffff8118a94a>] copy_process+0x1c1a/0x66b0
    [75722.067533] softirqs last  enabled at (0): [<ffffffff8118a989>] copy_process+0x1c59/0x66b0
    [75722.077423] softirqs last disabled at (0): [<0000000000000000>] 0x0
    [75722.085335] ---[ end trace 0000000000000000 ]---
    
    To fix the estimation, we need to introduce fs_info->max_extent_size to
    replace BTRFS_MAX_EXTENT_SIZE, which allow setting the different size for
    regular vs zoned filesystem.
    
    Set fs_info->max_extent_size to BTRFS_MAX_EXTENT_SIZE by default. On zoned
    filesystem, it is set to fs_info->max_zone_append_size.
    
    CC: stable@vger.kernel.org # 5.12+
    Fixes: d8e3fb106f39 ("btrfs: zoned: use ZONE_APPEND write for zoned mode")
    Reviewed-by: Johannes Thumshirn <johannes.thumshirn@wdc.com>
    Signed-off-by: Naohiro Aota <naohiro.aota@wdc.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

commit 4a557a5d1a6145ea586dc9b17a9b4e5190c9c017
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jun 30 09:34:10 2022 -0700

    sparse: introduce conditional lock acquire function attribute
    
    The kernel tends to try to avoid conditional locking semantics because
    it makes it harder to think about and statically check locking rules,
    but we do have a few fundamental locking primitives that take locks
    conditionally - most obviously the 'trylock' functions.
    
    That has always been a problem for 'sparse' checking for locking
    imbalance, and we've had a special '__cond_lock()' macro that we've used
    to let sparse know how the locking works:
    
        # define __cond_lock(x,c)        ((c) ? ({ __acquire(x); 1; }) : 0)
    
    so that you can then use this to tell sparse that (for example) the
    spinlock trylock macro ends up acquiring the lock when it succeeds, but
    not when it fails:
    
        #define raw_spin_trylock(lock)  __cond_lock(lock, _raw_spin_trylock(lock))
    
    and then sparse can follow along the locking rules when you have code like
    
            if (!spin_trylock(&dentry->d_lock))
                    return LRU_SKIP;
            .. sparse sees that the lock is held here..
            spin_unlock(&dentry->d_lock);
    
    and sparse ends up happy about the lock contexts.
    
    However, this '__cond_lock()' use does result in very ugly header files,
    and requires you to basically wrap the real function with that macro
    that uses '__cond_lock'.  Which has made PeterZ NAK things that try to
    fix sparse warnings over the years [1].
    
    To solve this, there is now a very experimental patch to sparse that
    basically does the exact same thing as '__cond_lock()' did, but using a
    function attribute instead.  That seems to make PeterZ happy [2].
    
    Note that this does not replace existing use of '__cond_lock()', but
    only exposes the new proposed attribute and uses it for the previously
    unannotated 'refcount_dec_and_lock()' family of functions.
    
    For existing sparse installations, this will make no difference (a
    negative output context was ignored), but if you have the experimental
    sparse patch it will make sparse now understand code that uses those
    functions, the same way '__cond_lock()' makes sparse understand the very
    similar 'atomic_dec_and_lock()' uses that have the old '__cond_lock()'
    annotations.
    
    Note that in some cases this will silence existing context imbalance
    warnings.  But in other cases it may end up exposing new sparse warnings
    for code that sparse just didn't see the locking for at all before.
    
    This is a trial, in other words.  I'd expect that if it ends up being
    successful, and new sparse releases end up having this new attribute,
    we'll migrate the old-style '__cond_lock()' users to use the new-style
    '__cond_acquires' function attribute.
    
    The actual experimental sparse patch was posted in [3].
    
    Link: https://lore.kernel.org/all/20130930134434.GC12926@twins.programming.kicks-ass.net/ [1]
    Link: https://lore.kernel.org/all/Yr60tWxN4P568x3W@worktop.programming.kicks-ass.net/ [2]
    Link: https://lore.kernel.org/all/CAHk-=wjZfO9hGqJ2_hGQG3U_XzSh9_XaXze=HgPdvJbgrvASfA@mail.gmail.com/ [3]
    Acked-by: Peter Zijlstra <peterz@infradead.org>
    Cc: Alexander Aring <aahringo@redhat.com>
    Cc: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit 1fa37b00dc55a061a3eb82e378849862b4aeca9d
Author: Yunfei Dong <yunfei.dong@mediatek.com>
Date:   Thu May 12 04:19:50 2022 +0200

    media: mediatek: vcodec: prevent kernel crash when rmmod mtk-vcodec-dec.ko
    
    [ Upstream commit c10c0086db688c95bb4e0e378e523818dff1551d ]
    
    If the driver support subdev mode, the parameter "dev->pm.dev" will be
    NULL in mtk_vcodec_dec_remove. Kernel will crash when try to rmmod
    mtk-vcodec-dec.ko.
    
    [ 4380.702726] pc : do_raw_spin_trylock+0x4/0x80
    [ 4380.707075] lr : _raw_spin_lock_irq+0x90/0x14c
    [ 4380.711509] sp : ffff80000819bc10
    [ 4380.714811] x29: ffff80000819bc10 x28: ffff3600c03e4000 x27: 0000000000000000
    [ 4380.721934] x26: 0000000000000000 x25: 0000000000000000 x24: 0000000000000000
    [ 4380.729057] x23: ffff3600c0f34930 x22: ffffd5e923549000 x21: 0000000000000220
    [ 4380.736179] x20: 0000000000000208 x19: ffffd5e9213e8ebc x18: 0000000000000020
    [ 4380.743298] x17: 0000002000000000 x16: ffffd5e9213e8e90 x15: 696c346f65646976
    [ 4380.750420] x14: 0000000000000000 x13: 0000000000000001 x12: 0000000000000040
    [ 4380.757542] x11: 0000000000000000 x10: 0000000000000000 x9 : 0000000000000000
    [ 4380.764664] x8 : 0000000000000000 x7 : ffff3600c7273ae8 x6 : ffffd5e9213e8ebc
    [ 4380.771786] x5 : 0000000000000000 x4 : 0000000000000001 x3 : 0000000000000000
    [ 4380.778908] x2 : 0000000000000000 x1 : ffff3600c03e4000 x0 : 0000000000000208
    [ 4380.786031] Call trace:
    [ 4380.788465]  do_raw_spin_trylock+0x4/0x80
    [ 4380.792462]  __pm_runtime_disable+0x2c/0x1b0
    [ 4380.796723]  mtk_vcodec_dec_remove+0x5c/0xa0 [mtk_vcodec_dec]
    [ 4380.802466]  platform_remove+0x2c/0x60
    [ 4380.806204]  __device_release_driver+0x194/0x250
    [ 4380.810810]  driver_detach+0xc8/0x15c
    [ 4380.814462]  bus_remove_driver+0x5c/0xb0
    [ 4380.818375]  driver_unregister+0x34/0x64
    [ 4380.822288]  platform_driver_unregister+0x18/0x24
    [ 4380.826979]  mtk_vcodec_dec_driver_exit+0x1c/0x888 [mtk_vcodec_dec]
    [ 4380.833240]  __arm64_sys_delete_module+0x190/0x224
    [ 4380.838020]  invoke_syscall+0x48/0x114
    [ 4380.841760]  el0_svc_common.constprop.0+0x60/0x11c
    [ 4380.846540]  do_el0_svc+0x28/0x90
    [ 4380.849844]  el0_svc+0x4c/0x100
    [ 4380.852975]  el0t_64_sync_handler+0xec/0xf0
    [ 4380.857148]  el0t_64_sync+0x190/0x194
    [ 4380.860801] Code: 94431515 17ffffca d503201f d503245f (b9400004)
    
    Signed-off-by: Yunfei Dong <yunfei.dong@mediatek.com>
    Tested-by: Ncolas F. R. A. Prado <nfraprado@collabora.com>
    Signed-off-by: Hans Verkuil <hverkuil-cisco@xs4all.nl>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@kernel.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit c10c0086db688c95bb4e0e378e523818dff1551d
Author: Yunfei Dong <yunfei.dong@mediatek.com>
Date:   Thu May 12 04:19:50 2022 +0200

    media: mediatek: vcodec: prevent kernel crash when rmmod mtk-vcodec-dec.ko
    
    If the driver support subdev mode, the parameter "dev->pm.dev" will be
    NULL in mtk_vcodec_dec_remove. Kernel will crash when try to rmmod
    mtk-vcodec-dec.ko.
    
    [ 4380.702726] pc : do_raw_spin_trylock+0x4/0x80
    [ 4380.707075] lr : _raw_spin_lock_irq+0x90/0x14c
    [ 4380.711509] sp : ffff80000819bc10
    [ 4380.714811] x29: ffff80000819bc10 x28: ffff3600c03e4000 x27: 0000000000000000
    [ 4380.721934] x26: 0000000000000000 x25: 0000000000000000 x24: 0000000000000000
    [ 4380.729057] x23: ffff3600c0f34930 x22: ffffd5e923549000 x21: 0000000000000220
    [ 4380.736179] x20: 0000000000000208 x19: ffffd5e9213e8ebc x18: 0000000000000020
    [ 4380.743298] x17: 0000002000000000 x16: ffffd5e9213e8e90 x15: 696c346f65646976
    [ 4380.750420] x14: 0000000000000000 x13: 0000000000000001 x12: 0000000000000040
    [ 4380.757542] x11: 0000000000000000 x10: 0000000000000000 x9 : 0000000000000000
    [ 4380.764664] x8 : 0000000000000000 x7 : ffff3600c7273ae8 x6 : ffffd5e9213e8ebc
    [ 4380.771786] x5 : 0000000000000000 x4 : 0000000000000001 x3 : 0000000000000000
    [ 4380.778908] x2 : 0000000000000000 x1 : ffff3600c03e4000 x0 : 0000000000000208
    [ 4380.786031] Call trace:
    [ 4380.788465]  do_raw_spin_trylock+0x4/0x80
    [ 4380.792462]  __pm_runtime_disable+0x2c/0x1b0
    [ 4380.796723]  mtk_vcodec_dec_remove+0x5c/0xa0 [mtk_vcodec_dec]
    [ 4380.802466]  platform_remove+0x2c/0x60
    [ 4380.806204]  __device_release_driver+0x194/0x250
    [ 4380.810810]  driver_detach+0xc8/0x15c
    [ 4380.814462]  bus_remove_driver+0x5c/0xb0
    [ 4380.818375]  driver_unregister+0x34/0x64
    [ 4380.822288]  platform_driver_unregister+0x18/0x24
    [ 4380.826979]  mtk_vcodec_dec_driver_exit+0x1c/0x888 [mtk_vcodec_dec]
    [ 4380.833240]  __arm64_sys_delete_module+0x190/0x224
    [ 4380.838020]  invoke_syscall+0x48/0x114
    [ 4380.841760]  el0_svc_common.constprop.0+0x60/0x11c
    [ 4380.846540]  do_el0_svc+0x28/0x90
    [ 4380.849844]  el0_svc+0x4c/0x100
    [ 4380.852975]  el0t_64_sync_handler+0xec/0xf0
    [ 4380.857148]  el0t_64_sync+0x190/0x194
    [ 4380.860801] Code: 94431515 17ffffca d503201f d503245f (b9400004)
    
    Signed-off-by: Yunfei Dong <yunfei.dong@mediatek.com>
    Tested-by: Ncolas F. R. A. Prado <nfraprado@collabora.com>
    Signed-off-by: Hans Verkuil <hverkuil-cisco@xs4all.nl>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@kernel.org>

commit 2d24336c7214b281b51860e54783dfc65f1248df
Author: John Meneghini <jmeneghi@redhat.com>
Date:   Mon Jan 24 09:51:10 2022 -0500

    scsi: bnx2fc: Make bnx2fc_recv_frame() mp safe
    
    commit 936bd03405fc83ba039d42bc93ffd4b88418f1d3 upstream.
    
    Running tests with a debug kernel shows that bnx2fc_recv_frame() is
    modifying the per_cpu lport stats counters in a non-mpsafe way.  Just boot
    a debug kernel and run the bnx2fc driver with the hardware enabled.
    
    [ 1391.699147] BUG: using smp_processor_id() in preemptible [00000000] code: bnx2fc_
    [ 1391.699160] caller is bnx2fc_recv_frame+0xbf9/0x1760 [bnx2fc]
    [ 1391.699174] CPU: 2 PID: 4355 Comm: bnx2fc_l2_threa Kdump: loaded Tainted: G    B
    [ 1391.699180] Hardware name: HP ProLiant DL120 G7, BIOS J01 07/01/2013
    [ 1391.699183] Call Trace:
    [ 1391.699188]  dump_stack_lvl+0x57/0x7d
    [ 1391.699198]  check_preemption_disabled+0xc8/0xd0
    [ 1391.699205]  bnx2fc_recv_frame+0xbf9/0x1760 [bnx2fc]
    [ 1391.699215]  ? do_raw_spin_trylock+0xb5/0x180
    [ 1391.699221]  ? bnx2fc_npiv_create_vports.isra.0+0x4e0/0x4e0 [bnx2fc]
    [ 1391.699229]  ? bnx2fc_l2_rcv_thread+0xb7/0x3a0 [bnx2fc]
    [ 1391.699240]  bnx2fc_l2_rcv_thread+0x1af/0x3a0 [bnx2fc]
    [ 1391.699250]  ? bnx2fc_ulp_init+0xc0/0xc0 [bnx2fc]
    [ 1391.699258]  kthread+0x364/0x420
    [ 1391.699263]  ? _raw_spin_unlock_irq+0x24/0x50
    [ 1391.699268]  ? set_kthread_struct+0x100/0x100
    [ 1391.699273]  ret_from_fork+0x22/0x30
    
    Restore the old get_cpu/put_cpu code with some modifications to reduce the
    size of the critical section.
    
    Link: https://lore.kernel.org/r/20220124145110.442335-1-jmeneghi@redhat.com
    Fixes: d576a5e80cd0 ("bnx2fc: Improve stats update mechanism")
    Tested-by: Guangwu Zhang <guazhang@redhat.com>
    Acked-by: Saurav Kashyap <skashyap@marvell.com>
    Signed-off-by: John Meneghini <jmeneghi@redhat.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 2f5a1ac68bdf2899ce822ab845081922ea8c588e
Author: John Meneghini <jmeneghi@redhat.com>
Date:   Mon Jan 24 09:51:10 2022 -0500

    scsi: bnx2fc: Make bnx2fc_recv_frame() mp safe
    
    commit 936bd03405fc83ba039d42bc93ffd4b88418f1d3 upstream.
    
    Running tests with a debug kernel shows that bnx2fc_recv_frame() is
    modifying the per_cpu lport stats counters in a non-mpsafe way.  Just boot
    a debug kernel and run the bnx2fc driver with the hardware enabled.
    
    [ 1391.699147] BUG: using smp_processor_id() in preemptible [00000000] code: bnx2fc_
    [ 1391.699160] caller is bnx2fc_recv_frame+0xbf9/0x1760 [bnx2fc]
    [ 1391.699174] CPU: 2 PID: 4355 Comm: bnx2fc_l2_threa Kdump: loaded Tainted: G    B
    [ 1391.699180] Hardware name: HP ProLiant DL120 G7, BIOS J01 07/01/2013
    [ 1391.699183] Call Trace:
    [ 1391.699188]  dump_stack_lvl+0x57/0x7d
    [ 1391.699198]  check_preemption_disabled+0xc8/0xd0
    [ 1391.699205]  bnx2fc_recv_frame+0xbf9/0x1760 [bnx2fc]
    [ 1391.699215]  ? do_raw_spin_trylock+0xb5/0x180
    [ 1391.699221]  ? bnx2fc_npiv_create_vports.isra.0+0x4e0/0x4e0 [bnx2fc]
    [ 1391.699229]  ? bnx2fc_l2_rcv_thread+0xb7/0x3a0 [bnx2fc]
    [ 1391.699240]  bnx2fc_l2_rcv_thread+0x1af/0x3a0 [bnx2fc]
    [ 1391.699250]  ? bnx2fc_ulp_init+0xc0/0xc0 [bnx2fc]
    [ 1391.699258]  kthread+0x364/0x420
    [ 1391.699263]  ? _raw_spin_unlock_irq+0x24/0x50
    [ 1391.699268]  ? set_kthread_struct+0x100/0x100
    [ 1391.699273]  ret_from_fork+0x22/0x30
    
    Restore the old get_cpu/put_cpu code with some modifications to reduce the
    size of the critical section.
    
    Link: https://lore.kernel.org/r/20220124145110.442335-1-jmeneghi@redhat.com
    Fixes: d576a5e80cd0 ("bnx2fc: Improve stats update mechanism")
    Tested-by: Guangwu Zhang <guazhang@redhat.com>
    Acked-by: Saurav Kashyap <skashyap@marvell.com>
    Signed-off-by: John Meneghini <jmeneghi@redhat.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit ec4334152dae175dbd8fd5bde1d2139bbe7b42d0
Author: John Meneghini <jmeneghi@redhat.com>
Date:   Mon Jan 24 09:51:10 2022 -0500

    scsi: bnx2fc: Make bnx2fc_recv_frame() mp safe
    
    commit 936bd03405fc83ba039d42bc93ffd4b88418f1d3 upstream.
    
    Running tests with a debug kernel shows that bnx2fc_recv_frame() is
    modifying the per_cpu lport stats counters in a non-mpsafe way.  Just boot
    a debug kernel and run the bnx2fc driver with the hardware enabled.
    
    [ 1391.699147] BUG: using smp_processor_id() in preemptible [00000000] code: bnx2fc_
    [ 1391.699160] caller is bnx2fc_recv_frame+0xbf9/0x1760 [bnx2fc]
    [ 1391.699174] CPU: 2 PID: 4355 Comm: bnx2fc_l2_threa Kdump: loaded Tainted: G    B
    [ 1391.699180] Hardware name: HP ProLiant DL120 G7, BIOS J01 07/01/2013
    [ 1391.699183] Call Trace:
    [ 1391.699188]  dump_stack_lvl+0x57/0x7d
    [ 1391.699198]  check_preemption_disabled+0xc8/0xd0
    [ 1391.699205]  bnx2fc_recv_frame+0xbf9/0x1760 [bnx2fc]
    [ 1391.699215]  ? do_raw_spin_trylock+0xb5/0x180
    [ 1391.699221]  ? bnx2fc_npiv_create_vports.isra.0+0x4e0/0x4e0 [bnx2fc]
    [ 1391.699229]  ? bnx2fc_l2_rcv_thread+0xb7/0x3a0 [bnx2fc]
    [ 1391.699240]  bnx2fc_l2_rcv_thread+0x1af/0x3a0 [bnx2fc]
    [ 1391.699250]  ? bnx2fc_ulp_init+0xc0/0xc0 [bnx2fc]
    [ 1391.699258]  kthread+0x364/0x420
    [ 1391.699263]  ? _raw_spin_unlock_irq+0x24/0x50
    [ 1391.699268]  ? set_kthread_struct+0x100/0x100
    [ 1391.699273]  ret_from_fork+0x22/0x30
    
    Restore the old get_cpu/put_cpu code with some modifications to reduce the
    size of the critical section.
    
    Link: https://lore.kernel.org/r/20220124145110.442335-1-jmeneghi@redhat.com
    Fixes: d576a5e80cd0 ("bnx2fc: Improve stats update mechanism")
    Tested-by: Guangwu Zhang <guazhang@redhat.com>
    Acked-by: Saurav Kashyap <skashyap@marvell.com>
    Signed-off-by: John Meneghini <jmeneghi@redhat.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 53e4f71763c61a557283eb43301efd671922d1e8
Author: John Meneghini <jmeneghi@redhat.com>
Date:   Mon Jan 24 09:51:10 2022 -0500

    scsi: bnx2fc: Make bnx2fc_recv_frame() mp safe
    
    commit 936bd03405fc83ba039d42bc93ffd4b88418f1d3 upstream.
    
    Running tests with a debug kernel shows that bnx2fc_recv_frame() is
    modifying the per_cpu lport stats counters in a non-mpsafe way.  Just boot
    a debug kernel and run the bnx2fc driver with the hardware enabled.
    
    [ 1391.699147] BUG: using smp_processor_id() in preemptible [00000000] code: bnx2fc_
    [ 1391.699160] caller is bnx2fc_recv_frame+0xbf9/0x1760 [bnx2fc]
    [ 1391.699174] CPU: 2 PID: 4355 Comm: bnx2fc_l2_threa Kdump: loaded Tainted: G    B
    [ 1391.699180] Hardware name: HP ProLiant DL120 G7, BIOS J01 07/01/2013
    [ 1391.699183] Call Trace:
    [ 1391.699188]  dump_stack_lvl+0x57/0x7d
    [ 1391.699198]  check_preemption_disabled+0xc8/0xd0
    [ 1391.699205]  bnx2fc_recv_frame+0xbf9/0x1760 [bnx2fc]
    [ 1391.699215]  ? do_raw_spin_trylock+0xb5/0x180
    [ 1391.699221]  ? bnx2fc_npiv_create_vports.isra.0+0x4e0/0x4e0 [bnx2fc]
    [ 1391.699229]  ? bnx2fc_l2_rcv_thread+0xb7/0x3a0 [bnx2fc]
    [ 1391.699240]  bnx2fc_l2_rcv_thread+0x1af/0x3a0 [bnx2fc]
    [ 1391.699250]  ? bnx2fc_ulp_init+0xc0/0xc0 [bnx2fc]
    [ 1391.699258]  kthread+0x364/0x420
    [ 1391.699263]  ? _raw_spin_unlock_irq+0x24/0x50
    [ 1391.699268]  ? set_kthread_struct+0x100/0x100
    [ 1391.699273]  ret_from_fork+0x22/0x30
    
    Restore the old get_cpu/put_cpu code with some modifications to reduce the
    size of the critical section.
    
    Link: https://lore.kernel.org/r/20220124145110.442335-1-jmeneghi@redhat.com
    Fixes: d576a5e80cd0 ("bnx2fc: Improve stats update mechanism")
    Tested-by: Guangwu Zhang <guazhang@redhat.com>
    Acked-by: Saurav Kashyap <skashyap@marvell.com>
    Signed-off-by: John Meneghini <jmeneghi@redhat.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 003bcee66a8f0e76157eb3af369c173151901d97
Author: John Meneghini <jmeneghi@redhat.com>
Date:   Mon Jan 24 09:51:10 2022 -0500

    scsi: bnx2fc: Make bnx2fc_recv_frame() mp safe
    
    commit 936bd03405fc83ba039d42bc93ffd4b88418f1d3 upstream.
    
    Running tests with a debug kernel shows that bnx2fc_recv_frame() is
    modifying the per_cpu lport stats counters in a non-mpsafe way.  Just boot
    a debug kernel and run the bnx2fc driver with the hardware enabled.
    
    [ 1391.699147] BUG: using smp_processor_id() in preemptible [00000000] code: bnx2fc_
    [ 1391.699160] caller is bnx2fc_recv_frame+0xbf9/0x1760 [bnx2fc]
    [ 1391.699174] CPU: 2 PID: 4355 Comm: bnx2fc_l2_threa Kdump: loaded Tainted: G    B
    [ 1391.699180] Hardware name: HP ProLiant DL120 G7, BIOS J01 07/01/2013
    [ 1391.699183] Call Trace:
    [ 1391.699188]  dump_stack_lvl+0x57/0x7d
    [ 1391.699198]  check_preemption_disabled+0xc8/0xd0
    [ 1391.699205]  bnx2fc_recv_frame+0xbf9/0x1760 [bnx2fc]
    [ 1391.699215]  ? do_raw_spin_trylock+0xb5/0x180
    [ 1391.699221]  ? bnx2fc_npiv_create_vports.isra.0+0x4e0/0x4e0 [bnx2fc]
    [ 1391.699229]  ? bnx2fc_l2_rcv_thread+0xb7/0x3a0 [bnx2fc]
    [ 1391.699240]  bnx2fc_l2_rcv_thread+0x1af/0x3a0 [bnx2fc]
    [ 1391.699250]  ? bnx2fc_ulp_init+0xc0/0xc0 [bnx2fc]
    [ 1391.699258]  kthread+0x364/0x420
    [ 1391.699263]  ? _raw_spin_unlock_irq+0x24/0x50
    [ 1391.699268]  ? set_kthread_struct+0x100/0x100
    [ 1391.699273]  ret_from_fork+0x22/0x30
    
    Restore the old get_cpu/put_cpu code with some modifications to reduce the
    size of the critical section.
    
    Link: https://lore.kernel.org/r/20220124145110.442335-1-jmeneghi@redhat.com
    Fixes: d576a5e80cd0 ("bnx2fc: Improve stats update mechanism")
    Tested-by: Guangwu Zhang <guazhang@redhat.com>
    Acked-by: Saurav Kashyap <skashyap@marvell.com>
    Signed-off-by: John Meneghini <jmeneghi@redhat.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 471085571f926a1fe6b1bed095638994dbf23990
Author: John Meneghini <jmeneghi@redhat.com>
Date:   Mon Jan 24 09:51:10 2022 -0500

    scsi: bnx2fc: Make bnx2fc_recv_frame() mp safe
    
    commit 936bd03405fc83ba039d42bc93ffd4b88418f1d3 upstream.
    
    Running tests with a debug kernel shows that bnx2fc_recv_frame() is
    modifying the per_cpu lport stats counters in a non-mpsafe way.  Just boot
    a debug kernel and run the bnx2fc driver with the hardware enabled.
    
    [ 1391.699147] BUG: using smp_processor_id() in preemptible [00000000] code: bnx2fc_
    [ 1391.699160] caller is bnx2fc_recv_frame+0xbf9/0x1760 [bnx2fc]
    [ 1391.699174] CPU: 2 PID: 4355 Comm: bnx2fc_l2_threa Kdump: loaded Tainted: G    B
    [ 1391.699180] Hardware name: HP ProLiant DL120 G7, BIOS J01 07/01/2013
    [ 1391.699183] Call Trace:
    [ 1391.699188]  dump_stack_lvl+0x57/0x7d
    [ 1391.699198]  check_preemption_disabled+0xc8/0xd0
    [ 1391.699205]  bnx2fc_recv_frame+0xbf9/0x1760 [bnx2fc]
    [ 1391.699215]  ? do_raw_spin_trylock+0xb5/0x180
    [ 1391.699221]  ? bnx2fc_npiv_create_vports.isra.0+0x4e0/0x4e0 [bnx2fc]
    [ 1391.699229]  ? bnx2fc_l2_rcv_thread+0xb7/0x3a0 [bnx2fc]
    [ 1391.699240]  bnx2fc_l2_rcv_thread+0x1af/0x3a0 [bnx2fc]
    [ 1391.699250]  ? bnx2fc_ulp_init+0xc0/0xc0 [bnx2fc]
    [ 1391.699258]  kthread+0x364/0x420
    [ 1391.699263]  ? _raw_spin_unlock_irq+0x24/0x50
    [ 1391.699268]  ? set_kthread_struct+0x100/0x100
    [ 1391.699273]  ret_from_fork+0x22/0x30
    
    Restore the old get_cpu/put_cpu code with some modifications to reduce the
    size of the critical section.
    
    Link: https://lore.kernel.org/r/20220124145110.442335-1-jmeneghi@redhat.com
    Fixes: d576a5e80cd0 ("bnx2fc: Improve stats update mechanism")
    Tested-by: Guangwu Zhang <guazhang@redhat.com>
    Acked-by: Saurav Kashyap <skashyap@marvell.com>
    Signed-off-by: John Meneghini <jmeneghi@redhat.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 3a345198a7c2d1db2526dc60b77052f75de019d3
Author: John Meneghini <jmeneghi@redhat.com>
Date:   Mon Jan 24 09:51:10 2022 -0500

    scsi: bnx2fc: Make bnx2fc_recv_frame() mp safe
    
    commit 936bd03405fc83ba039d42bc93ffd4b88418f1d3 upstream.
    
    Running tests with a debug kernel shows that bnx2fc_recv_frame() is
    modifying the per_cpu lport stats counters in a non-mpsafe way.  Just boot
    a debug kernel and run the bnx2fc driver with the hardware enabled.
    
    [ 1391.699147] BUG: using smp_processor_id() in preemptible [00000000] code: bnx2fc_
    [ 1391.699160] caller is bnx2fc_recv_frame+0xbf9/0x1760 [bnx2fc]
    [ 1391.699174] CPU: 2 PID: 4355 Comm: bnx2fc_l2_threa Kdump: loaded Tainted: G    B
    [ 1391.699180] Hardware name: HP ProLiant DL120 G7, BIOS J01 07/01/2013
    [ 1391.699183] Call Trace:
    [ 1391.699188]  dump_stack_lvl+0x57/0x7d
    [ 1391.699198]  check_preemption_disabled+0xc8/0xd0
    [ 1391.699205]  bnx2fc_recv_frame+0xbf9/0x1760 [bnx2fc]
    [ 1391.699215]  ? do_raw_spin_trylock+0xb5/0x180
    [ 1391.699221]  ? bnx2fc_npiv_create_vports.isra.0+0x4e0/0x4e0 [bnx2fc]
    [ 1391.699229]  ? bnx2fc_l2_rcv_thread+0xb7/0x3a0 [bnx2fc]
    [ 1391.699240]  bnx2fc_l2_rcv_thread+0x1af/0x3a0 [bnx2fc]
    [ 1391.699250]  ? bnx2fc_ulp_init+0xc0/0xc0 [bnx2fc]
    [ 1391.699258]  kthread+0x364/0x420
    [ 1391.699263]  ? _raw_spin_unlock_irq+0x24/0x50
    [ 1391.699268]  ? set_kthread_struct+0x100/0x100
    [ 1391.699273]  ret_from_fork+0x22/0x30
    
    Restore the old get_cpu/put_cpu code with some modifications to reduce the
    size of the critical section.
    
    Link: https://lore.kernel.org/r/20220124145110.442335-1-jmeneghi@redhat.com
    Fixes: d576a5e80cd0 ("bnx2fc: Improve stats update mechanism")
    Tested-by: Guangwu Zhang <guazhang@redhat.com>
    Acked-by: Saurav Kashyap <skashyap@marvell.com>
    Signed-off-by: John Meneghini <jmeneghi@redhat.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 936bd03405fc83ba039d42bc93ffd4b88418f1d3
Author: John Meneghini <jmeneghi@redhat.com>
Date:   Mon Jan 24 09:51:10 2022 -0500

    scsi: bnx2fc: Make bnx2fc_recv_frame() mp safe
    
    Running tests with a debug kernel shows that bnx2fc_recv_frame() is
    modifying the per_cpu lport stats counters in a non-mpsafe way.  Just boot
    a debug kernel and run the bnx2fc driver with the hardware enabled.
    
    [ 1391.699147] BUG: using smp_processor_id() in preemptible [00000000] code: bnx2fc_
    [ 1391.699160] caller is bnx2fc_recv_frame+0xbf9/0x1760 [bnx2fc]
    [ 1391.699174] CPU: 2 PID: 4355 Comm: bnx2fc_l2_threa Kdump: loaded Tainted: G    B
    [ 1391.699180] Hardware name: HP ProLiant DL120 G7, BIOS J01 07/01/2013
    [ 1391.699183] Call Trace:
    [ 1391.699188]  dump_stack_lvl+0x57/0x7d
    [ 1391.699198]  check_preemption_disabled+0xc8/0xd0
    [ 1391.699205]  bnx2fc_recv_frame+0xbf9/0x1760 [bnx2fc]
    [ 1391.699215]  ? do_raw_spin_trylock+0xb5/0x180
    [ 1391.699221]  ? bnx2fc_npiv_create_vports.isra.0+0x4e0/0x4e0 [bnx2fc]
    [ 1391.699229]  ? bnx2fc_l2_rcv_thread+0xb7/0x3a0 [bnx2fc]
    [ 1391.699240]  bnx2fc_l2_rcv_thread+0x1af/0x3a0 [bnx2fc]
    [ 1391.699250]  ? bnx2fc_ulp_init+0xc0/0xc0 [bnx2fc]
    [ 1391.699258]  kthread+0x364/0x420
    [ 1391.699263]  ? _raw_spin_unlock_irq+0x24/0x50
    [ 1391.699268]  ? set_kthread_struct+0x100/0x100
    [ 1391.699273]  ret_from_fork+0x22/0x30
    
    Restore the old get_cpu/put_cpu code with some modifications to reduce the
    size of the critical section.
    
    Link: https://lore.kernel.org/r/20220124145110.442335-1-jmeneghi@redhat.com
    Fixes: d576a5e80cd0 ("bnx2fc: Improve stats update mechanism")
    Tested-by: Guangwu Zhang <guazhang@redhat.com>
    Acked-by: Saurav Kashyap <skashyap@marvell.com>
    Signed-off-by: John Meneghini <jmeneghi@redhat.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

commit 1081a9ac20c1721c080a582bce6307c4fe6e42e1
Author: Zekun Shen <bruceshenzk@gmail.com>
Date:   Thu Oct 28 18:21:42 2021 -0400

    ath9k: Fix out-of-bound memcpy in ath9k_hif_usb_rx_stream
    
    [ Upstream commit 6ce708f54cc8d73beca213cec66ede5ce100a781 ]
    
    Large pkt_len can lead to out-out-bound memcpy. Current
    ath9k_hif_usb_rx_stream allows combining the content of two urb
    inputs to one pkt. The first input can indicate the size of the
    pkt. Any remaining size is saved in hif_dev->rx_remain_len.
    While processing the next input, memcpy is used with rx_remain_len.
    
    4-byte pkt_len can go up to 0xffff, while a single input is 0x4000
    maximum in size (MAX_RX_BUF_SIZE). Thus, the patch adds a check for
    pkt_len which must not exceed 2 * MAX_RX_BUG_SIZE.
    
    BUG: KASAN: slab-out-of-bounds in ath9k_hif_usb_rx_cb+0x490/0xed7 [ath9k_htc]
    Read of size 46393 at addr ffff888018798000 by task kworker/0:1/23
    
    CPU: 0 PID: 23 Comm: kworker/0:1 Not tainted 5.6.0 #63
    Hardware name: QEMU Standard PC (i440FX + PIIX, 1996),
    BIOS rel-1.10.2-0-g5f4c7b1-prebuilt.qemu-project.org 04/01/2014
    Workqueue: events request_firmware_work_func
    Call Trace:
     <IRQ>
     dump_stack+0x76/0xa0
     print_address_description.constprop.0+0x16/0x200
     ? ath9k_hif_usb_rx_cb+0x490/0xed7 [ath9k_htc]
     ? ath9k_hif_usb_rx_cb+0x490/0xed7 [ath9k_htc]
     __kasan_report.cold+0x37/0x7c
     ? ath9k_hif_usb_rx_cb+0x490/0xed7 [ath9k_htc]
     kasan_report+0xe/0x20
     check_memory_region+0x15a/0x1d0
     memcpy+0x20/0x50
     ath9k_hif_usb_rx_cb+0x490/0xed7 [ath9k_htc]
     ? hif_usb_mgmt_cb+0x2d9/0x2d9 [ath9k_htc]
     ? _raw_spin_lock_irqsave+0x7b/0xd0
     ? _raw_spin_trylock_bh+0x120/0x120
     ? __usb_unanchor_urb+0x12f/0x210
     __usb_hcd_giveback_urb+0x1e4/0x380
     usb_giveback_urb_bh+0x241/0x4f0
     ? __hrtimer_run_queues+0x316/0x740
     ? __usb_hcd_giveback_urb+0x380/0x380
     tasklet_action_common.isra.0+0x135/0x330
     __do_softirq+0x18c/0x634
     irq_exit+0x114/0x140
     smp_apic_timer_interrupt+0xde/0x380
     apic_timer_interrupt+0xf/0x20
    
    I found the bug using a custome USBFuzz port. It's a research work
    to fuzz USB stack/drivers. I modified it to fuzz ath9k driver only,
    providing hand-crafted usb descriptors to QEMU.
    
    After fixing the value of pkt_tag to ATH_USB_RX_STREAM_MODE_TAG in QEMU
    emulation, I found the KASAN report. The bug is triggerable whenever
    pkt_len is above two MAX_RX_BUG_SIZE. I used the same input that crashes
    to test the driver works when applying the patch.
    
    Signed-off-by: Zekun Shen <bruceshenzk@gmail.com>
    Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
    Link: https://lore.kernel.org/r/YXsidrRuK6zBJicZ@10-18-43-117.dynapool.wireless.nyu.edu
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit bd2b5268910cdd77a6b4376c4eee390d89f8e246
Author: Zekun Shen <bruceshenzk@gmail.com>
Date:   Fri Oct 29 16:19:23 2021 -0400

    rsi: Fix out-of-bounds read in rsi_read_pkt()
    
    [ Upstream commit f1cb3476e48b60c450ec3a1d7da0805bffc6e43a ]
    
    rsi_get_* functions rely on an offset variable from usb
    input. The size of usb input is RSI_MAX_RX_USB_PKT_SIZE(3000),
    while 2-byte offset can be up to 0xFFFF. Thus a large offset
    can cause out-of-bounds read.
    
    The patch adds a bound checking condition when rcv_pkt_len is 0,
    indicating it's USB. It's unclear whether this is triggerable
    from other type of bus. The following check might help in that case.
    offset > rcv_pkt_len - FRAME_DESC_SZ
    
    The bug is trigerrable with conpromised/malfunctioning USB devices.
    I tested the patch with the crashing input and got no more bug report.
    
    Attached is the KASAN report from fuzzing.
    
    BUG: KASAN: slab-out-of-bounds in rsi_read_pkt+0x42e/0x500 [rsi_91x]
    Read of size 2 at addr ffff888019439fdb by task RX-Thread/227
    
    CPU: 0 PID: 227 Comm: RX-Thread Not tainted 5.6.0 #66
    Call Trace:
     dump_stack+0x76/0xa0
     print_address_description.constprop.0+0x16/0x200
     ? rsi_read_pkt+0x42e/0x500 [rsi_91x]
     ? rsi_read_pkt+0x42e/0x500 [rsi_91x]
     __kasan_report.cold+0x37/0x7c
     ? rsi_read_pkt+0x42e/0x500 [rsi_91x]
     kasan_report+0xe/0x20
     rsi_read_pkt+0x42e/0x500 [rsi_91x]
     rsi_usb_rx_thread+0x1b1/0x2fc [rsi_usb]
     ? rsi_probe+0x16a0/0x16a0 [rsi_usb]
     ? _raw_spin_lock_irqsave+0x7b/0xd0
     ? _raw_spin_trylock_bh+0x120/0x120
     ? __wake_up_common+0x10b/0x520
     ? rsi_probe+0x16a0/0x16a0 [rsi_usb]
     kthread+0x2b5/0x3b0
     ? kthread_create_on_node+0xd0/0xd0
     ret_from_fork+0x22/0x40
    
    Reported-by: Brendan Dolan-Gavitt <brendandg@nyu.edu>
    Signed-off-by: Zekun Shen <bruceshenzk@gmail.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
    Link: https://lore.kernel.org/r/YXxXS4wgu2OsmlVv@10-18-43-117.dynapool.wireless.nyu.edu
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit c91e7952bce2d5293503a0466777b44682017ebc
Author: Zekun Shen <bruceshenzk@gmail.com>
Date:   Thu Oct 28 18:37:49 2021 -0400

    ar5523: Fix null-ptr-deref with unexpected WDCMSG_TARGET_START reply
    
    [ Upstream commit ae80b6033834342601e99f74f6a62ff5092b1cee ]
    
    Unexpected WDCMSG_TARGET_START replay can lead to null-ptr-deref
    when ar->tx_cmd->odata is NULL. The patch adds a null check to
    prevent such case.
    
    KASAN: null-ptr-deref in range [0x0000000000000000-0x0000000000000007]
     ar5523_cmd+0x46a/0x581 [ar5523]
     ar5523_probe.cold+0x1b7/0x18da [ar5523]
     ? ar5523_cmd_rx_cb+0x7a0/0x7a0 [ar5523]
     ? __pm_runtime_set_status+0x54a/0x8f0
     ? _raw_spin_trylock_bh+0x120/0x120
     ? pm_runtime_barrier+0x220/0x220
     ? __pm_runtime_resume+0xb1/0xf0
     usb_probe_interface+0x25b/0x710
     really_probe+0x209/0x5d0
     driver_probe_device+0xc6/0x1b0
     device_driver_attach+0xe2/0x120
    
    I found the bug using a custome USBFuzz port. It's a research work
    to fuzz USB stack/drivers. I modified it to fuzz ath9k driver only,
    providing hand-crafted usb descriptors to QEMU.
    
    After fixing the code (fourth byte in usb packet) to WDCMSG_TARGET_START,
    I got the null-ptr-deref bug. I believe the bug is triggerable whenever
    cmd->odata is NULL. After patching, I tested with the same input and no
    longer see the KASAN report.
    
    This was NOT tested on a real device.
    
    Signed-off-by: Zekun Shen <bruceshenzk@gmail.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
    Link: https://lore.kernel.org/r/YXsmPQ3awHFLuAj2@10-18-43-117.dynapool.wireless.nyu.edu
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 38d8d8a882745f87c6a0f54549734241a5818d37
Author: Zekun Shen <bruceshenzk@gmail.com>
Date:   Thu Oct 28 18:21:42 2021 -0400

    ath9k: Fix out-of-bound memcpy in ath9k_hif_usb_rx_stream
    
    [ Upstream commit 6ce708f54cc8d73beca213cec66ede5ce100a781 ]
    
    Large pkt_len can lead to out-out-bound memcpy. Current
    ath9k_hif_usb_rx_stream allows combining the content of two urb
    inputs to one pkt. The first input can indicate the size of the
    pkt. Any remaining size is saved in hif_dev->rx_remain_len.
    While processing the next input, memcpy is used with rx_remain_len.
    
    4-byte pkt_len can go up to 0xffff, while a single input is 0x4000
    maximum in size (MAX_RX_BUF_SIZE). Thus, the patch adds a check for
    pkt_len which must not exceed 2 * MAX_RX_BUG_SIZE.
    
    BUG: KASAN: slab-out-of-bounds in ath9k_hif_usb_rx_cb+0x490/0xed7 [ath9k_htc]
    Read of size 46393 at addr ffff888018798000 by task kworker/0:1/23
    
    CPU: 0 PID: 23 Comm: kworker/0:1 Not tainted 5.6.0 #63
    Hardware name: QEMU Standard PC (i440FX + PIIX, 1996),
    BIOS rel-1.10.2-0-g5f4c7b1-prebuilt.qemu-project.org 04/01/2014
    Workqueue: events request_firmware_work_func
    Call Trace:
     <IRQ>
     dump_stack+0x76/0xa0
     print_address_description.constprop.0+0x16/0x200
     ? ath9k_hif_usb_rx_cb+0x490/0xed7 [ath9k_htc]
     ? ath9k_hif_usb_rx_cb+0x490/0xed7 [ath9k_htc]
     __kasan_report.cold+0x37/0x7c
     ? ath9k_hif_usb_rx_cb+0x490/0xed7 [ath9k_htc]
     kasan_report+0xe/0x20
     check_memory_region+0x15a/0x1d0
     memcpy+0x20/0x50
     ath9k_hif_usb_rx_cb+0x490/0xed7 [ath9k_htc]
     ? hif_usb_mgmt_cb+0x2d9/0x2d9 [ath9k_htc]
     ? _raw_spin_lock_irqsave+0x7b/0xd0
     ? _raw_spin_trylock_bh+0x120/0x120
     ? __usb_unanchor_urb+0x12f/0x210
     __usb_hcd_giveback_urb+0x1e4/0x380
     usb_giveback_urb_bh+0x241/0x4f0
     ? __hrtimer_run_queues+0x316/0x740
     ? __usb_hcd_giveback_urb+0x380/0x380
     tasklet_action_common.isra.0+0x135/0x330
     __do_softirq+0x18c/0x634
     irq_exit+0x114/0x140
     smp_apic_timer_interrupt+0xde/0x380
     apic_timer_interrupt+0xf/0x20
    
    I found the bug using a custome USBFuzz port. It's a research work
    to fuzz USB stack/drivers. I modified it to fuzz ath9k driver only,
    providing hand-crafted usb descriptors to QEMU.
    
    After fixing the value of pkt_tag to ATH_USB_RX_STREAM_MODE_TAG in QEMU
    emulation, I found the KASAN report. The bug is triggerable whenever
    pkt_len is above two MAX_RX_BUG_SIZE. I used the same input that crashes
    to test the driver works when applying the patch.
    
    Signed-off-by: Zekun Shen <bruceshenzk@gmail.com>
    Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
    Link: https://lore.kernel.org/r/YXsidrRuK6zBJicZ@10-18-43-117.dynapool.wireless.nyu.edu
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit dbba81756c1b7a8e7a6df443f863d8da11c2054b
Author: Zekun Shen <bruceshenzk@gmail.com>
Date:   Fri Oct 29 16:19:23 2021 -0400

    rsi: Fix out-of-bounds read in rsi_read_pkt()
    
    [ Upstream commit f1cb3476e48b60c450ec3a1d7da0805bffc6e43a ]
    
    rsi_get_* functions rely on an offset variable from usb
    input. The size of usb input is RSI_MAX_RX_USB_PKT_SIZE(3000),
    while 2-byte offset can be up to 0xFFFF. Thus a large offset
    can cause out-of-bounds read.
    
    The patch adds a bound checking condition when rcv_pkt_len is 0,
    indicating it's USB. It's unclear whether this is triggerable
    from other type of bus. The following check might help in that case.
    offset > rcv_pkt_len - FRAME_DESC_SZ
    
    The bug is trigerrable with conpromised/malfunctioning USB devices.
    I tested the patch with the crashing input and got no more bug report.
    
    Attached is the KASAN report from fuzzing.
    
    BUG: KASAN: slab-out-of-bounds in rsi_read_pkt+0x42e/0x500 [rsi_91x]
    Read of size 2 at addr ffff888019439fdb by task RX-Thread/227
    
    CPU: 0 PID: 227 Comm: RX-Thread Not tainted 5.6.0 #66
    Call Trace:
     dump_stack+0x76/0xa0
     print_address_description.constprop.0+0x16/0x200
     ? rsi_read_pkt+0x42e/0x500 [rsi_91x]
     ? rsi_read_pkt+0x42e/0x500 [rsi_91x]
     __kasan_report.cold+0x37/0x7c
     ? rsi_read_pkt+0x42e/0x500 [rsi_91x]
     kasan_report+0xe/0x20
     rsi_read_pkt+0x42e/0x500 [rsi_91x]
     rsi_usb_rx_thread+0x1b1/0x2fc [rsi_usb]
     ? rsi_probe+0x16a0/0x16a0 [rsi_usb]
     ? _raw_spin_lock_irqsave+0x7b/0xd0
     ? _raw_spin_trylock_bh+0x120/0x120
     ? __wake_up_common+0x10b/0x520
     ? rsi_probe+0x16a0/0x16a0 [rsi_usb]
     kthread+0x2b5/0x3b0
     ? kthread_create_on_node+0xd0/0xd0
     ret_from_fork+0x22/0x40
    
    Reported-by: Brendan Dolan-Gavitt <brendandg@nyu.edu>
    Signed-off-by: Zekun Shen <bruceshenzk@gmail.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
    Link: https://lore.kernel.org/r/YXxXS4wgu2OsmlVv@10-18-43-117.dynapool.wireless.nyu.edu
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit fbcd1e9f8a4306cea72195292658ab51f7722b98
Author: Zekun Shen <bruceshenzk@gmail.com>
Date:   Thu Oct 28 18:37:49 2021 -0400

    ar5523: Fix null-ptr-deref with unexpected WDCMSG_TARGET_START reply
    
    [ Upstream commit ae80b6033834342601e99f74f6a62ff5092b1cee ]
    
    Unexpected WDCMSG_TARGET_START replay can lead to null-ptr-deref
    when ar->tx_cmd->odata is NULL. The patch adds a null check to
    prevent such case.
    
    KASAN: null-ptr-deref in range [0x0000000000000000-0x0000000000000007]
     ar5523_cmd+0x46a/0x581 [ar5523]
     ar5523_probe.cold+0x1b7/0x18da [ar5523]
     ? ar5523_cmd_rx_cb+0x7a0/0x7a0 [ar5523]
     ? __pm_runtime_set_status+0x54a/0x8f0
     ? _raw_spin_trylock_bh+0x120/0x120
     ? pm_runtime_barrier+0x220/0x220
     ? __pm_runtime_resume+0xb1/0xf0
     usb_probe_interface+0x25b/0x710
     really_probe+0x209/0x5d0
     driver_probe_device+0xc6/0x1b0
     device_driver_attach+0xe2/0x120
    
    I found the bug using a custome USBFuzz port. It's a research work
    to fuzz USB stack/drivers. I modified it to fuzz ath9k driver only,
    providing hand-crafted usb descriptors to QEMU.
    
    After fixing the code (fourth byte in usb packet) to WDCMSG_TARGET_START,
    I got the null-ptr-deref bug. I believe the bug is triggerable whenever
    cmd->odata is NULL. After patching, I tested with the same input and no
    longer see the KASAN report.
    
    This was NOT tested on a real device.
    
    Signed-off-by: Zekun Shen <bruceshenzk@gmail.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
    Link: https://lore.kernel.org/r/YXsmPQ3awHFLuAj2@10-18-43-117.dynapool.wireless.nyu.edu
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 3ef25f3122c07d143732e27235edb4eaecabb3da
Author: Zekun Shen <bruceshenzk@gmail.com>
Date:   Thu Oct 28 18:21:42 2021 -0400

    ath9k: Fix out-of-bound memcpy in ath9k_hif_usb_rx_stream
    
    [ Upstream commit 6ce708f54cc8d73beca213cec66ede5ce100a781 ]
    
    Large pkt_len can lead to out-out-bound memcpy. Current
    ath9k_hif_usb_rx_stream allows combining the content of two urb
    inputs to one pkt. The first input can indicate the size of the
    pkt. Any remaining size is saved in hif_dev->rx_remain_len.
    While processing the next input, memcpy is used with rx_remain_len.
    
    4-byte pkt_len can go up to 0xffff, while a single input is 0x4000
    maximum in size (MAX_RX_BUF_SIZE). Thus, the patch adds a check for
    pkt_len which must not exceed 2 * MAX_RX_BUG_SIZE.
    
    BUG: KASAN: slab-out-of-bounds in ath9k_hif_usb_rx_cb+0x490/0xed7 [ath9k_htc]
    Read of size 46393 at addr ffff888018798000 by task kworker/0:1/23
    
    CPU: 0 PID: 23 Comm: kworker/0:1 Not tainted 5.6.0 #63
    Hardware name: QEMU Standard PC (i440FX + PIIX, 1996),
    BIOS rel-1.10.2-0-g5f4c7b1-prebuilt.qemu-project.org 04/01/2014
    Workqueue: events request_firmware_work_func
    Call Trace:
     <IRQ>
     dump_stack+0x76/0xa0
     print_address_description.constprop.0+0x16/0x200
     ? ath9k_hif_usb_rx_cb+0x490/0xed7 [ath9k_htc]
     ? ath9k_hif_usb_rx_cb+0x490/0xed7 [ath9k_htc]
     __kasan_report.cold+0x37/0x7c
     ? ath9k_hif_usb_rx_cb+0x490/0xed7 [ath9k_htc]
     kasan_report+0xe/0x20
     check_memory_region+0x15a/0x1d0
     memcpy+0x20/0x50
     ath9k_hif_usb_rx_cb+0x490/0xed7 [ath9k_htc]
     ? hif_usb_mgmt_cb+0x2d9/0x2d9 [ath9k_htc]
     ? _raw_spin_lock_irqsave+0x7b/0xd0
     ? _raw_spin_trylock_bh+0x120/0x120
     ? __usb_unanchor_urb+0x12f/0x210
     __usb_hcd_giveback_urb+0x1e4/0x380
     usb_giveback_urb_bh+0x241/0x4f0
     ? __hrtimer_run_queues+0x316/0x740
     ? __usb_hcd_giveback_urb+0x380/0x380
     tasklet_action_common.isra.0+0x135/0x330
     __do_softirq+0x18c/0x634
     irq_exit+0x114/0x140
     smp_apic_timer_interrupt+0xde/0x380
     apic_timer_interrupt+0xf/0x20
    
    I found the bug using a custome USBFuzz port. It's a research work
    to fuzz USB stack/drivers. I modified it to fuzz ath9k driver only,
    providing hand-crafted usb descriptors to QEMU.
    
    After fixing the value of pkt_tag to ATH_USB_RX_STREAM_MODE_TAG in QEMU
    emulation, I found the KASAN report. The bug is triggerable whenever
    pkt_len is above two MAX_RX_BUG_SIZE. I used the same input that crashes
    to test the driver works when applying the patch.
    
    Signed-off-by: Zekun Shen <bruceshenzk@gmail.com>
    Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
    Link: https://lore.kernel.org/r/YXsidrRuK6zBJicZ@10-18-43-117.dynapool.wireless.nyu.edu
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit ab523ea096ef289da0f4431a4395f0ceb1e4ede9
Author: Zekun Shen <bruceshenzk@gmail.com>
Date:   Fri Oct 29 16:19:23 2021 -0400

    rsi: Fix out-of-bounds read in rsi_read_pkt()
    
    [ Upstream commit f1cb3476e48b60c450ec3a1d7da0805bffc6e43a ]
    
    rsi_get_* functions rely on an offset variable from usb
    input. The size of usb input is RSI_MAX_RX_USB_PKT_SIZE(3000),
    while 2-byte offset can be up to 0xFFFF. Thus a large offset
    can cause out-of-bounds read.
    
    The patch adds a bound checking condition when rcv_pkt_len is 0,
    indicating it's USB. It's unclear whether this is triggerable
    from other type of bus. The following check might help in that case.
    offset > rcv_pkt_len - FRAME_DESC_SZ
    
    The bug is trigerrable with conpromised/malfunctioning USB devices.
    I tested the patch with the crashing input and got no more bug report.
    
    Attached is the KASAN report from fuzzing.
    
    BUG: KASAN: slab-out-of-bounds in rsi_read_pkt+0x42e/0x500 [rsi_91x]
    Read of size 2 at addr ffff888019439fdb by task RX-Thread/227
    
    CPU: 0 PID: 227 Comm: RX-Thread Not tainted 5.6.0 #66
    Call Trace:
     dump_stack+0x76/0xa0
     print_address_description.constprop.0+0x16/0x200
     ? rsi_read_pkt+0x42e/0x500 [rsi_91x]
     ? rsi_read_pkt+0x42e/0x500 [rsi_91x]
     __kasan_report.cold+0x37/0x7c
     ? rsi_read_pkt+0x42e/0x500 [rsi_91x]
     kasan_report+0xe/0x20
     rsi_read_pkt+0x42e/0x500 [rsi_91x]
     rsi_usb_rx_thread+0x1b1/0x2fc [rsi_usb]
     ? rsi_probe+0x16a0/0x16a0 [rsi_usb]
     ? _raw_spin_lock_irqsave+0x7b/0xd0
     ? _raw_spin_trylock_bh+0x120/0x120
     ? __wake_up_common+0x10b/0x520
     ? rsi_probe+0x16a0/0x16a0 [rsi_usb]
     kthread+0x2b5/0x3b0
     ? kthread_create_on_node+0xd0/0xd0
     ret_from_fork+0x22/0x40
    
    Reported-by: Brendan Dolan-Gavitt <brendandg@nyu.edu>
    Signed-off-by: Zekun Shen <bruceshenzk@gmail.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
    Link: https://lore.kernel.org/r/YXxXS4wgu2OsmlVv@10-18-43-117.dynapool.wireless.nyu.edu
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 2f13f10fddf4689fbc06204fe75ad595dbe93091
Author: Zekun Shen <bruceshenzk@gmail.com>
Date:   Thu Oct 28 18:37:49 2021 -0400

    ar5523: Fix null-ptr-deref with unexpected WDCMSG_TARGET_START reply
    
    [ Upstream commit ae80b6033834342601e99f74f6a62ff5092b1cee ]
    
    Unexpected WDCMSG_TARGET_START replay can lead to null-ptr-deref
    when ar->tx_cmd->odata is NULL. The patch adds a null check to
    prevent such case.
    
    KASAN: null-ptr-deref in range [0x0000000000000000-0x0000000000000007]
     ar5523_cmd+0x46a/0x581 [ar5523]
     ar5523_probe.cold+0x1b7/0x18da [ar5523]
     ? ar5523_cmd_rx_cb+0x7a0/0x7a0 [ar5523]
     ? __pm_runtime_set_status+0x54a/0x8f0
     ? _raw_spin_trylock_bh+0x120/0x120
     ? pm_runtime_barrier+0x220/0x220
     ? __pm_runtime_resume+0xb1/0xf0
     usb_probe_interface+0x25b/0x710
     really_probe+0x209/0x5d0
     driver_probe_device+0xc6/0x1b0
     device_driver_attach+0xe2/0x120
    
    I found the bug using a custome USBFuzz port. It's a research work
    to fuzz USB stack/drivers. I modified it to fuzz ath9k driver only,
    providing hand-crafted usb descriptors to QEMU.
    
    After fixing the code (fourth byte in usb packet) to WDCMSG_TARGET_START,
    I got the null-ptr-deref bug. I believe the bug is triggerable whenever
    cmd->odata is NULL. After patching, I tested with the same input and no
    longer see the KASAN report.
    
    This was NOT tested on a real device.
    
    Signed-off-by: Zekun Shen <bruceshenzk@gmail.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
    Link: https://lore.kernel.org/r/YXsmPQ3awHFLuAj2@10-18-43-117.dynapool.wireless.nyu.edu
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit c8fe499c456528a8a946058e33a52f1762c41c89
Author: Zekun Shen <bruceshenzk@gmail.com>
Date:   Thu Oct 28 18:21:42 2021 -0400

    ath9k: Fix out-of-bound memcpy in ath9k_hif_usb_rx_stream
    
    [ Upstream commit 6ce708f54cc8d73beca213cec66ede5ce100a781 ]
    
    Large pkt_len can lead to out-out-bound memcpy. Current
    ath9k_hif_usb_rx_stream allows combining the content of two urb
    inputs to one pkt. The first input can indicate the size of the
    pkt. Any remaining size is saved in hif_dev->rx_remain_len.
    While processing the next input, memcpy is used with rx_remain_len.
    
    4-byte pkt_len can go up to 0xffff, while a single input is 0x4000
    maximum in size (MAX_RX_BUF_SIZE). Thus, the patch adds a check for
    pkt_len which must not exceed 2 * MAX_RX_BUG_SIZE.
    
    BUG: KASAN: slab-out-of-bounds in ath9k_hif_usb_rx_cb+0x490/0xed7 [ath9k_htc]
    Read of size 46393 at addr ffff888018798000 by task kworker/0:1/23
    
    CPU: 0 PID: 23 Comm: kworker/0:1 Not tainted 5.6.0 #63
    Hardware name: QEMU Standard PC (i440FX + PIIX, 1996),
    BIOS rel-1.10.2-0-g5f4c7b1-prebuilt.qemu-project.org 04/01/2014
    Workqueue: events request_firmware_work_func
    Call Trace:
     <IRQ>
     dump_stack+0x76/0xa0
     print_address_description.constprop.0+0x16/0x200
     ? ath9k_hif_usb_rx_cb+0x490/0xed7 [ath9k_htc]
     ? ath9k_hif_usb_rx_cb+0x490/0xed7 [ath9k_htc]
     __kasan_report.cold+0x37/0x7c
     ? ath9k_hif_usb_rx_cb+0x490/0xed7 [ath9k_htc]
     kasan_report+0xe/0x20
     check_memory_region+0x15a/0x1d0
     memcpy+0x20/0x50
     ath9k_hif_usb_rx_cb+0x490/0xed7 [ath9k_htc]
     ? hif_usb_mgmt_cb+0x2d9/0x2d9 [ath9k_htc]
     ? _raw_spin_lock_irqsave+0x7b/0xd0
     ? _raw_spin_trylock_bh+0x120/0x120
     ? __usb_unanchor_urb+0x12f/0x210
     __usb_hcd_giveback_urb+0x1e4/0x380
     usb_giveback_urb_bh+0x241/0x4f0
     ? __hrtimer_run_queues+0x316/0x740
     ? __usb_hcd_giveback_urb+0x380/0x380
     tasklet_action_common.isra.0+0x135/0x330
     __do_softirq+0x18c/0x634
     irq_exit+0x114/0x140
     smp_apic_timer_interrupt+0xde/0x380
     apic_timer_interrupt+0xf/0x20
    
    I found the bug using a custome USBFuzz port. It's a research work
    to fuzz USB stack/drivers. I modified it to fuzz ath9k driver only,
    providing hand-crafted usb descriptors to QEMU.
    
    After fixing the value of pkt_tag to ATH_USB_RX_STREAM_MODE_TAG in QEMU
    emulation, I found the KASAN report. The bug is triggerable whenever
    pkt_len is above two MAX_RX_BUG_SIZE. I used the same input that crashes
    to test the driver works when applying the patch.
    
    Signed-off-by: Zekun Shen <bruceshenzk@gmail.com>
    Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
    Link: https://lore.kernel.org/r/YXsidrRuK6zBJicZ@10-18-43-117.dynapool.wireless.nyu.edu
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit c27a52321190a45d37c09234c507dcbb1d763d69
Author: Zekun Shen <bruceshenzk@gmail.com>
Date:   Fri Oct 29 16:19:23 2021 -0400

    rsi: Fix out-of-bounds read in rsi_read_pkt()
    
    [ Upstream commit f1cb3476e48b60c450ec3a1d7da0805bffc6e43a ]
    
    rsi_get_* functions rely on an offset variable from usb
    input. The size of usb input is RSI_MAX_RX_USB_PKT_SIZE(3000),
    while 2-byte offset can be up to 0xFFFF. Thus a large offset
    can cause out-of-bounds read.
    
    The patch adds a bound checking condition when rcv_pkt_len is 0,
    indicating it's USB. It's unclear whether this is triggerable
    from other type of bus. The following check might help in that case.
    offset > rcv_pkt_len - FRAME_DESC_SZ
    
    The bug is trigerrable with conpromised/malfunctioning USB devices.
    I tested the patch with the crashing input and got no more bug report.
    
    Attached is the KASAN report from fuzzing.
    
    BUG: KASAN: slab-out-of-bounds in rsi_read_pkt+0x42e/0x500 [rsi_91x]
    Read of size 2 at addr ffff888019439fdb by task RX-Thread/227
    
    CPU: 0 PID: 227 Comm: RX-Thread Not tainted 5.6.0 #66
    Call Trace:
     dump_stack+0x76/0xa0
     print_address_description.constprop.0+0x16/0x200
     ? rsi_read_pkt+0x42e/0x500 [rsi_91x]
     ? rsi_read_pkt+0x42e/0x500 [rsi_91x]
     __kasan_report.cold+0x37/0x7c
     ? rsi_read_pkt+0x42e/0x500 [rsi_91x]
     kasan_report+0xe/0x20
     rsi_read_pkt+0x42e/0x500 [rsi_91x]
     rsi_usb_rx_thread+0x1b1/0x2fc [rsi_usb]
     ? rsi_probe+0x16a0/0x16a0 [rsi_usb]
     ? _raw_spin_lock_irqsave+0x7b/0xd0
     ? _raw_spin_trylock_bh+0x120/0x120
     ? __wake_up_common+0x10b/0x520
     ? rsi_probe+0x16a0/0x16a0 [rsi_usb]
     kthread+0x2b5/0x3b0
     ? kthread_create_on_node+0xd0/0xd0
     ret_from_fork+0x22/0x40
    
    Reported-by: Brendan Dolan-Gavitt <brendandg@nyu.edu>
    Signed-off-by: Zekun Shen <bruceshenzk@gmail.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
    Link: https://lore.kernel.org/r/YXxXS4wgu2OsmlVv@10-18-43-117.dynapool.wireless.nyu.edu
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 3642493839af4b18bf2d88f5889f3997957f2f89
Author: Zekun Shen <bruceshenzk@gmail.com>
Date:   Thu Oct 28 18:37:49 2021 -0400

    ar5523: Fix null-ptr-deref with unexpected WDCMSG_TARGET_START reply
    
    [ Upstream commit ae80b6033834342601e99f74f6a62ff5092b1cee ]
    
    Unexpected WDCMSG_TARGET_START replay can lead to null-ptr-deref
    when ar->tx_cmd->odata is NULL. The patch adds a null check to
    prevent such case.
    
    KASAN: null-ptr-deref in range [0x0000000000000000-0x0000000000000007]
     ar5523_cmd+0x46a/0x581 [ar5523]
     ar5523_probe.cold+0x1b7/0x18da [ar5523]
     ? ar5523_cmd_rx_cb+0x7a0/0x7a0 [ar5523]
     ? __pm_runtime_set_status+0x54a/0x8f0
     ? _raw_spin_trylock_bh+0x120/0x120
     ? pm_runtime_barrier+0x220/0x220
     ? __pm_runtime_resume+0xb1/0xf0
     usb_probe_interface+0x25b/0x710
     really_probe+0x209/0x5d0
     driver_probe_device+0xc6/0x1b0
     device_driver_attach+0xe2/0x120
    
    I found the bug using a custome USBFuzz port. It's a research work
    to fuzz USB stack/drivers. I modified it to fuzz ath9k driver only,
    providing hand-crafted usb descriptors to QEMU.
    
    After fixing the code (fourth byte in usb packet) to WDCMSG_TARGET_START,
    I got the null-ptr-deref bug. I believe the bug is triggerable whenever
    cmd->odata is NULL. After patching, I tested with the same input and no
    longer see the KASAN report.
    
    This was NOT tested on a real device.
    
    Signed-off-by: Zekun Shen <bruceshenzk@gmail.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
    Link: https://lore.kernel.org/r/YXsmPQ3awHFLuAj2@10-18-43-117.dynapool.wireless.nyu.edu
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 8fcc23dce6a1355d6e71bc8b35272390e11cd42f
Author: Zekun Shen <bruceshenzk@gmail.com>
Date:   Thu Oct 28 18:21:42 2021 -0400

    ath9k: Fix out-of-bound memcpy in ath9k_hif_usb_rx_stream
    
    [ Upstream commit 6ce708f54cc8d73beca213cec66ede5ce100a781 ]
    
    Large pkt_len can lead to out-out-bound memcpy. Current
    ath9k_hif_usb_rx_stream allows combining the content of two urb
    inputs to one pkt. The first input can indicate the size of the
    pkt. Any remaining size is saved in hif_dev->rx_remain_len.
    While processing the next input, memcpy is used with rx_remain_len.
    
    4-byte pkt_len can go up to 0xffff, while a single input is 0x4000
    maximum in size (MAX_RX_BUF_SIZE). Thus, the patch adds a check for
    pkt_len which must not exceed 2 * MAX_RX_BUG_SIZE.
    
    BUG: KASAN: slab-out-of-bounds in ath9k_hif_usb_rx_cb+0x490/0xed7 [ath9k_htc]
    Read of size 46393 at addr ffff888018798000 by task kworker/0:1/23
    
    CPU: 0 PID: 23 Comm: kworker/0:1 Not tainted 5.6.0 #63
    Hardware name: QEMU Standard PC (i440FX + PIIX, 1996),
    BIOS rel-1.10.2-0-g5f4c7b1-prebuilt.qemu-project.org 04/01/2014
    Workqueue: events request_firmware_work_func
    Call Trace:
     <IRQ>
     dump_stack+0x76/0xa0
     print_address_description.constprop.0+0x16/0x200
     ? ath9k_hif_usb_rx_cb+0x490/0xed7 [ath9k_htc]
     ? ath9k_hif_usb_rx_cb+0x490/0xed7 [ath9k_htc]
     __kasan_report.cold+0x37/0x7c
     ? ath9k_hif_usb_rx_cb+0x490/0xed7 [ath9k_htc]
     kasan_report+0xe/0x20
     check_memory_region+0x15a/0x1d0
     memcpy+0x20/0x50
     ath9k_hif_usb_rx_cb+0x490/0xed7 [ath9k_htc]
     ? hif_usb_mgmt_cb+0x2d9/0x2d9 [ath9k_htc]
     ? _raw_spin_lock_irqsave+0x7b/0xd0
     ? _raw_spin_trylock_bh+0x120/0x120
     ? __usb_unanchor_urb+0x12f/0x210
     __usb_hcd_giveback_urb+0x1e4/0x380
     usb_giveback_urb_bh+0x241/0x4f0
     ? __hrtimer_run_queues+0x316/0x740
     ? __usb_hcd_giveback_urb+0x380/0x380
     tasklet_action_common.isra.0+0x135/0x330
     __do_softirq+0x18c/0x634
     irq_exit+0x114/0x140
     smp_apic_timer_interrupt+0xde/0x380
     apic_timer_interrupt+0xf/0x20
    
    I found the bug using a custome USBFuzz port. It's a research work
    to fuzz USB stack/drivers. I modified it to fuzz ath9k driver only,
    providing hand-crafted usb descriptors to QEMU.
    
    After fixing the value of pkt_tag to ATH_USB_RX_STREAM_MODE_TAG in QEMU
    emulation, I found the KASAN report. The bug is triggerable whenever
    pkt_len is above two MAX_RX_BUG_SIZE. I used the same input that crashes
    to test the driver works when applying the patch.
    
    Signed-off-by: Zekun Shen <bruceshenzk@gmail.com>
    Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
    Link: https://lore.kernel.org/r/YXsidrRuK6zBJicZ@10-18-43-117.dynapool.wireless.nyu.edu
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit b61836cd323c94942402c3191169518607db8bfd
Author: Zekun Shen <bruceshenzk@gmail.com>
Date:   Fri Oct 29 16:19:23 2021 -0400

    rsi: Fix out-of-bounds read in rsi_read_pkt()
    
    [ Upstream commit f1cb3476e48b60c450ec3a1d7da0805bffc6e43a ]
    
    rsi_get_* functions rely on an offset variable from usb
    input. The size of usb input is RSI_MAX_RX_USB_PKT_SIZE(3000),
    while 2-byte offset can be up to 0xFFFF. Thus a large offset
    can cause out-of-bounds read.
    
    The patch adds a bound checking condition when rcv_pkt_len is 0,
    indicating it's USB. It's unclear whether this is triggerable
    from other type of bus. The following check might help in that case.
    offset > rcv_pkt_len - FRAME_DESC_SZ
    
    The bug is trigerrable with conpromised/malfunctioning USB devices.
    I tested the patch with the crashing input and got no more bug report.
    
    Attached is the KASAN report from fuzzing.
    
    BUG: KASAN: slab-out-of-bounds in rsi_read_pkt+0x42e/0x500 [rsi_91x]
    Read of size 2 at addr ffff888019439fdb by task RX-Thread/227
    
    CPU: 0 PID: 227 Comm: RX-Thread Not tainted 5.6.0 #66
    Call Trace:
     dump_stack+0x76/0xa0
     print_address_description.constprop.0+0x16/0x200
     ? rsi_read_pkt+0x42e/0x500 [rsi_91x]
     ? rsi_read_pkt+0x42e/0x500 [rsi_91x]
     __kasan_report.cold+0x37/0x7c
     ? rsi_read_pkt+0x42e/0x500 [rsi_91x]
     kasan_report+0xe/0x20
     rsi_read_pkt+0x42e/0x500 [rsi_91x]
     rsi_usb_rx_thread+0x1b1/0x2fc [rsi_usb]
     ? rsi_probe+0x16a0/0x16a0 [rsi_usb]
     ? _raw_spin_lock_irqsave+0x7b/0xd0
     ? _raw_spin_trylock_bh+0x120/0x120
     ? __wake_up_common+0x10b/0x520
     ? rsi_probe+0x16a0/0x16a0 [rsi_usb]
     kthread+0x2b5/0x3b0
     ? kthread_create_on_node+0xd0/0xd0
     ret_from_fork+0x22/0x40
    
    Reported-by: Brendan Dolan-Gavitt <brendandg@nyu.edu>
    Signed-off-by: Zekun Shen <bruceshenzk@gmail.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
    Link: https://lore.kernel.org/r/YXxXS4wgu2OsmlVv@10-18-43-117.dynapool.wireless.nyu.edu
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 52a20b60421be926cfa72f578bae869b26d77b99
Author: Zekun Shen <bruceshenzk@gmail.com>
Date:   Thu Oct 28 18:37:49 2021 -0400

    ar5523: Fix null-ptr-deref with unexpected WDCMSG_TARGET_START reply
    
    [ Upstream commit ae80b6033834342601e99f74f6a62ff5092b1cee ]
    
    Unexpected WDCMSG_TARGET_START replay can lead to null-ptr-deref
    when ar->tx_cmd->odata is NULL. The patch adds a null check to
    prevent such case.
    
    KASAN: null-ptr-deref in range [0x0000000000000000-0x0000000000000007]
     ar5523_cmd+0x46a/0x581 [ar5523]
     ar5523_probe.cold+0x1b7/0x18da [ar5523]
     ? ar5523_cmd_rx_cb+0x7a0/0x7a0 [ar5523]
     ? __pm_runtime_set_status+0x54a/0x8f0
     ? _raw_spin_trylock_bh+0x120/0x120
     ? pm_runtime_barrier+0x220/0x220
     ? __pm_runtime_resume+0xb1/0xf0
     usb_probe_interface+0x25b/0x710
     really_probe+0x209/0x5d0
     driver_probe_device+0xc6/0x1b0
     device_driver_attach+0xe2/0x120
    
    I found the bug using a custome USBFuzz port. It's a research work
    to fuzz USB stack/drivers. I modified it to fuzz ath9k driver only,
    providing hand-crafted usb descriptors to QEMU.
    
    After fixing the code (fourth byte in usb packet) to WDCMSG_TARGET_START,
    I got the null-ptr-deref bug. I believe the bug is triggerable whenever
    cmd->odata is NULL. After patching, I tested with the same input and no
    longer see the KASAN report.
    
    This was NOT tested on a real device.
    
    Signed-off-by: Zekun Shen <bruceshenzk@gmail.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
    Link: https://lore.kernel.org/r/YXsmPQ3awHFLuAj2@10-18-43-117.dynapool.wireless.nyu.edu
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 1d153d82e55f1cd2f32f5de72859a2608f05a0dc
Author: Zekun Shen <bruceshenzk@gmail.com>
Date:   Thu Oct 28 18:21:42 2021 -0400

    ath9k: Fix out-of-bound memcpy in ath9k_hif_usb_rx_stream
    
    [ Upstream commit 6ce708f54cc8d73beca213cec66ede5ce100a781 ]
    
    Large pkt_len can lead to out-out-bound memcpy. Current
    ath9k_hif_usb_rx_stream allows combining the content of two urb
    inputs to one pkt. The first input can indicate the size of the
    pkt. Any remaining size is saved in hif_dev->rx_remain_len.
    While processing the next input, memcpy is used with rx_remain_len.
    
    4-byte pkt_len can go up to 0xffff, while a single input is 0x4000
    maximum in size (MAX_RX_BUF_SIZE). Thus, the patch adds a check for
    pkt_len which must not exceed 2 * MAX_RX_BUG_SIZE.
    
    BUG: KASAN: slab-out-of-bounds in ath9k_hif_usb_rx_cb+0x490/0xed7 [ath9k_htc]
    Read of size 46393 at addr ffff888018798000 by task kworker/0:1/23
    
    CPU: 0 PID: 23 Comm: kworker/0:1 Not tainted 5.6.0 #63
    Hardware name: QEMU Standard PC (i440FX + PIIX, 1996),
    BIOS rel-1.10.2-0-g5f4c7b1-prebuilt.qemu-project.org 04/01/2014
    Workqueue: events request_firmware_work_func
    Call Trace:
     <IRQ>
     dump_stack+0x76/0xa0
     print_address_description.constprop.0+0x16/0x200
     ? ath9k_hif_usb_rx_cb+0x490/0xed7 [ath9k_htc]
     ? ath9k_hif_usb_rx_cb+0x490/0xed7 [ath9k_htc]
     __kasan_report.cold+0x37/0x7c
     ? ath9k_hif_usb_rx_cb+0x490/0xed7 [ath9k_htc]
     kasan_report+0xe/0x20
     check_memory_region+0x15a/0x1d0
     memcpy+0x20/0x50
     ath9k_hif_usb_rx_cb+0x490/0xed7 [ath9k_htc]
     ? hif_usb_mgmt_cb+0x2d9/0x2d9 [ath9k_htc]
     ? _raw_spin_lock_irqsave+0x7b/0xd0
     ? _raw_spin_trylock_bh+0x120/0x120
     ? __usb_unanchor_urb+0x12f/0x210
     __usb_hcd_giveback_urb+0x1e4/0x380
     usb_giveback_urb_bh+0x241/0x4f0
     ? __hrtimer_run_queues+0x316/0x740
     ? __usb_hcd_giveback_urb+0x380/0x380
     tasklet_action_common.isra.0+0x135/0x330
     __do_softirq+0x18c/0x634
     irq_exit+0x114/0x140
     smp_apic_timer_interrupt+0xde/0x380
     apic_timer_interrupt+0xf/0x20
    
    I found the bug using a custome USBFuzz port. It's a research work
    to fuzz USB stack/drivers. I modified it to fuzz ath9k driver only,
    providing hand-crafted usb descriptors to QEMU.
    
    After fixing the value of pkt_tag to ATH_USB_RX_STREAM_MODE_TAG in QEMU
    emulation, I found the KASAN report. The bug is triggerable whenever
    pkt_len is above two MAX_RX_BUG_SIZE. I used the same input that crashes
    to test the driver works when applying the patch.
    
    Signed-off-by: Zekun Shen <bruceshenzk@gmail.com>
    Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
    Link: https://lore.kernel.org/r/YXsidrRuK6zBJicZ@10-18-43-117.dynapool.wireless.nyu.edu
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 105f110a3632c89cf19b2227dfb4f70cd10c9799
Author: Zekun Shen <bruceshenzk@gmail.com>
Date:   Thu Oct 28 18:37:49 2021 -0400

    ar5523: Fix null-ptr-deref with unexpected WDCMSG_TARGET_START reply
    
    [ Upstream commit ae80b6033834342601e99f74f6a62ff5092b1cee ]
    
    Unexpected WDCMSG_TARGET_START replay can lead to null-ptr-deref
    when ar->tx_cmd->odata is NULL. The patch adds a null check to
    prevent such case.
    
    KASAN: null-ptr-deref in range [0x0000000000000000-0x0000000000000007]
     ar5523_cmd+0x46a/0x581 [ar5523]
     ar5523_probe.cold+0x1b7/0x18da [ar5523]
     ? ar5523_cmd_rx_cb+0x7a0/0x7a0 [ar5523]
     ? __pm_runtime_set_status+0x54a/0x8f0
     ? _raw_spin_trylock_bh+0x120/0x120
     ? pm_runtime_barrier+0x220/0x220
     ? __pm_runtime_resume+0xb1/0xf0
     usb_probe_interface+0x25b/0x710
     really_probe+0x209/0x5d0
     driver_probe_device+0xc6/0x1b0
     device_driver_attach+0xe2/0x120
    
    I found the bug using a custome USBFuzz port. It's a research work
    to fuzz USB stack/drivers. I modified it to fuzz ath9k driver only,
    providing hand-crafted usb descriptors to QEMU.
    
    After fixing the code (fourth byte in usb packet) to WDCMSG_TARGET_START,
    I got the null-ptr-deref bug. I believe the bug is triggerable whenever
    cmd->odata is NULL. After patching, I tested with the same input and no
    longer see the KASAN report.
    
    This was NOT tested on a real device.
    
    Signed-off-by: Zekun Shen <bruceshenzk@gmail.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
    Link: https://lore.kernel.org/r/YXsmPQ3awHFLuAj2@10-18-43-117.dynapool.wireless.nyu.edu
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit ee29701dfeef15bc770a4c92e512efe6a3760e4d
Author: Zekun Shen <bruceshenzk@gmail.com>
Date:   Thu Oct 28 18:21:42 2021 -0400

    ath9k: Fix out-of-bound memcpy in ath9k_hif_usb_rx_stream
    
    [ Upstream commit 6ce708f54cc8d73beca213cec66ede5ce100a781 ]
    
    Large pkt_len can lead to out-out-bound memcpy. Current
    ath9k_hif_usb_rx_stream allows combining the content of two urb
    inputs to one pkt. The first input can indicate the size of the
    pkt. Any remaining size is saved in hif_dev->rx_remain_len.
    While processing the next input, memcpy is used with rx_remain_len.
    
    4-byte pkt_len can go up to 0xffff, while a single input is 0x4000
    maximum in size (MAX_RX_BUF_SIZE). Thus, the patch adds a check for
    pkt_len which must not exceed 2 * MAX_RX_BUG_SIZE.
    
    BUG: KASAN: slab-out-of-bounds in ath9k_hif_usb_rx_cb+0x490/0xed7 [ath9k_htc]
    Read of size 46393 at addr ffff888018798000 by task kworker/0:1/23
    
    CPU: 0 PID: 23 Comm: kworker/0:1 Not tainted 5.6.0 #63
    Hardware name: QEMU Standard PC (i440FX + PIIX, 1996),
    BIOS rel-1.10.2-0-g5f4c7b1-prebuilt.qemu-project.org 04/01/2014
    Workqueue: events request_firmware_work_func
    Call Trace:
     <IRQ>
     dump_stack+0x76/0xa0
     print_address_description.constprop.0+0x16/0x200
     ? ath9k_hif_usb_rx_cb+0x490/0xed7 [ath9k_htc]
     ? ath9k_hif_usb_rx_cb+0x490/0xed7 [ath9k_htc]
     __kasan_report.cold+0x37/0x7c
     ? ath9k_hif_usb_rx_cb+0x490/0xed7 [ath9k_htc]
     kasan_report+0xe/0x20
     check_memory_region+0x15a/0x1d0
     memcpy+0x20/0x50
     ath9k_hif_usb_rx_cb+0x490/0xed7 [ath9k_htc]
     ? hif_usb_mgmt_cb+0x2d9/0x2d9 [ath9k_htc]
     ? _raw_spin_lock_irqsave+0x7b/0xd0
     ? _raw_spin_trylock_bh+0x120/0x120
     ? __usb_unanchor_urb+0x12f/0x210
     __usb_hcd_giveback_urb+0x1e4/0x380
     usb_giveback_urb_bh+0x241/0x4f0
     ? __hrtimer_run_queues+0x316/0x740
     ? __usb_hcd_giveback_urb+0x380/0x380
     tasklet_action_common.isra.0+0x135/0x330
     __do_softirq+0x18c/0x634
     irq_exit+0x114/0x140
     smp_apic_timer_interrupt+0xde/0x380
     apic_timer_interrupt+0xf/0x20
    
    I found the bug using a custome USBFuzz port. It's a research work
    to fuzz USB stack/drivers. I modified it to fuzz ath9k driver only,
    providing hand-crafted usb descriptors to QEMU.
    
    After fixing the value of pkt_tag to ATH_USB_RX_STREAM_MODE_TAG in QEMU
    emulation, I found the KASAN report. The bug is triggerable whenever
    pkt_len is above two MAX_RX_BUG_SIZE. I used the same input that crashes
    to test the driver works when applying the patch.
    
    Signed-off-by: Zekun Shen <bruceshenzk@gmail.com>
    Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
    Link: https://lore.kernel.org/r/YXsidrRuK6zBJicZ@10-18-43-117.dynapool.wireless.nyu.edu
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 729674532ddac2cb6866d0da60d8f3dd0c603096
Author: Zekun Shen <bruceshenzk@gmail.com>
Date:   Thu Oct 28 18:37:49 2021 -0400

    ar5523: Fix null-ptr-deref with unexpected WDCMSG_TARGET_START reply
    
    [ Upstream commit ae80b6033834342601e99f74f6a62ff5092b1cee ]
    
    Unexpected WDCMSG_TARGET_START replay can lead to null-ptr-deref
    when ar->tx_cmd->odata is NULL. The patch adds a null check to
    prevent such case.
    
    KASAN: null-ptr-deref in range [0x0000000000000000-0x0000000000000007]
     ar5523_cmd+0x46a/0x581 [ar5523]
     ar5523_probe.cold+0x1b7/0x18da [ar5523]
     ? ar5523_cmd_rx_cb+0x7a0/0x7a0 [ar5523]
     ? __pm_runtime_set_status+0x54a/0x8f0
     ? _raw_spin_trylock_bh+0x120/0x120
     ? pm_runtime_barrier+0x220/0x220
     ? __pm_runtime_resume+0xb1/0xf0
     usb_probe_interface+0x25b/0x710
     really_probe+0x209/0x5d0
     driver_probe_device+0xc6/0x1b0
     device_driver_attach+0xe2/0x120
    
    I found the bug using a custome USBFuzz port. It's a research work
    to fuzz USB stack/drivers. I modified it to fuzz ath9k driver only,
    providing hand-crafted usb descriptors to QEMU.
    
    After fixing the code (fourth byte in usb packet) to WDCMSG_TARGET_START,
    I got the null-ptr-deref bug. I believe the bug is triggerable whenever
    cmd->odata is NULL. After patching, I tested with the same input and no
    longer see the KASAN report.
    
    This was NOT tested on a real device.
    
    Signed-off-by: Zekun Shen <bruceshenzk@gmail.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
    Link: https://lore.kernel.org/r/YXsmPQ3awHFLuAj2@10-18-43-117.dynapool.wireless.nyu.edu
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 36371eb1ffa10fec85edc074cfb9475a957f9012
Author: Zekun Shen <bruceshenzk@gmail.com>
Date:   Thu Oct 28 18:21:42 2021 -0400

    ath9k: Fix out-of-bound memcpy in ath9k_hif_usb_rx_stream
    
    [ Upstream commit 6ce708f54cc8d73beca213cec66ede5ce100a781 ]
    
    Large pkt_len can lead to out-out-bound memcpy. Current
    ath9k_hif_usb_rx_stream allows combining the content of two urb
    inputs to one pkt. The first input can indicate the size of the
    pkt. Any remaining size is saved in hif_dev->rx_remain_len.
    While processing the next input, memcpy is used with rx_remain_len.
    
    4-byte pkt_len can go up to 0xffff, while a single input is 0x4000
    maximum in size (MAX_RX_BUF_SIZE). Thus, the patch adds a check for
    pkt_len which must not exceed 2 * MAX_RX_BUG_SIZE.
    
    BUG: KASAN: slab-out-of-bounds in ath9k_hif_usb_rx_cb+0x490/0xed7 [ath9k_htc]
    Read of size 46393 at addr ffff888018798000 by task kworker/0:1/23
    
    CPU: 0 PID: 23 Comm: kworker/0:1 Not tainted 5.6.0 #63
    Hardware name: QEMU Standard PC (i440FX + PIIX, 1996),
    BIOS rel-1.10.2-0-g5f4c7b1-prebuilt.qemu-project.org 04/01/2014
    Workqueue: events request_firmware_work_func
    Call Trace:
     <IRQ>
     dump_stack+0x76/0xa0
     print_address_description.constprop.0+0x16/0x200
     ? ath9k_hif_usb_rx_cb+0x490/0xed7 [ath9k_htc]
     ? ath9k_hif_usb_rx_cb+0x490/0xed7 [ath9k_htc]
     __kasan_report.cold+0x37/0x7c
     ? ath9k_hif_usb_rx_cb+0x490/0xed7 [ath9k_htc]
     kasan_report+0xe/0x20
     check_memory_region+0x15a/0x1d0
     memcpy+0x20/0x50
     ath9k_hif_usb_rx_cb+0x490/0xed7 [ath9k_htc]
     ? hif_usb_mgmt_cb+0x2d9/0x2d9 [ath9k_htc]
     ? _raw_spin_lock_irqsave+0x7b/0xd0
     ? _raw_spin_trylock_bh+0x120/0x120
     ? __usb_unanchor_urb+0x12f/0x210
     __usb_hcd_giveback_urb+0x1e4/0x380
     usb_giveback_urb_bh+0x241/0x4f0
     ? __hrtimer_run_queues+0x316/0x740
     ? __usb_hcd_giveback_urb+0x380/0x380
     tasklet_action_common.isra.0+0x135/0x330
     __do_softirq+0x18c/0x634
     irq_exit+0x114/0x140
     smp_apic_timer_interrupt+0xde/0x380
     apic_timer_interrupt+0xf/0x20
    
    I found the bug using a custome USBFuzz port. It's a research work
    to fuzz USB stack/drivers. I modified it to fuzz ath9k driver only,
    providing hand-crafted usb descriptors to QEMU.
    
    After fixing the value of pkt_tag to ATH_USB_RX_STREAM_MODE_TAG in QEMU
    emulation, I found the KASAN report. The bug is triggerable whenever
    pkt_len is above two MAX_RX_BUG_SIZE. I used the same input that crashes
    to test the driver works when applying the patch.
    
    Signed-off-by: Zekun Shen <bruceshenzk@gmail.com>
    Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
    Link: https://lore.kernel.org/r/YXsidrRuK6zBJicZ@10-18-43-117.dynapool.wireless.nyu.edu
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit a5f1c71982623bbcda9ee21818b7f693e1536f05
Author: Zekun Shen <bruceshenzk@gmail.com>
Date:   Thu Oct 28 18:37:49 2021 -0400

    ar5523: Fix null-ptr-deref with unexpected WDCMSG_TARGET_START reply
    
    [ Upstream commit ae80b6033834342601e99f74f6a62ff5092b1cee ]
    
    Unexpected WDCMSG_TARGET_START replay can lead to null-ptr-deref
    when ar->tx_cmd->odata is NULL. The patch adds a null check to
    prevent such case.
    
    KASAN: null-ptr-deref in range [0x0000000000000000-0x0000000000000007]
     ar5523_cmd+0x46a/0x581 [ar5523]
     ar5523_probe.cold+0x1b7/0x18da [ar5523]
     ? ar5523_cmd_rx_cb+0x7a0/0x7a0 [ar5523]
     ? __pm_runtime_set_status+0x54a/0x8f0
     ? _raw_spin_trylock_bh+0x120/0x120
     ? pm_runtime_barrier+0x220/0x220
     ? __pm_runtime_resume+0xb1/0xf0
     usb_probe_interface+0x25b/0x710
     really_probe+0x209/0x5d0
     driver_probe_device+0xc6/0x1b0
     device_driver_attach+0xe2/0x120
    
    I found the bug using a custome USBFuzz port. It's a research work
    to fuzz USB stack/drivers. I modified it to fuzz ath9k driver only,
    providing hand-crafted usb descriptors to QEMU.
    
    After fixing the code (fourth byte in usb packet) to WDCMSG_TARGET_START,
    I got the null-ptr-deref bug. I believe the bug is triggerable whenever
    cmd->odata is NULL. After patching, I tested with the same input and no
    longer see the KASAN report.
    
    This was NOT tested on a real device.
    
    Signed-off-by: Zekun Shen <bruceshenzk@gmail.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
    Link: https://lore.kernel.org/r/YXsmPQ3awHFLuAj2@10-18-43-117.dynapool.wireless.nyu.edu
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 6ce708f54cc8d73beca213cec66ede5ce100a781
Author: Zekun Shen <bruceshenzk@gmail.com>
Date:   Thu Oct 28 18:21:42 2021 -0400

    ath9k: Fix out-of-bound memcpy in ath9k_hif_usb_rx_stream
    
    Large pkt_len can lead to out-out-bound memcpy. Current
    ath9k_hif_usb_rx_stream allows combining the content of two urb
    inputs to one pkt. The first input can indicate the size of the
    pkt. Any remaining size is saved in hif_dev->rx_remain_len.
    While processing the next input, memcpy is used with rx_remain_len.
    
    4-byte pkt_len can go up to 0xffff, while a single input is 0x4000
    maximum in size (MAX_RX_BUF_SIZE). Thus, the patch adds a check for
    pkt_len which must not exceed 2 * MAX_RX_BUG_SIZE.
    
    BUG: KASAN: slab-out-of-bounds in ath9k_hif_usb_rx_cb+0x490/0xed7 [ath9k_htc]
    Read of size 46393 at addr ffff888018798000 by task kworker/0:1/23
    
    CPU: 0 PID: 23 Comm: kworker/0:1 Not tainted 5.6.0 #63
    Hardware name: QEMU Standard PC (i440FX + PIIX, 1996),
    BIOS rel-1.10.2-0-g5f4c7b1-prebuilt.qemu-project.org 04/01/2014
    Workqueue: events request_firmware_work_func
    Call Trace:
     <IRQ>
     dump_stack+0x76/0xa0
     print_address_description.constprop.0+0x16/0x200
     ? ath9k_hif_usb_rx_cb+0x490/0xed7 [ath9k_htc]
     ? ath9k_hif_usb_rx_cb+0x490/0xed7 [ath9k_htc]
     __kasan_report.cold+0x37/0x7c
     ? ath9k_hif_usb_rx_cb+0x490/0xed7 [ath9k_htc]
     kasan_report+0xe/0x20
     check_memory_region+0x15a/0x1d0
     memcpy+0x20/0x50
     ath9k_hif_usb_rx_cb+0x490/0xed7 [ath9k_htc]
     ? hif_usb_mgmt_cb+0x2d9/0x2d9 [ath9k_htc]
     ? _raw_spin_lock_irqsave+0x7b/0xd0
     ? _raw_spin_trylock_bh+0x120/0x120
     ? __usb_unanchor_urb+0x12f/0x210
     __usb_hcd_giveback_urb+0x1e4/0x380
     usb_giveback_urb_bh+0x241/0x4f0
     ? __hrtimer_run_queues+0x316/0x740
     ? __usb_hcd_giveback_urb+0x380/0x380
     tasklet_action_common.isra.0+0x135/0x330
     __do_softirq+0x18c/0x634
     irq_exit+0x114/0x140
     smp_apic_timer_interrupt+0xde/0x380
     apic_timer_interrupt+0xf/0x20
    
    I found the bug using a custome USBFuzz port. It's a research work
    to fuzz USB stack/drivers. I modified it to fuzz ath9k driver only,
    providing hand-crafted usb descriptors to QEMU.
    
    After fixing the value of pkt_tag to ATH_USB_RX_STREAM_MODE_TAG in QEMU
    emulation, I found the KASAN report. The bug is triggerable whenever
    pkt_len is above two MAX_RX_BUG_SIZE. I used the same input that crashes
    to test the driver works when applying the patch.
    
    Signed-off-by: Zekun Shen <bruceshenzk@gmail.com>
    Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
    Link: https://lore.kernel.org/r/YXsidrRuK6zBJicZ@10-18-43-117.dynapool.wireless.nyu.edu

commit f1cb3476e48b60c450ec3a1d7da0805bffc6e43a
Author: Zekun Shen <bruceshenzk@gmail.com>
Date:   Fri Oct 29 16:19:23 2021 -0400

    rsi: Fix out-of-bounds read in rsi_read_pkt()
    
    rsi_get_* functions rely on an offset variable from usb
    input. The size of usb input is RSI_MAX_RX_USB_PKT_SIZE(3000),
    while 2-byte offset can be up to 0xFFFF. Thus a large offset
    can cause out-of-bounds read.
    
    The patch adds a bound checking condition when rcv_pkt_len is 0,
    indicating it's USB. It's unclear whether this is triggerable
    from other type of bus. The following check might help in that case.
    offset > rcv_pkt_len - FRAME_DESC_SZ
    
    The bug is trigerrable with conpromised/malfunctioning USB devices.
    I tested the patch with the crashing input and got no more bug report.
    
    Attached is the KASAN report from fuzzing.
    
    BUG: KASAN: slab-out-of-bounds in rsi_read_pkt+0x42e/0x500 [rsi_91x]
    Read of size 2 at addr ffff888019439fdb by task RX-Thread/227
    
    CPU: 0 PID: 227 Comm: RX-Thread Not tainted 5.6.0 #66
    Call Trace:
     dump_stack+0x76/0xa0
     print_address_description.constprop.0+0x16/0x200
     ? rsi_read_pkt+0x42e/0x500 [rsi_91x]
     ? rsi_read_pkt+0x42e/0x500 [rsi_91x]
     __kasan_report.cold+0x37/0x7c
     ? rsi_read_pkt+0x42e/0x500 [rsi_91x]
     kasan_report+0xe/0x20
     rsi_read_pkt+0x42e/0x500 [rsi_91x]
     rsi_usb_rx_thread+0x1b1/0x2fc [rsi_usb]
     ? rsi_probe+0x16a0/0x16a0 [rsi_usb]
     ? _raw_spin_lock_irqsave+0x7b/0xd0
     ? _raw_spin_trylock_bh+0x120/0x120
     ? __wake_up_common+0x10b/0x520
     ? rsi_probe+0x16a0/0x16a0 [rsi_usb]
     kthread+0x2b5/0x3b0
     ? kthread_create_on_node+0xd0/0xd0
     ret_from_fork+0x22/0x40
    
    Reported-by: Brendan Dolan-Gavitt <brendandg@nyu.edu>
    Signed-off-by: Zekun Shen <bruceshenzk@gmail.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
    Link: https://lore.kernel.org/r/YXxXS4wgu2OsmlVv@10-18-43-117.dynapool.wireless.nyu.edu

commit ae80b6033834342601e99f74f6a62ff5092b1cee
Author: Zekun Shen <bruceshenzk@gmail.com>
Date:   Thu Oct 28 18:37:49 2021 -0400

    ar5523: Fix null-ptr-deref with unexpected WDCMSG_TARGET_START reply
    
    Unexpected WDCMSG_TARGET_START replay can lead to null-ptr-deref
    when ar->tx_cmd->odata is NULL. The patch adds a null check to
    prevent such case.
    
    KASAN: null-ptr-deref in range [0x0000000000000000-0x0000000000000007]
     ar5523_cmd+0x46a/0x581 [ar5523]
     ar5523_probe.cold+0x1b7/0x18da [ar5523]
     ? ar5523_cmd_rx_cb+0x7a0/0x7a0 [ar5523]
     ? __pm_runtime_set_status+0x54a/0x8f0
     ? _raw_spin_trylock_bh+0x120/0x120
     ? pm_runtime_barrier+0x220/0x220
     ? __pm_runtime_resume+0xb1/0xf0
     usb_probe_interface+0x25b/0x710
     really_probe+0x209/0x5d0
     driver_probe_device+0xc6/0x1b0
     device_driver_attach+0xe2/0x120
    
    I found the bug using a custome USBFuzz port. It's a research work
    to fuzz USB stack/drivers. I modified it to fuzz ath9k driver only,
    providing hand-crafted usb descriptors to QEMU.
    
    After fixing the code (fourth byte in usb packet) to WDCMSG_TARGET_START,
    I got the null-ptr-deref bug. I believe the bug is triggerable whenever
    cmd->odata is NULL. After patching, I tested with the same input and no
    longer see the KASAN report.
    
    This was NOT tested on a real device.
    
    Signed-off-by: Zekun Shen <bruceshenzk@gmail.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
    Link: https://lore.kernel.org/r/YXsmPQ3awHFLuAj2@10-18-43-117.dynapool.wireless.nyu.edu

commit 61616be899975404df44c20ab902464b60882cd7
Author: Jacob Keller <jacob.e.keller@intel.com>
Date:   Mon Oct 11 13:48:06 2021 -0700

    ice: fix locking for Tx timestamp tracking flush
    
    commit 4d4a223a86afe658cd878800f09458e8bb54415d upstream.
    
    Commit 4dd0d5c33c3e ("ice: add lock around Tx timestamp tracker flush")
    added a lock around the Tx timestamp tracker flow which is used to
    cleanup any left over SKBs and prepare for device removal.
    
    This lock is problematic because it is being held around a call to
    ice_clear_phy_tstamp. The clear function takes a mutex to send a PHY
    write command to firmware. This could lead to a deadlock if the mutex
    actually sleeps, and causes the following warning on a kernel with
    preemption debugging enabled:
    
    [  715.419426] BUG: sleeping function called from invalid context at kernel/locking/mutex.c:573
    [  715.427900] in_atomic(): 1, irqs_disabled(): 0, non_block: 0, pid: 3100, name: rmmod
    [  715.435652] INFO: lockdep is turned off.
    [  715.439591] Preemption disabled at:
    [  715.439594] [<0000000000000000>] 0x0
    [  715.446678] CPU: 52 PID: 3100 Comm: rmmod Tainted: G        W  OE     5.15.0-rc4+ #42 bdd7ec3018e725f159ca0d372ce8c2c0e784891c
    [  715.458058] Hardware name: Intel Corporation S2600STQ/S2600STQ, BIOS SE5C620.86B.02.01.0010.010620200716 01/06/2020
    [  715.468483] Call Trace:
    [  715.470940]  dump_stack_lvl+0x6a/0x9a
    [  715.474613]  ___might_sleep.cold+0x224/0x26a
    [  715.478895]  __mutex_lock+0xb3/0x1440
    [  715.482569]  ? stack_depot_save+0x378/0x500
    [  715.486763]  ? ice_sq_send_cmd+0x78/0x14c0 [ice 9a7e1ec00971c89ecd3fe0d4dc7da2b3786a421d]
    [  715.494979]  ? kfree+0xc1/0x520
    [  715.498128]  ? mutex_lock_io_nested+0x12a0/0x12a0
    [  715.502837]  ? kasan_set_free_info+0x20/0x30
    [  715.507110]  ? __kasan_slab_free+0x10b/0x140
    [  715.511385]  ? slab_free_freelist_hook+0xc7/0x220
    [  715.516092]  ? kfree+0xc1/0x520
    [  715.519235]  ? ice_deinit_lag+0x16c/0x220 [ice 9a7e1ec00971c89ecd3fe0d4dc7da2b3786a421d]
    [  715.527359]  ? ice_remove+0x1cf/0x6a0 [ice 9a7e1ec00971c89ecd3fe0d4dc7da2b3786a421d]
    [  715.535133]  ? pci_device_remove+0xab/0x1d0
    [  715.539318]  ? __device_release_driver+0x35b/0x690
    [  715.544110]  ? driver_detach+0x214/0x2f0
    [  715.548035]  ? bus_remove_driver+0x11d/0x2f0
    [  715.552309]  ? pci_unregister_driver+0x26/0x250
    [  715.556840]  ? ice_module_exit+0xc/0x2f [ice 9a7e1ec00971c89ecd3fe0d4dc7da2b3786a421d]
    [  715.564799]  ? __do_sys_delete_module.constprop.0+0x2d8/0x4e0
    [  715.570554]  ? do_syscall_64+0x3b/0x90
    [  715.574303]  ? entry_SYSCALL_64_after_hwframe+0x44/0xae
    [  715.579529]  ? start_flush_work+0x542/0x8f0
    [  715.583719]  ? ice_sq_send_cmd+0x78/0x14c0 [ice 9a7e1ec00971c89ecd3fe0d4dc7da2b3786a421d]
    [  715.591923]  ice_sq_send_cmd+0x78/0x14c0 [ice 9a7e1ec00971c89ecd3fe0d4dc7da2b3786a421d]
    [  715.599960]  ? wait_for_completion_io+0x250/0x250
    [  715.604662]  ? lock_acquire+0x196/0x200
    [  715.608504]  ? do_raw_spin_trylock+0xa5/0x160
    [  715.612864]  ice_sbq_rw_reg+0x1e6/0x2f0 [ice 9a7e1ec00971c89ecd3fe0d4dc7da2b3786a421d]
    [  715.620813]  ? ice_reset+0x130/0x130 [ice 9a7e1ec00971c89ecd3fe0d4dc7da2b3786a421d]
    [  715.628497]  ? __debug_check_no_obj_freed+0x1e8/0x3c0
    [  715.633550]  ? trace_hardirqs_on+0x1c/0x130
    [  715.637748]  ice_write_phy_reg_e810+0x70/0xf0 [ice 9a7e1ec00971c89ecd3fe0d4dc7da2b3786a421d]
    [  715.646220]  ? do_raw_spin_trylock+0xa5/0x160
    [  715.650581]  ? ice_ptp_release+0x910/0x910 [ice 9a7e1ec00971c89ecd3fe0d4dc7da2b3786a421d]
    [  715.658797]  ? ice_ptp_release+0x255/0x910 [ice 9a7e1ec00971c89ecd3fe0d4dc7da2b3786a421d]
    [  715.667013]  ice_clear_phy_tstamp+0x2c/0x110 [ice 9a7e1ec00971c89ecd3fe0d4dc7da2b3786a421d]
    [  715.675403]  ice_ptp_release+0x408/0x910 [ice 9a7e1ec00971c89ecd3fe0d4dc7da2b3786a421d]
    [  715.683440]  ice_remove+0x560/0x6a0 [ice 9a7e1ec00971c89ecd3fe0d4dc7da2b3786a421d]
    [  715.691037]  ? _raw_spin_unlock_irqrestore+0x46/0x73
    [  715.696005]  pci_device_remove+0xab/0x1d0
    [  715.700018]  __device_release_driver+0x35b/0x690
    [  715.704637]  driver_detach+0x214/0x2f0
    [  715.708389]  bus_remove_driver+0x11d/0x2f0
    [  715.712489]  pci_unregister_driver+0x26/0x250
    [  715.716857]  ice_module_exit+0xc/0x2f [ice 9a7e1ec00971c89ecd3fe0d4dc7da2b3786a421d]
    [  715.724637]  __do_sys_delete_module.constprop.0+0x2d8/0x4e0
    [  715.730210]  ? free_module+0x6d0/0x6d0
    [  715.733963]  ? task_work_run+0xe1/0x170
    [  715.737803]  ? exit_to_user_mode_loop+0x17f/0x1d0
    [  715.742509]  ? rcu_read_lock_sched_held+0x12/0x80
    [  715.747215]  ? trace_hardirqs_on+0x1c/0x130
    [  715.751401]  do_syscall_64+0x3b/0x90
    [  715.754981]  entry_SYSCALL_64_after_hwframe+0x44/0xae
    [  715.760033] RIP: 0033:0x7f4dfe59000b
    [  715.763612] Code: 73 01 c3 48 8b 0d 6d 1e 0c 00 f7 d8 64 89 01 48 83 c8 ff c3 66 2e 0f 1f 84 00 00 00 00 00 90 f3 0f 1e fa b8 b0 00 00 00 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 8b 0d 3d 1e 0c 00 f7 d8 64 89 01 48
    [  715.782357] RSP: 002b:00007ffe8c891708 EFLAGS: 00000206 ORIG_RAX: 00000000000000b0
    [  715.789923] RAX: ffffffffffffffda RBX: 00005558a20468b0 RCX: 00007f4dfe59000b
    [  715.797054] RDX: 000000000000000a RSI: 0000000000000800 RDI: 00005558a2046918
    [  715.804189] RBP: 0000000000000000 R08: 0000000000000000 R09: 0000000000000000
    [  715.811319] R10: 00007f4dfe603ac0 R11: 0000000000000206 R12: 00007ffe8c891940
    [  715.818455] R13: 00007ffe8c8920a3 R14: 00005558a20462a0 R15: 00005558a20468b0
    
    Notice that this is the only case where we use the lock in this way. In
    the cleanup kthread and work kthread the lock is only taken around the
    bit accesses. This was done intentionally to avoid this kind of issue.
    The way the lock is used, we only protect ordering of bit sets vs bit
    clears. The Tx writers in the hot path don't need to be protected
    against the entire kthread loop. The Tx queues threads only need to
    ensure that they do not re-use an index that is currently in use. The
    cleanup loop does not need to block all new set bits, since it will
    re-queue itself if new timestamps are present.
    
    Fix the tracker flow so that it uses the same flow as the standard
    cleanup thread. In addition, ensure the in_use bitmap actually gets
    cleared properly.
    
    This fixes the warning and also avoids the potential deadlock that might
    have occurred otherwise.
    
    Fixes: 4dd0d5c33c3e ("ice: add lock around Tx timestamp tracker flush")
    Signed-off-by: Jacob Keller <jacob.e.keller@intel.com>
    Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 4d4a223a86afe658cd878800f09458e8bb54415d
Author: Jacob Keller <jacob.e.keller@intel.com>
Date:   Mon Oct 11 13:48:06 2021 -0700

    ice: fix locking for Tx timestamp tracking flush
    
    Commit 4dd0d5c33c3e ("ice: add lock around Tx timestamp tracker flush")
    added a lock around the Tx timestamp tracker flow which is used to
    cleanup any left over SKBs and prepare for device removal.
    
    This lock is problematic because it is being held around a call to
    ice_clear_phy_tstamp. The clear function takes a mutex to send a PHY
    write command to firmware. This could lead to a deadlock if the mutex
    actually sleeps, and causes the following warning on a kernel with
    preemption debugging enabled:
    
    [  715.419426] BUG: sleeping function called from invalid context at kernel/locking/mutex.c:573
    [  715.427900] in_atomic(): 1, irqs_disabled(): 0, non_block: 0, pid: 3100, name: rmmod
    [  715.435652] INFO: lockdep is turned off.
    [  715.439591] Preemption disabled at:
    [  715.439594] [<0000000000000000>] 0x0
    [  715.446678] CPU: 52 PID: 3100 Comm: rmmod Tainted: G        W  OE     5.15.0-rc4+ #42 bdd7ec3018e725f159ca0d372ce8c2c0e784891c
    [  715.458058] Hardware name: Intel Corporation S2600STQ/S2600STQ, BIOS SE5C620.86B.02.01.0010.010620200716 01/06/2020
    [  715.468483] Call Trace:
    [  715.470940]  dump_stack_lvl+0x6a/0x9a
    [  715.474613]  ___might_sleep.cold+0x224/0x26a
    [  715.478895]  __mutex_lock+0xb3/0x1440
    [  715.482569]  ? stack_depot_save+0x378/0x500
    [  715.486763]  ? ice_sq_send_cmd+0x78/0x14c0 [ice 9a7e1ec00971c89ecd3fe0d4dc7da2b3786a421d]
    [  715.494979]  ? kfree+0xc1/0x520
    [  715.498128]  ? mutex_lock_io_nested+0x12a0/0x12a0
    [  715.502837]  ? kasan_set_free_info+0x20/0x30
    [  715.507110]  ? __kasan_slab_free+0x10b/0x140
    [  715.511385]  ? slab_free_freelist_hook+0xc7/0x220
    [  715.516092]  ? kfree+0xc1/0x520
    [  715.519235]  ? ice_deinit_lag+0x16c/0x220 [ice 9a7e1ec00971c89ecd3fe0d4dc7da2b3786a421d]
    [  715.527359]  ? ice_remove+0x1cf/0x6a0 [ice 9a7e1ec00971c89ecd3fe0d4dc7da2b3786a421d]
    [  715.535133]  ? pci_device_remove+0xab/0x1d0
    [  715.539318]  ? __device_release_driver+0x35b/0x690
    [  715.544110]  ? driver_detach+0x214/0x2f0
    [  715.548035]  ? bus_remove_driver+0x11d/0x2f0
    [  715.552309]  ? pci_unregister_driver+0x26/0x250
    [  715.556840]  ? ice_module_exit+0xc/0x2f [ice 9a7e1ec00971c89ecd3fe0d4dc7da2b3786a421d]
    [  715.564799]  ? __do_sys_delete_module.constprop.0+0x2d8/0x4e0
    [  715.570554]  ? do_syscall_64+0x3b/0x90
    [  715.574303]  ? entry_SYSCALL_64_after_hwframe+0x44/0xae
    [  715.579529]  ? start_flush_work+0x542/0x8f0
    [  715.583719]  ? ice_sq_send_cmd+0x78/0x14c0 [ice 9a7e1ec00971c89ecd3fe0d4dc7da2b3786a421d]
    [  715.591923]  ice_sq_send_cmd+0x78/0x14c0 [ice 9a7e1ec00971c89ecd3fe0d4dc7da2b3786a421d]
    [  715.599960]  ? wait_for_completion_io+0x250/0x250
    [  715.604662]  ? lock_acquire+0x196/0x200
    [  715.608504]  ? do_raw_spin_trylock+0xa5/0x160
    [  715.612864]  ice_sbq_rw_reg+0x1e6/0x2f0 [ice 9a7e1ec00971c89ecd3fe0d4dc7da2b3786a421d]
    [  715.620813]  ? ice_reset+0x130/0x130 [ice 9a7e1ec00971c89ecd3fe0d4dc7da2b3786a421d]
    [  715.628497]  ? __debug_check_no_obj_freed+0x1e8/0x3c0
    [  715.633550]  ? trace_hardirqs_on+0x1c/0x130
    [  715.637748]  ice_write_phy_reg_e810+0x70/0xf0 [ice 9a7e1ec00971c89ecd3fe0d4dc7da2b3786a421d]
    [  715.646220]  ? do_raw_spin_trylock+0xa5/0x160
    [  715.650581]  ? ice_ptp_release+0x910/0x910 [ice 9a7e1ec00971c89ecd3fe0d4dc7da2b3786a421d]
    [  715.658797]  ? ice_ptp_release+0x255/0x910 [ice 9a7e1ec00971c89ecd3fe0d4dc7da2b3786a421d]
    [  715.667013]  ice_clear_phy_tstamp+0x2c/0x110 [ice 9a7e1ec00971c89ecd3fe0d4dc7da2b3786a421d]
    [  715.675403]  ice_ptp_release+0x408/0x910 [ice 9a7e1ec00971c89ecd3fe0d4dc7da2b3786a421d]
    [  715.683440]  ice_remove+0x560/0x6a0 [ice 9a7e1ec00971c89ecd3fe0d4dc7da2b3786a421d]
    [  715.691037]  ? _raw_spin_unlock_irqrestore+0x46/0x73
    [  715.696005]  pci_device_remove+0xab/0x1d0
    [  715.700018]  __device_release_driver+0x35b/0x690
    [  715.704637]  driver_detach+0x214/0x2f0
    [  715.708389]  bus_remove_driver+0x11d/0x2f0
    [  715.712489]  pci_unregister_driver+0x26/0x250
    [  715.716857]  ice_module_exit+0xc/0x2f [ice 9a7e1ec00971c89ecd3fe0d4dc7da2b3786a421d]
    [  715.724637]  __do_sys_delete_module.constprop.0+0x2d8/0x4e0
    [  715.730210]  ? free_module+0x6d0/0x6d0
    [  715.733963]  ? task_work_run+0xe1/0x170
    [  715.737803]  ? exit_to_user_mode_loop+0x17f/0x1d0
    [  715.742509]  ? rcu_read_lock_sched_held+0x12/0x80
    [  715.747215]  ? trace_hardirqs_on+0x1c/0x130
    [  715.751401]  do_syscall_64+0x3b/0x90
    [  715.754981]  entry_SYSCALL_64_after_hwframe+0x44/0xae
    [  715.760033] RIP: 0033:0x7f4dfe59000b
    [  715.763612] Code: 73 01 c3 48 8b 0d 6d 1e 0c 00 f7 d8 64 89 01 48 83 c8 ff c3 66 2e 0f 1f 84 00 00 00 00 00 90 f3 0f 1e fa b8 b0 00 00 00 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 8b 0d 3d 1e 0c 00 f7 d8 64 89 01 48
    [  715.782357] RSP: 002b:00007ffe8c891708 EFLAGS: 00000206 ORIG_RAX: 00000000000000b0
    [  715.789923] RAX: ffffffffffffffda RBX: 00005558a20468b0 RCX: 00007f4dfe59000b
    [  715.797054] RDX: 000000000000000a RSI: 0000000000000800 RDI: 00005558a2046918
    [  715.804189] RBP: 0000000000000000 R08: 0000000000000000 R09: 0000000000000000
    [  715.811319] R10: 00007f4dfe603ac0 R11: 0000000000000206 R12: 00007ffe8c891940
    [  715.818455] R13: 00007ffe8c8920a3 R14: 00005558a20462a0 R15: 00005558a20468b0
    
    Notice that this is the only case where we use the lock in this way. In
    the cleanup kthread and work kthread the lock is only taken around the
    bit accesses. This was done intentionally to avoid this kind of issue.
    The way the lock is used, we only protect ordering of bit sets vs bit
    clears. The Tx writers in the hot path don't need to be protected
    against the entire kthread loop. The Tx queues threads only need to
    ensure that they do not re-use an index that is currently in use. The
    cleanup loop does not need to block all new set bits, since it will
    re-queue itself if new timestamps are present.
    
    Fix the tracker flow so that it uses the same flow as the standard
    cleanup thread. In addition, ensure the in_use bitmap actually gets
    cleared properly.
    
    This fixes the warning and also avoids the potential deadlock that might
    have occurred otherwise.
    
    Fixes: 4dd0d5c33c3e ("ice: add lock around Tx timestamp tracker flush")
    Signed-off-by: Jacob Keller <jacob.e.keller@intel.com>
    Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit ae746b6f4ce619cf4032fd798a232b010907a397
Author: Pawel Laszczak <pawell@cadence.com>
Date:   Wed May 26 08:05:27 2021 +0200

    usb: cdnsp: Fix deadlock issue in cdnsp_thread_irq_handler
    
    commit a9aecef198faae3240921b707bc09b602e966fce upstream.
    
    Patch fixes the following critical issue caused by deadlock which has been
    detected during testing NCM class:
    
    smp: csd: Detected non-responsive CSD lock (#1) on CPU#0
    smp:     csd: CSD lock (#1) unresponsive.
    ....
    RIP: 0010:native_queued_spin_lock_slowpath+0x61/0x1d0
    RSP: 0018:ffffbc494011cde0 EFLAGS: 00000002
    RAX: 0000000000000101 RBX: ffff9ee8116b4a68 RCX: 0000000000000000
    RDX: 0000000000000000 RSI: 0000000000000000 RDI: ffff9ee8116b4658
    RBP: ffffbc494011cde0 R08: 0000000000000001 R09: 0000000000000000
    R10: ffff9ee8116b4670 R11: 0000000000000000 R12: ffff9ee8116b4658
    R13: ffff9ee8116b4670 R14: 0000000000000246 R15: ffff9ee8116b4658
    CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    CR2: 00007f7bcc41a830 CR3: 000000007a612003 CR4: 00000000001706e0
    Call Trace:
     <IRQ>
     do_raw_spin_lock+0xc0/0xd0
     _raw_spin_lock_irqsave+0x95/0xa0
     cdnsp_gadget_ep_queue.cold+0x88/0x107 [cdnsp_udc_pci]
     usb_ep_queue+0x35/0x110
     eth_start_xmit+0x220/0x3d0 [u_ether]
     ncm_tx_timeout+0x34/0x40 [usb_f_ncm]
     ? ncm_free_inst+0x50/0x50 [usb_f_ncm]
     __hrtimer_run_queues+0xac/0x440
     hrtimer_run_softirq+0x8c/0xb0
     __do_softirq+0xcf/0x428
     asm_call_irq_on_stack+0x12/0x20
     </IRQ>
     do_softirq_own_stack+0x61/0x70
     irq_exit_rcu+0xc1/0xd0
     sysvec_apic_timer_interrupt+0x52/0xb0
     asm_sysvec_apic_timer_interrupt+0x12/0x20
    RIP: 0010:do_raw_spin_trylock+0x18/0x40
    RSP: 0018:ffffbc494138bda8 EFLAGS: 00000246
    RAX: 0000000000000000 RBX: ffff9ee8116b4658 RCX: 0000000000000000
    RDX: 0000000000000001 RSI: 0000000000000000 RDI: ffff9ee8116b4658
    RBP: ffffbc494138bda8 R08: 0000000000000001 R09: 0000000000000000
    R10: ffff9ee8116b4670 R11: 0000000000000000 R12: ffff9ee8116b4658
    R13: ffff9ee8116b4670 R14: ffff9ee7b5c73d80 R15: ffff9ee8116b4000
     _raw_spin_lock+0x3d/0x70
     ? cdnsp_thread_irq_handler.cold+0x32/0x112c [cdnsp_udc_pci]
     cdnsp_thread_irq_handler.cold+0x32/0x112c [cdnsp_udc_pci]
     ? cdnsp_remove_request+0x1f0/0x1f0 [cdnsp_udc_pci]
     ? cdnsp_thread_irq_handler+0x5/0xa0 [cdnsp_udc_pci]
     ? irq_thread+0xa0/0x1c0
     irq_thread_fn+0x28/0x60
     irq_thread+0x105/0x1c0
     ? __kthread_parkme+0x42/0x90
     ? irq_forced_thread_fn+0x90/0x90
     ? wake_threads_waitq+0x30/0x30
     ? irq_thread_check_affinity+0xe0/0xe0
     kthread+0x12a/0x160
     ? kthread_park+0x90/0x90
     ret_from_fork+0x22/0x30
    
    The root cause of issue is spin_lock/spin_unlock instruction instead
    spin_lock_irqsave/spin_lock_irqrestore in cdnsp_thread_irq_handler
    function.
    
    Cc: stable@vger.kernel.org
    Fixes: 3d82904559f4 ("usb: cdnsp: cdns3 Add main part of Cadence USBSSP DRD Driver")
    Signed-off-by: Pawel Laszczak <pawell@cadence.com>
    Link: https://lore.kernel.org/r/20210526060527.7197-1-pawell@gli-login.cadence.com
    Signed-off-by: Peter Chen <peter.chen@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit a9aecef198faae3240921b707bc09b602e966fce
Author: Pawel Laszczak <pawell@cadence.com>
Date:   Wed May 26 08:05:27 2021 +0200

    usb: cdnsp: Fix deadlock issue in cdnsp_thread_irq_handler
    
    Patch fixes the following critical issue caused by deadlock which has been
    detected during testing NCM class:
    
    smp: csd: Detected non-responsive CSD lock (#1) on CPU#0
    smp:     csd: CSD lock (#1) unresponsive.
    ....
    RIP: 0010:native_queued_spin_lock_slowpath+0x61/0x1d0
    RSP: 0018:ffffbc494011cde0 EFLAGS: 00000002
    RAX: 0000000000000101 RBX: ffff9ee8116b4a68 RCX: 0000000000000000
    RDX: 0000000000000000 RSI: 0000000000000000 RDI: ffff9ee8116b4658
    RBP: ffffbc494011cde0 R08: 0000000000000001 R09: 0000000000000000
    R10: ffff9ee8116b4670 R11: 0000000000000000 R12: ffff9ee8116b4658
    R13: ffff9ee8116b4670 R14: 0000000000000246 R15: ffff9ee8116b4658
    CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    CR2: 00007f7bcc41a830 CR3: 000000007a612003 CR4: 00000000001706e0
    Call Trace:
     <IRQ>
     do_raw_spin_lock+0xc0/0xd0
     _raw_spin_lock_irqsave+0x95/0xa0
     cdnsp_gadget_ep_queue.cold+0x88/0x107 [cdnsp_udc_pci]
     usb_ep_queue+0x35/0x110
     eth_start_xmit+0x220/0x3d0 [u_ether]
     ncm_tx_timeout+0x34/0x40 [usb_f_ncm]
     ? ncm_free_inst+0x50/0x50 [usb_f_ncm]
     __hrtimer_run_queues+0xac/0x440
     hrtimer_run_softirq+0x8c/0xb0
     __do_softirq+0xcf/0x428
     asm_call_irq_on_stack+0x12/0x20
     </IRQ>
     do_softirq_own_stack+0x61/0x70
     irq_exit_rcu+0xc1/0xd0
     sysvec_apic_timer_interrupt+0x52/0xb0
     asm_sysvec_apic_timer_interrupt+0x12/0x20
    RIP: 0010:do_raw_spin_trylock+0x18/0x40
    RSP: 0018:ffffbc494138bda8 EFLAGS: 00000246
    RAX: 0000000000000000 RBX: ffff9ee8116b4658 RCX: 0000000000000000
    RDX: 0000000000000001 RSI: 0000000000000000 RDI: ffff9ee8116b4658
    RBP: ffffbc494138bda8 R08: 0000000000000001 R09: 0000000000000000
    R10: ffff9ee8116b4670 R11: 0000000000000000 R12: ffff9ee8116b4658
    R13: ffff9ee8116b4670 R14: ffff9ee7b5c73d80 R15: ffff9ee8116b4000
     _raw_spin_lock+0x3d/0x70
     ? cdnsp_thread_irq_handler.cold+0x32/0x112c [cdnsp_udc_pci]
     cdnsp_thread_irq_handler.cold+0x32/0x112c [cdnsp_udc_pci]
     ? cdnsp_remove_request+0x1f0/0x1f0 [cdnsp_udc_pci]
     ? cdnsp_thread_irq_handler+0x5/0xa0 [cdnsp_udc_pci]
     ? irq_thread+0xa0/0x1c0
     irq_thread_fn+0x28/0x60
     irq_thread+0x105/0x1c0
     ? __kthread_parkme+0x42/0x90
     ? irq_forced_thread_fn+0x90/0x90
     ? wake_threads_waitq+0x30/0x30
     ? irq_thread_check_affinity+0xe0/0xe0
     kthread+0x12a/0x160
     ? kthread_park+0x90/0x90
     ret_from_fork+0x22/0x30
    
    The root cause of issue is spin_lock/spin_unlock instruction instead
    spin_lock_irqsave/spin_lock_irqrestore in cdnsp_thread_irq_handler
    function.
    
    Cc: stable@vger.kernel.org
    Fixes: 3d82904559f4 ("usb: cdnsp: cdns3 Add main part of Cadence USBSSP DRD Driver")
    Signed-off-by: Pawel Laszczak <pawell@cadence.com>
    
    Link: https://lore.kernel.org/r/20210526060527.7197-1-pawell@gli-login.cadence.com
    Signed-off-by: Peter Chen <peter.chen@kernel.org>

commit 3799cc62513a58f314ebdde8efe2c9fbfedfd4ff
Author: Song Liu <songliubraving@fb.com>
Date:   Mon Oct 5 09:58:38 2020 -0700

    bpf: Use raw_spin_trylock() for pcpu_freelist_push/pop in NMI
    
    [ Upstream commit 39d8f0d1026a990604770a658708f5845f7dbec0 ]
    
    Recent improvements in LOCKDEP highlighted a potential A-A deadlock with
    pcpu_freelist in NMI:
    
    ./tools/testing/selftests/bpf/test_progs -t stacktrace_build_id_nmi
    
    [   18.984807] ================================
    [   18.984807] WARNING: inconsistent lock state
    [   18.984808] 5.9.0-rc6-01771-g1466de1330e1 #2967 Not tainted
    [   18.984809] --------------------------------
    [   18.984809] inconsistent {INITIAL USE} -> {IN-NMI} usage.
    [   18.984810] test_progs/1990 [HC2[2]:SC0[0]:HE0:SE1] takes:
    [   18.984810] ffffe8ffffc219c0 (&head->lock){....}-{2:2}, at: __pcpu_freelist_pop+0xe3/0x180
    [   18.984813] {INITIAL USE} state was registered at:
    [   18.984814]   lock_acquire+0x175/0x7c0
    [   18.984814]   _raw_spin_lock+0x2c/0x40
    [   18.984815]   __pcpu_freelist_pop+0xe3/0x180
    [   18.984815]   pcpu_freelist_pop+0x31/0x40
    [   18.984816]   htab_map_alloc+0xbbf/0xf40
    [   18.984816]   __do_sys_bpf+0x5aa/0x3ed0
    [   18.984817]   do_syscall_64+0x2d/0x40
    [   18.984818]   entry_SYSCALL_64_after_hwframe+0x44/0xa9
    [   18.984818] irq event stamp: 12
    [...]
    [   18.984822] other info that might help us debug this:
    [   18.984823]  Possible unsafe locking scenario:
    [   18.984823]
    [   18.984824]        CPU0
    [   18.984824]        ----
    [   18.984824]   lock(&head->lock);
    [   18.984826]   <Interrupt>
    [   18.984826]     lock(&head->lock);
    [   18.984827]
    [   18.984828]  *** DEADLOCK ***
    [   18.984828]
    [   18.984829] 2 locks held by test_progs/1990:
    [...]
    [   18.984838]  <NMI>
    [   18.984838]  dump_stack+0x9a/0xd0
    [   18.984839]  lock_acquire+0x5c9/0x7c0
    [   18.984839]  ? lock_release+0x6f0/0x6f0
    [   18.984840]  ? __pcpu_freelist_pop+0xe3/0x180
    [   18.984840]  _raw_spin_lock+0x2c/0x40
    [   18.984841]  ? __pcpu_freelist_pop+0xe3/0x180
    [   18.984841]  __pcpu_freelist_pop+0xe3/0x180
    [   18.984842]  pcpu_freelist_pop+0x17/0x40
    [   18.984842]  ? lock_release+0x6f0/0x6f0
    [   18.984843]  __bpf_get_stackid+0x534/0xaf0
    [   18.984843]  bpf_prog_1fd9e30e1438d3c5_oncpu+0x73/0x350
    [   18.984844]  bpf_overflow_handler+0x12f/0x3f0
    
    This is because pcpu_freelist_head.lock is accessed in both NMI and
    non-NMI context. Fix this issue by using raw_spin_trylock() in NMI.
    
    Since NMI interrupts non-NMI context, when NMI context tries to lock the
    raw_spinlock, non-NMI context of the same CPU may already have locked a
    lock and is blocked from unlocking the lock. For a system with N CPUs,
    there could be N NMIs at the same time, and they may block N non-NMI
    raw_spinlocks. This is tricky for pcpu_freelist_push(), where unlike
    _pop(), failing _push() means leaking memory. This issue is more likely to
    trigger in non-SMP system.
    
    Fix this issue with an extra list, pcpu_freelist.extralist. The extralist
    is primarily used to take _push() when raw_spin_trylock() failed on all
    the per CPU lists. It should be empty most of the time. The following
    table summarizes the behavior of pcpu_freelist in NMI and non-NMI:
    
    non-NMI pop():  use _lock(); check per CPU lists first;
                    if all per CPU lists are empty, check extralist;
                    if extralist is empty, return NULL.
    
    non-NMI push(): use _lock(); only push to per CPU lists.
    
    NMI pop():    use _trylock(); check per CPU lists first;
                  if all per CPU lists are locked or empty, check extralist;
                  if extralist is locked or empty, return NULL.
    
    NMI push():   use _trylock(); check per CPU lists first;
                  if all per CPU lists are locked; try push to extralist;
                  if extralist is also locked, keep trying on per CPU lists.
    
    Reported-by: Alexei Starovoitov <ast@kernel.org>
    Signed-off-by: Song Liu <songliubraving@fb.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
    Acked-by: Martin KaFai Lau <kafai@fb.com>
    Link: https://lore.kernel.org/bpf/20201005165838.3735218-1-songliubraving@fb.com
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 6cc0a248bcfa9b9f9511f2a55c4a1f64b1aff87d
Author: Song Liu <songliubraving@fb.com>
Date:   Mon Oct 5 09:58:38 2020 -0700

    bpf: Use raw_spin_trylock() for pcpu_freelist_push/pop in NMI
    
    [ Upstream commit 39d8f0d1026a990604770a658708f5845f7dbec0 ]
    
    Recent improvements in LOCKDEP highlighted a potential A-A deadlock with
    pcpu_freelist in NMI:
    
    ./tools/testing/selftests/bpf/test_progs -t stacktrace_build_id_nmi
    
    [   18.984807] ================================
    [   18.984807] WARNING: inconsistent lock state
    [   18.984808] 5.9.0-rc6-01771-g1466de1330e1 #2967 Not tainted
    [   18.984809] --------------------------------
    [   18.984809] inconsistent {INITIAL USE} -> {IN-NMI} usage.
    [   18.984810] test_progs/1990 [HC2[2]:SC0[0]:HE0:SE1] takes:
    [   18.984810] ffffe8ffffc219c0 (&head->lock){....}-{2:2}, at: __pcpu_freelist_pop+0xe3/0x180
    [   18.984813] {INITIAL USE} state was registered at:
    [   18.984814]   lock_acquire+0x175/0x7c0
    [   18.984814]   _raw_spin_lock+0x2c/0x40
    [   18.984815]   __pcpu_freelist_pop+0xe3/0x180
    [   18.984815]   pcpu_freelist_pop+0x31/0x40
    [   18.984816]   htab_map_alloc+0xbbf/0xf40
    [   18.984816]   __do_sys_bpf+0x5aa/0x3ed0
    [   18.984817]   do_syscall_64+0x2d/0x40
    [   18.984818]   entry_SYSCALL_64_after_hwframe+0x44/0xa9
    [   18.984818] irq event stamp: 12
    [...]
    [   18.984822] other info that might help us debug this:
    [   18.984823]  Possible unsafe locking scenario:
    [   18.984823]
    [   18.984824]        CPU0
    [   18.984824]        ----
    [   18.984824]   lock(&head->lock);
    [   18.984826]   <Interrupt>
    [   18.984826]     lock(&head->lock);
    [   18.984827]
    [   18.984828]  *** DEADLOCK ***
    [   18.984828]
    [   18.984829] 2 locks held by test_progs/1990:
    [...]
    [   18.984838]  <NMI>
    [   18.984838]  dump_stack+0x9a/0xd0
    [   18.984839]  lock_acquire+0x5c9/0x7c0
    [   18.984839]  ? lock_release+0x6f0/0x6f0
    [   18.984840]  ? __pcpu_freelist_pop+0xe3/0x180
    [   18.984840]  _raw_spin_lock+0x2c/0x40
    [   18.984841]  ? __pcpu_freelist_pop+0xe3/0x180
    [   18.984841]  __pcpu_freelist_pop+0xe3/0x180
    [   18.984842]  pcpu_freelist_pop+0x17/0x40
    [   18.984842]  ? lock_release+0x6f0/0x6f0
    [   18.984843]  __bpf_get_stackid+0x534/0xaf0
    [   18.984843]  bpf_prog_1fd9e30e1438d3c5_oncpu+0x73/0x350
    [   18.984844]  bpf_overflow_handler+0x12f/0x3f0
    
    This is because pcpu_freelist_head.lock is accessed in both NMI and
    non-NMI context. Fix this issue by using raw_spin_trylock() in NMI.
    
    Since NMI interrupts non-NMI context, when NMI context tries to lock the
    raw_spinlock, non-NMI context of the same CPU may already have locked a
    lock and is blocked from unlocking the lock. For a system with N CPUs,
    there could be N NMIs at the same time, and they may block N non-NMI
    raw_spinlocks. This is tricky for pcpu_freelist_push(), where unlike
    _pop(), failing _push() means leaking memory. This issue is more likely to
    trigger in non-SMP system.
    
    Fix this issue with an extra list, pcpu_freelist.extralist. The extralist
    is primarily used to take _push() when raw_spin_trylock() failed on all
    the per CPU lists. It should be empty most of the time. The following
    table summarizes the behavior of pcpu_freelist in NMI and non-NMI:
    
    non-NMI pop():  use _lock(); check per CPU lists first;
                    if all per CPU lists are empty, check extralist;
                    if extralist is empty, return NULL.
    
    non-NMI push(): use _lock(); only push to per CPU lists.
    
    NMI pop():    use _trylock(); check per CPU lists first;
                  if all per CPU lists are locked or empty, check extralist;
                  if extralist is locked or empty, return NULL.
    
    NMI push():   use _trylock(); check per CPU lists first;
                  if all per CPU lists are locked; try push to extralist;
                  if extralist is also locked, keep trying on per CPU lists.
    
    Reported-by: Alexei Starovoitov <ast@kernel.org>
    Signed-off-by: Song Liu <songliubraving@fb.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
    Acked-by: Martin KaFai Lau <kafai@fb.com>
    Link: https://lore.kernel.org/bpf/20201005165838.3735218-1-songliubraving@fb.com
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 39d8f0d1026a990604770a658708f5845f7dbec0
Author: Song Liu <songliubraving@fb.com>
Date:   Mon Oct 5 09:58:38 2020 -0700

    bpf: Use raw_spin_trylock() for pcpu_freelist_push/pop in NMI
    
    Recent improvements in LOCKDEP highlighted a potential A-A deadlock with
    pcpu_freelist in NMI:
    
    ./tools/testing/selftests/bpf/test_progs -t stacktrace_build_id_nmi
    
    [   18.984807] ================================
    [   18.984807] WARNING: inconsistent lock state
    [   18.984808] 5.9.0-rc6-01771-g1466de1330e1 #2967 Not tainted
    [   18.984809] --------------------------------
    [   18.984809] inconsistent {INITIAL USE} -> {IN-NMI} usage.
    [   18.984810] test_progs/1990 [HC2[2]:SC0[0]:HE0:SE1] takes:
    [   18.984810] ffffe8ffffc219c0 (&head->lock){....}-{2:2}, at: __pcpu_freelist_pop+0xe3/0x180
    [   18.984813] {INITIAL USE} state was registered at:
    [   18.984814]   lock_acquire+0x175/0x7c0
    [   18.984814]   _raw_spin_lock+0x2c/0x40
    [   18.984815]   __pcpu_freelist_pop+0xe3/0x180
    [   18.984815]   pcpu_freelist_pop+0x31/0x40
    [   18.984816]   htab_map_alloc+0xbbf/0xf40
    [   18.984816]   __do_sys_bpf+0x5aa/0x3ed0
    [   18.984817]   do_syscall_64+0x2d/0x40
    [   18.984818]   entry_SYSCALL_64_after_hwframe+0x44/0xa9
    [   18.984818] irq event stamp: 12
    [...]
    [   18.984822] other info that might help us debug this:
    [   18.984823]  Possible unsafe locking scenario:
    [   18.984823]
    [   18.984824]        CPU0
    [   18.984824]        ----
    [   18.984824]   lock(&head->lock);
    [   18.984826]   <Interrupt>
    [   18.984826]     lock(&head->lock);
    [   18.984827]
    [   18.984828]  *** DEADLOCK ***
    [   18.984828]
    [   18.984829] 2 locks held by test_progs/1990:
    [...]
    [   18.984838]  <NMI>
    [   18.984838]  dump_stack+0x9a/0xd0
    [   18.984839]  lock_acquire+0x5c9/0x7c0
    [   18.984839]  ? lock_release+0x6f0/0x6f0
    [   18.984840]  ? __pcpu_freelist_pop+0xe3/0x180
    [   18.984840]  _raw_spin_lock+0x2c/0x40
    [   18.984841]  ? __pcpu_freelist_pop+0xe3/0x180
    [   18.984841]  __pcpu_freelist_pop+0xe3/0x180
    [   18.984842]  pcpu_freelist_pop+0x17/0x40
    [   18.984842]  ? lock_release+0x6f0/0x6f0
    [   18.984843]  __bpf_get_stackid+0x534/0xaf0
    [   18.984843]  bpf_prog_1fd9e30e1438d3c5_oncpu+0x73/0x350
    [   18.984844]  bpf_overflow_handler+0x12f/0x3f0
    
    This is because pcpu_freelist_head.lock is accessed in both NMI and
    non-NMI context. Fix this issue by using raw_spin_trylock() in NMI.
    
    Since NMI interrupts non-NMI context, when NMI context tries to lock the
    raw_spinlock, non-NMI context of the same CPU may already have locked a
    lock and is blocked from unlocking the lock. For a system with N CPUs,
    there could be N NMIs at the same time, and they may block N non-NMI
    raw_spinlocks. This is tricky for pcpu_freelist_push(), where unlike
    _pop(), failing _push() means leaking memory. This issue is more likely to
    trigger in non-SMP system.
    
    Fix this issue with an extra list, pcpu_freelist.extralist. The extralist
    is primarily used to take _push() when raw_spin_trylock() failed on all
    the per CPU lists. It should be empty most of the time. The following
    table summarizes the behavior of pcpu_freelist in NMI and non-NMI:
    
    non-NMI pop():  use _lock(); check per CPU lists first;
                    if all per CPU lists are empty, check extralist;
                    if extralist is empty, return NULL.
    
    non-NMI push(): use _lock(); only push to per CPU lists.
    
    NMI pop():    use _trylock(); check per CPU lists first;
                  if all per CPU lists are locked or empty, check extralist;
                  if extralist is locked or empty, return NULL.
    
    NMI push():   use _trylock(); check per CPU lists first;
                  if all per CPU lists are locked; try push to extralist;
                  if extralist is also locked, keep trying on per CPU lists.
    
    Reported-by: Alexei Starovoitov <ast@kernel.org>
    Signed-off-by: Song Liu <songliubraving@fb.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
    Acked-by: Martin KaFai Lau <kafai@fb.com>
    Link: https://lore.kernel.org/bpf/20201005165838.3735218-1-songliubraving@fb.com

commit 10b8d2696578858486629b21411422fd75f7d952
Author: Fred Oh <fred.oh@linux.intel.com>
Date:   Thu Jun 25 14:13:02 2020 -0500

    ASoC: Intel: Boards: cml_rt1011_rt5682: use statically define codec config
    
    [ Upstream commit 8a473c39ae54c27e694a131c34a739d0f8aa5300 ]
    
    When the cml_rt1011_rt5682_dailink[].codecs pointer is overridden by
    a quirk with a devm allocated structure and the probe is deferred,
    in the next probe we will see an use-after-free condition
    (verified with KASAN). This can be avoided by using statically allocated
    configurations - which simplifies the code quite a bit as well.
    
    KASAN issue fixed.
    [   23.301373] cml_rt1011_rt5682 cml_rt1011_rt5682: sof_rt1011_quirk = f
    [   23.301875] ==================================================================
    [   23.302018] BUG: KASAN: use-after-free in snd_cml_rt1011_probe+0x23a/0x3d0 [snd_soc_cml_rt1011_rt5682]
    [   23.302178] Read of size 8 at addr ffff8881ec6acae0 by task kworker/0:2/105
    [   23.302320] CPU: 0 PID: 105 Comm: kworker/0:2 Not tainted 5.7.0-rc7-test+ #3
    [   23.302322] Hardware name: Google Helios/Helios, BIOS  01/21/2020
    [   23.302329] Workqueue: events deferred_probe_work_func
    [   23.302331] Call Trace:
    [   23.302339]  dump_stack+0x76/0xa0
    [   23.302345]  print_address_description.constprop.0.cold+0xd3/0x43e
    [   23.302351]  ? _raw_spin_lock_irqsave+0x7b/0xd0
    [   23.302355]  ? _raw_spin_trylock_bh+0xf0/0xf0
    [   23.302362]  ? snd_cml_rt1011_probe+0x23a/0x3d0 [snd_soc_cml_rt1011_rt5682]
    [   23.302365]  __kasan_report.cold+0x37/0x86
    [   23.302371]  ? snd_cml_rt1011_probe+0x23a/0x3d0 [snd_soc_cml_rt1011_rt5682]
    [   23.302375]  kasan_report+0x38/0x50
    [   23.302382]  snd_cml_rt1011_probe+0x23a/0x3d0 [snd_soc_cml_rt1011_rt5682]
    [   23.302389]  platform_drv_probe+0x66/0xc0
    
    Fixes: 629ba12e9998 ("ASoC: Intel: boards: split woofer and tweeter support")
    Suggested-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Signed-off-by: Fred Oh <fred.oh@linux.intel.com>
    Signed-off-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Reviewed-by: Bard Liao <yung-chuan.liao@linux.intel.com>
    Link: https://lore.kernel.org/r/20200625191308.3322-12-pierre-louis.bossart@linux.intel.com
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 8a473c39ae54c27e694a131c34a739d0f8aa5300
Author: Fred Oh <fred.oh@linux.intel.com>
Date:   Thu Jun 25 14:13:02 2020 -0500

    ASoC: Intel: Boards: cml_rt1011_rt5682: use statically define codec config
    
    When the cml_rt1011_rt5682_dailink[].codecs pointer is overridden by
    a quirk with a devm allocated structure and the probe is deferred,
    in the next probe we will see an use-after-free condition
    (verified with KASAN). This can be avoided by using statically allocated
    configurations - which simplifies the code quite a bit as well.
    
    KASAN issue fixed.
    [   23.301373] cml_rt1011_rt5682 cml_rt1011_rt5682: sof_rt1011_quirk = f
    [   23.301875] ==================================================================
    [   23.302018] BUG: KASAN: use-after-free in snd_cml_rt1011_probe+0x23a/0x3d0 [snd_soc_cml_rt1011_rt5682]
    [   23.302178] Read of size 8 at addr ffff8881ec6acae0 by task kworker/0:2/105
    [   23.302320] CPU: 0 PID: 105 Comm: kworker/0:2 Not tainted 5.7.0-rc7-test+ #3
    [   23.302322] Hardware name: Google Helios/Helios, BIOS  01/21/2020
    [   23.302329] Workqueue: events deferred_probe_work_func
    [   23.302331] Call Trace:
    [   23.302339]  dump_stack+0x76/0xa0
    [   23.302345]  print_address_description.constprop.0.cold+0xd3/0x43e
    [   23.302351]  ? _raw_spin_lock_irqsave+0x7b/0xd0
    [   23.302355]  ? _raw_spin_trylock_bh+0xf0/0xf0
    [   23.302362]  ? snd_cml_rt1011_probe+0x23a/0x3d0 [snd_soc_cml_rt1011_rt5682]
    [   23.302365]  __kasan_report.cold+0x37/0x86
    [   23.302371]  ? snd_cml_rt1011_probe+0x23a/0x3d0 [snd_soc_cml_rt1011_rt5682]
    [   23.302375]  kasan_report+0x38/0x50
    [   23.302382]  snd_cml_rt1011_probe+0x23a/0x3d0 [snd_soc_cml_rt1011_rt5682]
    [   23.302389]  platform_drv_probe+0x66/0xc0
    
    Fixes: 629ba12e9998 ("ASoC: Intel: boards: split woofer and tweeter support")
    Suggested-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Signed-off-by: Fred Oh <fred.oh@linux.intel.com>
    Signed-off-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Reviewed-by: Bard Liao <yung-chuan.liao@linux.intel.com>
    Link: https://lore.kernel.org/r/20200625191308.3322-12-pierre-louis.bossart@linux.intel.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

commit 9ced454807191e44ef093aeeee68194be9ce3a1a
Author: Jules Irenge <jbi.octave@gmail.com>
Date:   Mon Jan 20 22:42:15 2020 +0000

    rcu: Add missing annotation for rcu_nocb_bypass_lock()
    
    Sparse reports warning at rcu_nocb_bypass_lock()
    
    |warning: context imbalance in rcu_nocb_bypass_lock() - wrong count at exit
    
    To fix this, this commit adds an __acquires(&rdp->nocb_bypass_lock).
    Given that rcu_nocb_bypass_lock() does actually call raw_spin_lock()
    when raw_spin_trylock() fails, this not only fixes the warning but also
    improves on the readability of the code.
    
    Signed-off-by: Jules Irenge <jbi.octave@gmail.com>
    Signed-off-by: Paul E. McKenney <paulmck@kernel.org>

commit 81c0b3d724f419c0524f432c1ac22b9f518c2899
Author: Paul E. McKenney <paulmck@linux.ibm.com>
Date:   Tue May 28 07:18:08 2019 -0700

    rcu/nocb: Avoid ->nocb_lock capture by corresponding CPU
    
    A given rcu_data structure's ->nocb_lock can be acquired very frequently
    by the corresponding CPU and occasionally by the corresponding no-CBs
    grace-period and callbacks kthreads.  In particular, these two kthreads
    will have frequent gaps between ->nocb_lock acquisitions that are roughly
    a grace period in duration.  This means that any excessive ->nocb_lock
    contention will be due to the CPU's acquisitions, and this in turn
    enables a very naive contention-avoidance strategy to be quite effective.
    
    This commit therefore modifies rcu_nocb_lock() to first
    attempt a raw_spin_trylock(), and to atomically increment a
    separate ->nocb_lock_contended across a raw_spin_lock().  This new
    ->nocb_lock_contended field is checked in __call_rcu_nocb_wake() when
    interrupts are enabled, with a spin-wait for contending acquisitions
    to complete, thus allowing the kthreads a chance to acquire the lock.
    
    Signed-off-by: Paul E. McKenney <paulmck@linux.ibm.com>

commit 6cd34b10cd642c15a8e4b2ed5fc4815c12c41d52
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Aug 9 08:37:23 2019 +0100

    drm/i915/execlists: Backtrack along timeline
    
    After a preempt-to-busy, we may find an active request that is caught
    between execution states. Walk back along the timeline instead of the
    execution list to be safe.
    
    [  106.417541] i915 0000:00:02.0: Resetting rcs0 for preemption time out
    [  106.417659] ==================================================================
    [  106.418041] BUG: KASAN: slab-out-of-bounds in __execlists_reset+0x2f2/0x440 [i915]
    [  106.418123] Read of size 8 at addr ffff888703506b30 by task swapper/1/0
    [  106.418194]
    [  106.418267] CPU: 1 PID: 0 Comm: swapper/1 Tainted: G     U            5.3.0-rc3+ #5
    [  106.418344] Hardware name: Intel Corporation NUC7i5BNK/NUC7i5BNB, BIOS BNKBL357.86A.0052.2017.0918.1346 09/18/2017
    [  106.418434] Call Trace:
    [  106.418508]  <IRQ>
    [  106.418585]  dump_stack+0x5b/0x90
    [  106.418941]  ? __execlists_reset+0x2f2/0x440 [i915]
    [  106.419022]  print_address_description+0x67/0x32d
    [  106.419376]  ? __execlists_reset+0x2f2/0x440 [i915]
    [  106.419731]  ? __execlists_reset+0x2f2/0x440 [i915]
    [  106.419810]  __kasan_report.cold.6+0x1a/0x3c
    [  106.419888]  ? __trace_bprintk+0xc0/0xd0
    [  106.420239]  ? __execlists_reset+0x2f2/0x440 [i915]
    [  106.420318]  check_memory_region+0x144/0x1c0
    [  106.420671]  __execlists_reset+0x2f2/0x440 [i915]
    [  106.421029]  execlists_reset+0x3d/0x50 [i915]
    [  106.421387]  intel_engine_reset+0x203/0x3a0 [i915]
    [  106.421744]  ? igt_reset_nop+0x2b0/0x2b0 [i915]
    [  106.421825]  ? _raw_spin_trylock_bh+0xe0/0xe0
    [  106.421901]  ? rcu_core+0x1b9/0x6a0
    [  106.422251]  preempt_reset+0x9a/0xf0 [i915]
    [  106.422333]  tasklet_action_common.isra.15+0xc0/0x1e0
    [  106.422685]  ? execlists_submit_request+0x200/0x200 [i915]
    [  106.422764]  __do_softirq+0x106/0x3cf
    [  106.422840]  irq_exit+0xdc/0xf0
    [  106.422914]  smp_apic_timer_interrupt+0x81/0x1c0
    [  106.422988]  apic_timer_interrupt+0xf/0x20
    [  106.423059]  </IRQ>
    [  106.423144] RIP: 0010:cpuidle_enter_state+0xc3/0x620
    [  106.423222] Code: 24 0f 1f 44 00 00 31 ff e8 da 87 9c ff 80 7c 24 10 00 74 12 9c 58 f6 c4 02 0f 85 33 05 00 00 31 ff e8 c1 77 a3 ff fb 45 85 e4 <0f> 89 bf 02 00 00 48 8d 7d 10 e8 4e 45 b9 ff c7 45 10 00 00 00 00
    [  106.423311] RSP: 0018:ffff88881c30fda8 EFLAGS: 00000202 ORIG_RAX: ffffffffffffff13
    [  106.423390] RAX: 0000000000000000 RBX: ffffffff825b4c80 RCX: ffffffff810c8a00
    [  106.423465] RDX: dffffc0000000000 RSI: 0000000039f89620 RDI: ffff88881f6b00a8
    [  106.423540] RBP: ffff88881f6b5bf8 R08: 0000000000000002 R09: 000000000002ed80
    [  106.423616] R10: 0000003fdd956146 R11: ffff88881c2d1e47 R12: 0000000000000008
    [  106.423691] R13: 0000000000000008 R14: ffffffff825b4f80 R15: ffffffff825b4fc0
    [  106.423772]  ? sched_idle_set_state+0x20/0x30
    [  106.423851]  ? cpuidle_enter_state+0xa6/0x620
    [  106.423874]  ? tick_nohz_idle_stop_tick+0x1d1/0x3f0
    [  106.423896]  cpuidle_enter+0x37/0x60
    [  106.423919]  do_idle+0x246/0x280
    [  106.423941]  ? arch_cpu_idle_exit+0x30/0x30
    [  106.423964]  ? __wake_up_common+0x46/0x240
    [  106.423986]  cpu_startup_entry+0x14/0x20
    [  106.424009]  start_secondary+0x1b0/0x200
    [  106.424031]  ? set_cpu_sibling_map+0x990/0x990
    [  106.424054]  secondary_startup_64+0xa4/0xb0
    [  106.424075]
    [  106.424096] Allocated by task 626:
    [  106.424119]  save_stack+0x19/0x80
    [  106.424143]  __kasan_kmalloc.constprop.7+0xc1/0xd0
    [  106.424165]  kmem_cache_alloc+0xb2/0x1d0
    [  106.424277]  i915_sched_lookup_priolist+0x1ab/0x320 [i915]
    [  106.424385]  execlists_submit_request+0x73/0x200 [i915]
    [  106.424498]  submit_notify+0x59/0x60 [i915]
    [  106.424600]  __i915_sw_fence_complete+0x9b/0x330 [i915]
    [  106.424713]  __i915_request_commit+0x4bf/0x570 [i915]
    [  106.424818]  intel_engine_pulse+0x213/0x310 [i915]
    [  106.424925]  context_close+0x22f/0x470 [i915]
    [  106.425033]  i915_gem_context_destroy_ioctl+0x7b/0xa0 [i915]
    [  106.425058]  drm_ioctl_kernel+0x131/0x170
    [  106.425081]  drm_ioctl+0x2d9/0x4f1
    [  106.425104]  do_vfs_ioctl+0x115/0x890
    [  106.425126]  ksys_ioctl+0x35/0x70
    [  106.425147]  __x64_sys_ioctl+0x38/0x40
    [  106.425169]  do_syscall_64+0x66/0x220
    [  106.425191]  entry_SYSCALL_64_after_hwframe+0x44/0xa9
    [  106.425213]
    [  106.425234] Freed by task 0:
    [  106.425255] (stack is not available)
    [  106.425276]
    [  106.425297] The buggy address belongs to the object at ffff888703506a40
    [  106.425297]  which belongs to the cache i915_priolist of size 104
    [  106.425321] The buggy address is located 136 bytes to the right of
    [  106.425321]  104-byte region [ffff888703506a40, ffff888703506aa8)
    [  106.425345] The buggy address belongs to the page:
    [  106.425367] page:ffffea001c0d4180 refcount:1 mapcount:0 mapping:ffff88873e1cf740 index:0xffff888703506e40 compound_mapcount: 0
    [  106.425391] flags: 0x8000000000010200(slab|head)
    [  106.425415] raw: 8000000000010200 ffffea0020192b88 ffff8888174b5450 ffff88873e1cf740
    [  106.425439] raw: ffff888703506e40 000000000010000e 00000001ffffffff 0000000000000000
    [  106.425464] page dumped because: kasan: bad access detected
    [  106.425486]
    [  106.425506] Memory state around the buggy address:
    [  106.425528]  ffff888703506a00: fc fc fc fc fc fc fc fc 00 00 00 00 00 00 00 00
    [  106.425551]  ffff888703506a80: 00 00 00 00 00 fc fc fc fc fc fc fc fc fc fc fc
    [  106.425573] >ffff888703506b00: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
    [  106.425597]                                      ^
    [  106.425619]  ffff888703506b80: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
    [  106.425642]  ffff888703506c00: fc fc fc fc fc fc fc fc 00 00 00 00 00 00 00 00
    [  106.425664] ==================================================================
    
    Fixes: 22b7a426bbe1 ("drm/i915/execlists: Preempt-to-busy")
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Mika Kuoppala <mika.kuoppala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190809073723.6593-1-chris@chris-wilson.co.uk

commit ef9ef4adb85c3d14ab838a886c153432046c6c02
Author: Li RongQing <lirongqing@baidu.com>
Date:   Wed Mar 6 14:46:27 2019 +0800

    connector: fix unsafe usage of ->real_parent
    
    [ Upstream commit 6d2b0f02f5a07a4bf02e4cbc90d7eaa85cac2986 ]
    
    proc_exit_connector() uses ->real_parent lockless. This is not
    safe that its parent can go away at any moment, so use RCU to
    protect it, and ensure that this task is not released.
    
    [  747.624551] ==================================================================
    [  747.632946] BUG: KASAN: use-after-free in proc_exit_connector+0x1f7/0x310
    [  747.640686] Read of size 4 at addr ffff88a0276988e0 by task sshd/2882
    [  747.648032]
    [  747.649804] CPU: 11 PID: 2882 Comm: sshd Tainted: G            E     4.19.26-rc2 #11
    [  747.658629] Hardware name: IBM x3550M4 -[7914OFV]-/00AM544, BIOS -[D7E142BUS-1.71]- 07/31/2014
    [  747.668419] Call Trace:
    [  747.671269]  dump_stack+0xf0/0x19b
    [  747.675186]  ? show_regs_print_info+0x5/0x5
    [  747.679988]  ? kmsg_dump_rewind_nolock+0x59/0x59
    [  747.685302]  print_address_description+0x6a/0x270
    [  747.691162]  kasan_report+0x258/0x380
    [  747.695835]  ? proc_exit_connector+0x1f7/0x310
    [  747.701402]  proc_exit_connector+0x1f7/0x310
    [  747.706767]  ? proc_coredump_connector+0x2d0/0x2d0
    [  747.712715]  ? _raw_write_unlock_irq+0x29/0x50
    [  747.718270]  ? _raw_write_unlock_irq+0x29/0x50
    [  747.723820]  ? ___preempt_schedule+0x16/0x18
    [  747.729193]  ? ___preempt_schedule+0x16/0x18
    [  747.734574]  do_exit+0xa11/0x14f0
    [  747.738880]  ? mm_update_next_owner+0x590/0x590
    [  747.744525]  ? debug_show_all_locks+0x3c0/0x3c0
    [  747.761448]  ? ktime_get_coarse_real_ts64+0xeb/0x1c0
    [  747.767589]  ? lockdep_hardirqs_on+0x1a6/0x290
    [  747.773154]  ? check_chain_key+0x139/0x1f0
    [  747.778345]  ? check_flags.part.35+0x240/0x240
    [  747.783908]  ? __lock_acquire+0x2300/0x2300
    [  747.789171]  ? _raw_spin_unlock_irqrestore+0x59/0x70
    [  747.795316]  ? _raw_spin_unlock_irqrestore+0x59/0x70
    [  747.801457]  ? do_raw_spin_unlock+0x10f/0x1e0
    [  747.806914]  ? do_raw_spin_trylock+0x120/0x120
    [  747.812481]  ? preempt_count_sub+0x14/0xc0
    [  747.817645]  ? _raw_spin_unlock+0x2e/0x50
    [  747.822708]  ? __handle_mm_fault+0x12db/0x1fa0
    [  747.828367]  ? __pmd_alloc+0x2d0/0x2d0
    [  747.833143]  ? check_noncircular+0x50/0x50
    [  747.838309]  ? match_held_lock+0x7f/0x340
    [  747.843380]  ? check_noncircular+0x50/0x50
    [  747.848561]  ? handle_mm_fault+0x21a/0x5f0
    [  747.853730]  ? check_flags.part.35+0x240/0x240
    [  747.859290]  ? check_chain_key+0x139/0x1f0
    [  747.864474]  ? __do_page_fault+0x40f/0x760
    [  747.869655]  ? __audit_syscall_entry+0x4b/0x1f0
    [  747.875319]  ? syscall_trace_enter+0x1d5/0x7b0
    [  747.880877]  ? trace_raw_output_preemptirq_template+0x90/0x90
    [  747.887895]  ? trace_raw_output_sys_exit+0x80/0x80
    [  747.893860]  ? up_read+0x3b/0x90
    [  747.898142]  ? stop_critical_timings+0x260/0x260
    [  747.903909]  do_group_exit+0xe0/0x1c0
    [  747.908591]  ? __x64_sys_exit+0x30/0x30
    [  747.913460]  ? trace_raw_output_preemptirq_template+0x90/0x90
    [  747.920485]  ? tracer_hardirqs_on+0x270/0x270
    [  747.925956]  __x64_sys_exit_group+0x28/0x30
    [  747.931214]  do_syscall_64+0x117/0x400
    [  747.935988]  ? syscall_return_slowpath+0x2f0/0x2f0
    [  747.941931]  ? trace_hardirqs_off_thunk+0x1a/0x1c
    [  747.947788]  ? trace_hardirqs_on_caller+0x1d0/0x1d0
    [  747.953838]  ? lockdep_sys_exit+0x16/0x8e
    [  747.958915]  ? trace_hardirqs_off_thunk+0x1a/0x1c
    [  747.964784]  entry_SYSCALL_64_after_hwframe+0x49/0xbe
    [  747.971021] RIP: 0033:0x7f572f154c68
    [  747.975606] Code: Bad RIP value.
    [  747.979791] RSP: 002b:00007ffed2dfaa58 EFLAGS: 00000246 ORIG_RAX: 00000000000000e7
    [  747.989324] RAX: ffffffffffffffda RBX: 00007f572f431840 RCX: 00007f572f154c68
    [  747.997910] RDX: 0000000000000001 RSI: 000000000000003c RDI: 0000000000000001
    [  748.006495] RBP: 0000000000000001 R08: 00000000000000e7 R09: fffffffffffffee0
    [  748.015079] R10: 00007f572f4387e8 R11: 0000000000000246 R12: 00007f572f431840
    [  748.023664] R13: 000055a7f90f2c50 R14: 000055a7f96e2310 R15: 000055a7f96e2310
    [  748.032287]
    [  748.034509] Allocated by task 2300:
    [  748.038982]  kasan_kmalloc+0xa0/0xd0
    [  748.043562]  kmem_cache_alloc_node+0xf5/0x2e0
    [  748.049018]  copy_process+0x1781/0x4790
    [  748.053884]  _do_fork+0x166/0x9a0
    [  748.058163]  do_syscall_64+0x117/0x400
    [  748.062943]  entry_SYSCALL_64_after_hwframe+0x49/0xbe
    [  748.069180]
    [  748.071405] Freed by task 15395:
    [  748.075591]  __kasan_slab_free+0x130/0x180
    [  748.080752]  kmem_cache_free+0xc2/0x310
    [  748.085619]  free_task+0xea/0x130
    [  748.089901]  __put_task_struct+0x177/0x230
    [  748.095063]  finish_task_switch+0x51b/0x5d0
    [  748.100315]  __schedule+0x506/0xfa0
    [  748.104791]  schedule+0xca/0x260
    [  748.108978]  futex_wait_queue_me+0x27e/0x420
    [  748.114333]  futex_wait+0x251/0x550
    [  748.118814]  do_futex+0x75b/0xf80
    [  748.123097]  __x64_sys_futex+0x231/0x2a0
    [  748.128065]  do_syscall_64+0x117/0x400
    [  748.132835]  entry_SYSCALL_64_after_hwframe+0x49/0xbe
    [  748.139066]
    [  748.141289] The buggy address belongs to the object at ffff88a027698000
    [  748.141289]  which belongs to the cache task_struct of size 12160
    [  748.156589] The buggy address is located 2272 bytes inside of
    [  748.156589]  12160-byte region [ffff88a027698000, ffff88a02769af80)
    [  748.171114] The buggy address belongs to the page:
    [  748.177055] page:ffffea00809da600 count:1 mapcount:0 mapping:ffff888107d01e00 index:0x0 compound_mapcount: 0
    [  748.189136] flags: 0x57ffffc0008100(slab|head)
    [  748.194688] raw: 0057ffffc0008100 ffffea00809a3200 0000000300000003 ffff888107d01e00
    [  748.204424] raw: 0000000000000000 0000000000020002 00000001ffffffff 0000000000000000
    [  748.214146] page dumped because: kasan: bad access detected
    [  748.220976]
    [  748.223197] Memory state around the buggy address:
    [  748.229128]  ffff88a027698780: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [  748.238271]  ffff88a027698800: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [  748.247414] >ffff88a027698880: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [  748.256564]                                                        ^
    [  748.264267]  ffff88a027698900: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [  748.273493]  ffff88a027698980: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [  748.282630] ==================================================================
    
    Fixes: b086ff87251b4a4 ("connector: add parent pid and tgid to coredump and exit events")
    Signed-off-by: Zhang Yu <zhangyu31@baidu.com>
    Signed-off-by: Li RongQing <lirongqing@baidu.com>
    Acked-by: Evgeniy Polyakov <zbr@ioremap.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 28d1ecc9f529d995282d95b8b16785227ed87537
Author: Li RongQing <lirongqing@baidu.com>
Date:   Wed Mar 6 14:46:27 2019 +0800

    connector: fix unsafe usage of ->real_parent
    
    [ Upstream commit 6d2b0f02f5a07a4bf02e4cbc90d7eaa85cac2986 ]
    
    proc_exit_connector() uses ->real_parent lockless. This is not
    safe that its parent can go away at any moment, so use RCU to
    protect it, and ensure that this task is not released.
    
    [  747.624551] ==================================================================
    [  747.632946] BUG: KASAN: use-after-free in proc_exit_connector+0x1f7/0x310
    [  747.640686] Read of size 4 at addr ffff88a0276988e0 by task sshd/2882
    [  747.648032]
    [  747.649804] CPU: 11 PID: 2882 Comm: sshd Tainted: G            E     4.19.26-rc2 #11
    [  747.658629] Hardware name: IBM x3550M4 -[7914OFV]-/00AM544, BIOS -[D7E142BUS-1.71]- 07/31/2014
    [  747.668419] Call Trace:
    [  747.671269]  dump_stack+0xf0/0x19b
    [  747.675186]  ? show_regs_print_info+0x5/0x5
    [  747.679988]  ? kmsg_dump_rewind_nolock+0x59/0x59
    [  747.685302]  print_address_description+0x6a/0x270
    [  747.691162]  kasan_report+0x258/0x380
    [  747.695835]  ? proc_exit_connector+0x1f7/0x310
    [  747.701402]  proc_exit_connector+0x1f7/0x310
    [  747.706767]  ? proc_coredump_connector+0x2d0/0x2d0
    [  747.712715]  ? _raw_write_unlock_irq+0x29/0x50
    [  747.718270]  ? _raw_write_unlock_irq+0x29/0x50
    [  747.723820]  ? ___preempt_schedule+0x16/0x18
    [  747.729193]  ? ___preempt_schedule+0x16/0x18
    [  747.734574]  do_exit+0xa11/0x14f0
    [  747.738880]  ? mm_update_next_owner+0x590/0x590
    [  747.744525]  ? debug_show_all_locks+0x3c0/0x3c0
    [  747.761448]  ? ktime_get_coarse_real_ts64+0xeb/0x1c0
    [  747.767589]  ? lockdep_hardirqs_on+0x1a6/0x290
    [  747.773154]  ? check_chain_key+0x139/0x1f0
    [  747.778345]  ? check_flags.part.35+0x240/0x240
    [  747.783908]  ? __lock_acquire+0x2300/0x2300
    [  747.789171]  ? _raw_spin_unlock_irqrestore+0x59/0x70
    [  747.795316]  ? _raw_spin_unlock_irqrestore+0x59/0x70
    [  747.801457]  ? do_raw_spin_unlock+0x10f/0x1e0
    [  747.806914]  ? do_raw_spin_trylock+0x120/0x120
    [  747.812481]  ? preempt_count_sub+0x14/0xc0
    [  747.817645]  ? _raw_spin_unlock+0x2e/0x50
    [  747.822708]  ? __handle_mm_fault+0x12db/0x1fa0
    [  747.828367]  ? __pmd_alloc+0x2d0/0x2d0
    [  747.833143]  ? check_noncircular+0x50/0x50
    [  747.838309]  ? match_held_lock+0x7f/0x340
    [  747.843380]  ? check_noncircular+0x50/0x50
    [  747.848561]  ? handle_mm_fault+0x21a/0x5f0
    [  747.853730]  ? check_flags.part.35+0x240/0x240
    [  747.859290]  ? check_chain_key+0x139/0x1f0
    [  747.864474]  ? __do_page_fault+0x40f/0x760
    [  747.869655]  ? __audit_syscall_entry+0x4b/0x1f0
    [  747.875319]  ? syscall_trace_enter+0x1d5/0x7b0
    [  747.880877]  ? trace_raw_output_preemptirq_template+0x90/0x90
    [  747.887895]  ? trace_raw_output_sys_exit+0x80/0x80
    [  747.893860]  ? up_read+0x3b/0x90
    [  747.898142]  ? stop_critical_timings+0x260/0x260
    [  747.903909]  do_group_exit+0xe0/0x1c0
    [  747.908591]  ? __x64_sys_exit+0x30/0x30
    [  747.913460]  ? trace_raw_output_preemptirq_template+0x90/0x90
    [  747.920485]  ? tracer_hardirqs_on+0x270/0x270
    [  747.925956]  __x64_sys_exit_group+0x28/0x30
    [  747.931214]  do_syscall_64+0x117/0x400
    [  747.935988]  ? syscall_return_slowpath+0x2f0/0x2f0
    [  747.941931]  ? trace_hardirqs_off_thunk+0x1a/0x1c
    [  747.947788]  ? trace_hardirqs_on_caller+0x1d0/0x1d0
    [  747.953838]  ? lockdep_sys_exit+0x16/0x8e
    [  747.958915]  ? trace_hardirqs_off_thunk+0x1a/0x1c
    [  747.964784]  entry_SYSCALL_64_after_hwframe+0x49/0xbe
    [  747.971021] RIP: 0033:0x7f572f154c68
    [  747.975606] Code: Bad RIP value.
    [  747.979791] RSP: 002b:00007ffed2dfaa58 EFLAGS: 00000246 ORIG_RAX: 00000000000000e7
    [  747.989324] RAX: ffffffffffffffda RBX: 00007f572f431840 RCX: 00007f572f154c68
    [  747.997910] RDX: 0000000000000001 RSI: 000000000000003c RDI: 0000000000000001
    [  748.006495] RBP: 0000000000000001 R08: 00000000000000e7 R09: fffffffffffffee0
    [  748.015079] R10: 00007f572f4387e8 R11: 0000000000000246 R12: 00007f572f431840
    [  748.023664] R13: 000055a7f90f2c50 R14: 000055a7f96e2310 R15: 000055a7f96e2310
    [  748.032287]
    [  748.034509] Allocated by task 2300:
    [  748.038982]  kasan_kmalloc+0xa0/0xd0
    [  748.043562]  kmem_cache_alloc_node+0xf5/0x2e0
    [  748.049018]  copy_process+0x1781/0x4790
    [  748.053884]  _do_fork+0x166/0x9a0
    [  748.058163]  do_syscall_64+0x117/0x400
    [  748.062943]  entry_SYSCALL_64_after_hwframe+0x49/0xbe
    [  748.069180]
    [  748.071405] Freed by task 15395:
    [  748.075591]  __kasan_slab_free+0x130/0x180
    [  748.080752]  kmem_cache_free+0xc2/0x310
    [  748.085619]  free_task+0xea/0x130
    [  748.089901]  __put_task_struct+0x177/0x230
    [  748.095063]  finish_task_switch+0x51b/0x5d0
    [  748.100315]  __schedule+0x506/0xfa0
    [  748.104791]  schedule+0xca/0x260
    [  748.108978]  futex_wait_queue_me+0x27e/0x420
    [  748.114333]  futex_wait+0x251/0x550
    [  748.118814]  do_futex+0x75b/0xf80
    [  748.123097]  __x64_sys_futex+0x231/0x2a0
    [  748.128065]  do_syscall_64+0x117/0x400
    [  748.132835]  entry_SYSCALL_64_after_hwframe+0x49/0xbe
    [  748.139066]
    [  748.141289] The buggy address belongs to the object at ffff88a027698000
    [  748.141289]  which belongs to the cache task_struct of size 12160
    [  748.156589] The buggy address is located 2272 bytes inside of
    [  748.156589]  12160-byte region [ffff88a027698000, ffff88a02769af80)
    [  748.171114] The buggy address belongs to the page:
    [  748.177055] page:ffffea00809da600 count:1 mapcount:0 mapping:ffff888107d01e00 index:0x0 compound_mapcount: 0
    [  748.189136] flags: 0x57ffffc0008100(slab|head)
    [  748.194688] raw: 0057ffffc0008100 ffffea00809a3200 0000000300000003 ffff888107d01e00
    [  748.204424] raw: 0000000000000000 0000000000020002 00000001ffffffff 0000000000000000
    [  748.214146] page dumped because: kasan: bad access detected
    [  748.220976]
    [  748.223197] Memory state around the buggy address:
    [  748.229128]  ffff88a027698780: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [  748.238271]  ffff88a027698800: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [  748.247414] >ffff88a027698880: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [  748.256564]                                                        ^
    [  748.264267]  ffff88a027698900: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [  748.273493]  ffff88a027698980: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [  748.282630] ==================================================================
    
    Fixes: b086ff87251b4a4 ("connector: add parent pid and tgid to coredump and exit events")
    Signed-off-by: Zhang Yu <zhangyu31@baidu.com>
    Signed-off-by: Li RongQing <lirongqing@baidu.com>
    Acked-by: Evgeniy Polyakov <zbr@ioremap.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit c4b5717a016849b4eb437013e662f3546a0ed163
Author: Li RongQing <lirongqing@baidu.com>
Date:   Wed Mar 6 14:46:27 2019 +0800

    connector: fix unsafe usage of ->real_parent
    
    [ Upstream commit 6d2b0f02f5a07a4bf02e4cbc90d7eaa85cac2986 ]
    
    proc_exit_connector() uses ->real_parent lockless. This is not
    safe that its parent can go away at any moment, so use RCU to
    protect it, and ensure that this task is not released.
    
    [  747.624551] ==================================================================
    [  747.632946] BUG: KASAN: use-after-free in proc_exit_connector+0x1f7/0x310
    [  747.640686] Read of size 4 at addr ffff88a0276988e0 by task sshd/2882
    [  747.648032]
    [  747.649804] CPU: 11 PID: 2882 Comm: sshd Tainted: G            E     4.19.26-rc2 #11
    [  747.658629] Hardware name: IBM x3550M4 -[7914OFV]-/00AM544, BIOS -[D7E142BUS-1.71]- 07/31/2014
    [  747.668419] Call Trace:
    [  747.671269]  dump_stack+0xf0/0x19b
    [  747.675186]  ? show_regs_print_info+0x5/0x5
    [  747.679988]  ? kmsg_dump_rewind_nolock+0x59/0x59
    [  747.685302]  print_address_description+0x6a/0x270
    [  747.691162]  kasan_report+0x258/0x380
    [  747.695835]  ? proc_exit_connector+0x1f7/0x310
    [  747.701402]  proc_exit_connector+0x1f7/0x310
    [  747.706767]  ? proc_coredump_connector+0x2d0/0x2d0
    [  747.712715]  ? _raw_write_unlock_irq+0x29/0x50
    [  747.718270]  ? _raw_write_unlock_irq+0x29/0x50
    [  747.723820]  ? ___preempt_schedule+0x16/0x18
    [  747.729193]  ? ___preempt_schedule+0x16/0x18
    [  747.734574]  do_exit+0xa11/0x14f0
    [  747.738880]  ? mm_update_next_owner+0x590/0x590
    [  747.744525]  ? debug_show_all_locks+0x3c0/0x3c0
    [  747.761448]  ? ktime_get_coarse_real_ts64+0xeb/0x1c0
    [  747.767589]  ? lockdep_hardirqs_on+0x1a6/0x290
    [  747.773154]  ? check_chain_key+0x139/0x1f0
    [  747.778345]  ? check_flags.part.35+0x240/0x240
    [  747.783908]  ? __lock_acquire+0x2300/0x2300
    [  747.789171]  ? _raw_spin_unlock_irqrestore+0x59/0x70
    [  747.795316]  ? _raw_spin_unlock_irqrestore+0x59/0x70
    [  747.801457]  ? do_raw_spin_unlock+0x10f/0x1e0
    [  747.806914]  ? do_raw_spin_trylock+0x120/0x120
    [  747.812481]  ? preempt_count_sub+0x14/0xc0
    [  747.817645]  ? _raw_spin_unlock+0x2e/0x50
    [  747.822708]  ? __handle_mm_fault+0x12db/0x1fa0
    [  747.828367]  ? __pmd_alloc+0x2d0/0x2d0
    [  747.833143]  ? check_noncircular+0x50/0x50
    [  747.838309]  ? match_held_lock+0x7f/0x340
    [  747.843380]  ? check_noncircular+0x50/0x50
    [  747.848561]  ? handle_mm_fault+0x21a/0x5f0
    [  747.853730]  ? check_flags.part.35+0x240/0x240
    [  747.859290]  ? check_chain_key+0x139/0x1f0
    [  747.864474]  ? __do_page_fault+0x40f/0x760
    [  747.869655]  ? __audit_syscall_entry+0x4b/0x1f0
    [  747.875319]  ? syscall_trace_enter+0x1d5/0x7b0
    [  747.880877]  ? trace_raw_output_preemptirq_template+0x90/0x90
    [  747.887895]  ? trace_raw_output_sys_exit+0x80/0x80
    [  747.893860]  ? up_read+0x3b/0x90
    [  747.898142]  ? stop_critical_timings+0x260/0x260
    [  747.903909]  do_group_exit+0xe0/0x1c0
    [  747.908591]  ? __x64_sys_exit+0x30/0x30
    [  747.913460]  ? trace_raw_output_preemptirq_template+0x90/0x90
    [  747.920485]  ? tracer_hardirqs_on+0x270/0x270
    [  747.925956]  __x64_sys_exit_group+0x28/0x30
    [  747.931214]  do_syscall_64+0x117/0x400
    [  747.935988]  ? syscall_return_slowpath+0x2f0/0x2f0
    [  747.941931]  ? trace_hardirqs_off_thunk+0x1a/0x1c
    [  747.947788]  ? trace_hardirqs_on_caller+0x1d0/0x1d0
    [  747.953838]  ? lockdep_sys_exit+0x16/0x8e
    [  747.958915]  ? trace_hardirqs_off_thunk+0x1a/0x1c
    [  747.964784]  entry_SYSCALL_64_after_hwframe+0x49/0xbe
    [  747.971021] RIP: 0033:0x7f572f154c68
    [  747.975606] Code: Bad RIP value.
    [  747.979791] RSP: 002b:00007ffed2dfaa58 EFLAGS: 00000246 ORIG_RAX: 00000000000000e7
    [  747.989324] RAX: ffffffffffffffda RBX: 00007f572f431840 RCX: 00007f572f154c68
    [  747.997910] RDX: 0000000000000001 RSI: 000000000000003c RDI: 0000000000000001
    [  748.006495] RBP: 0000000000000001 R08: 00000000000000e7 R09: fffffffffffffee0
    [  748.015079] R10: 00007f572f4387e8 R11: 0000000000000246 R12: 00007f572f431840
    [  748.023664] R13: 000055a7f90f2c50 R14: 000055a7f96e2310 R15: 000055a7f96e2310
    [  748.032287]
    [  748.034509] Allocated by task 2300:
    [  748.038982]  kasan_kmalloc+0xa0/0xd0
    [  748.043562]  kmem_cache_alloc_node+0xf5/0x2e0
    [  748.049018]  copy_process+0x1781/0x4790
    [  748.053884]  _do_fork+0x166/0x9a0
    [  748.058163]  do_syscall_64+0x117/0x400
    [  748.062943]  entry_SYSCALL_64_after_hwframe+0x49/0xbe
    [  748.069180]
    [  748.071405] Freed by task 15395:
    [  748.075591]  __kasan_slab_free+0x130/0x180
    [  748.080752]  kmem_cache_free+0xc2/0x310
    [  748.085619]  free_task+0xea/0x130
    [  748.089901]  __put_task_struct+0x177/0x230
    [  748.095063]  finish_task_switch+0x51b/0x5d0
    [  748.100315]  __schedule+0x506/0xfa0
    [  748.104791]  schedule+0xca/0x260
    [  748.108978]  futex_wait_queue_me+0x27e/0x420
    [  748.114333]  futex_wait+0x251/0x550
    [  748.118814]  do_futex+0x75b/0xf80
    [  748.123097]  __x64_sys_futex+0x231/0x2a0
    [  748.128065]  do_syscall_64+0x117/0x400
    [  748.132835]  entry_SYSCALL_64_after_hwframe+0x49/0xbe
    [  748.139066]
    [  748.141289] The buggy address belongs to the object at ffff88a027698000
    [  748.141289]  which belongs to the cache task_struct of size 12160
    [  748.156589] The buggy address is located 2272 bytes inside of
    [  748.156589]  12160-byte region [ffff88a027698000, ffff88a02769af80)
    [  748.171114] The buggy address belongs to the page:
    [  748.177055] page:ffffea00809da600 count:1 mapcount:0 mapping:ffff888107d01e00 index:0x0 compound_mapcount: 0
    [  748.189136] flags: 0x57ffffc0008100(slab|head)
    [  748.194688] raw: 0057ffffc0008100 ffffea00809a3200 0000000300000003 ffff888107d01e00
    [  748.204424] raw: 0000000000000000 0000000000020002 00000001ffffffff 0000000000000000
    [  748.214146] page dumped because: kasan: bad access detected
    [  748.220976]
    [  748.223197] Memory state around the buggy address:
    [  748.229128]  ffff88a027698780: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [  748.238271]  ffff88a027698800: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [  748.247414] >ffff88a027698880: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [  748.256564]                                                        ^
    [  748.264267]  ffff88a027698900: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [  748.273493]  ffff88a027698980: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [  748.282630] ==================================================================
    
    Fixes: b086ff87251b4a4 ("connector: add parent pid and tgid to coredump and exit events")
    Signed-off-by: Zhang Yu <zhangyu31@baidu.com>
    Signed-off-by: Li RongQing <lirongqing@baidu.com>
    Acked-by: Evgeniy Polyakov <zbr@ioremap.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 6d2b0f02f5a07a4bf02e4cbc90d7eaa85cac2986
Author: Li RongQing <lirongqing@baidu.com>
Date:   Wed Mar 6 14:46:27 2019 +0800

    connector: fix unsafe usage of ->real_parent
    
    proc_exit_connector() uses ->real_parent lockless. This is not
    safe that its parent can go away at any moment, so use RCU to
    protect it, and ensure that this task is not released.
    
    [  747.624551] ==================================================================
    [  747.632946] BUG: KASAN: use-after-free in proc_exit_connector+0x1f7/0x310
    [  747.640686] Read of size 4 at addr ffff88a0276988e0 by task sshd/2882
    [  747.648032]
    [  747.649804] CPU: 11 PID: 2882 Comm: sshd Tainted: G            E     4.19.26-rc2 #11
    [  747.658629] Hardware name: IBM x3550M4 -[7914OFV]-/00AM544, BIOS -[D7E142BUS-1.71]- 07/31/2014
    [  747.668419] Call Trace:
    [  747.671269]  dump_stack+0xf0/0x19b
    [  747.675186]  ? show_regs_print_info+0x5/0x5
    [  747.679988]  ? kmsg_dump_rewind_nolock+0x59/0x59
    [  747.685302]  print_address_description+0x6a/0x270
    [  747.691162]  kasan_report+0x258/0x380
    [  747.695835]  ? proc_exit_connector+0x1f7/0x310
    [  747.701402]  proc_exit_connector+0x1f7/0x310
    [  747.706767]  ? proc_coredump_connector+0x2d0/0x2d0
    [  747.712715]  ? _raw_write_unlock_irq+0x29/0x50
    [  747.718270]  ? _raw_write_unlock_irq+0x29/0x50
    [  747.723820]  ? ___preempt_schedule+0x16/0x18
    [  747.729193]  ? ___preempt_schedule+0x16/0x18
    [  747.734574]  do_exit+0xa11/0x14f0
    [  747.738880]  ? mm_update_next_owner+0x590/0x590
    [  747.744525]  ? debug_show_all_locks+0x3c0/0x3c0
    [  747.761448]  ? ktime_get_coarse_real_ts64+0xeb/0x1c0
    [  747.767589]  ? lockdep_hardirqs_on+0x1a6/0x290
    [  747.773154]  ? check_chain_key+0x139/0x1f0
    [  747.778345]  ? check_flags.part.35+0x240/0x240
    [  747.783908]  ? __lock_acquire+0x2300/0x2300
    [  747.789171]  ? _raw_spin_unlock_irqrestore+0x59/0x70
    [  747.795316]  ? _raw_spin_unlock_irqrestore+0x59/0x70
    [  747.801457]  ? do_raw_spin_unlock+0x10f/0x1e0
    [  747.806914]  ? do_raw_spin_trylock+0x120/0x120
    [  747.812481]  ? preempt_count_sub+0x14/0xc0
    [  747.817645]  ? _raw_spin_unlock+0x2e/0x50
    [  747.822708]  ? __handle_mm_fault+0x12db/0x1fa0
    [  747.828367]  ? __pmd_alloc+0x2d0/0x2d0
    [  747.833143]  ? check_noncircular+0x50/0x50
    [  747.838309]  ? match_held_lock+0x7f/0x340
    [  747.843380]  ? check_noncircular+0x50/0x50
    [  747.848561]  ? handle_mm_fault+0x21a/0x5f0
    [  747.853730]  ? check_flags.part.35+0x240/0x240
    [  747.859290]  ? check_chain_key+0x139/0x1f0
    [  747.864474]  ? __do_page_fault+0x40f/0x760
    [  747.869655]  ? __audit_syscall_entry+0x4b/0x1f0
    [  747.875319]  ? syscall_trace_enter+0x1d5/0x7b0
    [  747.880877]  ? trace_raw_output_preemptirq_template+0x90/0x90
    [  747.887895]  ? trace_raw_output_sys_exit+0x80/0x80
    [  747.893860]  ? up_read+0x3b/0x90
    [  747.898142]  ? stop_critical_timings+0x260/0x260
    [  747.903909]  do_group_exit+0xe0/0x1c0
    [  747.908591]  ? __x64_sys_exit+0x30/0x30
    [  747.913460]  ? trace_raw_output_preemptirq_template+0x90/0x90
    [  747.920485]  ? tracer_hardirqs_on+0x270/0x270
    [  747.925956]  __x64_sys_exit_group+0x28/0x30
    [  747.931214]  do_syscall_64+0x117/0x400
    [  747.935988]  ? syscall_return_slowpath+0x2f0/0x2f0
    [  747.941931]  ? trace_hardirqs_off_thunk+0x1a/0x1c
    [  747.947788]  ? trace_hardirqs_on_caller+0x1d0/0x1d0
    [  747.953838]  ? lockdep_sys_exit+0x16/0x8e
    [  747.958915]  ? trace_hardirqs_off_thunk+0x1a/0x1c
    [  747.964784]  entry_SYSCALL_64_after_hwframe+0x49/0xbe
    [  747.971021] RIP: 0033:0x7f572f154c68
    [  747.975606] Code: Bad RIP value.
    [  747.979791] RSP: 002b:00007ffed2dfaa58 EFLAGS: 00000246 ORIG_RAX: 00000000000000e7
    [  747.989324] RAX: ffffffffffffffda RBX: 00007f572f431840 RCX: 00007f572f154c68
    [  747.997910] RDX: 0000000000000001 RSI: 000000000000003c RDI: 0000000000000001
    [  748.006495] RBP: 0000000000000001 R08: 00000000000000e7 R09: fffffffffffffee0
    [  748.015079] R10: 00007f572f4387e8 R11: 0000000000000246 R12: 00007f572f431840
    [  748.023664] R13: 000055a7f90f2c50 R14: 000055a7f96e2310 R15: 000055a7f96e2310
    [  748.032287]
    [  748.034509] Allocated by task 2300:
    [  748.038982]  kasan_kmalloc+0xa0/0xd0
    [  748.043562]  kmem_cache_alloc_node+0xf5/0x2e0
    [  748.049018]  copy_process+0x1781/0x4790
    [  748.053884]  _do_fork+0x166/0x9a0
    [  748.058163]  do_syscall_64+0x117/0x400
    [  748.062943]  entry_SYSCALL_64_after_hwframe+0x49/0xbe
    [  748.069180]
    [  748.071405] Freed by task 15395:
    [  748.075591]  __kasan_slab_free+0x130/0x180
    [  748.080752]  kmem_cache_free+0xc2/0x310
    [  748.085619]  free_task+0xea/0x130
    [  748.089901]  __put_task_struct+0x177/0x230
    [  748.095063]  finish_task_switch+0x51b/0x5d0
    [  748.100315]  __schedule+0x506/0xfa0
    [  748.104791]  schedule+0xca/0x260
    [  748.108978]  futex_wait_queue_me+0x27e/0x420
    [  748.114333]  futex_wait+0x251/0x550
    [  748.118814]  do_futex+0x75b/0xf80
    [  748.123097]  __x64_sys_futex+0x231/0x2a0
    [  748.128065]  do_syscall_64+0x117/0x400
    [  748.132835]  entry_SYSCALL_64_after_hwframe+0x49/0xbe
    [  748.139066]
    [  748.141289] The buggy address belongs to the object at ffff88a027698000
    [  748.141289]  which belongs to the cache task_struct of size 12160
    [  748.156589] The buggy address is located 2272 bytes inside of
    [  748.156589]  12160-byte region [ffff88a027698000, ffff88a02769af80)
    [  748.171114] The buggy address belongs to the page:
    [  748.177055] page:ffffea00809da600 count:1 mapcount:0 mapping:ffff888107d01e00 index:0x0 compound_mapcount: 0
    [  748.189136] flags: 0x57ffffc0008100(slab|head)
    [  748.194688] raw: 0057ffffc0008100 ffffea00809a3200 0000000300000003 ffff888107d01e00
    [  748.204424] raw: 0000000000000000 0000000000020002 00000001ffffffff 0000000000000000
    [  748.214146] page dumped because: kasan: bad access detected
    [  748.220976]
    [  748.223197] Memory state around the buggy address:
    [  748.229128]  ffff88a027698780: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [  748.238271]  ffff88a027698800: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [  748.247414] >ffff88a027698880: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [  748.256564]                                                        ^
    [  748.264267]  ffff88a027698900: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [  748.273493]  ffff88a027698980: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [  748.282630] ==================================================================
    
    Fixes: b086ff87251b4a4 ("connector: add parent pid and tgid to coredump and exit events")
    Signed-off-by: Zhang Yu <zhangyu31@baidu.com>
    Signed-off-by: Li RongQing <lirongqing@baidu.com>
    Acked-by: Evgeniy Polyakov <zbr@ioremap.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit ae60f4705f95889cdb3cc9d8c4fd3ef2486074bc
Author: Taehee Yoo <ap420073@gmail.com>
Date:   Mon Nov 5 03:44:11 2018 +0900

    netfilter: nf_conncount: fix list_del corruption in conn_free
    
    [ Upstream commit 31568ec09ea02a050249921698c9729419539cce ]
    
    nf_conncount_tuple is an element of nft_connlimit and that is deleted by
    conn_free(). Elements can be deleted by both GC routine and data path
    functions (nf_conncount_lookup, nf_conncount_add) and they call
    conn_free() to free elements. But conn_free() only protects lists, not
    each element. So that list_del corruption could occurred.
    
    The conn_free() doesn't check whether element is already deleted. In
    order to protect elements, dead flag is added. If an element is deleted,
    dead flag is set. The only conn_free() can delete elements so that both
    list lock and dead flag are enough to protect it.
    
    test commands:
       %nft add table ip filter
       %nft add chain ip filter input { type filter hook input priority 0\; }
       %nft add rule filter input meter test { ip id ct count over 2 } counter
    
    splat looks like:
    [ 1779.495778] list_del corruption, ffff8800b6e12008->prev is LIST_POISON2 (dead000000000200)
    [ 1779.505453] ------------[ cut here ]------------
    [ 1779.506260] kernel BUG at lib/list_debug.c:50!
    [ 1779.515831] invalid opcode: 0000 [#1] SMP DEBUG_PAGEALLOC KASAN PTI
    [ 1779.516772] CPU: 0 PID: 33 Comm: kworker/0:2 Not tainted 4.19.0-rc6+ #22
    [ 1779.516772] Workqueue: events_power_efficient nft_rhash_gc [nf_tables_set]
    [ 1779.516772] RIP: 0010:__list_del_entry_valid+0xd8/0x150
    [ 1779.516772] Code: 39 48 83 c4 08 b8 01 00 00 00 5b 5d c3 48 89 ea 48 c7 c7 00 c3 5b 98 e8 0f dc 40 ff 0f 0b 48 c7 c7 60 c3 5b 98 e8 01 dc 40 ff <0f> 0b 48 c7 c7 c0 c3 5b 98 e8 f3 db 40 ff 0f 0b 48 c7 c7 20 c4 5b
    [ 1779.516772] RSP: 0018:ffff880119127420 EFLAGS: 00010286
    [ 1779.516772] RAX: 000000000000004e RBX: dead000000000200 RCX: 0000000000000000
    [ 1779.516772] RDX: 000000000000004e RSI: 0000000000000008 RDI: ffffed0023224e7a
    [ 1779.516772] RBP: ffff88011934bc10 R08: ffffed002367cea9 R09: ffffed002367cea9
    [ 1779.516772] R10: 0000000000000001 R11: ffffed002367cea8 R12: ffff8800b6e12008
    [ 1779.516772] R13: ffff8800b6e12010 R14: ffff88011934bc20 R15: ffff8800b6e12008
    [ 1779.516772] FS:  0000000000000000(0000) GS:ffff88011b200000(0000) knlGS:0000000000000000
    [ 1779.516772] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [ 1779.516772] CR2: 00007fc876534010 CR3: 000000010da16000 CR4: 00000000001006f0
    [ 1779.516772] Call Trace:
    [ 1779.516772]  conn_free+0x9f/0x2b0 [nf_conncount]
    [ 1779.516772]  ? nf_ct_tmpl_alloc+0x2a0/0x2a0 [nf_conntrack]
    [ 1779.516772]  ? nf_conncount_add+0x520/0x520 [nf_conncount]
    [ 1779.516772]  ? do_raw_spin_trylock+0x1a0/0x1a0
    [ 1779.516772]  ? do_raw_spin_trylock+0x10/0x1a0
    [ 1779.516772]  find_or_evict+0xe5/0x150 [nf_conncount]
    [ 1779.516772]  nf_conncount_gc_list+0x162/0x360 [nf_conncount]
    [ 1779.516772]  ? nf_conncount_lookup+0xee0/0xee0 [nf_conncount]
    [ 1779.516772]  ? _raw_spin_unlock_irqrestore+0x45/0x50
    [ 1779.516772]  ? trace_hardirqs_off+0x6b/0x220
    [ 1779.516772]  ? trace_hardirqs_on_caller+0x220/0x220
    [ 1779.516772]  nft_rhash_gc+0x16b/0x540 [nf_tables_set]
    [ ... ]
    
    Fixes: 5c789e131cbb ("netfilter: nf_conncount: Add list lock and gc worker, and RCU for init tree search")
    Signed-off-by: Taehee Yoo <ap420073@gmail.com>
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 31568ec09ea02a050249921698c9729419539cce
Author: Taehee Yoo <ap420073@gmail.com>
Date:   Mon Nov 5 03:44:11 2018 +0900

    netfilter: nf_conncount: fix list_del corruption in conn_free
    
    nf_conncount_tuple is an element of nft_connlimit and that is deleted by
    conn_free(). Elements can be deleted by both GC routine and data path
    functions (nf_conncount_lookup, nf_conncount_add) and they call
    conn_free() to free elements. But conn_free() only protects lists, not
    each element. So that list_del corruption could occurred.
    
    The conn_free() doesn't check whether element is already deleted. In
    order to protect elements, dead flag is added. If an element is deleted,
    dead flag is set. The only conn_free() can delete elements so that both
    list lock and dead flag are enough to protect it.
    
    test commands:
       %nft add table ip filter
       %nft add chain ip filter input { type filter hook input priority 0\; }
       %nft add rule filter input meter test { ip id ct count over 2 } counter
    
    splat looks like:
    [ 1779.495778] list_del corruption, ffff8800b6e12008->prev is LIST_POISON2 (dead000000000200)
    [ 1779.505453] ------------[ cut here ]------------
    [ 1779.506260] kernel BUG at lib/list_debug.c:50!
    [ 1779.515831] invalid opcode: 0000 [#1] SMP DEBUG_PAGEALLOC KASAN PTI
    [ 1779.516772] CPU: 0 PID: 33 Comm: kworker/0:2 Not tainted 4.19.0-rc6+ #22
    [ 1779.516772] Workqueue: events_power_efficient nft_rhash_gc [nf_tables_set]
    [ 1779.516772] RIP: 0010:__list_del_entry_valid+0xd8/0x150
    [ 1779.516772] Code: 39 48 83 c4 08 b8 01 00 00 00 5b 5d c3 48 89 ea 48 c7 c7 00 c3 5b 98 e8 0f dc 40 ff 0f 0b 48 c7 c7 60 c3 5b 98 e8 01 dc 40 ff <0f> 0b 48 c7 c7 c0 c3 5b 98 e8 f3 db 40 ff 0f 0b 48 c7 c7 20 c4 5b
    [ 1779.516772] RSP: 0018:ffff880119127420 EFLAGS: 00010286
    [ 1779.516772] RAX: 000000000000004e RBX: dead000000000200 RCX: 0000000000000000
    [ 1779.516772] RDX: 000000000000004e RSI: 0000000000000008 RDI: ffffed0023224e7a
    [ 1779.516772] RBP: ffff88011934bc10 R08: ffffed002367cea9 R09: ffffed002367cea9
    [ 1779.516772] R10: 0000000000000001 R11: ffffed002367cea8 R12: ffff8800b6e12008
    [ 1779.516772] R13: ffff8800b6e12010 R14: ffff88011934bc20 R15: ffff8800b6e12008
    [ 1779.516772] FS:  0000000000000000(0000) GS:ffff88011b200000(0000) knlGS:0000000000000000
    [ 1779.516772] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [ 1779.516772] CR2: 00007fc876534010 CR3: 000000010da16000 CR4: 00000000001006f0
    [ 1779.516772] Call Trace:
    [ 1779.516772]  conn_free+0x9f/0x2b0 [nf_conncount]
    [ 1779.516772]  ? nf_ct_tmpl_alloc+0x2a0/0x2a0 [nf_conntrack]
    [ 1779.516772]  ? nf_conncount_add+0x520/0x520 [nf_conncount]
    [ 1779.516772]  ? do_raw_spin_trylock+0x1a0/0x1a0
    [ 1779.516772]  ? do_raw_spin_trylock+0x10/0x1a0
    [ 1779.516772]  find_or_evict+0xe5/0x150 [nf_conncount]
    [ 1779.516772]  nf_conncount_gc_list+0x162/0x360 [nf_conncount]
    [ 1779.516772]  ? nf_conncount_lookup+0xee0/0xee0 [nf_conncount]
    [ 1779.516772]  ? _raw_spin_unlock_irqrestore+0x45/0x50
    [ 1779.516772]  ? trace_hardirqs_off+0x6b/0x220
    [ 1779.516772]  ? trace_hardirqs_on_caller+0x220/0x220
    [ 1779.516772]  nft_rhash_gc+0x16b/0x540 [nf_tables_set]
    [ ... ]
    
    Fixes: 5c789e131cbb ("netfilter: nf_conncount: Add list lock and gc worker, and RCU for init tree search")
    Signed-off-by: Taehee Yoo <ap420073@gmail.com>
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>

commit 8d3156b3c109dbceea5ece40cfb74b3a22ee2fb1
Author: Taehee Yoo <ap420073@gmail.com>
Date:   Thu Aug 30 17:56:52 2018 +0900

    netfilter: nft_set_rbtree: add missing rb_erase() in GC routine
    
    [ Upstream commit a13f814a67b12a2f29d1decf4b4f4e700658a517 ]
    
    The nft_set_gc_batch_check() checks whether gc buffer is full.
    If gc buffer is full, gc buffer is released by
    the nft_set_gc_batch_complete() internally.
    In case of rbtree, the rb_erase() should be called before calling the
    nft_set_gc_batch_complete(). therefore the rb_erase() should
    be called before calling the nft_set_gc_batch_check() too.
    
    test commands:
       table ip filter {
               set set1 {
                       type ipv4_addr; flags interval, timeout;
                       gc-interval 10s;
                       timeout 1s;
                       elements = {
                               1-2,
                               3-4,
                               5-6,
                               ...
                               10000-10001,
                       }
               }
       }
       %nft -f test.nft
    
    splat looks like:
    [  430.273885] kasan: GPF could be caused by NULL-ptr deref or user memory access
    [  430.282158] general protection fault: 0000 [#1] SMP DEBUG_PAGEALLOC KASAN PTI
    [  430.283116] CPU: 1 PID: 190 Comm: kworker/1:2 Tainted: G    B             4.18.0+ #7
    [  430.283116] Workqueue: events_power_efficient nft_rbtree_gc [nf_tables_set]
    [  430.313559] RIP: 0010:rb_next+0x81/0x130
    [  430.313559] Code: 08 49 bd 00 00 00 00 00 fc ff df 48 bb 00 00 00 00 00 fc ff df 48 85 c0 75 05 eb 58 48 89 d4
    [  430.313559] RSP: 0018:ffff88010cdb7680 EFLAGS: 00010207
    [  430.313559] RAX: 0000000000b84854 RBX: dffffc0000000000 RCX: ffffffff83f01973
    [  430.313559] RDX: 000000000017090c RSI: 0000000000000008 RDI: 0000000000b84864
    [  430.313559] RBP: ffff8801060d4588 R08: fffffbfff09bc349 R09: fffffbfff09bc349
    [  430.313559] R10: 0000000000000001 R11: fffffbfff09bc348 R12: ffff880100f081a8
    [  430.313559] R13: dffffc0000000000 R14: ffff880100ff8688 R15: dffffc0000000000
    [  430.313559] FS:  0000000000000000(0000) GS:ffff88011b400000(0000) knlGS:0000000000000000
    [  430.313559] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [  430.313559] CR2: 0000000001551008 CR3: 000000005dc16000 CR4: 00000000001006e0
    [  430.313559] Call Trace:
    [  430.313559]  nft_rbtree_gc+0x112/0x5c0 [nf_tables_set]
    [  430.313559]  process_one_work+0xc13/0x1ec0
    [  430.313559]  ? _raw_spin_unlock_irq+0x29/0x40
    [  430.313559]  ? pwq_dec_nr_in_flight+0x3c0/0x3c0
    [  430.313559]  ? set_load_weight+0x270/0x270
    [  430.313559]  ? __switch_to_asm+0x34/0x70
    [  430.313559]  ? __switch_to_asm+0x40/0x70
    [  430.313559]  ? __switch_to_asm+0x34/0x70
    [  430.313559]  ? __switch_to_asm+0x34/0x70
    [  430.313559]  ? __switch_to_asm+0x40/0x70
    [  430.313559]  ? __switch_to_asm+0x34/0x70
    [  430.313559]  ? __switch_to_asm+0x40/0x70
    [  430.313559]  ? __switch_to_asm+0x34/0x70
    [  430.313559]  ? __switch_to_asm+0x34/0x70
    [  430.313559]  ? __switch_to_asm+0x40/0x70
    [  430.313559]  ? __switch_to_asm+0x34/0x70
    [  430.313559]  ? __schedule+0x6d3/0x1f50
    [  430.313559]  ? find_held_lock+0x39/0x1c0
    [  430.313559]  ? __sched_text_start+0x8/0x8
    [  430.313559]  ? cyc2ns_read_end+0x10/0x10
    [  430.313559]  ? save_trace+0x300/0x300
    [  430.313559]  ? sched_clock_local+0xd4/0x140
    [  430.313559]  ? find_held_lock+0x39/0x1c0
    [  430.313559]  ? worker_thread+0x353/0x1120
    [  430.313559]  ? worker_thread+0x353/0x1120
    [  430.313559]  ? lock_contended+0xe70/0xe70
    [  430.313559]  ? __lock_acquire+0x4500/0x4500
    [  430.535635]  ? do_raw_spin_unlock+0xa5/0x330
    [  430.535635]  ? do_raw_spin_trylock+0x101/0x1a0
    [  430.535635]  ? do_raw_spin_lock+0x1f0/0x1f0
    [  430.535635]  ? _raw_spin_lock_irq+0x10/0x70
    [  430.535635]  worker_thread+0x15d/0x1120
    [ ... ]
    
    Fixes: 8d8540c4f5e0 ("netfilter: nft_set_rbtree: add timeout support")
    Signed-off-by: Taehee Yoo <ap420073@gmail.com>
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit a13f814a67b12a2f29d1decf4b4f4e700658a517
Author: Taehee Yoo <ap420073@gmail.com>
Date:   Thu Aug 30 17:56:52 2018 +0900

    netfilter: nft_set_rbtree: add missing rb_erase() in GC routine
    
    The nft_set_gc_batch_check() checks whether gc buffer is full.
    If gc buffer is full, gc buffer is released by
    the nft_set_gc_batch_complete() internally.
    In case of rbtree, the rb_erase() should be called before calling the
    nft_set_gc_batch_complete(). therefore the rb_erase() should
    be called before calling the nft_set_gc_batch_check() too.
    
    test commands:
       table ip filter {
               set set1 {
                       type ipv4_addr; flags interval, timeout;
                       gc-interval 10s;
                       timeout 1s;
                       elements = {
                               1-2,
                               3-4,
                               5-6,
                               ...
                               10000-10001,
                       }
               }
       }
       %nft -f test.nft
    
    splat looks like:
    [  430.273885] kasan: GPF could be caused by NULL-ptr deref or user memory access
    [  430.282158] general protection fault: 0000 [#1] SMP DEBUG_PAGEALLOC KASAN PTI
    [  430.283116] CPU: 1 PID: 190 Comm: kworker/1:2 Tainted: G    B             4.18.0+ #7
    [  430.283116] Workqueue: events_power_efficient nft_rbtree_gc [nf_tables_set]
    [  430.313559] RIP: 0010:rb_next+0x81/0x130
    [  430.313559] Code: 08 49 bd 00 00 00 00 00 fc ff df 48 bb 00 00 00 00 00 fc ff df 48 85 c0 75 05 eb 58 48 89 d4
    [  430.313559] RSP: 0018:ffff88010cdb7680 EFLAGS: 00010207
    [  430.313559] RAX: 0000000000b84854 RBX: dffffc0000000000 RCX: ffffffff83f01973
    [  430.313559] RDX: 000000000017090c RSI: 0000000000000008 RDI: 0000000000b84864
    [  430.313559] RBP: ffff8801060d4588 R08: fffffbfff09bc349 R09: fffffbfff09bc349
    [  430.313559] R10: 0000000000000001 R11: fffffbfff09bc348 R12: ffff880100f081a8
    [  430.313559] R13: dffffc0000000000 R14: ffff880100ff8688 R15: dffffc0000000000
    [  430.313559] FS:  0000000000000000(0000) GS:ffff88011b400000(0000) knlGS:0000000000000000
    [  430.313559] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [  430.313559] CR2: 0000000001551008 CR3: 000000005dc16000 CR4: 00000000001006e0
    [  430.313559] Call Trace:
    [  430.313559]  nft_rbtree_gc+0x112/0x5c0 [nf_tables_set]
    [  430.313559]  process_one_work+0xc13/0x1ec0
    [  430.313559]  ? _raw_spin_unlock_irq+0x29/0x40
    [  430.313559]  ? pwq_dec_nr_in_flight+0x3c0/0x3c0
    [  430.313559]  ? set_load_weight+0x270/0x270
    [  430.313559]  ? __switch_to_asm+0x34/0x70
    [  430.313559]  ? __switch_to_asm+0x40/0x70
    [  430.313559]  ? __switch_to_asm+0x34/0x70
    [  430.313559]  ? __switch_to_asm+0x34/0x70
    [  430.313559]  ? __switch_to_asm+0x40/0x70
    [  430.313559]  ? __switch_to_asm+0x34/0x70
    [  430.313559]  ? __switch_to_asm+0x40/0x70
    [  430.313559]  ? __switch_to_asm+0x34/0x70
    [  430.313559]  ? __switch_to_asm+0x34/0x70
    [  430.313559]  ? __switch_to_asm+0x40/0x70
    [  430.313559]  ? __switch_to_asm+0x34/0x70
    [  430.313559]  ? __schedule+0x6d3/0x1f50
    [  430.313559]  ? find_held_lock+0x39/0x1c0
    [  430.313559]  ? __sched_text_start+0x8/0x8
    [  430.313559]  ? cyc2ns_read_end+0x10/0x10
    [  430.313559]  ? save_trace+0x300/0x300
    [  430.313559]  ? sched_clock_local+0xd4/0x140
    [  430.313559]  ? find_held_lock+0x39/0x1c0
    [  430.313559]  ? worker_thread+0x353/0x1120
    [  430.313559]  ? worker_thread+0x353/0x1120
    [  430.313559]  ? lock_contended+0xe70/0xe70
    [  430.313559]  ? __lock_acquire+0x4500/0x4500
    [  430.535635]  ? do_raw_spin_unlock+0xa5/0x330
    [  430.535635]  ? do_raw_spin_trylock+0x101/0x1a0
    [  430.535635]  ? do_raw_spin_lock+0x1f0/0x1f0
    [  430.535635]  ? _raw_spin_lock_irq+0x10/0x70
    [  430.535635]  worker_thread+0x15d/0x1120
    [ ... ]
    
    Fixes: 8d8540c4f5e0 ("netfilter: nft_set_rbtree: add timeout support")
    Signed-off-by: Taehee Yoo <ap420073@gmail.com>
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>

commit c293ac959f809ee1cd31609d9e62bccf6804b2e6
Author: Taehee Yoo <ap420073@gmail.com>
Date:   Tue Jul 10 23:22:01 2018 +0900

    netfilter: nft_set_rbtree: fix panic when destroying set by GC
    
    This patch fixes below.
    1. check null pointer of rb_next.
     rb_next can return null. so null check routine should be added.
    2. add rcu_barrier in destroy routine.
     GC uses call_rcu to remove elements. but all elements should be
     removed before destroying set and chains. so that rcu_barrier is added.
    
    test script:
       %cat test.nft
       table inet aa {
               map map1 {
                       type ipv4_addr : verdict; flags interval, timeout;
                       elements = {
                               0-1 : jump a0,
                               3-4 : jump a0,
                               6-7 : jump a0,
                               9-10 : jump a0,
                               12-13 : jump a0,
                               15-16 : jump a0,
                               18-19 : jump a0,
                               21-22 : jump a0,
                               24-25 : jump a0,
                               27-28 : jump a0,
                       }
                       timeout 1s;
               }
               chain a0 {
               }
       }
       flush ruleset
       table inet aa {
               map map1 {
                       type ipv4_addr : verdict; flags interval, timeout;
                       elements = {
                               0-1 : jump a0,
                               3-4 : jump a0,
                               6-7 : jump a0,
                               9-10 : jump a0,
                               12-13 : jump a0,
                               15-16 : jump a0,
                               18-19 : jump a0,
                               21-22 : jump a0,
                               24-25 : jump a0,
                               27-28 : jump a0,
                       }
                       timeout 1s;
               }
               chain a0 {
               }
       }
       flush ruleset
    
    splat looks like:
    [ 2402.419838] kasan: GPF could be caused by NULL-ptr deref or user memory access
    [ 2402.428433] general protection fault: 0000 [#1] SMP DEBUG_PAGEALLOC KASAN PTI
    [ 2402.429343] CPU: 1 PID: 1350 Comm: kworker/1:1 Not tainted 4.18.0-rc2+ #1
    [ 2402.429343] Hardware name: To be filled by O.E.M. To be filled by O.E.M./Aptio CRB, BIOS 5.6.5 03/23/2017
    [ 2402.429343] Workqueue: events_power_efficient nft_rbtree_gc [nft_set_rbtree]
    [ 2402.429343] RIP: 0010:rb_next+0x1e/0x130
    [ 2402.429343] Code: e9 de f2 ff ff 0f 1f 80 00 00 00 00 41 55 48 89 fa 41 54 55 53 48 c1 ea 03 48 b8 00 00 00 0
    [ 2402.429343] RSP: 0018:ffff880105f77678 EFLAGS: 00010296
    [ 2402.429343] RAX: dffffc0000000000 RBX: ffff8801143e3428 RCX: 1ffff1002287c69c
    [ 2402.429343] RDX: 0000000000000000 RSI: 0000000000000004 RDI: 0000000000000000
    [ 2402.429343] RBP: 0000000000000000 R08: ffffed0016aabc24 R09: ffffed0016aabc24
    [ 2402.429343] R10: 0000000000000001 R11: ffffed0016aabc23 R12: 0000000000000000
    [ 2402.429343] R13: ffff8800b6933388 R14: dffffc0000000000 R15: ffff8801143e3440
    [ 2402.534486] kasan: CONFIG_KASAN_INLINE enabled
    [ 2402.534212] FS:  0000000000000000(0000) GS:ffff88011b600000(0000) knlGS:0000000000000000
    [ 2402.534212] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [ 2402.534212] CR2: 0000000000863008 CR3: 00000000a3c16000 CR4: 00000000001006e0
    [ 2402.534212] Call Trace:
    [ 2402.534212]  nft_rbtree_gc+0x2b5/0x5f0 [nft_set_rbtree]
    [ 2402.534212]  process_one_work+0xc1b/0x1ee0
    [ 2402.540329] kasan: GPF could be caused by NULL-ptr deref or user memory access
    [ 2402.534212]  ? _raw_spin_unlock_irq+0x29/0x40
    [ 2402.534212]  ? pwq_dec_nr_in_flight+0x3e0/0x3e0
    [ 2402.534212]  ? set_load_weight+0x270/0x270
    [ 2402.534212]  ? __schedule+0x6ea/0x1fb0
    [ 2402.534212]  ? __sched_text_start+0x8/0x8
    [ 2402.534212]  ? save_trace+0x320/0x320
    [ 2402.534212]  ? sched_clock_local+0xe2/0x150
    [ 2402.534212]  ? find_held_lock+0x39/0x1c0
    [ 2402.534212]  ? worker_thread+0x35f/0x1150
    [ 2402.534212]  ? lock_contended+0xe90/0xe90
    [ 2402.534212]  ? __lock_acquire+0x4520/0x4520
    [ 2402.534212]  ? do_raw_spin_unlock+0xb1/0x350
    [ 2402.534212]  ? do_raw_spin_trylock+0x111/0x1b0
    [ 2402.534212]  ? do_raw_spin_lock+0x1f0/0x1f0
    [ 2402.534212]  worker_thread+0x169/0x1150
    
    Fixes: 8d8540c4f5e0("netfilter: nft_set_rbtree: add timeout support")
    Signed-off-by: Taehee Yoo <ap420073@gmail.com>
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>

commit 68d2f84a1368cc5d4ccbbbfc6821f159d27681c9
Author: Prashant Bhole <bhole_prashant_q7@lab.ntt.co.jp>
Date:   Thu Jul 12 16:24:59 2018 +0900

    net: gro: properly remove skb from list
    
    Following crash occurs in validate_xmit_skb_list() when same skb is
    iterated multiple times in the loop and consume_skb() is called.
    
    The root cause is calling list_del_init(&skb->list) and not clearing
    skb->next in d4546c2509b1. list_del_init(&skb->list) sets skb->next
    to point to skb itself. skb->next needs to be cleared because other
    parts of network stack uses another kind of SKB lists.
    validate_xmit_skb_list() uses such list.
    
    A similar type of bugfix was reported by Jesper Dangaard Brouer.
    https://patchwork.ozlabs.org/patch/942541/
    
    This patch clears skb->next and changes list_del_init() to list_del()
    so that list->prev will maintain the list poison.
    
    [  148.185511] ==================================================================
    [  148.187865] BUG: KASAN: use-after-free in validate_xmit_skb_list+0x4b/0xa0
    [  148.190158] Read of size 8 at addr ffff8801e52eefc0 by task swapper/1/0
    [  148.192940]
    [  148.193642] CPU: 1 PID: 0 Comm: swapper/1 Not tainted 4.18.0-rc3+ #25
    [  148.195423] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS ?-20180531_142017-buildhw-08.phx2.fedoraproject.org-1.fc28 04/01/2014
    [  148.199129] Call Trace:
    [  148.200565]  <IRQ>
    [  148.201911]  dump_stack+0xc6/0x14c
    [  148.203572]  ? dump_stack_print_info.cold.1+0x2f/0x2f
    [  148.205083]  ? kmsg_dump_rewind_nolock+0x59/0x59
    [  148.206307]  ? validate_xmit_skb+0x2c6/0x560
    [  148.207432]  ? debug_show_held_locks+0x30/0x30
    [  148.208571]  ? validate_xmit_skb_list+0x4b/0xa0
    [  148.211144]  print_address_description+0x6c/0x23c
    [  148.212601]  ? validate_xmit_skb_list+0x4b/0xa0
    [  148.213782]  kasan_report.cold.6+0x241/0x2fd
    [  148.214958]  validate_xmit_skb_list+0x4b/0xa0
    [  148.216494]  sch_direct_xmit+0x1b0/0x680
    [  148.217601]  ? dev_watchdog+0x4e0/0x4e0
    [  148.218675]  ? do_raw_spin_trylock+0x10/0x120
    [  148.219818]  ? do_raw_spin_lock+0xe0/0xe0
    [  148.221032]  __dev_queue_xmit+0x1167/0x1810
    [  148.222155]  ? sched_clock+0x5/0x10
    [...]
    
    [  148.474257] Allocated by task 0:
    [  148.475363]  kasan_kmalloc+0xbf/0xe0
    [  148.476503]  kmem_cache_alloc+0xb4/0x1b0
    [  148.477654]  __build_skb+0x91/0x250
    [  148.478677]  build_skb+0x67/0x180
    [  148.479657]  e1000_clean_rx_irq+0x542/0x8a0
    [  148.480757]  e1000_clean+0x652/0xd10
    [  148.481772]  net_rx_action+0x4ea/0xc20
    [  148.482808]  __do_softirq+0x1f9/0x574
    [  148.483831]
    [  148.484575] Freed by task 0:
    [  148.485504]  __kasan_slab_free+0x12e/0x180
    [  148.486589]  kmem_cache_free+0xb4/0x240
    [  148.487634]  kfree_skbmem+0xed/0x150
    [  148.488648]  consume_skb+0x146/0x250
    [  148.489665]  validate_xmit_skb+0x2b7/0x560
    [  148.490754]  validate_xmit_skb_list+0x70/0xa0
    [  148.491897]  sch_direct_xmit+0x1b0/0x680
    [  148.493949]  __dev_queue_xmit+0x1167/0x1810
    [  148.495103]  br_dev_queue_push_xmit+0xce/0x250
    [  148.496196]  br_forward_finish+0x276/0x280
    [  148.497234]  __br_forward+0x44f/0x520
    [  148.498260]  br_forward+0x19f/0x1b0
    [  148.499264]  br_handle_frame_finish+0x65e/0x980
    [  148.500398]  NF_HOOK.constprop.10+0x290/0x2a0
    [  148.501522]  br_handle_frame+0x417/0x640
    [  148.502582]  __netif_receive_skb_core+0xaac/0x18f0
    [  148.503753]  __netif_receive_skb_one_core+0x98/0x120
    [  148.504958]  netif_receive_skb_internal+0xe3/0x330
    [  148.506154]  napi_gro_complete+0x190/0x2a0
    [  148.507243]  dev_gro_receive+0x9f7/0x1100
    [  148.508316]  napi_gro_receive+0xcb/0x260
    [  148.509387]  e1000_clean_rx_irq+0x2fc/0x8a0
    [  148.510501]  e1000_clean+0x652/0xd10
    [  148.511523]  net_rx_action+0x4ea/0xc20
    [  148.512566]  __do_softirq+0x1f9/0x574
    [  148.513598]
    [  148.514346] The buggy address belongs to the object at ffff8801e52eefc0
    [  148.514346]  which belongs to the cache skbuff_head_cache of size 232
    [  148.517047] The buggy address is located 0 bytes inside of
    [  148.517047]  232-byte region [ffff8801e52eefc0, ffff8801e52ef0a8)
    [  148.519549] The buggy address belongs to the page:
    [  148.520726] page:ffffea000794bb00 count:1 mapcount:0 mapping:ffff880106f4dfc0 index:0xffff8801e52ee840 compound_mapcount: 0
    [  148.524325] flags: 0x17ffffc0008100(slab|head)
    [  148.525481] raw: 0017ffffc0008100 ffff880106b938d0 ffff880106b938d0 ffff880106f4dfc0
    [  148.527503] raw: ffff8801e52ee840 0000000000190011 00000001ffffffff 0000000000000000
    [  148.529547] page dumped because: kasan: bad access detected
    
    Fixes: d4546c2509b1 ("net: Convert GRO SKB handling to list_head.")
    Signed-off-by: Prashant Bhole <bhole_prashant_q7@lab.ntt.co.jp>
    Reported-by: Tyler Hicks <tyhicks@canonical.com>
    Tested-by: Tyler Hicks <tyhicks@canonical.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 510e1e8020a8a1b7cf53a84f18a7d03757daba55
Author: Sebastian Ott <sebott@linux.ibm.com>
Date:   Tue May 15 14:05:13 2018 +0200

    s390/dasd: use blk_mq_rq_from_pdu for per request data
    
    [ Upstream commit f0f59a2fab8e52b9d582b39da39f22230ca80aee ]
    
    Dasd uses completion_data from struct request to store per request
    private data - this is problematic since this member is part of a
    union which is also used by IO schedulers.
    Let the block layer maintain space for per request data behind each
    struct request.
    
    Fixes crashes on block layer timeouts like this one:
    
    Unable to handle kernel pointer dereference in virtual kernel address space
    Failing address: 0000000000000000 TEID: 0000000000000483
    Fault in home space mode while using kernel ASCE.
    AS:0000000001308007 R3:00000000fffc8007 S:00000000fffcc000 P:000000000000013d
    Oops: 0004 ilc:2 [#1] PREEMPT SMP
    Modules linked in: [...]
    CPU: 0 PID: 1480 Comm: kworker/0:2H Not tainted 4.17.0-rc4-00046-gaa3bcd43b5af #203
    Hardware name: IBM 3906 M02 702 (LPAR)
    Workqueue: kblockd blk_mq_timeout_work
    Krnl PSW : 0000000067ac406b 00000000b6960308 (do_raw_spin_trylock+0x30/0x78)
               R:0 T:1 IO:0 EX:0 Key:0 M:1 W:0 P:0 AS:3 CC:2 PM:0 RI:0 EA:3
    Krnl GPRS: 0000000000000c00 0000000000000000 0000000000000000 0000000000000001
               0000000000b9d3c8 0000000000000000 0000000000000001 00000000cf9639d8
               0000000000000000 0700000000000000 0000000000000000 000000000099f09e
               0000000000000000 000000000076e9d0 000000006247bb08 000000006247bae0
    Krnl Code: 00000000001c159c: b90400c2           lgr     %r12,%r2
               00000000001c15a0: a7180000           lhi     %r1,0
              #00000000001c15a4: 583003a4           l       %r3,932
              >00000000001c15a8: ba132000           cs      %r1,%r3,0(%r2)
               00000000001c15ac: a7180001           lhi     %r1,1
               00000000001c15b0: a784000b           brc     8,1c15c6
               00000000001c15b4: c0e5004e72aa       brasl   %r14,b8fb08
               00000000001c15ba: 1812               lr      %r1,%r2
    Call Trace:
    ([<0700000000000000>] 0x700000000000000)
     [<0000000000b9d3d2>] _raw_spin_lock_irqsave+0x7a/0xb8
     [<000000000099f09e>] dasd_times_out+0x46/0x278
     [<000000000076ea6e>] blk_mq_terminate_expired+0x9e/0x108
     [<000000000077497a>] bt_for_each+0x102/0x130
     [<0000000000774e54>] blk_mq_queue_tag_busy_iter+0x74/0xd8
     [<000000000076fea0>] blk_mq_timeout_work+0x260/0x320
     [<0000000000169dd4>] process_one_work+0x3bc/0x708
     [<000000000016a382>] worker_thread+0x262/0x408
     [<00000000001723a8>] kthread+0x160/0x178
     [<0000000000b9e73a>] kernel_thread_starter+0x6/0xc
     [<0000000000b9e734>] kernel_thread_starter+0x0/0xc
    INFO: lockdep is turned off.
    Last Breaking-Event-Address:
     [<0000000000b9d3cc>] _raw_spin_lock_irqsave+0x74/0xb8
    
    Kernel panic - not syncing: Fatal exception: panic_on_oops
    
    Signed-off-by: Sebastian Ott <sebott@linux.ibm.com>
    Reviewed-by: Stefan Haberland <sth@linux.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Signed-off-by: Sasha Levin <alexander.levin@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit a9203311e5bd6e8a8121a1df9f8b52c77d691c15
Author: Leon Romanovsky <leon@kernel.org>
Date:   Wed Mar 7 15:29:09 2018 +0200

    RDMA/mlx5: Fix integer overflow while resizing CQ
    
    commit 28e9091e3119933c38933cb8fc48d5618eb784c8 upstream.
    
    The user can provide very large cqe_size which will cause to integer
    overflow as it can be seen in the following UBSAN warning:
    
    =======================================================================
    UBSAN: Undefined behaviour in drivers/infiniband/hw/mlx5/cq.c:1192:53
    signed integer overflow:
    64870 * 65536 cannot be represented in type 'int'
    CPU: 0 PID: 267 Comm: syzkaller605279 Not tainted 4.15.0+ #90 Hardware
    name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS
    rel-1.7.5-0-ge51488c-20140602_164612-nilsson.home.kraxel.org 04/01/2014
    Call Trace:
     dump_stack+0xde/0x164
     ? dma_virt_map_sg+0x22c/0x22c
     ubsan_epilogue+0xe/0x81
     handle_overflow+0x1f3/0x251
     ? __ubsan_handle_negate_overflow+0x19b/0x19b
     ? lock_acquire+0x440/0x440
     mlx5_ib_resize_cq+0x17e7/0x1e40
     ? cyc2ns_read_end+0x10/0x10
     ? native_read_msr_safe+0x6c/0x9b
     ? cyc2ns_read_end+0x10/0x10
     ? mlx5_ib_modify_cq+0x220/0x220
     ? sched_clock_cpu+0x18/0x200
     ? lookup_get_idr_uobject+0x200/0x200
     ? rdma_lookup_get_uobject+0x145/0x2f0
     ib_uverbs_resize_cq+0x207/0x3e0
     ? ib_uverbs_ex_create_cq+0x250/0x250
     ib_uverbs_write+0x7f9/0xef0
     ? cyc2ns_read_end+0x10/0x10
     ? print_irqtrace_events+0x280/0x280
     ? ib_uverbs_ex_create_cq+0x250/0x250
     ? uverbs_devnode+0x110/0x110
     ? sched_clock_cpu+0x18/0x200
     ? do_raw_spin_trylock+0x100/0x100
     ? __lru_cache_add+0x16e/0x290
     __vfs_write+0x10d/0x700
     ? uverbs_devnode+0x110/0x110
     ? kernel_read+0x170/0x170
     ? sched_clock_cpu+0x18/0x200
     ? security_file_permission+0x93/0x260
     vfs_write+0x1b0/0x550
     SyS_write+0xc7/0x1a0
     ? SyS_read+0x1a0/0x1a0
     ? trace_hardirqs_on_thunk+0x1a/0x1c
     entry_SYSCALL_64_fastpath+0x1e/0x8b
    RIP: 0033:0x433549
    RSP: 002b:00007ffe63bd1ea8 EFLAGS: 00000217
    =======================================================================
    
    Cc: syzkaller <syzkaller@googlegroups.com>
    Fixes: bde51583f49b ("IB/mlx5: Add support for resize CQ")
    Reported-by: Noa Osherovich <noaos@mellanox.com>
    Reviewed-by: Yishai Hadas <yishaih@mellanox.com>
    Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
    Signed-off-by: Doug Ledford <dledford@redhat.com>
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit 003ad57484d9154db1ba93370a20c92d8356a61d
Author: Petr Machata <petrm@mellanox.com>
Date:   Thu May 17 16:36:15 2018 +0200

    net: ip6_gre: Fix headroom request in ip6erspan_tunnel_xmit()
    
    [ Upstream commit 5691484df961aff897d824bcc26cd1a2aa036b5b ]
    
    dev->needed_headroom is not primed until ip6_tnl_xmit(), so it starts
    out zero. Thus the call to skb_cow_head() fails to actually make sure
    there's enough headroom to push the ERSPAN headers to. That can lead to
    the panic cited below. (Reproducer below that).
    
    Fix by requesting either needed_headroom if already primed, or just the
    bare minimum needed for the header otherwise.
    
    [  190.703567] kernel BUG at net/core/skbuff.c:104!
    [  190.708384] invalid opcode: 0000 [#1] PREEMPT SMP KASAN PTI
    [  190.714007] Modules linked in: act_mirred cls_matchall ip6_gre ip6_tunnel tunnel6 gre sch_ingress vrf veth x86_pkg_temp_thermal mlx_platform nfsd e1000e leds_mlxcpld
    [  190.728975] CPU: 1 PID: 959 Comm: kworker/1:2 Not tainted 4.17.0-rc4-net_master-custom-139 #10
    [  190.737647] Hardware name: Mellanox Technologies Ltd. "MSN2410-CB2F"/"SA000874", BIOS 4.6.5 03/08/2016
    [  190.747006] Workqueue: ipv6_addrconf addrconf_dad_work
    [  190.752222] RIP: 0010:skb_panic+0xc3/0x100
    [  190.756358] RSP: 0018:ffff8801d54072f0 EFLAGS: 00010282
    [  190.761629] RAX: 0000000000000085 RBX: ffff8801c1a8ecc0 RCX: 0000000000000000
    [  190.768830] RDX: 0000000000000085 RSI: dffffc0000000000 RDI: ffffed003aa80e54
    [  190.776025] RBP: ffff8801bd1ec5a0 R08: ffffed003aabce19 R09: ffffed003aabce19
    [  190.783226] R10: 0000000000000001 R11: ffffed003aabce18 R12: ffff8801bf695dbe
    [  190.790418] R13: 0000000000000084 R14: 00000000000006c0 R15: ffff8801bf695dc8
    [  190.797621] FS:  0000000000000000(0000) GS:ffff8801d5400000(0000) knlGS:0000000000000000
    [  190.805786] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [  190.811582] CR2: 000055fa929aced0 CR3: 0000000003228004 CR4: 00000000001606e0
    [  190.818790] Call Trace:
    [  190.821264]  <IRQ>
    [  190.823314]  ? ip6erspan_tunnel_xmit+0x5e4/0x1982 [ip6_gre]
    [  190.828940]  ? ip6erspan_tunnel_xmit+0x5e4/0x1982 [ip6_gre]
    [  190.834562]  skb_push+0x78/0x90
    [  190.837749]  ip6erspan_tunnel_xmit+0x5e4/0x1982 [ip6_gre]
    [  190.843219]  ? ip6gre_tunnel_ioctl+0xd90/0xd90 [ip6_gre]
    [  190.848577]  ? debug_check_no_locks_freed+0x210/0x210
    [  190.853679]  ? debug_check_no_locks_freed+0x210/0x210
    [  190.858783]  ? print_irqtrace_events+0x120/0x120
    [  190.863451]  ? sched_clock_cpu+0x18/0x210
    [  190.867496]  ? cyc2ns_read_end+0x10/0x10
    [  190.871474]  ? skb_network_protocol+0x76/0x200
    [  190.875977]  dev_hard_start_xmit+0x137/0x770
    [  190.880317]  ? do_raw_spin_trylock+0x6d/0xa0
    [  190.884624]  sch_direct_xmit+0x2ef/0x5d0
    [  190.888589]  ? pfifo_fast_dequeue+0x3fa/0x670
    [  190.892994]  ? pfifo_fast_change_tx_queue_len+0x810/0x810
    [  190.898455]  ? __lock_is_held+0xa0/0x160
    [  190.902422]  __qdisc_run+0x39e/0xfc0
    [  190.906041]  ? _raw_spin_unlock+0x29/0x40
    [  190.910090]  ? pfifo_fast_enqueue+0x24b/0x3e0
    [  190.914501]  ? sch_direct_xmit+0x5d0/0x5d0
    [  190.918658]  ? pfifo_fast_dequeue+0x670/0x670
    [  190.923047]  ? __dev_queue_xmit+0x172/0x1770
    [  190.927365]  ? preempt_count_sub+0xf/0xd0
    [  190.931421]  __dev_queue_xmit+0x410/0x1770
    [  190.935553]  ? ___slab_alloc+0x605/0x930
    [  190.939524]  ? print_irqtrace_events+0x120/0x120
    [  190.944186]  ? memcpy+0x34/0x50
    [  190.947364]  ? netdev_pick_tx+0x1c0/0x1c0
    [  190.951428]  ? __skb_clone+0x2fd/0x3d0
    [  190.955218]  ? __copy_skb_header+0x270/0x270
    [  190.959537]  ? rcu_read_lock_sched_held+0x93/0xa0
    [  190.964282]  ? kmem_cache_alloc+0x344/0x4d0
    [  190.968520]  ? cyc2ns_read_end+0x10/0x10
    [  190.972495]  ? skb_clone+0x123/0x230
    [  190.976112]  ? skb_split+0x820/0x820
    [  190.979747]  ? tcf_mirred+0x554/0x930 [act_mirred]
    [  190.984582]  tcf_mirred+0x554/0x930 [act_mirred]
    [  190.989252]  ? tcf_mirred_act_wants_ingress.part.2+0x10/0x10 [act_mirred]
    [  190.996109]  ? __lock_acquire+0x706/0x26e0
    [  191.000239]  ? sched_clock_cpu+0x18/0x210
    [  191.004294]  tcf_action_exec+0xcf/0x2a0
    [  191.008179]  tcf_classify+0xfa/0x340
    [  191.011794]  __netif_receive_skb_core+0x8e1/0x1c60
    [  191.016630]  ? debug_check_no_locks_freed+0x210/0x210
    [  191.021732]  ? nf_ingress+0x500/0x500
    [  191.025458]  ? process_backlog+0x347/0x4b0
    [  191.029619]  ? print_irqtrace_events+0x120/0x120
    [  191.034302]  ? lock_acquire+0xd8/0x320
    [  191.038089]  ? process_backlog+0x1b6/0x4b0
    [  191.042246]  ? process_backlog+0xc2/0x4b0
    [  191.046303]  process_backlog+0xc2/0x4b0
    [  191.050189]  net_rx_action+0x5cc/0x980
    [  191.053991]  ? napi_complete_done+0x2c0/0x2c0
    [  191.058386]  ? mark_lock+0x13d/0xb40
    [  191.062001]  ? clockevents_program_event+0x6b/0x1d0
    [  191.066922]  ? print_irqtrace_events+0x120/0x120
    [  191.071593]  ? __lock_is_held+0xa0/0x160
    [  191.075566]  __do_softirq+0x1d4/0x9d2
    [  191.079282]  ? ip6_finish_output2+0x524/0x1460
    [  191.083771]  do_softirq_own_stack+0x2a/0x40
    [  191.087994]  </IRQ>
    [  191.090130]  do_softirq.part.13+0x38/0x40
    [  191.094178]  __local_bh_enable_ip+0x135/0x190
    [  191.098591]  ip6_finish_output2+0x54d/0x1460
    [  191.102916]  ? ip6_forward_finish+0x2f0/0x2f0
    [  191.107314]  ? ip6_mtu+0x3c/0x2c0
    [  191.110674]  ? ip6_finish_output+0x2f8/0x650
    [  191.114992]  ? ip6_output+0x12a/0x500
    [  191.118696]  ip6_output+0x12a/0x500
    [  191.122223]  ? ip6_route_dev_notify+0x5b0/0x5b0
    [  191.126807]  ? ip6_finish_output+0x650/0x650
    [  191.131120]  ? ip6_fragment+0x1a60/0x1a60
    [  191.135182]  ? icmp6_dst_alloc+0x26e/0x470
    [  191.139317]  mld_sendpack+0x672/0x830
    [  191.143021]  ? igmp6_mcf_seq_next+0x2f0/0x2f0
    [  191.147429]  ? __local_bh_enable_ip+0x77/0x190
    [  191.151913]  ipv6_mc_dad_complete+0x47/0x90
    [  191.156144]  addrconf_dad_completed+0x561/0x720
    [  191.160731]  ? addrconf_rs_timer+0x3a0/0x3a0
    [  191.165036]  ? mark_held_locks+0xc9/0x140
    [  191.169095]  ? __local_bh_enable_ip+0x77/0x190
    [  191.173570]  ? addrconf_dad_work+0x50d/0xa20
    [  191.177886]  ? addrconf_dad_work+0x529/0xa20
    [  191.182194]  addrconf_dad_work+0x529/0xa20
    [  191.186342]  ? addrconf_dad_completed+0x720/0x720
    [  191.191088]  ? __lock_is_held+0xa0/0x160
    [  191.195059]  ? process_one_work+0x45d/0xe20
    [  191.199302]  ? process_one_work+0x51e/0xe20
    [  191.203531]  ? rcu_read_lock_sched_held+0x93/0xa0
    [  191.208279]  process_one_work+0x51e/0xe20
    [  191.212340]  ? pwq_dec_nr_in_flight+0x200/0x200
    [  191.216912]  ? get_lock_stats+0x4b/0xf0
    [  191.220788]  ? preempt_count_sub+0xf/0xd0
    [  191.224844]  ? worker_thread+0x219/0x860
    [  191.228823]  ? do_raw_spin_trylock+0x6d/0xa0
    [  191.233142]  worker_thread+0xeb/0x860
    [  191.236848]  ? process_one_work+0xe20/0xe20
    [  191.241095]  kthread+0x206/0x300
    [  191.244352]  ? process_one_work+0xe20/0xe20
    [  191.248587]  ? kthread_stop+0x570/0x570
    [  191.252459]  ret_from_fork+0x3a/0x50
    [  191.256082] Code: 14 3e ff 8b 4b 78 55 4d 89 f9 41 56 41 55 48 c7 c7 a0 cf db 82 41 54 44 8b 44 24 2c 48 8b 54 24 30 48 8b 74 24 20 e8 16 94 13 ff <0f> 0b 48 c7 c7 60 8e 1f 85 48 83 c4 20 e8 55 ef a6 ff 89 74 24
    [  191.275327] RIP: skb_panic+0xc3/0x100 RSP: ffff8801d54072f0
    [  191.281024] ---[ end trace 7ea51094e099e006 ]---
    [  191.285724] Kernel panic - not syncing: Fatal exception in interrupt
    [  191.292168] Kernel Offset: disabled
    [  191.295697] ---[ end Kernel panic - not syncing: Fatal exception in interrupt ]---
    
    Reproducer:
    
            ip link add h1 type veth peer name swp1
            ip link add h3 type veth peer name swp3
    
            ip link set dev h1 up
            ip address add 192.0.2.1/28 dev h1
    
            ip link add dev vh3 type vrf table 20
            ip link set dev h3 master vh3
            ip link set dev vh3 up
            ip link set dev h3 up
    
            ip link set dev swp3 up
            ip address add dev swp3 2001:db8:2::1/64
    
            ip link set dev swp1 up
            tc qdisc add dev swp1 clsact
    
            ip link add name gt6 type ip6erspan \
                    local 2001:db8:2::1 remote 2001:db8:2::2 oseq okey 123
            ip link set dev gt6 up
    
            sleep 1
    
            tc filter add dev swp1 ingress pref 1000 matchall skip_hw \
                    action mirred egress mirror dev gt6
            ping -I h1 192.0.2.2
    
    Fixes: e41c7c68ea77 ("ip6erspan: make sure enough headroom at xmit.")
    Signed-off-by: Petr Machata <petrm@mellanox.com>
    Acked-by: William Tu <u9012063@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit f0f59a2fab8e52b9d582b39da39f22230ca80aee
Author: Sebastian Ott <sebott@linux.ibm.com>
Date:   Tue May 15 14:05:13 2018 +0200

    s390/dasd: use blk_mq_rq_from_pdu for per request data
    
    Dasd uses completion_data from struct request to store per request
    private data - this is problematic since this member is part of a
    union which is also used by IO schedulers.
    Let the block layer maintain space for per request data behind each
    struct request.
    
    Fixes crashes on block layer timeouts like this one:
    
    Unable to handle kernel pointer dereference in virtual kernel address space
    Failing address: 0000000000000000 TEID: 0000000000000483
    Fault in home space mode while using kernel ASCE.
    AS:0000000001308007 R3:00000000fffc8007 S:00000000fffcc000 P:000000000000013d
    Oops: 0004 ilc:2 [#1] PREEMPT SMP
    Modules linked in: [...]
    CPU: 0 PID: 1480 Comm: kworker/0:2H Not tainted 4.17.0-rc4-00046-gaa3bcd43b5af #203
    Hardware name: IBM 3906 M02 702 (LPAR)
    Workqueue: kblockd blk_mq_timeout_work
    Krnl PSW : 0000000067ac406b 00000000b6960308 (do_raw_spin_trylock+0x30/0x78)
               R:0 T:1 IO:0 EX:0 Key:0 M:1 W:0 P:0 AS:3 CC:2 PM:0 RI:0 EA:3
    Krnl GPRS: 0000000000000c00 0000000000000000 0000000000000000 0000000000000001
               0000000000b9d3c8 0000000000000000 0000000000000001 00000000cf9639d8
               0000000000000000 0700000000000000 0000000000000000 000000000099f09e
               0000000000000000 000000000076e9d0 000000006247bb08 000000006247bae0
    Krnl Code: 00000000001c159c: b90400c2           lgr     %r12,%r2
               00000000001c15a0: a7180000           lhi     %r1,0
              #00000000001c15a4: 583003a4           l       %r3,932
              >00000000001c15a8: ba132000           cs      %r1,%r3,0(%r2)
               00000000001c15ac: a7180001           lhi     %r1,1
               00000000001c15b0: a784000b           brc     8,1c15c6
               00000000001c15b4: c0e5004e72aa       brasl   %r14,b8fb08
               00000000001c15ba: 1812               lr      %r1,%r2
    Call Trace:
    ([<0700000000000000>] 0x700000000000000)
     [<0000000000b9d3d2>] _raw_spin_lock_irqsave+0x7a/0xb8
     [<000000000099f09e>] dasd_times_out+0x46/0x278
     [<000000000076ea6e>] blk_mq_terminate_expired+0x9e/0x108
     [<000000000077497a>] bt_for_each+0x102/0x130
     [<0000000000774e54>] blk_mq_queue_tag_busy_iter+0x74/0xd8
     [<000000000076fea0>] blk_mq_timeout_work+0x260/0x320
     [<0000000000169dd4>] process_one_work+0x3bc/0x708
     [<000000000016a382>] worker_thread+0x262/0x408
     [<00000000001723a8>] kthread+0x160/0x178
     [<0000000000b9e73a>] kernel_thread_starter+0x6/0xc
     [<0000000000b9e734>] kernel_thread_starter+0x0/0xc
    INFO: lockdep is turned off.
    Last Breaking-Event-Address:
     [<0000000000b9d3cc>] _raw_spin_lock_irqsave+0x74/0xb8
    
    Kernel panic - not syncing: Fatal exception: panic_on_oops
    
    Signed-off-by: Sebastian Ott <sebott@linux.ibm.com>
    Reviewed-by: Stefan Haberland <sth@linux.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

commit 5691484df961aff897d824bcc26cd1a2aa036b5b
Author: Petr Machata <petrm@mellanox.com>
Date:   Thu May 17 16:36:15 2018 +0200

    net: ip6_gre: Fix headroom request in ip6erspan_tunnel_xmit()
    
    dev->needed_headroom is not primed until ip6_tnl_xmit(), so it starts
    out zero. Thus the call to skb_cow_head() fails to actually make sure
    there's enough headroom to push the ERSPAN headers to. That can lead to
    the panic cited below. (Reproducer below that).
    
    Fix by requesting either needed_headroom if already primed, or just the
    bare minimum needed for the header otherwise.
    
    [  190.703567] kernel BUG at net/core/skbuff.c:104!
    [  190.708384] invalid opcode: 0000 [#1] PREEMPT SMP KASAN PTI
    [  190.714007] Modules linked in: act_mirred cls_matchall ip6_gre ip6_tunnel tunnel6 gre sch_ingress vrf veth x86_pkg_temp_thermal mlx_platform nfsd e1000e leds_mlxcpld
    [  190.728975] CPU: 1 PID: 959 Comm: kworker/1:2 Not tainted 4.17.0-rc4-net_master-custom-139 #10
    [  190.737647] Hardware name: Mellanox Technologies Ltd. "MSN2410-CB2F"/"SA000874", BIOS 4.6.5 03/08/2016
    [  190.747006] Workqueue: ipv6_addrconf addrconf_dad_work
    [  190.752222] RIP: 0010:skb_panic+0xc3/0x100
    [  190.756358] RSP: 0018:ffff8801d54072f0 EFLAGS: 00010282
    [  190.761629] RAX: 0000000000000085 RBX: ffff8801c1a8ecc0 RCX: 0000000000000000
    [  190.768830] RDX: 0000000000000085 RSI: dffffc0000000000 RDI: ffffed003aa80e54
    [  190.776025] RBP: ffff8801bd1ec5a0 R08: ffffed003aabce19 R09: ffffed003aabce19
    [  190.783226] R10: 0000000000000001 R11: ffffed003aabce18 R12: ffff8801bf695dbe
    [  190.790418] R13: 0000000000000084 R14: 00000000000006c0 R15: ffff8801bf695dc8
    [  190.797621] FS:  0000000000000000(0000) GS:ffff8801d5400000(0000) knlGS:0000000000000000
    [  190.805786] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [  190.811582] CR2: 000055fa929aced0 CR3: 0000000003228004 CR4: 00000000001606e0
    [  190.818790] Call Trace:
    [  190.821264]  <IRQ>
    [  190.823314]  ? ip6erspan_tunnel_xmit+0x5e4/0x1982 [ip6_gre]
    [  190.828940]  ? ip6erspan_tunnel_xmit+0x5e4/0x1982 [ip6_gre]
    [  190.834562]  skb_push+0x78/0x90
    [  190.837749]  ip6erspan_tunnel_xmit+0x5e4/0x1982 [ip6_gre]
    [  190.843219]  ? ip6gre_tunnel_ioctl+0xd90/0xd90 [ip6_gre]
    [  190.848577]  ? debug_check_no_locks_freed+0x210/0x210
    [  190.853679]  ? debug_check_no_locks_freed+0x210/0x210
    [  190.858783]  ? print_irqtrace_events+0x120/0x120
    [  190.863451]  ? sched_clock_cpu+0x18/0x210
    [  190.867496]  ? cyc2ns_read_end+0x10/0x10
    [  190.871474]  ? skb_network_protocol+0x76/0x200
    [  190.875977]  dev_hard_start_xmit+0x137/0x770
    [  190.880317]  ? do_raw_spin_trylock+0x6d/0xa0
    [  190.884624]  sch_direct_xmit+0x2ef/0x5d0
    [  190.888589]  ? pfifo_fast_dequeue+0x3fa/0x670
    [  190.892994]  ? pfifo_fast_change_tx_queue_len+0x810/0x810
    [  190.898455]  ? __lock_is_held+0xa0/0x160
    [  190.902422]  __qdisc_run+0x39e/0xfc0
    [  190.906041]  ? _raw_spin_unlock+0x29/0x40
    [  190.910090]  ? pfifo_fast_enqueue+0x24b/0x3e0
    [  190.914501]  ? sch_direct_xmit+0x5d0/0x5d0
    [  190.918658]  ? pfifo_fast_dequeue+0x670/0x670
    [  190.923047]  ? __dev_queue_xmit+0x172/0x1770
    [  190.927365]  ? preempt_count_sub+0xf/0xd0
    [  190.931421]  __dev_queue_xmit+0x410/0x1770
    [  190.935553]  ? ___slab_alloc+0x605/0x930
    [  190.939524]  ? print_irqtrace_events+0x120/0x120
    [  190.944186]  ? memcpy+0x34/0x50
    [  190.947364]  ? netdev_pick_tx+0x1c0/0x1c0
    [  190.951428]  ? __skb_clone+0x2fd/0x3d0
    [  190.955218]  ? __copy_skb_header+0x270/0x270
    [  190.959537]  ? rcu_read_lock_sched_held+0x93/0xa0
    [  190.964282]  ? kmem_cache_alloc+0x344/0x4d0
    [  190.968520]  ? cyc2ns_read_end+0x10/0x10
    [  190.972495]  ? skb_clone+0x123/0x230
    [  190.976112]  ? skb_split+0x820/0x820
    [  190.979747]  ? tcf_mirred+0x554/0x930 [act_mirred]
    [  190.984582]  tcf_mirred+0x554/0x930 [act_mirred]
    [  190.989252]  ? tcf_mirred_act_wants_ingress.part.2+0x10/0x10 [act_mirred]
    [  190.996109]  ? __lock_acquire+0x706/0x26e0
    [  191.000239]  ? sched_clock_cpu+0x18/0x210
    [  191.004294]  tcf_action_exec+0xcf/0x2a0
    [  191.008179]  tcf_classify+0xfa/0x340
    [  191.011794]  __netif_receive_skb_core+0x8e1/0x1c60
    [  191.016630]  ? debug_check_no_locks_freed+0x210/0x210
    [  191.021732]  ? nf_ingress+0x500/0x500
    [  191.025458]  ? process_backlog+0x347/0x4b0
    [  191.029619]  ? print_irqtrace_events+0x120/0x120
    [  191.034302]  ? lock_acquire+0xd8/0x320
    [  191.038089]  ? process_backlog+0x1b6/0x4b0
    [  191.042246]  ? process_backlog+0xc2/0x4b0
    [  191.046303]  process_backlog+0xc2/0x4b0
    [  191.050189]  net_rx_action+0x5cc/0x980
    [  191.053991]  ? napi_complete_done+0x2c0/0x2c0
    [  191.058386]  ? mark_lock+0x13d/0xb40
    [  191.062001]  ? clockevents_program_event+0x6b/0x1d0
    [  191.066922]  ? print_irqtrace_events+0x120/0x120
    [  191.071593]  ? __lock_is_held+0xa0/0x160
    [  191.075566]  __do_softirq+0x1d4/0x9d2
    [  191.079282]  ? ip6_finish_output2+0x524/0x1460
    [  191.083771]  do_softirq_own_stack+0x2a/0x40
    [  191.087994]  </IRQ>
    [  191.090130]  do_softirq.part.13+0x38/0x40
    [  191.094178]  __local_bh_enable_ip+0x135/0x190
    [  191.098591]  ip6_finish_output2+0x54d/0x1460
    [  191.102916]  ? ip6_forward_finish+0x2f0/0x2f0
    [  191.107314]  ? ip6_mtu+0x3c/0x2c0
    [  191.110674]  ? ip6_finish_output+0x2f8/0x650
    [  191.114992]  ? ip6_output+0x12a/0x500
    [  191.118696]  ip6_output+0x12a/0x500
    [  191.122223]  ? ip6_route_dev_notify+0x5b0/0x5b0
    [  191.126807]  ? ip6_finish_output+0x650/0x650
    [  191.131120]  ? ip6_fragment+0x1a60/0x1a60
    [  191.135182]  ? icmp6_dst_alloc+0x26e/0x470
    [  191.139317]  mld_sendpack+0x672/0x830
    [  191.143021]  ? igmp6_mcf_seq_next+0x2f0/0x2f0
    [  191.147429]  ? __local_bh_enable_ip+0x77/0x190
    [  191.151913]  ipv6_mc_dad_complete+0x47/0x90
    [  191.156144]  addrconf_dad_completed+0x561/0x720
    [  191.160731]  ? addrconf_rs_timer+0x3a0/0x3a0
    [  191.165036]  ? mark_held_locks+0xc9/0x140
    [  191.169095]  ? __local_bh_enable_ip+0x77/0x190
    [  191.173570]  ? addrconf_dad_work+0x50d/0xa20
    [  191.177886]  ? addrconf_dad_work+0x529/0xa20
    [  191.182194]  addrconf_dad_work+0x529/0xa20
    [  191.186342]  ? addrconf_dad_completed+0x720/0x720
    [  191.191088]  ? __lock_is_held+0xa0/0x160
    [  191.195059]  ? process_one_work+0x45d/0xe20
    [  191.199302]  ? process_one_work+0x51e/0xe20
    [  191.203531]  ? rcu_read_lock_sched_held+0x93/0xa0
    [  191.208279]  process_one_work+0x51e/0xe20
    [  191.212340]  ? pwq_dec_nr_in_flight+0x200/0x200
    [  191.216912]  ? get_lock_stats+0x4b/0xf0
    [  191.220788]  ? preempt_count_sub+0xf/0xd0
    [  191.224844]  ? worker_thread+0x219/0x860
    [  191.228823]  ? do_raw_spin_trylock+0x6d/0xa0
    [  191.233142]  worker_thread+0xeb/0x860
    [  191.236848]  ? process_one_work+0xe20/0xe20
    [  191.241095]  kthread+0x206/0x300
    [  191.244352]  ? process_one_work+0xe20/0xe20
    [  191.248587]  ? kthread_stop+0x570/0x570
    [  191.252459]  ret_from_fork+0x3a/0x50
    [  191.256082] Code: 14 3e ff 8b 4b 78 55 4d 89 f9 41 56 41 55 48 c7 c7 a0 cf db 82 41 54 44 8b 44 24 2c 48 8b 54 24 30 48 8b 74 24 20 e8 16 94 13 ff <0f> 0b 48 c7 c7 60 8e 1f 85 48 83 c4 20 e8 55 ef a6 ff 89 74 24
    [  191.275327] RIP: skb_panic+0xc3/0x100 RSP: ffff8801d54072f0
    [  191.281024] ---[ end trace 7ea51094e099e006 ]---
    [  191.285724] Kernel panic - not syncing: Fatal exception in interrupt
    [  191.292168] Kernel Offset: disabled
    [  191.295697] ---[ end Kernel panic - not syncing: Fatal exception in interrupt ]---
    
    Reproducer:
    
            ip link add h1 type veth peer name swp1
            ip link add h3 type veth peer name swp3
    
            ip link set dev h1 up
            ip address add 192.0.2.1/28 dev h1
    
            ip link add dev vh3 type vrf table 20
            ip link set dev h3 master vh3
            ip link set dev vh3 up
            ip link set dev h3 up
    
            ip link set dev swp3 up
            ip address add dev swp3 2001:db8:2::1/64
    
            ip link set dev swp1 up
            tc qdisc add dev swp1 clsact
    
            ip link add name gt6 type ip6erspan \
                    local 2001:db8:2::1 remote 2001:db8:2::2 oseq okey 123
            ip link set dev gt6 up
    
            sleep 1
    
            tc filter add dev swp1 ingress pref 1000 matchall skip_hw \
                    action mirred egress mirror dev gt6
            ping -I h1 192.0.2.2
    
    Fixes: e41c7c68ea77 ("ip6erspan: make sure enough headroom at xmit.")
    Signed-off-by: Petr Machata <petrm@mellanox.com>
    Acked-by: William Tu <u9012063@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit b951ffb160f765db6b06b9ee065f79faed5fa9e1
Author: Prashant Bhole <bhole_prashant_q7@lab.ntt.co.jp>
Date:   Mon Apr 9 19:03:46 2018 +0900

    perf/core: Fix use-after-free in uprobe_perf_close()
    
    commit 621b6d2ea297d0fb6030452c5bcd221f12165fcf upstream.
    
    A use-after-free bug was caught by KASAN while running usdt related
    code (BCC project. bcc/tests/python/test_usdt2.py):
    
            ==================================================================
            BUG: KASAN: use-after-free in uprobe_perf_close+0x222/0x3b0
            Read of size 4 at addr ffff880384f9b4a4 by task test_usdt2.py/870
    
            CPU: 4 PID: 870 Comm: test_usdt2.py Tainted: G        W         4.16.0-next-20180409 #215
            Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Ubuntu-1.8.2-1ubuntu1 04/01/2014
            Call Trace:
             dump_stack+0xc7/0x15b
             ? show_regs_print_info+0x5/0x5
             ? printk+0x9c/0xc3
             ? kmsg_dump_rewind_nolock+0x6e/0x6e
             ? uprobe_perf_close+0x222/0x3b0
             print_address_description+0x83/0x3a0
             ? uprobe_perf_close+0x222/0x3b0
             kasan_report+0x1dd/0x460
             ? uprobe_perf_close+0x222/0x3b0
             uprobe_perf_close+0x222/0x3b0
             ? probes_open+0x180/0x180
             ? free_filters_list+0x290/0x290
             trace_uprobe_register+0x1bb/0x500
             ? perf_event_attach_bpf_prog+0x310/0x310
             ? probe_event_disable+0x4e0/0x4e0
             perf_uprobe_destroy+0x63/0xd0
             _free_event+0x2bc/0xbd0
             ? lockdep_rcu_suspicious+0x100/0x100
             ? ring_buffer_attach+0x550/0x550
             ? kvm_sched_clock_read+0x1a/0x30
             ? perf_event_release_kernel+0x3e4/0xc00
             ? __mutex_unlock_slowpath+0x12e/0x540
             ? wait_for_completion+0x430/0x430
             ? lock_downgrade+0x3c0/0x3c0
             ? lock_release+0x980/0x980
             ? do_raw_spin_trylock+0x118/0x150
             ? do_raw_spin_unlock+0x121/0x210
             ? do_raw_spin_trylock+0x150/0x150
             perf_event_release_kernel+0x5d4/0xc00
             ? put_event+0x30/0x30
             ? fsnotify+0xd2d/0xea0
             ? sched_clock_cpu+0x18/0x1a0
             ? __fsnotify_update_child_dentry_flags.part.0+0x1b0/0x1b0
             ? pvclock_clocksource_read+0x152/0x2b0
             ? pvclock_read_flags+0x80/0x80
             ? kvm_sched_clock_read+0x1a/0x30
             ? sched_clock_cpu+0x18/0x1a0
             ? pvclock_clocksource_read+0x152/0x2b0
             ? locks_remove_file+0xec/0x470
             ? pvclock_read_flags+0x80/0x80
             ? fcntl_setlk+0x880/0x880
             ? ima_file_free+0x8d/0x390
             ? lockdep_rcu_suspicious+0x100/0x100
             ? ima_file_check+0x110/0x110
             ? fsnotify+0xea0/0xea0
             ? kvm_sched_clock_read+0x1a/0x30
             ? rcu_note_context_switch+0x600/0x600
             perf_release+0x21/0x40
             __fput+0x264/0x620
             ? fput+0xf0/0xf0
             ? do_raw_spin_unlock+0x121/0x210
             ? do_raw_spin_trylock+0x150/0x150
             ? SyS_fchdir+0x100/0x100
             ? fsnotify+0xea0/0xea0
             task_work_run+0x14b/0x1e0
             ? task_work_cancel+0x1c0/0x1c0
             ? copy_fd_bitmaps+0x150/0x150
             ? vfs_read+0xe5/0x260
             exit_to_usermode_loop+0x17b/0x1b0
             ? trace_event_raw_event_sys_exit+0x1a0/0x1a0
             do_syscall_64+0x3f6/0x490
             ? syscall_return_slowpath+0x2c0/0x2c0
             ? lockdep_sys_exit+0x1f/0xaa
             ? syscall_return_slowpath+0x1a3/0x2c0
             ? lockdep_sys_exit+0x1f/0xaa
             ? prepare_exit_to_usermode+0x11c/0x1e0
             ? enter_from_user_mode+0x30/0x30
            random: crng init done
             ? __put_user_4+0x1c/0x30
             entry_SYSCALL_64_after_hwframe+0x3d/0xa2
            RIP: 0033:0x7f41d95f9340
            RSP: 002b:00007fffe71e4268 EFLAGS: 00000246 ORIG_RAX: 0000000000000003
            RAX: 0000000000000000 RBX: 000000000000000d RCX: 00007f41d95f9340
            RDX: 0000000000000000 RSI: 0000000000002401 RDI: 000000000000000d
            RBP: 0000000000000000 R08: 00007f41ca8ff700 R09: 00007f41d996dd1f
            R10: 00007fffe71e41e0 R11: 0000000000000246 R12: 00007fffe71e4330
            R13: 0000000000000000 R14: fffffffffffffffc R15: 00007fffe71e4290
    
            Allocated by task 870:
             kasan_kmalloc+0xa0/0xd0
             kmem_cache_alloc_node+0x11a/0x430
             copy_process.part.19+0x11a0/0x41c0
             _do_fork+0x1be/0xa20
             do_syscall_64+0x198/0x490
             entry_SYSCALL_64_after_hwframe+0x3d/0xa2
    
            Freed by task 0:
             __kasan_slab_free+0x12e/0x180
             kmem_cache_free+0x102/0x4d0
             free_task+0xfe/0x160
             __put_task_struct+0x189/0x290
             delayed_put_task_struct+0x119/0x250
             rcu_process_callbacks+0xa6c/0x1b60
             __do_softirq+0x238/0x7ae
    
            The buggy address belongs to the object at ffff880384f9b480
             which belongs to the cache task_struct of size 12928
    
    It occurs because task_struct is freed before perf_event which refers
    to the task and task flags are checked while teardown of the event.
    perf_event_alloc() assigns task_struct to hw.target of perf_event,
    but there is no reference counting for it.
    
    As a fix we get_task_struct() in perf_event_alloc() at above mentioned
    assignment and put_task_struct() in _free_event().
    
    Signed-off-by: Prashant Bhole <bhole_prashant_q7@lab.ntt.co.jp>
    Reviewed-by: Oleg Nesterov <oleg@redhat.com>
    Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: <stable@kernel.org>
    Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Cc: Arnaldo Carvalho de Melo <acme@kernel.org>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Fixes: 63b6da39bb38e8f1a1ef3180d32a39d6 ("perf: Fix perf_event_exit_task() race")
    Link: http://lkml.kernel.org/r/20180409100346.6416-1-bhole_prashant_q7@lab.ntt.co.jp
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 6f22be4ba787eb76abbf66aad14b4d60ec59e641
Author: Prashant Bhole <bhole_prashant_q7@lab.ntt.co.jp>
Date:   Mon Apr 9 19:03:46 2018 +0900

    perf/core: Fix use-after-free in uprobe_perf_close()
    
    commit 621b6d2ea297d0fb6030452c5bcd221f12165fcf upstream.
    
    A use-after-free bug was caught by KASAN while running usdt related
    code (BCC project. bcc/tests/python/test_usdt2.py):
    
            ==================================================================
            BUG: KASAN: use-after-free in uprobe_perf_close+0x222/0x3b0
            Read of size 4 at addr ffff880384f9b4a4 by task test_usdt2.py/870
    
            CPU: 4 PID: 870 Comm: test_usdt2.py Tainted: G        W         4.16.0-next-20180409 #215
            Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Ubuntu-1.8.2-1ubuntu1 04/01/2014
            Call Trace:
             dump_stack+0xc7/0x15b
             ? show_regs_print_info+0x5/0x5
             ? printk+0x9c/0xc3
             ? kmsg_dump_rewind_nolock+0x6e/0x6e
             ? uprobe_perf_close+0x222/0x3b0
             print_address_description+0x83/0x3a0
             ? uprobe_perf_close+0x222/0x3b0
             kasan_report+0x1dd/0x460
             ? uprobe_perf_close+0x222/0x3b0
             uprobe_perf_close+0x222/0x3b0
             ? probes_open+0x180/0x180
             ? free_filters_list+0x290/0x290
             trace_uprobe_register+0x1bb/0x500
             ? perf_event_attach_bpf_prog+0x310/0x310
             ? probe_event_disable+0x4e0/0x4e0
             perf_uprobe_destroy+0x63/0xd0
             _free_event+0x2bc/0xbd0
             ? lockdep_rcu_suspicious+0x100/0x100
             ? ring_buffer_attach+0x550/0x550
             ? kvm_sched_clock_read+0x1a/0x30
             ? perf_event_release_kernel+0x3e4/0xc00
             ? __mutex_unlock_slowpath+0x12e/0x540
             ? wait_for_completion+0x430/0x430
             ? lock_downgrade+0x3c0/0x3c0
             ? lock_release+0x980/0x980
             ? do_raw_spin_trylock+0x118/0x150
             ? do_raw_spin_unlock+0x121/0x210
             ? do_raw_spin_trylock+0x150/0x150
             perf_event_release_kernel+0x5d4/0xc00
             ? put_event+0x30/0x30
             ? fsnotify+0xd2d/0xea0
             ? sched_clock_cpu+0x18/0x1a0
             ? __fsnotify_update_child_dentry_flags.part.0+0x1b0/0x1b0
             ? pvclock_clocksource_read+0x152/0x2b0
             ? pvclock_read_flags+0x80/0x80
             ? kvm_sched_clock_read+0x1a/0x30
             ? sched_clock_cpu+0x18/0x1a0
             ? pvclock_clocksource_read+0x152/0x2b0
             ? locks_remove_file+0xec/0x470
             ? pvclock_read_flags+0x80/0x80
             ? fcntl_setlk+0x880/0x880
             ? ima_file_free+0x8d/0x390
             ? lockdep_rcu_suspicious+0x100/0x100
             ? ima_file_check+0x110/0x110
             ? fsnotify+0xea0/0xea0
             ? kvm_sched_clock_read+0x1a/0x30
             ? rcu_note_context_switch+0x600/0x600
             perf_release+0x21/0x40
             __fput+0x264/0x620
             ? fput+0xf0/0xf0
             ? do_raw_spin_unlock+0x121/0x210
             ? do_raw_spin_trylock+0x150/0x150
             ? SyS_fchdir+0x100/0x100
             ? fsnotify+0xea0/0xea0
             task_work_run+0x14b/0x1e0
             ? task_work_cancel+0x1c0/0x1c0
             ? copy_fd_bitmaps+0x150/0x150
             ? vfs_read+0xe5/0x260
             exit_to_usermode_loop+0x17b/0x1b0
             ? trace_event_raw_event_sys_exit+0x1a0/0x1a0
             do_syscall_64+0x3f6/0x490
             ? syscall_return_slowpath+0x2c0/0x2c0
             ? lockdep_sys_exit+0x1f/0xaa
             ? syscall_return_slowpath+0x1a3/0x2c0
             ? lockdep_sys_exit+0x1f/0xaa
             ? prepare_exit_to_usermode+0x11c/0x1e0
             ? enter_from_user_mode+0x30/0x30
            random: crng init done
             ? __put_user_4+0x1c/0x30
             entry_SYSCALL_64_after_hwframe+0x3d/0xa2
            RIP: 0033:0x7f41d95f9340
            RSP: 002b:00007fffe71e4268 EFLAGS: 00000246 ORIG_RAX: 0000000000000003
            RAX: 0000000000000000 RBX: 000000000000000d RCX: 00007f41d95f9340
            RDX: 0000000000000000 RSI: 0000000000002401 RDI: 000000000000000d
            RBP: 0000000000000000 R08: 00007f41ca8ff700 R09: 00007f41d996dd1f
            R10: 00007fffe71e41e0 R11: 0000000000000246 R12: 00007fffe71e4330
            R13: 0000000000000000 R14: fffffffffffffffc R15: 00007fffe71e4290
    
            Allocated by task 870:
             kasan_kmalloc+0xa0/0xd0
             kmem_cache_alloc_node+0x11a/0x430
             copy_process.part.19+0x11a0/0x41c0
             _do_fork+0x1be/0xa20
             do_syscall_64+0x198/0x490
             entry_SYSCALL_64_after_hwframe+0x3d/0xa2
    
            Freed by task 0:
             __kasan_slab_free+0x12e/0x180
             kmem_cache_free+0x102/0x4d0
             free_task+0xfe/0x160
             __put_task_struct+0x189/0x290
             delayed_put_task_struct+0x119/0x250
             rcu_process_callbacks+0xa6c/0x1b60
             __do_softirq+0x238/0x7ae
    
            The buggy address belongs to the object at ffff880384f9b480
             which belongs to the cache task_struct of size 12928
    
    It occurs because task_struct is freed before perf_event which refers
    to the task and task flags are checked while teardown of the event.
    perf_event_alloc() assigns task_struct to hw.target of perf_event,
    but there is no reference counting for it.
    
    As a fix we get_task_struct() in perf_event_alloc() at above mentioned
    assignment and put_task_struct() in _free_event().
    
    Signed-off-by: Prashant Bhole <bhole_prashant_q7@lab.ntt.co.jp>
    Reviewed-by: Oleg Nesterov <oleg@redhat.com>
    Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: <stable@kernel.org>
    Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Cc: Arnaldo Carvalho de Melo <acme@kernel.org>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Fixes: 63b6da39bb38e8f1a1ef3180d32a39d6 ("perf: Fix perf_event_exit_task() race")
    Link: http://lkml.kernel.org/r/20180409100346.6416-1-bhole_prashant_q7@lab.ntt.co.jp
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit ab0ed342375f15e4316e7295e661125596b654ae
Author: Prashant Bhole <bhole_prashant_q7@lab.ntt.co.jp>
Date:   Mon Apr 9 19:03:46 2018 +0900

    perf/core: Fix use-after-free in uprobe_perf_close()
    
    commit 621b6d2ea297d0fb6030452c5bcd221f12165fcf upstream.
    
    A use-after-free bug was caught by KASAN while running usdt related
    code (BCC project. bcc/tests/python/test_usdt2.py):
    
            ==================================================================
            BUG: KASAN: use-after-free in uprobe_perf_close+0x222/0x3b0
            Read of size 4 at addr ffff880384f9b4a4 by task test_usdt2.py/870
    
            CPU: 4 PID: 870 Comm: test_usdt2.py Tainted: G        W         4.16.0-next-20180409 #215
            Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Ubuntu-1.8.2-1ubuntu1 04/01/2014
            Call Trace:
             dump_stack+0xc7/0x15b
             ? show_regs_print_info+0x5/0x5
             ? printk+0x9c/0xc3
             ? kmsg_dump_rewind_nolock+0x6e/0x6e
             ? uprobe_perf_close+0x222/0x3b0
             print_address_description+0x83/0x3a0
             ? uprobe_perf_close+0x222/0x3b0
             kasan_report+0x1dd/0x460
             ? uprobe_perf_close+0x222/0x3b0
             uprobe_perf_close+0x222/0x3b0
             ? probes_open+0x180/0x180
             ? free_filters_list+0x290/0x290
             trace_uprobe_register+0x1bb/0x500
             ? perf_event_attach_bpf_prog+0x310/0x310
             ? probe_event_disable+0x4e0/0x4e0
             perf_uprobe_destroy+0x63/0xd0
             _free_event+0x2bc/0xbd0
             ? lockdep_rcu_suspicious+0x100/0x100
             ? ring_buffer_attach+0x550/0x550
             ? kvm_sched_clock_read+0x1a/0x30
             ? perf_event_release_kernel+0x3e4/0xc00
             ? __mutex_unlock_slowpath+0x12e/0x540
             ? wait_for_completion+0x430/0x430
             ? lock_downgrade+0x3c0/0x3c0
             ? lock_release+0x980/0x980
             ? do_raw_spin_trylock+0x118/0x150
             ? do_raw_spin_unlock+0x121/0x210
             ? do_raw_spin_trylock+0x150/0x150
             perf_event_release_kernel+0x5d4/0xc00
             ? put_event+0x30/0x30
             ? fsnotify+0xd2d/0xea0
             ? sched_clock_cpu+0x18/0x1a0
             ? __fsnotify_update_child_dentry_flags.part.0+0x1b0/0x1b0
             ? pvclock_clocksource_read+0x152/0x2b0
             ? pvclock_read_flags+0x80/0x80
             ? kvm_sched_clock_read+0x1a/0x30
             ? sched_clock_cpu+0x18/0x1a0
             ? pvclock_clocksource_read+0x152/0x2b0
             ? locks_remove_file+0xec/0x470
             ? pvclock_read_flags+0x80/0x80
             ? fcntl_setlk+0x880/0x880
             ? ima_file_free+0x8d/0x390
             ? lockdep_rcu_suspicious+0x100/0x100
             ? ima_file_check+0x110/0x110
             ? fsnotify+0xea0/0xea0
             ? kvm_sched_clock_read+0x1a/0x30
             ? rcu_note_context_switch+0x600/0x600
             perf_release+0x21/0x40
             __fput+0x264/0x620
             ? fput+0xf0/0xf0
             ? do_raw_spin_unlock+0x121/0x210
             ? do_raw_spin_trylock+0x150/0x150
             ? SyS_fchdir+0x100/0x100
             ? fsnotify+0xea0/0xea0
             task_work_run+0x14b/0x1e0
             ? task_work_cancel+0x1c0/0x1c0
             ? copy_fd_bitmaps+0x150/0x150
             ? vfs_read+0xe5/0x260
             exit_to_usermode_loop+0x17b/0x1b0
             ? trace_event_raw_event_sys_exit+0x1a0/0x1a0
             do_syscall_64+0x3f6/0x490
             ? syscall_return_slowpath+0x2c0/0x2c0
             ? lockdep_sys_exit+0x1f/0xaa
             ? syscall_return_slowpath+0x1a3/0x2c0
             ? lockdep_sys_exit+0x1f/0xaa
             ? prepare_exit_to_usermode+0x11c/0x1e0
             ? enter_from_user_mode+0x30/0x30
            random: crng init done
             ? __put_user_4+0x1c/0x30
             entry_SYSCALL_64_after_hwframe+0x3d/0xa2
            RIP: 0033:0x7f41d95f9340
            RSP: 002b:00007fffe71e4268 EFLAGS: 00000246 ORIG_RAX: 0000000000000003
            RAX: 0000000000000000 RBX: 000000000000000d RCX: 00007f41d95f9340
            RDX: 0000000000000000 RSI: 0000000000002401 RDI: 000000000000000d
            RBP: 0000000000000000 R08: 00007f41ca8ff700 R09: 00007f41d996dd1f
            R10: 00007fffe71e41e0 R11: 0000000000000246 R12: 00007fffe71e4330
            R13: 0000000000000000 R14: fffffffffffffffc R15: 00007fffe71e4290
    
            Allocated by task 870:
             kasan_kmalloc+0xa0/0xd0
             kmem_cache_alloc_node+0x11a/0x430
             copy_process.part.19+0x11a0/0x41c0
             _do_fork+0x1be/0xa20
             do_syscall_64+0x198/0x490
             entry_SYSCALL_64_after_hwframe+0x3d/0xa2
    
            Freed by task 0:
             __kasan_slab_free+0x12e/0x180
             kmem_cache_free+0x102/0x4d0
             free_task+0xfe/0x160
             __put_task_struct+0x189/0x290
             delayed_put_task_struct+0x119/0x250
             rcu_process_callbacks+0xa6c/0x1b60
             __do_softirq+0x238/0x7ae
    
            The buggy address belongs to the object at ffff880384f9b480
             which belongs to the cache task_struct of size 12928
    
    It occurs because task_struct is freed before perf_event which refers
    to the task and task flags are checked while teardown of the event.
    perf_event_alloc() assigns task_struct to hw.target of perf_event,
    but there is no reference counting for it.
    
    As a fix we get_task_struct() in perf_event_alloc() at above mentioned
    assignment and put_task_struct() in _free_event().
    
    Signed-off-by: Prashant Bhole <bhole_prashant_q7@lab.ntt.co.jp>
    Reviewed-by: Oleg Nesterov <oleg@redhat.com>
    Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: <stable@kernel.org>
    Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Cc: Arnaldo Carvalho de Melo <acme@kernel.org>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Fixes: 63b6da39bb38e8f1a1ef3180d32a39d6 ("perf: Fix perf_event_exit_task() race")
    Link: http://lkml.kernel.org/r/20180409100346.6416-1-bhole_prashant_q7@lab.ntt.co.jp
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 122a80f16ee6d8bb3cd4e3b81a9bf32cda2ba61d
Author: Prashant Bhole <bhole_prashant_q7@lab.ntt.co.jp>
Date:   Mon Apr 9 19:03:46 2018 +0900

    perf/core: Fix use-after-free in uprobe_perf_close()
    
    commit 621b6d2ea297d0fb6030452c5bcd221f12165fcf upstream.
    
    A use-after-free bug was caught by KASAN while running usdt related
    code (BCC project. bcc/tests/python/test_usdt2.py):
    
            ==================================================================
            BUG: KASAN: use-after-free in uprobe_perf_close+0x222/0x3b0
            Read of size 4 at addr ffff880384f9b4a4 by task test_usdt2.py/870
    
            CPU: 4 PID: 870 Comm: test_usdt2.py Tainted: G        W         4.16.0-next-20180409 #215
            Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Ubuntu-1.8.2-1ubuntu1 04/01/2014
            Call Trace:
             dump_stack+0xc7/0x15b
             ? show_regs_print_info+0x5/0x5
             ? printk+0x9c/0xc3
             ? kmsg_dump_rewind_nolock+0x6e/0x6e
             ? uprobe_perf_close+0x222/0x3b0
             print_address_description+0x83/0x3a0
             ? uprobe_perf_close+0x222/0x3b0
             kasan_report+0x1dd/0x460
             ? uprobe_perf_close+0x222/0x3b0
             uprobe_perf_close+0x222/0x3b0
             ? probes_open+0x180/0x180
             ? free_filters_list+0x290/0x290
             trace_uprobe_register+0x1bb/0x500
             ? perf_event_attach_bpf_prog+0x310/0x310
             ? probe_event_disable+0x4e0/0x4e0
             perf_uprobe_destroy+0x63/0xd0
             _free_event+0x2bc/0xbd0
             ? lockdep_rcu_suspicious+0x100/0x100
             ? ring_buffer_attach+0x550/0x550
             ? kvm_sched_clock_read+0x1a/0x30
             ? perf_event_release_kernel+0x3e4/0xc00
             ? __mutex_unlock_slowpath+0x12e/0x540
             ? wait_for_completion+0x430/0x430
             ? lock_downgrade+0x3c0/0x3c0
             ? lock_release+0x980/0x980
             ? do_raw_spin_trylock+0x118/0x150
             ? do_raw_spin_unlock+0x121/0x210
             ? do_raw_spin_trylock+0x150/0x150
             perf_event_release_kernel+0x5d4/0xc00
             ? put_event+0x30/0x30
             ? fsnotify+0xd2d/0xea0
             ? sched_clock_cpu+0x18/0x1a0
             ? __fsnotify_update_child_dentry_flags.part.0+0x1b0/0x1b0
             ? pvclock_clocksource_read+0x152/0x2b0
             ? pvclock_read_flags+0x80/0x80
             ? kvm_sched_clock_read+0x1a/0x30
             ? sched_clock_cpu+0x18/0x1a0
             ? pvclock_clocksource_read+0x152/0x2b0
             ? locks_remove_file+0xec/0x470
             ? pvclock_read_flags+0x80/0x80
             ? fcntl_setlk+0x880/0x880
             ? ima_file_free+0x8d/0x390
             ? lockdep_rcu_suspicious+0x100/0x100
             ? ima_file_check+0x110/0x110
             ? fsnotify+0xea0/0xea0
             ? kvm_sched_clock_read+0x1a/0x30
             ? rcu_note_context_switch+0x600/0x600
             perf_release+0x21/0x40
             __fput+0x264/0x620
             ? fput+0xf0/0xf0
             ? do_raw_spin_unlock+0x121/0x210
             ? do_raw_spin_trylock+0x150/0x150
             ? SyS_fchdir+0x100/0x100
             ? fsnotify+0xea0/0xea0
             task_work_run+0x14b/0x1e0
             ? task_work_cancel+0x1c0/0x1c0
             ? copy_fd_bitmaps+0x150/0x150
             ? vfs_read+0xe5/0x260
             exit_to_usermode_loop+0x17b/0x1b0
             ? trace_event_raw_event_sys_exit+0x1a0/0x1a0
             do_syscall_64+0x3f6/0x490
             ? syscall_return_slowpath+0x2c0/0x2c0
             ? lockdep_sys_exit+0x1f/0xaa
             ? syscall_return_slowpath+0x1a3/0x2c0
             ? lockdep_sys_exit+0x1f/0xaa
             ? prepare_exit_to_usermode+0x11c/0x1e0
             ? enter_from_user_mode+0x30/0x30
            random: crng init done
             ? __put_user_4+0x1c/0x30
             entry_SYSCALL_64_after_hwframe+0x3d/0xa2
            RIP: 0033:0x7f41d95f9340
            RSP: 002b:00007fffe71e4268 EFLAGS: 00000246 ORIG_RAX: 0000000000000003
            RAX: 0000000000000000 RBX: 000000000000000d RCX: 00007f41d95f9340
            RDX: 0000000000000000 RSI: 0000000000002401 RDI: 000000000000000d
            RBP: 0000000000000000 R08: 00007f41ca8ff700 R09: 00007f41d996dd1f
            R10: 00007fffe71e41e0 R11: 0000000000000246 R12: 00007fffe71e4330
            R13: 0000000000000000 R14: fffffffffffffffc R15: 00007fffe71e4290
    
            Allocated by task 870:
             kasan_kmalloc+0xa0/0xd0
             kmem_cache_alloc_node+0x11a/0x430
             copy_process.part.19+0x11a0/0x41c0
             _do_fork+0x1be/0xa20
             do_syscall_64+0x198/0x490
             entry_SYSCALL_64_after_hwframe+0x3d/0xa2
    
            Freed by task 0:
             __kasan_slab_free+0x12e/0x180
             kmem_cache_free+0x102/0x4d0
             free_task+0xfe/0x160
             __put_task_struct+0x189/0x290
             delayed_put_task_struct+0x119/0x250
             rcu_process_callbacks+0xa6c/0x1b60
             __do_softirq+0x238/0x7ae
    
            The buggy address belongs to the object at ffff880384f9b480
             which belongs to the cache task_struct of size 12928
    
    It occurs because task_struct is freed before perf_event which refers
    to the task and task flags are checked while teardown of the event.
    perf_event_alloc() assigns task_struct to hw.target of perf_event,
    but there is no reference counting for it.
    
    As a fix we get_task_struct() in perf_event_alloc() at above mentioned
    assignment and put_task_struct() in _free_event().
    
    Signed-off-by: Prashant Bhole <bhole_prashant_q7@lab.ntt.co.jp>
    Reviewed-by: Oleg Nesterov <oleg@redhat.com>
    Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: <stable@kernel.org>
    Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Cc: Arnaldo Carvalho de Melo <acme@kernel.org>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Fixes: 63b6da39bb38e8f1a1ef3180d32a39d6 ("perf: Fix perf_event_exit_task() race")
    Link: http://lkml.kernel.org/r/20180409100346.6416-1-bhole_prashant_q7@lab.ntt.co.jp
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 621b6d2ea297d0fb6030452c5bcd221f12165fcf
Author: Prashant Bhole <bhole_prashant_q7@lab.ntt.co.jp>
Date:   Mon Apr 9 19:03:46 2018 +0900

    perf/core: Fix use-after-free in uprobe_perf_close()
    
    A use-after-free bug was caught by KASAN while running usdt related
    code (BCC project. bcc/tests/python/test_usdt2.py):
    
            ==================================================================
            BUG: KASAN: use-after-free in uprobe_perf_close+0x222/0x3b0
            Read of size 4 at addr ffff880384f9b4a4 by task test_usdt2.py/870
    
            CPU: 4 PID: 870 Comm: test_usdt2.py Tainted: G        W         4.16.0-next-20180409 #215
            Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Ubuntu-1.8.2-1ubuntu1 04/01/2014
            Call Trace:
             dump_stack+0xc7/0x15b
             ? show_regs_print_info+0x5/0x5
             ? printk+0x9c/0xc3
             ? kmsg_dump_rewind_nolock+0x6e/0x6e
             ? uprobe_perf_close+0x222/0x3b0
             print_address_description+0x83/0x3a0
             ? uprobe_perf_close+0x222/0x3b0
             kasan_report+0x1dd/0x460
             ? uprobe_perf_close+0x222/0x3b0
             uprobe_perf_close+0x222/0x3b0
             ? probes_open+0x180/0x180
             ? free_filters_list+0x290/0x290
             trace_uprobe_register+0x1bb/0x500
             ? perf_event_attach_bpf_prog+0x310/0x310
             ? probe_event_disable+0x4e0/0x4e0
             perf_uprobe_destroy+0x63/0xd0
             _free_event+0x2bc/0xbd0
             ? lockdep_rcu_suspicious+0x100/0x100
             ? ring_buffer_attach+0x550/0x550
             ? kvm_sched_clock_read+0x1a/0x30
             ? perf_event_release_kernel+0x3e4/0xc00
             ? __mutex_unlock_slowpath+0x12e/0x540
             ? wait_for_completion+0x430/0x430
             ? lock_downgrade+0x3c0/0x3c0
             ? lock_release+0x980/0x980
             ? do_raw_spin_trylock+0x118/0x150
             ? do_raw_spin_unlock+0x121/0x210
             ? do_raw_spin_trylock+0x150/0x150
             perf_event_release_kernel+0x5d4/0xc00
             ? put_event+0x30/0x30
             ? fsnotify+0xd2d/0xea0
             ? sched_clock_cpu+0x18/0x1a0
             ? __fsnotify_update_child_dentry_flags.part.0+0x1b0/0x1b0
             ? pvclock_clocksource_read+0x152/0x2b0
             ? pvclock_read_flags+0x80/0x80
             ? kvm_sched_clock_read+0x1a/0x30
             ? sched_clock_cpu+0x18/0x1a0
             ? pvclock_clocksource_read+0x152/0x2b0
             ? locks_remove_file+0xec/0x470
             ? pvclock_read_flags+0x80/0x80
             ? fcntl_setlk+0x880/0x880
             ? ima_file_free+0x8d/0x390
             ? lockdep_rcu_suspicious+0x100/0x100
             ? ima_file_check+0x110/0x110
             ? fsnotify+0xea0/0xea0
             ? kvm_sched_clock_read+0x1a/0x30
             ? rcu_note_context_switch+0x600/0x600
             perf_release+0x21/0x40
             __fput+0x264/0x620
             ? fput+0xf0/0xf0
             ? do_raw_spin_unlock+0x121/0x210
             ? do_raw_spin_trylock+0x150/0x150
             ? SyS_fchdir+0x100/0x100
             ? fsnotify+0xea0/0xea0
             task_work_run+0x14b/0x1e0
             ? task_work_cancel+0x1c0/0x1c0
             ? copy_fd_bitmaps+0x150/0x150
             ? vfs_read+0xe5/0x260
             exit_to_usermode_loop+0x17b/0x1b0
             ? trace_event_raw_event_sys_exit+0x1a0/0x1a0
             do_syscall_64+0x3f6/0x490
             ? syscall_return_slowpath+0x2c0/0x2c0
             ? lockdep_sys_exit+0x1f/0xaa
             ? syscall_return_slowpath+0x1a3/0x2c0
             ? lockdep_sys_exit+0x1f/0xaa
             ? prepare_exit_to_usermode+0x11c/0x1e0
             ? enter_from_user_mode+0x30/0x30
            random: crng init done
             ? __put_user_4+0x1c/0x30
             entry_SYSCALL_64_after_hwframe+0x3d/0xa2
            RIP: 0033:0x7f41d95f9340
            RSP: 002b:00007fffe71e4268 EFLAGS: 00000246 ORIG_RAX: 0000000000000003
            RAX: 0000000000000000 RBX: 000000000000000d RCX: 00007f41d95f9340
            RDX: 0000000000000000 RSI: 0000000000002401 RDI: 000000000000000d
            RBP: 0000000000000000 R08: 00007f41ca8ff700 R09: 00007f41d996dd1f
            R10: 00007fffe71e41e0 R11: 0000000000000246 R12: 00007fffe71e4330
            R13: 0000000000000000 R14: fffffffffffffffc R15: 00007fffe71e4290
    
            Allocated by task 870:
             kasan_kmalloc+0xa0/0xd0
             kmem_cache_alloc_node+0x11a/0x430
             copy_process.part.19+0x11a0/0x41c0
             _do_fork+0x1be/0xa20
             do_syscall_64+0x198/0x490
             entry_SYSCALL_64_after_hwframe+0x3d/0xa2
    
            Freed by task 0:
             __kasan_slab_free+0x12e/0x180
             kmem_cache_free+0x102/0x4d0
             free_task+0xfe/0x160
             __put_task_struct+0x189/0x290
             delayed_put_task_struct+0x119/0x250
             rcu_process_callbacks+0xa6c/0x1b60
             __do_softirq+0x238/0x7ae
    
            The buggy address belongs to the object at ffff880384f9b480
             which belongs to the cache task_struct of size 12928
    
    It occurs because task_struct is freed before perf_event which refers
    to the task and task flags are checked while teardown of the event.
    perf_event_alloc() assigns task_struct to hw.target of perf_event,
    but there is no reference counting for it.
    
    As a fix we get_task_struct() in perf_event_alloc() at above mentioned
    assignment and put_task_struct() in _free_event().
    
    Signed-off-by: Prashant Bhole <bhole_prashant_q7@lab.ntt.co.jp>
    Reviewed-by: Oleg Nesterov <oleg@redhat.com>
    Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: <stable@kernel.org>
    Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Cc: Arnaldo Carvalho de Melo <acme@kernel.org>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Fixes: 63b6da39bb38e8f1a1ef3180d32a39d6 ("perf: Fix perf_event_exit_task() race")
    Link: http://lkml.kernel.org/r/20180409100346.6416-1-bhole_prashant_q7@lab.ntt.co.jp
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 3563289208ecef339853692ecbf8690084744b53
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Fri Mar 16 14:37:33 2018 -0300

    perf annotate: Use the default annotation options for --stdio2
    
    With an empty '[annotate]' section in ~/.perfconfig:
    
      # perf record -a --all-kernel -e '{cycles,instructions}:P' sleep 5
      [ perf record: Woken up 1 times to write data ]
      [ perf record: Captured and wrote 2.243 MB perf.data (5513 samples) ]
      # perf annotate --stdio2 _raw_spin_lock | head -20
    
                         Disassembly of section .text:
    
                         ffffffff81868790 <_raw_spin_lock>:
                         _raw_spin_lock():
                         EXPORT_SYMBOL(_raw_spin_trylock_bh);
                         #endif
    
                         #ifndef CONFIG_INLINE_SPIN_LOCK
                         void __lockfunc _raw_spin_lock(raw_spinlock_t *lock)
                         {
                          callq  __fentry__
                         atomic_cmpxchg():
                                 return xadd(&v->counter, -i);
                         }
    
                         static __always_inline int atomic_cmpxchg(atomic_t *v, int old, int new)
                         {
      # perf annotate --stdio2 _raw_spin_lock | head -20
                          callq  __fentry__
                           xor    %eax,%eax
                           mov    $0x1,%edx
       87.50 100.00        lock   cmpxchg %edx,(%rdi)
        6.25   0.00        test   %eax,%eax
                          jne    16
        6.25   0.00        repz   retq
                     16:   mov    %eax,%esi
                          jmpq   ffffffff810e96b0 <queued_spin_lock_slowpath>
      #
      # cat ~/.perfconfig
      [annotate]
    
        hide_src_code = false
        show_linenr = true
      # perf annotate --stdio2 _raw_spin_lock | head -20
    
                     3   Disassembly of section .text:
    
                     5   ffffffff81868790 <_raw_spin_lock>:
                     6   _raw_spin_lock():
                     143 EXPORT_SYMBOL(_raw_spin_trylock_bh);
                     144 #endif
    
                     146 #ifndef CONFIG_INLINE_SPIN_LOCK
                     147 void __lockfunc _raw_spin_lock(raw_spinlock_t *lock)
                     148 {
                          callq  __fentry__
                     150 atomic_cmpxchg():
                     187         return xadd(&v->counter, -i);
                     188 }
    
                     190 static __always_inline int atomic_cmpxchg(atomic_t *v, int old, int new)
                     191 {
      #
      # cat ~/.perfconfig
      [annotate]
    
        hide_src_code = true
        show_total_period = true
      # perf annotate --stdio2 _raw_spin_lock | head -20
                                    callq  __fentry__
                                     xor    %eax,%eax
                                     mov    $0x1,%edx
          1411316      152339        lock   cmpxchg %edx,(%rdi)
           344694           0        test   %eax,%eax
                                    jne    16
            80806           0        repz   retq
                               16:   mov    %eax,%esi
                                    jmpq   ffffffff810e96b0 <queued_spin_lock_slowpath>
      #
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Andi Kleen <ak@linux.intel.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Jin Yao <yao.jin@linux.intel.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Wang Nan <wangnan0@huawei.com>
    Link: https://lkml.kernel.org/n/tip-nu4rxg5zkdtgs1b2gc40p7v7@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

commit 1bb454527e18b04437c41b2b4dfe31678fb4146d
Author: Leon Romanovsky <leon@kernel.org>
Date:   Wed Mar 7 15:29:09 2018 +0200

    RDMA/mlx5: Fix integer overflow while resizing CQ
    
    commit 28e9091e3119933c38933cb8fc48d5618eb784c8 upstream.
    
    The user can provide very large cqe_size which will cause to integer
    overflow as it can be seen in the following UBSAN warning:
    
    =======================================================================
    UBSAN: Undefined behaviour in drivers/infiniband/hw/mlx5/cq.c:1192:53
    signed integer overflow:
    64870 * 65536 cannot be represented in type 'int'
    CPU: 0 PID: 267 Comm: syzkaller605279 Not tainted 4.15.0+ #90 Hardware
    name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS
    rel-1.7.5-0-ge51488c-20140602_164612-nilsson.home.kraxel.org 04/01/2014
    Call Trace:
     dump_stack+0xde/0x164
     ? dma_virt_map_sg+0x22c/0x22c
     ubsan_epilogue+0xe/0x81
     handle_overflow+0x1f3/0x251
     ? __ubsan_handle_negate_overflow+0x19b/0x19b
     ? lock_acquire+0x440/0x440
     mlx5_ib_resize_cq+0x17e7/0x1e40
     ? cyc2ns_read_end+0x10/0x10
     ? native_read_msr_safe+0x6c/0x9b
     ? cyc2ns_read_end+0x10/0x10
     ? mlx5_ib_modify_cq+0x220/0x220
     ? sched_clock_cpu+0x18/0x200
     ? lookup_get_idr_uobject+0x200/0x200
     ? rdma_lookup_get_uobject+0x145/0x2f0
     ib_uverbs_resize_cq+0x207/0x3e0
     ? ib_uverbs_ex_create_cq+0x250/0x250
     ib_uverbs_write+0x7f9/0xef0
     ? cyc2ns_read_end+0x10/0x10
     ? print_irqtrace_events+0x280/0x280
     ? ib_uverbs_ex_create_cq+0x250/0x250
     ? uverbs_devnode+0x110/0x110
     ? sched_clock_cpu+0x18/0x200
     ? do_raw_spin_trylock+0x100/0x100
     ? __lru_cache_add+0x16e/0x290
     __vfs_write+0x10d/0x700
     ? uverbs_devnode+0x110/0x110
     ? kernel_read+0x170/0x170
     ? sched_clock_cpu+0x18/0x200
     ? security_file_permission+0x93/0x260
     vfs_write+0x1b0/0x550
     SyS_write+0xc7/0x1a0
     ? SyS_read+0x1a0/0x1a0
     ? trace_hardirqs_on_thunk+0x1a/0x1c
     entry_SYSCALL_64_fastpath+0x1e/0x8b
    RIP: 0033:0x433549
    RSP: 002b:00007ffe63bd1ea8 EFLAGS: 00000217
    =======================================================================
    
    Cc: syzkaller <syzkaller@googlegroups.com>
    Cc: <stable@vger.kernel.org> # 3.13
    Fixes: bde51583f49b ("IB/mlx5: Add support for resize CQ")
    Reported-by: Noa Osherovich <noaos@mellanox.com>
    Reviewed-by: Yishai Hadas <yishaih@mellanox.com>
    Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
    Signed-off-by: Doug Ledford <dledford@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 6f8b6627f367d040877afd44635b867109c142e9
Author: Leon Romanovsky <leon@kernel.org>
Date:   Wed Mar 7 15:29:09 2018 +0200

    RDMA/mlx5: Fix integer overflow while resizing CQ
    
    commit 28e9091e3119933c38933cb8fc48d5618eb784c8 upstream.
    
    The user can provide very large cqe_size which will cause to integer
    overflow as it can be seen in the following UBSAN warning:
    
    =======================================================================
    UBSAN: Undefined behaviour in drivers/infiniband/hw/mlx5/cq.c:1192:53
    signed integer overflow:
    64870 * 65536 cannot be represented in type 'int'
    CPU: 0 PID: 267 Comm: syzkaller605279 Not tainted 4.15.0+ #90 Hardware
    name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS
    rel-1.7.5-0-ge51488c-20140602_164612-nilsson.home.kraxel.org 04/01/2014
    Call Trace:
     dump_stack+0xde/0x164
     ? dma_virt_map_sg+0x22c/0x22c
     ubsan_epilogue+0xe/0x81
     handle_overflow+0x1f3/0x251
     ? __ubsan_handle_negate_overflow+0x19b/0x19b
     ? lock_acquire+0x440/0x440
     mlx5_ib_resize_cq+0x17e7/0x1e40
     ? cyc2ns_read_end+0x10/0x10
     ? native_read_msr_safe+0x6c/0x9b
     ? cyc2ns_read_end+0x10/0x10
     ? mlx5_ib_modify_cq+0x220/0x220
     ? sched_clock_cpu+0x18/0x200
     ? lookup_get_idr_uobject+0x200/0x200
     ? rdma_lookup_get_uobject+0x145/0x2f0
     ib_uverbs_resize_cq+0x207/0x3e0
     ? ib_uverbs_ex_create_cq+0x250/0x250
     ib_uverbs_write+0x7f9/0xef0
     ? cyc2ns_read_end+0x10/0x10
     ? print_irqtrace_events+0x280/0x280
     ? ib_uverbs_ex_create_cq+0x250/0x250
     ? uverbs_devnode+0x110/0x110
     ? sched_clock_cpu+0x18/0x200
     ? do_raw_spin_trylock+0x100/0x100
     ? __lru_cache_add+0x16e/0x290
     __vfs_write+0x10d/0x700
     ? uverbs_devnode+0x110/0x110
     ? kernel_read+0x170/0x170
     ? sched_clock_cpu+0x18/0x200
     ? security_file_permission+0x93/0x260
     vfs_write+0x1b0/0x550
     SyS_write+0xc7/0x1a0
     ? SyS_read+0x1a0/0x1a0
     ? trace_hardirqs_on_thunk+0x1a/0x1c
     entry_SYSCALL_64_fastpath+0x1e/0x8b
    RIP: 0033:0x433549
    RSP: 002b:00007ffe63bd1ea8 EFLAGS: 00000217
    =======================================================================
    
    Cc: syzkaller <syzkaller@googlegroups.com>
    Cc: <stable@vger.kernel.org> # 3.13
    Fixes: bde51583f49b ("IB/mlx5: Add support for resize CQ")
    Reported-by: Noa Osherovich <noaos@mellanox.com>
    Reviewed-by: Yishai Hadas <yishaih@mellanox.com>
    Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
    Signed-off-by: Doug Ledford <dledford@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 45c0604dbeae88a00d773473dd0f3532257b9fd6
Author: Leon Romanovsky <leon@kernel.org>
Date:   Wed Mar 7 15:29:09 2018 +0200

    RDMA/mlx5: Fix integer overflow while resizing CQ
    
    commit 28e9091e3119933c38933cb8fc48d5618eb784c8 upstream.
    
    The user can provide very large cqe_size which will cause to integer
    overflow as it can be seen in the following UBSAN warning:
    
    =======================================================================
    UBSAN: Undefined behaviour in drivers/infiniband/hw/mlx5/cq.c:1192:53
    signed integer overflow:
    64870 * 65536 cannot be represented in type 'int'
    CPU: 0 PID: 267 Comm: syzkaller605279 Not tainted 4.15.0+ #90 Hardware
    name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS
    rel-1.7.5-0-ge51488c-20140602_164612-nilsson.home.kraxel.org 04/01/2014
    Call Trace:
     dump_stack+0xde/0x164
     ? dma_virt_map_sg+0x22c/0x22c
     ubsan_epilogue+0xe/0x81
     handle_overflow+0x1f3/0x251
     ? __ubsan_handle_negate_overflow+0x19b/0x19b
     ? lock_acquire+0x440/0x440
     mlx5_ib_resize_cq+0x17e7/0x1e40
     ? cyc2ns_read_end+0x10/0x10
     ? native_read_msr_safe+0x6c/0x9b
     ? cyc2ns_read_end+0x10/0x10
     ? mlx5_ib_modify_cq+0x220/0x220
     ? sched_clock_cpu+0x18/0x200
     ? lookup_get_idr_uobject+0x200/0x200
     ? rdma_lookup_get_uobject+0x145/0x2f0
     ib_uverbs_resize_cq+0x207/0x3e0
     ? ib_uverbs_ex_create_cq+0x250/0x250
     ib_uverbs_write+0x7f9/0xef0
     ? cyc2ns_read_end+0x10/0x10
     ? print_irqtrace_events+0x280/0x280
     ? ib_uverbs_ex_create_cq+0x250/0x250
     ? uverbs_devnode+0x110/0x110
     ? sched_clock_cpu+0x18/0x200
     ? do_raw_spin_trylock+0x100/0x100
     ? __lru_cache_add+0x16e/0x290
     __vfs_write+0x10d/0x700
     ? uverbs_devnode+0x110/0x110
     ? kernel_read+0x170/0x170
     ? sched_clock_cpu+0x18/0x200
     ? security_file_permission+0x93/0x260
     vfs_write+0x1b0/0x550
     SyS_write+0xc7/0x1a0
     ? SyS_read+0x1a0/0x1a0
     ? trace_hardirqs_on_thunk+0x1a/0x1c
     entry_SYSCALL_64_fastpath+0x1e/0x8b
    RIP: 0033:0x433549
    RSP: 002b:00007ffe63bd1ea8 EFLAGS: 00000217
    =======================================================================
    
    Cc: syzkaller <syzkaller@googlegroups.com>
    Cc: <stable@vger.kernel.org> # 3.13
    Fixes: bde51583f49b ("IB/mlx5: Add support for resize CQ")
    Reported-by: Noa Osherovich <noaos@mellanox.com>
    Reviewed-by: Yishai Hadas <yishaih@mellanox.com>
    Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
    Signed-off-by: Doug Ledford <dledford@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit dbfed071633c27242eba0fe710d396168fd2dba7
Author: Leon Romanovsky <leon@kernel.org>
Date:   Wed Mar 7 15:29:09 2018 +0200

    RDMA/mlx5: Fix integer overflow while resizing CQ
    
    commit 28e9091e3119933c38933cb8fc48d5618eb784c8 upstream.
    
    The user can provide very large cqe_size which will cause to integer
    overflow as it can be seen in the following UBSAN warning:
    
    =======================================================================
    UBSAN: Undefined behaviour in drivers/infiniband/hw/mlx5/cq.c:1192:53
    signed integer overflow:
    64870 * 65536 cannot be represented in type 'int'
    CPU: 0 PID: 267 Comm: syzkaller605279 Not tainted 4.15.0+ #90 Hardware
    name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS
    rel-1.7.5-0-ge51488c-20140602_164612-nilsson.home.kraxel.org 04/01/2014
    Call Trace:
     dump_stack+0xde/0x164
     ? dma_virt_map_sg+0x22c/0x22c
     ubsan_epilogue+0xe/0x81
     handle_overflow+0x1f3/0x251
     ? __ubsan_handle_negate_overflow+0x19b/0x19b
     ? lock_acquire+0x440/0x440
     mlx5_ib_resize_cq+0x17e7/0x1e40
     ? cyc2ns_read_end+0x10/0x10
     ? native_read_msr_safe+0x6c/0x9b
     ? cyc2ns_read_end+0x10/0x10
     ? mlx5_ib_modify_cq+0x220/0x220
     ? sched_clock_cpu+0x18/0x200
     ? lookup_get_idr_uobject+0x200/0x200
     ? rdma_lookup_get_uobject+0x145/0x2f0
     ib_uverbs_resize_cq+0x207/0x3e0
     ? ib_uverbs_ex_create_cq+0x250/0x250
     ib_uverbs_write+0x7f9/0xef0
     ? cyc2ns_read_end+0x10/0x10
     ? print_irqtrace_events+0x280/0x280
     ? ib_uverbs_ex_create_cq+0x250/0x250
     ? uverbs_devnode+0x110/0x110
     ? sched_clock_cpu+0x18/0x200
     ? do_raw_spin_trylock+0x100/0x100
     ? __lru_cache_add+0x16e/0x290
     __vfs_write+0x10d/0x700
     ? uverbs_devnode+0x110/0x110
     ? kernel_read+0x170/0x170
     ? sched_clock_cpu+0x18/0x200
     ? security_file_permission+0x93/0x260
     vfs_write+0x1b0/0x550
     SyS_write+0xc7/0x1a0
     ? SyS_read+0x1a0/0x1a0
     ? trace_hardirqs_on_thunk+0x1a/0x1c
     entry_SYSCALL_64_fastpath+0x1e/0x8b
    RIP: 0033:0x433549
    RSP: 002b:00007ffe63bd1ea8 EFLAGS: 00000217
    =======================================================================
    
    Cc: syzkaller <syzkaller@googlegroups.com>
    Cc: <stable@vger.kernel.org> # 3.13
    Fixes: bde51583f49b ("IB/mlx5: Add support for resize CQ")
    Reported-by: Noa Osherovich <noaos@mellanox.com>
    Reviewed-by: Yishai Hadas <yishaih@mellanox.com>
    Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
    Signed-off-by: Doug Ledford <dledford@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 28e9091e3119933c38933cb8fc48d5618eb784c8
Author: Leon Romanovsky <leon@kernel.org>
Date:   Wed Mar 7 15:29:09 2018 +0200

    RDMA/mlx5: Fix integer overflow while resizing CQ
    
    The user can provide very large cqe_size which will cause to integer
    overflow as it can be seen in the following UBSAN warning:
    
    =======================================================================
    UBSAN: Undefined behaviour in drivers/infiniband/hw/mlx5/cq.c:1192:53
    signed integer overflow:
    64870 * 65536 cannot be represented in type 'int'
    CPU: 0 PID: 267 Comm: syzkaller605279 Not tainted 4.15.0+ #90 Hardware
    name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS
    rel-1.7.5-0-ge51488c-20140602_164612-nilsson.home.kraxel.org 04/01/2014
    Call Trace:
     dump_stack+0xde/0x164
     ? dma_virt_map_sg+0x22c/0x22c
     ubsan_epilogue+0xe/0x81
     handle_overflow+0x1f3/0x251
     ? __ubsan_handle_negate_overflow+0x19b/0x19b
     ? lock_acquire+0x440/0x440
     mlx5_ib_resize_cq+0x17e7/0x1e40
     ? cyc2ns_read_end+0x10/0x10
     ? native_read_msr_safe+0x6c/0x9b
     ? cyc2ns_read_end+0x10/0x10
     ? mlx5_ib_modify_cq+0x220/0x220
     ? sched_clock_cpu+0x18/0x200
     ? lookup_get_idr_uobject+0x200/0x200
     ? rdma_lookup_get_uobject+0x145/0x2f0
     ib_uverbs_resize_cq+0x207/0x3e0
     ? ib_uverbs_ex_create_cq+0x250/0x250
     ib_uverbs_write+0x7f9/0xef0
     ? cyc2ns_read_end+0x10/0x10
     ? print_irqtrace_events+0x280/0x280
     ? ib_uverbs_ex_create_cq+0x250/0x250
     ? uverbs_devnode+0x110/0x110
     ? sched_clock_cpu+0x18/0x200
     ? do_raw_spin_trylock+0x100/0x100
     ? __lru_cache_add+0x16e/0x290
     __vfs_write+0x10d/0x700
     ? uverbs_devnode+0x110/0x110
     ? kernel_read+0x170/0x170
     ? sched_clock_cpu+0x18/0x200
     ? security_file_permission+0x93/0x260
     vfs_write+0x1b0/0x550
     SyS_write+0xc7/0x1a0
     ? SyS_read+0x1a0/0x1a0
     ? trace_hardirqs_on_thunk+0x1a/0x1c
     entry_SYSCALL_64_fastpath+0x1e/0x8b
    RIP: 0033:0x433549
    RSP: 002b:00007ffe63bd1ea8 EFLAGS: 00000217
    =======================================================================
    
    Cc: syzkaller <syzkaller@googlegroups.com>
    Cc: <stable@vger.kernel.org> # 3.13
    Fixes: bde51583f49b ("IB/mlx5: Add support for resize CQ")
    Reported-by: Noa Osherovich <noaos@mellanox.com>
    Reviewed-by: Yishai Hadas <yishaih@mellanox.com>
    Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
    Signed-off-by: Doug Ledford <dledford@redhat.com>

commit 58cea8e8f1c09cb52fdbe3915f7bf2014dd2ecb0
Author: Paolo Abeni <pabeni@redhat.com>
Date:   Mon Feb 5 22:23:01 2018 +0100

    cls_u32: fix use after free in u32_destroy_key()
    
    
    [ Upstream commit d7cdee5ea8d28ae1b6922deb0c1badaa3aa0ef8c ]
    
    Li Shuang reported an Oops with cls_u32 due to an use-after-free
    in u32_destroy_key(). The use-after-free can be triggered with:
    
    dev=lo
    tc qdisc add dev $dev root handle 1: htb default 10
    tc filter add dev $dev parent 1: prio 5 handle 1: protocol ip u32 divisor 256
    tc filter add dev $dev protocol ip parent 1: prio 5 u32 ht 800:: match ip dst\
     10.0.0.0/8 hashkey mask 0x0000ff00 at 16 link 1:
    tc qdisc del dev $dev root
    
    Which causes the following kasan splat:
    
     ==================================================================
     BUG: KASAN: use-after-free in u32_destroy_key.constprop.21+0x117/0x140 [cls_u32]
     Read of size 4 at addr ffff881b83dae618 by task kworker/u48:5/571
    
     CPU: 17 PID: 571 Comm: kworker/u48:5 Not tainted 4.15.0+ #87
     Hardware name: Dell Inc. PowerEdge R730/072T6D, BIOS 2.1.7 06/16/2016
     Workqueue: tc_filter_workqueue u32_delete_key_freepf_work [cls_u32]
     Call Trace:
      dump_stack+0xd6/0x182
      ? dma_virt_map_sg+0x22e/0x22e
      print_address_description+0x73/0x290
      kasan_report+0x277/0x360
      ? u32_destroy_key.constprop.21+0x117/0x140 [cls_u32]
      u32_destroy_key.constprop.21+0x117/0x140 [cls_u32]
      u32_delete_key_freepf_work+0x1c/0x30 [cls_u32]
      process_one_work+0xae0/0x1c80
      ? sched_clock+0x5/0x10
      ? pwq_dec_nr_in_flight+0x3c0/0x3c0
      ? _raw_spin_unlock_irq+0x29/0x40
      ? trace_hardirqs_on_caller+0x381/0x570
      ? _raw_spin_unlock_irq+0x29/0x40
      ? finish_task_switch+0x1e5/0x760
      ? finish_task_switch+0x208/0x760
      ? preempt_notifier_dec+0x20/0x20
      ? __schedule+0x839/0x1ee0
      ? check_noncircular+0x20/0x20
      ? firmware_map_remove+0x73/0x73
      ? find_held_lock+0x39/0x1c0
      ? worker_thread+0x434/0x1820
      ? lock_contended+0xee0/0xee0
      ? lock_release+0x1100/0x1100
      ? init_rescuer.part.16+0x150/0x150
      ? retint_kernel+0x10/0x10
      worker_thread+0x216/0x1820
      ? process_one_work+0x1c80/0x1c80
      ? lock_acquire+0x1a5/0x540
      ? lock_downgrade+0x6b0/0x6b0
      ? sched_clock+0x5/0x10
      ? lock_release+0x1100/0x1100
      ? compat_start_thread+0x80/0x80
      ? do_raw_spin_trylock+0x190/0x190
      ? _raw_spin_unlock_irq+0x29/0x40
      ? trace_hardirqs_on_caller+0x381/0x570
      ? _raw_spin_unlock_irq+0x29/0x40
      ? finish_task_switch+0x1e5/0x760
      ? finish_task_switch+0x208/0x760
      ? preempt_notifier_dec+0x20/0x20
      ? __schedule+0x839/0x1ee0
      ? kmem_cache_alloc_trace+0x143/0x320
      ? firmware_map_remove+0x73/0x73
      ? sched_clock+0x5/0x10
      ? sched_clock_cpu+0x18/0x170
      ? find_held_lock+0x39/0x1c0
      ? schedule+0xf3/0x3b0
      ? lock_downgrade+0x6b0/0x6b0
      ? __schedule+0x1ee0/0x1ee0
      ? do_wait_intr_irq+0x340/0x340
      ? do_raw_spin_trylock+0x190/0x190
      ? _raw_spin_unlock_irqrestore+0x32/0x60
      ? process_one_work+0x1c80/0x1c80
      ? process_one_work+0x1c80/0x1c80
      kthread+0x312/0x3d0
      ? kthread_create_worker_on_cpu+0xc0/0xc0
      ret_from_fork+0x3a/0x50
    
     Allocated by task 1688:
      kasan_kmalloc+0xa0/0xd0
      __kmalloc+0x162/0x380
      u32_change+0x1220/0x3c9e [cls_u32]
      tc_ctl_tfilter+0x1ba6/0x2f80
      rtnetlink_rcv_msg+0x4f0/0x9d0
      netlink_rcv_skb+0x124/0x320
      netlink_unicast+0x430/0x600
      netlink_sendmsg+0x8fa/0xd60
      sock_sendmsg+0xb1/0xe0
      ___sys_sendmsg+0x678/0x980
      __sys_sendmsg+0xc4/0x210
      do_syscall_64+0x232/0x7f0
      return_from_SYSCALL_64+0x0/0x75
    
     Freed by task 112:
      kasan_slab_free+0x71/0xc0
      kfree+0x114/0x320
      rcu_process_callbacks+0xc3f/0x1600
      __do_softirq+0x2bf/0xc06
    
     The buggy address belongs to the object at ffff881b83dae600
      which belongs to the cache kmalloc-4096 of size 4096
     The buggy address is located 24 bytes inside of
      4096-byte region [ffff881b83dae600, ffff881b83daf600)
     The buggy address belongs to the page:
     page:ffffea006e0f6a00 count:1 mapcount:0 mapping:          (null) index:0x0 compound_mapcount: 0
     flags: 0x17ffffc0008100(slab|head)
     raw: 0017ffffc0008100 0000000000000000 0000000000000000 0000000100070007
     raw: dead000000000100 dead000000000200 ffff880187c0e600 0000000000000000
     page dumped because: kasan: bad access detected
    
     Memory state around the buggy address:
      ffff881b83dae500: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
      ffff881b83dae580: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
     >ffff881b83dae600: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
                                 ^
      ffff881b83dae680: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
      ffff881b83dae700: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
     ==================================================================
    
    The problem is that the htnode is freed before the linked knodes and the
    latter will try to access the first at u32_destroy_key() time.
    This change addresses the issue using the htnode refcnt to guarantee
    the correct free order. While at it also add a RCU annotation,
    to keep sparse happy.
    
    v1 -> v2: use rtnl_derefence() instead of RCU read locks
    v2 -> v3:
      - don't check refcnt in u32_destroy_hnode()
      - cleaned-up u32_destroy() implementation
      - cleaned-up code comment
    v3 -> v4:
      - dropped unneeded comment
    
    Reported-by: Li Shuang <shuali@redhat.com>
    Fixes: c0d378ef1266 ("net_sched: use tcf_queue_work() in u32 filter")
    Signed-off-by: Paolo Abeni <pabeni@redhat.com>
    Acked-by: Cong Wang <xiyou.wangcong@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit ebadf888288c9e069b0141a4f00784e7245c5e28
Author: Paolo Abeni <pabeni@redhat.com>
Date:   Mon Feb 5 22:23:01 2018 +0100

    cls_u32: fix use after free in u32_destroy_key()
    
    
    [ Upstream commit d7cdee5ea8d28ae1b6922deb0c1badaa3aa0ef8c ]
    
    Li Shuang reported an Oops with cls_u32 due to an use-after-free
    in u32_destroy_key(). The use-after-free can be triggered with:
    
    dev=lo
    tc qdisc add dev $dev root handle 1: htb default 10
    tc filter add dev $dev parent 1: prio 5 handle 1: protocol ip u32 divisor 256
    tc filter add dev $dev protocol ip parent 1: prio 5 u32 ht 800:: match ip dst\
     10.0.0.0/8 hashkey mask 0x0000ff00 at 16 link 1:
    tc qdisc del dev $dev root
    
    Which causes the following kasan splat:
    
     ==================================================================
     BUG: KASAN: use-after-free in u32_destroy_key.constprop.21+0x117/0x140 [cls_u32]
     Read of size 4 at addr ffff881b83dae618 by task kworker/u48:5/571
    
     CPU: 17 PID: 571 Comm: kworker/u48:5 Not tainted 4.15.0+ #87
     Hardware name: Dell Inc. PowerEdge R730/072T6D, BIOS 2.1.7 06/16/2016
     Workqueue: tc_filter_workqueue u32_delete_key_freepf_work [cls_u32]
     Call Trace:
      dump_stack+0xd6/0x182
      ? dma_virt_map_sg+0x22e/0x22e
      print_address_description+0x73/0x290
      kasan_report+0x277/0x360
      ? u32_destroy_key.constprop.21+0x117/0x140 [cls_u32]
      u32_destroy_key.constprop.21+0x117/0x140 [cls_u32]
      u32_delete_key_freepf_work+0x1c/0x30 [cls_u32]
      process_one_work+0xae0/0x1c80
      ? sched_clock+0x5/0x10
      ? pwq_dec_nr_in_flight+0x3c0/0x3c0
      ? _raw_spin_unlock_irq+0x29/0x40
      ? trace_hardirqs_on_caller+0x381/0x570
      ? _raw_spin_unlock_irq+0x29/0x40
      ? finish_task_switch+0x1e5/0x760
      ? finish_task_switch+0x208/0x760
      ? preempt_notifier_dec+0x20/0x20
      ? __schedule+0x839/0x1ee0
      ? check_noncircular+0x20/0x20
      ? firmware_map_remove+0x73/0x73
      ? find_held_lock+0x39/0x1c0
      ? worker_thread+0x434/0x1820
      ? lock_contended+0xee0/0xee0
      ? lock_release+0x1100/0x1100
      ? init_rescuer.part.16+0x150/0x150
      ? retint_kernel+0x10/0x10
      worker_thread+0x216/0x1820
      ? process_one_work+0x1c80/0x1c80
      ? lock_acquire+0x1a5/0x540
      ? lock_downgrade+0x6b0/0x6b0
      ? sched_clock+0x5/0x10
      ? lock_release+0x1100/0x1100
      ? compat_start_thread+0x80/0x80
      ? do_raw_spin_trylock+0x190/0x190
      ? _raw_spin_unlock_irq+0x29/0x40
      ? trace_hardirqs_on_caller+0x381/0x570
      ? _raw_spin_unlock_irq+0x29/0x40
      ? finish_task_switch+0x1e5/0x760
      ? finish_task_switch+0x208/0x760
      ? preempt_notifier_dec+0x20/0x20
      ? __schedule+0x839/0x1ee0
      ? kmem_cache_alloc_trace+0x143/0x320
      ? firmware_map_remove+0x73/0x73
      ? sched_clock+0x5/0x10
      ? sched_clock_cpu+0x18/0x170
      ? find_held_lock+0x39/0x1c0
      ? schedule+0xf3/0x3b0
      ? lock_downgrade+0x6b0/0x6b0
      ? __schedule+0x1ee0/0x1ee0
      ? do_wait_intr_irq+0x340/0x340
      ? do_raw_spin_trylock+0x190/0x190
      ? _raw_spin_unlock_irqrestore+0x32/0x60
      ? process_one_work+0x1c80/0x1c80
      ? process_one_work+0x1c80/0x1c80
      kthread+0x312/0x3d0
      ? kthread_create_worker_on_cpu+0xc0/0xc0
      ret_from_fork+0x3a/0x50
    
     Allocated by task 1688:
      kasan_kmalloc+0xa0/0xd0
      __kmalloc+0x162/0x380
      u32_change+0x1220/0x3c9e [cls_u32]
      tc_ctl_tfilter+0x1ba6/0x2f80
      rtnetlink_rcv_msg+0x4f0/0x9d0
      netlink_rcv_skb+0x124/0x320
      netlink_unicast+0x430/0x600
      netlink_sendmsg+0x8fa/0xd60
      sock_sendmsg+0xb1/0xe0
      ___sys_sendmsg+0x678/0x980
      __sys_sendmsg+0xc4/0x210
      do_syscall_64+0x232/0x7f0
      return_from_SYSCALL_64+0x0/0x75
    
     Freed by task 112:
      kasan_slab_free+0x71/0xc0
      kfree+0x114/0x320
      rcu_process_callbacks+0xc3f/0x1600
      __do_softirq+0x2bf/0xc06
    
     The buggy address belongs to the object at ffff881b83dae600
      which belongs to the cache kmalloc-4096 of size 4096
     The buggy address is located 24 bytes inside of
      4096-byte region [ffff881b83dae600, ffff881b83daf600)
     The buggy address belongs to the page:
     page:ffffea006e0f6a00 count:1 mapcount:0 mapping:          (null) index:0x0 compound_mapcount: 0
     flags: 0x17ffffc0008100(slab|head)
     raw: 0017ffffc0008100 0000000000000000 0000000000000000 0000000100070007
     raw: dead000000000100 dead000000000200 ffff880187c0e600 0000000000000000
     page dumped because: kasan: bad access detected
    
     Memory state around the buggy address:
      ffff881b83dae500: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
      ffff881b83dae580: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
     >ffff881b83dae600: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
                                 ^
      ffff881b83dae680: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
      ffff881b83dae700: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
     ==================================================================
    
    The problem is that the htnode is freed before the linked knodes and the
    latter will try to access the first at u32_destroy_key() time.
    This change addresses the issue using the htnode refcnt to guarantee
    the correct free order. While at it also add a RCU annotation,
    to keep sparse happy.
    
    v1 -> v2: use rtnl_derefence() instead of RCU read locks
    v2 -> v3:
      - don't check refcnt in u32_destroy_hnode()
      - cleaned-up u32_destroy() implementation
      - cleaned-up code comment
    v3 -> v4:
      - dropped unneeded comment
    
    Reported-by: Li Shuang <shuali@redhat.com>
    Fixes: c0d378ef1266 ("net_sched: use tcf_queue_work() in u32 filter")
    Signed-off-by: Paolo Abeni <pabeni@redhat.com>
    Acked-by: Cong Wang <xiyou.wangcong@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 294975841483c08e84572713f348cd51b8408021
Author: Steven Rostedt (VMware) <rostedt@goodmis.org>
Date:   Mon Feb 5 22:18:11 2018 -0500

    tracing: Fix parsing of globs with a wildcard at the beginning
    
    commit 07234021410bbc27b7c86c18de98616c29fbe667 upstream.
    
    Al Viro reported:
    
        For substring - sure, but what about something like "*a*b" and "a*b"?
        AFAICS, filter_parse_regex() ends up with identical results in both
        cases - MATCH_GLOB and *search = "a*b".  And no way for the caller
        to tell one from another.
    
    Testing this with the following:
    
     # cd /sys/kernel/tracing
     # echo '*raw*lock' > set_ftrace_filter
     bash: echo: write error: Invalid argument
    
    With this patch:
    
     # echo '*raw*lock' > set_ftrace_filter
     # cat set_ftrace_filter
    _raw_read_trylock
    _raw_write_trylock
    _raw_read_unlock
    _raw_spin_unlock
    _raw_write_unlock
    _raw_spin_trylock
    _raw_spin_lock
    _raw_write_lock
    _raw_read_lock
    
    Al recommended not setting the search buffer to skip the first '*' unless we
    know we are not using MATCH_GLOB. This implements his suggested logic.
    
    Link: http://lkml.kernel.org/r/20180127170748.GF13338@ZenIV.linux.org.uk
    
    Cc: stable@vger.kernel.org
    Fixes: 60f1d5e3bac44 ("ftrace: Support full glob matching")
    Reviewed-by: Masami Hiramatsu <mhiramat@kernel.org>
    Reported-by: Al Viro <viro@ZenIV.linux.org.uk>
    Suggsted-by: Al Viro <viro@ZenIV.linux.org.uk>
    Signed-off-by: Steven Rostedt (VMware) <rostedt@goodmis.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 95f92d0a0ca9dd0f4a92e9eb02b2b7b3d257d46f
Author: Steven Rostedt (VMware) <rostedt@goodmis.org>
Date:   Mon Feb 5 22:18:11 2018 -0500

    tracing: Fix parsing of globs with a wildcard at the beginning
    
    commit 07234021410bbc27b7c86c18de98616c29fbe667 upstream.
    
    Al Viro reported:
    
        For substring - sure, but what about something like "*a*b" and "a*b"?
        AFAICS, filter_parse_regex() ends up with identical results in both
        cases - MATCH_GLOB and *search = "a*b".  And no way for the caller
        to tell one from another.
    
    Testing this with the following:
    
     # cd /sys/kernel/tracing
     # echo '*raw*lock' > set_ftrace_filter
     bash: echo: write error: Invalid argument
    
    With this patch:
    
     # echo '*raw*lock' > set_ftrace_filter
     # cat set_ftrace_filter
    _raw_read_trylock
    _raw_write_trylock
    _raw_read_unlock
    _raw_spin_unlock
    _raw_write_unlock
    _raw_spin_trylock
    _raw_spin_lock
    _raw_write_lock
    _raw_read_lock
    
    Al recommended not setting the search buffer to skip the first '*' unless we
    know we are not using MATCH_GLOB. This implements his suggested logic.
    
    Link: http://lkml.kernel.org/r/20180127170748.GF13338@ZenIV.linux.org.uk
    
    Cc: stable@vger.kernel.org
    Fixes: 60f1d5e3bac44 ("ftrace: Support full glob matching")
    Reviewed-by: Masami Hiramatsu <mhiramat@kernel.org>
    Reported-by: Al Viro <viro@ZenIV.linux.org.uk>
    Suggsted-by: Al Viro <viro@ZenIV.linux.org.uk>
    Signed-off-by: Steven Rostedt (VMware) <rostedt@goodmis.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 07234021410bbc27b7c86c18de98616c29fbe667
Author: Steven Rostedt (VMware) <rostedt@goodmis.org>
Date:   Mon Feb 5 22:18:11 2018 -0500

    tracing: Fix parsing of globs with a wildcard at the beginning
    
    Al Viro reported:
    
        For substring - sure, but what about something like "*a*b" and "a*b"?
        AFAICS, filter_parse_regex() ends up with identical results in both
        cases - MATCH_GLOB and *search = "a*b".  And no way for the caller
        to tell one from another.
    
    Testing this with the following:
    
     # cd /sys/kernel/tracing
     # echo '*raw*lock' > set_ftrace_filter
     bash: echo: write error: Invalid argument
    
    With this patch:
    
     # echo '*raw*lock' > set_ftrace_filter
     # cat set_ftrace_filter
    _raw_read_trylock
    _raw_write_trylock
    _raw_read_unlock
    _raw_spin_unlock
    _raw_write_unlock
    _raw_spin_trylock
    _raw_spin_lock
    _raw_write_lock
    _raw_read_lock
    
    Al recommended not setting the search buffer to skip the first '*' unless we
    know we are not using MATCH_GLOB. This implements his suggested logic.
    
    Link: http://lkml.kernel.org/r/20180127170748.GF13338@ZenIV.linux.org.uk
    
    Cc: stable@vger.kernel.org
    Fixes: 60f1d5e3bac44 ("ftrace: Support full glob matching")
    Reviewed-by: Masami Hiramatsu <mhiramat@kernel.org>
    Reported-by: Al Viro <viro@ZenIV.linux.org.uk>
    Suggsted-by: Al Viro <viro@ZenIV.linux.org.uk>
    Signed-off-by: Steven Rostedt (VMware) <rostedt@goodmis.org>

commit d7cdee5ea8d28ae1b6922deb0c1badaa3aa0ef8c
Author: Paolo Abeni <pabeni@redhat.com>
Date:   Mon Feb 5 22:23:01 2018 +0100

    cls_u32: fix use after free in u32_destroy_key()
    
    Li Shuang reported an Oops with cls_u32 due to an use-after-free
    in u32_destroy_key(). The use-after-free can be triggered with:
    
    dev=lo
    tc qdisc add dev $dev root handle 1: htb default 10
    tc filter add dev $dev parent 1: prio 5 handle 1: protocol ip u32 divisor 256
    tc filter add dev $dev protocol ip parent 1: prio 5 u32 ht 800:: match ip dst\
     10.0.0.0/8 hashkey mask 0x0000ff00 at 16 link 1:
    tc qdisc del dev $dev root
    
    Which causes the following kasan splat:
    
     ==================================================================
     BUG: KASAN: use-after-free in u32_destroy_key.constprop.21+0x117/0x140 [cls_u32]
     Read of size 4 at addr ffff881b83dae618 by task kworker/u48:5/571
    
     CPU: 17 PID: 571 Comm: kworker/u48:5 Not tainted 4.15.0+ #87
     Hardware name: Dell Inc. PowerEdge R730/072T6D, BIOS 2.1.7 06/16/2016
     Workqueue: tc_filter_workqueue u32_delete_key_freepf_work [cls_u32]
     Call Trace:
      dump_stack+0xd6/0x182
      ? dma_virt_map_sg+0x22e/0x22e
      print_address_description+0x73/0x290
      kasan_report+0x277/0x360
      ? u32_destroy_key.constprop.21+0x117/0x140 [cls_u32]
      u32_destroy_key.constprop.21+0x117/0x140 [cls_u32]
      u32_delete_key_freepf_work+0x1c/0x30 [cls_u32]
      process_one_work+0xae0/0x1c80
      ? sched_clock+0x5/0x10
      ? pwq_dec_nr_in_flight+0x3c0/0x3c0
      ? _raw_spin_unlock_irq+0x29/0x40
      ? trace_hardirqs_on_caller+0x381/0x570
      ? _raw_spin_unlock_irq+0x29/0x40
      ? finish_task_switch+0x1e5/0x760
      ? finish_task_switch+0x208/0x760
      ? preempt_notifier_dec+0x20/0x20
      ? __schedule+0x839/0x1ee0
      ? check_noncircular+0x20/0x20
      ? firmware_map_remove+0x73/0x73
      ? find_held_lock+0x39/0x1c0
      ? worker_thread+0x434/0x1820
      ? lock_contended+0xee0/0xee0
      ? lock_release+0x1100/0x1100
      ? init_rescuer.part.16+0x150/0x150
      ? retint_kernel+0x10/0x10
      worker_thread+0x216/0x1820
      ? process_one_work+0x1c80/0x1c80
      ? lock_acquire+0x1a5/0x540
      ? lock_downgrade+0x6b0/0x6b0
      ? sched_clock+0x5/0x10
      ? lock_release+0x1100/0x1100
      ? compat_start_thread+0x80/0x80
      ? do_raw_spin_trylock+0x190/0x190
      ? _raw_spin_unlock_irq+0x29/0x40
      ? trace_hardirqs_on_caller+0x381/0x570
      ? _raw_spin_unlock_irq+0x29/0x40
      ? finish_task_switch+0x1e5/0x760
      ? finish_task_switch+0x208/0x760
      ? preempt_notifier_dec+0x20/0x20
      ? __schedule+0x839/0x1ee0
      ? kmem_cache_alloc_trace+0x143/0x320
      ? firmware_map_remove+0x73/0x73
      ? sched_clock+0x5/0x10
      ? sched_clock_cpu+0x18/0x170
      ? find_held_lock+0x39/0x1c0
      ? schedule+0xf3/0x3b0
      ? lock_downgrade+0x6b0/0x6b0
      ? __schedule+0x1ee0/0x1ee0
      ? do_wait_intr_irq+0x340/0x340
      ? do_raw_spin_trylock+0x190/0x190
      ? _raw_spin_unlock_irqrestore+0x32/0x60
      ? process_one_work+0x1c80/0x1c80
      ? process_one_work+0x1c80/0x1c80
      kthread+0x312/0x3d0
      ? kthread_create_worker_on_cpu+0xc0/0xc0
      ret_from_fork+0x3a/0x50
    
     Allocated by task 1688:
      kasan_kmalloc+0xa0/0xd0
      __kmalloc+0x162/0x380
      u32_change+0x1220/0x3c9e [cls_u32]
      tc_ctl_tfilter+0x1ba6/0x2f80
      rtnetlink_rcv_msg+0x4f0/0x9d0
      netlink_rcv_skb+0x124/0x320
      netlink_unicast+0x430/0x600
      netlink_sendmsg+0x8fa/0xd60
      sock_sendmsg+0xb1/0xe0
      ___sys_sendmsg+0x678/0x980
      __sys_sendmsg+0xc4/0x210
      do_syscall_64+0x232/0x7f0
      return_from_SYSCALL_64+0x0/0x75
    
     Freed by task 112:
      kasan_slab_free+0x71/0xc0
      kfree+0x114/0x320
      rcu_process_callbacks+0xc3f/0x1600
      __do_softirq+0x2bf/0xc06
    
     The buggy address belongs to the object at ffff881b83dae600
      which belongs to the cache kmalloc-4096 of size 4096
     The buggy address is located 24 bytes inside of
      4096-byte region [ffff881b83dae600, ffff881b83daf600)
     The buggy address belongs to the page:
     page:ffffea006e0f6a00 count:1 mapcount:0 mapping:          (null) index:0x0 compound_mapcount: 0
     flags: 0x17ffffc0008100(slab|head)
     raw: 0017ffffc0008100 0000000000000000 0000000000000000 0000000100070007
     raw: dead000000000100 dead000000000200 ffff880187c0e600 0000000000000000
     page dumped because: kasan: bad access detected
    
     Memory state around the buggy address:
      ffff881b83dae500: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
      ffff881b83dae580: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
     >ffff881b83dae600: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
                                 ^
      ffff881b83dae680: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
      ffff881b83dae700: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
     ==================================================================
    
    The problem is that the htnode is freed before the linked knodes and the
    latter will try to access the first at u32_destroy_key() time.
    This change addresses the issue using the htnode refcnt to guarantee
    the correct free order. While at it also add a RCU annotation,
    to keep sparse happy.
    
    v1 -> v2: use rtnl_derefence() instead of RCU read locks
    v2 -> v3:
      - don't check refcnt in u32_destroy_hnode()
      - cleaned-up u32_destroy() implementation
      - cleaned-up code comment
    v3 -> v4:
      - dropped unneeded comment
    
    Reported-by: Li Shuang <shuali@redhat.com>
    Fixes: c0d378ef1266 ("net_sched: use tcf_queue_work() in u32 filter")
    Signed-off-by: Paolo Abeni <pabeni@redhat.com>
    Acked-by: Cong Wang <xiyou.wangcong@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit e2204d254f27087a71e58d371b2a60bddf3e7c54
Author: Sean Young <sean@mess.org>
Date:   Fri Aug 4 10:12:03 2017 -0400

    media: Revert "[media] lirc_dev: remove superfluous get/put_device() calls"
    
    commit a607f51e5a4c421e2097077db88105402099c528 upstream.
    
    This reverts commit 5be2b76a9ca4ea5fd3e221114d62eeb0d78267ca.
    
    Only when the lirc device is freed, should we drop our reference to
    rc_dev, else we the rc_dev is freed to early. If userspace has
    a file descriptor open during unplug, it goes bang.
    
    ==================================================================
    BUG: KASAN: use-after-free in __lock_acquire+0x7bb/0x1e10
    Read of size 8 at addr ffff8801d7d61ed0 by task ir-rec/2609
    
    -snip-
     mutex_lock_nested+0x1b/0x20
     ? mutex_lock_nested+0x1b/0x20
     rc_close.part.6+0x20/0x60 [rc_core]
     rc_close+0x13/0x20 [rc_core]
     lirc_dev_fop_close+0x62/0xd0 [lirc_dev]
     __fput+0x236/0x410
     ? fput+0xb0/0xb0
     ? do_raw_spin_trylock+0x110/0x110
     ? set_rq_offline.part.70+0xa0/0xa0
     ____fput+0xe/0x10
     task_work_run+0x116/0x180
     ? task_work_cancel+0x170/0x170
     ? _raw_spin_unlock+0x27/0x40
     ? switch_task_namespaces+0x5f/0x90
     do_exit+0x68b/0xe80
    
    Fixes: 5be2b76a9ca4 ("[media] lirc_dev: remove superfluous get/put_device() calls")
    Signed-off-by: Sean Young <sean@mess.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit a607f51e5a4c421e2097077db88105402099c528
Author: Sean Young <sean@mess.org>
Date:   Fri Aug 4 10:12:03 2017 -0400

    media: Revert "[media] lirc_dev: remove superfluous get/put_device() calls"
    
    This reverts commit 5be2b76a9ca4ea5fd3e221114d62eeb0d78267ca.
    
    Only when the lirc device is freed, should we drop our reference to
    rc_dev, else we the rc_dev is freed to early. If userspace has
    a file descriptor open during unplug, it goes bang.
    
    ==================================================================
    BUG: KASAN: use-after-free in __lock_acquire+0x7bb/0x1e10
    Read of size 8 at addr ffff8801d7d61ed0 by task ir-rec/2609
    
    -snip-
     mutex_lock_nested+0x1b/0x20
     ? mutex_lock_nested+0x1b/0x20
     rc_close.part.6+0x20/0x60 [rc_core]
     rc_close+0x13/0x20 [rc_core]
     lirc_dev_fop_close+0x62/0xd0 [lirc_dev]
     __fput+0x236/0x410
     ? fput+0xb0/0xb0
     ? do_raw_spin_trylock+0x110/0x110
     ? set_rq_offline.part.70+0xa0/0xa0
     ____fput+0xe/0x10
     task_work_run+0x116/0x180
     ? task_work_cancel+0x170/0x170
     ? _raw_spin_unlock+0x27/0x40
     ? switch_task_namespaces+0x5f/0x90
     do_exit+0x68b/0xe80
    
    Cc: stable@vger.kernel.org # For Kernel 4.13
    Fixes: 5be2b76a9ca4 ("[media] lirc_dev: remove superfluous get/put_device() calls")
    Signed-off-by: Sean Young <sean@mess.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

commit 24c2503255d35c269b67162c397a1a1c1e02f6ce
Author: Borislav Petkov <bp@suse.de>
Date:   Wed Jan 25 21:00:48 2017 +0100

    x86/microcode: Do not access the initrd after it has been freed
    
    When we look for microcode blobs, we first try builtin and if that
    doesn't succeed, we fallback to the initrd supplied to the kernel.
    
    However, at some point doing boot, that initrd gets jettisoned and we
    shouldn't access it anymore. But we do, as the below KASAN report shows.
    That's because find_microcode_in_initrd() doesn't check whether the
    initrd is still valid or not.
    
    So do that.
    
      ==================================================================
      BUG: KASAN: use-after-free in find_cpio_data
      Read of size 1 by task swapper/1/0
      page:ffffea0000db9d40 count:0 mapcount:0 mapping:          (null) index:0x1
      flags: 0x100000000000000()
      raw: 0100000000000000 0000000000000000 0000000000000001 00000000ffffffff
      raw: dead000000000100 dead000000000200 0000000000000000 0000000000000000
      page dumped because: kasan: bad access detected
      CPU: 1 PID: 0 Comm: swapper/1 Tainted: G        W       4.10.0-rc5-debug-00075-g2dbde22 #3
      Hardware name: Dell Inc. XPS 13 9360/0839Y6, BIOS 1.2.3 12/01/2016
      Call Trace:
       dump_stack
       ? _atomic_dec_and_lock
       ? __dump_page
       kasan_report_error
       ? pointer
       ? find_cpio_data
       __asan_report_load1_noabort
       ? find_cpio_data
       find_cpio_data
       ? vsprintf
       ? dump_stack
       ? get_ucode_user
       ? print_usage_bug
       find_microcode_in_initrd
       __load_ucode_intel
       ? collect_cpu_info_early
       ? debug_check_no_locks_freed
       load_ucode_intel_ap
       ? collect_cpu_info
       ? trace_hardirqs_on
       ? flat_send_IPI_mask_allbutself
       load_ucode_ap
       ? get_builtin_firmware
       ? flush_tlb_func
       ? do_raw_spin_trylock
       ? cpumask_weight
       cpu_init
       ? trace_hardirqs_off
       ? play_dead_common
       ? native_play_dead
       ? hlt_play_dead
       ? syscall_init
       ? arch_cpu_idle_dead
       ? do_idle
       start_secondary
       start_cpu
      Memory state around the buggy address:
       ffff880036e74f00: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
       ffff880036e74f80: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
      >ffff880036e75000: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
                         ^
       ffff880036e75080: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
       ffff880036e75100: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
      ==================================================================
    
    Reported-by: Andrey Ryabinin <aryabinin@virtuozzo.com>
    Tested-by: Andrey Ryabinin <aryabinin@virtuozzo.com>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/20170126165833.evjemhbqzaepirxo@pd.tnic
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit c17af4dd96aa99e6e58b5d715a7c66db63a15106
Author: David Ahern <david.ahern@oracle.com>
Date:   Mon Jun 15 16:15:43 2015 -0400

    sparc: perf: Disable pagefaults while walking userspace stacks
    
    Page faults generated walking userspace stacks can call schedule to switch
    out the task. When collecting callchains for scheduler tracepoints this
    causes a deadlock as the tracepoints can be hit with the runqueue lock held:
    
    [ 8138.159054] WARNING: CPU: 758 PID: 12488 at /opt/dahern/linux.git/arch/sparc/kernel/nmi.c:80 perfctr_irq+0x1f8/0x2b4()
    
    [ 8138.203152] Watchdog detected hard LOCKUP on cpu 758
    
    [ 8138.410969] CPU: 758 PID: 12488 Comm: perf Not tainted 4.0.0-rc6+ #6
    [ 8138.437146] Call Trace:
    [ 8138.447193]  [000000000045cdd4] warn_slowpath_common+0x7c/0xa0
    [ 8138.471238]  [000000000045ce90] warn_slowpath_fmt+0x30/0x40
    [ 8138.494189]  [0000000000983e38] perfctr_irq+0x1f8/0x2b4
    [ 8138.515716]  [00000000004209f4] tl0_irq15+0x14/0x20
    [ 8138.535791]  [00000000009839ec] _raw_spin_trylock_bh+0x68/0x108
    [ 8138.560180]  [0000000000980018] __schedule+0xcc/0x710
    [ 8138.580981]  [00000000009806dc] preempt_schedule_common+0x10/0x3c
    [ 8138.606082]  [000000000098077c] _cond_resched+0x34/0x44
    [ 8138.627603]  [0000000000565990] kmem_cache_alloc_node+0x24/0x1a0
    [ 8138.652345]  [0000000000450b60] tsb_grow+0xac/0x488
    [ 8138.672429]  [0000000000985040] do_sparc64_fault+0x4dc/0x6e4
    [ 8138.695736]  [0000000000407c2c] sparc64_realfault_common+0x10/0x20
    [ 8138.721202]  [00000000006f2e24] NG4copy_from_user+0xa4/0x3c0
    [ 8138.744510]  [000000000044f900] perf_callchain_user+0x5c/0x6c
    [ 8138.768182]  [0000000000517b5c] perf_callchain+0x16c/0x19c
    [ 8138.790774]  [0000000000515f84] perf_prepare_sample+0x68/0x218
    [ 8138.814801] ---[ end trace 42ca6294b1ff7573 ]---
    
    As with PowerPC (b59a1bfcc240, "powerpc/perf: Disable pagefaults during
    callchain stack read") disable pagefaults while walking userspace stacks.
    
    Signed-off-by: David Ahern <david.ahern@oracle.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 6fad18fa51392c9847a4e3a95134b2e57155e563
Author: Rabin Vincent <rabin@rab.in>
Date:   Fri Nov 14 19:00:41 2014 +0100

    serial: 8250: don't attempt a trylock if in sysrq
    
    Attempting to use SysRq via the 8250 serial port with spin lock
    debugging on on a uniprocessor system results in the following splat:
    
     SysRq :
     BUG: spinlock trylock failure on UP on CPU#0, swapper/0
      lock: serial8250_ports+0x0/0x8c0, .magic: dead4ead, .owner: swapper/0, .owner_cpu: 0
     CPU: 0 PID: 0 Comm: swapper Not tainted 3.18.0-rc4+ #37
     Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.7.5-20140531_083030-gandalf 04/01/2014
      ffffffff8245ba00 ffffffff81628b28 ffffffff812c8d27 ffffffff81628b48
      ffffffff8106812e ffffffff8245ba00 ffffffff814e22ed ffffffff81628b68
      ffffffff810681a6 0000000000000000 0000000000000000 ffffffff81628b88
     Call Trace:
      <IRQ>  [<ffffffff812c8d27>] dump_stack+0x19/0x1b
      [<ffffffff8106812e>] spin_dump+0x7e/0xd0
      [<ffffffff810681a6>] spin_bug+0x26/0x30
      [<ffffffff8106843c>] do_raw_spin_trylock+0x4c/0x60
      [<ffffffff812cdb1d>] _raw_spin_trylock+0x1d/0x60
      [<ffffffff812336d8>] serial8250_console_write+0x68/0x190
      [<ffffffff811eb0b0>] ? sprintf+0x40/0x50
      [<ffffffff8106ab5e>] call_console_drivers.constprop.11+0x9e/0xf0
      [<ffffffff8106b276>] console_unlock+0x3e6/0x490
      [<ffffffff8106b595>] vprintk_emit+0x275/0x530
      [<ffffffff812c869a>] printk+0x4d/0x4f
      [<ffffffff8121e612>] __handle_sysrq+0x62/0x1b0
      [<ffffffff8121e5b5>] ? __handle_sysrq+0x5/0x1b0
      [<ffffffff8121ebc6>] handle_sysrq+0x26/0x30
      [<ffffffff81233157>] serial8250_rx_chars+0x1d7/0x250
      [<ffffffff812338bb>] serial8250_handle_irq+0x7b/0x90
      [<ffffffff812338f3>] serial8250_default_handle_irq+0x23/0x30
      [<ffffffff812318b3>] serial8250_interrupt+0x63/0xe0
      [<ffffffff8106d80e>] handle_irq_event_percpu+0x4e/0x200
      [<ffffffff8106da01>] handle_irq_event+0x41/0x70
      [<ffffffff810701ee>] ? handle_edge_irq+0x1e/0x110
      [<ffffffff8107026e>] handle_edge_irq+0x9e/0x110
      [<ffffffff810041c2>] handle_irq+0x22/0x40
      [<ffffffff812d096e>] do_IRQ+0x4e/0xf0
      [<ffffffff812cf4ed>] common_interrupt+0x6d/0x6d
      <EOI>  [<ffffffff8100acbf>] ? default_idle+0x1f/0xd0
      [<ffffffff8100acbd>] ? default_idle+0x1d/0xd0
      [<ffffffff8100b61f>] arch_cpu_idle+0xf/0x20
      [<ffffffff8105c1db>] cpu_startup_entry+0x25b/0x360
      [<ffffffff812c726e>] rest_init+0xbe/0xd0
      [<ffffffff816a4dcb>] start_kernel+0x339/0x346
      [<ffffffff816a4495>] x86_64_start_reservations+0x2a/0x2c
      [<ffffffff816a4589>] x86_64_start_kernel+0xf2/0xf6
     HELP : loglevel(0-9) reboot(b) crash(c) show-all-locks(d) te...
    
    Before ebade5e833eda30 ("serial: 8250: Clean up the locking for -rt")
    this was handled by not even attempting to try the lock if port->sysrq,
    since it is known to be taken by the interrupt handler; see
    https://bugzilla.kernel.org/show_bug.cgi?id=6716#c1.  Restore that
    behavior.
    
    Signed-off-by: Rabin Vincent <rabin@rab.in>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 02f52975eb0858eb03ca091f644c8eb171895f92
Author: Helge Deller <deller@gmx.de>
Date:   Fri May 24 21:27:35 2013 +0000

    parisc: fix irq stack on UP and SMP
    
    commit d96b51ec14650b490ab98e738bcc02309396e5bc upstream.
    
    The logic to detect if the irq stack was already in use with
    raw_spin_trylock() is wrong, because it will generate a "trylock failure
    on UP" error message with CONFIG_SMP=n and CONFIG_DEBUG_SPINLOCK=y.
    
    arch_spin_trylock() can't be used either since in the CONFIG_SMP=n case
    no atomic protection is given and we are reentrant here. A mutex didn't
    worked either and brings more overhead by turning off interrupts.
    
    So, let's use the fastest path for parisc which is the ldcw instruction.
    
    Counting how often the irq stack was used is pretty useless, so just
    drop this piece of code.
    
    Signed-off-by: Helge Deller <deller@gmx.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit d96b51ec14650b490ab98e738bcc02309396e5bc
Author: Helge Deller <deller@gmx.de>
Date:   Fri May 24 21:27:35 2013 +0000

    parisc: fix irq stack on UP and SMP
    
    The logic to detect if the irq stack was already in use with
    raw_spin_trylock() is wrong, because it will generate a "trylock failure
    on UP" error message with CONFIG_SMP=n and CONFIG_DEBUG_SPINLOCK=y.
    
    arch_spin_trylock() can't be used either since in the CONFIG_SMP=n case
    no atomic protection is given and we are reentrant here. A mutex didn't
    worked either and brings more overhead by turning off interrupts.
    
    So, let's use the fastest path for parisc which is the ldcw instruction.
    
    Counting how often the irq stack was used is pretty useless, so just
    drop this piece of code.
    
    Signed-off-by: Helge Deller <deller@gmx.de>

commit de2070fc4aa7c0205348010f500f5abce012e67b
Author: Mohammed Shafi Shajakhan <mohammed@qca.qualcomm.com>
Date:   Fri Nov 16 18:22:40 2012 +0530

    ath6kl: Fix kernel panic on continuous driver load/unload
    
    On continuous loading and unloading of AR6004 ath6kl USB
    driver it triggers a panic due to NULL pointer dereference of
    'target' pointer.
    
    while true; do sudo modprobe -v ath6kl_core;
    sudo modprobe -v ath6kl_usb; sudo modprobe -r usb;
    sudo modprobe -r ath6kl_core; done
    
    ar->htc_target can be NULL due to a race condition that can occur
    during driver initialization(we do 'ath6kl_hif_power_on' before
    initializing 'ar->htc_target' via 'ath6kl_htc_create').
    'ath6kl_hif_power_on' assigns 'ath6kl_recv_complete' as
    usb_complete_t/callback function for 'usb_fill_bulk_urb'.
    Thus the possibility of ar->htc_target being NULL
    via ath6kl_recv_complete -> ath6kl_usb_io_comp_work
    before even 'ath6kl_htc_create' is finished to initialize
    ar->htc_create.
    
    Worth noting is the obvious solution  of doing 'ath6kl_hif_power_on'
    later(i.e after we are done with 'ath6kl_htc_create', causes a
    h/w bring up failure in AR6003 SDIO, as 'ath6kl_hif_power_on' is a
    pre-requisite to get the target version 'ath6kl_bmi_get_target_info'.
    So simply check for NULL pointer for 'ar->htc_target' and bail out.
    
    [23614.518282] BUG: unable to handle kernel NULL pointer dereference at
    00000904
    [23614.518463] IP: [<c012e7a6>] __ticket_spin_trylock+0x6/0x30
    [23614.518570] *pde = 00000000
    [23614.518664] Oops: 0000 [#1] SMP
    [23614.518795] Modules linked in: ath6kl_usb(O+) ath6kl_core(O)
    [23614.520012] EIP: 0060:[<c012e7a6>] EFLAGS: 00010286 CPU: 0
    [23614.520012] EIP is at __ticket_spin_trylock+0x6/0x30
    Call Trace:
            [<c03f2a44>] do_raw_spin_trylock+0x14/0x40
            [<c06daa12>] _raw_spin_lock_bh+0x52/0x80
            [<f85464b4>] ? ath6kl_htc_pipe_rx_complete+0x3b4/0x4c0 [ath6kl_core]
            [<f85464b4>] ath6kl_htc_pipe_rx_complete+0x3b4/0x4c0 [ath6kl_core]
            [<c05bc272>] ? skb_dequeue+0x22/0x70
            [<c05bc272>] ? skb_dequeue+0x22/0x70
            [<f855bb32>] ath6kl_core_rx_complete+0x12/0x20 [ath6kl_core]
            [<f848771a>] ath6kl_usb_io_comp_work+0xaa/0xb0 [ath6kl_usb]
            [<c015b863>] process_one_work+0x1a3/0x5e0
            [<c015b7e7>] ? process_one_work+0x127/0x5e0
            [<f8487670>] ? ath6kl_usb_reset_resume+0x30/0x30 [ath6kl_usb]
            [<c015bfde>] worker_thread+0x11e/0x3f0
            Kernel panic - not syncing: Fatal exception in interrupt
    
    Signed-off-by: Mohammed Shafi Shajakhan <mohammed@qca.qualcomm.com>
    Signed-off-by: Kalle Valo <kvalo@qca.qualcomm.com>

commit d4d2dbcaedb9334d0c462129099346d617f61768
Author: Fengguang Wu <fengguang.wu@intel.com>
Date:   Sun Sep 9 16:23:46 2012 +0800

    Staging: panel: fix spinlock trylock failure on UP
    
    Use spin_lock_irq() to quiet warning:
    
             [    8.232324] BUG: spinlock trylock failure on UP on CPU#0, reboot/85
             [    8.234138]  lock: c161c760, .magic: dead4ead, .owner: reboot/85, .owner_cpu: 0
             [    8.236132] Pid: 85, comm: reboot Not tainted 3.4.0-rc7-00656-g82163ed #5
             [    8.237965] Call Trace:
             [    8.238648]  [<c13dfd20>] ? printk+0x18/0x1a
             [    8.239827]  [<c122a5e0>] spin_dump+0x80/0xd0
             [    8.241016]  [<c122a652>] spin_bug+0x22/0x30
             [    8.242181]  [<c122a93b>] do_raw_spin_trylock+0x5b/0x70
             [    8.243611]  [<c13e8bae>] _raw_spin_trylock+0xe/0x60
             [    8.244975]  [<c1392230>] ? keypad_send_key.constprop.9+0xe0/0xe0
     ==>     [    8.246638]  [<c13922ea>] panel_scan_timer+0xba/0x570
             [    8.248019]  [<c1392230>] ? keypad_send_key.constprop.9+0xe0/0xe0
             [    8.249689]  [<c102f6f5>] run_timer_softirq+0x1e5/0x370
             [    8.251191]  [<c102f645>] ? run_timer_softirq+0x135/0x370
             [    8.252718]  [<c1392230>] ? keypad_send_key.constprop.9+0xe0/0xe0
             [    8.254462]  [<c102a592>] __do_softirq+0xc2/0x1c0
             [    8.255758]  [<c102a4d0>] ? local_bh_enable_ip+0x130/0x130
             [    8.257228]  <IRQ>  [<c102a855>] ? irq_exit+0x65/0x70
             [    8.258647]  [<c1013ff9>] ? smp_apic_timer_interrupt+0x49/0x80
             [    8.260226]  [<c13e96c1>] ? apic_timer_interrupt+0x31/0x38
             [    8.261737]  [<c12700e0>] ? drm_vm_open_locked+0x70/0xb0
             [    8.263166]  [<c122489a>] ? delay_tsc+0x1a/0x30
             [    8.264452]  [<c12248c9>] ? __delay+0x9/0x10
             [    8.265621]  [<c12248ec>] ? __const_udelay+0x1c/0x20
     ==>     [    8.266967]  [<c139136c>] ? lcd_clear_fast_p8+0x9c/0xe0
             [    8.268386]  [<c1391a66>] ? lcd_write+0x226/0x810
             [    8.269653]  [<c1367900>] ? md_set_readonly+0xc0/0xc0
             [    8.271013]  [<c122a9ed>] ? do_raw_spin_unlock+0x9d/0xe0
             [    8.272470]  [<c1392a98>] ? panel_lcd_print+0x38/0x40
             [    8.273837]  [<c1392ace>] ? panel_notify_sys+0x2e/0x60
             [    8.275224]  [<c1046634>] ? notifier_call_chain+0x84/0xb0
             [    8.276754]  [<c10469ce>] ? __blocking_notifier_call_chain+0x3e/0x60
             [    8.278576]  [<c1046a0a>] ? blocking_notifier_call_chain+0x1a/0x20
             [    8.280267]  [<c1036a14>] ? kernel_restart_prepare+0x14/0x40
             [    8.281901]  [<c1036a8e>] ? kernel_restart+0xe/0x50
             [    8.283216]  [<c1036ce9>] ? sys_reboot+0x149/0x1e0
             [    8.284532]  [<c10b3fb3>] ? handle_pte_fault+0x93/0xd70
             [    8.285956]  [<c1019e35>] ? do_page_fault+0x215/0x5e0
             [    8.287330]  [<c101a113>] ? do_page_fault+0x4f3/0x5e0
             [    8.288704]  [<c1045ac6>] ? up_read+0x16/0x30
             [    8.289890]  [<c101a113>] ? do_page_fault+0x4f3/0x5e0
             [    8.291252]  [<c10d4486>] ? iterate_supers+0x86/0xd0
             [    8.292615]  [<c122a9ed>] ? do_raw_spin_unlock+0x9d/0xe0
             [    8.294049]  [<c13e8dcd>] ? _raw_spin_unlock+0x1d/0x20
             [    8.295449]  [<c10d44ab>] ? iterate_supers+0xab/0xd0
             [    8.296795]  [<c10fb620>] ? __sync_filesystem+0xa0/0xa0
             [    8.298199]  [<c13e9b03>] ? sysenter_do_call+0x12/0x37
             [    8.306899] Restarting system.
             [    8.307747] machine restart
    
    Signed-off-by: Fengguang Wu <fengguang.wu@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 1d58996da6a8045c8df2899ce5689a19c721322f
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Thu Sep 15 17:56:39 2011 -0400

    bluetooth: macroize two small inlines to avoid module.h
    
    These two small inlines make calls to try_module_get() and
    module_put() which would force us to keep module.h present
    within yet another common include header.  We can avoid this
    by turning them into macros.  The hci_dev_hold construct
    is patterned off of raw_spin_trylock_irqsave() in spinlock.h
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

commit 7fd29aa920273b70be50c14c4b7e2213fb6623ce
Author: Nicholas Bellinger <nab@linux-iscsi.org>
Date:   Thu Jun 23 23:48:32 2011 +0000

    target: Fix transport_get_lun_for_tmr failure cases
    
    This patch fixes two possible NULL pointer dereferences in target v4.0
    code where se_tmr release path in core_tmr_release_req() can OOPs upon
    transport_get_lun_for_tmr() failure by attempting to access se_device or
    se_tmr->tmr_list without a valid member of se_device->tmr_list during
    transport_free_se_cmd() release.  This patch moves the se_tmr->tmr_dev
    pointer assignment in transport_get_lun_for_tmr() until after possible
    -ENODEV failures during unpacked_lun lookup.
    
    This addresses an OOPs originally reported with LIO v4.1 upstream on
    .39 code here:
    
        TARGET_CORE[qla2xxx]: Detected NON_EXISTENT_LUN Access for 0x00000000
        BUG: unable to handle kernel NULL pointer dereference at 0000000000000550
        IP: [<ffffffff81035ec4>] __ticket_spin_trylock+0x4/0x20
        PGD 0
        Oops: 0000 [#1] SMP
        last sysfs file: /sys/devices/system/cpu/cpu23/cache/index2/shared_cpu_map
        CPU 1
        Modules linked in: netconsole target_core_pscsi target_core_file
    tcm_qla2xxx target_core_iblock tcm_loop target_core_mod configfs
    ipmi_devintf ipmi_si ipmi_msghandler serio_raw i7core_edac ioatdma dca
    edac_core ps_bdrv ses enclosure usbhid usb_storage ahci qla2xxx hid
    uas e1000e mpt2sas libahci mlx4_core scsi_transport_fc
    scsi_transport_sas raid_class scsi_tgt [last unloaded: netconsole]
    
        Pid: 0, comm: kworker/0:0 Tainted: G        W   2.6.39+ #1 Xyratex Storage Server
        RIP: 0010:[<ffffffff81035ec4>] [<ffffffff81035ec4>]__ticket_spin_trylock+0x4/0x20
        RSP: 0018:ffff88063e803c08  EFLAGS: 00010286
        RAX: ffff880619ab45e0 RBX: 0000000000000550 RCX: 0000000000000000
        RDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000000000550
        RBP: ffff88063e803c08 R08: 0000000000000002 R09: 0000000000000000
        R10: 0000000000000000 R11: 0000000000000001 R12: 0000000000000568
        R13: 0000000000000001 R14: 0000000000000000 R15: ffff88060cd96a20
        FS:  0000000000000000(0000) GS:ffff88063e800000(0000) knlGS:0000000000000000
        CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b
        CR2: 0000000000000550 CR3: 0000000001a03000 CR4: 00000000000006e0
        DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
        DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400
        Process kworker/0:0 (pid: 0, threadinfo ffff880619ab8000, task ffff880619ab45e0)
        Stack:
         ffff88063e803c28 ffffffff812cf039 0000000000000550 0000000000000568
         ffff88063e803c58 ffffffff8157071e ffffffffa028a1dc ffff88060f7e4600
         0000000000000550 ffff880616961480 ffff88063e803c78 ffffffffa028a1dc
        Call Trace:
    <IRQ>
         [<ffffffff812cf039>] do_raw_spin_trylock+0x19/0x50
         [<ffffffff8157071e>] _raw_spin_lock+0x3e/0x70
         [<ffffffffa028a1dc>] ? core_tmr_release_req+0x2c/0x60 [target_core_mod]
         [<ffffffffa028a1dc>] core_tmr_release_req+0x2c/0x60 [target_core_mod]
         [<ffffffffa028d0d2>] transport_free_se_cmd+0x22/0x50 [target_core_mod]
         [<ffffffffa028d120>] transport_release_cmd_to_pool+0x20/0x40 [target_core_mod]
         [<ffffffffa028e525>] transport_generic_free_cmd+0xa5/0xb0 [target_core_mod]
         [<ffffffffa0147cc4>] tcm_qla2xxx_handle_tmr+0xc4/0xd0 [tcm_qla2xxx]
         [<ffffffffa0191ba3>] __qla24xx_handle_abts+0xd3/0x150 [qla2xxx]
         [<ffffffffa0197651>] qla_tgt_response_pkt+0x171/0x520 [qla2xxx]
         [<ffffffffa0197a2d>] qla_tgt_response_pkt_all_vps+0x2d/0x220 [qla2xxx]
         [<ffffffffa0171dd3>] qla24xx_process_response_queue+0x1a3/0x670 [qla2xxx]
         [<ffffffffa0196281>] ? qla24xx_atio_pkt+0x81/0x120 [qla2xxx]
         [<ffffffffa0174025>] ? qla24xx_msix_default+0x45/0x2a0 [qla2xxx]
         [<ffffffffa0174198>] qla24xx_msix_default+0x1b8/0x2a0 [qla2xxx]
         [<ffffffff810dadb4>] handle_irq_event_percpu+0x54/0x210
         [<ffffffff810dafb8>] handle_irq_event+0x48/0x70
         [<ffffffff810dd5ee>] ? handle_edge_irq+0x1e/0x110
         [<ffffffff810dd647>] handle_edge_irq+0x77/0x110
         [<ffffffff8100d362>] handle_irq+0x22/0x40
         [<ffffffff8157b28d>] do_IRQ+0x5d/0xe0
         [<ffffffff81571413>] common_interrupt+0x13/0x13
    <EOI>
         [<ffffffff813003f7>] ? intel_idle+0xd7/0x130
         [<ffffffff813003f0>] ? intel_idle+0xd0/0x130
         [<ffffffff8144832b>] cpuidle_idle_call+0xab/0x1c0
         [<ffffffff8100a26b>] cpu_idle+0xab/0xf0
         [<ffffffff81566c59>] start_secondary+0x1cb/0x1d2
    
    Reported-by: Roland Dreier <roland@purestorage.com>
    Signed-off-by: Nicholas Bellinger <nab@linux-iscsi.org>

commit d3678758048308049cdad31ec3eae063be17c0db
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Tue Dec 21 23:38:37 2010 -0200

    perf test: Look forward for symbol aliases
    
    Not just before, fixing these false positives:
    
    [acme@mica linux]$ perf test -v 1
     1: vmlinux symtab matches kallsyms:
    --- start ---
    Looking at the vmlinux_path (6 entries long)
    Using //lib/modules/2.6.37-rc5-00180-ge06b6bf/build/vmlinux for symbols
    0xffffffff81058dc0: diff name v: sys_vm86old k: sys_ni_syscall
    0xffffffff81058dc0: diff name v: sys_vm86 k: sys_ni_syscall
    0xffffffff81058dc0: diff name v: sys_subpage_prot k: sys_ni_syscall
    0xffffffff810b5f7c: diff name v: probe_kernel_write k: __probe_kernel_write
    0xffffffff810b5fe5: diff name v: probe_kernel_read k: __probe_kernel_read
    0xffffffff811bc380: diff name v: __memset k: memset
    0xffffffff81384a98: diff name v: __sched_text_start k: sleep_on_common
    0xffffffff81386750: diff name v: __sched_text_end k: _raw_spin_trylock
    0xffffffff8138cee8: diff name v: __irqentry_text_start k: do_IRQ
    0xffffffff8138f079: diff name v: __start_notes k: _etext
    0xffffffff8138f079: diff name v: __stop_notes k: _etext
    ---- end ----
    vmlinux symtab matches kallsyms: FAILED!
    
    [acme@mica linux]$
    
    Some are weak functions, others are just markers, etc. They get in the rb tree
    with the same addr, so we need to look around to find the symbol with the same
    name.
    
    We were looking just at the previous entries with the same addr, look forward
    too.
    
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Han Pingtian <phan@redhat.com>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Stephane Eranian <eranian@google.com>
    LKML-Reference: <new-submission>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

commit 45141d4667d208421ca787a3301542b6a5e0b112
Author: Steven Rostedt <srostedt@redhat.com>
Date:   Thu Feb 12 13:19:48 2009 -0500

    ring-buffer: rename label out_unlock to out_reset
    
    Impact: clean up
    
    While reviewing the ring buffer code, I thougth I saw a bug with
    
            if (!__raw_spin_trylock(&cpu_buffer->lock))
                    goto out_unlock;
    
    But I forgot that we use a variable "lock_taken" that is set if
    the spinlock is taken, and only unlock it if that variable is set.
    
    To avoid further confusion from other reviewers, this patch
    renames the label out_unlock with out_reset, which is the more
    appropriate name.
    
    Signed-off-by: Steven Rostedt <srostedt@redhat.com>

commit ef6edc9746dc2bfdacf44eefd5f881179971c478
Author: Martin Schwidefsky <schwidefsky@de.ibm.com>
Date:   Sat Sep 30 23:27:43 2006 -0700

    [PATCH] Directed yield: cpu_relax variants for spinlocks and rw-locks
    
    On systems running with virtual cpus there is optimization potential in
    regard to spinlocks and rw-locks.  If the virtual cpu that has taken a lock
    is known to a cpu that wants to acquire the same lock it is beneficial to
    yield the timeslice of the virtual cpu in favour of the cpu that has the
    lock (directed yield).
    
    With CONFIG_PREEMPT="n" this can be implemented by the architecture without
    common code changes.  Powerpc already does this.
    
    With CONFIG_PREEMPT="y" the lock loops are coded with _raw_spin_trylock,
    _raw_read_trylock and _raw_write_trylock in kernel/spinlock.c.  If the lock
    could not be taken cpu_relax is called.  A directed yield is not possible
    because cpu_relax doesn't know anything about the lock.  To be able to
    yield the lock in favour of the current lock holder variants of cpu_relax
    for spinlocks and rw-locks are needed.  The new _raw_spin_relax,
    _raw_read_relax and _raw_write_relax primitives differ from cpu_relax
    insofar that they have an argument: a pointer to the lock structure.
    
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Haavard Skinnemoen <hskinnemoen@atmel.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>
