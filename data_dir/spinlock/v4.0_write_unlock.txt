commit b9fb10d131b8c84af9bb14e2078d5c63600c7dea
Author: Eric Dumazet <edumazet@google.com>
Date:   Tue Jan 17 11:01:31 2023 +0000

    l2tp: prevent lockdep issue in l2tp_tunnel_register()
    
    lockdep complains with the following lock/unlock sequence:
    
         lock_sock(sk);
         write_lock_bh(&sk->sk_callback_lock);
    [1]  release_sock(sk);
    [2]  write_unlock_bh(&sk->sk_callback_lock);
    
    We need to swap [1] and [2] to fix this issue.
    
    Fixes: 0b2c59720e65 ("l2tp: close all race conditions in l2tp_tunnel_register()")
    Reported-by: syzbot+bbd35b345c7cab0d9a08@syzkaller.appspotmail.com
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Link: https://lore.kernel.org/netdev/20230114030137.672706-1-xiyou.wangcong@gmail.com/T/#m1164ff20628671b0f326a24cb106ab3239c70ce3
    Cc: Cong Wang <cong.wang@bytedance.com>
    Cc: Guillaume Nault <gnault@redhat.com>
    Reviewed-by: Guillaume Nault <gnault@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit c7e9624d90bf20f1eed6b228949396d614b94020
Author: Gaosheng Cui <cuigaosheng1@huawei.com>
Date:   Tue Dec 6 14:10:04 2022 +0800

    ALSA: mts64: fix possible null-ptr-defer in snd_mts64_interrupt
    
    [ Upstream commit cf2ea3c86ad90d63d1c572b43e1ca9276b0357ad ]
    
    I got a null-ptr-defer error report when I do the following tests
    on the qemu platform:
    
    make defconfig and CONFIG_PARPORT=m, CONFIG_PARPORT_PC=m,
    CONFIG_SND_MTS64=m
    
    Then making test scripts:
    cat>test_mod1.sh<<EOF
    modprobe snd-mts64
    modprobe snd-mts64
    EOF
    
    Executing the script, perhaps several times, we will get a null-ptr-defer
    report, as follow:
    
    syzkaller:~# ./test_mod.sh
    snd_mts64: probe of snd_mts64.0 failed with error -5
    modprobe: ERROR: could not insert 'snd_mts64': No such device
     BUG: kernel NULL pointer dereference, address: 0000000000000000
     #PF: supervisor write access in kernel mode
     #PF: error_code(0x0002) - not-present page
     PGD 0 P4D 0
     Oops: 0002 [#1] PREEMPT SMP PTI
     CPU: 0 PID: 205 Comm: modprobe Not tainted 6.1.0-rc8-00588-g76dcd734eca2 #6
     Call Trace:
      <IRQ>
      snd_mts64_interrupt+0x24/0xa0 [snd_mts64]
      parport_irq_handler+0x37/0x50 [parport]
      __handle_irq_event_percpu+0x39/0x190
      handle_irq_event_percpu+0xa/0x30
      handle_irq_event+0x2f/0x50
      handle_edge_irq+0x99/0x1b0
      __common_interrupt+0x5d/0x100
      common_interrupt+0xa0/0xc0
      </IRQ>
      <TASK>
      asm_common_interrupt+0x22/0x40
     RIP: 0010:_raw_write_unlock_irqrestore+0x11/0x30
      parport_claim+0xbd/0x230 [parport]
      snd_mts64_probe+0x14a/0x465 [snd_mts64]
      platform_probe+0x3f/0xa0
      really_probe+0x129/0x2c0
      __driver_probe_device+0x6d/0xc0
      driver_probe_device+0x1a/0xa0
      __device_attach_driver+0x7a/0xb0
      bus_for_each_drv+0x62/0xb0
      __device_attach+0xe4/0x180
      bus_probe_device+0x82/0xa0
      device_add+0x550/0x920
      platform_device_add+0x106/0x220
      snd_mts64_attach+0x2e/0x80 [snd_mts64]
      port_check+0x14/0x20 [parport]
      bus_for_each_dev+0x6e/0xc0
      __parport_register_driver+0x7c/0xb0 [parport]
      snd_mts64_module_init+0x31/0x1000 [snd_mts64]
      do_one_initcall+0x3c/0x1f0
      do_init_module+0x46/0x1c6
      load_module+0x1d8d/0x1e10
      __do_sys_finit_module+0xa2/0xf0
      do_syscall_64+0x37/0x90
      entry_SYSCALL_64_after_hwframe+0x63/0xcd
      </TASK>
     Kernel panic - not syncing: Fatal exception in interrupt
     Rebooting in 1 seconds..
    
    The mts wa not initialized during interrupt,  we add check for
    mts to fix this bug.
    
    Fixes: 68ab801e32bb ("[ALSA] Add snd-mts64 driver for ESI Miditerminal 4140")
    Signed-off-by: Gaosheng Cui <cuigaosheng1@huawei.com>
    Link: https://lore.kernel.org/r/20221206061004.1222966-1-cuigaosheng1@huawei.com
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 7e91667db38abb056da5a496d40fbd044c66bed2
Author: Gaosheng Cui <cuigaosheng1@huawei.com>
Date:   Tue Dec 6 14:10:04 2022 +0800

    ALSA: mts64: fix possible null-ptr-defer in snd_mts64_interrupt
    
    [ Upstream commit cf2ea3c86ad90d63d1c572b43e1ca9276b0357ad ]
    
    I got a null-ptr-defer error report when I do the following tests
    on the qemu platform:
    
    make defconfig and CONFIG_PARPORT=m, CONFIG_PARPORT_PC=m,
    CONFIG_SND_MTS64=m
    
    Then making test scripts:
    cat>test_mod1.sh<<EOF
    modprobe snd-mts64
    modprobe snd-mts64
    EOF
    
    Executing the script, perhaps several times, we will get a null-ptr-defer
    report, as follow:
    
    syzkaller:~# ./test_mod.sh
    snd_mts64: probe of snd_mts64.0 failed with error -5
    modprobe: ERROR: could not insert 'snd_mts64': No such device
     BUG: kernel NULL pointer dereference, address: 0000000000000000
     #PF: supervisor write access in kernel mode
     #PF: error_code(0x0002) - not-present page
     PGD 0 P4D 0
     Oops: 0002 [#1] PREEMPT SMP PTI
     CPU: 0 PID: 205 Comm: modprobe Not tainted 6.1.0-rc8-00588-g76dcd734eca2 #6
     Call Trace:
      <IRQ>
      snd_mts64_interrupt+0x24/0xa0 [snd_mts64]
      parport_irq_handler+0x37/0x50 [parport]
      __handle_irq_event_percpu+0x39/0x190
      handle_irq_event_percpu+0xa/0x30
      handle_irq_event+0x2f/0x50
      handle_edge_irq+0x99/0x1b0
      __common_interrupt+0x5d/0x100
      common_interrupt+0xa0/0xc0
      </IRQ>
      <TASK>
      asm_common_interrupt+0x22/0x40
     RIP: 0010:_raw_write_unlock_irqrestore+0x11/0x30
      parport_claim+0xbd/0x230 [parport]
      snd_mts64_probe+0x14a/0x465 [snd_mts64]
      platform_probe+0x3f/0xa0
      really_probe+0x129/0x2c0
      __driver_probe_device+0x6d/0xc0
      driver_probe_device+0x1a/0xa0
      __device_attach_driver+0x7a/0xb0
      bus_for_each_drv+0x62/0xb0
      __device_attach+0xe4/0x180
      bus_probe_device+0x82/0xa0
      device_add+0x550/0x920
      platform_device_add+0x106/0x220
      snd_mts64_attach+0x2e/0x80 [snd_mts64]
      port_check+0x14/0x20 [parport]
      bus_for_each_dev+0x6e/0xc0
      __parport_register_driver+0x7c/0xb0 [parport]
      snd_mts64_module_init+0x31/0x1000 [snd_mts64]
      do_one_initcall+0x3c/0x1f0
      do_init_module+0x46/0x1c6
      load_module+0x1d8d/0x1e10
      __do_sys_finit_module+0xa2/0xf0
      do_syscall_64+0x37/0x90
      entry_SYSCALL_64_after_hwframe+0x63/0xcd
      </TASK>
     Kernel panic - not syncing: Fatal exception in interrupt
     Rebooting in 1 seconds..
    
    The mts wa not initialized during interrupt,  we add check for
    mts to fix this bug.
    
    Fixes: 68ab801e32bb ("[ALSA] Add snd-mts64 driver for ESI Miditerminal 4140")
    Signed-off-by: Gaosheng Cui <cuigaosheng1@huawei.com>
    Link: https://lore.kernel.org/r/20221206061004.1222966-1-cuigaosheng1@huawei.com
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit b471fe61da523a15e4cb60fa81f5a2377e4bad98
Author: Gaosheng Cui <cuigaosheng1@huawei.com>
Date:   Tue Dec 6 14:10:04 2022 +0800

    ALSA: mts64: fix possible null-ptr-defer in snd_mts64_interrupt
    
    [ Upstream commit cf2ea3c86ad90d63d1c572b43e1ca9276b0357ad ]
    
    I got a null-ptr-defer error report when I do the following tests
    on the qemu platform:
    
    make defconfig and CONFIG_PARPORT=m, CONFIG_PARPORT_PC=m,
    CONFIG_SND_MTS64=m
    
    Then making test scripts:
    cat>test_mod1.sh<<EOF
    modprobe snd-mts64
    modprobe snd-mts64
    EOF
    
    Executing the script, perhaps several times, we will get a null-ptr-defer
    report, as follow:
    
    syzkaller:~# ./test_mod.sh
    snd_mts64: probe of snd_mts64.0 failed with error -5
    modprobe: ERROR: could not insert 'snd_mts64': No such device
     BUG: kernel NULL pointer dereference, address: 0000000000000000
     #PF: supervisor write access in kernel mode
     #PF: error_code(0x0002) - not-present page
     PGD 0 P4D 0
     Oops: 0002 [#1] PREEMPT SMP PTI
     CPU: 0 PID: 205 Comm: modprobe Not tainted 6.1.0-rc8-00588-g76dcd734eca2 #6
     Call Trace:
      <IRQ>
      snd_mts64_interrupt+0x24/0xa0 [snd_mts64]
      parport_irq_handler+0x37/0x50 [parport]
      __handle_irq_event_percpu+0x39/0x190
      handle_irq_event_percpu+0xa/0x30
      handle_irq_event+0x2f/0x50
      handle_edge_irq+0x99/0x1b0
      __common_interrupt+0x5d/0x100
      common_interrupt+0xa0/0xc0
      </IRQ>
      <TASK>
      asm_common_interrupt+0x22/0x40
     RIP: 0010:_raw_write_unlock_irqrestore+0x11/0x30
      parport_claim+0xbd/0x230 [parport]
      snd_mts64_probe+0x14a/0x465 [snd_mts64]
      platform_probe+0x3f/0xa0
      really_probe+0x129/0x2c0
      __driver_probe_device+0x6d/0xc0
      driver_probe_device+0x1a/0xa0
      __device_attach_driver+0x7a/0xb0
      bus_for_each_drv+0x62/0xb0
      __device_attach+0xe4/0x180
      bus_probe_device+0x82/0xa0
      device_add+0x550/0x920
      platform_device_add+0x106/0x220
      snd_mts64_attach+0x2e/0x80 [snd_mts64]
      port_check+0x14/0x20 [parport]
      bus_for_each_dev+0x6e/0xc0
      __parport_register_driver+0x7c/0xb0 [parport]
      snd_mts64_module_init+0x31/0x1000 [snd_mts64]
      do_one_initcall+0x3c/0x1f0
      do_init_module+0x46/0x1c6
      load_module+0x1d8d/0x1e10
      __do_sys_finit_module+0xa2/0xf0
      do_syscall_64+0x37/0x90
      entry_SYSCALL_64_after_hwframe+0x63/0xcd
      </TASK>
     Kernel panic - not syncing: Fatal exception in interrupt
     Rebooting in 1 seconds..
    
    The mts wa not initialized during interrupt,  we add check for
    mts to fix this bug.
    
    Fixes: 68ab801e32bb ("[ALSA] Add snd-mts64 driver for ESI Miditerminal 4140")
    Signed-off-by: Gaosheng Cui <cuigaosheng1@huawei.com>
    Link: https://lore.kernel.org/r/20221206061004.1222966-1-cuigaosheng1@huawei.com
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 0649129359219ce6ff380ec401f87308485c6ae3
Author: Gaosheng Cui <cuigaosheng1@huawei.com>
Date:   Tue Dec 6 14:10:04 2022 +0800

    ALSA: mts64: fix possible null-ptr-defer in snd_mts64_interrupt
    
    [ Upstream commit cf2ea3c86ad90d63d1c572b43e1ca9276b0357ad ]
    
    I got a null-ptr-defer error report when I do the following tests
    on the qemu platform:
    
    make defconfig and CONFIG_PARPORT=m, CONFIG_PARPORT_PC=m,
    CONFIG_SND_MTS64=m
    
    Then making test scripts:
    cat>test_mod1.sh<<EOF
    modprobe snd-mts64
    modprobe snd-mts64
    EOF
    
    Executing the script, perhaps several times, we will get a null-ptr-defer
    report, as follow:
    
    syzkaller:~# ./test_mod.sh
    snd_mts64: probe of snd_mts64.0 failed with error -5
    modprobe: ERROR: could not insert 'snd_mts64': No such device
     BUG: kernel NULL pointer dereference, address: 0000000000000000
     #PF: supervisor write access in kernel mode
     #PF: error_code(0x0002) - not-present page
     PGD 0 P4D 0
     Oops: 0002 [#1] PREEMPT SMP PTI
     CPU: 0 PID: 205 Comm: modprobe Not tainted 6.1.0-rc8-00588-g76dcd734eca2 #6
     Call Trace:
      <IRQ>
      snd_mts64_interrupt+0x24/0xa0 [snd_mts64]
      parport_irq_handler+0x37/0x50 [parport]
      __handle_irq_event_percpu+0x39/0x190
      handle_irq_event_percpu+0xa/0x30
      handle_irq_event+0x2f/0x50
      handle_edge_irq+0x99/0x1b0
      __common_interrupt+0x5d/0x100
      common_interrupt+0xa0/0xc0
      </IRQ>
      <TASK>
      asm_common_interrupt+0x22/0x40
     RIP: 0010:_raw_write_unlock_irqrestore+0x11/0x30
      parport_claim+0xbd/0x230 [parport]
      snd_mts64_probe+0x14a/0x465 [snd_mts64]
      platform_probe+0x3f/0xa0
      really_probe+0x129/0x2c0
      __driver_probe_device+0x6d/0xc0
      driver_probe_device+0x1a/0xa0
      __device_attach_driver+0x7a/0xb0
      bus_for_each_drv+0x62/0xb0
      __device_attach+0xe4/0x180
      bus_probe_device+0x82/0xa0
      device_add+0x550/0x920
      platform_device_add+0x106/0x220
      snd_mts64_attach+0x2e/0x80 [snd_mts64]
      port_check+0x14/0x20 [parport]
      bus_for_each_dev+0x6e/0xc0
      __parport_register_driver+0x7c/0xb0 [parport]
      snd_mts64_module_init+0x31/0x1000 [snd_mts64]
      do_one_initcall+0x3c/0x1f0
      do_init_module+0x46/0x1c6
      load_module+0x1d8d/0x1e10
      __do_sys_finit_module+0xa2/0xf0
      do_syscall_64+0x37/0x90
      entry_SYSCALL_64_after_hwframe+0x63/0xcd
      </TASK>
     Kernel panic - not syncing: Fatal exception in interrupt
     Rebooting in 1 seconds..
    
    The mts wa not initialized during interrupt,  we add check for
    mts to fix this bug.
    
    Fixes: 68ab801e32bb ("[ALSA] Add snd-mts64 driver for ESI Miditerminal 4140")
    Signed-off-by: Gaosheng Cui <cuigaosheng1@huawei.com>
    Link: https://lore.kernel.org/r/20221206061004.1222966-1-cuigaosheng1@huawei.com
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 06ec592389f2be3199779ab823c4323dcfd2121f
Author: Gaosheng Cui <cuigaosheng1@huawei.com>
Date:   Tue Dec 6 14:10:04 2022 +0800

    ALSA: mts64: fix possible null-ptr-defer in snd_mts64_interrupt
    
    [ Upstream commit cf2ea3c86ad90d63d1c572b43e1ca9276b0357ad ]
    
    I got a null-ptr-defer error report when I do the following tests
    on the qemu platform:
    
    make defconfig and CONFIG_PARPORT=m, CONFIG_PARPORT_PC=m,
    CONFIG_SND_MTS64=m
    
    Then making test scripts:
    cat>test_mod1.sh<<EOF
    modprobe snd-mts64
    modprobe snd-mts64
    EOF
    
    Executing the script, perhaps several times, we will get a null-ptr-defer
    report, as follow:
    
    syzkaller:~# ./test_mod.sh
    snd_mts64: probe of snd_mts64.0 failed with error -5
    modprobe: ERROR: could not insert 'snd_mts64': No such device
     BUG: kernel NULL pointer dereference, address: 0000000000000000
     #PF: supervisor write access in kernel mode
     #PF: error_code(0x0002) - not-present page
     PGD 0 P4D 0
     Oops: 0002 [#1] PREEMPT SMP PTI
     CPU: 0 PID: 205 Comm: modprobe Not tainted 6.1.0-rc8-00588-g76dcd734eca2 #6
     Call Trace:
      <IRQ>
      snd_mts64_interrupt+0x24/0xa0 [snd_mts64]
      parport_irq_handler+0x37/0x50 [parport]
      __handle_irq_event_percpu+0x39/0x190
      handle_irq_event_percpu+0xa/0x30
      handle_irq_event+0x2f/0x50
      handle_edge_irq+0x99/0x1b0
      __common_interrupt+0x5d/0x100
      common_interrupt+0xa0/0xc0
      </IRQ>
      <TASK>
      asm_common_interrupt+0x22/0x40
     RIP: 0010:_raw_write_unlock_irqrestore+0x11/0x30
      parport_claim+0xbd/0x230 [parport]
      snd_mts64_probe+0x14a/0x465 [snd_mts64]
      platform_probe+0x3f/0xa0
      really_probe+0x129/0x2c0
      __driver_probe_device+0x6d/0xc0
      driver_probe_device+0x1a/0xa0
      __device_attach_driver+0x7a/0xb0
      bus_for_each_drv+0x62/0xb0
      __device_attach+0xe4/0x180
      bus_probe_device+0x82/0xa0
      device_add+0x550/0x920
      platform_device_add+0x106/0x220
      snd_mts64_attach+0x2e/0x80 [snd_mts64]
      port_check+0x14/0x20 [parport]
      bus_for_each_dev+0x6e/0xc0
      __parport_register_driver+0x7c/0xb0 [parport]
      snd_mts64_module_init+0x31/0x1000 [snd_mts64]
      do_one_initcall+0x3c/0x1f0
      do_init_module+0x46/0x1c6
      load_module+0x1d8d/0x1e10
      __do_sys_finit_module+0xa2/0xf0
      do_syscall_64+0x37/0x90
      entry_SYSCALL_64_after_hwframe+0x63/0xcd
      </TASK>
     Kernel panic - not syncing: Fatal exception in interrupt
     Rebooting in 1 seconds..
    
    The mts wa not initialized during interrupt,  we add check for
    mts to fix this bug.
    
    Fixes: 68ab801e32bb ("[ALSA] Add snd-mts64 driver for ESI Miditerminal 4140")
    Signed-off-by: Gaosheng Cui <cuigaosheng1@huawei.com>
    Link: https://lore.kernel.org/r/20221206061004.1222966-1-cuigaosheng1@huawei.com
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit e325285de2cd82fbdcc4df8898e4c6a597674816
Author: Cristian Marussi <cristian.marussi@arm.com>
Date:   Thu Dec 22 18:38:23 2022 +0000

    firmware: arm_scmi: Fix virtio channels cleanup on shutdown
    
    When unloading the SCMI core stack module, configured to use the virtio
    SCMI transport, LOCKDEP reports the splat down below about unsafe locks
    dependencies.
    
    In order to avoid this possible unsafe locking scenario call upfront
    virtio_break_device() before getting hold of vioch->lock.
    
    =====================================================
     WARNING: HARDIRQ-safe -> HARDIRQ-unsafe lock order detected
     6.1.0-00067-g6b934395ba07-dirty #4 Not tainted
     -----------------------------------------------------
     rmmod/307 [HC0[0]:SC0[0]:HE0:SE1] is trying to acquire:
     ffff000080c510e0 (&dev->vqs_list_lock){+.+.}-{3:3}, at: virtio_break_device+0x28/0x68
    
     and this task is already holding:
     ffff00008288ada0 (&channels[i].lock){-.-.}-{3:3}, at: virtio_chan_free+0x60/0x168 [scmi_module]
    
     which would create a new lock dependency:
      (&channels[i].lock){-.-.}-{3:3} -> (&dev->vqs_list_lock){+.+.}-{3:3}
    
     but this new dependency connects a HARDIRQ-irq-safe lock:
      (&channels[i].lock){-.-.}-{3:3}
    
     ... which became HARDIRQ-irq-safe at:
       lock_acquire+0x128/0x398
       _raw_spin_lock_irqsave+0x78/0x140
       scmi_vio_complete_cb+0xb4/0x3b8 [scmi_module]
       vring_interrupt+0x84/0x120
       vm_interrupt+0x94/0xe8
       __handle_irq_event_percpu+0xb4/0x3d8
       handle_irq_event_percpu+0x20/0x68
       handle_irq_event+0x50/0xb0
       handle_fasteoi_irq+0xac/0x138
       generic_handle_domain_irq+0x34/0x50
       gic_handle_irq+0xa0/0xd8
       call_on_irq_stack+0x2c/0x54
       do_interrupt_handler+0x8c/0x90
       el1_interrupt+0x40/0x78
       el1h_64_irq_handler+0x18/0x28
       el1h_64_irq+0x64/0x68
       _raw_write_unlock_irq+0x48/0x80
       ep_start_scan+0xf0/0x128
       do_epoll_wait+0x390/0x858
       do_compat_epoll_pwait.part.34+0x1c/0xb8
       __arm64_sys_epoll_pwait+0x80/0xd0
       invoke_syscall+0x4c/0x110
       el0_svc_common.constprop.3+0x98/0x120
       do_el0_svc+0x34/0xd0
       el0_svc+0x40/0x98
       el0t_64_sync_handler+0x98/0xc0
       el0t_64_sync+0x170/0x174
    
     to a HARDIRQ-irq-unsafe lock:
      (&dev->vqs_list_lock){+.+.}-{3:3}
    
     ... which became HARDIRQ-irq-unsafe at:
     ...
       lock_acquire+0x128/0x398
       _raw_spin_lock+0x58/0x70
       __vring_new_virtqueue+0x130/0x1c0
       vring_create_virtqueue+0xc4/0x2b8
       vm_find_vqs+0x20c/0x430
       init_vq+0x308/0x390
       virtblk_probe+0x114/0x9b0
       virtio_dev_probe+0x1a4/0x248
       really_probe+0xc8/0x3a8
       __driver_probe_device+0x84/0x190
       driver_probe_device+0x44/0x110
       __driver_attach+0x104/0x1e8
       bus_for_each_dev+0x7c/0xd0
       driver_attach+0x2c/0x38
       bus_add_driver+0x1e4/0x258
       driver_register+0x6c/0x128
       register_virtio_driver+0x2c/0x48
       virtio_blk_init+0x70/0xac
       do_one_initcall+0x84/0x420
       kernel_init_freeable+0x2d0/0x340
       kernel_init+0x2c/0x138
       ret_from_fork+0x10/0x20
    
     other info that might help us debug this:
    
      Possible interrupt unsafe locking scenario:
    
            CPU0                    CPU1
            ----                    ----
       lock(&dev->vqs_list_lock);
                                    local_irq_disable();
                                    lock(&channels[i].lock);
                                    lock(&dev->vqs_list_lock);
       <Interrupt>
         lock(&channels[i].lock);
    
      *** DEADLOCK ***
    ================
    
    Fixes: 42e90eb53bf3f ("firmware: arm_scmi: Add a virtio channel refcount")
    Signed-off-by: Cristian Marussi <cristian.marussi@arm.com>
    Link: https://lore.kernel.org/r/20221222183823.518856-6-cristian.marussi@arm.com
    Signed-off-by: Sudeep Holla <sudeep.holla@arm.com>

commit 250eed7b9994d79f9c409f954dbd08e88f5afd83
Author: Gaosheng Cui <cuigaosheng1@huawei.com>
Date:   Tue Dec 6 14:10:04 2022 +0800

    ALSA: mts64: fix possible null-ptr-defer in snd_mts64_interrupt
    
    [ Upstream commit cf2ea3c86ad90d63d1c572b43e1ca9276b0357ad ]
    
    I got a null-ptr-defer error report when I do the following tests
    on the qemu platform:
    
    make defconfig and CONFIG_PARPORT=m, CONFIG_PARPORT_PC=m,
    CONFIG_SND_MTS64=m
    
    Then making test scripts:
    cat>test_mod1.sh<<EOF
    modprobe snd-mts64
    modprobe snd-mts64
    EOF
    
    Executing the script, perhaps several times, we will get a null-ptr-defer
    report, as follow:
    
    syzkaller:~# ./test_mod.sh
    snd_mts64: probe of snd_mts64.0 failed with error -5
    modprobe: ERROR: could not insert 'snd_mts64': No such device
     BUG: kernel NULL pointer dereference, address: 0000000000000000
     #PF: supervisor write access in kernel mode
     #PF: error_code(0x0002) - not-present page
     PGD 0 P4D 0
     Oops: 0002 [#1] PREEMPT SMP PTI
     CPU: 0 PID: 205 Comm: modprobe Not tainted 6.1.0-rc8-00588-g76dcd734eca2 #6
     Call Trace:
      <IRQ>
      snd_mts64_interrupt+0x24/0xa0 [snd_mts64]
      parport_irq_handler+0x37/0x50 [parport]
      __handle_irq_event_percpu+0x39/0x190
      handle_irq_event_percpu+0xa/0x30
      handle_irq_event+0x2f/0x50
      handle_edge_irq+0x99/0x1b0
      __common_interrupt+0x5d/0x100
      common_interrupt+0xa0/0xc0
      </IRQ>
      <TASK>
      asm_common_interrupt+0x22/0x40
     RIP: 0010:_raw_write_unlock_irqrestore+0x11/0x30
      parport_claim+0xbd/0x230 [parport]
      snd_mts64_probe+0x14a/0x465 [snd_mts64]
      platform_probe+0x3f/0xa0
      really_probe+0x129/0x2c0
      __driver_probe_device+0x6d/0xc0
      driver_probe_device+0x1a/0xa0
      __device_attach_driver+0x7a/0xb0
      bus_for_each_drv+0x62/0xb0
      __device_attach+0xe4/0x180
      bus_probe_device+0x82/0xa0
      device_add+0x550/0x920
      platform_device_add+0x106/0x220
      snd_mts64_attach+0x2e/0x80 [snd_mts64]
      port_check+0x14/0x20 [parport]
      bus_for_each_dev+0x6e/0xc0
      __parport_register_driver+0x7c/0xb0 [parport]
      snd_mts64_module_init+0x31/0x1000 [snd_mts64]
      do_one_initcall+0x3c/0x1f0
      do_init_module+0x46/0x1c6
      load_module+0x1d8d/0x1e10
      __do_sys_finit_module+0xa2/0xf0
      do_syscall_64+0x37/0x90
      entry_SYSCALL_64_after_hwframe+0x63/0xcd
      </TASK>
     Kernel panic - not syncing: Fatal exception in interrupt
     Rebooting in 1 seconds..
    
    The mts wa not initialized during interrupt,  we add check for
    mts to fix this bug.
    
    Fixes: 68ab801e32bb ("[ALSA] Add snd-mts64 driver for ESI Miditerminal 4140")
    Signed-off-by: Gaosheng Cui <cuigaosheng1@huawei.com>
    Link: https://lore.kernel.org/r/20221206061004.1222966-1-cuigaosheng1@huawei.com
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 1a763c748acd5540ccc43306c57c9c6c5fb60884
Author: Gaosheng Cui <cuigaosheng1@huawei.com>
Date:   Tue Dec 6 14:10:04 2022 +0800

    ALSA: mts64: fix possible null-ptr-defer in snd_mts64_interrupt
    
    [ Upstream commit cf2ea3c86ad90d63d1c572b43e1ca9276b0357ad ]
    
    I got a null-ptr-defer error report when I do the following tests
    on the qemu platform:
    
    make defconfig and CONFIG_PARPORT=m, CONFIG_PARPORT_PC=m,
    CONFIG_SND_MTS64=m
    
    Then making test scripts:
    cat>test_mod1.sh<<EOF
    modprobe snd-mts64
    modprobe snd-mts64
    EOF
    
    Executing the script, perhaps several times, we will get a null-ptr-defer
    report, as follow:
    
    syzkaller:~# ./test_mod.sh
    snd_mts64: probe of snd_mts64.0 failed with error -5
    modprobe: ERROR: could not insert 'snd_mts64': No such device
     BUG: kernel NULL pointer dereference, address: 0000000000000000
     #PF: supervisor write access in kernel mode
     #PF: error_code(0x0002) - not-present page
     PGD 0 P4D 0
     Oops: 0002 [#1] PREEMPT SMP PTI
     CPU: 0 PID: 205 Comm: modprobe Not tainted 6.1.0-rc8-00588-g76dcd734eca2 #6
     Call Trace:
      <IRQ>
      snd_mts64_interrupt+0x24/0xa0 [snd_mts64]
      parport_irq_handler+0x37/0x50 [parport]
      __handle_irq_event_percpu+0x39/0x190
      handle_irq_event_percpu+0xa/0x30
      handle_irq_event+0x2f/0x50
      handle_edge_irq+0x99/0x1b0
      __common_interrupt+0x5d/0x100
      common_interrupt+0xa0/0xc0
      </IRQ>
      <TASK>
      asm_common_interrupt+0x22/0x40
     RIP: 0010:_raw_write_unlock_irqrestore+0x11/0x30
      parport_claim+0xbd/0x230 [parport]
      snd_mts64_probe+0x14a/0x465 [snd_mts64]
      platform_probe+0x3f/0xa0
      really_probe+0x129/0x2c0
      __driver_probe_device+0x6d/0xc0
      driver_probe_device+0x1a/0xa0
      __device_attach_driver+0x7a/0xb0
      bus_for_each_drv+0x62/0xb0
      __device_attach+0xe4/0x180
      bus_probe_device+0x82/0xa0
      device_add+0x550/0x920
      platform_device_add+0x106/0x220
      snd_mts64_attach+0x2e/0x80 [snd_mts64]
      port_check+0x14/0x20 [parport]
      bus_for_each_dev+0x6e/0xc0
      __parport_register_driver+0x7c/0xb0 [parport]
      snd_mts64_module_init+0x31/0x1000 [snd_mts64]
      do_one_initcall+0x3c/0x1f0
      do_init_module+0x46/0x1c6
      load_module+0x1d8d/0x1e10
      __do_sys_finit_module+0xa2/0xf0
      do_syscall_64+0x37/0x90
      entry_SYSCALL_64_after_hwframe+0x63/0xcd
      </TASK>
     Kernel panic - not syncing: Fatal exception in interrupt
     Rebooting in 1 seconds..
    
    The mts wa not initialized during interrupt,  we add check for
    mts to fix this bug.
    
    Fixes: 68ab801e32bb ("[ALSA] Add snd-mts64 driver for ESI Miditerminal 4140")
    Signed-off-by: Gaosheng Cui <cuigaosheng1@huawei.com>
    Link: https://lore.kernel.org/r/20221206061004.1222966-1-cuigaosheng1@huawei.com
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit cba633b24a98d957e8190ef8bc4d4cdb4f6e9313
Author: Gaosheng Cui <cuigaosheng1@huawei.com>
Date:   Tue Dec 6 14:10:04 2022 +0800

    ALSA: mts64: fix possible null-ptr-defer in snd_mts64_interrupt
    
    [ Upstream commit cf2ea3c86ad90d63d1c572b43e1ca9276b0357ad ]
    
    I got a null-ptr-defer error report when I do the following tests
    on the qemu platform:
    
    make defconfig and CONFIG_PARPORT=m, CONFIG_PARPORT_PC=m,
    CONFIG_SND_MTS64=m
    
    Then making test scripts:
    cat>test_mod1.sh<<EOF
    modprobe snd-mts64
    modprobe snd-mts64
    EOF
    
    Executing the script, perhaps several times, we will get a null-ptr-defer
    report, as follow:
    
    syzkaller:~# ./test_mod.sh
    snd_mts64: probe of snd_mts64.0 failed with error -5
    modprobe: ERROR: could not insert 'snd_mts64': No such device
     BUG: kernel NULL pointer dereference, address: 0000000000000000
     #PF: supervisor write access in kernel mode
     #PF: error_code(0x0002) - not-present page
     PGD 0 P4D 0
     Oops: 0002 [#1] PREEMPT SMP PTI
     CPU: 0 PID: 205 Comm: modprobe Not tainted 6.1.0-rc8-00588-g76dcd734eca2 #6
     Call Trace:
      <IRQ>
      snd_mts64_interrupt+0x24/0xa0 [snd_mts64]
      parport_irq_handler+0x37/0x50 [parport]
      __handle_irq_event_percpu+0x39/0x190
      handle_irq_event_percpu+0xa/0x30
      handle_irq_event+0x2f/0x50
      handle_edge_irq+0x99/0x1b0
      __common_interrupt+0x5d/0x100
      common_interrupt+0xa0/0xc0
      </IRQ>
      <TASK>
      asm_common_interrupt+0x22/0x40
     RIP: 0010:_raw_write_unlock_irqrestore+0x11/0x30
      parport_claim+0xbd/0x230 [parport]
      snd_mts64_probe+0x14a/0x465 [snd_mts64]
      platform_probe+0x3f/0xa0
      really_probe+0x129/0x2c0
      __driver_probe_device+0x6d/0xc0
      driver_probe_device+0x1a/0xa0
      __device_attach_driver+0x7a/0xb0
      bus_for_each_drv+0x62/0xb0
      __device_attach+0xe4/0x180
      bus_probe_device+0x82/0xa0
      device_add+0x550/0x920
      platform_device_add+0x106/0x220
      snd_mts64_attach+0x2e/0x80 [snd_mts64]
      port_check+0x14/0x20 [parport]
      bus_for_each_dev+0x6e/0xc0
      __parport_register_driver+0x7c/0xb0 [parport]
      snd_mts64_module_init+0x31/0x1000 [snd_mts64]
      do_one_initcall+0x3c/0x1f0
      do_init_module+0x46/0x1c6
      load_module+0x1d8d/0x1e10
      __do_sys_finit_module+0xa2/0xf0
      do_syscall_64+0x37/0x90
      entry_SYSCALL_64_after_hwframe+0x63/0xcd
      </TASK>
     Kernel panic - not syncing: Fatal exception in interrupt
     Rebooting in 1 seconds..
    
    The mts wa not initialized during interrupt,  we add check for
    mts to fix this bug.
    
    Fixes: 68ab801e32bb ("[ALSA] Add snd-mts64 driver for ESI Miditerminal 4140")
    Signed-off-by: Gaosheng Cui <cuigaosheng1@huawei.com>
    Link: https://lore.kernel.org/r/20221206061004.1222966-1-cuigaosheng1@huawei.com
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit cf2ea3c86ad90d63d1c572b43e1ca9276b0357ad
Author: Gaosheng Cui <cuigaosheng1@huawei.com>
Date:   Tue Dec 6 14:10:04 2022 +0800

    ALSA: mts64: fix possible null-ptr-defer in snd_mts64_interrupt
    
    I got a null-ptr-defer error report when I do the following tests
    on the qemu platform:
    
    make defconfig and CONFIG_PARPORT=m, CONFIG_PARPORT_PC=m,
    CONFIG_SND_MTS64=m
    
    Then making test scripts:
    cat>test_mod1.sh<<EOF
    modprobe snd-mts64
    modprobe snd-mts64
    EOF
    
    Executing the script, perhaps several times, we will get a null-ptr-defer
    report, as follow:
    
    syzkaller:~# ./test_mod.sh
    snd_mts64: probe of snd_mts64.0 failed with error -5
    modprobe: ERROR: could not insert 'snd_mts64': No such device
     BUG: kernel NULL pointer dereference, address: 0000000000000000
     #PF: supervisor write access in kernel mode
     #PF: error_code(0x0002) - not-present page
     PGD 0 P4D 0
     Oops: 0002 [#1] PREEMPT SMP PTI
     CPU: 0 PID: 205 Comm: modprobe Not tainted 6.1.0-rc8-00588-g76dcd734eca2 #6
     Call Trace:
      <IRQ>
      snd_mts64_interrupt+0x24/0xa0 [snd_mts64]
      parport_irq_handler+0x37/0x50 [parport]
      __handle_irq_event_percpu+0x39/0x190
      handle_irq_event_percpu+0xa/0x30
      handle_irq_event+0x2f/0x50
      handle_edge_irq+0x99/0x1b0
      __common_interrupt+0x5d/0x100
      common_interrupt+0xa0/0xc0
      </IRQ>
      <TASK>
      asm_common_interrupt+0x22/0x40
     RIP: 0010:_raw_write_unlock_irqrestore+0x11/0x30
      parport_claim+0xbd/0x230 [parport]
      snd_mts64_probe+0x14a/0x465 [snd_mts64]
      platform_probe+0x3f/0xa0
      really_probe+0x129/0x2c0
      __driver_probe_device+0x6d/0xc0
      driver_probe_device+0x1a/0xa0
      __device_attach_driver+0x7a/0xb0
      bus_for_each_drv+0x62/0xb0
      __device_attach+0xe4/0x180
      bus_probe_device+0x82/0xa0
      device_add+0x550/0x920
      platform_device_add+0x106/0x220
      snd_mts64_attach+0x2e/0x80 [snd_mts64]
      port_check+0x14/0x20 [parport]
      bus_for_each_dev+0x6e/0xc0
      __parport_register_driver+0x7c/0xb0 [parport]
      snd_mts64_module_init+0x31/0x1000 [snd_mts64]
      do_one_initcall+0x3c/0x1f0
      do_init_module+0x46/0x1c6
      load_module+0x1d8d/0x1e10
      __do_sys_finit_module+0xa2/0xf0
      do_syscall_64+0x37/0x90
      entry_SYSCALL_64_after_hwframe+0x63/0xcd
      </TASK>
     Kernel panic - not syncing: Fatal exception in interrupt
     Rebooting in 1 seconds..
    
    The mts wa not initialized during interrupt,  we add check for
    mts to fix this bug.
    
    Fixes: 68ab801e32bb ("[ALSA] Add snd-mts64 driver for ESI Miditerminal 4140")
    Signed-off-by: Gaosheng Cui <cuigaosheng1@huawei.com>
    Link: https://lore.kernel.org/r/20221206061004.1222966-1-cuigaosheng1@huawei.com
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

commit 12c1dc8e7441773c74dc62fab76553c24015f6e1
Author: Abel Wu <wuyun.abel@bytedance.com>
Date:   Thu Aug 11 20:41:57 2022 +0800

    mm/mempolicy: fix lock contention on mems_allowed
    
    The mems_allowed field can be modified by other tasks, so it isn't safe to
    access it with alloc_lock unlocked even in the current process context.
    
    Say there are two tasks: A from cpusetA is performing set_mempolicy(2),
    and B is changing cpusetA's cpuset.mems:
    
      A (set_mempolicy)             B (echo xx > cpuset.mems)
      -------------------------------------------------------
      pol = mpol_new();
                                    update_tasks_nodemask(cpusetA) {
                                      foreach t in cpusetA {
                                        cpuset_change_task_nodemask(t) {
      mpol_set_nodemask(pol) {
                                          task_lock(t); // t could be A
        new = f(A->mems_allowed);
                                          update t->mems_allowed;
        pol.create(pol, new);
                                          task_unlock(t);
      }
                                        }
                                      }
                                    }
      task_lock(A);
      A->mempolicy = pol;
      task_unlock(A);
    
    In this case A's pol->nodes is computed by old mems_allowed, and could
    be inconsistent with A's new mems_allowed.
    
    While it is different when replacing vmas' policy: the pol->nodes is
    gone wild only when current_cpuset_is_being_rebound():
    
      A (mbind)                     B (echo xx > cpuset.mems)
      -------------------------------------------------------
      pol = mpol_new();
      mmap_write_lock(A->mm);
                                    cpuset_being_rebound = cpusetA;
                                    update_tasks_nodemask(cpusetA) {
                                      foreach t in cpusetA {
                                        cpuset_change_task_nodemask(t) {
      mpol_set_nodemask(pol) {
                                          task_lock(t); // t could be A
        mask = f(A->mems_allowed);
                                          update t->mems_allowed;
        pol.create(pol, mask);
                                          task_unlock(t);
      }
                                        }
      foreach v in A->mm {
        if (cpuset_being_rebound == cpusetA)
          pol.rebind(pol, cpuset.mems);
        v->vma_policy = pol;
      }
      mmap_write_unlock(A->mm);
                                        mmap_write_lock(t->mm);
                                        mpol_rebind_mm(t->mm);
                                        mmap_write_unlock(t->mm);
                                      }
                                    }
                                    cpuset_being_rebound = NULL;
    
    In this case, the cpuset.mems, which has already done updating, is finally
    used for calculating pol->nodes, rather than A->mems_allowed.  So it is OK
    to call mpol_set_nodemask() with alloc_lock unlocked when doing mbind(2).
    
    Link: https://lkml.kernel.org/r/20220811124157.74888-1-wuyun.abel@bytedance.com
    Fixes: 78b132e9bae9 ("mm/mempolicy: remove or narrow the lock on current")
    Signed-off-by: Abel Wu <wuyun.abel@bytedance.com>
    Acked-by: Michal Hocko <mhocko@suse.com>
    Reviewed-by: Wei Yang <richard.weiyang@gmail.com>
    Reviewed-by: Muchun Song <songmuchun@bytedance.com>
    Cc: Vlastimil Babka <vbabka@suse.cz>
    Cc: Mel Gorman <mgorman@techsingularity.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>

commit 357321557920c805de2b14832002465c320eea4f
Author: Waiman Long <longman@redhat.com>
Date:   Fri Aug 12 14:30:33 2022 -0400

    mm/slab_common: Deleting kobject in kmem_cache_destroy() without holding slab_mutex/cpu_hotplug_lock
    
    [ Upstream commit 0495e337b7039191dfce6e03f5f830454b1fae6b ]
    
    A circular locking problem is reported by lockdep due to the following
    circular locking dependency.
    
      +--> cpu_hotplug_lock --> slab_mutex --> kn->active --+
      |                                                     |
      +-----------------------------------------------------+
    
    The forward cpu_hotplug_lock ==> slab_mutex ==> kn->active dependency
    happens in
    
      kmem_cache_destroy(): cpus_read_lock(); mutex_lock(&slab_mutex);
      ==> sysfs_slab_unlink()
          ==> kobject_del()
              ==> kernfs_remove()
                  ==> __kernfs_remove()
                      ==> kernfs_drain(): rwsem_acquire(&kn->dep_map, ...);
    
    The backward kn->active ==> cpu_hotplug_lock dependency happens in
    
      kernfs_fop_write_iter(): kernfs_get_active();
      ==> slab_attr_store()
          ==> cpu_partial_store()
              ==> flush_all(): cpus_read_lock()
    
    One way to break this circular locking chain is to avoid holding
    cpu_hotplug_lock and slab_mutex while deleting the kobject in
    sysfs_slab_unlink() which should be equivalent to doing a write_lock
    and write_unlock pair of the kn->active virtual lock.
    
    Since the kobject structures are not protected by slab_mutex or the
    cpu_hotplug_lock, we can certainly release those locks before doing
    the delete operation.
    
    Move sysfs_slab_unlink() and sysfs_slab_release() to the newly
    created kmem_cache_release() and call it outside the slab_mutex &
    cpu_hotplug_lock critical sections. There will be a slight delay
    in the deletion of sysfs files if kmem_cache_release() is called
    indirectly from a work function.
    
    Fixes: 5a836bf6b09f ("mm: slub: move flush_cpu_slab() invocations __free_slab() invocations out of IRQ context")
    Signed-off-by: Waiman Long <longman@redhat.com>
    Reviewed-by: Hyeonggon Yoo <42.hyeyoo@gmail.com>
    Reviewed-by: Roman Gushchin <roman.gushchin@linux.dev>
    Acked-by: David Rientjes <rientjes@google.com>
    Link: https://lore.kernel.org/all/YwOImVd+nRUsSAga@hyeyoo/
    Signed-off-by: Vlastimil Babka <vbabka@suse.cz>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 0495e337b7039191dfce6e03f5f830454b1fae6b
Author: Waiman Long <longman@redhat.com>
Date:   Fri Aug 12 14:30:33 2022 -0400

    mm/slab_common: Deleting kobject in kmem_cache_destroy() without holding slab_mutex/cpu_hotplug_lock
    
    A circular locking problem is reported by lockdep due to the following
    circular locking dependency.
    
      +--> cpu_hotplug_lock --> slab_mutex --> kn->active --+
      |                                                     |
      +-----------------------------------------------------+
    
    The forward cpu_hotplug_lock ==> slab_mutex ==> kn->active dependency
    happens in
    
      kmem_cache_destroy(): cpus_read_lock(); mutex_lock(&slab_mutex);
      ==> sysfs_slab_unlink()
          ==> kobject_del()
              ==> kernfs_remove()
                  ==> __kernfs_remove()
                      ==> kernfs_drain(): rwsem_acquire(&kn->dep_map, ...);
    
    The backward kn->active ==> cpu_hotplug_lock dependency happens in
    
      kernfs_fop_write_iter(): kernfs_get_active();
      ==> slab_attr_store()
          ==> cpu_partial_store()
              ==> flush_all(): cpus_read_lock()
    
    One way to break this circular locking chain is to avoid holding
    cpu_hotplug_lock and slab_mutex while deleting the kobject in
    sysfs_slab_unlink() which should be equivalent to doing a write_lock
    and write_unlock pair of the kn->active virtual lock.
    
    Since the kobject structures are not protected by slab_mutex or the
    cpu_hotplug_lock, we can certainly release those locks before doing
    the delete operation.
    
    Move sysfs_slab_unlink() and sysfs_slab_release() to the newly
    created kmem_cache_release() and call it outside the slab_mutex &
    cpu_hotplug_lock critical sections. There will be a slight delay
    in the deletion of sysfs files if kmem_cache_release() is called
    indirectly from a work function.
    
    Fixes: 5a836bf6b09f ("mm: slub: move flush_cpu_slab() invocations __free_slab() invocations out of IRQ context")
    Signed-off-by: Waiman Long <longman@redhat.com>
    Reviewed-by: Hyeonggon Yoo <42.hyeyoo@gmail.com>
    Reviewed-by: Roman Gushchin <roman.gushchin@linux.dev>
    Acked-by: David Rientjes <rientjes@google.com>
    Link: https://lore.kernel.org/all/YwOImVd+nRUsSAga@hyeyoo/
    Signed-off-by: Vlastimil Babka <vbabka@suse.cz>

commit 1aa262c1d056551dd1246115af8b7e351184deae
Author: Naohiro Aota <naohiro.aota@wdc.com>
Date:   Mon Aug 22 15:07:03 2022 +0900

    btrfs: replace BTRFS_MAX_EXTENT_SIZE with fs_info->max_extent_size
    
    commit f7b12a62f008a3041f42f2426983e59a6a0a3c59 upstream
    
    On zoned filesystem, data write out is limited by max_zone_append_size,
    and a large ordered extent is split according the size of a bio. OTOH,
    the number of extents to be written is calculated using
    BTRFS_MAX_EXTENT_SIZE, and that estimated number is used to reserve the
    metadata bytes to update and/or create the metadata items.
    
    The metadata reservation is done at e.g, btrfs_buffered_write() and then
    released according to the estimation changes. Thus, if the number of extent
    increases massively, the reserved metadata can run out.
    
    The increase of the number of extents easily occurs on zoned filesystem
    if BTRFS_MAX_EXTENT_SIZE > max_zone_append_size. And, it causes the
    following warning on a small RAM environment with disabling metadata
    over-commit (in the following patch).
    
    [75721.498492] ------------[ cut here ]------------
    [75721.505624] BTRFS: block rsv 1 returned -28
    [75721.512230] WARNING: CPU: 24 PID: 2327559 at fs/btrfs/block-rsv.c:537 btrfs_use_block_rsv+0x560/0x760 [btrfs]
    [75721.581854] CPU: 24 PID: 2327559 Comm: kworker/u64:10 Kdump: loaded Tainted: G        W         5.18.0-rc2-BTRFS-ZNS+ #109
    [75721.597200] Hardware name: Supermicro Super Server/H12SSL-NT, BIOS 2.0 02/22/2021
    [75721.607310] Workqueue: btrfs-endio-write btrfs_work_helper [btrfs]
    [75721.616209] RIP: 0010:btrfs_use_block_rsv+0x560/0x760 [btrfs]
    [75721.646649] RSP: 0018:ffffc9000fbdf3e0 EFLAGS: 00010286
    [75721.654126] RAX: 0000000000000000 RBX: 0000000000004000 RCX: 0000000000000000
    [75721.663524] RDX: 0000000000000004 RSI: 0000000000000008 RDI: fffff52001f7be6e
    [75721.672921] RBP: ffffc9000fbdf420 R08: 0000000000000001 R09: ffff889f8d1fc6c7
    [75721.682493] R10: ffffed13f1a3f8d8 R11: 0000000000000001 R12: ffff88980a3c0e28
    [75721.692284] R13: ffff889b66590000 R14: ffff88980a3c0e40 R15: ffff88980a3c0e8a
    [75721.701878] FS:  0000000000000000(0000) GS:ffff889f8d000000(0000) knlGS:0000000000000000
    [75721.712601] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [75721.720726] CR2: 000055d12e05c018 CR3: 0000800193594000 CR4: 0000000000350ee0
    [75721.730499] Call Trace:
    [75721.735166]  <TASK>
    [75721.739886]  btrfs_alloc_tree_block+0x1e1/0x1100 [btrfs]
    [75721.747545]  ? btrfs_alloc_logged_file_extent+0x550/0x550 [btrfs]
    [75721.756145]  ? btrfs_get_32+0xea/0x2d0 [btrfs]
    [75721.762852]  ? btrfs_get_32+0xea/0x2d0 [btrfs]
    [75721.769520]  ? push_leaf_left+0x420/0x620 [btrfs]
    [75721.776431]  ? memcpy+0x4e/0x60
    [75721.781931]  split_leaf+0x433/0x12d0 [btrfs]
    [75721.788392]  ? btrfs_get_token_32+0x580/0x580 [btrfs]
    [75721.795636]  ? push_for_double_split.isra.0+0x420/0x420 [btrfs]
    [75721.803759]  ? leaf_space_used+0x15d/0x1a0 [btrfs]
    [75721.811156]  btrfs_search_slot+0x1bc3/0x2790 [btrfs]
    [75721.818300]  ? lock_downgrade+0x7c0/0x7c0
    [75721.824411]  ? free_extent_buffer.part.0+0x107/0x200 [btrfs]
    [75721.832456]  ? split_leaf+0x12d0/0x12d0 [btrfs]
    [75721.839149]  ? free_extent_buffer.part.0+0x14f/0x200 [btrfs]
    [75721.846945]  ? free_extent_buffer+0x13/0x20 [btrfs]
    [75721.853960]  ? btrfs_release_path+0x4b/0x190 [btrfs]
    [75721.861429]  btrfs_csum_file_blocks+0x85c/0x1500 [btrfs]
    [75721.869313]  ? rcu_read_lock_sched_held+0x16/0x80
    [75721.876085]  ? lock_release+0x552/0xf80
    [75721.881957]  ? btrfs_del_csums+0x8c0/0x8c0 [btrfs]
    [75721.888886]  ? __kasan_check_write+0x14/0x20
    [75721.895152]  ? do_raw_read_unlock+0x44/0x80
    [75721.901323]  ? _raw_write_lock_irq+0x60/0x80
    [75721.907983]  ? btrfs_global_root+0xb9/0xe0 [btrfs]
    [75721.915166]  ? btrfs_csum_root+0x12b/0x180 [btrfs]
    [75721.921918]  ? btrfs_get_global_root+0x820/0x820 [btrfs]
    [75721.929166]  ? _raw_write_unlock+0x23/0x40
    [75721.935116]  ? unpin_extent_cache+0x1e3/0x390 [btrfs]
    [75721.942041]  btrfs_finish_ordered_io.isra.0+0xa0c/0x1dc0 [btrfs]
    [75721.949906]  ? try_to_wake_up+0x30/0x14a0
    [75721.955700]  ? btrfs_unlink_subvol+0xda0/0xda0 [btrfs]
    [75721.962661]  ? rcu_read_lock_sched_held+0x16/0x80
    [75721.969111]  ? lock_acquire+0x41b/0x4c0
    [75721.974982]  finish_ordered_fn+0x15/0x20 [btrfs]
    [75721.981639]  btrfs_work_helper+0x1af/0xa80 [btrfs]
    [75721.988184]  ? _raw_spin_unlock_irq+0x28/0x50
    [75721.994643]  process_one_work+0x815/0x1460
    [75722.000444]  ? pwq_dec_nr_in_flight+0x250/0x250
    [75722.006643]  ? do_raw_spin_trylock+0xbb/0x190
    [75722.013086]  worker_thread+0x59a/0xeb0
    [75722.018511]  kthread+0x2ac/0x360
    [75722.023428]  ? process_one_work+0x1460/0x1460
    [75722.029431]  ? kthread_complete_and_exit+0x30/0x30
    [75722.036044]  ret_from_fork+0x22/0x30
    [75722.041255]  </TASK>
    [75722.045047] irq event stamp: 0
    [75722.049703] hardirqs last  enabled at (0): [<0000000000000000>] 0x0
    [75722.057610] hardirqs last disabled at (0): [<ffffffff8118a94a>] copy_process+0x1c1a/0x66b0
    [75722.067533] softirqs last  enabled at (0): [<ffffffff8118a989>] copy_process+0x1c59/0x66b0
    [75722.077423] softirqs last disabled at (0): [<0000000000000000>] 0x0
    [75722.085335] ---[ end trace 0000000000000000 ]---
    
    To fix the estimation, we need to introduce fs_info->max_extent_size to
    replace BTRFS_MAX_EXTENT_SIZE, which allow setting the different size for
    regular vs zoned filesystem.
    
    Set fs_info->max_extent_size to BTRFS_MAX_EXTENT_SIZE by default. On zoned
    filesystem, it is set to fs_info->max_zone_append_size.
    
    CC: stable@vger.kernel.org # 5.12+
    Fixes: d8e3fb106f39 ("btrfs: zoned: use ZONE_APPEND write for zoned mode")
    Reviewed-by: Johannes Thumshirn <johannes.thumshirn@wdc.com>
    Signed-off-by: Naohiro Aota <naohiro.aota@wdc.com>
    Signed-off-by: David Sterba <dsterba@suse.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 36a88efe8747ea90b94519345aa0795350d463f1
Author: Zhang Yi <yi.zhang@huawei.com>
Date:   Sat Jun 11 21:04:26 2022 +0800

    jbd2: fix outstanding credits assert in jbd2_journal_commit_transaction()
    
    [ Upstream commit a89573ce4ad32f19f43ec669771726817e185be0 ]
    
    We catch an assert problem in jbd2_journal_commit_transaction() when
    doing fsstress and request falut injection tests. The problem is
    happened in a race condition between jbd2_journal_commit_transaction()
    and ext4_end_io_end(). Firstly, ext4_writepages() writeback dirty pages
    and start reserved handle, and then the journal was aborted due to some
    previous metadata IO error, jbd2_journal_abort() start to commit current
    running transaction, the committing procedure could be raced by
    ext4_end_io_end() and lead to subtract j_reserved_credits twice from
    commit_transaction->t_outstanding_credits, finally the
    t_outstanding_credits is mistakenly smaller than t_nr_buffers and
    trigger assert.
    
    kjournald2           kworker
    
    jbd2_journal_commit_transaction()
     write_unlock(&journal->j_state_lock);
     atomic_sub(j_reserved_credits, t_outstanding_credits); //sub once
    
                         jbd2_journal_start_reserved()
                          start_this_handle()  //detect aborted journal
                          jbd2_journal_free_reserved()  //get running transaction
                           read_lock(&journal->j_state_lock)
                            __jbd2_journal_unreserve_handle()
                           atomic_sub(j_reserved_credits, t_outstanding_credits);
                           //sub again
                           read_unlock(&journal->j_state_lock);
    
     journal->j_running_transaction = NULL;
     J_ASSERT(t_nr_buffers <= t_outstanding_credits) //bomb!!!
    
    Fix this issue by using journal->j_state_lock to protect the subtraction
    in jbd2_journal_commit_transaction().
    
    Fixes: 96f1e0974575 ("jbd2: avoid long hold times of j_state_lock while committing a transaction")
    Signed-off-by: Zhang Yi <yi.zhang@huawei.com>
    Reviewed-by: Jan Kara <jack@suse.cz>
    Link: https://lore.kernel.org/r/20220611130426.2013258-1-yi.zhang@huawei.com
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 914bf4aa2d5bfc4a83866410dcd661a0fe955cb2
Author: Zhang Yi <yi.zhang@huawei.com>
Date:   Sat Jun 11 21:04:26 2022 +0800

    jbd2: fix outstanding credits assert in jbd2_journal_commit_transaction()
    
    [ Upstream commit a89573ce4ad32f19f43ec669771726817e185be0 ]
    
    We catch an assert problem in jbd2_journal_commit_transaction() when
    doing fsstress and request falut injection tests. The problem is
    happened in a race condition between jbd2_journal_commit_transaction()
    and ext4_end_io_end(). Firstly, ext4_writepages() writeback dirty pages
    and start reserved handle, and then the journal was aborted due to some
    previous metadata IO error, jbd2_journal_abort() start to commit current
    running transaction, the committing procedure could be raced by
    ext4_end_io_end() and lead to subtract j_reserved_credits twice from
    commit_transaction->t_outstanding_credits, finally the
    t_outstanding_credits is mistakenly smaller than t_nr_buffers and
    trigger assert.
    
    kjournald2           kworker
    
    jbd2_journal_commit_transaction()
     write_unlock(&journal->j_state_lock);
     atomic_sub(j_reserved_credits, t_outstanding_credits); //sub once
    
                         jbd2_journal_start_reserved()
                          start_this_handle()  //detect aborted journal
                          jbd2_journal_free_reserved()  //get running transaction
                           read_lock(&journal->j_state_lock)
                            __jbd2_journal_unreserve_handle()
                           atomic_sub(j_reserved_credits, t_outstanding_credits);
                           //sub again
                           read_unlock(&journal->j_state_lock);
    
     journal->j_running_transaction = NULL;
     J_ASSERT(t_nr_buffers <= t_outstanding_credits) //bomb!!!
    
    Fix this issue by using journal->j_state_lock to protect the subtraction
    in jbd2_journal_commit_transaction().
    
    Fixes: 96f1e0974575 ("jbd2: avoid long hold times of j_state_lock while committing a transaction")
    Signed-off-by: Zhang Yi <yi.zhang@huawei.com>
    Reviewed-by: Jan Kara <jack@suse.cz>
    Link: https://lore.kernel.org/r/20220611130426.2013258-1-yi.zhang@huawei.com
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 096e8eb9639b342bc35f9b741cf05e26d0106e92
Author: Naohiro Aota <naohiro.aota@wdc.com>
Date:   Sat Jul 9 08:18:40 2022 +0900

    btrfs: replace BTRFS_MAX_EXTENT_SIZE with fs_info->max_extent_size
    
    [ Upstream commit f7b12a62f008a3041f42f2426983e59a6a0a3c59 ]
    
    On zoned filesystem, data write out is limited by max_zone_append_size,
    and a large ordered extent is split according the size of a bio. OTOH,
    the number of extents to be written is calculated using
    BTRFS_MAX_EXTENT_SIZE, and that estimated number is used to reserve the
    metadata bytes to update and/or create the metadata items.
    
    The metadata reservation is done at e.g, btrfs_buffered_write() and then
    released according to the estimation changes. Thus, if the number of extent
    increases massively, the reserved metadata can run out.
    
    The increase of the number of extents easily occurs on zoned filesystem
    if BTRFS_MAX_EXTENT_SIZE > max_zone_append_size. And, it causes the
    following warning on a small RAM environment with disabling metadata
    over-commit (in the following patch).
    
    [75721.498492] ------------[ cut here ]------------
    [75721.505624] BTRFS: block rsv 1 returned -28
    [75721.512230] WARNING: CPU: 24 PID: 2327559 at fs/btrfs/block-rsv.c:537 btrfs_use_block_rsv+0x560/0x760 [btrfs]
    [75721.581854] CPU: 24 PID: 2327559 Comm: kworker/u64:10 Kdump: loaded Tainted: G        W         5.18.0-rc2-BTRFS-ZNS+ #109
    [75721.597200] Hardware name: Supermicro Super Server/H12SSL-NT, BIOS 2.0 02/22/2021
    [75721.607310] Workqueue: btrfs-endio-write btrfs_work_helper [btrfs]
    [75721.616209] RIP: 0010:btrfs_use_block_rsv+0x560/0x760 [btrfs]
    [75721.646649] RSP: 0018:ffffc9000fbdf3e0 EFLAGS: 00010286
    [75721.654126] RAX: 0000000000000000 RBX: 0000000000004000 RCX: 0000000000000000
    [75721.663524] RDX: 0000000000000004 RSI: 0000000000000008 RDI: fffff52001f7be6e
    [75721.672921] RBP: ffffc9000fbdf420 R08: 0000000000000001 R09: ffff889f8d1fc6c7
    [75721.682493] R10: ffffed13f1a3f8d8 R11: 0000000000000001 R12: ffff88980a3c0e28
    [75721.692284] R13: ffff889b66590000 R14: ffff88980a3c0e40 R15: ffff88980a3c0e8a
    [75721.701878] FS:  0000000000000000(0000) GS:ffff889f8d000000(0000) knlGS:0000000000000000
    [75721.712601] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [75721.720726] CR2: 000055d12e05c018 CR3: 0000800193594000 CR4: 0000000000350ee0
    [75721.730499] Call Trace:
    [75721.735166]  <TASK>
    [75721.739886]  btrfs_alloc_tree_block+0x1e1/0x1100 [btrfs]
    [75721.747545]  ? btrfs_alloc_logged_file_extent+0x550/0x550 [btrfs]
    [75721.756145]  ? btrfs_get_32+0xea/0x2d0 [btrfs]
    [75721.762852]  ? btrfs_get_32+0xea/0x2d0 [btrfs]
    [75721.769520]  ? push_leaf_left+0x420/0x620 [btrfs]
    [75721.776431]  ? memcpy+0x4e/0x60
    [75721.781931]  split_leaf+0x433/0x12d0 [btrfs]
    [75721.788392]  ? btrfs_get_token_32+0x580/0x580 [btrfs]
    [75721.795636]  ? push_for_double_split.isra.0+0x420/0x420 [btrfs]
    [75721.803759]  ? leaf_space_used+0x15d/0x1a0 [btrfs]
    [75721.811156]  btrfs_search_slot+0x1bc3/0x2790 [btrfs]
    [75721.818300]  ? lock_downgrade+0x7c0/0x7c0
    [75721.824411]  ? free_extent_buffer.part.0+0x107/0x200 [btrfs]
    [75721.832456]  ? split_leaf+0x12d0/0x12d0 [btrfs]
    [75721.839149]  ? free_extent_buffer.part.0+0x14f/0x200 [btrfs]
    [75721.846945]  ? free_extent_buffer+0x13/0x20 [btrfs]
    [75721.853960]  ? btrfs_release_path+0x4b/0x190 [btrfs]
    [75721.861429]  btrfs_csum_file_blocks+0x85c/0x1500 [btrfs]
    [75721.869313]  ? rcu_read_lock_sched_held+0x16/0x80
    [75721.876085]  ? lock_release+0x552/0xf80
    [75721.881957]  ? btrfs_del_csums+0x8c0/0x8c0 [btrfs]
    [75721.888886]  ? __kasan_check_write+0x14/0x20
    [75721.895152]  ? do_raw_read_unlock+0x44/0x80
    [75721.901323]  ? _raw_write_lock_irq+0x60/0x80
    [75721.907983]  ? btrfs_global_root+0xb9/0xe0 [btrfs]
    [75721.915166]  ? btrfs_csum_root+0x12b/0x180 [btrfs]
    [75721.921918]  ? btrfs_get_global_root+0x820/0x820 [btrfs]
    [75721.929166]  ? _raw_write_unlock+0x23/0x40
    [75721.935116]  ? unpin_extent_cache+0x1e3/0x390 [btrfs]
    [75721.942041]  btrfs_finish_ordered_io.isra.0+0xa0c/0x1dc0 [btrfs]
    [75721.949906]  ? try_to_wake_up+0x30/0x14a0
    [75721.955700]  ? btrfs_unlink_subvol+0xda0/0xda0 [btrfs]
    [75721.962661]  ? rcu_read_lock_sched_held+0x16/0x80
    [75721.969111]  ? lock_acquire+0x41b/0x4c0
    [75721.974982]  finish_ordered_fn+0x15/0x20 [btrfs]
    [75721.981639]  btrfs_work_helper+0x1af/0xa80 [btrfs]
    [75721.988184]  ? _raw_spin_unlock_irq+0x28/0x50
    [75721.994643]  process_one_work+0x815/0x1460
    [75722.000444]  ? pwq_dec_nr_in_flight+0x250/0x250
    [75722.006643]  ? do_raw_spin_trylock+0xbb/0x190
    [75722.013086]  worker_thread+0x59a/0xeb0
    [75722.018511]  kthread+0x2ac/0x360
    [75722.023428]  ? process_one_work+0x1460/0x1460
    [75722.029431]  ? kthread_complete_and_exit+0x30/0x30
    [75722.036044]  ret_from_fork+0x22/0x30
    [75722.041255]  </TASK>
    [75722.045047] irq event stamp: 0
    [75722.049703] hardirqs last  enabled at (0): [<0000000000000000>] 0x0
    [75722.057610] hardirqs last disabled at (0): [<ffffffff8118a94a>] copy_process+0x1c1a/0x66b0
    [75722.067533] softirqs last  enabled at (0): [<ffffffff8118a989>] copy_process+0x1c59/0x66b0
    [75722.077423] softirqs last disabled at (0): [<0000000000000000>] 0x0
    [75722.085335] ---[ end trace 0000000000000000 ]---
    
    To fix the estimation, we need to introduce fs_info->max_extent_size to
    replace BTRFS_MAX_EXTENT_SIZE, which allow setting the different size for
    regular vs zoned filesystem.
    
    Set fs_info->max_extent_size to BTRFS_MAX_EXTENT_SIZE by default. On zoned
    filesystem, it is set to fs_info->max_zone_append_size.
    
    CC: stable@vger.kernel.org # 5.12+
    Fixes: d8e3fb106f39 ("btrfs: zoned: use ZONE_APPEND write for zoned mode")
    Reviewed-by: Johannes Thumshirn <johannes.thumshirn@wdc.com>
    Signed-off-by: Naohiro Aota <naohiro.aota@wdc.com>
    Signed-off-by: David Sterba <dsterba@suse.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit d65c93290045e868e104d2aee781ea36d4356666
Author: Zhang Yi <yi.zhang@huawei.com>
Date:   Sat Jun 11 21:04:26 2022 +0800

    jbd2: fix outstanding credits assert in jbd2_journal_commit_transaction()
    
    [ Upstream commit a89573ce4ad32f19f43ec669771726817e185be0 ]
    
    We catch an assert problem in jbd2_journal_commit_transaction() when
    doing fsstress and request falut injection tests. The problem is
    happened in a race condition between jbd2_journal_commit_transaction()
    and ext4_end_io_end(). Firstly, ext4_writepages() writeback dirty pages
    and start reserved handle, and then the journal was aborted due to some
    previous metadata IO error, jbd2_journal_abort() start to commit current
    running transaction, the committing procedure could be raced by
    ext4_end_io_end() and lead to subtract j_reserved_credits twice from
    commit_transaction->t_outstanding_credits, finally the
    t_outstanding_credits is mistakenly smaller than t_nr_buffers and
    trigger assert.
    
    kjournald2           kworker
    
    jbd2_journal_commit_transaction()
     write_unlock(&journal->j_state_lock);
     atomic_sub(j_reserved_credits, t_outstanding_credits); //sub once
    
                         jbd2_journal_start_reserved()
                          start_this_handle()  //detect aborted journal
                          jbd2_journal_free_reserved()  //get running transaction
                           read_lock(&journal->j_state_lock)
                            __jbd2_journal_unreserve_handle()
                           atomic_sub(j_reserved_credits, t_outstanding_credits);
                           //sub again
                           read_unlock(&journal->j_state_lock);
    
     journal->j_running_transaction = NULL;
     J_ASSERT(t_nr_buffers <= t_outstanding_credits) //bomb!!!
    
    Fix this issue by using journal->j_state_lock to protect the subtraction
    in jbd2_journal_commit_transaction().
    
    Fixes: 96f1e0974575 ("jbd2: avoid long hold times of j_state_lock while committing a transaction")
    Signed-off-by: Zhang Yi <yi.zhang@huawei.com>
    Reviewed-by: Jan Kara <jack@suse.cz>
    Link: https://lore.kernel.org/r/20220611130426.2013258-1-yi.zhang@huawei.com
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 6cb4b96df97082a54634ba02196516919cda228c
Author: Naohiro Aota <naohiro.aota@wdc.com>
Date:   Sat Jul 9 08:18:40 2022 +0900

    btrfs: replace BTRFS_MAX_EXTENT_SIZE with fs_info->max_extent_size
    
    [ Upstream commit f7b12a62f008a3041f42f2426983e59a6a0a3c59 ]
    
    On zoned filesystem, data write out is limited by max_zone_append_size,
    and a large ordered extent is split according the size of a bio. OTOH,
    the number of extents to be written is calculated using
    BTRFS_MAX_EXTENT_SIZE, and that estimated number is used to reserve the
    metadata bytes to update and/or create the metadata items.
    
    The metadata reservation is done at e.g, btrfs_buffered_write() and then
    released according to the estimation changes. Thus, if the number of extent
    increases massively, the reserved metadata can run out.
    
    The increase of the number of extents easily occurs on zoned filesystem
    if BTRFS_MAX_EXTENT_SIZE > max_zone_append_size. And, it causes the
    following warning on a small RAM environment with disabling metadata
    over-commit (in the following patch).
    
    [75721.498492] ------------[ cut here ]------------
    [75721.505624] BTRFS: block rsv 1 returned -28
    [75721.512230] WARNING: CPU: 24 PID: 2327559 at fs/btrfs/block-rsv.c:537 btrfs_use_block_rsv+0x560/0x760 [btrfs]
    [75721.581854] CPU: 24 PID: 2327559 Comm: kworker/u64:10 Kdump: loaded Tainted: G        W         5.18.0-rc2-BTRFS-ZNS+ #109
    [75721.597200] Hardware name: Supermicro Super Server/H12SSL-NT, BIOS 2.0 02/22/2021
    [75721.607310] Workqueue: btrfs-endio-write btrfs_work_helper [btrfs]
    [75721.616209] RIP: 0010:btrfs_use_block_rsv+0x560/0x760 [btrfs]
    [75721.646649] RSP: 0018:ffffc9000fbdf3e0 EFLAGS: 00010286
    [75721.654126] RAX: 0000000000000000 RBX: 0000000000004000 RCX: 0000000000000000
    [75721.663524] RDX: 0000000000000004 RSI: 0000000000000008 RDI: fffff52001f7be6e
    [75721.672921] RBP: ffffc9000fbdf420 R08: 0000000000000001 R09: ffff889f8d1fc6c7
    [75721.682493] R10: ffffed13f1a3f8d8 R11: 0000000000000001 R12: ffff88980a3c0e28
    [75721.692284] R13: ffff889b66590000 R14: ffff88980a3c0e40 R15: ffff88980a3c0e8a
    [75721.701878] FS:  0000000000000000(0000) GS:ffff889f8d000000(0000) knlGS:0000000000000000
    [75721.712601] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [75721.720726] CR2: 000055d12e05c018 CR3: 0000800193594000 CR4: 0000000000350ee0
    [75721.730499] Call Trace:
    [75721.735166]  <TASK>
    [75721.739886]  btrfs_alloc_tree_block+0x1e1/0x1100 [btrfs]
    [75721.747545]  ? btrfs_alloc_logged_file_extent+0x550/0x550 [btrfs]
    [75721.756145]  ? btrfs_get_32+0xea/0x2d0 [btrfs]
    [75721.762852]  ? btrfs_get_32+0xea/0x2d0 [btrfs]
    [75721.769520]  ? push_leaf_left+0x420/0x620 [btrfs]
    [75721.776431]  ? memcpy+0x4e/0x60
    [75721.781931]  split_leaf+0x433/0x12d0 [btrfs]
    [75721.788392]  ? btrfs_get_token_32+0x580/0x580 [btrfs]
    [75721.795636]  ? push_for_double_split.isra.0+0x420/0x420 [btrfs]
    [75721.803759]  ? leaf_space_used+0x15d/0x1a0 [btrfs]
    [75721.811156]  btrfs_search_slot+0x1bc3/0x2790 [btrfs]
    [75721.818300]  ? lock_downgrade+0x7c0/0x7c0
    [75721.824411]  ? free_extent_buffer.part.0+0x107/0x200 [btrfs]
    [75721.832456]  ? split_leaf+0x12d0/0x12d0 [btrfs]
    [75721.839149]  ? free_extent_buffer.part.0+0x14f/0x200 [btrfs]
    [75721.846945]  ? free_extent_buffer+0x13/0x20 [btrfs]
    [75721.853960]  ? btrfs_release_path+0x4b/0x190 [btrfs]
    [75721.861429]  btrfs_csum_file_blocks+0x85c/0x1500 [btrfs]
    [75721.869313]  ? rcu_read_lock_sched_held+0x16/0x80
    [75721.876085]  ? lock_release+0x552/0xf80
    [75721.881957]  ? btrfs_del_csums+0x8c0/0x8c0 [btrfs]
    [75721.888886]  ? __kasan_check_write+0x14/0x20
    [75721.895152]  ? do_raw_read_unlock+0x44/0x80
    [75721.901323]  ? _raw_write_lock_irq+0x60/0x80
    [75721.907983]  ? btrfs_global_root+0xb9/0xe0 [btrfs]
    [75721.915166]  ? btrfs_csum_root+0x12b/0x180 [btrfs]
    [75721.921918]  ? btrfs_get_global_root+0x820/0x820 [btrfs]
    [75721.929166]  ? _raw_write_unlock+0x23/0x40
    [75721.935116]  ? unpin_extent_cache+0x1e3/0x390 [btrfs]
    [75721.942041]  btrfs_finish_ordered_io.isra.0+0xa0c/0x1dc0 [btrfs]
    [75721.949906]  ? try_to_wake_up+0x30/0x14a0
    [75721.955700]  ? btrfs_unlink_subvol+0xda0/0xda0 [btrfs]
    [75721.962661]  ? rcu_read_lock_sched_held+0x16/0x80
    [75721.969111]  ? lock_acquire+0x41b/0x4c0
    [75721.974982]  finish_ordered_fn+0x15/0x20 [btrfs]
    [75721.981639]  btrfs_work_helper+0x1af/0xa80 [btrfs]
    [75721.988184]  ? _raw_spin_unlock_irq+0x28/0x50
    [75721.994643]  process_one_work+0x815/0x1460
    [75722.000444]  ? pwq_dec_nr_in_flight+0x250/0x250
    [75722.006643]  ? do_raw_spin_trylock+0xbb/0x190
    [75722.013086]  worker_thread+0x59a/0xeb0
    [75722.018511]  kthread+0x2ac/0x360
    [75722.023428]  ? process_one_work+0x1460/0x1460
    [75722.029431]  ? kthread_complete_and_exit+0x30/0x30
    [75722.036044]  ret_from_fork+0x22/0x30
    [75722.041255]  </TASK>
    [75722.045047] irq event stamp: 0
    [75722.049703] hardirqs last  enabled at (0): [<0000000000000000>] 0x0
    [75722.057610] hardirqs last disabled at (0): [<ffffffff8118a94a>] copy_process+0x1c1a/0x66b0
    [75722.067533] softirqs last  enabled at (0): [<ffffffff8118a989>] copy_process+0x1c59/0x66b0
    [75722.077423] softirqs last disabled at (0): [<0000000000000000>] 0x0
    [75722.085335] ---[ end trace 0000000000000000 ]---
    
    To fix the estimation, we need to introduce fs_info->max_extent_size to
    replace BTRFS_MAX_EXTENT_SIZE, which allow setting the different size for
    regular vs zoned filesystem.
    
    Set fs_info->max_extent_size to BTRFS_MAX_EXTENT_SIZE by default. On zoned
    filesystem, it is set to fs_info->max_zone_append_size.
    
    CC: stable@vger.kernel.org # 5.12+
    Fixes: d8e3fb106f39 ("btrfs: zoned: use ZONE_APPEND write for zoned mode")
    Reviewed-by: Johannes Thumshirn <johannes.thumshirn@wdc.com>
    Signed-off-by: Naohiro Aota <naohiro.aota@wdc.com>
    Signed-off-by: David Sterba <dsterba@suse.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 75e1ce13ed632c7a3814cbf6bd41119a31e1c120
Author: Zhang Yi <yi.zhang@huawei.com>
Date:   Sat Jun 11 21:04:26 2022 +0800

    jbd2: fix outstanding credits assert in jbd2_journal_commit_transaction()
    
    [ Upstream commit a89573ce4ad32f19f43ec669771726817e185be0 ]
    
    We catch an assert problem in jbd2_journal_commit_transaction() when
    doing fsstress and request falut injection tests. The problem is
    happened in a race condition between jbd2_journal_commit_transaction()
    and ext4_end_io_end(). Firstly, ext4_writepages() writeback dirty pages
    and start reserved handle, and then the journal was aborted due to some
    previous metadata IO error, jbd2_journal_abort() start to commit current
    running transaction, the committing procedure could be raced by
    ext4_end_io_end() and lead to subtract j_reserved_credits twice from
    commit_transaction->t_outstanding_credits, finally the
    t_outstanding_credits is mistakenly smaller than t_nr_buffers and
    trigger assert.
    
    kjournald2           kworker
    
    jbd2_journal_commit_transaction()
     write_unlock(&journal->j_state_lock);
     atomic_sub(j_reserved_credits, t_outstanding_credits); //sub once
    
                         jbd2_journal_start_reserved()
                          start_this_handle()  //detect aborted journal
                          jbd2_journal_free_reserved()  //get running transaction
                           read_lock(&journal->j_state_lock)
                            __jbd2_journal_unreserve_handle()
                           atomic_sub(j_reserved_credits, t_outstanding_credits);
                           //sub again
                           read_unlock(&journal->j_state_lock);
    
     journal->j_running_transaction = NULL;
     J_ASSERT(t_nr_buffers <= t_outstanding_credits) //bomb!!!
    
    Fix this issue by using journal->j_state_lock to protect the subtraction
    in jbd2_journal_commit_transaction().
    
    Fixes: 96f1e0974575 ("jbd2: avoid long hold times of j_state_lock while committing a transaction")
    Signed-off-by: Zhang Yi <yi.zhang@huawei.com>
    Reviewed-by: Jan Kara <jack@suse.cz>
    Link: https://lore.kernel.org/r/20220611130426.2013258-1-yi.zhang@huawei.com
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit b0e1268a8efd48d887e1f1555dd8ee738e3b5ab5
Author: Zhang Yi <yi.zhang@huawei.com>
Date:   Sat Jun 11 21:04:26 2022 +0800

    jbd2: fix outstanding credits assert in jbd2_journal_commit_transaction()
    
    [ Upstream commit a89573ce4ad32f19f43ec669771726817e185be0 ]
    
    We catch an assert problem in jbd2_journal_commit_transaction() when
    doing fsstress and request falut injection tests. The problem is
    happened in a race condition between jbd2_journal_commit_transaction()
    and ext4_end_io_end(). Firstly, ext4_writepages() writeback dirty pages
    and start reserved handle, and then the journal was aborted due to some
    previous metadata IO error, jbd2_journal_abort() start to commit current
    running transaction, the committing procedure could be raced by
    ext4_end_io_end() and lead to subtract j_reserved_credits twice from
    commit_transaction->t_outstanding_credits, finally the
    t_outstanding_credits is mistakenly smaller than t_nr_buffers and
    trigger assert.
    
    kjournald2           kworker
    
    jbd2_journal_commit_transaction()
     write_unlock(&journal->j_state_lock);
     atomic_sub(j_reserved_credits, t_outstanding_credits); //sub once
    
                         jbd2_journal_start_reserved()
                          start_this_handle()  //detect aborted journal
                          jbd2_journal_free_reserved()  //get running transaction
                           read_lock(&journal->j_state_lock)
                            __jbd2_journal_unreserve_handle()
                           atomic_sub(j_reserved_credits, t_outstanding_credits);
                           //sub again
                           read_unlock(&journal->j_state_lock);
    
     journal->j_running_transaction = NULL;
     J_ASSERT(t_nr_buffers <= t_outstanding_credits) //bomb!!!
    
    Fix this issue by using journal->j_state_lock to protect the subtraction
    in jbd2_journal_commit_transaction().
    
    Fixes: 96f1e0974575 ("jbd2: avoid long hold times of j_state_lock while committing a transaction")
    Signed-off-by: Zhang Yi <yi.zhang@huawei.com>
    Reviewed-by: Jan Kara <jack@suse.cz>
    Link: https://lore.kernel.org/r/20220611130426.2013258-1-yi.zhang@huawei.com
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit a89573ce4ad32f19f43ec669771726817e185be0
Author: Zhang Yi <yi.zhang@huawei.com>
Date:   Sat Jun 11 21:04:26 2022 +0800

    jbd2: fix outstanding credits assert in jbd2_journal_commit_transaction()
    
    We catch an assert problem in jbd2_journal_commit_transaction() when
    doing fsstress and request falut injection tests. The problem is
    happened in a race condition between jbd2_journal_commit_transaction()
    and ext4_end_io_end(). Firstly, ext4_writepages() writeback dirty pages
    and start reserved handle, and then the journal was aborted due to some
    previous metadata IO error, jbd2_journal_abort() start to commit current
    running transaction, the committing procedure could be raced by
    ext4_end_io_end() and lead to subtract j_reserved_credits twice from
    commit_transaction->t_outstanding_credits, finally the
    t_outstanding_credits is mistakenly smaller than t_nr_buffers and
    trigger assert.
    
    kjournald2           kworker
    
    jbd2_journal_commit_transaction()
     write_unlock(&journal->j_state_lock);
     atomic_sub(j_reserved_credits, t_outstanding_credits); //sub once
    
                         jbd2_journal_start_reserved()
                          start_this_handle()  //detect aborted journal
                          jbd2_journal_free_reserved()  //get running transaction
                           read_lock(&journal->j_state_lock)
                            __jbd2_journal_unreserve_handle()
                           atomic_sub(j_reserved_credits, t_outstanding_credits);
                           //sub again
                           read_unlock(&journal->j_state_lock);
    
     journal->j_running_transaction = NULL;
     J_ASSERT(t_nr_buffers <= t_outstanding_credits) //bomb!!!
    
    Fix this issue by using journal->j_state_lock to protect the subtraction
    in jbd2_journal_commit_transaction().
    
    Fixes: 96f1e0974575 ("jbd2: avoid long hold times of j_state_lock while committing a transaction")
    Signed-off-by: Zhang Yi <yi.zhang@huawei.com>
    Reviewed-by: Jan Kara <jack@suse.cz>
    Link: https://lore.kernel.org/r/20220611130426.2013258-1-yi.zhang@huawei.com
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>

commit 3d4b966e54b91e82534d58777bdbbbd67dff165a
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sun Jul 24 16:51:48 2022 +0200

    Revert "Revert "char/random: silence a lockdep splat with printk()""
    
    In 2019, Sergey fixed a lockdep splat with 15341b1dd409 ("char/random:
    silence a lockdep splat with printk()"), but that got reverted soon
    after from 4.19 because back then it apparently caused various problems.
    But the issue it was fixing is still there, and more generally, many
    patches turning printk() into printk_deferred() have landed since,
    making me suspect it's okay to try this out again.
    
    This should fix the following deadlock found by the kernel test robot:
    
    [   18.287691] WARNING: possible circular locking dependency detected
    [   18.287692] 4.19.248-00165-g3d1f971aa81f #1 Not tainted
    [   18.287693] ------------------------------------------------------
    [   18.287712] stop/202 is trying to acquire lock:
    [   18.287713] (ptrval) (console_owner){..-.}, at: console_unlock (??:?)
    [   18.287717]
    [   18.287718] but task is already holding lock:
    [   18.287718] (ptrval) (&(&port->lock)->rlock){-...}, at: pty_write (pty.c:?)
    [   18.287722]
    [   18.287722] which lock already depends on the new lock.
    [   18.287723]
    [   18.287724]
    [   18.287725] the existing dependency chain (in reverse order) is:
    [   18.287725]
    [   18.287726] -> #2 (&(&port->lock)->rlock){-...}:
    [   18.287729] validate_chain+0x84a/0xe00
    [   18.287729] __lock_acquire (lockdep.c:?)
    [   18.287730] lock_acquire (??:?)
    [   18.287731] _raw_spin_lock_irqsave (??:?)
    [   18.287732] tty_port_tty_get (??:?)
    [   18.287733] tty_port_default_wakeup (tty_port.c:?)
    [   18.287734] tty_port_tty_wakeup (??:?)
    [   18.287734] uart_write_wakeup (??:?)
    [   18.287735] serial8250_tx_chars (??:?)
    [   18.287736] serial8250_handle_irq (??:?)
    [   18.287737] serial8250_default_handle_irq (8250_port.c:?)
    [   18.287738] serial8250_interrupt (8250_core.c:?)
    [   18.287738] __handle_irq_event_percpu (??:?)
    [   18.287739] handle_irq_event_percpu (??:?)
    [   18.287740] handle_irq_event (??:?)
    [   18.287741] handle_edge_irq (??:?)
    [   18.287742] handle_irq (??:?)
    [   18.287742] do_IRQ (??:?)
    [   18.287743] common_interrupt (entry_32.o:?)
    [   18.287744] _raw_spin_unlock_irqrestore (??:?)
    [   18.287745] uart_write (serial_core.c:?)
    [   18.287746] process_output_block (n_tty.c:?)
    [   18.287747] n_tty_write (n_tty.c:?)
    [   18.287747] tty_write (tty_io.c:?)
    [   18.287748] __vfs_write (??:?)
    [   18.287749] vfs_write (??:?)
    [   18.287750] ksys_write (??:?)
    [   18.287750] sys_write (??:?)
    [   18.287751] do_fast_syscall_32 (??:?)
    [   18.287752] entry_SYSENTER_32 (??:?)
    [   18.287752]
    [   18.287753] -> #1 (&port_lock_key){-.-.}:
    [   18.287756]
    [   18.287756] -> #0 (console_owner){..-.}:
    [   18.287759] check_prevs_add (lockdep.c:?)
    [   18.287760] validate_chain+0x84a/0xe00
    [   18.287761] __lock_acquire (lockdep.c:?)
    [   18.287761] lock_acquire (??:?)
    [   18.287762] console_unlock (??:?)
    [   18.287763] vprintk_emit (??:?)
    [   18.287764] vprintk_default (??:?)
    [   18.287764] vprintk_func (??:?)
    [   18.287765] printk (??:?)
    [   18.287766] get_random_u32 (??:?)
    [   18.287767] shuffle_freelist (slub.c:?)
    [   18.287767] allocate_slab (slub.c:?)
    [   18.287768] new_slab (slub.c:?)
    [   18.287769] ___slab_alloc+0x6d0/0xb20
    [   18.287770] __slab_alloc+0xd6/0x2e0
    [   18.287770] __kmalloc (??:?)
    [   18.287771] tty_buffer_alloc (tty_buffer.c:?)
    [   18.287772] __tty_buffer_request_room (tty_buffer.c:?)
    [   18.287773] tty_insert_flip_string_fixed_flag (??:?)
    [   18.287774] pty_write (pty.c:?)
    [   18.287775] process_output_block (n_tty.c:?)
    [   18.287776] n_tty_write (n_tty.c:?)
    [   18.287777] tty_write (tty_io.c:?)
    [   18.287778] __vfs_write (??:?)
    [   18.287779] vfs_write (??:?)
    [   18.287780] ksys_write (??:?)
    [   18.287780] sys_write (??:?)
    [   18.287781] do_fast_syscall_32 (??:?)
    [   18.287782] entry_SYSENTER_32 (??:?)
    [   18.287783]
    [   18.287783] other info that might help us debug this:
    [   18.287784]
    [   18.287785] Chain exists of:
    [   18.287785]   console_owner --> &port_lock_key --> &(&port->lock)->rlock
    [   18.287789]
    [   18.287790]  Possible unsafe locking scenario:
    [   18.287790]
    [   18.287791]        CPU0                    CPU1
    [   18.287792]        ----                    ----
    [   18.287792]   lock(&(&port->lock)->rlock);
    [   18.287794]                                lock(&port_lock_key);
    [   18.287814]                                lock(&(&port->lock)->rlock);
    [   18.287815]   lock(console_owner);
    [   18.287817]
    [   18.287818]  *** DEADLOCK ***
    [   18.287818]
    [   18.287819] 6 locks held by stop/202:
    [   18.287820] #0: (ptrval) (&tty->ldisc_sem){++++}, at: ldsem_down_read (??:?)
    [   18.287823] #1: (ptrval) (&tty->atomic_write_lock){+.+.}, at: tty_write_lock (tty_io.c:?)
    [   18.287826] #2: (ptrval) (&o_tty->termios_rwsem/1){++++}, at: n_tty_write (n_tty.c:?)
    [   18.287830] #3: (ptrval) (&ldata->output_lock){+.+.}, at: process_output_block (n_tty.c:?)
    [   18.287834] #4: (ptrval) (&(&port->lock)->rlock){-...}, at: pty_write (pty.c:?)
    [   18.287838] #5: (ptrval) (console_lock){+.+.}, at: console_trylock_spinning (printk.c:?)
    [   18.287841]
    [   18.287842] stack backtrace:
    [   18.287843] CPU: 0 PID: 202 Comm: stop Not tainted 4.19.248-00165-g3d1f971aa81f #1
    [   18.287843] Call Trace:
    [   18.287844] dump_stack (??:?)
    [   18.287845] print_circular_bug.cold+0x78/0x8b
    [   18.287846] check_prev_add+0x66a/0xd20
    [   18.287847] check_prevs_add (lockdep.c:?)
    [   18.287848] validate_chain+0x84a/0xe00
    [   18.287848] __lock_acquire (lockdep.c:?)
    [   18.287849] lock_acquire (??:?)
    [   18.287850] ? console_unlock (??:?)
    [   18.287851] console_unlock (??:?)
    [   18.287851] ? console_unlock (??:?)
    [   18.287852] ? native_save_fl (??:?)
    [   18.287853] vprintk_emit (??:?)
    [   18.287854] vprintk_default (??:?)
    [   18.287855] vprintk_func (??:?)
    [   18.287855] printk (??:?)
    [   18.287856] get_random_u32 (??:?)
    [   18.287857] ? shuffle_freelist (slub.c:?)
    [   18.287858] shuffle_freelist (slub.c:?)
    [   18.287858] ? page_address (??:?)
    [   18.287859] allocate_slab (slub.c:?)
    [   18.287860] new_slab (slub.c:?)
    [   18.287861] ? pvclock_clocksource_read (??:?)
    [   18.287862] ___slab_alloc+0x6d0/0xb20
    [   18.287862] ? kvm_sched_clock_read (kvmclock.c:?)
    [   18.287863] ? __slab_alloc+0xbc/0x2e0
    [   18.287864] ? native_wbinvd (paravirt.c:?)
    [   18.287865] __slab_alloc+0xd6/0x2e0
    [   18.287865] __kmalloc (??:?)
    [   18.287866] ? __lock_acquire (lockdep.c:?)
    [   18.287867] ? tty_buffer_alloc (tty_buffer.c:?)
    [   18.287868] tty_buffer_alloc (tty_buffer.c:?)
    [   18.287869] __tty_buffer_request_room (tty_buffer.c:?)
    [   18.287869] tty_insert_flip_string_fixed_flag (??:?)
    [   18.287870] pty_write (pty.c:?)
    [   18.287871] process_output_block (n_tty.c:?)
    [   18.287872] n_tty_write (n_tty.c:?)
    [   18.287873] ? print_dl_stats (??:?)
    [   18.287874] ? n_tty_ioctl (n_tty.c:?)
    [   18.287874] tty_write (tty_io.c:?)
    [   18.287875] ? n_tty_ioctl (n_tty.c:?)
    [   18.287876] ? tty_write_unlock (tty_io.c:?)
    [   18.287877] __vfs_write (??:?)
    [   18.287877] vfs_write (??:?)
    [   18.287878] ? __fget_light (file.c:?)
    [   18.287879] ksys_write (??:?)
    
    Cc: Sergey Senozhatsky <sergey.senozhatsky.work@gmail.com>
    Cc: Qian Cai <cai@lca.pw>
    Cc: Lech Perczak <l.perczak@camlintechnologies.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Theodore Ts'o <tytso@mit.edu>
    Cc: Sasha Levin <sashal@kernel.org>
    Cc: Petr Mladek <pmladek@suse.com>
    Cc: John Ogness <john.ogness@linutronix.de>
    Reported-by: kernel test robot <oliver.sang@intel.com>
    Link: https://lore.kernel.org/lkml/Ytz+lo4zRQYG3JUR@xsang-OptiPlex-9020
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit df4cb7f30e831cce0bd85bbbc1a88aaa46a5fa98
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sun Jul 24 16:51:48 2022 +0200

    Revert "Revert "char/random: silence a lockdep splat with printk()""
    
    In 2019, Sergey fixed a lockdep splat with 15341b1dd409 ("char/random:
    silence a lockdep splat with printk()"), but that got reverted soon
    after from 4.19 because back then it apparently caused various problems.
    But the issue it was fixing is still there, and more generally, many
    patches turning printk() into printk_deferred() have landed since,
    making me suspect it's okay to try this out again.
    
    This should fix the following deadlock found by the kernel test robot:
    
    [   18.287691] WARNING: possible circular locking dependency detected
    [   18.287692] 4.19.248-00165-g3d1f971aa81f #1 Not tainted
    [   18.287693] ------------------------------------------------------
    [   18.287712] stop/202 is trying to acquire lock:
    [   18.287713] (ptrval) (console_owner){..-.}, at: console_unlock (??:?)
    [   18.287717]
    [   18.287718] but task is already holding lock:
    [   18.287718] (ptrval) (&(&port->lock)->rlock){-...}, at: pty_write (pty.c:?)
    [   18.287722]
    [   18.287722] which lock already depends on the new lock.
    [   18.287723]
    [   18.287724]
    [   18.287725] the existing dependency chain (in reverse order) is:
    [   18.287725]
    [   18.287726] -> #2 (&(&port->lock)->rlock){-...}:
    [   18.287729] validate_chain+0x84a/0xe00
    [   18.287729] __lock_acquire (lockdep.c:?)
    [   18.287730] lock_acquire (??:?)
    [   18.287731] _raw_spin_lock_irqsave (??:?)
    [   18.287732] tty_port_tty_get (??:?)
    [   18.287733] tty_port_default_wakeup (tty_port.c:?)
    [   18.287734] tty_port_tty_wakeup (??:?)
    [   18.287734] uart_write_wakeup (??:?)
    [   18.287735] serial8250_tx_chars (??:?)
    [   18.287736] serial8250_handle_irq (??:?)
    [   18.287737] serial8250_default_handle_irq (8250_port.c:?)
    [   18.287738] serial8250_interrupt (8250_core.c:?)
    [   18.287738] __handle_irq_event_percpu (??:?)
    [   18.287739] handle_irq_event_percpu (??:?)
    [   18.287740] handle_irq_event (??:?)
    [   18.287741] handle_edge_irq (??:?)
    [   18.287742] handle_irq (??:?)
    [   18.287742] do_IRQ (??:?)
    [   18.287743] common_interrupt (entry_32.o:?)
    [   18.287744] _raw_spin_unlock_irqrestore (??:?)
    [   18.287745] uart_write (serial_core.c:?)
    [   18.287746] process_output_block (n_tty.c:?)
    [   18.287747] n_tty_write (n_tty.c:?)
    [   18.287747] tty_write (tty_io.c:?)
    [   18.287748] __vfs_write (??:?)
    [   18.287749] vfs_write (??:?)
    [   18.287750] ksys_write (??:?)
    [   18.287750] sys_write (??:?)
    [   18.287751] do_fast_syscall_32 (??:?)
    [   18.287752] entry_SYSENTER_32 (??:?)
    [   18.287752]
    [   18.287753] -> #1 (&port_lock_key){-.-.}:
    [   18.287756]
    [   18.287756] -> #0 (console_owner){..-.}:
    [   18.287759] check_prevs_add (lockdep.c:?)
    [   18.287760] validate_chain+0x84a/0xe00
    [   18.287761] __lock_acquire (lockdep.c:?)
    [   18.287761] lock_acquire (??:?)
    [   18.287762] console_unlock (??:?)
    [   18.287763] vprintk_emit (??:?)
    [   18.287764] vprintk_default (??:?)
    [   18.287764] vprintk_func (??:?)
    [   18.287765] printk (??:?)
    [   18.287766] get_random_u32 (??:?)
    [   18.287767] shuffle_freelist (slub.c:?)
    [   18.287767] allocate_slab (slub.c:?)
    [   18.287768] new_slab (slub.c:?)
    [   18.287769] ___slab_alloc+0x6d0/0xb20
    [   18.287770] __slab_alloc+0xd6/0x2e0
    [   18.287770] __kmalloc (??:?)
    [   18.287771] tty_buffer_alloc (tty_buffer.c:?)
    [   18.287772] __tty_buffer_request_room (tty_buffer.c:?)
    [   18.287773] tty_insert_flip_string_fixed_flag (??:?)
    [   18.287774] pty_write (pty.c:?)
    [   18.287775] process_output_block (n_tty.c:?)
    [   18.287776] n_tty_write (n_tty.c:?)
    [   18.287777] tty_write (tty_io.c:?)
    [   18.287778] __vfs_write (??:?)
    [   18.287779] vfs_write (??:?)
    [   18.287780] ksys_write (??:?)
    [   18.287780] sys_write (??:?)
    [   18.287781] do_fast_syscall_32 (??:?)
    [   18.287782] entry_SYSENTER_32 (??:?)
    [   18.287783]
    [   18.287783] other info that might help us debug this:
    [   18.287784]
    [   18.287785] Chain exists of:
    [   18.287785]   console_owner --> &port_lock_key --> &(&port->lock)->rlock
    [   18.287789]
    [   18.287790]  Possible unsafe locking scenario:
    [   18.287790]
    [   18.287791]        CPU0                    CPU1
    [   18.287792]        ----                    ----
    [   18.287792]   lock(&(&port->lock)->rlock);
    [   18.287794]                                lock(&port_lock_key);
    [   18.287814]                                lock(&(&port->lock)->rlock);
    [   18.287815]   lock(console_owner);
    [   18.287817]
    [   18.287818]  *** DEADLOCK ***
    [   18.287818]
    [   18.287819] 6 locks held by stop/202:
    [   18.287820] #0: (ptrval) (&tty->ldisc_sem){++++}, at: ldsem_down_read (??:?)
    [   18.287823] #1: (ptrval) (&tty->atomic_write_lock){+.+.}, at: tty_write_lock (tty_io.c:?)
    [   18.287826] #2: (ptrval) (&o_tty->termios_rwsem/1){++++}, at: n_tty_write (n_tty.c:?)
    [   18.287830] #3: (ptrval) (&ldata->output_lock){+.+.}, at: process_output_block (n_tty.c:?)
    [   18.287834] #4: (ptrval) (&(&port->lock)->rlock){-...}, at: pty_write (pty.c:?)
    [   18.287838] #5: (ptrval) (console_lock){+.+.}, at: console_trylock_spinning (printk.c:?)
    [   18.287841]
    [   18.287842] stack backtrace:
    [   18.287843] CPU: 0 PID: 202 Comm: stop Not tainted 4.19.248-00165-g3d1f971aa81f #1
    [   18.287843] Call Trace:
    [   18.287844] dump_stack (??:?)
    [   18.287845] print_circular_bug.cold+0x78/0x8b
    [   18.287846] check_prev_add+0x66a/0xd20
    [   18.287847] check_prevs_add (lockdep.c:?)
    [   18.287848] validate_chain+0x84a/0xe00
    [   18.287848] __lock_acquire (lockdep.c:?)
    [   18.287849] lock_acquire (??:?)
    [   18.287850] ? console_unlock (??:?)
    [   18.287851] console_unlock (??:?)
    [   18.287851] ? console_unlock (??:?)
    [   18.287852] ? native_save_fl (??:?)
    [   18.287853] vprintk_emit (??:?)
    [   18.287854] vprintk_default (??:?)
    [   18.287855] vprintk_func (??:?)
    [   18.287855] printk (??:?)
    [   18.287856] get_random_u32 (??:?)
    [   18.287857] ? shuffle_freelist (slub.c:?)
    [   18.287858] shuffle_freelist (slub.c:?)
    [   18.287858] ? page_address (??:?)
    [   18.287859] allocate_slab (slub.c:?)
    [   18.287860] new_slab (slub.c:?)
    [   18.287861] ? pvclock_clocksource_read (??:?)
    [   18.287862] ___slab_alloc+0x6d0/0xb20
    [   18.287862] ? kvm_sched_clock_read (kvmclock.c:?)
    [   18.287863] ? __slab_alloc+0xbc/0x2e0
    [   18.287864] ? native_wbinvd (paravirt.c:?)
    [   18.287865] __slab_alloc+0xd6/0x2e0
    [   18.287865] __kmalloc (??:?)
    [   18.287866] ? __lock_acquire (lockdep.c:?)
    [   18.287867] ? tty_buffer_alloc (tty_buffer.c:?)
    [   18.287868] tty_buffer_alloc (tty_buffer.c:?)
    [   18.287869] __tty_buffer_request_room (tty_buffer.c:?)
    [   18.287869] tty_insert_flip_string_fixed_flag (??:?)
    [   18.287870] pty_write (pty.c:?)
    [   18.287871] process_output_block (n_tty.c:?)
    [   18.287872] n_tty_write (n_tty.c:?)
    [   18.287873] ? print_dl_stats (??:?)
    [   18.287874] ? n_tty_ioctl (n_tty.c:?)
    [   18.287874] tty_write (tty_io.c:?)
    [   18.287875] ? n_tty_ioctl (n_tty.c:?)
    [   18.287876] ? tty_write_unlock (tty_io.c:?)
    [   18.287877] __vfs_write (??:?)
    [   18.287877] vfs_write (??:?)
    [   18.287878] ? __fget_light (file.c:?)
    [   18.287879] ksys_write (??:?)
    
    Cc: Sergey Senozhatsky <sergey.senozhatsky.work@gmail.com>
    Cc: Qian Cai <cai@lca.pw>
    Cc: Lech Perczak <l.perczak@camlintechnologies.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Theodore Ts'o <tytso@mit.edu>
    Cc: Sasha Levin <sashal@kernel.org>
    Cc: Petr Mladek <pmladek@suse.com>
    Cc: John Ogness <john.ogness@linutronix.de>
    Reported-by: kernel test robot <oliver.sang@intel.com>
    Link: https://lore.kernel.org/lkml/Ytz+lo4zRQYG3JUR@xsang-OptiPlex-9020
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 2bbc39ce7809b1e2cd0f96103d4510550a96d02f
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sun Jul 24 16:51:48 2022 +0200

    Revert "Revert "char/random: silence a lockdep splat with printk()""
    
    In 2019, Sergey fixed a lockdep splat with 15341b1dd409 ("char/random:
    silence a lockdep splat with printk()"), but that got reverted soon
    after from 4.19 because back then it apparently caused various problems.
    But the issue it was fixing is still there, and more generally, many
    patches turning printk() into printk_deferred() have landed since,
    making me suspect it's okay to try this out again.
    
    This should fix the following deadlock found by the kernel test robot:
    
    [   18.287691] WARNING: possible circular locking dependency detected
    [   18.287692] 4.19.248-00165-g3d1f971aa81f #1 Not tainted
    [   18.287693] ------------------------------------------------------
    [   18.287712] stop/202 is trying to acquire lock:
    [   18.287713] (ptrval) (console_owner){..-.}, at: console_unlock (??:?)
    [   18.287717]
    [   18.287718] but task is already holding lock:
    [   18.287718] (ptrval) (&(&port->lock)->rlock){-...}, at: pty_write (pty.c:?)
    [   18.287722]
    [   18.287722] which lock already depends on the new lock.
    [   18.287723]
    [   18.287724]
    [   18.287725] the existing dependency chain (in reverse order) is:
    [   18.287725]
    [   18.287726] -> #2 (&(&port->lock)->rlock){-...}:
    [   18.287729] validate_chain+0x84a/0xe00
    [   18.287729] __lock_acquire (lockdep.c:?)
    [   18.287730] lock_acquire (??:?)
    [   18.287731] _raw_spin_lock_irqsave (??:?)
    [   18.287732] tty_port_tty_get (??:?)
    [   18.287733] tty_port_default_wakeup (tty_port.c:?)
    [   18.287734] tty_port_tty_wakeup (??:?)
    [   18.287734] uart_write_wakeup (??:?)
    [   18.287735] serial8250_tx_chars (??:?)
    [   18.287736] serial8250_handle_irq (??:?)
    [   18.287737] serial8250_default_handle_irq (8250_port.c:?)
    [   18.287738] serial8250_interrupt (8250_core.c:?)
    [   18.287738] __handle_irq_event_percpu (??:?)
    [   18.287739] handle_irq_event_percpu (??:?)
    [   18.287740] handle_irq_event (??:?)
    [   18.287741] handle_edge_irq (??:?)
    [   18.287742] handle_irq (??:?)
    [   18.287742] do_IRQ (??:?)
    [   18.287743] common_interrupt (entry_32.o:?)
    [   18.287744] _raw_spin_unlock_irqrestore (??:?)
    [   18.287745] uart_write (serial_core.c:?)
    [   18.287746] process_output_block (n_tty.c:?)
    [   18.287747] n_tty_write (n_tty.c:?)
    [   18.287747] tty_write (tty_io.c:?)
    [   18.287748] __vfs_write (??:?)
    [   18.287749] vfs_write (??:?)
    [   18.287750] ksys_write (??:?)
    [   18.287750] sys_write (??:?)
    [   18.287751] do_fast_syscall_32 (??:?)
    [   18.287752] entry_SYSENTER_32 (??:?)
    [   18.287752]
    [   18.287753] -> #1 (&port_lock_key){-.-.}:
    [   18.287756]
    [   18.287756] -> #0 (console_owner){..-.}:
    [   18.287759] check_prevs_add (lockdep.c:?)
    [   18.287760] validate_chain+0x84a/0xe00
    [   18.287761] __lock_acquire (lockdep.c:?)
    [   18.287761] lock_acquire (??:?)
    [   18.287762] console_unlock (??:?)
    [   18.287763] vprintk_emit (??:?)
    [   18.287764] vprintk_default (??:?)
    [   18.287764] vprintk_func (??:?)
    [   18.287765] printk (??:?)
    [   18.287766] get_random_u32 (??:?)
    [   18.287767] shuffle_freelist (slub.c:?)
    [   18.287767] allocate_slab (slub.c:?)
    [   18.287768] new_slab (slub.c:?)
    [   18.287769] ___slab_alloc+0x6d0/0xb20
    [   18.287770] __slab_alloc+0xd6/0x2e0
    [   18.287770] __kmalloc (??:?)
    [   18.287771] tty_buffer_alloc (tty_buffer.c:?)
    [   18.287772] __tty_buffer_request_room (tty_buffer.c:?)
    [   18.287773] tty_insert_flip_string_fixed_flag (??:?)
    [   18.287774] pty_write (pty.c:?)
    [   18.287775] process_output_block (n_tty.c:?)
    [   18.287776] n_tty_write (n_tty.c:?)
    [   18.287777] tty_write (tty_io.c:?)
    [   18.287778] __vfs_write (??:?)
    [   18.287779] vfs_write (??:?)
    [   18.287780] ksys_write (??:?)
    [   18.287780] sys_write (??:?)
    [   18.287781] do_fast_syscall_32 (??:?)
    [   18.287782] entry_SYSENTER_32 (??:?)
    [   18.287783]
    [   18.287783] other info that might help us debug this:
    [   18.287784]
    [   18.287785] Chain exists of:
    [   18.287785]   console_owner --> &port_lock_key --> &(&port->lock)->rlock
    [   18.287789]
    [   18.287790]  Possible unsafe locking scenario:
    [   18.287790]
    [   18.287791]        CPU0                    CPU1
    [   18.287792]        ----                    ----
    [   18.287792]   lock(&(&port->lock)->rlock);
    [   18.287794]                                lock(&port_lock_key);
    [   18.287814]                                lock(&(&port->lock)->rlock);
    [   18.287815]   lock(console_owner);
    [   18.287817]
    [   18.287818]  *** DEADLOCK ***
    [   18.287818]
    [   18.287819] 6 locks held by stop/202:
    [   18.287820] #0: (ptrval) (&tty->ldisc_sem){++++}, at: ldsem_down_read (??:?)
    [   18.287823] #1: (ptrval) (&tty->atomic_write_lock){+.+.}, at: tty_write_lock (tty_io.c:?)
    [   18.287826] #2: (ptrval) (&o_tty->termios_rwsem/1){++++}, at: n_tty_write (n_tty.c:?)
    [   18.287830] #3: (ptrval) (&ldata->output_lock){+.+.}, at: process_output_block (n_tty.c:?)
    [   18.287834] #4: (ptrval) (&(&port->lock)->rlock){-...}, at: pty_write (pty.c:?)
    [   18.287838] #5: (ptrval) (console_lock){+.+.}, at: console_trylock_spinning (printk.c:?)
    [   18.287841]
    [   18.287842] stack backtrace:
    [   18.287843] CPU: 0 PID: 202 Comm: stop Not tainted 4.19.248-00165-g3d1f971aa81f #1
    [   18.287843] Call Trace:
    [   18.287844] dump_stack (??:?)
    [   18.287845] print_circular_bug.cold+0x78/0x8b
    [   18.287846] check_prev_add+0x66a/0xd20
    [   18.287847] check_prevs_add (lockdep.c:?)
    [   18.287848] validate_chain+0x84a/0xe00
    [   18.287848] __lock_acquire (lockdep.c:?)
    [   18.287849] lock_acquire (??:?)
    [   18.287850] ? console_unlock (??:?)
    [   18.287851] console_unlock (??:?)
    [   18.287851] ? console_unlock (??:?)
    [   18.287852] ? native_save_fl (??:?)
    [   18.287853] vprintk_emit (??:?)
    [   18.287854] vprintk_default (??:?)
    [   18.287855] vprintk_func (??:?)
    [   18.287855] printk (??:?)
    [   18.287856] get_random_u32 (??:?)
    [   18.287857] ? shuffle_freelist (slub.c:?)
    [   18.287858] shuffle_freelist (slub.c:?)
    [   18.287858] ? page_address (??:?)
    [   18.287859] allocate_slab (slub.c:?)
    [   18.287860] new_slab (slub.c:?)
    [   18.287861] ? pvclock_clocksource_read (??:?)
    [   18.287862] ___slab_alloc+0x6d0/0xb20
    [   18.287862] ? kvm_sched_clock_read (kvmclock.c:?)
    [   18.287863] ? __slab_alloc+0xbc/0x2e0
    [   18.287864] ? native_wbinvd (paravirt.c:?)
    [   18.287865] __slab_alloc+0xd6/0x2e0
    [   18.287865] __kmalloc (??:?)
    [   18.287866] ? __lock_acquire (lockdep.c:?)
    [   18.287867] ? tty_buffer_alloc (tty_buffer.c:?)
    [   18.287868] tty_buffer_alloc (tty_buffer.c:?)
    [   18.287869] __tty_buffer_request_room (tty_buffer.c:?)
    [   18.287869] tty_insert_flip_string_fixed_flag (??:?)
    [   18.287870] pty_write (pty.c:?)
    [   18.287871] process_output_block (n_tty.c:?)
    [   18.287872] n_tty_write (n_tty.c:?)
    [   18.287873] ? print_dl_stats (??:?)
    [   18.287874] ? n_tty_ioctl (n_tty.c:?)
    [   18.287874] tty_write (tty_io.c:?)
    [   18.287875] ? n_tty_ioctl (n_tty.c:?)
    [   18.287876] ? tty_write_unlock (tty_io.c:?)
    [   18.287877] __vfs_write (??:?)
    [   18.287877] vfs_write (??:?)
    [   18.287878] ? __fget_light (file.c:?)
    [   18.287879] ksys_write (??:?)
    
    Cc: Sergey Senozhatsky <sergey.senozhatsky.work@gmail.com>
    Cc: Qian Cai <cai@lca.pw>
    Cc: Lech Perczak <l.perczak@camlintechnologies.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Theodore Ts'o <tytso@mit.edu>
    Cc: Sasha Levin <sashal@kernel.org>
    Cc: Petr Mladek <pmladek@suse.com>
    Cc: John Ogness <john.ogness@linutronix.de>
    Reported-by: kernel test robot <oliver.sang@intel.com>
    Link: https://lore.kernel.org/lkml/Ytz+lo4zRQYG3JUR@xsang-OptiPlex-9020
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit f7b12a62f008a3041f42f2426983e59a6a0a3c59
Author: Naohiro Aota <naohiro.aota@wdc.com>
Date:   Sat Jul 9 08:18:40 2022 +0900

    btrfs: replace BTRFS_MAX_EXTENT_SIZE with fs_info->max_extent_size
    
    On zoned filesystem, data write out is limited by max_zone_append_size,
    and a large ordered extent is split according the size of a bio. OTOH,
    the number of extents to be written is calculated using
    BTRFS_MAX_EXTENT_SIZE, and that estimated number is used to reserve the
    metadata bytes to update and/or create the metadata items.
    
    The metadata reservation is done at e.g, btrfs_buffered_write() and then
    released according to the estimation changes. Thus, if the number of extent
    increases massively, the reserved metadata can run out.
    
    The increase of the number of extents easily occurs on zoned filesystem
    if BTRFS_MAX_EXTENT_SIZE > max_zone_append_size. And, it causes the
    following warning on a small RAM environment with disabling metadata
    over-commit (in the following patch).
    
    [75721.498492] ------------[ cut here ]------------
    [75721.505624] BTRFS: block rsv 1 returned -28
    [75721.512230] WARNING: CPU: 24 PID: 2327559 at fs/btrfs/block-rsv.c:537 btrfs_use_block_rsv+0x560/0x760 [btrfs]
    [75721.581854] CPU: 24 PID: 2327559 Comm: kworker/u64:10 Kdump: loaded Tainted: G        W         5.18.0-rc2-BTRFS-ZNS+ #109
    [75721.597200] Hardware name: Supermicro Super Server/H12SSL-NT, BIOS 2.0 02/22/2021
    [75721.607310] Workqueue: btrfs-endio-write btrfs_work_helper [btrfs]
    [75721.616209] RIP: 0010:btrfs_use_block_rsv+0x560/0x760 [btrfs]
    [75721.646649] RSP: 0018:ffffc9000fbdf3e0 EFLAGS: 00010286
    [75721.654126] RAX: 0000000000000000 RBX: 0000000000004000 RCX: 0000000000000000
    [75721.663524] RDX: 0000000000000004 RSI: 0000000000000008 RDI: fffff52001f7be6e
    [75721.672921] RBP: ffffc9000fbdf420 R08: 0000000000000001 R09: ffff889f8d1fc6c7
    [75721.682493] R10: ffffed13f1a3f8d8 R11: 0000000000000001 R12: ffff88980a3c0e28
    [75721.692284] R13: ffff889b66590000 R14: ffff88980a3c0e40 R15: ffff88980a3c0e8a
    [75721.701878] FS:  0000000000000000(0000) GS:ffff889f8d000000(0000) knlGS:0000000000000000
    [75721.712601] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [75721.720726] CR2: 000055d12e05c018 CR3: 0000800193594000 CR4: 0000000000350ee0
    [75721.730499] Call Trace:
    [75721.735166]  <TASK>
    [75721.739886]  btrfs_alloc_tree_block+0x1e1/0x1100 [btrfs]
    [75721.747545]  ? btrfs_alloc_logged_file_extent+0x550/0x550 [btrfs]
    [75721.756145]  ? btrfs_get_32+0xea/0x2d0 [btrfs]
    [75721.762852]  ? btrfs_get_32+0xea/0x2d0 [btrfs]
    [75721.769520]  ? push_leaf_left+0x420/0x620 [btrfs]
    [75721.776431]  ? memcpy+0x4e/0x60
    [75721.781931]  split_leaf+0x433/0x12d0 [btrfs]
    [75721.788392]  ? btrfs_get_token_32+0x580/0x580 [btrfs]
    [75721.795636]  ? push_for_double_split.isra.0+0x420/0x420 [btrfs]
    [75721.803759]  ? leaf_space_used+0x15d/0x1a0 [btrfs]
    [75721.811156]  btrfs_search_slot+0x1bc3/0x2790 [btrfs]
    [75721.818300]  ? lock_downgrade+0x7c0/0x7c0
    [75721.824411]  ? free_extent_buffer.part.0+0x107/0x200 [btrfs]
    [75721.832456]  ? split_leaf+0x12d0/0x12d0 [btrfs]
    [75721.839149]  ? free_extent_buffer.part.0+0x14f/0x200 [btrfs]
    [75721.846945]  ? free_extent_buffer+0x13/0x20 [btrfs]
    [75721.853960]  ? btrfs_release_path+0x4b/0x190 [btrfs]
    [75721.861429]  btrfs_csum_file_blocks+0x85c/0x1500 [btrfs]
    [75721.869313]  ? rcu_read_lock_sched_held+0x16/0x80
    [75721.876085]  ? lock_release+0x552/0xf80
    [75721.881957]  ? btrfs_del_csums+0x8c0/0x8c0 [btrfs]
    [75721.888886]  ? __kasan_check_write+0x14/0x20
    [75721.895152]  ? do_raw_read_unlock+0x44/0x80
    [75721.901323]  ? _raw_write_lock_irq+0x60/0x80
    [75721.907983]  ? btrfs_global_root+0xb9/0xe0 [btrfs]
    [75721.915166]  ? btrfs_csum_root+0x12b/0x180 [btrfs]
    [75721.921918]  ? btrfs_get_global_root+0x820/0x820 [btrfs]
    [75721.929166]  ? _raw_write_unlock+0x23/0x40
    [75721.935116]  ? unpin_extent_cache+0x1e3/0x390 [btrfs]
    [75721.942041]  btrfs_finish_ordered_io.isra.0+0xa0c/0x1dc0 [btrfs]
    [75721.949906]  ? try_to_wake_up+0x30/0x14a0
    [75721.955700]  ? btrfs_unlink_subvol+0xda0/0xda0 [btrfs]
    [75721.962661]  ? rcu_read_lock_sched_held+0x16/0x80
    [75721.969111]  ? lock_acquire+0x41b/0x4c0
    [75721.974982]  finish_ordered_fn+0x15/0x20 [btrfs]
    [75721.981639]  btrfs_work_helper+0x1af/0xa80 [btrfs]
    [75721.988184]  ? _raw_spin_unlock_irq+0x28/0x50
    [75721.994643]  process_one_work+0x815/0x1460
    [75722.000444]  ? pwq_dec_nr_in_flight+0x250/0x250
    [75722.006643]  ? do_raw_spin_trylock+0xbb/0x190
    [75722.013086]  worker_thread+0x59a/0xeb0
    [75722.018511]  kthread+0x2ac/0x360
    [75722.023428]  ? process_one_work+0x1460/0x1460
    [75722.029431]  ? kthread_complete_and_exit+0x30/0x30
    [75722.036044]  ret_from_fork+0x22/0x30
    [75722.041255]  </TASK>
    [75722.045047] irq event stamp: 0
    [75722.049703] hardirqs last  enabled at (0): [<0000000000000000>] 0x0
    [75722.057610] hardirqs last disabled at (0): [<ffffffff8118a94a>] copy_process+0x1c1a/0x66b0
    [75722.067533] softirqs last  enabled at (0): [<ffffffff8118a989>] copy_process+0x1c59/0x66b0
    [75722.077423] softirqs last disabled at (0): [<0000000000000000>] 0x0
    [75722.085335] ---[ end trace 0000000000000000 ]---
    
    To fix the estimation, we need to introduce fs_info->max_extent_size to
    replace BTRFS_MAX_EXTENT_SIZE, which allow setting the different size for
    regular vs zoned filesystem.
    
    Set fs_info->max_extent_size to BTRFS_MAX_EXTENT_SIZE by default. On zoned
    filesystem, it is set to fs_info->max_zone_append_size.
    
    CC: stable@vger.kernel.org # 5.12+
    Fixes: d8e3fb106f39 ("btrfs: zoned: use ZONE_APPEND write for zoned mode")
    Reviewed-by: Johannes Thumshirn <johannes.thumshirn@wdc.com>
    Signed-off-by: Naohiro Aota <naohiro.aota@wdc.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

commit 97be7d13fbd4001eeab49b1be6399f23a8c66160
Author: Jan Kara <jack@suse.cz>
Date:   Tue Jun 7 11:15:09 2022 +0200

    bfq: Avoid merging queues with different parents
    
    commit c1cee4ab36acef271be9101590756ed0c0c374d9 upstream.
    
    It can happen that the parent of a bfqq changes between the moment we
    decide two queues are worth to merge (and set bic->stable_merge_bfqq)
    and the moment bfq_setup_merge() is called. This can happen e.g. because
    the process submitted IO for a different cgroup and thus bfqq got
    reparented. It can even happen that the bfqq we are merging with has
    parent cgroup that is already offline and going to be destroyed in which
    case the merge can lead to use-after-free issues such as:
    
    BUG: KASAN: use-after-free in __bfq_deactivate_entity+0x9cb/0xa50
    Read of size 8 at addr ffff88800693c0c0 by task runc:[2:INIT]/10544
    
    CPU: 0 PID: 10544 Comm: runc:[2:INIT] Tainted: G            E     5.15.2-0.g5fb85fd-default #1 openSUSE Tumbleweed (unreleased) f1f3b891c72369aebecd2e43e4641a6358867c70
    Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.14.0-0-g155821a-rebuilt.opensuse.org 04/01/2014
    Call Trace:
     <IRQ>
     dump_stack_lvl+0x46/0x5a
     print_address_description.constprop.0+0x1f/0x140
     ? __bfq_deactivate_entity+0x9cb/0xa50
     kasan_report.cold+0x7f/0x11b
     ? __bfq_deactivate_entity+0x9cb/0xa50
     __bfq_deactivate_entity+0x9cb/0xa50
     ? update_curr+0x32f/0x5d0
     bfq_deactivate_entity+0xa0/0x1d0
     bfq_del_bfqq_busy+0x28a/0x420
     ? resched_curr+0x116/0x1d0
     ? bfq_requeue_bfqq+0x70/0x70
     ? check_preempt_wakeup+0x52b/0xbc0
     __bfq_bfqq_expire+0x1a2/0x270
     bfq_bfqq_expire+0xd16/0x2160
     ? try_to_wake_up+0x4ee/0x1260
     ? bfq_end_wr_async_queues+0xe0/0xe0
     ? _raw_write_unlock_bh+0x60/0x60
     ? _raw_spin_lock_irq+0x81/0xe0
     bfq_idle_slice_timer+0x109/0x280
     ? bfq_dispatch_request+0x4870/0x4870
     __hrtimer_run_queues+0x37d/0x700
     ? enqueue_hrtimer+0x1b0/0x1b0
     ? kvm_clock_get_cycles+0xd/0x10
     ? ktime_get_update_offsets_now+0x6f/0x280
     hrtimer_interrupt+0x2c8/0x740
    
    Fix the problem by checking that the parent of the two bfqqs we are
    merging in bfq_setup_merge() is the same.
    
    Link: https://lore.kernel.org/linux-block/20211125172809.GC19572@quack2.suse.cz/
    CC: stable@vger.kernel.org
    Fixes: 430a67f9d616 ("block, bfq: merge bursts of newly-created queues")
    Tested-by: "yukuai (C)" <yukuai3@huawei.com>
    Signed-off-by: Jan Kara <jack@suse.cz>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Link: https://lore.kernel.org/r/20220401102752.8599-2-jack@suse.cz
    Signed-off-by: Jens Axboe <axboe@kernel.dk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 8abc8763b11c35e03cc91d59fd0cd28d39f88ca9
Author: Jan Kara <jack@suse.cz>
Date:   Fri Apr 1 12:27:43 2022 +0200

    bfq: Avoid merging queues with different parents
    
    commit c1cee4ab36acef271be9101590756ed0c0c374d9 upstream.
    
    It can happen that the parent of a bfqq changes between the moment we
    decide two queues are worth to merge (and set bic->stable_merge_bfqq)
    and the moment bfq_setup_merge() is called. This can happen e.g. because
    the process submitted IO for a different cgroup and thus bfqq got
    reparented. It can even happen that the bfqq we are merging with has
    parent cgroup that is already offline and going to be destroyed in which
    case the merge can lead to use-after-free issues such as:
    
    BUG: KASAN: use-after-free in __bfq_deactivate_entity+0x9cb/0xa50
    Read of size 8 at addr ffff88800693c0c0 by task runc:[2:INIT]/10544
    
    CPU: 0 PID: 10544 Comm: runc:[2:INIT] Tainted: G            E     5.15.2-0.g5fb85fd-default #1 openSUSE Tumbleweed (unreleased) f1f3b891c72369aebecd2e43e4641a6358867c70
    Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.14.0-0-g155821a-rebuilt.opensuse.org 04/01/2014
    Call Trace:
     <IRQ>
     dump_stack_lvl+0x46/0x5a
     print_address_description.constprop.0+0x1f/0x140
     ? __bfq_deactivate_entity+0x9cb/0xa50
     kasan_report.cold+0x7f/0x11b
     ? __bfq_deactivate_entity+0x9cb/0xa50
     __bfq_deactivate_entity+0x9cb/0xa50
     ? update_curr+0x32f/0x5d0
     bfq_deactivate_entity+0xa0/0x1d0
     bfq_del_bfqq_busy+0x28a/0x420
     ? resched_curr+0x116/0x1d0
     ? bfq_requeue_bfqq+0x70/0x70
     ? check_preempt_wakeup+0x52b/0xbc0
     __bfq_bfqq_expire+0x1a2/0x270
     bfq_bfqq_expire+0xd16/0x2160
     ? try_to_wake_up+0x4ee/0x1260
     ? bfq_end_wr_async_queues+0xe0/0xe0
     ? _raw_write_unlock_bh+0x60/0x60
     ? _raw_spin_lock_irq+0x81/0xe0
     bfq_idle_slice_timer+0x109/0x280
     ? bfq_dispatch_request+0x4870/0x4870
     __hrtimer_run_queues+0x37d/0x700
     ? enqueue_hrtimer+0x1b0/0x1b0
     ? kvm_clock_get_cycles+0xd/0x10
     ? ktime_get_update_offsets_now+0x6f/0x280
     hrtimer_interrupt+0x2c8/0x740
    
    Fix the problem by checking that the parent of the two bfqqs we are
    merging in bfq_setup_merge() is the same.
    
    Link: https://lore.kernel.org/linux-block/20211125172809.GC19572@quack2.suse.cz/
    CC: stable@vger.kernel.org
    Fixes: 430a67f9d616 ("block, bfq: merge bursts of newly-created queues")
    Tested-by: "yukuai (C)" <yukuai3@huawei.com>
    Signed-off-by: Jan Kara <jack@suse.cz>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Link: https://lore.kernel.org/r/20220401102752.8599-2-jack@suse.cz
    Signed-off-by: Jens Axboe <axboe@kernel.dk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit a16c65cca7d2c7ff965fdd3adc8df2156529caf1
Author: Jan Kara <jack@suse.cz>
Date:   Fri Apr 1 12:27:43 2022 +0200

    bfq: Avoid merging queues with different parents
    
    commit c1cee4ab36acef271be9101590756ed0c0c374d9 upstream.
    
    It can happen that the parent of a bfqq changes between the moment we
    decide two queues are worth to merge (and set bic->stable_merge_bfqq)
    and the moment bfq_setup_merge() is called. This can happen e.g. because
    the process submitted IO for a different cgroup and thus bfqq got
    reparented. It can even happen that the bfqq we are merging with has
    parent cgroup that is already offline and going to be destroyed in which
    case the merge can lead to use-after-free issues such as:
    
    BUG: KASAN: use-after-free in __bfq_deactivate_entity+0x9cb/0xa50
    Read of size 8 at addr ffff88800693c0c0 by task runc:[2:INIT]/10544
    
    CPU: 0 PID: 10544 Comm: runc:[2:INIT] Tainted: G            E     5.15.2-0.g5fb85fd-default #1 openSUSE Tumbleweed (unreleased) f1f3b891c72369aebecd2e43e4641a6358867c70
    Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.14.0-0-g155821a-rebuilt.opensuse.org 04/01/2014
    Call Trace:
     <IRQ>
     dump_stack_lvl+0x46/0x5a
     print_address_description.constprop.0+0x1f/0x140
     ? __bfq_deactivate_entity+0x9cb/0xa50
     kasan_report.cold+0x7f/0x11b
     ? __bfq_deactivate_entity+0x9cb/0xa50
     __bfq_deactivate_entity+0x9cb/0xa50
     ? update_curr+0x32f/0x5d0
     bfq_deactivate_entity+0xa0/0x1d0
     bfq_del_bfqq_busy+0x28a/0x420
     ? resched_curr+0x116/0x1d0
     ? bfq_requeue_bfqq+0x70/0x70
     ? check_preempt_wakeup+0x52b/0xbc0
     __bfq_bfqq_expire+0x1a2/0x270
     bfq_bfqq_expire+0xd16/0x2160
     ? try_to_wake_up+0x4ee/0x1260
     ? bfq_end_wr_async_queues+0xe0/0xe0
     ? _raw_write_unlock_bh+0x60/0x60
     ? _raw_spin_lock_irq+0x81/0xe0
     bfq_idle_slice_timer+0x109/0x280
     ? bfq_dispatch_request+0x4870/0x4870
     __hrtimer_run_queues+0x37d/0x700
     ? enqueue_hrtimer+0x1b0/0x1b0
     ? kvm_clock_get_cycles+0xd/0x10
     ? ktime_get_update_offsets_now+0x6f/0x280
     hrtimer_interrupt+0x2c8/0x740
    
    Fix the problem by checking that the parent of the two bfqqs we are
    merging in bfq_setup_merge() is the same.
    
    Link: https://lore.kernel.org/linux-block/20211125172809.GC19572@quack2.suse.cz/
    CC: stable@vger.kernel.org
    Fixes: 430a67f9d616 ("block, bfq: merge bursts of newly-created queues")
    Tested-by: "yukuai (C)" <yukuai3@huawei.com>
    Signed-off-by: Jan Kara <jack@suse.cz>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Link: https://lore.kernel.org/r/20220401102752.8599-2-jack@suse.cz
    Signed-off-by: Jens Axboe <axboe@kernel.dk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 5ee21edaed09e6b25f2c007b3f326752bc89bacf
Author: Jan Kara <jack@suse.cz>
Date:   Fri Apr 1 12:27:43 2022 +0200

    bfq: Avoid merging queues with different parents
    
    commit c1cee4ab36acef271be9101590756ed0c0c374d9 upstream.
    
    It can happen that the parent of a bfqq changes between the moment we
    decide two queues are worth to merge (and set bic->stable_merge_bfqq)
    and the moment bfq_setup_merge() is called. This can happen e.g. because
    the process submitted IO for a different cgroup and thus bfqq got
    reparented. It can even happen that the bfqq we are merging with has
    parent cgroup that is already offline and going to be destroyed in which
    case the merge can lead to use-after-free issues such as:
    
    BUG: KASAN: use-after-free in __bfq_deactivate_entity+0x9cb/0xa50
    Read of size 8 at addr ffff88800693c0c0 by task runc:[2:INIT]/10544
    
    CPU: 0 PID: 10544 Comm: runc:[2:INIT] Tainted: G            E     5.15.2-0.g5fb85fd-default #1 openSUSE Tumbleweed (unreleased) f1f3b891c72369aebecd2e43e4641a6358867c70
    Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.14.0-0-g155821a-rebuilt.opensuse.org 04/01/2014
    Call Trace:
     <IRQ>
     dump_stack_lvl+0x46/0x5a
     print_address_description.constprop.0+0x1f/0x140
     ? __bfq_deactivate_entity+0x9cb/0xa50
     kasan_report.cold+0x7f/0x11b
     ? __bfq_deactivate_entity+0x9cb/0xa50
     __bfq_deactivate_entity+0x9cb/0xa50
     ? update_curr+0x32f/0x5d0
     bfq_deactivate_entity+0xa0/0x1d0
     bfq_del_bfqq_busy+0x28a/0x420
     ? resched_curr+0x116/0x1d0
     ? bfq_requeue_bfqq+0x70/0x70
     ? check_preempt_wakeup+0x52b/0xbc0
     __bfq_bfqq_expire+0x1a2/0x270
     bfq_bfqq_expire+0xd16/0x2160
     ? try_to_wake_up+0x4ee/0x1260
     ? bfq_end_wr_async_queues+0xe0/0xe0
     ? _raw_write_unlock_bh+0x60/0x60
     ? _raw_spin_lock_irq+0x81/0xe0
     bfq_idle_slice_timer+0x109/0x280
     ? bfq_dispatch_request+0x4870/0x4870
     __hrtimer_run_queues+0x37d/0x700
     ? enqueue_hrtimer+0x1b0/0x1b0
     ? kvm_clock_get_cycles+0xd/0x10
     ? ktime_get_update_offsets_now+0x6f/0x280
     hrtimer_interrupt+0x2c8/0x740
    
    Fix the problem by checking that the parent of the two bfqqs we are
    merging in bfq_setup_merge() is the same.
    
    Link: https://lore.kernel.org/linux-block/20211125172809.GC19572@quack2.suse.cz/
    CC: stable@vger.kernel.org
    Fixes: 430a67f9d616 ("block, bfq: merge bursts of newly-created queues")
    Tested-by: "yukuai (C)" <yukuai3@huawei.com>
    Signed-off-by: Jan Kara <jack@suse.cz>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Link: https://lore.kernel.org/r/20220401102752.8599-2-jack@suse.cz
    Signed-off-by: Jens Axboe <axboe@kernel.dk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 7d172b9dc913e161d8ff88770eea01701ff553de
Author: Jan Kara <jack@suse.cz>
Date:   Mon Jun 6 19:56:36 2022 +0200

    bfq: Avoid merging queues with different parents
    
    commit c1cee4ab36acef271be9101590756ed0c0c374d9 upstream.
    
    It can happen that the parent of a bfqq changes between the moment we
    decide two queues are worth to merge (and set bic->stable_merge_bfqq)
    and the moment bfq_setup_merge() is called. This can happen e.g. because
    the process submitted IO for a different cgroup and thus bfqq got
    reparented. It can even happen that the bfqq we are merging with has
    parent cgroup that is already offline and going to be destroyed in which
    case the merge can lead to use-after-free issues such as:
    
    BUG: KASAN: use-after-free in __bfq_deactivate_entity+0x9cb/0xa50
    Read of size 8 at addr ffff88800693c0c0 by task runc:[2:INIT]/10544
    
    CPU: 0 PID: 10544 Comm: runc:[2:INIT] Tainted: G            E     5.15.2-0.g5fb85fd-default #1 openSUSE Tumbleweed (unreleased) f1f3b891c72369aebecd2e43e4641a6358867c70
    Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.14.0-0-g155821a-rebuilt.opensuse.org 04/01/2014
    Call Trace:
     <IRQ>
     dump_stack_lvl+0x46/0x5a
     print_address_description.constprop.0+0x1f/0x140
     ? __bfq_deactivate_entity+0x9cb/0xa50
     kasan_report.cold+0x7f/0x11b
     ? __bfq_deactivate_entity+0x9cb/0xa50
     __bfq_deactivate_entity+0x9cb/0xa50
     ? update_curr+0x32f/0x5d0
     bfq_deactivate_entity+0xa0/0x1d0
     bfq_del_bfqq_busy+0x28a/0x420
     ? resched_curr+0x116/0x1d0
     ? bfq_requeue_bfqq+0x70/0x70
     ? check_preempt_wakeup+0x52b/0xbc0
     __bfq_bfqq_expire+0x1a2/0x270
     bfq_bfqq_expire+0xd16/0x2160
     ? try_to_wake_up+0x4ee/0x1260
     ? bfq_end_wr_async_queues+0xe0/0xe0
     ? _raw_write_unlock_bh+0x60/0x60
     ? _raw_spin_lock_irq+0x81/0xe0
     bfq_idle_slice_timer+0x109/0x280
     ? bfq_dispatch_request+0x4870/0x4870
     __hrtimer_run_queues+0x37d/0x700
     ? enqueue_hrtimer+0x1b0/0x1b0
     ? kvm_clock_get_cycles+0xd/0x10
     ? ktime_get_update_offsets_now+0x6f/0x280
     hrtimer_interrupt+0x2c8/0x740
    
    Fix the problem by checking that the parent of the two bfqqs we are
    merging in bfq_setup_merge() is the same.
    
    Link: https://lore.kernel.org/linux-block/20211125172809.GC19572@quack2.suse.cz/
    CC: stable@vger.kernel.org
    Fixes: 430a67f9d616 ("block, bfq: merge bursts of newly-created queues")
    Tested-by: "yukuai (C)" <yukuai3@huawei.com>
    Signed-off-by: Jan Kara <jack@suse.cz>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Link: https://lore.kernel.org/r/20220401102752.8599-2-jack@suse.cz
    Signed-off-by: Jens Axboe <axboe@kernel.dk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 750ee454908e90a8792b1e2b157c2948da86e926
Author: Filipe Manana <fdmanana@suse.com>
Date:   Tue May 3 11:57:02 2022 +0100

    btrfs: fix assertion failure when logging directory key range item
    
    When inserting a key range item (BTRFS_DIR_LOG_INDEX_KEY) while logging
    a directory, we don't expect the insertion to fail with -EEXIST, because
    we are holding the directory's log_mutex and we have dropped all existing
    BTRFS_DIR_LOG_INDEX_KEY keys from the log tree before we started to log
    the directory. However it's possible that during the logging we attempt
    to insert the same BTRFS_DIR_LOG_INDEX_KEY key twice, but for this to
    happen we need to race with insertions of items from other inodes in the
    subvolume's tree while we are logging a directory. Here's how this can
    happen:
    
    1) We are logging a directory with inode number 1000 that has its items
       spread across 3 leaves in the subvolume's tree:
    
       leaf A - has index keys from the range 2 to 20 for example. The last
       item in the leaf corresponds to a dir item for index number 20. All
       these dir items were created in a past transaction.
    
       leaf B - has index keys from the range 22 to 100 for example. It has
       no keys from other inodes, all its keys are dir index keys for our
       directory inode number 1000. Its first key is for the dir item with
       a sequence number of 22. All these dir items were also created in a
       past transaction.
    
       leaf C - has index keys for our directory for the range 101 to 120 for
       example. This leaf also has items from other inodes, and its first
       item corresponds to the dir item for index number 101 for our directory
       with inode number 1000;
    
    2) When we finish processing the items from leaf A at log_dir_items(),
       we log a BTRFS_DIR_LOG_INDEX_KEY key with an offset of 21 and a last
       offset of 21, meaning the log is authoritative for the index range
       from 21 to 21 (a single sequence number). At this point leaf B was
       not yet modified in the current transaction;
    
    3) When we return from log_dir_items() we have released our read lock on
       leaf B, and have set *last_offset_ret to 21 (index number of the first
       item on leaf B minus 1);
    
    4) Some other task inserts an item for other inode (inode number 1001 for
       example) into leaf C. That resulted in pushing some items from leaf C
       into leaf B, in order to make room for the new item, so now leaf B
       has dir index keys for the sequence number range from 22 to 102 and
       leaf C has the dir items for the sequence number range 103 to 120;
    
    5) At log_directory_changes() we call log_dir_items() again, passing it
       a 'min_offset' / 'min_key' value of 22 (*last_offset_ret from step 3
       plus 1, so 21 + 1). Then btrfs_search_forward() leaves us at slot 0
       of leaf B, since leaf B was modified in the current transaction.
    
       We have also initialized 'last_old_dentry_offset' to 20 after calling
       btrfs_previous_item() at log_dir_items(), as it left us at the last
       item of leaf A, which refers to the dir item with sequence number 20;
    
    6) We then call process_dir_items_leaf() to process the dir items of
       leaf B, and when we process the first item, corresponding to slot 0,
       sequence number 22, we notice the dir item was created in a past
       transaction and its sequence number is greater than the value of
       *last_old_dentry_offset + 1 (20 + 1), so we decide to log again a
       BTRFS_DIR_LOG_INDEX_KEY key with an offset of 21 and an end range
       of 21 (key.offset - 1 == 22 - 1 == 21), which results in an -EEXIST
       error from insert_dir_log_key(), as we have already inserted that
       key at step 2, triggering the assertion at process_dir_items_leaf().
    
    The trace produced in dmesg is like the following:
    
    assertion failed: ret != -EEXIST, in fs/btrfs/tree-log.c:3857
    [198255.980839][ T7460] ------------[ cut here ]------------
    [198255.981666][ T7460] kernel BUG at fs/btrfs/ctree.h:3617!
    [198255.983141][ T7460] invalid opcode: 0000 [#1] PREEMPT SMP KASAN PTI
    [198255.984080][ T7460] CPU: 0 PID: 7460 Comm: repro-ghost-dir Not tainted 5.18.0-5314c78ac373-misc-next+
    [198255.986027][ T7460] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.14.0-2 04/01/2014
    [198255.988600][ T7460] RIP: 0010:assertfail.constprop.0+0x1c/0x1e
    [198255.989465][ T7460] Code: 8b 4c 89 (...)
    [198255.992599][ T7460] RSP: 0018:ffffc90007387188 EFLAGS: 00010282
    [198255.993414][ T7460] RAX: 000000000000003d RBX: 0000000000000065 RCX: 0000000000000000
    [198255.996056][ T7460] RDX: 0000000000000001 RSI: ffffffff8b62b180 RDI: fffff52000e70e24
    [198255.997668][ T7460] RBP: ffffc90007387188 R08: 000000000000003d R09: ffff8881f0e16507
    [198255.999199][ T7460] R10: ffffed103e1c2ca0 R11: 0000000000000001 R12: 00000000ffffffef
    [198256.000683][ T7460] R13: ffff88813befc630 R14: ffff888116c16e70 R15: ffffc90007387358
    [198256.007082][ T7460] FS:  00007fc7f7c24640(0000) GS:ffff8881f0c00000(0000) knlGS:0000000000000000
    [198256.009939][ T7460] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [198256.014133][ T7460] CR2: 0000560bb16d0b78 CR3: 0000000140b34005 CR4: 0000000000170ef0
    [198256.015239][ T7460] Call Trace:
    [198256.015674][ T7460]  <TASK>
    [198256.016313][ T7460]  log_dir_items.cold+0x16/0x2c
    [198256.018858][ T7460]  ? replay_one_extent+0xbf0/0xbf0
    [198256.025932][ T7460]  ? release_extent_buffer+0x1d2/0x270
    [198256.029658][ T7460]  ? rcu_read_lock_sched_held+0x16/0x80
    [198256.031114][ T7460]  ? lock_acquired+0xbe/0x660
    [198256.032633][ T7460]  ? rcu_read_lock_sched_held+0x16/0x80
    [198256.034386][ T7460]  ? lock_release+0xcf/0x8a0
    [198256.036152][ T7460]  log_directory_changes+0xf9/0x170
    [198256.036993][ T7460]  ? log_dir_items+0xba0/0xba0
    [198256.037661][ T7460]  ? do_raw_write_unlock+0x7d/0xe0
    [198256.038680][ T7460]  btrfs_log_inode+0x233b/0x26d0
    [198256.041294][ T7460]  ? log_directory_changes+0x170/0x170
    [198256.042864][ T7460]  ? btrfs_attach_transaction_barrier+0x60/0x60
    [198256.045130][ T7460]  ? rcu_read_lock_sched_held+0x16/0x80
    [198256.046568][ T7460]  ? lock_release+0xcf/0x8a0
    [198256.047504][ T7460]  ? lock_downgrade+0x420/0x420
    [198256.048712][ T7460]  ? ilookup5_nowait+0x81/0xa0
    [198256.049747][ T7460]  ? lock_downgrade+0x420/0x420
    [198256.050652][ T7460]  ? do_raw_spin_unlock+0xa9/0x100
    [198256.051618][ T7460]  ? __might_resched+0x128/0x1c0
    [198256.052511][ T7460]  ? __might_sleep+0x66/0xc0
    [198256.053442][ T7460]  ? __kasan_check_read+0x11/0x20
    [198256.054251][ T7460]  ? iget5_locked+0xbd/0x150
    [198256.054986][ T7460]  ? run_delayed_iput_locked+0x110/0x110
    [198256.055929][ T7460]  ? btrfs_iget+0xc7/0x150
    [198256.056630][ T7460]  ? btrfs_orphan_cleanup+0x4a0/0x4a0
    [198256.057502][ T7460]  ? free_extent_buffer+0x13/0x20
    [198256.058322][ T7460]  btrfs_log_inode+0x2654/0x26d0
    [198256.059137][ T7460]  ? log_directory_changes+0x170/0x170
    [198256.060020][ T7460]  ? rcu_read_lock_sched_held+0x16/0x80
    [198256.060930][ T7460]  ? rcu_read_lock_sched_held+0x16/0x80
    [198256.061905][ T7460]  ? lock_contended+0x770/0x770
    [198256.062682][ T7460]  ? btrfs_log_inode_parent+0xd04/0x1750
    [198256.063582][ T7460]  ? lock_downgrade+0x420/0x420
    [198256.064432][ T7460]  ? preempt_count_sub+0x18/0xc0
    [198256.065550][ T7460]  ? __mutex_lock+0x580/0xdc0
    [198256.066654][ T7460]  ? stack_trace_save+0x94/0xc0
    [198256.068008][ T7460]  ? __kasan_check_write+0x14/0x20
    [198256.072149][ T7460]  ? __mutex_unlock_slowpath+0x12a/0x430
    [198256.073145][ T7460]  ? mutex_lock_io_nested+0xcd0/0xcd0
    [198256.074341][ T7460]  ? wait_for_completion_io_timeout+0x20/0x20
    [198256.075345][ T7460]  ? lock_downgrade+0x420/0x420
    [198256.076142][ T7460]  ? lock_contended+0x770/0x770
    [198256.076939][ T7460]  ? do_raw_spin_lock+0x1c0/0x1c0
    [198256.078401][ T7460]  ? btrfs_sync_file+0x5e6/0xa40
    [198256.080598][ T7460]  btrfs_log_inode_parent+0x523/0x1750
    [198256.081991][ T7460]  ? wait_current_trans+0xc8/0x240
    [198256.083320][ T7460]  ? lock_downgrade+0x420/0x420
    [198256.085450][ T7460]  ? btrfs_end_log_trans+0x70/0x70
    [198256.086362][ T7460]  ? rcu_read_lock_sched_held+0x16/0x80
    [198256.087544][ T7460]  ? lock_release+0xcf/0x8a0
    [198256.088305][ T7460]  ? lock_downgrade+0x420/0x420
    [198256.090375][ T7460]  ? dget_parent+0x8e/0x300
    [198256.093538][ T7460]  ? do_raw_spin_lock+0x1c0/0x1c0
    [198256.094918][ T7460]  ? lock_downgrade+0x420/0x420
    [198256.097815][ T7460]  ? do_raw_spin_unlock+0xa9/0x100
    [198256.101822][ T7460]  ? dget_parent+0xb7/0x300
    [198256.103345][ T7460]  btrfs_log_dentry_safe+0x48/0x60
    [198256.105052][ T7460]  btrfs_sync_file+0x629/0xa40
    [198256.106829][ T7460]  ? start_ordered_ops.constprop.0+0x120/0x120
    [198256.109655][ T7460]  ? __fget_files+0x161/0x230
    [198256.110760][ T7460]  vfs_fsync_range+0x6d/0x110
    [198256.111923][ T7460]  ? start_ordered_ops.constprop.0+0x120/0x120
    [198256.113556][ T7460]  __x64_sys_fsync+0x45/0x70
    [198256.114323][ T7460]  do_syscall_64+0x5c/0xc0
    [198256.115084][ T7460]  ? syscall_exit_to_user_mode+0x3b/0x50
    [198256.116030][ T7460]  ? do_syscall_64+0x69/0xc0
    [198256.116768][ T7460]  ? do_syscall_64+0x69/0xc0
    [198256.117555][ T7460]  ? do_syscall_64+0x69/0xc0
    [198256.118324][ T7460]  ? sysvec_call_function_single+0x57/0xc0
    [198256.119308][ T7460]  ? asm_sysvec_call_function_single+0xa/0x20
    [198256.120363][ T7460]  entry_SYSCALL_64_after_hwframe+0x44/0xae
    [198256.121334][ T7460] RIP: 0033:0x7fc7fe97b6ab
    [198256.122067][ T7460] Code: 0f 05 48 (...)
    [198256.125198][ T7460] RSP: 002b:00007fc7f7c23950 EFLAGS: 00000293 ORIG_RAX: 000000000000004a
    [198256.126568][ T7460] RAX: ffffffffffffffda RBX: 00007fc7f7c239f0 RCX: 00007fc7fe97b6ab
    [198256.127942][ T7460] RDX: 0000000000000002 RSI: 000056167536bcf0 RDI: 0000000000000004
    [198256.129302][ T7460] RBP: 0000000000000004 R08: 0000000000000000 R09: 000000007ffffeb8
    [198256.130670][ T7460] R10: 00000000000001ff R11: 0000000000000293 R12: 0000000000000001
    [198256.132046][ T7460] R13: 0000561674ca8140 R14: 00007fc7f7c239d0 R15: 000056167536dab8
    [198256.133403][ T7460]  </TASK>
    
    Fix this by treating -EEXIST as expected at insert_dir_log_key() and have
    it update the item with an end offset corresponding to the maximum between
    the previously logged end offset and the new requested end offset. The end
    offsets may be different due to dir index key deletions that happened as
    part of unlink operations while we are logging a directory (triggered when
    fsyncing some other inode parented by the directory) or during renames
    which always attempt to log a single dir index deletion.
    
    Reported-by: Zygo Blaxell <ce3g8jdj@umail.furryterror.org>
    Link: https://lore.kernel.org/linux-btrfs/YmyefE9mc2xl5ZMz@hungrycats.org/
    Fixes: 732d591a5d6c12 ("btrfs: stop copying old dir items when logging a directory")
    Signed-off-by: Filipe Manana <fdmanana@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

commit 8467f9e34955c6923e0ed63b1c2dbbf1df70b908
Merge: 1f5e98e723a0 9dca4168a37c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Apr 23 09:46:44 2022 -0700

    Merge tag 'block-5.18-2022-04-22' of git://git.kernel.dk/linux-block
    
    Pull block fixes from Jens Axboe:
     "Just two small regression fixes for bcache"
    
    * tag 'block-5.18-2022-04-22' of git://git.kernel.dk/linux-block:
      bcache: fix wrong bdev parameter when calling bio_alloc_clone() in do_bio_hook()
      bcache: put bch_bio_map() back to correct location in journal_write_unlocked()

commit ff2695e52c9936febf65aa36a1769881da71bec5
Author: Coly Li <colyli@suse.de>
Date:   Wed Apr 20 00:04:24 2022 +0800

    bcache: put bch_bio_map() back to correct location in journal_write_unlocked()
    
    Commit a7c50c940477 ("block: pass a block_device and opf to bio_reset")
    moves bch_bio_map() inside journal_write_unlocked() next to the location
    where the modified bio_reset() was called.
    
    This change is wrong because calling bch_bio_map() immediately after
    bio_reset(), a BUG_ON(!bio->bi_iter.bi_size) inside bch_bio_map() will
    be triggered and panic the kernel.
    
    This patch puts bch_bio_map() back to its original correct location in
    journal_write_unlocked() and avoid the BUG_ON().
    
    Fixes: a7c50c940477 ("block: pass a block_device and opf to bio_reset")
    Signed-off-by: Coly Li <colyli@suse.de>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Chaitanya Kulkarni <kch@nvidia.com>
    Link: https://lore.kernel.org/r/20220419160425.4148-2-colyli@suse.de
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

commit c1cee4ab36acef271be9101590756ed0c0c374d9
Author: Jan Kara <jack@suse.cz>
Date:   Fri Apr 1 12:27:43 2022 +0200

    bfq: Avoid merging queues with different parents
    
    It can happen that the parent of a bfqq changes between the moment we
    decide two queues are worth to merge (and set bic->stable_merge_bfqq)
    and the moment bfq_setup_merge() is called. This can happen e.g. because
    the process submitted IO for a different cgroup and thus bfqq got
    reparented. It can even happen that the bfqq we are merging with has
    parent cgroup that is already offline and going to be destroyed in which
    case the merge can lead to use-after-free issues such as:
    
    BUG: KASAN: use-after-free in __bfq_deactivate_entity+0x9cb/0xa50
    Read of size 8 at addr ffff88800693c0c0 by task runc:[2:INIT]/10544
    
    CPU: 0 PID: 10544 Comm: runc:[2:INIT] Tainted: G            E     5.15.2-0.g5fb85fd-default #1 openSUSE Tumbleweed (unreleased) f1f3b891c72369aebecd2e43e4641a6358867c70
    Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.14.0-0-g155821a-rebuilt.opensuse.org 04/01/2014
    Call Trace:
     <IRQ>
     dump_stack_lvl+0x46/0x5a
     print_address_description.constprop.0+0x1f/0x140
     ? __bfq_deactivate_entity+0x9cb/0xa50
     kasan_report.cold+0x7f/0x11b
     ? __bfq_deactivate_entity+0x9cb/0xa50
     __bfq_deactivate_entity+0x9cb/0xa50
     ? update_curr+0x32f/0x5d0
     bfq_deactivate_entity+0xa0/0x1d0
     bfq_del_bfqq_busy+0x28a/0x420
     ? resched_curr+0x116/0x1d0
     ? bfq_requeue_bfqq+0x70/0x70
     ? check_preempt_wakeup+0x52b/0xbc0
     __bfq_bfqq_expire+0x1a2/0x270
     bfq_bfqq_expire+0xd16/0x2160
     ? try_to_wake_up+0x4ee/0x1260
     ? bfq_end_wr_async_queues+0xe0/0xe0
     ? _raw_write_unlock_bh+0x60/0x60
     ? _raw_spin_lock_irq+0x81/0xe0
     bfq_idle_slice_timer+0x109/0x280
     ? bfq_dispatch_request+0x4870/0x4870
     __hrtimer_run_queues+0x37d/0x700
     ? enqueue_hrtimer+0x1b0/0x1b0
     ? kvm_clock_get_cycles+0xd/0x10
     ? ktime_get_update_offsets_now+0x6f/0x280
     hrtimer_interrupt+0x2c8/0x740
    
    Fix the problem by checking that the parent of the two bfqqs we are
    merging in bfq_setup_merge() is the same.
    
    Link: https://lore.kernel.org/linux-block/20211125172809.GC19572@quack2.suse.cz/
    CC: stable@vger.kernel.org
    Fixes: 430a67f9d616 ("block, bfq: merge bursts of newly-created queues")
    Tested-by: "yukuai (C)" <yukuai3@huawei.com>
    Signed-off-by: Jan Kara <jack@suse.cz>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Link: https://lore.kernel.org/r/20220401102752.8599-2-jack@suse.cz
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

commit e9c478014b602fda2a99a6370d9eb2e5d7355246
Author: Damien Le Moal <damien.lemoal@opensource.wdc.com>
Date:   Tue Mar 1 20:30:08 2022 +0900

    scsi: scsi_debug: Silence unexpected unlock warnings
    
    The return statement inside the sdeb_read_lock(), sdeb_read_unlock(),
    sdeb_write_lock() and sdeb_write_unlock() confuse sparse, leading to many
    warnings about unexpected unlocks in the resp_xxx() functions.
    
    Modify the lock/unlock functions using the __acquire() and __release()
    inline annotations for the sdebug_no_rwlock == true case to avoid these
    warnings.
    
    Link: https://lore.kernel.org/r/20220301113009.595857-2-damien.lemoal@opensource.wdc.com
    Acked-by: Douglas Gilbert <dgilbert@interlog.com>
    Signed-off-by: Damien Le Moal <damien.lemoal@opensource.wdc.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

commit f7f497cb702462e8505ff3d8d4e7722ad95626a1
Author: Ritesh Harjani <riteshh@linux.ibm.com>
Date:   Wed Feb 16 12:30:35 2022 +0530

    jbd2: kill t_handle_lock transaction spinlock
    
    This patch kills t_handle_lock transaction spinlock completely from
    jbd2.
    
    To explain the reasoning, currently there were three sites at which
    this spinlock was used.
    
    1. jbd2_journal_wait_updates()
       a. Based on careful code review it can be seen that, we don't need this
          lock here. This is since we wait for any currently ongoing updates
          based on a atomic variable t_updates. And we anyway don't take any
          t_handle_lock while in stop_this_handle().
          i.e.
    
            write_lock(&journal->j_state_lock()
            jbd2_journal_wait_updates()                     stop_this_handle()
                    while (atomic_read(txn->t_updates) {            |
                    DEFINE_WAIT(wait);                              |
                    prepare_to_wait();                              |
                    if (atomic_read(txn->t_updates)                 if (atomic_dec_and_test(txn->t_updates))
                            write_unlock(&journal->j_state_lock);
                            schedule();                                     wake_up()
                            write_lock(&journal->j_state_lock);
                    finish_wait();
               }
            txn->t_state = T_COMMIT
            write_unlock(&journal->j_state_lock);
    
       b.  Also note that between atomic_inc(&txn->t_updates) in
           start_this_handle() and jbd2_journal_wait_updates(), the
           synchronization happens via read_lock(journal->j_state_lock) in
           start_this_handle();
    
    2. jbd2_journal_extend()
       a. jbd2_journal_extend() is called with the handle of each process from
          task_struct. So no lock required in updating member fields of handle_t
    
       b. For member fields of h_transaction, all updates happens only via
          atomic APIs (which is also within read_lock()).
          So, no need of this transaction spinlock.
    
    3. update_t_max_wait()
       Based on Jan suggestion, this can be carefully removed using atomic
       cmpxchg API.
       Note that there can be several processes which are waiting for a new
       transaction to be allocated and started. For doing this only one
       process will succeed in taking write_lock() and allocating a new txn.
       After that all of the process will be updating the t_max_wait (max
       transaction wait time). This can be done via below method w/o taking
       any locks using atomic cmpxchg.
       For more details refer [1]
    
               new = get_new_val();
               old = READ_ONCE(ptr->max_val);
               while (old < new)
                    old = cmpxchg(&ptr->max_val, old, new);
    
    [1]: https://lwn.net/Articles/849237/
    
    Suggested-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Ritesh Harjani <riteshh@linux.ibm.com>
    Reviewed-by: Jan Kara <jack@suse.cz>
    Link: https://lore.kernel.org/r/d89e599658b4a1f3893a48c6feded200073037fc.1644992076.git.riteshh@linux.ibm.com
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>

commit dfd5b60b5342b6b505a104e48f08ad9b9bdbbd7b
Author: Andrea Righi <andrea.righi@canonical.com>
Date:   Mon Nov 29 00:08:13 2021 -0800

    Input: elantech - fix stack out of bound access in elantech_change_report_id()
    
    [ Upstream commit 1d72d9f960ccf1052a0630a68c3d358791dbdaaa ]
    
    The array param[] in elantech_change_report_id() must be at least 3
    bytes, because elantech_read_reg_params() is calling ps2_command() with
    PSMOUSE_CMD_GETINFO, that is going to access 3 bytes from param[], but
    it's defined in the stack as an array of 2 bytes, therefore we have a
    potential stack out-of-bounds access here, also confirmed by KASAN:
    
    [    6.512374] BUG: KASAN: stack-out-of-bounds in __ps2_command+0x372/0x7e0
    [    6.512397] Read of size 1 at addr ffff8881024d77c2 by task kworker/2:1/118
    
    [    6.512416] CPU: 2 PID: 118 Comm: kworker/2:1 Not tainted 5.13.0-22-generic #22+arighi20211110
    [    6.512428] Hardware name: LENOVO 20T8000QGE/20T8000QGE, BIOS R1AET32W (1.08 ) 08/14/2020
    [    6.512436] Workqueue: events_long serio_handle_event
    [    6.512453] Call Trace:
    [    6.512462]  show_stack+0x52/0x58
    [    6.512474]  dump_stack+0xa1/0xd3
    [    6.512487]  print_address_description.constprop.0+0x1d/0x140
    [    6.512502]  ? __ps2_command+0x372/0x7e0
    [    6.512516]  __kasan_report.cold+0x7d/0x112
    [    6.512527]  ? _raw_write_lock_irq+0x20/0xd0
    [    6.512539]  ? __ps2_command+0x372/0x7e0
    [    6.512552]  kasan_report+0x3c/0x50
    [    6.512564]  __asan_load1+0x6a/0x70
    [    6.512575]  __ps2_command+0x372/0x7e0
    [    6.512589]  ? ps2_drain+0x240/0x240
    [    6.512601]  ? dev_printk_emit+0xa2/0xd3
    [    6.512612]  ? dev_vprintk_emit+0xc5/0xc5
    [    6.512621]  ? __kasan_check_write+0x14/0x20
    [    6.512634]  ? mutex_lock+0x8f/0xe0
    [    6.512643]  ? __mutex_lock_slowpath+0x20/0x20
    [    6.512655]  ps2_command+0x52/0x90
    [    6.512670]  elantech_ps2_command+0x4f/0xc0 [psmouse]
    [    6.512734]  elantech_change_report_id+0x1e6/0x256 [psmouse]
    [    6.512799]  ? elantech_report_trackpoint.constprop.0.cold+0xd/0xd [psmouse]
    [    6.512863]  ? ps2_command+0x7f/0x90
    [    6.512877]  elantech_query_info.cold+0x6bd/0x9ed [psmouse]
    [    6.512943]  ? elantech_setup_ps2+0x460/0x460 [psmouse]
    [    6.513005]  ? psmouse_reset+0x69/0xb0 [psmouse]
    [    6.513064]  ? psmouse_attr_set_helper+0x2a0/0x2a0 [psmouse]
    [    6.513122]  ? phys_pmd_init+0x30e/0x521
    [    6.513137]  elantech_init+0x8a/0x200 [psmouse]
    [    6.513200]  ? elantech_init_ps2+0xf0/0xf0 [psmouse]
    [    6.513249]  ? elantech_query_info+0x440/0x440 [psmouse]
    [    6.513296]  ? synaptics_send_cmd+0x60/0x60 [psmouse]
    [    6.513342]  ? elantech_query_info+0x440/0x440 [psmouse]
    [    6.513388]  ? psmouse_try_protocol+0x11e/0x170 [psmouse]
    [    6.513432]  psmouse_extensions+0x65d/0x6e0 [psmouse]
    [    6.513476]  ? psmouse_try_protocol+0x170/0x170 [psmouse]
    [    6.513519]  ? mutex_unlock+0x22/0x40
    [    6.513526]  ? ps2_command+0x7f/0x90
    [    6.513536]  ? psmouse_probe+0xa3/0xf0 [psmouse]
    [    6.513580]  psmouse_switch_protocol+0x27d/0x2e0 [psmouse]
    [    6.513624]  psmouse_connect+0x272/0x530 [psmouse]
    [    6.513669]  serio_driver_probe+0x55/0x70
    [    6.513679]  really_probe+0x190/0x720
    [    6.513689]  driver_probe_device+0x160/0x1f0
    [    6.513697]  device_driver_attach+0x119/0x130
    [    6.513705]  ? device_driver_attach+0x130/0x130
    [    6.513713]  __driver_attach+0xe7/0x1a0
    [    6.513720]  ? device_driver_attach+0x130/0x130
    [    6.513728]  bus_for_each_dev+0xfb/0x150
    [    6.513738]  ? subsys_dev_iter_exit+0x10/0x10
    [    6.513748]  ? _raw_write_unlock_bh+0x30/0x30
    [    6.513757]  driver_attach+0x2d/0x40
    [    6.513764]  serio_handle_event+0x199/0x3d0
    [    6.513775]  process_one_work+0x471/0x740
    [    6.513785]  worker_thread+0x2d2/0x790
    [    6.513794]  ? process_one_work+0x740/0x740
    [    6.513802]  kthread+0x1b4/0x1e0
    [    6.513809]  ? set_kthread_struct+0x80/0x80
    [    6.513816]  ret_from_fork+0x22/0x30
    
    [    6.513832] The buggy address belongs to the page:
    [    6.513838] page:00000000bc35e189 refcount:0 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x1024d7
    [    6.513847] flags: 0x17ffffc0000000(node=0|zone=2|lastcpupid=0x1fffff)
    [    6.513860] raw: 0017ffffc0000000 dead000000000100 dead000000000122 0000000000000000
    [    6.513867] raw: 0000000000000000 0000000000000000 00000000ffffffff 0000000000000000
    [    6.513872] page dumped because: kasan: bad access detected
    
    [    6.513879] addr ffff8881024d77c2 is located in stack of task kworker/2:1/118 at offset 34 in frame:
    [    6.513887]  elantech_change_report_id+0x0/0x256 [psmouse]
    
    [    6.513941] this frame has 1 object:
    [    6.513947]  [32, 34) 'param'
    
    [    6.513956] Memory state around the buggy address:
    [    6.513962]  ffff8881024d7680: f2 f2 f2 f2 f2 00 00 f3 f3 00 00 00 00 00 00 00
    [    6.513969]  ffff8881024d7700: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    [    6.513976] >ffff8881024d7780: 00 00 00 00 f1 f1 f1 f1 02 f3 f3 f3 00 00 00 00
    [    6.513982]                                            ^
    [    6.513988]  ffff8881024d7800: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    [    6.513995]  ffff8881024d7880: 00 f1 f1 f1 f1 03 f2 03 f2 03 f3 f3 f3 00 00 00
    [    6.514000] ==================================================================
    
    Define param[] in elantech_change_report_id() as an array of 3 bytes to
    prevent the out-of-bounds access in the stack.
    
    Fixes: e4c9062717fe ("Input: elantech - fix protocol errors for some trackpoints in SMBus mode")
    BugLink: https://bugs.launchpad.net/bugs/1945590
    Signed-off-by: Andrea Righi <andrea.righi@canonical.com>
    Reviewed-by: Wolfram Sang <wsa@kernel.org>
    Link: https://lore.kernel.org/r/20211116095559.24395-1-andrea.righi@canonical.com
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 676c572439e58b7ee6b7ca3f1e5595382921045c
Author: Andrea Righi <andrea.righi@canonical.com>
Date:   Mon Nov 29 00:08:13 2021 -0800

    Input: elantech - fix stack out of bound access in elantech_change_report_id()
    
    [ Upstream commit 1d72d9f960ccf1052a0630a68c3d358791dbdaaa ]
    
    The array param[] in elantech_change_report_id() must be at least 3
    bytes, because elantech_read_reg_params() is calling ps2_command() with
    PSMOUSE_CMD_GETINFO, that is going to access 3 bytes from param[], but
    it's defined in the stack as an array of 2 bytes, therefore we have a
    potential stack out-of-bounds access here, also confirmed by KASAN:
    
    [    6.512374] BUG: KASAN: stack-out-of-bounds in __ps2_command+0x372/0x7e0
    [    6.512397] Read of size 1 at addr ffff8881024d77c2 by task kworker/2:1/118
    
    [    6.512416] CPU: 2 PID: 118 Comm: kworker/2:1 Not tainted 5.13.0-22-generic #22+arighi20211110
    [    6.512428] Hardware name: LENOVO 20T8000QGE/20T8000QGE, BIOS R1AET32W (1.08 ) 08/14/2020
    [    6.512436] Workqueue: events_long serio_handle_event
    [    6.512453] Call Trace:
    [    6.512462]  show_stack+0x52/0x58
    [    6.512474]  dump_stack+0xa1/0xd3
    [    6.512487]  print_address_description.constprop.0+0x1d/0x140
    [    6.512502]  ? __ps2_command+0x372/0x7e0
    [    6.512516]  __kasan_report.cold+0x7d/0x112
    [    6.512527]  ? _raw_write_lock_irq+0x20/0xd0
    [    6.512539]  ? __ps2_command+0x372/0x7e0
    [    6.512552]  kasan_report+0x3c/0x50
    [    6.512564]  __asan_load1+0x6a/0x70
    [    6.512575]  __ps2_command+0x372/0x7e0
    [    6.512589]  ? ps2_drain+0x240/0x240
    [    6.512601]  ? dev_printk_emit+0xa2/0xd3
    [    6.512612]  ? dev_vprintk_emit+0xc5/0xc5
    [    6.512621]  ? __kasan_check_write+0x14/0x20
    [    6.512634]  ? mutex_lock+0x8f/0xe0
    [    6.512643]  ? __mutex_lock_slowpath+0x20/0x20
    [    6.512655]  ps2_command+0x52/0x90
    [    6.512670]  elantech_ps2_command+0x4f/0xc0 [psmouse]
    [    6.512734]  elantech_change_report_id+0x1e6/0x256 [psmouse]
    [    6.512799]  ? elantech_report_trackpoint.constprop.0.cold+0xd/0xd [psmouse]
    [    6.512863]  ? ps2_command+0x7f/0x90
    [    6.512877]  elantech_query_info.cold+0x6bd/0x9ed [psmouse]
    [    6.512943]  ? elantech_setup_ps2+0x460/0x460 [psmouse]
    [    6.513005]  ? psmouse_reset+0x69/0xb0 [psmouse]
    [    6.513064]  ? psmouse_attr_set_helper+0x2a0/0x2a0 [psmouse]
    [    6.513122]  ? phys_pmd_init+0x30e/0x521
    [    6.513137]  elantech_init+0x8a/0x200 [psmouse]
    [    6.513200]  ? elantech_init_ps2+0xf0/0xf0 [psmouse]
    [    6.513249]  ? elantech_query_info+0x440/0x440 [psmouse]
    [    6.513296]  ? synaptics_send_cmd+0x60/0x60 [psmouse]
    [    6.513342]  ? elantech_query_info+0x440/0x440 [psmouse]
    [    6.513388]  ? psmouse_try_protocol+0x11e/0x170 [psmouse]
    [    6.513432]  psmouse_extensions+0x65d/0x6e0 [psmouse]
    [    6.513476]  ? psmouse_try_protocol+0x170/0x170 [psmouse]
    [    6.513519]  ? mutex_unlock+0x22/0x40
    [    6.513526]  ? ps2_command+0x7f/0x90
    [    6.513536]  ? psmouse_probe+0xa3/0xf0 [psmouse]
    [    6.513580]  psmouse_switch_protocol+0x27d/0x2e0 [psmouse]
    [    6.513624]  psmouse_connect+0x272/0x530 [psmouse]
    [    6.513669]  serio_driver_probe+0x55/0x70
    [    6.513679]  really_probe+0x190/0x720
    [    6.513689]  driver_probe_device+0x160/0x1f0
    [    6.513697]  device_driver_attach+0x119/0x130
    [    6.513705]  ? device_driver_attach+0x130/0x130
    [    6.513713]  __driver_attach+0xe7/0x1a0
    [    6.513720]  ? device_driver_attach+0x130/0x130
    [    6.513728]  bus_for_each_dev+0xfb/0x150
    [    6.513738]  ? subsys_dev_iter_exit+0x10/0x10
    [    6.513748]  ? _raw_write_unlock_bh+0x30/0x30
    [    6.513757]  driver_attach+0x2d/0x40
    [    6.513764]  serio_handle_event+0x199/0x3d0
    [    6.513775]  process_one_work+0x471/0x740
    [    6.513785]  worker_thread+0x2d2/0x790
    [    6.513794]  ? process_one_work+0x740/0x740
    [    6.513802]  kthread+0x1b4/0x1e0
    [    6.513809]  ? set_kthread_struct+0x80/0x80
    [    6.513816]  ret_from_fork+0x22/0x30
    
    [    6.513832] The buggy address belongs to the page:
    [    6.513838] page:00000000bc35e189 refcount:0 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x1024d7
    [    6.513847] flags: 0x17ffffc0000000(node=0|zone=2|lastcpupid=0x1fffff)
    [    6.513860] raw: 0017ffffc0000000 dead000000000100 dead000000000122 0000000000000000
    [    6.513867] raw: 0000000000000000 0000000000000000 00000000ffffffff 0000000000000000
    [    6.513872] page dumped because: kasan: bad access detected
    
    [    6.513879] addr ffff8881024d77c2 is located in stack of task kworker/2:1/118 at offset 34 in frame:
    [    6.513887]  elantech_change_report_id+0x0/0x256 [psmouse]
    
    [    6.513941] this frame has 1 object:
    [    6.513947]  [32, 34) 'param'
    
    [    6.513956] Memory state around the buggy address:
    [    6.513962]  ffff8881024d7680: f2 f2 f2 f2 f2 00 00 f3 f3 00 00 00 00 00 00 00
    [    6.513969]  ffff8881024d7700: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    [    6.513976] >ffff8881024d7780: 00 00 00 00 f1 f1 f1 f1 02 f3 f3 f3 00 00 00 00
    [    6.513982]                                            ^
    [    6.513988]  ffff8881024d7800: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    [    6.513995]  ffff8881024d7880: 00 f1 f1 f1 f1 03 f2 03 f2 03 f3 f3 f3 00 00 00
    [    6.514000] ==================================================================
    
    Define param[] in elantech_change_report_id() as an array of 3 bytes to
    prevent the out-of-bounds access in the stack.
    
    Fixes: e4c9062717fe ("Input: elantech - fix protocol errors for some trackpoints in SMBus mode")
    BugLink: https://bugs.launchpad.net/bugs/1945590
    Signed-off-by: Andrea Righi <andrea.righi@canonical.com>
    Reviewed-by: Wolfram Sang <wsa@kernel.org>
    Link: https://lore.kernel.org/r/20211116095559.24395-1-andrea.righi@canonical.com
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit a7f95328c6f0afffdc4555f16e3bbab8bbf0d9be
Author: Andrea Righi <andrea.righi@canonical.com>
Date:   Mon Nov 29 00:08:13 2021 -0800

    Input: elantech - fix stack out of bound access in elantech_change_report_id()
    
    [ Upstream commit 1d72d9f960ccf1052a0630a68c3d358791dbdaaa ]
    
    The array param[] in elantech_change_report_id() must be at least 3
    bytes, because elantech_read_reg_params() is calling ps2_command() with
    PSMOUSE_CMD_GETINFO, that is going to access 3 bytes from param[], but
    it's defined in the stack as an array of 2 bytes, therefore we have a
    potential stack out-of-bounds access here, also confirmed by KASAN:
    
    [    6.512374] BUG: KASAN: stack-out-of-bounds in __ps2_command+0x372/0x7e0
    [    6.512397] Read of size 1 at addr ffff8881024d77c2 by task kworker/2:1/118
    
    [    6.512416] CPU: 2 PID: 118 Comm: kworker/2:1 Not tainted 5.13.0-22-generic #22+arighi20211110
    [    6.512428] Hardware name: LENOVO 20T8000QGE/20T8000QGE, BIOS R1AET32W (1.08 ) 08/14/2020
    [    6.512436] Workqueue: events_long serio_handle_event
    [    6.512453] Call Trace:
    [    6.512462]  show_stack+0x52/0x58
    [    6.512474]  dump_stack+0xa1/0xd3
    [    6.512487]  print_address_description.constprop.0+0x1d/0x140
    [    6.512502]  ? __ps2_command+0x372/0x7e0
    [    6.512516]  __kasan_report.cold+0x7d/0x112
    [    6.512527]  ? _raw_write_lock_irq+0x20/0xd0
    [    6.512539]  ? __ps2_command+0x372/0x7e0
    [    6.512552]  kasan_report+0x3c/0x50
    [    6.512564]  __asan_load1+0x6a/0x70
    [    6.512575]  __ps2_command+0x372/0x7e0
    [    6.512589]  ? ps2_drain+0x240/0x240
    [    6.512601]  ? dev_printk_emit+0xa2/0xd3
    [    6.512612]  ? dev_vprintk_emit+0xc5/0xc5
    [    6.512621]  ? __kasan_check_write+0x14/0x20
    [    6.512634]  ? mutex_lock+0x8f/0xe0
    [    6.512643]  ? __mutex_lock_slowpath+0x20/0x20
    [    6.512655]  ps2_command+0x52/0x90
    [    6.512670]  elantech_ps2_command+0x4f/0xc0 [psmouse]
    [    6.512734]  elantech_change_report_id+0x1e6/0x256 [psmouse]
    [    6.512799]  ? elantech_report_trackpoint.constprop.0.cold+0xd/0xd [psmouse]
    [    6.512863]  ? ps2_command+0x7f/0x90
    [    6.512877]  elantech_query_info.cold+0x6bd/0x9ed [psmouse]
    [    6.512943]  ? elantech_setup_ps2+0x460/0x460 [psmouse]
    [    6.513005]  ? psmouse_reset+0x69/0xb0 [psmouse]
    [    6.513064]  ? psmouse_attr_set_helper+0x2a0/0x2a0 [psmouse]
    [    6.513122]  ? phys_pmd_init+0x30e/0x521
    [    6.513137]  elantech_init+0x8a/0x200 [psmouse]
    [    6.513200]  ? elantech_init_ps2+0xf0/0xf0 [psmouse]
    [    6.513249]  ? elantech_query_info+0x440/0x440 [psmouse]
    [    6.513296]  ? synaptics_send_cmd+0x60/0x60 [psmouse]
    [    6.513342]  ? elantech_query_info+0x440/0x440 [psmouse]
    [    6.513388]  ? psmouse_try_protocol+0x11e/0x170 [psmouse]
    [    6.513432]  psmouse_extensions+0x65d/0x6e0 [psmouse]
    [    6.513476]  ? psmouse_try_protocol+0x170/0x170 [psmouse]
    [    6.513519]  ? mutex_unlock+0x22/0x40
    [    6.513526]  ? ps2_command+0x7f/0x90
    [    6.513536]  ? psmouse_probe+0xa3/0xf0 [psmouse]
    [    6.513580]  psmouse_switch_protocol+0x27d/0x2e0 [psmouse]
    [    6.513624]  psmouse_connect+0x272/0x530 [psmouse]
    [    6.513669]  serio_driver_probe+0x55/0x70
    [    6.513679]  really_probe+0x190/0x720
    [    6.513689]  driver_probe_device+0x160/0x1f0
    [    6.513697]  device_driver_attach+0x119/0x130
    [    6.513705]  ? device_driver_attach+0x130/0x130
    [    6.513713]  __driver_attach+0xe7/0x1a0
    [    6.513720]  ? device_driver_attach+0x130/0x130
    [    6.513728]  bus_for_each_dev+0xfb/0x150
    [    6.513738]  ? subsys_dev_iter_exit+0x10/0x10
    [    6.513748]  ? _raw_write_unlock_bh+0x30/0x30
    [    6.513757]  driver_attach+0x2d/0x40
    [    6.513764]  serio_handle_event+0x199/0x3d0
    [    6.513775]  process_one_work+0x471/0x740
    [    6.513785]  worker_thread+0x2d2/0x790
    [    6.513794]  ? process_one_work+0x740/0x740
    [    6.513802]  kthread+0x1b4/0x1e0
    [    6.513809]  ? set_kthread_struct+0x80/0x80
    [    6.513816]  ret_from_fork+0x22/0x30
    
    [    6.513832] The buggy address belongs to the page:
    [    6.513838] page:00000000bc35e189 refcount:0 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x1024d7
    [    6.513847] flags: 0x17ffffc0000000(node=0|zone=2|lastcpupid=0x1fffff)
    [    6.513860] raw: 0017ffffc0000000 dead000000000100 dead000000000122 0000000000000000
    [    6.513867] raw: 0000000000000000 0000000000000000 00000000ffffffff 0000000000000000
    [    6.513872] page dumped because: kasan: bad access detected
    
    [    6.513879] addr ffff8881024d77c2 is located in stack of task kworker/2:1/118 at offset 34 in frame:
    [    6.513887]  elantech_change_report_id+0x0/0x256 [psmouse]
    
    [    6.513941] this frame has 1 object:
    [    6.513947]  [32, 34) 'param'
    
    [    6.513956] Memory state around the buggy address:
    [    6.513962]  ffff8881024d7680: f2 f2 f2 f2 f2 00 00 f3 f3 00 00 00 00 00 00 00
    [    6.513969]  ffff8881024d7700: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    [    6.513976] >ffff8881024d7780: 00 00 00 00 f1 f1 f1 f1 02 f3 f3 f3 00 00 00 00
    [    6.513982]                                            ^
    [    6.513988]  ffff8881024d7800: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    [    6.513995]  ffff8881024d7880: 00 f1 f1 f1 f1 03 f2 03 f2 03 f3 f3 f3 00 00 00
    [    6.514000] ==================================================================
    
    Define param[] in elantech_change_report_id() as an array of 3 bytes to
    prevent the out-of-bounds access in the stack.
    
    Fixes: e4c9062717fe ("Input: elantech - fix protocol errors for some trackpoints in SMBus mode")
    BugLink: https://bugs.launchpad.net/bugs/1945590
    Signed-off-by: Andrea Righi <andrea.righi@canonical.com>
    Reviewed-by: Wolfram Sang <wsa@kernel.org>
    Link: https://lore.kernel.org/r/20211116095559.24395-1-andrea.righi@canonical.com
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 1d72d9f960ccf1052a0630a68c3d358791dbdaaa
Author: Andrea Righi <andrea.righi@canonical.com>
Date:   Mon Nov 29 00:08:13 2021 -0800

    Input: elantech - fix stack out of bound access in elantech_change_report_id()
    
    The array param[] in elantech_change_report_id() must be at least 3
    bytes, because elantech_read_reg_params() is calling ps2_command() with
    PSMOUSE_CMD_GETINFO, that is going to access 3 bytes from param[], but
    it's defined in the stack as an array of 2 bytes, therefore we have a
    potential stack out-of-bounds access here, also confirmed by KASAN:
    
    [    6.512374] BUG: KASAN: stack-out-of-bounds in __ps2_command+0x372/0x7e0
    [    6.512397] Read of size 1 at addr ffff8881024d77c2 by task kworker/2:1/118
    
    [    6.512416] CPU: 2 PID: 118 Comm: kworker/2:1 Not tainted 5.13.0-22-generic #22+arighi20211110
    [    6.512428] Hardware name: LENOVO 20T8000QGE/20T8000QGE, BIOS R1AET32W (1.08 ) 08/14/2020
    [    6.512436] Workqueue: events_long serio_handle_event
    [    6.512453] Call Trace:
    [    6.512462]  show_stack+0x52/0x58
    [    6.512474]  dump_stack+0xa1/0xd3
    [    6.512487]  print_address_description.constprop.0+0x1d/0x140
    [    6.512502]  ? __ps2_command+0x372/0x7e0
    [    6.512516]  __kasan_report.cold+0x7d/0x112
    [    6.512527]  ? _raw_write_lock_irq+0x20/0xd0
    [    6.512539]  ? __ps2_command+0x372/0x7e0
    [    6.512552]  kasan_report+0x3c/0x50
    [    6.512564]  __asan_load1+0x6a/0x70
    [    6.512575]  __ps2_command+0x372/0x7e0
    [    6.512589]  ? ps2_drain+0x240/0x240
    [    6.512601]  ? dev_printk_emit+0xa2/0xd3
    [    6.512612]  ? dev_vprintk_emit+0xc5/0xc5
    [    6.512621]  ? __kasan_check_write+0x14/0x20
    [    6.512634]  ? mutex_lock+0x8f/0xe0
    [    6.512643]  ? __mutex_lock_slowpath+0x20/0x20
    [    6.512655]  ps2_command+0x52/0x90
    [    6.512670]  elantech_ps2_command+0x4f/0xc0 [psmouse]
    [    6.512734]  elantech_change_report_id+0x1e6/0x256 [psmouse]
    [    6.512799]  ? elantech_report_trackpoint.constprop.0.cold+0xd/0xd [psmouse]
    [    6.512863]  ? ps2_command+0x7f/0x90
    [    6.512877]  elantech_query_info.cold+0x6bd/0x9ed [psmouse]
    [    6.512943]  ? elantech_setup_ps2+0x460/0x460 [psmouse]
    [    6.513005]  ? psmouse_reset+0x69/0xb0 [psmouse]
    [    6.513064]  ? psmouse_attr_set_helper+0x2a0/0x2a0 [psmouse]
    [    6.513122]  ? phys_pmd_init+0x30e/0x521
    [    6.513137]  elantech_init+0x8a/0x200 [psmouse]
    [    6.513200]  ? elantech_init_ps2+0xf0/0xf0 [psmouse]
    [    6.513249]  ? elantech_query_info+0x440/0x440 [psmouse]
    [    6.513296]  ? synaptics_send_cmd+0x60/0x60 [psmouse]
    [    6.513342]  ? elantech_query_info+0x440/0x440 [psmouse]
    [    6.513388]  ? psmouse_try_protocol+0x11e/0x170 [psmouse]
    [    6.513432]  psmouse_extensions+0x65d/0x6e0 [psmouse]
    [    6.513476]  ? psmouse_try_protocol+0x170/0x170 [psmouse]
    [    6.513519]  ? mutex_unlock+0x22/0x40
    [    6.513526]  ? ps2_command+0x7f/0x90
    [    6.513536]  ? psmouse_probe+0xa3/0xf0 [psmouse]
    [    6.513580]  psmouse_switch_protocol+0x27d/0x2e0 [psmouse]
    [    6.513624]  psmouse_connect+0x272/0x530 [psmouse]
    [    6.513669]  serio_driver_probe+0x55/0x70
    [    6.513679]  really_probe+0x190/0x720
    [    6.513689]  driver_probe_device+0x160/0x1f0
    [    6.513697]  device_driver_attach+0x119/0x130
    [    6.513705]  ? device_driver_attach+0x130/0x130
    [    6.513713]  __driver_attach+0xe7/0x1a0
    [    6.513720]  ? device_driver_attach+0x130/0x130
    [    6.513728]  bus_for_each_dev+0xfb/0x150
    [    6.513738]  ? subsys_dev_iter_exit+0x10/0x10
    [    6.513748]  ? _raw_write_unlock_bh+0x30/0x30
    [    6.513757]  driver_attach+0x2d/0x40
    [    6.513764]  serio_handle_event+0x199/0x3d0
    [    6.513775]  process_one_work+0x471/0x740
    [    6.513785]  worker_thread+0x2d2/0x790
    [    6.513794]  ? process_one_work+0x740/0x740
    [    6.513802]  kthread+0x1b4/0x1e0
    [    6.513809]  ? set_kthread_struct+0x80/0x80
    [    6.513816]  ret_from_fork+0x22/0x30
    
    [    6.513832] The buggy address belongs to the page:
    [    6.513838] page:00000000bc35e189 refcount:0 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x1024d7
    [    6.513847] flags: 0x17ffffc0000000(node=0|zone=2|lastcpupid=0x1fffff)
    [    6.513860] raw: 0017ffffc0000000 dead000000000100 dead000000000122 0000000000000000
    [    6.513867] raw: 0000000000000000 0000000000000000 00000000ffffffff 0000000000000000
    [    6.513872] page dumped because: kasan: bad access detected
    
    [    6.513879] addr ffff8881024d77c2 is located in stack of task kworker/2:1/118 at offset 34 in frame:
    [    6.513887]  elantech_change_report_id+0x0/0x256 [psmouse]
    
    [    6.513941] this frame has 1 object:
    [    6.513947]  [32, 34) 'param'
    
    [    6.513956] Memory state around the buggy address:
    [    6.513962]  ffff8881024d7680: f2 f2 f2 f2 f2 00 00 f3 f3 00 00 00 00 00 00 00
    [    6.513969]  ffff8881024d7700: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    [    6.513976] >ffff8881024d7780: 00 00 00 00 f1 f1 f1 f1 02 f3 f3 f3 00 00 00 00
    [    6.513982]                                            ^
    [    6.513988]  ffff8881024d7800: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    [    6.513995]  ffff8881024d7880: 00 f1 f1 f1 f1 03 f2 03 f2 03 f3 f3 f3 00 00 00
    [    6.514000] ==================================================================
    
    Define param[] in elantech_change_report_id() as an array of 3 bytes to
    prevent the out-of-bounds access in the stack.
    
    Fixes: e4c9062717fe ("Input: elantech - fix protocol errors for some trackpoints in SMBus mode")
    BugLink: https://bugs.launchpad.net/bugs/1945590
    Signed-off-by: Andrea Righi <andrea.righi@canonical.com>
    Reviewed-by: Wolfram Sang <wsa@kernel.org>
    Link: https://lore.kernel.org/r/20211116095559.24395-1-andrea.righi@canonical.com
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

commit 81121524f1c798c9481bd7900450b72ee7ac2eef
Author: Boqun Feng <boqun.feng@gmail.com>
Date:   Thu Sep 9 12:59:19 2021 +0200

    locking/rwbase: Take care of ordering guarantee for fastpath reader
    
    Readers of rwbase can lock and unlock without taking any inner lock, if
    that happens, we need the ordering provided by atomic operations to
    satisfy the ordering semantics of lock/unlock. Without that, considering
    the follow case:
    
            { X = 0 initially }
    
            CPU 0                   CPU 1
            =====                   =====
                                    rt_write_lock();
                                    X = 1
                                    rt_write_unlock():
                                      atomic_add(READER_BIAS - WRITER_BIAS, ->readers);
                                      // ->readers is READER_BIAS.
            rt_read_lock():
              if ((r = atomic_read(->readers)) < 0) // True
                atomic_try_cmpxchg(->readers, r, r + 1); // succeed.
              <acquire the read lock via fast path>
    
            r1 = X; // r1 may be 0, because nothing prevent the reordering
                    // of "X=1" and atomic_add() on CPU 1.
    
    Therefore audit every usage of atomic operations that may happen in a
    fast path, and add necessary barriers.
    
    Signed-off-by: Boqun Feng <boqun.feng@gmail.com>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lkml.kernel.org/r/20210909110203.953991276@infradead.org

commit 95ac706744de78a93a7ec98d603c35fb21de8400
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Tue Aug 3 16:16:12 2021 +0200

    ACPI: processor: Replace deprecated CPU-hotplug functions
    
    The functions cpu_hotplug_begin, cpu_hotplug_done, get_online_cpus() and
    put_online_cpus() have been deprecated during the CPU hotplug rework. They map
    directly to cpus_write_lock(), cpus_write_unlock, cpus_read_lock() and
    cpus_read_unlock().
    
    Replace deprecated CPU-hotplug functions with the official version.
    The behavior remains unchanged.
    
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 6126891c6d4f6f4ef50323d2020635ee255a796e
Author: Vasily Averin <vvs@virtuozzo.com>
Date:   Mon Jul 19 13:44:31 2021 +0300

    memcg: enable accounting for IP address and routing-related objects
    
    An netadmin inside container can use 'ip a a' and 'ip r a'
    to assign a large number of ipv4/ipv6 addresses and routing entries
    and force kernel to allocate megabytes of unaccounted memory
    for long-lived per-netdevice related kernel objects:
    'struct in_ifaddr', 'struct inet6_ifaddr', 'struct fib6_node',
    'struct rt6_info', 'struct fib_rules' and ip_fib caches.
    
    These objects can be manually removed, though usually they lives
    in memory till destroy of its net namespace.
    
    It makes sense to account for them to restrict the host's memory
    consumption from inside the memcg-limited container.
    
    One of such objects is the 'struct fib6_node' mostly allocated in
    net/ipv6/route.c::__ip6_ins_rt() inside the lock_bh()/unlock_bh() section:
    
     write_lock_bh(&table->tb6_lock);
     err = fib6_add(&table->tb6_root, rt, info, mxc);
     write_unlock_bh(&table->tb6_lock);
    
    In this case it is not enough to simply add SLAB_ACCOUNT to corresponding
    kmem cache. The proper memory cgroup still cannot be found due to the
    incorrect 'in_interrupt()' check used in memcg_kmem_bypass().
    
    Obsoleted in_interrupt() does not describe real execution context properly.
    >From include/linux/preempt.h:
    
     The following macros are deprecated and should not be used in new code:
     in_interrupt() - We're in NMI,IRQ,SoftIRQ context or have BH disabled
    
    To verify the current execution context new macro should be used instead:
     in_task()      - We're in task context
    
    Signed-off-by: Vasily Averin <vvs@virtuozzo.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 0a42b3feff92d80b561e0d78c1d327d61c91a168
Author: Li Jun <jun.li@nxp.com>
Date:   Fri May 14 18:59:44 2021 +0800

    usb: chipidea: udc: assign interrupt number to USB gadget structure
    
    [ Upstream commit 9e3927f6373da54cb17e17f4bd700907e1123d2f ]
    
    Chipidea also need sync interrupt before unbind the udc while
    gadget remove driver, otherwise setup irq handling may happen
    while unbind, see below dump generated from android function
    switch stress test:
    
    [ 4703.503056] android_work: sent uevent USB_STATE=CONNECTED
    [ 4703.514642] android_work: sent uevent USB_STATE=DISCONNECTED
    [ 4703.651339] android_work: sent uevent USB_STATE=CONNECTED
    [ 4703.661806] init: Control message: Processed ctl.stop for 'adbd' from pid: 561 (system_server)
    [ 4703.673469] init: processing action (init.svc.adbd=stopped) from (/system/etc/init/hw/init.usb.configfs.rc:14)
    [ 4703.676451] Unable to handle kernel read from unreadable memory at virtual address 0000000000000090
    [ 4703.676454] Mem abort info:
    [ 4703.676458]   ESR = 0x96000004
    [ 4703.676461]   EC = 0x25: DABT (current EL), IL = 32 bits
    [ 4703.676464]   SET = 0, FnV = 0
    [ 4703.676466]   EA = 0, S1PTW = 0
    [ 4703.676468] Data abort info:
    [ 4703.676471]   ISV = 0, ISS = 0x00000004
    [ 4703.676473]   CM = 0, WnR = 0
    [ 4703.676478] user pgtable: 4k pages, 48-bit VAs, pgdp=000000004a867000
    [ 4703.676481] [0000000000000090] pgd=0000000000000000, p4d=0000000000000000
    [ 4703.676503] Internal error: Oops: 96000004 [#1] PREEMPT SMP
    [ 4703.758297] Modules linked in: synaptics_dsx_i2c moal(O) mlan(O)
    [ 4703.764327] CPU: 0 PID: 235 Comm: lmkd Tainted: G        W  O      5.10.9-00001-g3f5fd8487c38-dirty #63
    [ 4703.773720] Hardware name: NXP i.MX8MNano EVK board (DT)
    [ 4703.779033] pstate: 60400085 (nZCv daIf +PAN -UAO -TCO BTYPE=--)
    [ 4703.785046] pc : _raw_write_unlock_bh+0xc0/0x2c8
    [ 4703.789667] lr : android_setup+0x4c/0x168
    [ 4703.793676] sp : ffff80001256bd80
    [ 4703.796989] x29: ffff80001256bd80 x28: 00000000000000a8
    [ 4703.802304] x27: ffff800012470000 x26: ffff80006d923000
    [ 4703.807616] x25: ffff800012471000 x24: ffff00000b091140
    [ 4703.812929] x23: ffff0000077dbd38 x22: ffff0000077da490
    [ 4703.818242] x21: ffff80001256be30 x20: 0000000000000000
    [ 4703.823554] x19: 0000000000000080 x18: ffff800012561048
    [ 4703.828867] x17: 0000000000000000 x16: 0000000000000039
    [ 4703.834180] x15: ffff8000106ad258 x14: ffff80001194c277
    [ 4703.839493] x13: 0000000000003934 x12: 0000000000000000
    [ 4703.844805] x11: 0000000000000000 x10: 0000000000000001
    [ 4703.850117] x9 : 0000000000000000 x8 : 0000000000000090
    [ 4703.855429] x7 : 6f72646e61203a70 x6 : ffff8000124f2450
    [ 4703.860742] x5 : ffffffffffffffff x4 : 0000000000000009
    [ 4703.866054] x3 : ffff8000108a290c x2 : ffff00007fb3a9c8
    [ 4703.871367] x1 : 0000000000000000 x0 : 0000000000000090
    [ 4703.876681] Call trace:
    [ 4703.879129]  _raw_write_unlock_bh+0xc0/0x2c8
    [ 4703.883397]  android_setup+0x4c/0x168
    [ 4703.887059]  udc_irq+0x824/0xa9c
    [ 4703.890287]  ci_irq+0x124/0x148
    [ 4703.893429]  __handle_irq_event_percpu+0x84/0x268
    [ 4703.898131]  handle_irq_event+0x64/0x14c
    [ 4703.902054]  handle_fasteoi_irq+0x110/0x210
    [ 4703.906236]  __handle_domain_irq+0x8c/0xd4
    [ 4703.910332]  gic_handle_irq+0x6c/0x124
    [ 4703.914081]  el1_irq+0xdc/0x1c0
    [ 4703.917221]  _raw_spin_unlock_irq+0x20/0x54
    [ 4703.921405]  finish_task_switch+0x84/0x224
    [ 4703.925502]  __schedule+0x4a4/0x734
    [ 4703.928990]  schedule+0xa0/0xe8
    [ 4703.932132]  do_notify_resume+0x150/0x184
    [ 4703.936140]  work_pending+0xc/0x40c
    [ 4703.939633] Code: d5384613 521b0a69 d5184609 f9800111 (885ffd01)
    [ 4703.945732] ---[ end trace ba5c1875ae49d53c ]---
    [ 4703.950350] Kernel panic - not syncing: Oops: Fatal exception in interrupt
    [ 4703.957223] SMP: stopping secondary CPUs
    [ 4703.961151] Kernel Offset: disabled
    [ 4703.964638] CPU features: 0x0240002,2000200c
    [ 4703.968905] Memory Limit: none
    [ 4703.971963] Rebooting in 5 seconds..
    
    Tested-by: faqiang.zhu <faqiang.zhu@nxp.com>
    Signed-off-by: Li Jun <jun.li@nxp.com>
    Link: https://lore.kernel.org/r/1620989984-7653-1-git-send-email-jun.li@nxp.com
    Signed-off-by: Peter Chen <peter.chen@kernel.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 2e2145ccfbcb0dd38d8423681d22b595ca735846
Author: Li Jun <jun.li@nxp.com>
Date:   Fri May 14 18:59:44 2021 +0800

    usb: chipidea: udc: assign interrupt number to USB gadget structure
    
    [ Upstream commit 9e3927f6373da54cb17e17f4bd700907e1123d2f ]
    
    Chipidea also need sync interrupt before unbind the udc while
    gadget remove driver, otherwise setup irq handling may happen
    while unbind, see below dump generated from android function
    switch stress test:
    
    [ 4703.503056] android_work: sent uevent USB_STATE=CONNECTED
    [ 4703.514642] android_work: sent uevent USB_STATE=DISCONNECTED
    [ 4703.651339] android_work: sent uevent USB_STATE=CONNECTED
    [ 4703.661806] init: Control message: Processed ctl.stop for 'adbd' from pid: 561 (system_server)
    [ 4703.673469] init: processing action (init.svc.adbd=stopped) from (/system/etc/init/hw/init.usb.configfs.rc:14)
    [ 4703.676451] Unable to handle kernel read from unreadable memory at virtual address 0000000000000090
    [ 4703.676454] Mem abort info:
    [ 4703.676458]   ESR = 0x96000004
    [ 4703.676461]   EC = 0x25: DABT (current EL), IL = 32 bits
    [ 4703.676464]   SET = 0, FnV = 0
    [ 4703.676466]   EA = 0, S1PTW = 0
    [ 4703.676468] Data abort info:
    [ 4703.676471]   ISV = 0, ISS = 0x00000004
    [ 4703.676473]   CM = 0, WnR = 0
    [ 4703.676478] user pgtable: 4k pages, 48-bit VAs, pgdp=000000004a867000
    [ 4703.676481] [0000000000000090] pgd=0000000000000000, p4d=0000000000000000
    [ 4703.676503] Internal error: Oops: 96000004 [#1] PREEMPT SMP
    [ 4703.758297] Modules linked in: synaptics_dsx_i2c moal(O) mlan(O)
    [ 4703.764327] CPU: 0 PID: 235 Comm: lmkd Tainted: G        W  O      5.10.9-00001-g3f5fd8487c38-dirty #63
    [ 4703.773720] Hardware name: NXP i.MX8MNano EVK board (DT)
    [ 4703.779033] pstate: 60400085 (nZCv daIf +PAN -UAO -TCO BTYPE=--)
    [ 4703.785046] pc : _raw_write_unlock_bh+0xc0/0x2c8
    [ 4703.789667] lr : android_setup+0x4c/0x168
    [ 4703.793676] sp : ffff80001256bd80
    [ 4703.796989] x29: ffff80001256bd80 x28: 00000000000000a8
    [ 4703.802304] x27: ffff800012470000 x26: ffff80006d923000
    [ 4703.807616] x25: ffff800012471000 x24: ffff00000b091140
    [ 4703.812929] x23: ffff0000077dbd38 x22: ffff0000077da490
    [ 4703.818242] x21: ffff80001256be30 x20: 0000000000000000
    [ 4703.823554] x19: 0000000000000080 x18: ffff800012561048
    [ 4703.828867] x17: 0000000000000000 x16: 0000000000000039
    [ 4703.834180] x15: ffff8000106ad258 x14: ffff80001194c277
    [ 4703.839493] x13: 0000000000003934 x12: 0000000000000000
    [ 4703.844805] x11: 0000000000000000 x10: 0000000000000001
    [ 4703.850117] x9 : 0000000000000000 x8 : 0000000000000090
    [ 4703.855429] x7 : 6f72646e61203a70 x6 : ffff8000124f2450
    [ 4703.860742] x5 : ffffffffffffffff x4 : 0000000000000009
    [ 4703.866054] x3 : ffff8000108a290c x2 : ffff00007fb3a9c8
    [ 4703.871367] x1 : 0000000000000000 x0 : 0000000000000090
    [ 4703.876681] Call trace:
    [ 4703.879129]  _raw_write_unlock_bh+0xc0/0x2c8
    [ 4703.883397]  android_setup+0x4c/0x168
    [ 4703.887059]  udc_irq+0x824/0xa9c
    [ 4703.890287]  ci_irq+0x124/0x148
    [ 4703.893429]  __handle_irq_event_percpu+0x84/0x268
    [ 4703.898131]  handle_irq_event+0x64/0x14c
    [ 4703.902054]  handle_fasteoi_irq+0x110/0x210
    [ 4703.906236]  __handle_domain_irq+0x8c/0xd4
    [ 4703.910332]  gic_handle_irq+0x6c/0x124
    [ 4703.914081]  el1_irq+0xdc/0x1c0
    [ 4703.917221]  _raw_spin_unlock_irq+0x20/0x54
    [ 4703.921405]  finish_task_switch+0x84/0x224
    [ 4703.925502]  __schedule+0x4a4/0x734
    [ 4703.928990]  schedule+0xa0/0xe8
    [ 4703.932132]  do_notify_resume+0x150/0x184
    [ 4703.936140]  work_pending+0xc/0x40c
    [ 4703.939633] Code: d5384613 521b0a69 d5184609 f9800111 (885ffd01)
    [ 4703.945732] ---[ end trace ba5c1875ae49d53c ]---
    [ 4703.950350] Kernel panic - not syncing: Oops: Fatal exception in interrupt
    [ 4703.957223] SMP: stopping secondary CPUs
    [ 4703.961151] Kernel Offset: disabled
    [ 4703.964638] CPU features: 0x0240002,2000200c
    [ 4703.968905] Memory Limit: none
    [ 4703.971963] Rebooting in 5 seconds..
    
    Tested-by: faqiang.zhu <faqiang.zhu@nxp.com>
    Signed-off-by: Li Jun <jun.li@nxp.com>
    Link: https://lore.kernel.org/r/1620989984-7653-1-git-send-email-jun.li@nxp.com
    Signed-off-by: Peter Chen <peter.chen@kernel.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 9e3927f6373da54cb17e17f4bd700907e1123d2f
Author: Li Jun <jun.li@nxp.com>
Date:   Fri May 14 18:59:44 2021 +0800

    usb: chipidea: udc: assign interrupt number to USB gadget structure
    
    Chipidea also need sync interrupt before unbind the udc while
    gadget remove driver, otherwise setup irq handling may happen
    while unbind, see below dump generated from android function
    switch stress test:
    
    [ 4703.503056] android_work: sent uevent USB_STATE=CONNECTED
    [ 4703.514642] android_work: sent uevent USB_STATE=DISCONNECTED
    [ 4703.651339] android_work: sent uevent USB_STATE=CONNECTED
    [ 4703.661806] init: Control message: Processed ctl.stop for 'adbd' from pid: 561 (system_server)
    [ 4703.673469] init: processing action (init.svc.adbd=stopped) from (/system/etc/init/hw/init.usb.configfs.rc:14)
    [ 4703.676451] Unable to handle kernel read from unreadable memory at virtual address 0000000000000090
    [ 4703.676454] Mem abort info:
    [ 4703.676458]   ESR = 0x96000004
    [ 4703.676461]   EC = 0x25: DABT (current EL), IL = 32 bits
    [ 4703.676464]   SET = 0, FnV = 0
    [ 4703.676466]   EA = 0, S1PTW = 0
    [ 4703.676468] Data abort info:
    [ 4703.676471]   ISV = 0, ISS = 0x00000004
    [ 4703.676473]   CM = 0, WnR = 0
    [ 4703.676478] user pgtable: 4k pages, 48-bit VAs, pgdp=000000004a867000
    [ 4703.676481] [0000000000000090] pgd=0000000000000000, p4d=0000000000000000
    [ 4703.676503] Internal error: Oops: 96000004 [#1] PREEMPT SMP
    [ 4703.758297] Modules linked in: synaptics_dsx_i2c moal(O) mlan(O)
    [ 4703.764327] CPU: 0 PID: 235 Comm: lmkd Tainted: G        W  O      5.10.9-00001-g3f5fd8487c38-dirty #63
    [ 4703.773720] Hardware name: NXP i.MX8MNano EVK board (DT)
    [ 4703.779033] pstate: 60400085 (nZCv daIf +PAN -UAO -TCO BTYPE=--)
    [ 4703.785046] pc : _raw_write_unlock_bh+0xc0/0x2c8
    [ 4703.789667] lr : android_setup+0x4c/0x168
    [ 4703.793676] sp : ffff80001256bd80
    [ 4703.796989] x29: ffff80001256bd80 x28: 00000000000000a8
    [ 4703.802304] x27: ffff800012470000 x26: ffff80006d923000
    [ 4703.807616] x25: ffff800012471000 x24: ffff00000b091140
    [ 4703.812929] x23: ffff0000077dbd38 x22: ffff0000077da490
    [ 4703.818242] x21: ffff80001256be30 x20: 0000000000000000
    [ 4703.823554] x19: 0000000000000080 x18: ffff800012561048
    [ 4703.828867] x17: 0000000000000000 x16: 0000000000000039
    [ 4703.834180] x15: ffff8000106ad258 x14: ffff80001194c277
    [ 4703.839493] x13: 0000000000003934 x12: 0000000000000000
    [ 4703.844805] x11: 0000000000000000 x10: 0000000000000001
    [ 4703.850117] x9 : 0000000000000000 x8 : 0000000000000090
    [ 4703.855429] x7 : 6f72646e61203a70 x6 : ffff8000124f2450
    [ 4703.860742] x5 : ffffffffffffffff x4 : 0000000000000009
    [ 4703.866054] x3 : ffff8000108a290c x2 : ffff00007fb3a9c8
    [ 4703.871367] x1 : 0000000000000000 x0 : 0000000000000090
    [ 4703.876681] Call trace:
    [ 4703.879129]  _raw_write_unlock_bh+0xc0/0x2c8
    [ 4703.883397]  android_setup+0x4c/0x168
    [ 4703.887059]  udc_irq+0x824/0xa9c
    [ 4703.890287]  ci_irq+0x124/0x148
    [ 4703.893429]  __handle_irq_event_percpu+0x84/0x268
    [ 4703.898131]  handle_irq_event+0x64/0x14c
    [ 4703.902054]  handle_fasteoi_irq+0x110/0x210
    [ 4703.906236]  __handle_domain_irq+0x8c/0xd4
    [ 4703.910332]  gic_handle_irq+0x6c/0x124
    [ 4703.914081]  el1_irq+0xdc/0x1c0
    [ 4703.917221]  _raw_spin_unlock_irq+0x20/0x54
    [ 4703.921405]  finish_task_switch+0x84/0x224
    [ 4703.925502]  __schedule+0x4a4/0x734
    [ 4703.928990]  schedule+0xa0/0xe8
    [ 4703.932132]  do_notify_resume+0x150/0x184
    [ 4703.936140]  work_pending+0xc/0x40c
    [ 4703.939633] Code: d5384613 521b0a69 d5184609 f9800111 (885ffd01)
    [ 4703.945732] ---[ end trace ba5c1875ae49d53c ]---
    [ 4703.950350] Kernel panic - not syncing: Oops: Fatal exception in interrupt
    [ 4703.957223] SMP: stopping secondary CPUs
    [ 4703.961151] Kernel Offset: disabled
    [ 4703.964638] CPU features: 0x0240002,2000200c
    [ 4703.968905] Memory Limit: none
    [ 4703.971963] Rebooting in 5 seconds..
    
    Tested-by: faqiang.zhu <faqiang.zhu@nxp.com>
    Signed-off-by: Li Jun <jun.li@nxp.com>
    Link: https://lore.kernel.org/r/1620989984-7653-1-git-send-email-jun.li@nxp.com
    Signed-off-by: Peter Chen <peter.chen@kernel.org>

commit 97bc84bbd4de3c060b68aea4d546c7f21c4d6814
Author: Hoang Huu Le <hoang.h.le@dektech.com.au>
Date:   Thu Mar 11 10:33:23 2021 +0700

    tipc: clean up warnings detected by sparse
    
    This patch fixes the following warning from sparse:
    
    net/tipc/monitor.c:263:35: warning: incorrect type in assignment (different base types)
    net/tipc/monitor.c:263:35:    expected unsigned int
    net/tipc/monitor.c:263:35:    got restricted __be32 [usertype]
    [...]
    net/tipc/node.c:374:13: warning: context imbalance in 'tipc_node_read_lock' - wrong count at exit
    net/tipc/node.c:379:13: warning: context imbalance in 'tipc_node_read_unlock' - unexpected unlock
    net/tipc/node.c:384:13: warning: context imbalance in 'tipc_node_write_lock' - wrong count at exit
    net/tipc/node.c:389:13: warning: context imbalance in 'tipc_node_write_unlock_fast' - unexpected unlock
    net/tipc/node.c:404:17: warning: context imbalance in 'tipc_node_write_unlock' - unexpected unlock
    [...]
    net/tipc/crypto.c:1201:9: warning: incorrect type in initializer (different address spaces)
    net/tipc/crypto.c:1201:9:    expected struct tipc_aead [noderef] __rcu *__tmp
    net/tipc/crypto.c:1201:9:    got struct tipc_aead *
    [...]
    
    Acked-by: Jon Maloy <jmaloy@redhat.com>
    Signed-off-by: Hoang Huu Le <hoang.h.le@dektech.com.au>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 2000bb546525890584a3cf0ce4787270250b582c
Author: John Fastabend <john.fastabend@gmail.com>
Date:   Thu Jun 25 16:12:59 2020 -0700

    bpf, sockmap: RCU splat with redirect and strparser error or TLS
    
    [ Upstream commit 93dd5f185916b05e931cffae636596f21f98546e ]
    
    There are two paths to generate the below RCU splat the first and
    most obvious is the result of the BPF verdict program issuing a
    redirect on a TLS socket (This is the splat shown below). Unlike
    the non-TLS case the caller of the *strp_read() hooks does not
    wrap the call in a rcu_read_lock/unlock. Then if the BPF program
    issues a redirect action we hit the RCU splat.
    
    However, in the non-TLS socket case the splat appears to be
    relatively rare, because the skmsg caller into the strp_data_ready()
    is wrapped in a rcu_read_lock/unlock. Shown here,
    
     static void sk_psock_strp_data_ready(struct sock *sk)
     {
            struct sk_psock *psock;
    
            rcu_read_lock();
            psock = sk_psock(sk);
            if (likely(psock)) {
                    if (tls_sw_has_ctx_rx(sk)) {
                            psock->parser.saved_data_ready(sk);
                    } else {
                            write_lock_bh(&sk->sk_callback_lock);
                            strp_data_ready(&psock->parser.strp);
                            write_unlock_bh(&sk->sk_callback_lock);
                    }
            }
            rcu_read_unlock();
     }
    
    If the above was the only way to run the verdict program we
    would be safe. But, there is a case where the strparser may throw an
    ENOMEM error while parsing the skb. This is a result of a failed
    skb_clone, or alloc_skb_for_msg while building a new merged skb when
    the msg length needed spans multiple skbs. This will in turn put the
    skb on the strp_wrk workqueue in the strparser code. The skb will
    later be dequeued and verdict programs run, but now from a
    different context without the rcu_read_lock()/unlock() critical
    section in sk_psock_strp_data_ready() shown above. In practice
    I have not seen this yet, because as far as I know most users of the
    verdict programs are also only working on single skbs. In this case no
    merge happens which could trigger the above ENOMEM errors. In addition
    the system would need to be under memory pressure. For example, we
    can't hit the above case in selftests because we missed having tests
    to merge skbs. (Added in later patch)
    
    To fix the below splat extend the rcu_read_lock/unnlock block to
    include the call to sk_psock_tls_verdict_apply(). This will fix both
    TLS redirect case and non-TLS redirect+error case. Also remove
    psock from the sk_psock_tls_verdict_apply() function signature its
    not used there.
    
    [ 1095.937597] WARNING: suspicious RCU usage
    [ 1095.940964] 5.7.0-rc7-02911-g463bac5f1ca79 #1 Tainted: G        W
    [ 1095.944363] -----------------------------
    [ 1095.947384] include/linux/skmsg.h:284 suspicious rcu_dereference_check() usage!
    [ 1095.950866]
    [ 1095.950866] other info that might help us debug this:
    [ 1095.950866]
    [ 1095.957146]
    [ 1095.957146] rcu_scheduler_active = 2, debug_locks = 1
    [ 1095.961482] 1 lock held by test_sockmap/15970:
    [ 1095.964501]  #0: ffff9ea6b25de660 (sk_lock-AF_INET){+.+.}-{0:0}, at: tls_sw_recvmsg+0x13a/0x840 [tls]
    [ 1095.968568]
    [ 1095.968568] stack backtrace:
    [ 1095.975001] CPU: 1 PID: 15970 Comm: test_sockmap Tainted: G        W         5.7.0-rc7-02911-g463bac5f1ca79 #1
    [ 1095.977883] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.12.0-1 04/01/2014
    [ 1095.980519] Call Trace:
    [ 1095.982191]  dump_stack+0x8f/0xd0
    [ 1095.984040]  sk_psock_skb_redirect+0xa6/0xf0
    [ 1095.986073]  sk_psock_tls_strp_read+0x1d8/0x250
    [ 1095.988095]  tls_sw_recvmsg+0x714/0x840 [tls]
    
    v2: Improve commit message to identify non-TLS redirect plus error case
        condition as well as more common TLS case. In the process I decided
        doing the rcu_read_unlock followed by the lock/unlock inside branches
        was unnecessarily complex. We can just extend the current rcu block
        and get the same effeective without the shuffling and branching.
        Thanks Martin!
    
    Fixes: e91de6afa81c1 ("bpf: Fix running sk_skb program types with ktls")
    Reported-by: Jakub Sitnicki <jakub@cloudflare.com>
    Reported-by: kernel test robot <rong.a.chen@intel.com>
    Signed-off-by: John Fastabend <john.fastabend@gmail.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>
    Acked-by: Martin KaFai Lau <kafai@fb.com>
    Acked-by: Jakub Sitnicki <jakub@cloudflare.com>
    Link: https://lore.kernel.org/bpf/159312677907.18340.11064813152758406626.stgit@john-XPS-13-9370
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 7f1c6b6194807a926deac5363d532c662489a09f
Author: John Fastabend <john.fastabend@gmail.com>
Date:   Thu Jun 25 16:12:59 2020 -0700

    bpf, sockmap: RCU splat with redirect and strparser error or TLS
    
    [ Upstream commit 93dd5f185916b05e931cffae636596f21f98546e ]
    
    There are two paths to generate the below RCU splat the first and
    most obvious is the result of the BPF verdict program issuing a
    redirect on a TLS socket (This is the splat shown below). Unlike
    the non-TLS case the caller of the *strp_read() hooks does not
    wrap the call in a rcu_read_lock/unlock. Then if the BPF program
    issues a redirect action we hit the RCU splat.
    
    However, in the non-TLS socket case the splat appears to be
    relatively rare, because the skmsg caller into the strp_data_ready()
    is wrapped in a rcu_read_lock/unlock. Shown here,
    
     static void sk_psock_strp_data_ready(struct sock *sk)
     {
            struct sk_psock *psock;
    
            rcu_read_lock();
            psock = sk_psock(sk);
            if (likely(psock)) {
                    if (tls_sw_has_ctx_rx(sk)) {
                            psock->parser.saved_data_ready(sk);
                    } else {
                            write_lock_bh(&sk->sk_callback_lock);
                            strp_data_ready(&psock->parser.strp);
                            write_unlock_bh(&sk->sk_callback_lock);
                    }
            }
            rcu_read_unlock();
     }
    
    If the above was the only way to run the verdict program we
    would be safe. But, there is a case where the strparser may throw an
    ENOMEM error while parsing the skb. This is a result of a failed
    skb_clone, or alloc_skb_for_msg while building a new merged skb when
    the msg length needed spans multiple skbs. This will in turn put the
    skb on the strp_wrk workqueue in the strparser code. The skb will
    later be dequeued and verdict programs run, but now from a
    different context without the rcu_read_lock()/unlock() critical
    section in sk_psock_strp_data_ready() shown above. In practice
    I have not seen this yet, because as far as I know most users of the
    verdict programs are also only working on single skbs. In this case no
    merge happens which could trigger the above ENOMEM errors. In addition
    the system would need to be under memory pressure. For example, we
    can't hit the above case in selftests because we missed having tests
    to merge skbs. (Added in later patch)
    
    To fix the below splat extend the rcu_read_lock/unnlock block to
    include the call to sk_psock_tls_verdict_apply(). This will fix both
    TLS redirect case and non-TLS redirect+error case. Also remove
    psock from the sk_psock_tls_verdict_apply() function signature its
    not used there.
    
    [ 1095.937597] WARNING: suspicious RCU usage
    [ 1095.940964] 5.7.0-rc7-02911-g463bac5f1ca79 #1 Tainted: G        W
    [ 1095.944363] -----------------------------
    [ 1095.947384] include/linux/skmsg.h:284 suspicious rcu_dereference_check() usage!
    [ 1095.950866]
    [ 1095.950866] other info that might help us debug this:
    [ 1095.950866]
    [ 1095.957146]
    [ 1095.957146] rcu_scheduler_active = 2, debug_locks = 1
    [ 1095.961482] 1 lock held by test_sockmap/15970:
    [ 1095.964501]  #0: ffff9ea6b25de660 (sk_lock-AF_INET){+.+.}-{0:0}, at: tls_sw_recvmsg+0x13a/0x840 [tls]
    [ 1095.968568]
    [ 1095.968568] stack backtrace:
    [ 1095.975001] CPU: 1 PID: 15970 Comm: test_sockmap Tainted: G        W         5.7.0-rc7-02911-g463bac5f1ca79 #1
    [ 1095.977883] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.12.0-1 04/01/2014
    [ 1095.980519] Call Trace:
    [ 1095.982191]  dump_stack+0x8f/0xd0
    [ 1095.984040]  sk_psock_skb_redirect+0xa6/0xf0
    [ 1095.986073]  sk_psock_tls_strp_read+0x1d8/0x250
    [ 1095.988095]  tls_sw_recvmsg+0x714/0x840 [tls]
    
    v2: Improve commit message to identify non-TLS redirect plus error case
        condition as well as more common TLS case. In the process I decided
        doing the rcu_read_unlock followed by the lock/unlock inside branches
        was unnecessarily complex. We can just extend the current rcu block
        and get the same effeective without the shuffling and branching.
        Thanks Martin!
    
    Fixes: e91de6afa81c1 ("bpf: Fix running sk_skb program types with ktls")
    Reported-by: Jakub Sitnicki <jakub@cloudflare.com>
    Reported-by: kernel test robot <rong.a.chen@intel.com>
    Signed-off-by: John Fastabend <john.fastabend@gmail.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>
    Acked-by: Martin KaFai Lau <kafai@fb.com>
    Acked-by: Jakub Sitnicki <jakub@cloudflare.com>
    Link: https://lore.kernel.org/bpf/159312677907.18340.11064813152758406626.stgit@john-XPS-13-9370
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 93dd5f185916b05e931cffae636596f21f98546e
Author: John Fastabend <john.fastabend@gmail.com>
Date:   Thu Jun 25 16:12:59 2020 -0700

    bpf, sockmap: RCU splat with redirect and strparser error or TLS
    
    There are two paths to generate the below RCU splat the first and
    most obvious is the result of the BPF verdict program issuing a
    redirect on a TLS socket (This is the splat shown below). Unlike
    the non-TLS case the caller of the *strp_read() hooks does not
    wrap the call in a rcu_read_lock/unlock. Then if the BPF program
    issues a redirect action we hit the RCU splat.
    
    However, in the non-TLS socket case the splat appears to be
    relatively rare, because the skmsg caller into the strp_data_ready()
    is wrapped in a rcu_read_lock/unlock. Shown here,
    
     static void sk_psock_strp_data_ready(struct sock *sk)
     {
            struct sk_psock *psock;
    
            rcu_read_lock();
            psock = sk_psock(sk);
            if (likely(psock)) {
                    if (tls_sw_has_ctx_rx(sk)) {
                            psock->parser.saved_data_ready(sk);
                    } else {
                            write_lock_bh(&sk->sk_callback_lock);
                            strp_data_ready(&psock->parser.strp);
                            write_unlock_bh(&sk->sk_callback_lock);
                    }
            }
            rcu_read_unlock();
     }
    
    If the above was the only way to run the verdict program we
    would be safe. But, there is a case where the strparser may throw an
    ENOMEM error while parsing the skb. This is a result of a failed
    skb_clone, or alloc_skb_for_msg while building a new merged skb when
    the msg length needed spans multiple skbs. This will in turn put the
    skb on the strp_wrk workqueue in the strparser code. The skb will
    later be dequeued and verdict programs run, but now from a
    different context without the rcu_read_lock()/unlock() critical
    section in sk_psock_strp_data_ready() shown above. In practice
    I have not seen this yet, because as far as I know most users of the
    verdict programs are also only working on single skbs. In this case no
    merge happens which could trigger the above ENOMEM errors. In addition
    the system would need to be under memory pressure. For example, we
    can't hit the above case in selftests because we missed having tests
    to merge skbs. (Added in later patch)
    
    To fix the below splat extend the rcu_read_lock/unnlock block to
    include the call to sk_psock_tls_verdict_apply(). This will fix both
    TLS redirect case and non-TLS redirect+error case. Also remove
    psock from the sk_psock_tls_verdict_apply() function signature its
    not used there.
    
    [ 1095.937597] WARNING: suspicious RCU usage
    [ 1095.940964] 5.7.0-rc7-02911-g463bac5f1ca79 #1 Tainted: G        W
    [ 1095.944363] -----------------------------
    [ 1095.947384] include/linux/skmsg.h:284 suspicious rcu_dereference_check() usage!
    [ 1095.950866]
    [ 1095.950866] other info that might help us debug this:
    [ 1095.950866]
    [ 1095.957146]
    [ 1095.957146] rcu_scheduler_active = 2, debug_locks = 1
    [ 1095.961482] 1 lock held by test_sockmap/15970:
    [ 1095.964501]  #0: ffff9ea6b25de660 (sk_lock-AF_INET){+.+.}-{0:0}, at: tls_sw_recvmsg+0x13a/0x840 [tls]
    [ 1095.968568]
    [ 1095.968568] stack backtrace:
    [ 1095.975001] CPU: 1 PID: 15970 Comm: test_sockmap Tainted: G        W         5.7.0-rc7-02911-g463bac5f1ca79 #1
    [ 1095.977883] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.12.0-1 04/01/2014
    [ 1095.980519] Call Trace:
    [ 1095.982191]  dump_stack+0x8f/0xd0
    [ 1095.984040]  sk_psock_skb_redirect+0xa6/0xf0
    [ 1095.986073]  sk_psock_tls_strp_read+0x1d8/0x250
    [ 1095.988095]  tls_sw_recvmsg+0x714/0x840 [tls]
    
    v2: Improve commit message to identify non-TLS redirect plus error case
        condition as well as more common TLS case. In the process I decided
        doing the rcu_read_unlock followed by the lock/unlock inside branches
        was unnecessarily complex. We can just extend the current rcu block
        and get the same effeective without the shuffling and branching.
        Thanks Martin!
    
    Fixes: e91de6afa81c1 ("bpf: Fix running sk_skb program types with ktls")
    Reported-by: Jakub Sitnicki <jakub@cloudflare.com>
    Reported-by: kernel test robot <rong.a.chen@intel.com>
    Signed-off-by: John Fastabend <john.fastabend@gmail.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>
    Acked-by: Martin KaFai Lau <kafai@fb.com>
    Acked-by: Jakub Sitnicki <jakub@cloudflare.com>
    Link: https://lore.kernel.org/bpf/159312677907.18340.11064813152758406626.stgit@john-XPS-13-9370

commit d8ed45c5dcd455fc5848d47f86883a1b872ac0d0
Author: Michel Lespinasse <walken@google.com>
Date:   Mon Jun 8 21:33:25 2020 -0700

    mmap locking API: use coccinelle to convert mmap_sem rwsem call sites
    
    This change converts the existing mmap_sem rwsem calls to use the new mmap
    locking API instead.
    
    The change is generated using coccinelle with the following rule:
    
    // spatch --sp-file mmap_lock_api.cocci --in-place --include-headers --dir .
    
    @@
    expression mm;
    @@
    (
    -init_rwsem
    +mmap_init_lock
    |
    -down_write
    +mmap_write_lock
    |
    -down_write_killable
    +mmap_write_lock_killable
    |
    -down_write_trylock
    +mmap_write_trylock
    |
    -up_write
    +mmap_write_unlock
    |
    -downgrade_write
    +mmap_write_downgrade
    |
    -down_read
    +mmap_read_lock
    |
    -down_read_killable
    +mmap_read_lock_killable
    |
    -down_read_trylock
    +mmap_read_trylock
    |
    -up_read
    +mmap_read_unlock
    )
    -(&mm->mmap_sem)
    +(mm)
    
    Signed-off-by: Michel Lespinasse <walken@google.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Reviewed-by: Daniel Jordan <daniel.m.jordan@oracle.com>
    Reviewed-by: Laurent Dufour <ldufour@linux.ibm.com>
    Reviewed-by: Vlastimil Babka <vbabka@suse.cz>
    Cc: Davidlohr Bueso <dbueso@suse.de>
    Cc: David Rientjes <rientjes@google.com>
    Cc: Hugh Dickins <hughd@google.com>
    Cc: Jason Gunthorpe <jgg@ziepe.ca>
    Cc: Jerome Glisse <jglisse@redhat.com>
    Cc: John Hubbard <jhubbard@nvidia.com>
    Cc: Liam Howlett <Liam.Howlett@oracle.com>
    Cc: Matthew Wilcox <willy@infradead.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Ying Han <yinghan@google.com>
    Link: http://lkml.kernel.org/r/20200520052908.204642-5-walken@google.com
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit f2453978a4f2ddb1938fa80e9bf0c9d6252bd5f8
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Mon Apr 6 16:01:42 2020 -0400

    NFSD: Fix improperly-formatted Doxygen comments
    
    fs/nfsd/nfsctl.c:256: warning: Function parameter or member 'file' not described in 'write_unlock_ip'
    fs/nfsd/nfsctl.c:256: warning: Function parameter or member 'buf' not described in 'write_unlock_ip'
    fs/nfsd/nfsctl.c:256: warning: Function parameter or member 'size' not described in 'write_unlock_ip'
    fs/nfsd/nfsctl.c:295: warning: Function parameter or member 'file' not described in 'write_unlock_fs'
    fs/nfsd/nfsctl.c:295: warning: Function parameter or member 'buf' not described in 'write_unlock_fs'
    fs/nfsd/nfsctl.c:295: warning: Function parameter or member 'size' not described in 'write_unlock_fs'
    fs/nfsd/nfsctl.c:352: warning: Function parameter or member 'file' not described in 'write_filehandle'
    fs/nfsd/nfsctl.c:352: warning: Function parameter or member 'buf' not described in 'write_filehandle'
    fs/nfsd/nfsctl.c:352: warning: Function parameter or member 'size' not described in 'write_filehandle'
    fs/nfsd/nfsctl.c:434: warning: Function parameter or member 'file' not described in 'write_threads'
    fs/nfsd/nfsctl.c:434: warning: Function parameter or member 'buf' not described in 'write_threads'
    fs/nfsd/nfsctl.c:434: warning: Function parameter or member 'size' not described in 'write_threads'
    fs/nfsd/nfsctl.c:478: warning: Function parameter or member 'file' not described in 'write_pool_threads'
    fs/nfsd/nfsctl.c:478: warning: Function parameter or member 'buf' not described in 'write_pool_threads'
    fs/nfsd/nfsctl.c:478: warning: Function parameter or member 'size' not described in 'write_pool_threads'
    fs/nfsd/nfsctl.c:697: warning: Function parameter or member 'file' not described in 'write_versions'
    fs/nfsd/nfsctl.c:697: warning: Function parameter or member 'buf' not described in 'write_versions'
    fs/nfsd/nfsctl.c:697: warning: Function parameter or member 'size' not described in 'write_versions'
    fs/nfsd/nfsctl.c:858: warning: Function parameter or member 'file' not described in 'write_ports'
    fs/nfsd/nfsctl.c:858: warning: Function parameter or member 'buf' not described in 'write_ports'
    fs/nfsd/nfsctl.c:858: warning: Function parameter or member 'size' not described in 'write_ports'
    fs/nfsd/nfsctl.c:892: warning: Function parameter or member 'file' not described in 'write_maxblksize'
    fs/nfsd/nfsctl.c:892: warning: Function parameter or member 'buf' not described in 'write_maxblksize'
    fs/nfsd/nfsctl.c:892: warning: Function parameter or member 'size' not described in 'write_maxblksize'
    fs/nfsd/nfsctl.c:941: warning: Function parameter or member 'file' not described in 'write_maxconn'
    fs/nfsd/nfsctl.c:941: warning: Function parameter or member 'buf' not described in 'write_maxconn'
    fs/nfsd/nfsctl.c:941: warning: Function parameter or member 'size' not described in 'write_maxconn'
    fs/nfsd/nfsctl.c:1023: warning: Function parameter or member 'file' not described in 'write_leasetime'
    fs/nfsd/nfsctl.c:1023: warning: Function parameter or member 'buf' not described in 'write_leasetime'
    fs/nfsd/nfsctl.c:1023: warning: Function parameter or member 'size' not described in 'write_leasetime'
    fs/nfsd/nfsctl.c:1039: warning: Function parameter or member 'file' not described in 'write_gracetime'
    fs/nfsd/nfsctl.c:1039: warning: Function parameter or member 'buf' not described in 'write_gracetime'
    fs/nfsd/nfsctl.c:1039: warning: Function parameter or member 'size' not described in 'write_gracetime'
    fs/nfsd/nfsctl.c:1094: warning: Function parameter or member 'file' not described in 'write_recoverydir'
    fs/nfsd/nfsctl.c:1094: warning: Function parameter or member 'buf' not described in 'write_recoverydir'
    fs/nfsd/nfsctl.c:1094: warning: Function parameter or member 'size' not described in 'write_recoverydir'
    fs/nfsd/nfsctl.c:1125: warning: Function parameter or member 'file' not described in 'write_v4_end_grace'
    fs/nfsd/nfsctl.c:1125: warning: Function parameter or member 'buf' not described in 'write_v4_end_grace'
    fs/nfsd/nfsctl.c:1125: warning: Function parameter or member 'size' not described in 'write_v4_end_grace'
    
    fs/nfsd/nfs4proc.c:1164: warning: Function parameter or member 'nss' not described in 'nfsd4_interssc_connect'
    fs/nfsd/nfs4proc.c:1164: warning: Function parameter or member 'rqstp' not described in 'nfsd4_interssc_connect'
    fs/nfsd/nfs4proc.c:1164: warning: Function parameter or member 'mount' not described in 'nfsd4_interssc_connect'
    fs/nfsd/nfs4proc.c:1262: warning: Function parameter or member 'rqstp' not described in 'nfsd4_setup_inter_ssc'
    fs/nfsd/nfs4proc.c:1262: warning: Function parameter or member 'cstate' not described in 'nfsd4_setup_inter_ssc'
    fs/nfsd/nfs4proc.c:1262: warning: Function parameter or member 'copy' not described in 'nfsd4_setup_inter_ssc'
    fs/nfsd/nfs4proc.c:1262: warning: Function parameter or member 'mount' not described in 'nfsd4_setup_inter_ssc'
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>

commit 3c32e1a8b7ea89ca1831d883cd6b9df447f42be7
Author: Eric Dumazet <edumazet@google.com>
Date:   Thu Dec 12 10:32:13 2019 -0800

    6pack,mkiss: fix possible deadlock
    
    commit 5c9934b6767b16ba60be22ec3cbd4379ad64170d upstream.
    
    We got another syzbot report [1] that tells us we must use
    write_lock_irq()/write_unlock_irq() to avoid possible deadlock.
    
    [1]
    
    WARNING: inconsistent lock state
    5.5.0-rc1-syzkaller #0 Not tainted
    --------------------------------
    inconsistent {HARDIRQ-ON-W} -> {IN-HARDIRQ-R} usage.
    syz-executor826/9605 [HC1[1]:SC0[0]:HE0:SE1] takes:
    ffffffff8a128718 (disc_data_lock){+-..}, at: sp_get.isra.0+0x1d/0xf0 drivers/net/ppp/ppp_synctty.c:138
    {HARDIRQ-ON-W} state was registered at:
      lock_acquire+0x190/0x410 kernel/locking/lockdep.c:4485
      __raw_write_lock_bh include/linux/rwlock_api_smp.h:203 [inline]
      _raw_write_lock_bh+0x33/0x50 kernel/locking/spinlock.c:319
      sixpack_close+0x1d/0x250 drivers/net/hamradio/6pack.c:657
      tty_ldisc_close.isra.0+0x119/0x1a0 drivers/tty/tty_ldisc.c:489
      tty_set_ldisc+0x230/0x6b0 drivers/tty/tty_ldisc.c:585
      tiocsetd drivers/tty/tty_io.c:2337 [inline]
      tty_ioctl+0xe8d/0x14f0 drivers/tty/tty_io.c:2597
      vfs_ioctl fs/ioctl.c:47 [inline]
      file_ioctl fs/ioctl.c:545 [inline]
      do_vfs_ioctl+0x977/0x14e0 fs/ioctl.c:732
      ksys_ioctl+0xab/0xd0 fs/ioctl.c:749
      __do_sys_ioctl fs/ioctl.c:756 [inline]
      __se_sys_ioctl fs/ioctl.c:754 [inline]
      __x64_sys_ioctl+0x73/0xb0 fs/ioctl.c:754
      do_syscall_64+0xfa/0x790 arch/x86/entry/common.c:294
      entry_SYSCALL_64_after_hwframe+0x49/0xbe
    irq event stamp: 3946
    hardirqs last  enabled at (3945): [<ffffffff87c86e43>] __raw_spin_unlock_irq include/linux/spinlock_api_smp.h:168 [inline]
    hardirqs last  enabled at (3945): [<ffffffff87c86e43>] _raw_spin_unlock_irq+0x23/0x80 kernel/locking/spinlock.c:199
    hardirqs last disabled at (3946): [<ffffffff8100675f>] trace_hardirqs_off_thunk+0x1a/0x1c arch/x86/entry/thunk_64.S:42
    softirqs last  enabled at (2658): [<ffffffff86a8b4df>] spin_unlock_bh include/linux/spinlock.h:383 [inline]
    softirqs last  enabled at (2658): [<ffffffff86a8b4df>] clusterip_netdev_event+0x46f/0x670 net/ipv4/netfilter/ipt_CLUSTERIP.c:222
    softirqs last disabled at (2656): [<ffffffff86a8b22b>] spin_lock_bh include/linux/spinlock.h:343 [inline]
    softirqs last disabled at (2656): [<ffffffff86a8b22b>] clusterip_netdev_event+0x1bb/0x670 net/ipv4/netfilter/ipt_CLUSTERIP.c:196
    
    other info that might help us debug this:
     Possible unsafe locking scenario:
    
           CPU0
           ----
      lock(disc_data_lock);
      <Interrupt>
        lock(disc_data_lock);
    
     *** DEADLOCK ***
    
    5 locks held by syz-executor826/9605:
     #0: ffff8880a905e198 (&tty->legacy_mutex){+.+.}, at: tty_lock+0xc7/0x130 drivers/tty/tty_mutex.c:19
     #1: ffffffff899a56c0 (rcu_read_lock){....}, at: mutex_spin_on_owner+0x0/0x330 kernel/locking/mutex.c:413
     #2: ffff8880a496a2b0 (&(&i->lock)->rlock){-.-.}, at: spin_lock include/linux/spinlock.h:338 [inline]
     #2: ffff8880a496a2b0 (&(&i->lock)->rlock){-.-.}, at: serial8250_interrupt+0x2d/0x1a0 drivers/tty/serial/8250/8250_core.c:116
     #3: ffffffff8c104048 (&port_lock_key){-.-.}, at: serial8250_handle_irq.part.0+0x24/0x330 drivers/tty/serial/8250/8250_port.c:1823
     #4: ffff8880a905e090 (&tty->ldisc_sem){++++}, at: tty_ldisc_ref+0x22/0x90 drivers/tty/tty_ldisc.c:288
    
    stack backtrace:
    CPU: 1 PID: 9605 Comm: syz-executor826 Not tainted 5.5.0-rc1-syzkaller #0
    Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011
    Call Trace:
     <IRQ>
     __dump_stack lib/dump_stack.c:77 [inline]
     dump_stack+0x197/0x210 lib/dump_stack.c:118
     print_usage_bug.cold+0x327/0x378 kernel/locking/lockdep.c:3101
     valid_state kernel/locking/lockdep.c:3112 [inline]
     mark_lock_irq kernel/locking/lockdep.c:3309 [inline]
     mark_lock+0xbb4/0x1220 kernel/locking/lockdep.c:3666
     mark_usage kernel/locking/lockdep.c:3554 [inline]
     __lock_acquire+0x1e55/0x4a00 kernel/locking/lockdep.c:3909
     lock_acquire+0x190/0x410 kernel/locking/lockdep.c:4485
     __raw_read_lock include/linux/rwlock_api_smp.h:149 [inline]
     _raw_read_lock+0x32/0x50 kernel/locking/spinlock.c:223
     sp_get.isra.0+0x1d/0xf0 drivers/net/ppp/ppp_synctty.c:138
     sixpack_write_wakeup+0x25/0x340 drivers/net/hamradio/6pack.c:402
     tty_wakeup+0xe9/0x120 drivers/tty/tty_io.c:536
     tty_port_default_wakeup+0x2b/0x40 drivers/tty/tty_port.c:50
     tty_port_tty_wakeup+0x57/0x70 drivers/tty/tty_port.c:387
     uart_write_wakeup+0x46/0x70 drivers/tty/serial/serial_core.c:104
     serial8250_tx_chars+0x495/0xaf0 drivers/tty/serial/8250/8250_port.c:1761
     serial8250_handle_irq.part.0+0x2a2/0x330 drivers/tty/serial/8250/8250_port.c:1834
     serial8250_handle_irq drivers/tty/serial/8250/8250_port.c:1820 [inline]
     serial8250_default_handle_irq+0xc0/0x150 drivers/tty/serial/8250/8250_port.c:1850
     serial8250_interrupt+0xf1/0x1a0 drivers/tty/serial/8250/8250_core.c:126
     __handle_irq_event_percpu+0x15d/0x970 kernel/irq/handle.c:149
     handle_irq_event_percpu+0x74/0x160 kernel/irq/handle.c:189
     handle_irq_event+0xa7/0x134 kernel/irq/handle.c:206
     handle_edge_irq+0x25e/0x8d0 kernel/irq/chip.c:830
     generic_handle_irq_desc include/linux/irqdesc.h:156 [inline]
     do_IRQ+0xde/0x280 arch/x86/kernel/irq.c:250
     common_interrupt+0xf/0xf arch/x86/entry/entry_64.S:607
     </IRQ>
    RIP: 0010:cpu_relax arch/x86/include/asm/processor.h:685 [inline]
    RIP: 0010:mutex_spin_on_owner+0x247/0x330 kernel/locking/mutex.c:579
    Code: c3 be 08 00 00 00 4c 89 e7 e8 e5 06 59 00 4c 89 e0 48 c1 e8 03 42 80 3c 38 00 0f 85 e1 00 00 00 49 8b 04 24 a8 01 75 96 f3 90 <e9> 2f fe ff ff 0f 0b e8 0d 19 09 00 84 c0 0f 85 ff fd ff ff 48 c7
    RSP: 0018:ffffc90001eafa20 EFLAGS: 00000246 ORIG_RAX: ffffffffffffffd7
    RAX: 0000000000000000 RBX: ffff88809fd9e0c0 RCX: 1ffffffff13266dd
    RDX: 0000000000000000 RSI: 0000000000000008 RDI: 0000000000000000
    RBP: ffffc90001eafa60 R08: 1ffff11013d22898 R09: ffffed1013d22899
    R10: ffffed1013d22898 R11: ffff88809e9144c7 R12: ffff8880a905e138
    R13: ffff88809e9144c0 R14: 0000000000000000 R15: dffffc0000000000
     mutex_optimistic_spin kernel/locking/mutex.c:673 [inline]
     __mutex_lock_common kernel/locking/mutex.c:962 [inline]
     __mutex_lock+0x32b/0x13c0 kernel/locking/mutex.c:1106
     mutex_lock_nested+0x16/0x20 kernel/locking/mutex.c:1121
     tty_lock+0xc7/0x130 drivers/tty/tty_mutex.c:19
     tty_release+0xb5/0xe90 drivers/tty/tty_io.c:1665
     __fput+0x2ff/0x890 fs/file_table.c:280
     ____fput+0x16/0x20 fs/file_table.c:313
     task_work_run+0x145/0x1c0 kernel/task_work.c:113
     exit_task_work include/linux/task_work.h:22 [inline]
     do_exit+0x8e7/0x2ef0 kernel/exit.c:797
     do_group_exit+0x135/0x360 kernel/exit.c:895
     __do_sys_exit_group kernel/exit.c:906 [inline]
     __se_sys_exit_group kernel/exit.c:904 [inline]
     __x64_sys_exit_group+0x44/0x50 kernel/exit.c:904
     do_syscall_64+0xfa/0x790 arch/x86/entry/common.c:294
     entry_SYSCALL_64_after_hwframe+0x49/0xbe
    RIP: 0033:0x43fef8
    Code: Bad RIP value.
    RSP: 002b:00007ffdb07d2338 EFLAGS: 00000246 ORIG_RAX: 00000000000000e7
    RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 000000000043fef8
    RDX: 0000000000000000 RSI: 000000000000003c RDI: 0000000000000000
    RBP: 00000000004bf730 R08: 00000000000000e7 R09: ffffffffffffffd0
    R10: 00000000004002c8 R11: 0000000000000246 R12: 0000000000000001
    R13: 00000000006d1180 R14: 0000000000000000 R15: 0000000000000000
    
    Fixes: 6e4e2f811bad ("6pack,mkiss: fix lock inconsistency")
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Reported-by: syzbot <syzkaller@googlegroups.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit 62bcfd5e5316f81e6c3f273443df4d89ee6d3e78
Author: Filipe Manana <fdmanana@suse.com>
Date:   Wed Dec 11 09:01:40 2019 +0000

    Btrfs: fix infinite loop during nocow writeback due to race
    
    commit de7999afedff02c6631feab3ea726a0e8f8c3d40 upstream.
    
    When starting writeback for a range that covers part of a preallocated
    extent, due to a race with writeback for another range that also covers
    another part of the same preallocated extent, we can end up in an infinite
    loop.
    
    Consider the following example where for inode 280 we have two dirty
    ranges:
    
      range A, from 294912 to 303103, 8192 bytes
      range B, from 348160 to 438271, 90112 bytes
    
    and we have the following file extent item layout for our inode:
    
      leaf 38895616 gen 24544 total ptrs 29 free space 13820 owner 5
          (...)
          item 27 key (280 108 200704) itemoff 14598 itemsize 53
              extent data disk bytenr 0 nr 0 type 1 (regular)
              extent data offset 0 nr 94208 ram 94208
          item 28 key (280 108 294912) itemoff 14545 itemsize 53
              extent data disk bytenr 10433052672 nr 81920 type 2 (prealloc)
              extent data offset 0 nr 81920 ram 81920
    
    Then the following happens:
    
    1) Writeback starts for range B (from 348160 to 438271), execution of
       run_delalloc_nocow() starts;
    
    2) The first iteration of run_delalloc_nocow()'s whil loop leaves us at
       the extent item at slot 28, pointing to the prealloc extent item
       covering the range from 294912 to 376831. This extent covers part of
       our range;
    
    3) An ordered extent is created against that extent, covering the file
       range from 348160 to 376831 (28672 bytes);
    
    4) We adjust 'cur_offset' to 376832 and move on to the next iteration of
       the while loop;
    
    5) The call to btrfs_lookup_file_extent() leaves us at the same leaf,
       pointing to slot 29, 1 slot after the last item (the extent item
       we processed in the previous iteration);
    
    6) Because we are a slot beyond the last item, we call btrfs_next_leaf(),
       which releases the search path before doing a another search for the
       last key of the leaf (280 108 294912);
    
    7) Right after btrfs_next_leaf() released the path, and before it did
       another search for the last key of the leaf, writeback for the range
       A (from 294912 to 303103) completes (it was previously started at
       some point);
    
    8) Upon completion of the ordered extent for range A, the prealloc extent
       we previously found got split into two extent items, one covering the
       range from 294912 to 303103 (8192 bytes), with a type of regular extent
       (and no longer prealloc) and another covering the range from 303104 to
       376831 (73728 bytes), with a type of prealloc and an offset of 8192
       bytes. So our leaf now has the following layout:
    
         leaf 38895616 gen 24544 total ptrs 31 free space 13664 owner 5
             (...)
             item 27 key (280 108 200704) itemoff 14598 itemsize 53
                 extent data disk bytenr 0 nr 0 type 1
                 extent data offset 0 nr 8192 ram 94208
             item 28 key (280 108 208896) itemoff 14545 itemsize 53
                 extent data disk bytenr 10433142784 nr 86016 type 1
                 extent data offset 0 nr 86016 ram 86016
             item 29 key (280 108 294912) itemoff 14492 itemsize 53
                 extent data disk bytenr 10433052672 nr 81920 type 1
                 extent data offset 0 nr 8192 ram 81920
             item 30 key (280 108 303104) itemoff 14439 itemsize 53
                 extent data disk bytenr 10433052672 nr 81920 type 2
                 extent data offset 8192 nr 73728 ram 81920
    
    9) After btrfs_next_leaf() returns, we have our path pointing to that same
       leaf and at slot 30, since it has a key we didn't have before and it's
       the first key greater then the key that was previously the last key of
       the leaf (key (280 108 294912));
    
    10) The extent item at slot 30 covers the range from 303104 to 376831
        which is in our target range, so we process it, despite having already
        created an ordered extent against this extent for the file range from
        348160 to 376831. This is because we skip to the next extent item only
        if its end is less than or equals to the start of our delalloc range,
        and not less than or equals to the current offset ('cur_offset');
    
    11) As a result we compute 'num_bytes' as:
    
        num_bytes = min(end + 1, extent_end) - cur_offset;
                  = min(438271 + 1, 376832) - 376832 = 0
    
    12) We then call create_io_em() for a 0 bytes range starting at offset
        376832;
    
    13) Then create_io_em() enters an infinite loop because its calls to
        btrfs_drop_extent_cache() do nothing due to the 0 length range
        passed to it. So no existing extent maps that cover the offset
        376832 get removed, and therefore calls to add_extent_mapping()
        return -EEXIST, resulting in an infinite loop. This loop from
        create_io_em() is the following:
    
        do {
            btrfs_drop_extent_cache(BTRFS_I(inode), em->start,
                                    em->start + em->len - 1, 0);
            write_lock(&em_tree->lock);
            ret = add_extent_mapping(em_tree, em, 1);
            write_unlock(&em_tree->lock);
            /*
             * The caller has taken lock_extent(), who could race with us
             * to add em?
             */
        } while (ret == -EEXIST);
    
    Also, each call to btrfs_drop_extent_cache() triggers a warning because
    the start offset passed to it (376832) is smaller then the end offset
    (376832 - 1) passed to it by -1, due to the 0 length:
    
      [258532.052621] ------------[ cut here ]------------
      [258532.052643] WARNING: CPU: 0 PID: 9987 at fs/btrfs/file.c:602 btrfs_drop_extent_cache+0x3f4/0x590 [btrfs]
      (...)
      [258532.052672] CPU: 0 PID: 9987 Comm: fsx Tainted: G        W         5.4.0-rc7-btrfs-next-64 #1
      [258532.052673] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.12.0-0-ga698c8995f-prebuilt.qemu.org 04/01/2014
      [258532.052691] RIP: 0010:btrfs_drop_extent_cache+0x3f4/0x590 [btrfs]
      (...)
      [258532.052695] RSP: 0018:ffffb4be0153f860 EFLAGS: 00010287
      [258532.052700] RAX: ffff975b445ee360 RBX: ffff975b44eb3e08 RCX: 0000000000000000
      [258532.052700] RDX: 0000000000038fff RSI: 0000000000039000 RDI: ffff975b445ee308
      [258532.052700] RBP: 0000000000038fff R08: 0000000000000000 R09: 0000000000000001
      [258532.052701] R10: ffff975b513c5c10 R11: 00000000e3c0cfa9 R12: 0000000000039000
      [258532.052703] R13: ffff975b445ee360 R14: 00000000ffffffef R15: ffff975b445ee308
      [258532.052705] FS:  00007f86a821de80(0000) GS:ffff975b76a00000(0000) knlGS:0000000000000000
      [258532.052707] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
      [258532.052708] CR2: 00007fdacf0f3ab4 CR3: 00000001f9d26002 CR4: 00000000003606f0
      [258532.052712] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
      [258532.052717] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
      [258532.052717] Call Trace:
      [258532.052718]  ? preempt_schedule_common+0x32/0x70
      [258532.052722]  ? ___preempt_schedule+0x16/0x20
      [258532.052741]  create_io_em+0xff/0x180 [btrfs]
      [258532.052767]  run_delalloc_nocow+0x942/0xb10 [btrfs]
      [258532.052791]  btrfs_run_delalloc_range+0x30b/0x520 [btrfs]
      [258532.052812]  ? find_lock_delalloc_range+0x221/0x250 [btrfs]
      [258532.052834]  writepage_delalloc+0xe4/0x140 [btrfs]
      [258532.052855]  __extent_writepage+0x110/0x4e0 [btrfs]
      [258532.052876]  extent_write_cache_pages+0x21c/0x480 [btrfs]
      [258532.052906]  extent_writepages+0x52/0xb0 [btrfs]
      [258532.052911]  do_writepages+0x23/0x80
      [258532.052915]  __filemap_fdatawrite_range+0xd2/0x110
      [258532.052938]  btrfs_fdatawrite_range+0x1b/0x50 [btrfs]
      [258532.052954]  start_ordered_ops+0x57/0xa0 [btrfs]
      [258532.052973]  ? btrfs_sync_file+0x225/0x490 [btrfs]
      [258532.052988]  btrfs_sync_file+0x225/0x490 [btrfs]
      [258532.052997]  __x64_sys_msync+0x199/0x200
      [258532.053004]  do_syscall_64+0x5c/0x250
      [258532.053007]  entry_SYSCALL_64_after_hwframe+0x49/0xbe
      [258532.053010] RIP: 0033:0x7f86a7dfd760
      (...)
      [258532.053014] RSP: 002b:00007ffd99af0368 EFLAGS: 00000246 ORIG_RAX: 000000000000001a
      [258532.053016] RAX: ffffffffffffffda RBX: 0000000000000ec9 RCX: 00007f86a7dfd760
      [258532.053017] RDX: 0000000000000004 RSI: 000000000000836c RDI: 00007f86a8221000
      [258532.053019] RBP: 0000000000021ec9 R08: 0000000000000003 R09: 00007f86a812037c
      [258532.053020] R10: 0000000000000001 R11: 0000000000000246 R12: 00000000000074a3
      [258532.053021] R13: 00007f86a8221000 R14: 000000000000836c R15: 0000000000000001
      [258532.053032] irq event stamp: 1653450494
      [258532.053035] hardirqs last  enabled at (1653450493): [<ffffffff9dec69f9>] _raw_spin_unlock_irq+0x29/0x50
      [258532.053037] hardirqs last disabled at (1653450494): [<ffffffff9d4048ea>] trace_hardirqs_off_thunk+0x1a/0x20
      [258532.053039] softirqs last  enabled at (1653449852): [<ffffffff9e200466>] __do_softirq+0x466/0x6bd
      [258532.053042] softirqs last disabled at (1653449845): [<ffffffff9d4c8a0c>] irq_exit+0xec/0x120
      [258532.053043] ---[ end trace 8476fce13d9ce20a ]---
    
    Which results in flooding dmesg/syslog since btrfs_drop_extent_cache()
    uses WARN_ON() and not WARN_ON_ONCE().
    
    So fix this issue by changing run_delalloc_nocow()'s loop to move to the
    next extent item when the current extent item ends at at offset less than
    or equals to the current offset instead of the start offset.
    
    Fixes: 80ff385665b7fc ("Btrfs: update nodatacow code v2")
    Reviewed-by: Josef Bacik <josef@toxicpanda.com>
    Signed-off-by: Filipe Manana <fdmanana@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>
    [bwh: Backported to 3.16: adjust context]
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit 746a1eda682cb7b5cd22f1b437da2121af64fbfe
Author: Hoang Le <hoang.h.le@dektech.com.au>
Date:   Fri Mar 13 10:18:03 2020 +0700

    tipc: add NULL pointer check to prevent kernel oops
    
    Calling:
    tipc_node_link_down()->
       - tipc_node_write_unlock()->tipc_mon_peer_down()
       - tipc_mon_peer_down()
      just after disabling bearer could be caused kernel oops.
    
    Fix this by adding a sanity check to make sure valid memory
    access.
    
    Acked-by: Jon Maloy <jmaloy@redhat.com>
    Signed-off-by: Hoang Le <hoang.h.le@dektech.com.au>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 2ff28b22a337b437a931cefa724f3abd45766258
Author: Cezary Rojewski <cezary.rojewski@intel.com>
Date:   Wed Jan 22 19:12:54 2020 +0100

    ASoC: Intel: skl_hda_dsp_common: Fix global-out-of-bounds bug
    
    commit 15adb20f64c302b31e10ad50f22bb224052ce1df upstream.
    
    Definitions for idisp snd_soc_dai_links within skl_hda_dsp_common are
    missing platform component. Add it to address following bug reported by
    KASAN:
    
    [   10.538502] BUG: KASAN: global-out-of-bounds in skl_hda_audio_probe+0x13a/0x2b0 [snd_soc_skl_hda_dsp]
    [   10.538509] Write of size 8 at addr ffffffffc0606840 by task systemd-udevd/299
    (...)
    [   10.538519] Call Trace:
    [   10.538524]  dump_stack+0x62/0x95
    [   10.538528]  print_address_description+0x2f5/0x3b0
    [   10.538532]  ? skl_hda_audio_probe+0x13a/0x2b0 [snd_soc_skl_hda_dsp]
    [   10.538535]  __kasan_report+0x134/0x191
    [   10.538538]  ? skl_hda_audio_probe+0x13a/0x2b0 [snd_soc_skl_hda_dsp]
    [   10.538542]  ? skl_hda_audio_probe+0x13a/0x2b0 [snd_soc_skl_hda_dsp]
    [   10.538544]  kasan_report+0x12/0x20
    [   10.538546]  __asan_store8+0x57/0x90
    [   10.538550]  skl_hda_audio_probe+0x13a/0x2b0 [snd_soc_skl_hda_dsp]
    [   10.538553]  platform_drv_probe+0x51/0xb0
    [   10.538556]  really_probe+0x311/0x600
    [   10.538559]  driver_probe_device+0x87/0x1b0
    [   10.538562]  device_driver_attach+0x8f/0xa0
    [   10.538565]  ? device_driver_attach+0xa0/0xa0
    [   10.538567]  __driver_attach+0x102/0x1a0
    [   10.538569]  ? device_driver_attach+0xa0/0xa0
    [   10.538572]  bus_for_each_dev+0xe8/0x160
    [   10.538574]  ? subsys_dev_iter_exit+0x10/0x10
    [   10.538577]  ? preempt_count_sub+0x18/0xc0
    [   10.538580]  ? _raw_write_unlock+0x1f/0x40
    [   10.538582]  driver_attach+0x2b/0x30
    [   10.538585]  bus_add_driver+0x251/0x340
    [   10.538588]  driver_register+0xd3/0x1c0
    [   10.538590]  __platform_driver_register+0x6c/0x80
    [   10.538592]  ? 0xffffffffc03e8000
    [   10.538595]  skl_hda_audio_init+0x1c/0x1000 [snd_soc_skl_hda_dsp]
    [   10.538598]  do_one_initcall+0xd0/0x36a
    [   10.538600]  ? trace_event_raw_event_initcall_finish+0x160/0x160
    [   10.538602]  ? kasan_unpoison_shadow+0x36/0x50
    [   10.538605]  ? __kasan_kmalloc+0xcc/0xe0
    [   10.538607]  ? kasan_unpoison_shadow+0x36/0x50
    [   10.538609]  ? kasan_poison_shadow+0x2f/0x40
    [   10.538612]  ? __asan_register_globals+0x65/0x80
    [   10.538615]  do_init_module+0xf9/0x36f
    [   10.538619]  load_module+0x398e/0x4590
    [   10.538625]  ? module_frob_arch_sections+0x20/0x20
    [   10.538628]  ? __kasan_check_write+0x14/0x20
    [   10.538630]  ? kernel_read+0x9a/0xc0
    [   10.538632]  ? __kasan_check_write+0x14/0x20
    [   10.538634]  ? kernel_read_file+0x1d3/0x3c0
    [   10.538638]  ? cap_capable+0xca/0x110
    [   10.538642]  __do_sys_finit_module+0x190/0x1d0
    [   10.538644]  ? __do_sys_finit_module+0x190/0x1d0
    [   10.538646]  ? __x64_sys_init_module+0x50/0x50
    [   10.538649]  ? expand_files+0x380/0x380
    [   10.538652]  ? __kasan_check_write+0x14/0x20
    [   10.538654]  ? fput_many+0x20/0xc0
    [   10.538658]  __x64_sys_finit_module+0x43/0x50
    [   10.538660]  do_syscall_64+0xce/0x700
    [   10.538662]  ? syscall_return_slowpath+0x230/0x230
    [   10.538665]  ? __do_page_fault+0x51e/0x640
    [   10.538668]  ? __kasan_check_read+0x11/0x20
    [   10.538670]  ? prepare_exit_to_usermode+0xc7/0x200
    [   10.538673]  entry_SYSCALL_64_after_hwframe+0x44/0xa9
    
    Fixes: a78959f407e6 ("ASoC: Intel: skl_hda_dsp_common: use modern dai_link style")
    Signed-off-by: Cezary Rojewski <cezary.rojewski@intel.com>
    Reviewed-by: Kai Vehmanen <kai.vehmanen@linux.intel.com>
    Link: https://lore.kernel.org/r/20200122181254.22801-1-cezary.rojewski@intel.com
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 9af68afd832fe664eeca856942d0c45aa71db14e
Author: Cezary Rojewski <cezary.rojewski@intel.com>
Date:   Wed Jan 22 19:12:54 2020 +0100

    ASoC: Intel: skl_hda_dsp_common: Fix global-out-of-bounds bug
    
    commit 15adb20f64c302b31e10ad50f22bb224052ce1df upstream.
    
    Definitions for idisp snd_soc_dai_links within skl_hda_dsp_common are
    missing platform component. Add it to address following bug reported by
    KASAN:
    
    [   10.538502] BUG: KASAN: global-out-of-bounds in skl_hda_audio_probe+0x13a/0x2b0 [snd_soc_skl_hda_dsp]
    [   10.538509] Write of size 8 at addr ffffffffc0606840 by task systemd-udevd/299
    (...)
    [   10.538519] Call Trace:
    [   10.538524]  dump_stack+0x62/0x95
    [   10.538528]  print_address_description+0x2f5/0x3b0
    [   10.538532]  ? skl_hda_audio_probe+0x13a/0x2b0 [snd_soc_skl_hda_dsp]
    [   10.538535]  __kasan_report+0x134/0x191
    [   10.538538]  ? skl_hda_audio_probe+0x13a/0x2b0 [snd_soc_skl_hda_dsp]
    [   10.538542]  ? skl_hda_audio_probe+0x13a/0x2b0 [snd_soc_skl_hda_dsp]
    [   10.538544]  kasan_report+0x12/0x20
    [   10.538546]  __asan_store8+0x57/0x90
    [   10.538550]  skl_hda_audio_probe+0x13a/0x2b0 [snd_soc_skl_hda_dsp]
    [   10.538553]  platform_drv_probe+0x51/0xb0
    [   10.538556]  really_probe+0x311/0x600
    [   10.538559]  driver_probe_device+0x87/0x1b0
    [   10.538562]  device_driver_attach+0x8f/0xa0
    [   10.538565]  ? device_driver_attach+0xa0/0xa0
    [   10.538567]  __driver_attach+0x102/0x1a0
    [   10.538569]  ? device_driver_attach+0xa0/0xa0
    [   10.538572]  bus_for_each_dev+0xe8/0x160
    [   10.538574]  ? subsys_dev_iter_exit+0x10/0x10
    [   10.538577]  ? preempt_count_sub+0x18/0xc0
    [   10.538580]  ? _raw_write_unlock+0x1f/0x40
    [   10.538582]  driver_attach+0x2b/0x30
    [   10.538585]  bus_add_driver+0x251/0x340
    [   10.538588]  driver_register+0xd3/0x1c0
    [   10.538590]  __platform_driver_register+0x6c/0x80
    [   10.538592]  ? 0xffffffffc03e8000
    [   10.538595]  skl_hda_audio_init+0x1c/0x1000 [snd_soc_skl_hda_dsp]
    [   10.538598]  do_one_initcall+0xd0/0x36a
    [   10.538600]  ? trace_event_raw_event_initcall_finish+0x160/0x160
    [   10.538602]  ? kasan_unpoison_shadow+0x36/0x50
    [   10.538605]  ? __kasan_kmalloc+0xcc/0xe0
    [   10.538607]  ? kasan_unpoison_shadow+0x36/0x50
    [   10.538609]  ? kasan_poison_shadow+0x2f/0x40
    [   10.538612]  ? __asan_register_globals+0x65/0x80
    [   10.538615]  do_init_module+0xf9/0x36f
    [   10.538619]  load_module+0x398e/0x4590
    [   10.538625]  ? module_frob_arch_sections+0x20/0x20
    [   10.538628]  ? __kasan_check_write+0x14/0x20
    [   10.538630]  ? kernel_read+0x9a/0xc0
    [   10.538632]  ? __kasan_check_write+0x14/0x20
    [   10.538634]  ? kernel_read_file+0x1d3/0x3c0
    [   10.538638]  ? cap_capable+0xca/0x110
    [   10.538642]  __do_sys_finit_module+0x190/0x1d0
    [   10.538644]  ? __do_sys_finit_module+0x190/0x1d0
    [   10.538646]  ? __x64_sys_init_module+0x50/0x50
    [   10.538649]  ? expand_files+0x380/0x380
    [   10.538652]  ? __kasan_check_write+0x14/0x20
    [   10.538654]  ? fput_many+0x20/0xc0
    [   10.538658]  __x64_sys_finit_module+0x43/0x50
    [   10.538660]  do_syscall_64+0xce/0x700
    [   10.538662]  ? syscall_return_slowpath+0x230/0x230
    [   10.538665]  ? __do_page_fault+0x51e/0x640
    [   10.538668]  ? __kasan_check_read+0x11/0x20
    [   10.538670]  ? prepare_exit_to_usermode+0xc7/0x200
    [   10.538673]  entry_SYSCALL_64_after_hwframe+0x44/0xa9
    
    Fixes: a78959f407e6 ("ASoC: Intel: skl_hda_dsp_common: use modern dai_link style")
    Signed-off-by: Cezary Rojewski <cezary.rojewski@intel.com>
    Reviewed-by: Kai Vehmanen <kai.vehmanen@linux.intel.com>
    Link: https://lore.kernel.org/r/20200122181254.22801-1-cezary.rojewski@intel.com
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 8d19f1c8e1937baf74e1962aae9f90fa3aeab463
Author: Mike Christie <mchristi@redhat.com>
Date:   Mon Nov 11 18:19:00 2019 -0600

    prctl: PR_{G,S}ET_IO_FLUSHER to support controlling memory reclaim
    
    There are several storage drivers like dm-multipath, iscsi, tcmu-runner,
    amd nbd that have userspace components that can run in the IO path. For
    example, iscsi and nbd's userspace deamons may need to recreate a socket
    and/or send IO on it, and dm-multipath's daemon multipathd may need to
    send SG IO or read/write IO to figure out the state of paths and re-set
    them up.
    
    In the kernel these drivers have access to GFP_NOIO/GFP_NOFS and the
    memalloc_*_save/restore functions to control the allocation behavior,
    but for userspace we would end up hitting an allocation that ended up
    writing data back to the same device we are trying to allocate for.
    The device is then in a state of deadlock, because to execute IO the
    device needs to allocate memory, but to allocate memory the memory
    layers want execute IO to the device.
    
    Here is an example with nbd using a local userspace daemon that performs
    network IO to a remote server. We are using XFS on top of the nbd device,
    but it can happen with any FS or other modules layered on top of the nbd
    device that can write out data to free memory.  Here a nbd daemon helper
    thread, msgr-worker-1, is performing a write/sendmsg on a socket to execute
    a request. This kicks off a reclaim operation which results in a WRITE to
    the nbd device and the nbd thread calling back into the mm layer.
    
    [ 1626.609191] msgr-worker-1   D    0  1026      1 0x00004000
    [ 1626.609193] Call Trace:
    [ 1626.609195]  ? __schedule+0x29b/0x630
    [ 1626.609197]  ? wait_for_completion+0xe0/0x170
    [ 1626.609198]  schedule+0x30/0xb0
    [ 1626.609200]  schedule_timeout+0x1f6/0x2f0
    [ 1626.609202]  ? blk_finish_plug+0x21/0x2e
    [ 1626.609204]  ? _xfs_buf_ioapply+0x2e6/0x410
    [ 1626.609206]  ? wait_for_completion+0xe0/0x170
    [ 1626.609208]  wait_for_completion+0x108/0x170
    [ 1626.609210]  ? wake_up_q+0x70/0x70
    [ 1626.609212]  ? __xfs_buf_submit+0x12e/0x250
    [ 1626.609214]  ? xfs_bwrite+0x25/0x60
    [ 1626.609215]  xfs_buf_iowait+0x22/0xf0
    [ 1626.609218]  __xfs_buf_submit+0x12e/0x250
    [ 1626.609220]  xfs_bwrite+0x25/0x60
    [ 1626.609222]  xfs_reclaim_inode+0x2e8/0x310
    [ 1626.609224]  xfs_reclaim_inodes_ag+0x1b6/0x300
    [ 1626.609227]  xfs_reclaim_inodes_nr+0x31/0x40
    [ 1626.609228]  super_cache_scan+0x152/0x1a0
    [ 1626.609231]  do_shrink_slab+0x12c/0x2d0
    [ 1626.609233]  shrink_slab+0x9c/0x2a0
    [ 1626.609235]  shrink_node+0xd7/0x470
    [ 1626.609237]  do_try_to_free_pages+0xbf/0x380
    [ 1626.609240]  try_to_free_pages+0xd9/0x1f0
    [ 1626.609245]  __alloc_pages_slowpath+0x3a4/0xd30
    [ 1626.609251]  ? ___slab_alloc+0x238/0x560
    [ 1626.609254]  __alloc_pages_nodemask+0x30c/0x350
    [ 1626.609259]  skb_page_frag_refill+0x97/0xd0
    [ 1626.609274]  sk_page_frag_refill+0x1d/0x80
    [ 1626.609279]  tcp_sendmsg_locked+0x2bb/0xdd0
    [ 1626.609304]  tcp_sendmsg+0x27/0x40
    [ 1626.609307]  sock_sendmsg+0x54/0x60
    [ 1626.609308]  ___sys_sendmsg+0x29f/0x320
    [ 1626.609313]  ? sock_poll+0x66/0xb0
    [ 1626.609318]  ? ep_item_poll.isra.15+0x40/0xc0
    [ 1626.609320]  ? ep_send_events_proc+0xe6/0x230
    [ 1626.609322]  ? hrtimer_try_to_cancel+0x54/0xf0
    [ 1626.609324]  ? ep_read_events_proc+0xc0/0xc0
    [ 1626.609326]  ? _raw_write_unlock_irq+0xa/0x20
    [ 1626.609327]  ? ep_scan_ready_list.constprop.19+0x218/0x230
    [ 1626.609329]  ? __hrtimer_init+0xb0/0xb0
    [ 1626.609331]  ? _raw_spin_unlock_irq+0xa/0x20
    [ 1626.609334]  ? ep_poll+0x26c/0x4a0
    [ 1626.609337]  ? tcp_tsq_write.part.54+0xa0/0xa0
    [ 1626.609339]  ? release_sock+0x43/0x90
    [ 1626.609341]  ? _raw_spin_unlock_bh+0xa/0x20
    [ 1626.609342]  __sys_sendmsg+0x47/0x80
    [ 1626.609347]  do_syscall_64+0x5f/0x1c0
    [ 1626.609349]  ? prepare_exit_to_usermode+0x75/0xa0
    [ 1626.609351]  entry_SYSCALL_64_after_hwframe+0x44/0xa9
    
    This patch adds a new prctl command that daemons can use after they have
    done their initial setup, and before they start to do allocations that
    are in the IO path. It sets the PF_MEMALLOC_NOIO and PF_LESS_THROTTLE
    flags so both userspace block and FS threads can use it to avoid the
    allocation recursion and try to prevent from being throttled while
    writing out data to free up memory.
    
    Signed-off-by: Mike Christie <mchristi@redhat.com>
    Acked-by: Michal Hocko <mhocko@suse.com>
    Tested-by: Masato Suzuki <masato.suzuki@wdc.com>
    Reviewed-by: Damien Le Moal <damien.lemoal@wdc.com>
    Reviewed-by: Bart Van Assche <bvanassche@acm.org>
    Reviewed-by: Dave Chinner <dchinner@redhat.com>
    Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
    Link: https://lore.kernel.org/r/20191112001900.9206-1-mchristi@redhat.com
    Signed-off-by: Christian Brauner <christian.brauner@ubuntu.com>

commit 15adb20f64c302b31e10ad50f22bb224052ce1df
Author: Cezary Rojewski <cezary.rojewski@intel.com>
Date:   Wed Jan 22 19:12:54 2020 +0100

    ASoC: Intel: skl_hda_dsp_common: Fix global-out-of-bounds bug
    
    Definitions for idisp snd_soc_dai_links within skl_hda_dsp_common are
    missing platform component. Add it to address following bug reported by
    KASAN:
    
    [   10.538502] BUG: KASAN: global-out-of-bounds in skl_hda_audio_probe+0x13a/0x2b0 [snd_soc_skl_hda_dsp]
    [   10.538509] Write of size 8 at addr ffffffffc0606840 by task systemd-udevd/299
    (...)
    [   10.538519] Call Trace:
    [   10.538524]  dump_stack+0x62/0x95
    [   10.538528]  print_address_description+0x2f5/0x3b0
    [   10.538532]  ? skl_hda_audio_probe+0x13a/0x2b0 [snd_soc_skl_hda_dsp]
    [   10.538535]  __kasan_report+0x134/0x191
    [   10.538538]  ? skl_hda_audio_probe+0x13a/0x2b0 [snd_soc_skl_hda_dsp]
    [   10.538542]  ? skl_hda_audio_probe+0x13a/0x2b0 [snd_soc_skl_hda_dsp]
    [   10.538544]  kasan_report+0x12/0x20
    [   10.538546]  __asan_store8+0x57/0x90
    [   10.538550]  skl_hda_audio_probe+0x13a/0x2b0 [snd_soc_skl_hda_dsp]
    [   10.538553]  platform_drv_probe+0x51/0xb0
    [   10.538556]  really_probe+0x311/0x600
    [   10.538559]  driver_probe_device+0x87/0x1b0
    [   10.538562]  device_driver_attach+0x8f/0xa0
    [   10.538565]  ? device_driver_attach+0xa0/0xa0
    [   10.538567]  __driver_attach+0x102/0x1a0
    [   10.538569]  ? device_driver_attach+0xa0/0xa0
    [   10.538572]  bus_for_each_dev+0xe8/0x160
    [   10.538574]  ? subsys_dev_iter_exit+0x10/0x10
    [   10.538577]  ? preempt_count_sub+0x18/0xc0
    [   10.538580]  ? _raw_write_unlock+0x1f/0x40
    [   10.538582]  driver_attach+0x2b/0x30
    [   10.538585]  bus_add_driver+0x251/0x340
    [   10.538588]  driver_register+0xd3/0x1c0
    [   10.538590]  __platform_driver_register+0x6c/0x80
    [   10.538592]  ? 0xffffffffc03e8000
    [   10.538595]  skl_hda_audio_init+0x1c/0x1000 [snd_soc_skl_hda_dsp]
    [   10.538598]  do_one_initcall+0xd0/0x36a
    [   10.538600]  ? trace_event_raw_event_initcall_finish+0x160/0x160
    [   10.538602]  ? kasan_unpoison_shadow+0x36/0x50
    [   10.538605]  ? __kasan_kmalloc+0xcc/0xe0
    [   10.538607]  ? kasan_unpoison_shadow+0x36/0x50
    [   10.538609]  ? kasan_poison_shadow+0x2f/0x40
    [   10.538612]  ? __asan_register_globals+0x65/0x80
    [   10.538615]  do_init_module+0xf9/0x36f
    [   10.538619]  load_module+0x398e/0x4590
    [   10.538625]  ? module_frob_arch_sections+0x20/0x20
    [   10.538628]  ? __kasan_check_write+0x14/0x20
    [   10.538630]  ? kernel_read+0x9a/0xc0
    [   10.538632]  ? __kasan_check_write+0x14/0x20
    [   10.538634]  ? kernel_read_file+0x1d3/0x3c0
    [   10.538638]  ? cap_capable+0xca/0x110
    [   10.538642]  __do_sys_finit_module+0x190/0x1d0
    [   10.538644]  ? __do_sys_finit_module+0x190/0x1d0
    [   10.538646]  ? __x64_sys_init_module+0x50/0x50
    [   10.538649]  ? expand_files+0x380/0x380
    [   10.538652]  ? __kasan_check_write+0x14/0x20
    [   10.538654]  ? fput_many+0x20/0xc0
    [   10.538658]  __x64_sys_finit_module+0x43/0x50
    [   10.538660]  do_syscall_64+0xce/0x700
    [   10.538662]  ? syscall_return_slowpath+0x230/0x230
    [   10.538665]  ? __do_page_fault+0x51e/0x640
    [   10.538668]  ? __kasan_check_read+0x11/0x20
    [   10.538670]  ? prepare_exit_to_usermode+0xc7/0x200
    [   10.538673]  entry_SYSCALL_64_after_hwframe+0x44/0xa9
    
    Fixes: a78959f407e6 ("ASoC: Intel: skl_hda_dsp_common: use modern dai_link style")
    Signed-off-by: Cezary Rojewski <cezary.rojewski@intel.com>
    Reviewed-by: Kai Vehmanen <kai.vehmanen@linux.intel.com>
    Link: https://lore.kernel.org/r/20200122181254.22801-1-cezary.rojewski@intel.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

commit 842c4cd688268859f077f552fd60f0521abf52dc
Author: Filipe Manana <fdmanana@suse.com>
Date:   Wed Dec 11 09:01:40 2019 +0000

    Btrfs: fix infinite loop during nocow writeback due to race
    
    commit de7999afedff02c6631feab3ea726a0e8f8c3d40 upstream.
    
    When starting writeback for a range that covers part of a preallocated
    extent, due to a race with writeback for another range that also covers
    another part of the same preallocated extent, we can end up in an infinite
    loop.
    
    Consider the following example where for inode 280 we have two dirty
    ranges:
    
      range A, from 294912 to 303103, 8192 bytes
      range B, from 348160 to 438271, 90112 bytes
    
    and we have the following file extent item layout for our inode:
    
      leaf 38895616 gen 24544 total ptrs 29 free space 13820 owner 5
          (...)
          item 27 key (280 108 200704) itemoff 14598 itemsize 53
              extent data disk bytenr 0 nr 0 type 1 (regular)
              extent data offset 0 nr 94208 ram 94208
          item 28 key (280 108 294912) itemoff 14545 itemsize 53
              extent data disk bytenr 10433052672 nr 81920 type 2 (prealloc)
              extent data offset 0 nr 81920 ram 81920
    
    Then the following happens:
    
    1) Writeback starts for range B (from 348160 to 438271), execution of
       run_delalloc_nocow() starts;
    
    2) The first iteration of run_delalloc_nocow()'s whil loop leaves us at
       the extent item at slot 28, pointing to the prealloc extent item
       covering the range from 294912 to 376831. This extent covers part of
       our range;
    
    3) An ordered extent is created against that extent, covering the file
       range from 348160 to 376831 (28672 bytes);
    
    4) We adjust 'cur_offset' to 376832 and move on to the next iteration of
       the while loop;
    
    5) The call to btrfs_lookup_file_extent() leaves us at the same leaf,
       pointing to slot 29, 1 slot after the last item (the extent item
       we processed in the previous iteration);
    
    6) Because we are a slot beyond the last item, we call btrfs_next_leaf(),
       which releases the search path before doing a another search for the
       last key of the leaf (280 108 294912);
    
    7) Right after btrfs_next_leaf() released the path, and before it did
       another search for the last key of the leaf, writeback for the range
       A (from 294912 to 303103) completes (it was previously started at
       some point);
    
    8) Upon completion of the ordered extent for range A, the prealloc extent
       we previously found got split into two extent items, one covering the
       range from 294912 to 303103 (8192 bytes), with a type of regular extent
       (and no longer prealloc) and another covering the range from 303104 to
       376831 (73728 bytes), with a type of prealloc and an offset of 8192
       bytes. So our leaf now has the following layout:
    
         leaf 38895616 gen 24544 total ptrs 31 free space 13664 owner 5
             (...)
             item 27 key (280 108 200704) itemoff 14598 itemsize 53
                 extent data disk bytenr 0 nr 0 type 1
                 extent data offset 0 nr 8192 ram 94208
             item 28 key (280 108 208896) itemoff 14545 itemsize 53
                 extent data disk bytenr 10433142784 nr 86016 type 1
                 extent data offset 0 nr 86016 ram 86016
             item 29 key (280 108 294912) itemoff 14492 itemsize 53
                 extent data disk bytenr 10433052672 nr 81920 type 1
                 extent data offset 0 nr 8192 ram 81920
             item 30 key (280 108 303104) itemoff 14439 itemsize 53
                 extent data disk bytenr 10433052672 nr 81920 type 2
                 extent data offset 8192 nr 73728 ram 81920
    
    9) After btrfs_next_leaf() returns, we have our path pointing to that same
       leaf and at slot 30, since it has a key we didn't have before and it's
       the first key greater then the key that was previously the last key of
       the leaf (key (280 108 294912));
    
    10) The extent item at slot 30 covers the range from 303104 to 376831
        which is in our target range, so we process it, despite having already
        created an ordered extent against this extent for the file range from
        348160 to 376831. This is because we skip to the next extent item only
        if its end is less than or equals to the start of our delalloc range,
        and not less than or equals to the current offset ('cur_offset');
    
    11) As a result we compute 'num_bytes' as:
    
        num_bytes = min(end + 1, extent_end) - cur_offset;
                  = min(438271 + 1, 376832) - 376832 = 0
    
    12) We then call create_io_em() for a 0 bytes range starting at offset
        376832;
    
    13) Then create_io_em() enters an infinite loop because its calls to
        btrfs_drop_extent_cache() do nothing due to the 0 length range
        passed to it. So no existing extent maps that cover the offset
        376832 get removed, and therefore calls to add_extent_mapping()
        return -EEXIST, resulting in an infinite loop. This loop from
        create_io_em() is the following:
    
        do {
            btrfs_drop_extent_cache(BTRFS_I(inode), em->start,
                                    em->start + em->len - 1, 0);
            write_lock(&em_tree->lock);
            ret = add_extent_mapping(em_tree, em, 1);
            write_unlock(&em_tree->lock);
            /*
             * The caller has taken lock_extent(), who could race with us
             * to add em?
             */
        } while (ret == -EEXIST);
    
    Also, each call to btrfs_drop_extent_cache() triggers a warning because
    the start offset passed to it (376832) is smaller then the end offset
    (376832 - 1) passed to it by -1, due to the 0 length:
    
      [258532.052621] ------------[ cut here ]------------
      [258532.052643] WARNING: CPU: 0 PID: 9987 at fs/btrfs/file.c:602 btrfs_drop_extent_cache+0x3f4/0x590 [btrfs]
      (...)
      [258532.052672] CPU: 0 PID: 9987 Comm: fsx Tainted: G        W         5.4.0-rc7-btrfs-next-64 #1
      [258532.052673] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.12.0-0-ga698c8995f-prebuilt.qemu.org 04/01/2014
      [258532.052691] RIP: 0010:btrfs_drop_extent_cache+0x3f4/0x590 [btrfs]
      (...)
      [258532.052695] RSP: 0018:ffffb4be0153f860 EFLAGS: 00010287
      [258532.052700] RAX: ffff975b445ee360 RBX: ffff975b44eb3e08 RCX: 0000000000000000
      [258532.052700] RDX: 0000000000038fff RSI: 0000000000039000 RDI: ffff975b445ee308
      [258532.052700] RBP: 0000000000038fff R08: 0000000000000000 R09: 0000000000000001
      [258532.052701] R10: ffff975b513c5c10 R11: 00000000e3c0cfa9 R12: 0000000000039000
      [258532.052703] R13: ffff975b445ee360 R14: 00000000ffffffef R15: ffff975b445ee308
      [258532.052705] FS:  00007f86a821de80(0000) GS:ffff975b76a00000(0000) knlGS:0000000000000000
      [258532.052707] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
      [258532.052708] CR2: 00007fdacf0f3ab4 CR3: 00000001f9d26002 CR4: 00000000003606f0
      [258532.052712] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
      [258532.052717] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
      [258532.052717] Call Trace:
      [258532.052718]  ? preempt_schedule_common+0x32/0x70
      [258532.052722]  ? ___preempt_schedule+0x16/0x20
      [258532.052741]  create_io_em+0xff/0x180 [btrfs]
      [258532.052767]  run_delalloc_nocow+0x942/0xb10 [btrfs]
      [258532.052791]  btrfs_run_delalloc_range+0x30b/0x520 [btrfs]
      [258532.052812]  ? find_lock_delalloc_range+0x221/0x250 [btrfs]
      [258532.052834]  writepage_delalloc+0xe4/0x140 [btrfs]
      [258532.052855]  __extent_writepage+0x110/0x4e0 [btrfs]
      [258532.052876]  extent_write_cache_pages+0x21c/0x480 [btrfs]
      [258532.052906]  extent_writepages+0x52/0xb0 [btrfs]
      [258532.052911]  do_writepages+0x23/0x80
      [258532.052915]  __filemap_fdatawrite_range+0xd2/0x110
      [258532.052938]  btrfs_fdatawrite_range+0x1b/0x50 [btrfs]
      [258532.052954]  start_ordered_ops+0x57/0xa0 [btrfs]
      [258532.052973]  ? btrfs_sync_file+0x225/0x490 [btrfs]
      [258532.052988]  btrfs_sync_file+0x225/0x490 [btrfs]
      [258532.052997]  __x64_sys_msync+0x199/0x200
      [258532.053004]  do_syscall_64+0x5c/0x250
      [258532.053007]  entry_SYSCALL_64_after_hwframe+0x49/0xbe
      [258532.053010] RIP: 0033:0x7f86a7dfd760
      (...)
      [258532.053014] RSP: 002b:00007ffd99af0368 EFLAGS: 00000246 ORIG_RAX: 000000000000001a
      [258532.053016] RAX: ffffffffffffffda RBX: 0000000000000ec9 RCX: 00007f86a7dfd760
      [258532.053017] RDX: 0000000000000004 RSI: 000000000000836c RDI: 00007f86a8221000
      [258532.053019] RBP: 0000000000021ec9 R08: 0000000000000003 R09: 00007f86a812037c
      [258532.053020] R10: 0000000000000001 R11: 0000000000000246 R12: 00000000000074a3
      [258532.053021] R13: 00007f86a8221000 R14: 000000000000836c R15: 0000000000000001
      [258532.053032] irq event stamp: 1653450494
      [258532.053035] hardirqs last  enabled at (1653450493): [<ffffffff9dec69f9>] _raw_spin_unlock_irq+0x29/0x50
      [258532.053037] hardirqs last disabled at (1653450494): [<ffffffff9d4048ea>] trace_hardirqs_off_thunk+0x1a/0x20
      [258532.053039] softirqs last  enabled at (1653449852): [<ffffffff9e200466>] __do_softirq+0x466/0x6bd
      [258532.053042] softirqs last disabled at (1653449845): [<ffffffff9d4c8a0c>] irq_exit+0xec/0x120
      [258532.053043] ---[ end trace 8476fce13d9ce20a ]---
    
    Which results in flooding dmesg/syslog since btrfs_drop_extent_cache()
    uses WARN_ON() and not WARN_ON_ONCE().
    
    So fix this issue by changing run_delalloc_nocow()'s loop to move to the
    next extent item when the current extent item ends at at offset less than
    or equals to the current offset instead of the start offset.
    
    Fixes: 80ff385665b7fc ("Btrfs: update nodatacow code v2")
    CC: stable@vger.kernel.org # 4.4+
    Reviewed-by: Josef Bacik <josef@toxicpanda.com>
    Signed-off-by: Filipe Manana <fdmanana@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit f0a1380de70a88f63ebfc2e3756d7f1543d2d68f
Author: Eric Dumazet <edumazet@google.com>
Date:   Thu Dec 12 10:32:13 2019 -0800

    6pack,mkiss: fix possible deadlock
    
    commit 5c9934b6767b16ba60be22ec3cbd4379ad64170d upstream.
    
    We got another syzbot report [1] that tells us we must use
    write_lock_irq()/write_unlock_irq() to avoid possible deadlock.
    
    [1]
    
    WARNING: inconsistent lock state
    5.5.0-rc1-syzkaller #0 Not tainted
    --------------------------------
    inconsistent {HARDIRQ-ON-W} -> {IN-HARDIRQ-R} usage.
    syz-executor826/9605 [HC1[1]:SC0[0]:HE0:SE1] takes:
    ffffffff8a128718 (disc_data_lock){+-..}, at: sp_get.isra.0+0x1d/0xf0 drivers/net/ppp/ppp_synctty.c:138
    {HARDIRQ-ON-W} state was registered at:
      lock_acquire+0x190/0x410 kernel/locking/lockdep.c:4485
      __raw_write_lock_bh include/linux/rwlock_api_smp.h:203 [inline]
      _raw_write_lock_bh+0x33/0x50 kernel/locking/spinlock.c:319
      sixpack_close+0x1d/0x250 drivers/net/hamradio/6pack.c:657
      tty_ldisc_close.isra.0+0x119/0x1a0 drivers/tty/tty_ldisc.c:489
      tty_set_ldisc+0x230/0x6b0 drivers/tty/tty_ldisc.c:585
      tiocsetd drivers/tty/tty_io.c:2337 [inline]
      tty_ioctl+0xe8d/0x14f0 drivers/tty/tty_io.c:2597
      vfs_ioctl fs/ioctl.c:47 [inline]
      file_ioctl fs/ioctl.c:545 [inline]
      do_vfs_ioctl+0x977/0x14e0 fs/ioctl.c:732
      ksys_ioctl+0xab/0xd0 fs/ioctl.c:749
      __do_sys_ioctl fs/ioctl.c:756 [inline]
      __se_sys_ioctl fs/ioctl.c:754 [inline]
      __x64_sys_ioctl+0x73/0xb0 fs/ioctl.c:754
      do_syscall_64+0xfa/0x790 arch/x86/entry/common.c:294
      entry_SYSCALL_64_after_hwframe+0x49/0xbe
    irq event stamp: 3946
    hardirqs last  enabled at (3945): [<ffffffff87c86e43>] __raw_spin_unlock_irq include/linux/spinlock_api_smp.h:168 [inline]
    hardirqs last  enabled at (3945): [<ffffffff87c86e43>] _raw_spin_unlock_irq+0x23/0x80 kernel/locking/spinlock.c:199
    hardirqs last disabled at (3946): [<ffffffff8100675f>] trace_hardirqs_off_thunk+0x1a/0x1c arch/x86/entry/thunk_64.S:42
    softirqs last  enabled at (2658): [<ffffffff86a8b4df>] spin_unlock_bh include/linux/spinlock.h:383 [inline]
    softirqs last  enabled at (2658): [<ffffffff86a8b4df>] clusterip_netdev_event+0x46f/0x670 net/ipv4/netfilter/ipt_CLUSTERIP.c:222
    softirqs last disabled at (2656): [<ffffffff86a8b22b>] spin_lock_bh include/linux/spinlock.h:343 [inline]
    softirqs last disabled at (2656): [<ffffffff86a8b22b>] clusterip_netdev_event+0x1bb/0x670 net/ipv4/netfilter/ipt_CLUSTERIP.c:196
    
    other info that might help us debug this:
     Possible unsafe locking scenario:
    
           CPU0
           ----
      lock(disc_data_lock);
      <Interrupt>
        lock(disc_data_lock);
    
     *** DEADLOCK ***
    
    5 locks held by syz-executor826/9605:
     #0: ffff8880a905e198 (&tty->legacy_mutex){+.+.}, at: tty_lock+0xc7/0x130 drivers/tty/tty_mutex.c:19
     #1: ffffffff899a56c0 (rcu_read_lock){....}, at: mutex_spin_on_owner+0x0/0x330 kernel/locking/mutex.c:413
     #2: ffff8880a496a2b0 (&(&i->lock)->rlock){-.-.}, at: spin_lock include/linux/spinlock.h:338 [inline]
     #2: ffff8880a496a2b0 (&(&i->lock)->rlock){-.-.}, at: serial8250_interrupt+0x2d/0x1a0 drivers/tty/serial/8250/8250_core.c:116
     #3: ffffffff8c104048 (&port_lock_key){-.-.}, at: serial8250_handle_irq.part.0+0x24/0x330 drivers/tty/serial/8250/8250_port.c:1823
     #4: ffff8880a905e090 (&tty->ldisc_sem){++++}, at: tty_ldisc_ref+0x22/0x90 drivers/tty/tty_ldisc.c:288
    
    stack backtrace:
    CPU: 1 PID: 9605 Comm: syz-executor826 Not tainted 5.5.0-rc1-syzkaller #0
    Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011
    Call Trace:
     <IRQ>
     __dump_stack lib/dump_stack.c:77 [inline]
     dump_stack+0x197/0x210 lib/dump_stack.c:118
     print_usage_bug.cold+0x327/0x378 kernel/locking/lockdep.c:3101
     valid_state kernel/locking/lockdep.c:3112 [inline]
     mark_lock_irq kernel/locking/lockdep.c:3309 [inline]
     mark_lock+0xbb4/0x1220 kernel/locking/lockdep.c:3666
     mark_usage kernel/locking/lockdep.c:3554 [inline]
     __lock_acquire+0x1e55/0x4a00 kernel/locking/lockdep.c:3909
     lock_acquire+0x190/0x410 kernel/locking/lockdep.c:4485
     __raw_read_lock include/linux/rwlock_api_smp.h:149 [inline]
     _raw_read_lock+0x32/0x50 kernel/locking/spinlock.c:223
     sp_get.isra.0+0x1d/0xf0 drivers/net/ppp/ppp_synctty.c:138
     sixpack_write_wakeup+0x25/0x340 drivers/net/hamradio/6pack.c:402
     tty_wakeup+0xe9/0x120 drivers/tty/tty_io.c:536
     tty_port_default_wakeup+0x2b/0x40 drivers/tty/tty_port.c:50
     tty_port_tty_wakeup+0x57/0x70 drivers/tty/tty_port.c:387
     uart_write_wakeup+0x46/0x70 drivers/tty/serial/serial_core.c:104
     serial8250_tx_chars+0x495/0xaf0 drivers/tty/serial/8250/8250_port.c:1761
     serial8250_handle_irq.part.0+0x2a2/0x330 drivers/tty/serial/8250/8250_port.c:1834
     serial8250_handle_irq drivers/tty/serial/8250/8250_port.c:1820 [inline]
     serial8250_default_handle_irq+0xc0/0x150 drivers/tty/serial/8250/8250_port.c:1850
     serial8250_interrupt+0xf1/0x1a0 drivers/tty/serial/8250/8250_core.c:126
     __handle_irq_event_percpu+0x15d/0x970 kernel/irq/handle.c:149
     handle_irq_event_percpu+0x74/0x160 kernel/irq/handle.c:189
     handle_irq_event+0xa7/0x134 kernel/irq/handle.c:206
     handle_edge_irq+0x25e/0x8d0 kernel/irq/chip.c:830
     generic_handle_irq_desc include/linux/irqdesc.h:156 [inline]
     do_IRQ+0xde/0x280 arch/x86/kernel/irq.c:250
     common_interrupt+0xf/0xf arch/x86/entry/entry_64.S:607
     </IRQ>
    RIP: 0010:cpu_relax arch/x86/include/asm/processor.h:685 [inline]
    RIP: 0010:mutex_spin_on_owner+0x247/0x330 kernel/locking/mutex.c:579
    Code: c3 be 08 00 00 00 4c 89 e7 e8 e5 06 59 00 4c 89 e0 48 c1 e8 03 42 80 3c 38 00 0f 85 e1 00 00 00 49 8b 04 24 a8 01 75 96 f3 90 <e9> 2f fe ff ff 0f 0b e8 0d 19 09 00 84 c0 0f 85 ff fd ff ff 48 c7
    RSP: 0018:ffffc90001eafa20 EFLAGS: 00000246 ORIG_RAX: ffffffffffffffd7
    RAX: 0000000000000000 RBX: ffff88809fd9e0c0 RCX: 1ffffffff13266dd
    RDX: 0000000000000000 RSI: 0000000000000008 RDI: 0000000000000000
    RBP: ffffc90001eafa60 R08: 1ffff11013d22898 R09: ffffed1013d22899
    R10: ffffed1013d22898 R11: ffff88809e9144c7 R12: ffff8880a905e138
    R13: ffff88809e9144c0 R14: 0000000000000000 R15: dffffc0000000000
     mutex_optimistic_spin kernel/locking/mutex.c:673 [inline]
     __mutex_lock_common kernel/locking/mutex.c:962 [inline]
     __mutex_lock+0x32b/0x13c0 kernel/locking/mutex.c:1106
     mutex_lock_nested+0x16/0x20 kernel/locking/mutex.c:1121
     tty_lock+0xc7/0x130 drivers/tty/tty_mutex.c:19
     tty_release+0xb5/0xe90 drivers/tty/tty_io.c:1665
     __fput+0x2ff/0x890 fs/file_table.c:280
     ____fput+0x16/0x20 fs/file_table.c:313
     task_work_run+0x145/0x1c0 kernel/task_work.c:113
     exit_task_work include/linux/task_work.h:22 [inline]
     do_exit+0x8e7/0x2ef0 kernel/exit.c:797
     do_group_exit+0x135/0x360 kernel/exit.c:895
     __do_sys_exit_group kernel/exit.c:906 [inline]
     __se_sys_exit_group kernel/exit.c:904 [inline]
     __x64_sys_exit_group+0x44/0x50 kernel/exit.c:904
     do_syscall_64+0xfa/0x790 arch/x86/entry/common.c:294
     entry_SYSCALL_64_after_hwframe+0x49/0xbe
    RIP: 0033:0x43fef8
    Code: Bad RIP value.
    RSP: 002b:00007ffdb07d2338 EFLAGS: 00000246 ORIG_RAX: 00000000000000e7
    RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 000000000043fef8
    RDX: 0000000000000000 RSI: 000000000000003c RDI: 0000000000000000
    RBP: 00000000004bf730 R08: 00000000000000e7 R09: ffffffffffffffd0
    R10: 00000000004002c8 R11: 0000000000000246 R12: 0000000000000001
    R13: 00000000006d1180 R14: 0000000000000000 R15: 0000000000000000
    
    Fixes: 6e4e2f811bad ("6pack,mkiss: fix lock inconsistency")
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Reported-by: syzbot <syzkaller@googlegroups.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 9b8e63d0a6e8d39bcbff3d99c8c52dab7771a68f
Author: Eric Dumazet <edumazet@google.com>
Date:   Thu Dec 12 10:32:13 2019 -0800

    6pack,mkiss: fix possible deadlock
    
    commit 5c9934b6767b16ba60be22ec3cbd4379ad64170d upstream.
    
    We got another syzbot report [1] that tells us we must use
    write_lock_irq()/write_unlock_irq() to avoid possible deadlock.
    
    [1]
    
    WARNING: inconsistent lock state
    5.5.0-rc1-syzkaller #0 Not tainted
    --------------------------------
    inconsistent {HARDIRQ-ON-W} -> {IN-HARDIRQ-R} usage.
    syz-executor826/9605 [HC1[1]:SC0[0]:HE0:SE1] takes:
    ffffffff8a128718 (disc_data_lock){+-..}, at: sp_get.isra.0+0x1d/0xf0 drivers/net/ppp/ppp_synctty.c:138
    {HARDIRQ-ON-W} state was registered at:
      lock_acquire+0x190/0x410 kernel/locking/lockdep.c:4485
      __raw_write_lock_bh include/linux/rwlock_api_smp.h:203 [inline]
      _raw_write_lock_bh+0x33/0x50 kernel/locking/spinlock.c:319
      sixpack_close+0x1d/0x250 drivers/net/hamradio/6pack.c:657
      tty_ldisc_close.isra.0+0x119/0x1a0 drivers/tty/tty_ldisc.c:489
      tty_set_ldisc+0x230/0x6b0 drivers/tty/tty_ldisc.c:585
      tiocsetd drivers/tty/tty_io.c:2337 [inline]
      tty_ioctl+0xe8d/0x14f0 drivers/tty/tty_io.c:2597
      vfs_ioctl fs/ioctl.c:47 [inline]
      file_ioctl fs/ioctl.c:545 [inline]
      do_vfs_ioctl+0x977/0x14e0 fs/ioctl.c:732
      ksys_ioctl+0xab/0xd0 fs/ioctl.c:749
      __do_sys_ioctl fs/ioctl.c:756 [inline]
      __se_sys_ioctl fs/ioctl.c:754 [inline]
      __x64_sys_ioctl+0x73/0xb0 fs/ioctl.c:754
      do_syscall_64+0xfa/0x790 arch/x86/entry/common.c:294
      entry_SYSCALL_64_after_hwframe+0x49/0xbe
    irq event stamp: 3946
    hardirqs last  enabled at (3945): [<ffffffff87c86e43>] __raw_spin_unlock_irq include/linux/spinlock_api_smp.h:168 [inline]
    hardirqs last  enabled at (3945): [<ffffffff87c86e43>] _raw_spin_unlock_irq+0x23/0x80 kernel/locking/spinlock.c:199
    hardirqs last disabled at (3946): [<ffffffff8100675f>] trace_hardirqs_off_thunk+0x1a/0x1c arch/x86/entry/thunk_64.S:42
    softirqs last  enabled at (2658): [<ffffffff86a8b4df>] spin_unlock_bh include/linux/spinlock.h:383 [inline]
    softirqs last  enabled at (2658): [<ffffffff86a8b4df>] clusterip_netdev_event+0x46f/0x670 net/ipv4/netfilter/ipt_CLUSTERIP.c:222
    softirqs last disabled at (2656): [<ffffffff86a8b22b>] spin_lock_bh include/linux/spinlock.h:343 [inline]
    softirqs last disabled at (2656): [<ffffffff86a8b22b>] clusterip_netdev_event+0x1bb/0x670 net/ipv4/netfilter/ipt_CLUSTERIP.c:196
    
    other info that might help us debug this:
     Possible unsafe locking scenario:
    
           CPU0
           ----
      lock(disc_data_lock);
      <Interrupt>
        lock(disc_data_lock);
    
     *** DEADLOCK ***
    
    5 locks held by syz-executor826/9605:
     #0: ffff8880a905e198 (&tty->legacy_mutex){+.+.}, at: tty_lock+0xc7/0x130 drivers/tty/tty_mutex.c:19
     #1: ffffffff899a56c0 (rcu_read_lock){....}, at: mutex_spin_on_owner+0x0/0x330 kernel/locking/mutex.c:413
     #2: ffff8880a496a2b0 (&(&i->lock)->rlock){-.-.}, at: spin_lock include/linux/spinlock.h:338 [inline]
     #2: ffff8880a496a2b0 (&(&i->lock)->rlock){-.-.}, at: serial8250_interrupt+0x2d/0x1a0 drivers/tty/serial/8250/8250_core.c:116
     #3: ffffffff8c104048 (&port_lock_key){-.-.}, at: serial8250_handle_irq.part.0+0x24/0x330 drivers/tty/serial/8250/8250_port.c:1823
     #4: ffff8880a905e090 (&tty->ldisc_sem){++++}, at: tty_ldisc_ref+0x22/0x90 drivers/tty/tty_ldisc.c:288
    
    stack backtrace:
    CPU: 1 PID: 9605 Comm: syz-executor826 Not tainted 5.5.0-rc1-syzkaller #0
    Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011
    Call Trace:
     <IRQ>
     __dump_stack lib/dump_stack.c:77 [inline]
     dump_stack+0x197/0x210 lib/dump_stack.c:118
     print_usage_bug.cold+0x327/0x378 kernel/locking/lockdep.c:3101
     valid_state kernel/locking/lockdep.c:3112 [inline]
     mark_lock_irq kernel/locking/lockdep.c:3309 [inline]
     mark_lock+0xbb4/0x1220 kernel/locking/lockdep.c:3666
     mark_usage kernel/locking/lockdep.c:3554 [inline]
     __lock_acquire+0x1e55/0x4a00 kernel/locking/lockdep.c:3909
     lock_acquire+0x190/0x410 kernel/locking/lockdep.c:4485
     __raw_read_lock include/linux/rwlock_api_smp.h:149 [inline]
     _raw_read_lock+0x32/0x50 kernel/locking/spinlock.c:223
     sp_get.isra.0+0x1d/0xf0 drivers/net/ppp/ppp_synctty.c:138
     sixpack_write_wakeup+0x25/0x340 drivers/net/hamradio/6pack.c:402
     tty_wakeup+0xe9/0x120 drivers/tty/tty_io.c:536
     tty_port_default_wakeup+0x2b/0x40 drivers/tty/tty_port.c:50
     tty_port_tty_wakeup+0x57/0x70 drivers/tty/tty_port.c:387
     uart_write_wakeup+0x46/0x70 drivers/tty/serial/serial_core.c:104
     serial8250_tx_chars+0x495/0xaf0 drivers/tty/serial/8250/8250_port.c:1761
     serial8250_handle_irq.part.0+0x2a2/0x330 drivers/tty/serial/8250/8250_port.c:1834
     serial8250_handle_irq drivers/tty/serial/8250/8250_port.c:1820 [inline]
     serial8250_default_handle_irq+0xc0/0x150 drivers/tty/serial/8250/8250_port.c:1850
     serial8250_interrupt+0xf1/0x1a0 drivers/tty/serial/8250/8250_core.c:126
     __handle_irq_event_percpu+0x15d/0x970 kernel/irq/handle.c:149
     handle_irq_event_percpu+0x74/0x160 kernel/irq/handle.c:189
     handle_irq_event+0xa7/0x134 kernel/irq/handle.c:206
     handle_edge_irq+0x25e/0x8d0 kernel/irq/chip.c:830
     generic_handle_irq_desc include/linux/irqdesc.h:156 [inline]
     do_IRQ+0xde/0x280 arch/x86/kernel/irq.c:250
     common_interrupt+0xf/0xf arch/x86/entry/entry_64.S:607
     </IRQ>
    RIP: 0010:cpu_relax arch/x86/include/asm/processor.h:685 [inline]
    RIP: 0010:mutex_spin_on_owner+0x247/0x330 kernel/locking/mutex.c:579
    Code: c3 be 08 00 00 00 4c 89 e7 e8 e5 06 59 00 4c 89 e0 48 c1 e8 03 42 80 3c 38 00 0f 85 e1 00 00 00 49 8b 04 24 a8 01 75 96 f3 90 <e9> 2f fe ff ff 0f 0b e8 0d 19 09 00 84 c0 0f 85 ff fd ff ff 48 c7
    RSP: 0018:ffffc90001eafa20 EFLAGS: 00000246 ORIG_RAX: ffffffffffffffd7
    RAX: 0000000000000000 RBX: ffff88809fd9e0c0 RCX: 1ffffffff13266dd
    RDX: 0000000000000000 RSI: 0000000000000008 RDI: 0000000000000000
    RBP: ffffc90001eafa60 R08: 1ffff11013d22898 R09: ffffed1013d22899
    R10: ffffed1013d22898 R11: ffff88809e9144c7 R12: ffff8880a905e138
    R13: ffff88809e9144c0 R14: 0000000000000000 R15: dffffc0000000000
     mutex_optimistic_spin kernel/locking/mutex.c:673 [inline]
     __mutex_lock_common kernel/locking/mutex.c:962 [inline]
     __mutex_lock+0x32b/0x13c0 kernel/locking/mutex.c:1106
     mutex_lock_nested+0x16/0x20 kernel/locking/mutex.c:1121
     tty_lock+0xc7/0x130 drivers/tty/tty_mutex.c:19
     tty_release+0xb5/0xe90 drivers/tty/tty_io.c:1665
     __fput+0x2ff/0x890 fs/file_table.c:280
     ____fput+0x16/0x20 fs/file_table.c:313
     task_work_run+0x145/0x1c0 kernel/task_work.c:113
     exit_task_work include/linux/task_work.h:22 [inline]
     do_exit+0x8e7/0x2ef0 kernel/exit.c:797
     do_group_exit+0x135/0x360 kernel/exit.c:895
     __do_sys_exit_group kernel/exit.c:906 [inline]
     __se_sys_exit_group kernel/exit.c:904 [inline]
     __x64_sys_exit_group+0x44/0x50 kernel/exit.c:904
     do_syscall_64+0xfa/0x790 arch/x86/entry/common.c:294
     entry_SYSCALL_64_after_hwframe+0x49/0xbe
    RIP: 0033:0x43fef8
    Code: Bad RIP value.
    RSP: 002b:00007ffdb07d2338 EFLAGS: 00000246 ORIG_RAX: 00000000000000e7
    RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 000000000043fef8
    RDX: 0000000000000000 RSI: 000000000000003c RDI: 0000000000000000
    RBP: 00000000004bf730 R08: 00000000000000e7 R09: ffffffffffffffd0
    R10: 00000000004002c8 R11: 0000000000000246 R12: 0000000000000001
    R13: 00000000006d1180 R14: 0000000000000000 R15: 0000000000000000
    
    Fixes: 6e4e2f811bad ("6pack,mkiss: fix lock inconsistency")
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Reported-by: syzbot <syzkaller@googlegroups.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 8b58905f212b4880d94b5b8ae54e5b84e311947d
Author: Eric Dumazet <edumazet@google.com>
Date:   Thu Dec 12 10:32:13 2019 -0800

    6pack,mkiss: fix possible deadlock
    
    commit 5c9934b6767b16ba60be22ec3cbd4379ad64170d upstream.
    
    We got another syzbot report [1] that tells us we must use
    write_lock_irq()/write_unlock_irq() to avoid possible deadlock.
    
    [1]
    
    WARNING: inconsistent lock state
    5.5.0-rc1-syzkaller #0 Not tainted
    --------------------------------
    inconsistent {HARDIRQ-ON-W} -> {IN-HARDIRQ-R} usage.
    syz-executor826/9605 [HC1[1]:SC0[0]:HE0:SE1] takes:
    ffffffff8a128718 (disc_data_lock){+-..}, at: sp_get.isra.0+0x1d/0xf0 drivers/net/ppp/ppp_synctty.c:138
    {HARDIRQ-ON-W} state was registered at:
      lock_acquire+0x190/0x410 kernel/locking/lockdep.c:4485
      __raw_write_lock_bh include/linux/rwlock_api_smp.h:203 [inline]
      _raw_write_lock_bh+0x33/0x50 kernel/locking/spinlock.c:319
      sixpack_close+0x1d/0x250 drivers/net/hamradio/6pack.c:657
      tty_ldisc_close.isra.0+0x119/0x1a0 drivers/tty/tty_ldisc.c:489
      tty_set_ldisc+0x230/0x6b0 drivers/tty/tty_ldisc.c:585
      tiocsetd drivers/tty/tty_io.c:2337 [inline]
      tty_ioctl+0xe8d/0x14f0 drivers/tty/tty_io.c:2597
      vfs_ioctl fs/ioctl.c:47 [inline]
      file_ioctl fs/ioctl.c:545 [inline]
      do_vfs_ioctl+0x977/0x14e0 fs/ioctl.c:732
      ksys_ioctl+0xab/0xd0 fs/ioctl.c:749
      __do_sys_ioctl fs/ioctl.c:756 [inline]
      __se_sys_ioctl fs/ioctl.c:754 [inline]
      __x64_sys_ioctl+0x73/0xb0 fs/ioctl.c:754
      do_syscall_64+0xfa/0x790 arch/x86/entry/common.c:294
      entry_SYSCALL_64_after_hwframe+0x49/0xbe
    irq event stamp: 3946
    hardirqs last  enabled at (3945): [<ffffffff87c86e43>] __raw_spin_unlock_irq include/linux/spinlock_api_smp.h:168 [inline]
    hardirqs last  enabled at (3945): [<ffffffff87c86e43>] _raw_spin_unlock_irq+0x23/0x80 kernel/locking/spinlock.c:199
    hardirqs last disabled at (3946): [<ffffffff8100675f>] trace_hardirqs_off_thunk+0x1a/0x1c arch/x86/entry/thunk_64.S:42
    softirqs last  enabled at (2658): [<ffffffff86a8b4df>] spin_unlock_bh include/linux/spinlock.h:383 [inline]
    softirqs last  enabled at (2658): [<ffffffff86a8b4df>] clusterip_netdev_event+0x46f/0x670 net/ipv4/netfilter/ipt_CLUSTERIP.c:222
    softirqs last disabled at (2656): [<ffffffff86a8b22b>] spin_lock_bh include/linux/spinlock.h:343 [inline]
    softirqs last disabled at (2656): [<ffffffff86a8b22b>] clusterip_netdev_event+0x1bb/0x670 net/ipv4/netfilter/ipt_CLUSTERIP.c:196
    
    other info that might help us debug this:
     Possible unsafe locking scenario:
    
           CPU0
           ----
      lock(disc_data_lock);
      <Interrupt>
        lock(disc_data_lock);
    
     *** DEADLOCK ***
    
    5 locks held by syz-executor826/9605:
     #0: ffff8880a905e198 (&tty->legacy_mutex){+.+.}, at: tty_lock+0xc7/0x130 drivers/tty/tty_mutex.c:19
     #1: ffffffff899a56c0 (rcu_read_lock){....}, at: mutex_spin_on_owner+0x0/0x330 kernel/locking/mutex.c:413
     #2: ffff8880a496a2b0 (&(&i->lock)->rlock){-.-.}, at: spin_lock include/linux/spinlock.h:338 [inline]
     #2: ffff8880a496a2b0 (&(&i->lock)->rlock){-.-.}, at: serial8250_interrupt+0x2d/0x1a0 drivers/tty/serial/8250/8250_core.c:116
     #3: ffffffff8c104048 (&port_lock_key){-.-.}, at: serial8250_handle_irq.part.0+0x24/0x330 drivers/tty/serial/8250/8250_port.c:1823
     #4: ffff8880a905e090 (&tty->ldisc_sem){++++}, at: tty_ldisc_ref+0x22/0x90 drivers/tty/tty_ldisc.c:288
    
    stack backtrace:
    CPU: 1 PID: 9605 Comm: syz-executor826 Not tainted 5.5.0-rc1-syzkaller #0
    Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011
    Call Trace:
     <IRQ>
     __dump_stack lib/dump_stack.c:77 [inline]
     dump_stack+0x197/0x210 lib/dump_stack.c:118
     print_usage_bug.cold+0x327/0x378 kernel/locking/lockdep.c:3101
     valid_state kernel/locking/lockdep.c:3112 [inline]
     mark_lock_irq kernel/locking/lockdep.c:3309 [inline]
     mark_lock+0xbb4/0x1220 kernel/locking/lockdep.c:3666
     mark_usage kernel/locking/lockdep.c:3554 [inline]
     __lock_acquire+0x1e55/0x4a00 kernel/locking/lockdep.c:3909
     lock_acquire+0x190/0x410 kernel/locking/lockdep.c:4485
     __raw_read_lock include/linux/rwlock_api_smp.h:149 [inline]
     _raw_read_lock+0x32/0x50 kernel/locking/spinlock.c:223
     sp_get.isra.0+0x1d/0xf0 drivers/net/ppp/ppp_synctty.c:138
     sixpack_write_wakeup+0x25/0x340 drivers/net/hamradio/6pack.c:402
     tty_wakeup+0xe9/0x120 drivers/tty/tty_io.c:536
     tty_port_default_wakeup+0x2b/0x40 drivers/tty/tty_port.c:50
     tty_port_tty_wakeup+0x57/0x70 drivers/tty/tty_port.c:387
     uart_write_wakeup+0x46/0x70 drivers/tty/serial/serial_core.c:104
     serial8250_tx_chars+0x495/0xaf0 drivers/tty/serial/8250/8250_port.c:1761
     serial8250_handle_irq.part.0+0x2a2/0x330 drivers/tty/serial/8250/8250_port.c:1834
     serial8250_handle_irq drivers/tty/serial/8250/8250_port.c:1820 [inline]
     serial8250_default_handle_irq+0xc0/0x150 drivers/tty/serial/8250/8250_port.c:1850
     serial8250_interrupt+0xf1/0x1a0 drivers/tty/serial/8250/8250_core.c:126
     __handle_irq_event_percpu+0x15d/0x970 kernel/irq/handle.c:149
     handle_irq_event_percpu+0x74/0x160 kernel/irq/handle.c:189
     handle_irq_event+0xa7/0x134 kernel/irq/handle.c:206
     handle_edge_irq+0x25e/0x8d0 kernel/irq/chip.c:830
     generic_handle_irq_desc include/linux/irqdesc.h:156 [inline]
     do_IRQ+0xde/0x280 arch/x86/kernel/irq.c:250
     common_interrupt+0xf/0xf arch/x86/entry/entry_64.S:607
     </IRQ>
    RIP: 0010:cpu_relax arch/x86/include/asm/processor.h:685 [inline]
    RIP: 0010:mutex_spin_on_owner+0x247/0x330 kernel/locking/mutex.c:579
    Code: c3 be 08 00 00 00 4c 89 e7 e8 e5 06 59 00 4c 89 e0 48 c1 e8 03 42 80 3c 38 00 0f 85 e1 00 00 00 49 8b 04 24 a8 01 75 96 f3 90 <e9> 2f fe ff ff 0f 0b e8 0d 19 09 00 84 c0 0f 85 ff fd ff ff 48 c7
    RSP: 0018:ffffc90001eafa20 EFLAGS: 00000246 ORIG_RAX: ffffffffffffffd7
    RAX: 0000000000000000 RBX: ffff88809fd9e0c0 RCX: 1ffffffff13266dd
    RDX: 0000000000000000 RSI: 0000000000000008 RDI: 0000000000000000
    RBP: ffffc90001eafa60 R08: 1ffff11013d22898 R09: ffffed1013d22899
    R10: ffffed1013d22898 R11: ffff88809e9144c7 R12: ffff8880a905e138
    R13: ffff88809e9144c0 R14: 0000000000000000 R15: dffffc0000000000
     mutex_optimistic_spin kernel/locking/mutex.c:673 [inline]
     __mutex_lock_common kernel/locking/mutex.c:962 [inline]
     __mutex_lock+0x32b/0x13c0 kernel/locking/mutex.c:1106
     mutex_lock_nested+0x16/0x20 kernel/locking/mutex.c:1121
     tty_lock+0xc7/0x130 drivers/tty/tty_mutex.c:19
     tty_release+0xb5/0xe90 drivers/tty/tty_io.c:1665
     __fput+0x2ff/0x890 fs/file_table.c:280
     ____fput+0x16/0x20 fs/file_table.c:313
     task_work_run+0x145/0x1c0 kernel/task_work.c:113
     exit_task_work include/linux/task_work.h:22 [inline]
     do_exit+0x8e7/0x2ef0 kernel/exit.c:797
     do_group_exit+0x135/0x360 kernel/exit.c:895
     __do_sys_exit_group kernel/exit.c:906 [inline]
     __se_sys_exit_group kernel/exit.c:904 [inline]
     __x64_sys_exit_group+0x44/0x50 kernel/exit.c:904
     do_syscall_64+0xfa/0x790 arch/x86/entry/common.c:294
     entry_SYSCALL_64_after_hwframe+0x49/0xbe
    RIP: 0033:0x43fef8
    Code: Bad RIP value.
    RSP: 002b:00007ffdb07d2338 EFLAGS: 00000246 ORIG_RAX: 00000000000000e7
    RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 000000000043fef8
    RDX: 0000000000000000 RSI: 000000000000003c RDI: 0000000000000000
    RBP: 00000000004bf730 R08: 00000000000000e7 R09: ffffffffffffffd0
    R10: 00000000004002c8 R11: 0000000000000246 R12: 0000000000000001
    R13: 00000000006d1180 R14: 0000000000000000 R15: 0000000000000000
    
    Fixes: 6e4e2f811bad ("6pack,mkiss: fix lock inconsistency")
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Reported-by: syzbot <syzkaller@googlegroups.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit c8c17adc7ea8f0ed28c20d49acf07a371acf1b5b
Author: Eric Dumazet <edumazet@google.com>
Date:   Thu Dec 12 10:32:13 2019 -0800

    6pack,mkiss: fix possible deadlock
    
    commit 5c9934b6767b16ba60be22ec3cbd4379ad64170d upstream.
    
    We got another syzbot report [1] that tells us we must use
    write_lock_irq()/write_unlock_irq() to avoid possible deadlock.
    
    [1]
    
    WARNING: inconsistent lock state
    5.5.0-rc1-syzkaller #0 Not tainted
    --------------------------------
    inconsistent {HARDIRQ-ON-W} -> {IN-HARDIRQ-R} usage.
    syz-executor826/9605 [HC1[1]:SC0[0]:HE0:SE1] takes:
    ffffffff8a128718 (disc_data_lock){+-..}, at: sp_get.isra.0+0x1d/0xf0 drivers/net/ppp/ppp_synctty.c:138
    {HARDIRQ-ON-W} state was registered at:
      lock_acquire+0x190/0x410 kernel/locking/lockdep.c:4485
      __raw_write_lock_bh include/linux/rwlock_api_smp.h:203 [inline]
      _raw_write_lock_bh+0x33/0x50 kernel/locking/spinlock.c:319
      sixpack_close+0x1d/0x250 drivers/net/hamradio/6pack.c:657
      tty_ldisc_close.isra.0+0x119/0x1a0 drivers/tty/tty_ldisc.c:489
      tty_set_ldisc+0x230/0x6b0 drivers/tty/tty_ldisc.c:585
      tiocsetd drivers/tty/tty_io.c:2337 [inline]
      tty_ioctl+0xe8d/0x14f0 drivers/tty/tty_io.c:2597
      vfs_ioctl fs/ioctl.c:47 [inline]
      file_ioctl fs/ioctl.c:545 [inline]
      do_vfs_ioctl+0x977/0x14e0 fs/ioctl.c:732
      ksys_ioctl+0xab/0xd0 fs/ioctl.c:749
      __do_sys_ioctl fs/ioctl.c:756 [inline]
      __se_sys_ioctl fs/ioctl.c:754 [inline]
      __x64_sys_ioctl+0x73/0xb0 fs/ioctl.c:754
      do_syscall_64+0xfa/0x790 arch/x86/entry/common.c:294
      entry_SYSCALL_64_after_hwframe+0x49/0xbe
    irq event stamp: 3946
    hardirqs last  enabled at (3945): [<ffffffff87c86e43>] __raw_spin_unlock_irq include/linux/spinlock_api_smp.h:168 [inline]
    hardirqs last  enabled at (3945): [<ffffffff87c86e43>] _raw_spin_unlock_irq+0x23/0x80 kernel/locking/spinlock.c:199
    hardirqs last disabled at (3946): [<ffffffff8100675f>] trace_hardirqs_off_thunk+0x1a/0x1c arch/x86/entry/thunk_64.S:42
    softirqs last  enabled at (2658): [<ffffffff86a8b4df>] spin_unlock_bh include/linux/spinlock.h:383 [inline]
    softirqs last  enabled at (2658): [<ffffffff86a8b4df>] clusterip_netdev_event+0x46f/0x670 net/ipv4/netfilter/ipt_CLUSTERIP.c:222
    softirqs last disabled at (2656): [<ffffffff86a8b22b>] spin_lock_bh include/linux/spinlock.h:343 [inline]
    softirqs last disabled at (2656): [<ffffffff86a8b22b>] clusterip_netdev_event+0x1bb/0x670 net/ipv4/netfilter/ipt_CLUSTERIP.c:196
    
    other info that might help us debug this:
     Possible unsafe locking scenario:
    
           CPU0
           ----
      lock(disc_data_lock);
      <Interrupt>
        lock(disc_data_lock);
    
     *** DEADLOCK ***
    
    5 locks held by syz-executor826/9605:
     #0: ffff8880a905e198 (&tty->legacy_mutex){+.+.}, at: tty_lock+0xc7/0x130 drivers/tty/tty_mutex.c:19
     #1: ffffffff899a56c0 (rcu_read_lock){....}, at: mutex_spin_on_owner+0x0/0x330 kernel/locking/mutex.c:413
     #2: ffff8880a496a2b0 (&(&i->lock)->rlock){-.-.}, at: spin_lock include/linux/spinlock.h:338 [inline]
     #2: ffff8880a496a2b0 (&(&i->lock)->rlock){-.-.}, at: serial8250_interrupt+0x2d/0x1a0 drivers/tty/serial/8250/8250_core.c:116
     #3: ffffffff8c104048 (&port_lock_key){-.-.}, at: serial8250_handle_irq.part.0+0x24/0x330 drivers/tty/serial/8250/8250_port.c:1823
     #4: ffff8880a905e090 (&tty->ldisc_sem){++++}, at: tty_ldisc_ref+0x22/0x90 drivers/tty/tty_ldisc.c:288
    
    stack backtrace:
    CPU: 1 PID: 9605 Comm: syz-executor826 Not tainted 5.5.0-rc1-syzkaller #0
    Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011
    Call Trace:
     <IRQ>
     __dump_stack lib/dump_stack.c:77 [inline]
     dump_stack+0x197/0x210 lib/dump_stack.c:118
     print_usage_bug.cold+0x327/0x378 kernel/locking/lockdep.c:3101
     valid_state kernel/locking/lockdep.c:3112 [inline]
     mark_lock_irq kernel/locking/lockdep.c:3309 [inline]
     mark_lock+0xbb4/0x1220 kernel/locking/lockdep.c:3666
     mark_usage kernel/locking/lockdep.c:3554 [inline]
     __lock_acquire+0x1e55/0x4a00 kernel/locking/lockdep.c:3909
     lock_acquire+0x190/0x410 kernel/locking/lockdep.c:4485
     __raw_read_lock include/linux/rwlock_api_smp.h:149 [inline]
     _raw_read_lock+0x32/0x50 kernel/locking/spinlock.c:223
     sp_get.isra.0+0x1d/0xf0 drivers/net/ppp/ppp_synctty.c:138
     sixpack_write_wakeup+0x25/0x340 drivers/net/hamradio/6pack.c:402
     tty_wakeup+0xe9/0x120 drivers/tty/tty_io.c:536
     tty_port_default_wakeup+0x2b/0x40 drivers/tty/tty_port.c:50
     tty_port_tty_wakeup+0x57/0x70 drivers/tty/tty_port.c:387
     uart_write_wakeup+0x46/0x70 drivers/tty/serial/serial_core.c:104
     serial8250_tx_chars+0x495/0xaf0 drivers/tty/serial/8250/8250_port.c:1761
     serial8250_handle_irq.part.0+0x2a2/0x330 drivers/tty/serial/8250/8250_port.c:1834
     serial8250_handle_irq drivers/tty/serial/8250/8250_port.c:1820 [inline]
     serial8250_default_handle_irq+0xc0/0x150 drivers/tty/serial/8250/8250_port.c:1850
     serial8250_interrupt+0xf1/0x1a0 drivers/tty/serial/8250/8250_core.c:126
     __handle_irq_event_percpu+0x15d/0x970 kernel/irq/handle.c:149
     handle_irq_event_percpu+0x74/0x160 kernel/irq/handle.c:189
     handle_irq_event+0xa7/0x134 kernel/irq/handle.c:206
     handle_edge_irq+0x25e/0x8d0 kernel/irq/chip.c:830
     generic_handle_irq_desc include/linux/irqdesc.h:156 [inline]
     do_IRQ+0xde/0x280 arch/x86/kernel/irq.c:250
     common_interrupt+0xf/0xf arch/x86/entry/entry_64.S:607
     </IRQ>
    RIP: 0010:cpu_relax arch/x86/include/asm/processor.h:685 [inline]
    RIP: 0010:mutex_spin_on_owner+0x247/0x330 kernel/locking/mutex.c:579
    Code: c3 be 08 00 00 00 4c 89 e7 e8 e5 06 59 00 4c 89 e0 48 c1 e8 03 42 80 3c 38 00 0f 85 e1 00 00 00 49 8b 04 24 a8 01 75 96 f3 90 <e9> 2f fe ff ff 0f 0b e8 0d 19 09 00 84 c0 0f 85 ff fd ff ff 48 c7
    RSP: 0018:ffffc90001eafa20 EFLAGS: 00000246 ORIG_RAX: ffffffffffffffd7
    RAX: 0000000000000000 RBX: ffff88809fd9e0c0 RCX: 1ffffffff13266dd
    RDX: 0000000000000000 RSI: 0000000000000008 RDI: 0000000000000000
    RBP: ffffc90001eafa60 R08: 1ffff11013d22898 R09: ffffed1013d22899
    R10: ffffed1013d22898 R11: ffff88809e9144c7 R12: ffff8880a905e138
    R13: ffff88809e9144c0 R14: 0000000000000000 R15: dffffc0000000000
     mutex_optimistic_spin kernel/locking/mutex.c:673 [inline]
     __mutex_lock_common kernel/locking/mutex.c:962 [inline]
     __mutex_lock+0x32b/0x13c0 kernel/locking/mutex.c:1106
     mutex_lock_nested+0x16/0x20 kernel/locking/mutex.c:1121
     tty_lock+0xc7/0x130 drivers/tty/tty_mutex.c:19
     tty_release+0xb5/0xe90 drivers/tty/tty_io.c:1665
     __fput+0x2ff/0x890 fs/file_table.c:280
     ____fput+0x16/0x20 fs/file_table.c:313
     task_work_run+0x145/0x1c0 kernel/task_work.c:113
     exit_task_work include/linux/task_work.h:22 [inline]
     do_exit+0x8e7/0x2ef0 kernel/exit.c:797
     do_group_exit+0x135/0x360 kernel/exit.c:895
     __do_sys_exit_group kernel/exit.c:906 [inline]
     __se_sys_exit_group kernel/exit.c:904 [inline]
     __x64_sys_exit_group+0x44/0x50 kernel/exit.c:904
     do_syscall_64+0xfa/0x790 arch/x86/entry/common.c:294
     entry_SYSCALL_64_after_hwframe+0x49/0xbe
    RIP: 0033:0x43fef8
    Code: Bad RIP value.
    RSP: 002b:00007ffdb07d2338 EFLAGS: 00000246 ORIG_RAX: 00000000000000e7
    RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 000000000043fef8
    RDX: 0000000000000000 RSI: 000000000000003c RDI: 0000000000000000
    RBP: 00000000004bf730 R08: 00000000000000e7 R09: ffffffffffffffd0
    R10: 00000000004002c8 R11: 0000000000000246 R12: 0000000000000001
    R13: 00000000006d1180 R14: 0000000000000000 R15: 0000000000000000
    
    Fixes: 6e4e2f811bad ("6pack,mkiss: fix lock inconsistency")
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Reported-by: syzbot <syzkaller@googlegroups.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 521b00fe8fafaf444f895882b3a2b3f912133fc8
Author: Eric Dumazet <edumazet@google.com>
Date:   Thu Dec 12 10:32:13 2019 -0800

    6pack,mkiss: fix possible deadlock
    
    commit 5c9934b6767b16ba60be22ec3cbd4379ad64170d upstream.
    
    We got another syzbot report [1] that tells us we must use
    write_lock_irq()/write_unlock_irq() to avoid possible deadlock.
    
    [1]
    
    WARNING: inconsistent lock state
    5.5.0-rc1-syzkaller #0 Not tainted
    --------------------------------
    inconsistent {HARDIRQ-ON-W} -> {IN-HARDIRQ-R} usage.
    syz-executor826/9605 [HC1[1]:SC0[0]:HE0:SE1] takes:
    ffffffff8a128718 (disc_data_lock){+-..}, at: sp_get.isra.0+0x1d/0xf0 drivers/net/ppp/ppp_synctty.c:138
    {HARDIRQ-ON-W} state was registered at:
      lock_acquire+0x190/0x410 kernel/locking/lockdep.c:4485
      __raw_write_lock_bh include/linux/rwlock_api_smp.h:203 [inline]
      _raw_write_lock_bh+0x33/0x50 kernel/locking/spinlock.c:319
      sixpack_close+0x1d/0x250 drivers/net/hamradio/6pack.c:657
      tty_ldisc_close.isra.0+0x119/0x1a0 drivers/tty/tty_ldisc.c:489
      tty_set_ldisc+0x230/0x6b0 drivers/tty/tty_ldisc.c:585
      tiocsetd drivers/tty/tty_io.c:2337 [inline]
      tty_ioctl+0xe8d/0x14f0 drivers/tty/tty_io.c:2597
      vfs_ioctl fs/ioctl.c:47 [inline]
      file_ioctl fs/ioctl.c:545 [inline]
      do_vfs_ioctl+0x977/0x14e0 fs/ioctl.c:732
      ksys_ioctl+0xab/0xd0 fs/ioctl.c:749
      __do_sys_ioctl fs/ioctl.c:756 [inline]
      __se_sys_ioctl fs/ioctl.c:754 [inline]
      __x64_sys_ioctl+0x73/0xb0 fs/ioctl.c:754
      do_syscall_64+0xfa/0x790 arch/x86/entry/common.c:294
      entry_SYSCALL_64_after_hwframe+0x49/0xbe
    irq event stamp: 3946
    hardirqs last  enabled at (3945): [<ffffffff87c86e43>] __raw_spin_unlock_irq include/linux/spinlock_api_smp.h:168 [inline]
    hardirqs last  enabled at (3945): [<ffffffff87c86e43>] _raw_spin_unlock_irq+0x23/0x80 kernel/locking/spinlock.c:199
    hardirqs last disabled at (3946): [<ffffffff8100675f>] trace_hardirqs_off_thunk+0x1a/0x1c arch/x86/entry/thunk_64.S:42
    softirqs last  enabled at (2658): [<ffffffff86a8b4df>] spin_unlock_bh include/linux/spinlock.h:383 [inline]
    softirqs last  enabled at (2658): [<ffffffff86a8b4df>] clusterip_netdev_event+0x46f/0x670 net/ipv4/netfilter/ipt_CLUSTERIP.c:222
    softirqs last disabled at (2656): [<ffffffff86a8b22b>] spin_lock_bh include/linux/spinlock.h:343 [inline]
    softirqs last disabled at (2656): [<ffffffff86a8b22b>] clusterip_netdev_event+0x1bb/0x670 net/ipv4/netfilter/ipt_CLUSTERIP.c:196
    
    other info that might help us debug this:
     Possible unsafe locking scenario:
    
           CPU0
           ----
      lock(disc_data_lock);
      <Interrupt>
        lock(disc_data_lock);
    
     *** DEADLOCK ***
    
    5 locks held by syz-executor826/9605:
     #0: ffff8880a905e198 (&tty->legacy_mutex){+.+.}, at: tty_lock+0xc7/0x130 drivers/tty/tty_mutex.c:19
     #1: ffffffff899a56c0 (rcu_read_lock){....}, at: mutex_spin_on_owner+0x0/0x330 kernel/locking/mutex.c:413
     #2: ffff8880a496a2b0 (&(&i->lock)->rlock){-.-.}, at: spin_lock include/linux/spinlock.h:338 [inline]
     #2: ffff8880a496a2b0 (&(&i->lock)->rlock){-.-.}, at: serial8250_interrupt+0x2d/0x1a0 drivers/tty/serial/8250/8250_core.c:116
     #3: ffffffff8c104048 (&port_lock_key){-.-.}, at: serial8250_handle_irq.part.0+0x24/0x330 drivers/tty/serial/8250/8250_port.c:1823
     #4: ffff8880a905e090 (&tty->ldisc_sem){++++}, at: tty_ldisc_ref+0x22/0x90 drivers/tty/tty_ldisc.c:288
    
    stack backtrace:
    CPU: 1 PID: 9605 Comm: syz-executor826 Not tainted 5.5.0-rc1-syzkaller #0
    Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011
    Call Trace:
     <IRQ>
     __dump_stack lib/dump_stack.c:77 [inline]
     dump_stack+0x197/0x210 lib/dump_stack.c:118
     print_usage_bug.cold+0x327/0x378 kernel/locking/lockdep.c:3101
     valid_state kernel/locking/lockdep.c:3112 [inline]
     mark_lock_irq kernel/locking/lockdep.c:3309 [inline]
     mark_lock+0xbb4/0x1220 kernel/locking/lockdep.c:3666
     mark_usage kernel/locking/lockdep.c:3554 [inline]
     __lock_acquire+0x1e55/0x4a00 kernel/locking/lockdep.c:3909
     lock_acquire+0x190/0x410 kernel/locking/lockdep.c:4485
     __raw_read_lock include/linux/rwlock_api_smp.h:149 [inline]
     _raw_read_lock+0x32/0x50 kernel/locking/spinlock.c:223
     sp_get.isra.0+0x1d/0xf0 drivers/net/ppp/ppp_synctty.c:138
     sixpack_write_wakeup+0x25/0x340 drivers/net/hamradio/6pack.c:402
     tty_wakeup+0xe9/0x120 drivers/tty/tty_io.c:536
     tty_port_default_wakeup+0x2b/0x40 drivers/tty/tty_port.c:50
     tty_port_tty_wakeup+0x57/0x70 drivers/tty/tty_port.c:387
     uart_write_wakeup+0x46/0x70 drivers/tty/serial/serial_core.c:104
     serial8250_tx_chars+0x495/0xaf0 drivers/tty/serial/8250/8250_port.c:1761
     serial8250_handle_irq.part.0+0x2a2/0x330 drivers/tty/serial/8250/8250_port.c:1834
     serial8250_handle_irq drivers/tty/serial/8250/8250_port.c:1820 [inline]
     serial8250_default_handle_irq+0xc0/0x150 drivers/tty/serial/8250/8250_port.c:1850
     serial8250_interrupt+0xf1/0x1a0 drivers/tty/serial/8250/8250_core.c:126
     __handle_irq_event_percpu+0x15d/0x970 kernel/irq/handle.c:149
     handle_irq_event_percpu+0x74/0x160 kernel/irq/handle.c:189
     handle_irq_event+0xa7/0x134 kernel/irq/handle.c:206
     handle_edge_irq+0x25e/0x8d0 kernel/irq/chip.c:830
     generic_handle_irq_desc include/linux/irqdesc.h:156 [inline]
     do_IRQ+0xde/0x280 arch/x86/kernel/irq.c:250
     common_interrupt+0xf/0xf arch/x86/entry/entry_64.S:607
     </IRQ>
    RIP: 0010:cpu_relax arch/x86/include/asm/processor.h:685 [inline]
    RIP: 0010:mutex_spin_on_owner+0x247/0x330 kernel/locking/mutex.c:579
    Code: c3 be 08 00 00 00 4c 89 e7 e8 e5 06 59 00 4c 89 e0 48 c1 e8 03 42 80 3c 38 00 0f 85 e1 00 00 00 49 8b 04 24 a8 01 75 96 f3 90 <e9> 2f fe ff ff 0f 0b e8 0d 19 09 00 84 c0 0f 85 ff fd ff ff 48 c7
    RSP: 0018:ffffc90001eafa20 EFLAGS: 00000246 ORIG_RAX: ffffffffffffffd7
    RAX: 0000000000000000 RBX: ffff88809fd9e0c0 RCX: 1ffffffff13266dd
    RDX: 0000000000000000 RSI: 0000000000000008 RDI: 0000000000000000
    RBP: ffffc90001eafa60 R08: 1ffff11013d22898 R09: ffffed1013d22899
    R10: ffffed1013d22898 R11: ffff88809e9144c7 R12: ffff8880a905e138
    R13: ffff88809e9144c0 R14: 0000000000000000 R15: dffffc0000000000
     mutex_optimistic_spin kernel/locking/mutex.c:673 [inline]
     __mutex_lock_common kernel/locking/mutex.c:962 [inline]
     __mutex_lock+0x32b/0x13c0 kernel/locking/mutex.c:1106
     mutex_lock_nested+0x16/0x20 kernel/locking/mutex.c:1121
     tty_lock+0xc7/0x130 drivers/tty/tty_mutex.c:19
     tty_release+0xb5/0xe90 drivers/tty/tty_io.c:1665
     __fput+0x2ff/0x890 fs/file_table.c:280
     ____fput+0x16/0x20 fs/file_table.c:313
     task_work_run+0x145/0x1c0 kernel/task_work.c:113
     exit_task_work include/linux/task_work.h:22 [inline]
     do_exit+0x8e7/0x2ef0 kernel/exit.c:797
     do_group_exit+0x135/0x360 kernel/exit.c:895
     __do_sys_exit_group kernel/exit.c:906 [inline]
     __se_sys_exit_group kernel/exit.c:904 [inline]
     __x64_sys_exit_group+0x44/0x50 kernel/exit.c:904
     do_syscall_64+0xfa/0x790 arch/x86/entry/common.c:294
     entry_SYSCALL_64_after_hwframe+0x49/0xbe
    RIP: 0033:0x43fef8
    Code: Bad RIP value.
    RSP: 002b:00007ffdb07d2338 EFLAGS: 00000246 ORIG_RAX: 00000000000000e7
    RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 000000000043fef8
    RDX: 0000000000000000 RSI: 000000000000003c RDI: 0000000000000000
    RBP: 00000000004bf730 R08: 00000000000000e7 R09: ffffffffffffffd0
    R10: 00000000004002c8 R11: 0000000000000246 R12: 0000000000000001
    R13: 00000000006d1180 R14: 0000000000000000 R15: 0000000000000000
    
    Fixes: 6e4e2f811bad ("6pack,mkiss: fix lock inconsistency")
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Reported-by: syzbot <syzkaller@googlegroups.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit de7999afedff02c6631feab3ea726a0e8f8c3d40
Author: Filipe Manana <fdmanana@suse.com>
Date:   Wed Dec 11 09:01:40 2019 +0000

    Btrfs: fix infinite loop during nocow writeback due to race
    
    When starting writeback for a range that covers part of a preallocated
    extent, due to a race with writeback for another range that also covers
    another part of the same preallocated extent, we can end up in an infinite
    loop.
    
    Consider the following example where for inode 280 we have two dirty
    ranges:
    
      range A, from 294912 to 303103, 8192 bytes
      range B, from 348160 to 438271, 90112 bytes
    
    and we have the following file extent item layout for our inode:
    
      leaf 38895616 gen 24544 total ptrs 29 free space 13820 owner 5
          (...)
          item 27 key (280 108 200704) itemoff 14598 itemsize 53
              extent data disk bytenr 0 nr 0 type 1 (regular)
              extent data offset 0 nr 94208 ram 94208
          item 28 key (280 108 294912) itemoff 14545 itemsize 53
              extent data disk bytenr 10433052672 nr 81920 type 2 (prealloc)
              extent data offset 0 nr 81920 ram 81920
    
    Then the following happens:
    
    1) Writeback starts for range B (from 348160 to 438271), execution of
       run_delalloc_nocow() starts;
    
    2) The first iteration of run_delalloc_nocow()'s whil loop leaves us at
       the extent item at slot 28, pointing to the prealloc extent item
       covering the range from 294912 to 376831. This extent covers part of
       our range;
    
    3) An ordered extent is created against that extent, covering the file
       range from 348160 to 376831 (28672 bytes);
    
    4) We adjust 'cur_offset' to 376832 and move on to the next iteration of
       the while loop;
    
    5) The call to btrfs_lookup_file_extent() leaves us at the same leaf,
       pointing to slot 29, 1 slot after the last item (the extent item
       we processed in the previous iteration);
    
    6) Because we are a slot beyond the last item, we call btrfs_next_leaf(),
       which releases the search path before doing a another search for the
       last key of the leaf (280 108 294912);
    
    7) Right after btrfs_next_leaf() released the path, and before it did
       another search for the last key of the leaf, writeback for the range
       A (from 294912 to 303103) completes (it was previously started at
       some point);
    
    8) Upon completion of the ordered extent for range A, the prealloc extent
       we previously found got split into two extent items, one covering the
       range from 294912 to 303103 (8192 bytes), with a type of regular extent
       (and no longer prealloc) and another covering the range from 303104 to
       376831 (73728 bytes), with a type of prealloc and an offset of 8192
       bytes. So our leaf now has the following layout:
    
         leaf 38895616 gen 24544 total ptrs 31 free space 13664 owner 5
             (...)
             item 27 key (280 108 200704) itemoff 14598 itemsize 53
                 extent data disk bytenr 0 nr 0 type 1
                 extent data offset 0 nr 8192 ram 94208
             item 28 key (280 108 208896) itemoff 14545 itemsize 53
                 extent data disk bytenr 10433142784 nr 86016 type 1
                 extent data offset 0 nr 86016 ram 86016
             item 29 key (280 108 294912) itemoff 14492 itemsize 53
                 extent data disk bytenr 10433052672 nr 81920 type 1
                 extent data offset 0 nr 8192 ram 81920
             item 30 key (280 108 303104) itemoff 14439 itemsize 53
                 extent data disk bytenr 10433052672 nr 81920 type 2
                 extent data offset 8192 nr 73728 ram 81920
    
    9) After btrfs_next_leaf() returns, we have our path pointing to that same
       leaf and at slot 30, since it has a key we didn't have before and it's
       the first key greater then the key that was previously the last key of
       the leaf (key (280 108 294912));
    
    10) The extent item at slot 30 covers the range from 303104 to 376831
        which is in our target range, so we process it, despite having already
        created an ordered extent against this extent for the file range from
        348160 to 376831. This is because we skip to the next extent item only
        if its end is less than or equals to the start of our delalloc range,
        and not less than or equals to the current offset ('cur_offset');
    
    11) As a result we compute 'num_bytes' as:
    
        num_bytes = min(end + 1, extent_end) - cur_offset;
                  = min(438271 + 1, 376832) - 376832 = 0
    
    12) We then call create_io_em() for a 0 bytes range starting at offset
        376832;
    
    13) Then create_io_em() enters an infinite loop because its calls to
        btrfs_drop_extent_cache() do nothing due to the 0 length range
        passed to it. So no existing extent maps that cover the offset
        376832 get removed, and therefore calls to add_extent_mapping()
        return -EEXIST, resulting in an infinite loop. This loop from
        create_io_em() is the following:
    
        do {
            btrfs_drop_extent_cache(BTRFS_I(inode), em->start,
                                    em->start + em->len - 1, 0);
            write_lock(&em_tree->lock);
            ret = add_extent_mapping(em_tree, em, 1);
            write_unlock(&em_tree->lock);
            /*
             * The caller has taken lock_extent(), who could race with us
             * to add em?
             */
        } while (ret == -EEXIST);
    
    Also, each call to btrfs_drop_extent_cache() triggers a warning because
    the start offset passed to it (376832) is smaller then the end offset
    (376832 - 1) passed to it by -1, due to the 0 length:
    
      [258532.052621] ------------[ cut here ]------------
      [258532.052643] WARNING: CPU: 0 PID: 9987 at fs/btrfs/file.c:602 btrfs_drop_extent_cache+0x3f4/0x590 [btrfs]
      (...)
      [258532.052672] CPU: 0 PID: 9987 Comm: fsx Tainted: G        W         5.4.0-rc7-btrfs-next-64 #1
      [258532.052673] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.12.0-0-ga698c8995f-prebuilt.qemu.org 04/01/2014
      [258532.052691] RIP: 0010:btrfs_drop_extent_cache+0x3f4/0x590 [btrfs]
      (...)
      [258532.052695] RSP: 0018:ffffb4be0153f860 EFLAGS: 00010287
      [258532.052700] RAX: ffff975b445ee360 RBX: ffff975b44eb3e08 RCX: 0000000000000000
      [258532.052700] RDX: 0000000000038fff RSI: 0000000000039000 RDI: ffff975b445ee308
      [258532.052700] RBP: 0000000000038fff R08: 0000000000000000 R09: 0000000000000001
      [258532.052701] R10: ffff975b513c5c10 R11: 00000000e3c0cfa9 R12: 0000000000039000
      [258532.052703] R13: ffff975b445ee360 R14: 00000000ffffffef R15: ffff975b445ee308
      [258532.052705] FS:  00007f86a821de80(0000) GS:ffff975b76a00000(0000) knlGS:0000000000000000
      [258532.052707] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
      [258532.052708] CR2: 00007fdacf0f3ab4 CR3: 00000001f9d26002 CR4: 00000000003606f0
      [258532.052712] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
      [258532.052717] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
      [258532.052717] Call Trace:
      [258532.052718]  ? preempt_schedule_common+0x32/0x70
      [258532.052722]  ? ___preempt_schedule+0x16/0x20
      [258532.052741]  create_io_em+0xff/0x180 [btrfs]
      [258532.052767]  run_delalloc_nocow+0x942/0xb10 [btrfs]
      [258532.052791]  btrfs_run_delalloc_range+0x30b/0x520 [btrfs]
      [258532.052812]  ? find_lock_delalloc_range+0x221/0x250 [btrfs]
      [258532.052834]  writepage_delalloc+0xe4/0x140 [btrfs]
      [258532.052855]  __extent_writepage+0x110/0x4e0 [btrfs]
      [258532.052876]  extent_write_cache_pages+0x21c/0x480 [btrfs]
      [258532.052906]  extent_writepages+0x52/0xb0 [btrfs]
      [258532.052911]  do_writepages+0x23/0x80
      [258532.052915]  __filemap_fdatawrite_range+0xd2/0x110
      [258532.052938]  btrfs_fdatawrite_range+0x1b/0x50 [btrfs]
      [258532.052954]  start_ordered_ops+0x57/0xa0 [btrfs]
      [258532.052973]  ? btrfs_sync_file+0x225/0x490 [btrfs]
      [258532.052988]  btrfs_sync_file+0x225/0x490 [btrfs]
      [258532.052997]  __x64_sys_msync+0x199/0x200
      [258532.053004]  do_syscall_64+0x5c/0x250
      [258532.053007]  entry_SYSCALL_64_after_hwframe+0x49/0xbe
      [258532.053010] RIP: 0033:0x7f86a7dfd760
      (...)
      [258532.053014] RSP: 002b:00007ffd99af0368 EFLAGS: 00000246 ORIG_RAX: 000000000000001a
      [258532.053016] RAX: ffffffffffffffda RBX: 0000000000000ec9 RCX: 00007f86a7dfd760
      [258532.053017] RDX: 0000000000000004 RSI: 000000000000836c RDI: 00007f86a8221000
      [258532.053019] RBP: 0000000000021ec9 R08: 0000000000000003 R09: 00007f86a812037c
      [258532.053020] R10: 0000000000000001 R11: 0000000000000246 R12: 00000000000074a3
      [258532.053021] R13: 00007f86a8221000 R14: 000000000000836c R15: 0000000000000001
      [258532.053032] irq event stamp: 1653450494
      [258532.053035] hardirqs last  enabled at (1653450493): [<ffffffff9dec69f9>] _raw_spin_unlock_irq+0x29/0x50
      [258532.053037] hardirqs last disabled at (1653450494): [<ffffffff9d4048ea>] trace_hardirqs_off_thunk+0x1a/0x20
      [258532.053039] softirqs last  enabled at (1653449852): [<ffffffff9e200466>] __do_softirq+0x466/0x6bd
      [258532.053042] softirqs last disabled at (1653449845): [<ffffffff9d4c8a0c>] irq_exit+0xec/0x120
      [258532.053043] ---[ end trace 8476fce13d9ce20a ]---
    
    Which results in flooding dmesg/syslog since btrfs_drop_extent_cache()
    uses WARN_ON() and not WARN_ON_ONCE().
    
    So fix this issue by changing run_delalloc_nocow()'s loop to move to the
    next extent item when the current extent item ends at at offset less than
    or equals to the current offset instead of the start offset.
    
    Fixes: 80ff385665b7fc ("Btrfs: update nodatacow code v2")
    CC: stable@vger.kernel.org # 4.4+
    Reviewed-by: Josef Bacik <josef@toxicpanda.com>
    Signed-off-by: Filipe Manana <fdmanana@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

commit 5c9934b6767b16ba60be22ec3cbd4379ad64170d
Author: Eric Dumazet <edumazet@google.com>
Date:   Thu Dec 12 10:32:13 2019 -0800

    6pack,mkiss: fix possible deadlock
    
    We got another syzbot report [1] that tells us we must use
    write_lock_irq()/write_unlock_irq() to avoid possible deadlock.
    
    [1]
    
    WARNING: inconsistent lock state
    5.5.0-rc1-syzkaller #0 Not tainted
    --------------------------------
    inconsistent {HARDIRQ-ON-W} -> {IN-HARDIRQ-R} usage.
    syz-executor826/9605 [HC1[1]:SC0[0]:HE0:SE1] takes:
    ffffffff8a128718 (disc_data_lock){+-..}, at: sp_get.isra.0+0x1d/0xf0 drivers/net/ppp/ppp_synctty.c:138
    {HARDIRQ-ON-W} state was registered at:
      lock_acquire+0x190/0x410 kernel/locking/lockdep.c:4485
      __raw_write_lock_bh include/linux/rwlock_api_smp.h:203 [inline]
      _raw_write_lock_bh+0x33/0x50 kernel/locking/spinlock.c:319
      sixpack_close+0x1d/0x250 drivers/net/hamradio/6pack.c:657
      tty_ldisc_close.isra.0+0x119/0x1a0 drivers/tty/tty_ldisc.c:489
      tty_set_ldisc+0x230/0x6b0 drivers/tty/tty_ldisc.c:585
      tiocsetd drivers/tty/tty_io.c:2337 [inline]
      tty_ioctl+0xe8d/0x14f0 drivers/tty/tty_io.c:2597
      vfs_ioctl fs/ioctl.c:47 [inline]
      file_ioctl fs/ioctl.c:545 [inline]
      do_vfs_ioctl+0x977/0x14e0 fs/ioctl.c:732
      ksys_ioctl+0xab/0xd0 fs/ioctl.c:749
      __do_sys_ioctl fs/ioctl.c:756 [inline]
      __se_sys_ioctl fs/ioctl.c:754 [inline]
      __x64_sys_ioctl+0x73/0xb0 fs/ioctl.c:754
      do_syscall_64+0xfa/0x790 arch/x86/entry/common.c:294
      entry_SYSCALL_64_after_hwframe+0x49/0xbe
    irq event stamp: 3946
    hardirqs last  enabled at (3945): [<ffffffff87c86e43>] __raw_spin_unlock_irq include/linux/spinlock_api_smp.h:168 [inline]
    hardirqs last  enabled at (3945): [<ffffffff87c86e43>] _raw_spin_unlock_irq+0x23/0x80 kernel/locking/spinlock.c:199
    hardirqs last disabled at (3946): [<ffffffff8100675f>] trace_hardirqs_off_thunk+0x1a/0x1c arch/x86/entry/thunk_64.S:42
    softirqs last  enabled at (2658): [<ffffffff86a8b4df>] spin_unlock_bh include/linux/spinlock.h:383 [inline]
    softirqs last  enabled at (2658): [<ffffffff86a8b4df>] clusterip_netdev_event+0x46f/0x670 net/ipv4/netfilter/ipt_CLUSTERIP.c:222
    softirqs last disabled at (2656): [<ffffffff86a8b22b>] spin_lock_bh include/linux/spinlock.h:343 [inline]
    softirqs last disabled at (2656): [<ffffffff86a8b22b>] clusterip_netdev_event+0x1bb/0x670 net/ipv4/netfilter/ipt_CLUSTERIP.c:196
    
    other info that might help us debug this:
     Possible unsafe locking scenario:
    
           CPU0
           ----
      lock(disc_data_lock);
      <Interrupt>
        lock(disc_data_lock);
    
     *** DEADLOCK ***
    
    5 locks held by syz-executor826/9605:
     #0: ffff8880a905e198 (&tty->legacy_mutex){+.+.}, at: tty_lock+0xc7/0x130 drivers/tty/tty_mutex.c:19
     #1: ffffffff899a56c0 (rcu_read_lock){....}, at: mutex_spin_on_owner+0x0/0x330 kernel/locking/mutex.c:413
     #2: ffff8880a496a2b0 (&(&i->lock)->rlock){-.-.}, at: spin_lock include/linux/spinlock.h:338 [inline]
     #2: ffff8880a496a2b0 (&(&i->lock)->rlock){-.-.}, at: serial8250_interrupt+0x2d/0x1a0 drivers/tty/serial/8250/8250_core.c:116
     #3: ffffffff8c104048 (&port_lock_key){-.-.}, at: serial8250_handle_irq.part.0+0x24/0x330 drivers/tty/serial/8250/8250_port.c:1823
     #4: ffff8880a905e090 (&tty->ldisc_sem){++++}, at: tty_ldisc_ref+0x22/0x90 drivers/tty/tty_ldisc.c:288
    
    stack backtrace:
    CPU: 1 PID: 9605 Comm: syz-executor826 Not tainted 5.5.0-rc1-syzkaller #0
    Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011
    Call Trace:
     <IRQ>
     __dump_stack lib/dump_stack.c:77 [inline]
     dump_stack+0x197/0x210 lib/dump_stack.c:118
     print_usage_bug.cold+0x327/0x378 kernel/locking/lockdep.c:3101
     valid_state kernel/locking/lockdep.c:3112 [inline]
     mark_lock_irq kernel/locking/lockdep.c:3309 [inline]
     mark_lock+0xbb4/0x1220 kernel/locking/lockdep.c:3666
     mark_usage kernel/locking/lockdep.c:3554 [inline]
     __lock_acquire+0x1e55/0x4a00 kernel/locking/lockdep.c:3909
     lock_acquire+0x190/0x410 kernel/locking/lockdep.c:4485
     __raw_read_lock include/linux/rwlock_api_smp.h:149 [inline]
     _raw_read_lock+0x32/0x50 kernel/locking/spinlock.c:223
     sp_get.isra.0+0x1d/0xf0 drivers/net/ppp/ppp_synctty.c:138
     sixpack_write_wakeup+0x25/0x340 drivers/net/hamradio/6pack.c:402
     tty_wakeup+0xe9/0x120 drivers/tty/tty_io.c:536
     tty_port_default_wakeup+0x2b/0x40 drivers/tty/tty_port.c:50
     tty_port_tty_wakeup+0x57/0x70 drivers/tty/tty_port.c:387
     uart_write_wakeup+0x46/0x70 drivers/tty/serial/serial_core.c:104
     serial8250_tx_chars+0x495/0xaf0 drivers/tty/serial/8250/8250_port.c:1761
     serial8250_handle_irq.part.0+0x2a2/0x330 drivers/tty/serial/8250/8250_port.c:1834
     serial8250_handle_irq drivers/tty/serial/8250/8250_port.c:1820 [inline]
     serial8250_default_handle_irq+0xc0/0x150 drivers/tty/serial/8250/8250_port.c:1850
     serial8250_interrupt+0xf1/0x1a0 drivers/tty/serial/8250/8250_core.c:126
     __handle_irq_event_percpu+0x15d/0x970 kernel/irq/handle.c:149
     handle_irq_event_percpu+0x74/0x160 kernel/irq/handle.c:189
     handle_irq_event+0xa7/0x134 kernel/irq/handle.c:206
     handle_edge_irq+0x25e/0x8d0 kernel/irq/chip.c:830
     generic_handle_irq_desc include/linux/irqdesc.h:156 [inline]
     do_IRQ+0xde/0x280 arch/x86/kernel/irq.c:250
     common_interrupt+0xf/0xf arch/x86/entry/entry_64.S:607
     </IRQ>
    RIP: 0010:cpu_relax arch/x86/include/asm/processor.h:685 [inline]
    RIP: 0010:mutex_spin_on_owner+0x247/0x330 kernel/locking/mutex.c:579
    Code: c3 be 08 00 00 00 4c 89 e7 e8 e5 06 59 00 4c 89 e0 48 c1 e8 03 42 80 3c 38 00 0f 85 e1 00 00 00 49 8b 04 24 a8 01 75 96 f3 90 <e9> 2f fe ff ff 0f 0b e8 0d 19 09 00 84 c0 0f 85 ff fd ff ff 48 c7
    RSP: 0018:ffffc90001eafa20 EFLAGS: 00000246 ORIG_RAX: ffffffffffffffd7
    RAX: 0000000000000000 RBX: ffff88809fd9e0c0 RCX: 1ffffffff13266dd
    RDX: 0000000000000000 RSI: 0000000000000008 RDI: 0000000000000000
    RBP: ffffc90001eafa60 R08: 1ffff11013d22898 R09: ffffed1013d22899
    R10: ffffed1013d22898 R11: ffff88809e9144c7 R12: ffff8880a905e138
    R13: ffff88809e9144c0 R14: 0000000000000000 R15: dffffc0000000000
     mutex_optimistic_spin kernel/locking/mutex.c:673 [inline]
     __mutex_lock_common kernel/locking/mutex.c:962 [inline]
     __mutex_lock+0x32b/0x13c0 kernel/locking/mutex.c:1106
     mutex_lock_nested+0x16/0x20 kernel/locking/mutex.c:1121
     tty_lock+0xc7/0x130 drivers/tty/tty_mutex.c:19
     tty_release+0xb5/0xe90 drivers/tty/tty_io.c:1665
     __fput+0x2ff/0x890 fs/file_table.c:280
     ____fput+0x16/0x20 fs/file_table.c:313
     task_work_run+0x145/0x1c0 kernel/task_work.c:113
     exit_task_work include/linux/task_work.h:22 [inline]
     do_exit+0x8e7/0x2ef0 kernel/exit.c:797
     do_group_exit+0x135/0x360 kernel/exit.c:895
     __do_sys_exit_group kernel/exit.c:906 [inline]
     __se_sys_exit_group kernel/exit.c:904 [inline]
     __x64_sys_exit_group+0x44/0x50 kernel/exit.c:904
     do_syscall_64+0xfa/0x790 arch/x86/entry/common.c:294
     entry_SYSCALL_64_after_hwframe+0x49/0xbe
    RIP: 0033:0x43fef8
    Code: Bad RIP value.
    RSP: 002b:00007ffdb07d2338 EFLAGS: 00000246 ORIG_RAX: 00000000000000e7
    RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 000000000043fef8
    RDX: 0000000000000000 RSI: 000000000000003c RDI: 0000000000000000
    RBP: 00000000004bf730 R08: 00000000000000e7 R09: ffffffffffffffd0
    R10: 00000000004002c8 R11: 0000000000000246 R12: 0000000000000001
    R13: 00000000006d1180 R14: 0000000000000000 R15: 0000000000000000
    
    Fixes: 6e4e2f811bad ("6pack,mkiss: fix lock inconsistency")
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Reported-by: syzbot <syzkaller@googlegroups.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>

commit 7dee607ed0e04500459db53001d8e02f8831f084
Author: Parav Pandit <parav@mellanox.com>
Date:   Wed Sep 18 18:50:32 2019 -0500

    net/mlx5: Support lockless FTE read lookups
    
    During connection tracking offloads with high number of connections,
    (40K connections per second), flow table group lock contention is
    observed.
    To improve the performance by reducing lock contention, lockless
    FTE read lookup is performed as described below.
    
    Each flow table entry is refcounted.
    Flow table entry is removed when refcount drops to zero.
    rhash table allows rcu protected lookup.
    Each hash table entry insertion and removal is write lock protected.
    
    Hence, it is possible to perform lockless lookup in rhash table using
    following scheme.
    
    (a) Guard FTE entry lookup per group using rcu read lock.
    (b) Before freeing the FTE entry, wait for all readers to finish
    accessing the FTE.
    
    Below example of one reader and write in parallel racing, shows
    protection in effect with rcu lock.
    
    lookup_fte_locked()
      rcu_read_lock();
      search_hash_table()
                                      existing_flow_group_write_lock();
                                      tree_put_node(fte)
                                        drop_ref_cnt(fte)
                                        del_sw_fte(fte)
                                        del_hash_table_entry();
                                        call_rcu();
                                      existing_flow_group_write_unlock();
      get_ref_cnt(fte) fails
      rcu_read_unlock();
                                      rcu grace period();
                                        [..]
                                        kmem_cache_free(fte);
    
    Signed-off-by: Parav Pandit <parav@mellanox.com>
    Reviewed-by: Mark Bloch <markb@mellanox.com>
    Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>

commit 3cddd3866be7e3c5f05ea0b8eda435b75320160d
Author: Coly Li <colyli@suse.de>
Date:   Thu Apr 25 00:48:33 2019 +0800

    bcache: never set KEY_PTRS of journal key to 0 in journal_reclaim()
    
    commit 1bee2addc0c8470c8aaa65ef0599eeae96dd88bc upstream.
    
    In journal_reclaim() ja->cur_idx of each cache will be update to
    reclaim available journal buckets. Variable 'int n' is used to count how
    many cache is successfully reclaimed, then n is set to c->journal.key
    by SET_KEY_PTRS(). Later in journal_write_unlocked(), a for_each_cache()
    loop will write the jset data onto each cache.
    
    The problem is, if all jouranl buckets on each cache is full, the
    following code in journal_reclaim(),
    
    529 for_each_cache(ca, c, iter) {
    530       struct journal_device *ja = &ca->journal;
    531       unsigned int next = (ja->cur_idx + 1) % ca->sb.njournal_buckets;
    532
    533       /* No space available on this device */
    534       if (next == ja->discard_idx)
    535               continue;
    536
    537       ja->cur_idx = next;
    538       k->ptr[n++] = MAKE_PTR(0,
    539                         bucket_to_sector(c, ca->sb.d[ja->cur_idx]),
    540                         ca->sb.nr_this_dev);
    541 }
    542
    543 bkey_init(k);
    544 SET_KEY_PTRS(k, n);
    
    If there is no available bucket to reclaim, the if() condition at line
    534 will always true, and n remains 0. Then at line 544, SET_KEY_PTRS()
    will set KEY_PTRS field of c->journal.key to 0.
    
    Setting KEY_PTRS field of c->journal.key to 0 is wrong. Because in
    journal_write_unlocked() the journal data is written in following loop,
    
    649     for (i = 0; i < KEY_PTRS(k); i++) {
    650-671         submit journal data to cache device
    672     }
    
    If KEY_PTRS field is set to 0 in jouranl_reclaim(), the journal data
    won't be written to cache device here. If system crahed or rebooted
    before bkeys of the lost journal entries written into btree nodes, data
    corruption will be reported during bcache reload after rebooting the
    system.
    
    Indeed there is only one cache in a cache set, there is no need to set
    KEY_PTRS field in journal_reclaim() at all. But in order to keep the
    for_each_cache() logic consistent for now, this patch fixes the above
    problem by not setting 0 KEY_PTRS of journal key, if there is no bucket
    available to reclaim.
    
    Signed-off-by: Coly Li <colyli@suse.de>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit 06a80feb3f20cbaaf087dca14580a346b3fd11a1
Author: Xin Long <lucien.xin@gmail.com>
Date:   Tue Sep 3 17:53:12 2019 +0800

    tipc: add NULL pointer check before calling kfree_rcu
    
    [ Upstream commit 42dec1dbe38239cf91cc1f4df7830c66276ced37 ]
    
    Unlike kfree(p), kfree_rcu(p, rcu) won't do NULL pointer check. When
    tipc_nametbl_remove_publ returns NULL, the panic below happens:
    
       BUG: unable to handle kernel NULL pointer dereference at 0000000000000068
       RIP: 0010:__call_rcu+0x1d/0x290
       Call Trace:
        <IRQ>
        tipc_publ_notify+0xa9/0x170 [tipc]
        tipc_node_write_unlock+0x8d/0x100 [tipc]
        tipc_node_link_down+0xae/0x1d0 [tipc]
        tipc_node_check_dest+0x3ea/0x8f0 [tipc]
        ? tipc_disc_rcv+0x2c7/0x430 [tipc]
        tipc_disc_rcv+0x2c7/0x430 [tipc]
        ? tipc_rcv+0x6bb/0xf20 [tipc]
        tipc_rcv+0x6bb/0xf20 [tipc]
        ? ip_route_input_slow+0x9cf/0xb10
        tipc_udp_recv+0x195/0x1e0 [tipc]
        ? tipc_udp_is_known_peer+0x80/0x80 [tipc]
        udp_queue_rcv_skb+0x180/0x460
        udp_unicast_rcv_skb.isra.56+0x75/0x90
        __udp4_lib_rcv+0x4ce/0xb90
        ip_local_deliver_finish+0x11c/0x210
        ip_local_deliver+0x6b/0xe0
        ? ip_rcv_finish+0xa9/0x410
        ip_rcv+0x273/0x362
    
    Fixes: 97ede29e80ee ("tipc: convert name table read-write lock to RCU")
    Reported-by: Li Shuang <shuali@redhat.com>
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit b9eeaa30e4ea12c416f9d085a597adcbb7b28239
Author: Xin Long <lucien.xin@gmail.com>
Date:   Tue Sep 3 17:53:12 2019 +0800

    tipc: add NULL pointer check before calling kfree_rcu
    
    [ Upstream commit 42dec1dbe38239cf91cc1f4df7830c66276ced37 ]
    
    Unlike kfree(p), kfree_rcu(p, rcu) won't do NULL pointer check. When
    tipc_nametbl_remove_publ returns NULL, the panic below happens:
    
       BUG: unable to handle kernel NULL pointer dereference at 0000000000000068
       RIP: 0010:__call_rcu+0x1d/0x290
       Call Trace:
        <IRQ>
        tipc_publ_notify+0xa9/0x170 [tipc]
        tipc_node_write_unlock+0x8d/0x100 [tipc]
        tipc_node_link_down+0xae/0x1d0 [tipc]
        tipc_node_check_dest+0x3ea/0x8f0 [tipc]
        ? tipc_disc_rcv+0x2c7/0x430 [tipc]
        tipc_disc_rcv+0x2c7/0x430 [tipc]
        ? tipc_rcv+0x6bb/0xf20 [tipc]
        tipc_rcv+0x6bb/0xf20 [tipc]
        ? ip_route_input_slow+0x9cf/0xb10
        tipc_udp_recv+0x195/0x1e0 [tipc]
        ? tipc_udp_is_known_peer+0x80/0x80 [tipc]
        udp_queue_rcv_skb+0x180/0x460
        udp_unicast_rcv_skb.isra.56+0x75/0x90
        __udp4_lib_rcv+0x4ce/0xb90
        ip_local_deliver_finish+0x11c/0x210
        ip_local_deliver+0x6b/0xe0
        ? ip_rcv_finish+0xa9/0x410
        ip_rcv+0x273/0x362
    
    Fixes: 97ede29e80ee ("tipc: convert name table read-write lock to RCU")
    Reported-by: Li Shuang <shuali@redhat.com>
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 48da78093aa1b697029c9a7736366fcf1f1b8586
Author: Xin Long <lucien.xin@gmail.com>
Date:   Tue Sep 3 17:53:12 2019 +0800

    tipc: add NULL pointer check before calling kfree_rcu
    
    [ Upstream commit 42dec1dbe38239cf91cc1f4df7830c66276ced37 ]
    
    Unlike kfree(p), kfree_rcu(p, rcu) won't do NULL pointer check. When
    tipc_nametbl_remove_publ returns NULL, the panic below happens:
    
       BUG: unable to handle kernel NULL pointer dereference at 0000000000000068
       RIP: 0010:__call_rcu+0x1d/0x290
       Call Trace:
        <IRQ>
        tipc_publ_notify+0xa9/0x170 [tipc]
        tipc_node_write_unlock+0x8d/0x100 [tipc]
        tipc_node_link_down+0xae/0x1d0 [tipc]
        tipc_node_check_dest+0x3ea/0x8f0 [tipc]
        ? tipc_disc_rcv+0x2c7/0x430 [tipc]
        tipc_disc_rcv+0x2c7/0x430 [tipc]
        ? tipc_rcv+0x6bb/0xf20 [tipc]
        tipc_rcv+0x6bb/0xf20 [tipc]
        ? ip_route_input_slow+0x9cf/0xb10
        tipc_udp_recv+0x195/0x1e0 [tipc]
        ? tipc_udp_is_known_peer+0x80/0x80 [tipc]
        udp_queue_rcv_skb+0x180/0x460
        udp_unicast_rcv_skb.isra.56+0x75/0x90
        __udp4_lib_rcv+0x4ce/0xb90
        ip_local_deliver_finish+0x11c/0x210
        ip_local_deliver+0x6b/0xe0
        ? ip_rcv_finish+0xa9/0x410
        ip_rcv+0x273/0x362
    
    Fixes: 97ede29e80ee ("tipc: convert name table read-write lock to RCU")
    Reported-by: Li Shuang <shuali@redhat.com>
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 9a4598424e99feda9c6592230a0d020869f776f1
Author: Xin Long <lucien.xin@gmail.com>
Date:   Tue Sep 3 17:53:12 2019 +0800

    tipc: add NULL pointer check before calling kfree_rcu
    
    [ Upstream commit 42dec1dbe38239cf91cc1f4df7830c66276ced37 ]
    
    Unlike kfree(p), kfree_rcu(p, rcu) won't do NULL pointer check. When
    tipc_nametbl_remove_publ returns NULL, the panic below happens:
    
       BUG: unable to handle kernel NULL pointer dereference at 0000000000000068
       RIP: 0010:__call_rcu+0x1d/0x290
       Call Trace:
        <IRQ>
        tipc_publ_notify+0xa9/0x170 [tipc]
        tipc_node_write_unlock+0x8d/0x100 [tipc]
        tipc_node_link_down+0xae/0x1d0 [tipc]
        tipc_node_check_dest+0x3ea/0x8f0 [tipc]
        ? tipc_disc_rcv+0x2c7/0x430 [tipc]
        tipc_disc_rcv+0x2c7/0x430 [tipc]
        ? tipc_rcv+0x6bb/0xf20 [tipc]
        tipc_rcv+0x6bb/0xf20 [tipc]
        ? ip_route_input_slow+0x9cf/0xb10
        tipc_udp_recv+0x195/0x1e0 [tipc]
        ? tipc_udp_is_known_peer+0x80/0x80 [tipc]
        udp_queue_rcv_skb+0x180/0x460
        udp_unicast_rcv_skb.isra.56+0x75/0x90
        __udp4_lib_rcv+0x4ce/0xb90
        ip_local_deliver_finish+0x11c/0x210
        ip_local_deliver+0x6b/0xe0
        ? ip_rcv_finish+0xa9/0x410
        ip_rcv+0x273/0x362
    
    Fixes: 97ede29e80ee ("tipc: convert name table read-write lock to RCU")
    Reported-by: Li Shuang <shuali@redhat.com>
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 7de5d0c7e7b86141824cb01824fb47999dd803d5
Author: Xin Long <lucien.xin@gmail.com>
Date:   Tue Sep 3 17:53:12 2019 +0800

    tipc: add NULL pointer check before calling kfree_rcu
    
    [ Upstream commit 42dec1dbe38239cf91cc1f4df7830c66276ced37 ]
    
    Unlike kfree(p), kfree_rcu(p, rcu) won't do NULL pointer check. When
    tipc_nametbl_remove_publ returns NULL, the panic below happens:
    
       BUG: unable to handle kernel NULL pointer dereference at 0000000000000068
       RIP: 0010:__call_rcu+0x1d/0x290
       Call Trace:
        <IRQ>
        tipc_publ_notify+0xa9/0x170 [tipc]
        tipc_node_write_unlock+0x8d/0x100 [tipc]
        tipc_node_link_down+0xae/0x1d0 [tipc]
        tipc_node_check_dest+0x3ea/0x8f0 [tipc]
        ? tipc_disc_rcv+0x2c7/0x430 [tipc]
        tipc_disc_rcv+0x2c7/0x430 [tipc]
        ? tipc_rcv+0x6bb/0xf20 [tipc]
        tipc_rcv+0x6bb/0xf20 [tipc]
        ? ip_route_input_slow+0x9cf/0xb10
        tipc_udp_recv+0x195/0x1e0 [tipc]
        ? tipc_udp_is_known_peer+0x80/0x80 [tipc]
        udp_queue_rcv_skb+0x180/0x460
        udp_unicast_rcv_skb.isra.56+0x75/0x90
        __udp4_lib_rcv+0x4ce/0xb90
        ip_local_deliver_finish+0x11c/0x210
        ip_local_deliver+0x6b/0xe0
        ? ip_rcv_finish+0xa9/0x410
        ip_rcv+0x273/0x362
    
    Fixes: 97ede29e80ee ("tipc: convert name table read-write lock to RCU")
    Reported-by: Li Shuang <shuali@redhat.com>
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit d60df1c0892f1a36f63fb386824f8a688432c151
Author: Daniel Bristot de Oliveira <bristot@redhat.com>
Date:   Wed Jun 22 17:28:41 2016 -0300

    cgroup: Disable IRQs while holding css_set_lock
    
    commit 82d6489d0fed2ec8a8c48c19e8d8a04ac8e5bb26 upstream.
    
    While testing the deadline scheduler + cgroup setup I hit this
    warning.
    
    [  132.612935] ------------[ cut here ]------------
    [  132.612951] WARNING: CPU: 5 PID: 0 at kernel/softirq.c:150 __local_bh_enable_ip+0x6b/0x80
    [  132.612952] Modules linked in: (a ton of modules...)
    [  132.612981] CPU: 5 PID: 0 Comm: swapper/5 Not tainted 4.7.0-rc2 #2
    [  132.612981] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.8.2-20150714_191134- 04/01/2014
    [  132.612982]  0000000000000086 45c8bb5effdd088b ffff88013fd43da0 ffffffff813d229e
    [  132.612984]  0000000000000000 0000000000000000 ffff88013fd43de0 ffffffff810a652b
    [  132.612985]  00000096811387b5 0000000000000200 ffff8800bab29d80 ffff880034c54c00
    [  132.612986] Call Trace:
    [  132.612987]  <IRQ>  [<ffffffff813d229e>] dump_stack+0x63/0x85
    [  132.612994]  [<ffffffff810a652b>] __warn+0xcb/0xf0
    [  132.612997]  [<ffffffff810e76a0>] ? push_dl_task.part.32+0x170/0x170
    [  132.612999]  [<ffffffff810a665d>] warn_slowpath_null+0x1d/0x20
    [  132.613000]  [<ffffffff810aba5b>] __local_bh_enable_ip+0x6b/0x80
    [  132.613008]  [<ffffffff817d6c8a>] _raw_write_unlock_bh+0x1a/0x20
    [  132.613010]  [<ffffffff817d6c9e>] _raw_spin_unlock_bh+0xe/0x10
    [  132.613015]  [<ffffffff811388ac>] put_css_set+0x5c/0x60
    [  132.613016]  [<ffffffff8113dc7f>] cgroup_free+0x7f/0xa0
    [  132.613017]  [<ffffffff810a3912>] __put_task_struct+0x42/0x140
    [  132.613018]  [<ffffffff810e776a>] dl_task_timer+0xca/0x250
    [  132.613027]  [<ffffffff810e76a0>] ? push_dl_task.part.32+0x170/0x170
    [  132.613030]  [<ffffffff8111371e>] __hrtimer_run_queues+0xee/0x270
    [  132.613031]  [<ffffffff81113ec8>] hrtimer_interrupt+0xa8/0x190
    [  132.613034]  [<ffffffff81051a58>] local_apic_timer_interrupt+0x38/0x60
    [  132.613035]  [<ffffffff817d9b0d>] smp_apic_timer_interrupt+0x3d/0x50
    [  132.613037]  [<ffffffff817d7c5c>] apic_timer_interrupt+0x8c/0xa0
    [  132.613038]  <EOI>  [<ffffffff81063466>] ? native_safe_halt+0x6/0x10
    [  132.613043]  [<ffffffff81037a4e>] default_idle+0x1e/0xd0
    [  132.613044]  [<ffffffff810381cf>] arch_cpu_idle+0xf/0x20
    [  132.613046]  [<ffffffff810e8fda>] default_idle_call+0x2a/0x40
    [  132.613047]  [<ffffffff810e92d7>] cpu_startup_entry+0x2e7/0x340
    [  132.613048]  [<ffffffff81050235>] start_secondary+0x155/0x190
    [  132.613049] ---[ end trace f91934d162ce9977 ]---
    
    The warn is the spin_(lock|unlock)_bh(&css_set_lock) in the interrupt
    context. Converting the spin_lock_bh to spin_lock_irq(save) to avoid
    this problem - and other problems of sharing a spinlock with an
    interrupt.
    
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Li Zefan <lizefan@huawei.com>
    Cc: Johannes Weiner <hannes@cmpxchg.org>
    Cc: Juri Lelli <juri.lelli@arm.com>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: cgroups@vger.kernel.org
    Cc: stable@vger.kernel.org # 4.5+
    Cc: linux-kernel@vger.kernel.org
    Reviewed-by: Rik van Riel <riel@redhat.com>
    Reviewed-by: "Luis Claudio R. Goncalves" <lgoncalv@redhat.com>
    Signed-off-by: Daniel Bristot de Oliveira <bristot@redhat.com>
    Acked-by: Zefan Li <lizefan@huawei.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Zubin Mithra <zsm@chromium.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 42dec1dbe38239cf91cc1f4df7830c66276ced37
Author: Xin Long <lucien.xin@gmail.com>
Date:   Tue Sep 3 17:53:12 2019 +0800

    tipc: add NULL pointer check before calling kfree_rcu
    
    Unlike kfree(p), kfree_rcu(p, rcu) won't do NULL pointer check. When
    tipc_nametbl_remove_publ returns NULL, the panic below happens:
    
       BUG: unable to handle kernel NULL pointer dereference at 0000000000000068
       RIP: 0010:__call_rcu+0x1d/0x290
       Call Trace:
        <IRQ>
        tipc_publ_notify+0xa9/0x170 [tipc]
        tipc_node_write_unlock+0x8d/0x100 [tipc]
        tipc_node_link_down+0xae/0x1d0 [tipc]
        tipc_node_check_dest+0x3ea/0x8f0 [tipc]
        ? tipc_disc_rcv+0x2c7/0x430 [tipc]
        tipc_disc_rcv+0x2c7/0x430 [tipc]
        ? tipc_rcv+0x6bb/0xf20 [tipc]
        tipc_rcv+0x6bb/0xf20 [tipc]
        ? ip_route_input_slow+0x9cf/0xb10
        tipc_udp_recv+0x195/0x1e0 [tipc]
        ? tipc_udp_is_known_peer+0x80/0x80 [tipc]
        udp_queue_rcv_skb+0x180/0x460
        udp_unicast_rcv_skb.isra.56+0x75/0x90
        __udp4_lib_rcv+0x4ce/0xb90
        ip_local_deliver_finish+0x11c/0x210
        ip_local_deliver+0x6b/0xe0
        ? ip_rcv_finish+0xa9/0x410
        ip_rcv+0x273/0x362
    
    Fixes: 97ede29e80ee ("tipc: convert name table read-write lock to RCU")
    Reported-by: Li Shuang <shuali@redhat.com>
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit b3c963d51a02153ffd7c2c41ed4a9287c9d25da2
Author: Josh Elsasser <jelsasser@appneta.com>
Date:   Mon Jul 1 16:48:47 2019 -0700

    net: check before dereferencing netdev_ops during busy poll
    
    init_dummy_netdev() leaves its netdev_ops pointer zeroed. This leads
    to a NULL pointer dereference when sk_busy_loop fires against an iwlwifi
    wireless adapter and checks napi->dev->netdev_ops->ndo_busy_poll.
    
    Avoid this by ensuring napi->dev->netdev_ops is valid before following
    the pointer, avoiding the following panic when busy polling on a dummy
    netdev:
    
      BUG: unable to handle kernel NULL pointer dereference at 00000000000000c8
      IP: [<ffffffff817b4b72>] sk_busy_loop+0x92/0x2f0
      Call Trace:
       [<ffffffff815a3134>] ? uart_write_room+0x74/0xf0
       [<ffffffff817964a9>] sock_poll+0x99/0xa0
       [<ffffffff81223142>] do_sys_poll+0x2e2/0x520
       [<ffffffff8118d3fc>] ? get_page_from_freelist+0x3bc/0xa30
       [<ffffffff810ada22>] ? update_curr+0x62/0x140
       [<ffffffff811ea671>] ? __slab_free+0xa1/0x2a0
       [<ffffffff811ea671>] ? __slab_free+0xa1/0x2a0
       [<ffffffff8179dbb1>] ? skb_free_head+0x21/0x30
       [<ffffffff81221bd0>] ? poll_initwait+0x50/0x50
       [<ffffffff811eaa36>] ? kmem_cache_free+0x1c6/0x1e0
       [<ffffffff815a4884>] ? uart_write+0x124/0x1d0
       [<ffffffff810bd1cd>] ? remove_wait_queue+0x4d/0x60
       [<ffffffff810bd224>] ? __wake_up+0x44/0x50
       [<ffffffff81582731>] ? tty_write_unlock+0x31/0x40
       [<ffffffff8158c5c6>] ? tty_ldisc_deref+0x16/0x20
       [<ffffffff81584820>] ? tty_write+0x1e0/0x2f0
       [<ffffffff81587e50>] ? process_echoes+0x80/0x80
       [<ffffffff8120c17b>] ? __vfs_write+0x2b/0x130
       [<ffffffff8120d09a>] ? vfs_write+0x15a/0x1a0
       [<ffffffff81223455>] SyS_poll+0x75/0x100
       [<ffffffff819a6524>] entry_SYSCALL_64_fastpath+0x24/0xcf
    
    Commit 79e7fff47b7b ("net: remove support for per driver ndo_busy_poll()")
    indirectly fixed this upstream in linux-4.11 by removing the offending
    pointer usage. No other users of napi->dev touch its netdev_ops.
    
    Fixes: 8b80cda536ea ("net: rename include/net/ll_poll.h to include/net/busy_poll.h") # 4.4.y
    Signed-off-by: Josh Elsasser <jelsasser@appneta.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit d76e874053c31555af4fa0ec9819978527ba84e6
Author: Josh Elsasser <jelsasser@appneta.com>
Date:   Mon Jul 1 16:41:43 2019 -0700

    net: check before dereferencing netdev_ops during busy poll
    
    init_dummy_netdev() leaves its netdev_ops pointer zeroed. This leads
    to a NULL pointer dereference when sk_busy_loop fires against an iwlwifi
    wireless adapter and checks napi->dev->netdev_ops->ndo_busy_poll.
    
    Avoid this by ensuring napi->dev->netdev_ops is valid before following
    the pointer, avoiding the following panic when busy polling on a dummy
    netdev:
    
      BUG: unable to handle kernel NULL pointer dereference at 00000000000000c8
      IP: [<ffffffff817b4b72>] sk_busy_loop+0x92/0x2f0
      Call Trace:
       [<ffffffff815a3134>] ? uart_write_room+0x74/0xf0
       [<ffffffff817964a9>] sock_poll+0x99/0xa0
       [<ffffffff81223142>] do_sys_poll+0x2e2/0x520
       [<ffffffff8118d3fc>] ? get_page_from_freelist+0x3bc/0xa30
       [<ffffffff810ada22>] ? update_curr+0x62/0x140
       [<ffffffff811ea671>] ? __slab_free+0xa1/0x2a0
       [<ffffffff811ea671>] ? __slab_free+0xa1/0x2a0
       [<ffffffff8179dbb1>] ? skb_free_head+0x21/0x30
       [<ffffffff81221bd0>] ? poll_initwait+0x50/0x50
       [<ffffffff811eaa36>] ? kmem_cache_free+0x1c6/0x1e0
       [<ffffffff815a4884>] ? uart_write+0x124/0x1d0
       [<ffffffff810bd1cd>] ? remove_wait_queue+0x4d/0x60
       [<ffffffff810bd224>] ? __wake_up+0x44/0x50
       [<ffffffff81582731>] ? tty_write_unlock+0x31/0x40
       [<ffffffff8158c5c6>] ? tty_ldisc_deref+0x16/0x20
       [<ffffffff81584820>] ? tty_write+0x1e0/0x2f0
       [<ffffffff81587e50>] ? process_echoes+0x80/0x80
       [<ffffffff8120c17b>] ? __vfs_write+0x2b/0x130
       [<ffffffff8120d09a>] ? vfs_write+0x15a/0x1a0
       [<ffffffff81223455>] SyS_poll+0x75/0x100
       [<ffffffff819a6524>] entry_SYSCALL_64_fastpath+0x24/0xcf
    
    Commit 79e7fff47b7b ("net: remove support for per driver ndo_busy_poll()")
    indirectly fixed this upstream in linux-4.11 by removing the offending
    pointer usage. No other users of napi->dev touch its netdev_ops.
    
    Fixes: ce6aea93f751 ("net: network drivers no longer need to implement ndo_busy_poll()") # 4.9.y
    Signed-off-by: Josh Elsasser <jelsasser@appneta.com>
    Reviewed-by: Eric Dumazet <edumazet@google.com>
    Tested-by: Matteo Croce <mcroce@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit d0f84d0856c11fbafadae3d580f6a9c98d818ccd
Author: Tuong Lien <tuong.t.lien@dektech.com.au>
Date:   Mon Jun 17 11:56:12 2019 +0700

    tipc: fix issues with early FAILOVER_MSG from peer
    
    It appears that a FAILOVER_MSG can come from peer even when the failure
    link is resetting (i.e. just after the 'node_write_unlock()'...). This
    means the failover procedure on the node has not been started yet.
    The situation is as follows:
    
             node1                                node2
      linkb          linka                  linka        linkb
        |              |                      |            |
        |              |                      x failure    |
        |              |                  RESETTING        |
        |              |                      |            |
        |              x failure            RESET          |
        |          RESETTING             FAILINGOVER       |
        |              |   (FAILOVER_MSG)     |            |
        |<-------------------------------------------------|
        | *FAILINGOVER |                      |            |
        |              | (dummy FAILOVER_MSG) |            |
        |------------------------------------------------->|
        |            RESET                    |            | FAILOVER_END
        |         FAILINGOVER               RESET          |
        .              .                      .            .
        .              .                      .            .
        .              .                      .            .
    
    Once this happens, the link failover procedure will be triggered
    wrongly on the receiving node since the node isn't in FAILINGOVER state
    but then another link failover will be carried out.
    The consequences are:
    
    1) A peer might get stuck in FAILINGOVER state because the 'sync_point'
    was set, reset and set incorrectly, the criteria to end the failover
    would not be met, it could keep waiting for a message that has already
    received.
    
    2) The early FAILOVER_MSG(s) could be queued in the link failover
    deferdq but would be purged or not pulled out because the 'drop_point'
    was not set correctly.
    
    3) The early FAILOVER_MSG(s) could be dropped too.
    
    4) The dummy FAILOVER_MSG could make the peer leaving FAILINGOVER state
    shortly, but later on it would be restarted.
    
    The same situation can also happen when the link is in PEER_RESET state
    and a FAILOVER_MSG arrives.
    
    The commit resolves the issues by forcing the link down immediately, so
    the failover procedure will be started normally (which is the same as
    when receiving a FAILOVER_MSG and the link is in up state).
    
    Also, the function "tipc_node_link_failover()" is toughen to avoid such
    a situation from happening.
    
    Acked-by: Jon Maloy <jon.maloy@ericsson.se>
    Signed-off-by: Tuong Lien <tuong.t.lien@dektech.com.au>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit bef039b2419ea35f5acede56820b42e818cdcdcb
Author: Coly Li <colyli@suse.de>
Date:   Thu Apr 25 00:48:33 2019 +0800

    bcache: never set KEY_PTRS of journal key to 0 in journal_reclaim()
    
    commit 1bee2addc0c8470c8aaa65ef0599eeae96dd88bc upstream.
    
    In journal_reclaim() ja->cur_idx of each cache will be update to
    reclaim available journal buckets. Variable 'int n' is used to count how
    many cache is successfully reclaimed, then n is set to c->journal.key
    by SET_KEY_PTRS(). Later in journal_write_unlocked(), a for_each_cache()
    loop will write the jset data onto each cache.
    
    The problem is, if all jouranl buckets on each cache is full, the
    following code in journal_reclaim(),
    
    529 for_each_cache(ca, c, iter) {
    530       struct journal_device *ja = &ca->journal;
    531       unsigned int next = (ja->cur_idx + 1) % ca->sb.njournal_buckets;
    532
    533       /* No space available on this device */
    534       if (next == ja->discard_idx)
    535               continue;
    536
    537       ja->cur_idx = next;
    538       k->ptr[n++] = MAKE_PTR(0,
    539                         bucket_to_sector(c, ca->sb.d[ja->cur_idx]),
    540                         ca->sb.nr_this_dev);
    541 }
    542
    543 bkey_init(k);
    544 SET_KEY_PTRS(k, n);
    
    If there is no available bucket to reclaim, the if() condition at line
    534 will always true, and n remains 0. Then at line 544, SET_KEY_PTRS()
    will set KEY_PTRS field of c->journal.key to 0.
    
    Setting KEY_PTRS field of c->journal.key to 0 is wrong. Because in
    journal_write_unlocked() the journal data is written in following loop,
    
    649     for (i = 0; i < KEY_PTRS(k); i++) {
    650-671         submit journal data to cache device
    672     }
    
    If KEY_PTRS field is set to 0 in jouranl_reclaim(), the journal data
    won't be written to cache device here. If system crahed or rebooted
    before bkeys of the lost journal entries written into btree nodes, data
    corruption will be reported during bcache reload after rebooting the
    system.
    
    Indeed there is only one cache in a cache set, there is no need to set
    KEY_PTRS field in journal_reclaim() at all. But in order to keep the
    for_each_cache() logic consistent for now, this patch fixes the above
    problem by not setting 0 KEY_PTRS of journal key, if there is no bucket
    available to reclaim.
    
    Signed-off-by: Coly Li <colyli@suse.de>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Jens Axboe <axboe@kernel.dk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 9c52c4cf74055872fdd4b3c98fa777a02e7a6558
Author: Coly Li <colyli@suse.de>
Date:   Thu Apr 25 00:48:33 2019 +0800

    bcache: never set KEY_PTRS of journal key to 0 in journal_reclaim()
    
    commit 1bee2addc0c8470c8aaa65ef0599eeae96dd88bc upstream.
    
    In journal_reclaim() ja->cur_idx of each cache will be update to
    reclaim available journal buckets. Variable 'int n' is used to count how
    many cache is successfully reclaimed, then n is set to c->journal.key
    by SET_KEY_PTRS(). Later in journal_write_unlocked(), a for_each_cache()
    loop will write the jset data onto each cache.
    
    The problem is, if all jouranl buckets on each cache is full, the
    following code in journal_reclaim(),
    
    529 for_each_cache(ca, c, iter) {
    530       struct journal_device *ja = &ca->journal;
    531       unsigned int next = (ja->cur_idx + 1) % ca->sb.njournal_buckets;
    532
    533       /* No space available on this device */
    534       if (next == ja->discard_idx)
    535               continue;
    536
    537       ja->cur_idx = next;
    538       k->ptr[n++] = MAKE_PTR(0,
    539                         bucket_to_sector(c, ca->sb.d[ja->cur_idx]),
    540                         ca->sb.nr_this_dev);
    541 }
    542
    543 bkey_init(k);
    544 SET_KEY_PTRS(k, n);
    
    If there is no available bucket to reclaim, the if() condition at line
    534 will always true, and n remains 0. Then at line 544, SET_KEY_PTRS()
    will set KEY_PTRS field of c->journal.key to 0.
    
    Setting KEY_PTRS field of c->journal.key to 0 is wrong. Because in
    journal_write_unlocked() the journal data is written in following loop,
    
    649     for (i = 0; i < KEY_PTRS(k); i++) {
    650-671         submit journal data to cache device
    672     }
    
    If KEY_PTRS field is set to 0 in jouranl_reclaim(), the journal data
    won't be written to cache device here. If system crahed or rebooted
    before bkeys of the lost journal entries written into btree nodes, data
    corruption will be reported during bcache reload after rebooting the
    system.
    
    Indeed there is only one cache in a cache set, there is no need to set
    KEY_PTRS field in journal_reclaim() at all. But in order to keep the
    for_each_cache() logic consistent for now, this patch fixes the above
    problem by not setting 0 KEY_PTRS of journal key, if there is no bucket
    available to reclaim.
    
    Signed-off-by: Coly Li <colyli@suse.de>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Jens Axboe <axboe@kernel.dk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit bfc6980ff235fb6234e94fd4920765da28ff11d5
Author: Coly Li <colyli@suse.de>
Date:   Thu Apr 25 00:48:33 2019 +0800

    bcache: never set KEY_PTRS of journal key to 0 in journal_reclaim()
    
    commit 1bee2addc0c8470c8aaa65ef0599eeae96dd88bc upstream.
    
    In journal_reclaim() ja->cur_idx of each cache will be update to
    reclaim available journal buckets. Variable 'int n' is used to count how
    many cache is successfully reclaimed, then n is set to c->journal.key
    by SET_KEY_PTRS(). Later in journal_write_unlocked(), a for_each_cache()
    loop will write the jset data onto each cache.
    
    The problem is, if all jouranl buckets on each cache is full, the
    following code in journal_reclaim(),
    
    529 for_each_cache(ca, c, iter) {
    530       struct journal_device *ja = &ca->journal;
    531       unsigned int next = (ja->cur_idx + 1) % ca->sb.njournal_buckets;
    532
    533       /* No space available on this device */
    534       if (next == ja->discard_idx)
    535               continue;
    536
    537       ja->cur_idx = next;
    538       k->ptr[n++] = MAKE_PTR(0,
    539                         bucket_to_sector(c, ca->sb.d[ja->cur_idx]),
    540                         ca->sb.nr_this_dev);
    541 }
    542
    543 bkey_init(k);
    544 SET_KEY_PTRS(k, n);
    
    If there is no available bucket to reclaim, the if() condition at line
    534 will always true, and n remains 0. Then at line 544, SET_KEY_PTRS()
    will set KEY_PTRS field of c->journal.key to 0.
    
    Setting KEY_PTRS field of c->journal.key to 0 is wrong. Because in
    journal_write_unlocked() the journal data is written in following loop,
    
    649     for (i = 0; i < KEY_PTRS(k); i++) {
    650-671         submit journal data to cache device
    672     }
    
    If KEY_PTRS field is set to 0 in jouranl_reclaim(), the journal data
    won't be written to cache device here. If system crahed or rebooted
    before bkeys of the lost journal entries written into btree nodes, data
    corruption will be reported during bcache reload after rebooting the
    system.
    
    Indeed there is only one cache in a cache set, there is no need to set
    KEY_PTRS field in journal_reclaim() at all. But in order to keep the
    for_each_cache() logic consistent for now, this patch fixes the above
    problem by not setting 0 KEY_PTRS of journal key, if there is no bucket
    available to reclaim.
    
    Signed-off-by: Coly Li <colyli@suse.de>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Jens Axboe <axboe@kernel.dk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 88681649ed8c88cfe565a55b47728edee91d6d53
Author: Coly Li <colyli@suse.de>
Date:   Thu Apr 25 00:48:33 2019 +0800

    bcache: never set KEY_PTRS of journal key to 0 in journal_reclaim()
    
    commit 1bee2addc0c8470c8aaa65ef0599eeae96dd88bc upstream.
    
    In journal_reclaim() ja->cur_idx of each cache will be update to
    reclaim available journal buckets. Variable 'int n' is used to count how
    many cache is successfully reclaimed, then n is set to c->journal.key
    by SET_KEY_PTRS(). Later in journal_write_unlocked(), a for_each_cache()
    loop will write the jset data onto each cache.
    
    The problem is, if all jouranl buckets on each cache is full, the
    following code in journal_reclaim(),
    
    529 for_each_cache(ca, c, iter) {
    530       struct journal_device *ja = &ca->journal;
    531       unsigned int next = (ja->cur_idx + 1) % ca->sb.njournal_buckets;
    532
    533       /* No space available on this device */
    534       if (next == ja->discard_idx)
    535               continue;
    536
    537       ja->cur_idx = next;
    538       k->ptr[n++] = MAKE_PTR(0,
    539                         bucket_to_sector(c, ca->sb.d[ja->cur_idx]),
    540                         ca->sb.nr_this_dev);
    541 }
    542
    543 bkey_init(k);
    544 SET_KEY_PTRS(k, n);
    
    If there is no available bucket to reclaim, the if() condition at line
    534 will always true, and n remains 0. Then at line 544, SET_KEY_PTRS()
    will set KEY_PTRS field of c->journal.key to 0.
    
    Setting KEY_PTRS field of c->journal.key to 0 is wrong. Because in
    journal_write_unlocked() the journal data is written in following loop,
    
    649     for (i = 0; i < KEY_PTRS(k); i++) {
    650-671         submit journal data to cache device
    672     }
    
    If KEY_PTRS field is set to 0 in jouranl_reclaim(), the journal data
    won't be written to cache device here. If system crahed or rebooted
    before bkeys of the lost journal entries written into btree nodes, data
    corruption will be reported during bcache reload after rebooting the
    system.
    
    Indeed there is only one cache in a cache set, there is no need to set
    KEY_PTRS field in journal_reclaim() at all. But in order to keep the
    for_each_cache() logic consistent for now, this patch fixes the above
    problem by not setting 0 KEY_PTRS of journal key, if there is no bucket
    available to reclaim.
    
    Signed-off-by: Coly Li <colyli@suse.de>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Jens Axboe <axboe@kernel.dk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit c738ffb58c21cc46b4b6dd83a55868fb59ac4083
Author: Coly Li <colyli@suse.de>
Date:   Thu Apr 25 00:48:33 2019 +0800

    bcache: never set KEY_PTRS of journal key to 0 in journal_reclaim()
    
    commit 1bee2addc0c8470c8aaa65ef0599eeae96dd88bc upstream.
    
    In journal_reclaim() ja->cur_idx of each cache will be update to
    reclaim available journal buckets. Variable 'int n' is used to count how
    many cache is successfully reclaimed, then n is set to c->journal.key
    by SET_KEY_PTRS(). Later in journal_write_unlocked(), a for_each_cache()
    loop will write the jset data onto each cache.
    
    The problem is, if all jouranl buckets on each cache is full, the
    following code in journal_reclaim(),
    
    529 for_each_cache(ca, c, iter) {
    530       struct journal_device *ja = &ca->journal;
    531       unsigned int next = (ja->cur_idx + 1) % ca->sb.njournal_buckets;
    532
    533       /* No space available on this device */
    534       if (next == ja->discard_idx)
    535               continue;
    536
    537       ja->cur_idx = next;
    538       k->ptr[n++] = MAKE_PTR(0,
    539                         bucket_to_sector(c, ca->sb.d[ja->cur_idx]),
    540                         ca->sb.nr_this_dev);
    541 }
    542
    543 bkey_init(k);
    544 SET_KEY_PTRS(k, n);
    
    If there is no available bucket to reclaim, the if() condition at line
    534 will always true, and n remains 0. Then at line 544, SET_KEY_PTRS()
    will set KEY_PTRS field of c->journal.key to 0.
    
    Setting KEY_PTRS field of c->journal.key to 0 is wrong. Because in
    journal_write_unlocked() the journal data is written in following loop,
    
    649     for (i = 0; i < KEY_PTRS(k); i++) {
    650-671         submit journal data to cache device
    672     }
    
    If KEY_PTRS field is set to 0 in jouranl_reclaim(), the journal data
    won't be written to cache device here. If system crahed or rebooted
    before bkeys of the lost journal entries written into btree nodes, data
    corruption will be reported during bcache reload after rebooting the
    system.
    
    Indeed there is only one cache in a cache set, there is no need to set
    KEY_PTRS field in journal_reclaim() at all. But in order to keep the
    for_each_cache() logic consistent for now, this patch fixes the above
    problem by not setting 0 KEY_PTRS of journal key, if there is no bucket
    available to reclaim.
    
    Signed-off-by: Coly Li <colyli@suse.de>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Jens Axboe <axboe@kernel.dk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 7366d0cd181ab6093f5758dc724bc9eeecca7d88
Author: Coly Li <colyli@suse.de>
Date:   Thu Apr 25 00:48:33 2019 +0800

    bcache: never set KEY_PTRS of journal key to 0 in journal_reclaim()
    
    commit 1bee2addc0c8470c8aaa65ef0599eeae96dd88bc upstream.
    
    In journal_reclaim() ja->cur_idx of each cache will be update to
    reclaim available journal buckets. Variable 'int n' is used to count how
    many cache is successfully reclaimed, then n is set to c->journal.key
    by SET_KEY_PTRS(). Later in journal_write_unlocked(), a for_each_cache()
    loop will write the jset data onto each cache.
    
    The problem is, if all jouranl buckets on each cache is full, the
    following code in journal_reclaim(),
    
    529 for_each_cache(ca, c, iter) {
    530       struct journal_device *ja = &ca->journal;
    531       unsigned int next = (ja->cur_idx + 1) % ca->sb.njournal_buckets;
    532
    533       /* No space available on this device */
    534       if (next == ja->discard_idx)
    535               continue;
    536
    537       ja->cur_idx = next;
    538       k->ptr[n++] = MAKE_PTR(0,
    539                         bucket_to_sector(c, ca->sb.d[ja->cur_idx]),
    540                         ca->sb.nr_this_dev);
    541 }
    542
    543 bkey_init(k);
    544 SET_KEY_PTRS(k, n);
    
    If there is no available bucket to reclaim, the if() condition at line
    534 will always true, and n remains 0. Then at line 544, SET_KEY_PTRS()
    will set KEY_PTRS field of c->journal.key to 0.
    
    Setting KEY_PTRS field of c->journal.key to 0 is wrong. Because in
    journal_write_unlocked() the journal data is written in following loop,
    
    649     for (i = 0; i < KEY_PTRS(k); i++) {
    650-671         submit journal data to cache device
    672     }
    
    If KEY_PTRS field is set to 0 in jouranl_reclaim(), the journal data
    won't be written to cache device here. If system crahed or rebooted
    before bkeys of the lost journal entries written into btree nodes, data
    corruption will be reported during bcache reload after rebooting the
    system.
    
    Indeed there is only one cache in a cache set, there is no need to set
    KEY_PTRS field in journal_reclaim() at all. But in order to keep the
    for_each_cache() logic consistent for now, this patch fixes the above
    problem by not setting 0 KEY_PTRS of journal key, if there is no bucket
    available to reclaim.
    
    Signed-off-by: Coly Li <colyli@suse.de>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Jens Axboe <axboe@kernel.dk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 1bee2addc0c8470c8aaa65ef0599eeae96dd88bc
Author: Coly Li <colyli@suse.de>
Date:   Thu Apr 25 00:48:33 2019 +0800

    bcache: never set KEY_PTRS of journal key to 0 in journal_reclaim()
    
    In journal_reclaim() ja->cur_idx of each cache will be update to
    reclaim available journal buckets. Variable 'int n' is used to count how
    many cache is successfully reclaimed, then n is set to c->journal.key
    by SET_KEY_PTRS(). Later in journal_write_unlocked(), a for_each_cache()
    loop will write the jset data onto each cache.
    
    The problem is, if all jouranl buckets on each cache is full, the
    following code in journal_reclaim(),
    
    529 for_each_cache(ca, c, iter) {
    530       struct journal_device *ja = &ca->journal;
    531       unsigned int next = (ja->cur_idx + 1) % ca->sb.njournal_buckets;
    532
    533       /* No space available on this device */
    534       if (next == ja->discard_idx)
    535               continue;
    536
    537       ja->cur_idx = next;
    538       k->ptr[n++] = MAKE_PTR(0,
    539                         bucket_to_sector(c, ca->sb.d[ja->cur_idx]),
    540                         ca->sb.nr_this_dev);
    541 }
    542
    543 bkey_init(k);
    544 SET_KEY_PTRS(k, n);
    
    If there is no available bucket to reclaim, the if() condition at line
    534 will always true, and n remains 0. Then at line 544, SET_KEY_PTRS()
    will set KEY_PTRS field of c->journal.key to 0.
    
    Setting KEY_PTRS field of c->journal.key to 0 is wrong. Because in
    journal_write_unlocked() the journal data is written in following loop,
    
    649     for (i = 0; i < KEY_PTRS(k); i++) {
    650-671         submit journal data to cache device
    672     }
    
    If KEY_PTRS field is set to 0 in jouranl_reclaim(), the journal data
    won't be written to cache device here. If system crahed or rebooted
    before bkeys of the lost journal entries written into btree nodes, data
    corruption will be reported during bcache reload after rebooting the
    system.
    
    Indeed there is only one cache in a cache set, there is no need to set
    KEY_PTRS field in journal_reclaim() at all. But in order to keep the
    for_each_cache() logic consistent for now, this patch fixes the above
    problem by not setting 0 KEY_PTRS of journal key, if there is no bucket
    available to reclaim.
    
    Signed-off-by: Coly Li <colyli@suse.de>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

commit ef9ef4adb85c3d14ab838a886c153432046c6c02
Author: Li RongQing <lirongqing@baidu.com>
Date:   Wed Mar 6 14:46:27 2019 +0800

    connector: fix unsafe usage of ->real_parent
    
    [ Upstream commit 6d2b0f02f5a07a4bf02e4cbc90d7eaa85cac2986 ]
    
    proc_exit_connector() uses ->real_parent lockless. This is not
    safe that its parent can go away at any moment, so use RCU to
    protect it, and ensure that this task is not released.
    
    [  747.624551] ==================================================================
    [  747.632946] BUG: KASAN: use-after-free in proc_exit_connector+0x1f7/0x310
    [  747.640686] Read of size 4 at addr ffff88a0276988e0 by task sshd/2882
    [  747.648032]
    [  747.649804] CPU: 11 PID: 2882 Comm: sshd Tainted: G            E     4.19.26-rc2 #11
    [  747.658629] Hardware name: IBM x3550M4 -[7914OFV]-/00AM544, BIOS -[D7E142BUS-1.71]- 07/31/2014
    [  747.668419] Call Trace:
    [  747.671269]  dump_stack+0xf0/0x19b
    [  747.675186]  ? show_regs_print_info+0x5/0x5
    [  747.679988]  ? kmsg_dump_rewind_nolock+0x59/0x59
    [  747.685302]  print_address_description+0x6a/0x270
    [  747.691162]  kasan_report+0x258/0x380
    [  747.695835]  ? proc_exit_connector+0x1f7/0x310
    [  747.701402]  proc_exit_connector+0x1f7/0x310
    [  747.706767]  ? proc_coredump_connector+0x2d0/0x2d0
    [  747.712715]  ? _raw_write_unlock_irq+0x29/0x50
    [  747.718270]  ? _raw_write_unlock_irq+0x29/0x50
    [  747.723820]  ? ___preempt_schedule+0x16/0x18
    [  747.729193]  ? ___preempt_schedule+0x16/0x18
    [  747.734574]  do_exit+0xa11/0x14f0
    [  747.738880]  ? mm_update_next_owner+0x590/0x590
    [  747.744525]  ? debug_show_all_locks+0x3c0/0x3c0
    [  747.761448]  ? ktime_get_coarse_real_ts64+0xeb/0x1c0
    [  747.767589]  ? lockdep_hardirqs_on+0x1a6/0x290
    [  747.773154]  ? check_chain_key+0x139/0x1f0
    [  747.778345]  ? check_flags.part.35+0x240/0x240
    [  747.783908]  ? __lock_acquire+0x2300/0x2300
    [  747.789171]  ? _raw_spin_unlock_irqrestore+0x59/0x70
    [  747.795316]  ? _raw_spin_unlock_irqrestore+0x59/0x70
    [  747.801457]  ? do_raw_spin_unlock+0x10f/0x1e0
    [  747.806914]  ? do_raw_spin_trylock+0x120/0x120
    [  747.812481]  ? preempt_count_sub+0x14/0xc0
    [  747.817645]  ? _raw_spin_unlock+0x2e/0x50
    [  747.822708]  ? __handle_mm_fault+0x12db/0x1fa0
    [  747.828367]  ? __pmd_alloc+0x2d0/0x2d0
    [  747.833143]  ? check_noncircular+0x50/0x50
    [  747.838309]  ? match_held_lock+0x7f/0x340
    [  747.843380]  ? check_noncircular+0x50/0x50
    [  747.848561]  ? handle_mm_fault+0x21a/0x5f0
    [  747.853730]  ? check_flags.part.35+0x240/0x240
    [  747.859290]  ? check_chain_key+0x139/0x1f0
    [  747.864474]  ? __do_page_fault+0x40f/0x760
    [  747.869655]  ? __audit_syscall_entry+0x4b/0x1f0
    [  747.875319]  ? syscall_trace_enter+0x1d5/0x7b0
    [  747.880877]  ? trace_raw_output_preemptirq_template+0x90/0x90
    [  747.887895]  ? trace_raw_output_sys_exit+0x80/0x80
    [  747.893860]  ? up_read+0x3b/0x90
    [  747.898142]  ? stop_critical_timings+0x260/0x260
    [  747.903909]  do_group_exit+0xe0/0x1c0
    [  747.908591]  ? __x64_sys_exit+0x30/0x30
    [  747.913460]  ? trace_raw_output_preemptirq_template+0x90/0x90
    [  747.920485]  ? tracer_hardirqs_on+0x270/0x270
    [  747.925956]  __x64_sys_exit_group+0x28/0x30
    [  747.931214]  do_syscall_64+0x117/0x400
    [  747.935988]  ? syscall_return_slowpath+0x2f0/0x2f0
    [  747.941931]  ? trace_hardirqs_off_thunk+0x1a/0x1c
    [  747.947788]  ? trace_hardirqs_on_caller+0x1d0/0x1d0
    [  747.953838]  ? lockdep_sys_exit+0x16/0x8e
    [  747.958915]  ? trace_hardirqs_off_thunk+0x1a/0x1c
    [  747.964784]  entry_SYSCALL_64_after_hwframe+0x49/0xbe
    [  747.971021] RIP: 0033:0x7f572f154c68
    [  747.975606] Code: Bad RIP value.
    [  747.979791] RSP: 002b:00007ffed2dfaa58 EFLAGS: 00000246 ORIG_RAX: 00000000000000e7
    [  747.989324] RAX: ffffffffffffffda RBX: 00007f572f431840 RCX: 00007f572f154c68
    [  747.997910] RDX: 0000000000000001 RSI: 000000000000003c RDI: 0000000000000001
    [  748.006495] RBP: 0000000000000001 R08: 00000000000000e7 R09: fffffffffffffee0
    [  748.015079] R10: 00007f572f4387e8 R11: 0000000000000246 R12: 00007f572f431840
    [  748.023664] R13: 000055a7f90f2c50 R14: 000055a7f96e2310 R15: 000055a7f96e2310
    [  748.032287]
    [  748.034509] Allocated by task 2300:
    [  748.038982]  kasan_kmalloc+0xa0/0xd0
    [  748.043562]  kmem_cache_alloc_node+0xf5/0x2e0
    [  748.049018]  copy_process+0x1781/0x4790
    [  748.053884]  _do_fork+0x166/0x9a0
    [  748.058163]  do_syscall_64+0x117/0x400
    [  748.062943]  entry_SYSCALL_64_after_hwframe+0x49/0xbe
    [  748.069180]
    [  748.071405] Freed by task 15395:
    [  748.075591]  __kasan_slab_free+0x130/0x180
    [  748.080752]  kmem_cache_free+0xc2/0x310
    [  748.085619]  free_task+0xea/0x130
    [  748.089901]  __put_task_struct+0x177/0x230
    [  748.095063]  finish_task_switch+0x51b/0x5d0
    [  748.100315]  __schedule+0x506/0xfa0
    [  748.104791]  schedule+0xca/0x260
    [  748.108978]  futex_wait_queue_me+0x27e/0x420
    [  748.114333]  futex_wait+0x251/0x550
    [  748.118814]  do_futex+0x75b/0xf80
    [  748.123097]  __x64_sys_futex+0x231/0x2a0
    [  748.128065]  do_syscall_64+0x117/0x400
    [  748.132835]  entry_SYSCALL_64_after_hwframe+0x49/0xbe
    [  748.139066]
    [  748.141289] The buggy address belongs to the object at ffff88a027698000
    [  748.141289]  which belongs to the cache task_struct of size 12160
    [  748.156589] The buggy address is located 2272 bytes inside of
    [  748.156589]  12160-byte region [ffff88a027698000, ffff88a02769af80)
    [  748.171114] The buggy address belongs to the page:
    [  748.177055] page:ffffea00809da600 count:1 mapcount:0 mapping:ffff888107d01e00 index:0x0 compound_mapcount: 0
    [  748.189136] flags: 0x57ffffc0008100(slab|head)
    [  748.194688] raw: 0057ffffc0008100 ffffea00809a3200 0000000300000003 ffff888107d01e00
    [  748.204424] raw: 0000000000000000 0000000000020002 00000001ffffffff 0000000000000000
    [  748.214146] page dumped because: kasan: bad access detected
    [  748.220976]
    [  748.223197] Memory state around the buggy address:
    [  748.229128]  ffff88a027698780: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [  748.238271]  ffff88a027698800: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [  748.247414] >ffff88a027698880: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [  748.256564]                                                        ^
    [  748.264267]  ffff88a027698900: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [  748.273493]  ffff88a027698980: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [  748.282630] ==================================================================
    
    Fixes: b086ff87251b4a4 ("connector: add parent pid and tgid to coredump and exit events")
    Signed-off-by: Zhang Yu <zhangyu31@baidu.com>
    Signed-off-by: Li RongQing <lirongqing@baidu.com>
    Acked-by: Evgeniy Polyakov <zbr@ioremap.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 28d1ecc9f529d995282d95b8b16785227ed87537
Author: Li RongQing <lirongqing@baidu.com>
Date:   Wed Mar 6 14:46:27 2019 +0800

    connector: fix unsafe usage of ->real_parent
    
    [ Upstream commit 6d2b0f02f5a07a4bf02e4cbc90d7eaa85cac2986 ]
    
    proc_exit_connector() uses ->real_parent lockless. This is not
    safe that its parent can go away at any moment, so use RCU to
    protect it, and ensure that this task is not released.
    
    [  747.624551] ==================================================================
    [  747.632946] BUG: KASAN: use-after-free in proc_exit_connector+0x1f7/0x310
    [  747.640686] Read of size 4 at addr ffff88a0276988e0 by task sshd/2882
    [  747.648032]
    [  747.649804] CPU: 11 PID: 2882 Comm: sshd Tainted: G            E     4.19.26-rc2 #11
    [  747.658629] Hardware name: IBM x3550M4 -[7914OFV]-/00AM544, BIOS -[D7E142BUS-1.71]- 07/31/2014
    [  747.668419] Call Trace:
    [  747.671269]  dump_stack+0xf0/0x19b
    [  747.675186]  ? show_regs_print_info+0x5/0x5
    [  747.679988]  ? kmsg_dump_rewind_nolock+0x59/0x59
    [  747.685302]  print_address_description+0x6a/0x270
    [  747.691162]  kasan_report+0x258/0x380
    [  747.695835]  ? proc_exit_connector+0x1f7/0x310
    [  747.701402]  proc_exit_connector+0x1f7/0x310
    [  747.706767]  ? proc_coredump_connector+0x2d0/0x2d0
    [  747.712715]  ? _raw_write_unlock_irq+0x29/0x50
    [  747.718270]  ? _raw_write_unlock_irq+0x29/0x50
    [  747.723820]  ? ___preempt_schedule+0x16/0x18
    [  747.729193]  ? ___preempt_schedule+0x16/0x18
    [  747.734574]  do_exit+0xa11/0x14f0
    [  747.738880]  ? mm_update_next_owner+0x590/0x590
    [  747.744525]  ? debug_show_all_locks+0x3c0/0x3c0
    [  747.761448]  ? ktime_get_coarse_real_ts64+0xeb/0x1c0
    [  747.767589]  ? lockdep_hardirqs_on+0x1a6/0x290
    [  747.773154]  ? check_chain_key+0x139/0x1f0
    [  747.778345]  ? check_flags.part.35+0x240/0x240
    [  747.783908]  ? __lock_acquire+0x2300/0x2300
    [  747.789171]  ? _raw_spin_unlock_irqrestore+0x59/0x70
    [  747.795316]  ? _raw_spin_unlock_irqrestore+0x59/0x70
    [  747.801457]  ? do_raw_spin_unlock+0x10f/0x1e0
    [  747.806914]  ? do_raw_spin_trylock+0x120/0x120
    [  747.812481]  ? preempt_count_sub+0x14/0xc0
    [  747.817645]  ? _raw_spin_unlock+0x2e/0x50
    [  747.822708]  ? __handle_mm_fault+0x12db/0x1fa0
    [  747.828367]  ? __pmd_alloc+0x2d0/0x2d0
    [  747.833143]  ? check_noncircular+0x50/0x50
    [  747.838309]  ? match_held_lock+0x7f/0x340
    [  747.843380]  ? check_noncircular+0x50/0x50
    [  747.848561]  ? handle_mm_fault+0x21a/0x5f0
    [  747.853730]  ? check_flags.part.35+0x240/0x240
    [  747.859290]  ? check_chain_key+0x139/0x1f0
    [  747.864474]  ? __do_page_fault+0x40f/0x760
    [  747.869655]  ? __audit_syscall_entry+0x4b/0x1f0
    [  747.875319]  ? syscall_trace_enter+0x1d5/0x7b0
    [  747.880877]  ? trace_raw_output_preemptirq_template+0x90/0x90
    [  747.887895]  ? trace_raw_output_sys_exit+0x80/0x80
    [  747.893860]  ? up_read+0x3b/0x90
    [  747.898142]  ? stop_critical_timings+0x260/0x260
    [  747.903909]  do_group_exit+0xe0/0x1c0
    [  747.908591]  ? __x64_sys_exit+0x30/0x30
    [  747.913460]  ? trace_raw_output_preemptirq_template+0x90/0x90
    [  747.920485]  ? tracer_hardirqs_on+0x270/0x270
    [  747.925956]  __x64_sys_exit_group+0x28/0x30
    [  747.931214]  do_syscall_64+0x117/0x400
    [  747.935988]  ? syscall_return_slowpath+0x2f0/0x2f0
    [  747.941931]  ? trace_hardirqs_off_thunk+0x1a/0x1c
    [  747.947788]  ? trace_hardirqs_on_caller+0x1d0/0x1d0
    [  747.953838]  ? lockdep_sys_exit+0x16/0x8e
    [  747.958915]  ? trace_hardirqs_off_thunk+0x1a/0x1c
    [  747.964784]  entry_SYSCALL_64_after_hwframe+0x49/0xbe
    [  747.971021] RIP: 0033:0x7f572f154c68
    [  747.975606] Code: Bad RIP value.
    [  747.979791] RSP: 002b:00007ffed2dfaa58 EFLAGS: 00000246 ORIG_RAX: 00000000000000e7
    [  747.989324] RAX: ffffffffffffffda RBX: 00007f572f431840 RCX: 00007f572f154c68
    [  747.997910] RDX: 0000000000000001 RSI: 000000000000003c RDI: 0000000000000001
    [  748.006495] RBP: 0000000000000001 R08: 00000000000000e7 R09: fffffffffffffee0
    [  748.015079] R10: 00007f572f4387e8 R11: 0000000000000246 R12: 00007f572f431840
    [  748.023664] R13: 000055a7f90f2c50 R14: 000055a7f96e2310 R15: 000055a7f96e2310
    [  748.032287]
    [  748.034509] Allocated by task 2300:
    [  748.038982]  kasan_kmalloc+0xa0/0xd0
    [  748.043562]  kmem_cache_alloc_node+0xf5/0x2e0
    [  748.049018]  copy_process+0x1781/0x4790
    [  748.053884]  _do_fork+0x166/0x9a0
    [  748.058163]  do_syscall_64+0x117/0x400
    [  748.062943]  entry_SYSCALL_64_after_hwframe+0x49/0xbe
    [  748.069180]
    [  748.071405] Freed by task 15395:
    [  748.075591]  __kasan_slab_free+0x130/0x180
    [  748.080752]  kmem_cache_free+0xc2/0x310
    [  748.085619]  free_task+0xea/0x130
    [  748.089901]  __put_task_struct+0x177/0x230
    [  748.095063]  finish_task_switch+0x51b/0x5d0
    [  748.100315]  __schedule+0x506/0xfa0
    [  748.104791]  schedule+0xca/0x260
    [  748.108978]  futex_wait_queue_me+0x27e/0x420
    [  748.114333]  futex_wait+0x251/0x550
    [  748.118814]  do_futex+0x75b/0xf80
    [  748.123097]  __x64_sys_futex+0x231/0x2a0
    [  748.128065]  do_syscall_64+0x117/0x400
    [  748.132835]  entry_SYSCALL_64_after_hwframe+0x49/0xbe
    [  748.139066]
    [  748.141289] The buggy address belongs to the object at ffff88a027698000
    [  748.141289]  which belongs to the cache task_struct of size 12160
    [  748.156589] The buggy address is located 2272 bytes inside of
    [  748.156589]  12160-byte region [ffff88a027698000, ffff88a02769af80)
    [  748.171114] The buggy address belongs to the page:
    [  748.177055] page:ffffea00809da600 count:1 mapcount:0 mapping:ffff888107d01e00 index:0x0 compound_mapcount: 0
    [  748.189136] flags: 0x57ffffc0008100(slab|head)
    [  748.194688] raw: 0057ffffc0008100 ffffea00809a3200 0000000300000003 ffff888107d01e00
    [  748.204424] raw: 0000000000000000 0000000000020002 00000001ffffffff 0000000000000000
    [  748.214146] page dumped because: kasan: bad access detected
    [  748.220976]
    [  748.223197] Memory state around the buggy address:
    [  748.229128]  ffff88a027698780: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [  748.238271]  ffff88a027698800: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [  748.247414] >ffff88a027698880: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [  748.256564]                                                        ^
    [  748.264267]  ffff88a027698900: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [  748.273493]  ffff88a027698980: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [  748.282630] ==================================================================
    
    Fixes: b086ff87251b4a4 ("connector: add parent pid and tgid to coredump and exit events")
    Signed-off-by: Zhang Yu <zhangyu31@baidu.com>
    Signed-off-by: Li RongQing <lirongqing@baidu.com>
    Acked-by: Evgeniy Polyakov <zbr@ioremap.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit c4b5717a016849b4eb437013e662f3546a0ed163
Author: Li RongQing <lirongqing@baidu.com>
Date:   Wed Mar 6 14:46:27 2019 +0800

    connector: fix unsafe usage of ->real_parent
    
    [ Upstream commit 6d2b0f02f5a07a4bf02e4cbc90d7eaa85cac2986 ]
    
    proc_exit_connector() uses ->real_parent lockless. This is not
    safe that its parent can go away at any moment, so use RCU to
    protect it, and ensure that this task is not released.
    
    [  747.624551] ==================================================================
    [  747.632946] BUG: KASAN: use-after-free in proc_exit_connector+0x1f7/0x310
    [  747.640686] Read of size 4 at addr ffff88a0276988e0 by task sshd/2882
    [  747.648032]
    [  747.649804] CPU: 11 PID: 2882 Comm: sshd Tainted: G            E     4.19.26-rc2 #11
    [  747.658629] Hardware name: IBM x3550M4 -[7914OFV]-/00AM544, BIOS -[D7E142BUS-1.71]- 07/31/2014
    [  747.668419] Call Trace:
    [  747.671269]  dump_stack+0xf0/0x19b
    [  747.675186]  ? show_regs_print_info+0x5/0x5
    [  747.679988]  ? kmsg_dump_rewind_nolock+0x59/0x59
    [  747.685302]  print_address_description+0x6a/0x270
    [  747.691162]  kasan_report+0x258/0x380
    [  747.695835]  ? proc_exit_connector+0x1f7/0x310
    [  747.701402]  proc_exit_connector+0x1f7/0x310
    [  747.706767]  ? proc_coredump_connector+0x2d0/0x2d0
    [  747.712715]  ? _raw_write_unlock_irq+0x29/0x50
    [  747.718270]  ? _raw_write_unlock_irq+0x29/0x50
    [  747.723820]  ? ___preempt_schedule+0x16/0x18
    [  747.729193]  ? ___preempt_schedule+0x16/0x18
    [  747.734574]  do_exit+0xa11/0x14f0
    [  747.738880]  ? mm_update_next_owner+0x590/0x590
    [  747.744525]  ? debug_show_all_locks+0x3c0/0x3c0
    [  747.761448]  ? ktime_get_coarse_real_ts64+0xeb/0x1c0
    [  747.767589]  ? lockdep_hardirqs_on+0x1a6/0x290
    [  747.773154]  ? check_chain_key+0x139/0x1f0
    [  747.778345]  ? check_flags.part.35+0x240/0x240
    [  747.783908]  ? __lock_acquire+0x2300/0x2300
    [  747.789171]  ? _raw_spin_unlock_irqrestore+0x59/0x70
    [  747.795316]  ? _raw_spin_unlock_irqrestore+0x59/0x70
    [  747.801457]  ? do_raw_spin_unlock+0x10f/0x1e0
    [  747.806914]  ? do_raw_spin_trylock+0x120/0x120
    [  747.812481]  ? preempt_count_sub+0x14/0xc0
    [  747.817645]  ? _raw_spin_unlock+0x2e/0x50
    [  747.822708]  ? __handle_mm_fault+0x12db/0x1fa0
    [  747.828367]  ? __pmd_alloc+0x2d0/0x2d0
    [  747.833143]  ? check_noncircular+0x50/0x50
    [  747.838309]  ? match_held_lock+0x7f/0x340
    [  747.843380]  ? check_noncircular+0x50/0x50
    [  747.848561]  ? handle_mm_fault+0x21a/0x5f0
    [  747.853730]  ? check_flags.part.35+0x240/0x240
    [  747.859290]  ? check_chain_key+0x139/0x1f0
    [  747.864474]  ? __do_page_fault+0x40f/0x760
    [  747.869655]  ? __audit_syscall_entry+0x4b/0x1f0
    [  747.875319]  ? syscall_trace_enter+0x1d5/0x7b0
    [  747.880877]  ? trace_raw_output_preemptirq_template+0x90/0x90
    [  747.887895]  ? trace_raw_output_sys_exit+0x80/0x80
    [  747.893860]  ? up_read+0x3b/0x90
    [  747.898142]  ? stop_critical_timings+0x260/0x260
    [  747.903909]  do_group_exit+0xe0/0x1c0
    [  747.908591]  ? __x64_sys_exit+0x30/0x30
    [  747.913460]  ? trace_raw_output_preemptirq_template+0x90/0x90
    [  747.920485]  ? tracer_hardirqs_on+0x270/0x270
    [  747.925956]  __x64_sys_exit_group+0x28/0x30
    [  747.931214]  do_syscall_64+0x117/0x400
    [  747.935988]  ? syscall_return_slowpath+0x2f0/0x2f0
    [  747.941931]  ? trace_hardirqs_off_thunk+0x1a/0x1c
    [  747.947788]  ? trace_hardirqs_on_caller+0x1d0/0x1d0
    [  747.953838]  ? lockdep_sys_exit+0x16/0x8e
    [  747.958915]  ? trace_hardirqs_off_thunk+0x1a/0x1c
    [  747.964784]  entry_SYSCALL_64_after_hwframe+0x49/0xbe
    [  747.971021] RIP: 0033:0x7f572f154c68
    [  747.975606] Code: Bad RIP value.
    [  747.979791] RSP: 002b:00007ffed2dfaa58 EFLAGS: 00000246 ORIG_RAX: 00000000000000e7
    [  747.989324] RAX: ffffffffffffffda RBX: 00007f572f431840 RCX: 00007f572f154c68
    [  747.997910] RDX: 0000000000000001 RSI: 000000000000003c RDI: 0000000000000001
    [  748.006495] RBP: 0000000000000001 R08: 00000000000000e7 R09: fffffffffffffee0
    [  748.015079] R10: 00007f572f4387e8 R11: 0000000000000246 R12: 00007f572f431840
    [  748.023664] R13: 000055a7f90f2c50 R14: 000055a7f96e2310 R15: 000055a7f96e2310
    [  748.032287]
    [  748.034509] Allocated by task 2300:
    [  748.038982]  kasan_kmalloc+0xa0/0xd0
    [  748.043562]  kmem_cache_alloc_node+0xf5/0x2e0
    [  748.049018]  copy_process+0x1781/0x4790
    [  748.053884]  _do_fork+0x166/0x9a0
    [  748.058163]  do_syscall_64+0x117/0x400
    [  748.062943]  entry_SYSCALL_64_after_hwframe+0x49/0xbe
    [  748.069180]
    [  748.071405] Freed by task 15395:
    [  748.075591]  __kasan_slab_free+0x130/0x180
    [  748.080752]  kmem_cache_free+0xc2/0x310
    [  748.085619]  free_task+0xea/0x130
    [  748.089901]  __put_task_struct+0x177/0x230
    [  748.095063]  finish_task_switch+0x51b/0x5d0
    [  748.100315]  __schedule+0x506/0xfa0
    [  748.104791]  schedule+0xca/0x260
    [  748.108978]  futex_wait_queue_me+0x27e/0x420
    [  748.114333]  futex_wait+0x251/0x550
    [  748.118814]  do_futex+0x75b/0xf80
    [  748.123097]  __x64_sys_futex+0x231/0x2a0
    [  748.128065]  do_syscall_64+0x117/0x400
    [  748.132835]  entry_SYSCALL_64_after_hwframe+0x49/0xbe
    [  748.139066]
    [  748.141289] The buggy address belongs to the object at ffff88a027698000
    [  748.141289]  which belongs to the cache task_struct of size 12160
    [  748.156589] The buggy address is located 2272 bytes inside of
    [  748.156589]  12160-byte region [ffff88a027698000, ffff88a02769af80)
    [  748.171114] The buggy address belongs to the page:
    [  748.177055] page:ffffea00809da600 count:1 mapcount:0 mapping:ffff888107d01e00 index:0x0 compound_mapcount: 0
    [  748.189136] flags: 0x57ffffc0008100(slab|head)
    [  748.194688] raw: 0057ffffc0008100 ffffea00809a3200 0000000300000003 ffff888107d01e00
    [  748.204424] raw: 0000000000000000 0000000000020002 00000001ffffffff 0000000000000000
    [  748.214146] page dumped because: kasan: bad access detected
    [  748.220976]
    [  748.223197] Memory state around the buggy address:
    [  748.229128]  ffff88a027698780: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [  748.238271]  ffff88a027698800: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [  748.247414] >ffff88a027698880: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [  748.256564]                                                        ^
    [  748.264267]  ffff88a027698900: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [  748.273493]  ffff88a027698980: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [  748.282630] ==================================================================
    
    Fixes: b086ff87251b4a4 ("connector: add parent pid and tgid to coredump and exit events")
    Signed-off-by: Zhang Yu <zhangyu31@baidu.com>
    Signed-off-by: Li RongQing <lirongqing@baidu.com>
    Acked-by: Evgeniy Polyakov <zbr@ioremap.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 6d2b0f02f5a07a4bf02e4cbc90d7eaa85cac2986
Author: Li RongQing <lirongqing@baidu.com>
Date:   Wed Mar 6 14:46:27 2019 +0800

    connector: fix unsafe usage of ->real_parent
    
    proc_exit_connector() uses ->real_parent lockless. This is not
    safe that its parent can go away at any moment, so use RCU to
    protect it, and ensure that this task is not released.
    
    [  747.624551] ==================================================================
    [  747.632946] BUG: KASAN: use-after-free in proc_exit_connector+0x1f7/0x310
    [  747.640686] Read of size 4 at addr ffff88a0276988e0 by task sshd/2882
    [  747.648032]
    [  747.649804] CPU: 11 PID: 2882 Comm: sshd Tainted: G            E     4.19.26-rc2 #11
    [  747.658629] Hardware name: IBM x3550M4 -[7914OFV]-/00AM544, BIOS -[D7E142BUS-1.71]- 07/31/2014
    [  747.668419] Call Trace:
    [  747.671269]  dump_stack+0xf0/0x19b
    [  747.675186]  ? show_regs_print_info+0x5/0x5
    [  747.679988]  ? kmsg_dump_rewind_nolock+0x59/0x59
    [  747.685302]  print_address_description+0x6a/0x270
    [  747.691162]  kasan_report+0x258/0x380
    [  747.695835]  ? proc_exit_connector+0x1f7/0x310
    [  747.701402]  proc_exit_connector+0x1f7/0x310
    [  747.706767]  ? proc_coredump_connector+0x2d0/0x2d0
    [  747.712715]  ? _raw_write_unlock_irq+0x29/0x50
    [  747.718270]  ? _raw_write_unlock_irq+0x29/0x50
    [  747.723820]  ? ___preempt_schedule+0x16/0x18
    [  747.729193]  ? ___preempt_schedule+0x16/0x18
    [  747.734574]  do_exit+0xa11/0x14f0
    [  747.738880]  ? mm_update_next_owner+0x590/0x590
    [  747.744525]  ? debug_show_all_locks+0x3c0/0x3c0
    [  747.761448]  ? ktime_get_coarse_real_ts64+0xeb/0x1c0
    [  747.767589]  ? lockdep_hardirqs_on+0x1a6/0x290
    [  747.773154]  ? check_chain_key+0x139/0x1f0
    [  747.778345]  ? check_flags.part.35+0x240/0x240
    [  747.783908]  ? __lock_acquire+0x2300/0x2300
    [  747.789171]  ? _raw_spin_unlock_irqrestore+0x59/0x70
    [  747.795316]  ? _raw_spin_unlock_irqrestore+0x59/0x70
    [  747.801457]  ? do_raw_spin_unlock+0x10f/0x1e0
    [  747.806914]  ? do_raw_spin_trylock+0x120/0x120
    [  747.812481]  ? preempt_count_sub+0x14/0xc0
    [  747.817645]  ? _raw_spin_unlock+0x2e/0x50
    [  747.822708]  ? __handle_mm_fault+0x12db/0x1fa0
    [  747.828367]  ? __pmd_alloc+0x2d0/0x2d0
    [  747.833143]  ? check_noncircular+0x50/0x50
    [  747.838309]  ? match_held_lock+0x7f/0x340
    [  747.843380]  ? check_noncircular+0x50/0x50
    [  747.848561]  ? handle_mm_fault+0x21a/0x5f0
    [  747.853730]  ? check_flags.part.35+0x240/0x240
    [  747.859290]  ? check_chain_key+0x139/0x1f0
    [  747.864474]  ? __do_page_fault+0x40f/0x760
    [  747.869655]  ? __audit_syscall_entry+0x4b/0x1f0
    [  747.875319]  ? syscall_trace_enter+0x1d5/0x7b0
    [  747.880877]  ? trace_raw_output_preemptirq_template+0x90/0x90
    [  747.887895]  ? trace_raw_output_sys_exit+0x80/0x80
    [  747.893860]  ? up_read+0x3b/0x90
    [  747.898142]  ? stop_critical_timings+0x260/0x260
    [  747.903909]  do_group_exit+0xe0/0x1c0
    [  747.908591]  ? __x64_sys_exit+0x30/0x30
    [  747.913460]  ? trace_raw_output_preemptirq_template+0x90/0x90
    [  747.920485]  ? tracer_hardirqs_on+0x270/0x270
    [  747.925956]  __x64_sys_exit_group+0x28/0x30
    [  747.931214]  do_syscall_64+0x117/0x400
    [  747.935988]  ? syscall_return_slowpath+0x2f0/0x2f0
    [  747.941931]  ? trace_hardirqs_off_thunk+0x1a/0x1c
    [  747.947788]  ? trace_hardirqs_on_caller+0x1d0/0x1d0
    [  747.953838]  ? lockdep_sys_exit+0x16/0x8e
    [  747.958915]  ? trace_hardirqs_off_thunk+0x1a/0x1c
    [  747.964784]  entry_SYSCALL_64_after_hwframe+0x49/0xbe
    [  747.971021] RIP: 0033:0x7f572f154c68
    [  747.975606] Code: Bad RIP value.
    [  747.979791] RSP: 002b:00007ffed2dfaa58 EFLAGS: 00000246 ORIG_RAX: 00000000000000e7
    [  747.989324] RAX: ffffffffffffffda RBX: 00007f572f431840 RCX: 00007f572f154c68
    [  747.997910] RDX: 0000000000000001 RSI: 000000000000003c RDI: 0000000000000001
    [  748.006495] RBP: 0000000000000001 R08: 00000000000000e7 R09: fffffffffffffee0
    [  748.015079] R10: 00007f572f4387e8 R11: 0000000000000246 R12: 00007f572f431840
    [  748.023664] R13: 000055a7f90f2c50 R14: 000055a7f96e2310 R15: 000055a7f96e2310
    [  748.032287]
    [  748.034509] Allocated by task 2300:
    [  748.038982]  kasan_kmalloc+0xa0/0xd0
    [  748.043562]  kmem_cache_alloc_node+0xf5/0x2e0
    [  748.049018]  copy_process+0x1781/0x4790
    [  748.053884]  _do_fork+0x166/0x9a0
    [  748.058163]  do_syscall_64+0x117/0x400
    [  748.062943]  entry_SYSCALL_64_after_hwframe+0x49/0xbe
    [  748.069180]
    [  748.071405] Freed by task 15395:
    [  748.075591]  __kasan_slab_free+0x130/0x180
    [  748.080752]  kmem_cache_free+0xc2/0x310
    [  748.085619]  free_task+0xea/0x130
    [  748.089901]  __put_task_struct+0x177/0x230
    [  748.095063]  finish_task_switch+0x51b/0x5d0
    [  748.100315]  __schedule+0x506/0xfa0
    [  748.104791]  schedule+0xca/0x260
    [  748.108978]  futex_wait_queue_me+0x27e/0x420
    [  748.114333]  futex_wait+0x251/0x550
    [  748.118814]  do_futex+0x75b/0xf80
    [  748.123097]  __x64_sys_futex+0x231/0x2a0
    [  748.128065]  do_syscall_64+0x117/0x400
    [  748.132835]  entry_SYSCALL_64_after_hwframe+0x49/0xbe
    [  748.139066]
    [  748.141289] The buggy address belongs to the object at ffff88a027698000
    [  748.141289]  which belongs to the cache task_struct of size 12160
    [  748.156589] The buggy address is located 2272 bytes inside of
    [  748.156589]  12160-byte region [ffff88a027698000, ffff88a02769af80)
    [  748.171114] The buggy address belongs to the page:
    [  748.177055] page:ffffea00809da600 count:1 mapcount:0 mapping:ffff888107d01e00 index:0x0 compound_mapcount: 0
    [  748.189136] flags: 0x57ffffc0008100(slab|head)
    [  748.194688] raw: 0057ffffc0008100 ffffea00809a3200 0000000300000003 ffff888107d01e00
    [  748.204424] raw: 0000000000000000 0000000000020002 00000001ffffffff 0000000000000000
    [  748.214146] page dumped because: kasan: bad access detected
    [  748.220976]
    [  748.223197] Memory state around the buggy address:
    [  748.229128]  ffff88a027698780: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [  748.238271]  ffff88a027698800: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [  748.247414] >ffff88a027698880: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [  748.256564]                                                        ^
    [  748.264267]  ffff88a027698900: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [  748.273493]  ffff88a027698980: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [  748.282630] ==================================================================
    
    Fixes: b086ff87251b4a4 ("connector: add parent pid and tgid to coredump and exit events")
    Signed-off-by: Zhang Yu <zhangyu31@baidu.com>
    Signed-off-by: Li RongQing <lirongqing@baidu.com>
    Acked-by: Evgeniy Polyakov <zbr@ioremap.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 3032f0c9008088a3effdc2622ce16c3e1bcb13a2
Author: Vineet Gupta <vgupta@synopsys.com>
Date:   Thu Mar 7 13:29:59 2019 -0800

    ARCv2: spinlock: remove the extra smp_mb before lock, after unlock
    
     - ARCv2 LLSC spinlocks have smp_mb() both before and after the LLSC
       instructions, which is not required per lkmm ACQ/REL semantics.
       smp_mb() is only needed _after_ lock and _before_ unlock.
       So remove the extra barriers.
       The reason they were there was mainly historical. At the time of
       initial SMP Linux bringup on HS38 cores, I was too conservative,
       given the fluidity of both hw and sw. The last attempt to ditch the
       extra barrier showed some hackbench regression which is apparently
       not the case now (atleast for LLSC case, read on...)
    
     - EX based spinlocks (!CONFIG_ARC_HAS_LLSC) still needs the extra
       smp_mb(), not due to lkmm, but due to some hardware shenanigans.
       W/o that, hackbench triggers RCU stall splat so extra DMB is retained
       !LLSC based systems are not realistic Linux sstem anyways so they can
       afford to be a nit suboptimal ;-)
    
       | [ARCLinux]# for i in (seq 1 1 5) ; do hackbench; done
       | Running with 10 groups 400 process
       | INFO: task hackbench:158 blocked for more than 10 seconds.
       |       Not tainted 4.20.0-00005-g96b18288a88e-dirty #117
       | "echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
       | hackbench       D    0   158    135 0x00000000
       |
       | Stack Trace:
       | watchdog: BUG: soft lockup - CPU#3 stuck for 59s! [hackbench:469]
       | Modules linked in:
       | Path: (null)
       | CPU: 3 PID: 469 Comm: hackbench Not tainted 4.20.0-00005-g96b18288a88e-dirty
       |
       | [ECR   ]: 0x00000000 => Check Programmer's Manual
       | [EFA   ]: 0x00000000
       | [BLINK ]: do_exit+0x4a6/0x7d0
       | [ERET  ]: _raw_write_unlock_irq+0x44/0x5c
    
     - And while at it, remove the extar smp_mb() from EX based
       arch_read_trylock() since the spin lock there guarantees a full
       barrier anyways
    
     - For LLSC case, hackbench threads improves with this patch (HAPS @ 50MHz)
    
       ---- before ----
       |
       | [ARCLinux]# for i in 1 2 3 4 5; do hackbench 10 thread; done
       | Running with 10 groups 400 threads
       | Time: 16.253
       | Time: 16.445
       | Time: 16.590
       | Time: 16.721
       | Time: 16.544
    
       ---- after ----
       |
       | [ARCLinux]# for i in 1 2 3 4 5; do hackbench 10 thread; done
       | Running with 10 groups 400 threads
       | Time: 15.638
       | Time: 15.730
       | Time: 15.870
       | Time: 15.842
       | Time: 15.729
    
    Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>

commit 3a8844c298522fa22df4bdd863011e5b639a4e84
Author: Lyude Paul <lyude@redhat.com>
Date:   Fri Feb 1 19:20:01 2019 -0500

    drm/dp_mst: Fix unbalanced malloc ref in drm_dp_mst_deallocate_vcpi()
    
    In drm_dp_mst_deallocate_vcpi(), we currently unconditionally call
    drm_dp_mst_put_port_malloc() on the port that's passed to us, even if we
    never successfully allocated VCPI to it. This is contrary to what we do
    in drm_dp_mst_allocate_vcpi(), where we only call
    drm_dp_mst_get_port_malloc() on the passed port if we successfully
    allocated VCPI to it.
    
    As a result, if drm_dp_mst_allocate_vcpi() fails during a modeset and
    another successive modeset calls drm_dp_mst_deallocate_vcpi() we will
    end up dropping someone else's malloc reference to the port. Example:
    
    [  962.309260] ==================================================================
    [  962.309290] BUG: KASAN: use-after-free in drm_dp_mst_put_port_malloc+0x72/0x180 [drm_kms_helper]
    [  962.309296] Read of size 4 at addr ffff888416c30004 by task kworker/0:1H/500
    
    [  962.309308] CPU: 0 PID: 500 Comm: kworker/0:1H Tainted: G        W  O      5.0.0-rc2Lyude-Test+ #1
    [  962.309313] Hardware name: LENOVO 20L8S2N800/20L8S2N800, BIOS N22ET35W (1.12 ) 04/09/2018
    [  962.309428] Workqueue: events_highpri intel_atomic_cleanup_work [i915]
    [  962.309434] Call Trace:
    [  962.309452]  dump_stack+0xad/0x150
    [  962.309462]  ? dump_stack_print_info.cold.0+0x1b/0x1b
    [  962.309472]  ? kmsg_dump_rewind_nolock+0xd9/0xd9
    [  962.309504]  ? drm_dp_mst_put_port_malloc+0x72/0x180 [drm_kms_helper]
    [  962.309515]  print_address_description+0x6c/0x23c
    [  962.309542]  ? drm_dp_mst_put_port_malloc+0x72/0x180 [drm_kms_helper]
    [  962.309568]  ? drm_dp_mst_put_port_malloc+0x72/0x180 [drm_kms_helper]
    [  962.309577]  kasan_report.cold.3+0x1a/0x32
    [  962.309605]  ? drm_dp_mst_put_port_malloc+0x72/0x180 [drm_kms_helper]
    [  962.309631]  drm_dp_mst_put_port_malloc+0x72/0x180 [drm_kms_helper]
    [  962.309658]  ? drm_dp_mst_put_mstb_malloc+0x180/0x180 [drm_kms_helper]
    [  962.309687]  drm_dp_mst_destroy_state+0xcd/0x120 [drm_kms_helper]
    [  962.309745]  drm_atomic_state_default_clear+0x6ee/0xcc0 [drm]
    [  962.309864]  intel_atomic_state_clear+0xe/0x80 [i915]
    [  962.309928]  __drm_atomic_state_free+0x35/0xd0 [drm]
    [  962.310044]  intel_atomic_cleanup_work+0x56/0x70 [i915]
    [  962.310057]  process_one_work+0x884/0x1400
    [  962.310067]  ? drain_workqueue+0x5a0/0x5a0
    [  962.310075]  ? __schedule+0x87f/0x1e80
    [  962.310086]  ? __sched_text_start+0x8/0x8
    [  962.310095]  ? run_rebalance_domains+0x400/0x400
    [  962.310110]  ? deref_stack_reg+0xb4/0x120
    [  962.310117]  ? __read_once_size_nocheck.constprop.7+0x10/0x10
    [  962.310124]  ? worker_enter_idle+0x47f/0x6a0
    [  962.310134]  ? schedule+0xd7/0x2e0
    [  962.310141]  ? __schedule+0x1e80/0x1e80
    [  962.310148]  ? _raw_spin_lock_irq+0x9f/0x130
    [  962.310155]  ? _raw_write_unlock_irqrestore+0x110/0x110
    [  962.310164]  worker_thread+0x196/0x11e0
    [  962.310175]  ? set_load_weight+0x2e0/0x2e0
    [  962.310181]  ? __switch_to_asm+0x34/0x70
    [  962.310187]  ? __switch_to_asm+0x40/0x70
    [  962.310194]  ? process_one_work+0x1400/0x1400
    [  962.310199]  ? __switch_to_asm+0x40/0x70
    [  962.310205]  ? __switch_to_asm+0x34/0x70
    [  962.310211]  ? __switch_to_asm+0x34/0x70
    [  962.310216]  ? __switch_to_asm+0x40/0x70
    [  962.310221]  ? __switch_to_asm+0x34/0x70
    [  962.310226]  ? __switch_to_asm+0x40/0x70
    [  962.310231]  ? __switch_to_asm+0x34/0x70
    [  962.310236]  ? __switch_to_asm+0x40/0x70
    [  962.310242]  ? syscall_return_via_sysret+0xf/0x7f
    [  962.310248]  ? __switch_to_asm+0x34/0x70
    [  962.310253]  ? __switch_to_asm+0x40/0x70
    [  962.310258]  ? __switch_to_asm+0x34/0x70
    [  962.310263]  ? __switch_to_asm+0x40/0x70
    [  962.310268]  ? __switch_to_asm+0x34/0x70
    [  962.310273]  ? __switch_to_asm+0x40/0x70
    [  962.310281]  ? __schedule+0x87f/0x1e80
    [  962.310292]  ? __sched_text_start+0x8/0x8
    [  962.310300]  ? save_stack+0x8c/0xb0
    [  962.310308]  ? __kasan_kmalloc.constprop.6+0xc6/0xd0
    [  962.310313]  ? kthread+0x98/0x3a0
    [  962.310318]  ? ret_from_fork+0x35/0x40
    [  962.310334]  ? __wake_up_common+0x178/0x6f0
    [  962.310343]  ? _raw_spin_lock_irqsave+0xa4/0x140
    [  962.310349]  ? __lock_text_start+0x8/0x8
    [  962.310355]  ? _raw_write_lock_irqsave+0x70/0x130
    [  962.310360]  ? __lock_text_start+0x8/0x8
    [  962.310371]  ? process_one_work+0x1400/0x1400
    [  962.310376]  kthread+0x2e2/0x3a0
    [  962.310383]  ? kthread_create_on_node+0xc0/0xc0
    [  962.310389]  ret_from_fork+0x35/0x40
    
    [  962.310401] Allocated by task 1462:
    [  962.310410]  __kasan_kmalloc.constprop.6+0xc6/0xd0
    [  962.310437]  drm_dp_add_port+0xd60/0x1960 [drm_kms_helper]
    [  962.310464]  drm_dp_send_link_address+0x4b0/0x770 [drm_kms_helper]
    [  962.310491]  drm_dp_check_and_send_link_address+0x197/0x1f0 [drm_kms_helper]
    [  962.310515]  drm_dp_mst_link_probe_work+0x2b6/0x330 [drm_kms_helper]
    [  962.310522]  process_one_work+0x884/0x1400
    [  962.310529]  worker_thread+0x196/0x11e0
    [  962.310533]  kthread+0x2e2/0x3a0
    [  962.310538]  ret_from_fork+0x35/0x40
    
    [  962.310543] Freed by task 500:
    [  962.310550]  __kasan_slab_free+0x133/0x180
    [  962.310555]  kfree+0x92/0x1a0
    [  962.310581]  drm_dp_mst_put_port_malloc+0x14d/0x180 [drm_kms_helper]
    [  962.310693]  intel_connector_destroy+0xb2/0xe0 [i915]
    [  962.310747]  drm_mode_object_put.part.0+0x12b/0x1a0 [drm]
    [  962.310802]  drm_atomic_state_default_clear+0x1f2/0xcc0 [drm]
    [  962.310916]  intel_atomic_state_clear+0xe/0x80 [i915]
    [  962.310972]  __drm_atomic_state_free+0x35/0xd0 [drm]
    [  962.311083]  intel_atomic_cleanup_work+0x56/0x70 [i915]
    [  962.311092]  process_one_work+0x884/0x1400
    [  962.311098]  worker_thread+0x196/0x11e0
    [  962.311103]  kthread+0x2e2/0x3a0
    [  962.311108]  ret_from_fork+0x35/0x40
    
    [  962.311116] The buggy address belongs to the object at ffff888416c30000
                    which belongs to the cache kmalloc-2k of size 2048
    [  962.311122] The buggy address is located 4 bytes inside of
                    2048-byte region [ffff888416c30000, ffff888416c30800)
    [  962.311124] The buggy address belongs to the page:
    [  962.311132] page:ffffea00105b0c00 count:1 mapcount:0 mapping:ffff88841d003040 index:0x0 compound_mapcount: 0
    [  962.311142] flags: 0x8000000000010200(slab|head)
    [  962.311152] raw: 8000000000010200 dead000000000100 dead000000000200 ffff88841d003040
    [  962.311159] raw: 0000000000000000 00000000000f000f 00000001ffffffff 0000000000000000
    [  962.311162] page dumped because: kasan: bad access detected
    
    So, bail early if drm_dp_mst_deallocate_vcpi() is called on a port with
    no VCPI allocation. Additionally, clean up the surrounding kerneldoc
    while we're at it since the port is assumed to be kept around because
    the DRM driver is expected to hold a malloc reference to it, not just
    us.
    
    Changes since v1:
    * Doc changes - danvet
    
    Signed-off-by: Lyude Paul <lyude@redhat.com>
    Fixes: eceae1472467 ("drm/dp_mst: Start tracking per-port VCPI allocations")
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190202002023.29665-2-lyude@redhat.com

commit 1ac18a1dbc3f2f1fa67d57db57d85308cbd8680c
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Mon Oct 1 21:42:37 2018 -0700

    Revert "serial: 8250_dw: Fix runtime PM handling"
    
    [ Upstream commit beeeac43b6fae5f5eaf707b6fcc2bf1e09deb785 ]
    
    This reverts commit d76c74387e1c978b6c5524a146ab0f3f72206f98.
    
    While commit d76c74387e1c ("serial: 8250_dw: Fix runtime PM handling")
    fixes runtime PM handling when using kgdb, it introduces a traceback for
    everyone else.
    
    BUG: sleeping function called from invalid context at
            /mnt/host/source/src/third_party/kernel/next/drivers/base/power/runtime.c:1034
    in_atomic(): 1, irqs_disabled(): 1, pid: 1, name: swapper/0
    7 locks held by swapper/0/1:
     #0: 000000005ec5bc72 (&dev->mutex){....}, at: __driver_attach+0xb5/0x12b
     #1: 000000005d5fa9e5 (&dev->mutex){....}, at: __device_attach+0x3e/0x15b
     #2: 0000000047e93286 (serial_mutex){+.+.}, at: serial8250_register_8250_port+0x51/0x8bb
     #3: 000000003b328f07 (port_mutex){+.+.}, at: uart_add_one_port+0xab/0x8b0
     #4: 00000000fa313d4d (&port->mutex){+.+.}, at: uart_add_one_port+0xcc/0x8b0
     #5: 00000000090983ca (console_lock){+.+.}, at: vprintk_emit+0xdb/0x217
     #6: 00000000c743e583 (console_owner){-...}, at: console_unlock+0x211/0x60f
    irq event stamp: 735222
    __down_trylock_console_sem+0x4a/0x84
    console_unlock+0x338/0x60f
    __do_softirq+0x4a4/0x50d
    irq_exit+0x64/0xe2
    CPU: 2 PID: 1 Comm: swapper/0 Not tainted 4.19.0-rc5 #6
    Hardware name: Google Caroline/Caroline, BIOS Google_Caroline.7820.286.0 03/15/2017
    Call Trace:
     dump_stack+0x7d/0xbd
     ___might_sleep+0x238/0x259
     __pm_runtime_resume+0x4e/0xa4
     ? serial8250_rpm_get+0x2e/0x44
     serial8250_console_write+0x44/0x301
     ? lock_acquire+0x1b8/0x1fa
     console_unlock+0x577/0x60f
     vprintk_emit+0x1f0/0x217
     printk+0x52/0x6e
     register_console+0x43b/0x524
     uart_add_one_port+0x672/0x8b0
     ? set_io_from_upio+0x150/0x162
     serial8250_register_8250_port+0x825/0x8bb
     dw8250_probe+0x80c/0x8b0
     ? dw8250_serial_inq+0x8e/0x8e
     ? dw8250_check_lcr+0x108/0x108
     ? dw8250_runtime_resume+0x5b/0x5b
     ? dw8250_serial_outq+0xa1/0xa1
     ? dw8250_remove+0x115/0x115
     platform_drv_probe+0x76/0xc5
     really_probe+0x1f1/0x3ee
     ? driver_allows_async_probing+0x5d/0x5d
     driver_probe_device+0xd6/0x112
     ? driver_allows_async_probing+0x5d/0x5d
     bus_for_each_drv+0xbe/0xe5
     __device_attach+0xdd/0x15b
     bus_probe_device+0x5a/0x10b
     device_add+0x501/0x894
     ? _raw_write_unlock+0x27/0x3a
     platform_device_add+0x224/0x2b7
     mfd_add_device+0x718/0x75b
     ? __kmalloc+0x144/0x16a
     ? mfd_add_devices+0x38/0xdb
     mfd_add_devices+0x9b/0xdb
     intel_lpss_probe+0x7d4/0x8ee
     intel_lpss_pci_probe+0xac/0xd4
     pci_device_probe+0x101/0x18e
    ...
    
    Revert the offending patch until a more comprehensive solution
    is available.
    
    Cc: Tony Lindgren <tony@atomide.com>
    Cc: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Cc: Phil Edworthy <phil.edworthy@renesas.com>
    Fixes: d76c74387e1c ("serial: 8250_dw: Fix runtime PM handling")
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 523983401644ebeb331c923c28c9591c07430a7d
Author: Liu Bo <bo.liu@linux.alibaba.com>
Date:   Wed Aug 22 05:54:37 2018 +0800

    Btrfs: kill btrfs_clear_path_blocking
    
    Btrfs's btree locking has two modes, spinning mode and blocking mode,
    while searching btree, locking is always acquired in spinning mode and
    then converted to blocking mode if necessary, and in some hot paths we may
    switch the locking back to spinning mode by btrfs_clear_path_blocking().
    
    When acquiring locks, both of reader and writer need to wait for blocking
    readers and writers to complete before doing read_lock()/write_lock().
    
    The problem is that btrfs_clear_path_blocking() needs to switch nodes
    in the path to blocking mode at first (by btrfs_set_path_blocking) to
    make lockdep happy before doing its actual clearing blocking job.
    
    When switching to blocking mode from spinning mode, it consists of
    
    step 1) bumping up blocking readers counter and
    step 2) read_unlock()/write_unlock(),
    
    this has caused serious ping-pong effect if there're a great amount of
    concurrent readers/writers, as waiters will be woken up and go to
    sleep immediately.
    
    1) Killing this kind of ping-pong results in a big improvement in my 1600k
    files creation script,
    
    MNT=/mnt/btrfs
    mkfs.btrfs -f /dev/sdf
    mount /dev/def $MNT
    time fsmark  -D  10000  -S0  -n  100000  -s  0  -L  1 -l /tmp/fs_log.txt \
            -d  $MNT/0  -d  $MNT/1 \
            -d  $MNT/2  -d  $MNT/3 \
            -d  $MNT/4  -d  $MNT/5 \
            -d  $MNT/6  -d  $MNT/7 \
            -d  $MNT/8  -d  $MNT/9 \
            -d  $MNT/10  -d  $MNT/11 \
            -d  $MNT/12  -d  $MNT/13 \
            -d  $MNT/14  -d  $MNT/15
    
    w/o patch:
    real    2m27.307s
    user    0m12.839s
    sys     13m42.831s
    
    w/ patch:
    real    1m2.273s
    user    0m15.802s
    sys     8m16.495s
    
    1.1) latency histogram from funclatency[1]
    
    Overall with the patch, there're ~50% less write lock acquisition and
    the 95% max latency that write lock takes also reduces to ~100ms from
    >500ms.
    
    --------------------------------------------
    w/o patch:
    --------------------------------------------
    Function = btrfs_tree_lock
         msecs               : count     distribution
             0 -> 1          : 2385222  |****************************************|
             2 -> 3          : 37147    |                                        |
             4 -> 7          : 20452    |                                        |
             8 -> 15         : 13131    |                                        |
            16 -> 31         : 3877     |                                        |
            32 -> 63         : 3900     |                                        |
            64 -> 127        : 2612     |                                        |
           128 -> 255        : 974      |                                        |
           256 -> 511        : 165      |                                        |
           512 -> 1023       : 13       |                                        |
    
    Function = btrfs_tree_read_lock
         msecs               : count     distribution
             0 -> 1          : 6743860  |****************************************|
             2 -> 3          : 2146     |                                        |
             4 -> 7          : 190      |                                        |
             8 -> 15         : 38       |                                        |
            16 -> 31         : 4        |                                        |
    
    --------------------------------------------
    w/ patch:
    --------------------------------------------
    Function = btrfs_tree_lock
         msecs               : count     distribution
             0 -> 1          : 1318454  |****************************************|
             2 -> 3          : 6800     |                                        |
             4 -> 7          : 3664     |                                        |
             8 -> 15         : 2145     |                                        |
            16 -> 31         : 809      |                                        |
            32 -> 63         : 219      |                                        |
            64 -> 127        : 10       |                                        |
    
    Function = btrfs_tree_read_lock
         msecs               : count     distribution
             0 -> 1          : 6854317  |****************************************|
             2 -> 3          : 2383     |                                        |
             4 -> 7          : 601      |                                        |
             8 -> 15         : 92       |                                        |
    
    2) dbench also proves the improvement,
    dbench -t 120 -D /mnt/btrfs 16
    
    w/o patch:
    Throughput 158.363 MB/sec
    
    w/ patch:
    Throughput 449.52 MB/sec
    
    3) xfstests didn't show any additional failures.
    
    One thing to note is that callers may set path->leave_spinning to have
    all nodes in the path stay in spinning mode, which means callers are
    ready to not sleep before releasing the path, but it won't cause
    problems if they don't want to sleep in blocking mode.
    
    [1]: https://github.com/iovisor/bcc/blob/master/tools/funclatency.py
    
    Signed-off-by: Liu Bo <bo.liu@linux.alibaba.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

commit beeeac43b6fae5f5eaf707b6fcc2bf1e09deb785
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Mon Oct 1 21:42:37 2018 -0700

    Revert "serial: 8250_dw: Fix runtime PM handling"
    
    This reverts commit d76c74387e1c978b6c5524a146ab0f3f72206f98.
    
    While commit d76c74387e1c ("serial: 8250_dw: Fix runtime PM handling")
    fixes runtime PM handling when using kgdb, it introduces a traceback for
    everyone else.
    
    BUG: sleeping function called from invalid context at
            /mnt/host/source/src/third_party/kernel/next/drivers/base/power/runtime.c:1034
    in_atomic(): 1, irqs_disabled(): 1, pid: 1, name: swapper/0
    7 locks held by swapper/0/1:
     #0: 000000005ec5bc72 (&dev->mutex){....}, at: __driver_attach+0xb5/0x12b
     #1: 000000005d5fa9e5 (&dev->mutex){....}, at: __device_attach+0x3e/0x15b
     #2: 0000000047e93286 (serial_mutex){+.+.}, at: serial8250_register_8250_port+0x51/0x8bb
     #3: 000000003b328f07 (port_mutex){+.+.}, at: uart_add_one_port+0xab/0x8b0
     #4: 00000000fa313d4d (&port->mutex){+.+.}, at: uart_add_one_port+0xcc/0x8b0
     #5: 00000000090983ca (console_lock){+.+.}, at: vprintk_emit+0xdb/0x217
     #6: 00000000c743e583 (console_owner){-...}, at: console_unlock+0x211/0x60f
    irq event stamp: 735222
    __down_trylock_console_sem+0x4a/0x84
    console_unlock+0x338/0x60f
    __do_softirq+0x4a4/0x50d
    irq_exit+0x64/0xe2
    CPU: 2 PID: 1 Comm: swapper/0 Not tainted 4.19.0-rc5 #6
    Hardware name: Google Caroline/Caroline, BIOS Google_Caroline.7820.286.0 03/15/2017
    Call Trace:
     dump_stack+0x7d/0xbd
     ___might_sleep+0x238/0x259
     __pm_runtime_resume+0x4e/0xa4
     ? serial8250_rpm_get+0x2e/0x44
     serial8250_console_write+0x44/0x301
     ? lock_acquire+0x1b8/0x1fa
     console_unlock+0x577/0x60f
     vprintk_emit+0x1f0/0x217
     printk+0x52/0x6e
     register_console+0x43b/0x524
     uart_add_one_port+0x672/0x8b0
     ? set_io_from_upio+0x150/0x162
     serial8250_register_8250_port+0x825/0x8bb
     dw8250_probe+0x80c/0x8b0
     ? dw8250_serial_inq+0x8e/0x8e
     ? dw8250_check_lcr+0x108/0x108
     ? dw8250_runtime_resume+0x5b/0x5b
     ? dw8250_serial_outq+0xa1/0xa1
     ? dw8250_remove+0x115/0x115
     platform_drv_probe+0x76/0xc5
     really_probe+0x1f1/0x3ee
     ? driver_allows_async_probing+0x5d/0x5d
     driver_probe_device+0xd6/0x112
     ? driver_allows_async_probing+0x5d/0x5d
     bus_for_each_drv+0xbe/0xe5
     __device_attach+0xdd/0x15b
     bus_probe_device+0x5a/0x10b
     device_add+0x501/0x894
     ? _raw_write_unlock+0x27/0x3a
     platform_device_add+0x224/0x2b7
     mfd_add_device+0x718/0x75b
     ? __kmalloc+0x144/0x16a
     ? mfd_add_devices+0x38/0xdb
     mfd_add_devices+0x9b/0xdb
     intel_lpss_probe+0x7d4/0x8ee
     intel_lpss_pci_probe+0xac/0xd4
     pci_device_probe+0x101/0x18e
    ...
    
    Revert the offending patch until a more comprehensive solution
    is available.
    
    Cc: Tony Lindgren <tony@atomide.com>
    Cc: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Cc: Phil Edworthy <phil.edworthy@renesas.com>
    Fixes: d76c74387e1c ("serial: 8250_dw: Fix runtime PM handling")
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 3572fd055e69a583eff9d7fd5cb8a7736ed27d65
Author: Vincent Pelletier <plr.vincent@gmail.com>
Date:   Wed Jun 13 11:05:06 2018 +0000

    usb: gadget: ffs: Fix BUG when userland exits with submitted AIO transfers
    
    [ Upstream commit d52e4d0c0c428bf2ba35074a7495cdb28e2efbae ]
    
    This bug happens only when the UDC needs to sleep during usb_ep_dequeue,
    as is the case for (at least) dwc3.
    
    [  382.200896] BUG: scheduling while atomic: screen/1808/0x00000100
    [  382.207124] 4 locks held by screen/1808:
    [  382.211266]  #0:  (rcu_callback){....}, at: [<c10b4ff0>] rcu_process_callbacks+0x260/0x440
    [  382.219949]  #1:  (rcu_read_lock_sched){....}, at: [<c1358ba0>] percpu_ref_switch_to_atomic_rcu+0xb0/0x130
    [  382.230034]  #2:  (&(&ctx->ctx_lock)->rlock){....}, at: [<c11f0c73>] free_ioctx_users+0x23/0xd0
    [  382.230096]  #3:  (&(&ffs->eps_lock)->rlock){....}, at: [<f81e7710>] ffs_aio_cancel+0x20/0x60 [usb_f_fs]
    [  382.230160] Modules linked in: usb_f_fs libcomposite configfs bnep btsdio bluetooth ecdh_generic brcmfmac brcmutil intel_powerclamp coretemp dwc3 kvm_intel ulpi udc_core kvm irqbypass crc32_pclmul crc32c_intel pcbc dwc3_pci aesni_intel aes_i586 crypto_simd cryptd ehci_pci ehci_hcd gpio_keys usbcore basincove_gpadc industrialio usb_common
    [  382.230407] CPU: 1 PID: 1808 Comm: screen Not tainted 4.14.0-edison+ #117
    [  382.230416] Hardware name: Intel Corporation Merrifield/BODEGA BAY, BIOS 542 2015.01.21:18.19.48
    [  382.230425] Call Trace:
    [  382.230438]  <SOFTIRQ>
    [  382.230466]  dump_stack+0x47/0x62
    [  382.230498]  __schedule_bug+0x61/0x80
    [  382.230522]  __schedule+0x43/0x7a0
    [  382.230587]  schedule+0x5f/0x70
    [  382.230625]  dwc3_gadget_ep_dequeue+0x14c/0x270 [dwc3]
    [  382.230669]  ? do_wait_intr_irq+0x70/0x70
    [  382.230724]  usb_ep_dequeue+0x19/0x90 [udc_core]
    [  382.230770]  ffs_aio_cancel+0x37/0x60 [usb_f_fs]
    [  382.230798]  kiocb_cancel+0x31/0x40
    [  382.230822]  free_ioctx_users+0x4d/0xd0
    [  382.230858]  percpu_ref_switch_to_atomic_rcu+0x10a/0x130
    [  382.230881]  ? percpu_ref_exit+0x40/0x40
    [  382.230904]  rcu_process_callbacks+0x2b3/0x440
    [  382.230965]  __do_softirq+0xf8/0x26b
    [  382.231011]  ? __softirqentry_text_start+0x8/0x8
    [  382.231033]  do_softirq_own_stack+0x22/0x30
    [  382.231042]  </SOFTIRQ>
    [  382.231071]  irq_exit+0x45/0xc0
    [  382.231089]  smp_apic_timer_interrupt+0x13c/0x150
    [  382.231118]  apic_timer_interrupt+0x35/0x3c
    [  382.231132] EIP: __copy_user_ll+0xe2/0xf0
    [  382.231142] EFLAGS: 00210293 CPU: 1
    [  382.231154] EAX: bfd4508c EBX: 00000004 ECX: 00000003 EDX: f3d8fe50
    [  382.231165] ESI: f3d8fe51 EDI: bfd4508d EBP: f3d8fe14 ESP: f3d8fe08
    [  382.231176]  DS: 007b ES: 007b FS: 00d8 GS: 0033 SS: 0068
    [  382.231265]  core_sys_select+0x25f/0x320
    [  382.231346]  ? __wake_up_common_lock+0x62/0x80
    [  382.231399]  ? tty_ldisc_deref+0x13/0x20
    [  382.231438]  ? ldsem_up_read+0x1b/0x40
    [  382.231459]  ? tty_ldisc_deref+0x13/0x20
    [  382.231479]  ? tty_write+0x29f/0x2e0
    [  382.231514]  ? n_tty_ioctl+0xe0/0xe0
    [  382.231541]  ? tty_write_unlock+0x30/0x30
    [  382.231566]  ? __vfs_write+0x22/0x110
    [  382.231604]  ? security_file_permission+0x2f/0xd0
    [  382.231635]  ? rw_verify_area+0xac/0x120
    [  382.231677]  ? vfs_write+0x103/0x180
    [  382.231711]  SyS_select+0x87/0xc0
    [  382.231739]  ? SyS_write+0x42/0x90
    [  382.231781]  do_fast_syscall_32+0xd6/0x1a0
    [  382.231836]  entry_SYSENTER_32+0x47/0x71
    [  382.231848] EIP: 0xb7f75b05
    [  382.231857] EFLAGS: 00000246 CPU: 1
    [  382.231868] EAX: ffffffda EBX: 00000400 ECX: bfd4508c EDX: bfd4510c
    [  382.231878] ESI: 00000000 EDI: 00000000 EBP: 00000000 ESP: bfd45020
    [  382.231889]  DS: 007b ES: 007b FS: 0000 GS: 0033 SS: 007b
    [  382.232281] softirq: huh, entered softirq 9 RCU c10b4d90 with preempt_count 00000100, exited with 00000000?
    
    Tested-by: Sam Protsenko <semen.protsenko@linaro.org>
    Signed-off-by: Vincent Pelletier <plr.vincent@gmail.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Signed-off-by: Sasha Levin <alexander.levin@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit e8ca0700a0cde5a5d80b9753f1ed35c69602964d
Author: Vincent Pelletier <plr.vincent@gmail.com>
Date:   Wed Jun 13 11:05:06 2018 +0000

    usb: gadget: ffs: Fix BUG when userland exits with submitted AIO transfers
    
    [ Upstream commit d52e4d0c0c428bf2ba35074a7495cdb28e2efbae ]
    
    This bug happens only when the UDC needs to sleep during usb_ep_dequeue,
    as is the case for (at least) dwc3.
    
    [  382.200896] BUG: scheduling while atomic: screen/1808/0x00000100
    [  382.207124] 4 locks held by screen/1808:
    [  382.211266]  #0:  (rcu_callback){....}, at: [<c10b4ff0>] rcu_process_callbacks+0x260/0x440
    [  382.219949]  #1:  (rcu_read_lock_sched){....}, at: [<c1358ba0>] percpu_ref_switch_to_atomic_rcu+0xb0/0x130
    [  382.230034]  #2:  (&(&ctx->ctx_lock)->rlock){....}, at: [<c11f0c73>] free_ioctx_users+0x23/0xd0
    [  382.230096]  #3:  (&(&ffs->eps_lock)->rlock){....}, at: [<f81e7710>] ffs_aio_cancel+0x20/0x60 [usb_f_fs]
    [  382.230160] Modules linked in: usb_f_fs libcomposite configfs bnep btsdio bluetooth ecdh_generic brcmfmac brcmutil intel_powerclamp coretemp dwc3 kvm_intel ulpi udc_core kvm irqbypass crc32_pclmul crc32c_intel pcbc dwc3_pci aesni_intel aes_i586 crypto_simd cryptd ehci_pci ehci_hcd gpio_keys usbcore basincove_gpadc industrialio usb_common
    [  382.230407] CPU: 1 PID: 1808 Comm: screen Not tainted 4.14.0-edison+ #117
    [  382.230416] Hardware name: Intel Corporation Merrifield/BODEGA BAY, BIOS 542 2015.01.21:18.19.48
    [  382.230425] Call Trace:
    [  382.230438]  <SOFTIRQ>
    [  382.230466]  dump_stack+0x47/0x62
    [  382.230498]  __schedule_bug+0x61/0x80
    [  382.230522]  __schedule+0x43/0x7a0
    [  382.230587]  schedule+0x5f/0x70
    [  382.230625]  dwc3_gadget_ep_dequeue+0x14c/0x270 [dwc3]
    [  382.230669]  ? do_wait_intr_irq+0x70/0x70
    [  382.230724]  usb_ep_dequeue+0x19/0x90 [udc_core]
    [  382.230770]  ffs_aio_cancel+0x37/0x60 [usb_f_fs]
    [  382.230798]  kiocb_cancel+0x31/0x40
    [  382.230822]  free_ioctx_users+0x4d/0xd0
    [  382.230858]  percpu_ref_switch_to_atomic_rcu+0x10a/0x130
    [  382.230881]  ? percpu_ref_exit+0x40/0x40
    [  382.230904]  rcu_process_callbacks+0x2b3/0x440
    [  382.230965]  __do_softirq+0xf8/0x26b
    [  382.231011]  ? __softirqentry_text_start+0x8/0x8
    [  382.231033]  do_softirq_own_stack+0x22/0x30
    [  382.231042]  </SOFTIRQ>
    [  382.231071]  irq_exit+0x45/0xc0
    [  382.231089]  smp_apic_timer_interrupt+0x13c/0x150
    [  382.231118]  apic_timer_interrupt+0x35/0x3c
    [  382.231132] EIP: __copy_user_ll+0xe2/0xf0
    [  382.231142] EFLAGS: 00210293 CPU: 1
    [  382.231154] EAX: bfd4508c EBX: 00000004 ECX: 00000003 EDX: f3d8fe50
    [  382.231165] ESI: f3d8fe51 EDI: bfd4508d EBP: f3d8fe14 ESP: f3d8fe08
    [  382.231176]  DS: 007b ES: 007b FS: 00d8 GS: 0033 SS: 0068
    [  382.231265]  core_sys_select+0x25f/0x320
    [  382.231346]  ? __wake_up_common_lock+0x62/0x80
    [  382.231399]  ? tty_ldisc_deref+0x13/0x20
    [  382.231438]  ? ldsem_up_read+0x1b/0x40
    [  382.231459]  ? tty_ldisc_deref+0x13/0x20
    [  382.231479]  ? tty_write+0x29f/0x2e0
    [  382.231514]  ? n_tty_ioctl+0xe0/0xe0
    [  382.231541]  ? tty_write_unlock+0x30/0x30
    [  382.231566]  ? __vfs_write+0x22/0x110
    [  382.231604]  ? security_file_permission+0x2f/0xd0
    [  382.231635]  ? rw_verify_area+0xac/0x120
    [  382.231677]  ? vfs_write+0x103/0x180
    [  382.231711]  SyS_select+0x87/0xc0
    [  382.231739]  ? SyS_write+0x42/0x90
    [  382.231781]  do_fast_syscall_32+0xd6/0x1a0
    [  382.231836]  entry_SYSENTER_32+0x47/0x71
    [  382.231848] EIP: 0xb7f75b05
    [  382.231857] EFLAGS: 00000246 CPU: 1
    [  382.231868] EAX: ffffffda EBX: 00000400 ECX: bfd4508c EDX: bfd4510c
    [  382.231878] ESI: 00000000 EDI: 00000000 EBP: 00000000 ESP: bfd45020
    [  382.231889]  DS: 007b ES: 007b FS: 0000 GS: 0033 SS: 007b
    [  382.232281] softirq: huh, entered softirq 9 RCU c10b4d90 with preempt_count 00000100, exited with 00000000?
    
    Tested-by: Sam Protsenko <semen.protsenko@linaro.org>
    Signed-off-by: Vincent Pelletier <plr.vincent@gmail.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Signed-off-by: Sasha Levin <alexander.levin@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 264d4f88ad5ba0d3c890a70a1216b4e87e5c26ec
Author: Andrea Parri <andrea.parri@amarulasolutions.com>
Date:   Thu Jun 7 12:01:57 2018 +0200

    doc: Update synchronize_rcu() definition in whatisRCU.txt
    
    The synchronize_rcu() definition based on RW-locks in whatisRCU.txt
    does not meet the "Memory-Barrier Guarantees" in Requirements.html;
    for example, the following SB-like test:
    
        P0:                      P1:
    
        WRITE_ONCE(x, 1);        WRITE_ONCE(y, 1);
        synchronize_rcu();       smp_mb();
        r0 = READ_ONCE(y);       r1 = READ_ONCE(x);
    
    should not be allowed to reach the state "r0 = 0 AND r1 = 0", but
    the current write_lock()+write_unlock() definition can not ensure
    this.  This commit therefore inserts an smp_mb__after_spinlock()
    in order to cause this synchronize_rcu() implementation to provide
    this memory-barrier guarantee.
    
    Suggested-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Signed-off-by: Andrea Parri <andrea.parri@amarulasolutions.com>
    Cc: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Cc: Josh Triplett <josh@joshtriplett.org>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
    Cc: Lai Jiangshan <jiangshanlai@gmail.com>
    Cc: Jonathan Corbet <corbet@lwn.net>
    Signed-off-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>

commit e9db4ef6bf4ca9894bb324c76e01b8f1a16b2650
Author: John Fastabend <john.fastabend@gmail.com>
Date:   Sat Jun 30 06:17:47 2018 -0700

    bpf: sockhash fix omitted bucket lock in sock_close
    
    First the sk_callback_lock() was being used to protect both the
    sock callback hooks and the psock->maps list. This got overly
    convoluted after the addition of sockhash (in sockmap it made
    some sense because masp and callbacks were tightly coupled) so
    lets split out a specific lock for maps and only use the callback
    lock for its intended purpose. This fixes a couple cases where
    we missed using maps lock when it was in fact needed. Also this
    makes it easier to follow the code because now we can put the
    locking closer to the actual code its serializing.
    
    Next, in sock_hash_delete_elem() the pattern was as follows,
    
      sock_hash_delete_elem()
         [...]
         spin_lock(bucket_lock)
         l = lookup_elem_raw()
         if (l)
            hlist_del_rcu()
            write_lock(sk_callback_lock)
             .... destroy psock ...
            write_unlock(sk_callback_lock)
         spin_unlock(bucket_lock)
    
    The ordering is necessary because we only know the {p}sock after
    dereferencing the hash table which we can't do unless we have the
    bucket lock held. Once we have the bucket lock and the psock element
    it is deleted from the hashmap to ensure any other path doing a lookup
    will fail. Finally, the refcnt is decremented and if zero the psock
    is destroyed.
    
    In parallel with the above (or free'ing the map) a tcp close event
    may trigger tcp_close(). Which at the moment omits the bucket lock
    altogether (oops!) where the flow looks like this,
    
      bpf_tcp_close()
         [...]
         write_lock(sk_callback_lock)
         for each psock->maps // list of maps this sock is part of
             hlist_del_rcu(ref_hash_node);
             .... destroy psock ...
         write_unlock(sk_callback_lock)
    
    Obviously, and demonstrated by syzbot, this is broken because
    we can have multiple threads deleting entries via hlist_del_rcu().
    
    To fix this we might be tempted to wrap the hlist operation in a
    bucket lock but that would create a lock inversion problem. In
    summary to follow locking rules the psocks maps list needs the
    sk_callback_lock (after this patch maps_lock) but we need the bucket
    lock to do the hlist_del_rcu.
    
    To resolve the lock inversion problem pop the head of the maps list
    repeatedly and remove the reference until no more are left. If a
    delete happens in parallel from the BPF API that is OK as well because
    it will do a similar action, lookup the lock in the map/hash, delete
    it from the map/hash, and dec the refcnt. We check for this case
    before doing a destroy on the psock to ensure we don't have two
    threads tearing down a psock. The new logic is as follows,
    
      bpf_tcp_close()
      e = psock_map_pop(psock->maps) // done with map lock
      bucket_lock() // lock hash list bucket
      l = lookup_elem_raw(head, hash, key, key_size);
      if (l) {
         //only get here if elmnt was not already removed
         hlist_del_rcu()
         ... destroy psock...
      }
      bucket_unlock()
    
    And finally for all the above to work add missing locking around  map
    operations per above. Then add RCU annotations and use
    rcu_dereference/rcu_assign_pointer to manage values relying on RCU so
    that the object is not free'd from sock_hash_free() while it is being
    referenced in bpf_tcp_close().
    
    Reported-by: syzbot+0ce137753c78f7b6acc1@syzkaller.appspotmail.com
    Fixes: 81110384441a ("bpf: sockmap, add hash map support")
    Signed-off-by: John Fastabend <john.fastabend@gmail.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>

commit d52e4d0c0c428bf2ba35074a7495cdb28e2efbae
Author: Vincent Pelletier <plr.vincent@gmail.com>
Date:   Wed Jun 13 11:05:06 2018 +0000

    usb: gadget: ffs: Fix BUG when userland exits with submitted AIO transfers
    
    This bug happens only when the UDC needs to sleep during usb_ep_dequeue,
    as is the case for (at least) dwc3.
    
    [  382.200896] BUG: scheduling while atomic: screen/1808/0x00000100
    [  382.207124] 4 locks held by screen/1808:
    [  382.211266]  #0:  (rcu_callback){....}, at: [<c10b4ff0>] rcu_process_callbacks+0x260/0x440
    [  382.219949]  #1:  (rcu_read_lock_sched){....}, at: [<c1358ba0>] percpu_ref_switch_to_atomic_rcu+0xb0/0x130
    [  382.230034]  #2:  (&(&ctx->ctx_lock)->rlock){....}, at: [<c11f0c73>] free_ioctx_users+0x23/0xd0
    [  382.230096]  #3:  (&(&ffs->eps_lock)->rlock){....}, at: [<f81e7710>] ffs_aio_cancel+0x20/0x60 [usb_f_fs]
    [  382.230160] Modules linked in: usb_f_fs libcomposite configfs bnep btsdio bluetooth ecdh_generic brcmfmac brcmutil intel_powerclamp coretemp dwc3 kvm_intel ulpi udc_core kvm irqbypass crc32_pclmul crc32c_intel pcbc dwc3_pci aesni_intel aes_i586 crypto_simd cryptd ehci_pci ehci_hcd gpio_keys usbcore basincove_gpadc industrialio usb_common
    [  382.230407] CPU: 1 PID: 1808 Comm: screen Not tainted 4.14.0-edison+ #117
    [  382.230416] Hardware name: Intel Corporation Merrifield/BODEGA BAY, BIOS 542 2015.01.21:18.19.48
    [  382.230425] Call Trace:
    [  382.230438]  <SOFTIRQ>
    [  382.230466]  dump_stack+0x47/0x62
    [  382.230498]  __schedule_bug+0x61/0x80
    [  382.230522]  __schedule+0x43/0x7a0
    [  382.230587]  schedule+0x5f/0x70
    [  382.230625]  dwc3_gadget_ep_dequeue+0x14c/0x270 [dwc3]
    [  382.230669]  ? do_wait_intr_irq+0x70/0x70
    [  382.230724]  usb_ep_dequeue+0x19/0x90 [udc_core]
    [  382.230770]  ffs_aio_cancel+0x37/0x60 [usb_f_fs]
    [  382.230798]  kiocb_cancel+0x31/0x40
    [  382.230822]  free_ioctx_users+0x4d/0xd0
    [  382.230858]  percpu_ref_switch_to_atomic_rcu+0x10a/0x130
    [  382.230881]  ? percpu_ref_exit+0x40/0x40
    [  382.230904]  rcu_process_callbacks+0x2b3/0x440
    [  382.230965]  __do_softirq+0xf8/0x26b
    [  382.231011]  ? __softirqentry_text_start+0x8/0x8
    [  382.231033]  do_softirq_own_stack+0x22/0x30
    [  382.231042]  </SOFTIRQ>
    [  382.231071]  irq_exit+0x45/0xc0
    [  382.231089]  smp_apic_timer_interrupt+0x13c/0x150
    [  382.231118]  apic_timer_interrupt+0x35/0x3c
    [  382.231132] EIP: __copy_user_ll+0xe2/0xf0
    [  382.231142] EFLAGS: 00210293 CPU: 1
    [  382.231154] EAX: bfd4508c EBX: 00000004 ECX: 00000003 EDX: f3d8fe50
    [  382.231165] ESI: f3d8fe51 EDI: bfd4508d EBP: f3d8fe14 ESP: f3d8fe08
    [  382.231176]  DS: 007b ES: 007b FS: 00d8 GS: 0033 SS: 0068
    [  382.231265]  core_sys_select+0x25f/0x320
    [  382.231346]  ? __wake_up_common_lock+0x62/0x80
    [  382.231399]  ? tty_ldisc_deref+0x13/0x20
    [  382.231438]  ? ldsem_up_read+0x1b/0x40
    [  382.231459]  ? tty_ldisc_deref+0x13/0x20
    [  382.231479]  ? tty_write+0x29f/0x2e0
    [  382.231514]  ? n_tty_ioctl+0xe0/0xe0
    [  382.231541]  ? tty_write_unlock+0x30/0x30
    [  382.231566]  ? __vfs_write+0x22/0x110
    [  382.231604]  ? security_file_permission+0x2f/0xd0
    [  382.231635]  ? rw_verify_area+0xac/0x120
    [  382.231677]  ? vfs_write+0x103/0x180
    [  382.231711]  SyS_select+0x87/0xc0
    [  382.231739]  ? SyS_write+0x42/0x90
    [  382.231781]  do_fast_syscall_32+0xd6/0x1a0
    [  382.231836]  entry_SYSENTER_32+0x47/0x71
    [  382.231848] EIP: 0xb7f75b05
    [  382.231857] EFLAGS: 00000246 CPU: 1
    [  382.231868] EAX: ffffffda EBX: 00000400 ECX: bfd4508c EDX: bfd4510c
    [  382.231878] ESI: 00000000 EDI: 00000000 EBP: 00000000 ESP: bfd45020
    [  382.231889]  DS: 007b ES: 007b FS: 0000 GS: 0033 SS: 007b
    [  382.232281] softirq: huh, entered softirq 9 RCU c10b4d90 with preempt_count 00000100, exited with 00000000?
    
    Tested-by: Sam Protsenko <semen.protsenko@linaro.org>
    Signed-off-by: Vincent Pelletier <plr.vincent@gmail.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

commit 2f2f95d96b8e59e29701621f94354325479cd91e
Author: Michael Bringmann <mwb@linux.vnet.ibm.com>
Date:   Tue Nov 28 16:58:40 2017 -0600

    powerpc/numa: Ensure nodes initialized for hotplug
    
    [ Upstream commit ea05ba7c559c8e5a5946c3a94a2a266e9a6680a6 ]
    
    This patch fixes some problems encountered at runtime with
    configurations that support memory-less nodes, or that hot-add CPUs
    into nodes that are memoryless during system execution after boot. The
    problems of interest include:
    
    * Nodes known to powerpc to be memoryless at boot, but to have CPUs in
      them are allowed to be 'possible' and 'online'. Memory allocations
      for those nodes are taken from another node that does have memory
      until and if memory is hot-added to the node.
    
    * Nodes which have no resources assigned at boot, but which may still
      be referenced subsequently by affinity or associativity attributes,
      are kept in the list of 'possible' nodes for powerpc. Hot-add of
      memory or CPUs to the system can reference these nodes and bring
      them online instead of redirecting the references to one of the set
      of nodes known to have memory at boot.
    
    Note that this software operates under the context of CPU hotplug. We
    are not doing memory hotplug in this code, but rather updating the
    kernel's CPU topology (i.e. arch_update_cpu_topology /
    numa_update_cpu_topology). We are initializing a node that may be used
    by CPUs or memory before it can be referenced as invalid by a CPU
    hotplug operation. CPU hotplug operations are protected by a range of
    APIs including cpu_maps_update_begin/cpu_maps_update_done,
    cpus_read/write_lock / cpus_read/write_unlock, device locks, and more.
    Memory hotplug operations, including try_online_node, are protected by
    mem_hotplug_begin/mem_hotplug_done, device locks, and more. In the
    case of CPUs being hot-added to a previously memoryless node, the
    try_online_node operation occurs wholly within the CPU locks with no
    overlap. Using HMC hot-add/hot-remove operations, we have been able to
    add and remove CPUs to any possible node without failures. HMC
    operations involve a degree self-serialization, though.
    
    Signed-off-by: Michael Bringmann <mwb@linux.vnet.ibm.com>
    Reviewed-by: Nathan Fontenot <nfont@linux.vnet.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Signed-off-by: Sasha Levin <alexander.levin@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit b4e84e5aed7680dedd44727bcf8ed7fdbd409b86
Author: Michael Bringmann <mwb@linux.vnet.ibm.com>
Date:   Tue Nov 28 16:58:40 2017 -0600

    powerpc/numa: Ensure nodes initialized for hotplug
    
    [ Upstream commit ea05ba7c559c8e5a5946c3a94a2a266e9a6680a6 ]
    
    This patch fixes some problems encountered at runtime with
    configurations that support memory-less nodes, or that hot-add CPUs
    into nodes that are memoryless during system execution after boot. The
    problems of interest include:
    
    * Nodes known to powerpc to be memoryless at boot, but to have CPUs in
      them are allowed to be 'possible' and 'online'. Memory allocations
      for those nodes are taken from another node that does have memory
      until and if memory is hot-added to the node.
    
    * Nodes which have no resources assigned at boot, but which may still
      be referenced subsequently by affinity or associativity attributes,
      are kept in the list of 'possible' nodes for powerpc. Hot-add of
      memory or CPUs to the system can reference these nodes and bring
      them online instead of redirecting the references to one of the set
      of nodes known to have memory at boot.
    
    Note that this software operates under the context of CPU hotplug. We
    are not doing memory hotplug in this code, but rather updating the
    kernel's CPU topology (i.e. arch_update_cpu_topology /
    numa_update_cpu_topology). We are initializing a node that may be used
    by CPUs or memory before it can be referenced as invalid by a CPU
    hotplug operation. CPU hotplug operations are protected by a range of
    APIs including cpu_maps_update_begin/cpu_maps_update_done,
    cpus_read/write_lock / cpus_read/write_unlock, device locks, and more.
    Memory hotplug operations, including try_online_node, are protected by
    mem_hotplug_begin/mem_hotplug_done, device locks, and more. In the
    case of CPUs being hot-added to a previously memoryless node, the
    try_online_node operation occurs wholly within the CPU locks with no
    overlap. Using HMC hot-add/hot-remove operations, we have been able to
    add and remove CPUs to any possible node without failures. HMC
    operations involve a degree self-serialization, though.
    
    Signed-off-by: Michael Bringmann <mwb@linux.vnet.ibm.com>
    Reviewed-by: Nathan Fontenot <nfont@linux.vnet.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Signed-off-by: Sasha Levin <alexander.levin@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 0759c1c2f140ec56a9fec96dddf9e5beb89f3b48
Author: Sahitya Tummala <stummala@codeaurora.org>
Date:   Wed Feb 1 20:49:35 2017 -0500

    jbd2: fix use after free in kjournald2()
    
    [ Upstream commit dbfcef6b0f4012c57bc0b6e0e660d5ed12a5eaed ]
    
    Below is the synchronization issue between unmount and kjournald2
    contexts, which results into use after free issue in kjournald2().
    Fix this issue by using journal->j_state_lock to synchronize the
    wait_event() done in journal_kill_thread() and the wake_up() done
    in kjournald2().
    
    TASK 1:
    umount cmd:
       |--jbd2_journal_destroy() {
           |--journal_kill_thread() {
                write_lock(&journal->j_state_lock);
                journal->j_flags |= JBD2_UNMOUNT;
                ...
                write_unlock(&journal->j_state_lock);
                wake_up(&journal->j_wait_commit);      TASK 2 wakes up here:
                                                       kjournald2() {
                                                         ...
                                                         checks JBD2_UNMOUNT flag and calls goto end-loop;
                                                         ...
                                                         end_loop:
                                                           write_unlock(&journal->j_state_lock);
                                                           journal->j_task = NULL; --> If this thread gets
                                                           pre-empted here, then TASK 1 wait_event will
                                                           exit even before this thread is completely
                                                           done.
                wait_event(journal->j_wait_done_commit, journal->j_task == NULL);
                ...
                write_lock(&journal->j_state_lock);
                write_unlock(&journal->j_state_lock);
              }
           |--kfree(journal);
         }
    }
                                                           wake_up(&journal->j_wait_done_commit); --> this step
                                                           now results into use after free issue.
                                                       }
    
    Signed-off-by: Sahitya Tummala <stummala@codeaurora.org>
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>
    Signed-off-by: Sasha Levin <alexander.levin@microsoft.com>

commit cff3a5f282ff1813352a146c487f4d8b472c250e
Author: Sahitya Tummala <stummala@codeaurora.org>
Date:   Wed Feb 1 20:49:35 2017 -0500

    jbd2: fix use after free in kjournald2()
    
    commit dbfcef6b0f4012c57bc0b6e0e660d5ed12a5eaed upstream.
    
    Below is the synchronization issue between unmount and kjournald2
    contexts, which results into use after free issue in kjournald2().
    Fix this issue by using journal->j_state_lock to synchronize the
    wait_event() done in journal_kill_thread() and the wake_up() done
    in kjournald2().
    
    TASK 1:
    umount cmd:
       |--jbd2_journal_destroy() {
           |--journal_kill_thread() {
                write_lock(&journal->j_state_lock);
                journal->j_flags |= JBD2_UNMOUNT;
                ...
                write_unlock(&journal->j_state_lock);
                wake_up(&journal->j_wait_commit);      TASK 2 wakes up here:
                                                       kjournald2() {
                                                         ...
                                                         checks JBD2_UNMOUNT flag and calls goto end-loop;
                                                         ...
                                                         end_loop:
                                                           write_unlock(&journal->j_state_lock);
                                                           journal->j_task = NULL; --> If this thread gets
                                                           pre-empted here, then TASK 1 wait_event will
                                                           exit even before this thread is completely
                                                           done.
                wait_event(journal->j_wait_done_commit, journal->j_task == NULL);
                ...
                write_lock(&journal->j_state_lock);
                write_unlock(&journal->j_state_lock);
              }
           |--kfree(journal);
         }
    }
                                                           wake_up(&journal->j_wait_done_commit); --> this step
                                                           now results into use after free issue.
                                                       }
    
    Signed-off-by: Sahitya Tummala <stummala@codeaurora.org>
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>
    Cc: Amit Pundir <amit.pundir@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 87dfe99e129679c23bebda36b83cb223285afc2a
Author: Sahitya Tummala <stummala@codeaurora.org>
Date:   Wed Feb 1 20:49:35 2017 -0500

    jbd2: fix use after free in kjournald2()
    
    commit dbfcef6b0f4012c57bc0b6e0e660d5ed12a5eaed upstream.
    
    Below is the synchronization issue between unmount and kjournald2
    contexts, which results into use after free issue in kjournald2().
    Fix this issue by using journal->j_state_lock to synchronize the
    wait_event() done in journal_kill_thread() and the wake_up() done
    in kjournald2().
    
    TASK 1:
    umount cmd:
       |--jbd2_journal_destroy() {
           |--journal_kill_thread() {
                write_lock(&journal->j_state_lock);
                journal->j_flags |= JBD2_UNMOUNT;
                ...
                write_unlock(&journal->j_state_lock);
                wake_up(&journal->j_wait_commit);      TASK 2 wakes up here:
                                                       kjournald2() {
                                                         ...
                                                         checks JBD2_UNMOUNT flag and calls goto end-loop;
                                                         ...
                                                         end_loop:
                                                           write_unlock(&journal->j_state_lock);
                                                           journal->j_task = NULL; --> If this thread gets
                                                           pre-empted here, then TASK 1 wait_event will
                                                           exit even before this thread is completely
                                                           done.
                wait_event(journal->j_wait_done_commit, journal->j_task == NULL);
                ...
                write_lock(&journal->j_state_lock);
                write_unlock(&journal->j_state_lock);
              }
           |--kfree(journal);
         }
    }
                                                           wake_up(&journal->j_wait_done_commit); --> this step
                                                           now results into use after free issue.
                                                       }
    
    Signed-off-by: Sahitya Tummala <stummala@codeaurora.org>
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>
    Cc: Amit Pundir <amit.pundir@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit f47bd1b5605e2a5cb89853e3fc595b7d84f4db4c
Author: Sahitya Tummala <stummala@codeaurora.org>
Date:   Wed Feb 1 20:49:35 2017 -0500

    jbd2: fix use after free in kjournald2()
    
    commit dbfcef6b0f4012c57bc0b6e0e660d5ed12a5eaed upstream.
    
    Below is the synchronization issue between unmount and kjournald2
    contexts, which results into use after free issue in kjournald2().
    Fix this issue by using journal->j_state_lock to synchronize the
    wait_event() done in journal_kill_thread() and the wake_up() done
    in kjournald2().
    
    TASK 1:
    umount cmd:
       |--jbd2_journal_destroy() {
           |--journal_kill_thread() {
                write_lock(&journal->j_state_lock);
                journal->j_flags |= JBD2_UNMOUNT;
                ...
                write_unlock(&journal->j_state_lock);
                wake_up(&journal->j_wait_commit);      TASK 2 wakes up here:
                                                       kjournald2() {
                                                         ...
                                                         checks JBD2_UNMOUNT flag and calls goto end-loop;
                                                         ...
                                                         end_loop:
                                                           write_unlock(&journal->j_state_lock);
                                                           journal->j_task = NULL; --> If this thread gets
                                                           pre-empted here, then TASK 1 wait_event will
                                                           exit even before this thread is completely
                                                           done.
                wait_event(journal->j_wait_done_commit, journal->j_task == NULL);
                ...
                write_lock(&journal->j_state_lock);
                write_unlock(&journal->j_state_lock);
              }
           |--kfree(journal);
         }
    }
                                                           wake_up(&journal->j_wait_done_commit); --> this step
                                                           now results into use after free issue.
                                                       }
    
    Signed-off-by: Sahitya Tummala <stummala@codeaurora.org>
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>
    Cc: Amit Pundir <amit.pundir@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 0bddd43ac2001d87471117ff29e789aa3bcfd18b
Author: Michael Bringmann <mwb@linux.vnet.ibm.com>
Date:   Tue Nov 28 16:58:40 2017 -0600

    powerpc/numa: Ensure nodes initialized for hotplug
    
    
    [ Upstream commit ea05ba7c559c8e5a5946c3a94a2a266e9a6680a6 ]
    
    This patch fixes some problems encountered at runtime with
    configurations that support memory-less nodes, or that hot-add CPUs
    into nodes that are memoryless during system execution after boot. The
    problems of interest include:
    
    * Nodes known to powerpc to be memoryless at boot, but to have CPUs in
      them are allowed to be 'possible' and 'online'. Memory allocations
      for those nodes are taken from another node that does have memory
      until and if memory is hot-added to the node.
    
    * Nodes which have no resources assigned at boot, but which may still
      be referenced subsequently by affinity or associativity attributes,
      are kept in the list of 'possible' nodes for powerpc. Hot-add of
      memory or CPUs to the system can reference these nodes and bring
      them online instead of redirecting the references to one of the set
      of nodes known to have memory at boot.
    
    Note that this software operates under the context of CPU hotplug. We
    are not doing memory hotplug in this code, but rather updating the
    kernel's CPU topology (i.e. arch_update_cpu_topology /
    numa_update_cpu_topology). We are initializing a node that may be used
    by CPUs or memory before it can be referenced as invalid by a CPU
    hotplug operation. CPU hotplug operations are protected by a range of
    APIs including cpu_maps_update_begin/cpu_maps_update_done,
    cpus_read/write_lock / cpus_read/write_unlock, device locks, and more.
    Memory hotplug operations, including try_online_node, are protected by
    mem_hotplug_begin/mem_hotplug_done, device locks, and more. In the
    case of CPUs being hot-added to a previously memoryless node, the
    try_online_node operation occurs wholly within the CPU locks with no
    overlap. Using HMC hot-add/hot-remove operations, we have been able to
    add and remove CPUs to any possible node without failures. HMC
    operations involve a degree self-serialization, though.
    
    Signed-off-by: Michael Bringmann <mwb@linux.vnet.ibm.com>
    Reviewed-by: Nathan Fontenot <nfont@linux.vnet.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Signed-off-by: Sasha Levin <alexander.levin@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 294975841483c08e84572713f348cd51b8408021
Author: Steven Rostedt (VMware) <rostedt@goodmis.org>
Date:   Mon Feb 5 22:18:11 2018 -0500

    tracing: Fix parsing of globs with a wildcard at the beginning
    
    commit 07234021410bbc27b7c86c18de98616c29fbe667 upstream.
    
    Al Viro reported:
    
        For substring - sure, but what about something like "*a*b" and "a*b"?
        AFAICS, filter_parse_regex() ends up with identical results in both
        cases - MATCH_GLOB and *search = "a*b".  And no way for the caller
        to tell one from another.
    
    Testing this with the following:
    
     # cd /sys/kernel/tracing
     # echo '*raw*lock' > set_ftrace_filter
     bash: echo: write error: Invalid argument
    
    With this patch:
    
     # echo '*raw*lock' > set_ftrace_filter
     # cat set_ftrace_filter
    _raw_read_trylock
    _raw_write_trylock
    _raw_read_unlock
    _raw_spin_unlock
    _raw_write_unlock
    _raw_spin_trylock
    _raw_spin_lock
    _raw_write_lock
    _raw_read_lock
    
    Al recommended not setting the search buffer to skip the first '*' unless we
    know we are not using MATCH_GLOB. This implements his suggested logic.
    
    Link: http://lkml.kernel.org/r/20180127170748.GF13338@ZenIV.linux.org.uk
    
    Cc: stable@vger.kernel.org
    Fixes: 60f1d5e3bac44 ("ftrace: Support full glob matching")
    Reviewed-by: Masami Hiramatsu <mhiramat@kernel.org>
    Reported-by: Al Viro <viro@ZenIV.linux.org.uk>
    Suggsted-by: Al Viro <viro@ZenIV.linux.org.uk>
    Signed-off-by: Steven Rostedt (VMware) <rostedt@goodmis.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 95f92d0a0ca9dd0f4a92e9eb02b2b7b3d257d46f
Author: Steven Rostedt (VMware) <rostedt@goodmis.org>
Date:   Mon Feb 5 22:18:11 2018 -0500

    tracing: Fix parsing of globs with a wildcard at the beginning
    
    commit 07234021410bbc27b7c86c18de98616c29fbe667 upstream.
    
    Al Viro reported:
    
        For substring - sure, but what about something like "*a*b" and "a*b"?
        AFAICS, filter_parse_regex() ends up with identical results in both
        cases - MATCH_GLOB and *search = "a*b".  And no way for the caller
        to tell one from another.
    
    Testing this with the following:
    
     # cd /sys/kernel/tracing
     # echo '*raw*lock' > set_ftrace_filter
     bash: echo: write error: Invalid argument
    
    With this patch:
    
     # echo '*raw*lock' > set_ftrace_filter
     # cat set_ftrace_filter
    _raw_read_trylock
    _raw_write_trylock
    _raw_read_unlock
    _raw_spin_unlock
    _raw_write_unlock
    _raw_spin_trylock
    _raw_spin_lock
    _raw_write_lock
    _raw_read_lock
    
    Al recommended not setting the search buffer to skip the first '*' unless we
    know we are not using MATCH_GLOB. This implements his suggested logic.
    
    Link: http://lkml.kernel.org/r/20180127170748.GF13338@ZenIV.linux.org.uk
    
    Cc: stable@vger.kernel.org
    Fixes: 60f1d5e3bac44 ("ftrace: Support full glob matching")
    Reviewed-by: Masami Hiramatsu <mhiramat@kernel.org>
    Reported-by: Al Viro <viro@ZenIV.linux.org.uk>
    Suggsted-by: Al Viro <viro@ZenIV.linux.org.uk>
    Signed-off-by: Steven Rostedt (VMware) <rostedt@goodmis.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 07234021410bbc27b7c86c18de98616c29fbe667
Author: Steven Rostedt (VMware) <rostedt@goodmis.org>
Date:   Mon Feb 5 22:18:11 2018 -0500

    tracing: Fix parsing of globs with a wildcard at the beginning
    
    Al Viro reported:
    
        For substring - sure, but what about something like "*a*b" and "a*b"?
        AFAICS, filter_parse_regex() ends up with identical results in both
        cases - MATCH_GLOB and *search = "a*b".  And no way for the caller
        to tell one from another.
    
    Testing this with the following:
    
     # cd /sys/kernel/tracing
     # echo '*raw*lock' > set_ftrace_filter
     bash: echo: write error: Invalid argument
    
    With this patch:
    
     # echo '*raw*lock' > set_ftrace_filter
     # cat set_ftrace_filter
    _raw_read_trylock
    _raw_write_trylock
    _raw_read_unlock
    _raw_spin_unlock
    _raw_write_unlock
    _raw_spin_trylock
    _raw_spin_lock
    _raw_write_lock
    _raw_read_lock
    
    Al recommended not setting the search buffer to skip the first '*' unless we
    know we are not using MATCH_GLOB. This implements his suggested logic.
    
    Link: http://lkml.kernel.org/r/20180127170748.GF13338@ZenIV.linux.org.uk
    
    Cc: stable@vger.kernel.org
    Fixes: 60f1d5e3bac44 ("ftrace: Support full glob matching")
    Reviewed-by: Masami Hiramatsu <mhiramat@kernel.org>
    Reported-by: Al Viro <viro@ZenIV.linux.org.uk>
    Suggsted-by: Al Viro <viro@ZenIV.linux.org.uk>
    Signed-off-by: Steven Rostedt (VMware) <rostedt@goodmis.org>

commit ea05ba7c559c8e5a5946c3a94a2a266e9a6680a6
Author: Michael Bringmann <mwb@linux.vnet.ibm.com>
Date:   Tue Nov 28 16:58:40 2017 -0600

    powerpc/numa: Ensure nodes initialized for hotplug
    
    This patch fixes some problems encountered at runtime with
    configurations that support memory-less nodes, or that hot-add CPUs
    into nodes that are memoryless during system execution after boot. The
    problems of interest include:
    
    * Nodes known to powerpc to be memoryless at boot, but to have CPUs in
      them are allowed to be 'possible' and 'online'. Memory allocations
      for those nodes are taken from another node that does have memory
      until and if memory is hot-added to the node.
    
    * Nodes which have no resources assigned at boot, but which may still
      be referenced subsequently by affinity or associativity attributes,
      are kept in the list of 'possible' nodes for powerpc. Hot-add of
      memory or CPUs to the system can reference these nodes and bring
      them online instead of redirecting the references to one of the set
      of nodes known to have memory at boot.
    
    Note that this software operates under the context of CPU hotplug. We
    are not doing memory hotplug in this code, but rather updating the
    kernel's CPU topology (i.e. arch_update_cpu_topology /
    numa_update_cpu_topology). We are initializing a node that may be used
    by CPUs or memory before it can be referenced as invalid by a CPU
    hotplug operation. CPU hotplug operations are protected by a range of
    APIs including cpu_maps_update_begin/cpu_maps_update_done,
    cpus_read/write_lock / cpus_read/write_unlock, device locks, and more.
    Memory hotplug operations, including try_online_node, are protected by
    mem_hotplug_begin/mem_hotplug_done, device locks, and more. In the
    case of CPUs being hot-added to a previously memoryless node, the
    try_online_node operation occurs wholly within the CPU locks with no
    overlap. Using HMC hot-add/hot-remove operations, we have been able to
    add and remove CPUs to any possible node without failures. HMC
    operations involve a degree self-serialization, though.
    
    Signed-off-by: Michael Bringmann <mwb@linux.vnet.ibm.com>
    Reviewed-by: Nathan Fontenot <nfont@linux.vnet.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

commit 1ecbd7170d6579a1ee389a37bf1f0437ea01a388
Author: George Cherian <george.cherian@cavium.com>
Date:   Mon Dec 4 14:06:54 2017 +0000

    ACPI / CPPC: Fix KASAN global out of bounds warning
    
    Default value of pcc_subspace_idx is -1.
    Make sure to check pcc_subspace_idx before using the same as array index.
    This will avoid following KASAN warnings too.
    
    [   15.113449] ==================================================================
    [   15.116983] BUG: KASAN: global-out-of-bounds in cppc_get_perf_caps+0xf3/0x3b0
    [   15.116983] Read of size 8 at addr ffffffffb9a5c0d8 by task swapper/0/1
    [   15.116983] CPU: 3 PID: 1 Comm: swapper/0 Not tainted 4.15.0-rc2+ #2
    [   15.116983] Hardware name: Dell Inc. OptiPlex 7040/0Y7WYT, BIOS 1.2.8 01/26/2016
    [   15.116983] Call Trace:
    [   15.116983]  dump_stack+0x7c/0xbb
    [   15.116983]  print_address_description+0x1df/0x290
    [   15.116983]  kasan_report+0x28a/0x370
    [   15.116983]  ? cppc_get_perf_caps+0xf3/0x3b0
    [   15.116983]  cppc_get_perf_caps+0xf3/0x3b0
    [   15.116983]  ? cpc_read+0x210/0x210
    [   15.116983]  ? __rdmsr_on_cpu+0x90/0x90
    [   15.116983]  ? rdmsrl_on_cpu+0xa9/0xe0
    [   15.116983]  ? rdmsr_on_cpu+0x100/0x100
    [   15.116983]  ? wrmsrl_on_cpu+0x9c/0xd0
    [   15.116983]  ? wrmsrl_on_cpu+0x9c/0xd0
    [   15.116983]  ? wrmsr_on_cpu+0xe0/0xe0
    [   15.116983]  __intel_pstate_cpu_init.part.16+0x3a2/0x530
    [   15.116983]  ? intel_pstate_init_cpu+0x197/0x390
    [   15.116983]  ? show_no_turbo+0xe0/0xe0
    [   15.116983]  ? __lockdep_init_map+0xa0/0x290
    [   15.116983]  intel_pstate_cpu_init+0x30/0x60
    [   15.116983]  cpufreq_online+0x155/0xac0
    [   15.116983]  cpufreq_add_dev+0x9b/0xb0
    [   15.116983]  subsys_interface_register+0x1ae/0x290
    [   15.116983]  ? bus_unregister_notifier+0x40/0x40
    [   15.116983]  ? mark_held_locks+0x83/0xb0
    [   15.116983]  ? _raw_write_unlock_irqrestore+0x32/0x60
    [   15.116983]  ? intel_pstate_setup+0xc/0x104
    [   15.116983]  ? intel_pstate_setup+0xc/0x104
    [   15.116983]  ? cpufreq_register_driver+0x1ce/0x2b0
    [   15.116983]  cpufreq_register_driver+0x1ce/0x2b0
    [   15.116983]  ? intel_pstate_setup+0x104/0x104
    [   15.116983]  intel_pstate_register_driver+0x3a/0xa0
    [   15.116983]  intel_pstate_init+0x3c4/0x434
    [   15.116983]  ? intel_pstate_setup+0x104/0x104
    [   15.116983]  ? intel_pstate_setup+0x104/0x104
    [   15.116983]  do_one_initcall+0x9c/0x206
    [   15.116983]  ? parameq+0xa0/0xa0
    [   15.116983]  ? initcall_blacklisted+0x150/0x150
    [   15.116983]  ? lock_downgrade+0x2c0/0x2c0
    [   15.116983]  kernel_init_freeable+0x327/0x3f0
    [   15.116983]  ? start_kernel+0x612/0x612
    [   15.116983]  ? _raw_spin_unlock_irq+0x29/0x40
    [   15.116983]  ? finish_task_switch+0xdd/0x320
    [   15.116983]  ? finish_task_switch+0x8e/0x320
    [   15.116983]  ? rest_init+0xd0/0xd0
    [   15.116983]  kernel_init+0xf/0x11a
    [   15.116983]  ? rest_init+0xd0/0xd0
    [   15.116983]  ret_from_fork+0x24/0x30
    
    [   15.116983] The buggy address belongs to the variable:
    [   15.116983]  __key.36299+0x38/0x40
    
    [   15.116983] Memory state around the buggy address:
    [   15.116983]  ffffffffb9a5bf80: fa fa fa fa 00 fa fa fa fa fa fa fa 00 fa fa fa
    [   15.116983]  ffffffffb9a5c000: fa fa fa fa 00 fa fa fa fa fa fa fa 00 fa fa fa
    [   15.116983] >ffffffffb9a5c080: fa fa fa fa 00 fa fa fa fa fa fa fa 00 00 00 00
    [   15.116983]                                                     ^
    [   15.116983]  ffffffffb9a5c100: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    [   15.116983]  ffffffffb9a5c180: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    [   15.116983] ==================================================================
    
    Fixes: 85b1407bf6d2 (ACPI / CPPC: Make CPPC ACPI driver aware of PCC subspace IDs)
    Reported-by: Changbin Du <changbin.du@intel.com>
    Signed-off-by: George Cherian <george.cherian@cavium.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 69af22696bc737dfe3444d2ece5db000fbff5c35
Author: John Johansen <john.johansen@canonical.com>
Date:   Wed Nov 22 07:33:38 2017 -0800

    apparmor: fix oops in audit_signal_cb hook
    
    commit b12cbb21586277f72533769832c24cc6c1d60ab3 upstream.
    
    The apparmor_audit_data struct ordering got messed up during a merge
    conflict, resulting in the signal integer and peer pointer being in
    a union instead of a struct.
    
    For most of the 4.13 and 4.14 life cycle, this was hidden by
    commit 651e28c5537a ("apparmor: add base infastructure for socket
    mediation") which fixed the apparmor_audit_data struct when its data
    was added. When that commit was reverted in -rc7 the signal audit bug
    was exposed, and unfortunately it never showed up in any of the
    testing until after 4.14 was released. Shaun Khan, Zephaniah
    E. Loss-Cutler-Hull filed nearly simultaneous bug reports (with
    different oopes, the smaller of which is included below).
    
    Full credit goes to Tetsuo Handa for jumping on this as well and
    noticing the audit data struct problem and reporting it.
    
    [   76.178568] BUG: unable to handle kernel paging request at
    ffffffff0eee3bc0
    [   76.178579] IP: audit_signal_cb+0x6c/0xe0
    [   76.178581] PGD 1a640a067 P4D 1a640a067 PUD 0
    [   76.178586] Oops: 0000 [#1] PREEMPT SMP
    [   76.178589] Modules linked in: fuse rfcomm bnep usblp uvcvideo btusb
    btrtl btbcm btintel bluetooth ecdh_generic ip6table_filter ip6_tables
    xt_tcpudp nf_conntrack_ipv4 nf_defrag_ipv4 xt_conntrack nf_conntrack
    iptable_filter ip_tables x_tables intel_rapl joydev wmi_bmof serio_raw
    iwldvm iwlwifi shpchp kvm_intel kvm irqbypass autofs4 algif_skcipher
    nls_iso8859_1 nls_cp437 crc32_pclmul ghash_clmulni_intel
    [   76.178620] CPU: 0 PID: 10675 Comm: pidgin Not tainted
    4.14.0-f1-dirty #135
    [   76.178623] Hardware name: Hewlett-Packard HP EliteBook Folio
    9470m/18DF, BIOS 68IBD Ver. F.62 10/22/2015
    [   76.178625] task: ffff9c7a94c31dc0 task.stack: ffffa09b02a4c000
    [   76.178628] RIP: 0010:audit_signal_cb+0x6c/0xe0
    [   76.178631] RSP: 0018:ffffa09b02a4fc08 EFLAGS: 00010292
    [   76.178634] RAX: ffffa09b02a4fd60 RBX: ffff9c7aee0741f8 RCX:
    0000000000000000
    [   76.178636] RDX: ffffffffee012290 RSI: 0000000000000006 RDI:
    ffff9c7a9493d800
    [   76.178638] RBP: ffffa09b02a4fd40 R08: 000000000000004d R09:
    ffffa09b02a4fc46
    [   76.178641] R10: ffffa09b02a4fcb8 R11: ffff9c7ab44f5072 R12:
    ffffa09b02a4fd40
    [   76.178643] R13: ffffffff9e447be0 R14: ffff9c7a94c31dc0 R15:
    0000000000000001
    [   76.178646] FS:  00007f8b11ba2a80(0000) GS:ffff9c7afea00000(0000)
    knlGS:0000000000000000
    [   76.178648] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [   76.178650] CR2: ffffffff0eee3bc0 CR3: 00000003d5209002 CR4:
    00000000001606f0
    [   76.178652] Call Trace:
    [   76.178660]  common_lsm_audit+0x1da/0x780
    [   76.178665]  ? d_absolute_path+0x60/0x90
    [   76.178669]  ? aa_check_perms+0xcd/0xe0
    [   76.178672]  aa_check_perms+0xcd/0xe0
    [   76.178675]  profile_signal_perm.part.0+0x90/0xa0
    [   76.178679]  aa_may_signal+0x16e/0x1b0
    [   76.178686]  apparmor_task_kill+0x51/0x120
    [   76.178690]  security_task_kill+0x44/0x60
    [   76.178695]  group_send_sig_info+0x25/0x60
    [   76.178699]  kill_pid_info+0x36/0x60
    [   76.178703]  SYSC_kill+0xdb/0x180
    [   76.178707]  ? preempt_count_sub+0x92/0xd0
    [   76.178712]  ? _raw_write_unlock_irq+0x13/0x30
    [   76.178716]  ? task_work_run+0x6a/0x90
    [   76.178720]  ? exit_to_usermode_loop+0x80/0xa0
    [   76.178723]  entry_SYSCALL_64_fastpath+0x13/0x94
    [   76.178727] RIP: 0033:0x7f8b0e58b767
    [   76.178729] RSP: 002b:00007fff19efd4d8 EFLAGS: 00000206 ORIG_RAX:
    000000000000003e
    [   76.178732] RAX: ffffffffffffffda RBX: 0000557f3e3c2050 RCX:
    00007f8b0e58b767
    [   76.178735] RDX: 0000000000000000 RSI: 0000000000000000 RDI:
    000000000000263b
    [   76.178737] RBP: 0000000000000000 R08: 0000557f3e3c2270 R09:
    0000000000000001
    [   76.178739] R10: 000000000000022d R11: 0000000000000206 R12:
    0000000000000000
    [   76.178741] R13: 0000000000000001 R14: 0000557f3e3c13c0 R15:
    0000000000000000
    [   76.178745] Code: 48 8b 55 18 48 89 df 41 b8 20 00 08 01 5b 5d 48 8b
    42 10 48 8b 52 30 48 63 48 4c 48 8b 44 c8 48 31 c9 48 8b 70 38 e9 f4 fd
    00 00 <48> 8b 14 d5 40 27 e5 9e 48 c7 c6 7d 07 19 9f 48 89 df e8 fd 35
    [   76.178794] RIP: audit_signal_cb+0x6c/0xe0 RSP: ffffa09b02a4fc08
    [   76.178796] CR2: ffffffff0eee3bc0
    [   76.178799] ---[ end trace 514af9529297f1a3 ]---
    
    Fixes: cd1dbf76b23d ("apparmor: add the ability to mediate signals")
    Reported-by: Zephaniah E. Loss-Cutler-Hull <warp-spam_kernel@aehallh.com>
    Reported-by: Shuah Khan <shuahkh@osg.samsung.com>
    Suggested-by: Tetsuo Handa <penguin-kernel@i-love.sakura.ne.jp>
    Tested-by: Ivan Kozik <ivan@ludios.org>
    Tested-by: Zephaniah E. Loss-Cutler-Hull <warp-spam_kernel@aehallh.com>
    Tested-by: Christian Boltz <apparmor@cboltz.de>
    Tested-by: Shuah Khan <shuahkh@osg.samsung.com>
    Signed-off-by: John Johansen <john.johansen@canonical.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit b12cbb21586277f72533769832c24cc6c1d60ab3
Author: John Johansen <john.johansen@canonical.com>
Date:   Wed Nov 22 07:33:38 2017 -0800

    apparmor: fix oops in audit_signal_cb hook
    
    The apparmor_audit_data struct ordering got messed up during a merge
    conflict, resulting in the signal integer and peer pointer being in
    a union instead of a struct.
    
    For most of the 4.13 and 4.14 life cycle, this was hidden by
    commit 651e28c5537a ("apparmor: add base infastructure for socket
    mediation") which fixed the apparmor_audit_data struct when its data
    was added. When that commit was reverted in -rc7 the signal audit bug
    was exposed, and unfortunately it never showed up in any of the
    testing until after 4.14 was released. Shaun Khan, Zephaniah
    E. Loss-Cutler-Hull filed nearly simultaneous bug reports (with
    different oopes, the smaller of which is included below).
    
    Full credit goes to Tetsuo Handa for jumping on this as well and
    noticing the audit data struct problem and reporting it.
    
    [   76.178568] BUG: unable to handle kernel paging request at
    ffffffff0eee3bc0
    [   76.178579] IP: audit_signal_cb+0x6c/0xe0
    [   76.178581] PGD 1a640a067 P4D 1a640a067 PUD 0
    [   76.178586] Oops: 0000 [#1] PREEMPT SMP
    [   76.178589] Modules linked in: fuse rfcomm bnep usblp uvcvideo btusb
    btrtl btbcm btintel bluetooth ecdh_generic ip6table_filter ip6_tables
    xt_tcpudp nf_conntrack_ipv4 nf_defrag_ipv4 xt_conntrack nf_conntrack
    iptable_filter ip_tables x_tables intel_rapl joydev wmi_bmof serio_raw
    iwldvm iwlwifi shpchp kvm_intel kvm irqbypass autofs4 algif_skcipher
    nls_iso8859_1 nls_cp437 crc32_pclmul ghash_clmulni_intel
    [   76.178620] CPU: 0 PID: 10675 Comm: pidgin Not tainted
    4.14.0-f1-dirty #135
    [   76.178623] Hardware name: Hewlett-Packard HP EliteBook Folio
    9470m/18DF, BIOS 68IBD Ver. F.62 10/22/2015
    [   76.178625] task: ffff9c7a94c31dc0 task.stack: ffffa09b02a4c000
    [   76.178628] RIP: 0010:audit_signal_cb+0x6c/0xe0
    [   76.178631] RSP: 0018:ffffa09b02a4fc08 EFLAGS: 00010292
    [   76.178634] RAX: ffffa09b02a4fd60 RBX: ffff9c7aee0741f8 RCX:
    0000000000000000
    [   76.178636] RDX: ffffffffee012290 RSI: 0000000000000006 RDI:
    ffff9c7a9493d800
    [   76.178638] RBP: ffffa09b02a4fd40 R08: 000000000000004d R09:
    ffffa09b02a4fc46
    [   76.178641] R10: ffffa09b02a4fcb8 R11: ffff9c7ab44f5072 R12:
    ffffa09b02a4fd40
    [   76.178643] R13: ffffffff9e447be0 R14: ffff9c7a94c31dc0 R15:
    0000000000000001
    [   76.178646] FS:  00007f8b11ba2a80(0000) GS:ffff9c7afea00000(0000)
    knlGS:0000000000000000
    [   76.178648] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [   76.178650] CR2: ffffffff0eee3bc0 CR3: 00000003d5209002 CR4:
    00000000001606f0
    [   76.178652] Call Trace:
    [   76.178660]  common_lsm_audit+0x1da/0x780
    [   76.178665]  ? d_absolute_path+0x60/0x90
    [   76.178669]  ? aa_check_perms+0xcd/0xe0
    [   76.178672]  aa_check_perms+0xcd/0xe0
    [   76.178675]  profile_signal_perm.part.0+0x90/0xa0
    [   76.178679]  aa_may_signal+0x16e/0x1b0
    [   76.178686]  apparmor_task_kill+0x51/0x120
    [   76.178690]  security_task_kill+0x44/0x60
    [   76.178695]  group_send_sig_info+0x25/0x60
    [   76.178699]  kill_pid_info+0x36/0x60
    [   76.178703]  SYSC_kill+0xdb/0x180
    [   76.178707]  ? preempt_count_sub+0x92/0xd0
    [   76.178712]  ? _raw_write_unlock_irq+0x13/0x30
    [   76.178716]  ? task_work_run+0x6a/0x90
    [   76.178720]  ? exit_to_usermode_loop+0x80/0xa0
    [   76.178723]  entry_SYSCALL_64_fastpath+0x13/0x94
    [   76.178727] RIP: 0033:0x7f8b0e58b767
    [   76.178729] RSP: 002b:00007fff19efd4d8 EFLAGS: 00000206 ORIG_RAX:
    000000000000003e
    [   76.178732] RAX: ffffffffffffffda RBX: 0000557f3e3c2050 RCX:
    00007f8b0e58b767
    [   76.178735] RDX: 0000000000000000 RSI: 0000000000000000 RDI:
    000000000000263b
    [   76.178737] RBP: 0000000000000000 R08: 0000557f3e3c2270 R09:
    0000000000000001
    [   76.178739] R10: 000000000000022d R11: 0000000000000206 R12:
    0000000000000000
    [   76.178741] R13: 0000000000000001 R14: 0000557f3e3c13c0 R15:
    0000000000000000
    [   76.178745] Code: 48 8b 55 18 48 89 df 41 b8 20 00 08 01 5b 5d 48 8b
    42 10 48 8b 52 30 48 63 48 4c 48 8b 44 c8 48 31 c9 48 8b 70 38 e9 f4 fd
    00 00 <48> 8b 14 d5 40 27 e5 9e 48 c7 c6 7d 07 19 9f 48 89 df e8 fd 35
    [   76.178794] RIP: audit_signal_cb+0x6c/0xe0 RSP: ffffa09b02a4fc08
    [   76.178796] CR2: ffffffff0eee3bc0
    [   76.178799] ---[ end trace 514af9529297f1a3 ]---
    
    Fixes: cd1dbf76b23d ("apparmor: add the ability to mediate signals")
    Reported-by: Zephaniah E. Loss-Cutler-Hull <warp-spam_kernel@aehallh.com>
    Reported-by: Shuah Khan <shuahkh@osg.samsung.com>
    Suggested-by: Tetsuo Handa <penguin-kernel@i-love.sakura.ne.jp>
    Tested-by: Ivan Kozik <ivan@ludios.org>
    Tested-by: Zephaniah E. Loss-Cutler-Hull <warp-spam_kernel@aehallh.com>
    Tested-by: Christian Boltz <apparmor@cboltz.de>
    Tested-by: Shuah Khan <shuahkh@osg.samsung.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: John Johansen <john.johansen@canonical.com>

commit c7584c095b02eee50c311e1a17afb228c391a1ba
Author: Tang Junhui <tang.junhui@zte.com.cn>
Date:   Wed Sep 6 14:25:59 2017 +0800

    bcache: fix for gc and write-back race
    
    commit 9baf30972b5568d8b5bc8b3c46a6ec5b58100463 upstream.
    
    gc and write-back get raced (see the email "bcache get stucked" I sended
    before):
    gc thread                               write-back thread
    |                                       |bch_writeback_thread()
    |bch_gc_thread()                        |
    |                                       |==>read_dirty()
    |==>bch_btree_gc()                      |
    |==>btree_root() //get btree root       |
    |                //node write locker    |
    |==>bch_btree_gc_root()                 |
    |                                       |==>read_dirty_submit()
    |                                       |==>write_dirty()
    |                                       |==>continue_at(cl,
    |                                       |               write_dirty_finish,
    |                                       |               system_wq);
    |                                       |==>write_dirty_finish()//excute
    |                                       |               //in system_wq
    |                                       |==>bch_btree_insert()
    |                                       |==>bch_btree_map_leaf_nodes()
    |                                       |==>__bch_btree_map_nodes()
    |                                       |==>btree_root //try to get btree
    |                                       |              //root node read
    |                                       |              //lock
    |                                       |-----stuck here
    |==>bch_btree_set_root()
    |==>bch_journal_meta()
    |==>bch_journal()
    |==>journal_try_write()
    |==>journal_write_unlocked() //journal_full(&c->journal)
    |                            //condition satisfied
    |==>continue_at(cl, journal_write, system_wq); //try to excute
    |                               //journal_write in system_wq
    |                               //but work queue is excuting
    |                               //write_dirty_finish()
    |==>closure_sync(); //wait journal_write execute
    |                   //over and wake up gc,
    |-------------stuck here
    |==>release root node write locker
    
    This patch alloc a separate work-queue for write-back thread to avoid such
    race.
    
    (Commit log re-organized by Coly Li to pass checkpatch.pl checking)
    
    Signed-off-by: Tang Junhui <tang.junhui@zte.com.cn>
    Acked-by: Coly Li <colyli@suse.de>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>
    [bwh: Backported to 3.16: adjust context]
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit ce04caa126bc701fe4e3d59b49962f9a99e9c6c8
Author: Tang Junhui <tang.junhui@zte.com.cn>
Date:   Wed Sep 6 14:25:59 2017 +0800

    bcache: fix for gc and write-back race
    
    [ Upstream commit 9baf30972b5568d8b5bc8b3c46a6ec5b58100463 ]
    
    gc and write-back get raced (see the email "bcache get stucked" I sended
    before):
    gc thread                               write-back thread
    |                                       |bch_writeback_thread()
    |bch_gc_thread()                        |
    |                                       |==>read_dirty()
    |==>bch_btree_gc()                      |
    |==>btree_root() //get btree root       |
    |                //node write locker    |
    |==>bch_btree_gc_root()                 |
    |                                       |==>read_dirty_submit()
    |                                       |==>write_dirty()
    |                                       |==>continue_at(cl,
    |                                       |               write_dirty_finish,
    |                                       |               system_wq);
    |                                       |==>write_dirty_finish()//excute
    |                                       |               //in system_wq
    |                                       |==>bch_btree_insert()
    |                                       |==>bch_btree_map_leaf_nodes()
    |                                       |==>__bch_btree_map_nodes()
    |                                       |==>btree_root //try to get btree
    |                                       |              //root node read
    |                                       |              //lock
    |                                       |-----stuck here
    |==>bch_btree_set_root()
    |==>bch_journal_meta()
    |==>bch_journal()
    |==>journal_try_write()
    |==>journal_write_unlocked() //journal_full(&c->journal)
    |                            //condition satisfied
    |==>continue_at(cl, journal_write, system_wq); //try to excute
    |                               //journal_write in system_wq
    |                               //but work queue is excuting
    |                               //write_dirty_finish()
    |==>closure_sync(); //wait journal_write execute
    |                   //over and wake up gc,
    |-------------stuck here
    |==>release root node write locker
    
    This patch alloc a separate work-queue for write-back thread to avoid such
    race.
    
    (Commit log re-organized by Coly Li to pass checkpatch.pl checking)
    
    Signed-off-by: Tang Junhui <tang.junhui@zte.com.cn>
    Acked-by: Coly Li <colyli@suse.de>
    Cc: stable@vger.kernel.org
    Signed-off-by: Jens Axboe <axboe@kernel.dk>
    Signed-off-by: Sasha Levin <alexander.levin@verizon.com>

commit 16b8488fb369162e93ba886ac28927a8679e74c1
Author: Eric Dumazet <edumazet@google.com>
Date:   Wed Aug 16 07:03:15 2017 -0700

    dccp: defer ccid_hc_tx_delete() at dismantle time
    
    [ Upstream commit 120e9dabaf551c6dc03d3a10a1f026376cb1811c ]
    
    syszkaller team reported another problem in DCCP [1]
    
    Problem here is that the structure holding RTO timer
    (ccid2_hc_tx_rto_expire() handler) is freed too soon.
    
    We can not use del_timer_sync() to cancel the timer
    since this timer wants to grab socket lock (that would risk a dead lock)
    
    Solution is to defer the freeing of memory when all references to
    the socket were released. Socket timers do own a reference, so this
    should fix the issue.
    
    [1]
    
    ==================================================================
    BUG: KASAN: use-after-free in ccid2_hc_tx_rto_expire+0x51c/0x5c0 net/dccp/ccids/ccid2.c:144
    Read of size 4 at addr ffff8801d2660540 by task kworker/u4:7/3365
    
    CPU: 1 PID: 3365 Comm: kworker/u4:7 Not tainted 4.13.0-rc4+ #3
    Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011
    Workqueue: events_unbound call_usermodehelper_exec_work
    Call Trace:
     <IRQ>
     __dump_stack lib/dump_stack.c:16 [inline]
     dump_stack+0x194/0x257 lib/dump_stack.c:52
     print_address_description+0x73/0x250 mm/kasan/report.c:252
     kasan_report_error mm/kasan/report.c:351 [inline]
     kasan_report+0x24e/0x340 mm/kasan/report.c:409
     __asan_report_load4_noabort+0x14/0x20 mm/kasan/report.c:429
     ccid2_hc_tx_rto_expire+0x51c/0x5c0 net/dccp/ccids/ccid2.c:144
     call_timer_fn+0x233/0x830 kernel/time/timer.c:1268
     expire_timers kernel/time/timer.c:1307 [inline]
     __run_timers+0x7fd/0xb90 kernel/time/timer.c:1601
     run_timer_softirq+0x21/0x80 kernel/time/timer.c:1614
     __do_softirq+0x2f5/0xba3 kernel/softirq.c:284
     invoke_softirq kernel/softirq.c:364 [inline]
     irq_exit+0x1cc/0x200 kernel/softirq.c:405
     exiting_irq arch/x86/include/asm/apic.h:638 [inline]
     smp_apic_timer_interrupt+0x76/0xa0 arch/x86/kernel/apic/apic.c:1044
     apic_timer_interrupt+0x93/0xa0 arch/x86/entry/entry_64.S:702
    RIP: 0010:arch_local_irq_enable arch/x86/include/asm/paravirt.h:824 [inline]
    RIP: 0010:__raw_write_unlock_irq include/linux/rwlock_api_smp.h:267 [inline]
    RIP: 0010:_raw_write_unlock_irq+0x56/0x70 kernel/locking/spinlock.c:343
    RSP: 0018:ffff8801cd50eaa8 EFLAGS: 00000286 ORIG_RAX: ffffffffffffff10
    RAX: dffffc0000000000 RBX: ffffffff85a090c0 RCX: 0000000000000006
    RDX: 1ffffffff0b595f3 RSI: 1ffff1003962f989 RDI: ffffffff85acaf98
    RBP: ffff8801cd50eab0 R08: 0000000000000001 R09: 0000000000000000
    R10: 0000000000000000 R11: 0000000000000000 R12: ffff8801cc96ea60
    R13: dffffc0000000000 R14: ffff8801cc96e4c0 R15: ffff8801cc96e4c0
     </IRQ>
     release_task+0xe9e/0x1a40 kernel/exit.c:220
     wait_task_zombie kernel/exit.c:1162 [inline]
     wait_consider_task+0x29b8/0x33c0 kernel/exit.c:1389
     do_wait_thread kernel/exit.c:1452 [inline]
     do_wait+0x441/0xa90 kernel/exit.c:1523
     kernel_wait4+0x1f5/0x370 kernel/exit.c:1665
     SYSC_wait4+0x134/0x140 kernel/exit.c:1677
     SyS_wait4+0x2c/0x40 kernel/exit.c:1673
     call_usermodehelper_exec_sync kernel/kmod.c:286 [inline]
     call_usermodehelper_exec_work+0x1a0/0x2c0 kernel/kmod.c:323
     process_one_work+0xbf3/0x1bc0 kernel/workqueue.c:2097
     worker_thread+0x223/0x1860 kernel/workqueue.c:2231
     kthread+0x35e/0x430 kernel/kthread.c:231
     ret_from_fork+0x2a/0x40 arch/x86/entry/entry_64.S:425
    
    Allocated by task 21267:
     save_stack_trace+0x16/0x20 arch/x86/kernel/stacktrace.c:59
     save_stack+0x43/0xd0 mm/kasan/kasan.c:447
     set_track mm/kasan/kasan.c:459 [inline]
     kasan_kmalloc+0xad/0xe0 mm/kasan/kasan.c:551
     kasan_slab_alloc+0x12/0x20 mm/kasan/kasan.c:489
     kmem_cache_alloc+0x127/0x750 mm/slab.c:3561
     ccid_new+0x20e/0x390 net/dccp/ccid.c:151
     dccp_hdlr_ccid+0x27/0x140 net/dccp/feat.c:44
     __dccp_feat_activate+0x142/0x2a0 net/dccp/feat.c:344
     dccp_feat_activate_values+0x34e/0xa90 net/dccp/feat.c:1538
     dccp_rcv_request_sent_state_process net/dccp/input.c:472 [inline]
     dccp_rcv_state_process+0xed1/0x1620 net/dccp/input.c:677
     dccp_v4_do_rcv+0xeb/0x160 net/dccp/ipv4.c:679
     sk_backlog_rcv include/net/sock.h:911 [inline]
     __release_sock+0x124/0x360 net/core/sock.c:2269
     release_sock+0xa4/0x2a0 net/core/sock.c:2784
     inet_wait_for_connect net/ipv4/af_inet.c:557 [inline]
     __inet_stream_connect+0x671/0xf00 net/ipv4/af_inet.c:643
     inet_stream_connect+0x58/0xa0 net/ipv4/af_inet.c:682
     SYSC_connect+0x204/0x470 net/socket.c:1642
     SyS_connect+0x24/0x30 net/socket.c:1623
     entry_SYSCALL_64_fastpath+0x1f/0xbe
    
    Freed by task 3049:
     save_stack_trace+0x16/0x20 arch/x86/kernel/stacktrace.c:59
     save_stack+0x43/0xd0 mm/kasan/kasan.c:447
     set_track mm/kasan/kasan.c:459 [inline]
     kasan_slab_free+0x71/0xc0 mm/kasan/kasan.c:524
     __cache_free mm/slab.c:3503 [inline]
     kmem_cache_free+0x77/0x280 mm/slab.c:3763
     ccid_hc_tx_delete+0xc5/0x100 net/dccp/ccid.c:190
     dccp_destroy_sock+0x1d1/0x2b0 net/dccp/proto.c:225
     inet_csk_destroy_sock+0x166/0x3f0 net/ipv4/inet_connection_sock.c:833
     dccp_done+0xb7/0xd0 net/dccp/proto.c:145
     dccp_time_wait+0x13d/0x300 net/dccp/minisocks.c:72
     dccp_rcv_reset+0x1d1/0x5b0 net/dccp/input.c:160
     dccp_rcv_state_process+0x8fc/0x1620 net/dccp/input.c:663
     dccp_v4_do_rcv+0xeb/0x160 net/dccp/ipv4.c:679
     sk_backlog_rcv include/net/sock.h:911 [inline]
     __sk_receive_skb+0x33e/0xc00 net/core/sock.c:521
     dccp_v4_rcv+0xef1/0x1c00 net/dccp/ipv4.c:871
     ip_local_deliver_finish+0x2e2/0xba0 net/ipv4/ip_input.c:216
     NF_HOOK include/linux/netfilter.h:248 [inline]
     ip_local_deliver+0x1ce/0x6d0 net/ipv4/ip_input.c:257
     dst_input include/net/dst.h:477 [inline]
     ip_rcv_finish+0x8db/0x19c0 net/ipv4/ip_input.c:397
     NF_HOOK include/linux/netfilter.h:248 [inline]
     ip_rcv+0xc3f/0x17d0 net/ipv4/ip_input.c:488
     __netif_receive_skb_core+0x19af/0x33d0 net/core/dev.c:4417
     __netif_receive_skb+0x2c/0x1b0 net/core/dev.c:4455
     process_backlog+0x203/0x740 net/core/dev.c:5130
     napi_poll net/core/dev.c:5527 [inline]
     net_rx_action+0x792/0x1910 net/core/dev.c:5593
     __do_softirq+0x2f5/0xba3 kernel/softirq.c:284
    
    The buggy address belongs to the object at ffff8801d2660100
     which belongs to the cache ccid2_hc_tx_sock of size 1240
    The buggy address is located 1088 bytes inside of
     1240-byte region [ffff8801d2660100, ffff8801d26605d8)
    The buggy address belongs to the page:
    page:ffffea0007499800 count:1 mapcount:0 mapping:ffff8801d2660100 index:0x0 compound_mapcount: 0
    flags: 0x200000000008100(slab|head)
    raw: 0200000000008100 ffff8801d2660100 0000000000000000 0000000100000005
    raw: ffffea00075271a0 ffffea0007538820 ffff8801d3aef9c0 0000000000000000
    page dumped because: kasan: bad access detected
    
    Memory state around the buggy address:
     ffff8801d2660400: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
     ffff8801d2660480: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    >ffff8801d2660500: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
                                               ^
     ffff8801d2660580: fb fb fb fb fb fb fb fb fb fb fb fc fc fc fc fc
     ffff8801d2660600: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
    ==================================================================
    
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Reported-by: Dmitry Vyukov <dvyukov@google.com>
    Cc: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sasha Levin <alexander.levin@verizon.com>

commit 5e0693d40d2c0a875bb17f8d022be665352dcef6
Author: Tang Junhui <tang.junhui@zte.com.cn>
Date:   Wed Sep 6 14:25:59 2017 +0800

    bcache: fix for gc and write-back race
    
    commit 9baf30972b5568d8b5bc8b3c46a6ec5b58100463 upstream.
    
    gc and write-back get raced (see the email "bcache get stucked" I sended
    before):
    gc thread                               write-back thread
    |                                       |bch_writeback_thread()
    |bch_gc_thread()                        |
    |                                       |==>read_dirty()
    |==>bch_btree_gc()                      |
    |==>btree_root() //get btree root       |
    |                //node write locker    |
    |==>bch_btree_gc_root()                 |
    |                                       |==>read_dirty_submit()
    |                                       |==>write_dirty()
    |                                       |==>continue_at(cl,
    |                                       |               write_dirty_finish,
    |                                       |               system_wq);
    |                                       |==>write_dirty_finish()//excute
    |                                       |               //in system_wq
    |                                       |==>bch_btree_insert()
    |                                       |==>bch_btree_map_leaf_nodes()
    |                                       |==>__bch_btree_map_nodes()
    |                                       |==>btree_root //try to get btree
    |                                       |              //root node read
    |                                       |              //lock
    |                                       |-----stuck here
    |==>bch_btree_set_root()
    |==>bch_journal_meta()
    |==>bch_journal()
    |==>journal_try_write()
    |==>journal_write_unlocked() //journal_full(&c->journal)
    |                            //condition satisfied
    |==>continue_at(cl, journal_write, system_wq); //try to excute
    |                               //journal_write in system_wq
    |                               //but work queue is excuting
    |                               //write_dirty_finish()
    |==>closure_sync(); //wait journal_write execute
    |                   //over and wake up gc,
    |-------------stuck here
    |==>release root node write locker
    
    This patch alloc a separate work-queue for write-back thread to avoid such
    race.
    
    (Commit log re-organized by Coly Li to pass checkpatch.pl checking)
    
    Signed-off-by: Tang Junhui <tang.junhui@zte.com.cn>
    Acked-by: Coly Li <colyli@suse.de>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 57aa1a6967b28431d62beec299125a969a469f3f
Author: Tang Junhui <tang.junhui@zte.com.cn>
Date:   Wed Sep 6 14:25:59 2017 +0800

    bcache: fix for gc and write-back race
    
    commit 9baf30972b5568d8b5bc8b3c46a6ec5b58100463 upstream.
    
    gc and write-back get raced (see the email "bcache get stucked" I sended
    before):
    gc thread                               write-back thread
    |                                       |bch_writeback_thread()
    |bch_gc_thread()                        |
    |                                       |==>read_dirty()
    |==>bch_btree_gc()                      |
    |==>btree_root() //get btree root       |
    |                //node write locker    |
    |==>bch_btree_gc_root()                 |
    |                                       |==>read_dirty_submit()
    |                                       |==>write_dirty()
    |                                       |==>continue_at(cl,
    |                                       |               write_dirty_finish,
    |                                       |               system_wq);
    |                                       |==>write_dirty_finish()//excute
    |                                       |               //in system_wq
    |                                       |==>bch_btree_insert()
    |                                       |==>bch_btree_map_leaf_nodes()
    |                                       |==>__bch_btree_map_nodes()
    |                                       |==>btree_root //try to get btree
    |                                       |              //root node read
    |                                       |              //lock
    |                                       |-----stuck here
    |==>bch_btree_set_root()
    |==>bch_journal_meta()
    |==>bch_journal()
    |==>journal_try_write()
    |==>journal_write_unlocked() //journal_full(&c->journal)
    |                            //condition satisfied
    |==>continue_at(cl, journal_write, system_wq); //try to excute
    |                               //journal_write in system_wq
    |                               //but work queue is excuting
    |                               //write_dirty_finish()
    |==>closure_sync(); //wait journal_write execute
    |                   //over and wake up gc,
    |-------------stuck here
    |==>release root node write locker
    
    This patch alloc a separate work-queue for write-back thread to avoid such
    race.
    
    (Commit log re-organized by Coly Li to pass checkpatch.pl checking)
    
    Signed-off-by: Tang Junhui <tang.junhui@zte.com.cn>
    Acked-by: Coly Li <colyli@suse.de>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit f522051a84e566b5552b3ba6127184d9cba54120
Author: Tang Junhui <tang.junhui@zte.com.cn>
Date:   Wed Sep 6 14:25:59 2017 +0800

    bcache: fix for gc and write-back race
    
    commit 9baf30972b5568d8b5bc8b3c46a6ec5b58100463 upstream.
    
    gc and write-back get raced (see the email "bcache get stucked" I sended
    before):
    gc thread                               write-back thread
    |                                       |bch_writeback_thread()
    |bch_gc_thread()                        |
    |                                       |==>read_dirty()
    |==>bch_btree_gc()                      |
    |==>btree_root() //get btree root       |
    |                //node write locker    |
    |==>bch_btree_gc_root()                 |
    |                                       |==>read_dirty_submit()
    |                                       |==>write_dirty()
    |                                       |==>continue_at(cl,
    |                                       |               write_dirty_finish,
    |                                       |               system_wq);
    |                                       |==>write_dirty_finish()//excute
    |                                       |               //in system_wq
    |                                       |==>bch_btree_insert()
    |                                       |==>bch_btree_map_leaf_nodes()
    |                                       |==>__bch_btree_map_nodes()
    |                                       |==>btree_root //try to get btree
    |                                       |              //root node read
    |                                       |              //lock
    |                                       |-----stuck here
    |==>bch_btree_set_root()
    |==>bch_journal_meta()
    |==>bch_journal()
    |==>journal_try_write()
    |==>journal_write_unlocked() //journal_full(&c->journal)
    |                            //condition satisfied
    |==>continue_at(cl, journal_write, system_wq); //try to excute
    |                               //journal_write in system_wq
    |                               //but work queue is excuting
    |                               //write_dirty_finish()
    |==>closure_sync(); //wait journal_write execute
    |                   //over and wake up gc,
    |-------------stuck here
    |==>release root node write locker
    
    This patch alloc a separate work-queue for write-back thread to avoid such
    race.
    
    (Commit log re-organized by Coly Li to pass checkpatch.pl checking)
    
    Signed-off-by: Tang Junhui <tang.junhui@zte.com.cn>
    Acked-by: Coly Li <colyli@suse.de>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 50aee960b0d1f55c2fb682ab54262bcceaf558aa
Author: Tang Junhui <tang.junhui@zte.com.cn>
Date:   Wed Sep 6 14:25:59 2017 +0800

    bcache: fix for gc and write-back race
    
    commit 9baf30972b5568d8b5bc8b3c46a6ec5b58100463 upstream.
    
    gc and write-back get raced (see the email "bcache get stucked" I sended
    before):
    gc thread                               write-back thread
    |                                       |bch_writeback_thread()
    |bch_gc_thread()                        |
    |                                       |==>read_dirty()
    |==>bch_btree_gc()                      |
    |==>btree_root() //get btree root       |
    |                //node write locker    |
    |==>bch_btree_gc_root()                 |
    |                                       |==>read_dirty_submit()
    |                                       |==>write_dirty()
    |                                       |==>continue_at(cl,
    |                                       |               write_dirty_finish,
    |                                       |               system_wq);
    |                                       |==>write_dirty_finish()//excute
    |                                       |               //in system_wq
    |                                       |==>bch_btree_insert()
    |                                       |==>bch_btree_map_leaf_nodes()
    |                                       |==>__bch_btree_map_nodes()
    |                                       |==>btree_root //try to get btree
    |                                       |              //root node read
    |                                       |              //lock
    |                                       |-----stuck here
    |==>bch_btree_set_root()
    |==>bch_journal_meta()
    |==>bch_journal()
    |==>journal_try_write()
    |==>journal_write_unlocked() //journal_full(&c->journal)
    |                            //condition satisfied
    |==>continue_at(cl, journal_write, system_wq); //try to excute
    |                               //journal_write in system_wq
    |                               //but work queue is excuting
    |                               //write_dirty_finish()
    |==>closure_sync(); //wait journal_write execute
    |                   //over and wake up gc,
    |-------------stuck here
    |==>release root node write locker
    
    This patch alloc a separate work-queue for write-back thread to avoid such
    race.
    
    (Commit log re-organized by Coly Li to pass checkpatch.pl checking)
    
    Signed-off-by: Tang Junhui <tang.junhui@zte.com.cn>
    Acked-by: Coly Li <colyli@suse.de>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 941154bd6937a710ae9193a3c733c0029e5ae7b8
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Sep 12 21:37:04 2017 +0200

    watchdog/hardlockup/perf: Prevent CPU hotplug deadlock
    
    The following deadlock is possible in the watchdog hotplug code:
    
      cpus_write_lock()
        ...
          takedown_cpu()
            smpboot_park_threads()
              smpboot_park_thread()
                kthread_park()
                  ->park() := watchdog_disable()
                    watchdog_nmi_disable()
                      perf_event_release_kernel();
                        put_event()
                          _free_event()
                            ->destroy() := hw_perf_event_destroy()
                              x86_release_hardware()
                                release_ds_buffers()
                                  get_online_cpus()
    
    when a per cpu watchdog perf event is destroyed which drops the last
    reference to the PMU hardware. The cleanup code there invokes
    get_online_cpus() which instantly deadlocks because the hotplug percpu
    rwsem is write locked.
    
    To solve this add a deferring mechanism:
    
      cpus_write_lock()
                               kthread_park()
                                watchdog_nmi_disable(deferred)
                                  perf_event_disable(event);
                                  move_event_to_deferred(event);
                               ....
      cpus_write_unlock()
      cleaup_deferred_events()
        perf_event_release_kernel()
    
    This is still properly serialized against concurrent hotplug via the
    cpu_add_remove_lock, which is held by the task which initiated the hotplug
    event.
    
    This is also used to handle event destruction when the watchdog threads are
    parked via other mechanisms than CPU hotplug.
    
    Analyzed-by: Peter Zijlstra <peterz@infradead.org>
    
    Reported-by: Borislav Petkov <bp@alien8.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Don Zickus <dzickus@redhat.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Chris Metcalf <cmetcalf@mellanox.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Nicholas Piggin <npiggin@gmail.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Sebastian Siewior <bigeasy@linutronix.de>
    Cc: Ulrich Obergfell <uobergfe@redhat.com>
    Link: http://lkml.kernel.org/r/20170912194146.884469246@linutronix.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 20d853fd0703b1d73c35a22024c0d4fcbcc57c8c
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Sep 12 21:37:03 2017 +0200

    watchdog/hardlockup/perf: Remove broken self disable on failure
    
    The self disabling feature is broken vs. CPU hotplug locking:
    
    CPU 0                      CPU 1
    cpus_write_lock();
     cpu_up(1)
       wait_for_completion()
                               ....
                               unpark_watchdog()
                               ->unpark()
                                 perf_event_create() <- fails
                                   watchdog_enable &= ~NMI_WATCHDOG;
                               ....
    cpus_write_unlock();
                               CPU 2
    cpus_write_lock()
     cpu_down(2)
       wait_for_completion()
                               wakeup(watchdog);
                                 watchdog()
                                 if (!(watchdog_enable & NMI_WATCHDOG))
                                    watchdog_nmi_disable()
                                      perf_event_disable()
                                      ....
                                      cpus_read_lock();
    
                               stop_smpboot_threads()
                                 park_watchdog();
                                   wait_for_completion(watchdog->parked);
    
    Result: End of hotplug and instantaneous full lockup of the machine.
    
    There is a similar problem with disabling the watchdog via the user space
    interface as the sysctl function fiddles with watchdog_enable directly.
    
    It's very debatable whether this is required at all. If the watchdog works
    nicely on N CPUs and it fails to enable on the N + 1 CPU either during
    hotplug or because the user space interface disabled it via sysctl cpumask
    and then some perf user grabbed the counter which is then unavailable for
    the watchdog when the sysctl cpumask gets changed back.
    
    There is no real justification for this.
    
    One of the reasons WHY this is done is the utter stupidity of the init code
    of the perf NMI watchdog. Instead of checking upfront at boot whether PERF
    is available and functional at all, it just does this check at run time
    over and over when user space fiddles with the sysctl. That's broken beyond
    repair along with the idiotic error code dependent warn level printks and
    the even more silly printk rate limiting.
    
    If the init code checks whether perf works at boot time, then this mess can
    be more or less avoided completely. Perf does not come magically into life
    at runtime. Brain usage while coding is overrated.
    
    Remove the cruft and add a temporary safe guard which gets removed later.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Don Zickus <dzickus@redhat.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Chris Metcalf <cmetcalf@mellanox.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Nicholas Piggin <npiggin@gmail.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Sebastian Siewior <bigeasy@linutronix.de>
    Cc: Ulrich Obergfell <uobergfe@redhat.com>
    Link: http://lkml.kernel.org/r/20170912194146.806708429@linutronix.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 9baf30972b5568d8b5bc8b3c46a6ec5b58100463
Author: Tang Junhui <tang.junhui@zte.com.cn>
Date:   Wed Sep 6 14:25:59 2017 +0800

    bcache: fix for gc and write-back race
    
    gc and write-back get raced (see the email "bcache get stucked" I sended
    before):
    gc thread                               write-back thread
    |                                       |bch_writeback_thread()
    |bch_gc_thread()                        |
    |                                       |==>read_dirty()
    |==>bch_btree_gc()                      |
    |==>btree_root() //get btree root       |
    |                //node write locker    |
    |==>bch_btree_gc_root()                 |
    |                                       |==>read_dirty_submit()
    |                                       |==>write_dirty()
    |                                       |==>continue_at(cl,
    |                                       |               write_dirty_finish,
    |                                       |               system_wq);
    |                                       |==>write_dirty_finish()//excute
    |                                       |               //in system_wq
    |                                       |==>bch_btree_insert()
    |                                       |==>bch_btree_map_leaf_nodes()
    |                                       |==>__bch_btree_map_nodes()
    |                                       |==>btree_root //try to get btree
    |                                       |              //root node read
    |                                       |              //lock
    |                                       |-----stuck here
    |==>bch_btree_set_root()
    |==>bch_journal_meta()
    |==>bch_journal()
    |==>journal_try_write()
    |==>journal_write_unlocked() //journal_full(&c->journal)
    |                            //condition satisfied
    |==>continue_at(cl, journal_write, system_wq); //try to excute
    |                               //journal_write in system_wq
    |                               //but work queue is excuting
    |                               //write_dirty_finish()
    |==>closure_sync(); //wait journal_write execute
    |                   //over and wake up gc,
    |-------------stuck here
    |==>release root node write locker
    
    This patch alloc a separate work-queue for write-back thread to avoid such
    race.
    
    (Commit log re-organized by Coly Li to pass checkpatch.pl checking)
    
    Signed-off-by: Tang Junhui <tang.junhui@zte.com.cn>
    Acked-by: Coly Li <colyli@suse.de>
    Cc: stable@vger.kernel.org
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

commit f1d0554639802449428e72c7e19c04d8ebc90665
Author: Eric Dumazet <edumazet@google.com>
Date:   Wed Aug 16 07:03:15 2017 -0700

    dccp: defer ccid_hc_tx_delete() at dismantle time
    
    
    [ Upstream commit 120e9dabaf551c6dc03d3a10a1f026376cb1811c ]
    
    syszkaller team reported another problem in DCCP [1]
    
    Problem here is that the structure holding RTO timer
    (ccid2_hc_tx_rto_expire() handler) is freed too soon.
    
    We can not use del_timer_sync() to cancel the timer
    since this timer wants to grab socket lock (that would risk a dead lock)
    
    Solution is to defer the freeing of memory when all references to
    the socket were released. Socket timers do own a reference, so this
    should fix the issue.
    
    [1]
    
    ==================================================================
    BUG: KASAN: use-after-free in ccid2_hc_tx_rto_expire+0x51c/0x5c0 net/dccp/ccids/ccid2.c:144
    Read of size 4 at addr ffff8801d2660540 by task kworker/u4:7/3365
    
    CPU: 1 PID: 3365 Comm: kworker/u4:7 Not tainted 4.13.0-rc4+ #3
    Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011
    Workqueue: events_unbound call_usermodehelper_exec_work
    Call Trace:
     <IRQ>
     __dump_stack lib/dump_stack.c:16 [inline]
     dump_stack+0x194/0x257 lib/dump_stack.c:52
     print_address_description+0x73/0x250 mm/kasan/report.c:252
     kasan_report_error mm/kasan/report.c:351 [inline]
     kasan_report+0x24e/0x340 mm/kasan/report.c:409
     __asan_report_load4_noabort+0x14/0x20 mm/kasan/report.c:429
     ccid2_hc_tx_rto_expire+0x51c/0x5c0 net/dccp/ccids/ccid2.c:144
     call_timer_fn+0x233/0x830 kernel/time/timer.c:1268
     expire_timers kernel/time/timer.c:1307 [inline]
     __run_timers+0x7fd/0xb90 kernel/time/timer.c:1601
     run_timer_softirq+0x21/0x80 kernel/time/timer.c:1614
     __do_softirq+0x2f5/0xba3 kernel/softirq.c:284
     invoke_softirq kernel/softirq.c:364 [inline]
     irq_exit+0x1cc/0x200 kernel/softirq.c:405
     exiting_irq arch/x86/include/asm/apic.h:638 [inline]
     smp_apic_timer_interrupt+0x76/0xa0 arch/x86/kernel/apic/apic.c:1044
     apic_timer_interrupt+0x93/0xa0 arch/x86/entry/entry_64.S:702
    RIP: 0010:arch_local_irq_enable arch/x86/include/asm/paravirt.h:824 [inline]
    RIP: 0010:__raw_write_unlock_irq include/linux/rwlock_api_smp.h:267 [inline]
    RIP: 0010:_raw_write_unlock_irq+0x56/0x70 kernel/locking/spinlock.c:343
    RSP: 0018:ffff8801cd50eaa8 EFLAGS: 00000286 ORIG_RAX: ffffffffffffff10
    RAX: dffffc0000000000 RBX: ffffffff85a090c0 RCX: 0000000000000006
    RDX: 1ffffffff0b595f3 RSI: 1ffff1003962f989 RDI: ffffffff85acaf98
    RBP: ffff8801cd50eab0 R08: 0000000000000001 R09: 0000000000000000
    R10: 0000000000000000 R11: 0000000000000000 R12: ffff8801cc96ea60
    R13: dffffc0000000000 R14: ffff8801cc96e4c0 R15: ffff8801cc96e4c0
     </IRQ>
     release_task+0xe9e/0x1a40 kernel/exit.c:220
     wait_task_zombie kernel/exit.c:1162 [inline]
     wait_consider_task+0x29b8/0x33c0 kernel/exit.c:1389
     do_wait_thread kernel/exit.c:1452 [inline]
     do_wait+0x441/0xa90 kernel/exit.c:1523
     kernel_wait4+0x1f5/0x370 kernel/exit.c:1665
     SYSC_wait4+0x134/0x140 kernel/exit.c:1677
     SyS_wait4+0x2c/0x40 kernel/exit.c:1673
     call_usermodehelper_exec_sync kernel/kmod.c:286 [inline]
     call_usermodehelper_exec_work+0x1a0/0x2c0 kernel/kmod.c:323
     process_one_work+0xbf3/0x1bc0 kernel/workqueue.c:2097
     worker_thread+0x223/0x1860 kernel/workqueue.c:2231
     kthread+0x35e/0x430 kernel/kthread.c:231
     ret_from_fork+0x2a/0x40 arch/x86/entry/entry_64.S:425
    
    Allocated by task 21267:
     save_stack_trace+0x16/0x20 arch/x86/kernel/stacktrace.c:59
     save_stack+0x43/0xd0 mm/kasan/kasan.c:447
     set_track mm/kasan/kasan.c:459 [inline]
     kasan_kmalloc+0xad/0xe0 mm/kasan/kasan.c:551
     kasan_slab_alloc+0x12/0x20 mm/kasan/kasan.c:489
     kmem_cache_alloc+0x127/0x750 mm/slab.c:3561
     ccid_new+0x20e/0x390 net/dccp/ccid.c:151
     dccp_hdlr_ccid+0x27/0x140 net/dccp/feat.c:44
     __dccp_feat_activate+0x142/0x2a0 net/dccp/feat.c:344
     dccp_feat_activate_values+0x34e/0xa90 net/dccp/feat.c:1538
     dccp_rcv_request_sent_state_process net/dccp/input.c:472 [inline]
     dccp_rcv_state_process+0xed1/0x1620 net/dccp/input.c:677
     dccp_v4_do_rcv+0xeb/0x160 net/dccp/ipv4.c:679
     sk_backlog_rcv include/net/sock.h:911 [inline]
     __release_sock+0x124/0x360 net/core/sock.c:2269
     release_sock+0xa4/0x2a0 net/core/sock.c:2784
     inet_wait_for_connect net/ipv4/af_inet.c:557 [inline]
     __inet_stream_connect+0x671/0xf00 net/ipv4/af_inet.c:643
     inet_stream_connect+0x58/0xa0 net/ipv4/af_inet.c:682
     SYSC_connect+0x204/0x470 net/socket.c:1642
     SyS_connect+0x24/0x30 net/socket.c:1623
     entry_SYSCALL_64_fastpath+0x1f/0xbe
    
    Freed by task 3049:
     save_stack_trace+0x16/0x20 arch/x86/kernel/stacktrace.c:59
     save_stack+0x43/0xd0 mm/kasan/kasan.c:447
     set_track mm/kasan/kasan.c:459 [inline]
     kasan_slab_free+0x71/0xc0 mm/kasan/kasan.c:524
     __cache_free mm/slab.c:3503 [inline]
     kmem_cache_free+0x77/0x280 mm/slab.c:3763
     ccid_hc_tx_delete+0xc5/0x100 net/dccp/ccid.c:190
     dccp_destroy_sock+0x1d1/0x2b0 net/dccp/proto.c:225
     inet_csk_destroy_sock+0x166/0x3f0 net/ipv4/inet_connection_sock.c:833
     dccp_done+0xb7/0xd0 net/dccp/proto.c:145
     dccp_time_wait+0x13d/0x300 net/dccp/minisocks.c:72
     dccp_rcv_reset+0x1d1/0x5b0 net/dccp/input.c:160
     dccp_rcv_state_process+0x8fc/0x1620 net/dccp/input.c:663
     dccp_v4_do_rcv+0xeb/0x160 net/dccp/ipv4.c:679
     sk_backlog_rcv include/net/sock.h:911 [inline]
     __sk_receive_skb+0x33e/0xc00 net/core/sock.c:521
     dccp_v4_rcv+0xef1/0x1c00 net/dccp/ipv4.c:871
     ip_local_deliver_finish+0x2e2/0xba0 net/ipv4/ip_input.c:216
     NF_HOOK include/linux/netfilter.h:248 [inline]
     ip_local_deliver+0x1ce/0x6d0 net/ipv4/ip_input.c:257
     dst_input include/net/dst.h:477 [inline]
     ip_rcv_finish+0x8db/0x19c0 net/ipv4/ip_input.c:397
     NF_HOOK include/linux/netfilter.h:248 [inline]
     ip_rcv+0xc3f/0x17d0 net/ipv4/ip_input.c:488
     __netif_receive_skb_core+0x19af/0x33d0 net/core/dev.c:4417
     __netif_receive_skb+0x2c/0x1b0 net/core/dev.c:4455
     process_backlog+0x203/0x740 net/core/dev.c:5130
     napi_poll net/core/dev.c:5527 [inline]
     net_rx_action+0x792/0x1910 net/core/dev.c:5593
     __do_softirq+0x2f5/0xba3 kernel/softirq.c:284
    
    The buggy address belongs to the object at ffff8801d2660100
     which belongs to the cache ccid2_hc_tx_sock of size 1240
    The buggy address is located 1088 bytes inside of
     1240-byte region [ffff8801d2660100, ffff8801d26605d8)
    The buggy address belongs to the page:
    page:ffffea0007499800 count:1 mapcount:0 mapping:ffff8801d2660100 index:0x0 compound_mapcount: 0
    flags: 0x200000000008100(slab|head)
    raw: 0200000000008100 ffff8801d2660100 0000000000000000 0000000100000005
    raw: ffffea00075271a0 ffffea0007538820 ffff8801d3aef9c0 0000000000000000
    page dumped because: kasan: bad access detected
    
    Memory state around the buggy address:
     ffff8801d2660400: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
     ffff8801d2660480: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    >ffff8801d2660500: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
                                               ^
     ffff8801d2660580: fb fb fb fb fb fb fb fb fb fb fb fc fc fc fc fc
     ffff8801d2660600: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
    ==================================================================
    
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Reported-by: Dmitry Vyukov <dvyukov@google.com>
    Cc: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 236b0d939b05e100a70ab20c402bf10e10269051
Author: Eric Dumazet <edumazet@google.com>
Date:   Wed Aug 16 07:03:15 2017 -0700

    dccp: defer ccid_hc_tx_delete() at dismantle time
    
    
    [ Upstream commit 120e9dabaf551c6dc03d3a10a1f026376cb1811c ]
    
    syszkaller team reported another problem in DCCP [1]
    
    Problem here is that the structure holding RTO timer
    (ccid2_hc_tx_rto_expire() handler) is freed too soon.
    
    We can not use del_timer_sync() to cancel the timer
    since this timer wants to grab socket lock (that would risk a dead lock)
    
    Solution is to defer the freeing of memory when all references to
    the socket were released. Socket timers do own a reference, so this
    should fix the issue.
    
    [1]
    
    ==================================================================
    BUG: KASAN: use-after-free in ccid2_hc_tx_rto_expire+0x51c/0x5c0 net/dccp/ccids/ccid2.c:144
    Read of size 4 at addr ffff8801d2660540 by task kworker/u4:7/3365
    
    CPU: 1 PID: 3365 Comm: kworker/u4:7 Not tainted 4.13.0-rc4+ #3
    Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011
    Workqueue: events_unbound call_usermodehelper_exec_work
    Call Trace:
     <IRQ>
     __dump_stack lib/dump_stack.c:16 [inline]
     dump_stack+0x194/0x257 lib/dump_stack.c:52
     print_address_description+0x73/0x250 mm/kasan/report.c:252
     kasan_report_error mm/kasan/report.c:351 [inline]
     kasan_report+0x24e/0x340 mm/kasan/report.c:409
     __asan_report_load4_noabort+0x14/0x20 mm/kasan/report.c:429
     ccid2_hc_tx_rto_expire+0x51c/0x5c0 net/dccp/ccids/ccid2.c:144
     call_timer_fn+0x233/0x830 kernel/time/timer.c:1268
     expire_timers kernel/time/timer.c:1307 [inline]
     __run_timers+0x7fd/0xb90 kernel/time/timer.c:1601
     run_timer_softirq+0x21/0x80 kernel/time/timer.c:1614
     __do_softirq+0x2f5/0xba3 kernel/softirq.c:284
     invoke_softirq kernel/softirq.c:364 [inline]
     irq_exit+0x1cc/0x200 kernel/softirq.c:405
     exiting_irq arch/x86/include/asm/apic.h:638 [inline]
     smp_apic_timer_interrupt+0x76/0xa0 arch/x86/kernel/apic/apic.c:1044
     apic_timer_interrupt+0x93/0xa0 arch/x86/entry/entry_64.S:702
    RIP: 0010:arch_local_irq_enable arch/x86/include/asm/paravirt.h:824 [inline]
    RIP: 0010:__raw_write_unlock_irq include/linux/rwlock_api_smp.h:267 [inline]
    RIP: 0010:_raw_write_unlock_irq+0x56/0x70 kernel/locking/spinlock.c:343
    RSP: 0018:ffff8801cd50eaa8 EFLAGS: 00000286 ORIG_RAX: ffffffffffffff10
    RAX: dffffc0000000000 RBX: ffffffff85a090c0 RCX: 0000000000000006
    RDX: 1ffffffff0b595f3 RSI: 1ffff1003962f989 RDI: ffffffff85acaf98
    RBP: ffff8801cd50eab0 R08: 0000000000000001 R09: 0000000000000000
    R10: 0000000000000000 R11: 0000000000000000 R12: ffff8801cc96ea60
    R13: dffffc0000000000 R14: ffff8801cc96e4c0 R15: ffff8801cc96e4c0
     </IRQ>
     release_task+0xe9e/0x1a40 kernel/exit.c:220
     wait_task_zombie kernel/exit.c:1162 [inline]
     wait_consider_task+0x29b8/0x33c0 kernel/exit.c:1389
     do_wait_thread kernel/exit.c:1452 [inline]
     do_wait+0x441/0xa90 kernel/exit.c:1523
     kernel_wait4+0x1f5/0x370 kernel/exit.c:1665
     SYSC_wait4+0x134/0x140 kernel/exit.c:1677
     SyS_wait4+0x2c/0x40 kernel/exit.c:1673
     call_usermodehelper_exec_sync kernel/kmod.c:286 [inline]
     call_usermodehelper_exec_work+0x1a0/0x2c0 kernel/kmod.c:323
     process_one_work+0xbf3/0x1bc0 kernel/workqueue.c:2097
     worker_thread+0x223/0x1860 kernel/workqueue.c:2231
     kthread+0x35e/0x430 kernel/kthread.c:231
     ret_from_fork+0x2a/0x40 arch/x86/entry/entry_64.S:425
    
    Allocated by task 21267:
     save_stack_trace+0x16/0x20 arch/x86/kernel/stacktrace.c:59
     save_stack+0x43/0xd0 mm/kasan/kasan.c:447
     set_track mm/kasan/kasan.c:459 [inline]
     kasan_kmalloc+0xad/0xe0 mm/kasan/kasan.c:551
     kasan_slab_alloc+0x12/0x20 mm/kasan/kasan.c:489
     kmem_cache_alloc+0x127/0x750 mm/slab.c:3561
     ccid_new+0x20e/0x390 net/dccp/ccid.c:151
     dccp_hdlr_ccid+0x27/0x140 net/dccp/feat.c:44
     __dccp_feat_activate+0x142/0x2a0 net/dccp/feat.c:344
     dccp_feat_activate_values+0x34e/0xa90 net/dccp/feat.c:1538
     dccp_rcv_request_sent_state_process net/dccp/input.c:472 [inline]
     dccp_rcv_state_process+0xed1/0x1620 net/dccp/input.c:677
     dccp_v4_do_rcv+0xeb/0x160 net/dccp/ipv4.c:679
     sk_backlog_rcv include/net/sock.h:911 [inline]
     __release_sock+0x124/0x360 net/core/sock.c:2269
     release_sock+0xa4/0x2a0 net/core/sock.c:2784
     inet_wait_for_connect net/ipv4/af_inet.c:557 [inline]
     __inet_stream_connect+0x671/0xf00 net/ipv4/af_inet.c:643
     inet_stream_connect+0x58/0xa0 net/ipv4/af_inet.c:682
     SYSC_connect+0x204/0x470 net/socket.c:1642
     SyS_connect+0x24/0x30 net/socket.c:1623
     entry_SYSCALL_64_fastpath+0x1f/0xbe
    
    Freed by task 3049:
     save_stack_trace+0x16/0x20 arch/x86/kernel/stacktrace.c:59
     save_stack+0x43/0xd0 mm/kasan/kasan.c:447
     set_track mm/kasan/kasan.c:459 [inline]
     kasan_slab_free+0x71/0xc0 mm/kasan/kasan.c:524
     __cache_free mm/slab.c:3503 [inline]
     kmem_cache_free+0x77/0x280 mm/slab.c:3763
     ccid_hc_tx_delete+0xc5/0x100 net/dccp/ccid.c:190
     dccp_destroy_sock+0x1d1/0x2b0 net/dccp/proto.c:225
     inet_csk_destroy_sock+0x166/0x3f0 net/ipv4/inet_connection_sock.c:833
     dccp_done+0xb7/0xd0 net/dccp/proto.c:145
     dccp_time_wait+0x13d/0x300 net/dccp/minisocks.c:72
     dccp_rcv_reset+0x1d1/0x5b0 net/dccp/input.c:160
     dccp_rcv_state_process+0x8fc/0x1620 net/dccp/input.c:663
     dccp_v4_do_rcv+0xeb/0x160 net/dccp/ipv4.c:679
     sk_backlog_rcv include/net/sock.h:911 [inline]
     __sk_receive_skb+0x33e/0xc00 net/core/sock.c:521
     dccp_v4_rcv+0xef1/0x1c00 net/dccp/ipv4.c:871
     ip_local_deliver_finish+0x2e2/0xba0 net/ipv4/ip_input.c:216
     NF_HOOK include/linux/netfilter.h:248 [inline]
     ip_local_deliver+0x1ce/0x6d0 net/ipv4/ip_input.c:257
     dst_input include/net/dst.h:477 [inline]
     ip_rcv_finish+0x8db/0x19c0 net/ipv4/ip_input.c:397
     NF_HOOK include/linux/netfilter.h:248 [inline]
     ip_rcv+0xc3f/0x17d0 net/ipv4/ip_input.c:488
     __netif_receive_skb_core+0x19af/0x33d0 net/core/dev.c:4417
     __netif_receive_skb+0x2c/0x1b0 net/core/dev.c:4455
     process_backlog+0x203/0x740 net/core/dev.c:5130
     napi_poll net/core/dev.c:5527 [inline]
     net_rx_action+0x792/0x1910 net/core/dev.c:5593
     __do_softirq+0x2f5/0xba3 kernel/softirq.c:284
    
    The buggy address belongs to the object at ffff8801d2660100
     which belongs to the cache ccid2_hc_tx_sock of size 1240
    The buggy address is located 1088 bytes inside of
     1240-byte region [ffff8801d2660100, ffff8801d26605d8)
    The buggy address belongs to the page:
    page:ffffea0007499800 count:1 mapcount:0 mapping:ffff8801d2660100 index:0x0 compound_mapcount: 0
    flags: 0x200000000008100(slab|head)
    raw: 0200000000008100 ffff8801d2660100 0000000000000000 0000000100000005
    raw: ffffea00075271a0 ffffea0007538820 ffff8801d3aef9c0 0000000000000000
    page dumped because: kasan: bad access detected
    
    Memory state around the buggy address:
     ffff8801d2660400: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
     ffff8801d2660480: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    >ffff8801d2660500: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
                                               ^
     ffff8801d2660580: fb fb fb fb fb fb fb fb fb fb fb fc fc fc fc fc
     ffff8801d2660600: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
    ==================================================================
    
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Reported-by: Dmitry Vyukov <dvyukov@google.com>
    Cc: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit c207ec46b3010d147d9b1363849fe43a818fa696
Author: Eric Dumazet <edumazet@google.com>
Date:   Wed Aug 16 07:03:15 2017 -0700

    dccp: defer ccid_hc_tx_delete() at dismantle time
    
    
    [ Upstream commit 120e9dabaf551c6dc03d3a10a1f026376cb1811c ]
    
    syszkaller team reported another problem in DCCP [1]
    
    Problem here is that the structure holding RTO timer
    (ccid2_hc_tx_rto_expire() handler) is freed too soon.
    
    We can not use del_timer_sync() to cancel the timer
    since this timer wants to grab socket lock (that would risk a dead lock)
    
    Solution is to defer the freeing of memory when all references to
    the socket were released. Socket timers do own a reference, so this
    should fix the issue.
    
    [1]
    
    ==================================================================
    BUG: KASAN: use-after-free in ccid2_hc_tx_rto_expire+0x51c/0x5c0 net/dccp/ccids/ccid2.c:144
    Read of size 4 at addr ffff8801d2660540 by task kworker/u4:7/3365
    
    CPU: 1 PID: 3365 Comm: kworker/u4:7 Not tainted 4.13.0-rc4+ #3
    Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011
    Workqueue: events_unbound call_usermodehelper_exec_work
    Call Trace:
     <IRQ>
     __dump_stack lib/dump_stack.c:16 [inline]
     dump_stack+0x194/0x257 lib/dump_stack.c:52
     print_address_description+0x73/0x250 mm/kasan/report.c:252
     kasan_report_error mm/kasan/report.c:351 [inline]
     kasan_report+0x24e/0x340 mm/kasan/report.c:409
     __asan_report_load4_noabort+0x14/0x20 mm/kasan/report.c:429
     ccid2_hc_tx_rto_expire+0x51c/0x5c0 net/dccp/ccids/ccid2.c:144
     call_timer_fn+0x233/0x830 kernel/time/timer.c:1268
     expire_timers kernel/time/timer.c:1307 [inline]
     __run_timers+0x7fd/0xb90 kernel/time/timer.c:1601
     run_timer_softirq+0x21/0x80 kernel/time/timer.c:1614
     __do_softirq+0x2f5/0xba3 kernel/softirq.c:284
     invoke_softirq kernel/softirq.c:364 [inline]
     irq_exit+0x1cc/0x200 kernel/softirq.c:405
     exiting_irq arch/x86/include/asm/apic.h:638 [inline]
     smp_apic_timer_interrupt+0x76/0xa0 arch/x86/kernel/apic/apic.c:1044
     apic_timer_interrupt+0x93/0xa0 arch/x86/entry/entry_64.S:702
    RIP: 0010:arch_local_irq_enable arch/x86/include/asm/paravirt.h:824 [inline]
    RIP: 0010:__raw_write_unlock_irq include/linux/rwlock_api_smp.h:267 [inline]
    RIP: 0010:_raw_write_unlock_irq+0x56/0x70 kernel/locking/spinlock.c:343
    RSP: 0018:ffff8801cd50eaa8 EFLAGS: 00000286 ORIG_RAX: ffffffffffffff10
    RAX: dffffc0000000000 RBX: ffffffff85a090c0 RCX: 0000000000000006
    RDX: 1ffffffff0b595f3 RSI: 1ffff1003962f989 RDI: ffffffff85acaf98
    RBP: ffff8801cd50eab0 R08: 0000000000000001 R09: 0000000000000000
    R10: 0000000000000000 R11: 0000000000000000 R12: ffff8801cc96ea60
    R13: dffffc0000000000 R14: ffff8801cc96e4c0 R15: ffff8801cc96e4c0
     </IRQ>
     release_task+0xe9e/0x1a40 kernel/exit.c:220
     wait_task_zombie kernel/exit.c:1162 [inline]
     wait_consider_task+0x29b8/0x33c0 kernel/exit.c:1389
     do_wait_thread kernel/exit.c:1452 [inline]
     do_wait+0x441/0xa90 kernel/exit.c:1523
     kernel_wait4+0x1f5/0x370 kernel/exit.c:1665
     SYSC_wait4+0x134/0x140 kernel/exit.c:1677
     SyS_wait4+0x2c/0x40 kernel/exit.c:1673
     call_usermodehelper_exec_sync kernel/kmod.c:286 [inline]
     call_usermodehelper_exec_work+0x1a0/0x2c0 kernel/kmod.c:323
     process_one_work+0xbf3/0x1bc0 kernel/workqueue.c:2097
     worker_thread+0x223/0x1860 kernel/workqueue.c:2231
     kthread+0x35e/0x430 kernel/kthread.c:231
     ret_from_fork+0x2a/0x40 arch/x86/entry/entry_64.S:425
    
    Allocated by task 21267:
     save_stack_trace+0x16/0x20 arch/x86/kernel/stacktrace.c:59
     save_stack+0x43/0xd0 mm/kasan/kasan.c:447
     set_track mm/kasan/kasan.c:459 [inline]
     kasan_kmalloc+0xad/0xe0 mm/kasan/kasan.c:551
     kasan_slab_alloc+0x12/0x20 mm/kasan/kasan.c:489
     kmem_cache_alloc+0x127/0x750 mm/slab.c:3561
     ccid_new+0x20e/0x390 net/dccp/ccid.c:151
     dccp_hdlr_ccid+0x27/0x140 net/dccp/feat.c:44
     __dccp_feat_activate+0x142/0x2a0 net/dccp/feat.c:344
     dccp_feat_activate_values+0x34e/0xa90 net/dccp/feat.c:1538
     dccp_rcv_request_sent_state_process net/dccp/input.c:472 [inline]
     dccp_rcv_state_process+0xed1/0x1620 net/dccp/input.c:677
     dccp_v4_do_rcv+0xeb/0x160 net/dccp/ipv4.c:679
     sk_backlog_rcv include/net/sock.h:911 [inline]
     __release_sock+0x124/0x360 net/core/sock.c:2269
     release_sock+0xa4/0x2a0 net/core/sock.c:2784
     inet_wait_for_connect net/ipv4/af_inet.c:557 [inline]
     __inet_stream_connect+0x671/0xf00 net/ipv4/af_inet.c:643
     inet_stream_connect+0x58/0xa0 net/ipv4/af_inet.c:682
     SYSC_connect+0x204/0x470 net/socket.c:1642
     SyS_connect+0x24/0x30 net/socket.c:1623
     entry_SYSCALL_64_fastpath+0x1f/0xbe
    
    Freed by task 3049:
     save_stack_trace+0x16/0x20 arch/x86/kernel/stacktrace.c:59
     save_stack+0x43/0xd0 mm/kasan/kasan.c:447
     set_track mm/kasan/kasan.c:459 [inline]
     kasan_slab_free+0x71/0xc0 mm/kasan/kasan.c:524
     __cache_free mm/slab.c:3503 [inline]
     kmem_cache_free+0x77/0x280 mm/slab.c:3763
     ccid_hc_tx_delete+0xc5/0x100 net/dccp/ccid.c:190
     dccp_destroy_sock+0x1d1/0x2b0 net/dccp/proto.c:225
     inet_csk_destroy_sock+0x166/0x3f0 net/ipv4/inet_connection_sock.c:833
     dccp_done+0xb7/0xd0 net/dccp/proto.c:145
     dccp_time_wait+0x13d/0x300 net/dccp/minisocks.c:72
     dccp_rcv_reset+0x1d1/0x5b0 net/dccp/input.c:160
     dccp_rcv_state_process+0x8fc/0x1620 net/dccp/input.c:663
     dccp_v4_do_rcv+0xeb/0x160 net/dccp/ipv4.c:679
     sk_backlog_rcv include/net/sock.h:911 [inline]
     __sk_receive_skb+0x33e/0xc00 net/core/sock.c:521
     dccp_v4_rcv+0xef1/0x1c00 net/dccp/ipv4.c:871
     ip_local_deliver_finish+0x2e2/0xba0 net/ipv4/ip_input.c:216
     NF_HOOK include/linux/netfilter.h:248 [inline]
     ip_local_deliver+0x1ce/0x6d0 net/ipv4/ip_input.c:257
     dst_input include/net/dst.h:477 [inline]
     ip_rcv_finish+0x8db/0x19c0 net/ipv4/ip_input.c:397
     NF_HOOK include/linux/netfilter.h:248 [inline]
     ip_rcv+0xc3f/0x17d0 net/ipv4/ip_input.c:488
     __netif_receive_skb_core+0x19af/0x33d0 net/core/dev.c:4417
     __netif_receive_skb+0x2c/0x1b0 net/core/dev.c:4455
     process_backlog+0x203/0x740 net/core/dev.c:5130
     napi_poll net/core/dev.c:5527 [inline]
     net_rx_action+0x792/0x1910 net/core/dev.c:5593
     __do_softirq+0x2f5/0xba3 kernel/softirq.c:284
    
    The buggy address belongs to the object at ffff8801d2660100
     which belongs to the cache ccid2_hc_tx_sock of size 1240
    The buggy address is located 1088 bytes inside of
     1240-byte region [ffff8801d2660100, ffff8801d26605d8)
    The buggy address belongs to the page:
    page:ffffea0007499800 count:1 mapcount:0 mapping:ffff8801d2660100 index:0x0 compound_mapcount: 0
    flags: 0x200000000008100(slab|head)
    raw: 0200000000008100 ffff8801d2660100 0000000000000000 0000000100000005
    raw: ffffea00075271a0 ffffea0007538820 ffff8801d3aef9c0 0000000000000000
    page dumped because: kasan: bad access detected
    
    Memory state around the buggy address:
     ffff8801d2660400: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
     ffff8801d2660480: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    >ffff8801d2660500: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
                                               ^
     ffff8801d2660580: fb fb fb fb fb fb fb fb fb fb fb fc fc fc fc fc
     ffff8801d2660600: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
    ==================================================================
    
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Reported-by: Dmitry Vyukov <dvyukov@google.com>
    Cc: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit e96bad763bdd2d092afdd6bc0c35ad84eb39ea26
Author: Eric Dumazet <edumazet@google.com>
Date:   Wed Aug 16 07:03:15 2017 -0700

    dccp: defer ccid_hc_tx_delete() at dismantle time
    
    
    [ Upstream commit 120e9dabaf551c6dc03d3a10a1f026376cb1811c ]
    
    syszkaller team reported another problem in DCCP [1]
    
    Problem here is that the structure holding RTO timer
    (ccid2_hc_tx_rto_expire() handler) is freed too soon.
    
    We can not use del_timer_sync() to cancel the timer
    since this timer wants to grab socket lock (that would risk a dead lock)
    
    Solution is to defer the freeing of memory when all references to
    the socket were released. Socket timers do own a reference, so this
    should fix the issue.
    
    [1]
    
    ==================================================================
    BUG: KASAN: use-after-free in ccid2_hc_tx_rto_expire+0x51c/0x5c0 net/dccp/ccids/ccid2.c:144
    Read of size 4 at addr ffff8801d2660540 by task kworker/u4:7/3365
    
    CPU: 1 PID: 3365 Comm: kworker/u4:7 Not tainted 4.13.0-rc4+ #3
    Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011
    Workqueue: events_unbound call_usermodehelper_exec_work
    Call Trace:
     <IRQ>
     __dump_stack lib/dump_stack.c:16 [inline]
     dump_stack+0x194/0x257 lib/dump_stack.c:52
     print_address_description+0x73/0x250 mm/kasan/report.c:252
     kasan_report_error mm/kasan/report.c:351 [inline]
     kasan_report+0x24e/0x340 mm/kasan/report.c:409
     __asan_report_load4_noabort+0x14/0x20 mm/kasan/report.c:429
     ccid2_hc_tx_rto_expire+0x51c/0x5c0 net/dccp/ccids/ccid2.c:144
     call_timer_fn+0x233/0x830 kernel/time/timer.c:1268
     expire_timers kernel/time/timer.c:1307 [inline]
     __run_timers+0x7fd/0xb90 kernel/time/timer.c:1601
     run_timer_softirq+0x21/0x80 kernel/time/timer.c:1614
     __do_softirq+0x2f5/0xba3 kernel/softirq.c:284
     invoke_softirq kernel/softirq.c:364 [inline]
     irq_exit+0x1cc/0x200 kernel/softirq.c:405
     exiting_irq arch/x86/include/asm/apic.h:638 [inline]
     smp_apic_timer_interrupt+0x76/0xa0 arch/x86/kernel/apic/apic.c:1044
     apic_timer_interrupt+0x93/0xa0 arch/x86/entry/entry_64.S:702
    RIP: 0010:arch_local_irq_enable arch/x86/include/asm/paravirt.h:824 [inline]
    RIP: 0010:__raw_write_unlock_irq include/linux/rwlock_api_smp.h:267 [inline]
    RIP: 0010:_raw_write_unlock_irq+0x56/0x70 kernel/locking/spinlock.c:343
    RSP: 0018:ffff8801cd50eaa8 EFLAGS: 00000286 ORIG_RAX: ffffffffffffff10
    RAX: dffffc0000000000 RBX: ffffffff85a090c0 RCX: 0000000000000006
    RDX: 1ffffffff0b595f3 RSI: 1ffff1003962f989 RDI: ffffffff85acaf98
    RBP: ffff8801cd50eab0 R08: 0000000000000001 R09: 0000000000000000
    R10: 0000000000000000 R11: 0000000000000000 R12: ffff8801cc96ea60
    R13: dffffc0000000000 R14: ffff8801cc96e4c0 R15: ffff8801cc96e4c0
     </IRQ>
     release_task+0xe9e/0x1a40 kernel/exit.c:220
     wait_task_zombie kernel/exit.c:1162 [inline]
     wait_consider_task+0x29b8/0x33c0 kernel/exit.c:1389
     do_wait_thread kernel/exit.c:1452 [inline]
     do_wait+0x441/0xa90 kernel/exit.c:1523
     kernel_wait4+0x1f5/0x370 kernel/exit.c:1665
     SYSC_wait4+0x134/0x140 kernel/exit.c:1677
     SyS_wait4+0x2c/0x40 kernel/exit.c:1673
     call_usermodehelper_exec_sync kernel/kmod.c:286 [inline]
     call_usermodehelper_exec_work+0x1a0/0x2c0 kernel/kmod.c:323
     process_one_work+0xbf3/0x1bc0 kernel/workqueue.c:2097
     worker_thread+0x223/0x1860 kernel/workqueue.c:2231
     kthread+0x35e/0x430 kernel/kthread.c:231
     ret_from_fork+0x2a/0x40 arch/x86/entry/entry_64.S:425
    
    Allocated by task 21267:
     save_stack_trace+0x16/0x20 arch/x86/kernel/stacktrace.c:59
     save_stack+0x43/0xd0 mm/kasan/kasan.c:447
     set_track mm/kasan/kasan.c:459 [inline]
     kasan_kmalloc+0xad/0xe0 mm/kasan/kasan.c:551
     kasan_slab_alloc+0x12/0x20 mm/kasan/kasan.c:489
     kmem_cache_alloc+0x127/0x750 mm/slab.c:3561
     ccid_new+0x20e/0x390 net/dccp/ccid.c:151
     dccp_hdlr_ccid+0x27/0x140 net/dccp/feat.c:44
     __dccp_feat_activate+0x142/0x2a0 net/dccp/feat.c:344
     dccp_feat_activate_values+0x34e/0xa90 net/dccp/feat.c:1538
     dccp_rcv_request_sent_state_process net/dccp/input.c:472 [inline]
     dccp_rcv_state_process+0xed1/0x1620 net/dccp/input.c:677
     dccp_v4_do_rcv+0xeb/0x160 net/dccp/ipv4.c:679
     sk_backlog_rcv include/net/sock.h:911 [inline]
     __release_sock+0x124/0x360 net/core/sock.c:2269
     release_sock+0xa4/0x2a0 net/core/sock.c:2784
     inet_wait_for_connect net/ipv4/af_inet.c:557 [inline]
     __inet_stream_connect+0x671/0xf00 net/ipv4/af_inet.c:643
     inet_stream_connect+0x58/0xa0 net/ipv4/af_inet.c:682
     SYSC_connect+0x204/0x470 net/socket.c:1642
     SyS_connect+0x24/0x30 net/socket.c:1623
     entry_SYSCALL_64_fastpath+0x1f/0xbe
    
    Freed by task 3049:
     save_stack_trace+0x16/0x20 arch/x86/kernel/stacktrace.c:59
     save_stack+0x43/0xd0 mm/kasan/kasan.c:447
     set_track mm/kasan/kasan.c:459 [inline]
     kasan_slab_free+0x71/0xc0 mm/kasan/kasan.c:524
     __cache_free mm/slab.c:3503 [inline]
     kmem_cache_free+0x77/0x280 mm/slab.c:3763
     ccid_hc_tx_delete+0xc5/0x100 net/dccp/ccid.c:190
     dccp_destroy_sock+0x1d1/0x2b0 net/dccp/proto.c:225
     inet_csk_destroy_sock+0x166/0x3f0 net/ipv4/inet_connection_sock.c:833
     dccp_done+0xb7/0xd0 net/dccp/proto.c:145
     dccp_time_wait+0x13d/0x300 net/dccp/minisocks.c:72
     dccp_rcv_reset+0x1d1/0x5b0 net/dccp/input.c:160
     dccp_rcv_state_process+0x8fc/0x1620 net/dccp/input.c:663
     dccp_v4_do_rcv+0xeb/0x160 net/dccp/ipv4.c:679
     sk_backlog_rcv include/net/sock.h:911 [inline]
     __sk_receive_skb+0x33e/0xc00 net/core/sock.c:521
     dccp_v4_rcv+0xef1/0x1c00 net/dccp/ipv4.c:871
     ip_local_deliver_finish+0x2e2/0xba0 net/ipv4/ip_input.c:216
     NF_HOOK include/linux/netfilter.h:248 [inline]
     ip_local_deliver+0x1ce/0x6d0 net/ipv4/ip_input.c:257
     dst_input include/net/dst.h:477 [inline]
     ip_rcv_finish+0x8db/0x19c0 net/ipv4/ip_input.c:397
     NF_HOOK include/linux/netfilter.h:248 [inline]
     ip_rcv+0xc3f/0x17d0 net/ipv4/ip_input.c:488
     __netif_receive_skb_core+0x19af/0x33d0 net/core/dev.c:4417
     __netif_receive_skb+0x2c/0x1b0 net/core/dev.c:4455
     process_backlog+0x203/0x740 net/core/dev.c:5130
     napi_poll net/core/dev.c:5527 [inline]
     net_rx_action+0x792/0x1910 net/core/dev.c:5593
     __do_softirq+0x2f5/0xba3 kernel/softirq.c:284
    
    The buggy address belongs to the object at ffff8801d2660100
     which belongs to the cache ccid2_hc_tx_sock of size 1240
    The buggy address is located 1088 bytes inside of
     1240-byte region [ffff8801d2660100, ffff8801d26605d8)
    The buggy address belongs to the page:
    page:ffffea0007499800 count:1 mapcount:0 mapping:ffff8801d2660100 index:0x0 compound_mapcount: 0
    flags: 0x200000000008100(slab|head)
    raw: 0200000000008100 ffff8801d2660100 0000000000000000 0000000100000005
    raw: ffffea00075271a0 ffffea0007538820 ffff8801d3aef9c0 0000000000000000
    page dumped because: kasan: bad access detected
    
    Memory state around the buggy address:
     ffff8801d2660400: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
     ffff8801d2660480: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    >ffff8801d2660500: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
                                               ^
     ffff8801d2660580: fb fb fb fb fb fb fb fb fb fb fb fc fc fc fc fc
     ffff8801d2660600: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
    ==================================================================
    
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Reported-by: Dmitry Vyukov <dvyukov@google.com>
    Cc: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 70e42fd02c46e2aa9ab07b766d418637e3a51de7
Author: Damien Le Moal <damien.lemoal@wdc.com>
Date:   Wed Aug 9 12:00:22 2017 +0900

    scsi: sd_zbc: Write unlock zone from sd_uninit_cmnd()
    
    Releasing a zone write lock only when the write commnand that acquired
    the lock completes can cause deadlocks due to potential command
    reordering if the lock owning request is requeued and not executed. This
    problem exists only with the scsi-mq path as, unlike the legacy path,
    requests are moved out of the dispatch queue before being prepared and
    so before locking a zone for a write command.
    
    Since sd_uninit_cmnd() is now always called when a request is requeued,
    call sd_zbc_write_unlock_zone() from that function for write requests
    that acquired a zone lock instead of from sd_done(). Acquisition of a zone
    lock by a write command is indicated using the new command
    flag SCMD_ZONE_WRITE_LOCK.
    
    Signed-off-by: Damien Le Moal <damien.lemoal@wdc.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Bart Van Assche <Bart.VanAssche@wdc.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

commit 120e9dabaf551c6dc03d3a10a1f026376cb1811c
Author: Eric Dumazet <edumazet@google.com>
Date:   Wed Aug 16 07:03:15 2017 -0700

    dccp: defer ccid_hc_tx_delete() at dismantle time
    
    syszkaller team reported another problem in DCCP [1]
    
    Problem here is that the structure holding RTO timer
    (ccid2_hc_tx_rto_expire() handler) is freed too soon.
    
    We can not use del_timer_sync() to cancel the timer
    since this timer wants to grab socket lock (that would risk a dead lock)
    
    Solution is to defer the freeing of memory when all references to
    the socket were released. Socket timers do own a reference, so this
    should fix the issue.
    
    [1]
    
    ==================================================================
    BUG: KASAN: use-after-free in ccid2_hc_tx_rto_expire+0x51c/0x5c0 net/dccp/ccids/ccid2.c:144
    Read of size 4 at addr ffff8801d2660540 by task kworker/u4:7/3365
    
    CPU: 1 PID: 3365 Comm: kworker/u4:7 Not tainted 4.13.0-rc4+ #3
    Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011
    Workqueue: events_unbound call_usermodehelper_exec_work
    Call Trace:
     <IRQ>
     __dump_stack lib/dump_stack.c:16 [inline]
     dump_stack+0x194/0x257 lib/dump_stack.c:52
     print_address_description+0x73/0x250 mm/kasan/report.c:252
     kasan_report_error mm/kasan/report.c:351 [inline]
     kasan_report+0x24e/0x340 mm/kasan/report.c:409
     __asan_report_load4_noabort+0x14/0x20 mm/kasan/report.c:429
     ccid2_hc_tx_rto_expire+0x51c/0x5c0 net/dccp/ccids/ccid2.c:144
     call_timer_fn+0x233/0x830 kernel/time/timer.c:1268
     expire_timers kernel/time/timer.c:1307 [inline]
     __run_timers+0x7fd/0xb90 kernel/time/timer.c:1601
     run_timer_softirq+0x21/0x80 kernel/time/timer.c:1614
     __do_softirq+0x2f5/0xba3 kernel/softirq.c:284
     invoke_softirq kernel/softirq.c:364 [inline]
     irq_exit+0x1cc/0x200 kernel/softirq.c:405
     exiting_irq arch/x86/include/asm/apic.h:638 [inline]
     smp_apic_timer_interrupt+0x76/0xa0 arch/x86/kernel/apic/apic.c:1044
     apic_timer_interrupt+0x93/0xa0 arch/x86/entry/entry_64.S:702
    RIP: 0010:arch_local_irq_enable arch/x86/include/asm/paravirt.h:824 [inline]
    RIP: 0010:__raw_write_unlock_irq include/linux/rwlock_api_smp.h:267 [inline]
    RIP: 0010:_raw_write_unlock_irq+0x56/0x70 kernel/locking/spinlock.c:343
    RSP: 0018:ffff8801cd50eaa8 EFLAGS: 00000286 ORIG_RAX: ffffffffffffff10
    RAX: dffffc0000000000 RBX: ffffffff85a090c0 RCX: 0000000000000006
    RDX: 1ffffffff0b595f3 RSI: 1ffff1003962f989 RDI: ffffffff85acaf98
    RBP: ffff8801cd50eab0 R08: 0000000000000001 R09: 0000000000000000
    R10: 0000000000000000 R11: 0000000000000000 R12: ffff8801cc96ea60
    R13: dffffc0000000000 R14: ffff8801cc96e4c0 R15: ffff8801cc96e4c0
     </IRQ>
     release_task+0xe9e/0x1a40 kernel/exit.c:220
     wait_task_zombie kernel/exit.c:1162 [inline]
     wait_consider_task+0x29b8/0x33c0 kernel/exit.c:1389
     do_wait_thread kernel/exit.c:1452 [inline]
     do_wait+0x441/0xa90 kernel/exit.c:1523
     kernel_wait4+0x1f5/0x370 kernel/exit.c:1665
     SYSC_wait4+0x134/0x140 kernel/exit.c:1677
     SyS_wait4+0x2c/0x40 kernel/exit.c:1673
     call_usermodehelper_exec_sync kernel/kmod.c:286 [inline]
     call_usermodehelper_exec_work+0x1a0/0x2c0 kernel/kmod.c:323
     process_one_work+0xbf3/0x1bc0 kernel/workqueue.c:2097
     worker_thread+0x223/0x1860 kernel/workqueue.c:2231
     kthread+0x35e/0x430 kernel/kthread.c:231
     ret_from_fork+0x2a/0x40 arch/x86/entry/entry_64.S:425
    
    Allocated by task 21267:
     save_stack_trace+0x16/0x20 arch/x86/kernel/stacktrace.c:59
     save_stack+0x43/0xd0 mm/kasan/kasan.c:447
     set_track mm/kasan/kasan.c:459 [inline]
     kasan_kmalloc+0xad/0xe0 mm/kasan/kasan.c:551
     kasan_slab_alloc+0x12/0x20 mm/kasan/kasan.c:489
     kmem_cache_alloc+0x127/0x750 mm/slab.c:3561
     ccid_new+0x20e/0x390 net/dccp/ccid.c:151
     dccp_hdlr_ccid+0x27/0x140 net/dccp/feat.c:44
     __dccp_feat_activate+0x142/0x2a0 net/dccp/feat.c:344
     dccp_feat_activate_values+0x34e/0xa90 net/dccp/feat.c:1538
     dccp_rcv_request_sent_state_process net/dccp/input.c:472 [inline]
     dccp_rcv_state_process+0xed1/0x1620 net/dccp/input.c:677
     dccp_v4_do_rcv+0xeb/0x160 net/dccp/ipv4.c:679
     sk_backlog_rcv include/net/sock.h:911 [inline]
     __release_sock+0x124/0x360 net/core/sock.c:2269
     release_sock+0xa4/0x2a0 net/core/sock.c:2784
     inet_wait_for_connect net/ipv4/af_inet.c:557 [inline]
     __inet_stream_connect+0x671/0xf00 net/ipv4/af_inet.c:643
     inet_stream_connect+0x58/0xa0 net/ipv4/af_inet.c:682
     SYSC_connect+0x204/0x470 net/socket.c:1642
     SyS_connect+0x24/0x30 net/socket.c:1623
     entry_SYSCALL_64_fastpath+0x1f/0xbe
    
    Freed by task 3049:
     save_stack_trace+0x16/0x20 arch/x86/kernel/stacktrace.c:59
     save_stack+0x43/0xd0 mm/kasan/kasan.c:447
     set_track mm/kasan/kasan.c:459 [inline]
     kasan_slab_free+0x71/0xc0 mm/kasan/kasan.c:524
     __cache_free mm/slab.c:3503 [inline]
     kmem_cache_free+0x77/0x280 mm/slab.c:3763
     ccid_hc_tx_delete+0xc5/0x100 net/dccp/ccid.c:190
     dccp_destroy_sock+0x1d1/0x2b0 net/dccp/proto.c:225
     inet_csk_destroy_sock+0x166/0x3f0 net/ipv4/inet_connection_sock.c:833
     dccp_done+0xb7/0xd0 net/dccp/proto.c:145
     dccp_time_wait+0x13d/0x300 net/dccp/minisocks.c:72
     dccp_rcv_reset+0x1d1/0x5b0 net/dccp/input.c:160
     dccp_rcv_state_process+0x8fc/0x1620 net/dccp/input.c:663
     dccp_v4_do_rcv+0xeb/0x160 net/dccp/ipv4.c:679
     sk_backlog_rcv include/net/sock.h:911 [inline]
     __sk_receive_skb+0x33e/0xc00 net/core/sock.c:521
     dccp_v4_rcv+0xef1/0x1c00 net/dccp/ipv4.c:871
     ip_local_deliver_finish+0x2e2/0xba0 net/ipv4/ip_input.c:216
     NF_HOOK include/linux/netfilter.h:248 [inline]
     ip_local_deliver+0x1ce/0x6d0 net/ipv4/ip_input.c:257
     dst_input include/net/dst.h:477 [inline]
     ip_rcv_finish+0x8db/0x19c0 net/ipv4/ip_input.c:397
     NF_HOOK include/linux/netfilter.h:248 [inline]
     ip_rcv+0xc3f/0x17d0 net/ipv4/ip_input.c:488
     __netif_receive_skb_core+0x19af/0x33d0 net/core/dev.c:4417
     __netif_receive_skb+0x2c/0x1b0 net/core/dev.c:4455
     process_backlog+0x203/0x740 net/core/dev.c:5130
     napi_poll net/core/dev.c:5527 [inline]
     net_rx_action+0x792/0x1910 net/core/dev.c:5593
     __do_softirq+0x2f5/0xba3 kernel/softirq.c:284
    
    The buggy address belongs to the object at ffff8801d2660100
     which belongs to the cache ccid2_hc_tx_sock of size 1240
    The buggy address is located 1088 bytes inside of
     1240-byte region [ffff8801d2660100, ffff8801d26605d8)
    The buggy address belongs to the page:
    page:ffffea0007499800 count:1 mapcount:0 mapping:ffff8801d2660100 index:0x0 compound_mapcount: 0
    flags: 0x200000000008100(slab|head)
    raw: 0200000000008100 ffff8801d2660100 0000000000000000 0000000100000005
    raw: ffffea00075271a0 ffffea0007538820 ffff8801d3aef9c0 0000000000000000
    page dumped because: kasan: bad access detected
    
    Memory state around the buggy address:
     ffff8801d2660400: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
     ffff8801d2660480: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    >ffff8801d2660500: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
                                               ^
     ffff8801d2660580: fb fb fb fb fb fb fb fb fb fb fb fc fc fc fc fc
     ffff8801d2660600: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
    ==================================================================
    
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Reported-by: Dmitry Vyukov <dvyukov@google.com>
    Cc: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit f68a45776a62fce560e4e28f89c5009895066ae1
Author: Parthasarathy Bhuvaragan <parthasarathy.bhuvaragan@ericsson.com>
Date:   Tue Jan 24 13:00:43 2017 +0100

    tipc: fix nametbl_lock soft lockup at node/link events
    
    
    [ Upstream commit 93f955aad4bacee5acebad141d1a03cd51f27b4e ]
    
    We trigger a soft lockup as we grab nametbl_lock twice if the node
    has a pending node up/down or link up/down event while:
    - we process an incoming named message in tipc_named_rcv() and
      perform an tipc_update_nametbl().
    - we have pending backlog items in the name distributor queue
      during a nametable update using tipc_nametbl_publish() or
      tipc_nametbl_withdraw().
    
    The following are the call chain associated:
    tipc_named_rcv() Grabs nametbl_lock
       tipc_update_nametbl() (publish/withdraw)
         tipc_node_subscribe()/unsubscribe()
           tipc_node_write_unlock()
              << lockup occurs if an outstanding node/link event
                 exits, as we grabs nametbl_lock again >>
    
    tipc_nametbl_withdraw() Grab nametbl_lock
      tipc_named_process_backlog()
        tipc_update_nametbl()
          << rest as above >>
    
    The function tipc_node_write_unlock(), in addition to releasing the
    lock processes the outstanding node/link up/down events. To do this,
    we need to grab the nametbl_lock again leading to the lockup.
    
    In this commit we fix the soft lockup by introducing a fast variant of
    node_unlock(), where we just release the lock. We adapt the
    node_subscribe()/node_unsubscribe() to use the fast variants.
    
    Reported-and-Tested-by: John Thompson <thompa.atl@gmail.com>
    Acked-by: Ying Xue <ying.xue@windriver.com>
    Acked-by: Jon Maloy <jon.maloy@ericsson.com>
    Signed-off-by: Parthasarathy Bhuvaragan <parthasarathy.bhuvaragan@ericsson.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sasha Levin <alexander.levin@verizon.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 1c2287b99f5c97cb692c7e30b856e9166d713e1f
Author: Steffen Maier <maier@linux.vnet.ibm.com>
Date:   Fri Dec 9 17:16:33 2016 +0100

    scsi: zfcp: fix rport unblock race with LUN recovery
    
    commit 6f2ce1c6af37191640ee3ff6e8fc39ea10352f4c upstream.
    
    It is unavoidable that zfcp_scsi_queuecommand() has to finish requests
    with DID_IMM_RETRY (like fc_remote_port_chkready()) during the time
    window when zfcp detected an unavailable rport but
    fc_remote_port_delete(), which is asynchronous via
    zfcp_scsi_schedule_rport_block(), has not yet blocked the rport.
    
    However, for the case when the rport becomes available again, we should
    prevent unblocking the rport too early.  In contrast to other FCP LLDDs,
    zfcp has to open each LUN with the FCP channel hardware before it can
    send I/O to a LUN.  So if a port already has LUNs attached and we
    unblock the rport just after port recovery, recoveries of LUNs behind
    this port can still be pending which in turn force
    zfcp_scsi_queuecommand() to unnecessarily finish requests with
    DID_IMM_RETRY.
    
    This also opens a time window with unblocked rport (until the followup
    LUN reopen recovery has finished).  If a scsi_cmnd timeout occurs during
    this time window fc_timed_out() cannot work as desired and such command
    would indeed time out and trigger scsi_eh. This prevents a clean and
    timely path failover.  This should not happen if the path issue can be
    recovered on FC transport layer such as path issues involving RSCNs.
    
    Fix this by only calling zfcp_scsi_schedule_rport_register(), to
    asynchronously trigger fc_remote_port_add(), after all LUN recoveries as
    children of the rport have finished and no new recoveries of equal or
    higher order were triggered meanwhile.  Finished intentionally includes
    any recovery result no matter if successful or failed (still unblock
    rport so other successful LUNs work).  For simplicity, we check after
    each finished LUN recovery if there is another LUN recovery pending on
    the same port and then do nothing.  We handle the special case of a
    successful recovery of a port without LUN children the same way without
    changing this case's semantics.
    
    For debugging we introduce 2 new trace records written if the rport
    unblock attempt was aborted due to still unfinished or freshly triggered
    recovery. The records are only written above the default trace level.
    
    Benjamin noticed the important special case of new recovery that can be
    triggered between having given up the erp_lock and before calling
    zfcp_erp_action_cleanup() within zfcp_erp_strategy().  We must avoid the
    following sequence:
    
    ERP thread                 rport_work      other context
    -------------------------  --------------  --------------------------------
    port is unblocked, rport still blocked,
     due to pending/running ERP action,
     so ((port->status & ...UNBLOCK) != 0)
     and (port->rport == NULL)
    unlock ERP
    zfcp_erp_action_cleanup()
    case ZFCP_ERP_ACTION_REOPEN_LUN:
    zfcp_erp_try_rport_unblock()
    ((status & ...UNBLOCK) != 0) [OLD!]
                                               zfcp_erp_port_reopen()
                                               lock ERP
                                               zfcp_erp_port_block()
                                               port->status clear ...UNBLOCK
                                               unlock ERP
                                               zfcp_scsi_schedule_rport_block()
                                               port->rport_task = RPORT_DEL
                                               queue_work(rport_work)
                               zfcp_scsi_rport_work()
                               (port->rport_task != RPORT_ADD)
                               port->rport_task = RPORT_NONE
                               zfcp_scsi_rport_block()
                               if (!port->rport) return
    zfcp_scsi_schedule_rport_register()
    port->rport_task = RPORT_ADD
    queue_work(rport_work)
                               zfcp_scsi_rport_work()
                               (port->rport_task == RPORT_ADD)
                               port->rport_task = RPORT_NONE
                               zfcp_scsi_rport_register()
                               (port->rport == NULL)
                               rport = fc_remote_port_add()
                               port->rport = rport;
    
    Now the rport was erroneously unblocked while the zfcp_port is blocked.
    This is another situation we want to avoid due to scsi_eh
    potential. This state would at least remain until the new recovery from
    the other context finished successfully, or potentially forever if it
    failed.  In order to close this race, we take the erp_lock inside
    zfcp_erp_try_rport_unblock() when checking the status of zfcp_port or
    LUN.  With that, the possible corresponding rport state sequences would
    be: (unblock[ERP thread],block[other context]) if the ERP thread gets
    erp_lock first and still sees ((port->status & ...UNBLOCK) != 0),
    (block[other context],NOP[ERP thread]) if the ERP thread gets erp_lock
    after the other context has already cleard ...UNBLOCK from port->status.
    
    Since checking fields of struct erp_action is unsafe because they could
    have been overwritten (re-used for new recovery) meanwhile, we only
    check status of zfcp_port and LUN since these are only changed under
    erp_lock elsewhere. Regarding the check of the proper status flags (port
    or port_forced are similar to the shown adapter recovery):
    
    [zfcp_erp_adapter_shutdown()]
    zfcp_erp_adapter_reopen()
     zfcp_erp_adapter_block()
      * clear UNBLOCK ---------------------------------------+
     zfcp_scsi_schedule_rports_block()                       |
     write_lock_irqsave(&adapter->erp_lock, flags);-------+  |
     zfcp_erp_action_enqueue()                            |  |
      zfcp_erp_setup_act()                                |  |
       * set ERP_INUSE -----------------------------------|--|--+
     write_unlock_irqrestore(&adapter->erp_lock, flags);--+  |  |
    .context-switch.                                         |  |
    zfcp_erp_thread()                                        |  |
     zfcp_erp_strategy()                                     |  |
      write_lock_irqsave(&adapter->erp_lock, flags);------+  |  |
      ...                                                 |  |  |
      zfcp_erp_strategy_check_target()                    |  |  |
       zfcp_erp_strategy_check_adapter()                  |  |  |
        zfcp_erp_adapter_unblock()                        |  |  |
         * set UNBLOCK -----------------------------------|--+  |
      zfcp_erp_action_dequeue()                           |     |
       * clear ERP_INUSE ---------------------------------|-----+
      ...                                                 |
      write_unlock_irqrestore(&adapter->erp_lock, flags);-+
    
    Hence, we should check for both UNBLOCK and ERP_INUSE because they are
    interleaved.  Also we need to explicitly check ERP_FAILED for the link
    down case which currently does not clear the UNBLOCK flag in
    zfcp_fsf_link_down_info_eval().
    
    Signed-off-by: Steffen Maier <maier@linux.vnet.ibm.com>
    Fixes: 8830271c4819 ("[SCSI] zfcp: Dont fail SCSI commands when transitioning to blocked fc_rport")
    Fixes: a2fa0aede07c ("[SCSI] zfcp: Block FC transport rports early on errors")
    Fixes: 5f852be9e11d ("[SCSI] zfcp: Fix deadlock between zfcp ERP and SCSI")
    Fixes: 338151e06608 ("[SCSI] zfcp: make use of fc_remote_port_delete when target port is unavailable")
    Fixes: 3859f6a248cb ("[PATCH] zfcp: add rports to enable scsi_add_device to work again")
    Reviewed-by: Benjamin Block <bblock@linux.vnet.ibm.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
    Signed-off-by: Willy Tarreau <w@1wt.eu>

commit a90dfdc2dea1ce8ab87e3949c3c6bab3c1e36137
Author: Damien Le Moal <damien.lemoal@wdc.com>
Date:   Mon Apr 24 16:51:13 2017 +0900

    scsi: sd: sd_zbc: Rename sd_zbc_setup_write_cmnd
    
    Rename sd_zbc_setup_write_cmnd() to sd_zbc_write_lock_zone() to be clear
    about what the function actually does. To be consistent, also rename
    sd_zbc_cancel_write_cmnd() to sd_zbc_write_unlock_zone().
    
    No functional change is introduced by this patch.
    
    Signed-off-by: Damien Le Moal <damien.lemoal@wdc.com>
    Reviewed-by: Bart Van Assche <Bart.VanAssche@sandisk.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

commit 044a8ceeb012d956a02cc7587b19a795d4deca79
Author: Steffen Maier <maier@linux.vnet.ibm.com>
Date:   Fri Dec 9 17:16:33 2016 +0100

    scsi: zfcp: fix rport unblock race with LUN recovery
    
    commit 6f2ce1c6af37191640ee3ff6e8fc39ea10352f4c upstream.
    
    It is unavoidable that zfcp_scsi_queuecommand() has to finish requests
    with DID_IMM_RETRY (like fc_remote_port_chkready()) during the time
    window when zfcp detected an unavailable rport but
    fc_remote_port_delete(), which is asynchronous via
    zfcp_scsi_schedule_rport_block(), has not yet blocked the rport.
    
    However, for the case when the rport becomes available again, we should
    prevent unblocking the rport too early.  In contrast to other FCP LLDDs,
    zfcp has to open each LUN with the FCP channel hardware before it can
    send I/O to a LUN.  So if a port already has LUNs attached and we
    unblock the rport just after port recovery, recoveries of LUNs behind
    this port can still be pending which in turn force
    zfcp_scsi_queuecommand() to unnecessarily finish requests with
    DID_IMM_RETRY.
    
    This also opens a time window with unblocked rport (until the followup
    LUN reopen recovery has finished).  If a scsi_cmnd timeout occurs during
    this time window fc_timed_out() cannot work as desired and such command
    would indeed time out and trigger scsi_eh. This prevents a clean and
    timely path failover.  This should not happen if the path issue can be
    recovered on FC transport layer such as path issues involving RSCNs.
    
    Fix this by only calling zfcp_scsi_schedule_rport_register(), to
    asynchronously trigger fc_remote_port_add(), after all LUN recoveries as
    children of the rport have finished and no new recoveries of equal or
    higher order were triggered meanwhile.  Finished intentionally includes
    any recovery result no matter if successful or failed (still unblock
    rport so other successful LUNs work).  For simplicity, we check after
    each finished LUN recovery if there is another LUN recovery pending on
    the same port and then do nothing.  We handle the special case of a
    successful recovery of a port without LUN children the same way without
    changing this case's semantics.
    
    For debugging we introduce 2 new trace records written if the rport
    unblock attempt was aborted due to still unfinished or freshly triggered
    recovery. The records are only written above the default trace level.
    
    Benjamin noticed the important special case of new recovery that can be
    triggered between having given up the erp_lock and before calling
    zfcp_erp_action_cleanup() within zfcp_erp_strategy().  We must avoid the
    following sequence:
    
    ERP thread                 rport_work      other context
    -------------------------  --------------  --------------------------------
    port is unblocked, rport still blocked,
     due to pending/running ERP action,
     so ((port->status & ...UNBLOCK) != 0)
     and (port->rport == NULL)
    unlock ERP
    zfcp_erp_action_cleanup()
    case ZFCP_ERP_ACTION_REOPEN_LUN:
    zfcp_erp_try_rport_unblock()
    ((status & ...UNBLOCK) != 0) [OLD!]
                                               zfcp_erp_port_reopen()
                                               lock ERP
                                               zfcp_erp_port_block()
                                               port->status clear ...UNBLOCK
                                               unlock ERP
                                               zfcp_scsi_schedule_rport_block()
                                               port->rport_task = RPORT_DEL
                                               queue_work(rport_work)
                               zfcp_scsi_rport_work()
                               (port->rport_task != RPORT_ADD)
                               port->rport_task = RPORT_NONE
                               zfcp_scsi_rport_block()
                               if (!port->rport) return
    zfcp_scsi_schedule_rport_register()
    port->rport_task = RPORT_ADD
    queue_work(rport_work)
                               zfcp_scsi_rport_work()
                               (port->rport_task == RPORT_ADD)
                               port->rport_task = RPORT_NONE
                               zfcp_scsi_rport_register()
                               (port->rport == NULL)
                               rport = fc_remote_port_add()
                               port->rport = rport;
    
    Now the rport was erroneously unblocked while the zfcp_port is blocked.
    This is another situation we want to avoid due to scsi_eh
    potential. This state would at least remain until the new recovery from
    the other context finished successfully, or potentially forever if it
    failed.  In order to close this race, we take the erp_lock inside
    zfcp_erp_try_rport_unblock() when checking the status of zfcp_port or
    LUN.  With that, the possible corresponding rport state sequences would
    be: (unblock[ERP thread],block[other context]) if the ERP thread gets
    erp_lock first and still sees ((port->status & ...UNBLOCK) != 0),
    (block[other context],NOP[ERP thread]) if the ERP thread gets erp_lock
    after the other context has already cleard ...UNBLOCK from port->status.
    
    Since checking fields of struct erp_action is unsafe because they could
    have been overwritten (re-used for new recovery) meanwhile, we only
    check status of zfcp_port and LUN since these are only changed under
    erp_lock elsewhere. Regarding the check of the proper status flags (port
    or port_forced are similar to the shown adapter recovery):
    
    [zfcp_erp_adapter_shutdown()]
    zfcp_erp_adapter_reopen()
     zfcp_erp_adapter_block()
      * clear UNBLOCK ---------------------------------------+
     zfcp_scsi_schedule_rports_block()                       |
     write_lock_irqsave(&adapter->erp_lock, flags);-------+  |
     zfcp_erp_action_enqueue()                            |  |
      zfcp_erp_setup_act()                                |  |
       * set ERP_INUSE -----------------------------------|--|--+
     write_unlock_irqrestore(&adapter->erp_lock, flags);--+  |  |
    .context-switch.                                         |  |
    zfcp_erp_thread()                                        |  |
     zfcp_erp_strategy()                                     |  |
      write_lock_irqsave(&adapter->erp_lock, flags);------+  |  |
      ...                                                 |  |  |
      zfcp_erp_strategy_check_target()                    |  |  |
       zfcp_erp_strategy_check_adapter()                  |  |  |
        zfcp_erp_adapter_unblock()                        |  |  |
         * set UNBLOCK -----------------------------------|--+  |
      zfcp_erp_action_dequeue()                           |     |
       * clear ERP_INUSE ---------------------------------|-----+
      ...                                                 |
      write_unlock_irqrestore(&adapter->erp_lock, flags);-+
    
    Hence, we should check for both UNBLOCK and ERP_INUSE because they are
    interleaved.  Also we need to explicitly check ERP_FAILED for the link
    down case which currently does not clear the UNBLOCK flag in
    zfcp_fsf_link_down_info_eval().
    
    Signed-off-by: Steffen Maier <maier@linux.vnet.ibm.com>
    Fixes: 8830271c4819 ("[SCSI] zfcp: Dont fail SCSI commands when transitioning to blocked fc_rport")
    Fixes: a2fa0aede07c ("[SCSI] zfcp: Block FC transport rports early on errors")
    Fixes: 5f852be9e11d ("[SCSI] zfcp: Fix deadlock between zfcp ERP and SCSI")
    Fixes: 338151e06608 ("[SCSI] zfcp: make use of fc_remote_port_delete when target port is unavailable")
    Fixes: 3859f6a248cb ("[PATCH] zfcp: add rports to enable scsi_add_device to work again")
    Reviewed-by: Benjamin Block <bblock@linux.vnet.ibm.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit fffadf3cf34c662a94d64fa7f3dc7a26063c07bd
Author: Steffen Maier <maier@linux.vnet.ibm.com>
Date:   Fri Dec 9 17:16:33 2016 +0100

    scsi: zfcp: fix rport unblock race with LUN recovery
    
    commit 6f2ce1c6af37191640ee3ff6e8fc39ea10352f4c upstream.
    
    It is unavoidable that zfcp_scsi_queuecommand() has to finish requests
    with DID_IMM_RETRY (like fc_remote_port_chkready()) during the time
    window when zfcp detected an unavailable rport but
    fc_remote_port_delete(), which is asynchronous via
    zfcp_scsi_schedule_rport_block(), has not yet blocked the rport.
    
    However, for the case when the rport becomes available again, we should
    prevent unblocking the rport too early.  In contrast to other FCP LLDDs,
    zfcp has to open each LUN with the FCP channel hardware before it can
    send I/O to a LUN.  So if a port already has LUNs attached and we
    unblock the rport just after port recovery, recoveries of LUNs behind
    this port can still be pending which in turn force
    zfcp_scsi_queuecommand() to unnecessarily finish requests with
    DID_IMM_RETRY.
    
    This also opens a time window with unblocked rport (until the followup
    LUN reopen recovery has finished).  If a scsi_cmnd timeout occurs during
    this time window fc_timed_out() cannot work as desired and such command
    would indeed time out and trigger scsi_eh. This prevents a clean and
    timely path failover.  This should not happen if the path issue can be
    recovered on FC transport layer such as path issues involving RSCNs.
    
    Fix this by only calling zfcp_scsi_schedule_rport_register(), to
    asynchronously trigger fc_remote_port_add(), after all LUN recoveries as
    children of the rport have finished and no new recoveries of equal or
    higher order were triggered meanwhile.  Finished intentionally includes
    any recovery result no matter if successful or failed (still unblock
    rport so other successful LUNs work).  For simplicity, we check after
    each finished LUN recovery if there is another LUN recovery pending on
    the same port and then do nothing.  We handle the special case of a
    successful recovery of a port without LUN children the same way without
    changing this case's semantics.
    
    For debugging we introduce 2 new trace records written if the rport
    unblock attempt was aborted due to still unfinished or freshly triggered
    recovery. The records are only written above the default trace level.
    
    Benjamin noticed the important special case of new recovery that can be
    triggered between having given up the erp_lock and before calling
    zfcp_erp_action_cleanup() within zfcp_erp_strategy().  We must avoid the
    following sequence:
    
    ERP thread                 rport_work      other context
    -------------------------  --------------  --------------------------------
    port is unblocked, rport still blocked,
     due to pending/running ERP action,
     so ((port->status & ...UNBLOCK) != 0)
     and (port->rport == NULL)
    unlock ERP
    zfcp_erp_action_cleanup()
    case ZFCP_ERP_ACTION_REOPEN_LUN:
    zfcp_erp_try_rport_unblock()
    ((status & ...UNBLOCK) != 0) [OLD!]
                                               zfcp_erp_port_reopen()
                                               lock ERP
                                               zfcp_erp_port_block()
                                               port->status clear ...UNBLOCK
                                               unlock ERP
                                               zfcp_scsi_schedule_rport_block()
                                               port->rport_task = RPORT_DEL
                                               queue_work(rport_work)
                               zfcp_scsi_rport_work()
                               (port->rport_task != RPORT_ADD)
                               port->rport_task = RPORT_NONE
                               zfcp_scsi_rport_block()
                               if (!port->rport) return
    zfcp_scsi_schedule_rport_register()
    port->rport_task = RPORT_ADD
    queue_work(rport_work)
                               zfcp_scsi_rport_work()
                               (port->rport_task == RPORT_ADD)
                               port->rport_task = RPORT_NONE
                               zfcp_scsi_rport_register()
                               (port->rport == NULL)
                               rport = fc_remote_port_add()
                               port->rport = rport;
    
    Now the rport was erroneously unblocked while the zfcp_port is blocked.
    This is another situation we want to avoid due to scsi_eh
    potential. This state would at least remain until the new recovery from
    the other context finished successfully, or potentially forever if it
    failed.  In order to close this race, we take the erp_lock inside
    zfcp_erp_try_rport_unblock() when checking the status of zfcp_port or
    LUN.  With that, the possible corresponding rport state sequences would
    be: (unblock[ERP thread],block[other context]) if the ERP thread gets
    erp_lock first and still sees ((port->status & ...UNBLOCK) != 0),
    (block[other context],NOP[ERP thread]) if the ERP thread gets erp_lock
    after the other context has already cleard ...UNBLOCK from port->status.
    
    Since checking fields of struct erp_action is unsafe because they could
    have been overwritten (re-used for new recovery) meanwhile, we only
    check status of zfcp_port and LUN since these are only changed under
    erp_lock elsewhere. Regarding the check of the proper status flags (port
    or port_forced are similar to the shown adapter recovery):
    
    [zfcp_erp_adapter_shutdown()]
    zfcp_erp_adapter_reopen()
     zfcp_erp_adapter_block()
      * clear UNBLOCK ---------------------------------------+
     zfcp_scsi_schedule_rports_block()                       |
     write_lock_irqsave(&adapter->erp_lock, flags);-------+  |
     zfcp_erp_action_enqueue()                            |  |
      zfcp_erp_setup_act()                                |  |
       * set ERP_INUSE -----------------------------------|--|--+
     write_unlock_irqrestore(&adapter->erp_lock, flags);--+  |  |
    .context-switch.                                         |  |
    zfcp_erp_thread()                                        |  |
     zfcp_erp_strategy()                                     |  |
      write_lock_irqsave(&adapter->erp_lock, flags);------+  |  |
      ...                                                 |  |  |
      zfcp_erp_strategy_check_target()                    |  |  |
       zfcp_erp_strategy_check_adapter()                  |  |  |
        zfcp_erp_adapter_unblock()                        |  |  |
         * set UNBLOCK -----------------------------------|--+  |
      zfcp_erp_action_dequeue()                           |     |
       * clear ERP_INUSE ---------------------------------|-----+
      ...                                                 |
      write_unlock_irqrestore(&adapter->erp_lock, flags);-+
    
    Hence, we should check for both UNBLOCK and ERP_INUSE because they are
    interleaved.  Also we need to explicitly check ERP_FAILED for the link
    down case which currently does not clear the UNBLOCK flag in
    zfcp_fsf_link_down_info_eval().
    
    Signed-off-by: Steffen Maier <maier@linux.vnet.ibm.com>
    Fixes: 8830271c4819 ("[SCSI] zfcp: Dont fail SCSI commands when transitioning to blocked fc_rport")
    Fixes: a2fa0aede07c ("[SCSI] zfcp: Block FC transport rports early on errors")
    Fixes: 5f852be9e11d ("[SCSI] zfcp: Fix deadlock between zfcp ERP and SCSI")
    Fixes: 338151e06608 ("[SCSI] zfcp: make use of fc_remote_port_delete when target port is unavailable")
    Fixes: 3859f6a248cb ("[PATCH] zfcp: add rports to enable scsi_add_device to work again")
    Reviewed-by: Benjamin Block <bblock@linux.vnet.ibm.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit dbfcef6b0f4012c57bc0b6e0e660d5ed12a5eaed
Author: Sahitya Tummala <stummala@codeaurora.org>
Date:   Wed Feb 1 20:49:35 2017 -0500

    jbd2: fix use after free in kjournald2()
    
    Below is the synchronization issue between unmount and kjournald2
    contexts, which results into use after free issue in kjournald2().
    Fix this issue by using journal->j_state_lock to synchronize the
    wait_event() done in journal_kill_thread() and the wake_up() done
    in kjournald2().
    
    TASK 1:
    umount cmd:
       |--jbd2_journal_destroy() {
           |--journal_kill_thread() {
                write_lock(&journal->j_state_lock);
                journal->j_flags |= JBD2_UNMOUNT;
                ...
                write_unlock(&journal->j_state_lock);
                wake_up(&journal->j_wait_commit);      TASK 2 wakes up here:
                                                       kjournald2() {
                                                         ...
                                                         checks JBD2_UNMOUNT flag and calls goto end-loop;
                                                         ...
                                                         end_loop:
                                                           write_unlock(&journal->j_state_lock);
                                                           journal->j_task = NULL; --> If this thread gets
                                                           pre-empted here, then TASK 1 wait_event will
                                                           exit even before this thread is completely
                                                           done.
                wait_event(journal->j_wait_done_commit, journal->j_task == NULL);
                ...
                write_lock(&journal->j_state_lock);
                write_unlock(&journal->j_state_lock);
              }
           |--kfree(journal);
         }
    }
                                                           wake_up(&journal->j_wait_done_commit); --> this step
                                                           now results into use after free issue.
                                                       }
    
    Signed-off-by: Sahitya Tummala <stummala@codeaurora.org>
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>

commit 197663e65f08e1b6a18982984a0ae1559a76df7d
Author: Steffen Maier <maier@linux.vnet.ibm.com>
Date:   Fri Dec 9 17:16:33 2016 +0100

    scsi: zfcp: fix rport unblock race with LUN recovery
    
    commit 6f2ce1c6af37191640ee3ff6e8fc39ea10352f4c upstream.
    
    It is unavoidable that zfcp_scsi_queuecommand() has to finish requests
    with DID_IMM_RETRY (like fc_remote_port_chkready()) during the time
    window when zfcp detected an unavailable rport but
    fc_remote_port_delete(), which is asynchronous via
    zfcp_scsi_schedule_rport_block(), has not yet blocked the rport.
    
    However, for the case when the rport becomes available again, we should
    prevent unblocking the rport too early.  In contrast to other FCP LLDDs,
    zfcp has to open each LUN with the FCP channel hardware before it can
    send I/O to a LUN.  So if a port already has LUNs attached and we
    unblock the rport just after port recovery, recoveries of LUNs behind
    this port can still be pending which in turn force
    zfcp_scsi_queuecommand() to unnecessarily finish requests with
    DID_IMM_RETRY.
    
    This also opens a time window with unblocked rport (until the followup
    LUN reopen recovery has finished).  If a scsi_cmnd timeout occurs during
    this time window fc_timed_out() cannot work as desired and such command
    would indeed time out and trigger scsi_eh. This prevents a clean and
    timely path failover.  This should not happen if the path issue can be
    recovered on FC transport layer such as path issues involving RSCNs.
    
    Fix this by only calling zfcp_scsi_schedule_rport_register(), to
    asynchronously trigger fc_remote_port_add(), after all LUN recoveries as
    children of the rport have finished and no new recoveries of equal or
    higher order were triggered meanwhile.  Finished intentionally includes
    any recovery result no matter if successful or failed (still unblock
    rport so other successful LUNs work).  For simplicity, we check after
    each finished LUN recovery if there is another LUN recovery pending on
    the same port and then do nothing.  We handle the special case of a
    successful recovery of a port without LUN children the same way without
    changing this case's semantics.
    
    For debugging we introduce 2 new trace records written if the rport
    unblock attempt was aborted due to still unfinished or freshly triggered
    recovery. The records are only written above the default trace level.
    
    Benjamin noticed the important special case of new recovery that can be
    triggered between having given up the erp_lock and before calling
    zfcp_erp_action_cleanup() within zfcp_erp_strategy().  We must avoid the
    following sequence:
    
    ERP thread                 rport_work      other context
    -------------------------  --------------  --------------------------------
    port is unblocked, rport still blocked,
     due to pending/running ERP action,
     so ((port->status & ...UNBLOCK) != 0)
     and (port->rport == NULL)
    unlock ERP
    zfcp_erp_action_cleanup()
    case ZFCP_ERP_ACTION_REOPEN_LUN:
    zfcp_erp_try_rport_unblock()
    ((status & ...UNBLOCK) != 0) [OLD!]
                                               zfcp_erp_port_reopen()
                                               lock ERP
                                               zfcp_erp_port_block()
                                               port->status clear ...UNBLOCK
                                               unlock ERP
                                               zfcp_scsi_schedule_rport_block()
                                               port->rport_task = RPORT_DEL
                                               queue_work(rport_work)
                               zfcp_scsi_rport_work()
                               (port->rport_task != RPORT_ADD)
                               port->rport_task = RPORT_NONE
                               zfcp_scsi_rport_block()
                               if (!port->rport) return
    zfcp_scsi_schedule_rport_register()
    port->rport_task = RPORT_ADD
    queue_work(rport_work)
                               zfcp_scsi_rport_work()
                               (port->rport_task == RPORT_ADD)
                               port->rport_task = RPORT_NONE
                               zfcp_scsi_rport_register()
                               (port->rport == NULL)
                               rport = fc_remote_port_add()
                               port->rport = rport;
    
    Now the rport was erroneously unblocked while the zfcp_port is blocked.
    This is another situation we want to avoid due to scsi_eh
    potential. This state would at least remain until the new recovery from
    the other context finished successfully, or potentially forever if it
    failed.  In order to close this race, we take the erp_lock inside
    zfcp_erp_try_rport_unblock() when checking the status of zfcp_port or
    LUN.  With that, the possible corresponding rport state sequences would
    be: (unblock[ERP thread],block[other context]) if the ERP thread gets
    erp_lock first and still sees ((port->status & ...UNBLOCK) != 0),
    (block[other context],NOP[ERP thread]) if the ERP thread gets erp_lock
    after the other context has already cleard ...UNBLOCK from port->status.
    
    Since checking fields of struct erp_action is unsafe because they could
    have been overwritten (re-used for new recovery) meanwhile, we only
    check status of zfcp_port and LUN since these are only changed under
    erp_lock elsewhere. Regarding the check of the proper status flags (port
    or port_forced are similar to the shown adapter recovery):
    
    [zfcp_erp_adapter_shutdown()]
    zfcp_erp_adapter_reopen()
     zfcp_erp_adapter_block()
      * clear UNBLOCK ---------------------------------------+
     zfcp_scsi_schedule_rports_block()                       |
     write_lock_irqsave(&adapter->erp_lock, flags);-------+  |
     zfcp_erp_action_enqueue()                            |  |
      zfcp_erp_setup_act()                                |  |
       * set ERP_INUSE -----------------------------------|--|--+
     write_unlock_irqrestore(&adapter->erp_lock, flags);--+  |  |
    .context-switch.                                         |  |
    zfcp_erp_thread()                                        |  |
     zfcp_erp_strategy()                                     |  |
      write_lock_irqsave(&adapter->erp_lock, flags);------+  |  |
      ...                                                 |  |  |
      zfcp_erp_strategy_check_target()                    |  |  |
       zfcp_erp_strategy_check_adapter()                  |  |  |
        zfcp_erp_adapter_unblock()                        |  |  |
         * set UNBLOCK -----------------------------------|--+  |
      zfcp_erp_action_dequeue()                           |     |
       * clear ERP_INUSE ---------------------------------|-----+
      ...                                                 |
      write_unlock_irqrestore(&adapter->erp_lock, flags);-+
    
    Hence, we should check for both UNBLOCK and ERP_INUSE because they are
    interleaved.  Also we need to explicitly check ERP_FAILED for the link
    down case which currently does not clear the UNBLOCK flag in
    zfcp_fsf_link_down_info_eval().
    
    Signed-off-by: Steffen Maier <maier@linux.vnet.ibm.com>
    Fixes: 8830271c4819 ("[SCSI] zfcp: Dont fail SCSI commands when transitioning to blocked fc_rport")
    Fixes: a2fa0aede07c ("[SCSI] zfcp: Block FC transport rports early on errors")
    Fixes: 5f852be9e11d ("[SCSI] zfcp: Fix deadlock between zfcp ERP and SCSI")
    Fixes: 338151e06608 ("[SCSI] zfcp: make use of fc_remote_port_delete when target port is unavailable")
    Fixes: 3859f6a248cb ("[PATCH] zfcp: add rports to enable scsi_add_device to work again")
    Reviewed-by: Benjamin Block <bblock@linux.vnet.ibm.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>

commit 93f955aad4bacee5acebad141d1a03cd51f27b4e
Author: Parthasarathy Bhuvaragan <parthasarathy.bhuvaragan@ericsson.com>
Date:   Tue Jan 24 13:00:43 2017 +0100

    tipc: fix nametbl_lock soft lockup at node/link events
    
    We trigger a soft lockup as we grab nametbl_lock twice if the node
    has a pending node up/down or link up/down event while:
    - we process an incoming named message in tipc_named_rcv() and
      perform an tipc_update_nametbl().
    - we have pending backlog items in the name distributor queue
      during a nametable update using tipc_nametbl_publish() or
      tipc_nametbl_withdraw().
    
    The following are the call chain associated:
    tipc_named_rcv() Grabs nametbl_lock
       tipc_update_nametbl() (publish/withdraw)
         tipc_node_subscribe()/unsubscribe()
           tipc_node_write_unlock()
              << lockup occurs if an outstanding node/link event
                 exits, as we grabs nametbl_lock again >>
    
    tipc_nametbl_withdraw() Grab nametbl_lock
      tipc_named_process_backlog()
        tipc_update_nametbl()
          << rest as above >>
    
    The function tipc_node_write_unlock(), in addition to releasing the
    lock processes the outstanding node/link up/down events. To do this,
    we need to grab the nametbl_lock again leading to the lockup.
    
    In this commit we fix the soft lockup by introducing a fast variant of
    node_unlock(), where we just release the lock. We adapt the
    node_subscribe()/node_unsubscribe() to use the fast variants.
    
    Reported-and-Tested-by: John Thompson <thompa.atl@gmail.com>
    Acked-by: Ying Xue <ying.xue@windriver.com>
    Acked-by: Jon Maloy <jon.maloy@ericsson.com>
    Signed-off-by: Parthasarathy Bhuvaragan <parthasarathy.bhuvaragan@ericsson.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 2a940b853ef679cd981e38f23c756d4335a3375c
Author: Steffen Maier <maier@linux.vnet.ibm.com>
Date:   Fri Dec 9 17:16:33 2016 +0100

    scsi: zfcp: fix rport unblock race with LUN recovery
    
    commit 6f2ce1c6af37191640ee3ff6e8fc39ea10352f4c upstream.
    
    It is unavoidable that zfcp_scsi_queuecommand() has to finish requests
    with DID_IMM_RETRY (like fc_remote_port_chkready()) during the time
    window when zfcp detected an unavailable rport but
    fc_remote_port_delete(), which is asynchronous via
    zfcp_scsi_schedule_rport_block(), has not yet blocked the rport.
    
    However, for the case when the rport becomes available again, we should
    prevent unblocking the rport too early.  In contrast to other FCP LLDDs,
    zfcp has to open each LUN with the FCP channel hardware before it can
    send I/O to a LUN.  So if a port already has LUNs attached and we
    unblock the rport just after port recovery, recoveries of LUNs behind
    this port can still be pending which in turn force
    zfcp_scsi_queuecommand() to unnecessarily finish requests with
    DID_IMM_RETRY.
    
    This also opens a time window with unblocked rport (until the followup
    LUN reopen recovery has finished).  If a scsi_cmnd timeout occurs during
    this time window fc_timed_out() cannot work as desired and such command
    would indeed time out and trigger scsi_eh. This prevents a clean and
    timely path failover.  This should not happen if the path issue can be
    recovered on FC transport layer such as path issues involving RSCNs.
    
    Fix this by only calling zfcp_scsi_schedule_rport_register(), to
    asynchronously trigger fc_remote_port_add(), after all LUN recoveries as
    children of the rport have finished and no new recoveries of equal or
    higher order were triggered meanwhile.  Finished intentionally includes
    any recovery result no matter if successful or failed (still unblock
    rport so other successful LUNs work).  For simplicity, we check after
    each finished LUN recovery if there is another LUN recovery pending on
    the same port and then do nothing.  We handle the special case of a
    successful recovery of a port without LUN children the same way without
    changing this case's semantics.
    
    For debugging we introduce 2 new trace records written if the rport
    unblock attempt was aborted due to still unfinished or freshly triggered
    recovery. The records are only written above the default trace level.
    
    Benjamin noticed the important special case of new recovery that can be
    triggered between having given up the erp_lock and before calling
    zfcp_erp_action_cleanup() within zfcp_erp_strategy().  We must avoid the
    following sequence:
    
    ERP thread                 rport_work      other context
    -------------------------  --------------  --------------------------------
    port is unblocked, rport still blocked,
     due to pending/running ERP action,
     so ((port->status & ...UNBLOCK) != 0)
     and (port->rport == NULL)
    unlock ERP
    zfcp_erp_action_cleanup()
    case ZFCP_ERP_ACTION_REOPEN_LUN:
    zfcp_erp_try_rport_unblock()
    ((status & ...UNBLOCK) != 0) [OLD!]
                                               zfcp_erp_port_reopen()
                                               lock ERP
                                               zfcp_erp_port_block()
                                               port->status clear ...UNBLOCK
                                               unlock ERP
                                               zfcp_scsi_schedule_rport_block()
                                               port->rport_task = RPORT_DEL
                                               queue_work(rport_work)
                               zfcp_scsi_rport_work()
                               (port->rport_task != RPORT_ADD)
                               port->rport_task = RPORT_NONE
                               zfcp_scsi_rport_block()
                               if (!port->rport) return
    zfcp_scsi_schedule_rport_register()
    port->rport_task = RPORT_ADD
    queue_work(rport_work)
                               zfcp_scsi_rport_work()
                               (port->rport_task == RPORT_ADD)
                               port->rport_task = RPORT_NONE
                               zfcp_scsi_rport_register()
                               (port->rport == NULL)
                               rport = fc_remote_port_add()
                               port->rport = rport;
    
    Now the rport was erroneously unblocked while the zfcp_port is blocked.
    This is another situation we want to avoid due to scsi_eh
    potential. This state would at least remain until the new recovery from
    the other context finished successfully, or potentially forever if it
    failed.  In order to close this race, we take the erp_lock inside
    zfcp_erp_try_rport_unblock() when checking the status of zfcp_port or
    LUN.  With that, the possible corresponding rport state sequences would
    be: (unblock[ERP thread],block[other context]) if the ERP thread gets
    erp_lock first and still sees ((port->status & ...UNBLOCK) != 0),
    (block[other context],NOP[ERP thread]) if the ERP thread gets erp_lock
    after the other context has already cleard ...UNBLOCK from port->status.
    
    Since checking fields of struct erp_action is unsafe because they could
    have been overwritten (re-used for new recovery) meanwhile, we only
    check status of zfcp_port and LUN since these are only changed under
    erp_lock elsewhere. Regarding the check of the proper status flags (port
    or port_forced are similar to the shown adapter recovery):
    
    [zfcp_erp_adapter_shutdown()]
    zfcp_erp_adapter_reopen()
     zfcp_erp_adapter_block()
      * clear UNBLOCK ---------------------------------------+
     zfcp_scsi_schedule_rports_block()                       |
     write_lock_irqsave(&adapter->erp_lock, flags);-------+  |
     zfcp_erp_action_enqueue()                            |  |
      zfcp_erp_setup_act()                                |  |
       * set ERP_INUSE -----------------------------------|--|--+
     write_unlock_irqrestore(&adapter->erp_lock, flags);--+  |  |
    .context-switch.                                         |  |
    zfcp_erp_thread()                                        |  |
     zfcp_erp_strategy()                                     |  |
      write_lock_irqsave(&adapter->erp_lock, flags);------+  |  |
      ...                                                 |  |  |
      zfcp_erp_strategy_check_target()                    |  |  |
       zfcp_erp_strategy_check_adapter()                  |  |  |
        zfcp_erp_adapter_unblock()                        |  |  |
         * set UNBLOCK -----------------------------------|--+  |
      zfcp_erp_action_dequeue()                           |     |
       * clear ERP_INUSE ---------------------------------|-----+
      ...                                                 |
      write_unlock_irqrestore(&adapter->erp_lock, flags);-+
    
    Hence, we should check for both UNBLOCK and ERP_INUSE because they are
    interleaved.  Also we need to explicitly check ERP_FAILED for the link
    down case which currently does not clear the UNBLOCK flag in
    zfcp_fsf_link_down_info_eval().
    
    Signed-off-by: Steffen Maier <maier@linux.vnet.ibm.com>
    Fixes: 8830271c4819 ("[SCSI] zfcp: Dont fail SCSI commands when transitioning to blocked fc_rport")
    Fixes: a2fa0aede07c ("[SCSI] zfcp: Block FC transport rports early on errors")
    Fixes: 5f852be9e11d ("[SCSI] zfcp: Fix deadlock between zfcp ERP and SCSI")
    Fixes: 338151e06608 ("[SCSI] zfcp: make use of fc_remote_port_delete when target port is unavailable")
    Fixes: 3859f6a248cb ("[PATCH] zfcp: add rports to enable scsi_add_device to work again")
    Reviewed-by: Benjamin Block <bblock@linux.vnet.ibm.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 6d675dffd425a68e6647e77647eb9976fd6868a1
Author: Steffen Maier <maier@linux.vnet.ibm.com>
Date:   Fri Dec 9 17:16:33 2016 +0100

    scsi: zfcp: fix rport unblock race with LUN recovery
    
    commit 6f2ce1c6af37191640ee3ff6e8fc39ea10352f4c upstream.
    
    It is unavoidable that zfcp_scsi_queuecommand() has to finish requests
    with DID_IMM_RETRY (like fc_remote_port_chkready()) during the time
    window when zfcp detected an unavailable rport but
    fc_remote_port_delete(), which is asynchronous via
    zfcp_scsi_schedule_rport_block(), has not yet blocked the rport.
    
    However, for the case when the rport becomes available again, we should
    prevent unblocking the rport too early.  In contrast to other FCP LLDDs,
    zfcp has to open each LUN with the FCP channel hardware before it can
    send I/O to a LUN.  So if a port already has LUNs attached and we
    unblock the rport just after port recovery, recoveries of LUNs behind
    this port can still be pending which in turn force
    zfcp_scsi_queuecommand() to unnecessarily finish requests with
    DID_IMM_RETRY.
    
    This also opens a time window with unblocked rport (until the followup
    LUN reopen recovery has finished).  If a scsi_cmnd timeout occurs during
    this time window fc_timed_out() cannot work as desired and such command
    would indeed time out and trigger scsi_eh. This prevents a clean and
    timely path failover.  This should not happen if the path issue can be
    recovered on FC transport layer such as path issues involving RSCNs.
    
    Fix this by only calling zfcp_scsi_schedule_rport_register(), to
    asynchronously trigger fc_remote_port_add(), after all LUN recoveries as
    children of the rport have finished and no new recoveries of equal or
    higher order were triggered meanwhile.  Finished intentionally includes
    any recovery result no matter if successful or failed (still unblock
    rport so other successful LUNs work).  For simplicity, we check after
    each finished LUN recovery if there is another LUN recovery pending on
    the same port and then do nothing.  We handle the special case of a
    successful recovery of a port without LUN children the same way without
    changing this case's semantics.
    
    For debugging we introduce 2 new trace records written if the rport
    unblock attempt was aborted due to still unfinished or freshly triggered
    recovery. The records are only written above the default trace level.
    
    Benjamin noticed the important special case of new recovery that can be
    triggered between having given up the erp_lock and before calling
    zfcp_erp_action_cleanup() within zfcp_erp_strategy().  We must avoid the
    following sequence:
    
    ERP thread                 rport_work      other context
    -------------------------  --------------  --------------------------------
    port is unblocked, rport still blocked,
     due to pending/running ERP action,
     so ((port->status & ...UNBLOCK) != 0)
     and (port->rport == NULL)
    unlock ERP
    zfcp_erp_action_cleanup()
    case ZFCP_ERP_ACTION_REOPEN_LUN:
    zfcp_erp_try_rport_unblock()
    ((status & ...UNBLOCK) != 0) [OLD!]
                                               zfcp_erp_port_reopen()
                                               lock ERP
                                               zfcp_erp_port_block()
                                               port->status clear ...UNBLOCK
                                               unlock ERP
                                               zfcp_scsi_schedule_rport_block()
                                               port->rport_task = RPORT_DEL
                                               queue_work(rport_work)
                               zfcp_scsi_rport_work()
                               (port->rport_task != RPORT_ADD)
                               port->rport_task = RPORT_NONE
                               zfcp_scsi_rport_block()
                               if (!port->rport) return
    zfcp_scsi_schedule_rport_register()
    port->rport_task = RPORT_ADD
    queue_work(rport_work)
                               zfcp_scsi_rport_work()
                               (port->rport_task == RPORT_ADD)
                               port->rport_task = RPORT_NONE
                               zfcp_scsi_rport_register()
                               (port->rport == NULL)
                               rport = fc_remote_port_add()
                               port->rport = rport;
    
    Now the rport was erroneously unblocked while the zfcp_port is blocked.
    This is another situation we want to avoid due to scsi_eh
    potential. This state would at least remain until the new recovery from
    the other context finished successfully, or potentially forever if it
    failed.  In order to close this race, we take the erp_lock inside
    zfcp_erp_try_rport_unblock() when checking the status of zfcp_port or
    LUN.  With that, the possible corresponding rport state sequences would
    be: (unblock[ERP thread],block[other context]) if the ERP thread gets
    erp_lock first and still sees ((port->status & ...UNBLOCK) != 0),
    (block[other context],NOP[ERP thread]) if the ERP thread gets erp_lock
    after the other context has already cleard ...UNBLOCK from port->status.
    
    Since checking fields of struct erp_action is unsafe because they could
    have been overwritten (re-used for new recovery) meanwhile, we only
    check status of zfcp_port and LUN since these are only changed under
    erp_lock elsewhere. Regarding the check of the proper status flags (port
    or port_forced are similar to the shown adapter recovery):
    
    [zfcp_erp_adapter_shutdown()]
    zfcp_erp_adapter_reopen()
     zfcp_erp_adapter_block()
      * clear UNBLOCK ---------------------------------------+
     zfcp_scsi_schedule_rports_block()                       |
     write_lock_irqsave(&adapter->erp_lock, flags);-------+  |
     zfcp_erp_action_enqueue()                            |  |
      zfcp_erp_setup_act()                                |  |
       * set ERP_INUSE -----------------------------------|--|--+
     write_unlock_irqrestore(&adapter->erp_lock, flags);--+  |  |
    .context-switch.                                         |  |
    zfcp_erp_thread()                                        |  |
     zfcp_erp_strategy()                                     |  |
      write_lock_irqsave(&adapter->erp_lock, flags);------+  |  |
      ...                                                 |  |  |
      zfcp_erp_strategy_check_target()                    |  |  |
       zfcp_erp_strategy_check_adapter()                  |  |  |
        zfcp_erp_adapter_unblock()                        |  |  |
         * set UNBLOCK -----------------------------------|--+  |
      zfcp_erp_action_dequeue()                           |     |
       * clear ERP_INUSE ---------------------------------|-----+
      ...                                                 |
      write_unlock_irqrestore(&adapter->erp_lock, flags);-+
    
    Hence, we should check for both UNBLOCK and ERP_INUSE because they are
    interleaved.  Also we need to explicitly check ERP_FAILED for the link
    down case which currently does not clear the UNBLOCK flag in
    zfcp_fsf_link_down_info_eval().
    
    Signed-off-by: Steffen Maier <maier@linux.vnet.ibm.com>
    Fixes: 8830271c4819 ("[SCSI] zfcp: Dont fail SCSI commands when transitioning to blocked fc_rport")
    Fixes: a2fa0aede07c ("[SCSI] zfcp: Block FC transport rports early on errors")
    Fixes: 5f852be9e11d ("[SCSI] zfcp: Fix deadlock between zfcp ERP and SCSI")
    Fixes: 338151e06608 ("[SCSI] zfcp: make use of fc_remote_port_delete when target port is unavailable")
    Fixes: 3859f6a248cb ("[PATCH] zfcp: add rports to enable scsi_add_device to work again")
    Reviewed-by: Benjamin Block <bblock@linux.vnet.ibm.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 565ae61d8995916da836b98f8c2f12a4192525fa
Author: Steffen Maier <maier@linux.vnet.ibm.com>
Date:   Fri Dec 9 17:16:33 2016 +0100

    scsi: zfcp: fix rport unblock race with LUN recovery
    
    commit 6f2ce1c6af37191640ee3ff6e8fc39ea10352f4c upstream.
    
    It is unavoidable that zfcp_scsi_queuecommand() has to finish requests
    with DID_IMM_RETRY (like fc_remote_port_chkready()) during the time
    window when zfcp detected an unavailable rport but
    fc_remote_port_delete(), which is asynchronous via
    zfcp_scsi_schedule_rport_block(), has not yet blocked the rport.
    
    However, for the case when the rport becomes available again, we should
    prevent unblocking the rport too early.  In contrast to other FCP LLDDs,
    zfcp has to open each LUN with the FCP channel hardware before it can
    send I/O to a LUN.  So if a port already has LUNs attached and we
    unblock the rport just after port recovery, recoveries of LUNs behind
    this port can still be pending which in turn force
    zfcp_scsi_queuecommand() to unnecessarily finish requests with
    DID_IMM_RETRY.
    
    This also opens a time window with unblocked rport (until the followup
    LUN reopen recovery has finished).  If a scsi_cmnd timeout occurs during
    this time window fc_timed_out() cannot work as desired and such command
    would indeed time out and trigger scsi_eh. This prevents a clean and
    timely path failover.  This should not happen if the path issue can be
    recovered on FC transport layer such as path issues involving RSCNs.
    
    Fix this by only calling zfcp_scsi_schedule_rport_register(), to
    asynchronously trigger fc_remote_port_add(), after all LUN recoveries as
    children of the rport have finished and no new recoveries of equal or
    higher order were triggered meanwhile.  Finished intentionally includes
    any recovery result no matter if successful or failed (still unblock
    rport so other successful LUNs work).  For simplicity, we check after
    each finished LUN recovery if there is another LUN recovery pending on
    the same port and then do nothing.  We handle the special case of a
    successful recovery of a port without LUN children the same way without
    changing this case's semantics.
    
    For debugging we introduce 2 new trace records written if the rport
    unblock attempt was aborted due to still unfinished or freshly triggered
    recovery. The records are only written above the default trace level.
    
    Benjamin noticed the important special case of new recovery that can be
    triggered between having given up the erp_lock and before calling
    zfcp_erp_action_cleanup() within zfcp_erp_strategy().  We must avoid the
    following sequence:
    
    ERP thread                 rport_work      other context
    -------------------------  --------------  --------------------------------
    port is unblocked, rport still blocked,
     due to pending/running ERP action,
     so ((port->status & ...UNBLOCK) != 0)
     and (port->rport == NULL)
    unlock ERP
    zfcp_erp_action_cleanup()
    case ZFCP_ERP_ACTION_REOPEN_LUN:
    zfcp_erp_try_rport_unblock()
    ((status & ...UNBLOCK) != 0) [OLD!]
                                               zfcp_erp_port_reopen()
                                               lock ERP
                                               zfcp_erp_port_block()
                                               port->status clear ...UNBLOCK
                                               unlock ERP
                                               zfcp_scsi_schedule_rport_block()
                                               port->rport_task = RPORT_DEL
                                               queue_work(rport_work)
                               zfcp_scsi_rport_work()
                               (port->rport_task != RPORT_ADD)
                               port->rport_task = RPORT_NONE
                               zfcp_scsi_rport_block()
                               if (!port->rport) return
    zfcp_scsi_schedule_rport_register()
    port->rport_task = RPORT_ADD
    queue_work(rport_work)
                               zfcp_scsi_rport_work()
                               (port->rport_task == RPORT_ADD)
                               port->rport_task = RPORT_NONE
                               zfcp_scsi_rport_register()
                               (port->rport == NULL)
                               rport = fc_remote_port_add()
                               port->rport = rport;
    
    Now the rport was erroneously unblocked while the zfcp_port is blocked.
    This is another situation we want to avoid due to scsi_eh
    potential. This state would at least remain until the new recovery from
    the other context finished successfully, or potentially forever if it
    failed.  In order to close this race, we take the erp_lock inside
    zfcp_erp_try_rport_unblock() when checking the status of zfcp_port or
    LUN.  With that, the possible corresponding rport state sequences would
    be: (unblock[ERP thread],block[other context]) if the ERP thread gets
    erp_lock first and still sees ((port->status & ...UNBLOCK) != 0),
    (block[other context],NOP[ERP thread]) if the ERP thread gets erp_lock
    after the other context has already cleard ...UNBLOCK from port->status.
    
    Since checking fields of struct erp_action is unsafe because they could
    have been overwritten (re-used for new recovery) meanwhile, we only
    check status of zfcp_port and LUN since these are only changed under
    erp_lock elsewhere. Regarding the check of the proper status flags (port
    or port_forced are similar to the shown adapter recovery):
    
    [zfcp_erp_adapter_shutdown()]
    zfcp_erp_adapter_reopen()
     zfcp_erp_adapter_block()
      * clear UNBLOCK ---------------------------------------+
     zfcp_scsi_schedule_rports_block()                       |
     write_lock_irqsave(&adapter->erp_lock, flags);-------+  |
     zfcp_erp_action_enqueue()                            |  |
      zfcp_erp_setup_act()                                |  |
       * set ERP_INUSE -----------------------------------|--|--+
     write_unlock_irqrestore(&adapter->erp_lock, flags);--+  |  |
    .context-switch.                                         |  |
    zfcp_erp_thread()                                        |  |
     zfcp_erp_strategy()                                     |  |
      write_lock_irqsave(&adapter->erp_lock, flags);------+  |  |
      ...                                                 |  |  |
      zfcp_erp_strategy_check_target()                    |  |  |
       zfcp_erp_strategy_check_adapter()                  |  |  |
        zfcp_erp_adapter_unblock()                        |  |  |
         * set UNBLOCK -----------------------------------|--+  |
      zfcp_erp_action_dequeue()                           |     |
       * clear ERP_INUSE ---------------------------------|-----+
      ...                                                 |
      write_unlock_irqrestore(&adapter->erp_lock, flags);-+
    
    Hence, we should check for both UNBLOCK and ERP_INUSE because they are
    interleaved.  Also we need to explicitly check ERP_FAILED for the link
    down case which currently does not clear the UNBLOCK flag in
    zfcp_fsf_link_down_info_eval().
    
    Signed-off-by: Steffen Maier <maier@linux.vnet.ibm.com>
    Fixes: 8830271c4819 ("[SCSI] zfcp: Dont fail SCSI commands when transitioning to blocked fc_rport")
    Fixes: a2fa0aede07c ("[SCSI] zfcp: Block FC transport rports early on errors")
    Fixes: 5f852be9e11d ("[SCSI] zfcp: Fix deadlock between zfcp ERP and SCSI")
    Fixes: 338151e06608 ("[SCSI] zfcp: make use of fc_remote_port_delete when target port is unavailable")
    Fixes: 3859f6a248cb ("[PATCH] zfcp: add rports to enable scsi_add_device to work again")
    Reviewed-by: Benjamin Block <bblock@linux.vnet.ibm.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 6f2ce1c6af37191640ee3ff6e8fc39ea10352f4c
Author: Steffen Maier <maier@linux.vnet.ibm.com>
Date:   Fri Dec 9 17:16:33 2016 +0100

    scsi: zfcp: fix rport unblock race with LUN recovery
    
    It is unavoidable that zfcp_scsi_queuecommand() has to finish requests
    with DID_IMM_RETRY (like fc_remote_port_chkready()) during the time
    window when zfcp detected an unavailable rport but
    fc_remote_port_delete(), which is asynchronous via
    zfcp_scsi_schedule_rport_block(), has not yet blocked the rport.
    
    However, for the case when the rport becomes available again, we should
    prevent unblocking the rport too early.  In contrast to other FCP LLDDs,
    zfcp has to open each LUN with the FCP channel hardware before it can
    send I/O to a LUN.  So if a port already has LUNs attached and we
    unblock the rport just after port recovery, recoveries of LUNs behind
    this port can still be pending which in turn force
    zfcp_scsi_queuecommand() to unnecessarily finish requests with
    DID_IMM_RETRY.
    
    This also opens a time window with unblocked rport (until the followup
    LUN reopen recovery has finished).  If a scsi_cmnd timeout occurs during
    this time window fc_timed_out() cannot work as desired and such command
    would indeed time out and trigger scsi_eh. This prevents a clean and
    timely path failover.  This should not happen if the path issue can be
    recovered on FC transport layer such as path issues involving RSCNs.
    
    Fix this by only calling zfcp_scsi_schedule_rport_register(), to
    asynchronously trigger fc_remote_port_add(), after all LUN recoveries as
    children of the rport have finished and no new recoveries of equal or
    higher order were triggered meanwhile.  Finished intentionally includes
    any recovery result no matter if successful or failed (still unblock
    rport so other successful LUNs work).  For simplicity, we check after
    each finished LUN recovery if there is another LUN recovery pending on
    the same port and then do nothing.  We handle the special case of a
    successful recovery of a port without LUN children the same way without
    changing this case's semantics.
    
    For debugging we introduce 2 new trace records written if the rport
    unblock attempt was aborted due to still unfinished or freshly triggered
    recovery. The records are only written above the default trace level.
    
    Benjamin noticed the important special case of new recovery that can be
    triggered between having given up the erp_lock and before calling
    zfcp_erp_action_cleanup() within zfcp_erp_strategy().  We must avoid the
    following sequence:
    
    ERP thread                 rport_work      other context
    -------------------------  --------------  --------------------------------
    port is unblocked, rport still blocked,
     due to pending/running ERP action,
     so ((port->status & ...UNBLOCK) != 0)
     and (port->rport == NULL)
    unlock ERP
    zfcp_erp_action_cleanup()
    case ZFCP_ERP_ACTION_REOPEN_LUN:
    zfcp_erp_try_rport_unblock()
    ((status & ...UNBLOCK) != 0) [OLD!]
                                               zfcp_erp_port_reopen()
                                               lock ERP
                                               zfcp_erp_port_block()
                                               port->status clear ...UNBLOCK
                                               unlock ERP
                                               zfcp_scsi_schedule_rport_block()
                                               port->rport_task = RPORT_DEL
                                               queue_work(rport_work)
                               zfcp_scsi_rport_work()
                               (port->rport_task != RPORT_ADD)
                               port->rport_task = RPORT_NONE
                               zfcp_scsi_rport_block()
                               if (!port->rport) return
    zfcp_scsi_schedule_rport_register()
    port->rport_task = RPORT_ADD
    queue_work(rport_work)
                               zfcp_scsi_rport_work()
                               (port->rport_task == RPORT_ADD)
                               port->rport_task = RPORT_NONE
                               zfcp_scsi_rport_register()
                               (port->rport == NULL)
                               rport = fc_remote_port_add()
                               port->rport = rport;
    
    Now the rport was erroneously unblocked while the zfcp_port is blocked.
    This is another situation we want to avoid due to scsi_eh
    potential. This state would at least remain until the new recovery from
    the other context finished successfully, or potentially forever if it
    failed.  In order to close this race, we take the erp_lock inside
    zfcp_erp_try_rport_unblock() when checking the status of zfcp_port or
    LUN.  With that, the possible corresponding rport state sequences would
    be: (unblock[ERP thread],block[other context]) if the ERP thread gets
    erp_lock first and still sees ((port->status & ...UNBLOCK) != 0),
    (block[other context],NOP[ERP thread]) if the ERP thread gets erp_lock
    after the other context has already cleard ...UNBLOCK from port->status.
    
    Since checking fields of struct erp_action is unsafe because they could
    have been overwritten (re-used for new recovery) meanwhile, we only
    check status of zfcp_port and LUN since these are only changed under
    erp_lock elsewhere. Regarding the check of the proper status flags (port
    or port_forced are similar to the shown adapter recovery):
    
    [zfcp_erp_adapter_shutdown()]
    zfcp_erp_adapter_reopen()
     zfcp_erp_adapter_block()
      * clear UNBLOCK ---------------------------------------+
     zfcp_scsi_schedule_rports_block()                       |
     write_lock_irqsave(&adapter->erp_lock, flags);-------+  |
     zfcp_erp_action_enqueue()                            |  |
      zfcp_erp_setup_act()                                |  |
       * set ERP_INUSE -----------------------------------|--|--+
     write_unlock_irqrestore(&adapter->erp_lock, flags);--+  |  |
    .context-switch.                                         |  |
    zfcp_erp_thread()                                        |  |
     zfcp_erp_strategy()                                     |  |
      write_lock_irqsave(&adapter->erp_lock, flags);------+  |  |
      ...                                                 |  |  |
      zfcp_erp_strategy_check_target()                    |  |  |
       zfcp_erp_strategy_check_adapter()                  |  |  |
        zfcp_erp_adapter_unblock()                        |  |  |
         * set UNBLOCK -----------------------------------|--+  |
      zfcp_erp_action_dequeue()                           |     |
       * clear ERP_INUSE ---------------------------------|-----+
      ...                                                 |
      write_unlock_irqrestore(&adapter->erp_lock, flags);-+
    
    Hence, we should check for both UNBLOCK and ERP_INUSE because they are
    interleaved.  Also we need to explicitly check ERP_FAILED for the link
    down case which currently does not clear the UNBLOCK flag in
    zfcp_fsf_link_down_info_eval().
    
    Signed-off-by: Steffen Maier <maier@linux.vnet.ibm.com>
    Fixes: 8830271c4819 ("[SCSI] zfcp: Dont fail SCSI commands when transitioning to blocked fc_rport")
    Fixes: a2fa0aede07c ("[SCSI] zfcp: Block FC transport rports early on errors")
    Fixes: 5f852be9e11d ("[SCSI] zfcp: Fix deadlock between zfcp ERP and SCSI")
    Fixes: 338151e06608 ("[SCSI] zfcp: make use of fc_remote_port_delete when target port is unavailable")
    Fixes: 3859f6a248cb ("[PATCH] zfcp: add rports to enable scsi_add_device to work again")
    Cc: <stable@vger.kernel.org> #2.6.32+
    Reviewed-by: Benjamin Block <bblock@linux.vnet.ibm.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

commit 6bbeeaf13d27b68303e5e1663139faa144200c8d
Author: Will Deacon <will.deacon@arm.com>
Date:   Wed Aug 24 10:07:14 2016 +0100

    perf/core: Use this_cpu_ptr() when stopping AUX events
    
    commit 8b6a3fe8fab97716990a3abde1a01fb5a34552a3 upstream.
    
    When tearing down an AUX buf for an event via perf_mmap_close(),
    __perf_event_output_stop() is called on the event's CPU to ensure that
    trace generation is halted before the process of unmapping and
    freeing the buffer pages begins.
    
    The callback is performed via cpu_function_call(), which ensures that it
    runs with interrupts disabled and is therefore not preemptible.
    Unfortunately, the current code grabs the per-cpu context pointer using
    get_cpu_ptr(), which unnecessarily disables preemption and doesn't pair
    the call with put_cpu_ptr(), leading to a preempt_count() imbalance and
    a BUG when freeing the AUX buffer later on:
    
      WARNING: CPU: 1 PID: 2249 at kernel/events/ring_buffer.c:539 __rb_free_aux+0x10c/0x120
      Modules linked in:
      [...]
      Call Trace:
       [<ffffffff813379dd>] dump_stack+0x4f/0x72
       [<ffffffff81059ff6>] __warn+0xc6/0xe0
       [<ffffffff8105a0c8>] warn_slowpath_null+0x18/0x20
       [<ffffffff8112761c>] __rb_free_aux+0x10c/0x120
       [<ffffffff81128163>] rb_free_aux+0x13/0x20
       [<ffffffff8112515e>] perf_mmap_close+0x29e/0x2f0
       [<ffffffff8111da30>] ? perf_iterate_ctx+0xe0/0xe0
       [<ffffffff8115f685>] remove_vma+0x25/0x60
       [<ffffffff81161796>] exit_mmap+0x106/0x140
       [<ffffffff8105725c>] mmput+0x1c/0xd0
       [<ffffffff8105cac3>] do_exit+0x253/0xbf0
       [<ffffffff8105e32e>] do_group_exit+0x3e/0xb0
       [<ffffffff81068d49>] get_signal+0x249/0x640
       [<ffffffff8101c273>] do_signal+0x23/0x640
       [<ffffffff81905f42>] ? _raw_write_unlock_irq+0x12/0x30
       [<ffffffff81905f69>] ? _raw_spin_unlock_irq+0x9/0x10
       [<ffffffff81901896>] ? __schedule+0x2c6/0x710
       [<ffffffff810022a4>] exit_to_usermode_loop+0x74/0x90
       [<ffffffff81002a56>] prepare_exit_to_usermode+0x26/0x30
       [<ffffffff81906d1b>] retint_user+0x8/0x10
    
    This patch uses this_cpu_ptr() instead of get_cpu_ptr(), since preemption is
    already disabled by the caller.
    
    Signed-off-by: Will Deacon <will.deacon@arm.com>
    Reviewed-by: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Cc: Arnaldo Carvalho de Melo <acme@kernel.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Vince Weaver <vincent.weaver@maine.edu>
    Fixes: 95ff4ca26c49 ("perf/core: Free AUX pages in unmap path")
    Link: http://lkml.kernel.org/r/20160824091905.GA16944@arm.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 8b6a3fe8fab97716990a3abde1a01fb5a34552a3
Author: Will Deacon <will.deacon@arm.com>
Date:   Wed Aug 24 10:07:14 2016 +0100

    perf/core: Use this_cpu_ptr() when stopping AUX events
    
    When tearing down an AUX buf for an event via perf_mmap_close(),
    __perf_event_output_stop() is called on the event's CPU to ensure that
    trace generation is halted before the process of unmapping and
    freeing the buffer pages begins.
    
    The callback is performed via cpu_function_call(), which ensures that it
    runs with interrupts disabled and is therefore not preemptible.
    Unfortunately, the current code grabs the per-cpu context pointer using
    get_cpu_ptr(), which unnecessarily disables preemption and doesn't pair
    the call with put_cpu_ptr(), leading to a preempt_count() imbalance and
    a BUG when freeing the AUX buffer later on:
    
      WARNING: CPU: 1 PID: 2249 at kernel/events/ring_buffer.c:539 __rb_free_aux+0x10c/0x120
      Modules linked in:
      [...]
      Call Trace:
       [<ffffffff813379dd>] dump_stack+0x4f/0x72
       [<ffffffff81059ff6>] __warn+0xc6/0xe0
       [<ffffffff8105a0c8>] warn_slowpath_null+0x18/0x20
       [<ffffffff8112761c>] __rb_free_aux+0x10c/0x120
       [<ffffffff81128163>] rb_free_aux+0x13/0x20
       [<ffffffff8112515e>] perf_mmap_close+0x29e/0x2f0
       [<ffffffff8111da30>] ? perf_iterate_ctx+0xe0/0xe0
       [<ffffffff8115f685>] remove_vma+0x25/0x60
       [<ffffffff81161796>] exit_mmap+0x106/0x140
       [<ffffffff8105725c>] mmput+0x1c/0xd0
       [<ffffffff8105cac3>] do_exit+0x253/0xbf0
       [<ffffffff8105e32e>] do_group_exit+0x3e/0xb0
       [<ffffffff81068d49>] get_signal+0x249/0x640
       [<ffffffff8101c273>] do_signal+0x23/0x640
       [<ffffffff81905f42>] ? _raw_write_unlock_irq+0x12/0x30
       [<ffffffff81905f69>] ? _raw_spin_unlock_irq+0x9/0x10
       [<ffffffff81901896>] ? __schedule+0x2c6/0x710
       [<ffffffff810022a4>] exit_to_usermode_loop+0x74/0x90
       [<ffffffff81002a56>] prepare_exit_to_usermode+0x26/0x30
       [<ffffffff81906d1b>] retint_user+0x8/0x10
    
    This patch uses this_cpu_ptr() instead of get_cpu_ptr(), since preemption is
    already disabled by the caller.
    
    Signed-off-by: Will Deacon <will.deacon@arm.com>
    Reviewed-by: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Cc: Arnaldo Carvalho de Melo <acme@kernel.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Vince Weaver <vincent.weaver@maine.edu>
    Fixes: 95ff4ca26c49 ("perf/core: Free AUX pages in unmap path")
    Link: http://lkml.kernel.org/r/20160824091905.GA16944@arm.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 2db34e8bf9a22f4e38b29deccee57457bc0e7d74
Author: pan xinhui <xinhui.pan@linux.vnet.ibm.com>
Date:   Mon Jul 18 17:47:39 2016 +0800

    locking/qrwlock: Fix write unlock bug on big endian systems
    
    This patch aims to get rid of endianness in queued_write_unlock(). We
    want to set  __qrwlock->wmode to NULL, however the address is not
    &lock->cnts in big endian machine. That causes queued_write_unlock()
    write NULL to the wrong field of __qrwlock.
    
    So implement __qrwlock_write_byte() which returns the correct
    __qrwlock->wmode address.
    
    Suggested-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Signed-off-by: Pan Xinhui <xinhui.pan@linux.vnet.ibm.com>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Waiman.Long@hpe.com
    Cc: arnd@arndb.de
    Cc: boqun.feng@gmail.com
    Cc: will.deacon@arm.com
    Link: http://lkml.kernel.org/r/1468835259-4486-1-git-send-email-xinhui.pan@linux.vnet.ibm.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 2644b9787694c3e18fc82ec74087daf15eef3249
Author: Daniel Bristot de Oliveira <bristot@redhat.com>
Date:   Wed Jun 22 17:28:41 2016 -0300

    cgroup: Disable IRQs while holding css_set_lock
    
    commit 82d6489d0fed2ec8a8c48c19e8d8a04ac8e5bb26 upstream.
    
    While testing the deadline scheduler + cgroup setup I hit this
    warning.
    
    [  132.612935] ------------[ cut here ]------------
    [  132.612951] WARNING: CPU: 5 PID: 0 at kernel/softirq.c:150 __local_bh_enable_ip+0x6b/0x80
    [  132.612952] Modules linked in: (a ton of modules...)
    [  132.612981] CPU: 5 PID: 0 Comm: swapper/5 Not tainted 4.7.0-rc2 #2
    [  132.612981] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.8.2-20150714_191134- 04/01/2014
    [  132.612982]  0000000000000086 45c8bb5effdd088b ffff88013fd43da0 ffffffff813d229e
    [  132.612984]  0000000000000000 0000000000000000 ffff88013fd43de0 ffffffff810a652b
    [  132.612985]  00000096811387b5 0000000000000200 ffff8800bab29d80 ffff880034c54c00
    [  132.612986] Call Trace:
    [  132.612987]  <IRQ>  [<ffffffff813d229e>] dump_stack+0x63/0x85
    [  132.612994]  [<ffffffff810a652b>] __warn+0xcb/0xf0
    [  132.612997]  [<ffffffff810e76a0>] ? push_dl_task.part.32+0x170/0x170
    [  132.612999]  [<ffffffff810a665d>] warn_slowpath_null+0x1d/0x20
    [  132.613000]  [<ffffffff810aba5b>] __local_bh_enable_ip+0x6b/0x80
    [  132.613008]  [<ffffffff817d6c8a>] _raw_write_unlock_bh+0x1a/0x20
    [  132.613010]  [<ffffffff817d6c9e>] _raw_spin_unlock_bh+0xe/0x10
    [  132.613015]  [<ffffffff811388ac>] put_css_set+0x5c/0x60
    [  132.613016]  [<ffffffff8113dc7f>] cgroup_free+0x7f/0xa0
    [  132.613017]  [<ffffffff810a3912>] __put_task_struct+0x42/0x140
    [  132.613018]  [<ffffffff810e776a>] dl_task_timer+0xca/0x250
    [  132.613027]  [<ffffffff810e76a0>] ? push_dl_task.part.32+0x170/0x170
    [  132.613030]  [<ffffffff8111371e>] __hrtimer_run_queues+0xee/0x270
    [  132.613031]  [<ffffffff81113ec8>] hrtimer_interrupt+0xa8/0x190
    [  132.613034]  [<ffffffff81051a58>] local_apic_timer_interrupt+0x38/0x60
    [  132.613035]  [<ffffffff817d9b0d>] smp_apic_timer_interrupt+0x3d/0x50
    [  132.613037]  [<ffffffff817d7c5c>] apic_timer_interrupt+0x8c/0xa0
    [  132.613038]  <EOI>  [<ffffffff81063466>] ? native_safe_halt+0x6/0x10
    [  132.613043]  [<ffffffff81037a4e>] default_idle+0x1e/0xd0
    [  132.613044]  [<ffffffff810381cf>] arch_cpu_idle+0xf/0x20
    [  132.613046]  [<ffffffff810e8fda>] default_idle_call+0x2a/0x40
    [  132.613047]  [<ffffffff810e92d7>] cpu_startup_entry+0x2e7/0x340
    [  132.613048]  [<ffffffff81050235>] start_secondary+0x155/0x190
    [  132.613049] ---[ end trace f91934d162ce9977 ]---
    
    The warn is the spin_(lock|unlock)_bh(&css_set_lock) in the interrupt
    context. Converting the spin_lock_bh to spin_lock_irq(save) to avoid
    this problem - and other problems of sharing a spinlock with an
    interrupt.
    
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Li Zefan <lizefan@huawei.com>
    Cc: Johannes Weiner <hannes@cmpxchg.org>
    Cc: Juri Lelli <juri.lelli@arm.com>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: cgroups@vger.kernel.org
    Cc: linux-kernel@vger.kernel.org
    Reviewed-by: Rik van Riel <riel@redhat.com>
    Reviewed-by: "Luis Claudio R. Goncalves" <lgoncalv@redhat.com>
    Signed-off-by: Daniel Bristot de Oliveira <bristot@redhat.com>
    Acked-by: Zefan Li <lizefan@huawei.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 82d6489d0fed2ec8a8c48c19e8d8a04ac8e5bb26
Author: Daniel Bristot de Oliveira <bristot@redhat.com>
Date:   Wed Jun 22 17:28:41 2016 -0300

    cgroup: Disable IRQs while holding css_set_lock
    
    While testing the deadline scheduler + cgroup setup I hit this
    warning.
    
    [  132.612935] ------------[ cut here ]------------
    [  132.612951] WARNING: CPU: 5 PID: 0 at kernel/softirq.c:150 __local_bh_enable_ip+0x6b/0x80
    [  132.612952] Modules linked in: (a ton of modules...)
    [  132.612981] CPU: 5 PID: 0 Comm: swapper/5 Not tainted 4.7.0-rc2 #2
    [  132.612981] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.8.2-20150714_191134- 04/01/2014
    [  132.612982]  0000000000000086 45c8bb5effdd088b ffff88013fd43da0 ffffffff813d229e
    [  132.612984]  0000000000000000 0000000000000000 ffff88013fd43de0 ffffffff810a652b
    [  132.612985]  00000096811387b5 0000000000000200 ffff8800bab29d80 ffff880034c54c00
    [  132.612986] Call Trace:
    [  132.612987]  <IRQ>  [<ffffffff813d229e>] dump_stack+0x63/0x85
    [  132.612994]  [<ffffffff810a652b>] __warn+0xcb/0xf0
    [  132.612997]  [<ffffffff810e76a0>] ? push_dl_task.part.32+0x170/0x170
    [  132.612999]  [<ffffffff810a665d>] warn_slowpath_null+0x1d/0x20
    [  132.613000]  [<ffffffff810aba5b>] __local_bh_enable_ip+0x6b/0x80
    [  132.613008]  [<ffffffff817d6c8a>] _raw_write_unlock_bh+0x1a/0x20
    [  132.613010]  [<ffffffff817d6c9e>] _raw_spin_unlock_bh+0xe/0x10
    [  132.613015]  [<ffffffff811388ac>] put_css_set+0x5c/0x60
    [  132.613016]  [<ffffffff8113dc7f>] cgroup_free+0x7f/0xa0
    [  132.613017]  [<ffffffff810a3912>] __put_task_struct+0x42/0x140
    [  132.613018]  [<ffffffff810e776a>] dl_task_timer+0xca/0x250
    [  132.613027]  [<ffffffff810e76a0>] ? push_dl_task.part.32+0x170/0x170
    [  132.613030]  [<ffffffff8111371e>] __hrtimer_run_queues+0xee/0x270
    [  132.613031]  [<ffffffff81113ec8>] hrtimer_interrupt+0xa8/0x190
    [  132.613034]  [<ffffffff81051a58>] local_apic_timer_interrupt+0x38/0x60
    [  132.613035]  [<ffffffff817d9b0d>] smp_apic_timer_interrupt+0x3d/0x50
    [  132.613037]  [<ffffffff817d7c5c>] apic_timer_interrupt+0x8c/0xa0
    [  132.613038]  <EOI>  [<ffffffff81063466>] ? native_safe_halt+0x6/0x10
    [  132.613043]  [<ffffffff81037a4e>] default_idle+0x1e/0xd0
    [  132.613044]  [<ffffffff810381cf>] arch_cpu_idle+0xf/0x20
    [  132.613046]  [<ffffffff810e8fda>] default_idle_call+0x2a/0x40
    [  132.613047]  [<ffffffff810e92d7>] cpu_startup_entry+0x2e7/0x340
    [  132.613048]  [<ffffffff81050235>] start_secondary+0x155/0x190
    [  132.613049] ---[ end trace f91934d162ce9977 ]---
    
    The warn is the spin_(lock|unlock)_bh(&css_set_lock) in the interrupt
    context. Converting the spin_lock_bh to spin_lock_irq(save) to avoid
    this problem - and other problems of sharing a spinlock with an
    interrupt.
    
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Li Zefan <lizefan@huawei.com>
    Cc: Johannes Weiner <hannes@cmpxchg.org>
    Cc: Juri Lelli <juri.lelli@arm.com>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: cgroups@vger.kernel.org
    Cc: stable@vger.kernel.org # 4.5+
    Cc: linux-kernel@vger.kernel.org
    Reviewed-by: Rik van Riel <riel@redhat.com>
    Reviewed-by: "Luis Claudio R. Goncalves" <lgoncalv@redhat.com>
    Signed-off-by: Daniel Bristot de Oliveira <bristot@redhat.com>
    Acked-by: Zefan Li <lizefan@huawei.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

commit ba6f5e33bdbb9ed2014b778fbbaecf20060ca989
Author: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
Date:   Wed Apr 6 15:15:19 2016 -0300

    sctp: avoid refreshing heartbeat timer too often
    
    Currently on high rate SCTP streams the heartbeat timer refresh can
    consume quite a lot of resources as timer updates are costly and it
    contains a random factor, which a) is also costly and b) invalidates
    mod_timer() optimization for not editing a timer to the same value.
    It may even cause the timer to be slightly advanced, for no good reason.
    
    As suggested by David Laight this patch now removes this timer update
    from hot path by leaving the timer on and re-evaluating upon its
    expiration if the heartbeat is still needed or not, similarly to what is
    done for TCP. If it's not needed anymore the timer is re-scheduled to
    the new timeout, considering the time already elapsed.
    
    For this, we now record the last tx timestamp per transport, updated in
    the same spots as hb timer was restarted on tx. Also split up
    sctp_transport_reset_timers into sctp_transport_reset_t3_rtx and
    sctp_transport_reset_hb_timer, so we can re-arm T3 without re-arming the
    heartbeat one.
    
    On loopback with MTU of 65535 and data chunks with 1636, so that we
    have a considerable amount of chunks without stressing system calls,
    netperf -t SCTP_STREAM -l 30, perf looked like this before:
    
    Samples: 103K of event 'cpu-clock', Event count (approx.): 25833000000
      Overhead  Command  Shared Object      Symbol
    +    6,15%  netperf  [kernel.vmlinux]   [k] copy_user_enhanced_fast_string
    -    5,43%  netperf  [kernel.vmlinux]   [k] _raw_write_unlock_irqrestore
       - _raw_write_unlock_irqrestore
          - 96,54% _raw_spin_unlock_irqrestore
             - 36,14% mod_timer
                + 97,24% sctp_transport_reset_timers
                + 2,76% sctp_do_sm
             + 33,65% __wake_up_sync_key
             + 28,77% sctp_ulpq_tail_event
             + 1,40% del_timer
          - 1,84% mod_timer
             + 99,03% sctp_transport_reset_timers
             + 0,97% sctp_do_sm
          + 1,50% sctp_ulpq_tail_event
    
    And after this patch, now with netperf -l 60:
    
    Samples: 230K of event 'cpu-clock', Event count (approx.): 57707250000
      Overhead  Command  Shared Object      Symbol
    +    5,65%  netperf  [kernel.vmlinux]   [k] memcpy_erms
    +    5,59%  netperf  [kernel.vmlinux]   [k] copy_user_enhanced_fast_string
    -    5,05%  netperf  [kernel.vmlinux]   [k] _raw_spin_unlock_irqrestore
       - _raw_spin_unlock_irqrestore
          + 49,89% __wake_up_sync_key
          + 45,68% sctp_ulpq_tail_event
          - 2,85% mod_timer
             + 76,51% sctp_transport_reset_t3_rtx
             + 23,49% sctp_do_sm
          + 1,55% del_timer
    +    2,50%  netperf  [sctp]             [k] sctp_datamsg_from_user
    +    2,26%  netperf  [sctp]             [k] sctp_sendmsg
    
    Throughput-wise, from 6800mbps without the patch to 7050mbps with it,
    ~3.7%.
    
    Signed-off-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit c9ff0e39da0903f48ef93983f84338674192936b
Author: Filipe Manana <fdmanana@suse.com>
Date:   Mon Mar 30 18:23:59 2015 +0100

    Btrfs: fix inode eviction infinite loop after cloning into it
    
    commit ccccf3d67294714af2d72a6fd6fd7d73b01c9329 upstream.
    
    If we attempt to clone a 0 length region into a file we can end up
    inserting a range in the inode's extent_io tree with a start offset
    that is greater then the end offset, which triggers immediately the
    following warning:
    
    [ 3914.619057] WARNING: CPU: 17 PID: 4199 at fs/btrfs/extent_io.c:435 insert_state+0x4b/0x10b [btrfs]()
    [ 3914.620886] BTRFS: end < start 4095 4096
    (...)
    [ 3914.638093] Call Trace:
    [ 3914.638636]  [<ffffffff81425fd9>] dump_stack+0x4c/0x65
    [ 3914.639620]  [<ffffffff81045390>] warn_slowpath_common+0xa1/0xbb
    [ 3914.640789]  [<ffffffffa03ca44f>] ? insert_state+0x4b/0x10b [btrfs]
    [ 3914.642041]  [<ffffffff810453f0>] warn_slowpath_fmt+0x46/0x48
    [ 3914.643236]  [<ffffffffa03ca44f>] insert_state+0x4b/0x10b [btrfs]
    [ 3914.644441]  [<ffffffffa03ca729>] __set_extent_bit+0x107/0x3f4 [btrfs]
    [ 3914.645711]  [<ffffffffa03cb256>] lock_extent_bits+0x65/0x1bf [btrfs]
    [ 3914.646914]  [<ffffffff8142b2fb>] ? _raw_spin_unlock+0x28/0x33
    [ 3914.648058]  [<ffffffffa03cbac4>] ? test_range_bit+0xcc/0xde [btrfs]
    [ 3914.650105]  [<ffffffffa03cb3c3>] lock_extent+0x13/0x15 [btrfs]
    [ 3914.651361]  [<ffffffffa03db39e>] lock_extent_range+0x3d/0xcd [btrfs]
    [ 3914.652761]  [<ffffffffa03de1fe>] btrfs_ioctl_clone+0x278/0x388 [btrfs]
    [ 3914.654128]  [<ffffffff811226dd>] ? might_fault+0x58/0xb5
    [ 3914.655320]  [<ffffffffa03e0909>] btrfs_ioctl+0xb51/0x2195 [btrfs]
    (...)
    [ 3914.669271] ---[ end trace 14843d3e2e622fc1 ]---
    
    This later makes the inode eviction handler enter an infinite loop that
    keeps dumping the following warning over and over:
    
    [ 3915.117629] WARNING: CPU: 22 PID: 4228 at fs/btrfs/extent_io.c:435 insert_state+0x4b/0x10b [btrfs]()
    [ 3915.119913] BTRFS: end < start 4095 4096
    (...)
    [ 3915.137394] Call Trace:
    [ 3915.137913]  [<ffffffff81425fd9>] dump_stack+0x4c/0x65
    [ 3915.139154]  [<ffffffff81045390>] warn_slowpath_common+0xa1/0xbb
    [ 3915.140316]  [<ffffffffa03ca44f>] ? insert_state+0x4b/0x10b [btrfs]
    [ 3915.141505]  [<ffffffff810453f0>] warn_slowpath_fmt+0x46/0x48
    [ 3915.142709]  [<ffffffffa03ca44f>] insert_state+0x4b/0x10b [btrfs]
    [ 3915.143849]  [<ffffffffa03ca729>] __set_extent_bit+0x107/0x3f4 [btrfs]
    [ 3915.145120]  [<ffffffffa038c1e3>] ? btrfs_kill_super+0x17/0x23 [btrfs]
    [ 3915.146352]  [<ffffffff811548f6>] ? deactivate_locked_super+0x3b/0x50
    [ 3915.147565]  [<ffffffffa03cb256>] lock_extent_bits+0x65/0x1bf [btrfs]
    [ 3915.148785]  [<ffffffff8142b7e2>] ? _raw_write_unlock+0x28/0x33
    [ 3915.149931]  [<ffffffffa03bc325>] btrfs_evict_inode+0x196/0x482 [btrfs]
    [ 3915.151154]  [<ffffffff81168904>] evict+0xa0/0x148
    [ 3915.152094]  [<ffffffff811689e5>] dispose_list+0x39/0x43
    [ 3915.153081]  [<ffffffff81169564>] evict_inodes+0xdc/0xeb
    [ 3915.154062]  [<ffffffff81154418>] generic_shutdown_super+0x49/0xef
    [ 3915.155193]  [<ffffffff811546d1>] kill_anon_super+0x13/0x1e
    [ 3915.156274]  [<ffffffffa038c1e3>] btrfs_kill_super+0x17/0x23 [btrfs]
    (...)
    [ 3915.167404] ---[ end trace 14843d3e2e622fc2 ]---
    
    So just bail out of the clone ioctl if the length of the region to clone
    is zero, without locking any extent range, in order to prevent this issue
    (same behaviour as a pwrite with a 0 length for example).
    
    This is trivial to reproduce. For example, the steps for the test I just
    made for fstests:
    
      mkfs.btrfs -f SCRATCH_DEV
      mount SCRATCH_DEV $SCRATCH_MNT
    
      touch $SCRATCH_MNT/foo
      touch $SCRATCH_MNT/bar
    
      $CLONER_PROG -s 0 -d 4096 -l 0 $SCRATCH_MNT/foo $SCRATCH_MNT/bar
      umount $SCRATCH_MNT
    
    A test case for fstests follows soon.
    
    Signed-off-by: Filipe Manana <fdmanana@suse.com>
    Reviewed-by: Omar Sandoval <osandov@osandov.com>
    Signed-off-by: Chris Mason <clm@fb.com>
    Signed-off-by: Zefan Li <lizefan@huawei.com>

commit ca520cab25e0e8da717c596ccaa2c2b3650cfa09
Merge: 4c12ab7e5e2e d420acd816c0
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Sep 3 15:46:07 2015 -0700

    Merge branch 'locking-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull locking and atomic updates from Ingo Molnar:
     "Main changes in this cycle are:
    
       - Extend atomic primitives with coherent logic op primitives
         (atomic_{or,and,xor}()) and deprecate the old partial APIs
         (atomic_{set,clear}_mask())
    
         The old ops were incoherent with incompatible signatures across
         architectures and with incomplete support.  Now every architecture
         supports the primitives consistently (by Peter Zijlstra)
    
       - Generic support for 'relaxed atomics':
    
           - _acquire/release/relaxed() flavours of xchg(), cmpxchg() and {add,sub}_return()
           - atomic_read_acquire()
           - atomic_set_release()
    
         This came out of porting qwrlock code to arm64 (by Will Deacon)
    
       - Clean up the fragile static_key APIs that were causing repeat bugs,
         by introducing a new one:
    
           DEFINE_STATIC_KEY_TRUE(name);
           DEFINE_STATIC_KEY_FALSE(name);
    
         which define a key of different types with an initial true/false
         value.
    
         Then allow:
    
           static_branch_likely()
           static_branch_unlikely()
    
         to take a key of either type and emit the right instruction for the
         case.  To be able to know the 'type' of the static key we encode it
         in the jump entry (by Peter Zijlstra)
    
       - Static key self-tests (by Jason Baron)
    
       - qrwlock optimizations (by Waiman Long)
    
       - small futex enhancements (by Davidlohr Bueso)
    
       - ... and misc other changes"
    
    * 'locking-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (63 commits)
      jump_label/x86: Work around asm build bug on older/backported GCCs
      locking, ARM, atomics: Define our SMP atomics in terms of _relaxed() operations
      locking, include/llist: Use linux/atomic.h instead of asm/cmpxchg.h
      locking/qrwlock: Make use of _{acquire|release|relaxed}() atomics
      locking/qrwlock: Implement queue_write_unlock() using smp_store_release()
      locking/lockref: Remove homebrew cmpxchg64_relaxed() macro definition
      locking, asm-generic: Add _{relaxed|acquire|release}() variants for 'atomic_long_t'
      locking, asm-generic: Rework atomic-long.h to avoid bulk code duplication
      locking/atomics: Add _{acquire|release|relaxed}() variants of some atomic operations
      locking, compiler.h: Cast away attributes in the WRITE_ONCE() magic
      locking/static_keys: Make verify_keys() static
      jump label, locking/static_keys: Update docs
      locking/static_keys: Provide a selftest
      jump_label: Provide a self-test
      s390/uaccess, locking/static_keys: employ static_branch_likely()
      x86, tsc, locking/static_keys: Employ static_branch_likely()
      locking/static_keys: Add selftest
      locking/static_keys: Add a new static_key interface
      locking/static_keys: Rework update logic
      locking/static_keys: Add static_key_{en,dis}able() helpers
      ...

commit 2b2a85a4d3534b8884fcfa5bb52837f0e1c672bc
Author: Will Deacon <will.deacon@arm.com>
Date:   Thu Aug 6 17:54:41 2015 +0100

    locking/qrwlock: Implement queue_write_unlock() using smp_store_release()
    
    Since the following commit:
    
      536fa402221f ("compiler: Allow 1- and 2-byte smp_load_acquire() and smp_store_release()")
    
    smp_store_release() supports byte accesses, so use that in writer unlock
    and remove the conditional macro override.
    
    Signed-off-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Reviewed-by: Waiman Long <Waiman.Long@hp.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: paulmck@linux.vnet.ibm.com
    Link: http://lkml.kernel.org/r/1438880084-18856-6-git-send-email-will.deacon@arm.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit aae89a4f7996bb0f5ded693fb1768f2faa9f4ace
Author: Filipe Manana <fdmanana@suse.com>
Date:   Mon Mar 30 18:23:59 2015 +0100

    Btrfs: fix inode eviction infinite loop after cloning into it
    
    commit ccccf3d67294714af2d72a6fd6fd7d73b01c9329 upstream.
    
    If we attempt to clone a 0 length region into a file we can end up
    inserting a range in the inode's extent_io tree with a start offset
    that is greater then the end offset, which triggers immediately the
    following warning:
    
    [ 3914.619057] WARNING: CPU: 17 PID: 4199 at fs/btrfs/extent_io.c:435 insert_state+0x4b/0x10b [btrfs]()
    [ 3914.620886] BTRFS: end < start 4095 4096
    (...)
    [ 3914.638093] Call Trace:
    [ 3914.638636]  [<ffffffff81425fd9>] dump_stack+0x4c/0x65
    [ 3914.639620]  [<ffffffff81045390>] warn_slowpath_common+0xa1/0xbb
    [ 3914.640789]  [<ffffffffa03ca44f>] ? insert_state+0x4b/0x10b [btrfs]
    [ 3914.642041]  [<ffffffff810453f0>] warn_slowpath_fmt+0x46/0x48
    [ 3914.643236]  [<ffffffffa03ca44f>] insert_state+0x4b/0x10b [btrfs]
    [ 3914.644441]  [<ffffffffa03ca729>] __set_extent_bit+0x107/0x3f4 [btrfs]
    [ 3914.645711]  [<ffffffffa03cb256>] lock_extent_bits+0x65/0x1bf [btrfs]
    [ 3914.646914]  [<ffffffff8142b2fb>] ? _raw_spin_unlock+0x28/0x33
    [ 3914.648058]  [<ffffffffa03cbac4>] ? test_range_bit+0xcc/0xde [btrfs]
    [ 3914.650105]  [<ffffffffa03cb3c3>] lock_extent+0x13/0x15 [btrfs]
    [ 3914.651361]  [<ffffffffa03db39e>] lock_extent_range+0x3d/0xcd [btrfs]
    [ 3914.652761]  [<ffffffffa03de1fe>] btrfs_ioctl_clone+0x278/0x388 [btrfs]
    [ 3914.654128]  [<ffffffff811226dd>] ? might_fault+0x58/0xb5
    [ 3914.655320]  [<ffffffffa03e0909>] btrfs_ioctl+0xb51/0x2195 [btrfs]
    (...)
    [ 3914.669271] ---[ end trace 14843d3e2e622fc1 ]---
    
    This later makes the inode eviction handler enter an infinite loop that
    keeps dumping the following warning over and over:
    
    [ 3915.117629] WARNING: CPU: 22 PID: 4228 at fs/btrfs/extent_io.c:435 insert_state+0x4b/0x10b [btrfs]()
    [ 3915.119913] BTRFS: end < start 4095 4096
    (...)
    [ 3915.137394] Call Trace:
    [ 3915.137913]  [<ffffffff81425fd9>] dump_stack+0x4c/0x65
    [ 3915.139154]  [<ffffffff81045390>] warn_slowpath_common+0xa1/0xbb
    [ 3915.140316]  [<ffffffffa03ca44f>] ? insert_state+0x4b/0x10b [btrfs]
    [ 3915.141505]  [<ffffffff810453f0>] warn_slowpath_fmt+0x46/0x48
    [ 3915.142709]  [<ffffffffa03ca44f>] insert_state+0x4b/0x10b [btrfs]
    [ 3915.143849]  [<ffffffffa03ca729>] __set_extent_bit+0x107/0x3f4 [btrfs]
    [ 3915.145120]  [<ffffffffa038c1e3>] ? btrfs_kill_super+0x17/0x23 [btrfs]
    [ 3915.146352]  [<ffffffff811548f6>] ? deactivate_locked_super+0x3b/0x50
    [ 3915.147565]  [<ffffffffa03cb256>] lock_extent_bits+0x65/0x1bf [btrfs]
    [ 3915.148785]  [<ffffffff8142b7e2>] ? _raw_write_unlock+0x28/0x33
    [ 3915.149931]  [<ffffffffa03bc325>] btrfs_evict_inode+0x196/0x482 [btrfs]
    [ 3915.151154]  [<ffffffff81168904>] evict+0xa0/0x148
    [ 3915.152094]  [<ffffffff811689e5>] dispose_list+0x39/0x43
    [ 3915.153081]  [<ffffffff81169564>] evict_inodes+0xdc/0xeb
    [ 3915.154062]  [<ffffffff81154418>] generic_shutdown_super+0x49/0xef
    [ 3915.155193]  [<ffffffff811546d1>] kill_anon_super+0x13/0x1e
    [ 3915.156274]  [<ffffffffa038c1e3>] btrfs_kill_super+0x17/0x23 [btrfs]
    (...)
    [ 3915.167404] ---[ end trace 14843d3e2e622fc2 ]---
    
    So just bail out of the clone ioctl if the length of the region to clone
    is zero, without locking any extent range, in order to prevent this issue
    (same behaviour as a pwrite with a 0 length for example).
    
    This is trivial to reproduce. For example, the steps for the test I just
    made for fstests:
    
      mkfs.btrfs -f SCRATCH_DEV
      mount SCRATCH_DEV $SCRATCH_MNT
    
      touch $SCRATCH_MNT/foo
      touch $SCRATCH_MNT/bar
    
      $CLONER_PROG -s 0 -d 4096 -l 0 $SCRATCH_MNT/foo $SCRATCH_MNT/bar
      umount $SCRATCH_MNT
    
    A test case for fstests follows soon.
    
    Signed-off-by: Filipe Manana <fdmanana@suse.com>
    Reviewed-by: Omar Sandoval <osandov@osandov.com>
    Signed-off-by: Chris Mason <clm@fb.com>
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit 6f6ed482653723e53da4a57b200348ac1eed5ce9
Author: Leonid Yegoshin <Leonid.Yegoshin@imgtec.com>
Date:   Mon Jun 1 17:09:52 2015 -0700

    MIPS: Replace smp_mb with release barrier function in unlocks.
    
    Repleace smp_mb() in arch_write_unlock() and __clear_bit_unlock() to
    smp_mb__before_llsc() call which does "release" barrier functionality.
    
    It seems like it was missed in commit f252ffd50c97dae87b45f1dbad24f71358ccfbd6
    during introduction of "acquire" and "release" semantics.
    
    [ralf@linux-mips: The original patch submission was labelled a fix but
    actually it replaces a barrier with another less restrictive type of
    barrier so it doesn't fix any ill behaviour but rather squeezes out a
    tad better performance.  Further improvments will be possible once
    smp_release() has been merged.]
    
    Signed-off-by: Leonid Yegoshin <Leonid.Yegoshin@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Cc: benh@kernel.crashing.org
    Cc: will.deacon@arm.com
    Cc: linux-kernel@vger.kernel.org
    Cc: markos.chandras@imgtec.com
    Cc: macro@linux-mips.org
    Cc: Steven.Hill@imgtec.com
    Cc: alexander.h.duyck@redhat.com
    Cc: davem@davemloft.net
    Patchwork: https://patchwork.linux-mips.org/patch/10507/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

commit f548d99ef4f5ec8f7080e88ad07c44d16d058ddc
Author: Alexey Kodanev <alexey.kodanev@oracle.com>
Date:   Sat Mar 7 03:06:53 2015 +0300

    locktorture: fix deadlock in 'rw_lock_irq' type
    
    torture_rwlock_read_unlock_irq() must use read_unlock_irqrestore()
    instead of write_unlock_irqrestore().
    
    Use read_unlock_irqrestore() instead of write_unlock_irqrestore().
    
    Signed-off-by: Alexey Kodanev <alexey.kodanev@oracle.com>
    Signed-off-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Reviewed-by: Josh Triplett <josh@joshtriplett.org>

commit d5454242a1332e0a9a9ff154618c57b7629d41e7
Author: Filipe Manana <fdmanana@suse.com>
Date:   Mon Mar 30 18:23:59 2015 +0100

    Btrfs: fix inode eviction infinite loop after cloning into it
    
    [ Upstream commit HEAD ]
    
    commit ccccf3d67294714af2d72a6fd6fd7d73b01c9329 upstream.
    
    If we attempt to clone a 0 length region into a file we can end up
    inserting a range in the inode's extent_io tree with a start offset
    that is greater then the end offset, which triggers immediately the
    following warning:
    
    [ 3914.619057] WARNING: CPU: 17 PID: 4199 at fs/btrfs/extent_io.c:435 insert_state+0x4b/0x10b [btrfs]()
    [ 3914.620886] BTRFS: end < start 4095 4096
    (...)
    [ 3914.638093] Call Trace:
    [ 3914.638636]  [<ffffffff81425fd9>] dump_stack+0x4c/0x65
    [ 3914.639620]  [<ffffffff81045390>] warn_slowpath_common+0xa1/0xbb
    [ 3914.640789]  [<ffffffffa03ca44f>] ? insert_state+0x4b/0x10b [btrfs]
    [ 3914.642041]  [<ffffffff810453f0>] warn_slowpath_fmt+0x46/0x48
    [ 3914.643236]  [<ffffffffa03ca44f>] insert_state+0x4b/0x10b [btrfs]
    [ 3914.644441]  [<ffffffffa03ca729>] __set_extent_bit+0x107/0x3f4 [btrfs]
    [ 3914.645711]  [<ffffffffa03cb256>] lock_extent_bits+0x65/0x1bf [btrfs]
    [ 3914.646914]  [<ffffffff8142b2fb>] ? _raw_spin_unlock+0x28/0x33
    [ 3914.648058]  [<ffffffffa03cbac4>] ? test_range_bit+0xcc/0xde [btrfs]
    [ 3914.650105]  [<ffffffffa03cb3c3>] lock_extent+0x13/0x15 [btrfs]
    [ 3914.651361]  [<ffffffffa03db39e>] lock_extent_range+0x3d/0xcd [btrfs]
    [ 3914.652761]  [<ffffffffa03de1fe>] btrfs_ioctl_clone+0x278/0x388 [btrfs]
    [ 3914.654128]  [<ffffffff811226dd>] ? might_fault+0x58/0xb5
    [ 3914.655320]  [<ffffffffa03e0909>] btrfs_ioctl+0xb51/0x2195 [btrfs]
    (...)
    [ 3914.669271] ---[ end trace 14843d3e2e622fc1 ]---
    
    This later makes the inode eviction handler enter an infinite loop that
    keeps dumping the following warning over and over:
    
    [ 3915.117629] WARNING: CPU: 22 PID: 4228 at fs/btrfs/extent_io.c:435 insert_state+0x4b/0x10b [btrfs]()
    [ 3915.119913] BTRFS: end < start 4095 4096
    (...)
    [ 3915.137394] Call Trace:
    [ 3915.137913]  [<ffffffff81425fd9>] dump_stack+0x4c/0x65
    [ 3915.139154]  [<ffffffff81045390>] warn_slowpath_common+0xa1/0xbb
    [ 3915.140316]  [<ffffffffa03ca44f>] ? insert_state+0x4b/0x10b [btrfs]
    [ 3915.141505]  [<ffffffff810453f0>] warn_slowpath_fmt+0x46/0x48
    [ 3915.142709]  [<ffffffffa03ca44f>] insert_state+0x4b/0x10b [btrfs]
    [ 3915.143849]  [<ffffffffa03ca729>] __set_extent_bit+0x107/0x3f4 [btrfs]
    [ 3915.145120]  [<ffffffffa038c1e3>] ? btrfs_kill_super+0x17/0x23 [btrfs]
    [ 3915.146352]  [<ffffffff811548f6>] ? deactivate_locked_super+0x3b/0x50
    [ 3915.147565]  [<ffffffffa03cb256>] lock_extent_bits+0x65/0x1bf [btrfs]
    [ 3915.148785]  [<ffffffff8142b7e2>] ? _raw_write_unlock+0x28/0x33
    [ 3915.149931]  [<ffffffffa03bc325>] btrfs_evict_inode+0x196/0x482 [btrfs]
    [ 3915.151154]  [<ffffffff81168904>] evict+0xa0/0x148
    [ 3915.152094]  [<ffffffff811689e5>] dispose_list+0x39/0x43
    [ 3915.153081]  [<ffffffff81169564>] evict_inodes+0xdc/0xeb
    [ 3915.154062]  [<ffffffff81154418>] generic_shutdown_super+0x49/0xef
    [ 3915.155193]  [<ffffffff811546d1>] kill_anon_super+0x13/0x1e
    [ 3915.156274]  [<ffffffffa038c1e3>] btrfs_kill_super+0x17/0x23 [btrfs]
    (...)
    [ 3915.167404] ---[ end trace 14843d3e2e622fc2 ]---
    
    So just bail out of the clone ioctl if the length of the region to clone
    is zero, without locking any extent range, in order to prevent this issue
    (same behaviour as a pwrite with a 0 length for example).
    
    This is trivial to reproduce. For example, the steps for the test I just
    made for fstests:
    
      mkfs.btrfs -f SCRATCH_DEV
      mount SCRATCH_DEV $SCRATCH_MNT
    
      touch $SCRATCH_MNT/foo
      touch $SCRATCH_MNT/bar
    
      $CLONER_PROG -s 0 -d 4096 -l 0 $SCRATCH_MNT/foo $SCRATCH_MNT/bar
      umount $SCRATCH_MNT
    
    A test case for fstests follows soon.
    
    Signed-off-by: Filipe Manana <fdmanana@suse.com>
    Reviewed-by: Omar Sandoval <osandov@osandov.com>
    Signed-off-by: Chris Mason <clm@fb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    
    (cherry picked from commit 449b46275ce58e1d3fc20d1efacd0d0369c6070f)
    Signed-off-by: Sasha Levin <sasha.levin@oracle.com>

commit 9301d5068d8732a0f2d787240270a1426d09ecf5
Author: Filipe Manana <fdmanana@suse.com>
Date:   Mon Mar 30 18:23:59 2015 +0100

    Btrfs: fix inode eviction infinite loop after cloning into it
    
    commit ccccf3d67294714af2d72a6fd6fd7d73b01c9329 upstream.
    
    If we attempt to clone a 0 length region into a file we can end up
    inserting a range in the inode's extent_io tree with a start offset
    that is greater then the end offset, which triggers immediately the
    following warning:
    
    [ 3914.619057] WARNING: CPU: 17 PID: 4199 at fs/btrfs/extent_io.c:435 insert_state+0x4b/0x10b [btrfs]()
    [ 3914.620886] BTRFS: end < start 4095 4096
    (...)
    [ 3914.638093] Call Trace:
    [ 3914.638636]  [<ffffffff81425fd9>] dump_stack+0x4c/0x65
    [ 3914.639620]  [<ffffffff81045390>] warn_slowpath_common+0xa1/0xbb
    [ 3914.640789]  [<ffffffffa03ca44f>] ? insert_state+0x4b/0x10b [btrfs]
    [ 3914.642041]  [<ffffffff810453f0>] warn_slowpath_fmt+0x46/0x48
    [ 3914.643236]  [<ffffffffa03ca44f>] insert_state+0x4b/0x10b [btrfs]
    [ 3914.644441]  [<ffffffffa03ca729>] __set_extent_bit+0x107/0x3f4 [btrfs]
    [ 3914.645711]  [<ffffffffa03cb256>] lock_extent_bits+0x65/0x1bf [btrfs]
    [ 3914.646914]  [<ffffffff8142b2fb>] ? _raw_spin_unlock+0x28/0x33
    [ 3914.648058]  [<ffffffffa03cbac4>] ? test_range_bit+0xcc/0xde [btrfs]
    [ 3914.650105]  [<ffffffffa03cb3c3>] lock_extent+0x13/0x15 [btrfs]
    [ 3914.651361]  [<ffffffffa03db39e>] lock_extent_range+0x3d/0xcd [btrfs]
    [ 3914.652761]  [<ffffffffa03de1fe>] btrfs_ioctl_clone+0x278/0x388 [btrfs]
    [ 3914.654128]  [<ffffffff811226dd>] ? might_fault+0x58/0xb5
    [ 3914.655320]  [<ffffffffa03e0909>] btrfs_ioctl+0xb51/0x2195 [btrfs]
    (...)
    [ 3914.669271] ---[ end trace 14843d3e2e622fc1 ]---
    
    This later makes the inode eviction handler enter an infinite loop that
    keeps dumping the following warning over and over:
    
    [ 3915.117629] WARNING: CPU: 22 PID: 4228 at fs/btrfs/extent_io.c:435 insert_state+0x4b/0x10b [btrfs]()
    [ 3915.119913] BTRFS: end < start 4095 4096
    (...)
    [ 3915.137394] Call Trace:
    [ 3915.137913]  [<ffffffff81425fd9>] dump_stack+0x4c/0x65
    [ 3915.139154]  [<ffffffff81045390>] warn_slowpath_common+0xa1/0xbb
    [ 3915.140316]  [<ffffffffa03ca44f>] ? insert_state+0x4b/0x10b [btrfs]
    [ 3915.141505]  [<ffffffff810453f0>] warn_slowpath_fmt+0x46/0x48
    [ 3915.142709]  [<ffffffffa03ca44f>] insert_state+0x4b/0x10b [btrfs]
    [ 3915.143849]  [<ffffffffa03ca729>] __set_extent_bit+0x107/0x3f4 [btrfs]
    [ 3915.145120]  [<ffffffffa038c1e3>] ? btrfs_kill_super+0x17/0x23 [btrfs]
    [ 3915.146352]  [<ffffffff811548f6>] ? deactivate_locked_super+0x3b/0x50
    [ 3915.147565]  [<ffffffffa03cb256>] lock_extent_bits+0x65/0x1bf [btrfs]
    [ 3915.148785]  [<ffffffff8142b7e2>] ? _raw_write_unlock+0x28/0x33
    [ 3915.149931]  [<ffffffffa03bc325>] btrfs_evict_inode+0x196/0x482 [btrfs]
    [ 3915.151154]  [<ffffffff81168904>] evict+0xa0/0x148
    [ 3915.152094]  [<ffffffff811689e5>] dispose_list+0x39/0x43
    [ 3915.153081]  [<ffffffff81169564>] evict_inodes+0xdc/0xeb
    [ 3915.154062]  [<ffffffff81154418>] generic_shutdown_super+0x49/0xef
    [ 3915.155193]  [<ffffffff811546d1>] kill_anon_super+0x13/0x1e
    [ 3915.156274]  [<ffffffffa038c1e3>] btrfs_kill_super+0x17/0x23 [btrfs]
    (...)
    [ 3915.167404] ---[ end trace 14843d3e2e622fc2 ]---
    
    So just bail out of the clone ioctl if the length of the region to clone
    is zero, without locking any extent range, in order to prevent this issue
    (same behaviour as a pwrite with a 0 length for example).
    
    This is trivial to reproduce. For example, the steps for the test I just
    made for fstests:
    
      mkfs.btrfs -f SCRATCH_DEV
      mount SCRATCH_DEV $SCRATCH_MNT
    
      touch $SCRATCH_MNT/foo
      touch $SCRATCH_MNT/bar
    
      $CLONER_PROG -s 0 -d 4096 -l 0 $SCRATCH_MNT/foo $SCRATCH_MNT/bar
      umount $SCRATCH_MNT
    
    A test case for fstests follows soon.
    
    Signed-off-by: Filipe Manana <fdmanana@suse.com>
    Reviewed-by: Omar Sandoval <osandov@osandov.com>
    Signed-off-by: Chris Mason <clm@fb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 449b46275ce58e1d3fc20d1efacd0d0369c6070f
Author: Filipe Manana <fdmanana@suse.com>
Date:   Mon Mar 30 18:23:59 2015 +0100

    Btrfs: fix inode eviction infinite loop after cloning into it
    
    commit ccccf3d67294714af2d72a6fd6fd7d73b01c9329 upstream.
    
    If we attempt to clone a 0 length region into a file we can end up
    inserting a range in the inode's extent_io tree with a start offset
    that is greater then the end offset, which triggers immediately the
    following warning:
    
    [ 3914.619057] WARNING: CPU: 17 PID: 4199 at fs/btrfs/extent_io.c:435 insert_state+0x4b/0x10b [btrfs]()
    [ 3914.620886] BTRFS: end < start 4095 4096
    (...)
    [ 3914.638093] Call Trace:
    [ 3914.638636]  [<ffffffff81425fd9>] dump_stack+0x4c/0x65
    [ 3914.639620]  [<ffffffff81045390>] warn_slowpath_common+0xa1/0xbb
    [ 3914.640789]  [<ffffffffa03ca44f>] ? insert_state+0x4b/0x10b [btrfs]
    [ 3914.642041]  [<ffffffff810453f0>] warn_slowpath_fmt+0x46/0x48
    [ 3914.643236]  [<ffffffffa03ca44f>] insert_state+0x4b/0x10b [btrfs]
    [ 3914.644441]  [<ffffffffa03ca729>] __set_extent_bit+0x107/0x3f4 [btrfs]
    [ 3914.645711]  [<ffffffffa03cb256>] lock_extent_bits+0x65/0x1bf [btrfs]
    [ 3914.646914]  [<ffffffff8142b2fb>] ? _raw_spin_unlock+0x28/0x33
    [ 3914.648058]  [<ffffffffa03cbac4>] ? test_range_bit+0xcc/0xde [btrfs]
    [ 3914.650105]  [<ffffffffa03cb3c3>] lock_extent+0x13/0x15 [btrfs]
    [ 3914.651361]  [<ffffffffa03db39e>] lock_extent_range+0x3d/0xcd [btrfs]
    [ 3914.652761]  [<ffffffffa03de1fe>] btrfs_ioctl_clone+0x278/0x388 [btrfs]
    [ 3914.654128]  [<ffffffff811226dd>] ? might_fault+0x58/0xb5
    [ 3914.655320]  [<ffffffffa03e0909>] btrfs_ioctl+0xb51/0x2195 [btrfs]
    (...)
    [ 3914.669271] ---[ end trace 14843d3e2e622fc1 ]---
    
    This later makes the inode eviction handler enter an infinite loop that
    keeps dumping the following warning over and over:
    
    [ 3915.117629] WARNING: CPU: 22 PID: 4228 at fs/btrfs/extent_io.c:435 insert_state+0x4b/0x10b [btrfs]()
    [ 3915.119913] BTRFS: end < start 4095 4096
    (...)
    [ 3915.137394] Call Trace:
    [ 3915.137913]  [<ffffffff81425fd9>] dump_stack+0x4c/0x65
    [ 3915.139154]  [<ffffffff81045390>] warn_slowpath_common+0xa1/0xbb
    [ 3915.140316]  [<ffffffffa03ca44f>] ? insert_state+0x4b/0x10b [btrfs]
    [ 3915.141505]  [<ffffffff810453f0>] warn_slowpath_fmt+0x46/0x48
    [ 3915.142709]  [<ffffffffa03ca44f>] insert_state+0x4b/0x10b [btrfs]
    [ 3915.143849]  [<ffffffffa03ca729>] __set_extent_bit+0x107/0x3f4 [btrfs]
    [ 3915.145120]  [<ffffffffa038c1e3>] ? btrfs_kill_super+0x17/0x23 [btrfs]
    [ 3915.146352]  [<ffffffff811548f6>] ? deactivate_locked_super+0x3b/0x50
    [ 3915.147565]  [<ffffffffa03cb256>] lock_extent_bits+0x65/0x1bf [btrfs]
    [ 3915.148785]  [<ffffffff8142b7e2>] ? _raw_write_unlock+0x28/0x33
    [ 3915.149931]  [<ffffffffa03bc325>] btrfs_evict_inode+0x196/0x482 [btrfs]
    [ 3915.151154]  [<ffffffff81168904>] evict+0xa0/0x148
    [ 3915.152094]  [<ffffffff811689e5>] dispose_list+0x39/0x43
    [ 3915.153081]  [<ffffffff81169564>] evict_inodes+0xdc/0xeb
    [ 3915.154062]  [<ffffffff81154418>] generic_shutdown_super+0x49/0xef
    [ 3915.155193]  [<ffffffff811546d1>] kill_anon_super+0x13/0x1e
    [ 3915.156274]  [<ffffffffa038c1e3>] btrfs_kill_super+0x17/0x23 [btrfs]
    (...)
    [ 3915.167404] ---[ end trace 14843d3e2e622fc2 ]---
    
    So just bail out of the clone ioctl if the length of the region to clone
    is zero, without locking any extent range, in order to prevent this issue
    (same behaviour as a pwrite with a 0 length for example).
    
    This is trivial to reproduce. For example, the steps for the test I just
    made for fstests:
    
      mkfs.btrfs -f SCRATCH_DEV
      mount SCRATCH_DEV $SCRATCH_MNT
    
      touch $SCRATCH_MNT/foo
      touch $SCRATCH_MNT/bar
    
      $CLONER_PROG -s 0 -d 4096 -l 0 $SCRATCH_MNT/foo $SCRATCH_MNT/bar
      umount $SCRATCH_MNT
    
    A test case for fstests follows soon.
    
    Signed-off-by: Filipe Manana <fdmanana@suse.com>
    Reviewed-by: Omar Sandoval <osandov@osandov.com>
    Signed-off-by: Chris Mason <clm@fb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 81a65d1f0fcda11ff10f6a1bd0da5b39961bf493
Author: Filipe Manana <fdmanana@suse.com>
Date:   Mon Mar 30 18:23:59 2015 +0100

    Btrfs: fix inode eviction infinite loop after cloning into it
    
    commit ccccf3d67294714af2d72a6fd6fd7d73b01c9329 upstream.
    
    If we attempt to clone a 0 length region into a file we can end up
    inserting a range in the inode's extent_io tree with a start offset
    that is greater then the end offset, which triggers immediately the
    following warning:
    
    [ 3914.619057] WARNING: CPU: 17 PID: 4199 at fs/btrfs/extent_io.c:435 insert_state+0x4b/0x10b [btrfs]()
    [ 3914.620886] BTRFS: end < start 4095 4096
    (...)
    [ 3914.638093] Call Trace:
    [ 3914.638636]  [<ffffffff81425fd9>] dump_stack+0x4c/0x65
    [ 3914.639620]  [<ffffffff81045390>] warn_slowpath_common+0xa1/0xbb
    [ 3914.640789]  [<ffffffffa03ca44f>] ? insert_state+0x4b/0x10b [btrfs]
    [ 3914.642041]  [<ffffffff810453f0>] warn_slowpath_fmt+0x46/0x48
    [ 3914.643236]  [<ffffffffa03ca44f>] insert_state+0x4b/0x10b [btrfs]
    [ 3914.644441]  [<ffffffffa03ca729>] __set_extent_bit+0x107/0x3f4 [btrfs]
    [ 3914.645711]  [<ffffffffa03cb256>] lock_extent_bits+0x65/0x1bf [btrfs]
    [ 3914.646914]  [<ffffffff8142b2fb>] ? _raw_spin_unlock+0x28/0x33
    [ 3914.648058]  [<ffffffffa03cbac4>] ? test_range_bit+0xcc/0xde [btrfs]
    [ 3914.650105]  [<ffffffffa03cb3c3>] lock_extent+0x13/0x15 [btrfs]
    [ 3914.651361]  [<ffffffffa03db39e>] lock_extent_range+0x3d/0xcd [btrfs]
    [ 3914.652761]  [<ffffffffa03de1fe>] btrfs_ioctl_clone+0x278/0x388 [btrfs]
    [ 3914.654128]  [<ffffffff811226dd>] ? might_fault+0x58/0xb5
    [ 3914.655320]  [<ffffffffa03e0909>] btrfs_ioctl+0xb51/0x2195 [btrfs]
    (...)
    [ 3914.669271] ---[ end trace 14843d3e2e622fc1 ]---
    
    This later makes the inode eviction handler enter an infinite loop that
    keeps dumping the following warning over and over:
    
    [ 3915.117629] WARNING: CPU: 22 PID: 4228 at fs/btrfs/extent_io.c:435 insert_state+0x4b/0x10b [btrfs]()
    [ 3915.119913] BTRFS: end < start 4095 4096
    (...)
    [ 3915.137394] Call Trace:
    [ 3915.137913]  [<ffffffff81425fd9>] dump_stack+0x4c/0x65
    [ 3915.139154]  [<ffffffff81045390>] warn_slowpath_common+0xa1/0xbb
    [ 3915.140316]  [<ffffffffa03ca44f>] ? insert_state+0x4b/0x10b [btrfs]
    [ 3915.141505]  [<ffffffff810453f0>] warn_slowpath_fmt+0x46/0x48
    [ 3915.142709]  [<ffffffffa03ca44f>] insert_state+0x4b/0x10b [btrfs]
    [ 3915.143849]  [<ffffffffa03ca729>] __set_extent_bit+0x107/0x3f4 [btrfs]
    [ 3915.145120]  [<ffffffffa038c1e3>] ? btrfs_kill_super+0x17/0x23 [btrfs]
    [ 3915.146352]  [<ffffffff811548f6>] ? deactivate_locked_super+0x3b/0x50
    [ 3915.147565]  [<ffffffffa03cb256>] lock_extent_bits+0x65/0x1bf [btrfs]
    [ 3915.148785]  [<ffffffff8142b7e2>] ? _raw_write_unlock+0x28/0x33
    [ 3915.149931]  [<ffffffffa03bc325>] btrfs_evict_inode+0x196/0x482 [btrfs]
    [ 3915.151154]  [<ffffffff81168904>] evict+0xa0/0x148
    [ 3915.152094]  [<ffffffff811689e5>] dispose_list+0x39/0x43
    [ 3915.153081]  [<ffffffff81169564>] evict_inodes+0xdc/0xeb
    [ 3915.154062]  [<ffffffff81154418>] generic_shutdown_super+0x49/0xef
    [ 3915.155193]  [<ffffffff811546d1>] kill_anon_super+0x13/0x1e
    [ 3915.156274]  [<ffffffffa038c1e3>] btrfs_kill_super+0x17/0x23 [btrfs]
    (...)
    [ 3915.167404] ---[ end trace 14843d3e2e622fc2 ]---
    
    So just bail out of the clone ioctl if the length of the region to clone
    is zero, without locking any extent range, in order to prevent this issue
    (same behaviour as a pwrite with a 0 length for example).
    
    This is trivial to reproduce. For example, the steps for the test I just
    made for fstests:
    
      mkfs.btrfs -f SCRATCH_DEV
      mount SCRATCH_DEV $SCRATCH_MNT
    
      touch $SCRATCH_MNT/foo
      touch $SCRATCH_MNT/bar
    
      $CLONER_PROG -s 0 -d 4096 -l 0 $SCRATCH_MNT/foo $SCRATCH_MNT/bar
      umount $SCRATCH_MNT
    
    A test case for fstests follows soon.
    
    Signed-off-by: Filipe Manana <fdmanana@suse.com>
    Reviewed-by: Omar Sandoval <osandov@osandov.com>
    Signed-off-by: Chris Mason <clm@fb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 6073c4162289fcae16b359f8e105d60343a209ca
Author: Filipe Manana <fdmanana@suse.com>
Date:   Mon Mar 30 18:23:59 2015 +0100

    Btrfs: fix inode eviction infinite loop after cloning into it
    
    commit ccccf3d67294714af2d72a6fd6fd7d73b01c9329 upstream.
    
    If we attempt to clone a 0 length region into a file we can end up
    inserting a range in the inode's extent_io tree with a start offset
    that is greater then the end offset, which triggers immediately the
    following warning:
    
    [ 3914.619057] WARNING: CPU: 17 PID: 4199 at fs/btrfs/extent_io.c:435 insert_state+0x4b/0x10b [btrfs]()
    [ 3914.620886] BTRFS: end < start 4095 4096
    (...)
    [ 3914.638093] Call Trace:
    [ 3914.638636]  [<ffffffff81425fd9>] dump_stack+0x4c/0x65
    [ 3914.639620]  [<ffffffff81045390>] warn_slowpath_common+0xa1/0xbb
    [ 3914.640789]  [<ffffffffa03ca44f>] ? insert_state+0x4b/0x10b [btrfs]
    [ 3914.642041]  [<ffffffff810453f0>] warn_slowpath_fmt+0x46/0x48
    [ 3914.643236]  [<ffffffffa03ca44f>] insert_state+0x4b/0x10b [btrfs]
    [ 3914.644441]  [<ffffffffa03ca729>] __set_extent_bit+0x107/0x3f4 [btrfs]
    [ 3914.645711]  [<ffffffffa03cb256>] lock_extent_bits+0x65/0x1bf [btrfs]
    [ 3914.646914]  [<ffffffff8142b2fb>] ? _raw_spin_unlock+0x28/0x33
    [ 3914.648058]  [<ffffffffa03cbac4>] ? test_range_bit+0xcc/0xde [btrfs]
    [ 3914.650105]  [<ffffffffa03cb3c3>] lock_extent+0x13/0x15 [btrfs]
    [ 3914.651361]  [<ffffffffa03db39e>] lock_extent_range+0x3d/0xcd [btrfs]
    [ 3914.652761]  [<ffffffffa03de1fe>] btrfs_ioctl_clone+0x278/0x388 [btrfs]
    [ 3914.654128]  [<ffffffff811226dd>] ? might_fault+0x58/0xb5
    [ 3914.655320]  [<ffffffffa03e0909>] btrfs_ioctl+0xb51/0x2195 [btrfs]
    (...)
    [ 3914.669271] ---[ end trace 14843d3e2e622fc1 ]---
    
    This later makes the inode eviction handler enter an infinite loop that
    keeps dumping the following warning over and over:
    
    [ 3915.117629] WARNING: CPU: 22 PID: 4228 at fs/btrfs/extent_io.c:435 insert_state+0x4b/0x10b [btrfs]()
    [ 3915.119913] BTRFS: end < start 4095 4096
    (...)
    [ 3915.137394] Call Trace:
    [ 3915.137913]  [<ffffffff81425fd9>] dump_stack+0x4c/0x65
    [ 3915.139154]  [<ffffffff81045390>] warn_slowpath_common+0xa1/0xbb
    [ 3915.140316]  [<ffffffffa03ca44f>] ? insert_state+0x4b/0x10b [btrfs]
    [ 3915.141505]  [<ffffffff810453f0>] warn_slowpath_fmt+0x46/0x48
    [ 3915.142709]  [<ffffffffa03ca44f>] insert_state+0x4b/0x10b [btrfs]
    [ 3915.143849]  [<ffffffffa03ca729>] __set_extent_bit+0x107/0x3f4 [btrfs]
    [ 3915.145120]  [<ffffffffa038c1e3>] ? btrfs_kill_super+0x17/0x23 [btrfs]
    [ 3915.146352]  [<ffffffff811548f6>] ? deactivate_locked_super+0x3b/0x50
    [ 3915.147565]  [<ffffffffa03cb256>] lock_extent_bits+0x65/0x1bf [btrfs]
    [ 3915.148785]  [<ffffffff8142b7e2>] ? _raw_write_unlock+0x28/0x33
    [ 3915.149931]  [<ffffffffa03bc325>] btrfs_evict_inode+0x196/0x482 [btrfs]
    [ 3915.151154]  [<ffffffff81168904>] evict+0xa0/0x148
    [ 3915.152094]  [<ffffffff811689e5>] dispose_list+0x39/0x43
    [ 3915.153081]  [<ffffffff81169564>] evict_inodes+0xdc/0xeb
    [ 3915.154062]  [<ffffffff81154418>] generic_shutdown_super+0x49/0xef
    [ 3915.155193]  [<ffffffff811546d1>] kill_anon_super+0x13/0x1e
    [ 3915.156274]  [<ffffffffa038c1e3>] btrfs_kill_super+0x17/0x23 [btrfs]
    (...)
    [ 3915.167404] ---[ end trace 14843d3e2e622fc2 ]---
    
    So just bail out of the clone ioctl if the length of the region to clone
    is zero, without locking any extent range, in order to prevent this issue
    (same behaviour as a pwrite with a 0 length for example).
    
    This is trivial to reproduce. For example, the steps for the test I just
    made for fstests:
    
      mkfs.btrfs -f SCRATCH_DEV
      mount SCRATCH_DEV $SCRATCH_MNT
    
      touch $SCRATCH_MNT/foo
      touch $SCRATCH_MNT/bar
    
      $CLONER_PROG -s 0 -d 4096 -l 0 $SCRATCH_MNT/foo $SCRATCH_MNT/bar
      umount $SCRATCH_MNT
    
    A test case for fstests follows soon.
    
    Signed-off-by: Filipe Manana <fdmanana@suse.com>
    Reviewed-by: Omar Sandoval <osandov@osandov.com>
    Signed-off-by: Chris Mason <clm@fb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit fea3314d5941f23306d9505321aaf5baebefb761
Author: Filipe Manana <fdmanana@suse.com>
Date:   Mon Mar 30 18:23:59 2015 +0100

    Btrfs: fix inode eviction infinite loop after cloning into it
    
    commit ccccf3d67294714af2d72a6fd6fd7d73b01c9329 upstream.
    
    If we attempt to clone a 0 length region into a file we can end up
    inserting a range in the inode's extent_io tree with a start offset
    that is greater then the end offset, which triggers immediately the
    following warning:
    
    [ 3914.619057] WARNING: CPU: 17 PID: 4199 at fs/btrfs/extent_io.c:435 insert_state+0x4b/0x10b [btrfs]()
    [ 3914.620886] BTRFS: end < start 4095 4096
    (...)
    [ 3914.638093] Call Trace:
    [ 3914.638636]  [<ffffffff81425fd9>] dump_stack+0x4c/0x65
    [ 3914.639620]  [<ffffffff81045390>] warn_slowpath_common+0xa1/0xbb
    [ 3914.640789]  [<ffffffffa03ca44f>] ? insert_state+0x4b/0x10b [btrfs]
    [ 3914.642041]  [<ffffffff810453f0>] warn_slowpath_fmt+0x46/0x48
    [ 3914.643236]  [<ffffffffa03ca44f>] insert_state+0x4b/0x10b [btrfs]
    [ 3914.644441]  [<ffffffffa03ca729>] __set_extent_bit+0x107/0x3f4 [btrfs]
    [ 3914.645711]  [<ffffffffa03cb256>] lock_extent_bits+0x65/0x1bf [btrfs]
    [ 3914.646914]  [<ffffffff8142b2fb>] ? _raw_spin_unlock+0x28/0x33
    [ 3914.648058]  [<ffffffffa03cbac4>] ? test_range_bit+0xcc/0xde [btrfs]
    [ 3914.650105]  [<ffffffffa03cb3c3>] lock_extent+0x13/0x15 [btrfs]
    [ 3914.651361]  [<ffffffffa03db39e>] lock_extent_range+0x3d/0xcd [btrfs]
    [ 3914.652761]  [<ffffffffa03de1fe>] btrfs_ioctl_clone+0x278/0x388 [btrfs]
    [ 3914.654128]  [<ffffffff811226dd>] ? might_fault+0x58/0xb5
    [ 3914.655320]  [<ffffffffa03e0909>] btrfs_ioctl+0xb51/0x2195 [btrfs]
    (...)
    [ 3914.669271] ---[ end trace 14843d3e2e622fc1 ]---
    
    This later makes the inode eviction handler enter an infinite loop that
    keeps dumping the following warning over and over:
    
    [ 3915.117629] WARNING: CPU: 22 PID: 4228 at fs/btrfs/extent_io.c:435 insert_state+0x4b/0x10b [btrfs]()
    [ 3915.119913] BTRFS: end < start 4095 4096
    (...)
    [ 3915.137394] Call Trace:
    [ 3915.137913]  [<ffffffff81425fd9>] dump_stack+0x4c/0x65
    [ 3915.139154]  [<ffffffff81045390>] warn_slowpath_common+0xa1/0xbb
    [ 3915.140316]  [<ffffffffa03ca44f>] ? insert_state+0x4b/0x10b [btrfs]
    [ 3915.141505]  [<ffffffff810453f0>] warn_slowpath_fmt+0x46/0x48
    [ 3915.142709]  [<ffffffffa03ca44f>] insert_state+0x4b/0x10b [btrfs]
    [ 3915.143849]  [<ffffffffa03ca729>] __set_extent_bit+0x107/0x3f4 [btrfs]
    [ 3915.145120]  [<ffffffffa038c1e3>] ? btrfs_kill_super+0x17/0x23 [btrfs]
    [ 3915.146352]  [<ffffffff811548f6>] ? deactivate_locked_super+0x3b/0x50
    [ 3915.147565]  [<ffffffffa03cb256>] lock_extent_bits+0x65/0x1bf [btrfs]
    [ 3915.148785]  [<ffffffff8142b7e2>] ? _raw_write_unlock+0x28/0x33
    [ 3915.149931]  [<ffffffffa03bc325>] btrfs_evict_inode+0x196/0x482 [btrfs]
    [ 3915.151154]  [<ffffffff81168904>] evict+0xa0/0x148
    [ 3915.152094]  [<ffffffff811689e5>] dispose_list+0x39/0x43
    [ 3915.153081]  [<ffffffff81169564>] evict_inodes+0xdc/0xeb
    [ 3915.154062]  [<ffffffff81154418>] generic_shutdown_super+0x49/0xef
    [ 3915.155193]  [<ffffffff811546d1>] kill_anon_super+0x13/0x1e
    [ 3915.156274]  [<ffffffffa038c1e3>] btrfs_kill_super+0x17/0x23 [btrfs]
    (...)
    [ 3915.167404] ---[ end trace 14843d3e2e622fc2 ]---
    
    So just bail out of the clone ioctl if the length of the region to clone
    is zero, without locking any extent range, in order to prevent this issue
    (same behaviour as a pwrite with a 0 length for example).
    
    This is trivial to reproduce. For example, the steps for the test I just
    made for fstests:
    
      mkfs.btrfs -f SCRATCH_DEV
      mount SCRATCH_DEV $SCRATCH_MNT
    
      touch $SCRATCH_MNT/foo
      touch $SCRATCH_MNT/bar
    
      $CLONER_PROG -s 0 -d 4096 -l 0 $SCRATCH_MNT/foo $SCRATCH_MNT/bar
      umount $SCRATCH_MNT
    
    A test case for fstests follows soon.
    
    Signed-off-by: Filipe Manana <fdmanana@suse.com>
    Reviewed-by: Omar Sandoval <osandov@osandov.com>
    Signed-off-by: Chris Mason <clm@fb.com>
    Signed-off-by: Luis Henriques <luis.henriques@canonical.com>

commit 4ab0f403b8dad3d804ac5550bcf499bbd318b069
Author: Filipe Manana <fdmanana@suse.com>
Date:   Mon Mar 30 18:23:59 2015 +0100

    Btrfs: fix inode eviction infinite loop after cloning into it
    
    commit ccccf3d67294714af2d72a6fd6fd7d73b01c9329 upstream.
    
    If we attempt to clone a 0 length region into a file we can end up
    inserting a range in the inode's extent_io tree with a start offset
    that is greater then the end offset, which triggers immediately the
    following warning:
    
    [ 3914.619057] WARNING: CPU: 17 PID: 4199 at fs/btrfs/extent_io.c:435 insert_state+0x4b/0x10b [btrfs]()
    [ 3914.620886] BTRFS: end < start 4095 4096
    (...)
    [ 3914.638093] Call Trace:
    [ 3914.638636]  [<ffffffff81425fd9>] dump_stack+0x4c/0x65
    [ 3914.639620]  [<ffffffff81045390>] warn_slowpath_common+0xa1/0xbb
    [ 3914.640789]  [<ffffffffa03ca44f>] ? insert_state+0x4b/0x10b [btrfs]
    [ 3914.642041]  [<ffffffff810453f0>] warn_slowpath_fmt+0x46/0x48
    [ 3914.643236]  [<ffffffffa03ca44f>] insert_state+0x4b/0x10b [btrfs]
    [ 3914.644441]  [<ffffffffa03ca729>] __set_extent_bit+0x107/0x3f4 [btrfs]
    [ 3914.645711]  [<ffffffffa03cb256>] lock_extent_bits+0x65/0x1bf [btrfs]
    [ 3914.646914]  [<ffffffff8142b2fb>] ? _raw_spin_unlock+0x28/0x33
    [ 3914.648058]  [<ffffffffa03cbac4>] ? test_range_bit+0xcc/0xde [btrfs]
    [ 3914.650105]  [<ffffffffa03cb3c3>] lock_extent+0x13/0x15 [btrfs]
    [ 3914.651361]  [<ffffffffa03db39e>] lock_extent_range+0x3d/0xcd [btrfs]
    [ 3914.652761]  [<ffffffffa03de1fe>] btrfs_ioctl_clone+0x278/0x388 [btrfs]
    [ 3914.654128]  [<ffffffff811226dd>] ? might_fault+0x58/0xb5
    [ 3914.655320]  [<ffffffffa03e0909>] btrfs_ioctl+0xb51/0x2195 [btrfs]
    (...)
    [ 3914.669271] ---[ end trace 14843d3e2e622fc1 ]---
    
    This later makes the inode eviction handler enter an infinite loop that
    keeps dumping the following warning over and over:
    
    [ 3915.117629] WARNING: CPU: 22 PID: 4228 at fs/btrfs/extent_io.c:435 insert_state+0x4b/0x10b [btrfs]()
    [ 3915.119913] BTRFS: end < start 4095 4096
    (...)
    [ 3915.137394] Call Trace:
    [ 3915.137913]  [<ffffffff81425fd9>] dump_stack+0x4c/0x65
    [ 3915.139154]  [<ffffffff81045390>] warn_slowpath_common+0xa1/0xbb
    [ 3915.140316]  [<ffffffffa03ca44f>] ? insert_state+0x4b/0x10b [btrfs]
    [ 3915.141505]  [<ffffffff810453f0>] warn_slowpath_fmt+0x46/0x48
    [ 3915.142709]  [<ffffffffa03ca44f>] insert_state+0x4b/0x10b [btrfs]
    [ 3915.143849]  [<ffffffffa03ca729>] __set_extent_bit+0x107/0x3f4 [btrfs]
    [ 3915.145120]  [<ffffffffa038c1e3>] ? btrfs_kill_super+0x17/0x23 [btrfs]
    [ 3915.146352]  [<ffffffff811548f6>] ? deactivate_locked_super+0x3b/0x50
    [ 3915.147565]  [<ffffffffa03cb256>] lock_extent_bits+0x65/0x1bf [btrfs]
    [ 3915.148785]  [<ffffffff8142b7e2>] ? _raw_write_unlock+0x28/0x33
    [ 3915.149931]  [<ffffffffa03bc325>] btrfs_evict_inode+0x196/0x482 [btrfs]
    [ 3915.151154]  [<ffffffff81168904>] evict+0xa0/0x148
    [ 3915.152094]  [<ffffffff811689e5>] dispose_list+0x39/0x43
    [ 3915.153081]  [<ffffffff81169564>] evict_inodes+0xdc/0xeb
    [ 3915.154062]  [<ffffffff81154418>] generic_shutdown_super+0x49/0xef
    [ 3915.155193]  [<ffffffff811546d1>] kill_anon_super+0x13/0x1e
    [ 3915.156274]  [<ffffffffa038c1e3>] btrfs_kill_super+0x17/0x23 [btrfs]
    (...)
    [ 3915.167404] ---[ end trace 14843d3e2e622fc2 ]---
    
    So just bail out of the clone ioctl if the length of the region to clone
    is zero, without locking any extent range, in order to prevent this issue
    (same behaviour as a pwrite with a 0 length for example).
    
    This is trivial to reproduce. For example, the steps for the test I just
    made for fstests:
    
      mkfs.btrfs -f SCRATCH_DEV
      mount SCRATCH_DEV $SCRATCH_MNT
    
      touch $SCRATCH_MNT/foo
      touch $SCRATCH_MNT/bar
    
      $CLONER_PROG -s 0 -d 4096 -l 0 $SCRATCH_MNT/foo $SCRATCH_MNT/bar
      umount $SCRATCH_MNT
    
    A test case for fstests follows soon.
    
    Signed-off-by: Filipe Manana <fdmanana@suse.com>
    Reviewed-by: Omar Sandoval <osandov@osandov.com>
    Signed-off-by: Chris Mason <clm@fb.com>
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>

commit ccccf3d67294714af2d72a6fd6fd7d73b01c9329
Author: Filipe Manana <fdmanana@suse.com>
Date:   Mon Mar 30 18:23:59 2015 +0100

    Btrfs: fix inode eviction infinite loop after cloning into it
    
    If we attempt to clone a 0 length region into a file we can end up
    inserting a range in the inode's extent_io tree with a start offset
    that is greater then the end offset, which triggers immediately the
    following warning:
    
    [ 3914.619057] WARNING: CPU: 17 PID: 4199 at fs/btrfs/extent_io.c:435 insert_state+0x4b/0x10b [btrfs]()
    [ 3914.620886] BTRFS: end < start 4095 4096
    (...)
    [ 3914.638093] Call Trace:
    [ 3914.638636]  [<ffffffff81425fd9>] dump_stack+0x4c/0x65
    [ 3914.639620]  [<ffffffff81045390>] warn_slowpath_common+0xa1/0xbb
    [ 3914.640789]  [<ffffffffa03ca44f>] ? insert_state+0x4b/0x10b [btrfs]
    [ 3914.642041]  [<ffffffff810453f0>] warn_slowpath_fmt+0x46/0x48
    [ 3914.643236]  [<ffffffffa03ca44f>] insert_state+0x4b/0x10b [btrfs]
    [ 3914.644441]  [<ffffffffa03ca729>] __set_extent_bit+0x107/0x3f4 [btrfs]
    [ 3914.645711]  [<ffffffffa03cb256>] lock_extent_bits+0x65/0x1bf [btrfs]
    [ 3914.646914]  [<ffffffff8142b2fb>] ? _raw_spin_unlock+0x28/0x33
    [ 3914.648058]  [<ffffffffa03cbac4>] ? test_range_bit+0xcc/0xde [btrfs]
    [ 3914.650105]  [<ffffffffa03cb3c3>] lock_extent+0x13/0x15 [btrfs]
    [ 3914.651361]  [<ffffffffa03db39e>] lock_extent_range+0x3d/0xcd [btrfs]
    [ 3914.652761]  [<ffffffffa03de1fe>] btrfs_ioctl_clone+0x278/0x388 [btrfs]
    [ 3914.654128]  [<ffffffff811226dd>] ? might_fault+0x58/0xb5
    [ 3914.655320]  [<ffffffffa03e0909>] btrfs_ioctl+0xb51/0x2195 [btrfs]
    (...)
    [ 3914.669271] ---[ end trace 14843d3e2e622fc1 ]---
    
    This later makes the inode eviction handler enter an infinite loop that
    keeps dumping the following warning over and over:
    
    [ 3915.117629] WARNING: CPU: 22 PID: 4228 at fs/btrfs/extent_io.c:435 insert_state+0x4b/0x10b [btrfs]()
    [ 3915.119913] BTRFS: end < start 4095 4096
    (...)
    [ 3915.137394] Call Trace:
    [ 3915.137913]  [<ffffffff81425fd9>] dump_stack+0x4c/0x65
    [ 3915.139154]  [<ffffffff81045390>] warn_slowpath_common+0xa1/0xbb
    [ 3915.140316]  [<ffffffffa03ca44f>] ? insert_state+0x4b/0x10b [btrfs]
    [ 3915.141505]  [<ffffffff810453f0>] warn_slowpath_fmt+0x46/0x48
    [ 3915.142709]  [<ffffffffa03ca44f>] insert_state+0x4b/0x10b [btrfs]
    [ 3915.143849]  [<ffffffffa03ca729>] __set_extent_bit+0x107/0x3f4 [btrfs]
    [ 3915.145120]  [<ffffffffa038c1e3>] ? btrfs_kill_super+0x17/0x23 [btrfs]
    [ 3915.146352]  [<ffffffff811548f6>] ? deactivate_locked_super+0x3b/0x50
    [ 3915.147565]  [<ffffffffa03cb256>] lock_extent_bits+0x65/0x1bf [btrfs]
    [ 3915.148785]  [<ffffffff8142b7e2>] ? _raw_write_unlock+0x28/0x33
    [ 3915.149931]  [<ffffffffa03bc325>] btrfs_evict_inode+0x196/0x482 [btrfs]
    [ 3915.151154]  [<ffffffff81168904>] evict+0xa0/0x148
    [ 3915.152094]  [<ffffffff811689e5>] dispose_list+0x39/0x43
    [ 3915.153081]  [<ffffffff81169564>] evict_inodes+0xdc/0xeb
    [ 3915.154062]  [<ffffffff81154418>] generic_shutdown_super+0x49/0xef
    [ 3915.155193]  [<ffffffff811546d1>] kill_anon_super+0x13/0x1e
    [ 3915.156274]  [<ffffffffa038c1e3>] btrfs_kill_super+0x17/0x23 [btrfs]
    (...)
    [ 3915.167404] ---[ end trace 14843d3e2e622fc2 ]---
    
    So just bail out of the clone ioctl if the length of the region to clone
    is zero, without locking any extent range, in order to prevent this issue
    (same behaviour as a pwrite with a 0 length for example).
    
    This is trivial to reproduce. For example, the steps for the test I just
    made for fstests:
    
      mkfs.btrfs -f SCRATCH_DEV
      mount SCRATCH_DEV $SCRATCH_MNT
    
      touch $SCRATCH_MNT/foo
      touch $SCRATCH_MNT/bar
    
      $CLONER_PROG -s 0 -d 4096 -l 0 $SCRATCH_MNT/foo $SCRATCH_MNT/bar
      umount $SCRATCH_MNT
    
    A test case for fstests follows soon.
    
    CC: <stable@vger.kernel.org>
    Signed-off-by: Filipe Manana <fdmanana@suse.com>
    Reviewed-by: Omar Sandoval <osandov@osandov.com>
    Signed-off-by: Chris Mason <clm@fb.com>

commit 369e2b84e4eed08e5368abc3bc4277d500a186ea
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Thu Oct 16 14:19:49 2014 -0400

    tty: Remove sparse lock annotations from tty_write_lock()/_unlock()
    
    sparse lock annotations cannot represent conditional acquire, such
    as mutex_lock_interruptible() or mutex_trylock(), and produce sparse
    warnings at _every_ correct call site.
    
    Remove lock annotations from tty_write_lock() and tty_write_unlock().
    
    Fixes sparse warnings:
    drivers/tty/tty_io.c:1083:13: warning: context imbalance in 'tty_write_unlock' - wrong count at exit
    drivers/tty/tty_io.c:1090:12: warning: context imbalance in 'tty_write_lock' - wrong count at exit
    drivers/tty/tty_io.c:1211:17: warning: context imbalance in 'tty_write_message' - unexpected unlock
    drivers/tty/tty_io.c:1233:16: warning: context imbalance in 'tty_write' - different lock contexts for basic block
    drivers/tty/tty_io.c:1285:5: warning: context imbalance in 'tty_send_xchar' - different lock contexts for basic block
    drivers/tty/tty_io.c:2653:12: warning: context imbalance in 'send_break' - different lock contexts for basic block
    
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit e8564b710c6df2c3aeb56c507c22f4bcfa4c0b2d
Author: Jiri Olsa <jolsa@kernel.org>
Date:   Mon Aug 25 16:45:43 2014 +0200

    perf script: Add period as a default output column
    
    Adding period as a default output column in script command fo hardware,
    software and raw events.
    
    If PERF_SAMPLE_PERIOD sample type is defined in perf.data, following
    will be displayed in perf script output:
    
      $ perf script
                  ls  8034 57477.887209:     250000 task-clock:  ffffffff81361d72 memset ([kernel.kallsyms])
                  ls  8034 57477.887464:     250000 task-clock:  ffffffff816f6d92 _raw_spin_unlock_irqrestore ([kernel.kallsyms])
                  ls  8034 57477.887708:     250000 task-clock:  ffffffff811a94f0 do_munmap ([kernel.kallsyms])
                  ls  8034 57477.887959:     250000 task-clock:        34080916c6 get_next_seq (/usr/lib64/libc-2.17.so)
                  ls  8034 57477.888208:     250000 task-clock:        3408079230 _IO_doallocbuf (/usr/lib64/libc-2.17.so)
                  ls  8034 57477.888717:     250000 task-clock:  ffffffff814242c8 n_tty_write ([kernel.kallsyms])
                  ls  8034 57477.889285:     250000 task-clock:        3408076402 fwrite_unlocked (/usr/lib64/libc-2.17.so)
    
    Signed-off-by: Jiri Olsa <jolsa@kernel.org>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: "Jen-Cheng(Tommy) Huang" <tommy24@gatech.edu>
    Cc: Andi Kleen <andi@firstfloor.org>
    Cc: Corey Ashford <cjashfor@linux.vnet.ibm.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Jen-Cheng(Tommy) Huang <tommy24@gatech.edu>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Stephane Eranian <eranian@google.com>
    Link: http://lkml.kernel.org/r/1408977943-16594-10-git-send-email-jolsa@kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

commit 136d5258b2bc4ffae99cb69874a76624c26fbfad
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Wed Sep 10 15:06:34 2014 -0400

    tty: Move and rename send_prio_char() as tty_send_xchar()
    
    Relocate the file-scope function, send_prio_char(), as a global
    helper tty_send_xchar(). Remove the global declarations for
    tty_write_lock()/tty_write_unlock(), as these are file-scope only now.
    
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit bd01ec1a13f9a327950c8e3080096446c7804753
Author: Waiman Long <Waiman.Long@hp.com>
Date:   Mon Feb 3 13:18:57 2014 +0100

    x86, locking/rwlocks: Enable qrwlocks on x86
    
    Make x86 use the fair rwlock_t.
    
    Implement the custom queue_write_unlock() for best performance.
    
    Signed-off-by: Waiman Long <Waiman.Long@hp.com>
    [peterz: near complete rewrite]
    Signed-off-by: Peter Zijlstra <peterz@infradead.org>
    Cc: Dave Jones <davej@redhat.com>
    Cc: Jeremy Fitzhardinge <jeremy@goop.org>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Raghavendra K T <raghavendra.kt@linux.vnet.ibm.com>
    Cc: "Paul E.McKenney" <paulmck@linux.vnet.ibm.com>
    Cc: linux-kernel@vger.kernel.org
    Cc: x86@kernel.org
    Link: http://lkml.kernel.org/n/tip-r1xuzmdysvuhl3h86n5fbxi7@git.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 70af2f8a4f48d6cebdf92d533d3aef37853ce6de
Author: Waiman Long <Waiman.Long@hp.com>
Date:   Mon Feb 3 13:18:49 2014 +0100

    locking/rwlocks: Introduce 'qrwlocks' - fair, queued rwlocks
    
    This rwlock uses the arch_spin_lock_t as a waitqueue, and assuming the
    arch_spin_lock_t is a fair lock (ticket,mcs etc..) the resulting
    rwlock is a fair lock.
    
    It fits in the same 8 bytes as the regular rwlock_t by folding the
    reader and writer count into a single integer, using the remaining 4
    bytes for the arch_spinlock_t.
    
    Architectures that can single-copy adress bytes can optimize
    queue_write_unlock() with a 0 write to the LSB (the write count).
    
    Performance as measured by Davidlohr Bueso (rwlock_t -> qrwlock_t):
    
     +--------------+-------------+---------------+
     |   Workload   |   #users    |     delta     |
     +--------------+-------------+---------------+
     | alltests     | > 1400      | -4.83%        |
     | custom       | 0-100,> 100 | +1.43%,-1.57% |
     | high_systime | > 1000      | -2.61         |
     | shared       | all         | +0.32         |
     +--------------+-------------+---------------+
    
    http://www.stgolabs.net/qrwlock-stuff/aim7-results-vs-rwsem_optsin/
    
    Signed-off-by: Waiman Long <Waiman.Long@hp.com>
    [peterz: near complete rewrite]
    Signed-off-by: Peter Zijlstra <peterz@infradead.org>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: "Paul E.McKenney" <paulmck@linux.vnet.ibm.com>
    Cc: linux-arch@vger.kernel.org
    Cc: linux-kernel@vger.kernel.org
    Link: http://lkml.kernel.org/n/tip-gac1nnl3wvs2ij87zv2xkdzq@git.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 7bda701e012373ca53c9d837b7b25131852e0238
Author: fan.du <fan.du@windriver.com>
Date:   Fri Jan 3 10:18:58 2014 +0800

    {vxlan, inet6} Mark vxlan_dev flags with VXLAN_F_IPV6 properly
    
    Even if user doesn't supply the physical netdev to attach vxlan dev
    to, and at the same time user want to vxlan sit top of IPv6, mark
    vxlan_dev flags with VXLAN_F_IPV6 to create IPv6 based socket.
    Otherwise kernel crashes safely every time spitting below messages,
    
    Steps to reproduce:
    ip link add vxlan0 type vxlan id 42 group ff0e::110
    ip link set vxlan0 up
    
    [   62.656266] BUG: unable to handle kernel NULL pointer dereference[   62.656320] ip (3008) used greatest stack depth: 3912 bytes left
     at 0000000000000046
    [   62.656423] IP: [<ffffffff816d822d>] ip6_route_output+0xbd/0xe0
    [   62.656525] PGD 2c966067 PUD 2c9a2067 PMD 0
    [   62.656674] Oops: 0000 [#1] SMP
    [   62.656781] Modules linked in: vxlan netconsole deflate zlib_deflate af_key
    [   62.657083] CPU: 1 PID: 2128 Comm: whoopsie Not tainted 3.12.0+ #182
    [   62.657083] Hardware name: innotek GmbH VirtualBox, BIOS VirtualBox 12/01/2006
    [   62.657083] task: ffff88002e2335d0 ti: ffff88002c94c000 task.ti: ffff88002c94c000
    [   62.657083] RIP: 0010:[<ffffffff816d822d>]  [<ffffffff816d822d>] ip6_route_output+0xbd/0xe0
    [   62.657083] RSP: 0000:ffff88002fd038f8  EFLAGS: 00210296
    [   62.657083] RAX: 0000000000000000 RBX: ffff88002fd039e0 RCX: 0000000000000000
    [   62.657083] RDX: ffff88002fd0eb68 RSI: ffff88002fd0d278 RDI: ffff88002fd0d278
    [   62.657083] RBP: ffff88002fd03918 R08: 0000000002000000 R09: 0000000000000000
    [   62.657083] R10: 00000000000001ff R11: 0000000000000000 R12: 0000000000000001
    [   62.657083] R13: ffff88002d96b480 R14: ffffffff81c8e2c0 R15: 0000000000000001
    [   62.657083] FS:  0000000000000000(0000) GS:ffff88002fd00000(0063) knlGS:00000000f693b740
    [   62.657083] CS:  0010 DS: 002b ES: 002b CR0: 0000000080050033
    [   62.657083] CR2: 0000000000000046 CR3: 000000002c9d2000 CR4: 00000000000006e0
    [   62.657083] Stack:
    [   62.657083]  ffff88002fd03a40 ffffffff81c8e2c0 ffff88002fd039e0 ffff88002d96b480
    [   62.657083]  ffff88002fd03958 ffffffff816cac8b ffff880019277cc0 ffff8800192b5d00
    [   62.657083]  ffff88002d5bc000 ffff880019277cc0 0000000000001821 0000000000000001
    [   62.657083] Call Trace:
    [   62.657083]  <IRQ>
    [   62.657083]  [<ffffffff816cac8b>] ip6_dst_lookup_tail+0xdb/0xf0
    [   62.657083]  [<ffffffff816caea0>] ip6_dst_lookup+0x10/0x20
    [   62.657083]  [<ffffffffa0020c13>] vxlan_xmit_one+0x193/0x9c0 [vxlan]
    [   62.657083]  [<ffffffff8137b3b7>] ? account+0xc7/0x1f0
    [   62.657083]  [<ffffffffa0021513>] vxlan_xmit+0xd3/0x400 [vxlan]
    [   62.657083]  [<ffffffff8161390d>] dev_hard_start_xmit+0x49d/0x5e0
    [   62.657083]  [<ffffffff81613d29>] dev_queue_xmit+0x2d9/0x480
    [   62.657083]  [<ffffffff817cb854>] ? _raw_write_unlock_bh+0x14/0x20
    [   62.657083]  [<ffffffff81630565>] ? eth_header+0x35/0xe0
    [   62.657083]  [<ffffffff8161bc5e>] neigh_resolve_output+0x11e/0x1e0
    [   62.657083]  [<ffffffff816ce0e0>] ? ip6_fragment+0xad0/0xad0
    [   62.657083]  [<ffffffff816cb465>] ip6_finish_output2+0x2f5/0x470
    [   62.657083]  [<ffffffff816ce166>] ip6_finish_output+0x86/0xc0
    [   62.657083]  [<ffffffff816ce218>] ip6_output+0x78/0xb0
    [   62.657083]  [<ffffffff816eadd6>] mld_sendpack+0x256/0x2a0
    [   62.657083]  [<ffffffff816ebd8c>] mld_ifc_timer_expire+0x17c/0x290
    [   62.657083]  [<ffffffff816ebc10>] ? igmp6_timer_handler+0x80/0x80
    [   62.657083]  [<ffffffff816ebc10>] ? igmp6_timer_handler+0x80/0x80
    [   62.657083]  [<ffffffff81051065>] call_timer_fn+0x45/0x150
    [   62.657083]  [<ffffffff816ebc10>] ? igmp6_timer_handler+0x80/0x80
    [   62.657083]  [<ffffffff81052353>] run_timer_softirq+0x1f3/0x2a0
    [   62.657083]  [<ffffffff8102dfd8>] ? lapic_next_event+0x18/0x20
    [   62.657083]  [<ffffffff8109e36f>] ? clockevents_program_event+0x6f/0x110
    [   62.657083]  [<ffffffff8104a2f6>] __do_softirq+0xd6/0x2b0
    [   62.657083]  [<ffffffff8104a75e>] irq_exit+0x7e/0xa0
    [   62.657083]  [<ffffffff8102ea15>] smp_apic_timer_interrupt+0x45/0x60
    [   62.657083]  [<ffffffff817d3eca>] apic_timer_interrupt+0x6a/0x70
    [   62.657083]  <EOI>
    [   62.657083]  [<ffffffff817d4a35>] ? sysenter_dispatch+0x7/0x1a
    [   62.657083] Code: 4d 8b 85 a8 02 00 00 4c 89 e9 ba 03 04 00 00 48 c7 c6 c0 be 8d 81 48 c7 c7 48 35 a3 81 31 c0 e8 db 68 0e 00 49 8b 85 a8 02 00 00 <0f> b6 40 46 c0 e8 05 0f b6 c0 c1 e0 03 41 09 c4 e9 77 ff ff ff
    [   62.657083] RIP  [<ffffffff816d822d>] ip6_route_output+0xbd/0xe0
    [   62.657083]  RSP <ffff88002fd038f8>
    [   62.657083] CR2: 0000000000000046
    [   62.657083] ---[ end trace ba8a9583d7cd1934 ]---
    [   62.657083] Kernel panic - not syncing: Fatal exception in interrupt
    
    Signed-off-by: Fan Du <fan.du@windriver.com>
    Reported-by: Ryan Whelan <rcwhelan@gmail.com>
    Acked-by: Cong Wang <xiyou.wangcong@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit feded5077ba27265ce2f317eeb89dbed64674fed
Author: Roland Dreier <roland@purestorage.com>
Date:   Mon Aug 5 17:55:01 2013 -0700

    sg: Fix user memory corruption when SG_IO is interrupted by a signal
    
    commit 35dc248383bbab0a7203fca4d722875bc81ef091 upstream.
    
    There is a nasty bug in the SCSI SG_IO ioctl that in some circumstances
    leads to one process writing data into the address space of some other
    random unrelated process if the ioctl is interrupted by a signal.
    What happens is the following:
    
     - A process issues an SG_IO ioctl with direction DXFER_FROM_DEV (ie the
       underlying SCSI command will transfer data from the SCSI device to
       the buffer provided in the ioctl)
    
     - Before the command finishes, a signal is sent to the process waiting
       in the ioctl.  This will end up waking up the sg_ioctl() code:
    
                    result = wait_event_interruptible(sfp->read_wait,
                            (srp_done(sfp, srp) || sdp->detached));
    
       but neither srp_done() nor sdp->detached is true, so we end up just
       setting srp->orphan and returning to userspace:
    
                    srp->orphan = 1;
                    write_unlock_irq(&sfp->rq_list_lock);
                    return result;  /* -ERESTARTSYS because signal hit process */
    
       At this point the original process is done with the ioctl and
       blithely goes ahead handling the signal, reissuing the ioctl, etc.
    
     - Eventually, the SCSI command issued by the first ioctl finishes and
       ends up in sg_rq_end_io().  At the end of that function, we run through:
    
            write_lock_irqsave(&sfp->rq_list_lock, iflags);
            if (unlikely(srp->orphan)) {
                    if (sfp->keep_orphan)
                            srp->sg_io_owned = 0;
                    else
                            done = 0;
            }
            srp->done = done;
            write_unlock_irqrestore(&sfp->rq_list_lock, iflags);
    
            if (likely(done)) {
                    /* Now wake up any sg_read() that is waiting for this
                     * packet.
                     */
                    wake_up_interruptible(&sfp->read_wait);
                    kill_fasync(&sfp->async_qp, SIGPOLL, POLL_IN);
                    kref_put(&sfp->f_ref, sg_remove_sfp);
            } else {
                    INIT_WORK(&srp->ew.work, sg_rq_end_io_usercontext);
                    schedule_work(&srp->ew.work);
            }
    
       Since srp->orphan *is* set, we set done to 0 (assuming the
       userspace app has not set keep_orphan via an SG_SET_KEEP_ORPHAN
       ioctl), and therefore we end up scheduling sg_rq_end_io_usercontext()
       to run in a workqueue.
    
     - In workqueue context we go through sg_rq_end_io_usercontext() ->
       sg_finish_rem_req() -> blk_rq_unmap_user() -> ... ->
       bio_uncopy_user() -> __bio_copy_iov() -> copy_to_user().
    
       The key point here is that we are doing copy_to_user() on a
       workqueue -- that is, we're on a kernel thread with current->mm
       equal to whatever random previous user process was scheduled before
       this kernel thread.  So we end up copying whatever data the SCSI
       command returned to the virtual address of the buffer passed into
       the original ioctl, but it's quite likely we do this copying into a
       different address space!
    
    As suggested by James Bottomley <James.Bottomley@hansenpartnership.com>,
    add a check for current->mm (which is NULL if we're on a kernel thread
    without a real userspace address space) in bio_uncopy_user(), and skip
    the copy if we're on a kernel thread.
    
    There's no reason that I can think of for any caller of bio_uncopy_user()
    to want to do copying on a kernel thread with a random active userspace
    address space.
    
    Huge thanks to Costa Sapuntzakis <costa@purestorage.com> for the
    original pointer to this bug in the sg code.
    
    Signed-off-by: Roland Dreier <roland@purestorage.com>
    Tested-by: David Milburn <dmilburn@redhat.com>
    Cc: Jens Axboe <axboe@kernel.dk>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit d3ba21877b9488abffd4528aa4b316ec5af27ea3
Author: Roland Dreier <roland@purestorage.com>
Date:   Mon Aug 5 17:55:01 2013 -0700

    SCSI: sg: Fix user memory corruption when SG_IO is interrupted by a signal
    
    commit 35dc248383bbab0a7203fca4d722875bc81ef091 upstream.
    
    There is a nasty bug in the SCSI SG_IO ioctl that in some circumstances
    leads to one process writing data into the address space of some other
    random unrelated process if the ioctl is interrupted by a signal.
    What happens is the following:
    
     - A process issues an SG_IO ioctl with direction DXFER_FROM_DEV (ie the
       underlying SCSI command will transfer data from the SCSI device to
       the buffer provided in the ioctl)
    
     - Before the command finishes, a signal is sent to the process waiting
       in the ioctl.  This will end up waking up the sg_ioctl() code:
    
                    result = wait_event_interruptible(sfp->read_wait,
                            (srp_done(sfp, srp) || sdp->detached));
    
       but neither srp_done() nor sdp->detached is true, so we end up just
       setting srp->orphan and returning to userspace:
    
                    srp->orphan = 1;
                    write_unlock_irq(&sfp->rq_list_lock);
                    return result;  /* -ERESTARTSYS because signal hit process */
    
       At this point the original process is done with the ioctl and
       blithely goes ahead handling the signal, reissuing the ioctl, etc.
    
     - Eventually, the SCSI command issued by the first ioctl finishes and
       ends up in sg_rq_end_io().  At the end of that function, we run through:
    
            write_lock_irqsave(&sfp->rq_list_lock, iflags);
            if (unlikely(srp->orphan)) {
                    if (sfp->keep_orphan)
                            srp->sg_io_owned = 0;
                    else
                            done = 0;
            }
            srp->done = done;
            write_unlock_irqrestore(&sfp->rq_list_lock, iflags);
    
            if (likely(done)) {
                    /* Now wake up any sg_read() that is waiting for this
                     * packet.
                     */
                    wake_up_interruptible(&sfp->read_wait);
                    kill_fasync(&sfp->async_qp, SIGPOLL, POLL_IN);
                    kref_put(&sfp->f_ref, sg_remove_sfp);
            } else {
                    INIT_WORK(&srp->ew.work, sg_rq_end_io_usercontext);
                    schedule_work(&srp->ew.work);
            }
    
       Since srp->orphan *is* set, we set done to 0 (assuming the
       userspace app has not set keep_orphan via an SG_SET_KEEP_ORPHAN
       ioctl), and therefore we end up scheduling sg_rq_end_io_usercontext()
       to run in a workqueue.
    
     - In workqueue context we go through sg_rq_end_io_usercontext() ->
       sg_finish_rem_req() -> blk_rq_unmap_user() -> ... ->
       bio_uncopy_user() -> __bio_copy_iov() -> copy_to_user().
    
       The key point here is that we are doing copy_to_user() on a
       workqueue -- that is, we're on a kernel thread with current->mm
       equal to whatever random previous user process was scheduled before
       this kernel thread.  So we end up copying whatever data the SCSI
       command returned to the virtual address of the buffer passed into
       the original ioctl, but it's quite likely we do this copying into a
       different address space!
    
    As suggested by James Bottomley <James.Bottomley@hansenpartnership.com>,
    add a check for current->mm (which is NULL if we're on a kernel thread
    without a real userspace address space) in bio_uncopy_user(), and skip
    the copy if we're on a kernel thread.
    
    There's no reason that I can think of for any caller of bio_uncopy_user()
    to want to do copying on a kernel thread with a random active userspace
    address space.
    
    Huge thanks to Costa Sapuntzakis <costa@purestorage.com> for the
    original pointer to this bug in the sg code.
    
    Signed-off-by: Roland Dreier <roland@purestorage.com>
    Tested-by: David Milburn <dmilburn@redhat.com>
    Cc: Jens Axboe <axboe@kernel.dk>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>
    [lizf: backported to 3.4:
     - Use __bio_for_each_segment() instead of bio_for_each_segment_all()]
    Signed-off-by: Li Zefan <lizefan@huawei.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit eb18ce5b78b1efb313a14532d2883420163e681a
Author: Roland Dreier <roland@purestorage.com>
Date:   Mon Aug 5 17:55:01 2013 -0700

    SCSI: sg: Fix user memory corruption when SG_IO is interrupted by a signal
    
    commit 35dc248383bbab0a7203fca4d722875bc81ef091 upstream.
    
    There is a nasty bug in the SCSI SG_IO ioctl that in some circumstances
    leads to one process writing data into the address space of some other
    random unrelated process if the ioctl is interrupted by a signal.
    What happens is the following:
    
     - A process issues an SG_IO ioctl with direction DXFER_FROM_DEV (ie the
       underlying SCSI command will transfer data from the SCSI device to
       the buffer provided in the ioctl)
    
     - Before the command finishes, a signal is sent to the process waiting
       in the ioctl.  This will end up waking up the sg_ioctl() code:
    
                    result = wait_event_interruptible(sfp->read_wait,
                            (srp_done(sfp, srp) || sdp->detached));
    
       but neither srp_done() nor sdp->detached is true, so we end up just
       setting srp->orphan and returning to userspace:
    
                    srp->orphan = 1;
                    write_unlock_irq(&sfp->rq_list_lock);
                    return result;  /* -ERESTARTSYS because signal hit process */
    
       At this point the original process is done with the ioctl and
       blithely goes ahead handling the signal, reissuing the ioctl, etc.
    
     - Eventually, the SCSI command issued by the first ioctl finishes and
       ends up in sg_rq_end_io().  At the end of that function, we run through:
    
            write_lock_irqsave(&sfp->rq_list_lock, iflags);
            if (unlikely(srp->orphan)) {
                    if (sfp->keep_orphan)
                            srp->sg_io_owned = 0;
                    else
                            done = 0;
            }
            srp->done = done;
            write_unlock_irqrestore(&sfp->rq_list_lock, iflags);
    
            if (likely(done)) {
                    /* Now wake up any sg_read() that is waiting for this
                     * packet.
                     */
                    wake_up_interruptible(&sfp->read_wait);
                    kill_fasync(&sfp->async_qp, SIGPOLL, POLL_IN);
                    kref_put(&sfp->f_ref, sg_remove_sfp);
            } else {
                    INIT_WORK(&srp->ew.work, sg_rq_end_io_usercontext);
                    schedule_work(&srp->ew.work);
            }
    
       Since srp->orphan *is* set, we set done to 0 (assuming the
       userspace app has not set keep_orphan via an SG_SET_KEEP_ORPHAN
       ioctl), and therefore we end up scheduling sg_rq_end_io_usercontext()
       to run in a workqueue.
    
     - In workqueue context we go through sg_rq_end_io_usercontext() ->
       sg_finish_rem_req() -> blk_rq_unmap_user() -> ... ->
       bio_uncopy_user() -> __bio_copy_iov() -> copy_to_user().
    
       The key point here is that we are doing copy_to_user() on a
       workqueue -- that is, we're on a kernel thread with current->mm
       equal to whatever random previous user process was scheduled before
       this kernel thread.  So we end up copying whatever data the SCSI
       command returned to the virtual address of the buffer passed into
       the original ioctl, but it's quite likely we do this copying into a
       different address space!
    
    As suggested by James Bottomley <James.Bottomley@hansenpartnership.com>,
    add a check for current->mm (which is NULL if we're on a kernel thread
    without a real userspace address space) in bio_uncopy_user(), and skip
    the copy if we're on a kernel thread.
    
    There's no reason that I can think of for any caller of bio_uncopy_user()
    to want to do copying on a kernel thread with a random active userspace
    address space.
    
    Huge thanks to Costa Sapuntzakis <costa@purestorage.com> for the
    original pointer to this bug in the sg code.
    
    Signed-off-by: Roland Dreier <roland@purestorage.com>
    Tested-by: David Milburn <dmilburn@redhat.com>
    Cc: Jens Axboe <axboe@kernel.dk>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>
    [lizf: backported to 3.4:
     - Use __bio_for_each_segment() instead of bio_for_each_segment_all()]
    Signed-off-by: Li Zefan <lizefan@huawei.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 32b8d5f874e1c6ca88ec4f2d10cd885b3d70cf17
Author: Roland Dreier <roland@purestorage.com>
Date:   Mon Aug 5 17:55:01 2013 -0700

    SCSI: sg: Fix user memory corruption when SG_IO is interrupted by a signal
    
    commit 35dc248383bbab0a7203fca4d722875bc81ef091 upstream.
    
    There is a nasty bug in the SCSI SG_IO ioctl that in some circumstances
    leads to one process writing data into the address space of some other
    random unrelated process if the ioctl is interrupted by a signal.
    What happens is the following:
    
     - A process issues an SG_IO ioctl with direction DXFER_FROM_DEV (ie the
       underlying SCSI command will transfer data from the SCSI device to
       the buffer provided in the ioctl)
    
     - Before the command finishes, a signal is sent to the process waiting
       in the ioctl.  This will end up waking up the sg_ioctl() code:
    
                    result = wait_event_interruptible(sfp->read_wait,
                            (srp_done(sfp, srp) || sdp->detached));
    
       but neither srp_done() nor sdp->detached is true, so we end up just
       setting srp->orphan and returning to userspace:
    
                    srp->orphan = 1;
                    write_unlock_irq(&sfp->rq_list_lock);
                    return result;  /* -ERESTARTSYS because signal hit process */
    
       At this point the original process is done with the ioctl and
       blithely goes ahead handling the signal, reissuing the ioctl, etc.
    
     - Eventually, the SCSI command issued by the first ioctl finishes and
       ends up in sg_rq_end_io().  At the end of that function, we run through:
    
            write_lock_irqsave(&sfp->rq_list_lock, iflags);
            if (unlikely(srp->orphan)) {
                    if (sfp->keep_orphan)
                            srp->sg_io_owned = 0;
                    else
                            done = 0;
            }
            srp->done = done;
            write_unlock_irqrestore(&sfp->rq_list_lock, iflags);
    
            if (likely(done)) {
                    /* Now wake up any sg_read() that is waiting for this
                     * packet.
                     */
                    wake_up_interruptible(&sfp->read_wait);
                    kill_fasync(&sfp->async_qp, SIGPOLL, POLL_IN);
                    kref_put(&sfp->f_ref, sg_remove_sfp);
            } else {
                    INIT_WORK(&srp->ew.work, sg_rq_end_io_usercontext);
                    schedule_work(&srp->ew.work);
            }
    
       Since srp->orphan *is* set, we set done to 0 (assuming the
       userspace app has not set keep_orphan via an SG_SET_KEEP_ORPHAN
       ioctl), and therefore we end up scheduling sg_rq_end_io_usercontext()
       to run in a workqueue.
    
     - In workqueue context we go through sg_rq_end_io_usercontext() ->
       sg_finish_rem_req() -> blk_rq_unmap_user() -> ... ->
       bio_uncopy_user() -> __bio_copy_iov() -> copy_to_user().
    
       The key point here is that we are doing copy_to_user() on a
       workqueue -- that is, we're on a kernel thread with current->mm
       equal to whatever random previous user process was scheduled before
       this kernel thread.  So we end up copying whatever data the SCSI
       command returned to the virtual address of the buffer passed into
       the original ioctl, but it's quite likely we do this copying into a
       different address space!
    
    As suggested by James Bottomley <James.Bottomley@hansenpartnership.com>,
    add a check for current->mm (which is NULL if we're on a kernel thread
    without a real userspace address space) in bio_uncopy_user(), and skip
    the copy if we're on a kernel thread.
    
    There's no reason that I can think of for any caller of bio_uncopy_user()
    to want to do copying on a kernel thread with a random active userspace
    address space.
    
    Huge thanks to Costa Sapuntzakis <costa@purestorage.com> for the
    original pointer to this bug in the sg code.
    
    Signed-off-by: Roland Dreier <roland@purestorage.com>
    Tested-by: David Milburn <dmilburn@redhat.com>
    Cc: Jens Axboe <axboe@kernel.dk>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 35dc248383bbab0a7203fca4d722875bc81ef091
Author: Roland Dreier <roland@purestorage.com>
Date:   Mon Aug 5 17:55:01 2013 -0700

    [SCSI] sg: Fix user memory corruption when SG_IO is interrupted by a signal
    
    There is a nasty bug in the SCSI SG_IO ioctl that in some circumstances
    leads to one process writing data into the address space of some other
    random unrelated process if the ioctl is interrupted by a signal.
    What happens is the following:
    
     - A process issues an SG_IO ioctl with direction DXFER_FROM_DEV (ie the
       underlying SCSI command will transfer data from the SCSI device to
       the buffer provided in the ioctl)
    
     - Before the command finishes, a signal is sent to the process waiting
       in the ioctl.  This will end up waking up the sg_ioctl() code:
    
                    result = wait_event_interruptible(sfp->read_wait,
                            (srp_done(sfp, srp) || sdp->detached));
    
       but neither srp_done() nor sdp->detached is true, so we end up just
       setting srp->orphan and returning to userspace:
    
                    srp->orphan = 1;
                    write_unlock_irq(&sfp->rq_list_lock);
                    return result;  /* -ERESTARTSYS because signal hit process */
    
       At this point the original process is done with the ioctl and
       blithely goes ahead handling the signal, reissuing the ioctl, etc.
    
     - Eventually, the SCSI command issued by the first ioctl finishes and
       ends up in sg_rq_end_io().  At the end of that function, we run through:
    
            write_lock_irqsave(&sfp->rq_list_lock, iflags);
            if (unlikely(srp->orphan)) {
                    if (sfp->keep_orphan)
                            srp->sg_io_owned = 0;
                    else
                            done = 0;
            }
            srp->done = done;
            write_unlock_irqrestore(&sfp->rq_list_lock, iflags);
    
            if (likely(done)) {
                    /* Now wake up any sg_read() that is waiting for this
                     * packet.
                     */
                    wake_up_interruptible(&sfp->read_wait);
                    kill_fasync(&sfp->async_qp, SIGPOLL, POLL_IN);
                    kref_put(&sfp->f_ref, sg_remove_sfp);
            } else {
                    INIT_WORK(&srp->ew.work, sg_rq_end_io_usercontext);
                    schedule_work(&srp->ew.work);
            }
    
       Since srp->orphan *is* set, we set done to 0 (assuming the
       userspace app has not set keep_orphan via an SG_SET_KEEP_ORPHAN
       ioctl), and therefore we end up scheduling sg_rq_end_io_usercontext()
       to run in a workqueue.
    
     - In workqueue context we go through sg_rq_end_io_usercontext() ->
       sg_finish_rem_req() -> blk_rq_unmap_user() -> ... ->
       bio_uncopy_user() -> __bio_copy_iov() -> copy_to_user().
    
       The key point here is that we are doing copy_to_user() on a
       workqueue -- that is, we're on a kernel thread with current->mm
       equal to whatever random previous user process was scheduled before
       this kernel thread.  So we end up copying whatever data the SCSI
       command returned to the virtual address of the buffer passed into
       the original ioctl, but it's quite likely we do this copying into a
       different address space!
    
    As suggested by James Bottomley <James.Bottomley@hansenpartnership.com>,
    add a check for current->mm (which is NULL if we're on a kernel thread
    without a real userspace address space) in bio_uncopy_user(), and skip
    the copy if we're on a kernel thread.
    
    There's no reason that I can think of for any caller of bio_uncopy_user()
    to want to do copying on a kernel thread with a random active userspace
    address space.
    
    Huge thanks to Costa Sapuntzakis <costa@purestorage.com> for the
    original pointer to this bug in the sg code.
    
    Signed-off-by: Roland Dreier <roland@purestorage.com>
    Tested-by: David Milburn <dmilburn@redhat.com>
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

commit 5ede52538ee2b2202d9dff5b06c33bfde421e6e4
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Wed Jul 24 08:29:57 2013 -0400

    tty: Remove extra wakeup from pty write() path
    
    Acquiring the write_wait queue spin lock now accounts for the largest
    slice of cpu time on the tty write path. Two factors contribute to
    this situation; a overly-pessimistic line discipline write loop which
    _always_ sets up a wait loop even if i/o will immediately succeed, and
    on ptys, a wakeup storm from reads and writes.
    
    Writer wakeup does not need to be performed by the pty driver.
    Firstly, since the actual i/o is performed within the write, the
    line discipline write loop will continue while space remains in
    the flip buffers. Secondly, when space becomes avail in the
    line discipline receive buffer (and thus also in the flip buffers),
    the pty unthrottle re-wakes the writer (non-flow-controlled line
    disciplines unconditionally unthrottle the driver when data is
    received). Thus, existing in-kernel i/o is guaranteed to advance.
    Finally, writer wakeup occurs at the conclusion of the line discipline
    write (in tty_write_unlock()). This guarantees that any user-space write
    waiters are woken to continue additional i/o.
    
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 8e0bf542fadde9a9ef58c46fa1411dd6cdfb3b14
Author: Jan Schmidt <list.btrfs@jan-o-sch.net>
Date:   Wed Mar 20 13:49:48 2013 +0000

    Btrfs: fix locking on ROOT_REPLACE operations in tree mod log
    
    commit d9abbf1c3131b679379762700201ae69367f3f62 upstream.
    
    To resolve backrefs, ROOT_REPLACE operations in the tree mod log are
    required to be tied to at least one KEY_REMOVE_WHILE_FREEING operation.
    Therefore, those operations must be enclosed by tree_mod_log_write_lock()
    and tree_mod_log_write_unlock() calls.
    
    Those calls are private to the tree_mod_log_* functions, which means that
    removal of the elements of an old root node must be logged from
    tree_mod_log_insert_root. This partly reverts and corrects commit ba1bfbd5
    (Btrfs: fix a tree mod logging issue for root replacement operations).
    
    This fixes the brand-new version of xfstest 276 as of commit cfe73f71.
    
    Signed-off-by: Jan Schmidt <list.btrfs@jan-o-sch.net>
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>
    Signed-off-by: Chris Mason <chris.mason@fusionio.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit d9abbf1c3131b679379762700201ae69367f3f62
Author: Jan Schmidt <list.btrfs@jan-o-sch.net>
Date:   Wed Mar 20 13:49:48 2013 +0000

    Btrfs: fix locking on ROOT_REPLACE operations in tree mod log
    
    To resolve backrefs, ROOT_REPLACE operations in the tree mod log are
    required to be tied to at least one KEY_REMOVE_WHILE_FREEING operation.
    Therefore, those operations must be enclosed by tree_mod_log_write_lock()
    and tree_mod_log_write_unlock() calls.
    
    Those calls are private to the tree_mod_log_* functions, which means that
    removal of the elements of an old root node must be logged from
    tree_mod_log_insert_root. This partly reverts and corrects commit ba1bfbd5
    (Btrfs: fix a tree mod logging issue for root replacement operations).
    
    This fixes the brand-new version of xfstest 276 as of commit cfe73f71.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Jan Schmidt <list.btrfs@jan-o-sch.net>
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>
    Signed-off-by: Chris Mason <chris.mason@fusionio.com>

commit b5f0e251211531180989a32ba598968104562c84
Author: Jan Kara <jack@suse.cz>
Date:   Fri Dec 21 00:15:51 2012 -0500

    jbd2: fix assertion failure in jbd2_journal_flush()
    
    commit d7961c7fa4d2e3c3f12be67e21ba8799b5a7238a upstream.
    
    The following race is possible between start_this_handle() and someone
    calling jbd2_journal_flush().
    
    Process A                              Process B
    start_this_handle().
      if (journal->j_barrier_count) # false
      if (!journal->j_running_transaction) { #true
        read_unlock(&journal->j_state_lock);
                                           jbd2_journal_lock_updates()
                                           jbd2_journal_flush()
                                             write_lock(&journal->j_state_lock);
                                             if (journal->j_running_transaction) {
                                               # false
                                             ... wait for committing trans ...
                                             write_unlock(&journal->j_state_lock);
        ...
        write_lock(&journal->j_state_lock);
        if (!journal->j_running_transaction) { # true
          jbd2_get_transaction(journal, new_transaction);
        write_unlock(&journal->j_state_lock);
        goto repeat; # eventually blocks on j_barrier_count > 0
                                             ...
                                             J_ASSERT(!journal->j_running_transaction);
                                               # fails
    
    We fix the race by rechecking j_barrier_count after reacquiring j_state_lock
    in exclusive mode.
    
    Reported-by: yjwsignal@empal.com
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: "Theodore Ts'o" <tytso@mit.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 3a06c3ff07f7a00a48edbe264987cc33f409a6d5
Author: Jan Kara <jack@suse.cz>
Date:   Fri Dec 21 00:15:51 2012 -0500

    jbd2: fix assertion failure in jbd2_journal_flush()
    
    commit d7961c7fa4d2e3c3f12be67e21ba8799b5a7238a upstream.
    
    The following race is possible between start_this_handle() and someone
    calling jbd2_journal_flush().
    
    Process A                              Process B
    start_this_handle().
      if (journal->j_barrier_count) # false
      if (!journal->j_running_transaction) { #true
        read_unlock(&journal->j_state_lock);
                                           jbd2_journal_lock_updates()
                                           jbd2_journal_flush()
                                             write_lock(&journal->j_state_lock);
                                             if (journal->j_running_transaction) {
                                               # false
                                             ... wait for committing trans ...
                                             write_unlock(&journal->j_state_lock);
        ...
        write_lock(&journal->j_state_lock);
        if (!journal->j_running_transaction) { # true
          jbd2_get_transaction(journal, new_transaction);
        write_unlock(&journal->j_state_lock);
        goto repeat; # eventually blocks on j_barrier_count > 0
                                             ...
                                             J_ASSERT(!journal->j_running_transaction);
                                               # fails
    
    We fix the race by rechecking j_barrier_count after reacquiring j_state_lock
    in exclusive mode.
    
    Reported-by: yjwsignal@empal.com
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: "Theodore Ts'o" <tytso@mit.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 7c558b7eb837ca7bc014af2f5509be143c3c3670
Author: Jan Kara <jack@suse.cz>
Date:   Fri Dec 21 00:15:51 2012 -0500

    jbd2: fix assertion failure in jbd2_journal_flush()
    
    commit d7961c7fa4d2e3c3f12be67e21ba8799b5a7238a upstream.
    
    The following race is possible between start_this_handle() and someone
    calling jbd2_journal_flush().
    
    Process A                              Process B
    start_this_handle().
      if (journal->j_barrier_count) # false
      if (!journal->j_running_transaction) { #true
        read_unlock(&journal->j_state_lock);
                                           jbd2_journal_lock_updates()
                                           jbd2_journal_flush()
                                             write_lock(&journal->j_state_lock);
                                             if (journal->j_running_transaction) {
                                               # false
                                             ... wait for committing trans ...
                                             write_unlock(&journal->j_state_lock);
        ...
        write_lock(&journal->j_state_lock);
        if (!journal->j_running_transaction) { # true
          jbd2_get_transaction(journal, new_transaction);
        write_unlock(&journal->j_state_lock);
        goto repeat; # eventually blocks on j_barrier_count > 0
                                             ...
                                             J_ASSERT(!journal->j_running_transaction);
                                               # fails
    
    We fix the race by rechecking j_barrier_count after reacquiring j_state_lock
    in exclusive mode.
    
    Reported-by: yjwsignal@empal.com
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: "Theodore Ts'o" <tytso@mit.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 7a55283222cdd70c1cd7a33df0db1e0c96462ac9
Author: Jan Kara <jack@suse.cz>
Date:   Fri Dec 21 00:15:51 2012 -0500

    jbd2: fix assertion failure in jbd2_journal_flush()
    
    commit d7961c7fa4d2e3c3f12be67e21ba8799b5a7238a upstream.
    
    The following race is possible between start_this_handle() and someone
    calling jbd2_journal_flush().
    
    Process A                              Process B
    start_this_handle().
      if (journal->j_barrier_count) # false
      if (!journal->j_running_transaction) { #true
        read_unlock(&journal->j_state_lock);
                                           jbd2_journal_lock_updates()
                                           jbd2_journal_flush()
                                             write_lock(&journal->j_state_lock);
                                             if (journal->j_running_transaction) {
                                               # false
                                             ... wait for committing trans ...
                                             write_unlock(&journal->j_state_lock);
        ...
        write_lock(&journal->j_state_lock);
        if (!journal->j_running_transaction) { # true
          jbd2_get_transaction(journal, new_transaction);
        write_unlock(&journal->j_state_lock);
        goto repeat; # eventually blocks on j_barrier_count > 0
                                             ...
                                             J_ASSERT(!journal->j_running_transaction);
                                               # fails
    
    We fix the race by rechecking j_barrier_count after reacquiring j_state_lock
    in exclusive mode.
    
    Reported-by: yjwsignal@empal.com
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: "Theodore Ts'o" <tytso@mit.edu>
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit d7961c7fa4d2e3c3f12be67e21ba8799b5a7238a
Author: Jan Kara <jack@suse.cz>
Date:   Fri Dec 21 00:15:51 2012 -0500

    jbd2: fix assertion failure in jbd2_journal_flush()
    
    The following race is possible between start_this_handle() and someone
    calling jbd2_journal_flush().
    
    Process A                              Process B
    start_this_handle().
      if (journal->j_barrier_count) # false
      if (!journal->j_running_transaction) { #true
        read_unlock(&journal->j_state_lock);
                                           jbd2_journal_lock_updates()
                                           jbd2_journal_flush()
                                             write_lock(&journal->j_state_lock);
                                             if (journal->j_running_transaction) {
                                               # false
                                             ... wait for committing trans ...
                                             write_unlock(&journal->j_state_lock);
        ...
        write_lock(&journal->j_state_lock);
        if (!journal->j_running_transaction) { # true
          jbd2_get_transaction(journal, new_transaction);
        write_unlock(&journal->j_state_lock);
        goto repeat; # eventually blocks on j_barrier_count > 0
                                             ...
                                             J_ASSERT(!journal->j_running_transaction);
                                               # fails
    
    We fix the race by rechecking j_barrier_count after reacquiring j_state_lock
    in exclusive mode.
    
    Reported-by: yjwsignal@empal.com
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: "Theodore Ts'o" <tytso@mit.edu>
    Cc: stable@vger.kernel.org

commit 0b0ea6a363eb3f5802adcb07c8c23e052a10d6bb
Author: Lin Ming <mlin@ss.pku.edu.cn>
Date:   Sat Jul 7 18:26:10 2012 +0800

    ipvs: fix oops on NAT reply in br_nf context
    
    commit 9e33ce453f8ac8452649802bee1f410319408f4b upstream.
    
    IPVS should not reset skb->nf_bridge in FORWARD hook
    by calling nf_reset for NAT replies. It triggers oops in
    br_nf_forward_finish.
    
    [  579.781508] BUG: unable to handle kernel NULL pointer dereference at 0000000000000004
    [  579.781669] IP: [<ffffffff817b1ca5>] br_nf_forward_finish+0x58/0x112
    [  579.781792] PGD 218f9067 PUD 0
    [  579.781865] Oops: 0000 [#1] SMP
    [  579.781945] CPU 0
    [  579.781983] Modules linked in:
    [  579.782047]
    [  579.782080]
    [  579.782114] Pid: 4644, comm: qemu Tainted: G        W    3.5.0-rc5-00006-g95e69f9 #282 Hewlett-Packard  /30E8
    [  579.782300] RIP: 0010:[<ffffffff817b1ca5>]  [<ffffffff817b1ca5>] br_nf_forward_finish+0x58/0x112
    [  579.782455] RSP: 0018:ffff88007b003a98  EFLAGS: 00010287
    [  579.782541] RAX: 0000000000000008 RBX: ffff8800762ead00 RCX: 000000000001670a
    [  579.782653] RDX: 0000000000000000 RSI: 000000000000000a RDI: ffff8800762ead00
    [  579.782845] RBP: ffff88007b003ac8 R08: 0000000000016630 R09: ffff88007b003a90
    [  579.782957] R10: ffff88007b0038e8 R11: ffff88002da37540 R12: ffff88002da01a02
    [  579.783066] R13: ffff88002da01a80 R14: ffff88002d83c000 R15: ffff88002d82a000
    [  579.783177] FS:  0000000000000000(0000) GS:ffff88007b000000(0063) knlGS:00000000f62d1b70
    [  579.783306] CS:  0010 DS: 002b ES: 002b CR0: 000000008005003b
    [  579.783395] CR2: 0000000000000004 CR3: 00000000218fe000 CR4: 00000000000027f0
    [  579.783505] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
    [  579.783684] DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400
    [  579.783795] Process qemu (pid: 4644, threadinfo ffff880021b20000, task ffff880021aba760)
    [  579.783919] Stack:
    [  579.783959]  ffff88007693cedc ffff8800762ead00 ffff88002da01a02 ffff8800762ead00
    [  579.784110]  ffff88002da01a02 ffff88002da01a80 ffff88007b003b18 ffffffff817b26c7
    [  579.784260]  ffff880080000000 ffffffff81ef59f0 ffff8800762ead00 ffffffff81ef58b0
    [  579.784477] Call Trace:
    [  579.784523]  <IRQ>
    [  579.784562]
    [  579.784603]  [<ffffffff817b26c7>] br_nf_forward_ip+0x275/0x2c8
    [  579.784707]  [<ffffffff81704b58>] nf_iterate+0x47/0x7d
    [  579.784797]  [<ffffffff817ac32e>] ? br_dev_queue_push_xmit+0xae/0xae
    [  579.784906]  [<ffffffff81704bfb>] nf_hook_slow+0x6d/0x102
    [  579.784995]  [<ffffffff817ac32e>] ? br_dev_queue_push_xmit+0xae/0xae
    [  579.785175]  [<ffffffff8187fa95>] ? _raw_write_unlock_bh+0x19/0x1b
    [  579.785179]  [<ffffffff817ac417>] __br_forward+0x97/0xa2
    [  579.785179]  [<ffffffff817ad366>] br_handle_frame_finish+0x1a6/0x257
    [  579.785179]  [<ffffffff817b2386>] br_nf_pre_routing_finish+0x26d/0x2cb
    [  579.785179]  [<ffffffff817b2cf0>] br_nf_pre_routing+0x55d/0x5c1
    [  579.785179]  [<ffffffff81704b58>] nf_iterate+0x47/0x7d
    [  579.785179]  [<ffffffff817ad1c0>] ? br_handle_local_finish+0x44/0x44
    [  579.785179]  [<ffffffff81704bfb>] nf_hook_slow+0x6d/0x102
    [  579.785179]  [<ffffffff817ad1c0>] ? br_handle_local_finish+0x44/0x44
    [  579.785179]  [<ffffffff81551525>] ? sky2_poll+0xb35/0xb54
    [  579.785179]  [<ffffffff817ad62a>] br_handle_frame+0x213/0x229
    [  579.785179]  [<ffffffff817ad417>] ? br_handle_frame_finish+0x257/0x257
    [  579.785179]  [<ffffffff816e3b47>] __netif_receive_skb+0x2b4/0x3f1
    [  579.785179]  [<ffffffff816e69fc>] process_backlog+0x99/0x1e2
    [  579.785179]  [<ffffffff816e6800>] net_rx_action+0xdf/0x242
    [  579.785179]  [<ffffffff8107e8a8>] __do_softirq+0xc1/0x1e0
    [  579.785179]  [<ffffffff8135a5ba>] ? trace_hardirqs_off_thunk+0x3a/0x6c
    [  579.785179]  [<ffffffff8188812c>] call_softirq+0x1c/0x30
    
    The steps to reproduce as follow,
    
    1. On Host1, setup brige br0(192.168.1.106)
    2. Boot a kvm guest(192.168.1.105) on Host1 and start httpd
    3. Start IPVS service on Host1
       ipvsadm -A -t 192.168.1.106:80 -s rr
       ipvsadm -a -t 192.168.1.106:80 -r 192.168.1.105:80 -m
    4. Run apache benchmark on Host2(192.168.1.101)
       ab -n 1000 http://192.168.1.106/
    
    ip_vs_reply4
      ip_vs_out
        handle_response
          ip_vs_notrack
            nf_reset()
            {
              skb->nf_bridge = NULL;
            }
    
    Actually, IPVS wants in this case just to replace nfct
    with untracked version. So replace the nf_reset(skb) call
    in ip_vs_notrack() with a nf_conntrack_put(skb->nfct) call.
    
    Signed-off-by: Lin Ming <mlin@ss.pku.edu.cn>
    Signed-off-by: Julian Anastasov <ja@ssi.bg>
    Signed-off-by: Simon Horman <horms@verge.net.au>
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
    Acked-by: David Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 4b552154cccd5407bb02a7f17ed5a37939fd821e
Author: Lin Ming <mlin@ss.pku.edu.cn>
Date:   Sat Jul 7 18:26:10 2012 +0800

    ipvs: fix oops on NAT reply in br_nf context
    
    commit 9e33ce453f8ac8452649802bee1f410319408f4b upstream.
    
    IPVS should not reset skb->nf_bridge in FORWARD hook
    by calling nf_reset for NAT replies. It triggers oops in
    br_nf_forward_finish.
    
    [  579.781508] BUG: unable to handle kernel NULL pointer dereference at 0000000000000004
    [  579.781669] IP: [<ffffffff817b1ca5>] br_nf_forward_finish+0x58/0x112
    [  579.781792] PGD 218f9067 PUD 0
    [  579.781865] Oops: 0000 [#1] SMP
    [  579.781945] CPU 0
    [  579.781983] Modules linked in:
    [  579.782047]
    [  579.782080]
    [  579.782114] Pid: 4644, comm: qemu Tainted: G        W    3.5.0-rc5-00006-g95e69f9 #282 Hewlett-Packard  /30E8
    [  579.782300] RIP: 0010:[<ffffffff817b1ca5>]  [<ffffffff817b1ca5>] br_nf_forward_finish+0x58/0x112
    [  579.782455] RSP: 0018:ffff88007b003a98  EFLAGS: 00010287
    [  579.782541] RAX: 0000000000000008 RBX: ffff8800762ead00 RCX: 000000000001670a
    [  579.782653] RDX: 0000000000000000 RSI: 000000000000000a RDI: ffff8800762ead00
    [  579.782845] RBP: ffff88007b003ac8 R08: 0000000000016630 R09: ffff88007b003a90
    [  579.782957] R10: ffff88007b0038e8 R11: ffff88002da37540 R12: ffff88002da01a02
    [  579.783066] R13: ffff88002da01a80 R14: ffff88002d83c000 R15: ffff88002d82a000
    [  579.783177] FS:  0000000000000000(0000) GS:ffff88007b000000(0063) knlGS:00000000f62d1b70
    [  579.783306] CS:  0010 DS: 002b ES: 002b CR0: 000000008005003b
    [  579.783395] CR2: 0000000000000004 CR3: 00000000218fe000 CR4: 00000000000027f0
    [  579.783505] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
    [  579.783684] DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400
    [  579.783795] Process qemu (pid: 4644, threadinfo ffff880021b20000, task ffff880021aba760)
    [  579.783919] Stack:
    [  579.783959]  ffff88007693cedc ffff8800762ead00 ffff88002da01a02 ffff8800762ead00
    [  579.784110]  ffff88002da01a02 ffff88002da01a80 ffff88007b003b18 ffffffff817b26c7
    [  579.784260]  ffff880080000000 ffffffff81ef59f0 ffff8800762ead00 ffffffff81ef58b0
    [  579.784477] Call Trace:
    [  579.784523]  <IRQ>
    [  579.784562]
    [  579.784603]  [<ffffffff817b26c7>] br_nf_forward_ip+0x275/0x2c8
    [  579.784707]  [<ffffffff81704b58>] nf_iterate+0x47/0x7d
    [  579.784797]  [<ffffffff817ac32e>] ? br_dev_queue_push_xmit+0xae/0xae
    [  579.784906]  [<ffffffff81704bfb>] nf_hook_slow+0x6d/0x102
    [  579.784995]  [<ffffffff817ac32e>] ? br_dev_queue_push_xmit+0xae/0xae
    [  579.785175]  [<ffffffff8187fa95>] ? _raw_write_unlock_bh+0x19/0x1b
    [  579.785179]  [<ffffffff817ac417>] __br_forward+0x97/0xa2
    [  579.785179]  [<ffffffff817ad366>] br_handle_frame_finish+0x1a6/0x257
    [  579.785179]  [<ffffffff817b2386>] br_nf_pre_routing_finish+0x26d/0x2cb
    [  579.785179]  [<ffffffff817b2cf0>] br_nf_pre_routing+0x55d/0x5c1
    [  579.785179]  [<ffffffff81704b58>] nf_iterate+0x47/0x7d
    [  579.785179]  [<ffffffff817ad1c0>] ? br_handle_local_finish+0x44/0x44
    [  579.785179]  [<ffffffff81704bfb>] nf_hook_slow+0x6d/0x102
    [  579.785179]  [<ffffffff817ad1c0>] ? br_handle_local_finish+0x44/0x44
    [  579.785179]  [<ffffffff81551525>] ? sky2_poll+0xb35/0xb54
    [  579.785179]  [<ffffffff817ad62a>] br_handle_frame+0x213/0x229
    [  579.785179]  [<ffffffff817ad417>] ? br_handle_frame_finish+0x257/0x257
    [  579.785179]  [<ffffffff816e3b47>] __netif_receive_skb+0x2b4/0x3f1
    [  579.785179]  [<ffffffff816e69fc>] process_backlog+0x99/0x1e2
    [  579.785179]  [<ffffffff816e6800>] net_rx_action+0xdf/0x242
    [  579.785179]  [<ffffffff8107e8a8>] __do_softirq+0xc1/0x1e0
    [  579.785179]  [<ffffffff8135a5ba>] ? trace_hardirqs_off_thunk+0x3a/0x6c
    [  579.785179]  [<ffffffff8188812c>] call_softirq+0x1c/0x30
    
    The steps to reproduce as follow,
    
    1. On Host1, setup brige br0(192.168.1.106)
    2. Boot a kvm guest(192.168.1.105) on Host1 and start httpd
    3. Start IPVS service on Host1
       ipvsadm -A -t 192.168.1.106:80 -s rr
       ipvsadm -a -t 192.168.1.106:80 -r 192.168.1.105:80 -m
    4. Run apache benchmark on Host2(192.168.1.101)
       ab -n 1000 http://192.168.1.106/
    
    ip_vs_reply4
      ip_vs_out
        handle_response
          ip_vs_notrack
            nf_reset()
            {
              skb->nf_bridge = NULL;
            }
    
    Actually, IPVS wants in this case just to replace nfct
    with untracked version. So replace the nf_reset(skb) call
    in ip_vs_notrack() with a nf_conntrack_put(skb->nfct) call.
    
    Signed-off-by: Lin Ming <mlin@ss.pku.edu.cn>
    Signed-off-by: Julian Anastasov <ja@ssi.bg>
    Signed-off-by: Simon Horman <horms@verge.net.au>
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
    Acked-by: David Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit bfa539657d2f54ed7f584e0577a37d4e06c2d959
Author: Lin Ming <mlin@ss.pku.edu.cn>
Date:   Sat Jul 7 18:26:10 2012 +0800

    ipvs: fix oops on NAT reply in br_nf context
    
    commit 9e33ce453f8ac8452649802bee1f410319408f4b upstream.
    
    IPVS should not reset skb->nf_bridge in FORWARD hook
    by calling nf_reset for NAT replies. It triggers oops in
    br_nf_forward_finish.
    
    [  579.781508] BUG: unable to handle kernel NULL pointer dereference at 0000000000000004
    [  579.781669] IP: [<ffffffff817b1ca5>] br_nf_forward_finish+0x58/0x112
    [  579.781792] PGD 218f9067 PUD 0
    [  579.781865] Oops: 0000 [#1] SMP
    [  579.781945] CPU 0
    [  579.781983] Modules linked in:
    [  579.782047]
    [  579.782080]
    [  579.782114] Pid: 4644, comm: qemu Tainted: G        W    3.5.0-rc5-00006-g95e69f9 #282 Hewlett-Packard  /30E8
    [  579.782300] RIP: 0010:[<ffffffff817b1ca5>]  [<ffffffff817b1ca5>] br_nf_forward_finish+0x58/0x112
    [  579.782455] RSP: 0018:ffff88007b003a98  EFLAGS: 00010287
    [  579.782541] RAX: 0000000000000008 RBX: ffff8800762ead00 RCX: 000000000001670a
    [  579.782653] RDX: 0000000000000000 RSI: 000000000000000a RDI: ffff8800762ead00
    [  579.782845] RBP: ffff88007b003ac8 R08: 0000000000016630 R09: ffff88007b003a90
    [  579.782957] R10: ffff88007b0038e8 R11: ffff88002da37540 R12: ffff88002da01a02
    [  579.783066] R13: ffff88002da01a80 R14: ffff88002d83c000 R15: ffff88002d82a000
    [  579.783177] FS:  0000000000000000(0000) GS:ffff88007b000000(0063) knlGS:00000000f62d1b70
    [  579.783306] CS:  0010 DS: 002b ES: 002b CR0: 000000008005003b
    [  579.783395] CR2: 0000000000000004 CR3: 00000000218fe000 CR4: 00000000000027f0
    [  579.783505] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
    [  579.783684] DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400
    [  579.783795] Process qemu (pid: 4644, threadinfo ffff880021b20000, task ffff880021aba760)
    [  579.783919] Stack:
    [  579.783959]  ffff88007693cedc ffff8800762ead00 ffff88002da01a02 ffff8800762ead00
    [  579.784110]  ffff88002da01a02 ffff88002da01a80 ffff88007b003b18 ffffffff817b26c7
    [  579.784260]  ffff880080000000 ffffffff81ef59f0 ffff8800762ead00 ffffffff81ef58b0
    [  579.784477] Call Trace:
    [  579.784523]  <IRQ>
    [  579.784562]
    [  579.784603]  [<ffffffff817b26c7>] br_nf_forward_ip+0x275/0x2c8
    [  579.784707]  [<ffffffff81704b58>] nf_iterate+0x47/0x7d
    [  579.784797]  [<ffffffff817ac32e>] ? br_dev_queue_push_xmit+0xae/0xae
    [  579.784906]  [<ffffffff81704bfb>] nf_hook_slow+0x6d/0x102
    [  579.784995]  [<ffffffff817ac32e>] ? br_dev_queue_push_xmit+0xae/0xae
    [  579.785175]  [<ffffffff8187fa95>] ? _raw_write_unlock_bh+0x19/0x1b
    [  579.785179]  [<ffffffff817ac417>] __br_forward+0x97/0xa2
    [  579.785179]  [<ffffffff817ad366>] br_handle_frame_finish+0x1a6/0x257
    [  579.785179]  [<ffffffff817b2386>] br_nf_pre_routing_finish+0x26d/0x2cb
    [  579.785179]  [<ffffffff817b2cf0>] br_nf_pre_routing+0x55d/0x5c1
    [  579.785179]  [<ffffffff81704b58>] nf_iterate+0x47/0x7d
    [  579.785179]  [<ffffffff817ad1c0>] ? br_handle_local_finish+0x44/0x44
    [  579.785179]  [<ffffffff81704bfb>] nf_hook_slow+0x6d/0x102
    [  579.785179]  [<ffffffff817ad1c0>] ? br_handle_local_finish+0x44/0x44
    [  579.785179]  [<ffffffff81551525>] ? sky2_poll+0xb35/0xb54
    [  579.785179]  [<ffffffff817ad62a>] br_handle_frame+0x213/0x229
    [  579.785179]  [<ffffffff817ad417>] ? br_handle_frame_finish+0x257/0x257
    [  579.785179]  [<ffffffff816e3b47>] __netif_receive_skb+0x2b4/0x3f1
    [  579.785179]  [<ffffffff816e69fc>] process_backlog+0x99/0x1e2
    [  579.785179]  [<ffffffff816e6800>] net_rx_action+0xdf/0x242
    [  579.785179]  [<ffffffff8107e8a8>] __do_softirq+0xc1/0x1e0
    [  579.785179]  [<ffffffff8135a5ba>] ? trace_hardirqs_off_thunk+0x3a/0x6c
    [  579.785179]  [<ffffffff8188812c>] call_softirq+0x1c/0x30
    
    The steps to reproduce as follow,
    
    1. On Host1, setup brige br0(192.168.1.106)
    2. Boot a kvm guest(192.168.1.105) on Host1 and start httpd
    3. Start IPVS service on Host1
       ipvsadm -A -t 192.168.1.106:80 -s rr
       ipvsadm -a -t 192.168.1.106:80 -r 192.168.1.105:80 -m
    4. Run apache benchmark on Host2(192.168.1.101)
       ab -n 1000 http://192.168.1.106/
    
    ip_vs_reply4
      ip_vs_out
        handle_response
          ip_vs_notrack
            nf_reset()
            {
              skb->nf_bridge = NULL;
            }
    
    Actually, IPVS wants in this case just to replace nfct
    with untracked version. So replace the nf_reset(skb) call
    in ip_vs_notrack() with a nf_conntrack_put(skb->nfct) call.
    
    Signed-off-by: Lin Ming <mlin@ss.pku.edu.cn>
    Signed-off-by: Julian Anastasov <ja@ssi.bg>
    Signed-off-by: Simon Horman <horms@verge.net.au>
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit 0967237ca6521c63822340138e4d62ecf8a3d173
Author: Tony Luck <tony.luck@intel.com>
Date:   Thu Sep 20 11:47:13 2012 -0700

    [IA64] Must enable interrupts in do_notify_resume_user before calling tracehook_notify_resume()
    
    If we call with interrupts disabled, we'll be hit with:
    
    WARNING: at kernel/softirq.c:160 local_bh_enable_ip+0x150/0x180() and a stack
    trace like this:
    
    Call Trace:
     [<a000000100015480>] show_stack+0x80/0xa0
     [<a000000100d9a520>] dump_stack+0x30/0x50
     [<a000000100072fc0>] warn_slowpath_common+0xc0/0x100
     [<a000000100073040>] warn_slowpath_null+0x40/0x60
     [<a0000001000884d0>] local_bh_enable_ip+0x150/0x180
     [<a000000100da2960>] _raw_write_unlock_bh+0x40/0x60
     [<a000000100cf03c0>] unix_release_sock+0x120/0x5a0
     [<a000000100cf0880>] unix_release+0x40/0x60
     [<a000000100b84400>] sock_release+0x60/0x1a0
     [<a000000100b84b70>] sock_close+0x30/0xa0
     [<a0000001001d10f0>] __fput+0x190/0x500
     [<a0000001001d1580>] ____fput+0x20/0x40
     [<a0000001000b6570>] task_work_run+0x1b0/0x260
     [<a000000100015190>] do_notify_resume_user+0x110/0x2a0
     [<a00000010000c5a0>] notify_resume_user+0x40/0x60
     [<a00000010000c4d0>] skip_rbs_switch+0xe0/0xf0
     [<a000000000040720>] ia64_ivt+0xffffffff00040720/0x400
    
    Fix-suggested-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Tony Luck <tony.luck@intel.com>

commit 9e33ce453f8ac8452649802bee1f410319408f4b
Author: Lin Ming <mlin@ss.pku.edu.cn>
Date:   Sat Jul 7 18:26:10 2012 +0800

    ipvs: fix oops on NAT reply in br_nf context
    
    IPVS should not reset skb->nf_bridge in FORWARD hook
    by calling nf_reset for NAT replies. It triggers oops in
    br_nf_forward_finish.
    
    [  579.781508] BUG: unable to handle kernel NULL pointer dereference at 0000000000000004
    [  579.781669] IP: [<ffffffff817b1ca5>] br_nf_forward_finish+0x58/0x112
    [  579.781792] PGD 218f9067 PUD 0
    [  579.781865] Oops: 0000 [#1] SMP
    [  579.781945] CPU 0
    [  579.781983] Modules linked in:
    [  579.782047]
    [  579.782080]
    [  579.782114] Pid: 4644, comm: qemu Tainted: G        W    3.5.0-rc5-00006-g95e69f9 #282 Hewlett-Packard  /30E8
    [  579.782300] RIP: 0010:[<ffffffff817b1ca5>]  [<ffffffff817b1ca5>] br_nf_forward_finish+0x58/0x112
    [  579.782455] RSP: 0018:ffff88007b003a98  EFLAGS: 00010287
    [  579.782541] RAX: 0000000000000008 RBX: ffff8800762ead00 RCX: 000000000001670a
    [  579.782653] RDX: 0000000000000000 RSI: 000000000000000a RDI: ffff8800762ead00
    [  579.782845] RBP: ffff88007b003ac8 R08: 0000000000016630 R09: ffff88007b003a90
    [  579.782957] R10: ffff88007b0038e8 R11: ffff88002da37540 R12: ffff88002da01a02
    [  579.783066] R13: ffff88002da01a80 R14: ffff88002d83c000 R15: ffff88002d82a000
    [  579.783177] FS:  0000000000000000(0000) GS:ffff88007b000000(0063) knlGS:00000000f62d1b70
    [  579.783306] CS:  0010 DS: 002b ES: 002b CR0: 000000008005003b
    [  579.783395] CR2: 0000000000000004 CR3: 00000000218fe000 CR4: 00000000000027f0
    [  579.783505] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
    [  579.783684] DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400
    [  579.783795] Process qemu (pid: 4644, threadinfo ffff880021b20000, task ffff880021aba760)
    [  579.783919] Stack:
    [  579.783959]  ffff88007693cedc ffff8800762ead00 ffff88002da01a02 ffff8800762ead00
    [  579.784110]  ffff88002da01a02 ffff88002da01a80 ffff88007b003b18 ffffffff817b26c7
    [  579.784260]  ffff880080000000 ffffffff81ef59f0 ffff8800762ead00 ffffffff81ef58b0
    [  579.784477] Call Trace:
    [  579.784523]  <IRQ>
    [  579.784562]
    [  579.784603]  [<ffffffff817b26c7>] br_nf_forward_ip+0x275/0x2c8
    [  579.784707]  [<ffffffff81704b58>] nf_iterate+0x47/0x7d
    [  579.784797]  [<ffffffff817ac32e>] ? br_dev_queue_push_xmit+0xae/0xae
    [  579.784906]  [<ffffffff81704bfb>] nf_hook_slow+0x6d/0x102
    [  579.784995]  [<ffffffff817ac32e>] ? br_dev_queue_push_xmit+0xae/0xae
    [  579.785175]  [<ffffffff8187fa95>] ? _raw_write_unlock_bh+0x19/0x1b
    [  579.785179]  [<ffffffff817ac417>] __br_forward+0x97/0xa2
    [  579.785179]  [<ffffffff817ad366>] br_handle_frame_finish+0x1a6/0x257
    [  579.785179]  [<ffffffff817b2386>] br_nf_pre_routing_finish+0x26d/0x2cb
    [  579.785179]  [<ffffffff817b2cf0>] br_nf_pre_routing+0x55d/0x5c1
    [  579.785179]  [<ffffffff81704b58>] nf_iterate+0x47/0x7d
    [  579.785179]  [<ffffffff817ad1c0>] ? br_handle_local_finish+0x44/0x44
    [  579.785179]  [<ffffffff81704bfb>] nf_hook_slow+0x6d/0x102
    [  579.785179]  [<ffffffff817ad1c0>] ? br_handle_local_finish+0x44/0x44
    [  579.785179]  [<ffffffff81551525>] ? sky2_poll+0xb35/0xb54
    [  579.785179]  [<ffffffff817ad62a>] br_handle_frame+0x213/0x229
    [  579.785179]  [<ffffffff817ad417>] ? br_handle_frame_finish+0x257/0x257
    [  579.785179]  [<ffffffff816e3b47>] __netif_receive_skb+0x2b4/0x3f1
    [  579.785179]  [<ffffffff816e69fc>] process_backlog+0x99/0x1e2
    [  579.785179]  [<ffffffff816e6800>] net_rx_action+0xdf/0x242
    [  579.785179]  [<ffffffff8107e8a8>] __do_softirq+0xc1/0x1e0
    [  579.785179]  [<ffffffff8135a5ba>] ? trace_hardirqs_off_thunk+0x3a/0x6c
    [  579.785179]  [<ffffffff8188812c>] call_softirq+0x1c/0x30
    
    The steps to reproduce as follow,
    
    1. On Host1, setup brige br0(192.168.1.106)
    2. Boot a kvm guest(192.168.1.105) on Host1 and start httpd
    3. Start IPVS service on Host1
       ipvsadm -A -t 192.168.1.106:80 -s rr
       ipvsadm -a -t 192.168.1.106:80 -r 192.168.1.105:80 -m
    4. Run apache benchmark on Host2(192.168.1.101)
       ab -n 1000 http://192.168.1.106/
    
    ip_vs_reply4
      ip_vs_out
        handle_response
          ip_vs_notrack
            nf_reset()
            {
              skb->nf_bridge = NULL;
            }
    
    Actually, IPVS wants in this case just to replace nfct
    with untracked version. So replace the nf_reset(skb) call
    in ip_vs_notrack() with a nf_conntrack_put(skb->nfct) call.
    
    Signed-off-by: Lin Ming <mlin@ss.pku.edu.cn>
    Signed-off-by: Julian Anastasov <ja@ssi.bg>
    Signed-off-by: Simon Horman <horms@verge.net.au>
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>

commit 4157368edbc3d69b05e9294a73c84fc9c96bdec4
Merge: 9479f0f8018a 00a62d4bc9b9
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Apr 6 17:56:20 2012 -0700

    Merge branch 'stable' of git://git.kernel.org/pub/scm/linux/kernel/git/cmetcalf/linux-tile
    
    Pull arch/tile bug fixes from Chris Metcalf:
     "This includes Paul Gortmaker's change to fix the <asm/system.h>
      disintegration issues on tile, a fix to unbreak the tilepro ethernet
      driver, and a backlog of bugfix-only changes from internal Tilera
      development over the last few months.
    
      They have all been to LKML and on linux-next for the last few days.
      The EDAC change to MAINTAINERS is an oddity but discussion on the
      linux-edac list suggested I ask you to pull that change through my
      tree since they don't have a tree to pull edac changes from at the
      moment."
    
    * 'stable' of git://git.kernel.org/pub/scm/linux/kernel/git/cmetcalf/linux-tile: (39 commits)
      drivers/net/ethernet/tile: fix netdev_alloc_skb() bombing
      MAINTAINERS: update EDAC information
      tilepro ethernet driver: fix a few minor issues
      tile-srom.c driver: minor code cleanup
      edac: say "TILEGx" not "TILEPro" for the tilegx edac driver
      arch/tile: avoid accidentally unmasking NMI-type interrupt accidentally
      arch/tile: remove bogus performance optimization
      arch/tile: return SIGBUS for addresses that are unaligned AND invalid
      arch/tile: fix finv_buffer_remote() for tilegx
      arch/tile: use atomic exchange in arch_write_unlock()
      arch/tile: stop mentioning the "kvm" subdirectory
      arch/tile: export the page_home() function.
      arch/tile: fix pointer cast in cacheflush.c
      arch/tile: fix single-stepping over swint1 instructions on tilegx
      arch/tile: implement panic_smp_self_stop()
      arch/tile: add "nop" after "nap" to help GX idle power draw
      arch/tile: use proper memparse() for "maxmem" options
      arch/tile: fix up locking in pgtable.c slightly
      arch/tile: don't leak kernel memory when we unload modules
      arch/tile: fix bug in delay_backoff()
      ...

commit ab306cae660e524edbeb8889e4e23d3c97717b9c
Author: Chris Metcalf <cmetcalf@tilera.com>
Date:   Fri Mar 30 15:46:29 2012 -0400

    arch/tile: use atomic exchange in arch_write_unlock()
    
    This idiom is used elsewhere when we do an unlock by writing a zero,
    but I missed it here.  Using an atomic operation avoids waiting
    on the write buffer for the unlocking write to be sent to the home cache.
    
    Signed-off-by: Chris Metcalf <cmetcalf@tilera.com>

commit 3ce3230a0cff484e5130153f244d4fb8a56b3a8b
Author: Frederic Weisbecker <fweisbec@gmail.com>
Date:   Wed Feb 8 03:37:27 2012 +0100

    cgroup: Walk task list under tasklist_lock in cgroup_enable_task_cg_list
    
    Walking through the tasklist in cgroup_enable_task_cg_list() inside
    an RCU read side critical section is not enough because:
    
    - RCU is not (yet) safe against while_each_thread()
    
    - If we use only RCU, a forking task that has passed cgroup_post_fork()
      without seeing use_task_css_set_links == 1 is not guaranteed to have
      its child immediately visible in the tasklist if we walk through it
      remotely with RCU. In this case it will be missing in its css_set's
      task list.
    
    Thus we need to traverse the list (unfortunately) under the
    tasklist_lock. It makes us safe against while_each_thread() and also
    make sure we see all forked task that have been added to the tasklist.
    
    As a secondary effect, reading and writing use_task_css_set_links are
    now well ordered against tasklist traversing and modification. The new
    layout is:
    
    CPU 0                                      CPU 1
    
    use_task_css_set_links = 1                write_lock(tasklist_lock)
    read_lock(tasklist_lock)                  add task to tasklist
    do_each_thread() {                        write_unlock(tasklist_lock)
            add thread to css set links       if (use_task_css_set_links)
    } while_each_thread()                         add thread to css set links
    read_unlock(tasklist_lock)
    
    If CPU 0 traverse the list after the task has been added to the tasklist
    then it is correctly added to the css set links. OTOH if CPU 0 traverse
    the tasklist before the new task had the opportunity to be added to the
    tasklist because it was too early in the fork process, then CPU 1
    catches up and add the task to the css set links after it added the task
    to the tasklist. The right value of use_task_css_set_links is guaranteed
    to be visible from CPU 1 due to the LOCK/UNLOCK implicit barrier properties:
    the read_unlock on CPU 0 makes the write on use_task_css_set_links happening
    and the write_lock on CPU 1 make the read of use_task_css_set_links that comes
    afterward to return the correct value.
    
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>
    Acked-by: Li Zefan <lizf@cn.fujitsu.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Mandeep Singh Baines <msb@chromium.org>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Paul E. McKenney <paulmck@linux.vnet.ibm.com>

commit 27c57858531c4829a1446ebb5fd606d07846b2e5
Author: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
Date:   Thu Dec 22 02:45:29 2011 +0530

    VFS: Fix race between CPU hotplug and lglocks
    
    commit e30e2fdfe56288576ee9e04dbb06b4bd5f282203 upstream.
    
    Currently, the *_global_[un]lock_online() routines are not at all synchronized
    with CPU hotplug. Soft-lockups detected as a consequence of this race was
    reported earlier at https://lkml.org/lkml/2011/8/24/185. (Thanks to Cong Meng
    for finding out that the root-cause of this issue is the race condition
    between br_write_[un]lock() and CPU hotplug, which results in the lock states
    getting messed up).
    
    Fixing this race by just adding {get,put}_online_cpus() at appropriate places
    in *_global_[un]lock_online() is not a good option, because, then suddenly
    br_write_[un]lock() would become blocking, whereas they have been kept as
    non-blocking all this time, and we would want to keep them that way.
    
    So, overall, we want to ensure 3 things:
    1. br_write_lock() and br_write_unlock() must remain as non-blocking.
    2. The corresponding lock and unlock of the per-cpu spinlocks must not happen
       for different sets of CPUs.
    3. Either prevent any new CPU online operation in between this lock-unlock, or
       ensure that the newly onlined CPU does not proceed with its corresponding
       per-cpu spinlock unlocked.
    
    To achieve all this:
    (a) We introduce a new spinlock that is taken by the *_global_lock_online()
        routine and released by the *_global_unlock_online() routine.
    (b) We register a callback for CPU hotplug notifications, and this callback
        takes the same spinlock as above.
    (c) We maintain a bitmap which is close to the cpu_online_mask, and once it is
        initialized in the lock_init() code, all future updates to it are done in
        the callback, under the above spinlock.
    (d) The above bitmap is used (instead of cpu_online_mask) while locking and
        unlocking the per-cpu locks.
    
    The callback takes the spinlock upon the CPU_UP_PREPARE event. So, if the
    br_write_lock-unlock sequence is in progress, the callback keeps spinning,
    thus preventing the CPU online operation till the lock-unlock sequence is
    complete. This takes care of requirement (3).
    
    The bitmap that we maintain remains unmodified throughout the lock-unlock
    sequence, since all updates to it are managed by the callback, which takes
    the same spinlock as the one taken by the lock code and released only by the
    unlock routine. Combining this with (d) above, satisfies requirement (2).
    
    Overall, since we use a spinlock (mentioned in (a)) to prevent CPU hotplug
    operations from racing with br_write_lock-unlock, requirement (1) is also
    taken care of.
    
    By the way, it is to be noted that a CPU offline operation can actually run
    in parallel with our lock-unlock sequence, because our callback doesn't react
    to notifications earlier than CPU_DEAD (in order to maintain our bitmap
    properly). And this means, since we use our own bitmap (which is stale, on
    purpose) during the lock-unlock sequence, we could end up unlocking the
    per-cpu lock of an offline CPU (because we had locked it earlier, when the
    CPU was online), in order to satisfy requirement (2). But this is harmless,
    though it looks a bit awkward.
    
    Debugged-by: Cong Meng <mc@linux.vnet.ibm.com>
    Signed-off-by: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit f3545737cf06d342d34483b7a8421d0bb90b9c1b
Author: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
Date:   Thu Dec 22 02:45:29 2011 +0530

    VFS: Fix race between CPU hotplug and lglocks
    
    commit e30e2fdfe56288576ee9e04dbb06b4bd5f282203 upstream.
    
    Currently, the *_global_[un]lock_online() routines are not at all synchronized
    with CPU hotplug. Soft-lockups detected as a consequence of this race was
    reported earlier at https://lkml.org/lkml/2011/8/24/185. (Thanks to Cong Meng
    for finding out that the root-cause of this issue is the race condition
    between br_write_[un]lock() and CPU hotplug, which results in the lock states
    getting messed up).
    
    Fixing this race by just adding {get,put}_online_cpus() at appropriate places
    in *_global_[un]lock_online() is not a good option, because, then suddenly
    br_write_[un]lock() would become blocking, whereas they have been kept as
    non-blocking all this time, and we would want to keep them that way.
    
    So, overall, we want to ensure 3 things:
    1. br_write_lock() and br_write_unlock() must remain as non-blocking.
    2. The corresponding lock and unlock of the per-cpu spinlocks must not happen
       for different sets of CPUs.
    3. Either prevent any new CPU online operation in between this lock-unlock, or
       ensure that the newly onlined CPU does not proceed with its corresponding
       per-cpu spinlock unlocked.
    
    To achieve all this:
    (a) We introduce a new spinlock that is taken by the *_global_lock_online()
        routine and released by the *_global_unlock_online() routine.
    (b) We register a callback for CPU hotplug notifications, and this callback
        takes the same spinlock as above.
    (c) We maintain a bitmap which is close to the cpu_online_mask, and once it is
        initialized in the lock_init() code, all future updates to it are done in
        the callback, under the above spinlock.
    (d) The above bitmap is used (instead of cpu_online_mask) while locking and
        unlocking the per-cpu locks.
    
    The callback takes the spinlock upon the CPU_UP_PREPARE event. So, if the
    br_write_lock-unlock sequence is in progress, the callback keeps spinning,
    thus preventing the CPU online operation till the lock-unlock sequence is
    complete. This takes care of requirement (3).
    
    The bitmap that we maintain remains unmodified throughout the lock-unlock
    sequence, since all updates to it are managed by the callback, which takes
    the same spinlock as the one taken by the lock code and released only by the
    unlock routine. Combining this with (d) above, satisfies requirement (2).
    
    Overall, since we use a spinlock (mentioned in (a)) to prevent CPU hotplug
    operations from racing with br_write_lock-unlock, requirement (1) is also
    taken care of.
    
    By the way, it is to be noted that a CPU offline operation can actually run
    in parallel with our lock-unlock sequence, because our callback doesn't react
    to notifications earlier than CPU_DEAD (in order to maintain our bitmap
    properly). And this means, since we use our own bitmap (which is stale, on
    purpose) during the lock-unlock sequence, we could end up unlocking the
    per-cpu lock of an offline CPU (because we had locked it earlier, when the
    CPU was online), in order to satisfy requirement (2). But this is harmless,
    though it looks a bit awkward.
    
    Debugged-by: Cong Meng <mc@linux.vnet.ibm.com>
    Signed-off-by: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 9837d8e982b7e87a7207f90618e45d460e196e6a
Author: Jan Kara <jack@suse.cz>
Date:   Wed Jan 4 22:03:11 2012 -0500

    jbd2: fix hung processes in jbd2_journal_lock_updates()
    
    Toshiyuki Okajima found out that when running
    
    for ((i=0; i < 100000; i++)); do
            if ((i%2 == 0)); then
                    chattr +j /mnt/file
            else
                    chattr -j /mnt/file
            fi
            echo "0" >> /mnt/file
    done
    
    process sometimes hangs indefinitely in jbd2_journal_lock_updates().
    
    Toshiyuki identified that the following race happens:
    
    jbd2_journal_lock_updates()            |jbd2_journal_stop()
    ---------------------------------------+---------------------------------------
     write_lock(&journal->j_state_lock)    |    .
     ++journal->j_barrier_count            |    .
     spin_lock(&tran->t_handle_lock)       |    .
     atomic_read(&tran->t_updates) //not 0 |
                                           | atomic_dec_and_test(&tran->t_updates)
                                           |    // t_updates = 0
                                           | wake_up(&journal->j_wait_updates)
     prepare_to_wait()                     |    // no process is woken up.
     spin_unlock(&tran->t_handle_lock)     |
     write_unlock(&journal->j_state_lock)  |
     schedule() // never return            |
    
    We fix the problem by first calling prepare_to_wait() and only after that
    checking t_updates in jbd2_journal_lock_updates().
    
    Reported-and-analyzed-by: Toshiyuki Okajima <toshi.okajima@jp.fujitsu.com>
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: "Theodore Ts'o" <tytso@mit.edu>

commit e30e2fdfe56288576ee9e04dbb06b4bd5f282203
Author: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
Date:   Thu Dec 22 02:45:29 2011 +0530

    VFS: Fix race between CPU hotplug and lglocks
    
    Currently, the *_global_[un]lock_online() routines are not at all synchronized
    with CPU hotplug. Soft-lockups detected as a consequence of this race was
    reported earlier at https://lkml.org/lkml/2011/8/24/185. (Thanks to Cong Meng
    for finding out that the root-cause of this issue is the race condition
    between br_write_[un]lock() and CPU hotplug, which results in the lock states
    getting messed up).
    
    Fixing this race by just adding {get,put}_online_cpus() at appropriate places
    in *_global_[un]lock_online() is not a good option, because, then suddenly
    br_write_[un]lock() would become blocking, whereas they have been kept as
    non-blocking all this time, and we would want to keep them that way.
    
    So, overall, we want to ensure 3 things:
    1. br_write_lock() and br_write_unlock() must remain as non-blocking.
    2. The corresponding lock and unlock of the per-cpu spinlocks must not happen
       for different sets of CPUs.
    3. Either prevent any new CPU online operation in between this lock-unlock, or
       ensure that the newly onlined CPU does not proceed with its corresponding
       per-cpu spinlock unlocked.
    
    To achieve all this:
    (a) We introduce a new spinlock that is taken by the *_global_lock_online()
        routine and released by the *_global_unlock_online() routine.
    (b) We register a callback for CPU hotplug notifications, and this callback
        takes the same spinlock as above.
    (c) We maintain a bitmap which is close to the cpu_online_mask, and once it is
        initialized in the lock_init() code, all future updates to it are done in
        the callback, under the above spinlock.
    (d) The above bitmap is used (instead of cpu_online_mask) while locking and
        unlocking the per-cpu locks.
    
    The callback takes the spinlock upon the CPU_UP_PREPARE event. So, if the
    br_write_lock-unlock sequence is in progress, the callback keeps spinning,
    thus preventing the CPU online operation till the lock-unlock sequence is
    complete. This takes care of requirement (3).
    
    The bitmap that we maintain remains unmodified throughout the lock-unlock
    sequence, since all updates to it are managed by the callback, which takes
    the same spinlock as the one taken by the lock code and released only by the
    unlock routine. Combining this with (d) above, satisfies requirement (2).
    
    Overall, since we use a spinlock (mentioned in (a)) to prevent CPU hotplug
    operations from racing with br_write_lock-unlock, requirement (1) is also
    taken care of.
    
    By the way, it is to be noted that a CPU offline operation can actually run
    in parallel with our lock-unlock sequence, because our callback doesn't react
    to notifications earlier than CPU_DEAD (in order to maintain our bitmap
    properly). And this means, since we use our own bitmap (which is stale, on
    purpose) during the lock-unlock sequence, we could end up unlocking the
    per-cpu lock of an offline CPU (because we had locked it earlier, when the
    CPU was online), in order to satisfy requirement (2). But this is harmless,
    though it looks a bit awkward.
    
    Debugged-by: Cong Meng <mc@linux.vnet.ibm.com>
    Signed-off-by: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Cc: stable@vger.kernel.org

commit 257058ae2b971646b96ab3a15605ac69186e562a
Author: Tejun Heo <tj@kernel.org>
Date:   Mon Dec 12 18:12:21 2011 -0800

    threadgroup: rename signal->threadgroup_fork_lock to ->group_rwsem
    
    Make the following renames to prepare for extension of threadgroup
    locking.
    
    * s/signal->threadgroup_fork_lock/signal->group_rwsem/
    * s/threadgroup_fork_read_lock()/threadgroup_change_begin()/
    * s/threadgroup_fork_read_unlock()/threadgroup_change_end()/
    * s/threadgroup_fork_write_lock()/threadgroup_lock()/
    * s/threadgroup_fork_write_unlock()/threadgroup_unlock()/
    
    This patch doesn't cause any behavior change.
    
    -v2: Rename threadgroup_change_done() to threadgroup_change_end() per
         KAMEZAWA's suggestion.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Reviewed-by: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
    Acked-by: Li Zefan <lizf@cn.fujitsu.com>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Paul Menage <paul@paulmenage.org>

commit c8efe8c2805748f93add31d0463252c57f27a0ab
Author: Mikael Pettersson <mikpe@it.uu.se>
Date:   Mon Aug 15 10:11:50 2011 +0000

    sparc32: unbreak arch_write_unlock()
    
    commit 3f6aa0b113846a8628baa649af422cfc6fb1d786 upstream.
    
    The sparc32 version of arch_write_unlock() is just a plain assignment.
    Unfortunately this allows the compiler to schedule side-effects in a
    protected region to occur after the HW-level unlock, which is broken.
    E.g., the following trivial test case gets miscompiled:
    
            #include <linux/spinlock.h>
            rwlock_t lock;
            int counter;
            void foo(void) { write_lock(&lock); ++counter; write_unlock(&lock); }
    
    Fixed by adding a compiler memory barrier to arch_write_unlock().  The
    sparc64 version combines the barrier and assignment into a single asm(),
    and implements the operation as a static inline, so that's what I did too.
    
    Compile-tested with sparc32_defconfig + CONFIG_SMP=y.
    
    Signed-off-by: Mikael Pettersson <mikpe@it.uu.se>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 7fe1e169829030a8257be59636f82c45753ca941
Author: Mikael Pettersson <mikpe@it.uu.se>
Date:   Mon Aug 15 10:11:50 2011 +0000

    sparc32: unbreak arch_write_unlock()
    
    commit 3f6aa0b113846a8628baa649af422cfc6fb1d786 upstream.
    
    The sparc32 version of arch_write_unlock() is just a plain assignment.
    Unfortunately this allows the compiler to schedule side-effects in a
    protected region to occur after the HW-level unlock, which is broken.
    E.g., the following trivial test case gets miscompiled:
    
            #include <linux/spinlock.h>
            rwlock_t lock;
            int counter;
            void foo(void) { write_lock(&lock); ++counter; write_unlock(&lock); }
    
    Fixed by adding a compiler memory barrier to arch_write_unlock().  The
    sparc64 version combines the barrier and assignment into a single asm(),
    and implements the operation as a static inline, so that's what I did too.
    
    Compile-tested with sparc32_defconfig + CONFIG_SMP=y.
    
    Signed-off-by: Mikael Pettersson <mikpe@it.uu.se>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit edb581110d04c70a4be5723ff8862a0f523657dd
Merge: 291b63c86aea 178a29600340
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Aug 15 19:16:01 2011 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/sparc
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/davem/sparc:
      sparc64: Set HAVE_C_RECORDMCOUNT
      sparc32: unbreak arch_write_unlock()
      sparc64: remove unnecessary macros from spinlock_64.h

commit 3f6aa0b113846a8628baa649af422cfc6fb1d786
Author: Mikael Pettersson <mikpe@it.uu.se>
Date:   Mon Aug 15 10:11:50 2011 +0000

    sparc32: unbreak arch_write_unlock()
    
    The sparc32 version of arch_write_unlock() is just a plain assignment.
    Unfortunately this allows the compiler to schedule side-effects in a
    protected region to occur after the HW-level unlock, which is broken.
    E.g., the following trivial test case gets miscompiled:
    
            #include <linux/spinlock.h>
            rwlock_t lock;
            int counter;
            void foo(void) { write_lock(&lock); ++counter; write_unlock(&lock); }
    
    Fixed by adding a compiler memory barrier to arch_write_unlock().  The
    sparc64 version combines the barrier and assignment into a single asm(),
    and implements the operation as a static inline, so that's what I did too.
    
    Compile-tested with sparc32_defconfig + CONFIG_SMP=y.
    
    Signed-off-by: Mikael Pettersson <mikpe@it.uu.se>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 83c67571b372c4a40023a84e183fdb7fa4e89e48
Author: Jiri Slaby <jslaby@suse.cz>
Date:   Wed Apr 20 10:43:18 2011 +0200

    TTY: tty_io, annotate locking functions
    
    tty_write_lock and tty_write_unlock contain imbalanced locking. But
    this is intentional, so mark them appropriately by
    __acquires/__releases.
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit c1a3a4b90a5a47adcca0e587f5d7e9ea61329b26
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Mon Nov 22 14:01:55 2010 -0200

    perf record: Handle restrictive permissions in /proc/{kallsyms,modules}
    
    The 59365d1 commit, even being reverted by 33e0d57, showed a non robust
    behavior in 'perf record': it really should just warn the user that some
    functionality will not be available.
    
    The new behavior then becomes:
    
            [acme@felicio linux]$ ls -la /proc/{kallsyms,modules}
            -r-------- 1 root root 0 Nov 22 12:19 /proc/kallsyms
            -r-------- 1 root root 0 Nov 22 12:19 /proc/modules
            [acme@felicio linux]$ perf record ls -R > /dev/null
            Couldn't record kernel reference relocation symbol
            Symbol resolution may be skewed if relocation was used (e.g. kexec).
            Check /proc/kallsyms permission or run as root.
            [ perf record: Woken up 1 times to write data ]
            [ perf record: Captured and wrote 0.004 MB perf.data (~161 samples) ]
            [acme@felicio linux]$ perf report --stdio
            [kernel.kallsyms] with build id 77b05e00e64e4de1c9347d83879779b540d69f00 not found, continuing without symbols
            # Events: 98  cycles
            #
            # Overhead  Command    Shared Object                Symbol
            # ........  .......  ...............  ....................
            #
                48.26%       ls  [kernel]         [k] ffffffff8102b92b
                22.49%       ls  libc-2.12.90.so  [.] __strlen_sse2
                 8.35%       ls  libc-2.12.90.so  [.] __GI___strcoll_l
                 8.17%       ls  ls               [.]            11580
                 3.35%       ls  libc-2.12.90.so  [.] _IO_new_file_xsputn
                 3.33%       ls  libc-2.12.90.so  [.] _int_malloc
                 1.88%       ls  libc-2.12.90.so  [.] _int_free
                 0.84%       ls  libc-2.12.90.so  [.] malloc_consolidate
                 0.84%       ls  libc-2.12.90.so  [.] __readdir64
                 0.83%       ls  ls               [.] strlen@plt
                 0.83%       ls  libc-2.12.90.so  [.] __GI_fwrite_unlocked
                 0.83%       ls  libc-2.12.90.so  [.] __memcpy_sse2
    
            #
            # (For a higher level overview, try: perf report --sort comm,dso)
            #
    [acme@felicio linux]$
    
    It still has the build-ids for DSOs in the maps with hits:
    
    [acme@felicio linux]$ perf buildid-list
    77b05e00e64e4de1c9347d83879779b540d69f00 [kernel.kallsyms]
    09c4a431a4a8b648fcfc2c2bdda70f56050ddff1 /bin/ls
    af75ea9ad951d25e0f038901a11b3846dccb29a4 /lib64/libc-2.12.90.so
    [acme@felicio linux]$
    
    That can be used in another machine to resolve kernel symbols.
    
    Cc: Eugene Teo <eugeneteo@kernel.org>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Jesper Juhl <jj@chaosbits.net>
    Cc: Marcus Meissner <meissner@suse.de>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Cc: Stephane Eranian <eranian@google.com>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Tom Zanussi <tzanussi@gmail.com>
    LKML-Reference: <new-submission>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

commit f064af1e500a2bf4607706f0f458163bdb2a6ea5
Author: Eric Dumazet <eric.dumazet@gmail.com>
Date:   Wed Sep 22 12:43:39 2010 +0000

    net: fix a lockdep splat
    
    We have for each socket :
    
    One spinlock (sk_slock.slock)
    One rwlock (sk_callback_lock)
    
    Possible scenarios are :
    
    (A) (this is used in net/sunrpc/xprtsock.c)
    read_lock(&sk->sk_callback_lock) (without blocking BH)
    <BH>
    spin_lock(&sk->sk_slock.slock);
    ...
    read_lock(&sk->sk_callback_lock);
    ...
    
    (B)
    write_lock_bh(&sk->sk_callback_lock)
    stuff
    write_unlock_bh(&sk->sk_callback_lock)
    
    (C)
    spin_lock_bh(&sk->sk_slock)
    ...
    write_lock_bh(&sk->sk_callback_lock)
    stuff
    write_unlock_bh(&sk->sk_callback_lock)
    spin_unlock_bh(&sk->sk_slock)
    
    This (C) case conflicts with (A) :
    
    CPU1 [A]                         CPU2 [C]
    read_lock(callback_lock)
    <BH>                             spin_lock_bh(slock)
    <wait to spin_lock(slock)>
                                     <wait to write_lock_bh(callback_lock)>
    
    We have one problematic (C) use case in inet_csk_listen_stop() :
    
    local_bh_disable();
    bh_lock_sock(child); // spin_lock_bh(&sk->sk_slock)
    WARN_ON(sock_owned_by_user(child));
    ...
    sock_orphan(child); // write_lock_bh(&sk->sk_callback_lock)
    
    lockdep is not happy with this, as reported by Tetsuo Handa
    
    It seems only way to deal with this is to use read_lock_bh(callbacklock)
    everywhere.
    
    Thanks to Jarek for pointing a bug in my first attempt and suggesting
    this solution.
    
    Reported-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
    Tested-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
    Signed-off-by: Eric Dumazet <eric.dumazet@gmail.com>
    CC: Jarek Poplawski <jarkao2@gmail.com>
    Tested-by: Eric Dumazet <eric.dumazet@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 71cd03b0044183843318bfac0b6ce5868a96ef34
Author: Julia Lawall <julia@diku.dk>
Date:   Mon Aug 2 16:04:21 2010 -0700

    arch/sparc/mm: Use GFP_KERNEL
    
    GFP_ATOMIC is not needed here, as evidenced by the other two uses of
    GFP_KERNEL in the same function.
    
    The semantic match that finds this problem is as follows:
    (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @@ identifier f; @@
    
    *f(...,GFP_ATOMIC,...)
    ... when != spin_unlock(...)
        when != read_unlock(...)
        when != write_unlock(...)
        when != read_unlock_irq(...)
        when != write_unlock_irq(...)
        when != read_unlock_irqrestore(...)
        when != write_unlock_irqrestore(...)
        when != spin_unlock_irq(...)
        when != spin_unlock_irqrestore(...)
    *f(...,GFP_KERNEL,...)
    // </smpl>
    
    Signed-off-by: Julia Lawall <julia@diku.dk>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit e2e0c7c9ddbe6b79fe647aca5eea3a405d38ada4
Author: Julia Lawall <julia@diku.dk>
Date:   Fri Jul 30 23:56:39 2010 +0000

    net/rose: Use GFP_ATOMIC
    
    The other calls to kmalloc in the same function use GFP_ATOMIC, and indeed
    two locks are held within the body of the function.
    
    The semantic match that finds this problem is as follows:
    (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @@ identifier f; @@
    
    *f(...,GFP_ATOMIC,...)
    ... when != spin_unlock(...)
        when != read_unlock(...)
        when != write_unlock(...)
        when != read_unlock_irq(...)
        when != write_unlock_irq(...)
        when != read_unlock_irqrestore(...)
        when != write_unlock_irqrestore(...)
        when != spin_unlock_irq(...)
        when != spin_unlock_irqrestore(...)
    *f(...,GFP_KERNEL,...)
    // </smpl>
    
    Signed-off-by: Julia Lawall <julia@diku.dk>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit d8b6569a31e9dfa66fc85afe79dc9b3aed48a1c7
Author: Toshiyuki Okajima <toshi.okajima@jp.fujitsu.com>
Date:   Fri Apr 30 14:32:13 2010 +0100

    KEYS: find_keyring_by_name() can gain access to a freed keyring
    
    commit cea7daa3589d6b550546a8c8963599f7c1a3ae5c upstream.
    
    find_keyring_by_name() can gain access to a keyring that has had its reference
    count reduced to zero, and is thus ready to be freed.  This then allows the
    dead keyring to be brought back into use whilst it is being destroyed.
    
    The following timeline illustrates the process:
    
    |(cleaner)                           (user)
    |
    | free_user(user)                    sys_keyctl()
    |  |                                  |
    |  key_put(user->session_keyring)     keyctl_get_keyring_ID()
    |  ||   //=> keyring->usage = 0        |
    |  |schedule_work(&key_cleanup_task)   lookup_user_key()
    |  ||                                   |
    |  kmem_cache_free(,user)               |
    |  .                                    |[KEY_SPEC_USER_KEYRING]
    |  .                                    install_user_keyrings()
    |  .                                    ||
    | key_cleanup() [<= worker_thread()]    ||
    |  |                                    ||
    |  [spin_lock(&key_serial_lock)]        |[mutex_lock(&key_user_keyr..mutex)]
    |  |                                    ||
    |  atomic_read() == 0                   ||
    |  |{ rb_ease(&key->serial_node,) }     ||
    |  |                                    ||
    |  [spin_unlock(&key_serial_lock)]      |find_keyring_by_name()
    |  |                                    |||
    |  keyring_destroy(keyring)             ||[read_lock(&keyring_name_lock)]
    |  ||                                   |||
    |  |[write_lock(&keyring_name_lock)]    ||atomic_inc(&keyring->usage)
    |  |.                                   ||| *** GET freeing keyring ***
    |  |.                                   ||[read_unlock(&keyring_name_lock)]
    |  ||                                   ||
    |  |list_del()                          |[mutex_unlock(&key_user_k..mutex)]
    |  ||                                   |
    |  |[write_unlock(&keyring_name_lock)]  ** INVALID keyring is returned **
    |  |                                    .
    |  kmem_cache_free(,keyring)            .
    |                                       .
    |                                       atomic_dec(&keyring->usage)
    v                                         *** DESTROYED ***
    TIME
    
    If CONFIG_SLUB_DEBUG=y then we may see the following message generated:
    
            =============================================================================
            BUG key_jar: Poison overwritten
            -----------------------------------------------------------------------------
    
            INFO: 0xffff880197a7e200-0xffff880197a7e200. First byte 0x6a instead of 0x6b
            INFO: Allocated in key_alloc+0x10b/0x35f age=25 cpu=1 pid=5086
            INFO: Freed in key_cleanup+0xd0/0xd5 age=12 cpu=1 pid=10
            INFO: Slab 0xffffea000592cb90 objects=16 used=2 fp=0xffff880197a7e200 flags=0x200000000000c3
            INFO: Object 0xffff880197a7e200 @offset=512 fp=0xffff880197a7e300
    
            Bytes b4 0xffff880197a7e1f0:  5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a ZZZZZZZZZZZZZZZZ
              Object 0xffff880197a7e200:  6a 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b jkkkkkkkkkkkkkkk
    
    Alternatively, we may see a system panic happen, such as:
    
            BUG: unable to handle kernel NULL pointer dereference at 0000000000000001
            IP: [<ffffffff810e61a3>] kmem_cache_alloc+0x5b/0xe9
            PGD 6b2b4067 PUD 6a80d067 PMD 0
            Oops: 0000 [#1] SMP
            last sysfs file: /sys/kernel/kexec_crash_loaded
            CPU 1
            ...
            Pid: 31245, comm: su Not tainted 2.6.34-rc5-nofixed-nodebug #2 D2089/PRIMERGY
            RIP: 0010:[<ffffffff810e61a3>]  [<ffffffff810e61a3>] kmem_cache_alloc+0x5b/0xe9
            RSP: 0018:ffff88006af3bd98  EFLAGS: 00010002
            RAX: 0000000000000000 RBX: 0000000000000001 RCX: ffff88007d19900b
            RDX: 0000000100000000 RSI: 00000000000080d0 RDI: ffffffff81828430
            RBP: ffffffff81828430 R08: ffff88000a293750 R09: 0000000000000000
            R10: 0000000000000001 R11: 0000000000100000 R12: 00000000000080d0
            R13: 00000000000080d0 R14: 0000000000000296 R15: ffffffff810f20ce
            FS:  00007f97116bc700(0000) GS:ffff88000a280000(0000) knlGS:0000000000000000
            CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
            CR2: 0000000000000001 CR3: 000000006a91c000 CR4: 00000000000006e0
            DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
            DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400
            Process su (pid: 31245, threadinfo ffff88006af3a000, task ffff8800374414c0)
            Stack:
             0000000512e0958e 0000000000008000 ffff880037f8d180 0000000000000001
             0000000000000000 0000000000008001 ffff88007d199000 ffffffff810f20ce
             0000000000008000 ffff88006af3be48 0000000000000024 ffffffff810face3
            Call Trace:
             [<ffffffff810f20ce>] ? get_empty_filp+0x70/0x12f
             [<ffffffff810face3>] ? do_filp_open+0x145/0x590
             [<ffffffff810ce208>] ? tlb_finish_mmu+0x2a/0x33
             [<ffffffff810ce43c>] ? unmap_region+0xd3/0xe2
             [<ffffffff810e4393>] ? virt_to_head_page+0x9/0x2d
             [<ffffffff81103916>] ? alloc_fd+0x69/0x10e
             [<ffffffff810ef4ed>] ? do_sys_open+0x56/0xfc
             [<ffffffff81008a02>] ? system_call_fastpath+0x16/0x1b
            Code: 0f 1f 44 00 00 49 89 c6 fa 66 0f 1f 44 00 00 65 4c 8b 04 25 60 e8 00 00 48 8b 45 00 49 01 c0 49 8b 18 48 85 db 74 0d 48 63 45 18 <48> 8b 04 03 49 89 00 eb 14 4c 89 f9 83 ca ff 44 89 e6 48 89 ef
            RIP  [<ffffffff810e61a3>] kmem_cache_alloc+0x5b/0xe9
    
    This problem is that find_keyring_by_name does not confirm that the keyring is
    valid before accepting it.
    
    Skipping keyrings that have been reduced to a zero count seems the way to go.
    To this end, use atomic_inc_not_zero() to increment the usage count and skip
    the candidate keyring if that returns false.
    
    The following script _may_ cause the bug to happen, but there's no guarantee
    as the window of opportunity is small:
    
            #!/bin/sh
            LOOP=100000
            USER=dummy_user
            /bin/su -c "exit;" $USER || { /usr/sbin/adduser -m $USER; add=1; }
            for ((i=0; i<LOOP; i++))
            do
                    /bin/su -c "echo '$i' > /dev/null" $USER
            done
            (( add == 1 )) && /usr/sbin/userdel -r $USER
            exit
    
    Note that the nominated user must not be in use.
    
    An alternative way of testing this may be:
    
            for ((i=0; i<100000; i++))
            do
                    keyctl session foo /bin/true || break
            done >&/dev/null
    
    as that uses a keyring named "foo" rather than relying on the user and
    user-session named keyrings.
    
    Reported-by: Toshiyuki Okajima <toshi.okajima@jp.fujitsu.com>
    Signed-off-by: David Howells <dhowells@redhat.com>
    Tested-by: Toshiyuki Okajima <toshi.okajima@jp.fujitsu.com>
    Acked-by: Serge Hallyn <serue@us.ibm.com>
    Signed-off-by: James Morris <jmorris@namei.org>
    Cc: Ben Hutchings <ben@decadent.org.uk>
    Cc: Chuck Ebbert <cebbert@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 48b97a01ba4d411047dad9abce933301699cdf25
Author: Toshiyuki Okajima <toshi.okajima@jp.fujitsu.com>
Date:   Fri Apr 30 14:32:13 2010 +0100

    KEYS: find_keyring_by_name() can gain access to a freed keyring
    
    commit cea7daa3589d6b550546a8c8963599f7c1a3ae5c upstream.
    
    find_keyring_by_name() can gain access to a keyring that has had its reference
    count reduced to zero, and is thus ready to be freed.  This then allows the
    dead keyring to be brought back into use whilst it is being destroyed.
    
    The following timeline illustrates the process:
    
    |(cleaner)                           (user)
    |
    | free_user(user)                    sys_keyctl()
    |  |                                  |
    |  key_put(user->session_keyring)     keyctl_get_keyring_ID()
    |  ||   //=> keyring->usage = 0        |
    |  |schedule_work(&key_cleanup_task)   lookup_user_key()
    |  ||                                   |
    |  kmem_cache_free(,user)               |
    |  .                                    |[KEY_SPEC_USER_KEYRING]
    |  .                                    install_user_keyrings()
    |  .                                    ||
    | key_cleanup() [<= worker_thread()]    ||
    |  |                                    ||
    |  [spin_lock(&key_serial_lock)]        |[mutex_lock(&key_user_keyr..mutex)]
    |  |                                    ||
    |  atomic_read() == 0                   ||
    |  |{ rb_ease(&key->serial_node,) }     ||
    |  |                                    ||
    |  [spin_unlock(&key_serial_lock)]      |find_keyring_by_name()
    |  |                                    |||
    |  keyring_destroy(keyring)             ||[read_lock(&keyring_name_lock)]
    |  ||                                   |||
    |  |[write_lock(&keyring_name_lock)]    ||atomic_inc(&keyring->usage)
    |  |.                                   ||| *** GET freeing keyring ***
    |  |.                                   ||[read_unlock(&keyring_name_lock)]
    |  ||                                   ||
    |  |list_del()                          |[mutex_unlock(&key_user_k..mutex)]
    |  ||                                   |
    |  |[write_unlock(&keyring_name_lock)]  ** INVALID keyring is returned **
    |  |                                    .
    |  kmem_cache_free(,keyring)            .
    |                                       .
    |                                       atomic_dec(&keyring->usage)
    v                                         *** DESTROYED ***
    TIME
    
    If CONFIG_SLUB_DEBUG=y then we may see the following message generated:
    
            =============================================================================
            BUG key_jar: Poison overwritten
            -----------------------------------------------------------------------------
    
            INFO: 0xffff880197a7e200-0xffff880197a7e200. First byte 0x6a instead of 0x6b
            INFO: Allocated in key_alloc+0x10b/0x35f age=25 cpu=1 pid=5086
            INFO: Freed in key_cleanup+0xd0/0xd5 age=12 cpu=1 pid=10
            INFO: Slab 0xffffea000592cb90 objects=16 used=2 fp=0xffff880197a7e200 flags=0x200000000000c3
            INFO: Object 0xffff880197a7e200 @offset=512 fp=0xffff880197a7e300
    
            Bytes b4 0xffff880197a7e1f0:  5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a ZZZZZZZZZZZZZZZZ
              Object 0xffff880197a7e200:  6a 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b jkkkkkkkkkkkkkkk
    
    Alternatively, we may see a system panic happen, such as:
    
            BUG: unable to handle kernel NULL pointer dereference at 0000000000000001
            IP: [<ffffffff810e61a3>] kmem_cache_alloc+0x5b/0xe9
            PGD 6b2b4067 PUD 6a80d067 PMD 0
            Oops: 0000 [#1] SMP
            last sysfs file: /sys/kernel/kexec_crash_loaded
            CPU 1
            ...
            Pid: 31245, comm: su Not tainted 2.6.34-rc5-nofixed-nodebug #2 D2089/PRIMERGY
            RIP: 0010:[<ffffffff810e61a3>]  [<ffffffff810e61a3>] kmem_cache_alloc+0x5b/0xe9
            RSP: 0018:ffff88006af3bd98  EFLAGS: 00010002
            RAX: 0000000000000000 RBX: 0000000000000001 RCX: ffff88007d19900b
            RDX: 0000000100000000 RSI: 00000000000080d0 RDI: ffffffff81828430
            RBP: ffffffff81828430 R08: ffff88000a293750 R09: 0000000000000000
            R10: 0000000000000001 R11: 0000000000100000 R12: 00000000000080d0
            R13: 00000000000080d0 R14: 0000000000000296 R15: ffffffff810f20ce
            FS:  00007f97116bc700(0000) GS:ffff88000a280000(0000) knlGS:0000000000000000
            CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
            CR2: 0000000000000001 CR3: 000000006a91c000 CR4: 00000000000006e0
            DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
            DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400
            Process su (pid: 31245, threadinfo ffff88006af3a000, task ffff8800374414c0)
            Stack:
             0000000512e0958e 0000000000008000 ffff880037f8d180 0000000000000001
             0000000000000000 0000000000008001 ffff88007d199000 ffffffff810f20ce
             0000000000008000 ffff88006af3be48 0000000000000024 ffffffff810face3
            Call Trace:
             [<ffffffff810f20ce>] ? get_empty_filp+0x70/0x12f
             [<ffffffff810face3>] ? do_filp_open+0x145/0x590
             [<ffffffff810ce208>] ? tlb_finish_mmu+0x2a/0x33
             [<ffffffff810ce43c>] ? unmap_region+0xd3/0xe2
             [<ffffffff810e4393>] ? virt_to_head_page+0x9/0x2d
             [<ffffffff81103916>] ? alloc_fd+0x69/0x10e
             [<ffffffff810ef4ed>] ? do_sys_open+0x56/0xfc
             [<ffffffff81008a02>] ? system_call_fastpath+0x16/0x1b
            Code: 0f 1f 44 00 00 49 89 c6 fa 66 0f 1f 44 00 00 65 4c 8b 04 25 60 e8 00 00 48 8b 45 00 49 01 c0 49 8b 18 48 85 db 74 0d 48 63 45 18 <48> 8b 04 03 49 89 00 eb 14 4c 89 f9 83 ca ff 44 89 e6 48 89 ef
            RIP  [<ffffffff810e61a3>] kmem_cache_alloc+0x5b/0xe9
    
    This problem is that find_keyring_by_name does not confirm that the keyring is
    valid before accepting it.
    
    Skipping keyrings that have been reduced to a zero count seems the way to go.
    To this end, use atomic_inc_not_zero() to increment the usage count and skip
    the candidate keyring if that returns false.
    
    The following script _may_ cause the bug to happen, but there's no guarantee
    as the window of opportunity is small:
    
            #!/bin/sh
            LOOP=100000
            USER=dummy_user
            /bin/su -c "exit;" $USER || { /usr/sbin/adduser -m $USER; add=1; }
            for ((i=0; i<LOOP; i++))
            do
                    /bin/su -c "echo '$i' > /dev/null" $USER
            done
            (( add == 1 )) && /usr/sbin/userdel -r $USER
            exit
    
    Note that the nominated user must not be in use.
    
    An alternative way of testing this may be:
    
            for ((i=0; i<100000; i++))
            do
                    keyctl session foo /bin/true || break
            done >&/dev/null
    
    as that uses a keyring named "foo" rather than relying on the user and
    user-session named keyrings.
    
    Reported-by: Toshiyuki Okajima <toshi.okajima@jp.fujitsu.com>
    Signed-off-by: David Howells <dhowells@redhat.com>
    Tested-by: Toshiyuki Okajima <toshi.okajima@jp.fujitsu.com>
    Acked-by: Serge Hallyn <serue@us.ibm.com>
    Signed-off-by: James Morris <jmorris@namei.org>
    Cc: Ben Hutchings <ben@decadent.org.uk>
    Cc: Chuck Ebbert <cebbert@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 8e3c5b14d0aa33e347569e53f42f874a83f426c5
Author: Toshiyuki Okajima <toshi.okajima@jp.fujitsu.com>
Date:   Fri Apr 30 14:32:13 2010 +0100

    KEYS: find_keyring_by_name() can gain access to a freed keyring
    
    commit cea7daa3589d6b550546a8c8963599f7c1a3ae5c upstream.
    
    find_keyring_by_name() can gain access to a keyring that has had its reference
    count reduced to zero, and is thus ready to be freed.  This then allows the
    dead keyring to be brought back into use whilst it is being destroyed.
    
    The following timeline illustrates the process:
    
    |(cleaner)                           (user)
    |
    | free_user(user)                    sys_keyctl()
    |  |                                  |
    |  key_put(user->session_keyring)     keyctl_get_keyring_ID()
    |  ||   //=> keyring->usage = 0        |
    |  |schedule_work(&key_cleanup_task)   lookup_user_key()
    |  ||                                   |
    |  kmem_cache_free(,user)               |
    |  .                                    |[KEY_SPEC_USER_KEYRING]
    |  .                                    install_user_keyrings()
    |  .                                    ||
    | key_cleanup() [<= worker_thread()]    ||
    |  |                                    ||
    |  [spin_lock(&key_serial_lock)]        |[mutex_lock(&key_user_keyr..mutex)]
    |  |                                    ||
    |  atomic_read() == 0                   ||
    |  |{ rb_ease(&key->serial_node,) }     ||
    |  |                                    ||
    |  [spin_unlock(&key_serial_lock)]      |find_keyring_by_name()
    |  |                                    |||
    |  keyring_destroy(keyring)             ||[read_lock(&keyring_name_lock)]
    |  ||                                   |||
    |  |[write_lock(&keyring_name_lock)]    ||atomic_inc(&keyring->usage)
    |  |.                                   ||| *** GET freeing keyring ***
    |  |.                                   ||[read_unlock(&keyring_name_lock)]
    |  ||                                   ||
    |  |list_del()                          |[mutex_unlock(&key_user_k..mutex)]
    |  ||                                   |
    |  |[write_unlock(&keyring_name_lock)]  ** INVALID keyring is returned **
    |  |                                    .
    |  kmem_cache_free(,keyring)            .
    |                                       .
    |                                       atomic_dec(&keyring->usage)
    v                                         *** DESTROYED ***
    TIME
    
    If CONFIG_SLUB_DEBUG=y then we may see the following message generated:
    
            =============================================================================
            BUG key_jar: Poison overwritten
            -----------------------------------------------------------------------------
    
            INFO: 0xffff880197a7e200-0xffff880197a7e200. First byte 0x6a instead of 0x6b
            INFO: Allocated in key_alloc+0x10b/0x35f age=25 cpu=1 pid=5086
            INFO: Freed in key_cleanup+0xd0/0xd5 age=12 cpu=1 pid=10
            INFO: Slab 0xffffea000592cb90 objects=16 used=2 fp=0xffff880197a7e200 flags=0x200000000000c3
            INFO: Object 0xffff880197a7e200 @offset=512 fp=0xffff880197a7e300
    
            Bytes b4 0xffff880197a7e1f0:  5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a ZZZZZZZZZZZZZZZZ
              Object 0xffff880197a7e200:  6a 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b jkkkkkkkkkkkkkkk
    
    Alternatively, we may see a system panic happen, such as:
    
            BUG: unable to handle kernel NULL pointer dereference at 0000000000000001
            IP: [<ffffffff810e61a3>] kmem_cache_alloc+0x5b/0xe9
            PGD 6b2b4067 PUD 6a80d067 PMD 0
            Oops: 0000 [#1] SMP
            last sysfs file: /sys/kernel/kexec_crash_loaded
            CPU 1
            ...
            Pid: 31245, comm: su Not tainted 2.6.34-rc5-nofixed-nodebug #2 D2089/PRIMERGY
            RIP: 0010:[<ffffffff810e61a3>]  [<ffffffff810e61a3>] kmem_cache_alloc+0x5b/0xe9
            RSP: 0018:ffff88006af3bd98  EFLAGS: 00010002
            RAX: 0000000000000000 RBX: 0000000000000001 RCX: ffff88007d19900b
            RDX: 0000000100000000 RSI: 00000000000080d0 RDI: ffffffff81828430
            RBP: ffffffff81828430 R08: ffff88000a293750 R09: 0000000000000000
            R10: 0000000000000001 R11: 0000000000100000 R12: 00000000000080d0
            R13: 00000000000080d0 R14: 0000000000000296 R15: ffffffff810f20ce
            FS:  00007f97116bc700(0000) GS:ffff88000a280000(0000) knlGS:0000000000000000
            CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
            CR2: 0000000000000001 CR3: 000000006a91c000 CR4: 00000000000006e0
            DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
            DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400
            Process su (pid: 31245, threadinfo ffff88006af3a000, task ffff8800374414c0)
            Stack:
             0000000512e0958e 0000000000008000 ffff880037f8d180 0000000000000001
             0000000000000000 0000000000008001 ffff88007d199000 ffffffff810f20ce
             0000000000008000 ffff88006af3be48 0000000000000024 ffffffff810face3
            Call Trace:
             [<ffffffff810f20ce>] ? get_empty_filp+0x70/0x12f
             [<ffffffff810face3>] ? do_filp_open+0x145/0x590
             [<ffffffff810ce208>] ? tlb_finish_mmu+0x2a/0x33
             [<ffffffff810ce43c>] ? unmap_region+0xd3/0xe2
             [<ffffffff810e4393>] ? virt_to_head_page+0x9/0x2d
             [<ffffffff81103916>] ? alloc_fd+0x69/0x10e
             [<ffffffff810ef4ed>] ? do_sys_open+0x56/0xfc
             [<ffffffff81008a02>] ? system_call_fastpath+0x16/0x1b
            Code: 0f 1f 44 00 00 49 89 c6 fa 66 0f 1f 44 00 00 65 4c 8b 04 25 60 e8 00 00 48 8b 45 00 49 01 c0 49 8b 18 48 85 db 74 0d 48 63 45 18 <48> 8b 04 03 49 89 00 eb 14 4c 89 f9 83 ca ff 44 89 e6 48 89 ef
            RIP  [<ffffffff810e61a3>] kmem_cache_alloc+0x5b/0xe9
    
    This problem is that find_keyring_by_name does not confirm that the keyring is
    valid before accepting it.
    
    Skipping keyrings that have been reduced to a zero count seems the way to go.
    To this end, use atomic_inc_not_zero() to increment the usage count and skip
    the candidate keyring if that returns false.
    
    The following script _may_ cause the bug to happen, but there's no guarantee
    as the window of opportunity is small:
    
            #!/bin/sh
            LOOP=100000
            USER=dummy_user
            /bin/su -c "exit;" $USER || { /usr/sbin/adduser -m $USER; add=1; }
            for ((i=0; i<LOOP; i++))
            do
                    /bin/su -c "echo '$i' > /dev/null" $USER
            done
            (( add == 1 )) && /usr/sbin/userdel -r $USER
            exit
    
    Note that the nominated user must not be in use.
    
    An alternative way of testing this may be:
    
            for ((i=0; i<100000; i++))
            do
                    keyctl session foo /bin/true || break
            done >&/dev/null
    
    as that uses a keyring named "foo" rather than relying on the user and
    user-session named keyrings.
    
    Reported-by: Toshiyuki Okajima <toshi.okajima@jp.fujitsu.com>
    Signed-off-by: David Howells <dhowells@redhat.com>
    Tested-by: Toshiyuki Okajima <toshi.okajima@jp.fujitsu.com>
    Acked-by: Serge Hallyn <serue@us.ibm.com>
    Signed-off-by: James Morris <jmorris@namei.org>
    Cc: Ben Hutchings <ben@decadent.org.uk>
    Cc: Chuck Ebbert <cebbert@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit cea7daa3589d6b550546a8c8963599f7c1a3ae5c
Author: Toshiyuki Okajima <toshi.okajima@jp.fujitsu.com>
Date:   Fri Apr 30 14:32:13 2010 +0100

    KEYS: find_keyring_by_name() can gain access to a freed keyring
    
    find_keyring_by_name() can gain access to a keyring that has had its reference
    count reduced to zero, and is thus ready to be freed.  This then allows the
    dead keyring to be brought back into use whilst it is being destroyed.
    
    The following timeline illustrates the process:
    
    |(cleaner)                           (user)
    |
    | free_user(user)                    sys_keyctl()
    |  |                                  |
    |  key_put(user->session_keyring)     keyctl_get_keyring_ID()
    |  ||   //=> keyring->usage = 0        |
    |  |schedule_work(&key_cleanup_task)   lookup_user_key()
    |  ||                                   |
    |  kmem_cache_free(,user)               |
    |  .                                    |[KEY_SPEC_USER_KEYRING]
    |  .                                    install_user_keyrings()
    |  .                                    ||
    | key_cleanup() [<= worker_thread()]    ||
    |  |                                    ||
    |  [spin_lock(&key_serial_lock)]        |[mutex_lock(&key_user_keyr..mutex)]
    |  |                                    ||
    |  atomic_read() == 0                   ||
    |  |{ rb_ease(&key->serial_node,) }     ||
    |  |                                    ||
    |  [spin_unlock(&key_serial_lock)]      |find_keyring_by_name()
    |  |                                    |||
    |  keyring_destroy(keyring)             ||[read_lock(&keyring_name_lock)]
    |  ||                                   |||
    |  |[write_lock(&keyring_name_lock)]    ||atomic_inc(&keyring->usage)
    |  |.                                   ||| *** GET freeing keyring ***
    |  |.                                   ||[read_unlock(&keyring_name_lock)]
    |  ||                                   ||
    |  |list_del()                          |[mutex_unlock(&key_user_k..mutex)]
    |  ||                                   |
    |  |[write_unlock(&keyring_name_lock)]  ** INVALID keyring is returned **
    |  |                                    .
    |  kmem_cache_free(,keyring)            .
    |                                       .
    |                                       atomic_dec(&keyring->usage)
    v                                         *** DESTROYED ***
    TIME
    
    If CONFIG_SLUB_DEBUG=y then we may see the following message generated:
    
            =============================================================================
            BUG key_jar: Poison overwritten
            -----------------------------------------------------------------------------
    
            INFO: 0xffff880197a7e200-0xffff880197a7e200. First byte 0x6a instead of 0x6b
            INFO: Allocated in key_alloc+0x10b/0x35f age=25 cpu=1 pid=5086
            INFO: Freed in key_cleanup+0xd0/0xd5 age=12 cpu=1 pid=10
            INFO: Slab 0xffffea000592cb90 objects=16 used=2 fp=0xffff880197a7e200 flags=0x200000000000c3
            INFO: Object 0xffff880197a7e200 @offset=512 fp=0xffff880197a7e300
    
            Bytes b4 0xffff880197a7e1f0:  5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a ZZZZZZZZZZZZZZZZ
              Object 0xffff880197a7e200:  6a 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b jkkkkkkkkkkkkkkk
    
    Alternatively, we may see a system panic happen, such as:
    
            BUG: unable to handle kernel NULL pointer dereference at 0000000000000001
            IP: [<ffffffff810e61a3>] kmem_cache_alloc+0x5b/0xe9
            PGD 6b2b4067 PUD 6a80d067 PMD 0
            Oops: 0000 [#1] SMP
            last sysfs file: /sys/kernel/kexec_crash_loaded
            CPU 1
            ...
            Pid: 31245, comm: su Not tainted 2.6.34-rc5-nofixed-nodebug #2 D2089/PRIMERGY
            RIP: 0010:[<ffffffff810e61a3>]  [<ffffffff810e61a3>] kmem_cache_alloc+0x5b/0xe9
            RSP: 0018:ffff88006af3bd98  EFLAGS: 00010002
            RAX: 0000000000000000 RBX: 0000000000000001 RCX: ffff88007d19900b
            RDX: 0000000100000000 RSI: 00000000000080d0 RDI: ffffffff81828430
            RBP: ffffffff81828430 R08: ffff88000a293750 R09: 0000000000000000
            R10: 0000000000000001 R11: 0000000000100000 R12: 00000000000080d0
            R13: 00000000000080d0 R14: 0000000000000296 R15: ffffffff810f20ce
            FS:  00007f97116bc700(0000) GS:ffff88000a280000(0000) knlGS:0000000000000000
            CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
            CR2: 0000000000000001 CR3: 000000006a91c000 CR4: 00000000000006e0
            DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
            DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400
            Process su (pid: 31245, threadinfo ffff88006af3a000, task ffff8800374414c0)
            Stack:
             0000000512e0958e 0000000000008000 ffff880037f8d180 0000000000000001
             0000000000000000 0000000000008001 ffff88007d199000 ffffffff810f20ce
             0000000000008000 ffff88006af3be48 0000000000000024 ffffffff810face3
            Call Trace:
             [<ffffffff810f20ce>] ? get_empty_filp+0x70/0x12f
             [<ffffffff810face3>] ? do_filp_open+0x145/0x590
             [<ffffffff810ce208>] ? tlb_finish_mmu+0x2a/0x33
             [<ffffffff810ce43c>] ? unmap_region+0xd3/0xe2
             [<ffffffff810e4393>] ? virt_to_head_page+0x9/0x2d
             [<ffffffff81103916>] ? alloc_fd+0x69/0x10e
             [<ffffffff810ef4ed>] ? do_sys_open+0x56/0xfc
             [<ffffffff81008a02>] ? system_call_fastpath+0x16/0x1b
            Code: 0f 1f 44 00 00 49 89 c6 fa 66 0f 1f 44 00 00 65 4c 8b 04 25 60 e8 00 00 48 8b 45 00 49 01 c0 49 8b 18 48 85 db 74 0d 48 63 45 18 <48> 8b 04 03 49 89 00 eb 14 4c 89 f9 83 ca ff 44 89 e6 48 89 ef
            RIP  [<ffffffff810e61a3>] kmem_cache_alloc+0x5b/0xe9
    
    This problem is that find_keyring_by_name does not confirm that the keyring is
    valid before accepting it.
    
    Skipping keyrings that have been reduced to a zero count seems the way to go.
    To this end, use atomic_inc_not_zero() to increment the usage count and skip
    the candidate keyring if that returns false.
    
    The following script _may_ cause the bug to happen, but there's no guarantee
    as the window of opportunity is small:
    
            #!/bin/sh
            LOOP=100000
            USER=dummy_user
            /bin/su -c "exit;" $USER || { /usr/sbin/adduser -m $USER; add=1; }
            for ((i=0; i<LOOP; i++))
            do
                    /bin/su -c "echo '$i' > /dev/null" $USER
            done
            (( add == 1 )) && /usr/sbin/userdel -r $USER
            exit
    
    Note that the nominated user must not be in use.
    
    An alternative way of testing this may be:
    
            for ((i=0; i<100000; i++))
            do
                    keyctl session foo /bin/true || break
            done >&/dev/null
    
    as that uses a keyring named "foo" rather than relying on the user and
    user-session named keyrings.
    
    Reported-by: Toshiyuki Okajima <toshi.okajima@jp.fujitsu.com>
    Signed-off-by: David Howells <dhowells@redhat.com>
    Tested-by: Toshiyuki Okajima <toshi.okajima@jp.fujitsu.com>
    Acked-by: Serge Hallyn <serue@us.ibm.com>
    Signed-off-by: James Morris <jmorris@namei.org>

commit 14d209ccb3a6eb7916f1d282e586afe8fd01b1dd
Author: Jeff Mahoney <jeffm@jeffreymahoney.com>
Date:   Mon Mar 29 15:12:39 2010 -0400

    reiserfs: Fix locking BUG during mount failure
    
    commit b7b7fa43103a9fb30dbcc60cbd5161fdfc25f904 upstream.
    
    Commit 8ebc423238341b52912c7295b045a32477b33f09 (reiserfs: kill-the-BKL)
    introduced a bug in the mount failure case.
    
    The error label releases the lock before calling journal_release_error,
    but it requires that the lock be held. do_journal_release unlocks and
    retakes it. When it releases it without it held, we trigger a BUG().
    
    The error_alloc label skips the unlock since the lock isn't held yet
    but none of the other conditions that are clean up exist yet either.
    
    This patch returns immediately after the kzalloc failure and moves
    the reiserfs_write_unlock after the journal_release_error call.
    
    This was reported in https://bugzilla.novell.com/show_bug.cgi?id=591807
    
    Reported-by:  Thomas Siedentopf <thomas.siedentopf@novell.com>
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Cc: Thomas Siedentopf <thomas.siedentopf@novell.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit f8e1d0803d2db9ef0116941a4ce46069a2009ea6
Author: Ming Lei <tom.leiming@gmail.com>
Date:   Tue Apr 13 00:29:27 2010 +0800

    ath9k-htc: fix lockdep warning and kernel warning after unplugging ar9271 usb device
    
    This patch fixes two warnings below after unplugging ar9271 usb device:
            -one is a kernel warning[1]
            -another is a lockdep warning[2]
    
    The root reason is that __skb_queue_purge can't be executed in hardirq
    context, so the patch forks ath9k_skb_queue_purge(ath9k version of _skb_queue_purge),
    which frees skb with dev_kfree_skb_any which can be run in hardirq
    context safely, then prevent the lockdep warning and kernel warning after
    unplugging ar9271 usb device.
    
    [1] kernel warning
    [  602.894005] ------------[ cut here ]------------
    [  602.894005] WARNING: at net/core/skbuff.c:398 skb_release_head_state+0x71/0x87()
    [  602.894005] Hardware name: 6475EK2
    [  602.894005] Modules linked in: ath9k_htc ath9k ath9k_common ath9k_hw ath bridge stp llc sunrpc ipv6 cpufreq_ondemand acpi_cpufreq freq_table kvm_intel kvm arc4 ecb mac80211 snd_hda_codec_conexant snd_hda_intel snd_hda_codec snd_hwdep thinkpad_acpi snd_pcm snd_timer hwmon iTCO_wdt snd e1000e pcspkr i2c_i801 usbhid iTCO_vendor_support wmi cfg80211 yenta_socket rsrc_nonstatic pata_acpi snd_page_alloc soundcore uhci_hcd ohci_hcd ehci_hcd usbcore i915 drm_kms_helper drm i2c_algo_bit i2c_core video output [last unloaded: ath]
    [  602.894005] Pid: 2506, comm: ping Tainted: G        W  2.6.34-rc3-wl #20
    [  602.894005] Call Trace:
    [  602.894005]  <IRQ>  [<ffffffff8104a41c>] warn_slowpath_common+0x7c/0x94
    [  602.894005]  [<ffffffffa022f398>] ? __skb_queue_purge+0x43/0x4a [ath9k_htc]
    [  602.894005]  [<ffffffff8104a448>] warn_slowpath_null+0x14/0x16
    [  602.894005]  [<ffffffff813269c1>] skb_release_head_state+0x71/0x87
    [  602.894005]  [<ffffffff8132829a>] __kfree_skb+0x16/0x81
    [  602.894005]  [<ffffffff813283b2>] kfree_skb+0x7e/0x86
    [  602.894005]  [<ffffffffa022f398>] __skb_queue_purge+0x43/0x4a [ath9k_htc]
    [  602.894005]  [<ffffffffa022f560>] __hif_usb_tx+0x1c1/0x21b [ath9k_htc]
    [  602.894005]  [<ffffffffa022f73c>] hif_usb_tx_cb+0x12f/0x154 [ath9k_htc]
    [  602.894005]  [<ffffffffa00d2fbe>] usb_hcd_giveback_urb+0x91/0xc5 [usbcore]
    [  602.894005]  [<ffffffffa00f6c34>] ehci_urb_done+0x7a/0x8b [ehci_hcd]
    [  602.894005]  [<ffffffffa00f6f33>] qh_completions+0x2ee/0x376 [ehci_hcd]
    [  602.894005]  [<ffffffffa00f8ba5>] ehci_work+0x95/0x76e [ehci_hcd]
    [  602.894005]  [<ffffffffa00fa5ae>] ? ehci_irq+0x2f/0x1d4 [ehci_hcd]
    [  602.894005]  [<ffffffffa00fa725>] ehci_irq+0x1a6/0x1d4 [ehci_hcd]
    [  602.894005]  [<ffffffff810a6d18>] ? __rcu_process_callbacks+0x7a/0x2df
    [  602.894005]  [<ffffffff810a47a4>] ? handle_fasteoi_irq+0x22/0xd2
    [  602.894005]  [<ffffffffa00d268d>] usb_hcd_irq+0x4a/0xa7 [usbcore]
    [  602.894005]  [<ffffffff810a2853>] handle_IRQ_event+0x77/0x14f
    [  602.894005]  [<ffffffff813285ce>] ? skb_release_data+0xc9/0xce
    [  602.894005]  [<ffffffff810a4814>] handle_fasteoi_irq+0x92/0xd2
    [  602.894005]  [<ffffffff8100c4fb>] handle_irq+0x88/0x91
    [  602.894005]  [<ffffffff8100baed>] do_IRQ+0x63/0xc9
    [  602.894005]  [<ffffffff81354245>] ? ip_flush_pending_frames+0x4d/0x5c
    [  602.894005]  [<ffffffff813ba993>] ret_from_intr+0x0/0x16
    [  602.894005]  <EOI>  [<ffffffff811095fe>] ? __delete_object+0x5a/0xb1
    [  602.894005]  [<ffffffff813ba5f5>] ? _raw_write_unlock_irqrestore+0x47/0x7e
    [  602.894005]  [<ffffffff813ba5fa>] ? _raw_write_unlock_irqrestore+0x4c/0x7e
    [  602.894005]  [<ffffffff811095fe>] __delete_object+0x5a/0xb1
    [  602.894005]  [<ffffffff81109814>] delete_object_full+0x25/0x31
    [  602.894005]  [<ffffffff813a60c0>] kmemleak_free+0x26/0x45
    [  602.894005]  [<ffffffff810ff517>] kfree+0xaa/0x149
    [  602.894005]  [<ffffffff81323fb7>] ? sock_def_write_space+0x84/0x89
    [  602.894005]  [<ffffffff81354245>] ? ip_flush_pending_frames+0x4d/0x5c
    [  602.894005]  [<ffffffff813285ce>] skb_release_data+0xc9/0xce
    [  602.894005]  [<ffffffff813282a2>] __kfree_skb+0x1e/0x81
    [  602.894005]  [<ffffffff813283b2>] kfree_skb+0x7e/0x86
    [  602.894005]  [<ffffffff81354245>] ip_flush_pending_frames+0x4d/0x5c
    [  602.894005]  [<ffffffff81370c1f>] raw_sendmsg+0x653/0x709
    [  602.894005]  [<ffffffff81379e31>] inet_sendmsg+0x54/0x5d
    [  602.894005]  [<ffffffff813207a2>] ? sock_recvmsg+0xc6/0xdf
    [  602.894005]  [<ffffffff813208c1>] sock_sendmsg+0xc0/0xd9
    [  602.894005]  [<ffffffff810e13b4>] ? might_fault+0x68/0xb8
    [  602.894005]  [<ffffffff810e13fd>] ? might_fault+0xb1/0xb8
    [  602.894005]  [<ffffffff8132a1c3>] ? copy_from_user+0x2f/0x31
    [  602.894005]  [<ffffffff8132a5b3>] ? verify_iovec+0x54/0x91
    [  602.894005]  [<ffffffff81320d41>] sys_sendmsg+0x1da/0x241
    [  602.894005]  [<ffffffff8103d327>] ? finish_task_switch+0x0/0xc9
    [  602.894005]  [<ffffffff8103d327>] ? finish_task_switch+0x0/0xc9
    [  602.894005]  [<ffffffff8107642e>] ? trace_hardirqs_on_caller+0x16/0x150
    [  602.894005]  [<ffffffff813ba27d>] ? _raw_spin_unlock_irq+0x56/0x63
    [  602.894005]  [<ffffffff8103d3cb>] ? finish_task_switch+0xa4/0xc9
    [  602.894005]  [<ffffffff8103d327>] ? finish_task_switch+0x0/0xc9
    [  602.894005]  [<ffffffff810357fe>] ? need_resched+0x23/0x2d
    [  602.894005]  [<ffffffff8107642e>] ? trace_hardirqs_on_caller+0x16/0x150
    [  602.894005]  [<ffffffff813b9750>] ? trace_hardirqs_on_thunk+0x3a/0x3f
    [  602.894005]  [<ffffffff81009c02>] system_call_fastpath+0x16/0x1b
    [  602.894005] ---[ end trace 91ba2d8dc7826839 ]---
    
    [2] lockdep warning
    [  169.363215] ======================================================
    [  169.365390] [ INFO: HARDIRQ-safe -> HARDIRQ-unsafe lock order detected ]
    [  169.366334] 2.6.34-rc3-wl #20
    [  169.366872] ------------------------------------------------------
    [  169.366872] khubd/78 [HC0[0]:SC0[0]:HE0:SE1] is trying to acquire:
    [  169.366872]  (clock-AF_INET){++.?..}, at: [<ffffffff81323f51>] sock_def_write_space+0x1e/0x89
    [  169.366872]
    [  169.366872] and this task is already holding:
    [  169.366872]  (&(&hif_dev->tx.tx_lock)->rlock){-.-...}, at: [<ffffffffa03715b0>] hif_usb_stop+0x24/0x53 [ath9k_htc]
    [  169.366872] which would create a new lock dependency:
    [  169.366872]  (&(&hif_dev->tx.tx_lock)->rlock){-.-...} -> (clock-AF_INET){++.?..}
    [  169.366872]
    [  169.366872] but this new dependency connects a HARDIRQ-irq-safe lock:
    [  169.366872]  (&(&hif_dev->tx.tx_lock)->rlock){-.-...}
    [  169.366872] ... which became HARDIRQ-irq-safe at:
    [  169.366872]   [<ffffffff810772d5>] __lock_acquire+0x2c6/0xd2b
    [  169.366872]   [<ffffffff8107866d>] lock_acquire+0xec/0x119
    [  169.366872]   [<ffffffff813b99bb>] _raw_spin_lock+0x40/0x73
    [  169.366872]   [<ffffffffa037163d>] hif_usb_tx_cb+0x5e/0x154 [ath9k_htc]
    [  169.366872]   [<ffffffffa00d2fbe>] usb_hcd_giveback_urb+0x91/0xc5 [usbcore]
    [  169.366872]   [<ffffffffa00f6c34>] ehci_urb_done+0x7a/0x8b [ehci_hcd]
    [  169.366872]   [<ffffffffa00f6f33>] qh_completions+0x2ee/0x376 [ehci_hcd]
    [  169.366872]   [<ffffffffa00f8ba5>] ehci_work+0x95/0x76e [ehci_hcd]
    [  169.366872]   [<ffffffffa00fa725>] ehci_irq+0x1a6/0x1d4 [ehci_hcd]
    [  169.366872]   [<ffffffffa00d268d>] usb_hcd_irq+0x4a/0xa7 [usbcore]
    [  169.366872]   [<ffffffff810a2853>] handle_IRQ_event+0x77/0x14f
    [  169.366872]   [<ffffffff810a4814>] handle_fasteoi_irq+0x92/0xd2
    [  169.366872]   [<ffffffff8100c4fb>] handle_irq+0x88/0x91
    [  169.366872]   [<ffffffff8100baed>] do_IRQ+0x63/0xc9
    [  169.366872]   [<ffffffff813ba993>] ret_from_intr+0x0/0x16
    [  169.366872]   [<ffffffff8130f6ee>] cpuidle_idle_call+0xa7/0x115
    [  169.366872]   [<ffffffff81008c4f>] cpu_idle+0x68/0xc4
    [  169.366872]   [<ffffffff813a41e0>] rest_init+0x104/0x10b
    [  169.366872]   [<ffffffff81899db3>] start_kernel+0x3f1/0x3fc
    [  169.366872]   [<ffffffff818992c8>] x86_64_start_reservations+0xb3/0xb7
    [  169.366872]   [<ffffffff818993c4>] x86_64_start_kernel+0xf8/0x107
    [  169.366872]
    [  169.366872] to a HARDIRQ-irq-unsafe lock:
    [  169.366872]  (clock-AF_INET){++.?..}
    [  169.366872] ... which became HARDIRQ-irq-unsafe at:
    [  169.366872] ...  [<ffffffff81077349>] __lock_acquire+0x33a/0xd2b
    [  169.366872]   [<ffffffff8107866d>] lock_acquire+0xec/0x119
    [  169.366872]   [<ffffffff813b9d07>] _raw_write_lock_bh+0x45/0x7a
    [  169.366872]   [<ffffffff8135cf14>] tcp_close+0x165/0x34d
    [  169.366872]   [<ffffffff8137aced>] inet_release+0x55/0x5c
    [  169.366872]   [<ffffffff81321350>] sock_release+0x1f/0x6e
    [  169.366872]   [<ffffffff813213c6>] sock_close+0x27/0x2b
    [  169.366872]   [<ffffffff8110dd45>] __fput+0x125/0x1ca
    [  169.366872]   [<ffffffff8110de04>] fput+0x1a/0x1c
    [  169.366872]   [<ffffffff8110adc9>] filp_close+0x68/0x72
    [  169.366872]   [<ffffffff8110ae80>] sys_close+0xad/0xe7
    [  169.366872]   [<ffffffff81009c02>] system_call_fastpath+0x16/0x1b
    
    (Trimmed at the "other info that might help us debug this" line in
    the interest of brevity... -- JWL)
    
    Signed-off-by: Ming Lei <tom.leiming@gmail.com>
    Acked-by: Sujith <Sujith.Manoharan@atheros.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

commit b7b7fa43103a9fb30dbcc60cbd5161fdfc25f904
Author: Jeff Mahoney <jeffm@jeffreymahoney.com>
Date:   Mon Mar 29 15:12:39 2010 -0400

    reiserfs: Fix locking BUG during mount failure
    
    Commit 8ebc423238341b52912c7295b045a32477b33f09 (reiserfs: kill-the-BKL)
    introduced a bug in the mount failure case.
    
    The error label releases the lock before calling journal_release_error,
    but it requires that the lock be held. do_journal_release unlocks and
    retakes it. When it releases it without it held, we trigger a BUG().
    
    The error_alloc label skips the unlock since the lock isn't held yet
    but none of the other conditions that are clean up exist yet either.
    
    This patch returns immediately after the kzalloc failure and moves
    the reiserfs_write_unlock after the journal_release_error call.
    
    This was reported in https://bugzilla.novell.com/show_bug.cgi?id=591807
    
    Reported-by:  Thomas Siedentopf <thomas.siedentopf@novell.com>
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Cc: Thomas Siedentopf <thomas.siedentopf@novell.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: 2.6.33.x <stable@kernel.org>
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>

commit b31aa5cccb9b5850135c07d8a0cb22984a5fe0f2
Author: Richard Rjfors <richard.rojfors@pelagicore.com>
Date:   Tue Feb 2 13:44:12 2010 -0800

    uartlite: fix crash when using as console
    
    commit 03eac7bb882a75e6ee5705288f7ec36ad2e7d0d5 upstream.
    
    Move the ulite_console_setup to the .devinit section since it might be
    called on probe, which is in devinit.  Fixes the crash below where the
    uartlite hw is probed after the .init section is freed from the kernel.
    
    uartlite: ttyUL0 at MMIO 0xc8000100 (irq = 30) is a uartlite
    BUG: unable to handle kernel NULL pointer dereference at (null)
    IP: [<c176720e>] ulite_console_setup+0x6f/0xa8
    *pdpt = 0000000036fb0001 *pde = 0000000000000000
    Oops: 0000 [#1] PREEMPT SMP
    last sysfs file: /sys/devices/pci0000:00/0000:00:1f.1/host0/uevent
    Modules linked in: puffin(+) serio_raw
    
    Pid: 151, comm: modprobe Not tainted (2.6.31.5-1.0.b1-b1 #1) POULSBO
    EIP: 0060:[<c176720e>] EFLAGS: 00010246 CPU: 0
    EIP is at ulite_console_setup+0x6f/0xa8
    EAX: c16ec824 EBX: c16ec824 ECX: c176719f EDX: 00000000
    ESI: 00000000 EDI: c17b42c4 EBP: f6fd1cf0 ESP: f6fd1cd8
     DS: 007b ES: 007b FS: 00d8 GS: 0033 SS: 0068
    Process modprobe (pid: 151, ti=f6fd0000 task=f6fa1020 task.ti=f6fd0000)
    Stack:
     c1031f51 00000000 00000000 00000246 c182237c f7742000 f6fd1d5c c11fd316
    <0> c16ec85c f77420d4 0000001e 00000000 00000000 c1633e78 4f494d4d 63783020
    <0> 30303038 00303031 f6fd1d3c c10e0786 f6fd1d48 00000000 f6fd1d48 00000000
    Call Trace:
     [<c1031f51>] ? register_console+0xf6/0x1fc
     [<c11fd316>] ? uart_add_one_port+0x237/0x2bb
     [<c10e0786>] ? sysfs_add_one+0x13/0xd3
     [<c10e142f>] ? sysfs_do_create_link+0xba/0xfc
     [<c146f200>] ? ulite_probe+0x198/0x1eb
     [<c12064ee>] ? platform_drv_probe+0xc/0xe
     [<c120597b>] ? driver_probe_device+0x79/0x105
     [<c1205a8e>] ? __device_attach+0x28/0x30
     [<c120511f>] ? bus_for_each_drv+0x3d/0x67
     [<c1205af9>] ? device_attach+0x44/0x58
     [<c1205a66>] ? __device_attach+0x0/0x30
     [<c1204fb8>] ? bus_probe_device+0x1f/0x34
     [<c1203e68>] ? device_add+0x385/0x4c0
     [<c148491f>] ? _write_unlock+0x8/0x1f
     [<c1206aac>] ? platform_device_add+0xd9/0x11c
     [<c120c685>] ? mfd_add_devices+0x165/0x1bc
     [<f831b378>] ? puffin_probe+0x2d0/0x390 [puffin]
     [<c11a08ef>] ? pci_match_device+0xa0/0xa7
     [<c11a07bc>] ? local_pci_probe+0xe/0x10
     [<c11a11db>] ? pci_device_probe+0x43/0x66
     [<c120597b>] ? driver_probe_device+0x79/0x105
     [<c1205a4a>] ? __driver_attach+0x43/0x5f
     [<c120535d>] ? bus_for_each_dev+0x3d/0x67
     [<c1205852>] ? driver_attach+0x14/0x16
     [<c1205a07>] ? __driver_attach+0x0/0x5f
     [<c1204dea>] ? bus_add_driver+0xf9/0x220
     [<c1205c8f>] ? driver_register+0x8b/0xeb
     [<c11a1518>] ? __pci_register_driver+0x43/0x9f
     [<c10477ef>] ? __blocking_notifier_call_chain+0x40/0x4c
     [<f831f000>] ? puffin_init+0x0/0x48 [puffin]
     [<f831f017>] ? puffin_init+0x17/0x48 [puffin]
     [<c1001139>] ? do_one_initcall+0x4c/0x131
     [<c105607b>] ? sys_init_module+0xa7/0x1b7
     [<c1002a61>] ? syscall_call+0x7/0xb
     Code: 6e 74 00 00 00 92 33 00 00 18 00 0e 01 73 79 6e 63 65 2d 72 65 67 69 73 74 72 79 0c 00 49 32
    00 00 14 00 09 01 61 6c 73 61 2d 69 <6e> 66 6f 00 00 00 42 37 00 00 10 00 07 01 6b 69 6c 6c 61 6c 6c
    EIP: [<c176720e>] ulite_console_setup+0x6f/0xa8 SS:ESP 0068:f6fd1cd8
    CR2: 0000000000000000
    
    Signed-off-by: Richard Rjfors <richard.rojfors@pelagicore.com>
    Acked-by: Peter Korsgaard <jacmet@sunsite.dk>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 03eac7bb882a75e6ee5705288f7ec36ad2e7d0d5
Author: Richard Rjfors <richard.rojfors@pelagicore.com>
Date:   Tue Feb 2 13:44:12 2010 -0800

    uartlite: fix crash when using as console
    
    Move the ulite_console_setup to the .devinit section since it might be
    called on probe, which is in devinit.  Fixes the crash below where the
    uartlite hw is probed after the .init section is freed from the kernel.
    
    uartlite: ttyUL0 at MMIO 0xc8000100 (irq = 30) is a uartlite
    BUG: unable to handle kernel NULL pointer dereference at (null)
    IP: [<c176720e>] ulite_console_setup+0x6f/0xa8
    *pdpt = 0000000036fb0001 *pde = 0000000000000000
    Oops: 0000 [#1] PREEMPT SMP
    last sysfs file: /sys/devices/pci0000:00/0000:00:1f.1/host0/uevent
    Modules linked in: puffin(+) serio_raw
    
    Pid: 151, comm: modprobe Not tainted (2.6.31.5-1.0.b1-b1 #1) POULSBO
    EIP: 0060:[<c176720e>] EFLAGS: 00010246 CPU: 0
    EIP is at ulite_console_setup+0x6f/0xa8
    EAX: c16ec824 EBX: c16ec824 ECX: c176719f EDX: 00000000
    ESI: 00000000 EDI: c17b42c4 EBP: f6fd1cf0 ESP: f6fd1cd8
     DS: 007b ES: 007b FS: 00d8 GS: 0033 SS: 0068
    Process modprobe (pid: 151, ti=f6fd0000 task=f6fa1020 task.ti=f6fd0000)
    Stack:
     c1031f51 00000000 00000000 00000246 c182237c f7742000 f6fd1d5c c11fd316
    <0> c16ec85c f77420d4 0000001e 00000000 00000000 c1633e78 4f494d4d 63783020
    <0> 30303038 00303031 f6fd1d3c c10e0786 f6fd1d48 00000000 f6fd1d48 00000000
    Call Trace:
     [<c1031f51>] ? register_console+0xf6/0x1fc
     [<c11fd316>] ? uart_add_one_port+0x237/0x2bb
     [<c10e0786>] ? sysfs_add_one+0x13/0xd3
     [<c10e142f>] ? sysfs_do_create_link+0xba/0xfc
     [<c146f200>] ? ulite_probe+0x198/0x1eb
     [<c12064ee>] ? platform_drv_probe+0xc/0xe
     [<c120597b>] ? driver_probe_device+0x79/0x105
     [<c1205a8e>] ? __device_attach+0x28/0x30
     [<c120511f>] ? bus_for_each_drv+0x3d/0x67
     [<c1205af9>] ? device_attach+0x44/0x58
     [<c1205a66>] ? __device_attach+0x0/0x30
     [<c1204fb8>] ? bus_probe_device+0x1f/0x34
     [<c1203e68>] ? device_add+0x385/0x4c0
     [<c148491f>] ? _write_unlock+0x8/0x1f
     [<c1206aac>] ? platform_device_add+0xd9/0x11c
     [<c120c685>] ? mfd_add_devices+0x165/0x1bc
     [<f831b378>] ? puffin_probe+0x2d0/0x390 [puffin]
     [<c11a08ef>] ? pci_match_device+0xa0/0xa7
     [<c11a07bc>] ? local_pci_probe+0xe/0x10
     [<c11a11db>] ? pci_device_probe+0x43/0x66
     [<c120597b>] ? driver_probe_device+0x79/0x105
     [<c1205a4a>] ? __driver_attach+0x43/0x5f
     [<c120535d>] ? bus_for_each_dev+0x3d/0x67
     [<c1205852>] ? driver_attach+0x14/0x16
     [<c1205a07>] ? __driver_attach+0x0/0x5f
     [<c1204dea>] ? bus_add_driver+0xf9/0x220
     [<c1205c8f>] ? driver_register+0x8b/0xeb
     [<c11a1518>] ? __pci_register_driver+0x43/0x9f
     [<c10477ef>] ? __blocking_notifier_call_chain+0x40/0x4c
     [<f831f000>] ? puffin_init+0x0/0x48 [puffin]
     [<f831f017>] ? puffin_init+0x17/0x48 [puffin]
     [<c1001139>] ? do_one_initcall+0x4c/0x131
     [<c105607b>] ? sys_init_module+0xa7/0x1b7
     [<c1002a61>] ? syscall_call+0x7/0xb
     Code: 6e 74 00 00 00 92 33 00 00 18 00 0e 01 73 79 6e 63 65 2d 72 65 67 69 73 74 72 79 0c 00 49 32
    00 00 14 00 09 01 61 6c 73 61 2d 69 <6e> 66 6f 00 00 00 42 37 00 00 10 00 07 01 6b 69 6c 6c 61 6c 6c
    EIP: [<c176720e>] ulite_console_setup+0x6f/0xa8 SS:ESP 0068:f6fd1cd8
    CR2: 0000000000000000
    
    Signed-off-by: Richard Rjfors <richard.rojfors@pelagicore.com>
    Acked-by: Peter Korsgaard <jacmet@sunsite.dk>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Cc: <stable@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit 846f99749ab68bbc7f75c74fec305de675b1a1bf
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Sat Jan 2 13:37:12 2010 -0800

    sysfs: Add lockdep annotations for the sysfs active reference
    
    Holding locks over device_del -> kobject_del -> sysfs_deactivate can
    cause deadlocks if those same locks are grabbed in sysfs show or store
    methods.
    
    The I model s_active count + completion as a sleeping read/write lock.
    I describe to lockdep sysfs_get_active as a read_trylock,
    sysfs_put_active as a read_unlock, and sysfs_deactivate as a
    write_lock and write_unlock pair.  This seems to capture the essence
    for purposes of finding deadlocks, and in my testing gives finds real
    issues and ignores non-issues.
    
    This brings us back to holding locks over kobject_del is a problem
    that ideally we should find a way of addressing, but at least lockdep
    can tell us about the problems instead of requiring developers to debug
    rare strange system deadlocks, that happen when sysfs files are removed
    while being written to.
    
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>
    Acked-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit 7e94277050e31aa4204060f03953bba72598cf7d
Author: Frederic Weisbecker <fweisbec@gmail.com>
Date:   Tue Aug 25 03:38:12 2009 +0200

    kill-the-bkl/reiserfs: fix recursive reiserfs write lock in reiserfs_commit_write()
    
    reiserfs_commit_write() is always called with the write lock held.
    Thus the current calls to reiserfs_write_lock() in this function are
    acquiring the lock recursively.
    We can safely drop them.
    
    This also solves further assumptions for this lock to be really
    released while calling reiserfs_write_unlock().
    
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Jeff Mahoney <jeffm@suse.com>
    Cc: Chris Mason <chris.mason@oracle.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Alexander Beregalov <a.beregalov@gmail.com>
    Cc: Laurent Riffard <laurent.riffard@free.fr>

commit c63e3c0b2498adec921b06c670d12c8c74b85538
Author: Frederic Weisbecker <fweisbec@gmail.com>
Date:   Fri May 8 20:01:09 2009 +0200

    kill-the-bkl/reiserfs: use mutex_lock in reiserfs_mutex_lock_safe
    
    reiserfs_mutex_lock_safe() is a hack to avoid any dependency between
    an internal reiserfs mutex and the write lock, it has been proposed
    to follow the old bkl logic.
    
    The code does the following:
    
    while (!mutex_trylock(m)) {
            reiserfs_write_unlock(s);
            schedule();
            reiserfs_write_lock(s);
    }
    
    It then imitate the implicit behaviour of the lock when it was
    a Bkl and hadn't such dependency:
    
    mutex_lock(m) {
            if (fastpath)
                    let's go
            else {
                    wait_for_mutex() {
                            schedule() {
                                    unlock_kernel()
                                    reacquire_lock_kernel()
                            }
                    }
            }
    }
    
    The problem is that by using such explicit schedule(), we don't
    benefit of the adaptive mutex spinning on owner.
    
    The logic in use now is:
    
    reiserfs_write_unlock(s);
    mutex_lock(m); // -> possible adaptive spinning
    reiserfs_write_lock(s);
    
    [ Impact: restore the use of adaptive spinning mutexes in reiserfs ]
    
    Cc: Jeff Mahoney <jeffm@suse.com>
    Cc: Chris Mason <chris.mason@oracle.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Alexander Beregalov <a.beregalov@gmail.com>
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>

commit daf88c898312a22b5385655bc6e0b064eaa2efba
Author: Frederic Weisbecker <fweisbec@gmail.com>
Date:   Tue Apr 14 05:34:23 2009 +0200

    kill-the-BKL/reiserfs: provide a tool to lock only once the write lock
    
    Sometimes we don't want to recursively hold the per superblock write
    lock because we want to be sure it is actually released when we come
    to sleep.
    
    This patch introduces the necessary tools for that.
    
    reiserfs_write_lock_once() does the same job than reiserfs_write_lock()
    except that it won't try to acquire recursively the lock if the current
    task already owns it. Also the lock_depth before the call of this function
    is returned.
    
    reiserfs_write_unlock_once() unlock only if reiserfs_write_lock_once()
    returned a depth equal to -1, ie: only if it actually locked.
    
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Alessio Igor Bogani <abogani@texware.it>
    Cc: Jeff Mahoney <jeffm@suse.com>
    Cc: Alexander Beregalov <a.beregalov@gmail.com>
    Cc: Chris Mason <chris.mason@oracle.com>
    LKML-Reference: <1239680065-25013-2-git-send-email-fweisbec@gmail.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

commit 5fbba42ae4b30f9eb2a4fd87d4599e3c4cde2137
Author: Zygo Blaxell <zygo.blaxell@xandros.com>
Date:   Tue Jun 16 15:33:57 2009 -0700

    lib/genalloc.c: remove unmatched write_lock() in gen_pool_destroy
    
    commit 8e8a2dea0ca91fe2cb7de7ea212124cfe8c82c35 upstream.
    
    There is a call to write_lock() in gen_pool_destroy which is not balanced
    by any corresponding write_unlock().  This causes problems with preemption
    because the preemption-disable counter is incremented in the write_lock()
    call, but never decremented by any call to write_unlock().  This bug is
    gen_pool_destroy, and one of them is non-x86 arch-specific code.
    
    Signed-off-by: Zygo Blaxell <zygo.blaxell@xandros.com>
    Cc: Jiri Kosina <trivial@kernel.org>
    Cc: Steve Wise <swise@opengridcomputing.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 8e8a2dea0ca91fe2cb7de7ea212124cfe8c82c35
Author: Zygo Blaxell <zygo.blaxell@xandros.com>
Date:   Tue Jun 16 15:33:57 2009 -0700

    lib/genalloc.c: remove unmatched write_lock() in gen_pool_destroy
    
    There is a call to write_lock() in gen_pool_destroy which is not balanced
    by any corresponding write_unlock().  This causes problems with preemption
    because the preemption-disable counter is incremented in the write_lock()
    call, but never decremented by any call to write_unlock().  This bug is
    gen_pool_destroy, and one of them is non-x86 arch-specific code.
    
    Signed-off-by: Zygo Blaxell <zygo.blaxell@xandros.com>
    Cc: Jiri Kosina <trivial@kernel.org>
    Cc: Steve Wise <swise@opengridcomputing.com>
    Cc: <stable@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit e8e1abe92fd7ea9d823a3aaf81d10e2cba593b6b
Author: Steven Rostedt <srostedt@redhat.com>
Date:   Wed Dec 3 11:04:51 2008 -0500

    ftrace: fix race in function graph during fork
    
    Impact: graph tracer race/crash fix
    
    There is a nasy race in startup of a new process running the
    function graph tracer. In fork.c:
    
            total_forks++;
            spin_unlock(&current->sighand->siglock);
            write_unlock_irq(&tasklist_lock);
            ftrace_graph_init_task(p);
            proc_fork_connector(p);
            cgroup_post_fork(p);
            return p;
    
    The new task is free to run as soon as the tasklist_lock is released.
    This is before the ftrace_graph_init_task. If the task does run
    it will be using the same ret_stack and curr_ret_stack as the parent.
    This will cause crashes that are difficult to debug.
    
    This patch moves the ftrace_graph_init_task to just after the alloc_pid
    code. This fixes the above race.
    
    Signed-off-by: Steven Rostedt <srostedt@redhat.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

commit 9db66bdcc83749affe61c61eb8ff3cf08f42afec
Author: Eric Dumazet <dada1@cosmosbay.com>
Date:   Thu Nov 20 20:39:09 2008 -0800

    net: convert TCP/DCCP ehash rwlocks to spinlocks
    
    Now TCP & DCCP use RCU lookups, we can convert ehash rwlocks to spinlocks.
    
    /proc/net/tcp and other seq_file 'readers' can safely be converted to 'writers'.
    
    This should speedup writers, since spin_lock()/spin_unlock()
    only use one atomic operation instead of two for write_lock()/write_unlock()
    
    Signed-off-by: Eric Dumazet <dada1@cosmosbay.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 52fd8ca6ad4124c15952ded35cfcf6adbd7ae8d4
Author: Vegard Nossum <vegard.nossum@gmail.com>
Date:   Wed Jul 30 09:29:06 2008 -0700

    IB/ipath: Use unsigned long for irq flags
    
    A few functions in the ipath driver incorrectly use unsigned int to
    hold irq flags for spin_lock_irqsave().
    
    This patch was generated using the Coccinelle framework with the
    following semantic patch:
    
    The semantic patch I used was this:
    
    @@
    expression lock;
    identifier flags;
    expression subclass;
    @@
    
    - unsigned int flags;
    + unsigned long flags;
    
    ...
    
    <+...
    
    (
     spin_lock_irqsave(lock, flags)
    |
     _spin_lock_irqsave(lock)
    |
     spin_unlock_irqrestore(lock, flags)
    |
     _spin_unlock_irqrestore(lock, flags)
    |
     read_lock_irqsave(lock, flags)
    |
     _read_lock_irqsave(lock)
    |
     read_unlock_irqrestore(lock, flags)
    |
     _read_unlock_irqrestore(lock, flags)
    |
     write_lock_irqsave(lock, flags)
    |
     _write_lock_irqsave(lock)
    |
     write_unlock_irqrestore(lock, flags)
    |
     _write_unlock_irqrestore(lock, flags)
    |
     spin_lock_irqsave_nested(lock, flags, subclass)
    |
     _spin_lock_irqsave_nested(lock, subclass)
    |
     spin_unlock_irqrestore(lock, flags)
    |
     _spin_unlock_irqrestore(lock, flags)
    |
     _raw_spin_lock_flags(lock, flags)
    |
     __raw_spin_lock_flags(lock, flags)
    )
    
    ...+>
    
    Cc: Ralph Campbell <ralph.campbell@qlogic.com>
    Cc: Julia Lawall <julia@diku.dk>
    Cc: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Vegard Nossum <vegard.nossum@gmail.com>
    Signed-off-by: Roland Dreier <rolandd@cisco.com>

commit 77bbadd5ea893f364a0d1879723037678a03725c
Author: Vegard Nossum <vegard.nossum@gmail.com>
Date:   Tue Jul 29 13:31:47 2008 +0200

    PS3: gelic: use unsigned long for irqflags
    
    The semantic patch I used was this:
    
    @@
    expression lock;
    identifier flags;
    expression subclass;
    @@
    
    - unsigned int flags;
    + unsigned long flags;
    
    ...
    
    <+...
    
    (
     spin_lock_irqsave(lock, flags)
    |
     _spin_lock_irqsave(lock)
    |
     spin_unlock_irqrestore(lock, flags)
    |
     _spin_unlock_irqrestore(lock, flags)
    |
     read_lock_irqsave(lock, flags)
    |
     _read_lock_irqsave(lock)
    |
     read_unlock_irqrestore(lock, flags)
    |
     _read_unlock_irqrestore(lock, flags)
    |
     write_lock_irqsave(lock, flags)
    |
     _write_lock_irqsave(lock)
    |
     write_unlock_irqrestore(lock, flags)
    |
     _write_unlock_irqrestore(lock, flags)
    |
     spin_lock_irqsave_nested(lock, flags, subclass)
    |
     _spin_lock_irqsave_nested(lock, subclass)
    |
     spin_unlock_irqrestore(lock, flags)
    |
     _spin_unlock_irqrestore(lock, flags)
    |
     _raw_spin_lock_flags(lock, flags)
    |
     __raw_spin_lock_flags(lock, flags)
    )
    
    ...+>
    
    This patch was generated using the Coccinelle framework.
    
    Cc: Masakazu Mokuno <mokuno@sm.sony.co.jp>
    Cc: Julia Lawall <julia@diku.dk>
    Cc: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Vegard Nossum <vegard.nossum@gmail.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

commit 4dee959723e2bf3a0f9343a46841cd2f0029d424
Author: Pavel Emelyanov <xemul@openvz.org>
Date:   Mon Apr 14 00:44:52 2008 -0700

    [NETFILTER]: ipt_CLUSTERIP: fix race between clusterip_config_find_get and _entry_put
    
    Consider we are putting a clusterip_config entry with the "entries"
    count == 1, and on the other CPU there's a clusterip_config_find_get
    in progress:
    
    CPU1:                                                   CPU2:
    clusterip_config_entry_put:                             clusterip_config_find_get:
    if (atomic_dec_and_test(&c->entries)) {
            /* true */
                                                            read_lock_bh(&clusterip_lock);
                                                            c = __clusterip_config_find(clusterip);
                                                            /* found - it's still in list */
                                                            ...
                                                            atomic_inc(&c->entries);
                                                            read_unlock_bh(&clusterip_lock);
    
            write_lock_bh(&clusterip_lock);
            list_del(&c->list);
            write_unlock_bh(&clusterip_lock);
            ...
            dev_put(c->dev);
    
    Oops! We have an entry returned by the clusterip_config_find_get,
    which is a) not in list b) has a stale dev pointer.
    
    The problems will happen when the CPU2 will release the entry - it
    will remove it from the list for the 2nd time, thus spoiling it, and
    will put a stale dev pointer.
    
    The fix is to make atomic_dec_and_test under the clusterip_lock.
    
    Signed-off-by: Pavel Emelyanov <xemul@openvz.org>
    Signed-off-by: Patrick McHardy <kaber@trash.net>

commit 86e8dfc5603ed76917eed0a9dd9e85a1e1a8b162
Author: Martin Peschke <mp3@de.ibm.com>
Date:   Thu Nov 15 13:57:17 2007 +0100

    [SCSI] zfcp: fix cleanup of dismissed error recovery actions
    
    Calling zfcp_erp_strategy_check_action() after zfcp_erp_action_to_running()
    in zfcp_erp_strategy() might cause an unbalanced up() for erp_ready_sem,
    which makes the zfcp recovery fail somewhere along the way:
    
    erp thread processing erp_action:
    |
    |       someone waking up erp thread for erp_action
    |       |
    |       |               someone else dismissing erp_action:
    |       |               |
    V       V               V
    
            write_lock_irqsave(&adapter->erp_lock, flags);
            ...
            if (zfcp_erp_action_exists(erp_action) == ZFCP_ERP_ACTION_RUNNING) {
                    zfcp_erp_action_to_ready(erp_action);
                    up(&adapter->erp_ready_sem);    /* first up() for erp_action */
            }
            write_unlock_irqrestore(&adapter->erp_lock, flags);
    
    write_lock_irqsave(&adapter->erp_lock, flags);
    ...
    zfcp_erp_action_to_running(erp_action);
    write_unlock_restore(&adapter->erp_lock, flags);
    /* processing erp_action */
    
                            write_lock_irqsave(&adapter->erp_lock, flags);
                            ...
                            erp_action->status |= ZFCP_STATUS_ERP_DISMISSED;
                            if (zfcp_erp_action_exists(erp_action) ==
                                                    ZFCP_ERP_ACTION_RUNNING) {
                                    zfcp_erp_action_to_ready(erp_action);
                                    up(&adapter->erp_ready_sem);
                                    /* second, unbalanced up() for erp_action */
                            }
                            ...
                            write_unlock_restore(&adapter->erp_lock, flags);
    
    write_lock_irqsave(&adapter->erp_lock, flags);
    if (erp_action->status & ZFCP_STATUS_ERP_DISMISSED) {
            zfcp_erp_action_dequeue(erp_action);
            retval = ZFCP_ERP_DISMISSED;
    }
    ...
    write_unlock_restore(&adapter->erp_lock, flags);
    down(&adapter->erp_ready_sem);
    /* this down() is meant to balance the first up() */
    
    The erp thread must not dismiss an erp_action after moving that action to
    erp_running_head. Instead it should just go through the down() operation,
    which balances the first up(), and run through zfcp_erp_strategy one more
    time for the second up(), which eventually cleans up erp_action. Which
    is similar to the normal processing of an event for erp_action doing
    something asynchronously (e.g. waiting for the completion of an fsf_req).
    
    This only works if we make sure that a dismissed erp_action is passed to
    zfcp_erp_strategy() prior to the other action, which caused actions to be
    dismissed. Therefore the patch implements this rule: running actions go to
    the head of the ready list; new actions go to the tail of the ready list;
    the erp thread picks actions to be processed from the ready list's head.
    
    Signed-off-by: Martin Peschke <mp3@de.ibm.com>
    Acked-by: Swen Schillig <swen@vnet.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

commit 885be03b069131d242506f0f717d38659b2bdb6c
Author: Robin Getz <robin.getz@analog.com>
Date:   Mon Oct 29 17:20:41 2007 +0800

    Blackfin arch: fix bug: kernel prints out error message twice
    
    This fixes two things:
     - stop calling write_lock_irq/write_unlock_irq which can turn modify
       irq levels
     - don't calling mmput when handing exceptions - since this might_sleep,
       which does a rti, and leaves us in kernel space (irq15, rather
       than irq5).
    
    Signed-off-by: Robin Getz <robin.getz@analog.com>
    Signed-off-by: Bryan Wu <bryan.wu@analog.com>

commit 0ba239cc0ef0ebf9d38cd733754fcf657ae79b2b
Author: Oleg Nesterov <oleg@tv-sign.ru>
Date:   Thu Jun 15 20:11:43 2006 +0400

    [PATCH] run_posix_cpu_timers: remove a bogus BUG_ON() (CVE-2006-2445)
    
    do_exit() clears ->it_##clock##_expires, but nothing prevents
    another cpu to attach the timer to exiting process after that.
    arm_timer() tries to protect against this race, but the check
    is racy.
    
    After exit_notify() does 'write_unlock_irq(&tasklist_lock)' and
    before do_exit() calls 'schedule() local timer interrupt can find
    tsk->exit_state != 0. If that state was EXIT_DEAD (or another cpu
    does sys_wait4) interrupted task has ->signal == NULL.
    
    At this moment exiting task has no pending cpu timers, they were
    cleanuped in __exit_signal()->posix_cpu_timers_exit{,_group}(),
    so we can just return from irq.
    
    John Stultz recently confirmed this bug, see
    
            http://marc.theaimsgroup.com/?l=linux-kernel&m=115015841413687
    
    Signed-off-by: Oleg Nesterov <oleg@tv-sign.ru>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>
    Signed-off-by: Chris Wright <chrisw@sous-sol.org>

commit 30f1e3dd8c72abda343bcf415f7d8894a02b4290
Author: Oleg Nesterov <oleg@tv-sign.ru>
Date:   Thu Jun 15 20:11:43 2006 +0400

    [PATCH] run_posix_cpu_timers: remove a bogus BUG_ON()
    
    do_exit() clears ->it_##clock##_expires, but nothing prevents
    another cpu to attach the timer to exiting process after that.
    arm_timer() tries to protect against this race, but the check
    is racy.
    
    After exit_notify() does 'write_unlock_irq(&tasklist_lock)' and
    before do_exit() calls 'schedule() local timer interrupt can find
    tsk->exit_state != 0. If that state was EXIT_DEAD (or another cpu
    does sys_wait4) interrupted task has ->signal == NULL.
    
    At this moment exiting task has no pending cpu timers, they were
    cleanuped in __exit_signal()->posix_cpu_timers_exit{,_group}(),
    so we can just return from irq.
    
    John Stultz recently confirmed this bug, see
    
            http://marc.theaimsgroup.com/?l=linux-kernel&m=115015841413687
    
    Signed-off-by: Oleg Nesterov <oleg@tv-sign.ru>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

commit 8c4b8add83c93306b07d78469fd351dc462e4b66
Author: Paul Jackson <pj@sgi.com>
Date:   Mon Nov 28 13:44:05 2005 -0800

    [PATCH] cpuset fork locking fix
    
    Move the cpuset_fork() call below the write_unlock_irq call in
    kernel/fork.c copy_process().
    
    Since the cpuset-dual-semaphore-locking-overhaul.patch, the cpuset_fork()
    routine acquires task_lock(), so cannot be called while holding the
    tasklist_lock for write.
    
    Signed-off-by: Paul Jackson <pj@sgi.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

commit 3de463c7d9d58f8cf3395268230cb20a4c15bffa
Author: Oleg Nesterov <oleg@tv-sign.ru>
Date:   Mon Oct 24 14:34:03 2005 +0400

    [PATCH] posix-timers: remove false BUG_ON() from run_posix_cpu_timers()
    
    do_exit() clears ->it_##clock##_expires, but nothing prevents
    another cpu to attach the timer to exiting process after that.
    
    After exit_notify() does 'write_unlock_irq(&tasklist_lock)' and
    before do_exit() calls 'schedule() local timer interrupt can find
    tsk->exit_state != 0. If that state was EXIT_DEAD (or another cpu
    does sys_wait4) interrupted task has ->signal == NULL.
    
    At this moment exiting task has no pending cpu timers, they were cleaned
    up in __exit_signal()->posix_cpu_timers_exit{,_group}(), so we can just
    return from irq.
    
    Signed-off-by: Oleg Nesterov <oleg@tv-sign.ru>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

commit 99e56fc6ee51c66c0d248c6dea7a45d70e15604e
Author: Alexander Nyberg <alexn@telia.com>
Date:   Wed Sep 14 18:54:06 2005 +0200

    [PATCH] Fix fs/exec.c:788 (de_thread()) BUG_ON
    
    It turns out that the BUG_ON() in fs/exec.c: de_thread() is unreliable
    and can trigger due to the test itself being racy.
    
    de_thread() does
            while (atomic_read(&sig->count) > count) {
            }
            .....
            .....
            BUG_ON(!thread_group_empty(current));
    
    but release_task does
            write_lock_irq(&tasklist_lock)
            __exit_signal
                    (this is where atomic_dec(&sig->count) is run)
            __exit_sighand
            __unhash_process
                    takes write lock on tasklist_lock
                    remove itself out of PIDTYPE_TGID list
            write_unlock_irq(&tasklist_lock)
    
    so there's a clear (although small) window between the
    atomic_dec(&sig->count) and the actual PIDTYPE_TGID unhashing of the
    thread.
    
    And actually there is no need for all threads to have exited at this
    point, so we simply kill the BUG_ON.
    
    Big thanks to Marc Lehmann who provided the test-case.
    
    Fixes Bug 5170 (http://bugme.osdl.org/show_bug.cgi?id=5170)
    
    Signed-off-by: Alexander Nyberg <alexn@telia.com>
    Cc: Roland McGrath <roland@redhat.com>
    Cc: Andrew Morton <akpm@osdl.org>
    Cc: Ingo Molnar <mingo@elte.hu>
    Acked-by: Andi Kleen <ak@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>
    Signed-off-by: Chris Wright <chrisw@osdl.org>

commit fb085cf1d4294824571815d487daccc0609543f0
Author: Alexander Nyberg <alexn@telia.com>
Date:   Wed Sep 14 18:54:06 2005 +0200

    [PATCH] Fix fs/exec.c:788 (de_thread()) BUG_ON
    
    It turns out that the BUG_ON() in fs/exec.c: de_thread() is unreliable
    and can trigger due to the test itself being racy.
    
    de_thread() does
            while (atomic_read(&sig->count) > count) {
            }
            .....
            .....
            BUG_ON(!thread_group_empty(current));
    
    but release_task does
            write_lock_irq(&tasklist_lock)
            __exit_signal
                    (this is where atomic_dec(&sig->count) is run)
            __exit_sighand
            __unhash_process
                    takes write lock on tasklist_lock
                    remove itself out of PIDTYPE_TGID list
            write_unlock_irq(&tasklist_lock)
    
    so there's a clear (although small) window between the
    atomic_dec(&sig->count) and the actual PIDTYPE_TGID unhashing of the
    thread.
    
    And actually there is no need for all threads to have exited at this
    point, so we simply kill the BUG_ON.
    
    Big thanks to Marc Lehmann who provided the test-case.
    
    Fixes Bug 5170 (http://bugme.osdl.org/show_bug.cgi?id=5170)
    
    Signed-off-by: Alexander Nyberg <alexn@telia.com>
    Cc: Roland McGrath <roland@redhat.com>
    Cc: Andrew Morton <akpm@osdl.org>
    Cc: Ingo Molnar <mingo@elte.hu>
    Acked-by: Andi Kleen <ak@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

commit f521089158cd48a81b4d72e8e39da006dd79779b
Author: Christoph Lameter <clameter@sgi.com>
Date:   Fri Aug 5 08:02:00 2005 -0700

    [IA64] Spinlock optimizations
    
    1. Nontemporal store for spin unlock.
    
    A nontemporal store will not update the LRU setting for the cacheline. The
    cacheline with the lock may therefore be evicted faster from the cpu
    caches. Doing so may be useful since it increases the chance that the
    exclusive cache line has been evicted when another cpu is trying to
    acquire the lock.
    
    The time between dropping and reacquiring a lock on the same cpu is
    typically very small so the danger of the cacheline being
    evicted is negligible.
    
    2. Avoid semaphore operation in write_unlock and use nontemporal store
    
    write_lock uses a cmpxchg like the regular spin_lock but write_unlock uses
    clear_bit which requires a load and then a loop over a cmpxchg. The
    following patch makes write_unlock simply use a nontemporal store to clear
    the highest 8 bits. We will then still have the lower 3 bytes (24 bits)
    left to count the readers.
    
    Doing the byte store will reduce the number of possible readers from 2^31
    to 2^24 = 16 million.
    
    These patches were discussed already:
    
    http://marc.theaimsgroup.com/?t=111472054400001&r=1&w=2
    http://marc.theaimsgroup.com/?l=linux-ia64&m=111401837707849&w=2
    
    The nontemporal stores will only work using GCC. If a compiler is used
    that does not support inline asm then fallback C code is used. This
    will preserve the byte store but not be able to do the nontemporal stores.
    
    Signed-off-by: Christoph Lameter <clameter@sgi.com>
    Signed-off-by: Tony Luck <tony.luck@intel.com>
