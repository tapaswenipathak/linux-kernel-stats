commit 97e14ae082040b2a65c7cbf7f2a53c240cc805db
Author: Mel Gorman <mgorman@techsingularity.net>
Date:   Fri Dec 2 10:02:23 2022 +0000

    rtmutex: Add acquire semantics for rtmutex lock acquisition slow path
    
    commit 1c0908d8e441631f5b8ba433523cf39339ee2ba0 upstream.
    
    Jan Kara reported the following bug triggering on 6.0.5-rt14 running dbench
    on XFS on arm64.
    
     kernel BUG at fs/inode.c:625!
     Internal error: Oops - BUG: 0 [#1] PREEMPT_RT SMP
     CPU: 11 PID: 6611 Comm: dbench Tainted: G            E   6.0.0-rt14-rt+ #1
     pc : clear_inode+0xa0/0xc0
     lr : clear_inode+0x38/0xc0
     Call trace:
      clear_inode+0xa0/0xc0
      evict+0x160/0x180
      iput+0x154/0x240
      do_unlinkat+0x184/0x300
      __arm64_sys_unlinkat+0x48/0xc0
      el0_svc_common.constprop.4+0xe4/0x2c0
      do_el0_svc+0xac/0x100
      el0_svc+0x78/0x200
      el0t_64_sync_handler+0x9c/0xc0
      el0t_64_sync+0x19c/0x1a0
    
    It also affects 6.1-rc7-rt5 and affects a preempt-rt fork of 5.14 so this
    is likely a bug that existed forever and only became visible when ARM
    support was added to preempt-rt. The same problem does not occur on x86-64
    and he also reported that converting sb->s_inode_wblist_lock to
    raw_spinlock_t makes the problem disappear indicating that the RT spinlock
    variant is the problem.
    
    Which in turn means that RT mutexes on ARM64 and any other weakly ordered
    architecture are affected by this independent of RT.
    
    Will Deacon observed:
    
      "I'd be more inclined to be suspicious of the slowpath tbh, as we need to
       make sure that we have acquire semantics on all paths where the lock can
       be taken. Looking at the rtmutex code, this really isn't obvious to me
       -- for example, try_to_take_rt_mutex() appears to be able to return via
       the 'takeit' label without acquire semantics and it looks like we might
       be relying on the caller's subsequent _unlock_ of the wait_lock for
       ordering, but that will give us release semantics which aren't correct."
    
    Sebastian Andrzej Siewior prototyped a fix that does work based on that
    comment but it was a little bit overkill and added some fences that should
    not be necessary.
    
    The lock owner is updated with an IRQ-safe raw spinlock held, but the
    spin_unlock does not provide acquire semantics which are needed when
    acquiring a mutex.
    
    Adds the necessary acquire semantics for lock owner updates in the slow path
    acquisition and the waiter bit logic.
    
    It successfully completed 10 iterations of the dbench workload while the
    vanilla kernel fails on the first iteration.
    
    [ bigeasy@linutronix.de: Initial prototype fix ]
    
    Fixes: 700318d1d7b38 ("locking/rtmutex: Use acquire/release semantics")
    Fixes: 23f78d4a03c5 ("[PATCH] pi-futex: rt mutex core")
    Reported-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Mel Gorman <mgorman@techsingularity.net>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/20221202100223.6mevpbl7i6x5udfd@techsingularity.net
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 693e7e52a89a1de572bfef47ffae3644096df2f2
Author: Mel Gorman <mgorman@techsingularity.net>
Date:   Fri Dec 2 10:02:23 2022 +0000

    rtmutex: Add acquire semantics for rtmutex lock acquisition slow path
    
    commit 1c0908d8e441631f5b8ba433523cf39339ee2ba0 upstream.
    
    Jan Kara reported the following bug triggering on 6.0.5-rt14 running dbench
    on XFS on arm64.
    
     kernel BUG at fs/inode.c:625!
     Internal error: Oops - BUG: 0 [#1] PREEMPT_RT SMP
     CPU: 11 PID: 6611 Comm: dbench Tainted: G            E   6.0.0-rt14-rt+ #1
     pc : clear_inode+0xa0/0xc0
     lr : clear_inode+0x38/0xc0
     Call trace:
      clear_inode+0xa0/0xc0
      evict+0x160/0x180
      iput+0x154/0x240
      do_unlinkat+0x184/0x300
      __arm64_sys_unlinkat+0x48/0xc0
      el0_svc_common.constprop.4+0xe4/0x2c0
      do_el0_svc+0xac/0x100
      el0_svc+0x78/0x200
      el0t_64_sync_handler+0x9c/0xc0
      el0t_64_sync+0x19c/0x1a0
    
    It also affects 6.1-rc7-rt5 and affects a preempt-rt fork of 5.14 so this
    is likely a bug that existed forever and only became visible when ARM
    support was added to preempt-rt. The same problem does not occur on x86-64
    and he also reported that converting sb->s_inode_wblist_lock to
    raw_spinlock_t makes the problem disappear indicating that the RT spinlock
    variant is the problem.
    
    Which in turn means that RT mutexes on ARM64 and any other weakly ordered
    architecture are affected by this independent of RT.
    
    Will Deacon observed:
    
      "I'd be more inclined to be suspicious of the slowpath tbh, as we need to
       make sure that we have acquire semantics on all paths where the lock can
       be taken. Looking at the rtmutex code, this really isn't obvious to me
       -- for example, try_to_take_rt_mutex() appears to be able to return via
       the 'takeit' label without acquire semantics and it looks like we might
       be relying on the caller's subsequent _unlock_ of the wait_lock for
       ordering, but that will give us release semantics which aren't correct."
    
    Sebastian Andrzej Siewior prototyped a fix that does work based on that
    comment but it was a little bit overkill and added some fences that should
    not be necessary.
    
    The lock owner is updated with an IRQ-safe raw spinlock held, but the
    spin_unlock does not provide acquire semantics which are needed when
    acquiring a mutex.
    
    Adds the necessary acquire semantics for lock owner updates in the slow path
    acquisition and the waiter bit logic.
    
    It successfully completed 10 iterations of the dbench workload while the
    vanilla kernel fails on the first iteration.
    
    [ bigeasy@linutronix.de: Initial prototype fix ]
    
    Fixes: 700318d1d7b38 ("locking/rtmutex: Use acquire/release semantics")
    Fixes: 23f78d4a03c5 ("[PATCH] pi-futex: rt mutex core")
    Reported-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Mel Gorman <mgorman@techsingularity.net>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/20221202100223.6mevpbl7i6x5udfd@techsingularity.net
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 1c0908d8e441631f5b8ba433523cf39339ee2ba0
Author: Mel Gorman <mgorman@techsingularity.net>
Date:   Fri Dec 2 10:02:23 2022 +0000

    rtmutex: Add acquire semantics for rtmutex lock acquisition slow path
    
    Jan Kara reported the following bug triggering on 6.0.5-rt14 running dbench
    on XFS on arm64.
    
     kernel BUG at fs/inode.c:625!
     Internal error: Oops - BUG: 0 [#1] PREEMPT_RT SMP
     CPU: 11 PID: 6611 Comm: dbench Tainted: G            E   6.0.0-rt14-rt+ #1
     pc : clear_inode+0xa0/0xc0
     lr : clear_inode+0x38/0xc0
     Call trace:
      clear_inode+0xa0/0xc0
      evict+0x160/0x180
      iput+0x154/0x240
      do_unlinkat+0x184/0x300
      __arm64_sys_unlinkat+0x48/0xc0
      el0_svc_common.constprop.4+0xe4/0x2c0
      do_el0_svc+0xac/0x100
      el0_svc+0x78/0x200
      el0t_64_sync_handler+0x9c/0xc0
      el0t_64_sync+0x19c/0x1a0
    
    It also affects 6.1-rc7-rt5 and affects a preempt-rt fork of 5.14 so this
    is likely a bug that existed forever and only became visible when ARM
    support was added to preempt-rt. The same problem does not occur on x86-64
    and he also reported that converting sb->s_inode_wblist_lock to
    raw_spinlock_t makes the problem disappear indicating that the RT spinlock
    variant is the problem.
    
    Which in turn means that RT mutexes on ARM64 and any other weakly ordered
    architecture are affected by this independent of RT.
    
    Will Deacon observed:
    
      "I'd be more inclined to be suspicious of the slowpath tbh, as we need to
       make sure that we have acquire semantics on all paths where the lock can
       be taken. Looking at the rtmutex code, this really isn't obvious to me
       -- for example, try_to_take_rt_mutex() appears to be able to return via
       the 'takeit' label without acquire semantics and it looks like we might
       be relying on the caller's subsequent _unlock_ of the wait_lock for
       ordering, but that will give us release semantics which aren't correct."
    
    Sebastian Andrzej Siewior prototyped a fix that does work based on that
    comment but it was a little bit overkill and added some fences that should
    not be necessary.
    
    The lock owner is updated with an IRQ-safe raw spinlock held, but the
    spin_unlock does not provide acquire semantics which are needed when
    acquiring a mutex.
    
    Adds the necessary acquire semantics for lock owner updates in the slow path
    acquisition and the waiter bit logic.
    
    It successfully completed 10 iterations of the dbench workload while the
    vanilla kernel fails on the first iteration.
    
    [ bigeasy@linutronix.de: Initial prototype fix ]
    
    Fixes: 700318d1d7b38 ("locking/rtmutex: Use acquire/release semantics")
    Fixes: 23f78d4a03c5 ("[PATCH] pi-futex: rt mutex core")
    Reported-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Mel Gorman <mgorman@techsingularity.net>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/20221202100223.6mevpbl7i6x5udfd@techsingularity.net

commit 14d3eb66e16a55d279598c8ed7ae1ca85066ff5b
Merge: 4b28ba9eeab4 b539ce9f1a31
Author: Vlastimil Babka <vbabka@suse.cz>
Date:   Thu Nov 10 09:48:37 2022 +0100

    Merge branch 'slab/for-6.2/locking' into slab/for-next
    
    A patch from Jiri Kosina that makes SLAB's list_lock a raw_spinlock_t.
    While there are no plans to make SLAB actually compatible with
    PREEMPT_RT or any other future, it makes !PREEMPT_RT lockdep happy.

commit b4a5ea09b29371c2e6a10783faa3593428404343
Merge: b8321ed4a40c 022bb490c797
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Mar 31 12:10:42 2022 -0700

    Merge tag 'docs-5.18-2' of git://git.lwn.net/linux
    
    Pull more documentation updates from Jonathan Corbet:
     "Some late-arriving documentation improvements.
    
      This is mostly build-system fixes from Mauro and Akira; I also took
      the liberty of dropping in my 'messy diffstat' document"
    
    * tag 'docs-5.18-2' of git://git.lwn.net/linux:
      docs: Add a document on how to fix a messy diffstat
      docs: sphinx/requirements: Limit jinja2<3.1
      Documentation: kunit: Fix cross-referencing warnings
      scripts/kernel-doc: change the line number meta info
      scripts/get_abi: change the file/line number meta info
      docs: kernel_include.py: add sphinx build dependencies
      docs: kernel_abi.py: add sphinx build dependencies
      docs: kernel_feat.py: add build dependencies
      scripts/get_feat.pl: allow output the parsed file names
      docs: kfigure.py: Don't warn of missing PDF converter in 'make htmldocs'
      Documentation: Fix duplicate statement about raw_spinlock_t type

commit 8d6451b9a51b555be2c9a6c326a980b2de00741a
Author: Guilherme G. Piccoli <gpiccoli@igalia.com>
Date:   Mon Mar 21 11:41:33 2022 -0300

    Documentation: Fix duplicate statement about raw_spinlock_t type
    
    Unless it was duplicate on purpose, to emphasize that a raw_spinlock_t
    is always a spinning lock regardless of PREEMPT_RT or kernel config,
    it's a bit odd that this text is duplicate. So, this patch just clean
    it up, keeping the consistency with the other sections of the text.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Fixes: 919e9e6395cf ("Documentation: Add lock ordering and nesting documentation")
    Signed-off-by: Guilherme G. Piccoli <gpiccoli@igalia.com>
    Link: https://lore.kernel.org/r/20220321144133.49804-1-gpiccoli@igalia.com
    Signed-off-by: Jonathan Corbet <corbet@lwn.net>

commit b9fae6a47b8bcb397e6a482095431f6ba9648211
Author: Randy Dunlap <rdunlap@infradead.org>
Date:   Sat Feb 26 13:37:03 2022 -0800

    x86/PCI: Add #includes to asm/pci_x86.h
    
    <asm/pci_x86.h> uses raw_spinlock_t, __init, and EINVAL; #include the
    appropriate files to prevent build errors.
    
      ../arch/x86/include/asm/pci_x86.h:105:8: error: unknown type name ‘raw_spinlock_t’
      ../arch/x86/include/asm/pci_x86.h:141:20: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘dmi_check_pciprobe’
      ../arch/x86/include/asm/pci_x86.h:150:10: error: ‘EINVAL’ undeclared (first use in this function)
    
    Link: https://lore.kernel.org/r/20220226213703.24041-1-rdunlap@infradead.org
    Signed-off-by: Randy Dunlap <rdunlap@infradead.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Mark Brown <broonie@kernel.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Dave Hansen <dave.hansen@linux.intel.com>

commit 1170233f063de7eb9020344338966fd30afea7b6
Author: Iwona Winiarska <iwona.winiarska@intel.com>
Date:   Sat Dec 4 18:10:27 2021 +0100

    gpio: aspeed-sgpio: Convert aspeed_sgpio.lock to raw_spinlock
    
    [ Upstream commit ab39d6988dd53f354130438d8afa5596a2440fed ]
    
    The gpio-aspeed-sgpio driver implements an irq_chip which need to be
    invoked from hardirq context. Since spin_lock() can sleep with
    PREEMPT_RT, it is no longer legal to invoke it while interrupts are
    disabled.
    This also causes lockdep to complain about:
    [   25.919465] [ BUG: Invalid wait context ]
    because aspeed_sgpio.lock (spin_lock_t) is taken under irq_desc.lock
    (raw_spinlock_t).
    Let's use of raw_spinlock_t instead of spinlock_t.
    
    Signed-off-by: Iwona Winiarska <iwona.winiarska@intel.com>
    Signed-off-by: Bartosz Golaszewski <brgl@bgdev.pl>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 102dd8b25de70d91db4736b3e11b9a44308babd2
Author: Iwona Winiarska <iwona.winiarska@intel.com>
Date:   Sat Dec 4 18:10:26 2021 +0100

    gpio: aspeed: Convert aspeed_gpio.lock to raw_spinlock
    
    [ Upstream commit 61a7904b6ace99b1bde0d0e867fa3097f5c8cee2 ]
    
    The gpio-aspeed driver implements an irq_chip which need to be invoked
    from hardirq context. Since spin_lock() can sleep with PREEMPT_RT, it is
    no longer legal to invoke it while interrupts are disabled.
    This also causes lockdep to complain about:
    [    0.649797] [ BUG: Invalid wait context ]
    because aspeed_gpio.lock (spin_lock_t) is taken under irq_desc.lock
    (raw_spinlock_t).
    Let's use of raw_spinlock_t instead of spinlock_t.
    
    Signed-off-by: Iwona Winiarska <iwona.winiarska@intel.com>
    Signed-off-by: Bartosz Golaszewski <brgl@bgdev.pl>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 8bb1290e90504203c2909113e1af1828948b1b7a
Author: Iwona Winiarska <iwona.winiarska@intel.com>
Date:   Sat Dec 4 18:10:27 2021 +0100

    gpio: aspeed-sgpio: Convert aspeed_sgpio.lock to raw_spinlock
    
    [ Upstream commit ab39d6988dd53f354130438d8afa5596a2440fed ]
    
    The gpio-aspeed-sgpio driver implements an irq_chip which need to be
    invoked from hardirq context. Since spin_lock() can sleep with
    PREEMPT_RT, it is no longer legal to invoke it while interrupts are
    disabled.
    This also causes lockdep to complain about:
    [   25.919465] [ BUG: Invalid wait context ]
    because aspeed_sgpio.lock (spin_lock_t) is taken under irq_desc.lock
    (raw_spinlock_t).
    Let's use of raw_spinlock_t instead of spinlock_t.
    
    Signed-off-by: Iwona Winiarska <iwona.winiarska@intel.com>
    Signed-off-by: Bartosz Golaszewski <brgl@bgdev.pl>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit d9332eab23381364b70e13eb17e7bf0a709504c5
Author: Iwona Winiarska <iwona.winiarska@intel.com>
Date:   Sat Dec 4 18:10:26 2021 +0100

    gpio: aspeed: Convert aspeed_gpio.lock to raw_spinlock
    
    [ Upstream commit 61a7904b6ace99b1bde0d0e867fa3097f5c8cee2 ]
    
    The gpio-aspeed driver implements an irq_chip which need to be invoked
    from hardirq context. Since spin_lock() can sleep with PREEMPT_RT, it is
    no longer legal to invoke it while interrupts are disabled.
    This also causes lockdep to complain about:
    [    0.649797] [ BUG: Invalid wait context ]
    because aspeed_gpio.lock (spin_lock_t) is taken under irq_desc.lock
    (raw_spinlock_t).
    Let's use of raw_spinlock_t instead of spinlock_t.
    
    Signed-off-by: Iwona Winiarska <iwona.winiarska@intel.com>
    Signed-off-by: Bartosz Golaszewski <brgl@bgdev.pl>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 07ecabf15ad3bfcaaa7e3ee6d660cfce8018dc2a
Author: Iwona Winiarska <iwona.winiarska@intel.com>
Date:   Sat Dec 4 18:10:26 2021 +0100

    gpio: aspeed: Convert aspeed_gpio.lock to raw_spinlock
    
    [ Upstream commit 61a7904b6ace99b1bde0d0e867fa3097f5c8cee2 ]
    
    The gpio-aspeed driver implements an irq_chip which need to be invoked
    from hardirq context. Since spin_lock() can sleep with PREEMPT_RT, it is
    no longer legal to invoke it while interrupts are disabled.
    This also causes lockdep to complain about:
    [    0.649797] [ BUG: Invalid wait context ]
    because aspeed_gpio.lock (spin_lock_t) is taken under irq_desc.lock
    (raw_spinlock_t).
    Let's use of raw_spinlock_t instead of spinlock_t.
    
    Signed-off-by: Iwona Winiarska <iwona.winiarska@intel.com>
    Signed-off-by: Bartosz Golaszewski <brgl@bgdev.pl>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 2481ee0ce59cae61dcad426e659b0d24e10abe5e
Author: Iwona Winiarska <iwona.winiarska@intel.com>
Date:   Sat Dec 4 18:10:26 2021 +0100

    gpio: aspeed: Convert aspeed_gpio.lock to raw_spinlock
    
    [ Upstream commit 61a7904b6ace99b1bde0d0e867fa3097f5c8cee2 ]
    
    The gpio-aspeed driver implements an irq_chip which need to be invoked
    from hardirq context. Since spin_lock() can sleep with PREEMPT_RT, it is
    no longer legal to invoke it while interrupts are disabled.
    This also causes lockdep to complain about:
    [    0.649797] [ BUG: Invalid wait context ]
    because aspeed_gpio.lock (spin_lock_t) is taken under irq_desc.lock
    (raw_spinlock_t).
    Let's use of raw_spinlock_t instead of spinlock_t.
    
    Signed-off-by: Iwona Winiarska <iwona.winiarska@intel.com>
    Signed-off-by: Bartosz Golaszewski <brgl@bgdev.pl>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 361c81dbc58c8aa230e1f2d556045fa7bc3eb4a3
Author: Wander Lairson Costa <wander@redhat.com>
Date:   Mon Dec 20 16:28:27 2021 -0300

    blktrace: switch trace spinlock to a raw spinlock
    
    The running_trace_lock protects running_trace_list and is acquired
    within the tracepoint which implies disabled preemption. The spinlock_t
    typed lock can not be acquired with disabled preemption on PREEMPT_RT
    because it becomes a sleeping lock.
    The runtime of the tracepoint depends on the number of entries in
    running_trace_list and has no limit. The blk-tracer is considered debug
    code and higher latencies here are okay.
    
    Make running_trace_lock a raw_spinlock_t.
    
    Signed-off-by: Wander Lairson Costa <wander@redhat.com>
    Link: https://lore.kernel.org/r/20211220192827.38297-1-wander@redhat.com
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

commit ab39d6988dd53f354130438d8afa5596a2440fed
Author: Iwona Winiarska <iwona.winiarska@intel.com>
Date:   Sat Dec 4 18:10:27 2021 +0100

    gpio: aspeed-sgpio: Convert aspeed_sgpio.lock to raw_spinlock
    
    The gpio-aspeed-sgpio driver implements an irq_chip which need to be
    invoked from hardirq context. Since spin_lock() can sleep with
    PREEMPT_RT, it is no longer legal to invoke it while interrupts are
    disabled.
    This also causes lockdep to complain about:
    [   25.919465] [ BUG: Invalid wait context ]
    because aspeed_sgpio.lock (spin_lock_t) is taken under irq_desc.lock
    (raw_spinlock_t).
    Let's use of raw_spinlock_t instead of spinlock_t.
    
    Signed-off-by: Iwona Winiarska <iwona.winiarska@intel.com>
    Signed-off-by: Bartosz Golaszewski <brgl@bgdev.pl>

commit 61a7904b6ace99b1bde0d0e867fa3097f5c8cee2
Author: Iwona Winiarska <iwona.winiarska@intel.com>
Date:   Sat Dec 4 18:10:26 2021 +0100

    gpio: aspeed: Convert aspeed_gpio.lock to raw_spinlock
    
    The gpio-aspeed driver implements an irq_chip which need to be invoked
    from hardirq context. Since spin_lock() can sleep with PREEMPT_RT, it is
    no longer legal to invoke it while interrupts are disabled.
    This also causes lockdep to complain about:
    [    0.649797] [ BUG: Invalid wait context ]
    because aspeed_gpio.lock (spin_lock_t) is taken under irq_desc.lock
    (raw_spinlock_t).
    Let's use of raw_spinlock_t instead of spinlock_t.
    
    Signed-off-by: Iwona Winiarska <iwona.winiarska@intel.com>
    Signed-off-by: Bartosz Golaszewski <brgl@bgdev.pl>

commit 77993b595ada5731e513eb06a0f4bf4b9f1e9532
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Mon Nov 29 18:46:54 2021 +0100

    locking: Allow to include asm/spinlock_types.h from linux/spinlock_types_raw.h
    
    The printk header file includes ratelimit_types.h for its __ratelimit()
    based usage. It is required for the static initializer used in
    printk_ratelimited(). It uses a raw_spinlock_t and includes the
    spinlock_types.h.
    
    PREEMPT_RT substitutes spinlock_t with a rtmutex based implementation and so
    its spinlock_t implmentation (provided by spinlock_rt.h) includes rtmutex.h and
    atomic.h which leads to recursive includes where defines are missing.
    
    By including only the raw_spinlock_t defines it avoids the atomic.h
    related includes at this stage.
    
    An example on powerpc:
    
    |  CALL    scripts/atomic/check-atomics.sh
    |In file included from include/linux/bug.h:5,
    |                 from include/linux/page-flags.h:10,
    |                 from kernel/bounds.c:10:
    |arch/powerpc/include/asm/page_32.h: In function âclear_pageâ:
    |arch/powerpc/include/asm/bug.h:87:4: error: implicit declaration of function â=80=98__WARNâ=80=99 [-Werror=3Dimplicit-function-declaration]
    |   87 |    __WARN();    \
    |      |    ^~~~~~
    |arch/powerpc/include/asm/page_32.h:48:2: note: in expansion of macro âWARN_ONâ=99
    |   48 |  WARN_ON((unsigned long)addr & (L1_CACHE_BYTES - 1));
    |      |  ^~~~~~~
    |arch/powerpc/include/asm/bug.h:58:17: error: invalid application of âsizeofâ=99 to incomplete type âstruct bug_entryâ=99
    |   58 |     "i" (sizeof(struct bug_entry)), \
    |      |                 ^~~~~~
    |arch/powerpc/include/asm/bug.h:89:3: note: in expansion of macro âBUG_ENTRYâ=99
    |   89 |   BUG_ENTRY(PPC_TLNEI " %4, 0",   \
    |      |   ^~~~~~~~~
    |arch/powerpc/include/asm/page_32.h:48:2: note: in expansion of macro âWARN_ONâ=99
    |   48 |  WARN_ON((unsigned long)addr & (L1_CACHE_BYTES - 1));
    |      |  ^~~~~~~
    |In file included from arch/powerpc/include/asm/ptrace.h:298,
    |                 from arch/powerpc/include/asm/hw_irq.h:12,
    |                 from arch/powerpc/include/asm/irqflags.h:12,
    |                 from include/linux/irqflags.h:16,
    |                 from include/asm-generic/cmpxchg-local.h:6,
    |                 from arch/powerpc/include/asm/cmpxchg.h:526,
    |                 from arch/powerpc/include/asm/atomic.h:11,
    |                 from include/linux/atomic.h:7,
    |                 from include/linux/rwbase_rt.h:6,
    |                 from include/linux/rwlock_types.h:55,
    |                 from include/linux/spinlock_types.h:74,
    |                 from include/linux/ratelimit_types.h:7,
    |                 from include/linux/printk.h:10,
    |                 from include/asm-generic/bug.h:22,
    |                 from arch/powerpc/include/asm/bug.h:109,
    |                 from include/linux/bug.h:5,
    |                 from include/linux/page-flags.h:10,
    |                 from kernel/bounds.c:10:
    |include/linux/thread_info.h: In function â=80=98copy_overflowâ=80=99:
    |include/linux/thread_info.h:210:2: error: implicit declaration of function â=80=98WARNâ=80=99 [-Werror=3Dimplicit-function-declaration]
    |  210 |  WARN(1, "Buffer overflow detected (%d < %lu)!\n", size, count);
    |      |  ^~~~
    
    The WARN / BUG include pulls in printk.h and then ptrace.h expects WARN
    (from bug.h) which is not yet complete. Even hw_irq.h has WARN_ON()
    statements.
    
    On POWERPC64 there are missing atomic64 defines while building 32bit
    VDSO:
    |  VDSO32C arch/powerpc/kernel/vdso32/vgettimeofday.o
    |In file included from include/linux/atomic.h:80,
    |                 from include/linux/rwbase_rt.h:6,
    |                 from include/linux/rwlock_types.h:55,
    |                 from include/linux/spinlock_types.h:74,
    |                 from include/linux/ratelimit_types.h:7,
    |                 from include/linux/printk.h:10,
    |                 from include/linux/kernel.h:19,
    |                 from arch/powerpc/include/asm/page.h:11,
    |                 from arch/powerpc/include/asm/vdso/gettimeofday.h:5,
    |                 from include/vdso/datapage.h:137,
    |                 from lib/vdso/gettimeofday.c:5,
    |                 from <command-line>:
    |include/linux/atomic-arch-fallback.h: In function âarch_atomic64_incâ=99:
    |include/linux/atomic-arch-fallback.h:1447:2: error: implicit declaration of function âarch_atomic64_addâ; did you mean âarch_atomic_addâ? [-Werror=3Dimpl
    |icit-function-declaration]
    | 1447 |  arch_atomic64_add(1, v);
    |      |  ^~~~~~~~~~~~~~~~~
    |      |  arch_atomic_add
    
    The generic fallback is not included, atomics itself are not used. If
    kernel.h does not include printk.h then it comes later from the bug.h
    include.
    
    Allow asm/spinlock_types.h to be included from
    linux/spinlock_types_raw.h.
    
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Link: https://lkml.kernel.org/r/20211129174654.668506-12-bigeasy@linutronix.de

commit f4a79b7d8bd6171ce60902a5d3ef9badec397ab3
Author: Valentin Schneider <vschneid@redhat.com>
Date:   Wed Aug 11 21:14:31 2021 +0100

    PM: cpu: Make notifier chain use a raw_spinlock_t
    
    [ Upstream commit b2f6662ac08d0e7c25574ce53623c71bdae9dd78 ]
    
    Invoking atomic_notifier_chain_notify() requires acquiring a spinlock_t,
    which can block under CONFIG_PREEMPT_RT. Notifications for members of the
    cpu_pm notification chain will be issued by the idle task, which can never
    block.
    
    Making *all* atomic_notifiers use a raw_spinlock is too big of a hammer, as
    only notifications issued by the idle task are problematic.
    
    Special-case cpu_pm_notifier_chain by kludging a raw_notifier and
    raw_spinlock_t together, matching the atomic_notifier behavior with a
    raw_spinlock_t.
    
    Fixes: 70d932985757 ("notifier: Fix broken error handling pattern")
    Signed-off-by: Valentin Schneider <valentin.schneider@arm.com>
    Acked-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 2f20c3cb46d97e97ef72d29b4794a3072f0a2e17
Author: Valentin Schneider <vschneid@redhat.com>
Date:   Wed Aug 11 21:14:31 2021 +0100

    PM: cpu: Make notifier chain use a raw_spinlock_t
    
    [ Upstream commit b2f6662ac08d0e7c25574ce53623c71bdae9dd78 ]
    
    Invoking atomic_notifier_chain_notify() requires acquiring a spinlock_t,
    which can block under CONFIG_PREEMPT_RT. Notifications for members of the
    cpu_pm notification chain will be issued by the idle task, which can never
    block.
    
    Making *all* atomic_notifiers use a raw_spinlock is too big of a hammer, as
    only notifications issued by the idle task are problematic.
    
    Special-case cpu_pm_notifier_chain by kludging a raw_notifier and
    raw_spinlock_t together, matching the atomic_notifier behavior with a
    raw_spinlock_t.
    
    Fixes: 70d932985757 ("notifier: Fix broken error handling pattern")
    Signed-off-by: Valentin Schneider <valentin.schneider@arm.com>
    Acked-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 4b7874a32ec23cc4892e7c9ffac1dd8160ea3697
Author: Valentin Schneider <vschneid@redhat.com>
Date:   Wed Aug 11 21:14:31 2021 +0100

    PM: cpu: Make notifier chain use a raw_spinlock_t
    
    [ Upstream commit b2f6662ac08d0e7c25574ce53623c71bdae9dd78 ]
    
    Invoking atomic_notifier_chain_notify() requires acquiring a spinlock_t,
    which can block under CONFIG_PREEMPT_RT. Notifications for members of the
    cpu_pm notification chain will be issued by the idle task, which can never
    block.
    
    Making *all* atomic_notifiers use a raw_spinlock is too big of a hammer, as
    only notifications issued by the idle task are problematic.
    
    Special-case cpu_pm_notifier_chain by kludging a raw_notifier and
    raw_spinlock_t together, matching the atomic_notifier behavior with a
    raw_spinlock_t.
    
    Fixes: 70d932985757 ("notifier: Fix broken error handling pattern")
    Signed-off-by: Valentin Schneider <valentin.schneider@arm.com>
    Acked-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit cc09ee80c3b18ae1a897a30a17fe710b2b2f620a
Merge: 49832c819ab8 bd0e7491a931
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Sep 8 12:36:00 2021 -0700

    Merge tag 'mm-slub-5.15-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/vbabka/linux
    
    Pull SLUB updates from Vlastimil Babka:
     "SLUB: reduce irq disabled scope and make it RT compatible
    
      This series was initially inspired by Mel's pcplist local_lock
      rewrite, and also interest to better understand SLUB's locking and the
      new primitives and RT variants and implications. It makes SLUB
      compatible with PREEMPT_RT and generally more preemption-friendly,
      apparently without significant regressions, as the fast paths are not
      affected.
    
      The main changes to SLUB by this series:
    
       - irq disabling is now only done for minimum amount of time needed to
         protect the strict kmem_cache_cpu fields, and as part of spin lock,
         local lock and bit lock operations to make them irq-safe
    
       - SLUB is fully PREEMPT_RT compatible
    
      The series should now be sufficiently tested in both RT and !RT
      configs, mainly thanks to Mike.
    
      The RFC/v1 version also got basic performance screening by Mel that
      didn't show major regressions. Mike's testing with hackbench of v2 on
      !RT reported negligible differences [6]:
    
        virgin(ish) tip
        5.13.0.g60ab3ed-tip
                  7,320.67 msec task-clock                #    7.792 CPUs utilized            ( +-  0.31% )
                   221,215      context-switches          #    0.030 M/sec                    ( +-  3.97% )
                    16,234      cpu-migrations            #    0.002 M/sec                    ( +-  4.07% )
                    13,233      page-faults               #    0.002 M/sec                    ( +-  0.91% )
            27,592,205,252      cycles                    #    3.769 GHz                      ( +-  0.32% )
             8,309,495,040      instructions              #    0.30  insn per cycle           ( +-  0.37% )
             1,555,210,607      branches                  #  212.441 M/sec                    ( +-  0.42% )
                 5,484,209      branch-misses             #    0.35% of all branches          ( +-  2.13% )
    
                   0.93949 +- 0.00423 seconds time elapsed  ( +-  0.45% )
                   0.94608 +- 0.00384 seconds time elapsed  ( +-  0.41% ) (repeat)
                   0.94422 +- 0.00410 seconds time elapsed  ( +-  0.43% )
    
        5.13.0.g60ab3ed-tip +slub-local-lock-v2r3
                  7,343.57 msec task-clock                #    7.776 CPUs utilized            ( +-  0.44% )
                   223,044      context-switches          #    0.030 M/sec                    ( +-  3.02% )
                    16,057      cpu-migrations            #    0.002 M/sec                    ( +-  4.03% )
                    13,164      page-faults               #    0.002 M/sec                    ( +-  0.97% )
            27,684,906,017      cycles                    #    3.770 GHz                      ( +-  0.45% )
             8,323,273,871      instructions              #    0.30  insn per cycle           ( +-  0.28% )
             1,556,106,680      branches                  #  211.901 M/sec                    ( +-  0.31% )
                 5,463,468      branch-misses             #    0.35% of all branches          ( +-  1.33% )
    
                   0.94440 +- 0.00352 seconds time elapsed  ( +-  0.37% )
                   0.94830 +- 0.00228 seconds time elapsed  ( +-  0.24% ) (repeat)
                   0.93813 +- 0.00440 seconds time elapsed  ( +-  0.47% ) (repeat)
    
      RT configs showed some throughput regressions, but that's expected
      tradeoff for the preemption improvements through the RT mutex. It
      didn't prevent the v2 to be incorporated to the 5.13 RT tree [7],
      leading to testing exposure and bugfixes.
    
      Before the series, SLUB is lockless in both allocation and free fast
      paths, but elsewhere, it's disabling irqs for considerable periods of
      time - especially in allocation slowpath and the bulk allocation,
      where IRQs are re-enabled only when a new page from the page allocator
      is needed, and the context allows blocking. The irq disabled sections
      can then include deactivate_slab() which walks a full freelist and
      frees the slab back to page allocator or unfreeze_partials() going
      through a list of percpu partial slabs. The RT tree currently has some
      patches mitigating these, but we can do much better in mainline too.
    
      Patches 1-6 are straightforward improvements or cleanups that could
      exist outside of this series too, but are prerequsities.
    
      Patches 7-9 are also preparatory code changes without functional
      changes, but not so useful without the rest of the series.
    
      Patch 10 simplifies the fast paths on systems with preemption, based
      on (hopefully correct) observation that the current loops to verify
      tid are unnecessary.
    
      Patches 11-20 focus on reducing irq disabled scope in the allocation
      slowpath:
    
       - patch 11 moves disabling of irqs into ___slab_alloc() from its
         callers, which are the allocation slowpath, and bulk allocation.
         Instead these callers only disable preemption to stabilize the cpu.
    
       - The following patches then gradually reduce the scope of disabled
         irqs in ___slab_alloc() and the functions called from there. As of
         patch 14, the re-enabling of irqs based on gfp flags before calling
         the page allocator is removed from allocate_slab(). As of patch 17,
         it's possible to reach the page allocator (in case of existing
         slabs depleted) without disabling and re-enabling irqs a single
         time.
    
      Pathces 21-26 reduce the scope of disabled irqs in functions related
      to unfreezing percpu partial slab.
    
      Patch 27 is preparatory. Patch 28 is adopted from the RT tree and
      converts the flushing of percpu slabs on all cpus from using IPI to
      workqueue, so that the processing isn't happening with irqs disabled
      in the IPI handler. The flushing is not performance critical so it
      should be acceptable.
    
      Patch 29 also comes from RT tree and makes object_map_lock RT
      compatible.
    
      Patch 30 make slab_lock irq-safe on RT where we cannot rely on having
      irq disabled from the list_lock spin lock usage.
    
      Patch 31 changes kmem_cache_cpu->partial handling in put_cpu_partial()
      from cmpxchg loop to a short irq disabled section, which is used by
      all other code modifying the field. This addresses a theoretical race
      scenario pointed out by Jann, and makes the critical section safe wrt
      with RT local_lock semantics after the conversion in patch 35.
    
      Patch 32 changes preempt disable to migrate disable, so that the
      nested list_lock spinlock is safe to take on RT. Because
      migrate_disable() is a function call even on !RT, a small set of
      private wrappers is introduced to keep using the cheaper
      preempt_disable() on !PREEMPT_RT configurations. As of this patch,
      SLUB should be already compatible with RT's lock semantics.
    
      Finally, patch 33 changes irq disabled sections that protect
      kmem_cache_cpu fields in the slow paths, with a local lock. However on
      PREEMPT_RT it means the lockless fast paths can now preempt slow paths
      which don't expect that, so the local lock has to be taken also in the
      fast paths and they are no longer lockless. RT folks seem to not mind
      this tradeoff. The patch also updates the locking documentation in the
      file's comment"
    
    Mike Galbraith and Mel Gorman verified that their earlier testing
    observations still hold for the final series:
    
    Link: https://lore.kernel.org/lkml/89ba4f783114520c167cc915ba949ad2c04d6790.camel@gmx.de/
    Link: https://lore.kernel.org/lkml/20210907082010.GB3959@techsingularity.net/
    
    * tag 'mm-slub-5.15-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/vbabka/linux: (33 commits)
      mm, slub: convert kmem_cpu_slab protection to local_lock
      mm, slub: use migrate_disable() on PREEMPT_RT
      mm, slub: protect put_cpu_partial() with disabled irqs instead of cmpxchg
      mm, slub: make slab_lock() disable irqs with PREEMPT_RT
      mm: slub: make object_map_lock a raw_spinlock_t
      mm: slub: move flush_cpu_slab() invocations __free_slab() invocations out of IRQ context
      mm, slab: split out the cpu offline variant of flush_slab()
      mm, slub: don't disable irqs in slub_cpu_dead()
      mm, slub: only disable irq with spin_lock in __unfreeze_partials()
      mm, slub: separate detaching of partial list in unfreeze_partials() from unfreezing
      mm, slub: detach whole partial list at once in unfreeze_partials()
      mm, slub: discard slabs in unfreeze_partials() without irqs disabled
      mm, slub: move irq control into unfreeze_partials()
      mm, slub: call deactivate_slab() without disabling irqs
      mm, slub: make locking in deactivate_slab() irq-safe
      mm, slub: move reset of c->page and freelist out of deactivate_slab()
      mm, slub: stop disabling irqs around get_partial()
      mm, slub: check new pages with restored irqs
      mm, slub: validate slab from partial list or page allocator before making it cpu slab
      mm, slub: restore irqs around calling new_slab()
      ...

commit 94ef0304e2b8dc942f46c74a13841d6b61f61d2f
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Thu Jul 16 18:47:50 2020 +0200

    mm: slub: make object_map_lock a raw_spinlock_t
    
    The variable object_map is protected by object_map_lock. The lock is always
    acquired in debug code and within already atomic context
    
    Make object_map_lock a raw_spinlock_t.
    
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Vlastimil Babka <vbabka@suse.cz>

commit bf11b9a8e9a93c1fc0ebfc2929622d5cf7d43888
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Thu Sep 2 14:54:03 2021 -0700

    shmem: use raw_spinlock_t for ->stat_lock
    
    Each CPU has SHMEM_INO_BATCH inodes available in `->ino_batch' which is
    per-CPU.  Access here is serialized by disabling preemption.  If the pool
    is empty, it gets reloaded from `->next_ino'.  Access here is serialized
    by ->stat_lock which is a spinlock_t and can not be acquired with disabled
    preemption.
    
    One way around it would make per-CPU ino_batch struct containing the inode
    number a local_lock_t.
    
    Another solution is to promote ->stat_lock to a raw_spinlock_t.  The
    critical sections are short.  The mpol_put() must be moved outside of the
    critical section to avoid invoking the destructor with disabled
    preemption.
    
    Link: https://lkml.kernel.org/r/20210806142916.jdwkb5bx62q5fwfo@linutronix.de
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Acked-by: Hugh Dickins <hughd@google.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit 5cbba60596b1f32f637190ca9ed5b1acdadb852c
Merge: 9b2eacd8f046 fe583359ddf0
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Aug 31 13:21:58 2021 -0700

    Merge tag 'pm-5.15-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull power management updates from Rafael Wysocki:
     "These address some PCI device power management issues, add new
      hardware support to the RAPL power capping driver, add HWP guaranteed
      performance change notification support to the intel_pstate driver,
      replace deprecated CPU-hotplug functions in a few places, update CPU
      PM notifiers to use raw spinlocks, update the PM domains framework
      (new DT property support, Kconfig fix), do a couple of cleanups in
      code related to system sleep, and improve the energy model and the
      schedutil cpufreq governor.
    
      Specifics:
    
       - Address 3 PCI device power management issues (Rafael Wysocki).
    
       - Add Power Limit4 support for Alder Lake to the Intel RAPL power
         capping driver (Sumeet Pawnikar).
    
       - Add HWP guaranteed performance change notification support to the
         intel_pstate driver (Srinivas Pandruvada).
    
       - Replace deprecated CPU-hotplug functions in code related to power
         management (Sebastian Andrzej Siewior).
    
       - Update CPU PM notifiers to use raw spinlocks (Valentin Schneider).
    
       - Add support for 'required-opps' DT property to the generic power
         domains (genpd) framework and use this property for I2C on ARM64
         sc7180 (Rajendra Nayak).
    
       - Fix Kconfig issue related to genpd (Geert Uytterhoeven).
    
       - Increase energy calculation precision in the Energy Model (Lukasz
         Luba).
    
       - Fix kobject deletion in the exit code of the schedutil cpufreq
         governor (Kevin Hao).
    
       - Unmark some functions as kernel-doc in the PM core to avoid
         false-positive documentation build warnings (Randy Dunlap).
    
       - Check RTC features instead of ops in suspend_test Alexandre
         Belloni)"
    
    * tag 'pm-5.15-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm:
      PM: domains: Fix domain attach for CONFIG_PM_OPP=n
      powercap: Add Power Limit4 support for Alder Lake SoC
      cpufreq: intel_pstate: Process HWP Guaranteed change notification
      thermal: intel: Allow processing of HWP interrupt
      notifier: Remove atomic_notifier_call_chain_robust()
      PM: cpu: Make notifier chain use a raw_spinlock_t
      PM: sleep: unmark 'state' functions as kernel-doc
      arm64: dts: sc7180: Add required-opps for i2c
      PM: domains: Add support for 'required-opps' to set default perf state
      opp: Don't print an error if required-opps is missing
      cpufreq: schedutil: Use kobject release() method to free sugov_tunables
      PM: EM: Increase energy calculation precision
      PM: sleep: check RTC features instead of ops in suspend_test
      PM: sleep: s2idle: Replace deprecated CPU-hotplug functions
      cpufreq: Replace deprecated CPU-hotplug functions
      powercap: intel_rapl: Replace deprecated CPU-hotplug functions
      PCI: PM: Enable PME if it can be signaled from D3cold
      PCI: PM: Avoid forcing PCI_D0 for wakeup reasons inconsistently
      PCI: Use pci_update_current_state() in pci_enable_device_flags()

commit 88e9c0bf1ca38b11b48b97b5821a7ac99d42e825
Merge: 7ee5fd12e8ca d0e936adbd22 15538a20579f 7fcc17d0cb12
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Aug 30 19:25:13 2021 +0200

    Merge branches 'pm-cpufreq', 'pm-cpu' and 'pm-em'
    
    * pm-cpufreq:
      cpufreq: intel_pstate: Process HWP Guaranteed change notification
      thermal: intel: Allow processing of HWP interrupt
      cpufreq: schedutil: Use kobject release() method to free sugov_tunables
      cpufreq: Replace deprecated CPU-hotplug functions
    
    * pm-cpu:
      notifier: Remove atomic_notifier_call_chain_robust()
      PM: cpu: Make notifier chain use a raw_spinlock_t
    
    * pm-em:
      PM: EM: Increase energy calculation precision

commit a403abbdc715986760821e67731d60ff65bde4bd
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Sun Aug 15 23:28:16 2021 +0200

    locking/rtmutex: Prevent future include recursion hell
    
    rtmutex only needs raw_spinlock_t, but it includes spinlock_types.h, which
    is not a problem on an non RT enabled kernel.
    
    RT kernels substitute regular spinlocks with 'sleeping' spinlocks, which
    are based on rtmutexes, and therefore must be able to include rtmutex.h.
    
    Include <linux/spinlock_types_raw.h> instead.
    
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Link: https://lore.kernel.org/r/20210815211303.428224188@linutronix.de

commit b2f6662ac08d0e7c25574ce53623c71bdae9dd78
Author: Valentin Schneider <vschneid@redhat.com>
Date:   Wed Aug 11 21:14:31 2021 +0100

    PM: cpu: Make notifier chain use a raw_spinlock_t
    
    Invoking atomic_notifier_chain_notify() requires acquiring a spinlock_t,
    which can block under CONFIG_PREEMPT_RT. Notifications for members of the
    cpu_pm notification chain will be issued by the idle task, which can never
    block.
    
    Making *all* atomic_notifiers use a raw_spinlock is too big of a hammer, as
    only notifications issued by the idle task are problematic.
    
    Special-case cpu_pm_notifier_chain by kludging a raw_notifier and
    raw_spinlock_t together, matching the atomic_notifier behavior with a
    raw_spinlock_t.
    
    Fixes: 70d932985757 ("notifier: Fix broken error handling pattern")
    Signed-off-by: Valentin Schneider <valentin.schneider@arm.com>
    Acked-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 77de34b9f5029d68a47c00d9b462e425c546d679
Author: Luca Fancellu <luca.fancellu@arm.com>
Date:   Tue Apr 6 11:51:04 2021 +0100

    xen/evtchn: Change irq_info lock to raw_spinlock_t
    
    commit d120198bd5ff1d41808b6914e1eb89aff937415c upstream.
    
    Unmask operation must be called with interrupt disabled,
    on preempt_rt spin_lock_irqsave/spin_unlock_irqrestore
    don't disable/enable interrupts, so use raw_* implementation
    and change lock variable in struct irq_info from spinlock_t
    to raw_spinlock_t
    
    Cc: stable@vger.kernel.org
    Fixes: 25da4618af24 ("xen/events: don't unmask an event channel when an eoi is pending")
    Signed-off-by: Luca Fancellu <luca.fancellu@arm.com>
    Reviewed-by: Julien Grall <jgrall@amazon.com>
    Reviewed-by: Wei Liu <wei.liu@kernel.org>
    Link: https://lore.kernel.org/r/20210406105105.10141-1-luca.fancellu@arm.com
    Signed-off-by: Boris Ostrovsky <boris.ostrovsky@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit af48f1856d655a3abe9704f9e13532a21dd28ce3
Author: Luca Fancellu <luca.fancellu@arm.com>
Date:   Tue Apr 6 11:51:04 2021 +0100

    xen/evtchn: Change irq_info lock to raw_spinlock_t
    
    commit d120198bd5ff1d41808b6914e1eb89aff937415c upstream.
    
    Unmask operation must be called with interrupt disabled,
    on preempt_rt spin_lock_irqsave/spin_unlock_irqrestore
    don't disable/enable interrupts, so use raw_* implementation
    and change lock variable in struct irq_info from spinlock_t
    to raw_spinlock_t
    
    Cc: stable@vger.kernel.org
    Fixes: 25da4618af24 ("xen/events: don't unmask an event channel when an eoi is pending")
    Signed-off-by: Luca Fancellu <luca.fancellu@arm.com>
    Reviewed-by: Julien Grall <jgrall@amazon.com>
    Reviewed-by: Wei Liu <wei.liu@kernel.org>
    Link: https://lore.kernel.org/r/20210406105105.10141-1-luca.fancellu@arm.com
    Signed-off-by: Boris Ostrovsky <boris.ostrovsky@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit c9697faba3a144454d1f0aac47d27d150c0bc2cc
Author: Luca Fancellu <luca.fancellu@arm.com>
Date:   Tue Apr 6 11:51:04 2021 +0100

    xen/evtchn: Change irq_info lock to raw_spinlock_t
    
    commit d120198bd5ff1d41808b6914e1eb89aff937415c upstream.
    
    Unmask operation must be called with interrupt disabled,
    on preempt_rt spin_lock_irqsave/spin_unlock_irqrestore
    don't disable/enable interrupts, so use raw_* implementation
    and change lock variable in struct irq_info from spinlock_t
    to raw_spinlock_t
    
    Cc: stable@vger.kernel.org
    Fixes: 25da4618af24 ("xen/events: don't unmask an event channel when an eoi is pending")
    Signed-off-by: Luca Fancellu <luca.fancellu@arm.com>
    Reviewed-by: Julien Grall <jgrall@amazon.com>
    Reviewed-by: Wei Liu <wei.liu@kernel.org>
    Link: https://lore.kernel.org/r/20210406105105.10141-1-luca.fancellu@arm.com
    Signed-off-by: Boris Ostrovsky <boris.ostrovsky@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 108b525bc87a6c337cd6582dad04fe11716d28a0
Author: Luca Fancellu <luca.fancellu@arm.com>
Date:   Tue Apr 6 11:51:04 2021 +0100

    xen/evtchn: Change irq_info lock to raw_spinlock_t
    
    commit d120198bd5ff1d41808b6914e1eb89aff937415c upstream.
    
    Unmask operation must be called with interrupt disabled,
    on preempt_rt spin_lock_irqsave/spin_unlock_irqrestore
    don't disable/enable interrupts, so use raw_* implementation
    and change lock variable in struct irq_info from spinlock_t
    to raw_spinlock_t
    
    Cc: stable@vger.kernel.org
    Fixes: 25da4618af24 ("xen/events: don't unmask an event channel when an eoi is pending")
    Signed-off-by: Luca Fancellu <luca.fancellu@arm.com>
    Reviewed-by: Julien Grall <jgrall@amazon.com>
    Reviewed-by: Wei Liu <wei.liu@kernel.org>
    Link: https://lore.kernel.org/r/20210406105105.10141-1-luca.fancellu@arm.com
    Signed-off-by: Boris Ostrovsky <boris.ostrovsky@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 005c5afa9f8557b92df6708478bb2729f523af33
Author: Luca Fancellu <luca.fancellu@arm.com>
Date:   Tue Apr 6 11:51:04 2021 +0100

    xen/evtchn: Change irq_info lock to raw_spinlock_t
    
    commit d120198bd5ff1d41808b6914e1eb89aff937415c upstream.
    
    Unmask operation must be called with interrupt disabled,
    on preempt_rt spin_lock_irqsave/spin_unlock_irqrestore
    don't disable/enable interrupts, so use raw_* implementation
    and change lock variable in struct irq_info from spinlock_t
    to raw_spinlock_t
    
    Cc: stable@vger.kernel.org
    Fixes: 25da4618af24 ("xen/events: don't unmask an event channel when an eoi is pending")
    Signed-off-by: Luca Fancellu <luca.fancellu@arm.com>
    Reviewed-by: Julien Grall <jgrall@amazon.com>
    Reviewed-by: Wei Liu <wei.liu@kernel.org>
    Link: https://lore.kernel.org/r/20210406105105.10141-1-luca.fancellu@arm.com
    Signed-off-by: Boris Ostrovsky <boris.ostrovsky@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit a09acbb53934fab5ebfcf97e4f967327abd0c121
Author: Luca Fancellu <luca.fancellu@arm.com>
Date:   Tue Apr 6 11:51:04 2021 +0100

    xen/evtchn: Change irq_info lock to raw_spinlock_t
    
    commit d120198bd5ff1d41808b6914e1eb89aff937415c upstream.
    
    Unmask operation must be called with interrupt disabled,
    on preempt_rt spin_lock_irqsave/spin_unlock_irqrestore
    don't disable/enable interrupts, so use raw_* implementation
    and change lock variable in struct irq_info from spinlock_t
    to raw_spinlock_t
    
    Cc: stable@vger.kernel.org
    Fixes: 25da4618af24 ("xen/events: don't unmask an event channel when an eoi is pending")
    Signed-off-by: Luca Fancellu <luca.fancellu@arm.com>
    Reviewed-by: Julien Grall <jgrall@amazon.com>
    Reviewed-by: Wei Liu <wei.liu@kernel.org>
    Link: https://lore.kernel.org/r/20210406105105.10141-1-luca.fancellu@arm.com
    Signed-off-by: Boris Ostrovsky <boris.ostrovsky@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit df720c5687aeae1f99ded448d26893e288702ff3
Author: Luca Fancellu <luca.fancellu@arm.com>
Date:   Tue Apr 6 11:51:04 2021 +0100

    xen/evtchn: Change irq_info lock to raw_spinlock_t
    
    commit d120198bd5ff1d41808b6914e1eb89aff937415c upstream.
    
    Unmask operation must be called with interrupt disabled,
    on preempt_rt spin_lock_irqsave/spin_unlock_irqrestore
    don't disable/enable interrupts, so use raw_* implementation
    and change lock variable in struct irq_info from spinlock_t
    to raw_spinlock_t
    
    Cc: stable@vger.kernel.org
    Fixes: 25da4618af24 ("xen/events: don't unmask an event channel when an eoi is pending")
    Signed-off-by: Luca Fancellu <luca.fancellu@arm.com>
    Reviewed-by: Julien Grall <jgrall@amazon.com>
    Reviewed-by: Wei Liu <wei.liu@kernel.org>
    Link: https://lore.kernel.org/r/20210406105105.10141-1-luca.fancellu@arm.com
    Signed-off-by: Boris Ostrovsky <boris.ostrovsky@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 0b76088799cc8db1ea9c626e54e7bc65f605e65f
Merge: ccd6c35c72c7 d120198bd5ff
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Apr 9 09:58:42 2021 -0700

    Merge tag 'for-linus-5.12b-rc7-tag' of git://git.kernel.org/pub/scm/linux/kernel/git/xen/tip
    
    Pull xen fix from Juergen Gross:
     "A single fix of a 5.12 patch for the rather uncommon problem of
      running as a Xen guest with a real time kernel config"
    
    * tag 'for-linus-5.12b-rc7-tag' of git://git.kernel.org/pub/scm/linux/kernel/git/xen/tip:
      xen/evtchn: Change irq_info lock to raw_spinlock_t

commit d120198bd5ff1d41808b6914e1eb89aff937415c
Author: Luca Fancellu <luca.fancellu@arm.com>
Date:   Tue Apr 6 11:51:04 2021 +0100

    xen/evtchn: Change irq_info lock to raw_spinlock_t
    
    Unmask operation must be called with interrupt disabled,
    on preempt_rt spin_lock_irqsave/spin_unlock_irqrestore
    don't disable/enable interrupts, so use raw_* implementation
    and change lock variable in struct irq_info from spinlock_t
    to raw_spinlock_t
    
    Cc: stable@vger.kernel.org
    Fixes: 25da4618af24 ("xen/events: don't unmask an event channel when an eoi is pending")
    Signed-off-by: Luca Fancellu <luca.fancellu@arm.com>
    Reviewed-by: Julien Grall <jgrall@amazon.com>
    Reviewed-by: Wei Liu <wei.liu@kernel.org>
    Link: https://lore.kernel.org/r/20210406105105.10141-1-luca.fancellu@arm.com
    Signed-off-by: Boris Ostrovsky <boris.ostrovsky@oracle.com>

commit ef1e21503cc41937b53d436c8f744ded95ab954b
Author: Chanho Park <chanho61.park@samsung.com>
Date:   Wed Jan 27 09:16:31 2021 +0900

    pinctrl: samsung: use raw_spinlock for s3c64xx
    
    Convert spin_[lock|unlock] functions of pin bank to
    raw_spinlock to support preempt-rt for pinctrl-s3c64xx. Below patch
    converted spinlock_t to raw_spinlock_t but it didn't convert the
    s3c64xx's spinlock.
    
    Fixes: 1f306ecbe0f6 ("pinctrl: samsung: use raw_spinlock for locking")
    Cc: Tomasz Figa <tomasz.figa@gmail.com>
    Cc: Krzysztof Kozlowski <krzk@kernel.org>
    Cc: Sylwester Nawrocki <s.nawrocki@samsung.com>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Chanho Park <chanho61.park@samsung.com>
    Link: https://lore.kernel.org/r/20210127001631.91209-1-chanho61.park@samsung.com
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

commit 1f306ecbe0f66681bd87a2bb9013630233a32f7f
Author: Chanho Park <chanho61.park@samsung.com>
Date:   Thu Jan 21 12:00:09 2021 +0900

    pinctrl: samsung: use raw_spinlock for locking
    
    This patch converts spin_[lock|unlock] functions of pin bank to
    raw_spinlock to support preempt-rt. This can avoid BUG() assertion when
    irqchip callbacks are triggerred. Spinlocks can be converted rt_mutex
    which is preemptible when we apply preempt-rt patches.
    
    According to "Documentation/driver-api/gpio/driver.rst",
    
    "Realtime considerations: a realtime compliant GPIO driver should not
    use spinlock_t or any sleepable APIs (like PM runtime) as part of its
    irqchip implementation.
    
    - spinlock_t should be replaced with raw_spinlock_t.[1]
    "
    
    Cc: Tomasz Figa <tomasz.figa@gmail.com>
    Cc: Krzysztof Kozlowski <krzk@kernel.org>
    Cc: Sylwester Nawrocki <s.nawrocki@samsung.com>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Chanho Park <chanho61.park@samsung.com>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Reviewed-by: Krzysztof Kozlowski <krzk@kernel.org>
    Link: https://lore.kernel.org/r/20210121030009.25673-1-chanho61.park@samsung.com
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

commit 9b81af9c845559f8cf9fad2dfc377e548be6da59
Author: Uladzislau Rezki (Sony) <urezki@gmail.com>
Date:   Thu Oct 29 17:50:04 2020 +0100

    rcu/tree: Defer kvfree_rcu() allocation to a clean context
    
    [ Upstream commit 56292e8609e39537297a7468dda4d87b9bd81d6a ]
    
    The current memmory-allocation interface causes the following difficulties
    for kvfree_rcu():
    
    a) If built with CONFIG_PROVE_RAW_LOCK_NESTING, the lockdep will
       complain about violation of the nesting rules, as in "BUG: Invalid
       wait context".  This Kconfig option checks for proper raw_spinlock
       vs. spinlock nesting, in particular, it is not legal to acquire a
       spinlock_t while holding a raw_spinlock_t.
    
       This is a problem because kfree_rcu() uses raw_spinlock_t whereas the
       "page allocator" internally deals with spinlock_t to access to its
       zones. The code also can be broken from higher level of view:
       <snip>
           raw_spin_lock(&some_lock);
           kfree_rcu(some_pointer, some_field_offset);
       <snip>
    
    b) If built with CONFIG_PREEMPT_RT, spinlock_t is converted into
       sleeplock.  This means that invoking the page allocator from atomic
       contexts results in "BUG: scheduling while atomic".
    
    c) Please note that call_rcu() is already invoked from raw atomic context,
       so it is only reasonable to expaect that kfree_rcu() and kvfree_rcu()
       will also be called from atomic raw context.
    
    This commit therefore defers page allocation to a clean context using the
    combination of an hrtimer and a workqueue.  The hrtimer stage is required
    in order to avoid deadlocks with the scheduler.  This deferred allocation
    is required only when kvfree_rcu()'s per-CPU page cache is empty.
    
    Link: https://lore.kernel.org/lkml/20200630164543.4mdcf6zb4zfclhln@linutronix.de/
    Fixes: 3042f83f19be ("rcu: Support reclaim for head-less object")
    Reported-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Uladzislau Rezki (Sony) <urezki@gmail.com>
    Signed-off-by: Paul E. McKenney <paulmck@kernel.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit a2e9ae58d5042b3aa4a61f676ff6975ff3bc7bc7
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Fri Oct 30 12:37:43 2020 +0100

    lockdep/selftests: Fix PROVE_RAW_LOCK_NESTING
    
    The selftest nests rwlock_t inside raw_spinlock_t, this is invalid.
    
    Reported-by: Boqun Feng <boqun.feng@gmail.com>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>

commit 56292e8609e39537297a7468dda4d87b9bd81d6a
Author: Uladzislau Rezki (Sony) <urezki@gmail.com>
Date:   Thu Oct 29 17:50:04 2020 +0100

    rcu/tree: Defer kvfree_rcu() allocation to a clean context
    
    The current memmory-allocation interface causes the following difficulties
    for kvfree_rcu():
    
    a) If built with CONFIG_PROVE_RAW_LOCK_NESTING, the lockdep will
       complain about violation of the nesting rules, as in "BUG: Invalid
       wait context".  This Kconfig option checks for proper raw_spinlock
       vs. spinlock nesting, in particular, it is not legal to acquire a
       spinlock_t while holding a raw_spinlock_t.
    
       This is a problem because kfree_rcu() uses raw_spinlock_t whereas the
       "page allocator" internally deals with spinlock_t to access to its
       zones. The code also can be broken from higher level of view:
       <snip>
           raw_spin_lock(&some_lock);
           kfree_rcu(some_pointer, some_field_offset);
       <snip>
    
    b) If built with CONFIG_PREEMPT_RT, spinlock_t is converted into
       sleeplock.  This means that invoking the page allocator from atomic
       contexts results in "BUG: scheduling while atomic".
    
    c) Please note that call_rcu() is already invoked from raw atomic context,
       so it is only reasonable to expaect that kfree_rcu() and kvfree_rcu()
       will also be called from atomic raw context.
    
    This commit therefore defers page allocation to a clean context using the
    combination of an hrtimer and a workqueue.  The hrtimer stage is required
    in order to avoid deadlocks with the scheduler.  This deferred allocation
    is required only when kvfree_rcu()'s per-CPU page cache is empty.
    
    Link: https://lore.kernel.org/lkml/20200630164543.4mdcf6zb4zfclhln@linutronix.de/
    Fixes: 3042f83f19be ("rcu: Support reclaim for head-less object")
    Reported-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Uladzislau Rezki (Sony) <urezki@gmail.com>
    Signed-off-by: Paul E. McKenney <paulmck@kernel.org>

commit 89e5193ace1af78a2cee0fc83dfcf73b4c5c83d8
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Tue Sep 1 10:41:46 2020 +0200

    io_wq: Make io_wqe::lock a raw_spinlock_t
    
    commit 95da84659226d75698a1ab958be0af21d9cc2a9c upstream.
    
    During a context switch the scheduler invokes wq_worker_sleeping() with
    disabled preemption. Disabling preemption is needed because it protects
    access to `worker->sleeping'. As an optimisation it avoids invoking
    schedule() within the schedule path as part of possible wake up (thus
    preempt_enable_no_resched() afterwards).
    
    The io-wq has been added to the mix in the same section with disabled
    preemption. This breaks on PREEMPT_RT because io_wq_worker_sleeping()
    acquires a spinlock_t. Also within the schedule() the spinlock_t must be
    acquired after tsk_is_pi_blocked() otherwise it will block on the
    sleeping lock again while scheduling out.
    
    While playing with `io_uring-bench' I didn't notice a significant
    latency spike after converting io_wqe::lock to a raw_spinlock_t. The
    latency was more or less the same.
    
    In order to keep the spinlock_t it would have to be moved after the
    tsk_is_pi_blocked() check which would introduce a branch instruction
    into the hot path.
    
    The lock is used to maintain the `work_list' and wakes one task up at
    most.
    Should io_wqe_cancel_pending_work() cause latency spikes, while
    searching for a specific item, then it would need to drop the lock
    during iterations.
    revert_creds() is also invoked under the lock. According to debug
    cred::non_rcu is 0. Otherwise it should be moved outside of the locked
    section because put_cred_rcu()->free_uid() acquires a sleeping lock.
    
    Convert io_wqe::lock to a raw_spinlock_t.c
    
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 4863be6534250e0adb3236af65f1a7ec92c6b6bd
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Tue Sep 1 10:41:46 2020 +0200

    io_wq: Make io_wqe::lock a raw_spinlock_t
    
    commit 95da84659226d75698a1ab958be0af21d9cc2a9c upstream.
    
    During a context switch the scheduler invokes wq_worker_sleeping() with
    disabled preemption. Disabling preemption is needed because it protects
    access to `worker->sleeping'. As an optimisation it avoids invoking
    schedule() within the schedule path as part of possible wake up (thus
    preempt_enable_no_resched() afterwards).
    
    The io-wq has been added to the mix in the same section with disabled
    preemption. This breaks on PREEMPT_RT because io_wq_worker_sleeping()
    acquires a spinlock_t. Also within the schedule() the spinlock_t must be
    acquired after tsk_is_pi_blocked() otherwise it will block on the
    sleeping lock again while scheduling out.
    
    While playing with `io_uring-bench' I didn't notice a significant
    latency spike after converting io_wqe::lock to a raw_spinlock_t. The
    latency was more or less the same.
    
    In order to keep the spinlock_t it would have to be moved after the
    tsk_is_pi_blocked() check which would introduce a branch instruction
    into the hot path.
    
    The lock is used to maintain the `work_list' and wakes one task up at
    most.
    Should io_wqe_cancel_pending_work() cause latency spikes, while
    searching for a specific item, then it would need to drop the lock
    during iterations.
    revert_creds() is also invoked under the lock. According to debug
    cred::non_rcu is 0. Otherwise it should be moved outside of the locked
    section because put_cred_rcu()->free_uid() acquires a sleeping lock.
    
    Convert io_wqe::lock to a raw_spinlock_t.c
    
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 1a2b85f1e2a93a3f84243e654d225e4088735336
Author: Davidlohr Bueso <dave@stgolabs.net>
Date:   Wed Oct 21 12:07:49 2020 -0700

    timekeeping: Convert jiffies_seq to seqcount_raw_spinlock_t
    
    Use the new api and associate the seqcounter to the jiffies_lock enabling
    lockdep support - although for this particular case the write-side locking
    and non-preemptibility are quite obvious.
    
    Signed-off-by: Davidlohr Bueso <dbueso@suse.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lore.kernel.org/r/20201021190749.19363-1-dave@stgolabs.net

commit 95da84659226d75698a1ab958be0af21d9cc2a9c
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Tue Sep 1 10:41:46 2020 +0200

    io_wq: Make io_wqe::lock a raw_spinlock_t
    
    During a context switch the scheduler invokes wq_worker_sleeping() with
    disabled preemption. Disabling preemption is needed because it protects
    access to `worker->sleeping'. As an optimisation it avoids invoking
    schedule() within the schedule path as part of possible wake up (thus
    preempt_enable_no_resched() afterwards).
    
    The io-wq has been added to the mix in the same section with disabled
    preemption. This breaks on PREEMPT_RT because io_wq_worker_sleeping()
    acquires a spinlock_t. Also within the schedule() the spinlock_t must be
    acquired after tsk_is_pi_blocked() otherwise it will block on the
    sleeping lock again while scheduling out.
    
    While playing with `io_uring-bench' I didn't notice a significant
    latency spike after converting io_wqe::lock to a raw_spinlock_t. The
    latency was more or less the same.
    
    In order to keep the spinlock_t it would have to be moved after the
    tsk_is_pi_blocked() check which would introduce a branch instruction
    into the hot path.
    
    The lock is used to maintain the `work_list' and wakes one task up at
    most.
    Should io_wqe_cancel_pending_work() cause latency spikes, while
    searching for a specific item, then it would need to drop the lock
    during iterations.
    revert_creds() is also invoked under the lock. According to debug
    cred::non_rcu is 0. Otherwise it should be moved outside of the locked
    section because put_cred_rcu()->free_uid() acquires a sleeping lock.
    
    Convert io_wqe::lock to a raw_spinlock_t.c
    
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

commit 249d053835320cb3e7c00066cf085a6ba9b1f126
Author: Ahmed S. Darwish <a.darwish@linutronix.de>
Date:   Thu Aug 27 13:40:41 2020 +0200

    timekeeping: Use seqcount_latch_t
    
    Latch sequence counters are a multiversion concurrency control mechanism
    where the seqcount_t counter even/odd value is used to switch between
    two data storage copies. This allows the seqcount_t read path to safely
    interrupt its write side critical section (e.g. from NMIs).
    
    Initially, latch sequence counters were implemented as a single write
    function, raw_write_seqcount_latch(), above plain seqcount_t. The read
    path was expected to use plain seqcount_t raw_read_seqcount().
    
    A specialized read function was later added, raw_read_seqcount_latch(),
    and became the standardized way for latch read paths. Having unique read
    and write APIs meant that latch sequence counters are basically a data
    type of their own -- just inappropriately overloading plain seqcount_t.
    The seqcount_latch_t data type was thus introduced at seqlock.h.
    
    Use that new data type instead of seqcount_raw_spinlock_t. This ensures
    that only latch-safe APIs are to be used with the sequence counter.
    
    Note that the use of seqcount_raw_spinlock_t was not very useful in the
    first place. Only the "raw_" subset of seqcount_t APIs were used at
    timekeeping.c. This subset was created for contexts where lockdep cannot
    be used. seqcount_LOCKTYPE_t's raison d'être -- verifying that the
    seqcount_t writer serialization lock is held -- cannot thus be done.
    
    References: 0c3351d451ae ("seqlock: Use raw_ prefix instead of _no_lockdep")
    References: 55f3560df975 ("seqlock: Extend seqcount API with associated locks")
    Signed-off-by: Ahmed S. Darwish <a.darwish@linutronix.de>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Link: https://lkml.kernel.org/r/20200827114044.11173-6-a.darwish@linutronix.de

commit 80793c3471d90d4dc2b48deadb6413bdfe39500f
Author: Ahmed S. Darwish <a.darwish@linutronix.de>
Date:   Thu Aug 27 13:40:39 2020 +0200

    seqlock: Introduce seqcount_latch_t
    
    Latch sequence counters are a multiversion concurrency control mechanism
    where the seqcount_t counter even/odd value is used to switch between
    two copies of protected data. This allows the seqcount_t read path to
    safely interrupt its write side critical section (e.g. from NMIs).
    
    Initially, latch sequence counters were implemented as a single write
    function above plain seqcount_t: raw_write_seqcount_latch(). The read
    side was expected to use plain seqcount_t raw_read_seqcount().
    
    A specialized latch read function, raw_read_seqcount_latch(), was later
    added. It became the standardized way for latch read paths.  Due to the
    dependent load, it has one read memory barrier less than the plain
    seqcount_t raw_read_seqcount() API.
    
    Only raw_write_seqcount_latch() and raw_read_seqcount_latch() should be
    used with latch sequence counters. Having *unique* read and write path
    APIs means that latch sequence counters are actually a data type of
    their own -- just inappropriately overloading plain seqcount_t.
    
    Introduce seqcount_latch_t. This adds type-safety and ensures that only
    the correct latch-safe APIs are to be used.
    
    Not to break bisection, let the latch APIs also accept plain seqcount_t
    or seqcount_raw_spinlock_t. After converting all call sites to
    seqcount_latch_t, only that new data type will be allowed.
    
    References: 9b0fd802e8c0 ("seqcount: Add raw_write_seqcount_latch()")
    References: 7fc26327b756 ("seqlock: Introduce raw_read_seqcount_latch()")
    References: aadd6e5caaac ("time/sched_clock: Use raw_read_seqcount_latch()")
    Signed-off-by: Ahmed S. Darwish <a.darwish@linutronix.de>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Link: https://lkml.kernel.org/r/20200827114044.11173-4-a.darwish@linutronix.de

commit f7987153ab716d2e87dd694926c486c55313c8b3
Author: Bartosz Golaszewski <bgolaszewski@baylibre.com>
Date:   Mon Jun 15 09:44:45 2020 +0200

    irqchip/irq-mtk-sysirq: Replace spinlock with raw_spinlock
    
    [ Upstream commit 6eeb997ab5075e770a002c51351fa4ec2c6b5c39 ]
    
    This driver may take a regular spinlock when a raw spinlock
    (irq_desc->lock) is already taken which results in the following
    lockdep splat:
    
    =============================
    [ BUG: Invalid wait context ]
    5.7.0-rc7 #1 Not tainted
    -----------------------------
    swapper/0/0 is trying to lock:
    ffffff800303b798 (&chip_data->lock){....}-{3:3}, at: mtk_sysirq_set_type+0x48/0xc0
    other info that might help us debug this:
    context-{5:5}
    2 locks held by swapper/0/0:
     #0: ffffff800302ee68 (&desc->request_mutex){....}-{4:4}, at: __setup_irq+0xc4/0x8a0
     #1: ffffff800302ecf0 (&irq_desc_lock_class){....}-{2:2}, at: __setup_irq+0xe4/0x8a0
    stack backtrace:
    CPU: 0 PID: 0 Comm: swapper/0 Not tainted 5.7.0-rc7 #1
    Hardware name: Pumpkin MT8516 (DT)
    Call trace:
     dump_backtrace+0x0/0x180
     show_stack+0x14/0x20
     dump_stack+0xd0/0x118
     __lock_acquire+0x8c8/0x2270
     lock_acquire+0xf8/0x470
     _raw_spin_lock_irqsave+0x50/0x78
     mtk_sysirq_set_type+0x48/0xc0
     __irq_set_trigger+0x58/0x170
     __setup_irq+0x420/0x8a0
     request_threaded_irq+0xd8/0x190
     timer_of_init+0x1e8/0x2c4
     mtk_gpt_init+0x5c/0x1dc
     timer_probe+0x74/0xf4
     time_init+0x14/0x44
     start_kernel+0x394/0x4f0
    
    Replace the spinlock_t with raw_spinlock_t to avoid this warning.
    
    Signed-off-by: Bartosz Golaszewski <bgolaszewski@baylibre.com>
    Signed-off-by: Marc Zyngier <maz@kernel.org>
    Link: https://lore.kernel.org/r/20200615074445.3579-1-brgl@bgdev.pl
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit b70d115ebdcf97cc605716329c754676df881617
Author: Bartosz Golaszewski <bgolaszewski@baylibre.com>
Date:   Mon Jun 15 09:44:45 2020 +0200

    irqchip/irq-mtk-sysirq: Replace spinlock with raw_spinlock
    
    [ Upstream commit 6eeb997ab5075e770a002c51351fa4ec2c6b5c39 ]
    
    This driver may take a regular spinlock when a raw spinlock
    (irq_desc->lock) is already taken which results in the following
    lockdep splat:
    
    =============================
    [ BUG: Invalid wait context ]
    5.7.0-rc7 #1 Not tainted
    -----------------------------
    swapper/0/0 is trying to lock:
    ffffff800303b798 (&chip_data->lock){....}-{3:3}, at: mtk_sysirq_set_type+0x48/0xc0
    other info that might help us debug this:
    context-{5:5}
    2 locks held by swapper/0/0:
     #0: ffffff800302ee68 (&desc->request_mutex){....}-{4:4}, at: __setup_irq+0xc4/0x8a0
     #1: ffffff800302ecf0 (&irq_desc_lock_class){....}-{2:2}, at: __setup_irq+0xe4/0x8a0
    stack backtrace:
    CPU: 0 PID: 0 Comm: swapper/0 Not tainted 5.7.0-rc7 #1
    Hardware name: Pumpkin MT8516 (DT)
    Call trace:
     dump_backtrace+0x0/0x180
     show_stack+0x14/0x20
     dump_stack+0xd0/0x118
     __lock_acquire+0x8c8/0x2270
     lock_acquire+0xf8/0x470
     _raw_spin_lock_irqsave+0x50/0x78
     mtk_sysirq_set_type+0x48/0xc0
     __irq_set_trigger+0x58/0x170
     __setup_irq+0x420/0x8a0
     request_threaded_irq+0xd8/0x190
     timer_of_init+0x1e8/0x2c4
     mtk_gpt_init+0x5c/0x1dc
     timer_probe+0x74/0xf4
     time_init+0x14/0x44
     start_kernel+0x394/0x4f0
    
    Replace the spinlock_t with raw_spinlock_t to avoid this warning.
    
    Signed-off-by: Bartosz Golaszewski <bgolaszewski@baylibre.com>
    Signed-off-by: Marc Zyngier <maz@kernel.org>
    Link: https://lore.kernel.org/r/20200615074445.3579-1-brgl@bgdev.pl
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 950a1a7f661d7c9e7860cc33fd7057073ea90e19
Author: Bartosz Golaszewski <bgolaszewski@baylibre.com>
Date:   Mon Jun 15 09:44:45 2020 +0200

    irqchip/irq-mtk-sysirq: Replace spinlock with raw_spinlock
    
    [ Upstream commit 6eeb997ab5075e770a002c51351fa4ec2c6b5c39 ]
    
    This driver may take a regular spinlock when a raw spinlock
    (irq_desc->lock) is already taken which results in the following
    lockdep splat:
    
    =============================
    [ BUG: Invalid wait context ]
    5.7.0-rc7 #1 Not tainted
    -----------------------------
    swapper/0/0 is trying to lock:
    ffffff800303b798 (&chip_data->lock){....}-{3:3}, at: mtk_sysirq_set_type+0x48/0xc0
    other info that might help us debug this:
    context-{5:5}
    2 locks held by swapper/0/0:
     #0: ffffff800302ee68 (&desc->request_mutex){....}-{4:4}, at: __setup_irq+0xc4/0x8a0
     #1: ffffff800302ecf0 (&irq_desc_lock_class){....}-{2:2}, at: __setup_irq+0xe4/0x8a0
    stack backtrace:
    CPU: 0 PID: 0 Comm: swapper/0 Not tainted 5.7.0-rc7 #1
    Hardware name: Pumpkin MT8516 (DT)
    Call trace:
     dump_backtrace+0x0/0x180
     show_stack+0x14/0x20
     dump_stack+0xd0/0x118
     __lock_acquire+0x8c8/0x2270
     lock_acquire+0xf8/0x470
     _raw_spin_lock_irqsave+0x50/0x78
     mtk_sysirq_set_type+0x48/0xc0
     __irq_set_trigger+0x58/0x170
     __setup_irq+0x420/0x8a0
     request_threaded_irq+0xd8/0x190
     timer_of_init+0x1e8/0x2c4
     mtk_gpt_init+0x5c/0x1dc
     timer_probe+0x74/0xf4
     time_init+0x14/0x44
     start_kernel+0x394/0x4f0
    
    Replace the spinlock_t with raw_spinlock_t to avoid this warning.
    
    Signed-off-by: Bartosz Golaszewski <bgolaszewski@baylibre.com>
    Signed-off-by: Marc Zyngier <maz@kernel.org>
    Link: https://lore.kernel.org/r/20200615074445.3579-1-brgl@bgdev.pl
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit ae3033d3859691136642ca01e8fdae2a05ffcd3c
Author: Bartosz Golaszewski <bgolaszewski@baylibre.com>
Date:   Mon Jun 15 09:44:45 2020 +0200

    irqchip/irq-mtk-sysirq: Replace spinlock with raw_spinlock
    
    [ Upstream commit 6eeb997ab5075e770a002c51351fa4ec2c6b5c39 ]
    
    This driver may take a regular spinlock when a raw spinlock
    (irq_desc->lock) is already taken which results in the following
    lockdep splat:
    
    =============================
    [ BUG: Invalid wait context ]
    5.7.0-rc7 #1 Not tainted
    -----------------------------
    swapper/0/0 is trying to lock:
    ffffff800303b798 (&chip_data->lock){....}-{3:3}, at: mtk_sysirq_set_type+0x48/0xc0
    other info that might help us debug this:
    context-{5:5}
    2 locks held by swapper/0/0:
     #0: ffffff800302ee68 (&desc->request_mutex){....}-{4:4}, at: __setup_irq+0xc4/0x8a0
     #1: ffffff800302ecf0 (&irq_desc_lock_class){....}-{2:2}, at: __setup_irq+0xe4/0x8a0
    stack backtrace:
    CPU: 0 PID: 0 Comm: swapper/0 Not tainted 5.7.0-rc7 #1
    Hardware name: Pumpkin MT8516 (DT)
    Call trace:
     dump_backtrace+0x0/0x180
     show_stack+0x14/0x20
     dump_stack+0xd0/0x118
     __lock_acquire+0x8c8/0x2270
     lock_acquire+0xf8/0x470
     _raw_spin_lock_irqsave+0x50/0x78
     mtk_sysirq_set_type+0x48/0xc0
     __irq_set_trigger+0x58/0x170
     __setup_irq+0x420/0x8a0
     request_threaded_irq+0xd8/0x190
     timer_of_init+0x1e8/0x2c4
     mtk_gpt_init+0x5c/0x1dc
     timer_probe+0x74/0xf4
     time_init+0x14/0x44
     start_kernel+0x394/0x4f0
    
    Replace the spinlock_t with raw_spinlock_t to avoid this warning.
    
    Signed-off-by: Bartosz Golaszewski <bgolaszewski@baylibre.com>
    Signed-off-by: Marc Zyngier <maz@kernel.org>
    Link: https://lore.kernel.org/r/20200615074445.3579-1-brgl@bgdev.pl
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 1016f98b586dce303561d4e32c1173e1cecd7131
Author: Bartosz Golaszewski <bgolaszewski@baylibre.com>
Date:   Mon Jun 15 09:44:45 2020 +0200

    irqchip/irq-mtk-sysirq: Replace spinlock with raw_spinlock
    
    [ Upstream commit 6eeb997ab5075e770a002c51351fa4ec2c6b5c39 ]
    
    This driver may take a regular spinlock when a raw spinlock
    (irq_desc->lock) is already taken which results in the following
    lockdep splat:
    
    =============================
    [ BUG: Invalid wait context ]
    5.7.0-rc7 #1 Not tainted
    -----------------------------
    swapper/0/0 is trying to lock:
    ffffff800303b798 (&chip_data->lock){....}-{3:3}, at: mtk_sysirq_set_type+0x48/0xc0
    other info that might help us debug this:
    context-{5:5}
    2 locks held by swapper/0/0:
     #0: ffffff800302ee68 (&desc->request_mutex){....}-{4:4}, at: __setup_irq+0xc4/0x8a0
     #1: ffffff800302ecf0 (&irq_desc_lock_class){....}-{2:2}, at: __setup_irq+0xe4/0x8a0
    stack backtrace:
    CPU: 0 PID: 0 Comm: swapper/0 Not tainted 5.7.0-rc7 #1
    Hardware name: Pumpkin MT8516 (DT)
    Call trace:
     dump_backtrace+0x0/0x180
     show_stack+0x14/0x20
     dump_stack+0xd0/0x118
     __lock_acquire+0x8c8/0x2270
     lock_acquire+0xf8/0x470
     _raw_spin_lock_irqsave+0x50/0x78
     mtk_sysirq_set_type+0x48/0xc0
     __irq_set_trigger+0x58/0x170
     __setup_irq+0x420/0x8a0
     request_threaded_irq+0xd8/0x190
     timer_of_init+0x1e8/0x2c4
     mtk_gpt_init+0x5c/0x1dc
     timer_probe+0x74/0xf4
     time_init+0x14/0x44
     start_kernel+0x394/0x4f0
    
    Replace the spinlock_t with raw_spinlock_t to avoid this warning.
    
    Signed-off-by: Bartosz Golaszewski <bgolaszewski@baylibre.com>
    Signed-off-by: Marc Zyngier <maz@kernel.org>
    Link: https://lore.kernel.org/r/20200615074445.3579-1-brgl@bgdev.pl
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit af5a06b582ec3d7b0160b4faaa65f73d8dcf989f
Author: Ahmed S. Darwish <a.darwish@linutronix.de>
Date:   Mon Jul 20 17:55:30 2020 +0200

    hrtimer: Use sequence counter with associated raw spinlock
    
    A sequence counter write side critical section must be protected by some
    form of locking to serialize writers. A plain seqcount_t does not
    contain the information of which lock must be held when entering a write
    side critical section.
    
    Use the new seqcount_raw_spinlock_t data type, which allows to associate
    a raw spinlock with the sequence counter. This enables lockdep to verify
    that the raw spinlock used for writer serialization is held when the
    write side critical section is entered.
    
    If lockdep is disabled this lock association is compiled out and has
    neither storage size nor runtime overhead.
    
    Signed-off-by: Ahmed S. Darwish <a.darwish@linutronix.de>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Link: https://lkml.kernel.org/r/20200720155530.1173732-25-a.darwish@linutronix.de

commit 025e82bcbc34cd071390e72fd0b31593282f9425
Author: Ahmed S. Darwish <a.darwish@linutronix.de>
Date:   Mon Jul 20 17:55:23 2020 +0200

    timekeeping: Use sequence counter with associated raw spinlock
    
    A sequence counter write side critical section must be protected by some
    form of locking to serialize writers. A plain seqcount_t does not
    contain the information of which lock must be held when entering a write
    side critical section.
    
    Use the new seqcount_raw_spinlock_t data type, which allows to associate
    a raw spinlock with the sequence counter. This enables lockdep to verify
    that the raw spinlock used for writer serialization is held when the
    write side critical section is entered.
    
    If lockdep is disabled this lock association is compiled out and has
    neither storage size nor runtime overhead.
    
    Signed-off-by: Ahmed S. Darwish <a.darwish@linutronix.de>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Link: https://lkml.kernel.org/r/20200720155530.1173732-18-a.darwish@linutronix.de

commit 55f3560df975f557c48aa6afc636808f31ecb87a
Author: Ahmed S. Darwish <a.darwish@linutronix.de>
Date:   Mon Jul 20 17:55:15 2020 +0200

    seqlock: Extend seqcount API with associated locks
    
    A sequence counter write side critical section must be protected by some
    form of locking to serialize writers. If the serialization primitive is
    not disabling preemption implicitly, preemption has to be explicitly
    disabled before entering the write side critical section.
    
    There is no built-in debugging mechanism to verify that the lock used
    for writer serialization is held and preemption is disabled. Some usage
    sites like dma-buf have explicit lockdep checks for the writer-side
    lock, but this covers only a small portion of the sequence counter usage
    in the kernel.
    
    Add new sequence counter types which allows to associate a lock to the
    sequence counter at initialization time. The seqcount API functions are
    extended to provide appropriate lockdep assertions depending on the
    seqcount/lock type.
    
    For sequence counters with associated locks that do not implicitly
    disable preemption, preemption protection is enforced in the sequence
    counter write side functions. This removes the need to explicitly add
    preempt_disable/enable() around the write side critical sections: the
    write_begin/end() functions for these new sequence counter types
    automatically do this.
    
    Introduce the following seqcount types with associated locks:
    
         seqcount_spinlock_t
         seqcount_raw_spinlock_t
         seqcount_rwlock_t
         seqcount_mutex_t
         seqcount_ww_mutex_t
    
    Extend the seqcount read and write functions to branch out to the
    specific seqcount_LOCKTYPE_t implementation at compile-time. This avoids
    kernel API explosion per each new seqcount_LOCKTYPE_t added. Add such
    compile-time type detection logic into a new, internal, seqlock header.
    
    Document the proper seqcount_LOCKTYPE_t usage, and rationale, at
    Documentation/locking/seqlock.rst.
    
    If lockdep is disabled, this lock association is compiled out and has
    neither storage size nor runtime overhead.
    
    Signed-off-by: Ahmed S. Darwish <a.darwish@linutronix.de>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Link: https://lkml.kernel.org/r/20200720155530.1173732-10-a.darwish@linutronix.de

commit 6eeb997ab5075e770a002c51351fa4ec2c6b5c39
Author: Bartosz Golaszewski <bgolaszewski@baylibre.com>
Date:   Mon Jun 15 09:44:45 2020 +0200

    irqchip/irq-mtk-sysirq: Replace spinlock with raw_spinlock
    
    This driver may take a regular spinlock when a raw spinlock
    (irq_desc->lock) is already taken which results in the following
    lockdep splat:
    
    =============================
    [ BUG: Invalid wait context ]
    5.7.0-rc7 #1 Not tainted
    -----------------------------
    swapper/0/0 is trying to lock:
    ffffff800303b798 (&chip_data->lock){....}-{3:3}, at: mtk_sysirq_set_type+0x48/0xc0
    other info that might help us debug this:
    context-{5:5}
    2 locks held by swapper/0/0:
     #0: ffffff800302ee68 (&desc->request_mutex){....}-{4:4}, at: __setup_irq+0xc4/0x8a0
     #1: ffffff800302ecf0 (&irq_desc_lock_class){....}-{2:2}, at: __setup_irq+0xe4/0x8a0
    stack backtrace:
    CPU: 0 PID: 0 Comm: swapper/0 Not tainted 5.7.0-rc7 #1
    Hardware name: Pumpkin MT8516 (DT)
    Call trace:
     dump_backtrace+0x0/0x180
     show_stack+0x14/0x20
     dump_stack+0xd0/0x118
     __lock_acquire+0x8c8/0x2270
     lock_acquire+0xf8/0x470
     _raw_spin_lock_irqsave+0x50/0x78
     mtk_sysirq_set_type+0x48/0xc0
     __irq_set_trigger+0x58/0x170
     __setup_irq+0x420/0x8a0
     request_threaded_irq+0xd8/0x190
     timer_of_init+0x1e8/0x2c4
     mtk_gpt_init+0x5c/0x1dc
     timer_probe+0x74/0xf4
     time_init+0x14/0x44
     start_kernel+0x394/0x4f0
    
    Replace the spinlock_t with raw_spinlock_t to avoid this warning.
    
    Signed-off-by: Bartosz Golaszewski <bgolaszewski@baylibre.com>
    Signed-off-by: Marc Zyngier <maz@kernel.org>
    Link: https://lore.kernel.org/r/20200615074445.3579-1-brgl@bgdev.pl

commit fe3bc8a988a4d38dc090e77071ff9b8ea266528a
Merge: 4a7e89c5ec02 10cdb1575954
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jun 6 10:01:48 2020 -0700

    Merge branch 'for-5.8' of git://git.kernel.org/pub/scm/linux/kernel/git/tj/wq
    
    Pull workqueue updates from Tejun Heo:
     "Mostly cleanups and other trivial changes.
    
      The only interesting change is Sebastian's rcuwait conversion for RT"
    
    * 'for-5.8' of git://git.kernel.org/pub/scm/linux/kernel/git/tj/wq:
      workqueue: use BUILD_BUG_ON() for compile time test instead of WARN_ON()
      workqueue: fix a piece of comment about reserved bits for work flags
      workqueue: remove useless unlock() and lock() in series
      workqueue: void unneeded requeuing the pwq in rescuer thread
      workqueue: Convert the pool::lock and wq_mayday_lock to raw_spinlock_t
      workqueue: Use rcuwait for wq_manager_wait
      workqueue: Remove unnecessary kfree() call in rcu_free_wq()
      workqueue: Fix an use after free in init_rescuer()
      workqueue: Use IS_ERR and PTR_ERR instead of PTR_ERR_OR_ZERO.

commit a9b8a985294debae00f6c087dfec8c384d30a3b9
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Wed May 27 21:46:33 2020 +0200

    workqueue: Convert the pool::lock and wq_mayday_lock to raw_spinlock_t
    
    The workqueue code has it's internal spinlocks (pool::lock), which
    are acquired on most workqueue operations. These spinlocks are
    converted to 'sleeping' spinlocks on a RT-kernel.
    
    Workqueue functions can be invoked from contexts which are truly atomic
    even on a PREEMPT_RT enabled kernel. Taking sleeping locks from such
    contexts is forbidden.
    
    The pool::lock hold times are bound and the code sections are
    relatively short, which allows to convert pool::lock and as a
    consequence wq_mayday_lock to raw spinlocks which are truly spinning
    locks even on a PREEMPT_RT kernel.
    
    With the previous conversion of the manager waitqueue to a simple
    waitqueue workqueues are now fully RT compliant.
    
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Reviewed-by: Lai Jiangshan <jiangshanlai@gmail.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

commit 34183ddd13dbfa859c4b68d16a30aad2cce72b11
Merge: 8645f09bad14 11700fcb90b4
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Apr 7 20:00:16 2020 -0700

    Merge tag 'thermal-v5.7-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/thermal/linux
    
    Pull thermal updates from Daniel Lezcano:
    
     - Convert tsens configuration DT binding to yaml (Rajeshwari)
    
     - Add interrupt support on the rcar sensor (Niklas Söderlund)
    
     - Add a new Spreadtrum thermal driver (Baolin Wang)
    
     - Add thermal binding for the fsl scu board, a new API to retrieve the
       sensor id bound to the thermal zone and i.MX system controller sensor
       (Anson Huang))
    
     - Remove warning log when a deferred probe is requested on Exynos
       (Marek Szyprowski)
    
     - Add the thermal monitoring unit support for imx8mm with its DT
       bindings (Anson Huang)
    
     - Rephrase the Kconfig text for clarity (Linus Walleij)
    
     - Use the gpio descriptor for the ti-soc-thermal (Linus Walleij)
    
     - Align msg structure to 4 bytes for i.MX SC, fix the Kconfig
       dependency, add the __may_be unused annotation for PM functions and
       the COMPILE_TEST option for imx8mm (Anson Huang)
    
     - Fix a dependency on regmap in Kconfig for qoriq (Yuantian Tang)
    
     - Add DT binding and support for the rcar gen3 r8a77961 and improve the
       error path on the rcar init function (Niklas Söderlund)
    
     - Cleanup and improvements for the tsens Qcom sensor (Amit Kucheria)
    
     - Improve code by removing lock and caching values in the rcar thermal
       sensor (Niklas Söderlund)
    
     - Cleanup in the qoriq drivers and add a call to
       imx_thermal_unregister_legacy_cooling in the removal function (Anson
       Huang)
    
     - Remove redundant 'maxItems' in tsens and sprd DT bindings (Rob
       Herring)
    
     - Change the thermal DT bindings by making the cooling-maps optional
       (Yuantian Tang)
    
     - Add Tiger Lake support (Sumeet Pawnikar)
    
     - Use scnprintf() for avoiding potential buffer overflow (Takashi Iwai)
    
     - Make pkg_temp_lock a raw_spinlock_t(Clark Williams)
    
     - Fix incorrect data types by changing them to signed on i.MX SC (Anson
       Huang)
    
     - Replace zero-length array with flexible-array member (Gustavo A. R.
       Silva)
    
     - Add support for i.MX8MP in the driver and in the DT bindings (Anson
       Huang)
    
     - Fix return value of the cpufreq_set_cur_state() function (Willy
       Wolff)
    
     - Remove abusing and scary WARN_ON in the cpufreq cooling device
       (Daniel Lezcano)
    
     - Fix build warning of incorrect argument type reported by sparse on
       imx8mm (Anson Huang)
    
     - Fix stub for the devfreq cooling device (Martin Blumenstingl)
    
     - Fix cpu idle cooling documentation (Sergey Vidishev)
    
    * tag 'thermal-v5.7-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/thermal/linux: (52 commits)
      Documentation: cpu-idle-cooling: Fix diagram for 33% duty cycle
      thermal: devfreq_cooling: inline all stubs for CONFIG_DEVFREQ_THERMAL=n
      thermal: imx8mm: Fix build warning of incorrect argument type
      thermal/drivers/cpufreq_cooling: Remove abusing WARN_ON
      thermal/drivers/cpufreq_cooling: Fix return of cpufreq_set_cur_state
      thermal: imx8mm: Add i.MX8MP support
      dt-bindings: thermal: imx8mm-thermal: Add support for i.MX8MP
      thermal: qcom: tsens.h: Replace zero-length array with flexible-array member
      thermal: imx_sc_thermal: Fix incorrect data type
      thermal: int340x_thermal: Use scnprintf() for avoiding potential buffer overflow
      thermal: int340x: processor_thermal: Add Tiger Lake support
      thermal/x86_pkg_temp: Make pkg_temp_lock a raw_spinlock_t
      dt-bindings: thermal: make cooling-maps property optional
      dt-bindings: thermal: qcom-tsens: Remove redundant 'maxItems'
      dt-bindings: thermal: sprd: Remove redundant 'maxItems'
      thermal: imx: Calling imx_thermal_unregister_legacy_cooling() in .remove
      thermal: qoriq: Sort includes alphabetically
      thermal: qoriq: Use devm_add_action_or_reset() to handle all cleanups
      thermal: rcar_thermal: Remove lock in rcar_thermal_get_current_temp()
      thermal: rcar_thermal: Do not store ctemp in rcar_thermal_priv
      ...

commit 4b9fd8a829a1eec7442e38afff21d610604de56a
Merge: a776c270a0b2 f1e67e355c2a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Mar 30 16:17:15 2020 -0700

    Merge branch 'locking-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull locking updates from Ingo Molnar:
     "The main changes in this cycle were:
    
       - Continued user-access cleanups in the futex code.
    
       - percpu-rwsem rewrite that uses its own waitqueue and atomic_t
         instead of an embedded rwsem. This addresses a couple of
         weaknesses, but the primary motivation was complications on the -rt
         kernel.
    
       - Introduce raw lock nesting detection on lockdep
         (CONFIG_PROVE_RAW_LOCK_NESTING=y), document the raw_lock vs. normal
         lock differences. This too originates from -rt.
    
       - Reuse lockdep zapped chain_hlocks entries, to conserve RAM
         footprint on distro-ish kernels running into the "BUG:
         MAX_LOCKDEP_CHAIN_HLOCKS too low!" depletion of the lockdep
         chain-entries pool.
    
       - Misc cleanups, smaller fixes and enhancements - see the changelog
         for details"
    
    * 'locking-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (55 commits)
      fs/buffer: Make BH_Uptodate_Lock bit_spin_lock a regular spinlock_t
      thermal/x86_pkg_temp: Make pkg_temp_lock a raw_spinlock_t
      Documentation/locking/locktypes: Minor copy editor fixes
      Documentation/locking/locktypes: Further clarifications and wordsmithing
      m68knommu: Remove mm.h include from uaccess_no.h
      x86: get rid of user_atomic_cmpxchg_inatomic()
      generic arch_futex_atomic_op_inuser() doesn't need access_ok()
      x86: don't reload after cmpxchg in unsafe_atomic_op2() loop
      x86: convert arch_futex_atomic_op_inuser() to user_access_begin/user_access_end()
      objtool: whitelist __sanitizer_cov_trace_switch()
      [parisc, s390, sparc64] no need for access_ok() in futex handling
      sh: no need of access_ok() in arch_futex_atomic_op_inuser()
      futex: arch_futex_atomic_op_inuser() calling conventions change
      completion: Use lockdep_assert_RT_in_threaded_ctx() in complete_all()
      lockdep: Add posixtimer context tracing bits
      lockdep: Annotate irq_work
      lockdep: Add hrtimer context tracing bits
      lockdep: Introduce wait-type checks
      completion: Use simple wait queues
      sched/swait: Prepare usage in completions
      ...

commit fc32150e6f43d6cb93ea75937bb6a88a1764cc37
Author: Clark Williams <williams@redhat.com>
Date:   Tue Oct 8 13:00:21 2019 +0200

    thermal/x86_pkg_temp: Make pkg_temp_lock a raw_spinlock_t
    
    The pkg_temp_lock spinlock is acquired in the thermal vector handler which
    is truly atomic context even on PREEMPT_RT kernels.
    
    The critical sections are tiny, so change it to a raw spinlock.
    
    Signed-off-by: Clark Williams <williams@redhat.com>
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lore.kernel.org/r/20191008110021.2j44ayunal7fkb7i@linutronix.de

commit de8f5e4f2dc1f032b46afda0a78cab5456974f89
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Sat Mar 21 12:26:01 2020 +0100

    lockdep: Introduce wait-type checks
    
    Extend lockdep to validate lock wait-type context.
    
    The current wait-types are:
    
            LD_WAIT_FREE,           /* wait free, rcu etc.. */
            LD_WAIT_SPIN,           /* spin loops, raw_spinlock_t etc.. */
            LD_WAIT_CONFIG,         /* CONFIG_PREEMPT_LOCK, spinlock_t etc.. */
            LD_WAIT_SLEEP,          /* sleeping locks, mutex_t etc.. */
    
    Where lockdep validates that the current lock (the one being acquired)
    fits in the current wait-context (as generated by the held stack).
    
    This ensures that there is no attempt to acquire mutexes while holding
    spinlocks, to acquire spinlocks while holding raw_spinlocks and so on. In
    other words, its a more fancy might_sleep().
    
    Obviously RCU made the entire ordeal more complex than a simple single
    value test because RCU can be acquired in (pretty much) any context and
    while it presents a context to nested locks it is not the same as it
    got acquired in.
    
    Therefore its necessary to split the wait_type into two values, one
    representing the acquire (outer) and one representing the nested context
    (inner). For most 'normal' locks these two are the same.
    
    [ To make static initialization easier we have the rule that:
      .outer == INV means .outer == .inner; because INV == 0. ]
    
    It further means that its required to find the minimal .inner of the held
    stack to compare against the outer of the new lock; because while 'normal'
    RCU presents a CONFIG type to nested locks, if it is taken while already
    holding a SPIN type it obviously doesn't relax the rules.
    
    Below is an example output generated by the trivial test code:
    
      raw_spin_lock(&foo);
      spin_lock(&bar);
      spin_unlock(&bar);
      raw_spin_unlock(&foo);
    
     [ BUG: Invalid wait context ]
     -----------------------------
     swapper/0/1 is trying to lock:
     ffffc90000013f20 (&bar){....}-{3:3}, at: kernel_init+0xdb/0x187
     other info that might help us debug this:
     1 lock held by swapper/0/1:
      #0: ffffc90000013ee0 (&foo){+.+.}-{2:2}, at: kernel_init+0xd1/0x187
    
    The way to read it is to look at the new -{n,m} part in the lock
    description; -{3:3} for the attempted lock, and try and match that up to
    the held locks, which in this case is the one: -{2,2}.
    
    This tells that the acquiring lock requires a more relaxed environment than
    presented by the lock stack.
    
    Currently only the normal locks and RCU are converted, the rest of the
    lockdep users defaults to .inner = INV which is ignored. More conversions
    can be done when desired.
    
    The check for spinlock_t nesting is not enabled by default. It's a separate
    config option for now as there are known problems which are currently
    addressed. The config option allows to identify these problems and to
    verify that the solutions found are indeed solving them.
    
    The config switch will be removed and the checks will permanently enabled
    once the vast majority of issues has been addressed.
    
    [ bigeasy: Move LD_WAIT_FREE,… out of CONFIG_LOCKDEP to avoid compile
               failure with CONFIG_DEBUG_SPINLOCK + !CONFIG_LOCKDEP]
    [ tglx: Add the config option ]
    
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Link: https://lkml.kernel.org/r/20200321113242.427089655@linutronix.de

commit a5c6234e10280b3ec65e2410ce34904a2580e5f8
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Mar 21 12:26:00 2020 +0100

    completion: Use simple wait queues
    
    completion uses a wait_queue_head_t to enqueue waiters.
    
    wait_queue_head_t contains a spinlock_t to protect the list of waiters
    which excludes it from being used in truly atomic context on a PREEMPT_RT
    enabled kernel.
    
    The spinlock in the wait queue head cannot be replaced by a raw_spinlock
    because:
    
      - wait queues can have custom wakeup callbacks, which acquire other
        spinlock_t locks and have potentially long execution times
    
      - wake_up() walks an unbounded number of list entries during the wake up
        and may wake an unbounded number of waiters.
    
    For simplicity and performance reasons complete() should be usable on
    PREEMPT_RT enabled kernels.
    
    completions do not use custom wakeup callbacks and are usually single
    waiter, except for a few corner cases.
    
    Replace the wait queue in the completion with a simple wait queue (swait),
    which uses a raw_spinlock_t for protecting the waiter list and therefore is
    safe to use inside truly atomic regions on PREEMPT_RT.
    
    There is no semantical or functional change:
    
      - completions use the exclusive wait mode which is what swait provides
    
      - complete() wakes one exclusive waiter
    
      - complete_all() wakes all waiters while holding the lock which protects
        the wait queue against newly incoming waiters. The conversion to swait
        preserves this behaviour.
    
    complete_all() might cause unbound latencies with a large number of waiters
    being woken at once, but most complete_all() usage sites are either in
    testing or initialization code or have only a really small number of
    concurrent waiters which for now does not cause a latency problem. Keep it
    simple for now.
    
    The fixup of the warning check in the USB gadget driver is just a straight
    forward conversion of the lockless waiter check from one waitqueue type to
    the other.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Reviewed-by: Davidlohr Bueso <dbueso@suse.de>
    Reviewed-by: Joel Fernandes (Google) <joel@joelfernandes.org>
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Link: https://lkml.kernel.org/r/20200321113242.317954042@linutronix.de

commit e5d4d1756b07d9490a0269a9e68c1e05ee1feb9b
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Mar 21 12:25:58 2020 +0100

    timekeeping: Split jiffies seqlock
    
    seqlock consists of a sequence counter and a spinlock_t which is used to
    serialize the writers. spinlock_t is substituted by a "sleeping" spinlock
    on PREEMPT_RT enabled kernels which breaks the usage in the timekeeping
    code as the writers are executed in hard interrupt and therefore
    non-preemptible context even on PREEMPT_RT.
    
    The spinlock in seqlock cannot be unconditionally replaced by a
    raw_spinlock_t as many seqlock users have nesting spinlock sections or
    other code which is not suitable to run in truly atomic context on RT.
    
    Instead of providing a raw_seqlock API for a single use case, open code the
    seqlock for the jiffies use case and implement it with a raw_spinlock_t and
    a sequence counter.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Link: https://lkml.kernel.org/r/20200321113242.120587764@linutronix.de

commit afa58b49ac52dff053e1bb363a425f09dbebc0a3
Author: Clark Williams <williams@redhat.com>
Date:   Tue Oct 8 13:00:21 2019 +0200

    thermal/x86_pkg_temp: Make pkg_temp_lock a raw_spinlock_t
    
    The spinlock pkg_temp_lock has the potential of being taken in atomic
    context because it can be acquired from the thermal IRQ vector.
    It's static and limited scope so go ahead and make it a raw spinlock.
    
    Signed-off-by: Clark Williams <williams@redhat.com>
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Link: https://lore.kernel.org/r/20191008110021.2j44ayunal7fkb7i@linutronix.de

commit 8c96f1bc6fc49c724c4cdd22d3e99260263b7384
Author: He Zhe <zhe.he@windriver.com>
Date:   Thu Jan 30 22:12:00 2020 -0800

    mm/kmemleak: turn kmemleak_lock and object->lock to raw_spinlock_t
    
    kmemleak_lock as a rwlock on RT can possibly be acquired in atomic
    context which does work.
    
    Since the kmemleak operation is performed in atomic context make it a
    raw_spinlock_t so it can also be acquired on RT.  This is used for
    debugging and is not enabled by default in a production like environment
    (where performance/latency matters) so it makes sense to make it a
    raw_spinlock_t instead trying to get rid of the atomic context.  Turn
    also the kmemleak_object->lock into raw_spinlock_t which is acquired
    (nested) while the kmemleak_lock is held.
    
    The time spent in "echo scan > kmemleak" slightly improved on 64core box
    with this patch applied after boot.
    
    [bigeasy@linutronix.de: redo the description, update comments. Merge the individual bits:  He Zhe did the kmemleak_lock, Liu Haitao the ->lock and Yongxin Liu forwarded Liu's patch.]
    Link: http://lkml.kernel.org/r/20191219170834.4tah3prf2gdothz4@linutronix.de
    Link: https://lkml.kernel.org/r/20181218150744.GB20197@arrakis.emea.arm.com
    Link: https://lkml.kernel.org/r/1542877459-144382-1-git-send-email-zhe.he@windriver.com
    Link: https://lkml.kernel.org/r/20190927082230.34152-1-yongxin.liu@windriver.com
    Signed-off-by: He Zhe <zhe.he@windriver.com>
    Signed-off-by: Liu Haitao <haitao.liu@windriver.com>
    Signed-off-by: Yongxin Liu <yongxin.liu@windriver.com>
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Acked-by: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit a7d881464194920a04fb9b8c324877b32fd58a1f
Merge: f7fd41afa15d a5a9dffcc903
Author: Olof Johansson <olof@lixom.net>
Date:   Tue Jun 25 05:51:56 2019 -0700

    Merge tag 'imx-soc-5.3' of git://git.kernel.org/pub/scm/linux/kernel/git/shawnguo/linux into arm/soc
    
    i.MX SoC changes for 5.3:
     - Switch imx7d to imx-cpufreq-dt for speed-grading, as imx-cpufreq-dt
       driver can handle speed grading bits on imx7d just like on imx8mq.
     - Improve imx6 cpuidle driver to use raw_spinlock_t.  The change makes
       no difference for !RT build, but is required by RT kernel.
    
    * tag 'imx-soc-5.3' of git://git.kernel.org/pub/scm/linux/kernel/git/shawnguo/linux:
      ARM: imx: Switch imx7d to imx-cpufreq-dt for speed-grading
      ARM: imx6: cpuidle: Use raw_spinlock_t
    
    Signed-off-by: Olof Johansson <olof@lixom.net>

commit 99ae52edeba17c78753695e0d94d49c5f9e9a803
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Wed May 29 17:42:29 2019 +0200

    ARM: imx6: cpuidle: Use raw_spinlock_t
    
    The idle call back is invoked with disabled interrupts and requires
    raw_spinlock_t locks to work.
    
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Reviewed-by: Fabio Estevam <festevam@gmail.com>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

commit 4528b128bbbc138b295f1dc9ff19fb1a9552bc88
Author: Yang Shi <yang.shi@linaro.org>
Date:   Wed Feb 13 17:14:23 2019 +0100

    ARM: 8839/1: kprobe: make patch_lock a raw_spinlock_t
    
    [ Upstream commit 143c2a89e0e5fda6c6fd08d7bc1126438c19ae90 ]
    
    When running kprobe on -rt kernel, the below bug is caught:
    
    |BUG: sleeping function called from invalid context at kernel/locking/rtmutex.c:931
    |in_atomic(): 1, irqs_disabled(): 128, pid: 14, name: migration/0
    |Preemption disabled at:[<802f2b98>] cpu_stopper_thread+0xc0/0x140
    |CPU: 0 PID: 14 Comm: migration/0 Tainted: G O 4.8.3-rt2 #1
    |Hardware name: Freescale LS1021A
    |[<8025a43c>] (___might_sleep)
    |[<80b5b324>] (rt_spin_lock)
    |[<80b5c31c>] (__patch_text_real)
    |[<80b5c3ac>] (patch_text_stop_machine)
    |[<802f2920>] (multi_cpu_stop)
    
    Since patch_text_stop_machine() is called in stop_machine() which
    disables IRQ, sleepable lock should be not used in this atomic context,
     so replace patch_lock to raw lock.
    
    Signed-off-by: Yang Shi <yang.shi@linaro.org>
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 1c2bfc4636de925f47d5f4e111e32235da0ef646
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Wed Feb 13 17:14:42 2019 +0100

    ARM: 8840/1: use a raw_spinlock_t in unwind
    
    [ Upstream commit 74ffe79ae538283bbf7c155e62339f1e5c87b55a ]
    
    Mostly unwind is done with irqs enabled however SLUB may call it with
    irqs disabled while creating a new SLUB cache.
    
    I had system freeze while loading a module which called
    kmem_cache_create() on init. That means SLUB's __slab_alloc() disabled
    interrupts and then
    
    ->new_slab_objects()
     ->new_slab()
      ->setup_object()
       ->setup_object_debug()
        ->init_tracking()
         ->set_track()
          ->save_stack_trace()
           ->save_stack_trace_tsk()
            ->walk_stackframe()
             ->unwind_frame()
              ->unwind_find_idx()
               =>spin_lock_irqsave(&unwind_lock);
    
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 61c4d9023651d8a0a2f636285a9af44bd072d519
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Wed Feb 13 17:14:42 2019 +0100

    ARM: 8840/1: use a raw_spinlock_t in unwind
    
    [ Upstream commit 74ffe79ae538283bbf7c155e62339f1e5c87b55a ]
    
    Mostly unwind is done with irqs enabled however SLUB may call it with
    irqs disabled while creating a new SLUB cache.
    
    I had system freeze while loading a module which called
    kmem_cache_create() on init. That means SLUB's __slab_alloc() disabled
    interrupts and then
    
    ->new_slab_objects()
     ->new_slab()
      ->setup_object()
       ->setup_object_debug()
        ->init_tracking()
         ->set_track()
          ->save_stack_trace()
           ->save_stack_trace_tsk()
            ->walk_stackframe()
             ->unwind_frame()
              ->unwind_find_idx()
               =>spin_lock_irqsave(&unwind_lock);
    
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 3835c46e6ff51d24698487ef1e073573264dcfd6
Author: Yang Shi <yang.shi@linaro.org>
Date:   Wed Feb 13 17:14:23 2019 +0100

    ARM: 8839/1: kprobe: make patch_lock a raw_spinlock_t
    
    [ Upstream commit 143c2a89e0e5fda6c6fd08d7bc1126438c19ae90 ]
    
    When running kprobe on -rt kernel, the below bug is caught:
    
    |BUG: sleeping function called from invalid context at kernel/locking/rtmutex.c:931
    |in_atomic(): 1, irqs_disabled(): 128, pid: 14, name: migration/0
    |Preemption disabled at:[<802f2b98>] cpu_stopper_thread+0xc0/0x140
    |CPU: 0 PID: 14 Comm: migration/0 Tainted: G O 4.8.3-rt2 #1
    |Hardware name: Freescale LS1021A
    |[<8025a43c>] (___might_sleep)
    |[<80b5b324>] (rt_spin_lock)
    |[<80b5c31c>] (__patch_text_real)
    |[<80b5c3ac>] (patch_text_stop_machine)
    |[<802f2920>] (multi_cpu_stop)
    
    Since patch_text_stop_machine() is called in stop_machine() which
    disables IRQ, sleepable lock should be not used in this atomic context,
     so replace patch_lock to raw lock.
    
    Signed-off-by: Yang Shi <yang.shi@linaro.org>
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 91583411b5d1cee67b1e0f83754430aed5a1535f
Author: Yang Shi <yang.shi@linaro.org>
Date:   Wed Feb 13 17:14:23 2019 +0100

    ARM: 8839/1: kprobe: make patch_lock a raw_spinlock_t
    
    [ Upstream commit 143c2a89e0e5fda6c6fd08d7bc1126438c19ae90 ]
    
    When running kprobe on -rt kernel, the below bug is caught:
    
    |BUG: sleeping function called from invalid context at kernel/locking/rtmutex.c:931
    |in_atomic(): 1, irqs_disabled(): 128, pid: 14, name: migration/0
    |Preemption disabled at:[<802f2b98>] cpu_stopper_thread+0xc0/0x140
    |CPU: 0 PID: 14 Comm: migration/0 Tainted: G O 4.8.3-rt2 #1
    |Hardware name: Freescale LS1021A
    |[<8025a43c>] (___might_sleep)
    |[<80b5b324>] (rt_spin_lock)
    |[<80b5c31c>] (__patch_text_real)
    |[<80b5c3ac>] (patch_text_stop_machine)
    |[<802f2920>] (multi_cpu_stop)
    
    Since patch_text_stop_machine() is called in stop_machine() which
    disables IRQ, sleepable lock should be not used in this atomic context,
     so replace patch_lock to raw lock.
    
    Signed-off-by: Yang Shi <yang.shi@linaro.org>
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 5e3f6ba82ed450d62ac7910b0fe026d31eb2aa5b
Author: Yang Shi <yang.shi@linaro.org>
Date:   Wed Feb 13 17:14:23 2019 +0100

    ARM: 8839/1: kprobe: make patch_lock a raw_spinlock_t
    
    [ Upstream commit 143c2a89e0e5fda6c6fd08d7bc1126438c19ae90 ]
    
    When running kprobe on -rt kernel, the below bug is caught:
    
    |BUG: sleeping function called from invalid context at kernel/locking/rtmutex.c:931
    |in_atomic(): 1, irqs_disabled(): 128, pid: 14, name: migration/0
    |Preemption disabled at:[<802f2b98>] cpu_stopper_thread+0xc0/0x140
    |CPU: 0 PID: 14 Comm: migration/0 Tainted: G O 4.8.3-rt2 #1
    |Hardware name: Freescale LS1021A
    |[<8025a43c>] (___might_sleep)
    |[<80b5b324>] (rt_spin_lock)
    |[<80b5c31c>] (__patch_text_real)
    |[<80b5c3ac>] (patch_text_stop_machine)
    |[<802f2920>] (multi_cpu_stop)
    
    Since patch_text_stop_machine() is called in stop_machine() which
    disables IRQ, sleepable lock should be not used in this atomic context,
     so replace patch_lock to raw lock.
    
    Signed-off-by: Yang Shi <yang.shi@linaro.org>
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit a05948319bf995b68b136680ece97341a79e207e
Author: Yang Shi <yang.shi@linaro.org>
Date:   Wed Feb 13 17:14:23 2019 +0100

    ARM: 8839/1: kprobe: make patch_lock a raw_spinlock_t
    
    [ Upstream commit 143c2a89e0e5fda6c6fd08d7bc1126438c19ae90 ]
    
    When running kprobe on -rt kernel, the below bug is caught:
    
    |BUG: sleeping function called from invalid context at kernel/locking/rtmutex.c:931
    |in_atomic(): 1, irqs_disabled(): 128, pid: 14, name: migration/0
    |Preemption disabled at:[<802f2b98>] cpu_stopper_thread+0xc0/0x140
    |CPU: 0 PID: 14 Comm: migration/0 Tainted: G O 4.8.3-rt2 #1
    |Hardware name: Freescale LS1021A
    |[<8025a43c>] (___might_sleep)
    |[<80b5b324>] (rt_spin_lock)
    |[<80b5c31c>] (__patch_text_real)
    |[<80b5c3ac>] (patch_text_stop_machine)
    |[<802f2920>] (multi_cpu_stop)
    
    Since patch_text_stop_machine() is called in stop_machine() which
    disables IRQ, sleepable lock should be not used in this atomic context,
     so replace patch_lock to raw lock.
    
    Signed-off-by: Yang Shi <yang.shi@linaro.org>
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit dbda5b6625bda33a1369a6aadf756287fd70c1d8
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Wed Feb 13 17:14:42 2019 +0100

    ARM: 8840/1: use a raw_spinlock_t in unwind
    
    [ Upstream commit 74ffe79ae538283bbf7c155e62339f1e5c87b55a ]
    
    Mostly unwind is done with irqs enabled however SLUB may call it with
    irqs disabled while creating a new SLUB cache.
    
    I had system freeze while loading a module which called
    kmem_cache_create() on init. That means SLUB's __slab_alloc() disabled
    interrupts and then
    
    ->new_slab_objects()
     ->new_slab()
      ->setup_object()
       ->setup_object_debug()
        ->init_tracking()
         ->set_track()
          ->save_stack_trace()
           ->save_stack_trace_tsk()
            ->walk_stackframe()
             ->unwind_frame()
              ->unwind_find_idx()
               =>spin_lock_irqsave(&unwind_lock);
    
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit d81bdb3c17f1a2f760f257c60950c176df1e77ef
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Wed Feb 13 17:14:42 2019 +0100

    ARM: 8840/1: use a raw_spinlock_t in unwind
    
    [ Upstream commit 74ffe79ae538283bbf7c155e62339f1e5c87b55a ]
    
    Mostly unwind is done with irqs enabled however SLUB may call it with
    irqs disabled while creating a new SLUB cache.
    
    I had system freeze while loading a module which called
    kmem_cache_create() on init. That means SLUB's __slab_alloc() disabled
    interrupts and then
    
    ->new_slab_objects()
     ->new_slab()
      ->setup_object()
       ->setup_object_debug()
        ->init_tracking()
         ->set_track()
          ->save_stack_trace()
           ->save_stack_trace_tsk()
            ->walk_stackframe()
             ->unwind_frame()
              ->unwind_find_idx()
               =>spin_lock_irqsave(&unwind_lock);
    
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 8b847ace66d6c4d540855050c21aafc92a953213
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Wed Feb 13 17:14:42 2019 +0100

    ARM: 8840/1: use a raw_spinlock_t in unwind
    
    [ Upstream commit 74ffe79ae538283bbf7c155e62339f1e5c87b55a ]
    
    Mostly unwind is done with irqs enabled however SLUB may call it with
    irqs disabled while creating a new SLUB cache.
    
    I had system freeze while loading a module which called
    kmem_cache_create() on init. That means SLUB's __slab_alloc() disabled
    interrupts and then
    
    ->new_slab_objects()
     ->new_slab()
      ->setup_object()
       ->setup_object_debug()
        ->init_tracking()
         ->set_track()
          ->save_stack_trace()
           ->save_stack_trace_tsk()
            ->walk_stackframe()
             ->unwind_frame()
              ->unwind_find_idx()
               =>spin_lock_irqsave(&unwind_lock);
    
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 43e01fefac9d571cad781e3ae164dbcc28a146ab
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Wed Feb 13 17:14:42 2019 +0100

    ARM: 8840/1: use a raw_spinlock_t in unwind
    
    [ Upstream commit 74ffe79ae538283bbf7c155e62339f1e5c87b55a ]
    
    Mostly unwind is done with irqs enabled however SLUB may call it with
    irqs disabled while creating a new SLUB cache.
    
    I had system freeze while loading a module which called
    kmem_cache_create() on init. That means SLUB's __slab_alloc() disabled
    interrupts and then
    
    ->new_slab_objects()
     ->new_slab()
      ->setup_object()
       ->setup_object_debug()
        ->init_tracking()
         ->set_track()
          ->save_stack_trace()
           ->save_stack_trace_tsk()
            ->walk_stackframe()
             ->unwind_frame()
              ->unwind_find_idx()
               =>spin_lock_irqsave(&unwind_lock);
    
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 6ac972dd4db42ef4e298669647b946de4e0243aa
Author: Julien Grall <julien.grall@arm.com>
Date:   Wed Mar 13 11:40:34 2019 +0000

    tty/sysrq: Convert show_lock to raw_spinlock_t
    
    Systems which don't provide arch_trigger_cpumask_backtrace() will
    invoke showacpu() from a smp_call_function() function which is invoked
    with disabled interrupts even on -RT systems.
    
    The function acquires the show_lock lock which only purpose is to
    ensure that the CPUs don't print simultaneously. Otherwise the
    output would clash and it would be hard to tell the output from CPUx
    apart from CPUy.
    
    On -RT the spin_lock() can not be acquired from this context. A
    raw_spin_lock() is required. It will introduce the system's latency
    by performing the sysrq request and other CPUs will block on the lock
    until the request is done. This is okay because the user asked for a
    backtrace of all active CPUs and under "normal circumstances in
    production" this path should not be triggered.
    
    Signed-off-by: Julien Grall <julien.grall@arm.com>
    [bigeasy@linuxtronix.de: commit description]
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Acked-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 0be288630752e6358d02eba7b283c1783a5c7c38
Merge: e8a71a386689 4c2741ac5e10
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Mar 15 14:37:46 2019 -0700

    Merge tag 'for-linus' of git://git.armlinux.org.uk/~rmk/linux-arm
    
    Pull ARM updates from Russell King:
    
     - An improvement from Ard Biesheuvel, who noted that the identity map
       setup was taking a long time due to flush_cache_louis().
    
     - Update a comment about dma_ops from Wolfram Sang.
    
     - Remove use of "-p" with ld, where this flag has been a no-op since
       2004.
    
     - Remove the printing of the virtual memory layout, which is no longer
       useful since we hide pointers.
    
     - Correct SCU help text.
    
     - Remove legacy TWD registration method.
    
     - Add pgprot_device() implementation for mapping PCI sysfs resource
       files.
    
     - Initialise PFN limits earlier for kmemleak.
    
     - Fix argument count to match macro definition (affects clang builds)
    
     - Use unified assembler language almost everywhere for clang, and other
       clang improvements (from Stefan Agner, Nathan Chancellor).
    
     - Support security extension for noMMU and other noMMU cleanups (from
       Vladimir Murzin).
    
     - Remove unnecessary SMP bringup code (which was incorrectly copy'n'
       pasted from the ARM platform implementations) and remove it from the
       arch code to discourge further copys of it appearing.
    
     - Add Cortex A9 erratum preventing kexec working on some SoCs.
    
     - AMBA bus identification updates from Mike Leach.
    
     - More use of raw spinlocks to avoid -RT kernel issues (from Yang Shi
       and Sebastian Andrzej Siewior).
    
     - MCPM hyp/svc mode mismatch fixes from Marek Szyprowski.
    
    * tag 'for-linus' of git://git.armlinux.org.uk/~rmk/linux-arm: (32 commits)
      ARM: 8849/1: NOMMU: Fix encodings for PMSAv8's PRBAR4/PRLAR4
      ARM: 8848/1: virt: Align GIC version check with arm64 counterpart
      ARM: 8847/1: pm: fix HYP/SVC mode mismatch when MCPM is used
      ARM: 8845/1: use unified assembler in c files
      ARM: 8844/1: use unified assembler in assembly files
      ARM: 8843/1: use unified assembler in headers
      ARM: 8841/1: use unified assembler in macros
      ARM: 8840/1: use a raw_spinlock_t in unwind
      ARM: 8839/1: kprobe: make patch_lock a raw_spinlock_t
      ARM: 8837/1: coresight: etmv4: Update ID register table to add UCI support
      ARM: 8836/1: drivers: amba: Update component matching to use the CoreSight UCI values.
      ARM: 8838/1: drivers: amba: Updates to component identification for driver matching.
      ARM: 8833/1: Ensure that NEON code always compiles with Clang
      ARM: avoid Cortex-A9 livelock on tight dmb loops
      ARM: smp: remove arch-provided "pen_release"
      ARM: actions: remove boot_lock and pen_release
      ARM: oxnas: remove CPU hotplug implementation
      ARM: qcom: remove unnecessary boot_lock
      ARM: 8832/1: NOMMU: Limit visibility for CONFIG_FLASH_{MEM_BASE,SIZE}
      ARM: 8831/1: NOMMU: pmsa-v8: remove unneeded semicolon
      ...

commit 74ffe79ae538283bbf7c155e62339f1e5c87b55a
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Wed Feb 13 17:14:42 2019 +0100

    ARM: 8840/1: use a raw_spinlock_t in unwind
    
    Mostly unwind is done with irqs enabled however SLUB may call it with
    irqs disabled while creating a new SLUB cache.
    
    I had system freeze while loading a module which called
    kmem_cache_create() on init. That means SLUB's __slab_alloc() disabled
    interrupts and then
    
    ->new_slab_objects()
     ->new_slab()
      ->setup_object()
       ->setup_object_debug()
        ->init_tracking()
         ->set_track()
          ->save_stack_trace()
           ->save_stack_trace_tsk()
            ->walk_stackframe()
             ->unwind_frame()
              ->unwind_find_idx()
               =>spin_lock_irqsave(&unwind_lock);
    
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>

commit 143c2a89e0e5fda6c6fd08d7bc1126438c19ae90
Author: Yang Shi <yang.shi@linaro.org>
Date:   Wed Feb 13 17:14:23 2019 +0100

    ARM: 8839/1: kprobe: make patch_lock a raw_spinlock_t
    
    When running kprobe on -rt kernel, the below bug is caught:
    
    |BUG: sleeping function called from invalid context at kernel/locking/rtmutex.c:931
    |in_atomic(): 1, irqs_disabled(): 128, pid: 14, name: migration/0
    |Preemption disabled at:[<802f2b98>] cpu_stopper_thread+0xc0/0x140
    |CPU: 0 PID: 14 Comm: migration/0 Tainted: G O 4.8.3-rt2 #1
    |Hardware name: Freescale LS1021A
    |[<8025a43c>] (___might_sleep)
    |[<80b5b324>] (rt_spin_lock)
    |[<80b5c31c>] (__patch_text_real)
    |[<80b5c3ac>] (patch_text_stop_machine)
    |[<802f2920>] (multi_cpu_stop)
    
    Since patch_text_stop_machine() is called in stop_machine() which
    disables IRQ, sleepable lock should be not used in this atomic context,
     so replace patch_lock to raw lock.
    
    Signed-off-by: Yang Shi <yang.shi@linaro.org>
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>

commit 345671ea0f9258f410eb057b9ced9cefbbe5dc78
Merge: 4904008165c8 22146c3ce989
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Oct 26 19:33:41 2018 -0700

    Merge branch 'akpm' (patches from Andrew)
    
    Merge updates from Andrew Morton:
    
     - a few misc things
    
     - ocfs2 updates
    
     - most of MM
    
    * emailed patches from Andrew Morton <akpm@linux-foundation.org>: (132 commits)
      hugetlbfs: dirty pages as they are added to pagecache
      mm: export add_swap_extent()
      mm: split SWP_FILE into SWP_ACTIVATED and SWP_FS
      tools/testing/selftests/vm/map_fixed_noreplace.c: add test for MAP_FIXED_NOREPLACE
      mm: thp: relocate flush_cache_range() in migrate_misplaced_transhuge_page()
      mm: thp: fix mmu_notifier in migrate_misplaced_transhuge_page()
      mm: thp: fix MADV_DONTNEED vs migrate_misplaced_transhuge_page race condition
      mm/kasan/quarantine.c: make quarantine_lock a raw_spinlock_t
      mm/gup: cache dev_pagemap while pinning pages
      Revert "x86/e820: put !E820_TYPE_RAM regions into memblock.reserved"
      mm: return zero_resv_unavail optimization
      mm: zero remaining unavailable struct pages
      tools/testing/selftests/vm/gup_benchmark.c: add MAP_HUGETLB option
      tools/testing/selftests/vm/gup_benchmark.c: add MAP_SHARED option
      tools/testing/selftests/vm/gup_benchmark.c: allow user specified file
      tools/testing/selftests/vm/gup_benchmark.c: fix 'write' flag usage
      mm/gup_benchmark.c: add additional pinning methods
      mm/gup_benchmark.c: time put_page()
      mm: don't raise MEMCG_OOM event due to failed high-order allocation
      mm/page-writeback.c: fix range_cyclic writeback vs writepages deadlock
      ...

commit 026d1eaf5ef1a5d6258b46e4e411cd9f5ab8c41d
Author: Clark Williams <williams@redhat.com>
Date:   Fri Oct 26 15:10:32 2018 -0700

    mm/kasan/quarantine.c: make quarantine_lock a raw_spinlock_t
    
    The static lock quarantine_lock is used in quarantine.c to protect the
    quarantine queue datastructures.  It is taken inside quarantine queue
    manipulation routines (quarantine_put(), quarantine_reduce() and
    quarantine_remove_cache()), with IRQs disabled.  This is not a problem on
    a stock kernel but is problematic on an RT kernel where spin locks are
    sleeping spinlocks, which can sleep and can not be acquired with disabled
    interrupts.
    
    Convert the quarantine_lock to a raw spinlock_t.  The usage of
    quarantine_lock is confined to quarantine.c and the work performed while
    the lock is held is used for debug purpose.
    
    [bigeasy@linutronix.de: slightly altered the commit message]
    Link: http://lkml.kernel.org/r/20181010214945.5owshc3mlrh74z4b@linutronix.de
    Signed-off-by: Clark Williams <williams@redhat.com>
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Acked-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Acked-by: Dmitry Vyukov <dvyukov@google.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit cee1352f792646ae87e65f8bfb0ae91ff3d2cb95
Merge: e2b623fbe6a3 d0346559a7c3
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Oct 23 12:31:17 2018 +0100

    Merge branch 'core-rcu-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull RCU updates from Ingo Molnar:
     "The biggest change in this cycle is the conclusion of the big
      'simplify RCU to two primary flavors' consolidation work - i.e.
      there's a single RCU flavor for any kernel variant (PREEMPT and
      !PREEMPT):
    
        - Consolidate the RCU-bh, RCU-preempt, and RCU-sched flavors into a
          single flavor similar to RCU-sched in !PREEMPT kernels and into a
          single flavor similar to RCU-preempt (but also waiting on
          preempt-disabled sequences of code) in PREEMPT kernels.
    
          This branch also includes a refactoring of
          rcu_{nmi,irq}_{enter,exit}() from Byungchul Park.
    
        - Now that there is only one RCU flavor in any given running kernel,
          the many "rsp" pointers are no longer required, and this cleanup
          series removes them.
    
        - This branch carries out additional cleanups made possible by the
          RCU flavor consolidation, including inlining now-trivial
          functions, updating comments and definitions, and removing
          now-unneeded rcutorture scenarios.
    
        - Now that there is only one flavor of RCU in any running kernel,
          there is also only on rcu_data structure per CPU. This means that
          the rcu_dynticks structure can be merged into the rcu_data
          structure, a task taken on by this branch. This branch also
          contains a -rt-related fix from Mike Galbraith.
    
      There were also other updates:
    
        - Documentation updates, including some good-eye catches from Joel
          Fernandes.
    
        - SRCU updates, most notably changes enabling call_srcu() to be
          invoked very early in the boot sequence.
    
        - Torture-test updates, including some preliminary work towards
          making rcutorture better able to find problems that result in
          insufficient grace-period forward progress.
    
        - Initial changes to RCU to better promote forward progress of grace
          periods, including fixing a bug found by Marius Hillenbrand and
          David Woodhouse, with the fix suggested by Peter Zijlstra"
    
    * 'core-rcu-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (140 commits)
      srcu: Make early-boot call_srcu() reuse workqueue lists
      rcutorture: Test early boot call_srcu()
      srcu: Make call_srcu() available during very early boot
      rcu: Convert rcu_state.ofl_lock to raw_spinlock_t
      rcu: Remove obsolete ->dynticks_fqs and ->cond_resched_completed
      rcu: Switch ->dynticks to rcu_data structure, remove rcu_dynticks
      rcu: Switch dyntick nesting counters to rcu_data structure
      rcu: Switch urgent quiescent-state requests to rcu_data structure
      rcu: Switch lazy counts to rcu_data structure
      rcu: Switch last accelerate/advance to rcu_data structure
      rcu: Switch ->tick_nohz_enabled_snap to rcu_data structure
      rcu: Merge rcu_dynticks structure into rcu_data structure
      rcu: Remove unused rcu_dynticks_snap() from Tiny RCU
      rcu: Convert "1UL << x" to "BIT(x)"
      rcu: Avoid resched_cpu() when rescheduling the current CPU
      rcu: More aggressively enlist scheduler aid for nohz_full CPUs
      rcu: Compute jiffies_till_sched_qs from other kernel parameters
      rcu: Provide functions for determining if call_rcu() has been invoked
      rcu: Eliminate ->rcu_qs_ctr from the rcu_dynticks structure
      rcu: Motivate Tiny RCU forward progress
      ...

commit 894d45bbf7e7569ec2aa845155801fd503b5f1bf
Author: Mike Galbraith <efault@gmx.de>
Date:   Wed Aug 15 09:05:29 2018 -0700

    rcu: Convert rcu_state.ofl_lock to raw_spinlock_t
    
    1e64b15a4b10 ("rcu: Fix grace-period hangs due to race with CPU offline")
    added spinlock_t ofl_lock to the rcu_state structure, then takes it with
    preemption disabled during CPU offline, which gives the -rt patchset's
    sleeping spinlock heartburn.
    
    This commit therefore converts ->ofl_lock to raw_spinlock_t.
    
    Signed-off-by: Mike Galbraith <efault@gmx.de>
    Signed-off-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Cc: Sebastian Andrzej Siewior <bigeasy@linutronix.de>

commit c06f5a018f710ff24ef7c1b922d2b6704c35dd8c
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Mon Apr 23 18:10:23 2018 +0200

    delayacct: Use raw_spinlocks
    
    [ Upstream commit 02acc80d19edb0d5684c997b2004ad19f9f5236e ]
    
    try_to_wake_up() might invoke delayacct_blkio_end() while holding the
    pi_lock (which is a raw_spinlock_t). delayacct_blkio_end() acquires
    task_delay_info.lock which is a spinlock_t. This causes a might sleep splat
    on -RT where non raw spinlocks are converted to 'sleeping' spinlocks.
    
    task_delay_info.lock is only held for a short amount of time so it's not a
    problem latency wise to make convert it to a raw spinlock.
    
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Balbir Singh <bsingharora@gmail.com>
    Link: https://lkml.kernel.org/r/20180423161024.6710-1-bigeasy@linutronix.de
    Signed-off-by: Sasha Levin <alexander.levin@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit fe52ec8c67bf1b2b026e857b7b49c6c2f3b6363a
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Mon Apr 23 18:10:23 2018 +0200

    delayacct: Use raw_spinlocks
    
    [ Upstream commit 02acc80d19edb0d5684c997b2004ad19f9f5236e ]
    
    try_to_wake_up() might invoke delayacct_blkio_end() while holding the
    pi_lock (which is a raw_spinlock_t). delayacct_blkio_end() acquires
    task_delay_info.lock which is a spinlock_t. This causes a might sleep splat
    on -RT where non raw spinlocks are converted to 'sleeping' spinlocks.
    
    task_delay_info.lock is only held for a short amount of time so it's not a
    problem latency wise to make convert it to a raw spinlock.
    
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Balbir Singh <bsingharora@gmail.com>
    Link: https://lkml.kernel.org/r/20180423161024.6710-1-bigeasy@linutronix.de
    Signed-off-by: Sasha Levin <alexander.levin@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit f4fe74cc909bf811cd9cc7fd84f5a7514e06a7e1
Merge: 3c89adb0d111 2448d1399bac
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jun 5 10:08:27 2018 -0700

    Merge tag 'acpi-4.18-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull ACPI updates from Rafael Wysocki:
     "These update the ACPICA code in the kernel to the 20180508 upstream
      revision and make it support the RT patch, add CPPC v3 support to the
      ACPI CPPC library, add a WDAT-based watchdog quirk to prevent clashes
      with the RTC, add quirks to the ACPI AC and battery drivers, and
      update the ACPI SoC drivers.
    
      Specifics:
    
       - Update the ACPICA code in the kernel to the 20180508 upstream
         revision including:
           * iASL -tc option enhancement (Bob Moore).
           * Debugger improvements (Bob Moore).
           * Support for tables larger than 1 MB in acpidump/acpixtract (Bob
             Moore).
           * Minor fixes and cleanups (Colin Ian King, Toomas Soome).
    
       - Make the ACPICA code in the kernel support the RT patch (Sebastian
         Andrzej Siewior, Steven Rostedt).
    
       - Add a kmemleak annotation to the ACPICA code (Larry Finger).
    
       - Add CPPC v3 support to the ACPI CPPC library and fix two issues
         related to CPPC (Prashanth Prakash, Al Stone).
    
       - Add an ACPI WDAT-based watchdog quirk to prefer iTCO_wdt on systems
         where WDAT clashes with the RTC SRAM (Mika Westerberg).
    
       - Add some quirks to the ACPI AC and battery drivers (Carlo Caione,
         Hans de Goede).
    
       - Update the ACPI SoC drivers for Intel (LPSS) and AMD (APD)
         platforms (Akshu Agrawal, Hans de Goede).
    
       - Fix up some assorted minor issues (Al Stone, Laszlo Toth, Mathieu
         Malaterre)"
    
    * tag 'acpi-4.18-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (32 commits)
      ACPICA: Mark acpi_ut_create_internal_object_dbg() memory allocations as non-leaks
      ACPI / watchdog: Prefer iTCO_wdt always when WDAT table uses RTC SRAM
      mailbox: PCC: erroneous error message when parsing ACPI PCCT
      ACPICA: Update version to 20180508
      ACPICA: acpidump/acpixtract: Support for tables larger than 1MB
      ACPI: APD: Add AMD misc clock handler support
      clk: x86: Add ST oscout platform clock
      ACPICA: Update version to 20180427
      ACPICA: Debugger: Removed direct support for EC address space in "Test Objects"
      ACPICA: Debugger: Add Package support for "test objects" command
      ACPICA: Improve error messages for the namespace root node
      ACPICA: Fix potential infinite loop in acpi_rs_dump_byte_list
      ACPICA: vsnprintf: this statement may fall through
      ACPICA: Tables: Fix spelling mistake in comment
      ACPICA: iASL: Enhance the -tc option (create AML hex file in C)
      ACPI: Add missing prototype_for arch_post_acpi_subsys_init()
      ACPI / tables: improve comments regarding acpi_parse_entries_array()
      ACPICA: Convert acpi_gbl_hardware lock back to an acpi_raw_spinlock
      ACPICA: provide abstraction for raw_spinlock_t
      ACPI / CPPC: Fix invalid PCC channel status errors
      ...

commit ba609f7f21e45fc1170aa6beffae922a82c1b2d8
Merge: 5a802a7a285c 087ec15606b4
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Jun 4 10:43:12 2018 +0200

    Merge branch 'acpica'
    
    * acpica:
      ACPICA: Mark acpi_ut_create_internal_object_dbg() memory allocations as non-leaks
      ACPICA: Update version to 20180508
      ACPICA: acpidump/acpixtract: Support for tables larger than 1MB
      ACPICA: Update version to 20180427
      ACPICA: Debugger: Removed direct support for EC address space in "Test Objects"
      ACPICA: Debugger: Add Package support for "test objects" command
      ACPICA: Improve error messages for the namespace root node
      ACPICA: Fix potential infinite loop in acpi_rs_dump_byte_list
      ACPICA: vsnprintf: this statement may fall through
      ACPICA: Tables: Fix spelling mistake in comment
      ACPICA: iASL: Enhance the -tc option (create AML hex file in C)
      ACPICA: Convert acpi_gbl_hardware lock back to an acpi_raw_spinlock
      ACPICA: provide abstraction for raw_spinlock_t

commit c3052594c8ded984ceab3725f63990dfdea1e58f
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Wed Apr 25 16:28:26 2018 +0200

    ACPICA: provide abstraction for raw_spinlock_t
    
    Provide a new lock type acpi_raw_spinlock which is implemented as
    raw_spinlock_t on Linux. This type should be used in code which covers
    small areas of code and disables interrupts only for short time even on
    a realtime OS.
    There is a fallback to spinlock_t if an OS does not provide an
    implementation for acpi_raw_spinlock.
    
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

commit 02acc80d19edb0d5684c997b2004ad19f9f5236e
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Mon Apr 23 18:10:23 2018 +0200

    delayacct: Use raw_spinlocks
    
    try_to_wake_up() might invoke delayacct_blkio_end() while holding the
    pi_lock (which is a raw_spinlock_t). delayacct_blkio_end() acquires
    task_delay_info.lock which is a spinlock_t. This causes a might sleep splat
    on -RT where non raw spinlocks are converted to 'sleeping' spinlocks.
    
    task_delay_info.lock is only held for a short amount of time so it's not a
    problem latency wise to make convert it to a raw spinlock.
    
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Balbir Singh <bsingharora@gmail.com>
    Link: https://lkml.kernel.org/r/20180423161024.6710-1-bigeasy@linutronix.de

commit 3563289208ecef339853692ecbf8690084744b53
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Fri Mar 16 14:37:33 2018 -0300

    perf annotate: Use the default annotation options for --stdio2
    
    With an empty '[annotate]' section in ~/.perfconfig:
    
      # perf record -a --all-kernel -e '{cycles,instructions}:P' sleep 5
      [ perf record: Woken up 1 times to write data ]
      [ perf record: Captured and wrote 2.243 MB perf.data (5513 samples) ]
      # perf annotate --stdio2 _raw_spin_lock | head -20
    
                         Disassembly of section .text:
    
                         ffffffff81868790 <_raw_spin_lock>:
                         _raw_spin_lock():
                         EXPORT_SYMBOL(_raw_spin_trylock_bh);
                         #endif
    
                         #ifndef CONFIG_INLINE_SPIN_LOCK
                         void __lockfunc _raw_spin_lock(raw_spinlock_t *lock)
                         {
                         → callq  __fentry__
                         atomic_cmpxchg():
                                 return xadd(&v->counter, -i);
                         }
    
                         static __always_inline int atomic_cmpxchg(atomic_t *v, int old, int new)
                         {
      # perf annotate --stdio2 _raw_spin_lock | head -20
                         → callq  __fentry__
                           xor    %eax,%eax
                           mov    $0x1,%edx
       87.50 100.00        lock   cmpxchg %edx,(%rdi)
        6.25   0.00        test   %eax,%eax
                         ↓ jne    16
        6.25   0.00        repz   retq
                     16:   mov    %eax,%esi
                         ↑ jmpq   ffffffff810e96b0 <queued_spin_lock_slowpath>
      #
      # cat ~/.perfconfig
      [annotate]
    
        hide_src_code = false
        show_linenr = true
      # perf annotate --stdio2 _raw_spin_lock | head -20
    
                     3   Disassembly of section .text:
    
                     5   ffffffff81868790 <_raw_spin_lock>:
                     6   _raw_spin_lock():
                     143 EXPORT_SYMBOL(_raw_spin_trylock_bh);
                     144 #endif
    
                     146 #ifndef CONFIG_INLINE_SPIN_LOCK
                     147 void __lockfunc _raw_spin_lock(raw_spinlock_t *lock)
                     148 {
                         → callq  __fentry__
                     150 atomic_cmpxchg():
                     187         return xadd(&v->counter, -i);
                     188 }
    
                     190 static __always_inline int atomic_cmpxchg(atomic_t *v, int old, int new)
                     191 {
      #
      # cat ~/.perfconfig
      [annotate]
    
        hide_src_code = true
        show_total_period = true
      # perf annotate --stdio2 _raw_spin_lock | head -20
                                   → callq  __fentry__
                                     xor    %eax,%eax
                                     mov    $0x1,%edx
          1411316      152339        lock   cmpxchg %edx,(%rdi)
           344694           0        test   %eax,%eax
                                   ↓ jne    16
            80806           0        repz   retq
                               16:   mov    %eax,%esi
                                   ↑ jmpq   ffffffff810e96b0 <queued_spin_lock_slowpath>
      #
    
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Andi Kleen <ak@linux.intel.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Jin Yao <yao.jin@linux.intel.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Wang Nan <wangnan0@huawei.com>
    Link: https://lkml.kernel.org/n/tip-nu4rxg5zkdtgs1b2gc40p7v7@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

commit 70b7aa7a87b4593f50f634dc721e18bd1f9e5448
Author: John Keeping <john@metanate.com>
Date:   Thu Mar 23 10:59:29 2017 +0000

    pinctrl: rockchip: convert to raw spinlock
    
    This lock is used from rockchip_irq_set_type() which is part of the
    irq_chip implementation and thus must use raw_spinlock_t as documented
    in Documentation/gpio/driver.txt.
    
    Signed-off-by: John Keeping <john@metanate.com>
    Reviewed-by: Heiko Stuebner <heiko@sntech.de>
    Tested-by: Heiko Stuebner <heiko@sntech.de>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

commit b716d0f38305a2bfe98379ce884e34802e2fcadf
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Thu May 28 10:22:10 2015 +0200

    mtd: dc21285: use raw spinlock functions for nw_gpio_lock
    
    commit e5babdf928e5d0c432a8d4b99f20421ce14d1ab6 upstream.
    
    Since commit bd31b85960a7 (which is in 3.2-rc1) nw_gpio_lock is a raw spinlock
    that needs usage of the corresponding raw functions.
    
    This fixes:
    
      drivers/mtd/maps/dc21285.c: In function 'nw_en_write':
      drivers/mtd/maps/dc21285.c:41:340: warning: passing argument 1 of 'spinlock_check' from incompatible pointer type
        spin_lock_irqsave(&nw_gpio_lock, flags);
    
      In file included from include/linux/seqlock.h:35:0,
                       from include/linux/time.h:5,
                       from include/linux/stat.h:18,
                       from include/linux/module.h:10,
                       from drivers/mtd/maps/dc21285.c:8:
      include/linux/spinlock.h:299:102: note: expected 'struct spinlock_t *' but argument is of type 'struct raw_spinlock_t *'
       static inline raw_spinlock_t *spinlock_check(spinlock_t *lock)
                                                                                                            ^
      drivers/mtd/maps/dc21285.c:43:25: warning: passing argument 1 of 'spin_unlock_irqrestore' from incompatible pointer type
        spin_unlock_irqrestore(&nw_gpio_lock, flags);
                               ^
      In file included from include/linux/seqlock.h:35:0,
                       from include/linux/time.h:5,
                       from include/linux/stat.h:18,
                       from include/linux/module.h:10,
                       from drivers/mtd/maps/dc21285.c:8:
      include/linux/spinlock.h:370:91: note: expected 'struct spinlock_t *' but argument is of type 'struct raw_spinlock_t *'
       static inline void spin_unlock_irqrestore(spinlock_t *lock, unsigned long flags)
    
    Fixes: bd31b85960a7 ("locking, ARM: Annotate low level hw locks as raw")
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Signed-off-by: Zefan Li <lizefan@huawei.com>

commit 627c89b4d7c0a916b7702e23ded6e063dcb14ad5
Author: Axel Lin <axel.lin@ingics.com>
Date:   Wed Aug 5 22:37:41 2015 +0800

    gpio: omap: Fix missing raw locks conversion
    
    Fix below build warning:
      CC      drivers/gpio/gpio-omap.o
    drivers/gpio/gpio-omap.c: In function 'omap_gpio_irq_type':
    drivers/gpio/gpio-omap.c:504:3: warning: passing argument 1 of 'spin_unlock_irqrestore' from incompatible pointer type [enabled by default]
    include/linux/spinlock.h:360:29: note: expected 'struct spinlock_t *' but argument is of type 'struct raw_spinlock_t *'
    
    Fixes: commit 4dbada2be460 ("gpio: omap: use raw locks for locking")
    Signed-off-by: Axel Lin <axel.lin@ingics.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

commit 3d0b261c65b60df9dde561616217f93f8e411bdb
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Thu May 28 10:22:10 2015 +0200

    mtd: dc21285: use raw spinlock functions for nw_gpio_lock
    
    commit e5babdf928e5d0c432a8d4b99f20421ce14d1ab6 upstream.
    
    Since commit bd31b85960a7 (which is in 3.2-rc1) nw_gpio_lock is a raw spinlock
    that needs usage of the corresponding raw functions.
    
    This fixes:
    
      drivers/mtd/maps/dc21285.c: In function 'nw_en_write':
      drivers/mtd/maps/dc21285.c:41:340: warning: passing argument 1 of 'spinlock_check' from incompatible pointer type
        spin_lock_irqsave(&nw_gpio_lock, flags);
    
      In file included from include/linux/seqlock.h:35:0,
                       from include/linux/time.h:5,
                       from include/linux/stat.h:18,
                       from include/linux/module.h:10,
                       from drivers/mtd/maps/dc21285.c:8:
      include/linux/spinlock.h:299:102: note: expected 'struct spinlock_t *' but argument is of type 'struct raw_spinlock_t *'
       static inline raw_spinlock_t *spinlock_check(spinlock_t *lock)
                                                                                                            ^
      drivers/mtd/maps/dc21285.c:43:25: warning: passing argument 1 of 'spin_unlock_irqrestore' from incompatible pointer type
        spin_unlock_irqrestore(&nw_gpio_lock, flags);
                               ^
      In file included from include/linux/seqlock.h:35:0,
                       from include/linux/time.h:5,
                       from include/linux/stat.h:18,
                       from include/linux/module.h:10,
                       from drivers/mtd/maps/dc21285.c:8:
      include/linux/spinlock.h:370:91: note: expected 'struct spinlock_t *' but argument is of type 'struct raw_spinlock_t *'
       static inline void spin_unlock_irqrestore(spinlock_t *lock, unsigned long flags)
    
    Fixes: bd31b85960a7 ("locking, ARM: Annotate low level hw locks as raw")
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit 9b35e24e866fd5456fec99277a80c4d7622941f1
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Thu May 28 10:22:10 2015 +0200

    mtd: dc21285: use raw spinlock functions for nw_gpio_lock
    
    commit e5babdf928e5d0c432a8d4b99f20421ce14d1ab6 upstream.
    
    Since commit bd31b85960a7 (which is in 3.2-rc1) nw_gpio_lock is a raw spinlock
    that needs usage of the corresponding raw functions.
    
    This fixes:
    
      drivers/mtd/maps/dc21285.c: In function 'nw_en_write':
      drivers/mtd/maps/dc21285.c:41:340: warning: passing argument 1 of 'spinlock_check' from incompatible pointer type
        spin_lock_irqsave(&nw_gpio_lock, flags);
    
      In file included from include/linux/seqlock.h:35:0,
                       from include/linux/time.h:5,
                       from include/linux/stat.h:18,
                       from include/linux/module.h:10,
                       from drivers/mtd/maps/dc21285.c:8:
      include/linux/spinlock.h:299:102: note: expected 'struct spinlock_t *' but argument is of type 'struct raw_spinlock_t *'
       static inline raw_spinlock_t *spinlock_check(spinlock_t *lock)
                                                                                                            ^
      drivers/mtd/maps/dc21285.c:43:25: warning: passing argument 1 of 'spin_unlock_irqrestore' from incompatible pointer type
        spin_unlock_irqrestore(&nw_gpio_lock, flags);
                               ^
      In file included from include/linux/seqlock.h:35:0,
                       from include/linux/time.h:5,
                       from include/linux/stat.h:18,
                       from include/linux/module.h:10,
                       from drivers/mtd/maps/dc21285.c:8:
      include/linux/spinlock.h:370:91: note: expected 'struct spinlock_t *' but argument is of type 'struct raw_spinlock_t *'
       static inline void spin_unlock_irqrestore(spinlock_t *lock, unsigned long flags)
    
    Fixes: bd31b85960a7 ("locking, ARM: Annotate low level hw locks as raw")
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 7f9e2ccd7f142ca51219fdbeb3cb04b9f665966c
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Thu May 28 10:22:10 2015 +0200

    mtd: dc21285: use raw spinlock functions for nw_gpio_lock
    
    commit e5babdf928e5d0c432a8d4b99f20421ce14d1ab6 upstream.
    
    Since commit bd31b85960a7 (which is in 3.2-rc1) nw_gpio_lock is a raw spinlock
    that needs usage of the corresponding raw functions.
    
    This fixes:
    
      drivers/mtd/maps/dc21285.c: In function 'nw_en_write':
      drivers/mtd/maps/dc21285.c:41:340: warning: passing argument 1 of 'spinlock_check' from incompatible pointer type
        spin_lock_irqsave(&nw_gpio_lock, flags);
    
      In file included from include/linux/seqlock.h:35:0,
                       from include/linux/time.h:5,
                       from include/linux/stat.h:18,
                       from include/linux/module.h:10,
                       from drivers/mtd/maps/dc21285.c:8:
      include/linux/spinlock.h:299:102: note: expected 'struct spinlock_t *' but argument is of type 'struct raw_spinlock_t *'
       static inline raw_spinlock_t *spinlock_check(spinlock_t *lock)
                                                                                                            ^
      drivers/mtd/maps/dc21285.c:43:25: warning: passing argument 1 of 'spin_unlock_irqrestore' from incompatible pointer type
        spin_unlock_irqrestore(&nw_gpio_lock, flags);
                               ^
      In file included from include/linux/seqlock.h:35:0,
                       from include/linux/time.h:5,
                       from include/linux/stat.h:18,
                       from include/linux/module.h:10,
                       from drivers/mtd/maps/dc21285.c:8:
      include/linux/spinlock.h:370:91: note: expected 'struct spinlock_t *' but argument is of type 'struct raw_spinlock_t *'
       static inline void spin_unlock_irqrestore(spinlock_t *lock, unsigned long flags)
    
    Fixes: bd31b85960a7 ("locking, ARM: Annotate low level hw locks as raw")
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit bd206d3d8439b3994e0c5aa88b30a47e962b9797
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Thu May 28 10:22:10 2015 +0200

    mtd: dc21285: use raw spinlock functions for nw_gpio_lock
    
    commit e5babdf928e5d0c432a8d4b99f20421ce14d1ab6 upstream.
    
    Since commit bd31b85960a7 (which is in 3.2-rc1) nw_gpio_lock is a raw spinlock
    that needs usage of the corresponding raw functions.
    
    This fixes:
    
      drivers/mtd/maps/dc21285.c: In function 'nw_en_write':
      drivers/mtd/maps/dc21285.c:41:340: warning: passing argument 1 of 'spinlock_check' from incompatible pointer type
        spin_lock_irqsave(&nw_gpio_lock, flags);
    
      In file included from include/linux/seqlock.h:35:0,
                       from include/linux/time.h:5,
                       from include/linux/stat.h:18,
                       from include/linux/module.h:10,
                       from drivers/mtd/maps/dc21285.c:8:
      include/linux/spinlock.h:299:102: note: expected 'struct spinlock_t *' but argument is of type 'struct raw_spinlock_t *'
       static inline raw_spinlock_t *spinlock_check(spinlock_t *lock)
                                                                                                            ^
      drivers/mtd/maps/dc21285.c:43:25: warning: passing argument 1 of 'spin_unlock_irqrestore' from incompatible pointer type
        spin_unlock_irqrestore(&nw_gpio_lock, flags);
                               ^
      In file included from include/linux/seqlock.h:35:0,
                       from include/linux/time.h:5,
                       from include/linux/stat.h:18,
                       from include/linux/module.h:10,
                       from drivers/mtd/maps/dc21285.c:8:
      include/linux/spinlock.h:370:91: note: expected 'struct spinlock_t *' but argument is of type 'struct raw_spinlock_t *'
       static inline void spin_unlock_irqrestore(spinlock_t *lock, unsigned long flags)
    
    Fixes: bd31b85960a7 ("locking, ARM: Annotate low level hw locks as raw")
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>

commit cf5a5f22560fd3ec00551760264ec22bfdb3e5ee
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Thu May 28 10:22:10 2015 +0200

    mtd: dc21285: use raw spinlock functions for nw_gpio_lock
    
    commit e5babdf928e5d0c432a8d4b99f20421ce14d1ab6 upstream.
    
    Since commit bd31b85960a7 (which is in 3.2-rc1) nw_gpio_lock is a raw spinlock
    that needs usage of the corresponding raw functions.
    
    This fixes:
    
      drivers/mtd/maps/dc21285.c: In function 'nw_en_write':
      drivers/mtd/maps/dc21285.c:41:340: warning: passing argument 1 of 'spinlock_check' from incompatible pointer type
        spin_lock_irqsave(&nw_gpio_lock, flags);
    
      In file included from include/linux/seqlock.h:35:0,
                       from include/linux/time.h:5,
                       from include/linux/stat.h:18,
                       from include/linux/module.h:10,
                       from drivers/mtd/maps/dc21285.c:8:
      include/linux/spinlock.h:299:102: note: expected 'struct spinlock_t *' but argument is of type 'struct raw_spinlock_t *'
       static inline raw_spinlock_t *spinlock_check(spinlock_t *lock)
                                                                                                            ^
      drivers/mtd/maps/dc21285.c:43:25: warning: passing argument 1 of 'spin_unlock_irqrestore' from incompatible pointer type
        spin_unlock_irqrestore(&nw_gpio_lock, flags);
                               ^
      In file included from include/linux/seqlock.h:35:0,
                       from include/linux/time.h:5,
                       from include/linux/stat.h:18,
                       from include/linux/module.h:10,
                       from drivers/mtd/maps/dc21285.c:8:
      include/linux/spinlock.h:370:91: note: expected 'struct spinlock_t *' but argument is of type 'struct raw_spinlock_t *'
       static inline void spin_unlock_irqrestore(spinlock_t *lock, unsigned long flags)
    
    Fixes: bd31b85960a7 ("locking, ARM: Annotate low level hw locks as raw")
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 4aa339cddbcc05b7f8ff4f0960550929aa77213e
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Thu May 28 10:22:10 2015 +0200

    mtd: dc21285: use raw spinlock functions for nw_gpio_lock
    
    commit e5babdf928e5d0c432a8d4b99f20421ce14d1ab6 upstream.
    
    Since commit bd31b85960a7 (which is in 3.2-rc1) nw_gpio_lock is a raw spinlock
    that needs usage of the corresponding raw functions.
    
    This fixes:
    
      drivers/mtd/maps/dc21285.c: In function 'nw_en_write':
      drivers/mtd/maps/dc21285.c:41:340: warning: passing argument 1 of 'spinlock_check' from incompatible pointer type
        spin_lock_irqsave(&nw_gpio_lock, flags);
    
      In file included from include/linux/seqlock.h:35:0,
                       from include/linux/time.h:5,
                       from include/linux/stat.h:18,
                       from include/linux/module.h:10,
                       from drivers/mtd/maps/dc21285.c:8:
      include/linux/spinlock.h:299:102: note: expected 'struct spinlock_t *' but argument is of type 'struct raw_spinlock_t *'
       static inline raw_spinlock_t *spinlock_check(spinlock_t *lock)
                                                                                                            ^
      drivers/mtd/maps/dc21285.c:43:25: warning: passing argument 1 of 'spin_unlock_irqrestore' from incompatible pointer type
        spin_unlock_irqrestore(&nw_gpio_lock, flags);
                               ^
      In file included from include/linux/seqlock.h:35:0,
                       from include/linux/time.h:5,
                       from include/linux/stat.h:18,
                       from include/linux/module.h:10,
                       from drivers/mtd/maps/dc21285.c:8:
      include/linux/spinlock.h:370:91: note: expected 'struct spinlock_t *' but argument is of type 'struct raw_spinlock_t *'
       static inline void spin_unlock_irqrestore(spinlock_t *lock, unsigned long flags)
    
    Fixes: bd31b85960a7 ("locking, ARM: Annotate low level hw locks as raw")
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit ced5ded3421844a32405d18e3f2b58d65bc12271
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Thu May 28 10:22:10 2015 +0200

    mtd: dc21285: use raw spinlock functions for nw_gpio_lock
    
    commit e5babdf928e5d0c432a8d4b99f20421ce14d1ab6 upstream.
    
    Since commit bd31b85960a7 (which is in 3.2-rc1) nw_gpio_lock is a raw spinlock
    that needs usage of the corresponding raw functions.
    
    This fixes:
    
      drivers/mtd/maps/dc21285.c: In function 'nw_en_write':
      drivers/mtd/maps/dc21285.c:41:340: warning: passing argument 1 of 'spinlock_check' from incompatible pointer type
        spin_lock_irqsave(&nw_gpio_lock, flags);
    
      In file included from include/linux/seqlock.h:35:0,
                       from include/linux/time.h:5,
                       from include/linux/stat.h:18,
                       from include/linux/module.h:10,
                       from drivers/mtd/maps/dc21285.c:8:
      include/linux/spinlock.h:299:102: note: expected 'struct spinlock_t *' but argument is of type 'struct raw_spinlock_t *'
       static inline raw_spinlock_t *spinlock_check(spinlock_t *lock)
                                                                                                            ^
      drivers/mtd/maps/dc21285.c:43:25: warning: passing argument 1 of 'spin_unlock_irqrestore' from incompatible pointer type
        spin_unlock_irqrestore(&nw_gpio_lock, flags);
                               ^
      In file included from include/linux/seqlock.h:35:0,
                       from include/linux/time.h:5,
                       from include/linux/stat.h:18,
                       from include/linux/module.h:10,
                       from drivers/mtd/maps/dc21285.c:8:
      include/linux/spinlock.h:370:91: note: expected 'struct spinlock_t *' but argument is of type 'struct raw_spinlock_t *'
       static inline void spin_unlock_irqrestore(spinlock_t *lock, unsigned long flags)
    
    Fixes: bd31b85960a7 ("locking, ARM: Annotate low level hw locks as raw")
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Signed-off-by: Luis Henriques <luis.henriques@canonical.com>

commit e5babdf928e5d0c432a8d4b99f20421ce14d1ab6
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Thu May 28 10:22:10 2015 +0200

    mtd: dc21285: use raw spinlock functions for nw_gpio_lock
    
    Since commit bd31b85960a7 (which is in 3.2-rc1) nw_gpio_lock is a raw spinlock
    that needs usage of the corresponding raw functions.
    
    This fixes:
    
      drivers/mtd/maps/dc21285.c: In function 'nw_en_write':
      drivers/mtd/maps/dc21285.c:41:340: warning: passing argument 1 of 'spinlock_check' from incompatible pointer type
        spin_lock_irqsave(&nw_gpio_lock, flags);
    
      In file included from include/linux/seqlock.h:35:0,
                       from include/linux/time.h:5,
                       from include/linux/stat.h:18,
                       from include/linux/module.h:10,
                       from drivers/mtd/maps/dc21285.c:8:
      include/linux/spinlock.h:299:102: note: expected 'struct spinlock_t *' but argument is of type 'struct raw_spinlock_t *'
       static inline raw_spinlock_t *spinlock_check(spinlock_t *lock)
                                                                                                            ^
      drivers/mtd/maps/dc21285.c:43:25: warning: passing argument 1 of 'spin_unlock_irqrestore' from incompatible pointer type
        spin_unlock_irqrestore(&nw_gpio_lock, flags);
                               ^
      In file included from include/linux/seqlock.h:35:0,
                       from include/linux/time.h:5,
                       from include/linux/stat.h:18,
                       from include/linux/module.h:10,
                       from drivers/mtd/maps/dc21285.c:8:
      include/linux/spinlock.h:370:91: note: expected 'struct spinlock_t *' but argument is of type 'struct raw_spinlock_t *'
       static inline void spin_unlock_irqrestore(spinlock_t *lock, unsigned long flags)
    
    Fixes: bd31b85960a7 ("locking, ARM: Annotate low level hw locks as raw")
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

commit e979121b1b1556e184492e6fc149bbe188fc83e6
Author: Maria Dimakopoulou <maria.n.dimakopoulou@gmail.com>
Date:   Mon Nov 17 20:06:58 2014 +0100

    perf/x86/intel: Implement cross-HT corruption bug workaround
    
    This patch implements a software workaround for a HW erratum
    on Intel SandyBridge, IvyBridge and Haswell processors
    with Hyperthreading enabled. The errata are documented for
    each processor in their respective specification update
    documents:
    
      - SandyBridge: BJ122
      - IvyBridge: BV98
      - Haswell: HSD29
    
    The bug causes silent counter corruption across hyperthreads only
    when measuring certain memory events (0xd0, 0xd1, 0xd2, 0xd3).
    Counters measuring those events may leak counts to the sibling
    counter. For instance, counter 0, thread 0 measuring event 0xd0,
    may leak to counter 0, thread 1, regardless of the event measured
    there. The size of the leak is not predictible. It all depends on
    the workload and the state of each sibling hyper-thread. The
    corrupting events do undercount as a consequence of the leak. The
    leak is compensated automatically only when the sibling counter measures
    the exact same corrupting event AND the workload is on the two threads
    is the same. Given, there is no way to guarantee this, a work-around
    is necessary. Furthermore, there is a serious problem if the leaked count
    is added to a low-occurrence event. In that case the corruption on
    the low occurrence event can be very large, e.g., orders of magnitude.
    
    There is no HW or FW workaround for this problem.
    
    The bug is very easy to reproduce on a loaded system.
    Here is an example on a Haswell client, where CPU0, CPU4
    are siblings. We load the CPUs with a simple triad app
    streaming large floating-point vector. We use 0x81d0
    corrupting event (MEM_UOPS_RETIRED:ALL_LOADS) and
    0x20cc (ROB_MISC_EVENTS:LBR_INSERTS). Given we are not
    using the LBR, the 0x20cc event should be zero.
    
      $ taskset -c 0 triad &
      $ taskset -c 4 triad &
      $ perf stat -a -C 0 -e r81d0 sleep 100 &
      $ perf stat -a -C 4 -r20cc sleep 10
      Performance counter stats for 'system wide':
            139 277 291      r20cc
           10,000969126 seconds time elapsed
    
    In this example, 0x81d0 and r20cc ar eusing sinling counters
    on CPU0 and CPU4. 0x81d0 leaks into 0x20cc and corrupts it
    from 0 to 139 millions occurrences.
    
    This patch provides a software workaround to this problem by modifying the
    way events are scheduled onto counters by the kernel. The patch forces
    cross-thread mutual exclusion between counters in case a corrupting event
    is measured by one of the hyper-threads. If thread 0, counter 0 is measuring
    event 0xd0, then nothing can be measured on counter 0, thread 1. If no corrupting
    event is measured on any hyper-thread, event scheduling proceeds as before.
    
    The same example run with the workaround enabled, yield the correct answer:
    
      $ taskset -c 0 triad &
      $ taskset -c 4 triad &
      $ perf stat -a -C 0 -e r81d0 sleep 100 &
      $ perf stat -a -C 4 -r20cc sleep 10
      Performance counter stats for 'system wide':
            0 r20cc
           10,000969126 seconds time elapsed
    
    The patch does provide correctness for all non-corrupting events. It does not
    "repatriate" the leaked counts back to the leaking counter. This is planned
    for a second patch series. This patch series makes this repatriation more
    easy by guaranteeing the sibling counter is not measuring any useful event.
    
    The patch introduces dynamic constraints for events. That means that events which
    did not have constraints, i.e., could be measured on any counters, may now be
    constrained to a subset of the counters depending on what is going on the sibling
    thread. The algorithm is similar to a cache coherency protocol. We call it XSU
    in reference to Exclusive, Shared, Unused, the 3 possible states of a PMU
    counter.
    
    As a consequence of the workaround, users may see an increased amount of event
    multiplexing, even in situtations where there are fewer events than counters
    measured on a CPU.
    
    Patch has been tested on all three impacted processors. Note that when
    HT is off, there is no corruption. However, the workaround is still enabled,
    yet not costing too much. Adding a dynamic detection of HT on turned out to
    be complex are requiring too much to code to be justified.
    
    This patch addresses the issue when PEBS is not used. A subsequent patch
    fixes the problem when PEBS is used.
    
    Signed-off-by: Maria Dimakopoulou <maria.n.dimakopoulou@gmail.com>
    [spinlock_t -> raw_spinlock_t]
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Reviewed-by: Stephane Eranian <eranian@google.com>
    Cc: bp@alien8.de
    Cc: jolsa@redhat.com
    Cc: kan.liang@intel.com
    Link: http://lkml.kernel.org/r/1416251225-17721-7-git-send-email-eranian@google.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 6f6539cad926f55d5eb6e79d05bbe99f0d54d56d
Author: Maria Dimakopoulou <maria.n.dimakopoulou@gmail.com>
Date:   Mon Nov 17 20:06:57 2014 +0100

    perf/x86/intel: Add cross-HT counter exclusion infrastructure
    
    This patch adds a new shared_regs style structure to the
    per-cpu x86 state (cpuc). It is used to coordinate access
    between counters which must be used with exclusion across
    HyperThreads on Intel processors. This new struct is not
    needed on each PMU, thus is is allocated on demand.
    
    Signed-off-by: Maria Dimakopoulou <maria.n.dimakopoulou@gmail.com>
    [peterz: spinlock_t -> raw_spinlock_t]
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Reviewed-by: Stephane Eranian <eranian@google.com>
    Cc: bp@alien8.de
    Cc: jolsa@redhat.com
    Cc: kan.liang@intel.com
    Link: http://lkml.kernel.org/r/1416251225-17721-6-git-send-email-eranian@google.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 45ef6ac6f5d4d4ea441a042fee3790b3f33cba73
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Sun Aug 5 14:59:12 2012 +0000

    ARM: footbridge: nw_gpio_lock is raw_spin_lock
    
    bd31b85960a "locking, ARM: Annotate low level hw locks as raw"
    made nw_gpio_lock a raw spinlock, but did not change all the
    users in device drivers. This fixes the remaining ones.
    
    sound/oss/waveartist.c: In function 'vnc_mute_spkr':
    sound/oss/waveartist.c:1485:2: warning: passing argument 1 of 'spinlock_check' from incompatible pointer type [enabled by default]
    include/linux/spinlock.h:272:102: note: expected 'struct spinlock_t *' but argument is of type 'struct raw_spinlock_t *'
    drivers/char/ds1620.c: In function 'netwinder_lock':
    drivers/char/ds1620.c:77:2: warning: passing argument 1 of 'spinlock_check' from incompatible pointer type [enabled by default]
    include/linux/spinlock.h:272:102: note: expected 'struct spinlock_t *' but argument is of type 'struct raw_spinlock_t *'
    drivers/char/nwflash.c: In function 'kick_open':
    drivers/char/nwflash.c:620:2: warning: passing argument 1 of 'spinlock_check' from incompatible pointer type [enabled by default]
    include/linux/spinlock.h:272:102: note: expected 'struct spinlock_t *' but argument is of type 'struct raw_spinlock_t *'
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Russell King <rmk+kernel@arm.linux.org.uk>

commit 3cfef9524677a4ecb392d6fbffe6ebce6302f1d4
Merge: 982653009b88 68cc3990a545
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Oct 26 16:17:32 2011 +0200

    Merge branch 'core-locking-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    * 'core-locking-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (27 commits)
      rtmutex: Add missing rcu_read_unlock() in debug_rt_mutex_print_deadlock()
      lockdep: Comment all warnings
      lib: atomic64: Change the type of local lock to raw_spinlock_t
      locking, lib/atomic64: Annotate atomic64_lock::lock as raw
      locking, x86, iommu: Annotate qi->q_lock as raw
      locking, x86, iommu: Annotate irq_2_ir_lock as raw
      locking, x86, iommu: Annotate iommu->register_lock as raw
      locking, dma, ipu: Annotate bank_lock as raw
      locking, ARM: Annotate low level hw locks as raw
      locking, drivers/dca: Annotate dca_lock as raw
      locking, powerpc: Annotate uic->lock as raw
      locking, x86: mce: Annotate cmci_discover_lock as raw
      locking, ACPI: Annotate c3_lock as raw
      locking, oprofile: Annotate oprofilefs lock as raw
      locking, video: Annotate vga console lock as raw
      locking, latencytop: Annotate latency_lock as raw
      locking, timer_stats: Annotate table_lock as raw
      locking, rwsem: Annotate inner lock as raw
      locking, semaphores: Annotate inner lock as raw
      locking, sched: Annotate thread_group_cputimer as raw
      ...
    
    Fix up conflicts in kernel/posix-cpu-timers.c manually: making
    cputimer->cputime a raw lock conflicted with the ABBA fix in commit
    bcd5cff7216f ("cputimer: Cure lock inversion").

commit cb475de3d12df6912bc95048202ae8c280d4cad5
Author: Yong Zhang <yong.zhang0@gmail.com>
Date:   Wed Sep 14 15:49:24 2011 +0800

    lib: atomic64: Change the type of local lock to raw_spinlock_t
    
    There are still some leftovers of commit f59ca058
    [locking, lib/atomic64: Annotate atomic64_lock::lock as raw]
    
    [ tglx: Seems I picked the wrong version of that patch :( ]
    
    Signed-off-by: Yong Zhang <yong.zhang0@gmail.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Shan Hai <haishan.bai@gmail.com>
    Cc: Stephen Rothwell <sfr@canb.auug.org.au>
    Link: http://lkml.kernel.org/r/20110914074924.GA16096@zhy
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 961ec6daa7b14f376c30d447a830fa4783a2112c
Author: Will Deacon <will@kernel.org>
Date:   Thu Dec 2 18:01:49 2010 +0100

    ARM: 6521/1: perf: use raw_spinlock_t for pmu_lock
    
    For kernels built with PREEMPT_RT, critical sections protected
    by standard spinlocks are preemptible. This is not acceptable
    on perf as (a) we may be scheduled onto a different CPU whilst
    reading/writing banked PMU registers and (b) the latency when
    reading the PMU registers becomes unpredictable.
    
    This patch upgrades the pmu_lock spinlock to a raw_spinlock
    instead.
    
    Reported-by: Jamie Iles <jamie@jamieiles.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

commit f4f510508741680e423524c222f615276ca6222c
Author: Avi Kivity <avi@redhat.com>
Date:   Sun Sep 19 18:44:07 2010 +0200

    KVM: Convert PIC lock from raw spinlock to ordinary spinlock
    
    The PIC code used to be called from preempt_disable() context, which
    wasn't very good for PREEMPT_RT.  That is no longer the case, so move
    back from raw_spinlock_t to spinlock_t.
    
    Signed-off-by: Avi Kivity <avi@redhat.com>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Marcelo Tosatti <mtosatti@redhat.com>

commit c812a51d11bbe983f4c24e32b59b265705ddd3c2
Merge: 9467c4fdd66f d2be1651b736
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Mar 5 13:12:34 2010 -0800

    Merge branch 'kvm-updates/2.6.34' of git://git.kernel.org/pub/scm/virt/kvm/kvm
    
    * 'kvm-updates/2.6.34' of git://git.kernel.org/pub/scm/virt/kvm/kvm: (145 commits)
      KVM: x86: Add KVM_CAP_X86_ROBUST_SINGLESTEP
      KVM: VMX: Update instruction length on intercepted BP
      KVM: Fix emulate_sys[call, enter, exit]()'s fault handling
      KVM: Fix segment descriptor loading
      KVM: Fix load_guest_segment_descriptor() to inject page fault
      KVM: x86 emulator: Forbid modifying CS segment register by mov instruction
      KVM: Convert kvm->requests_lock to raw_spinlock_t
      KVM: Convert i8254/i8259 locks to raw_spinlocks
      KVM: x86 emulator: disallow opcode 82 in 64-bit mode
      KVM: x86 emulator: code style cleanup
      KVM: Plan obsolescence of kernel allocated slots, paravirt mmu
      KVM: x86 emulator: Add LOCK prefix validity checking
      KVM: x86 emulator: Check CPL level during privilege instruction emulation
      KVM: x86 emulator: Fix popf emulation
      KVM: x86 emulator: Check IOPL level during io instruction emulation
      KVM: x86 emulator: fix memory access during x86 emulation
      KVM: x86 emulator: Add Virtual-8086 mode of emulation
      KVM: x86 emulator: Add group9 instruction decoding
      KVM: x86 emulator: Add group8 instruction decoding
      KVM: do not store wqh in irqfd
      ...
    
    Trivial conflicts in Documentation/feature-removal-schedule.txt

commit 70e335e16882df5b5d6971022e63c3603a1e8c23
Author: Avi Kivity <avi@redhat.com>
Date:   Thu Feb 18 11:25:22 2010 +0200

    KVM: Convert kvm->requests_lock to raw_spinlock_t
    
    The code relies on kvm->requests_lock inhibiting preemption.
    
    Noted by Jan Kiszka.
    
    Signed-off-by: Avi Kivity <avi@redhat.com>

commit 5f6384c5fb6bfc9aac506e058974d3ba293951b3
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Dec 8 16:16:41 2009 +0100

    alpha: Fix fallout from locking changes
    
    spin_* functions are mostly static inline now. That causes the alpha
    compile to fail:
    
    CC      arch/alpha/kernel/sys_sable.o
    cc1: warnings being treated as errors
    In file included from arch/alpha/kernel/sys_sable.c:25:
    arch/alpha/include/asm/core_t2.h: In function 't2_readb':
    arch/alpha/include/asm/core_t2.h:451: error: 'spinlock_check' is static but \
            used in inline function 't2_readb' which is not static
    arch/alpha/include/asm/core_t2.h:456: error: 'spin_unlock_irqrestore' is \
            static but used in inline function 't2_readb' which is not static
    
    That's caused by the "extern inline" magic which is used for the
    subarch specific read/write[bwl] functions. I tried to distangle the
    uncountable macro onion layers, but failed miserably.
    
    Last resort solution: switch the t2_hae_lock to raw_spinlock_t so the
    lock functions are pure macros and function calls again.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Peter Zijlstra <peterz@infradead.org>
    Acked-by: Ingo Molnar <mingo@elte.hu>
    Cc: Richard Henderson <rth@twiddle.net>
    Cc: linux-alpha@vger.kernel.org

commit 94cd3e6cbebf85903b4d53ed2147bdb4c6e08625
Author: Eric Dumazet <dada1@cosmosbay.com>
Date:   Tue Jan 27 17:45:10 2009 -0800

    net: wrong test in inet_ehash_locks_alloc()
    
    In commit 9db66bdcc83749affe61c61eb8ff3cf08f42afec (net: convert
    TCP/DCCP ehash rwlocks to spinlocks), I forgot to change one
    occurrence of rwlock_t to spinlock_t
    
    I believe sizeof(raw_spinlock_t) might be > 0 on !CONFIG_SMP if
    CONFIG_DEBUG_SPINLOCK while sizeof(raw_rwlock_t) should be 0 in this
    case.
    
    Fortunatly, CONFIG_DEBUG_SPINLOCK adds fields to both spinlock_t and
    rwlock_t, but at this might change in the future (being able to debug
    spinlocks but not rwlocks for example), better to be safe.
    
    Signed-off-by: Eric Dumazet <dada1@cosmosbay.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 087052b02f42b50316c6e4d7f2d8dfba3de6fc2e
Author: Ingo Molnar <mingo@elte.hu>
Date:   Fri Oct 17 16:09:57 2008 +0200

    x86: fix default_spin_lock_flags() prototype
    
    these warnings:
    
      arch/x86/kernel/paravirt-spinlocks.c: In function ‘default_spin_lock_flags’:
      arch/x86/kernel/paravirt-spinlocks.c:12: warning: passing argument 1 of ‘__raw_spin_lock’ from incompatible pointer type
      arch/x86/kernel/paravirt-spinlocks.c: At top level:
      arch/x86/kernel/paravirt-spinlocks.c:11: warning: ‘default_spin_lock_flags’ defined but not used
    
    showed that the prototype of default_spin_lock_flags() was confused about
    what type spinlocks have.
    
    the proper type on UP is raw_spinlock_t.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

commit c60ff51eb26dfcfb0bdc807b09a096aeadd01325
Author: Xiantao Zhang <xiantao.zhang@intel.com>
Date:   Sat Nov 8 15:46:59 2008 +0800

    KVM: ia64: fix vmm_spin_{un}lock for !CONFIG_SMP
    
    In the case of !CONFIG_SMP, raw_spinlock_t is empty and the spinlock functions
    don't build.  Fix by defining spinlock functions for the uniprocessor case.
    
    Signed-off-by: Xiantao Zhang <xiantao.zhang@intel.com>
    Signed-off-by: Avi Kivity <avi@redhat.com>

commit 3b4beb31759765efdda9f9431aebfedf828bbfe0
Author: Heiko Carstens <hca@linux.ibm.com>
Date:   Sat Jan 26 14:11:03 2008 +0100

    [S390] Remove owner_pc member from raw_spinlock_t.
    
    Used to contain the address of the holder of the lock. But since the
    spinlock code is not inlined anymore all locks contain the same address
    anyway. And since in addtition nobody complained about that for ages
    its obviously unused. So remove it.
    
    Signed-off-by: Heiko Carstens <heiko.carstens@de.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

commit 21f8ca3bf6198bd21e3c4cc820af2ccf753a6ec8
Author: Peter Zijlstra <a.p.zijlstra@chello.nl>
Date:   Thu Jul 19 01:48:53 2007 -0700

    fix raw_spinlock_t vs lockdep
    
    Use the lockdep infrastructure to track lock contention and other lock
    statistics.
    
    It tracks lock contention events, and the first four unique call-sites that
    encountered contention.
    
    It also measures lock wait-time and hold-time in nanoseconds. The minimum and
    maximum times are tracked, as well as a total (which together with the number
    of event can give the avg).
    
    All statistics are done per lock class, per write (exclusive state) and per read
    (shared state).
    
    The statistics are collected per-cpu, so that the collection overhead is
    minimized via having no global cachemisses.
    
    This new lock statistics feature is independent of the lock dependency checking
    traditionally done by lockdep; it just shares the lock tracking code. It is
    also possible to enable both and runtime disabled either component - thereby
    avoiding the O(n^2) lock chain walks for instance.
    
    This patch:
    
    raw_spinlock_t should not use lockdep (and doesn't) since lockdep itself
    relies on it.
    
    Signed-off-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Acked-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit 57468af3267bfb89391f9c607a9637e86e55d299
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Mon Oct 3 13:40:26 2005 +0100

    Define and initialize kdb_lock using DEFINE_SPINLOCK.
    Convert kgdb_cpulock into a raw_spinlock_t.
    
    SPIN_LOCK_UNLOCKED is deprecated and it's replacement DEFINE_SPINLOCK is
    not suitable for arrays of spinlocks.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

commit 3efc333e7fdb6fab9d4eae129e2b249c6483b250
Author: Kumar Gala <galak@freescale.com>
Date:   Thu Sep 22 10:13:31 2005 -0500

    [PATCH] powerpc: Fix building of power3 config on ppc32
    
    The spinlock_types.h merge renamed the structure for raw_spinlock_t to
    match ppc64.  In doing so some of the spinlock macros/functions needed to
    be updated to match.  Apparently, this seems to only be caught when
    building power3.
    
    Signed-off-by: Kumar Gala <kumar.gala@freescale.com>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

commit fb1c8f93d869b34cacb8b8932e2b83d96a19d720
Author: Ingo Molnar <mingo@elte.hu>
Date:   Sat Sep 10 00:25:56 2005 -0700

    [PATCH] spinlock consolidation
    
    This patch (written by me and also containing many suggestions of Arjan van
    de Ven) does a major cleanup of the spinlock code.  It does the following
    things:
    
     - consolidates and enhances the spinlock/rwlock debugging code
    
     - simplifies the asm/spinlock.h files
    
     - encapsulates the raw spinlock type and moves generic spinlock
       features (such as ->break_lock) into the generic code.
    
     - cleans up the spinlock code hierarchy to get rid of the spaghetti.
    
    Most notably there's now only a single variant of the debugging code,
    located in lib/spinlock_debug.c.  (previously we had one SMP debugging
    variant per architecture, plus a separate generic one for UP builds)
    
    Also, i've enhanced the rwlock debugging facility, it will now track
    write-owners.  There is new spinlock-owner/CPU-tracking on SMP builds too.
    All locks have lockup detection now, which will work for both soft and hard
    spin/rwlock lockups.
    
    The arch-level include files now only contain the minimally necessary
    subset of the spinlock code - all the rest that can be generalized now
    lives in the generic headers:
    
     include/asm-i386/spinlock_types.h       |   16
     include/asm-x86_64/spinlock_types.h     |   16
    
    I have also split up the various spinlock variants into separate files,
    making it easier to see which does what. The new layout is:
    
       SMP                         |  UP
       ----------------------------|-----------------------------------
       asm/spinlock_types_smp.h    |  linux/spinlock_types_up.h
       linux/spinlock_types.h      |  linux/spinlock_types.h
       asm/spinlock_smp.h          |  linux/spinlock_up.h
       linux/spinlock_api_smp.h    |  linux/spinlock_api_up.h
       linux/spinlock.h            |  linux/spinlock.h
    
    /*
     * here's the role of the various spinlock/rwlock related include files:
     *
     * on SMP builds:
     *
     *  asm/spinlock_types.h: contains the raw_spinlock_t/raw_rwlock_t and the
     *                        initializers
     *
     *  linux/spinlock_types.h:
     *                        defines the generic type and initializers
     *
     *  asm/spinlock.h:       contains the __raw_spin_*()/etc. lowlevel
     *                        implementations, mostly inline assembly code
     *
     *   (also included on UP-debug builds:)
     *
     *  linux/spinlock_api_smp.h:
     *                        contains the prototypes for the _spin_*() APIs.
     *
     *  linux/spinlock.h:     builds the final spin_*() APIs.
     *
     * on UP builds:
     *
     *  linux/spinlock_type_up.h:
     *                        contains the generic, simplified UP spinlock type.
     *                        (which is an empty structure on non-debug builds)
     *
     *  linux/spinlock_types.h:
     *                        defines the generic type and initializers
     *
     *  linux/spinlock_up.h:
     *                        contains the __raw_spin_*()/etc. version of UP
     *                        builds. (which are NOPs on non-debug, non-preempt
     *                        builds)
     *
     *   (included on UP-non-debug builds:)
     *
     *  linux/spinlock_api_up.h:
     *                        builds the _spin_*() APIs.
     *
     *  linux/spinlock.h:     builds the final spin_*() APIs.
     */
    
    All SMP and UP architectures are converted by this patch.
    
    arm, i386, ia64, ppc, ppc64, s390/s390x, x64 was build-tested via
    crosscompilers.  m32r, mips, sh, sparc, have not been tested yet, but should
    be mostly fine.
    
    From: Grant Grundler <grundler@parisc-linux.org>
    
      Booted and lightly tested on a500-44 (64-bit, SMP kernel, dual CPU).
      Builds 32-bit SMP kernel (not booted or tested).  I did not try to build
      non-SMP kernels.  That should be trivial to fix up later if necessary.
    
      I converted bit ops atomic_hash lock to raw_spinlock_t.  Doing so avoids
      some ugly nesting of linux/*.h and asm/*.h files.  Those particular locks
      are well tested and contained entirely inside arch specific code.  I do NOT
      expect any new issues to arise with them.
    
     If someone does ever need to use debug/metrics with them, then they will
      need to unravel this hairball between spinlocks, atomic ops, and bit ops
      that exist only because parisc has exactly one atomic instruction: LDCW
      (load and clear word).
    
    From: "Luck, Tony" <tony.luck@intel.com>
    
       ia64 fix
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Arjan van de Ven <arjanv@infradead.org>
    Signed-off-by: Grant Grundler <grundler@parisc-linux.org>
    Cc: Matthew Wilcox <willy@debian.org>
    Signed-off-by: Hirokazu Takata <takata@linux-m32r.org>
    Signed-off-by: Mikael Pettersson <mikpe@csd.uu.se>
    Signed-off-by: Benoit Boissinot <benoit.boissinot@ens-lyon.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>
